uint64_t tagCompare(int **a1, int **a2)
{
  int *v2;
  int v3;
  int v4;
  uint64_t result;
  int v6;

  v2 = *a1;
  v3 = **a1;
  v4 = **a2;
  result = (v3 - v4);
  if (v3 == v4)
  {
    v6 = v2[2];
    if (v6)
      return ((*a2)[2] - v6);
    else
      return 0;
  }
  return result;
}

uint64_t CGImageMetadataTagKeyHash(const void **a1)
{
  const void *v2;

  if (!a1)
    return -1;
  v2 = *a1;
  if (!v2 || !a1[1])
    return -1;
  CFHash(v2);
  CFHash(a1[1]);
  return os_simple_hash();
}

void CGImageMetadataTagKeyReleaseCallback(int a1, _QWORD *a2)
{
  CGImageMetadataTagKeyRelease(a2);
}

uint64_t imageio_key_hash(void *a1, void *a2)
{
  return os_simple_hash();
}

void ___ZN13PNGReadPlugin19DecodeFrameStandardEP19IIOImageReadSessionRK14ReadPluginDataRK13PNGPluginDataR20IIODecodeFrameParams_block_invoke(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  unsigned int *v9;
  unsigned int *v10;
  IIOImageReadSession *v11;
  int appleflags;
  uint64_t v13;
  int v14;
  unsigned int v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  unsigned int v20;
  int v21;
  int v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  int v26;
  int v27;
  uint64_t v28;
  int v29;
  int v30;
  uint64_t v31;
  int chunk_header;
  size_t rowbytes;
  int v34;
  size_t v35;
  char *v36;
  unint64_t v37;
  uint64_t v38;
  unsigned int *v39;
  unsigned int v40;
  _DWORD *exception;
  IIOImageReadSession *v42;
  uint64_t v43;
  uint64_t v44;
  _OWORD v45[5];
  unsigned int *v46;
  _QWORD *v47;

  v46 = 0;
  v47 = 0;
  v4 = *(_QWORD *)(a1[7] + 48);
  v5 = v4 + 12 * a2;
  memset(v45, 0, sizeof(v45));
  v6 = *(unsigned int *)(v5 + 4);
  v7 = *(unsigned int *)(v5 + 8);
  v8 = _cg_png_create_read_struct("1.6.43", 0, (uint64_t)handle_error_idot, (uint64_t)handle_warning);
  v47 = v8;
  _cg_png_create_info_struct((uint64_t)v8);
  v10 = v9;
  v46 = v9;
  _cg_png_set_option((uint64_t)v8, 2u, 3);
  _cg_png_set_benign_errors((uint64_t)v8, 1);
  v11 = (IIOImageReadSession *)a1[8];
  v43 = 0;
  v44 = 0;
  v42 = v11;
  _cg_png_set_read_fn(v8, (uint64_t)&v42, (size_t (*)(size_t, void *, size_t))read_fn2);
  _cg_png_set_keep_unknown_chunks_sized((uint64_t)v8, 3u, "CgBI", 4);
  appleflags = _cg_png_get_appleflags((uint64_t)v8);
  _cg_png_set_appleflags((uint64_t)v8, appleflags | 0xC);
  _cg_png_set_read_user_chunk_fn((uint64_t)v8, (uint64_t)v45, (uint64_t)PNGReadPlugin::Read_user_chunk_callback2);
  _cg_png_read_info((uLong)v8, v10);
  if (*(_BYTE *)(a1[9] + 63) == 1)
    _cg_png_set_swap((uint64_t)v8);
  if (*(_BYTE *)(a1[7] + 27))
  {
    _cg_png_set_add_alpha((uint64_t)v8, 255, 1);
    if ((gIIODebugFlags & 0x20000) != 0)
    {
      v13 = a1[9];
      v14 = *(_DWORD *)(v13 + 20);
      v15 = v14 >> 24;
      v16 = MEMORY[0x1E0C80978];
      if (v14 < 0)
      {
        v17 = __maskrune(v15, 0x40000uLL);
        v13 = a1[9];
      }
      else
      {
        v17 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v15 + 60) & 0x40000;
      }
      v18 = *(_DWORD *)(v13 + 20);
      if (v17)
        v19 = (v18 >> 24);
      else
        v19 = 46;
      v20 = v18 << 8 >> 24;
      if (v18 << 8 < 0)
      {
        v21 = __maskrune(v20, 0x40000uLL);
        v13 = a1[9];
      }
      else
      {
        v21 = *(_DWORD *)(v16 + 4 * v20 + 60) & 0x40000;
      }
      v22 = *(_DWORD *)(v13 + 20);
      if (v21)
        v23 = (v22 << 8 >> 24);
      else
        v23 = 46;
      v24 = (__int16)v22 >> 8;
      if (v22 << 16 < 0)
      {
        v26 = __maskrune(v24, 0x40000uLL);
        v25 = v16;
        v13 = a1[9];
      }
      else
      {
        v25 = v16;
        v26 = *(_DWORD *)(v16 + 4 * v24 + 60) & 0x40000;
      }
      v27 = *(_DWORD *)(v13 + 20);
      if (v26)
        v28 = ((__int16)v27 >> 8);
      else
        v28 = 46;
      if ((v27 << 24) <= 0x7F000000)
      {
        if ((*(_DWORD *)(v25 + 4 * (char)v27 + 60) & 0x40000) != 0)
          goto LABEL_25;
      }
      else if (__maskrune((char)v27, 0x40000uLL))
      {
LABEL_25:
        v29 = *(_DWORD *)(a1[9] + 20);
LABEL_28:
        ImageIOLog("♦️  '%c%c%c%c' %d: png_set_add_alpha: PNG_FILLER_AFTER\n", v19, v23, v28, (char)v29, 4274);
        goto LABEL_29;
      }
      LOBYTE(v29) = 46;
      goto LABEL_28;
    }
  }
LABEL_29:
  if (a2)
  {
    v30 = _cg_png_get_appleflags((uint64_t)v8);
    _cg_png_set_appleflags((uint64_t)v8, v30 | 0x10);
  }
  if (*(_BYTE *)(a1[7] + 28) && _cg_png_get_valid((uint64_t)v8, (uint64_t)v10, 0x10u))
  {
    _cg_png_set_palette_to_rgb((uint64_t)v8);
    _cg_png_read_update_info((uint64_t)v8, v10);
  }
  v31 = (*(_DWORD *)(v4 + 12 * a2 + 12) - 4);
  v43 = v31;
  v44 = 0;
  IIOImageReadSession::willNeed((IIOImageRead **)v42, v31, 0x10000uLL);
  v44 = v31 + 0x10000;
  _cg_png_set_row_number((uint64_t)v8, v6);
  chunk_header = _cg_png_read_chunk_header((uLong)v8);
  _cg_png_set_idat_size((uint64_t)v8, chunk_header);
  _cg_png_read_update_info((uint64_t)v8, v10);
  rowbytes = _cg_png_get_rowbytes((uint64_t)v8, (uint64_t)v10);
  v34 = rowbytes;
  if (rowbytes >= *(unsigned int *)(a1[9] + 116))
    v35 = *(unsigned int *)(a1[9] + 116);
  else
    v35 = rowbytes;
  v36 = (char *)malloc_type_malloc(rowbytes, 0x8AF7BE66uLL);
  if (!v36)
  {
    exception = __cxa_allocate_exception(4uLL);
    *exception = -1;
    __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
  }
  if ((_DWORD)v7)
  {
    v37 = v7 + v6;
    do
    {
      _cg_png_read_row_sized((uLong)v8, v36, v34, 0);
      memmove((void *)(a1[10] + v6 * *(unsigned int *)(a1[9] + 116)), v36, v35);
      if (a2)
        v38 = a1[5];
      else
        v38 = a1[4];
      v39 = (unsigned int *)(*(_QWORD *)(v38 + 8) + 24);
      do
        v40 = __ldxr(v39);
      while (__stxr(v40 + 1, v39));
      ++v6;
    }
    while (v6 < v37);
  }
  _cg_png_destroy_read_struct((uint64_t *)&v47, (void **)&v46, 0);
  v46 = 0;
  v47 = 0;
  free(v36);
}

void sub_187E35CB8(void *a1)
{
  uint64_t v1;
  uint64_t v2;

  __cxa_begin_catch(a1);
  imagePNG_error_break(*(_QWORD *)(v2 - 96));
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v1 + 48) + 8) + 24) = -50;
  __cxa_end_catch();
  JUMPOUT(0x187E35C54);
}

void sub_187E35CF4(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void png_read_row_indexed(uLong a1, char *a2, char *__dst)
{
  unint64_t v6;
  unint64_t v7;
  unsigned __int16 v8;
  _BYTE *v9;
  int v10;
  uint64_t v11;
  uint8x8_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  _BYTE *v18;
  char v19;
  unsigned __int16 *v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  const char *v25;
  int v26;
  char *v27;
  char *v28;
  int v29;
  unsigned int v30;
  void (*v31)(uLong, _QWORD, _QWORD);
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;

  if (a1)
  {
    if ((*(_BYTE *)(a1 + 80) & 0x40) == 0)
      png_read_start_row(a1);
    v32 = 0;
    v33 = 0;
    LODWORD(v32) = *(_DWORD *)(a1 + 304);
    v6 = *(unsigned __int8 *)(a1 + 394);
    if (v6 >= 8)
      v7 = (v6 >> 3) * (unint64_t)v32;
    else
      v7 = (*(unsigned __int8 *)(a1 + 394) * (unint64_t)v32 + 7) >> 3;
    v8 = *(_WORD *)(a1 + 391);
    v33 = v7;
    v34 = v8;
    BYTE2(v34) = *(_BYTE *)(a1 + 395);
    BYTE3(v34) = v6;
    if (!*(_BYTE *)(a1 + 388) || (*(_BYTE *)(a1 + 88) & 2) == 0)
    {
LABEL_9:
      if ((*(_BYTE *)(a1 + 76) & 4) == 0)
      {
        v25 = "Invalid attempt to read row data";
        goto LABEL_96;
      }
      if ((*(_BYTE *)(a1 + 84) & 1) != 0)
      {
        png_read_IDAT_dataApple(a1);
      }
      else
      {
        **(_BYTE **)(a1 + 328) = -1;
        v7 = v33;
        png_read_IDAT_data(a1, *(_QWORD *)(a1 + 328));
      }
      BYTE4(v34) = 0;
      v9 = *(_BYTE **)(a1 + 328);
      v10 = *v9;
      if (!*v9)
        goto LABEL_22;
      if (!*(_QWORD *)(a1 + 968))
        png_init_filter_functions(a1);
      if ((*(_BYTE *)(a1 + 81) & 8) != 0 && (*(_BYTE *)(a1 + 84) & 2) != 0)
      {
        v11 = (uint64_t)a2;
        BYTE4(v34) = *(_QWORD *)(a1 + 968) == (_QWORD)png_read_filter_row_sub_apple_neon;
        if (BYTE4(v34))
          goto LABEL_20;
      }
      else
      {
        BYTE4(v34) = 0;
      }
      v11 = *(_QWORD *)(a1 + 320) + 1;
LABEL_20:
      png_read_filter_row(a1, (uint64_t)&v32, *(_QWORD *)(a1 + 328) + 1, v11, v10);
      if (BYTE4(v34))
      {
LABEL_23:
        if ((*(_BYTE *)(a1 + 760) & 4) == 0 || *(_BYTE *)(a1 + 764) != 64 || (v34 & 2) == 0)
          goto LABEL_70;
        v13 = *(_QWORD *)(a1 + 328);
        v14 = v32;
        if (BYTE1(v34) != 16)
        {
          if (BYTE1(v34) == 8)
          {
            if (v34 == 2)
            {
              v15 = 3;
LABEL_62:
              if ((_DWORD)v32)
              {
                v18 = (_BYTE *)(v13 + 3);
                do
                {
                  v19 = *(v18 - 1);
                  *(v18 - 2) += v19;
                  *v18 += v19;
                  v18 += v15;
                  --v14;
                }
                while (v14);
              }
              goto LABEL_70;
            }
            if (v34 == 6)
            {
              v15 = 4;
              goto LABEL_62;
            }
          }
LABEL_70:
          if (*(_DWORD *)(a1 + 88) || (*(_DWORD *)(a1 + 380) & 0x80000000) == 0)
            png_do_read_transformations(a1, (unsigned int *)&v32, v12);
          v24 = BYTE3(v34);
          if (*(_BYTE *)(a1 + 399))
          {
            if (*(unsigned __int8 *)(a1 + 399) != BYTE3(v34))
            {
              v25 = "internal sequential row size calculation error";
              goto LABEL_96;
            }
LABEL_77:
            if (*(_BYTE *)(a1 + 388) && (v26 = *(_DWORD *)(a1 + 88), (v26 & 2) != 0))
            {
              v30 = *(unsigned __int8 *)(a1 + 389);
              if (v30 <= 5)
                png_do_read_interlace((uint64_t)&v32, *(_QWORD *)(a1 + 328) + 1, v30, v26);
              if (__dst)
                png_combine_row((char *)a1, __dst, 1);
              if (!a2)
                goto LABEL_91;
              v27 = (char *)a1;
              v28 = a2;
              v29 = 0;
            }
            else
            {
              if (a2 && !BYTE4(v34))
                png_combine_row((char *)a1, a2, -1);
              if (!__dst)
                goto LABEL_91;
              v27 = (char *)a1;
              v28 = __dst;
              v29 = -1;
            }
            png_combine_row(v27, v28, v29);
LABEL_91:
            png_read_finish_row(a1);
            v31 = *(void (**)(uLong, _QWORD, _QWORD))(a1 + 544);
            if (v31)
              v31(a1, *(unsigned int *)(a1 + 308), *(unsigned __int8 *)(a1 + 389));
            return;
          }
          *(_BYTE *)(a1 + 399) = BYTE3(v34);
          if (v24 <= *(unsigned __int8 *)(a1 + 398))
            goto LABEL_77;
          v25 = "sequential row overflow";
LABEL_96:
          _cg_png_error((void (**)(void))a1, v25);
        }
        if (v34 == 2)
        {
          v17 = 6;
        }
        else
        {
          if (v34 != 6)
            goto LABEL_70;
          v17 = 8;
        }
        if ((_DWORD)v32)
        {
          v20 = (unsigned __int16 *)(v13 + 3);
          do
          {
            v21 = *v20;
            v22 = __rev16(v21) + (bswap32(*(v20 - 1)) >> 16);
            v23 = __rev16(v20[1]) + (bswap32(v21) >> 16);
            *((_BYTE *)v20 - 2) = BYTE1(v22);
            *((_BYTE *)v20 - 1) = v22;
            *((_BYTE *)v20 + 2) = BYTE1(v23);
            *((_BYTE *)v20 + 3) = v23;
            v20 = (unsigned __int16 *)((char *)v20 + v17);
            --v14;
          }
          while (v14);
        }
        goto LABEL_70;
      }
      v9 = *(_BYTE **)(a1 + 328);
      v7 = v33;
LABEL_22:
      memcpy(*(void **)(a1 + 320), v9, v7 + 1);
      goto LABEL_23;
    }
    v16 = *(_DWORD *)(a1 + 308);
    switch(*(_BYTE *)(a1 + 389))
    {
      case 0:
        if ((v16 & 7) == 0)
          goto LABEL_9;
        goto LABEL_55;
      case 1:
        if ((v16 & 7) != 0 || *(_DWORD *)(a1 + 280) <= 4u)
          goto LABEL_55;
        goto LABEL_9;
      case 2:
        if ((*(_DWORD *)(a1 + 308) & 7) == 4)
          goto LABEL_9;
        if (!__dst || (v16 & 4) == 0)
          goto LABEL_57;
        goto LABEL_56;
      case 3:
        if ((v16 & 3) != 0 || *(_DWORD *)(a1 + 280) <= 2u)
          goto LABEL_55;
        goto LABEL_9;
      case 4:
        if ((*(_DWORD *)(a1 + 308) & 3) == 2)
          goto LABEL_9;
        if (!__dst || (v16 & 2) == 0)
          goto LABEL_57;
        goto LABEL_56;
      case 5:
        if ((v16 & 1) == 0 && *(_DWORD *)(a1 + 280) > 1u)
          goto LABEL_9;
LABEL_55:
        if (__dst)
LABEL_56:
          png_combine_row((char *)a1, __dst, 1);
LABEL_57:
        png_read_finish_row(a1);
        break;
      default:
        if ((v16 & 1) == 0)
          goto LABEL_57;
        goto LABEL_9;
    }
  }
}

void png_read_finish_row(uint64_t a1)
{
  unsigned int v1;
  unsigned __int8 v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;

  v1 = *(_DWORD *)(a1 + 308) + 1;
  *(_DWORD *)(a1 + 308) = v1;
  if (v1 >= *(_DWORD *)(a1 + 288))
  {
    if (*(_BYTE *)(a1 + 388))
    {
      *(_DWORD *)(a1 + 308) = 0;
      bzero(*(void **)(a1 + 320), *(_QWORD *)(a1 + 296) + 1);
      v3 = *(_BYTE *)(a1 + 389);
      while (++v3 <= 6u)
      {
        v4 = png_read_start_row_png_pass_inc[v3];
        v5 = *(_DWORD *)(a1 + 280) + v4 + ~png_read_start_row_png_pass_start[v3];
        *(_DWORD *)(a1 + 304) = v5 / v4;
        if ((*(_BYTE *)(a1 + 88) & 2) == 0)
        {
          v6 = png_read_finish_row_png_pass_yinc[v3];
          v7 = *(_DWORD *)(a1 + 284) + v6 + ~png_read_finish_row_png_pass_ystart[v3];
          *(_DWORD *)(a1 + 288) = v7 / v6;
          if (v7 < v6 || v5 < v4)
            continue;
        }
        *(_BYTE *)(a1 + 389) = v3;
        return;
      }
      *(_BYTE *)(a1 + 389) = v3;
    }
    if ((*(_BYTE *)(a1 + 84) & 1) != 0)
      *(_DWORD *)(a1 + 80) |= 8u;
    png_read_finish_IDAT(a1);
  }
}

void _cg_png_read_row_sized(uLong a1, char *a2, int a3, char *__dst)
{
  png_read_row_indexed(a1, a2, __dst);
}

char *png_combine_row(char *result, char *__dst, int a3)
{
  unint64_t v3;
  _BYTE *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  char *v10;
  unint64_t v11;
  unint64_t v12;
  char v13;
  unint64_t v14;
  char *v15;
  char v16;
  unsigned int v17;
  int v18;
  char v19;
  int v20;
  int v21;
  size_t v22;
  unsigned int v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  char *v28;
  int v29;
  char v30;
  BOOL v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  char *v35;
  unint64_t v36;
  size_t v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _BYTE *v41;
  _BYTE *v42;
  uint64_t v43;
  unsigned int v44;
  uint64_t v45;
  uint64_t v46;
  _WORD *v47;
  char *v48;
  size_t v49;
  __int16 v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unsigned int v54;
  unint64_t v55;
  uint64_t v56;
  uint64_t v57;
  _DWORD *v58;
  char *v59;
  size_t v60;
  int v61;
  uint64_t v62;
  uint64_t v63;

  v3 = result[399];
  if (!result[399])
    _cg_png_error((void (**)(void))result, "internal row logic error");
  v4 = __dst;
  v5 = *((_QWORD *)result + 41);
  v6 = *((unsigned int *)result + 70);
  v7 = result[389];
  v8 = *((_QWORD *)result + 44);
  if (v8)
  {
    v9 = (v6 * (unint64_t)result[399] + 7) >> 3;
    if (v3 >= 8)
      v9 = v6 * (unint64_t)(v3 >> 3);
    if (v8 != v9)
      _cg_png_error((void (**)(void))result, "internal row size calculation error");
  }
  if (!(_DWORD)v6)
    _cg_png_error((void (**)(void))result, "internal row width error");
  v10 = (char *)(v5 + 1);
  v11 = v6 * (unint64_t)result[399];
  v12 = v3 >> 3;
  v13 = v11 & 7;
  if ((v11 & 7) != 0)
  {
    v14 = v12 * (unint64_t)v6;
    if (v3 <= 7)
      v14 = (v11 + 7) >> 3;
    v15 = &__dst[v14 - 1];
    v16 = *v15;
    v17 = 0xFFu >> v13;
    v18 = 255 << v13;
    if ((result[90] & 1) != 0)
      v19 = v18;
    else
      v19 = v17;
  }
  else
  {
    v15 = 0;
    v16 = 0;
    v19 = 0;
  }
  if (!result[388])
    goto LABEL_21;
  v20 = *((_DWORD *)result + 22);
  if ((v20 & 2) == 0 || v7 > 5)
    goto LABEL_21;
  if (a3 != 1)
  {
    if (!a3)
    {
      v21 = v7 & 1;
      goto LABEL_29;
    }
LABEL_21:
    if (v3 <= 7)
      v22 = (v11 + 7) >> 3;
    else
      v22 = v12 * (unint64_t)v6;
    result = (char *)memcpy(__dst, v10, v22);
LABEL_25:
    if (v15)
      *v15 = *v15 & ~v19 | v19 & v16;
    return result;
  }
  if ((v7 & 1) == 0)
    goto LABEL_21;
  v21 = 1;
LABEL_29:
  v23 = (v21 << (3 - ((v7 + 1) >> 1))) & 7;
  if (v6 <= v23)
    return result;
  if (v3 <= 7)
  {
    v24 = 8 / v3;
    v25 = 1;
    if ((_DWORD)v3 != 2)
      v25 = 2;
    if ((_DWORD)v3 == 1)
      v26 = 0;
    else
      v26 = v25;
    v27 = (char *)&png_combine_row_row_mask + 24 * v26 + 4 * v7 + 72;
    if (a3)
      v27 = (char *)&png_combine_row_display_mask + 12 * v26 + ((2 * (int)v7) & 0x1FCLL) + 36;
    v28 = (char *)&png_combine_row_display_mask + 12 * v26 + ((2 * (int)v7) & 0x1FCLL);
    if (!a3)
      v28 = (char *)&png_combine_row_row_mask + 24 * v26 + 4 * result[389];
    if ((v20 & 0x10000) == 0)
      v28 = v27;
    v29 = *(_DWORD *)v28;
    while (1)
    {
      if ((_BYTE)v29)
      {
        if (v29 == 255)
          v30 = *v10;
        else
          v30 = v29 & *v10 | *v4 & ~(_BYTE)v29;
        *v4 = v30;
      }
      v31 = v6 > v24;
      v6 -= v24;
      if (!v31)
        break;
      HIDWORD(v32) = v29;
      LODWORD(v32) = v29;
      v29 = v32 >> 8;
      ++v4;
      ++v10;
    }
    goto LABEL_25;
  }
  if ((v3 & 7) != 0)
    _cg_png_error((void (**)(void))result, "invalid user transform pixel depth");
  v33 = v23 * v12;
  v34 = v6 * (unint64_t)v12 - v33;
  result = &__dst[v33];
  v35 = &v10[v33];
  v36 = ((_DWORD)v12 << ((6 - v7) >> 1));
  if (v34 < v36)
    LODWORD(v36) = v6 * v12 - v33;
  if (a3)
    v37 = v36;
  else
    v37 = v12;
  v38 = ((_DWORD)v12 << ((7 - v7) >> 1));
  switch((_DWORD)v37)
  {
    case 1:
      *result = *v35;
      if (v34 > v38)
      {
        v43 = v38 + v33;
        do
        {
          v34 -= v38;
          v4[v43] = v10[v43];
          v43 += v38;
        }
        while (v34 > v38);
      }
      break;
    case 2:
      while (1)
      {
        v42 = &v4[v33];
        *v42 = *(_BYTE *)(v5 + v33 + 1);
        v42[1] = *(_BYTE *)(v5 + v33 + 2);
        v31 = v34 > v38;
        v34 -= v38;
        if (!v31)
          break;
        v33 += v38;
        if (v34 <= 1)
        {
          v4[v33] = *(_BYTE *)(v5 + v33 + 1);
          return result;
        }
      }
      break;
    case 3:
      *result = *v35;
      result[1] = v35[1];
      result[2] = v35[2];
      if (v34 > v38)
      {
        v39 = v5 + 3;
        v40 = v38 + v33;
        do
        {
          v41 = &v4[v40];
          v34 -= v38;
          *v41 = *(_BYTE *)(v39 + v40 - 2);
          v41[1] = *(_BYTE *)(v39 + v40 - 1);
          v41[2] = *(_BYTE *)(v39 + v40);
          v40 += v38;
        }
        while (v34 > v38);
      }
      break;
    default:
      if (v37 > 0xF
        || (result & 1) != 0
        || (v35 & 1) != 0
        || (v37 & 1) != 0
        || (v38 & 1) != 0)
      {
        result = (char *)memcpy(result, v35, v37);
        if (v34 > v38)
        {
          v53 = v38 + v33;
          v54 = v6 * v12 - v33 - v38;
          do
          {
            v55 = v34 - v38;
            if (v34 - v38 >= v37)
              v37 = v37;
            else
              v37 = v54;
            result = (char *)memcpy(&v4[v53], &v10[v53], v37);
            v53 += v38;
            v54 -= v38;
            v34 -= v38;
          }
          while (v55 > v38);
        }
      }
      else
      {
        v44 = v38 - v37;
        if ((((v35 | v38) | (result | v37)) & 3) != 0)
        {
          v45 = v44 >> 1;
          v46 = v45;
          while (1)
          {
            v47 = result;
            v48 = v35;
            v49 = v37;
            do
            {
              v50 = *(_WORD *)v48;
              v48 += 2;
              *v47++ = v50;
              v49 -= 2;
            }
            while (v49);
            v31 = v34 > v38;
            v34 -= v38;
            if (!v31)
              break;
            v35 = &v48[v46 * 2];
            result = (char *)&v47[v46];
            if (v34 < v37)
            {
              v51 = 0;
              v52 = v45;
              do
              {
                *((_BYTE *)&v47[v52] + v51) = v48[v52 * 2 + v51];
                ++v51;
              }
              while (v34 != v51);
              return result;
            }
          }
        }
        else
        {
          v56 = v44 >> 2;
          v57 = v56;
          while (1)
          {
            v58 = result;
            v59 = v35;
            v60 = v37;
            do
            {
              v61 = *(_DWORD *)v59;
              v59 += 4;
              *v58++ = v61;
              v60 -= 4;
            }
            while (v60);
            v31 = v34 > v38;
            v34 -= v38;
            if (!v31)
              break;
            v35 = &v59[v57 * 4];
            result = (char *)&v58[v57];
            if (v34 < v37)
            {
              v62 = 0;
              v63 = v56;
              do
              {
                *((_BYTE *)&v58[v63] + v62) = v59[v63 * 4 + v62];
                ++v62;
              }
              while (v34 != v62);
              return result;
            }
          }
        }
      }
      break;
  }
  return result;
}

unint64_t IIOImageRead::getBytesAtOffset(IIOImageRead *this, _BYTE *a2, unint64_t a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t v5;
  pthread_mutex_t *v9;
  const __CFData *v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t CGDataProviderBytesAtOffset;
  BOOL v15;
  int v16;

  v4 = 0;
  if (a2)
  {
    v5 = a4;
    if (a4)
    {
      v9 = (pthread_mutex_t *)((char *)this + 376);
      pthread_mutex_lock((pthread_mutex_t *)((char *)this + 376));
      v16 = 0;
      ERROR_ImageIO_DestinationBufferIsNotWritable(a2);
      ERROR_ImageIO_DestinationBufferIsNotBigEnough((uint64_t)a2, v5 - 1);
      if ((*((_DWORD *)this + 6) & 0x80000000) != 0
        && !*((_QWORD *)this + 4)
        && !*((_QWORD *)this + 5)
        && *((_BYTE *)this + 67))
      {
        if ((gIIODebugFlags & 0x100000000000) == 0
          || (ImageIOLog("    %s:   <IIOImageRead: %p> mmapping data   count: %d\n", "getBytesAtOffset", this, *((_DWORD *)this + 110) + 1), !*((_QWORD *)this + 4)))
        {
          v15 = 0;
          v10 = IIOImageRead::createDataWithMappedFile(this, &v15, &v16);
          *((_QWORD *)this + 4) = v10;
          if ((gIIODebugFlags & 0x80000000000) != 0)
            ImageIOLog("D   %s:%d createDataWithMappedFile %p\n", "getBytesAtOffset", 1514, v10);
        }
        ++*((_DWORD *)this + 110);
      }
      v11 = *((_QWORD *)this + 10);
      if (v11 != -1)
      {
        if (v11 < a3)
        {
          _cg_jpeg_mem_term("getBytesAtOffset", 1524, "*** ERROR: offset > _length (%ld > %ld)\n", a3, v11);
          v11 = *((_QWORD *)this + 10);
        }
        v12 = v11 - a3;
        if (v11 <= a3)
          goto LABEL_25;
        if (v12 >= v5)
          v12 = v5;
        if (v12 <= 0)
        {
          _cg_jpeg_mem_term("getBytesAtOffset", 1536, " inCount = %ld   count = %ld   _length = %ld   offset = %ld \n", v5, v12, v11, a3);
          goto LABEL_25;
        }
        v5 = v12;
      }
      if (*((_QWORD *)this + 5))
      {
        CGDataProviderBytesAtOffset = IIOImageRead::getCGDataProviderBytesAtOffset(this, a2);
LABEL_28:
        v4 = CGDataProviderBytesAtOffset;
        goto LABEL_29;
      }
      if (*((_QWORD *)this + 4))
      {
        CGDataProviderBytesAtOffset = IIOImageRead::getCFDataBytesAtOffset(this, a2, a3, v5);
        goto LABEL_28;
      }
      if ((*((_DWORD *)this + 6) & 0x80000000) == 0)
      {
        CGDataProviderBytesAtOffset = IIOImageRead::getFileBytesAtOffset(this, a2, a3, v5);
        goto LABEL_28;
      }
LABEL_25:
      v4 = 0;
LABEL_29:
      pthread_mutex_unlock(v9);
    }
  }
  return v4;
}

uint64_t ERROR_ImageIO_DestinationBufferIsNotBigEnough(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(result + a2) = 0;
  return result;
}

_BYTE *ERROR_ImageIO_DestinationBufferIsNotWritable(_BYTE *result)
{
  *result = 0;
  return result;
}

unint64_t IIOImageRead::getCFDataBytesAtOffset(IIOImageRead *this, UInt8 *a2, CFIndex a3, unint64_t a4)
{
  const __CFData *v8;
  CFIndex Length;
  const void *v10;
  CFTypeID v11;
  unint64_t v12;
  const UInt8 *BytePtr;
  const UInt8 *v15;
  CFRange v16;

  if ((gIIODebugFlags & 0x800000) != 0)
  {
    v8 = (const __CFData *)*((_QWORD *)this + 4);
    Length = CFDataGetLength(v8);
    ImageIOLog("    %s:%d:  data: %p  [%8ld]  offset: 0x%08lX   size: %8ld\n", "getCFDataBytesAtOffset", 1347, v8, Length, a3, a4);
  }
  v10 = (const void *)*((_QWORD *)this + 4);
  if (!v10)
    return 0;
  v11 = CFGetTypeID(v10);
  if (v11 != CFDataGetTypeID())
    return 0;
  v12 = CFDataGetLength(*((CFDataRef *)this + 4));
  if (v12 < *((_QWORD *)this + 10) && !*((_BYTE *)this + 69))
  {
    LogFault("getCFDataBytesAtOffset", 1357, ": *** ERROR *** CGImageSource was created with data size: %ld - current size is only: %ld\n", *((_QWORD *)this + 10), v12);
    *((_BYTE *)this + 69) = 1;
  }
  if (a4 + a3 > v12)
  {
    LogError("getCFDataBytesAtOffset", 1365, ": *** ERROR *** requested range: %ld-%lld - is outside input CFData range (0-%ld)\n", a3, a4 + a3, v12);
    return 0;
  }
  if (v12 - a3 < a4)
    a4 = v12 - a3;
  if (a4)
  {
    BytePtr = CFDataGetBytePtr(*((CFDataRef *)this + 4));
    v15 = BytePtr;
    if (a3)
      CHECK_FIRST_BYTE_OF_IMAGEBLOCK((unsigned __int8 *)&BytePtr[a3 - 1]);
    CHECK_LAST_BYTE_OF_IMAGEBLOCK((unsigned __int8 *)&v15[a3]);
    v16.location = a3;
    v16.length = a4;
    CFDataGetBytes(*((CFDataRef *)this + 4), v16, a2);
  }
  return a4;
}

uint64_t png_read_IDAT_data(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uLong v6;
  int v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t result;
  int v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int chunk_header;
  int v16;
  unsigned int v17;
  size_t v18;
  Bytef *buffer;
  const char *v20;
  const char *v21;
  uint64_t v22;
  _QWORD v23[514];

  v2 = MEMORY[0x1E0C80A78](a1, a2);
  v5 = v3;
  v6 = v2;
  v7 = 0;
  v23[512] = *MEMORY[0x1E0C80C00];
  if (v3)
    v8 = v4;
  else
    v8 = 0;
  *(_QWORD *)(v2 + 120) = v3;
  *(_DWORD *)(v2 + 128) = 0;
  while (1)
  {
    bzero(v23, 0x1000uLL);
    if (*(_DWORD *)(v6 + 104))
    {
      if (!v5)
        goto LABEL_26;
      goto LABEL_7;
    }
    LODWORD(v13) = *(_DWORD *)(v6 + 360);
    if (!(_DWORD)v13)
    {
      v14 = 0;
      while (1)
      {
        while (1)
        {
          while (1)
          {
            png_crc_finish(v6, v14);
            chunk_header = _cg_png_read_chunk_header(v6);
            LODWORD(v13) = chunk_header;
            *(_DWORD *)(v6 + 360) = chunk_header;
            v16 = *(_DWORD *)(v6 + 312);
            if (*(_DWORD *)(v6 + 784))
              break;
            if (v16 != 1229209940)
              goto LABEL_45;
            v14 = 0;
            if (chunk_header)
              goto LABEL_21;
          }
          if (v16 == 1717846356)
            break;
          if (v16 == 1229278788)
            goto LABEL_45;
          png_warning(v6, "Skipped (ignored) a chunk between APNG chunks");
          v13 = *(unsigned int *)(v6 + 360);
          v14 = v13;
          if ((_DWORD)v13)
            goto LABEL_21;
        }
        png_ensure_sequence_number(v6, chunk_header);
        v14 = 0;
        LODWORD(v13) = *(_DWORD *)(v6 + 360) - 4;
        *(_DWORD *)(v6 + 360) = v13;
        if ((_DWORD)v13)
        {
LABEL_21:
          if (!(_DWORD)v14)
            break;
        }
      }
    }
    v17 = *(_DWORD *)(v6 + 952);
    if (v17 >= v13)
      v18 = v13;
    else
      v18 = v17;
    buffer = (Bytef *)png_read_buffer(v6, v18, 0);
    png_crc_read(v6, buffer, v18);
    *(_DWORD *)(v6 + 360) -= v18;
    *(_QWORD *)(v6 + 96) = buffer;
    *(_DWORD *)(v6 + 104) = v18;
    if (!v5)
    {
LABEL_26:
      *(_QWORD *)(v6 + 120) = v23;
      *(_DWORD *)(v6 + 128) = 4096;
      result = png_zlib_inflate(v6, 0);
      v12 = result;
      v8 = v8 - *(unsigned int *)(v6 + 128) + 4096;
      goto LABEL_27;
    }
LABEL_7:
    v9 = 0xFFFFFFFFLL;
    if (v8 < 0xFFFFFFFF)
      v9 = v8;
    v10 = v8 - v9;
    *(_DWORD *)(v6 + 128) = v9;
    result = png_zlib_inflate(v6, 0);
    v12 = result;
    v8 = v10 + *(unsigned int *)(v6 + 128);
LABEL_27:
    *(_DWORD *)(v6 + 128) = 0;
    if (!v12)
      goto LABEL_33;
    if (v12 == 1)
      break;
    png_zstream_error(v6, v12);
    v20 = *(const char **)(v6 + 144);
    if (!v5)
    {
      v22 = v6;
      v21 = *(const char **)(v6 + 144);
      return png_chunk_benign_error(v22, v21);
    }
    if (strncmp(*(const char **)(v6 + 144), "incorrect data check", 0x14uLL))
      png_chunk_error((void (**)(void))v6, v20);
    result = png_chunk_benign_error(v6, "ADLER32 checksum mismatch");
    if (v7 > 99)
      return result;
    ++v7;
LABEL_33:
    if (!v8)
      return result;
  }
  *(_QWORD *)(v6 + 120) = 0;
  *(_QWORD *)(v6 + 76) |= 0x800000008uLL;
  ++*(_DWORD *)(v6 + 784);
  if ((*(_DWORD *)(v6 + 104) || *(_DWORD *)(v6 + 360)) && (*(_BYTE *)(v6 + 84) & 0x10) == 0)
    result = png_chunk_benign_error(v6, "Extra compressed data");
  if (v8)
  {
    if (v5)
LABEL_45:
      _cg_png_error((void (**)(void))v6, "Not enough image data");
    v21 = "Too much image data";
    v22 = v6;
    return png_chunk_benign_error(v22, v21);
  }
  return result;
}

uint64_t png_zlib_inflate(uint64_t a1, int a2)
{
  if (!*(_BYTE *)(a1 + 400) || !*(_DWORD *)(a1 + 104))
    return inflate((z_streamp)(a1 + 96), a2);
  if ((**(char **)(a1 + 96) & 0x80000000) == 0)
  {
    *(_BYTE *)(a1 + 400) = 0;
    return inflate((z_streamp)(a1 + 96), a2);
  }
  *(_QWORD *)(a1 + 144) = "invalid window size (libpng)";
  return 4294967293;
}

uint64_t png_read_filter_row(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  unsigned int v5;
  uint64_t v9;
  unsigned int v10;
  void *v11;

  v5 = a5 - 1;
  if ((a5 - 1) <= 3)
  {
    v9 = result;
    if (!*(_QWORD *)(result + 968))
    {
      v10 = (*(unsigned __int8 *)(result + 394) + 7) >> 3;
      *(_QWORD *)(result + 968) = png_read_filter_row_sub;
      *(_QWORD *)(result + 976) = png_read_filter_row_up;
      *(_QWORD *)(result + 984) = png_read_filter_row_avg;
      v11 = png_read_filter_row_paeth_1byte_pixel;
      if (v10 != 1)
        v11 = png_read_filter_row_paeth_multibyte_pixel;
      *(_QWORD *)(result + 992) = v11;
      png_init_filter_functions_apple((_QWORD *)result, v10);
    }
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v9 + 8 * v5 + 968))(a2, a3, a4);
  }
  return result;
}

uint64_t png_read_IDAT_dataApple(uLong a1)
{
  unsigned int v2;
  BOOL v3;
  unint64_t v4;
  uint64_t result;
  unsigned int chunk_header;
  unsigned int v7;
  size_t v8;
  Bytef *buffer;
  unsigned int v10;
  const char *v11;

  *(_QWORD *)(a1 + 120) = *(_QWORD *)(a1 + 328);
  v4 = *(unsigned __int8 *)(a1 + 394);
  v2 = *(_DWORD *)(a1 + 304);
  v3 = v4 >= 8;
  LODWORD(v4) = v2 * (v4 >> 3);
  if (!v3)
    v4 = (v2 * (unint64_t)*(unsigned __int8 *)(a1 + 394) + 7) >> 3;
  *(_DWORD *)(a1 + 128) = v4 + 1;
  while (1)
  {
    result = png_read_zstream(a1);
    if ((_DWORD)result != -5)
    {
      if ((_DWORD)result)
        break;
    }
    if (*(_DWORD *)(a1 + 128))
    {
      if (*(_DWORD *)(a1 + 104))
        continue;
      chunk_header = *(_DWORD *)(a1 + 360);
      while (!chunk_header)
      {
        png_crc_finish(a1, 0);
        chunk_header = _cg_png_read_chunk_header(a1);
        *(_DWORD *)(a1 + 360) = chunk_header;
        if (*(_DWORD *)(a1 + 312) != 1229209940)
        {
          v11 = "Not enough image data";
          goto LABEL_26;
        }
      }
      v7 = *(_DWORD *)(a1 + 952);
      v8 = v7 >= chunk_header ? chunk_header : v7;
      buffer = (Bytef *)png_read_buffer(a1, v8, 0);
      *(_DWORD *)(a1 + 104) = v8;
      *(_QWORD *)(a1 + 96) = buffer;
      v10 = *(_DWORD *)(a1 + 360);
      if (v8 > v10)
      {
        *(_DWORD *)(a1 + 104) = v10;
        LODWORD(v8) = v10;
      }
      result = png_crc_read(a1, buffer, v8);
      *(_DWORD *)(a1 + 360) -= *(_DWORD *)(a1 + 104);
      if (*(_DWORD *)(a1 + 128))
        continue;
    }
    return result;
  }
  if ((_DWORD)result != 1)
  {
    if (*(_QWORD *)(a1 + 144))
      v11 = *(const char **)(a1 + 144);
    else
      v11 = "Decompression error";
LABEL_26:
    _cg_png_error((void (**)(void))a1, v11);
  }
  if ((*(_DWORD *)(a1 + 128) || *(_DWORD *)(a1 + 104) || *(_DWORD *)(a1 + 360)) && (*(_BYTE *)(a1 + 84) & 8) == 0)
  {
    v11 = "Extra compressed data";
    goto LABEL_26;
  }
  *(_DWORD *)(a1 + 76) |= 8u;
  return result;
}

uint64_t png_read_zstream(uint64_t a1)
{
  z_stream *v1;
  int v3;
  const char *v5;

  v1 = (z_stream *)(a1 + 96);
  if (!*(_QWORD *)(a1 + 152))
  {
    v3 = (*(_BYTE *)(a1 + 84) & 1) != 0
       ? inflateInit2_((z_streamp)(a1 + 96), -15, "1.2.12", 112)
       : inflateInit_((z_streamp)(a1 + 96), "1.2.12", 112);
    if (v3)
    {
      if (v3 == -6)
      {
        v5 = "zlib version error";
      }
      else if (v3 == -2 || v3 == -4)
      {
        v5 = "zlib memory error";
      }
      else
      {
        v5 = "Unknown zlib error";
      }
      _cg_png_error((void (**)(void))a1, v5);
    }
  }
  return inflate(v1, 1);
}

uint64_t png_do_read_transformations(uint64_t result, unsigned int *a2, uint8x8_t a3)
{
  uint64_t v3;
  uint64_t v4;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  unsigned __int8 *v15;
  _BYTE *v16;
  unsigned int v17;
  unsigned __int16 *v18;
  unsigned int *v19;
  char *v20;
  unsigned __int8 *v21;
  int v22;
  uint64_t v23;
  char v24;
  unsigned int v25;
  uint64_t v26;
  char v27;
  char v28;
  int v29;
  unsigned __int8 *v30;
  _BYTE *v31;
  unsigned int v32;
  int v33;
  unsigned __int8 *v34;
  _BYTE *v35;
  unsigned int v36;
  _BYTE *v37;
  unsigned __int8 *v38;
  unsigned int v39;
  int v40;
  char v41;
  unsigned __int8 *v42;
  int v43;
  int v44;
  int v45;
  unsigned int v46;
  unsigned int v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  _BYTE *v51;
  uint64_t v52;
  uint64_t v53;
  BOOL v54;
  uint64_t v55;
  unsigned __int8 v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  int v60;
  unsigned int v61;
  uint64_t v62;
  unsigned int v63;
  unsigned int v64;
  char v66;
  unsigned int v67;
  unsigned int v68;
  uint64_t v69;
  unsigned __int8 v70;
  unsigned __int8 *v71;
  int v72;
  int v73;
  int v74;
  unsigned __int8 v76;
  unsigned __int16 *v77;
  unsigned int v78;
  unsigned int v79;
  unsigned int v80;
  unsigned int v81;
  unsigned int v83;
  unsigned __int8 v84;
  char v85;
  unsigned __int8 v86;
  unint64_t v87;
  unint64_t v88;
  int v89;
  int v90;
  unsigned __int8 *v91;
  uint64_t v92;
  uint64_t v93;
  int v94;
  unsigned int v95;
  unsigned int v96;
  unsigned __int8 *v97;
  unsigned int v98;
  unsigned __int8 *v99;
  unsigned int v100;
  unint64_t v101;
  int v102;
  unsigned __int8 *v103;
  unsigned __int8 *v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  int v111;
  int v112;
  unsigned int v113;
  int v114;
  int v115;
  unsigned int v116;
  BOOL v117;
  int v118;
  uint64_t v119;
  unsigned int v120;
  int v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  _BYTE *v125;
  unsigned int v126;
  _BYTE *v127;
  uint64_t v128;
  uint64_t v129;
  char v130;
  int v131;
  unsigned int v132;
  unsigned __int16 v133;
  unsigned __int8 *v134;
  int v135;
  unsigned int v136;
  int v137;
  int v138;
  unsigned int v139;
  int v140;
  unsigned int v141;
  int v142;
  int v143;
  unsigned __int8 *v144;
  uint64_t v145;
  unsigned int v146;
  uint64_t v147;
  unsigned int v148;
  unsigned int v149;
  unsigned __int16 *v150;
  unsigned __int8 *v151;
  unsigned int v152;
  unsigned int v153;
  unsigned int v154;
  unsigned int v155;
  unsigned int v156;
  unsigned int v157;
  unsigned __int8 *v158;
  unsigned int v159;
  unsigned int v160;
  int v161;
  unsigned int v162;
  unsigned int v163;
  unsigned int v164;
  unsigned int v165;
  unsigned int v166;
  unsigned int v167;
  unsigned int v168;
  unsigned int v169;
  unsigned int v170;
  unsigned int v171;
  unsigned int v172;
  uint64_t v173;
  int v174;
  uint64_t v175;
  unsigned __int8 *v176;
  int v177;
  uint64_t v178;
  unsigned __int8 *v179;
  unsigned __int8 *v180;
  unsigned __int8 *v181;
  int v182;
  uint64_t v183;
  char *v184;
  char *v185;
  char *v186;
  char v187;
  int v188;
  _BYTE *v189;
  uint64_t v190;
  uint64_t v191;
  unsigned int v192;
  unsigned int v193;
  int v194;
  unsigned __int8 *v195;
  unsigned __int8 *v196;
  unsigned int v197;
  unint64_t v198;
  uint64_t v199;
  uint64_t v200;
  unint64_t v201;
  char *v202;
  char *v203;
  char v204;
  BOOL v205;
  uint64_t v206;
  unsigned int v207;
  int v208;
  _BYTE *v209;
  _BYTE *v210;
  _BYTE *v211;
  _BYTE *v212;
  int v213;
  int v214;
  uint64_t v215;
  int v216;
  int v217;
  int v218;
  int v219;
  _BYTE *v220;
  uint64_t v221;
  int v222;
  int v223;
  _BOOL4 v224;
  unint64_t v225;
  uint64_t v226;
  _BYTE *v227;
  uint64_t v228;
  _BYTE *v229;
  char v230;
  unsigned int v231;
  uint64_t v232;
  int v233;
  _BYTE *v234;
  int v235;
  uint64_t v236;
  int v237;
  _BYTE *v238;
  unsigned int v239;
  unsigned int v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  int v244;
  _BYTE *v245;
  unsigned __int8 *v246;
  unsigned int v247;
  uint64_t v248;
  _BYTE *v249;
  unsigned __int8 *v250;
  int v251;
  unsigned int v252;
  int v253;
  _BOOL4 v254;
  uint64_t v255;
  _BYTE *v256;
  unsigned __int8 *v257;
  int v258;
  unsigned int v259;
  uint64_t v260;
  int v261;
  int v262;
  uint64_t v263;
  uint64_t v264;
  unsigned int v265;
  int v266;
  uint64_t v267;
  int v268;
  _BYTE *v269;
  char *v270;
  unsigned int v271;
  char v272;
  int v273;
  _BYTE *v274;
  _BYTE *v275;
  unsigned int v276;
  _BYTE *v277;
  _BYTE *v278;
  unsigned int v279;
  _BYTE *v280;
  _BYTE *v281;
  unsigned int v282;
  uint64_t v283;
  char *v284;
  int v285;
  char v286;
  char v287;
  char v288;
  char v289;
  uint64_t v290;
  int v291;
  _BYTE *v292;
  uint64_t v293;
  __int16 v294;
  int v295;
  _BYTE *v296;
  uint64_t v297;
  int v298;
  _BYTE *v299;
  __int16 v300;
  uint64_t v301;
  unsigned int v302;
  int v303;
  __int32 *v304;
  int16x8_t v305;
  char *v306;
  char v307;
  int8x8_t *v308;
  __int32 *v309;
  int16x8_t v310;
  int v311;
  uint64_t (*v312)(uint64_t, unsigned int *, uint64_t);
  char v313;
  unsigned __int8 v314;
  BOOL v315;
  unint64_t v316;
  unint64_t v317;
  int v318;
  uint64_t v319;
  unsigned int v320;
  unsigned __int16 *v321;
  int v322;
  unsigned int v323;
  unsigned __int16 v324;
  unsigned __int8 *v325;
  int v326;
  unsigned int v327;
  __int16 v328;
  __int16 v329;
  int v330;
  uint64_t v331;
  unsigned int v332;
  unsigned int v333;
  unsigned int v334;
  uint64_t v335;
  unsigned int v336;
  unsigned int v337;
  unsigned int v338;
  unsigned int v339;
  unsigned int v340;
  unsigned int v341;
  unsigned int v342;
  unsigned int v343;
  unsigned int v344;
  int v345;
  _BYTE *v346;
  int v347;
  unsigned __int16 *v348;
  int v349;
  int v350;
  unsigned int v351;
  unsigned int v352;
  int v353;
  BOOL v354;
  int v355;
  int v356;
  unsigned int v357;
  uint64_t v358;
  unsigned int v359;
  int v360;
  BOOL v361;
  int v362;
  uint64_t v363;
  unsigned __int8 v364;
  unsigned __int8 *v365;
  unsigned __int8 *v366;
  unsigned __int8 *v367;
  int v368;
  int v369;
  unsigned int v370;
  BOOL v371;
  int v372;
  int v373;
  unsigned int v374;
  BOOL v375;
  int v376;
  unsigned int i;
  int v378;
  uint64_t v379;
  const char *v380;
  int v381;
  uint64_t v382;
  int v383;
  uint64_t v384;

  v3 = result;
  v384 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(result + 328);
  if (!v4)
  {
    v380 = "NULL row buffer";
    goto LABEL_663;
  }
  if ((*(_DWORD *)(result + 80) & 0x4040) == 0x4000)
  {
    v380 = "Uninitialized row";
    goto LABEL_663;
  }
  v6 = *(_DWORD *)(result + 88);
  if ((v6 & 0x1000) != 0)
  {
    if (*((_BYTE *)a2 + 16) == 3)
    {
      v7 = v4 + 1;
      v8 = *(_QWORD *)(result + 368);
      v9 = *(_QWORD *)(result + 520);
      v10 = *(unsigned __int16 *)(result + 384);
      v11 = *a2;
      v12 = *((unsigned __int8 *)a2 + 17);
      if (v12 <= 7)
      {
        if (v12 == 1)
        {
          if ((_DWORD)v11)
          {
            v29 = -(int)v11 & 7;
            v30 = (unsigned __int8 *)(v7 + ((v11 - 1) >> 3));
            v31 = (_BYTE *)(v4 + v11);
            v32 = *a2;
            do
            {
              *v31-- = (*v30 >> v29) & 1;
              result = v29 == 7;
              if (v29 == 7)
                v29 = 0;
              else
                ++v29;
              v30 -= result;
              --v32;
            }
            while (v32);
LABEL_41:
            v13 = v11;
            goto LABEL_43;
          }
        }
        else if (v12 == 2)
        {
          if ((_DWORD)v11)
          {
            v33 = ~(2 * v11 + 6) & 6;
            v34 = (unsigned __int8 *)(v7 + ((v11 - 1) >> 2));
            v35 = (_BYTE *)(v4 + v11);
            v36 = *a2;
            do
            {
              *v35-- = (*v34 >> v33) & 3;
              v54 = v33 == 6;
              result = v33 == 6;
              v33 += 2;
              if (v54)
                v33 = 0;
              v34 -= result;
              --v36;
            }
            while (v36);
            goto LABEL_41;
          }
        }
        else
        {
          v13 = *a2;
          if (v12 != 4)
            goto LABEL_43;
          if ((_DWORD)v11)
          {
            v14 = 4 * (*a2 & 1);
            v15 = (unsigned __int8 *)(v7 + ((v11 - 1) >> 1));
            v16 = (_BYTE *)(v4 + v11);
            v17 = *a2;
            do
            {
              *v16-- = (*v15 >> v14) & 0xF;
              v54 = v14 == 4;
              result = v14 == 4;
              v14 += 4;
              if (v54)
                v14 = 0;
              v15 -= result;
              --v17;
            }
            while (v17);
            goto LABEL_41;
          }
        }
        v13 = 0;
LABEL_43:
        *((_BYTE *)a2 + 17) = 8;
        *((_BYTE *)a2 + 19) = 8;
        *((_QWORD *)a2 + 1) = v13;
        if (!v10)
          goto LABEL_44;
        goto LABEL_20;
      }
      if (v12 == 8)
      {
        if (!*(_WORD *)(result + 384))
        {
LABEL_44:
          v26 = (3 * v11);
          if ((_DWORD)v11)
          {
            v37 = (_BYTE *)(v4 + v26);
            v38 = (unsigned __int8 *)(v4 + v11);
            do
            {
              *v37 = *(_BYTE *)(v8 + 3 * *v38 + 2);
              *(v37 - 1) = *(_BYTE *)(v8 + 3 * *v38 + 1);
              v39 = *v38--;
              *(v37 - 2) = *(_BYTE *)(v8 + 3 * v39);
              v37 -= 3;
              LODWORD(v11) = v11 - 1;
            }
            while ((_DWORD)v11);
          }
          *((_BYTE *)a2 + 17) = 8;
          *((_BYTE *)a2 + 19) = 24;
          v27 = 3;
          v28 = 2;
LABEL_48:
          *((_QWORD *)a2 + 1) = v26;
          *((_BYTE *)a2 + 16) = v28;
          *((_BYTE *)a2 + 18) = v27;
          goto LABEL_49;
        }
LABEL_20:
        if ((_DWORD)v11)
        {
          v20 = (char *)(v4 + 4 * v11);
          v21 = (unsigned __int8 *)(v4 + v11);
          v22 = v11;
          do
          {
            v23 = *v21;
            if (v10 <= v23)
              v24 = -1;
            else
              v24 = *(_BYTE *)(v9 + v23);
            *v20 = v24;
            *(v20 - 1) = *(_BYTE *)(v8 + 3 * *v21 + 2);
            *(v20 - 2) = *(_BYTE *)(v8 + 3 * *v21 + 1);
            v25 = *v21--;
            *(v20 - 3) = *(_BYTE *)(v8 + 3 * v25);
            v20 -= 4;
            --v22;
          }
          while (v22);
        }
        *((_BYTE *)a2 + 17) = 8;
        *((_BYTE *)a2 + 19) = 32;
        v26 = (4 * v11);
        v27 = 4;
        v28 = 6;
        goto LABEL_48;
      }
    }
    else
    {
      if ((v6 & 0x2000000) != 0 && *(_WORD *)(result + 384))
      {
        v18 = (unsigned __int16 *)(result + 528);
        v19 = a2;
      }
      else
      {
        v19 = a2;
        v18 = 0;
      }
      result = (uint64_t)png_do_expand(v19, v4 + 1, v18);
    }
  }
LABEL_49:
  v40 = *(_DWORD *)(v3 + 88);
  if ((v40 & 0x40080) == 0x40000 && (*((unsigned __int8 *)a2 + 16) | 2) == 6)
  {
    result = png_do_strip_channel((uint64_t)a2, (_BYTE *)(*(_QWORD *)(v3 + 328) + 1), 0);
    v40 = *(_DWORD *)(v3 + 88);
  }
  if ((v40 & 0x600000) == 0)
    goto LABEL_119;
  v41 = *((_BYTE *)a2 + 16);
  if ((v41 & 3) != 2)
    goto LABEL_119;
  v42 = (unsigned __int8 *)(*(_QWORD *)(v3 + 328) + 1);
  v43 = *(unsigned __int16 *)(v3 + 754);
  v44 = *(unsigned __int16 *)(v3 + 756);
  v45 = 0x8000 - (v43 + v44);
  v46 = *a2;
  v47 = *a2;
  if (*((_BYTE *)a2 + 17) == 8)
  {
    v48 = *(_QWORD *)(v3 + 472);
    if (v48)
    {
      v49 = *(_QWORD *)(v3 + 480);
      if (v49)
      {
        if (v47)
        {
          v50 = 0;
          result = *(_QWORD *)(v3 + 328) + 1;
          while (1)
          {
            v51 = (_BYTE *)*v42;
            v52 = v42[1];
            v53 = v42[2];
            v54 = (_DWORD)v51 == (_DWORD)v52 && (_DWORD)v51 == (_DWORD)v53;
            if (!v54)
              break;
            v55 = *(_QWORD *)(v3 + 456);
            if (v55)
            {
              v51 += v55;
              goto LABEL_66;
            }
LABEL_67:
            *(_BYTE *)result = (_BYTE)v51;
            if ((v41 & 4) != 0)
            {
              v56 = v42[3];
              v42 += 4;
              *(_BYTE *)(result + 1) = v56;
              result += 2;
            }
            else
            {
              v42 += 3;
              ++result;
            }
            if (!--v47)
              goto LABEL_113;
          }
          v51 = (_BYTE *)(v48
                        + ((*(unsigned __int8 *)(v49 + v52) * v44
                          + v51[v49] * v43
                          + v45 * *(unsigned __int8 *)(v49 + v53)
                          + 0x4000) >> 15));
          v50 = 1;
LABEL_66:
          LOBYTE(v51) = *v51;
          goto LABEL_67;
        }
        goto LABEL_112;
      }
    }
    if (v47)
    {
      v50 = 0;
      v71 = (unsigned __int8 *)(*(_QWORD *)(v3 + 328) + 1);
      do
      {
        v72 = *v71;
        v73 = v71[1];
        v74 = v71[2];
        if (v72 != v73 || v72 != v74)
        {
          LOBYTE(v72) = (v72 * v43 + v73 * v44 + v45 * v74) >> 15;
          v50 = 1;
        }
        *v42 = v72;
        result = (uint64_t)(v42 + 1);
        if ((v41 & 4) != 0)
        {
          v76 = v71[3];
          v71 += 4;
          v42[1] = v76;
          v42 += 2;
        }
        else
        {
          v71 += 3;
          ++v42;
        }
        --v47;
      }
      while (v47);
      goto LABEL_113;
    }
LABEL_112:
    v50 = 0;
    goto LABEL_113;
  }
  v57 = *(_QWORD *)(v3 + 496);
  if (v57 && (v58 = *(_QWORD *)(v3 + 488)) != 0)
  {
    if (!v47)
      goto LABEL_112;
    v50 = 0;
    result = *(_QWORD *)(v3 + 328) + 1;
    do
    {
      v59 = *(unsigned __int8 *)result;
      v60 = *(unsigned __int8 *)(result + 1);
      v61 = v60 | (v59 << 8);
      v62 = *(unsigned __int8 *)(result + 2);
      v63 = *(unsigned __int8 *)(result + 3);
      v64 = __rev16(*(unsigned __int16 *)(result + 4));
      if ((v63 | ((_DWORD)v62 << 8)) == v61 && v61 == v64)
      {
        v69 = *(_QWORD *)(v3 + 464);
        if (v69)
        {
          LOBYTE(v60) = *(_WORD *)(*(_QWORD *)(v69 + 8 * (v63 >> *(_DWORD *)(v3 + 448))) + 2 * v62);
          v59 = HIBYTE(*(unsigned __int16 *)(*(_QWORD *)(v69 + 8 * (v63 >> *(_DWORD *)(v3 + 448))) + 2 * v62));
        }
      }
      else
      {
        v66 = *(_DWORD *)(v3 + 448);
        v67 = *(unsigned __int16 *)(*(_QWORD *)(v57 + 8 * (v63 >> v66)) + 2 * v62) * v44
            + *(unsigned __int16 *)(*(_QWORD *)(v57 + 8 * (v61 >> v66)) + 2 * (v61 >> 8)) * v43
            + v45 * *(unsigned __int16 *)(*(_QWORD *)(v57 + 8 * (v64 >> v66)) + 2 * (v64 >> 8))
            + 0x4000;
        v68 = *(unsigned __int16 *)(*(_QWORD *)(v58 + 8 * ((v67 >> 15) >> v66))
                                  + 2 * (v67 >> 23));
        LOBYTE(v60) = v68;
        v59 = v68 >> 8;
        v50 = 1;
      }
      *v42 = v59;
      v42[1] = v60;
      if ((v41 & 4) != 0)
      {
        v42[2] = *(_BYTE *)(result + 6);
        v70 = *(_BYTE *)(result + 7);
        result += 8;
        v42[3] = v70;
        v42 += 4;
      }
      else
      {
        result += 6;
        v42 += 2;
      }
      --v47;
    }
    while (v47);
  }
  else
  {
    if (!v47)
      goto LABEL_112;
    v50 = 0;
    v77 = (unsigned __int16 *)(*(_QWORD *)(v3 + 328) + 1);
    do
    {
      v78 = __rev16(*v77);
      v79 = __rev16(v77[1]);
      v80 = v77[2];
      v81 = __rev16(v80);
      if (v78 != bswap32(v80) >> 16 || v78 != v79)
        v50 = 1;
      v83 = v79 * v44 + v78 * v43 + v81 * v45 + 0x4000;
      result = v83 >> 15;
      *v42 = v83 >> 23;
      v42[1] = result;
      if ((v41 & 4) != 0)
      {
        v42[2] = *((_BYTE *)v77 + 6);
        v84 = *((_BYTE *)v77 + 7);
        v77 += 4;
        v42[3] = v84;
        v42 += 4;
      }
      else
      {
        v77 += 3;
        v42 += 2;
      }
      --v47;
    }
    while (v47);
  }
LABEL_113:
  v85 = *((_BYTE *)a2 + 18) - 2;
  *((_BYTE *)a2 + 18) = v85;
  *((_BYTE *)a2 + 16) &= ~2u;
  v86 = *((_BYTE *)a2 + 17) * v85;
  *((_BYTE *)a2 + 19) = v86;
  v87 = (v86 * (unint64_t)v46 + 7) >> 3;
  v88 = v46 * (unint64_t)(v86 >> 3);
  if (v86 < 8u)
    v88 = v87;
  *((_QWORD *)a2 + 1) = v88;
  v40 = *(_DWORD *)(v3 + 88);
  if (v50)
  {
    *(_BYTE *)(v3 + 752) = 1;
    if ((v40 & 0x600000) == 0x400000)
    {
      result = png_warning(v3, "png_do_rgb_to_gray found nongray pixel");
      v40 = *(_DWORD *)(v3 + 88);
    }
    if ((v40 & 0x600000) == 0x200000)
    {
      v380 = "png_do_rgb_to_gray found nongray pixel";
      goto LABEL_663;
    }
  }
LABEL_119:
  if ((v40 & 0x4000) != 0 && (*(_BYTE *)(v3 + 77) & 8) == 0)
  {
    result = (uint64_t)png_do_gray_to_rgb(a2, *(_QWORD *)(v3 + 328) + 1);
    v40 = *(_DWORD *)(v3 + 88);
  }
  if ((v40 & 0x80) != 0)
  {
    result = *(_QWORD *)(v3 + 328);
    v104 = (unsigned __int8 *)(result + 1);
    v105 = *(_QWORD *)(v3 + 472);
    v106 = *(_QWORD *)(v3 + 480);
    v107 = *(_QWORD *)(v3 + 456);
    v108 = *(_QWORD *)(v3 + 464);
    v109 = *(_QWORD *)(v3 + 488);
    v110 = *(_QWORD *)(v3 + 496);
    v111 = *(_DWORD *)(v3 + 448);
    v112 = *(_DWORD *)(v3 + 80);
    v113 = *a2;
    switch(*((_BYTE *)a2 + 16))
    {
      case 0:
        switch(*((_BYTE *)a2 + 17))
        {
          case 1:
            if (v113)
            {
              v114 = *(unsigned __int16 *)(v3 + 536);
              v115 = 7;
              do
              {
                v116 = *v104;
                if (((v116 >> v115) & 1) == v114)
                  *v104 = (*(unsigned __int16 *)(v3 + 420) << v115) | (0x7F7Fu >> (7 - v115)) & v116;
                v117 = v115 == 0;
                if (v115)
                  --v115;
                else
                  v115 = 7;
                if (v117)
                  ++v104;
                --v113;
              }
              while (v113);
            }
            break;
          case 2:
            if (v107)
            {
              if (v113)
              {
                v349 = *(unsigned __int16 *)(v3 + 536);
                v350 = 6;
                do
                {
                  v351 = *v104;
                  v352 = (v351 >> v350) & 3;
                  if (v352 == v349)
                  {
                    v351 &= 0x3F3Fu >> (6 - v350);
                    LOBYTE(v353) = *(unsigned __int16 *)(v3 + 420) << v350;
                  }
                  else
                  {
                    result = 0x3F3Fu >> (6 - v350);
                    LOBYTE(v351) = result & v351;
                    v353 = *(unsigned __int8 *)(v107 + 85 * v352) >> 6 << v350;
                  }
                  *v104 = v353 | v351;
                  v354 = v350 == 0;
                  if (v350)
                    v350 -= 2;
                  else
                    v350 = 6;
                  if (v354)
                    ++v104;
                  --v113;
                }
                while (v113);
              }
            }
            else if (v113)
            {
              v368 = *(unsigned __int16 *)(v3 + 536);
              v369 = 6;
              do
              {
                v370 = *v104;
                if (((v370 >> v369) & 3) == v368)
                  *v104 = (*(unsigned __int16 *)(v3 + 420) << v369) | (0x3F3Fu >> (6 - v369)) & v370;
                v371 = v369 == 0;
                if (v369)
                  v369 -= 2;
                else
                  v369 = 6;
                if (v371)
                  ++v104;
                --v113;
              }
              while (v113);
            }
            break;
          case 3:
          case 5:
          case 6:
          case 7:
            goto LABEL_123;
          case 4:
            if (v107)
            {
              if (v113)
              {
                v355 = *(unsigned __int16 *)(v3 + 536);
                v356 = 4;
                do
                {
                  v357 = *v104;
                  v358 = (v357 >> v356) & 0xF;
                  v359 = (0xF0Fu >> (4 - v356)) & v357;
                  if ((_DWORD)v358 == v355)
                    LOBYTE(v360) = *(unsigned __int16 *)(v3 + 420) << v356;
                  else
                    v360 = *(unsigned __int8 *)(v107 + (v358 | (16 * v358))) >> 4 << v356;
                  *v104 = v360 | v359;
                  v361 = v356 == 0;
                  if (v356)
                    v356 -= 4;
                  else
                    v356 = 4;
                  if (v361)
                    ++v104;
                  --v113;
                }
                while (v113);
              }
            }
            else if (v113)
            {
              v372 = *(unsigned __int16 *)(v3 + 536);
              v373 = 4;
              do
              {
                v374 = *v104;
                if (((v374 >> v373) & 0xF) == v372)
                  *v104 = (*(unsigned __int16 *)(v3 + 420) << v373) | (0xF0Fu >> (4 - v373)) & v374;
                v375 = v373 == 0;
                if (v373)
                  v373 -= 4;
                else
                  v373 = 4;
                if (v375)
                  ++v104;
                --v113;
              }
              while (v113);
            }
            break;
          case 8:
            if (v107)
            {
              if (v113)
              {
                v362 = *(unsigned __int16 *)(v3 + 536);
                do
                {
                  v363 = *v104;
                  if (v362 == (_DWORD)v363)
                    v364 = *(_BYTE *)(v3 + 420);
                  else
                    v364 = *(_BYTE *)(v107 + v363);
                  *v104++ = v364;
                  --v113;
                }
                while (v113);
              }
            }
            else if (v113)
            {
              v376 = *(unsigned __int16 *)(v3 + 536);
              do
              {
                if (v376 == *v104)
                  *v104 = *(_BYTE *)(v3 + 420);
                ++v104;
                --v113;
              }
              while (v113);
            }
            break;
          default:
            if (*((_BYTE *)a2 + 17) == 16)
            {
              if (v108)
              {
                if (v113)
                {
                  v318 = *(unsigned __int16 *)(v3 + 536);
                  do
                  {
                    v319 = *v104;
                    v320 = v104[1];
                    v321 = (unsigned __int16 *)(v3 + 420);
                    if ((v320 | ((_DWORD)v319 << 8)) != v318)
                      v321 = (unsigned __int16 *)(*(_QWORD *)(v108 + 8 * (v320 >> v111)) + 2 * v319);
                    *(_WORD *)v104 = bswap32(*v321) >> 16;
                    v104 += 2;
                    --v113;
                  }
                  while (v113);
                }
              }
              else if (v113)
              {
                v378 = *(unsigned __int16 *)(v3 + 536);
                v379 = result + 2;
                do
                {
                  if (v378 == bswap32(*(unsigned __int16 *)(v379 - 1)) >> 16)
                    *(_WORD *)(v379 - 1) = bswap32(*(unsigned __int16 *)(v3 + 420)) >> 16;
                  v379 += 2;
                  --v113;
                }
                while (v113);
              }
            }
            break;
        }
        goto LABEL_123;
      case 2:
        if (*((_BYTE *)a2 + 17) == 8)
        {
          if (v107)
          {
            if (v113)
            {
              v126 = *(unsigned __int16 *)(v3 + 530);
              v127 = (_BYTE *)(result + 3);
              do
              {
                v128 = *(v127 - 2);
                v129 = *(v127 - 1);
                if (__PAIR64__(*(unsigned __int16 *)(v3 + 532), v126) == __PAIR64__(v129, v128)
                  && *(_WORD *)(v3 + 534) == *v127)
                {
                  *(v127 - 2) = *(_BYTE *)(v3 + 414);
                  *(v127 - 1) = *(_BYTE *)(v3 + 416);
                  v130 = *(_BYTE *)(v3 + 418);
                }
                else
                {
                  *(v127 - 2) = *(_BYTE *)(v107 + v128);
                  *(v127 - 1) = *(_BYTE *)(v107 + v129);
                  v130 = *(_BYTE *)(v107 + *v127);
                }
                *v127 = v130;
                v127 += 3;
                --v113;
              }
              while (v113);
            }
          }
          else if (v113)
          {
            v345 = *(unsigned __int16 *)(v3 + 530);
            v346 = (_BYTE *)(result + 3);
            do
            {
              if (v345 == *(v346 - 2)
                && *(_WORD *)(v3 + 532) == *(v346 - 1)
                && *(_WORD *)(v3 + 534) == *v346)
              {
                *(v346 - 2) = *(_BYTE *)(v3 + 414);
                *(v346 - 1) = *(_BYTE *)(v3 + 416);
                *v346 = *(_BYTE *)(v3 + 418);
              }
              v346 += 3;
              --v113;
            }
            while (v113);
          }
        }
        else if (v108)
        {
          if (v113)
          {
            v143 = *(unsigned __int16 *)(v3 + 530);
            v144 = (unsigned __int8 *)(result + 3);
            do
            {
              v145 = *(v144 - 2);
              v146 = *(v144 - 1);
              v147 = v144[2];
              v148 = v144[3];
              result = v144[1];
              v149 = *v144;
              if ((v146 | ((_DWORD)v145 << 8)) == v143
                && (result | (v149 << 8)) == *(unsigned __int16 *)(v3 + 532)
                && (v148 | ((_DWORD)v147 << 8)) == *(unsigned __int16 *)(v3 + 534))
              {
                *((_WORD *)v144 - 1) = bswap32(*(unsigned __int16 *)(v3 + 414)) >> 16;
                *(_WORD *)v144 = bswap32(*(unsigned __int16 *)(v3 + 416)) >> 16;
                v150 = (unsigned __int16 *)(v3 + 418);
              }
              else
              {
                *((_WORD *)v144 - 1) = bswap32(*(unsigned __int16 *)(*(_QWORD *)(v108 + 8 * (v146 >> v111)) + 2 * v145)) >> 16;
                *(_WORD *)v144 = bswap32(*(unsigned __int16 *)(*(_QWORD *)(v108 + 8 * (result >> v111))
                                                             + 2 * v149)) >> 16;
                v150 = (unsigned __int16 *)(*(_QWORD *)(v108 + 8 * (v148 >> v111)) + 2 * v147);
              }
              *((_WORD *)v144 + 1) = bswap32(*v150) >> 16;
              v144 += 6;
              --v113;
            }
            while (v113);
          }
        }
        else if (v113)
        {
          v347 = *(unsigned __int16 *)(v3 + 530);
          v348 = (unsigned __int16 *)(result + 3);
          do
          {
            if (v347 == bswap32(*(v348 - 1)) >> 16
              && *(unsigned __int16 *)(v3 + 532) == bswap32(*v348) >> 16
              && __rev16(v348[1]) == *(unsigned __int16 *)(v3 + 534))
            {
              *(v348 - 1) = bswap32(*(unsigned __int16 *)(v3 + 414)) >> 16;
              *v348 = bswap32(*(unsigned __int16 *)(v3 + 416)) >> 16;
              v348[1] = bswap32(*(unsigned __int16 *)(v3 + 418)) >> 16;
            }
            v348 += 3;
            --v113;
          }
          while (v113);
        }
        goto LABEL_123;
      case 4:
        if (*((_BYTE *)a2 + 17) == 8)
        {
          if (v106 && v105 && v107)
          {
            for (; v113; --v113)
            {
              v131 = v104[1];
              if (v104[1])
              {
                if (v131 == 255)
                {
                  LOBYTE(v132) = *(_BYTE *)(v107 + *v104);
                }
                else
                {
                  v133 = *(unsigned __int8 *)(v106 + *v104) * (_WORD)v131 + *(_WORD *)(v3 + 430) * (v131 ^ 0xFF) + 128;
                  v132 = HIBYTE(v133) + v133;
                  if ((v112 & 0x2000) != 0)
                    v132 >>= 8;
                  else
                    LOBYTE(v132) = *(_BYTE *)(v105 + BYTE1(v132));
                }
              }
              else
              {
                LOBYTE(v132) = *(_BYTE *)(v3 + 420);
              }
              *v104 = v132;
              v104 += 2;
            }
          }
          else
          {
            for (; v113; --v113)
            {
              v322 = v104[1];
              if (v322 != 255)
              {
                if (v104[1])
                {
                  v324 = *v104 * (_WORD)v322 + *(_WORD *)(v3 + 420) * (v322 ^ 0xFF) + 128;
                  v323 = (HIBYTE(v324) + v324) >> 8;
                }
                else
                {
                  LOBYTE(v323) = *(_BYTE *)(v3 + 420);
                }
                *v104 = v323;
              }
              v104 += 2;
            }
          }
          goto LABEL_123;
        }
        if (!v108 || !v109 || !v110)
        {
          if (v113)
          {
            v331 = result + 2;
            do
            {
              v332 = __rev16(*(unsigned __int16 *)(v331 + 1));
              if (v332 != 0xFFFF)
              {
                if (v332)
                {
                  v333 = __rev16(*(unsigned __int16 *)(v331 - 1)) * v332
                       + (v332 ^ 0xFFFF) * *(unsigned __int16 *)(v3 + 420)
                       + 0x8000;
                  v334 = v333 + HIWORD(v333);
                  *(_BYTE *)(v331 - 1) = HIBYTE(v334);
                  *(_BYTE *)v331 = BYTE2(v334);
                }
                else
                {
                  *(_WORD *)(v331 - 1) = bswap32(*(unsigned __int16 *)(v3 + 420)) >> 16;
                }
              }
              v331 += 4;
              --v113;
            }
            while (v113);
          }
          goto LABEL_123;
        }
        if (!v113)
          goto LABEL_123;
        v151 = (unsigned __int8 *)(result + 2);
        while (1)
        {
          v152 = __rev16(*(unsigned __int16 *)(v151 + 1));
          if (v152)
          {
            if (v152 != 0xFFFF)
            {
              result = (v152 ^ 0xFFFF) * *(unsigned __int16 *)(v3 + 430);
              v154 = result
                   + v152 * *(unsigned __int16 *)(*(_QWORD *)(v110 + 8 * (*v151 >> v111)) + 2 * *(v151 - 1))
                   + 0x8000;
              v155 = v154 + HIWORD(v154);
              if ((v112 & 0x2000) != 0)
              {
                v156 = HIWORD(v155);
                v157 = HIBYTE(v155);
              }
              else
              {
                v156 = *(unsigned __int16 *)(*(_QWORD *)(v109 + 8 * (BYTE2(v155) >> v111)) + 2 * HIBYTE(v155));
                v157 = v156 >> 8;
              }
              *(v151 - 1) = v157;
              *v151 = v156;
              goto LABEL_243;
            }
            v153 = *(unsigned __int16 *)(*(_QWORD *)(v108 + 8 * (*v151 >> v111)) + 2 * *(v151 - 1));
          }
          else
          {
            v153 = *(unsigned __int16 *)(v3 + 420);
          }
          *(_WORD *)(v151 - 1) = bswap32(v153) >> 16;
LABEL_243:
          v151 += 4;
          if (!--v113)
            goto LABEL_123;
        }
      case 6:
        if (*((_BYTE *)a2 + 17) == 8)
        {
          if (v106 && v105 && v107)
          {
            if (v113)
            {
              v134 = (unsigned __int8 *)(result + 2);
              do
              {
                v135 = v134[2];
                if (v134[2])
                {
                  if (v135 == 255)
                  {
                    *(v134 - 1) = *(_BYTE *)(v107 + *(v134 - 1));
                    *v134 = *(_BYTE *)(v107 + *v134);
                    LOBYTE(v136) = *(_BYTE *)(v107 + v134[1]);
                  }
                  else
                  {
                    v137 = v135 ^ 0xFF;
                    v138 = *(unsigned __int16 *)(v3 + 424) * (v135 ^ 0xFF)
                         + *(unsigned __int8 *)(v106 + *(v134 - 1)) * v135
                         + 128;
                    v139 = v138 + BYTE1(v138);
                    if ((v112 & 0x2000) != 0)
                      v139 >>= 8;
                    else
                      LOBYTE(v139) = *(_BYTE *)(v105 + BYTE1(v139));
                    *(v134 - 1) = v139;
                    v140 = *(unsigned __int16 *)(v3 + 426) * v137 + *(unsigned __int8 *)(v106 + *v134) * v135 + 128;
                    v141 = v140 + BYTE1(v140);
                    if ((v112 & 0x2000) != 0)
                      v141 >>= 8;
                    else
                      LOBYTE(v141) = *(_BYTE *)(v105 + BYTE1(v141));
                    *v134 = v141;
                    v142 = *(unsigned __int16 *)(v3 + 428) * v137 + *(unsigned __int8 *)(v106 + v134[1]) * v135 + 128;
                    v136 = v142 + BYTE1(v142);
                    if ((v112 & 0x2000) != 0)
                      v136 >>= 8;
                    else
                      LOBYTE(v136) = *(_BYTE *)(v105 + BYTE1(v136));
                  }
                }
                else
                {
                  *(v134 - 1) = *(_BYTE *)(v3 + 414);
                  *v134 = *(_BYTE *)(v3 + 416);
                  LOBYTE(v136) = *(_BYTE *)(v3 + 418);
                }
                v134[1] = v136;
                v134 += 4;
                --v113;
              }
              while (v113);
            }
          }
          else if (v113)
          {
            v325 = (unsigned __int8 *)(result + 2);
            do
            {
              v326 = v325[2];
              if (v326 != 255)
              {
                if (v325[2])
                {
                  v328 = *(_WORD *)(v3 + 414) * (v326 ^ 0xFF) + *(v325 - 1) * (_WORD)v326 + 128;
                  *(v325 - 1) = (unsigned __int16)(v328 + HIBYTE(v328)) >> 8;
                  v329 = *(_WORD *)(v3 + 416) * (v326 ^ 0xFF) + *v325 * (_WORD)v326 + 128;
                  *v325 = (unsigned __int16)(v329 + HIBYTE(v329)) >> 8;
                  v330 = *(unsigned __int16 *)(v3 + 418) * (v326 ^ 0xFF) + v325[1] * v326 + 128;
                  v327 = (v330 + BYTE1(v330)) >> 8;
                }
                else
                {
                  *(v325 - 1) = *(_BYTE *)(v3 + 414);
                  *v325 = *(_BYTE *)(v3 + 416);
                  LOBYTE(v327) = *(_BYTE *)(v3 + 418);
                }
                v325[1] = v327;
              }
              v325 += 4;
              --v113;
            }
            while (v113);
          }
          goto LABEL_123;
        }
        if (!v108 || !v109 || !v110)
        {
          if (v113)
          {
            v335 = result + 4;
            do
            {
              v336 = __rev16(*(unsigned __int16 *)(v335 + 3));
              if (v336 != 0xFFFF)
              {
                if (v336)
                {
                  v337 = __rev16(*(unsigned __int16 *)(v335 - 1));
                  v338 = __rev16(*(unsigned __int16 *)(v335 + 1));
                  v339 = (v336 ^ 0xFFFF) * *(unsigned __int16 *)(v3 + 414)
                       + __rev16(*(unsigned __int16 *)(v335 - 3)) * v336
                       + 0x8000;
                  v340 = v339 + HIWORD(v339);
                  *(_BYTE *)(v335 - 3) = HIBYTE(v340);
                  *(_BYTE *)(v335 - 2) = BYTE2(v340);
                  v341 = (v336 ^ 0xFFFF) * *(unsigned __int16 *)(v3 + 416) + v337 * v336 + 0x8000;
                  v342 = v341 + HIWORD(v341);
                  *(_BYTE *)(v335 - 1) = HIBYTE(v342);
                  *(_BYTE *)v335 = BYTE2(v342);
                  v343 = (v336 ^ 0xFFFF) * *(unsigned __int16 *)(v3 + 418) + v338 * v336 + 0x8000;
                  v344 = v343 + HIWORD(v343);
                  *(_BYTE *)(v335 + 1) = HIBYTE(v344);
                  *(_BYTE *)(v335 + 2) = BYTE2(v344);
                }
                else
                {
                  *(_WORD *)(v335 - 3) = bswap32(*(unsigned __int16 *)(v3 + 414)) >> 16;
                  *(_WORD *)(v335 - 1) = bswap32(*(unsigned __int16 *)(v3 + 416)) >> 16;
                  *(_WORD *)(v335 + 1) = bswap32(*(unsigned __int16 *)(v3 + 418)) >> 16;
                }
              }
              v335 += 8;
              --v113;
            }
            while (v113);
          }
          goto LABEL_123;
        }
        if (!v113)
          goto LABEL_123;
        v158 = (unsigned __int8 *)(result + 4);
        break;
      default:
        goto LABEL_123;
    }
    do
    {
      v159 = __rev16(*(unsigned __int16 *)(v158 + 3));
      if (v159)
      {
        if (v159 != 0xFFFF)
        {
          v161 = v159 ^ 0xFFFF;
          v162 = (v159 ^ 0xFFFF) * *(unsigned __int16 *)(v3 + 424)
               + v159 * *(unsigned __int16 *)(*(_QWORD *)(v110 + 8 * (*(v158 - 2) >> v111)) + 2 * *(v158 - 3))
               + 0x8000;
          v163 = v162 + HIWORD(v162);
          v164 = HIBYTE(v163);
          if ((v112 & 0x2000) != 0)
          {
            v165 = HIWORD(v163);
          }
          else
          {
            v165 = *(unsigned __int16 *)(*(_QWORD *)(v109 + 8 * (BYTE2(v163) >> v111)) + 2 * v164);
            v164 = v165 >> 8;
          }
          *(v158 - 3) = v164;
          *(v158 - 2) = v165;
          v166 = v161 * *(unsigned __int16 *)(v3 + 426)
               + v159 * *(unsigned __int16 *)(*(_QWORD *)(v110 + 8 * (*v158 >> v111)) + 2 * *(v158 - 1))
               + 0x8000;
          v167 = v166 + HIWORD(v166);
          v168 = HIBYTE(v167);
          if ((v112 & 0x2000) != 0)
          {
            v169 = HIWORD(v167);
          }
          else
          {
            v169 = *(unsigned __int16 *)(*(_QWORD *)(v109 + 8 * (BYTE2(v167) >> v111)) + 2 * v168);
            v168 = v169 >> 8;
          }
          *(v158 - 1) = v168;
          *v158 = v169;
          result = *(unsigned __int16 *)(*(_QWORD *)(v110 + 8 * (v158[2] >> v111)) + 2 * v158[1]);
          v170 = v161 * *(unsigned __int16 *)(v3 + 428)
               + v159 * result
               + 0x8000
               + ((v161 * *(unsigned __int16 *)(v3 + 428) + v159 * result + 0x8000) >> 16);
          v171 = HIBYTE(v170);
          if ((v112 & 0x2000) != 0)
          {
            v172 = HIWORD(v170);
          }
          else
          {
            v172 = *(unsigned __int16 *)(*(_QWORD *)(v109 + 8 * (BYTE2(v170) >> v111)) + 2 * v171);
            v171 = v172 >> 8;
          }
          v158[1] = v171;
          v158[2] = v172;
          goto LABEL_265;
        }
        *(_WORD *)(v158 - 3) = bswap32(*(unsigned __int16 *)(*(_QWORD *)(v108 + 8 * (*(v158 - 2) >> v111))
                                                           + 2 * *(v158 - 3))) >> 16;
        *(_WORD *)(v158 - 1) = bswap32(*(unsigned __int16 *)(*(_QWORD *)(v108 + 8 * (*v158 >> v111))
                                                           + 2 * *(v158 - 1))) >> 16;
        v160 = *(unsigned __int16 *)(*(_QWORD *)(v108 + 8 * (v158[2] >> v111)) + 2 * v158[1]);
      }
      else
      {
        *(_WORD *)(v158 - 3) = bswap32(*(unsigned __int16 *)(v3 + 414)) >> 16;
        *(_WORD *)(v158 - 1) = bswap32(*(unsigned __int16 *)(v3 + 416)) >> 16;
        v160 = *(unsigned __int16 *)(v3 + 418);
      }
      *(_WORD *)(v158 + 1) = bswap32(v160) >> 16;
LABEL_265:
      v158 += 8;
      --v113;
    }
    while (v113);
  }
LABEL_123:
  v89 = *(_DWORD *)(v3 + 88);
  if ((v89 & 0x602000) != 0x2000)
    goto LABEL_159;
  if ((v89 & 0x80) != 0)
  {
    if (*(_WORD *)(v3 + 384))
      goto LABEL_159;
    v90 = *(unsigned __int8 *)(v3 + 391);
    if ((v90 & 4) != 0)
      goto LABEL_159;
  }
  else
  {
    v90 = *(unsigned __int8 *)(v3 + 391);
  }
  if (v90 != 3)
  {
    if ((v91 = *(unsigned __int8 **)(v3 + 328),
          v93 = *(_QWORD *)(v3 + 456),
          v92 = *(_QWORD *)(v3 + 464),
          v94 = *(_DWORD *)(v3 + 448),
          v95 = *a2,
          v96 = *((unsigned __int8 *)a2 + 17),
          v96 <= 8)
      && v93
      || v96 == 16 && v92)
    {
      v97 = v91 + 1;
      switch(*((_BYTE *)a2 + 16))
      {
        case 0:
          if (v96 == 2 && v95)
          {
            v98 = 0;
            v99 = v91 + 1;
            do
            {
              v100 = *v99;
              v101 = v100 & 0xC;
              v102 = (v100 & 0xC) >> 2;
              result = (*(unsigned __int8 *)(v93
                                           + ((4 * (_DWORD)v101) & 0xFFFFFF3F | ((v102 & 3) << 6) | (v101 >> 2) | v101)) >> 4) & 0xC;
              *v99++ = (*(_BYTE *)(v93
                                 + (((v100 & 0x30) >> 2) & 0xFFFFFF3F | ((((v100 & 0x30) >> 4) & 3) << 6) | ((v100 & 0x30) >> 4) | (unint64_t)(v100 & 0x30))) >> 2) & 0x30 | *(_BYTE *)(v93 + ((v100 >> 6) | ((v100 & 0xC0) >> 4) | ((v100 & 0xC0) >> 2) | (unint64_t)(v100 & 0xC0))) & 0xC0 | (*(_BYTE *)(v93 + ((4 * (_DWORD)v101) & 0xFFFFFF3F | ((v102 & 3) << 6) | (v101 >> 2) | v101)) >> 4) & 0xC | (*(_BYTE *)(v93 + 85 * (v100 & 3)) >> 6);
              v98 += 4;
            }
            while (v98 < v95);
            v96 = *((unsigned __int8 *)a2 + 17);
          }
          if (v96 == 4)
          {
            if (v95)
            {
              for (i = 0; i < v95; i += 2)
              {
                *v97 = *(_BYTE *)(v93 + (*v97 & 0xF0 | ((unint64_t)*v97 >> 4))) & 0xF0 | (*(_BYTE *)(v93 + (*v97 & 0xF | (16 * (*v97 & 0xF)))) >> 4);
                ++v97;
              }
            }
          }
          else if (v96 == 8)
          {
            for (; v95; --v95)
            {
              *v97 = *(_BYTE *)(v93 + *v97);
              ++v97;
            }
          }
          else if (v96 == 16 && v95)
          {
            v103 = v91 + 2;
            do
            {
              *(_WORD *)(v103 - 1) = bswap32(*(unsigned __int16 *)(*(_QWORD *)(v92 + 8 * (*v103 >> v94))
                                                                 + 2 * *(v103 - 1))) >> 16;
              v103 += 2;
              --v95;
            }
            while (v95);
          }
          break;
        case 2:
          if (v96 == 8)
          {
            for (; v95; --v95)
            {
              *v97 = *(_BYTE *)(v93 + *v97);
              v97[1] = *(_BYTE *)(v93 + v97[1]);
              v97[2] = *(_BYTE *)(v93 + v97[2]);
              v97 += 3;
            }
          }
          else if (v95)
          {
            v365 = v91 + 3;
            do
            {
              *((_WORD *)v365 - 1) = bswap32(*(unsigned __int16 *)(*(_QWORD *)(v92 + 8 * (*(v365 - 1) >> v94))
                                                                 + 2 * *(v365 - 2))) >> 16;
              *(_WORD *)v365 = bswap32(*(unsigned __int16 *)(*(_QWORD *)(v92 + 8 * (v365[1] >> v94)) + 2 * *v365)) >> 16;
              *((_WORD *)v365 + 1) = bswap32(*(unsigned __int16 *)(*(_QWORD *)(v92 + 8 * (v365[3] >> v94))
                                                                 + 2 * v365[2])) >> 16;
              v365 += 6;
              --v95;
            }
            while (v95);
          }
          break;
        case 4:
          if (v96 == 8)
          {
            for (; v95; --v95)
            {
              *v97 = *(_BYTE *)(v93 + *v97);
              v97 += 2;
            }
          }
          else if (v95)
          {
            v366 = v91 + 2;
            do
            {
              *(_WORD *)(v366 - 1) = bswap32(*(unsigned __int16 *)(*(_QWORD *)(v92 + 8 * (*v366 >> v94))
                                                                 + 2 * *(v366 - 1))) >> 16;
              v366 += 4;
              --v95;
            }
            while (v95);
          }
          break;
        case 6:
          if (v96 == 8)
          {
            for (; v95; --v95)
            {
              *v97 = *(_BYTE *)(v93 + *v97);
              v97[1] = *(_BYTE *)(v93 + v97[1]);
              v97[2] = *(_BYTE *)(v93 + v97[2]);
              v97 += 4;
            }
          }
          else if (v95)
          {
            v367 = v91 + 3;
            do
            {
              *((_WORD *)v367 - 1) = bswap32(*(unsigned __int16 *)(*(_QWORD *)(v92 + 8 * (*(v367 - 1) >> v94))
                                                                 + 2 * *(v367 - 2))) >> 16;
              *(_WORD *)v367 = bswap32(*(unsigned __int16 *)(*(_QWORD *)(v92 + 8 * (v367[1] >> v94)) + 2 * *v367)) >> 16;
              *((_WORD *)v367 + 1) = bswap32(*(unsigned __int16 *)(*(_QWORD *)(v92 + 8 * (v367[3] >> v94))
                                                                 + 2 * v367[2])) >> 16;
              v367 += 8;
              --v95;
            }
            while (v95);
          }
          break;
        default:
          break;
      }
    }
  }
LABEL_159:
  v118 = *(_DWORD *)(v3 + 88);
  if ((~v118 & 0x40080) == 0 && (*((unsigned __int8 *)a2 + 16) | 2) == 6)
  {
    result = png_do_strip_channel((uint64_t)a2, (_BYTE *)(*(_QWORD *)(v3 + 328) + 1), 0);
    v118 = *(_DWORD *)(v3 + 88);
  }
  if ((v118 & 0x800000) != 0 && (a2[4] & 4) != 0)
  {
    v119 = *(_QWORD *)(v3 + 328);
    v120 = *a2;
    v121 = *((unsigned __int8 *)a2 + 17);
    if (v121 != 16)
    {
      if (v121 == 8)
      {
        v122 = *(_QWORD *)(v3 + 472);
        if (v122)
        {
          if (v120)
          {
            v123 = v119 + 1;
            if ((a2[4] & 2) != 0)
              v124 = 4;
            else
              v124 = 2;
            v125 = (_BYTE *)(v123 + (v124 - 1));
            do
            {
              *v125 = *(_BYTE *)(v122 + *v125);
              v125 += v124;
              --v120;
            }
            while (v120);
          }
          goto LABEL_276;
        }
      }
LABEL_275:
      result = png_warning(v3, "png_do_encode_alpha: unexpected call");
      goto LABEL_276;
    }
    v173 = *(_QWORD *)(v3 + 488);
    if (!v173)
      goto LABEL_275;
    if (v120)
    {
      v174 = *(_DWORD *)(v3 + 448);
      if ((a2[4] & 2) != 0)
        v175 = 8;
      else
        v175 = 4;
      v176 = (unsigned __int8 *)((v175 - 4) + v119 + 4);
      do
      {
        *(_WORD *)(v176 - 1) = bswap32(*(unsigned __int16 *)(*(_QWORD *)(v173 + 8 * (*v176 >> v174))
                                                           + 2 * *(v176 - 1))) >> 16;
        v176 += v175;
        --v120;
      }
      while (v120);
    }
  }
LABEL_276:
  v177 = *(_DWORD *)(v3 + 88);
  if ((v177 & 0x4000000) != 0 && *((_BYTE *)a2 + 17) == 16)
  {
    v178 = *((_QWORD *)a2 + 1);
    if (v178 >= 1)
    {
      v179 = (unsigned __int8 *)(*(_QWORD *)(v3 + 328) + 1);
      v180 = &v179[v178];
      v181 = v179;
      do
      {
        *v181++ = *v179 + ((0xFFFF * (v179[1] - *v179) + 8388480) >> 24);
        v179 += 2;
      }
      while (v179 < v180);
      v177 = *(_DWORD *)(v3 + 88);
    }
    *((_BYTE *)a2 + 17) = 8;
    v182 = *((unsigned __int8 *)a2 + 18);
    *((_BYTE *)a2 + 19) = 8 * v182;
    *((_QWORD *)a2 + 1) = *a2 * v182;
  }
  if ((v177 & 0x400) != 0 && *((_BYTE *)a2 + 17) == 16)
  {
    v183 = *((_QWORD *)a2 + 1);
    if (v183 >= 1)
    {
      v184 = (char *)(*(_QWORD *)(v3 + 328) + 1);
      v185 = &v184[v183];
      v186 = v184;
      do
      {
        v187 = *v186;
        v186 += 2;
        *v184++ = v187;
      }
      while (v186 < v185);
      v177 = *(_DWORD *)(v3 + 88);
    }
    *((_BYTE *)a2 + 17) = 8;
    v188 = *((unsigned __int8 *)a2 + 18);
    *((_BYTE *)a2 + 19) = 8 * v188;
    *((_QWORD *)a2 + 1) = *a2 * v188;
  }
  if ((v177 & 0x40) != 0)
  {
    if (*((_BYTE *)a2 + 17) != 8)
    {
LABEL_308:
      if (*((_QWORD *)a2 + 1))
      {
        v177 = *(_DWORD *)(v3 + 88);
        goto LABEL_310;
      }
      v380 = "png_do_quantize returned rowbytes=0";
LABEL_663:
      _cg_png_error((void (**)(void))v3, v380);
    }
    v189 = (_BYTE *)(*(_QWORD *)(v3 + 328) + 1);
    v190 = *(_QWORD *)(v3 + 664);
    v191 = *(_QWORD *)(v3 + 672);
    v192 = *a2;
    v193 = *a2;
    v194 = *((unsigned __int8 *)a2 + 16);
    if (v190 && v194 == 2)
    {
      if (v193)
      {
        v195 = (unsigned __int8 *)(*(_QWORD *)(v3 + 328) + 1);
        do
        {
          *v189++ = *(_BYTE *)(v190
                             + ((*v195 << 7) & 0x7C00 | (32 * (((unint64_t)v195[1] >> 3) & 0x1F)) | ((unint64_t)v195[2] >> 3)));
          v195 += 3;
          --v193;
        }
        while (v193);
        goto LABEL_303;
      }
    }
    else
    {
      if (!v190 || v194 != 6)
      {
        if (v191 && v194 == 3 && v193)
        {
          do
          {
            *v189 = *(_BYTE *)(v191 + *v189);
            ++v189;
            --v193;
          }
          while (v193);
        }
        goto LABEL_308;
      }
      if (v193)
      {
        v196 = (unsigned __int8 *)(*(_QWORD *)(v3 + 328) + 1);
        do
        {
          *v189++ = *(_BYTE *)(v190
                             + ((*v196 << 7) & 0x7C00 | (32 * (((unint64_t)v196[1] >> 3) & 0x1F)) | ((unint64_t)v196[2] >> 3)));
          v196 += 4;
          --v193;
        }
        while (v193);
LABEL_303:
        v197 = *((unsigned __int8 *)a2 + 17);
        *((_BYTE *)a2 + 16) = 3;
        *((_BYTE *)a2 + 18) = 1;
        *((_BYTE *)a2 + 19) = v197;
        if (v197 < 8)
        {
          v198 = (v197 * (unint64_t)v192 + 7) >> 3;
LABEL_307:
          *((_QWORD *)a2 + 1) = v198;
          goto LABEL_308;
        }
LABEL_306:
        v198 = v192 * (unint64_t)(v197 >> 3);
        goto LABEL_307;
      }
    }
    *((_BYTE *)a2 + 16) = 3;
    *((_WORD *)a2 + 9) = 2049;
    v197 = 8;
    goto LABEL_306;
  }
LABEL_310:
  if ((v177 & 0x200) != 0 && *((_BYTE *)a2 + 17) == 8 && *((_BYTE *)a2 + 16) != 3)
  {
    v199 = *((_QWORD *)a2 + 1);
    if (v199 >= 1)
    {
      v200 = *(_QWORD *)(v3 + 328);
      v201 = v200 + 1 + v199 + v199;
      v202 = (char *)(v200 + v199);
      v203 = v202;
      do
      {
        v204 = *v203--;
        *(_BYTE *)(v201 - 2) = v204;
        v201 -= 2;
        *(_BYTE *)(v201 + 1) = v204;
        v205 = v201 > (unint64_t)v202;
        v202 = v203;
      }
      while (v205);
      v199 = *((_QWORD *)a2 + 1);
      v177 = *(_DWORD *)(v3 + 88);
    }
    *((_QWORD *)a2 + 1) = 2 * v199;
    *((_BYTE *)a2 + 17) = 16;
    *((_BYTE *)a2 + 19) = 16 * *((_BYTE *)a2 + 18);
  }
  if ((v177 & 0x4000) != 0 && (*(_BYTE *)(v3 + 77) & 8) != 0)
  {
    result = (uint64_t)png_do_gray_to_rgb(a2, *(_QWORD *)(v3 + 328) + 1);
    v177 = *(_DWORD *)(v3 + 88);
  }
  if ((v177 & 0x20) != 0)
  {
    result = png_do_invert((uint64_t)a2, (_BYTE *)(*(_QWORD *)(v3 + 328) + 1));
    v177 = *(_DWORD *)(v3 + 88);
  }
  if ((v177 & 0x80000) != 0)
  {
    v206 = *(_QWORD *)(v3 + 328);
    v207 = *a2;
    v208 = *((unsigned __int8 *)a2 + 16);
    if (v208 == 4)
    {
      if (*((_BYTE *)a2 + 17) == 8)
      {
        if (v207)
        {
          v210 = (_BYTE *)(v206 + *((_QWORD *)a2 + 1));
          do
          {
            *v210 = ~*v210;
            v210 -= 2;
            --v207;
          }
          while (v207);
        }
      }
      else if (v207)
      {
        v212 = (_BYTE *)(v206 + *((_QWORD *)a2 + 1));
        do
        {
          *v212 = ~*v212;
          *(v212 - 1) = ~*(v212 - 1);
          v212 -= 4;
          --v207;
        }
        while (v207);
      }
    }
    else if (v208 == 6)
    {
      if (*((_BYTE *)a2 + 17) == 8)
      {
        if (v207)
        {
          v209 = (_BYTE *)(v206 + *((_QWORD *)a2 + 1));
          do
          {
            *v209 = ~*v209;
            v209 -= 4;
            --v207;
          }
          while (v207);
        }
      }
      else if (v207)
      {
        v211 = (_BYTE *)(v206 + *((_QWORD *)a2 + 1));
        do
        {
          *v211 = ~*v211;
          *(v211 - 1) = ~*(v211 - 1);
          v211 -= 8;
          --v207;
        }
        while (v207);
      }
    }
  }
  v213 = *(_DWORD *)(v3 + 88);
  if ((v213 & 8) != 0)
  {
    v214 = *((unsigned __int8 *)a2 + 16);
    if (v214 != 3)
    {
      v215 = *(_QWORD *)(v3 + 328);
      v383 = 0;
      v382 = 0;
      v216 = *((unsigned __int8 *)a2 + 17);
      if ((v214 & 2) != 0)
      {
        v217 = *(unsigned __int8 *)(v3 + 509);
        v219 = v216 - *(unsigned __int8 *)(v3 + 511);
        LODWORD(v382) = v216 - *(unsigned __int8 *)(v3 + 510);
        HIDWORD(v382) = v219;
        v218 = 3;
      }
      else
      {
        v217 = *(unsigned __int8 *)(v3 + 512);
        v218 = 1;
      }
      v220 = (_BYTE *)(v215 + 1);
      v381 = v216 - v217;
      if ((v214 & 4) != 0)
        *(&v381 + v218++) = v216 - *(unsigned __int8 *)(v3 + 513);
      v221 = 0;
      v222 = 0;
      do
      {
        v223 = *(int *)((char *)&v381 + v221);
        v224 = v223 > 0;
        result = v223 < v216;
        if ((v224 & result) == 0)
          v223 = 0;
        *(int *)((char *)&v381 + v221) = v223;
        if ((v224 & result) != 0)
          v222 = 1;
        v221 += 4;
      }
      while (4 * v218 != v221);
      if (v222)
      {
        HIDWORD(v225) = v216;
        LODWORD(v225) = v216 - 2;
        switch((v225 >> 1))
        {
          case 0u:
            v226 = *((_QWORD *)a2 + 1);
            if (v226 >= 1)
            {
              v227 = &v220[v226];
              do
              {
                *v220 = (*v220 >> 1) & 0x55;
                ++v220;
              }
              while (v220 < v227);
            }
            break;
          case 1u:
            v228 = *((_QWORD *)a2 + 1);
            if (v228 >= 1)
            {
              v229 = &v220[v228];
              v230 = v381;
              v231 = (0xFu >> v381) | (16 * (0xFu >> v381));
              do
              {
                *v220 = (*v220 >> v230) & v231;
                ++v220;
              }
              while (v220 < v229);
            }
            break;
          case 3u:
            v232 = *((_QWORD *)a2 + 1);
            if (v232 >= 1)
            {
              v233 = 0;
              v234 = &v220[v232];
              do
              {
                v235 = *v220 >> *(&v381 + v233);
                if (v233 + 1 < v218)
                  ++v233;
                else
                  v233 = 0;
                *v220++ = v235;
              }
              while (v220 < v234);
            }
            break;
          case 7u:
            v236 = *((_QWORD *)a2 + 1);
            if (v236 >= 1)
            {
              v237 = 0;
              v238 = &v220[v236];
              do
              {
                v239 = __rev16(*(unsigned __int16 *)v220) >> *(&v381 + v237);
                if (v237 + 1 < v218)
                  ++v237;
                else
                  v237 = 0;
                *(_WORD *)v220 = __rev16(v239);
                v220 += 2;
              }
              while (v220 < v238);
            }
            break;
          default:
            break;
        }
        v213 = *(_DWORD *)(v3 + 88);
      }
    }
  }
  if ((v213 & 4) != 0)
  {
    v240 = *((unsigned __int8 *)a2 + 17);
    if (v240 <= 7)
    {
      v241 = *(_QWORD *)(v3 + 328);
      v242 = v241 + 1;
      v243 = *a2;
      if (v240 == 4)
      {
        if ((_DWORD)v243)
        {
          v249 = (_BYTE *)(v241 + v243);
          v250 = (unsigned __int8 *)(v242 + ((v243 - 1) >> 1));
          v251 = 4 * (*a2 & 1);
          v252 = *a2;
          do
          {
            v253 = *v250 >> v251;
            v54 = v251 == 0;
            v254 = v251 == 0;
            *v249-- = v253 & 0xF;
            v255 = !v54;
            v250 -= v255;
            v251 = 4 * v254;
            --v252;
          }
          while (v252);
        }
      }
      else if (v240 == 2)
      {
        if ((_DWORD)v243)
        {
          v256 = (_BYTE *)(v241 + v243);
          v257 = (unsigned __int8 *)(v242 + ((v243 - 1) >> 2));
          v258 = ~(2 * v243 + 6) & 6;
          v259 = *a2;
          do
          {
            *v256-- = (*v257 >> v258) & 3;
            v54 = v258 == 6;
            v260 = v258 == 6;
            v258 += 2;
            if (v54)
              v258 = 0;
            v257 -= v260;
            --v259;
          }
          while (v259);
        }
      }
      else if (v240 == 1 && (_DWORD)v243)
      {
        v244 = -(int)v243 & 7;
        v245 = (_BYTE *)(v241 + v243);
        v246 = (unsigned __int8 *)(v242 + ((v243 - 1) >> 3));
        v247 = *a2;
        do
        {
          *v245-- = (*v246 >> v244) & 1;
          v248 = v244 == 7;
          if (v244 == 7)
            v244 = 0;
          else
            ++v244;
          v246 -= v248;
          --v247;
        }
        while (v247);
      }
      *((_BYTE *)a2 + 17) = 8;
      v261 = *((unsigned __int8 *)a2 + 18);
      *((_BYTE *)a2 + 19) = 8 * v261;
      *((_QWORD *)a2 + 1) = (v243 * v261);
    }
  }
  if (*((_BYTE *)a2 + 16) == 3 && (*(_DWORD *)(v3 + 380) & 0x80000000) == 0)
    result = png_do_check_palette_indexes(v3, (uint64_t)a2);
  v262 = *(_DWORD *)(v3 + 88);
  if ((v262 & 1) != 0)
  {
    result = (uint64_t)png_do_bgr((int *)a2, (__int16 *)(*(_QWORD *)(v3 + 328) + 1));
    v262 = *(_DWORD *)(v3 + 88);
    if ((v262 & 0x10000) == 0)
    {
LABEL_415:
      if ((v262 & 0x8000) == 0)
        goto LABEL_467;
      goto LABEL_419;
    }
  }
  else if ((v262 & 0x10000) == 0)
  {
    goto LABEL_415;
  }
  result = png_do_packswap((uint64_t)a2, (_BYTE *)(*(_QWORD *)(v3 + 328) + 1));
  v262 = *(_DWORD *)(v3 + 88);
  if ((v262 & 0x8000) == 0)
    goto LABEL_467;
LABEL_419:
  v263 = *(_QWORD *)(v3 + 328);
  v264 = v263 + 1;
  v265 = *(unsigned __int16 *)(v3 + 402);
  v266 = *(_DWORD *)(v3 + 80);
  v267 = *a2;
  if (*((_BYTE *)a2 + 16) == 2)
  {
    v273 = *((unsigned __int8 *)a2 + 17);
    if (v273 == 16)
    {
      if ((v266 & 0x80) != 0)
      {
        v297 = v264 + 6 * v267 + 2 * v267;
        if (v267 >= 2)
        {
          v298 = v267 - 1;
          v299 = (_BYTE *)(6 * v267 + v263 - 2);
          v300 = __rev16(v265);
          do
          {
            *(_WORD *)(v297 - 2) = v300;
            *(_BYTE *)(v297 - 3) = v299[2];
            *(_BYTE *)(v297 - 4) = v299[1];
            *(_BYTE *)(v297 - 5) = *v299;
            *(_BYTE *)(v297 - 6) = *(v299 - 1);
            *(_BYTE *)(v297 - 7) = *(v299 - 2);
            *(_BYTE *)(v297 - 8) = *(v299 - 3);
            v297 -= 8;
            v299 -= 6;
            --v298;
          }
          while (v298);
        }
        *(_WORD *)(v297 - 2) = __rev16(v265);
      }
      else if ((_DWORD)v267)
      {
        v280 = (_BYTE *)(v263 + 6 * v267 - 2);
        v281 = (_BYTE *)(v263 + 8 * v267 - 3);
        v282 = *a2;
        do
        {
          v281[3] = v280[2];
          v281[2] = v280[1];
          v281[1] = *v280;
          *v281 = *(v280 - 1);
          *(v281 - 1) = *(v280 - 2);
          *(v281 - 2) = *(v280 - 3);
          *(v281 - 3) = v265;
          *(v281 - 4) = BYTE1(v265);
          v280 -= 6;
          v281 -= 8;
          --v282;
        }
        while (v282);
      }
      v287 = 3;
      v288 = 64;
    }
    else
    {
      if (v273 != 8)
        goto LABEL_467;
      if ((v266 & 0x80) != 0)
      {
        v290 = v264 + v267 + 3 * v267;
        if (v267 >= 2)
        {
          v291 = v267 - 1;
          v292 = (_BYTE *)(v263 + 3 * v267);
          do
          {
            *(_BYTE *)(v290 - 1) = v265;
            *(_BYTE *)(v290 - 2) = *v292;
            *(_BYTE *)(v290 - 3) = *(v292 - 1);
            *(_BYTE *)(v290 - 4) = *(v292 - 2);
            v290 -= 4;
            v292 -= 3;
            --v291;
          }
          while (v291);
        }
        *(_BYTE *)(v290 - 1) = v265;
      }
      else if ((_DWORD)v267)
      {
        v274 = (_BYTE *)(v263 + 3 * v267);
        v275 = (_BYTE *)(v263 + 4 * v267 - 1);
        v276 = *a2;
        do
        {
          v275[1] = *v274;
          *v275 = *(v274 - 1);
          *(v275 - 1) = *(v274 - 2);
          *(v275 - 2) = v265;
          v274 -= 3;
          v275 -= 4;
          --v276;
        }
        while (v276);
      }
      v287 = 2;
      v288 = 32;
    }
    v289 = 4;
  }
  else
  {
    if (*((_BYTE *)a2 + 16))
      goto LABEL_467;
    v268 = *((unsigned __int8 *)a2 + 17);
    if (v268 == 16)
    {
      if ((v266 & 0x80) != 0)
      {
        v293 = v264 + 2 * v267 + 2 * v267;
        v294 = __rev16(v265);
        if (v267 >= 2)
        {
          v295 = v267 - 1;
          v296 = (_BYTE *)(v263 + 2 * v267);
          do
          {
            *(_WORD *)(v293 - 2) = v294;
            *(_BYTE *)(v293 - 3) = *v296;
            *(_BYTE *)(v293 - 4) = *(v296 - 1);
            v293 -= 4;
            v296 -= 2;
            --v295;
          }
          while (v295);
        }
        *(_WORD *)(v293 - 2) = v294;
      }
      else if ((_DWORD)v267)
      {
        v277 = (_BYTE *)(v263 + 2 * v267);
        v278 = (_BYTE *)(v263 + 4 * v267 - 1);
        v279 = *a2;
        do
        {
          v278[1] = *v277;
          *v278 = *(v277 - 1);
          *(v278 - 1) = v265;
          *(v278 - 2) = BYTE1(v265);
          v277 -= 2;
          v278 -= 4;
          --v279;
        }
        while (v279);
      }
      v289 = 2;
      v288 = 32;
      v287 = 2;
    }
    else
    {
      if (v268 != 8)
        goto LABEL_467;
      if ((v266 & 0x80) != 0)
      {
        v283 = v264 + v267 + v267;
        if (v267 >= 2)
        {
          v284 = (char *)(v263 + v267);
          v285 = v267 - 1;
          do
          {
            *(_BYTE *)(v283 - 1) = v265;
            v286 = *v284--;
            *(_BYTE *)(v283 - 2) = v286;
            v283 -= 2;
            --v285;
          }
          while (v285);
        }
        *(_BYTE *)(v283 - 1) = v265;
      }
      else if ((_DWORD)v267)
      {
        v269 = (_BYTE *)(v263 + 2 * v267);
        v270 = (char *)(v263 + v267);
        v271 = *a2;
        do
        {
          v272 = *v270--;
          *v269 = v272;
          *(v269 - 1) = v265;
          v269 -= 2;
          --v271;
        }
        while (v271);
      }
      v287 = 1;
      v288 = 16;
      v289 = 2;
    }
  }
  *((_BYTE *)a2 + 18) = v289;
  *((_BYTE *)a2 + 19) = v288;
  *((_QWORD *)a2 + 1) = ((_DWORD)v267 << v287);
  v262 = *(_DWORD *)(v3 + 88);
LABEL_467:
  if ((v262 & 0x20000) != 0)
  {
    v301 = *(_QWORD *)(v3 + 328);
    v302 = *a2;
    v303 = *((unsigned __int8 *)a2 + 16);
    if (v303 == 4)
    {
      if (*((_BYTE *)a2 + 17) == 8)
      {
        if (v302)
        {
          v306 = (char *)(v301 + *((_QWORD *)a2 + 1));
          do
          {
            v307 = *v306;
            *v306 = *(v306 - 1);
            *(v306 - 1) = v307;
            v306 -= 2;
            --v302;
          }
          while (v302);
        }
      }
      else if (v302)
      {
        v309 = (__int32 *)(*((_QWORD *)a2 + 1) + v301 - 3);
        do
        {
          a3.i32[0] = *v309;
          v310 = (int16x8_t)vmovl_u8(a3);
          *(int8x8_t *)v310.i8 = vext_s8(*(int8x8_t *)v310.i8, *(int8x8_t *)v310.i8, 4uLL);
          a3 = (uint8x8_t)vmovn_s16(v310);
          *v309-- = a3.i32[0];
          --v302;
        }
        while (v302);
      }
    }
    else if (v303 == 6)
    {
      if (*((_BYTE *)a2 + 17) == 8)
      {
        if (v302)
        {
          v304 = (__int32 *)(*((_QWORD *)a2 + 1) + v301 - 3);
          do
          {
            a3.i32[0] = *v304;
            v305 = (int16x8_t)vmovl_u8(a3);
            *(int8x8_t *)v305.i8 = vext_s8(*(int8x8_t *)v305.i8, *(int8x8_t *)v305.i8, 6uLL);
            a3 = (uint8x8_t)vmovn_s16(v305);
            *v304-- = a3.i32[0];
            --v302;
          }
          while (v302);
        }
      }
      else if (v302)
      {
        v308 = (int8x8_t *)(*((_QWORD *)a2 + 1) + v301 - 7);
        do
        {
          *v308 = vext_s8(*v308, *v308, 6uLL);
          --v308;
          --v302;
        }
        while (v302);
      }
    }
  }
  v311 = *(_DWORD *)(v3 + 88);
  if ((v311 & 0x10) != 0)
  {
    result = png_do_swap((uint64_t)a2, (char *)(*(_QWORD *)(v3 + 328) + 1));
    v311 = *(_DWORD *)(v3 + 88);
  }
  if ((v311 & 0x100000) != 0)
  {
    v312 = *(uint64_t (**)(uint64_t, unsigned int *, uint64_t))(v3 + 48);
    if (v312)
      result = v312(v3, a2, *(_QWORD *)(v3 + 328) + 1);
    if (*(_BYTE *)(v3 + 72))
      *((_BYTE *)a2 + 17) = *(_BYTE *)(v3 + 72);
    v313 = *(_BYTE *)(v3 + 73);
    if (v313)
      *((_BYTE *)a2 + 18) = v313;
    else
      v313 = *((_BYTE *)a2 + 18);
    v314 = v313 * *((_BYTE *)a2 + 17);
    *((_BYTE *)a2 + 19) = v314;
    v315 = v314 >= 8u;
    v316 = (*a2 * (unint64_t)v314 + 7) >> 3;
    v317 = *a2 * (unint64_t)(v314 >> 3);
    if (!v315)
      v317 = v316;
    *((_QWORD *)a2 + 1) = v317;
  }
  return result;
}

double png_read_filter_row_up_4bpp_neon(uint64_t a1, int8x16_t *a2, int8x16_t *a3, int8x16_t a4, int8x16_t a5)
{
  unint64_t v5;
  int8x16_t *v6;
  int8x16_t v7;
  int8x16_t v8;
  int8x16_t v9;
  int8x16_t v10;
  int8x16_t v11;
  int8x16_t v12;
  int8x16_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int8x16_t v16;
  int8x16_t v17;
  int8x16_t v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t *v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  __n128 *v28;
  int8x16_t v29;
  int8x16_t v30;
  int8x16_t v31;
  unsigned __int32 v32;
  unsigned __int32 v33;

  v5 = *(_QWORD *)(a1 + 8);
  if (v5 >= 0x80)
  {
    do
    {
      v6 = a2 + 8;
      v7 = *a3;
      v8 = a3[1];
      v9 = a3[2];
      v10 = a3[3];
      v11 = a3[4];
      v12 = a3[5];
      v13 = a3[6];
      v14 = a3[7];
      a3 += 8;
      a4 = vaddq_s8(v7, *a2);
      a5 = vaddq_s8(v8, a2[1]);
      v15 = vaddq_s8(v9, a2[2]);
      v16 = vaddq_s8(v10, a2[3]);
      v17 = vaddq_s8(v11, a2[4]);
      v18 = vaddq_s8(v12, a2[5]);
      v19 = vaddq_s8(v13, a2[6]);
      v20 = vaddq_s8(v14, a2[7]);
      *a2 = a4;
      a2[1] = a5;
      a2[2] = v15;
      a2[3] = v16;
      a2[4] = v17;
      a2[5] = v18;
      v5 -= 128;
      a2[6] = v19;
      a2[7] = v20;
      a2 += 8;
    }
    while (v5 > 0x7F);
    a2 = v6;
  }
  if (v5 >= 0x40)
  {
    do
    {
      v21 = a2 + 4;
      v22 = *a3;
      v23 = a3[1];
      v24 = a3[2];
      v25 = a3[3];
      a3 += 4;
      a4 = vaddq_s8(v22, *a2);
      a5 = vaddq_s8(v23, a2[1]);
      v26 = vaddq_s8(v24, a2[2]);
      v27 = vaddq_s8(v25, a2[3]);
      *a2 = a4;
      a2[1] = a5;
      a2[2] = v26;
      a2[3] = v27;
      v5 -= 64;
      a2 += 4;
    }
    while (v5 > 0x3F);
    a2 = v21;
  }
  v28 = (__n128 *)a2;
  if (v5 >= 0x10)
  {
    do
    {
      v29 = *a2++;
      v30 = v29;
      v31 = *a3++;
      a5.i32[1] = v31.i32[1];
      a4 = vaddq_s8(v31, v30);
      *v28++ = (__n128)a4;
      v5 -= 16;
    }
    while (v5 > 0xF);
  }
  if (v5 >= 4)
  {
    do
    {
      v32 = a2->i32[0];
      a2 = (int8x16_t *)((char *)a2 + 4);
      a4.i32[0] = v32;
      v33 = a3->i32[0];
      a3 = (int8x16_t *)((char *)a3 + 4);
      a5.i32[0] = v33;
      *(int8x8_t *)a4.i8 = vmovn_s16((int16x8_t)vaddl_u8(*(uint8x8_t *)a5.i8, *(uint8x8_t *)a4.i8));
      v28->n128_u32[0] = a4.i32[0];
      v28 = (__n128 *)((char *)v28 + 4);
      v5 -= 4;
    }
    while (v5 > 3);
  }
  return *(double *)a4.i64;
}

uint64_t png_read_filter_row_up_apple_vector(uint64_t result, int8x16_t *a2, int8x16_t *a3)
{
  unsigned int v3;
  int8x16_t *v4;
  int8x16_t *v5;
  int8x16_t v6;
  int8x16_t v7;
  int8x16_t v8;
  int8x16_t v9;
  int8x16_t v10;
  int8x16_t v11;
  int8x16_t v12;
  __int8 v13;

  v3 = *(_DWORD *)(result + 8);
  if (v3 < 0x40)
  {
    v5 = a2;
    v4 = a3;
  }
  else
  {
    do
    {
      v4 = a3 + 4;
      v5 = a2 + 4;
      v6 = vaddq_s8(a2[1], a3[1]);
      v7 = vaddq_s8(*a2, *a3);
      v8 = vaddq_s8(a2[3], a3[3]);
      a2[2] = vaddq_s8(a2[2], a3[2]);
      a2[3] = v8;
      *a2 = v7;
      a2[1] = v6;
      v3 -= 64;
      a3 += 4;
      a2 += 4;
    }
    while (v3 > 0x3F);
  }
  if (v3 >= 0x20)
  {
    v9 = *v4;
    v10 = v4[1];
    v4 += 2;
    v11 = vaddq_s8(v5[1], v10);
    *v5 = vaddq_s8(*v5, v9);
    v5[1] = v11;
    v5 += 2;
    v3 -= 32;
  }
  if (v3 >= 0x10)
  {
    v12 = *v4++;
    *v5 = vaddq_s8(*v5, v12);
    ++v5;
    v3 -= 16;
  }
  for (; v3; --v3)
  {
    v13 = v4->i8[0];
    v4 = (int8x16_t *)((char *)v4 + 1);
    v5->i8[0] += v13;
    v5 = (int8x16_t *)((char *)v5 + 1);
  }
  return result;
}

uint64_t png_read_filter_row_paeth3_apple(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;
  int32x2_t v8;
  int32x2_t v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  int v12;
  int32x2_t v13;
  unsigned int v14;
  int v15;
  unsigned int v16;
  int v17;
  unsigned int v18;
  int32x2_t v19;
  uint32x2_t v20;
  uint32x2_t v21;
  int32x2_t v22;
  int32x2_t v23;
  int8x8_t v24;

  v3 = 0;
  v4 = *(_QWORD *)(result + 8);
  do
  {
    LOBYTE(v5) = *(_BYTE *)(a3 + v3) + *(_BYTE *)(a2 + v3);
    *(_BYTE *)(a2 + v3++) = v5;
  }
  while ((_DWORD)v3 != 3);
  if ((int)v4 >= 4)
  {
    v6 = 0;
    v5 = v5;
    v7 = *(unsigned __int8 *)(a3 + v3 - 1);
    v8.i32[0] = *(unsigned __int8 *)(a2 + v3 - 3);
    v8.i32[1] = *(unsigned __int8 *)(a2 + v3 - 2);
    v9.i32[0] = *(unsigned __int8 *)(a3 + v3 - 3);
    v9.i32[1] = *(unsigned __int8 *)(a3 + v3 - 2);
    do
    {
      v10 = (unsigned __int8 *)(a3 + v6 + v3);
      v11 = (unsigned __int8 *)(a2 + v6 + v3);
      v12 = v10[2];
      v13 = vsub_s32(v8, v9);
      v14 = v12 - v7;
      v15 = v5 - v7;
      if (v12 - v7 >= 0)
        result = v14;
      else
        result = (v7 - v12);
      if (v15 >= 0)
        v16 = v5 - v7;
      else
        v16 = v7 - v5;
      v17 = v14 + v15;
      if (v17 < 0)
        v17 = -v17;
      if (v16 >= result)
      {
        v18 = result;
      }
      else
      {
        LOBYTE(v5) = v10[2];
        v18 = v16;
      }
      if (v17 < v18)
        LOBYTE(v5) = v7;
      v19.i32[0] = *v10;
      v19.i32[1] = v10[1];
      v20 = (uint32x2_t)vabd_s32(v19, v9);
      v21 = (uint32x2_t)vabd_s32(v8, v9);
      v22 = (int32x2_t)vbsl_s8((int8x8_t)vcgt_u32(vmin_u32(v21, v20), (uint32x2_t)vabs_s32(vadd_s32(vsub_s32(v19, v9), v13))), (int8x8_t)v9, vbsl_s8((int8x8_t)vcgt_u32(v20, v21), (int8x8_t)v19, (int8x8_t)v8));
      v23.i32[0] = *v11;
      v23.i32[1] = v11[1];
      v24 = (int8x8_t)vadd_s32(v22, v23);
      LOBYTE(v5) = v5 + v11[2];
      v8 = (int32x2_t)vand_s8(v24, (int8x8_t)0xFF000000FFLL);
      *v11 = v24.i8[0];
      v11[1] = v24.u8[4];
      v11[2] = v5;
      v5 = v5;
      v6 += 3;
      v7 = v12;
      v9 = v19;
    }
    while ((int)v6 + 3 < (int)v4);
  }
  return result;
}

uint8x8_t png_read_filter_row_sub_neon(uint64_t a1, unsigned __int32 *a2, uint8x8_t result, uint8x8_t a4, double a5, double a6, int8x16_t a7)
{
  uint64_t v7;
  int8x16_t *v8;
  uint64_t v9;
  unint64_t v10;
  int8x16_t v11;
  int8x16_t v12;
  __int32 *v13;
  __int32 v14;

  v7 = *(_QWORD *)(a1 + 8);
  v8 = (int8x16_t *)(a2 + 1);
  v9 = v7 - 4;
  if ((unint64_t)(v7 - 4) < 0x10)
  {
    v10 = v7 - 4;
  }
  else
  {
    a7.i32[0] = *a2;
    result = (uint8x8_t)0x706050480808080;
    a4.i32[1] = -2139062144;
    v10 = v7 - 4;
    do
    {
      v11 = vaddq_s8(*v8, a7);
      v12 = vaddq_s8(vaddq_s8(vaddq_s8(vqtbl1q_s8(v11, (int8x16_t)xmmword_18822DA90), vqtbl1q_s8(v11, (int8x16_t)xmmword_18822DA80)), vqtbl1q_s8(v11, (int8x16_t)xmmword_18822DAA0)), (int8x16_t)vdupq_lane_s32(*(int32x2_t *)v11.i8, 0));
      *v8++ = v12;
      a7 = vextq_s8(v12, (int8x16_t)0, 0xCuLL);
      v10 -= 16;
    }
    while (v10 > 0xF);
  }
  if (v10 >= 4)
  {
    v13 = (__int32 *)((char *)a2 + (v9 & 0xFFFFFFFFFFFFFFF0));
    do
    {
      result.i32[0] = v8->i32[0];
      v14 = *v13++;
      a4.i32[0] = v14;
      result = (uint8x8_t)vmovn_s16((int16x8_t)vaddl_u8(a4, result));
      v8->i32[0] = result.i32[0];
      v8 = (int8x16_t *)((char *)v8 + 4);
      v10 -= 4;
    }
    while (v10 > 3);
  }
  return result;
}

uint8x8_t png_read_filter_row_paeth_neon(uint64_t a1, _BYTE *a2, _BYTE *a3, uint8x8_t result, uint16x8_t a5, int32x2_t a6, int8x16_t a7, int32x2_t a8)
{
  uint64_t v8;
  int32x2_t *v9;
  int32x4_t *v10;
  uint64_t v11;
  unint64_t v12;
  int32x4_t v13;
  int8x8_t v14;
  int8x8_t v15;
  int8x8_t v16;
  uint16x8_t v17;
  int8x16_t v18;
  int8x16_t v19;
  int8x8_t v20;
  int8x16_t v21;
  int8x16_t v22;
  int8x16_t v23;
  int8x8_t v24;
  uint16x8_t v25;
  int8x16_t v26;
  uint16x8_t v27;
  int16x8_t v28;
  unint64_t v29;
  unsigned __int32 *v30;
  unsigned __int32 *v31;
  unsigned __int32 v32;
  __int32 v33;
  int8x8_t v34;
  unsigned __int32 v35;
  uint32x4_t v36;
  uint32x4_t v37;
  uint32x4_t v38;
  uint32x4_t v39;

  v8 = *(_QWORD *)(a1 + 8);
  *a2 += *a3;
  a2[1] += a3[1];
  a2[2] += a3[2];
  a2[3] += a3[3];
  v9 = (int32x2_t *)(a2 + 4);
  v10 = (int32x4_t *)(a3 + 4);
  v11 = v8 - 4;
  if ((unint64_t)(v8 - 4) < 0x10)
  {
    v12 = v8 - 4;
  }
  else
  {
    a8.i32[0] = *(_DWORD *)a3;
    a6.i32[0] = *(_DWORD *)a2;
    result = (uint8x8_t)0x101010101010101;
    a5 = 0uLL;
    v12 = v8 - 4;
    do
    {
      v13 = *v10++;
      v14 = (int8x8_t)vdup_lane_s32(*(int32x2_t *)v13.i8, 0);
      v15 = (int8x8_t)vdup_lane_s32(a8, 0);
      v16 = (int8x8_t)vdup_lane_s32(a6, 0);
      v17 = vabdq_u16(vaddl_u8((uint8x8_t)v14, (uint8x8_t)v16), vshll_n_u8((uint8x8_t)v15, 1uLL));
      *(int8x8_t *)v18.i8 = vand_s8(vmovn_s16((int16x8_t)vcgeq_u16(v17, vabdl_u8((uint8x8_t)v14, (uint8x8_t)v15))), vand_s8((int8x8_t)vcge_u8(vabd_u8((uint8x8_t)v16, (uint8x8_t)v15), vabd_u8((uint8x8_t)v14, (uint8x8_t)v15)), (int8x8_t)0x101010101010101));
      v18.i64[1] = v18.i64[0];
      *(int8x8_t *)v19.i8 = vand_s8(vmovn_s16((int16x8_t)vcgeq_u16(v17, vabdl_u8((uint8x8_t)v16, (uint8x8_t)v15))), (int8x8_t)0x101010101010101);
      v19.i64[1] = v19.i64[0];
      v20 = (int8x8_t)vcltzq_s8(vshlq_n_s8(v18, 7uLL)).u64[0];
      *(int32x2_t *)v18.i8 = vdup_lane_s32(*(int32x2_t *)v13.i8, 1);
      *(int8x8_t *)v21.i8 = vadd_s8(vbsl_s8(v20, v16, vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s8(vshlq_n_s8(v19, 7uLL)), v14, v15)), (int8x8_t)vdup_lane_s32(*v9, 0));
      v22 = (int8x16_t)vabdq_u16(vaddl_u8(*(uint8x8_t *)v21.i8, *(uint8x8_t *)v18.i8), vshll_n_u8((uint8x8_t)v14, 1uLL));
      *(int8x8_t *)v23.i8 = vand_s8(vmovn_s16((int16x8_t)vcgeq_u16((uint16x8_t)v22, vabdl_u8(*(uint8x8_t *)v18.i8, (uint8x8_t)v14))), vand_s8((int8x8_t)vcge_u8(vabd_u8(*(uint8x8_t *)v21.i8, (uint8x8_t)v14), vabd_u8(*(uint8x8_t *)v18.i8, (uint8x8_t)v14)), (int8x8_t)0x101010101010101));
      v23.i64[1] = v23.i64[0];
      *(int8x8_t *)v19.i8 = vand_s8(vmovn_s16((int16x8_t)vcgeq_u16((uint16x8_t)v22, vabdl_u8(*(uint8x8_t *)v21.i8, (uint8x8_t)v14))), (int8x8_t)0x101010101010101);
      v19.i64[1] = v19.i64[0];
      v22.i64[0] = vcltzq_s8(vshlq_n_s8(v23, 7uLL)).u64[0];
      v23.i64[0] = vdupq_laneq_s32(v13, 2).u64[0];
      v24 = vadd_s8(vbsl_s8(*(int8x8_t *)v22.i8, *(int8x8_t *)v21.i8, vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s8(vshlq_n_s8(v19, 7uLL)), *(int8x8_t *)v18.i8, v14)), (int8x8_t)vdup_lane_s32(*v9, 1));
      v25 = vabdq_u16(vaddl_u8((uint8x8_t)v24, *(uint8x8_t *)v23.i8), vshll_n_u8(*(uint8x8_t *)v18.i8, 1uLL));
      *(int8x8_t *)v19.i8 = vand_s8(vmovn_s16((int16x8_t)vcgeq_u16(v25, vabdl_u8(*(uint8x8_t *)v23.i8, *(uint8x8_t *)v18.i8))), vand_s8((int8x8_t)vcge_u8(vabd_u8((uint8x8_t)v24, *(uint8x8_t *)v18.i8), vabd_u8(*(uint8x8_t *)v23.i8, *(uint8x8_t *)v18.i8)), (int8x8_t)0x101010101010101));
      v19.i64[1] = v19.i64[0];
      *(int8x8_t *)v22.i8 = vand_s8(vmovn_s16((int16x8_t)vcgeq_u16(v25, vabdl_u8((uint8x8_t)v24, *(uint8x8_t *)v18.i8))), (int8x8_t)0x101010101010101);
      v22.i64[1] = v22.i64[0];
      v26 = vcltzq_s8(vshlq_n_s8(v19, 7uLL));
      a7 = (int8x16_t)vdupq_laneq_s32(v13, 3);
      *(int8x8_t *)v18.i8 = vadd_s8(vbsl_s8(*(int8x8_t *)v26.i8, v24, vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s8(vshlq_n_s8(v22, 7uLL)), *(int8x8_t *)v23.i8, *(int8x8_t *)v18.i8)), (int8x8_t)*(_OWORD *)&vdupq_laneq_s32(*(int32x4_t *)v9->i8, 2));
      v27 = vabdq_u16(vaddl_u8(*(uint8x8_t *)v18.i8, *(uint8x8_t *)a7.i8), vshll_n_u8(*(uint8x8_t *)v23.i8, 1uLL));
      v28 = (int16x8_t)vcgeq_u16(v27, vabdl_u8(*(uint8x8_t *)v18.i8, *(uint8x8_t *)v23.i8));
      *(int8x8_t *)v28.i8 = vmovn_s16(v28);
      *(int8x8_t *)v26.i8 = vand_s8(vmovn_s16((int16x8_t)vcgeq_u16(v27, vabdl_u8(*(uint8x8_t *)a7.i8, *(uint8x8_t *)v23.i8))), (int8x8_t)vcge_u8(vabd_u8(*(uint8x8_t *)v18.i8, *(uint8x8_t *)v23.i8), vabd_u8(*(uint8x8_t *)a7.i8, *(uint8x8_t *)v23.i8)));
      v21.i32[1] = v24.i32[1];
      v18.i32[1] = vadd_s8(vbsl_s8((int8x8_t)vcltzq_s8(vshlq_n_s8(v26, 7uLL)), *(int8x8_t *)&v18, vbsl_s8((int8x8_t)vcltzq_s8(vshlq_n_s8(*(int8x16_t *)&v28, 7uLL)), *(int8x8_t *)&a7, *(int8x8_t *)&v23)), (int8x8_t)vextq_s8(*(int8x16_t *)v9, *(int8x16_t *)v9, 8uLL)).i32[1];
      v21.i64[1] = v18.i64[0];
      *(int8x16_t *)v9->i8 = v21;
      v9 += 2;
      a6 = (int32x2_t)vextq_s8(v21, (int8x16_t)0, 0xCuLL).u64[0];
      a8 = (int32x2_t)vextq_s8(a7, (int8x16_t)0, 0xCuLL).u64[0];
      v12 -= 16;
    }
    while (v12 > 0xF);
  }
  if (v12 >= 4)
  {
    v29 = v11 & 0xFFFFFFFFFFFFFFF0;
    v30 = (unsigned __int32 *)&a2[v11 & 0xFFFFFFFFFFFFFFF0];
    v31 = (unsigned __int32 *)&a3[v29];
    do
    {
      result.i32[0] = v9->i32[0];
      v32 = *v30++;
      a5.i32[0] = v32;
      a5 = vmovl_u8(*(uint8x8_t *)a5.i8);
      v33 = v10->i32[0];
      v10 = (int32x4_t *)((char *)v10 + 4);
      a6.i32[0] = v33;
      v34 = (int8x8_t)vmovl_u8((uint8x8_t)a6).u64[0];
      v35 = *v31++;
      a7.i32[0] = v35;
      a7.i64[0] = vmovl_u8(*(uint8x8_t *)a7.i8).u64[0];
      v36 = vmovl_u16(*(uint16x4_t *)a7.i8);
      v37 = vabdq_u32(vmovl_u16((uint16x4_t)v34), v36);
      v38 = vabdq_u32(vmovl_u16(*(uint16x4_t *)a5.i8), v36);
      v39 = (uint32x4_t)vabsq_s32(vaddq_s32((int32x4_t)vsubl_u16((uint16x4_t)v34, *(uint16x4_t *)a7.i8), (int32x4_t)vsubl_u16(*(uint16x4_t *)a5.i8, *(uint16x4_t *)a7.i8)));
      a6 = (int32x2_t)vbsl_s8((int8x8_t)vmovn_s32((int32x4_t)vcgtq_u32(v38, v39)), *(int8x8_t *)a7.i8, v34);
      *(int8x8_t *)a5.i8 = vbsl_s8((int8x8_t)vmovn_s32((int32x4_t)vcgtq_u32(v37, vminq_u32(v38, v39))), (int8x8_t)a6, *(int8x8_t *)a5.i8);
      result = (uint8x8_t)vmovn_s16((int16x8_t)vaddw_u8(a5, result));
      v9->i32[0] = result.i32[0];
      v9 = (int32x2_t *)((char *)v9 + 4);
      v12 -= 4;
    }
    while (v12 > 3);
  }
  return result;
}

uint64_t png_read_filter_row_paeth_1byte_pixel(uint64_t result, unsigned __int8 *a2, unsigned __int8 *a3)
{
  uint64_t v3;
  int v4;
  unsigned __int8 v5;
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  int v9;
  int v10;
  unsigned int v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  unsigned int v16;

  v3 = *(_QWORD *)(result + 8);
  v4 = *a3;
  v5 = *a2 + v4;
  *a2 = v5;
  if (v3 >= 2)
  {
    v6 = &a2[v3];
    v7 = a2 + 1;
    v8 = a3 + 1;
    do
    {
      v10 = *v8++;
      v9 = v10;
      v11 = v10 - v4;
      v12 = v5 - v4;
      if (v10 - v4 >= 0)
        v13 = v11;
      else
        v13 = -v11;
      if (v12 >= 0)
        v14 = v5 - v4;
      else
        v14 = v4 - v5;
      v15 = v11 + v12;
      if (v15 < 0)
        v15 = -v15;
      if (v14 >= v13)
      {
        v16 = v13;
      }
      else
      {
        v5 = v9;
        v16 = v14;
      }
      if (v15 >= v16)
        LOBYTE(v4) = v5;
      v5 = v4 + *v7;
      *v7++ = v5;
      v4 = v9;
    }
    while (v7 < v6);
  }
  return result;
}

uint64_t png_read_filter_row_avg3_apple(uint64_t result, _BYTE *a2, unsigned __int8 *a3)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unsigned int v8;
  unint64_t v9;
  unint64_t v10;
  int v11;
  int v12;
  int v13;
  _BYTE *v14;

  v3 = *(unsigned __int8 *)(result + 19);
  v4 = v3 + 7;
  v5 = (unint64_t)(v3 + 7) >> 3;
  v6 = *(_QWORD *)(result + 8);
  if (*(_BYTE *)(result + 19))
  {
    if (v5 <= 1)
      v7 = 1;
    else
      v7 = (unint64_t)(v3 + 7) >> 3;
    do
    {
      v8 = *a3++;
      *a2++ += v8 >> 1;
      --v7;
    }
    while (v7);
  }
  if (v6 != v5)
  {
    v9 = 0;
    v10 = v6 - (v4 >> 3);
    v11 = *(a2 - 1);
    v12 = *(a2 - 2);
    v13 = *(a2 - 3);
    do
    {
      v14 = &a2[v9];
      result = a2[v9 + 1];
      LOBYTE(v13) = a2[v9] + ((v13 + a3[v9]) >> 1);
      LOBYTE(v12) = result + ((v12 + a3[v9 + 1]) >> 1);
      LOBYTE(v11) = a2[v9 + 2] + ((v11 + a3[v9 + 2]) >> 1);
      *v14 = v13;
      v14[1] = v12;
      v14[2] = v11;
      v13 = v13;
      v12 = v12;
      v11 = v11;
      v9 += 3;
    }
    while (v9 < v10);
  }
  return result;
}

uint64_t png_do_swap(uint64_t result, char *a2)
{
  int i;
  char v3;

  if (*(_BYTE *)(result + 17) == 16)
  {
    for (i = *(_DWORD *)result * *(unsigned __int8 *)(result + 18); i; --i)
    {
      v3 = *a2;
      *a2 = a2[1];
      a2[1] = v3;
      a2 += 2;
    }
  }
  return result;
}

uint64_t png_read_filter_row_paeth_multibyte_pixel(uint64_t result, _BYTE *a2, char *a3)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  _BYTE *v6;
  _BYTE *v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE *v11;
  int v12;
  int v13;
  char v14;
  int v15;
  unsigned int v16;
  int v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  unsigned int v21;

  v3 = *(unsigned __int8 *)(result + 19);
  v4 = (unint64_t)(v3 + 7) >> 3;
  if (*(_BYTE *)(result + 19))
  {
    v5 = (unint64_t)&a2[(unint64_t)(v3 + 7) >> 3];
    if (&a2[v4] <= a2 + 1)
      v6 = a2 + 1;
    else
      v6 = &a2[v4];
    v7 = a2;
    do
    {
      v8 = *a3++;
      *v7++ += v8;
    }
    while ((unint64_t)v7 < v5);
  }
  else
  {
    v6 = a2;
    v7 = a2;
  }
  v9 = *(_QWORD *)(result + 8);
  if (v7 < &a2[v9])
  {
    v10 = -(uint64_t)v4;
    v11 = (_BYTE *)(&a2[v9] - v6);
    do
    {
      v12 = a3[v10];
      v13 = v7[v10];
      v15 = *a3++;
      v14 = v15;
      v16 = v15 - v12;
      v17 = v13 - v12;
      if (v15 - v12 >= 0)
        v18 = v16;
      else
        v18 = -v16;
      if (v17 >= 0)
        v19 = v13 - v12;
      else
        v19 = v12 - v13;
      v20 = v16 + v17;
      if (v20 < 0)
        v20 = -v20;
      if (v19 >= v18)
      {
        v21 = v18;
      }
      else
      {
        LOBYTE(v13) = v14;
        v21 = v19;
      }
      if (v20 >= v21)
        LOBYTE(v12) = v13;
      *v7++ += v12;
      --v11;
    }
    while (v11);
  }
  return result;
}

uint64_t png_read_filter_row_avg(uint64_t result, _BYTE *a2, unsigned __int8 *a3)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;

  v3 = *(unsigned __int8 *)(result + 19);
  v4 = (unint64_t)(v3 + 7) >> 3;
  v5 = *(_QWORD *)(result + 8);
  if (*(_BYTE *)(result + 19))
  {
    if (v4 <= 1)
      v6 = 1;
    else
      v6 = (unint64_t)(v3 + 7) >> 3;
    do
    {
      v7 = *a3++;
      *a2++ += v7 >> 1;
      --v6;
    }
    while (v6);
  }
  if (v5 != v4)
  {
    v8 = -(uint64_t)v4;
    v9 = -v5;
    do
    {
      v10 = *a3++;
      *a2 += (a2[v8] + v10) >> 1;
      ++a2;
      ++v9;
    }
    while (v8 != v9);
  }
  return result;
}

uint64_t png_read_filter_row_sub_apple_neon(uint64_t result, int8x16_t *a2, __int32 *a3)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  BOOL v7;
  __int8 *v8;
  unsigned int v9;
  __int32 v10;
  __int32 *v11;
  unint64_t v12;
  int8x16_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int8x16_t *v16;
  unint64_t v17;
  int8x16_t v18;
  int8x16_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  char v24;
  char v25;
  __int8 v26;

  v3 = *(unsigned __int8 *)(result + 19);
  v4 = (unint64_t)(v3 + 7) >> 3;
  v5 = *(_QWORD *)(result + 8);
  v6 = v5 - v4;
  v7 = (_DWORD)v4 == 3 && v6 >= 0x1D;
  if (v7)
  {
    v13 = a2[1];
    v14 = vaddq_s8(vaddq_s8(vaddq_s8(vextq_s8((int8x16_t)0, *a2, 0xAuLL), *a2), vaddq_s8(vextq_s8((int8x16_t)0, *a2, 0xDuLL), vextq_s8((int8x16_t)0, *a2, 7uLL))), vaddq_s8(vextq_s8((int8x16_t)0, *a2, 4uLL), vextq_s8((int8x16_t)0, *a2, 1uLL)));
    v15 = vaddq_s8(vaddq_s8(vaddq_s8(vaddq_s8(vextq_s8(*a2, v13, 0xAuLL), v13), vaddq_s8(vextq_s8(*a2, v13, 0xDuLL), vextq_s8(*a2, v13, 7uLL))), vaddq_s8(vextq_s8(*a2, v13, 4uLL), vextq_s8(*a2, v13, 1uLL))), vextq_s8((int8x16_t)0, v14, 0xEuLL));
    *a2 = v14;
    a2[1] = v15;
    v16 = a2 + 2;
    v17 = v6 - 29;
    if (v17 >= 0x10)
    {
      do
      {
        v18 = *v16;
        v19 = vaddq_s8(vaddq_s8(vaddq_s8(*v16, vextq_s8(v14, v15, 0xEuLL)), vextq_s8(v13, *v16, 0xAuLL)), vaddq_s8(vextq_s8(v13, *v16, 0xDuLL), vextq_s8(v13, *v16, 7uLL)));
        v14 = v15;
        v15 = vaddq_s8(v19, vaddq_s8(vextq_s8(v13, *v16, 4uLL), vextq_s8(v13, *v16, 1uLL)));
        *v16++ = v15;
        v17 -= 16;
        v13 = v18;
      }
      while (v17 > 0xF);
    }
    if (v17)
    {
      v20 = -(uint64_t)v4;
      do
      {
        v16->i8[0] += v16->i8[v20];
        v16 = (int8x16_t *)((char *)v16 + 1);
        --v17;
      }
      while (v17);
    }
  }
  else
  {
    v8 = &a2->i8[v4];
    if ((_DWORD)v3 == 32)
    {
      v9 = v5 - 3;
      v10 = a2->i32[0];
      v11 = (__int32 *)((char *)a2->i32 + v4);
      if (*(_BYTE *)(result + 20))
      {
        *a3 = v10;
        v11 = a3 + 1;
      }
      if (v4 >= v9)
      {
        a3 = v11;
      }
      else
      {
        v12 = 0;
        do
        {
          result = v10 & 0x7F7F7F7F;
          v10 = ((*(__int32 *)((_BYTE *)a2->i32 + v4 + v12) & 0x7F7F7F7F) + result) ^ (*(__int32 *)((char *)a2->i32
                                                                                                  + v4
                                                                                                  + v12) ^ v10) & 0x80808080;
          v11[v12 / 4] = v10;
          v12 += 4;
        }
        while ((int)v4 + (int)v12 < v9);
        a2 = (int8x16_t *)((char *)a2 + v12);
        a3 = &v11[v12 / 4];
        v8 = &a2->i8[v4];
        LODWORD(v4) = v4 + v12;
      }
    }
    else if (*(_BYTE *)(result + 20))
    {
      if (*(_BYTE *)(result + 19))
      {
        v21 = 0;
        if (v4 <= 1)
          v22 = 1;
        else
          v22 = v4;
        LODWORD(v4) = v22;
        do
        {
          *((_BYTE *)a3 + v21) = a2->i8[v21];
          ++v21;
        }
        while (v22 != v21);
        a3 = (__int32 *)((char *)a3 + v21);
      }
      else
      {
        LODWORD(v4) = 0;
      }
    }
    else
    {
      a3 = (__int32 *)((char *)a2->i32 + v4);
    }
    v7 = v5 >= v4;
    v23 = v5 - v4;
    if (v23 != 0 && v7)
    {
      do
      {
        v25 = *v8++;
        v24 = v25;
        v26 = a2->i8[0];
        a2 = (int8x16_t *)((char *)a2 + 1);
        *(_BYTE *)a3 = v26 + v24;
        a3 = (__int32 *)((char *)a3 + 1);
        --v23;
      }
      while (v23);
    }
  }
  return result;
}

unsigned int *png_do_expand(unsigned int *result, uint64_t a2, unsigned __int16 *a3)
{
  uint64_t v3;
  int v4;
  char *v5;
  char *v6;
  int v7;
  int v8;
  int v9;
  int v10;
  char v11;
  char v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  unsigned __int8 *v16;
  _BYTE *v17;
  int v18;
  int v19;
  BOOL v20;
  _BOOL4 v21;
  uint64_t v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  char *v26;
  char *v27;
  int v28;
  char v29;
  unsigned __int8 v30;
  unsigned int v31;
  int v32;
  unsigned __int8 *v33;
  char *v34;
  int v35;
  char v36;
  uint64_t v37;
  int v38;
  unsigned __int8 *v39;
  _BYTE *v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  char *v45;
  int v46;
  char v47;
  char v48;
  uint64_t v49;
  char *v50;
  char *v51;
  int v52;
  char v53;
  char v54;
  BOOL v55;
  unint64_t v56;
  unint64_t v57;

  v3 = *result;
  if (!*((_BYTE *)result + 16))
  {
    if (a3)
      v13 = a3[4];
    else
      v13 = 0;
    v14 = *((unsigned __int8 *)result + 17);
    if (v14 > 7)
      goto LABEL_59;
    switch(v14)
    {
      case 1u:
        v13 = ((int)(v13 << 31) >> 31);
        if ((_DWORD)v3)
        {
          v32 = -(int)v3 & 7;
          v33 = (unsigned __int8 *)(a2 + ((v3 - 1) >> 3));
          v34 = (char *)(v3 + a2 - 1);
          v35 = *result;
          do
          {
            if (((*v33 >> v32) & 1) != 0)
              v36 = -1;
            else
              v36 = 0;
            *v34-- = v36;
            v37 = v32 == 7;
            if (v32 == 7)
              v32 = 0;
            else
              ++v32;
            v33 -= v37;
            --v35;
          }
          while (v35);
          goto LABEL_56;
        }
        break;
      case 2u:
        v13 = 85 * (v13 & 3);
        if ((_DWORD)v3)
        {
          v38 = ~(2 * v3 + 6) & 6;
          v39 = (unsigned __int8 *)(a2 + ((v3 - 1) >> 2));
          v40 = (_BYTE *)(v3 + a2 - 1);
          v41 = *result;
          do
          {
            *v40-- = 85 * ((*v39 >> v38) & 3);
            v20 = v38 == 6;
            v42 = v38 == 6;
            v38 += 2;
            if (v20)
              v38 = 0;
            v39 -= v42;
            --v41;
          }
          while (v41);
          goto LABEL_56;
        }
        break;
      case 4u:
        v13 = v13 & 0xF | (16 * (v13 & 0xF));
        if ((_DWORD)v3)
        {
          v15 = 4 * (*result & 1);
          v16 = (unsigned __int8 *)(a2 + ((v3 - 1) >> 1));
          v17 = (_BYTE *)(v3 + a2 - 1);
          v18 = *result;
          do
          {
            v19 = *v16 >> v15;
            v20 = v15 == 0;
            v21 = v15 == 0;
            *v17-- = v19 & 0xF | (16 * v19);
            v22 = !v20;
            v15 = 4 * v21;
            v16 -= v22;
            --v18;
          }
          while (v18);
          goto LABEL_56;
        }
        break;
      default:
LABEL_56:
        v43 = v3;
LABEL_58:
        v14 = 8;
        *((_BYTE *)result + 17) = 8;
        *((_BYTE *)result + 19) = 8;
        *((_QWORD *)result + 1) = v43;
LABEL_59:
        if (!a3)
          return result;
        if (v14 == 16)
        {
          if ((_DWORD)v3)
          {
            v49 = *((_QWORD *)result + 1);
            v50 = (char *)(a2 + 2 * v49 - 1);
            v51 = (char *)(a2 + v49 - 1);
            v52 = v3;
            do
            {
              if (*(v51 - 1) == v13 >> 8 && *v51 == v13)
                v53 = 0;
              else
                v53 = -1;
              *v50 = v53;
              *(v50 - 1) = v53;
              *(v50 - 2) = *v51;
              v54 = *(v51 - 1);
              v51 -= 2;
              *(v50 - 3) = v54;
              v50 -= 4;
              --v52;
            }
            while (v52);
          }
        }
        else if (v14 == 8 && (_DWORD)v3)
        {
          v44 = (char *)(a2 + 2 * v3 - 1);
          v45 = (char *)(v3 + a2 - 1);
          v46 = v3;
          do
          {
            if (*v45 == v13)
              v47 = 0;
            else
              v47 = -1;
            *v44 = v47;
            v48 = *v45--;
            *(v44 - 1) = v48;
            v44 -= 2;
            --v46;
          }
          while (v46);
        }
        *((_BYTE *)result + 16) = 4;
        *((_BYTE *)result + 18) = 2;
        v30 = 2 * *((_BYTE *)result + 17);
        v31 = v30;
        goto LABEL_77;
    }
    v43 = 0;
    goto LABEL_58;
  }
  if (!a3 || *((_BYTE *)result + 16) != 2)
    return result;
  v4 = *((unsigned __int8 *)result + 17);
  if (v4 == 16)
  {
    if ((_DWORD)v3)
    {
      v23 = a3[1];
      v24 = a3[2];
      v25 = a3[3];
      v26 = (char *)(a2 + 8 * v3 - 1);
      v27 = (char *)(*((_QWORD *)result + 1) + a2 - 3);
      v28 = *result;
      do
      {
        if (v23 >> 8 == *(v27 - 3)
          && *(v27 - 2) == v23
          && v24 >> 8 == *(v27 - 1)
          && *v27 == v24
          && v25 >> 8 == v27[1]
          && v27[2] == v25)
        {
          v29 = 0;
        }
        else
        {
          v29 = -1;
        }
        *v26 = v29;
        *(v26 - 1) = v29;
        *(v26 - 2) = v27[2];
        *(v26 - 3) = v27[1];
        *(v26 - 4) = *v27;
        *(v26 - 5) = *(v27 - 1);
        *(v26 - 6) = *(v27 - 2);
        *(v26 - 7) = *(v27 - 3);
        v26 -= 8;
        v27 -= 6;
        --v28;
      }
      while (v28);
    }
  }
  else if (v4 == 8 && (_DWORD)v3)
  {
    v5 = (char *)(a2 + 4 * v3 - 1);
    v6 = (char *)(a2 + *((_QWORD *)result + 1) - 1);
    v7 = *((unsigned __int8 *)a3 + 6);
    v8 = *((unsigned __int8 *)a3 + 4);
    v9 = *((unsigned __int8 *)a3 + 2);
    v10 = *result;
    do
    {
      if (*(v6 - 2) == v9 && *(v6 - 1) == v8 && *v6 == v7)
        v11 = 0;
      else
        v11 = -1;
      *v5 = v11;
      *(v5 - 1) = *v6;
      *(v5 - 2) = *(v6 - 1);
      v12 = *(v6 - 2);
      v6 -= 3;
      *(v5 - 3) = v12;
      v5 -= 4;
      --v10;
    }
    while (v10);
  }
  *((_BYTE *)result + 16) = 6;
  *((_BYTE *)result + 18) = 4;
  v30 = 4 * *((_BYTE *)result + 17);
  v31 = v30;
LABEL_77:
  *((_BYTE *)result + 19) = v30;
  v55 = v31 >= 8;
  v56 = (v30 * (unint64_t)v3 + 7) >> 3;
  v57 = v3 * (unint64_t)(v30 >> 3);
  if (!v55)
    v57 = v56;
  *((_QWORD *)result + 1) = v57;
  return result;
}

uint64_t png_do_check_palette_indexes(uint64_t result, uint64_t a2)
{
  int v2;
  BOOL v3;
  int v4;
  int v5;
  unint64_t v6;
  uint64_t v7;
  unsigned __int8 *v8;
  int v9;
  int v10;
  unsigned int v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  int v22;
  int v23;
  unsigned int v24;
  int v25;
  unsigned int v26;
  unsigned int v27;
  int v29;
  int v30;

  v2 = *(unsigned __int8 *)(a2 + 17);
  if (*(_WORD *)(result + 376))
    v3 = 1 << v2 <= *(unsigned __int16 *)(result + 376);
  else
    v3 = 1;
  if (!v3)
  {
    v4 = v2 - 1;
    v5 = -(*(_DWORD *)a2 * *(unsigned __int8 *)(a2 + 19)) & 7;
    v6 = *(_QWORD *)(result + 328);
    v7 = *(_QWORD *)(a2 + 8);
    v8 = (unsigned __int8 *)(v6 + v7);
    switch(v4)
    {
      case 0:
        if (v7 >= 1)
        {
          do
          {
            if (*v8 >> v5)
              *(_DWORD *)(result + 380) = 1;
            LOBYTE(v5) = 0;
            --v8;
          }
          while ((unint64_t)v8 > v6);
        }
        break;
      case 1:
        if (v7 >= 1)
        {
          v9 = *(_DWORD *)(result + 380);
          do
          {
            v10 = v9;
            v11 = *v8 >> v5;
            v12 = v11 & 3;
            if (v12 <= v9)
              v13 = v9;
            else
              v13 = v11 & 3;
            v14 = (v11 >> 2) & 3;
            if (v14 <= v13)
              v15 = v13;
            else
              v15 = (v11 >> 2) & 3;
            v16 = (v11 >> 4) & 3;
            if (v16 <= v15)
              v17 = v15;
            else
              v17 = (v11 >> 4) & 3;
            v18 = v11 >> 6;
            if (v18 <= v17)
              v9 = v17;
            else
              v9 = v18;
            if (v12 > v10 || v14 > v13 || v16 > v15 || v18 > v17)
              *(_DWORD *)(result + 380) = v9;
            LOBYTE(v5) = 0;
            --v8;
          }
          while ((unint64_t)v8 > v6);
        }
        break;
      case 3:
        if (v7 >= 1)
        {
          v22 = *(_DWORD *)(result + 380);
          do
          {
            v23 = v22;
            v24 = *v8 >> v5;
            v25 = v24 & 0xF;
            if (v25 <= v22)
              v26 = v22;
            else
              v26 = v24 & 0xF;
            v27 = v24 >> 4;
            if (v27 <= v26)
              v22 = v26;
            else
              v22 = v27;
            if (v25 > v23 || v27 > v26)
              *(_DWORD *)(result + 380) = v22;
            LOBYTE(v5) = 0;
            --v8;
          }
          while ((unint64_t)v8 > v6);
        }
        break;
      case 7:
        if (v7 >= 1)
        {
          v29 = *(_DWORD *)(result + 380);
          do
          {
            v30 = *v8;
            if (v29 < v30)
            {
              *(_DWORD *)(result + 380) = v30;
              v29 = v30;
            }
            --v8;
          }
          while ((unint64_t)v8 > v6);
        }
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t png_do_read_interlace(uint64_t result, uint64_t a2, int a3, int a4)
{
  uint64_t v4;
  int v5;
  int v6;
  unsigned int v7;
  unint64_t v8;
  unsigned int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  unsigned int v15;
  unsigned __int8 *v16;
  _BYTE *v17;
  int v18;
  int v19;
  BOOL v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  unsigned int v29;
  unsigned __int8 *v30;
  _BYTE *v31;
  int v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  unsigned int v41;
  unsigned __int8 *v42;
  _BYTE *v43;
  int v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  unsigned int v48;
  size_t v49;
  char *v50;
  uint64_t v51;
  int v52;
  int v53;
  BOOL v54;
  unint64_t v55;
  unint64_t v56;
  _QWORD v57[2];

  v57[1] = *MEMORY[0x1E0C80C00];
  if (!result || !a2)
    return result;
  v4 = result;
  v5 = *(_DWORD *)result;
  v6 = dword_18822D7D0[a3];
  v7 = v6 * *(_DWORD *)result;
  v8 = *(unsigned __int8 *)(result + 19);
  switch((_DWORD)v8)
  {
    case 4:
      v36 = (4 * (*(_DWORD *)result & 1)) ^ 4;
      v37 = ~(4 * v7) & 4;
      if ((a4 & 0x10000) != 0)
      {
        v38 = 4;
      }
      else
      {
        v36 = 4 * (*(_DWORD *)result & 1);
        v37 = 4 * (v7 & 1);
        v38 = 0;
      }
      if ((a4 & 0x10000) != 0)
        v39 = 0;
      else
        v39 = 4;
      if ((a4 & 0x10000) != 0)
        v40 = -4;
      else
        v40 = 4;
      if (v5)
      {
        v41 = 0;
        v42 = (unsigned __int8 *)(a2 + ((v5 - 1) >> 1));
        v43 = (_BYTE *)(a2 + ((v7 - 1) >> 1));
        if (v6 <= 1)
          v6 = 1;
        result = 3855;
        do
        {
          v44 = (*v42 >> v36) & 0xF;
          v45 = v6;
          do
          {
            *v43 = (0xF0Fu >> (4 - v37)) & *v43 | (v44 << v37);
            v20 = v37 == v39;
            v46 = v37 == v39;
            v37 += v40;
            if (v20)
              v37 = v38;
            v43 -= v46;
            --v45;
          }
          while (v45);
          v20 = v36 == v39;
          v47 = v36 == v39;
          v36 += v40;
          if (v20)
            v36 = v38;
          v42 -= v47;
          ++v41;
        }
        while (v41 < *(_DWORD *)v4);
      }
      goto LABEL_79;
    case 2:
      v23 = (2 * (_BYTE)v5 + 6) & 6 ^ 6;
      v24 = 2 * v7 + 6;
      v25 = ~v24 & 6;
      if ((a4 & 0x10000) != 0)
      {
        v23 = (2 * (_BYTE)v5 + 6) & 6;
        v25 = v24 & 6;
        v26 = 6;
      }
      else
      {
        v26 = 0;
      }
      if ((a4 & 0x10000) != 0)
        v27 = 0;
      else
        v27 = 6;
      if ((a4 & 0x10000) != 0)
        v28 = -2;
      else
        v28 = 2;
      if (v5)
      {
        v29 = 0;
        v30 = (unsigned __int8 *)(a2 + ((v5 - 1) >> 2));
        v31 = (_BYTE *)(a2 + ((v7 - 1) >> 2));
        if (v6 <= 1)
          v6 = 1;
        result = 16191;
        do
        {
          v32 = (*v30 >> v23) & 3;
          v33 = v6;
          do
          {
            *v31 = (0x3F3Fu >> (6 - v25)) & *v31 | (v32 << v25);
            v20 = v25 == v27;
            v34 = v25 == v27;
            v25 += v28;
            if (v20)
              v25 = v26;
            v31 -= v34;
            --v33;
          }
          while (v33);
          v20 = v23 == v27;
          v35 = v23 == v27;
          v23 += v28;
          if (v20)
            v23 = v26;
          v30 -= v35;
          ++v29;
        }
        while (v29 < *(_DWORD *)v4);
      }
      goto LABEL_79;
    case 1:
      v9 = v5 - 1;
      v10 = (v5 - 1) & 7;
      v11 = -v7 & 7;
      result = (v7 - 1) & 7;
      if ((a4 & 0x10000) != 0)
        v11 = (v7 - 1) & 7;
      else
        v10 ^= 7u;
      if ((a4 & 0x10000) != 0)
        v12 = 7;
      else
        v12 = 0;
      if ((a4 & 0x10000) != 0)
        v13 = 0;
      else
        v13 = 7;
      if ((a4 & 0x10000) != 0)
        v14 = -1;
      else
        v14 = 1;
      if (v5)
      {
        v15 = 0;
        v16 = (unsigned __int8 *)(a2 + (v9 >> 3));
        v17 = (_BYTE *)(a2 + ((v7 - 1) >> 3));
        if (v6 <= 1)
          v6 = 1;
        result = 32639;
        do
        {
          v18 = (*v16 >> v10) & 1;
          v19 = v6;
          do
          {
            *v17 = (0x7F7Fu >> (7 - v11)) & *v17 | (v18 << v11);
            v20 = v11 == v13;
            v21 = v11 == v13;
            v11 += v14;
            if (v20)
              v11 = v12;
            v17 -= v21;
            --v19;
          }
          while (v19);
          v20 = v10 == v13;
          v22 = v10 == v13;
          v10 += v14;
          if (v20)
            v10 = v12;
          v16 -= v22;
          ++v15;
        }
        while (v15 < *(_DWORD *)v4);
      }
      goto LABEL_79;
  }
  if (v5)
  {
    v48 = 0;
    v49 = v8 >> 3;
    v50 = (char *)(a2 + (v8 >> 3) * (unint64_t)(v7 - 1));
    v51 = a2 + (v8 >> 3) * (unint64_t)(v5 - 1);
    if (v6 <= 1)
      v52 = 1;
    else
      v52 = dword_18822D7D0[a3];
    do
    {
      v57[0] = 0;
      __memcpy_chk();
      v53 = v52;
      do
      {
        result = (uint64_t)memcpy(v50, v57, v49);
        v50 -= v49;
        --v53;
      }
      while (v53);
      v51 -= v49;
      ++v48;
    }
    while (v48 < *(_DWORD *)v4);
LABEL_79:
    LODWORD(v8) = *(unsigned __int8 *)(v4 + 19);
  }
  *(_DWORD *)v4 = v7;
  v54 = v8 >= 8;
  v55 = (v7 * (unint64_t)v8 + 7) >> 3;
  v56 = v7 * (unint64_t)(v8 >> 3);
  if (v54)
    v55 = v56;
  *(_QWORD *)(v4 + 8) = v55;
  return result;
}

uint8x8_t png_read_filter_row_avg_neon(uint64_t a1, _BYTE *a2, _BYTE *a3, uint8x8_t result, uint16x8_t a5, uint8x8_t a6, double a7, int32x2_t a8)
{
  uint64_t v8;
  int32x2_t *v9;
  int32x4_t *v10;
  uint64_t v11;
  unint64_t v12;
  int32x4_t v13;
  uint8x16_t v14;
  uint8x16_t v15;
  uint8x16_t v16;
  uint8x16_t v17;
  uint8x16_t v18;
  int8x16_t v19;
  unsigned __int32 *v20;
  unsigned __int32 v21;
  __int32 v22;

  v8 = *(_QWORD *)(a1 + 8);
  *a2 += *a3 >> 1;
  a2[1] += a3[1] >> 1;
  a2[2] += a3[2] >> 1;
  a2[3] += a3[3] >> 1;
  v9 = (int32x2_t *)(a2 + 4);
  v10 = (int32x4_t *)(a3 + 4);
  v11 = v8 - 4;
  if ((unint64_t)(v8 - 4) < 0x10)
  {
    v12 = v8 - 4;
  }
  else
  {
    a8.i32[0] = *(_DWORD *)a2;
    result = (uint8x8_t)0x706050480808080;
    a5.i32[1] = -2139062144;
    a6.i32[1] = -2139062144;
    v12 = v8 - 4;
    do
    {
      v13 = *v10++;
      v14 = (uint8x16_t)vaddq_s8((int8x16_t)vhaddq_u8((uint8x16_t)vdupq_lane_s32(*(int32x2_t *)v13.i8, 0), (uint8x16_t)vdupq_lane_s32(a8, 0)), (int8x16_t)vdupq_lane_s32(*v9, 0));
      v15 = (uint8x16_t)vdupq_lane_s32(*(int32x2_t *)v13.i8, 1);
      v15.i32[0] = v14.i32[0];
      v16 = (uint8x16_t)vaddq_s8(vqtbl1q_s8(*(int8x16_t *)v9->i8, (int8x16_t)xmmword_18822DA80), (int8x16_t)vhaddq_u8(v14, v15));
      v15.i64[0] = v16.i64[0];
      v15.i64[1] = vdupq_laneq_s32(v13, 2).i64[1];
      v17 = (uint8x16_t)vaddq_s8(vqtbl1q_s8(*(int8x16_t *)v9->i8, (int8x16_t)xmmword_18822DA90), (int8x16_t)vhaddq_u8(v16, v15));
      v18 = v17;
      v18.i32[3] = v13.i32[3];
      v19 = vaddq_s8(vqtbl1q_s8(*(int8x16_t *)v9->i8, (int8x16_t)xmmword_18822DAA0), (int8x16_t)vhaddq_u8(v17, v18));
      *(int8x16_t *)v9->i8 = v19;
      v9 += 2;
      a8 = (int32x2_t)vextq_s8(v19, (int8x16_t)0, 0xCuLL).u64[0];
      v12 -= 16;
    }
    while (v12 > 0xF);
  }
  if (v12 >= 4)
  {
    v20 = (unsigned __int32 *)&a2[v11 & 0xFFFFFFFFFFFFFFF0];
    do
    {
      result.i32[0] = v9->i32[0];
      v21 = *v20++;
      a5.i32[0] = v21;
      a5 = vmovl_u8(*(uint8x8_t *)a5.i8);
      v22 = v10->i32[0];
      v10 = (int32x4_t *)((char *)v10 + 4);
      a6.i32[0] = v22;
      a6 = (uint8x8_t)vmovl_u8(a6).u64[0];
      *(uint16x4_t *)a5.i8 = vhadd_u16((uint16x4_t)a6, *(uint16x4_t *)a5.i8);
      result = (uint8x8_t)vmovn_s16((int16x8_t)vaddw_u8(a5, result));
      v9->i32[0] = result.i32[0];
      v9 = (int32x2_t *)((char *)v9 + 4);
      v12 -= 4;
    }
    while (v12 > 3);
  }
  return result;
}

uint64_t _cg_png_set_row_number(uint64_t result, int a2)
{
  *(_DWORD *)(result + 308) = a2;
  return result;
}

uint64_t _cg_png_set_idat_size(uint64_t result, int a2)
{
  *(_DWORD *)(result + 360) = a2;
  return result;
}

uint64_t png_init_filter_functions_apple(_QWORD *a1, int a2)
{
  void *v4;
  uint64_t result;

  a1[122] = png_read_filter_row_up_apple_vector;
  a1[121] = png_read_filter_row_sub_apple_neon;
  if (a2 == 4)
  {
    a1[124] = png_read_filter_row_paeth4_apple;
    a1[121] = png_read_filter_row_sub4_a64;
    v4 = png_read_filter_row_avg4_a64;
  }
  else
  {
    if (a2 != 3)
      goto LABEL_6;
    a1[124] = png_read_filter_row_paeth3_apple;
    v4 = png_read_filter_row_avg3_apple;
  }
  a1[123] = v4;
LABEL_6:
  result = AppleGetCPUCapabilities();
  if (a2 == 4 && (result & 0x100) != 0)
  {
    a1[121] = png_read_filter_row_sub_neon;
    a1[122] = png_read_filter_row_up_4bpp_neon;
    a1[123] = png_read_filter_row_avg_neon;
    a1[124] = png_read_filter_row_paeth_neon;
  }
  return result;
}

uint64_t png_init_filter_functions(uint64_t a1)
{
  unsigned int v1;
  int v2;
  void *v3;

  v1 = *(unsigned __int8 *)(a1 + 394) + 7;
  *(_QWORD *)(a1 + 968) = png_read_filter_row_sub;
  *(_QWORD *)(a1 + 976) = png_read_filter_row_up;
  *(_QWORD *)(a1 + 984) = png_read_filter_row_avg;
  v2 = v1 >> 3;
  if (v1 >> 3 == 1)
    v3 = png_read_filter_row_paeth_1byte_pixel;
  else
    v3 = png_read_filter_row_paeth_multibyte_pixel;
  *(_QWORD *)(a1 + 992) = v3;
  return png_init_filter_functions_apple((_QWORD *)a1, v2);
}

uint64_t IIOImageRead::getCGDataProviderBytesAtOffset(IIOImageRead *this, void *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t Bytes;
  BOOL v13;
  _BYTE v14[8192];
  uint64_t v15;

  v2 = MEMORY[0x1E0C80A78](this, a2);
  v4 = v3;
  v6 = v5;
  v7 = v2;
  v15 = *MEMORY[0x1E0C80C00];
  v8 = CGAccessSessionCreate();
  if (v6)
  {
    if ((gIIODebugFlags & 0x800000) != 0)
      ImageIOLog("    %s:%d:  dataProvider %p skip offset: 0x%08lX\n", "getCGDataProviderBytesAtOffset", 1305, *(const void **)(v7 + 40), v6);
    if (*(_QWORD *)(v7 + 80) == -1)
    {
      bzero(v14, 0x2000uLL);
      v11 = v6;
      do
      {
        Bytes = CGAccessSessionGetBytes();
        v11 -= Bytes;
        if (Bytes)
          v13 = v11 == 0;
        else
          v13 = 1;
      }
      while (!v13);
      if (v11)
      {
        v9 = 0;
        if (!v8)
          return v9;
        goto LABEL_9;
      }
    }
    else
    {
      CGAccessSessionSkipForward();
    }
  }
  if ((gIIODebugFlags & 0x800000) != 0)
    ImageIOLog("    %s:%d:  dataProvider %p read offset: 0x%08lX   size: %8ld\n", "getCGDataProviderBytesAtOffset", 1328, *(const void **)(v7 + 40), v6, v4);
  v9 = CGAccessSessionGetBytes();
  if (v8)
LABEL_9:
    CGAccessSessionRelease();
  return v9;
}

uint64_t png_app_error(uint64_t a1, char *a2)
{
  if ((*(_BYTE *)(a1 + 82) & 0x40) == 0)
    _cg_png_error((void (**)(void))a1, a2);
  return png_warning(a1, a2);
}

uint64_t CGImageMetadataTagKeyRetainCallback(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  unsigned int *v3;
  unsigned int v4;

  result = a2;
  v3 = (unsigned int *)(a2 + 16);
  do
    v4 = __ldaxr(v3);
  while (__stlxr(v4 + 1, v3));
  return result;
}

_QWORD *png_zalloc(_QWORD *result, unsigned int a2, unsigned int a3)
{
  if (result)
    return png_malloc_warn(result, a3 * (unint64_t)a2);
  return result;
}

CGImage *CGImageGetImageSource(CGImage *a1)
{
  const __CFData *Property;
  IIOImageRead *Source;
  IIOImagePlus *v4;
  UInt8 buffer[8];
  CFRange v7;

  IIOInitDebugFlags();
  if ((~(_DWORD)gIIODebugFlags & 0xC000) == 0)
    ImageIODebugOptions(3, "S", "CGImageGetImageSource", 0, 0, -1, 0);
  if (!a1)
  {
    _cg_jpeg_mem_term("CGImageGetImageSource", 5673, "*** ERROR: CGImageGetImageSource - image is NULL\n");
    return a1;
  }
  if (ERROR_CGImageCopyImageSource_WAS_CALLED_WITH_INVALID_CGIMAGE(a1))
    return 0;
  Property = (const __CFData *)CGImageGetProperty();
  if (!Property)
    return 0;
  *(_QWORD *)buffer = 0;
  v7.location = 0;
  v7.length = 8;
  CFDataGetBytes(Property, v7, buffer);
  Source = (IIOImageRead *)CGImageSourceGetSource(*(uint64_t *)buffer);
  if (!Source)
    return 0;
  v4 = Source;
  IIOImageRead::lock(Source);
  a1 = (CGImage *)IIOImagePlus::isr(v4);
  if (!CGTrackImageSource((unint64_t)a1, 0))
  {
    IIOImageRead::unlock(v4);
    return 0;
  }
  CFRetain(a1);
  IIOImageRead::unlock(v4);
  if (a1)
    CFAutorelease(a1);
  return a1;
}

BOOL ERROR_CGImageCopyImageSource_WAS_CALLED_WITH_INVALID_CGIMAGE(CGImage *a1)
{
  CFTypeID v1;

  if (a1)
  {
    v1 = CFGetTypeID(a1);
    return v1 != CGImageGetTypeID();
  }
  else
  {
    return 1;
  }
}

uint64_t _CGImageSourceFinalize(CGImageSource *a1)
{
  unint64_t v2;
  unsigned int v3;
  uint64_t result;
  uint64_t v5;
  IIO_Reader *v6;
  IIOImageRead *Source;
  IIOImageRead *v8;

  do
    v2 = __ldxr(&gISRCount);
  while (__stxr(v2 - 1, &gISRCount));
  v3 = (gIIODebugFlags >> 12) & 3;
  if (v3)
    ImageIODebugOptions(v3, "A", "_CGImageSourceFinalize", a1, 0, -1, 0);
  result = CGTrackImageSource((unint64_t)a1, -1);
  v5 = *((_QWORD *)a1 + 3);
  if (v5)
  {
    v6 = *(IIO_Reader **)(v5 + 80);
    if (v6)
      IIO_Reader::osType(v6);
    kdebug_trace();
    Source = (IIOImageRead *)CGImageSourceGetSource(*(_QWORD *)(*((_QWORD *)a1 + 3) + 16));
    if (Source)
    {
      v8 = Source;
      IIOImageRead::lock(Source);
      IIOImageRead::setISR(v8, 0);
      IIOImageRead::unlock(v8);
    }
    result = *((_QWORD *)a1 + 3);
    if (result)
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  *((_QWORD *)a1 + 2) = 0;
  *((_QWORD *)a1 + 3) = 0;
  return result;
}

uint64_t CGImageSourceRefCreateWith_ImageSource(uint64_t a1)
{
  unint64_t Instance;
  uint64_t v3;
  unint64_t v4;
  IIOImageRead *Source;
  IIOImageRead *v6;

  if (CGImageSourceGetTypeID::once != -1)
    dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_139);
  Instance = _CFRuntimeCreateInstance();
  v3 = Instance;
  *(_DWORD *)(Instance + 16) = 1;
  do
    v4 = __ldxr(&gISRCount);
  while (__stxr(v4 + 1, &gISRCount));
  CGTrackImageSource(Instance, 1);
  *(_QWORD *)(v3 + 24) = a1;
  *(_QWORD *)(a1 + 8) = v3;
  Source = (IIOImageRead *)CGImageSourceGetSource(*(_QWORD *)(a1 + 16));
  if (Source)
  {
    v6 = Source;
    IIOImageRead::lock(Source);
    IIOImageRead::setISR(v6, v3);
    IIOImageRead::unlock(v6);
  }
  return v3;
}

uint64_t IIOImageRead::unlock(IIOImageRead *this)
{
  return pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 376));
}

uint64_t IIOImageRead::lock(IIOImageRead *this)
{
  return pthread_mutex_lock((pthread_mutex_t *)((char *)this + 376));
}

BOOL CGTrackImageSource(unint64_t a1, int a2)
{
  uint64_t v4;
  unint64_t v5;
  _BOOL8 v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  unint64_t v10;
  BOOL v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  unint64_t v17;
  BOOL v18;
  _QWORD *v19;
  unint64_t v21;
  unint64_t *v22;

  os_unfair_lock_lock((os_unfair_lock_t)&CGTrackImageSource(CGImageSource *,int)::mutex);
  v4 = CGTrackImageSource(CGImageSource *,int)::gImageSources;
  if (!CGTrackImageSource(CGImageSource *,int)::gImageSources)
  {
    v4 = operator new();
    *(_QWORD *)(v4 + 16) = 0;
    *(_QWORD *)(v4 + 8) = 0;
    *(_QWORD *)v4 = v4 + 8;
    CGTrackImageSource(CGImageSource *,int)::gImageSources = v4;
  }
  v5 = ~a1;
  v21 = ~a1;
  if (a2 == -1)
  {
    v7 = v4 + 8;
    v8 = *(_QWORD **)(v4 + 8);
    if (!v8)
      goto LABEL_18;
    v9 = v4 + 8;
    do
    {
      v10 = v8[4];
      v11 = v10 >= v5;
      if (v10 >= v5)
        v12 = v8;
      else
        v12 = v8 + 1;
      if (v11)
        v9 = (uint64_t)v8;
      v8 = (_QWORD *)*v12;
    }
    while (*v12);
    if (v9 == v7 || *(_QWORD *)(v9 + 32) > v5)
LABEL_18:
      v9 = v4 + 8;
    v6 = v9 != v7;
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__erase_unique<unsigned long>(v4, &v21);
  }
  else if (a2)
  {
    if (a2 == 1)
    {
      v22 = &v21;
      v6 = 1;
      std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>((uint64_t **)v4, &v21, (uint64_t)&std::piecewise_construct, (uint64_t **)&v22)[5] = 1;
    }
    else
    {
      v6 = 0;
    }
  }
  else
  {
    v15 = *(_QWORD **)(v4 + 8);
    v13 = v4 + 8;
    v14 = v15;
    if (!v15)
      goto LABEL_31;
    v16 = (_QWORD *)v13;
    do
    {
      v17 = v14[4];
      v18 = v17 >= v5;
      if (v17 >= v5)
        v19 = v14;
      else
        v19 = v14 + 1;
      if (v18)
        v16 = v14;
      v14 = (_QWORD *)*v19;
    }
    while (*v19);
    if (v16 == (_QWORD *)v13 || v16[4] > v5)
LABEL_31:
      v16 = (_QWORD *)v13;
    v6 = v16 != (_QWORD *)v13;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&CGTrackImageSource(CGImageSource *,int)::mutex);
  return v6;
}

uint64_t *std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  uint64_t *v6;
  uint64_t **v7;
  unint64_t v8;
  uint64_t **v9;
  unint64_t v10;
  uint64_t *v11;

  v7 = a1 + 1;
  v6 = a1[1];
  if (v6)
  {
    v8 = *a2;
    while (1)
    {
      while (1)
      {
        v9 = (uint64_t **)v6;
        v10 = v6[4];
        if (v8 >= v10)
          break;
        v6 = *v9;
        v7 = v9;
        if (!*v9)
          goto LABEL_10;
      }
      if (v10 >= v8)
        break;
      v6 = v9[1];
      if (!v6)
      {
        v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v9 = a1 + 1;
LABEL_10:
    v11 = (uint64_t *)operator new(0x30uLL);
    v11[4] = **a4;
    v11[5] = 0;
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__insert_node_at(a1, (uint64_t)v9, v7, v11);
    return v11;
  }
  return (uint64_t *)v9;
}

uint64_t *std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  uint64_t *v5;
  uint64_t *result;

  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__erase_unique<unsigned long>(uint64_t a1, unint64_t *a2)
{
  _QWORD *v2;
  unint64_t v3;
  uint64_t *v4;
  unint64_t v5;
  BOOL v6;
  _QWORD *v7;

  v2 = *(_QWORD **)(a1 + 8);
  if (!v2)
    return 0;
  v3 = *a2;
  v4 = (uint64_t *)(a1 + 8);
  do
  {
    v5 = v2[4];
    v6 = v5 >= v3;
    if (v5 >= v3)
      v7 = v2;
    else
      v7 = v2 + 1;
    if (v6)
      v4 = v2;
    v2 = (_QWORD *)*v7;
  }
  while (*v7);
  if (v4 == (uint64_t *)(a1 + 8) || v3 < v4[4])
    return 0;
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__remove_node_pointer((uint64_t **)a1, v4);
  operator delete(v4);
  return 1;
}

uint64_t *std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__remove_node_pointer(uint64_t **a1, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  BOOL v5;
  uint64_t *v6;

  v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      v3 = v2;
      v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    v4 = a2;
    do
    {
      v3 = (uint64_t *)v4[2];
      v5 = *v3 == (_QWORD)v4;
      v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2)
    *a1 = v3;
  v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v6, a2);
  return v3;
}

void IIOImageSource::~IIOImageSource(IIOImageSource *this)
{
  IIOImageSource::~IIOImageSource(this);
  JUMPOUT(0x18D761C30);
}

{
  uint64_t v2;
  IIOImageRead *Source;
  const __CFArray *v4;
  const __CFArray *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  uint64_t v10;
  uint64_t v11;
  const void *v12;
  const void *v13;
  void *v14;
  void *v15;
  CFRange v16;

  *(_QWORD *)this = &off_1E1BAE3E0;
  if (*((_QWORD *)this + 2))
  {
    IIOImageSource::unmapData(this);
    v2 = *((_QWORD *)this + 2);
    if (v2 != *MEMORY[0x1E0C9B0D0])
    {
      Source = (IIOImageRead *)CGImageSourceGetSource(v2);
      IIOImageRead::lock(Source);
      IIOImageRead::setISR(Source, 0);
      IIOImageRead::unlock(Source);
      CFRelease(*((CFTypeRef *)this + 2));
    }
    *((_QWORD *)this + 2) = 0;
  }
  v4 = (const __CFArray *)*((_QWORD *)this + 18);
  if (v4 && CFArrayGetCount(v4))
  {
    v5 = (const __CFArray *)*((_QWORD *)this + 18);
    v16.length = CFArrayGetCount(v5);
    v16.location = 0;
    CFArrayApplyFunction(v5, v16, (CFArrayApplierFunction)releaseUnusedImageProvider, 0);
  }
  v6 = (const void *)*((_QWORD *)this + 20);
  if (v6)
  {
    CFRelease(v6);
    *((_QWORD *)this + 20) = 0;
  }
  v7 = (const void *)*((_QWORD *)this + 21);
  if (v7)
  {
    CFRelease(v7);
    *((_QWORD *)this + 21) = 0;
  }
  v8 = (const void *)*((_QWORD *)this + 18);
  if (v8)
  {
    CFRelease(v8);
    *((_QWORD *)this + 18) = 0;
  }
  v9 = (const void *)*((_QWORD *)this + 7);
  if (v9)
  {
    CFRelease(v9);
    *((_QWORD *)this + 7) = 0;
  }
  v10 = *((_QWORD *)this + 12);
  if (v10)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
    *((_QWORD *)this + 12) = 0;
  }
  v11 = *((_QWORD *)this + 13);
  if (v11)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
    *((_QWORD *)this + 13) = 0;
  }
  v12 = (const void *)*((_QWORD *)this + 14);
  if (v12)
  {
    CFRelease(v12);
    *((_QWORD *)this + 14) = 0;
  }
  v13 = (const void *)*((_QWORD *)this + 19);
  if (v13)
  {
    CFRelease(v13);
    *((_QWORD *)this + 19) = 0;
  }
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 200));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 264));
  v14 = (void *)*((_QWORD *)this + 22);
  if (v14)
  {
    *((_QWORD *)this + 23) = v14;
    operator delete(v14);
  }
  v15 = (void *)*((_QWORD *)this + 15);
  if (v15)
  {
    *((_QWORD *)this + 16) = v15;
    operator delete(v15);
  }
}

const char *IIOImageRead::unmapData(const char *this)
{
  const char *v1;
  int v2;
  CFIndex v3;
  const void *v4;
  uint64_t v5;

  v1 = this;
  if ((gIIODebugFlags & 0x100000000000) != 0)
    this = ImageIOLog("    %s: <IIOImageRead: %p> un-mmapping data <CFData:%p>  count: %d\n", "unmapData", this, *((const void **)this + 4), *((_DWORD *)this + 110));
  if (*((_QWORD *)v1 + 4) && v1[67])
  {
    pthread_mutex_lock((pthread_mutex_t *)(v1 + 376));
    if (v1[67])
    {
      v2 = *((_DWORD *)v1 + 110) - 1;
      *((_DWORD *)v1 + 110) = v2;
      if ((gIIODebugFlags & 0x100000000000) != 0)
      {
        v3 = CFGetRetainCount(*((CFTypeRef *)v1 + 4));
        ImageIOLog("    %s:                  new count: %d   (rc=%ld)\n", "unmapData", v2, v3);
        v2 = *((_DWORD *)v1 + 110);
      }
      if (v2 <= 0)
      {
        v4 = (const void *)*((_QWORD *)v1 + 4);
        if (v4)
        {
          v5 = gIIODebugFlags;
          if ((gIIODebugFlags & 0x100000000000) != 0)
          {
            ImageIOLog("    %s:                  CFRelease: <CFData:%p>\n", "unmapData", v4);
            v5 = gIIODebugFlags;
            v4 = (const void *)*((_QWORD *)v1 + 4);
          }
          if ((v5 & 0x80000000000) != 0)
          {
            ImageIOLog("D   %s:%d CFRelease %p\n", "unmapData", 994, v4);
            v4 = (const void *)*((_QWORD *)v1 + 4);
          }
          CFRelease(v4);
          *((_QWORD *)v1 + 4) = 0;
        }
      }
    }
    return (const char *)pthread_mutex_unlock((pthread_mutex_t *)(v1 + 376));
  }
  return this;
}

const char *IIOImageSource::unmapData(IIOImageSource *this)
{
  const char *result;

  result = (const char *)CGImageSourceGetSource(*((_QWORD *)this + 2));
  if (result)
    return IIOImageRead::unmapData(result);
  return result;
}

void AdobeXMPCore_Int::NameSpacePrefixMapImpl::~NameSpacePrefixMapImpl(AdobeXMPCore_Int::NameSpacePrefixMapImpl *this, uint64_t *a2)
{
  uint64_t v3;

  v3 = *a2;
  *(_QWORD *)this = *a2;
  *(_QWORD *)((char *)this + *(_QWORD *)(v3 - 176)) = a2[1];
  *(_QWORD *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 48)) = a2[2];
  *(_QWORD *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 56)) = a2[3];
  *(_QWORD *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 64)) = a2[4];
  *(_QWORD *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 72)) = a2[5];
  *(_QWORD *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 80)) = a2[6];
  *(_QWORD *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 88)) = a2[7];
  *(_QWORD *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 184)) = a2[8];
  *(_QWORD *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 200)) = a2[9];
  std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::destroy((uint64_t)this + 32, *((_QWORD **)this + 5));
  std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::destroy((uint64_t)this + 8, *((_QWORD **)this + 2));
}

uint64_t std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::destroy(uint64_t result, _QWORD *a2)
{
  uint64_t v3;
  AdobeXMPCore_Int::IMemoryAllocator_I *v4;
  uint64_t MemoryAllocator;

  if (a2)
  {
    v3 = result;
    std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::destroy(result, *a2);
    std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::destroy(v3, a2[1]);
    std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100]((uint64_t)(a2 + 6));
    v4 = (AdobeXMPCore_Int::IMemoryAllocator_I *)std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100]((uint64_t)(a2 + 4));
    MemoryAllocator = AdobeXMPCore_Int::IMemoryAllocator_I::GetMemoryAllocator(v4);
    return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)MemoryAllocator + 8))(MemoryAllocator, a2);
  }
  return result;
}

uint64_t AdobeXMPCore_Int::NameSpacePrefixMapImpl::Insert(uint64_t **this, char *a2, const char *a3, char *a4, size_t a5)
{
  const char *v5;
  int64_t v7;
  uint64_t v10;
  int v11;
  char *v12;
  _QWORD *exception;
  const char *v14;
  int v15;
  unsigned int v17;
  unsigned int v18;
  BOOL v21;
  uint64_t **v22;
  uint64_t *v23;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  uint64_t **v30;
  uint64_t *v31;
  unint64_t v32;
  unint64_t *v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  uint64_t *v38;
  uint64_t *v39;
  std::__shared_weak_count *v40;
  unint64_t *v41;
  unint64_t v42;
  std::__shared_weak_count *v43;
  unint64_t *v44;
  unint64_t v45;
  _BYTE v47[24];
  unint64_t v48[2];
  __int128 v49;
  __int128 v50;
  unsigned int v51[2];

  v5 = (const char *)a5;
  v7 = (int64_t)a3;
  v10 = AdobeXMPCore_Int::VerifyParameters((AdobeXMPCore_Int *)1, 1, a2, a4, a3, a5);
  if ((_DWORD)v10)
  {
    if (a2 && v7 == -1)
      v7 = strlen(a2);
    if (a4 && v5 == (const char *)-1)
      v5 = (const char *)strlen(a4);
    if (v7 <= 0)
    {
      exception = __cxa_allocate_exception(0x18uLL);
      v14 = "Empty XML name";
LABEL_93:
      *(_DWORD *)exception = 102;
      exception[1] = v14;
      *((_BYTE *)exception + 16) = 0;
    }
    if (*a2 < 0)
    {
      v51[0] = 0;
      v48[0] = 0;
      CodePoint_from_UTF8(a2, 4uLL, v51, v48);
      v12 = &a2[v48[0]];
      if (v51[0] - 192 >= 0x17
        && v51[0] - 216 >= 0x1F
        && v51[0] - 248 >= 0x208
        && v51[0] - 880 >= 0xE
        && v51[0] - 895 >= 0x1C81
        && (v51[0] & 0xFFFFFFFE) != 0x200C
        && v51[0] - 8304 >= 0x120
        && v51[0] - 11264 >= 0x3F0
        && v51[0] - 12289 >= 0xA7FF
        && v51[0] - 63744 >= 0x4D0
        && v51[0] - 65008 >= 0x20E
        && (v51[0] - 0x10000) >> 17 > 6)
      {
        goto LABEL_13;
      }
    }
    else
    {
      v11 = *a2;
      v12 = a2 + 1;
      if ((v11 - 97) >= 0x1A && v11 != 95 && (v11 - 65) >= 0x1A)
      {
LABEL_13:
        exception = __cxa_allocate_exception(0x18uLL);
        v14 = "Bad XML name";
        goto LABEL_93;
      }
    }
    while (v12 < &a2[v7])
    {
      if (*v12 < 0)
      {
        v51[0] = 0;
        v48[0] = 0;
        CodePoint_from_UTF8(v12, 4uLL, v51, v48);
        v12 += v48[0];
        if (v51[0] - 192 >= 0x17 && v51[0] - 216 >= 0x1F)
        {
          v21 = v51[0] - 248 >= 0x208 && v51[0] - 880 >= 0xE;
          if (v21
            && v51[0] - 895 >= 0x1C81
            && (v51[0] & 0xFFFFFFFE) != 0x200C
            && v51[0] - 8304 >= 0x120
            && v51[0] - 11264 >= 0x3F0
            && v51[0] - 12289 >= 0xA7FF
            && v51[0] - 63744 >= 0x4D0
            && v51[0] - 768 >= 0x70
            && v51[0] - 65008 >= 0x20E
            && v51[0] - 0x10000 >= 0xE0000
            && v51[0] - 8255 >= 2
            && v51[0] != 183)
          {
            goto LABEL_13;
          }
        }
      }
      else
      {
        v15 = *v12++;
        if ((v15 - 97) >= 0x1A && v15 != 95 && (v15 - 65) >= 0x1A)
        {
          v17 = v15 - 48;
          v18 = v15 - 45;
          if (v17 >= 0xA && v18 >= 2)
            goto LABEL_13;
        }
      }
    }
    v50 = 0uLL;
    AdobeXMPCore_Int::IUTF8String_I::CreateUTF8String((AdobeXMPCore_Int::IUTF8String_I *)a2, (const char *)v7, (uint64_t *)&v49);
    v50 = v49;
    v49 = 0uLL;
    AdobeXMPCore_Int::IUTF8String_I::CreateUTF8String((AdobeXMPCore_Int::IUTF8String_I *)a4, v5, (uint64_t *)v48);
    v49 = *(_OWORD *)v48;
    AdobeXMPCore_Int::AutoSharedLock::AutoSharedLock(v47, (char *)this + *(*this - 25) + 8, 1);
    AdobeXMPCore_Int::AutoSharedLock::~AutoSharedLock((AdobeXMPCore_Int::AutoSharedLock *)v47);
    v22 = this + 4;
    if (this + 5 != std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::find<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>((uint64_t)(this + 4), &v50))
    {
      v48[0] = 0;
      v48[1] = 0;
      *(_QWORD *)v51 = &v50;
      v23 = std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::__emplace_unique_key_args<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const> const&>,std::tuple<>>(this + 4, &v50, (uint64_t)&std::piecewise_construct, (uint64_t **)v51);
      v24 = v23[7];
      v48[0] = v23[6];
      v48[1] = v24;
      if (v24)
      {
        v25 = (unint64_t *)(v24 + 8);
        do
          v26 = __ldxr(v25);
        while (__stxr(v26 + 1, v25));
      }
      std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::__erase_unique<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>(this + 4, &v50);
      std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::__erase_unique<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>(this + 1, v48);
      v27 = (std::__shared_weak_count *)v48[1];
      if (v48[1])
      {
        v28 = (unint64_t *)(v48[1] + 8);
        do
          v29 = __ldaxr(v28);
        while (__stlxr(v29 - 1, v28));
        if (!v29)
        {
          ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
          std::__shared_weak_count::__release_weak(v27);
        }
      }
    }
    v30 = this + 1;
    if (this + 2 != std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::find<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>((uint64_t)(this + 1), &v49))
    {
      *(_QWORD *)v51 = &v49;
      v31 = std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::__emplace_unique_key_args<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const> const&>,std::tuple<>>(this + 1, &v49, (uint64_t)&std::piecewise_construct, (uint64_t **)v51);
      v32 = v31[7];
      v48[0] = v31[6];
      v48[1] = v32;
      if (v32)
      {
        v33 = (unint64_t *)(v32 + 8);
        do
          v34 = __ldxr(v33);
        while (__stxr(v34 + 1, v33));
      }
      std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::__erase_unique<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>(this + 4, v48);
      std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::__erase_unique<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>(this + 1, &v49);
      v35 = (std::__shared_weak_count *)v48[1];
      if (v48[1])
      {
        v36 = (unint64_t *)(v48[1] + 8);
        do
          v37 = __ldaxr(v36);
        while (__stlxr(v37 - 1, v36));
        if (!v37)
        {
          ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
          std::__shared_weak_count::__release_weak(v35);
        }
      }
    }
    v48[0] = (unint64_t)&v49;
    v38 = std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::__emplace_unique_key_args<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const> const&>,std::tuple<>>(v30, &v49, (uint64_t)&std::piecewise_construct, (uint64_t **)v48);
    std::shared_ptr<IIOBaseObject>::operator=[abi:ne180100](v38 + 6, (uint64_t *)&v50);
    v48[0] = (unint64_t)&v50;
    v39 = std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::__emplace_unique_key_args<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const> const&>,std::tuple<>>(v22, &v50, (uint64_t)&std::piecewise_construct, (uint64_t **)v48);
    std::shared_ptr<IIOBaseObject>::operator=[abi:ne180100](v39 + 6, (uint64_t *)&v49);
    v40 = (std::__shared_weak_count *)*((_QWORD *)&v49 + 1);
    if (*((_QWORD *)&v49 + 1))
    {
      v41 = (unint64_t *)(*((_QWORD *)&v49 + 1) + 8);
      do
        v42 = __ldaxr(v41);
      while (__stlxr(v42 - 1, v41));
      if (!v42)
      {
        ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
        std::__shared_weak_count::__release_weak(v40);
      }
    }
    v43 = (std::__shared_weak_count *)*((_QWORD *)&v50 + 1);
    if (*((_QWORD *)&v50 + 1))
    {
      v44 = (unint64_t *)(*((_QWORD *)&v50 + 1) + 8);
      do
        v45 = __ldaxr(v44);
      while (__stlxr(v45 - 1, v44));
      if (!v45)
      {
        ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
        std::__shared_weak_count::__release_weak(v43);
      }
    }
  }
  return v10;
}

void sub_187E3BF18()
{
  __break(1u);
}

void sub_187E3C080(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v6;
  va_list va;
  uint64_t v8;
  va_list va1;

  va_start(va1, a6);
  va_start(va, a6);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100]((uint64_t)va);
  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  __cxa_end_catch();
  JUMPOUT(0x187E3C0A0);
}

_QWORD *std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::find<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v5;
  _QWORD *v6;
  _BOOL4 v7;
  _QWORD *v8;

  v2 = (_QWORD *)(a1 + 8);
  v3 = *(_QWORD **)(a1 + 8);
  if (!v3)
    return v2;
  v5 = a1 + 16;
  v6 = (_QWORD *)(a1 + 8);
  do
  {
    v7 = AdobeXMPCore_Int::IUTF8StringComparator::operator()(v5, v3 + 4, a2);
    v8 = v3 + 1;
    if (!v7)
    {
      v8 = v3;
      v6 = v3;
    }
    v3 = (_QWORD *)*v8;
  }
  while (*v8);
  if (v6 == v2 || AdobeXMPCore_Int::IUTF8StringComparator::operator()(v5, a2, v6 + 4))
    return v2;
  return v6;
}

uint64_t *std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::__emplace_unique_key_args<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const> const&>,std::tuple<>>(uint64_t **a1, _QWORD *a2, uint64_t a3, uint64_t **a4)
{
  AdobeXMPCore_Int::IMemoryAllocator_I *v6;
  uint64_t *v7;
  uint64_t **v8;
  uint64_t (***MemoryAllocator)(_QWORD, uint64_t);
  uint64_t *v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v15;

  v15 = 0;
  v6 = (AdobeXMPCore_Int::IMemoryAllocator_I *)std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::__find_equal<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>((uint64_t)a1, &v15, a2);
  v7 = *(uint64_t **)v6;
  if (!*(_QWORD *)v6)
  {
    v8 = (uint64_t **)v6;
    MemoryAllocator = (uint64_t (***)(_QWORD, uint64_t))AdobeXMPCore_Int::IMemoryAllocator_I::GetMemoryAllocator(v6);
    v10 = (uint64_t *)(**MemoryAllocator)(MemoryAllocator, 64);
    v7 = v10;
    v11 = (*a4)[1];
    v10[4] = **a4;
    v10[5] = v11;
    if (v11)
    {
      v12 = (unint64_t *)(v11 + 8);
      do
        v13 = __ldxr(v12);
      while (__stxr(v13 + 1, v12));
    }
    v10[6] = 0;
    v10[7] = 0;
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__insert_node_at(a1, v15, v8, v10);
  }
  return v7;
}

_QWORD *std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::__find_equal<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD **)(a1 + 8);
  if (v4)
  {
    v7 = a1 + 16;
    do
    {
      while (1)
      {
        v8 = v4;
        v9 = v4 + 4;
        if (!AdobeXMPCore_Int::IUTF8StringComparator::operator()(v7, a3, v4 + 4))
          break;
        v4 = (_QWORD *)*v8;
        v5 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (!AdobeXMPCore_Int::IUTF8StringComparator::operator()(v7, v9, a3))
        break;
      v5 = v8 + 1;
      v4 = (_QWORD *)v8[1];
    }
    while (v4);
  }
  else
  {
    v8 = (_QWORD *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

BOOL AdobeXMPCore_Int::IUTF8StringComparator::operator()(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  unint64_t v5;
  unint64_t v6;
  const char *v7;
  const char *v8;
  size_t v9;
  unsigned int v10;
  BOOL v11;

  v5 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a2 + 208))(*a2);
  v6 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a3 + 208))(*a3);
  v7 = (const char *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)*a2 + 192))(*a2);
  v8 = (const char *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)*a3 + 192))(*a3);
  if (v6 >= v5)
    v9 = v5;
  else
    v9 = v6;
  v10 = strncmp(v7, v8, v9);
  if (v10)
    v11 = 1;
  else
    v11 = v5 == v6;
  if (v11)
    return v10 >> 31;
  else
    return v5 < v6;
}

uint64_t AdobeXMPCore_Int::UTF8StringImpl::c_str(AdobeXMPCore_Int::UTF8StringImpl *this)
{
  uint64_t result;

  result = (uint64_t)this + 24;
  if (*((char *)this + 47) < 0)
    return *(_QWORD *)result;
  return result;
}

uint64_t AdobeXMPCore_Int::UTF8StringImpl::size(AdobeXMPCore_Int::UTF8StringImpl *this)
{
  if (*((char *)this + 47) < 0)
    return *((_QWORD *)this + 4);
  else
    return *((unsigned __int8 *)this + 47);
}

void AdobeXMPCore_Int::IUTF8String_I::CreateUTF8String(AdobeXMPCore_Int::IUTF8String_I *this@<X0>, const char *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  uint64_t v15;

  v14 = 0;
  v15 = 0;
  v6 = AdobeXMPCore_Int::MemoryManagedObject::operator new((AdobeXMPCore_Int::MemoryManagedObject *)0x50);
  *(_QWORD *)(v6 + 64) = 0;
  *(_QWORD *)(v6 + 72) = 0;
  *(_QWORD *)(v6 + 16) = 0;
  *(_QWORD *)(v6 + 24) = 0;
  *(_QWORD *)v6 = off_1E1BB7368;
  *(_QWORD *)(v6 + 8) = 0;
  *(_QWORD *)(v6 + 48) = off_1E1BB7518;
  *(_QWORD *)(v6 + 56) = off_1E1BB7580;
  *(_QWORD *)(v6 + 32) = 0;
  *(_QWORD *)(v6 + 40) = 0;
  AdobeXMPCore_Int::MakeUncheckedSharedPointer<AdobeXMPCore_Int::UTF8StringImpl>((char *)v6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ImageIO/XMP-Toolkit-SDK/XMPCommon/source/UTF8StringImpl.cpp", 243, 1, &v14);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, AdobeXMPCore_Int::IUTF8String_I *, const char *))(*(_QWORD *)v14 + 56))(&v12, v14, this, a2);
  v7 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  v10 = v14;
  if (v14)
    v10 = v14 + *(_QWORD *)(*(_QWORD *)v14 - 408);
  v11 = v15;
  *a3 = v10;
  a3[1] = v11;
}

void sub_187E3C448(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

_QWORD *AdobeXMPCore_Int::UTF8StringImpl::assign@<X0>(AdobeXMPCore_Int::UTF8StringImpl *this@<X0>, char *a2@<X1>, size_t a3@<X2>, _QWORD *a4@<X8>)
{
  void **v6;

  if (a2 && a3)
  {
    v6 = (void **)((char *)this + 24);
    if (a3 == -1)
      std::basic_string<char,std::char_traits<char>,AdobeXMPCore_Int::TAllocator<char>>::__assign_external(v6, a2);
    else
      std::basic_string<char,std::char_traits<char>,AdobeXMPCore_Int::TAllocator<char>>::__assign_external(v6, a2, a3);
  }
  else if (*((char *)this + 47) < 0)
  {
    **((_BYTE **)this + 3) = 0;
    *((_QWORD *)this + 4) = 0;
  }
  else
  {
    *((_BYTE *)this + 24) = 0;
    *((_BYTE *)this + 47) = 0;
  }
  return AdobeXMPCore_Int::UTF8StringImpl::returnSelfSharedPointer(this, a4);
}

void **std::basic_string<char,std::char_traits<char>,AdobeXMPCore_Int::TAllocator<char>>::__assign_external(void **__dst, void *__src, size_t __len)
{
  unint64_t v6;
  void *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;

  LODWORD(v6) = *((char *)__dst + 23);
  if ((v6 & 0x80000000) != 0)
  {
    v10 = (unint64_t)__dst[2];
    v9 = (v10 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v9 < __len)
    {
      v8 = (uint64_t)__dst[1];
      goto LABEL_6;
    }
    v6 = HIBYTE(v10);
    v7 = *__dst;
  }
  else
  {
    v7 = __dst;
    if (__len > 0x16)
    {
      v8 = *((unsigned __int8 *)__dst + 23);
      v9 = 22;
LABEL_6:
      std::basic_string<char,std::char_traits<char>,AdobeXMPCore_Int::TAllocator<char>>::__grow_by_and_replace((AdobeXMPCore_Int::IMemoryAllocator_I *)__dst, v9, __len - v9, v8, 0, v8, __len, __src);
      return __dst;
    }
  }
  if (__len)
  {
    memmove(v7, __src, __len);
    LOBYTE(v6) = *((_BYTE *)__dst + 23);
  }
  if ((v6 & 0x80) != 0)
    __dst[1] = (void *)__len;
  else
    *((_BYTE *)__dst + 23) = __len & 0x7F;
  *((_BYTE *)v7 + __len) = 0;
  return __dst;
}

uint64_t *AdobeXMPCore_Int::MakeUncheckedSharedPointer<AdobeXMPCore_Int::UTF8StringImpl>@<X0>(char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, uint64_t *a5@<X8>)
{
  _OWORD *exception;
  __int128 v11;

  if (!a1 && a4)
  {
    v11 = 0uLL;
    AdobeXMPCore_Int::IError_I::CreateError(1, 6, 2, &v11);
    (*(void (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)(v11 + *(_QWORD *)(*(_QWORD *)v11 - 304)) + 120))(v11 + *(_QWORD *)(*(_QWORD *)v11 - 304), a2, a3);
    (*(void (**)(_QWORD, const char *, uint64_t))(*(_QWORD *)(v11 + *(_QWORD *)(*(_QWORD *)v11 - 304))
                                                          + 112))(v11 + *(_QWORD *)(*(_QWORD *)v11 - 304), "NULL pointer provided for creating shared pointer", -1);
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = v11;
    v11 = 0uLL;
  }
  (**(void (***)(char *))&a1[*(_QWORD *)(*(_QWORD *)a1 - 448)])(&a1[*(_QWORD *)(*(_QWORD *)a1 - 448)]);
  return std::shared_ptr<AdobeXMPCore_Int::UTF8StringImpl>::shared_ptr[abi:ne180100]<AdobeXMPCore_Int::UTF8StringImpl,std::__mem_fn<void (AdobeXMPCore_Int::SharedObjectImpl::*)(void)const>,void>(a5, (uint64_t)a1, 8, 1);
}

void sub_187E3C680(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t AdobeXMPCore_Int::SharedObjectImpl::Acquire(uint64_t this)
{
  unint64_t *v1;
  unint64_t v3;
  unint64_t *v4;
  unint64_t v5;

  v1 = (unint64_t *)(this + 16);
  if (atomic_load((unint64_t *)(this + 16)))
  {
    do
      v3 = __ldaxr(v1);
    while (__stlxr(v3 - 1, v1));
  }
  else
  {
    v4 = (unint64_t *)(this + 8);
    do
      v5 = __ldaxr(v4);
    while (__stlxr(v5 + 1, v4));
  }
  return this;
}

_QWORD *AdobeXMPCore_Int::UTF8StringImpl::returnSelfSharedPointer@<X0>(AdobeXMPCore_Int::UTF8StringImpl *this@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *result;
  uint64_t v4;
  uint64_t v5;
  _QWORD v6[2];

  result = std::shared_ptr<AdobeXMPCommon::IUTF8StringProxy>::shared_ptr[abi:ne180100]<AdobeXMPCommon::IUTF8StringProxy,void>(v6, (_QWORD *)this + 1);
  v4 = v6[0];
  if (v6[0])
    v4 = v6[0] + *(_QWORD *)(*(_QWORD *)v6[0] - 408);
  v5 = v6[1];
  *a2 = v4;
  a2[1] = v5;
  return result;
}

uint64_t std::__shared_ptr_pointer<AdobeXMPCore_Int::UTF8StringImpl *,std::__mem_fn<void (AdobeXMPCore_Int::SharedObjectImpl::*)(void)const>,std::allocator<AdobeXMPCore_Int::UTF8StringImpl>>::__on_zero_shared(_QWORD *a1)
{
  uint64_t (*v1)(_QWORD *);
  uint64_t v2;
  _QWORD *v3;

  v1 = (uint64_t (*)(_QWORD *))a1[4];
  v2 = a1[5];
  v3 = (_QWORD *)(a1[3] + *(_QWORD *)(*(_QWORD *)a1[3] - 448) + (v2 >> 1));
  if ((v2 & 1) != 0)
    v1 = *(uint64_t (**)(_QWORD *))(*v3 + v1);
  return v1(v3);
}

void AdobeXMPCore_Int::MemoryAllocatorWrapperImpl::deallocate(AdobeXMPCore_Int::MemoryAllocatorWrapperImpl *this, _QWORD *a2)
{
  uint64_t v2;
  char *v3;
  uint64_t v4;

  v4 = *(a2 - 1);
  v3 = (char *)(a2 - 1);
  v2 = v4;
  if (v4)
    (*(void (**)(uint64_t, char *))(*(_QWORD *)v2 + 8))(v2, v3);
  else
    free(v3);
}

unint64_t *AdobeXMPCore_Int::SharedObjectImpl::Release(unint64_t *this)
{
  unint64_t *v1;
  unint64_t v3;
  unint64_t v4;

  v1 = this + 1;
  if (!atomic_load(this + 1))
    return (unint64_t *)(*(uint64_t (**)(unint64_t *))(*this + 32))(this);
  do
  {
    v3 = __ldaxr(v1);
    v4 = v3 - 1;
  }
  while (__stlxr(v4, v1));
  if (!v4)
    return (unint64_t *)(*(uint64_t (**)(unint64_t *))(*this + 32))(this);
  return this;
}

void AdobeXMPCore_Int::MemoryManagedObject::operator delete(AdobeXMPCore_Int::IMemoryAllocator_I *a1)
{
  uint64_t MemoryAllocator;

  MemoryAllocator = AdobeXMPCore_Int::IMemoryAllocator_I::GetMemoryAllocator(a1);
  (*(void (**)(uint64_t, AdobeXMPCore_Int::IMemoryAllocator_I *))(*(_QWORD *)MemoryAllocator + 8))(MemoryAllocator, a1);
}

uint64_t AdobeXMPCore_Int::MemoryManagedObject::operator new(AdobeXMPCore_Int::MemoryManagedObject *this)
{
  uint64_t (***MemoryAllocator)(_QWORD, AdobeXMPCore_Int::MemoryManagedObject *);
  uint64_t result;
  std::bad_alloc *exception;
  std::bad_alloc *v5;

  MemoryAllocator = (uint64_t (***)(_QWORD, AdobeXMPCore_Int::MemoryManagedObject *))AdobeXMPCore_Int::IMemoryAllocator_I::GetMemoryAllocator(this);
  result = (**MemoryAllocator)(MemoryAllocator, this);
  if (!result)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    v5 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v5, MEMORY[0x1E0DE4EA8], MEMORY[0x1E0DE4DC0]);
  }
  return result;
}

uint64_t AdobeXMPCore_Int::IMemoryAllocator_I::GetMemoryAllocator(AdobeXMPCore_Int::IMemoryAllocator_I *this)
{
  if (AdobeXMPCore_Int::sDefaultMemoryAllocator(void)::onceToken != -1)
    dispatch_once(&AdobeXMPCore_Int::sDefaultMemoryAllocator(void)::onceToken, &__block_literal_global_42);
  if (AdobeXMPCore_Int::gDefaultMemoryAllocator)
    return AdobeXMPCore_Int::gDefaultMemoryAllocator
         + *(_QWORD *)(*(_QWORD *)AdobeXMPCore_Int::gDefaultMemoryAllocator - 56);
  else
    return 0;
}

_QWORD *AdobeXMPCore_Int::MemoryAllocatorWrapperImpl::allocate(AdobeXMPCore_Int::MemoryAllocatorWrapperImpl *this, uint64_t a2)
{
  size_t v3;
  uint64_t (***v4)(_QWORD, size_t);
  _QWORD *result;

  v3 = a2 + 8;
  v4 = (uint64_t (***)(_QWORD, size_t))*((_QWORD *)this + 1);
  if (v4)
    result = (_QWORD *)(**v4)(v4, v3);
  else
    result = malloc_type_malloc(v3, 0x88C6C06BuLL);
  if (result)
    *result++ = *((_QWORD *)this + 1);
  return result;
}

void AdobeXMPCore_Int::UTF8StringImpl::~UTF8StringImpl(AdobeXMPCore_Int::UTF8StringImpl *this)
{
  uint64_t v2;

  AdobeXMPCore_Int::SharedObjectImpl::~SharedObjectImpl((AdobeXMPCore_Int::SharedObjectImpl *)(v2 + 56), (uint64_t *)&off_1E1BAA500);
  AdobeXMPCore_Int::MemoryManagedObject::operator delete(this);
}

{
  uint64_t v1;

  AdobeXMPCore_Int::SharedObjectImpl::~SharedObjectImpl((AdobeXMPCore_Int::SharedObjectImpl *)(v1 + 56), (uint64_t *)&off_1E1BAA500);
}

void AdobeXMPCore_Int::SharedObjectImpl::~SharedObjectImpl(AdobeXMPCore_Int::SharedObjectImpl *this, uint64_t *a2)
{
  uint64_t v2;

  v2 = *a2;
  *(_QWORD *)this = *a2;
  *(_QWORD *)((char *)this + *(_QWORD *)(v2 - 72)) = a2[1];
  *(_QWORD *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 56)) = a2[2];
  if (atomic_load((unint64_t *)this + 1))
    __assert_rtn("~SharedObjectImpl", "SharedObjectImpl.cpp", 32, "mRefCount == 0");
}

void AdobeXMPCore_Int::UTF8StringImpl::~UTF8StringImpl(AdobeXMPCore_Int::UTF8StringImpl *this, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t MemoryAllocator;
  std::__shared_weak_count *v6;

  v3 = *a2;
  *(_QWORD *)this = *a2;
  *(_QWORD *)((char *)this + *(_QWORD *)(v3 - 440)) = a2[1];
  *(_QWORD *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 408)) = a2[2];
  *(_QWORD *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 56)) = a2[3];
  *(_QWORD *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 64)) = a2[4];
  *(_QWORD *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 416)) = a2[5];
  *(_QWORD *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 448)) = a2[6];
  if (*((char *)this + 47) < 0)
  {
    v4 = *((_QWORD *)this + 3);
    MemoryAllocator = AdobeXMPCore_Int::IMemoryAllocator_I::GetMemoryAllocator(this);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)MemoryAllocator + 8))(MemoryAllocator, v4);
  }
  v6 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  if (v6)
    std::__shared_weak_count::__release_weak(v6);
}

uint64_t AdobeXMPCore_Int::VerifyParameters(AdobeXMPCore_Int *this, int a2, char *__s, const char *a4, const char *a5, size_t a6)
{
  uint64_t v8;
  AdobeXMPCore_Int::IErrorNotifier_I *v9;
  char *v10;
  AdobeXMPCore_Int::IErrorNotifier_I *v11;
  char *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  uint64_t (***ErrorNotifier)(_QWORD, __int128 *);
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  uint64_t (***v24)(_QWORD, __int128 *);
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t *v28;
  AdobeXMPCore_Int::IErrorNotifier_I *v29;
  char *v30;
  AdobeXMPCore_Int::IErrorNotifier_I *v31;
  char *v32;
  unint64_t *v33;
  unint64_t v34;
  uint64_t (***v35)(_QWORD, __int128 *);
  std::__shared_weak_count *v36;
  unint64_t *v37;
  unint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  unint64_t *v42;
  unint64_t v43;
  uint64_t (***v44)(_QWORD, __int128 *);
  std::__shared_weak_count *v45;
  unint64_t *v46;
  unint64_t v47;
  unint64_t *v48;
  _OWORD *exception;
  _OWORD *v51;
  _OWORD *v52;
  _OWORD *v53;
  __int128 v54;
  char *v55;
  std::__shared_weak_count *v56;
  size_t v57;
  const char *v58;

  v57 = a6;
  v58 = a5;
  if ((_DWORD)this)
  {
    if (!__s)
    {
      v55 = 0;
      v56 = 0;
      AdobeXMPCore_Int::IError_I::CreateError(1, 1, 1, &v55);
      (*(void (**)(char *, const char *, uint64_t))(*(_QWORD *)&v55[*(_QWORD *)(*(_QWORD *)v55 - 304)]
                                                            + 120))(&v55[*(_QWORD *)(*(_QWORD *)v55 - 304)], "/Library/Caches/com.apple.xbs/Sources/ImageIO/XMP-Toolkit-SDK/XMPCore/source/NameSpacePrefixMapImpl.cpp", 68);
      (*(void (**)(char *, const char *, uint64_t))(*(_QWORD *)&v55[*(_QWORD *)(*(_QWORD *)v55 - 304)]
                                                            + 112))(&v55[*(_QWORD *)(*(_QWORD *)v55 - 304)], "prefix is NULL", -1);
      v9 = (AdobeXMPCore_Int::IErrorNotifier_I *)(*(uint64_t (**)(char *, _QWORD))(*(_QWORD *)&v55[*(_QWORD *)(*(_QWORD *)v55 - 304)]
                                                                                           + 136))(&v55[*(_QWORD *)(*(_QWORD *)v55 - 304)], 0);
      v54 = 0uLL;
      if (v55)
        v10 = &v55[*(_QWORD *)(*(_QWORD *)v55 - 304)];
      else
        v10 = 0;
      *(_QWORD *)&v54 = v10;
      *((_QWORD *)&v54 + 1) = v56;
      if (v56)
      {
        p_shared_owners = (unint64_t *)&v56->__shared_owners_;
        do
          v14 = __ldxr(p_shared_owners);
        while (__stxr(v14 + 1, p_shared_owners));
      }
      ErrorNotifier = (uint64_t (***)(_QWORD, __int128 *))AdobeXMPCore_Int::IErrorNotifier_I::GetErrorNotifier(v9);
      if (((**ErrorNotifier)(ErrorNotifier, &v54) & 1) == 0)
      {
        exception = __cxa_allocate_exception(0x10uLL);
        *exception = v54;
        v54 = 0uLL;
      }
      v16 = (std::__shared_weak_count *)*((_QWORD *)&v54 + 1);
      if (*((_QWORD *)&v54 + 1))
      {
        v17 = (unint64_t *)(*((_QWORD *)&v54 + 1) + 8);
        do
          v18 = __ldaxr(v17);
        while (__stlxr(v18 - 1, v17));
        if (!v18)
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
      }
      v19 = v56;
      if (v56)
      {
        v20 = (unint64_t *)&v56->__shared_owners_;
        do
          v21 = __ldaxr(v20);
        while (__stlxr(v21 - 1, v20));
LABEL_39:
        if (!v21)
        {
          ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
          std::__shared_weak_count::__release_weak(v19);
        }
      }
LABEL_41:
      v8 = 0;
      if (!a2)
        return v8;
      goto LABEL_42;
    }
    if (a5 != (const char *)-1)
    {
      if (a5)
        goto LABEL_5;
LABEL_10:
      v55 = 0;
      v56 = 0;
      AdobeXMPCore_Int::IError_I::CreateError(1, 1, 1, &v55);
      (*(void (**)(char *, const char *, uint64_t))(*(_QWORD *)&v55[*(_QWORD *)(*(_QWORD *)v55 - 304)]
                                                            + 120))(&v55[*(_QWORD *)(*(_QWORD *)v55 - 304)], "/Library/Caches/com.apple.xbs/Sources/ImageIO/XMP-Toolkit-SDK/XMPCore/source/NameSpacePrefixMapImpl.cpp", 73);
      (*(void (**)(char *, const char *, uint64_t))(*(_QWORD *)&v55[*(_QWORD *)(*(_QWORD *)v55 - 304)]
                                                            + 112))(&v55[*(_QWORD *)(*(_QWORD *)v55 - 304)], "prefixLength is 0", -1);
      v11 = (AdobeXMPCore_Int::IErrorNotifier_I *)(*(uint64_t (**)(char *, const char **))(*(_QWORD *)&v55[*(_QWORD *)(*(_QWORD *)v55 - 304)] + 152))(&v55[*(_QWORD *)(*(_QWORD *)v55 - 304)], &v58);
      v54 = 0uLL;
      if (v55)
        v12 = &v55[*(_QWORD *)(*(_QWORD *)v55 - 304)];
      else
        v12 = 0;
      *(_QWORD *)&v54 = v12;
      *((_QWORD *)&v54 + 1) = v56;
      if (v56)
      {
        v22 = (unint64_t *)&v56->__shared_owners_;
        do
          v23 = __ldxr(v22);
        while (__stxr(v23 + 1, v22));
      }
      v24 = (uint64_t (***)(_QWORD, __int128 *))AdobeXMPCore_Int::IErrorNotifier_I::GetErrorNotifier(v11);
      if (((**v24)(v24, &v54) & 1) == 0)
      {
        v52 = __cxa_allocate_exception(0x10uLL);
        *v52 = v54;
        v54 = 0uLL;
      }
      v25 = (std::__shared_weak_count *)*((_QWORD *)&v54 + 1);
      if (*((_QWORD *)&v54 + 1))
      {
        v26 = (unint64_t *)(*((_QWORD *)&v54 + 1) + 8);
        do
          v27 = __ldaxr(v26);
        while (__stlxr(v27 - 1, v26));
        if (!v27)
        {
          ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
          std::__shared_weak_count::__release_weak(v25);
        }
      }
      v19 = v56;
      if (v56)
      {
        v28 = (unint64_t *)&v56->__shared_owners_;
        do
          v21 = __ldaxr(v28);
        while (__stlxr(v21 - 1, v28));
        goto LABEL_39;
      }
      goto LABEL_41;
    }
    v58 = (const char *)strlen(__s);
    if (!v58)
      goto LABEL_10;
  }
LABEL_5:
  v8 = 1;
  if (!a2)
    return v8;
LABEL_42:
  if (!a4)
  {
    v55 = 0;
    v56 = 0;
    AdobeXMPCore_Int::IError_I::CreateError(1, 1, 1, &v55);
    (*(void (**)(char *, const char *, uint64_t))(*(_QWORD *)&v55[*(_QWORD *)(*(_QWORD *)v55 - 304)] + 120))(&v55[*(_QWORD *)(*(_QWORD *)v55 - 304)], "/Library/Caches/com.apple.xbs/Sources/ImageIO/XMP-Toolkit-SDK/XMPCore/source/NameSpacePrefixMapImpl.cpp", 81);
    (*(void (**)(char *, const char *, uint64_t))(*(_QWORD *)&v55[*(_QWORD *)(*(_QWORD *)v55 - 304)] + 112))(&v55[*(_QWORD *)(*(_QWORD *)v55 - 304)], "nameSpace is NULL", -1);
    v29 = (AdobeXMPCore_Int::IErrorNotifier_I *)(*(uint64_t (**)(char *, _QWORD))(*(_QWORD *)&v55[*(_QWORD *)(*(_QWORD *)v55 - 304)]
                                                                                          + 136))(&v55[*(_QWORD *)(*(_QWORD *)v55 - 304)], 0);
    if (v55)
      v30 = &v55[*(_QWORD *)(*(_QWORD *)v55 - 304)];
    else
      v30 = 0;
    *(_QWORD *)&v54 = v30;
    *((_QWORD *)&v54 + 1) = v56;
    if (v56)
    {
      v33 = (unint64_t *)&v56->__shared_owners_;
      do
        v34 = __ldxr(v33);
      while (__stxr(v34 + 1, v33));
    }
    v35 = (uint64_t (***)(_QWORD, __int128 *))AdobeXMPCore_Int::IErrorNotifier_I::GetErrorNotifier(v29);
    if (((**v35)(v35, &v54) & 1) == 0)
    {
      v51 = __cxa_allocate_exception(0x10uLL);
      *v51 = v54;
      v54 = 0uLL;
    }
    v36 = (std::__shared_weak_count *)*((_QWORD *)&v54 + 1);
    if (*((_QWORD *)&v54 + 1))
    {
      v37 = (unint64_t *)(*((_QWORD *)&v54 + 1) + 8);
      do
        v38 = __ldaxr(v37);
      while (__stlxr(v38 - 1, v37));
      if (!v38)
      {
        ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
        std::__shared_weak_count::__release_weak(v36);
      }
    }
    v39 = v56;
    if (!v56)
      return 0;
    v40 = (unint64_t *)&v56->__shared_owners_;
    do
      v41 = __ldaxr(v40);
    while (__stlxr(v41 - 1, v40));
    goto LABEL_78;
  }
  if (v57 == -1)
  {
    v57 = strlen(a4);
    if (!v57)
    {
LABEL_49:
      v55 = 0;
      v56 = 0;
      AdobeXMPCore_Int::IError_I::CreateError(1, 1, 1, &v55);
      (*(void (**)(char *, const char *, uint64_t))(*(_QWORD *)&v55[*(_QWORD *)(*(_QWORD *)v55 - 304)]
                                                            + 120))(&v55[*(_QWORD *)(*(_QWORD *)v55 - 304)], "/Library/Caches/com.apple.xbs/Sources/ImageIO/XMP-Toolkit-SDK/XMPCore/source/NameSpacePrefixMapImpl.cpp", 86);
      (*(void (**)(char *, const char *, uint64_t))(*(_QWORD *)&v55[*(_QWORD *)(*(_QWORD *)v55 - 304)]
                                                            + 112))(&v55[*(_QWORD *)(*(_QWORD *)v55 - 304)], "nameSpaceLength is 0", -1);
      v31 = (AdobeXMPCore_Int::IErrorNotifier_I *)(*(uint64_t (**)(char *, size_t *))(*(_QWORD *)&v55[*(_QWORD *)(*(_QWORD *)v55 - 304)]
                                                                                              + 152))(&v55[*(_QWORD *)(*(_QWORD *)v55 - 304)], &v57);
      if (v55)
        v32 = &v55[*(_QWORD *)(*(_QWORD *)v55 - 304)];
      else
        v32 = 0;
      *(_QWORD *)&v54 = v32;
      *((_QWORD *)&v54 + 1) = v56;
      if (v56)
      {
        v42 = (unint64_t *)&v56->__shared_owners_;
        do
          v43 = __ldxr(v42);
        while (__stxr(v43 + 1, v42));
      }
      v44 = (uint64_t (***)(_QWORD, __int128 *))AdobeXMPCore_Int::IErrorNotifier_I::GetErrorNotifier(v31);
      if (((**v44)(v44, &v54) & 1) == 0)
      {
        v53 = __cxa_allocate_exception(0x10uLL);
        *v53 = v54;
        v54 = 0uLL;
      }
      v45 = (std::__shared_weak_count *)*((_QWORD *)&v54 + 1);
      if (*((_QWORD *)&v54 + 1))
      {
        v46 = (unint64_t *)(*((_QWORD *)&v54 + 1) + 8);
        do
          v47 = __ldaxr(v46);
        while (__stlxr(v47 - 1, v46));
        if (!v47)
        {
          ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
          std::__shared_weak_count::__release_weak(v45);
        }
      }
      v39 = v56;
      if (!v56)
        return 0;
      v48 = (unint64_t *)&v56->__shared_owners_;
      do
        v41 = __ldaxr(v48);
      while (__stlxr(v41 - 1, v48));
LABEL_78:
      if (!v41)
      {
        ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
        std::__shared_weak_count::__release_weak(v39);
      }
      return 0;
    }
  }
  else if (!v57)
  {
    goto LABEL_49;
  }
  return v8;
}

void sub_187E3D0F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void AdobeXMPCore_Int::AutoSharedLock::~AutoSharedLock(AdobeXMPCore_Int::AutoSharedLock *this)
{
  AdobeXMPCore_Int::AutoSharedLock::Release(this);
  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100]((uint64_t)this);
}

uint64_t AdobeXMPCore_Int::AutoSharedLock::AutoSharedLock(uint64_t a1, uint64_t a2, int a3)
{
  _QWORD *v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  int v9;
  AdobeXMPCore_Int::IErrorNotifier_I *v11;
  char *v12;
  unint64_t *v13;
  unint64_t v14;
  void (***ErrorNotifier)(_QWORD, __int128 *);
  _OWORD *exception;
  __int128 v17;
  char *v18;
  uint64_t v19;

  v4 = *(_QWORD **)a2;
  *(_QWORD *)a1 = *(_QWORD *)a2;
  v5 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 8) = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
    v4 = *(_QWORD **)a1;
  }
  *(_BYTE *)(a1 + 16) = a3;
  if (v4)
  {
    v8 = 64;
    if (a3)
      v8 = 40;
    v9 = (*(uint64_t (**)(void))(*v4 + v8))();
    if (v9)
    {
      v18 = 0;
      v19 = 0;
      AdobeXMPCore_Int::IError_I::CreateError(4, v9, 4, &v18);
      (*(void (**)(char *, const char *, uint64_t))(*(_QWORD *)&v18[*(_QWORD *)(*(_QWORD *)v18 - 304)]
                                                            + 120))(&v18[*(_QWORD *)(*(_QWORD *)v18 - 304)], "/Library/Caches/com.apple.xbs/Sources/ImageIO/XMP-Toolkit-SDK/XMPCommon/source/AutoSharedLock.cpp", 27);
      v11 = (AdobeXMPCore_Int::IErrorNotifier_I *)(*(uint64_t (**)(char *, const char *, uint64_t))(*(_QWORD *)&v18[*(_QWORD *)(*(_QWORD *)v18 - 304)] + 112))(&v18[*(_QWORD *)(*(_QWORD *)v18 - 304)], "Unable to lock the mutex", -1);
      if (v18)
        v12 = &v18[*(_QWORD *)(*(_QWORD *)v18 - 304)];
      else
        v12 = 0;
      *(_QWORD *)&v17 = v12;
      *((_QWORD *)&v17 + 1) = v19;
      if (v19)
      {
        v13 = (unint64_t *)(v19 + 8);
        do
          v14 = __ldxr(v13);
        while (__stxr(v14 + 1, v13));
      }
      ErrorNotifier = (void (***)(_QWORD, __int128 *))AdobeXMPCore_Int::IErrorNotifier_I::GetErrorNotifier(v11);
      (**ErrorNotifier)(ErrorNotifier, &v17);
      exception = __cxa_allocate_exception(0x10uLL);
      *exception = v17;
      v17 = 0uLL;
    }
  }
  return a1;
}

void sub_187E3D2B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  uint64_t v11;

  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100](v11);
  _Unwind_Resume(a1);
}

uint64_t AdobeXMPCore_Int::SharedMutexImpl::Lock(AdobeXMPCore_Int::SharedMutexImpl *this)
{
  return 0;
}

_QWORD *AdobeXMPCore_Int::AutoSharedLock::Release(AdobeXMPCore_Int::AutoSharedLock *this)
{
  _QWORD *result;
  BOOL v3;
  uint64_t v4;
  AdobeXMPCore_Int::IErrorNotifier_I *v5;
  char *v6;
  unint64_t *v7;
  unint64_t v8;
  void (***ErrorNotifier)(_QWORD, __int128 *);
  _OWORD *exception;
  __int128 v11;
  char *v12;
  uint64_t v13;

  result = *(_QWORD **)this;
  if (result)
  {
    v3 = *((_BYTE *)this + 16) == 0;
    v4 = 56;
    if (v3)
      v4 = 80;
    result = (_QWORD *)(*(uint64_t (**)(void))(*result + v4))();
    if ((_DWORD)result)
    {
      v12 = 0;
      v13 = 0;
      AdobeXMPCore_Int::IError_I::CreateError(4, (int)result, 4, &v12);
      (*(void (**)(char *, const char *, uint64_t))(*(_QWORD *)&v12[*(_QWORD *)(*(_QWORD *)v12 - 304)]
                                                            + 120))(&v12[*(_QWORD *)(*(_QWORD *)v12 - 304)], "/Library/Caches/com.apple.xbs/Sources/ImageIO/XMP-Toolkit-SDK/XMPCommon/source/AutoSharedLock.cpp", 44);
      v5 = (AdobeXMPCore_Int::IErrorNotifier_I *)(*(uint64_t (**)(char *, const char *, uint64_t))(*(_QWORD *)&v12[*(_QWORD *)(*(_QWORD *)v12 - 304)] + 112))(&v12[*(_QWORD *)(*(_QWORD *)v12 - 304)], "Unable to lock the mutex", -1);
      v6 = 0;
      if (v12)
        v6 = &v12[*(_QWORD *)(*(_QWORD *)v12 - 304)];
      *(_QWORD *)&v11 = v6;
      *((_QWORD *)&v11 + 1) = v13;
      if (v13)
      {
        v7 = (unint64_t *)(v13 + 8);
        do
          v8 = __ldxr(v7);
        while (__stxr(v8 + 1, v7));
      }
      ErrorNotifier = (void (***)(_QWORD, __int128 *))AdobeXMPCore_Int::IErrorNotifier_I::GetErrorNotifier(v5);
      (**ErrorNotifier)(ErrorNotifier, &v11);
      exception = __cxa_allocate_exception(0x10uLL);
      *exception = v11;
      v11 = 0uLL;
    }
  }
  return result;
}

void sub_187E3D424(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

uint64_t AdobeXMPCore_Int::SharedMutexImpl::Unlock(AdobeXMPCore_Int::SharedMutexImpl *this)
{
  return 0;
}

_BYTE *std::basic_string<char,std::char_traits<char>,AdobeXMPCore_Int::TAllocator<char>>::__grow_by_and_replace(AdobeXMPCore_Int::IMemoryAllocator_I *a1, unint64_t a2, unint64_t a3, uint64_t a4, size_t a5, uint64_t a6, size_t a7, const void *a8)
{
  char *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t (***MemoryAllocator)(_QWORD, uint64_t);
  _BYTE *result;
  _BYTE *v21;
  size_t v22;
  uint64_t v23;
  size_t v24;

  if (0x7FFFFFFFFFFFFFF6 - a2 < a3)
    std::string::__throw_length_error[abi:ne180100]();
  v15 = (char *)a1;
  if (*((char *)a1 + 23) < 0)
    v15 = *(char **)a1;
  if (a2 > 0x3FFFFFFFFFFFFFF2)
  {
    v18 = 0x7FFFFFFFFFFFFFF7;
  }
  else
  {
    v16 = a3 + a2;
    if (a3 + a2 <= 2 * a2)
      v16 = 2 * a2;
    v17 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v16 | 7) != 0x17)
      v17 = v16 | 7;
    if (v16 >= 0x17)
      v18 = v17 + 1;
    else
      v18 = 23;
  }
  MemoryAllocator = (uint64_t (***)(_QWORD, uint64_t))AdobeXMPCore_Int::IMemoryAllocator_I::GetMemoryAllocator(a1);
  result = (_BYTE *)(**MemoryAllocator)(MemoryAllocator, v18);
  v21 = result;
  if (a5)
    result = memmove(result, v15, a5);
  if (a7)
    result = memmove(&v21[a5], a8, a7);
  v22 = a4 - (a6 + a5);
  if (v22)
    result = memmove(&v21[a5 + a7], &v15[a5 + a6], v22);
  if (a2 != 22)
  {
    v23 = AdobeXMPCore_Int::IMemoryAllocator_I::GetMemoryAllocator((AdobeXMPCore_Int::IMemoryAllocator_I *)result);
    result = (_BYTE *)(*(uint64_t (**)(uint64_t, char *))(*(_QWORD *)v23 + 8))(v23, v15);
  }
  v24 = a7 + a5 + v22;
  *(_QWORD *)a1 = v21;
  *((_QWORD *)a1 + 1) = v24;
  *((_QWORD *)a1 + 2) = v18 | 0x8000000000000000;
  v21[v24] = 0;
  return result;
}

uint64_t std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::__erase_unique<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>(uint64_t **a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::find<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>((uint64_t)a1, a2);
  if (a1 + 1 == (uint64_t **)v3)
    return 0;
  std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::erase(a1, v3);
  return 1;
}

uint64_t *std::__tree<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,std::__map_value_compare<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>,AdobeXMPCore_Int::IUTF8StringComparator,true>,AdobeXMPCore_Int::TAllocator<std::__value_type<std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>,std::shared_ptr<AdobeXMPCommon::IUTF8String_v1 const>>>>::erase(uint64_t **a1, uint64_t *a2)
{
  uint64_t *v3;
  AdobeXMPCore_Int::IMemoryAllocator_I *v4;
  uint64_t MemoryAllocator;

  v3 = std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__remove_node_pointer(a1, a2);
  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100]((uint64_t)(a2 + 6));
  v4 = (AdobeXMPCore_Int::IMemoryAllocator_I *)std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100]((uint64_t)(a2 + 4));
  MemoryAllocator = AdobeXMPCore_Int::IMemoryAllocator_I::GetMemoryAllocator(v4);
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)MemoryAllocator + 8))(MemoryAllocator, a2);
  return v3;
}

uint64_t std::__shared_ptr_pointer<AdobeXMPCore_Int::NameSpacePrefixMapImpl *,std::__mem_fn<void (AdobeXMPCore_Int::SharedObjectImpl::*)(void)const>,std::allocator<AdobeXMPCore_Int::NameSpacePrefixMapImpl>>::__on_zero_shared(_QWORD *a1)
{
  uint64_t (*v1)(_QWORD *);
  uint64_t v2;
  _QWORD *v3;

  v1 = (uint64_t (*)(_QWORD *))a1[4];
  v2 = a1[5];
  v3 = (_QWORD *)(a1[3] + *(_QWORD *)(*(_QWORD *)a1[3] - 184) + (v2 >> 1));
  if ((v2 & 1) != 0)
    v1 = *(uint64_t (**)(_QWORD *))(*v3 + v1);
  return v1(v3);
}

void `virtual thunk to'AdobeXMPCore_Int::NameSpacePrefixMapImpl::~NameSpacePrefixMapImpl(AdobeXMPCore_Int::NameSpacePrefixMapImpl *this)
{
  AdobeXMPCore_Int::IMemoryAllocator_I *v1;

  AdobeXMPCore_Int::NameSpacePrefixMapImpl::~NameSpacePrefixMapImpl((AdobeXMPCore_Int::NameSpacePrefixMapImpl *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 48)));
  AdobeXMPCore_Int::MemoryManagedObject::operator delete(v1);
}

{
  AdobeXMPCore_Int::NameSpacePrefixMapImpl::~NameSpacePrefixMapImpl((AdobeXMPCore_Int::NameSpacePrefixMapImpl *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 48)));
}

{
  AdobeXMPCore_Int::NameSpacePrefixMapImpl::~NameSpacePrefixMapImpl((AdobeXMPCore_Int::NameSpacePrefixMapImpl *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 56)));
}

{
  AdobeXMPCore_Int::IMemoryAllocator_I *v1;

  AdobeXMPCore_Int::NameSpacePrefixMapImpl::~NameSpacePrefixMapImpl((AdobeXMPCore_Int::NameSpacePrefixMapImpl *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 56)));
  AdobeXMPCore_Int::MemoryManagedObject::operator delete(v1);
}

uint64_t std::__shared_ptr_pointer<AdobeXMPCore_Int::SharedMutexImpl *,std::__mem_fn<void (AdobeXMPCore_Int::SharedObjectImpl::*)(void)const>,std::allocator<AdobeXMPCore_Int::SharedMutexImpl>>::__on_zero_shared(_QWORD *a1)
{
  uint64_t (*v1)(_QWORD *);
  uint64_t v2;
  _QWORD *v3;

  v1 = (uint64_t (*)(_QWORD *))a1[4];
  v2 = a1[5];
  v3 = (_QWORD *)(a1[3] + *(_QWORD *)(*(_QWORD *)a1[3] - 120) + (v2 >> 1));
  if ((v2 & 1) != 0)
    v1 = *(uint64_t (**)(_QWORD *))(*v3 + v1);
  return v1(v3);
}

void `virtual thunk to'AdobeXMPCore_Int::SharedMutexImpl::~SharedMutexImpl(AdobeXMPCore_Int::SharedMutexImpl *this)
{
  char *v1;

  v1 = (char *)this + *(_QWORD *)(*(_QWORD *)this - 48);
  AdobeXMPCore_Int::SharedObjectImpl::~SharedObjectImpl((AdobeXMPCore_Int::SharedObjectImpl *)(v1 + 8), (uint64_t *)&off_1E1BAA5F0);
  AdobeXMPCore_Int::MemoryManagedObject::operator delete((AdobeXMPCore_Int::IMemoryAllocator_I *)v1);
}

{
  AdobeXMPCore_Int::SharedObjectImpl::~SharedObjectImpl((AdobeXMPCore_Int::SharedMutexImpl *)((char *)this + *(_QWORD *)(*(_QWORD *)this - 48) + 8), (uint64_t *)&off_1E1BAA5F0);
}

void AdobeXMPCore_Int::NameSpacePrefixMapImpl::~NameSpacePrefixMapImpl(AdobeXMPCore_Int::NameSpacePrefixMapImpl *this)
{
  uint64_t v2;

  *(_QWORD *)(v2 + 96) = off_1E1BA1818;
  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100](v2 + 104);
  AdobeXMPCore_Int::SharedObjectImpl::~SharedObjectImpl((AdobeXMPCore_Int::NameSpacePrefixMapImpl *)((char *)this + 72), (uint64_t *)&off_1E1BAADC0);
}

{
  AdobeXMPCore_Int::IMemoryAllocator_I *v1;

  AdobeXMPCore_Int::NameSpacePrefixMapImpl::~NameSpacePrefixMapImpl(this);
  AdobeXMPCore_Int::MemoryManagedObject::operator delete(v1);
}

uint64_t std::__shared_ptr_emplace<ASTCTextureImp>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t IIOImagePlus::setISR(uint64_t this, unint64_t a2)
{
  *(_QWORD *)(this + 16) = ~a2;
  return this;
}

void *iio_jpeg_Malloc(size_t a1, void *a2)
{
  return malloc_type_malloc(a1, 0xD7A2A118uLL);
}

void iio_jpeg_Free(void *a1, void *a2)
{
  if (a1)
    free(a1);
}

void ReadTiffMetadata(IIOImageReadSession *a1, CGImageMetadata *a2, unint64_t a3, unsigned int a4, const __CFData *a5, char a6)
{
  CGMutableImageMetadataRef MetadataFromDatablock;
  CGMutableImageMetadataRef v8;

  MetadataFromDatablock = CreateMetadataFromDatablock(a1, tagdefsIFD0, a3, a4, a5, a6);
  if (MetadataFromDatablock)
  {
    v8 = MetadataFromDatablock;
    CGImageMetadataMerge((uint64_t)a2, (uint64_t)MetadataFromDatablock, 0);
    CFRelease(v8);
  }
}

void metadataSetSource(uint64_t a1, int a2)
{
  const __CFDictionary *v3;
  int64_t Count;
  const void **v6;
  const void **v7;
  uint64_t *v8;
  uint64_t v9;

  if (a1)
  {
    v3 = *(const __CFDictionary **)(a1 + 24);
    if (v3)
    {
      Count = CFDictionaryGetCount(v3);
      v6 = (const void **)malloc_type_calloc(8uLL, Count, 0xBF61FE04uLL);
      v7 = (const void **)malloc_type_calloc(8uLL, Count, 0x19865A04uLL);
      CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 24), v6, v7);
      if (Count >= 1)
      {
        v8 = (uint64_t *)v7;
        do
        {
          v9 = *v8++;
          *(_DWORD *)(CGImageSourceGetSource(v9) + 68) = a2;
          --Count;
        }
        while (Count);
      }
      if (v6)
        free(v6);
      if (v7)
        free(v7);
    }
  }
}

BOOL CGImageMetadataSetTagWithPath(CGMutableImageMetadataRef metadata, CGImageMetadataTagRef parent, CFStringRef path, CGImageMetadataTagRef tag)
{
  uint64_t Source;
  uint64_t v9;
  CFTypeID v10;
  _BOOL4 v11;
  CFTypeID v12;
  CFTypeID TypeID;
  CFTypeID v14;
  pthread_mutex_t *v15;
  void *TagWithPath;
  uint64_t v18;
  uint64_t v19;
  const __CFArray *v20;

  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0)
    ImageIODebugOptions(3, "A", "CGImageMetadataSetTagWithPath", 0, 0, -1, 0);
  Source = CGImageSourceGetSource((uint64_t)tag);
  if (!metadata)
    goto LABEL_14;
  v9 = Source;
  v10 = CFGetTypeID(metadata);
  if (CGImageMetadataGetTypeID::once != -1)
    dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_20);
  if (v10 != CGImageMetadataGetTypeID::id)
    goto LABEL_14;
  LOBYTE(v11) = 0;
  if (!path)
    return v11;
  if (!*((_BYTE *)metadata + 16))
    return v11;
  v12 = CFGetTypeID(path);
  TypeID = CFStringGetTypeID();
  LOBYTE(v11) = 0;
  if (!tag || v12 != TypeID)
    return v11;
  v14 = CFGetTypeID(tag);
  if (v14 != CGImageMetadataTagGetTypeID())
  {
LABEL_14:
    LOBYTE(v11) = 0;
    return v11;
  }
  v15 = (pthread_mutex_t *)((char *)metadata + 208);
  pthread_mutex_lock((pthread_mutex_t *)((char *)metadata + 208));
  if (*((_BYTE *)metadata + 200))
  {
    LogMetadata("CGImageMetadataSetTagWithPath", 946, "Cannot mutate metadata while enumerating");
    LOBYTE(v11) = 0;
  }
  else
  {
    pthread_mutex_unlock((pthread_mutex_t *)((char *)metadata + 208));
    v15 = (pthread_mutex_t *)((char *)metadata + 72);
    pthread_mutex_lock((pthread_mutex_t *)((char *)metadata + 72));
    v11 = CGImageMetadataSetValueWithPath(metadata, parent, path, *(CFTypeRef *)(v9 + 48));
    if (v11)
    {
      TagWithPath = CGImageMetadataGetTagWithPath(metadata, parent, path);
      if (TagWithPath)
      {
        v18 = (uint64_t)TagWithPath;
        v19 = CGImageSourceGetSource((uint64_t)TagWithPath);
        CGImageMetadataTagSetNamespace(v18, *(const __CFString **)(v9 + 16));
        CGImageMetadataTagSetPrefix(v18, *(const __CFString **)(v9 + 24));
        v20 = *(const __CFArray **)(v9 + 56);
        if (v20)
          *(_QWORD *)(v19 + 56) = CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v20);
        *(_DWORD *)(v19 + 40) = *(_DWORD *)(v9 + 40);
      }
    }
  }
  pthread_mutex_unlock(v15);
  return v11;
}

void metadataSetUnspecifiedSource(uint64_t a1, int a2)
{
  int64_t Count;
  const void **v5;
  const void **v6;
  uint64_t *v7;
  uint64_t Source;

  Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 24));
  v5 = (const void **)malloc_type_calloc(8uLL, Count, 0xCA0516E0uLL);
  v6 = (const void **)malloc_type_calloc(8uLL, Count, 0x1765CA0CuLL);
  CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 24), v5, v6);
  if (Count >= 1)
  {
    v7 = (uint64_t *)v6;
    do
    {
      Source = CGImageSourceGetSource(*v7);
      if (*(_DWORD *)(Source + 68) <= 1u)
        *(_DWORD *)(Source + 68) = a2;
      ++v7;
      --Count;
    }
    while (Count);
  }
  if (v5)
    free(v5);
  if (v6)
    free(v6);
}

void reconcileGPSTimeStamp(const __CFDictionary *a1)
{
  const __CFDictionary *TopLevelTag;
  const __CFDictionary *v3;
  uint64_t Source;
  uint64_t v5;
  const __CFString *v6;
  const __CFString *v7;
  BOOL v8;
  const __CFDictionary *v9;
  const __CFString *Value;
  const __CFDictionary *v11;
  const __CFString *GPSDateStringWithXMPDateTimeString;
  const __CFString *v13;
  CFStringRef XMPDateFromEXIFGPSDateAndTime;
  CFStringRef v15;
  CFStringRef v16;
  CFStringRef v17;

  TopLevelTag = CGImageMetadataGetTopLevelTag(a1, (uint64_t)CFSTR("http://ns.adobe.com/exif/1.0/"), (uint64_t)CFSTR("GPSTime"));
  v3 = CGImageMetadataGetTopLevelTag(a1, (uint64_t)CFSTR("http://ns.adobe.com/exif/1.0/"), (uint64_t)CFSTR("GPSDate"));
  Source = CGImageSourceGetSource((uint64_t)TopLevelTag);
  v5 = CGImageSourceGetSource((uint64_t)v3);
  if (TopLevelTag)
  {
    v6 = *(const __CFString **)(Source + 48);
    if (!v3 || ((v7 = *(const __CFString **)(v5 + 48), v6) ? (v8 = v7 == 0) : (v8 = 1), v8))
    {
      if (v6)
      {
        v9 = CGImageMetadataGetTopLevelTag(a1, (uint64_t)CFSTR("http://ns.adobe.com/photoshop/1.0/"), (uint64_t)CFSTR("DateCreated"));
        Value = (const __CFString *)CGImageMetadataTagGetValue((uint64_t)v9);
        if (Value
          || (v11 = CGImageMetadataGetTopLevelTag(a1, (uint64_t)CFSTR("http://ns.adobe.com/xap/1.0/"), (uint64_t)CFSTR("CreateDate")), (Value = (const __CFString *)CGImageMetadataTagGetValue((uint64_t)v11)) != 0))
        {
          GPSDateStringWithXMPDateTimeString = CreateGPSDateStringWithXMPDateTimeString(Value);
          if (GPSDateStringWithXMPDateTimeString)
          {
            v13 = GPSDateStringWithXMPDateTimeString;
            XMPDateFromEXIFGPSDateAndTime = CreateXMPDateFromEXIFGPSDateAndTime(GPSDateStringWithXMPDateTimeString, v6);
            if (XMPDateFromEXIFGPSDateAndTime)
            {
              v15 = XMPDateFromEXIFGPSDateAndTime;
              CGImageMetadataSetValueWithPath(a1, 0, CFSTR("exif:GPSTimeStamp"), XMPDateFromEXIFGPSDateAndTime);
              CFRelease(v15);
              CGImageMetadataRemoveTag((uint64_t)a1, (uint64_t)TopLevelTag);
            }
            CFRelease(v13);
          }
        }
      }
    }
    else
    {
      v16 = CreateXMPDateFromEXIFGPSDateAndTime(v7, v6);
      if (v16)
      {
        v17 = v16;
        CGImageMetadataSetValueWithPath(a1, 0, CFSTR("exif:GPSTimeStamp"), v16);
        CFRelease(v17);
        CGImageMetadataRemoveTag((uint64_t)a1, (uint64_t)TopLevelTag);
        CGImageMetadataRemoveTag((uint64_t)a1, (uint64_t)v3);
      }
    }
  }
}

void CGImageMetadataMerge(uint64_t a1, uint64_t a2, IIODictionary *a3)
{
  CFTypeID v6;
  CFTypeID TypeID;
  CFTypeID v8;
  CFIndex Count;
  const void **v10;
  const void **v11;
  const void **v12;
  const __CFString *v13;
  const void *v14;
  const __CFString *v15;
  const void *v16;
  _BOOL4 BoolForKey;
  uint64_t v18;
  const void *v19;
  CFTypeID v20;
  uint64_t Source;
  int ValueIfPresent;
  uint64_t v23;
  int v24;
  char v25;
  char v26;
  uint64_t v27;
  const __CFString *v28;
  char v29;
  CGMutableImageMetadataRef v30;
  const __CFDictionary **v31;
  IIODictionary *v32;
  IIODictionary *v33;
  const __CFDictionary *ObjectForKey;
  IIODictionary *v35;
  uint64_t v36;
  const __CFString *v37;
  const __CFString *EXIFDataTimeStringWithXMPDateTimeString;
  const __CFString *v39;
  const __CFString *v40;
  char v41;
  int v42;
  unsigned int v43;
  int v44;
  const __CFDictionary *v45;
  const __CFDictionary *v46;
  IIODictionary *v47;
  const __CFDictionary *v48;
  __CFDictionary *Mutable;
  IIODictionary *v50;
  __CFDictionary *v51;
  IIODictionary *v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  unsigned int v56;
  _BOOL4 v57;
  CFTypeRef v58[3];
  CFTypeRef v59[3];
  const __CFString *v60;
  const __CFString *v61;
  uint64_t v62;
  void *value;

  if (a1)
  {
    v6 = CFGetTypeID((CFTypeRef)a1);
    TypeID = CGImageMetadataGetTypeID();
    if (a2)
    {
      if (v6 == TypeID)
      {
        v8 = CFGetTypeID((CFTypeRef)a2);
        if (v8 == CGImageMetadataGetTypeID())
        {
          Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a2 + 24));
          CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 24));
          if (Count < 1)
          {
            v11 = 0;
            v12 = 0;
LABEL_85:
            v45 = *(const __CFDictionary **)(a2 + 32);
            if (v45 && CFDictionaryGetCount(v45))
            {
              if (*(_QWORD *)(a1 + 32))
              {
                if ((IIODictionaryIsMutable() & 1) == 0)
                {
                  _cg_jpeg_mem_term("CGImageMetadataMerge", 871, "*** ERROR: metadata->_NStoPrefix is immutable???\n");
                  v46 = *(const __CFDictionary **)(a1 + 32);
                  *(_QWORD *)(a1 + 32) = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v46);
                  CFRelease(v46);
                }
              }
              else
              {
                *(_QWORD *)(a1 + 32) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
              }
              v60 = 0;
              v61 = 0;
              v62 = 0;
              v47 = IIODictionary::IIODictionary((IIODictionary *)&v60, *(__CFDictionary **)(a1 + 32));
              IIODictionary::appendDictionary(v47, *(const __CFDictionary **)(a2 + 32));
              IIODictionary::~IIODictionary((IIODictionary *)&v60);
            }
            v48 = *(const __CFDictionary **)(a2 + 40);
            if (v48 && CFDictionaryGetCount(v48))
            {
              Mutable = *(__CFDictionary **)(a1 + 40);
              if (!Mutable)
              {
                Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                *(_QWORD *)(a1 + 40) = Mutable;
              }
              v60 = 0;
              v61 = 0;
              v62 = 0;
              v50 = IIODictionary::IIODictionary((IIODictionary *)&v60, Mutable);
              IIODictionary::appendDictionary(v50, *(const __CFDictionary **)(a2 + 40));
              IIODictionary::~IIODictionary((IIODictionary *)&v60);
            }
            if (*(_QWORD *)(a2 + 48))
            {
              v51 = *(__CFDictionary **)(a1 + 48);
              if (!v51)
              {
                v51 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                *(_QWORD *)(a1 + 48) = v51;
              }
              v60 = 0;
              v61 = 0;
              v62 = 0;
              v52 = IIODictionary::IIODictionary((IIODictionary *)&v60, v51);
              IIODictionary::appendDictionary(v52, *(const __CFDictionary **)(a2 + 48));
              IIODictionary::~IIODictionary((IIODictionary *)&v60);
            }
            if (!v11)
              goto LABEL_103;
          }
          else
          {
            v10 = (const void **)malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
            if (!v10)
              return;
            v11 = v10;
            v12 = (const void **)malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
            if (v12)
            {
              CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a2 + 24), v11, v12);
              v13 = *(const __CFString **)(a2 + 56);
              if (v13)
              {
                v14 = *(const void **)(a1 + 56);
                if (v14)
                {
                  CFRelease(v14);
                  v13 = *(const __CFString **)(a2 + 56);
                }
                *(_QWORD *)(a1 + 56) = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v13);
              }
              v15 = *(const __CFString **)(a2 + 64);
              if (v15)
              {
                v16 = *(const void **)(a1 + 64);
                if (v16)
                {
                  CFRelease(v16);
                  v15 = *(const __CFString **)(a2 + 64);
                }
                *(_QWORD *)(a1 + 64) = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v15);
              }
              v57 = CGImageIIMDigestsMatchOrMissing(a1);
              v54 = a2;
              if (a3)
              {
                v56 = IIODictionary::containsKey(a3, CFSTR("kCGImageMetadataMergeOverwrite"));
                BoolForKey = IIODictionary::getBoolForKey(a3, CFSTR("kCGImageSourceShouldPreferIPTCToEXIF"));
              }
              else
              {
                v56 = 0;
                BoolForKey = 0;
              }
              v18 = 0;
              v53 = !v57 || BoolForKey;
              v55 = *MEMORY[0x1E0C9B0D0];
              while (1)
              {
                v19 = v12[v18];
                if (!v19)
                  goto LABEL_83;
                v20 = CFGetTypeID(v12[v18]);
                if (v20 != CGImageMetadataTagGetTypeID())
                  goto LABEL_83;
                Source = CGImageSourceGetSource((uint64_t)v19);
                value = 0;
                ValueIfPresent = CFDictionaryGetValueIfPresent(*(CFDictionaryRef *)(a1 + 24), v11[v18], (const void **)&value);
                v23 = CGImageSourceGetSource((uint64_t)value);
                v24 = CGImageMetadataTagGetSource((uint64_t)v19);
                v25 = v24;
                if (ValueIfPresent)
                  break;
                v29 = v57;
                if (v24 != 8)
                  v29 = 1;
                if ((v29 & 1) != 0)
                  goto LABEL_82;
                v30 = CGImageMetadataCreateMutable();
                if (!v30)
                  goto LABEL_82;
                v31 = (const __CFDictionary **)v30;
                CGImageMetadataAddTag((uint64_t)v30, v19);
                v32 = (IIODictionary *)CGImagePropertiesCreateFromMetadata(v31);
                if (!v32)
                  goto LABEL_79;
                v33 = v32;
                ObjectForKey = IIODictionary::getObjectForKey(v32, CFSTR("{IPTC}"));
                if (!ObjectForKey)
                {
                  (*(void (**)(IIODictionary *))(*(_QWORD *)v33 + 8))(v33);
LABEL_79:
                  CFRelease(v31);
LABEL_82:
                  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), v11[v18], v19);
                  goto LABEL_83;
                }
                v60 = 0;
                v61 = 0;
                v62 = 0;
                v35 = IIODictionary::IIODictionary((IIODictionary *)&v60, ObjectForKey);
                v36 = SizeOfIPTCData(v35);
                IIODictionary::~IIODictionary((IIODictionary *)&v60);
                (*(void (**)(IIODictionary *))(*(_QWORD *)v33 + 8))(v33);
                CFRelease(v31);
                if (!v36)
                  goto LABEL_82;
LABEL_83:
                if (Count == ++v18)
                {
                  a2 = v54;
                  goto LABEL_85;
                }
              }
              v26 = CGImageMetadataTagGetSource((uint64_t)value);
              v60 = CFSTR("http://ns.adobe.com/photoshop/1.0/");
              v61 = CFSTR("DateCreated");
              v62 = 0;
              v58[2] = 0;
              v59[0] = CFSTR("http://ns.adobe.com/xap/1.0/");
              v59[1] = CFSTR("CreateDate");
              v59[2] = 0;
              v58[0] = CFSTR("http://ns.adobe.com/xap/1.0/");
              v58[1] = CFSTR("ModifyDate");
              if (!CGImageMetadataTagKeyEqual((CFTypeRef *)v11[v18], (CFTypeRef *)&v60)
                && !CGImageMetadataTagKeyEqual((CFTypeRef *)v11[v18], v59)
                && !CGImageMetadataTagKeyEqual((CFTypeRef *)v11[v18], v58))
              {
LABEL_53:
                if (v56)
                {
                  if (CGImageMetadataTagGetValue((uint64_t)v19) == v55)
                  {
                    CGImageMetadataRemoveTag(a1, (uint64_t)v19);
                  }
                  else
                  {
                    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), v11[v18], v19);
                    CGImageMetadataTagGetSource((uint64_t)v19);
                  }
                  goto LABEL_83;
                }
                v42 = CGImageMetadataTagGetSource((uint64_t)v19);
                v43 = CGImageMetadataTagGetSource((uint64_t)value);
                if ((v42 & 2) != 0)
                {
                  if (v43 == 4)
                  {
                    if ((v53 & 1) != 0)
                      goto LABEL_83;
                  }
                  else if (v43 != 8 && (~v43 & 0x22) != 0)
                  {
                    goto LABEL_83;
                  }
                  goto LABEL_82;
                }
                if (v42 == 16)
                {
                  if (v43 != 4 && v43 != 8 && (v43 & 2) == 0)
                    goto LABEL_83;
                  goto LABEL_82;
                }
                if (v42 == 8)
                {
                  v44 = v57;
                  if (v43 != 4)
                    v44 = 0;
                }
                else
                {
                  if (v42 != 4 || v43 == 4)
                    goto LABEL_83;
                  if (v43 == 8)
                  {
                    if (v57)
                      goto LABEL_83;
                    goto LABEL_82;
                  }
                  v44 = v53 & (v43 >> 1);
                }
                if (v44 == 1)
                  goto LABEL_82;
                goto LABEL_83;
              }
              v27 = v23;
              if ((v26 & 0xC) != 0 || (v27 = Source, (v25 & 0xC) != 0))
              {
                v28 = *(const __CFString **)(v27 + 48);
                if ((v26 & 2) != 0)
                  goto LABEL_41;
              }
              else
              {
                v28 = 0;
                if ((v26 & 2) != 0)
                  goto LABEL_41;
              }
              v23 = Source;
              if ((v25 & 2) == 0)
                goto LABEL_53;
LABEL_41:
              v37 = *(const __CFString **)(v23 + 48);
              if (!v37 || !v28)
                goto LABEL_53;
              EXIFDataTimeStringWithXMPDateTimeString = CreateEXIFDataTimeStringWithXMPDateTimeString(v28);
              v39 = CreateEXIFDataTimeStringWithXMPDateTimeString(v37);
              v40 = v39;
              if (EXIFDataTimeStringWithXMPDateTimeString && v39)
              {
                v41 = 0;
                if (CFStringCompare(EXIFDataTimeStringWithXMPDateTimeString, v39, 0) == kCFCompareEqualTo
                  && (v25 & 0xC) != 0)
                {
                  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), v11[v18], v19);
                  v41 = 1;
                }
              }
              else
              {
                v41 = 0;
                if (!EXIFDataTimeStringWithXMPDateTimeString)
                  goto LABEL_50;
              }
              CFRelease(EXIFDataTimeStringWithXMPDateTimeString);
LABEL_50:
              if (v40)
                CFRelease(v40);
              if ((v41 & 1) != 0)
                goto LABEL_83;
              goto LABEL_53;
            }
          }
          free(v11);
LABEL_103:
          if (v12)
            free(v12);
        }
      }
    }
  }
}

void sub_187E3E3EC(_Unwind_Exception *a1)
{
  uint64_t v1;

  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 120));
  _Unwind_Resume(a1);
}

uint64_t CGImageMetadataTagKeyEqual(CFTypeRef *a1, CFTypeRef *a2)
{
  uint64_t result;

  result = CFEqual(a1[1], a2[1]);
  if ((_DWORD)result)
    return CFEqual(*a1, *a2) != 0;
  return result;
}

void sub_187E3ED38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

const __CFDictionary *IIODictionary::getObjectForKey(IIODictionary *this, const __CFString *a2)
{
  const __CFDictionary *result;

  result = (const __CFDictionary *)*((_QWORD *)this + 1);
  if (result)
    return (const __CFDictionary *)CFDictionaryGetValue(result, a2);
  return result;
}

void *CGImageMetadataGetTagWithPath(_QWORD *a1, void *Value, const __CFString *a3)
{
  char *v3;
  void *v4;
  CFTypeID v8;
  CFTypeID v9;
  uint64_t Source;
  IIOMetadata_Tag *v11;
  CFTypeID v12;
  const __CFAllocator *v13;
  const __CFString *v14;
  char *v15;
  uint64_t v16;
  int v17;
  char *v18;
  char *v19;
  uint64_t v20;
  int v21;
  char *v22;
  const void *v23;
  const __CFDictionary *v24;
  CFStringRef v25;
  CFTypeID v26;
  char *v27;
  const char *v28;
  CFStringRef v29;
  const void *v30;
  CFTypeID v31;
  CFIndex v32;
  const void *ValueAtIndex;
  uint64_t v34;
  CFTypeID v35;
  CFTypeID TypeID;
  uint64_t *v37;
  const void *v38;
  CFTypeID v39;
  CFStringRef v40;
  CFStringRef v41;
  const void *v42;
  CFTypeID v43;
  const void *v44;
  CFTypeID v45;
  CFTypeID v46;
  uint64_t v47;
  const __CFString *PropertyPrefixFromCStrPrefix;
  CFStringRef v50;
  const __CFString *cf;
  _QWORD v52[7];
  _QWORD v53[7];
  const void *key;
  _QWORD *p_isa;
  uint64_t v56;
  char v57;
  uint64_t v58;
  uint64_t *v59;
  uint64_t v60;
  uint64_t v61;

  v3 = 0;
  v4 = 0;
  v58 = 0;
  v59 = &v58;
  v60 = 0x2000000000;
  v61 = 0;
  if (a1)
  {
    v8 = CFGetTypeID(a1);
    if (CGImageMetadataGetTypeID::once != -1)
      dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_20);
    v3 = 0;
    if (!a3)
    {
      v4 = 0;
      goto LABEL_89;
    }
    v4 = 0;
    if (v8 == CGImageMetadataGetTypeID::id)
    {
      v9 = CFGetTypeID(a3);
      if (v9 == CFStringGetTypeID())
      {
        Source = CGImageSourceGetSource((uint64_t)Value);
        if (!Value)
        {
          v13 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          cf = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a3);
          v17 = 0;
          v18 = parse_metadata_pathString(cf);
          goto LABEL_21;
        }
        v11 = (IIOMetadata_Tag *)Source;
        v12 = CFGetTypeID(Value);
        if (v12 == CGImageMetadataTagGetTypeID())
        {
          v13 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          v14 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%@:%@"), *((_QWORD *)v11 + 3), *((_QWORD *)v11 + 4));
          if (v14)
          {
            cf = IIOMetadata_Tag::createPathWithChildPath(v11, a3);
            v15 = parse_metadata_pathString(v14);
            if (v15)
            {
              v16 = *((_QWORD *)v15 + 5);
              if (v16)
              {
                v17 = 0;
                do
                {
                  if ((*(_DWORD *)v16 & 0xFFFFFFFE) != 2)
                    break;
                  ++v17;
                  v16 = *(_QWORD *)(v16 + 40);
                }
                while (v16);
              }
              else
              {
                v17 = 0;
              }
              freeNodes(v15);
            }
            else
            {
              v17 = 0;
            }
            CFRelease(v14);
            v18 = parse_metadata_pathString(cf);
LABEL_21:
            v3 = v18;
            if (v18 && (v19 = (char *)*((_QWORD *)v18 + 1)) != 0 && *((_QWORD *)v3 + 2))
            {
              if (Value)
              {
                v20 = CGImageSourceGetSource((uint64_t)Value);
                v21 = v17 + 1;
                v22 = v3;
                do
                {
                  v22 = (char *)*((_QWORD *)v22 + 5);
                  --v21;
                }
                while (v21);
                PropertyPrefixFromCStrPrefix = 0;
                v50 = 0;
                goto LABEL_34;
              }
              PropertyPrefixFromCStrPrefix = createPropertyPrefixFromCStrPrefix(v19);
              v50 = CFStringCreateWithCString(v13, *((const char **)v3 + 2), 0x8000100u);
              if (v50)
              {
                v23 = CGImageMetadataNamespaceForPrefix(a1, PropertyPrefixFromCStrPrefix);
                if (v23)
                {
                  v24 = (const __CFDictionary *)a1[3];
                  if (v24)
                  {
                    key = v23;
                    p_isa = &v50->isa;
                    v56 = 0;
                    Value = (void *)CFDictionaryGetValue(v24, &key);
                  }
                  else
                  {
                    Value = 0;
                  }
                  v20 = CGImageSourceGetSource((uint64_t)Value);
                  v22 = (char *)*((_QWORD *)v3 + 5);
LABEL_34:
                  v25 = 0;
                  if (!Value || !v22)
                  {
                    v4 = Value;
                    v29 = 0;
                    goto LABEL_79;
                  }
                  while (1)
                  {
                    v26 = CFGetTypeID(Value);
                    if (v26 != CGImageMetadataTagGetTypeID())
                      break;
                    v27 = (char *)*((_QWORD *)v22 + 1);
                    if (v27)
                      v25 = createPropertyPrefixFromCStrPrefix(v27);
                    else
                      v25 = 0;
                    v28 = (const char *)*((_QWORD *)v22 + 2);
                    if (v28)
                      v29 = CFStringCreateWithCString(v13, v28, 0x8000100u);
                    else
                      v29 = 0;
                    switch(*(_DWORD *)v22)
                    {
                      case 2:
                        if (CGImageMetadataTagGetType((CGImageMetadataTagRef)Value) != kCGImageMetadataTypeArrayOrdered
                          && CGImageMetadataTagGetType((CGImageMetadataTagRef)Value) != kCGImageMetadataTypeArrayUnordered
                          && CGImageMetadataTagGetType((CGImageMetadataTagRef)Value) != kCGImageMetadataTypeAlternateArray)
                        {
                          goto LABEL_90;
                        }
                        v30 = (const void *)CGImageMetadataTagGetValue((uint64_t)Value);
                        v31 = CFGetTypeID(v30);
                        if (v31 != CFArrayGetTypeID())
                          goto LABEL_90;
                        v32 = *((int *)v22 + 6);
                        if (CFArrayGetCount((CFArrayRef)v30) <= v32)
                          goto LABEL_90;
                        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v30, *((int *)v22 + 6));
                        v34 = (uint64_t)ValueAtIndex;
                        if (!ValueAtIndex)
                          goto LABEL_90;
                        v35 = CFGetTypeID(ValueAtIndex);
                        TypeID = CGImageMetadataTagGetTypeID();
                        v37 = v59;
                        if (v35 == TypeID)
                          goto LABEL_63;
                        v59[3] = 0;
                        LogMetadata("CGImageMetadataGetTagWithPath", 740, "Error: Array element's value was not a CGImageMetadataTagRef\n");
                        goto LABEL_67;
                      case 3:
                        if (CGImageMetadataTagGetType((CGImageMetadataTagRef)Value) != kCGImageMetadataTypeAlternateText)
                          goto LABEL_90;
                        v38 = (const void *)CGImageMetadataTagGetValue((uint64_t)Value);
                        v39 = CFGetTypeID(v38);
                        if (v39 != CFArrayGetTypeID())
                          goto LABEL_90;
                        v40 = CFStringCreateWithCString(v13, *((const char **)v22 + 4), 0x8000100u);
                        v41 = v40;
                        if (!v40)
                          goto LABEL_90;
                        key = 0;
                        p_isa = &key;
                        v56 = 0x2000000000;
                        v57 = 0;
                        v53[0] = MEMORY[0x1E0C809B0];
                        v53[1] = 0x40000000;
                        v53[2] = __CGImageMetadataGetTagWithPath_block_invoke;
                        v53[3] = &unk_1E1BC4D50;
                        v53[5] = &key;
                        v53[6] = v40;
                        v53[4] = &v58;
                        IIOArrayEnumerateUsingBlock((uint64_t)v38, (uint64_t)v53);
                        if (!*((_BYTE *)p_isa + 24))
                          v59[3] = 0;
                        CFRelease(v41);
                        _Block_object_dispose(&key, 8);
                        goto LABEL_67;
                      case 4:
                        if (CGImageMetadataTagGetType((CGImageMetadataTagRef)Value) != kCGImageMetadataTypeStructure
                          || (v42 = (const void *)CGImageMetadataTagGetValue((uint64_t)Value),
                              v43 = CFGetTypeID(v42),
                              v43 != CFDictionaryGetTypeID())
                          || !v29
                          || (v44 = CFDictionaryGetValue((CFDictionaryRef)v42, v29), (v34 = (uint64_t)v44) == 0))
                        {
LABEL_90:
                          v4 = 0;
                          goto LABEL_79;
                        }
                        v45 = CFGetTypeID(v44);
                        v46 = CGImageMetadataTagGetTypeID();
                        v37 = v59;
                        if (v45 == v46)
                        {
LABEL_63:
                          v37[3] = v34;
                        }
                        else
                        {
                          v59[3] = 0;
                          LogMetadata("CGImageMetadataGetTagWithPath", 717, "Error: Structure field's value was not a CGImageMetadataTagRef\n");
                        }
LABEL_67:
                        v22 = (char *)*((_QWORD *)v22 + 5);
                        Value = (void *)v59[3];
                        if (v22 && !Value)
                        {
                          v20 = 0;
                          if (!v25)
                            goto LABEL_73;
LABEL_72:
                          CFRelease(v25);
                          goto LABEL_73;
                        }
                        v20 = CGImageSourceGetSource(v59[3]);
                        v59[3] = 0;
                        if (v25)
                          goto LABEL_72;
LABEL_73:
                        if (v29)
                          CFRelease(v29);
                        if (!Value || !v22)
                        {
                          v25 = 0;
                          v29 = 0;
                          v4 = Value;
                          goto LABEL_79;
                        }
                        break;
                      case 5:
                        v47 = *(_QWORD *)(v20 + 56);
                        if (v47)
                        {
                          v52[0] = MEMORY[0x1E0C809B0];
                          v52[1] = 0x40000000;
                          v52[2] = __CGImageMetadataGetTagWithPath_block_invoke_2;
                          v52[3] = &unk_1E1BC4D78;
                          v52[5] = v25;
                          v52[6] = v29;
                          v52[4] = &v58;
                          IIOArrayEnumerateUsingBlock(v47, (uint64_t)v52);
                        }
                        goto LABEL_67;
                      default:
                        goto LABEL_67;
                    }
                  }
                }
                v4 = 0;
                goto LABEL_92;
              }
              v4 = 0;
            }
            else
            {
              v4 = 0;
              PropertyPrefixFromCStrPrefix = 0;
            }
            v50 = 0;
LABEL_92:
            v25 = 0;
            v29 = 0;
LABEL_79:
            if (cf)
              CFRelease(cf);
            if (PropertyPrefixFromCStrPrefix)
              CFRelease(PropertyPrefixFromCStrPrefix);
            if (v50)
              CFRelease(v50);
            if (v25)
              CFRelease(v25);
            if (v29)
              CFRelease(v29);
            goto LABEL_89;
          }
        }
      }
      v3 = 0;
      v4 = 0;
    }
  }
LABEL_89:
  freeNodes(v3);
  _Block_object_dispose(&v58, 8);
  return v4;
}

void sub_187E3F3BC(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

uint64_t CGImageSourceGetSource(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 24);
  return result;
}

void freeNodes(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  void *v3;
  void *v4;
  void *v5;

  if (a1)
  {
    v1 = a1;
    do
    {
      v2 = (_QWORD *)v1[5];
      v3 = (void *)v1[1];
      if (v3)
        free(v3);
      v4 = (void *)v1[2];
      if (v4)
        free(v4);
      v5 = (void *)v1[4];
      if (v5)
        free(v5);
      free(v1);
      v1 = v2;
    }
    while (v2);
  }
}

char *parse_metadata_pathString(const __CFString *a1)
{
  char *CStringPtr;
  char *v3;
  CFIndex Length;
  CFIndex v5;
  char *v6;
  char *v7;

  pthread_mutex_lock(&parse_metadata_pathString::mutex);
  CStringPtr = (char *)CFStringGetCStringPtr(a1, 0);
  if (CStringPtr)
  {
    v3 = parse_metadata_path(CStringPtr);
  }
  else
  {
    Length = CFStringGetLength(a1);
    v5 = CFStringGetMaximumSizeForEncoding(Length, 0) + 1;
    v6 = (char *)malloc_type_calloc(1uLL, v5, 0x1419E70BuLL);
    if (v6)
    {
      v7 = v6;
      if (CFStringGetCString(a1, v6, v5, 0))
        v3 = parse_metadata_path(v7);
      else
        v3 = 0;
      free(v7);
    }
    else
    {
      v3 = 0;
    }
  }
  pthread_mutex_unlock(&parse_metadata_pathString::mutex);
  return v3;
}

char *parse_metadata_path(char *result)
{
  char *v1;
  void **v2;
  int v3;
  size_t v4;
  char *v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;

  if (result)
  {
    v1 = result;
    v7 = 0;
    v8 = 0;
    v9 = malloc_type_calloc(0x18uLL, 1uLL, 0x2CD795DAuLL);
    yylex_init_extra((uint64_t)v9, &v7);
    v8 = 0;
    v2 = (void **)yy_scan_string(v1, v7);
    if (yyparse(&v7))
    {
      if (v9)
      {
        v3 = *((_DWORD *)v9 + 2) - *((_DWORD *)v9 + 1);
        v4 = v3 & ~(v3 >> 31);
        result = (char *)malloc_type_malloc((v4 + 1), 0x4AD4B78FuLL);
        if (!result)
          return result;
        v5 = result;
        memset(result, 126, v4);
        v5[v4] = 0;
        LogMetadata("parse_metadata_path", 72, "Error occured '%s' at columns: %d:%d while parsing metadata path.\n%s\n%*s%s\n", *((const char **)v9 + 2), *((_DWORD *)v9 + 1), *((_DWORD *)v9 + 2), v1, *((_DWORD *)v9 + 1) + 1, "^", v5);
        free(v5);
      }
      else
      {
        LogMetadata("parse_metadata_path", 77, "Error occured while parsing metadata path: '%s'", v1);
      }
      return 0;
    }
    else
    {
      yy_delete_buffer(v2, v7);
      v6 = v9;
      if (v9)
      {
        if (*((_QWORD *)v9 + 2))
        {
          free(*((void **)v9 + 2));
          v6 = v9;
        }
        free(v6);
      }
      yylex_destroy(v7);
      return (char *)v8;
    }
  }
  return result;
}

uint64_t yylex_destroy(uint64_t a1)
{
  _QWORD *i;

  for (i = *(_QWORD **)(a1 + 40); i; i = *(_QWORD **)(a1 + 40))
  {
    if (!i[*(_QWORD *)(a1 + 24)])
      break;
    yy_delete_buffer((void **)i[*(_QWORD *)(a1 + 24)], a1);
    *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * *(_QWORD *)(a1 + 24)) = 0;
    yypop_buffer_state(a1);
  }
  free(i);
  *(_QWORD *)(a1 + 40) = 0;
  free(*(void **)(a1 + 96));
  free((void *)a1);
  return 0;
}

_QWORD *yy_scan_bytes(char *a1, int a2, uint64_t a3)
{
  size_t v6;
  _BYTE *v7;
  uint64_t v8;
  _BYTE *v9;
  char v10;
  _QWORD *result;
  FILE *v12;
  const char *v13;

  v6 = a2 + 2;
  v7 = malloc_type_malloc(v6, 0xB53DB697uLL);
  if (!v7)
  {
    v12 = (FILE *)*MEMORY[0x1E0C80C10];
    v13 = "out of dynamic memory in yy_scan_bytes()";
    goto LABEL_9;
  }
  if (a2 >= 1)
  {
    v8 = a2;
    v9 = v7;
    do
    {
      v10 = *a1++;
      *v9++ = v10;
      --v8;
    }
    while (v8);
  }
  *(_WORD *)&v7[a2] = 0;
  result = yy_scan_buffer((uint64_t)v7, v6, a3);
  if (!result)
  {
    v12 = (FILE *)*MEMORY[0x1E0C80C10];
    v13 = "bad buffer in yy_scan_bytes()";
LABEL_9:
    fprintf(v12, "%s\n", v13);
    exit(2);
  }
  *((_DWORD *)result + 9) = 1;
  return result;
}

uint64_t yyparse(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  char *v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  int *v19;
  int v20;
  int *v21;
  int v22;
  __int16 *v23;
  int v24;
  uint64_t v25;
  BOOL v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  int v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;

  v38 = 0;
  yynerrs = 0;
  v35 = 0u;
  v36 = 0u;
  v37 = 0u;
  if (!yygrowstack((uint64_t)&v35))
  {
    v8 = 0;
    v9 = -1;
    *(_QWORD *)&v36 = *((_QWORD *)&v35 + 1);
    *((_QWORD *)&v37 + 1) = v37;
    **((_WORD **)&v35 + 1) = 0;
    while (((0x1FC3C3BuLL >> v8) & 1) != 0)
    {
      if (v9 < 0)
      {
        v11 = yylex((uint64_t)&v38, *a1, v2, v3, v4, v5, v6, v7);
        v9 = v11 & ~(v11 >> 31);
      }
      if (((0x603C3CCuLL >> v8) & 1) != 0
        || (v12 = (v9 + yysindex[v8]), v12 > 0x111)
        || v9 != (__int16)yycheck[v12])
      {
        if (((0x783DBCFuLL >> v8) & 1) != 0
          || (v14 = (v9 + yyrindex[v8]), v14 > 0x111)
          || v9 != (__int16)yycheck[v14])
        {
          yyerror((uint64_t)a1, "syntax error", v2, v3, v4, v5, v6, v7, v35);
          ++yynerrs;
          v31 = v36;
          v32 = *((_QWORD *)&v37 + 1);
          while (v31 > *((_QWORD *)&v35 + 1))
          {
            v31 -= 2;
            v32 -= 8;
          }
          *(_QWORD *)&v36 = v31;
          *((_QWORD *)&v37 + 1) = v32;
          goto LABEL_62;
        }
        v10 = (char *)&yytable[v14];
LABEL_19:
        v15 = *(__int16 *)v10;
        v16 = yylen[v15];
        v17 = (uint64_t *)*((_QWORD *)&v37 + 1);
        v18 = *(_QWORD *)(*((_QWORD *)&v37 + 1) + 8 * (1 - v16));
        switch((int)v15)
        {
          case 1:
            v18 = **((_QWORD **)&v37 + 1);
            goto LABEL_25;
          case 2:
            v18 = *(_QWORD *)(*((_QWORD *)&v37 + 1) - 16);
            v19 = (int *)**((_QWORD **)&v37 + 1);
            v20 = 4;
            goto LABEL_24;
          case 3:
            v18 = *(_QWORD *)(*((_QWORD *)&v37 + 1) - 16);
            v19 = (int *)**((_QWORD **)&v37 + 1);
            v20 = 5;
LABEL_24:
            *v19 = v20;
            appendNode(v18, *v17);
            fixPrefixes((char *)v18);
LABEL_25:
            a1[1] = v18;
            break;
          case 5:
          case 10:
          case 11:
          case 15:
          case 17:
            v18 = **((_QWORD **)&v37 + 1);
            break;
          case 6:
            v18 = *(_QWORD *)(*((_QWORD *)&v37 + 1) - 16);
            v21 = (int *)**((_QWORD **)&v37 + 1);
            v22 = 4;
            goto LABEL_28;
          case 7:
            v18 = *(_QWORD *)(*((_QWORD *)&v37 + 1) - 16);
            v21 = (int *)**((_QWORD **)&v37 + 1);
            v22 = 5;
LABEL_28:
            *v21 = v22;
            goto LABEL_37;
          case 8:
            v18 = **((_QWORD **)&v37 + 1);
            goto LABEL_35;
          case 9:
            v18 = *(_QWORD *)(*((_QWORD *)&v37 + 1) - 8);
            *(_DWORD *)v18 = 1;
            goto LABEL_37;
          case 12:
            v18 = **((_QWORD **)&v37 + 1);
            ***((_DWORD ***)&v37 + 1) = 0;
            break;
          case 13:
            v18 = *(_QWORD *)(*((_QWORD *)&v37 + 1) - 8);
            *(_DWORD *)v18 = 0;
            goto LABEL_37;
          case 14:
            v18 = **((_QWORD **)&v37 + 1);
            *(_QWORD *)(**((_QWORD **)&v37 + 1) + 8) = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)&v37 + 1) - 8) + 8);
            free((void *)*(v17 - 1));
            break;
          case 16:
            v18 = *(_QWORD *)(*((_QWORD *)&v37 + 1) - 8);
            *(_QWORD *)(v18 + 16) = *(_QWORD *)(**((_QWORD **)&v37 + 1) + 16);
            free((void *)*v17);
LABEL_35:
            *(_DWORD *)v18 = 1;
            break;
          case 18:
            v18 = *(_QWORD *)(*((_QWORD *)&v37 + 1) - 8);
LABEL_37:
            appendNode(v18, *v17);
            break;
          case 19:
            v18 = **((_QWORD **)&v37 + 1);
            ***((_DWORD ***)&v37 + 1) = 3;
            break;
          case 20:
            v18 = **((_QWORD **)&v37 + 1);
            ***((_DWORD ***)&v37 + 1) = 2;
            break;
          default:
            break;
        }
        v23 = (__int16 *)(v36 - 2 * v16);
        *(_QWORD *)&v36 = v23;
        v24 = *v23;
        v25 = *((_QWORD *)&v37 + 1) - 8 * v16;
        *((_QWORD *)&v37 + 1) = v25;
        if (v24)
          v26 = 1;
        else
          v26 = (unint64_t)(v15 - 1) > 3;
        if (v26)
        {
          v27 = yylhs[v15];
          if (((0x19uLL >> v27) & 1) != 0
            || (v28 = (yygindex[v27] + v24), v28 > 0x111)
            || yycheck[v28] != (unsigned __int16)v24)
          {
            v29 = (char *)&yydgoto + 2 * v27;
          }
          else
          {
            v29 = (char *)&yytable[v28];
          }
          v8 = *(__int16 *)v29;
          if ((unint64_t)v23 >= *((_QWORD *)&v36 + 1))
          {
            if (yygrowstack((uint64_t)&v35))
              goto LABEL_2;
            v23 = (__int16 *)v36;
            v25 = *((_QWORD *)&v37 + 1);
          }
          v23[1] = v8;
          *(_QWORD *)&v36 = v23 + 1;
          *((_QWORD *)&v37 + 1) = v25 + 8;
          *(_QWORD *)(v25 + 8) = v18;
        }
        else
        {
          v23[1] = 3;
          *(_QWORD *)&v36 = v23 + 1;
          *((_QWORD *)&v37 + 1) = v25 + 8;
          *(_QWORD *)(v25 + 8) = v18;
          if (v9 < 0)
          {
            v30 = yylex((uint64_t)&v38, *a1, v2, v3, v4, v5, v6, v7);
            v9 = v30 & ~(v30 >> 31);
          }
          v8 = 3;
          if (!v9)
          {
            v34 = 0;
            goto LABEL_63;
          }
        }
      }
      else
      {
        v13 = v36;
        if ((unint64_t)v36 >= *((_QWORD *)&v36 + 1))
        {
          if (yygrowstack((uint64_t)&v35))
            goto LABEL_2;
          v13 = v36;
        }
        v8 = yytable[v12];
        *(_WORD *)(v13 + 2) = v8;
        *(_QWORD *)&v36 = v13 + 2;
        *((_QWORD *)&v37 + 1) += 8;
        **((_QWORD **)&v37 + 1) = v38;
        v9 = -1;
      }
    }
    v10 = &yydefred[2 * v8];
    goto LABEL_19;
  }
LABEL_2:
  yyerror((uint64_t)a1, "yacc stack overflow", v2, v3, v4, v5, v6, v7, v35);
LABEL_62:
  v34 = 1;
LABEL_63:
  yyfreestack((uint64_t)&v35);
  return v34;
}

uint64_t yylex(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t buffer;
  _BYTE *v14;
  _BYTE *v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  _BYTE **v21;
  _BYTE *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  unint64_t v29;
  _BYTE *v30;
  uint64_t v31;
  char *v32;
  unint64_t v33;
  int v34;
  int v35;
  char v36;
  size_t v37;
  int v38;
  int v39;
  unint64_t v40;
  int v41;
  char *v42;
  void *v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  size_t v47;
  int v48;
  int v50;
  int v51;
  void *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  int previous_state;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  int v64;
  int v65;
  BOOL v66;
  int *v67;
  size_t v68;
  int v69;
  int *v70;
  int v71;
  int *v73;
  int v74;
  int *v75;
  int v76;
  int v77;
  uint64_t v78;
  int *v79;
  int v80;
  const char *v81;
  char *v82;
  uint64_t v83;
  int *v84;
  int v85;
  int *v86;
  int v87;
  int *v88;
  int v89;
  FILE *v90;
  const char *v91;
  uint64_t v92;
  int v93;
  _BYTE *v94;
  int v95;
  unint64_t *v96;
  _BYTE *v97;

  *(_QWORD *)(a2 + 144) = a1;
  if (!*(_DWORD *)(a2 + 72))
  {
    *(_DWORD *)(a2 + 72) = 1;
    v9 = *(int **)a2;
    if (*(_QWORD *)a2)
    {
      v9[2] = 0;
      *(_QWORD *)v9 = 0;
      *((_QWORD *)v9 + 2) = 0;
    }
    if (!*(_DWORD *)(a2 + 76))
      *(_DWORD *)(a2 + 76) = 1;
    if (!*(_QWORD *)(a2 + 8))
      *(_QWORD *)(a2 + 8) = *MEMORY[0x1E0C80C18];
    if (!*(_QWORD *)(a2 + 16))
      *(_QWORD *)(a2 + 16) = *MEMORY[0x1E0C80C20];
    v10 = *(_QWORD *)(a2 + 40);
    if (!v10 || (v11 = *(_QWORD *)(a2 + 24), (v12 = *(_QWORD *)(v10 + 8 * v11)) == 0))
    {
      yyensure_buffer_stack((_QWORD *)a2);
      buffer = yy_create_buffer(*(_QWORD *)(a2 + 8), 0x4000, a2);
      v11 = *(_QWORD *)(a2 + 24);
      *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8 * v11) = buffer;
      v10 = *(_QWORD *)(a2 + 40);
      v12 = *(_QWORD *)(v10 + 8 * v11);
    }
    *(_DWORD *)(a2 + 52) = *(_DWORD *)(v12 + 32);
    v14 = *(_BYTE **)(v12 + 16);
    *(_QWORD *)(a2 + 64) = v14;
    *(_QWORD *)(a2 + 128) = v14;
    *(_QWORD *)(a2 + 8) = **(_QWORD **)(v10 + 8 * v11);
    *(_BYTE *)(a2 + 48) = *v14;
  }
  v96 = (unint64_t *)(a2 + 64);
LABEL_15:
  v15 = *(_BYTE **)(a2 + 64);
  *v15 = *(_BYTE *)(a2 + 48);
  v16 = *(_DWORD *)(a2 + 76);
  v94 = v15;
  do
  {
LABEL_16:
    v17 = yy_ec[4 * *v15];
    if (((0xD84007uLL >> v16) & 1) == 0)
    {
      *(_DWORD *)(a2 + 104) = v16;
      *(_QWORD *)(a2 + 112) = v15;
    }
    v18 = v17 + yy_base[v16];
    if (v16 != (__int16)yy_chk[v18])
    {
      v19 = v16;
      do
      {
        if (((0x104500uLL >> v19) & 1) != 0)
          LOBYTE(v17) = yy_meta[4 * v17];
        v19 = yy_def[v19];
        v18 = yy_base[v19] + v17;
      }
      while (yy_chk[v18] != (unsigned __int16)v19);
    }
    v16 = yy_nxt[v18];
    ++v15;
  }
  while (v16 != 23);
LABEL_24:
  while (2)
  {
    v20 = *(_DWORD *)(a2 + 104);
    v21 = (_BYTE **)(a2 + 112);
LABEL_25:
    v22 = *v21;
    v23 = yy_accept[v20];
    *(_QWORD *)(a2 + 128) = v94;
    *(_DWORD *)(a2 + 56) = (_DWORD)v22 - (_DWORD)v94;
    *(_BYTE *)(a2 + 48) = *v22;
    *v22 = 0;
    v97 = v22;
    *(_QWORD *)(a2 + 64) = v22;
    while (v23 == 9)
    {
      v24 = *(_QWORD *)(a2 + 128);
      *v97 = *(_BYTE *)(a2 + 48);
      v25 = *(_QWORD *)(a2 + 40);
      v26 = *(_QWORD *)(a2 + 24);
      v27 = *(_QWORD *)(v25 + 8 * v26);
      if (*(_DWORD *)(v27 + 60))
      {
        v28 = *(_DWORD *)(a2 + 52);
      }
      else
      {
        v28 = *(_DWORD *)(v27 + 32);
        *(_DWORD *)(a2 + 52) = v28;
        *(_QWORD *)v27 = *(_QWORD *)(a2 + 8);
        v27 = *(_QWORD *)(v25 + 8 * v26);
        *(_DWORD *)(v27 + 60) = 1;
      }
      v29 = *v96;
      v30 = *(_BYTE **)(v27 + 8);
      if (*v96 <= (unint64_t)&v30[v28])
      {
        *(_QWORD *)(a2 + 64) = *(_QWORD *)(a2 + 128) + ~(_DWORD)v24 + (int)v97;
        previous_state = yy_get_previous_state(a2);
        if (((0xD84007uLL >> previous_state) & 1) == 0)
        {
          v61 = *(_QWORD *)(a2 + 64);
          *(_DWORD *)(a2 + 104) = previous_state;
          *(_QWORD *)(a2 + 112) = v61;
        }
        v62 = yy_base[previous_state] + 1;
        if (previous_state != (__int16)yy_chk[v62])
        {
          v63 = previous_state;
          do
          {
            v64 = (unsigned __int16)yy_def[v63];
            v63 = (__int16)v64;
          }
          while (v64 != yy_chk[yy_base[(__int16)v64] + 1]);
          LODWORD(v62) = yy_base[(__int16)v64] + 1;
        }
        v65 = (unsigned __int16)yy_nxt[v62];
        v94 = *(_BYTE **)(a2 + 128);
        if ((_DWORD)v62)
          v66 = v65 == 23;
        else
          v66 = 1;
        if (!v66)
        {
          v16 = (__int16)v65;
          v15 = (_BYTE *)(*v96 + 1);
          *v96 = (unint64_t)v15;
          goto LABEL_16;
        }
        goto LABEL_24;
      }
      v31 = v28;
      if (v29 > (unint64_t)&v30[v28 + 1])
      {
        v90 = (FILE *)*MEMORY[0x1E0C80C10];
        v91 = "fatal flex scanner internal error--end of buffer missed";
        goto LABEL_128;
      }
      v32 = *(char **)(a2 + 128);
      v33 = v29 - (_QWORD)v32;
      if (!*(_DWORD *)(v27 + 56))
      {
        if (v33 != 1)
          goto LABEL_86;
        goto LABEL_80;
      }
      v34 = v33 - 1;
      if ((int)v33 >= 2)
      {
        v35 = v33 - 1;
        do
        {
          v36 = *v32++;
          *v30++ = v36;
          --v35;
        }
        while (v35);
        v27 = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8 * *(_QWORD *)(a2 + 24));
      }
      v95 = v33 - 1;
      v93 = v24;
      if (*(_DWORD *)(v27 + 60) == 2)
      {
        *(_DWORD *)(a2 + 52) = 0;
LABEL_39:
        *(_DWORD *)(v27 + 32) = 0;
        if (!v34)
          goto LABEL_74;
        goto LABEL_40;
      }
      v92 = v34;
      v39 = ~v34;
      v40 = *(_QWORD *)(v27 + 24);
      v41 = v40 - v33;
      if ((int)v40 - (int)v33 <= 0)
      {
        v42 = (char *)*v96;
        while (*(_DWORD *)(v27 + 36))
        {
          v43 = *(void **)(v27 + 8);
          v44 = 2 * v40;
          v45 = v40 + (v40 >> 3);
          if ((int)v44 >= 1)
            v45 = v44;
          *(_QWORD *)(v27 + 24) = v45;
          v46 = (char *)malloc_type_realloc(v43, v45 + 2, 0xFAA2C7D0uLL);
          *(_QWORD *)(v27 + 8) = v46;
          if (!v46)
            goto LABEL_127;
          v42 = &v46[(int)v42 - (int)v43];
          *(_QWORD *)(a2 + 64) = v42;
          v27 = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8 * *(_QWORD *)(a2 + 24));
          v40 = *(_QWORD *)(v27 + 24);
          v41 = v40 + v39;
          if ((int)v40 + v39 >= 1)
            goto LABEL_50;
        }
        *(_QWORD *)(v27 + 8) = 0;
LABEL_127:
        v90 = (FILE *)*MEMORY[0x1E0C80C10];
        v91 = "fatal error - scanner input buffer overflow";
LABEL_128:
        fprintf(v90, "%s\n", v91);
        exit(2);
      }
LABEL_50:
      if (v41 >= 0x2000)
        v47 = 0x2000;
      else
        v47 = v41;
      if (!*(_DWORD *)(v27 + 40))
      {
        *__error() = 0;
        v50 = fread((void *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 8 * *(_QWORD *)(a2 + 24)) + 8) + v92), 1uLL, v47, *(FILE **)(a2 + 8));
        *(_DWORD *)(a2 + 52) = v50;
        if (v50)
        {
LABEL_68:
          v38 = 0;
          v27 = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8 * *(_QWORD *)(a2 + 24));
          *(_DWORD *)(v27 + 32) = v50;
          LODWORD(v37) = v50;
LABEL_72:
          v34 = v95;
          goto LABEL_75;
        }
        while (ferror(*(FILE **)(a2 + 8)))
        {
          if (*__error() != 4)
            goto LABEL_131;
          *__error() = 0;
          clearerr(*(FILE **)(a2 + 8));
          v50 = fread((void *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 8 * *(_QWORD *)(a2 + 24)) + 8) + v92), 1uLL, v47, *(FILE **)(a2 + 8));
          *(_DWORD *)(a2 + 52) = v50;
          if (v50)
            goto LABEL_68;
        }
        v27 = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8 * *(_QWORD *)(a2 + 24));
        v34 = v95;
        goto LABEL_39;
      }
      v37 = 0;
      while (1)
      {
        v48 = getc(*(FILE **)(a2 + 8));
        if (v48 == -1 || v48 == 10)
          break;
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 8 * *(_QWORD *)(a2 + 24)) + 8) + v92 + v37++) = v48;
        if (v47 == v37)
        {
          v37 = v47;
          break;
        }
      }
      if (v48 == -1)
      {
        if (ferror(*(FILE **)(a2 + 8)))
        {
LABEL_131:
          v90 = (FILE *)*MEMORY[0x1E0C80C10];
          v91 = "input in flex scanner failed";
          goto LABEL_128;
        }
      }
      else if (v48 == 10)
      {
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 8 * *(_QWORD *)(a2 + 24)) + 8) + v92 + v37) = 10;
        LODWORD(v37) = v37 + 1;
      }
      *(_DWORD *)(a2 + 52) = v37;
      v27 = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8 * *(_QWORD *)(a2 + 24));
      *(_DWORD *)(v27 + 32) = v37;
      if ((_DWORD)v37)
      {
        v38 = 0;
        goto LABEL_72;
      }
      v34 = v95;
      if (!v95)
      {
LABEL_74:
        yyrestart(*(_QWORD *)(a2 + 8), a2);
        v34 = v95;
        LODWORD(v37) = *(_DWORD *)(a2 + 52);
        v27 = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8 * *(_QWORD *)(a2 + 24));
        v38 = 1;
        goto LABEL_75;
      }
LABEL_40:
      LODWORD(v37) = 0;
      v38 = 2;
      *(_DWORD *)(v27 + 60) = 2;
LABEL_75:
      v51 = v37 + v34;
      if (*(_QWORD *)(v27 + 24) >= (unint64_t)((int)v37 + v34))
      {
        v56 = v51;
        v55 = *(_QWORD *)(v27 + 8);
      }
      else
      {
        v52 = malloc_type_realloc(*(void **)(v27 + 8), v51 + ((int)v37 >> 1), 0xFAA2C7D0uLL);
        v53 = *(_QWORD *)(a2 + 40);
        v54 = *(_QWORD *)(a2 + 24);
        *(_QWORD *)(*(_QWORD *)(v53 + 8 * v54) + 8) = v52;
        v55 = *(_QWORD *)(*(_QWORD *)(v53 + 8 * v54) + 8);
        if (!v55)
        {
          v90 = (FILE *)*MEMORY[0x1E0C80C10];
          v91 = "out of dynamic memory in yy_get_next_buffer()";
          goto LABEL_128;
        }
        v56 = *(int *)(a2 + 52) + (uint64_t)v95;
        v51 = *(_DWORD *)(a2 + 52) + v95;
      }
      *(_DWORD *)(a2 + 52) = v51;
      *(_BYTE *)(v55 + v56) = 0;
      *(_BYTE *)(*(int *)(a2 + 52)
               + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + 8 * *(_QWORD *)(a2 + 24)) + 8)
               + 1) = 0;
      v57 = *(_QWORD *)(a2 + 40);
      v58 = *(_QWORD *)(a2 + 24);
      v32 = *(char **)(*(_QWORD *)(v57 + 8 * v58) + 8);
      *(_QWORD *)(a2 + 128) = v32;
      if (v38 != 1)
      {
        if (!v38)
        {
          *(_QWORD *)(a2 + 64) = &v32[~v93 + (int)v97];
          v16 = yy_get_previous_state(a2);
          v15 = *(_BYTE **)(a2 + 64);
          v94 = *(_BYTE **)(a2 + 128);
          goto LABEL_16;
        }
        v30 = *(_BYTE **)(*(_QWORD *)(v57 + 8 * v58) + 8);
        v31 = *(int *)(a2 + 52);
LABEL_86:
        *(_QWORD *)(a2 + 64) = &v30[v31];
        v20 = yy_get_previous_state(a2);
        v94 = *(_BYTE **)(a2 + 128);
        v21 = (_BYTE **)(a2 + 64);
        goto LABEL_25;
      }
LABEL_80:
      *(_DWORD *)(a2 + 80) = 0;
      *(_QWORD *)(a2 + 64) = v32;
      v59 = *(_DWORD *)(a2 + 76);
      if (v59 >= 1)
        --v59;
      v23 = (v59 >> 1) + 10;
    }
    switch(v23)
    {
      case 0:
        *v97 = *(_BYTE *)(a2 + 48);
        continue;
      case 1:
        v70 = *(int **)a2;
        if (*(_QWORD *)a2)
        {
          v71 = *v70 + *(_DWORD *)(a2 + 56);
          v70[1] = *v70;
          v70[2] = v71 - 1;
          *v70 = v71;
        }
        **(_QWORD **)(a2 + 144) = malloc_type_calloc(1uLL, 0x30uLL, 0x103004087E73D75uLL);
        *(_QWORD *)(**(_QWORD **)(a2 + 144) + 8) = strdup(*(const char **)(a2 + 128));
        return 257;
      case 2:
        v73 = *(int **)a2;
        if (*(_QWORD *)a2)
        {
          v74 = *v73 + *(_DWORD *)(a2 + 56);
          v73[1] = *v73;
          v73[2] = v74 - 1;
          *v73 = v74;
        }
        **(_QWORD **)(a2 + 144) = malloc_type_calloc(1uLL, 0x30uLL, 0x103004087E73D75uLL);
        *(_QWORD *)(**(_QWORD **)(a2 + 144) + 16) = strdup(*(const char **)(a2 + 128));
        return 258;
      case 3:
        v75 = *(int **)a2;
        if (*(_QWORD *)a2)
        {
          v76 = *v75 + *(_DWORD *)(a2 + 56);
          v75[1] = *v75;
          v75[2] = v76 - 1;
          *v75 = v76;
        }
        **(_QWORD **)(a2 + 144) = malloc_type_calloc(1uLL, 0x30uLL, 0x103004087E73D75uLL);
        v77 = strtol((const char *)(*(_QWORD *)(a2 + 128) + 1), 0, 10);
        v78 = *(_QWORD *)(a2 + 144);
        *(_DWORD *)(*(_QWORD *)v78 + 24) = v77;
        *(_QWORD *)(*(_QWORD *)v78 + 16) = strdup(*(const char **)(a2 + 128));
        return 259;
      case 4:
        v79 = *(int **)a2;
        if (*(_QWORD *)a2)
        {
          v80 = *v79 + *(_DWORD *)(a2 + 56);
          v79[1] = *v79;
          v79[2] = v80 - 1;
          *v79 = v80;
        }
        **(_QWORD **)(a2 + 144) = malloc_type_calloc(1uLL, 0x30uLL, 0x103004087E73D75uLL);
        v81 = *(const char **)(a2 + 128);
        v82 = strdup(v81 + 1);
        v83 = *(_QWORD *)(a2 + 144);
        *(_QWORD *)(*(_QWORD *)v83 + 32) = v82;
        *(_BYTE *)(strlen(v81) + *(_QWORD *)(*(_QWORD *)v83 + 32) - 2) = 0;
        *(_QWORD *)(**(_QWORD **)(a2 + 144) + 16) = strdup(*(const char **)(a2 + 128));
        return 260;
      case 5:
        v84 = *(int **)a2;
        if (*(_QWORD *)a2)
        {
          v85 = *v84 + *(_DWORD *)(a2 + 56);
          v84[1] = *v84;
          v84[2] = v85 - 1;
          *v84 = v85;
        }
        return 261;
      case 6:
        v86 = *(int **)a2;
        if (*(_QWORD *)a2)
        {
          v87 = *v86 + *(_DWORD *)(a2 + 56);
          v86[1] = *v86;
          v86[2] = v87 - 1;
          *v86 = v87;
        }
        return 262;
      case 7:
        v88 = *(int **)a2;
        if (*(_QWORD *)a2)
        {
          v89 = *v88 + *(_DWORD *)(a2 + 56);
          v88[1] = *v88;
          v88[2] = v89 - 1;
          *v88 = v89;
        }
        lexerror((uint64_t)v88, "Unrecognized input: '%s'", a3, a4, a5, a6, a7, a8, *(_QWORD *)(a2 + 128));
        return 263;
      case 8:
        v67 = *(int **)a2;
        v68 = *(int *)(a2 + 56);
        if (*(_QWORD *)a2)
        {
          v69 = *v67 + v68;
          v67[1] = *v67;
          v67[2] = v69 - 1;
          *v67 = v69;
        }
        fwrite(*(const void **)(a2 + 128), v68, 1uLL, *(FILE **)(a2 + 16));
        goto LABEL_15;
      case 10:
        return 0;
      default:
        v90 = (FILE *)*MEMORY[0x1E0C80C10];
        v91 = "fatal flex scanner internal error--no action found";
        break;
    }
    goto LABEL_128;
  }
}

double yyfreestack(uint64_t a1)
{
  double result;

  free(*(void **)(a1 + 8));
  free(*(void **)(a1 + 32));
  result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  return result;
}

uint64_t yygrowstack(uint64_t a1)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  void *v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  uint64_t result;

  v2 = *(_DWORD *)a1;
  if (*(_DWORD *)a1)
  {
    if (v2 > 0x1F3)
      return 0xFFFFFFFFLL;
    v3 = 2 * v2;
    if (v3 >= 0x1F4)
      v4 = 500;
    else
      v4 = v3;
  }
  else
  {
    v4 = 500;
  }
  v5 = *(void **)(a1 + 8);
  v6 = *(_QWORD *)(a1 + 16);
  v7 = (char *)malloc_type_realloc(v5, 2 * v4, 0x1000040BDFB0063uLL);
  if (v7)
  {
    v8 = (v6 - (uint64_t)v5) >> 1;
    *(_QWORD *)(a1 + 8) = v7;
    *(_QWORD *)(a1 + 16) = &v7[2 * v8];
    v9 = (char *)malloc_type_realloc(*(void **)(a1 + 32), 8 * v4, 0x1032040A1E07149uLL);
    if (v9)
    {
      v10 = v9;
      result = 0;
      *(_QWORD *)(a1 + 32) = v10;
      *(_QWORD *)(a1 + 40) = &v10[8 * v8];
      *(_DWORD *)a1 = v4;
      *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 8) + 2 * v4 - 2;
      return result;
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t yylex_init_extra(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  int *v8;
  int v9;

  if (a2)
  {
    v4 = malloc_type_malloc(0x98uLL, 0xB53DB697uLL);
    *a2 = v4;
    if (v4)
    {
      v5 = v4;
      result = 0;
      v5[18] = 0;
      *((_OWORD *)v5 + 7) = 0u;
      *((_OWORD *)v5 + 8) = 0u;
      *((_OWORD *)v5 + 5) = 0u;
      *((_OWORD *)v5 + 6) = 0u;
      *((_OWORD *)v5 + 3) = 0u;
      *((_OWORD *)v5 + 4) = 0u;
      *((_OWORD *)v5 + 1) = 0u;
      *((_OWORD *)v5 + 2) = 0u;
      *(_OWORD *)v5 = 0u;
      *(_QWORD *)*a2 = a1;
      v7 = (_QWORD *)*a2;
      *((_DWORD *)v7 + 21) = 0;
      *((_DWORD *)v7 + 22) = 0;
      v7[12] = 0;
      *(_OWORD *)(v7 + 1) = 0u;
      *(_OWORD *)(v7 + 3) = 0u;
      v7[5] = 0;
      v7[8] = 0;
      v7[9] = 0;
      return result;
    }
    v8 = __error();
    v9 = 12;
  }
  else
  {
    v8 = __error();
    v9 = 22;
  }
  *v8 = v9;
  return 1;
}

void yy_delete_buffer(void **a1, uint64_t a2)
{
  uint64_t v3;
  void **v4;

  if (a1)
  {
    v3 = *(_QWORD *)(a2 + 40);
    if (v3)
      v4 = *(void ***)(v3 + 8 * *(_QWORD *)(a2 + 24));
    else
      v4 = 0;
    if (v4 == a1)
      *(_QWORD *)(v3 + 8 * *(_QWORD *)(a2 + 24)) = 0;
    if (*((_DWORD *)a1 + 9))
      free(a1[1]);
    free(a1);
  }
}

_QWORD *yy_scan_string(char *a1, uint64_t a2)
{
  int v4;

  v4 = strlen(a1);
  return yy_scan_bytes(a1, v4, a2);
}

_QWORD *yy_scan_buffer(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v3;
  _QWORD *v5;
  _QWORD *v8;

  v3 = a2 - 2;
  if (a2 < 2 || *(_BYTE *)(a1 + v3) || *(_BYTE *)(a2 + a1 - 1))
    return 0;
  v8 = malloc_type_malloc(0x40uLL, 0xB53DB697uLL);
  if (!v8)
  {
    fprintf((FILE *)*MEMORY[0x1E0C80C10], "%s\n", "out of dynamic memory in yy_scan_buffer()");
    exit(2);
  }
  v5 = v8;
  v8[2] = a1;
  v8[3] = v3;
  *v8 = 0;
  v8[1] = a1;
  *((_DWORD *)v8 + 8) = v3;
  *(_QWORD *)((char *)v8 + 36) = 0;
  *((_DWORD *)v8 + 11) = 1;
  v8[7] = 0;
  yy_switch_to_buffer((uint64_t)v8, a3);
  return v5;
}

void yy_switch_to_buffer(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;

  yyensure_buffer_stack((_QWORD *)a2);
  v4 = *(_QWORD *)(a2 + 40);
  if (v4)
  {
    v5 = *(_QWORD *)(a2 + 24);
    v6 = *(_QWORD *)(v4 + 8 * v5);
    if (v6 != a1)
    {
      if (v6)
      {
        **(_BYTE **)(a2 + 64) = *(_BYTE *)(a2 + 48);
        v4 = *(_QWORD *)(a2 + 40);
        v5 = *(_QWORD *)(a2 + 24);
        *(_QWORD *)(*(_QWORD *)(v4 + 8 * v5) + 16) = *(_QWORD *)(a2 + 64);
        *(_DWORD *)(*(_QWORD *)(v4 + 8 * v5) + 32) = *(_DWORD *)(a2 + 52);
      }
      *(_QWORD *)(v4 + 8 * v5) = a1;
      v7 = *(_QWORD *)(a2 + 40);
      v8 = *(_QWORD *)(v7 + 8 * v5);
      *(_DWORD *)(a2 + 52) = *(_DWORD *)(v8 + 32);
      v9 = *(_BYTE **)(v8 + 16);
      *(_QWORD *)(a2 + 64) = v9;
      *(_QWORD *)(a2 + 128) = v9;
      *(_QWORD *)(a2 + 8) = **(_QWORD **)(v7 + 8 * v5);
      *(_BYTE *)(a2 + 48) = *v9;
      *(_DWORD *)(a2 + 80) = 1;
    }
  }
}

double yyensure_buffer_stack(_QWORD *a1)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;
  char *v6;
  double result;
  _QWORD *v8;

  v2 = (void *)a1[5];
  if (v2)
  {
    v3 = a1[4];
    if (a1[3] >= (unint64_t)(v3 - 1))
    {
      v4 = (v3 << 32) + 0x800000000;
      v5 = (char *)malloc_type_realloc(v2, v4 >> 29, 0xFAA2C7D0uLL);
      a1[5] = v5;
      if (v5)
      {
        v6 = &v5[8 * a1[4]];
        result = 0.0;
        *((_OWORD *)v6 + 2) = 0u;
        *((_OWORD *)v6 + 3) = 0u;
        *(_OWORD *)v6 = 0u;
        *((_OWORD *)v6 + 1) = 0u;
        a1[4] = v4 >> 32;
        return result;
      }
LABEL_8:
      fprintf((FILE *)*MEMORY[0x1E0C80C10], "%s\n", "out of dynamic memory in yyensure_buffer_stack()");
      exit(2);
    }
  }
  else
  {
    v8 = malloc_type_malloc(8uLL, 0xB53DB697uLL);
    a1[5] = v8;
    if (!v8)
      goto LABEL_8;
    *v8 = 0;
    result = 0.0;
    *(_OWORD *)(a1 + 3) = xmmword_18820C490;
  }
  return result;
}

uint64_t yy_get_previous_state(uint64_t a1)
{
  uint64_t v1;
  _BYTE *v2;
  _BYTE *v3;
  uint64_t v4;
  int v5;

  v1 = *(unsigned int *)(a1 + 76);
  v2 = *(_BYTE **)(a1 + 128);
  v3 = *(_BYTE **)(a1 + 64);
  if (v2 < v3)
  {
    do
    {
      if (*v2)
        LODWORD(v4) = yy_ec[4 * *v2];
      else
        LODWORD(v4) = 1;
      if (((0xD84007uLL >> v1) & 1) == 0)
      {
        *(_DWORD *)(a1 + 104) = v1;
        *(_QWORD *)(a1 + 112) = v2;
      }
      v5 = v4 + yy_base[(int)v1];
      if ((_DWORD)v1 != (__int16)yy_chk[v5])
      {
        v4 = v4;
        v1 = (int)v1;
        do
        {
          if (((0x104500uLL >> v1) & 1) != 0)
            LOBYTE(v4) = yy_meta[4 * v4];
          v1 = yy_def[v1];
          v5 = yy_base[v1] + v4;
        }
        while (yy_chk[v5] != (unsigned __int16)v1);
      }
      v1 = yy_nxt[v5];
      ++v2;
    }
    while (v2 != v3);
  }
  return v1;
}

const void *CGImageMetadataNamespaceForPrefix(const void *result, const __CFString *a2)
{
  const void *v3;
  CFTypeID v4;
  CFTypeID TypeID;
  CFTypeID v6;
  const __CFDictionary *v7;
  CFTypeID v8;
  const void *v9;
  CFTypeID v10;

  if (result)
  {
    v3 = result;
    v4 = CFGetTypeID(result);
    TypeID = CGImageMetadataGetTypeID();
    result = 0;
    if (a2)
    {
      if (v4 == TypeID)
      {
        v6 = CFGetTypeID(a2);
        if (v6 != CFStringGetTypeID())
          return 0;
        result = CGImageMetadataNamespaceForDefaultPrefix(a2);
        if (result)
          return result;
        v7 = (const __CFDictionary *)*((_QWORD *)v3 + 5);
        if (v7 && (v8 = CFGetTypeID(v7), v8 == CFDictionaryGetTypeID()))
        {
          result = CFDictionaryGetValue(v7, a2);
          if (result)
          {
            v9 = result;
            v10 = CFGetTypeID(result);
            if (v10 == CFStringGetTypeID())
              return v9;
            else
              return 0;
          }
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

CFTypeID CGImageMetadataGetTypeID(void)
{
  if (CGImageMetadataGetTypeID::once != -1)
    dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_20);
  return CGImageMetadataGetTypeID::id;
}

__CFString *CGImageMetadataNamespaceForDefaultPrefix(const __CFString *a1)
{
  __CFString **v2;
  __CFString *result;
  const __CFSet *Mutable;
  const char *v5;
  _BYTE v6[24];

  if (CFStringCompare(a1, CFSTR("exif"), 0) == kCFCompareEqualTo)
  {
    v2 = (__CFString **)&kCGImageMetadataNamespaceExif;
    goto LABEL_27;
  }
  if (CFStringCompare(a1, CFSTR("tiff"), 0) == kCFCompareEqualTo)
  {
    v2 = (__CFString **)&kCGImageMetadataNamespaceTIFF;
    goto LABEL_27;
  }
  if (CFStringCompare(a1, CFSTR("xmp"), 0) == kCFCompareEqualTo)
  {
    v2 = (__CFString **)&kCGImageMetadataNamespaceXMPBasic;
    goto LABEL_27;
  }
  if (CFStringCompare(a1, CFSTR("dc"), 0) == kCFCompareEqualTo)
  {
    v2 = (__CFString **)&kCGImageMetadataNamespaceDublinCore;
    goto LABEL_27;
  }
  if (CFStringCompare(a1, CFSTR("photoshop"), 0) == kCFCompareEqualTo)
  {
    v2 = (__CFString **)&kCGImageMetadataNamespacePhotoshop;
    goto LABEL_27;
  }
  if (CFStringCompare(a1, CFSTR("exifEX"), 0) == kCFCompareEqualTo)
  {
    v2 = (__CFString **)&kCGImageMetadataNamespaceExifEX;
    goto LABEL_27;
  }
  if (CFStringCompare(a1, CFSTR("Iptc4xmpCore"), 0) == kCFCompareEqualTo)
  {
    v2 = (__CFString **)&kCGImageMetadataNamespaceIPTCCore;
    goto LABEL_27;
  }
  if (CFStringCompare(a1, CFSTR("Iptc4xmpExt"), 0) == kCFCompareEqualTo)
  {
    v2 = (__CFString **)&kCGImageMetadataNamespaceIPTCExtension;
    goto LABEL_27;
  }
  if (CFStringCompare(a1, CFSTR("iio"), 0) == kCFCompareEqualTo)
  {
    v2 = kCGImageMetadataNamespaceImageIO;
    goto LABEL_27;
  }
  if (CFStringCompare(a1, CFSTR("mwg-rs"), 0) == kCFCompareEqualTo)
  {
    v2 = kCGImageMetadataNamespaceMWGRegions;
    goto LABEL_27;
  }
  if (CFStringCompare(a1, CFSTR("crs"), 0) == kCFCompareEqualTo)
  {
    v2 = kCGImageMetadataNamespaceCameraRawSettings;
    goto LABEL_27;
  }
  if (CFStringCompare(a1, CFSTR("aux"), 0) == kCFCompareEqualTo)
  {
    v2 = (__CFString **)&kCGImageMetadataNamespaceExifAux;
LABEL_27:
    result = *v2;
    if (*v2)
      return result;
    goto LABEL_28;
  }
  if (CFStringCompare(a1, CFSTR("xmpRights"), 0) == kCFCompareEqualTo)
  {
    v2 = (__CFString **)&kCGImageMetadataNamespaceXMPRights;
    goto LABEL_27;
  }
LABEL_28:
  Mutable = (const __CFSet *)CGImageMetadataNamespaceForDefaultPrefix::unknownPrefixSet;
  if (!CGImageMetadataNamespaceForDefaultPrefix::unknownPrefixSet)
  {
    Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 1, MEMORY[0x1E0C9B3B0]);
    CGImageMetadataNamespaceForDefaultPrefix::unknownPrefixSet = (uint64_t)Mutable;
  }
  if (!CFSetContainsValue(Mutable, a1))
  {
    IIOString::IIOString((IIOString *)v6, a1);
    v5 = (const char *)IIOString::utf8String((IIOString *)v6);
    _cg_jpeg_mem_term("CGImageMetadataNamespaceForDefaultPrefix", 2530, "*** unknown prefix '%s'\n", v5);
    IIOString::~IIOString((IIOString *)v6);
    CFSetAddValue((CFMutableSetRef)CGImageMetadataNamespaceForDefaultPrefix::unknownPrefixSet, a1);
  }
  return 0;
}

void sub_187E40FA4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

CFStringRef createPropertyPrefixFromCStrPrefix(char *cStr)
{
  const __CFAllocator *v1;
  const __CFString *v2;
  const __CFString *v3;
  CFStringRef v4;
  CFRange v6;

  if (!cStr)
    return 0;
  v1 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v2 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], cStr, 0x8000100u);
  if (!v2)
    return 0;
  v3 = v2;
  v6.length = CFStringGetLength(v2) - 1;
  v6.location = 0;
  v4 = CFStringCreateWithSubstring(v1, v3, v6);
  CFRelease(v3);
  return v4;
}

__CFString *CGImageMetadataDefaultPrefixForNamespace(const __CFString *a1)
{
  __CFString **v2;
  __CFString *result;
  const char *v4;
  _BYTE v5[24];

  if (CFStringCompare(a1, CFSTR("http://ns.adobe.com/exif/1.0/"), 0) == kCFCompareEqualTo)
  {
    v2 = (__CFString **)&kCGImageMetadataPrefixExif;
    goto LABEL_27;
  }
  if (CFStringCompare(a1, CFSTR("http://ns.adobe.com/tiff/1.0/"), 0) == kCFCompareEqualTo)
  {
    v2 = (__CFString **)&kCGImageMetadataPrefixTIFF;
    goto LABEL_27;
  }
  if (CFStringCompare(a1, CFSTR("http://ns.adobe.com/xap/1.0/"), 0) == kCFCompareEqualTo)
  {
    v2 = (__CFString **)&kCGImageMetadataPrefixXMPBasic;
    goto LABEL_27;
  }
  if (CFStringCompare(a1, CFSTR("http://purl.org/dc/elements/1.1/"), 0) == kCFCompareEqualTo)
  {
    v2 = (__CFString **)&kCGImageMetadataPrefixDublinCore;
    goto LABEL_27;
  }
  if (CFStringCompare(a1, CFSTR("http://ns.adobe.com/photoshop/1.0/"), 0) == kCFCompareEqualTo)
  {
    v2 = (__CFString **)&kCGImageMetadataPrefixPhotoshop;
    goto LABEL_27;
  }
  if (CFStringCompare(a1, CFSTR("http://cipa.jp/exif/1.0/"), 0) == kCFCompareEqualTo)
  {
    v2 = (__CFString **)&kCGImageMetadataPrefixExifEX;
    goto LABEL_27;
  }
  if (CFStringCompare(a1, CFSTR("http://iptc.org/std/Iptc4xmpCore/1.0/xmlns/"), 0) == kCFCompareEqualTo)
  {
    v2 = (__CFString **)&kCGImageMetadataPrefixIPTCCore;
    goto LABEL_27;
  }
  if (CFStringCompare(a1, CFSTR("http://iptc.org/std/Iptc4xmpExt/2008-02-29/"), 0) == kCFCompareEqualTo)
  {
    v2 = (__CFString **)&kCGImageMetadataPrefixIPTCExtension;
    goto LABEL_27;
  }
  if (CFStringCompare(a1, CFSTR("http://ns.apple.com/ImageIO/1.0/"), 0) == kCFCompareEqualTo)
  {
    v2 = xmpImageIOPrefix;
    goto LABEL_27;
  }
  if (CFStringCompare(a1, CFSTR("http://www.metadataworkinggroup.com/schemas/regions/"), 0) == kCFCompareEqualTo)
  {
    v2 = xmpMWGRegionsPrefix;
    goto LABEL_27;
  }
  if (CFStringCompare(a1, CFSTR("http://ns.adobe.com/camera-raw-settings/1.0/"), 0) == kCFCompareEqualTo)
  {
    v2 = xmpCRSPrefix;
    goto LABEL_27;
  }
  if (CFStringCompare(a1, CFSTR("http://ns.adobe.com/exif/1.0/aux/"), 0) == kCFCompareEqualTo)
  {
    v2 = (__CFString **)&kCGImageMetadataPrefixExifAux;
LABEL_27:
    result = *v2;
    if (*v2)
      return result;
    goto LABEL_28;
  }
  if (CFStringCompare(a1, CFSTR("http://ns.adobe.com/xap/1.0/rights/"), 0) == kCFCompareEqualTo)
  {
    v2 = (__CFString **)&kCGImageMetadataPrefixXMPRights;
    goto LABEL_27;
  }
LABEL_28:
  IIOString::IIOString((IIOString *)v5, a1);
  v4 = (const char *)IIOString::utf8String((IIOString *)v5);
  _cg_jpeg_mem_term("CGImageMetadataDefaultPrefixForNamespace", 2480, "*** unknown schema '%s'\n", v4);
  IIOString::~IIOString((IIOString *)v5);
  return 0;
}

void sub_187E41298(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void LogMetadata(const char *a1, int a2, const char *a3, ...)
{
  va_list va;

  va_start(va, a3);
  IIOInitDebugFlags();
  if ((gIIODebugFlags & 0x1000000) != 0)
    gImageIOLogProc(2, "ImageIO <Metadata>: ", a1, a2, a3, va);
}

CFTypeID CGImageMetadataTagGetTypeID(void)
{
  if (CGImageMetadataTagGetTypeID::once != -1)
    dispatch_once(&CGImageMetadataTagGetTypeID::once, &__block_literal_global_33);
  return CGImageMetadataTagGetTypeID::id;
}

uint64_t CGImageMetadataTagGetSource(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    v1 = *(_QWORD *)(result + 24);
    if (v1)
      return *(unsigned int *)(v1 + 68);
    else
      return 0;
  }
  return result;
}

BOOL CGImageIIMDigestsMatchOrMissing(uint64_t a1)
{
  const __CFString *v2;
  const __CFString *v3;
  BOOL v4;

  v2 = *(const __CFString **)(a1 + 56);
  v3 = *(const __CFString **)(a1 + 64);
  if (v2)
    v4 = v3 == 0;
  else
    v4 = 1;
  return v4 || CFStringCompare(v2, v3, 1uLL) == kCFCompareEqualTo;
}

uint64_t CGImageMetadataTagSetSource(uint64_t result, int a2)
{
  uint64_t v2;

  if (result)
  {
    v2 = *(_QWORD *)(result + 24);
    if (v2)
      *(_DWORD *)(v2 + 68) = a2;
  }
  return result;
}

void IIOMetadata_Tag::setPrefix(IIOMetadata_Tag *this, const __CFString *a2)
{
  const void *v2;

  v2 = (const void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2);
  if (v2)
    CFRelease(v2);
}

void CGImageMetadataTagSetPrefix(uint64_t a1, const __CFString *a2)
{
  IIOMetadata_Tag *v2;

  if (a1)
  {
    v2 = *(IIOMetadata_Tag **)(a1 + 24);
    if (v2)
      IIOMetadata_Tag::setPrefix(v2, a2);
  }
}

void CGImageMetadataTagSetNamespace(uint64_t a1, const __CFString *a2)
{
  IIOMetadata_Tag *v2;

  if (a1)
  {
    v2 = *(IIOMetadata_Tag **)(a1 + 24);
    if (v2)
      IIOMetadata_Tag::setNamespace(v2, a2);
  }
}

void IIOMetadata_Tag::setNamespace(IIOMetadata_Tag *this, const __CFString *a2)
{
  const void *v2;

  v2 = (const void *)*((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2);
  if (v2)
    CFRelease(v2);
}

void IIODictionary::appendDictionary(IIODictionary *this, const __CFDictionary *a2)
{
  __CFDictionary *v2;

  v2 = (__CFDictionary *)*((_QWORD *)this + 1);
  if (v2)
    IIODictionaryAppendDictionary(v2, a2, 1);
}

uint64_t appendNode(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  do
  {
    v2 = result;
    result = *(_QWORD *)(result + 40);
  }
  while (result);
  *(_QWORD *)(v2 + 40) = a2;
  return result;
}

uint64_t iioReadCallback(_BYTE *a1, int a2, IIOImageReadSession **a3)
{
  uint64_t result;

  if (!a2)
    return 0;
  LODWORD(result) = IIOImageReadSession::getBytes(*a3, a1, a2);
  if ((_DWORD)result)
    return result;
  else
    return 0xFFFFFFFFLL;
}

uint64_t png_handle_PLTE(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4;
  int v5;
  int v6;
  const char *v7;
  uint64_t result;
  int v10;
  int v11;
  _BYTE *v12;
  int v13;
  const char *v14;
  int v15;
  const char *v16;
  _WORD v17[2];
  _BYTE v18[768];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v4 = *(_DWORD *)(a1 + 76);
  if ((v4 & 1) == 0)
  {
    v16 = "missing IHDR";
    goto LABEL_35;
  }
  if ((v4 & 2) != 0)
  {
    v16 = "duplicate";
    goto LABEL_35;
  }
  v5 = a3;
  if ((v4 & 4) != 0)
  {
    png_crc_finish(a1, a3);
    v7 = "out of place";
    return png_chunk_benign_error(a1, v7);
  }
  *(_DWORD *)(a1 + 76) = v4 | 2;
  v6 = *(unsigned __int8 *)(a1 + 391);
  if ((v6 & 2) == 0)
  {
    png_crc_finish(a1, a3);
    v7 = "ignored in grayscale PNG";
    return png_chunk_benign_error(a1, v7);
  }
  if (a3 > 0x300 || a3 % 3)
  {
    png_crc_finish(a1, a3);
    if (*(_BYTE *)(a1 + 391) != 3)
    {
      v7 = "invalid";
      return png_chunk_benign_error(a1, v7);
    }
    v16 = "invalid";
LABEL_35:
    png_chunk_error((void (**)(void))a1, v16);
  }
  v10 = (unsigned __int16)a3 / 3u;
  if (v6 == 3)
    v11 = 1 << *(_BYTE *)(a1 + 392);
  else
    v11 = 256;
  bzero(v18, 0x300uLL);
  if (v11 < v10)
    v10 = v11;
  if (v10 >= 1)
  {
    v12 = v18;
    v13 = v10;
    do
    {
      memset(v17, 0, 3);
      png_crc_read(a1, (Bytef *)v17, 3u);
      *v12 = v17[0];
      *(_WORD *)(v12 + 1) = *(_WORD *)((char *)v17 + 1);
      v12 += 3;
      --v13;
    }
    while (v13);
  }
  png_crc_finish(a1, (-3 * v10 + v5));
  result = (uint64_t)_cg_png_set_PLTE((void (**)(void))a1, a2, v18, v10);
  if (*(_WORD *)(a1 + 384))
  {
    *(_WORD *)(a1 + 384) = 0;
    if (!a2)
    {
      v14 = "tRNS must be after";
      return png_chunk_benign_error(a1, v14);
    }
    goto LABEL_26;
  }
  if (!a2)
    return result;
  v15 = *(_DWORD *)(a2 + 8);
  if ((v15 & 0x10) != 0)
  {
    *(_WORD *)(a1 + 384) = 0;
LABEL_26:
    *(_WORD *)(a2 + 34) = 0;
    result = png_chunk_benign_error(a1, "tRNS must be after");
    v15 = *(_DWORD *)(a2 + 8);
  }
  if ((v15 & 0x40) != 0)
    result = png_chunk_benign_error(a1, "hIST must be after");
  if ((*(_BYTE *)(a2 + 8) & 0x20) != 0)
  {
    v14 = "bKGD must be after";
    return png_chunk_benign_error(a1, v14);
  }
  return result;
}

void png_handle_eXIf(uint64_t a1, uint64_t a2, size_t size)
{
  const char *v5;
  _QWORD *v7;
  uint64_t v8;
  Bytef v9;

  if ((*(_BYTE *)(a1 + 76) & 1) == 0)
    png_chunk_error((void (**)(void))a1, "missing IHDR");
  if (size <= 1)
  {
    png_crc_finish(a1, size);
    v5 = "too short";
LABEL_15:
    png_chunk_benign_error(a1, v5);
    return;
  }
  if (!a2 || (*(_BYTE *)(a2 + 10) & 1) != 0)
  {
    png_crc_finish(a1, size);
    v5 = "duplicate";
    goto LABEL_15;
  }
  *(_DWORD *)(a2 + 300) |= 0x8000u;
  v7 = png_malloc_warn((_QWORD *)a1, size);
  *(_QWORD *)(a2 + 248) = v7;
  if (!v7)
  {
    png_crc_finish(a1, size);
    v5 = "out of memory";
    goto LABEL_15;
  }
  v8 = 0;
  do
  {
    v9 = 0;
    png_crc_read(a1, &v9, 1u);
    *(_BYTE *)(*(_QWORD *)(a2 + 248) + v8) = v9;
    if (v8 == 1 && ((v9 & 0xFB) != 0x49 || **(unsigned __int8 **)(a2 + 248) != v9))
    {
      png_crc_finish(a1, (size - 2));
      png_chunk_benign_error(a1, "incorrect byte-order specifier");
      goto LABEL_18;
    }
    ++v8;
  }
  while (size != v8);
  if (!png_crc_finish(a1, 0))
    _cg_png_set_eXIf_1(a1, a2, size, *(const void **)(a2 + 248));
LABEL_18:
  png_free(a1, *(void **)(a2 + 248));
  *(_QWORD *)(a2 + 248) = 0;
}

uint64_t png_calculate_crc(uint64_t result, Bytef *buf, uint64_t a3)
{
  _BOOL4 v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;

  if ((*(_BYTE *)(result + 315) & 0x20) != 0)
    v3 = (~*(_DWORD *)(result + 80) & 0x300) != 0;
  else
    v3 = (*(_DWORD *)(result + 80) & 0x800) == 0;
  if (a3 && v3)
  {
    v4 = a3;
    v6 = result;
    result = *(unsigned int *)(result + 364);
    do
    {
      if ((_DWORD)v4)
        v7 = v4;
      else
        v7 = 0xFFFFFFFFLL;
      result = crc32(result, buf, v7);
      buf += v7;
      v4 -= v7;
    }
    while (v4);
    *(_DWORD *)(v6 + 364) = result;
  }
  return result;
}

uint64_t png_crc_read(uint64_t result, Bytef *a2, unsigned int a3)
{
  uint64_t v4;
  uint64_t v5;

  if (result)
  {
    if (a3)
    {
      v4 = result;
      v5 = a3;
      png_read_data(result);
      return png_calculate_crc(v4, a2, v5);
    }
  }
  return result;
}

uint64_t png_read_data(uint64_t a1)
{
  uint64_t (*v1)(void);

  v1 = *(uint64_t (**)(void))(a1 + 32);
  if (!v1)
    _cg_png_error((void (**)(void))a1, "Call to NULL read function");
  return v1();
}

unint64_t pngReadCallback(void (**a1)(void), _BYTE *a2, unint64_t a3)
{
  IIOImageReadSession *io_ptr;
  unint64_t result;

  io_ptr = (IIOImageReadSession *)_cg_png_get_io_ptr((uint64_t)a1);
  result = IIOImageReadSession::getBytes(io_ptr, a2, a3);
  if (result != a3)
    _cg_png_error(a1, "PNG read error");
  return result;
}

uint64_t _cg_png_get_io_ptr(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 40);
  return result;
}

unint64_t IIOImageReadSession::getBytes(IIOImageReadSession *this, _BYTE *a2, unint64_t a3)
{
  IIOImageRead *v4;
  unint64_t result;

  v4 = (IIOImageRead *)*((_QWORD *)this + 4);
  if (v4)
  {
    result = IIOImageRead::getBytesAtOffset(v4, a2, *((_QWORD *)this + 5), a3);
  }
  else
  {
    LogError("getBytes", 244, "*** ERROR: IIOImageReadSession::getBytes: _iRead is NULL\n");
    result = 0;
  }
  *((_QWORD *)this + 5) += result;
  return result;
}

unint64_t read_fn2(uint64_t a1, _BYTE *a2, unint64_t a3)
{
  uint64_t io_ptr;
  uint64_t v6;
  int64_t v7;
  IIOImageRead **v8;
  uint64_t v9;
  size_t v10;
  unint64_t result;

  io_ptr = _cg_png_get_io_ptr(a1);
  v6 = io_ptr;
  v8 = *(IIOImageRead ***)io_ptr;
  v7 = *(_QWORD *)(io_ptr + 8);
  v9 = *(_QWORD *)(io_ptr + 16);
  if (v7 > v9 - 0x8000)
  {
    if (v9)
      v10 = 0x20000;
    else
      v10 = 0x10000;
    IIOImageReadSession::willNeed(*(IIOImageRead ***)io_ptr, v9, v10);
    *(_QWORD *)(v6 + 16) = v10 + v9;
    v7 = *(_QWORD *)(v6 + 8);
  }
  result = IIOImageReadSession::getBytesAtOffset((IIOImageReadSession *)v8, a2, v7, a3);
  *(_QWORD *)(v6 + 8) += result;
  return result;
}

unint64_t IIOImageReadSession::getBytesAtOffset(IIOImageReadSession *this, _BYTE *a2, unint64_t a3, unint64_t a4)
{
  IIOImageRead *v4;

  v4 = (IIOImageRead *)*((_QWORD *)this + 4);
  if (v4)
    return IIOImageRead::getBytesAtOffset(v4, a2, a3, a4);
  LogError("getBytesAtOffset", 261, "*** ERROR: IIOImageReadSession::getBytesAtOffset: _iRead is NULL\n");
  return 0;
}

unint64_t read_fn(void (**a1)(void), _BYTE *a2, unint64_t a3)
{
  IIOImageReadSession *io_ptr;
  unint64_t result;

  io_ptr = (IIOImageReadSession *)_cg_png_get_io_ptr((uint64_t)a1);
  result = IIOImageReadSession::getBytes(io_ptr, a2, a3);
  if (result != a3)
    _cg_png_error(a1, "");
  return result;
}

BOOL IIOImageReadSession::willNeed(IIOImageRead **this, uint64_t a2, size_t a3)
{
  return IIOImageRead::willNeed(this[4], a2, a3);
}

BOOL IIOImageRead::willNeed(IIOImageRead *this, uint64_t a2, size_t a3)
{
  const __CFData *v3;
  pthread_mutex_t *v6;
  const UInt8 *BytePtr;
  const UInt8 *v8;
  unint64_t Length;
  _BOOL4 v10;
  size_t v12;
  _BOOL8 v13;

  v3 = (const __CFData *)*((_QWORD *)this + 4);
  if (!v3)
    return 0;
  v6 = (pthread_mutex_t *)((char *)this + 376);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 376));
  BytePtr = CFDataGetBytePtr(v3);
  if (BytePtr && (v8 = BytePtr, (Length = CFDataGetLength(v3)) != 0))
  {
    v10 = __CFADD__(a2, a3);
    if (a2 + a3 <= Length || v10)
      v12 = a3;
    else
      v12 = Length - a2;
    v13 = madvise((void *)&v8[a2], v12, 3) == 0;
  }
  else
  {
    v13 = 0;
  }
  pthread_mutex_unlock(v6);
  return v13;
}

void png_handle_sRGB(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4;
  const char *v5;
  int v7;
  Bytef v8;

  v4 = *(_DWORD *)(a1 + 76);
  if ((v4 & 1) == 0)
    png_chunk_error((void (**)(void))a1, "missing IHDR");
  if ((v4 & 6) != 0)
  {
    png_crc_finish(a1, a3);
    v5 = "out of place";
LABEL_8:
    png_chunk_benign_error(a1, v5);
    return;
  }
  if ((_DWORD)a3 != 1)
  {
    png_crc_finish(a1, a3);
    v5 = "invalid";
    goto LABEL_8;
  }
  v8 = 0;
  png_crc_read(a1, &v8, 1u);
  if (!png_crc_finish(a1, 0))
  {
    v7 = *(__int16 *)(a1 + 1074);
    if ((v7 & 0x80000000) == 0)
    {
      if ((v7 & 4) != 0)
      {
        *(_WORD *)(a1 + 1074) = v7 | 0x8000;
        png_colorspace_sync(a1, a2);
        png_chunk_benign_error(a1, "too many profiles");
      }
      else
      {
        png_colorspace_set_sRGB(a1, a1 + 1000, v8);
        png_colorspace_sync(a1, a2);
      }
    }
  }
}

void _cg_png_read_info(uLong a1, _DWORD *a2)
{
  uint64_t chunk_header;
  int i;
  int v6;
  int v7;
  int v8;
  int v9;
  const char *v10;

  if (!a1 || !a2)
    return;
  png_read_sig(a1, (uint64_t)a2);
  chunk_header = _cg_png_read_chunk_header(a1);
  for (i = *(_DWORD *)(a1 + 312); i != 1229209940; i = *(_DWORD *)(a1 + 312))
  {
    v8 = *(_DWORD *)(a1 + 76);
    if ((v8 & 4) != 0)
      *(_DWORD *)(a1 + 76) = v8 | 0x2008;
    if (i == 1229278788)
    {
      png_handle_IEND(a1, (uint64_t)a2, chunk_header);
    }
    else if (i == 1229472850)
    {
      png_handle_IHDR(a1, (uint64_t)a2, chunk_header);
    }
    else
    {
      v9 = png_chunk_unknown_handling(a1, i);
      if (v9)
      {
        png_handle_unknown(a1, (uint64_t)a2, chunk_header, v9);
        if (i == 1347179589)
          *(_DWORD *)(a1 + 76) |= 2u;
        goto LABEL_20;
      }
      if (i > 1866876530)
      {
        if (i <= 1934642259)
        {
          if (i <= 1883789682)
          {
            if (i == 1866876531)
            {
              png_handle_oFFs(a1, (uint64_t)a2, chunk_header);
            }
            else
            {
              if (i != 1883455820)
                goto LABEL_74;
              png_handle_pCAL(a1, (uint64_t)a2, chunk_header);
            }
          }
          else
          {
            switch(i)
            {
              case 1883789683:
                png_handle_pHYs(a1, (uint64_t)a2, chunk_header);
                break;
              case 1933723988:
                png_handle_sBIT(a1, (uint64_t)a2, chunk_header);
                break;
              case 1933787468:
                png_handle_sCAL(a1, (uint64_t)a2, chunk_header);
                break;
              default:
                goto LABEL_74;
            }
          }
        }
        else if (i > 1950960964)
        {
          switch(i)
          {
            case 1950960965:
              png_handle_tIME(a1, (uint64_t)a2, chunk_header);
              break;
            case 1951551059:
              png_handle_tRNS(a1, (uint64_t)a2, chunk_header);
              break;
            case 2052348020:
              png_handle_zTXt(a1, (uint64_t)a2, chunk_header);
              break;
            default:
              goto LABEL_74;
          }
        }
        else
        {
          switch(i)
          {
            case 1934642260:
              png_handle_sPLT(a1, (uint64_t)a2, chunk_header);
              break;
            case 1934772034:
              png_handle_sRGB(a1, (uint64_t)a2, chunk_header);
              break;
            case 1950701684:
              png_handle_tEXt(a1, (uint64_t)a2, chunk_header);
              break;
            default:
              goto LABEL_74;
          }
        }
      }
      else if (i <= 1717785675)
      {
        if (i <= 1649100611)
        {
          if (i == 1347179589)
          {
            png_handle_PLTE(a1, (uint64_t)a2, chunk_header);
          }
          else
          {
            if (i != 1633899596)
              goto LABEL_74;
            png_handle_acTL(a1, a2, chunk_header);
          }
        }
        else
        {
          switch(i)
          {
            case 1649100612:
              png_handle_bKGD(a1, (uint64_t)a2, chunk_header);
              break;
            case 1665684045:
              png_handle_cHRM(a1, (uint64_t)a2, chunk_header);
              break;
            case 1700284774:
              png_handle_eXIf(a1, (uint64_t)a2, chunk_header);
              break;
            default:
              goto LABEL_74;
          }
        }
      }
      else if (i > 1749635923)
      {
        switch(i)
        {
          case 1749635924:
            png_handle_hIST(a1, (uint64_t)a2, chunk_header);
            break;
          case 1766015824:
            if ((*(_BYTE *)(a1 + 84) & 4) != 0)
              png_crc_finish(a1, chunk_header);
            else
              png_handle_iCCP(a1, (uint64_t)a2);
            break;
          case 1767135348:
            png_handle_iTXt(a1, (uint64_t)a2, chunk_header);
            break;
          default:
LABEL_74:
            png_handle_unknown(a1, (uint64_t)a2, chunk_header, 0);
            break;
        }
      }
      else
      {
        switch(i)
        {
          case 1717785676:
            png_handle_fcTL(a1, a2, chunk_header);
            break;
          case 1717846356:
            png_handle_fdAT(a1, (uint64_t)a2, chunk_header);
            break;
          case 1732332865:
            png_handle_gAMA(a1, (uint64_t)a2, chunk_header);
            break;
          default:
            goto LABEL_74;
        }
      }
    }
LABEL_20:
    chunk_header = _cg_png_read_chunk_header(a1);
  }
  v6 = *(_DWORD *)(a1 + 76);
  if ((v6 & 1) == 0)
  {
    v10 = "Missing IHDR before IDAT";
    goto LABEL_81;
  }
  if ((v6 & 2) == 0 && *(_BYTE *)(a1 + 391) == 3)
  {
    v10 = "Missing PLTE before IDAT";
LABEL_81:
    png_chunk_error((void (**)(void))a1, v10);
  }
  if ((v6 & 8) != 0)
  {
    png_chunk_benign_error(a1, "Too many IDATs found");
    v6 = *(_DWORD *)(a1 + 76);
  }
  *(_DWORD *)(a1 + 76) = v6 | 4;
  v7 = png_chunk_unknown_handling(a1, 1229209940);
  if (v7)
  {
    png_handle_unknown(a1, (uint64_t)a2, chunk_header, v7);
    LODWORD(chunk_header) = 0;
  }
  else
  {
    png_have_info(a1, (uint64_t)a2);
  }
  *(_DWORD *)(a1 + 360) = chunk_header;
}

uint64_t _cg_png_read_chunk_header(uLong a1)
{
  uint64_t v2;
  _QWORD v4[2];

  v4[1] = *MEMORY[0x1E0C80C00];
  v4[0] = 0;
  *(_DWORD *)(a1 + 956) = 33;
  png_read_data(a1);
  v2 = bswap32(LOBYTE(v4[0]));
  if ((v2 & 0x80000000) != 0)
    _cg_png_error((void (**)(void))a1, "PNG unsigned integer out of range");
  *(_DWORD *)(a1 + 312) = bswap32(HIDWORD(v4[0]));
  png_reset_crc(a1);
  png_calculate_crc(a1, (Bytef *)v4 + 4, 4);
  png_check_chunk_name((void (**)(void))a1, *(_DWORD *)(a1 + 312));
  png_check_chunk_length(a1, v2);
  *(_DWORD *)(a1 + 956) = 65;
  return v2;
}

uLong png_reset_crc(uLong result)
{
  uLong v2;

  if ((~*(_DWORD *)(result + 80) & 0x300) != 0 && (*(_DWORD *)(result + 80) & 0x800) == 0)
  {
    v2 = result;
    result = crc32(0, 0, 0);
    *(_DWORD *)(v2 + 364) = result;
  }
  return result;
}

void (**png_check_chunk_name(void (**result)(void), unsigned int a2))(void)
{
  int v2;

  v2 = 4;
  do
  {
    if (a2 - 123 < 0xFFFFFFC6 || a2 - 91 <= 5)
      png_chunk_error(result, "invalid chunk type");
    a2 >>= 8;
    --v2;
  }
  while (v2);
  return result;
}

uint64_t png_check_chunk_length(uint64_t result, unsigned int a2)
{
  unint64_t v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;

  v2 = *(_QWORD *)(result + 888);
  if (v2 - 1 >= 0x7FFFFFFE)
    v2 = 0x7FFFFFFFLL;
  if (*(_DWORD *)(result + 312) == 1229209940)
  {
    v3 = 6;
    if (!*(_BYTE *)(result + 388))
      v3 = 0;
    v4 = ((*(unsigned __int8 *)(result + 395) * (unint64_t)*(unsigned int *)(result + 280)) << (*(unsigned __int8 *)(result + 392) > 8u))
       + v3;
    v5 = *(unsigned int *)(result + 284);
    if (0xFFFFFFFF / (v4 + 1) >= v5)
      v6 = (v4 + 1) * v5;
    else
      v6 = 0x7FFFFFFFLL;
    if (v4 + 1 < 0x7F36)
      v7 = v4 + 1;
    else
      v7 = 32566;
    v8 = 5 * (v6 / v7) + v6 + 11;
    if (v8 >= 0x7FFFFFFF)
      v8 = 0x7FFFFFFFLL;
    if (v2 <= v8)
      v2 = v8;
  }
  if (v2 < a2)
    return png_benign_error(result, "chunk data is too large");
  return result;
}

uint64_t png_chunk_unknown_handling(uint64_t a1, int a2)
{
  int v3;
  char v4;

  LOBYTE(v3) = HIBYTE(a2);
  BYTE1(v3) = BYTE2(a2);
  BYTE2(v3) = BYTE1(a2);
  HIBYTE(v3) = a2;
  v4 = 0;
  return png_handle_as_unknown(a1, &v3);
}

uint64_t png_handle_as_unknown(uint64_t a1, _DWORD *a2)
{
  uint64_t result;
  int v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  int v8;

  result = 0;
  if (a1 && a2)
  {
    v4 = *(_DWORD *)(a1 + 740);
    if (v4)
    {
      v5 = *(_QWORD *)(a1 + 744);
      v6 = v5 + (5 * v4);
      v7 = v6;
      while (1)
      {
        v8 = *(_DWORD *)(v7 - 5);
        v7 -= 5;
        if (*a2 == v8)
          break;
        v6 = v7;
        if (v7 <= v5)
          return 0;
      }
      return *(unsigned __int8 *)(v6 - 1);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t png_read_sig(uint64_t result, uint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  const char *v5;

  v2 = *(unsigned __int8 *)(result + 397);
  if (v2 <= 7)
  {
    v3 = result;
    *(_DWORD *)(result + 956) = 17;
    v4 = a2 + 44;
    png_read_data(result);
    *(_BYTE *)(v3 + 397) = 8;
    result = png_sig_cmp(v4, v2, 8 - v2);
    if ((_DWORD)result)
    {
      if (v2 <= 3 && png_sig_cmp(v4, v2, 4 - v2))
        v5 = "Not a PNG file";
      else
        v5 = "PNG file corrupted by ASCII conversion";
      _cg_png_error((void (**)(void))v3, v5);
    }
    if (v2 <= 2)
      *(_DWORD *)(v3 + 76) |= 0x1000u;
  }
  return result;
}

uint64_t png_have_info(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)(a2 + 8) & 0x60000) == 0x20000)
  {
    *(_DWORD *)(result + 768) |= 1u;
    ++*(_DWORD *)(a2 + 360);
  }
  return result;
}

uint64_t png_sig_cmp(uint64_t a1, unint64_t a2, size_t a3)
{
  if (a3 <= 8)
  {
    if (!a3)
      return 0xFFFFFFFFLL;
  }
  else
  {
    a3 = 8;
  }
  if (a2 > 7)
    return 0xFFFFFFFFLL;
  if (a3 + a2 > 8)
    a3 = 8 - a2;
  return memcmp((const void *)(a1 + a2), (char *)&png_sig_cmp_png_signature + a2, a3);
}

uint64_t png_handle_IHDR(uint64_t a1, uint64_t a2, int a3)
{
  int v4;
  unsigned int v6;
  unsigned int v7;
  unsigned __int8 v8;
  unint64_t v9;
  unsigned __int8 v10;
  unsigned __int8 v11;
  unsigned __int8 v12;
  unint64_t v13;
  unsigned __int8 v14;
  BOOL v15;
  unint64_t v16;
  unint64_t v17;
  const char *v19;
  _QWORD v20[3];

  v20[2] = *MEMORY[0x1E0C80C00];
  v4 = *(_DWORD *)(a1 + 76);
  if ((v4 & 1) != 0)
  {
    v19 = "out of place";
    goto LABEL_13;
  }
  if (a3 != 13)
  {
    v19 = "invalid";
LABEL_13:
    png_chunk_error((void (**)(void))a1, v19);
  }
  *(_QWORD *)((char *)v20 + 5) = 0;
  v20[0] = 0;
  *(_DWORD *)(a1 + 76) = v4 | 1;
  png_crc_read(a1, (Bytef *)v20, 0xDu);
  png_crc_finish(a1, 0);
  v6 = bswap32(v20[0]);
  if ((v6 & 0x80000000) != 0 || (v7 = bswap32(HIDWORD(v20[0])), (v7 & 0x80000000) != 0))
    _cg_png_error((void (**)(void))a1, "PNG unsigned integer out of range");
  v8 = v20[1];
  v9 = BYTE1(v20[1]);
  v10 = BYTE2(v20[1]);
  v11 = BYTE3(v20[1]);
  v12 = BYTE4(v20[1]);
  *(_DWORD *)(a1 + 776) = v6;
  *(_DWORD *)(a1 + 780) = v7;
  *(_DWORD *)(a1 + 280) = v6;
  *(_DWORD *)(a1 + 284) = v7;
  *(_BYTE *)(a1 + 392) = v8;
  *(_BYTE *)(a1 + 388) = v12;
  *(_BYTE *)(a1 + 391) = v9;
  *(_BYTE *)(a1 + 764) = v11;
  *(_BYTE *)(a1 + 872) = v10;
  v13 = 0x4010201030101uLL >> (8 * v9);
  if (v9 >= 7)
    LOBYTE(v13) = 1;
  *(_BYTE *)(a1 + 395) = v13;
  v14 = v13 * v8;
  *(_BYTE *)(a1 + 394) = v14;
  v15 = v14 >= 8u;
  v16 = (v14 * (unint64_t)v6 + 7) >> 3;
  v17 = v6 * (unint64_t)(v14 >> 3);
  if (!v15)
    v17 = v16;
  *(_QWORD *)(a1 + 296) = v17;
  return _cg_png_set_IHDR(a1, a2, v6, v7, v8, v9, v12, v10, v11);
}

BOOL png_crc_finish(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  _BOOL8 result;
  int v7;
  Bytef v8[4096];
  uint64_t v9;

  v3 = MEMORY[0x1E0C80A78](a1, a2);
  v9 = *MEMORY[0x1E0C80C00];
  if (v2)
  {
    v4 = v2;
    do
    {
      bzero(v8, 0x1000uLL);
      if (v4 >= 0x1000)
        v5 = 4096;
      else
        v5 = v4;
      v4 -= v5;
      png_crc_read(v3, v8, v5);
    }
    while (v4);
  }
  result = png_crc_error((_DWORD *)v3);
  if (result)
  {
    v7 = *(_DWORD *)(v3 + 80);
    if ((*(_BYTE *)(v3 + 315) & 0x20) != 0)
    {
      if ((v7 & 0x200) == 0)
        goto LABEL_10;
    }
    else if ((v7 & 0x400) != 0)
    {
LABEL_10:
      png_chunk_warning(v3, "CRC error");
      return 1;
    }
    png_chunk_error((void (**)(void))v3, "CRC error");
  }
  return result;
}

BOOL png_crc_error(_DWORD *a1)
{
  int v2;
  int v3;

  v2 = a1[78];
  v3 = a1[20];
  a1[239] = 129;
  png_read_data((uint64_t)a1);
  if ((v2 & 0x20000000) != 0)
  {
    if ((~v3 & 0x300) == 0)
      return 0;
  }
  else if ((v3 & 0x800) != 0)
  {
    return 0;
  }
  return bswap32(0) != a1[91];
}

uint64_t _cg_png_set_IHDR(uint64_t result, uint64_t a2, unsigned int a3, unsigned int a4, unsigned __int8 a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, unsigned __int8 a9)
{
  int v11;
  char v12;
  unsigned __int8 v13;
  BOOL v14;
  unint64_t v15;
  unint64_t v16;

  if (!result || !a2)
    return result;
  *(_DWORD *)a2 = a3;
  *(_DWORD *)(a2 + 4) = a4;
  *(_BYTE *)(a2 + 36) = a5;
  *(_BYTE *)(a2 + 37) = a6;
  *(_BYTE *)(a2 + 38) = a8;
  *(_BYTE *)(a2 + 39) = a9;
  *(_BYTE *)(a2 + 40) = a7;
  result = png_check_IHDR(result, a3, a4, a5, a6, a7, a8, a9);
  v11 = *(unsigned __int8 *)(a2 + 37);
  if (v11 == 3)
  {
    v12 = 1;
LABEL_7:
    *(_BYTE *)(a2 + 41) = v12;
    goto LABEL_8;
  }
  v12 = v11 & 2 | 1;
  *(_BYTE *)(a2 + 41) = v12;
  if ((v11 & 4) != 0)
  {
    v12 = (v11 & 2) + 2;
    goto LABEL_7;
  }
LABEL_8:
  v13 = *(_BYTE *)(a2 + 36) * v12;
  *(_BYTE *)(a2 + 42) = v13;
  v14 = v13 >= 8u;
  v15 = (v13 * (unint64_t)a3 + 7) >> 3;
  v16 = a3 * (unint64_t)(v13 >> 3);
  if (!v14)
    v16 = v15;
  *(_QWORD *)(a2 + 16) = v16;
  *(_DWORD *)(a2 + 360) = 1;
  return result;
}

uint64_t png_check_IHDR(uint64_t result, unsigned int a2, unsigned int a3, int a4, unsigned int a5, int a6, int a7, int a8)
{
  uint64_t v15;
  int v16;
  char *v17;
  char *v18;
  unsigned int v19;
  BOOL v20;
  int v21;

  v15 = result;
  if (a2)
  {
    if ((a2 & 0x80000000) == 0)
    {
      v16 = 0;
      goto LABEL_7;
    }
    v17 = "Invalid image width in IHDR";
  }
  else
  {
    v17 = "Image width is zero in IHDR";
  }
  result = png_warning(result, v17);
  v16 = 1;
LABEL_7:
  if (*(_DWORD *)(v15 + 876) < a2)
  {
    result = png_warning(v15, "Image width exceeds user limit in IHDR");
    v16 = 1;
  }
  if (a3)
  {
    if ((a3 & 0x80000000) == 0)
      goto LABEL_14;
    v18 = "Invalid image height in IHDR";
  }
  else
  {
    v18 = "Image height is zero in IHDR";
  }
  result = png_warning(v15, v18);
  v16 = 1;
LABEL_14:
  if (*(_DWORD *)(v15 + 880) < a3)
  {
    result = png_warning(v15, "Image height exceeds user limit in IHDR");
    v16 = 1;
  }
  if (a4 > 0x10 || ((1 << a4) & 0x10116) == 0)
  {
    result = png_warning(v15, "Invalid bit depth in IHDR");
    v16 = 1;
  }
  v19 = a5 & 0xFFFFFFFB;
  if (a5 > 6 || v19 == 1)
  {
    result = png_warning(v15, "Invalid color type in IHDR");
    v16 = 1;
  }
  if (a4 > 8 && a5 == 3 || (a5 != 4 ? (v20 = v19 == 2) : (v20 = 1), !v20 ? (v21 = 0) : (v21 = 1), a4 < 8 && v21))
  {
    result = png_warning(v15, "Invalid color type/bit depth combination in IHDR");
    v16 = 1;
  }
  if (a6 >= 2)
  {
    result = png_warning(v15, "Unknown interlace method in IHDR");
    v16 = 1;
  }
  if (a7)
  {
    result = png_warning(v15, "Unknown compression method in IHDR");
    v16 = 1;
  }
  if ((*(_BYTE *)(v15 + 77) & 0x10) != 0 && *(_DWORD *)(v15 + 760))
    result = png_warning(v15, "MNG features are not allowed in a PNG datastream");
  if (a8 && (a8 != 64 || (*(_DWORD *)(v15 + 760) & 4) == 0 || v19 != 2 || (*(_DWORD *)(v15 + 76) & 0x1000) != 0))
  {
    png_warning(v15, "Unknown filter method in IHDR");
    if ((*(_BYTE *)(v15 + 77) & 0x10) != 0)
      png_warning(v15, "Invalid filter method in IHDR");
LABEL_49:
    _cg_png_error((void (**)(void))v15, "Invalid IHDR data");
  }
  if (v16)
    goto LABEL_49;
  return result;
}

void png_handle_unknown(uint64_t a1, uint64_t a2, uint64_t size, int a4)
{
  int v4;
  int v7;
  int v8;
  int v9;
  void *v10;
  const char *v11;

  v4 = a4;
  if (*(_QWORD *)(a1 + 728))
  {
    if (!png_cache_unknown_chunk(a1, size))
      goto LABEL_22;
    v7 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 728))(a1, a1 + 896);
    if (v7 < 0)
    {
      v11 = "error in user chunk";
LABEL_33:
      png_chunk_error((void (**)(void))a1, v11);
    }
    if (v7)
      goto LABEL_25;
    if (v4 <= 1)
    {
      if (*(int *)(a1 + 736) <= 1)
      {
        png_chunk_warning(a1, "Saving unknown chunk:");
        png_app_warning(a1, "forcing save of an unhandled chunk; please call png_set_keep_unknown_chunks");
      }
      goto LABEL_17;
    }
  }
  else
  {
    if (!a4)
      v4 = *(_DWORD *)(a1 + 736);
    if (v4 == 3 || v4 == 2 && (*(_BYTE *)(a1 + 315) & 0x20) != 0)
    {
      if (!png_cache_unknown_chunk(a1, size))
        goto LABEL_22;
    }
    else
    {
      png_crc_finish(a1, size);
    }
  }
  if (v4 == 3)
    goto LABEL_18;
  if (v4 != 2)
    goto LABEL_22;
LABEL_17:
  if ((*(_BYTE *)(a1 + 315) & 0x20) == 0)
    goto LABEL_22;
LABEL_18:
  v8 = *(_DWORD *)(a1 + 884);
  if (v8)
  {
    if (v8 != 1)
    {
      if (v8 == 2)
      {
        v9 = 1;
        *(_DWORD *)(a1 + 884) = 1;
        png_chunk_benign_error(a1, "no space in chunk cache");
        goto LABEL_26;
      }
      *(_DWORD *)(a1 + 884) = v8 - 1;
      goto LABEL_24;
    }
LABEL_22:
    v9 = 1;
    goto LABEL_26;
  }
LABEL_24:
  _cg_png_set_unknown_chunks((void (**)(void))a1, a2, a1 + 896, 1);
LABEL_25:
  v9 = 0;
LABEL_26:
  v10 = *(void **)(a1 + 904);
  if (v10)
    png_free(a1, v10);
  *(_QWORD *)(a1 + 904) = 0;
  *(_QWORD *)(a1 + 912) = 0;
  if (v9 && (*(_BYTE *)(a1 + 315) & 0x20) == 0)
  {
    v11 = "unhandled critical chunk";
    goto LABEL_33;
  }
}

uint64_t png_cache_unknown_chunk(uint64_t a1, uint64_t size)
{
  _QWORD *v4;
  void *v5;
  unint64_t v6;
  Bytef *v7;
  int v8;

  v4 = (_QWORD *)(a1 + 904);
  v5 = *(void **)(a1 + 904);
  if (v5)
  {
    png_free(a1, v5);
    *v4 = 0;
    v4[1] = 0;
  }
  v6 = *(_QWORD *)(a1 + 888);
  if (v6 + 1 > 1 && v6 < size)
  {
    v7 = 0;
    if (!(_DWORD)size)
    {
LABEL_11:
      if ((_DWORD)size)
        png_crc_read(a1, v7, size);
      goto LABEL_14;
    }
LABEL_9:
    if (!v7)
    {
      png_crc_finish(a1, size);
      png_chunk_benign_error(a1, "unknown chunk exceeds memory limits");
      return 0;
    }
    goto LABEL_11;
  }
  v8 = *(_DWORD *)(a1 + 312);
  *(_BYTE *)(a1 + 896) = HIBYTE(v8);
  *(_BYTE *)(a1 + 897) = BYTE2(v8);
  *(_BYTE *)(a1 + 898) = BYTE1(v8);
  *(_BYTE *)(a1 + 899) = v8;
  *(_BYTE *)(a1 + 900) = 0;
  *(_BYTE *)(a1 + 920) = *(_DWORD *)(a1 + 76);
  if ((_DWORD)size)
  {
    v7 = (Bytef *)png_malloc_warn((_QWORD *)a1, size);
    *(_QWORD *)(a1 + 904) = v7;
    *(_QWORD *)(a1 + 912) = size;
    goto LABEL_9;
  }
  *v4 = 0;
  v4[1] = 0;
LABEL_14:
  png_crc_finish(a1, 0);
  return 1;
}

_QWORD *png_create_read_struct_2(_BYTE *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  _QWORD *png_struct;
  _QWORD *v8;
  int v9;

  png_struct = png_create_png_struct(a1, a2, a3, a4, a5, a6, a7);
  v8 = png_struct;
  if (png_struct)
  {
    *((_DWORD *)png_struct + 238) = 0x4000;
    v9 = *((_DWORD *)png_struct + 20) | 0x300000;
    *((_DWORD *)png_struct + 19) = 0x8000;
    *((_DWORD *)png_struct + 20) = v9;
    _cg_png_set_read_fn(png_struct, 0, 0);
  }
  return v8;
}

_QWORD *_cg_png_set_read_fn(_QWORD *result, uint64_t a2, size_t (*a3)(size_t result, void *__ptr, size_t a3))
{
  _QWORD *v3;
  size_t (*v4)(size_t, void *, size_t);

  if (result)
  {
    v3 = result;
    v4 = png_default_read_data;
    if (a3)
      v4 = a3;
    result[4] = v4;
    result[5] = a2;
    if (result[3])
    {
      result[3] = 0;
      result = (_QWORD *)png_warning((uint64_t)result, "Can't set both read_data_fn and write_data_fn in the same structure");
    }
    v3[54] = 0;
  }
  return result;
}

_QWORD *png_create_png_struct(_BYTE *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  _QWORD *v14;
  _QWORD *v15;
  _QWORD v17[136];

  v17[135] = *MEMORY[0x1E0C80C00];
  bzero(v17, 0x438uLL);
  HIDWORD(v17[109]) = 1000000;
  v17[110] = 0x3E8000F4240;
  v17[111] = 8000000;
  png_set_mem_fn(v17, a5, a6, a7);
  png_set_error_fn(v17, a2, a3, a4);
  if (!png_user_version_check((uint64_t)v17, a1))
    return 0;
  v14 = png_malloc_warn(v17, 0x438uLL);
  v15 = v14;
  if (v14)
  {
    v17[20] = png_zalloc;
    v17[21] = png_zfree;
    v17[22] = v14;
    memcpy(v14, v17, 0x438uLL);
  }
  return v15;
}

_QWORD *png_malloc_warn(_QWORD *result, size_t size)
{
  uint64_t v2;
  uint64_t (*v3)(_QWORD *);

  if (result)
  {
    v2 = (uint64_t)result;
    if (!size)
      goto LABEL_5;
    v3 = (uint64_t (*)(_QWORD *))result[103];
    if (v3)
    {
      result = (_QWORD *)v3(result);
      if (result)
        return result;
      goto LABEL_5;
    }
    result = malloc_type_malloc(size, 0xB622AF59uLL);
    if (!result)
    {
LABEL_5:
      png_warning(v2, "Out of memory");
      return 0;
    }
  }
  return result;
}

_QWORD *png_set_mem_fn(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (result)
  {
    result[102] = a2;
    result[103] = a3;
    result[104] = a4;
  }
  return result;
}

uint64_t png_user_version_check(uint64_t a1, _BYTE *a2)
{
  uint64_t v4;
  unsigned int v5;
  int v6;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  _OWORD v13[8];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v4 = 0;
    v5 = 0;
    do
    {
      v6 = a2[v4];
      if (v6 != a1643[v4])
        *(_DWORD *)(a1 + 80) |= 0x20000u;
      if (v6 == 46)
        ++v5;
    }
    while (v5 <= 1 && v4++ != 6 && v6 != 0);
    if ((*(_BYTE *)(a1 + 82) & 2) == 0)
      return 1;
  }
  else
  {
    *(_DWORD *)(a1 + 80) |= 0x20000u;
  }
  memset(v13, 0, sizeof(v13));
  v10 = png_safecat((uint64_t)v13, 0x80uLL, 0, "Application built with libpng-");
  v11 = png_safecat((uint64_t)v13, 0x80uLL, v10, a2);
  v12 = png_safecat((uint64_t)v13, 0x80uLL, v11, " but running with ");
  png_safecat((uint64_t)v13, 0x80uLL, v12, "1.6.43");
  png_warning(a1, v13);
  return 0;
}

_QWORD *png_set_error_fn(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (result)
  {
    result[1] = a4;
    result[2] = a2;
    *result = a3;
  }
  return result;
}

void png_colorspace_sync_info(uint64_t a1, uint64_t a2)
{
  int v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;

  v2 = *(_DWORD *)(a2 + 8);
  if (*(__int16 *)(a2 + 126) < 0)
  {
    *(_DWORD *)(a2 + 8) = v2 & 0xFFFFE7FA;
    png_free_data(a1, a2, 0x10u, -1);
  }
  else
  {
    v3 = *(unsigned __int16 *)(a2 + 126);
    v4 = v2 & 0xFFFFF7FB | (((v3 >> 7) & 1) << 11) | (4 * ((v3 >> 1) & 1));
    if ((v3 & 1) != 0)
      v5 = v4 | 1;
    else
      v5 = v4 & 0xFFFFFFFE;
    *(_DWORD *)(a2 + 8) = v5;
  }
}

void png_colorspace_sync(uint64_t a1, uint64_t a2)
{
  __int128 v2;
  __int128 v3;

  if (a2)
  {
    v2 = *(_OWORD *)(a1 + 1000);
    *(_OWORD *)(a2 + 68) = *(_OWORD *)(a1 + 1016);
    v3 = *(_OWORD *)(a1 + 1048);
    *(_OWORD *)(a2 + 84) = *(_OWORD *)(a1 + 1032);
    *(_OWORD *)(a2 + 100) = v3;
    *(_OWORD *)(a2 + 112) = *(_OWORD *)(a1 + 1060);
    *(_OWORD *)(a2 + 52) = v2;
    png_colorspace_sync_info(a1, a2);
  }
}

uint64_t PNGReadPlugin::Read_user_chunk_callback(void (**a1)(void), uint64_t a2)
{
  uint64_t user_chunk_ptr;
  uint64_t v5;
  uint64_t v6;
  uint64_t i;

  user_chunk_ptr = _cg_png_get_user_chunk_ptr((uint64_t)a1);
  switch(*(_DWORD *)a2)
  {
    case 0x49426743:
      return PNGReadPlugin::Read_user_chunkCgBI(user_chunk_ptr, a1, a2);
    case 0x544F4469:
      PNGReadPlugin::Read_user_chunkIDOT(user_chunk_ptr, (uint64_t)a1, a2);
      return 1;
    case 0x44507061:
      PNGReadPlugin::Read_user_chunkapPD(user_chunk_ptr, v5, a2);
      return 1;
    case 0x50434963:
      if (!*(_BYTE *)(user_chunk_ptr + 25))
      {
        if (*(_QWORD *)(a2 + 16) == 4)
        {
          for (i = 0; i != 4; ++i)
            *(_BYTE *)(user_chunk_ptr + 21 + i) = *(_BYTE *)(*(_QWORD *)(a2 + 8) + i);
          v6 = 1;
          *(_BYTE *)(user_chunk_ptr + 25) = 1;
          return v6;
        }
        return 0;
      }
      return 1;
  }
  return 0;
}

uint64_t _cg_png_get_user_chunk_ptr(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 720);
  return result;
}

uint64_t PNGReadPlugin::Read_user_chunk_callback2(void (**a1)(void), _DWORD *a2)
{
  uint64_t user_chunk_ptr;

  user_chunk_ptr = _cg_png_get_user_chunk_ptr((uint64_t)a1);
  if (*a2 == 1229088579)
    return PNGReadPlugin::Read_user_chunkCgBI(user_chunk_ptr, a1, (uint64_t)a2);
  else
    return 0;
}

uint64_t PNGReadPlugin::Read_user_chunkCgBI(uint64_t a1, void (**a2)(void), uint64_t a3)
{
  uint64_t result;
  unsigned __int8 *v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int appleflags;
  int v14;

  if (*(_BYTE *)(a1 + 36))
  {
    *(_BYTE *)(a1 + 35) = 0;
    *(_DWORD *)(a1 + 40) = 0;
    return 1;
  }
  else if (*(_QWORD *)(a3 + 16) == 4)
  {
    v6 = *(unsigned __int8 **)(a3 + 8);
    v7 = *v6 >> 4;
    v8 = v6[3] & 0x1F;
    if (*(_BYTE *)(a1 + 72) == 1)
      v9 = 4;
    else
      v9 = 2;
    if (v8 == 6)
      v10 = 6;
    else
      v10 = v9;
    v11 = v10 & 0xFFFFFFF | (v7 << 28) | 0x2000;
    if (v11 == 268443650)
      v12 = 805314562;
    else
      v12 = v10 & 0xFFFFFFF | (v7 << 28) | 0x2000;
    *(_DWORD *)(a1 + 40) = v12;
    if ((v11 & 0x10000000) != 0)
    {
      if (*(_QWORD *)(_cg_png_get_zstream((uint64_t)a2) + 56))
        _cg_png_error(a2, "Too late to change zlib mode.");
      appleflags = _cg_png_get_appleflags((uint64_t)a2);
      _cg_png_set_appleflags((uint64_t)a2, appleflags | 1);
    }
    if ((v11 & 0x20000000) != 0)
    {
      v14 = _cg_png_get_appleflags((uint64_t)a2);
      _cg_png_set_appleflags((uint64_t)a2, v14 | 2);
    }
    result = 1;
    *(_BYTE *)(a1 + 35) = 1;
  }
  else
  {
    _cg_jpeg_mem_term("Read_user_chunkCgBI", 719, "*** ERROR: PNG ERROR: CgBI chunk encountered with incorrect length (%d)\n", *(_QWORD *)(a3 + 16));
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t _cg_png_set_appleflags(uint64_t result, int a2)
{
  *(_DWORD *)(result + 84) = a2;
  return result;
}

uint64_t _cg_png_get_appleflags(uint64_t a1)
{
  return *(unsigned int *)(a1 + 84);
}

uint64_t _cg_png_get_zstream(uint64_t a1)
{
  return a1 + 96;
}

uint64_t png_colorspace_set_sRGB(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int v3;
  __int16 v4;
  unint64_t v7;
  char *v8;
  __int16 v9;

  v3 = *(__int16 *)(a2 + 74);
  if (v3 < 0)
    return 0;
  v4 = a3;
  if (a3 >= 4)
  {
    v7 = (int)a3;
    v8 = "invalid sRGB rendering intent";
LABEL_13:
    png_icc_profile_error(a1, a2, "sRGB", v7, v8);
    return 0;
  }
  if ((v3 & 4) != 0 && *(unsigned __int16 *)(a2 + 72) != a3)
  {
    v7 = a3;
    v8 = "inconsistent rendering intents";
    goto LABEL_13;
  }
  if ((v3 & 0x20) != 0)
  {
    png_benign_error(a1, "duplicate sRGB information ignored");
    return 0;
  }
  if ((v3 & 2) != 0 && !png_colorspace_endpoints_match((int *)&sRGB_xy, (_DWORD *)(a2 + 4), 100))
    png_chunk_report(a1, "cHRM chunk does not match sRGB", 2);
  png_colorspace_check_gamma(a1, a2, 45455, 2);
  *(_OWORD *)(a2 + 4) = sRGB_xy;
  *(_OWORD *)(a2 + 20) = unk_18822AAB4;
  *(_OWORD *)(a2 + 36) = png_colorspace_set_sRGB_sRGB_XYZ;
  *(_WORD *)(a2 + 72) = v4;
  v9 = *(_WORD *)(a2 + 74);
  *(_DWORD *)(a2 + 68) = 95053;
  *(_OWORD *)(a2 + 52) = unk_18822AA90;
  *(_DWORD *)a2 = 45455;
  *(_WORD *)(a2 + 74) = v9 | 0xE7;
  return 1;
}

uint64_t png_colorspace_check_gamma(uint64_t a1, uint64_t a2, int a3, int a4)
{
  __int16 v4;
  double v5;
  BOOL v6;
  BOOL v7;
  _BOOL8 v8;

  v4 = *(_WORD *)(a2 + 74);
  if ((v4 & 1) != 0)
  {
    if (!a3
      || !*(_DWORD *)a2
      || ((v5 = floor((double)*(int *)a2 * 100000.0 / (double)a3 + 0.5), v5 <= 2147483650.0)
        ? (v6 = v5 < -2147483650.0)
        : (v6 = 1),
          !v6 ? (v7 = ((int)v5 - 95000) >= 0x2711) : (v7 = 1),
          v7))
    {
      if (a4 == 2 || (v4 & 0x20) != 0)
      {
        v8 = a4 == 2;
        png_chunk_report(a1, "gamma value does not match sRGB", 2);
        return v8;
      }
      png_chunk_report(a1, "gamma value does not match libpng estimate", 0);
    }
  }
  return 1;
}

void _cg_png_set_eXIf_1(uint64_t a1, uint64_t a2, size_t size, const void *a4)
{
  int v7;
  size_t v8;
  _QWORD *v9;
  _QWORD *v10;

  if (a1 && a2 && (*(_BYTE *)(a1 + 77) & 0x40) == 0)
  {
    v7 = size;
    v8 = size;
    v9 = png_malloc_warn((_QWORD *)a1, size);
    if (v9)
    {
      v10 = v9;
      memcpy(v9, a4, v8);
      png_free_data(a1, a2, 0x8000u, 0);
      *(_DWORD *)(a2 + 236) = v7;
      *(_QWORD *)(a2 + 240) = v10;
      *(_DWORD *)(a2 + 300) |= 0x8000u;
      *(_DWORD *)(a2 + 8) |= 0x10000u;
    }
    else
    {
      *(_DWORD *)(a2 + 236) = 0;
      png_warning(a1, "Insufficient memory for eXIf chunk data");
    }
  }
}

uint64_t png_handle_pHYs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4;
  uint64_t result;
  const char *v7;
  uint64_t v8;
  char v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v4 = *(_DWORD *)(a1 + 76);
  if ((v4 & 1) == 0)
    png_chunk_error((void (**)(void))a1, "missing IHDR");
  if ((v4 & 4) != 0)
  {
    png_crc_finish(a1, a3);
    v7 = "out of place";
    return png_chunk_benign_error(a1, v7);
  }
  if (a2 && (*(_BYTE *)(a2 + 8) & 0x80) != 0)
  {
    png_crc_finish(a1, a3);
    v7 = "duplicate";
    return png_chunk_benign_error(a1, v7);
  }
  if ((_DWORD)a3 != 9)
  {
    png_crc_finish(a1, a3);
    v7 = "invalid";
    return png_chunk_benign_error(a1, v7);
  }
  v9 = 0;
  v8 = 0;
  png_crc_read(a1, (Bytef *)&v8, 9u);
  result = png_crc_finish(a1, 0);
  if (!(_DWORD)result)
    return _cg_png_set_pHYs(a1, a2, bswap32(v8), bswap32(HIDWORD(v8)), v9);
  return result;
}

uint64_t _cg_png_set_pHYs(uint64_t result, uint64_t a2, int a3, int a4, char a5)
{
  if (result)
  {
    if (a2)
    {
      *(_DWORD *)(a2 + 224) = a3;
      *(_DWORD *)(a2 + 228) = a4;
      *(_BYTE *)(a2 + 232) = a5;
      *(_DWORD *)(a2 + 8) |= 0x80u;
    }
  }
  return result;
}

uint64_t PNGReadPlugin::Read_user_chunkIDOT(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t io_ptr;
  unsigned int *v7;
  void *v8;
  uint64_t v10;
  IIO_Reader *v11;
  uint64_t v12;
  _DWORD *v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int height;
  char *v17;
  _DWORD *v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v24;
  IIOImageRead *Size;
  unint64_t v26;
  uint64_t v28;
  _DWORD *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 56) || *(_QWORD *)(a1 + 48))
    return 1;
  io_ptr = _cg_png_get_io_ptr(a2);
  *(_BYTE *)(a1 + 57) = 0;
  v7 = *(unsigned int **)(a3 + 8);
  if (!v7 || *(_QWORD *)(a3 + 16) <= 7uLL)
  {
    *(_BYTE *)(a1 + 57) = 1;
LABEL_6:
    LogError("Read_user_chunkIDOT", 985, "invalid 'iDOT' chunk (count = %d)\n");
    goto LABEL_7;
  }
  v10 = bswap32(*v7);
  if ((v10 - 2) > 0xE)
    goto LABEL_6;
  v11 = (IIO_Reader *)io_ptr;
  v12 = 12 * v10;
  v13 = malloc_type_malloc(v12 + 4, 0xBD87507CuLL);
  *(_QWORD *)(a1 + 48) = v13;
  *v13 = v10;
  if (*(_QWORD *)(a3 + 16) < (unint64_t)(v12 + 4))
    *(_BYTE *)(a1 + 57) = 1;
  v14 = IIO_Reader::minimumFileSize(v11);
  if (*(_BYTE *)(a1 + 57))
    goto LABEL_8;
  v15 = v14;
  height = _cg_png_get_height(a2);
  v17 = (char *)v7 + 7;
  v18 = v13 + 3;
  v19 = v10;
  while (1)
  {
    v20 = bswap32(*(_DWORD *)(v17 - 3));
    if (v20 > height)
      break;
    *(v18 - 2) = v20;
    v21 = bswap32(*(_DWORD *)(v17 + 1));
    v22 = v21 + v20;
    if (v21 > height || v22 > height)
      break;
    *(v18 - 1) = v21;
    v24 = *(_DWORD *)(v17 + 5);
    v17 += 12;
    *v18 = v15 - 12 * v10 - 12 + bswap32(v24);
    v18 += 3;
    if (!--v19)
    {
      if (*(_BYTE *)(a1 + 57))
        goto LABEL_8;
      LODWORD(v31) = 0;
      if (IIOImageReadSession::getBytesAtOffset(v11, &v31, v15 + 4, 4uLL) == 4)
      {
        if ((_DWORD)v31 == 1413563465)
        {
          if (*(_BYTE *)(a1 + 57))
            goto LABEL_8;
          Size = IIOImageReadSession::getSize(v11);
          v34 = 0;
          v33 = 0;
          v26 = (unint64_t)Size;
          IIOImageReadSession::getBytesAtOffset(v11, &v33, (unint64_t)Size - 12, 0xCuLL);
          if (v33 != 0x444E454900000000 || v34 != -2107620690)
          {
            LogError("Read_user_chunkIDOT", 935, "invalid PNG file: no valid iEnd chunk\n");
            *(_BYTE *)(a1 + 57) = 1;
            return 1;
          }
          v28 = 0;
          v31 = 0;
          v32 = 0;
          v29 = v13 + 3;
          while (1)
          {
            v30 = v29[v28];
            if (v30 < 0xC)
              break;
            IIOImageReadSession::getBytesAtOffset(v11, &v31, v30 - 12, 0x10uLL);
            if (HIDWORD(v32) != 1413563465)
            {
              LogWarning("Read_user_chunkIDOT", 958, "*** ERROR: invalid PNG file: iDOT doesn't point to valid IDAT chunk\n");
              goto LABEL_7;
            }
            if (v26 < bswap32(v32) + v30)
            {
              LogWarning("Read_user_chunkIDOT", 965, "*** ERROR: invalid PNG file: bad IDAT size\n");
              goto LABEL_7;
            }
            if (v28 * 4 && (_DWORD)v31 != -65536)
            {
              _cg_jpeg_mem_term("Read_user_chunkIDOT", 975, "*** ERROR: hacked PNG file\n");
              goto LABEL_7;
            }
            v28 += 3;
            if (!--v10)
            {
              if (*(_BYTE *)(a1 + 57))
                goto LABEL_8;
              return 1;
            }
          }
        }
        else
        {
          LogError("Read_user_chunkIDOT", 918, "invalid PNG file: extra chunks between iDOT and IDAT\n");
        }
      }
      break;
    }
  }
LABEL_7:
  *(_BYTE *)(a1 + 57) = 1;
LABEL_8:
  *(_BYTE *)(a1 + 56) = 1;
  v8 = *(void **)(a1 + 48);
  if (v8)
  {
    free(v8);
    *(_QWORD *)(a1 + 48) = 0;
    _cg_jpeg_mem_term("Read_user_chunkIDOT", 996, "PNG: invalid 'iDOT' chunk\n");
  }
  return 1;
}

uint64_t _cg_png_get_height(uint64_t a1)
{
  return *(unsigned int *)(a1 + 284);
}

uint64_t IIO_Reader::minimumFileSize(IIO_Reader *this)
{
  return *((_QWORD *)this + 5);
}

char *png_realloc_array(void (**a1)(void), const void *a2, unsigned int a3, unsigned int a4, unint64_t a5)
{
  char *v9;
  char *v10;
  size_t v11;

  if ((a3 & 0x80000000) != 0 || (int)a4 < 1 || !a5 || !a2 && a3)
    _cg_png_error(a1, "internal error: array realloc");
  if ((a3 ^ 0x7FFFFFFF) < a4)
    return 0;
  v9 = 0;
  if (is_mul_ok(a5, a4 + a3))
  {
    v10 = (char *)png_malloc_base((uint64_t)a1, (a4 + a3) * a5);
    v9 = v10;
    if (v10)
    {
      if (a3)
      {
        v11 = a3 * a5;
        memcpy(v10, a2, v11);
      }
      else
      {
        v11 = 0;
      }
      bzero(&v9[v11], a4 * a5);
    }
  }
  return v9;
}

uint64_t check_location(uint64_t a1, char a2)
{
  int v2;
  int v4;
  int v5;

  v2 = a2 & 0xB;
  if ((a2 & 0xB) == 0)
  {
    if ((*(_BYTE *)(a1 + 77) & 0x80) != 0
      || (png_app_warning(a1, "png_set_unknown_chunks now expects a valid location"),
          (v2 = *(_DWORD *)(a1 + 76) & 0xB) == 0))
    {
      _cg_png_error((void (**)(void))a1, "invalid location in png_set_unknown_chunks");
    }
  }
  do
  {
    v4 = v2;
    v5 = v2 & -v2;
    v2 ^= v5;
  }
  while (v4 != v5);
  return v4;
}

void png_handle_gAMA(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4;
  const char *v5;
  int v7;
  int v8;
  unsigned int v9;

  v4 = *(_DWORD *)(a1 + 76);
  if ((v4 & 1) == 0)
    png_chunk_error((void (**)(void))a1, "missing IHDR");
  if ((v4 & 6) != 0)
  {
    png_crc_finish(a1, a3);
    v5 = "out of place";
LABEL_12:
    png_chunk_benign_error(a1, v5);
    return;
  }
  if ((_DWORD)a3 != 4)
  {
    png_crc_finish(a1, a3);
    v5 = "invalid";
    goto LABEL_12;
  }
  v9 = 0;
  png_crc_read(a1, (Bytef *)&v9, 4u);
  if (!png_crc_finish(a1, 0))
  {
    v7 = bswap32(v9);
    if (v7 < 0)
      v8 = -1;
    else
      v8 = v7;
    png_colorspace_set_gamma(a1, a1 + 1000, v8);
    png_colorspace_sync(a1, a2);
  }
}

uint64_t png_colorspace_set_gamma(uint64_t result, uint64_t a2, int a3)
{
  __int16 v4;
  char *v5;

  if ((a3 - 625000001) < 0xDABF41CF)
  {
    v4 = *(_WORD *)(a2 + 74);
    v5 = "gamma value out of range";
LABEL_6:
    *(_WORD *)(a2 + 74) = v4 | 0x8000;
    return png_chunk_report(result, v5, 1);
  }
  v4 = *(_WORD *)(a2 + 74);
  if ((*(_BYTE *)(result + 77) & 0x80) != 0 && (v4 & 8) != 0)
  {
    v5 = "duplicate";
    goto LABEL_6;
  }
  if ((*(_WORD *)(a2 + 74) & 0x8000) == 0)
  {
    result = png_colorspace_check_gamma(result, a2, a3, 1);
    if ((_DWORD)result)
    {
      *(_DWORD *)a2 = a3;
      *(_WORD *)(a2 + 74) = v4 | 9;
    }
  }
  return result;
}

void png_handle_cHRM(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4;
  const char *v5;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  const char *v24;
  int v25[8];
  __int128 v26;
  __int128 v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v4 = *(_DWORD *)(a1 + 76);
  if ((v4 & 1) == 0)
    png_chunk_error((void (**)(void))a1, "missing IHDR");
  if ((v4 & 6) != 0)
  {
    png_crc_finish(a1, a3);
    v5 = "out of place";
LABEL_42:
    png_chunk_benign_error(a1, v5);
    return;
  }
  if ((_DWORD)a3 != 32)
  {
    png_crc_finish(a1, a3);
    v5 = "invalid";
    goto LABEL_42;
  }
  v26 = 0u;
  v27 = 0u;
  png_crc_read(a1, (Bytef *)&v26, 0x20u);
  if (!png_crc_finish(a1, 0))
  {
    v7 = bswap32(v26);
    if (v7 < 0)
      v8 = -1;
    else
      v8 = v7;
    v9 = bswap32(DWORD1(v26));
    if (v9 < 0)
      v10 = -1;
    else
      v10 = v9;
    v25[6] = v8;
    v25[7] = v10;
    v11 = bswap32(DWORD2(v26));
    if (v11 < 0)
      v12 = -1;
    else
      v12 = v11;
    v13 = bswap32(HIDWORD(v26));
    if (v13 < 0)
      v14 = -1;
    else
      v14 = v13;
    v25[0] = v12;
    v25[1] = v14;
    v15 = bswap32(v27);
    if (v15 < 0)
      v16 = -1;
    else
      v16 = v15;
    v17 = bswap32(DWORD1(v27));
    if (v17 < 0)
      v18 = -1;
    else
      v18 = v17;
    v25[2] = v16;
    v25[3] = v18;
    v19 = bswap32(DWORD2(v27));
    if (v19 < 0)
      v20 = -1;
    else
      v20 = v19;
    v21 = bswap32(HIDWORD(v27));
    if (v21 < 0)
      v22 = -1;
    else
      v22 = v21;
    v25[4] = v20;
    v25[5] = v22;
    if (v7 < 0 || v9 < 0 || v11 < 0 || v13 < 0 || v15 < 0 || v17 < 0 || v19 < 0 || v21 < 0)
    {
      v24 = "invalid values";
    }
    else
    {
      v23 = *(__int16 *)(a1 + 1074);
      if (v23 < 0)
        return;
      if ((v23 & 0x10) == 0)
      {
        *(_WORD *)(a1 + 1074) = v23 | 0x10;
        png_colorspace_set_chromaticities((void (**)(void))a1, a1 + 1000, v25, 1);
        png_colorspace_sync(a1, a2);
        return;
      }
      *(_WORD *)(a1 + 1074) = v23 | 0x8000;
      png_colorspace_sync(a1, a2);
      v24 = "duplicate";
    }
    png_chunk_benign_error(a1, v24);
  }
}

uint64_t png_colorspace_check_xy(int *a1, int *a2)
{
  int v2;
  uint64_t result;
  int v5;
  unsigned int v6;
  signed int v7;
  unsigned int v8;
  signed int v9;
  unsigned int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  double v15;
  int v17;
  int v18;
  int v19;
  double v20;
  int v22;
  int v23;
  double v24;
  int v26;
  int v27;
  double v28;
  int v30;
  int v31;
  int v32;
  double v33;
  int v35;
  double v36;
  int v38;
  double v39;
  int v41;
  double v42;
  double v44;
  double v45;
  BOOL v46;
  unsigned int v47;
  double v48;
  double v49;
  double v50;
  BOOL v51;
  unsigned int v52;
  double v53;
  unsigned int v54;
  double v55;
  double v56;
  BOOL v57;
  unsigned int v58;
  int v59;
  double v60;
  int v62;
  double v63;
  int v65;
  double v66;
  int v68;
  double v69;
  int v71;
  double v72;
  int v74;
  double v75;
  int v77;
  double v78;
  int v80;
  double v81;
  int v83;
  double v84;
  _OWORD v87[2];

  v2 = *a2;
  if (*a2 > 0x186A0)
    return 1;
  v5 = a2[1];
  result = 1;
  if ((v5 & 0x80000000) == 0 && v5 <= 100000 - v2)
  {
    v6 = a2[2];
    if (v6 <= 0x186A0)
    {
      v7 = a2[3];
      if ((v7 & 0x80000000) == 0 && v7 <= (int)(100000 - v6))
      {
        v8 = a2[4];
        if (v8 <= 0x186A0)
        {
          v9 = a2[5];
          if ((v9 & 0x80000000) == 0 && v9 <= (int)(100000 - v8))
          {
            v10 = a2[6];
            if (v10 <= 0x186A0)
            {
              v11 = a2[7];
              if (v11 >= 5 && v11 <= (int)(100000 - v10))
              {
                v12 = 0;
                v13 = v5 - v9;
                v14 = v6 - v8;
                if (v6 != v8 && v5 != v9)
                {
                  v15 = floor((double)v14 * (double)v13 / 7.0 + 0.5);
                  if (v15 > 2147483650.0 || v15 < -2147483650.0)
                    return 2;
                  v12 = (int)v15;
                }
                v17 = 0;
                v18 = v7 - v9;
                v19 = v2 - v8;
                if (v2 != v8 && v7 != v9)
                {
                  v20 = floor((double)v19 * (double)v18 / 7.0 + 0.5);
                  if (v20 > 2147483650.0 || v20 < -2147483650.0)
                    return 2;
                  v17 = (int)v20;
                }
                v22 = 0;
                v23 = v11 - v9;
                if (v6 != v8 && v11 != v9)
                {
                  v24 = floor((double)v14 * (double)v23 / 7.0 + 0.5);
                  if (v24 > 2147483650.0 || v24 < -2147483650.0)
                    return 2;
                  v22 = (int)v24;
                }
                v26 = 0;
                v27 = v10 - v8;
                if (v7 != v9 && v10 != v8)
                {
                  v28 = floor((double)v18 * (double)v27 / 7.0 + 0.5);
                  if (v28 > 2147483650.0 || v28 < -2147483650.0)
                    return 2;
                  v26 = (int)v28;
                }
                v30 = v22 - v26;
                if (v22 == v26)
                  return 1;
                v31 = v12 - v17;
                if (v12 == v17)
                {
                  v32 = 0;
                }
                else
                {
                  v33 = floor((double)v11 * (double)v31 / (double)v30 + 0.5);
                  if (v33 > 2147483650.0 || v33 < -2147483650.0)
                    return 1;
                  v32 = (int)v33;
                }
                if (v32 <= v11)
                  return 1;
                v35 = 0;
                if (v5 != v9 && v10 != v8)
                {
                  v36 = floor((double)v13 * (double)v27 / 7.0 + 0.5);
                  if (v36 > 2147483650.0 || v36 < -2147483650.0)
                    return 2;
                  v35 = (int)v36;
                }
                v38 = 0;
                if (v2 == v8 || v11 == v9)
                {
LABEL_67:
                  if (v35 != v38)
                  {
                    if (v12 == v17)
                    {
                      v41 = 0;
                    }
                    else
                    {
                      v42 = floor((double)v11 * (double)v31 / (double)(v35 - v38) + 0.5);
                      if (v42 > 2147483650.0 || v42 < -2147483650.0)
                        return 1;
                      v41 = (int)v42;
                    }
                    if (v41 <= v11)
                      return 1;
                    v44 = 1.0e10 / (double)v11 + 0.5;
                    v45 = floor(v44);
                    v46 = v45 < -2147483650.0 || v45 > 2147483650.0;
                    v47 = vcvtmd_s64_f64(v44);
                    if (v46)
                      v47 = 0;
                    v48 = (double)v32;
                    v49 = 1.0e10 / (double)v32 + 0.5;
                    v50 = floor(v49);
                    v51 = v50 < -2147483650.0 || v50 > 2147483650.0;
                    v52 = vcvtmd_s64_f64(v49);
                    v53 = (double)v41;
                    if (v51)
                      v54 = 0;
                    else
                      v54 = v52;
                    v55 = 1.0e10 / v53 + 0.5;
                    v56 = floor(v55);
                    v57 = v56 < -2147483650.0 || v56 > 2147483650.0;
                    v58 = vcvtmd_s64_f64(v55);
                    if (v57)
                      v58 = 0;
                    v59 = v47 - (v54 + v58);
                    if (v59 < 1)
                      return 1;
                    if (v2)
                    {
                      v60 = floor((double)v2 * 100000.0 / v48 + 0.5);
                      if (v60 > 2147483650.0 || v60 < -2147483650.0)
                        return 1;
                      v2 = (int)v60;
                    }
                    *a1 = v2;
                    v62 = a2[1];
                    if (v62)
                    {
                      v63 = floor((double)v62 * 100000.0 / v48 + 0.5);
                      if (v63 > 2147483650.0 || v63 < -2147483650.0)
                        return 1;
                      v62 = (int)v63;
                    }
                    a1[1] = v62;
                    v65 = 100000 - (a2[1] + *a2);
                    if (v65)
                    {
                      v66 = floor((double)v65 * 100000.0 / v48 + 0.5);
                      if (v66 > 2147483650.0 || v66 < -2147483650.0)
                        return 1;
                      v65 = (int)v66;
                    }
                    a1[2] = v65;
                    v68 = a2[2];
                    if (v68)
                    {
                      v69 = floor((double)v68 * 100000.0 / v53 + 0.5);
                      if (v69 > 2147483650.0 || v69 < -2147483650.0)
                        return 1;
                      v68 = (int)v69;
                    }
                    a1[3] = v68;
                    v71 = a2[3];
                    if (v71)
                    {
                      v72 = floor((double)v71 * 100000.0 / v53 + 0.5);
                      if (v72 > 2147483650.0 || v72 < -2147483650.0)
                        return 1;
                      v71 = (int)v72;
                    }
                    a1[4] = v71;
                    v74 = 100000 - (a2[3] + a2[2]);
                    if (v74)
                    {
                      v75 = floor((double)v74 * 100000.0 / v53 + 0.5);
                      if (v75 > 2147483650.0 || v75 < -2147483650.0)
                        return 1;
                      v74 = (int)v75;
                    }
                    a1[5] = v74;
                    v77 = a2[4];
                    if (v77)
                    {
                      v78 = floor((double)v59 * (double)v77 / 100000.0 + 0.5);
                      if (v78 > 2147483650.0 || v78 < -2147483650.0)
                        return 1;
                      v77 = (int)v78;
                    }
                    a1[6] = v77;
                    v80 = a2[5];
                    if (v80)
                    {
                      v81 = floor((double)v59 * (double)v80 / 100000.0 + 0.5);
                      if (v81 > 2147483650.0 || v81 < -2147483650.0)
                        return 1;
                      v80 = (int)v81;
                    }
                    a1[7] = v80;
                    v83 = 100000 - (a2[5] + a2[4]);
                    if (v83)
                    {
                      v84 = floor((double)v59 * (double)v83 / 100000.0 + 0.5);
                      if (v84 > 2147483650.0 || v84 < -2147483650.0)
                        return 1;
                      v83 = (int)v84;
                    }
                    memset(v87, 0, sizeof(v87));
                    a1[8] = v83;
                    if (!png_xy_from_XYZ((int *)v87, a1))
                      return !png_colorspace_endpoints_match(a2, v87, 5);
                  }
                  return 1;
                }
                v39 = floor((double)v19 * (double)v23 / 7.0 + 0.5);
                if (v39 <= 2147483650.0 && v39 >= -2147483650.0)
                {
                  v38 = (int)v39;
                  goto LABEL_67;
                }
                return 2;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t png_xy_from_XYZ(int *a1, int *a2)
{
  int v2;
  int v3;
  double v4;
  int v6;
  double v7;
  int v9;
  int v10;
  int v11;
  int v12;
  double v13;
  int v15;
  double v16;
  int v18;
  int v19;
  int v20;
  int v21;
  double v22;
  int v24;
  double v25;
  int v27;
  int v28;
  int v29;
  int v30;
  double v31;
  int v33;
  double v34;
  uint64_t v36;
  int v38;

  v2 = *a2;
  v3 = a2[1] + *a2 + a2[2];
  if (v3)
  {
    if (v2)
    {
      v4 = floor((double)v2 * 100000.0 / (double)v3 + 0.5);
      if (v4 > 2147483650.0 || v4 < -2147483650.0)
        return 1;
      v2 = (int)v4;
    }
    *a1 = v2;
    v6 = a2[1];
    if (v6)
    {
      v7 = floor((double)v6 * 100000.0 / (double)v3 + 0.5);
      if (v7 > 2147483650.0 || v7 < -2147483650.0)
        return 1;
      v6 = (int)v7;
    }
    a1[1] = v6;
    v9 = a2[3];
    v10 = a2[4] + v9 + a2[5];
    if (v10)
    {
      v12 = *a2;
      v11 = a2[1];
      if (v9)
      {
        v13 = floor((double)v9 * 100000.0 / (double)v10 + 0.5);
        if (v13 > 2147483650.0 || v13 < -2147483650.0)
          return 1;
        v9 = (int)v13;
      }
      a1[2] = v9;
      v15 = a2[4];
      if (v15)
      {
        v16 = floor((double)v15 * 100000.0 / (double)v10 + 0.5);
        if (v16 > 2147483650.0 || v16 < -2147483650.0)
          return 1;
        v15 = (int)v16;
      }
      a1[3] = v15;
      v18 = a2[6];
      v19 = a2[7] + v18 + a2[8];
      if (v19)
      {
        v21 = a2[3];
        v20 = a2[4];
        if (v18)
        {
          v22 = floor((double)v18 * 100000.0 / (double)v19 + 0.5);
          if (v22 > 2147483650.0 || v22 < -2147483650.0)
            return 1;
          v18 = (int)v22;
        }
        a1[4] = v18;
        v24 = a2[7];
        if (v24)
        {
          v25 = floor((double)v24 * 100000.0 / (double)v19 + 0.5);
          if (v25 > 2147483650.0 || v25 < -2147483650.0)
            return 1;
          v24 = (int)v25;
        }
        a1[5] = v24;
        v27 = v10 + v3 + v19;
        if (v27)
        {
          v28 = v21 + v12;
          v29 = a2[7];
          v30 = v28 + a2[6];
          if (v30)
          {
            v31 = floor((double)v30 * 100000.0 / (double)v27 + 0.5);
            if (v31 > 2147483650.0 || v31 < -2147483650.0)
              return 1;
            v30 = (int)v31;
          }
          a1[6] = v30;
          v33 = v20 + v11 + v29;
          if (!v33)
          {
            v38 = 0;
            goto LABEL_56;
          }
          v34 = floor((double)v33 * 100000.0 / (double)v27 + 0.5);
          if (v34 <= 2147483650.0 && v34 >= -2147483650.0)
          {
            v38 = (int)v34;
LABEL_56:
            v36 = 0;
            a1[7] = v38;
            return v36;
          }
        }
      }
    }
  }
  return 1;
}

uint64_t png_colorspace_set_chromaticities(void (**a1)(void), uint64_t a2, int *a3, int a4)
{
  int v8;
  _OWORD v10[2];
  int v11;

  v11 = 0;
  memset(v10, 0, sizeof(v10));
  v8 = png_colorspace_check_xy((int *)v10, a3);
  if (v8 == 1)
  {
    *(_WORD *)(a2 + 74) |= 0x8000u;
    png_benign_error((uint64_t)a1, "invalid chromaticities");
    return 0;
  }
  else
  {
    if (v8)
    {
      *(_WORD *)(a2 + 74) |= 0x8000u;
      _cg_png_error(a1, "internal error checking chromaticities");
    }
    return png_colorspace_set_xy_and_XYZ((uint64_t)a1, a2, (uint64_t)a3, (uint64_t)v10, a4);
  }
}

uint64_t png_colorspace_set_xy_and_XYZ(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  int v5;
  __int128 v11;
  __int128 v12;
  _BOOL4 v13;
  __int16 v14;

  v5 = *(__int16 *)(a2 + 74);
  if (v5 < 0)
    return 0;
  if (a5 > 1 || (v5 & 2) == 0)
    goto LABEL_6;
  if (!png_colorspace_endpoints_match((int *)a3, (_DWORD *)(a2 + 4), 100))
  {
    *(_WORD *)(a2 + 74) = v5 | 0x8000;
    png_benign_error(a1, "inconsistent chromaticities");
    return 0;
  }
  if (!a5)
    return 1;
LABEL_6:
  v11 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)(a2 + 4) = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 20) = v11;
  v12 = *(_OWORD *)(a4 + 16);
  *(_OWORD *)(a2 + 36) = *(_OWORD *)a4;
  *(_OWORD *)(a2 + 52) = v12;
  *(_DWORD *)(a2 + 68) = *(_DWORD *)(a4 + 32);
  v13 = png_colorspace_endpoints_match((int *)a3, &sRGB_xy, 1000);
  v14 = v5 & 0xFFBD | 2;
  if (v13)
    v14 = v5 | 0x42;
  *(_WORD *)(a2 + 74) = v14;
  return 2;
}

BOOL png_colorspace_endpoints_match(int *a1, _DWORD *a2, int a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  BOOL v7;
  BOOL v8;
  BOOL v9;
  int v10;
  int v11;
  int v12;
  int v13;
  BOOL v14;
  BOOL v15;
  BOOL v16;
  int v17;
  int v18;
  BOOL v19;
  BOOL v20;
  BOOL v21;
  uint64_t v22;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  BOOL v36;
  BOOL v37;
  BOOL v38;

  v3 = a1[6];
  v4 = a2[6];
  v5 = v4 - a3;
  v6 = v4 + a3;
  if (v3 >= v5)
  {
    v9 = __OFSUB__(v3, v6);
    v7 = v3 == v6;
    v8 = v3 - v6 < 0;
  }
  else
  {
    v9 = 0;
    v7 = 0;
    v8 = 0;
  }
  if (!(v8 ^ v9 | v7))
    return 0;
  v10 = a1[7];
  v11 = a2[7];
  v12 = v11 - a3;
  v13 = v11 + a3;
  if (v10 >= v12)
  {
    v16 = __OFSUB__(v10, v13);
    v14 = v10 == v13;
    v15 = v10 - v13 < 0;
  }
  else
  {
    v16 = 0;
    v14 = 0;
    v15 = 0;
  }
  if (!(v15 ^ v16 | v14))
    return 0;
  v17 = *a1;
  v18 = *a2 + a3;
  if (*a1 >= *a2 - a3)
  {
    v21 = __OFSUB__(v17, v18);
    v19 = v17 == v18;
    v20 = v17 - v18 < 0;
  }
  else
  {
    v21 = 0;
    v19 = 0;
    v20 = 0;
  }
  if (!(v20 ^ v21 | v19))
    return 0;
  v22 = 0;
  v24 = a1[1];
  v25 = a2[1];
  if (v24 >= v25 - a3 && v24 <= v25 + a3)
  {
    v22 = 0;
    v26 = a1[2];
    v27 = a2[2];
    if (v26 >= v27 - a3 && v26 <= v27 + a3)
    {
      v22 = 0;
      v28 = a1[3];
      v29 = a2[3];
      if (v28 >= v29 - a3 && v28 <= v29 + a3)
      {
        v22 = 0;
        v30 = a1[4];
        v31 = a2[4];
        if (v30 >= v31 - a3 && v30 <= v31 + a3)
        {
          v32 = a1[5];
          v33 = a2[5];
          v34 = v33 - a3;
          v35 = v33 + a3;
          if (v32 >= v34)
          {
            v38 = __OFSUB__(v32, v35);
            v36 = v32 == v35;
            v37 = v32 - v35 < 0;
          }
          else
          {
            v38 = 0;
            v36 = 0;
            v37 = 0;
          }
          return (v37 ^ v38 | v36) != 0;
        }
      }
    }
  }
  return v22;
}

const char *LogError(const char *result, int a2, const char *a3, ...)
{
  va_list va;

  va_start(va, a3);
  if (gImageIOLogProc)
    return (const char *)gImageIOLogProc(16, 0, result, a2, a3, va);
  return result;
}

void (**_cg_png_set_PLTE(void (**result)(void), uint64_t a2, const void *a3, unsigned int a4))(void)
{
  void (**v7)(void);
  const char *v8;
  void (**v9)(void);

  if (result && a2)
  {
    v7 = result;
    if (*(_BYTE *)(a2 + 37) == 3)
    {
      if ((a4 & 0x80000000) != 0 || 1 << *(_BYTE *)(a2 + 36) < (int)a4)
      {
        v8 = "Invalid palette length";
        goto LABEL_18;
      }
    }
    else if (a4 > 0x100)
    {
      return (void (**)(void))png_warning((uint64_t)result, "Invalid palette length");
    }
    if (!a3 && a4 || !a4 && ((_BYTE)result[95] & 1) == 0)
    {
      v8 = "Invalid palette";
LABEL_18:
      _cg_png_error(result, v8);
    }
    png_free_data((uint64_t)result, a2, 0x1000u, 0);
    result = png_calloc(v7, 0x300uLL);
    v9 = result;
    v7[46] = (void (*)(void))result;
    if (a4)
      result = (void (**)(void))memcpy(result, a3, 3 * a4);
    *(_QWORD *)(a2 + 24) = v9;
    *((_WORD *)v7 + 188) = a4;
    *(_WORD *)(a2 + 32) = a4;
    *(_DWORD *)(a2 + 300) |= 0x1000u;
    *(_DWORD *)(a2 + 8) |= 8u;
  }
  return result;
}

void (**png_calloc(void (**a1)(void), size_t a2))(void)
{
  void (**v3)(void);
  void (**v4)(void);

  v3 = png_malloc(a1, a2);
  v4 = v3;
  if (v3)
    bzero(v3, a2);
  return v4;
}

void _cg_png_error(void (**a1)(void), const char *a2)
{
  if (a1)
  {
    if (*a1)
      (*a1)();
  }
  png_default_error(a2);
}

void png_handle_tRNS(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4;
  __int16 v5;
  int v7;
  const char *v8;
  int v9;
  unsigned int v10;
  int v11;
  unsigned __int16 v12;
  _OWORD v13[16];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v4 = *(_DWORD *)(a1 + 76);
  if ((v4 & 1) == 0)
    png_chunk_error((void (**)(void))a1, "missing IHDR");
  v5 = a3;
  if ((v4 & 4) != 0)
    goto LABEL_12;
  if (a2 && (*(_BYTE *)(a2 + 8) & 0x10) != 0)
  {
    png_crc_finish(a1, a3);
    v8 = "duplicate";
    goto LABEL_13;
  }
  memset(v13, 0, sizeof(v13));
  v7 = *(unsigned __int8 *)(a1 + 391);
  if (v7 == 3)
  {
    if ((v4 & 2) != 0)
    {
      if (a3 > 0x100 || (int)a3 - 1 >= *(unsigned __int16 *)(a1 + 376))
      {
        png_crc_finish(a1, a3);
        v8 = "invalid";
        goto LABEL_13;
      }
      png_crc_read(a1, (Bytef *)v13, a3);
      *(_WORD *)(a1 + 384) = v5;
      goto LABEL_21;
    }
LABEL_12:
    png_crc_finish(a1, a3);
    v8 = "out of place";
    goto LABEL_13;
  }
  if (v7 != 2)
  {
    if (!*(_BYTE *)(a1 + 391))
    {
      LOWORD(v11) = 0;
      if ((_DWORD)a3 == 2)
      {
        png_crc_read(a1, (Bytef *)&v11, 2u);
        *(_WORD *)(a1 + 384) = 1;
        *(_WORD *)(a1 + 536) = bswap32((unsigned __int16)v11) >> 16;
        goto LABEL_21;
      }
LABEL_17:
      png_crc_finish(a1, a3);
      png_chunk_benign_error(a1, "invalid");
      return;
    }
    png_crc_finish(a1, a3);
    v8 = "invalid with alpha channel";
LABEL_13:
    png_chunk_benign_error(a1, v8);
    return;
  }
  v12 = 0;
  v11 = 0;
  if ((_DWORD)a3 != 6)
    goto LABEL_17;
  png_crc_read(a1, (Bytef *)&v11, 6u);
  *(_WORD *)(a1 + 384) = 1;
  *(_WORD *)(a1 + 530) = bswap32((unsigned __int16)v11) >> 16;
  *(_WORD *)(a1 + 532) = bswap32(HIWORD(v11)) >> 16;
  *(_WORD *)(a1 + 534) = bswap32(v12) >> 16;
LABEL_21:
  if (png_crc_finish(a1, 0))
  {
    *(_WORD *)(a1 + 384) = 0;
    v9 = *(_DWORD *)(a1 + 80);
    if ((*(_BYTE *)(a1 + 315) & 0x20) != 0)
    {
      if ((v9 & 0x200) != 0)
        return;
    }
    else if ((v9 & 0x400) == 0)
    {
      return;
    }
    v10 = 0;
  }
  else
  {
    v10 = *(unsigned __int16 *)(a1 + 384);
  }
  _cg_png_set_tRNS(a1, a2, v13, v10, a1 + 528);
}

void _cg_png_set_tRNS(uint64_t a1, uint64_t a2, const void *a3, unsigned int a4, uint64_t a5)
{
  void (**v10)(void);
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  __int16 v14;

  if (a1 && a2)
  {
    if (a3)
    {
      png_free_data(a1, a2, 0x2000u, 0);
      if (a4 - 1 >= 0x100)
      {
        v10 = *(void (***)(void))(a2 + 184);
      }
      else
      {
        v10 = png_malloc((void (**)(void))a1, 0x100uLL);
        *(_QWORD *)(a2 + 184) = v10;
        memcpy(v10, a3, a4);
        *(_DWORD *)(a2 + 300) |= 0x2000u;
        *(_DWORD *)(a2 + 8) |= 0x10u;
      }
      *(_QWORD *)(a1 + 520) = v10;
    }
    if (a5)
    {
      v11 = *(unsigned __int8 *)(a2 + 36);
      if (v11 <= 0xF)
      {
        v12 = ~(-1 << v11);
        if (*(_BYTE *)(a2 + 37) == 2)
        {
          if (*(unsigned __int16 *)(a5 + 2) > v12 || *(unsigned __int16 *)(a5 + 4) > v12)
            goto LABEL_19;
          v13 = *(unsigned __int16 *)(a5 + 6);
        }
        else
        {
          if (*(_BYTE *)(a2 + 37))
            goto LABEL_20;
          v13 = *(unsigned __int16 *)(a5 + 8);
        }
        if (v13 > v12)
LABEL_19:
          png_warning(a1, "tRNS chunk has out-of-range samples for bit_depth");
      }
LABEL_20:
      *(_QWORD *)(a2 + 192) = *(_QWORD *)a5;
      *(_WORD *)(a2 + 200) = *(_WORD *)(a5 + 8);
      if (a4 <= 1)
        v14 = 1;
      else
        v14 = a4;
      *(_WORD *)(a2 + 34) = v14;
      goto LABEL_24;
    }
    *(_WORD *)(a2 + 34) = a4;
    if (a4)
    {
LABEL_24:
      *(_DWORD *)(a2 + 300) |= 0x2000u;
      *(_DWORD *)(a2 + 8) |= 0x10u;
    }
  }
}

uint64_t png_handle_zTXt(uint64_t a1, uint64_t a2, uint64_t size)
{
  int v6;
  int v7;
  uint64_t result;
  const char *v9;
  int v10;
  Bytef *buffer;
  Bytef *v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  unint64_t v16;
  _QWORD v17[7];
  unint64_t v18;

  v6 = *(_DWORD *)(a1 + 884);
  if (v6)
  {
    v7 = v6 - 1;
    if (!v7)
      return png_crc_finish(a1, size);
    *(_DWORD *)(a1 + 884) = v7;
    if (v7 == 1)
    {
      png_crc_finish(a1, size);
      v9 = "no space in chunk cache";
      return png_chunk_benign_error(a1, v9);
    }
  }
  v10 = *(_DWORD *)(a1 + 76);
  if ((v10 & 1) == 0)
    png_chunk_error((void (**)(void))a1, "missing IHDR");
  if ((v10 & 4) != 0)
    *(_DWORD *)(a1 + 76) = v10 | 8;
  buffer = (Bytef *)png_read_buffer(a1, size, 2);
  if (!buffer)
  {
    png_crc_finish(a1, size);
    v9 = "out of memory";
    return png_chunk_benign_error(a1, v9);
  }
  v12 = buffer;
  png_crc_read(a1, buffer, size);
  result = png_crc_finish(a1, 0);
  if (!(_DWORD)result)
  {
    if (!(_DWORD)size)
      goto LABEL_17;
    v13 = 0;
    while (v12[v13])
    {
      if (size == ++v13)
      {
        LODWORD(v13) = size;
        break;
      }
    }
    if ((v13 - 80) < 0xFFFFFFB1)
    {
LABEL_17:
      v14 = "bad keyword";
      return png_chunk_benign_error(a1, v14);
    }
    if ((int)v13 + 3 > size)
    {
      v14 = "truncated";
      return png_chunk_benign_error(a1, v14);
    }
    if (v12[v13 + 1])
    {
      v14 = "unknown compression type";
      return png_chunk_benign_error(a1, v14);
    }
    v18 = -1;
    result = png_decompress_chunk(a1, size, (int)v13 + 2, &v18);
    if ((_DWORD)result == 1)
    {
      v17[0] = 0;
      v15 = *(_QWORD *)(a1 + 936);
      if (v15)
      {
        v16 = v18;
        *(_BYTE *)(v15 + v18 + (v13 + 2)) = 0;
        v17[1] = v15;
        v17[2] = v15 + v13 + 2;
        v17[3] = v16;
        memset(&v17[4], 0, 24);
        result = png_set_text_2((void (**)(void))a1, a2, (uint64_t)v17, 1);
        if ((_DWORD)result)
          v14 = "insufficient memory";
        else
          v14 = 0;
      }
      else
      {
        v14 = "Read failure in png_handle_zTXt";
      }
    }
    else
    {
      v14 = *(const char **)(a1 + 144);
    }
    if (v14)
      return png_chunk_benign_error(a1, v14);
  }
  return result;
}

void png_default_error(const char *a1)
{
  FILE **v1;
  const char *v2;

  v1 = (FILE **)MEMORY[0x1E0C80C10];
  v2 = "undefined";
  if (a1)
    v2 = a1;
  fprintf((FILE *)*MEMORY[0x1E0C80C10], "libpng error: %s", v2);
  fputc(10, *v1);
  abort();
}

uint64_t IIOTextureHandler::LockDataCallback(IIOTextureHandler *this, void *a2, uint64_t a3, uint64_t a4, unint64_t *a5, unint64_t *a6, unint64_t *a7)
{
  uint64_t result;
  char v15[16];
  __int128 v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if ((gIIODebugFlags & 0xC000) != 0)
  {
    *(_OWORD *)v15 = 0u;
    v16 = 0u;
    sprintf(v15, "option: %d", (_DWORD)a7);
    if ((unsigned __int16)gIIODebugFlags >> 14)
      ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "LockDataCallback", 0, v15, -1, 0);
  }
  if (!this)
    return 0;
  result = *((_QWORD *)this + 1);
  if (result)
    return (*(uint64_t (**)(uint64_t, _QWORD, void *, uint64_t, uint64_t, unint64_t *, unint64_t *, unint64_t *))(*(_QWORD *)result + 40))(result, *((_QWORD *)this + 6), a2, a3, a4, a5, a6, a7);
  return result;
}

uint64_t ASTCTextureImp::textureDataLockData(ASTCTextureImp *this, IIOImageReadSession *a2, uint64_t a3, unint64_t a4, unint64_t *a5, unint64_t *a6, unint64_t *a7, char a8)
{
  pthread_mutex_t *v15;
  uint64_t v16;
  unint64_t v17;

  *a5 = 0;
  *a6 = 0;
  *a7 = 0;
  v15 = (pthread_mutex_t *)((char *)this + 168);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 168));
  if ((a8 & 2) != 0)
  {
    v16 = *((_QWORD *)this + 10);
    if (!v16)
    {
      if (*((_BYTE *)this + 41))
      {
        if (*((_BYTE *)this + 40))
          LogError("textureDataLockData", 1057, "*** pre-twiddled LZFSE compressed ASTC is not supported\n");
        else
          ASTCTextureImp::createTwiddledDataFromTwiddled(this, a2);
      }
      else if (*((_BYTE *)this + 40))
      {
        ASTCTextureImp::createTwiddledDataFromLinearLZFSE(this, a2, a3);
      }
      else
      {
        ASTCTextureImp::createTwiddledDataFromLinear((char *)this, a2, a3);
      }
      v16 = *((_QWORD *)this + 10);
      if (!v16)
        goto LABEL_22;
    }
    goto LABEL_21;
  }
  v16 = *((_QWORD *)this + 7);
  if (v16)
  {
LABEL_21:
    v17 = *((_QWORD *)this + 19);
    *a5 = *((_QWORD *)this + 18);
    *a6 = v17;
    *a7 = *((_QWORD *)this + 20);
LABEL_22:
    pthread_mutex_unlock(v15);
    return v16;
  }
  if (!*((_BYTE *)this + 41))
  {
    if (*((_BYTE *)this + 40))
      _cg_jpeg_mem_term("createLinearDataFromLZFSE", 992, "*** ERROR: createLinearDataFromLZFSE is not supported\n");
    else
      ASTCTextureImp::createLinearDataFromLinear(this, a2);
LABEL_17:
    v16 = *((_QWORD *)this + 7);
    if (!v16)
      goto LABEL_22;
    goto LABEL_21;
  }
  if (!*((_BYTE *)this + 40))
  {
    _cg_jpeg_mem_term("createLinearDataFromTwiddled", 1003, "*** ERROR: createLinearDataFromTwiddled is not supported\n");
    goto LABEL_17;
  }
  LogError("textureDataLockData", 1106, "*** pre-twiddled LZFSE compressed ASTC is not supported\n");
  return 0;
}

const char *ASTCTextureImp::createTwiddledDataFromLinearLZFSE(ASTCTextureImp *this, IIOImageReadSession *a2, uint64_t a3)
{
  ASTCTwiddler *v6;
  const void *v7;
  unsigned int Size;
  uint64_t v9;
  size_t v10;
  const char *result;
  unsigned __int8 *v12;
  int v14;

  ASTCTextureImp::createTwiddler(this, 1uLL);
  v6 = (ASTCTwiddler *)*((_QWORD *)this + 30);
  if (v6)
  {
    if (!ASTCTwiddler::finalized(v6))
    {
      if (!*((_QWORD *)this + 15))
      {
        *((_QWORD *)this + 15) = IIOImageReadSession::retainBytePointer(a2, (const __CFData **)this + 16, 1);
        v7 = (const void *)IIOImageSource::cf(a2);
        *((_QWORD *)this + 17) = v7;
        CFRetain(v7);
        if (!*((_QWORD *)this + 15))
        {
          result = (const char *)_cg_jpeg_mem_term("createTwiddledDataFromLinearLZFSE", 911, "*** ImageIO - can't access image data\n");
          goto LABEL_19;
        }
      }
      Size = IIOImageReadSession::getSize(a2);
      v9 = *((_QWORD *)this + 6);
      v10 = *((unsigned int *)this + 11);
      if (v9 + v10 > Size)
      {
        result = LogError("createTwiddledDataFromLinearLZFSE", 881, "*** ImageIO - bad LZFSE data - (fileSize: %ld   compressedDataOffset: %ld   compressedSize: %ld)\n");
LABEL_19:
        *((_QWORD *)this + 10) = 0;
        v14 = -50;
        goto LABEL_20;
      }
      v12 = (unsigned __int8 *)(*((_QWORD *)this + 15) + v9);
      if (v10 >= 9 && (*(_DWORD *)v12 != 846755426 || *(_DWORD *)&v12[v10 - 4] != 611874402))
      {
        result = LogError("createTwiddledDataFromLinearLZFSE", 900, "*** ImageIO - bad LZFSE data - no start/end marker\n");
        goto LABEL_19;
      }
      ASTCTwiddler::decodeAndCopyFromLinearData(*((ASTCTwiddler **)this + 30), v12, v10, (16 * *((_DWORD *)this + 5)), *((_DWORD *)this + 4));
    }
    v6 = (ASTCTwiddler *)*((_QWORD *)this + 30);
    if (!a3)
    {
      ASTCTwiddler::finalizeTwiddling(v6);
      v6 = (ASTCTwiddler *)*((_QWORD *)this + 30);
    }
  }
  *((_QWORD *)this + 10) = ASTCTwiddler::twiddledData(v6);
  result = (const char *)ASTCTwiddler::twiddledDataSize(*((ASTCTwiddler **)this + 30));
  v14 = 0;
  *((_QWORD *)this + 18) = result;
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 20) = result;
LABEL_20:
  *((_DWORD *)this + 58) = v14;
  return result;
}

ASTCTwiddler *ASTCTextureImp::createTwiddler(ASTCTwiddler *this, unint64_t a2)
{
  uint64_t v3;
  ASTCTwiddler *v4;

  if (!*((_QWORD *)this + 30))
  {
    v3 = (uint64_t)this;
    v4 = (ASTCTwiddler *)operator new();
    this = ASTCTwiddler::ASTCTwiddler(v4, *(unsigned int *)(v3 + 96), *(unsigned int *)(v3 + 100), *(unsigned int *)(v3 + 104), a2, 1);
    *(_QWORD *)(v3 + 240) = v4;
  }
  return this;
}

void sub_187E45BDC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0xA1C40BD48D6D6);
  _Unwind_Resume(a1);
}

void ASTCTwiddler::ASTCTwiddler(ASTCTwiddler *this, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, int a6)
{
  id v12;
  void *v13;
  void *v14;
  void *v15;
  memory_object_offset_t v16;
  size_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  size_t v21;
  uint64_t v22;
  size_t v23;

  *(_QWORD *)this = &off_1E1BAC030;
  *((_QWORD *)this + 1) = 0;
  v12 = MTLCreateSystemDefaultDevice();
  if (v12)
  {
    v13 = (void *)MEMORY[0x18D7626F8]();
    v14 = (void *)objc_msgSend(MEMORY[0x1E0CC6BB8], "texture2DDescriptorWithPixelFormat:width:height:mipmapped:", a2, a3, a4, a5 > 1);
    objc_msgSend(v14, "setMipmapLevelCount:", a5);
    v15 = (void *)objc_msgSend(v12, "newTextureLayoutWithDescriptor:isHeapOrBufferBacked:", v14, 0);
    objc_autoreleasePoolPop(v13);
    v16 = 0;
    v23 = 0;
    if (a6)
    {
      v17 = objc_msgSend(v15, "size");
      v18 = objc_msgSend(v15, "alignment");
      if (v18)
        v17 = (v18 + v17 - 1) / v18 * v18;
      v16 = _ImageIO_Malloc(v17, v18, &v23, (uint64_t)kImageMalloc_ASTC_Data[0], 0, 0, 0);
      if (!v16)
        goto LABEL_16;
    }
    v19 = 0;
    if (a2 > 203)
    {
      if (a2 == 212)
        goto LABEL_13;
      if (a2 != 204)
        goto LABEL_14;
    }
    else if (a2 != 186)
    {
      if (a2 != 194)
      {
LABEL_14:
        v20 = operator new();
        v21 = v23;
        *(_QWORD *)v20 = &off_1E1BB3178;
        *(_QWORD *)(v20 + 8) = a3;
        *(_QWORD *)(v20 + 16) = a4;
        *(_QWORD *)(v20 + 24) = v19;
        *(_QWORD *)(v20 + 32) = a5;
        *(_QWORD *)(v20 + 40) = v16;
        *(_QWORD *)(v20 + 48) = v21;
        *(_QWORD *)(v20 + 56) = v15;
        *(_BYTE *)(v20 + 64) = 0;
        v22 = *((_QWORD *)this + 1);
        *((_QWORD *)this + 1) = v20;
        if (v22)
          (*(void (**)(uint64_t))(*(_QWORD *)v22 + 8))(v22);
LABEL_16:

        return;
      }
LABEL_13:
      v19 = 8;
      goto LABEL_14;
    }
    v19 = 4;
    goto LABEL_14;
  }
}

void sub_187E45DC8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 + 8);
  *(_QWORD *)(v1 + 8) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  _Unwind_Resume(exception_object);
}

BOOL ASTCTwiddler::finalized(ASTCTwiddler *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 1);
  return v1 && *(_BYTE *)(v1 + 64) != 0;
}

void ASTCTwiddler::decodeAndCopyFromLinearData(ASTCTwiddler *this, unsigned __int8 *a2, size_t a3, size_t a4, int a5)
{
  ASTCTwiddler::ASTCTwiddlerImpl *v5;

  v5 = (ASTCTwiddler::ASTCTwiddlerImpl *)*((_QWORD *)this + 1);
  if (v5)
    ASTCTwiddler::ASTCTwiddlerImpl::decodeAndCopyFromLinearDataImp(v5, a2, a3, a4, a5);
}

const char *ASTCTwiddler::finalizeTwiddling(ASTCTwiddler *this)
{
  const char *result;

  result = (const char *)*((_QWORD *)this + 1);
  if (result)
    return ASTCTwiddler::ASTCTwiddlerImpl::finalizeTwiddlingImp(result);
  return result;
}

uint64_t ASTCTwiddler::twiddledDataSize(ASTCTwiddler *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 1);
  if (v1)
    return objc_msgSend(*(id *)(v1 + 56), "size");
  else
    return 0;
}

void ASTCTwiddler::ASTCTwiddlerImpl::decodeAndCopyFromLinearDataImp(ASTCTwiddler::ASTCTwiddlerImpl *this, unsigned __int8 *a2, size_t a3, size_t size, int a5)
{
  uint64_t v6;
  uint8_t *v11;
  uint64_t v12;
  uint64_t v13;
  compression_status v14;
  compression_status v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD v19[6];
  compression_stream stream;

  if (*((_QWORD *)this + 1) >> a5 <= 1uLL)
    v6 = 1;
  else
    v6 = *((_QWORD *)this + 1) >> a5;
  if (size)
  {
    memset(&stream, 0, sizeof(stream));
    v11 = (uint8_t *)malloc_type_malloc(size, 0x3323123uLL);
    *gCrashMessage = 0;
    snprintf(gCrashMessage, 0x200uLL, "LZFSE->TW_ASTC:  src: %p (%ld)   tmp: %p (%ld)   dst: %p (%ld)   (%ldx%ld)  rb: %ld\n", a2, a3, v11, size, *((const void **)this + 5), *((_QWORD *)this + 6), *((_QWORD *)this + 1), *((_QWORD *)this + 2), size);
    qword_1ECDD8318 = gCrashMessage;
    CHECK_FIRST_BYTE_OF_IMAGEBLOCK(a2);
    CHECK_LAST_BYTE_OF_IMAGEBLOCK(a2);
    if (compression_stream_init(&stream, COMPRESSION_STREAM_DECODE, COMPRESSION_LZFSE) == COMPRESSION_STATUS_OK)
    {
      stream.src_ptr = a2;
      stream.src_size = a3;
      objc_msgSend(*((id *)this + 7), "initializeTextureMemory:", *((_QWORD *)this + 5));
      v12 = 0;
      v13 = a5;
      do
      {
        stream.dst_ptr = v11;
        stream.dst_size = size;
        v14 = compression_stream_process(&stream, 0);
        if (v14 == COMPRESSION_STATUS_ERROR)
          break;
        v15 = v14;
        v16 = (void *)*((_QWORD *)this + 7);
        v17 = *((_QWORD *)this + 5);
        v18 = *((_QWORD *)this + 3);
        v19[0] = 0;
        v19[1] = v12;
        v19[2] = 0;
        v19[3] = v6;
        v19[4] = v18;
        v19[5] = 1;
        objc_msgSend(v16, "copyFromLinearBytes:linearOffset:linearBytesPerRow:linearBytesPerImage:toTextureMemory:textureSlice:textureLevel:textureRegion:", v11, 0, size, 0, v17, 0, v13, v19);
        v12 += *((_QWORD *)this + 3);
      }
      while (v15 != COMPRESSION_STATUS_END);
      compression_stream_destroy(&stream);
    }
    qword_1ECDD8318 = 0;
    free(v11);
  }
}

const char *ASTCTwiddler::ASTCTwiddlerImpl::finalizeTwiddlingImp(const char *this)
{
  uint64_t v1;

  if (!this[64])
  {
    v1 = (uint64_t)this;
    if (*((_QWORD *)this + 5))
    {
      objc_msgSend(*((id *)this + 7), "finalizeTextureMemory:");
      this = ImageIO_make_read_only(*(_QWORD *)(v1 + 40), *(_QWORD *)(v1 + 48));
    }
    *(_BYTE *)(v1 + 64) = 1;
  }
  return this;
}

const char *ImageIO_make_read_only(mach_vm_address_t a1, mach_vm_size_t a2)
{
  const char *result;
  mach_vm_address_t v5;
  unint64_t *v6;

  pthread_mutex_lock(&gImageIOMemoryHashLock);
  if (gMemoryHashCreateOnce == -1)
  {
    if (a2)
      goto LABEL_4;
    goto LABEL_3;
  }
  dispatch_once(&gMemoryHashCreateOnce, &__block_literal_global_30);
  if (!a2)
  {
LABEL_3:
    v5 = ~a1;
    v6 = &v5;
    a2 = std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>((uint64_t **)(gIIOMemoryHash + 8), &v5, (uint64_t)&std::piecewise_construct, (uint64_t **)&v6)[5];
  }
LABEL_4:
  mach_vm_protect(*MEMORY[0x1E0C83DA0], a1, a2, 1, 1);
  result = (const char *)pthread_mutex_unlock(&gImageIOMemoryHashLock);
  if ((gIIODebugFlags & 0x80000000000) != 0)
    return ImageIOLog("D   %s:%d mach_vm_protect: %p\n", "ImageIO_make_read_only", 640, (const void *)a1);
  return result;
}

uint64_t ASTCTwiddler::twiddledData(ASTCTwiddler *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 1);
  if (v1 && *(_BYTE *)(v1 + 64))
    return *(_QWORD *)(v1 + 40);
  else
    return 0;
}

CFTypeRef ASTCTextureImp::createTwiddledDataFromTwiddled(CFTypeRef this, IIOImageReadSession *a2)
{
  uint64_t v2;
  uint64_t v3;
  const void *v5;
  int v6;
  uint64_t v7;

  v2 = (uint64_t)this;
  v3 = *((_QWORD *)this + 15);
  if (v3
    || (*((_QWORD *)this + 15) = IIOImageReadSession::retainBytePointer(a2, (const __CFData **)this + 16, 1),
        v5 = (const void *)IIOImageSource::cf(a2),
        *(_QWORD *)(v2 + 136) = v5,
        this = CFRetain(v5),
        (v3 = *(_QWORD *)(v2 + 120)) != 0))
  {
    v6 = 0;
    v7 = v3 + *(_QWORD *)(v2 + 112);
  }
  else
  {
    this = (CFTypeRef)_cg_jpeg_mem_term("createTwiddledDataFromTwiddled", 952, "*** Can't access image data\n");
    v7 = 0;
    v6 = -50;
  }
  *(_QWORD *)(v2 + 80) = v7;
  *(_DWORD *)(v2 + 232) = v6;
  return this;
}

const char *IIOReadPlugin::ImageBlockSetReleaseInfo(const char *this, void *a2)
{
  if ((gIIODebugFlags & 0xC00) != 0)
    return IIO_ImageBlockSetReleased(this);
  return this;
}

uint64_t IIOReadPlugin::setupImageProviderCallbackV2(uint64_t a1, CFDictionaryRef *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  CGColorSpace *SourceGeomColorSpace;

  v8 = IIOReadPlugin::prepareGeometry(a1, a2);
  if (!(_DWORD)v8)
  {
    IIOImagePlus::setImageBlockProc(*(_QWORD *)(a1 + 16), (CFTypeRef *)a2, (const void *)2, a3, a4, 0, 0, (uint64_t)IIOReadPlugin::ReleaseInfo);
    SourceGeomColorSpace = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(*(IIOImagePlus **)(a1 + 16));
    *(_DWORD *)(a1 + 320) = CGColorSpaceGetModel(SourceGeomColorSpace);
  }
  return v8;
}

IIODictionary *IIOImageSource::getPropertiesAtIndexInternal(IIOImageSource *this, unint64_t a2, const __CFDictionary **a3)
{
  const void *ImagePlus;
  IIOImagePlus *v7;
  IIODictionary *Properties;
  uint64_t Metadata;
  const __CFDictionary **ImageMetadataAtIndex;
  uint64_t v11;
  IIODictionary *v12;
  const __CFDictionary *ObjectForKey;
  unsigned int Uint32ForKey;
  int v15;
  _BYTE v17[24];

  if (!IIOImageSource::bindToReader(this))
    return 0;
  ImagePlus = IIOImageSource::makeImagePlus(this, a2, a3);
  if (ImagePlus)
  {
    v7 = (IIOImagePlus *)*((_QWORD *)ImagePlus + 3);
    Properties = (IIODictionary *)IIOImagePlus::getProperties(v7);
    Metadata = IIOImagePlus::getMetadata(v7);
    if (!Properties)
    {
      _cg_jpeg_mem_term("getPropertiesAtIndexInternal", 1733, "*** iPlus->getProperties() is nil\n");
      return Properties;
    }
    ImageMetadataAtIndex = (const __CFDictionary **)Metadata;
  }
  else
  {
    Properties = (IIODictionary *)IIOImageSource::getImagePropertiesAtIndex(this, a2);
    if (!Properties)
    {
      _cg_jpeg_mem_term("getPropertiesAtIndexInternal", 1738, "*** this->getImagePropertiesAtIndex() is nil\n");
      return Properties;
    }
    ImageMetadataAtIndex = (const __CFDictionary **)IIOImageSource::getImageMetadataAtIndex((CFArrayRef *)this, a2);
    v7 = 0;
  }
  if (IIODictionary::getBoolForKey(Properties, CFSTR("kCGSourceMetadataNotSynced")))
  {
    v11 = CGImagePropertiesCreateFromMetadata(ImageMetadataAtIndex);
    if (v11)
    {
      v12 = (IIODictionary *)v11;
      if (!CGImageMetadataGetTopLevelTag((const __CFDictionary *)ImageMetadataAtIndex, (uint64_t)CFSTR("http://ns.apple.com/ImageIO/1.0/"), (uint64_t)CFSTR("hasIIM")))
      {
        if (IIODictionary::containsKey(v12, CFSTR("{IPTC}")))
        {
          IIODictionary::removeObjectForKeyGroup(v12, CFSTR("DateCreated"), CFSTR("{IPTC}"));
          IIODictionary::removeObjectForKeyGroup(v12, CFSTR("TimeCreated"), CFSTR("{IPTC}"));
          IIODictionary::removeObjectForKeyGroup(v12, CFSTR("DigitalCreationDate"), CFSTR("{IPTC}"));
          IIODictionary::removeObjectForKeyGroup(v12, CFSTR("DigitalCreationTime"), CFSTR("{IPTC}"));
          if (!CGImageMetadataGetTopLevelTag((const __CFDictionary *)ImageMetadataAtIndex, (uint64_t)CFSTR("http://ns.apple.com/ImageIO/1.0/"), (uint64_t)CFSTR("hasXMP")))
          {
            IIODictionary::removeObjectForKeyGroup(v12, CFSTR("CopyrightNotice"), CFSTR("{IPTC}"));
            IIODictionary::removeObjectForKeyGroup(v12, CFSTR("Caption/Abstract"), CFSTR("{IPTC}"));
            IIODictionary::removeObjectForKeyGroup(v12, CFSTR("Byline"), CFSTR("{IPTC}"));
          }
        }
      }
      if (IIODictionary::containsKey(v12, CFSTR("{IPTC}")))
      {
        ObjectForKey = IIODictionary::getObjectForKey(v12, CFSTR("{IPTC}"));
        if (!CFDictionaryGetCount(ObjectForKey))
          IIODictionary::removeObjectForKey(v12, CFSTR("{IPTC}"));
      }
      IIODictionary::appendDictionary(Properties, (const __CFDictionary **)v12);
      (*(void (**)(IIODictionary *))(*(_QWORD *)v12 + 8))(v12);
    }
    IIODictionary::removeObjectForKey(Properties, CFSTR("kCGSourceMetadataNotSynced"));
  }
  if (!a3)
  {
    IIODictionary::removeObjectForKey(Properties, CFSTR("_RenderingDepth"));
LABEL_32:
    IIODictionary::removeObjectForKeyGroup(Properties, CFSTR("JPEGInterchangeFormat"), CFSTR("{Exif}"));
    IIODictionary::removeObjectForKeyGroup(Properties, CFSTR("JPEGInterchangeFormatLength"), CFSTR("{Exif}"));
    goto LABEL_33;
  }
  if (IIODictionary::containsKey((IIODictionary *)a3, CFSTR("kCGImageSourceAddRenderingInformation"))
    && IIODictionary::getBoolForKey((IIODictionary *)a3, CFSTR("kCGImageSourceAddRenderingInformation"))
    && IIODictionary::containsKey(Properties, CFSTR("Depth")))
  {
    Uint32ForKey = IIODictionary::getUint32ForKey(Properties, CFSTR("Depth"));
    if (Uint32ForKey <= 8)
      v15 = 8;
    else
      v15 = Uint32ForKey;
    IIONumber::IIONumber((IIONumber *)v17, v15);
    IIODictionary::setObjectForKey((uint64_t)Properties, (uint64_t)v17, CFSTR("_RenderingDepth"));
    IIONumber::~IIONumber((IIONumber *)v17);
  }
  else
  {
    IIODictionary::removeObjectForKey(Properties, CFSTR("_RenderingDepth"));
  }
  if (!IIODictionary::containsKey((IIODictionary *)a3, CFSTR("kCGImageSourceAddThumbnailInformation"))
    || !IIODictionary::getBoolForKey((IIODictionary *)a3, CFSTR("kCGImageSourceAddThumbnailInformation")))
  {
    goto LABEL_32;
  }
LABEL_33:
  if (IIODictionary::containsKey(Properties, CFSTR("kCGImageSourceAddThumbnailInformation")))
    IIODictionary::removeObjectForKey(Properties, CFSTR("XMP_FROM_SIDECAR"));
  IIODictionary::removeObjectForKeyGroup(Properties, CFSTR("iptcComputedMD5"), CFSTR("{IPTC}"));
  IIODictionary::removeObjectForKeyGroup(Properties, CFSTR("iptcPhotoshopMD5"), CFSTR("{IPTC}"));
  if (v7 && IIOImagePlus::getStatus(v7) == -1)
    IIOImagePlus::setStatus((uint64_t)v7, kCGImageStatusComplete);
  return Properties;
}

void sub_187E466AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

void IIODictionary::removeObjectForKeyGroup(IIODictionary *this, const __CFString *a2, const __CFString *a3)
{
  __CFDictionary *GroupForKey;

  GroupForKey = IIODictionary::getGroupForKey(this, a3, 0);
  if (a2)
  {
    if (GroupForKey)
      CFDictionaryRemoveValue(GroupForKey, a2);
  }
}

void IIODictionary::setObjectForKeyGroup(IIODictionary *a1, uint64_t a2, const void *a3, const __CFString *a4)
{
  __CFDictionary *GroupForKey;

  if (a3 && a4 && *((_QWORD *)a1 + 1))
  {
    GroupForKey = IIODictionary::getGroupForKey(a1, a4, 1);
    if (GroupForKey)
      CFDictionarySetValue(GroupForKey, a3, *(const void **)(a2 + 16));
  }
}

const __CFDictionary *IIODictionary::getObjectForKeyGroup(IIODictionary *this, const __CFString *a2, const __CFString *a3)
{
  const __CFDictionary *result;

  result = IIODictionary::getGroupForKey(this, a3, 0);
  if (result)
    return (const __CFDictionary *)CFDictionaryGetValue(result, a2);
  return result;
}

CFMutableDictionaryRef IIODictionary::getGroupForKey(IIODictionary *this, const __CFString *a2, int a3)
{
  CFMutableDictionaryRef Mutable;
  const __CFDictionary *v5;
  __CFDictionary *Value;
  CFTypeID v9;
  CFTypeID v10;

  Mutable = 0;
  if (a2)
  {
    v5 = (const __CFDictionary *)*((_QWORD *)this + 1);
    if (v5)
    {
      Value = (__CFDictionary *)CFDictionaryGetValue(v5, a2);
      Mutable = Value;
      if (!Value || (v9 = CFGetTypeID(Value), v9 == CFNullGetTypeID()))
      {
        if (a3)
        {
          Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 1), a2, Mutable);
          CFRelease(Mutable);
        }
        if (Mutable)
        {
          v10 = CFGetTypeID(Mutable);
          if (v10 == CFNullGetTypeID())
            return 0;
        }
      }
    }
  }
  return Mutable;
}

void IIODictionary::removeObjectForKey(IIODictionary *this, const __CFString *a2)
{
  __CFDictionary *v2;

  if (a2)
  {
    v2 = (__CFDictionary *)*((_QWORD *)this + 1);
    if (v2)
      CFDictionaryRemoveValue(v2, a2);
  }
}

uint64_t IIOImagePlus::getStatus(IIOImagePlus *this)
{
  unsigned int v1;

  v1 = *((_DWORD *)this + 34);
  if (v1 == -6)
    return 4294967291;
  else
    return v1;
}

uint64_t IIOImageSource::extractOptions(IIOImageSource *this, IIODictionary *a2)
{
  _BOOL4 BoolForKey;
  uint64_t result;
  IIO_ReaderHandler *ObjectForKey;
  const __CFString *v7;
  IIO_ReaderHandler *ReaderHandler;
  IIO_Reader *v9;
  const char *v10;
  _BYTE v11[24];

  if (!*((_QWORD *)this + 7))
  {
    ObjectForKey = IIODictionary::getObjectForKey(a2, CFSTR("kCGImageSourceTypeIdentifierHint"));
    if (ObjectForKey)
    {
      v7 = (const __CFString *)ObjectForKey;
      ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(ObjectForKey);
      v9 = IIO_ReaderHandler::readerForUTType(ReaderHandler, v7);
      *((_QWORD *)this + 9) = v9;
      if (v9)
      {
        *((_QWORD *)this + 7) = CFRetain(v7);
        *((_BYTE *)this + 64) = IIODictionary::getBoolForKey(a2, CFSTR("kCGImageSourceFailForDataNotMatchingHint"));
      }
      else
      {
        IIOString::IIOString((IIOString *)v11, v7);
        v10 = (const char *)IIOString::utf8String((IIOString *)v11);
        LogError("extractOptions", 211, "*** ERROR: unknown hint identifier 'kCGImageSourceTypeIdentifierHint:%s' -- ignoring...\n", v10);
        IIOString::~IIOString((IIOString *)v11);
      }
    }
  }
  if ((IIODictionary::containsKey(a2, CFSTR("kCGImageSourceShouldMemoryMap")) & 1) != 0)
  {
    BoolForKey = IIODictionary::getBoolForKey(a2, CFSTR("kCGImageSourceShouldMemoryMap"));
    *((_BYTE *)this + 48) = BoolForKey;
    if (!BoolForKey)
      goto LABEL_8;
  }
  else if (!*((_BYTE *)this + 48))
  {
    goto LABEL_8;
  }
  if (IIODictionary::containsKey(a2, CFSTR("kCGImageSourceMemoryMapAsShared")))
    *((_BYTE *)this + 49) = 1;
LABEL_8:
  *((_BYTE *)this + 50) = 1;
  if (IIODictionary::containsKey(a2, CFSTR("kCGImageSourceRespectHEIFFileOrder")))
    *((_BYTE *)this + 50) = IIODictionary::getBoolForKey(a2, CFSTR("kCGImageSourceRespectHEIFFileOrder"));
  *((_BYTE *)this + 51) = -1;
  if (IIODictionary::containsKey(a2, CFSTR("kCGImageSourceIgnoreJPEGAuxImages")))
    *((_BYTE *)this + 51) = IIODictionary::getBoolForKey(a2, CFSTR("kCGImageSourceIgnoreJPEGAuxImages"));
  *((_BYTE *)this + 52) = 1;
  if (IIODictionary::containsKey(a2, CFSTR("kCGImageSourcePreferHEIFCollection")))
    *((_BYTE *)this + 52) = !IIODictionary::getBoolForKey(a2, CFSTR("kCGImageSourcePreferHEIFCollection"));
  *((_QWORD *)this + 14) = 0;
  if (IIODictionary::containsKey(a2, CFSTR("kCGImageSourceForceUseServer")))
    result = IIODictionary::getBoolForKey(a2, CFSTR("kCGImageSourceForceUseServer"));
  else
    result = 255;
  *((_BYTE *)this + 53) = result;
  return result;
}

void sub_187E46A88(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void CopyTiffPropertiesToRoot(IIODictionary *this, CGImageMetadata *a2)
{
  const __CFDictionary *ObjectForKeyGroup;
  const __CFDictionary *v5;
  BOOL v6;
  BOOL v7;
  const __CFDictionary *v8;
  CFStringRef IPTCDateFromExifDateTime;
  CFStringRef v10;
  IIODictionary *v11;
  CFStringRef v12;
  const __CFString *v13;
  const __CFDictionary *v14;
  CFStringRef IPTCTimeFromExifDateTime;
  const __CFDictionary *v16;
  IIODictionary *v17;
  uint64_t v18;
  const void *v19;
  uint64_t v20;
  const void *v21;
  const __CFDictionary *ObjectForKey;
  const __CFDictionary *v23;
  __CFDictionary *v24;
  IIODictionary *v25;
  unsigned int Uint32ForKey;
  int v27;
  unsigned __int16 v28;
  unsigned int v29;
  double DoubleForKey;
  int v32;
  unsigned int v33;
  double v34;
  double v35;
  IIONumber *v36;
  const __CFString *StringValueWithPath;
  float v38;
  float v39;
  _BYTE v40[24];
  _BYTE v41[24];
  _BYTE v42[24];
  _BYTE v43[24];
  _BYTE v44[24];
  _BYTE v45[24];
  _BYTE v46[16];
  void *value;
  const __CFDictionary *v48;
  uint64_t v49;
  uint64_t v50;

  if (this && a2)
  {
    if (!IIODictionary::getBoolForKey(this, CFSTR("needsPostProcessing")))
      goto LABEL_33;
    IIODictionary::removeObjectForKey(this, CFSTR("needsPostProcessing"));
    ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup(this, CFSTR("DateCreated"), CFSTR("{IPTC}"));
    v5 = IIODictionary::getObjectForKeyGroup(this, CFSTR("TimeCreated"), CFSTR("{IPTC}"));
    if (ObjectForKeyGroup)
      v6 = v5 == 0;
    else
      v6 = 0;
    if (v6)
    {
      v14 = IIODictionary::getObjectForKeyGroup(this, CFSTR("DateTimeOriginal"), CFSTR("{Exif}"));
      IPTCTimeFromExifDateTime = CreateIPTCTimeFromExifDateTime(v14);
      if (!IPTCTimeFromExifDateTime)
      {
LABEL_19:
        v16 = (const __CFDictionary *)*((_QWORD *)a2 + 6);
        if (v16)
        {
          v48 = 0;
          v49 = 0;
          v50 = 0;
          v17 = IIODictionary::IIODictionary((IIODictionary *)&v48, v16, 1);
          v18 = CGImageMetadataCreateFromLegacyProps(v17);
          v19 = (const void *)v18;
          if (v18)
          {
            metadataSetSource(v18, 34);
            CGImageMetadataMerge((uint64_t)a2, (uint64_t)v19, 0);
            CFRelease(v19);
          }
          IIODictionary::appendDictionary(this, &v48);
          IIODictionary::~IIODictionary((IIODictionary *)&v48);
        }
        v20 = CGImageMetadataCreateFromLegacyProps(this);
        if (v20)
        {
          v21 = (const void *)v20;
          CGImageMetadataMerge((uint64_t)a2, v20, 0);
          CFRelease(v21);
        }
        ObjectForKey = IIODictionary::getObjectForKey(this, CFSTR("{XMP}"));
        if (ObjectForKey)
        {
          CGImageMetadataMerge((uint64_t)a2, (uint64_t)ObjectForKey, 0);
          IIODictionary::removeObjectForKey(this, CFSTR("{XMP}"));
        }
        copyRenderingProperties(this, a2);
        if (IIODictionary::containsKeyGroup(this, CFSTR("Orientation"), CFSTR("{TIFF}"))
          && IIODictionary::getUint32ForKeyGroup(this, CFSTR("Orientation"), CFSTR("{TIFF}")) - 9 <= 0xFFFFFFF7)
        {
          IIODictionary::removeObjectForKeyGroup(this, CFSTR("Orientation"), CFSTR("{TIFF}"));
        }
        reconcileSubsecTimes(a2);
        reconcileGPSTimeStamp(a2);
        IIODictionary::setObjectForKey(this, (const void *)*MEMORY[0x1E0C9AE50], CFSTR("kCGSourceMetadataNotSynced"));
        if (IIODictionary::containsKey(this, CFSTR("{IPTC}")))
        {
          v23 = IIODictionary::getObjectForKey(this, CFSTR("{IPTC}"));
          if (!CFDictionaryGetCount(v23))
            IIODictionary::removeObjectForKey(this, CFSTR("{IPTC}"));
        }
        goto LABEL_33;
      }
      v10 = IPTCTimeFromExifDateTime;
      v11 = this;
      v12 = v10;
      v13 = CFSTR("TimeCreated");
    }
    else
    {
      if (ObjectForKeyGroup)
        v7 = 1;
      else
        v7 = v5 == 0;
      if (v7)
        goto LABEL_19;
      v8 = IIODictionary::getObjectForKeyGroup(this, CFSTR("DateTimeOriginal"), CFSTR("{Exif}"));
      IPTCDateFromExifDateTime = CreateIPTCDateFromExifDateTime(v8);
      if (!IPTCDateFromExifDateTime)
        goto LABEL_19;
      v10 = IPTCDateFromExifDateTime;
      v11 = this;
      v12 = v10;
      v13 = CFSTR("DateCreated");
    }
    IIODictionary::setObjectForKeyGroup(v11, v12, v13, CFSTR("{IPTC}"));
    CFRelease(v10);
    goto LABEL_19;
  }
  if (!this)
    return;
LABEL_33:
  if (!IIODictionary::containsKey(this, CFSTR("{TIFF}")))
    return;
  v24 = IIODictionary::getObjectForKey(this, CFSTR("{TIFF}"));
  v48 = 0;
  v49 = 0;
  v50 = 0;
  v25 = IIODictionary::IIODictionary((IIODictionary *)&v48, v24);
  if (IIODictionary::containsKey(v25, CFSTR("Orientation")))
  {
    Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)&v48, CFSTR("Orientation"));
    if (Uint32ForKey - 9 < 0xFFFFFFF8)
      v27 = 1;
    else
      v27 = Uint32ForKey;
    IIONumber::IIONumber((IIONumber *)v46, v27);
    IIODictionary::setObjectForKey((IIODictionary *)&v48, value, CFSTR("Orientation"));
    IIONumber::~IIONumber((IIONumber *)v46);
    IIONumber::IIONumber((IIONumber *)v46, v27);
    IIODictionary::setObjectForKey(this, value, CFSTR("Orientation"));
    IIONumber::~IIONumber((IIONumber *)v46);
  }
  if (IIODictionary::containsKey((IIODictionary *)&v48, CFSTR("ResolutionUnit")))
    v28 = (unsigned __int16)IIODictionary::getUint32ForKey((IIODictionary *)&v48, CFSTR("ResolutionUnit"));
  else
    v28 = 0;
  v29 = IIODictionary::containsKey((IIODictionary *)&v48, CFSTR("XResolution"));
  if (!v29)
  {
    v32 = 0;
    goto LABEL_49;
  }
  DoubleForKey = IIODictionary::getDoubleForKey((IIODictionary *)&v48, CFSTR("XResolution"));
  if (DoubleForKey <= 0.0 || (*(_QWORD *)&DoubleForKey & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
  {
    v32 = 1;
LABEL_49:
    DoubleForKey = 72.0;
    goto LABEL_50;
  }
  v32 = 0;
LABEL_50:
  v33 = IIODictionary::containsKey((IIODictionary *)&v48, CFSTR("YResolution"));
  if (v33)
  {
    v34 = IIODictionary::getDoubleForKey((IIODictionary *)&v48, CFSTR("YResolution"));
    if (v34 <= 0.0)
      goto LABEL_54;
    v35 = v34;
    if ((*(_QWORD *)&v34 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL || v32)
      goto LABEL_54;
  }
  else
  {
    v35 = 72.0;
    v34 = DoubleForKey;
    if (v32)
    {
LABEL_54:
      IIONumber::IIONumber((IIONumber *)v45, 72.0);
      IIODictionary::setObjectForKey((uint64_t)&v48, (uint64_t)v45, CFSTR("XResolution"));
      IIONumber::~IIONumber((IIONumber *)v45);
      IIONumber::IIONumber((IIONumber *)v44, 72.0);
      IIODictionary::setObjectForKey((uint64_t)&v48, (uint64_t)v44, CFSTR("YResolution"));
      IIONumber::~IIONumber((IIONumber *)v44);
      v35 = 72.0;
      v34 = 72.0;
      goto LABEL_55;
    }
  }
  if (v29)
  {
    if ((v33 & 1) == 0)
    {
      StringValueWithPath = (const __CFString *)CGImageMetadataGetStringValueWithPath(a2, 0, CFSTR("tiff:YResolution"));
      if (StringValueWithPath && CFStringHasSuffix(StringValueWithPath, CFSTR("/0")))
        v35 = 72.0;
      else
        v35 = DoubleForKey;
    }
    v34 = DoubleForKey;
    goto LABEL_55;
  }
  if (v33)
  {
LABEL_55:
    if (v28 == 3)
    {
      IIONumber::IIONumber((IIONumber *)v43, round(v34 * 2.54));
      IIODictionary::setObjectForKey((uint64_t)this, (uint64_t)v43, CFSTR("DPIWidth"));
      IIONumber::~IIONumber((IIONumber *)v43);
      IIONumber::IIONumber((IIONumber *)v42, round(v35 * 2.54));
      v36 = (IIONumber *)v42;
      IIODictionary::setObjectForKey((uint64_t)this, (uint64_t)v42, CFSTR("DPIHeight"));
    }
    else
    {
      v38 = v34;
      IIONumber::IIONumber((IIONumber *)v41, v38);
      IIODictionary::setObjectForKey((uint64_t)this, (uint64_t)v41, CFSTR("DPIWidth"));
      IIONumber::~IIONumber((IIONumber *)v41);
      v39 = v35;
      IIONumber::IIONumber((IIONumber *)v40, v39);
      v36 = (IIONumber *)v40;
      IIODictionary::setObjectForKey((uint64_t)this, (uint64_t)v40, CFSTR("DPIHeight"));
    }
    IIONumber::~IIONumber(v36);
  }
  IIODictionary::~IIODictionary((IIODictionary *)&v48);
}

void sub_187E470C0(_Unwind_Exception *a1)
{
  uint64_t v1;

  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 120));
  _Unwind_Resume(a1);
}

const __CFDictionary *IIODictionary::containsKeyGroup(IIODictionary *this, const __CFString *a2, const __CFString *a3)
{
  const __CFDictionary *result;

  result = IIODictionary::getGroupForKey(this, a3, 0);
  if (result)
    return (const __CFDictionary *)(CFDictionaryGetValue(result, a2) != 0);
  return result;
}

void copyRenderingProperties(IIODictionary *a1, const __CFDictionary *a2)
{
  const __CFString *TopLevelTag;
  const __CFString *v5;
  const __CFString *v6;
  const __CFString *v7;
  _BYTE v8[24];
  _BYTE v9[24];
  _BYTE v10[24];
  _BYTE v11[24];
  double v12;
  SInt32 v13;

  v13 = 0;
  v12 = 0.0;
  TopLevelTag = (const __CFString *)CGImageMetadataGetTopLevelTag(a2, (uint64_t)CFSTR("http://ns.adobe.com/tiff/1.0/"), (uint64_t)CFSTR("Orientation"));
  if (TopLevelTag && GetIntegerFromPropertyValue(TopLevelTag, &v13))
  {
    IIONumber::IIONumber((IIONumber *)v11, v13);
    IIODictionary::setObjectForKeyGroup(a1, (uint64_t)v11, CFSTR("Orientation"), CFSTR("{TIFF}"));
    IIONumber::~IIONumber((IIONumber *)v11);
  }
  v5 = (const __CFString *)CGImageMetadataGetTopLevelTag(a2, (uint64_t)CFSTR("http://ns.adobe.com/tiff/1.0/"), (uint64_t)CFSTR("XResolution"));
  if (v5 && GetDoubleFromPropertyValue(v5, &v12))
  {
    IIONumber::IIONumber((IIONumber *)v10, v12);
    IIODictionary::setObjectForKeyGroup(a1, (uint64_t)v10, CFSTR("XResolution"), CFSTR("{TIFF}"));
    IIONumber::~IIONumber((IIONumber *)v10);
  }
  v6 = (const __CFString *)CGImageMetadataGetTopLevelTag(a2, (uint64_t)CFSTR("http://ns.adobe.com/tiff/1.0/"), (uint64_t)CFSTR("YResolution"));
  if (v6 && GetDoubleFromPropertyValue(v6, &v12))
  {
    IIONumber::IIONumber((IIONumber *)v9, v12);
    IIODictionary::setObjectForKeyGroup(a1, (uint64_t)v9, CFSTR("YResolution"), CFSTR("{TIFF}"));
    IIONumber::~IIONumber((IIONumber *)v9);
  }
  v7 = (const __CFString *)CGImageMetadataGetTopLevelTag(a2, (uint64_t)CFSTR("http://ns.adobe.com/tiff/1.0/"), (uint64_t)CFSTR("ResolutionUnit"));
  if (v7)
  {
    if (GetIntegerFromPropertyValue(v7, &v13))
    {
      IIONumber::IIONumber((IIONumber *)v8, v13);
      IIODictionary::setObjectForKeyGroup(a1, (uint64_t)v8, CFSTR("ResolutionUnit"), CFSTR("{TIFF}"));
      IIONumber::~IIONumber((IIONumber *)v8);
    }
  }
}

void sub_187E47334(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  IIONumber::~IIONumber((IIONumber *)&a9);
  _Unwind_Resume(a1);
}

void reconcileSubsecTimes(const __CFDictionary *a1)
{
  const __CFDictionary *TopLevelTag;
  const __CFDictionary *v3;
  uint64_t v4;
  BOOL v5;
  const __CFString *Value;
  const __CFString *SubsecTimeFromXMPDateTime;
  const __CFString *v8;
  const void *v9;
  const void *v10;
  const __CFString *v11;
  uint64_t v12;
  const __CFString *XMPDateFromXMPDateTimeAndSubsecTime;
  const __CFDictionary *v14;
  const __CFDictionary *v15;
  uint64_t v16;
  BOOL v17;
  const __CFString *v18;
  const __CFString *v19;
  const __CFString *v20;
  const void *v21;
  const void *v22;
  const __CFString *v23;
  uint64_t v24;
  const __CFString *v25;
  const __CFDictionary *v26;
  const __CFDictionary *v27;
  uint64_t v28;
  BOOL v29;
  const __CFString *v30;
  const __CFString *v31;
  const __CFString *v32;
  const void *v33;
  const void *v34;
  const __CFString *v35;
  uint64_t v36;
  const __CFString *v37;

  TopLevelTag = CGImageMetadataGetTopLevelTag(a1, (uint64_t)CFSTR("http://ns.adobe.com/exif/1.0/"), (uint64_t)CFSTR("SubsecTimeOriginal"));
  v3 = CGImageMetadataGetTopLevelTag(a1, (uint64_t)CFSTR("http://ns.adobe.com/photoshop/1.0/"), (uint64_t)CFSTR("DateCreated"));
  v4 = (uint64_t)v3;
  if (v3)
    v5 = TopLevelTag == 0;
  else
    v5 = 1;
  if (v5)
  {
    if (!v3)
      goto LABEL_13;
    Value = (const __CFString *)CGImageMetadataTagGetValue((uint64_t)v3);
    SubsecTimeFromXMPDateTime = CreateSubsecTimeFromXMPDateTime(Value);
    if (!SubsecTimeFromXMPDateTime)
      goto LABEL_13;
    v8 = SubsecTimeFromXMPDateTime;
    v9 = (const void *)CGImageMetadataTagCreateFromImageProperty(CFSTR("{Exif}"), CFSTR("SubsecTimeOriginal"), (uint64_t)SubsecTimeFromXMPDateTime);
    if (v9)
    {
      v10 = v9;
      CGImageMetadataAddTag((uint64_t)a1, v9);
      CFRelease(v10);
    }
  }
  else
  {
    v11 = (const __CFString *)CGImageMetadataTagGetValue((uint64_t)v3);
    v12 = CGImageMetadataTagGetValue((uint64_t)TopLevelTag);
    XMPDateFromXMPDateTimeAndSubsecTime = CreateXMPDateFromXMPDateTimeAndSubsecTime(v11, v12);
    if (!XMPDateFromXMPDateTimeAndSubsecTime)
      goto LABEL_13;
    v8 = XMPDateFromXMPDateTimeAndSubsecTime;
    CGImageMetadataTagSetValue(v4, XMPDateFromXMPDateTimeAndSubsecTime);
  }
  CFRelease(v8);
LABEL_13:
  v14 = CGImageMetadataGetTopLevelTag(a1, (uint64_t)CFSTR("http://ns.adobe.com/exif/1.0/"), (uint64_t)CFSTR("SubsecTimeDigitized"));
  v15 = CGImageMetadataGetTopLevelTag(a1, (uint64_t)CFSTR("http://ns.adobe.com/xap/1.0/"), (uint64_t)CFSTR("CreateDate"));
  v16 = (uint64_t)v15;
  if (v15)
    v17 = v14 == 0;
  else
    v17 = 1;
  if (v17)
  {
    if (!v15)
      goto LABEL_25;
    v18 = (const __CFString *)CGImageMetadataTagGetValue((uint64_t)v15);
    v19 = CreateSubsecTimeFromXMPDateTime(v18);
    if (!v19)
      goto LABEL_25;
    v20 = v19;
    v21 = (const void *)CGImageMetadataTagCreateFromImageProperty(CFSTR("{Exif}"), CFSTR("SubsecTimeDigitized"), (uint64_t)v19);
    if (v21)
    {
      v22 = v21;
      CGImageMetadataAddTag((uint64_t)a1, v21);
      CFRelease(v22);
    }
  }
  else
  {
    v23 = (const __CFString *)CGImageMetadataTagGetValue((uint64_t)v15);
    v24 = CGImageMetadataTagGetValue((uint64_t)v14);
    v25 = CreateXMPDateFromXMPDateTimeAndSubsecTime(v23, v24);
    if (!v25)
      goto LABEL_25;
    v20 = v25;
    CGImageMetadataTagSetValue(v16, v25);
  }
  CFRelease(v20);
LABEL_25:
  v26 = CGImageMetadataGetTopLevelTag(a1, (uint64_t)CFSTR("http://ns.adobe.com/exif/1.0/"), (uint64_t)CFSTR("SubsecTime"));
  v27 = CGImageMetadataGetTopLevelTag(a1, (uint64_t)CFSTR("http://ns.adobe.com/xap/1.0/"), (uint64_t)CFSTR("ModifyDate"));
  v28 = (uint64_t)v27;
  if (v27)
    v29 = v26 == 0;
  else
    v29 = 1;
  if (v29)
  {
    if (v27)
    {
      v30 = (const __CFString *)CGImageMetadataTagGetValue((uint64_t)v27);
      v31 = CreateSubsecTimeFromXMPDateTime(v30);
      if (v31)
      {
        v32 = v31;
        v33 = (const void *)CGImageMetadataTagCreateFromImageProperty(CFSTR("{Exif}"), CFSTR("SubsecTime"), (uint64_t)v31);
        if (v33)
        {
          v34 = v33;
          CGImageMetadataAddTag((uint64_t)a1, v33);
          CFRelease(v34);
        }
        goto LABEL_36;
      }
    }
  }
  else
  {
    v35 = (const __CFString *)CGImageMetadataTagGetValue((uint64_t)v27);
    v36 = CGImageMetadataTagGetValue((uint64_t)v26);
    v37 = CreateXMPDateFromXMPDateTimeAndSubsecTime(v35, v36);
    if (v37)
    {
      v32 = v37;
      CGImageMetadataTagSetValue(v28, v37);
LABEL_36:
      CFRelease(v32);
    }
  }
}

const __CFDictionary *XMPMappingIteratePropertiesUsingBlock(IIODictionary *this, uint64_t a2)
{
  uint64_t v4;
  const __CFDictionary *result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __CFString ***v10;
  uint64_t v11;
  BOOL v12;
  char v13;

  v13 = 0;
  if (this && !IIODictionary::containsKey(this, CFSTR("{Exif}")))
  {
LABEL_7:
    result = IIODictionary::containsKey(this, CFSTR("{ExifAux}"));
    if ((_DWORD)result)
    {
LABEL_8:
      v6 = 0;
      while (1)
      {
        result = (const __CFDictionary *)(*(uint64_t (**)(uint64_t, __CFString ***, char *))(a2 + 16))(a2, &legacyToXMPArrayExifAux[v6], &v13);
        if (v13)
          break;
        v6 += 5;
        if (v6 == 50)
        {
          if (this)
            goto LABEL_14;
          goto LABEL_15;
        }
      }
    }
    else if (!v13)
    {
LABEL_14:
      result = IIODictionary::containsKey(this, CFSTR("{GPS}"));
      if ((_DWORD)result)
      {
LABEL_15:
        v7 = 0;
        while (1)
        {
          result = (const __CFDictionary *)(*(uint64_t (**)(uint64_t, __CFString ***, char *))(a2 + 16))(a2, &legacyToXMPArrayGPS[v7], &v13);
          if (v13)
            break;
          v7 += 5;
          if (v7 == 160)
          {
            if (this)
              goto LABEL_21;
            goto LABEL_22;
          }
        }
      }
      else if (!v13)
      {
LABEL_21:
        result = IIODictionary::containsKey(this, CFSTR("{TIFF}"));
        if ((_DWORD)result)
        {
LABEL_22:
          v8 = 0;
          while (1)
          {
            result = (const __CFDictionary *)(*(uint64_t (**)(uint64_t, __CFString ***, char *))(a2 + 16))(a2, &legacyToXMPArrayTIFF[v8], &v13);
            if (v13)
              break;
            v8 += 5;
            if (v8 == 110)
            {
              if (this)
                goto LABEL_28;
              goto LABEL_29;
            }
          }
        }
        else if (!v13)
        {
LABEL_28:
          result = IIODictionary::containsKey(this, CFSTR("{PNG}"));
          if ((_DWORD)result)
          {
LABEL_29:
            v9 = 0;
            while (1)
            {
              result = (const __CFDictionary *)(*(uint64_t (**)(uint64_t, __CFString ***, char *))(a2 + 16))(a2, &legacyToXMPArrayPNG[v9], &v13);
              if (v13)
                break;
              v9 += 5;
              if (v9 == 30)
              {
                if (this)
                  goto LABEL_35;
                goto LABEL_36;
              }
            }
          }
          else if (!v13)
          {
LABEL_35:
            result = IIODictionary::containsKey(this, CFSTR("{IPTC}"));
            if ((_DWORD)result)
            {
LABEL_36:
              v10 = legacyToXMPArrayIPTC;
              v11 = 212;
              do
              {
                result = (const __CFDictionary *)(*(uint64_t (**)(uint64_t, __CFString ***, char *))(a2 + 16))(a2, v10, &v13);
                if (v13)
                  v12 = 1;
                else
                  v12 = v11 == 0;
                --v11;
                v10 += 5;
              }
              while (!v12);
            }
          }
        }
      }
    }
  }
  else
  {
    v4 = 0;
    while (1)
    {
      result = (const __CFDictionary *)(*(uint64_t (**)(uint64_t, __CFString ***, char *))(a2 + 16))(a2, &legacyToXMPArrayExif[v4], &v13);
      if (v13)
        break;
      v4 += 5;
      if (v4 == 400)
      {
        if (!this)
          goto LABEL_8;
        goto LABEL_7;
      }
    }
  }
  return result;
}

void sub_187E48BD8(_Unwind_Exception *a1)
{
  uint64_t v1;

  IIOString::~IIOString((IIOString *)(v1 - 200));
  _Unwind_Resume(a1);
}

const __CFDictionary *CGImageMetadataGetTopLevelTag(const __CFDictionary *result, uint64_t a2, uint64_t a3)
{
  _QWORD key[3];

  if (result)
  {
    result = (const __CFDictionary *)*((_QWORD *)result + 3);
    if (result)
    {
      key[1] = a3;
      key[2] = 0;
      key[0] = a2;
      return (const __CFDictionary *)CFDictionaryGetValue(result, key);
    }
  }
  return result;
}

const __CFDictionary *IIODictionary::containsKey(IIODictionary *this, const __CFString *a2)
{
  const __CFDictionary *result;

  result = (const __CFDictionary *)*((_QWORD *)this + 1);
  if (result)
    return (const __CFDictionary *)(CFDictionaryContainsKey(result, a2) != 0);
  return result;
}

uint64_t IIOReadPlugin::callInitialize(IIOReadPlugin *this)
{
  int v2;
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int Uint32ForKey;
  IIO_ReaderHandler *v18;
  unsigned int v19;
  IIO_ReaderHandler *ReaderHandler;
  IIO_Reader *v21;
  IIOImageSource *v22;
  IIOReadPlugin *v23;
  int v24;
  int v25;
  int v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  unsigned int v34;
  int v35;
  uint64_t v36;
  unsigned int v37;
  int v38;
  uint64_t v39;
  unsigned int v40;
  int v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  int v46;
  uint64_t v47;
  int v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  __n128 v52;
  uint64_t v54;
  int v55;
  uint64_t v56;
  int v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  unsigned int v61;
  int v62;
  uint64_t v63;
  unsigned int v64;
  int v65;
  uint64_t v66;
  unsigned int v67;
  int v68;
  int v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  int v79;
  int v80;
  uint64_t v81;
  _QWORD v82[3];
  const __CFDictionary *v83;
  uint64_t v84;
  uint64_t v85;

  v83 = 0;
  v84 = 0;
  v85 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v83);
  memset(v82, 0, sizeof(v82));
  IIODictionary::IIODictionary((IIODictionary *)v82);
  v2 = *((_DWORD *)this + 51);
  *((_QWORD *)this + 19) = v84;
  LODWORD(v3) = v2 >> 24;
  v4 = v2 << 8 >> 24;
  v79 = v2 << 16;
  v80 = v2 << 8;
  v5 = (__int16)v2 >> 8;
  if ((gIIODebugFlags & 0x30000) != 0)
  {
    v6 = MEMORY[0x1E0C80978];
    if (v2 < 0)
      v7 = __maskrune(v2 >> 24, 0x40000uLL);
    else
      v7 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v3 + 60) & 0x40000;
    if (v7)
      v8 = v3;
    else
      v8 = 46;
    if (v80 < 0)
      v9 = __maskrune(v2 << 8 >> 24, 0x40000uLL);
    else
      v9 = *(_DWORD *)(v6 + 4 * v4 + 60) & 0x40000;
    if (v9)
      v10 = v4;
    else
      v10 = 46;
    if (v79 < 0)
      v11 = __maskrune((__int16)v2 >> 8, 0x40000uLL);
    else
      v11 = *(_DWORD *)(v6 + 4 * v5 + 60) & 0x40000;
    if ((v2 << 24) <= 0x7F000000)
      v12 = *(_DWORD *)(v6 + 4 * (char)v2 + 60) & 0x40000;
    else
      v12 = __maskrune((char)v2, 0x40000uLL);
    if (v11)
      v13 = v5;
    else
      v13 = 46;
    if (v12)
      v14 = (char)v2;
    else
      v14 = 46;
    ImageIOLog("    callInitialize '%c%c%c%c' - [0x%x]\n", v8, v10, v13, v14, (_DWORD)this);
  }
  v15 = (*(uint64_t (**)(IIOReadPlugin *, _QWORD *))(*(_QWORD *)this + 88))(this, v82);
  v16 = v15;
  if (!(_DWORD)v15)
    goto LABEL_37;
  if ((_DWORD)v15 != -49)
  {
LABEL_85:
    v23 = this;
    goto LABEL_86;
  }
  Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v82, CFSTR("NEW_PLUGIN_ostype"));
  v18 = IIODictionary::getUint32ForKey((IIODictionary *)v82, CFSTR("NEW_PLUGIN_dataOffset"));
  v19 = v18;
  ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(v18);
  v21 = IIO_ReaderHandler::readerForType(ReaderHandler, Uint32ForKey);
  v22 = v21;
  if (!v21)
  {
    if (v2 < 0)
      v26 = __maskrune(v2 >> 24, 0x40000uLL);
    else
      v26 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v3 + 60) & 0x40000;
    if (v26)
      v27 = v3;
    else
      v27 = 46;
    v77 = v27;
    if (v80 < 0)
      v28 = __maskrune(v2 << 8 >> 24, 0x40000uLL);
    else
      v28 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v4 + 60) & 0x40000;
    if (v28)
      v29 = v4;
    else
      v29 = 46;
    v76 = v29;
    if (v79 < 0)
      v30 = __maskrune((__int16)v2 >> 8, 0x40000uLL);
    else
      v30 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v5 + 60) & 0x40000;
    if (v30)
      v31 = v5;
    else
      v31 = 46;
    v75 = v31;
    if ((v2 << 24) <= 0x7F000000)
      v32 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v2 + 60) & 0x40000;
    else
      v32 = __maskrune((char)v2, 0x40000uLL);
    if (v32)
      v33 = (char)v2;
    else
      v33 = 46;
    v74 = v33;
    v34 = Uint32ForKey >> 24;
    if (Uint32ForKey < 0)
      v35 = __maskrune(Uint32ForKey >> 24, 0x40000uLL);
    else
      v35 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v34 + 60) & 0x40000;
    if (v35)
      v36 = v34;
    else
      v36 = 46;
    v73 = v36;
    v37 = Uint32ForKey << 8 >> 24;
    if (Uint32ForKey << 8 < 0)
      v38 = __maskrune(Uint32ForKey << 8 >> 24, 0x40000uLL);
    else
      v38 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v37 + 60) & 0x40000;
    if (v38)
      v39 = v37;
    else
      v39 = 46;
    v72 = v39;
    v40 = (__int16)Uint32ForKey >> 8;
    if (Uint32ForKey << 16 < 0)
      v41 = __maskrune((__int16)Uint32ForKey >> 8, 0x40000uLL);
    else
      v41 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v40 + 60) & 0x40000;
    if ((Uint32ForKey << 24) <= 0x7F000000)
      v42 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)Uint32ForKey + 60) & 0x40000;
    else
      v42 = __maskrune((char)Uint32ForKey, 0x40000uLL);
    if (v41)
      v43 = v40;
    else
      v43 = 46;
    if (v42)
      v44 = (char)Uint32ForKey;
    else
      v44 = 46;
    LogError("callInitialize", 362, "*** cannot switch plugin: '%c%c%c%c' -> '%c%c%c%c'\n", v77, v76, v75, v74, v73, v72, v43, v44);
    v16 = 4294967247;
    goto LABEL_85;
  }
  (*(void (**)(IIO_Reader *, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v21 + 32))(v21, *((_QWORD *)this + 3), 0, 0, 0);
  v23 = (IIOReadPlugin *)(*(uint64_t (**)(IIOImageSource *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v22 + 248))(v22, *((_QWORD *)this + 1), 0, v19);
  *((_QWORD *)v23 + 19) = v84;
  v16 = (*(uint64_t (**)(IIOReadPlugin *, _QWORD *))(*(_QWORD *)v23 + 88))(v23, v82);
  *((_QWORD *)v23 + 9) = IIOImageSource::cf(v22);
  *((_DWORD *)v23 + 51) = IIO_Reader::osType(v22);
  (*(void (**)(IIOReadPlugin *))(*(_QWORD *)this + 8))(this);
  if ((_DWORD)v16)
  {
    v24 = *((_DWORD *)v23 + 51);
    if (v24)
    {
      if (v2 < 0)
        v25 = __maskrune(v2 >> 24, 0x40000uLL);
      else
        v25 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v3 + 60) & 0x40000;
      if (v25)
        v54 = v3;
      else
        v54 = 46;
      v78 = v54;
      if (v80 < 0)
        v55 = __maskrune(v2 << 8 >> 24, 0x40000uLL);
      else
        v55 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v4 + 60) & 0x40000;
      if (v55)
        v56 = v4;
      else
        v56 = 46;
      v81 = v56;
      if (v79 < 0)
        v57 = __maskrune((__int16)v2 >> 8, 0x40000uLL);
      else
        v57 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v5 + 60) & 0x40000;
      if (v57)
        v58 = v5;
      else
        v58 = 46;
      if ((v2 << 24) <= 0x7F000000)
        v59 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v2 + 60) & 0x40000;
      else
        v59 = __maskrune((char)v2, 0x40000uLL);
      if (v59)
        v60 = (char)v2;
      else
        v60 = 46;
      v61 = v24 >> 24;
      if (v24 < 0)
        v62 = __maskrune(v24 >> 24, 0x40000uLL);
      else
        v62 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v61 + 60) & 0x40000;
      if (v62)
        v63 = v61;
      else
        v63 = 46;
      v64 = v24 << 8 >> 24;
      if (v24 << 8 < 0)
        v65 = __maskrune(v24 << 8 >> 24, 0x40000uLL);
      else
        v65 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v64 + 60) & 0x40000;
      if (v65)
        v66 = v64;
      else
        v66 = 46;
      v67 = (__int16)v24 >> 8;
      if (v24 << 16 < 0)
        v68 = __maskrune((__int16)v24 >> 8, 0x40000uLL);
      else
        v68 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v67 + 60) & 0x40000;
      if ((v24 << 24) <= 0x7F000000)
        v69 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v24 + 60) & 0x40000;
      else
        v69 = __maskrune((char)v24, 0x40000uLL);
      if (v68)
        v70 = v67;
      else
        v70 = 46;
      if (v69)
        v71 = (char)v24;
      else
        v71 = 46;
      v52 = _cg_jpeg_mem_term("callInitialize", 384, "*** '%c%c%c%c' -> '%c%c%c%c' initialize failed - err = %d\n", v78, v81, v58, v60, v63, v66, v70, v71, v16);
LABEL_111:
      (*(void (**)(IIOReadPlugin *, __n128))(*(_QWORD *)v23 + 8))(v23, v52);
      goto LABEL_112;
    }
LABEL_86:
    if (v2 < 0)
      v45 = __maskrune(v2 >> 24, 0x40000uLL);
    else
      v45 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v3 + 60) & 0x40000;
    if (v45)
      v3 = v3;
    else
      v3 = 46;
    if (v80 < 0)
      v46 = __maskrune(v2 << 8 >> 24, 0x40000uLL);
    else
      v46 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v4 + 60) & 0x40000;
    if (v46)
      v47 = v4;
    else
      v47 = 46;
    if (v79 < 0)
      v48 = __maskrune((__int16)v2 >> 8, 0x40000uLL);
    else
      v48 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v5 + 60) & 0x40000;
    if ((v2 << 24) <= 0x7F000000)
      v49 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v2 + 60) & 0x40000;
    else
      v49 = __maskrune((char)v2, 0x40000uLL);
    if (v48)
      v50 = v5;
    else
      v50 = 46;
    if (v49)
      v51 = (char)v2;
    else
      v51 = 46;
    v52 = _cg_jpeg_mem_term("callInitialize", 386, "*** '%c%c%c%c' initialize failed - err = %d\n", v3, v47, v50, v51, v16);
    goto LABEL_111;
  }
  this = v23;
LABEL_37:
  IIOReadPlugin::postInitialize(this, &v83);
  v16 = 0;
LABEL_112:
  IIODictionary::~IIODictionary((IIODictionary *)v82);
  IIODictionary::~IIODictionary((IIODictionary *)&v83);
  return v16;
}

void sub_187E49608(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  uint64_t v26;

  IIODictionary::~IIODictionary((IIODictionary *)&a26);
  IIODictionary::~IIODictionary((IIODictionary *)(v26 - 112));
  _Unwind_Resume(a1);
}

void IIODictionary::IIODictionary(IIODictionary *this)
{
  *(_QWORD *)this = &off_1E1BACDA8;
  *((_QWORD *)this + 1) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  *((_BYTE *)this + 16) = 1;
}

uint64_t IIOReadPlugin::postInitialize(IIOReadPlugin *this, const __CFDictionary **a2)
{
  __CFDictionary **InfoPtr;
  int v6;
  unsigned int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  _QWORD v19[3];

  if (*((_DWORD *)this + 57) && *((_DWORD *)this + 58))
  {
    InfoPtr = (__CFDictionary **)IIOReadPlugin::createInfoPtr(this);
    if (IIODictionary::getCount((IIODictionary *)a2))
    {
      memset(v19, 0, sizeof(v19));
      IIODictionary::IIODictionary((IIODictionary *)v19, *InfoPtr);
      IIODictionary::appendDictionary((IIODictionary *)v19, a2);
      IIODictionary::~IIODictionary((IIODictionary *)v19);
    }
    InfoPtr[1] = this;
    (*(void (**)(IIOReadPlugin *, __CFDictionary **))(*(_QWORD *)this + 56))(this, InfoPtr);
    return 0;
  }
  else
  {
    v6 = *((_DWORD *)this + 51);
    v7 = v6 >> 24;
    v8 = MEMORY[0x1E0C80978];
    if (v6 < 0)
      v9 = __maskrune(v6 >> 24, 0x40000uLL);
    else
      v9 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v7 + 60) & 0x40000;
    if (v9)
      v10 = v7;
    else
      v10 = 46;
    v11 = v6 << 8 >> 24;
    if (v6 << 8 < 0)
      v12 = __maskrune(v6 << 8 >> 24, 0x40000uLL);
    else
      v12 = *(_DWORD *)(v8 + 4 * v11 + 60) & 0x40000;
    if (v12)
      v13 = v11;
    else
      v13 = 46;
    v14 = (__int16)v6 >> 8;
    if (v6 << 16 < 0)
      v15 = __maskrune((__int16)v6 >> 8, 0x40000uLL);
    else
      v15 = *(_DWORD *)(v8 + 4 * v14 + 60) & 0x40000;
    if (v15)
      v16 = v14;
    else
      v16 = 46;
    if ((v6 << 24) <= 0x7F000000)
      v17 = *(_DWORD *)(v8 + 4 * (char)v6 + 60) & 0x40000;
    else
      v17 = __maskrune((char)v6, 0x40000uLL);
    if (v17)
      v18 = (char)v6;
    else
      v18 = 46;
    _cg_jpeg_mem_term("postInitialize", 403, "*** '%c%c%c%c' initialize returned bad _inputGeo (%d x %d)\n", v10, v13, v16, v18, *((_DWORD *)this + 57), *((_DWORD *)this + 58));
    return 4294967246;
  }
}

void sub_187E4985C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t CGImageMetadataCreateFromLegacyProps(IIODictionary *a1)
{
  const __CFString *ObjectForKeyGroup;
  CFStringRef Copy;
  uint64_t v4;
  _QWORD v6[6];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = 0;
  if (a1)
  {
    if (IIODictionary::getCount(a1))
    {
      v6[0] = MEMORY[0x1E0C809B0];
      v6[1] = 0x40000000;
      v6[2] = __CGImageMetadataCreateFromLegacyProps_block_invoke;
      v6[3] = &unk_1E1BBD3D0;
      v6[4] = &v7;
      v6[5] = a1;
      XMPMappingIteratePropertiesUsingBlock(a1, (uint64_t)v6);
      ObjectForKeyGroup = (const __CFString *)IIODictionary::getObjectForKeyGroup(a1, CFSTR("iptcComputedMD5"), CFSTR("{IPTC}"));
      if (v8[3])
      {
        if (ObjectForKeyGroup)
        {
          Copy = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], ObjectForKeyGroup);
          *(_QWORD *)(v8[3] + 56) = Copy;
        }
      }
    }
  }
  v4 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

void sub_187E4995C(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187E49934);
}

void sub_187E49968(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

const __CFDictionary *IIODictionary::getCount(IIODictionary *this)
{
  const __CFDictionary *result;

  result = (const __CFDictionary *)*((_QWORD *)this + 1);
  if (result)
    return (const __CFDictionary *)CFDictionaryGetCount(result);
  return result;
}

_QWORD *IIOReadPlugin::createInfoPtr(IIOReadPlugin *this)
{
  _QWORD *v2;
  CFMutableDictionaryRef Mutable;
  IIOImageSource *v4;
  __CFDictionary *v5;
  const void *v6;

  v2 = malloc_type_calloc(0x10uLL, 1uLL, 0x1BAAB1CDuLL);
  v2[1] = this;
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  *v2 = Mutable;
  *((_QWORD *)this + 19) = Mutable;
  v4 = (IIOImageSource *)*((_QWORD *)this + 3);
  if (v4 && IIOImageSource::cf(v4))
  {
    v5 = (__CFDictionary *)*((_QWORD *)this + 19);
    v6 = (const void *)IIOImageSource::cf(*((IIOImageSource **)this + 3));
    CFDictionarySetValue(v5, CFSTR("kImageIOInfoHeader_session"), v6);
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 19), CFSTR("kImageIOInfoHeader_pluginHandlesReMapping"), (const void *)*MEMORY[0x1E0C9AE50]);
  }
  return v2;
}

uint64_t IIOImageSource::cf(IIOImageSource *this)
{
  return *((_QWORD *)this + 1);
}

uint64_t IIOReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v4;
  unsigned int v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;

  if (*(_WORD *)(a1 + 376) != 1)
  {
    v4 = *(_DWORD *)(a1 + 204);
    v5 = v4 >> 24;
    v6 = MEMORY[0x1E0C80978];
    v7 = v4 < 0 ? __maskrune(v4 >> 24, 0x40000uLL) : *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v5 + 60) & 0x40000;
    v8 = v7 ? v5 : 46;
    v9 = v4 << 8 >> 24;
    v10 = v4 << 8 < 0 ? __maskrune(v4 << 8 >> 24, 0x40000uLL) : *(_DWORD *)(v6 + 4 * v9 + 60) & 0x40000;
    v11 = v10 ? v9 : 46;
    v12 = (__int16)v4 >> 8;
    v13 = v4 << 16 < 0 ? __maskrune((__int16)v4 >> 8, 0x40000uLL) : *(_DWORD *)(v6 + 4 * v12 + 60) & 0x40000;
    v14 = v13 ? v12 : 46;
    v15 = (v4 << 24) <= 0x7F000000
        ? *(_DWORD *)(v6 + 4 * (char)v4 + 60) & 0x40000
        : __maskrune((char)v4, 0x40000uLL);
    v16 = v15 ? (char)v4 : 46;
    _cg_jpeg_mem_term("setupCallback", 433, "*** '%c%c%c%c' plugin has to implement 'setupCallback' for non-version1 callbacks [%d]\n", v8, v11, v14, v16, *(__int16 *)(a1 + 376));
    if (v4 != 1246774599)
      return 4294967246;
  }
  IIOReadPlugin::setupImageProviderCallbackV1(a1, a2, (uint64_t)IIO_Reader::CopyImageBlockSetProc);
  return 0;
}

uint64_t IIOReadPlugin::setupImageProviderCallbackV1(uint64_t a1, CFDictionaryRef *a2, uint64_t a3)
{
  uint64_t v6;
  CGColorSpace *SourceGeomColorSpace;

  v6 = IIOReadPlugin::prepareGeometry(a1, a2);
  if (!(_DWORD)v6)
  {
    IIOImagePlus::setImageBlockProc(*(_QWORD *)(a1 + 16), (CFTypeRef *)a2, (const void *)1, a3, 0, 0, 0, (uint64_t)IIOReadPlugin::ReleaseInfo);
    SourceGeomColorSpace = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(*(IIOImagePlus **)(a1 + 16));
    *(_DWORD *)(a1 + 320) = CGColorSpaceGetModel(SourceGeomColorSpace);
  }
  return v6;
}

uint64_t IIOImagePlus::getSourceGeomColorSpace(IIOImagePlus *this)
{
  return *((_QWORD *)this + 11);
}

uint64_t PNGReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v2;

  v2 = *(__int16 *)(a1 + 376);
  if (v2 == 12)
    return IIOReadPlugin::setupImageProviderCallbackV2(a1, a2, (uint64_t)IIO_Reader::CopyImageBlockSetProc, (uint64_t)IIO_Reader::CopyIOSurfaceProc);
  if (v2 == 1)
    return IIOReadPlugin::setupCallback(a1, a2);
  return 4294967246;
}

uint64_t PNGReadPlugin::initialize(IIODictionary **this, IIODictionary *a2)
{
  IIOImageReadSession *v3;

  v3 = (IIOImageReadSession *)IIOImageSource::count((IIOImageSource *)this);
  return PNGReadPlugin::InitializePluginData(v3, this[6], this[7], this[8], this + 20, (uint64_t)(this + 23), (uint64_t)(this + 55), this[19]);
}

uint64_t IIOImageSource::count(IIOImageSource *this)
{
  return *((_QWORD *)this + 3);
}

uint64_t GetIntegerFromPropertyValue(const __CFString *cf, SInt32 *a2)
{
  uint64_t result;
  CFTypeID v5;
  CFTypeID v6;

  result = 0;
  if (cf && a2)
  {
    *a2 = 0;
    v5 = CFGetTypeID(cf);
    if ((v5 != CGImageMetadataTagGetTypeID()
       || (cf = *(const __CFString **)(CGImageSourceGetSource((uint64_t)cf) + 48)) != 0)
      && (v6 = CFGetTypeID(cf), v6 == CFStringGetTypeID()))
    {
      *a2 = CFStringGetIntValue(cf);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void IIODictionaryAppendDictionary(__CFDictionary *a1, const __CFDictionary *a2, BOOL a3)
{
  CFIndex Count;
  const void **v7;
  const void **v8;
  const void **v9;
  const void **v10;
  const __CFAllocator *v11;
  CFTypeRef *v12;
  const void **v13;
  CFTypeID v14;
  CFTypeID TypeID;
  const void *v16;
  const __CFDictionary *Value;
  const __CFDictionary *v18;
  CFTypeID v19;
  __CFDictionary *MutableCopy;
  __CFDictionary *v21;

  if (a1 && a2)
  {
    if ((IIODictionaryIsMutable() & 1) == 0)
      _cg_jpeg_mem_term("IIODictionaryAppendDictionary", 1436, "*** ERROR: ❌ IIODictionaryAppendDictionary called with immutable dictionary!  [%p]\n", a1);
    Count = CFDictionaryGetCount(a2);
    v7 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
    if (v7)
    {
      v8 = v7;
      v9 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
      if (v9)
      {
        v10 = v9;
        CFDictionaryGetKeysAndValues(a2, v8, v9);
        if (Count >= 1)
        {
          v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          v12 = v10;
          v13 = v8;
          do
          {
            if (a3 || !CFDictionaryContainsKey(a1, *v13))
            {
              v14 = CFGetTypeID(*v12);
              TypeID = CFDictionaryGetTypeID();
              v16 = *v13;
              if (v14 == TypeID)
              {
                Value = (const __CFDictionary *)CFDictionaryGetValue(a1, v16);
                if (Value)
                {
                  v18 = Value;
                  v19 = CFGetTypeID(Value);
                  if (v19 == CFDictionaryGetTypeID())
                  {
                    MutableCopy = CFDictionaryCreateMutableCopy(v11, 0, v18);
                    if (!MutableCopy)
                      break;
                    v21 = MutableCopy;
                    IIODictionaryAppendDictionary(MutableCopy, (const __CFDictionary *)*v12, a3);
                    CFDictionarySetValue(a1, *v13, v21);
                    CFRelease(v21);
                    goto LABEL_18;
                  }
                }
                v16 = *v13;
              }
              CFDictionarySetValue(a1, v16, *v12);
            }
LABEL_18:
            ++v13;
            ++v12;
            --Count;
          }
          while (Count);
        }
        free(v8);
      }
      else
      {
        v10 = v8;
      }
      free(v10);
    }
  }
}

void IIONumber::IIONumber(IIONumber *this, float a2)
{
  float valuePtr;

  valuePtr = a2;
  *(_QWORD *)this = &off_1E1BB2F60;
  *((_QWORD *)this + 1) = 12;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 2) = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberFloatType, &valuePtr);
}

uint64_t CGImagePropertiesCreateFromMetadata(const __CFDictionary **a1)
{
  CFTypeID v2;
  const __CFDictionary *v3;
  uint64_t v4;
  IIODictionary *v5;
  uint64_t v6;
  _QWORD v8[6];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;

  v9 = 0;
  v10 = &v9;
  v11 = 0x2000000000;
  v12 = 0;
  if (!a1)
    goto LABEL_13;
  v2 = CFGetTypeID(a1);
  if (v2 != CGImageMetadataGetTypeID())
    goto LABEL_13;
  v3 = a1[3];
  if (v3 && !CFDictionaryGetCount(v3) && !a1[6])
  {
    v6 = 0;
    goto LABEL_14;
  }
  v4 = v10[3];
  if (a1[6])
  {
    if (!v4)
    {
      v5 = (IIODictionary *)operator new();
      IIODictionary::IIODictionary(v5, a1[6], 1);
LABEL_11:
      v10[3] = (uint64_t)v5;
    }
  }
  else if (!v4)
  {
    v5 = (IIODictionary *)operator new();
    IIODictionary::IIODictionary(v5);
    goto LABEL_11;
  }
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 0x40000000;
  v8[2] = __CGImagePropertiesCreateFromMetadata_block_invoke;
  v8[3] = &unk_1E1BC9FB0;
  v8[4] = &v9;
  v8[5] = a1;
  XMPMappingIterateUsingBlock((uint64_t)v8);
LABEL_13:
  v6 = v10[3];
LABEL_14:
  _Block_object_dispose(&v9, 8);
  return v6;
}

void sub_187E4A0D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v7;
  va_list va;

  va_start(va, a7);
  MEMORY[0x18D761C30](v7, 0x10A1C4047070A01);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void IIODictionary::appendDictionary(IIODictionary *this, const __CFDictionary **a2)
{
  __CFDictionary *v2;

  v2 = (__CFDictionary *)*((_QWORD *)this + 1);
  if (v2)
    IIODictionaryAppendDictionary(v2, a2[1], 1);
}

uint64_t GetDoubleFromPropertyValue(const __CFString *cf, double *a2)
{
  const __CFString *v3;
  CFTypeID v4;
  CFTypeID v5;
  uint64_t result;
  double v7;
  char *v8;
  uint64_t v9;
  _OWORD v10[2];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (!a2)
    return 0;
  v3 = cf;
  *a2 = 0.0;
  if (!cf)
    return 0;
  v4 = CFGetTypeID(cf);
  if (v4 == CGImageMetadataTagGetTypeID())
  {
    v3 = *(const __CFString **)(CGImageSourceGetSource((uint64_t)v3) + 48);
    if (!v3)
      return 0;
  }
  v5 = CFGetTypeID(v3);
  if (v5 != CFStringGetTypeID())
    return 0;
  memset(v10, 0, sizeof(v10));
  result = CFStringGetCString(v3, (char *)v10, 32, 0x8000100u);
  if ((_DWORD)result)
  {
    v7 = (double)atol((const char *)v10);
    v8 = strchr((char *)v10, 47);
    if (v8)
    {
      *v8 = 0;
      v9 = atol(v8 + 1);
      if (v9)
      {
        if (v9 != 1)
          v7 = v7 / (double)v9;
      }
      else
      {
        v7 = 0.0;
      }
    }
    *a2 = v7;
    return 1;
  }
  return result;
}

uint64_t HEIFReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;

  IIO_LoadHEIFSymbols();
  v4 = *(__int16 *)(a1 + 376);
  if (v4 == 12)
  {
    v5 = IIOReadPlugin::setupImageProviderCallbackV2(a1, a2, (uint64_t)IIO_Reader::CopyImageBlockSetProc, (uint64_t)IIO_Reader::CopyIOSurfaceProc);
    goto LABEL_5;
  }
  if (v4 == 1)
  {
    v5 = IIOReadPlugin::setupCallback(a1, a2);
LABEL_5:
    v6 = v5;
    goto LABEL_7;
  }
  v6 = 4294967246;
LABEL_7:
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("       useMainImageForThumbnail: %d\n", *(unsigned __int8 *)(a1 + 490));
  return v6;
}

double IIODictionary::getDoubleFromValue(IIODictionary *this, const __CFString *cf)
{
  double v2;
  CFTypeID v4;
  CFTypeID v5;
  double valuePtr;

  valuePtr = 0.0;
  v2 = 0.0;
  if (cf)
  {
    v4 = CFGetTypeID(cf);
    if (v4 == CFNumberGetTypeID())
    {
      CFNumberGetValue((CFNumberRef)cf, kCFNumberDoubleType, &valuePtr);
      return valuePtr;
    }
    else
    {
      v5 = CFGetTypeID(cf);
      if (v5 == CFStringGetTypeID())
        return CFStringGetDoubleValue(cf);
    }
  }
  return v2;
}

double IIODictionary::getDoubleForKey(IIODictionary *this, const __CFString *a2)
{
  const __CFDictionary *v2;
  IIODictionary *Value;

  v2 = (const __CFDictionary *)*((_QWORD *)this + 1);
  if (!v2)
    return 0.0;
  Value = (IIODictionary *)CFDictionaryGetValue(v2, a2);
  return IIODictionary::getDoubleFromValue(Value, (const __CFString *)Value);
}

uint64_t AppleJPEGReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v2;

  v2 = *(__int16 *)(a1 + 376);
  switch(v2)
  {
    case 123:
      return IIOReadPlugin::setupImageProviderCallbackV3(a1, a2, (uint64_t)IIO_Reader::CopyImageBlockSetProc, (uint64_t)IIO_Reader::CopyIOSurfaceProc, (uint64_t)IIO_Reader::CopyIOSurfaceSetProc, 0);
    case 12:
      return IIOReadPlugin::setupImageProviderCallbackV2(a1, a2, (uint64_t)IIO_Reader::CopyImageBlockSetProc, (uint64_t)IIO_Reader::CopyIOSurfaceProc);
    case 1:
      return IIOReadPlugin::setupCallback(a1, a2);
  }
  return 4294967246;
}

uint64_t IIOReadPlugin::setupImageProviderCallbackV3(uint64_t a1, CFDictionaryRef *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12;
  CGColorSpace *SourceGeomColorSpace;

  v12 = IIOReadPlugin::prepareGeometry(a1, a2);
  if (!(_DWORD)v12)
  {
    IIOImagePlus::setImageBlockProc(*(_QWORD *)(a1 + 16), (CFTypeRef *)a2, (const void *)3, a3, a4, a5, a6, (uint64_t)IIOReadPlugin::ReleaseInfo);
    SourceGeomColorSpace = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(*(IIOImagePlus **)(a1 + 16));
    *(_DWORD *)(a1 + 320) = CGColorSpaceGetModel(SourceGeomColorSpace);
  }
  return v12;
}

uint64_t ATXReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v2;

  v2 = *(__int16 *)(a1 + 376);
  switch(v2)
  {
    case 13:
      return IIOReadPlugin::setupImageProviderCallbackV3(a1, a2, (uint64_t)IIO_Reader::CopyImageBlockSetProc, 0, 0, (uint64_t)IIO_Reader::CopyImageTextureDataProc);
    case 12:
      return IIOReadPlugin::setupImageProviderCallbackV2(a1, a2, (uint64_t)IIO_Reader::CopyImageBlockSetProc, (uint64_t)IIO_Reader::CopyIOSurfaceProc420f);
    case 1:
      return IIOReadPlugin::setupCallback(a1, a2);
  }
  return 4294967246;
}

const __CFString *CreateSubsecTimeFromXMPDateTime(const __CFString *cf)
{
  const __CFString *v1;
  CFTypeID v2;
  CFIndex v3;
  char *v4;
  char *v5;
  int v7;
  int v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  char cStr[8];
  __int16 v18;
  uint64_t v19;

  v1 = cf;
  v19 = *MEMORY[0x1E0C80C00];
  v18 = 0;
  *(_QWORD *)cStr = 0;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  v16 = 0;
  v9 = 0u;
  v10 = 0u;
  v11 = 0u;
  v12 = 0;
  if (cf)
  {
    v2 = CFGetTypeID(cf);
    if (v2 == CFStringGetTypeID()
      && (v3 = CFStringGetLength(v1) + 1, (v4 = (char *)malloc_type_calloc(1uLL, v3, 0x2C26E6C3uLL)) != 0))
    {
      v5 = v4;
      v8 = 0;
      if (CFStringGetCString(v1, v4, v3, 0x600u)
        && (sscanf(v5, "%04d-%02d-%02dT%02d:%02d:%02d.%9[0-9]+%02d:%02d", (char *)&v14 + 4, &v14, (unint64_t)&v13 | 0xC, (char *)&v13 + 8, (char *)&v13 + 4, &v8, cStr, (char *)&v9 + 8, (char *)&v9 + 4) == 9|| sscanf(v5, "%04d-%02d-%02dT%02d:%02d:%02d.%9[0-9]-%02d:%02d", (char *)&v14 + 4, &v14, (unint64_t)&v13 | 0xC, (char *)&v13 + 8, (char *)&v13 + 4,
              &v8,
              cStr,
              (char *)&v9 + 8,
              (char *)&v9 + 4) == 9
         || sscanf(v5, "%04d-%02d-%02dT%02d:%02d:%02d.%9[0-9]Z", (char *)&v14 + 4, &v14, (unint64_t)&v13 | 0xC, (char *)&v13 + 8, (char *)&v13 + 4, &v8, cStr) == 7))
      {
        v7 = 0;
        v1 = 0;
        if (sscanf(cStr, "%d", &v7) == 1 && v7 >= 1)
          v1 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], cStr, 0x600u);
      }
      else
      {
        v1 = 0;
      }
      free(v5);
    }
    else
    {
      return 0;
    }
  }
  return v1;
}

uint64_t ASTCReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v2;

  v2 = *(__int16 *)(a1 + 376);
  if (v2 == 13)
    return IIOReadPlugin::setupImageProviderCallbackV3(a1, a2, (uint64_t)IIO_Reader::CopyImageBlockSetProc, 0, 0, (uint64_t)IIO_Reader::CopyImageTextureDataProc);
  if (v2 == 1)
    return IIOReadPlugin::setupCallback(a1, a2);
  return 4294967246;
}

const __CFDictionary **IIOImageSource::copyPropertiesAtIndex(IIOImageSource *this, unint64_t a2, const __CFDictionary **a3)
{
  const __CFDictionary **PropertiesAtIndexInternal;
  uint64_t v5;
  CFTypeRef cf;
  uint64_t v7;

  PropertiesAtIndexInternal = (const __CFDictionary **)IIOImageSource::getPropertiesAtIndexInternal(this, a2, a3);
  if (PropertiesAtIndexInternal)
  {
    if ((gIIODebugFlags & 0x2000000000000) != 0)
      IIODebugOrientation("copyPropertiesAtIndex", 1577, (IIODictionary *)PropertiesAtIndexInternal);
    cf = 0;
    v7 = 0;
    v5 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v5, PropertiesAtIndexInternal[1], 1);
    PropertiesAtIndexInternal = (const __CFDictionary **)CFRetain(cf);
    if (!PropertiesAtIndexInternal)
      LogError("copyPropertiesAtIndex", 1584, "*** ERROR: CFDictionaryCreateCopy failed\n");
    IIODictionary::~IIODictionary((IIODictionary *)&v5);
  }
  return PropertiesAtIndexInternal;
}

void sub_187E4A7F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

CGImage *IIOImagePlus::createImage(IIOImagePlus *this, CGImageSource *a2, int *a3)
{
  uint64_t Source;
  uint64_t v6;
  IIOImageSource *v7;
  void *v8;
  int v9;
  CGImage *v10;
  int v11;
  uint64_t v12;
  CGColorSpace *v13;
  int v14;
  char v15;
  int v16;
  int v17;
  uint64_t v18;
  IIOImageReadSession *v19;
  const void *ImageProvider;
  const void *v21;
  double v22;
  double v23;
  uint64_t v24;
  uint64_t CopyWithClipPath;
  CGImage *v26;
  unsigned int v28;

  Source = CGImageSourceGetSource((uint64_t)a2);
  v6 = *((_QWORD *)this + 5);
  if (!v6 || !*((_QWORD *)this + 6) || !*((_QWORD *)this + 9))
  {
    LogError("createImage", 1445, "*** ERROR: bad image size (%ld x %ld) rb: %ld\n", v6, *((_QWORD *)this + 6), *((_QWORD *)this + 9));
    v10 = 0;
    v11 = -67;
    goto LABEL_54;
  }
  v7 = (IIOImageSource *)Source;
  v8 = (void *)*((_QWORD *)this + 16);
  if (v8)
  {
    if (*((_DWORD *)this + 34))
    {
      v9 = IIOImageSource::imageSourceType(v7);
      v8 = (void *)*((_QWORD *)this + 16);
      if (v9 == 6)
      {
        if (CFGetRetainCount(v8) <= 1
          && (IIOImageSource::imageSourceType(v7) != 6
           || IIOImageSource::incrementalDataUpdated(v7)))
        {
          IIOImageSource::removeImageFromSet((uint64_t)v7, *((IIOImagePlus ***)this + 1), *((const void **)this + 16));
          *((_QWORD *)this + 16) = 0;
          *((_BYTE *)this + 192) &= ~0x40u;
          goto LABEL_14;
        }
        v8 = (void *)*((_QWORD *)this + 16);
      }
    }
    v10 = CGImageRetain((CGImageRef)v8);
    if (!v10)
    {
      v11 = 0;
      goto LABEL_54;
    }
    goto LABEL_52;
  }
LABEL_14:
  v12 = *((_QWORD *)this + 7);
  v13 = (CGColorSpace *)*((_QWORD *)this + 11);
  v14 = *((_DWORD *)this + 24);
  v15 = *((_BYTE *)this + 104);
  v16 = v14 | 0x100;
  if ((v15 & 1) == 0)
    v16 = *((_DWORD *)this + 24);
  if ((*((_BYTE *)this + 105) & (v12 == 16)) != 0)
    v16 |= 0x1000u;
  if ((*((_BYTE *)this + 105) & (v12 == 32)) != 0)
    v17 = v16 | 0x2000;
  else
    v17 = v16;
  v28 = v17;
  CGColorSpaceGetRenderingIntent();
  v18 = 0;
  if (v12 <= 15)
  {
    if (v12 == 8)
    {
      v18 = 1;
    }
    else if (v12 == 10)
    {
      v18 = 6;
      if (!v14)
        goto LABEL_36;
LABEL_35:
      CGColorSpaceGetModel(v13);
      goto LABEL_36;
    }
LABEL_34:
    if (!v14)
      goto LABEL_36;
    goto LABEL_35;
  }
  if (v12 == 16)
  {
    if ((v15 & 1) != 0)
      v18 = 5;
    else
      v18 = 2;
    if (v14)
      goto LABEL_35;
  }
  else
  {
    if (v12 != 32)
      goto LABEL_34;
    if ((v15 & 1) != 0)
      v18 = 4;
    else
      v18 = 3;
    if (v14)
      goto LABEL_35;
  }
LABEL_36:
  v19 = (IIOImageReadSession *)CGImageSourceGetSource(*((_QWORD *)this + 3));
  if (IIOImageReadSession::isFinal(v19))
    *((_DWORD *)this + 34) = 0;
  ImageProvider = IIOImagePlus::getImageProvider(this);
  if (ImageProvider)
  {
    v21 = ImageProvider;
    CGImageProviderGetSize();
    if (v22 < 1.0 || v23 < 1.0 || v22 != (double)(unint64_t)v22 || v23 != (double)(unint64_t)v23)
      LogError("createImage", 1550, "*** ERROR: CGImageProvider %p   size: %g x %g\n", v21, v22, v23);
    v10 = (CGImage *)CGImageCreateWithImageProvider();
    if (v10)
    {
      v24 = IIOImageSource::reader(v7);
      if (v24)
        (*(void (**)(uint64_t, CGImage *, IIOImageReadSession *, CGColorSpace *, uint64_t, _QWORD))(*(_QWORD *)v24 + 128))(v24, v10, v19, v13, v18, v28);
      IIOImagePlus::releaseImageProvider(this);
      *((_BYTE *)this + 192) |= 0x40u;
      *(_QWORD *)(**((_QWORD **)this + 30) + 8) = v10;
      if (*((_QWORD *)this + 23))
      {
        CopyWithClipPath = CGImageCreateCopyWithClipPath();
        if (CopyWithClipPath)
        {
          v26 = (CGImage *)CopyWithClipPath;
          CGImageRelease(v10);
          v10 = v26;
        }
      }
      CGImageSetProperty();
      if (CGImageReadSessionGetFilePath(*((_QWORD *)this + 3)))
        CGImageSetProperty();
LABEL_52:
      v11 = 0;
      *((_QWORD *)this + 16) = v10;
      goto LABEL_54;
    }
    IIOImagePlus::releaseImageProvider(this);
    LogError("createImage", 1572, "*** ERROR: CGImageCreateWithImageProvider failed\n");
    v11 = -61;
  }
  else
  {
    _cg_jpeg_mem_term("createImage", 1541, "imageProvider is NULL\n");
    v10 = 0;
    v11 = -60;
  }
LABEL_54:
  if (a3)
    *a3 = v11;
  return v10;
}

uint64_t IIOReadPlugin::IIOReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  CFIndex *v9;
  IIOImageSource *v10;
  IIOImagePlus **v11;
  uint64_t v12;
  IIOImageReadSession *Source;
  IIOImageRead *v14;
  IIOImagePlus *v15;
  __int128 v16;
  IIODictionary *v17;
  const __CFString *ObjectForKey;

  *(_OWORD *)(a1 + 184) = 0u;
  v9 = (CFIndex *)(a1 + 184);
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_QWORD *)(a1 + 424) = 0;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_QWORD *)a1 = &off_1E1BACDE8;
  *(_QWORD *)(a1 + 8) = a2;
  if (!a2)
  {
    *(_QWORD *)(a1 + 16) = 0;
    v11 = (IIOImagePlus **)(a1 + 16);
    *(_BYTE *)(a1 + 40) = 0;
    *(_DWORD *)(a1 + 432) = 0;
LABEL_7:
    *(_BYTE *)(a1 + 341) = 1;
    *(_QWORD *)(a1 + 24) = 0;
    *(_QWORD *)(a1 + 32) = 0;
    goto LABEL_8;
  }
  v10 = *(IIOImageSource **)(a2 + 24);
  *(_QWORD *)(a1 + 16) = v10;
  v11 = (IIOImagePlus **)(a1 + 16);
  *(_BYTE *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 432) = 0;
  if (!v10)
    goto LABEL_7;
  v12 = IIOImageSource::count(v10);
  if (!v12)
    goto LABEL_7;
  Source = (IIOImageReadSession *)CGImageSourceGetSource(v12);
  *(_QWORD *)(a1 + 24) = Source;
  *(_BYTE *)(a1 + 341) = IIOImageReadSession::isFinal(Source);
  v14 = (IIOImageRead *)IIO_Reader::testHeaderSize(*(IIO_Reader **)(a1 + 24));
  *(_QWORD *)(a1 + 32) = v14;
  if (v14)
    *v9 = IIOImageRead::getSize(v14);
LABEL_8:
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  v15 = *(IIOImagePlus **)(a1 + 16);
  if (v15)
  {
    *(_QWORD *)(a1 + 48) = IIOImagePlus::getOptions(v15);
    *(_QWORD *)(a1 + 56) = IIOImagePlus::getProperties(*(IIOImagePlus **)(a1 + 16));
    *(_QWORD *)(a1 + 64) = IIOImagePlus::getMetadata(*(IIOImagePlus **)(a1 + 16));
  }
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 104) = 0;
  v16 = *(_OWORD *)(MEMORY[0x1E0C9D628] + 16);
  *(_OWORD *)(a1 + 120) = *MEMORY[0x1E0C9D628];
  *(_OWORD *)(a1 + 136) = v16;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 152) = 0;
  *(_BYTE *)(a1 + 176) = IIOPluginShouldDebugWriteImageBlocks();
  *(_BYTE *)(a1 + 177) = IIOPluginShouldDebugWriteImageBlocks();
  *(_DWORD *)(a1 + 208) = a3;
  *(_QWORD *)(a1 + 192) = a4;
  *(_BYTE *)(a1 + 355) = -1;
  *(_DWORD *)(a1 + 320) = -1;
  *(_WORD *)(a1 + 328) = 0;
  *(_QWORD *)(a1 + 332) = 0x2D2D2D2D00000000;
  *(_BYTE *)(a1 + 342) = 1;
  if ((gIIODebugFlags & 0x20000000) != 0)
  {
    *(_BYTE *)(a1 + 343) = (gIIODebugFlags & 0x40000000) != 0;
  }
  else if (*v11)
  {
    *(_BYTE *)(a1 + 343) = IIOImagePlus::shouldCacheImageBlocks(*v11);
  }
  *(_BYTE *)(a1 + 344) = 1;
  *(_WORD *)(a1 + 353) = 0;
  v17 = *(IIODictionary **)(a1 + 48);
  if (v17 && IIODictionary::containsKey(v17, CFSTR("kCGImageSourceDecodeRequest")))
  {
    ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey(*(IIODictionary **)(a1 + 48), CFSTR("kCGImageSourceDecodeRequest"));
    *(_BYTE *)(a1 + 353) = CFStringCompare(ObjectForKey, CFSTR("kCGImageSourceDecodeToSDR"), 0) == kCFCompareEqualTo;
    *(_BYTE *)(a1 + 354) = CFStringCompare(ObjectForKey, CFSTR("kCGImageSourceDecodeToHDR"), 0) == kCFCompareEqualTo;
  }
  *(_QWORD *)(a1 + 384) = 0;
  *(_QWORD *)(a1 + 392) = 0;
  *(_QWORD *)(a1 + 404) = -1;
  *(_DWORD *)(a1 + 400) = 538976288;
  *(_WORD *)(a1 + 413) = 256;
  *(_DWORD *)(a1 + 204) = a5;
  return a1;
}

uint64_t IIO_Reader::testHeaderSize(IIO_Reader *this)
{
  return *((_QWORD *)this + 4);
}

IIOImageRead *IIOImageReadSession::isFinal(IIOImageReadSession *this)
{
  IIOImageRead *result;

  result = (IIOImageRead *)*((_QWORD *)this + 4);
  if (result)
    return (IIOImageRead *)IIOImageRead::isFinal(result);
  return result;
}

uint64_t IIOImagePlus::getMetadata(IIOImagePlus *this)
{
  return *((_QWORD *)this + 15);
}

uint64_t IIOImagePlus::getOptions(IIOImagePlus *this)
{
  return *((_QWORD *)this + 25);
}

const void *IIOImageSource::makeImagePlus(IIOImageSource *this, unint64_t a2, const __CFDictionary **a3)
{
  unint64_t v6;
  IIOImageSource *v7;
  int v8;
  IIOImagePlus *ImagePlus;
  IIOImagePlus *v10;
  uint64_t Options;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  unsigned int Status;
  uint64_t v17;
  const void *v18;
  uint64_t v19;
  uint64_t v20;
  const void *v21;
  uint64_t Image;
  uint64_t v23;
  uint64_t v24;
  IIOImagePlus *v25;
  IIODictionary *Properties;
  unsigned int Uint32ForKey;
  uint64_t v28;
  int v29;
  int v30;
  const char *v31;
  IIODictionary *v32;
  unsigned int v33;
  int v34;
  uint64_t v35;
  unsigned int v36;
  int v37;
  uint64_t v38;
  unsigned int v39;
  int v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t Metadata;
  unsigned int v45;
  uint64_t v46;
  int v47;
  const __CFDictionary *ObjectForKey;
  uint64_t v49;
  float v50;
  uint64_t v51;
  unsigned int v52;
  int v53;
  uint64_t v54;
  unsigned int v55;
  int v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v61;
  uint64_t v62;
  _QWORD *cf;
  _BYTE v64[16];
  void *value;
  _BYTE v66[24];
  uint64_t v67;
  const __CFDictionary *v68;
  uint64_t v69;
  unsigned __int8 v70[10];

  *(_WORD *)v70 = 0;
  v6 = IIOImageSource::updatedCount(this);
  v67 = 0;
  v68 = 0;
  v69 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v67, a3[1], 1);
  v7 = (IIOImageSource *)IIO_Reader::osType(*((IIO_Reader **)this + 10));
  if (v6 <= a2)
  {
    _cg_jpeg_mem_term("makeImagePlus", 3471, "*** ERROR: index (%d) >= count (%ld)\n", a2, v6);
    goto LABEL_101;
  }
  v8 = (int)v7;
  IIOImageSource::getCacheValues(v7, (IIODictionary *)a3, (BOOL *)&v70[1], (BOOL *)v70);
  ImagePlus = (IIOImagePlus *)IIOImageSource::getImagePlus(this, a2);
  v10 = ImagePlus;
  if (ImagePlus)
  {
    Options = IIOImagePlus::getOptions(ImagePlus);
    if (*((_BYTE *)this + 33))
    {
      v12 = *((unsigned __int8 *)this + 33) ^ 1;
    }
    else
    {
      v13 = Options;
      v14 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 10) + 168))(*((_QWORD *)this + 10));
      if (v13)
        v15 = v14;
      else
        v15 = 0;
      if (v15 != 1)
      {
LABEL_11:
        Status = IIOImagePlus::getStatus(v10);
        if (Status != 0 && Status < 0xFFFFFFFB || ((1 << (Status + 5)) & 0x31) == 0)
        {
          IIOImagePlus::clearProperties((IIODictionary **)v10);
          IIOImagePlus::clearMetadata(v10);
          v17 = IIO_Reader::testHeaderSize(v10);
          IIOImageReadSession::rewind(v17);
          v18 = (const void *)IIO_Reader::utType(*((IIO_Reader **)this + 10));
          IIODebugCallbackPriv(v18, "initThumbnail");
          v19 = *((_QWORD *)this + 10);
          v20 = IIOImageSource::cf(v10);
          (*(void (**)(uint64_t, uint64_t, unint64_t, _QWORD))(*(_QWORD *)v19 + 88))(v19, v20, a2, 0);
          IIOImagePlus::copyPropertiesToRoot((IIODictionary **)v10);
        }
        v21 = (const void *)IIOImageSource::cf(v10);
        goto LABEL_94;
      }
      v12 = (*(uint64_t (**)(_QWORD, _QWORD, const __CFDictionary *))(**((_QWORD **)this + 10) + 80))(*((_QWORD *)this + 10), *(_QWORD *)(v13 + 8), a3[1]);
    }
    if (v12)
      goto LABEL_11;
    *((_BYTE *)this + 33) = 0;
    if (IIOImagePlus::getImageProvider(v10))
    {
      Image = IIOImagePlus::getImage(v10);
      if (!Image || Image == *MEMORY[0x1E0C9B0D0])
        IIOImagePlus::releaseImageProvider(v10);
    }
    IIOImageSource::setImagePlusAtIndex((uint64_t)this, 0, a2);
  }
  v23 = *((_QWORD *)this + 2);
  if (!v23)
  {
    _cg_jpeg_mem_term("makeImagePlus", 3549, "*** this->imageReadRef() failed\n");
    goto LABEL_101;
  }
  cf = CGImageReadSessionCreate(*((const void **)this + 2));
  if (!cf)
  {
LABEL_101:
    v21 = 0;
    goto LABEL_94;
  }
  CGImageSourceGetSource(v23);
  IIONumber::IIONumber((IIONumber *)v66, *((char *)this + 53));
  IIODictionary::setObjectForKey((uint64_t)&v67, (uint64_t)v66, CFSTR("kCGImageSourceForceUseServer"));
  IIONumber::~IIONumber((IIONumber *)v66);
  v24 = CGImagePlusCreateWithSession(cf, *((_QWORD *)this + 14), v68, *((_QWORD *)this + 1));
  v21 = (const void *)v24;
  if (v24)
  {
    v25 = *(IIOImagePlus **)(v24 + 24);
    IIOImagePlus::setShouldCacheImageBlocks((uint64_t)v25, v70[1]);
    IIOImagePlus::setShouldCacheImmediately((uint64_t)v25, v70[0]);
    *((_BYTE *)this + 33) = 0;
    IIOImagePlus::setStatus((uint64_t)v25, kCGImageStatusReadingHeader);
    Properties = (IIODictionary *)IIOImagePlus::getProperties(v25);
    if (Properties && IIODictionary::containsKey((IIODictionary *)a3, CFSTR("kCGImageSourceXMPSidecar")))
      IIODictionary::setObjectForKey(Properties, (const void *)*MEMORY[0x1E0C9AE50], CFSTR("XMP_FROM_SIDECAR"));
    if (IIO_Reader::osType(*((IIO_Reader **)this + 10)) == 1346651680)
      Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)a3, CFSTR("kCGImageSourceThumbnailMaxPixelSize"));
    else
      Uint32ForKey = 0;
    v28 = Uint32ForKey;
    v29 = IIO_Reader::callInitializeImageAtOffset(*((_QWORD *)this + 10), (uint64_t)v21, a2, Uint32ForKey, 0, *((char *)this + 53));
    if ((unsigned __int16)v29 == 64136)
    {
      ImageIOLog("‼️ retrying 'initializeImageAtOffset' (ImageIOXPCService crashed?)\n");
      v30 = IIO_Reader::callInitializeImageAtOffset(*((_QWORD *)this + 10), (uint64_t)v21, a2, v28, 0, *((char *)this + 53));
      v29 = v30;
      v31 = "❌";
      if (!(_WORD)v30)
        v31 = "✅";
      ImageIOLog("%s retrying 'initializeImageAtOffset'  err: %d\n", v31, (__int16)v30);
    }
    IIOImagePlus::copyPropertiesToRoot((IIODictionary **)v25);
    v32 = (IIODictionary *)IIOImagePlus::getProperties(v25);
    if (!v32)
    {
      v33 = v8 >> 24;
      if (v8 < 0)
        v34 = __maskrune(v8 >> 24, 0x40000uLL);
      else
        v34 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v33 + 60) & 0x40000;
      if (v34)
        v35 = v33;
      else
        v35 = 46;
      v62 = v35;
      v36 = v8 << 8 >> 24;
      if (v8 << 8 < 0)
        v37 = __maskrune(v8 << 8 >> 24, 0x40000uLL);
      else
        v37 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v36 + 60) & 0x40000;
      if (v37)
        v38 = v36;
      else
        v38 = 46;
      v61 = v38;
      v39 = (__int16)v8 >> 8;
      if (v8 << 16 < 0)
        v40 = __maskrune((__int16)v8 >> 8, 0x40000uLL);
      else
        v40 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v39 + 60) & 0x40000;
      if ((v8 << 24) <= 0x7F000000)
        v41 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v8 + 60) & 0x40000;
      else
        v41 = __maskrune((char)v8, 0x40000uLL);
      if (v40)
        v42 = v39;
      else
        v42 = 46;
      if (v41)
        v43 = (char)v8;
      else
        v43 = 46;
      LogError("makeImagePlus", 3608, "*** ERROR: '%c%c%c%c'-_reader->initImage[%d] iPlus properties == NULL\n", v62, v61, v42, v43, a2);
    }
    Metadata = IIOImagePlus::getMetadata(v25);
    if (v29 << 16)
    {
      CFArrayAppendValue(*((CFMutableArrayRef *)this + 21), v21);
      CFRelease(v21);
      v45 = v8 >> 24;
      v46 = MEMORY[0x1E0C80978];
      if (v8 < 0)
        v47 = __maskrune(v8 >> 24, 0x40000uLL);
      else
        v47 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v45 + 60) & 0x40000;
      if (v47)
        v51 = v45;
      else
        v51 = 46;
      v52 = v8 << 8 >> 24;
      if (v8 << 8 < 0)
        v53 = __maskrune(v8 << 8 >> 24, 0x40000uLL);
      else
        v53 = *(_DWORD *)(v46 + 4 * v52 + 60) & 0x40000;
      if (v53)
        v54 = v52;
      else
        v54 = 46;
      v55 = (__int16)v8 >> 8;
      if (v8 << 16 < 0)
        v56 = __maskrune((__int16)v8 >> 8, 0x40000uLL);
      else
        v56 = *(_DWORD *)(v46 + 4 * v55 + 60) & 0x40000;
      if ((v8 << 24) <= 0x7F000000)
        v57 = *(_DWORD *)(v46 + 4 * (char)v8 + 60) & 0x40000;
      else
        v57 = __maskrune((char)v8, 0x40000uLL);
      if (v56)
        v58 = v55;
      else
        v58 = 46;
      if (v57)
        v59 = (char)v8;
      else
        v59 = 46;
      LogError("makeImagePlus", 3621, "*** ERROR: '%c%c%c%c'-_reader->initImage[%d] failed err=%d\n", v51, v54, v58, v59, a2, (__int16)v29);
    }
    else
    {
      ObjectForKey = (const __CFDictionary *)Metadata;
      IIOImageSource::setImagePlusAtIndex((uint64_t)this, v21, a2);
      if (ObjectForKey)
      {
        IIOImageSource::setImageMedadataAtIndex((CFArrayRef *)this, ObjectForKey, a2);
      }
      else if (v32)
      {
        ObjectForKey = IIODictionary::getObjectForKey(v32, CFSTR("{MetaData}"));
        if (ObjectForKey)
        {
          IIOImageSource::setImageMedadataAtIndex((CFArrayRef *)this, ObjectForKey, a2);
          IIODictionary::removeObjectForKey(v32, CFSTR("{MetaData}"));
        }
      }
      else
      {
        ObjectForKey = 0;
      }
      CFRelease(v21);
      v49 = IIO_Reader::testHeaderSize(v25);
      (*(void (**)(_QWORD, _QWORD, uint64_t, _QWORD, _QWORD, _QWORD))(**((_QWORD **)this + 10) + 128))(*((_QWORD *)this + 10), 0, v49, 0, 0, 0);
      if (v32)
      {
        if (v50 > 0.0)
        {
          IIONumber::IIONumber((IIONumber *)v64, v50);
          IIODictionary::setObjectForKey(v32, value, CFSTR("Headroom"));
          IIONumber::~IIONumber((IIONumber *)v64);
        }
        IIOImageSource::setImagePropertiesAtIndex(this, v32, a2);
      }
      if (ObjectForKey)
        IIOImageSource::setImageMedadataAtIndex((CFArrayRef *)this, ObjectForKey, a2);
    }
  }
  else
  {
    _cg_jpeg_mem_term("makeImagePlus", 3561, "*** CGImagePlusCreateWithSession failed\n");
  }
  CFRelease(cf);
LABEL_94:
  IIODictionary::~IIODictionary((IIODictionary *)&v67);
  return v21;
}

void sub_187E4B590(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  uint64_t v11;
  va_list va;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a10);
  va_start(va, a10);
  v11 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  _Unwind_Resume(a1);
}

void IIONumber::IIONumber(IIONumber *this, int a2)
{
  int valuePtr;

  valuePtr = a2;
  *(_QWORD *)this = &off_1E1BB2F60;
  *((_QWORD *)this + 1) = 9;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 2) = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
}

{
  int valuePtr;

  valuePtr = a2;
  *(_QWORD *)this = &off_1E1BB2F60;
  *((_QWORD *)this + 1) = 3;
  *((_QWORD *)this + 2) = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &valuePtr);
}

uint64_t IIOImagePlus::getProperties(IIOImagePlus *this)
{
  return *((_QWORD *)this + 14);
}

uint64_t IIOImageSource::updatedCount(IIOImageSource *this)
{
  uint64_t v2;
  _QWORD *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const char *v10;
  int v11;
  _BYTE v13[24];
  _QWORD v14[3];
  uint64_t v15;

  if (*((_BYTE *)this + 32))
    return *((_QWORD *)this + 3);
  if (!IIOImageSource::bindToReader(this))
    return 0;
  if (((*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 10) + 160))(*((_QWORD *)this + 10)) & 1) != 0)
  {
    v3 = CGImageReadSessionCreate(*((const void **)this + 2));
    if (v3)
    {
      v4 = v3;
      v15 = 0xFFFFFFFFLL;
      v5 = (const void *)IIO_Reader::utType(*((IIO_Reader **)this + 10));
      IIODebugCallbackPriv(v5, "imageCount");
      memset(v14, 0, sizeof(v14));
      IIODictionary::IIODictionary((IIODictionary *)v14);
      v6 = (const void *)*MEMORY[0x1E0C9AE50];
      v7 = (const void *)*MEMORY[0x1E0C9AE40];
      if (*((_BYTE *)this + 50))
        v8 = (const void *)*MEMORY[0x1E0C9AE50];
      else
        v8 = (const void *)*MEMORY[0x1E0C9AE40];
      IIODictionary::setObjectForKey((IIODictionary *)v14, v8, CFSTR("shouldExposeMultiFrameContents"));
      if (*((_BYTE *)this + 52))
        v9 = v6;
      else
        v9 = v7;
      IIODictionary::setObjectForKey((IIODictionary *)v14, v9, CFSTR("useImageSequence"));
      IIONumber::IIONumber((IIONumber *)v13, *((char *)this + 53));
      IIODictionary::setObjectForKey((uint64_t)v14, (uint64_t)v13, CFSTR("kCGImageSourceForceUseServer"));
      IIONumber::~IIONumber((IIONumber *)v13);
      v2 = (*(uint64_t (**)(_QWORD, const void *, _QWORD *, uint64_t *, char *))(**((_QWORD **)this + 10) + 24))(*((_QWORD *)this + 10), v4, v14, &v15, (char *)&v15 + 4);
      if (HIDWORD(v15) == -1400)
      {
        ImageIOLog("‼️ retrying 'getImageCount' (ImageIOXPCService crashed?)\n");
        v2 = (*(uint64_t (**)(_QWORD, const void *, _QWORD *, uint64_t *, char *))(**((_QWORD **)this + 10)
                                                                                          + 24))(*((_QWORD *)this + 10), v4, v14, &v15, (char *)&v15 + 4);
        v10 = "❌";
        if (!HIDWORD(v15))
          v10 = "✅";
        ImageIOLog("%s retrying 'getImageCount'  err: %d\n", v10, HIDWORD(v15));
      }
      v11 = v15;
      pthread_mutex_lock((pthread_mutex_t *)((char *)this + 264));
      *((_DWORD *)this + 22) = v11;
      pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 264));
      CFRelease(v4);
      IIODictionary::~IIODictionary((IIODictionary *)v14);
    }
    else
    {
      v2 = 0;
    }
  }
  else
  {
    IIOXPCLog("✅ ImageIOXPC: XPC_READPLUGIN_IMAGECOUNT skipped - defaults to 1\n");
    v2 = 1;
  }
  *((_QWORD *)this + 3) = v2;
  *((_BYTE *)this + 32) = 1;
  return v2;
}

void sub_187E4B84C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  _Unwind_Resume(a1);
}

__n128 IIOImageSource::setImageMedadataAtIndex(CFArrayRef *this, const CGImageMetadata *a2, CFIndex a3)
{
  unsigned int Count;
  const void *v7;
  __n128 result;

  Count = CFArrayGetCount(this[19]);
  v7 = (const void *)*MEMORY[0x1E0C9B0D0];
  if (!a2)
    a2 = (const CGImageMetadata *)*MEMORY[0x1E0C9B0D0];
  if (a3 < Count)
    goto LABEL_4;
  if (this[3] > a3)
  {
    while (CFArrayGetCount(this[19]) <= a3)
      CFArrayAppendValue(this[19], v7);
LABEL_4:
    CFArraySetValueAtIndex(this[19], a3, a2);
    return result;
  }
  return _cg_jpeg_mem_term("setImageMedadataAtIndex", 3911, "setImageMedadataAtIndex index (%d) larger than arrayCount (%d) and image count (%d)\n", a3, Count, this[3]);
}

void IIODictionary::IIODictionary(IIODictionary *this, CFDictionaryRef theDict, int a3)
{
  __CFDictionary *DeepCopy;

  *(_QWORD *)this = &off_1E1BACDA8;
  if (theDict)
  {
    if (a3)
      DeepCopy = IIODictionaryCreateDeepCopy(theDict);
    else
      DeepCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, theDict);
  }
  else
  {
    DeepCopy = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  }
  *((_QWORD *)this + 1) = DeepCopy;
  *((_BYTE *)this + 16) = 1;
}

__CFDictionary *IIODictionaryCreateDeepCopy(const __CFDictionary *a1)
{
  const __CFAllocator *v2;
  __CFDictionary *DeepCopy;
  CFIndex Count;
  const void **v5;
  const void **v6;
  const void **v7;
  const void **v8;
  CFTypeRef *v9;
  const void **v10;
  CFTypeID v11;
  CFTypeID TypeID;
  CFTypeRef v13;
  __CFArray *v14;
  CFTypeID v15;
  __CFArray *v16;

  if (!a1)
    return 0;
  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  DeepCopy = (__CFDictionary *)CFPropertyListCreateDeepCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, 2uLL);
  if (!DeepCopy)
  {
    Count = CFDictionaryGetCount(a1);
    DeepCopy = CFDictionaryCreateMutable(v2, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (DeepCopy)
    {
      v5 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
      if (v5)
      {
        v6 = v5;
        v7 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
        if (v7)
        {
          v8 = v7;
          CFDictionaryGetKeysAndValues(a1, v6, v7);
          if (Count >= 1)
          {
            v9 = v8;
            v10 = v6;
            while (1)
            {
              v11 = CFGetTypeID(*v9);
              TypeID = CFDictionaryGetTypeID();
              v13 = *v9;
              if (v11 == TypeID)
                break;
              v15 = CFGetTypeID(v13);
              if (v15 != CFArrayGetTypeID())
              {
                CFDictionarySetValue(DeepCopy, *v10, *v9);
                goto LABEL_15;
              }
              v14 = IIOArrayCreateDeepCopy((__CFArray *)*v9);
              if (v14)
                goto LABEL_13;
LABEL_15:
              ++v10;
              ++v9;
              if (!--Count)
                goto LABEL_16;
            }
            v14 = (__CFArray *)IIODictionaryCreateDeepCopy((const __CFDictionary *)v13);
            if (!v14)
              goto LABEL_15;
LABEL_13:
            v16 = v14;
            CFDictionaryAddValue(DeepCopy, *v10, v14);
            CFRelease(v16);
            goto LABEL_15;
          }
LABEL_16:
          free(v6);
        }
        else
        {
          v8 = v6;
        }
        free(v8);
      }
    }
  }
  return DeepCopy;
}

void IIOImageSource::setImagePlusAtIndex(uint64_t a1, const void *a2, CFIndex a3)
{
  unsigned int Count;
  const void *v7;
  const void *v8;
  uint64_t v9;

  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 144));
  v7 = (const void *)*MEMORY[0x1E0C9B0D0];
  if (a2)
    v8 = a2;
  else
    v8 = (const void *)*MEMORY[0x1E0C9B0D0];
  if (a3 >= Count)
  {
    v9 = *(_QWORD *)(a1 + 24);
    if (v9 <= a3)
    {
      _cg_jpeg_mem_term("setImagePlusAtIndex", 3856, "setImagePlusAtIndex index (%d) larger than arrayCount (%d) and image count (%d)\n", a3, Count, v9);
      if (a2)
        CFRetain(a2);
    }
    else
    {
      while (CFArrayGetCount(*(CFArrayRef *)(a1 + 144)) <= a3)
        CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 144), v7);
      CFArraySetValueAtIndex(*(CFMutableArrayRef *)(a1 + 144), a3, v8);
    }
  }
  else
  {
    CFArraySetValueAtIndex(*(CFMutableArrayRef *)(a1 + 144), a3, v8);
    if (!a2)
    {
      IIOImageSource::setImagePropertiesAtIndex((IIOImageSource *)a1, 0, a3);
      IIOImageSource::setImageMedadataAtIndex((CFArrayRef *)a1, 0, a3);
    }
  }
}

_QWORD *CGImageReadSessionCreate(const void *a1)
{
  uint64_t Instance;
  _QWORD *v3;
  unint64_t v4;
  _QWORD *v5;
  int v6;
  IIOImagePlus *Source;
  const void *v8;
  char __str[16];
  __int128 v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (CGImageReadSessionGetTypeID::once != -1)
    dispatch_once(&CGImageReadSessionGetTypeID::once, &__block_literal_global_13);
  Instance = _CFRuntimeCreateInstance();
  v3 = (_QWORD *)Instance;
  if (Instance)
  {
    do
      v4 = __ldxr(&gReadSessionCount);
    while (__stxr(v4 + 1, &gReadSessionCount));
    *(_DWORD *)(Instance + 16) = 1;
    v5 = (_QWORD *)operator new();
    IIOImageReadSession::IIOImageReadSession(v5, (uint64_t)v3, a1);
    v3[3] = v5;
  }
  if ((gIIODebugFlags & 0xC000) != 0)
  {
    *(_OWORD *)__str = 0u;
    v11 = 0u;
    snprintf(__str, 0x20uLL, "(%p)", v3);
    v6 = (unsigned __int16)gIIODebugFlags >> 14;
    if ((unsigned __int16)gIIODebugFlags >> 14)
    {
      Source = (IIOImagePlus *)CGImageSourceGetSource((uint64_t)a1);
      v8 = (const void *)IIOImagePlus::isr(Source);
      ImageIODebugOptions(v6, "S", "CGImageReadSessionCreate", v8, __str, -1, 0);
    }
  }
  return v3;
}

void sub_187E4BE1C(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

_QWORD *IIOImageReadSession::IIOImageReadSession(_QWORD *a1, uint64_t a2, CFTypeRef cf)
{
  CFTypeRef v4;
  IIOImagePlus *Source;

  *a1 = &off_1E1BB1BD0;
  a1[1] = a2;
  v4 = CFRetain(cf);
  a1[3] = v4;
  Source = (IIOImagePlus *)CGImageSourceGetSource((uint64_t)v4);
  a1[4] = Source;
  a1[2] = IIOImagePlus::isr(Source);
  a1[5] = 0;
  a1[6] = a1;
  a1[7] = a1;
  return a1;
}

uint64_t IIOImageSource::bindToReader(IIOImageSource *this)
{
  uint64_t result;
  _BOOL4 isFinal;
  int v4;

  result = CGImageSourceGetSource(*((_QWORD *)this + 2));
  if (result)
  {
    if (*((_BYTE *)this + 65))
    {
      return 0;
    }
    else
    {
      isFinal = IIOImageRead::isFinal((IIOImageRead *)result);
      if (*((_QWORD *)this + 10))
      {
        v4 = isFinal - 1;
        pthread_mutex_lock((pthread_mutex_t *)((char *)this + 264));
        *((_DWORD *)this + 22) = v4;
        pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 264));
        return 1;
      }
      else
      {
        return IIOImageSource::doBindToReader(this);
      }
    }
  }
  return result;
}

BOOL IIOImageRead::isFinal(IIOImageRead *this)
{
  pthread_mutex_t *v2;
  int v3;

  if (*((_BYTE *)this + 65))
  {
    v2 = (pthread_mutex_t *)((char *)this + 376);
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 376));
    v3 = *((unsigned __int8 *)this + 64);
    pthread_mutex_unlock(v2);
  }
  else
  {
    v3 = *((unsigned __int8 *)this + 64);
  }
  return v3 != 0;
}

uint64_t IIOImagePlus::isr(IIOImagePlus *this)
{
  return ~*((_QWORD *)this + 2);
}

void IIOImageSource::getCacheValues(IIOImageSource *this, IIODictionary *a2, BOOL *a3, BOOL *a4)
{
  unsigned __int8 v7;
  unsigned __int8 v8;
  BOOL BoolForKey;
  BOOL v10;
  unsigned int v11;

  v7 = IIODictionary::containsKey(a2, CFSTR("kCGImageSourceShouldCache"));
  v8 = IIODictionary::containsKey(a2, CFSTR("kCGImageSourceShouldCacheImmediately"));
  BoolForKey = IIODictionary::getBoolForKey(a2, CFSTR("kCGImageSourceShouldCache"));
  v10 = IIODictionary::getBoolForKey(a2, CFSTR("kCGImageSourceShouldCacheImmediately"));
  if ((gIIODebugFlags & 0x20000000) != 0)
  {
    if (IIOImageSource::getCacheValues(IIODictionary *,BOOL *,BOOL *)::__onceToken != -1)
      dispatch_once(&IIOImageSource::getCacheValues(IIODictionary *,BOOL *,BOOL *)::__onceToken, &__block_literal_global_3);
    v11 = (gIIODebugFlags >> 30) & 1;
  }
  else
  {
    LOBYTE(v11) = v7 ^ 1 | BoolForKey;
  }
  *a3 = v11;
  *a4 = v8 & v10;
}

uint64_t IIOImageSource::getImagePlus(IIOImageSource *this, unint64_t a2)
{
  unint64_t v4;
  _QWORD *ImagePlusAtIndex;

  v4 = IIOImageSource::updatedCount(this);
  if (v4 <= a2)
  {
    _cg_jpeg_mem_term("getImagePlus", 3380, "index (%d) out of range [0-%d]\n", a2, v4);
  }
  else
  {
    ImagePlusAtIndex = IIOImageSource::getImagePlusAtIndex((CFArrayRef *)this, a2);
    if (ImagePlusAtIndex)
      return ImagePlusAtIndex[3];
    IIOImageSource::setImagePlusAtIndex((uint64_t)this, 0, a2);
  }
  return 0;
}

const void *IIOImageSource::getImagePlusAtIndex(CFArrayRef *this, CFIndex a2)
{
  const void *result;

  if (CFArrayGetCount(this[18]) <= a2)
    return 0;
  result = CFArrayGetValueAtIndex(this[18], a2);
  if (result == (const void *)*MEMORY[0x1E0C9B0D0])
    return 0;
  return result;
}

uint64_t IIOImagePlus::setStatus(uint64_t this, CGImageSourceStatus a2)
{
  if (*(_DWORD *)(this + 136) != -6)
  {
    *(_DWORD *)(this + 136) = a2;
    if (a2 == kCGImageStatusInvalidData)
    {
      this = CGImageSourceGetSource(~*(_QWORD *)(this + 16));
      if (this)
        return IIOImageSource::setStatus((IIOImageSource *)this, kCGImageStatusInvalidData);
    }
  }
  return this;
}

__n128 IIOImageSource::setImagePropertiesAtIndex(IIOImageSource *this, IIODictionary *a2, uint64_t a3)
{
  uint64_t v5;
  void **v6;
  _QWORD *v7;
  unint64_t v8;
  uint64_t v9;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  __n128 result;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v5 = *((_QWORD *)this + 15);
  v7 = (_QWORD *)*((_QWORD *)this + 16);
  v6 = (void **)((char *)this + 120);
  v8 = ((uint64_t)v7 - v5) >> 3;
  if (a3 < v8)
  {
LABEL_2:
    *(_QWORD *)(v5 + 8 * a3) = a2;
    return result;
  }
  v9 = *((_QWORD *)this + 3);
  if (v9 > a3)
  {
    if (v8 <= a3)
    {
      v11 = (_QWORD *)((char *)this + 136);
      do
      {
        if ((unint64_t)v7 >= *v11)
        {
          if ((v8 + 1) >> 61)
            std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
          v12 = *v11 - v5;
          v13 = v12 >> 2;
          if (v12 >> 2 <= v8 + 1)
            v13 = v8 + 1;
          if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
            v14 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v14 = v13;
          if (v14)
            v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)v11, v14);
          else
            v15 = 0;
          v17 = &v15[8 * v8];
          *(_QWORD *)v17 = 0;
          v7 = v17 + 8;
          v19 = (char *)*((_QWORD *)this + 15);
          v18 = (char *)*((_QWORD *)this + 16);
          if (v18 != v19)
          {
            do
            {
              v20 = *((_QWORD *)v18 - 1);
              v18 -= 8;
              *((_QWORD *)v17 - 1) = v20;
              v17 -= 8;
            }
            while (v18 != v19);
            v18 = (char *)*v6;
          }
          *((_QWORD *)this + 15) = v17;
          *((_QWORD *)this + 16) = v7;
          *((_QWORD *)this + 17) = &v15[8 * v14];
          if (v18)
            operator delete(v18);
        }
        else
        {
          *v7++ = 0;
        }
        *((_QWORD *)this + 16) = v7;
        v5 = *((_QWORD *)this + 15);
        v8 = ((uint64_t)v7 - v5) >> 3;
      }
      while (v8 <= a3);
    }
    goto LABEL_2;
  }
  return _cg_jpeg_mem_term("setImagePropertiesAtIndex", 3950, "setImagePropertiesAtIndex index (%d) larger than vectorCount (%d) and image count (%d\n", a3, ((uint64_t)v7 - v5) >> 3, v9);
}

uint64_t IIOPluginShouldDebugWriteImageBlocks()
{
  return 0;
}

uint64_t IIOImagePlus::shouldCacheImageBlocks(IIOImagePlus *this)
{
  return (*((unsigned __int8 *)this + 192) >> 1) & 1;
}

uint64_t IIOImagePlus::setShouldCacheImageBlocks(uint64_t this, int a2)
{
  char v2;

  if (a2)
    v2 = 2;
  else
    v2 = 0;
  *(_BYTE *)(this + 192) = *(_BYTE *)(this + 192) & 0xFD | v2;
  return this;
}

void IIOImagePlus::copyPropertiesToRoot(IIODictionary **this)
{
  CopyTiffPropertiesToRoot(this[14], this[15]);
}

uint64_t CGImagePlusCreateWithSession(const void *a1, uint64_t a2, const __CFDictionary *a3, unint64_t a4)
{
  uint64_t Instance;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char __str[16];
  __int128 v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (CGImagePlusGetTypeID::once != -1)
    dispatch_once(&CGImagePlusGetTypeID::once, &__block_literal_global_5);
  Instance = _CFRuntimeCreateInstance();
  *(_DWORD *)(Instance + 16) = 1;
  do
    v8 = __ldxr(&gImagePlusCount);
  while (__stxr(v8 + 1, &gImagePlusCount));
  v9 = operator new();
  IIOImagePlus::IIOImagePlus(v9, a1, v10, a3);
  *(_QWORD *)(Instance + 24) = v9;
  *(_QWORD *)(v9 + 8) = Instance;
  *(_QWORD *)(v9 + 16) = ~a4;
  if ((gIIODebugFlags & 0xC000) != 0)
  {
    *(_OWORD *)__str = 0u;
    v13 = 0u;
    snprintf(__str, 0x20uLL, "(%p)", (const void *)Instance);
    if ((unsigned __int16)gIIODebugFlags >> 14)
      ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImagePlusCreate", (CFTypeRef)a4, __str, -1, 0);
  }
  return Instance;
}

void sub_187E4C494(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t IIOImagePlus::IIOImagePlus(uint64_t a1, CFTypeRef cf, uint64_t a3, const __CFDictionary *a4)
{
  IIODictionary **v7;
  CFTypeRef v8;
  IIODictionary *v9;
  char v10;
  IIODictionary *v11;

  *(_QWORD *)a1 = &off_1E1BAC210;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_DWORD *)(a1 + 136) = -3;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  strcpy((char *)(a1 + 176), "....");
  *(_QWORD *)(a1 + 184) = 0;
  *(_OWORD *)(a1 + 200) = 0u;
  v7 = (IIODictionary **)(a1 + 200);
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_BYTE *)(a1 + 192) &= 0x80u;
  *(_DWORD *)(a1 + 196) = 0;
  *(_QWORD *)(a1 + 248) = a1;
  *(_QWORD *)(a1 + 256) = a1;
  if (cf)
    v8 = CFRetain(cf);
  else
    v8 = 0;
  *(_QWORD *)(a1 + 24) = v8;
  *(_QWORD *)(a1 + 32) = CGImageSourceGetSource((uint64_t)cf);
  v9 = (IIODictionary *)operator new();
  IIODictionary::IIODictionary(v9, a4);
  *v7 = v9;
  v10 = 2;
  if (!IIODictionary::getBoolForKey(v9, CFSTR("kCGImageSourceShouldCache")))
  {
    if (IIOImageReadSession::isFinal(*(IIOImageReadSession **)(a1 + 32)))
      v10 = 0;
    else
      v10 = 2;
  }
  *(_BYTE *)(a1 + 192) = *(_BYTE *)(a1 + 192) & 0xFD | v10;
  *(_BYTE *)(a1 + 180) = 0;
  v11 = (IIODictionary *)operator new();
  IIODictionary::IIODictionary(v11);
  *(_QWORD *)(a1 + 112) = v11;
  *(_QWORD *)(a1 + 120) = CGImageMetadataCreateMutable();
  IIODictionary::setObjectForKey(*(IIODictionary **)(a1 + 112), (const void *)*MEMORY[0x1E0C9AE50], CFSTR("needsPostProcessing"));
  *(_DWORD *)(a1 + 136) = -3;
  *(_BYTE *)(a1 + 192) &= ~0x40u;
  return a1;
}

void sub_187E4C650(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

CGMutableImageMetadataRef CGImageMetadataCreateMutable(void)
{
  const __CFAllocator *v0;
  uint64_t Instance;
  uint64_t v2;

  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0)
    ImageIODebugOptions(3, "A", "CGImageMetadataCreateMutable", 0, 0, -1, 0);
  v0 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (CGImageMetadataGetTypeID::once != -1)
    dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_20);
  Instance = _CFRuntimeCreateInstance();
  v2 = Instance;
  if (Instance)
  {
    *(_BYTE *)(Instance + 16) = 1;
    *(_QWORD *)(Instance + 24) = CFDictionaryCreateMutable(v0, 0, &kCGImageMetadataTagKeyCallbacks, MEMORY[0x1E0C9B3A0]);
    *(_OWORD *)(v2 + 32) = 0u;
    *(_OWORD *)(v2 + 48) = 0u;
    *(_QWORD *)(v2 + 64) = 0;
    initRecursivePthread_mutex((pthread_mutex_t *)(v2 + 72));
    pthread_mutex_init((pthread_mutex_t *)(v2 + 136), 0);
    initRecursivePthread_mutex((pthread_mutex_t *)(v2 + 208));
  }
  return (CGMutableImageMetadataRef)v2;
}

uint64_t initRecursivePthread_mutex(pthread_mutex_t *a1)
{
  pthread_mutexattr_t v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v3.__sig = 0;
  *(_QWORD *)v3.__opaque = 0;
  pthread_mutexattr_init(&v3);
  pthread_mutexattr_settype(&v3, 2);
  pthread_mutex_init(a1, &v3);
  return pthread_mutexattr_destroy(&v3);
}

uint64_t IIOImagePlus::setShouldCacheImmediately(uint64_t this, int a2)
{
  char v2;

  if (a2)
    v2 = 4;
  else
    v2 = 0;
  *(_BYTE *)(this + 192) = *(_BYTE *)(this + 192) & 0xFB | v2;
  return this;
}

uint64_t IIOReadPlugin::prepareGeometry(uint64_t a1, CFDictionaryRef *a2)
{
  int v4;
  int v5;
  char *v6;
  int v7;
  int v8;
  uint8x8_t v9;
  int16x8_t v10;
  BOOL v11;
  int v12;
  int v13;
  unsigned int v14;
  int v15;
  int v16;
  unsigned int v17;
  unsigned int v18;
  int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  int v25;
  int v26;
  unsigned int v27;
  BOOL v28;
  unsigned int v29;
  unsigned int v30;
  uint64_t v31;
  BOOL v33;
  int16x4_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  unsigned int v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  unsigned int v42;
  int v43;
  uint64_t v44;
  unsigned int v45;
  int v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  _OWORD v50[4];
  uint64_t v51;
  _BYTE v52[24];
  _QWORD v53[3];
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  uint64_t v58;

  v58 = 0;
  v56 = 0u;
  v57 = 0u;
  v54 = 0u;
  v55 = 0u;
  memset(v53, 0, sizeof(v53));
  IIODictionary::IIODictionary((IIODictionary *)v53, *(__CFDictionary **)(a1 + 152));
  if (*(_BYTE *)(a1 + 348))
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 152), CFSTR("kImageIOInfoHeader_supportsMultipleResolutions"), (const void *)*MEMORY[0x1E0C9AE50]);
  if (*(_BYTE *)(a1 + 350))
  {
    v4 = (*(unsigned __int8 *)(a1 + 279) << 12) | (*(unsigned __int8 *)(a1 + 280) << 16) | ((*(_BYTE *)(a1 + 281) != 0) << 8) | *(unsigned __int8 *)(a1 + 278);
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      v5 = *(unsigned __int16 *)(a1 + 272);
      v6 = IIO_BitmapInfoString(v4);
      ImageIOLog("◇⃟   createImageProviderWithBitmapInfo[decodedGeo]: bpc=%d  '%08X' %s\n", v5, v4, v6);
    }
    IIONumber::IIONumber((IIONumber *)v52, v4);
    IIODictionary::setObjectForKey((uint64_t)v53, (uint64_t)v52, CFSTR("kImageIOInfoHeader_createImageProviderWithBitmapInfo"));
    IIONumber::~IIONumber((IIONumber *)v52);
  }
  IIOReadPlugin::updateColorSpace(a1, a2);
  v7 = *(unsigned __int16 *)(a1 + 244);
  v8 = *(unsigned __int8 *)(a1 + 278);
  switch(CGColorSpaceGetModel(*(CGColorSpaceRef *)(a1 + 160)))
  {
    case kCGColorSpaceModelMonochrome:
      v11 = v8 == 0;
      v12 = 1;
      goto LABEL_11;
    case kCGColorSpaceModelRGB:
    case kCGColorSpaceModelLab:
      v11 = v8 == 0;
      v12 = 3;
      goto LABEL_11;
    case kCGColorSpaceModelCMYK:
      v11 = v8 == 0;
      v12 = 4;
LABEL_11:
      if (!v11)
        ++v12;
      break;
    default:
      if (v8)
        v33 = v7 == 0;
      else
        v33 = 1;
      if (v33)
        v12 = v7;
      else
        v12 = v7 + 1;
      break;
  }
  v13 = *(unsigned __int16 *)(a1 + 276);
  if (v13 == 3)
  {
    v13 = 4;
    if (*(_BYTE *)(a1 + 278))
      *(_WORD *)(a1 + 276) = 4;
  }
  v14 = *(_DWORD *)(a1 + 236);
  v15 = *(_DWORD *)(a1 + 228);
  if (!v14)
  {
    v14 = v15 * v12 * ((*(unsigned __int16 *)(a1 + 240) + 7) >> 3);
    *(_DWORD *)(a1 + 236) = v14;
  }
  v16 = *(_DWORD *)(a1 + 232);
  if (v15
    && v16
    && (v17 = *(unsigned __int16 *)(a1 + 242), *(_WORD *)(a1 + 242))
    && (v18 = *(unsigned __int16 *)(a1 + 240), *(_WORD *)(a1 + 240))
    && v14)
  {
    v19 = *(unsigned __int16 *)(a1 + 244);
    if (!*(_WORD *)(a1 + 244))
    {
      v19 = v17 / v18;
      *(_WORD *)(a1 + 244) = v17 / v18;
    }
    v20 = *(_DWORD *)(a1 + 260);
    if (!v20)
    {
      *(_DWORD *)(a1 + 260) = v15;
      v20 = v15;
    }
    v21 = *(_DWORD *)(a1 + 264);
    if (!v21)
    {
      *(_DWORD *)(a1 + 264) = v16;
      v21 = v16;
    }
    v22 = *(unsigned __int16 *)(a1 + 272);
    if (!*(_WORD *)(a1 + 272))
    {
      *(_WORD *)(a1 + 272) = v18;
      v22 = v18;
    }
    v23 = *(unsigned __int16 *)(a1 + 274);
    if (!*(_WORD *)(a1 + 274))
    {
      *(_WORD *)(a1 + 274) = v17;
      v23 = v17;
    }
    if (!v13)
      *(_WORD *)(a1 + 276) = v19;
    v24 = *(unsigned __int8 *)(a1 + 280);
    v25 = *(unsigned __int8 *)(a1 + 278);
    if (!((*(unsigned __int8 *)(a1 + 279) << 12) | (v24 << 16) | ((*(_BYTE *)(a1 + 281) != 0) << 8) | v25))
    {
      v26 = *(unsigned __int8 *)(a1 + 247);
      v27 = (v26 << 12) | (*(unsigned __int8 *)(a1 + 248) << 16);
      v28 = *(_BYTE *)(a1 + 249) != 0;
      v25 = *(_BYTE *)(a1 + 246) & 0x1F;
      *(_BYTE *)(a1 + 278) = v25;
      *(_BYTE *)(a1 + 279) = v26 & 7;
      v24 = HIWORD(v27) & 0xF;
      *(_BYTE *)(a1 + 280) = v24;
      *(_BYTE *)(a1 + 281) = v28;
    }
    v29 = (((v23 + 7) >> 3) * v20 + 3) & 0xFFFFFFFC;
    if (*(unsigned __int16 *)(a1 + 316) > 1u)
    {
      v30 = *(_DWORD *)(a1 + 268);
      if (v30 < v29)
      {
        if (v29 <= v14)
          v30 = v14;
        else
          v30 = (((v23 + 7) >> 3) * v20 + 3) & 0xFFFFFFFC;
        *(_DWORD *)(a1 + 268) = v30;
      }
    }
    else if (*(_BYTE *)(a1 + 349))
    {
      *(_DWORD *)(a1 + 268) = v14;
      v30 = v14;
    }
    else
    {
      v30 = *(_DWORD *)(a1 + 268);
      if (v30 < v29)
      {
        *(_DWORD *)(a1 + 268) = v29;
        v30 = (((v23 + 7) >> 3) * v20 + 3) & 0xFFFFFFFC;
      }
    }
    *(_QWORD *)&v54 = v20;
    *((_QWORD *)&v54 + 1) = v21;
    *(_QWORD *)&v55 = v22;
    *((_QWORD *)&v55 + 1) = v23;
    *(_QWORD *)&v56 = v30;
    DWORD2(v56) = *(_DWORD *)(a1 + 324);
    *(_QWORD *)&v57 = *(_QWORD *)(a1 + 160);
    DWORD2(v57) = v25;
    HIDWORD(v57) = v24 << 16;
    v9.i32[0] = *(_DWORD *)(a1 + 344);
    v34 = (int16x4_t)vmovl_u8(v9).u64[0];
    v10.i32[0] = vrev32_s16(v34).u32[0];
    v10.i32[1] = v34.i32[1];
    LODWORD(v58) = vmovn_s16(v10).u32[0];
    if (!v19)
      *(_WORD *)(a1 + 244) = v17 / v18;
    v35 = *(_QWORD *)(a1 + 16);
    if (v35)
    {
      IIOImagePlus::setReadPlugin(v35, (_DWORD *)a1);
      v36 = *(_QWORD *)(a1 + 16);
      v50[2] = v56;
      v50[3] = v57;
      v51 = v58;
      v50[0] = v54;
      v50[1] = v55;
      IIOImagePlus::setGeometry(v36, (CFTypeRef *)a2, (uint64_t)v50);
      if ((gIIODebugFlags & 0x30000) != 0)
      {
        v37 = *(_DWORD *)(a1 + 204);
        v38 = v37 >> 24;
        v39 = MEMORY[0x1E0C80978];
        if (v37 < 0)
        {
          v40 = __maskrune(v38, 0x40000uLL);
          v37 = *(_DWORD *)(a1 + 204);
        }
        else
        {
          v40 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v38 + 60) & 0x40000;
        }
        if (v40)
          v41 = (v37 >> 24);
        else
          v41 = 46;
        v42 = v37 << 8 >> 24;
        if (v37 << 8 < 0)
        {
          v43 = __maskrune(v42, 0x40000uLL);
          v37 = *(_DWORD *)(a1 + 204);
        }
        else
        {
          v43 = *(_DWORD *)(v39 + 4 * v42 + 60) & 0x40000;
        }
        if (v43)
          v44 = (v37 << 8 >> 24);
        else
          v44 = 46;
        v45 = (__int16)v37 >> 8;
        if (v37 << 16 < 0)
        {
          v46 = __maskrune(v45, 0x40000uLL);
          v37 = *(_DWORD *)(a1 + 204);
        }
        else
        {
          v46 = *(_DWORD *)(v39 + 4 * v45 + 60) & 0x40000;
        }
        if (v46)
          v47 = ((__int16)v37 >> 8);
        else
          v47 = 46;
        if ((v37 << 24) <= 0x7F000000)
          v48 = *(_DWORD *)(v39 + 4 * (char)v37 + 60) & 0x40000;
        else
          v48 = __maskrune((char)v37, 0x40000uLL);
        if (v48)
          v49 = *(char *)(a1 + 204);
        else
          v49 = 46;
        ImageIOLog("♦️  '%c%c%c%c' IIOReadPlugin::prepareGeometry\n", v41, v44, v47, v49);
        IIOReadPlugin::debugGeometry(a1, &v54, (IIODictionary *)v53);
      }
    }
    v31 = 0;
  }
  else
  {
    _cg_jpeg_mem_term("prepareGeometry", 927, "*** input-size: %d x %d   rb: %d    bpp: %d      bpc: %d\n", v15, v16, v14, *(unsigned __int16 *)(a1 + 242), *(unsigned __int16 *)(a1 + 240));
    v31 = 4294967246;
  }
  IIODictionary::~IIODictionary((IIODictionary *)v53);
  return v31;
}

void sub_187E4CD24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,char a28)
{
  IIONumber::~IIONumber((IIONumber *)&a25);
  IIODictionary::~IIODictionary((IIODictionary *)&a28);
  _Unwind_Resume(a1);
}

void IIODictionary::IIODictionary(IIODictionary *this, CFTypeRef cf)
{
  CFTypeID v4;
  void *Mutable;
  char v6;

  *(_QWORD *)this = &off_1E1BACDA8;
  if (cf)
  {
    v4 = CFGetTypeID(cf);
    if (v4 != CFDictionaryGetTypeID())
    {
      IIOLogTypeMismatch(cf, "IIODictionary", "CFDictionaryRef");
      v6 = 0;
      *((_QWORD *)this + 1) = 0;
      goto LABEL_7;
    }
    Mutable = (void *)CFRetain(cf);
  }
  else
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  }
  *((_QWORD *)this + 1) = Mutable;
  v6 = 1;
LABEL_7:
  *((_BYTE *)this + 16) = v6;
}

{
  CFTypeID v4;
  CFTypeRef v5;
  char v6;

  *(_QWORD *)this = &off_1E1BACDA8;
  if (cf)
  {
    v4 = CFGetTypeID(cf);
    if (v4 == CFDictionaryGetTypeID())
    {
      v5 = CFRetain(cf);
      v6 = 0;
      *((_QWORD *)this + 1) = v5;
    }
    else
    {
      IIOLogTypeMismatch(cf, "IIODictionary", "CFDictionaryRef");
      v6 = 0;
      *((_QWORD *)this + 1) = 0;
    }
  }
  else
  {
    *((_QWORD *)this + 1) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v6 = 1;
  }
  *((_BYTE *)this + 16) = v6;
}

void IIOImagePlus::setGeometry(uint64_t a1, CFTypeRef *a2, uint64_t a3)
{
  const __CFDictionary *v4;
  CFTypeID v7;
  _OWORD *v8;
  CGColorSpace *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  CGColorSpace *v18;
  int Type;
  CGColorSpaceModel Model;
  CGColorSpace *BaseColorSpace;
  CGColorSpaceModel v22;
  const void *v23;
  unsigned int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  int v35;
  uint64_t v36;
  unsigned int v37;
  int v38;
  uint64_t v39;
  unsigned int v40;
  int v41;
  uint64_t v42;
  int v43;
  int v44;
  int v45;
  unsigned int v46;
  int v47;
  uint64_t v48;
  unsigned int v49;
  int v50;
  uint64_t v51;
  unsigned int v52;
  int v53;
  uint64_t v54;
  int v55;
  CFStringRef Name;
  const char *v57;
  int v58;
  int v59;
  const void **v60;
  const void *v61;
  void *Lab;
  void *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  uint64_t v68;
  _BYTE v69[24];
  _BYTE v70[24];
  _BYTE v71[24];
  CGFloat range[2];
  __int128 v73;
  CGFloat blackPoint[3];
  CGFloat whitePoint[2];
  uint64_t v76;
  uint64_t v77;

  v77 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v4 = (const __CFDictionary *)*a2;
    if (!*a2 || (v7 = CFGetTypeID(*a2), v7 != CFDictionaryGetTypeID()))
    {
      LogFault("setGeometry", 745, "*** ERROR: ImageIO 'CGImagePlusSetGeometry' header is not a CFDictionary...\n");
      exit(0);
    }
    *(_QWORD *)(a1 + 160) = a2;
    pthread_mutex_lock(&ipGeomLock);
    v8 = (_OWORD *)(a1 + 40);
    v9 = *(CGColorSpace **)(a1 + 88);
    if (v9)
      CGColorSpaceRelease(v9);
    pthread_mutex_unlock(&ipGeomLock);
    *v8 = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
    *(_OWORD *)(a1 + 72) = 0u;
    *(_OWORD *)(a1 + 88) = 0u;
    *(_QWORD *)(a1 + 104) = 0;
    if ((unint64_t)(*(_QWORD *)a3 - 1) < 0xF4240 && (unint64_t)(*(_QWORD *)(a3 + 8) - 1) < 0xF4240)
    {
      v10 = *(_QWORD *)(a3 + 16);
      if (v10 - 1 <= 0x1F)
      {
        v11 = *(_QWORD *)(a3 + 24);
        if (v11 >= v10 && v11 - 641 >= 0xFFFFFFFFFFFFFD80)
        {
          v12 = v11 * *(_QWORD *)a3 + 7;
          v13 = v12 >> 3;
          v14 = *(_QWORD *)(a3 + 32);
          if (!v14)
          {
            v14 = ImageIOAlignRowBytes(v12 >> 3, 0x10uLL);
            *(_QWORD *)(a3 + 32) = v14;
          }
          if (v14 > 0x4C4B400)
          {
            _cg_jpeg_mem_term("setGeometry", 778, "*** geom.bytesPerRow > maxRB  %d > %d\n");
            return;
          }
          if (v14 < v13)
          {
            _cg_jpeg_mem_term("setGeometry", 783, "*** geom.bytesPerRow < minRB  %d < %d\n");
            return;
          }
          if (is_mul_ok(*(_QWORD *)(a3 + 8), v14))
          {
            pthread_mutex_lock(&ipGeomLock);
            *v8 = *(_OWORD *)a3;
            v16 = *(_OWORD *)(a3 + 32);
            v15 = *(_OWORD *)(a3 + 48);
            v17 = *(_OWORD *)(a3 + 16);
            *(_QWORD *)(a1 + 104) = *(_QWORD *)(a3 + 64);
            *(_OWORD *)(a1 + 72) = v16;
            *(_OWORD *)(a1 + 88) = v15;
            *(_OWORD *)(a1 + 56) = v17;
            pthread_mutex_unlock(&ipGeomLock);
            v18 = *(CGColorSpace **)(a3 + 48);
            if (v18)
            {
              Type = CGColorSpaceGetType();
              Model = CGColorSpaceGetModel(v18);
              if (Type == 7)
              {
                BaseColorSpace = CGColorSpaceGetBaseColorSpace(v18);
                Type = CGColorSpaceGetType();
                v22 = CGColorSpaceGetModel(BaseColorSpace);
                IIODictionary::setObjectForKey(*(IIODictionary **)(a1 + 112), (const void *)*MEMORY[0x1E0C9AE50], CFSTR("IsIndexed"));
              }
              else
              {
                v22 = Model;
              }
              if (Type == 10 || Type == 6)
              {
                v23 = (const void *)CGColorSpaceCopyICCProfileDescription();
                IIODictionary::setObjectForKey(*(IIODictionary **)(a1 + 112), v23, CFSTR("ProfileName"));
                if (v23)
                  CFRelease(v23);
              }
              if (v22 > kCGColorSpaceModelXYZ)
                v24 = 0;
              else
                v24 = *(_DWORD *)&aYargBgrkymcBal[4 * v22];
              v25 = *(_DWORD *)(a3 + 40);
              if (!v25)
              {
                *(_DWORD *)(a3 + 40) = v24;
                v25 = v24;
              }
              if (v24 != v25)
              {
                v26 = MEMORY[0x1E0C80978];
                v27 = MEMORY[0x1E0C80978] + 60;
                if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 60 + 4 * HIBYTE(v24)) & 0x40000) != 0)
                  v28 = HIBYTE(v24);
                else
                  v28 = 46;
                v29 = HIWORD(v24) & 0x7F;
                if ((*(_DWORD *)(v27 + 4 * v29) & 0x40000) != 0)
                  v30 = v29;
                else
                  v30 = 46;
                v31 = (v24 >> 8) & 0x7B;
                if ((*(_DWORD *)(v27 + 4 * v31) & 0x40000) != 0)
                  v32 = v31;
                else
                  v32 = 46;
                LODWORD(v33) = v24 & 0x7B;
                if ((*(_DWORD *)(v27 + 4 * v33) & 0x40000) != 0)
                  v33 = v33;
                else
                  v33 = 46;
                v68 = v33;
                v34 = v25 >> 24;
                if (v25 < 0)
                {
                  v35 = __maskrune(v34, 0x40000uLL);
                  v25 = *(_DWORD *)(a3 + 40);
                }
                else
                {
                  v35 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v34 + 60) & 0x40000;
                }
                if (v35)
                  v36 = (v25 >> 24);
                else
                  v36 = 46;
                v37 = v25 << 8 >> 24;
                if (v25 << 8 < 0)
                {
                  v38 = __maskrune(v37, 0x40000uLL);
                  v25 = *(_DWORD *)(a3 + 40);
                }
                else
                {
                  v38 = *(_DWORD *)(v26 + 4 * v37 + 60) & 0x40000;
                }
                if (v38)
                  v39 = (v25 << 8 >> 24);
                else
                  v39 = 46;
                v40 = (__int16)v25 >> 8;
                if (v25 << 16 < 0)
                {
                  v41 = __maskrune(v40, 0x40000uLL);
                  v25 = *(_DWORD *)(a3 + 40);
                }
                else
                {
                  v41 = *(_DWORD *)(v26 + 4 * v40 + 60) & 0x40000;
                }
                if (v41)
                  v42 = ((__int16)v25 >> 8);
                else
                  v42 = 46;
                if ((v25 << 24) <= 0x7F000000)
                  v43 = *(_DWORD *)(v26 + 4 * (char)v25 + 60) & 0x40000;
                else
                  v43 = __maskrune((char)v25, 0x40000uLL);
                if (v43)
                  v44 = *(_DWORD *)(a3 + 40);
                else
                  LOBYTE(v44) = 46;
                _cg_jpeg_mem_term("setGeometry", 846, "embedded profile '%c%c%c%c' does not match expected color model '%c%c%c%c'\n", v28, v30, v32, v68, v36, v39, v42, (char)v44);
                *(_QWORD *)(a3 + 48) = 0;
              }
            }
            if ((gIIODebugFlags & 0x8000300000) == 0)
            {
LABEL_95:
              v58 = *(_DWORD *)(a3 + 40);
              if (v58 <= 1281450527)
              {
                if (v58 == 1129142603)
                  goto LABEL_103;
                v59 = 1196573017;
              }
              else
              {
                if (v58 == 1281450528 || v58 == 1380401696)
                  goto LABEL_103;
                v59 = 1482250784;
              }
              if (v58 != v59)
              {
                LogError("setGeometry", 859, "*** ERROR: image is not of a supported color model (%d)\n", *(_DWORD *)(a3 + 40));
                v58 = *(_DWORD *)(a3 + 40);
              }
LABEL_103:
              if (v58 > 1281450527)
              {
                if (v58 == 1281450528)
                {
                  v60 = (const void **)&kCGImagePropertyColorModelLab;
                }
                else
                {
                  if (v58 != 1380401696)
                    goto LABEL_113;
                  v60 = (const void **)&kCGImagePropertyColorModelRGB;
                }
              }
              else if (v58 == 1129142603)
              {
                v60 = (const void **)&kCGImagePropertyColorModelCMYK;
              }
              else
              {
                if (v58 != 1196573017)
                  goto LABEL_113;
                v60 = (const void **)&kCGImagePropertyColorModelGray;
              }
              IIODictionary::setObjectForKey(*(IIODictionary **)(a1 + 112), *v60, CFSTR("ColorModel"));
LABEL_113:
              v61 = *(const void **)(a3 + 48);
              if (v61)
              {
                Lab = (void *)CFRetain(v61);
LABEL_115:
                v63 = Lab;
                goto LABEL_116;
              }
              v63 = 0;
              v67 = *(_DWORD *)(a3 + 40);
              if (v67 > 1281450527)
              {
                if (v67 == 1281450528)
                {
                  *(_OWORD *)whitePoint = xmmword_18820F988;
                  v76 = 0x3FEA6594AF4F0D84;
                  memset(blackPoint, 0, sizeof(blackPoint));
                  *(_OWORD *)range = xmmword_18820F9A0;
                  v73 = unk_18820F9B0;
                  Lab = CGColorSpaceCreateLab(whitePoint, blackPoint, range);
                  goto LABEL_115;
                }
                if (v67 == 1380401696)
                {
                  Lab = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
                  goto LABEL_115;
                }
              }
              else
              {
                if (v67 == 1129142603)
                {
                  Lab = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D968]);
                  goto LABEL_115;
                }
                if (v67 == 1196573017)
                {
                  Lab = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D978]);
                  goto LABEL_115;
                }
              }
LABEL_116:
              pthread_mutex_lock(&ipGeomLock);
              *(_QWORD *)(a1 + 88) = v63;
              if (*(_BYTE *)(a1 + 180) && !CFDictionaryContainsValue(v4, CFSTR("kIsAdobeRGB")))
                *(_BYTE *)(a1 + 180) = 0;
              pthread_mutex_unlock(&ipGeomLock);
              v64 = *(_QWORD *)(a1 + 112);
              IIONumber::IIONumber((IIONumber *)v71, *(_QWORD *)a3);
              IIODictionary::setObjectForKey(v64, (uint64_t)v71, CFSTR("PixelWidth"));
              IIONumber::~IIONumber((IIONumber *)v71);
              v65 = *(_QWORD *)(a1 + 112);
              IIONumber::IIONumber((IIONumber *)v70, *(_QWORD *)(a3 + 8));
              IIODictionary::setObjectForKey(v65, (uint64_t)v70, CFSTR("PixelHeight"));
              IIONumber::~IIONumber((IIONumber *)v70);
              if ((IIODictionary::containsKey(*(IIODictionary **)(a1 + 112), CFSTR("Depth")) & 1) == 0)
              {
                v66 = *(_QWORD *)(a1 + 112);
                IIONumber::IIONumber((IIONumber *)v69, *(_QWORD *)(a3 + 16));
                IIODictionary::setObjectForKey(v66, (uint64_t)v69, CFSTR("Depth"));
                IIONumber::~IIONumber((IIONumber *)v69);
              }
              if ((*(_DWORD *)(a3 + 56) & 0x1Fu) > 6 || ((1 << (*(_DWORD *)(a3 + 56) & 0x1F)) & 0x61) == 0)
                IIODictionary::setObjectForKey(*(IIODictionary **)(a1 + 112), (const void *)*MEMORY[0x1E0C9AE50], CFSTR("HasAlpha"));
              if (*(_BYTE *)(a3 + 64))
                IIODictionary::setObjectForKey(*(IIODictionary **)(a1 + 112), (const void *)*MEMORY[0x1E0C9AE50], CFSTR("IsFloat"));
              if (*(_DWORD *)(a1 + 136) != -6)
                *(_DWORD *)(a1 + 136) = -1;
              return;
            }
            v45 = *(_DWORD *)(a1 + 176);
            v46 = v45 >> 24;
            if (v45 < 0)
            {
              v47 = __maskrune(v46, 0x40000uLL);
              v45 = *(_DWORD *)(a1 + 176);
            }
            else
            {
              v47 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v46 + 60) & 0x40000;
            }
            if (v47)
              v48 = (v45 >> 24);
            else
              v48 = 46;
            v49 = v45 << 8 >> 24;
            if (v45 << 8 < 0)
            {
              v50 = __maskrune(v49, 0x40000uLL);
              v45 = *(_DWORD *)(a1 + 176);
            }
            else
            {
              v50 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v49 + 60) & 0x40000;
            }
            if (v50)
              v51 = (v45 << 8 >> 24);
            else
              v51 = 46;
            v52 = (__int16)v45 >> 8;
            if (v45 << 16 < 0)
            {
              v53 = __maskrune(v52, 0x40000uLL);
              v45 = *(_DWORD *)(a1 + 176);
            }
            else
            {
              v53 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v52 + 60) & 0x40000;
            }
            if (v53)
              v54 = ((__int16)v45 >> 8);
            else
              v54 = 46;
            if ((v45 << 24) <= 0x7F000000)
            {
              if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v45 + 60) & 0x40000) != 0)
                goto LABEL_91;
            }
            else if (__maskrune((char)v45, 0x40000uLL))
            {
LABEL_91:
              v55 = *(_DWORD *)(a1 + 176);
LABEL_94:
              Name = CGColorSpaceGetName(*(CGColorSpaceRef *)(a3 + 48));
              IIOString::IIOString((IIOString *)range, Name);
              v57 = (const char *)IIOString::utf8String((IIOString *)range);
              ImageIOLog("COL setGeometry - '%c%c%c%c' using colorSpace: '%s'\n", v48, v51, v54, (char)v55, v57);
              IIOString::~IIOString((IIOString *)range);
              goto LABEL_95;
            }
            LOBYTE(v55) = 46;
            goto LABEL_94;
          }
        }
      }
    }
  }
}

void sub_187E4D770(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOImagePlus::setReadPlugin(uint64_t this, _DWORD *a2)
{
  *(_QWORD *)(this + 168) = a2;
  if (a2)
    *(_DWORD *)(this + 176) = a2[51];
  return this;
}

void IIOImagePlus::setImageBlockProc(uint64_t a1, CFTypeRef *a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  __CFDictionary *v19;
  uint64_t *v20;
  CFTypeID v21;
  CGColorSpace *v22;
  CGColorSpaceModel Model;
  const void *v24;
  const void *v25;
  const void *v26;
  const void *v27;
  unint64_t v28;
  int v29;
  const __CFDictionary *ObjectForKey;
  unsigned int Uint32ForKey;
  const __CFString *v32;
  int v33;
  const char *v34;
  _BOOL4 BoolForKey;
  const void *SourceImageProvider;
  const void *v37;
  _BYTE v38[16];
  void *value;
  _QWORD v40[3];
  _BYTE v41[24];
  _BYTE v42[24];
  _BYTE v43[24];
  _BYTE v44[24];
  _BYTE v45[24];
  _BYTE v46[24];
  _BYTE v47[24];
  _QWORD v48[3];

  IIOImagePlus::releaseImageProvider((IIOImagePlus *)a1);
  v16 = operator new();
  IIOImageProviderInfo::IIOImageProviderInfo(v16, a1, v17, a3, a4, a5, a6, a7, a8);
  v18 = (uint64_t *)malloc_type_calloc(8uLL, 1uLL, 0xA6ABC36AuLL);
  *v18 = v16;
  v19 = (__CFDictionary *)*a2;
  if (!*a2 || (v20 = v18, v21 = CFGetTypeID(*a2), v21 != CFDictionaryGetTypeID()))
  {
    LogFault("setImageBlockProc", 1171, "header '%p' is not a CFDictionary...\n", v19);
    exit(0);
  }
  memset(v48, 0, sizeof(v48));
  IIODictionary::IIODictionary((IIODictionary *)v48, v19);
  v22 = *(CGColorSpace **)(a1 + 88);
  Model = CGColorSpaceGetModel(v22);
  CFDictionarySetValue(v19, CFSTR("kImageIOInfoHeader_plugin"), *(const void **)(a1 + 8));
  IIONumber::IIONumber((IIONumber *)v47, *(_QWORD *)(a1 + 56));
  IIODictionary::setObjectForKey((uint64_t)v48, (uint64_t)v47, CFSTR("kImageIOInfoHeader_bitsPerComponent"));
  IIONumber::~IIONumber((IIONumber *)v47);
  IIONumber::IIONumber((IIONumber *)v46, *(_QWORD *)(a1 + 64));
  IIODictionary::setObjectForKey((uint64_t)v48, (uint64_t)v46, CFSTR("kImageIOInfoHeader_bitsPerPixel"));
  IIONumber::~IIONumber((IIONumber *)v46);
  IIONumber::IIONumber((IIONumber *)v45, *(_QWORD *)(a1 + 48));
  IIODictionary::setObjectForKey((uint64_t)v48, (uint64_t)v45, CFSTR("kImageIOInfoHeader_imageHeight"));
  IIONumber::~IIONumber((IIONumber *)v45);
  IIONumber::IIONumber((IIONumber *)v44, *(_QWORD *)(a1 + 40));
  IIODictionary::setObjectForKey((uint64_t)v48, (uint64_t)v44, CFSTR("kImageIOInfoHeader_imageWidth"));
  IIONumber::~IIONumber((IIONumber *)v44);
  IIONumber::IIONumber((IIONumber *)v43, *(_QWORD *)(a1 + 72));
  IIODictionary::setObjectForKey((uint64_t)v48, (uint64_t)v43, CFSTR("kImageIOInfoHeader_rowBytes"));
  IIONumber::~IIONumber((IIONumber *)v43);
  v24 = (const void *)*MEMORY[0x1E0C9AE50];
  v25 = (const void *)*MEMORY[0x1E0C9AE40];
  if (*(_BYTE *)(a1 + 105))
    v26 = (const void *)*MEMORY[0x1E0C9AE50];
  else
    v26 = (const void *)*MEMORY[0x1E0C9AE40];
  IIODictionary::setObjectForKey((IIODictionary *)v48, v26, CFSTR("kImageIOInfoHeader_isLittleEndian"));
  if (*(_BYTE *)(a1 + 104))
    v27 = v24;
  else
    v27 = v25;
  IIODictionary::setObjectForKey((IIODictionary *)v48, v27, CFSTR("kImageIOInfoHeader_isFloat"));
  IIONumber::IIONumber((IIONumber *)v42, Model);
  IIODictionary::setObjectForKey((uint64_t)v48, (uint64_t)v42, CFSTR("kImageIOInfoHeader_colorspaceModel"));
  IIONumber::~IIONumber((IIONumber *)v42);
  IIONumber::IIONumber((IIONumber *)v41, *(unsigned int *)(a1 + 96));
  IIODictionary::setObjectForKey((uint64_t)v48, (uint64_t)v41, CFSTR("kImageIOInfoHeader_alphaInfo"));
  IIONumber::~IIONumber((IIONumber *)v41);
  memset(v40, 0, sizeof(v40));
  IIODictionary::IIODictionary((IIODictionary *)v40);
  v28 = *(_QWORD *)(a1 + 56);
  if (v28 < 9)
  {
    v29 = 1;
    goto LABEL_21;
  }
  if (v28 == 10)
  {
    if (*(_DWORD *)(a1 + 100) == 196608)
    {
      v29 = 6;
      goto LABEL_21;
    }
    goto LABEL_15;
  }
  if (v28 <= 0x10)
  {
LABEL_15:
    if (*(_BYTE *)(a1 + 104))
      v29 = 5;
    else
      v29 = 2;
    goto LABEL_21;
  }
  if (*(_BYTE *)(a1 + 104))
    v29 = 4;
  else
    v29 = 3;
LABEL_21:
  if (IIODictionary::containsKey((IIODictionary *)v48, CFSTR("kImageIOInfoHeader_createImageProviderWithBitmapInfo")))
  {
    ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v48, CFSTR("kImageIOInfoHeader_createImageProviderWithBitmapInfo"));
    Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v48, CFSTR("kImageIOInfoHeader_createImageProviderWithBitmapInfo"));
    v32 = (const __CFString *)*MEMORY[0x1E0C9DAF8];
    IIODictionary::setObjectForKey((IIODictionary *)v40, ObjectForKey, (const __CFString *)*MEMORY[0x1E0C9DAF8]);
    v33 = Uint32ForKey & 0x7000;
    if (v29 != 5 || v33 == 4096)
    {
      v34 = "kCGImageProviderBitmapInfo";
      if (v29 == 4 && v33 != 0x2000)
      {
        LogError("setImageBlockProc", 1230, "*** ERROR: ImageIO is trying to use unsupported bitmapInfo '0x%08x' for float\n", Uint32ForKey);
        IIONumber::IIONumber((IIONumber *)v38, Uint32ForKey & 0xFFFF8FFF | 0x2000);
        IIODictionary::setObjectForKey((IIODictionary *)v40, value, v32);
        IIONumber::~IIONumber((IIONumber *)v38);
      }
    }
    else
    {
      LogError("setImageBlockProc", 1221, "*** ERROR: ImageIO is trying to use unsupported bitmapInfo '0x%08x' for __fp16\n", Uint32ForKey);
      IIONumber::IIONumber((IIONumber *)v38, Uint32ForKey & 0xFFFF8FFF | 0x1000);
      IIODictionary::setObjectForKey((IIODictionary *)v40, value, v32);
      IIONumber::~IIONumber((IIONumber *)v38);
      v34 = "kCGImageProviderBitmapInfo";
    }
  }
  else
  {
    v32 = 0;
    v34 = "";
    switch(*(_DWORD *)(a1 + 96) & 0x1F)
    {
      case 0:
        break;
      case 1:
      case 2:
        IIODictionary::setObjectForKey((IIODictionary *)v40, v24, CFSTR("kCGImageProviderAlphaIsPremultiplied"));
        if ((gIIODebugFlags & 0x800) != 0)
          ImageIOLog("  CGImageProviderCreate - kCGImageProviderAlphaIsPremultiplied\n");
        v34 = "kCGImageProviderAlphaIsPremultiplied";
        v32 = CFSTR("kCGImageProviderAlphaIsPremultiplied");
        break;
      case 3:
      case 4:
        IIODictionary::setObjectForKey((IIODictionary *)v40, v24, CFSTR("kCGImageProviderAlphaIsNotPremultiplied"));
        if ((gIIODebugFlags & 0x800) != 0)
          ImageIOLog("  CGImageProviderCreate - kCGImageProviderAlphaIsNotPremultiplied\n");
        v34 = "kCGImageProviderAlphaIsNotPremultiplied";
        v32 = CFSTR("kCGImageProviderAlphaIsNotPremultiplied");
        break;
      case 5:
      case 6:
        IIODictionary::setObjectForKey((IIODictionary *)v40, v24, CFSTR("kCGImageProviderAlphaIsOne"));
        if ((gIIODebugFlags & 0x800) != 0)
          ImageIOLog("  CGImageProviderCreate - kCGImageProviderAlphaIsOne\n");
        v34 = "kCGImageProviderAlphaIsOne";
        v32 = CFSTR("kCGImageProviderAlphaIsOne");
        break;
      default:
        _cg_jpeg_mem_term("setImageBlockProc", 1245, "*** ERROR: unknown alphaInfo [0x%02X]\n", *(_DWORD *)(a1 + 96) & 0x1F);
        v32 = 0;
        v34 = "";
        break;
    }
  }
  BoolForKey = IIODictionary::getBoolForKey((IIODictionary *)v48, CFSTR("kImageIOInfoHeader_supportsMultipleResolutions"));
  if (BoolForKey)
    IIODictionary::setObjectForKey((IIODictionary *)v40, v24, (const __CFString *)*MEMORY[0x1E0C9DB00]);
  SourceImageProvider = IIOImagePlus::createSourceImageProvider(a1, v29, (uint64_t)v22, v20);
  v37 = SourceImageProvider;
  if ((gIIODebugFlags & 0x40000000000) != 0)
    printf("    <CGImageProviderRef:%p> %s\n", SourceImageProvider, v34);
  if (v37)
  {
    if (IIODictionary::getObjectForKey((IIODictionary *)v48, CFSTR("CIImage")))
      CGImageProviderSetProperty();
    if (v32)
      CGImageProviderSetProperty();
    if (BoolForKey)
      CGImageProviderSetProperty();
    if (IIODictionary::getBoolForKey((IIODictionary *)v48, CFSTR("kImageIOInfoHeader_originalIsIndexed")))
    {
      CGImageProviderSetProperty();
      if (IIODictionary::getObjectForKey((IIODictionary *)v48, CFSTR("kImageIOInfoHeader_originalIndexedColorMap")))
        CGImageProviderSetProperty();
    }
  }
  IIODictionary::~IIODictionary((IIODictionary *)v40);
  IIODictionary::~IIODictionary((IIODictionary *)v48);
}

void sub_187E4DE64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  IIODictionary::~IIODictionary((IIODictionary *)(v3 - 104));
  _Unwind_Resume(a1);
}

void IIONumber::~IIONumber(IIONumber *this)
{
  const void *v1;

  *(_QWORD *)this = &off_1E1BB2F60;
  v1 = (const void *)*((_QWORD *)this + 2);
  if (v1)
    CFRelease(v1);
}

{
  IIONumber::~IIONumber(this);
  JUMPOUT(0x18D761C30);
}

void IIODictionary::~IIODictionary(IIODictionary *this)
{
  const void *v1;

  *(_QWORD *)this = &off_1E1BACDA8;
  v1 = (const void *)*((_QWORD *)this + 1);
  if (v1)
    CFRelease(v1);
}

{
  IIODictionary::~IIODictionary(this);
  JUMPOUT(0x18D761C30);
}

void IIODictionary::setObjectForKey(uint64_t a1, uint64_t a2, const void *a3)
{
  __CFDictionary *v3;

  if (a3)
  {
    v3 = *(__CFDictionary **)(a1 + 8);
    if (v3)
      CFDictionarySetValue(v3, a3, *(const void **)(a2 + 16));
  }
}

void IIONumber::IIONumber(IIONumber *this, uint64_t a2)
{
  uint64_t valuePtr;

  valuePtr = a2;
  *(_QWORD *)this = &off_1E1BB2F60;
  *((_QWORD *)this + 1) = 10;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 2) = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberLongType, &valuePtr);
}

{
  uint64_t valuePtr;

  valuePtr = a2;
  *(_QWORD *)this = &off_1E1BB2F60;
  *((_QWORD *)this + 1) = 4;
  *((_QWORD *)this + 2) = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt64Type, &valuePtr);
}

void IIODictionary::setObjectForKey(IIODictionary *this, const void *value, const __CFString *key)
{
  __CFDictionary *v3;

  if (key)
  {
    v3 = (__CFDictionary *)*((_QWORD *)this + 1);
    if (v3)
    {
      if (value)
        CFDictionarySetValue(v3, key, value);
      else
        CFDictionaryRemoveValue(v3, key);
    }
  }
}

uint64_t IIOImagePlus::releaseImageProvider(IIOImagePlus *this)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  unint64_t v5;
  uint64_t result;
  BOOL v7;
  unint64_t v8;

  v2 = *((_QWORD *)this + 18);
  v3 = *MEMORY[0x1E0C9B0D0];
  if (v2)
    v4 = v2 == v3;
  else
    v4 = 1;
  if (!v4)
  {
    do
      v5 = __ldxr(&gImageProviderCount);
    while (__stxr(v5 - 1, &gImageProviderCount));
    CGImageProviderRelease();
  }
  result = *((_QWORD *)this + 19);
  if (result)
    v7 = result == v3;
  else
    v7 = 1;
  if (!v7)
  {
    do
      v8 = __ldxr(&gImageProviderCount);
    while (__stxr(v8 - 1, &gImageProviderCount));
    result = CGImageProviderRelease();
  }
  *((_BYTE *)this + 192) &= ~0x40u;
  *((_QWORD *)this + 18) = 0;
  *((_QWORD *)this + 19) = 0;
  return result;
}

uint64_t IIOImageProviderInfo::IIOImageProviderInfo(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  __int128 v15;
  __int128 v16;
  uint64_t v17;

  *(_QWORD *)a1 = &off_1E1BB1F40;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 40);
  v15 = *(_OWORD *)(a2 + 56);
  v16 = *(_OWORD *)(a2 + 88);
  v17 = *(_QWORD *)(a2 + 104);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 80) = v16;
  *(_OWORD *)(a1 + 48) = v15;
  *(_QWORD *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 96) = v17;
  *(_QWORD *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 160);
  *(_DWORD *)(a1 + 128) = *(_DWORD *)(a2 + 176);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 144), 0);
  *(_QWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  switch((int)a4)
  {
    case 0:
      return a1;
    case 1:
      *(_DWORD *)(a1 + 208) = 1;
      *(_QWORD *)(a1 + 216) = a5;
      *(_QWORD *)(a1 + 224) = a9;
      break;
    case 2:
      *(_DWORD *)(a1 + 208) = 2;
      *(_QWORD *)(a1 + 216) = a5;
      *(_QWORD *)(a1 + 224) = a6;
      *(_QWORD *)(a1 + 232) = a9;
      break;
    case 3:
      *(_DWORD *)(a1 + 208) = 3;
      *(_QWORD *)(a1 + 216) = a5;
      *(_QWORD *)(a1 + 224) = a6;
      *(_QWORD *)(a1 + 232) = a7;
      *(_QWORD *)(a1 + 240) = a8;
      *(_QWORD *)(a1 + 248) = a9;
      break;
    default:
      _cg_jpeg_mem_term("IIOImageProviderInfo", 1677, "*** unknown version number - %d [%p]\n", (_DWORD)a4, a4);
      CFShow(CFSTR("unknown image provider version number"));
      break;
  }
  return a1;
}

const void *IIOImagePlus::createSourceImageProvider(uint64_t a1, int a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v7;
  const void *v8;
  uint64_t v9;
  IIOImageSource *Source;
  unint64_t v11;
  char __str[16];
  __int128 v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v7 = *a4;
  if (*(_DWORD *)(*a4 + 208) >= 4u)
    _cg_jpeg_mem_term("createSourceImageProvider", 977, "*** unknown callbackVersion - %d\n", *(_DWORD *)(v7 + 208));
  if ((gIIODebugFlags & 0x20000) != 0)
    ImageIOLog("♦️  CGImageProviderCreate: %dx%d  compType: %d\n", *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), a2);
  v8 = (const void *)CGImageProviderCreate();
  if (!v8)
    _cg_jpeg_mem_term("createSourceImageProvider", 992, "*** CGImageProviderCreate returned NULL\n");
  v9 = ~*(_QWORD *)(a1 + 16);
  Source = (IIOImageSource *)CGImageSourceGetSource(v9);
  if (Source && IIOImageSource::isRAWFile(Source))
  {
    CGImageProviderSetProperty();
    IIONumber::IIONumber((IIONumber *)__str, 64);
    CGImageProviderSetProperty();
    IIONumber::~IIONumber((IIONumber *)__str);
  }
  if ((gIIODebugFlags & 0xC000) != 0)
  {
    *(_OWORD *)__str = 0u;
    v14 = 0u;
    snprintf(__str, 0x20uLL, "(%p)", v8);
    if ((unsigned __int16)gIIODebugFlags >> 14)
      ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageProviderCreate", (CFTypeRef)v9, __str, -1, 0);
  }
  do
    v11 = __ldxr(&gImageProviderCount);
  while (__stxr(v11 + 1, &gImageProviderCount));
  *(_QWORD *)(v7 + 16) = v8;
  *(_QWORD *)(a1 + 240) = a4;
  *(_QWORD *)(a1 + 144) = v8;
  if (*(_BYTE *)(a1 + 180))
  {
    v8 = (const void *)CGImageProviderCreate();
    if ((unsigned __int16)gIIODebugFlags >> 14)
      ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageProviderCreate", v8, 0, -1, 0);
    *(_QWORD *)(a1 + 152) = v8;
  }
  return v8;
}

void sub_187E4E54C(_Unwind_Exception *a1)
{
  uint64_t v1;

  IIONumber::~IIONumber((IIONumber *)(v1 - 128));
  _Unwind_Resume(a1);
}

IIOImageSource *IIOImageRead::setISR(IIOImageRead *this, uint64_t a2)
{
  IIOImageSource *result;

  result = (IIOImageSource *)CGImageSourceGetSource(a2);
  if (result)
  {
    result = (IIOImageSource *)IIOImageSource::forceUseServer(result);
    *((_BYTE *)this + 456) = (_BYTE)result;
  }
  *((_QWORD *)this + 2) = ~a2;
  return result;
}

IIO_Reader *IIOImageSource::isRAWFile(IIOImageSource *this)
{
  IIO_Reader *result;
  unsigned int v2;

  result = (IIO_Reader *)*((_QWORD *)this + 10);
  if (result)
  {
    v2 = IIO_Reader::osType(result);
    return (IIO_Reader *)(HIWORD(v2) == 21057 && ((v2 >> 8) & 0xFE) - 48 <= 9 && (v2 & 0xFE) - 48 < 0xA);
  }
  return result;
}

IIO_Reader *IIO_ReaderHandler::readerForType(IIO_ReaderHandler *this, int a2)
{
  IIO_Reader **v2;
  IIO_Reader **v3;

  v2 = (IIO_Reader **)*((_QWORD *)this + 2);
  v3 = (IIO_Reader **)*((_QWORD *)this + 3);
  if (v2 == v3)
    return 0;
  while (IIO_Reader::osType(*v2) != a2)
  {
    if (++v2 == v3)
      return 0;
  }
  return *v2;
}

uint64_t IIO_Reader::osType(IIO_Reader *this)
{
  return *((unsigned int *)this + 6);
}

const void *IIOImagePlus::getImageProvider(IIOImagePlus *this)
{
  const void *v1;
  double v3;
  double v4;
  double v5;
  BOOL v6;
  BOOL v7;

  if (*((_QWORD *)this + 18) == *MEMORY[0x1E0C9B0D0])
    v1 = 0;
  else
    v1 = (const void *)*((_QWORD *)this + 18);
  if (v1)
  {
    CGImageProviderGetSize();
    if (v3 != (double)*((unint64_t *)this + 5)
      || ((v5 = floor(v3), v4 == floor(v4)) ? (v6 = v3 == v5) : (v6 = 0),
          v6 ? (v7 = v4 == (double)*((unint64_t *)this + 6)) : (v7 = 0),
          !v7))
    {
      LogError("getImageProvider", 1056, "*** ERROR: imageProvider %p has illegal size: (%g, %g)\n", v1, v3, v4);
    }
  }
  return v1;
}

uint64_t IIOImageSource::forceUseServer(IIOImageSource *this)
{
  return *((char *)this + 53);
}

uint64_t IIOImageWriteSession::getSize(IIOImageWriteSession *this)
{
  return *((_QWORD *)this + 7);
}

uint64_t CGImageReadSessionGetFilePath(uint64_t a1)
{
  uint64_t v1;
  IIOImageWriteSession *v2;

  if (a1 && (v1 = *(_QWORD *)(a1 + 24)) != 0 && (v2 = *(IIOImageWriteSession **)(v1 + 32)) != 0)
    return IIOImageWriteSession::getSize(v2);
  else
    return 0;
}

uint64_t IIO_Reader_PNG::hasCustomImageCountProc(IIO_Reader_PNG *this)
{
  return 1;
}

uint64_t IIO_Reader_PNG::hasCustomCompareOptionsProc(IIO_Reader_PNG *this)
{
  return 1;
}

uint64_t IIO_Reader_PNG::compareOptions(IIO_Reader_PNG *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  unsigned int Uint32ForKey;
  unsigned int v5;
  int v6;
  int v7;
  _BOOL4 BoolForKey;
  const __CFDictionary *ObjectForKey;
  const __CFDictionary *v10;
  uint64_t v11;
  int v13;
  _QWORD v14[3];
  _QWORD v15[3];

  memset(v15, 0, sizeof(v15));
  IIODictionary::IIODictionary((IIODictionary *)v15, a2);
  memset(v14, 0, sizeof(v14));
  IIODictionary::IIODictionary((IIODictionary *)v14, a3);
  Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v15, CFSTR("kCGImageSourceSubsampleFactor"));
  v5 = IIODictionary::getUint32ForKey((IIODictionary *)v14, CFSTR("kCGImageSourceSubsampleFactor"));
  if (Uint32ForKey <= 1)
    v6 = 1;
  else
    v6 = Uint32ForKey;
  if (v5 <= 1)
    v7 = 1;
  else
    v7 = v5;
  if (v6 != v7
    || (BoolForKey = IIODictionary::getBoolForKey((IIODictionary *)v15, CFSTR("kCGImageSourceUseCoreImage")),
        BoolForKey != IIODictionary::getBoolForKey((IIODictionary *)v14, CFSTR("kCGImageSourceUseCoreImage")))
    || (ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v15, CFSTR("kCGImageSourceXMPSidecar")),
        v10 = IIODictionary::getObjectForKey((IIODictionary *)v14, CFSTR("kCGImageSourceXMPSidecar")),
        (ObjectForKey != 0) ^ (v10 != 0))
    || ObjectForKey && v10 && !CFEqual(ObjectForKey, v10))
  {
    v11 = 0;
  }
  else
  {
    v13 = IIOSkipMetadata((IIODictionary *)v15);
    v11 = v13 ^ 1 | IIOSkipMetadata((IIODictionary *)v14);
  }
  IIODictionary::~IIODictionary((IIODictionary *)v14);
  IIODictionary::~IIODictionary((IIODictionary *)v15);
  return v11;
}

void sub_187E4E880(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  IIODictionary::~IIODictionary((IIODictionary *)&a9);
  IIODictionary::~IIODictionary((IIODictionary *)&a12);
  _Unwind_Resume(a1);
}

uint64_t IIOImagePlus::getImage(IIOImagePlus *this)
{
  return *((_QWORD *)this + 16);
}

uint64_t IIO_Reader_HEIF::hasCustomImageCountProc(IIO_Reader_HEIF *this)
{
  return 1;
}

uint64_t IIO_Reader_HEIF::hasCustomCompareOptionsProc(IIO_Reader_HEIF *this)
{
  return 1;
}

uint64_t IIO_Reader_HEIF::compareOptions(IIO_Reader_HEIF *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  unsigned int Uint32ForKey;
  unsigned int v6;
  int v7;
  int v8;
  int v9;
  const __CFString *Value;
  const __CFString *v11;
  BOOL v12;
  uint64_t v13;
  _QWORD v15[3];
  _QWORD v16[3];

  memset(v16, 0, sizeof(v16));
  IIODictionary::IIODictionary((IIODictionary *)v16, a2);
  memset(v15, 0, sizeof(v15));
  IIODictionary::IIODictionary((IIODictionary *)v15, a3);
  Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v16, CFSTR("kCGImageSourceSubsampleFactor"));
  v6 = IIODictionary::getUint32ForKey((IIODictionary *)v15, CFSTR("kCGImageSourceSubsampleFactor"));
  if (Uint32ForKey <= 1)
    v7 = 1;
  else
    v7 = Uint32ForKey;
  if (v6 <= 1)
    v8 = 1;
  else
    v8 = v6;
  if (v7 == v8
    && (v9 = IIOSkipMetadata((IIODictionary *)v16),
        ((v9 ^ 1 | IIOSkipMetadata((IIODictionary *)v15)) & 1) != 0))
  {
    Value = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("kCGImageSourceDecodeRequest"));
    v11 = (const __CFString *)CFDictionaryGetValue(a3, CFSTR("kCGImageSourceDecodeRequest"));
    if (Value && v11)
      v12 = CFStringCompare(Value, v11, 0) == kCFCompareEqualTo;
    else
      v12 = ((unint64_t)Value | (unint64_t)v11) == 0;
    v13 = v12;
  }
  else
  {
    v13 = 0;
  }
  IIODictionary::~IIODictionary((IIODictionary *)v15);
  IIODictionary::~IIODictionary((IIODictionary *)v16);
  return v13;
}

void sub_187E4E9F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  IIODictionary::~IIODictionary((IIODictionary *)&a9);
  IIODictionary::~IIODictionary((IIODictionary *)&a12);
  _Unwind_Resume(a1);
}

void IIOXPCLog(char *a1, ...)
{
  FILE *v2;
  char *v3[2];
  uint8_t buf[4];
  char *v5;
  uint64_t v6;
  va_list va;

  va_start(va, a1);
  v6 = *MEMORY[0x1E0C80C00];
  if (IIOXPCLog::onceToken != -1)
    dispatch_once(&IIOXPCLog::onceToken, &__block_literal_global_21);
  if (IIOXPCLog::logXPC)
  {
    v3[0] = 0;
    va_copy((va_list)&v3[1], va);
    vasprintf(v3, a1, va);
    if (os_log_type_enabled(0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v5 = v3[0];
      _os_log_impl(&dword_187E34000, 0, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
    }
    v2 = (FILE *)*MEMORY[0x1E0C80C10];
    if (gRunningInXPCService)
      fprintf(v2, "[S] %s");
    else
      fprintf(v2, "[C] %s");
    free(v3[0]);
  }
}

uint64_t IIO_Reader::hasCustomImageCountProc(IIO_Reader *this)
{
  return 0;
}

uint64_t IIO_Reader_AppleJPEG::hasCustomCompareOptionsProc(IIO_Reader_AppleJPEG *this)
{
  return 1;
}

uint64_t IIO_Reader_AppleJPEG::compareOptions(IIO_Reader_AppleJPEG *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  unsigned int Uint32ForKey;
  unsigned int v6;
  int v7;
  int v8;
  _BOOL4 BoolForKey;
  const __CFDictionary *ObjectForKey;
  const __CFDictionary *v11;
  int v12;
  _BOOL4 v13;
  _BOOL4 v14;
  _BOOL4 v15;
  uint64_t v16;
  const __CFString *Value;
  const __CFString *v19;
  BOOL v20;
  _QWORD v21[3];
  _QWORD v22[3];

  memset(v22, 0, sizeof(v22));
  IIODictionary::IIODictionary((IIODictionary *)v22, a2);
  memset(v21, 0, sizeof(v21));
  IIODictionary::IIODictionary((IIODictionary *)v21, a3);
  Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v22, CFSTR("kCGImageSourceSubsampleFactor"));
  v6 = IIODictionary::getUint32ForKey((IIODictionary *)v21, CFSTR("kCGImageSourceSubsampleFactor"));
  if (Uint32ForKey <= 1)
    v7 = 1;
  else
    v7 = Uint32ForKey;
  if (v6 <= 1)
    v8 = 1;
  else
    v8 = v6;
  if (v7 == v8
    && (BoolForKey = IIODictionary::getBoolForKey((IIODictionary *)v22, CFSTR("kCGImageSourceUseCoreImage")),
        BoolForKey == IIODictionary::getBoolForKey((IIODictionary *)v21, CFSTR("kCGImageSourceUseCoreImage")))
    && (ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v22, CFSTR("kCGImageSourceXMPSidecar")),
        v11 = IIODictionary::getObjectForKey((IIODictionary *)v21, CFSTR("kCGImageSourceXMPSidecar")),
        (ObjectForKey != 0) == (v11 != 0))
    && (!ObjectForKey || !v11 || CFEqual(ObjectForKey, v11))
    && (v12 = IIOSkipMetadata((IIODictionary *)v22), (v12 ^ 1 | IIOSkipMetadata((IIODictionary *)v21)) == 1)
    && (v13 = IIODictionary::getBoolForKey((IIODictionary *)v22, CFSTR("kCGImageSourceAddJPEGQualityInformation")),
        v13 == IIODictionary::getBoolForKey((IIODictionary *)v21, CFSTR("kCGImageSourceAddJPEGQualityInformation")))
    && (v14 = IIODictionary::getBoolForKey((IIODictionary *)v22, CFSTR("kCGImageSourceAddThumbnailInformation")),
        v14 == IIODictionary::getBoolForKey((IIODictionary *)v21, CFSTR("kCGImageSourceAddThumbnailInformation")))
    && (v15 = IIODictionary::getBoolForKey((IIODictionary *)v22, CFSTR("kCGImageSourceUseHardwareAcceleration")),
        v15 == IIODictionary::getBoolForKey((IIODictionary *)v21, CFSTR("kCGImageSourceUseHardwareAcceleration"))))
  {
    Value = (const __CFString *)CFDictionaryGetValue(a2, CFSTR("kCGImageSourceDecodeRequest"));
    v19 = (const __CFString *)CFDictionaryGetValue(a3, CFSTR("kCGImageSourceDecodeRequest"));
    if (Value && v19)
      v20 = CFStringCompare(Value, v19, 0) == kCFCompareEqualTo;
    else
      v20 = ((unint64_t)Value | (unint64_t)v19) == 0;
    v16 = v20;
  }
  else
  {
    v16 = 0;
  }
  IIODictionary::~IIODictionary((IIODictionary *)v21);
  IIODictionary::~IIODictionary((IIODictionary *)v22);
  return v16;
}

void sub_187E4EDA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  IIODictionary::~IIODictionary((IIODictionary *)&a9);
  IIODictionary::~IIODictionary((IIODictionary *)&a12);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader::hasCustomCompareOptionsProc(IIO_Reader *this)
{
  return 0;
}

uint64_t IIO_Reader_ATX::hasCustomImageCountProc(IIO_Reader_ATX *this)
{
  return 1;
}

uint64_t IIO_Reader_TIFF::hasCustomCompareOptionsProc(IIO_Reader_TIFF *this)
{
  return 1;
}

uint64_t IIO_Reader_TIFF::hasCustomImageCountProc(IIO_Reader_TIFF *this)
{
  return 1;
}

uint64_t IIO_Reader_TIFF::compareOptions(IIO_Reader_TIFF *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  _BOOL4 BoolForKey;
  unsigned int Uint32ForKey;
  unsigned int v6;
  int v7;
  int v8;
  const __CFDictionary *ObjectForKey;
  const __CFDictionary *v10;
  uint64_t v11;
  int v13;
  _QWORD v14[3];
  _QWORD v15[3];

  memset(v15, 0, sizeof(v15));
  IIODictionary::IIODictionary((IIODictionary *)v15, a2);
  memset(v14, 0, sizeof(v14));
  IIODictionary::IIODictionary((IIODictionary *)v14, a3);
  BoolForKey = IIODictionary::getBoolForKey((IIODictionary *)v15, CFSTR("kCGImageSourceShouldAllowFloat"));
  if (BoolForKey != IIODictionary::getBoolForKey((IIODictionary *)v14, CFSTR("kCGImageSourceShouldAllowFloat"))
    || ((Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v15, CFSTR("kCGImageSourceSubsampleFactor")), v6 = IIODictionary::getUint32ForKey((IIODictionary *)v14, CFSTR("kCGImageSourceSubsampleFactor")), Uint32ForKey <= 1)? (v7 = 1): (v7 = Uint32ForKey), v6 <= 1 ? (v8 = 1) : (v8 = v6), v7 != v8|| (ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v15, CFSTR("kCGImageSourceXMPSidecar")), v10 = IIODictionary::getObjectForKey((IIODictionary *)v14, CFSTR("kCGImageSourceXMPSidecar")), (ObjectForKey != 0) ^ (v10 != 0))|| ObjectForKey && v10 && !CFEqual(ObjectForKey, v10)))
  {
    v11 = 0;
  }
  else
  {
    v13 = IIOSkipMetadata((IIODictionary *)v15);
    v11 = v13 ^ 1 | IIOSkipMetadata((IIODictionary *)v14);
  }
  IIODictionary::~IIODictionary((IIODictionary *)v14);
  IIODictionary::~IIODictionary((IIODictionary *)v15);
  return v11;
}

void sub_187E4EF48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  IIODictionary::~IIODictionary((IIODictionary *)&a9);
  IIODictionary::~IIODictionary((IIODictionary *)&a12);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_GIF::hasCustomImageCountProc(IIO_Reader_GIF *this)
{
  return 1;
}

uint64_t IIO_Reader_ASTC::hasCustomImageCountProc(IIO_Reader_ASTC *this)
{
  return 1;
}

double XMPMeta::Terminate(XMPMeta *this)
{
  XMPIterator *v1;
  XMPUtils *v2;
  AdobeXMPCore_Int::INameSpacePrefixMap_I *v3;
  AdobeXMPCore_Int::IDOMImplementationRegistry_I *v4;
  AdobeXMPCore::ICoreObjectFactory_v1 *v5;
  AdobeXMPCore_Int::ICoreConfigurationManager_I *v6;
  AdobeXMPCore_Int *v7;
  uint64_t v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  double result;

  if (!--sXMP_InitCount)
  {
    v1 = (XMPIterator *)kdebug_trace();
    v2 = (XMPUtils *)XMPIterator::Terminate(v1);
    v3 = (AdobeXMPCore_Int::INameSpacePrefixMap_I *)XMPUtils::Terminate(v2);
    AdobeXMPCore_Int::INameSpacePrefixMap_I::DestroyDefaultNameSapcePrefixMap(v3);
    AdobeXMPCore_Int::IDOMImplementationRegistry_I::DestoryDOMImplementationRegistry(v4);
    v6 = (AdobeXMPCore_Int::ICoreConfigurationManager_I *)AdobeXMPCore::ICoreObjectFactory_v1::DestroyCoreObjectFactory(v5);
    AdobeXMPCore_Int::ICoreConfigurationManager_I::DestroyCoreConfigurationManager(v6);
    AdobeXMPCore_Int::InitializeXMPCommonFramework(v7);
    if (sDefaultNamespacePrefixMapLock)
    {
      XMP_ReadWriteLock::~XMP_ReadWriteLock((XMP_ReadWriteLock *)sDefaultNamespacePrefixMapLock);
      MEMORY[0x18D761C30]();
    }
    sDefaultNamespacePrefixMapLock = 0;
    sUseNewCoreAPIs = 0;
    v10 = sRegisteredNamespaces;
    if (sRegisteredNamespaces)
      v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)sRegisteredNamespaces + 8))(sRegisteredNamespaces);
    sRegisteredNamespaces = 0;
    v11 = sRegisteredAliasMap;
    if (sRegisteredAliasMap)
    {
      std::__tree<std::__value_type<std::string,std::vector<XPathStepInfo>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<XPathStepInfo>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<XPathStepInfo>>>>::destroy(sRegisteredAliasMap, *(_QWORD **)(sRegisteredAliasMap + 8));
      v10 = MEMORY[0x18D761C30](v11, 0x1020C4062D53EE8);
    }
    sRegisteredAliasMap = 0;
    v12 = xdefaultName;
    if (xdefaultName)
    {
      if (*(char *)(xdefaultName + 23) < 0)
        operator delete(*(void **)xdefaultName);
      v10 = MEMORY[0x18D761C30](v12, 0x1012C40EC159624);
    }
    xdefaultName = 0;
    _cg_jpeg_mem_term(v10, v8, v9);
    if (sDefaultErrorCallback(void)::onceToken != -1)
      dispatch_once(&sDefaultErrorCallback(void)::onceToken, &__block_literal_global_45);
    v13 = gDefaultErrorCallback;
    *(_QWORD *)(gDefaultErrorCallback + 32) = 0;
    *(_QWORD *)(v13 + 40) = 0;
    *(_QWORD *)(v13 + 24) = 0;
    *(_QWORD *)&result = 1;
    *(_QWORD *)(v13 + 8) = 1;
    *(_BYTE *)(v13 + 16) = 0;
  }
  return result;
}

void std::__tree<std::__value_type<std::string,std::vector<XPathStepInfo>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<XPathStepInfo>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<XPathStepInfo>>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::string,std::vector<XPathStepInfo>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<XPathStepInfo>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<XPathStepInfo>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::string,std::vector<XPathStepInfo>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<XPathStepInfo>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<XPathStepInfo>>>>::destroy(a1, a2[1]);
    std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<XPathStepInfo>>,0>((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void WXMPIterator_Next_1(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, void (*a6)(uint64_t, uint64_t, _QWORD), uint64_t a7)
{
  uint64_t v14;
  int v15;
  XMP_ReadWriteLock *v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  XMP_ReadWriteLock *v23;

  v23 = (XMP_ReadWriteLock *)(a1 + 2);
  XMP_ReadWriteLock::Acquire((pthread_rwlock_t *)(a1 + 2), 1);
  *(_QWORD *)a7 = 0;
  v22 = 0;
  v21 = 0;
  v20 = 0;
  v19 = 0;
  v17 = 0;
  v18 = 0;
  if (!a5)
    a5 = &v17;
  v14 = a1[29];
  if (!v14)
    __assert_rtn("WXMPIterator_Next_1", "WXMPIterator.cpp", 140, "thiz->info.xmpObj != __null");
  v16 = (XMP_ReadWriteLock *)(v14 + 16);
  XMP_ReadWriteLock::Acquire((pthread_rwlock_t *)(v14 + 16), 0);
  v15 = (*(uint64_t (**)(_QWORD *, uint64_t *, unsigned int *, uint64_t *, unsigned int *, uint64_t *, char *, uint64_t *, XMP_ReadWriteLock *, uint64_t))(*a1 + 16))(a1, &v22, &v21, &v20, &v19, &v18, (char *)&v17 + 4, a5, v16, v17);
  *(_DWORD *)(a7 + 32) = v15;
  if (v15)
  {
    if (a2)
      a6(a2, v22, v21);
    if (a3)
      a6(a3, v20, v19);
    if (a4)
      a6(a4, v18, HIDWORD(v17));
  }
  XMP_AutoLock::~XMP_AutoLock(&v16);
  XMP_AutoLock::~XMP_AutoLock(&v23);
}

void sub_187E4F2A0(void *a1, int a2)
{
  uint64_t v2;
  void *v4;
  const char *v5;
  void *v6;
  uint64_t v7;

  if (a2 == 3)
  {
    v4 = __cxa_begin_catch(a1);
    *(_DWORD *)(v2 + 32) = *(_DWORD *)v4;
    *(_QWORD *)(v2 + 8) = "XMP";
    v5 = (const char *)*((_QWORD *)v4 + 1);
    if (!v5)
      v5 = "";
  }
  else
  {
    v6 = __cxa_begin_catch(a1);
    if (a2 != 2)
    {
      *(_DWORD *)(v2 + 32) = 14;
      *(_QWORD *)v2 = "Caught unknown exception";
      __cxa_end_catch();
LABEL_10:
      JUMPOUT(0x187E4F258);
    }
    *(_DWORD *)(v2 + 32) = 13;
    v7 = (*(uint64_t (**)(void *))(*(_QWORD *)v6 + 16))(v6);
    v5 = "";
    if (v7)
      v5 = (const char *)v7;
  }
  *(_QWORD *)v2 = v5;
  __cxa_end_catch();
  goto LABEL_10;
}

void sub_187E4F35C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  XMP_AutoLock::~XMP_AutoLock((XMP_ReadWriteLock **)va);
  _Unwind_Resume(a1);
}

void TXMPIterator<std::string>::SetClientString()
{
  JUMPOUT(0x18D761A20);
}

BOOL XMP_NamespaceTable::GetURI(XMP_NamespaceTable *this, char *a2, const char **a3, unsigned int *a4)
{
  std::string::size_type size;
  std::string *p_p;
  uint64_t v10;
  char *v11;
  char *v12;
  const char *v13;
  uint64_t v14;
  std::string __p;
  XMP_ReadWriteLock *v17;

  v17 = (XMP_NamespaceTable *)((char *)this + 8);
  XMP_ReadWriteLock::Acquire((pthread_rwlock_t *)((char *)this + 8), 0);
  if (!a2 || !*a2)
    __assert_rtn("GetURI", "XMP_LibUtils.cpp", 527, "(_prefix != 0) && (*_prefix != 0)");
  memset(&__p, 0, sizeof(__p));
  std::string::basic_string[abi:ne180100]<0>(&__p, a2);
  size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    p_p = &__p;
  }
  else
  {
    size = __p.__r_.__value_.__l.__size_;
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if (p_p->__r_.__value_.__s.__data_[size - 1] != 58)
    std::string::push_back(&__p, 58);
  v10 = std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::find<std::string>((uint64_t)this + 240, (const void **)&__p.__r_.__value_.__l.__data_);
  v11 = (char *)v10;
  v12 = (char *)this + 248;
  if (v12 != (char *)v10)
  {
    if (a3)
    {
      v13 = (const char *)(v10 + 56);
      if (*(char *)(v10 + 79) < 0)
        v13 = *(const char **)v13;
      *a3 = v13;
    }
    if (a4)
    {
      if (*(char *)(v10 + 79) < 0)
        v14 = *(_QWORD *)(v10 + 64);
      else
        LODWORD(v14) = *(unsigned __int8 *)(v10 + 79);
      *a4 = v14;
    }
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  XMP_AutoLock::~XMP_AutoLock(&v17);
  return v12 != v11;
}

void sub_187E4F4C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, XMP_ReadWriteLock *a15)
{
  if (a14 < 0)
    operator delete(__p);
  XMP_AutoLock::~XMP_AutoLock(&a15);
  _Unwind_Resume(a1);
}

void RegisterAlias(char *a1, char *a2, char *a3, char *a4, unsigned int a5)
{
  int v8;
  int v9;
  char *v10;
  int64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  __int128 v15;
  unint64_t v16;
  uint64_t v17;
  char *v18;
  std::string::size_type v19;
  uint64_t v20;
  __int128 v21;
  __int128 *v22;
  uint64_t v23;
  uint64_t v24;
  std::string *v25;
  int64_t v26;
  uint64_t v27;
  std::string::size_type v28;
  uint64_t v29;
  int v30;
  const void **p_size;
  unsigned __int8 *v32;
  uint64_t v33;
  std::string **v34;
  uint64_t v35;
  std::string::pointer data;
  char *v37;
  int v38;
  const void **v39;
  unsigned __int8 *v40;
  unsigned __int8 *v41;
  unsigned __int8 *v42;
  unsigned __int8 *v43;
  const std::string *v44;
  uint64_t **v45;
  uint64_t v46;
  _QWORD *v47;
  const void **v48;
  uint64_t v49;
  size_t v50;
  uint64_t v51;
  uint64_t v52;
  _QWORD *v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  unsigned __int8 *v57;
  const void **v58;
  uint64_t v59;
  _QWORD *v60;
  _QWORD *v61;
  BOOL v62;
  std::string **v63;
  std::string *v64;
  uint64_t v65;
  uint64_t v66;
  std::string::size_type v67;
  int v68;
  const void **v69;
  std::string::size_type *v70;
  _QWORD *v71;
  _QWORD *v72;
  _QWORD *exception;
  const char *v74;
  std::string v75;
  _QWORD v76[3];
  void *__p[2];
  uint64_t v78;
  int v79;
  std::string *__str;
  char *v81;
  unint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;

  v83 = 0;
  v84 = 0;
  v85 = 0;
  __str = 0;
  v81 = 0;
  v82 = 0;
  if (!a1 || !a2 || !a3 || !a4)
    __assert_rtn("RegisterAlias", "XMPMeta.cpp", 546, "(aliasNS != 0) && (aliasProp != 0) && (actualNS != 0) && (actualProp != 0)");
  ExpandXPath(a1, a2, &v83);
  ExpandXPath(a3, a4, (uint64_t *)&__str);
  if (v84 - v83 != 64 || v81 - (char *)__str != 64)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 102;
    v74 = "Alias and actual property names must be simple";
    goto LABEL_129;
  }
  v8 = VerifySetOptions(a5, 0);
  v9 = v8;
  if (v8)
  {
    if ((v8 & 0xFFFFE1FF) != 0)
    {
      exception = __cxa_allocate_exception(0x18uLL);
      *(_DWORD *)exception = 103;
      v74 = "Only array form flags are allowed";
      goto LABEL_129;
    }
    LODWORD(__str[2].__r_.__value_.__r.__words[1]) |= v8;
    if ((v8 & 0x1000) != 0)
    {
      std::string::basic_string[abi:ne180100]<0>(__p, "[?xml:lang=\"x-default\"]");
      v79 = 5;
      v10 = v81;
      if ((unint64_t)v81 >= v82)
      {
        v11 = (v81 - (char *)__str) >> 5;
        v16 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 59)
          std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
        v17 = v82 - (_QWORD)__str;
        if ((uint64_t)(v82 - (_QWORD)__str) >> 4 > v16)
          v16 = v17 >> 4;
        if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFE0)
          v14 = 0x7FFFFFFFFFFFFFFLL;
        else
          v14 = v16;
        goto LABEL_25;
      }
    }
    else
    {
      std::string::basic_string[abi:ne180100]<0>(__p, "[1]");
      v79 = 3;
      v10 = v81;
      if ((unint64_t)v81 >= v82)
      {
        v11 = (v81 - (char *)__str) >> 5;
        v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 59)
          std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
        v13 = v82 - (_QWORD)__str;
        if ((uint64_t)(v82 - (_QWORD)__str) >> 4 > v12)
          v12 = v13 >> 4;
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFE0)
          v14 = 0x7FFFFFFFFFFFFFFLL;
        else
          v14 = v12;
LABEL_25:
        v76[1] = &v82;
        v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<XPathStepInfo>>((uint64_t)&v82, v14);
        v19 = (std::string::size_type)&v18[32 * v11];
        v75.__r_.__value_.__r.__words[0] = (std::string::size_type)v18;
        v75.__r_.__value_.__l.__size_ = v19;
        v76[0] = &v18[32 * v20];
        v21 = *(_OWORD *)__p;
        *(_QWORD *)(v19 + 16) = v78;
        *(_OWORD *)v19 = v21;
        __p[1] = 0;
        v78 = 0;
        __p[0] = 0;
        *(_DWORD *)(v19 + 24) = v79;
        v75.__r_.__value_.__r.__words[2] = v19 + 32;
        std::vector<XPathStepInfo>::__swap_out_circular_buffer((uint64_t *)&__str, &v75);
        v22 = (__int128 *)v81;
        std::__split_buffer<XPathStepInfo>::~__split_buffer((uint64_t)&v75);
        v81 = (char *)v22;
        if (SHIBYTE(v78) < 0)
          operator delete(__p[0]);
        goto LABEL_27;
      }
    }
    v15 = *(_OWORD *)__p;
    *((_QWORD *)v10 + 2) = v78;
    *(_OWORD *)v10 = v15;
    __p[1] = 0;
    v78 = 0;
    __p[0] = 0;
    *((_DWORD *)v10 + 6) = v79;
    v81 = v10 + 32;
  }
LABEL_27:
  v23 = std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::find<std::string>(sRegisteredAliasMap, (const void **)(v83 + 32));
  if (sRegisteredAliasMap + 8 == v23)
  {
    v33 = std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::find<std::string>(sRegisteredAliasMap, (const void **)&__str[1].__r_.__value_.__l.__size_);
    if (sRegisteredAliasMap + 8 != v33)
    {
      v34 = (std::string **)(v33 + 56);
      if (v81 - (char *)__str == 64)
      {
        if (&__str != v34)
          std::vector<XPathStepInfo>::__assign_with_size[abi:ne180100]<XPathStepInfo*,XPathStepInfo*>((uint64_t)&__str, *(std::string **)(v33 + 56), *(__int128 **)(v33 + 64), (uint64_t)(*(_QWORD *)(v33 + 64) - *(_QWORD *)(v33 + 56)) >> 5);
      }
      else
      {
        v44 = *(const std::string **)(v33 + 56);
        if (*(_QWORD *)(v33 + 64) - (_QWORD)v44 != 64)
        {
LABEL_124:
          exception = __cxa_allocate_exception(0x18uLL);
          *(_DWORD *)exception = 4;
          v74 = "Can't alias an array item to an array item";
          goto LABEL_129;
        }
        std::string::operator=(__str, v44);
        std::string::operator=((std::string *)((char *)__str + 32), (std::string *)((char *)*v34 + 32));
      }
    }
    v45 = (uint64_t **)sRegisteredAliasMap;
    v46 = sRegisteredAliasMap + 8;
    v47 = *(_QWORD **)sRegisteredAliasMap;
    if (*(_QWORD *)sRegisteredAliasMap == sRegisteredAliasMap + 8)
    {
LABEL_117:
      std::pair<std::string const,std::vector<XPathStepInfo>>::pair[abi:ne180100]<std::string&,std::vector<XPathStepInfo>&,0>(&v75, (__int128 *)(v83 + 32), (__int128 **)&__str);
      std::__tree<std::__value_type<std::string,std::vector<XPathStepInfo>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<XPathStepInfo>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<XPathStepInfo>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::vector<XPathStepInfo>>>(v45, (const void **)&v75.__r_.__value_.__l.__data_, (__int128 *)&v75);
      __p[0] = v76;
      std::vector<XPathStepInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
      if (SHIBYTE(v75.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v75.__r_.__value_.__l.__data_);
      goto LABEL_120;
    }
    v48 = (const void **)(v83 + 32);
    v49 = *(unsigned __int8 *)(v83 + 55);
    v50 = *(_QWORD *)(v83 + 40);
    if ((v49 & 0x80u) == 0)
      v51 = *(unsigned __int8 *)(v83 + 55);
    else
      v51 = *(_QWORD *)(v83 + 40);
    v52 = v84 - v83;
    v53 = *(_QWORD **)sRegisteredAliasMap;
    while (1)
    {
      v54 = v53[7];
      v55 = *(unsigned __int8 *)(v54 + 55);
      v56 = (char)v55;
      if ((v55 & 0x80u) != 0)
        v55 = *(_QWORD *)(v54 + 40);
      if (v51 == v55)
      {
        if (v56 >= 0)
          v57 = (unsigned __int8 *)(v54 + 32);
        else
          v57 = *(unsigned __int8 **)(v54 + 32);
        if ((v49 & 0x80) != 0)
        {
          if (!memcmp(*v48, v57, v50))
          {
LABEL_84:
            if (v53[8] - v54 == 64 && v52 == 64)
              goto LABEL_124;
          }
        }
        else
        {
          if (!(_DWORD)v49)
            goto LABEL_84;
          v58 = v48;
          v59 = v49;
          while (*(unsigned __int8 *)v58 == *v57)
          {
            v58 = (const void **)((char *)v58 + 1);
            ++v57;
            if (!--v59)
              goto LABEL_84;
          }
        }
      }
      v60 = (_QWORD *)v53[1];
      if (v60)
      {
        do
        {
          v61 = v60;
          v60 = (_QWORD *)*v60;
        }
        while (v60);
      }
      else
      {
        do
        {
          v61 = (_QWORD *)v53[2];
          v62 = *v61 == (_QWORD)v53;
          v53 = v61;
        }
        while (!v62);
      }
      v53 = v61;
      if (v61 == (_QWORD *)v46)
      {
        while (1)
        {
          v63 = (std::string **)(v47 + 7);
          v64 = (std::string *)v47[7];
          v65 = *(unsigned __int8 *)(v83 + 55);
          if ((v65 & 0x80u) == 0)
            v66 = *(unsigned __int8 *)(v83 + 55);
          else
            v66 = *(_QWORD *)(v83 + 40);
          v67 = v64[2].__r_.__value_.__s.__data_[7];
          v68 = (char)v67;
          if ((v67 & 0x80u) != 0)
            v67 = v64[1].__r_.__value_.__r.__words[2];
          if (v66 != v67)
            goto LABEL_111;
          v69 = (const void **)(v83 + 32);
          v70 = v68 >= 0
              ? &v64[1].__r_.__value_.__r.__words[1]
              : (std::string::size_type *)v64[1].__r_.__value_.__l.__size_;
          if ((v65 & 0x80) == 0)
            break;
          if (!memcmp(*v69, v70, *(_QWORD *)(v83 + 40)))
            goto LABEL_107;
LABEL_111:
          v71 = (_QWORD *)v47[1];
          if (v71)
          {
            do
            {
              v72 = v71;
              v71 = (_QWORD *)*v71;
            }
            while (v71);
          }
          else
          {
            do
            {
              v72 = (_QWORD *)v47[2];
              v62 = *v72 == (_QWORD)v47;
              v47 = v72;
            }
            while (!v62);
          }
          v45 = (uint64_t **)sRegisteredAliasMap;
          v47 = v72;
          if (v72 == (_QWORD *)(sRegisteredAliasMap + 8))
            goto LABEL_117;
        }
        if (*(_BYTE *)(v83 + 55))
        {
          while (*(unsigned __int8 *)v69 == *(unsigned __int8 *)v70)
          {
            v69 = (const void **)((char *)v69 + 1);
            v70 = (std::string::size_type *)((char *)v70 + 1);
            if (!--v65)
              goto LABEL_107;
          }
          goto LABEL_111;
        }
LABEL_107:
        if (v47[8] - (_QWORD)v64 == 32)
        {
          if (v63 != &__str)
            std::vector<XPathStepInfo>::__assign_with_size[abi:ne180100]<XPathStepInfo*,XPathStepInfo*>((uint64_t)(v47 + 7), __str, (__int128 *)v81, (v81 - (char *)__str) >> 5);
        }
        else
        {
          std::string::operator=(v64, __str);
          std::string::operator=((std::string *)((char *)*v63 + 32), (std::string *)((char *)__str + 32));
        }
        goto LABEL_111;
      }
    }
  }
  v24 = *(_QWORD *)(v23 + 56);
  if (v9 != (*(_DWORD *)(v24 + 56) & 0x1E00))
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 4;
    v74 = "Mismatch with existing alias array form";
    goto LABEL_129;
  }
  v25 = __str;
  v26 = v81 - (char *)__str;
  if (v81 - (char *)__str != *(_QWORD *)(v23 + 64) - v24)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 4;
    v74 = "Mismatch with existing actual path";
LABEL_129:
    exception[1] = v74;
    *((_BYTE *)exception + 16) = 0;
  }
  v27 = __str[2].__r_.__value_.__s.__data_[7];
  if ((v27 & 0x80u) == 0)
    v28 = __str[2].__r_.__value_.__s.__data_[7];
  else
    v28 = __str[1].__r_.__value_.__r.__words[2];
  v29 = *(unsigned __int8 *)(v24 + 55);
  v30 = (char)v29;
  if ((v29 & 0x80u) != 0)
    v29 = *(_QWORD *)(v24 + 40);
  if (v28 != v29)
    goto LABEL_122;
  p_size = (const void **)&__str[1].__r_.__value_.__l.__size_;
  if (v30 >= 0)
    v32 = (unsigned __int8 *)(v24 + 32);
  else
    v32 = *(unsigned __int8 **)(v24 + 32);
  if ((v27 & 0x80) != 0)
  {
    if (!memcmp(*p_size, v32, __str[1].__r_.__value_.__r.__words[2]))
      goto LABEL_49;
LABEL_122:
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 4;
    v74 = "Mismatch with existing actual name";
    goto LABEL_129;
  }
  if (__str[2].__r_.__value_.__s.__data_[7])
  {
    while (*(unsigned __int8 *)p_size == *v32)
    {
      p_size = (const void **)((char *)p_size + 1);
      ++v32;
      if (!--v27)
        goto LABEL_49;
    }
    goto LABEL_122;
  }
LABEL_49:
  if (v26 != 96)
    goto LABEL_120;
  v35 = v25[3].__r_.__value_.__s.__data_[15];
  if ((v35 & 0x80u) == 0)
    data = (std::string::pointer)v25[3].__r_.__value_.__s.__data_[15];
  else
    data = v25[3].__r_.__value_.__l.__data_;
  v37 = (char *)*(unsigned __int8 *)(v24 + 87);
  v38 = (char)v37;
  if ((char)v37 < 0)
    v37 = *(char **)(v24 + 72);
  if (data != v37)
  {
LABEL_123:
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 4;
    v74 = "Mismatch with existing actual array item";
    goto LABEL_129;
  }
  v39 = (const void **)&v25[2].__r_.__value_.__r.__words[2];
  v42 = *(unsigned __int8 **)(v24 + 64);
  v41 = (unsigned __int8 *)(v24 + 64);
  v40 = v42;
  if (v38 >= 0)
    v43 = v41;
  else
    v43 = v40;
  if ((v35 & 0x80) != 0)
  {
    if (!memcmp(*v39, v43, v25[3].__r_.__value_.__r.__words[0]))
      goto LABEL_120;
    goto LABEL_123;
  }
  if (v25[3].__r_.__value_.__s.__data_[15])
  {
    while (*(unsigned __int8 *)v39 == *v43)
    {
      v39 = (const void **)((char *)v39 + 1);
      ++v43;
      if (!--v35)
        goto LABEL_120;
    }
    goto LABEL_123;
  }
LABEL_120:
  v75.__r_.__value_.__r.__words[0] = (std::string::size_type)&__str;
  std::vector<XPathStepInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&v75);
  v75.__r_.__value_.__r.__words[0] = (std::string::size_type)&v83;
  std::vector<XPathStepInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&v75);
}

void sub_187E4FCE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,char a25)
{
  std::__split_buffer<XPathStepInfo>::~__split_buffer((uint64_t)&a9);
  if (a20 < 0)
    operator delete(__p);
  __p = &a22;
  std::vector<XPathStepInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  __p = &a25;
  std::vector<XPathStepInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

void ExpandXPath(char *a1, _BYTE *a2, uint64_t *a3)
{
  int v5;
  unint64_t v7;
  uint64_t v8;
  uint64_t i;
  int v10;
  BOOL v11;
  std::string *v13;
  int v14;
  unsigned __int8 *v15;
  uint64_t v16;
  uint64_t j;
  size_t v18;
  size_t v19;
  size_t v20;
  const void *p_s1;
  unint64_t v22;
  unint64_t v23;
  __int128 v24;
  unint64_t v25;
  unint64_t v26;
  __int128 v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  char *v32;
  char *v33;
  uint64_t v34;
  __int128 v35;
  uint64_t v36;
  int v37;
  unint64_t v38;
  unint64_t v39;
  __int128 v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  char *v45;
  char *v46;
  uint64_t v47;
  __int128 v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  char *v55;
  char *v56;
  uint64_t v57;
  __int128 v58;
  uint64_t v59;
  int v60;
  unint64_t v61;
  unint64_t v62;
  __int128 v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t v67;
  char *v68;
  char *v69;
  uint64_t v70;
  __int128 v71;
  uint64_t v72;
  int v73;
  char *v74;
  char *v75;
  int v76;
  int v77;
  int v78;
  char *v79;
  char v80;
  int v81;
  int v82;
  unsigned __int8 *v83;
  int v84;
  int v85;
  int v86;
  uint64_t k;
  unsigned __int8 *v88;
  int v89;
  unsigned __int8 *v90;
  int v91;
  int v92;
  int v93;
  int v94;
  uint64_t v95;
  int v96;
  int v97;
  std::string *v98;
  int v99;
  std::string::value_type *v100;
  std::string *v101;
  std::string::size_type v102;
  int v103;
  std::string *v104;
  std::string::size_type v105;
  int v106;
  BOOL v108;
  std::string *v109;
  unint64_t v110;
  unint64_t v111;
  __int128 v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  unint64_t v116;
  char *v117;
  char *v118;
  uint64_t v119;
  __int128 v120;
  uint64_t v121;
  int v122;
  const char *v123;
  int v124;
  const char *v125;
  _QWORD *v126;
  const char *v127;
  _QWORD *v128;
  _QWORD *exception;
  const char *v130;
  _QWORD *v131;
  std::string v132;
  std::string v133;
  void *__s1;
  uint64_t v135;
  uint64_t v136;
  std::string __p;
  unsigned int v138;
  char *__s;
  char *v140;
  char *v141;
  char *v142;
  char *v143;
  uint64_t *v144;

  if (!a1 || !a2 || !a3 || (v5 = *a2, !*a2))
    ExpandXPath();
  memset(&v133, 0, sizeof(v133));
  v7 = 2;
  v8 = 1;
  while (v5 == 47 || v5 == 91)
  {
    ++v7;
LABEL_11:
    v5 = a2[v8++];
  }
  if (v5)
    goto LABEL_11;
  std::vector<XPathStepInfo>::__clear[abi:ne180100](a3);
  std::vector<XPathStepInfo>::reserve(a3, v7);
  for (i = 0; ; ++i)
  {
    v10 = a2[i];
    v11 = (v10 - 42) > 0x31 || ((1 << (v10 - 42)) & 0x2000000000021) == 0;
    if (!v11 || v10 == 0)
      break;
  }
  if (!i)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 102;
    v130 = "Empty initial XPath step";
    goto LABEL_199;
  }
  MEMORY[0x18D761A20](&v133, a2, i);
  if ((SHIBYTE(v133.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    v13 = &v133;
    goto LABEL_24;
  }
  v13 = (std::string *)v133.__r_.__value_.__r.__words[0];
  if (!v133.__r_.__value_.__r.__words[0])
    goto LABEL_191;
LABEL_24:
  v14 = v13->__r_.__value_.__s.__data_[0];
  if (!v13->__r_.__value_.__s.__data_[0])
  {
LABEL_191:
    v123 = "(schemaURI != 0) && (propName != 0) && (*propName != 0)";
    v124 = 170;
    goto LABEL_195;
  }
  if (*a3 != a3[1])
  {
    v123 = "(expandedXPath != 0) && (expandedXPath->empty())";
    v124 = 171;
LABEL_195:
    __assert_rtn("VerifyXPathRoot", "XMPCore_Impl.cpp", v124, v123);
  }
  if (!*a1)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 101;
    v130 = "Schema namespace URI is required";
    goto LABEL_199;
  }
  if ((v14 - 63) < 2)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 102;
    v130 = "Top level name must not be a qualifier";
    goto LABEL_199;
  }
  v15 = &a2[i];
  v16 = 1;
  if (v13->__r_.__value_.__s.__data_[0])
  {
    while (v14 != 47 && v14 != 91)
    {
      v14 = v13->__r_.__value_.__s.__data_[v16++];
      if (!v14)
        goto LABEL_32;
    }
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 102;
    v130 = "Top level name must be simple";
LABEL_199:
    exception[1] = v130;
    *((_BYTE *)exception + 16) = 0;
  }
LABEL_32:
  __s = 0;
  if (!XMP_NamespaceTable::GetPrefix((XMP_NamespaceTable *)sRegisteredNamespaces, a1, (const char **)&__s, 0))
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 101;
    v130 = "Unregistered schema namespace URI";
    goto LABEL_199;
  }
  for (j = 0; v13->__r_.__value_.__s.__data_[j] && v13->__r_.__value_.__s.__data_[j] != 58; ++j)
    ;
  VerifySimpleXMLName((char *)v13, (char *)v13 + j);
  if (v13->__r_.__value_.__s.__data_[j])
  {
    v18 = strlen((const char *)v13 + j);
    VerifySimpleXMLName(&v13->__r_.__value_.__s.__data_[j + 1], (char *)v13 + j + v18);
    __s1 = 0;
    v135 = 0;
    v136 = 0;
    std::string::basic_string[abi:ne180100](&__s1, v13, j + 1);
    v19 = strlen(__s);
    v20 = v19;
    if ((SHIBYTE(v136) & 0x80000000) == 0)
    {
      if (v19 == HIBYTE(v136))
      {
        if (v19 != -1)
        {
          p_s1 = &__s1;
          goto LABEL_47;
        }
LABEL_213:
        std::string::__throw_out_of_range[abi:ne180100]();
      }
LABEL_208:
      v131 = __cxa_allocate_exception(0x18uLL);
      *(_DWORD *)v131 = 101;
      v131[1] = "Schema namespace URI and prefix mismatch";
      *((_BYTE *)v131 + 16) = 0;
    }
    if (v19 != v135)
      goto LABEL_208;
    if (v19 == -1)
      goto LABEL_213;
    p_s1 = __s1;
LABEL_47:
    if (memcmp(p_s1, __s, v20))
      goto LABEL_208;
    std::string::basic_string[abi:ne180100]<0>(&__p, a1);
    v138 = 0x80000000;
    v25 = a3[2];
    v26 = a3[1];
    if (v26 >= v25)
    {
      v28 = (uint64_t)(v26 - *a3) >> 5;
      v29 = v28 + 1;
      if ((unint64_t)(v28 + 1) >> 59)
        std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
      v30 = v25 - *a3;
      if (v30 >> 4 > v29)
        v29 = v30 >> 4;
      if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFE0)
        v31 = 0x7FFFFFFFFFFFFFFLL;
      else
        v31 = v29;
      v144 = a3 + 2;
      v32 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<XPathStepInfo>>((uint64_t)(a3 + 2), v31);
      v33 = &v32[32 * v28];
      v140 = v32;
      v141 = v33;
      v143 = &v32[32 * v34];
      v35 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *((_QWORD *)v33 + 2) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
      *(_OWORD *)v33 = v35;
      memset(&__p, 0, sizeof(__p));
      *((_DWORD *)v33 + 6) = v138;
      v142 = v33 + 32;
      std::vector<XPathStepInfo>::__swap_out_circular_buffer(a3, &v140);
      v36 = a3[1];
      std::__split_buffer<XPathStepInfo>::~__split_buffer((uint64_t)&v140);
      v37 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
      a3[1] = v36;
      if (v37 < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    else
    {
      v27 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *(_QWORD *)(v26 + 16) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
      *(_OWORD *)v26 = v27;
      memset(&__p, 0, sizeof(__p));
      *(_DWORD *)(v26 + 24) = v138;
      a3[1] = v26 + 32;
    }
    std::string::basic_string[abi:ne180100]<0>(&__p, (char *)v13);
    v138 = 0;
    v38 = a3[1];
    v39 = a3[2];
    if (v38 >= v39)
    {
      v41 = (uint64_t)(v38 - *a3) >> 5;
      v42 = v41 + 1;
      if ((unint64_t)(v41 + 1) >> 59)
        std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
      v43 = v39 - *a3;
      if (v43 >> 4 > v42)
        v42 = v43 >> 4;
      if ((unint64_t)v43 >= 0x7FFFFFFFFFFFFFE0)
        v44 = 0x7FFFFFFFFFFFFFFLL;
      else
        v44 = v42;
      v144 = a3 + 2;
      v45 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<XPathStepInfo>>((uint64_t)(a3 + 2), v44);
      v46 = &v45[32 * v41];
      v140 = v45;
      v141 = v46;
      v143 = &v45[32 * v47];
      v48 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *((_QWORD *)v46 + 2) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
      *(_OWORD *)v46 = v48;
      memset(&__p, 0, sizeof(__p));
      *((_DWORD *)v46 + 6) = v138;
      v142 = v46 + 32;
      std::vector<XPathStepInfo>::__swap_out_circular_buffer(a3, &v140);
      v49 = a3[1];
      std::__split_buffer<XPathStepInfo>::~__split_buffer((uint64_t)&v140);
      v50 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
      a3[1] = v49;
      if (v50 < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    else
    {
      v40 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *(_QWORD *)(v38 + 16) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
      *(_OWORD *)v38 = v40;
      memset(&__p, 0, sizeof(__p));
      *(_DWORD *)(v38 + 24) = v138;
      a3[1] = v38 + 32;
    }
    if (SHIBYTE(v136) < 0)
      operator delete(__s1);
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(&__p, a1);
    v138 = 0x80000000;
    v22 = a3[2];
    v23 = a3[1];
    if (v23 >= v22)
    {
      v51 = (uint64_t)(v23 - *a3) >> 5;
      v52 = v51 + 1;
      if ((unint64_t)(v51 + 1) >> 59)
        std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
      v53 = v22 - *a3;
      if (v53 >> 4 > v52)
        v52 = v53 >> 4;
      if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFE0)
        v54 = 0x7FFFFFFFFFFFFFFLL;
      else
        v54 = v52;
      v144 = a3 + 2;
      v55 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<XPathStepInfo>>((uint64_t)(a3 + 2), v54);
      v56 = &v55[32 * v51];
      v140 = v55;
      v141 = v56;
      v143 = &v55[32 * v57];
      v58 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *((_QWORD *)v56 + 2) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
      *(_OWORD *)v56 = v58;
      memset(&__p, 0, sizeof(__p));
      *((_DWORD *)v56 + 6) = v138;
      v142 = v56 + 32;
      std::vector<XPathStepInfo>::__swap_out_circular_buffer(a3, &v140);
      v59 = a3[1];
      std::__split_buffer<XPathStepInfo>::~__split_buffer((uint64_t)&v140);
      v60 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
      a3[1] = v59;
      if (v60 < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    else
    {
      v24 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *(_QWORD *)(v23 + 16) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
      *(_OWORD *)v23 = v24;
      memset(&__p, 0, sizeof(__p));
      *(_DWORD *)(v23 + 24) = v138;
      a3[1] = v23 + 32;
    }
    std::string::basic_string[abi:ne180100]<0>(&__p, __s);
    v138 = 0;
    v61 = a3[1];
    v62 = a3[2];
    if (v61 >= v62)
    {
      v64 = (uint64_t)(v61 - *a3) >> 5;
      v65 = v64 + 1;
      if ((unint64_t)(v64 + 1) >> 59)
        std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
      v66 = v62 - *a3;
      if (v66 >> 4 > v65)
        v65 = v66 >> 4;
      if ((unint64_t)v66 >= 0x7FFFFFFFFFFFFFE0)
        v67 = 0x7FFFFFFFFFFFFFFLL;
      else
        v67 = v65;
      v144 = a3 + 2;
      v68 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<XPathStepInfo>>((uint64_t)(a3 + 2), v67);
      v69 = &v68[32 * v64];
      v140 = v68;
      v141 = v69;
      v143 = &v68[32 * v70];
      v71 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *((_QWORD *)v69 + 2) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
      *(_OWORD *)v69 = v71;
      memset(&__p, 0, sizeof(__p));
      *((_DWORD *)v69 + 6) = v138;
      v142 = v69 + 32;
      std::vector<XPathStepInfo>::__swap_out_circular_buffer(a3, &v140);
      v72 = a3[1];
      std::__split_buffer<XPathStepInfo>::~__split_buffer((uint64_t)&v140);
      v73 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
      a3[1] = v72;
      if (v73 < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    else
    {
      v63 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *(_QWORD *)(v61 + 16) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
      *(_OWORD *)v61 = v63;
      memset(&__p, 0, sizeof(__p));
      *(_DWORD *)(v61 + 24) = v138;
      a3[1] = v61 + 32;
    }
    std::string::append((std::string *)(*a3 + 32), (const std::string::value_type *)v13);
  }
  v74 = 0;
  v75 = 0;
  if (sRegisteredAliasMap + 8 == std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::find<std::string>(sRegisteredAliasMap, (const void **)(*a3 + 32)))v76 = 1;
  else
    v76 = 17;
  *(_DWORD *)(*a3 + 56) |= v76;
  while (2)
  {
    v77 = *v15;
    if (v77 == 47)
    {
      v78 = *++v15;
      v77 = v78;
LABEL_97:
      if (v77 == 42)
      {
        v82 = *++v15;
        if (v82 != 91)
        {
          v127 = "Missing '[' after '*'";
          goto LABEL_197;
        }
      }
      else
      {
        v79 = (char *)v15;
        if (v77 != 91)
        {
          while ((v77 - 42 > 0x31
                || ((1 << (v77 - 42)) & 0x2000000000021) == 0)
               && (_BYTE)v77)
          {
            v80 = *++v79;
            LOBYTE(v77) = v80;
          }
          v81 = 1;
          v74 = (char *)v15;
          v75 = v79;
          goto LABEL_129;
        }
      }
      v83 = v15 + 1;
      v84 = v15[1];
      if ((v84 - 48) < 0xA)
      {
        do
        {
          v86 = *++v83;
          v85 = v86;
        }
        while ((v86 - 48) < 0xA);
        if (v85 == 93)
        {
          v81 = 3;
          goto LABEL_125;
        }
        v127 = "Missing ']' for integer array index";
LABEL_197:
        v128 = __cxa_allocate_exception(0x18uLL);
        *(_DWORD *)v128 = 102;
        v128[1] = v127;
        *((_BYTE *)v128 + 16) = 0;
      }
      for (k = 0; ; ++k)
      {
        if (v84 == 61)
        {
          v88 = &v15[k];
          v89 = v15[k + 2];
          if (v89 == 34 || v89 == 39)
          {
            v90 = v88 + 3;
            v91 = v88[3];
            if (v88[3])
            {
              v75 = (char *)(v88 + 1);
              while (1)
              {
                if (v91 == v89)
                {
                  v93 = *++v90;
                  v92 = v93;
                  if (v93 != v89)
                    break;
                }
                v94 = *++v90;
                v91 = v94;
                if (!v94)
                  goto LABEL_192;
              }
              v81 = 6;
              v74 = (char *)(v15 + 1);
              goto LABEL_127;
            }
LABEL_192:
            v125 = "No terminating quote for array selector";
          }
          else
          {
            v125 = "Invalid quote in array selector";
          }
          v126 = __cxa_allocate_exception(0x18uLL);
          *(_DWORD *)v126 = 102;
          v126[1] = v125;
          *((_BYTE *)v126 + 16) = 0;
        }
        if (v84 == 93)
          break;
        if (!v84)
        {
          v127 = "Missing ']' or '=' for array index";
          goto LABEL_197;
        }
        v84 = v15[k + 2];
      }
      v95 = k + 1;
      if (strncmp("[last()", (const char *)v15, k + 1))
      {
        v127 = "Invalid non-numeric array index";
        goto LABEL_197;
      }
      v83 = &v15[v95];
      v81 = 4;
LABEL_125:
      v92 = *v83;
      v90 = v83;
LABEL_127:
      if (v92 != 93)
      {
        v127 = "Missing ']' for array index";
        goto LABEL_197;
      }
      v79 = (char *)(v90 + 1);
LABEL_129:
      if (v79 == (char *)v15)
      {
        v127 = "Empty XPath step";
        goto LABEL_197;
      }
      MEMORY[0x18D761A20](&v133, v15, v79 - (char *)v15);
      if (v81 != 6)
      {
        if (v81 != 1)
        {
LABEL_168:
          if (SHIBYTE(v133.__r_.__value_.__r.__words[2]) < 0)
            std::string::__init_copy_ctor_external(&v132, v133.__r_.__value_.__l.__data_, v133.__r_.__value_.__l.__size_);
          else
            v132 = v133;
          if (SHIBYTE(v132.__r_.__value_.__r.__words[2]) < 0)
            std::string::__init_copy_ctor_external(&__p, v132.__r_.__value_.__l.__data_, v132.__r_.__value_.__l.__size_);
          else
            __p = v132;
          v138 = v81;
          v110 = a3[1];
          v111 = a3[2];
          if (v110 >= v111)
          {
            v113 = (uint64_t)(v110 - *a3) >> 5;
            v114 = v113 + 1;
            if ((unint64_t)(v113 + 1) >> 59)
              std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
            v115 = v111 - *a3;
            if (v115 >> 4 > v114)
              v114 = v115 >> 4;
            if ((unint64_t)v115 >= 0x7FFFFFFFFFFFFFE0)
              v116 = 0x7FFFFFFFFFFFFFFLL;
            else
              v116 = v114;
            v144 = a3 + 2;
            v117 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<XPathStepInfo>>((uint64_t)(a3 + 2), v116);
            v118 = &v117[32 * v113];
            v140 = v117;
            v141 = v118;
            v143 = &v117[32 * v119];
            v120 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
            *((_QWORD *)v118 + 2) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
            *(_OWORD *)v118 = v120;
            memset(&__p, 0, sizeof(__p));
            *((_DWORD *)v118 + 6) = v138;
            v142 = v118 + 32;
            std::vector<XPathStepInfo>::__swap_out_circular_buffer(a3, &v140);
            v121 = a3[1];
            std::__split_buffer<XPathStepInfo>::~__split_buffer((uint64_t)&v140);
            v122 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
            a3[1] = v121;
            if (v122 < 0)
              operator delete(__p.__r_.__value_.__l.__data_);
          }
          else
          {
            v112 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
            *(_QWORD *)(v110 + 16) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
            *(_OWORD *)v110 = v112;
            memset(&__p, 0, sizeof(__p));
            *(_DWORD *)(v110 + 24) = v138;
            a3[1] = v110 + 32;
          }
          if (SHIBYTE(v132.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v132.__r_.__value_.__l.__data_);
          v15 = (unsigned __int8 *)v79;
          continue;
        }
        v96 = SHIBYTE(v133.__r_.__value_.__r.__words[2]);
        if (SHIBYTE(v133.__r_.__value_.__r.__words[2]) < 0)
        {
          v98 = (std::string *)v133.__r_.__value_.__r.__words[0];
          if (*v133.__r_.__value_.__l.__data_ != 64)
          {
LABEL_161:
            v108 = v96 < 0;
            v109 = &v133;
            if (v108)
              v109 = v98;
            v97 = v109->__r_.__value_.__s.__data_[0];
            goto LABEL_164;
          }
        }
        else
        {
          v97 = v133.__r_.__value_.__s.__data_[0];
          if (v133.__r_.__value_.__s.__data_[0] != 64)
          {
LABEL_164:
            if (v97 == 63)
            {
              ++v74;
              v81 = 2;
            }
            else
            {
              v81 = 1;
            }
LABEL_167:
            VerifyQualName(v74, v75);
            goto LABEL_168;
          }
          v98 = &v133;
        }
        v98->__r_.__value_.__s.__data_[0] = 63;
        v96 = SHIBYTE(v133.__r_.__value_.__r.__words[2]);
        if (SHIBYTE(v133.__r_.__value_.__r.__words[2]) < 0)
        {
          if (v133.__r_.__value_.__l.__size_ != 9)
            goto LABEL_202;
          v101 = (std::string *)v133.__r_.__value_.__r.__words[0];
        }
        else
        {
          if (SHIBYTE(v133.__r_.__value_.__r.__words[2]) != 9)
            goto LABEL_202;
          v101 = &v133;
        }
        v105 = v101->__r_.__value_.__r.__words[0];
        v106 = v101->__r_.__value_.__s.__data_[8];
        if (v105 != 0x6E616C3A6C6D783FLL || v106 != 103)
        {
LABEL_202:
          v127 = "Only xml:lang allowed with '@'";
          goto LABEL_197;
        }
        v98 = (std::string *)v133.__r_.__value_.__r.__words[0];
        goto LABEL_161;
      }
      if (SHIBYTE(v133.__r_.__value_.__r.__words[2]) < 0)
      {
        v102 = v133.__r_.__value_.__r.__words[0];
        v100 = (std::string::value_type *)(v133.__r_.__value_.__r.__words[0] + 1);
        if (*(_BYTE *)(v133.__r_.__value_.__r.__words[0] + 1) != 64)
        {
LABEL_149:
          v99 = *(unsigned __int8 *)(v102 + 1);
          goto LABEL_150;
        }
      }
      else
      {
        v99 = v133.__r_.__value_.__s.__data_[1];
        v100 = &v133.__r_.__value_.__s.__data_[1];
        if (v133.__r_.__value_.__s.__data_[1] != 64)
        {
LABEL_150:
          if (v99 == 63)
          {
            ++v74;
            v81 = 5;
          }
          else
          {
            v81 = 6;
          }
          goto LABEL_167;
        }
      }
      *v100 = 63;
      v103 = SHIBYTE(v133.__r_.__value_.__r.__words[2]);
      v102 = v133.__r_.__value_.__r.__words[0];
      if ((v133.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v104 = &v133;
      else
        v104 = (std::string *)v133.__r_.__value_.__r.__words[0];
      if (strncmp((const char *)v104, "[?xml:lang=", 0xBuLL))
        goto LABEL_202;
      if ((v103 & 0x80000000) == 0)
      {
        v99 = BYTE1(v102);
        goto LABEL_150;
      }
      goto LABEL_149;
    }
    break;
  }
  if (*v15)
    goto LABEL_97;
  if (SHIBYTE(v133.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v133.__r_.__value_.__l.__data_);
}

void sub_187E50A30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  uint64_t v35;

  std::__split_buffer<XPathStepInfo>::~__split_buffer(v35 - 128);
  if (a35 < 0)
    operator delete(__p);
  if (a23 < 0)
    operator delete(a18);
  _Unwind_Resume(a1);
}

uint64_t std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::find<std::string>(uint64_t a1, const void **a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  _BOOL4 v7;
  uint64_t *v8;

  v2 = a1 + 8;
  v3 = *(_QWORD *)(a1 + 8);
  if (!v3)
    return v2;
  v5 = a1 + 16;
  v6 = a1 + 8;
  do
  {
    v7 = std::less<std::string>::operator()[abi:ne180100](v5, (const void **)(v3 + 32), a2);
    v8 = (uint64_t *)(v3 + 8);
    if (!v7)
    {
      v8 = (uint64_t *)v3;
      v6 = v3;
    }
    v3 = *v8;
  }
  while (*v8);
  if (v6 == v2 || std::less<std::string>::operator()[abi:ne180100](v5, a2, (const void **)(v6 + 32)))
    return v2;
  return v6;
}

char *VerifySimpleXMLName(char *result, char *a2)
{
  char *v3;
  int v4;
  char *v5;
  BOOL v7;
  int v8;
  unsigned int v10;
  unsigned int v11;
  BOOL v14;
  _QWORD *exception;
  const char *v16;
  unint64_t v17;
  unsigned int v18;

  if (result >= a2)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 102;
    v16 = "Empty XML name";
LABEL_63:
    exception[1] = v16;
    *((_BYTE *)exception + 16) = 0;
  }
  v3 = result;
  if ((*result & 0x80000000) == 0)
  {
    v4 = *result;
    v5 = result + 1;
    if ((v4 - 97) < 0x1A)
      goto LABEL_14;
    if (v4 == 95 || (v4 - 65) < 0x1A)
      goto LABEL_14;
    goto LABEL_61;
  }
  v18 = 0;
  v17 = 0;
  result = CodePoint_from_UTF8(result, 4uLL, &v18, &v17);
  v5 = &v3[v17];
  v7 = v18 - 192 >= 0x17 && v18 - 216 >= 0x1F;
  if (v7
    && v18 - 248 >= 0x208
    && v18 - 880 >= 0xE
    && v18 - 895 >= 0x1C81
    && (v18 & 0xFFFFFFFE) != 0x200C
    && v18 - 8304 >= 0x120
    && v18 - 11264 >= 0x3F0
    && v18 - 12289 >= 0xA7FF
    && v18 - 63744 >= 0x4D0
    && v18 - 65008 >= 0x20E
    && (v18 - 0x10000) >> 17 > 6)
  {
LABEL_61:
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 102;
    v16 = "Bad XML name";
    goto LABEL_63;
  }
LABEL_14:
  while (v5 < a2)
  {
    if (*v5 < 0)
    {
      v18 = 0;
      v17 = 0;
      result = CodePoint_from_UTF8(v5, 4uLL, &v18, &v17);
      v5 += v17;
      if (v18 - 192 >= 0x17 && v18 - 216 >= 0x1F)
      {
        v14 = v18 - 248 >= 0x208 && v18 - 880 >= 0xE;
        if (v14
          && v18 - 895 >= 0x1C81
          && (v18 & 0xFFFFFFFE) != 0x200C
          && v18 - 8304 >= 0x120
          && v18 - 11264 >= 0x3F0
          && v18 - 12289 >= 0xA7FF
          && v18 - 63744 >= 0x4D0
          && v18 - 768 >= 0x70
          && v18 - 65008 >= 0x20E
          && v18 - 0x10000 >= 0xE0000
          && v18 - 8255 >= 2
          && v18 != 183)
        {
          goto LABEL_61;
        }
      }
    }
    else
    {
      v8 = *v5++;
      if ((v8 - 97) >= 0x1A && v8 != 95 && (v8 - 65) >= 0x1A)
      {
        v10 = v8 - 48;
        v11 = v8 - 45;
        if (v10 >= 0xA && v11 >= 2)
          goto LABEL_61;
      }
    }
  }
  return result;
}

uint64_t std::vector<XPathStepInfo>::reserve(uint64_t *a1, unint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v7[5];

  v4 = a1[2];
  result = (uint64_t)(a1 + 2);
  if (a2 > (v4 - *a1) >> 5)
  {
    if (a2 >> 59)
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:ne180100]<std::allocator<XPathStepInfo>>(result, a2);
    v7[1] = v7[0] + v5;
    v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 32 * v6;
    std::vector<XPathStepInfo>::__swap_out_circular_buffer(a1, v7);
    return std::__split_buffer<XPathStepInfo>::~__split_buffer((uint64_t)v7);
  }
  return result;
}

void sub_187E50F14(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<XPathStepInfo>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<XPathStepInfo>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<XPathStepInfo>,std::reverse_iterator<XPathStepInfo*>,std::reverse_iterator<XPathStepInfo*>,std::reverse_iterator<XPathStepInfo*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<XPathStepInfo>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<XPathStepInfo>::__destruct_at_end[abi:ne180100](a1, *(void ***)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

BOOL XMP_NamespaceTable::Define(XMP_NamespaceTable *this, char *a2, char *a3, const char **a4, unsigned int *a5)
{
  std::string::size_type v10;
  char v11;
  std::string::size_type size;
  std::string *v13;
  std::string::size_type v14;
  const char *v15;
  int v16;
  char *v17;
  const char *v18;
  int v19;
  BOOL v20;
  unsigned int v21;
  unsigned int v22;
  BOOL v25;
  uint64_t **v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t **v29;
  uint64_t *v30;
  int v31;
  std::string::size_type v32;
  std::string::size_type v33;
  __int128 v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  std::string::size_type v39;
  int v40;
  const void **v41;
  std::string *v42;
  uint64_t v43;
  int v44;
  int v45;
  int v46;
  int v47;
  char v48;
  _BOOL8 v49;
  _QWORD *exception;
  const char *v52;
  std::string v53[2];
  std::string v54;
  std::string v55;
  __int128 v56;
  uint64_t v57;
  XMP_ReadWriteLock *v58;
  char __str[16];
  __int128 v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  v58 = (XMP_NamespaceTable *)((char *)this + 8);
  XMP_ReadWriteLock::Acquire((pthread_rwlock_t *)((char *)this + 8), 1);
  if (!a2 || !a3 || !*a2 || !*a3)
    __assert_rtn("Define", "XMP_LibUtils.cpp", 451, "(_uri != 0) && (*_uri != 0) && (_suggPrefix != 0) && (*_suggPrefix != 0)");
  v56 = 0uLL;
  v57 = 0;
  std::string::basic_string[abi:ne180100]<0>(&v56, a2);
  memset(&v55, 0, sizeof(v55));
  std::string::basic_string[abi:ne180100]<0>(&v55, a3);
  v10 = HIBYTE(v55.__r_.__value_.__r.__words[2]);
  v11 = HIBYTE(v55.__r_.__value_.__r.__words[2]);
  size = v55.__r_.__value_.__l.__size_;
  v13 = (std::string *)v55.__r_.__value_.__r.__words[0];
  if ((v55.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v14 = HIBYTE(v55.__r_.__value_.__r.__words[2]);
  else
    v14 = v55.__r_.__value_.__l.__size_;
  if ((v55.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v13 = &v55;
  if (v13->__r_.__value_.__s.__data_[v14 - 1] != 58)
  {
    std::string::push_back(&v55, 58);
    v10 = HIBYTE(v55.__r_.__value_.__r.__words[2]);
    size = v55.__r_.__value_.__l.__size_;
    v11 = HIBYTE(v55.__r_.__value_.__r.__words[2]);
  }
  if (v11 < 0)
    v10 = size;
  v15 = &a3[v10 - 1];
  if (v15 <= a3)
  {
    v18 = "Empty XML name";
    goto LABEL_123;
  }
  if (*a3 < 0)
  {
    *(_DWORD *)__str = 0;
    v53[0].__r_.__value_.__r.__words[0] = 0;
    CodePoint_from_UTF8(a3, 4uLL, (unsigned int *)__str, (unint64_t *)v53);
    v17 = &a3[v53[0].__r_.__value_.__r.__words[0]];
    if ((*(_DWORD *)__str - 192) >= 0x17
      && (*(_DWORD *)__str - 216) >= 0x1F
      && (*(_DWORD *)__str - 248) >= 0x208
      && (*(_DWORD *)__str - 880) >= 0xE
      && (*(_DWORD *)__str - 895) >= 0x1C81
      && (*(_DWORD *)__str & 0xFFFFFFFE) != 0x200C
      && (*(_DWORD *)__str - 8304) >= 0x120
      && (*(_DWORD *)__str - 11264) >= 0x3F0
      && (*(_DWORD *)__str - 12289) >= 0xA7FF
      && (*(_DWORD *)__str - 63744) >= 0x4D0
      && (*(_DWORD *)__str - 65008) >= 0x20E
      && (*(_DWORD *)__str - 0x10000) >> 17 > 6)
    {
      goto LABEL_19;
    }
  }
  else
  {
    v16 = *a3;
    v17 = a3 + 1;
    if ((v16 - 97) >= 0x1A && v16 != 95 && (v16 - 65) >= 0x1A)
    {
LABEL_19:
      v18 = "Bad XML name";
LABEL_123:
      v52 = v18;
LABEL_124:
      exception = __cxa_allocate_exception(0x18uLL);
      *(_DWORD *)exception = 102;
      exception[1] = v52;
      *((_BYTE *)exception + 16) = 0;
    }
  }
  if (v17 < v15)
  {
    v52 = "Bad XML name";
    do
    {
      if (*v17 < 0)
      {
        *(_DWORD *)__str = 0;
        v53[0].__r_.__value_.__r.__words[0] = 0;
        CodePoint_from_UTF8(v17, 4uLL, (unsigned int *)__str, (unint64_t *)v53);
        v17 += v53[0].__r_.__value_.__r.__words[0];
        if ((*(_DWORD *)__str - 192) >= 0x17 && (*(_DWORD *)__str - 216) >= 0x1F)
        {
          v25 = (*(_DWORD *)__str - 248) >= 0x208 && (*(_DWORD *)__str - 880) >= 0xE;
          if (v25
            && (*(_DWORD *)__str - 895) >= 0x1C81
            && (*(_DWORD *)__str & 0xFFFFFFFE) != 0x200C
            && (*(_DWORD *)__str - 8304) >= 0x120
            && (*(_DWORD *)__str - 11264) >= 0x3F0
            && (*(_DWORD *)__str - 12289) >= 0xA7FF
            && (*(_DWORD *)__str - 63744) >= 0x4D0
            && (*(_DWORD *)__str - 768) >= 0x70
            && (*(_DWORD *)__str - 65008) >= 0x20E
            && (*(_DWORD *)__str - 0x10000) >= 0xE0000
            && (*(_DWORD *)__str - 8255) >= 2
            && *(_DWORD *)__str != 183)
          {
            goto LABEL_124;
          }
        }
      }
      else
      {
        v19 = *v17++;
        if ((v19 - 97) >= 0x1A)
        {
          v20 = v19 != 95 && (v19 - 65) >= 0x1A;
          if (v20)
          {
            v21 = v19 - 48;
            v22 = v19 - 45;
            if (v21 >= 0xA && v22 >= 2)
              goto LABEL_124;
          }
        }
      }
    }
    while (v17 < v15);
  }
  v26 = (uint64_t **)((char *)this + 216);
  v27 = std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::find<std::string>((uint64_t)this + 216, (const void **)&v56);
  v28 = (uint64_t *)((char *)this + 224);
  if ((XMP_NamespaceTable *)((char *)this + 224) == (XMP_NamespaceTable *)v27)
  {
    memset(&v54, 0, sizeof(v54));
    if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0)
      std::string::__init_copy_ctor_external(&v54, v55.__r_.__value_.__l.__data_, v55.__r_.__value_.__l.__size_);
    else
      v54 = v55;
    *(_OWORD *)__str = 0u;
    v60 = 0u;
    v29 = (uint64_t **)((char *)this + 240);
    v30 = (uint64_t *)((char *)this + 248);
    v31 = 1;
    while (v30 != (uint64_t *)std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::find<std::string>((uint64_t)v29, (const void **)&v54.__r_.__value_.__l.__data_))
    {
      snprintf(__str, 0x20uLL, "_%d_:", v31);
      std::string::operator=(&v54, &v55);
      v32 = HIBYTE(v54.__r_.__value_.__r.__words[2]);
      if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v32 = v54.__r_.__value_.__l.__size_;
      std::string::erase(&v54, v32 - 1, 0xFFFFFFFFFFFFFFFFLL);
      ++v31;
      std::string::append(&v54, __str);
    }
    memset(v53, 0, sizeof(v53));
    std::pair<std::string,std::string>::pair[abi:ne180100]<std::string&,std::string&,0>(v53, &v56, (__int128 *)&v54);
    v27 = (uint64_t)std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string,std::string> &>(v26, v28, (const void **)&v53[0].__r_.__value_.__l.__data_, (__int128 *)v53);
    v33 = v53[0].__r_.__value_.__r.__words[2];
    v34 = *(_OWORD *)&v53[0].__r_.__value_.__l.__data_;
    v53[0] = v53[1];
    *(_OWORD *)&v53[1].__r_.__value_.__l.__data_ = v34;
    v53[1].__r_.__value_.__r.__words[2] = v33;
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string,std::string> &>(v29, v30, (const void **)&v53[0].__r_.__value_.__l.__data_, (__int128 *)v53);
    if (SHIBYTE(v53[1].__r_.__value_.__r.__words[2]) < 0)
      operator delete(v53[1].__r_.__value_.__l.__data_);
    if (SHIBYTE(v53[0].__r_.__value_.__r.__words[2]) < 0)
      operator delete(v53[0].__r_.__value_.__l.__data_);
    if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v54.__r_.__value_.__l.__data_);
  }
  if (a4)
  {
    v35 = (const char *)(v27 + 56);
    if (*(char *)(v27 + 79) < 0)
      v35 = *(const char **)v35;
    *a4 = v35;
  }
  if (a5)
  {
    if (*(char *)(v27 + 79) < 0)
      v36 = *(_QWORD *)(v27 + 64);
    else
      LODWORD(v36) = *(unsigned __int8 *)(v27 + 79);
    *a5 = v36;
  }
  v37 = *(unsigned __int8 *)(v27 + 79);
  if ((v37 & 0x80u) == 0)
    v38 = *(unsigned __int8 *)(v27 + 79);
  else
    v38 = *(_QWORD *)(v27 + 64);
  v39 = HIBYTE(v55.__r_.__value_.__r.__words[2]);
  v40 = SHIBYTE(v55.__r_.__value_.__r.__words[2]);
  if ((v55.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v39 = v55.__r_.__value_.__l.__size_;
  if (v38 != v39)
  {
    v49 = 0;
    if ((SHIBYTE(v55.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_112;
    goto LABEL_116;
  }
  v41 = (const void **)(v27 + 56);
  if ((v55.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v42 = &v55;
  else
    v42 = (std::string *)v55.__r_.__value_.__r.__words[0];
  if ((v37 & 0x80) != 0)
  {
    v49 = memcmp(*v41, v42, *(_QWORD *)(v27 + 64)) == 0;
    if (v40 < 0)
      goto LABEL_116;
  }
  else
  {
    if (*(_BYTE *)(v27 + 79))
    {
      v43 = v37 - 1;
      do
      {
        v45 = *(unsigned __int8 *)v41;
        v41 = (const void **)((char *)v41 + 1);
        v44 = v45;
        v47 = v42->__r_.__value_.__s.__data_[0];
        v42 = (std::string *)((char *)v42 + 1);
        v46 = v47;
        v20 = v43-- != 0;
        v48 = v20;
        v49 = v44 == v46;
      }
      while (v44 == v46 && (v48 & 1) != 0);
      if ((SHIBYTE(v55.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_112;
      goto LABEL_116;
    }
    v49 = 1;
    if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0)
LABEL_116:
      operator delete(v55.__r_.__value_.__l.__data_);
  }
LABEL_112:
  if (SHIBYTE(v57) < 0)
    operator delete((void *)v56);
  XMP_AutoLock::~XMP_AutoLock(&v58);
  return v49;
}

void sub_187E51640(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,XMP_ReadWriteLock *a35)
{
  if (a28 < 0)
    operator delete(__p);
  if (a34 < 0)
    operator delete(a29);
  XMP_AutoLock::~XMP_AutoLock(&a35);
  _Unwind_Resume(a1);
}

BOOL XMP_NamespaceTable::GetPrefix(XMP_NamespaceTable *this, char *a2, const char **a3, unsigned int *a4)
{
  uint64_t v8;
  char *v9;
  char *v10;
  const char *v11;
  uint64_t v12;
  void *__p[2];
  uint64_t v15;
  XMP_ReadWriteLock *v16;

  v16 = (XMP_NamespaceTable *)((char *)this + 8);
  XMP_ReadWriteLock::Acquire((pthread_rwlock_t *)((char *)this + 8), 0);
  if (!a2 || !*a2)
    __assert_rtn("GetPrefix", "XMP_LibUtils.cpp", 504, "(_uri != 0) && (*_uri != 0)");
  __p[0] = 0;
  __p[1] = 0;
  v15 = 0;
  std::string::basic_string[abi:ne180100]<0>(__p, a2);
  v8 = std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::find<std::string>((uint64_t)this + 216, (const void **)__p);
  v9 = (char *)v8;
  v10 = (char *)this + 224;
  if (v10 != (char *)v8)
  {
    if (a3)
    {
      v11 = (const char *)(v8 + 56);
      if (*(char *)(v8 + 79) < 0)
        v11 = *(const char **)v11;
      *a3 = v11;
    }
    if (a4)
    {
      if (*(char *)(v8 + 79) < 0)
        v12 = *(_QWORD *)(v8 + 64);
      else
        LODWORD(v12) = *(unsigned __int8 *)(v8 + 79);
      *a4 = v12;
    }
  }
  if (SHIBYTE(v15) < 0)
    operator delete(__p[0]);
  XMP_AutoLock::~XMP_AutoLock(&v16);
  return v10 != v9;
}

void sub_187E517C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, XMP_ReadWriteLock *a15)
{
  if (a14 < 0)
    operator delete(__p);
  XMP_AutoLock::~XMP_AutoLock(&a15);
  _Unwind_Resume(a1);
}

void XMP_AutoLock::~XMP_AutoLock(XMP_ReadWriteLock **this)
{
  XMP_ReadWriteLock *v2;

  v2 = *this;
  if (v2)
    XMP_ReadWriteLock::Release(v2);
  *this = 0;
}

uint64_t XMP_ReadWriteLock::Acquire(pthread_rwlock_t *this, int a2)
{
  char v3;
  uint64_t result;
  unsigned int *v6;
  unsigned int v7;
  _QWORD *exception;
  const char *v9;

  if (a2)
  {
    v3 = a2;
    result = pthread_rwlock_wrlock(this);
    if (!(_DWORD)result)
    {
      BYTE4(this[1].__sig) = v3;
      if (atomic_load((unsigned int *)&this[1]))
        XMP_ReadWriteLock::Acquire();
      goto LABEL_7;
    }
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 11;
    v9 = "Acquire pthread write lock failed";
LABEL_13:
    exception[1] = v9;
    *((_BYTE *)exception + 16) = 0;
  }
  result = pthread_rwlock_rdlock(this);
  if ((_DWORD)result)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 11;
    v9 = "Acquire pthread read lock failed";
    goto LABEL_13;
  }
  if (BYTE4(this[1].__sig))
    XMP_ReadWriteLock::Acquire();
LABEL_7:
  v6 = (unsigned int *)&this[1];
  do
    v7 = __ldaxr(v6);
  while (__stlxr(v7 + 1, v6));
  return result;
}

uint64_t XMP_ReadWriteLock::Release(XMP_ReadWriteLock *this)
{
  unsigned int *v1;
  int v2;
  unsigned int v3;
  uint64_t result;
  _QWORD *exception;
  const char *v6;

  v1 = (unsigned int *)((char *)this + 200);
  v2 = atomic_load((unsigned int *)this + 50);
  if (v2 < 1)
    XMP_ReadWriteLock::Release();
  do
    v3 = __ldaxr(v1);
  while (__stlxr(v3 - 1, v1));
  if (*((_BYTE *)this + 204))
  {
    *((_BYTE *)this + 204) = 0;
    result = pthread_rwlock_unlock((pthread_rwlock_t *)this);
    if ((_DWORD)result)
    {
      exception = __cxa_allocate_exception(0x18uLL);
      *(_DWORD *)exception = 11;
      v6 = "Release pthread write lock failed";
      goto LABEL_10;
    }
  }
  else
  {
    result = pthread_rwlock_unlock((pthread_rwlock_t *)this);
    if ((_DWORD)result)
    {
      exception = __cxa_allocate_exception(0x18uLL);
      *(_DWORD *)exception = 11;
      v6 = "Release pthread read lock failed";
LABEL_10:
      exception[1] = v6;
      *((_BYTE *)exception + 16) = 0;
    }
  }
  return result;
}

uint64_t *std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string,std::string> &>(uint64_t **a1, uint64_t *a2, const void **a3, __int128 *a4)
{
  const void **v6;
  uint64_t *v7;
  uint64_t **v8;
  uint64_t *v10[3];
  uint64_t v11;
  const void **v12;

  v11 = 0;
  v12 = 0;
  v6 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>(a1, a2, &v12, &v11, a3);
  v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    v8 = (uint64_t **)v6;
    memset(v10, 0, sizeof(v10));
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__construct_node<std::pair<std::string,std::string> &>((uint64_t)a1, a4, v10);
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__insert_node_at(a1, (uint64_t)v12, v8, v10[0]);
    v7 = v10[0];
    v10[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::reset[abi:ne180100]((uint64_t)v10, 0);
  }
  return v7;
}

std::string *std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__construct_node<std::pair<std::string,std::string> &>@<X0>(uint64_t a1@<X0>, __int128 *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v5;
  char *v6;
  std::string *result;

  v5 = a1 + 8;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v6 = (char *)operator new(0x50uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  result = std::pair<std::string const,std::string>::pair[abi:ne180100]<std::string,std::string,0>((std::string *)(v6 + 32), a2);
  *((_BYTE *)a3 + 16) = 1;
  return result;
}

void sub_187E51A7C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

const void **std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>(_QWORD *a1, uint64_t *a2, const void ***a3, uint64_t *a4, const void **a5)
{
  const void **v9;
  const void **v11;
  const void **v12;
  uint64_t v13;
  const void **v14;
  const void **v15;
  uint64_t *v16;
  BOOL v17;
  const void **v18;

  v9 = (const void **)(a1 + 1);
  if (a1 + 1 == a2 || std::less<std::string>::operator()[abi:ne180100]((uint64_t)(a1 + 2), a5, (const void **)a2 + 4))
  {
    if ((uint64_t *)*a1 == a2)
    {
      v12 = (const void **)a2;
LABEL_16:
      if (*a2)
      {
        *a3 = v12;
        return v12 + 1;
      }
      else
      {
        *a3 = (const void **)a2;
        return (const void **)a2;
      }
    }
    v11 = (const void **)*a2;
    if (*a2)
    {
      do
      {
        v12 = v11;
        v11 = (const void **)v11[1];
      }
      while (v11);
    }
    else
    {
      v16 = a2;
      do
      {
        v12 = (const void **)v16[2];
        v17 = *v12 == v16;
        v16 = (uint64_t *)v12;
      }
      while (v17);
    }
    if (std::less<std::string>::operator()[abi:ne180100]((uint64_t)(a1 + 2), v12 + 4, a5))
      goto LABEL_16;
    return (const void **)std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::__find_equal<std::string>((uint64_t)a1, a3, a5);
  }
  if (std::less<std::string>::operator()[abi:ne180100]((uint64_t)(a1 + 2), (const void **)a2 + 4, a5))
  {
    a4 = a2 + 1;
    v13 = a2[1];
    if (v13)
    {
      v14 = (const void **)a2[1];
      do
      {
        v15 = v14;
        v14 = (const void **)*v14;
      }
      while (v14);
    }
    else
    {
      v18 = (const void **)a2;
      do
      {
        v15 = (const void **)v18[2];
        v17 = *v15 == v18;
        v18 = v15;
      }
      while (!v17);
    }
    if (v15 != v9)
    {
      if (!std::less<std::string>::operator()[abi:ne180100]((uint64_t)(a1 + 2), a5, v15 + 4))
        return (const void **)std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::__find_equal<std::string>((uint64_t)a1, a3, a5);
      v13 = *a4;
    }
    if (v13)
    {
      *a3 = v15;
      return v15;
    }
    else
    {
      *a3 = (const void **)a2;
    }
    return (const void **)a4;
  }
  *a3 = (const void **)a2;
  *a4 = (uint64_t)a2;
  return (const void **)a4;
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  std::string *v5;
  std::string::size_type v6;
  std::string::size_type v7;
  std::string *v8;

  v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8)
      std::string::__throw_length_error[abi:ne180100]();
    v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17)
      v6 = __sz | 7;
    v7 = v6 + 1;
    v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    v5 = v8;
  }
  else
  {
    *((_BYTE *)&this->__r_.__value_.__s + 23) = __sz;
  }
  memmove(v5, __s, __sz + 1);
}

_QWORD *std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::__find_equal<std::string>(uint64_t a1, _QWORD *a2, const void **a3)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v7;
  _QWORD *v8;
  const void **v9;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 8);
  if (v4)
  {
    v7 = a1 + 16;
    do
    {
      while (1)
      {
        v8 = (_QWORD *)v4;
        v9 = (const void **)(v4 + 32);
        if (!std::less<std::string>::operator()[abi:ne180100](v7, a3, (const void **)(v4 + 32)))
          break;
        v4 = *v8;
        v5 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (!std::less<std::string>::operator()[abi:ne180100](v7, v9, a3))
        break;
      v5 = v8 + 1;
      v4 = v8[1];
    }
    while (v4);
  }
  else
  {
    v8 = (_QWORD *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

uint64_t *std::__tree<std::__value_type<std::string,std::vector<XPathStepInfo>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<XPathStepInfo>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<XPathStepInfo>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::vector<XPathStepInfo>>>(uint64_t **a1, const void **a2, __int128 *a3)
{
  uint64_t **v5;
  uint64_t *v6;
  uint64_t **v7;
  uint64_t *v9[3];
  uint64_t v10;

  v10 = 0;
  v5 = (uint64_t **)std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::__find_equal<std::string>((uint64_t)a1, &v10, a2);
  v6 = *v5;
  if (!*v5)
  {
    v7 = v5;
    memset(v9, 0, sizeof(v9));
    std::__tree<std::__value_type<std::string,std::vector<XPathStepInfo>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<XPathStepInfo>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<XPathStepInfo>>>>::__construct_node<std::pair<std::string const,std::vector<XPathStepInfo>>>((uint64_t)a1, a3, v9);
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__insert_node_at(a1, v10, v7, v9[0]);
    v6 = v9[0];
    v9[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::vector<XPathStepInfo>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::vector<XPathStepInfo>>,void *>>>>::reset[abi:ne180100]((uint64_t)v9, 0);
  }
  return v6;
}

std::string *std::__tree<std::__value_type<std::string,std::vector<XPathStepInfo>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<XPathStepInfo>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<XPathStepInfo>>>>::__construct_node<std::pair<std::string const,std::vector<XPathStepInfo>>>@<X0>(uint64_t a1@<X0>, __int128 *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v5;
  char *v6;
  std::string *result;

  v5 = a1 + 8;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v6 = (char *)operator new(0x50uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  result = std::pair<std::string const,std::vector<XPathStepInfo>>::pair[abi:ne180100]((std::string *)(v6 + 32), a2);
  *((_BYTE *)a3 + 16) = 1;
  return result;
}

void sub_187E51E48(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::vector<XPathStepInfo>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::vector<XPathStepInfo>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

uint64_t VerifySetOptions(unsigned int a1, const char *a2)
{
  unsigned int v2;
  uint64_t v3;
  _QWORD *exception;
  const char *v6;

  if ((a1 & 0xDFFFE0FD) != 0)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 103;
    v6 = "Unrecognized option flags";
    goto LABEL_13;
  }
  v2 = (((a1 >> 1) & 0x800 | a1) >> 1) & 0x400 | (a1 >> 1) & 0x800 | a1;
  v3 = (v2 >> 1) & 0x200 | v2;
  if ((a1 & 0x100) != 0 && (v3 & 0x200) != 0)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 103;
    v6 = "IsStruct and IsArray options are mutually exclusive";
    goto LABEL_13;
  }
  if ((a1 & 2) != 0 && (v3 & 0x1F00) != 0)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 103;
    v6 = "Structs and arrays can't have \"value\" options";
    goto LABEL_13;
  }
  if (a2 && (v3 & 0x1F00) != 0)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 103;
    v6 = "Structs and arrays can't have string values";
LABEL_13:
    exception[1] = v6;
    *((_BYTE *)exception + 16) = 0;
  }
  return v3;
}

uint64_t XMPIterator::Next(XMPIterator *this, const char **a2, unsigned int *a3, const char **a4, unsigned int *a5, const char **a6, unsigned int *a7, unsigned int *a8)
{
  IterInfo *v16;
  uint64_t result;
  uint64_t v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  uint64_t v27;

  if (*((_QWORD *)this + 33) == *((_QWORD *)this + 34))
    return 0;
  v16 = (XMPIterator *)((char *)this + 224);
  result = (uint64_t)GetNextXMPNode((XMPIterator *)((char *)this + 224));
  if (result)
  {
    v18 = result;
    if ((*((_BYTE *)v16 + 1) & 2) != 0)
    {
      while (1)
      {
        v21 = *((_QWORD *)this + 33);
        if ((*(_DWORD *)v21 & 0x80000000) == 0 && *(_QWORD *)(v18 + 72) == *(_QWORD *)(v18 + 80))
          break;
        *(_BYTE *)(v21 + 88) = 2;
        result = (uint64_t)GetNextXMPNode(v16);
        v18 = result;
        if (!result)
          return result;
      }
    }
    v19 = (char *)this + 240;
    if (*((char *)this + 263) < 0)
      v19 = *(const char **)v19;
    *a2 = v19;
    if (*((char *)this + 263) < 0)
      v20 = *((_QWORD *)this + 31);
    else
      LODWORD(v20) = *((unsigned __int8 *)this + 263);
    *a3 = v20;
    *a8 = **((_DWORD **)this + 33);
    *a4 = "";
    *a5 = 0;
    *a6 = "";
    *a7 = 0;
    if ((*a8 & 0x80000000) == 0)
    {
      v22 = *((_QWORD *)this + 33);
      v23 = (const char *)(v22 + 8);
      if (*(char *)(v22 + 31) < 0)
        v23 = *(const char **)v23;
      *a4 = v23;
      v24 = *((_QWORD *)this + 33);
      if (*(char *)(v24 + 31) < 0)
        v25 = *(_QWORD *)(v24 + 16);
      else
        LODWORD(v25) = *(unsigned __int8 *)(v24 + 31);
      *a5 = v25;
      if ((*((_BYTE *)v16 + 1) & 4) != 0)
      {
        *a4 = &v23[*(_QWORD *)(v24 + 32)];
        *a5 = v25 - *(_DWORD *)(*((_QWORD *)this + 33) + 32);
        XMP_Node::GetLocalURI((XMP_Node *)v18, a2, a3);
      }
      if ((*((_BYTE *)a8 + 1) & 0x1F) == 0)
      {
        v26 = (const char *)(v18 + 40);
        if (*(char *)(v18 + 63) < 0)
          v26 = *(const char **)v26;
        *a6 = v26;
        if (*(char *)(v18 + 63) < 0)
          v27 = *(_QWORD *)(v18 + 48);
        else
          LODWORD(v27) = *(unsigned __int8 *)(v18 + 63);
        *a7 = v27;
      }
    }
    return 1;
  }
  return result;
}

const XMP_Node *GetNextXMPNode(IterInfo *a1)
{
  int *v2;
  int v3;
  char *v4;
  _BYTE *v5;
  const XMP_Node *Node;
  uint64_t v7;
  char *v8;
  uint64_t SchemaNode;
  uint64_t v10;
  uint64_t v11;
  void **v12;
  const void **v14[3];
  const void ***v15;

  v2 = (int *)*((_QWORD *)a1 + 5);
  if (*((_BYTE *)v2 + 88))
  {
    AdvanceIterPos(a1);
    v2 = (int *)*((_QWORD *)a1 + 5);
  }
  memset(v14, 0, sizeof(v14));
  if (v2 == *((int **)a1 + 6))
    goto LABEL_25;
  while (1)
  {
    v3 = *v2;
    if (*v2 < 0)
    {
      std::string::operator=((std::string *)((char *)a1 + 16), (const std::string *)(v2 + 2));
      v7 = *((_QWORD *)a1 + 5);
      v8 = (char *)(v7 + 8);
      if (*(char *)(v7 + 31) < 0)
        v8 = *(char **)v8;
      SchemaNode = FindSchemaNode((char **)(*((_QWORD *)a1 + 1) + 224), v8, 0, 0, 0, 0);
      Node = (const XMP_Node *)(SchemaNode ? SchemaNode : sDummySchema);
    }
    else
    {
      if (*((char *)a1 + 39) >= 0)
        v4 = (char *)a1 + 16;
      else
        v4 = (char *)*((_QWORD *)a1 + 2);
      v5 = v2 + 2;
      if (*((char *)v2 + 31) < 0)
        v5 = *(_BYTE **)v5;
      ExpandXPath(v4, v5, (uint64_t *)v14);
      Node = (const XMP_Node *)FindNode((char **)(*((_QWORD *)a1 + 1) + 224), v14, 0, 0, 0);
    }
    v10 = *((_QWORD *)a1 + 5);
    if (Node)
      break;
    v12 = *(void ***)(v10 + 40);
    v11 = v10 + 40;
    *(_BYTE *)(v11 + 48) = 3;
    std::vector<IterNode>::__base_destruct_at_end[abi:ne180100](v11, v12);
    std::vector<IterNode>::__base_destruct_at_end[abi:ne180100](*((_QWORD *)a1 + 5) + 64, *(void ***)(*((_QWORD *)a1 + 5) + 64));
    AdvanceIterPos(a1);
    v2 = (int *)*((_QWORD *)a1 + 5);
    if (v2 == *((int **)a1 + 6))
      goto LABEL_25;
  }
  if (v10 == *((_QWORD *)a1 + 6))
  {
LABEL_25:
    Node = 0;
  }
  else
  {
    if (*(_BYTE *)(v10 + 88))
      __assert_rtn("GetNextXMPNode", "XMPIterator.cpp", 312, "info.currPos->visitStage == kIter_BeforeVisit");
    if ((v3 & 0x80000000) == 0 && (*((_BYTE *)a1 + 1) & 1) == 0)
    {
      AddNodeOffspring(a1, *((IterNode **)a1 + 5), Node);
      v10 = *((_QWORD *)a1 + 5);
    }
    *(_BYTE *)(v10 + 88) = 1;
  }
  v15 = v14;
  std::vector<XPathStepInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&v15);
  return Node;
}

void sub_187E522E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<XPathStepInfo>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

void AddNodeOffspring(IterInfo *a1, IterNode *a2, const XMP_Node *a3)
{
  int v6;
  std::string::size_type v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  const std::string::value_type *v13;
  std::string::size_type v14;
  unint64_t v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  const std::string::value_type *v26;
  std::string::size_type v27;
  unint64_t v28;
  __int128 v29;
  uint64_t v30;
  _DWORD *exception;
  std::string v32;
  void **v33;
  void *__p[4];
  std::string::size_type v35;
  __int128 v36;
  _QWORD v37[4];
  char v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  memset(&v32, 0, sizeof(v32));
  v6 = *((char *)a2 + 31);
  if (v6 < 0)
  {
    std::string::__init_copy_ctor_external(&v32, *((const std::string::value_type **)a2 + 1), *((_QWORD *)a2 + 2));
    v6 = *((char *)a2 + 31);
    if (v6 < 0)
    {
      v7 = *((_QWORD *)a2 + 2);
      goto LABEL_5;
    }
  }
  else
  {
    v32 = *(std::string *)((char *)a2 + 8);
  }
  v7 = v6;
LABEL_5:
  if (*((_QWORD *)a3 + 12) != *((_QWORD *)a3 + 13) && (*((_BYTE *)a1 + 1) & 0x10) == 0)
  {
    std::string::append(&v32, "/?");
    v8 = *((_QWORD *)a3 + 13) - *((_QWORD *)a3 + 12);
    if (v8)
    {
      v9 = 0;
      v10 = v8 >> 3;
      do
      {
        v11 = *(_QWORD *)(*((_QWORD *)a3 + 12) + 8 * v9);
        v12 = *(char *)(v11 + 39);
        if (v12 >= 0)
          v13 = (const std::string::value_type *)(v11 + 16);
        else
          v13 = *(const std::string::value_type **)(v11 + 16);
        if (v12 >= 0)
          v14 = *(unsigned __int8 *)(v11 + 39);
        else
          v14 = *(_QWORD *)(v11 + 24);
        std::string::append(&v32, v13, v14);
        LODWORD(__p[0]) = *(_DWORD *)(v11 + 8);
        if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0)
          std::string::__init_copy_ctor_external((std::string *)&__p[1], v32.__r_.__value_.__l.__data_, v32.__r_.__value_.__l.__size_);
        else
          *(std::string *)&__p[1] = v32;
        v35 = v7 + 2;
        v36 = 0u;
        memset(v37, 0, sizeof(v37));
        v38 = 0;
        v15 = *((_QWORD *)a2 + 9);
        if (v15 >= *((_QWORD *)a2 + 10))
        {
          v17 = std::vector<IterNode>::__push_back_slow_path<IterNode>((uint64_t *)a2 + 8, (uint64_t)__p);
        }
        else
        {
          *(_DWORD *)v15 = __p[0];
          v16 = *(_OWORD *)&__p[1];
          *(void **)(v15 + 24) = __p[3];
          *(_OWORD *)(v15 + 8) = v16;
          memset(&__p[1], 0, 24);
          *(_QWORD *)(v15 + 32) = v35;
          *(_QWORD *)(v15 + 40) = 0;
          *(_QWORD *)(v15 + 48) = 0;
          *(_QWORD *)(v15 + 56) = 0;
          *(_OWORD *)(v15 + 40) = v36;
          v36 = 0uLL;
          *(_QWORD *)(v15 + 56) = v37[0];
          *(_QWORD *)(v15 + 64) = 0;
          v37[0] = 0;
          *(_QWORD *)(v15 + 72) = 0;
          *(_QWORD *)(v15 + 80) = 0;
          *(_OWORD *)(v15 + 64) = *(_OWORD *)&v37[1];
          *(_QWORD *)(v15 + 80) = v37[3];
          memset(&v37[1], 0, 24);
          *(_BYTE *)(v15 + 88) = v38;
          v17 = v15 + 96;
        }
        *((_QWORD *)a2 + 9) = v17;
        v33 = (void **)&v37[1];
        std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100](&v33);
        v33 = (void **)&v36;
        std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100](&v33);
        if (SHIBYTE(__p[3]) < 0)
          operator delete(__p[1]);
        std::string::erase(&v32, v7 + 2, 0xFFFFFFFFFFFFFFFFLL);
        ++v9;
      }
      while (v10 != v9);
    }
    std::string::erase(&v32, v7, 0xFFFFFFFFFFFFFFFFLL);
  }
  v19 = *((_QWORD *)a3 + 9);
  v18 = *((_QWORD *)a3 + 10);
  if (v19 != v18)
  {
    v20 = *((_DWORD *)a3 + 2);
    if ((v20 & 0x1F00) == 0)
    {
      exception = __cxa_allocate_exception(4uLL);
      *exception = -1;
      __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
    }
    if ((v20 & 0x100) != 0)
    {
      std::string::push_back(&v32, 47);
      ++v7;
      v19 = *((_QWORD *)a3 + 9);
      v18 = *((_QWORD *)a3 + 10);
    }
    v21 = v18 - v19;
    if (v21)
    {
      v22 = 0;
      v23 = v21 >> 3;
      do
      {
        v24 = *(_QWORD *)(*((_QWORD *)a3 + 9) + 8 * v22);
        if ((*((_BYTE *)a3 + 9) & 2) != 0)
        {
          memset(__p, 0, sizeof(__p));
          snprintf((char *)__p, 0x20uLL, "[%lu]", v22 + 1);
          std::string::append(&v32, (const std::string::value_type *)__p);
        }
        else
        {
          v25 = *(char *)(v24 + 39);
          if (v25 >= 0)
            v26 = (const std::string::value_type *)(v24 + 16);
          else
            v26 = *(const std::string::value_type **)(v24 + 16);
          if (v25 >= 0)
            v27 = *(unsigned __int8 *)(v24 + 39);
          else
            v27 = *(_QWORD *)(v24 + 24);
          std::string::append(&v32, v26, v27);
        }
        LODWORD(__p[0]) = *(_DWORD *)(v24 + 8);
        if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0)
          std::string::__init_copy_ctor_external((std::string *)&__p[1], v32.__r_.__value_.__l.__data_, v32.__r_.__value_.__l.__size_);
        else
          *(std::string *)&__p[1] = v32;
        v35 = v7;
        v36 = 0u;
        memset(v37, 0, sizeof(v37));
        v38 = 0;
        v28 = *((_QWORD *)a2 + 6);
        if (v28 >= *((_QWORD *)a2 + 7))
        {
          v30 = std::vector<IterNode>::__push_back_slow_path<IterNode>((uint64_t *)a2 + 5, (uint64_t)__p);
        }
        else
        {
          *(_DWORD *)v28 = __p[0];
          v29 = *(_OWORD *)&__p[1];
          *(void **)(v28 + 24) = __p[3];
          *(_OWORD *)(v28 + 8) = v29;
          memset(&__p[1], 0, 24);
          *(_QWORD *)(v28 + 32) = v35;
          *(_QWORD *)(v28 + 40) = 0;
          *(_QWORD *)(v28 + 48) = 0;
          *(_QWORD *)(v28 + 56) = 0;
          *(_OWORD *)(v28 + 40) = v36;
          v36 = 0uLL;
          *(_QWORD *)(v28 + 56) = v37[0];
          *(_QWORD *)(v28 + 64) = 0;
          v37[0] = 0;
          *(_QWORD *)(v28 + 72) = 0;
          *(_QWORD *)(v28 + 80) = 0;
          *(_OWORD *)(v28 + 64) = *(_OWORD *)&v37[1];
          *(_QWORD *)(v28 + 80) = v37[3];
          memset(&v37[1], 0, 24);
          *(_BYTE *)(v28 + 88) = v38;
          v30 = v28 + 96;
        }
        *((_QWORD *)a2 + 6) = v30;
        v33 = (void **)&v37[1];
        std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100](&v33);
        v33 = (void **)&v36;
        std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100](&v33);
        if (SHIBYTE(__p[3]) < 0)
          operator delete(__p[1]);
        std::string::erase(&v32, v7, 0xFFFFFFFFFFFFFFFFLL);
        ++v22;
      }
      while (v23 != v22);
    }
  }
  if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v32.__r_.__value_.__l.__data_);
}

void sub_187E52774(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18)
{
  _Unwind_Resume(exception_object);
}

void XMP_Node::GetLocalURI(XMP_Node *this, const char **a2, unsigned int *a3)
{
  const std::string *v5;
  std::string::size_type v6;
  std::string *v7;
  uint64_t v8;
  char v9;
  std::string v10;

  if (a2)
    *a2 = "";
  if (a3)
    *a3 = 0;
  if (*((char *)this + 39) < 0)
  {
    if (!*((_QWORD *)this + 3))
      return;
  }
  else if (!*((_BYTE *)this + 39))
  {
    return;
  }
  v5 = (const std::string *)((char *)this + 16);
  if ((*((_DWORD *)this + 2) & 0x80000000) != 0)
  {
    if (a2)
    {
      if ((*((_BYTE *)this + 39) & 0x80) != 0)
        v5 = (const std::string *)v5->__r_.__value_.__r.__words[0];
      *a2 = (const char *)v5;
    }
    if (a3)
    {
      if (*((char *)this + 39) < 0)
        v8 = *((_QWORD *)this + 3);
      else
        LODWORD(v8) = *((unsigned __int8 *)this + 39);
      *a3 = v8;
    }
  }
  else
  {
    v6 = std::string::find((const std::string *)((char *)this + 16), 58, 0);
    if (v6 != -1)
    {
      memset(&v10, 0, sizeof(v10));
      std::string::basic_string(&v10, v5, 0, v6, (std::allocator<char> *)&v9);
      if ((v10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v7 = &v10;
      else
        v7 = (std::string *)v10.__r_.__value_.__r.__words[0];
      XMP_NamespaceTable::GetURI((XMP_NamespaceTable *)sRegisteredNamespaces, (char *)v7, a2, a3);
      if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v10.__r_.__value_.__l.__data_);
    }
  }
}

void sub_187E528D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void VerifyQualName(char *a1, char *a2)
{
  uint64_t v4;
  _QWORD *exception;
  const char *v6;
  size_t v7;
  char *v8;
  _QWORD *v9;
  void *__p[2];
  uint64_t v11;

  if (a1 >= a2)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 102;
    v6 = "Empty qualified name";
LABEL_6:
    exception[1] = v6;
    *((_BYTE *)exception + 16) = 0;
  }
  v4 = 0;
  while (a1[v4] != 58)
  {
    if (a2 - a1 == ++v4)
      goto LABEL_5;
  }
  if (!v4)
  {
LABEL_5:
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 102;
    v6 = "Ill-formed qualified name";
    goto LABEL_6;
  }
  VerifySimpleXMLName(a1, &a1[v4]);
  v7 = v4 + 1;
  VerifySimpleXMLName(&a1[v7], a2);
  __p[0] = 0;
  __p[1] = 0;
  v11 = 0;
  std::string::basic_string[abi:ne180100](__p, a1, v7);
  if (v11 >= 0)
    v8 = (char *)__p;
  else
    v8 = (char *)__p[0];
  if (!XMP_NamespaceTable::GetURI((XMP_NamespaceTable *)sRegisteredNamespaces, v8, 0, 0))
  {
    v9 = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)v9 = 102;
    v9[1] = "Unknown namespace prefix for qualified name";
    *((_BYTE *)v9 + 16) = 0;
  }
  if (SHIBYTE(v11) < 0)
    operator delete(__p[0]);
}

void sub_187E52A40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void XMP_ReadWriteLock::Acquire()
{
  __assert_rtn("Acquire", "XMP_LibUtils.cpp", 92, "! this->beingWritten");
}

{
  __assert_rtn("Acquire", "XMP_LibUtils.cpp", 88, "this->lockCount == 0");
}

uint64_t XMPUtils::Terminate(XMPUtils *this)
{
  uint64_t v1;
  uint64_t result;

  v1 = XMPUtils::WhiteSpaceStrPtr;
  if (XMPUtils::WhiteSpaceStrPtr)
  {
    if (*(char *)(XMPUtils::WhiteSpaceStrPtr + 23) < 0)
      operator delete(*(void **)XMPUtils::WhiteSpaceStrPtr);
    result = MEMORY[0x18D761C30](v1, 0x1012C40EC159624);
  }
  XMPUtils::WhiteSpaceStrPtr = 0;
  return result;
}

uint64_t AdobeXMPCore_Int::ManageCoreObjectFactory(AdobeXMPCore_Int *this)
{
  unsigned __int8 v1;

  if ((v1 & 1) == 0
  {
    AdobeXMPCore_Int::ManageCoreObjectFactory(BOOL)::coreObjectFactoryImplObj = (uint64_t)&off_1E1BB9DE8;
  }
  return (uint64_t)&AdobeXMPCore_Int::ManageCoreObjectFactory(BOOL)::coreObjectFactoryImplObj
       + *(_QWORD *)(AdobeXMPCore_Int::ManageCoreObjectFactory(BOOL)::coreObjectFactoryImplObj - 216);
}

uint64_t AdobeXMPCore_Int::InitializeXMPCommonFramework(AdobeXMPCore_Int *this)
{
  return AdobeXMPCore_Int::IMemoryAllocator_I::SetMemoryAllocator(0);
}

void AdobeXMPCore_Int::INameSpacePrefixMap_I::DestroyDefaultNameSapcePrefixMap(AdobeXMPCore_Int::INameSpacePrefixMap_I *this)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;
  uint64_t v4;
  std::__shared_weak_count *v5;

  AdobeXMPCore_Int::ManageDefaultNameSpacePrefixMap((AdobeXMPCore_Int *)1, &v4);
  v1 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void XMP_NamespaceTable::~XMP_NamespaceTable(XMP_NamespaceTable *this)
{
  XMP_NamespaceTable::~XMP_NamespaceTable(this);
  JUMPOUT(0x18D761C30);
}

{
  *(_QWORD *)this = &off_1E1BB1880;
  std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy((uint64_t)this + 240, *((_QWORD **)this + 31));
  std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy((uint64_t)this + 216, *((_QWORD **)this + 28));
  XMP_ReadWriteLock::~XMP_ReadWriteLock((XMP_NamespaceTable *)((char *)this + 8));
}

double _CGImageMetadataFinalize(char *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  double result;

  if (a1 && (char *)*MEMORY[0x1E0C9B0D0] != a1)
  {
    v2 = (const void *)*((_QWORD *)a1 + 3);
    if (v2)
      CFRelease(v2);
    v3 = (const void *)*((_QWORD *)a1 + 6);
    if (v3)
      CFRelease(v3);
    v4 = (const void *)*((_QWORD *)a1 + 4);
    if (v4)
      CFRelease(v4);
    v5 = (const void *)*((_QWORD *)a1 + 5);
    if (v5)
      CFRelease(v5);
    v6 = (const void *)*((_QWORD *)a1 + 7);
    if (v6)
      CFRelease(v6);
    v7 = (const void *)*((_QWORD *)a1 + 8);
    if (v7)
      CFRelease(v7);
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 72));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 136));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 208));
    result = 0.0;
    *((_OWORD *)a1 + 1) = 0u;
    *((_OWORD *)a1 + 2) = 0u;
    *((_OWORD *)a1 + 3) = 0u;
    *((_OWORD *)a1 + 4) = 0u;
    *((_OWORD *)a1 + 5) = 0u;
    *((_OWORD *)a1 + 6) = 0u;
    *((_OWORD *)a1 + 7) = 0u;
    *((_OWORD *)a1 + 8) = 0u;
    *((_OWORD *)a1 + 9) = 0u;
    *((_OWORD *)a1 + 10) = 0u;
    *((_OWORD *)a1 + 11) = 0u;
    *((_OWORD *)a1 + 12) = 0u;
    *((_OWORD *)a1 + 13) = 0u;
    *((_OWORD *)a1 + 14) = 0u;
    *((_OWORD *)a1 + 15) = 0u;
    *((_OWORD *)a1 + 16) = 0u;
  }
  return result;
}

uint64_t EndElementHandler(uint64_t result, const char *a2)
{
  --*(_QWORD *)(result + 264);
  *(_QWORD *)(result + 168) -= 8;
  return result;
}

uint64_t ___ZN13IIOReadPlugin16cacheImmediatelyEPK14__CFDictionaryP7CGImage_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 32);
  CGImageGetImageProvider();
  *(_BYTE *)(v2 + 411) = 1;
  result = CGImageProviderCopyImageBlockSetWithOptions();
  if (result)
  {
    *(_BYTE *)(v2 + 411) = -1;
    return CGImageBlockSetRelease();
  }
  if (*(_QWORD *)(a1 + 96))
  {
    result = CGImageProviderCopyImageBlockSetWithOptions();
    *(_BYTE *)(v2 + 411) = -1;
    if (result)
      return CGImageBlockSetRelease();
  }
  else
  {
    *(_BYTE *)(v2 + 411) = -1;
  }
  return result;
}

uint64_t IIOImageProviderInfo::CopyImageTextureData(uint64_t *a1, const void *a2, const __CFDictionary *a3)
{
  uint64_t v6;
  uint64_t v7;

  kdebug_trace();
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CopyImageTextureData", a2, 0, -1, a3);
  if (a1)
  {
    v7 = IIOImageProviderInfo::copyImageTextureData(*a1, v6, a3);
    if (v7)
    {
      CGImageTextureDataGetSize();
      CGImageTextureDataIsCompressed();
      CGImageTextureDataSupportsTiledLayout();
      CGImageTextureDataGetNumberOfMipmaps();
      CGImageTextureDataGetNumberOfFaces();
      CGImageTextureDataGetPixelFormat();
      CGImageTextureDataGetPixelFormat();
    }
  }
  else
  {
    v7 = 0;
  }
  kdebug_trace();
  return v7;
}

uint64_t IIOImageProviderInfo::copyImageTextureData(uint64_t a1, uint64_t a2, const __CFDictionary *a3)
{
  CFTypeRef *v5;
  const __CFDictionary *v6;
  CFTypeID v7;
  const void *v8;
  const void *Value;
  IIOImageRead *v10;
  const char *v11;
  _BOOL4 v12;
  uint64_t v13;

  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "copyImageTextureData", 0, 0, -1, a3);
  IIOInitDebugFlags();
  if ((gIIODebugFlags & 0xC) != 0)
    *(CFAbsoluteTime *)(a1 + 136) = CFAbsoluteTimeGetCurrent();
  if (*(_QWORD *)(a1 + 240))
  {
    v5 = *(CFTypeRef **)(a1 + 112);
    if (v5)
    {
      v6 = (const __CFDictionary *)*v5;
      if (*v5)
      {
        v7 = CFGetTypeID(*v5);
        if (v7 == CFDictionaryGetTypeID())
        {
          pthread_mutex_lock((pthread_mutex_t *)(a1 + 144));
          v8 = (const void *)*MEMORY[0x1E0C9AE50];
          if (v8 == CFDictionaryGetValue(v6, CFSTR("kImageIOInfoHeader_pluginHandlesReMapping")))
          {
            v12 = 0;
            v11 = 0;
          }
          else
          {
            Value = CFDictionaryGetValue(v6, CFSTR("kImageIOInfoHeader_session"));
            v10 = (IIOImageRead *)CGImageReadSessionGetRead((uint64_t)Value);
            v11 = (const char *)v10;
            if (v10)
              v12 = IIOImageRead::mapData(v10);
            else
              v12 = 0;
          }
          v13 = (*(uint64_t (**)(_QWORD, _QWORD, const __CFDictionary *))(a1 + 240))(*(_QWORD *)(a1 + 112), *(_QWORD *)(a1 + 16), a3);
          if (v13 && (gIIODebugFlags & 0xC) != 0)
            *(CFAbsoluteTime *)(a1 + 136) = CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 136);
          if (v12 && v11)
            IIOImageRead::unmapData(v11);
          pthread_mutex_unlock((pthread_mutex_t *)(a1 + 144));
          if (v13)
            return v13;
          goto LABEL_24;
        }
      }
    }
    else
    {
      v6 = 0;
    }
    LogFault("copyImageTextureData", 2491, "header '%p' is not a CFDictionary...\n", v6);
    return 0;
  }
  v13 = 0;
LABEL_24:
  if ((gIIODebugFlags & 0x800000000000) != 0)
  {
    ImageIOLog("∆∆∆ ISSUE: %s:%d:  %s\n", "copyImageTextureData", 2522, "returned textureData is NULL\n");
    return 0;
  }
  return v13;
}

uint64_t IIO_Reader::CopyImageTextureDataProc(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _BYTE *v6;
  uint64_t v7;

  v6 = *(_BYTE **)(a1 + 8);
  if (v6[177])
    ImageIOLog("    CopyImageTextureDataProc\n");
  (*(void (**)(_BYTE *, uint64_t))(*(_QWORD *)v6 + 72))(v6, a3);
  v7 = (*(uint64_t (**)(_BYTE *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v6 + 248))(v6, a1, a2, a3);
  (*(void (**)(_BYTE *))(*(_QWORD *)v6 + 80))(v6);
  return v7;
}

void sub_187E53138(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187E53120);
}

const void *IIOImageProviderInfo::CopyImageBlockSetWithOptions(uint64_t *a1, const void *a2, const __CFDictionary *a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  uint64_t v18;
  int v19;
  int v20;
  __int16 v21;
  const void *v22;
  const void *v23;
  CGColorSpace *ColorSpace;
  CFTypeRef cf;
  char __str[16];
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    CGImageProviderGetBitmapInfo();
    v18 = *a1;
    IIOPackCopyCallbackInfo(*a1, a3);
    if (v18)
      v19 = *(_DWORD *)(v18 + 128);
    else
      v19 = 0;
    v20 = v19;
    kdebug_trace();
    IIOInitDebugFlags();
    v21 = gIIODebugFlags;
    if ((gIIODebugFlags & 0xC000) != 0)
    {
      v30 = 0u;
      v31 = 0u;
      v28 = 0u;
      v29 = 0u;
      *(_OWORD *)__str = 0u;
      if (v18 && *(_QWORD *)(v18 + 24))
      {
        cf = (CFTypeRef)IIOLookupISR();
        v21 = gIIODebugFlags;
      }
      else
      {
        cf = 0;
      }
      if (v21 < 0)
      {
        if (v20 < 0)
          __maskrune(v20 >> 24, 0x40000uLL);
        if (v20 << 8 < 0)
          __maskrune(v20 << 8 >> 24, 0x40000uLL);
        if (v20 << 16 < 0)
          __maskrune((__int16)v20 >> 8, 0x40000uLL);
        if ((v20 << 24) > 0x7F000000)
          __maskrune((char)v20, 0x40000uLL);
        snprintf(__str, 0x50uLL, "'%c%c%c%c' src={%g,%g,%g,%g}  dest={%g,%g}");
      }
      else
      {
        if (v20 < 0)
          __maskrune(v20 >> 24, 0x40000uLL);
        if (v20 << 8 < 0)
          __maskrune(v20 << 8 >> 24, 0x40000uLL);
        if (v20 << 16 < 0)
          __maskrune((__int16)v20 >> 8, 0x40000uLL);
        if ((v20 << 24) > 0x7F000000)
          __maskrune((char)v20, 0x40000uLL);
        snprintf(__str, 0x50uLL, "%c%c%c%c");
      }
      if ((unsigned __int16)gIIODebugFlags >> 14)
        ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CopyImageBlockSetWithOptions", cf, __str, -1, a3);
    }
    if (v18)
    {
      v22 = IIOImageProviderInfo::copyImageBlockSetWithOptions(v18, a2, a3, a4, a5, a6, a7, a8, a9);
      if (v22)
      {
        v23 = v22;
        CGImageBlockSetGetRect();
        goto LABEL_45;
      }
      _cg_jpeg_mem_term("CopyImageBlockSetWithOptions", 2599, "*** ERROR: CopyImageBlockSetWithOptions returned NULL\n");
    }
  }
  else
  {
    kdebug_trace();
  }
  if (a2)
  {
    CGImageProviderGetBitmapInfo();
    CGImageProviderGetComponentType();
    ColorSpace = (CGColorSpace *)CGImageProviderGetColorSpace();
    CGColorSpaceGetModel(ColorSpace);
  }
  kdebug_trace();
  v23 = 0;
LABEL_45:
  kdebug_trace();
  return v23;
}

const void *IIOImageProviderInfo::copyImageBlockSetWithOptions(uint64_t a1, const void *a2, CFDictionaryRef theDict, double a4, double a5, double a6, double a7, double a8, double a9)
{
  uint64_t v16;
  char v17;
  const void *v19;
  CFTypeRef *v20;
  const __CFDictionary *v21;
  CFTypeID v22;
  const void *v23;
  const void *Value;
  IIOImageRead *v25;
  const char *v26;
  _BOOL4 v27;
  uint64_t v28;
  uint64_t v31;
  const __CFDictionary *v32;
  __CFDictionary *MutableCopy;
  double v34;
  double v35;
  uint64_t Count;
  int v37;
  uint64_t v38;
  IIOImageRead *v39;
  uint64_t v40;
  int v41;

  v16 = a1;
  v17 = gIIODebugFlags;
  if ((gIIODebugFlags & 0x400000000000) != 0)
  {
    ImageIOLog("\n");
    LODWORD(a1) = ImageIOLog("*** copyImageBlockSetWithOptions *** %p {%g, %g, %g, %g} {%g, %g}\n", a2, a4, a5, a6, a7, a8, a9);
    v17 = gIIODebugFlags;
  }
  if ((v17 & 0xC) != 0)
    *(CFAbsoluteTime *)(v16 + 136) = CFAbsoluteTimeGetCurrent();
  v19 = 0;
  if (a8 != 0.0 && a9 != 0.0)
  {
    if (!*(_QWORD *)(v16 + 216))
    {
      v19 = 0;
      goto LABEL_17;
    }
    v20 = *(CFTypeRef **)(v16 + 112);
    if (!v20
      || (v21 = (const __CFDictionary *)*v20) == 0
      || (v22 = CFGetTypeID(*v20), v22 != CFDictionaryGetTypeID()))
    {
      LogError("copyImageBlockSetWithOptions", 2224, "*** ERROR: 'ImageProviderCopyImageBlockSetCallback' header is not a CFDictionary...\n");
      return 0;
    }
    pthread_mutex_lock((pthread_mutex_t *)(v16 + 144));
    v23 = (const void *)*MEMORY[0x1E0C9AE50];
    if (v23 == CFDictionaryGetValue(v21, CFSTR("kImageIOInfoHeader_pluginHandlesReMapping"))
      || (Value = CFDictionaryGetValue(v21, CFSTR("kImageIOInfoHeader_session"))) == 0)
    {
      v26 = 0;
    }
    else
    {
      v25 = (IIOImageRead *)CGImageReadSessionGetRead((uint64_t)Value);
      v26 = (const char *)v25;
      if (v25)
      {
        v27 = IIOImageRead::mapData(v25);
        goto LABEL_31;
      }
    }
    v27 = 0;
LABEL_31:
    v31 = *(_QWORD *)(v16 + 24);
    if (v31)
    {
      v32 = 0;
      if (!theDict || !*(_BYTE *)(v31 + 180))
        goto LABEL_38;
      if (CFDictionaryContainsValue(theDict, (const void *)*MEMORY[0x1E0C9DAA8]))
      {
        MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, theDict);
        v32 = MutableCopy;
        if (MutableCopy)
        {
          CFDictionaryRemoveValue(MutableCopy, (const void *)*MEMORY[0x1E0C9DAB0]);
          theDict = v32;
        }
LABEL_38:
        v19 = (const void *)(*(uint64_t (**)(_QWORD, _QWORD, CFDictionaryRef, double, double, double, double, double, double))(v16 + 216))(*(_QWORD *)(v16 + 112), *(_QWORD *)(v16 + 16), theDict, a4, a5, a6, a7, a8, a9);
        if (!v19)
          goto LABEL_49;
        CGImageBlockSetGetRect();
        v35 = v34;
        Count = CGImageBlockSetGetCount();
        if (!Count || v35 == 0.0)
        {
          CFRelease(v19);
        }
        else
        {
          v37 = Count;
          if (CGImageBlockSetGetImageBlock())
          {
            v38 = *(_QWORD *)(v16 + 24);
            if (v38)
            {
              v39 = (IIOImageRead *)CGImageReadSessionGetRead(*(_QWORD *)(v38 + 24));
              if (v39)
              {
                if (IIOImageRead::isFinal(v39))
                {
                  v40 = *(_QWORD *)(v16 + 24);
                  v41 = *(_DWORD *)(v40 + 136);
                  if (v41 != -6)
                  {
                    if (v41)
                      *(_DWORD *)(v40 + 136) = 0;
                  }
                }
              }
            }
            IIOImageProviderInfo::checkBlockSetBuffer(v16);
LABEL_49:
            if (v26 && v27)
              IIOImageRead::unmapData(v26);
            LODWORD(a1) = pthread_mutex_unlock((pthread_mutex_t *)(v16 + 144));
            if (!v32)
              goto LABEL_17;
LABEL_57:
            CFRelease(v32);
            goto LABEL_17;
          }
          _cg_jpeg_mem_term("copyImageBlockSetWithOptions", 2294, "*** CGImageBlockSetGetImageBlock returned NULL for index %d (count is %d)\n", 0, v37);
          IIO_ImageBlockSetRelease(v19);
          LODWORD(a1) = pthread_mutex_unlock((pthread_mutex_t *)(v16 + 144));
        }
        v19 = 0;
        if (!v32)
          goto LABEL_17;
        goto LABEL_57;
      }
    }
    v32 = 0;
    goto LABEL_38;
  }
LABEL_17:
  v28 = gIIODebugFlags;
  if ((gIIODebugFlags & 0xC) != 0)
  {
    *(CFAbsoluteTime *)(v16 + 136) = CFAbsoluteTimeGetCurrent() - *(double *)(v16 + 136);
    IIOImageProviderInfo::logBlockSetDecodingTime(v16, (uint64_t)v19, a4, a5, a6, a7, a8, a9);
    v28 = gIIODebugFlags;
  }
  if ((v28 & 0xC000) == 0x8000 || (v28 & 0x400000000000) != 0)
  {
    IIOImageProviderInfo::debugCallbackOptionsResult(a1, theDict, (uint64_t)v19);
    v28 = gIIODebugFlags;
  }
  if (!v19 && (v28 & 0x800000000000) != 0)
  {
    ImageIOLog("∆∆∆ ISSUE: %s:%d:  %s\n", "copyImageBlockSetWithOptions", 2333, "returned blockSet is NULL\n");
    return 0;
  }
  return v19;
}

uint64_t IIO_Reader::CopyImageBlockSetProc(uint64_t a1, uint64_t a2, const void *a3, CGFloat a4, CGFloat a5, double a6, double a7, double a8, double a9)
{
  _DWORD *v18;
  __n128 v19;
  unint64_t v20;
  double v21;
  unint64_t v22;
  unint64_t v23;
  double v24;
  double v25;
  double x;
  double y;
  double width;
  double height;
  int v30;
  unsigned int v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  unsigned int v35;
  int v36;
  uint64_t v37;
  unsigned int v38;
  int v39;
  uint64_t v40;
  int v41;
  unsigned int v42;
  int v43;
  int v44;
  const char *v45;
  int v46;
  unsigned int v47;
  int v48;
  uint64_t v49;
  unsigned int v50;
  int v51;
  uint64_t v52;
  unsigned int v53;
  int v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  int v58;
  unsigned int v59;
  int v60;
  uint64_t v61;
  unsigned int v62;
  int v63;
  uint64_t v64;
  unsigned int v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  _DWORD *exception;
  _OWORD v71[5];
  uint64_t v72;
  _OWORD v73[2];
  uint64_t ImageBlockSetFromCache;
  CGRect v75;
  CGRect v76;

  ImageBlockSetFromCache = 0;
  if ((IIO_XPCServer() & 1) == 0)
  {
    v18 = *(_DWORD **)(a1 + 8);
    if ((*(unsigned int (**)(_DWORD *, const void *))(*(_QWORD *)v18 + 72))(v18, a3))
    {
      exception = __cxa_allocate_exception(4uLL);
      *exception = -1;
      __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
    }
    if (*((_BYTE *)v18 + 177))
      ImageIOLog("    CopyImageBlockSetProc: rect:{%g,%g,%g,%g}  size:{%g,%g}\n", a4, a5, a6, a7, a8, a9);
    memset(v73, 0, sizeof(v73));
    v19 = IIOReadPlugin::inputGeometry((IIOReadPlugin *)v18, (uint64_t)v73);
    LODWORD(v20) = DWORD1(v73[0]);
    v19.n128_u32[0] = v73[0];
    v19.n128_f64[0] = (double)v19.n128_u64[0];
    v21 = (double)v20;
    LODWORD(v23) = HIDWORD(v73[0]);
    LODWORD(v22) = DWORD2(v73[0]);
    v24 = (double)v22;
    v25 = (double)v23;
    v76.size.width = fmax(a6, 1.0);
    v76.size.height = fmax(a7, 1.0);
    v76.origin.x = a4;
    v76.origin.y = a5;
    v75 = CGRectIntersection(*(CGRect *)v19.n128_u64, v76);
    x = v75.origin.x;
    y = v75.origin.y;
    width = v75.size.width;
    height = v75.size.height;
    if ((gIIODebugFlags & 0x30000) == 0)
    {
LABEL_30:
      ImageBlockSetFromCache = IIOReadPlugin::createImageBlockSetFromCache((uint64_t)v18, a1, a2, x, y, width, height, a8, a9);
      if (ImageBlockSetFromCache)
      {
LABEL_91:
        (*(void (**)(_DWORD *))(*(_QWORD *)v18 + 80))(v18);
        return ImageBlockSetFromCache;
      }
      v72 = 0;
      memset(v71, 0, sizeof(v71));
      v42 = IIOReadPlugin::index((IIOReadPlugin *)v18);
      IIODecodeParameter::IIODecodeParameter((uint64_t)v71, a1, a2, v42, a3, x, y, width, height, a8, a9);
      v43 = IIOReadPlugin::callDecodeImage((uint64_t)v18, (uint64_t)v71, 3, 0, 0, &ImageBlockSetFromCache);
      if (v43 == -1400)
      {
        ImageIOLog("‼️ retrying 'decodeImage' (ImageIOXPCService crashed?)\n");
        v44 = IIOReadPlugin::callDecodeImage((uint64_t)v18, (uint64_t)v71, 3, 0, 0, &ImageBlockSetFromCache);
        v43 = v44;
        v45 = "❌";
        if (!v44)
          v45 = "✅";
        ImageIOLog("%s retrying 'decodeImage'  err: %d\n", v45, v44);
      }
      if (v43 == -181)
      {
        IIOXPCLog("❗️ request not handled [%d]\n", -181);
      }
      else if (v43)
      {
        if (v43 == -56)
        {
          v46 = v18[51];
          v47 = v46 >> 24;
          if (v46 < 0)
          {
            v48 = __maskrune(v47, 0x40000uLL);
            v46 = v18[51];
          }
          else
          {
            v48 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v47 + 60) & 0x40000;
          }
          if (v48)
            v49 = (v46 >> 24);
          else
            v49 = 46;
          v50 = v46 << 8 >> 24;
          if (v46 << 8 < 0)
          {
            v51 = __maskrune(v50, 0x40000uLL);
            v46 = v18[51];
          }
          else
          {
            v51 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v50 + 60) & 0x40000;
          }
          if (v51)
            v52 = (v46 << 8 >> 24);
          else
            v52 = 46;
          v53 = (__int16)v46 >> 8;
          if (v46 << 16 < 0)
          {
            v54 = __maskrune(v53, 0x40000uLL);
            v46 = v18[51];
          }
          else
          {
            v54 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v53 + 60) & 0x40000;
          }
          if (v54)
            v55 = ((__int16)v46 >> 8);
          else
            v55 = 46;
          if ((v46 << 24) <= 0x7F000000)
            v56 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v46 + 60) & 0x40000;
          else
            v56 = __maskrune((char)v46, 0x40000uLL);
          if (v56)
            v57 = *((char *)v18 + 204);
          else
            v57 = 46;
          LogError("CopyImageBlockSetProc", 1553, "*** IIO_Reader::CopyImageBlockSetProc - '%c%c%c%c'- does not support 'callDecodeImage'\n", v49, v52, v55, v57);
        }
        v58 = v18[51];
        v59 = v58 >> 24;
        if (v58 < 0)
        {
          v60 = __maskrune(v59, 0x40000uLL);
          v58 = v18[51];
        }
        else
        {
          v60 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v59 + 60) & 0x40000;
        }
        if (v60)
          v61 = (v58 >> 24);
        else
          v61 = 46;
        v62 = v58 << 8 >> 24;
        if (v58 << 8 < 0)
        {
          v63 = __maskrune(v62, 0x40000uLL);
          v58 = v18[51];
        }
        else
        {
          v63 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v62 + 60) & 0x40000;
        }
        if (v63)
          v64 = (v58 << 8 >> 24);
        else
          v64 = 46;
        v65 = (__int16)v58 >> 8;
        if (v58 << 16 < 0)
        {
          v66 = __maskrune(v65, 0x40000uLL);
          v58 = v18[51];
        }
        else
        {
          v66 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v65 + 60) & 0x40000;
        }
        if (v66)
          v67 = ((__int16)v58 >> 8);
        else
          v67 = 46;
        if ((v58 << 24) <= 0x7F000000)
        {
          if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v58 + 60) & 0x40000) != 0)
            goto LABEL_84;
        }
        else if (__maskrune((char)v58, 0x40000uLL))
        {
LABEL_84:
          v68 = *((char *)v18 + 204);
LABEL_87:
          _cg_jpeg_mem_term("CopyImageBlockSetProc", 1559, "*** ERROR: '%c%c%c%c' callDecodeImage failed [%d]\n", v61, v64, v67, v68, v43);
          goto LABEL_88;
        }
        v68 = 46;
        goto LABEL_87;
      }
LABEL_88:
      if (!ImageBlockSetFromCache)
        _cg_jpeg_mem_term("CopyImageBlockSetProc", 1561, "*** ERROR: callDecodeImage returned NULL blockSet [%d]\n", v43);
      IIODecodeParameter::~IIODecodeParameter((IIODecodeParameter *)v71);
      goto LABEL_91;
    }
    v30 = v18[51];
    v31 = v30 >> 24;
    v32 = MEMORY[0x1E0C80978];
    if (v30 < 0)
    {
      v33 = __maskrune(v31, 0x40000uLL);
      v30 = v18[51];
    }
    else
    {
      v33 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v31 + 60) & 0x40000;
    }
    if (v33)
      v34 = (v30 >> 24);
    else
      v34 = 46;
    v35 = v30 << 8 >> 24;
    if (v30 << 8 < 0)
    {
      v36 = __maskrune(v35, 0x40000uLL);
      v30 = v18[51];
    }
    else
    {
      v36 = *(_DWORD *)(v32 + 4 * v35 + 60) & 0x40000;
    }
    if (v36)
      v37 = (v30 << 8 >> 24);
    else
      v37 = 46;
    v38 = (__int16)v30 >> 8;
    if (v30 << 16 < 0)
    {
      v39 = __maskrune(v38, 0x40000uLL);
      v30 = v18[51];
    }
    else
    {
      v39 = *(_DWORD *)(v32 + 4 * v38 + 60) & 0x40000;
    }
    if (v39)
      v40 = ((__int16)v30 >> 8);
    else
      v40 = 46;
    if ((v30 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v32 + 4 * (char)v30 + 60) & 0x40000) != 0)
        goto LABEL_26;
    }
    else if (__maskrune((char)v30, 0x40000uLL))
    {
LABEL_26:
      v41 = v18[51];
LABEL_29:
      ImageIOLog("*** IIO_Reader::CopyImageBlockSetProc - using new '%c%c%c%c'- callDecodeImage [kIIOImageType_ImageBlockSet]\n", v34, v37, v40, (char)v41);
      goto LABEL_30;
    }
    LOBYTE(v41) = 46;
    goto LABEL_29;
  }
  return ImageBlockSetFromCache;
}

void sub_187E53F90(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  uint64_t v15;

  __cxa_begin_catch(a1);
  *(_QWORD *)(v15 - 136) = 0;
  __cxa_end_catch();
  JUMPOUT(0x187E53F3CLL);
}

double IIOReadPlugin::didDecode(IIOReadPlugin *this)
{
  double result;

  result = 0.0;
  *(_OWORD *)((char *)this + 300) = 0u;
  *(_OWORD *)((char *)this + 284) = 0u;
  return result;
}

uint64_t IIOReadPlugin::willDecode(IIOReadPlugin *this, const __CFDictionary *a2)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  int v7;
  uint64_t v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  unsigned int v25;
  BOOL v26;
  int v27;
  int v28;
  __int16 v29;
  __int16 v30;
  int v31;
  BOOL v32;
  __int16 v33;
  unint64_t v34;
  __int128 v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int v38;
  unint64_t v39;
  uint64_t v40;
  int v41;
  int v42;
  int v43;
  unsigned int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  char *v50;
  int v51;
  unsigned int v52;
  int v53;
  uint64_t v54;
  unsigned int v55;
  int v56;
  uint64_t v57;
  unsigned int v58;
  int v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  _DWORD *exception;
  int v65;
  int v66;
  unsigned int v67;

  v4 = MEMORY[0x1E0C80978];
  if (*((_BYTE *)this + 177))
  {
    v5 = *((_DWORD *)this + 51);
    v6 = v5 >> 24;
    if (v5 < 0)
      v7 = __maskrune(v5 >> 24, 0x40000uLL);
    else
      v7 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v6 + 60) & 0x40000;
    if (v7)
      v8 = v6;
    else
      v8 = 46;
    v9 = v5 << 8 >> 24;
    if (v5 << 8 < 0)
      v10 = __maskrune(v5 << 8 >> 24, 0x40000uLL);
    else
      v10 = *(_DWORD *)(v4 + 4 * v9 + 60) & 0x40000;
    if (v10)
      v11 = v9;
    else
      v11 = 46;
    v12 = (__int16)v5 >> 8;
    if (v5 << 16 < 0)
      v13 = __maskrune((__int16)v5 >> 8, 0x40000uLL);
    else
      v13 = *(_DWORD *)(v4 + 4 * v12 + 60) & 0x40000;
    if (v13)
      v14 = v12;
    else
      v14 = 46;
    if ((v5 << 24) <= 0x7F000000)
      v15 = *(_DWORD *)(v4 + 4 * (char)v5 + 60) & 0x40000;
    else
      v15 = __maskrune((char)v5, 0x40000uLL);
    if (v15)
      v16 = (char)v5;
    else
      v16 = 46;
    ImageIOLog(">>> willDecode -start- %c%c%c%c\n", v8, v11, v14, v16);
  }
  v17 = *((_DWORD *)this + 73);
  if (!v17)
  {
    v17 = *((_DWORD *)this + 65);
    *((_DWORD *)this + 73) = v17;
  }
  if (!*((_DWORD *)this + 74))
    *((_DWORD *)this + 74) = *((_DWORD *)this + 66);
  v18 = *((_DWORD *)this + 75);
  if (!v18)
  {
    v18 = *((_DWORD *)this + 67);
    *((_DWORD *)this + 75) = v18;
  }
  v19 = *((unsigned __int16 *)this + 152);
  if (!*((_WORD *)this + 152))
  {
    v19 = *((unsigned __int16 *)this + 136);
    *((_WORD *)this + 152) = v19;
  }
  v20 = *((unsigned __int16 *)this + 153);
  if (!*((_WORD *)this + 153))
  {
    v20 = *((unsigned __int16 *)this + 137);
    *((_WORD *)this + 153) = v20;
  }
  v21 = *((unsigned __int16 *)this + 154);
  if (!*((_WORD *)this + 154))
  {
    v21 = *((unsigned __int16 *)this + 138);
    *((_WORD *)this + 154) = v21;
  }
  v22 = *((unsigned __int8 *)this + 312);
  v23 = *((unsigned __int8 *)this + 310);
  if (!((*((unsigned __int8 *)this + 311) << 12) | (v22 << 16) | ((*((_BYTE *)this + 313) != 0) << 8) | v23))
  {
    v24 = *((unsigned __int8 *)this + 279);
    v25 = (v24 << 12) | (*((unsigned __int8 *)this + 280) << 16);
    v26 = *((_BYTE *)this + 281) != 0;
    v23 = *((_BYTE *)this + 278) & 0x1F;
    *((_BYTE *)this + 310) = v23;
    *((_BYTE *)this + 311) = v24 & 7;
    v22 = HIWORD(v25) & 0xF;
    *((_BYTE *)this + 312) = v22;
    *((_BYTE *)this + 313) = v26;
  }
  if (v19 >= 9)
  {
    if (v19 == 10)
    {
      if (v22 << 16 == 196608 || v22 << 16 == 0x40000)
        goto LABEL_54;
    }
    else if (v19 > 0x10)
    {
      if (v19 > 0x20)
        goto LABEL_124;
      v19 = 32;
      goto LABEL_53;
    }
    v19 = 16;
LABEL_53:
    *((_WORD *)this + 152) = v19;
    goto LABEL_54;
  }
  v19 = 8;
  *((_WORD *)this + 152) = 8;
  if (v20 == 24)
  {
    if (!v23)
    {
      v28 = 0;
      v27 = *((_DWORD *)this + 80);
      LOWORD(v20) = 24;
      goto LABEL_61;
    }
    v20 = 32;
    *((_WORD *)this + 153) = 32;
  }
LABEL_54:
  v27 = *((_DWORD *)this + 80);
  v28 = v23 != 0;
  if (!v27 && v23)
  {
    if (v21 == 1)
    {
      v21 = 2;
      *((_WORD *)this + 154) = 2;
    }
    v27 = 0;
    if (v20 == v19)
    {
      LOWORD(v20) = v21 * v20;
      *((_WORD *)this + 153) = v20;
    }
    v28 = 1;
  }
LABEL_61:
  if (v21 * v19 > (unsigned __int16)v20)
  {
    switch(v27)
    {
      case 0:
      case 5:
        if (v28)
          v29 = 2;
        else
          v29 = 1;
        *((_WORD *)this + 154) = v29;
        v20 = v19 << v28;
        goto LABEL_79;
      case 1:
        if (v23)
          v30 = 4;
        else
          v30 = 3;
        *((_WORD *)this + 154) = v30;
        v31 = v22 << 16;
        LOWORD(v20) = 32;
        if (v31 != 196608 && v31 != 0x40000)
          LOWORD(v20) = v30 * v19;
        goto LABEL_79;
      case 2:
        v32 = v23 == 0;
        v33 = 4;
        goto LABEL_76;
      case 3:
        v32 = v23 == 0;
        v33 = 3;
LABEL_76:
        if (!v32)
          ++v33;
        *((_WORD *)this + 154) = v33;
        LOWORD(v20) = v33 * v19;
LABEL_79:
        *((_WORD *)this + 153) = v20;
        break;
      default:
        break;
    }
  }
  v34 = ((unsigned __int16)v20 >> 3) * (unint64_t)v17;
  if ((v34 & 0xFFFFFFFF00000000) != 0)
  {
LABEL_124:
    exception = __cxa_allocate_exception(4uLL);
    *exception = -50;
  }
  if (v18 < v34)
    *((_DWORD *)this + 75) = v34;
  *((_QWORD *)this + 14) = 0x100000000;
  v35 = *(_OWORD *)(MEMORY[0x1E0C9D628] + 16);
  *(_OWORD *)((char *)this + 120) = *MEMORY[0x1E0C9D628];
  *((_DWORD *)this + 26) = 1;
  *(_OWORD *)((char *)this + 136) = v35;
  *((_QWORD *)this + 48) = 0;
  *((_QWORD *)this + 49) = 0;
  *(_QWORD *)((char *)this + 404) = -1;
  *((_DWORD *)this + 100) = 538976288;
  *(_WORD *)((char *)this + 413) = 256;
  v67 = (*(uint64_t (**)(IIOReadPlugin *, const __CFDictionary *))(*(_QWORD *)this + 64))(this, a2);
  if ((IIOGeometry::isValid((IIOReadPlugin *)((char *)this + 220)) & 1) == 0)
  {
    v36 = ((*((unsigned __int16 *)this + 121) + 7) >> 3) * *((_DWORD *)this + 57);
    if (v36 > *((_DWORD *)this + 59))
      *((_DWORD *)this + 59) = (v36 + 15) & 0xFFFFFFF0;
  }
  if ((IIOGeometry::isValid((IIOReadPlugin *)((char *)this + 252)) & 1) == 0)
  {
    v37 = ((*((unsigned __int16 *)this + 137) + 7) >> 3) * *((_DWORD *)this + 65);
    if (v37 > *((_DWORD *)this + 67))
      *((_DWORD *)this + 67) = (v37 + 15) & 0xFFFFFFF0;
  }
  if ((IIOGeometry::isValid((IIOReadPlugin *)((char *)this + 284)) & 1) == 0)
  {
    v38 = ((*((unsigned __int16 *)this + 153) + 7) >> 3) * *((_DWORD *)this + 73);
    if (v38 > *((_DWORD *)this + 75))
      *((_DWORD *)this + 75) = (v38 + 15) & 0xFFFFFFF0;
  }
  v39 = *((_QWORD *)this + 49);
  if (v39)
  {
    v40 = *((unsigned int *)this + 75);
    if (v40 % (uint64_t)v39)
      *((_DWORD *)this + 75) = (v39 + v40 - 1) / v39 * v39;
  }
  IIOReadPlugin::updateRequestFormat((uint64_t)this);
  ++*((_QWORD *)this + 52);
  if ((gIIODebugFlags & 0x30000) != 0)
  {
    v66 = *((unsigned __int16 *)this + 153);
    v41 = *((unsigned __int16 *)this + 152);
    v42 = *((unsigned __int16 *)this + 154);
    v43 = *((unsigned __int8 *)this + 310);
    v44 = (*((unsigned __int8 *)this + 312) << 16) | (*((unsigned __int8 *)this + 311) << 12) | ((*((_BYTE *)this + 313) != 0) << 8) | v43;
    v45 = *((_DWORD *)this + 71);
    v46 = *((_DWORD *)this + 72);
    v47 = *((_DWORD *)this + 73);
    v48 = *((_DWORD *)this + 74);
    v49 = *((_DWORD *)this + 75);
    v50 = IIO_BitmapInfoString(v44);
    v65 = v47;
    v4 = MEMORY[0x1E0C80978];
    ImageIOLog("             _blockGeo   %5d %5d %5d %5d   %6d   %3d   %3d   %3d   %3d   %08X   %s\n", v45, v46, v65, v48, v49, v66, v41, v42, v43, v44, v50);
  }
  if (*((_BYTE *)this + 177))
  {
    v51 = *((_DWORD *)this + 51);
    v52 = v51 >> 24;
    if (v51 < 0)
      v53 = __maskrune(v51 >> 24, 0x40000uLL);
    else
      v53 = *(_DWORD *)(v4 + 4 * v52 + 60) & 0x40000;
    if (v53)
      v54 = v52;
    else
      v54 = 46;
    v55 = v51 << 8 >> 24;
    if (v51 << 8 < 0)
      v56 = __maskrune(v51 << 8 >> 24, 0x40000uLL);
    else
      v56 = *(_DWORD *)(v4 + 4 * v55 + 60) & 0x40000;
    if (v56)
      v57 = v55;
    else
      v57 = 46;
    v58 = (__int16)v51 >> 8;
    if (v51 << 16 < 0)
      v59 = __maskrune((__int16)v51 >> 8, 0x40000uLL);
    else
      v59 = *(_DWORD *)(v4 + 4 * v58 + 60) & 0x40000;
    if (v59)
      v60 = v58;
    else
      v60 = 46;
    if ((v51 << 24) <= 0x7F000000)
      v61 = *(_DWORD *)(v4 + 4 * (char)v51 + 60) & 0x40000;
    else
      v61 = __maskrune((char)v51, 0x40000uLL);
    if (v61)
      v62 = (char)v51;
    else
      v62 = 46;
    ImageIOLog("<<< willDecode -result- %c%c%c%c\n", v54, v57, v60, v62);
  }
  return v67;
}

uint64_t IIOGeometry::isValid(IIOGeometry *this)
{
  int v2;
  int v3;
  uint64_t result;
  unsigned int v5;
  int v6;
  int v7;
  int v8;
  unsigned int v9;
  BOOL v10;
  int v11;

  v3 = *((_DWORD *)this + 2);
  v2 = *((_DWORD *)this + 3);
  if (v3)
  {
    if (!v2)
      goto LABEL_5;
  }
  else
  {
    if (v2)
    {
LABEL_5:
      _cg_jpeg_mem_term("isValid", 172, "🔺 bad width/height:  w: %d   h: %d\n", v3, v2);
      result = 0;
      v3 = *((_DWORD *)this + 2);
      goto LABEL_8;
    }
    v3 = 0;
  }
  result = 1;
LABEL_8:
  v5 = *((unsigned __int16 *)this + 11);
  v6 = *((_DWORD *)this + 4);
  if (v3 * v5 > 8 * v6)
  {
    _cg_jpeg_mem_term("isValid", 178, "🔺 rowBytes too small: w: %d   bpp: %d   rb: %d   min: %d\n", v3, (v5 + 7) >> 3, v6, ((v5 + 7) >> 3) * v3);
    result = 0;
    v5 = *((unsigned __int16 *)this + 11);
  }
  v7 = *((unsigned __int16 *)this + 10);
  v8 = *((unsigned __int16 *)this + 12);
  v9 = v8 * v7;
  if (v8 * v7 <= v5)
  {
    if (v9 >= v5)
      goto LABEL_26;
    v10 = v7 == 10 || v7 == 5;
    if (v10 && v8 == 3)
      goto LABEL_26;
    _cg_jpeg_mem_term("isValid", 199, "🔺 bitsPerPixel too big: bpc: %d   #channels: %d   bpp: %d   min: %d\n");
    goto LABEL_25;
  }
  if (v7 != 10 || v8 != 4 || *((_BYTE *)this + 28) != 3)
  {
    _cg_jpeg_mem_term("isValid", 192, "🔺 bitsPerPixel too small: bpc: %d   #channels: %d   bpp: %d   min: %d\n");
    goto LABEL_25;
  }
  if (v9 > v5 + 8)
  {
    _cg_jpeg_mem_term("isValid", 187, "🔺 bitsPerPixel too small: bpc: %d   #channels: %d   bpp: %d   min: %d\n");
LABEL_25:
    result = 0;
  }
LABEL_26:
  v11 = *((unsigned __int16 *)this + 12);
  if ((v11 | 2) == 3 && *((_BYTE *)this + 26) && *((_WORD *)this + 10) != 5)
  {
    _cg_jpeg_mem_term("isValid", 208, "🔺 bad alpha: #channels: %d   alphaVal: %d 0x%08x\n", v11, *((unsigned __int8 *)this + 26), *((unsigned __int8 *)this + 26));
    return 0;
  }
  return result;
}

uint64_t IIOReadPlugin::extractDecodeOptions(IIOReadPlugin *this, const __CFDictionary *a2)
{
  uint64_t v3;
  _QWORD v5[5];
  _QWORD v6[3];

  *(_QWORD *)((char *)this + 404) = -1;
  *((_DWORD *)this + 100) = 538976288;
  *(_WORD *)((char *)this + 413) = 256;
  *((_OWORD *)this + 24) = xmmword_1882111C0;
  memset(v6, 0, sizeof(v6));
  IIODictionary::IIODictionary((IIODictionary *)v6, a2);
  if (IIODictionary::getBoolForKey((IIODictionary *)v6, CFSTR("kCGImageBlockIOSurfaceOptimizedRequest")))
  {
    if (*((_DWORD *)this + 80) == 1 && *((_WORD *)this + 153) == 32)
      *((_WORD *)this + 202) = 1;
    *((_BYTE *)this + 408) = 1;
    *((_QWORD *)this + 49) = 16;
    *((_BYTE *)this + 406) = 0;
    *((_BYTE *)this + 413) = 1;
  }
  else
  {
    v5[0] = MEMORY[0x1E0C809B0];
    v5[1] = 0x40000000;
    v5[2] = ___ZN13IIOReadPlugin20extractDecodeOptionsEPK14__CFDictionary_block_invoke;
    v5[3] = &__block_descriptor_tmp_33;
    v5[4] = this;
    IIODictionary::enumerate((uint64_t)v6, v5);
    if (!*((_BYTE *)this + 310) && *((_BYTE *)this + 406) == 1)
      *((_BYTE *)this + 414) = 0;
    if (*((unsigned __int8 *)this + 410) == 255)
      *((_QWORD *)this + 49) = 16;
    if (*((unsigned __int8 *)this + 409) == 255)
      *((_QWORD *)this + 48) = 64;
  }
  if (*((_BYTE *)this + 414))
    v3 = 0;
  else
    v3 = 4294967246;
  IIODictionary::~IIODictionary((IIODictionary *)v6);
  return v3;
}

void sub_187E54950(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOReadPlugin::updateRequestFormat(uint64_t this)
{
  int v1;

  switch(*(_DWORD *)(this + 320))
  {
    case 0:
      *(_DWORD *)(this + 400) = 1198678393;
      if (*(_BYTE *)(this + 404) == 1)
        *(_BYTE *)(this + 404) = -1;
      return this;
    case 1:
      if (*(_BYTE *)(this + 404) == 1)
      {
        v1 = 1111970392;
        goto LABEL_16;
      }
      if (*(_BYTE *)(this + 405) == 1)
      {
LABEL_12:
        v1 = 1380401752;
        goto LABEL_16;
      }
      switch(*(_BYTE *)(this + 310))
      {
        case 0:
          v1 = 1380401696;
          goto LABEL_16;
        case 1:
        case 2:
        case 3:
        case 4:
          v1 = 1380401729;
          goto LABEL_16;
        case 5:
        case 6:
          goto LABEL_12;
        default:
          return this;
      }
      return this;
    case 2:
      v1 = 1129142603;
      goto LABEL_16;
    case 3:
      v1 = 1281450528;
      goto LABEL_16;
    case 4:
      v1 = 1684371022;
      goto LABEL_16;
    case 5:
      v1 = 1768842360;
      goto LABEL_16;
    case 6:
      v1 = 1885434996;
LABEL_16:
      *(_DWORD *)(this + 400) = v1;
      break;
    default:
      return this;
  }
  return this;
}

void IIODictionary::enumerate(uint64_t a1, void *a2)
{
  const void *v2;

  v2 = *(const void **)(a1 + 8);
  if (v2)
    IIODictionaryEnumerateUsingBlock(v2, a2);
}

void IIODictionaryEnumerateUsingBlock(const void *a1, void *a2)
{
  CFTypeID v4;

  if (a1)
  {
    v4 = CFGetTypeID(a1);
    if (v4 == CFDictionaryGetTypeID())
      CFDictionaryApplyFunction((CFDictionaryRef)a1, (CFDictionaryApplierFunction)myApplierFunction, a2);
  }
}

uint64_t IIOReadPlugin::createImageBlockSetFromCache(uint64_t a1, uint64_t a2, uint64_t a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  uint64_t v14;
  int v15;
  unsigned int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  int v22;
  uint64_t v23;
  unsigned int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  unsigned int v29;
  int v30;
  uint64_t v31;
  unsigned int v32;
  int v33;
  uint64_t v34;
  unsigned int v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD v40[14];
  uint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  uint64_t v44;

  v41 = 0;
  v42 = &v41;
  v43 = 0x2000000000;
  v44 = 0;
  v14 = *(_QWORD *)(a1 + 32);
  v40[0] = MEMORY[0x1E0C809B0];
  v40[1] = 0x40000000;
  v40[2] = ___ZN13IIOReadPlugin28createImageBlockSetFromCacheEP7InfoRecP15CGImageProvider6CGRect6CGSizePK14__CFDictionary_block_invoke;
  v40[3] = &unk_1E1BC4B08;
  *(double *)&v40[6] = a4;
  *(double *)&v40[7] = a5;
  *(double *)&v40[8] = a6;
  *(double *)&v40[9] = a7;
  v40[4] = &v41;
  v40[5] = a1;
  v40[10] = a3;
  *(double *)&v40[11] = a8;
  *(double *)&v40[12] = a9;
  v40[13] = a2;
  IIOImageRead::enumerateCacheKeysWithBlock(v14, (uint64_t)v40);
  if (v42[3])
  {
    if ((gIIODebugFlags & 0x30000) == 0)
    {
LABEL_51:
      kdebug_trace();
      v19 = v42[3];
      goto LABEL_52;
    }
    v15 = *(_DWORD *)(a1 + 204);
    v16 = v15 >> 24;
    v17 = MEMORY[0x1E0C80978];
    if (v15 < 0)
    {
      v18 = __maskrune(v16, 0x40000uLL);
      v15 = *(_DWORD *)(a1 + 204);
    }
    else
    {
      v18 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v16 + 60) & 0x40000;
    }
    if (v18)
      v20 = (v15 >> 24);
    else
      v20 = 46;
    v21 = v15 << 8 >> 24;
    if (v15 << 8 < 0)
    {
      v22 = __maskrune(v21, 0x40000uLL);
      v15 = *(_DWORD *)(a1 + 204);
    }
    else
    {
      v22 = *(_DWORD *)(v17 + 4 * v21 + 60) & 0x40000;
    }
    if (v22)
      v23 = (v15 << 8 >> 24);
    else
      v23 = 46;
    v24 = (__int16)v15 >> 8;
    if (v15 << 16 < 0)
    {
      v25 = __maskrune(v24, 0x40000uLL);
      v15 = *(_DWORD *)(a1 + 204);
    }
    else
    {
      v25 = *(_DWORD *)(v17 + 4 * v24 + 60) & 0x40000;
    }
    if (v25)
      v26 = ((__int16)v15 >> 8);
    else
      v26 = 46;
    if ((v15 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v17 + 4 * (char)v15 + 60) & 0x40000) != 0)
        goto LABEL_24;
    }
    else if (__maskrune((char)v15, 0x40000uLL))
    {
LABEL_24:
      v27 = *(char *)(a1 + 204);
      goto LABEL_27;
    }
    v27 = 46;
LABEL_27:
    v28 = *(_DWORD *)(a1 + 400);
    v29 = v28 >> 24;
    if (v28 < 0)
    {
      v30 = __maskrune(v29, 0x40000uLL);
      v28 = *(_DWORD *)(a1 + 400);
    }
    else
    {
      v30 = *(_DWORD *)(v17 + 4 * v29 + 60) & 0x40000;
    }
    if (v30)
      v31 = (v28 >> 24);
    else
      v31 = 46;
    v32 = v28 << 8 >> 24;
    if (v28 << 8 < 0)
    {
      v33 = __maskrune(v32, 0x40000uLL);
      v28 = *(_DWORD *)(a1 + 400);
    }
    else
    {
      v33 = *(_DWORD *)(v17 + 4 * v32 + 60) & 0x40000;
    }
    if (v33)
      v34 = (v28 << 8 >> 24);
    else
      v34 = 46;
    v35 = (__int16)v28 >> 8;
    if (v28 << 16 < 0)
    {
      v36 = __maskrune(v35, 0x40000uLL);
      v28 = *(_DWORD *)(a1 + 400);
    }
    else
    {
      v36 = *(_DWORD *)(v17 + 4 * v35 + 60) & 0x40000;
    }
    if (v36)
      v37 = ((__int16)v28 >> 8);
    else
      v37 = 46;
    if ((v28 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v17 + 4 * (char)v28 + 60) & 0x40000) != 0)
        goto LABEL_47;
    }
    else if (__maskrune((char)v28, 0x40000uLL))
    {
LABEL_47:
      v38 = *(char *)(a1 + 400);
LABEL_50:
      ImageIOLog("❇️  '%c%c%c%c' rect: {%g,%g,%g,%g} found in cache - format: '%c%c%c%c'\n", v20, v23, v26, v27, a4, a5, a6, a7, v31, v34, v37, v38);
      goto LABEL_51;
    }
    v38 = 46;
    goto LABEL_50;
  }
  v19 = 0;
LABEL_52:
  _Block_object_dispose(&v41, 8);
  return v19;
}

void sub_187E54DEC(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 144), 8);
  _Unwind_Resume(a1);
}

uint64_t IIOImageRead::enumerateCacheKeysWithBlock(uint64_t a1, uint64_t a2)
{
  pthread_mutex_t *v4;
  __int128 *v5;
  __int128 *v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v11;
  _BYTE v12[28];

  v4 = (pthread_mutex_t *)(a1 + 312);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 312));
  v5 = *(__int128 **)(a1 + 288);
  v6 = *(__int128 **)(a1 + 296);
  if (v5 != v6)
  {
    v7 = 0;
    do
    {
      v8 = *v5;
      v9 = v5[1];
      *(_OWORD *)&v12[12] = *(__int128 *)((char *)v5 + 28);
      v11 = v8;
      *(_OWORD *)v12 = v9;
      (*(void (**)(uint64_t, __int128 *, uint64_t))(a2 + 16))(a2, &v11, v7);
      v7 = (v7 + 1);
      v5 = (__int128 *)((char *)v5 + 44);
    }
    while (v5 != v6);
  }
  return pthread_mutex_unlock(v4);
}

__n128 IIOReadPlugin::inputGeometry@<Q0>(IIOReadPlugin *this@<X0>, uint64_t a2@<X8>)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)((char *)this + 220);
  v3 = *(_OWORD *)((char *)this + 236);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v3;
  return result;
}

void IIOImageProviderInfo::checkBlockSetBuffer(uint64_t a1)
{
  uint64_t Count;
  uint64_t v3;
  uint64_t i;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  unint64_t BytesPerRow;
  unint64_t ComponentType;
  unint64_t PixelSize;
  unsigned __int8 *Data;
  unsigned __int8 *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  char v22;
  char v23;
  unint64_t v24;

  if (IIOImageProviderInfo::checkBlockSetBuffer(CGImageBlockSet *)::onceToken != -1)
    dispatch_once(&IIOImageProviderInfo::checkBlockSetBuffer(CGImageBlockSet *)::onceToken, &__block_literal_global_108);
  Count = CGImageBlockSetGetCount();
  if (Count)
  {
    v3 = Count;
    for (i = 0; i != v3; ++i)
    {
      if (CGImageBlockSetGetImageBlock())
      {
        CGImageBlockGetRect();
        v6 = v5;
        v8 = v7;
        v10 = v9;
        v12 = v11;
        BytesPerRow = CGImageBlockGetBytesPerRow();
        ComponentType = CGImageBlockSetGetComponentType();
        PixelSize = CGImageBlockSetGetPixelSize();
        Data = (unsigned __int8 *)CGImageBlockGetData();
        if (Data)
        {
          v17 = Data;
          v18 = v6;
          byte_1ECDD94D0 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[v18 >> 28];
          byte_1ECDD94D1 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v18 >> 24) & 0xF];
          byte_1ECDD94D2 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v18 >> 20) & 0xF];
          byte_1ECDD94D3 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v18 >> 16) & 0xF];
          byte_1ECDD94D4 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(unsigned __int16)v18 >> 12];
          byte_1ECDD94D5 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v18 >> 8) & 0xF];
          byte_1ECDD94D6 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[v18 >> 4];
          byte_1ECDD94D7 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[v18 & 0xF];
          v19 = v8;
          byte_1ECDD94DB = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[v19 >> 28];
          byte_1ECDD94DC = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v19 >> 24) & 0xF];
          byte_1ECDD94DD = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v19 >> 20) & 0xF];
          byte_1ECDD94DE = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v19 >> 16) & 0xF];
          byte_1ECDD94DF = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(unsigned __int16)v19 >> 12];
          byte_1ECDD94E0 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v19 >> 8) & 0xF];
          byte_1ECDD94E1 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[v19 >> 4];
          byte_1ECDD94E2 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[v19 & 0xF];
          v20 = v10;
          byte_1ECDD94E6 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[v20 >> 28];
          byte_1ECDD94E7 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v20 >> 24) & 0xF];
          byte_1ECDD94E8 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v20 >> 20) & 0xF];
          byte_1ECDD94E9 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v20 >> 16) & 0xF];
          byte_1ECDD94EA = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(unsigned __int16)v20 >> 12];
          byte_1ECDD94EB = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v20 >> 8) & 0xF];
          byte_1ECDD94EC = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[v20 >> 4];
          v21 = v12;
          byte_1ECDD94ED = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[v20 & 0xF];
          byte_1ECDD94F1 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[v21 >> 28];
          byte_1ECDD94F2 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v21 >> 24) & 0xF];
          byte_1ECDD94F3 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v21 >> 20) & 0xF];
          byte_1ECDD94F4 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v21 >> 16) & 0xF];
          byte_1ECDD94F5 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(unsigned __int16)v21 >> 12];
          byte_1ECDD94F6 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v21 >> 8) & 0xF];
          byte_1ECDD94F7 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[v21 >> 4];
          byte_1ECDD94F8 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[v21 & 0xF];
          byte_1ECDD9500 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[BytesPerRow >> 28];
          byte_1ECDD9501 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(BytesPerRow >> 24) & 0xF];
          byte_1ECDD9502 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(BytesPerRow >> 20) & 0xF];
          byte_1ECDD9503 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(BytesPerRow >> 16) & 0xF];
          byte_1ECDD9504 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(unsigned __int16)BytesPerRow >> 12];
          byte_1ECDD9505 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(BytesPerRow >> 8) & 0xF];
          byte_1ECDD9506 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[BytesPerRow >> 4];
          byte_1ECDD9507 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[BytesPerRow & 0xF];
          byte_1ECDD9513 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[PixelSize >> 28];
          byte_1ECDD9514 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(PixelSize >> 24) & 0xF];
          byte_1ECDD9515 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(PixelSize >> 20) & 0xF];
          byte_1ECDD9516 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(PixelSize >> 16) & 0xF];
          byte_1ECDD9517 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(unsigned __int16)PixelSize >> 12];
          byte_1ECDD9518 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(PixelSize >> 8) & 0xF];
          byte_1ECDD9519 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[PixelSize >> 4];
          byte_1ECDD951A = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[PixelSize & 0xF];
          byte_1ECDD9527 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(unint64_t)ComponentType >> 28];
          v22 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(ComponentType >> 20) & 0xF];
          byte_1ECDD9528 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(ComponentType >> 24) & 0xF];
          byte_1ECDD9529 = v22;
          byte_1ECDD952A = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(ComponentType >> 16) & 0xF];
          v23 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(ComponentType >> 8) & 0xF];
          byte_1ECDD952B = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(unsigned __int16)ComponentType >> 12];
          byte_1ECDD952C = v23;
          byte_1ECDD952D = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[ComponentType >> 4];
          byte_1ECDD952E = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[ComponentType & 0xF];
          *(_DWORD *)&algn_1ECDD952F[6] = bswap32(*(_DWORD *)(a1 + 72));
          LODWORD(v20) = *(_DWORD *)(a1 + 128);
          byte_1ECDD9540 = BYTE3(v20);
          byte_1ECDD9541 = BYTE2(v20);
          byte_1ECDD9542 = BYTE1(v20);
          byte_1ECDD9543 = v20;
          memset(&byte_1ECDD954F, 48, 16);
          qword_1ECDD8318 = (uint64_t)&IIOImageProviderInfo::checkBlockSetBuffer(CGImageBlockSet *)::logMessage;
          CHECK_FIRST_BYTE_OF_IMAGEBLOCK(Data);
          if (is_mul_ok((unint64_t)v12, BytesPerRow))
          {
            v24 = (unint64_t)v12 * BytesPerRow;
            if (v24)
            {
              byte_1ECDD954F = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v24 - 1) >> 60];
              byte_1ECDD9550 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[((v24 - 1) >> 56) & 0xF];
              byte_1ECDD9551 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[((v24 - 1) >> 52) & 0xF];
              byte_1ECDD9552 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[((v24 - 1) >> 48) & 0xF];
              byte_1ECDD9553 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[((v24 - 1) >> 44) & 0xF];
              byte_1ECDD9554 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[((v24 - 1) >> 40) & 0xF];
              byte_1ECDD9555 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[((v24 - 1) >> 36) & 0xF];
              byte_1ECDD9556 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[((v24 - 1) >> 32) & 0xF];
              byte_1ECDD9557 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[((unint64_t)v12 * BytesPerRow - 1) >> 28];
              byte_1ECDD9558 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[((v24 - 1) >> 24) & 0xF];
              byte_1ECDD9559 = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[((v24 - 1) >> 20) & 0xF];
              byte_1ECDD955A = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[((v24 - 1) >> 16) & 0xF];
              byte_1ECDD955B = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(unsigned __int16)((unint64_t)v12 * BytesPerRow - 1) >> 12];
              byte_1ECDD955C = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[((v24 - 1) >> 8) & 0xF];
              byte_1ECDD955D = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[((unint64_t)v12 * BytesPerRow - 1) >> 4];
              byte_1ECDD955E = CopyUInt32AsHexToStringAtOffset(unsigned int,char *,unsigned int)::table[(v24 - 1) & 0xF];
              qword_1ECDD8318 = (uint64_t)&IIOImageProviderInfo::checkBlockSetBuffer(CGImageBlockSet *)::logMessage;
              CHECK_LAST_BYTE_OF_IMAGEBLOCK(v17);
            }
          }
          qword_1ECDD8318 = 0;
        }
      }
    }
  }
}

uint64_t CGImageReadSessionGetRead(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    v1 = *(_QWORD *)(result + 24);
    if (v1)
      return *(_QWORD *)(v1 + 32);
    else
      return 0;
  }
  return result;
}

uint64_t IIODecodeParameter::IIODecodeParameter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, CFTypeRef cf, double a6, double a7, double a8, double a9, double a10, double a11)
{
  *(_QWORD *)a1 = &off_1E1BB1560;
  *(_QWORD *)(a1 + 8) = a2;
  *(_QWORD *)(a1 + 16) = a3;
  *(double *)(a1 + 24) = a6;
  *(double *)(a1 + 32) = a7;
  *(double *)(a1 + 40) = a8;
  *(double *)(a1 + 48) = a9;
  *(double *)(a1 + 56) = a10;
  *(double *)(a1 + 64) = a11;
  *(_QWORD *)(a1 + 72) = a4;
  *(_QWORD *)(a1 + 80) = 0;
  if (cf)
    *(_QWORD *)(a1 + 80) = CFRetain(cf);
  return a1;
}

uint64_t IIOReadPlugin::index(IIOReadPlugin *this)
{
  return *((unsigned int *)this + 52);
}

void IIODecodeParameter::~IIODecodeParameter(IIODecodeParameter *this)
{
  const void *v2;

  *(_QWORD *)this = &off_1E1BB1560;
  v2 = (const void *)*((_QWORD *)this + 10);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 10) = 0;
}

{
  IIODecodeParameter::~IIODecodeParameter(this);
  JUMPOUT(0x18D761C30);
}

uint64_t ___ZN13IIOReadPlugin28createImageBlockSetFromCacheEP7InfoRecP15CGImageProvider6CGRect6CGSizePK14__CFDictionary_block_invoke(uint64_t a1, uint64_t a2, double a3, double a4)
{
  uint64_t v6;
  double v7;
  double v8;
  double v9;
  double v10;
  uint64_t result;
  uint64_t v12;
  const void *v13;
  unint64_t v14;
  CGRect v15;

  v6 = *(_QWORD *)(a1 + 40);
  LODWORD(a3) = *(_DWORD *)(a2 + 8);
  LODWORD(a4) = *(_DWORD *)(a2 + 12);
  v7 = (double)*(unint64_t *)&a3;
  v8 = (double)*(unint64_t *)&a4;
  LODWORD(a3) = *(_DWORD *)(a2 + 16);
  LODWORD(a4) = *(_DWORD *)(a2 + 20);
  v9 = (double)*(unint64_t *)&a3;
  v10 = (double)*(unint64_t *)&a4;
  v15.origin.x = v7;
  v15.origin.y = v8;
  v15.size.width = (double)*(unint64_t *)&a3;
  v15.size.height = (double)*(unint64_t *)&a4;
  result = CGRectEqualToRect(*(CGRect *)(a1 + 48), v15);
  if ((_DWORD)result)
  {
    v12 = *(_QWORD *)(a2 + 28);
    if (*(_DWORD *)(v6 + 208) == (unsigned __int16)v12
      && *(_DWORD *)(a2 + 24) == *(_DWORD *)(v6 + 400)
      && *(_WORD *)(v6 + 304) == BYTE6(v12)
      && __PAIR64__((v12 & 0x200000000000000) != 0, HIBYTE(v12) & 1) == __PAIR64__(*(unsigned __int8 *)(v6 + 354), *(unsigned __int8 *)(v6 + 353)))
    {
      v14 = 0;
      result = IIOImageRead::getCachedImageBlockData(*(_QWORD *)(v6 + 32), (_DWORD *)a2, (void **)&v14);
      if ((_DWORD)result)
      {
        v13 = IIO_ImageBlockCreate(v14, *(unsigned int *)(a2 + 36), 0, v7, v8, v9, v10);
        result = IIOReadPlugin::imageBlockSetCreate(v6, *(_QWORD *)(a1 + 80), 1uLL, *(double *)(a1 + 88), *(double *)(a1 + 96), *(double *)(a1 + 48), *(double *)(a1 + 56), *(double *)(a1 + 64), *(double *)(a1 + 72), (uint64_t)&v13, *(const void **)(a1 + 104));
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
      }
    }
  }
  return result;
}

BOOL imageio_key_is_equal(char *a1, char *a2, void *a3)
{
  _BOOL8 v3;
  uint64_t v5;
  char *DebugStringFromKey;
  char *v7;
  const char *v8;
  char *v9;
  char *v10;
  _BOOL4 v12;

  v3 = 0;
  if (a1 && a2)
  {
    if (*(_QWORD *)a1 == *(_QWORD *)a2
      && *((_DWORD *)a1 + 2) == *((_DWORD *)a2 + 2)
      && *((_DWORD *)a1 + 3) == *((_DWORD *)a2 + 3)
      && *((_DWORD *)a1 + 4) == *((_DWORD *)a2 + 4)
      && *((_DWORD *)a1 + 5) == *((_DWORD *)a2 + 5)
      && (v5 = *(_QWORD *)(a2 + 28) ^ *(_QWORD *)(a1 + 28), (v5 & 0xFF00FFFFFFFFFFLL) == 0))
    {
      v12 = *((_DWORD *)a1 + 6) == *((_DWORD *)a2 + 6) && (v5 & 0x100000000000000) == 0;
      v3 = (v5 & 0x200000000000000) == 0 && (unint64_t)v12;
    }
    else
    {
      v3 = 0;
    }
    if ((~(_WORD)gIIODebugFlags & 0x300) == 0)
    {
      DebugStringFromKey = createDebugStringFromKey((uint64_t)a1);
      if (DebugStringFromKey)
      {
        v7 = DebugStringFromKey;
        v8 = "!=";
        if (v3)
          v8 = "==";
        ImageIOLog("    %s %s\n", v8, DebugStringFromKey);
        free(v7);
      }
      v9 = createDebugStringFromKey((uint64_t)a2);
      if (v9)
      {
        v10 = v9;
        ImageIOLog("       %s\n", v9);
        free(v10);
      }
    }
  }
  return v3;
}

const void *CommonASTCReadPlugin::copyImageTextureData(uint64_t a1)
{
  const void *result;
  uint64_t v3;
  int v4;
  const void *ColorSpace;
  int v6;
  const void **v7;
  int v8;
  const void *v9;
  _QWORD *v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  std::__shared_weak_count *v18;
  _BYTE v19[24];
  _BYTE v20[24];
  _BYTE v21[24];
  _BYTE v22[24];
  _BYTE v23[24];
  _BYTE v24[24];
  _BYTE v25[24];
  _BYTE v26[24];
  _QWORD v27[3];
  __int128 v28;
  __int128 v29;

  result = *(const void **)(a1 + 464);
  if (result)
    goto LABEL_15;
  v28 = xmmword_1E1BCA8E8;
  v29 = *(_OWORD *)off_1E1BCA8F8;
  v3 = IIOImageRead::imageCount(*(IIOImageRead **)(a1 + 32));
  memset(v27, 0, sizeof(v27));
  IIODictionary::IIODictionary((IIODictionary *)v27);
  v4 = *(_DWORD *)(a1 + 452);
  IIONumber::IIONumber((IIONumber *)v26, *(_DWORD *)(a1 + 436));
  IIODictionary::setObjectForKey((uint64_t)v27, (uint64_t)v26, CFSTR("width"));
  IIONumber::~IIONumber((IIONumber *)v26);
  IIONumber::IIONumber((IIONumber *)v25, *(_DWORD *)(a1 + 440));
  IIODictionary::setObjectForKey((uint64_t)v27, (uint64_t)v25, CFSTR("height"));
  IIONumber::~IIONumber((IIONumber *)v25);
  IIONumber::IIONumber((IIONumber *)v24, 16 * v4);
  IIODictionary::setObjectForKey((uint64_t)v27, (uint64_t)v24, CFSTR("rowBytes"));
  IIONumber::~IIONumber((IIONumber *)v24);
  IIONumber::IIONumber((IIONumber *)v23, *(_DWORD *)(a1 + 448));
  IIODictionary::setObjectForKey((uint64_t)v27, (uint64_t)v23, CFSTR("metalFormat"));
  IIONumber::~IIONumber((IIONumber *)v23);
  IIONumber::IIONumber((IIONumber *)v22, v3);
  IIODictionary::setObjectForKey((uint64_t)v27, (uint64_t)v22, CFSTR("mipmapLevelCount"));
  IIONumber::~IIONumber((IIONumber *)v22);
  IIONumber::IIONumber((IIONumber *)v21, 1);
  IIODictionary::setObjectForKey((uint64_t)v27, (uint64_t)v21, CFSTR("faceCount"));
  IIONumber::~IIONumber((IIONumber *)v21);
  ColorSpace = (const void *)CGImageProviderGetColorSpace();
  IIODictionary::setObjectForKey((IIODictionary *)v27, ColorSpace, CFSTR("colorSpace"));
  v6 = hardware_supports_astc();
  v7 = (const void **)MEMORY[0x1E0C9AE50];
  if (!v6)
    v7 = (const void **)MEMORY[0x1E0C9AE40];
  IIODictionary::setObjectForKey((IIODictionary *)v27, *v7, CFSTR("supportsTiledLayout"));
  v8 = ASTCTextureImp::GLFormatForMetalFormat((ASTCTextureImp *)*(unsigned int *)(a1 + 448));
  IIONumber::IIONumber((IIONumber *)v20, v8);
  IIODictionary::setObjectForKey((uint64_t)v27, (uint64_t)v20, CFSTR("pixelFormatGL"));
  IIONumber::~IIONumber((IIONumber *)v20);
  IIONumber::IIONumber((IIONumber *)v19, *(_DWORD *)(a1 + 448));
  IIODictionary::setObjectForKey((uint64_t)v27, (uint64_t)v19, CFSTR("pixelFormatMetal"));
  IIONumber::~IIONumber((IIONumber *)v19);
  v9 = (const void *)IIOImageSource::cf(*(IIOImageSource **)(a1 + 32));
  v10 = (_QWORD *)operator new();
  IIOTextureHandler::IIOTextureHandler(v10, v9);
  if (IIO_Reader::testHeaderSize(*(IIO_Reader **)(a1 + 32)))
  {
    *(_QWORD *)(a1 + 464) = CGImageTextureDataCreate();
    v11 = *(std::__shared_weak_count **)(a1 + 480);
    v17 = *(_QWORD *)(a1 + 472);
    v18 = v11;
    if (v11)
    {
      p_shared_owners = (unint64_t *)&v11->__shared_owners_;
      do
        v13 = __ldxr(p_shared_owners);
      while (__stxr(v13 + 1, p_shared_owners));
    }
    std::shared_ptr<IIOBaseObject>::operator=[abi:ne180100](v10 + 1, &v17);
    v14 = v18;
    if (v18)
    {
      v15 = (unint64_t *)&v18->__shared_owners_;
      do
        v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
  }
  else
  {
    (*(void (**)(_QWORD *))(*v10 + 8))(v10);
    *(_QWORD *)(a1 + 464) = 0;
  }
  IIODictionary::~IIODictionary((IIODictionary *)v27);
  result = *(const void **)(a1 + 464);
  if (result)
  {
LABEL_15:
    CFRetain(result);
    return *(const void **)(a1 + 464);
  }
  return result;
}

void sub_187E55AB8(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  MEMORY[0x18D761C30](v1, 0xA1C40B41E38F6);
  IIODictionary::~IIODictionary((IIODictionary *)(v2 - 104));
  _Unwind_Resume(a1);
}

uint64_t IIOArrayEnumerateUsingBlock(uint64_t result, uint64_t a2)
{
  const __CFArray *v3;
  CFTypeID v4;
  uint64_t v5;
  CFIndex v6;
  const void *ValueAtIndex;
  BOOL v8;
  char v9;

  if (result)
  {
    v3 = (const __CFArray *)result;
    v4 = CFGetTypeID((CFTypeRef)result);
    result = CFArrayGetTypeID();
    if (v4 == result)
    {
      result = CFArrayGetCount(v3);
      v9 = 0;
      v5 = result - 1;
      if (result >= 1)
      {
        v6 = 0;
        do
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v3, v6);
          result = (*(uint64_t (**)(uint64_t, const void *, CFIndex, char *))(a2 + 16))(a2, ValueAtIndex, v6, &v9);
          if (v9)
            v8 = 1;
          else
            v8 = v5 == v6;
          ++v6;
        }
        while (!v8);
      }
    }
  }
  return result;
}

void ___ZN17IIO_ReaderHandler15buildPluginListEv_block_invoke_2(uint64_t a1, const __CFDictionary *a2)
{
  _QWORD *v3;
  IIOReader_RawCamera *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;
  __int128 v19;
  char *v20;
  _QWORD v21[3];
  uint64_t v22;
  __int128 v23;
  char *v24;
  _QWORD *v25;

  v3 = *(_QWORD **)(a1 + 40);
  memset(v21, 0, sizeof(v21));
  IIODictionary::IIODictionary((IIODictionary *)v21, a2);
  if (!IIODictionary::getBoolForKey((IIODictionary *)v21, CFSTR("IsPreTiff")))
  {
    v4 = (IIOReader_RawCamera *)operator new();
    IIOReader_RawCamera::IIOReader_RawCamera(v4, (IIODictionary *)v21);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v4;
    v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v6 = *(_QWORD *)(v5 + 24);
    if (v6)
    {
      v7 = v3[4];
      v8 = (_QWORD *)v3[3];
      if ((unint64_t)v8 >= v7)
      {
        v10 = (_QWORD *)v3[2];
        v11 = v8 - v10;
        if ((unint64_t)(v11 + 1) >> 61)
          std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
        v12 = v7 - (_QWORD)v10;
        v13 = (uint64_t)(v7 - (_QWORD)v10) >> 2;
        if (v13 <= v11 + 1)
          v13 = v11 + 1;
        if (v12 >= 0x7FFFFFFFFFFFFFF8)
          v14 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v14 = v13;
        v25 = v3 + 4;
        if (v14)
        {
          v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)(v3 + 4), v14);
          v10 = (_QWORD *)v3[2];
          v8 = (_QWORD *)v3[3];
          v6 = *(_QWORD *)(v5 + 24);
        }
        else
        {
          v15 = 0;
        }
        v16 = &v15[8 * v11];
        v17 = &v15[8 * v14];
        v24 = v17;
        *(_QWORD *)v16 = v6;
        *((_QWORD *)&v23 + 1) = v16 + 8;
        if (v8 == v10)
        {
          v9 = v16 + 8;
        }
        else
        {
          do
          {
            v18 = *--v8;
            *v8 = 0;
            *((_QWORD *)v16 - 1) = v18;
            v16 -= 8;
          }
          while (v8 != v10);
          v9 = (_QWORD *)*((_QWORD *)&v23 + 1);
          v17 = v24;
        }
        v19 = *((_OWORD *)v3 + 1);
        v3[2] = v16;
        v3[3] = v9;
        v23 = v19;
        v20 = (char *)v3[4];
        v3[4] = v17;
        v24 = v20;
        v22 = v19;
        std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)&v22);
      }
      else
      {
        *v8 = v6;
        v9 = v8 + 1;
      }
      v3[3] = v9;
    }
  }
  IIODictionary::~IIODictionary((IIODictionary *)v21);
}

void sub_187E55D80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;

  MEMORY[0x18D761C30](v9, 0x10F1C409D307853);
  IIODictionary::~IIODictionary((IIODictionary *)&a9);
  _Unwind_Resume(a1);
}

void IIOReader_RawCamera::IIOReader_RawCamera(IIOReader_RawCamera *this, IIODictionary *a2)
{
  _QWORD *v4;
  const __CFDictionary *ObjectForKey;
  const __CFDictionary *v6;

  IIO_Reader::IIO_Reader(this);
  *v4 = &off_1E1BB1BF0;
  if (a2)
  {
    *((_BYTE *)this + 48) = 1;
    ObjectForKey = IIODictionary::getObjectForKey(a2, CFSTR("UTType"));
    *((_QWORD *)this + 7) = ObjectForKey;
    CFRetain(ObjectForKey);
    *((_QWORD *)this + 1) = (char *)this + 56;
    v6 = IIODictionary::getObjectForKey(a2, CFSTR("Extensions"));
    *((_QWORD *)this + 8) = v6;
    CFRetain(v6);
    *((_QWORD *)this + 2) = CFStringGetCStringPtr(*((CFStringRef *)this + 8), 0x8000100u);
    *((_DWORD *)this + 6) = 1380013856;
    *((_QWORD *)this + 4) = IIODictionary::getUint32ForKey(a2, CFSTR("TestHeaderSize"));
    *((_QWORD *)this + 5) = IIODictionary::getUint32ForKey(a2, CFSTR("MinimumFileSize"));
    *((_QWORD *)this + 9) = IIODictionary::getUint64ForKey(a2, CFSTR("TestHeaderProc"));
    *((_QWORD *)this + 10) = IIODictionary::getUint64ForKey(a2, CFSTR("AddSourcePropsProc"));
    *((_QWORD *)this + 11) = IIODictionary::getUint64ForKey(a2, CFSTR("ImageCountProc"));
    *((_QWORD *)this + 12) = IIODictionary::getUint64ForKey(a2, CFSTR("CompareOptsProc"));
    *((_QWORD *)this + 13) = IIODictionary::getUint64ForKey(a2, CFSTR("InitImageProc"));
    *((_QWORD *)this + 14) = IIODictionary::getUint64ForKey(a2, CFSTR("InitThumbnailProc"));
    *((_QWORD *)this + 15) = IIODictionary::getUint64ForKey(a2, CFSTR("CopyAuxiliaryDataProc"));
    IIOReader_RawCamera::createRAWOSType((uint64_t)this);
  }
}

void sub_187E56000(_Unwind_Exception *a1, uint64_t a2, const char *a3)
{
  uint64_t v3;

  _cg_jpeg_mem_term(v3, a2, a3);
  _Unwind_Resume(a1);
}

uint64_t IIODictionary::getUint64FromValue(IIODictionary *this, const __CFString *cf)
{
  CFTypeID v3;
  CFTypeID v5;
  uint64_t valuePtr;

  valuePtr = 0;
  if (!cf)
    return 0;
  v3 = CFGetTypeID(cf);
  if (v3 == CFNumberGetTypeID())
  {
    CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt64Type, &valuePtr);
    return valuePtr;
  }
  v5 = CFGetTypeID(cf);
  if (v5 == CFStringGetTypeID())
    return CFStringGetIntValue(cf);
  else
    return 0;
}

const __CFDictionary *IIODictionary::getUint64ForKey(IIODictionary *this, const __CFString *a2)
{
  const __CFDictionary *result;
  IIODictionary *Value;

  result = (const __CFDictionary *)*((_QWORD *)this + 1);
  if (result)
  {
    Value = (IIODictionary *)CFDictionaryGetValue(result, a2);
    return (const __CFDictionary *)IIODictionary::getUint64FromValue(Value, (const __CFString *)Value);
  }
  return result;
}

uint64_t IIOReader_RawCamera::createRAWOSType(uint64_t this)
{
  int v1;
  int v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;

  v1 = 1380003888;
  v2 = gRawIndex;
  v3 = gRawIndex % 0x5Au;
  if (gRawIndex % 0x5Au >= 0xA)
  {
    v4 = gRawIndex - v3;
    v5 = (gRawIndex - 10 - v4) / 0xA;
    v1 = (v5 << 8) + 1380004144;
    v3 = gRawIndex - 10 - 10 * v5 - v4;
  }
  *(_DWORD *)(this + 24) = v1 + v3;
  gRawIndex = v2 + 1;
  return this;
}

void IIO_Reader::IIO_Reader(IIO_Reader *this)
{
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = &off_1E1BAB4F8;
  *((_DWORD *)this + 6) = 538976288;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_BYTE *)this + 48) = 0;
}

BOOL IIODictionary::getBoolForKey(IIODictionary *this, const __CFString *a2)
{
  const __CFDictionary *v2;
  IIODictionary *Value;

  if (!a2)
    return 0;
  v2 = (const __CFDictionary *)*((_QWORD *)this + 1);
  if (!v2)
    return 0;
  Value = (IIODictionary *)CFDictionaryGetValue(v2, a2);
  return IIODictionary::getBoolFromValue(Value, (const __CFString *)Value);
}

BOOL IIODictionary::getBoolFromValue(IIODictionary *this, const __CFString *cf)
{
  CFTypeID v3;
  uint64_t v4;
  CFTypeID v5;
  BOOL v6;
  CFTypeID v7;
  char valuePtr;

  if (!cf)
    return 0;
  v3 = CFGetTypeID(cf);
  if (v3 == CFBooleanGetTypeID())
    return *MEMORY[0x1E0C9AE50] == (_QWORD)cf;
  v5 = CFGetTypeID(cf);
  if (v5 == CFNumberGetTypeID())
  {
    valuePtr = 0;
    CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt8Type, &valuePtr);
    v6 = valuePtr == 0;
    return !v6;
  }
  v7 = CFGetTypeID(cf);
  if (v7 != CFStringGetTypeID())
    return 0;
  v4 = 1;
  if (CFStringCompare(cf, CFSTR("true"), 1uLL) == kCFCompareEqualTo)
    return v4;
  if (CFStringCompare(cf, CFSTR("false"), 1uLL) == kCFCompareEqualTo)
    return 0;
  v6 = CFStringGetIntValue(cf) == 0;
  return !v6;
}

uint64_t IIODictionary::getUint32FromValue(IIODictionary *this, const __CFString *cf)
{
  CFTypeID v3;
  CFTypeID v5;
  unsigned int valuePtr;

  valuePtr = 0;
  if (!cf)
    return 0;
  v3 = CFGetTypeID(cf);
  if (v3 == CFNumberGetTypeID())
  {
    CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt32Type, &valuePtr);
    return valuePtr;
  }
  v5 = CFGetTypeID(cf);
  if (v5 == CFStringGetTypeID())
    return CFStringGetIntValue(cf);
  else
    return 0;
}

const __CFDictionary *IIODictionary::getUint32ForKey(IIODictionary *this, const __CFString *a2)
{
  const __CFDictionary *result;
  IIODictionary *Value;

  result = (const __CFDictionary *)*((_QWORD *)this + 1);
  if (result)
  {
    Value = (IIODictionary *)CFDictionaryGetValue(result, a2);
    return (const __CFDictionary *)IIODictionary::getUint32FromValue(Value, (const __CFString *)Value);
  }
  return result;
}

const __CFDictionary *IIODictionary::getUint32ForKeyGroup(IIODictionary *this, const __CFString *a2, const __CFString *a3)
{
  const __CFDictionary *result;
  IIODictionary *Value;

  result = IIODictionary::getGroupForKey(this, a3, 0);
  if (result)
  {
    Value = (IIODictionary *)CFDictionaryGetValue(result, a2);
    return (const __CFDictionary *)IIODictionary::getUint32FromValue(Value, (const __CFString *)Value);
  }
  return result;
}

void ___ZN17IIO_ReaderHandler17setAllowableTypesEPK9__CFArray_block_invoke(uint64_t a1, const void *a2)
{
  const __CFArray *v4;
  const char *v5;
  _QWORD v6[3];
  CFRange v7;

  v4 = *(const __CFArray **)(a1 + 40);
  v7.length = CFArrayGetCount(v4);
  v7.location = 0;
  if (CFArrayContainsValue(v4, v7, a2))
  {
    ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  else
  {
    memset(v6, 0, sizeof(v6));
    IIOString::IIOString((IIOString *)v6, a2);
    v5 = (const char *)IIOString::utf8String((IIOString *)v6);
    LogError("setAllowableTypes_block_invoke", 1259, "*** CGImageSourceSetAllowableTypes - ignoring unknown: '%s'\n", v5);
    IIOString::~IIOString((IIOString *)v6);
  }
}

void sub_187E56434(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

const void *IIO_ImageBlockCreate(unint64_t a1, uint64_t a2, const void *a3, double a4, double a5, double a6, double a7)
{
  const void *v13;
  const char *v14;
  const void *v15;
  unsigned int v16;
  unint64_t v18;
  unint64_t *v19;

  if (a3)
  {
    v13 = a3;
    v14 = "";
  }
  else
  {
    pthread_mutex_lock(&gImageIOMemoryHashLock);
    if (gMemoryHashCreateOnce != -1)
      dispatch_once(&gMemoryHashCreateOnce, &__block_literal_global_30);
    v18 = ~a1;
    v19 = &v18;
    v13 = (const void *)std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>((uint64_t **)(gIIOMemoryHash + 8), &v18, (uint64_t)&std::piecewise_construct, (uint64_t **)&v19)[5];
    pthread_mutex_unlock(&gImageIOMemoryHashLock);
    v14 = "cached";
  }
  v15 = (const void *)CGImageBlockCreate();
  if ((gIIODebugFlags & 0xC00) != 0)
  {
    do
      v16 = __ldxr((unsigned int *)&gBlockCount);
    while (__stxr(v16 + 1, (unsigned int *)&gBlockCount));
    ImageIOLog("    CGImageBlockCreate:       %14p - info: %14p  data: %14p  B-[%2ld]  rb: %8ld  r:(%4g,%4g,%4g,%4g) %s\n", v15, v13, (const void *)a1, gBlockCount, a2, a4, a5, a6, a7, v14);
    if ((gIIODebugFlags & 0x800) != 0)
      IIODebug_ShowBacktrace(2);
  }
  return v15;
}

_QWORD *IIOTextureHandler::IIOTextureHandler(_QWORD *a1, const void *a2)
{
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  _QWORD *v7;
  IIOImageRead **Source;
  __int128 v10;

  *a1 = &off_1E1BB10B0;
  a1[1] = 0;
  a1[2] = 0;
  v10 = 0uLL;
  std::shared_ptr<IIOTextureDataImp>::operator=[abi:ne180100]<BCTextureImp,void>((uint64_t)(a1 + 1), &v10);
  v4 = (std::__shared_weak_count *)*((_QWORD *)&v10 + 1);
  if (*((_QWORD *)&v10 + 1))
  {
    v5 = (unint64_t *)(*((_QWORD *)&v10 + 1) + 8);
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  a1[6] = 0;
  a1[3] = a2;
  a1[4] = 0;
  if (a2)
  {
    CFRetain(a2);
    a1[4] = CGImageSourceGetSource(a1[3]);
    v7 = CGImageReadSessionCreate((const void *)a1[3]);
    a1[5] = v7;
    Source = (IIOImageRead **)CGImageSourceGetSource((uint64_t)v7);
    a1[6] = Source;
    IIOImageReadSession::mapData(Source);
  }
  return a1;
}

void sub_187E56698(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t ASTCTextureImp::GLFormatForMetalFormat(ASTCTextureImp *this)
{
  if (((_DWORD)this - 186) > 0x32)
    return 0;
  else
    return dword_18821180C[(int)this - 186];
}

uint64_t IIOImageRead::imageCount(IIOImageRead *this)
{
  IIOImageSource *Source;

  Source = (IIOImageSource *)CGImageSourceGetSource(~*((_QWORD *)this + 2));
  if (Source)
    return IIOImageSource::count(Source);
  else
    return 1;
}

uint64_t hardware_supports_astc(void)
{
  if (hardware_supports_astc(void)::onceToken != -1)
    dispatch_once(&hardware_supports_astc(void)::onceToken, &__block_literal_global_16);
  return hardware_supports_astc(void)::supportsASTC;
}

uint64_t _CGImageMetadataTagFinalize(_QWORD *a1)
{
  unint64_t v2;
  uint64_t result;

  do
    v2 = __ldxr(&gMDTCount);
  while (__stxr(v2 - 1, &gMDTCount));
  result = a1[3];
  if (result)
  {
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
    a1[3] = 0;
  }
  return result;
}

void IIOMetadata_Tag::~IIOMetadata_Tag(IIOMetadata_Tag *this)
{
  IIOMetadata_Tag::~IIOMetadata_Tag(this);
  JUMPOUT(0x18D761C30);
}

{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;

  *(_QWORD *)this = &off_1E1BB0250;
  v2 = (const void *)*((_QWORD *)this + 4);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 2);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 3);
  if (v4)
    CFRelease(v4);
  v5 = (const void *)*((_QWORD *)this + 7);
  if (v5)
    CFRelease(v5);
  v6 = (const void *)*((_QWORD *)this + 6);
  if (v6)
    CFRelease(v6);
}

uint64_t imageio_make_purgeable(void *a1, void *a2)
{
  if ((gIIODebugFlags & 0x202) != 0)
    ImageIOLog("    imageio_make_purgeable    value: %p   user_data: %p\n", a1, a2);
  return ImageIO_make_purgeable(a1);
}

const char *IIOReadPlugin::ImageBlockRelease(const char *result, const void *a2)
{
  void *Data;

  if ((gIIODebugFlags & 0xC00) != 0)
    result = IIO_ImageBlockReleased(result, a2);
  if (a2)
  {
    Data = (void *)CGImageBlockGetData();
    return (const char *)CGImageReadSessionReleaseCachedImageBlockData(Data);
  }
  return result;
}

uint64_t releaseUnusedImageProvider(uint64_t result, void *a2)
{
  uint64_t v2;

  if (*MEMORY[0x1E0C9B0D0] != result)
  {
    v2 = *(_QWORD *)(result + 24);
    IIOImagePlus::releaseUnusedImageProvider(v2);
    return IIOImagePlus::setISR(v2, 0);
  }
  return result;
}

uint64_t IIOImagePlus::releaseUnusedImageProvider(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  unint64_t v5;
  BOOL v6;
  unint64_t v7;

  if ((*(_BYTE *)(this + 192) & 0x40) == 0)
  {
    v1 = this;
    v2 = *(_QWORD *)(this + 144);
    v3 = *MEMORY[0x1E0C9B0D0];
    if (v2)
      v4 = v2 == v3;
    else
      v4 = 1;
    if (!v4)
    {
      do
        v5 = __ldxr(&gImageProviderCount);
      while (__stxr(v5 - 1, &gImageProviderCount));
      CGImageProviderRelease();
    }
    this = *(_QWORD *)(v1 + 152);
    if (this)
      v6 = this == v3;
    else
      v6 = 1;
    if (!v6)
    {
      do
        v7 = __ldxr(&gImageProviderCount);
      while (__stxr(v7 - 1, &gImageProviderCount));
      this = CGImageProviderRelease();
    }
    *(_BYTE *)(v1 + 192) &= ~0x40u;
    *(_QWORD *)(v1 + 144) = 0;
    *(_QWORD *)(v1 + 152) = 0;
  }
  return this;
}

_QWORD *CGImageMetadataTagKeyCreate(const __CFString *a1, const __CFString *a2)
{
  CFTypeID v4;
  CFTypeID TypeID;
  _QWORD *v6;
  CFTypeID v7;
  const __CFAllocator *v8;

  if (!a1)
    return 0;
  v4 = CFGetTypeID(a1);
  TypeID = CFStringGetTypeID();
  v6 = 0;
  if (!a2 || v4 != TypeID)
    return v6;
  v7 = CFGetTypeID(a2);
  if (v7 != CFStringGetTypeID())
    return 0;
  v6 = malloc_type_malloc(0x18uLL, 0x106004091AC2883uLL);
  if (v6)
  {
    v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    *v6 = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1);
    v6[1] = CFStringCreateCopy(v8, a2);
    *((_DWORD *)v6 + 4) = 1;
  }
  return v6;
}

uint64_t PNGReadPlugin::InitializePluginData(IIOImageReadSession *a1, IIODictionary *this, IIODictionary *a3, CGImageMetadata *a4, CGColorSpace **a5, uint64_t a6, uint64_t a7, __CFDictionary *a8)
{
  char v11;
  uint64_t v12;
  IIOImageRead *v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  float v23;
  double v24;
  unint64_t v25;
  unsigned int *v26;
  int color_type;
  int v28;
  int v29;
  unsigned int v30;
  int v31;
  uint64_t v32;
  unsigned int v33;
  int v34;
  uint64_t v35;
  unsigned int v36;
  int v37;
  uint64_t v38;
  unsigned int v39;
  int v40;
  uint64_t v41;
  int v42;
  unsigned int v43;
  int v44;
  uint64_t v45;
  unsigned int v46;
  int v47;
  uint64_t v48;
  unsigned int v49;
  int v50;
  uint64_t v51;
  unsigned int v52;
  int v53;
  uint64_t v54;
  int v55;
  unsigned int v56;
  int v57;
  uint64_t v58;
  unsigned int v59;
  int v60;
  uint64_t v61;
  unsigned int v62;
  int v63;
  uint64_t v64;
  unsigned int v65;
  int v66;
  uint64_t v67;
  int v68;
  unsigned int v69;
  int v70;
  uint64_t v71;
  unsigned int v72;
  int v73;
  uint64_t v74;
  unsigned int v75;
  int v76;
  uint64_t v77;
  unsigned int v78;
  int v79;
  uint64_t v80;
  int v81;
  unsigned int v82;
  uint64_t v83;
  int v84;
  int v85;
  unsigned int v86;
  int v87;
  uint64_t v88;
  unsigned int v89;
  int v90;
  uint64_t v91;
  unsigned int v92;
  int v93;
  uint64_t v94;
  unsigned int v95;
  int v96;
  uint64_t v97;
  unsigned int channels;
  unsigned int image_width;
  unsigned int image_height;
  uint64_t rowbytes;
  unint64_t v102;
  int v103;
  CFDataRef v104;
  _BOOL4 v105;
  char v106;
  uint64_t v107;
  int v108;
  unsigned int v109;
  int v110;
  uint64_t v111;
  unsigned int v112;
  int v113;
  uint64_t v114;
  unsigned int v115;
  int v116;
  uint64_t v117;
  unsigned int v118;
  int v119;
  uint64_t v120;
  uint64_t v121;
  unsigned int v122;
  int v123;
  uint64_t v124;
  unsigned int v125;
  int v126;
  uint64_t v127;
  unsigned int v128;
  int v129;
  uint64_t v130;
  unsigned int v131;
  unint64_t v132;
  uint64_t v133;
  unint64_t v134;
  _BOOL4 v135;
  unsigned int v136;
  char v138;
  int v139;
  int v140;
  int interlace_type;
  unsigned int x_pixels_per_meter;
  unsigned int y_pixels_per_meter;
  unsigned int v144;
  float v145;
  _BOOL8 valid;
  uint64_t v147;
  float v148;
  IIONumber *v149;
  float pixel_aspect_ratio;
  const void *v151;
  int v152;
  unsigned int v153;
  char v154;
  char v155;
  const __CFDictionary *TopLevelTag;
  const __CFString *v157;
  CFTypeID TypeID;
  int v159;
  CFTypeID v160;
  char v161;
  int v162;
  int v163;
  int v164;
  int v165;
  int v166;
  unsigned int v167;
  int v168;
  uint64_t v169;
  unsigned int v170;
  int v171;
  uint64_t v172;
  unsigned int v173;
  int v174;
  uint64_t v175;
  int v176;
  unsigned int v177;
  char *v178;
  uint64_t v179;
  BOOL v181;
  int v182;
  unint64_t Uint32ForKey;
  unsigned int bit_depth;
  _BOOL4 BoolForKey;
  IIODictionary *v189;
  _BYTE v192[24];
  _BYTE v193[24];
  _BYTE v194[24];
  _BYTE v195[24];
  _BYTE v196[24];
  _BYTE v197[24];
  _BYTE v198[24];
  _BYTE v199[24];
  _BYTE v200[24];
  _BYTE v201[24];
  _BYTE v202[24];
  _BYTE v203[24];
  _BYTE v204[24];
  _BYTE v205[24];
  _BYTE v206[24];
  double v207;
  double v208;
  double v209;
  double v210;
  double v211;
  double v212;
  double v213;
  _BYTE v214[24];
  _BYTE v215[24];
  UInt8 *bytes;
  void *v217;
  void *value;
  double v219;
  _BYTE v220[24];
  _BYTE v221[24];
  _BYTE v222[24];
  _BYTE v223[24];
  _BYTE v224[24];
  _BYTE v225[24];
  _BYTE v226[24];
  _BYTE v227[24];
  unsigned int *v228;
  _QWORD *v229[2];

  v228 = 0;
  v229[0] = 0;
  if (!this)
  {
    v107 = 4294967246;
LABEL_417:
    kdebug_trace();
    return v107;
  }
  if (IIODictionary::containsKey(this, CFSTR("kCGImageSourceCreateUnpremultipliedPNG")))
  {
    if (IIODictionary::getBoolForKey(this, CFSTR("kCGImageSourceCreateUnpremultipliedPNG")))
      v11 = 1;
    else
      v11 = -1;
  }
  else
  {
    v11 = -1;
  }
  v12 = a6;
  *(_BYTE *)(a7 + 72) = v11;
  v182 = IIOSkipMetadata(this);
  IIOSkipXMP_and_IPTC(this);
  *(_BYTE *)(a7 + 28) = 0;
  v189 = this;
  *(_BYTE *)(a7 + 59) = IIODictionary::getBoolForKey(this, CFSTR("IIO_SKIP_APNG_COMPOSING"));
  v13 = IIOImageReadSession::globalInfoForType(a1, 1095781959);
  if (v13)
  {
    *(_BYTE *)(a7 + 30) = 1;
    v16 = *((_QWORD *)v13 + 1) + 34 * *(unsigned int *)(a6 + 24);
    v18 = *(_DWORD *)(v16 + 4);
    v17 = *(_DWORD *)(v16 + 8);
    v20 = *(_DWORD *)(v16 + 12);
    v19 = *(_DWORD *)(v16 + 16);
    v21 = *(unsigned __int8 *)(v16 + 24);
    v22 = *(unsigned __int8 *)(v16 + 25);
    LOWORD(v14) = *(_WORD *)(v16 + 20);
    LOWORD(v15) = *(_WORD *)(v16 + 22);
    v23 = (float)v14 / (float)v15;
    IIONumber::IIONumber((IIONumber *)v227, v23);
    IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v227, CFSTR("UnclampedDelayTime"), CFSTR("{PNG}"));
    IIONumber::~IIONumber((IIONumber *)v227);
    v24 = v23;
    if (v23 < 0.05)
      v24 = 0.05;
    IIONumber::IIONumber((IIONumber *)v226, v24);
    IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v226, CFSTR("DelayTime"), CFSTR("{PNG}"));
    IIONumber::~IIONumber((IIONumber *)v226);
    v12 = a6;
    if (*(_BYTE *)(a7 + 59))
    {
      IIONumber::IIONumber((IIONumber *)v225, v20);
      IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v225, CFSTR("xOffset"), CFSTR("{PNG}"));
      IIONumber::~IIONumber((IIONumber *)v225);
      IIONumber::IIONumber((IIONumber *)v224, v19);
      IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v224, CFSTR("yOffset"), CFSTR("{PNG}"));
      IIONumber::~IIONumber((IIONumber *)v224);
      IIONumber::IIONumber((IIONumber *)v223, v18);
      IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v223, CFSTR("width"), CFSTR("{PNG}"));
      IIONumber::~IIONumber((IIONumber *)v223);
      IIONumber::IIONumber((IIONumber *)v222, v17);
      IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v222, CFSTR("height"), CFSTR("{PNG}"));
      IIONumber::~IIONumber((IIONumber *)v222);
      IIONumber::IIONumber((IIONumber *)v221, v21);
      IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v221, CFSTR("disposeOp"), CFSTR("{PNG}"));
      IIONumber::~IIONumber((IIONumber *)v221);
      IIONumber::IIONumber((IIONumber *)v220, v22);
      IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v220, CFSTR("blendOp"), CFSTR("{PNG}"));
      IIONumber::~IIONumber((IIONumber *)v220);
    }
  }
  v25 = *(_QWORD *)(v12 + 8);
  if (v25)
    IIOImageReadSession::seek(a1, v25, 0);
  if (IIODictionary::containsKey(v189, CFSTR("kCGImageSourceSubsampleFactor")))
    Uint32ForKey = IIODictionary::getUint32ForKey(v189, CFSTR("kCGImageSourceSubsampleFactor"));
  else
    Uint32ForKey = 0;
  v229[0] = _cg_png_create_read_struct("1.6.43", 0, (uint64_t)handle_error, (uint64_t)handle_warning);
  if (!v229[0])
  {
    v107 = 4294967246;
    goto LABEL_417;
  }
  if (IIODictionary::containsKey(v189, CFSTR("kCGImageSourceSkipCRC")))
    BoolForKey = IIODictionary::getBoolForKey(v189, CFSTR("kCGImageSourceSkipCRC"));
  else
    BoolForKey = 0;
  if (IIODictionary::containsKey(v189, CFSTR("kCGImageSourceDisableParallelDecode")))
    v181 = IIODictionary::getBoolForKey(v189, CFSTR("kCGImageSourceDisableParallelDecode"));
  else
    v181 = 0;
  if (BoolForKey)
    _cg_png_set_crc_action((uint64_t)v229[0], 4, 4);
  _cg_png_create_info_struct((uint64_t)v229[0]);
  v228 = v26;
  if (!v26)
    goto LABEL_185;
  _cg_png_set_read_fn(v229[0], (uint64_t)a1, (size_t (*)(size_t, void *, size_t))pngReadCallback);
  _cg_png_set_option((uint64_t)v229[0], 2u, 3);
  _cg_png_set_benign_errors((uint64_t)v229[0], 1);
  *(_DWORD *)(a7 + 40) = 0;
  _cg_png_set_keep_unknown_chunks_sized((uint64_t)v229[0], 3u, "CgBI", 4);
  *(_BYTE *)(a7 + 56) = 0;
  _cg_png_set_read_user_chunk_fn((uint64_t)v229[0], a7, (uint64_t)PNGReadPlugin::Read_user_chunk_callback);
  _cg_png_read_info((uLong)v229[0], v228);
  PNGReadPlugin::Validate_png_info((uint64_t)v229[0], (uint64_t)v228, a7);
  bit_depth = _cg_png_get_bit_depth((uint64_t)v229[0], (uint64_t)v228);
  if (*(_BYTE *)(a7 + 30))
    *(_BYTE *)(a7 + 31) = _cg_png_get_first_frame_is_hidden((uint64_t)v229[0]) != 0;
  *(_BYTE *)(a7 + 20) = _cg_png_set_interlace_handling((uint64_t)v229[0]);
  color_type = _cg_png_get_color_type((uint64_t)v229[0], (uint64_t)v228);
  *(_BYTE *)(a7 + 19) = color_type;
  *(_BYTE *)(a7 + 18) = color_type;
  v28 = color_type;
  if (color_type == 3)
  {
    if (!*(_BYTE *)(v12 + 157) || *(_BYTE *)(a7 + 30) || *(_BYTE *)(a7 + 20) == 7)
    {
      *(_BYTE *)(a7 + 32) = 1;
      _cg_png_set_palette_to_rgb((uint64_t)v229[0]);
      if ((gIIODebugFlags & 0x20000) != 0)
      {
        v29 = *(_DWORD *)(v12 + 20);
        v30 = v29 >> 24;
        if (v29 < 0)
        {
          v31 = __maskrune(v30, 0x40000uLL);
          v29 = *(_DWORD *)(v12 + 20);
          v30 = v29 >> 24;
        }
        else
        {
          v31 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v30 + 60) & 0x40000;
        }
        if (v31)
          v32 = v30;
        else
          v32 = 46;
        v33 = v29 << 8 >> 24;
        if (v29 << 8 < 0)
        {
          v34 = __maskrune(v33, 0x40000uLL);
          v29 = *(_DWORD *)(v12 + 20);
          v33 = v29 << 8 >> 24;
        }
        else
        {
          v34 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v33 + 60) & 0x40000;
        }
        if (v34)
          v35 = v33;
        else
          v35 = 46;
        v36 = (__int16)v29 >> 8;
        if (v29 << 16 < 0)
        {
          v37 = __maskrune(v36, 0x40000uLL);
          v29 = *(_DWORD *)(v12 + 20);
          v36 = (__int16)v29 >> 8;
        }
        else
        {
          v37 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v36 + 60) & 0x40000;
        }
        if (v37)
          v38 = v36;
        else
          v38 = 46;
        v39 = (char)v29;
        if ((v29 << 24) <= 0x7F000000)
        {
          v40 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v29 + 60) & 0x40000;
        }
        else
        {
          v40 = __maskrune((char)v29, 0x40000uLL);
          v39 = *(char *)(v12 + 20);
        }
        if (v40)
          v41 = v39;
        else
          v41 = 46;
        ImageIOLog("♦️  '%c%c%c%c' %d: png_set_palette_to_rgb\n", v32, v35, v38, v41, 1816);
      }
      _cg_png_set_add_alpha((uint64_t)v229[0], 255, 0);
      if ((gIIODebugFlags & 0x20000) != 0)
      {
        v42 = *(_DWORD *)(v12 + 20);
        v43 = v42 >> 24;
        if (v42 < 0)
        {
          v44 = __maskrune(v43, 0x40000uLL);
          v42 = *(_DWORD *)(v12 + 20);
          v43 = v42 >> 24;
        }
        else
        {
          v44 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v43 + 60) & 0x40000;
        }
        if (v44)
          v45 = v43;
        else
          v45 = 46;
        v46 = v42 << 8 >> 24;
        if (v42 << 8 < 0)
        {
          v47 = __maskrune(v46, 0x40000uLL);
          v42 = *(_DWORD *)(v12 + 20);
          v46 = v42 << 8 >> 24;
        }
        else
        {
          v47 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v46 + 60) & 0x40000;
        }
        if (v47)
          v48 = v46;
        else
          v48 = 46;
        v49 = (__int16)v42 >> 8;
        if (v42 << 16 < 0)
        {
          v50 = __maskrune(v49, 0x40000uLL);
          v42 = *(_DWORD *)(v12 + 20);
          v49 = (__int16)v42 >> 8;
        }
        else
        {
          v50 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v49 + 60) & 0x40000;
        }
        if (v50)
          v51 = v49;
        else
          v51 = 46;
        v52 = (char)v42;
        if ((v42 << 24) <= 0x7F000000)
        {
          v53 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v42 + 60) & 0x40000;
        }
        else
        {
          v53 = __maskrune((char)v42, 0x40000uLL);
          v52 = *(char *)(v12 + 20);
        }
        if (v53)
          v54 = v52;
        else
          v54 = 46;
        ImageIOLog("♦️  '%c%c%c%c' %d: png_set_add_alpha: PNG_FILLER_BEFORE\n", v45, v48, v51, v54, 1818);
      }
      *(_BYTE *)(a7 + 27) = 1;
    }
    if (*(_WORD *)(v12 + 58) == 24)
    {
      _cg_png_set_add_alpha((uint64_t)v229[0], 255, 0);
      if ((gIIODebugFlags & 0x20000) != 0)
      {
        v55 = *(_DWORD *)(v12 + 20);
        v56 = v55 >> 24;
        if (v55 < 0)
        {
          v57 = __maskrune(v56, 0x40000uLL);
          v55 = *(_DWORD *)(v12 + 20);
          v56 = v55 >> 24;
        }
        else
        {
          v57 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v56 + 60) & 0x40000;
        }
        if (v57)
          v58 = v56;
        else
          v58 = 46;
        v59 = v55 << 8 >> 24;
        if (v55 << 8 < 0)
        {
          v60 = __maskrune(v59, 0x40000uLL);
          v55 = *(_DWORD *)(v12 + 20);
          v59 = v55 << 8 >> 24;
        }
        else
        {
          v60 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v59 + 60) & 0x40000;
        }
        if (v60)
          v61 = v59;
        else
          v61 = 46;
        v62 = (__int16)v55 >> 8;
        if (v55 << 16 < 0)
        {
          v63 = __maskrune(v62, 0x40000uLL);
          v55 = *(_DWORD *)(v12 + 20);
          v62 = (__int16)v55 >> 8;
        }
        else
        {
          v63 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v62 + 60) & 0x40000;
        }
        if (v63)
          v64 = v62;
        else
          v64 = 46;
        v65 = (char)v55;
        if ((v55 << 24) <= 0x7F000000)
        {
          v66 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v55 + 60) & 0x40000;
        }
        else
        {
          v66 = __maskrune((char)v55, 0x40000uLL);
          v65 = *(char *)(v12 + 20);
        }
        if (v66)
          v67 = v65;
        else
          v67 = 46;
        ImageIOLog("♦️  '%c%c%c%c' %d: png_set_add_alpha: PNG_FILLER_BEFORE\n", v58, v61, v64, v67, 1824);
      }
      *(_BYTE *)(a7 + 27) = 1;
    }
    v28 = *(unsigned __int8 *)(a7 + 19);
  }
  if (!v28 && _cg_png_get_bit_depth((uint64_t)v229[0], (uint64_t)v228) <= 7)
  {
    _cg_png_set_expand_gray_1_2_4_to_8((uint64_t)v229[0]);
    if ((gIIODebugFlags & 0x20000) != 0)
    {
      v68 = *(_DWORD *)(v12 + 20);
      v69 = v68 >> 24;
      if (v68 < 0)
      {
        v70 = __maskrune(v69, 0x40000uLL);
        v68 = *(_DWORD *)(v12 + 20);
        v69 = v68 >> 24;
      }
      else
      {
        v70 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v69 + 60) & 0x40000;
      }
      if (v70)
        v71 = v69;
      else
        v71 = 46;
      v72 = v68 << 8 >> 24;
      if (v68 << 8 < 0)
      {
        v73 = __maskrune(v72, 0x40000uLL);
        v68 = *(_DWORD *)(v12 + 20);
        v72 = v68 << 8 >> 24;
      }
      else
      {
        v73 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v72 + 60) & 0x40000;
      }
      if (v73)
        v74 = v72;
      else
        v74 = 46;
      v75 = (__int16)v68 >> 8;
      if (v68 << 16 < 0)
      {
        v76 = __maskrune(v75, 0x40000uLL);
        v68 = *(_DWORD *)(v12 + 20);
        v75 = (__int16)v68 >> 8;
      }
      else
      {
        v76 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v75 + 60) & 0x40000;
      }
      if (v76)
        v77 = v75;
      else
        v77 = 46;
      v78 = (char)v68;
      if ((v68 << 24) <= 0x7F000000)
      {
        v79 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v68 + 60) & 0x40000;
      }
      else
      {
        v79 = __maskrune((char)v68, 0x40000uLL);
        v78 = *(char *)(v12 + 20);
      }
      if (v79)
        v80 = v78;
      else
        v80 = 46;
      ImageIOLog("♦️  '%c%c%c%c' %d: png_set_expand_gray_1_2_4_to_8\n", v71, v74, v77, v80, 1834);
    }
  }
  if (_cg_png_get_valid((uint64_t)v229[0], (uint64_t)v228, 0x10u))
  {
    _cg_png_set_palette_to_rgb((uint64_t)v229[0]);
    if ((gIIODebugFlags & 0x20000) != 0)
    {
      v81 = *(_DWORD *)(v12 + 20);
      v82 = v81 >> 24;
      v83 = MEMORY[0x1E0C80978];
      if (v81 < 0)
      {
        v84 = __maskrune(v82, 0x40000uLL);
        v81 = *(_DWORD *)(v12 + 20);
        v82 = v81 >> 24;
      }
      else
      {
        v84 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v82 + 60) & 0x40000;
      }
      if (v84)
        v88 = v82;
      else
        v88 = 46;
      v89 = v81 << 8 >> 24;
      if (v81 << 8 < 0)
      {
        v90 = __maskrune(v89, 0x40000uLL);
        v81 = *(_DWORD *)(v12 + 20);
        v89 = v81 << 8 >> 24;
      }
      else
      {
        v90 = *(_DWORD *)(v83 + 4 * v89 + 60) & 0x40000;
      }
      if (v90)
        v91 = v89;
      else
        v91 = 46;
      v92 = (__int16)v81 >> 8;
      if (v81 << 16 < 0)
      {
        v93 = __maskrune(v92, 0x40000uLL);
        v81 = *(_DWORD *)(v12 + 20);
        v92 = (__int16)v81 >> 8;
      }
      else
      {
        v93 = *(_DWORD *)(v83 + 4 * v92 + 60) & 0x40000;
      }
      if (v93)
        v94 = v92;
      else
        v94 = 46;
      v95 = (char)v81;
      if ((v81 << 24) <= 0x7F000000)
      {
        v96 = *(_DWORD *)(v83 + 4 * (char)v81 + 60) & 0x40000;
      }
      else
      {
        v96 = __maskrune((char)v81, 0x40000uLL);
        v95 = *(char *)(v12 + 20);
      }
      if (v96)
        v97 = v95;
      else
        v97 = 46;
      ImageIOLog("♦️  '%c%c%c%c' %d: png_set_tRNS_to_alpha\n", v88, v91, v94, v97, 1842);
    }
    *(_BYTE *)(a7 + 28) = 1;
  }
  else if (*(_BYTE *)(a7 + 30) && (*(_BYTE *)(a7 + 18) & 0xFE) == 2)
  {
    _cg_png_set_add_alpha((uint64_t)v229[0], 255, 0);
    if ((gIIODebugFlags & 0x20000) != 0)
    {
      v85 = *(_DWORD *)(v12 + 20);
      v86 = v85 >> 24;
      if (v85 < 0)
      {
        v87 = __maskrune(v86, 0x40000uLL);
        v85 = *(_DWORD *)(v12 + 20);
        v86 = v85 >> 24;
      }
      else
      {
        v87 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v86 + 60) & 0x40000;
      }
      if (v87)
        v111 = v86;
      else
        v111 = 46;
      v112 = v85 << 8 >> 24;
      if (v85 << 8 < 0)
      {
        v113 = __maskrune(v112, 0x40000uLL);
        v85 = *(_DWORD *)(v12 + 20);
        v112 = v85 << 8 >> 24;
      }
      else
      {
        v113 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v112 + 60) & 0x40000;
      }
      if (v113)
        v114 = v112;
      else
        v114 = 46;
      v115 = (__int16)v85 >> 8;
      if (v85 << 16 < 0)
      {
        v116 = __maskrune(v115, 0x40000uLL);
        v85 = *(_DWORD *)(v12 + 20);
        v115 = (__int16)v85 >> 8;
      }
      else
      {
        v116 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v115 + 60) & 0x40000;
      }
      if (v116)
        v117 = v115;
      else
        v117 = 46;
      v118 = (char)v85;
      if ((v85 << 24) <= 0x7F000000)
      {
        v119 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v85 + 60) & 0x40000;
      }
      else
      {
        v119 = __maskrune((char)v85, 0x40000uLL);
        v118 = *(char *)(v12 + 20);
      }
      if (v119)
        v120 = v118;
      else
        v120 = 46;
      ImageIOLog("♦️  '%c%c%c%c' %d: png_set_add_alpha: PNG_FILLER_BEFORE\n", v111, v114, v117, v120, 1850);
    }
    *(_BYTE *)(a7 + 27) = 1;
  }
  _cg_png_read_update_info((uint64_t)v229[0], v228);
  channels = _cg_png_get_channels((uint64_t)v229[0], (uint64_t)v228);
  *(_BYTE *)(a7 + 18) = _cg_png_get_color_type((uint64_t)v229[0], (uint64_t)v228);
  image_width = _cg_png_get_image_width((uint64_t)v229[0], v228);
  image_height = _cg_png_get_image_height((uint64_t)v229[0], (uint64_t)v228);
  rowbytes = _cg_png_get_rowbytes((uint64_t)v229[0], (uint64_t)v228);
  v102 = ImageIOAlignRowBytes(rowbytes, 0x10uLL);
  if (image_width > 0x30D40 || image_height > 0x30D40)
  {
    LogError("InitializePluginData", 1868, "image too large (%ld x %ld)\n", image_width, image_height);
    goto LABEL_185;
  }
  v103 = v102;
  if (color_type != 3)
  {
    if (v102 * image_height <= 10000 * *(_QWORD *)v12)
    {
      v105 = a8 != 0;
      goto LABEL_190;
    }
    LogError("InitializePluginData", 1878, "image (%ld x %ld) too large (b = %ld  bpr=%ld fs = %ld\n", image_width, image_height, v102 * image_height, v102, *(_QWORD *)v12);
LABEL_185:
    v106 = 0;
    v107 = 4294967246;
    goto LABEL_414;
  }
  if (a8)
  {
    CFDictionarySetValue(a8, CFSTR("kImageIOInfoHeader_originalIsIndexed"), (const void *)*MEMORY[0x1E0C9AE50]);
    bytes = 0;
    LODWORD(v219) = 0;
    _cg_png_get_PLTE((uint64_t)v229[0], (uint64_t)v228, &bytes, &v219);
    if (LODWORD(v219))
    {
      v104 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], bytes, 3 * SLODWORD(v219));
      if (v104)
      {
        CFDictionarySetValue(a8, CFSTR("kImageIOInfoHeader_originalIndexedColorMap"), v104);
        CFRelease(v104);
      }
    }
    v105 = 1;
  }
  else
  {
    v105 = 0;
  }
LABEL_190:
  *(_DWORD *)(v12 + 44) = image_width;
  *(_DWORD *)(v12 + 48) = image_height;
  *(_DWORD *)(v12 + 52) = v103;
  *(_WORD *)(v12 + 56) = bit_depth;
  *(_WORD *)(v12 + 60) = channels;
  *(_WORD *)(v12 + 58) = channels * bit_depth;
  if ((*(_BYTE *)(a7 + 18) & 2) != 0 && bit_depth == 8)
  {
    if (channels <= 3)
    {
      _cg_png_set_add_alpha((uint64_t)v229[0], 255, 1);
      if ((gIIODebugFlags & 0x20000) != 0)
      {
        v108 = *(_DWORD *)(v12 + 20);
        v109 = v108 >> 24;
        if (v108 < 0)
        {
          v110 = __maskrune(v109, 0x40000uLL);
          v108 = *(_DWORD *)(v12 + 20);
          v109 = v108 >> 24;
        }
        else
        {
          v110 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v109 + 60) & 0x40000;
        }
        if (v110)
          v121 = v109;
        else
          v121 = 46;
        v122 = v108 << 8 >> 24;
        if (v108 << 8 < 0)
        {
          v123 = __maskrune(v122, 0x40000uLL);
          v108 = *(_DWORD *)(v12 + 20);
          v122 = v108 << 8 >> 24;
        }
        else
        {
          v123 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v122 + 60) & 0x40000;
        }
        if (v123)
          v124 = v122;
        else
          v124 = 46;
        v125 = (__int16)v108 >> 8;
        if (v108 << 16 < 0)
        {
          v126 = __maskrune(v125, 0x40000uLL);
          v108 = *(_DWORD *)(v12 + 20);
          v125 = (__int16)v108 >> 8;
        }
        else
        {
          v126 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v125 + 60) & 0x40000;
        }
        if (v126)
          v127 = v125;
        else
          v127 = 46;
        v128 = (char)v108;
        if ((v108 << 24) <= 0x7F000000)
        {
          v129 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v108 + 60) & 0x40000;
        }
        else
        {
          v129 = __maskrune((char)v108, 0x40000uLL);
          v128 = *(char *)(v12 + 20);
        }
        if (v129)
          v130 = v128;
        else
          v130 = 46;
        ImageIOLog("♦️  '%c%c%c%c' %d: png_set_add_alpha: PNG_FILLER_AFTER\n", v121, v124, v127, v130, 1915);
      }
      *(_BYTE *)(a7 + 27) = 1;
      *(_DWORD *)(v12 + 88) = 2097160;
      channels = 4;
      *(_WORD *)(v12 + 92) = 4;
    }
    *(_BYTE *)(v12 + 95) = 0;
  }
  *(_BYTE *)(a7 + 29) = BoolForKey;
  v131 = 1;
  *(_WORD *)(v12 + 132) = 1;
  if (image_width >= (unint64_t)image_height)
    v132 = image_height;
  else
    v132 = image_width;
  if (Uint32ForKey > v132)
  {
    v133 = 1;
LABEL_250:
    Uint32ForKey = v133;
    goto LABEL_277;
  }
  if (Uint32ForKey < 2)
  {
    if (*(unsigned __int8 *)(v12 + 32) < 2u)
    {
      v131 = 1;
      goto LABEL_277;
    }
    v134 = *(unsigned int *)(v12 + 28);
    if ((_DWORD)v134
      && ((v131 = 32, v134 < (unint64_t)image_width >> 5)
       || (unint64_t)image_height >> 5 > v134
       || (v131 = 16, v134 < (unint64_t)image_width >> 4)
       || (unint64_t)image_height >> 4 > v134
       || (v131 = 8, v134 < (unint64_t)image_width >> 3)
       || (unint64_t)image_height >> 3 > v134
       || (v131 = 4, v134 < (unint64_t)image_width >> 2)
       || (unint64_t)image_height >> 2 > v134
       || (v131 = 2, v134 < (unint64_t)image_width >> 1)
       || (unint64_t)image_height >> 1 > v134))
    {
      *(_WORD *)(v12 + 132) = v131;
    }
    else
    {
      v131 = 1;
    }
    if (*(_DWORD *)(v12 + 48) > v131)
    {
      v133 = v131;
      goto LABEL_250;
    }
    v131 = 1;
  }
  else if (Uint32ForKey < 0x80)
  {
    if (Uint32ForKey < 0x40)
    {
      if (Uint32ForKey < 0x20)
      {
        if (Uint32ForKey < 0x10)
        {
          if (Uint32ForKey < 8)
          {
            if (Uint32ForKey < 4)
              v131 = 2;
            else
              v131 = 4;
          }
          else
          {
            v131 = 8;
          }
        }
        else
        {
          v131 = 16;
        }
      }
      else
      {
        v131 = 32;
      }
    }
    else
    {
      v131 = 64;
    }
  }
  else
  {
    v131 = 128;
  }
  *(_WORD *)(v12 + 132) = v131;
LABEL_277:
  v135 = (*(unsigned __int8 *)(a7 + 30) | BYTE4(gIIODebugFlags) & 1) == 0;
  if (*(_BYTE *)(a7 + 18) == 3)
    goto LABEL_285;
  if (*(unsigned __int8 *)(a7 + 20) > 1u)
    goto LABEL_285;
  v136 = *(unsigned __int16 *)(v12 + 56);
  if (v136 != 8 && v136 != 16)
    goto LABEL_285;
  if (Uint32ForKey <= 1)
    v135 = 0;
  if (v135)
  {
    *(_DWORD *)(v12 + 76) = image_width / v131;
    *(_DWORD *)(v12 + 80) = image_height / v131;
    *(_DWORD *)(v12 + 84) = image_width / v131 * channels * (v136 >> 3);
  }
  else
  {
LABEL_285:
    *(_WORD *)(v12 + 132) = 1;
  }
  *(_BYTE *)(v12 + 160) = 0;
  *(_BYTE *)(v12 + 162) = 0;
  if (a5)
  {
    v219 = 0.0;
    *a5 = PNGReadPlugin::Get_colorspace(v12, a7, (uint64_t)v229[0], (uint64_t)v228, &v219);
    if (v219 != 0.0 && v105)
    {
      IIONumber::IIONumber((IIONumber *)&bytes, v219);
      CFDictionarySetValue(a8, CFSTR("kImageIOInfoHeader_gammaValue"), value);
      IIONumber::~IIONumber((IIONumber *)&bytes);
    }
  }
  v138 = *(_BYTE *)(a7 + 18);
  if (*(_BYTE *)(a7 + 35) && (*(_BYTE *)(a7 + 18) & 2) == 0)
    goto LABEL_185;
  switch(*(_BYTE *)(a7 + 18))
  {
    case 0:
      goto LABEL_303;
    case 2:
      *(_BYTE *)(v12 + 62) = 0;
      if (*(_WORD *)(v12 + 58) == 8 && *(_WORD *)(v12 + 56) == 8)
        *(_QWORD *)(v12 + 88) = 0x5000400200008;
      goto LABEL_320;
    case 3:
      if (*(_BYTE *)(a7 + 30) || *(_BYTE *)(a7 + 38))
        *(_BYTE *)(v12 + 62) = 5;
      else
        *(_BYTE *)(v12 + 62) = 0;
      goto LABEL_320;
    case 4:
      v138 = 3;
LABEL_303:
      *(_BYTE *)(v12 + 62) = v138;
      *(_BYTE *)(v12 + 94) = v138;
      *(_DWORD *)(v12 + 140) = 1196573017;
      goto LABEL_324;
    case 6:
      if (*(_BYTE *)(a7 + 35))
      {
        v140 = *(_DWORD *)(a7 + 40) & 0x1F;
        switch(v140)
        {
          case 2:
            LOBYTE(v140) = 1;
            break;
          case 6:
            LOBYTE(v140) = 5;
            break;
          case 4:
            LOBYTE(v140) = 3;
            break;
        }
        *(_BYTE *)(v12 + 62) = v140;
        *(_WORD *)(v12 + 63) = 0;
        *(_BYTE *)(v12 + 65) = 0;
      }
      else
      {
        if (*(_BYTE *)(a7 + 72) == 1 || *(_WORD *)(v12 + 56) != 8)
          LOBYTE(v140) = 3;
        else
          LOBYTE(v140) = 1;
        *(_BYTE *)(v12 + 62) = v140;
      }
      *(_BYTE *)(v12 + 94) = v140;
LABEL_320:
      *(_DWORD *)(v12 + 140) = 1380401696;
      v139 = 1380401696;
      break;
    default:
      v139 = *(_DWORD *)(v12 + 140);
      break;
  }
  if (v139 == 1380401696 && channels >= 3)
    *(_BYTE *)(a7 + 34) = 1;
LABEL_324:
  if (_cg_png_get_valid((uint64_t)v229[0], (uint64_t)v228, 1u))
  {
    _cg_png_get_gAMA((uint64_t)v229[0], (uint64_t)v228, (double *)(a7 + 8));
    IIONumber::IIONumber((IIONumber *)v215, *(double *)(a7 + 8));
    IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v215, CFSTR("Gamma"), CFSTR("{PNG}"));
    IIONumber::~IIONumber((IIONumber *)v215);
  }
  if (_cg_png_get_valid((uint64_t)v229[0], (uint64_t)v228, 0x800u))
  {
    LODWORD(bytes) = 0;
    _cg_png_get_sRGB((uint64_t)v229[0], (uint64_t)v228, &bytes);
    IIONumber::IIONumber((IIONumber *)v214, (int)bytes);
    IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v214, CFSTR("sRGBIntent"), CFSTR("{PNG}"));
    IIONumber::~IIONumber((IIONumber *)v214);
  }
  if (_cg_png_get_valid((uint64_t)v229[0], (uint64_t)v228, 4u))
  {
    v219 = 0.0;
    v213 = 0.0;
    v212 = 0.0;
    v211 = 0.0;
    v210 = 0.0;
    v208 = 0.0;
    v209 = 0.0;
    v207 = 0.0;
    _cg_png_get_cHRM((uint64_t)v229[0], (uint64_t)v228, &v219, &v213, &v212, &v211, &v210, &v209, &v208, &v207);
    v217 = 0;
    bytes = 0;
    value = 0;
    IIOArray::IIOArray((IIOArray *)&bytes);
    IIONumber::IIONumber((IIONumber *)v206, v219);
    IIOArray::addObject((CFMutableArrayRef *)&bytes, (uint64_t)v206);
    IIONumber::~IIONumber((IIONumber *)v206);
    IIONumber::IIONumber((IIONumber *)v205, v213);
    IIOArray::addObject((CFMutableArrayRef *)&bytes, (uint64_t)v205);
    IIONumber::~IIONumber((IIONumber *)v205);
    IIONumber::IIONumber((IIONumber *)v204, v212);
    IIOArray::addObject((CFMutableArrayRef *)&bytes, (uint64_t)v204);
    IIONumber::~IIONumber((IIONumber *)v204);
    IIONumber::IIONumber((IIONumber *)v203, v211);
    IIOArray::addObject((CFMutableArrayRef *)&bytes, (uint64_t)v203);
    IIONumber::~IIONumber((IIONumber *)v203);
    IIONumber::IIONumber((IIONumber *)v202, v210);
    IIOArray::addObject((CFMutableArrayRef *)&bytes, (uint64_t)v202);
    IIONumber::~IIONumber((IIONumber *)v202);
    IIONumber::IIONumber((IIONumber *)v201, v209);
    IIOArray::addObject((CFMutableArrayRef *)&bytes, (uint64_t)v201);
    IIONumber::~IIONumber((IIONumber *)v201);
    IIONumber::IIONumber((IIONumber *)v200, v208);
    IIOArray::addObject((CFMutableArrayRef *)&bytes, (uint64_t)v200);
    IIONumber::~IIONumber((IIONumber *)v200);
    IIONumber::IIONumber((IIONumber *)v199, v207);
    IIOArray::addObject((CFMutableArrayRef *)&bytes, (uint64_t)v199);
    IIONumber::~IIONumber((IIONumber *)v199);
    IIODictionary::setObjectForKeyGroup(a3, v217, CFSTR("Chromaticities"), CFSTR("{PNG}"));
    IIOArray::~IIOArray((IIOArray *)&bytes);
  }
  interlace_type = _cg_png_get_interlace_type((uint64_t)v229[0], (uint64_t)v228);
  IIONumber::IIONumber((IIONumber *)v198, interlace_type);
  IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v198, CFSTR("InterlaceType"), CFSTR("{PNG}"));
  IIONumber::~IIONumber((IIONumber *)v198);
  x_pixels_per_meter = _cg_png_get_x_pixels_per_meter((uint64_t)v229[0], (uint64_t)v228);
  y_pixels_per_meter = _cg_png_get_y_pixels_per_meter((uint64_t)v229[0], (uint64_t)v228);
  if (x_pixels_per_meter && (v144 = y_pixels_per_meter) != 0)
  {
    IIONumber::IIONumber((IIONumber *)v197, x_pixels_per_meter);
    IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v197, CFSTR("XPixelsPerMeter"), CFSTR("{PNG}"));
    IIONumber::~IIONumber((IIONumber *)v197);
    IIONumber::IIONumber((IIONumber *)v196, v144);
    IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v196, CFSTR("YPixelsPerMeter"), CFSTR("{PNG}"));
    IIONumber::~IIONumber((IIONumber *)v196);
    v145 = roundf((float)x_pixels_per_meter * 0.0254);
    valid = ValidDPI(v145);
    if (!valid)
      goto LABEL_338;
    v148 = roundf((float)v144 * 0.0254);
    valid = ValidDPI(v148);
    if (!valid)
      goto LABEL_338;
    IIONumber::IIONumber((IIONumber *)v195, v145);
    IIODictionary::setObjectForKey((uint64_t)a3, (uint64_t)v195, CFSTR("DPIWidth"));
    IIONumber::~IIONumber((IIONumber *)v195);
    IIONumber::IIONumber((IIONumber *)v194, v148);
    v149 = (IIONumber *)v194;
    IIODictionary::setObjectForKey((uint64_t)a3, (uint64_t)v194, CFSTR("DPIHeight"));
  }
  else
  {
    pixel_aspect_ratio = _cg_png_get_pixel_aspect_ratio((uint64_t)v229[0], (uint64_t)v228);
    if (pixel_aspect_ratio <= 0.0)
      goto LABEL_338;
    IIONumber::IIONumber((IIONumber *)v193, pixel_aspect_ratio);
    v149 = (IIONumber *)v193;
    IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v193, CFSTR("PixelAspectRatio"), CFSTR("{PNG}"));
  }
  IIONumber::~IIONumber(v149);
LABEL_338:
  if (v182)
    PNGReadPlugin::AddOrientationToMetadata(valid, v147, a4, (uint64_t)v229[0], (uint64_t)v228);
  else
    PNGReadPlugin::HandlePNGMetadata(v189, a3, a4, (uint64_t)v229[0], (uint64_t)v228);
  if (IIODictionary::containsKey(v189, CFSTR("kCGImageSourceAddPencilKitPrivateData")))
  {
    v151 = *(const void **)(a7 + 64);
    if (v151)
      IIODictionary::setObjectForKeyGroup(a3, v151, CFSTR("PencilKitPrivateData"), CFSTR("{PNG}"));
  }
  _cg_png_destroy_read_struct((uint64_t *)v229, (void **)&v228, 0);
  v229[0] = 0;
  v152 = *(unsigned __int16 *)(v12 + 58);
  v153 = *(unsigned __int16 *)(v12 + 56);
  if (v152 == 32 && v153 == 8)
  {
    if (*(_BYTE *)(v12 + 62) == 3)
    {
      v154 = 3;
      if (!*(_BYTE *)(a7 + 30) && *(_BYTE *)(a7 + 72) != 1)
      {
        if ((*(_DWORD *)(a7 + 40) & 0x1Fu) - 1 < 2)
          v154 = 1;
        else
          v154 = 3;
      }
      *(_BYTE *)(v12 + 62) = v154;
      *(_BYTE *)(v12 + 63) = 0;
      goto LABEL_364;
    }
    if (*(_BYTE *)(a7 + 19) == 3)
    {
LABEL_360:
      *(_BYTE *)(a7 + 26) = 1;
      goto LABEL_364;
    }
  }
  else
  {
    if (*(_BYTE *)(a7 + 19) == 3)
      goto LABEL_360;
    if (v152 == 24)
    {
      if (*(_BYTE *)(v12 + 157))
        v155 = 5;
      else
        v155 = 3;
      *(_BYTE *)(v12 + 94) = v155;
      *(_BYTE *)(v12 + 95) = 0;
      goto LABEL_364;
    }
    if (v153 == 16)
    {
      *(_BYTE *)(v12 + 63) = 1;
      *(_BYTE *)(v12 + 95) = 1;
      goto LABEL_364;
    }
  }
  if (!*(_BYTE *)(v12 + 157))
  {
    v159 = *(unsigned __int8 *)(a7 + 18);
    if (*(_BYTE *)(a7 + 18))
    {
      if (v159 == 2)
      {
        if (v153 > 7)
          goto LABEL_364;
      }
      else if (v159 != 3)
      {
        goto LABEL_364;
      }
      *(_BYTE *)(a7 + 26) = 1;
      *(_DWORD *)(v12 + 52) = 4 * *(_DWORD *)(v12 + 44);
      *(_DWORD *)(v12 + 56) = 2097160;
      *(_WORD *)(v12 + 62) = 1027;
      *(_BYTE *)(a7 + 34) = 1;
      goto LABEL_364;
    }
    if (v153 == 8)
    {
      *(_BYTE *)(a7 + 27) = 1;
      *(_WORD *)(v12 + 58) = 16;
      *(_DWORD *)(v12 + 52) = 2 * *(_DWORD *)(v12 + 44);
    }
    else
    {
      *(_DWORD *)(v12 + 52) = 2 * *(_DWORD *)(v12 + 44);
      *(_DWORD *)(v12 + 56) = 1048584;
    }
    *(_BYTE *)(v12 + 62) = 3;
  }
LABEL_364:
  if (a5)
  {
    if (!*a5 && *(_DWORD *)(v12 + 140) == 1380401696)
    {
      TopLevelTag = CGImageMetadataGetTopLevelTag(a4, (uint64_t)CFSTR("http://ns.adobe.com/exif/1.0/"), (uint64_t)CFSTR("ColorSpace"));
      if (TopLevelTag)
      {
        v157 = (const __CFString *)CGImageMetadataTagGetValue((uint64_t)TopLevelTag);
        if (v157)
        {
          TypeID = CFStringGetTypeID();
          if (TypeID == CFGetTypeID(v157))
          {
            if (CFStringGetIntValue(v157) == 1)
              *a5 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
          }
          else
          {
            v160 = CFNumberGetTypeID();
            if (v160 == CFGetTypeID(v157))
            {
              v217 = 0;
              bytes = 0;
              value = 0;
              IIONumber::IIONumber((IIONumber *)&bytes, (const __CFNumber *)v157);
              if (IIONumber::uint32Num((IIONumber *)&bytes) == 1)
                *a5 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
              IIONumber::~IIONumber((IIONumber *)&bytes);
            }
          }
        }
      }
    }
  }
  *(_QWORD *)(v12 + 176) = 1;
  *(_BYTE *)(a7 + 58) = v181;
  *(_BYTE *)a7 = 1;
  if (*(_BYTE *)(a7 + 30))
  {
    v161 = 3;
LABEL_384:
    *(_BYTE *)a7 = v161;
    goto LABEL_385;
  }
  if (*(_BYTE *)(a7 + 20) == 7)
  {
    v161 = 2;
    goto LABEL_384;
  }
LABEL_385:
  v106 = 1;
  *(_WORD *)(v12 + 192) = 1;
  if (*(unsigned __int16 *)(v12 + 56) != bit_depth)
  {
    IIONumber::IIONumber((IIONumber *)v192, bit_depth);
    IIODictionary::setObjectForKey((uint64_t)a3, (uint64_t)v192, CFSTR("Depth"));
    IIONumber::~IIONumber((IIONumber *)v192);
  }
  *(_BYTE *)(v12 + 166) = 1;
  v162 = *(_BYTE *)(v12 + 97) != 0;
  if ((gIIODebugFlags & 0x20000) != 0)
  {
    v163 = *(unsigned __int8 *)(v12 + 96);
    v164 = *(unsigned __int8 *)(v12 + 95);
    v165 = *(unsigned __int8 *)(v12 + 94);
    v166 = *(_DWORD *)(v12 + 20);
    v167 = v166 >> 24;
    if (v166 < 0)
    {
      v168 = __maskrune(v167, 0x40000uLL);
      v166 = *(_DWORD *)(v12 + 20);
      v167 = v166 >> 24;
    }
    else
    {
      v168 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v167 + 60) & 0x40000;
    }
    if (v168)
      v169 = v167;
    else
      v169 = 46;
    v170 = v166 << 8 >> 24;
    if (v166 << 8 < 0)
    {
      v171 = __maskrune(v170, 0x40000uLL);
      v166 = *(_DWORD *)(v12 + 20);
      v170 = v166 << 8 >> 24;
    }
    else
    {
      v171 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v170 + 60) & 0x40000;
    }
    if (v171)
      v172 = v170;
    else
      v172 = 46;
    v173 = (__int16)v166 >> 8;
    if (v166 << 16 < 0)
    {
      v174 = __maskrune(v173, 0x40000uLL);
      v166 = *(_DWORD *)(v12 + 20);
      v173 = (__int16)v166 >> 8;
    }
    else
    {
      v174 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v173 + 60) & 0x40000;
    }
    if (v174)
      v175 = v173;
    else
      v175 = 46;
    if ((v166 << 24) <= 0x7F000000)
    {
      v176 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v166 + 60) & 0x40000;
    }
    else
    {
      v176 = __maskrune((char)v166, 0x40000uLL);
      v166 = *(_DWORD *)(v12 + 20);
    }
    v177 = (v164 << 12) | (v163 << 16) | (v162 << 8) | v165;
    v178 = IIO_BitmapInfoString(v177);
    if (v176)
      v179 = (char)v166;
    else
      v179 = 46;
    ImageIOLog("♦️  '%c%c%c%c' %d: rpd._createImageProviderWithBitmapInfo 0x%08X  %s\n", v169, v172, v175, v179, 2400, v177, v178);
    v107 = 0;
    v106 = 1;
  }
  else
  {
    v107 = 0;
  }
LABEL_414:
  if (v229[0])
    _cg_png_destroy_read_struct((uint64_t *)v229, (void **)&v228, 0);
  if ((v106 & 1) == 0)
    goto LABEL_417;
  return v107;
}

void sub_187E58828(void *a1)
{
  uint64_t v1;

  __cxa_begin_catch(a1);
  imagePNG_error_break(*(_QWORD *)(v1 - 112));
  __cxa_end_catch();
  JUMPOUT(0x187E58708);
}

void sub_187E589E4()
{
  __cxa_end_catch();
  JUMPOUT(0x187E589A0);
}

uint64_t _cg_png_get_valid(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t result;

  result = 0;
  if (a1 && a2)
  {
    if (a3 == 16 && !*(_WORD *)(a1 + 384))
      return 0;
    else
      return *(_DWORD *)(a2 + 8) & a3;
  }
  return result;
}

void IIONumber::IIONumber(IIONumber *this, double a2)
{
  double valuePtr;

  valuePtr = a2;
  *(_QWORD *)this = &off_1E1BB2F60;
  *((_QWORD *)this + 1) = 13;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 2) = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberDoubleType, &valuePtr);
}

void IIOArray::addObject(CFMutableArrayRef *a1, uint64_t a2)
{
  IIOArray::addObject(a1, *(const void **)(a2 + 16));
}

uint64_t _cg_png_get_color_type(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = 0;
  if (a1)
  {
    if (a2)
      return *(unsigned __int8 *)(a2 + 37);
  }
  return result;
}

uint64_t IIOSkipXMP_and_IPTC(IIODictionary *a1)
{
  uint64_t result;

  if (!IIOMetadataParsingEnabledFlag())
    return 1;
  result = IIOSkipMetadata(a1);
  if (a1)
  {
    if ((result & 1) == 0)
    {
      result = IIODictionary::getBoolForKey(a1, CFSTR("kCGImageSourceSkipXMPMetadata"));
      if ((_DWORD)result)
      {
        if ((gIIODebugFlags & 0x4000000000000) != 0)
        {
          if (IIO_OSAppleInternalBuild())
            ImageIOLog("••• Ⓜ️  kCGImageSourceSkipXMPMetadata --> skipping XMP+IPTC\n");
        }
        return 1;
      }
    }
  }
  return result;
}

uint64_t IIOSkipMetadata(IIODictionary *a1)
{
  uint64_t v2;

  v2 = IIOMetadataParsingEnabledFlag() ^ 1;
  if (a1 && IIODictionary::getBoolForKey(a1, CFSTR("kCGImageSourceSkipMetadata")))
  {
    if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild())
      ImageIOLog("••• Ⓜ️  kCGImageSourceSkipMetadata --> handle minimum metadata only\n");
    return 1;
  }
  return v2;
}

uint64_t IIOMetadataParsingEnabledFlag()
{
  return (gPermissions >> 2) & 1;
}

uint64_t _cg_png_set_benign_errors(uint64_t result, int a2)
{
  int v2;

  if (a2)
    v2 = 7340032;
  else
    v2 = 0;
  *(_DWORD *)(result + 80) = *(_DWORD *)(result + 80) & 0xFF8FFFFF | v2;
  return result;
}

uint64_t _cg_png_set_option(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;

  v3 = 1;
  if (a1 && a2 <= 0xD && (a2 & 1) == 0)
  {
    v4 = 3 << a2;
    if (a3)
      v5 = 3;
    else
      v5 = 2;
    v6 = *(_DWORD *)(a1 + 680);
    *(_DWORD *)(a1 + 680) = v6 & ~v4 | (v5 << a2);
    return (v6 & v4) >> a2;
  }
  return v3;
}

uint64_t _cg_png_get_rowbytes(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = 0;
  if (a1)
  {
    if (a2)
      return *(_QWORD *)(a2 + 16);
  }
  return result;
}

void png_destroy_png_struct(void *__src)
{
  _QWORD v2[136];

  v2[135] = *MEMORY[0x1E0C80C00];
  if (__src)
  {
    memcpy(v2, __src, 0x438uLL);
    bzero(__src, 0x438uLL);
    if (v2[104])
      ((void (*)(_QWORD *, void *))v2[104])(v2, __src);
    else
      free(__src);
  }
}

uint64_t png_read_transform_info(uint64_t result, unsigned int *a2)
{
  int v2;
  int v3;
  char v4;
  unsigned int v5;
  int v7;
  char v8;
  char v9;
  char v10;
  unsigned __int8 v11;
  BOOL v12;
  unint64_t v13;
  unint64_t v14;

  v2 = *(_DWORD *)(result + 88);
  if ((v2 & 0x1000) == 0)
    goto LABEL_7;
  v3 = *((unsigned __int8 *)a2 + 37);
  if (v3 == 3)
  {
    if (*(_WORD *)(result + 384))
      v4 = 6;
    else
      v4 = 2;
    *((_BYTE *)a2 + 37) = v4;
    *((_BYTE *)a2 + 36) = 8;
    *((_WORD *)a2 + 17) = 0;
    if (!*(_QWORD *)(result + 368))
      _cg_png_error((void (**)(void))result, "Palette is NULL in indexed image");
LABEL_7:
    if ((v2 & 0x80) == 0)
      goto LABEL_9;
    goto LABEL_8;
  }
  if ((v2 & 0x2000000) != 0 && *(_WORD *)(result + 384))
    *((_BYTE *)a2 + 37) = v3 | 4;
  if (*((unsigned __int8 *)a2 + 36) <= 7u)
    *((_BYTE *)a2 + 36) = 8;
  *((_WORD *)a2 + 17) = 0;
  if ((v2 & 0x80) != 0)
  {
LABEL_8:
    *((_WORD *)a2 + 105) = *(_WORD *)(result + 420);
    *(_QWORD *)((char *)a2 + 202) = *(_QWORD *)(result + 412);
  }
LABEL_9:
  a2[13] = *(_DWORD *)(result + 1000);
  v5 = *((unsigned __int8 *)a2 + 36);
  if ((v2 & 0x4000400) != 0 && v5 == 16)
  {
    v5 = 8;
    *((_BYTE *)a2 + 36) = 8;
  }
  if ((v2 & 0x4000) != 0)
    *((_BYTE *)a2 + 37) |= 2u;
  if ((v2 & 0x600000) != 0)
    *((_BYTE *)a2 + 37) &= ~2u;
  if ((v2 & 0x40) != 0 && (*((unsigned __int8 *)a2 + 37) | 4) == 6 && *(_QWORD *)(result + 664) && v5 == 8)
  {
    *((_BYTE *)a2 + 37) = 3;
    if ((v2 & 0x200) == 0)
      goto LABEL_28;
  }
  else if ((v2 & 0x200) == 0 || v5 != 8)
  {
LABEL_29:
    if ((v2 & 4) == 0)
      goto LABEL_32;
    goto LABEL_30;
  }
  if (*((_BYTE *)a2 + 37) == 3)
  {
LABEL_28:
    v5 = 8;
    goto LABEL_29;
  }
  v5 = 16;
  *((_BYTE *)a2 + 36) = 16;
  if ((v2 & 4) == 0)
    goto LABEL_32;
LABEL_30:
  if (v5 <= 7)
  {
    LOBYTE(v5) = 8;
    *((_BYTE *)a2 + 36) = 8;
  }
LABEL_32:
  v7 = *((unsigned __int8 *)a2 + 37);
  if (v7 != 3 && (v7 & 2) != 0)
    v8 = 3;
  else
    v8 = 1;
  *((_BYTE *)a2 + 41) = v8;
  if ((v2 & 0x40000) != 0)
  {
    v7 &= ~4u;
    *((_BYTE *)a2 + 37) = v7;
    *((_WORD *)a2 + 17) = 0;
    if ((v7 & 4) == 0)
    {
LABEL_47:
      if ((v2 & 0x8000) == 0)
        goto LABEL_54;
      goto LABEL_51;
    }
  }
  else if ((v7 & 4) == 0)
  {
    goto LABEL_47;
  }
  *((_BYTE *)a2 + 41) = ++v8;
  if ((v2 & 0x8000) == 0)
    goto LABEL_54;
LABEL_51:
  if ((v7 | 2) == 2)
  {
    *((_BYTE *)a2 + 41) = ++v8;
    if ((v2 & 0x1000000) != 0)
      *((_BYTE *)a2 + 37) = v7 | 4;
  }
LABEL_54:
  if ((v2 & 0x100000) != 0)
  {
    v9 = *(_BYTE *)(result + 72);
    if (v9)
    {
      *((_BYTE *)a2 + 36) = v9;
      LOBYTE(v5) = v9;
    }
    v10 = *(_BYTE *)(result + 73);
    if (v10)
    {
      *((_BYTE *)a2 + 41) = v10;
      v8 = v10;
    }
  }
  v11 = v5 * v8;
  *((_BYTE *)a2 + 42) = v5 * v8;
  v12 = (v5 * v8) >= 8u;
  v13 = (*a2 * (unint64_t)(v5 * v8) + 7) >> 3;
  v14 = *a2 * (unint64_t)(v11 >> 3);
  if (!v12)
    v14 = v13;
  *((_QWORD *)a2 + 2) = v14;
  *(_QWORD *)(result + 352) = v14;
  return result;
}

uint64_t _cg_png_set_read_user_chunk_fn(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    *(_QWORD *)(result + 728) = a3;
    *(_QWORD *)(result + 720) = a2;
  }
  return result;
}

void _cg_png_set_keep_unknown_chunks_sized(uint64_t a1, unsigned int a2, const char *a3, int a4)
{
  char *v6;
  int v7;
  const char *v8;
  void (**v9)(void);
  int v10;
  void (**v11)(void);
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  int v15;
  void (**v16)(void);
  int v17;
  void (**v18)(void);
  void (**v19)(void);
  int v20;
  void (**v21)(void);

  if (!a1)
    return;
  if (a2 >= 4)
  {
    v6 = "png_set_keep_unknown_chunks: invalid keep";
LABEL_14:
    png_app_error(a1, v6);
    return;
  }
  v7 = a4;
  if (a4 <= 0)
  {
    *(_DWORD *)(a1 + 736) = a2;
    if (!a4)
      return;
    v7 = 18;
    v8 = "bKGD";
  }
  else
  {
    v8 = a3;
    if (!a3)
    {
      v6 = "png_set_keep_unknown_chunks: no chunk list";
      goto LABEL_14;
    }
  }
  v9 = *(void (***)(void))(a1 + 744);
  if (v9)
    v10 = *(_DWORD *)(a1 + 740);
  else
    v10 = 0;
  if ((v10 + v7) >= 0x33333334)
  {
    v6 = "png_set_keep_unknown_chunks: too many chunks";
    goto LABEL_14;
  }
  if (a2)
  {
    v11 = png_malloc((void (**)(void))a1, (5 * (v10 + v7)));
    v9 = v11;
    if (v10)
      memcpy(v11, *(const void **)(a1 + 744), (5 * v10));
  }
  else if (!v10)
  {
    goto LABEL_40;
  }
  if (!v9)
  {
LABEL_41:
    v17 = 0;
LABEL_42:
    v21 = v9;
    v9 = *(void (***)(void))(a1 + 744);
    goto LABEL_43;
  }
  v12 = 0;
  do
  {
    v13 = &v8[5 * v12];
    v14 = (uint64_t)v9;
    if (v10)
    {
      v14 = (uint64_t)v9 + 5 * (v10 - 1) + 5;
      v15 = v10;
      v16 = v9;
      while (*(_DWORD *)v16 != *(_DWORD *)v13)
      {
        v16 = (void (**)(void))((char *)v16 + 5);
        if (!--v15)
          goto LABEL_25;
      }
      v14 = (uint64_t)v16;
    }
    else
    {
LABEL_25:
      if (!a2)
        goto LABEL_29;
      ++v10;
      *(_DWORD *)v14 = *(_DWORD *)v13;
    }
    *(_BYTE *)(v14 + 4) = a2;
LABEL_29:
    ++v12;
  }
  while (v12 != v7);
  if (v10)
  {
    v17 = 0;
    v18 = v9;
    v19 = v9;
    do
    {
      if (*((_BYTE *)v19 + 4))
      {
        if (v19 != v18)
        {
          v20 = *(_DWORD *)v19;
          *((_BYTE *)v18 + 4) = *((_BYTE *)v19 + 4);
          *(_DWORD *)v18 = v20;
        }
        v18 = (void (**)(void))((char *)v18 + 5);
        ++v17;
      }
      v19 = (void (**)(void))((char *)v19 + 5);
      --v10;
    }
    while (v10);
    if (v17)
      goto LABEL_42;
  }
  if (*(void (***)(void))(a1 + 744) != v9)
  {
    png_free(a1, v9);
LABEL_40:
    v9 = 0;
    goto LABEL_41;
  }
  v21 = 0;
  v17 = 0;
LABEL_43:
  *(_DWORD *)(a1 + 740) = v17;
  if (v9 != v21)
  {
    if (v9)
      png_free(a1, v9);
    *(_QWORD *)(a1 + 744) = v21;
  }
}

uint64_t png_read_start_row(uint64_t a1)
{
  int v2;
  unsigned int v3;
  int v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  int v8;
  int v9;
  int v10;
  unsigned int v11;
  unint64_t v12;
  unint64_t v13;
  size_t v14;
  void (**v15)(void);
  void (**v16)(void);
  unint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t result;
  BOOL v21;
  int v22;
  int v23;
  const char *v24;

  png_init_read_transformations(a1);
  if (*(_BYTE *)(a1 + 388))
  {
    v2 = *(_DWORD *)(a1 + 88);
    v3 = *(_DWORD *)(a1 + 284);
    if ((v2 & 2) == 0)
      v3 = (v3 + 7) >> 3;
    *(_DWORD *)(a1 + 288) = v3;
    v4 = *(_DWORD *)(a1 + 280);
    *(_DWORD *)(a1 + 304) = (v4
                           + png_read_start_row_png_pass_inc[*(unsigned __int8 *)(a1 + 389)]
                           + ~png_read_start_row_png_pass_start[*(unsigned __int8 *)(a1 + 389)])
                          / png_read_start_row_png_pass_inc[*(unsigned __int8 *)(a1 + 389)];
  }
  else
  {
    *(_DWORD *)(a1 + 288) = *(_DWORD *)(a1 + 284);
    v4 = *(_DWORD *)(a1 + 280);
    *(_DWORD *)(a1 + 304) = v4;
    v2 = *(_DWORD *)(a1 + 88);
  }
  v5 = *(unsigned __int8 *)(a1 + 394);
  if ((v2 & 4) != 0 && *(unsigned __int8 *)(a1 + 392) < 8u)
    v5 = 8;
  if ((v2 & 0x1000) == 0)
  {
    if ((v2 & 0x200) != 0)
      *(_DWORD *)(a1 + 88) = v2 & 0xFFFFFDFF;
    goto LABEL_25;
  }
  v6 = *(unsigned __int8 *)(a1 + 391);
  if (!*(_BYTE *)(a1 + 391))
  {
    if (v5 <= 8)
      v5 = 8;
    v5 <<= *(_WORD *)(a1 + 384) != 0;
    goto LABEL_23;
  }
  if (v6 != 2)
  {
    if (v6 == 3)
    {
      if (*(_WORD *)(a1 + 384))
        v5 = 32;
      else
        v5 = 24;
      if ((v2 & 0x200) == 0)
        goto LABEL_25;
LABEL_24:
      v5 <<= *(unsigned __int8 *)(a1 + 392) < 0x10u;
      goto LABEL_25;
    }
LABEL_23:
    if ((v2 & 0x200) == 0)
      goto LABEL_25;
    goto LABEL_24;
  }
  if (*(_WORD *)(a1 + 384))
    v5 = (87384 * v5) >> 16;
  if ((v2 & 0x200) != 0)
    goto LABEL_24;
LABEL_25:
  v7 = *(_DWORD *)(a1 + 88);
  if ((v7 & 0x8000) == 0)
  {
    if ((v7 & 0x4000) != 0)
      goto LABEL_37;
LABEL_46:
    if ((v7 & 0x100000) == 0)
      goto LABEL_49;
    goto LABEL_47;
  }
  if (v5 <= 0x20)
    v8 = 32;
  else
    v8 = 64;
  if (v5 >= 9)
    v9 = 32;
  else
    v9 = 16;
  if (!*(_BYTE *)(a1 + 391))
    v5 = v9;
  if (*(unsigned __int8 *)(a1 + 391) - 2 < 2)
    v5 = v8;
  if ((v7 & 0x4000) == 0)
    goto LABEL_46;
LABEL_37:
  if ((v7 & 0x8000) != 0
    || ((*(_WORD *)(a1 + 384) != 0) & (v7 >> 12)) != 0
    || (v10 = *(unsigned __int8 *)(a1 + 391), v10 == 4))
  {
    if (v5 >= 0x11)
      v5 = 64;
    else
      v5 = 32;
    if ((v7 & 0x100000) == 0)
      goto LABEL_49;
  }
  else
  {
    v21 = v10 == 6;
    if (v10 == 6)
      v22 = 64;
    else
      v22 = 48;
    if (v21)
      v23 = 32;
    else
      v23 = 24;
    if (v5 <= 8)
      v5 = v23;
    else
      v5 = v22;
    if ((v7 & 0x100000) == 0)
      goto LABEL_49;
  }
LABEL_47:
  if (*(unsigned __int8 *)(a1 + 73) * *(unsigned __int8 *)(a1 + 72) > v5)
    v5 = *(unsigned __int8 *)(a1 + 73) * *(unsigned __int8 *)(a1 + 72);
LABEL_49:
  *(_BYTE *)(a1 + 398) = v5;
  *(_BYTE *)(a1 + 399) = 0;
  v11 = (v4 + 7) & 0xFFFFFFF8;
  v12 = v11 * (unint64_t)(v5 >> 3);
  v13 = (v11 * (unint64_t)v5) >> 3;
  if (v5 > 7)
    v13 = v12;
  v14 = v13 + ((v5 + 7) >> 3) + 49;
  if (v14 > *(_QWORD *)(a1 + 928))
  {
    png_free(a1, *(void **)(a1 + 840));
    png_free(a1, *(void **)(a1 + 960));
    if (*(_BYTE *)(a1 + 388))
      v15 = png_calloc((void (**)(void))a1, v14);
    else
      v15 = png_malloc((void (**)(void))a1, v14);
    *(_QWORD *)(a1 + 840) = v15;
    v16 = png_malloc((void (**)(void))a1, v14);
    *(_QWORD *)(a1 + 960) = v16;
    v17 = ((*(_QWORD *)(a1 + 840) + 32) & 0xFFFFFFFFFFFFFFF0) - 1;
    *(_QWORD *)(a1 + 320) = ((unint64_t)(v16 + 4) & 0xFFFFFFFFFFFFFFF0) - 1;
    *(_QWORD *)(a1 + 328) = v17;
    *(_QWORD *)(a1 + 928) = v14;
  }
  v18 = *(_QWORD *)(a1 + 296);
  if (v18 == -1)
  {
    v24 = "Row has too many bytes to allocate in memory";
    goto LABEL_78;
  }
  bzero(*(void **)(a1 + 320), v18 + 1);
  v19 = *(void **)(a1 + 936);
  if (v19)
  {
    *(_QWORD *)(a1 + 936) = 0;
    *(_QWORD *)(a1 + 944) = 0;
    png_free(a1, v19);
  }
  result = png_inflate_claim(a1, 1229209940);
  if ((_DWORD)result)
  {
    v24 = *(const char **)(a1 + 144);
LABEL_78:
    _cg_png_error((void (**)(void))a1, v24);
  }
  *(_DWORD *)(a1 + 80) |= 0x40u;
  return result;
}

void (**png_malloc(void (**result)(void), size_t size))(void)
{
  void (**v2)(void);
  void (*v3)(void);

  if (result)
  {
    v2 = result;
    if (!size)
      goto LABEL_7;
    v3 = result[103];
    if (v3)
    {
      result = (void (**)(void))((uint64_t (*)(void (**)(void)))v3)(result);
      if (result)
        return result;
LABEL_7:
      _cg_png_error(v2, "Out of memory");
    }
    result = (void (**)(void))malloc_type_malloc(size, 0xB622AF59uLL);
    if (!result)
      goto LABEL_7;
  }
  return result;
}

uint64_t png_inflate_claim(uint64_t a1, int a2)
{
  unsigned int v4;
  z_stream *v5;
  int v6;
  int v7;
  uint64_t v8;
  unsigned int v10;
  __int128 v11;
  __int128 v12;
  _DWORD v13[7];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v4 = *(_DWORD *)(a1 + 92);
  if (v4)
  {
    memset(v13, 0, sizeof(v13));
    v12 = 0u;
    v11 = 0u;
    v10 = bswap32(v4);
    png_safecat((uint64_t)&v10, 0x40uLL, 4uLL, " using zstream");
    png_chunk_warning(a1, (const char *)&v10);
    *(_DWORD *)(a1 + 92) = 0;
  }
  *(_QWORD *)(a1 + 96) = 0;
  v5 = (z_stream *)(a1 + 96);
  if ((*(_DWORD *)(a1 + 680) & 0xC) == 0xC)
    v6 = 15;
  else
    v6 = 0;
  *(_BYTE *)(a1 + 400) = (*(_DWORD *)(a1 + 680) & 0xC) != 12;
  if ((*(_DWORD *)(a1 + 84) & 0x11) != 0)
    v7 = -15;
  else
    v7 = v6;
  *(_DWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 128) = 0;
  if ((*(_BYTE *)(a1 + 80) & 2) != 0)
  {
    v8 = inflateReset2(v5, v7);
    if (!(_DWORD)v8)
      goto LABEL_14;
  }
  else
  {
    v8 = inflateInit2_(v5, v7, "1.2.12", 112);
    if (!(_DWORD)v8)
    {
      *(_DWORD *)(a1 + 80) |= 2u;
LABEL_14:
      v8 = 0;
      *(_DWORD *)(a1 + 92) = a2;
      return v8;
    }
  }
  png_zstream_error(a1, v8);
  return v8;
}

void png_init_read_transformations(uint64_t a1)
{
  int v2;
  int v3;
  _BOOL4 v4;
  unsigned int v5;
  _BOOL4 v6;
  unsigned int v7;
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  unsigned __int8 *v12;
  uint64_t v13;
  int v14;
  int v15;
  unsigned int v16;
  int v17;
  __int16 v18;
  __int16 v19;
  int v20;
  unsigned __int8 *v21;
  _BYTE *v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  __int16 v26;
  __int16 v27;
  __int16 v28;
  _BYTE *v29;
  uint64_t v30;
  int v31;
  __int16 v32;
  __int16 v33;
  uint64_t v34;
  uint64_t v35;
  _BYTE *v36;
  unsigned int v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  __int16 v44;
  uint64_t v45;
  char v46;
  uint64_t v47;
  char v48;
  uint64_t v49;
  __int16 v50;
  unsigned __int8 v51;
  unsigned __int8 v52;
  int v53;
  unsigned int v54;
  int v55;
  int v56;
  _BOOL4 v57;
  _BOOL4 v58;
  int v59;
  __int16 v60;
  _BOOL4 v61;
  _BOOL4 v62;
  unint64_t v63;
  _BYTE *v64;
  uint64_t v65;
  int v66;
  uint64_t v67;
  char v68;
  uint64_t v69;
  uint64_t v70;
  __int16 v71;
  __int16 v72;
  __int16 v73;
  uint64_t v74;
  int v75;
  char v76;
  _BYTE *v77;
  uint64_t v78;
  int v79;
  char v81;
  _BYTE *v82;
  uint64_t v83;
  int v84;
  char v86;
  _BYTE *v87;
  int v88;

  v2 = *(_DWORD *)(a1 + 1000);
  v3 = *(_DWORD *)(a1 + 452);
  if (v2)
  {
    if (v3)
    {
      v88 = 0;
      if (png_muldiv(&v88, v2, v3, 100000))
      {
        v4 = png_gamma_significant(v88);
        *(_WORD *)(a1 + 1074) |= 1u;
        if (!v4)
          goto LABEL_13;
      }
      else
      {
        *(_WORD *)(a1 + 1074) |= 1u;
      }
      v5 = *(_DWORD *)(a1 + 88) | 0x2000;
      goto LABEL_14;
    }
    *(_DWORD *)(a1 + 452) = png_reciprocal(*(_DWORD *)(a1 + 1000));
  }
  else if (v3)
  {
    *(_DWORD *)(a1 + 1000) = png_reciprocal(*(_DWORD *)(a1 + 452));
  }
  else
  {
    *(_DWORD *)(a1 + 1000) = 100000;
    *(_DWORD *)(a1 + 452) = 100000;
  }
  *(_WORD *)(a1 + 1074) |= 1u;
LABEL_13:
  v5 = *(_DWORD *)(a1 + 88) & 0xFFFFDFFF;
LABEL_14:
  *(_DWORD *)(a1 + 88) = v5;
  if ((v5 & 0x40080) == 0x40000)
  {
    *(_DWORD *)(a1 + 88) = v5 & 0xFD7FFEFF;
    *(_DWORD *)(a1 + 80) &= ~0x2000u;
    *(_WORD *)(a1 + 384) = 0;
  }
  v6 = png_gamma_significant(*(_DWORD *)(a1 + 452));
  v7 = *(_DWORD *)(a1 + 88);
  if (!v6)
  {
    v7 &= ~0x800000u;
    *(_DWORD *)(a1 + 88) = v7;
    *(_DWORD *)(a1 + 80) &= ~0x2000u;
  }
  if ((v7 & 0x600000) != 0)
  {
    png_colorspace_set_rgb_coefficients(a1);
    v7 = *(_DWORD *)(a1 + 88);
  }
  if ((v7 & 0x100) != 0)
  {
    if ((*(_BYTE *)(a1 + 391) & 2) == 0)
      *(_DWORD *)(a1 + 76) |= 0x800u;
  }
  else if ((~v7 & 0x4080) == 0)
  {
    v8 = *(unsigned __int16 *)(a1 + 414);
    if (v8 == *(unsigned __int16 *)(a1 + 416) && v8 == *(unsigned __int16 *)(a1 + 418))
    {
      *(_DWORD *)(a1 + 76) |= 0x800u;
      *(_WORD *)(a1 + 420) = v8;
    }
  }
  v9 = *(unsigned __int8 *)(a1 + 391);
  if (v9 == 3)
  {
    v10 = *(unsigned __int16 *)(a1 + 384);
    if (*(_WORD *)(a1 + 384))
    {
      v11 = 0;
      v12 = *(unsigned __int8 **)(a1 + 520);
      v13 = *(unsigned __int16 *)(a1 + 384);
      do
      {
        v15 = *v12++;
        v14 = v15;
        if (v15 != 255)
        {
          if (v14)
          {
            v16 = v7;
            goto LABEL_49;
          }
          v11 = 1;
        }
        --v13;
      }
      while (v13);
      v16 = v7 & 0xFF7FFFFF;
      *(_DWORD *)(a1 + 88) = v7 & 0xFF7FFFFF;
      *(_DWORD *)(a1 + 80) &= ~0x2000u;
      if (v11)
        goto LABEL_49;
    }
    else
    {
      *(_DWORD *)(a1 + 80) &= ~0x2000u;
    }
    v16 = v7 & 0xFF7FFE7F;
    *(_DWORD *)(a1 + 88) = v7 & 0xFF7FFE7F;
LABEL_49:
    if ((~v16 & 0x1100) == 0)
    {
      v21 = (unsigned __int8 *)(*(_QWORD *)(a1 + 368) + 3 * *(unsigned __int8 *)(a1 + 412));
      *(_WORD *)(a1 + 414) = *v21;
      *(_WORD *)(a1 + 416) = v21[1];
      *(_WORD *)(a1 + 418) = v21[2];
      if ((_DWORD)v10)
      {
        if ((v16 & 0x2080000) == 0x80000)
        {
          v22 = *(_BYTE **)(a1 + 520);
          do
          {
            *v22 = ~*v22;
            ++v22;
            --v10;
          }
          while (v10);
          v16 = *(_DWORD *)(a1 + 88);
        }
      }
    }
  }
  else
  {
    if ((v9 & 4) != 0)
    {
      v16 = v7;
    }
    else
    {
      v17 = *(unsigned __int16 *)(a1 + 384);
      v16 = v7 & 0xFF7FFFFF;
      *(_DWORD *)(a1 + 88) = v7 & 0xFF7FFFFF;
      *(_DWORD *)(a1 + 80) &= ~0x2000u;
      if (!v17)
      {
        v16 = v7 & 0xFF7FFE7F;
        *(_DWORD *)(a1 + 88) = v7 & 0xFF7FFE7F;
      }
    }
    if ((v9 & 2) == 0 && (v16 & 0x1100) == 0x1100)
    {
      v18 = *(_WORD *)(a1 + 420);
      v19 = *(_WORD *)(a1 + 536);
      v20 = *(unsigned __int8 *)(a1 + 392);
      switch(v20)
      {
        case 4:
          v18 *= 17;
          v19 *= 17;
          break;
        case 2:
          v18 *= 85;
          v19 *= 85;
          break;
        case 1:
          v18 *= 255;
          v19 *= 255;
          break;
      }
      *(_WORD *)(a1 + 418) = v18;
      *(_WORD *)(a1 + 416) = v18;
      *(_WORD *)(a1 + 414) = v18;
      if ((v16 & 0x2000000) == 0)
      {
        *(_WORD *)(a1 + 534) = v19;
        *(_WORD *)(a1 + 532) = v19;
        *(_WORD *)(a1 + 530) = v19;
      }
    }
  }
  if ((v16 & 0x380) == 0x280 && *(_BYTE *)(a1 + 392) != 16)
    *(int16x4_t *)(a1 + 414) = vaddhn_s32((int32x4_t)vmull_u16(*(uint16x4_t *)(a1 + 414), (uint16x4_t)0xFF00FF00FF00FFLL), vdupq_n_s32(0x807Fu));
  if ((v16 & 0x4000400) != 0 && (v16 & 0x180) == 0x80 && *(_BYTE *)(a1 + 392) == 16)
    *(int16x4_t *)(a1 + 414) = vmul_s16(*(int16x4_t *)(a1 + 414), (int16x4_t)0x101010101010101);
  *(_WORD *)(a1 + 430) = *(_WORD *)(a1 + 420);
  *(_QWORD *)(a1 + 422) = *(_QWORD *)(a1 + 412);
  if ((v16 & 0x2000) != 0)
    goto LABEL_88;
  if ((v16 & 0x600000) != 0)
  {
    if (png_gamma_significant(*(_DWORD *)(a1 + 1000)) || png_gamma_significant(*(_DWORD *)(a1 + 452)))
      goto LABEL_88;
    v16 = *(_DWORD *)(a1 + 88);
  }
  if ((v16 & 0x80) != 0
    && (png_gamma_significant(*(_DWORD *)(a1 + 1000))
     || png_gamma_significant(*(_DWORD *)(a1 + 452))
     || *(_BYTE *)(a1 + 404) == 3 && png_gamma_significant(*(_DWORD *)(a1 + 408))))
  {
    goto LABEL_88;
  }
  v23 = *(_DWORD *)(a1 + 88);
  if ((v23 & 0x800000) != 0)
  {
    if (!png_gamma_significant(*(_DWORD *)(a1 + 452)))
    {
      v23 = *(_DWORD *)(a1 + 88);
      goto LABEL_75;
    }
LABEL_88:
    png_build_gamma_table(a1, *(unsigned __int8 *)(a1 + 392));
    v23 = *(_DWORD *)(a1 + 88);
    if ((v23 & 0x80) == 0)
    {
      if (*(_BYTE *)(a1 + 391) == 3 && ((v23 & 0x1000) == 0 || (v23 & 0x600000) == 0))
      {
        v34 = *(unsigned __int16 *)(a1 + 376);
        if (*(_WORD *)(a1 + 376))
        {
          v35 = *(_QWORD *)(a1 + 456);
          v36 = (_BYTE *)(*(_QWORD *)(a1 + 368) + 2);
          do
          {
            *(v36 - 2) = *(_BYTE *)(v35 + *(v36 - 2));
            *(v36 - 1) = *(_BYTE *)(v35 + *(v36 - 1));
            *v36 = *(_BYTE *)(v35 + *v36);
            v36 += 3;
            --v34;
          }
          while (v34);
        }
        v23 &= ~0x2000u;
        goto LABEL_144;
      }
      goto LABEL_145;
    }
    if ((v23 & 0x600000) != 0)
      png_warning(a1, "libpng does not support gamma+background+rgb_to_gray");
    if (*(_BYTE *)(a1 + 391) == 3)
    {
      v37 = 100000;
      v38 = *(_QWORD *)(a1 + 368);
      v39 = *(unsigned __int16 *)(a1 + 376);
      v40 = *(unsigned __int8 *)(a1 + 404);
      if (v40 == 1)
      {
        v41 = *(_DWORD *)(a1 + 452);
      }
      else if (v40 == 3)
      {
        v41 = png_reciprocal(*(_DWORD *)(a1 + 408));
        v37 = png_reciprocal2(*(_DWORD *)(a1 + 408), *(_DWORD *)(a1 + 452));
      }
      else
      {
        v41 = 100000;
        if (v40 == 2)
        {
          v42 = *(_QWORD *)(a1 + 456);
          v43 = *(unsigned __int16 *)(a1 + 414);
          LOBYTE(v44) = *(_BYTE *)(v42 + v43);
          v45 = *(unsigned __int16 *)(a1 + 416);
          v46 = *(_BYTE *)(v42 + v45);
          v47 = *(unsigned __int16 *)(a1 + 418);
          v48 = *(_BYTE *)(v42 + v47);
          v49 = *(_QWORD *)(a1 + 480);
          LOBYTE(v50) = *(_BYTE *)(v49 + v43);
          v51 = *(_BYTE *)(v49 + v45);
          v52 = *(_BYTE *)(v49 + v47);
          if (!*(_WORD *)(a1 + 376))
            goto LABEL_143;
LABEL_133:
          v63 = 0;
          v64 = (_BYTE *)(v38 + 2);
          while (v63 < *(unsigned __int16 *)(a1 + 384))
          {
            v65 = *(_QWORD *)(a1 + 520);
            v66 = *(unsigned __int8 *)(v65 + v63);
            if (v66 == 255)
              break;
            if (*(_BYTE *)(v65 + v63))
            {
              v70 = *(_QWORD *)(a1 + 472);
              v69 = *(_QWORD *)(a1 + 480);
              v71 = *(unsigned __int8 *)(v69 + *(v64 - 2)) * (_WORD)v66
                  + (v66 ^ 0xFF) * v50
                  + 128;
              *(v64 - 2) = *(_BYTE *)(v70 + ((unsigned __int16)(v71 + HIBYTE(v71)) >> 8));
              v72 = *(unsigned __int8 *)(v65 + v63) * *(unsigned __int8 *)(v69 + *(v64 - 1))
                  + (*(unsigned __int8 *)(v65 + v63) ^ 0xFF) * v51
                  + 128;
              *(v64 - 1) = *(_BYTE *)(v70 + ((unsigned __int16)(v72 + HIBYTE(v72)) >> 8));
              v73 = *(unsigned __int8 *)(v65 + v63) * *(unsigned __int8 *)(v69 + *v64)
                  + (*(unsigned __int8 *)(v65 + v63) ^ 0xFF) * v52
                  + 128;
              v68 = *(_BYTE *)(v70 + ((unsigned __int16)(v73 + HIBYTE(v73)) >> 8));
              goto LABEL_139;
            }
            *(v64 - 2) = v44;
            *(v64 - 1) = v46;
            *v64 = v48;
LABEL_140:
            ++v63;
            v64 += 3;
            if (v39 == v63)
              goto LABEL_143;
          }
          v67 = *(_QWORD *)(a1 + 456);
          *(v64 - 2) = *(_BYTE *)(v67 + *(v64 - 2));
          *(v64 - 1) = *(_BYTE *)(v67 + *(v64 - 1));
          v68 = *(_BYTE *)(v67 + *v64);
LABEL_139:
          *v64 = v68;
          goto LABEL_140;
        }
      }
      v61 = png_gamma_significant(v37);
      v44 = *(_WORD *)(a1 + 414);
      if (v61)
      {
        LOBYTE(v44) = png_gamma_8bit_correct(*(unsigned __int16 *)(a1 + 414), v37);
        v46 = png_gamma_8bit_correct(*(unsigned __int16 *)(a1 + 416), v37);
        v48 = png_gamma_8bit_correct(*(unsigned __int16 *)(a1 + 418), v37);
      }
      else
      {
        v46 = *(_BYTE *)(a1 + 416);
        v48 = *(_BYTE *)(a1 + 418);
      }
      v62 = png_gamma_significant(v41);
      v50 = *(_WORD *)(a1 + 414);
      if (v62)
      {
        LOBYTE(v50) = png_gamma_8bit_correct(*(unsigned __int16 *)(a1 + 414), v41);
        v51 = png_gamma_8bit_correct(*(unsigned __int16 *)(a1 + 416), v41);
        v52 = png_gamma_8bit_correct(*(unsigned __int16 *)(a1 + 418), v41);
        if (!(_DWORD)v39)
          goto LABEL_143;
      }
      else
      {
        v51 = *(_BYTE *)(a1 + 416);
        v52 = *(_BYTE *)(a1 + 418);
        if (!(_DWORD)v39)
        {
LABEL_143:
          v23 = *(_DWORD *)(a1 + 88) & 0xFFFFDF7F;
LABEL_144:
          *(_DWORD *)(a1 + 88) = v23;
          goto LABEL_145;
        }
      }
      goto LABEL_133;
    }
    v53 = *(unsigned __int8 *)(a1 + 404);
    switch(v53)
    {
      case 3:
        v55 = png_reciprocal(*(_DWORD *)(a1 + 408));
        v56 = *(_DWORD *)(a1 + 408);
        break;
      case 2:
        v55 = png_reciprocal(*(_DWORD *)(a1 + 1000));
        v56 = *(_DWORD *)(a1 + 1000);
        break;
      case 1:
        v54 = 100000;
        v55 = *(_DWORD *)(a1 + 452);
        goto LABEL_111;
      default:
        _cg_png_error((void (**)(void))a1, "invalid background gamma type");
    }
    v54 = png_reciprocal2(v56, *(_DWORD *)(a1 + 452));
LABEL_111:
    v57 = png_gamma_significant(v55);
    v58 = png_gamma_significant(v54);
    if (v57)
      *(_WORD *)(a1 + 430) = png_gamma_correct(a1, *(unsigned __int16 *)(a1 + 420), v55);
    if (v58)
      *(_WORD *)(a1 + 420) = png_gamma_correct(a1, *(unsigned __int16 *)(a1 + 420), v54);
    v59 = *(unsigned __int16 *)(a1 + 414);
    if (v59 == *(unsigned __int16 *)(a1 + 416)
      && v59 == *(unsigned __int16 *)(a1 + 418)
      && v59 == *(unsigned __int16 *)(a1 + 420))
    {
      v60 = *(_WORD *)(a1 + 430);
      *(_WORD *)(a1 + 428) = v60;
      *(_WORD *)(a1 + 426) = v60;
      *(_WORD *)(a1 + 424) = v60;
      *(_WORD *)(a1 + 418) = v59;
      *(_WORD *)(a1 + 416) = v59;
      *(_WORD *)(a1 + 414) = v59;
    }
    else
    {
      if (v57)
      {
        *(_WORD *)(a1 + 424) = png_gamma_correct(a1, v59, v55);
        *(_WORD *)(a1 + 426) = png_gamma_correct(a1, *(unsigned __int16 *)(a1 + 416), v55);
        *(_WORD *)(a1 + 428) = png_gamma_correct(a1, *(unsigned __int16 *)(a1 + 418), v55);
      }
      if (v58)
      {
        *(_WORD *)(a1 + 414) = png_gamma_correct(a1, *(unsigned __int16 *)(a1 + 414), v54);
        *(_WORD *)(a1 + 416) = png_gamma_correct(a1, *(unsigned __int16 *)(a1 + 416), v54);
        *(_WORD *)(a1 + 418) = png_gamma_correct(a1, *(unsigned __int16 *)(a1 + 418), v54);
      }
    }
    *(_BYTE *)(a1 + 404) = 1;
    v23 = *(_DWORD *)(a1 + 88);
    goto LABEL_145;
  }
LABEL_75:
  if ((v23 & 0x80) != 0 && *(_BYTE *)(a1 + 391) == 3)
  {
    v24 = *(unsigned __int16 *)(a1 + 384);
    if (*(_WORD *)(a1 + 384))
    {
      v25 = 0;
      v26 = *(unsigned __int8 *)(a1 + 414);
      v27 = *(unsigned __int8 *)(a1 + 416);
      v28 = *(unsigned __int8 *)(a1 + 418);
      v29 = (_BYTE *)(*(_QWORD *)(a1 + 368) + 2);
      do
      {
        v30 = *(_QWORD *)(a1 + 520);
        v31 = *(unsigned __int8 *)(v30 + v25);
        if (v31 != 255)
        {
          if (*(_BYTE *)(v30 + v25))
          {
            v32 = *(v29 - 2) * (_WORD)v31 + v26 * (v31 ^ 0xFF) + 128;
            *(v29 - 2) = (unsigned __int16)(v32 + ((unsigned __int16)(v32 & 0xFF00) >> 8)) >> 8;
            *(v29 - 1) = (unsigned __int16)(*(unsigned __int8 *)(v30 + v25) * *(v29 - 1)
                                          + v27 * (*(unsigned __int8 *)(v30 + v25) ^ 0xFF)
                                          + 128
                                          + ((unsigned __int16)((*(unsigned __int8 *)(v30 + v25)
                                                               * *(v29 - 1)
                                                               + v27 * (*(unsigned __int8 *)(v30 + v25) ^ 0xFF)
                                                               + 128) & 0xFF00) >> 8)) >> 8;
            v33 = *(unsigned __int8 *)(v30 + v25) * *v29
                + v28 * (*(unsigned __int8 *)(v30 + v25) ^ 0xFF)
                + 128;
            *v29 = (unsigned __int16)(v33 + ((unsigned __int16)(v33 & 0xFF00) >> 8)) >> 8;
          }
          else
          {
            *(v29 - 2) = v26;
            *(v29 - 1) = v27;
            *v29 = v28;
          }
        }
        ++v25;
        v29 += 3;
      }
      while (v24 != v25);
      v23 = *(_DWORD *)(a1 + 88);
    }
    v23 &= ~0x80u;
    goto LABEL_144;
  }
LABEL_145:
  if ((v23 & 0x1008) == 8 && *(_BYTE *)(a1 + 391) == 3)
  {
    v74 = *(unsigned __int16 *)(a1 + 376);
    v75 = *(unsigned __int8 *)(a1 + 504);
    *(_DWORD *)(a1 + 88) = v23 & 0xFFFFFFF7;
    if ((v75 - 1) <= 6 && (_DWORD)v74)
    {
      v76 = 8 - v75;
      v77 = *(_BYTE **)(a1 + 368);
      v78 = v74;
      do
      {
        *v77 = *v77 >> v76;
        v77 += 3;
        --v78;
      }
      while (v78);
    }
    v79 = *(unsigned __int8 *)(a1 + 505);
    if ((v79 - 1) <= 6 && (_DWORD)v74 != 0)
    {
      v81 = 8 - v79;
      v82 = (_BYTE *)(*(_QWORD *)(a1 + 368) + 1);
      v83 = v74;
      do
      {
        *v82 = *v82 >> v81;
        v82 += 3;
        --v83;
      }
      while (v83);
    }
    v84 = *(unsigned __int8 *)(a1 + 506);
    if ((v84 - 1) <= 6 && (_DWORD)v74 != 0)
    {
      v86 = 8 - v84;
      v87 = (_BYTE *)(*(_QWORD *)(a1 + 368) + 2);
      do
      {
        *v87 = *v87 >> v86;
        v87 += 3;
        --v74;
      }
      while (v74);
    }
  }
}

BOOL png_gamma_significant(int a1)
{
  return (a1 - 105001) < 0xFFFFD8EF;
}

void _cg_png_destroy_read_struct(uint64_t *a1, void **a2, void **a3)
{
  uint64_t v4;
  int v6;
  unsigned int v7;

  if (a1)
  {
    v4 = *a1;
    if (*a1)
    {
      _cg_png_destroy_info_struct(*a1, a3);
      _cg_png_destroy_info_struct(v4, a2);
      *a1 = 0;
      png_destroy_gamma_table(v4);
      png_free(v4, *(void **)(v4 + 840));
      *(_QWORD *)(v4 + 840) = 0;
      png_free(v4, *(void **)(v4 + 960));
      *(_QWORD *)(v4 + 960) = 0;
      png_free(v4, *(void **)(v4 + 936));
      *(_QWORD *)(v4 + 936) = 0;
      png_free(v4, *(void **)(v4 + 664));
      *(_QWORD *)(v4 + 664) = 0;
      png_free(v4, *(void **)(v4 + 672));
      *(_QWORD *)(v4 + 672) = 0;
      v6 = *(_DWORD *)(v4 + 716);
      if ((v6 & 0x1000) != 0)
      {
        png_zfree(v4, *(_QWORD *)(v4 + 368));
        *(_QWORD *)(v4 + 368) = 0;
        v6 = *(_DWORD *)(v4 + 716);
      }
      v7 = v6 & 0xFFFFEFFF;
      *(_DWORD *)(v4 + 716) = v6 & 0xFFFFEFFF;
      if ((v6 & 0x2000) != 0)
      {
        png_free(v4, *(void **)(v4 + 520));
        *(_QWORD *)(v4 + 520) = 0;
        v7 = *(_DWORD *)(v4 + 716);
      }
      *(_DWORD *)(v4 + 716) = v7 & 0xFFFFDFFF;
      inflateEnd((z_streamp)(v4 + 96));
      png_free(v4, *(void **)(v4 + 592));
      *(_QWORD *)(v4 + 592) = 0;
      png_free(v4, *(void **)(v4 + 904));
      *(_QWORD *)(v4 + 912) = 0;
      *(_QWORD *)(v4 + 904) = 0;
      png_free(v4, *(void **)(v4 + 744));
      *(_QWORD *)(v4 + 744) = 0;
      png_destroy_png_struct((void *)v4);
    }
  }
}

void png_free(uint64_t a1, void *a2)
{
  void (*v2)(void);

  if (a1 && a2)
  {
    v2 = *(void (**)(void))(a1 + 832);
    if (v2)
      v2();
    else
      free(a2);
  }
}

void _cg_png_destroy_info_struct(uint64_t a1, void **a2)
{
  _QWORD *v2;

  if (a1 && a2)
  {
    v2 = *a2;
    if (*a2)
    {
      *a2 = 0;
      png_free_data(a1, (uint64_t)v2, 0xFFFFu, -1);
      v2[48] = 0;
      *((_OWORD *)v2 + 22) = 0u;
      *((_OWORD *)v2 + 23) = 0u;
      *((_OWORD *)v2 + 20) = 0u;
      *((_OWORD *)v2 + 21) = 0u;
      *((_OWORD *)v2 + 18) = 0u;
      *((_OWORD *)v2 + 19) = 0u;
      *((_OWORD *)v2 + 16) = 0u;
      *((_OWORD *)v2 + 17) = 0u;
      *((_OWORD *)v2 + 14) = 0u;
      *((_OWORD *)v2 + 15) = 0u;
      *((_OWORD *)v2 + 12) = 0u;
      *((_OWORD *)v2 + 13) = 0u;
      *((_OWORD *)v2 + 10) = 0u;
      *((_OWORD *)v2 + 11) = 0u;
      *((_OWORD *)v2 + 8) = 0u;
      *((_OWORD *)v2 + 9) = 0u;
      *((_OWORD *)v2 + 6) = 0u;
      *((_OWORD *)v2 + 7) = 0u;
      *((_OWORD *)v2 + 4) = 0u;
      *((_OWORD *)v2 + 5) = 0u;
      *((_OWORD *)v2 + 2) = 0u;
      *((_OWORD *)v2 + 3) = 0u;
      *(_OWORD *)v2 = 0u;
      *((_OWORD *)v2 + 1) = 0u;
      png_free(a1, v2);
    }
  }
}

void png_free_data(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  void *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  void *v12;
  unint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  void *v23;
  void *v24;
  void *v25;
  unint64_t v26;
  unsigned int v27;

  if (a1 && a2)
  {
    v8 = *(void **)(a2 + 160);
    if (v8 && (a3 & *(_DWORD *)(a2 + 300) & 0x4000) != 0)
    {
      if (a4 == -1)
      {
        if (*(int *)(a2 + 148) >= 1)
        {
          v9 = 0;
          v10 = 8;
          do
          {
            png_free(a1, *(void **)(*(_QWORD *)(a2 + 160) + v10));
            ++v9;
            v10 += 56;
          }
          while (v9 < *(int *)(a2 + 148));
          v8 = *(void **)(a2 + 160);
        }
        png_free(a1, v8);
        *(_QWORD *)(a2 + 160) = 0;
        *(_DWORD *)(a2 + 148) = 0;
        *(_DWORD *)(a2 + 152) = 0;
      }
      else
      {
        png_free(a1, *((void **)v8 + 7 * a4 + 1));
        *(_QWORD *)(*(_QWORD *)(a2 + 160) + 56 * a4 + 8) = 0;
      }
    }
    v11 = *(_DWORD *)(a2 + 300);
    if ((a3 & v11 & 0x2000) != 0)
    {
      *(_DWORD *)(a2 + 8) &= ~0x10u;
      png_free(a1, *(void **)(a2 + 184));
      *(_QWORD *)(a2 + 184) = 0;
      *(_WORD *)(a2 + 34) = 0;
      v11 = *(_DWORD *)(a2 + 300);
    }
    if ((a3 & v11 & 0x100) != 0)
    {
      png_free(a1, *(void **)(a2 + 336));
      png_free(a1, *(void **)(a2 + 344));
      *(_QWORD *)(a2 + 336) = 0;
      *(_QWORD *)(a2 + 344) = 0;
      *(_DWORD *)(a2 + 8) &= ~0x4000u;
      v11 = *(_DWORD *)(a2 + 300);
    }
    if ((a3 & v11 & 0x80) != 0)
    {
      png_free(a1, *(void **)(a2 + 264));
      png_free(a1, *(void **)(a2 + 280));
      *(_QWORD *)(a2 + 264) = 0;
      *(_QWORD *)(a2 + 280) = 0;
      v12 = *(void **)(a2 + 288);
      if (v12)
      {
        if (*(_BYTE *)(a2 + 297))
        {
          v13 = 0;
          do
            png_free(a1, *(void **)(*(_QWORD *)(a2 + 288) + 8 * v13++));
          while (v13 < *(unsigned __int8 *)(a2 + 297));
          v12 = *(void **)(a2 + 288);
        }
        png_free(a1, v12);
        *(_QWORD *)(a2 + 288) = 0;
        *(_BYTE *)(a2 + 297) = 0;
      }
      *(_DWORD *)(a2 + 8) &= ~0x400u;
      v11 = *(_DWORD *)(a2 + 300);
    }
    if ((a3 & v11 & 0x10) != 0)
    {
      png_free(a1, *(void **)(a2 + 128));
      png_free(a1, *(void **)(a2 + 136));
      *(_QWORD *)(a2 + 128) = 0;
      *(_QWORD *)(a2 + 136) = 0;
      *(_DWORD *)(a2 + 144) = 0;
      *(_DWORD *)(a2 + 8) &= ~0x1000u;
    }
    v14 = *(void **)(a2 + 320);
    if (v14 && (a3 & *(_DWORD *)(a2 + 300) & 0x20) != 0)
    {
      if (a4 == -1)
      {
        if (*(int *)(a2 + 328) >= 1)
        {
          v16 = 0;
          v17 = 0;
          do
          {
            png_free(a1, *(void **)(*(_QWORD *)(a2 + 320) + v16));
            png_free(a1, *(void **)(*(_QWORD *)(a2 + 320) + v16 + 24));
            ++v17;
            v16 += 40;
          }
          while (v17 < *(int *)(a2 + 328));
          v14 = *(void **)(a2 + 320);
        }
        png_free(a1, v14);
        *(_QWORD *)(a2 + 320) = 0;
        *(_DWORD *)(a2 + 328) = 0;
        *(_DWORD *)(a2 + 8) &= ~0x2000u;
      }
      else
      {
        png_free(a1, *((void **)v14 + 5 * a4));
        png_free(a1, *(void **)(*(_QWORD *)(a2 + 320) + 40 * a4 + 24));
        v15 = *(_QWORD *)(a2 + 320) + 40 * a4;
        *(_QWORD *)(v15 + 24) = 0;
        *(_DWORD *)(v15 + 32) = 0;
        *(_QWORD *)v15 = 0;
        *(_QWORD *)(v15 + 8) = 0;
      }
    }
    v18 = *(void **)(a2 + 304);
    if (v18 && (a3 & *(_DWORD *)(a2 + 300) & 0x200) != 0)
    {
      if (a4 == -1)
      {
        if (*(int *)(a2 + 312) >= 1)
        {
          v20 = 0;
          v21 = 8;
          do
          {
            png_free(a1, *(void **)(*(_QWORD *)(a2 + 304) + v21));
            ++v20;
            v21 += 32;
          }
          while (v20 < *(int *)(a2 + 312));
          v18 = *(void **)(a2 + 304);
        }
        png_free(a1, v18);
        *(_QWORD *)(a2 + 304) = 0;
        *(_DWORD *)(a2 + 312) = 0;
      }
      else
      {
        png_free(a1, *((void **)v18 + 4 * a4 + 1));
        v19 = *(_QWORD *)(a2 + 304) + 32 * a4;
        *(_QWORD *)(v19 + 8) = 0;
        *(_QWORD *)(v19 + 16) = 0;
      }
    }
    v22 = *(_DWORD *)(a2 + 300);
    if ((a3 & v22 & 0x8000) != 0)
    {
      v23 = *(void **)(a2 + 248);
      if (v23)
      {
        png_free(a1, v23);
        *(_QWORD *)(a2 + 248) = 0;
      }
      v24 = *(void **)(a2 + 240);
      if (v24)
      {
        png_free(a1, v24);
        *(_QWORD *)(a2 + 240) = 0;
        *(_DWORD *)(a2 + 236) = 0;
      }
      *(_DWORD *)(a2 + 8) &= ~0x10000u;
      v22 = *(_DWORD *)(a2 + 300);
    }
    if ((a3 & v22 & 8) != 0)
    {
      png_free(a1, *(void **)(a2 + 256));
      *(_QWORD *)(a2 + 256) = 0;
      *(_DWORD *)(a2 + 8) &= ~0x40u;
      v22 = *(_DWORD *)(a2 + 300);
    }
    if ((a3 & v22 & 0x1000) != 0)
    {
      png_free(a1, *(void **)(a2 + 24));
      *(_QWORD *)(a2 + 24) = 0;
      *(_DWORD *)(a2 + 8) &= ~8u;
      *(_WORD *)(a2 + 32) = 0;
      v22 = *(_DWORD *)(a2 + 300);
    }
    if ((a3 & v22 & 0x40) != 0)
    {
      v25 = *(void **)(a2 + 352);
      if (v25)
      {
        if (*(_DWORD *)(a2 + 4))
        {
          v26 = 0;
          do
            png_free(a1, *(void **)(*(_QWORD *)(a2 + 352) + 8 * v26++));
          while (v26 < *(unsigned int *)(a2 + 4));
          v25 = *(void **)(a2 + 352);
        }
        png_free(a1, v25);
        *(_QWORD *)(a2 + 352) = 0;
        v22 = *(_DWORD *)(a2 + 300);
      }
      *(_DWORD *)(a2 + 8) &= ~0x8000u;
    }
    v27 = a3 & 0xFFFFBDDF;
    if (a4 == -1)
      v27 = a3;
    *(_DWORD *)(a2 + 300) = v22 & ~v27;
  }
}

void png_destroy_gamma_table(uint64_t a1)
{
  void *v2;
  int v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  void *v7;
  int v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  void *v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;

  png_free(a1, *(void **)(a1 + 456));
  *(_QWORD *)(a1 + 456) = 0;
  v2 = *(void **)(a1 + 464);
  if (v2)
  {
    v3 = *(_DWORD *)(a1 + 448);
    if (v3 != -23)
    {
      v4 = 0;
      v5 = 1 << (8 - v3);
      if (v5 <= 1)
        v5 = 1;
      v6 = 8 * v5;
      do
      {
        png_free(a1, *(void **)(*(_QWORD *)(a1 + 464) + v4));
        v4 += 8;
      }
      while (v6 != v4);
      v2 = *(void **)(a1 + 464);
    }
    png_free(a1, v2);
    *(_QWORD *)(a1 + 464) = 0;
  }
  png_free(a1, *(void **)(a1 + 472));
  *(_QWORD *)(a1 + 472) = 0;
  png_free(a1, *(void **)(a1 + 480));
  *(_QWORD *)(a1 + 480) = 0;
  v7 = *(void **)(a1 + 488);
  if (v7)
  {
    v8 = *(_DWORD *)(a1 + 448);
    if (v8 != -23)
    {
      v9 = 0;
      v10 = 1 << (8 - v8);
      if (v10 <= 1)
        v10 = 1;
      v11 = 8 * v10;
      do
      {
        png_free(a1, *(void **)(*(_QWORD *)(a1 + 488) + v9));
        v9 += 8;
      }
      while (v11 != v9);
      v7 = *(void **)(a1 + 488);
    }
    png_free(a1, v7);
    *(_QWORD *)(a1 + 488) = 0;
  }
  v12 = *(void **)(a1 + 496);
  if (v12)
  {
    v13 = *(_DWORD *)(a1 + 448);
    if (v13 != -23)
    {
      v14 = 0;
      v15 = 1 << (8 - v13);
      if (v15 <= 1)
        v15 = 1;
      v16 = 8 * v15;
      do
      {
        png_free(a1, *(void **)(*(_QWORD *)(a1 + 496) + v14));
        v14 += 8;
      }
      while (v16 != v14);
      v12 = *(void **)(a1 + 496);
    }
    png_free(a1, v12);
    *(_QWORD *)(a1 + 496) = 0;
  }
}

uint64_t _cg_png_read_update_info(uint64_t result, unsigned int *a2)
{
  uint64_t v2;

  if (result)
  {
    v2 = result;
    if ((*(_BYTE *)(result + 80) & 0x40) != 0)
    {
      return png_app_error(result, "png_read_update_info/png_start_read_image: duplicate call");
    }
    else
    {
      png_read_start_row(result);
      return png_read_transform_info(v2, a2);
    }
  }
  return result;
}

_QWORD *_cg_png_create_read_struct(_BYTE *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return png_create_read_struct_2(a1, a2, a3, a4, 0, 0, 0);
}

IIOImageRead *IIOImageReadSession::globalInfoForType(IIOImageReadSession *this, int a2)
{
  IIOImageRead *result;

  result = (IIOImageRead *)*((_QWORD *)this + 4);
  if (result)
    return (IIOImageRead *)IIOImageRead::globalInfoPtrForType(result, a2);
  return result;
}

uint64_t IIOImageRead::globalInfoPtrForType(IIOImageRead *this, int a2)
{
  pthread_mutex_t *v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v8;

  v4 = (pthread_mutex_t *)((char *)this + 88);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 88));
  v5 = (uint64_t *)*((_QWORD *)this + 19);
  v6 = (uint64_t *)*((_QWORD *)this + 20);
  if (v5 == v6)
  {
LABEL_7:
    v8 = 0;
  }
  else
  {
    while (a2 != 1684170528 && *((_DWORD *)v5 + 4) != a2)
    {
      v5 += 3;
      if (v5 == v6)
        goto LABEL_7;
    }
    v8 = *v5;
  }
  pthread_mutex_unlock(v4);
  return v8;
}

uint64_t _cg_png_get_bit_depth(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = 0;
  if (a1)
  {
    if (a2)
      return *(unsigned __int8 *)(a2 + 36);
  }
  return result;
}

uint64_t PNGReadPlugin::Validate_png_info(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int bit_depth;
  int color_type;

  if (*(_BYTE *)(a3 + 35))
  {
    bit_depth = _cg_png_get_bit_depth(a1, a2);
    color_type = _cg_png_get_color_type(a1, a2);
    if (bit_depth != 8 || color_type == 3)
    {
      *(_WORD *)(a3 + 35) = 256;
      *(_DWORD *)(a3 + 40) = 0;
    }
  }
  return 0;
}

uint64_t _cg_png_set_interlace_handling(uint64_t a1)
{
  if (!a1 || !*(_BYTE *)(a1 + 388))
    return 1;
  *(_DWORD *)(a1 + 88) |= 2u;
  return 7;
}

unint64_t ImageIOAlignRowBytes(uint64_t a1, unint64_t a2)
{
  if (a2)
    return (a1 + a2 - 1) / a2 * a2;
  else
    return (a1 + 1) & 0xFFFFFFFFFFFFFFFELL;
}

uint64_t _cg_png_get_y_pixels_per_meter(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = 0;
  if (a1 && a2)
  {
    if ((*(_BYTE *)(a2 + 8) & 0x80) != 0 && *(_BYTE *)(a2 + 232) == 1)
      return *(unsigned int *)(a2 + 228);
    else
      return 0;
  }
  return result;
}

uint64_t _cg_png_get_x_pixels_per_meter(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = 0;
  if (a1 && a2)
  {
    if ((*(_BYTE *)(a2 + 8) & 0x80) != 0 && *(_BYTE *)(a2 + 232) == 1)
      return *(unsigned int *)(a2 + 224);
    else
      return 0;
  }
  return result;
}

uint64_t _cg_png_get_interlace_type(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = 0;
  if (a1)
  {
    if (a2)
      return *(unsigned __int8 *)(a2 + 40);
  }
  return result;
}

uint64_t _cg_png_get_image_width(uint64_t a1, unsigned int *a2)
{
  uint64_t result;

  result = 0;
  if (a1)
  {
    if (a2)
      return *a2;
  }
  return result;
}

uint64_t _cg_png_get_image_height(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = 0;
  if (a1)
  {
    if (a2)
      return *(unsigned int *)(a2 + 4);
  }
  return result;
}

uint64_t _cg_png_get_channels(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = 0;
  if (a1)
  {
    if (a2)
      return *(unsigned __int8 *)(a2 + 41);
  }
  return result;
}

CGColorSpace *PNGReadPlugin::Get_colorspace(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, double *a5)
{
  int color_type;
  CGColorSpace *cHRM_colorspace;
  UInt8 *valid;
  int v13;
  BOOL v14;
  _BOOL4 v15;
  uint64_t v17;
  CGColorSpaceRef Indexed;
  CGColorSpaceRef v19;
  CFIndex length;
  void *__src;
  _QWORD __dst[97];

  __dst[96] = *MEMORY[0x1E0C80C00];
  color_type = _cg_png_get_color_type(a3, a4);
  *a5 = 0.0;
  if (*(_BYTE *)(a2 + 25))
  {
    cHRM_colorspace = (CGColorSpace *)CGColorSpaceCreateFromCICP();
    if (cHRM_colorspace)
      goto LABEL_25;
  }
  valid = (UInt8 *)_cg_png_get_valid(a3, a4, 0x1000u);
  if (!(_DWORD)valid)
    goto LABEL_24;
  __src = 0;
  __dst[0] = 0;
  length = 0;
  valid = (UInt8 *)_cg_png_get_iCCP(a3, a4, __dst, &length, (unsigned int **)&__src, (_DWORD *)&length + 1);
  if (HIDWORD(length) < 0x81)
  {
    if (color_type != 3)
    {
      v14 = 0;
      LOBYTE(v15) = 0;
LABEL_19:
      if ((color_type & 2) != 0)
        LOBYTE(v15) = v14;
      if (v15)
        goto LABEL_24;
      valid = (UInt8 *)__src;
      goto LABEL_23;
    }
LABEL_24:
    cHRM_colorspace = PNGReadPlugin::Get_cHRM_colorspace((uint64_t)valid, a3, a4, a5);
    goto LABEL_25;
  }
  valid = (UInt8 *)__src;
  v13 = *((unsigned __int8 *)__src + 16);
  if (v13 == 71)
  {
    if (*((_BYTE *)__src + 17) == 82 && *((_BYTE *)__src + 18) == 65)
    {
      v15 = 0;
      v14 = *((_BYTE *)__src + 19) == 89;
      goto LABEL_16;
    }
  }
  else if (v13 == 82 && *((_BYTE *)__src + 17) == 71 && *((_BYTE *)__src + 18) == 66)
  {
    v14 = 0;
    v15 = *((unsigned __int8 *)__src + 19) == 32;
    goto LABEL_16;
  }
  v15 = 0;
  v14 = 0;
LABEL_16:
  if (color_type != 3)
    goto LABEL_19;
  if (!v15)
    goto LABEL_24;
LABEL_23:
  valid = (UInt8 *)CGColorSpaceCreateWithCopyOfData(valid, HIDWORD(length));
  cHRM_colorspace = (CGColorSpace *)valid;
  if (!valid)
    goto LABEL_24;
LABEL_25:
  if (color_type == 3 && !_cg_png_get_valid(a3, a4, 0x10u))
  {
    if (!cHRM_colorspace)
      cHRM_colorspace = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
    if (!*(_BYTE *)(a2 + 32))
    {
      bzero(__dst, 0x300uLL);
      __src = 0;
      HIDWORD(length) = 0;
      _cg_png_get_PLTE(a3, a4, &__src, (_DWORD *)&length + 1);
      v17 = SHIDWORD(length);
      memcpy(__dst, __src, 3 * SHIDWORD(length));
      if (*(_BYTE *)(a1 + 157))
      {
        Indexed = CGColorSpaceCreateIndexed(cHRM_colorspace, v17 - 1, (const unsigned __int8 *)__dst);
        if (Indexed)
        {
          v19 = Indexed;
          CGColorSpaceRelease(cHRM_colorspace);
          return v19;
        }
      }
    }
  }
  return cHRM_colorspace;
}

CGColorSpaceRef PNGReadPlugin::Get_cHRM_colorspace(uint64_t a1, uint64_t a2, uint64_t a3, double *a4)
{
  int color_type;
  CFStringRef *v8;
  CGColorSpaceRef result;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  double v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;

  *a4 = 0.0;
  color_type = _cg_png_get_color_type(a2, a3);
  if (_cg_png_get_valid(a2, a3, 0x800u))
  {
    if ((color_type & 2) == 0)
    {
      v8 = (CFStringRef *)MEMORY[0x1E0C9D978];
      return CGColorSpaceCreateWithName(*v8);
    }
LABEL_21:
    v8 = (CFStringRef *)MEMORY[0x1E0C9DA10];
    return CGColorSpaceCreateWithName(*v8);
  }
  if (_cg_png_get_valid(a2, a3, 4u) && _cg_png_get_valid(a2, a3, 1u))
  {
    v32 = 0.0;
    v33 = 0.0;
    v31 = 0.0;
    v29 = 0.0;
    v30 = 0.0;
    v27 = 0.0;
    v28 = 0.0;
    v25 = 0.0;
    v26 = 0.0;
    _cg_png_get_cHRM(a2, a3, &v32, &v31, &v30, &v29, &v28, &v27, &v26, &v25);
    _cg_png_get_gAMA(a2, a3, &v33);
    result = 0;
    if (v33 > 0.0 && v32 > 0.0 && v31 > 0.0)
    {
      if ((color_type & 2) != 0 && v30 > 0.0 && v29 > 0.0 && v28 > 0.0 && v27 > 0.0 && v26 > 0.0 && v25 > 0.0)
      {
        v10 = v32;
        v11 = v31;
        v12 = v30;
        v13 = v29;
        v14 = v28;
        v15 = v27;
        v16 = v26;
        v17 = v25;
        v18 = 1.0 / v33;
        return CGColorSpaceCreateCalRGB(v10, v11, v12, v13, v14, v15, v16, v17, v18);
      }
      if (color_type == 3)
        return 0;
      v22 = v32;
      v23 = v31;
      v24 = 1.0 / v33;
      return CGColorSpaceCreateCalGray(v22, v23, v24);
    }
  }
  else
  {
    if (!_cg_png_get_valid(a2, a3, 1u))
      return 0;
    _cg_png_get_gAMA(a2, a3, a4);
    v19 = *a4;
    if ((color_type & 2) == 0)
    {
      v20 = 1.0 / v19;
      return CGColorSpaceCreateCalGray(0.3127, 0.329, v20);
    }
    if (vabdd_f64(2.2, v19) < 0.00003)
      goto LABEL_21;
    v21 = 1.0 / v19;
    return CGColorSpaceCreateCalRGB(0.3127, 0.329, 0.64, 0.33, 0.3, 0.6, 0.15, 0.06, v21);
  }
  return result;
}

uint64_t png_reciprocal(int a1)
{
  double v1;
  double v2;
  BOOL v3;
  unsigned int v4;

  v1 = 1.0e10 / (double)a1 + 0.5;
  v2 = floor(v1);
  v3 = v2 < -2147483650.0 || v2 > 2147483650.0;
  v4 = vcvtmd_s64_f64(v1);
  if (v3)
    return 0;
  else
    return v4;
}

float _cg_png_get_pixel_aspect_ratio(uint64_t a1, uint64_t a2)
{
  float result;
  unsigned int v3;

  result = 0.0;
  if (a1 && a2 && (*(_BYTE *)(a2 + 8) & 0x80) != 0)
  {
    v3 = *(_DWORD *)(a2 + 224);
    if (v3)
      return (float)*(unsigned int *)(a2 + 228) / (float)v3;
  }
  return result;
}

uint64_t _cg_png_get_gAMA(uint64_t a1, uint64_t a2, double *a3)
{
  uint64_t result;

  result = 0;
  if (a1)
  {
    if (a2)
    {
      result = 0;
      if (a3)
      {
        if ((*(_WORD *)(a2 + 126) & 1) != 0)
        {
          *a3 = (double)*(int *)(a2 + 52) * 0.00001;
          return 1;
        }
      }
    }
  }
  return result;
}

uint64_t _cg_png_get_cHRM(uint64_t a1, uint64_t a2, double *a3, double *a4, double *a5, double *a6, double *a7, double *a8, double *a9, double *a10)
{
  uint64_t result;

  result = 0;
  if (a1 && a2)
  {
    if ((*(_WORD *)(a2 + 126) & 2) != 0)
    {
      if (a3)
        *a3 = (double)*(int *)(a2 + 80) * 0.00001;
      if (a4)
        *a4 = (double)*(int *)(a2 + 84) * 0.00001;
      if (a5)
        *a5 = (double)*(int *)(a2 + 56) * 0.00001;
      if (a6)
        *a6 = (double)*(int *)(a2 + 60) * 0.00001;
      if (a7)
        *a7 = (double)*(int *)(a2 + 64) * 0.00001;
      if (a8)
        *a8 = (double)*(int *)(a2 + 68) * 0.00001;
      if (a9)
        *a9 = (double)*(int *)(a2 + 72) * 0.00001;
      if (a10)
        *a10 = (double)*(int *)(a2 + 76) * 0.00001;
      return 4;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t _cg_png_get_sRGB(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t result;

  result = 0;
  if (a1)
  {
    if (a2)
    {
      result = 0;
      if (a3)
      {
        if ((*(_DWORD *)(a2 + 8) & 0x800) != 0)
        {
          *a3 = *(unsigned __int16 *)(a2 + 124);
          return 2048;
        }
      }
    }
  }
  return result;
}

uint64_t _cg_png_get_iCCP(uint64_t a1, uint64_t a2, _QWORD *a3, _DWORD *a4, unsigned int **a5, _DWORD *a6)
{
  uint64_t result;
  unsigned int *v8;

  result = 0;
  if (a1)
  {
    if (a2)
    {
      result = 0;
      if (a6)
      {
        if (a5 && a3 && (*(_DWORD *)(a2 + 8) & 0x1000) != 0)
        {
          v8 = *(unsigned int **)(a2 + 136);
          *a3 = *(_QWORD *)(a2 + 128);
          *a5 = v8;
          *a6 = bswap32(*v8);
          if (a4)
            *a4 = 0;
          return 4096;
        }
      }
    }
  }
  return result;
}

uint64_t _cg_png_set_crc_action(uint64_t result, int a2, int a3)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;

  if (result)
  {
    v4 = result;
    switch(a2)
    {
      case 2:
        result = png_warning(result, "Can't discard critical data on CRC error");
        goto LABEL_4;
      case 3:
        v5 = *(_DWORD *)(result + 80) & 0xFFFFF3FF | 0x400;
        goto LABEL_7;
      case 4:
        v5 = *(_DWORD *)(result + 80) | 0xC00;
        goto LABEL_7;
      case 5:
        goto LABEL_8;
      default:
LABEL_4:
        v5 = *(_DWORD *)(v4 + 80) & 0xFFFFF3FF;
LABEL_7:
        *(_DWORD *)(v4 + 80) = v5;
LABEL_8:
        switch(a3)
        {
          case 1:
            v6 = *(_DWORD *)(v4 + 80) & 0xFFFFFCFF | 0x200;
            goto LABEL_13;
          case 3:
            v6 = *(_DWORD *)(v4 + 80) & 0xFFFFFCFF | 0x100;
            goto LABEL_13;
          case 4:
            v6 = *(_DWORD *)(v4 + 80) | 0x300;
            goto LABEL_13;
          case 5:
            return result;
          default:
            v6 = *(_DWORD *)(v4 + 80) & 0xFFFFFCFF;
LABEL_13:
            *(_DWORD *)(v4 + 80) = v6;
            break;
        }
        break;
    }
  }
  return result;
}

uint64_t _cg_png_get_PLTE(uint64_t a1, uint64_t a2, _QWORD *a3, _DWORD *a4)
{
  uint64_t result;

  result = 0;
  if (a1)
  {
    if (a2)
    {
      result = 0;
      if (a3)
      {
        if ((*(_DWORD *)(a2 + 8) & 8) != 0)
        {
          *a3 = *(_QWORD *)(a2 + 24);
          *a4 = *(unsigned __int16 *)(a2 + 32);
          return 8;
        }
      }
    }
  }
  return result;
}

CGColorSpaceRef CGColorSpaceCreateCalGray(float a1, float a2, float a3)
{
  CFStringRef *v6;
  CGColorSpaceRef v7;
  const void *v8;
  const void *Profile;
  _BYTE v11[24];
  CFMutableArrayRef v12;
  void *v13;
  uint64_t v14;
  CFMutableArrayRef v15;
  void *v16;
  uint64_t v17;
  CFMutableArrayRef v18;
  void *value;
  uint64_t v20;
  _QWORD v21[3];

  if (fabs(a1 + -0.3127) >= 0.0005 || fabs(a2 + -0.329) >= 0.0005)
    goto LABEL_9;
  if (fabs(a3 + -2.2) < 0.0005)
  {
    v6 = (CFStringRef *)MEMORY[0x1E0C9D978];
    goto LABEL_7;
  }
  if (fabs(a3 + -1.0) >= 0.0005)
  {
LABEL_9:
    memset(v21, 0, sizeof(v21));
    IIODictionary::IIODictionary((IIODictionary *)v21);
    v18 = 0;
    value = 0;
    v20 = 0;
    IIOArray::IIOArray((IIOArray *)&v18);
    v15 = 0;
    v16 = 0;
    v17 = 0;
    IIOArray::IIOArray((IIOArray *)&v15);
    v12 = 0;
    v13 = 0;
    v14 = 0;
    IIOArray::IIOArray((IIOArray *)&v12);
    v8 = (const void *)*MEMORY[0x1E0C9AE50];
    IIODictionary::setObjectForKey((IIODictionary *)v21, (const void *)*MEMORY[0x1E0C9AE50], CFSTR("skipPhosphorsCheck"));
    IIODictionary::setObjectForKey((IIODictionary *)v21, CFSTR("Calibrated Gray Colorspace"), CFSTR("description"));
    IIODictionary::setObjectForKey((IIODictionary *)v21, v8, CFSTR("unrestrictedGamma"));
    IIODictionary::setObjectForKey((IIODictionary *)v21, CFSTR("calGray"), CFSTR("profileType"));
    IIOAddDateComponents(&v18);
    IIODictionary::setObjectForKey((IIODictionary *)v21, value, CFSTR("Date"));
    IIONumber::IIONumber((IIONumber *)v11, a3);
    IIODictionary::setObjectForKey((uint64_t)v21, (uint64_t)v11, CFSTR("kGamma"));
    IIONumber::~IIONumber((IIONumber *)v11);
    IIOAddXYZfrom_xy(&v15, a1, a2, 1.0);
    IIODictionary::setObjectForKey((IIODictionary *)v21, v16, CFSTR("wtpt"));
    IIOAddXYZfrom_xy(&v12, 0.0, 0.0, 0.0);
    IIODictionary::setObjectForKey((IIODictionary *)v21, v13, CFSTR("bkpt"));
    Profile = (const void *)ColorSyncMakeProfile();
    IIOArray::~IIOArray((IIOArray *)&v12);
    IIOArray::~IIOArray((IIOArray *)&v15);
    IIOArray::~IIOArray((IIOArray *)&v18);
    IIODictionary::~IIODictionary((IIODictionary *)v21);
    if (!Profile)
      return CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D978]);
    v7 = (CGColorSpaceRef)MEMORY[0x18D760CA0](Profile, 0);
    CFRelease(Profile);
    if (!v7)
      return CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D978]);
    return v7;
  }
  v6 = (CFStringRef *)MEMORY[0x1E0C9D9F0];
LABEL_7:
  v7 = CGColorSpaceCreateWithName(*v6);
  if (!v7)
    return CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D978]);
  return v7;
}

void sub_187E5B500(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  va_list va1;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  va_list va2;
  uint64_t v14;
  uint64_t v15;
  va_list va3;

  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v8 = va_arg(va2, _QWORD);
  v10 = va_arg(va2, _QWORD);
  v11 = va_arg(va2, _QWORD);
  va_copy(va3, va2);
  v12 = va_arg(va3, _QWORD);
  v14 = va_arg(va3, _QWORD);
  v15 = va_arg(va3, _QWORD);
  IIONumber::~IIONumber((IIONumber *)va);
  IIOArray::~IIOArray((IIOArray *)va1);
  IIOArray::~IIOArray((IIOArray *)va2);
  IIOArray::~IIOArray((IIOArray *)va3);
  IIODictionary::~IIODictionary((IIODictionary *)(v2 - 72));
  _Unwind_Resume(a1);
}

uint64_t _cg_png_set_palette_to_rgb(uint64_t result)
{
  int v1;

  if (result)
  {
    v1 = *(_DWORD *)(result + 80);
    if ((v1 & 0x40) != 0)
    {
      return png_app_error(result, "invalid after png_start_read_image or png_read_update_info");
    }
    else
    {
      *(_DWORD *)(result + 80) = v1 | 0x4000;
      *(_DWORD *)(result + 88) |= 0x2001000u;
    }
  }
  return result;
}

uint64_t ImageIO_make_purgeable(const void *a1)
{
  uint64_t result;
  int v3;

  result = IIO_XPCServer();
  if ((result & 1) == 0)
  {
    if ((gIIODebugFlags & 0xC0) != 0)
    {
      ImageIOLog("    ImageIO_make_purgeable:     %14p\n", a1);
      if ((gIIODebugFlags & 0x80) != 0)
        IIODebug_ShowBacktrace(1);
    }
    v3 = 1;
    result = MEMORY[0x18D7630AC](*MEMORY[0x1E0C83DA0], a1, 0, &v3);
    if ((_DWORD)result)
    {
      if ((gIIODebugFlags & 0xC0) != 0)
        return (uint64_t)ImageIOLog("    vm_purgable_control-SET_STATE-VM_PURGABLE_VOLATILE : %ld\n", (int)result);
    }
  }
  return result;
}

_OWORD *imageio_key_retain(__int128 *a1, void **a2, void *a3)
{
  _OWORD *result;
  __int128 v6;
  __int128 v7;

  result = malloc_type_calloc(0x2CuLL, 1uLL, 0x851384CFuLL);
  if (result)
  {
    v6 = *a1;
    v7 = a1[1];
    *(_OWORD *)((char *)result + 28) = *(__int128 *)((char *)a1 + 28);
    *result = v6;
    result[1] = v7;
  }
  *a2 = result;
  return result;
}

BOOL imageio_make_nonpurgeable(void *a1, void *a2)
{
  if ((gIIODebugFlags & 0x202) != 0)
    ImageIOLog("    imageio_make_nonpurgeable value: %p   user_data: %p\n", a1, a2);
  return ImageIO_make_non_purgeable(a1) == 0;
}

uint64_t ImageIO_make_non_purgeable(const void *a1)
{
  int v3;
  int v4;

  if ((IIO_XPCServer() & 1) != 0)
    return 0;
  if ((gIIODebugFlags & 0xC0) != 0)
  {
    ImageIOLog("    ImageIO_make_non_purgeable: %14p\n", a1);
    if ((gIIODebugFlags & 0x80) != 0)
      IIODebug_ShowBacktrace(1);
  }
  v4 = 0;
  v3 = MEMORY[0x18D7630AC](*MEMORY[0x1E0C83DA0], a1, 0, &v4);
  if (v3 && (gIIODebugFlags & 0xC0) != 0)
    ImageIOLog("    vm_purgable_control-SET_STATE-VM_PURGABLE_NONVOLATILE : %ld\n", v3);
  if (v4 == 2)
    return 14;
  else
    return 0;
}

uint64_t IIO_Reader_GIF::parse(IIO_Reader_GIF *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5, IIODictionary *a6)
{
  char v10;
  unsigned __int16 *v11;
  IIOImageRead *v12;
  GlobalGIFInfo *v13;
  unsigned int FrameCount;
  unint64_t ImageDescOffset;
  unsigned int v16;
  CGImageSourceStatus v17;
  char v18;
  char v19;
  int v20;
  int v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  unint64_t v25;
  int v26;
  __int16 v27;
  __int16 v28;
  __int16 v29;
  int v30;
  unint64_t v31;
  char *v32;
  char *v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  char *v37;
  int *v38;
  int v39;
  int v40;
  int v41;
  _BOOL4 v42;
  int v43;
  int Code;
  unint64_t v45;
  int v46;
  int v47;
  unint64_t v48;
  int Error;
  int v50;
  char v51;
  int v52;
  CFStringRef v53;
  CFStringRef v54;
  unsigned int v55;
  int v56;
  int v57;
  unint64_t v58;
  unsigned int v59;
  int v60;
  int v61;
  double v62;
  const void **v63;
  unint64_t i;
  const __CFAllocator *alloc;
  unsigned int *v68;
  CGImageSourceStatus *v69;
  BOOL v70;
  __CFSet *theSet;
  IIODictionary *context;
  int v73;
  IIOImageReadSession *v74;
  char v75;
  unsigned __int16 v76;
  int v77;
  __int16 v78;
  __int16 v79;
  int v80;
  int v81;
  __int16 v82;
  __int16 v83;
  unsigned __int16 v84[4];
  void *v85;
  uint64_t v86;
  unsigned __int16 v87[4];
  void *v88;
  uint64_t v89;
  _BYTE v90[24];
  _BYTE v91[30];
  unsigned __int16 v92;
  _BYTE v93[24];
  _BYTE v94[24];
  __int128 v95;
  __int16 v96;
  __int16 v97;
  __int16 v98;
  __int16 v99;
  int v100;
  __int16 v101;
  __int16 v102;
  int v103;
  __int16 v104;
  __int16 v105;
  unsigned __int16 v106[8];
  __int128 v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  int v111;
  uint64_t v112;
  int v113;
  unsigned __int8 *v114;
  int v115;
  unsigned int v116[3];

  v115 = 0;
  v116[0] = 1;
  v114 = 0;
  v113 = 0;
  v112 = 0;
  v111 = 0;
  v109 = 0;
  v110 = 0;
  v10 = IIOSkipMetadata(a3);
  v11 = (unsigned __int16 *)_cg_DGifOpen((uint64_t)a2, (int (*)(uint64_t, _DWORD *, uint64_t))gifRead, (int *)v116);
  if (!v11)
  {
    FrameCount = 0;
    v16 = 0;
    v17 = kCGImageStatusIncomplete;
    if (a4)
      goto LABEL_150;
    goto LABEL_151;
  }
  v69 = a4;
  v12 = IIOImageReadSession::globalInfoForType(a2, 1195984416);
  context = a6;
  if (v12)
  {
    v13 = v12;
    if (!a6)
    {
      FrameCount = GlobalGIFInfo::lastFrameCount(v12);
      if (FrameCount)
      {
        ImageDescOffset = GlobalGIFInfo::lastImageDescOffset(v13);
        IIOImageReadSession::seek(a2, ImageDescOffset, 0);
      }
      if (*((_BYTE *)v13 + 217))
      {
        FrameCount = GlobalGIFInfo::frameCount(v13);
        v16 = 0;
        theSet = 0;
        v80 = -1;
        if (!FrameCount)
          goto LABEL_139;
LABEL_127:
        if (GlobalGIFInfo::frameSizesMatchCanvasSize(v13, *v11, v11[1]))
          goto LABEL_139;
        if (GlobalGIFInfo::frameCount(v13) == 1 && !*v11 && !v11[1])
        {
          v108 = 0;
          *(_OWORD *)v106 = 0u;
          v107 = 0u;
          GlobalGIFInfo::getFrameInfoAtIndex(v13, 0, (uint64_t)v106);
          if (!(v106[4] | v106[5]))
            *(_DWORD *)v11 = *(_DWORD *)&v106[6];
        }
        _cg_jpeg_mem_term("parse", 531, "canvas size doesn't match frame sizes\n");
        v106[0] = 0;
        v87[0] = 0;
        v84[0] = 0;
        v92 = 0;
        GlobalGIFInfo::getMinMaxFrames((uint64_t)v13, v106, v87, v84, &v92);
        v56 = (__int16)*v11;
        v57 = (__int16)v11[1];
        v58 = 4 * v56 * (uint64_t)v57 * GlobalGIFInfo::frameCount(v13);
        v59 = (__int16)v11[1] * (__int16)*v11;
        v60 = v92 * v84[0];
        v61 = GlobalGIFInfo::frameCount(v13);
        _cg_jpeg_mem_term("parse", 541, "      count: %d\n", v61);
        _cg_jpeg_mem_term("parse", 542, "canvas size: %d x %d      [%d]\n", (__int16)*v11, (__int16)v11[1], v59);
        _cg_jpeg_mem_term("parse", 543, "     memory: %lld\n", v58);
        *(_QWORD *)&v62 = _cg_jpeg_mem_term("parse", 544, "  max frame: (%d, %d, %d, %d)   [%d]\n", v106[0], v87[0], v84[0], v92, v60).n128_u64[0];
        if (v58 < 0x3B9ACA01)
        {
          if (FrameCount < 0x2711 || v59 <= 100 * v60)
            goto LABEL_139;
          _cg_jpeg_mem_term("parse", 558, "framePixel vs. canvasPixel ratio looks suspicious\n", v62);
        }
        else
        {
          _cg_jpeg_mem_term("parse", 549, " too much memory\n", v62);
        }
        FrameCount = 0;
        goto LABEL_139;
      }
      v68 = a5;
      theSet = 0;
      v70 = 1;
      goto LABEL_18;
    }
  }
  else
  {
    v13 = (GlobalGIFInfo *)operator new();
    GlobalGIFInfo::GlobalGIFInfo(v13);
    IIOImageReadSession::setGlobalInfo((IIOImageRead **)a2, 1195984416, v13, (void (*)(void *))globalGIFInfoReleaseProc);
    *((_BYTE *)v13 + 216) = *((_BYTE *)v11 + 6);
    GlobalGIFInfo::setGlobalColorMap((uint64_t)v13, *((_QWORD *)v11 + 2));
  }
  v70 = a6 == 0;
  if (a6)
    v18 = v10;
  else
    v18 = 1;
  v68 = a5;
  if ((v18 & 1) != 0)
  {
    FrameCount = 0;
    theSet = 0;
  }
  else
  {
    theSet = CFSetCreateMutable(0, 0, MEMORY[0x1E0C9B3B0]);
    v70 = 0;
    FrameCount = 0;
  }
LABEL_18:
  v19 = 0;
  v82 = 0;
  v73 = 0;
  alloc = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v80 = -1;
  v74 = a2;
  do
  {
    v116[0] = _cg_DGifGetRecordType((uint64_t)v11, &v115);
    if (!v116[0])
    {
      IIOImageReadSession::getSize(a2);
      _cg_jpeg_mem_term("parse", 227, "    GIF-ERROR: DGifGetRecordType (%d)  fileSize: %ld\n");
      goto LABEL_163;
    }
    v20 = v115;
    switch(v115)
    {
      case 2:
        v25 = IIOImageReadSession::seek(a2, 0, 1);
        if ((v19 & 1) != 0)
        {
          v26 = (unsigned __int16)v109;
          v27 = v110;
          v28 = WORD2(v110);
          if (HIDWORD(v110) == -1)
            v29 = 8;
          else
            v29 = 10;
          v83 = v29;
          v30 = v82;
        }
        else
        {
          v26 = 0;
          v27 = 0;
          v28 = 0;
          v82 = FrameCount;
          v83 = 0;
          v30 = (__int16)FrameCount;
        }
        v116[0] = _cg_DGifGetImageDesc((uint64_t)v11);
        if (!v116[0])
        {
          IIOImageReadSession::getSize(a2);
          _cg_jpeg_mem_term("parse", 301, "    GIF-ERROR: DGifGetImageDesc (%d)   fileSize: %ld\n");
          goto LABEL_163;
        }
        v38 = (int *)*((_QWORD *)v11 + 6);
        v79 = v27;
        if (v38)
          v77 = *v38;
        else
          LOWORD(v77) = 0;
        v39 = v11[16];
        v40 = v11[17];
        v81 = v11[19];
        v78 = v28;
        v76 = v11[18];
        v41 = v30;
        v42 = !(v39 | v40) && v11[18] == (__int16)*v11 && v81 == (__int16)v11[1];
        v75 = *((_BYTE *)v11 + 40);
        if (FrameCount >= 2 && !v26 && !v42)
        {
          v108 = 0;
          *(_OWORD *)v106 = 0u;
          v107 = 0u;
          GlobalGIFInfo::getFrameInfoAtIndex(v13, FrameCount - 2, (uint64_t)v106);
          v82 = WORD4(v107);
          v41 = SWORD4(v107);
          LOWORD(v26) = 1;
        }
        if (v42)
        {
          if (FrameCount < 3)
          {
            v43 = 0;
          }
          else
          {
            v108 = 0;
            *(_OWORD *)v106 = 0u;
            v107 = 0u;
            GlobalGIFInfo::getFrameInfoAtIndex(v13, FrameCount - 1, (uint64_t)v106);
            v43 = BYTE4(v108) & 1;
          }
          if (v73 != 2)
            v43 = 0;
          if ((v83 & 2) == 0 || v43)
          {
            v41 = (__int16)(FrameCount - 1) & ~((__int16)(FrameCount - 1) >> 31);
            v82 = v41;
          }
        }
        Code = _cg_DGifGetCode((uint64_t)v11, &v111, (uint64_t)&v112);
        v116[0] = Code;
        if (!Code)
        {
          _cg_jpeg_mem_term("parse", 347, "    GIF-ERROR: DGifGetCode (%d)\n");
LABEL_163:
          v16 = -39;
LABEL_118:
          a5 = v68;
          if (FrameCount)
            goto LABEL_127;
          goto LABEL_139;
        }
        if (!FrameCount && !v112)
        {
          _cg_jpeg_mem_term("parse", 349, "    GIF-ERROR: frame[0] has no codeBlocks\n");
          FrameCount = 0;
          v16 = -50;
          a5 = v68;
          goto LABEL_139;
        }
        v45 = v25;
        if (v112)
        {
          v46 = 255;
          while (1)
          {
            v47 = v46;
            Code = _cg_DGifGetCodeNext((uint64_t)v11, (uint64_t)&v112);
            v116[0] = Code;
            if (!Code)
              break;
            v46 = v47 + 255;
            if (!v112)
            {
              if (!FrameCount)
                goto LABEL_84;
              goto LABEL_78;
            }
          }
          Error = _cg_GifLastError((uint64_t)v11);
          _cg_jpeg_mem_term("parse", 355, "    GIF-ERROR: DGifGetCodeNext (%d)\n", Error);
          Code = -39;
          v116[0] = -39;
          if (FrameCount)
            goto LABEL_78;
        }
        else
        {
          v47 = 255;
          if (FrameCount)
            goto LABEL_78;
        }
LABEL_84:
        GlobalGIFInfo::setSize((uint64_t)v13, (__int16)*v11, (__int16)v11[1]);
        Code = v116[0];
LABEL_78:
        if (Code == 1)
        {
          *(_QWORD *)&v95 = v45;
          WORD4(v95) = v39;
          WORD5(v95) = v40;
          WORD6(v95) = v76;
          HIWORD(v95) = v81;
          v96 = v26;
          v97 = v79;
          v98 = v78;
          v99 = 0;
          v100 = v41;
          v101 = v77;
          v102 = 0;
          v103 = v47;
          v104 = v83 | ((4 * v75) | v42);
          v105 = 0;
          GlobalGIFInfo::setFrameInfoAtIndex((uint64_t)v13, &v95, FrameCount++);
          GlobalGIFInfo::setLastFrameCount((uint64_t)v13, FrameCount);
          a2 = v74;
          v48 = IIOImageReadSession::seek(v74, 0, 1);
          if (v48 == -1)
            goto LABEL_117;
          GlobalGIFInfo::setLastImageDescOffset((uint64_t)v13, v48);
          if (v116[0] != 1)
            goto LABEL_117;
          v19 = 0;
        }
        else
        {
          v19 = 0;
          a2 = v74;
        }
        goto LABEL_114;
      case 3:
        v31 = IIOImageReadSession::seek(a2, 0, 1);
        v116[0] = _cg_DGifGetExtension((uint64_t)v11, &v113, (uint64_t)&v114);
        if (!v116[0])
        {
          _cg_jpeg_mem_term("parse", 396, "    GIF-ERROR: DGifGetExtension (%d)\n");
          goto LABEL_163;
        }
        v32 = (char *)malloc_type_malloc(0, 0x8447595BuLL);
        if (v32)
        {
          v33 = v32;
          v34 = 0;
          while (1)
          {
            if (!v114)
            {
              if (v113 == 255)
              {
                if (v34 >= 0xE)
                {
                  v50 = strncmp(v33, gNetscape[0], 0xBuLL);
                  v51 = v70;
                  if (v50)
                    v51 = 1;
                  if ((v51 & 1) == 0)
                  {
                    if (*((_WORD *)v33 + 6))
                      v52 = *((unsigned __int16 *)v33 + 6) + 1;
                    else
                      v52 = 0;
                    IIONumber::IIONumber((IIONumber *)v94, v52);
                    IIODictionary::setObjectForKeyGroup(context, (uint64_t)v94, CFSTR("LoopCount"), CFSTR("{GIF}"));
                    IIONumber::~IIONumber((IIONumber *)v94);
                  }
                }
                if (v34 >= 0xB && !strncmp(v33, gICCMagic[0], 0xBuLL))
                  GlobalGIFInfo::setColorSyncProfileOffset((uint64_t)v13, v31);
              }
              else if (v113 == 254)
              {
                if (theSet)
                {
                  v53 = CFStringCreateWithBytes(alloc, (const UInt8 *)v33, v34, 0x600u, 0);
                  if (v53)
                  {
                    v54 = v53;
                    CFSetAddValue(theSet, v53);
                    CFRelease(v54);
                  }
                }
              }
              else if (v113 == 249
                     && _cg_DGifExtensionToGCB(v34, (unsigned __int8 *)v33, (uint64_t)&v109) == 1)
              {
                v73 = (unsigned __int16)v109;
                v19 = 1;
              }
              free(v33);
              goto LABEL_114;
            }
            v35 = *v114;
            v36 = v34 + v35;
            if (__CFADD__(v34, v35))
              break;
            v37 = (char *)reallocf(v33, v34 + v35);
            if (!v37)
            {
              _cg_jpeg_mem_term("parse", 410, "    GIF-ERROR: realloc(%d) failed\n", v34 + *v114);
              goto LABEL_117;
            }
            v33 = v37;
            memcpy(&v37[v34], v114 + 1, *v114);
            v34 = v36;
            v116[0] = _cg_DGifGetExtensionNext((uint64_t)v11, (uint64_t)&v114);
            if (!v116[0])
            {
              _cg_jpeg_mem_term("parse", 416, "    GIF-ERROR: DGifGetExtensionNext (%d)\n", 0);
              v16 = -39;
              a5 = v68;
              goto LABEL_126;
            }
          }
          v16 = 0;
          a5 = v68;
LABEL_126:
          free(v33);
          if (!FrameCount)
            goto LABEL_139;
          goto LABEL_127;
        }
        goto LABEL_117;
      case 4:
        GlobalGIFInfo::setFinal((uint64_t)v13, 1);
        if (FrameCount != 1)
          goto LABEL_113;
        v21 = (__int16)*v11;
        v22 = (__int16)v11[1];
        if (v21 | v22)
        {
          v24 = (__int16)v11[1];
          v23 = (__int16)*v11;
          if (v11[16])
            goto LABEL_110;
        }
        else
        {
          if (v11[16] || v11[17])
          {
            v23 = 0;
            v24 = 0;
            goto LABEL_110;
          }
          v23 = (__int16)v11[18];
          v24 = (__int16)v11[19];
        }
        if (!v11[17] && v23 > (__int16)v11[18])
        {
          v55 = (__int16)v11[19];
          if (v24 > v55)
            v23 = (__int16)v11[18];
          if (v24 >= v55)
            v24 = (__int16)v11[19];
        }
LABEL_110:
        v80 = 0;
        FrameCount = 1;
        if (v23 != v21 && v24 != v22)
        {
          GlobalGIFInfo::setSize((uint64_t)v13, v23, v24);
LABEL_113:
          v80 = 0;
        }
LABEL_114:
        v20 = v115;
        break;
    }
  }
  while (v20 != 4);
  if (v70)
  {
LABEL_117:
    v16 = 0;
    goto LABEL_118;
  }
  a5 = v68;
  if ((IIODictionary::containsKeyGroup(context, CFSTR("LoopCount"), CFSTR("{GIF}")) & 1) == 0)
  {
    IIONumber::IIONumber((IIONumber *)v93, 1);
    IIODictionary::setObjectForKeyGroup(context, (uint64_t)v93, CFSTR("LoopCount"), CFSTR("{GIF}"));
    IIONumber::~IIONumber((IIONumber *)v93);
  }
  v16 = 0;
  if (FrameCount)
    goto LABEL_127;
LABEL_139:
  if (context)
  {
    if (*((_QWORD *)v11 + 2))
      v63 = (const void **)MEMORY[0x1E0C9AE50];
    else
      v63 = (const void **)MEMORY[0x1E0C9AE40];
    IIODictionary::setObjectForKeyGroup(context, *v63, CFSTR("HasGlobalColorMap"), CFSTR("{GIF}"));
    IIONumber::IIONumber((IIONumber *)v91, (__int16)*v11);
    IIODictionary::setObjectForKeyGroup(context, (uint64_t)v91, CFSTR("CanvasPixelWidth"), CFSTR("{GIF}"));
    IIONumber::~IIONumber((IIONumber *)v91);
    IIONumber::IIONumber((IIONumber *)v90, (__int16)v11[1]);
    IIODictionary::setObjectForKeyGroup(context, (uint64_t)v90, CFSTR("CanvasPixelHeight"), CFSTR("{GIF}"));
    IIONumber::~IIONumber((IIONumber *)v90);
    *(_QWORD *)v87 = 0;
    v88 = 0;
    v89 = 0;
    IIOArray::IIOArray((IIOArray *)v87);
    for (i = 0; i < GlobalGIFInfo::frameCount(v13); ++i)
    {
      v108 = 0;
      *(_OWORD *)v106 = 0u;
      v107 = 0u;
      GlobalGIFInfo::getFrameInfoAtIndex(v13, i, (uint64_t)v106);
      *(_QWORD *)v84 = 0;
      v85 = 0;
      v86 = 0;
      IIODictionary::IIODictionary((IIODictionary *)v84);
      IIO_addDelayTimeToDictionary(WORD1(v107), (IIODictionary *)v84, 0);
      IIOArray::addObject((CFMutableArrayRef *)v87, v85);
      IIODictionary::~IIODictionary((IIODictionary *)v84);
    }
    IIODictionary::setObjectForKeyGroup(context, v88, CFSTR("FrameInfo"), CFSTR("{GIF}"));
    if (theSet)
    {
      gCommentIndex = 0;
      CFSetApplyFunction(theSet, (CFSetApplierFunction)GifSetApplier, context);
      CFRelease(theSet);
    }
    IIOArray::~IIOArray((IIOArray *)v87);
  }
  a4 = v69;
  v17 = v80;
  if (v69)
LABEL_150:
    *a4 = v17;
LABEL_151:
  if (a5)
    *a5 = FrameCount;
  if (v11)
    _cg_DGifCloseFile((uint64_t)v11, 0);
  if (v16 == -39 && FrameCount > 1)
    return 0;
  else
    return v16;
}

void sub_187E5C46C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44)
{
  IIONumber::~IIONumber((IIONumber *)&a44);
  _Unwind_Resume(a1);
}

uint64_t _cg_DGifGetCodeNext(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int (*v5)(uint64_t, unsigned __int8 *, uint64_t);
  size_t v6;
  size_t v7;
  uint64_t v8;
  int (*v9)(uint64_t, uint64_t);
  size_t v10;
  uint64_t result;
  unsigned __int8 __ptr;

  __ptr = 0;
  v4 = *(_QWORD *)(a1 + 96);
  v5 = *(int (**)(uint64_t, unsigned __int8 *, uint64_t))(v4 + 48);
  if (v5)
    v6 = v5(a1, &__ptr, 1);
  else
    v6 = fread(&__ptr, 1uLL, 1uLL, *(FILE **)(v4 + 40));
  if (v6 != 1)
    goto LABEL_12;
  v7 = __ptr;
  if (!__ptr)
  {
    *(_QWORD *)a2 = 0;
    *(_BYTE *)(v4 + 64) = 0;
    result = 1;
    *(_QWORD *)(v4 + 32) = 0;
    return result;
  }
  *(_QWORD *)a2 = v4 + 64;
  *(_BYTE *)(v4 + 64) = v7;
  v8 = *(_QWORD *)(a1 + 96);
  v9 = *(int (**)(uint64_t, uint64_t))(v8 + 48);
  v10 = v9 ? v9(a1, *(_QWORD *)a2 + 1) : fread((void *)(*(_QWORD *)a2 + 1), 1uLL, v7, *(FILE **)(v8 + 40));
  if (v10 == __ptr)
    return 1;
LABEL_12:
  result = 0;
  *(_DWORD *)(a1 + 80) = 102;
  return result;
}

unint64_t gifRead(uint64_t a1, _BYTE *a2, int a3)
{
  return IIOImageReadSession::getBytes(*(IIOImageReadSession **)(a1 + 88), a2, a3);
}

unint64_t IIOImageReadSession::seek(IIOImageReadSession *this, unint64_t a2, int a3)
{
  IIOImageRead *v4;
  unint64_t Size;
  uint64_t v8;
  unint64_t v10;

  v4 = (IIOImageRead *)*((_QWORD *)this + 4);
  if (!v4)
    return -1;
  Size = IIOImageRead::getSize(v4);
  if (a3)
  {
    if (a3 == 1)
    {
      a2 += *((_QWORD *)this + 5);
    }
    else
    {
      v8 = -1;
      if (a3 != 2 || Size == -1)
        return v8;
      a2 += Size;
    }
  }
  if (Size != -1 && a2 > Size)
    return -1;
  v10 = *((_QWORD *)this + 5);
  if (a2 < v10)
  {
    v10 = 0;
    *((_QWORD *)this + 5) = 0;
  }
  if (a2 > v10)
  {
    IIOImageReadSession::skipBytes(this, a2 - v10);
    v10 = *((_QWORD *)this + 5);
  }
  if (v10 == a2)
    return a2;
  else
    return -1;
}

BOOL IIOImageSource::doBindToReader(IIOImageSource *this)
{
  IIO_ReaderHandler *Source;
  IIOImageSource *ReaderHandler;
  _BOOL4 isFinal;
  uint64_t v5;
  size_t v6;
  int v7;
  const UInt8 *v8;
  unsigned __int8 *v9;
  unint64_t Size;
  unsigned __int8 *v11;
  CFIndex v12;
  IIO_Reader *v13;
  _BOOL4 v14;
  const __CFString *v15;
  const __CFString *v16;
  char v17;
  unsigned int v18;
  IIO_Reader *v19;
  const char *v20;
  int v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  signed int v26;
  unsigned int v27;
  uint64_t v28;
  int v29;
  int v30;
  unsigned int v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  char *v35;
  unsigned __int8 *v37;
  _BYTE v38[28];
  int v39;
  CFTypeRef cf;

  cf = 0;
  Source = (IIO_ReaderHandler *)CGImageSourceGetSource(*((_QWORD *)this + 2));
  ReaderHandler = (IIOImageSource *)IIO_ReaderHandler::GetReaderHandler(Source);
  v39 = 0;
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 264));
  *((_DWORD *)this + 22) = -4;
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 264));
  if (!Source)
    goto LABEL_57;
  isFinal = IIOImageRead::isFinal(Source);
  v5 = IIOImageSource::cf(ReaderHandler);
  if (!v5)
  {
    v11 = 0;
    goto LABEL_53;
  }
  v6 = v5;
  if (isFinal)
    v7 = -5;
  else
    v7 = -2;
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 264));
  *((_DWORD *)this + 22) = v7;
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 264));
  v8 = IIOImageRead::retainBytePointer(Source, (const __CFData **)&cf, 0);
  if (v8)
  {
    v9 = (unsigned __int8 *)v8;
    Size = IIOImageRead::getSize(Source);
    v11 = 0;
    goto LABEL_10;
  }
  v11 = (unsigned __int8 *)malloc_type_malloc(v6, 0x891510ECuLL);
  if (v11)
  {
    Size = IIOImageRead::getBytesAtOffset(Source, v11, 0, v6);
    v9 = v11;
LABEL_10:
    if (Size < v6)
      v6 = Size;
    if (Size < 5)
      goto LABEL_53;
    ERROR_ImageIO_DataBufferIsNotReadable(v9);
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 264));
    *((_DWORD *)this + 22) = -3;
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 264));
    v12 = IIOImageRead::getSize(Source);
    v13 = (IIO_Reader *)*((_QWORD *)this + 9);
    v37 = v11;
    if (v13
      || (v16 = (const __CFString *)*((_QWORD *)this + 7)) != 0
      && (v13 = IIO_ReaderHandler::readerForUTType(ReaderHandler, v16), (*((_QWORD *)this + 9) = v13) != 0))
    {
      v14 = isFinal;
      v15 = (const __CFString *)IIO_Reader::utType(v13);
    }
    else
    {
      v14 = isFinal;
      v15 = 0;
    }
    if (*((_BYTE *)this + 51) == 1)
      v17 = 8;
    else
      v17 = 16 * (*((_BYTE *)this + 51) != 0);
    v18 = (v17 | (*((_BYTE *)this + 54) == 6) | (4 * *((_BYTE *)this + 64)));
    v19 = IIO_ReaderHandler::readerForBytes((IIO_Reader ***)ReaderHandler, v9, v6, v15, Source, v12, v18, *((char *)this + 53), &v39);
    *((_QWORD *)this + 10) = v19;
    if (!v19 && v39 == -1400)
    {
      ImageIOLog("‼️ retrying 'readerForBytes' (ImageIOXPCService crashed?)\n");
      *((_QWORD *)this + 10) = IIO_ReaderHandler::readerForBytes((IIO_Reader ***)ReaderHandler, v9, v6, v15, Source, v12, v18, *((char *)this + 53), &v39);
      v20 = "❌";
      if (!v39)
        v20 = "✅";
      ImageIOLog("%s retrying 'readerForBytes'  err: %d\n", v20, v39);
      v19 = (IIO_Reader *)*((_QWORD *)this + 10);
    }
    if (!v19)
    {
      if (v39 == -57)
      {
        IIOString::IIOString((IIOString *)v38, v15);
        v25 = (const char *)IIOString::utf8String((IIOString *)v38);
        _cg_jpeg_mem_term("doBindToReader", 965, "*** ERROR: hint ('%s') does not match image data - kCGImageSourceFailForDataNotMatchingHint was specified --> failing\n", v25);
        IIOString::~IIOString((IIOString *)v38);
        *((_BYTE *)this + 65) = 1;
      }
      goto LABEL_52;
    }
    if ((gIIODebugFlags & 0x30000) == 0)
    {
LABEL_51:
      pthread_mutex_lock((pthread_mutex_t *)((char *)this + 264));
      *((_DWORD *)this + 22) = v14 - 1;
      pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 264));
LABEL_52:
      v11 = v37;
      goto LABEL_53;
    }
    v21 = IIO_Reader::osType(v19);
    v22 = v21 >> 24;
    v23 = MEMORY[0x1E0C80978];
    if (v21 < 0)
    {
      if (__maskrune(v22, 0x40000uLL))
        goto LABEL_30;
    }
    else if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v22 + 60) & 0x40000) != 0)
    {
LABEL_30:
      v24 = ((int)IIO_Reader::osType(*((IIO_Reader **)this + 10)) >> 24);
      goto LABEL_35;
    }
    v24 = 46;
LABEL_35:
    v26 = IIO_Reader::osType(*((IIO_Reader **)this + 10)) << 8;
    v27 = v26 >> 24;
    if (v26 < 0)
    {
      if (__maskrune(v27, 0x40000uLL))
        goto LABEL_37;
    }
    else if ((*(_DWORD *)(v23 + 4 * v27 + 60) & 0x40000) != 0)
    {
LABEL_37:
      v28 = ((int)(IIO_Reader::osType(*((IIO_Reader **)this + 10)) << 8) >> 24);
      goto LABEL_40;
    }
    v28 = 46;
LABEL_40:
    v29 = IIO_Reader::osType(*((IIO_Reader **)this + 10));
    v30 = v29 << 16;
    v31 = (__int16)v29 >> 8;
    if (v30 < 0)
    {
      if (__maskrune(v31, 0x40000uLL))
        goto LABEL_42;
    }
    else if ((*(_DWORD *)(v23 + 4 * v31 + 60) & 0x40000) != 0)
    {
LABEL_42:
      v32 = ((__int16)IIO_Reader::osType(*((IIO_Reader **)this + 10)) >> 8);
      goto LABEL_45;
    }
    v32 = 46;
LABEL_45:
    v33 = IIO_Reader::osType(*((IIO_Reader **)this + 10));
    if ((v33 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v23 + 4 * (char)v33 + 60) & 0x40000) != 0)
        goto LABEL_47;
    }
    else if (__maskrune((char)v33, 0x40000uLL))
    {
LABEL_47:
      v34 = (char)IIO_Reader::osType(*((IIO_Reader **)this + 10));
LABEL_50:
      ImageIOLog("*** doBindToReader:  _reader->osType = '%c%c%c%c'\n", v24, v28, v32, v34);
      goto LABEL_51;
    }
    v34 = 46;
    goto LABEL_50;
  }
LABEL_53:
  if (cf)
    IIOImageRead::releaseBytePointer(Source, cf);
  if (v11)
    free(v11);
LABEL_57:
  if (!*((_QWORD *)this + 10))
  {
    v35 = IIOImageRead::copySourceInfo(Source);
    _cg_jpeg_mem_term("doBindToReader", 994, "*** could not find a reader for: '%s'\n", v35);
    if (v35)
      free(v35);
  }
  return *((_QWORD *)this + 10) != 0;
}

void sub_187E5CB44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

CFIndex IIOImageRead::getSize(IIOImageRead *this)
{
  pthread_mutex_t *v2;
  CFIndex Length;
  const __CFData *v4;
  const __CFData *v5;

  if (*((_BYTE *)this + 65))
  {
    v2 = (pthread_mutex_t *)((char *)this + 376);
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 376));
    if (*((_QWORD *)this + 6))
    {
      Length = *((_QWORD *)this + 10);
    }
    else
    {
      v4 = (const __CFData *)*((_QWORD *)this + 4);
      if (v4)
        Length = CFDataGetLength(v4);
      else
        Length = 0;
    }
    pthread_mutex_unlock(v2);
  }
  else if (*((_QWORD *)this + 6))
  {
    return *((_QWORD *)this + 10);
  }
  else
  {
    v5 = (const __CFData *)*((_QWORD *)this + 4);
    if (v5)
      return CFDataGetLength(v5);
    return 0;
  }
  return Length;
}

uint64_t IIO_ReaderHandler::GetReaderHandler(IIO_ReaderHandler *this)
{
  if (IIO_ReaderHandler::GetReaderHandler(void)::readerHandlerCreate != -1)
    dispatch_once(&IIO_ReaderHandler::GetReaderHandler(void)::readerHandlerCreate, &__block_literal_global_25);
  return IIO_ReaderHandler::GetReaderHandler(void)::gIIO_ReaderHandler;
}

const UInt8 *IIOImageRead::retainBytePointer(IIOImageRead *this, const __CFData **a2, int a3)
{
  const void *v5;
  const __CFData *v6;
  const __CFData *v8;
  const __CFData *v9;

  v5 = (const void *)*((_QWORD *)this + 4);
  if (v5)
  {
    if ((gIIODebugFlags & 0x80000000000) != 0)
    {
      ImageIOLog("D   %s:%d CFRetain %p\n", "retainBytePointer", 2033, v5);
      v5 = (const void *)*((_QWORD *)this + 4);
    }
    CFRetain(v5);
    *a2 = (const __CFData *)*((_QWORD *)this + 4);
    v6 = (const __CFData *)*((_QWORD *)this + 4);
    return CFDataGetBytePtr(v6);
  }
  if (a3)
  {
    v8 = IIOImageRead::copyData(this);
    v9 = v8;
    if ((gIIODebugFlags & 0x80000000000) != 0)
      ImageIOLog("D   %s:%d copyData %p\n", "retainBytePointer", 2041, v8);
    if (v9)
    {
      *a2 = v9;
      v6 = v9;
      return CFDataGetBytePtr(v6);
    }
  }
  return 0;
}

void IIOImageRead::releaseBytePointer(IIOImageRead *this, CFTypeRef cf)
{
  if (cf)
  {
    if ((gIIODebugFlags & 0x80000000000) != 0)
      ImageIOLog("D   %s:%d CFRelease %p\n", "releaseBytePointer", 2055, cf);
    CFRelease(cf);
  }
}

uint64_t ERROR_ImageIO_DataBufferIsNotReadable(unsigned __int8 *a1)
{
  return *a1;
}

IIO_Reader *IIO_ReaderHandler::readerForBytes(IIO_Reader ***a1, const void *a2, unint64_t a3, const __CFString *a4, IIOImageRead *a5, unint64_t a6, unsigned int a7, int a8, int *a9)
{
  uint64_t v17;
  IIOXPCClient *IIOXPCClient;
  xpc_object_t v19;
  void *v20;
  xpc_object_t v21;
  xpc_object_t v22;
  void *v23;
  const char *v24;
  _xpc_connection_s *v25;
  dispatch_queue_s *v26;
  xpc_object_t v27;
  void *v28;
  xpc_object_t message_dict;
  int error_code;
  const char *v31;
  IIO_Reader *v33;
  xpc_object_t source_dict;
  void *v35;
  const char *string;
  int uint64;
  int v38;
  unsigned int v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  unsigned int v43;
  int v44;
  uint64_t v45;
  unsigned int v46;
  uint64_t v47;
  int v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  const char *v52;
  uint64_t v53;
  uint64_t v54;
  __CFString *v55;

  v17 = IIO_XPCServer();
  if ((v17 & 1) != 0)
    return IIO_ReaderHandler::readerForBytesImp(a1, (uint64_t)a2, a3, a4, a6, a7, 0, a9);
  IIOXPCClient = (IIOXPCClient *)IIOXPCClient::GetIIOXPCClient((IIOXPCClient *)v17);
  if (!IIOXPCClient::useServerForIdentification(IIOXPCClient, a5, a8))
    return IIO_ReaderHandler::readerForBytesImp(a1, (uint64_t)a2, a3, a4, a6, a7, 0, a9);
  kdebug_trace();
  v19 = xpc_dictionary_create(0, 0, 0);
  v20 = v19;
  if (v19)
  {
    v21 = iio_xpc_add_source_dict(v19);
    xpc_dictionary_set_uint64(v20, "iio_xpc_message_id", 1uLL);
    v22 = xpc_data_create(a2, a3);
    if (v22)
    {
      v23 = v22;
      xpc_dictionary_set_value(v21, "iio_xpc_src_header_data", v22);
      xpc_release(v23);
    }
    if (a4)
    {
      v53 = 0;
      v54 = 0;
      v55 = 0;
      IIOString::IIOString((IIOString *)&v53, a4);
      v24 = (const char *)IIOString::utf8String((IIOString *)&v53);
      xpc_dictionary_set_string(v21, "iio_xpc_src_hint_string", v24);
      IIOString::~IIOString((IIOString *)&v53);
    }
    xpc_dictionary_set_uint64(v21, "iio_xpc_src_file_size", a6);
    xpc_dictionary_set_uint64(v21, "iio_xpc_src_header_options", a7);
  }
  v25 = (_xpc_connection_s *)IIOXPCClient::xpc_connection(IIOXPCClient);
  v26 = (dispatch_queue_s *)IIOXPCClient::xpc_queue(IIOXPCClient);
  v27 = IIOXPCClient::send_message_with_reply(IIOXPCClient, v25, v26, v20);
  if (v27)
  {
    v28 = v27;
    message_dict = iio_xpc_get_message_dict(v27);
    error_code = iio_xpc_dictionary_get_error_code(message_dict);
    if (a9)
      *a9 = error_code;
    if (error_code)
    {
      if (error_code == -1400)
        IIOXPCLog("❌ ImageIOXPC: XPC_READPLUGIN_IDENTIFY XPC connection interrupted\n");
      else
        IIOXPCLog("❌ ImageIOXPC: XPC_READPLUGIN_IDENTIFY error: %d\n");
    }
    else
    {
      source_dict = iio_xpc_get_source_dict(v28);
      if (source_dict)
      {
        v35 = source_dict;
        string = xpc_dictionary_get_string(source_dict, "iio_xpc_src_utitype");
        uint64 = xpc_dictionary_get_uint64(v35, "iio_xpc_src_ostype");
        v38 = uint64;
        if (string)
        {
          v53 = 0;
          v54 = 0;
          v55 = 0;
          IIOString::IIOString((IIOString *)&v53, string);
          v52 = (const char *)IIOString::utf8String((IIOString *)&v53);
          v39 = v38 >> 24;
          v40 = MEMORY[0x1E0C80978];
          if (v38 < 0)
            v41 = __maskrune(v38 >> 24, 0x40000uLL);
          else
            v41 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v39 + 60) & 0x40000;
          if (v41)
            v42 = v39;
          else
            v42 = 46;
          v43 = v38 << 8 >> 24;
          if (v38 << 8 < 0)
            v44 = __maskrune(v38 << 8 >> 24, 0x40000uLL);
          else
            v44 = *(_DWORD *)(v40 + 4 * v43 + 60) & 0x40000;
          if (v44)
            v45 = v43;
          else
            v45 = 46;
          v46 = (__int16)v38 >> 8;
          if (v38 << 16 < 0)
          {
            v48 = __maskrune((__int16)v38 >> 8, 0x40000uLL);
            v47 = v40;
          }
          else
          {
            v47 = v40;
            v48 = *(_DWORD *)(v40 + 4 * v46 + 60) & 0x40000;
          }
          if ((v38 << 24) <= 0x7F000000)
            v49 = *(_DWORD *)(v47 + 4 * (char)v38 + 60) & 0x40000;
          else
            v49 = __maskrune((char)v38, 0x40000uLL);
          if (v48)
            v50 = v46;
          else
            v50 = 46;
          if (v49)
            v51 = (char)v38;
          else
            v51 = 46;
          IIOXPCLog("✅ ImageIOXPC: XPC_READPLUGIN_IDENTIFY: '%s' '%c%c%c%c'\n", v52, v42, v45, v50, v51);
          v33 = IIO_ReaderHandler::readerForUTTypeAndOSType((IIO_ReaderHandler *)a1, v55, v38);
          IIOString::~IIOString((IIOString *)&v53);
          goto LABEL_33;
        }
        if (uint64 < 0)
          __maskrune(uint64 >> 24, 0x40000uLL);
      }
      else
      {
        v38 = 774778414;
      }
      if (v38 << 8 < 0)
        __maskrune(v38 << 8 >> 24, 0x40000uLL);
      if (v38 << 16 < 0)
        __maskrune((__int16)v38 >> 8, 0x40000uLL);
      if ((v38 << 24) > 0x7F000000)
        __maskrune((char)v38, 0x40000uLL);
      IIOXPCLog("❌ ImageIOXPC: XPC_READPLUGIN_IDENTIFY '%c%c%c%c' failed to get plugin\n");
    }
    v33 = 0;
LABEL_33:
    _cg_jpeg_mem_term(IIOXPCClient, v28, v31);
    xpc_release(v28);
    goto LABEL_34;
  }
  IIOXPCLog("❌ ImageIOXPC: XPC_READPLUGIN_IDENTIFY error null-reply\n");
  v33 = 0;
LABEL_34:
  xpc_release(v20);
  kdebug_trace();
  return v33;
}

void sub_187E5D27C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOXPCClient::useServerForIdentification(IIOXPCClient *a1, IIOImageRead *a2, int a3)
{
  return IIOXPCClient::useServerForCall(a1, a2, 0, a3, 1, 1);
}

uint64_t IIO_Reader::callGetImageCount(const void ***a1, uint64_t a2, uint64_t a3, _DWORD *a4, _DWORD *a5)
{
  IIO_Reader *Source;
  IIOImageRead *v10;
  IIOImageRead *v11;
  char v12;
  IIOXPCClient *IIOXPCClient;
  xpc_object_t v14;
  void *v15;
  xpc_object_t v16;
  xpc_object_t v17;
  const char *v18;
  const __CFData *v19;
  _xpc_connection_s *v20;
  dispatch_queue_s *v21;
  xpc_object_t v22;
  void *v23;
  xpc_object_t message_dict;
  xpc_object_t source_dict;
  uint64_t error_code;
  const char *v27;
  int v28;
  unsigned int v29;
  int v30;
  uint64_t uint64;
  int v33;
  unsigned int v34;
  int v35;
  int v36;
  unsigned int v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  unsigned int v41;
  int v42;
  uint64_t v43;
  unsigned int v44;
  int v45;
  uint64_t v46;
  unsigned int v47;
  int v48;
  uint64_t v49;
  unsigned int v50;
  uint64_t v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unsigned int v58;
  int v59;
  uint64_t v60;
  unsigned int v61;
  int v62;
  uint64_t v63;
  int v64;
  uint64_t v65;
  xpc_object_t GlobalInfo;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  xpc_object_t plugin_dict;
  uint64_t v71;
  void *v72[3];
  void *v73;

  Source = (IIO_Reader *)CGImageSourceGetSource(a2);
  v10 = (IIOImageRead *)IIO_Reader::testHeaderSize(Source);
  v11 = v10;
  if (v10)
  {
    v10 = (IIOImageRead *)IIOImageRead::forceUseServer(v10);
    v12 = (char)v10;
  }
  else
  {
    v12 = -1;
  }
  IIOXPCClient = (IIOXPCClient *)IIOXPCClient::GetIIOXPCClient(v10);
  if (IIOXPCClient::useServerForImageCount(IIOXPCClient, v11, (uint64_t)a1, v12))
  {
    kdebug_trace();
    v14 = xpc_dictionary_create(0, 0, 0);
    if (!v14)
    {
      LODWORD(a3) = 0;
      uint64 = 1;
      goto LABEL_73;
    }
    v15 = v14;
    v73 = 0;
    v16 = iio_xpc_add_source_dict(v14);
    v17 = iio_xpc_add_plugin_dict(v15);
    xpc_dictionary_set_uint64(v15, "iio_xpc_message_id", 2uLL);
    memset(v72, 0, sizeof(v72));
    IIOString::IIOString((IIOString *)v72, *a1[1]);
    v18 = (const char *)IIOString::utf8String((IIOString *)v72);
    xpc_dictionary_set_string(v16, "iio_xpc_src_utitype", v18);
    xpc_dictionary_set_uint64(v16, "iio_xpc_src_ostype", *((unsigned int *)a1 + 6));
    IIOImageReadSession::addDataToXPCDictionary(Source, v15, &v73);
    iio_xpc_dictionary_add_CFDictionary(v16, "iio_xpc_src_options");
    v19 = (const __CFData *)((uint64_t (*)(const void ***, IIO_Reader *))(*a1)[13])(a1, Source);
    if (v19)
    {
      iio_xpc_dictionary_add_GlobalInfo(v17, v19, *((_DWORD *)a1 + 6));
      CFRelease(v19);
    }
    v20 = (_xpc_connection_s *)IIOXPCClient::xpc_connection(IIOXPCClient);
    v21 = (dispatch_queue_s *)IIOXPCClient::xpc_queue(IIOXPCClient);
    v22 = IIOXPCClient::send_message_with_reply(IIOXPCClient, v20, v21, v15);
    v23 = v22;
    if (!v22)
    {
      IIOXPCLog("❌ ImageIOXPC: XPC_READPLUGIN_IMAGECOUNT error null-reply\n");
      LODWORD(a3) = 0;
      uint64 = 1;
      goto LABEL_69;
    }
    message_dict = iio_xpc_get_message_dict(v22);
    source_dict = iio_xpc_get_source_dict(v23);
    error_code = iio_xpc_dictionary_get_error_code(message_dict);
    a3 = error_code;
    if (!(_DWORD)error_code)
    {
      if (source_dict)
      {
        plugin_dict = iio_xpc_get_plugin_dict(v23);
        uint64 = xpc_dictionary_get_uint64(source_dict, "iio_xpc_src_image_count");
        v33 = *((_DWORD *)a1 + 6);
        v34 = v33 >> 24;
        if (v33 < 0)
        {
          v35 = __maskrune(v34, 0x40000uLL);
          v33 = *((_DWORD *)a1 + 6);
        }
        else
        {
          v35 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v34 + 60) & 0x40000;
        }
        LODWORD(v57) = v33 >> 24;
        if (v35)
          v57 = v57;
        else
          v57 = 46;
        v69 = v57;
        v58 = v33 << 8 >> 24;
        if (v33 << 8 < 0)
        {
          v59 = __maskrune(v58, 0x40000uLL);
          v33 = *((_DWORD *)a1 + 6);
        }
        else
        {
          v59 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v58 + 60) & 0x40000;
        }
        LODWORD(v60) = v33 << 8 >> 24;
        if (v59)
          v60 = v60;
        else
          v60 = 46;
        v68 = v60;
        v61 = (__int16)v33 >> 8;
        if (v33 << 16 < 0)
        {
          v62 = __maskrune(v61, 0x40000uLL);
          v33 = *((_DWORD *)a1 + 6);
        }
        else
        {
          v62 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v61 + 60) & 0x40000;
        }
        LODWORD(v63) = (__int16)v33 >> 8;
        if (v62)
          v63 = v63;
        else
          v63 = 46;
        v67 = v63;
        if ((v33 << 24) <= 0x7F000000)
          v64 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v33 + 60) & 0x40000;
        else
          v64 = __maskrune((char)v33, 0x40000uLL);
        if (v64)
          v65 = *((char *)a1 + 24);
        else
          v65 = 46;
        IIOXPCLog("✅ ImageIOXPC [%c%c%c%c]: XPC_READPLUGIN_IMAGECOUNT: %d\n", v69, v68, v67, v65, uint64);
        *a4 = xpc_dictionary_get_int64(source_dict, "iio_xpc_src_status");
        if (plugin_dict)
        {
          v71 = 0;
          GlobalInfo = iio_xpc_dictionary_get_GlobalInfo(plugin_dict, &v71);
          if (v71)
            ((void (*)(const void ***, IIO_Reader *, xpc_object_t))(*a1)[12])(a1, Source, GlobalInfo);
        }
        goto LABEL_68;
      }
LABEL_67:
      uint64 = 1;
LABEL_68:
      _cg_jpeg_mem_term(IIOXPCClient, v23, v27);
      xpc_release(v23);
LABEL_69:
      if (Source && v73)
        IIOImageReadSession::releaseBytePointer((IIOImageRead **)Source, v73);
      xpc_release(v15);
      IIOString::~IIOString((IIOString *)v72);
LABEL_73:
      kdebug_trace();
      if (!a5)
        return uint64;
      goto LABEL_14;
    }
    if ((_DWORD)error_code == -1400)
    {
      v28 = *((_DWORD *)a1 + 6);
      v29 = v28 >> 24;
      if (v28 < 0)
      {
        v30 = __maskrune(v29, 0x40000uLL);
        v28 = *((_DWORD *)a1 + 6);
      }
      else
      {
        v30 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v29 + 60) & 0x40000;
      }
      if (v30)
        v40 = (v28 >> 24);
      else
        v40 = 46;
      v41 = v28 << 8 >> 24;
      if (v28 << 8 < 0)
      {
        v42 = __maskrune(v41, 0x40000uLL);
        v28 = *((_DWORD *)a1 + 6);
      }
      else
      {
        v42 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v41 + 60) & 0x40000;
      }
      if (v42)
        v46 = (v28 << 8 >> 24);
      else
        v46 = 46;
      v47 = (__int16)v28 >> 8;
      if (v28 << 16 < 0)
      {
        v48 = __maskrune(v47, 0x40000uLL);
        v28 = *((_DWORD *)a1 + 6);
      }
      else
      {
        v48 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v47 + 60) & 0x40000;
      }
      if (v48)
        v53 = ((__int16)v28 >> 8);
      else
        v53 = 46;
      if ((v28 << 24) <= 0x7F000000)
      {
        if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v28 + 60) & 0x40000) != 0)
          goto LABEL_53;
      }
      else if (__maskrune((char)v28, 0x40000uLL))
      {
LABEL_53:
        v54 = *((char *)a1 + 24);
LABEL_56:
        IIOXPCLog("❌ ImageIOXPC [%c%c%c%c]: XPC_READPLUGIN_IMAGECOUNT XPC connection interrupted\n", v40, v46, v53, v54);
        goto LABEL_67;
      }
      v54 = 46;
      goto LABEL_56;
    }
    v36 = *((_DWORD *)a1 + 6);
    v37 = v36 >> 24;
    v38 = MEMORY[0x1E0C80978];
    if (v36 < 0)
    {
      v39 = __maskrune(v37, 0x40000uLL);
      v36 = *((_DWORD *)a1 + 6);
    }
    else
    {
      v39 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v37 + 60) & 0x40000;
    }
    if (v39)
      v43 = (v36 >> 24);
    else
      v43 = 46;
    v44 = v36 << 8 >> 24;
    if (v36 << 8 < 0)
    {
      v45 = __maskrune(v44, 0x40000uLL);
      v36 = *((_DWORD *)a1 + 6);
    }
    else
    {
      v45 = *(_DWORD *)(v38 + 4 * v44 + 60) & 0x40000;
    }
    if (v45)
      v49 = (v36 << 8 >> 24);
    else
      v49 = 46;
    v50 = (__int16)v36 >> 8;
    if (v36 << 16 < 0)
    {
      v52 = __maskrune(v50, 0x40000uLL);
      v51 = v38;
      v36 = *((_DWORD *)a1 + 6);
    }
    else
    {
      v51 = v38;
      v52 = *(_DWORD *)(v38 + 4 * v50 + 60) & 0x40000;
    }
    if (v52)
      v55 = ((__int16)v36 >> 8);
    else
      v55 = 46;
    if ((v36 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v51 + 4 * (char)v36 + 60) & 0x40000) != 0)
        goto LABEL_63;
    }
    else if (__maskrune((char)v36, 0x40000uLL))
    {
LABEL_63:
      v56 = *((char *)a1 + 24);
LABEL_66:
      IIOXPCLog("❌ ImageIOXPC [%c%c%c%c]: XPC_READPLUGIN_IMAGECOUNT error: %lld\n", v43, v49, v55, v56, a3);
      goto LABEL_67;
    }
    v56 = 46;
    goto LABEL_66;
  }
  LODWORD(v72[0]) = 0;
  ((void (*)(const void ***, IIO_Reader *, uint64_t, _DWORD *, void **))(*a1)[4])(a1, Source, a3, a4, v72);
  uint64 = LODWORD(v72[0]);
  LODWORD(a3) = 0;
  if (a5)
LABEL_14:
    *a5 = a3;
  return uint64;
}

void sub_187E5D920(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOReadPlugin::callDecodeImage(uint64_t a1, uint64_t a2, uint64_t a3, IOSurfaceRef *a4, uint64_t a5, uint64_t *a6)
{
  int v9;
  IIO_ReaderHandler *ReaderHandler;
  IIO_Reader *v11;
  IIO_Reader *v12;
  IIODictionary *Options;
  IIOXPCClient *v14;
  int v15;
  IIOXPCClient *IIOXPCClient;
  IIOImageRead *v17;
  int v18;
  int v19;
  const __CFString **v20;
  const __CFString *v21;
  const __CFString *v22;
  const void **v23;
  const void *v24;
  xpc_object_t v25;
  void *v26;
  xpc_object_t v27;
  xpc_object_t v28;
  const void *v29;
  IIOString *v30;
  const char *v31;
  const __CFData *v32;
  char v33;
  xpc_object_t XPCObject;
  unsigned int v35;
  int v36;
  uint64_t v37;
  void *v38;
  uint64_t v39;
  unsigned int v40;
  int v41;
  uint64_t v42;
  unsigned int v43;
  int v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  double v50;
  double v51;
  double y;
  double x;
  double v54;
  double v55;
  double v56;
  double v57;
  double v58;
  double v59;
  double v60;
  double v61;
  unint64_t v62;
  IIOString *v63;
  const char *v64;
  const void *v65;
  IIOString *v66;
  const char *v67;
  _xpc_connection_s *v68;
  dispatch_queue_s *v69;
  xpc_object_t v70;
  void *v71;
  xpc_object_t message_dict;
  void *v73;
  void *v74;
  uint64_t error_code;
  unsigned int v76;
  OSType PixelFormat;
  int v78;
  unsigned int v79;
  uint64_t v80;
  int v81;
  int v82;
  int v83;
  uint64_t v84;
  uint64_t v85;
  int v86;
  uint64_t v87;
  uint64_t v88;
  int v89;
  unsigned int v90;
  int v91;
  unsigned int v92;
  int v93;
  const char *v94;
  int v95;
  uint64_t v96;
  uint64_t v97;
  __IOSurface *ImageBlockSetFromXPCObject;
  IOSurfaceRef *v99;
  int v100;
  uint64_t v101;
  uint64_t v102;
  char v103;
  xpc_object_t value;
  xpc_object_t GlobalInfo;
  uint64_t v107;
  unsigned int v108;
  int v109;
  uint64_t v110;
  unsigned int v111;
  int v112;
  uint64_t v113;
  int v114;
  uint64_t v115;
  IOSurfaceRef v116;
  unsigned int v117;
  int v118;
  uint64_t v119;
  unsigned int v120;
  int v121;
  uint64_t v122;
  unsigned int v123;
  uint64_t v124;
  int v125;
  uint64_t v126;
  int v127;
  uint64_t v128;
  uint64_t v129;
  xpc_object_t callback_dict;
  xpc_object_t plugin_dict;
  xpc_object_t xdict;
  xpc_object_t xdicta;
  xpc_object_t object;
  IIOXPCClient *v135;
  IIOXPCClient *Width;
  uint64_t v138;
  IIODecodeParameter *v140;
  size_t Height;
  IIO_Reader *v143;
  IIOImageReadSession *v144;
  uint64_t v145;
  void *v146[3];
  _QWORD v147[4];
  CGRect v148;
  CGRect v149;

  v9 = *(_DWORD *)(a1 + 204);
  ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler((IIO_ReaderHandler *)a1);
  v11 = IIO_ReaderHandler::readerForType(ReaderHandler, v9);
  v12 = *(IIO_Reader **)(a1 + 16);
  if (v12)
    Options = (IIODictionary *)IIOImagePlus::getOptions(*(IIOImagePlus **)(a1 + 16));
  else
    Options = 0;
  v14 = (IIOXPCClient *)IIOImageRead::forceUseServer(*(IIOImageRead **)(a1 + 32));
  v15 = (int)v14;
  IIOXPCClient = (IIOXPCClient *)IIOXPCClient::GetIIOXPCClient(v14);
  v143 = (IIO_Reader *)IIO_Reader::testHeaderSize(v12);
  v17 = (IIOImageRead *)IIO_Reader::testHeaderSize(v143);
  v135 = IIOXPCClient;
  v18 = IIOXPCClient::useServerForDecodeImage(IIOXPCClient, v17, (uint64_t)v11, v15);
  if (!v11)
  {
    v35 = v9 >> 24;
    if (v9 < 0)
      v36 = __maskrune(v9 >> 24, 0x40000uLL);
    else
      v36 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v35 + 60) & 0x40000;
    if (v36)
      v39 = v35;
    else
      v39 = 46;
    v40 = v9 << 8 >> 24;
    if (v9 << 8 < 0)
      v41 = __maskrune(v9 << 8 >> 24, 0x40000uLL);
    else
      v41 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v40 + 60) & 0x40000;
    if (v41)
      v42 = v40;
    else
      v42 = 46;
    v43 = (__int16)v9 >> 8;
    if (v9 << 16 < 0)
      v44 = __maskrune((__int16)v9 >> 8, 0x40000uLL);
    else
      v44 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v43 + 60) & 0x40000;
    if (v44)
      v45 = v43;
    else
      v45 = 46;
    if ((v9 << 24) <= 0x7F000000)
      v46 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v9 + 60) & 0x40000;
    else
      v46 = __maskrune((char)v9, 0x40000uLL);
    if (v46)
      v47 = (char)v9;
    else
      v47 = 46;
    _cg_jpeg_mem_term("callDecodeImage", 2082, "*** ERROR: could not find a reader for '%c%c%c%c'\n", v39, v42, v45, v47);
    return 4294967246;
  }
  v19 = v18;
  v20 = *(const __CFString ***)(a1 + 72);
  if (v20)
  {
    v21 = *v20;
    if (*v20)
    {
      v22 = (const __CFString *)IIO_Reader::utType(v11);
      if (CFStringCompare(v21, v22, 0))
      {
        v23 = *(const void ***)(a1 + 72);
        if (v23)
          v24 = *v23;
        else
          v24 = 0;
        v63 = IIOString::IIOString((IIOString *)v147, v24);
        v64 = (const char *)IIOString::utf8String(v63);
        v65 = (const void *)IIO_Reader::utType(v11);
        v66 = IIOString::IIOString((IIOString *)v146, v65);
        v67 = (const char *)IIOString::utf8String(v66);
        _cg_jpeg_mem_term("callDecodeImage", 2087, "*** ERROR: pluginUTI '%s' does not match reader '%s'\n", v64, v67);
        IIOString::~IIOString((IIOString *)v146);
        IIOString::~IIOString((IIOString *)v147);
        return 4294967246;
      }
    }
  }
  if (v19)
  {
    kdebug_trace();
    IIOImagePlus::getProperties(v12);
    v146[0] = 0;
    v25 = xpc_dictionary_create(0, 0, 0);
    if (!v25)
    {
      v37 = 4294967246;
LABEL_167:
      kdebug_trace();
      return v37;
    }
    v26 = v25;
    iio_xpc_add_message_dict(v25);
    v27 = iio_xpc_add_source_dict(v26);
    v28 = iio_xpc_add_plugin_dict(v26);
    xdict = iio_xpc_add_callback_dict(v26);
    object = v26;
    xpc_dictionary_set_uint64(v26, "iio_xpc_message_id", 6uLL);
    memset(v147, 0, 24);
    v29 = (const void *)IIO_Reader::utType(v11);
    v30 = IIOString::IIOString((IIOString *)v147, v29);
    v31 = (const char *)IIOString::utf8String(v30);
    xpc_dictionary_set_string(v27, "iio_xpc_src_utitype", v31);
    xpc_dictionary_set_uint64(v27, "iio_xpc_src_ostype", *(unsigned int *)(a1 + 204));
    if (v143)
      IIOImageReadSession::addDataToXPCDictionary(v143, v26, v146);
    iio_xpc_dictionary_add_CFDictionary(v27, "iio_xpc_src_options");
    if (IIODictionary::containsKey(Options, CFSTR("kCGImageSourceDecodeRequest")))
      iio_xpc_dictionary_add_CFDictionary(v27, "iio_xpc_src_properties");
    IIODecodeParameter::saveDataToXPCObject((IIODecodeParameter *)a2, v26);
    xpc_dictionary_set_uint64(v27, "iio_xpc_src_image_type", a3);
    v32 = (const __CFData *)(*(uint64_t (**)(IIO_Reader *, IIO_Reader *))(*(_QWORD *)v11 + 104))(v11, v143);
    if (v32)
    {
      iio_xpc_dictionary_add_GlobalInfo(v28, v32, *(_DWORD *)(a1 + 204));
      CFRelease(v32);
    }
    (*(void (**)(uint64_t, xpc_object_t))(*(_QWORD *)a1 + 104))(a1, v28);
    v33 = 0;
    if ((_DWORD)a3 == 1 && a4)
    {
      if (*a4 && (XPCObject = IOSurfaceCreateXPCObject(*a4)) != 0)
      {
        xpc_dictionary_set_value(xdict, "iio_xpc_cb_decode_iosurface", XPCObject);
        xpc_release(XPCObject);
        v33 = 1;
      }
      else
      {
        v33 = 0;
      }
    }
    v68 = (_xpc_connection_s *)IIOXPCClient::xpc_connection(v135);
    v69 = (dispatch_queue_s *)IIOXPCClient::xpc_queue(v135);
    v70 = IIOXPCClient::send_message_with_reply(v135, v68, v69, v26);
    v71 = v70;
    if (!v70)
    {
      IIOXPCLog("❌ ImageIOXPC: XPC_READPLUGIN_DECODE_IMAGE error null-reply\n");
      v37 = 4294967246;
LABEL_164:
      xpc_release(object);
      IIOString::~IIOString((IIOString *)v147);
      if (v143 && v146[0])
        IIOImageReadSession::releaseBytePointer((IIOImageRead **)v143, v146[0]);
      goto LABEL_167;
    }
    plugin_dict = iio_xpc_get_plugin_dict(v70);
    message_dict = iio_xpc_get_message_dict(v71);
    v73 = v71;
    v74 = message_dict;
    xdicta = v73;
    callback_dict = iio_xpc_get_callback_dict(v73);
    error_code = iio_xpc_dictionary_get_error_code(v74);
    v76 = v9 >> 24;
    v37 = error_code;
    if ((_DWORD)error_code)
    {
      if ((_DWORD)error_code == -56)
      {
        if (v9 < 0)
          __maskrune(v9 >> 24, 0x40000uLL);
        if (v9 << 8 < 0)
          __maskrune(v9 << 8 >> 24, 0x40000uLL);
        if (v9 << 16 < 0)
          __maskrune((__int16)v9 >> 8, 0x40000uLL);
        if ((v9 << 24) > 0x7F000000)
          __maskrune((char)v9, 0x40000uLL);
        IIOXPCLog("❌ ImageIOXPC [%c%c%c%c]: XPC_READPLUGIN_DECODE_IMAGE: error: -56 (iio_methodNotImplemented)\n");
      }
      else if ((_DWORD)error_code == -1400)
      {
        if (v9 < 0)
          __maskrune(v9 >> 24, 0x40000uLL);
        if (v9 << 8 < 0)
          __maskrune(v9 << 8 >> 24, 0x40000uLL);
        if (v9 << 16 < 0)
          __maskrune((__int16)v9 >> 8, 0x40000uLL);
        if ((v9 << 24) > 0x7F000000)
          __maskrune((char)v9, 0x40000uLL);
        IIOXPCLog("❌ ImageIOXPC [%c%c%c%c]: XPC_READPLUGIN_DECODE_IMAGE XPC connection interrupted\n");
      }
      else
      {
        if (v9 < 0)
          v83 = __maskrune(v9 >> 24, 0x40000uLL);
        else
          v83 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v76 + 60) & 0x40000;
        if (v83)
          v87 = v76;
        else
          v87 = 46;
        LODWORD(v88) = v9 << 8 >> 24;
        if (v9 << 8 < 0)
          v89 = __maskrune(v9 << 8 >> 24, 0x40000uLL);
        else
          v89 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v88 + 60) & 0x40000;
        if (v89)
          v88 = v88;
        else
          v88 = 46;
        v92 = (__int16)v9 >> 8;
        if (v9 << 16 < 0)
          v93 = __maskrune((__int16)v9 >> 8, 0x40000uLL);
        else
          v93 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v92 + 60) & 0x40000;
        if ((v9 << 24) <= 0x7F000000)
          v100 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v9 + 60) & 0x40000;
        else
          v100 = __maskrune((char)v9, 0x40000uLL);
        if (v93)
          v101 = v92;
        else
          v101 = 46;
        if (v100)
          v102 = (char)v9;
        else
          v102 = 46;
        IIOXPCLog("❌ ImageIOXPC [%c%c%c%c]: XPC_READPLUGIN_DECODE_IMAGE error: %d\n", v87, v88, v101, v102, v37);
      }
LABEL_163:
      _cg_jpeg_mem_term(v135, xdicta, v94);
      xpc_release(xdicta);
      goto LABEL_164;
    }
    if (v9 < 0)
      v82 = __maskrune(v9 >> 24, 0x40000uLL);
    else
      v82 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v76 + 60) & 0x40000;
    if (v82)
      v84 = v76;
    else
      v84 = 46;
    v129 = v84;
    LODWORD(v85) = v9 << 8 >> 24;
    if (v9 << 8 < 0)
      v86 = __maskrune(v9 << 8 >> 24, 0x40000uLL);
    else
      v86 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v85 + 60) & 0x40000;
    if (v86)
      v85 = v85;
    else
      v85 = 46;
    v90 = (__int16)v9 >> 8;
    if (v9 << 16 < 0)
      v91 = __maskrune((__int16)v9 >> 8, 0x40000uLL);
    else
      v91 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v90 + 60) & 0x40000;
    if ((v9 << 24) <= 0x7F000000)
      v95 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v9 + 60) & 0x40000;
    else
      v95 = __maskrune((char)v9, 0x40000uLL);
    if (v91)
      v96 = v90;
    else
      v96 = 46;
    if (v95)
      v97 = (char)v9;
    else
      v97 = 46;
    IIOXPCLog("✅ ImageIOXPC [%c%c%c%c]: XPC_READPLUGIN_DECODE_IMAGE: OK\n", v129, v85, v96, v97);
    if ((_DWORD)a3 == 1)
    {
      if (callback_dict)
        v103 = v33;
      else
        v103 = 1;
      if ((v103 & 1) != 0 || (value = xpc_dictionary_get_value(callback_dict, "iio_xpc_cb_decode_iosurface"), !a4))
      {
LABEL_161:
        v145 = 0;
        GlobalInfo = iio_xpc_dictionary_get_GlobalInfo(plugin_dict, &v145);
        if (v145)
          (*(void (**)(IIO_Reader *, IIO_Reader *, xpc_object_t))(*(_QWORD *)v11 + 96))(v11, v143, GlobalInfo);
        goto LABEL_163;
      }
      ImageBlockSetFromXPCObject = IOSurfaceLookupFromXPCObject(value);
      v99 = a4;
    }
    else
    {
      if ((_DWORD)a3 != 3)
        goto LABEL_161;
      ImageBlockSetFromXPCObject = (__IOSurface *)IIOReadPlugin::createImageBlockSetFromXPCObject(a1, xdicta, *(const void **)(a2 + 8), *(_QWORD *)(a2 + 16));
      v99 = (IOSurfaceRef *)a6;
    }
    *v99 = ImageBlockSetFromXPCObject;
    goto LABEL_161;
  }
  if (v15 == 1)
    IIOXPCLog("⭕️ ImageIOXPC: OOP-request was made, but we're decoding in-process (XPC_READPLUGIN_DECODEIMAGE)...\n");
  v37 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, IOSurfaceRef *, uint64_t, uint64_t *))(*(_QWORD *)a1 + 208))(a1, a2, a3, a4, a5, a6);
  if (!(_DWORD)v37)
  {
    if ((_DWORD)a3 == 1)
    {
      PixelFormat = IOSurfaceGetPixelFormat(*a4);
      if ((gIIODebugFlags & 0x30000) != 0)
      {
        v78 = PixelFormat;
        v79 = v9 >> 24;
        v80 = MEMORY[0x1E0C80978];
        if (v9 < 0)
          v81 = __maskrune(v9 >> 24, 0x40000uLL);
        else
          v81 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v79 + 60) & 0x40000;
        if (v81)
          v107 = v79;
        else
          v107 = 46;
        v144 = (IIOImageReadSession *)v107;
        v108 = v9 << 8 >> 24;
        if (v9 << 8 < 0)
          v109 = __maskrune(v9 << 8 >> 24, 0x40000uLL);
        else
          v109 = *(_DWORD *)(v80 + 4 * v108 + 60) & 0x40000;
        if (v109)
          v110 = v108;
        else
          v110 = 46;
        v140 = (IIODecodeParameter *)v110;
        v111 = (__int16)v9 >> 8;
        if (v9 << 16 < 0)
          v112 = __maskrune((__int16)v9 >> 8, 0x40000uLL);
        else
          v112 = *(_DWORD *)(v80 + 4 * v111 + 60) & 0x40000;
        if (v112)
          v113 = v111;
        else
          v113 = 46;
        v138 = v113;
        if ((v9 << 24) <= 0x7F000000)
          v114 = *(_DWORD *)(v80 + 4 * (char)v9 + 60) & 0x40000;
        else
          v114 = __maskrune((char)v9, 0x40000uLL);
        if (v114)
          v115 = (char)v9;
        else
          v115 = 46;
        v116 = *a4;
        Width = (IIOXPCClient *)IOSurfaceGetWidth(*a4);
        Height = IOSurfaceGetHeight(*a4);
        v117 = v78 >> 24;
        if (v78 < 0)
          v118 = __maskrune(v78 >> 24, 0x40000uLL);
        else
          v118 = *(_DWORD *)(v80 + 4 * v117 + 60) & 0x40000;
        if (v118)
          v119 = v117;
        else
          v119 = 46;
        v120 = v78 << 8 >> 24;
        if (v78 << 8 < 0)
          v121 = __maskrune(v78 << 8 >> 24, 0x40000uLL);
        else
          v121 = *(_DWORD *)(v80 + 4 * v120 + 60) & 0x40000;
        if (v121)
          v122 = v120;
        else
          v122 = 46;
        v123 = (__int16)v78 >> 8;
        v124 = v80;
        if (v78 << 16 < 0)
          v125 = __maskrune((__int16)v78 >> 8, 0x40000uLL);
        else
          v125 = *(_DWORD *)(v80 + 4 * v123 + 60) & 0x40000;
        if (v125)
          v126 = v123;
        else
          v126 = 46;
        if ((v78 << 24) <= 0x7F000000)
          v127 = *(_DWORD *)(v124 + 4 * (char)v78 + 60) & 0x40000;
        else
          v127 = __maskrune((char)v78, 0x40000uLL);
        if (v127)
          v128 = (char)v78;
        else
          v128 = 46;
        ImageIOLog("♦️  '%c%c%c%c' - decoded IOSurface: <IOSurface: %p> %ldx%ld  '%c%c%c%c'\n", v144, v140, v138, v115, v116, Width, Height, v119, v122, v126, v128);
      }
    }
    else if ((_DWORD)a3 == 3 && !*a6)
    {
      v48 = *(_QWORD *)(a1 + 96);
      if (v48)
      {
        if (*(_DWORD *)(a1 + 104))
        {
          v49 = 0;
          v50 = 0.0;
          v51 = 0.0;
          y = 0.0;
          x = 0.0;
          do
          {
            CGImageBlockGetRect();
            v58 = v54;
            v59 = v55;
            v60 = v56;
            v61 = v57;
            if (v49)
            {
              v148.origin.x = x;
              v148.origin.y = y;
              v148.size.width = v51;
              v148.size.height = v50;
              v149 = CGRectUnion(v148, *(CGRect *)&v58);
              x = v149.origin.x;
              y = v149.origin.y;
              v51 = v149.size.width;
              v50 = v149.size.height;
            }
            else
            {
              v50 = v57;
              v51 = v56;
              y = v55;
              x = v54;
            }
            ++v49;
            v62 = *(unsigned int *)(a1 + 104);
          }
          while (v49 < v62);
          v48 = *(_QWORD *)(a1 + 96);
        }
        else
        {
          v62 = 0;
          x = 0.0;
          y = 0.0;
          v51 = 0.0;
          v50 = 0.0;
        }
        *a6 = IIOReadPlugin::imageBlockSetCreate(a1, *(_QWORD *)(a2 + 16), v62, v51, v50, x, y, v51, v50, v48, *(const void **)(a2 + 8));
      }
      else
      {
        LogError("callDecodeImage", 2262, "*** ERROR: decodeImageImp failed - NULL _blockArray\n");
      }
    }
  }
  v38 = *(void **)(a1 + 96);
  if (v38)
    free(v38);
  *(_QWORD *)(a1 + 96) = 0;
  *(_DWORD *)(a1 + 104) = 0;
  return v37;
}

void sub_187E5E6F4(_Unwind_Exception *a1)
{
  uint64_t v1;

  IIOString::~IIOString((IIOString *)(v1 - 144));
  _Unwind_Resume(a1);
}

uint64_t IIOImageRead::forceUseServer(IIOImageRead *this)
{
  return *((char *)this + 456);
}

uint64_t IIO_Reader::callInitializeImageAtOffset(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  IIO_Reader *v12;
  IIO_Reader *v13;
  IIOXPCClient *v14;
  IIOXPCClient *IIOXPCClient;
  xpc_object_t v16;
  void *v17;
  IIOXPCClient *v18;
  xpc_object_t v19;
  xpc_object_t v20;
  IIOString *v21;
  const char *v22;
  const __CFData *v23;
  _xpc_connection_s *v24;
  dispatch_queue_s *v25;
  xpc_object_t v26;
  void *v27;
  xpc_object_t message_dict;
  xpc_object_t plugin_dict;
  uint64_t error_code;
  int v31;
  unsigned int v32;
  int v33;
  uint64_t v35;
  BOOL v36;
  int v37;
  unsigned int v38;
  uint64_t v39;
  int v40;
  int v41;
  uint64_t v42;
  unsigned int v43;
  int v44;
  uint64_t v45;
  unsigned int v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  const char *v50;
  uint64_t v51;
  unsigned int v52;
  int v53;
  uint64_t v54;
  unsigned int v55;
  const void *v56;
  int v57;
  uint64_t v58;
  unsigned int v59;
  int v60;
  uint64_t v61;
  unsigned int v62;
  int v63;
  uint64_t v64;
  int v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  const __CFDictionary *v70;
  IIO_Reader *v71;
  uint64_t v72;
  IIODictionary *v73;
  unsigned int v74;
  int v75;
  uint64_t v76;
  unsigned int v77;
  int v78;
  uint64_t v79;
  unsigned int v80;
  int v81;
  uint64_t v82;
  int v83;
  uint64_t v84;
  unsigned int v85;
  int v86;
  uint64_t v87;
  unsigned int v88;
  int v89;
  uint64_t v90;
  unsigned int v91;
  int v92;
  int v93;
  uint64_t v94;
  uint64_t v95;
  IIO_ReaderHandler *v96;
  unsigned int v97;
  IIO_ReaderHandler *ReaderHandler;
  xpc_object_t GlobalInfo;
  IIOReadPlugin *v100;
  const __CFDictionary *v101;
  IIODictionary *v102;
  xpc_object_t value;
  CGMutableImageMetadataRef v104;
  const __CFDictionary *v105;
  __CFDictionary **InfoPtr;
  const __CFDictionary *cf;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  void *v112;
  CFTypeRef v113;
  CFTypeRef v114;
  const __CFDictionary *v115;
  void *v116;
  IIOXPCClient *v117;
  unsigned int v118[2];
  int Uint32ForKey;
  unsigned int v120[2];
  _QWORD v121[3];
  const __CFDictionary *v122[3];
  uint64_t v123;
  const __CFDictionary *v124;
  uint64_t v125;
  uint64_t v126;
  _QWORD buffer[2];
  __int128 v128;
  int v129;
  int v130;
  uint64_t v131;
  uint64_t v132;
  void *v133;

  IIODebugCallbackPriv(**(const void ***)(a1 + 8), "initImage");
  v12 = *(IIO_Reader **)(a2 + 24);
  v13 = (IIO_Reader *)IIO_Reader::testHeaderSize(v12);
  v14 = (IIOXPCClient *)IIO_Reader::testHeaderSize(v13);
  IIOXPCClient = (IIOXPCClient *)IIOXPCClient::GetIIOXPCClient(v14);
  if (!IIOXPCClient::useServerForInitImage(IIOXPCClient, v14, a1, a6))
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, a3, a4, a5);
  kdebug_trace();
  v132 = 256;
  v133 = 0;
  v128 = 0u;
  buffer[0] = IIOImagePlus::getOptions(v12);
  buffer[1] = IIOImagePlus::getProperties(v12);
  *(_QWORD *)v118 = a3;
  v129 = a3;
  v130 = a4;
  v131 = a5;
  BYTE2(v132) = IIOImageReadSession::isFinal(v13);
  if (a4)
    LOBYTE(v132) = 3;
  v16 = xpc_dictionary_create(0, 0, 0);
  v17 = v16;
  if (v16)
  {
    v18 = IIOXPCClient;
    v19 = iio_xpc_add_plugin_dict(v16);
    v20 = iio_xpc_add_source_dict(v17);
    xpc_dictionary_set_uint64(v17, "iio_xpc_message_id", 4uLL);
    v124 = 0;
    v125 = 0;
    v126 = 0;
    v21 = IIOString::IIOString((IIOString *)&v124, **(const void ***)(a1 + 8));
    v22 = (const char *)IIOString::utf8String(v21);
    xpc_dictionary_set_string(v20, "iio_xpc_src_utitype", v22);
    xpc_dictionary_set_uint64(v20, "iio_xpc_src_ostype", *(unsigned int *)(a1 + 24));
    IIOImageReadSession::addDataToXPCDictionary(v13, v17, &v133);
    iio_xpc_dictionary_add_databuffer(v19, "iio_xpc_plugin_init_data", buffer, 0x38uLL);
    iio_xpc_dictionary_add_CFDictionary(v20, "iio_xpc_src_options");
    v23 = (const __CFData *)(*(uint64_t (**)(uint64_t, IIO_Reader *))(*(_QWORD *)a1 + 104))(a1, v13);
    if (v23)
    {
      iio_xpc_dictionary_add_GlobalInfo(v19, v23, *(_DWORD *)(a1 + 24));
      CFRelease(v23);
    }
    IIOString::~IIOString((IIOString *)&v124);
    IIOXPCClient = v18;
  }
  v24 = (_xpc_connection_s *)IIOXPCClient::xpc_connection(IIOXPCClient);
  v25 = (dispatch_queue_s *)IIOXPCClient::xpc_queue(IIOXPCClient);
  v26 = IIOXPCClient::send_message_with_reply(IIOXPCClient, v24, v25, v17);
  if (v26)
  {
    v27 = v26;
    v117 = IIOXPCClient;
    message_dict = iio_xpc_get_message_dict(v26);
    plugin_dict = iio_xpc_get_plugin_dict(v27);
    error_code = iio_xpc_dictionary_get_error_code(message_dict);
    if ((_DWORD)error_code == -1400)
    {
      v31 = *(_DWORD *)(a1 + 24);
      v32 = v31 >> 24;
      if (v31 < 0)
      {
        v33 = __maskrune(v32, 0x40000uLL);
        v31 = *(_DWORD *)(a1 + 24);
      }
      else
      {
        v33 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v32 + 60) & 0x40000;
      }
      if (v33)
        v42 = (v31 >> 24);
      else
        v42 = 46;
      v43 = v31 << 8 >> 24;
      if (v31 << 8 < 0)
      {
        v44 = __maskrune(v43, 0x40000uLL);
        v31 = *(_DWORD *)(a1 + 24);
      }
      else
      {
        v44 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v43 + 60) & 0x40000;
      }
      if (v44)
        v45 = (v31 << 8 >> 24);
      else
        v45 = 46;
      v46 = (__int16)v31 >> 8;
      if (v31 << 16 < 0)
      {
        v47 = __maskrune(v46, 0x40000uLL);
        v31 = *(_DWORD *)(a1 + 24);
      }
      else
      {
        v47 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v46 + 60) & 0x40000;
      }
      if (v47)
        v48 = ((__int16)v31 >> 8);
      else
        v48 = 46;
      if ((v31 << 24) <= 0x7F000000)
      {
        if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v31 + 60) & 0x40000) != 0)
          goto LABEL_42;
      }
      else if (__maskrune((char)v31, 0x40000uLL))
      {
LABEL_42:
        v49 = *(char *)(a1 + 24);
LABEL_45:
        IIOXPCLog("❌ ImageIOXPC [%c%c%c%c]: XPC_READPLUGIN_INITIMAGE XPC connection interrupted\n", v42, v45, v48, v49);
        v35 = 4294965896;
LABEL_161:
        _cg_jpeg_mem_term(v117, v27, v50);
        xpc_release(v27);
        goto LABEL_162;
      }
      v49 = 46;
      goto LABEL_45;
    }
    v35 = error_code;
    v36 = (_DWORD)error_code == -49 || (_DWORD)error_code == 0;
    v37 = *(_DWORD *)(a1 + 24);
    v38 = v37 >> 24;
    if (v36 && plugin_dict)
    {
      v39 = MEMORY[0x1E0C80978];
      if (v37 < 0)
      {
        v40 = __maskrune(v38, 0x40000uLL);
        v37 = *(_DWORD *)(a1 + 24);
      }
      else
      {
        v40 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v38 + 60) & 0x40000;
      }
      LODWORD(v51) = v37 >> 24;
      if (v40)
        v51 = v51;
      else
        v51 = 46;
      v113 = (CFTypeRef)v51;
      v116 = plugin_dict;
      v52 = v37 << 8 >> 24;
      if (v37 << 8 < 0)
      {
        v53 = __maskrune(v52, 0x40000uLL);
        v37 = *(_DWORD *)(a1 + 24);
      }
      else
      {
        v53 = *(_DWORD *)(v39 + 4 * v52 + 60) & 0x40000;
      }
      if (v53)
        v58 = (v37 << 8 >> 24);
      else
        v58 = 46;
      v59 = (__int16)v37 >> 8;
      if (v37 << 16 < 0)
      {
        v60 = __maskrune(v59, 0x40000uLL);
        v37 = *(_DWORD *)(a1 + 24);
      }
      else
      {
        v60 = *(_DWORD *)(v39 + 4 * v59 + 60) & 0x40000;
      }
      if (v60)
        v64 = ((__int16)v37 >> 8);
      else
        v64 = 46;
      if ((v37 << 24) <= 0x7F000000)
        v65 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v37 + 60) & 0x40000;
      else
        v65 = __maskrune((char)v37, 0x40000uLL);
      v112 = v27;
      if (v65)
        v66 = *(_DWORD *)(a1 + 24);
      else
        LOBYTE(v66) = 46;
      IIOXPCLog("✅ ImageIOXPC [%c%c%c%c]: XPC_READPLUGIN_INITIMAGE: OK\n", v113, v58, v64, (char)v66);
      v69 = *(_DWORD *)(a1 + 24);
      v70 = (const __CFDictionary *)iio_xpc_dictionary_copy_CFDictionary(v116, "iio_xpc_plugin_type_changed");
      v71 = (IIO_Reader *)a1;
      v72 = *(_QWORD *)v118;
      if (v70)
      {
        v124 = 0;
        v125 = 0;
        v126 = 0;
        cf = v70;
        v73 = IIODictionary::IIODictionary((IIODictionary *)&v124, v70);
        Uint32ForKey = IIODictionary::getUint32ForKey(v73, CFSTR("NEW_PLUGIN_ostype"));
        v74 = v69 >> 24;
        if (v69 < 0)
          v75 = __maskrune(v69 >> 24, 0x40000uLL);
        else
          v75 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v74 + 60) & 0x40000;
        if (v75)
          v76 = v74;
        else
          v76 = 46;
        v114 = (CFTypeRef)v76;
        v77 = v69 << 8 >> 24;
        if (v69 << 8 < 0)
          v78 = __maskrune(v69 << 8 >> 24, 0x40000uLL);
        else
          v78 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v77 + 60) & 0x40000;
        if (v78)
          v79 = v77;
        else
          v79 = 46;
        v111 = v79;
        v80 = (__int16)v69 >> 8;
        if (v69 << 16 < 0)
          v81 = __maskrune((__int16)v69 >> 8, 0x40000uLL);
        else
          v81 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v80 + 60) & 0x40000;
        if (v81)
          v82 = v80;
        else
          v82 = 46;
        v110 = v82;
        if ((v69 << 24) <= 0x7F000000)
          v83 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v69 + 60) & 0x40000;
        else
          v83 = __maskrune((char)v69, 0x40000uLL);
        if (v83)
          v84 = (char)v69;
        else
          v84 = 46;
        v109 = v84;
        v85 = Uint32ForKey >> 24;
        if (Uint32ForKey < 0)
          v86 = __maskrune(Uint32ForKey >> 24, 0x40000uLL);
        else
          v86 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v85 + 60) & 0x40000;
        if (v86)
          v87 = v85;
        else
          v87 = 46;
        v108 = v87;
        v88 = Uint32ForKey << 8 >> 24;
        if (Uint32ForKey << 8 < 0)
          v89 = __maskrune(Uint32ForKey << 8 >> 24, 0x40000uLL);
        else
          v89 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v88 + 60) & 0x40000;
        if (v89)
          v90 = v88;
        else
          v90 = 46;
        v91 = (__int16)Uint32ForKey >> 8;
        if (Uint32ForKey << 16 < 0)
          v92 = __maskrune((__int16)Uint32ForKey >> 8, 0x40000uLL);
        else
          v92 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v91 + 60) & 0x40000;
        if ((Uint32ForKey << 24) <= 0x7F000000)
          v93 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)Uint32ForKey + 60) & 0x40000;
        else
          v93 = __maskrune((char)Uint32ForKey, 0x40000uLL);
        if (v92)
          v94 = v91;
        else
          v94 = 46;
        if (v93)
          v95 = (char)Uint32ForKey;
        else
          v95 = 46;
        IIOXPCLog("    changed pluin from '%c%c%c%c' to '%c%c%c%c'\n", v114, v111, v110, v109, v108, v90, v94, v95);
        v96 = IIODictionary::getUint32ForKey((IIODictionary *)&v124, CFSTR("NEW_PLUGIN_dataOffset"));
        v97 = v96;
        ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(v96);
        v71 = IIO_ReaderHandler::readerForType(ReaderHandler, Uint32ForKey);
        CFRelease(cf);
        a5 = v97;
        if (v71)
          v35 = v35;
        else
          v35 = 4294967246;
        IIODictionary::~IIODictionary((IIODictionary *)&v124);
        v72 = 0;
      }
      *(_QWORD *)v120 = v72;
      v123 = 0;
      GlobalInfo = iio_xpc_dictionary_get_GlobalInfo(v116, &v123);
      if (v123 && v71)
      {
        (*(void (**)(IIO_Reader *, IIO_Reader *, xpc_object_t))(*(_QWORD *)v71 + 96))(v71, v13, GlobalInfo);
        v27 = v112;
      }
      else
      {
        v27 = v112;
        if (!v71)
        {
          v100 = 0;
          if ((_DWORD)v35)
            goto LABEL_161;
          goto LABEL_148;
        }
      }
      v100 = (IIOReadPlugin *)(*(uint64_t (**)(IIO_Reader *, uint64_t, unsigned int *, uint64_t))(*(_QWORD *)v71 + 248))(v71, a2, *(unsigned int **)v120, a5);
      IIOReadPlugin::setUTIWithReader(v100, v71);
      v35 = (*(uint64_t (**)(IIOReadPlugin *, void *))(*(_QWORD *)v100 + 96))(v100, v116);
      if ((_DWORD)v35)
        goto LABEL_161;
LABEL_148:
      v101 = (const __CFDictionary *)iio_xpc_dictionary_copy_CFDictionary(v116, "iio_xpc_plugin_init_properties");
      v124 = 0;
      v125 = 0;
      v126 = 0;
      v115 = v101;
      v102 = IIODictionary::IIODictionary((IIODictionary *)&v124, v101, 1);
      if (IIODictionary::getCount(v102))
        IIOImagePlus::appendProperties((IIODictionary **)v12, &v124);
      value = xpc_dictionary_get_value(v116, "iio_xpc_plugin_init_metadata");
      if (value)
      {
        v104 = CGImageMetadataCreateFromXPCObj(value);
        if (v104)
        {
          IIOImagePlus::setMetadata(v12, v104);
          CFRelease(v104);
        }
      }
      v105 = (const __CFDictionary *)iio_xpc_dictionary_copy_CFDictionary(v116, "iio_xpc_plugin_header_infoptr");
      memset(v122, 0, sizeof(v122));
      IIODictionary::IIODictionary((IIODictionary *)v122, v105, 1);
      InfoPtr = (__CFDictionary **)IIOReadPlugin::createInfoPtr(v100);
      if (IIODictionary::getCount((IIODictionary *)v122))
      {
        memset(v121, 0, sizeof(v121));
        IIODictionary::IIODictionary((IIODictionary *)v121, *InfoPtr);
        IIODictionary::appendDictionaryNoOverwrite((IIODictionary *)v121, v122);
        IIOReadPlugin::updateTempColorSpace(v100);
        IIODictionary::~IIODictionary((IIODictionary *)v121);
      }
      InfoPtr[1] = v100;
      IIOReadPlugin::setIPlus(v100, v12, v13);
      (*(void (**)(IIOReadPlugin *, __CFDictionary **))(*(_QWORD *)v100 + 56))(v100, InfoPtr);
      if (v115)
        CFRelease(v115);
      if (v105)
        CFRelease(v105);
      IIODictionary::~IIODictionary((IIODictionary *)v122);
      IIODictionary::~IIODictionary((IIODictionary *)&v124);
      goto LABEL_161;
    }
    if (v37 < 0)
    {
      v41 = __maskrune(v38, 0x40000uLL);
      v37 = *(_DWORD *)(a1 + 24);
    }
    else
    {
      v41 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v38 + 60) & 0x40000;
    }
    if (v41)
      v54 = (v37 >> 24);
    else
      v54 = 46;
    v55 = v37 << 8 >> 24;
    v56 = plugin_dict;
    if (v37 << 8 < 0)
    {
      v57 = __maskrune(v55, 0x40000uLL);
      v37 = *(_DWORD *)(a1 + 24);
    }
    else
    {
      v57 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v55 + 60) & 0x40000;
    }
    if (v57)
      v61 = (v37 << 8 >> 24);
    else
      v61 = 46;
    v62 = (__int16)v37 >> 8;
    if (v37 << 16 < 0)
    {
      v63 = __maskrune(v62, 0x40000uLL);
      v37 = *(_DWORD *)(a1 + 24);
    }
    else
    {
      v63 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v62 + 60) & 0x40000;
    }
    if (v63)
      v67 = ((__int16)v37 >> 8);
    else
      v67 = 46;
    if ((v37 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v37 + 60) & 0x40000) != 0)
        goto LABEL_85;
    }
    else if (__maskrune((char)v37, 0x40000uLL))
    {
LABEL_85:
      v68 = *(char *)(a1 + 24);
LABEL_88:
      _cg_jpeg_mem_term("callInitializeImageAtOffset", 861, "❌ ImageIOXPC [%c%c%c%c]: XPC_READPLUGIN_INITIMAGE error: %d  (IMAGEIO_PLUGIN_REPLY: %p)\n", v54, v61, v67, v68, v35, v56);
      goto LABEL_161;
    }
    v68 = 46;
    goto LABEL_88;
  }
  IIOXPCLog("❌ ImageIOXPC: XPC_READPLUGIN_INITIMAGE error null-reply\n");
  v35 = 4294967246;
LABEL_162:
  if (v17)
    xpc_release(v17);
  if (v13)
  {
    if (v133)
      IIOImageReadSession::releaseBytePointer((IIOImageRead **)v13, v133);
  }
  kdebug_trace();
  return v35;
}

void sub_187E5F27C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  uint64_t v31;

  IIODictionary::~IIODictionary((IIODictionary *)&a31);
  IIODictionary::~IIODictionary((IIODictionary *)(v31 - 176));
  _Unwind_Resume(a1);
}

uint64_t IIOXPCClient::GetIIOXPCClient(IIOXPCClient *this)
{
  if (IIOXPCClient::GetIIOXPCClient(void)::xpcClientCreate != -1)
    dispatch_once(&IIOXPCClient::GetIIOXPCClient(void)::xpcClientCreate, &__block_literal_global_155);
  return IIOXPCClient::GetIIOXPCClient(void)::gIIOXPCClient;
}

uint64_t IIOXPCClient::useServerForCall(IIOXPCClient *a1, IIOImageRead *a2, uint64_t a3, int a4, uint64_t a5, int a6)
{
  uint64_t result;

  if ((IIO_XPCServer() & 1) != 0)
    return 0;
  if (a4 != 1)
  {
    if (a4 != -1)
      return 0;
    result = IIOXPCClient::processSupportsOOPCheckOnce(a1);
    if (!(_DWORD)result)
      return result;
  }
  if (a3)
  {
    if (((*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a3 + 232))(a3, a5) & 1) != 0)
      return IIOImageRead::trustedURL(a2) ^ 1;
  }
  else if (a6)
  {
    return IIOImageRead::trustedURL(a2) ^ 1;
  }
  return 0;
}

void IIODebugCallbackPriv(const void *a1, const char *a2)
{
  const char *v3;
  char *v4[3];
  char *v5;

  if ((gIIODebugFlags & 0xC000) != 0)
  {
    v5 = 0;
    memset(v4, 0, sizeof(v4));
    IIOString::IIOString((IIOString *)v4, a1);
    v3 = (const char *)IIOString::utf8String((IIOString *)v4);
    asprintf(&v5, "%s-%s", v3, a2);
    if (v5)
    {
      ImageIOLog("%s   %s\n", "S", v5);
      free(v5);
    }
    IIOString::~IIOString((IIOString *)v4);
  }
}

void sub_187E5F44C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOXPCClient::useServerForInitImage(IIOXPCClient *a1, IIOImageRead *a2, uint64_t a3, int a4)
{
  return IIOXPCClient::useServerForCall(a1, a2, a3, a4, 4, 1);
}

uint64_t IIOXPCClient::useServerForDecodeImage(IIOXPCClient *a1, IIOImageRead *a2, uint64_t a3, int a4)
{
  return IIOXPCClient::useServerForCall(a1, a2, a3, a4, 6, 1);
}

uint64_t IIOXPCClient::useServerForImageCount(IIOXPCClient *a1, IIOImageRead *a2, uint64_t a3, int a4)
{
  return IIOXPCClient::useServerForCall(a1, a2, a3, a4, 2, 1);
}

uint64_t _cg_DGifGetExtensionNext(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int (*v5)(uint64_t, unsigned __int8 *, uint64_t);
  size_t v6;
  size_t v7;
  uint64_t v8;
  int (*v9)(uint64_t, uint64_t);
  size_t v10;
  uint64_t result;
  unsigned __int8 __ptr;

  __ptr = 0;
  v4 = *(_QWORD *)(a1 + 96);
  v5 = *(int (**)(uint64_t, unsigned __int8 *, uint64_t))(v4 + 48);
  if (v5)
    v6 = v5(a1, &__ptr, 1);
  else
    v6 = fread(&__ptr, 1uLL, 1uLL, *(FILE **)(v4 + 40));
  if (v6 == 1)
  {
    v7 = __ptr;
    if (!__ptr)
    {
      *(_QWORD *)a2 = 0;
      return 1;
    }
    *(_QWORD *)a2 = v4 + 64;
    *(_BYTE *)(v4 + 64) = v7;
    v8 = *(_QWORD *)(a1 + 96);
    v9 = *(int (**)(uint64_t, uint64_t))(v8 + 48);
    if (v9)
      v10 = v9(a1, *(_QWORD *)a2 + 1);
    else
      v10 = fread((void *)(*(_QWORD *)a2 + 1), 1uLL, v7, *(FILE **)(v8 + 40));
    if (v10 == __ptr)
      return 1;
  }
  result = 0;
  *(_DWORD *)(a1 + 80) = 102;
  return result;
}

uint64_t _cg_DGifGetRecordType(uint64_t a1, int *a2)
{
  uint64_t v3;
  uint64_t result;
  int v5;
  int (*v7)(uint64_t, char *, uint64_t);
  size_t v8;
  int v9;
  char __ptr;

  v3 = *(_QWORD *)(a1 + 96);
  if ((*(_WORD *)v3 & 8) != 0)
  {
    __ptr = 0;
    v7 = *(int (**)(uint64_t, char *, uint64_t))(v3 + 48);
    if (v7)
      v8 = v7(a1, &__ptr, 1);
    else
      v8 = fread(&__ptr, 1uLL, 1uLL, *(FILE **)(v3 + 40));
    if (v8 == 1)
    {
      switch(__ptr)
      {
        case '!':
          v9 = 3;
          break;
        case ';':
          v9 = 4;
          break;
        case ',':
          v9 = 2;
          break;
        default:
          result = 0;
          *a2 = 0;
          v5 = 107;
          goto LABEL_12;
      }
      *a2 = v9;
      return 1;
    }
    result = 0;
    v5 = 102;
  }
  else
  {
    result = 0;
    v5 = 111;
  }
LABEL_12:
  *(_DWORD *)(a1 + 80) = v5;
  return result;
}

uint64_t GlobalGIFInfo::getFrameInfoAtIndex@<X0>(GlobalGIFInfo *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  pthread_mutex_t *v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;

  *(_QWORD *)(a3 + 32) = 0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  v6 = (pthread_mutex_t *)((char *)this + 8);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 8));
  v7 = *((_QWORD *)this + 17);
  if (-858993459 * ((unint64_t)(*((_QWORD *)this + 18) - v7) >> 3) > a2)
  {
    v8 = v7 + 40 * a2;
    v9 = *(_OWORD *)(v8 + 16);
    *(_OWORD *)a3 = *(_OWORD *)v8;
    *(_OWORD *)(a3 + 16) = v9;
    *(_QWORD *)(a3 + 32) = *(_QWORD *)(v8 + 32);
  }
  return pthread_mutex_unlock(v6);
}

uint64_t _cg_DGifGetExtension(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t result;
  int v6;
  int (*v9)(uint64_t, unsigned __int8 *, uint64_t);
  size_t v10;
  unsigned __int8 __ptr;

  v4 = *(_QWORD *)(a1 + 96);
  if ((*(_WORD *)v4 & 8) != 0)
  {
    __ptr = 0;
    v9 = *(int (**)(uint64_t, unsigned __int8 *, uint64_t))(v4 + 48);
    if (v9)
      v10 = v9(a1, &__ptr, 1);
    else
      v10 = fread(&__ptr, 1uLL, 1uLL, *(FILE **)(v4 + 40));
    if (v10 == 1)
    {
      *a2 = __ptr;
      return _cg_DGifGetExtensionNext(a1, a3);
    }
    result = 0;
    v6 = 102;
  }
  else
  {
    result = 0;
    v6 = 111;
  }
  *(_DWORD *)(a1 + 80) = v6;
  return result;
}

uint64_t _cg_DGifExtensionToGCB(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  int v3;

  if (a1 != 4)
    return 0;
  *(_DWORD *)a3 = (*a2 >> 2) & 7;
  *(_BYTE *)(a3 + 4) = (*a2 & 2) != 0;
  *(_DWORD *)(a3 + 8) = *(unsigned __int16 *)(a2 + 1);
  if ((*a2 & 1) != 0)
    v3 = a2[3];
  else
    v3 = -1;
  *(_DWORD *)(a3 + 12) = v3;
  return 1;
}

uint64_t GlobalGIFInfo::setLastImageDescOffset(uint64_t this, uint64_t a2)
{
  *(_QWORD *)(this + 192) = a2;
  return this;
}

uint64_t GlobalGIFInfo::setFrameInfoAtIndex(uint64_t a1, __int128 *a2, uint64_t a3)
{
  pthread_mutex_t *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  unint64_t v14;
  __int128 v15;
  __int128 v16;
  char *v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  __int128 v24;
  __int128 v25;
  char *v26;
  char *v27;
  __int128 v28;
  __int128 v29;

  v6 = (pthread_mutex_t *)(a1 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  v7 = *(_QWORD *)(a1 + 136);
  v8 = *(_QWORD *)(a1 + 144);
  v9 = (uint64_t)(v8 - v7) >> 3;
  v10 = 0xCCCCCCCCCCCCCCCDLL * v9;
  if (a3 >= (-858993459 * v9))
  {
    v14 = *(_QWORD *)(a1 + 152);
    if (v8 >= v14)
    {
      if (v10 + 1 > 0x666666666666666)
        std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
      v18 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v14 - v7) >> 3);
      v19 = 2 * v18;
      if (2 * v18 <= v10 + 1)
        v19 = v10 + 1;
      if (v18 >= 0x333333333333333)
        v20 = 0x666666666666666;
      else
        v20 = v19;
      if (v20)
        v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOThumbnailInfo>>(a1 + 152, v20);
      else
        v21 = 0;
      v22 = &v21[40 * v10];
      v23 = &v21[40 * v20];
      v24 = *a2;
      v25 = a2[1];
      *((_QWORD *)v22 + 4) = *((_QWORD *)a2 + 4);
      *(_OWORD *)v22 = v24;
      *((_OWORD *)v22 + 1) = v25;
      v17 = v22 + 40;
      v27 = *(char **)(a1 + 136);
      v26 = *(char **)(a1 + 144);
      if (v26 != v27)
      {
        do
        {
          v28 = *(_OWORD *)(v26 - 40);
          v29 = *(_OWORD *)(v26 - 24);
          *((_QWORD *)v22 - 1) = *((_QWORD *)v26 - 1);
          *(_OWORD *)(v22 - 24) = v29;
          *(_OWORD *)(v22 - 40) = v28;
          v22 -= 40;
          v26 -= 40;
        }
        while (v26 != v27);
        v26 = *(char **)(a1 + 136);
      }
      *(_QWORD *)(a1 + 136) = v22;
      *(_QWORD *)(a1 + 144) = v17;
      *(_QWORD *)(a1 + 152) = v23;
      if (v26)
        operator delete(v26);
    }
    else
    {
      v15 = *a2;
      v16 = a2[1];
      *(_QWORD *)(v8 + 32) = *((_QWORD *)a2 + 4);
      *(_OWORD *)v8 = v15;
      *(_OWORD *)(v8 + 16) = v16;
      v17 = (char *)(v8 + 40);
    }
    *(_QWORD *)(a1 + 144) = v17;
  }
  else
  {
    v11 = v7 + 40 * a3;
    v12 = *a2;
    v13 = a2[1];
    *(_QWORD *)(v11 + 32) = *((_QWORD *)a2 + 4);
    *(_OWORD *)v11 = v12;
    *(_OWORD *)(v11 + 16) = v13;
  }
  return pthread_mutex_unlock(v6);
}

uint64_t GlobalGIFInfo::setLastFrameCount(uint64_t this, int a2)
{
  *(_DWORD *)(this + 200) = a2;
  return this;
}

uint64_t _cg_DGifGetCode(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  _WORD *v3;

  v3 = *(_WORD **)(a1 + 96);
  if ((*v3 & 8) != 0)
  {
    *a2 = (__int16)v3[2];
    return _cg_DGifGetCodeNext(a1, a3);
  }
  else
  {
    *(_DWORD *)(a1 + 80) = 111;
    return 0;
  }
}

char *IIOImageRead::copySourceInfo(IIOImageRead *this)
{
  const void *v2;
  CFIndex Length;
  unsigned int v4;
  const char *v5;
  char *v6;
  char *v8;
  char __str[1024];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v8 = 0;
  bzero(__str, 0x400uLL);
  if (*((_QWORD *)this + 7))
  {
    _CFStringGetFileSystemRepresentation();
  }
  else
  {
    v2 = (const void *)*((_QWORD *)this + 4);
    if (v2)
    {
      Length = CFDataGetLength(*((CFDataRef *)this + 4));
      snprintf(__str, 0x400uLL, "(CFDataRef) %p @\"%ld bytes\"", v2, Length);
    }
  }
  v4 = *((_DWORD *)this + 18) - 1;
  if (v4 > 9)
    v5 = "[unknown]      %s";
  else
    v5 = off_1E1BC9A90[v4];
  v6 = __str;
  if (!__str[0])
    v6 = "";
  asprintf(&v8, v5, v6);
  return v8;
}

uint64_t GlobalGIFInfo::setFinal(uint64_t this, char a2)
{
  *(_BYTE *)(this + 217) = a2;
  return this;
}

uint64_t GlobalGIFInfo::setSize(uint64_t this, int a2, int a3)
{
  *(_DWORD *)(this + 208) = a2;
  *(_DWORD *)(this + 212) = a3;
  return this;
}

BOOL GlobalGIFInfo::frameSizesMatchCanvasSize(GlobalGIFInfo *this, int a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  _BOOL8 result;

  v4 = *((_QWORD *)this + 17);
  v3 = *((_QWORD *)this + 18);
  if (v4 == v3)
    return 0;
  v5 = v4 + 40;
  do
  {
    v6 = *(unsigned __int16 *)(v5 - 28) == a2 || *(unsigned __int16 *)(v5 - 26) == a3;
    result = v6;
    if (v6)
      break;
    v6 = v5 == v3;
    v5 += 40;
  }
  while (!v6);
  return result;
}

uint64_t IIO_Reader_GIF::getImageCount(IIO_Reader_GIF *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  return IIO_Reader_GIF::parse(this, a2, a3, a4, a5, 0);
}

uint64_t IIO_Reader_ASTC::getImageCount(IIO_Reader_ASTC *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  IIO_ReaderHandler *BytesAtOffset;
  uint64_t result;
  __CFString **v12;
  IIO_ReaderHandler *ReaderHandler;
  int v14;
  IIO_Reader *v15;
  int v16;

  if (a5)
    *a5 = 0;
  v16 = 0;
  BytesAtOffset = (IIO_ReaderHandler *)IIOImageReadSession::getBytesAtOffset(a2, &v16, 0, 4uLL);
  if (BytesAtOffset == (IIO_ReaderHandler *)4 && v16 == 1554098963)
  {
    result = 0;
    if (a5)
      *a5 = 1;
  }
  else
  {
    v12 = (__CFString **)*((_QWORD *)this + 1);
    if (v12 == kCGImageTypeIdentifierKTX)
    {
      ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(BytesAtOffset);
      v14 = 1263818784;
    }
    else
    {
      if (v12 != kCGImageTypeIdentifierKTX2)
        return 4294967246;
      ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(BytesAtOffset);
      v14 = 1263818802;
    }
    v15 = IIO_ReaderHandler::readerForType(ReaderHandler, v14);
    return (*(uint64_t (**)(IIO_Reader *, IIOImageReadSession *, IIODictionary *, CGImageSourceStatus *, unsigned int *))(*(_QWORD *)v15 + 32))(v15, a2, a3, a4, a5);
  }
  return result;
}

uint64_t IIO_Reader_KTX::getImageCount(IIO_Reader_KTX *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  unsigned int v7;
  uint64_t v8;
  unsigned int v9;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  int8x16_t __dst[3];
  __int128 v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v15 = 0;
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v11, a2);
  v7 = v12;
  v17 = 0u;
  memset(__dst, 0, sizeof(__dst));
  if (IIOScanner::getBytesAtOffset((IIOScanner *)&v11, __dst, 0, 0x40uLL) != 64)
  {
    v8 = 4294967246;
    v9 = 1;
    goto LABEL_13;
  }
  if (!(*(unsigned int (**)(IIO_Reader_KTX *, int8x16_t *, uint64_t, _QWORD, _QWORD))(*(_QWORD *)this + 16))(this, __dst, 64, 0, 0))goto LABEL_12;
  SwapKTXHeader(__dst);
  v8 = ValidateKTXHeader(__dst, v12);
  if ((_DWORD)v8)
  {
    v9 = 0;
    goto LABEL_13;
  }
  if (HIDWORD(v17) > v7)
  {
    _cg_jpeg_mem_term("getImageCount", 164, "*** invalid KTX file: bytesOfKeyValueData: %d (fileSize: %d)\n", HIDWORD(v17), v7);
LABEL_12:
    v9 = 0;
    v8 = 4294967246;
    goto LABEL_13;
  }
  v9 = DWORD1(v17);
  v8 = 0;
  if ((_DWORD)v17)
  {
    if (DWORD1(v17) == 1)
      v9 = v17;
    else
      v9 = 1;
  }
LABEL_13:
  if (a5)
    *a5 = v9;
  IIOScanner::~IIOScanner((IIOScanner *)&v11);
  return v8;
}

void sub_187E5FD1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(exception_object);
}

void GlobalGIFInfo::setGlobalColorMap(uint64_t a1, uint64_t a2)
{
  IIOColorMap *v4;
  uint64_t v5;
  IIOColorMap **v6;
  uint64_t v7;

  if (a2)
  {
    v4 = (IIOColorMap *)operator new();
    GIFColorMap::GIFColorMap(v4, a2);
  }
  else
  {
    v4 = 0;
  }
  v7 = *(_QWORD *)(a1 + 176);
  v6 = (IIOColorMap **)(a1 + 176);
  v5 = v7;
  *v6 = v4;
  if (v7)
    std::default_delete<IIOColorMap>::operator()[abi:ne180100]((uint64_t)v6, v5);
}

void sub_187E5FDB4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x1020C40D090CC53);
  _Unwind_Resume(a1);
}

XMPMeta *WXMPMeta_CTor_1(_QWORD *a1)
{
  XMPMeta2 *v2;
  XMPMeta *result;
  int v4;

  *a1 = 0;
  if (sUseNewCoreAPIs)
  {
    v2 = (XMPMeta2 *)operator new();
    result = XMPMeta2::XMPMeta2(v2);
  }
  else
  {
    v2 = (XMPMeta2 *)operator new();
    result = XMPMeta::XMPMeta(v2);
  }
  v4 = *((_DWORD *)v2 + 2);
  *((_DWORD *)v2 + 2) = v4 + 1;
  if (v4)
    __assert_rtn("WXMPMeta_CTor_1", "WXMPMeta.cpp", 100, "xmpObj->clientRefs == 1");
  a1[1] = v2;
  return result;
}

void sub_187E5FE8C(void *a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  void *v7;
  const char *v8;
  void *v9;
  uint64_t v10;
  const char *v11;

  v5 = v3;
  MEMORY[0x18D761C30](v5, 0x10B3C4030275F38);
  if (a2 == 3)
  {
    v7 = __cxa_begin_catch(a1);
    *(_DWORD *)(v2 + 32) = *(_DWORD *)v7;
    v8 = (const char *)*((_QWORD *)v7 + 1);
    if (!v8)
      v8 = "";
    *(_QWORD *)v2 = v8;
    *(_QWORD *)(v2 + 8) = "XMP";
  }
  else
  {
    v9 = __cxa_begin_catch(a1);
    if (a2 == 2)
    {
      *(_DWORD *)(v2 + 32) = 13;
      v10 = (*(uint64_t (**)(void *))(*(_QWORD *)v9 + 16))(v9);
      v11 = "";
      if (v10)
        v11 = (const char *)v10;
    }
    else
    {
      *(_DWORD *)(v2 + 32) = 14;
      v11 = "Caught unknown exception";
    }
    *(_QWORD *)v2 = v11;
  }
  __cxa_end_catch();
}

void XMPMeta::XMPMeta(XMPMeta *this)
{
  *(_QWORD *)this = &off_1E1BB29E0;
  *((_DWORD *)this + 2) = 0;
  XMP_ReadWriteLock::XMP_ReadWriteLock((XMPMeta *)((char *)this + 16));
  XMP_Node::XMP_Node((XMPMeta *)((char *)this + 224), 0, "", 0);
  *((_QWORD *)this + 45) = 1;
  *((_BYTE *)this + 368) = 0;
  *((_QWORD *)this + 43) = 0;
  *((_QWORD *)this + 44) = &off_1E1BBBFF8;
  *((_QWORD *)this + 48) = 0;
  *((_QWORD *)this + 49) = 0;
  *((_QWORD *)this + 47) = 0;
  if (sDefaultErrorCallback(void)::onceToken != -1)
    dispatch_once(&sDefaultErrorCallback(void)::onceToken, &__block_literal_global_45);
  if (*(_QWORD *)(gDefaultErrorCallback + 32))
  {
    *((_QWORD *)this + 47) = *(_QWORD *)(gDefaultErrorCallback + 24);
    *((_QWORD *)this + 48) = *(_QWORD *)(gDefaultErrorCallback + 32);
    *((_QWORD *)this + 49) = *(_QWORD *)(gDefaultErrorCallback + 40);
    *((_DWORD *)this + 90) = *(_DWORD *)(gDefaultErrorCallback + 8);
  }
}

void sub_187E60040(_Unwind_Exception *a1)
{
  XMP_ReadWriteLock *v1;

  XMP_ReadWriteLock::~XMP_ReadWriteLock(v1);
  _Unwind_Resume(a1);
}

uint64_t XMPMeta::Initialize(XMPMeta *this)
{
  int v1;
  uint64_t result;
  AdobeXMPCore_Int::INameSpacePrefixMap_I *v3;
  XMP_ReadWriteLock *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  unsigned int *v8;
  unsigned int *v9;
  unsigned int *v10;
  unsigned int *v11;
  unsigned int *v12;
  unsigned int *v13;
  unsigned int *v14;
  unsigned int *v15;
  unsigned int *v16;
  unsigned int *v17;
  unsigned int *v18;
  unsigned int *v19;
  unsigned int *v20;
  unsigned int *v21;
  unsigned int *v22;
  unsigned int *v23;
  unsigned int *v24;
  unsigned int *v25;
  unsigned int *v26;
  unsigned int *v27;
  unsigned int *v28;
  unsigned int *v29;
  unsigned int *v30;
  unsigned int *v31;
  unsigned int *v32;
  unsigned int *v33;
  unsigned int *v34;
  unsigned int *v35;
  unsigned int *v36;
  unsigned int *v37;
  unsigned int *v38;
  unsigned int *v39;
  unsigned int *v40;
  unsigned int *v41;
  unsigned int *v42;
  unsigned int *v43;
  unsigned int *v44;
  unsigned int *v45;
  unsigned int *v46;
  unsigned int *v47;
  unsigned int *v48;
  unsigned int *v49;
  unsigned int *v50;
  unsigned int *v51;
  unsigned int *v52;
  unsigned int *v53;
  unsigned int *v54;
  unsigned int *v55;
  unsigned int *v56;
  unsigned int *v57;
  unsigned int *v58;
  unsigned int *v59;
  unsigned int *v60;
  unsigned int *v61;
  unsigned int *v62;
  XMPIterator *v63;
  XMPUtils *v64;
  _QWORD *exception;
  const char *v66;
  _BYTE v67[12];

  v1 = sXMP_InitCount++;
  if (v1 > 0)
    return 1;
  kdebug_trace();
  result = ImageIOShouldAllowFullsizeDecode();
  if ((_DWORD)result)
  {
    v3 = (AdobeXMPCore_Int::INameSpacePrefixMap_I *)AdobeXMPCore_Int::InitializeXMPCommonFramework((AdobeXMPCore_Int *)result);
    AdobeXMPCore_Int::INameSpacePrefixMap_I::CreateDefaultNameSpacePrefixMap(v3);
    v4 = (XMP_ReadWriteLock *)operator new();
    XMP_ReadWriteLock::XMP_ReadWriteLock(v4);
    sDefaultNamespacePrefixMapLock = (uint64_t)v4;
    sUseNewCoreAPIs = 0;
    v5 = (_QWORD *)operator new();
    std::string::basic_string[abi:ne180100]<0>(v5, "x-default");
    xdefaultName = (uint64_t)v5;
    v6 = (_QWORD *)operator new();
    *v6 = &off_1E1BB1880;
    XMP_ReadWriteLock::XMP_ReadWriteLock((XMP_ReadWriteLock *)(v6 + 1));
    v6[28] = 0;
    v6[27] = v6 + 28;
    v6[31] = 0;
    v6[32] = 0;
    v6[29] = 0;
    v6[30] = v6 + 31;
    sRegisteredNamespaces = (uint64_t)v6;
    v7 = (_QWORD *)operator new();
    v7[2] = 0;
    v7[1] = 0;
    *v7 = v7 + 1;
    sRegisteredAliasMap = (uint64_t)v7;
    InitializeUnicodeConversions();
    memset(v67, 0, sizeof(v67));
    XMPMeta::RegisterNamespace((XMPMeta *)"http://www.w3.org/XML/1998/namespace", "xml", (const char **)&v67[4], (const char **)v67, v8);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://www.w3.org/1999/02/22-rdf-syntax-ns#", "rdf", (const char **)&v67[4], (const char **)v67, v9);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://purl.org/dc/elements/1.1/", "dc", (const char **)&v67[4], (const char **)v67, v10);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/xap/1.0/", "xmp", (const char **)&v67[4], (const char **)v67, v11);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/pdf/1.3/", "pdf", (const char **)&v67[4], (const char **)v67, v12);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/photoshop/1.0/", "photoshop", (const char **)&v67[4], (const char **)v67, v13);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/album/1.0/", "album", (const char **)&v67[4], (const char **)v67, v14);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/exif/1.0/", "exif", (const char **)&v67[4], (const char **)v67, v15);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/exif/1.0/aux/", "aux", (const char **)&v67[4], (const char **)v67, v16);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://cipa.jp/exif/1.0/", "exifEX", (const char **)&v67[4], (const char **)v67, v17);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/tiff/1.0/", "tiff", (const char **)&v67[4], (const char **)v67, v18);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/png/1.0/", "png", (const char **)&v67[4], (const char **)v67, v19);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/jpeg/1.0/", "jpeg", (const char **)&v67[4], (const char **)v67, v20);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/jp2k/1.0/", "jp2k", (const char **)&v67[4], (const char **)v67, v21);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/camera-raw-settings/1.0/", "crs", (const char **)&v67[4], (const char **)v67, v22);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/asf/1.0/", "asf", (const char **)&v67[4], (const char **)v67, v23);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/xmp/wav/1.0/", "wav", (const char **)&v67[4], (const char **)v67, v24);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/StockPhoto/1.0/", "bmsp", (const char **)&v67[4], (const char **)v67, v25);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/creatorAtom/1.0/", "creatorAtom", (const char **)&v67[4], (const char **)v67, v26);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/xap/1.0/rights/", "xmpRights", (const char **)&v67[4], (const char **)v67, v27);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/xap/1.0/mm/", "xmpMM", (const char **)&v67[4], (const char **)v67, v28);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/xap/1.0/bj/", "xmpBJ", (const char **)&v67[4], (const char **)v67, v29);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/xmp/note/", "xmpNote", (const char **)&v67[4], (const char **)v67, v30);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/xmp/1.0/DynamicMedia/", "xmpDM", (const char **)&v67[4], (const char **)v67, v31);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/xmp/1.0/Script/", "xmpScript", (const char **)&v67[4], (const char **)v67, v32);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/bwf/bext/1.0/", "bext", (const char **)&v67[4], (const char **)v67, v33);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/aes/cart/", "AEScart", (const char **)&v67[4], (const char **)v67, v34);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/riff/info/", "riffinfo", (const char **)&v67[4], (const char **)v67, v35);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/xap/1.0/t/", "xmpT", (const char **)&v67[4], (const char **)v67, v36);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/xap/1.0/t/pg/", "xmpTPg", (const char **)&v67[4], (const char **)v67, v37);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/xap/1.0/g/", "xmpG", (const char **)&v67[4], (const char **)v67, v38);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/xap/1.0/g/img/", "xmpGImg", (const char **)&v67[4], (const char **)v67, v39);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/xap/1.0/sType/Font#", "stFnt", (const char **)&v67[4], (const char **)v67, v40);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/xap/1.0/sType/Dimensions#", "stDim", (const char **)&v67[4], (const char **)v67, v41);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/xap/1.0/sType/ResourceEvent#", "stEvt", (const char **)&v67[4], (const char **)v67, v42);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/xap/1.0/sType/ResourceRef#", "stRef", (const char **)&v67[4], (const char **)v67, v43);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/xap/1.0/sType/Version#", "stVer", (const char **)&v67[4], (const char **)v67, v44);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/xap/1.0/sType/Job#", "stJob", (const char **)&v67[4], (const char **)v67, v45);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/xap/1.0/sType/ManifestItem#", "stMfs", (const char **)&v67[4], (const char **)v67, v46);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/xmp/Identifier/qual/1.0/", "xmpidq", (const char **)&v67[4], (const char **)v67, v47);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://iptc.org/std/Iptc4xmpCore/1.0/xmlns/", "Iptc4xmpCore", (const char **)&v67[4], (const char **)v67, v48);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://iptc.org/std/Iptc4xmpExt/2008-02-29/", "Iptc4xmpExt", (const char **)&v67[4], (const char **)v67, v49);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/DICOM/", "DICOM", (const char **)&v67[4], (const char **)v67, v50);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.useplus.org/ldf/xmp/1.0/", "plus", (const char **)&v67[4], (const char **)v67, v51);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://www.aiim.org/pdfa/ns/schema#", "pdfaSchema", (const char **)&v67[4], (const char **)v67, v52);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://www.aiim.org/pdfa/ns/property#", "pdfaProperty", (const char **)&v67[4], (const char **)v67, v53);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://www.aiim.org/pdfa/ns/type#", "pdfaType", (const char **)&v67[4], (const char **)v67, v54);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://www.aiim.org/pdfa/ns/field#", "pdfaField", (const char **)&v67[4], (const char **)v67, v55);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://www.aiim.org/pdfa/ns/id/", "pdfaid", (const char **)&v67[4], (const char **)v67, v56);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://www.aiim.org/pdfa/ns/extension/", "pdfaExtension", (const char **)&v67[4], (const char **)v67, v57);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/pdfx/1.3/", "pdfx", (const char **)&v67[4], (const char **)v67, v58);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://www.npes.org/pdfx/ns/id/", "pdfxid", (const char **)&v67[4], (const char **)v67, v59);
    XMPMeta::RegisterNamespace((XMPMeta *)"adobe:ns:meta/", "x", (const char **)&v67[4], (const char **)v67, v60);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/iX/1.0/", "iX", (const char **)&v67[4], (const char **)v67, v61);
    XMPMeta::RegisterNamespace((XMPMeta *)"http://ns.adobe.com/ixml/1.0/", "iXML", (const char **)&v67[4], (const char **)v67, v62);
    RegisterAlias("http://ns.adobe.com/xap/1.0/", "Author", "http://purl.org/dc/elements/1.1/", "creator", 0x400u);
    RegisterAlias("http://ns.adobe.com/xap/1.0/", "Authors", "http://purl.org/dc/elements/1.1/", "creator", 0);
    RegisterAlias("http://ns.adobe.com/xap/1.0/", "Description", "http://purl.org/dc/elements/1.1/", "description", 0);
    RegisterAlias("http://ns.adobe.com/xap/1.0/", "Format", "http://purl.org/dc/elements/1.1/", "format", 0);
    RegisterAlias("http://ns.adobe.com/xap/1.0/", "Keywords", "http://purl.org/dc/elements/1.1/", "subject", 0);
    RegisterAlias("http://ns.adobe.com/xap/1.0/", "Locale", "http://purl.org/dc/elements/1.1/", "language", 0);
    RegisterAlias("http://ns.adobe.com/xap/1.0/", "Title", "http://purl.org/dc/elements/1.1/", "title", 0);
    RegisterAlias("http://ns.adobe.com/xap/1.0/rights/", "Copyright", "http://purl.org/dc/elements/1.1/", "rights", 0);
    RegisterAlias("http://ns.adobe.com/pdf/1.3/", "Author", "http://purl.org/dc/elements/1.1/", "creator", 0x400u);
    RegisterAlias("http://ns.adobe.com/pdf/1.3/", "BaseURL", "http://ns.adobe.com/xap/1.0/", "BaseURL", 0);
    RegisterAlias("http://ns.adobe.com/pdf/1.3/", "CreationDate", "http://ns.adobe.com/xap/1.0/", "CreateDate", 0);
    RegisterAlias("http://ns.adobe.com/pdf/1.3/", "Creator", "http://ns.adobe.com/xap/1.0/", "CreatorTool", 0);
    RegisterAlias("http://ns.adobe.com/pdf/1.3/", "ModDate", "http://ns.adobe.com/xap/1.0/", "ModifyDate", 0);
    RegisterAlias("http://ns.adobe.com/pdf/1.3/", "Subject", "http://purl.org/dc/elements/1.1/", "description", 0x1000u);
    RegisterAlias("http://ns.adobe.com/pdf/1.3/", "Title", "http://purl.org/dc/elements/1.1/", "title", 0x1000u);
    RegisterAlias("http://ns.adobe.com/photoshop/1.0/", "Author", "http://purl.org/dc/elements/1.1/", "creator", 0x400u);
    RegisterAlias("http://ns.adobe.com/photoshop/1.0/", "Caption", "http://purl.org/dc/elements/1.1/", "description", 0x1000u);
    RegisterAlias("http://ns.adobe.com/photoshop/1.0/", "Copyright", "http://purl.org/dc/elements/1.1/", "rights", 0x1000u);
    RegisterAlias("http://ns.adobe.com/photoshop/1.0/", "Keywords", "http://purl.org/dc/elements/1.1/", "subject", 0);
    RegisterAlias("http://ns.adobe.com/photoshop/1.0/", "Marked", "http://ns.adobe.com/xap/1.0/rights/", "Marked", 0);
    RegisterAlias("http://ns.adobe.com/photoshop/1.0/", "Title", "http://purl.org/dc/elements/1.1/", "title", 0x1000u);
    RegisterAlias("http://ns.adobe.com/photoshop/1.0/", "WebStatement", "http://ns.adobe.com/xap/1.0/rights/", "WebStatement", 0);
    RegisterAlias("http://ns.adobe.com/tiff/1.0/", "Artist", "http://purl.org/dc/elements/1.1/", "creator", 0x400u);
    RegisterAlias("http://ns.adobe.com/tiff/1.0/", "Copyright", "http://purl.org/dc/elements/1.1/", "rights", 0);
    RegisterAlias("http://ns.adobe.com/tiff/1.0/", "DateTime", "http://ns.adobe.com/xap/1.0/", "ModifyDate", 0);
    RegisterAlias("http://ns.adobe.com/exif/1.0/", "DateTimeDigitized", "http://ns.adobe.com/xap/1.0/", "CreateDate", 0);
    RegisterAlias("http://ns.adobe.com/tiff/1.0/", "ImageDescription", "http://purl.org/dc/elements/1.1/", "description", 0x1000u);
    RegisterAlias("http://ns.adobe.com/tiff/1.0/", "Software", "http://ns.adobe.com/xap/1.0/", "CreatorTool", 0);
    RegisterAlias("http://ns.adobe.com/png/1.0/", "Author", "http://purl.org/dc/elements/1.1/", "creator", 0x400u);
    RegisterAlias("http://ns.adobe.com/png/1.0/", "Copyright", "http://purl.org/dc/elements/1.1/", "rights", 0x1000u);
    RegisterAlias("http://ns.adobe.com/png/1.0/", "CreationTime", "http://ns.adobe.com/xap/1.0/", "CreateDate", 0);
    RegisterAlias("http://ns.adobe.com/png/1.0/", "Description", "http://purl.org/dc/elements/1.1/", "description", 0x1000u);
    RegisterAlias("http://ns.adobe.com/png/1.0/", "ModificationTime", "http://ns.adobe.com/xap/1.0/", "ModifyDate", 0);
    RegisterAlias("http://ns.adobe.com/png/1.0/", "Software", "http://ns.adobe.com/xap/1.0/", "CreatorTool", 0);
    RegisterAlias("http://ns.adobe.com/png/1.0/", "Title", "http://purl.org/dc/elements/1.1/", "title", 0x1000u);
    v64 = (XMPUtils *)XMPIterator::Initialize(v63);
    if ((v64 & 1) != 0)
    {
      if ((XMPUtils::Initialize(v64) & 1) != 0)
        return *kXMPCore_EmbeddedVersion[0] && *kXMPCore_EmbeddedCopyright[0] != 0;
      exception = __cxa_allocate_exception(0x18uLL);
      *(_DWORD *)exception = 9;
      v66 = "Failure from XMPUtils::Initialize";
    }
    else
    {
      exception = __cxa_allocate_exception(0x18uLL);
      *(_DWORD *)exception = 9;
      v66 = "Failure from XMPIterator::Initialize";
    }
    exception[1] = v66;
    *((_BYTE *)exception + 16) = 0;
  }
  return result;
}

BOOL XMPMeta::RegisterNamespace(XMPMeta *this, char *a2, const char **a3, const char **a4, unsigned int *a5)
{
  _BOOL8 v6;
  AdobeXMPCore_Int::INameSpacePrefixMap_I *p_p;
  const char *v8;
  XMP_ReadWriteLock *v10;
  void *__p;
  const char *v12;
  uint64_t v13;
  unsigned int v14;
  void *__src;

  v6 = XMP_NamespaceTable::Define((XMP_NamespaceTable *)sRegisteredNamespaces, (char *)this, a2, a3, (unsigned int *)a4);
  __src = 0;
  v14 = 0;
  XMP_NamespaceTable::GetPrefix((XMP_NamespaceTable *)sRegisteredNamespaces, (char *)this, (const char **)&__src, &v14);
  __p = 0;
  v12 = 0;
  v13 = 0;
  std::string::basic_string[abi:ne180100](&__p, __src, v14 - 1);
  v10 = (XMP_ReadWriteLock *)sDefaultNamespacePrefixMapLock;
  XMP_ReadWriteLock::Acquire((pthread_rwlock_t *)sDefaultNamespacePrefixMapLock, 1);
  if (v13 >= 0)
    p_p = (AdobeXMPCore_Int::INameSpacePrefixMap_I *)&__p;
  else
    p_p = (AdobeXMPCore_Int::INameSpacePrefixMap_I *)__p;
  if (v13 >= 0)
    v8 = (const char *)HIBYTE(v13);
  else
    v8 = v12;
  AdobeXMPCore_Int::INameSpacePrefixMap_I::InsertInDefaultNameSpacePrefixMap(p_p, v8, (uint64_t)this, (const char *)0xFFFFFFFFFFFFFFFFLL);
  XMP_AutoLock::~XMP_AutoLock(&v10);
  if (SHIBYTE(v13) < 0)
    operator delete(__p);
  return v6;
}

void sub_187E60E1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  XMP_AutoLock::~XMP_AutoLock((XMP_ReadWriteLock **)&a9);
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t AdobeXMPCore_Int::INameSpacePrefixMap_I::InsertInDefaultNameSpacePrefixMap(AdobeXMPCore_Int::INameSpacePrefixMap_I *this, const char *a2, uint64_t a3, const char *a4)
{
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  uint64_t v13;
  std::__shared_weak_count *v14;

  AdobeXMPCore_Int::ManageDefaultNameSpacePrefixMap(0, &v13);
  v8 = (*(uint64_t (**)(uint64_t, AdobeXMPCore_Int::INameSpacePrefixMap_I *, const char *, uint64_t, const char *))(*(_QWORD *)v13 + 40))(v13, this, a2, a3, a4);
  v9 = v14;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  return v8;
}

void sub_187E60EEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

_QWORD *AdobeXMPCore_Int::ManageDefaultNameSpacePrefixMap@<X0>(AdobeXMPCore_Int *this@<X0>, _QWORD *a2@<X8>)
{
  int v2;
  _QWORD *result;
  uint64_t v5;
  _OWORD *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  __int128 v12;

  v2 = (int)this;
  result = (_QWORD *)AdobeXMPCore_Int::ManageDefaultNameSpacePrefixMap(BOOL)::sDefaultNameSpacePrefixMap;
  if (v2)
  {
    std::shared_ptr<AdobeXMPCore::INode_v1>::reset[abi:ne180100]((_QWORD *)AdobeXMPCore_Int::ManageDefaultNameSpacePrefixMap(BOOL)::sDefaultNameSpacePrefixMap);
    result = (_QWORD *)AdobeXMPCore_Int::ManageDefaultNameSpacePrefixMap(BOOL)::sDefaultNameSpacePrefixMap;
    if (AdobeXMPCore_Int::ManageDefaultNameSpacePrefixMap(BOOL)::sDefaultNameSpacePrefixMap)
    {
      v5 = std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100](AdobeXMPCore_Int::ManageDefaultNameSpacePrefixMap(BOOL)::sDefaultNameSpacePrefixMap);
      result = (_QWORD *)MEMORY[0x18D761C30](v5, 0x20C40A4A59CD2);
    }
    AdobeXMPCore_Int::ManageDefaultNameSpacePrefixMap(BOOL)::sDefaultNameSpacePrefixMap = 0;
    goto LABEL_5;
  }
  if (!AdobeXMPCore_Int::ManageDefaultNameSpacePrefixMap(BOOL)::sDefaultNameSpacePrefixMap)
  {
    v12 = 0uLL;
    AdobeXMPCore::INameSpacePrefixMap_v1::CreateNameSpacePrefixMap(&v12);
    v6 = (_OWORD *)operator new();
    v7 = (char *)v12;
    *v6 = v12;
    v8 = *(_QWORD *)v7;
    AdobeXMPCore_Int::ManageDefaultNameSpacePrefixMap(BOOL)::sDefaultNameSpacePrefixMap = (uint64_t)v6;
    (**(void (***)(char *))&v7[*(_QWORD *)(v8 - 72)])(&v7[*(_QWORD *)(v8 - 72)]);
    result = (_QWORD *)AdobeXMPCore_Int::ManageDefaultNameSpacePrefixMap(BOOL)::sDefaultNameSpacePrefixMap;
    if (!AdobeXMPCore_Int::ManageDefaultNameSpacePrefixMap(BOOL)::sDefaultNameSpacePrefixMap)
    {
LABEL_5:
      *a2 = 0;
      a2[1] = 0;
      return result;
    }
  }
  v9 = result[1];
  *a2 = *result;
  a2[1] = v9;
  if (v9)
  {
    v10 = (unint64_t *)(v9 + 8);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  return result;
}

void sub_187E60FDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t `virtual thunk to'AdobeXMPCore_Int::NameSpacePrefixMapImpl::Insert(AdobeXMPCore_Int::NameSpacePrefixMapImpl *this, char *a2, const char *a3, char *a4, size_t a5)
{
  return AdobeXMPCore_Int::NameSpacePrefixMapImpl::Insert((uint64_t **)((char *)this + *(_QWORD *)(*(_QWORD *)this - 80)), a2, a3, a4, a5);
}

void XMP_ReadWriteLock::XMP_ReadWriteLock(XMP_ReadWriteLock *this)
{
  _QWORD *exception;

  *((_BYTE *)this + 204) = 0;
  atomic_store(0, (unsigned int *)this + 50);
  if (pthread_rwlock_init((pthread_rwlock_t *)this, 0))
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 11;
    exception[1] = "Initialize pthread rwlock failed";
    *((_BYTE *)exception + 16) = 0;
  }
}

uint64_t AdobeXMPCore_Int::IMemoryAllocator_I::SetMemoryAllocator(uint64_t a1)
{
  if (AdobeXMPCore_Int::sDefaultMemoryAllocator(void)::onceToken != -1)
    dispatch_once(&AdobeXMPCore_Int::sDefaultMemoryAllocator(void)::onceToken, &__block_literal_global_42);
  return AdobeXMPCore_Int::MemoryAllocatorWrapperImpl::SetMemoryAllocator(AdobeXMPCore_Int::gDefaultMemoryAllocator, a1);
}

uint64_t AdobeXMPCore_Int::MemoryAllocatorWrapperImpl::SetMemoryAllocator(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 8) = a2;
  return v2;
}

uint64_t ImageIOShouldAllowFullsizeDecode()
{
  return 1;
}

uint64_t XMPUtils::Initialize(XMPUtils *this)
{
  std::string *v1;

  if (!XMPUtils::WhiteSpaceStrPtr)
  {
    v1 = (std::string *)operator new();
    v1->__r_.__value_.__l.__size_ = 0;
    v1->__r_.__value_.__r.__words[2] = 0;
    v1->__r_.__value_.__r.__words[0] = 0;
    XMPUtils::WhiteSpaceStrPtr = (uint64_t)v1;
    std::string::append(v1, " \t\n\r");
  }
  return 1;
}

void AdobeXMPCore_Int::ThreadSafeImpl::EnableThreadSafety(AdobeXMPCore_Int::ThreadSafeImpl *this)
{
  char *v1;
  std::__shared_weak_count *v2;
  unint64_t *v3;
  unint64_t v4;
  __int128 v5;

  v1 = (char *)this + 8;
  if (!*((_QWORD *)this + 1))
  {
    AdobeXMPCore_Int::ISharedMutex::CreateSharedMutex(&v5);
    std::shared_ptr<IIOTextureDataImp>::operator=[abi:ne180100]<BCTextureImp,void>((uint64_t)v1, &v5);
    v2 = (std::__shared_weak_count *)*((_QWORD *)&v5 + 1);
    if (*((_QWORD *)&v5 + 1))
    {
      v3 = (unint64_t *)(*((_QWORD *)&v5 + 1) + 8);
      do
        v4 = __ldaxr(v3);
      while (__stlxr(v4 - 1, v3));
      if (!v4)
      {
        ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
        std::__shared_weak_count::__release_weak(v2);
      }
    }
  }
}

void AdobeXMPCore_Int::INameSpacePrefixMap_I::CreateDefaultNameSpacePrefixMap(AdobeXMPCore_Int::INameSpacePrefixMap_I *this)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;
  uint64_t v4;
  std::__shared_weak_count *v5;

  AdobeXMPCore_Int::ManageDefaultNameSpacePrefixMap(0, &v4);
  v1 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

_QWORD *AdobeXMPCore_Int::ISharedMutex::CreateSharedMutex@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v3;
  _QWORD *result;
  uint64_t v5;
  uint64_t v6;
  _QWORD v7[2];

  v3 = (_QWORD *)AdobeXMPCore_Int::MemoryManagedObject::operator new((AdobeXMPCore_Int::MemoryManagedObject *)0x20);
  v3[2] = 0;
  v3[3] = 0;
  *v3 = off_1E1BB7868;
  v3[1] = off_1E1BB7908;
  AdobeXMPCore_Int::SharedObjectImpl::Acquire((uint64_t)(v3 + 1));
  result = std::shared_ptr<AdobeXMPCore_Int::SharedMutexImpl>::shared_ptr[abi:ne180100]<AdobeXMPCore_Int::SharedMutexImpl,std::__mem_fn<void (AdobeXMPCore_Int::SharedObjectImpl::*)(void)const>,void>(v7, (uint64_t)v3, 8, 1);
  v5 = v7[0];
  if (v7[0])
    v5 = v7[0] + *(_QWORD *)(*(_QWORD *)v7[0] - 112);
  v6 = v7[1];
  *a1 = v5;
  a1[1] = v6;
  return result;
}

_QWORD *AdobeXMPCore::INameSpacePrefixMap_v1::CreateNameSpacePrefixMap@<X0>(_QWORD *a1@<X8>)
{
  uint64_t v3;
  _QWORD *result;
  uint64_t v5;
  uint64_t v6;
  _QWORD v7[2];

  v3 = AdobeXMPCore_Int::MemoryManagedObject::operator new((AdobeXMPCore_Int::MemoryManagedObject *)0x78);
  *(_QWORD *)(v3 + 64) = 0x100000000;
  *(_QWORD *)(v3 + 104) = 0;
  *(_QWORD *)(v3 + 112) = 0;
  *(_QWORD *)(v3 + 72) = off_1E1BBA1F8;
  *(_QWORD *)(v3 + 80) = 0;
  *(_QWORD *)(v3 + 88) = 0;
  *(_QWORD *)(v3 + 96) = off_1E1BBA288;
  *(_QWORD *)(v3 + 16) = 0;
  *(_QWORD *)v3 = off_1E1BB9F70;
  *(_QWORD *)(v3 + 8) = v3 + 16;
  *(_QWORD *)(v3 + 48) = 0;
  *(_QWORD *)(v3 + 56) = off_1E1BBA100;
  *(_QWORD *)(v3 + 40) = 0;
  *(_QWORD *)(v3 + 24) = 0;
  *(_QWORD *)(v3 + 32) = v3 + 40;
  result = AdobeXMPCore_Int::MakeUncheckedSharedPointer<AdobeXMPCore_Int::NameSpacePrefixMapImpl>((char *)v3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ImageIO/XMP-Toolkit-SDK/XMPCore/source/NameSpacePrefixMapImpl.cpp", 332, 1, v7);
  v5 = v7[0];
  if (v7[0])
    v5 = v7[0] + *(_QWORD *)(*(_QWORD *)v7[0] - 48);
  v6 = v7[1];
  *a1 = v5;
  a1[1] = v6;
  return result;
}

_QWORD *AdobeXMPCore_Int::MakeUncheckedSharedPointer<AdobeXMPCore_Int::NameSpacePrefixMapImpl>@<X0>(char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, _QWORD *a5@<X8>)
{
  _OWORD *exception;
  __int128 v11;

  if (!a1 && a4)
  {
    v11 = 0uLL;
    AdobeXMPCore_Int::IError_I::CreateError(1, 6, 2, &v11);
    (*(void (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)(v11 + *(_QWORD *)(*(_QWORD *)v11 - 304)) + 120))(v11 + *(_QWORD *)(*(_QWORD *)v11 - 304), a2, a3);
    (*(void (**)(_QWORD, const char *, uint64_t))(*(_QWORD *)(v11 + *(_QWORD *)(*(_QWORD *)v11 - 304))
                                                          + 112))(v11 + *(_QWORD *)(*(_QWORD *)v11 - 304), "NULL pointer provided for creating shared pointer", -1);
    exception = __cxa_allocate_exception(0x10uLL);
    *exception = v11;
    v11 = 0uLL;
  }
  (**(void (***)(char *))&a1[*(_QWORD *)(*(_QWORD *)a1 - 184)])(&a1[*(_QWORD *)(*(_QWORD *)a1 - 184)]);
  return std::shared_ptr<AdobeXMPCore_Int::NameSpacePrefixMapImpl>::shared_ptr[abi:ne180100]<AdobeXMPCore_Int::NameSpacePrefixMapImpl,std::__mem_fn<void (AdobeXMPCore_Int::SharedObjectImpl::*)(void)const>,void>(a5, (uint64_t)a1, 8, 1);
}

void sub_187E61440(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t XMPIterator::Initialize(XMPIterator *this)
{
  XMP_Node *v1;

  v1 = (XMP_Node *)operator new();
  XMP_Node::XMP_Node(v1, 0, "dummy:schema/", 0x80000000);
  sDummySchema = (uint64_t)v1;
  return 1;
}

void sub_187E614A8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10B3C407D34617ELL);
  _Unwind_Resume(a1);
}

void InitializeUnicodeConversions(void)
{
  UTF8_to_UTF16Native = (uint64_t)UTF8_to_UTF16Nat;
  UTF8_to_UTF32Native = (uint64_t)UTF8_to_UTF32Nat;
  UTF16Native_to_UTF8 = (uint64_t)UTF16Nat_to_UTF8;
  UTF32Native_to_UTF8 = (uint64_t)UTF32Nat_to_UTF8;
  swap32to16Offset = 1;
  CodePoint_to_UTF16BE = (uint64_t)CodePoint_to_UTF16Swp;
  CodePoint_to_UTF16LE = (uint64_t)CodePoint_to_UTF16Nat;
  CodePoint_from_UTF16BE = (uint64_t)CodePoint_from_UTF16Swp;
  CodePoint_from_UTF16LE = (uint64_t)CodePoint_from_UTF16Nat;
  UTF8_to_UTF16BE = (uint64_t)UTF8_to_UTF16Swp;
  UTF8_to_UTF16LE = (uint64_t)UTF8_to_UTF16Nat;
  UTF8_to_UTF32BE = (uint64_t)UTF8_to_UTF32Swp;
  UTF8_to_UTF32LE = (uint64_t)UTF8_to_UTF32Nat;
  UTF16BE_to_UTF8 = (uint64_t)UTF16Swp_to_UTF8;
  UTF16LE_to_UTF8 = (uint64_t)UTF16Nat_to_UTF8;
  UTF32BE_to_UTF8 = (uint64_t)UTF32Swp_to_UTF8;
  UTF32LE_to_UTF8 = (uint64_t)UTF32Nat_to_UTF8;
  UTF16BE_to_UTF32BE = (uint64_t)UTF16Swp_to_UTF32Swp;
  UTF16BE_to_UTF32LE = (uint64_t)UTF16Swp_to_UTF32Nat;
  UTF16LE_to_UTF32BE = (uint64_t)UTF16Nat_to_UTF32Swp;
  UTF16LE_to_UTF32LE = (uint64_t)UTF16Nat_to_UTF32Nat;
  UTF32BE_to_UTF16BE = (uint64_t)UTF32Swp_to_UTF16Swp;
  UTF32BE_to_UTF16LE = (uint64_t)UTF32Swp_to_UTF16Nat;
  UTF32LE_to_UTF16BE = (uint64_t)UTF32Nat_to_UTF16Swp;
  UTF32LE_to_UTF16LE = (uint64_t)UTF32Nat_to_UTF16Nat;
}

void std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(a1, a2[1]);
    std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::string>,0>((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

CGImageMetadata *CreateMetadataFromXMPBufferInternal(const char *a1, uint64_t a2, const char *a3, uint64_t a4, int a5)
{
  CGImageMetadata *Mutable;
  CGImageMetadataTagRef v11;
  const __CFAllocator *v12;
  uint64_t v13;
  XMPMeta *v14;
  const char *v15;
  const __CFString *v16;
  const __CFString *NamespaceURIForPropertyPath;
  const __CFString *PropertyPrefixFromPath;
  const __CFString *PropertyNameFromPath;
  const char *CStringPtr;
  const char *v21;
  const __CFString *v22;
  const __CFString *v23;
  const char *v24;
  CGImageMetadataTagRef v25;
  int v26;
  const char *v27;
  void *p_p;
  const char *v29;
  __CFDictionary *StructPropertyValue;
  CGImageMetadataTagRef v31;
  const char *v32;
  const char *v33;
  void *v34;
  const char *v35;
  const __CFArray *ArrayPropertyValue;
  CGImageMetadataType v37;
  const __CFString *v38;
  const __CFString *v39;
  CGImageMetadataTagRef v40;
  int v41;
  void *TagWithPath;
  uint64_t v43;
  const void *Value;
  void *v45;
  void *v46;
  uint64_t v47;
  const void *v48;
  void *v49;
  void *v50;
  uint64_t v51;
  const void *v52;
  void *v53;
  void *v54;
  uint64_t v55;
  const void *v56;
  void *v57;
  void *v58;
  uint64_t v59;
  const void *v60;
  void *v61;
  uint64_t v62;
  const __CFString *v64;
  const __CFString *v65;
  CFTypeID v66;
  CFArrayRef ArrayBySeparatingStrings;
  CFArrayRef v68;
  void *v69;
  int v70;
  uint64_t (**v71)();
  _DWORD *v72;
  uint64_t (**v73)();
  _DWORD *v74;
  CFErrorRef err;
  void *__p;
  _DWORD *v77;
  uint64_t v78;
  uint64_t (**v79)();
  _DWORD *v80;
  uint64_t v81;
  uint64_t (**v82)();
  _DWORD *v83;
  int v84;
  char *cStr[2];
  uint64_t v86;
  char *v87;
  uint64_t v88;
  uint64_t v89;
  void *v90[2];
  uint64_t v91;

  Mutable = 0;
  if (!a1 || !a2)
    return Mutable;
  pthread_mutex_lock(&CreateMetadataFromXMPBufferInternal(char const*,unsigned long,char const*,unsigned long,unsigned int)::mutex);
  v90[0] = 0;
  v90[1] = 0;
  v91 = 0;
  v87 = 0;
  v88 = 0;
  v89 = 0;
  cStr[0] = 0;
  cStr[1] = 0;
  v86 = 0;
  v84 = 0;
  v70 = a5;
  if ((IIO_InitializeXMPToolkit() & 1) == 0)
  {
    pthread_mutex_unlock(&CreateMetadataFromXMPBufferInternal(char const*,unsigned long,char const*,unsigned long,unsigned int)::mutex);
    Mutable = 0;
    v11 = 0;
    v26 = 1;
    goto LABEL_112;
  }
  v82 = 0;
  v83 = 0;
  TXMPMeta<std::string>::TXMPMeta(&v82);
  v81 = 0;
  TXMPMeta<std::string>::SetErrorCallback((uint64_t)&v82, (uint64_t)IIO_XMPMeta_ErrorCallback, (uint64_t)&v81, 9999);
  TXMPMeta<std::string>::ParseFromBuffer((uint64_t)&v82, (uint64_t)a1, a2, 0);
  if (a3 && a4)
  {
    if (gIIO_SkipExtendedXMPMutex != -1)
      dispatch_once(&gIIO_SkipExtendedXMPMutex, &__block_literal_global_17);
    if (!gIIO_SkipExtendedXMP)
    {
      __p = 0;
      v77 = 0;
      TXMPMeta<std::string>::TXMPMeta(&__p, (uint64_t)a3, a4);
      TXMPUtils<std::string>::MergeFromJPEG((uint64_t)&v82, (uint64_t)&__p);
      __p = &off_1E1BB2B60;
      WXMPMeta_DecrementRefCount_1(v77);
    }
  }
  v79 = 0;
  v80 = 0;
  TXMPIterator<std::string>::TXMPIterator(&v79, (uint64_t)&v82, 0x400u);
  Mutable = 0;
  v11 = 0;
  v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  while (TXMPIterator<std::string>::Next((uint64_t)&v79, (uint64_t)v90, (uint64_t)&v87, (uint64_t)cStr, (uint64_t *)&v84))
  {
    __p = 0;
    v77 = 0;
    v78 = 0;
    v13 = HIBYTE(v89);
    if (v89 < 0)
      v13 = v88;
    if (v13)
    {
      if (Mutable || (Mutable = CGImageMetadataCreateMutable()) != 0)
      {
        if (v91 >= 0)
          v14 = (XMPMeta *)v90;
        else
          v14 = (XMPMeta *)v90[0];
        TXMPMeta<std::string>::GetNamespacePrefix(v14, (uint64_t)&__p);
        if (v89 >= 0)
          v15 = (const char *)&v87;
        else
          v15 = v87;
        v16 = CFStringCreateWithCString(v12, v15, 0x8000100u);
        NamespaceURIForPropertyPath = createNamespaceURIForPropertyPath(v16);
        PropertyPrefixFromPath = createPropertyPrefixFromPath(v16);
        PropertyNameFromPath = createPropertyNameFromPath(v16);
        err = 0;
        if (!CGImageMetadataRegisterNamespaceForPrefix(Mutable, NamespaceURIForPropertyPath, PropertyPrefixFromPath, &err))
        {
          CStringPtr = CFStringGetCStringPtr(PropertyPrefixFromPath, 0);
          v21 = v91 >= 0 ? (const char *)v90 : (const char *)v90[0];
          LogMetadata("CreateMetadataFromXMPBufferInternal", 479, "An error occurred while registering prefix '%s' for namespace '%s'\n", CStringPtr, v21);
          if (err)
          {
            v22 = CFErrorCopyFailureReason(err);
            v23 = v22;
            if (v22)
            {
              v24 = CFStringGetCStringPtr(v22, 0);
              LogMetadata("CreateMetadataFromXMPBufferInternal", 485, "Failure Reason: %s\n", v24);
              CFRelease(v23);
            }
          }
        }
        if ((v84 & 0x80010000) != 0)
          goto LABEL_31;
        if ((v84 & 0x1F00) != 0)
        {
          if ((v84 & 0x200) == 0)
          {
            if ((v84 & 0x100) == 0)
              goto LABEL_31;
            v71 = &off_1E1BB2B60;
            v72 = v83;
            WXMPMeta_IncrementRefCount_1((uint64_t)v83);
            if (v91 >= 0)
              v27 = (const char *)v90;
            else
              v27 = (const char *)v90[0];
            if (v78 >= 0)
              p_p = &__p;
            else
              p_p = __p;
            if (v89 >= 0)
              v29 = (const char *)&v87;
            else
              v29 = v87;
            StructPropertyValue = createStructPropertyValue(Mutable, (uint64_t)&v71, v27, (uint64_t)p_p, v29);
            v71 = &off_1E1BB2B60;
            WXMPMeta_DecrementRefCount_1(v72);
            v72 = 0;
            if (StructPropertyValue)
            {
              v31 = CGImageMetadataTagCreate(NamespaceURIForPropertyPath, PropertyPrefixFromPath, PropertyNameFromPath, kCGImageMetadataTypeStructure, StructPropertyValue);
              if (v31)
              {
                CGImageMetadataAddTag((uint64_t)Mutable, v31);
                if (v11)
                  CFRelease(v11);
              }
              else
              {
                v31 = v11;
              }
              v11 = v31;
              CFRelease(StructPropertyValue);
            }
            TXMPIterator<std::string>::Skip((uint64_t)&v79, 1);
            v25 = v11;
            goto LABEL_32;
          }
          v73 = &off_1E1BB2B60;
          v74 = v83;
          WXMPMeta_IncrementRefCount_1((uint64_t)v83);
          if (v91 >= 0)
            v33 = (const char *)v90;
          else
            v33 = (const char *)v90[0];
          if (v78 >= 0)
            v34 = &__p;
          else
            v34 = __p;
          if (v89 >= 0)
            v35 = (const char *)&v87;
          else
            v35 = v87;
          ArrayPropertyValue = createArrayPropertyValue(Mutable, (uint64_t)&v73, v33, (uint64_t)v34, v35);
          v73 = &off_1E1BB2B60;
          WXMPMeta_DecrementRefCount_1(v74);
          v74 = 0;
          if ((v84 & 0x1000) != 0)
          {
            v37 = kCGImageMetadataTypeAlternateText;
            if (ArrayPropertyValue)
              goto LABEL_88;
          }
          else
          {
            if ((v84 & 0x800) == 0)
            {
              if ((v84 & 0x400) != 0)
                v37 = kCGImageMetadataTypeArrayOrdered;
              else
                v37 = kCGImageMetadataTypeArrayUnordered;
              if (!ArrayPropertyValue)
                goto LABEL_104;
LABEL_88:
              v40 = CGImageMetadataTagCreate(NamespaceURIForPropertyPath, PropertyPrefixFromPath, PropertyNameFromPath, v37, ArrayPropertyValue);
              if (v40)
              {
                CGImageMetadataAddTag((uint64_t)Mutable, v40);
                if (v11)
                  CFRelease(v11);
              }
              else
              {
                v40 = v11;
              }
              v11 = v40;
              CFRelease(ArrayPropertyValue);
              goto LABEL_104;
            }
            v37 = kCGImageMetadataTypeAlternateArray;
            if (ArrayPropertyValue)
              goto LABEL_88;
          }
LABEL_104:
          TXMPIterator<std::string>::Skip((uint64_t)&v79, 1);
          goto LABEL_31;
        }
        if ((SHIBYTE(v86) & 0x80000000) == 0)
        {
          v32 = (const char *)cStr;
          goto LABEL_83;
        }
        v32 = cStr[0];
        if (cStr[0])
        {
LABEL_83:
          v38 = CFStringCreateWithCString(v12, v32, 0x8000100u);
          v39 = v38;
          if (v38)
          {
            if (CFStringGetLength(v38) < 1)
              v25 = 0;
            else
              v25 = CGImageMetadataTagCreate(NamespaceURIForPropertyPath, PropertyPrefixFromPath, PropertyNameFromPath, kCGImageMetadataTypeString, v39);
            CFRelease(v39);
LABEL_93:
            if ((v84 & 0x20) != 0)
            {
              if (v11 && v25)
              {
                CGImageMetadataTagAppendQualifier(Mutable, (uint64_t)v11, v25);
              }
              else if (!v25)
              {
                goto LABEL_31;
              }
              CFRelease(v25);
LABEL_31:
              v25 = v11;
            }
            else
            {
              if (!v25)
                goto LABEL_31;
              CGImageMetadataAddTag((uint64_t)Mutable, v25);
              if (v11)
                CFRelease(v11);
            }
LABEL_32:
            if (v16)
              CFRelease(v16);
            if (NamespaceURIForPropertyPath)
              CFRelease(NamespaceURIForPropertyPath);
            if (PropertyPrefixFromPath)
              CFRelease(PropertyPrefixFromPath);
            if (PropertyNameFromPath)
              CFRelease(PropertyNameFromPath);
            v26 = 0;
            v11 = v25;
            goto LABEL_42;
          }
        }
        v25 = 0;
        goto LABEL_93;
      }
      v26 = 6;
    }
    else
    {
      v26 = 2;
    }
LABEL_42:
    if (SHIBYTE(v78) < 0)
      operator delete(__p);
    if ((v26 | 2) != 2)
      goto LABEL_111;
  }
  v26 = 0;
LABEL_111:
  v79 = &off_1E1BAC3F0;
  WXMPIterator_DecrementRefCount_1(v80);
  v82 = &off_1E1BB2B60;
  WXMPMeta_DecrementRefCount_1(v83);
LABEL_112:
  if (SHIBYTE(v86) < 0)
    operator delete(cStr[0]);
  if (SHIBYTE(v89) < 0)
    operator delete(v87);
  if (SHIBYTE(v91) < 0)
  {
    operator delete(v90[0]);
    if (!v26)
      goto LABEL_122;
LABEL_118:
    if (v26 != 6)
      return 0;
    IIO_TerminateXMPToolkit();
    if (Mutable)
      goto LABEL_127;
LABEL_157:
    LOBYTE(v62) = 1;
    if (v11)
      goto LABEL_146;
    goto LABEL_147;
  }
  if (v26)
    goto LABEL_118;
LABEL_122:
  if (!Mutable)
  {
    IIO_TerminateXMPToolkit();
    Mutable = 0;
    goto LABEL_157;
  }
  if (v70 == 16)
    v41 = 16;
  else
    v41 = 8;
  metadataSetSource((uint64_t)Mutable, v41);
  IIO_TerminateXMPToolkit();
LABEL_127:
  TagWithPath = CGImageMetadataGetTagWithPath(Mutable, 0, CFSTR("exif:DateTimeOriginal"));
  if (TagWithPath)
  {
    v43 = (uint64_t)TagWithPath;
    if (!CGImageMetadataGetTagWithPath(Mutable, 0, CFSTR("photoshop:DateCreated")))
    {
      Value = (const void *)CGImageMetadataTagGetValue(v43);
      CGImageMetadataSetValueWithPath(Mutable, 0, CFSTR("photoshop:DateCreated"), Value);
      v45 = CGImageMetadataGetTagWithPath(Mutable, 0, CFSTR("photoshop:DateCreated"));
      CGImageMetadataTagSetSource((uint64_t)v45, 8);
      CGImageMetadataRemoveTag((uint64_t)Mutable, v43);
    }
  }
  v46 = CGImageMetadataGetTagWithPath(Mutable, 0, CFSTR("exif:DateTimeDigitized"));
  if (v46)
  {
    v47 = (uint64_t)v46;
    if (!CGImageMetadataGetTagWithPath(Mutable, 0, CFSTR("xmp:CreateDate")))
    {
      v48 = (const void *)CGImageMetadataTagGetValue(v47);
      CGImageMetadataSetValueWithPath(Mutable, 0, CFSTR("xmp:CreateDate"), v48);
      v49 = CGImageMetadataGetTagWithPath(Mutable, 0, CFSTR("photoshop:DateCreated"));
      CGImageMetadataTagSetSource((uint64_t)v49, 8);
      CGImageMetadataRemoveTag((uint64_t)Mutable, v47);
    }
  }
  v50 = CGImageMetadataGetTagWithPath(Mutable, 0, CFSTR("tiff:DateTime"));
  if (v50)
  {
    v51 = (uint64_t)v50;
    if (!CGImageMetadataGetTagWithPath(Mutable, 0, CFSTR("xmp:ModifyDate")))
    {
      v52 = (const void *)CGImageMetadataTagGetValue(v51);
      CGImageMetadataSetValueWithPath(Mutable, 0, CFSTR("xmp:ModifyDate"), v52);
      v53 = CGImageMetadataGetTagWithPath(Mutable, 0, CFSTR("xmp:ModifyDate"));
      CGImageMetadataTagSetSource((uint64_t)v53, 8);
      CGImageMetadataRemoveTag((uint64_t)Mutable, v51);
    }
  }
  v54 = CGImageMetadataGetTagWithPath(Mutable, 0, CFSTR("tiff:ImageDescription"));
  if (v54)
  {
    v55 = (uint64_t)v54;
    if (!CGImageMetadataGetTagWithPath(Mutable, 0, CFSTR("dc:description")))
    {
      v56 = (const void *)CGImageMetadataTagGetValue(v55);
      CGImageMetadataSetValueWithPath(Mutable, 0, CFSTR("dc:description"), v56);
      v57 = CGImageMetadataGetTagWithPath(Mutable, 0, CFSTR("dc:description"));
      CGImageMetadataTagSetSource((uint64_t)v57, 8);
      CGImageMetadataRemoveTag((uint64_t)Mutable, v55);
    }
  }
  v58 = CGImageMetadataGetTagWithPath(Mutable, 0, CFSTR("tiff:Copyright"));
  if (v58)
  {
    v59 = (uint64_t)v58;
    if (!CGImageMetadataGetTagWithPath(Mutable, 0, CFSTR("dc:rights")))
    {
      v60 = (const void *)CGImageMetadataTagGetValue(v59);
      CGImageMetadataSetValueWithPath(Mutable, 0, CFSTR("dc:rights"), v60);
      v61 = CGImageMetadataGetTagWithPath(Mutable, 0, CFSTR("dc:rights"));
      CGImageMetadataTagSetSource((uint64_t)v61, 8);
      CGImageMetadataRemoveTag((uint64_t)Mutable, v59);
    }
  }
  v62 = (uint64_t)CGImageMetadataGetTagWithPath(Mutable, 0, CFSTR("tiff:Artist"));
  if (v62)
  {
    if (!CGImageMetadataGetTagWithPath(Mutable, 0, CFSTR("dc:creator")))
    {
      v64 = (const __CFString *)CGImageMetadataTagGetValue(v62);
      if (v64)
      {
        v65 = v64;
        v66 = CFGetTypeID(v64);
        if (v66 == CFStringGetTypeID())
        {
          ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v65, CFSTR("; "));
          if (ArrayBySeparatingStrings)
          {
            v68 = ArrayBySeparatingStrings;
            CGImageMetadataSetValueWithPath(Mutable, 0, CFSTR("dc:creator"), ArrayBySeparatingStrings);
            v69 = CGImageMetadataGetTagWithPath(Mutable, 0, CFSTR("dc:creator"));
            CGImageMetadataTagSetSource((uint64_t)v69, 8);
            CGImageMetadataRemoveTag((uint64_t)Mutable, v62);
            CFRelease(v68);
          }
        }
      }
    }
    LOBYTE(v62) = 0;
  }
  if (v11)
LABEL_146:
    CFRelease(v11);
LABEL_147:
  if ((v62 & 1) == 0)
    CGImageMetadataSetValueWithPath(Mutable, 0, CFSTR("iio:hasXMP"), (CFTypeRef)*MEMORY[0x1E0C9AE50]);
  pthread_mutex_unlock(&CreateMetadataFromXMPBufferInternal(char const*,unsigned long,char const*,unsigned long,unsigned int)::mutex);
  return Mutable;
}

void sub_187E622D8(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void CGImageMetadataTagKeyRelease(_QWORD *a1)
{
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;
  const void *v5;
  const void *v6;

  v2 = (unsigned int *)(a1 + 2);
  do
  {
    v3 = __ldaxr(v2);
    v4 = v3 - 1;
  }
  while (__stlxr(v4, v2));
  if (!v4)
  {
    v5 = (const void *)*a1;
    if (*a1)
      CFRelease(v5);
    v6 = (const void *)a1[1];
    if (v6)
      CFRelease(v6);
    free(a1);
  }
}

BOOL TXMPIterator<std::string>::Next(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  _QWORD *exception;
  uint64_t v7;
  _OWORD v8[2];
  uint64_t v9;

  v9 = 0;
  memset(v8, 0, sizeof(v8));
  WXMPIterator_Next_1(*(_QWORD **)(a1 + 8), a2, a3, a4, a5, (void (*)(uint64_t, uint64_t, _QWORD))TXMPIterator<std::string>::SetClientString, (uint64_t)v8);
  if (*(_QWORD *)&v8[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v7 = *(_QWORD *)&v8[0];
    *(_DWORD *)exception = v9;
    exception[1] = v7;
    *((_BYTE *)exception + 16) = 0;
  }
  return (_DWORD)v9 != 0;
}

void CGImageMetadataAddTag(uint64_t a1, const void *a2)
{
  _QWORD *v4;
  _QWORD *v5;

  if (a1 && a2)
  {
    v4 = CGImageMetadataTagKeyCreateWithTag(a2);
    if (v4)
    {
      v5 = v4;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), v4, a2);
      CGImageMetadataTagKeyRelease(v5);
    }
  }
}

_QWORD *CGImageMetadataTagKeyCreateWithTag(const void *a1)
{
  uint64_t Source;
  uint64_t v3;
  CFTypeID v4;

  Source = CGImageSourceGetSource((uint64_t)a1);
  if (a1 && (v3 = Source, v4 = CFGetTypeID(a1), v4 == CGImageMetadataTagGetTypeID()))
    return CGImageMetadataTagKeyCreate(*(const __CFString **)(v3 + 16), *(const __CFString **)(v3 + 32));
  else
    return 0;
}

const __CFString *createPropertyNameFromPath(const __CFString *result)
{
  const __CFString *v1;
  CFIndex Length;
  CFRange v3;
  CFRange v4;
  CFRange v5;

  if (result)
  {
    v1 = result;
    v3.location = 0;
    v3.length = 0;
    Length = CFStringGetLength(result);
    v4.location = 0;
    v4.length = Length;
    if (CFStringFindWithOptions(v1, CFSTR(":"), v4, 4uLL, &v3))
    {
      v5.location = v3.location + 1;
      v5.length = Length - (v3.location + 1);
      return CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v1, v5);
    }
    else
    {
      return CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v1);
    }
  }
  return result;
}

BOOL CGImageMetadataRegisterNamespaceForPrefix(CGMutableImageMetadataRef metadata, CFStringRef xmlns, CFStringRef prefix, CFErrorRef *err)
{
  const char *v8;
  char *v9;
  int v10;
  BOOL v11;
  CFTypeID v12;
  CFTypeID v13;
  CFTypeID v14;
  pthread_mutex_t *v15;
  const __CFDictionary *v16;
  const __CFString *Value;
  const __CFString *v18;
  CFTypeID v19;
  const __CFSet *Mutable;
  __CFString *v21;
  __CFString *v22;
  __CFDictionary *v23;
  _BYTE v25[24];

  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0)
  {
    IIOString::IIOString((IIOString *)v25, prefix);
    v8 = (const char *)IIOString::utf8String((IIOString *)v25);
    ImageIODebugOptions(3, "A", "CGImageMetadataRegisterNamespaceForPrefix", 0, v8, -1, 0);
    IIOString::~IIOString((IIOString *)v25);
  }
  if (!metadata)
    goto LABEL_4;
  v12 = CFGetTypeID(metadata);
  if (CGImageMetadataGetTypeID::once != -1)
    dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_20);
  if (v12 == CGImageMetadataGetTypeID::id)
  {
    if (xmlns && (v13 = CFGetTypeID(xmlns), v13 == CFStringGetTypeID()))
    {
      if (prefix)
      {
        v14 = CFGetTypeID(prefix);
        if (v14 == CFStringGetTypeID())
        {
          v15 = (pthread_mutex_t *)((char *)metadata + 136);
          pthread_mutex_lock((pthread_mutex_t *)((char *)metadata + 136));
          v16 = (const __CFDictionary *)*((_QWORD *)metadata + 4);
          if (!v16)
            goto LABEL_24;
          Value = (const __CFString *)CFDictionaryGetValue(v16, xmlns);
          if (Value)
          {
            v18 = Value;
            v19 = CFGetTypeID(Value);
            if (v19 == CFStringGetTypeID())
            {
              v11 = 1;
              if (CFStringCompare(v18, prefix, 1uLL))
              {
                Mutable = (const __CFSet *)CGImageMetadataRegisterNamespaceForPrefix::alreadyRegistered;
                if (!CGImageMetadataRegisterNamespaceForPrefix::alreadyRegistered)
                {
                  Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B3B0]);
                  CGImageMetadataRegisterNamespaceForPrefix::alreadyRegistered = (uint64_t)Mutable;
                }
                if (!CFSetContainsValue(Mutable, v18))
                {
                  CFSetAddValue((CFMutableSetRef)CGImageMetadataRegisterNamespaceForPrefix::alreadyRegistered, v18);
                  v21 = (__CFString *)CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("Error: Cannot register the prefix '%@', '%@' is already associated with the prefix '%@'."), prefix, xmlns, v18);
                  if (v21)
                  {
                    v22 = v21;
                    CGImageMetadataCreateAndLogError("CGImageMetadataRegisterNamespaceForPrefix", 4, v21, err);
                    CFRelease(v22);
                  }
                }
                v11 = 0;
              }
              goto LABEL_29;
            }
LABEL_28:
            v11 = 1;
LABEL_29:
            pthread_mutex_unlock(v15);
            return v11;
          }
          v23 = (__CFDictionary *)*((_QWORD *)metadata + 4);
          if (!v23)
          {
LABEL_24:
            v23 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            *((_QWORD *)metadata + 4) = v23;
          }
          if (!*((_QWORD *)metadata + 5))
          {
            *((_QWORD *)metadata + 5) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            v23 = (__CFDictionary *)*((_QWORD *)metadata + 4);
          }
          CFDictionarySetValue(v23, xmlns, prefix);
          CFDictionarySetValue(*((CFMutableDictionaryRef *)metadata + 5), prefix, xmlns);
          goto LABEL_28;
        }
      }
      v9 = "prefix must be a non-NULL CFStringRef.";
      v10 = 2247;
    }
    else
    {
      v9 = "xmlns must be a non-NULL CFStringRef.";
      v10 = 2246;
    }
  }
  else
  {
LABEL_4:
    v9 = "metadata must be a non-NULL CGMutableImageMetadataRef.";
    v10 = 2245;
  }
  CGImageMetadataCreateAndLogUTF8Error("CGImageMetadataRegisterNamespaceForPrefix", v10, 2, v9, err);
  return 0;
}

void sub_187E62810(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

CFStringRef createNamespaceURIForPropertyPath(const __CFString *a1)
{
  const __CFString *PropertyPrefixFromPath;
  XMPMeta *UTF8String;
  void **v3;
  CFStringRef v4;
  _BYTE v6[24];
  void *__p[2];
  uint64_t v8;

  __p[0] = 0;
  __p[1] = 0;
  v8 = 0;
  if (!a1)
    return 0;
  PropertyPrefixFromPath = createPropertyPrefixFromPath(a1);
  if (!PropertyPrefixFromPath)
    return 0;
  IIOString::IIOString((IIOString *)v6, PropertyPrefixFromPath);
  UTF8String = (XMPMeta *)IIOString::createUTF8String((IIOString *)v6);
  IIOString::~IIOString((IIOString *)v6);
  if (UTF8String)
  {
    if (TXMPMeta<std::string>::GetNamespaceURI(UTF8String, (uint64_t)__p))
    {
      if (v8 >= 0)
        v3 = __p;
      else
        v3 = (void **)__p[0];
      v4 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const char *)v3, 0x8000100u);
    }
    else
    {
      v4 = 0;
    }
    free(UTF8String);
  }
  else
  {
    v4 = 0;
  }
  CFRelease(PropertyPrefixFromPath);
  if (SHIBYTE(v8) < 0)
    operator delete(__p[0]);
  return v4;
}

void sub_187E62904(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  IIOString::~IIOString((IIOString *)&a9);
  _Unwind_Resume(a1);
}

void IIOString::~IIOString(IIOString *this)
{
  const void *v2;
  void *v3;

  *(_QWORD *)this = &off_1E1BB2F80;
  v2 = (const void *)*((_QWORD *)this + 2);
  if (v2)
    CFRelease(v2);
  v3 = (void *)*((_QWORD *)this + 1);
  if (v3)
    free(v3);
}

{
  IIOString::~IIOString(this);
  JUMPOUT(0x18D761C30);
}

const __CFString *createPropertyPrefixFromPath(const __CFString *result)
{
  const __CFString *v1;
  CFIndex Length;
  int v3;
  CFIndex v4;
  CFIndex v5;
  CFIndex v6;
  int v7;
  CFRange v8;
  CFRange v9;
  CFRange v10;
  CFRange v11;
  CFRange v12;

  if (result)
  {
    v1 = result;
    v8.location = 0;
    v8.length = 0;
    Length = CFStringGetLength(result);
    v9.location = 0;
    v9.length = Length;
    v3 = CFStringFindWithOptions(v1, CFSTR("/"), v9, 4uLL, &v8);
    if (v3)
      v4 = ~v8.location;
    else
      v4 = 0;
    v5 = v4 + Length;
    if (v3)
      v6 = v8.location + 1;
    else
      v6 = 0;
    v10.location = v6;
    v10.length = 1;
    v7 = CFStringFindWithOptions(v1, CFSTR("?"), v10, 0, &v8);
    if (v7)
      ++v6;
    v11.length = v5 - (v7 != 0);
    v11.location = v6;
    if (CFStringFindWithOptions(v1, CFSTR(":"), v11, 4uLL, &v8))
    {
      v12.length = v8.location - v6;
      v12.location = v6;
      return CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v1, v12);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void IIOString::IIOString(IIOString *this, CFTypeRef cf)
{
  CFTypeID v4;

  *(_QWORD *)this = &off_1E1BB2F80;
  *((_QWORD *)this + 1) = 0;
  if (cf)
  {
    v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID())
    {
      *((_QWORD *)this + 2) = CFRetain(cf);
      return;
    }
    IIOLogTypeMismatch(cf, "IIOString", "CFStringRef");
  }
  *((_QWORD *)this + 2) = &stru_1E1BCE100;
  CFRetain(&stru_1E1BCE100);
}

void *IIOString::createUTF8String(IIOString *this)
{
  const __CFString *v2;
  CFIndex Length;
  CFIndex MaximumSizeForEncoding;
  void *v5;

  v2 = (const __CFString *)*((_QWORD *)this + 2);
  if (!v2)
    return 0;
  Length = CFStringGetLength(v2);
  MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length + 1, 0x8000100u);
  v5 = malloc_type_malloc(MaximumSizeForEncoding, 0x100004077774924uLL);
  if (v5 && !CFStringGetCString(*((CFStringRef *)this + 2), (char *)v5, MaximumSizeForEncoding, 0x8000100u))
  {
    free(v5);
    return 0;
  }
  return v5;
}

BOOL TXMPMeta<std::string>::GetNamespaceURI(XMPMeta *a1, uint64_t a2)
{
  _QWORD *exception;
  uint64_t v4;
  _OWORD v5[2];
  uint64_t v6;

  v6 = 0;
  memset(v5, 0, sizeof(v5));
  WXMPMeta_GetNamespaceURI_1(a1, a2, (uint64_t (*)(uint64_t, _QWORD, _QWORD))TXMPMeta<std::string>::SetClientString, (unsigned int *)v5);
  if (*(_QWORD *)&v5[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v4 = *(_QWORD *)&v5[0];
    *(_DWORD *)exception = v6;
    exception[1] = v4;
    *((_BYTE *)exception + 16) = 0;
  }
  return (_DWORD)v6 != 0;
}

uint64_t WXMPMeta_GetNamespaceURI_1(XMPMeta *a1, uint64_t a2, uint64_t (*a3)(uint64_t, _QWORD, _QWORD), unsigned int *a4)
{
  uint64_t result;
  char v8;
  _QWORD *exception;
  _BYTE v10[12];

  *(_QWORD *)a4 = 0;
  if (!a1 || !*(_BYTE *)a1)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 101;
    exception[1] = "Empty namespace prefix";
    *((_BYTE *)exception + 16) = 0;
  }
  memset(v10, 0, sizeof(v10));
  result = XMPMeta::GetNamespaceURI(a1, (const char **)&v10[4], (const char **)v10, a4);
  v8 = result ^ 1;
  a4[8] = result;
  if (!a2)
    v8 = 1;
  if ((v8 & 1) == 0)
    return a3(a2, *(_QWORD *)&v10[4], *(unsigned int *)v10);
  return result;
}

void sub_187E62CAC(void *a1, int a2)
{
  uint64_t v2;
  void *v4;
  const char *v5;
  void *v6;
  uint64_t v7;
  const char *v8;

  if (a2 == 3)
  {
    v4 = __cxa_begin_catch(a1);
    *(_DWORD *)(v2 + 32) = *(_DWORD *)v4;
    v5 = (const char *)*((_QWORD *)v4 + 1);
    if (!v5)
      v5 = "";
    *(_QWORD *)v2 = v5;
    *(_QWORD *)(v2 + 8) = "XMP";
  }
  else
  {
    v6 = __cxa_begin_catch(a1);
    if (a2 == 2)
    {
      *(_DWORD *)(v2 + 32) = 13;
      v7 = (*(uint64_t (**)(void *))(*(_QWORD *)v6 + 16))(v6);
      v8 = "";
      if (v7)
        v8 = (const char *)v7;
    }
    else
    {
      *(_DWORD *)(v2 + 32) = 14;
      v8 = "Caught unknown exception";
    }
    *(_QWORD *)v2 = v8;
  }
  __cxa_end_catch();
  JUMPOUT(0x187E62C64);
}

BOOL TXMPMeta<std::string>::GetNamespacePrefix(XMPMeta *a1, uint64_t a2)
{
  _QWORD *exception;
  uint64_t v4;
  _OWORD v5[2];
  uint64_t v6;

  v6 = 0;
  memset(v5, 0, sizeof(v5));
  WXMPMeta_GetNamespacePrefix_1(a1, a2, (uint64_t (*)(uint64_t, _QWORD, _QWORD))TXMPMeta<std::string>::SetClientString, (unsigned int *)v5);
  if (*(_QWORD *)&v5[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v4 = *(_QWORD *)&v5[0];
    *(_DWORD *)exception = v6;
    exception[1] = v4;
    *((_BYTE *)exception + 16) = 0;
  }
  return (_DWORD)v6 != 0;
}

uint64_t WXMPMeta_GetNamespacePrefix_1(XMPMeta *a1, uint64_t a2, uint64_t (*a3)(uint64_t, _QWORD, _QWORD), unsigned int *a4)
{
  uint64_t result;
  char v8;
  _QWORD *exception;
  _BYTE v10[12];

  *(_QWORD *)a4 = 0;
  if (!a1 || !*(_BYTE *)a1)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 101;
    exception[1] = "Empty namespace URI";
    *((_BYTE *)exception + 16) = 0;
  }
  memset(v10, 0, sizeof(v10));
  result = XMPMeta::GetNamespacePrefix(a1, (const char **)&v10[4], (const char **)v10, a4);
  v8 = result ^ 1;
  a4[8] = result;
  if (!a2)
    v8 = 1;
  if ((v8 & 1) == 0)
    return a3(a2, *(_QWORD *)&v10[4], *(unsigned int *)v10);
  return result;
}

void sub_187E62E60(void *a1, int a2)
{
  uint64_t v2;
  void *v4;
  const char *v5;
  void *v6;
  uint64_t v7;
  const char *v8;

  if (a2 == 3)
  {
    v4 = __cxa_begin_catch(a1);
    *(_DWORD *)(v2 + 32) = *(_DWORD *)v4;
    v5 = (const char *)*((_QWORD *)v4 + 1);
    if (!v5)
      v5 = "";
    *(_QWORD *)v2 = v5;
    *(_QWORD *)(v2 + 8) = "XMP";
  }
  else
  {
    v6 = __cxa_begin_catch(a1);
    if (a2 == 2)
    {
      *(_DWORD *)(v2 + 32) = 13;
      v7 = (*(uint64_t (**)(void *))(*(_QWORD *)v6 + 16))(v6);
      v8 = "";
      if (v7)
        v8 = (const char *)v7;
    }
    else
    {
      *(_DWORD *)(v2 + 32) = 14;
      v8 = "Caught unknown exception";
    }
    *(_QWORD *)v2 = v8;
  }
  __cxa_end_catch();
  JUMPOUT(0x187E62E18);
}

void TXMPMeta<std::string>::SetClientString()
{
  JUMPOUT(0x18D761A20);
}

BOOL XMPMeta::GetNamespacePrefix(XMPMeta *this, const char **a2, const char **a3, unsigned int *a4)
{
  return XMP_NamespaceTable::GetPrefix((XMP_NamespaceTable *)sRegisteredNamespaces, (char *)this, a2, (unsigned int *)a3);
}

BOOL XMPMeta::GetNamespaceURI(XMPMeta *this, const char **a2, const char **a3, unsigned int *a4)
{
  return XMP_NamespaceTable::GetURI((XMP_NamespaceTable *)sRegisteredNamespaces, (char *)this, a2, (unsigned int *)a3);
}

BOOL CGImageMetadataSetValueWithPath(CGMutableImageMetadataRef metadata, CGImageMetadataTagRef parent, CFStringRef path, CFTypeRef value)
{
  uint64_t Source;
  IIOMetadata_Tag *v9;
  CFTypeID v10;
  CFTypeID v11;
  CFTypeID TypeID;
  CFTypeID v13;
  void *TagWithPath;
  void *v15;
  const __CFString *v16;
  const __CFString *Mutable;
  const __CFAllocator *v18;
  const __CFString *v19;
  char *v20;
  uint64_t v21;
  int v22;
  char *v23;
  char *v24;
  char *v25;
  uint64_t v26;
  const char **v27;
  const __CFString *v28;
  const __CFDictionary *v29;
  uint64_t v30;
  const char *v31;
  int v32;
  CGImageMetadataType v33;
  const char *v34;
  BOOL v35;
  CFTypeID v36;
  char *v37;
  const char *v38;
  void *v39;
  CFTypeID v40;
  CFIndex Count;
  CFIndex v42;
  const void *ValueAtIndex;
  const __CFString *v44;
  void *v45;
  CFTypeID v46;
  const void *v47;
  const void *v48;
  CFTypeID v49;
  CFTypeRef v50;
  uint64_t v51;
  void *v52;
  CFTypeID v53;
  const __CFString *v54;
  const __CFString *v55;
  const __CFString *v56;
  const __CFString *v57;
  CGImageMetadataTagRef v58;
  CGImageMetadataTagRef v59;
  int *v60;
  int v61;
  CFMutableDictionaryRef v62;
  CGImageMetadataType v63;
  const __CFString *v64;
  CGImageMetadataTagRef v65;
  const __CFString *Namespace;
  const __CFString *Prefix;
  CFTypeID v68;
  CFTypeRef v69;
  int *v70;
  int v71;
  CFMutableDictionaryRef v72;
  CGImageMetadataType v73;
  CGImageMetadataTagRef v74;
  CGImageMetadataTagRef v75;
  CGImageMetadataTagRef v76;
  const void *v77;
  CGImageMetadataTagRef v78;
  const void *v79;
  const void *v80;
  pthread_mutex_t *v82;
  const __CFString *valuea;
  CGImageMetadata *v84;
  const __CFString *v85;
  const __CFString *PropertyPrefixFromCStrPrefix;
  const __CFString *cf;
  char v88;
  const char **v89;
  const __CFAllocator *allocator;
  _QWORD v91[8];
  const __CFString *key;
  const __CFString *p_key;
  uint64_t v94;
  char v95;
  uint64_t v96;
  uint64_t *v97;
  uint64_t v98;
  uint64_t v99;

  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0)
    ImageIODebugOptions(3, "A", "CGImageMetadataSetValueWithPath", 0, 0, -1, 0);
  v96 = 0;
  v97 = &v96;
  v98 = 0x2000000000;
  v99 = 0;
  Source = CGImageSourceGetSource((uint64_t)parent);
  if (!metadata)
    goto LABEL_4;
  v9 = (IIOMetadata_Tag *)Source;
  v10 = CFGetTypeID(metadata);
  if (CGImageMetadataGetTypeID::once != -1)
    dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_20);
  if (v10 != CGImageMetadataGetTypeID::id)
    goto LABEL_4;
  if (parent)
  {
    v11 = CFGetTypeID(parent);
    TypeID = CGImageMetadataTagGetTypeID();
    v89 = 0;
    v88 = 0;
    if (!path || v11 != TypeID)
      goto LABEL_161;
  }
  else if (!path)
  {
LABEL_4:
    v88 = 0;
    v89 = 0;
    goto LABEL_161;
  }
  v13 = CFGetTypeID(path);
  if (v13 != CFStringGetTypeID())
    goto LABEL_4;
  pthread_mutex_lock((pthread_mutex_t *)((char *)metadata + 208));
  if (*((_BYTE *)metadata + 200))
  {
    LogMetadata("CGImageMetadataSetValueWithPath", 1012, "Cannot mutate metadata while enumerating");
    pthread_mutex_unlock((pthread_mutex_t *)((char *)metadata + 208));
    goto LABEL_4;
  }
  pthread_mutex_unlock((pthread_mutex_t *)((char *)metadata + 208));
  v82 = (pthread_mutex_t *)((char *)metadata + 72);
  pthread_mutex_lock((pthread_mutex_t *)((char *)metadata + 72));
  TagWithPath = CGImageMetadataGetTagWithPath(metadata, parent, path);
  if (TagWithPath)
  {
    v88 = CGImageMetadataTagSetValue((uint64_t)TagWithPath, (const __CFString *)value);
LABEL_17:
    cf = 0;
LABEL_18:
    v15 = 0;
    v85 = 0;
    PropertyPrefixFromCStrPrefix = 0;
    v16 = 0;
    Mutable = 0;
    v89 = 0;
    goto LABEL_149;
  }
  v18 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (parent)
  {
    v19 = CFStringCreateWithFormat(v18, 0, CFSTR("%@:%@"), *((_QWORD *)v9 + 3), *((_QWORD *)v9 + 4));
    if (!v19)
    {
      v88 = 0;
      goto LABEL_17;
    }
    cf = IIOMetadata_Tag::createPathWithChildPath(v9, path);
    v20 = parse_metadata_pathString(v19);
    if (v20)
    {
      v21 = *((_QWORD *)v20 + 5);
      if (v21)
      {
        v22 = 0;
        do
        {
          if ((*(_DWORD *)v21 & 0xFFFFFFFE) != 2)
            break;
          ++v22;
          v21 = *(_QWORD *)(v21 + 40);
        }
        while (v21);
      }
      else
      {
        v22 = 0;
      }
      freeNodes(v20);
    }
    else
    {
      v22 = 0;
    }
    CFRelease(v19);
    v23 = parse_metadata_pathString(cf);
  }
  else
  {
    cf = CFStringCreateCopy(v18, path);
    v22 = 0;
    v23 = parse_metadata_pathString(cf);
  }
  v89 = (const char **)v23;
  v24 = v23;
  if (!v23)
  {
    v88 = 0;
    goto LABEL_18;
  }
  v25 = (char *)*((_QWORD *)v23 + 1);
  if (!v25 || !*((_QWORD *)v24 + 2))
    goto LABEL_170;
  if (parent)
  {
    v15 = (void *)CFRetain(parent);
    v26 = CGImageSourceGetSource((uint64_t)v15);
    if (v22 < 1)
    {
      v85 = 0;
      PropertyPrefixFromCStrPrefix = 0;
      v27 = v89;
    }
    else
    {
      v27 = v89;
      do
      {
        v27 = (const char **)v27[5];
        --v22;
      }
      while (v22);
      v85 = 0;
      PropertyPrefixFromCStrPrefix = 0;
    }
    goto LABEL_60;
  }
  PropertyPrefixFromCStrPrefix = createPropertyPrefixFromCStrPrefix(v25);
  if (!PropertyPrefixFromCStrPrefix)
  {
LABEL_170:
    v88 = 0;
    v15 = 0;
    v85 = 0;
    PropertyPrefixFromCStrPrefix = 0;
LABEL_171:
    v16 = 0;
    Mutable = 0;
    goto LABEL_149;
  }
  v85 = CFStringCreateWithCString(allocator, v89[2], 0x8000100u);
  v28 = (const __CFString *)CGImageMetadataNamespaceForPrefix(metadata, PropertyPrefixFromCStrPrefix);
  if (!v28)
  {
    LogMetadata("CGImageMetadataSetValueWithPath", 1091, "Could not obtain XMP namespace for prefix '%s'. Please ensure that the prefix has been registered with CGImageMetadataRegisterNamespaceForPrefix.", v89[1]);
    v88 = 0;
    v15 = 0;
    goto LABEL_171;
  }
  v29 = (const __CFDictionary *)*((_QWORD *)metadata + 3);
  if (v29)
  {
    key = v28;
    p_key = v85;
    v94 = 0;
    v15 = (void *)CFDictionaryGetValue(v29, &key);
  }
  else
  {
    v15 = 0;
  }
  v30 = CGImageSourceGetSource((uint64_t)v15);
  if (v15)
  {
    v26 = v30;
    CFRetain(v15);
    v27 = v89;
    goto LABEL_60;
  }
  v31 = v89[5];
  if (v31)
  {
    v32 = *(_DWORD *)v31;
    switch(v32)
    {
      case 4:
        Mutable = (const __CFString *)CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        v33 = kCGImageMetadataTypeStructure;
        break;
      case 3:
        Mutable = (const __CFString *)CFArrayCreateMutable(allocator, 0, MEMORY[0x1E0C9B378]);
        v33 = kCGImageMetadataTypeAlternateText;
        break;
      case 2:
        Mutable = (const __CFString *)CFArrayCreateMutable(allocator, 0, MEMORY[0x1E0C9B378]);
        v33 = kCGImageMetadataTypeArrayOrdered;
        break;
      default:
        LogMetadata("CGImageMetadataSetValueWithPath", 1122, "Unable to create top-level property with type %d\n", v32);
        v15 = 0;
        goto LABEL_147;
    }
    if (!Mutable)
    {
      v15 = 0;
      v16 = 0;
      goto LABEL_148;
    }
    v15 = CGImageMetadataTagCreate(v28, PropertyPrefixFromCStrPrefix, v85, v33, Mutable);
    v26 = CGImageSourceGetSource((uint64_t)v15);
    CFRelease(Mutable);
  }
  else
  {
    v15 = CGImageMetadataTagCreate(v28, PropertyPrefixFromCStrPrefix, v85, kCGImageMetadataTypeDefault, value);
    v26 = CGImageSourceGetSource((uint64_t)v15);
  }
  if (!v15)
  {
LABEL_147:
    v16 = 0;
    Mutable = 0;
LABEL_148:
    v88 = 1;
    goto LABEL_149;
  }
  CGImageMetadataAddTag((uint64_t)metadata, v15);
  v27 = v89;
LABEL_60:
  valuea = (const __CFString *)value;
  v84 = metadata;
  v34 = v27[5];
  if (v34)
    v35 = v15 == 0;
  else
    v35 = 1;
  if (v35)
    goto LABEL_147;
  v88 = 0;
  while (2)
  {
    v36 = CFGetTypeID(v15);
    if (v36 != CGImageMetadataTagGetTypeID())
      goto LABEL_171;
    v37 = (char *)*((_QWORD *)v34 + 1);
    if (v37)
      v16 = createPropertyPrefixFromCStrPrefix(v37);
    else
      v16 = 0;
    v38 = (const char *)*((_QWORD *)v34 + 2);
    if (v38)
      Mutable = CFStringCreateWithCString(allocator, v38, 0x8000100u);
    else
      Mutable = 0;
    switch(*(_DWORD *)v34)
    {
      case 2:
        if (CGImageMetadataTagGetType((CGImageMetadataTagRef)v15) != kCGImageMetadataTypeArrayOrdered
          && CGImageMetadataTagGetType((CGImageMetadataTagRef)v15) != kCGImageMetadataTypeArrayUnordered
          && CGImageMetadataTagGetType((CGImageMetadataTagRef)v15) != kCGImageMetadataTypeAlternateArray)
        {
          goto LABEL_149;
        }
        v39 = (void *)CGImageMetadataTagGetValue((uint64_t)v15);
        v40 = CFGetTypeID(v39);
        if (v40 != CFArrayGetTypeID())
          goto LABEL_149;
        Count = CFArrayGetCount((CFArrayRef)v39);
        v42 = *((int *)v34 + 6);
        if (Count < v42)
        {
          LogMetadata("CGImageMetadataSetValueWithPath", 1244, "Cannot set array element at index %d, current array has %d element(s).", *((_DWORD *)v34 + 6), Count);
          goto LABEL_149;
        }
        if (CFArrayGetCount((CFArrayRef)v39) <= v42)
          ValueAtIndex = 0;
        else
          ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v39, *((int *)v34 + 6));
        Namespace = (const __CFString *)CGImageMetadataTagGetNamespace((uint64_t)v15);
        Prefix = (const __CFString *)CGImageMetadataTagGetPrefix((uint64_t)v15);
        v54 = CFStringCreateWithFormat(allocator, 0, CFSTR("[%d]"), *((unsigned int *)v34 + 6));
        if (!v54)
          goto LABEL_149;
        if (ValueAtIndex)
        {
          v68 = CFGetTypeID(ValueAtIndex);
          if (v68 == CGImageMetadataTagGetTypeID())
          {
            v69 = CFRetain(ValueAtIndex);
            v97[3] = (uint64_t)v69;
            if (!*((_QWORD *)v34 + 5))
              CGImageMetadataTagSetValue((uint64_t)v69, valuea);
            goto LABEL_140;
          }
        }
        v70 = (int *)*((_QWORD *)v34 + 5);
        if (!v70)
        {
          v75 = CGImageMetadataTagCreate(Namespace, Prefix, v54, kCGImageMetadataTypeDefault, valuea);
          v97[3] = (uint64_t)v75;
          goto LABEL_138;
        }
        v71 = *v70;
        switch(v71)
        {
          case 4:
            v72 = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            v73 = kCGImageMetadataTypeStructure;
            if (!v72)
              goto LABEL_138;
            break;
          case 3:
            v72 = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E0C9B378]);
            v73 = kCGImageMetadataTypeAlternateText;
            if (!v72)
              goto LABEL_138;
            break;
          case 2:
            v72 = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E0C9B378]);
            v73 = kCGImageMetadataTypeArrayOrdered;
            if (!v72)
            {
LABEL_138:
              v79 = (const void *)v97[3];
              if (v79)
                CFArraySetValueAtIndex((CFMutableArrayRef)v39, *((int *)v34 + 6), v79);
              goto LABEL_140;
            }
            break;
          default:
            LogMetadata("CGImageMetadataSetValueWithPath", 1289, "Unable to create a property with type %d\n", v71);
            goto LABEL_138;
        }
        v78 = CGImageMetadataTagCreate(Namespace, Prefix, v54, v73, v72);
        v97[3] = (uint64_t)v78;
        CFRelease(v72);
        goto LABEL_138;
      case 3:
        if (CGImageMetadataTagGetType((CGImageMetadataTagRef)v15) != kCGImageMetadataTypeAlternateText)
          goto LABEL_149;
        v52 = (void *)CGImageMetadataTagGetValue((uint64_t)v15);
        v53 = CFGetTypeID(v52);
        if (v53 != CFArrayGetTypeID())
          goto LABEL_149;
        v54 = CFStringCreateWithCString(allocator, *((const char **)v34 + 4), 0x8000100u);
        if (!v54)
          goto LABEL_149;
        if (*((_QWORD *)v34 + 5))
        {
          LogMetadata("CGImageMetadataSetValueWithPath", 1327, "Language codes must be the last element in a path, all alternate-text array elements are strings and cannot have children.\n");
          CFRelease(v54);
          goto LABEL_149;
        }
        v55 = (const __CFString *)CGImageMetadataTagGetNamespace((uint64_t)v15);
        v56 = (const __CFString *)CGImageMetadataTagGetPrefix((uint64_t)v15);
        v57 = CFStringCreateWithFormat(allocator, 0, CFSTR("[%@]"), v54);
        if (v57)
        {
          v58 = CGImageMetadataTagCreate(v55, v56, v57, kCGImageMetadataTypeString, valuea);
          v97[3] = (uint64_t)v58;
          if (v58)
          {
            v59 = CGImageMetadataTagCreate(CFSTR("http://www.w3.org/XML/1998/namespace"), CFSTR("xml"), CFSTR("lang"), kCGImageMetadataTypeString, v54);
            if (v59)
            {
              CGImageMetadataTagAppendQualifier(v84, v97[3], v59);
              CFArrayAppendValue((CFMutableArrayRef)v52, (const void *)v97[3]);
              CFRelease(v59);
            }
          }
          CFRelease(v57);
        }
LABEL_140:
        CFRelease(v54);
        goto LABEL_141;
      case 4:
        if (CGImageMetadataTagGetType((CGImageMetadataTagRef)v15) != kCGImageMetadataTypeStructure)
          goto LABEL_149;
        v44 = (const __CFString *)CGImageMetadataNamespaceForPrefix(v84, v16);
        v45 = (void *)CGImageMetadataTagGetValue((uint64_t)v15);
        v46 = CFGetTypeID(v45);
        if (v46 != CFDictionaryGetTypeID() || !Mutable)
          goto LABEL_149;
        v47 = CFDictionaryGetValue((CFDictionaryRef)v45, Mutable);
        v48 = v47;
        if (v47)
        {
          v49 = CFGetTypeID(v47);
          if (v49 == CGImageMetadataTagGetTypeID())
          {
            v50 = CFRetain(v48);
            v97[3] = (uint64_t)v50;
            if (!*((_QWORD *)v34 + 5))
              CGImageMetadataTagSetValue((uint64_t)v50, valuea);
            goto LABEL_141;
          }
        }
        v60 = (int *)*((_QWORD *)v34 + 5);
        if (!v60)
        {
          v74 = CGImageMetadataTagCreate(v44, v16, Mutable, kCGImageMetadataTypeDefault, valuea);
          v97[3] = (uint64_t)v74;
          goto LABEL_131;
        }
        v61 = *v60;
        switch(v61)
        {
          case 4:
            v62 = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            v63 = kCGImageMetadataTypeStructure;
            if (!v62)
              goto LABEL_131;
            goto LABEL_129;
          case 3:
            v62 = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E0C9B378]);
            v63 = kCGImageMetadataTypeAlternateText;
            if (!v62)
              goto LABEL_131;
            goto LABEL_129;
          case 2:
            v62 = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E0C9B378]);
            v63 = kCGImageMetadataTypeArrayOrdered;
            if (!v62)
              goto LABEL_131;
LABEL_129:
            v76 = CGImageMetadataTagCreate(v44, v16, Mutable, v63, v62);
            v97[3] = (uint64_t)v76;
            CFRelease(v62);
            goto LABEL_131;
        }
        LogMetadata("CGImageMetadataSetValueWithPath", 1210, "Unable to create a property with type %d\n", v61);
LABEL_131:
        v77 = (const void *)v97[3];
        if (v77)
          CFDictionarySetValue((CFMutableDictionaryRef)v45, Mutable, v77);
        goto LABEL_141;
      case 5:
        key = 0;
        p_key = (const __CFString *)&key;
        v94 = 0x2000000000;
        v95 = 0;
        if (*((_QWORD *)v34 + 5))
        {
          LogMetadata("CGImageMetadataSetValueWithPath", 1358, "Only string qualifier values are currently supported.\n");
          goto LABEL_173;
        }
        v51 = *(_QWORD *)(v26 + 56);
        if (v51)
        {
          v91[0] = MEMORY[0x1E0C809B0];
          v91[1] = 0x40000000;
          v91[2] = __CGImageMetadataSetValueWithPath_block_invoke;
          v91[3] = &unk_1E1BC4DA0;
          v91[6] = v16;
          v91[7] = Mutable;
          v91[4] = &v96;
          v91[5] = &key;
          IIOArrayEnumerateUsingBlock(v51, (uint64_t)v91);
          if (LOBYTE(p_key->length))
          {
            if (!*((_QWORD *)v34 + 5))
              CGImageMetadataTagSetValue(v97[3], valuea);
            goto LABEL_111;
          }
        }
        v64 = (const __CFString *)CGImageMetadataNamespaceForPrefix(v84, v16);
        v65 = CGImageMetadataTagCreate(v64, v16, Mutable, kCGImageMetadataTypeDefault, valuea);
        v97[3] = (uint64_t)v65;
        if (!v65)
          goto LABEL_111;
        if (CGImageMetadataTagAppendQualifier(v84, (uint64_t)v15, v65))
        {
          v88 = 1;
LABEL_111:
          _Block_object_dispose(&key, 8);
LABEL_141:
          v34 = (const char *)*((_QWORD *)v34 + 5);
          CFRelease(v15);
          v15 = (void *)v97[3];
          v97[3] = 0;
          v26 = CGImageSourceGetSource((uint64_t)v15);
          if (v16)
            CFRelease(v16);
          if (Mutable)
            CFRelease(Mutable);
          if (!v34 || !v15)
            goto LABEL_147;
          continue;
        }
        v88 = 0;
LABEL_173:
        _Block_object_dispose(&key, 8);
LABEL_149:
        pthread_mutex_unlock(v82);
        if (v15)
          CFRelease(v15);
        if (cf)
          CFRelease(cf);
        if (PropertyPrefixFromCStrPrefix)
          CFRelease(PropertyPrefixFromCStrPrefix);
        if (v85)
          CFRelease(v85);
        if (v16)
          CFRelease(v16);
        if (Mutable)
          CFRelease(Mutable);
LABEL_161:
        v80 = (const void *)v97[3];
        if (v80)
          CFRelease(v80);
        freeNodes(v89);
        _Block_object_dispose(&v96, 8);
        return v88 & 1;
      default:
        goto LABEL_141;
    }
  }
}

void sub_187E63BE4(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

uint64_t IIOMetadata_Tag::setValue(IIOMetadata_Tag *this, const __CFString *cf)
{
  CFTypeID v4;
  CFTypeID v5;
  CFTypeID v6;
  CFTypeID v7;
  CFTypeID v8;
  const void *v9;
  CFTypeID v10;
  CFTypeID v11;
  void *SimpleStringFromCFValue;

  if (!cf)
    return 0;
  v4 = CFGetTypeID(cf);
  if (v4 != CFStringGetTypeID())
  {
    v5 = CFGetTypeID(cf);
    if (v5 != CFNumberGetTypeID())
    {
      v6 = CFGetTypeID(cf);
      if (v6 != CFBooleanGetTypeID())
      {
        v7 = CFGetTypeID(cf);
        if (v7 != CFDictionaryGetTypeID())
        {
          v8 = CFGetTypeID(cf);
          if (v8 != CFArrayGetTypeID())
            return 0;
        }
      }
    }
  }
  if (!*((_BYTE *)this + 64))
  {
    LogMetadata("setValue", 245, "Attempting to modify a tag from an immutable CGImageMetadataRef. Create a new CGImageMetadataTagRef or use CGImageMetadataCreateMutableCopy.\n");
    return 0;
  }
  v9 = (const void *)*((_QWORD *)this + 6);
  v10 = CFGetTypeID(cf);
  if (v10 == CFNumberGetTypeID() || (v11 = CFGetTypeID(cf), v11 == CFBooleanGetTypeID()))
  {
    SimpleStringFromCFValue = (void *)CGImageMetadataCreateSimpleStringFromCFValue(cf, 1);
    if (!SimpleStringFromCFValue)
    {
      _cg_jpeg_mem_term("setValue", 231, "*** ERROR: failed to create a CFString from 'value'\n");
      return 0;
    }
  }
  else
  {
    SimpleStringFromCFValue = (void *)CFRetain(cf);
  }
  *((_QWORD *)this + 6) = SimpleStringFromCFValue;
  if (v9)
    CFRelease(v9);
  return 1;
}

uint64_t CGImageMetadataTagSetValue(uint64_t a1, const __CFString *a2)
{
  IIOMetadata_Tag *v2;

  if (a1 && (v2 = *(IIOMetadata_Tag **)(a1 + 24)) != 0)
    return IIOMetadata_Tag::setValue(v2, a2);
  else
    return 0;
}

uint64_t TXMPMeta<std::string>::~TXMPMeta(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E1BB2B60;
  WXMPMeta_DecrementRefCount_1(*(_DWORD **)(a1 + 8));
  *(_QWORD *)(a1 + 8) = 0;
  return a1;
}

void WXMPMeta_DecrementRefCount_1(_DWORD *a1)
{
  unsigned __int8 v2;
  int v3;
  int v4;
  XMP_ReadWriteLock *v5;

  v5 = (XMP_ReadWriteLock *)(a1 + 4);
  XMP_ReadWriteLock::Acquire((pthread_rwlock_t *)(a1 + 4), 1);
  v3 = a1[2];
  if (v3 <= 0)
    __assert_rtn("WXMPMeta_DecrementRefCount_1", "WXMPMeta.cpp", 130, "thiz->clientRefs > 0");
  v4 = v3 - 1;
  a1[2] = v4;
  if (!v4)
  {
    XMP_ReadWriteLock::Release((XMP_ReadWriteLock *)(a1 + 4));
    v5 = 0;
    (*(void (**)(_DWORD *))(*(_QWORD *)a1 + 8))(a1);
  }
  XMP_AutoLock::~XMP_AutoLock(&v5);
}

void sub_187E63ED8(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187E63E7CLL);
}

void sub_187E63EE4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  XMP_AutoLock::~XMP_AutoLock((XMP_ReadWriteLock **)va);
  _Unwind_Resume(a1);
}

uint64_t TXMPIterator<std::string>::~TXMPIterator(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E1BAC3F0;
  WXMPIterator_DecrementRefCount_1(*(_DWORD **)(a1 + 8));
  *(_QWORD *)(a1 + 8) = 0;
  return a1;
}

void WXMPIterator_DecrementRefCount_1(_DWORD *a1)
{
  unsigned __int8 v2;
  int v3;
  int v4;
  XMP_ReadWriteLock *v5;

  v5 = (XMP_ReadWriteLock *)(a1 + 4);
  XMP_ReadWriteLock::Acquire((pthread_rwlock_t *)(a1 + 4), 1);
  v3 = a1[2];
  if (v3 <= 0)
    __assert_rtn("WXMPIterator_DecrementRefCount_1", "WXMPIterator.cpp", 105, "thiz->clientRefs > 0");
  v4 = v3 - 1;
  a1[2] = v4;
  if (!v4)
  {
    XMP_ReadWriteLock::Release((XMP_ReadWriteLock *)(a1 + 4));
    v5 = 0;
    (*(void (**)(_DWORD *))(*(_QWORD *)a1 + 8))(a1);
  }
  XMP_AutoLock::~XMP_AutoLock(&v5);
}

void sub_187E63FFC(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187E63FA0);
}

void sub_187E64008(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  XMP_AutoLock::~XMP_AutoLock((XMP_ReadWriteLock **)va);
  _Unwind_Resume(a1);
}

void XMPIterator::~XMPIterator(XMPIterator *this)
{
  XMPIterator::~XMPIterator(this);
  JUMPOUT(0x18D761C30);
}

{
  void *v2;
  void **v3;

  *(_QWORD *)this = &off_1E1BABF50;
  if (*((int *)this + 2) >= 1)
    __assert_rtn("~XMPIterator", "XMPIterator.cpp", 506, "this->clientRefs <= 0");
  v3 = (void **)((char *)this + 368);
  std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = (void **)((char *)this + 344);
  std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100](&v3);
  if (*((char *)this + 335) < 0)
    operator delete(*((void **)this + 39));
  v2 = (void *)*((_QWORD *)this + 35);
  if (v2)
  {
    *((_QWORD *)this + 36) = v2;
    operator delete(v2);
  }
  if (*((char *)this + 263) < 0)
    operator delete(*((void **)this + 30));
  XMP_ReadWriteLock::~XMP_ReadWriteLock((XMPIterator *)((char *)this + 16));
}

_QWORD *TXMPMeta<std::string>::TXMPMeta(_QWORD *a1)
{
  _QWORD *exception;
  uint64_t v4;
  _OWORD v5[2];
  uint64_t v6;

  *a1 = &off_1E1BB2B60;
  v6 = 0;
  memset(v5, 0, sizeof(v5));
  WXMPMeta_CTor_1(v5);
  if (*(_QWORD *)&v5[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v4 = *(_QWORD *)&v5[0];
    *(_DWORD *)exception = v6;
    exception[1] = v4;
    *((_BYTE *)exception + 16) = 0;
  }
  a1[1] = *((_QWORD *)&v5[0] + 1);
  return a1;
}

void TXMPMeta<std::string>::SetErrorCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *exception;
  uint64_t v5;
  _OWORD v6[2];
  uint64_t v7;

  v7 = 0;
  memset(v6, 0, sizeof(v6));
  WXMPMeta_SetErrorCallback_1(*(_QWORD *)(a1 + 8), (uint64_t)WrapErrorNotify, a2, a3, a4, v6);
  if (*(_QWORD *)&v6[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v5 = *(_QWORD *)&v6[0];
    *(_DWORD *)exception = v7;
    exception[1] = v5;
    *((_BYTE *)exception + 16) = 0;
  }
}

BOOL TXMPMeta<std::string>::Initialize()
{
  _QWORD *exception;
  uint64_t v2;
  _OWORD v3[2];
  uint64_t v4;

  v4 = 0;
  memset(v3, 0, sizeof(v3));
  WXMPMeta_Initialize_1((XMPMeta *)v3);
  if (*(_QWORD *)&v3[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v2 = *(_QWORD *)&v3[0];
    *(_DWORD *)exception = v4;
    exception[1] = v2;
    *((_BYTE *)exception + 16) = 0;
  }
  return (_DWORD)v4 != 0;
}

uint64_t WXMPMeta_Initialize_1(XMPMeta *a1)
{
  uint64_t result;

  *(_QWORD *)a1 = 0;
  result = XMPMeta::Initialize(a1);
  *((_DWORD *)a1 + 8) = result;
  return result;
}

void XMPMeta::~XMPMeta(XMPMeta *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_1E1BB29E0;
  if (*((int *)this + 2) >= 1)
    __assert_rtn("~XMPMeta", "XMPMeta.cpp", 732, "this->clientRefs <= 0");
  v2 = *((_QWORD *)this + 43);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  *((_QWORD *)this + 43) = 0;
  XMP_Node::~XMP_Node((XMPMeta *)((char *)this + 224));
  XMP_ReadWriteLock::~XMP_ReadWriteLock((XMPMeta *)((char *)this + 16));
}

{
  XMPMeta::~XMPMeta(this);
  JUMPOUT(0x18D761C30);
}

void XMP_ReadWriteLock::~XMP_ReadWriteLock(XMP_ReadWriteLock *this)
{
  const char *v2;
  int v3;

  if (atomic_load((unsigned int *)this + 50))
  {
    v2 = "this->lockCount == 0";
    v3 = 70;
    goto LABEL_6;
  }
  if (pthread_rwlock_destroy((pthread_rwlock_t *)this))
  {
    v2 = "err == 0";
    v3 = 72;
LABEL_6:
    __assert_rtn("~XMP_ReadWriteLock", "XMP_LibUtils.cpp", v3, v2);
  }
}

void XMPIterator::XMPIterator(XMPIterator *this, char **a2, char *a3, char *a4, int a5)
{
  const XMP_Node *Node;
  std::string::size_type v11;
  uint64_t v12;
  unint64_t v13;
  std::string::size_type v14;
  std::string::size_type v15;
  const std::string::value_type *v16;
  const std::string::value_type *v17;
  int v18;
  const std::string::value_type *v19;
  std::string::size_type v20;
  std::string::size_type size;
  std::string *v22;
  int v23;
  std::string::size_type v24;
  int v25;
  unint64_t v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  __int128 v35;
  unint64_t v36;
  __int128 v37;
  uint64_t v38;
  const XMP_Node *v39;
  const XMPMeta *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  __int128 v46;
  uint64_t v47;
  uint64_t v48;
  IterNode *SchemaNode;
  const XMP_Node *v50;
  _QWORD *exception;
  char *v52;
  uint64_t *v53;
  std::string v54;
  std::string *v55;
  std::string __p;
  _OWORD v57[4];
  std::string v58;
  std::string v59;
  void **v60[2];

  *((_DWORD *)this + 2) = 0;
  *(_QWORD *)this = &off_1E1BABF50;
  XMP_ReadWriteLock::XMP_ReadWriteLock((XMPIterator *)((char *)this + 16));
  *((_DWORD *)this + 56) = a5;
  *((_OWORD *)this + 15) = 0u;
  *((_QWORD *)this + 29) = a2;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  *((_BYTE *)this + 392) = 0;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *((_DWORD *)this + 76) = 0;
  if ((_BYTE)a5)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 103;
    exception[1] = "Unsupported iteration kind";
    *((_BYTE *)exception + 16) = 0;
  }
  v52 = a3;
  if (*a4)
  {
    memset(&v59, 0, sizeof(v59));
    ExpandXPath(a3, a4, (uint64_t *)&v59);
    Node = (const XMP_Node *)FindNode(a2 + 28, (const void ***)&v59, 0, 0, 0);
    if (Node)
    {
      memset(&v58, 0, sizeof(v58));
      v11 = v59.__r_.__value_.__r.__words[0];
      if (*(char *)(v59.__r_.__value_.__r.__words[0] + 55) < 0)
      {
        std::string::__init_copy_ctor_external(&v58, *(const std::string::value_type **)(v59.__r_.__value_.__r.__words[0] + 32), *(_QWORD *)(v59.__r_.__value_.__r.__words[0] + 40));
        v11 = v59.__r_.__value_.__r.__words[0];
      }
      else
      {
        v58 = *(std::string *)(v59.__r_.__value_.__r.__words[0] + 32);
      }
      if (v59.__r_.__value_.__l.__size_ - v11 >= 0x41)
      {
        v12 = 0;
        v13 = 2;
        do
        {
          if ((*(_DWORD *)(v11 + v12 + 88) & 0xFu) <= 2)
          {
            std::string::push_back(&v58, 47);
            v11 = v59.__r_.__value_.__r.__words[0];
          }
          v14 = v11 + v12;
          v17 = *(const std::string::value_type **)(v14 + 64);
          v15 = v14 + 64;
          v16 = v17;
          v18 = *(char *)(v15 + 23);
          if (v18 >= 0)
            v19 = (const std::string::value_type *)v15;
          else
            v19 = v16;
          if (v18 >= 0)
            v20 = *(unsigned __int8 *)(v15 + 23);
          else
            v20 = *(_QWORD *)(v15 + 8);
          std::string::append(&v58, v19, v20);
          ++v13;
          v11 = v59.__r_.__value_.__r.__words[0];
          v12 += 32;
        }
        while (v13 < (uint64_t)(v59.__r_.__value_.__l.__size_ - v59.__r_.__value_.__r.__words[0]) >> 5);
      }
      size = HIBYTE(v58.__r_.__value_.__r.__words[2]);
      if ((v58.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v22 = &v58;
      else
        v22 = (std::string *)v58.__r_.__value_.__r.__words[0];
      if ((v58.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        size = v58.__r_.__value_.__l.__size_;
      for (; size; --size)
      {
        v23 = v22->__r_.__value_.__s.__data_[size];
        if (v23 == 47)
          break;
        if (v23 == 91)
          break;
      }
      if (v22->__r_.__value_.__s.__data_[size] == 47)
        v24 = size + 1;
      else
        v24 = size;
      v25 = *((_DWORD *)Node + 2);
      std::string::basic_string[abi:ne180100]<0>(&v54, (char *)v22);
      LODWORD(v55) = v25;
      if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0)
        std::string::__init_copy_ctor_external(&__p, v54.__r_.__value_.__l.__data_, v54.__r_.__value_.__l.__size_);
      else
        __p = v54;
      *(_QWORD *)&v57[0] = v24;
      memset((char *)v57 + 8, 0, 49);
      v26 = *((_QWORD *)this + 44);
      if (v26 >= *((_QWORD *)this + 45))
      {
        v28 = std::vector<IterNode>::__push_back_slow_path<IterNode>((uint64_t *)this + 43, (uint64_t)&v55);
      }
      else
      {
        *(_DWORD *)v26 = (_DWORD)v55;
        v27 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
        *(_QWORD *)(v26 + 24) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
        *(_OWORD *)(v26 + 8) = v27;
        memset(&__p, 0, sizeof(__p));
        *(_QWORD *)(v26 + 32) = *(_QWORD *)&v57[0];
        *(_QWORD *)(v26 + 40) = 0;
        *(_QWORD *)(v26 + 48) = 0;
        *(_QWORD *)(v26 + 56) = 0;
        *(_OWORD *)(v26 + 40) = *(_OWORD *)((char *)v57 + 8);
        *((_QWORD *)&v57[0] + 1) = 0;
        *(_QWORD *)&v57[1] = 0;
        *(_QWORD *)(v26 + 56) = *((_QWORD *)&v57[1] + 1);
        *(_QWORD *)(v26 + 64) = 0;
        *((_QWORD *)&v57[1] + 1) = 0;
        *(_QWORD *)(v26 + 72) = 0;
        *(_QWORD *)(v26 + 80) = 0;
        *(_OWORD *)(v26 + 64) = v57[2];
        *(_QWORD *)(v26 + 80) = *(_QWORD *)&v57[3];
        memset(&v57[2], 0, 24);
        *(_BYTE *)(v26 + 88) = BYTE8(v57[3]);
        v28 = v26 + 96;
      }
      *((_QWORD *)this + 44) = v28;
      v60[0] = (void **)&v57[2];
      std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100](v60);
      v60[0] = (void **)v57 + 1;
      std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100](v60);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v54.__r_.__value_.__l.__data_);
      MEMORY[0x18D761A14]((char *)this + 240);
      if ((*((_BYTE *)this + 225) & 1) != 0)
        AddNodeOffspring((XMPIterator *)((char *)this + 224), (IterNode *)(*((_QWORD *)this + 44) - 96), Node);
      if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v58.__r_.__value_.__l.__data_);
    }
    v55 = &v59;
    std::vector<XPathStepInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&v55);
  }
  else if (*a3)
  {
    std::string::basic_string[abi:ne180100]<0>(&v59, a3);
    LODWORD(v55) = 0x80000000;
    if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0)
      std::string::__init_copy_ctor_external(&__p, v59.__r_.__value_.__l.__data_, v59.__r_.__value_.__l.__size_);
    else
      __p = v59;
    memset(v57, 0, 57);
    v45 = *((_QWORD *)this + 44);
    if (v45 >= *((_QWORD *)this + 45))
    {
      v47 = std::vector<IterNode>::__push_back_slow_path<IterNode>((uint64_t *)this + 43, (uint64_t)&v55);
    }
    else
    {
      *(_DWORD *)v45 = (_DWORD)v55;
      v46 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *(_QWORD *)(v45 + 24) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
      *(_OWORD *)(v45 + 8) = v46;
      memset(&__p, 0, sizeof(__p));
      *(_QWORD *)(v45 + 32) = *(_QWORD *)&v57[0];
      *(_QWORD *)(v45 + 40) = 0;
      *(_QWORD *)(v45 + 48) = 0;
      *(_QWORD *)(v45 + 56) = 0;
      *(_OWORD *)(v45 + 40) = *(_OWORD *)((char *)v57 + 8);
      *((_QWORD *)&v57[0] + 1) = 0;
      *(_QWORD *)&v57[1] = 0;
      *(_QWORD *)(v45 + 56) = *((_QWORD *)&v57[1] + 1);
      *(_QWORD *)(v45 + 64) = 0;
      *((_QWORD *)&v57[1] + 1) = 0;
      *(_QWORD *)(v45 + 72) = 0;
      *(_QWORD *)(v45 + 80) = 0;
      *(_OWORD *)(v45 + 64) = v57[2];
      *(_QWORD *)(v45 + 80) = *(_QWORD *)&v57[3];
      memset(&v57[2], 0, 24);
      *(_BYTE *)(v45 + 88) = BYTE8(v57[3]);
      v47 = v45 + 96;
    }
    *((_QWORD *)this + 44) = v47;
    v58.__r_.__value_.__r.__words[0] = (std::string::size_type)&v57[2];
    std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100]((void ***)&v58);
    v58.__r_.__value_.__r.__words[0] = (std::string::size_type)v57 + 8;
    std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100]((void ***)&v58);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v59.__r_.__value_.__l.__data_);
    v48 = *((_QWORD *)this + 44);
    SchemaNode = (IterNode *)FindSchemaNode(a2 + 28, a3, 0, 0, 0, 0);
    if (SchemaNode)
      AddSchemaProps((IterInfo *)(v48 - 96), SchemaNode, v50);
    if (*(_QWORD *)(v48 - 56) == *(_QWORD *)(v48 - 48))
      std::vector<IterNode>::__base_destruct_at_end[abi:ne180100]((uint64_t)this + 344, (void **)(*((_QWORD *)this + 44) - 96));
    else
      MEMORY[0x18D761A14]((char *)this + 240, a3);
  }
  else
  {
    v31 = a2[38] - a2[37];
    if (v31)
    {
      v32 = 0;
      v33 = v31 >> 3;
      v53 = (uint64_t *)((char *)this + 344);
      do
      {
        v34 = *(_QWORD *)&a2[37][8 * v32];
        LODWORD(v55) = 0x80000000;
        if (*(char *)(v34 + 39) < 0)
        {
          std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)(v34 + 16), *(_QWORD *)(v34 + 24));
        }
        else
        {
          v35 = *(_OWORD *)(v34 + 16);
          __p.__r_.__value_.__r.__words[2] = *(_QWORD *)(v34 + 32);
          *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v35;
        }
        memset(v57, 0, 57);
        v36 = *((_QWORD *)this + 44);
        if (v36 >= *((_QWORD *)this + 45))
        {
          v38 = std::vector<IterNode>::__push_back_slow_path<IterNode>(v53, (uint64_t)&v55);
        }
        else
        {
          *(_DWORD *)v36 = (_DWORD)v55;
          v37 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
          *(_QWORD *)(v36 + 24) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
          *(_OWORD *)(v36 + 8) = v37;
          memset(&__p, 0, sizeof(__p));
          *(_QWORD *)(v36 + 32) = *(_QWORD *)&v57[0];
          *(_QWORD *)(v36 + 40) = 0;
          *(_QWORD *)(v36 + 48) = 0;
          *(_QWORD *)(v36 + 56) = 0;
          *(_OWORD *)(v36 + 40) = *(_OWORD *)((char *)v57 + 8);
          *((_QWORD *)&v57[0] + 1) = 0;
          *(_QWORD *)&v57[1] = 0;
          *(_QWORD *)(v36 + 56) = *((_QWORD *)&v57[1] + 1);
          *(_QWORD *)(v36 + 64) = 0;
          *((_QWORD *)&v57[1] + 1) = 0;
          *(_QWORD *)(v36 + 72) = 0;
          *(_QWORD *)(v36 + 80) = 0;
          *(_OWORD *)(v36 + 64) = v57[2];
          *(_QWORD *)(v36 + 80) = *(_QWORD *)&v57[3];
          memset(&v57[2], 0, 24);
          *(_BYTE *)(v36 + 88) = BYTE8(v57[3]);
          v38 = v36 + 96;
        }
        *((_QWORD *)this + 44) = v38;
        v59.__r_.__value_.__r.__words[0] = (std::string::size_type)&v57[2];
        std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100]((void ***)&v59);
        v59.__r_.__value_.__r.__words[0] = (std::string::size_type)v57 + 8;
        std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100]((void ***)&v59);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        if ((*((_BYTE *)this + 225) & 1) == 0)
        {
          v40 = (const XMPMeta *)a2;
          v41 = v33;
          v42 = *((_QWORD *)this + 44);
          AddSchemaProps((IterInfo *)(v42 - 96), (IterNode *)v34, v39);
          v43 = *(_QWORD *)(v42 - 56);
          v44 = *(_QWORD *)(v42 - 48);
          v33 = v41;
          a2 = (char **)v40;
          if (v43 == v44)
            std::vector<IterNode>::__base_destruct_at_end[abi:ne180100]((uint64_t)v53, (void **)(*((_QWORD *)this + 44) - 96));
        }
        ++v32;
      }
      while (v33 != v32);
    }
  }
  v29 = *((_QWORD *)this + 43);
  v30 = *((_QWORD *)this + 44);
  *((_QWORD *)this + 33) = v29;
  *((_QWORD *)this + 34) = v30;
  if ((*((_BYTE *)this + 225) & 1) != 0 && v29 != v30)
  {
    if (*v52)
      *(_BYTE *)(v29 + 88) = 1;
  }
}

void sub_187E64AF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, XMP_ReadWriteLock *a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20)
{
  uint64_t v20;

  if (*(char *)(v20 - 97) < 0)
    operator delete(*(void **)(v20 - 120));
  IterInfo::~IterInfo(a10);
  XMP_ReadWriteLock::~XMP_ReadWriteLock(a11);
  _Unwind_Resume(a1);
}

void AddSchemaProps(IterInfo *a1, IterNode *a2, const XMP_Node *a3)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  __int128 v10;
  unint64_t v11;
  __int128 v12;
  uint64_t v13;
  int v14;
  _BYTE __p[56];
  _OWORD v16[2];
  void **v17;

  v3 = *((_QWORD *)a2 + 10) - *((_QWORD *)a2 + 9);
  if (v3)
  {
    v6 = 0;
    v7 = v3 >> 3;
    v8 = (uint64_t *)((char *)a1 + 40);
    do
    {
      v9 = *(_QWORD *)(*((_QWORD *)a2 + 9) + 8 * v6);
      v14 = *(_DWORD *)(v9 + 8);
      if (*(char *)(v9 + 39) < 0)
      {
        std::string::__init_copy_ctor_external((std::string *)__p, *(const std::string::value_type **)(v9 + 16), *(_QWORD *)(v9 + 24));
      }
      else
      {
        v10 = *(_OWORD *)(v9 + 16);
        *(_QWORD *)&__p[16] = *(_QWORD *)(v9 + 32);
        *(_OWORD *)__p = v10;
      }
      memset(v16, 0, 25);
      memset(&__p[24], 0, 32);
      v11 = *((_QWORD *)a1 + 6);
      if (v11 >= *((_QWORD *)a1 + 7))
      {
        v13 = std::vector<IterNode>::__push_back_slow_path<IterNode>(v8, (uint64_t)&v14);
      }
      else
      {
        *(_DWORD *)v11 = v14;
        v12 = *(_OWORD *)__p;
        *(_QWORD *)(v11 + 24) = *(_QWORD *)&__p[16];
        *(_OWORD *)(v11 + 8) = v12;
        memset(__p, 0, 24);
        *(_QWORD *)(v11 + 32) = *(_QWORD *)&__p[24];
        *(_QWORD *)(v11 + 40) = 0;
        *(_QWORD *)(v11 + 48) = 0;
        *(_QWORD *)(v11 + 56) = 0;
        *(_OWORD *)(v11 + 40) = *(_OWORD *)&__p[32];
        *(_OWORD *)&__p[32] = 0uLL;
        *(_QWORD *)(v11 + 56) = *(_QWORD *)&__p[48];
        *(_QWORD *)(v11 + 64) = 0;
        *(_QWORD *)&__p[48] = 0;
        *(_QWORD *)(v11 + 72) = 0;
        *(_QWORD *)(v11 + 80) = 0;
        *(_OWORD *)(v11 + 64) = v16[0];
        *(_QWORD *)(v11 + 80) = *(_QWORD *)&v16[1];
        memset(v16, 0, 24);
        *(_BYTE *)(v11 + 88) = BYTE8(v16[1]);
        v13 = v11 + 96;
      }
      *((_QWORD *)a1 + 6) = v13;
      v17 = (void **)v16;
      std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100](&v17);
      v17 = (void **)&__p[32];
      std::vector<IterNode>::__destroy_vector::operator()[abi:ne180100](&v17);
      if ((__p[23] & 0x80000000) != 0)
        operator delete(*(void **)__p);
      ++v6;
    }
    while (v7 != v6);
  }
}

void sub_187E64D4C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IterNode::~IterNode((void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<IterNode>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<IterNode>,std::reverse_iterator<IterNode*>,std::reverse_iterator<IterNode*>,std::reverse_iterator<IterNode*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<IterNode>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<IterNode>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void AdvanceIterPos(IterInfo *a1)
{
  char **v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  char *v31;
  char *v32;
  uint64_t v33;
  uint64_t *v34;
  char *v35;
  char *v36;
  char *v37;
  uint64_t v38;

  v2 = (char **)((char *)a1 + 56);
  v3 = *((_QWORD *)a1 + 5);
  while (1)
  {
    while (1)
    {
      v4 = *((_QWORD *)a1 + 6);
      if (v3 != v4)
        break;
      v6 = *((_QWORD *)a1 + 8);
      if (*((_QWORD *)a1 + 7) == v6)
        return;
      v8 = *(_QWORD *)(v6 - 16);
      v7 = v6 - 16;
      v3 = v8;
      *((_QWORD *)a1 + 5) = v8;
      *((_QWORD *)a1 + 6) = *(_QWORD *)(v7 + 8);
      *((_QWORD *)a1 + 8) = v7;
    }
    v5 = *(unsigned __int8 *)(v3 + 88);
    if (v5 == 1)
      break;
    if (v5 == 2)
      goto LABEL_10;
    if (!*(_BYTE *)(v3 + 88))
    {
      if ((*(_DWORD *)v3 & 0x80000000) != 0)
      {
        std::string::operator=((std::string *)((char *)a1 + 16), (const std::string *)(v3 + 8));
        v3 = *((_QWORD *)a1 + 5);
        v4 = *((_QWORD *)a1 + 6);
      }
      goto LABEL_50;
    }
LABEL_11:
    v3 = *((_QWORD *)a1 + 5);
    if (*(_BYTE *)(v3 + 88) == 3)
    {
      std::vector<IterNode>::__base_destruct_at_end[abi:ne180100](v3 + 40, *(void ***)(v3 + 40));
      v3 = *((_QWORD *)a1 + 5) + 96;
      *((_QWORD *)a1 + 5) = v3;
    }
  }
  *(_BYTE *)(v3 + 88) = 2;
  if (*(_QWORD *)(v3 + 64) != *(_QWORD *)(v3 + 72))
  {
    v15 = *((_QWORD *)a1 + 9);
    v16 = *((_QWORD *)a1 + 6);
    v17 = (uint64_t *)*((_QWORD *)a1 + 8);
    if ((unint64_t)v17 >= v15)
    {
      v24 = ((char *)v17 - *v2) >> 4;
      v25 = v24 + 1;
      if ((unint64_t)(v24 + 1) >> 60)
        goto LABEL_54;
      v26 = v15 - (_QWORD)*v2;
      if (v26 >> 3 > v25)
        v25 = v26 >> 3;
      if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF0)
        v27 = 0xFFFFFFFFFFFFFFFLL;
      else
        v27 = v25;
      if (v27)
        v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>>((uint64_t)a1 + 72, v27);
      else
        v28 = 0;
      v34 = (uint64_t *)&v28[16 * v24];
      v35 = &v28[16 * v27];
      *v34 = v3;
      v34[1] = v16;
      v18 = v34 + 2;
      v37 = (char *)*((_QWORD *)a1 + 7);
      v36 = (char *)*((_QWORD *)a1 + 8);
      if (v36 != v37)
      {
        do
        {
          *((_OWORD *)v34 - 1) = *((_OWORD *)v36 - 1);
          v34 -= 2;
          v36 -= 16;
        }
        while (v36 != v37);
        v36 = *v2;
      }
      *((_QWORD *)a1 + 7) = v34;
      *((_QWORD *)a1 + 8) = v18;
      *((_QWORD *)a1 + 9) = v35;
      if (v36)
        operator delete(v36);
    }
    else
    {
      *v17 = v3;
      v17[1] = v16;
      v18 = v17 + 2;
    }
    *((_QWORD *)a1 + 8) = v18;
    v38 = *((_QWORD *)a1 + 5);
    v4 = *(_QWORD *)(v38 + 72);
    *((_QWORD *)a1 + 6) = v4;
    v3 = *(_QWORD *)(v38 + 64);
    goto LABEL_49;
  }
LABEL_10:
  std::vector<IterNode>::__base_destruct_at_end[abi:ne180100](v3 + 64, *(void ***)(v3 + 64));
  v9 = *((_QWORD *)a1 + 5);
  *(_BYTE *)(v9 + 88) = 3;
  if (*(_QWORD *)(v9 + 40) == *(_QWORD *)(v9 + 48))
    goto LABEL_11;
  v10 = *((_QWORD *)a1 + 9);
  v12 = *((_QWORD *)a1 + 5);
  v11 = *((_QWORD *)a1 + 6);
  v13 = (_QWORD *)*((_QWORD *)a1 + 8);
  if ((unint64_t)v13 < v10)
  {
    *v13 = v12;
    v13[1] = v11;
    v14 = v13 + 2;
    goto LABEL_41;
  }
  v19 = ((char *)v13 - *v2) >> 4;
  v20 = v19 + 1;
  if ((unint64_t)(v19 + 1) >> 60)
LABEL_54:
    std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
  v21 = v10 - (_QWORD)*v2;
  if (v21 >> 3 > v20)
    v20 = v21 >> 3;
  if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF0)
    v22 = 0xFFFFFFFFFFFFFFFLL;
  else
    v22 = v20;
  if (v22)
    v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>>((uint64_t)a1 + 72, v22);
  else
    v23 = 0;
  v29 = &v23[16 * v19];
  v30 = &v23[16 * v22];
  *(_QWORD *)v29 = v12;
  *((_QWORD *)v29 + 1) = v11;
  v14 = v29 + 16;
  v32 = (char *)*((_QWORD *)a1 + 7);
  v31 = (char *)*((_QWORD *)a1 + 8);
  if (v31 != v32)
  {
    do
    {
      *((_OWORD *)v29 - 1) = *((_OWORD *)v31 - 1);
      v29 -= 16;
      v31 -= 16;
    }
    while (v31 != v32);
    v31 = *v2;
  }
  *((_QWORD *)a1 + 7) = v29;
  *((_QWORD *)a1 + 8) = v14;
  *((_QWORD *)a1 + 9) = v30;
  if (v31)
    operator delete(v31);
LABEL_41:
  *((_QWORD *)a1 + 8) = v14;
  v33 = *((_QWORD *)a1 + 5);
  v4 = *(_QWORD *)(v33 + 48);
  *((_QWORD *)a1 + 6) = v4;
  v3 = *(_QWORD *)(v33 + 40);
LABEL_49:
  *((_QWORD *)a1 + 5) = v3;
LABEL_50:
  if (v3 != v4)
  {
    if (*(_BYTE *)(v3 + 88))
      AdvanceIterPos();
  }
}

double WXMPMeta_Terminate_1(XMPMeta *a1)
{
  unsigned __int8 v1;

  if ((v1 & 1) == 0)
  {
    if ((_DWORD)a1)
  }
  return XMPMeta::Terminate(a1);
}

void sub_187E6512C(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
}

void TXMPMeta<std::string>::ParseFromBuffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *exception;
  uint64_t v5;
  _OWORD v6[2];
  uint64_t v7;

  v7 = 0;
  memset(v6, 0, sizeof(v6));
  WXMPMeta_ParseFromBuffer_1(*(_QWORD *)(a1 + 8), a2, a3, a4, v6);
  if (*(_QWORD *)&v6[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v5 = *(_QWORD *)&v6[0];
    *(_DWORD *)exception = v7;
    exception[1] = v5;
    *((_BYTE *)exception + 16) = 0;
  }
}

void TXMPIterator<std::string>::Skip(uint64_t a1, uint64_t a2)
{
  _QWORD *exception;
  uint64_t v3;
  _OWORD v4[2];
  uint64_t v5;

  v5 = 0;
  memset(v4, 0, sizeof(v4));
  WXMPIterator_Skip_1(*(_QWORD **)(a1 + 8), a2, v4);
  if (*(_QWORD *)&v4[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v3 = *(_QWORD *)&v4[0];
    *(_DWORD *)exception = v5;
    exception[1] = v3;
    *((_BYTE *)exception + 16) = 0;
  }
}

void WXMPMeta_IncrementRefCount_1(uint64_t a1)
{
  unsigned __int8 v2;
  int v3;
  XMP_ReadWriteLock *v4;

  v4 = (XMP_ReadWriteLock *)(a1 + 16);
  XMP_ReadWriteLock::Acquire((pthread_rwlock_t *)(a1 + 16), 1);
  v3 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v3 + 1;
  if (v3 < 0)
    __assert_rtn("WXMPMeta_IncrementRefCount_1", "WXMPMeta.cpp", 116, "thiz->clientRefs > 0");
  XMP_AutoLock::~XMP_AutoLock(&v4);
}

void sub_187E652A0(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187E65244);
}

void sub_187E652AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  XMP_AutoLock::~XMP_AutoLock((XMP_ReadWriteLock **)va);
  _Unwind_Resume(a1);
}

void WXMPIterator_Skip_1(_QWORD *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  XMP_ReadWriteLock *v7;
  XMP_ReadWriteLock *v8;

  v8 = (XMP_ReadWriteLock *)(a1 + 2);
  XMP_ReadWriteLock::Acquire((pthread_rwlock_t *)(a1 + 2), 1);
  *a3 = 0;
  v6 = a1[29];
  if (!v6)
    __assert_rtn("WXMPIterator_Skip_1", "WXMPIterator.cpp", 164, "thiz->info.xmpObj != __null");
  v7 = (XMP_ReadWriteLock *)(v6 + 16);
  XMP_ReadWriteLock::Acquire((pthread_rwlock_t *)(v6 + 16), 0);
  (*(void (**)(_QWORD *, uint64_t))(*a1 + 24))(a1, a2);
  XMP_AutoLock::~XMP_AutoLock(&v7);
  XMP_AutoLock::~XMP_AutoLock(&v8);
}

void sub_187E65368(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, XMP_ReadWriteLock *a9)
{
  uint64_t v9;
  void *v12;
  const char *v13;
  void *v14;
  uint64_t v15;

  XMP_AutoLock::~XMP_AutoLock(&a9);
  if (a2 == 3)
  {
    v12 = __cxa_begin_catch(a1);
    *(_DWORD *)(v9 + 32) = *(_DWORD *)v12;
    *(_QWORD *)(v9 + 8) = "XMP";
    v13 = (const char *)*((_QWORD *)v12 + 1);
    if (!v13)
      v13 = "";
  }
  else
  {
    v14 = __cxa_begin_catch(a1);
    if (a2 != 2)
    {
      *(_DWORD *)(v9 + 32) = 14;
      *(_QWORD *)v9 = "Caught unknown exception";
      __cxa_end_catch();
LABEL_10:
      JUMPOUT(0x187E65328);
    }
    *(_DWORD *)(v9 + 32) = 13;
    v15 = (*(uint64_t (**)(void *))(*(_QWORD *)v14 + 16))(v14);
    v13 = "";
    if (v15)
      v13 = (const char *)v15;
  }
  *(_QWORD *)v9 = v13;
  __cxa_end_catch();
  goto LABEL_10;
}

void sub_187E65428(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  XMP_AutoLock::~XMP_AutoLock((XMP_ReadWriteLock **)va);
  _Unwind_Resume(a1);
}

void XMPIterator::Skip(XMPIterator *this, unsigned int a2)
{
  _QWORD *exception;
  const char *v3;

  if (!a2)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 103;
    v3 = "Must specify what to skip";
    goto LABEL_10;
  }
  if (a2 >= 4)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 103;
    v3 = "Undefined options";
LABEL_10:
    exception[1] = v3;
    *((_BYTE *)exception + 16) = 0;
  }
  if ((a2 & 1) != 0)
  {
    *(_BYTE *)(*((_QWORD *)this + 33) + 88) = 3;
  }
  else if ((a2 & 2) != 0)
  {
    *((_QWORD *)this + 33) = *((_QWORD *)this + 34);
    AdvanceIterPos((XMPIterator *)((char *)this + 224));
  }
}

uint64_t myApplierFunction(const void *a1, const void *a2, uint64_t (**a3)(_QWORD, _QWORD, _QWORD, _QWORD))
{
  char v4;

  v4 = 0;
  return ((uint64_t (**)(_QWORD, const void *, const void *, char *))a3)[2](a3, a1, a2, &v4);
}

void ___ZN13IIOReadPlugin20extractDecodeOptionsEPK14__CFDictionary_block_invoke(uint64_t a1, CFStringRef theString1, const __CFString *a3, _BYTE *a4)
{
  uint64_t v7;
  CFStringRef v8;
  const char *v9;
  const char *v10;
  const char *v11;
  CFTypeID v13;
  CFTypeID v14;
  _BYTE v15[24];
  _BYTE v16[24];

  v7 = *(_QWORD *)(a1 + 32);
  if (CFStringCompare(theString1, (CFStringRef)*MEMORY[0x1E0C9DAB0], 0) == kCFCompareEqualTo)
  {
    if (CFStringCompare(a3, (CFStringRef)*MEMORY[0x1E0C9DAA8], 0))
    {
      IIOString::IIOString((IIOString *)v16, a3);
      v11 = (const char *)IIOString::utf8String((IIOString *)v16);
      LogWarning("extractDecodeOptions_block_invoke", 1259, "ImageIO - ignoring kCGImageBlockFormatRequest '%s'\n", v11);
      IIOString::~IIOString((IIOString *)v16);
      goto LABEL_19;
    }
    if (*(_DWORD *)(v7 + 320) == 1)
    {
      if (*(_WORD *)(v7 + 306) == 32 && *(_WORD *)(v7 + 304) == 8)
      {
        *(_WORD *)(v7 + 404) = 1;
        *(_BYTE *)(v7 + 406) = 1;
        return;
      }
      _cg_jpeg_mem_term("extractDecodeOptions_block_invoke", 1248, "*** ERROR: kCGImageBlockFormatBGRx8 is called for %d-bpp (%d-bpc) image\n");
    }
    else
    {
      _cg_jpeg_mem_term("extractDecodeOptions_block_invoke", 1253, "*** ERROR: kCGImageBlockFormatBGRx8 is called for non-RGB image [csm=%d]\n");
    }
    *(_BYTE *)(v7 + 414) = 0;
    return;
  }
  if (CFStringCompare(theString1, (CFStringRef)*MEMORY[0x1E0C9DA90], 0) == kCFCompareEqualTo)
  {
    IIONumber::IIONumber((IIONumber *)v16, (const __CFNumber *)a3);
    *(_QWORD *)(v7 + 384) = IIONumber::uint64Num((IIONumber *)v16);
    IIONumber::~IIONumber((IIONumber *)v16);
    if (*(_QWORD *)(v7 + 384))
      *(_BYTE *)(v7 + 409) = 1;
    return;
  }
  if (CFStringCompare(theString1, (CFStringRef)*MEMORY[0x1E0C9DA98], 0) == kCFCompareEqualTo)
  {
    IIONumber::IIONumber((IIONumber *)v16, (const __CFNumber *)a3);
    *(_QWORD *)(v7 + 392) = IIONumber::uint64Num((IIONumber *)v16);
    IIONumber::~IIONumber((IIONumber *)v16);
    if (*(_QWORD *)(v7 + 392))
      *(_BYTE *)(v7 + 410) = 1;
    return;
  }
  if (CFStringCompare(theString1, (CFStringRef)*MEMORY[0x1E0C9DAC0], 0) == kCFCompareEqualTo)
  {
    v13 = CFGetTypeID(a3);
    if (v13 == CFBooleanGetTypeID())
    {
      *(_BYTE *)(v7 + 408) = *MEMORY[0x1E0C9AE50] == (_QWORD)a3;
      return;
    }
    IIONumber::IIONumber((IIONumber *)v16, (const __CFNumber *)a3);
    *(_BYTE *)(v7 + 408) = IIONumber::uint64Num((IIONumber *)v16) != 0;
LABEL_40:
    IIONumber::~IIONumber((IIONumber *)v16);
    return;
  }
  if (CFStringCompare(theString1, (CFStringRef)*MEMORY[0x1E0C9DAA0], 0) == kCFCompareEqualTo)
  {
    LogWarning("extractDecodeOptions_block_invoke", 1286, "ignoring 'kCGImageBlockColorSpaceRequest'\n");
    goto LABEL_19;
  }
  if (CFStringCompare(theString1, (CFStringRef)*MEMORY[0x1E0C9DAB8], 0) == kCFCompareEqualTo)
  {
    v14 = CFGetTypeID(a3);
    if (v14 == CFBooleanGetTypeID())
    {
      *(_BYTE *)(v7 + 407) = *MEMORY[0x1E0C9AE50] == (_QWORD)a3;
      return;
    }
    IIONumber::IIONumber((IIONumber *)v16, (const __CFNumber *)a3);
    *(_BYTE *)(v7 + 407) = IIONumber::uint64Num((IIONumber *)v16) != 0;
    goto LABEL_40;
  }
  if (CFStringCompare(theString1, (CFStringRef)*MEMORY[0x1E0C9DAC8], 0)
    && CFStringCompare(theString1, CFSTR("kCGImageBlockIOSurfacePromoteToCIF10"), 0)
    && CFStringCompare(theString1, CFSTR("kImageIOConvertWideGamutImage"), 0)
    && CFStringCompare(theString1, CFSTR("kCGImageBlockPreHeating"), 0)
    && CFStringCompare(theString1, CFSTR("kCGImageSourceRasterizationDPI"), 0)
    && CFStringCompare(theString1, CFSTR("kCGImagePreferGPUForColorConversion"), 0)
    && CFStringCompare(theString1, CFSTR("kCGImagePreferredColorConversionMode"), 0)
    && CFStringCompare(theString1, CFSTR("kCGImageProviderPreferedBandHeight"), 0)
    && CFStringCompare(theString1, CFSTR("kCGImageSurfaceFormatRequest"), 0))
  {
    v8 = CFCopyDescription(a3);
    IIOString::IIOString((IIOString *)v16, theString1);
    v9 = (const char *)IIOString::utf8String((IIOString *)v16);
    IIOString::IIOString((IIOString *)v15, v8);
    v10 = (const char *)IIOString::utf8String((IIOString *)v15);
    _cg_jpeg_mem_term("extractDecodeOptions_block_invoke", 1326, "ignoring unknown request for '%s' : '%s'\n", v9, v10);
    IIOString::~IIOString((IIOString *)v15);
    IIOString::~IIOString((IIOString *)v16);
    CFRelease(v8);
LABEL_19:
    *(_BYTE *)(v7 + 414) = 0;
    *a4 = 1;
  }
}

void sub_187E65970(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void IIONumber::IIONumber(IIONumber *this, CFTypeRef cf)
{
  CFTypeID v4;
  CFTypeID v5;
  CFTypeID v6;
  const char *v7;
  uint64_t v8;
  _QWORD valuePtr[3];

  *(_QWORD *)this = &off_1E1BB2F60;
  if (!cf)
    goto LABEL_8;
  v4 = CFGetTypeID(cf);
  if (v4 == CFNumberGetTypeID())
  {
    *((_QWORD *)this + 2) = CFRetain(cf);
    *((_QWORD *)this + 1) = CFNumberGetType((CFNumberRef)cf);
    return;
  }
  v5 = CFGetTypeID(cf);
  if (v5 == CFBooleanGetTypeID())
  {
    LOBYTE(valuePtr[0]) = *MEMORY[0x1E0C9AE50] == (_QWORD)cf;
    *((_QWORD *)this + 1) = 1;
    *((_QWORD *)this + 2) = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt8Type, valuePtr);
    return;
  }
  v6 = CFGetTypeID(cf);
  if (v6 == CFStringGetTypeID())
  {
    memset(valuePtr, 0, sizeof(valuePtr));
    IIOString::IIOString((IIOString *)valuePtr, cf);
    v7 = (const char *)IIOString::utf8String((IIOString *)valuePtr);
    v8 = atol(v7);
    *((_QWORD *)this + 1) = 10;
    *((_QWORD *)this + 2) = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberLongType, &v8);
    IIOString::~IIOString((IIOString *)valuePtr);
  }
  else
  {
LABEL_8:
    IIOLogTypeMismatch(cf, "IIONumber", "CFNumberRef");
    *((_QWORD *)this + 2) = 0;
  }
}

void sub_187E65B10(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

unint64_t IIONumber::uint64Num(IIONumber *this)
{
  const __CFNumber *v2;
  double v4;
  uint64_t valuePtr;

  valuePtr = 0;
  v2 = (const __CFNumber *)*((_QWORD *)this + 2);
  if (v2)
  {
    if (CFNumberGetValue(v2, kCFNumberSInt64Type, &valuePtr))
      return valuePtr;
    v2 = (const __CFNumber *)*((_QWORD *)this + 2);
  }
  if (CFNumberIsFloatType(v2))
  {
    v4 = 0.0;
    if (CFNumberGetValue(*((CFNumberRef *)this + 2), kCFNumberDoubleType, &v4))
      return (unint64_t)v4;
  }
  LogError("uint64Num", 366, "CFNumberGetValue/uint64_t failed\n");
  return 0;
}

void IIOImageProviderInfo::ReleaseInfo(IIOImageProviderInfo *this, void *a2)
{
  _QWORD *v3;
  __CFArray *Property;
  unint64_t i;
  const __CFDictionary *ObjectAtIndex;
  unsigned int Uint32ForKey;
  const __CFDictionary *Uint64ForKey;
  _QWORD v9[3];
  char __str[16];
  __int128 v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (this)
  {
    if ((gIIODebugFlags & 0xC000) != 0)
    {
      *(_OWORD *)__str = 0u;
      v11 = 0u;
      v3 = *(_QWORD **)this;
      if (*(_QWORD *)this)
        v3 = (_QWORD *)v3[2];
      snprintf(__str, 0x20uLL, "(%p)", v3);
      if ((unsigned __int16)gIIODebugFlags >> 14)
        ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "_CGImageProviderRelease", 0, __str, -1, 0);
    }
    if (*(_QWORD *)this)
    {
      Property = (__CFArray *)CGImageProviderGetProperty();
      if (Property)
      {
        memset(__str, 0, sizeof(__str));
        *(_QWORD *)&v11 = 0;
        IIOArray::IIOArray((IIOArray *)__str, Property);
        for (i = 0; i < IIOArray::getCount((IIOArray *)__str); ++i)
        {
          ObjectAtIndex = IIOArray::getObjectAtIndex((IIOArray *)__str, i);
          memset(v9, 0, sizeof(v9));
          IIODictionary::IIODictionary((IIODictionary *)v9, ObjectAtIndex);
          Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v9, CFSTR("iosurface_plane_datasize"));
          Uint64ForKey = IIODictionary::getUint64ForKey((IIODictionary *)v9, CFSTR("iosurface_plane_baseAddress"));
          if (Uint64ForKey)
          {
            if (Uint32ForKey)
              _ImageIO_Free((unint64_t)Uint64ForKey, Uint32ForKey);
          }
          IIODictionary::~IIODictionary((IIODictionary *)v9);
        }
        IIOArray::~IIOArray((IIOArray *)__str);
      }
      if (*(_QWORD *)this)
        (*(void (**)(_QWORD))(**(_QWORD **)this + 8))(*(_QWORD *)this);
    }
    free(this);
  }
}

void sub_187E65D7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13)
{
  _Unwind_Resume(exception_object);
}

void IIOImageProviderInfo::~IIOImageProviderInfo(IIOImageProviderInfo *this)
{
  IIOImageProviderInfo::~IIOImageProviderInfo(this);
  JUMPOUT(0x18D761C30);
}

{
  pthread_mutex_t *v2;
  double v3;
  char *v4;
  void (*v5)(_QWORD);

  *(_QWORD *)this = &off_1E1BB1F40;
  v2 = (pthread_mutex_t *)((char *)this + 144);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 144));
  switch(*((_DWORD *)this + 52))
  {
    case 0:
    case 1:
      v4 = (char *)this + 224;
      goto LABEL_6;
    case 2:
      v4 = (char *)this + 232;
      goto LABEL_6;
    case 3:
      v4 = (char *)this + 248;
LABEL_6:
      v5 = *(void (**)(_QWORD))v4;
      *(_QWORD *)v4 = 0;
      if (!v5)
        goto LABEL_8;
      v5(*((_QWORD *)this + 14));
      break;
    default:
      *(_QWORD *)&v3 = _cg_jpeg_mem_term("~IIOImageProviderInfo", 1715, "*** unknown imageProvider callback version [%d]\n", *((_DWORD *)this + 52)).n128_u64[0];
LABEL_8:
      LogWarning("~IIOImageProviderInfo", 1728, "$$$ ImageProviderReleaseInfoCallback: cookie without releaseInfo - leaking\n", v3);
      break;
  }
  pthread_mutex_unlock(v2);
  pthread_mutex_destroy(v2);
}

void IIOReadPlugin::ReleaseInfo(IIOReadPlugin *this, void *a2)
{
  const void *v3;
  uint64_t v4;

  if (this)
  {
    v3 = *(const void **)this;
    if (v3)
      CFRelease(v3);
    *(_QWORD *)this = 0;
    v4 = *((_QWORD *)this + 1);
    if (v4)
      (*(void (**)(uint64_t, void *))(*(_QWORD *)v4 + 8))(v4, a2);
    free(this);
  }
}

void PNGReadPlugin::~PNGReadPlugin(PNGReadPlugin *this)
{
  PNGReadPlugin::~PNGReadPlugin(this);
  JUMPOUT(0x18D761C30);
}

{
  void *v2;
  const void *v3;

  *(_QWORD *)this = &off_1E1BAD7B8;
  v2 = (void *)*((_QWORD *)this + 61);
  if (v2)
  {
    free(v2);
    *((_QWORD *)this + 61) = 0;
  }
  v3 = (const void *)*((_QWORD *)this + 63);
  if (v3)
  {
    CFRelease(v3);
    *((_QWORD *)this + 63) = 0;
  }
  IIOReadPlugin::~IIOReadPlugin(this);
}

void IIOReadPlugin::~IIOReadPlugin(IIOReadPlugin *this)
{
  uint64_t v2;
  uint64_t v3;
  CGColorSpace *v4;
  const void *v5;
  void *v6;
  mach_port_name_t v7;

  *(_QWORD *)this = &off_1E1BACDE8;
  if (*((_BYTE *)this + 40))
  {
    v2 = *((_QWORD *)this + 4);
    if (!v2 || ((*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2), *((_BYTE *)this + 40)))
    {
      v3 = *((_QWORD *)this + 3);
      if (v3)
        (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
    }
  }
  v4 = (CGColorSpace *)*((_QWORD *)this + 20);
  if (v4)
  {
    CGColorSpaceRelease(v4);
    *((_QWORD *)this + 20) = 0;
  }
  v5 = (const void *)*((_QWORD *)this + 21);
  if (v5)
  {
    CFRelease(v5);
    *((_QWORD *)this + 21) = 0;
  }
  v6 = (void *)*((_QWORD *)this + 12);
  if (v6)
    free(v6);
  *((_QWORD *)this + 12) = 0;
  *((_DWORD *)this + 26) = 0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 6) = 0;
  v7 = *((_DWORD *)this + 108);
  if (v7)
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], v7);
}

{
  IIOReadPlugin::~IIOReadPlugin(this);
  JUMPOUT(0x18D761C30);
}

void HEIFReadPlugin::~HEIFReadPlugin(HEIFReadPlugin *this)
{
  HEIFReadPlugin::~HEIFReadPlugin(this);
  JUMPOUT(0x18D761C30);
}

{
  const void *v2;

  *(_QWORD *)this = &off_1E1BAE158;
  v2 = (const void *)*((_QWORD *)this + 64);
  if (v2)
    CFRelease(v2);
  IIOReadPlugin::~IIOReadPlugin(this);
}

void AppleJPEGReadPlugin::~AppleJPEGReadPlugin(AppleJPEGReadPlugin *this)
{
  AppleJPEGReadPlugin::~AppleJPEGReadPlugin(this);
  JUMPOUT(0x18D761C30);
}

{
  void *v2;

  *(_QWORD *)this = &off_1E1BB19F8;
  applejpeg_decode_destroy();
  *((_QWORD *)this + 63) = 0;
  v2 = (void *)*((_QWORD *)this + 79);
  if (v2)
  {
    free(v2);
    *((_QWORD *)this + 79) = 0;
  }
  JPEGReadPlugin::~JPEGReadPlugin(this);
}

void JPEGReadPlugin::~JPEGReadPlugin(JPEGReadPlugin *this)
{
  const void *v2;

  *(_QWORD *)this = &off_1E1BAF8A0;
  v2 = (const void *)*((_QWORD *)this + 55);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 55) = 0;
  IIOReadPlugin::~IIOReadPlugin(this);
}

{
  JPEGReadPlugin::~JPEGReadPlugin(this);
  JUMPOUT(0x18D761C30);
}

void ATXReadPlugin::~ATXReadPlugin(ATXReadPlugin *this)
{
  *(_QWORD *)this = &off_1E1BAC560;
  CommonASTCReadPlugin::~CommonASTCReadPlugin(this);
  JUMPOUT(0x18D761C30);
}

{
  *(_QWORD *)this = &off_1E1BAC560;
  CommonASTCReadPlugin::~CommonASTCReadPlugin(this);
}

void CommonASTCReadPlugin::~CommonASTCReadPlugin(CommonASTCReadPlugin *this)
{
  const void *v2;

  *(_QWORD *)this = &off_1E1BB1E20;
  v2 = (const void *)*((_QWORD *)this + 58);
  if (v2)
    CFRelease(v2);
  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100]((uint64_t)this + 472);
  IIOReadPlugin::~IIOReadPlugin(this);
}

{
  CommonASTCReadPlugin::~CommonASTCReadPlugin(this);
  JUMPOUT(0x18D761C30);
}

void TIFFReadPlugin::~TIFFReadPlugin(TIFFReadPlugin *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  TIFFReadPlugin::~TIFFReadPlugin(this, a2, a3, a4, a5, a6, a7, a8);
  JUMPOUT(0x18D761C30);
}

{
  uint64_t v9;

  *(_QWORD *)this = &off_1E1BAFD08;
  v9 = *((_QWORD *)this + 55);
  if (v9)
    _cg_TIFFClose(v9, a2, a3, a4, a5, a6, a7, a8);
  *((_QWORD *)this + 55) = 0;
  IIOReadPlugin::~IIOReadPlugin(this);
}

void IIO_ReaderHandler::buildPluginList(IIO_ReaderHandler *this)
{
  char *v2;
  void *v3;
  void *v4;
  const __CFArray *v5;
  uint64_t v6;
  char *v7;
  uint64_t (*v8)(char *, uint64_t *);
  char *v9;
  char *v10;
  IIO_Reader *Reader_AppleJPEG;
  uint64_t *v12;
  unint64_t v13;
  IIO_Reader **v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  uint64_t v24;
  __int128 v25;
  uint64_t v26;
  IIO_Reader *Reader_PNG;
  uint64_t *v28;
  unint64_t v29;
  IIO_Reader **v30;
  _QWORD *v31;
  _QWORD *v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  char *v37;
  char *v38;
  char *v39;
  uint64_t v40;
  __int128 v41;
  uint64_t v42;
  IIO_Reader *Reader_GIF;
  uint64_t *v44;
  unint64_t v45;
  IIO_Reader **v46;
  _QWORD *v47;
  _QWORD *v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  unint64_t v52;
  char *v53;
  char *v54;
  char *v55;
  uint64_t v56;
  __int128 v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t **v60;
  uint64_t v61;
  uint64_t *v62;
  unint64_t v63;
  uint64_t *v64;
  _QWORD *v65;
  uint64_t *v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  unint64_t v70;
  char *v71;
  char *v72;
  char *v73;
  uint64_t v74;
  __int128 v75;
  uint64_t v76;
  IIO_Reader *Reader_TIFF;
  uint64_t *v78;
  unint64_t v79;
  IIO_Reader **v80;
  _QWORD *v81;
  _QWORD *v82;
  uint64_t v83;
  unint64_t v84;
  uint64_t v85;
  unint64_t v86;
  char *v87;
  char *v88;
  char *v89;
  uint64_t v90;
  __int128 v91;
  uint64_t v92;
  IIO_Reader *Reader_JP2;
  uint64_t *v94;
  unint64_t v95;
  IIO_Reader **v96;
  _QWORD *v97;
  _QWORD *v98;
  uint64_t v99;
  unint64_t v100;
  uint64_t v101;
  unint64_t v102;
  char *v103;
  char *v104;
  char *v105;
  uint64_t v106;
  __int128 v107;
  uint64_t v108;
  IIO_Reader *Reader_ATX;
  uint64_t *v110;
  unint64_t v111;
  IIO_Reader **v112;
  _QWORD *v113;
  _QWORD *v114;
  uint64_t v115;
  unint64_t v116;
  uint64_t v117;
  unint64_t v118;
  char *v119;
  char *v120;
  char *v121;
  uint64_t v122;
  __int128 v123;
  uint64_t v124;
  IIO_Reader *Reader_ASTC;
  uint64_t *v126;
  unint64_t v127;
  IIO_Reader **v128;
  _QWORD *v129;
  _QWORD *v130;
  uint64_t v131;
  unint64_t v132;
  uint64_t v133;
  unint64_t v134;
  char *v135;
  char *v136;
  char *v137;
  uint64_t v138;
  __int128 v139;
  uint64_t v140;
  IIO_Reader *Reader_KTX_ASTC;
  uint64_t *v142;
  unint64_t v143;
  IIO_Reader **v144;
  _QWORD *v145;
  _QWORD *v146;
  uint64_t v147;
  unint64_t v148;
  uint64_t v149;
  unint64_t v150;
  char *v151;
  char *v152;
  char *v153;
  uint64_t v154;
  __int128 v155;
  uint64_t v156;
  IIO_Reader *Reader_KTX_BC;
  uint64_t *v158;
  unint64_t v159;
  IIO_Reader **v160;
  _QWORD *v161;
  _QWORD *v162;
  uint64_t v163;
  unint64_t v164;
  uint64_t v165;
  unint64_t v166;
  char *v167;
  char *v168;
  char *v169;
  uint64_t v170;
  __int128 v171;
  uint64_t v172;
  IIO_Reader *Reader_KTX_ETC;
  uint64_t *v174;
  unint64_t v175;
  IIO_Reader **v176;
  _QWORD *v177;
  _QWORD *v178;
  uint64_t v179;
  unint64_t v180;
  uint64_t v181;
  unint64_t v182;
  char *v183;
  char *v184;
  char *v185;
  uint64_t v186;
  __int128 v187;
  uint64_t v188;
  IIO_Reader *Reader_KTX_PVR;
  uint64_t *v190;
  unint64_t v191;
  IIO_Reader **v192;
  _QWORD *v193;
  _QWORD *v194;
  uint64_t v195;
  unint64_t v196;
  uint64_t v197;
  unint64_t v198;
  char *v199;
  char *v200;
  char *v201;
  uint64_t v202;
  __int128 v203;
  uint64_t v204;
  IIO_Reader *Reader_KTX;
  uint64_t *v206;
  unint64_t v207;
  IIO_Reader **v208;
  _QWORD *v209;
  _QWORD *v210;
  uint64_t v211;
  unint64_t v212;
  uint64_t v213;
  unint64_t v214;
  char *v215;
  char *v216;
  char *v217;
  uint64_t v218;
  __int128 v219;
  uint64_t v220;
  IIO_Reader *Reader_KTX2_ASTC;
  uint64_t *v222;
  unint64_t v223;
  IIO_Reader **v224;
  _QWORD *v225;
  _QWORD *v226;
  uint64_t v227;
  unint64_t v228;
  uint64_t v229;
  unint64_t v230;
  char *v231;
  char *v232;
  char *v233;
  uint64_t v234;
  __int128 v235;
  uint64_t v236;
  IIO_Reader *Reader_KTX2_BC;
  uint64_t *v238;
  unint64_t v239;
  IIO_Reader **v240;
  _QWORD *v241;
  _QWORD *v242;
  uint64_t v243;
  unint64_t v244;
  uint64_t v245;
  unint64_t v246;
  char *v247;
  char *v248;
  char *v249;
  uint64_t v250;
  __int128 v251;
  uint64_t v252;
  IIO_Reader *Reader_KTX2_ETC;
  uint64_t *v254;
  unint64_t v255;
  IIO_Reader **v256;
  _QWORD *v257;
  _QWORD *v258;
  uint64_t v259;
  unint64_t v260;
  uint64_t v261;
  unint64_t v262;
  char *v263;
  char *v264;
  char *v265;
  uint64_t v266;
  __int128 v267;
  uint64_t v268;
  IIO_Reader *Reader_KTX2_PVR;
  uint64_t *v270;
  unint64_t v271;
  IIO_Reader **v272;
  _QWORD *v273;
  _QWORD *v274;
  uint64_t v275;
  unint64_t v276;
  uint64_t v277;
  unint64_t v278;
  char *v279;
  char *v280;
  char *v281;
  uint64_t v282;
  __int128 v283;
  uint64_t v284;
  IIO_Reader *Reader_KTX2;
  uint64_t *v286;
  unint64_t v287;
  IIO_Reader **v288;
  _QWORD *v289;
  _QWORD *v290;
  uint64_t v291;
  unint64_t v292;
  uint64_t v293;
  unint64_t v294;
  char *v295;
  char *v296;
  char *v297;
  uint64_t v298;
  __int128 v299;
  uint64_t v300;
  uint64_t Reader_AVCI;
  uint64_t *v302;
  unint64_t v303;
  uint64_t *v304;
  _QWORD *v305;
  _QWORD *v306;
  uint64_t v307;
  unint64_t v308;
  uint64_t v309;
  unint64_t v310;
  char *v311;
  char *v312;
  char *v313;
  uint64_t v314;
  __int128 v315;
  uint64_t v316;
  uint64_t Reader_JPEGXL;
  uint64_t *v318;
  unint64_t v319;
  uint64_t *v320;
  _QWORD *v321;
  _QWORD *v322;
  uint64_t v323;
  unint64_t v324;
  uint64_t v325;
  unint64_t v326;
  char *v327;
  char *v328;
  char *v329;
  uint64_t v330;
  __int128 v331;
  uint64_t v332;
  uint64_t Reader_AVIF;
  uint64_t *v334;
  unint64_t v335;
  uint64_t *v336;
  _QWORD *v337;
  _QWORD *v338;
  uint64_t v339;
  unint64_t v340;
  uint64_t v341;
  unint64_t v342;
  char *v343;
  char *v344;
  char *v345;
  uint64_t v346;
  __int128 v347;
  uint64_t v348;
  uint64_t Reader_AVIS;
  uint64_t *v350;
  unint64_t v351;
  uint64_t *v352;
  _QWORD *v353;
  _QWORD *v354;
  uint64_t v355;
  unint64_t v356;
  uint64_t v357;
  unint64_t v358;
  char *v359;
  char *v360;
  char *v361;
  uint64_t v362;
  __int128 v363;
  uint64_t v364;
  uint64_t Reader_HEIC;
  uint64_t *v366;
  unint64_t v367;
  uint64_t *v368;
  _QWORD *v369;
  _QWORD *v370;
  uint64_t v371;
  unint64_t v372;
  uint64_t v373;
  unint64_t v374;
  char *v375;
  char *v376;
  char *v377;
  uint64_t v378;
  __int128 v379;
  uint64_t v380;
  uint64_t Reader_HEICS;
  uint64_t *v382;
  unint64_t v383;
  uint64_t *v384;
  _QWORD *v385;
  _QWORD *v386;
  uint64_t v387;
  unint64_t v388;
  uint64_t v389;
  unint64_t v390;
  char *v391;
  char *v392;
  char *v393;
  uint64_t v394;
  __int128 v395;
  uint64_t v396;
  uint64_t Reader_HEIC_JPEG;
  uint64_t *v398;
  unint64_t v399;
  uint64_t *v400;
  _QWORD *v401;
  _QWORD *v402;
  uint64_t v403;
  unint64_t v404;
  uint64_t v405;
  unint64_t v406;
  char *v407;
  char *v408;
  char *v409;
  uint64_t v410;
  __int128 v411;
  uint64_t v412;
  uint64_t Reader_HEIF;
  uint64_t *v414;
  unint64_t v415;
  uint64_t *v416;
  _QWORD *v417;
  _QWORD *v418;
  uint64_t v419;
  unint64_t v420;
  uint64_t v421;
  unint64_t v422;
  char *v423;
  char *v424;
  char *v425;
  uint64_t v426;
  __int128 v427;
  uint64_t v428;
  uint64_t v429;
  uint64_t **v430;
  uint64_t v431;
  uint64_t *v432;
  unint64_t v433;
  uint64_t *v434;
  _QWORD *v435;
  uint64_t *v436;
  uint64_t v437;
  unint64_t v438;
  uint64_t v439;
  unint64_t v440;
  char *v441;
  char *v442;
  char *v443;
  uint64_t v444;
  __int128 v445;
  uint64_t v446;
  IIO_Reader *Reader_ICO;
  uint64_t *v448;
  unint64_t v449;
  IIO_Reader **v450;
  _QWORD *v451;
  _QWORD *v452;
  uint64_t v453;
  unint64_t v454;
  uint64_t v455;
  unint64_t v456;
  char *v457;
  char *v458;
  char *v459;
  uint64_t v460;
  __int128 v461;
  uint64_t v462;
  IIO_Reader *Reader_BMP;
  uint64_t *v464;
  unint64_t v465;
  IIO_Reader **v466;
  _QWORD *v467;
  _QWORD *v468;
  uint64_t v469;
  unint64_t v470;
  uint64_t v471;
  unint64_t v472;
  char *v473;
  char *v474;
  char *v475;
  uint64_t v476;
  __int128 v477;
  uint64_t v478;
  IIO_Reader *Reader_ICNS;
  uint64_t *v480;
  unint64_t v481;
  IIO_Reader **v482;
  _QWORD *v483;
  _QWORD *v484;
  uint64_t v485;
  unint64_t v486;
  uint64_t v487;
  unint64_t v488;
  char *v489;
  char *v490;
  char *v491;
  uint64_t v492;
  __int128 v493;
  uint64_t v494;
  IIO_Reader *Reader_PSD;
  uint64_t *v496;
  unint64_t v497;
  IIO_Reader **v498;
  _QWORD *v499;
  _QWORD *v500;
  uint64_t v501;
  unint64_t v502;
  uint64_t v503;
  unint64_t v504;
  char *v505;
  char *v506;
  char *v507;
  uint64_t v508;
  __int128 v509;
  uint64_t v510;
  IIO_Reader *Reader_PDF;
  uint64_t *v512;
  unint64_t v513;
  IIO_Reader **v514;
  _QWORD *v515;
  _QWORD *v516;
  uint64_t v517;
  unint64_t v518;
  uint64_t v519;
  unint64_t v520;
  char *v521;
  char *v522;
  char *v523;
  uint64_t v524;
  __int128 v525;
  uint64_t v526;
  IIO_Reader *Reader_AI;
  uint64_t *v528;
  unint64_t v529;
  IIO_Reader **v530;
  _QWORD *v531;
  _QWORD *v532;
  uint64_t v533;
  unint64_t v534;
  uint64_t v535;
  unint64_t v536;
  char *v537;
  char *v538;
  char *v539;
  uint64_t v540;
  __int128 v541;
  uint64_t v542;
  uint64_t v543;
  uint64_t *v544;
  unint64_t v545;
  uint64_t *v546;
  _QWORD *v547;
  _QWORD *v548;
  uint64_t v549;
  unint64_t v550;
  uint64_t v551;
  unint64_t v552;
  char *v553;
  char *v554;
  char *v555;
  uint64_t v556;
  __int128 v557;
  uint64_t v558;
  IIO_Reader *Reader_CUR;
  uint64_t *v560;
  unint64_t v561;
  IIO_Reader **v562;
  _QWORD *v563;
  _QWORD *v564;
  uint64_t v565;
  unint64_t v566;
  uint64_t v567;
  unint64_t v568;
  char *v569;
  char *v570;
  char *v571;
  uint64_t v572;
  __int128 v573;
  uint64_t v574;
  IIO_Reader *Reader_TGA;
  uint64_t *v576;
  unint64_t v577;
  IIO_Reader **v578;
  _QWORD *v579;
  _QWORD *v580;
  uint64_t v581;
  unint64_t v582;
  uint64_t v583;
  unint64_t v584;
  char *v585;
  char *v586;
  char *v587;
  uint64_t v588;
  __int128 v589;
  uint64_t v590;
  IIO_Reader *Reader_EXR;
  uint64_t *v592;
  unint64_t v593;
  IIO_Reader **v594;
  _QWORD *v595;
  _QWORD *v596;
  uint64_t v597;
  unint64_t v598;
  uint64_t v599;
  unint64_t v600;
  char *v601;
  char *v602;
  char *v603;
  uint64_t v604;
  __int128 v605;
  uint64_t v606;
  IIO_Reader *Reader_WebP;
  uint64_t *v608;
  unint64_t v609;
  IIO_Reader **v610;
  _QWORD *v611;
  _QWORD *v612;
  uint64_t v613;
  unint64_t v614;
  uint64_t v615;
  unint64_t v616;
  char *v617;
  char *v618;
  char *v619;
  uint64_t v620;
  __int128 v621;
  uint64_t v622;
  uint64_t v623;
  uint64_t *v624;
  unint64_t v625;
  uint64_t *v626;
  _QWORD *v627;
  _QWORD *v628;
  uint64_t v629;
  unint64_t v630;
  uint64_t v631;
  unint64_t v632;
  char *v633;
  char *v634;
  char *v635;
  uint64_t v636;
  __int128 v637;
  uint64_t v638;
  IIO_Reader *Reader_RAD;
  uint64_t *v640;
  unint64_t v641;
  IIO_Reader **v642;
  _QWORD *v643;
  _QWORD *v644;
  uint64_t v645;
  unint64_t v646;
  uint64_t v647;
  unint64_t v648;
  char *v649;
  char *v650;
  char *v651;
  uint64_t v652;
  __int128 v653;
  uint64_t v654;
  IIO_Reader *Reader_PBM;
  uint64_t *v656;
  unint64_t v657;
  IIO_Reader **v658;
  _QWORD *v659;
  _QWORD *v660;
  uint64_t v661;
  unint64_t v662;
  uint64_t v663;
  unint64_t v664;
  char *v665;
  char *v666;
  char *v667;
  uint64_t v668;
  __int128 v669;
  uint64_t v670;
  IIO_Reader *Reader_MPO;
  uint64_t *v672;
  unint64_t v673;
  IIO_Reader **v674;
  _QWORD *v675;
  _QWORD *v676;
  uint64_t v677;
  unint64_t v678;
  uint64_t v679;
  unint64_t v680;
  char *v681;
  char *v682;
  char *v683;
  uint64_t v684;
  __int128 v685;
  uint64_t v686;
  IIO_Reader *Reader_PVR;
  uint64_t *v688;
  unint64_t v689;
  IIO_Reader **v690;
  _QWORD *v691;
  _QWORD *v692;
  uint64_t v693;
  unint64_t v694;
  uint64_t v695;
  unint64_t v696;
  char *v697;
  char *v698;
  char *v699;
  uint64_t v700;
  __int128 v701;
  uint64_t v702;
  IIO_Reader *Reader_DDS_BC;
  uint64_t *v704;
  unint64_t v705;
  IIO_Reader **v706;
  _QWORD *v707;
  _QWORD *v708;
  uint64_t v709;
  unint64_t v710;
  uint64_t v711;
  unint64_t v712;
  char *v713;
  char *v714;
  char *v715;
  uint64_t v716;
  __int128 v717;
  uint64_t v718;
  void *Reader_LibJPEG;
  const __CFArray *v720;
  const __CFDictionary *ValueAtIndex;
  IIOReader_RawCamera *v722;
  uint64_t *v723;
  unint64_t v724;
  IIOReader_RawCamera **v725;
  _QWORD *v726;
  _QWORD *v727;
  uint64_t v728;
  unint64_t v729;
  unint64_t v730;
  unint64_t v731;
  char *v732;
  char *v733;
  char *v734;
  uint64_t v735;
  __int128 v736;
  char *v737;
  uint64_t *v738;
  unint64_t v739;
  _QWORD *v740;
  _QWORD *v741;
  _QWORD *v742;
  uint64_t v743;
  unint64_t v744;
  uint64_t v745;
  unint64_t v746;
  char *v747;
  char *v748;
  char *v749;
  uint64_t v750;
  __int128 v751;
  uint64_t v752;
  IIOArray *v753;
  IIOArray *v754;
  unsigned int Count;
  uint64_t v756;
  const void *v757;
  _QWORD *v758;
  _QWORD *v759;
  _QWORD *v760;
  uint64_t v761;
  uint64_t v762;
  IIO_Reader **v763;
  IIO_Reader **v764;
  unint64_t v765;
  IIOArray *v766;
  _QWORD v767[3];
  _QWORD v768[6];
  _QWORD v769[6];
  uint64_t v770;
  uint64_t v771;
  uint64_t *v772;
  uint64_t v773;
  uint64_t v774;
  uint64_t v775;
  __int128 v776;
  char *v777;
  char *v778;
  char __path[72];
  uint64_t v780;

  v780 = *MEMORY[0x1E0C80C00];
  kdebug_trace();
  v771 = 0;
  v772 = &v771;
  v773 = 0x2000000000;
  v774 = 0;
  IIOInitDebugFlags();
  v770 = 0;
  if (IIO_OSAppleInternalBuild() && (dyld_process_is_restricted() & 1) == 0)
    v2 = getenv("RAWCAMERA_BUNDLE_PATH");
  else
    v2 = 0;
  if ((gIIODebugFlags & 0x8000000) == 0)
  {
    if (v2 && (v3 = dlopen(v2, 257)) != 0
      || (v3 = dlopen("/System/Library/CoreServices/RawCamera.bundle/RawCamera", 257)) != 0
      || (v3 = dlopen("/System/Library/CoreServices/RawCamera.bundle/Contents/MacOS/RawCamera", 257)) != 0)
    {
      v4 = dlsym(v3, RawCamera_CopyRawPluginsInfoArray);
      if (v4)
      {
        v5 = (const __CFArray *)((uint64_t (*)(_QWORD, _QWORD))v4)(0, 0);
        if (v5)
        {
          v766 = (IIOArray *)operator new();
          IIOArray::IIOArray(v766, v5);
          CFRelease(v5);
          v6 = 0;
LABEL_20:
          gReadMakerNoteProps = dlsym(v3, "ReadMakerNoteProps");
          goto LABEL_23;
        }
      }
      else
      {
        v7 = dlerror();
        LogError("buildPluginList", 884, "*** ERROR: failed to lookup 'CopyRawPluginsInfoArray' - '%s'\n", v7);
      }
      v8 = (uint64_t (*)(char *, uint64_t *))dlsym(v3, "GetRawPluginsInfo");
      if (v8)
      {
        v6 = v8((char *)&v770 + 4, &v770);
        if (v6)
        {
LABEL_19:
          v766 = 0;
          goto LABEL_20;
        }
      }
      else
      {
        v9 = dlerror();
        LogError("buildPluginList", 898, "*** ERROR: failed to lookup 'GetRawPluginsInfo' - '%s'\n", v9);
      }
      LogError("buildPluginList", 903, "*** ERROR: failed to load 'RawCamera' plugins\n");
      v6 = 0;
      goto LABEL_19;
    }
    v10 = dlerror();
    LogError("buildPluginList", 865, "*** ERROR: failed to load 'RawCamera' bundle: '%s'\n", v10);
  }
  v766 = 0;
  v6 = 0;
LABEL_23:
  if (IIO_ReaderHandler::UseAppleJPEG(void)::appleJPEGCheck != -1)
    dispatch_once(&IIO_ReaderHandler::UseAppleJPEG(void)::appleJPEGCheck, &__block_literal_global_28_0);
  if (IIO_ReaderHandler::UseAppleJPEG(void)::gUseAppleJPEGPlugin)
    Reader_AppleJPEG = CreateReader_AppleJPEG();
  else
    Reader_AppleJPEG = CreateReader_LibJPEG();
  v12 = v772;
  v772[3] = (uint64_t)Reader_AppleJPEG;
  if (Reader_AppleJPEG)
  {
    v13 = *((_QWORD *)this + 4);
    v14 = (IIO_Reader **)*((_QWORD *)this + 3);
    if ((unint64_t)v14 >= v13)
    {
      v16 = (_QWORD *)*((_QWORD *)this + 2);
      v17 = v14 - (IIO_Reader **)v16;
      v18 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61)
        goto LABEL_891;
      v19 = v13 - (_QWORD)v16;
      if (v19 >> 2 > v18)
        v18 = v19 >> 2;
      if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
        v20 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v20 = v18;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v20)
      {
        v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v20);
        v16 = (_QWORD *)*((_QWORD *)this + 2);
        v14 = (IIO_Reader **)*((_QWORD *)this + 3);
      }
      else
      {
        v21 = 0;
      }
      v22 = &v21[8 * v17];
      v23 = &v21[8 * v20];
      *(_QWORD *)&__path[24] = v23;
      *(_QWORD *)v22 = v12[3];
      *(_QWORD *)&__path[16] = v22 + 8;
      if (v14 == v16)
      {
        v15 = v22 + 8;
      }
      else
      {
        do
        {
          v24 = (uint64_t)*--v14;
          *v14 = 0;
          *((_QWORD *)v22 - 1) = v24;
          v22 -= 8;
        }
        while (v14 != v16);
        v15 = *(_QWORD **)&__path[16];
        v23 = *(char **)&__path[24];
      }
      v25 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v22;
      *((_QWORD *)this + 3) = v15;
      *(_OWORD *)&__path[8] = v25;
      v26 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v23;
      *(_QWORD *)&__path[24] = v26;
      *(_QWORD *)__path = v25;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v14 = Reader_AppleJPEG;
      v15 = v14 + 1;
    }
    *((_QWORD *)this + 3) = v15;
  }
  Reader_PNG = CreateReader_PNG();
  v28 = v772;
  v772[3] = (uint64_t)Reader_PNG;
  if (Reader_PNG)
  {
    v29 = *((_QWORD *)this + 4);
    v30 = (IIO_Reader **)*((_QWORD *)this + 3);
    if ((unint64_t)v30 >= v29)
    {
      v32 = (_QWORD *)*((_QWORD *)this + 2);
      v33 = v30 - (IIO_Reader **)v32;
      v34 = v33 + 1;
      if ((unint64_t)(v33 + 1) >> 61)
        goto LABEL_891;
      v35 = v29 - (_QWORD)v32;
      if (v35 >> 2 > v34)
        v34 = v35 >> 2;
      if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF8)
        v36 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v36 = v34;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v36)
      {
        v37 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v36);
        v32 = (_QWORD *)*((_QWORD *)this + 2);
        v30 = (IIO_Reader **)*((_QWORD *)this + 3);
      }
      else
      {
        v37 = 0;
      }
      v38 = &v37[8 * v33];
      v39 = &v37[8 * v36];
      *(_QWORD *)&__path[24] = v39;
      *(_QWORD *)v38 = v28[3];
      *(_QWORD *)&__path[16] = v38 + 8;
      if (v30 == v32)
      {
        v31 = v38 + 8;
      }
      else
      {
        do
        {
          v40 = (uint64_t)*--v30;
          *v30 = 0;
          *((_QWORD *)v38 - 1) = v40;
          v38 -= 8;
        }
        while (v30 != v32);
        v31 = *(_QWORD **)&__path[16];
        v39 = *(char **)&__path[24];
      }
      v41 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v38;
      *((_QWORD *)this + 3) = v31;
      *(_OWORD *)&__path[8] = v41;
      v42 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v39;
      *(_QWORD *)&__path[24] = v42;
      *(_QWORD *)__path = v41;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v30 = Reader_PNG;
      v31 = v30 + 1;
    }
    *((_QWORD *)this + 3) = v31;
  }
  Reader_GIF = CreateReader_GIF();
  v44 = v772;
  v772[3] = (uint64_t)Reader_GIF;
  if (Reader_GIF)
  {
    v45 = *((_QWORD *)this + 4);
    v46 = (IIO_Reader **)*((_QWORD *)this + 3);
    if ((unint64_t)v46 >= v45)
    {
      v48 = (_QWORD *)*((_QWORD *)this + 2);
      v49 = v46 - (IIO_Reader **)v48;
      v50 = v49 + 1;
      if ((unint64_t)(v49 + 1) >> 61)
        goto LABEL_891;
      v51 = v45 - (_QWORD)v48;
      if (v51 >> 2 > v50)
        v50 = v51 >> 2;
      if ((unint64_t)v51 >= 0x7FFFFFFFFFFFFFF8)
        v52 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v52 = v50;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v52)
      {
        v53 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v52);
        v48 = (_QWORD *)*((_QWORD *)this + 2);
        v46 = (IIO_Reader **)*((_QWORD *)this + 3);
      }
      else
      {
        v53 = 0;
      }
      v54 = &v53[8 * v49];
      v55 = &v53[8 * v52];
      *(_QWORD *)&__path[24] = v55;
      *(_QWORD *)v54 = v44[3];
      *(_QWORD *)&__path[16] = v54 + 8;
      if (v46 == v48)
      {
        v47 = v54 + 8;
      }
      else
      {
        do
        {
          v56 = (uint64_t)*--v46;
          *v46 = 0;
          *((_QWORD *)v54 - 1) = v56;
          v54 -= 8;
        }
        while (v46 != v48);
        v47 = *(_QWORD **)&__path[16];
        v55 = *(char **)&__path[24];
      }
      v57 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v54;
      *((_QWORD *)this + 3) = v47;
      *(_OWORD *)&__path[8] = v57;
      v58 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v55;
      *(_QWORD *)&__path[24] = v58;
      *(_QWORD *)__path = v57;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v46 = Reader_GIF;
      v47 = v46 + 1;
    }
    *((_QWORD *)this + 3) = v47;
  }
  if (v766)
  {
    v769[0] = MEMORY[0x1E0C809B0];
    v769[1] = 0x40000000;
    v769[2] = ___ZN17IIO_ReaderHandler15buildPluginListEv_block_invoke;
    v769[3] = &unk_1E1BC9680;
    v769[4] = &v771;
    v769[5] = this;
    IIOArray::enumerate((uint64_t)v766, (uint64_t)v769);
  }
  else if ((int)v770 >= 1)
  {
    v59 = 0;
    v60 = (uint64_t **)((char *)this + 16);
    do
    {
      v61 = operator new();
      IIOReader_RawCamera::IIOReader_RawCamera(v61, *(_QWORD *)(v6 + 8 * v59));
      v62 = v772;
      v772[3] = v61;
      v64 = (uint64_t *)*((_QWORD *)this + 3);
      v63 = *((_QWORD *)this + 4);
      if ((unint64_t)v64 >= v63)
      {
        v66 = *v60;
        v67 = v64 - *v60;
        v68 = v67 + 1;
        if ((unint64_t)(v67 + 1) >> 61)
          std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
        v69 = v63 - (_QWORD)v66;
        if (v69 >> 2 > v68)
          v68 = v69 >> 2;
        if ((unint64_t)v69 >= 0x7FFFFFFFFFFFFFF8)
          v70 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v70 = v68;
        *(_QWORD *)&__path[32] = (char *)this + 32;
        if (v70)
        {
          v71 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v70);
          v66 = (uint64_t *)*((_QWORD *)this + 2);
          v64 = (uint64_t *)*((_QWORD *)this + 3);
        }
        else
        {
          v71 = 0;
        }
        v72 = &v71[8 * v67];
        v73 = &v71[8 * v70];
        *(_QWORD *)&__path[24] = v73;
        *(_QWORD *)v72 = v62[3];
        *(_QWORD *)&__path[16] = v72 + 8;
        if (v64 == v66)
        {
          v65 = v72 + 8;
        }
        else
        {
          do
          {
            v74 = *--v64;
            *v64 = 0;
            *((_QWORD *)v72 - 1) = v74;
            v72 -= 8;
          }
          while (v64 != v66);
          v65 = *(_QWORD **)&__path[16];
          v73 = *(char **)&__path[24];
        }
        v75 = *((_OWORD *)this + 1);
        *((_QWORD *)this + 2) = v72;
        *((_QWORD *)this + 3) = v65;
        *(_OWORD *)&__path[8] = v75;
        v76 = *((_QWORD *)this + 4);
        *((_QWORD *)this + 4) = v73;
        *(_QWORD *)&__path[24] = v76;
        *(_QWORD *)__path = v75;
        std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
      }
      else
      {
        *v64 = v61;
        v65 = v64 + 1;
      }
      *((_QWORD *)this + 3) = v65;
      ++v59;
    }
    while (v59 < (int)v770);
  }
  Reader_TIFF = CreateReader_TIFF();
  v78 = v772;
  v772[3] = (uint64_t)Reader_TIFF;
  if (Reader_TIFF)
  {
    v79 = *((_QWORD *)this + 4);
    v80 = (IIO_Reader **)*((_QWORD *)this + 3);
    if ((unint64_t)v80 >= v79)
    {
      v82 = (_QWORD *)*((_QWORD *)this + 2);
      v83 = v80 - (IIO_Reader **)v82;
      v84 = v83 + 1;
      if ((unint64_t)(v83 + 1) >> 61)
        goto LABEL_891;
      v85 = v79 - (_QWORD)v82;
      if (v85 >> 2 > v84)
        v84 = v85 >> 2;
      if ((unint64_t)v85 >= 0x7FFFFFFFFFFFFFF8)
        v86 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v86 = v84;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v86)
      {
        v87 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v86);
        v82 = (_QWORD *)*((_QWORD *)this + 2);
        v80 = (IIO_Reader **)*((_QWORD *)this + 3);
      }
      else
      {
        v87 = 0;
      }
      v88 = &v87[8 * v83];
      v89 = &v87[8 * v86];
      *(_QWORD *)&__path[24] = v89;
      *(_QWORD *)v88 = v78[3];
      *(_QWORD *)&__path[16] = v88 + 8;
      if (v80 == v82)
      {
        v81 = v88 + 8;
      }
      else
      {
        do
        {
          v90 = (uint64_t)*--v80;
          *v80 = 0;
          *((_QWORD *)v88 - 1) = v90;
          v88 -= 8;
        }
        while (v80 != v82);
        v81 = *(_QWORD **)&__path[16];
        v89 = *(char **)&__path[24];
      }
      v91 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v88;
      *((_QWORD *)this + 3) = v81;
      *(_OWORD *)&__path[8] = v91;
      v92 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v89;
      *(_QWORD *)&__path[24] = v92;
      *(_QWORD *)__path = v91;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v80 = Reader_TIFF;
      v81 = v80 + 1;
    }
    *((_QWORD *)this + 3) = v81;
  }
  Reader_JP2 = CreateReader_JP2();
  v94 = v772;
  v772[3] = (uint64_t)Reader_JP2;
  if (Reader_JP2)
  {
    v95 = *((_QWORD *)this + 4);
    v96 = (IIO_Reader **)*((_QWORD *)this + 3);
    if ((unint64_t)v96 >= v95)
    {
      v98 = (_QWORD *)*((_QWORD *)this + 2);
      v99 = v96 - (IIO_Reader **)v98;
      v100 = v99 + 1;
      if ((unint64_t)(v99 + 1) >> 61)
        goto LABEL_891;
      v101 = v95 - (_QWORD)v98;
      if (v101 >> 2 > v100)
        v100 = v101 >> 2;
      if ((unint64_t)v101 >= 0x7FFFFFFFFFFFFFF8)
        v102 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v102 = v100;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v102)
      {
        v103 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v102);
        v98 = (_QWORD *)*((_QWORD *)this + 2);
        v96 = (IIO_Reader **)*((_QWORD *)this + 3);
      }
      else
      {
        v103 = 0;
      }
      v104 = &v103[8 * v99];
      v105 = &v103[8 * v102];
      *(_QWORD *)&__path[24] = v105;
      *(_QWORD *)v104 = v94[3];
      *(_QWORD *)&__path[16] = v104 + 8;
      if (v96 == v98)
      {
        v97 = v104 + 8;
      }
      else
      {
        do
        {
          v106 = (uint64_t)*--v96;
          *v96 = 0;
          *((_QWORD *)v104 - 1) = v106;
          v104 -= 8;
        }
        while (v96 != v98);
        v97 = *(_QWORD **)&__path[16];
        v105 = *(char **)&__path[24];
      }
      v107 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v104;
      *((_QWORD *)this + 3) = v97;
      *(_OWORD *)&__path[8] = v107;
      v108 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v105;
      *(_QWORD *)&__path[24] = v108;
      *(_QWORD *)__path = v107;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v96 = Reader_JP2;
      v97 = v96 + 1;
    }
    *((_QWORD *)this + 3) = v97;
  }
  Reader_ATX = CreateReader_ATX();
  v110 = v772;
  v772[3] = (uint64_t)Reader_ATX;
  if (Reader_ATX)
  {
    v111 = *((_QWORD *)this + 4);
    v112 = (IIO_Reader **)*((_QWORD *)this + 3);
    if ((unint64_t)v112 >= v111)
    {
      v114 = (_QWORD *)*((_QWORD *)this + 2);
      v115 = v112 - (IIO_Reader **)v114;
      v116 = v115 + 1;
      if ((unint64_t)(v115 + 1) >> 61)
        goto LABEL_891;
      v117 = v111 - (_QWORD)v114;
      if (v117 >> 2 > v116)
        v116 = v117 >> 2;
      if ((unint64_t)v117 >= 0x7FFFFFFFFFFFFFF8)
        v118 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v118 = v116;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v118)
      {
        v119 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v118);
        v114 = (_QWORD *)*((_QWORD *)this + 2);
        v112 = (IIO_Reader **)*((_QWORD *)this + 3);
      }
      else
      {
        v119 = 0;
      }
      v120 = &v119[8 * v115];
      v121 = &v119[8 * v118];
      *(_QWORD *)&__path[24] = v121;
      *(_QWORD *)v120 = v110[3];
      *(_QWORD *)&__path[16] = v120 + 8;
      if (v112 == v114)
      {
        v113 = v120 + 8;
      }
      else
      {
        do
        {
          v122 = (uint64_t)*--v112;
          *v112 = 0;
          *((_QWORD *)v120 - 1) = v122;
          v120 -= 8;
        }
        while (v112 != v114);
        v113 = *(_QWORD **)&__path[16];
        v121 = *(char **)&__path[24];
      }
      v123 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v120;
      *((_QWORD *)this + 3) = v113;
      *(_OWORD *)&__path[8] = v123;
      v124 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v121;
      *(_QWORD *)&__path[24] = v124;
      *(_QWORD *)__path = v123;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v112 = Reader_ATX;
      v113 = v112 + 1;
    }
    *((_QWORD *)this + 3) = v113;
  }
  Reader_ASTC = CreateReader_ASTC();
  v126 = v772;
  v772[3] = (uint64_t)Reader_ASTC;
  if (Reader_ASTC)
  {
    v127 = *((_QWORD *)this + 4);
    v128 = (IIO_Reader **)*((_QWORD *)this + 3);
    if ((unint64_t)v128 >= v127)
    {
      v130 = (_QWORD *)*((_QWORD *)this + 2);
      v131 = v128 - (IIO_Reader **)v130;
      v132 = v131 + 1;
      if ((unint64_t)(v131 + 1) >> 61)
        goto LABEL_891;
      v133 = v127 - (_QWORD)v130;
      if (v133 >> 2 > v132)
        v132 = v133 >> 2;
      if ((unint64_t)v133 >= 0x7FFFFFFFFFFFFFF8)
        v134 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v134 = v132;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v134)
      {
        v135 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v134);
        v130 = (_QWORD *)*((_QWORD *)this + 2);
        v128 = (IIO_Reader **)*((_QWORD *)this + 3);
      }
      else
      {
        v135 = 0;
      }
      v136 = &v135[8 * v131];
      v137 = &v135[8 * v134];
      *(_QWORD *)&__path[24] = v137;
      *(_QWORD *)v136 = v126[3];
      *(_QWORD *)&__path[16] = v136 + 8;
      if (v128 == v130)
      {
        v129 = v136 + 8;
      }
      else
      {
        do
        {
          v138 = (uint64_t)*--v128;
          *v128 = 0;
          *((_QWORD *)v136 - 1) = v138;
          v136 -= 8;
        }
        while (v128 != v130);
        v129 = *(_QWORD **)&__path[16];
        v137 = *(char **)&__path[24];
      }
      v139 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v136;
      *((_QWORD *)this + 3) = v129;
      *(_OWORD *)&__path[8] = v139;
      v140 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v137;
      *(_QWORD *)&__path[24] = v140;
      *(_QWORD *)__path = v139;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v128 = Reader_ASTC;
      v129 = v128 + 1;
    }
    *((_QWORD *)this + 3) = v129;
  }
  Reader_KTX_ASTC = CreateReader_KTX_ASTC();
  v142 = v772;
  v772[3] = (uint64_t)Reader_KTX_ASTC;
  if (Reader_KTX_ASTC)
  {
    v143 = *((_QWORD *)this + 4);
    v144 = (IIO_Reader **)*((_QWORD *)this + 3);
    if ((unint64_t)v144 >= v143)
    {
      v146 = (_QWORD *)*((_QWORD *)this + 2);
      v147 = v144 - (IIO_Reader **)v146;
      v148 = v147 + 1;
      if ((unint64_t)(v147 + 1) >> 61)
        goto LABEL_891;
      v149 = v143 - (_QWORD)v146;
      if (v149 >> 2 > v148)
        v148 = v149 >> 2;
      if ((unint64_t)v149 >= 0x7FFFFFFFFFFFFFF8)
        v150 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v150 = v148;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v150)
      {
        v151 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v150);
        v146 = (_QWORD *)*((_QWORD *)this + 2);
        v144 = (IIO_Reader **)*((_QWORD *)this + 3);
      }
      else
      {
        v151 = 0;
      }
      v152 = &v151[8 * v147];
      v153 = &v151[8 * v150];
      *(_QWORD *)&__path[24] = v153;
      *(_QWORD *)v152 = v142[3];
      *(_QWORD *)&__path[16] = v152 + 8;
      if (v144 == v146)
      {
        v145 = v152 + 8;
      }
      else
      {
        do
        {
          v154 = (uint64_t)*--v144;
          *v144 = 0;
          *((_QWORD *)v152 - 1) = v154;
          v152 -= 8;
        }
        while (v144 != v146);
        v145 = *(_QWORD **)&__path[16];
        v153 = *(char **)&__path[24];
      }
      v155 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v152;
      *((_QWORD *)this + 3) = v145;
      *(_OWORD *)&__path[8] = v155;
      v156 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v153;
      *(_QWORD *)&__path[24] = v156;
      *(_QWORD *)__path = v155;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v144 = Reader_KTX_ASTC;
      v145 = v144 + 1;
    }
    *((_QWORD *)this + 3) = v145;
  }
  Reader_KTX_BC = CreateReader_KTX_BC();
  v158 = v772;
  v772[3] = (uint64_t)Reader_KTX_BC;
  if (Reader_KTX_BC)
  {
    v159 = *((_QWORD *)this + 4);
    v160 = (IIO_Reader **)*((_QWORD *)this + 3);
    if ((unint64_t)v160 >= v159)
    {
      v162 = (_QWORD *)*((_QWORD *)this + 2);
      v163 = v160 - (IIO_Reader **)v162;
      v164 = v163 + 1;
      if ((unint64_t)(v163 + 1) >> 61)
        goto LABEL_891;
      v165 = v159 - (_QWORD)v162;
      if (v165 >> 2 > v164)
        v164 = v165 >> 2;
      if ((unint64_t)v165 >= 0x7FFFFFFFFFFFFFF8)
        v166 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v166 = v164;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v166)
      {
        v167 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v166);
        v162 = (_QWORD *)*((_QWORD *)this + 2);
        v160 = (IIO_Reader **)*((_QWORD *)this + 3);
      }
      else
      {
        v167 = 0;
      }
      v168 = &v167[8 * v163];
      v169 = &v167[8 * v166];
      *(_QWORD *)&__path[24] = v169;
      *(_QWORD *)v168 = v158[3];
      *(_QWORD *)&__path[16] = v168 + 8;
      if (v160 == v162)
      {
        v161 = v168 + 8;
      }
      else
      {
        do
        {
          v170 = (uint64_t)*--v160;
          *v160 = 0;
          *((_QWORD *)v168 - 1) = v170;
          v168 -= 8;
        }
        while (v160 != v162);
        v161 = *(_QWORD **)&__path[16];
        v169 = *(char **)&__path[24];
      }
      v171 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v168;
      *((_QWORD *)this + 3) = v161;
      *(_OWORD *)&__path[8] = v171;
      v172 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v169;
      *(_QWORD *)&__path[24] = v172;
      *(_QWORD *)__path = v171;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v160 = Reader_KTX_BC;
      v161 = v160 + 1;
    }
    *((_QWORD *)this + 3) = v161;
  }
  Reader_KTX_ETC = CreateReader_KTX_ETC();
  v174 = v772;
  v772[3] = (uint64_t)Reader_KTX_ETC;
  if (Reader_KTX_ETC)
  {
    v175 = *((_QWORD *)this + 4);
    v176 = (IIO_Reader **)*((_QWORD *)this + 3);
    if ((unint64_t)v176 >= v175)
    {
      v178 = (_QWORD *)*((_QWORD *)this + 2);
      v179 = v176 - (IIO_Reader **)v178;
      v180 = v179 + 1;
      if ((unint64_t)(v179 + 1) >> 61)
        goto LABEL_891;
      v181 = v175 - (_QWORD)v178;
      if (v181 >> 2 > v180)
        v180 = v181 >> 2;
      if ((unint64_t)v181 >= 0x7FFFFFFFFFFFFFF8)
        v182 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v182 = v180;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v182)
      {
        v183 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v182);
        v178 = (_QWORD *)*((_QWORD *)this + 2);
        v176 = (IIO_Reader **)*((_QWORD *)this + 3);
      }
      else
      {
        v183 = 0;
      }
      v184 = &v183[8 * v179];
      v185 = &v183[8 * v182];
      *(_QWORD *)&__path[24] = v185;
      *(_QWORD *)v184 = v174[3];
      *(_QWORD *)&__path[16] = v184 + 8;
      if (v176 == v178)
      {
        v177 = v184 + 8;
      }
      else
      {
        do
        {
          v186 = (uint64_t)*--v176;
          *v176 = 0;
          *((_QWORD *)v184 - 1) = v186;
          v184 -= 8;
        }
        while (v176 != v178);
        v177 = *(_QWORD **)&__path[16];
        v185 = *(char **)&__path[24];
      }
      v187 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v184;
      *((_QWORD *)this + 3) = v177;
      *(_OWORD *)&__path[8] = v187;
      v188 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v185;
      *(_QWORD *)&__path[24] = v188;
      *(_QWORD *)__path = v187;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v176 = Reader_KTX_ETC;
      v177 = v176 + 1;
    }
    *((_QWORD *)this + 3) = v177;
  }
  Reader_KTX_PVR = CreateReader_KTX_PVR();
  v190 = v772;
  v772[3] = (uint64_t)Reader_KTX_PVR;
  if (Reader_KTX_PVR)
  {
    v191 = *((_QWORD *)this + 4);
    v192 = (IIO_Reader **)*((_QWORD *)this + 3);
    if ((unint64_t)v192 >= v191)
    {
      v194 = (_QWORD *)*((_QWORD *)this + 2);
      v195 = v192 - (IIO_Reader **)v194;
      v196 = v195 + 1;
      if ((unint64_t)(v195 + 1) >> 61)
        goto LABEL_891;
      v197 = v191 - (_QWORD)v194;
      if (v197 >> 2 > v196)
        v196 = v197 >> 2;
      if ((unint64_t)v197 >= 0x7FFFFFFFFFFFFFF8)
        v198 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v198 = v196;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v198)
      {
        v199 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v198);
        v194 = (_QWORD *)*((_QWORD *)this + 2);
        v192 = (IIO_Reader **)*((_QWORD *)this + 3);
      }
      else
      {
        v199 = 0;
      }
      v200 = &v199[8 * v195];
      v201 = &v199[8 * v198];
      *(_QWORD *)&__path[24] = v201;
      *(_QWORD *)v200 = v190[3];
      *(_QWORD *)&__path[16] = v200 + 8;
      if (v192 == v194)
      {
        v193 = v200 + 8;
      }
      else
      {
        do
        {
          v202 = (uint64_t)*--v192;
          *v192 = 0;
          *((_QWORD *)v200 - 1) = v202;
          v200 -= 8;
        }
        while (v192 != v194);
        v193 = *(_QWORD **)&__path[16];
        v201 = *(char **)&__path[24];
      }
      v203 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v200;
      *((_QWORD *)this + 3) = v193;
      *(_OWORD *)&__path[8] = v203;
      v204 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v201;
      *(_QWORD *)&__path[24] = v204;
      *(_QWORD *)__path = v203;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v192 = Reader_KTX_PVR;
      v193 = v192 + 1;
    }
    *((_QWORD *)this + 3) = v193;
  }
  Reader_KTX = CreateReader_KTX();
  v206 = v772;
  v772[3] = (uint64_t)Reader_KTX;
  if (Reader_KTX)
  {
    v207 = *((_QWORD *)this + 4);
    v208 = (IIO_Reader **)*((_QWORD *)this + 3);
    if ((unint64_t)v208 >= v207)
    {
      v210 = (_QWORD *)*((_QWORD *)this + 2);
      v211 = v208 - (IIO_Reader **)v210;
      v212 = v211 + 1;
      if ((unint64_t)(v211 + 1) >> 61)
        goto LABEL_891;
      v213 = v207 - (_QWORD)v210;
      if (v213 >> 2 > v212)
        v212 = v213 >> 2;
      if ((unint64_t)v213 >= 0x7FFFFFFFFFFFFFF8)
        v214 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v214 = v212;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v214)
      {
        v215 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v214);
        v210 = (_QWORD *)*((_QWORD *)this + 2);
        v208 = (IIO_Reader **)*((_QWORD *)this + 3);
      }
      else
      {
        v215 = 0;
      }
      v216 = &v215[8 * v211];
      v217 = &v215[8 * v214];
      *(_QWORD *)&__path[24] = v217;
      *(_QWORD *)v216 = v206[3];
      *(_QWORD *)&__path[16] = v216 + 8;
      if (v208 == v210)
      {
        v209 = v216 + 8;
      }
      else
      {
        do
        {
          v218 = (uint64_t)*--v208;
          *v208 = 0;
          *((_QWORD *)v216 - 1) = v218;
          v216 -= 8;
        }
        while (v208 != v210);
        v209 = *(_QWORD **)&__path[16];
        v217 = *(char **)&__path[24];
      }
      v219 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v216;
      *((_QWORD *)this + 3) = v209;
      *(_OWORD *)&__path[8] = v219;
      v220 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v217;
      *(_QWORD *)&__path[24] = v220;
      *(_QWORD *)__path = v219;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v208 = Reader_KTX;
      v209 = v208 + 1;
    }
    *((_QWORD *)this + 3) = v209;
  }
  Reader_KTX2_ASTC = CreateReader_KTX2_ASTC();
  v222 = v772;
  v772[3] = (uint64_t)Reader_KTX2_ASTC;
  if (Reader_KTX2_ASTC)
  {
    v223 = *((_QWORD *)this + 4);
    v224 = (IIO_Reader **)*((_QWORD *)this + 3);
    if ((unint64_t)v224 >= v223)
    {
      v226 = (_QWORD *)*((_QWORD *)this + 2);
      v227 = v224 - (IIO_Reader **)v226;
      v228 = v227 + 1;
      if ((unint64_t)(v227 + 1) >> 61)
        goto LABEL_891;
      v229 = v223 - (_QWORD)v226;
      if (v229 >> 2 > v228)
        v228 = v229 >> 2;
      if ((unint64_t)v229 >= 0x7FFFFFFFFFFFFFF8)
        v230 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v230 = v228;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v230)
      {
        v231 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v230);
        v226 = (_QWORD *)*((_QWORD *)this + 2);
        v224 = (IIO_Reader **)*((_QWORD *)this + 3);
      }
      else
      {
        v231 = 0;
      }
      v232 = &v231[8 * v227];
      v233 = &v231[8 * v230];
      *(_QWORD *)&__path[24] = v233;
      *(_QWORD *)v232 = v222[3];
      *(_QWORD *)&__path[16] = v232 + 8;
      if (v224 == v226)
      {
        v225 = v232 + 8;
      }
      else
      {
        do
        {
          v234 = (uint64_t)*--v224;
          *v224 = 0;
          *((_QWORD *)v232 - 1) = v234;
          v232 -= 8;
        }
        while (v224 != v226);
        v225 = *(_QWORD **)&__path[16];
        v233 = *(char **)&__path[24];
      }
      v235 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v232;
      *((_QWORD *)this + 3) = v225;
      *(_OWORD *)&__path[8] = v235;
      v236 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v233;
      *(_QWORD *)&__path[24] = v236;
      *(_QWORD *)__path = v235;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v224 = Reader_KTX2_ASTC;
      v225 = v224 + 1;
    }
    *((_QWORD *)this + 3) = v225;
  }
  Reader_KTX2_BC = CreateReader_KTX2_BC();
  v238 = v772;
  v772[3] = (uint64_t)Reader_KTX2_BC;
  if (Reader_KTX2_BC)
  {
    v239 = *((_QWORD *)this + 4);
    v240 = (IIO_Reader **)*((_QWORD *)this + 3);
    if ((unint64_t)v240 >= v239)
    {
      v242 = (_QWORD *)*((_QWORD *)this + 2);
      v243 = v240 - (IIO_Reader **)v242;
      v244 = v243 + 1;
      if ((unint64_t)(v243 + 1) >> 61)
        goto LABEL_891;
      v245 = v239 - (_QWORD)v242;
      if (v245 >> 2 > v244)
        v244 = v245 >> 2;
      if ((unint64_t)v245 >= 0x7FFFFFFFFFFFFFF8)
        v246 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v246 = v244;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v246)
      {
        v247 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v246);
        v242 = (_QWORD *)*((_QWORD *)this + 2);
        v240 = (IIO_Reader **)*((_QWORD *)this + 3);
      }
      else
      {
        v247 = 0;
      }
      v248 = &v247[8 * v243];
      v249 = &v247[8 * v246];
      *(_QWORD *)&__path[24] = v249;
      *(_QWORD *)v248 = v238[3];
      *(_QWORD *)&__path[16] = v248 + 8;
      if (v240 == v242)
      {
        v241 = v248 + 8;
      }
      else
      {
        do
        {
          v250 = (uint64_t)*--v240;
          *v240 = 0;
          *((_QWORD *)v248 - 1) = v250;
          v248 -= 8;
        }
        while (v240 != v242);
        v241 = *(_QWORD **)&__path[16];
        v249 = *(char **)&__path[24];
      }
      v251 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v248;
      *((_QWORD *)this + 3) = v241;
      *(_OWORD *)&__path[8] = v251;
      v252 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v249;
      *(_QWORD *)&__path[24] = v252;
      *(_QWORD *)__path = v251;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v240 = Reader_KTX2_BC;
      v241 = v240 + 1;
    }
    *((_QWORD *)this + 3) = v241;
  }
  Reader_KTX2_ETC = CreateReader_KTX2_ETC();
  v254 = v772;
  v772[3] = (uint64_t)Reader_KTX2_ETC;
  if (Reader_KTX2_ETC)
  {
    v255 = *((_QWORD *)this + 4);
    v256 = (IIO_Reader **)*((_QWORD *)this + 3);
    if ((unint64_t)v256 >= v255)
    {
      v258 = (_QWORD *)*((_QWORD *)this + 2);
      v259 = v256 - (IIO_Reader **)v258;
      v260 = v259 + 1;
      if ((unint64_t)(v259 + 1) >> 61)
        goto LABEL_891;
      v261 = v255 - (_QWORD)v258;
      if (v261 >> 2 > v260)
        v260 = v261 >> 2;
      if ((unint64_t)v261 >= 0x7FFFFFFFFFFFFFF8)
        v262 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v262 = v260;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v262)
      {
        v263 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v262);
        v258 = (_QWORD *)*((_QWORD *)this + 2);
        v256 = (IIO_Reader **)*((_QWORD *)this + 3);
      }
      else
      {
        v263 = 0;
      }
      v264 = &v263[8 * v259];
      v265 = &v263[8 * v262];
      *(_QWORD *)&__path[24] = v265;
      *(_QWORD *)v264 = v254[3];
      *(_QWORD *)&__path[16] = v264 + 8;
      if (v256 == v258)
      {
        v257 = v264 + 8;
      }
      else
      {
        do
        {
          v266 = (uint64_t)*--v256;
          *v256 = 0;
          *((_QWORD *)v264 - 1) = v266;
          v264 -= 8;
        }
        while (v256 != v258);
        v257 = *(_QWORD **)&__path[16];
        v265 = *(char **)&__path[24];
      }
      v267 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v264;
      *((_QWORD *)this + 3) = v257;
      *(_OWORD *)&__path[8] = v267;
      v268 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v265;
      *(_QWORD *)&__path[24] = v268;
      *(_QWORD *)__path = v267;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v256 = Reader_KTX2_ETC;
      v257 = v256 + 1;
    }
    *((_QWORD *)this + 3) = v257;
  }
  Reader_KTX2_PVR = CreateReader_KTX2_PVR();
  v270 = v772;
  v772[3] = (uint64_t)Reader_KTX2_PVR;
  if (Reader_KTX2_PVR)
  {
    v271 = *((_QWORD *)this + 4);
    v272 = (IIO_Reader **)*((_QWORD *)this + 3);
    if ((unint64_t)v272 >= v271)
    {
      v274 = (_QWORD *)*((_QWORD *)this + 2);
      v275 = v272 - (IIO_Reader **)v274;
      v276 = v275 + 1;
      if ((unint64_t)(v275 + 1) >> 61)
        goto LABEL_891;
      v277 = v271 - (_QWORD)v274;
      if (v277 >> 2 > v276)
        v276 = v277 >> 2;
      if ((unint64_t)v277 >= 0x7FFFFFFFFFFFFFF8)
        v278 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v278 = v276;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v278)
      {
        v279 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v278);
        v274 = (_QWORD *)*((_QWORD *)this + 2);
        v272 = (IIO_Reader **)*((_QWORD *)this + 3);
      }
      else
      {
        v279 = 0;
      }
      v280 = &v279[8 * v275];
      v281 = &v279[8 * v278];
      *(_QWORD *)&__path[24] = v281;
      *(_QWORD *)v280 = v270[3];
      *(_QWORD *)&__path[16] = v280 + 8;
      if (v272 == v274)
      {
        v273 = v280 + 8;
      }
      else
      {
        do
        {
          v282 = (uint64_t)*--v272;
          *v272 = 0;
          *((_QWORD *)v280 - 1) = v282;
          v280 -= 8;
        }
        while (v272 != v274);
        v273 = *(_QWORD **)&__path[16];
        v281 = *(char **)&__path[24];
      }
      v283 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v280;
      *((_QWORD *)this + 3) = v273;
      *(_OWORD *)&__path[8] = v283;
      v284 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v281;
      *(_QWORD *)&__path[24] = v284;
      *(_QWORD *)__path = v283;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v272 = Reader_KTX2_PVR;
      v273 = v272 + 1;
    }
    *((_QWORD *)this + 3) = v273;
  }
  Reader_KTX2 = CreateReader_KTX2();
  v286 = v772;
  v772[3] = (uint64_t)Reader_KTX2;
  if (Reader_KTX2)
  {
    v287 = *((_QWORD *)this + 4);
    v288 = (IIO_Reader **)*((_QWORD *)this + 3);
    if ((unint64_t)v288 >= v287)
    {
      v290 = (_QWORD *)*((_QWORD *)this + 2);
      v291 = v288 - (IIO_Reader **)v290;
      v292 = v291 + 1;
      if ((unint64_t)(v291 + 1) >> 61)
        goto LABEL_891;
      v293 = v287 - (_QWORD)v290;
      if (v293 >> 2 > v292)
        v292 = v293 >> 2;
      if ((unint64_t)v293 >= 0x7FFFFFFFFFFFFFF8)
        v294 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v294 = v292;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v294)
      {
        v295 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v294);
        v290 = (_QWORD *)*((_QWORD *)this + 2);
        v288 = (IIO_Reader **)*((_QWORD *)this + 3);
      }
      else
      {
        v295 = 0;
      }
      v296 = &v295[8 * v291];
      v297 = &v295[8 * v294];
      *(_QWORD *)&__path[24] = v297;
      *(_QWORD *)v296 = v286[3];
      *(_QWORD *)&__path[16] = v296 + 8;
      if (v288 == v290)
      {
        v289 = v296 + 8;
      }
      else
      {
        do
        {
          v298 = (uint64_t)*--v288;
          *v288 = 0;
          *((_QWORD *)v296 - 1) = v298;
          v296 -= 8;
        }
        while (v288 != v290);
        v289 = *(_QWORD **)&__path[16];
        v297 = *(char **)&__path[24];
      }
      v299 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v296;
      *((_QWORD *)this + 3) = v289;
      *(_OWORD *)&__path[8] = v299;
      v300 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v297;
      *(_QWORD *)&__path[24] = v300;
      *(_QWORD *)__path = v299;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v288 = Reader_KTX2;
      v289 = v288 + 1;
    }
    *((_QWORD *)this + 3) = v289;
  }
  Reader_AVCI = CreateReader_AVCI();
  v302 = v772;
  v772[3] = Reader_AVCI;
  if (Reader_AVCI)
  {
    v303 = *((_QWORD *)this + 4);
    v304 = (uint64_t *)*((_QWORD *)this + 3);
    if ((unint64_t)v304 >= v303)
    {
      v306 = (_QWORD *)*((_QWORD *)this + 2);
      v307 = v304 - v306;
      v308 = v307 + 1;
      if ((unint64_t)(v307 + 1) >> 61)
        goto LABEL_891;
      v309 = v303 - (_QWORD)v306;
      if (v309 >> 2 > v308)
        v308 = v309 >> 2;
      if ((unint64_t)v309 >= 0x7FFFFFFFFFFFFFF8)
        v310 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v310 = v308;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v310)
      {
        v311 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v310);
        v306 = (_QWORD *)*((_QWORD *)this + 2);
        v304 = (uint64_t *)*((_QWORD *)this + 3);
      }
      else
      {
        v311 = 0;
      }
      v312 = &v311[8 * v307];
      v313 = &v311[8 * v310];
      *(_QWORD *)&__path[24] = v313;
      *(_QWORD *)v312 = v302[3];
      *(_QWORD *)&__path[16] = v312 + 8;
      if (v304 == v306)
      {
        v305 = v312 + 8;
      }
      else
      {
        do
        {
          v314 = *--v304;
          *v304 = 0;
          *((_QWORD *)v312 - 1) = v314;
          v312 -= 8;
        }
        while (v304 != v306);
        v305 = *(_QWORD **)&__path[16];
        v313 = *(char **)&__path[24];
      }
      v315 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v312;
      *((_QWORD *)this + 3) = v305;
      *(_OWORD *)&__path[8] = v315;
      v316 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v313;
      *(_QWORD *)&__path[24] = v316;
      *(_QWORD *)__path = v315;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v304 = Reader_AVCI;
      v305 = v304 + 1;
    }
    *((_QWORD *)this + 3) = v305;
  }
  Reader_JPEGXL = CreateReader_JPEGXL();
  v318 = v772;
  v772[3] = Reader_JPEGXL;
  if (Reader_JPEGXL)
  {
    v319 = *((_QWORD *)this + 4);
    v320 = (uint64_t *)*((_QWORD *)this + 3);
    if ((unint64_t)v320 >= v319)
    {
      v322 = (_QWORD *)*((_QWORD *)this + 2);
      v323 = v320 - v322;
      v324 = v323 + 1;
      if ((unint64_t)(v323 + 1) >> 61)
        goto LABEL_891;
      v325 = v319 - (_QWORD)v322;
      if (v325 >> 2 > v324)
        v324 = v325 >> 2;
      if ((unint64_t)v325 >= 0x7FFFFFFFFFFFFFF8)
        v326 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v326 = v324;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v326)
      {
        v327 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v326);
        v322 = (_QWORD *)*((_QWORD *)this + 2);
        v320 = (uint64_t *)*((_QWORD *)this + 3);
      }
      else
      {
        v327 = 0;
      }
      v328 = &v327[8 * v323];
      v329 = &v327[8 * v326];
      *(_QWORD *)&__path[24] = v329;
      *(_QWORD *)v328 = v318[3];
      *(_QWORD *)&__path[16] = v328 + 8;
      if (v320 == v322)
      {
        v321 = v328 + 8;
      }
      else
      {
        do
        {
          v330 = *--v320;
          *v320 = 0;
          *((_QWORD *)v328 - 1) = v330;
          v328 -= 8;
        }
        while (v320 != v322);
        v321 = *(_QWORD **)&__path[16];
        v329 = *(char **)&__path[24];
      }
      v331 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v328;
      *((_QWORD *)this + 3) = v321;
      *(_OWORD *)&__path[8] = v331;
      v332 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v329;
      *(_QWORD *)&__path[24] = v332;
      *(_QWORD *)__path = v331;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v320 = Reader_JPEGXL;
      v321 = v320 + 1;
    }
    *((_QWORD *)this + 3) = v321;
  }
  Reader_AVIF = CreateReader_AVIF();
  v334 = v772;
  v772[3] = Reader_AVIF;
  if (Reader_AVIF)
  {
    v335 = *((_QWORD *)this + 4);
    v336 = (uint64_t *)*((_QWORD *)this + 3);
    if ((unint64_t)v336 >= v335)
    {
      v338 = (_QWORD *)*((_QWORD *)this + 2);
      v339 = v336 - v338;
      v340 = v339 + 1;
      if ((unint64_t)(v339 + 1) >> 61)
        goto LABEL_891;
      v341 = v335 - (_QWORD)v338;
      if (v341 >> 2 > v340)
        v340 = v341 >> 2;
      if ((unint64_t)v341 >= 0x7FFFFFFFFFFFFFF8)
        v342 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v342 = v340;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v342)
      {
        v343 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v342);
        v338 = (_QWORD *)*((_QWORD *)this + 2);
        v336 = (uint64_t *)*((_QWORD *)this + 3);
      }
      else
      {
        v343 = 0;
      }
      v344 = &v343[8 * v339];
      v345 = &v343[8 * v342];
      *(_QWORD *)&__path[24] = v345;
      *(_QWORD *)v344 = v334[3];
      *(_QWORD *)&__path[16] = v344 + 8;
      if (v336 == v338)
      {
        v337 = v344 + 8;
      }
      else
      {
        do
        {
          v346 = *--v336;
          *v336 = 0;
          *((_QWORD *)v344 - 1) = v346;
          v344 -= 8;
        }
        while (v336 != v338);
        v337 = *(_QWORD **)&__path[16];
        v345 = *(char **)&__path[24];
      }
      v347 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v344;
      *((_QWORD *)this + 3) = v337;
      *(_OWORD *)&__path[8] = v347;
      v348 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v345;
      *(_QWORD *)&__path[24] = v348;
      *(_QWORD *)__path = v347;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v336 = Reader_AVIF;
      v337 = v336 + 1;
    }
    *((_QWORD *)this + 3) = v337;
  }
  Reader_AVIS = CreateReader_AVIS();
  v350 = v772;
  v772[3] = Reader_AVIS;
  if (Reader_AVIS)
  {
    v351 = *((_QWORD *)this + 4);
    v352 = (uint64_t *)*((_QWORD *)this + 3);
    if ((unint64_t)v352 >= v351)
    {
      v354 = (_QWORD *)*((_QWORD *)this + 2);
      v355 = v352 - v354;
      v356 = v355 + 1;
      if ((unint64_t)(v355 + 1) >> 61)
        goto LABEL_891;
      v357 = v351 - (_QWORD)v354;
      if (v357 >> 2 > v356)
        v356 = v357 >> 2;
      if ((unint64_t)v357 >= 0x7FFFFFFFFFFFFFF8)
        v358 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v358 = v356;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v358)
      {
        v359 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v358);
        v354 = (_QWORD *)*((_QWORD *)this + 2);
        v352 = (uint64_t *)*((_QWORD *)this + 3);
      }
      else
      {
        v359 = 0;
      }
      v360 = &v359[8 * v355];
      v361 = &v359[8 * v358];
      *(_QWORD *)&__path[24] = v361;
      *(_QWORD *)v360 = v350[3];
      *(_QWORD *)&__path[16] = v360 + 8;
      if (v352 == v354)
      {
        v353 = v360 + 8;
      }
      else
      {
        do
        {
          v362 = *--v352;
          *v352 = 0;
          *((_QWORD *)v360 - 1) = v362;
          v360 -= 8;
        }
        while (v352 != v354);
        v353 = *(_QWORD **)&__path[16];
        v361 = *(char **)&__path[24];
      }
      v363 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v360;
      *((_QWORD *)this + 3) = v353;
      *(_OWORD *)&__path[8] = v363;
      v364 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v361;
      *(_QWORD *)&__path[24] = v364;
      *(_QWORD *)__path = v363;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v352 = Reader_AVIS;
      v353 = v352 + 1;
    }
    *((_QWORD *)this + 3) = v353;
  }
  Reader_HEIC = CreateReader_HEIC();
  v366 = v772;
  v772[3] = Reader_HEIC;
  if (Reader_HEIC)
  {
    v367 = *((_QWORD *)this + 4);
    v368 = (uint64_t *)*((_QWORD *)this + 3);
    if ((unint64_t)v368 >= v367)
    {
      v370 = (_QWORD *)*((_QWORD *)this + 2);
      v371 = v368 - v370;
      v372 = v371 + 1;
      if ((unint64_t)(v371 + 1) >> 61)
        goto LABEL_891;
      v373 = v367 - (_QWORD)v370;
      if (v373 >> 2 > v372)
        v372 = v373 >> 2;
      if ((unint64_t)v373 >= 0x7FFFFFFFFFFFFFF8)
        v374 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v374 = v372;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v374)
      {
        v375 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v374);
        v370 = (_QWORD *)*((_QWORD *)this + 2);
        v368 = (uint64_t *)*((_QWORD *)this + 3);
      }
      else
      {
        v375 = 0;
      }
      v376 = &v375[8 * v371];
      v377 = &v375[8 * v374];
      *(_QWORD *)&__path[24] = v377;
      *(_QWORD *)v376 = v366[3];
      *(_QWORD *)&__path[16] = v376 + 8;
      if (v368 == v370)
      {
        v369 = v376 + 8;
      }
      else
      {
        do
        {
          v378 = *--v368;
          *v368 = 0;
          *((_QWORD *)v376 - 1) = v378;
          v376 -= 8;
        }
        while (v368 != v370);
        v369 = *(_QWORD **)&__path[16];
        v377 = *(char **)&__path[24];
      }
      v379 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v376;
      *((_QWORD *)this + 3) = v369;
      *(_OWORD *)&__path[8] = v379;
      v380 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v377;
      *(_QWORD *)&__path[24] = v380;
      *(_QWORD *)__path = v379;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v368 = Reader_HEIC;
      v369 = v368 + 1;
    }
    *((_QWORD *)this + 3) = v369;
  }
  Reader_HEICS = CreateReader_HEICS();
  v382 = v772;
  v772[3] = Reader_HEICS;
  if (Reader_HEICS)
  {
    v383 = *((_QWORD *)this + 4);
    v384 = (uint64_t *)*((_QWORD *)this + 3);
    if ((unint64_t)v384 >= v383)
    {
      v386 = (_QWORD *)*((_QWORD *)this + 2);
      v387 = v384 - v386;
      v388 = v387 + 1;
      if ((unint64_t)(v387 + 1) >> 61)
        goto LABEL_891;
      v389 = v383 - (_QWORD)v386;
      if (v389 >> 2 > v388)
        v388 = v389 >> 2;
      if ((unint64_t)v389 >= 0x7FFFFFFFFFFFFFF8)
        v390 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v390 = v388;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v390)
      {
        v391 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v390);
        v386 = (_QWORD *)*((_QWORD *)this + 2);
        v384 = (uint64_t *)*((_QWORD *)this + 3);
      }
      else
      {
        v391 = 0;
      }
      v392 = &v391[8 * v387];
      v393 = &v391[8 * v390];
      *(_QWORD *)&__path[24] = v393;
      *(_QWORD *)v392 = v382[3];
      *(_QWORD *)&__path[16] = v392 + 8;
      if (v384 == v386)
      {
        v385 = v392 + 8;
      }
      else
      {
        do
        {
          v394 = *--v384;
          *v384 = 0;
          *((_QWORD *)v392 - 1) = v394;
          v392 -= 8;
        }
        while (v384 != v386);
        v385 = *(_QWORD **)&__path[16];
        v393 = *(char **)&__path[24];
      }
      v395 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v392;
      *((_QWORD *)this + 3) = v385;
      *(_OWORD *)&__path[8] = v395;
      v396 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v393;
      *(_QWORD *)&__path[24] = v396;
      *(_QWORD *)__path = v395;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v384 = Reader_HEICS;
      v385 = v384 + 1;
    }
    *((_QWORD *)this + 3) = v385;
  }
  Reader_HEIC_JPEG = CreateReader_HEIC_JPEG();
  v398 = v772;
  v772[3] = Reader_HEIC_JPEG;
  if (Reader_HEIC_JPEG)
  {
    v399 = *((_QWORD *)this + 4);
    v400 = (uint64_t *)*((_QWORD *)this + 3);
    if ((unint64_t)v400 >= v399)
    {
      v402 = (_QWORD *)*((_QWORD *)this + 2);
      v403 = v400 - v402;
      v404 = v403 + 1;
      if ((unint64_t)(v403 + 1) >> 61)
        goto LABEL_891;
      v405 = v399 - (_QWORD)v402;
      if (v405 >> 2 > v404)
        v404 = v405 >> 2;
      if ((unint64_t)v405 >= 0x7FFFFFFFFFFFFFF8)
        v406 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v406 = v404;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v406)
      {
        v407 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v406);
        v402 = (_QWORD *)*((_QWORD *)this + 2);
        v400 = (uint64_t *)*((_QWORD *)this + 3);
      }
      else
      {
        v407 = 0;
      }
      v408 = &v407[8 * v403];
      v409 = &v407[8 * v406];
      *(_QWORD *)&__path[24] = v409;
      *(_QWORD *)v408 = v398[3];
      *(_QWORD *)&__path[16] = v408 + 8;
      if (v400 == v402)
      {
        v401 = v408 + 8;
      }
      else
      {
        do
        {
          v410 = *--v400;
          *v400 = 0;
          *((_QWORD *)v408 - 1) = v410;
          v408 -= 8;
        }
        while (v400 != v402);
        v401 = *(_QWORD **)&__path[16];
        v409 = *(char **)&__path[24];
      }
      v411 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v408;
      *((_QWORD *)this + 3) = v401;
      *(_OWORD *)&__path[8] = v411;
      v412 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v409;
      *(_QWORD *)&__path[24] = v412;
      *(_QWORD *)__path = v411;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v400 = Reader_HEIC_JPEG;
      v401 = v400 + 1;
    }
    *((_QWORD *)this + 3) = v401;
  }
  Reader_HEIF = CreateReader_HEIF();
  v414 = v772;
  v772[3] = Reader_HEIF;
  if (Reader_HEIF)
  {
    v415 = *((_QWORD *)this + 4);
    v416 = (uint64_t *)*((_QWORD *)this + 3);
    if ((unint64_t)v416 >= v415)
    {
      v418 = (_QWORD *)*((_QWORD *)this + 2);
      v419 = v416 - v418;
      v420 = v419 + 1;
      if ((unint64_t)(v419 + 1) >> 61)
        goto LABEL_891;
      v421 = v415 - (_QWORD)v418;
      if (v421 >> 2 > v420)
        v420 = v421 >> 2;
      if ((unint64_t)v421 >= 0x7FFFFFFFFFFFFFF8)
        v422 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v422 = v420;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v422)
      {
        v423 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v422);
        v418 = (_QWORD *)*((_QWORD *)this + 2);
        v416 = (uint64_t *)*((_QWORD *)this + 3);
      }
      else
      {
        v423 = 0;
      }
      v424 = &v423[8 * v419];
      v425 = &v423[8 * v422];
      *(_QWORD *)&__path[24] = v425;
      *(_QWORD *)v424 = v414[3];
      *(_QWORD *)&__path[16] = v424 + 8;
      if (v416 == v418)
      {
        v417 = v424 + 8;
      }
      else
      {
        do
        {
          v426 = *--v416;
          *v416 = 0;
          *((_QWORD *)v424 - 1) = v426;
          v424 -= 8;
        }
        while (v416 != v418);
        v417 = *(_QWORD **)&__path[16];
        v425 = *(char **)&__path[24];
      }
      v427 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v424;
      *((_QWORD *)this + 3) = v417;
      *(_OWORD *)&__path[8] = v427;
      v428 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v425;
      *(_QWORD *)&__path[24] = v428;
      *(_QWORD *)__path = v427;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v416 = Reader_HEIF;
      v417 = v416 + 1;
    }
    *((_QWORD *)this + 3) = v417;
  }
  if (v766)
  {
    v768[0] = MEMORY[0x1E0C809B0];
    v768[1] = 0x40000000;
    v768[2] = ___ZN17IIO_ReaderHandler15buildPluginListEv_block_invoke_2;
    v768[3] = &unk_1E1BC96A8;
    v768[4] = &v771;
    v768[5] = this;
    IIOArray::enumerate((uint64_t)v766, (uint64_t)v768);
  }
  else
  {
    v429 = (int)v770;
    if ((int)v770 < SHIDWORD(v770))
    {
      v430 = (uint64_t **)((char *)this + 16);
      do
      {
        v431 = operator new();
        IIOReader_RawCamera::IIOReader_RawCamera(v431, *(_QWORD *)(v6 + 8 * v429));
        v432 = v772;
        v772[3] = v431;
        v434 = (uint64_t *)*((_QWORD *)this + 3);
        v433 = *((_QWORD *)this + 4);
        if ((unint64_t)v434 >= v433)
        {
          v436 = *v430;
          v437 = v434 - *v430;
          v438 = v437 + 1;
          if ((unint64_t)(v437 + 1) >> 61)
            std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
          v439 = v433 - (_QWORD)v436;
          if (v439 >> 2 > v438)
            v438 = v439 >> 2;
          if ((unint64_t)v439 >= 0x7FFFFFFFFFFFFFF8)
            v440 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v440 = v438;
          *(_QWORD *)&__path[32] = (char *)this + 32;
          if (v440)
          {
            v441 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v440);
            v436 = (uint64_t *)*((_QWORD *)this + 2);
            v434 = (uint64_t *)*((_QWORD *)this + 3);
          }
          else
          {
            v441 = 0;
          }
          v442 = &v441[8 * v437];
          v443 = &v441[8 * v440];
          *(_QWORD *)&__path[24] = v443;
          *(_QWORD *)v442 = v432[3];
          *(_QWORD *)&__path[16] = v442 + 8;
          if (v434 == v436)
          {
            v435 = v442 + 8;
          }
          else
          {
            do
            {
              v444 = *--v434;
              *v434 = 0;
              *((_QWORD *)v442 - 1) = v444;
              v442 -= 8;
            }
            while (v434 != v436);
            v435 = *(_QWORD **)&__path[16];
            v443 = *(char **)&__path[24];
          }
          v445 = *((_OWORD *)this + 1);
          *((_QWORD *)this + 2) = v442;
          *((_QWORD *)this + 3) = v435;
          *(_OWORD *)&__path[8] = v445;
          v446 = *((_QWORD *)this + 4);
          *((_QWORD *)this + 4) = v443;
          *(_QWORD *)&__path[24] = v446;
          *(_QWORD *)__path = v445;
          std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
        }
        else
        {
          *v434 = v431;
          v435 = v434 + 1;
        }
        *((_QWORD *)this + 3) = v435;
        ++v429;
      }
      while (v429 < SHIDWORD(v770));
    }
  }
  Reader_ICO = CreateReader_ICO();
  v448 = v772;
  v772[3] = (uint64_t)Reader_ICO;
  if (Reader_ICO)
  {
    v449 = *((_QWORD *)this + 4);
    v450 = (IIO_Reader **)*((_QWORD *)this + 3);
    if ((unint64_t)v450 >= v449)
    {
      v452 = (_QWORD *)*((_QWORD *)this + 2);
      v453 = v450 - (IIO_Reader **)v452;
      v454 = v453 + 1;
      if ((unint64_t)(v453 + 1) >> 61)
        goto LABEL_891;
      v455 = v449 - (_QWORD)v452;
      if (v455 >> 2 > v454)
        v454 = v455 >> 2;
      if ((unint64_t)v455 >= 0x7FFFFFFFFFFFFFF8)
        v456 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v456 = v454;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v456)
      {
        v457 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v456);
        v452 = (_QWORD *)*((_QWORD *)this + 2);
        v450 = (IIO_Reader **)*((_QWORD *)this + 3);
      }
      else
      {
        v457 = 0;
      }
      v458 = &v457[8 * v453];
      v459 = &v457[8 * v456];
      *(_QWORD *)&__path[24] = v459;
      *(_QWORD *)v458 = v448[3];
      *(_QWORD *)&__path[16] = v458 + 8;
      if (v450 == v452)
      {
        v451 = v458 + 8;
      }
      else
      {
        do
        {
          v460 = (uint64_t)*--v450;
          *v450 = 0;
          *((_QWORD *)v458 - 1) = v460;
          v458 -= 8;
        }
        while (v450 != v452);
        v451 = *(_QWORD **)&__path[16];
        v459 = *(char **)&__path[24];
      }
      v461 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v458;
      *((_QWORD *)this + 3) = v451;
      *(_OWORD *)&__path[8] = v461;
      v462 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v459;
      *(_QWORD *)&__path[24] = v462;
      *(_QWORD *)__path = v461;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v450 = Reader_ICO;
      v451 = v450 + 1;
    }
    *((_QWORD *)this + 3) = v451;
  }
  Reader_BMP = CreateReader_BMP();
  v464 = v772;
  v772[3] = (uint64_t)Reader_BMP;
  if (Reader_BMP)
  {
    v465 = *((_QWORD *)this + 4);
    v466 = (IIO_Reader **)*((_QWORD *)this + 3);
    if ((unint64_t)v466 >= v465)
    {
      v468 = (_QWORD *)*((_QWORD *)this + 2);
      v469 = v466 - (IIO_Reader **)v468;
      v470 = v469 + 1;
      if ((unint64_t)(v469 + 1) >> 61)
        goto LABEL_891;
      v471 = v465 - (_QWORD)v468;
      if (v471 >> 2 > v470)
        v470 = v471 >> 2;
      if ((unint64_t)v471 >= 0x7FFFFFFFFFFFFFF8)
        v472 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v472 = v470;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v472)
      {
        v473 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v472);
        v468 = (_QWORD *)*((_QWORD *)this + 2);
        v466 = (IIO_Reader **)*((_QWORD *)this + 3);
      }
      else
      {
        v473 = 0;
      }
      v474 = &v473[8 * v469];
      v475 = &v473[8 * v472];
      *(_QWORD *)&__path[24] = v475;
      *(_QWORD *)v474 = v464[3];
      *(_QWORD *)&__path[16] = v474 + 8;
      if (v466 == v468)
      {
        v467 = v474 + 8;
      }
      else
      {
        do
        {
          v476 = (uint64_t)*--v466;
          *v466 = 0;
          *((_QWORD *)v474 - 1) = v476;
          v474 -= 8;
        }
        while (v466 != v468);
        v467 = *(_QWORD **)&__path[16];
        v475 = *(char **)&__path[24];
      }
      v477 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v474;
      *((_QWORD *)this + 3) = v467;
      *(_OWORD *)&__path[8] = v477;
      v478 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v475;
      *(_QWORD *)&__path[24] = v478;
      *(_QWORD *)__path = v477;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v466 = Reader_BMP;
      v467 = v466 + 1;
    }
    *((_QWORD *)this + 3) = v467;
  }
  Reader_ICNS = CreateReader_ICNS();
  v480 = v772;
  v772[3] = (uint64_t)Reader_ICNS;
  if (Reader_ICNS)
  {
    v481 = *((_QWORD *)this + 4);
    v482 = (IIO_Reader **)*((_QWORD *)this + 3);
    if ((unint64_t)v482 >= v481)
    {
      v484 = (_QWORD *)*((_QWORD *)this + 2);
      v485 = v482 - (IIO_Reader **)v484;
      v486 = v485 + 1;
      if ((unint64_t)(v485 + 1) >> 61)
        goto LABEL_891;
      v487 = v481 - (_QWORD)v484;
      if (v487 >> 2 > v486)
        v486 = v487 >> 2;
      if ((unint64_t)v487 >= 0x7FFFFFFFFFFFFFF8)
        v488 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v488 = v486;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v488)
      {
        v489 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v488);
        v484 = (_QWORD *)*((_QWORD *)this + 2);
        v482 = (IIO_Reader **)*((_QWORD *)this + 3);
      }
      else
      {
        v489 = 0;
      }
      v490 = &v489[8 * v485];
      v491 = &v489[8 * v488];
      *(_QWORD *)&__path[24] = v491;
      *(_QWORD *)v490 = v480[3];
      *(_QWORD *)&__path[16] = v490 + 8;
      if (v482 == v484)
      {
        v483 = v490 + 8;
      }
      else
      {
        do
        {
          v492 = (uint64_t)*--v482;
          *v482 = 0;
          *((_QWORD *)v490 - 1) = v492;
          v490 -= 8;
        }
        while (v482 != v484);
        v483 = *(_QWORD **)&__path[16];
        v491 = *(char **)&__path[24];
      }
      v493 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v490;
      *((_QWORD *)this + 3) = v483;
      *(_OWORD *)&__path[8] = v493;
      v494 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v491;
      *(_QWORD *)&__path[24] = v494;
      *(_QWORD *)__path = v493;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v482 = Reader_ICNS;
      v483 = v482 + 1;
    }
    *((_QWORD *)this + 3) = v483;
  }
  Reader_PSD = CreateReader_PSD();
  v496 = v772;
  v772[3] = (uint64_t)Reader_PSD;
  if (Reader_PSD)
  {
    v497 = *((_QWORD *)this + 4);
    v498 = (IIO_Reader **)*((_QWORD *)this + 3);
    if ((unint64_t)v498 >= v497)
    {
      v500 = (_QWORD *)*((_QWORD *)this + 2);
      v501 = v498 - (IIO_Reader **)v500;
      v502 = v501 + 1;
      if ((unint64_t)(v501 + 1) >> 61)
        goto LABEL_891;
      v503 = v497 - (_QWORD)v500;
      if (v503 >> 2 > v502)
        v502 = v503 >> 2;
      if ((unint64_t)v503 >= 0x7FFFFFFFFFFFFFF8)
        v504 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v504 = v502;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v504)
      {
        v505 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v504);
        v500 = (_QWORD *)*((_QWORD *)this + 2);
        v498 = (IIO_Reader **)*((_QWORD *)this + 3);
      }
      else
      {
        v505 = 0;
      }
      v506 = &v505[8 * v501];
      v507 = &v505[8 * v504];
      *(_QWORD *)&__path[24] = v507;
      *(_QWORD *)v506 = v496[3];
      *(_QWORD *)&__path[16] = v506 + 8;
      if (v498 == v500)
      {
        v499 = v506 + 8;
      }
      else
      {
        do
        {
          v508 = (uint64_t)*--v498;
          *v498 = 0;
          *((_QWORD *)v506 - 1) = v508;
          v506 -= 8;
        }
        while (v498 != v500);
        v499 = *(_QWORD **)&__path[16];
        v507 = *(char **)&__path[24];
      }
      v509 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v506;
      *((_QWORD *)this + 3) = v499;
      *(_OWORD *)&__path[8] = v509;
      v510 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v507;
      *(_QWORD *)&__path[24] = v510;
      *(_QWORD *)__path = v509;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v498 = Reader_PSD;
      v499 = v498 + 1;
    }
    *((_QWORD *)this + 3) = v499;
  }
  Reader_PDF = CreateReader_PDF();
  v512 = v772;
  v772[3] = (uint64_t)Reader_PDF;
  if (Reader_PDF)
  {
    v513 = *((_QWORD *)this + 4);
    v514 = (IIO_Reader **)*((_QWORD *)this + 3);
    if ((unint64_t)v514 >= v513)
    {
      v516 = (_QWORD *)*((_QWORD *)this + 2);
      v517 = v514 - (IIO_Reader **)v516;
      v518 = v517 + 1;
      if ((unint64_t)(v517 + 1) >> 61)
        goto LABEL_891;
      v519 = v513 - (_QWORD)v516;
      if (v519 >> 2 > v518)
        v518 = v519 >> 2;
      if ((unint64_t)v519 >= 0x7FFFFFFFFFFFFFF8)
        v520 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v520 = v518;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v520)
      {
        v521 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v520);
        v516 = (_QWORD *)*((_QWORD *)this + 2);
        v514 = (IIO_Reader **)*((_QWORD *)this + 3);
      }
      else
      {
        v521 = 0;
      }
      v522 = &v521[8 * v517];
      v523 = &v521[8 * v520];
      *(_QWORD *)&__path[24] = v523;
      *(_QWORD *)v522 = v512[3];
      *(_QWORD *)&__path[16] = v522 + 8;
      if (v514 == v516)
      {
        v515 = v522 + 8;
      }
      else
      {
        do
        {
          v524 = (uint64_t)*--v514;
          *v514 = 0;
          *((_QWORD *)v522 - 1) = v524;
          v522 -= 8;
        }
        while (v514 != v516);
        v515 = *(_QWORD **)&__path[16];
        v523 = *(char **)&__path[24];
      }
      v525 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v522;
      *((_QWORD *)this + 3) = v515;
      *(_OWORD *)&__path[8] = v525;
      v526 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v523;
      *(_QWORD *)&__path[24] = v526;
      *(_QWORD *)__path = v525;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v514 = Reader_PDF;
      v515 = v514 + 1;
    }
    *((_QWORD *)this + 3) = v515;
  }
  Reader_AI = CreateReader_AI();
  v528 = v772;
  v772[3] = (uint64_t)Reader_AI;
  if (Reader_AI)
  {
    v529 = *((_QWORD *)this + 4);
    v530 = (IIO_Reader **)*((_QWORD *)this + 3);
    if ((unint64_t)v530 >= v529)
    {
      v532 = (_QWORD *)*((_QWORD *)this + 2);
      v533 = v530 - (IIO_Reader **)v532;
      v534 = v533 + 1;
      if ((unint64_t)(v533 + 1) >> 61)
        goto LABEL_891;
      v535 = v529 - (_QWORD)v532;
      if (v535 >> 2 > v534)
        v534 = v535 >> 2;
      if ((unint64_t)v535 >= 0x7FFFFFFFFFFFFFF8)
        v536 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v536 = v534;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v536)
      {
        v537 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v536);
        v532 = (_QWORD *)*((_QWORD *)this + 2);
        v530 = (IIO_Reader **)*((_QWORD *)this + 3);
      }
      else
      {
        v537 = 0;
      }
      v538 = &v537[8 * v533];
      v539 = &v537[8 * v536];
      *(_QWORD *)&__path[24] = v539;
      *(_QWORD *)v538 = v528[3];
      *(_QWORD *)&__path[16] = v538 + 8;
      if (v530 == v532)
      {
        v531 = v538 + 8;
      }
      else
      {
        do
        {
          v540 = (uint64_t)*--v530;
          *v530 = 0;
          *((_QWORD *)v538 - 1) = v540;
          v538 -= 8;
        }
        while (v530 != v532);
        v531 = *(_QWORD **)&__path[16];
        v539 = *(char **)&__path[24];
      }
      v541 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v538;
      *((_QWORD *)this + 3) = v531;
      *(_OWORD *)&__path[8] = v541;
      v542 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v539;
      *(_QWORD *)&__path[24] = v542;
      *(_QWORD *)__path = v541;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v530 = Reader_AI;
      v531 = v530 + 1;
    }
    *((_QWORD *)this + 3) = v531;
  }
  v543 = IIOLookupISR();
  v544 = v772;
  v772[3] = v543;
  if (v543)
  {
    v545 = *((_QWORD *)this + 4);
    v546 = (uint64_t *)*((_QWORD *)this + 3);
    if ((unint64_t)v546 >= v545)
    {
      v548 = (_QWORD *)*((_QWORD *)this + 2);
      v549 = v546 - v548;
      v550 = v549 + 1;
      if ((unint64_t)(v549 + 1) >> 61)
        goto LABEL_891;
      v551 = v545 - (_QWORD)v548;
      if (v551 >> 2 > v550)
        v550 = v551 >> 2;
      if ((unint64_t)v551 >= 0x7FFFFFFFFFFFFFF8)
        v552 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v552 = v550;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v552)
      {
        v553 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v552);
        v548 = (_QWORD *)*((_QWORD *)this + 2);
        v546 = (uint64_t *)*((_QWORD *)this + 3);
      }
      else
      {
        v553 = 0;
      }
      v554 = &v553[8 * v549];
      v555 = &v553[8 * v552];
      *(_QWORD *)&__path[24] = v555;
      *(_QWORD *)v554 = v544[3];
      *(_QWORD *)&__path[16] = v554 + 8;
      if (v546 == v548)
      {
        v547 = v554 + 8;
      }
      else
      {
        do
        {
          v556 = *--v546;
          *v546 = 0;
          *((_QWORD *)v554 - 1) = v556;
          v554 -= 8;
        }
        while (v546 != v548);
        v547 = *(_QWORD **)&__path[16];
        v555 = *(char **)&__path[24];
      }
      v557 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v554;
      *((_QWORD *)this + 3) = v547;
      *(_OWORD *)&__path[8] = v557;
      v558 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v555;
      *(_QWORD *)&__path[24] = v558;
      *(_QWORD *)__path = v557;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v546 = v543;
      v547 = v546 + 1;
    }
    *((_QWORD *)this + 3) = v547;
  }
  Reader_CUR = CreateReader_CUR();
  v560 = v772;
  v772[3] = (uint64_t)Reader_CUR;
  if (Reader_CUR)
  {
    v561 = *((_QWORD *)this + 4);
    v562 = (IIO_Reader **)*((_QWORD *)this + 3);
    if ((unint64_t)v562 >= v561)
    {
      v564 = (_QWORD *)*((_QWORD *)this + 2);
      v565 = v562 - (IIO_Reader **)v564;
      v566 = v565 + 1;
      if ((unint64_t)(v565 + 1) >> 61)
        goto LABEL_891;
      v567 = v561 - (_QWORD)v564;
      if (v567 >> 2 > v566)
        v566 = v567 >> 2;
      if ((unint64_t)v567 >= 0x7FFFFFFFFFFFFFF8)
        v568 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v568 = v566;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v568)
      {
        v569 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v568);
        v564 = (_QWORD *)*((_QWORD *)this + 2);
        v562 = (IIO_Reader **)*((_QWORD *)this + 3);
      }
      else
      {
        v569 = 0;
      }
      v570 = &v569[8 * v565];
      v571 = &v569[8 * v568];
      *(_QWORD *)&__path[24] = v571;
      *(_QWORD *)v570 = v560[3];
      *(_QWORD *)&__path[16] = v570 + 8;
      if (v562 == v564)
      {
        v563 = v570 + 8;
      }
      else
      {
        do
        {
          v572 = (uint64_t)*--v562;
          *v562 = 0;
          *((_QWORD *)v570 - 1) = v572;
          v570 -= 8;
        }
        while (v562 != v564);
        v563 = *(_QWORD **)&__path[16];
        v571 = *(char **)&__path[24];
      }
      v573 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v570;
      *((_QWORD *)this + 3) = v563;
      *(_OWORD *)&__path[8] = v573;
      v574 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v571;
      *(_QWORD *)&__path[24] = v574;
      *(_QWORD *)__path = v573;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v562 = Reader_CUR;
      v563 = v562 + 1;
    }
    *((_QWORD *)this + 3) = v563;
  }
  Reader_TGA = CreateReader_TGA();
  v576 = v772;
  v772[3] = (uint64_t)Reader_TGA;
  if (Reader_TGA)
  {
    v577 = *((_QWORD *)this + 4);
    v578 = (IIO_Reader **)*((_QWORD *)this + 3);
    if ((unint64_t)v578 >= v577)
    {
      v580 = (_QWORD *)*((_QWORD *)this + 2);
      v581 = v578 - (IIO_Reader **)v580;
      v582 = v581 + 1;
      if ((unint64_t)(v581 + 1) >> 61)
        goto LABEL_891;
      v583 = v577 - (_QWORD)v580;
      if (v583 >> 2 > v582)
        v582 = v583 >> 2;
      if ((unint64_t)v583 >= 0x7FFFFFFFFFFFFFF8)
        v584 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v584 = v582;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v584)
      {
        v585 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v584);
        v580 = (_QWORD *)*((_QWORD *)this + 2);
        v578 = (IIO_Reader **)*((_QWORD *)this + 3);
      }
      else
      {
        v585 = 0;
      }
      v586 = &v585[8 * v581];
      v587 = &v585[8 * v584];
      *(_QWORD *)&__path[24] = v587;
      *(_QWORD *)v586 = v576[3];
      *(_QWORD *)&__path[16] = v586 + 8;
      if (v578 == v580)
      {
        v579 = v586 + 8;
      }
      else
      {
        do
        {
          v588 = (uint64_t)*--v578;
          *v578 = 0;
          *((_QWORD *)v586 - 1) = v588;
          v586 -= 8;
        }
        while (v578 != v580);
        v579 = *(_QWORD **)&__path[16];
        v587 = *(char **)&__path[24];
      }
      v589 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v586;
      *((_QWORD *)this + 3) = v579;
      *(_OWORD *)&__path[8] = v589;
      v590 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v587;
      *(_QWORD *)&__path[24] = v590;
      *(_QWORD *)__path = v589;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v578 = Reader_TGA;
      v579 = v578 + 1;
    }
    *((_QWORD *)this + 3) = v579;
  }
  Reader_EXR = CreateReader_EXR();
  v592 = v772;
  v772[3] = (uint64_t)Reader_EXR;
  if (Reader_EXR)
  {
    v593 = *((_QWORD *)this + 4);
    v594 = (IIO_Reader **)*((_QWORD *)this + 3);
    if ((unint64_t)v594 >= v593)
    {
      v596 = (_QWORD *)*((_QWORD *)this + 2);
      v597 = v594 - (IIO_Reader **)v596;
      v598 = v597 + 1;
      if ((unint64_t)(v597 + 1) >> 61)
        goto LABEL_891;
      v599 = v593 - (_QWORD)v596;
      if (v599 >> 2 > v598)
        v598 = v599 >> 2;
      if ((unint64_t)v599 >= 0x7FFFFFFFFFFFFFF8)
        v600 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v600 = v598;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v600)
      {
        v601 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v600);
        v596 = (_QWORD *)*((_QWORD *)this + 2);
        v594 = (IIO_Reader **)*((_QWORD *)this + 3);
      }
      else
      {
        v601 = 0;
      }
      v602 = &v601[8 * v597];
      v603 = &v601[8 * v600];
      *(_QWORD *)&__path[24] = v603;
      *(_QWORD *)v602 = v592[3];
      *(_QWORD *)&__path[16] = v602 + 8;
      if (v594 == v596)
      {
        v595 = v602 + 8;
      }
      else
      {
        do
        {
          v604 = (uint64_t)*--v594;
          *v594 = 0;
          *((_QWORD *)v602 - 1) = v604;
          v602 -= 8;
        }
        while (v594 != v596);
        v595 = *(_QWORD **)&__path[16];
        v603 = *(char **)&__path[24];
      }
      v605 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v602;
      *((_QWORD *)this + 3) = v595;
      *(_OWORD *)&__path[8] = v605;
      v606 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v603;
      *(_QWORD *)&__path[24] = v606;
      *(_QWORD *)__path = v605;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v594 = Reader_EXR;
      v595 = v594 + 1;
    }
    *((_QWORD *)this + 3) = v595;
  }
  Reader_WebP = CreateReader_WebP();
  v608 = v772;
  v772[3] = (uint64_t)Reader_WebP;
  if (Reader_WebP)
  {
    v609 = *((_QWORD *)this + 4);
    v610 = (IIO_Reader **)*((_QWORD *)this + 3);
    if ((unint64_t)v610 >= v609)
    {
      v612 = (_QWORD *)*((_QWORD *)this + 2);
      v613 = v610 - (IIO_Reader **)v612;
      v614 = v613 + 1;
      if ((unint64_t)(v613 + 1) >> 61)
        goto LABEL_891;
      v615 = v609 - (_QWORD)v612;
      if (v615 >> 2 > v614)
        v614 = v615 >> 2;
      if ((unint64_t)v615 >= 0x7FFFFFFFFFFFFFF8)
        v616 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v616 = v614;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v616)
      {
        v617 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v616);
        v612 = (_QWORD *)*((_QWORD *)this + 2);
        v610 = (IIO_Reader **)*((_QWORD *)this + 3);
      }
      else
      {
        v617 = 0;
      }
      v618 = &v617[8 * v613];
      v619 = &v617[8 * v616];
      *(_QWORD *)&__path[24] = v619;
      *(_QWORD *)v618 = v608[3];
      *(_QWORD *)&__path[16] = v618 + 8;
      if (v610 == v612)
      {
        v611 = v618 + 8;
      }
      else
      {
        do
        {
          v620 = (uint64_t)*--v610;
          *v610 = 0;
          *((_QWORD *)v618 - 1) = v620;
          v618 -= 8;
        }
        while (v610 != v612);
        v611 = *(_QWORD **)&__path[16];
        v619 = *(char **)&__path[24];
      }
      v621 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v618;
      *((_QWORD *)this + 3) = v611;
      *(_OWORD *)&__path[8] = v621;
      v622 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v619;
      *(_QWORD *)&__path[24] = v622;
      *(_QWORD *)__path = v621;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v610 = Reader_WebP;
      v611 = v610 + 1;
    }
    *((_QWORD *)this + 3) = v611;
    v608 = v772;
  }
  v608[3] = 0;
  v623 = IIOLookupISR();
  v624 = v772;
  v772[3] = v623;
  if (v623)
  {
    v625 = *((_QWORD *)this + 4);
    v626 = (uint64_t *)*((_QWORD *)this + 3);
    if ((unint64_t)v626 >= v625)
    {
      v628 = (_QWORD *)*((_QWORD *)this + 2);
      v629 = v626 - v628;
      v630 = v629 + 1;
      if ((unint64_t)(v629 + 1) >> 61)
        goto LABEL_891;
      v631 = v625 - (_QWORD)v628;
      if (v631 >> 2 > v630)
        v630 = v631 >> 2;
      if ((unint64_t)v631 >= 0x7FFFFFFFFFFFFFF8)
        v632 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v632 = v630;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v632)
      {
        v633 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v632);
        v628 = (_QWORD *)*((_QWORD *)this + 2);
        v626 = (uint64_t *)*((_QWORD *)this + 3);
      }
      else
      {
        v633 = 0;
      }
      v634 = &v633[8 * v629];
      v635 = &v633[8 * v632];
      *(_QWORD *)&__path[24] = v635;
      *(_QWORD *)v634 = v624[3];
      *(_QWORD *)&__path[16] = v634 + 8;
      if (v626 == v628)
      {
        v627 = v634 + 8;
      }
      else
      {
        do
        {
          v636 = *--v626;
          *v626 = 0;
          *((_QWORD *)v634 - 1) = v636;
          v634 -= 8;
        }
        while (v626 != v628);
        v627 = *(_QWORD **)&__path[16];
        v635 = *(char **)&__path[24];
      }
      v637 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v634;
      *((_QWORD *)this + 3) = v627;
      *(_OWORD *)&__path[8] = v637;
      v638 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v635;
      *(_QWORD *)&__path[24] = v638;
      *(_QWORD *)__path = v637;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v626 = v623;
      v627 = v626 + 1;
    }
    *((_QWORD *)this + 3) = v627;
  }
  Reader_RAD = CreateReader_RAD();
  v640 = v772;
  v772[3] = (uint64_t)Reader_RAD;
  if (Reader_RAD)
  {
    v641 = *((_QWORD *)this + 4);
    v642 = (IIO_Reader **)*((_QWORD *)this + 3);
    if ((unint64_t)v642 >= v641)
    {
      v644 = (_QWORD *)*((_QWORD *)this + 2);
      v645 = v642 - (IIO_Reader **)v644;
      v646 = v645 + 1;
      if ((unint64_t)(v645 + 1) >> 61)
        goto LABEL_891;
      v647 = v641 - (_QWORD)v644;
      if (v647 >> 2 > v646)
        v646 = v647 >> 2;
      if ((unint64_t)v647 >= 0x7FFFFFFFFFFFFFF8)
        v648 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v648 = v646;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v648)
      {
        v649 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v648);
        v644 = (_QWORD *)*((_QWORD *)this + 2);
        v642 = (IIO_Reader **)*((_QWORD *)this + 3);
      }
      else
      {
        v649 = 0;
      }
      v650 = &v649[8 * v645];
      v651 = &v649[8 * v648];
      *(_QWORD *)&__path[24] = v651;
      *(_QWORD *)v650 = v640[3];
      *(_QWORD *)&__path[16] = v650 + 8;
      if (v642 == v644)
      {
        v643 = v650 + 8;
      }
      else
      {
        do
        {
          v652 = (uint64_t)*--v642;
          *v642 = 0;
          *((_QWORD *)v650 - 1) = v652;
          v650 -= 8;
        }
        while (v642 != v644);
        v643 = *(_QWORD **)&__path[16];
        v651 = *(char **)&__path[24];
      }
      v653 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v650;
      *((_QWORD *)this + 3) = v643;
      *(_OWORD *)&__path[8] = v653;
      v654 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v651;
      *(_QWORD *)&__path[24] = v654;
      *(_QWORD *)__path = v653;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v642 = Reader_RAD;
      v643 = v642 + 1;
    }
    *((_QWORD *)this + 3) = v643;
  }
  Reader_PBM = CreateReader_PBM();
  v656 = v772;
  v772[3] = (uint64_t)Reader_PBM;
  if (Reader_PBM)
  {
    v657 = *((_QWORD *)this + 4);
    v658 = (IIO_Reader **)*((_QWORD *)this + 3);
    if ((unint64_t)v658 >= v657)
    {
      v660 = (_QWORD *)*((_QWORD *)this + 2);
      v661 = v658 - (IIO_Reader **)v660;
      v662 = v661 + 1;
      if ((unint64_t)(v661 + 1) >> 61)
        goto LABEL_891;
      v663 = v657 - (_QWORD)v660;
      if (v663 >> 2 > v662)
        v662 = v663 >> 2;
      if ((unint64_t)v663 >= 0x7FFFFFFFFFFFFFF8)
        v664 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v664 = v662;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v664)
      {
        v665 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v664);
        v660 = (_QWORD *)*((_QWORD *)this + 2);
        v658 = (IIO_Reader **)*((_QWORD *)this + 3);
      }
      else
      {
        v665 = 0;
      }
      v666 = &v665[8 * v661];
      v667 = &v665[8 * v664];
      *(_QWORD *)&__path[24] = v667;
      *(_QWORD *)v666 = v656[3];
      *(_QWORD *)&__path[16] = v666 + 8;
      if (v658 == v660)
      {
        v659 = v666 + 8;
      }
      else
      {
        do
        {
          v668 = (uint64_t)*--v658;
          *v658 = 0;
          *((_QWORD *)v666 - 1) = v668;
          v666 -= 8;
        }
        while (v658 != v660);
        v659 = *(_QWORD **)&__path[16];
        v667 = *(char **)&__path[24];
      }
      v669 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v666;
      *((_QWORD *)this + 3) = v659;
      *(_OWORD *)&__path[8] = v669;
      v670 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v667;
      *(_QWORD *)&__path[24] = v670;
      *(_QWORD *)__path = v669;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v658 = Reader_PBM;
      v659 = v658 + 1;
    }
    *((_QWORD *)this + 3) = v659;
  }
  Reader_MPO = CreateReader_MPO();
  v672 = v772;
  v772[3] = (uint64_t)Reader_MPO;
  if (Reader_MPO)
  {
    v673 = *((_QWORD *)this + 4);
    v674 = (IIO_Reader **)*((_QWORD *)this + 3);
    if ((unint64_t)v674 >= v673)
    {
      v676 = (_QWORD *)*((_QWORD *)this + 2);
      v677 = v674 - (IIO_Reader **)v676;
      v678 = v677 + 1;
      if ((unint64_t)(v677 + 1) >> 61)
        goto LABEL_891;
      v679 = v673 - (_QWORD)v676;
      if (v679 >> 2 > v678)
        v678 = v679 >> 2;
      if ((unint64_t)v679 >= 0x7FFFFFFFFFFFFFF8)
        v680 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v680 = v678;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v680)
      {
        v681 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v680);
        v676 = (_QWORD *)*((_QWORD *)this + 2);
        v674 = (IIO_Reader **)*((_QWORD *)this + 3);
      }
      else
      {
        v681 = 0;
      }
      v682 = &v681[8 * v677];
      v683 = &v681[8 * v680];
      *(_QWORD *)&__path[24] = v683;
      *(_QWORD *)v682 = v672[3];
      *(_QWORD *)&__path[16] = v682 + 8;
      if (v674 == v676)
      {
        v675 = v682 + 8;
      }
      else
      {
        do
        {
          v684 = (uint64_t)*--v674;
          *v674 = 0;
          *((_QWORD *)v682 - 1) = v684;
          v682 -= 8;
        }
        while (v674 != v676);
        v675 = *(_QWORD **)&__path[16];
        v683 = *(char **)&__path[24];
      }
      v685 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v682;
      *((_QWORD *)this + 3) = v675;
      *(_OWORD *)&__path[8] = v685;
      v686 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v683;
      *(_QWORD *)&__path[24] = v686;
      *(_QWORD *)__path = v685;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v674 = Reader_MPO;
      v675 = v674 + 1;
    }
    *((_QWORD *)this + 3) = v675;
  }
  Reader_PVR = CreateReader_PVR();
  v688 = v772;
  v772[3] = (uint64_t)Reader_PVR;
  if (Reader_PVR)
  {
    v689 = *((_QWORD *)this + 4);
    v690 = (IIO_Reader **)*((_QWORD *)this + 3);
    if ((unint64_t)v690 >= v689)
    {
      v692 = (_QWORD *)*((_QWORD *)this + 2);
      v693 = v690 - (IIO_Reader **)v692;
      v694 = v693 + 1;
      if ((unint64_t)(v693 + 1) >> 61)
        goto LABEL_891;
      v695 = v689 - (_QWORD)v692;
      if (v695 >> 2 > v694)
        v694 = v695 >> 2;
      if ((unint64_t)v695 >= 0x7FFFFFFFFFFFFFF8)
        v696 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v696 = v694;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v696)
      {
        v697 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v696);
        v692 = (_QWORD *)*((_QWORD *)this + 2);
        v690 = (IIO_Reader **)*((_QWORD *)this + 3);
      }
      else
      {
        v697 = 0;
      }
      v698 = &v697[8 * v693];
      v699 = &v697[8 * v696];
      *(_QWORD *)&__path[24] = v699;
      *(_QWORD *)v698 = v688[3];
      *(_QWORD *)&__path[16] = v698 + 8;
      if (v690 == v692)
      {
        v691 = v698 + 8;
      }
      else
      {
        do
        {
          v700 = (uint64_t)*--v690;
          *v690 = 0;
          *((_QWORD *)v698 - 1) = v700;
          v698 -= 8;
        }
        while (v690 != v692);
        v691 = *(_QWORD **)&__path[16];
        v699 = *(char **)&__path[24];
      }
      v701 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v698;
      *((_QWORD *)this + 3) = v691;
      *(_OWORD *)&__path[8] = v701;
      v702 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v699;
      *(_QWORD *)&__path[24] = v702;
      *(_QWORD *)__path = v701;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v690 = Reader_PVR;
      v691 = v690 + 1;
    }
    *((_QWORD *)this + 3) = v691;
  }
  Reader_DDS_BC = CreateReader_DDS_BC();
  v704 = v772;
  v772[3] = (uint64_t)Reader_DDS_BC;
  if (Reader_DDS_BC)
  {
    v705 = *((_QWORD *)this + 4);
    v706 = (IIO_Reader **)*((_QWORD *)this + 3);
    if ((unint64_t)v706 >= v705)
    {
      v708 = (_QWORD *)*((_QWORD *)this + 2);
      v709 = v706 - (IIO_Reader **)v708;
      v710 = v709 + 1;
      if ((unint64_t)(v709 + 1) >> 61)
        goto LABEL_891;
      v711 = v705 - (_QWORD)v708;
      if (v711 >> 2 > v710)
        v710 = v711 >> 2;
      if ((unint64_t)v711 >= 0x7FFFFFFFFFFFFFF8)
        v712 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v712 = v710;
      *(_QWORD *)&__path[32] = (char *)this + 32;
      if (v712)
      {
        v713 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v712);
        v708 = (_QWORD *)*((_QWORD *)this + 2);
        v706 = (IIO_Reader **)*((_QWORD *)this + 3);
      }
      else
      {
        v713 = 0;
      }
      v714 = &v713[8 * v709];
      v715 = &v713[8 * v712];
      *(_QWORD *)&__path[24] = v715;
      *(_QWORD *)v714 = v704[3];
      *(_QWORD *)&__path[16] = v714 + 8;
      if (v706 == v708)
      {
        v707 = v714 + 8;
      }
      else
      {
        do
        {
          v716 = (uint64_t)*--v706;
          *v706 = 0;
          *((_QWORD *)v714 - 1) = v716;
          v714 -= 8;
        }
        while (v706 != v708);
        v707 = *(_QWORD **)&__path[16];
        v715 = *(char **)&__path[24];
      }
      v717 = *((_OWORD *)this + 1);
      *((_QWORD *)this + 2) = v714;
      *((_QWORD *)this + 3) = v707;
      *(_OWORD *)&__path[8] = v717;
      v718 = *((_QWORD *)this + 4);
      *((_QWORD *)this + 4) = v715;
      *(_QWORD *)&__path[24] = v718;
      *(_QWORD *)__path = v717;
      std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
    }
    else
    {
      *v706 = Reader_DDS_BC;
      v707 = v706 + 1;
    }
    *((_QWORD *)this + 3) = v707;
    v704 = v772;
  }
  v704[3] = 0;
  Reader_LibJPEG = (void *)IIO_OSAppleInternalBuild();
  if ((_DWORD)Reader_LibJPEG)
  {
    strcpy(__path, "/AppleInternal/Library/Bundles/BMTLPlugin.bundle/BMTLPlugin");
    Reader_LibJPEG = dlopen(__path, 257);
    if (Reader_LibJPEG)
    {
      Reader_LibJPEG = dlsym(Reader_LibJPEG, RawCamera_CopyRawPluginsInfoArray);
      if (Reader_LibJPEG)
      {
        Reader_LibJPEG = (void *)((uint64_t (*)(_QWORD, _QWORD))Reader_LibJPEG)(0, 0);
        v720 = (const __CFArray *)Reader_LibJPEG;
        if (Reader_LibJPEG)
        {
          if (CFArrayGetCount((CFArrayRef)Reader_LibJPEG) == 1)
          {
            ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v720, 0);
            memset(v767, 0, sizeof(v767));
            IIODictionary::IIODictionary((IIODictionary *)v767, ValueAtIndex);
            v722 = (IIOReader_RawCamera *)operator new();
            IIOReader_RawCamera::IIOReader_RawCamera(v722, (IIODictionary *)v767);
            v723 = v772;
            v772[3] = (uint64_t)v722;
            v724 = *((_QWORD *)this + 4);
            v725 = (IIOReader_RawCamera **)*((_QWORD *)this + 3);
            if ((unint64_t)v725 >= v724)
            {
              v727 = (_QWORD *)*((_QWORD *)this + 2);
              v728 = v725 - (IIOReader_RawCamera **)v727;
              if ((unint64_t)(v728 + 1) >> 61)
                std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
              v729 = v724 - (_QWORD)v727;
              v730 = (uint64_t)(v724 - (_QWORD)v727) >> 2;
              if (v730 <= v728 + 1)
                v730 = v728 + 1;
              if (v729 >= 0x7FFFFFFFFFFFFFF8)
                v731 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v731 = v730;
              v778 = (char *)this + 32;
              if (v731)
              {
                v732 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v731);
                v727 = (_QWORD *)*((_QWORD *)this + 2);
                v725 = (IIOReader_RawCamera **)*((_QWORD *)this + 3);
              }
              else
              {
                v732 = 0;
              }
              v733 = &v732[8 * v728];
              v734 = &v732[8 * v731];
              v777 = v734;
              *(_QWORD *)v733 = v723[3];
              *((_QWORD *)&v776 + 1) = v733 + 8;
              if (v725 == v727)
              {
                v726 = v733 + 8;
              }
              else
              {
                do
                {
                  v735 = (uint64_t)*--v725;
                  *v725 = 0;
                  *((_QWORD *)v733 - 1) = v735;
                  v733 -= 8;
                }
                while (v725 != v727);
                v726 = (_QWORD *)*((_QWORD *)&v776 + 1);
                v734 = v777;
              }
              v736 = *((_OWORD *)this + 1);
              *((_QWORD *)this + 2) = v733;
              *((_QWORD *)this + 3) = v726;
              v776 = v736;
              v737 = (char *)*((_QWORD *)this + 4);
              *((_QWORD *)this + 4) = v734;
              v777 = v737;
              v775 = v736;
              std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)&v775);
            }
            else
            {
              *v725 = v722;
              v726 = v725 + 1;
            }
            *((_QWORD *)this + 3) = v726;
            IIODictionary::~IIODictionary((IIODictionary *)v767);
          }
          CFRelease(v720);
        }
      }
    }
  }
  if (IIO_ReaderHandler::UseAppleJPEG(void)::appleJPEGCheck != -1)
    dispatch_once(&IIO_ReaderHandler::UseAppleJPEG(void)::appleJPEGCheck, &__block_literal_global_28_0);
  if (IIO_ReaderHandler::UseAppleJPEG(void)::gUseAppleJPEGPlugin)
  {
    Reader_LibJPEG = CreateReader_LibJPEG();
    v738 = v772;
    v772[3] = (uint64_t)Reader_LibJPEG;
    if (Reader_LibJPEG)
    {
      v739 = *((_QWORD *)this + 4);
      v740 = (_QWORD *)*((_QWORD *)this + 3);
      if ((unint64_t)v740 < v739)
      {
        *v740 = Reader_LibJPEG;
        v741 = v740 + 1;
LABEL_869:
        *((_QWORD *)this + 3) = v741;
        goto LABEL_870;
      }
      v742 = (_QWORD *)*((_QWORD *)this + 2);
      v743 = v740 - v742;
      v744 = v743 + 1;
      if (!((unint64_t)(v743 + 1) >> 61))
      {
        v745 = v739 - (_QWORD)v742;
        if (v745 >> 2 > v744)
          v744 = v745 >> 2;
        if ((unint64_t)v745 >= 0x7FFFFFFFFFFFFFF8)
          v746 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v746 = v744;
        *(_QWORD *)&__path[32] = (char *)this + 32;
        if (v746)
        {
          v747 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 32, v746);
          v742 = (_QWORD *)*((_QWORD *)this + 2);
          v740 = (_QWORD *)*((_QWORD *)this + 3);
        }
        else
        {
          v747 = 0;
        }
        v748 = &v747[8 * v743];
        v749 = &v747[8 * v746];
        *(_QWORD *)&__path[24] = v749;
        *(_QWORD *)v748 = v738[3];
        *(_QWORD *)&__path[16] = v748 + 8;
        if (v740 == v742)
        {
          v741 = v748 + 8;
        }
        else
        {
          do
          {
            v750 = *--v740;
            *v740 = 0;
            *((_QWORD *)v748 - 1) = v750;
            v748 -= 8;
          }
          while (v740 != v742);
          v741 = *(_QWORD **)&__path[16];
          v749 = *(char **)&__path[24];
        }
        v751 = *((_OWORD *)this + 1);
        *((_QWORD *)this + 2) = v748;
        *((_QWORD *)this + 3) = v741;
        *(_OWORD *)&__path[8] = v751;
        v752 = *((_QWORD *)this + 4);
        *((_QWORD *)this + 4) = v749;
        *(_QWORD *)&__path[24] = v752;
        *(_QWORD *)__path = v751;
        Reader_LibJPEG = (void *)std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer((uint64_t)__path);
        goto LABEL_869;
      }
LABEL_891:
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    }
  }
LABEL_870:
  v753 = IIO_ReaderHandler::copySupportedTypes((IIO_ReaderHandler *)Reader_LibJPEG);
  v754 = v753;
  if (v753)
  {
    Count = IIOArray::getCount(v753);
    _cg_jpeg_mem_term("buildPluginList", 1197, "*** 'com.apple.imageio.allowabletypes' - limiting plugins to '%d'\n", Count);
    v756 = *((_QWORD *)this + 2);
    if (v756 != *((_QWORD *)this + 3))
    {
      do
      {
        v757 = (const void *)IIO_Reader::utType(*(IIO_Reader **)v756);
        if ((IIOArray::containsValue(v754, v757) & 1) != 0)
        {
          v756 += 8;
          v758 = (_QWORD *)*((_QWORD *)this + 3);
        }
        else
        {
          std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::unique_ptr<IIO_Reader> *,std::unique_ptr<IIO_Reader> *,std::unique_ptr<IIO_Reader> *,0>((uint64_t *)(v756 + 8), *((uint64_t **)this + 3), (uint64_t *)v756);
          v758 = v759;
          v760 = (_QWORD *)*((_QWORD *)this + 3);
          while (v760 != v758)
          {
            v762 = *--v760;
            v761 = v762;
            *v760 = 0;
            if (v762)
              (*(void (**)(uint64_t))(*(_QWORD *)v761 + 8))(v761);
          }
          *((_QWORD *)this + 3) = v758;
        }
      }
      while ((_QWORD *)v756 != v758);
    }
  }
  if (v766)
    (*(void (**)(IIOArray *))(*(_QWORD *)v766 + 8))(v766);
  if (v754)
    (*(void (**)(IIOArray *))(*(_QWORD *)v754 + 8))(v754);
  v763 = (IIO_Reader **)*((_QWORD *)this + 2);
  v764 = (IIO_Reader **)*((_QWORD *)this + 3);
  if (v763 != v764)
  {
    v765 = *((_QWORD *)this + 1);
    do
    {
      if (v765 <= IIO_Reader::testHeaderSize(*v763))
        v765 = IIO_Reader::testHeaderSize(*v763);
      else
        v765 = *((_QWORD *)this + 1);
      *((_QWORD *)this + 1) = v765;
      ++v763;
    }
    while (v763 != v764);
  }
  kdebug_trace();
  _Block_object_dispose(&v771, 8);
}

void sub_187E693E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  uint64_t v28;

  MEMORY[0x18D761C30](v28, 0x10F1C409D307853);
  IIODictionary::~IIODictionary((IIODictionary *)&a12);
  _Block_object_dispose(&a28, 8);
  _Unwind_Resume(a1);
}

IIO_Reader *IIO_ReaderHandler::readerForBytesImp(IIO_Reader ***this, uint64_t a2, unint64_t a3, const __CFString *a4, unint64_t a5, unsigned int a6, uint64_t a7, int *a8)
{
  IIO_Reader *v15;
  IIO_Reader *v16;
  uint64_t v17;
  int v18;
  IIO_Reader **v19;
  IIO_Reader **v20;
  uint64_t v21;
  const char *v22;
  _BYTE v24[24];

  if (a4)
  {
    v15 = IIO_ReaderHandler::readerForUTType((IIO_ReaderHandler *)this, a4);
    v16 = v15;
    if (v15)
    {
      if (a5 && IIO_Reader::minimumFileSize(v15) <= a5
        || (v17 = IIO_Reader::minimumFileSize(v16), (a6 & 1) != 0)
        || !v17)
      {
        if (IIO_Reader::testHeaderSize(v16) <= a3
          && ((*(uint64_t (**)(IIO_Reader *, uint64_t, unint64_t, const __CFString *, _QWORD))(*(_QWORD *)v16 + 16))(v16, a2, a3, a4, a6) & 1) != 0)
        {
          v18 = 0;
          if (!a8)
            return v16;
          goto LABEL_26;
        }
      }
    }
  }
  if ((a6 & 4) != 0)
  {
    IIOString::IIOString((IIOString *)v24, a4);
    v22 = (const char *)IIOString::utf8String((IIOString *)v24);
    _cg_jpeg_mem_term("readerForBytesImp", 399, "*** ERROR: hint ('%s') does not match image data - kCGImageSourceFailForDataNotMatchingHint was specified --> failing\n", v22);
    IIOString::~IIOString((IIOString *)v24);
    v16 = 0;
    v18 = -57;
    if (!a8)
      return v16;
LABEL_26:
    *a8 = v18;
    return v16;
  }
  v19 = this[2];
  v20 = this[3];
  if (v19 == v20)
  {
LABEL_20:
    v16 = 0;
    v18 = -50;
  }
  else
  {
    while (1)
    {
      if ((v16 = *v19, a5) && IIO_Reader::minimumFileSize(*v19) <= a5
        || (v21 = IIO_Reader::minimumFileSize(v16), (a6 & 1) != 0)
        || !v21)
      {
        if (IIO_Reader::testHeaderSize(v16) <= a3
          && ((*(uint64_t (**)(IIO_Reader *, uint64_t, unint64_t, const __CFString *, _QWORD))(*(_QWORD *)v16 + 16))(v16, a2, a3, a4, a6) & 1) != 0)
        {
          break;
        }
      }
      if (++v19 == v20)
        goto LABEL_20;
    }
    v18 = 0;
  }
  if (!v16)
    v18 = -63;
  if (a8)
    goto LABEL_26;
  return v16;
}

void sub_187E69678(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  uint64_t v10;

  __cxa_begin_catch(a1);
  __cxa_end_catch();
  if (!v10)
    JUMPOUT(0x187E6964CLL);
  JUMPOUT(0x187E69648);
}

uint64_t IIOReader_RawCamera::testHeader(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t (*v4)(uint64_t, unint64_t, uint64_t);

  v4 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t))(a1 + 72);
  if (v4 && *(_QWORD *)(a1 + 32) <= a3)
    return v4(a2, a3, a4);
  else
    return 0;
}

BOOL IIO_Reader_PNG::testHeader(uint64_t a1, unsigned __int8 *a2)
{
  return *a2 == 137
      && a2[1] == 80
      && a2[2] == 78
      && a2[3] == 71
      && a2[4] == 13
      && a2[5] == 10
      && a2[6] == 26
      && a2[7] == 10;
}

uint64_t IIO_Reader_AppleJPEG::testHeader(int a1, unsigned __int8 *a2, int a3, CFStringRef theString1, unsigned int a5)
{
  uint64_t result;
  int v6;
  int v7;

  if (*a2 != 255 || a2[1] != 216 || a2[2] != 255)
    return 0;
  v6 = (a5 >> 3) & 3;
  v7 = v6 ? -1 : 0;
  if (v6 == 1)
    v7 = 1;
  if (!v7)
    return 0;
  if (v7 != 255
    || a2[3] != 224
    || a2[4]
    || a2[5] != 20
    || a2[20] != 65
    || a2[21] != 77
    || a2[22] != 80
    || a2[23] != 70)
  {
    return 1;
  }
  result = 0;
  if ((a5 & 4) != 0 && !v6)
  {
    if (CFStringCompare(theString1, CFSTR("public.jpeg"), 0) == kCFCompareEqualTo)
    {
      LogError("testHeader", 74, "*** JPEG with aux-image + 'fail-for-non-matching-hint are not compatible' - ignoring aux-image\n");
      return 1;
    }
    return 0;
  }
  return result;
}

BOOL IIO_Reader_ASTC::testHeader(IIO_ReaderHandler *a1, _DWORD *a2, unint64_t a3, uint64_t a4, unsigned int a5)
{
  __CFString **v6;
  IIO_ReaderHandler *ReaderHandler;
  IIO_Reader *v11;
  _BOOL8 result;
  IIO_ReaderHandler *v13;
  IIO_Reader *v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;

  v6 = (__CFString **)*((_QWORD *)a1 + 1);
  if (v6 == kCGImageTypeIdentifierASTC)
    return *a2 == 1554098963;
  if (v6 != kCGImageTypeIdentifierKTX)
  {
    if (a3 < 0x51)
      return 0;
    if (v6 != kCGImageTypeIdentifierKTX2)
      return 0;
    ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(a1);
    v11 = IIO_ReaderHandler::readerForType(ReaderHandler, 1263818802);
    return (*(unsigned int (**)(IIO_Reader *, _DWORD *, unint64_t, uint64_t, _QWORD))(*(_QWORD *)v11 + 16))(v11, a2, a3, a4, a5)&& IsASTC(a2[3]);
  }
  if (a3 < 0x41)
    return 0;
  v13 = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(a1);
  v14 = IIO_ReaderHandler::readerForType(v13, 1263818784);
  if (!v14
    || !(*(unsigned int (**)(IIO_Reader *, _DWORD *, unint64_t, uint64_t, _QWORD))(*(_QWORD *)v14 + 16))(v14, a2, a3, a4, a5))
  {
    return 0;
  }
  v15 = a2[3];
  v16 = a2[4];
  v17 = bswap32(v16);
  if (v15 != 67305985)
    v16 = v17;
  if (v16)
    return 0;
  v18 = bswap32(a2[7]);
  v19 = v15 == 67305985 ? a2[7] : v18;
  result = 1;
  if (v19 >> 2 != 8855 && v19 - 37886 >= 0x10 && v19 - 37808 >= 0xE && v19 - 37840 >= 0xE)
    return 0;
  return result;
}

BOOL IIO_Reader_KTX::testHeader(int a1, unsigned __int8 *a2)
{
  return IsKTXHeader(a2);
}

BOOL IsKTXHeader(const unsigned __int8 *a1)
{
  return *a1 == 171
      && a1[1] == 75
      && a1[2] == 84
      && a1[3] == 88
      && a1[4] == 32
      && a1[5] == 49
      && a1[6] == 49
      && a1[7] == 187
      && a1[8] == 13
      && a1[9] == 10
      && a1[10] == 26
      && a1[11] == 10;
}

BOOL IIO_Reader_KTX2::testHeader(int a1, unsigned __int8 *a2)
{
  return IsKTX2Header(a2);
}

BOOL IsKTX2Header(const unsigned __int8 *a1)
{
  return *a1 == 171
      && a1[1] == 75
      && a1[2] == 84
      && a1[3] == 88
      && a1[4] == 32
      && a1[5] == 50
      && a1[6] == 48
      && a1[7] == 187
      && a1[8] == 13
      && a1[9] == 10
      && a1[10] == 26
      && a1[11] == 10;
}

BOOL IIO_Reader_PVR::testHeader(IIO_ReaderHandler *a1, unsigned __int8 *a2, unint64_t a3, uint64_t a4, unsigned int a5)
{
  __CFString **v6;
  IIO_ReaderHandler *v10;
  IIO_Reader *v11;
  int v12;
  IIO_ReaderHandler *ReaderHandler;
  IIO_Reader *v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  BOOL v19;
  int v20;

  v6 = (__CFString **)*((_QWORD *)a1 + 1);
  if (v6 == kCGImageTypeIdentifierPVR)
  {
    if (a2[44] == 80 && a2[45] == 86 && a2[46] == 82 && a2[47] == 33)
    {
      v12 = *a2;
      if (v12 == 52)
        return 1;
    }
    else
    {
      v12 = *a2;
    }
    return v12 == 80 && a2[1] == 86 && a2[2] == 82 && a2[3] == 3;
  }
  if (v6 == kCGImageTypeIdentifierKTX)
  {
    if (a3 < 0x40)
      return 0;
    ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(a1);
    v14 = IIO_ReaderHandler::readerForType(ReaderHandler, 1263818784);
    if (!v14
      || !(*(unsigned int (**)(IIO_Reader *, unsigned __int8 *, unint64_t, uint64_t, _QWORD))(*(_QWORD *)v14 + 16))(v14, a2, a3, a4, a5))
    {
      return 0;
    }
    v15 = *((_DWORD *)a2 + 3);
    v16 = *((_DWORD *)a2 + 4);
    v17 = bswap32(v16);
    v18 = bswap32(*((_DWORD *)a2 + 7));
    v19 = v15 == 67305985;
    v20 = v15 == 67305985 ? *((_DWORD *)a2 + 7) : v18;
    if (!v19)
      v16 = v17;
    return !v16 && (v20 & 0xFFFFFFFC) == 0x8C00;
  }
  if (a3 >= 0x50 && v6 == kCGImageTypeIdentifierKTX2)
  {
    v10 = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(a1);
    v11 = IIO_ReaderHandler::readerForType(v10, 1263818802);
    if ((*(unsigned int (**)(IIO_Reader *, unsigned __int8 *, unint64_t, uint64_t, _QWORD))(*(_QWORD *)v11 + 16))(v11, a2, a3, a4, a5))
    {
      if (IsPVRTC1(*((_DWORD *)a2 + 3)))
        return 1;
    }
  }
  return 0;
}

BOOL IIO_Reader_BC::testHeader(IIO_Reader_ETC *a1, unsigned __int8 *a2, unint64_t a3, uint64_t a4, unsigned int a5)
{
  __CFString **v6;
  IIO_ReaderHandler *ReaderHandler;
  IIO_Reader *v11;
  unsigned int v12;
  BOOL v13;
  int v14;
  BOOL v15;
  unint64_t v16;
  unsigned int v17;
  BOOL v18;
  _BOOL8 result;
  IIO_ReaderHandler *v20;
  IIO_Reader *v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;

  v6 = (__CFString **)*((_QWORD *)a1 + 1);
  if (v6 == kCGImageTypeIdentifierBMP)
  {
    if (a2[1] > 1u)
      return 0;
    v12 = a2[2];
    v13 = v12 > 0xB;
    v14 = (1 << v12) & 0xE0E;
    v15 = v13 || v14 == 0;
    if (v15 || a2[7] > 0x20u || !a2[12] && !a2[13])
      return 0;
    if (!a2[14] && !a2[15])
      return 0;
    HIDWORD(v16) = a2[16];
    LODWORD(v16) = (HIDWORD(v16) << 24) - 0x8000000;
    return (v16 >> 27) <= 3u && a2[17] < 0x40u;
  }
  if (v6 == kCGImageTypeIdentifierBC)
  {
    if (a3 < 0x80 || !IIO_Reader_ETC::isInDDSContainer(a1, a2))
      return 0;
    v17 = bswap32(*((_DWORD *)a2 + 21));
    v18 = v17 - 1146639409 < 5 || v17 == 1146630448;
    return v18 || !v17 && (a2[80] & 0x40) != 0;
  }
  if (v6 != kCGImageTypeIdentifierKTX)
  {
    if (a3 < 0x50)
      return 0;
    if (v6 != kCGImageTypeIdentifierKTX2)
      return 0;
    ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(a1);
    v11 = IIO_ReaderHandler::readerForType(ReaderHandler, 1263818802);
    return (*(unsigned int (**)(IIO_Reader *, unsigned __int8 *, unint64_t, uint64_t, _QWORD))(*(_QWORD *)v11 + 16))(v11, a2, a3, a4, a5)&& IsBCn(*((_DWORD *)a2 + 3));
  }
  if (a3 < 0x40)
    return 0;
  v20 = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(a1);
  v21 = IIO_ReaderHandler::readerForType(v20, 1263818784);
  if (!v21
    || !(*(unsigned int (**)(IIO_Reader *, unsigned __int8 *, unint64_t, uint64_t, _QWORD))(*(_QWORD *)v21 + 16))(v21, a2, a3, a4, a5))
  {
    return 0;
  }
  v22 = *((_DWORD *)a2 + 3);
  v23 = *((_DWORD *)a2 + 4);
  v24 = bswap32(v23);
  if (v22 != 67305985)
    v23 = v24;
  if (v23)
    return 0;
  v25 = bswap32(*((_DWORD *)a2 + 7));
  if (v22 == 67305985)
    v26 = *((_DWORD *)a2 + 7);
  else
    v26 = v25;
  if (v26 - 36283 < 4)
    return 1;
  v27 = v26 & 0xFFFFFFFC;
  result = 1;
  if (v27 != 33776 && v27 != 35916 && v27 != 36492)
    return 0;
  return result;
}

BOOL IIO_Reader_ETC::testHeader(IIO_Reader_ETC *a1, unsigned __int8 *a2, unint64_t a3, uint64_t a4, unsigned int a5)
{
  __CFString **v7;
  IIO_ReaderHandler *v10;
  IIO_Reader *v11;
  unsigned int v12;
  BOOL v13;
  IIO_ReaderHandler *ReaderHandler;
  IIO_Reader *v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;

  v7 = (__CFString **)*((_QWORD *)a1 + 1);
  if (v7 == kCGImageTypeIdentifierBC)
  {
    if (a3 < 0x80 || !IIO_Reader_ETC::isInDDSContainer(a1, a2))
      return 0;
    v12 = bswap32(*((_DWORD *)a2 + 21));
    v13 = v12 - 1146639409 < 5 || v12 == 1146630448;
    return v13 || !v12 && (a2[80] & 0x40) != 0;
  }
  if (v7 == kCGImageTypeIdentifierKTX)
  {
    if (a3 < 0x40)
      return 0;
    ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(a1);
    v16 = IIO_ReaderHandler::readerForType(ReaderHandler, 1263818784);
    if (!v16
      || !(*(unsigned int (**)(IIO_Reader *, unsigned __int8 *, unint64_t, uint64_t, _QWORD))(*(_QWORD *)v16 + 16))(v16, a2, a3, a4, a5))
    {
      return 0;
    }
    v17 = *((_DWORD *)a2 + 4);
    v18 = bswap32(v17);
    v19 = bswap32(*((_DWORD *)a2 + 7));
    if (*((_DWORD *)a2 + 3) == 67305985)
    {
      v20 = *((_DWORD *)a2 + 7);
    }
    else
    {
      v17 = v18;
      v20 = v19;
    }
    return !v17 && v20 - 37498 >= 0xFFFFFFF6;
  }
  if (a3 >= 0x50 && v7 == kCGImageTypeIdentifierKTX2)
  {
    v10 = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(a1);
    v11 = IIO_ReaderHandler::readerForType(v10, 1263818802);
    if ((*(unsigned int (**)(IIO_Reader *, unsigned __int8 *, unint64_t, uint64_t, _QWORD))(*(_QWORD *)v11 + 16))(v11, a2, a3, a4, a5))
    {
      if (IsETC(*((_DWORD *)a2 + 3)))
        return 1;
    }
  }
  return 0;
}

uint64_t std::__split_buffer<std::unique_ptr<IIO_Reader>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;
    v4 = *(_QWORD *)(i - 8);
    *(_QWORD *)(i - 8) = 0;
    if (v4)
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

BOOL IIO_Reader_ATX::testHeader(uint64_t a1, _BYTE *a2)
{
  return *a2 == 65
      && a2[1] == 65
      && a2[2] == 80
      && a2[3] == 76
      && a2[4] == 13
      && a2[5] == 10
      && a2[6] == 26
      && a2[7] == 10;
}

BOOL IIO_Reader_TIFF::testHeader(uint64_t a1, unsigned __int8 *a2)
{
  int v2;

  v2 = *a2;
  if (v2 == 73)
    return a2[1] == 73
        && (a2[2] != 42 || a2[3] || a2[8] != 67 || a2[9] != 82 || a2[10] != 2 || a2[11])
        && (a2[2] & 0xFE) == 0x2A
        && !a2[3];
  return v2 == 77
      && a2[1] == 77
      && (a2[2] || a2[3] != 42 || a2[8] != 186 || a2[9] != 176 || a2[10] != 172 || a2[11] != 187)
      && !a2[2]
      && (a2[3] & 0xFE) == 0x2A;
}

BOOL IIO_Reader_GIF::testHeader(uint64_t a1, _BYTE *a2)
{
  int v2;
  _BOOL8 result;

  result = *a2 == 71
        && a2[1] == 73
        && a2[2] == 70
        && a2[3] == 56
        && ((v2 = a2[4], v2 == 57) || v2 == 55)
        && a2[5] == 97;
  return result;
}

BOOL IIO_Reader_JP2::testHeader(uint64_t a1, unsigned __int8 *a2)
{
  int v2;
  uint64_t v3;

  if (*a2 == 255)
  {
    if (a2[1] == 79 && a2[2] == 255)
    {
      v2 = 81;
      v3 = 3;
      return a2[v3] == v2;
    }
    return 0;
  }
  if (*a2
    || a2[1]
    || a2[2]
    || a2[3] != 12
    || a2[4] != 106
    || a2[5] != 80
    || a2[8] != 13
    || a2[9] != 10
    || a2[10] != 135)
  {
    return 0;
  }
  v2 = 10;
  v3 = 11;
  return a2[v3] == v2;
}

IIO_Reader *IIO_ReaderHandler::readerForUTType(IIO_ReaderHandler *this, const __CFString *a2)
{
  IIO_Reader **v2;
  IIO_Reader **v3;
  const __CFString *v5;

  v2 = (IIO_Reader **)*((_QWORD *)this + 2);
  v3 = (IIO_Reader **)*((_QWORD *)this + 3);
  if (v2 == v3)
    return 0;
  while (1)
  {
    v5 = (const __CFString *)IIO_Reader::utType(*v2);
    if (CFStringCompare(v5, a2, 0) == kCFCompareEqualTo)
      break;
    if (++v2 == v3)
      return 0;
  }
  return *v2;
}

uint64_t IIO_OSAppleInternalBuild()
{
  if (IIO_OSAppleInternalBuild::predicate != -1)
    dispatch_once(&IIO_OSAppleInternalBuild::predicate, &__block_literal_global_19);
  return IIO_OSAppleInternalBuild::is_internal;
}

uint64_t IIOArray::enumerate(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 8);
  if (result)
    return IIOArrayEnumerateUsingBlock(result, a2);
  return result;
}

BOOL IIO_Reader_ICNS::testHeader(uint64_t a1, _BYTE *a2)
{
  return *a2 == 105 && a2[1] == 99 && a2[2] == 110 && a2[3] == 115;
}

BOOL IIO_Reader_RAD::testHeader(uint64_t a1, _BYTE *a2)
{
  return *a2 == 35
      && a2[1] == 63
      && (a2[2] == 82
       && a2[3] == 65
       && a2[4] == 68
       && a2[5] == 73
       && a2[6] == 65
       && a2[7] == 78
       && a2[8] == 67
       && a2[9] == 69
       || a2[2] == 82 && a2[3] == 71 && a2[4] == 66 && a2[5] == 69);
}

BOOL IIO_Reader_PSD::testHeader(uint64_t a1, _BYTE *a2)
{
  return *a2 == 56
      && a2[1] == 66
      && a2[2] == 80
      && a2[3] == 83
      && !a2[4]
      && a2[5] - 1 < 2;
}

BOOL IIO_Reader_ICO::testHeader(uint64_t a1, _BYTE *a2)
{
  _BOOL8 result;
  unsigned int v3;

  result = 0;
  if (!*a2 && !a2[1] && a2[2] == 1 && !a2[3])
  {
    if (a2[4])
    {
      if (!a2[5]
        && a2[6] - 12 <= 0xFFFFFFF4
        && a2[7] - 12 <= 0xFFFFFFF4)
      {
        v3 = a2[12];
        if (v3 <= 0x20 && ((1 << v3) & 0x101000113) != 0 && !a2[13])
          return 1;
      }
    }
  }
  return result;
}

BOOL IIO_Reader_AI::testHeader(int a1, _BYTE *a2, int a3, CFStringRef theString1)
{
  if (!theString1)
    return 0;
  return CFStringCompare(theString1, CFSTR("com.adobe.illustrator.ai-image"), 0) == kCFCompareEqualTo
      && *a2 == 37
      && a2[1] == 80
      && a2[2] == 68
      && a2[3] == 70
      && a2[4] == 45;
}

BOOL IIO_Reader_OpenEXR::testHeader(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _BOOL8 result;

  result = AppleEXREnabled();
  if (result)
    return gFunc_axr_introspect_data(a2, a3, 0) == 0;
  return result;
}

BOOL IIO_Reader_LibJPEG::testHeader(uint64_t a1, unsigned __int8 *a2)
{
  return *a2 == 255 && a2[1] == 216 && a2[2] == 255;
}

BOOL IIO_Reader_WebP::testHeader(uint64_t a1, _BYTE *a2)
{
  return *a2 == 82
      && a2[1] == 73
      && a2[2] == 70
      && a2[3] == 70
      && a2[8] == 87
      && a2[9] == 69
      && a2[10] == 66
      && a2[11] == 80;
}

BOOL IIO_Reader_TGA::testHeader(uint64_t a1, unsigned __int8 *a2)
{
  unsigned int v2;
  BOOL v3;
  int v4;
  BOOL v5;
  unsigned int v6;
  _BOOL8 result;

  result = 0;
  if (a2[1] <= 1u)
  {
    v2 = a2[2];
    v3 = v2 > 0xB;
    v4 = (1 << v2) & 0xE0E;
    v5 = v3 || v4 == 0;
    if (!v5 && a2[7] <= 0x20u && (a2[12] || a2[13]) && (a2[14] || a2[15]))
    {
      v6 = a2[16];
      if (v6 <= 0x20 && ((1 << v6) & 0x101018100) != 0 && a2[17] < 0x40u)
        return 1;
    }
  }
  return result;
}

BOOL IIO_Reader_PDF::testHeader(int a1, uint64_t a2, unint64_t a3, CFStringRef theString1)
{
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  unsigned int v11;

  if (theString1 && CFStringCompare(theString1, CFSTR("com.adobe.pdf"), 0) == kCFCompareEqualTo)
  {
    v11 = 1024;
    if (a3 < 0x400)
      v11 = a3;
    if (v11 < 6)
      return 0;
    v6 = v11 - 5;
  }
  else
  {
    v6 = 5;
  }
  v7 = 0;
  v8 = a2 + 2;
  v9 = 1;
  do
  {
    if (*(_BYTE *)(a2 + v7) == 37
      && *(_BYTE *)(v8 + v7 - 1) == 80
      && *(_BYTE *)(v8 + v7) == 68
      && *(_BYTE *)(v8 + v7 + 1) == 70
      && *(_BYTE *)(v8 + v7 + 2) == 45)
    {
      break;
    }
    v9 = ++v7 < (unint64_t)v6;
  }
  while (v6 != v7);
  return v9;
}

BOOL IIO_Reader_MPO::testHeader(uint64_t a1, unsigned __int8 *a2)
{
  return *a2 == 255 && a2[1] == 216 && a2[2] == 255 && (a2[3] & 0xF0) == 0xE0;
}

BOOL IIO_Reader_CUR::testHeader(uint64_t a1, _BYTE *a2)
{
  return !*a2 && !a2[1] && a2[2] == 2 && !a2[3] && a2[4] && !a2[5];
}

BOOL IIO_Reader_BMP::testHeader(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  BOOL v3;
  _BOOL8 result;

  result = 0;
  if (*(_BYTE *)a2 == 66 && *(_BYTE *)(a2 + 1) == 77)
  {
    v2 = *(unsigned int *)(a2 + 14);
    v3 = (v2 - 12) > 0x34 || ((1 << (v2 - 12)) & 0x10110010000011) == 0;
    if ((!v3 || (_DWORD)v2 == 124 || (_DWORD)v2 == 108) && v2 + 14 <= (unint64_t)*(unsigned int *)(a2 + 10))
      return 1;
  }
  return result;
}

BOOL IIO_Reader_ETC::isInDDSContainer(IIO_Reader_ETC *this, const unsigned __int8 *a2)
{
  return *a2 == 68 && a2[1] == 68 && a2[2] == 83 && a2[3] == 32 && a2[4] == 124 && !a2[5] && !a2[6] && !a2[7];
}

BOOL AppleEXREnabled(void)
{
  if (AppleEXREnabled(void)::onceToken != -1)
    dispatch_once(&AppleEXREnabled(void)::onceToken, &__block_literal_global_0);
  return (gAppleEXREnabled & 1) == 0;
}

IIO_Reader *CreateReader_GIF(void)
{
  IIO_Reader *v0;

  v0 = (IIO_Reader *)operator new();
  IIO_Reader::IIO_Reader(v0, (const __CFString *const *)kCGImageTypeIdentifierGIF, ".gif.", 1195984416, 18, 0);
  *(_QWORD *)v0 = &off_1E1BAE8E8;
  return v0;
}

void sub_187E6AAE8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void IIOArray::~IIOArray(IIOArray *this)
{
  IIOArray::~IIOArray(this);
  JUMPOUT(0x18D761C30);
}

{
  const void *v1;

  *(_QWORD *)this = &off_1E1BB2B40;
  v1 = (const void *)*((_QWORD *)this + 1);
  if (v1)
    CFRelease(v1);
}

IIOArray *IIO_ReaderHandler::copySupportedTypes(IIO_ReaderHandler *this)
{
  __SecTask *v1;
  __SecTask *v2;
  const __CFArray *v3;
  const __CFArray *v4;
  CFTypeID v5;
  IIOArray *v6;
  _QWORD v8[5];
  _QWORD v9[3];

  if ((IIO_XPCServer() & 1) != 0)
    return 0;
  v1 = SecTaskCreateFromSelf((CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
  if (!v1)
    return 0;
  v2 = v1;
  v3 = (const __CFArray *)SecTaskCopyValueForEntitlement(v1, CFSTR("com.apple.imageio.allowabletypes"), 0);
  if (v3)
  {
    v4 = v3;
    v5 = CFGetTypeID(v3);
    if (v5 == CFArrayGetTypeID())
    {
      v6 = (IIOArray *)operator new();
      IIOArray::IIOArray(v6);
      memset(v9, 0, sizeof(v9));
      IIOArray::IIOArray((IIOArray *)v9, v4);
      v8[0] = MEMORY[0x1E0C809B0];
      v8[1] = 0x40000000;
      v8[2] = ___ZN17IIO_ReaderHandler18copySupportedTypesEv_block_invoke;
      v8[3] = &__block_descriptor_tmp_33_1;
      v8[4] = v6;
      IIOArray::enumerate((uint64_t)v9, (uint64_t)v8);
      IIOArray::~IIOArray((IIOArray *)v9);
    }
    else
    {
      v6 = 0;
    }
    CFRelease(v4);
  }
  else
  {
    v6 = 0;
  }
  CFRelease(v2);
  return v6;
}

void sub_187E6AC48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  IIOArray::~IIOArray((IIOArray *)va);
  _Unwind_Resume(a1);
}

IIO_Reader *CreateReader_KTX2_ASTC(void)
{
  IIO_Reader *v0;

  v0 = (IIO_Reader *)operator new();
  IIO_Reader::IIO_Reader(v0, (const __CFString *const *)kCGImageTypeIdentifierKTX2, ".ktx2.", 1261584724, 32, 0);
  *(_QWORD *)v0 = &off_1E1BB0270;
  IIO_Reader::setAddToTypeIdentifiers((uint64_t)v0, 0);
  return v0;
}

void sub_187E6ACF0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

uint64_t CreateReader_HEIC_JPEG(void)
{
  uint64_t v0;

  IIODetermineHEIFSupport();
  if (!gHEIF_JPEG_DecodingSupported)
    return 0;
  v0 = operator new();
  IIO_Reader::IIO_Reader((IIO_Reader *)v0, (const __CFString *const *)kCGImageTypeIdentifierJPEG, ".jpg.jpeg.", 1212829767, 64, 0);
  *(_QWORD *)v0 = &off_1E1BB0390;
  *(_BYTE *)(v0 + 48) = *(_QWORD *)(v0 + 8) != (_QWORD)kCGImageTypeIdentifierJPEG;
  return v0;
}

void sub_187E6ADAC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

IIO_Reader *CreateReader_KTX_ASTC(void)
{
  IIO_Reader *v0;

  v0 = (IIO_Reader *)operator new();
  IIO_Reader::IIO_Reader(v0, (const __CFString *const *)kCGImageTypeIdentifierKTX, ".ktx.", 1262572372, 32, 0);
  *(_QWORD *)v0 = &off_1E1BB0270;
  IIO_Reader::setAddToTypeIdentifiers((uint64_t)v0, 0);
  return v0;
}

void sub_187E6AE44(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

IIO_Reader *CreateReader_KTX2_PVR(void)
{
  IIO_Reader *v0;

  v0 = (IIO_Reader *)operator new();
  IIO_Reader::IIO_Reader(v0, (const __CFString *const *)kCGImageTypeIdentifierKTX2, ".ktx2.", 1261588566, 84, 0);
  *(_QWORD *)v0 = &off_1E1BAF308;
  IIO_Reader::setAddToTypeIdentifiers((uint64_t)v0, 0);
  return v0;
}

void sub_187E6AEDC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

IIO_Reader *CreateReader_KTX2_ETC(void)
{
  IIO_Reader *v0;

  v0 = (IIO_Reader *)operator new();
  IIO_Reader::IIO_Reader(v0, (const __CFString *const *)kCGImageTypeIdentifierKTX2, ".ktx2.", 1261585748, 32, 0);
  *(_QWORD *)v0 = &off_1E1BAE7C8;
  IIO_Reader::setAddToTypeIdentifiers((uint64_t)v0, 0);
  return v0;
}

void sub_187E6AF74(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

IIO_Reader *CreateReader_LibJPEG(void)
{
  IIO_Reader *v0;

  v0 = (IIO_Reader *)operator new();
  IIO_Reader::IIO_Reader(v0, (const __CFString *const *)kCGImageTypeIdentifierJPEG, ".jpg.jpeg.jpe.jfif.jps.", 1279938631, 4, 0);
  *(_QWORD *)v0 = &off_1E1BB15A0;
  IIO_Reader::setAddToTypeIdentifiers((uint64_t)v0, 0);
  return v0;
}

void sub_187E6B00C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

IIO_Reader *CreateReader_KTX_PVR(void)
{
  IIO_Reader *v0;

  v0 = (IIO_Reader *)operator new();
  IIO_Reader::IIO_Reader(v0, (const __CFString *const *)kCGImageTypeIdentifierKTX, ".ktx.", 1263556178, 84, 0);
  *(_QWORD *)v0 = &off_1E1BAF308;
  IIO_Reader::setAddToTypeIdentifiers((uint64_t)v0, 0);
  return v0;
}

void sub_187E6B0A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

IIO_Reader *CreateReader_KTX_ETC(void)
{
  IIO_Reader *v0;

  v0 = (IIO_Reader *)operator new();
  IIO_Reader::IIO_Reader(v0, (const __CFString *const *)kCGImageTypeIdentifierKTX, ".ktx.", 1262834755, 32, 0);
  *(_QWORD *)v0 = &off_1E1BAE7C8;
  IIO_Reader::setAddToTypeIdentifiers((uint64_t)v0, 0);
  return v0;
}

void sub_187E6B13C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

IIO_Reader *CreateReader_KTX_BC(void)
{
  IIO_Reader *v0;

  v0 = (IIO_Reader *)operator new();
  IIO_Reader::IIO_Reader(v0, (const __CFString *const *)kCGImageTypeIdentifierKTX, ".ktx.", 1262633838, 32, 0);
  *(_QWORD *)v0 = &off_1E1BAD048;
  IIO_Reader::setAddToTypeIdentifiers((uint64_t)v0, 0);
  return v0;
}

void sub_187E6B1D4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

uint64_t CreateReader_JPEGXL(void)
{
  uint64_t v0;

  IIODetermineHEIFSupport();
  if (!gHEIF_JPEGXL_DecodingSupported)
    return 0;
  v0 = operator new();
  IIO_Reader::IIO_Reader((IIO_Reader *)v0, (const __CFString *const *)kCGImageTypeIdentifierJPEGXL, ".jxl.", 1247300640, 12, 0);
  *(_QWORD *)v0 = &off_1E1BB0390;
  *(_BYTE *)(v0 + 48) = *(_QWORD *)(v0 + 8) != (_QWORD)kCGImageTypeIdentifierJPEG;
  return v0;
}

void sub_187E6B294(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

IIO_Reader *CreateReader_DDS_BC(void)
{
  IIO_Reader *v0;

  v0 = (IIO_Reader *)operator new();
  IIO_Reader::IIO_Reader(v0, (const __CFString *const *)kCGImageTypeIdentifierBC, ".dds.", 1145193326, 32, 0);
  *(_QWORD *)v0 = &off_1E1BAD048;
  return v0;
}

void sub_187E6B320(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

uint64_t CreateReader_HEICS(void)
{
  uint64_t v0;

  IIODetermineHEIFSupport();
  if (!gHEIF_HEVC_DecodingSupported)
    return 0;
  v0 = operator new();
  IIO_Reader::IIO_Reader((IIO_Reader *)v0, (const __CFString *const *)kCGImageTypeIdentifierHEICS, ".heics.", 1212500307, 64, 0);
  *(_QWORD *)v0 = &off_1E1BB0390;
  *(_BYTE *)(v0 + 48) = *(_QWORD *)(v0 + 8) != (_QWORD)kCGImageTypeIdentifierJPEG;
  return v0;
}

void sub_187E6B3E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

IIO_Reader *CreateReader_WebP(void)
{
  IIO_Reader *v0;

  v0 = (IIO_Reader *)operator new();
  IIO_Reader::IIO_Reader(v0, (const __CFString *const *)kCGImageTypeIdentifierWEBP, ".webp.", 1464156752, 18, 0);
  *(_QWORD *)v0 = &off_1E1BB0818;
  return v0;
}

void sub_187E6B46C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C408A822D94);
  _Unwind_Resume(a1);
}

IIO_Reader *CreateReader_TIFF(void)
{
  IIO_Reader *v0;

  v0 = (IIO_Reader *)operator new();
  IIO_Reader::IIO_Reader(v0, (const __CFString *const *)kCGImageTypeIdentifierTIFF, ".tiff.tif.fax.g3.jfx.jfax.efx.", 1414088262, 46, 0);
  *(_QWORD *)v0 = &off_1E1BB06F8;
  return v0;
}

void sub_187E6B4F8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

uint64_t IIOLookupISR()
{
  return 0;
}

IIO_Reader *CreateReader_KTX2(void)
{
  IIO_Reader *v0;

  v0 = (IIO_Reader *)operator new();
  IIO_Reader::IIO_Reader(v0, (const __CFString *const *)kCGImageTypeIdentifierKTX2, ".ktx2.", 1263818802, 32, 0);
  *(_QWORD *)v0 = &off_1E1BB05D8;
  return v0;
}

void sub_187E6B58C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

IIO_Reader *CreateReader_ICNS(void)
{
  IIO_Reader *v0;

  v0 = (IIO_Reader *)operator new();
  IIO_Reader::IIO_Reader(v0, (const __CFString *const *)kCGImageTypeIdentifierICNS, ".icns.", 1229147731, 4, 0);
  *(_QWORD *)v0 = &off_1E1BB04B8;
  return v0;
}

void sub_187E6B618(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

uint64_t CreateReader_HEIF(void)
{
  uint64_t v0;

  IIODetermineHEIFSupport();
  if (!gHEIF_JPEG_DecodingSupported)
    return 0;
  v0 = operator new();
  IIO_Reader::IIO_Reader((IIO_Reader *)v0, (const __CFString *const *)kCGImageTypeIdentifierHEIF, ".heif.", 1212500294, 64, 0);
  *(_QWORD *)v0 = &off_1E1BB0390;
  *(_BYTE *)(v0 + 48) = *(_QWORD *)(v0 + 8) != (_QWORD)kCGImageTypeIdentifierJPEG;
  return v0;
}

void sub_187E6B6D8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

uint64_t CreateReader_HEIC(void)
{
  uint64_t v0;

  IIODetermineHEIFSupport();
  if (!gHEIF_HEVC_DecodingSupported)
    return 0;
  v0 = operator new();
  IIO_Reader::IIO_Reader((IIO_Reader *)v0, (const __CFString *const *)kCGImageTypeIdentifierHEIC, ".heic.hif.", 1212500291, 64, 0);
  *(_QWORD *)v0 = &off_1E1BB0390;
  *(_BYTE *)(v0 + 48) = *(_QWORD *)(v0 + 8) != (_QWORD)kCGImageTypeIdentifierJPEG;
  return v0;
}

void sub_187E6B798(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

uint64_t CreateReader_AVIS(void)
{
  uint64_t v0;

  IIODetermineHEIFSupport();
  if (!gHEIF_AVIF_DecodingSupported)
    return 0;
  v0 = operator new();
  IIO_Reader::IIO_Reader((IIO_Reader *)v0, (const __CFString *const *)kCGImageTypeIdentifierAVIS, ".avis.", 1096173907, 64, 0);
  *(_QWORD *)v0 = &off_1E1BB0390;
  *(_BYTE *)(v0 + 48) = *(_QWORD *)(v0 + 8) != (_QWORD)kCGImageTypeIdentifierJPEG;
  return v0;
}

void sub_187E6B858(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

uint64_t CreateReader_AVIF(void)
{
  uint64_t v0;

  IIODetermineHEIFSupport();
  if (!gHEIF_AVIF_DecodingSupported)
    return 0;
  v0 = operator new();
  IIO_Reader::IIO_Reader((IIO_Reader *)v0, (const __CFString *const *)kCGImageTypeIdentifierAVIF, ".avif.", 1096173894, 64, 0);
  *(_QWORD *)v0 = &off_1E1BB0390;
  *(_BYTE *)(v0 + 48) = *(_QWORD *)(v0 + 8) != (_QWORD)kCGImageTypeIdentifierJPEG;
  return v0;
}

void sub_187E6B918(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

IIO_Reader *CreateReader_ASTC(void)
{
  IIO_Reader *v0;

  v0 = (IIO_Reader *)operator new();
  IIO_Reader::IIO_Reader(v0, (const __CFString *const *)kCGImageTypeIdentifierASTC, ".astc.", 1095980099, 32, 0);
  *(_QWORD *)v0 = &off_1E1BB0270;
  return v0;
}

void sub_187E6B9A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

IIO_Reader *CreateReader_TGA(void)
{
  IIO_Reader *v0;

  v0 = (IIO_Reader *)operator new();
  IIO_Reader::IIO_Reader(v0, (const __CFString *const *)kCGImageTypeIdentifierTGA, ".tga.targa.", 1413955872, 18, 0);
  *(_QWORD *)v0 = &off_1E1BAF548;
  return v0;
}

void sub_187E6BA30(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

IIO_Reader *CreateReader_RAD(void)
{
  IIO_Reader *v0;

  v0 = (IIO_Reader *)operator new();
  IIO_Reader::IIO_Reader(v0, (const __CFString *const *)kCGImageTypeIdentifierRad, ".hdr.pic.", 1380008992, 10, 0);
  *(_QWORD *)v0 = &off_1E1BAF428;
  return v0;
}

void sub_187E6BABC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

IIO_Reader *CreateReader_PVR(void)
{
  IIO_Reader *v0;

  v0 = (IIO_Reader *)operator new();
  IIO_Reader::IIO_Reader(v0, (const __CFString *const *)kCGImageTypeIdentifierPVR, ".pvr.", 1347834400, 84, 0);
  *(_QWORD *)v0 = &off_1E1BAF308;
  return v0;
}

void sub_187E6BB48(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

IIO_Reader *CreateReader_PSD(void)
{
  IIO_Reader *v0;

  v0 = (IIO_Reader *)operator new();
  IIO_Reader::IIO_Reader(v0, (const __CFString *const *)kCGImageTypeIdentifierPSD, ".psd.psb.", 1347634208, 10, 0);
  *(_QWORD *)v0 = &off_1E1BAF1E8;
  return v0;
}

void sub_187E6BBD4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

IIO_Reader *CreateReader_PNG(void)
{
  IIO_Reader *v0;

  v0 = (IIO_Reader *)operator new();
  IIO_Reader::IIO_Reader(v0, (const __CFString *const *)kCGImageTypeIdentifierPNG, ".png.", 1347307296, 10, 0);
  *(_QWORD *)v0 = &off_1E1BAF0C8;
  return v0;
}

void sub_187E6BC60(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

IIO_Reader *CreateReader_PDF(void)
{
  IIO_Reader *v0;

  v0 = (IIO_Reader *)operator new();
  IIO_Reader::IIO_Reader(v0, (const __CFString *const *)kCGImageTypeIdentifierPDF, ".pdf.", 1346651680, 10, 0);
  *(_QWORD *)v0 = &off_1E1BAEFA8;
  IIO_Reader::setAddToTypeIdentifiers((uint64_t)v0, 0);
  return v0;
}

void sub_187E6BCF8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

IIO_Reader *CreateReader_PBM(void)
{
  IIO_Reader *v0;

  v0 = (IIO_Reader *)operator new();
  IIO_Reader::IIO_Reader(v0, (const __CFString *const *)kCGImageTypeIdentifierPBM, ".pbm.pgm.ppm.pfm.pam.", 1346522400, 10, 0);
  *(_QWORD *)v0 = &off_1E1BAEE88;
  return v0;
}

void sub_187E6BD84(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

IIO_Reader *CreateReader_MPO(void)
{
  IIO_Reader *v0;

  v0 = (IIO_Reader *)operator new();
  IIO_Reader::IIO_Reader(v0, (const __CFString *const *)kCGImageTypeIdentifierMPO, ".mpo.", 1297108768, 4, 0);
  *(_QWORD *)v0 = &off_1E1BAED68;
  return v0;
}

void sub_187E6BE10(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

IIO_Reader *CreateReader_KTX(void)
{
  IIO_Reader *v0;

  v0 = (IIO_Reader *)operator new();
  IIO_Reader::IIO_Reader(v0, (const __CFString *const *)kCGImageTypeIdentifierKTX, ".ktx.", 1263818784, 32, 0);
  *(_QWORD *)v0 = &off_1E1BAEC48;
  return v0;
}

void sub_187E6BE9C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

IIO_Reader *CreateReader_JP2(void)
{
  IIO_Reader *v0;

  v0 = (IIO_Reader *)operator new();
  IIO_Reader::IIO_Reader(v0, (const __CFString *const *)kCGImageTypeIdentifierJP2, ".jp2.jpf.j2k.j2c.", 1246769696, 12, 0);
  *(_QWORD *)v0 = &off_1E1BAEB28;
  return v0;
}

void sub_187E6BF28(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

IIO_Reader *CreateReader_ICO(void)
{
  IIO_Reader *v0;

  v0 = (IIO_Reader *)operator new();
  IIO_Reader::IIO_Reader(v0, (const __CFString *const *)kCGImageTypeIdentifierICO, ".ico.", 1229147936, 14, 0);
  *(_QWORD *)v0 = &off_1E1BAEA08;
  return v0;
}

void sub_187E6BFB4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

IIO_Reader *CreateReader_EXR(void)
{
  IIO_Reader *v0;

  v0 = (IIO_Reader *)operator new();
  IIO_Reader::IIO_Reader(v0, (const __CFString *const *)kCGImageTypeIdentifierOpenEXR, ".exr.", 1163416096, 18, 0);
  *(_QWORD *)v0 = &off_1E1BB16C0;
  return v0;
}

void sub_187E6C040(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

IIO_Reader *CreateReader_CUR(void)
{
  IIO_Reader *v0;

  v0 = (IIO_Reader *)operator new();
  IIO_Reader::IIO_Reader(v0, (const __CFString *const *)kCGImageTypeIdentifierCUR, ".cur.", 1129665056, 14, 0);
  *(_QWORD *)v0 = &off_1E1BAE6A8;
  return v0;
}

void sub_187E6C0CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

IIO_Reader *CreateReader_ATX(void)
{
  IIO_Reader *v0;

  v0 = (IIO_Reader *)operator new();
  IIO_Reader::IIO_Reader(v0, (const __CFString *const *)kCGImageTypeIdentifierATX, ".atx.", 1096046624, 8, 0);
  *(_QWORD *)v0 = &off_1E1BAE468;
  return v0;
}

void sub_187E6C158(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

uint64_t png_write_iCCP(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v5;
  int v8;
  uint64_t v9;
  const char *v11;
  _QWORD v12[2];
  _DWORD v13[258];
  Bytef v14[88];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (!a3)
  {
    v11 = "No profile for iCCP chunk";
    goto LABEL_15;
  }
  v5 = _byteswap_ulong(*(_DWORD *)a3);
  if (v5 <= 0x83)
  {
    v11 = "ICC profile too short";
    goto LABEL_15;
  }
  if ((*(_BYTE *)(a3 + 3) & 3) != 0 && *(unsigned __int8 *)(a3 + 8) >= 4u)
  {
    v11 = "ICC profile length invalid (not a multiple of 4)";
    goto LABEL_15;
  }
  memset(v14, 0, 81);
  bzero(v13, 0x408uLL);
  v8 = png_check_keyword(a1, a2, v14);
  if (!v8)
  {
    v11 = "iCCP: invalid keyword";
    goto LABEL_15;
  }
  v14[v8 + 1] = 0;
  v9 = (v8 + 2);
  v12[0] = a3;
  v12[1] = v5;
  v13[0] = 0;
  if (png_text_compress(a1, 1766015824, (uint64_t)v12, v9))
  {
    v11 = *(const char **)(a1 + 144);
LABEL_15:
    _cg_png_error((void (**)(void))a1, v11);
  }
  _cg_png_write_chunk_header(a1, 1766015824);
  _cg_png_write_chunk_data(a1, v14, v9);
  png_write_compressed_data_out(a1, (uint64_t)v12);
  return _cg_png_write_chunk_end(a1);
}

uint64_t PNGWritePlugin::writePNG(PNGWritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3)
{
  uint64_t Property;
  unsigned int BitmapInfo;
  vImagePixelCount v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t Error;
  unint64_t appleflags;
  IIOImagePlus *v13;
  unint64_t v14;
  unint64_t v15;
  CGColorSpace *SourceGeomColorSpace;
  char *v17;
  const char *v18;
  IIODictionary *v19;
  size_t rowbytes;
  char *v21;
  const __CFDictionary *ObjectForKey;
  const __CFData *v23;
  unint64_t v24;
  const UInt8 *BytePtr;
  unsigned int Length;
  uint64_t v27;
  Bytef *v28;
  unsigned int Uint32ForKey;
  unint64_t v30;
  Bytef *v31;
  char do_filter;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  Bytef *v37;
  int v38;
  uint64_t v39;
  void *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t Bytes;
  char *v47;
  unint64_t v48;
  char *v49;
  char *v50;
  uint64_t v51;
  vImagePixelCount v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  BOOL v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  vImage_Error v60;
  vImage_Error v61;
  char *v62;
  char *v63;
  vImagePixelCount i;
  unint64_t v65;
  unint64_t v66;
  unsigned int v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t v70;
  const void *v72;
  uint64_t v73;
  uint64_t v74;
  vImagePixelCount v75;
  unint64_t v76;
  uint64_t v77;
  int v78;
  CGColorSpaceModel Model;
  unint64_t v80;
  IIOImagePixelDataProvider *v81;
  unint64_t v82;
  int v83;
  int v84;
  unint64_t Size;
  vImage_Buffer src;
  unint64_t v87;
  unint64_t v88;
  char *v89;
  vImage_Buffer dest;
  uint64_t v91;

  v91 = *MEMORY[0x1E0C80C00];
  v89 = 0;
  v87 = 0;
  v88 = 0;
  IIOImageSource::imageReadRef(a2);
  CGImageGetImageProvider();
  Property = CGImageProviderGetProperty();
  BitmapInfo = IIOImagePixelDataProvider::getBitmapInfo(a2);
  v8 = IIOImageSource::count(a2);
  v9 = IIO_Reader::testHeaderSize(a2);
  v10 = IIOImagePlus::sourceImageProvider(a2);
  Error = _cg_GifLastError((uint64_t)a2);
  appleflags = _cg_png_get_appleflags((uint64_t)a2);
  v81 = a2;
  v13 = a2;
  v14 = Error;
  v15 = appleflags;
  SourceGeomColorSpace = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(v13);
  Model = CGColorSpaceGetModel(SourceGeomColorSpace);
  CGImageProviderGetProperty();
  if (*((_BYTE *)this + 37))
  {
    ImageIOLog("    --- writePNG <%p>------\n, this", v72);
    ImageIOLog("            size: %d x %d\n", v8, v9);
    ImageIOLog("        rowBytes: %d\n", v10);
    ImageIOLog("             bpc: %d\n", v14);
    ImageIOLog("             bpp: %d\n", v15);
    v17 = IIO_BitmapInfoString(BitmapInfo);
    v18 = IIO_AlphaInfoString(BitmapInfo);
    ImageIOLog("      bitmapInfo: %X '%s + %s'\n", BitmapInfo, v17, v18);
  }
  v76 = v9;
  if ((BitmapInfo & 0x1000) != 0)
  {
    v19 = a3;
    if ((_DWORD)v14 == 16)
    {
      v84 = (BitmapInfo >> 8) & 1;
    }
    else
    {
      LogError("writePNG", 235, "BAD bitmapInfo: use 'ByteOrder16Little' or 'ByteOrder16Big' only for 16-bpc images\n");
      v84 = 0;
    }
  }
  else
  {
    v84 = 0;
    v19 = a3;
  }
  if ((BitmapInfo & 0x6000) != 0 && (_DWORD)v14 != 32 && (_DWORD)v15 != 32)
    LogError("writePNG", 243, "BAD bitmapInfo: use 'ByteOrder32Little' or 'ByteOrder32Big' only for 32-bpp images\n");
  rowbytes = v10;
  if (_cg_png_get_rowbytes(*((_QWORD *)this + 5), *((_QWORD *)this + 6)) > v10)
    rowbytes = _cg_png_get_rowbytes(*((_QWORD *)this + 5), *((_QWORD *)this + 6));
  if (rowbytes != v10 || *MEMORY[0x1E0C9AE50] == Property)
  {
    v87 = v10;
    v88 = 1;
    v21 = (char *)malloc_type_malloc(rowbytes, 0x7723A3FFuLL);
  }
  else
  {
    v21 = (char *)IIOImagePixelDataProvider::createEncodingTempBuffer(v81, &v88, &v87);
  }
  v89 = v21;
  v74 = (int)_cg_png_set_interlace_handling(*((_QWORD *)this + 5));
  if ((_DWORD)v14 == 16)
    _cg_png_set_swap(*((_QWORD *)this + 5));
  if (IIODictionary::containsKey(v19, CFSTR("PencilKitPrivateData")))
  {
    ObjectForKey = IIODictionary::getObjectForKey(v19, CFSTR("PencilKitPrivateData"));
    if (ObjectForKey)
    {
      v23 = ObjectForKey;
      v24 = v15;
      BytePtr = CFDataGetBytePtr(ObjectForKey);
      Length = CFDataGetLength(v23);
      dest.data = *(void **)"";
      LODWORD(dest.height) = bswap32(Length);
      v27 = Length;
      _cg_png_write_chunk_header(*((_QWORD *)this + 5), 1634750532);
      _cg_png_write_chunk_data(*((_QWORD *)this + 5), (Bytef *)&dest, 12);
      v28 = (Bytef *)BytePtr;
      v15 = v24;
      _cg_png_write_chunk_data(*((_QWORD *)this + 5), v28, v27);
      _cg_png_write_chunk_end(*((_QWORD *)this + 5));
    }
  }
  Uint32ForKey = IIODictionary::getUint32ForKey(v19, CFSTR("kCGImagePropertyPNGBandCount"));
  if (Uint32ForKey >= 0x10)
    v30 = 16;
  else
    v30 = Uint32ForKey;
  v82 = v30;
  if (!(_DWORD)v74)
  {
    v41 = 0;
    v35 = v76;
LABEL_88:
    if (v41 == v35)
      v70 = 0;
    else
      v70 = 4294967246;
    goto LABEL_91;
  }
  if ((_DWORD)v74 == 1 && !*((_BYTE *)this + 122) && v76 >= v30 && Model != kCGColorSpaceModelIndexed)
  {
    Size = IIOImageWriteSession::getSize(*((IIOImageWriteSession **)this + 2));
    v31 = (Bytef *)malloc_type_calloc(12 * v82 + 4, 1uLL, 0xE9E3B020uLL);
    v80 = 12 * v82 + 4;
    _cg_png_write_chunk(*((void (***)(void))this + 5), (unsigned int *)"iDOT", v31, v80);
    *(_DWORD *)v31 = (_DWORD)v82 << 24;
    _cg_png_set_write_fn(*((_QWORD **)this + 5), *((_QWORD *)this + 2), (size_t (*)(size_t, void *, size_t))write_fn, (uint64_t (*)(uint64_t))flush_fn_noop);
    do_filter = _cg_png_get_do_filter(*((_QWORD *)this + 5));
    _cg_png_set_do_filter(*((_QWORD *)this + 5), do_filter & 0x1F);
    v33 = 0;
    v34 = 0;
    v35 = v76;
    v36 = (v76 + v82 - 1) / v82;
    do
    {
      if (v36 + v34 >= v35)
        v36 = v35 - v34;
      v37 = &v31[12 * v33];
      v38 = IIOImageWriteSession::getSize(*((IIOImageWriteSession **)this + 2));
      *((_DWORD *)v37 + 1) = bswap32(v34);
      *((_DWORD *)v37 + 2) = bswap32(v36);
      *((_DWORD *)v37 + 3) = bswap32(v38 - Size);
      v39 = v36 + v34;
      if (v34 >= v36 + v34)
      {
        v41 = v34;
      }
      else
      {
        while (1)
        {
          v40 = v89;
          if (IIOImagePixelDataProvider::getBytes((uint64_t (**)(IIOImagePixelDataProvider *, void *))v81, v89) != v10)break;
          _cg_png_write_row_sized(*((_QWORD *)this + 5), v40);
          if (v39 == ++v34)
          {
            v41 = v39;
            goto LABEL_40;
          }
        }
        v41 = v34;
LABEL_40:
        v35 = v76;
      }
      if (v33 != (_DWORD)v82 - 1)
        _cg_png_insert_iDOTBreak(*((_QWORD *)this + 5));
      ++v33;
      v34 = v39;
    }
    while (v33 != v82);
    _cg_png_set_write_fn(*((_QWORD **)this + 5), *((_QWORD *)this + 2), (size_t (*)(size_t, void *, size_t))write_fn, (uint64_t (*)(uint64_t))flush_fn);
    v42 = IIOImageWriteSession::getSize(*((IIOImageWriteSession **)this + 2));
    IIOImageWriteSession::seek(*((IIOImageWriteSession **)this + 2), Size, 0);
    _cg_png_write_chunk(*((void (***)(void))this + 5), (unsigned int *)"iDOT", v31, v80);
    free(v31);
    IIOImageWriteSession::seek(*((IIOImageWriteSession **)this + 2), v42, 0);
    goto LABEL_88;
  }
  v43 = 0;
  v83 = BitmapInfo & 0x1F;
  v78 = v14;
  v75 = v15 / v14 * v8;
  v35 = v76;
  while (1)
  {
    v73 = v43;
    v41 = 0;
    if (v35)
      break;
LABEL_83:
    v43 = v73 + 1;
    IIOImagePixelDataProvider::rewind(v81);
    if (v73 + 1 == v74)
      goto LABEL_88;
  }
  v45 = v87;
  v44 = v88;
  while (1)
  {
    if (v44 + v41 > v35)
    {
      v44 = v35 - v41;
      v45 = (v35 - v41) * v10;
    }
    if (!v45)
      goto LABEL_86;
    Bytes = IIOImagePixelDataProvider::getBytes((uint64_t (**)(IIOImagePixelDataProvider *, void *))v81, v89);
    if (Bytes != v45)
      break;
    v77 = v41;
    v47 = v89;
    dest.data = v89;
    dest.height = 1;
    dest.width = v75;
    dest.rowBytes = v10;
    src.data = v89;
    src.height = 1;
    src.width = v8;
    src.rowBytes = v10;
    if (v44)
    {
      v48 = 0;
      v49 = &v89[2 * v8 - 1];
      v50 = &v89[4 * v8 - 2];
      while (1)
      {
        if (*((_BYTE *)this + 122))
        {
          if (*((_BYTE *)this + 84) == 4)
          {
            if (v8)
            {
              v51 = 4 * v8 - 4;
              v52 = v8;
              do
              {
                v53 = v47[v52 - 1];
                v54 = v53 & 0xF;
                v55 = *((_QWORD *)this + 13) - 1;
                v56 = v55 >= v53 >> 4;
                v57 = v53 >> 4;
                if (!v56)
                  v57 = *((_QWORD *)this + 13) - 1;
                if (v55 < v54)
                  v54 = *((_QWORD *)this + 13) - 1;
                v58 = 3 * v57;
                v59 = &v47[v51];
                *v59 = *(_BYTE *)(*((_QWORD *)this + 14) + v58);
                v59[1] = *(_BYTE *)(v58 + *((_QWORD *)this + 14) + 1);
                v59[2] = *(_BYTE *)(v58 + *((_QWORD *)this + 14) + 2);
                v59[3] = 17 * v54;
                v51 -= 4;
                --v52;
              }
              while (v52);
            }
          }
          else
          {
            v62 = v50;
            v63 = v49;
            for (i = v8; i; --i)
            {
              v65 = *(v63 - 1);
              v67 = *v63;
              v63 -= 2;
              v66 = v67;
              v68 = *((_QWORD *)this + 13) - 1;
              if (v68 < v65)
                v65 = *((_QWORD *)this + 13) - 1;
              if (v68 < v66)
                v66 = *((_QWORD *)this + 13) - 1;
              v69 = 3 * v65;
              *(v62 - 2) = *(_BYTE *)(*((_QWORD *)this + 14) + v69);
              *(v62 - 1) = *(_BYTE *)(v69 + *((_QWORD *)this + 14) + 1);
              *v62 = *(_BYTE *)(v69 + *((_QWORD *)this + 14) + 2);
              v62[1] = v66;
              v62 -= 4;
            }
          }
          goto LABEL_81;
        }
        if (v84)
        {
          dest.data = v47;
          v60 = vImageConvert_16Fto16U(&dest, &dest, 0);
          if (v60)
            _cg_jpeg_mem_term("writePNG", 492, "    vImageConvert_16Uto16F err=%d\n", v60);
        }
        if (v83 != 1)
          goto LABEL_81;
        src.data = v47;
        if (Model != kCGColorSpaceModelRGB)
          goto LABEL_81;
        if (v78 == 16)
          break;
        v61 = vImageUnpremultiplyData_RGBA8888(&src, &src, 0);
        if (v61)
          goto LABEL_80;
LABEL_81:
        _cg_png_write_row_sized(*((_QWORD *)this + 5), v47);
        ++v48;
        v47 += v10;
        v49 += v10;
        v50 += v10;
        if (v44 <= v48)
          goto LABEL_82;
      }
      v61 = vImageUnpremultiplyData_RGBA16U(&src, &src, 0);
      if (!v61)
        goto LABEL_81;
LABEL_80:
      _cg_jpeg_mem_term("writePNG", 514, "    vImageUnpremultiply err=%d  (%d bpc)\n", v61, v78);
      goto LABEL_81;
    }
LABEL_82:
    v35 = v76;
    v41 = v44 + v77;
    if (v44 + v77 >= v76)
      goto LABEL_83;
  }
  _cg_jpeg_mem_term("writePNG", 438, "    iPixelDataProvider->getBytes asked for %ld bytes - got %d bytes\n", v45, Bytes);
LABEL_86:
  v70 = 4294967246;
LABEL_91:
  if (v89)
    free(v89);
  return v70;
}

void _cg_png_write_row_sized(uint64_t a1, void *__src)
{
  unsigned int v4;
  char v5;
  char v6;
  size_t v7;
  unsigned __int8 v8;
  uint8x8_t v9;
  unsigned int v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  _BYTE *v16;
  char v17;
  unsigned __int16 *v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  void (*v22)(uint64_t, _QWORD, _QWORD);
  const char *v23;
  uint64_t v24;
  size_t v25;
  uint64_t v26;

  if (!a1)
    return;
  if (!*(_DWORD *)(a1 + 308) && !*(_BYTE *)(a1 + 389))
  {
    if ((*(_BYTE *)(a1 + 77) & 4) == 0)
    {
      v23 = "png_write_info was never called before png_write_row";
      goto LABEL_66;
    }
    _cg_png_write_start_row(a1);
  }
  if (!*(_BYTE *)(a1 + 388) || (*(_BYTE *)(a1 + 88) & 2) == 0)
  {
LABEL_8:
    v24 = 0;
    v25 = 0;
    v4 = *(_DWORD *)(a1 + 292);
    v5 = *(_BYTE *)(a1 + 396);
    v6 = *(_BYTE *)(a1 + 393);
    if ((v6 * v5) >= 8u)
      v7 = v4 * (unint64_t)((v6 * v5) >> 3);
    else
      v7 = ((v6 * v5) * (unint64_t)v4 + 7) >> 3;
    v8 = *(_BYTE *)(a1 + 391);
    v25 = v7;
    v26 = v8;
    LODWORD(v24) = v4;
    BYTE2(v26) = v5;
    BYTE1(v26) = v6;
    *(_DWORD *)((char *)&v26 + 3) = (v6 * v5);
    memcpy((void *)(*(_QWORD *)(a1 + 328) + 1), __src, v7);
    if (*(_BYTE *)(a1 + 388))
    {
      v10 = *(unsigned __int8 *)(a1 + 389);
      if (v10 <= 5 && (*(_BYTE *)(a1 + 88) & 2) != 0)
      {
        png_do_write_interlace((uint64_t)&v24, (unsigned __int8 *)(*(_QWORD *)(a1 + 328) + 1), v10);
        if (!(_DWORD)v24)
        {
          png_write_finish_row(a1);
          return;
        }
      }
    }
    if (*(_DWORD *)(a1 + 88))
      png_do_write_transformations(a1, (int *)&v24, v9);
    if (BYTE3(v26) == *(unsigned __int8 *)(a1 + 394) && BYTE3(v26) == *(unsigned __int8 *)(a1 + 399))
    {
      if ((*(_BYTE *)(a1 + 760) & 4) == 0 || *(_BYTE *)(a1 + 764) != 64)
        goto LABEL_58;
      v11 = v26;
      if ((v26 & 2) == 0)
        goto LABEL_59;
      v12 = *(_QWORD *)(a1 + 328);
      v13 = v24;
      if (BYTE1(v26) != 16)
      {
        if (BYTE1(v26) == 8)
        {
          if (v26 == 2)
          {
            v14 = 3;
LABEL_50:
            if ((_DWORD)v24)
            {
              v16 = (_BYTE *)(v12 + 3);
              do
              {
                v17 = *(v16 - 1);
                *(v16 - 2) -= v17;
                *v16 -= v17;
                v16 += v14;
                --v13;
              }
              while (v13);
            }
            goto LABEL_58;
          }
          if (v26 == 6)
          {
            v14 = 4;
            goto LABEL_50;
          }
        }
LABEL_58:
        v11 = v26;
LABEL_59:
        if (v11 == 3 && (*(_DWORD *)(a1 + 380) & 0x80000000) == 0)
          png_do_check_palette_indexes(a1, (uint64_t)&v24);
        png_write_find_filter(a1, (uint64_t)&v24);
        v22 = *(void (**)(uint64_t, _QWORD, _QWORD))(a1 + 552);
        if (v22)
          v22(a1, *(unsigned int *)(a1 + 308), *(unsigned __int8 *)(a1 + 389));
        return;
      }
      if (v26 == 2)
      {
        v15 = 6;
      }
      else
      {
        if (v26 != 6)
          goto LABEL_58;
        v15 = 8;
      }
      if ((_DWORD)v24)
      {
        v18 = (unsigned __int16 *)(v12 + 3);
        do
        {
          v19 = bswap32(*v18);
          v20 = __rev16(*(v18 - 1)) - HIWORD(v19);
          v21 = __rev16(v18[1]) - HIWORD(v19);
          *((_BYTE *)v18 - 2) = BYTE1(v20);
          *((_BYTE *)v18 - 1) = v20;
          *((_BYTE *)v18 + 2) = BYTE1(v21);
          *((_BYTE *)v18 + 3) = v21;
          v18 = (unsigned __int16 *)((char *)v18 + v15);
          --v13;
        }
        while (v13);
      }
      goto LABEL_58;
    }
    v23 = "internal write transform logic error";
LABEL_66:
    _cg_png_error((void (**)(void))a1, v23);
  }
  switch(*(_BYTE *)(a1 + 389))
  {
    case 0:
      if ((*(_BYTE *)(a1 + 308) & 7) == 0)
        goto LABEL_8;
      goto LABEL_45;
    case 1:
      if ((*(_BYTE *)(a1 + 308) & 7) != 0 || *(_DWORD *)(a1 + 280) <= 4u)
        goto LABEL_45;
      goto LABEL_8;
    case 2:
      if ((*(_DWORD *)(a1 + 308) & 7) != 4)
        goto LABEL_45;
      goto LABEL_8;
    case 3:
      if ((*(_BYTE *)(a1 + 308) & 3) != 0 || *(_DWORD *)(a1 + 280) <= 2u)
        goto LABEL_45;
      goto LABEL_8;
    case 4:
      if ((*(_DWORD *)(a1 + 308) & 3) != 2)
        goto LABEL_45;
      goto LABEL_8;
    case 5:
      if ((*(_BYTE *)(a1 + 308) & 1) != 0 || *(_DWORD *)(a1 + 280) <= 1u)
        goto LABEL_45;
      goto LABEL_8;
    case 6:
      if ((*(_BYTE *)(a1 + 308) & 1) != 0)
        goto LABEL_8;
LABEL_45:
      png_write_finish_row(a1);
      break;
    default:
      goto LABEL_8;
  }
}

void png_write_find_filter(uint64_t a1, uint64_t a2)
{
  int v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  _BYTE *v9;
  _BYTE *v10;
  char *v11;
  unint64_t v12;
  char *v13;
  char v14;
  int v15;
  unsigned __int8 *v17;
  unint64_t v18;
  uint64_t v19;
  int v20;
  unsigned int v21;
  _BYTE *v22;
  unsigned __int8 *v23;
  __int16 CPUCapabilities;
  double v25;
  double v26;
  int32x4_t v27;
  int32x4_t v28;
  unint64_t v29;
  unint64_t v30;
  char v31;
  char v32;
  char v33;
  char *v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  int v38;
  unsigned int v39;
  unint64_t v40;
  char v41;
  char v42;
  char v43;
  unsigned __int8 v44;
  int v45;
  unsigned int v46;
  uint64_t v47;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unsigned int v52;
  unint64_t v53;
  uint64_t v54;
  _BYTE *v55;
  unsigned __int8 *v56;
  unsigned __int8 *v57;
  unint64_t v58;
  char *v59;
  char v60;
  char v61;
  unsigned int v62;
  uint64_t v63;
  __int16 v64;
  uint8x8_t v65;
  uint8x8_t v66;
  int32x4_t v67;
  int32x4_t v68;
  int32x4_t v69;
  unint64_t v70;
  unsigned int v71;
  char v72;
  char v73;
  int v74;
  int v75;
  int v76;
  unsigned __int8 *v77;
  unsigned __int8 *v78;
  unsigned __int8 *v79;
  unint64_t v80;
  char *v81;
  char v82;
  char v83;
  unsigned int v84;
  unsigned __int8 v85;
  int v86;
  unsigned int v87;
  uint64_t v88;
  unsigned int v89;
  char v90;
  char v91;
  int v92;
  int v93;
  int v94;
  unsigned __int8 v95;
  int v96;
  unsigned int v97;
  uint64_t v98;
  unint64_t v99;
  BOOL v100;
  uint64_t v101;
  _BYTE *v102;
  unsigned __int8 *v103;
  unsigned __int8 *v104;
  uint64_t v105;
  unsigned __int8 *v106;
  unsigned __int8 *v107;
  _BYTE *v108;
  __int16 v109;
  double v110;
  double v111;
  int8x16_t v112;
  uint16x8_t v113;
  int8x16_t v114;
  int8x16_t v115;
  unint64_t v116;
  unint64_t v117;
  int v118;
  int v119;
  int v120;
  int v121;
  char v122;
  int v123;
  int v124;
  unsigned int v125;
  unsigned int v126;
  int v127;
  char v129;
  unsigned __int8 *v130;
  unsigned __int8 *v131;
  unsigned __int8 *v132;
  uint64_t v133;
  unsigned __int8 v134;
  int v135;
  unsigned int v136;
  uint64_t v137;
  unsigned __int8 *v138;
  unsigned __int8 *v139;
  unint64_t v140;
  int v141;
  int v142;
  int v143;
  int v144;
  char v145;
  int v146;
  int v147;
  unsigned int v148;
  unsigned int v149;
  int v150;
  char v152;
  unsigned __int8 v153;
  int v154;
  unsigned int v155;
  uint64_t v156;
  uint64_t v158;

  v3 = *(unsigned __int8 *)(a1 + 390);
  v4 = *(_QWORD *)(a2 + 8);
  v5 = *(unsigned __int8 *)(a2 + 19);
  v6 = (unint64_t)(v5 + 7) >> 3;
  v7 = *(_QWORD *)(a1 + 328);
  if (v4 < 0x1FFFFFFFFFFFFFFLL)
  {
    v8 = -257;
    if ((v3 & 8) != 0 && v3 != 8)
    {
      v15 = AppleGetCPUCapabilities() & 0x100;
      if ((_DWORD)v6 != 4 || v15 == 0)
      {
        v8 = 0;
        if (v4)
        {
          v17 = (unsigned __int8 *)(v7 + 1);
          v18 = v4;
          do
          {
            v20 = *v17++;
            LODWORD(v19) = v20;
            v21 = 256 - v20;
            if ((v20 & 0x80u) == 0)
              v19 = v19;
            else
              v19 = v21;
            v8 += v19;
            --v18;
          }
          while (v18);
        }
      }
      else
      {
        v8 = png_write_filter_row_none_neon((int8x16_t *)(v7 + 1), v7 + 1, v4);
      }
    }
  }
  else
  {
    v3 &= -v3;
    v8 = -257;
  }
  if (v3 == 16)
  {
    v9 = *(_BYTE **)(a1 + 336);
    *v9 = 1;
    v10 = v9 + 1;
    v11 = (char *)(v7 + 1);
    if ((_DWORD)v5)
    {
      v12 = (unint64_t)(v5 + 7) >> 3;
      v13 = (char *)(v7 + 1);
      do
      {
        v14 = *v13++;
        *v10++ = v14;
        --v12;
      }
      while (v12);
    }
    else
    {
      v13 = (char *)(v7 + 1);
    }
    v30 = v4 - v6;
    if (v4 > v6)
    {
      do
      {
        v32 = *v13++;
        v31 = v32;
        v33 = *v11++;
        *v10++ = v31 - v33;
        --v30;
      }
      while (v30);
    }
  }
  else
  {
    v9 = (_BYTE *)v7;
    if ((v3 & 0x10) != 0)
    {
      v22 = *(_BYTE **)(a1 + 336);
      *v22 = 1;
      v23 = v22 + 1;
      CPUCapabilities = AppleGetCPUCapabilities();
      if ((_DWORD)v6 == 4 && (CPUCapabilities & 0x100) != 0)
      {
        v29 = png_write_filter_row_sub_neon((int8x16_t *)(v7 + 1), v23, v4, v25, v26, v27, v28);
      }
      else
      {
        v34 = (char *)(v7 + 1);
        v29 = 0;
        if ((_DWORD)v5)
        {
          v35 = v6;
          v36 = (char *)(v7 + 1);
          do
          {
            v38 = *v36++;
            LODWORD(v37) = v38;
            *v23++ = v38;
            v39 = 256 - v38;
            if ((v38 & 0x80u) == 0)
              v37 = v37;
            else
              v37 = v39;
            v29 += v37;
            --v35;
          }
          while (v35);
        }
        else
        {
          v36 = (char *)(v7 + 1);
        }
        if (v4 > v6)
        {
          v40 = v6 + 1;
          do
          {
            v42 = *v36++;
            v41 = v42;
            v43 = *v34++;
            v44 = v41 - v43;
            v45 = (char)v44;
            *v23++ = v44;
            v46 = v44;
            LODWORD(v47) = 256 - v44;
            if (v45 >= 0)
              v47 = v46;
            else
              v47 = v47;
            v29 += v47;
          }
          while (v29 <= v8 && v40++ < v4);
        }
      }
      if (v29 < v8)
      {
        v49 = *(_QWORD *)(a1 + 344);
        if (v49)
        {
          *(_QWORD *)(a1 + 336) = v49;
          *(_QWORD *)(a1 + 344) = v22;
        }
        v8 = v29;
        v9 = v22;
      }
    }
  }
  if (v3 == 32)
  {
    png_setup_up_row((_QWORD *)a1, v4, v8, (unint64_t)(v5 + 7) >> 3);
    v9 = *(_BYTE **)(a1 + 336);
LABEL_54:
    v50 = a2;
    goto LABEL_55;
  }
  if ((v3 & 0x20) != 0)
  {
    v53 = png_setup_up_row((_QWORD *)a1, v4, v8, (unint64_t)(v5 + 7) >> 3);
    if (v53 < v8)
    {
      v9 = *(_BYTE **)(a1 + 336);
      v54 = *(_QWORD *)(a1 + 344);
      if (v54)
      {
        *(_QWORD *)(a1 + 336) = v54;
        *(_QWORD *)(a1 + 344) = v9;
      }
      v8 = v53;
    }
  }
  if (v3 == 64)
  {
    v9 = *(_BYTE **)(a1 + 336);
    *v9 = 3;
    v55 = v9 + 1;
    v56 = (unsigned __int8 *)(*(_QWORD *)(a1 + 320) + 1);
    v57 = (unsigned __int8 *)(v7 + 1);
    if ((_DWORD)v5)
    {
      v58 = (unint64_t)(v5 + 7) >> 3;
      v59 = (char *)(v7 + 1);
      do
      {
        v61 = *v59++;
        v60 = v61;
        v62 = *v56++;
        *v55++ = v60 - (v62 >> 1);
        LODWORD(v58) = v58 - 1;
      }
      while ((_DWORD)v58);
    }
    else
    {
      v59 = (char *)(v7 + 1);
    }
    if (v4 > v6)
    {
      v71 = v6 + 1;
      do
      {
        v73 = *v59++;
        v72 = v73;
        v75 = *v56++;
        v74 = v75;
        v76 = *v57++;
        *v55++ = v72 - ((v76 + v74) >> 1);
        v100 = v4 > v71++;
      }
      while (v100);
    }
  }
  else if ((v3 & 0x40) != 0)
  {
    v63 = *(_QWORD *)(a1 + 336);
    *(_BYTE *)v63 = 3;
    v64 = AppleGetCPUCapabilities();
    if ((_DWORD)v6 == 4 && (v64 & 0x100) != 0)
    {
      v70 = png_write_filter_row_avg_neon((unsigned __int32 *)(v7 + 1), (_DWORD *)(v63 + 1), (_DWORD *)(*(_QWORD *)(a1 + 320) + 1), v4, v65, v66, v67, v68, v69);
    }
    else
    {
      v77 = (unsigned __int8 *)(v63 + 1);
      v78 = (unsigned __int8 *)(*(_QWORD *)(a1 + 320) + 1);
      v79 = (unsigned __int8 *)(v7 + 1);
      v70 = 0;
      if ((_DWORD)v5)
      {
        v80 = (unint64_t)(v5 + 7) >> 3;
        v81 = (char *)(v7 + 1);
        do
        {
          v83 = *v81++;
          v82 = v83;
          v84 = *v78++;
          v85 = v82 - (v84 >> 1);
          v86 = (char)v85;
          *v77++ = v85;
          v87 = v85;
          LODWORD(v88) = 256 - v85;
          if (v86 >= 0)
            v88 = v87;
          else
            v88 = v88;
          v70 += v88;
          LODWORD(v80) = v80 - 1;
        }
        while ((_DWORD)v80);
      }
      else
      {
        v81 = (char *)(v7 + 1);
      }
      if (v4 > v6)
      {
        v89 = v6 + 1;
        do
        {
          v91 = *v81++;
          v90 = v91;
          v93 = *v78++;
          v92 = v93;
          v94 = *v79++;
          v95 = v90 - ((v94 + v92) >> 1);
          v96 = (char)v95;
          *v77++ = v95;
          v97 = v95;
          LODWORD(v98) = 256 - v95;
          if (v96 >= 0)
            v98 = v97;
          else
            v98 = v98;
          v70 += v98;
          v99 = v89++;
          v100 = v70 <= v8 && v4 > v99;
        }
        while (v100);
      }
    }
    if (v70 < v8)
    {
      v101 = *(_QWORD *)(a1 + 344);
      if (v101)
      {
        *(_QWORD *)(a1 + 336) = v101;
        *(_QWORD *)(a1 + 344) = v63;
      }
      v8 = v70;
      v9 = (_BYTE *)v63;
    }
  }
  if (v3 == 128)
  {
    v9 = *(_BYTE **)(a1 + 336);
    *v9 = 4;
    v102 = v9 + 1;
    v103 = (unsigned __int8 *)(*(_QWORD *)(a1 + 320) + 1);
    v104 = (unsigned __int8 *)(v7 + 1);
    if ((_DWORD)v5)
    {
      v105 = 0;
      do
      {
        v102[v105] = v104[v105] - v103[v105];
        ++v105;
      }
      while (v6 != v105);
      v106 = &v104[v105];
      v107 = &v103[v105];
      v102 += v105;
    }
    else
    {
      v107 = (unsigned __int8 *)(*(_QWORD *)(a1 + 320) + 1);
      v106 = (unsigned __int8 *)(v7 + 1);
    }
    v50 = a2;
    v117 = v4 - v6;
    if (v4 > v6)
    {
      do
      {
        v119 = *v107++;
        v118 = v119;
        v121 = *v103++;
        v120 = v121;
        v123 = *v104++;
        v122 = v123;
        v124 = v123 - v120;
        if (v118 - v120 >= 0)
          v125 = v118 - v120;
        else
          v125 = v120 - v118;
        if (v124 >= 0)
          v126 = v124;
        else
          v126 = -v124;
        v127 = v124 + v118 - v120;
        if (v127 < 0)
          v127 = -v127;
        if (v126 > v127)
          LOBYTE(v118) = v120;
        if (v125 <= v127 && v125 <= v126)
          LOBYTE(v118) = v122;
        v129 = *v106++;
        *v102++ = v129 - v118;
        --v117;
      }
      while (v117);
    }
  }
  else
  {
    if ((v3 & 0x80) == 0)
      goto LABEL_54;
    v108 = *(_BYTE **)(a1 + 336);
    *v108 = 4;
    v109 = AppleGetCPUCapabilities();
    if ((_DWORD)v6 == 4 && (v109 & 0x100) != 0)
    {
      v116 = png_write_filter_row_paeth_neon((_BYTE *)(v7 + 1), v108 + 1, (_BYTE *)(*(_QWORD *)(a1 + 320) + 1), v4, v110, v111, v112, v113, v114, v115);
    }
    else
    {
      v130 = v108 + 1;
      v131 = (unsigned __int8 *)(*(_QWORD *)(a1 + 320) + 1);
      v132 = (unsigned __int8 *)(v7 + 1);
      v116 = 0;
      if ((_DWORD)v5)
      {
        v133 = 0;
        do
        {
          v134 = v132[v133] - v131[v133];
          v135 = (char)v134;
          v130[v133] = v134;
          v136 = v134;
          LODWORD(v137) = 256 - v134;
          if (v135 >= 0)
            v137 = v136;
          else
            v137 = v137;
          v116 += v137;
          ++v133;
        }
        while (v6 != v133);
        v138 = &v132[v133];
        v139 = &v131[v133];
        v130 += v133;
      }
      else
      {
        v139 = (unsigned __int8 *)(*(_QWORD *)(a1 + 320) + 1);
        v138 = (unsigned __int8 *)(v7 + 1);
      }
      if (v4 > v6)
      {
        v140 = v6 + 1;
        do
        {
          v142 = *v139++;
          v141 = v142;
          v144 = *v131++;
          v143 = v144;
          v146 = *v132++;
          v145 = v146;
          v147 = v146 - v143;
          if (v141 - v143 >= 0)
            v148 = v141 - v143;
          else
            v148 = v143 - v141;
          if (v147 >= 0)
            v149 = v147;
          else
            v149 = -v147;
          v150 = v147 + v141 - v143;
          if (v150 < 0)
            v150 = -v150;
          if (v149 > v150)
            LOBYTE(v141) = v143;
          if (v148 <= v150 && v148 <= v149)
            LOBYTE(v141) = v145;
          v152 = *v138++;
          v153 = v152 - v141;
          v154 = (char)v153;
          *v130++ = v153;
          v155 = v153;
          LODWORD(v156) = 256 - v153;
          if (v154 >= 0)
            v156 = v155;
          else
            v156 = v156;
          v116 += v156;
        }
        while (v116 <= v8 && v140++ < v4);
      }
    }
    v50 = a2;
    if (v116 < v8)
    {
      v158 = *(_QWORD *)(a1 + 344);
      if (v158)
      {
        *(_QWORD *)(a1 + 336) = v158;
        *(_QWORD *)(a1 + 344) = v108;
      }
      v9 = v108;
    }
  }
LABEL_55:
  png_compress_IDAT(a1, (uint64_t)v9, *(_QWORD *)(v50 + 8) + 1, 0);
  v51 = *(_QWORD *)(a1 + 320);
  if (v51)
  {
    *(_QWORD *)(a1 + 320) = *(_QWORD *)(a1 + 328);
    *(_QWORD *)(a1 + 328) = v51;
  }
  png_write_finish_row(a1);
  v52 = *(_DWORD *)(a1 + 444) + 1;
  *(_DWORD *)(a1 + 444) = v52;
  if (*(_DWORD *)(a1 + 440) - 1 < v52)
    _cg_png_write_flush(a1);
}

uint64_t AppleGetCPUCapabilities()
{
  if (AppleGetCPUCapabilities::onceToken != -1)
    dispatch_once(&AppleGetCPUCapabilities::onceToken, &__block_literal_global_29);
  return AppleGetCPUCapabilities::gImageIO_cpu_capabilities;
}

uint64_t png_compress_IDAT(uint64_t a1, uint64_t a2, unint64_t a3, int a4)
{
  _QWORD **v8;
  _QWORD *v9;
  _QWORD *v10;
  void (**v11)(void);
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  int v15;
  uint64_t result;
  int v17;
  unsigned __int8 *v18;
  unint64_t v19;
  unsigned __int8 *v20;
  int v21;
  unint64_t v22;
  const char *v23;

  if (*(_DWORD *)(a1 + 92) != 1229209940)
  {
    v8 = *(_QWORD ***)(a1 + 208);
    if (v8)
    {
      v9 = *v8;
      if (*v8)
      {
        *v8 = 0;
        do
        {
          v10 = (_QWORD *)*v9;
          png_free(a1, v9);
          v9 = v10;
        }
        while (v10);
      }
    }
    else
    {
      v11 = png_malloc((void (**)(void))a1, *(unsigned int *)(a1 + 216) + 16);
      *(_QWORD *)(a1 + 208) = v11;
      *v11 = 0;
      v11[1] = (void (*)(void))(v11 + 2);
    }
    v12 = png_image_size(a1);
    if (png_deflate_claim(a1, 1229209940, v12))
      goto LABEL_45;
    *(_QWORD *)(a1 + 120) = *(_QWORD *)(*(_QWORD *)(a1 + 208) + 8);
    *(_DWORD *)(a1 + 128) = *(_DWORD *)(a1 + 216);
  }
  *(_QWORD *)(a1 + 96) = a2;
  do
  {
    do
    {
      v13 = a3 >= 0xFFFFFFFF ? 0xFFFFFFFFLL : a3;
      *(_DWORD *)(a1 + 104) = v13;
      v14 = a3 - v13;
      v15 = HIDWORD(a3) ? 0 : a4;
      result = deflate((z_streamp)(a1 + 96), v15);
      v17 = result;
      a3 = v14 + *(unsigned int *)(a1 + 104);
      *(_DWORD *)(a1 + 104) = 0;
      LODWORD(v14) = *(_DWORD *)(a1 + 128);
      if ((_DWORD)v14)
        break;
      v18 = *(unsigned __int8 **)(*(_QWORD *)(a1 + 208) + 8);
      v14 = *(unsigned int *)(a1 + 216);
      if ((*(_BYTE *)(a1 + 76) & 4) != 0 || *(_BYTE *)(a1 + 872))
      {
        if ((_DWORD)v14)
          goto LABEL_24;
      }
      else
      {
        v19 = png_image_size(a1);
        result = (uint64_t)optimize_cmf(v18, v19);
        if ((_DWORD)v14)
        {
LABEL_24:
          if (*(_DWORD *)(a1 + 812))
            result = png_write_fdAT(a1, v18, v14);
          else
            result = (uint64_t)_cg_png_write_complete_chunk((void (**)(void))a1, 1229209940, v18, v14);
        }
      }
      *(_DWORD *)(a1 + 76) |= 4u;
      *(_QWORD *)(a1 + 120) = v18;
      *(_DWORD *)(a1 + 128) = v14;
    }
    while (a4 && !v17);
    if (v17)
    {
      if (a4 == 4 && v17 == 1)
      {
        v20 = *(unsigned __int8 **)(*(_QWORD *)(a1 + 208) + 8);
        v21 = *(_DWORD *)(a1 + 216);
        if ((*(_BYTE *)(a1 + 76) & 4) == 0 && !*(_BYTE *)(a1 + 872))
        {
          v22 = png_image_size(a1);
          result = (uint64_t)optimize_cmf(v20, v22);
        }
        if (v21 != (_DWORD)v14)
        {
          if (*(_DWORD *)(a1 + 812))
            result = png_write_fdAT(a1, v20, (v21 - v14));
          else
            result = (uint64_t)_cg_png_write_complete_chunk((void (**)(void))a1, 1229209940, v20, (v21 - v14));
        }
        *(_DWORD *)(a1 + 128) = 0;
        *(_QWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 76) |= 0xCu;
        *(_DWORD *)(a1 + 92) = 0;
        return result;
      }
      png_zstream_error(a1, v17);
LABEL_45:
      v23 = *(const char **)(a1 + 144);
LABEL_46:
      _cg_png_error((void (**)(void))a1, v23);
    }
  }
  while (a3);
  if (a4 == 4)
  {
    v23 = "Z_OK on Z_FINISH with output space";
    goto LABEL_46;
  }
  return result;
}

void png_write_finish_row(uint64_t a1)
{
  unsigned int v1;
  unsigned __int8 v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  BOOL v9;
  unint64_t v10;
  unint64_t v11;

  v1 = *(_DWORD *)(a1 + 308) + 1;
  *(_DWORD *)(a1 + 308) = v1;
  if (v1 >= *(_DWORD *)(a1 + 288))
  {
    if (!*(_BYTE *)(a1 + 388))
      goto LABEL_15;
    *(_DWORD *)(a1 + 308) = 0;
    v2 = *(_BYTE *)(a1 + 389);
    if ((*(_BYTE *)(a1 + 88) & 2) != 0)
    {
      ++v2;
    }
    else
    {
      while (++v2 <= 6u)
      {
        v3 = png_do_write_interlace_png_pass_inc[v2];
        v4 = *(_DWORD *)(a1 + 280) + v3 + ~png_do_write_interlace_png_pass_start[v2];
        *(_DWORD *)(a1 + 292) = v4 / v3;
        v5 = png_write_finish_row_png_pass_yinc[v2];
        v6 = *(_DWORD *)(a1 + 284) + v5 + ~png_write_finish_row_png_pass_ystart[v2];
        *(_DWORD *)(a1 + 288) = v6 / v5;
        if (v4 >= v3 && v6 >= v5)
          break;
      }
    }
    *(_BYTE *)(a1 + 389) = v2;
    if (v2 <= 6u)
    {
      if (*(_QWORD *)(a1 + 320))
      {
        v7 = *(unsigned __int8 *)(a1 + 393) * *(unsigned __int8 *)(a1 + 396);
        v8 = *(_DWORD *)(a1 + 280);
        v9 = v7 >= 8;
        v10 = (v8 * (unint64_t)v7 + 7) >> 3;
        v11 = v8 * (unint64_t)(v7 >> 3);
        if (!v9)
          v11 = v10;
        bzero(*(void **)(a1 + 320), v11 + 1);
      }
    }
    else
    {
LABEL_15:
      png_compress_IDAT(a1, 0, 0, 4);
    }
  }
}

unint64_t png_setup_up_row(_QWORD *a1, unint64_t a2, unint64_t a3, int a4)
{
  uint64_t v8;
  __int16 CPUCapabilities;
  double v10;
  double v11;
  int32x4_t v12;
  int32x4_t v13;
  unint64_t result;
  char *v15;
  char *v16;
  unsigned __int8 *v17;
  unint64_t v18;
  char v19;
  char v20;
  char v21;
  unsigned __int8 v22;
  int v23;
  unsigned int v24;
  uint64_t v25;

  v8 = a1[42];
  *(_BYTE *)v8 = 2;
  CPUCapabilities = AppleGetCPUCapabilities();
  if (a4 == 4 && (CPUCapabilities & 0x100) != 0)
    return png_write_filter_row_up_neon((int8x16_t *)(a1[41] + 1), (int8x16_t *)(v8 + 1), (int8x16_t *)(a1[40] + 1), a2, v10, v11, v12, v13);
  result = 0;
  if (a2)
  {
    v15 = (char *)(a1[41] + 1);
    v16 = (char *)(a1[40] + 1);
    v17 = (unsigned __int8 *)(v8 + 1);
    v18 = a2 - 1;
    do
    {
      v20 = *v15++;
      v19 = v20;
      v21 = *v16++;
      v22 = v19 - v21;
      v23 = (char)v22;
      *v17++ = v22;
      v24 = v22;
      LODWORD(v25) = 256 - v22;
      if (v23 >= 0)
        v25 = v24;
      else
        v25 = v25;
      result += v25;
    }
    while (result <= a3 && v18-- != 0);
  }
  return result;
}

uint64_t png_do_write_transformations(uint64_t result, int *a2, uint8x8_t a3)
{
  uint64_t v4;
  int v5;
  uint64_t (*v6)(uint64_t, int *, uint64_t);
  _BYTE *v7;
  int v8;
  int v9;
  int v10;
  int v11;
  _BYTE *v12;
  uint64_t v13;
  int v14;
  unsigned int v15;
  char v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  int v23;
  _BYTE *v24;
  unsigned __int8 v25;
  BOOL v26;
  unint64_t v27;
  unint64_t v28;
  int v29;
  uint64_t v30;
  unsigned int v31;
  int v32;
  unsigned int v33;
  int v34;
  int v35;
  unsigned __int8 *v36;
  int v37;
  uint64_t v38;
  int v39;
  int v41;
  int v43;
  uint64_t k;
  unsigned __int8 v45;
  unsigned int v46;
  char v47;
  int v48;
  int v49;
  unsigned int i;
  unsigned __int8 v51;
  int v52;
  int v53;
  unsigned int v54;
  unsigned int v55;
  int v56;
  BOOL v57;
  int v58;
  unsigned int j;
  unsigned int v60;
  int v61;
  int v62;
  unsigned int v63;
  unsigned int v64;
  int v65;
  BOOL v66;
  unsigned int v67;
  int8x8_t *v68;
  int v69;
  int v70;
  int16x8_t v71;
  int v72;
  __int8 v73;
  int16x8_t v74;
  _BYTE *v75;
  int v76;
  int v77;
  _BYTE *v78;
  int v79;
  _BYTE *v80;
  _BYTE *v81;
  _BYTE *v82;
  int v83;
  int v84;
  unint64_t v85;
  int v86;
  int v87;
  uint64_t v88;
  int v89;
  uint64_t v90;

  v90 = *MEMORY[0x1E0C80C00];
  if (!result)
    return result;
  v4 = result;
  v5 = *(_DWORD *)(result + 88);
  if ((v5 & 0x100000) != 0)
  {
    v6 = *(uint64_t (**)(uint64_t, int *, uint64_t))(result + 56);
    if (v6)
    {
      result = v6(result, a2, *(_QWORD *)(result + 328) + 1);
      v5 = *(_DWORD *)(v4 + 88);
    }
  }
  if ((v5 & 0x8000) != 0)
  {
    result = png_do_strip_channel((uint64_t)a2, (_BYTE *)(*(_QWORD *)(v4 + 328) + 1), ((*(_DWORD *)(v4 + 80) >> 7) & 1) == 0);
    v5 = *(_DWORD *)(v4 + 88);
    if ((v5 & 0x10000) == 0)
    {
LABEL_7:
      if ((v5 & 4) == 0)
        goto LABEL_47;
LABEL_11:
      if (*((_BYTE *)a2 + 17) == 8 && *((_BYTE *)a2 + 18) == 1)
      {
        v7 = (_BYTE *)(*(_QWORD *)(v4 + 328) + 1);
        v8 = *(unsigned __int8 *)(v4 + 392);
        switch(v8)
        {
          case 4:
            v23 = *a2;
            if (*a2)
            {
              v24 = (_BYTE *)(*(_QWORD *)(v4 + 328) + 1);
              while (v23 != 1)
              {
                *v7++ = v24[1] & 0xF | (16 * *v24);
                v24 += 2;
                v23 -= 2;
                if (!v23)
                  goto LABEL_44;
              }
              LOBYTE(v14) = 16 * *v24;
LABEL_43:
              *v7 = v14;
            }
            break;
          case 2:
            if (*a2)
            {
              v17 = 0;
              v18 = -*a2;
              v19 = *(_QWORD *)(v4 + 328) + 1;
LABEL_29:
              v20 = 0;
              v14 = 0;
              v21 = 6;
              do
              {
                v14 |= (*(_BYTE *)(v19 + v20) & 3) << v21;
                if (!v21)
                {
                  *v7++ = v14;
                  v19 += v20 + 1;
                  v22 = v17 + v20;
                  v17 += v20 + 1;
                  if (v22 + v18 != -1)
                    goto LABEL_29;
                  goto LABEL_44;
                }
                v21 -= 2;
                ++v20;
              }
              while (v18 + v17 + (_DWORD)v20);
              if (v21 != 6)
                goto LABEL_43;
            }
            break;
          case 1:
            v9 = *a2;
            if (*a2)
            {
              v10 = 0;
              v11 = *a2;
              v12 = (_BYTE *)(*(_QWORD *)(v4 + 328) + 1);
              do
              {
                v13 = 0;
                LOBYTE(v14) = 0;
                v15 = 128;
                while (1)
                {
                  v16 = v7[v13] ? v15 : 0;
                  LOBYTE(v14) = v16 | v14;
                  if ((_DWORD)v13 == 7)
                    break;
                  v15 >>= 1;
                  if (v11 == (_DWORD)++v13)
                  {
                    v7 = v12;
                    goto LABEL_43;
                  }
                }
                *v12++ = v14;
                v10 += 8;
                v7 += v13 + 1;
                v11 -= 8;
              }
              while (v10 != v9);
            }
            break;
        }
LABEL_44:
        *((_BYTE *)a2 + 17) = v8;
        v25 = *((_BYTE *)a2 + 18) * v8;
        *((_BYTE *)a2 + 19) = v25;
        v26 = v25 >= 8u;
        v27 = (*a2 * (unint64_t)v25 + 7) >> 3;
        v28 = *a2 * (unint64_t)(v25 >> 3);
        if (!v26)
          v28 = v27;
        *((_QWORD *)a2 + 1) = v28;
        v5 = *(_DWORD *)(v4 + 88);
      }
      goto LABEL_47;
    }
  }
  else if ((v5 & 0x10000) == 0)
  {
    goto LABEL_7;
  }
  result = png_do_packswap((uint64_t)a2, (_BYTE *)(*(_QWORD *)(v4 + 328) + 1));
  v5 = *(_DWORD *)(v4 + 88);
  if ((v5 & 4) != 0)
    goto LABEL_11;
LABEL_47:
  if ((v5 & 0x10) != 0)
  {
    result = png_do_swap((uint64_t)a2, (char *)(*(_QWORD *)(v4 + 328) + 1));
    v5 = *(_DWORD *)(v4 + 88);
  }
  if ((v5 & 8) != 0)
  {
    v29 = *((unsigned __int8 *)a2 + 16);
    if (v29 != 3)
    {
      v30 = *(_QWORD *)(v4 + 328);
      v89 = 0;
      v88 = 0;
      v86 = 0;
      v85 = 0;
      v31 = *((unsigned __int8 *)a2 + 17);
      if ((v29 & 2) != 0)
      {
        v32 = *(unsigned __int8 *)(v4 + 509);
        v34 = *(unsigned __int8 *)(v4 + 510);
        v35 = *(unsigned __int8 *)(v4 + 511);
        LODWORD(v88) = v31 - v34;
        HIDWORD(v88) = v31 - v35;
        v85 = __PAIR64__(v35, v34);
        v33 = 3;
      }
      else
      {
        v32 = *(unsigned __int8 *)(v4 + 512);
        v33 = 1;
      }
      v36 = (unsigned __int8 *)(v30 + 1);
      v87 = v31 - v32;
      v84 = v32;
      if ((v29 & 4) != 0)
      {
        v37 = *(unsigned __int8 *)(v4 + 513);
        *(&v87 + v33) = v31 - v37;
        *(&v84 + v33++) = v37;
      }
      if (v31 > 7)
      {
        v49 = *a2 * v33;
        if (v31 == 8)
        {
          if (v49)
          {
            for (i = 0; i != v49; ++i)
            {
              v51 = 0;
              v52 = *(&v87 + i % v33);
              v53 = *(&v84 + i % v33);
              if (v52 > -v53)
              {
                v51 = 0;
                v54 = *v36;
                LODWORD(result) = -v52;
                do
                {
                  v55 = v54 >> result;
                  v56 = v52 - v53;
                  result = (result + v53);
                  v57 = v52 <= 0;
                  if (v52 <= 0)
                    LOBYTE(v58) = v55;
                  else
                    v58 = v54 << v52;
                  v51 |= v58;
                  v52 = v56;
                }
                while (!v57);
              }
              *v36++ = v51;
            }
          }
        }
        else if (v49)
        {
          for (j = 0; j != v49; ++j)
          {
            v60 = 0;
            v61 = *(&v87 + j % v33);
            v62 = *(&v84 + j % v33);
            if (v61 > -v62)
            {
              v60 = 0;
              v63 = __rev16(*(unsigned __int16 *)v36);
              LODWORD(result) = -v61;
              do
              {
                v64 = v63 >> result;
                v65 = v61 - v62;
                result = (result + v62);
                v66 = v61 <= 0;
                if (v61 <= 0)
                  v67 = v64;
                else
                  v67 = v63 << v61;
                v60 |= v67;
                v61 = v65;
              }
              while (!v66);
            }
            *(_WORD *)v36 = bswap32(v60) >> 16;
            v36 += 2;
          }
        }
      }
      else
      {
        v38 = *((_QWORD *)a2 + 1);
        v39 = *(unsigned __int8 *)(v4 + 512);
        if (v39 == 3 && v31 == 4)
          v41 = 17;
        else
          v41 = 255;
        if (v39 == 1 && v31 == 2)
          v43 = 85;
        else
          v43 = v41;
        if (v38)
        {
          for (k = 0; k != v38; ++k)
          {
            v45 = 0;
            if (v31)
            {
              v46 = *v36;
              LODWORD(result) = v31;
              v47 = v32 - v31;
              do
              {
                if ((int)result - v32 <= 0)
                  v48 = (v46 >> v47) & v43;
                else
                  v48 = v46 << (result - v32);
                v45 |= v48;
                v47 += v32;
                result = (result - v32);
              }
              while ((int)result > 0);
            }
            *v36++ = v45;
          }
        }
      }
      v5 = *(_DWORD *)(v4 + 88);
    }
  }
  if ((v5 & 0x20000) != 0)
  {
    v68 = (int8x8_t *)(*(_QWORD *)(v4 + 328) + 1);
    v69 = *((unsigned __int8 *)a2 + 16);
    if (v69 == 4)
    {
      v72 = *a2;
      if (*((_BYTE *)a2 + 17) == 8)
      {
        for (; v72; --v72)
        {
          v73 = v68->i8[0];
          v68->i8[0] = v68->i8[1];
          v68->i8[1] = v73;
          v68 = (int8x8_t *)((char *)v68 + 2);
        }
      }
      else
      {
        for (; v72; --v72)
        {
          a3.i32[0] = v68->i32[0];
          v74 = (int16x8_t)vmovl_u8(a3);
          *(int8x8_t *)v74.i8 = vext_s8(*(int8x8_t *)v74.i8, *(int8x8_t *)v74.i8, 4uLL);
          a3 = (uint8x8_t)vmovn_s16(v74);
          v68->i32[0] = a3.i32[0];
          v68 = (int8x8_t *)((char *)v68 + 4);
        }
      }
    }
    else if (v69 == 6)
    {
      v70 = *a2;
      if (*((_BYTE *)a2 + 17) == 8)
      {
        for (; v70; --v70)
        {
          a3.i32[0] = v68->i32[0];
          v71 = (int16x8_t)vmovl_u8(a3);
          *(int8x8_t *)v71.i8 = vext_s8(*(int8x8_t *)v71.i8, *(int8x8_t *)v71.i8, 2uLL);
          a3 = (uint8x8_t)vmovn_s16(v71);
          v68->i32[0] = a3.i32[0];
          v68 = (int8x8_t *)((char *)v68 + 4);
        }
      }
      else
      {
        for (; v70; --v70)
        {
          *v68 = vext_s8(*v68, *v68, 2uLL);
          ++v68;
        }
      }
    }
  }
  if ((*(_BYTE *)(v4 + 90) & 8) != 0)
  {
    v75 = *(_BYTE **)(v4 + 328);
    v76 = *((unsigned __int8 *)a2 + 16);
    if (v76 == 4)
    {
      v79 = *a2;
      if (*((_BYTE *)a2 + 17) == 8)
      {
        if (v79)
        {
          v80 = v75 + 2;
          do
          {
            *v80 = ~*v80;
            v80 += 2;
            --v79;
          }
          while (v79);
        }
      }
      else if (v79)
      {
        v82 = v75 + 4;
        do
        {
          *(v82 - 1) = ~*(v82 - 1);
          *v82 = ~*v82;
          v82 += 4;
          --v79;
        }
        while (v79);
      }
    }
    else if (v76 == 6)
    {
      v77 = *a2;
      if (*((_BYTE *)a2 + 17) == 8)
      {
        if (v77)
        {
          v78 = v75 + 4;
          do
          {
            *v78 = ~*v78;
            v78 += 4;
            --v77;
          }
          while (v77);
        }
      }
      else if (v77)
      {
        v81 = v75 + 8;
        do
        {
          *(v81 - 1) = ~*(v81 - 1);
          *v81 = ~*v81;
          v81 += 8;
          --v77;
        }
        while (v77);
      }
    }
  }
  v83 = *(_DWORD *)(v4 + 88);
  if ((v83 & 1) != 0)
  {
    result = (uint64_t)png_do_bgr(a2, (__int16 *)(*(_QWORD *)(v4 + 328) + 1));
    v83 = *(_DWORD *)(v4 + 88);
  }
  if ((v83 & 0x20) != 0)
    return png_do_invert((uint64_t)a2, (_BYTE *)(*(_QWORD *)(v4 + 328) + 1));
  return result;
}

uint64_t png_do_strip_channel(uint64_t result, _BYTE *a2, int a3)
{
  uint64_t v3;
  unint64_t v4;
  int v5;
  int v6;
  char *v7;
  _BYTE *v8;
  char v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE *v13;
  char v14;
  _BYTE *v15;
  _BYTE *v16;
  uint64_t v17;
  uint64_t v18;
  _BYTE *v19;

  v3 = *(_QWORD *)(result + 8);
  v4 = (unint64_t)&a2[v3];
  v5 = *(unsigned __int8 *)(result + 18);
  if (v5 == 4)
  {
    v10 = *(unsigned __int8 *)(result + 17);
    if (v10 == 16)
    {
      v17 = 8;
      if (a3)
        v17 = 2;
      v18 = 6;
      if (a3)
        v18 = 0;
      v8 = &a2[v18];
      if (v17 < v3)
      {
        v19 = &a2[v17];
        do
        {
          *v8 = *v19;
          v8[1] = v19[1];
          v8[2] = v19[2];
          v8[3] = v19[3];
          v8[4] = v19[4];
          v8[5] = v19[5];
          v8 += 6;
          v19 += 8;
        }
        while ((unint64_t)v19 < v4);
      }
      v14 = 48;
    }
    else
    {
      if (v10 != 8)
        return result;
      if (a3)
        v11 = 1;
      else
        v11 = 4;
      v12 = 3;
      if (a3)
        v12 = 0;
      v8 = &a2[v12];
      if (v11 < v3)
      {
        v13 = &a2[v11];
        do
        {
          *v8 = *v13;
          v8[1] = v13[1];
          v8[2] = v13[2];
          v8 += 3;
          v13 += 4;
        }
        while ((unint64_t)v13 < v4);
      }
      v14 = 24;
    }
    *(_BYTE *)(result + 19) = v14;
    *(_BYTE *)(result + 18) = 3;
    if (*(_BYTE *)(result + 16) == 6)
      *(_BYTE *)(result + 16) = 2;
  }
  else
  {
    if (v5 != 2)
      return result;
    v6 = *(unsigned __int8 *)(result + 17);
    if (v6 == 16)
    {
      v15 = a2 + 4;
      if (a3)
      {
        v15 = a2 + 2;
        v16 = a2;
      }
      else
      {
        v16 = a2 + 2;
      }
      if ((unint64_t)v15 >= v4)
      {
        v8 = v16;
      }
      else
      {
        do
        {
          *v16 = *v15;
          v8 = v16 + 2;
          v16[1] = v15[1];
          v15 += 4;
          v16 += 2;
        }
        while ((unint64_t)v15 < v4);
      }
    }
    else
    {
      if (v6 != 8)
        return result;
      if (a3)
        v7 = a2 + 1;
      else
        v7 = a2 + 2;
      if (a3)
        v8 = a2;
      else
        v8 = a2 + 1;
      while ((unint64_t)v7 < v4)
      {
        v9 = *v7;
        v7 += 2;
        *v8++ = v9;
      }
    }
    *(_BYTE *)(result + 19) = v6;
    *(_BYTE *)(result + 18) = 1;
    if (*(_BYTE *)(result + 16) == 4)
      *(_BYTE *)(result + 16) = 0;
  }
  *(_QWORD *)(result + 8) = v8 - a2;
  return result;
}

uint64_t IIOImagePixelDataProvider::getBytes(uint64_t (**this)(IIOImagePixelDataProvider *, void *), void *a2)
{
  return this[22]((IIOImagePixelDataProvider *)this, a2);
}

uint64_t IIOImagePixelDataProvider::getBytesImageProvider(IIOImagePixelDataProvider *this, char *a2, unint64_t a3)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  unint64_t v8;
  _BOOL4 v10;
  uint64_t ImageProvider;
  const void *v12;
  uint64_t v13;
  double v15;
  CGFloat v16;
  double v17;
  double v18;
  double v19;
  CGFloat v20;
  double v21;
  double v22;
  double v23;
  double v24;
  unint64_t v25;
  double v26;
  double v27;
  double v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t PixelSize;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  double v40;
  double v41;
  double v42;
  uint64_t v43;
  double v44;
  double v45;
  double v46;
  double v47;
  uint64_t v48;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  size_t BytesPerRow;
  double v55;
  vImagePixelCount v56;
  char *v57;
  BOOL v58;
  vImagePixelCount v59;
  vImagePixelCount v60;
  BOOL v61;
  size_t v62;
  unint64_t v63;
  vImagePixelCount v64;
  size_t v65;
  vImagePixelCount v66;
  vImagePixelCount v67;
  uint64_t v68;
  vImagePixelCount v69;
  char *v70;
  unint64_t v71;
  uint64_t v72;
  uint64_t Data;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  vImage_Buffer dest;
  vImage_Buffer src;
  _BYTE v80[32];
  CGRect v81;

  result = 0;
  if (!a2 || !a3)
    return result;
  v5 = *((_QWORD *)this + 19);
  v6 = *((_QWORD *)this + 20);
  if (v6 <= v5)
    return 0;
  v7 = a2;
  if (v5 + a3 <= v6)
    v8 = a3;
  else
    v8 = v6 - v5;
  v10 = v8 != *((_QWORD *)this + 4) * *((_QWORD *)this + 18) && *((_QWORD *)this + 21) != 0;
  ImageProvider = CGImageGetImageProvider();
  v12 = (const void *)ImageProvider;
  v13 = *((_QWORD *)this + 24);
  if (!v10 || v13 == 0)
  {
    if (v13)
      goto LABEL_40;
    if (!ImageProvider)
      return 0;
LABEL_32:
    if (!*((_QWORD *)this + 23))
      *((_QWORD *)this + 23) = CFRetain(v12);
    if (!v10 || v8 % *((_QWORD *)this + 18))
    {
      memset(&src, 0, 24);
      IIODictionary::IIODictionary((IIODictionary *)&src);
      IIONumber::IIONumber((IIONumber *)v80, 0);
      IIODictionary::setObjectForKey((uint64_t)&src, (uint64_t)v80, CFSTR("kCGImageProviderPreferedBandHeight"));
      IIONumber::~IIONumber((IIONumber *)v80);
      v30 = CGImageProviderCopyImageBlockSetWithOptions();
      if (!v30)
        v30 = CGImageProviderCopyImageBlockSetWithOptions();
      IIODictionary::~IIODictionary((IIODictionary *)&src);
      if (!v30)
        return 0;
      goto LABEL_39;
    }
    v30 = CGImageProviderCopyImageBlockSetWithOptions();
    if (v30)
    {
LABEL_39:
      *((_QWORD *)this + 24) = v30;
      CGImageBlockSetGetImageBlock();
      *((_QWORD *)this + 17) = CGImageBlockGetBytesPerRow();
      goto LABEL_40;
    }
    return 0;
  }
  CGImageBlockSetGetRect();
  v16 = v15;
  v18 = v17;
  v20 = v19;
  v22 = v21;
  CGImageBlockSetGetImageBlock();
  CGImageBlockGetRect();
  if (v18 < v23)
    v18 = v23;
  if (v22 < v24)
    v22 = v24;
  *((_QWORD *)this + 17) = CGImageBlockGetBytesPerRow();
  v25 = *((_QWORD *)this + 18);
  v26 = 1.0;
  if (v8 > v25 && !(v8 % v25))
    v26 = (double)(v8 / v25);
  if (v8 != v25 && v8 % v25
    || (v27 = (double)(*((_QWORD *)this + 19) / v25),
        v28 = (double)*((unint64_t *)this + 3),
        v29 = 0,
        v81.origin.x = v16,
        v81.origin.y = v18,
        v81.size.width = v20,
        v81.size.height = v22,
        !CGRectContainsRect(v81, *(CGRect *)(&v26 - 3))))
  {
    CGImageBlockSetRelease();
    *((_QWORD *)this + 24) = 0;
    if (!v12)
      return 0;
    goto LABEL_32;
  }
LABEL_40:
  result = CGImageBlockSetGetCount();
  v71 = result;
  if (!result)
    return result;
  PixelSize = CGImageProviderGetPixelSize();
  v32 = (*((_DWORD *)this + 21) + 7) >> 3;
  if (v8 < v32)
  {
    _cg_jpeg_mem_term("getBytesImageProvider", 826, "Only %zu bytes requested, must request at least a full pixel (%zu bytes)", v8, v32);
    return 0;
  }
  v33 = PixelSize;
  result = 0;
  v74 = v33;
  v72 = *((_QWORD *)this + 3) * v33;
  v34 = v8 / v32 * v32;
LABEL_43:
  if (v34)
  {
    v77 = result;
    v70 = v7;
    v35 = 0;
    v36 = 0;
    while (1)
    {
      memset(&src, 0, sizeof(src));
      memset(&dest, 0, sizeof(dest));
      v38 = *((_QWORD *)this + 18);
      v37 = *((_QWORD *)this + 19);
      v39 = *((unsigned int *)this + 21);
      v40 = IIOImagePixelDataProvider::endingPointForByteCount(this, v34);
      v42 = v41;
      if (CGImageBlockSetGetImageBlock())
      {
        v43 = (uint64_t)(double)(v37 / v38);
        CGImageBlockGetRect();
        v48 = (uint64_t)v45 + (uint64_t)v47;
        if ((unint64_t)v48 >= *((_QWORD *)this + 4))
          v48 = *((_QWORD *)this + 4);
        v75 = (uint64_t)v45;
        v76 = v48;
        if (v43 >= (uint64_t)v45 && v48 > v43)
        {
          v50 = (uint64_t)(double)(8 * (v37 % v38) / v39);
          v51 = (uint64_t)v44;
          v52 = (unint64_t)((uint64_t)v44 + (uint64_t)v46) >= *((_QWORD *)this + 3)
              ? *((_QWORD *)this + 3)
              : (uint64_t)v44 + (uint64_t)v46;
          if (v50 >= v51 && v52 > v50)
            break;
        }
      }
LABEL_101:
      if (++v35 >= v71 || !v34)
      {
        if (v34)
        {
          v7 = v70;
          result = v77;
          if (v36)
            goto LABEL_43;
          return result;
        }
        return v77;
      }
    }
    Data = CGImageBlockGetData();
    BytesPerRow = CGImageBlockGetBytesPerRow();
    *((_QWORD *)this + 17) = BytesPerRow;
    if (v40 <= (double)v52)
      v55 = v40;
    else
      v55 = (double)v52;
    v56 = *((_QWORD *)this + 3);
    v57 = v70;
    while (1)
    {
      v58 = v40 < (double)(unint64_t)v52 && v42 == (double)v43;
      v59 = (unint64_t)(v55 - (double)v50);
      if (!v58)
        v59 = v52 - v50;
      src.data = (void *)(Data + (v50 - v51) * v74 + BytesPerRow * (v43 - v75));
      src.width = v59;
      src.rowBytes = BytesPerRow;
      if (v59 == v56 && BytesPerRow == *((_QWORD *)this + 16))
      {
        v60 = v34 / *((_QWORD *)this + 18);
        if (v60 >= v76 - v43)
          v60 = v76 - v43;
        if (v60 <= 1)
          v60 = 1;
      }
      else
      {
        v60 = 1;
      }
      src.height = v60;
      dest.height = v60;
      dest.width = v59;
      dest.data = v57;
      v61 = v59 < v56 && v60 == 1;
      v62 = v61 ? v59 * ((*((_DWORD *)this + 21) + 7) >> 3) : *((_QWORD *)this + 18);
      dest.rowBytes = v62;
      v63 = *((unsigned int *)this + 11);
      if (BytesPerRow < (v59 * v63 + 7) >> 3)
        return v77;
      if (v34 < v60 * v59 * ((*((_DWORD *)this + 21) + 7) >> 3))
      {
        _cg_jpeg_mem_term("getBytesImageProvider", 924, "*** numBytes < dstBuffer.rowBytes * dstBuffer.height (%ld > %d)\n", v34, v62 * v60);
        return v77;
      }
      if (v60 == 1)
      {
        v64 = v59 * (v63 >> 3);
        v65 = v56 * (v63 >> 3);
        if (v64 < v65)
          v65 = v64;
        src.rowBytes = v65;
      }
      v66 = IIOImagePixelDataProvider::convertBytes(this, &src, &dest);
      if (!v66)
        return v77;
      v67 = v66;
      BytesPerRow = *((_QWORD *)this + 17);
      v57 += v67;
      v34 -= v67;
      v77 += v67;
      v36 += BytesPerRow;
      *((_QWORD *)this + 19) += v67;
      if (!v51 && v34)
      {
        v68 = *((_QWORD *)this + 3);
        v69 = dest.width + v50 == v68 ? dest.height : 0;
        if (dest.width + v50 == v68)
          v50 = 0;
        else
          v50 += dest.width;
        if (v52 == v68)
        {
          v43 += v69;
          if (v43 < v76)
          {
            v56 = v52;
            if (v72 <= v52 * v74)
              continue;
          }
        }
      }
      v70 = v57;
      goto LABEL_101;
    }
  }
  return result;
}

void sub_187E6E874(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  IIONumber::~IIONumber((IIONumber *)&a27);
  IIODictionary::~IIODictionary((IIODictionary *)&a23);
  _Unwind_Resume(a1);
}

double IIOImagePixelDataProvider::endingPointForByteCount(IIOImagePixelDataProvider *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  double result;
  unint64_t v6;
  BOOL v7;
  unint64_t v8;
  unint64_t v9;

  v2 = *((unsigned int *)this + 21);
  v3 = *((_QWORD *)this + 18);
  v4 = 8 * (*((_QWORD *)this + 19) % v3);
  result = (double)(v4 / v2);
  if (v4 >= v2)
  {
    v6 = (unint64_t)((double)v3 + (double)v2 * result * -0.125);
    if (v6)
    {
      v7 = a2 >= v6;
      v8 = a2 - v6;
      if (v7)
      {
        result = 0.0;
        a2 = v8;
      }
      else
      {
        result = result + (double)(8 * a2 / v2);
        if (result > (double)*((unint64_t *)this + 3))
          result = (double)*((unint64_t *)this + 3);
        a2 = 0;
      }
    }
  }
  v9 = a2 % v3;
  if (v9)
  {
    result = (double)((v2 + 8 * v9 - 1) / v2);
    if (result > (double)*((unint64_t *)this + 3))
      return (double)*((unint64_t *)this + 3);
  }
  return result;
}

vImagePixelCount IIOImagePixelDataProvider::convertBytes(IIOImagePixelDataProvider *this, vImage_Buffer *src, vImage_Buffer *dest)
{
  int v6;
  unint64_t v7;
  void *v8;
  void *v9;
  vImage_Error v10;
  const char *v11;
  __int128 v13;
  vImage_Error v14;
  vImage_Buffer desta;

  if (*((_DWORD *)this + 10) == 16 && *((_DWORD *)this + 20) == 8 && (*((_BYTE *)this + 57) & 0x10) != 0)
  {
    v6 = *((_DWORD *)this + 11);
    if (v6 == 16)
    {
      if (*((_DWORD *)this + 21) == 8 && !vImageConvert_Planar16UtoPlanar8_dithered(src, dest, 3, 0))
        return dest->height * dest->rowBytes;
    }
    else if (v6 == 48)
    {
      if (*((_DWORD *)this + 21) == 24 && !vImageConvert_RGB16UtoRGB888_dithered(src, dest, 3, 0))
        return dest->height * dest->rowBytes;
    }
    else if (v6 == 64
           && *((_DWORD *)this + 21) == 32
           && !vImageConvert_ARGB16UtoARGB8888_dithered(src, dest, 3, 0, 0))
    {
      return dest->height * dest->rowBytes;
    }
  }
  v7 = vImageConvert_AnyToAny(*((const vImageConverterRef *)this + 15), src, dest, 0, 0x80u);
  v8 = (void *)*((_QWORD *)this + 28);
  if ((v7 & 0x8000000000000000) == 0)
  {
    if (!v8)
    {
      if (!v7)
      {
        v8 = 0;
        goto LABEL_23;
      }
      *((_QWORD *)this + 29) = v7;
      v9 = malloc_type_malloc(v7, 0x135719CFuLL);
      goto LABEL_21;
    }
    if (*((_QWORD *)this + 29) < v7)
    {
      *((_QWORD *)this + 29) = v7;
      v9 = reallocf(v8, v7);
LABEL_21:
      v8 = v9;
      *((_QWORD *)this + 28) = v9;
    }
  }
LABEL_23:
  v10 = iio_vImageConvert_AnyToAny(*((vImageConverterRef *)this + 15), src, dest, v8, 0);
  if (v10)
  {
    v11 = IIO_vImageErrorString(v10);
    LogError("convertBytes", 551, "*** ERROR: vImageConvert_AnyToAny error: '%s'\n", v11);
    return 0;
  }
  if (*((_BYTE *)this + 217))
  {
    v13 = *(_OWORD *)&dest->width;
    *(_OWORD *)&desta.data = *(_OWORD *)&dest->data;
    desta.rowBytes = *((_QWORD *)&v13 + 1);
    desta.width = 4 * v13;
    v14 = vImageByteSwap_Planar16U(&desta, &desta, 0x10u);
    if (v14)
      LogError("convertBytes", 562, "*** ERROR: vImageByteSwap_Planar16U error: %d", v14);
  }
  return dest->height * dest->rowBytes;
}

vImage_Error iio_vImageConvert_AnyToAny(vImageConverterRef converter, const vImage_Buffer *srcs, const vImage_Buffer *dests, void *a4, vImage_Flags flags)
{
  vImage_Error MustOperateOutOfPlace;
  vImageConverter *v11;
  const vImage_Buffer *v12;
  const vImage_Buffer *v13;
  void *v14;
  unint64_t v15;
  size_t v16;
  char *v17;
  const char *v18;
  void *v20;
  _QWORD v21[2];

  v21[1] = *MEMORY[0x1E0C80C00];
  if (!converter)
    return -50;
  if (srcs->data == dests->data)
  {
    MustOperateOutOfPlace = vImageConverter_MustOperateOutOfPlace(converter, srcs, dests, flags);
    if (MustOperateOutOfPlace == -21780)
    {
      LogError("iio_vImageConvert_AnyToAny", 1044, "ERROR: vImageConvert_AnyToAny cannot convert in-place\n");
      return -21780;
    }
  }
  else
  {
    MustOperateOutOfPlace = 0;
  }
  v11 = converter;
  if (a4)
  {
    v12 = srcs;
    v13 = dests;
    v14 = a4;
LABEL_15:
    MustOperateOutOfPlace = vImageConvert_AnyToAny(v11, v12, v13, v14, flags);
    goto LABEL_16;
  }
  v15 = vImageConvert_AnyToAny(converter, srcs, dests, 0, 0x80u);
  if ((v15 & 0x8000000000000000) != 0)
  {
    _cg_jpeg_mem_term("iio_vImageConvert_AnyToAny", 1052, "*** ERROR: vImageConvert_AnyToAny+kvImageGetTempBufferSize returned: %lld\n", v15);
  }
  else
  {
    if (!v15)
    {
      v17 = 0;
      goto LABEL_14;
    }
    if (v15 <= 0x800)
    {
      MEMORY[0x1E0C80A78](v15, v15);
      v17 = (char *)v21 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v17, v16);
LABEL_14:
      v11 = converter;
      v12 = srcs;
      v13 = dests;
      v14 = v17;
      goto LABEL_15;
    }
    v20 = malloc_type_malloc(v15, 0x540628ECuLL);
    MustOperateOutOfPlace = vImageConvert_AnyToAny(converter, srcs, dests, v20, flags);
    free(v20);
  }
LABEL_16:
  if (MustOperateOutOfPlace)
  {
    v18 = IIO_vImageErrorString(MustOperateOutOfPlace);
    _cg_jpeg_mem_term("iio_vImageConvert_AnyToAny", 1086, "*** ERROR *** vImageConvert_AnyToAny: %d (%s)\n", MustOperateOutOfPlace, v18);
    CFShow(converter);
  }
  return MustOperateOutOfPlace;
}

vImagePixelCount IIOImagePixelDataProvider::getBytesDataProvider(IIOImagePixelDataProvider *this, unsigned __int8 *a2, unint64_t a3)
{
  vImagePixelCount v3;
  unint64_t v5;
  unint64_t v6;
  unint64_t v8;
  const __CFData *v9;
  const UInt8 *BytePtr;
  const UInt8 *v11;
  unint64_t v12;
  unint64_t v13;
  CGFloat v14;
  double v15;
  double v16;
  double v17;
  double v18;
  unsigned __int8 *v19;
  CGImage *Mask;
  CGImage *v21;
  size_t BytesPerRow;
  CGDataProvider *v23;
  const __CFData *v24;
  const UInt8 *v25;
  unint64_t v26;
  _BYTE *v27;
  unint64_t v28;
  const UInt8 *v29;
  unint64_t i;
  CGDataProvider *DataProvider;
  CGDataProvider *v32;
  const __CFData *v33;
  unint64_t v34;
  unint64_t Length;
  int v36;
  const void *v37;
  double v38;
  CFIndex SizeOfData;
  uint64_t v40;
  uint64_t v41;
  __CFData *Mutable;
  __CFData *v43;
  uint64_t Bytes;
  CGPoint v46;
  CGPoint v47;

  v3 = 0;
  if (a2)
  {
    v5 = *((_QWORD *)this + 19);
    v6 = *((_QWORD *)this + 20);
    if (v6 > v5)
    {
      if (v5 + a3 <= v6)
        v8 = a3;
      else
        v8 = v6 - v5;
      v9 = (const __CFData *)*((_QWORD *)this + 25);
      if (!v9)
      {
        DataProvider = CGImageGetDataProvider(*((CGImageRef *)this + 2));
        if (!DataProvider)
          return 0;
        v32 = DataProvider;
        v33 = CGDataProviderCopyData(DataProvider);
        *((_QWORD *)this + 25) = v33;
        if (!v33)
          return 0;
        v34 = (*((_QWORD *)this + 4) - 1) * *((_QWORD *)this + 16)
            + ((*((_QWORD *)this + 3) * (unint64_t)*((unsigned int *)this + 11)) >> 3);
        Length = CFDataGetLength(v33);
        if (Length < v34)
        {
          v36 = Length;
          CFRelease(*((CFTypeRef *)this + 25));
          *((_QWORD *)this + 25) = 0;
          _cg_jpeg_mem_term("getBytesDataProvider", 1030, "CGDataProviderCopyData(%p) did not return enough data. Got %d, expected %d.\n", v32, v36, *((_DWORD *)this + 8) * *((_DWORD *)this + 32));
          v37 = (const void *)CGAccessSessionCreate();
          *(_QWORD *)&v38 = _cg_jpeg_mem_term("getBytesDataProvider", 1033, "Making a copy of the data via CGAccessSession (%p).\n", v37).n128_u64[0];
          if (v37)
          {
            SizeOfData = CGDataProviderGetSizeOfData();
            v40 = *((_QWORD *)this + 16);
            v41 = *((_QWORD *)this + 4);
            if (SizeOfData != v41 * v40)
              SizeOfData = (v41 - 1) * v40
                         + *((_QWORD *)this + 3) * ((unint64_t)*((unsigned int *)this + 11) >> 3);
            Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], SizeOfData);
            if (Mutable)
            {
              v43 = Mutable;
              CFDataSetLength(Mutable, SizeOfData);
              CFDataGetMutableBytePtr(v43);
              Bytes = CGAccessSessionGetBytes();
              if (Bytes == SizeOfData)
              {
                _cg_jpeg_mem_term("getBytesDataProvider", 1054, "    success: (%p) CGAccessSessionGetBytes - got all data.\n", v32);
                *((_QWORD *)this + 25) = CFRetain(v43);
              }
              else
              {
                _cg_jpeg_mem_term("getBytesDataProvider", 1058, "*** CGAccessSessionGetBytes did not return enough data. Expected %zd, Got %zd.\n", SizeOfData, Bytes);
              }
              CFRelease(v43);
            }
            else
            {
              _cg_jpeg_mem_term("getBytesDataProvider", 1063, "Failed to create CFData.\n");
            }
            CGAccessSessionRelease();
          }
          else
          {
            _cg_jpeg_mem_term("getBytesDataProvider", 1068, "*** Failed to create CGAccessSession.\n", v38);
          }
        }
        v9 = (const __CFData *)*((_QWORD *)this + 25);
        if (!v9)
          return 0;
      }
      BytePtr = CFDataGetBytePtr(v9);
      if (BytePtr)
      {
        v11 = BytePtr;
        v13 = *((_QWORD *)this + 18);
        v12 = *((_QWORD *)this + 19);
        v14 = (double)(8 * (v12 % v13) / *((unsigned int *)this + 21));
        v15 = (double)(v12 / v13);
        v16 = IIOImagePixelDataProvider::endingPointForByteCount(this, v8);
        v47.x = v16;
        v18 = v17;
        LODWORD(v16) = *((_DWORD *)this + 11);
        v19 = (unsigned __int8 *)&v11[*((_QWORD *)this + 16) * (uint64_t)v15
                                    + (uint64_t)(v14 * (double)*(unint64_t *)&v16 * 0.125)];
        v46.x = v14;
        v46.y = v15;
        v47.y = v18;
        v3 = IIOImagePixelDataProvider::convertBytesWithRange(this, v19, a2, v46, v47, v8);
        if ((*((_BYTE *)this + 56) & 0x1F) == 0 && (*((_DWORD *)this + 24) & 0x1F) == 3)
        {
          Mask = (CGImage *)CGImageGetMask();
          if (Mask)
          {
            v21 = Mask;
            BytesPerRow = CGImageGetBytesPerRow(Mask);
            v23 = CGImageGetDataProvider(v21);
            v24 = CGDataProviderCopyData(v23);
            v25 = CFDataGetBytePtr(v24);
            if (v18 > (double)(unint64_t)v15)
            {
              v26 = (unint64_t)v15;
              v27 = a2 + 1;
              v28 = *((_QWORD *)this + 3);
              v29 = &v25[BytesPerRow * (unint64_t)v15];
              do
              {
                if (v28)
                {
                  for (i = 0; i < v28; ++i)
                  {
                    *v27 = v29[i];
                    v27 += 2;
                    v28 = *((_QWORD *)this + 3);
                  }
                }
                ++v26;
                v29 += BytesPerRow;
              }
              while (v18 > (double)v26);
            }
            CFRelease(v24);
          }
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return v3;
}

vImagePixelCount IIOImagePixelDataProvider::convertBytesWithRange(IIOImagePixelDataProvider *this, unsigned __int8 *a2, unsigned __int8 *a3, CGPoint a4, CGPoint a5, vImagePixelCount a6)
{
  unsigned __int8 *v7;
  double y;
  double x;
  double v10;
  double v11;
  unsigned __int8 *v12;
  double v15;
  vImagePixelCount v16;
  vImagePixelCount v17;
  unint64_t v18;
  size_t v19;
  double v20;
  vImagePixelCount result;
  vImagePixelCount v22;
  vImagePixelCount v24;
  size_t v25;
  size_t v26;
  vImagePixelCount v27;
  vImagePixelCount v28;
  vImagePixelCount v29;
  size_t v30;
  size_t v31;
  vImagePixelCount v32;
  vImagePixelCount v33;
  vImagePixelCount v34;
  vImage_Buffer v35;
  vImage_Buffer src;

  v7 = a3;
  y = a5.y;
  x = a5.x;
  v10 = a4.y;
  v11 = a4.x;
  v12 = a2;
  memset(&src, 0, sizeof(src));
  memset(&v35, 0, sizeof(v35));
  if (a4.x <= 0.0 || a5.y <= a4.y)
  {
    v15 = a4.y;
    v16 = a6;
    goto LABEL_11;
  }
  v17 = (unint64_t)((double)*((unint64_t *)this + 3) - a4.x);
  src.data = a2;
  src.height = 1;
  LODWORD(a4.y) = *((_DWORD *)this + 11);
  *(double *)&v18 = a4.x * (double)*(unint64_t *)&a4.y * 0.125;
  v19 = (unint64_t)((double)*((unint64_t *)this + 16) - *(double *)&v18);
  src.width = v17;
  src.rowBytes = v19;
  v35.data = a3;
  v35.height = 1;
  LODWORD(v18) = *((_DWORD *)this + 21);
  v20 = (double)*((unint64_t *)this + 18) - a4.x * (double)v18 * 0.125;
  v35.width = v17;
  v35.rowBytes = (unint64_t)v20;
  result = IIOImagePixelDataProvider::convertBytes(this, &src, &v35);
  if (result)
  {
    v16 = a6 - result;
    v22 = *((_QWORD *)this + 19) + result;
    if (v22 >= *((_QWORD *)this + 20))
      v22 = *((_QWORD *)this + 20);
    *((_QWORD *)this + 19) = v22;
    v12 += src.rowBytes;
    v7 += result;
    v15 = v10 + 1.0;
    v11 = 0.0;
LABEL_11:
    if (y > v10 && v16 != 0)
    {
      v24 = *((_QWORD *)this + 3);
      src.data = v12;
      src.height = (unint64_t)(y - v15);
      v25 = *((_QWORD *)this + 16);
      src.width = v24;
      src.rowBytes = v25;
      v35.data = v7;
      v35.height = src.height;
      v26 = *((_QWORD *)this + 18);
      v35.width = v24;
      v35.rowBytes = v26;
      v27 = IIOImagePixelDataProvider::convertBytes(this, &src, &v35);
      if (!v27)
        return a6 - v16;
      v16 -= v27;
      v28 = *((_QWORD *)this + 19) + v27;
      if (v28 >= *((_QWORD *)this + 20))
        v28 = *((_QWORD *)this + 20);
      *((_QWORD *)this + 19) = v28;
      v12 += src.height * src.rowBytes;
      v7 += v27;
    }
    if (!v16)
    {
      v33 = 0;
      return v33 + a6;
    }
    v29 = (unint64_t)(x - v11);
    src.data = v12;
    src.height = 1;
    v30 = (*((unsigned int *)this + 11) * v29) >> 3;
    src.width = v29;
    src.rowBytes = v30;
    v35.data = v7;
    v35.height = 1;
    v31 = (*((unsigned int *)this + 21) * v29) >> 3;
    v35.width = v29;
    v35.rowBytes = v31;
    v32 = IIOImagePixelDataProvider::convertBytes(this, &src, &v35);
    if (v32)
    {
      v33 = v32 - v16;
      v34 = *((_QWORD *)this + 19) + v32;
      if (v34 >= *((_QWORD *)this + 20))
        v34 = *((_QWORD *)this + 20);
      *((_QWORD *)this + 19) = v34;
      return v33 + a6;
    }
    return a6 - v16;
  }
  return result;
}

void (**_cg_png_write_complete_chunk(void (**result)(void), int a2, Bytef *a3, unint64_t a4))(void)
{
  uint64_t v5;

  if (result)
  {
    v5 = (uint64_t)result;
    if (a4 >> 31)
      _cg_png_error(result, "length exceeds PNG maximum");
    _cg_png_write_chunk_header((uint64_t)result, a2);
    _cg_png_write_chunk_data(v5, a3, a4);
    *(_DWORD *)(v5 + 956) = 130;
    return (void (**)(void))png_write_data(v5);
  }
  return result;
}

uint64_t _cg_png_write_chunk_header(uint64_t result, int a2)
{
  uLong v3;
  Bytef v4[4];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v3 = result;
    *(_DWORD *)(result + 956) = 34;
    v4[0] = HIBYTE(a2);
    v4[1] = BYTE2(a2);
    v4[2] = BYTE1(a2);
    v4[3] = a2;
    png_write_data(result);
    *(_DWORD *)(v3 + 312) = a2;
    png_reset_crc(v3);
    result = png_calculate_crc(v3, v4, 4);
    *(_DWORD *)(v3 + 956) = 66;
  }
  return result;
}

_QWORD *_cg_png_set_write_fn(_QWORD *result, uint64_t a2, size_t (*a3)(size_t result, void *__ptr, size_t a3), uint64_t (*a4)(uint64_t result))
{
  size_t (*v4)(size_t, void *, size_t);
  uint64_t (*v5)(uint64_t);

  if (result)
  {
    result[5] = a2;
    v4 = png_default_write_data;
    if (a3)
      v4 = a3;
    result[3] = v4;
    v5 = png_default_flush;
    if (a4)
      v5 = a4;
    result[54] = v5;
    if (result[4])
    {
      result[4] = 0;
      return (_QWORD *)png_warning((uint64_t)result, "Can't set both read_data_fn and write_data_fn in the same structure");
    }
  }
  return result;
}

uint64_t png_deflate_claim(uint64_t a1, int a2, unint64_t a3)
{
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  unint64_t v13;
  unsigned int v14;
  z_stream *v15;
  _BYTE v17[4];
  __int16 v18;
  char v19;
  char v20;
  char v21;
  char v22;
  __int128 v23;
  __int128 v24;
  _WORD v25[11];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v6 = *(_DWORD *)(a1 + 92);
  if (!v6)
    goto LABEL_5;
  memset(v25, 0, sizeof(v25));
  v24 = 0u;
  v23 = 0u;
  v17[0] = HIBYTE(a2);
  v17[1] = BYTE2(a2);
  v17[2] = BYTE1(a2);
  v17[3] = a2;
  v18 = 8250;
  v19 = HIBYTE(v6);
  v20 = BYTE2(v6);
  v21 = BYTE1(v6);
  v22 = v6;
  png_safecat((uint64_t)v17, 0x40uLL, 0xAuLL, " using zstream");
  png_warning(a1, v17);
  if (*(_DWORD *)(a1 + 92) != 1229209940)
  {
    *(_DWORD *)(a1 + 92) = 0;
LABEL_5:
    if (a2 == 1229209940)
    {
      v8 = *(_DWORD *)(a1 + 220);
      v9 = *(_DWORD *)(a1 + 224);
      v10 = *(_DWORD *)(a1 + 228);
      v11 = *(_DWORD *)(a1 + 232);
      if ((*(_BYTE *)(a1 + 80) & 1) != 0)
        v12 = *(_DWORD *)(a1 + 236);
      else
        v12 = *(unsigned __int8 *)(a1 + 390) != 8;
    }
    else
    {
      v8 = *(_DWORD *)(a1 + 240);
      v9 = *(_DWORD *)(a1 + 244);
      v10 = *(_DWORD *)(a1 + 248);
      v11 = *(_DWORD *)(a1 + 252);
      v12 = *(_DWORD *)(a1 + 256);
    }
    if (a3 <= 0x4000)
    {
      v13 = (1 << (v10 - 1));
      if (a3 + 262 <= v13)
      {
        do
        {
          LODWORD(v13) = v13 >> 1;
          --v10;
        }
        while (v13 >= (int)a3 + 262);
      }
    }
    if ((*(_BYTE *)(a1 + 84) & 0x10) != 0)
      goto LABEL_31;
    v14 = *(_DWORD *)(a1 + 80);
    if ((v14 & 2) != 0
      && (*(_DWORD *)(a1 + 260) != v8
       || *(_DWORD *)(a1 + 264) != v9
       || *(_DWORD *)(a1 + 268) != v10
       || *(_DWORD *)(a1 + 272) != v11
       || *(_DWORD *)(a1 + 276) != v12))
    {
      if (deflateEnd((z_streamp)(a1 + 96)))
        png_warning(a1, "deflateEnd failed (ignored)");
      v14 = *(_DWORD *)(a1 + 80) & 0xFFFFFFFD;
      *(_DWORD *)(a1 + 80) = v14;
    }
    *(_QWORD *)(a1 + 96) = 0;
    v15 = (z_stream *)(a1 + 96);
    *(_DWORD *)(a1 + 104) = 0;
    *(_QWORD *)(a1 + 120) = 0;
    *(_DWORD *)(a1 + 128) = 0;
    if ((v14 & 2) != 0)
    {
      v7 = deflateReset(v15);
      if (!(_DWORD)v7)
        goto LABEL_31;
    }
    else
    {
      if (a2 == 1229209940 && (*(_BYTE *)(a1 + 84) & 0x11) != 0)
        v10 = -v10;
      v7 = deflateInit2_(v15, v8, v9, v10, v11, v12, "1.2.12", 112);
      if (!(_DWORD)v7)
      {
        *(_DWORD *)(a1 + 80) |= 2u;
LABEL_31:
        v7 = 0;
        *(_DWORD *)(a1 + 92) = a2;
        return v7;
      }
    }
    png_zstream_error(a1, v7);
    return v7;
  }
  *(_QWORD *)(a1 + 144) = "in use by IDAT";
  return 4294967294;
}

uint64_t png_image_size(uint64_t a1)
{
  uint64_t v1;
  unint64_t v2;
  BOOL v3;
  uint64_t result;
  unint64_t v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  char v11;
  unsigned int v12;
  unint64_t v13;
  unint64_t v14;
  unsigned int v15;
  uint64_t v16;

  v1 = *(unsigned int *)(a1 + 284);
  v2 = *(_QWORD *)(a1 + 296);
  if (v2 >> 15)
    v3 = 0;
  else
    v3 = v1 >> 15 == 0;
  if (!v3)
    return 0xFFFFFFFFLL;
  if (!*(_BYTE *)(a1 + 388))
    return v1 + v1 * v2;
  result = 0;
  v6 = *(unsigned __int8 *)(a1 + 394);
  v7 = *(_DWORD *)(a1 + 280);
  v8 = 7;
  v9 = 1;
  do
  {
    v10 = v9 - 1;
    if (v9 - 1 <= 1)
      v11 = 3;
    else
      v11 = v8 >> 1;
    v12 = (v7 + ~(-1 << v11) - (((v10 & 1) << (3 - (v9 >> 1))) & 7)) >> v11;
    if (v12)
    {
      v13 = (v6 >> 3) * (unint64_t)v12;
      v14 = (v6 * (unint64_t)v12 + 7) >> 3;
      if (v6 > 7)
        v14 = v13;
      v15 = (v8 + 1) >> 1;
      if (v10 < 3)
        LOBYTE(v15) = 3;
      v16 = (v1 - ((!(v10 & 1) << (3 - (v10 >> 1))) & 7) + ~(-1 << v15)) >> v15;
      result += v16 + v16 * v14;
    }
    ++v9;
    --v8;
  }
  while (v8);
  return result;
}

void (**_cg_png_write_chunk(void (**a1)(void), unsigned int *a2, Bytef *a3, unint64_t a4))(void)
{
  return _cg_png_write_complete_chunk(a1, bswap32(*a2), a3, a4);
}

uint64_t IIOImageWriteSession::seek(IIOImageWriteSession *this, uint64_t a2, int a3)
{
  uint64_t v4;
  char *v5;
  FILE *v6;

  v4 = a2;
  if (a3)
  {
    if (a3 == 2)
    {
      v5 = (char *)this + 56;
    }
    else
    {
      if (a3 != 1)
        return -1;
      v5 = (char *)this + 64;
    }
    v4 = *(_QWORD *)v5 + a2;
  }
  v6 = (FILE *)*((_QWORD *)this + 4);
  if (!v6 || !fseek(v6, a2, a3))
  {
    *((_QWORD *)this + 8) = v4;
    return v4;
  }
  return -1;
}

void (**_cg_png_write_start_row(uint64_t a1))(void)
{
  unsigned int v2;
  unsigned int v3;
  unint64_t v4;
  unint64_t v5;
  size_t v6;
  void *v7;
  void (**result)(void);
  unsigned int v9;
  unsigned int v10;
  int v11;
  unsigned int v12;

  v2 = *(unsigned __int8 *)(a1 + 393) * *(unsigned __int8 *)(a1 + 396);
  v3 = *(_DWORD *)(a1 + 280);
  v4 = (v3 * (unint64_t)v2 + 7) >> 3;
  v5 = v3 * (unint64_t)(v2 >> 3);
  if (v2 < 8)
    v5 = v4;
  v6 = v5 + 1;
  *(_BYTE *)(a1 + 399) = *(_BYTE *)(a1 + 394);
  *(_BYTE *)(a1 + 398) = v2;
  v7 = *(void **)(a1 + 328);
  if (v7)
    free(v7);
  result = png_malloc((void (**)(void))a1, v6);
  *(_QWORD *)(a1 + 328) = result;
  *(_BYTE *)result = 0;
  v9 = *(unsigned __int8 *)(a1 + 390);
  if (*(_DWORD *)(a1 + 284) == 1)
    v9 &= 0x1Fu;
  if (*(_DWORD *)(a1 + 280) == 1)
    v9 &= 0x2Fu;
  if ((_BYTE)v9)
    v10 = v9;
  else
    v10 = 8;
  *(_BYTE *)(a1 + 390) = v10;
  if (v10 >= 0x10)
  {
    if (!*(_QWORD *)(a1 + 336))
    {
      result = png_malloc((void (**)(void))a1, v6);
      *(_QWORD *)(a1 + 336) = result;
      if (((v10 >> 5) & 1) + (v10 >> 7) + ((v10 >> 4) & 1) + ((v10 >> 6) & 1) >= 2)
      {
        result = png_malloc((void (**)(void))a1, v6);
        *(_QWORD *)(a1 + 344) = result;
      }
    }
    if (v10 >= 0x20)
    {
      result = png_calloc((void (**)(void))a1, v6);
      *(_QWORD *)(a1 + 320) = result;
    }
  }
  if (!*(_BYTE *)(a1 + 388))
  {
    v11 = *(_DWORD *)(a1 + 284);
    goto LABEL_22;
  }
  v11 = *(_DWORD *)(a1 + 284);
  if ((*(_BYTE *)(a1 + 88) & 2) != 0)
  {
LABEL_22:
    *(_DWORD *)(a1 + 288) = v11;
    v12 = *(_DWORD *)(a1 + 280);
    goto LABEL_23;
  }
  *(_DWORD *)(a1 + 288) = (v11 + 7) >> 3;
  v12 = (*(_DWORD *)(a1 + 280) + 7) >> 3;
LABEL_23:
  *(_DWORD *)(a1 + 292) = v12;
  return result;
}

unsigned __int8 *optimize_cmf(unsigned __int8 *result, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  BOOL v5;
  int v6;
  unsigned __int8 v7;
  int v8;

  if (a2 <= 0x4000)
  {
    v2 = *result;
    if ((v2 & 0xF) == 8)
    {
      v3 = v2 >> 4;
      v4 = 128 << (*result >> 4);
      v5 = (v2 & 0xF0) <= 0x70 && v4 >= a2;
      if (v5)
      {
        v6 = ((v3 & 0xF) << 12) | 0x800;
        v7 = (v2 & 0xF0) + 8;
        v8 = v3 - 1;
        do
        {
          v6 -= 4096;
          v7 -= 16;
          v5 = v8-- != 0;
          if (!v5)
            break;
          v4 = v4 >> 1;
        }
        while (v4 >= a2);
        *result = v7;
        result[1] = (result[1] & 0xE0 | ((result[1] & 0xE0) - 31 * (((result[1] & 0xE0u) + v6) / 0x1F))) ^ 0x1F;
      }
    }
  }
  return result;
}

uint64_t png_write_eXIf(uint64_t a1, Bytef *a2, int a3)
{
  uint64_t v3;
  Bytef v6;
  Bytef v8;

  LODWORD(v3) = a3;
  v8 = 0;
  _cg_png_write_chunk_header(a1, 1700284774);
  if ((int)v3 >= 1)
  {
    v3 = v3;
    do
    {
      v6 = *a2++;
      v8 = v6;
      _cg_png_write_chunk_data(a1, &v8, 1);
      --v3;
    }
    while (v3);
  }
  return _cg_png_write_chunk_end(a1);
}

uint64_t _cg_png_write_chunk_data(uint64_t result, Bytef *a2, uint64_t a3)
{
  uint64_t v5;

  if (result && a2)
  {
    if (a3)
    {
      v5 = result;
      png_write_data(result);
      return png_calculate_crc(v5, a2, a3);
    }
  }
  return result;
}

uint64_t png_write_data(uint64_t a1)
{
  uint64_t (*v1)(void);

  v1 = *(uint64_t (**)(void))(a1 + 24);
  if (!v1)
    _cg_png_error((void (**)(void))a1, "Call to NULL write function");
  return v1();
}

size_t write_fn(void (**a1)(void), const void *a2, size_t a3)
{
  IIOImageWriteSession *io_ptr;
  size_t result;

  io_ptr = (IIOImageWriteSession *)_cg_png_get_io_ptr((uint64_t)a1);
  result = IIOImageWriteSession::putBytes(io_ptr, a2, a3);
  if (result != a3)
    _cg_png_error(a1, "Write Error");
  return result;
}

size_t IIOImageWriteSession::putBytes(IIOImageWriteSession *this, const void *__ptr, size_t __nitems)
{
  size_t v3;
  FILE *v6;
  int *v7;
  __CFData *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  size_t v13;
  UInt8 *MutableBytePtr;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  char v20[1024];
  uint64_t v21;

  v3 = __nitems;
  v21 = *MEMORY[0x1E0C80C00];
  v6 = (FILE *)*((_QWORD *)this + 4);
  if (v6)
  {
    if (fwrite(__ptr, 1uLL, __nitems, v6) != __nitems)
    {
      __error();
      v7 = __error();
      strerror(*v7);
      LogError("putBytes", 250, "*** ERROR: failed to write %ld bytes - got: %ld  (err = %d '%s')\n");
      return 0;
    }
  }
  else
  {
    v8 = (__CFData *)*((_QWORD *)this + 3);
    if (v8)
    {
      v10 = *((_QWORD *)this + 7);
      v9 = *((_QWORD *)this + 8);
      if (v9 == v10)
      {
        CFDataAppendBytes(v8, (const UInt8 *)__ptr, __nitems);
      }
      else
      {
        v13 = v9 + __nitems;
        if (v13 > v10)
        {
          CFDataIncreaseLength(v8, v13 - v10);
          v8 = (__CFData *)*((_QWORD *)this + 3);
        }
        MutableBytePtr = CFDataGetMutableBytePtr(v8);
        memcpy(&MutableBytePtr[*((_QWORD *)this + 8)], __ptr, v3);
      }
    }
    else if (*((_QWORD *)this + 2))
    {
      v12 = *((_QWORD *)this + 7);
      v11 = *((_QWORD *)this + 8);
      if (v11 < v12)
      {
        LogError("putBytes", 271, "*** ERROR: cannot write unless at end of data\n");
        return 0;
      }
      bzero(v20, 0x400uLL);
      if (v11 > v12)
      {
        do
        {
          v15 = CGDataConsumerPutBytes();
          v16 = *((_QWORD *)this + 8);
          v17 = *((_QWORD *)this + 7) + v15;
          *((_QWORD *)this + 7) = v17;
        }
        while (v16 > v17);
      }
      v3 = CGDataConsumerPutBytes();
    }
  }
  v18 = *((_QWORD *)this + 8) + v3;
  if (v18 > *((_QWORD *)this + 7))
    *((_QWORD *)this + 7) = v18;
  *((_QWORD *)this + 8) = v18;
  return v3;
}

uint64_t _cg_png_write_chunk_end(uint64_t result)
{
  if (result)
  {
    *(_DWORD *)(result + 956) = 130;
    return png_write_data(result);
  }
  return result;
}

void *IIOImagePixelDataProvider::createEncodingTempBuffer(IIOImagePixelDataProvider *this, unint64_t *a2, unint64_t *a3)
{
  unint64_t v6;
  size_t v7;
  size_t v8;
  void *memptr;

  if (IIOImagePixelDataProvider::createEncodingTempBuffer(unsigned long *,unsigned long *)::once != -1)
    dispatch_once(&IIOImagePixelDataProvider::createEncodingTempBuffer(unsigned long *,unsigned long *)::once, &__block_literal_global_40);
  if (*((uint64_t (**)(IIOImagePixelDataProvider *__hidden, void *, void *, unint64_t))this + 22) == IIOImagePixelDataProvider::GetBytesCGAccessSessionNoConvert)
  {
    v6 = 1;
  }
  else
  {
    v6 = *((_QWORD *)this + 21);
    if (!v6)
    {
      v6 = (unint64_t)IIOImagePixelDataProvider::createEncodingTempBuffer(unsigned long *,unsigned long *)::recommendedBufferSize
         / *((_QWORD *)this + 18);
      if (v6 >= *((_QWORD *)this + 4))
        v6 = *((_QWORD *)this + 4);
      if (v6 <= 1)
        v6 = 1;
    }
  }
  *a2 = v6;
  v7 = *((_QWORD *)this + 18) * v6;
  *a3 = v7;
  memptr = 0;
  if (!malloc_type_posix_memalign(&memptr, 0x40uLL, v7, 0xB8CC112uLL))
    return memptr;
  *a2 = 1;
  v8 = *((_QWORD *)this + 18);
  *a3 = v8;
  return malloc_type_malloc(v8, 0xA633ABACuLL);
}

uint64_t IIOImagePixelDataProvider::getBitmapInfo(IIOImagePixelDataProvider *this)
{
  return *((unsigned int *)this + 24);
}

uint64_t png_text_compress(uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t v7;
  unint64_t v8;
  _QWORD **v9;
  int v10;
  uint64_t v11;
  _QWORD *v12;
  int v13;
  uint64_t v14;
  int v15;

  v7 = png_deflate_claim(a1, a2, *(_QWORD *)(a3 + 8));
  if ((_DWORD)v7)
    return v7;
  v8 = *(_QWORD *)(a3 + 8);
  *(_QWORD *)(a1 + 96) = *(_QWORD *)a3;
  v9 = (_QWORD **)(a1 + 208);
  *(_QWORD *)(a1 + 120) = a3 + 20;
  v10 = 1024;
  *(_DWORD *)(a1 + 128) = 1024;
  while (1)
  {
    if (v8 >= 0xFFFFFFFF)
      v11 = 0xFFFFFFFFLL;
    else
      v11 = v8;
    v8 -= v11;
    *(_DWORD *)(a1 + 104) = v11;
    if (*(_DWORD *)(a1 + 128))
      goto LABEL_12;
    if (v10 + a4 < 0)
      goto LABEL_14;
    v12 = *v9;
    if (!*v9)
      break;
LABEL_11:
    *(_QWORD *)(a1 + 120) = v12[1];
    v13 = *(_DWORD *)(a1 + 216);
    *(_DWORD *)(a1 + 128) = v13;
    v10 += v13;
    v9 = (_QWORD **)v12;
LABEL_12:
    v14 = deflate((z_streamp)(a1 + 96), 4 * (v8 == 0));
    v8 += *(unsigned int *)(a1 + 104);
    *(_DWORD *)(a1 + 104) = 0;
    if ((_DWORD)v14)
    {
      v7 = v14;
      goto LABEL_15;
    }
  }
  v12 = png_malloc_base(a1, *(unsigned int *)(a1 + 216) + 16);
  if (v12)
  {
    *v12 = 0;
    v12[1] = v12 + 2;
    *v9 = v12;
    goto LABEL_11;
  }
LABEL_14:
  v7 = 4294967292;
LABEL_15:
  v15 = v10 - *(_DWORD *)(a1 + 128);
  *(_DWORD *)(a1 + 128) = 0;
  *(_DWORD *)(a3 + 16) = v15;
  if ((v15 + a4) < 0x7FFFFFFF)
  {
    png_zstream_error(a1, v7);
    *(_DWORD *)(a1 + 92) = 0;
    if ((_DWORD)v7 == 1 && !v8)
    {
      optimize_cmf((unsigned __int8 *)(a3 + 20), *(_QWORD *)(a3 + 8));
      return 0;
    }
  }
  else
  {
    *(_QWORD *)(a1 + 144) = "compressed data too long";
    *(_DWORD *)(a1 + 92) = 0;
    return 4294967292;
  }
  return v7;
}

void (**_cg_png_insert_iDOTBreak(uint64_t a1))(void)
{
  z_stream *v2;
  int v3;
  void (**result)(void);
  const char *v5;

  v2 = (z_stream *)(a1 + 96);
  while (1)
  {
    if (deflate(v2, 3))
    {
      v5 = *(const char **)(a1 + 144);
      if (!v5)
        v5 = "zlib error";
      _cg_png_error((void (**)(void))a1, v5);
    }
    v3 = *(_DWORD *)(a1 + 128);
    if (v3)
      break;
    _cg_png_write_complete_chunk((void (**)(void))a1, 1229209940, *(Bytef **)(*(_QWORD *)(a1 + 208) + 8), *(unsigned int *)(a1 + 216));
    *(_QWORD *)(a1 + 120) = *(_QWORD *)(*(_QWORD *)(a1 + 208) + 8);
    *(_DWORD *)(a1 + 128) = *(_DWORD *)(a1 + 216);
  }
  if (*(_DWORD *)(a1 + 104) != v3)
    _cg_png_write_complete_chunk((void (**)(void))a1, 1229209940, *(Bytef **)(*(_QWORD *)(a1 + 208) + 8), (*(_DWORD *)(a1 + 216) - v3));
  *(_DWORD *)(a1 + 444) = 0;
  png_flush(a1);
  _cg_png_cleanup_for_write_start_row(a1);
  *(_DWORD *)(a1 + 92) = 0;
  *(_DWORD *)(a1 + 84) |= 0x10u;
  result = _cg_png_write_start_row(a1);
  *(_QWORD *)(a1 + 120) = *(_QWORD *)(*(_QWORD *)(a1 + 208) + 8);
  *(_DWORD *)(a1 + 128) = *(_DWORD *)(a1 + 216);
  return result;
}

uint64_t png_write_compressed_data_out(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unsigned int v3;
  Bytef *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t result;
  unsigned int v9;
  _QWORD *v10;

  v2 = a1;
  v3 = *(_DWORD *)(a2 + 16);
  v4 = (Bytef *)(a2 + 20);
  v5 = *(_QWORD **)(a1 + 208);
  if (v3 >= 0x400)
    v6 = 1024;
  else
    v6 = v3;
  while (1)
  {
    result = _cg_png_write_chunk_data(a1, v4, v6);
    v3 -= v6;
    if (!v3 || v5 == 0)
      break;
    v9 = *(_DWORD *)(v2 + 216);
    v10 = v5;
    v5 = (_QWORD *)*v5;
    v4 = (Bytef *)v10[1];
    if (v9 >= v3)
      v6 = v3;
    else
      v6 = v9;
    a1 = v2;
  }
  if (v3)
    _cg_png_error((void (**)(void))v2, "error writing ancillary chunked compressed data");
  return result;
}

uint64_t png_flush(uint64_t result)
{
  uint64_t (*v1)(void);

  v1 = *(uint64_t (**)(void))(result + 432);
  if (v1)
    return v1();
  return result;
}

uint64_t png_check_keyword(uint64_t a1, unsigned __int8 *a2, _BYTE *a3)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  int v7;
  _BYTE *v8;
  unsigned int v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  unint64_t v13;
  _OWORD v15[16];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v4 = *a2;
    if (*a2)
    {
      v5 = 0;
      v6 = 0;
      v7 = 1;
      v8 = a2;
      do
      {
        if (v4 > 0xA0 || v4 - 33 <= 0x5D)
        {
          v7 = 0;
          *a3++ = v4;
          ++v6;
        }
        else
        {
          if (v7)
          {
            if (!v5)
              v5 = v4;
          }
          else
          {
            *a3++ = 32;
            ++v6;
            if (v4 != 32)
              v5 = v4;
          }
          v7 = 1;
        }
        v9 = *++v8;
        v4 = v9;
      }
      while (v9 && v6 < 0x4F);
    }
    else
    {
      v6 = 0;
      v5 = 0;
      v7 = 1;
      v8 = a2;
    }
    if (v6)
      v11 = v7 == 0;
    else
      v11 = 1;
    v12 = !v11;
    if ((v12 & (v5 == 0)) != 0)
      v13 = 32;
    else
      v13 = v5;
    a3[-v12] = 0;
    v10 = v6 - v12;
    if ((_DWORD)v10)
    {
      if (*v8)
      {
        png_warning(a1, "keyword truncated");
      }
      else if ((_DWORD)v13)
      {
        memset(v15, 0, sizeof(v15));
        png_warning_parameter((uint64_t)v15, 1, a2);
        png_warning_parameter_signed((uint64_t)v15, 2, 4, v13);
        png_formatted_warning(a1, (uint64_t)v15, "keyword \"@1\": bad character '0x@2'");
      }
    }
  }
  else
  {
    v10 = 0;
    *a3 = 0;
  }
  return v10;
}

uint64_t _cg_png_set_do_filter(uint64_t result, char a2)
{
  *(_BYTE *)(result + 390) = a2;
  return result;
}

uint64_t _cg_png_get_do_filter(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 390);
}

void _cg_png_cleanup_for_write_start_row(uint64_t a1)
{
  void *v2;
  void *v3;

  v2 = *(void **)(a1 + 328);
  if (v2)
  {
    free(v2);
    *(_QWORD *)(a1 + 328) = 0;
  }
  v3 = *(void **)(a1 + 320);
  if (v3)
  {
    free(v3);
    *(_QWORD *)(a1 + 320) = 0;
  }
}

uint64_t IIOImagePixelDataProvider::rewind(IIOImagePixelDataProvider *this)
{
  uint64_t result;

  *((_QWORD *)this + 19) = 0;
  result = *((_QWORD *)this + 30);
  if (result)
    return CGAccessSessionRewind();
  return result;
}

void IIOTextureHandler::UnlockDataCallback(IIOTextureHandler *this, void *a2)
{
  uint64_t v3;

  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "UnlockDataCallback", 0, 0, -1, 0);
  if (this)
  {
    v3 = *((_QWORD *)this + 1);
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 48))(v3);
  }
}

CFStringRef CGImageSourceGetType(CGImageSourceRef isrc)
{
  unsigned int v2;
  CFTypeID v3;
  uint64_t v4;
  const __CFDictionary *Type;
  const __CFString *v6;
  IIO_Reader *v7;

  kdebug_trace();
  IIOInitDebugFlags();
  v2 = (gIIODebugFlags >> 12) & 3;
  if (v2)
    ImageIODebugOptions(v2, "A", "CGImageSourceGetType", isrc, 0, -1, 0);
  if (!isrc)
  {
    LogError("CGImageSourceGetType", 4732, "*** ERROR: CGImageSourceGetType: source is nil\n");
LABEL_23:
    v6 = 0;
    goto LABEL_19;
  }
  v3 = CFGetTypeID(isrc);
  if (CGImageSourceGetTypeID::once != -1)
    dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_139);
  if (v3 != CGImageSourceGetTypeID::id)
  {
    LogError("CGImageSourceGetType", 4733, "*** ERROR: CGImageSourceGetType: source is not a CGImageSourceRef\n");
    goto LABEL_23;
  }
  v4 = *((_QWORD *)isrc + 3);
  if (!v4)
  {
    v6 = 0;
    goto LABEL_19;
  }
  if (*(_BYTE *)(v4 + 65))
  {
    LogError("CGImageSourceGetType", 4738, "*** ERROR: invalid CGImageSourceRef (non-matching hint)\n");
    goto LABEL_23;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 200));
  if (IIOImageSource::isProxy((IIOImageSource *)v4))
  {
    Type = IIOImageSource::proxyGetType((IIODictionary **)v4);
  }
  else
  {
    if (!IIOImageSource::bindToReader((IIOImageSource *)v4))
    {
      v6 = 0;
      goto LABEL_16;
    }
    Type = (const __CFDictionary *)IIO_Reader::utType(*(IIO_Reader **)(v4 + 80));
  }
  v6 = (const __CFString *)Type;
LABEL_16:
  v7 = *(IIO_Reader **)(v4 + 80);
  if (v7)
    IIO_Reader::osType(v7);
  pthread_mutex_unlock((pthread_mutex_t *)(v4 + 200));
LABEL_19:
  kdebug_trace();
  return v6;
}

CGImageSourceRef CGImageSourceCreateWithDataProvider(CGDataProviderRef provider, CFDictionaryRef options)
{
  CFTypeID v4;
  CFTypeID v5;
  uint64_t v6;
  IIO_Reader *v7;
  unsigned int v8;
  int v9;
  _QWORD v11[3];

  kdebug_trace();
  IIOInitDebugFlags();
  if (provider)
  {
    v4 = CFGetTypeID(provider);
    if (v4 == CGDataProviderGetTypeID())
    {
      if (options)
      {
        v5 = CFGetTypeID(options);
        if (v5 != CFDictionaryGetTypeID())
        {
          LogError("CGImageSourceCreateWithDataProvider", 4374, "*** ERROR: CGImageSourceCreateWithDataProvider: options parameter is not a CFDictionaryRef - ignoring\n");
          options = 0;
        }
      }
      memset(v11, 0, sizeof(v11));
      IIODictionary::IIODictionary((IIODictionary *)v11, options);
      v6 = operator new();
      IIOImageSource::IIOImageSource((IIOImageSource *)v6, provider, (IIODictionary *)v11);
      pthread_mutex_lock((pthread_mutex_t *)(v6 + 200));
      provider = (CGDataProviderRef)CGImageSourceRefCreateWith_ImageSource(v6);
      v7 = *(IIO_Reader **)(v6 + 80);
      if (v7)
        IIO_Reader::osType(v7);
      pthread_mutex_unlock((pthread_mutex_t *)(v6 + 200));
      IIODictionary::~IIODictionary((IIODictionary *)v11);
    }
    else
    {
      LogError("CGImageSourceCreateWithDataProvider", 4371, "*** ERROR: CGImageSourceCreateWithDataProvider: dataConsumer is not a CGDataProviderRef\n");
      provider = 0;
    }
  }
  else
  {
    LogError("CGImageSourceCreateWithDataProvider", 4370, "*** ERROR: CGImageSourceCreateWithDataProvider: dataProvider is nil\n");
  }
  v8 = gIIODebugFlags;
  if ((gIIODebugFlags & 0x800000000000) != 0 && !provider)
  {
    ImageIOLog("∆∆∆ ISSUE: %s:%d:  %s\n", "CGImageSourceCreateWithDataProvider", 4393, "could not create CGImageSourceRef");
    v8 = gIIODebugFlags;
  }
  v9 = (v8 >> 12) & 3;
  if (v9)
    ImageIODebugOptions(v9, "A", "CGImageSourceCreateWithDataProvider", provider, 0, -1, options);
  if (!provider)
    kdebug_trace();
  kdebug_trace();
  return provider;
}

void sub_187E7085C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v4;
  va_list va;

  va_start(va, a4);
  MEMORY[0x18D761C30](v4, 0x10E1C40B803A584);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void IIOImageSource::IIOImageSource(IIOImageSource *this, CGDataProvider *a2, IIODictionary *a3)
{
  const __CFData *v6;

  *(_QWORD *)this = &off_1E1BAE3E0;
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 17) = 0;
  *((_QWORD *)this + 22) = 0;
  *((_QWORD *)this + 23) = 0;
  *((_QWORD *)this + 24) = 0;
  IIOImageSource::setup((uint64_t)this, 2);
  if (a3)
    IIOImageSource::extractOptions(this, a3);
  *((_QWORD *)this + 2) = CGImageReadCreateWithProvider(*((_QWORD *)this + 1), a2, (CGDataProvider *)1);
  if ((gIIODebugFlags & 0x10000000) != 0)
  {
    v6 = CGDataProviderCopyData(a2);
    if (v6)
    {
      ImageIO_saveImageData("imageProvider", v6);
      CFRelease(v6);
    }
  }
}

void sub_187E70950(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void *v5;
  void *v6;

  v5 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 184) = v5;
    operator delete(v5);
  }
  v6 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 128) = v6;
    operator delete(v6);
  }
  _Unwind_Resume(exception_object);
}

uint64_t IIOImageRead::IIOImageRead(uint64_t a1, const UInt8 *a2, CFIndex a3, int a4, char a5)
{
  CFDataRef v9;

  *(_QWORD *)a1 = &off_1E1BAC230;
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 248) = 0;
  *(_QWORD *)(a1 + 240) = a1 + 248;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 256) = 0;
  *(_QWORD *)(a1 + 296) = 0;
  *(_QWORD *)(a1 + 304) = 0;
  *(_QWORD *)(a1 + 288) = 0;
  IIOImageRead::setup(a1, a4);
  *(_BYTE *)(a1 + 64) = a5;
  *(_BYTE *)(a1 + 65) = a5 ^ 1;
  v9 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, a3, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  *(_QWORD *)(a1 + 32) = v9;
  if ((gIIODebugFlags & 0x80000000000) != 0)
    ImageIOLog("D   %s:%d CFDataCreateWithBytesNoCopy %p\n", "IIOImageRead", 541, v9);
  *(_QWORD *)(a1 + 80) = a3;
  return a1;
}

void sub_187E70A74(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;
  _QWORD **v4;
  void **v5;
  void *v7;
  void *v8;

  v7 = *v5;
  if (*v5)
  {
    *(_QWORD *)(v1 + 296) = v7;
    operator delete(v7);
  }
  std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::destroy(v2, *v4);
  v8 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 160) = v8;
    operator delete(v8);
  }
  _Unwind_Resume(a1);
}

uint64_t IIOImageRead::IIOImageRead(uint64_t a1, const __CFData *a2, int a3, int a4, char a5, char a6)
{
  *(_QWORD *)a1 = &off_1E1BAC230;
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 248) = 0;
  *(_QWORD *)(a1 + 240) = a1 + 248;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 256) = 0;
  *(_QWORD *)(a1 + 296) = 0;
  *(_QWORD *)(a1 + 304) = 0;
  *(_QWORD *)(a1 + 288) = 0;
  IIOImageRead::setup(a1, a3);
  if (gCopyInputData)
  {
    *(_QWORD *)(a1 + 32) = CFDataCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2);
    if ((gIIODebugFlags & 0x80000000000) != 0)
      ImageIOLog("D   %s:%d CFDataCreateCopy %p\n");
  }
  else
  {
    *(_QWORD *)(a1 + 32) = CFRetain(a2);
    if ((gIIODebugFlags & 0x80000000000) != 0)
      ImageIOLog("D   %s:%d CFRetain %p\n");
  }
  *(_BYTE *)(a1 + 71) = a5;
  *(_QWORD *)(a1 + 80) = CFDataGetLength(a2);
  *(_BYTE *)(a1 + 64) = a6;
  *(_BYTE *)(a1 + 65) = a6 ^ 1;
  *(_BYTE *)(a1 + 66) = 1;
  *(_BYTE *)(a1 + 67) = a4;
  *(_DWORD *)(a1 + 440) = a4;
  return a1;
}

void sub_187E70BF4(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;
  _QWORD **v4;
  void **v5;
  void *v7;
  void *v8;

  v7 = *v5;
  if (*v5)
  {
    *(_QWORD *)(v1 + 296) = v7;
    operator delete(v7);
  }
  std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::destroy(v2, *v4);
  v8 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 160) = v8;
    operator delete(v8);
  }
  _Unwind_Resume(a1);
}

uint64_t CGImageReadCreateWithURL(uint64_t a1, const __CFURL *a2, unsigned __int8 *a3, int a4, int a5)
{
  CFStringRef v10;
  const __CFURL *v11;
  IIOImageRead *v12;
  __CFString __s1;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v10 = IIO_CFURLCopyResolvedFileSystemPath(a2);
    if (v10)
    {
      v11 = (const __CFURL *)v10;
      bzero(&__s1, 0x400uLL);
      if (_CFStringGetFileSystemRepresentation())
      {
        v12 = IIOImageRead::CreateWithURL(a2, v11, &__s1, a3, a4, a5);
        CFRelease(v11);
        if (v12)
        {
          pthread_mutex_lock((pthread_mutex_t *)((char *)v12 + 376));
          IIOImageRead::setISR(v12, a1);
          pthread_mutex_unlock((pthread_mutex_t *)((char *)v12 + 376));
          return CGImageReadRefCreateWith_ImageRead(v12);
        }
      }
      else
      {
        LogError("CGImageReadCreateWithURL", 2256, "*** ERROR: cannot get URL path\n");
        CFRelease(v11);
      }
    }
    else
    {
      LogError("CGImageReadCreateWithURL", 2249, "*** ERROR: cannot resolve URL\n");
    }
  }
  return 0;
}

CGImageSourceRef CGImageSourceCreateWithURL(CFURLRef url, CFDictionaryRef options)
{
  CFTypeID v4;
  CFTypeID v5;
  uint64_t v6;
  const void *v7;
  IIO_Reader *v8;
  CFStringRef v9;
  unsigned int v10;
  char v11;
  char v12;
  _QWORD v14[3];
  char v15[1024];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  IIOInitDebugFlags();
  kdebug_trace();
  if (url)
  {
    v4 = CFGetTypeID(url);
    if (v4 == CFURLGetTypeID())
    {
      if (options)
      {
        v5 = CFGetTypeID(options);
        if (v5 != CFDictionaryGetTypeID())
        {
          LogError("CGImageSourceCreateWithURL", 4495, "*** ERROR: CGImageSourceCreateWithURL: options parameter is not a CFDictionaryRef - ignoring\n");
          options = 0;
        }
      }
      memset(v14, 0, sizeof(v14));
      IIODictionary::IIODictionary((IIODictionary *)v14, options, 1);
      v6 = operator new();
      IIOImageSource::IIOImageSource((IIOImageSource *)v6, url, (IIODictionary *)v14);
      if (*(_DWORD *)(v6 + 328))
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
        v7 = 0;
      }
      else
      {
        pthread_mutex_lock((pthread_mutex_t *)(v6 + 200));
        v7 = (const void *)CGImageSourceRefCreateWith_ImageSource(v6);
        v8 = *(IIO_Reader **)(v6 + 80);
        if (v8)
          IIO_Reader::osType(v8);
        pthread_mutex_unlock((pthread_mutex_t *)(v6 + 200));
      }
      if ((gIIODebugFlags & 0x3000) != 0)
      {
        bzero(v15, 0x400uLL);
        v9 = IIO_CFURLCopyResolvedFileSystemPath(url);
        if (v9)
        {
          _CFStringGetFileSystemRepresentation();
          v10 = (gIIODebugFlags >> 12) & 3;
          if (v10)
            ImageIODebugOptions(v10, "A", "CGImageSourceCreateWithURL", v7, v15, -1, options);
          CFRelease(v9);
        }
      }
      IIODictionary::~IIODictionary((IIODictionary *)v14);
      if (v7)
      {
        v11 = 0;
        goto LABEL_21;
      }
    }
    else
    {
      LogError("CGImageSourceCreateWithURL", 4492, "*** ERROR: CGImageSourceCreateWithURL: url is not a CFURLRef\n");
    }
  }
  else
  {
    LogError("CGImageSourceCreateWithURL", 4491, "*** ERROR: CGImageSourceCreateWithURL: url is nil\n");
  }
  kdebug_trace();
  v7 = 0;
  v11 = 1;
LABEL_21:
  kdebug_trace();
  v12 = v11 ^ 1;
  if ((gIIODebugFlags & 0x800000000000) == 0)
    v12 = 1;
  if ((v12 & 1) == 0)
    ImageIOLog("∆∆∆ ISSUE: %s:%d:  %s\n", "CGImageSourceCreateWithURL", 4541, "could not create CGImageSourceRef");
  return (CGImageSourceRef)v7;
}

void sub_187E7105C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  uint64_t v13;

  if (a2)
  {
    MEMORY[0x18D761C30](v13, 0x10E1C40B803A584);
    IIODictionary::~IIODictionary((IIODictionary *)&a13);
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    JUMPOUT(0x187E70FA0);
  }
  _Unwind_Resume(exception_object);
}

CGImageSourceRef CGImageSourceCreateWithData(CFDataRef data, CFDictionaryRef options)
{
  CFTypeID v4;
  CFTypeID v5;
  CFTypeID TypeID;
  const __CFDictionary *v7;
  uint64_t v8;
  IIO_Reader *v9;
  unsigned int v10;
  const UInt8 *BytePtr;
  int64_t v12;
  size_t v13;
  uint64_t v14;
  int v15;
  char *v16;
  int v17;
  int v18;
  unsigned int v19;
  int v20;
  int v21;
  uint64_t v22;
  int v23;
  const __CFDictionary *v25;
  __CFData *v26;
  CFIndex Length;
  CFTypeRef cf;
  _WORD v29[40];
  char __dst[16];
  char __str[16];
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  kdebug_trace();
  IIOInitDebugFlags();
  if (!data)
  {
    LogError("CGImageSourceCreateWithData", 4414, "*** ERROR: CGImageSourceCreateWithData: data is nil\n");
LABEL_41:
    cf = 0;
    goto LABEL_33;
  }
  v4 = CFGetTypeID(data);
  if (v4 != CFDataGetTypeID())
  {
    LogError("CGImageSourceCreateWithData", 4415, "*** ERROR: CGImageSourceCreateWithData: data is not a CFDataRef\n");
    goto LABEL_41;
  }
  v26 = data;
  Length = CFDataGetLength(data);
  if (!options)
  {
LABEL_6:
    v7 = 0;
    goto LABEL_7;
  }
  v5 = CFGetTypeID(options);
  TypeID = CFDictionaryGetTypeID();
  v7 = options;
  if (v5 != TypeID)
  {
    LogError("CGImageSourceCreateWithData", 4419, "*** ERROR: CGImageSourceCreateWithData: options parameter is not a CFDictionaryRef - ignoring\n");
    goto LABEL_6;
  }
LABEL_7:
  memset(__str, 0, sizeof(__str));
  *(_QWORD *)&v32 = 0;
  v25 = v7;
  IIODictionary::IIODictionary((IIODictionary *)__str, v7);
  v8 = operator new();
  IIOImageSource::IIOImageSource((IIOImageSource *)v8, v26, (IIODictionary *)__str);
  pthread_mutex_lock((pthread_mutex_t *)(v8 + 200));
  cf = (CFTypeRef)CGImageSourceRefCreateWith_ImageSource(v8);
  v9 = *(IIO_Reader **)(v8 + 80);
  if (v9)
    IIO_Reader::osType(v9);
  pthread_mutex_unlock((pthread_mutex_t *)(v8 + 200));
  IIODictionary::~IIODictionary((IIODictionary *)__str);
  v10 = gIIODebugFlags;
  if ((gIIODebugFlags & 0x3000) != 0)
  {
    v35 = 0u;
    v36 = 0u;
    v33 = 0u;
    v34 = 0u;
    *(_OWORD *)__str = 0u;
    v32 = 0u;
    if (Length)
    {
      BytePtr = CFDataGetBytePtr(v26);
      if (Length >= 16)
        v12 = 16;
      else
        v12 = Length;
      if ((unint64_t)v12 <= 0xF)
        v13 = 16 - v12;
      else
        v13 = 0;
      bzero(&__dst[v12], v13);
      memcpy(__dst, BytePtr, v12);
      strcpy((char *)v29, "|x                                              |  |                |");
      if (Length >= 1)
      {
        if (v12 <= 1)
          v14 = 1;
        else
          v14 = v12;
        v15 = 1;
        v16 = __dst;
        v17 = 52;
        do
        {
          v18 = *v16++;
          v19 = v18;
          v20 = snprintf((char *)v29 + v15, 52 - v15, "%02X ", v18);
          if (v18 < 0)
            v21 = __maskrune(v19, 0x40000uLL);
          else
            v21 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v19 + 60) & 0x40000;
          v15 += v20;
          if (v21)
            v22 = v19;
          else
            v22 = 46;
          v17 += snprintf((char *)v29 + v17, 68 - v17, "%c", v22);
          --v14;
        }
        while (v14);
      }
      v29[24] = 8316;
      LOBYTE(v29[34]) = 124;
      snprintf(__str, 0x60uLL, "[%p]-(%ld) %s", v26, Length, (const char *)v29);
      v10 = gIIODebugFlags;
    }
    else
    {
      strcpy(__str, "(zero-length)");
    }
    v23 = (v10 >> 12) & 3;
    if (v23)
      ImageIODebugOptions(v23, "A", "CGImageSourceCreateWithData", cf, __str, -1, v25);
  }
LABEL_33:
  if ((gIIODebugFlags & 0x800000000000) != 0 && !cf)
  {
    ImageIOLog("∆∆∆ ISSUE: %s:%d:  %s\n", "CGImageSourceCreateWithData", 4472, "could not create CGImageSourceRef");
LABEL_37:
    kdebug_trace();
    goto LABEL_38;
  }
  if (!cf)
    goto LABEL_37;
LABEL_38:
  kdebug_trace();
  return (CGImageSourceRef)cf;
}

void sub_187E71500(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  uint64_t v29;

  MEMORY[0x18D761C30](v29, 0x10E1C40B803A584);
  IIODictionary::~IIODictionary((IIODictionary *)&a29);
  _Unwind_Resume(a1);
}

CFDictionaryRef CGImageSourceCopyPropertiesAtIndex(CGImageSourceRef isrc, size_t index, CFDictionaryRef options)
{
  unsigned int v6;
  CFTypeID v7;
  CFTypeID v8;
  uint64_t v9;
  pthread_mutex_t *v10;
  IIO_Reader *v11;
  const __CFDictionary *v12;
  const __CFDictionary *v13;
  const __CFDictionary *v15;
  uint64_t v16;
  uint64_t v17;

  kdebug_trace();
  IIOInitDebugFlags();
  v6 = (gIIODebugFlags >> 12) & 3;
  if (v6)
    ImageIODebugOptions(v6, "A", "CGImageSourceCopyPropertiesAtIndex", isrc, 0, index, options);
  if (isrc)
  {
    v7 = CFGetTypeID(isrc);
    if (CGImageSourceGetTypeID::once != -1)
      dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_139);
    if (v7 == CGImageSourceGetTypeID::id)
    {
      if (options)
      {
        v8 = CFGetTypeID(options);
        if (v8 != CFDictionaryGetTypeID())
        {
          LogError("CGImageSourceCopyPropertiesAtIndex", 5179, "*** ERROR: CGImageSourceCopyPropertiesAtIndex: options parameter is not a CFDictionaryRef - ignoring\n");
          options = 0;
        }
      }
      v9 = *((_QWORD *)isrc + 3);
      if (v9)
      {
        if (*(_BYTE *)(v9 + 65))
        {
          LogError("CGImageSourceCopyPropertiesAtIndex", 5186, "*** ERROR: invalid CGImageSourceRef (non-matching hint)\n");
        }
        else
        {
          v15 = 0;
          v16 = 0;
          v17 = 0;
          IIODictionary::IIODictionary((IIODictionary *)&v15, options);
          v10 = (pthread_mutex_t *)(v9 + 200);
          pthread_mutex_lock((pthread_mutex_t *)(v9 + 200));
          v11 = *(IIO_Reader **)(v9 + 80);
          if (v11)
            IIO_Reader::osType(v11);
          if (IIOImageSource::isProxy((IIOImageSource *)v9))
            v12 = (const __CFDictionary *)IIOImageSource::proxyCopyPropertiesAtIndex((IIODictionary **)v9, index, (IIODictionary *)&v15);
          else
            v12 = (const __CFDictionary *)IIOImageSource::copyPropertiesAtIndex((IIOImageSource *)v9, index, &v15);
          v13 = v12;
          pthread_mutex_unlock(v10);
          IIODictionary::~IIODictionary((IIODictionary *)&v15);
          if (v13)
          {
            v15 = 0;
            v16 = 0;
            v17 = 0;
            IIODictionary::IIODictionary((IIODictionary *)&v15, v13);
            IIOPackSrcInputInfo((IIODictionary *)&v15, index);
            IIODictionary::getCount((IIODictionary *)&v15);
            IIODictionary::~IIODictionary((IIODictionary *)&v15);
            goto LABEL_25;
          }
        }
      }
    }
    else
    {
      LogError("CGImageSourceCopyPropertiesAtIndex", 5176, "*** ERROR: CGImageSourceCopyPropertiesAtIndex: source is not a CGImageSourceRef\n");
    }
  }
  else
  {
    LogError("CGImageSourceCopyPropertiesAtIndex", 5175, "*** ERROR: CGImageSourceCopyPropertiesAtIndex: source is nil\n");
  }
  if ((gIIODebugFlags & 0x800000000000) != 0)
    ImageIOLog("∆∆∆ ISSUE: %s:%d:  %s\n", "CGImageSourceCopyPropertiesAtIndex", 5208, "could not create CFDictionaryRef");
  v13 = 0;
LABEL_25:
  kdebug_trace();
  return v13;
}

void sub_187E717CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

size_t CGImageSourceGetCount(CGImageSourceRef isrc)
{
  unsigned int v2;
  CFTypeID v3;
  uint64_t v4;
  CGImageSource *Count;
  IIO_Reader *v6;

  kdebug_trace();
  IIOInitDebugFlags();
  v2 = (gIIODebugFlags >> 12) & 3;
  if (v2)
    ImageIODebugOptions(v2, "A", "CGImageSourceGetCount", isrc, 0, -1, 0);
  if (!isrc)
  {
    LogError("CGImageSourceGetCount", 4773, "*** ERROR: CGImageSourceGetCount: source is nil\n");
    goto LABEL_16;
  }
  v3 = CFGetTypeID(isrc);
  if (CGImageSourceGetTypeID::once != -1)
    dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_139);
  if (v3 != CGImageSourceGetTypeID::id)
  {
    LogError("CGImageSourceGetCount", 4774, "*** ERROR: CGImageSourceGetCount: source is not a CGImageSourceRef\n");
LABEL_20:
    isrc = 0;
    goto LABEL_16;
  }
  v4 = *((_QWORD *)isrc + 3);
  if (!v4)
  {
    isrc = 0;
    goto LABEL_16;
  }
  if (*(_BYTE *)(v4 + 65))
  {
    LogError("CGImageSourceGetCount", 4779, "*** ERROR: invalid CGImageSourceRef (non-matching hint)\n");
    goto LABEL_20;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 200));
  if (IIOImageSource::isProxy((IIOImageSource *)v4))
    Count = (CGImageSource *)IIOImageSource::proxyGetCount((IIODictionary **)v4);
  else
    Count = (CGImageSource *)IIOImageSource::updatedCount((IIOImageSource *)v4);
  isrc = Count;
  v6 = *(IIO_Reader **)(v4 + 80);
  if (v6)
    IIO_Reader::osType(v6);
  pthread_mutex_unlock((pthread_mutex_t *)(v4 + 200));
LABEL_16:
  kdebug_trace();
  return (size_t)isrc;
}

CGImageRef CGImageSourceCreateImageAtIndex(CGImageSourceRef isrc, size_t index, CFDictionaryRef options)
{
  unsigned int v6;
  CFTypeID v7;
  CFTypeID v8;
  uint64_t v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  CGImage *v14;
  IIO_Reader *v15;
  CGColorSpace *ColorSpace;
  uint64_t v17;
  unsigned int v18;
  int v19;
  uint64_t v20;
  unsigned int v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  int v27;
  const __CFDictionary *v28[3];

  memset(v28, 0, sizeof(v28));
  IIODictionary::IIODictionary((IIODictionary *)v28, options);
  IIOPackSrcInputInfo((IIODictionary *)v28, index);
  kdebug_trace();
  IIOInitDebugFlags();
  v6 = (gIIODebugFlags >> 12) & 3;
  if (v6)
    ImageIODebugOptions(v6, "A", "CGImageSourceCreateImageAtIndex", isrc, 0, index, options);
  v27 = 0;
  if (!isrc)
  {
    LogError("CGImageSourceCreateImageAtIndex", 4947, "*** ERROR: CGImageSourceCreateImageAtIndex: source is nil\n");
LABEL_54:
    v9 = 0;
LABEL_12:
    v10 = 0;
LABEL_13:
    if ((gIIODebugFlags & 0x800000000000) != 0)
      ImageIOLog("∆∆∆ ISSUE: %s:%d:  %s\n", "CGImageSourceCreateImageAtIndex", 4972, "could not create CGImageRef");
    if (v9 && !IIOImageSource::isProxy((IIOImageSource *)v9))
    {
      kdebug_trace();
      v11 = v10 >> 24;
      v12 = MEMORY[0x1E0C80978];
      if (v10 < 0)
        v13 = __maskrune(v10 >> 24, 0x40000uLL);
      else
        v13 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v11 + 60) & 0x40000;
      if (v13)
        v17 = v11;
      else
        v17 = 46;
      v18 = v10 << 8 >> 24;
      if (v10 << 8 < 0)
        v19 = __maskrune(v10 << 8 >> 24, 0x40000uLL);
      else
        v19 = *(_DWORD *)(v12 + 4 * v18 + 60) & 0x40000;
      if (v19)
        v20 = v18;
      else
        v20 = 46;
      v21 = (__int16)v10 >> 8;
      if (v10 << 16 < 0)
        v22 = __maskrune((__int16)v10 >> 8, 0x40000uLL);
      else
        v22 = *(_DWORD *)(v12 + 4 * v21 + 60) & 0x40000;
      if ((v10 << 24) <= 0x7F000000)
        v23 = *(_DWORD *)(v12 + 4 * (char)v10 + 60) & 0x40000;
      else
        v23 = __maskrune((char)v10, 0x40000uLL);
      if (v22)
        v24 = v21;
      else
        v24 = 46;
      if (v23)
        v25 = (char)v10;
      else
        v25 = 46;
      LogError("CGImageSourceCreateImageAtIndex", 4984, "*** ERROR: CGImageSourceCreateImageAtIndex[%ld] - '%c%c%c%c' - failed to create image [%d]\n", index, v17, v20, v24, v25, v27);
    }
    v14 = 0;
    goto LABEL_51;
  }
  v7 = CFGetTypeID(isrc);
  if (CGImageSourceGetTypeID::once != -1)
    dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_139);
  if (v7 != CGImageSourceGetTypeID::id)
  {
    LogError("CGImageSourceCreateImageAtIndex", 4948, "*** ERROR: CGImageSourceCreateImageAtIndex: source is not a CGImageSourceRef\n");
    goto LABEL_54;
  }
  if (options)
  {
    v8 = CFGetTypeID(options);
    if (v8 != CFDictionaryGetTypeID())
      LogError("CGImageSourceCreateImageAtIndex", 4951, "*** ERROR: CGImageSourceCreateImageAtIndex: options parameter is not a CFDictionaryRef - ignoring\n");
  }
  v9 = *((_QWORD *)isrc + 3);
  if (!v9 || IIOImageSource::isProxy(*((IIOImageSource **)isrc + 3)))
    goto LABEL_12;
  if (*(_BYTE *)(v9 + 65))
  {
    LogError("CGImageSourceCreateImageAtIndex", 4958, "*** ERROR: invalid CGImageSourceRef (non-matching hint)\n");
    v10 = 0;
    goto LABEL_13;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v9 + 200));
  v14 = IIOImageSource::createImageAtIndex((IIOImageSource *)v9, index, v28, &v27);
  v15 = *(IIO_Reader **)(v9 + 80);
  if (v15)
    v10 = IIO_Reader::osType(v15);
  else
    v10 = 1848598816;
  pthread_mutex_unlock((pthread_mutex_t *)(v9 + 200));
  if (!v14)
    goto LABEL_13;
  if ((gIIODebugFlags & 0x10000000) != 0)
  {
    CFShow(v14);
    CGImageDumpToFile();
  }
  CGImageGetWidth(v14);
  CGImageGetHeight(v14);
  CGImageGetBitsPerPixel(v14);
  CGImageGetBitsPerComponent(v14);
  ColorSpace = CGImageGetColorSpace(v14);
  CGColorSpaceGetModel(ColorSpace);
  CGImageGetImageProvider();
  CGImageGetContentHeadroom();
  CGImageGetBitmapInfo(v14);
LABEL_51:
  kdebug_trace();
  IIO_CheckHeadroom("CGImageSourceCreateImageAtIndex", v10, v14, (IIODictionary *)v28);
  IIODictionary::~IIODictionary((IIODictionary *)v28);
  return v14;
}

void sub_187E71DFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

CGImage *IIOImageSource::createImageAtIndex(IIOImageSource *this, unint64_t a2, const __CFDictionary **a3, int *a4)
{
  _QWORD *ImagePlus;
  _QWORD *v8;
  const __CFArray *v9;
  CGImage *v10;
  IIOImagePlus *v11;
  int v12;
  IIOImageSource *Source;
  IIOImageRead *v14;
  unint64_t v15;
  unint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  int v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t Plugin;
  uint64_t v24;
  int v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  UInt8 v29;
  int v30;
  uint64_t v31;
  UInt8 v32;
  int v33;
  uint64_t v34;
  UInt8 v35;
  int v36;
  uint64_t v37;
  UInt8 v38;
  int v39;
  uint64_t v40;
  UInt8 v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  int *v46;
  IIO_Reader *v47;
  int v48;
  unsigned int v49;
  int v50;
  IIO_Reader *v51;
  uint64_t v52;
  signed int v53;
  unsigned int v54;
  int v55;
  unsigned int v56;
  const __CFAllocator *v57;
  CFDataRef v58;
  CFDataRef v59;
  CFNumberRef v60;
  IIODictionary *ImagePropertiesAtIndex;
  IIODictionary *v62;
  IIOImageSource *shouldCacheImmediately;
  unint64_t v64;
  IIO_Reader *v65;
  uint64_t v66;
  int v67;
  int v68;
  unsigned int v69;
  int v70;
  IIO_Reader *v71;
  uint64_t v72;
  int v73;
  unsigned int v74;
  IIO_Reader *v75;
  uint64_t v76;
  uint64_t v78;
  int v79;
  int v80;
  int v81;
  int v82;
  int v83;
  int v84;
  int v85;
  uint64_t v86;
  int v87;
  __int16 valuePtr;
  int v91;
  UInt8 v92[8];
  UInt8 bytes[16];
  uint64_t v94;
  CFRange v95;

  v94 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)v92 = 0;
  v91 = 0;
  if ((IIOImageSource::bindToReader(this) & 1) == 0)
  {
    Source = (IIOImageSource *)CGImageSourceGetSource(*((_QWORD *)this + 2));
    if (Source)
    {
      v14 = Source;
      v15 = IIOImageSource::reader(Source);
      if (v15 >= 8)
        v16 = 8;
      else
        v16 = v15;
      *(_QWORD *)bytes = 0;
      IIOImageRead::getBytesAtOffset(v14, bytes, 0, v16);
      v87 = *((unsigned __int8 *)this + 54);
      v86 = IIOImageSource::reader(v14);
      v17 = bytes[0];
      v18 = bytes[1];
      v85 = bytes[2];
      v84 = bytes[3];
      v83 = bytes[4];
      v82 = bytes[5];
      v81 = bytes[6];
      v80 = bytes[7];
      v19 = MEMORY[0x1E0C80978];
      if ((char)bytes[0] < 0)
      {
        v25 = bytes[1];
        v20 = __maskrune(bytes[0], 0x40000uLL);
        v21 = bytes[0];
        v22 = bytes[1];
        v18 = v25;
      }
      else
      {
        v20 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * bytes[0] + 60) & 0x40000;
        v21 = bytes[0];
        v22 = bytes[1];
      }
      if (v20)
        v26 = v21;
      else
        v26 = 46;
      v78 = v26;
      v79 = v18;
      if ((v22 & 0x80) != 0)
      {
        v27 = __maskrune(v22, 0x40000uLL);
        v22 = bytes[1];
      }
      else
      {
        v27 = *(_DWORD *)(v19 + 4 * v22 + 60) & 0x40000;
      }
      if (v27)
        v28 = v22;
      else
        v28 = 46;
      v29 = bytes[2];
      if ((char)bytes[2] < 0)
      {
        v30 = __maskrune(bytes[2], 0x40000uLL);
        v29 = bytes[2];
      }
      else
      {
        v30 = *(_DWORD *)(v19 + 4 * bytes[2] + 60) & 0x40000;
      }
      if (v30)
        v31 = v29;
      else
        v31 = 46;
      v32 = bytes[3];
      if ((char)bytes[3] < 0)
      {
        v33 = __maskrune(bytes[3], 0x40000uLL);
        v32 = bytes[3];
      }
      else
      {
        v33 = *(_DWORD *)(v19 + 4 * bytes[3] + 60) & 0x40000;
      }
      if (v33)
        v34 = v32;
      else
        v34 = 46;
      v35 = bytes[4];
      if ((char)bytes[4] < 0)
      {
        v36 = __maskrune(bytes[4], 0x40000uLL);
        v35 = bytes[4];
      }
      else
      {
        v36 = *(_DWORD *)(v19 + 4 * bytes[4] + 60) & 0x40000;
      }
      if (v36)
        v37 = v35;
      else
        v37 = 46;
      v38 = bytes[5];
      if ((char)bytes[5] < 0)
      {
        v39 = __maskrune(bytes[5], 0x40000uLL);
        v38 = bytes[5];
      }
      else
      {
        v39 = *(_DWORD *)(v19 + 4 * bytes[5] + 60) & 0x40000;
      }
      if (v39)
        v40 = v38;
      else
        v40 = 46;
      v41 = bytes[6];
      if ((char)bytes[6] < 0)
      {
        v42 = __maskrune(bytes[6], 0x40000uLL);
        v41 = bytes[6];
      }
      else
      {
        v42 = *(_DWORD *)(v19 + 4 * bytes[6] + 60) & 0x40000;
      }
      if (v42)
        v43 = v41;
      else
        v43 = 46;
      LOBYTE(v44) = bytes[7];
      if ((char)bytes[7] < 0)
      {
        v45 = __maskrune(bytes[7], 0x40000uLL);
        LOBYTE(v44) = bytes[7];
      }
      else
      {
        v45 = *(_DWORD *)(v19 + 4 * bytes[7] + 60) & 0x40000;
      }
      if (v45)
        v44 = v44;
      else
        v44 = 46;
      LogError("createImageAtIndex", 1878, "*** ERROR: createImageAtIndex %d could not find plugin for image source [%ld bytes] %02X %02X %02X %02X %02X %02X %02X %02X... '%c%c%c%c%c%c%c%c'\n", v87, v86, v17, v79, v85, v84, v83, v82, v81, v80, v78, v28, v31, v34, v37,
        v40,
        v43,
        v44);
    }
    else
    {
      LogError("createImageAtIndex", 1869, "*** ERROR: could not find plugin for image source - imageRead is NULL\n");
    }
    v10 = 0;
    v11 = 0;
    v12 = -62;
LABEL_69:
    v91 = v12;
    goto LABEL_70;
  }
  ImagePlus = IIOImageSource::makeImagePlus(this, a2, a3);
  *(_QWORD *)v92 = ImagePlus;
  if (!ImagePlus)
  {
    if ((gIIODebugFlags & 0x3000) != 0)
      ImageIOLog("*** %s:%d: makeImagePlus returned nil\n", "createImageAtIndex", 1889);
    v10 = 0;
    v11 = 0;
    v12 = -58;
    goto LABEL_69;
  }
  v8 = ImagePlus;
  v9 = (const __CFArray *)*((_QWORD *)this + 21);
  if (v9)
  {
    v95.length = CFArrayGetCount(*((CFArrayRef *)this + 21));
    v95.location = 0;
    if (CFArrayContainsValue(v9, v95, v8))
    {
      if ((gIIODebugFlags & 0x3000) != 0)
        ImageIOLog("*** %s:%d: 'createImage' returned incomplete iPlus: %p -- skipping image creation\n", "createImageAtIndex", 1898, 0);
      v10 = 0;
      v11 = 0;
      v12 = -59;
      goto LABEL_69;
    }
  }
  v11 = (IIOImagePlus *)v8[3];
  v10 = IIOImagePlus::createImage(v11, *((CGImageSource **)this + 1), &v91);
  if (v10)
  {
    CFSetAddValue(*((CFMutableSetRef *)this + 20), v10);
    Plugin = IIOImagePlus::readPlugin(v11);
    if (Plugin)
    {
      v24 = IIO_Reader::utType(*((IIO_Reader **)this + 10));
      (*(void (**)(uint64_t, CGImage *, uint64_t, unint64_t))(*(_QWORD *)Plugin + 120))(Plugin, v10, v24, a2);
    }
    else
    {
      IIO_Reader::utType(*((IIO_Reader **)this + 10));
      CGImageSetProperty();
      IIONumber::IIONumber((IIONumber *)bytes, a2);
      CGImageSetProperty();
      IIONumber::~IIONumber((IIONumber *)bytes);
      v56 = IIO_Reader::osType(*((IIO_Reader **)this + 10));
      IIOString::IIOString((IIOString *)bytes, v56);
      CGImageSetProperty();
      IIOString::~IIOString((IIOString *)bytes);
    }
    *(_QWORD *)bytes = *((_QWORD *)this + 2);
    v57 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v58 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], bytes, 8);
    if (v58)
    {
      CGImageSetProperty();
      CFRelease(v58);
    }
    v59 = CFDataCreate(v57, v92, 8);
    if (v59)
    {
      CGImageSetProperty();
      CFRelease(v59);
    }
    if (IIOImagePlus::getSubsampleFactor(v11))
    {
      valuePtr = IIOImagePlus::getSubsampleFactor(v11);
      v60 = CFNumberCreate(v57, kCFNumberSInt16Type, &valuePtr);
      if (v60)
      {
        CGImageSetProperty();
        CFRelease(v60);
      }
    }
    ImagePropertiesAtIndex = (IIODictionary *)IIOImageSource::getImagePropertiesAtIndex(this, a2);
    v62 = ImagePropertiesAtIndex;
    if (ImagePropertiesAtIndex
      && IIODictionary::containsKey(ImagePropertiesAtIndex, CFSTR("Orientation")))
    {
      IIODictionary::getObjectForKey(v62, CFSTR("Orientation"));
      CGImageSetProperty();
    }
    shouldCacheImmediately = (IIOImageSource *)IIOImagePlus::shouldCacheImmediately(v11);
    if ((_DWORD)shouldCacheImmediately)
      IIOImageSource::cacheImmediately(shouldCacheImmediately, v64, (IIODictionary *)a3, v10);
  }
  else
  {
    if ((gIIODebugFlags & 0x3000) != 0)
      ImageIOLog("*** %s:%d: 'createImage' returned nil (this: %p   iPlus: %p)\n", "createImageAtIndex", 1912, this, v11);
    v10 = 0;
  }
LABEL_70:
  IIOImageSource::removeUnusedImages((CFSetRef *)this);
  if ((gIIODebugFlags & 0x3000) == 0)
  {
    v46 = a4;
    if (v10)
      goto LABEL_127;
    v47 = (IIO_Reader *)*((_QWORD *)this + 10);
    if (v47)
    {
      v48 = IIO_Reader::osType(v47);
      v49 = v48 >> 24;
      if (v48 < 0)
      {
        v50 = __maskrune(v49, 0x40000uLL);
        goto LABEL_82;
      }
    }
    else
    {
      v49 = 110;
    }
    v50 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v49 + 60) & 0x40000;
LABEL_82:
    v51 = (IIO_Reader *)*((_QWORD *)this + 10);
    if (v50)
    {
      if (!v51)
      {
        v54 = 47;
        v52 = 110;
        goto LABEL_103;
      }
      v52 = ((int)IIO_Reader::osType(v51) >> 24);
      v51 = (IIO_Reader *)*((_QWORD *)this + 10);
      if (v51)
        goto LABEL_85;
    }
    else
    {
      v52 = 46;
      if (v51)
      {
LABEL_85:
        v53 = IIO_Reader::osType(v51) << 8;
        v54 = v53 >> 24;
        if (v53 < 0)
        {
          v55 = __maskrune(v54, 0x40000uLL);
          goto LABEL_104;
        }
LABEL_103:
        v55 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v54 + 60) & 0x40000;
LABEL_104:
        v65 = (IIO_Reader *)*((_QWORD *)this + 10);
        if (v55)
        {
          if (!v65)
          {
            v69 = 97;
            v66 = 47;
            goto LABEL_112;
          }
          v66 = ((int)(IIO_Reader::osType(v65) << 8) >> 24);
          v65 = (IIO_Reader *)*((_QWORD *)this + 10);
          if (v65)
            goto LABEL_107;
        }
        else
        {
          v66 = 46;
          if (v65)
          {
LABEL_107:
            v67 = IIO_Reader::osType(v65);
            v68 = v67 << 16;
            v69 = (__int16)v67 >> 8;
            if (v68 < 0)
            {
              v70 = __maskrune(v69, 0x40000uLL);
              goto LABEL_113;
            }
LABEL_112:
            v70 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v69 + 60) & 0x40000;
LABEL_113:
            v71 = (IIO_Reader *)*((_QWORD *)this + 10);
            if (v70)
            {
              if (!v71)
              {
                v74 = 32;
                v72 = 97;
                goto LABEL_123;
              }
              v72 = ((__int16)IIO_Reader::osType(v71) >> 8);
              v71 = (IIO_Reader *)*((_QWORD *)this + 10);
              if (v71)
              {
LABEL_116:
                v73 = IIO_Reader::osType(v71);
                v74 = (char)v73;
                if ((v73 << 24) > 0x7F000000)
                {
                  if (__maskrune((char)v73, 0x40000uLL))
                    goto LABEL_118;
                  goto LABEL_124;
                }
LABEL_123:
                if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v74 + 60) & 0x40000) != 0)
                {
LABEL_118:
                  v75 = (IIO_Reader *)*((_QWORD *)this + 10);
                  if (v75)
                    v76 = (char)IIO_Reader::osType(v75);
                  else
                    v76 = 32;
                  goto LABEL_126;
                }
LABEL_124:
                v76 = 46;
LABEL_126:
                LogError("createImageAtIndex", 2007, "*** ERROR: createImageAtIndex[%ld] - '%c%c%c%c' - failed to create image [%d]\n", a2, v52, v66, v72, v76, v91);
                goto LABEL_127;
              }
            }
            else
            {
              v72 = 46;
              if (v71)
                goto LABEL_116;
            }
            v74 = 32;
            goto LABEL_123;
          }
        }
        v69 = 97;
        goto LABEL_112;
      }
    }
    v54 = 47;
    goto LABEL_103;
  }
  v46 = a4;
  if (!v10)
    ImageIOLog("*** %s:%d: could not create image (nil) (this: %p  iPlus: %p)\n", "createImageAtIndex", 2005, this, v11);
LABEL_127:
  if (v46)
    *v46 = v91;
  return v10;
}

void sub_187E72700(_Unwind_Exception *a1)
{
  uint64_t v1;

  IIOString::~IIOString((IIOString *)(v1 - 120));
  _Unwind_Resume(a1);
}

uint64_t IIOImageSource::getImagePropertiesAtIndex(IIOImageSource *this, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *((_QWORD *)this + 15);
  v3 = *((_QWORD *)this + 16);
  if ((v3 - v2) >> 3 > a2)
    return *(_QWORD *)(v2 + 8 * a2);
  if (v3 != v2)
    _cg_jpeg_mem_term("getImagePropertiesAtIndex", 3926, "getImagePropertiesAtIndex index (%d) larger than vector size (%d)\n", a2, (v3 - v2) >> 3);
  return 0;
}

void IIOImageSource::removeUnusedImages(CFSetRef *this)
{
  CFIndex Count;
  CFIndex v3;
  const void **v4;
  const void **v5;
  const void **AllImagePlusValues;
  uint64_t v7;
  uint64_t v8;
  const void *v9;
  const void *v10;
  CFTypeID v11;
  uint64_t v12;
  const void *v13;
  IIOImagePlus *v15;
  uint64_t v16;

  Count = CFSetGetCount(this[20]);
  if (Count >= 2)
  {
    v3 = Count;
    v4 = (const void **)malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
    if (v4)
    {
      v5 = v4;
      v16 = 0;
      CFSetGetValues(this[20], v4);
      AllImagePlusValues = IIOImageSource::getAllImagePlusValues(this, &v16);
      v7 = 0;
      v8 = v16;
      v9 = (const void *)*MEMORY[0x1E0C9B0D0];
      do
      {
        v10 = v5[v7];
        v11 = CFGetTypeID(v10);
        if (v11 == CGImageGetTypeID() && CFGetRetainCount(v10) == 1)
        {
          if (v8 >= 1)
          {
            v12 = 0;
            while (1)
            {
              v13 = AllImagePlusValues[v12];
              if (v13 && v13 != v9)
              {
                v15 = (IIOImagePlus *)*((_QWORD *)v13 + 3);
                if ((const void *)IIOImagePlus::getImage(v15) == v5[v7])
                  break;
              }
              if (v8 == ++v12)
                goto LABEL_16;
            }
            IIOImagePlus::setRemoveCacheKey((uint64_t)v15, 1);
            IIOImagePlus::setImageIndex((uint64_t)v15, v12);
            IIOImageSource::setImagePlusAtIndex((uint64_t)this, 0, v12);
            AllImagePlusValues[v12] = v9;
          }
LABEL_16:
          CFSetRemoveValue(this[20], v5[v7]);
        }
        ++v7;
      }
      while (v7 != v3);
      if (AllImagePlusValues)
        free(AllImagePlusValues);
      free(v5);
    }
  }
}

uint64_t IIOImagePlus::shouldCacheImmediately(IIOImagePlus *this)
{
  return (*((unsigned __int8 *)this + 192) >> 2) & 1;
}

uint64_t IIOImagePlus::getSubsampleFactor(IIOImagePlus *this)
{
  return *((unsigned int *)this + 49);
}

uint64_t IIOImagePlus::readPlugin(IIOImagePlus *this)
{
  return *((_QWORD *)this + 21);
}

void IIOReadPlugin::addImageTypeIdentifier(IIOReadPlugin *this, CGImage *a2, const __CFString *a3, int a4)
{
  _BYTE v6[16];

  CGImageSetProperty();
  IIONumber::IIONumber((IIONumber *)v6, a4);
  CGImageSetProperty();
  IIONumber::~IIONumber((IIONumber *)v6);
  IIOString::IIOString((IIOString *)v6, *((_DWORD *)this + 51));
  CGImageSetProperty();
  IIOString::~IIOString((IIOString *)v6);
}

void sub_187E729DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void IIOImageSource::IIOImageSource(IIOImageSource *this, const __CFURL *a2, IIODictionary *a3)
{
  CFStringRef v6;
  IIO_ReaderHandler *v7;
  const __CFString *v8;
  off_t st_size;
  UInt8 *v10;
  FILE *v11;
  const __CFData *v12;
  uint64_t v13;
  IIO_ReaderHandler *v14;
  uint64_t v15;
  IIO_ReaderHandler *ReaderHandler;
  IIO_Reader *v17;
  IIO_Reader *v18;
  const __CFString *v19;
  const __CFURL *v20;
  const char *v21;
  IIO_ReaderHandler *v22;
  IIO_Reader *v23;
  IIOImageRead *v24;
  const __CFString *v25;
  const __CFString *v26;
  CFComparisonResult v27;
  int v28;
  uint64_t propertyValueTypeRefPtr;
  stat v30;
  char __filename[8];
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)this = &off_1E1BAE3E0;
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 17) = 0;
  *((_QWORD *)this + 22) = 0;
  *((_QWORD *)this + 23) = 0;
  *((_QWORD *)this + 24) = 0;
  IIOImageSource::setup((uint64_t)this, 3);
  if (a3)
    IIOImageSource::extractOptions(this, a3);
  v6 = IIO_CFURLCopyResolvedFileSystemPath(a2);
  v7 = (IIO_ReaderHandler *)CFURLCopyPathExtension(a2);
  v8 = (const __CFString *)v7;
  if ((gIIODebugFlags & 0x10000000) != 0 && v6)
  {
    bzero(__filename, 0x400uLL);
    if (_CFStringGetFileSystemRepresentation())
    {
      memset(&v30, 0, sizeof(v30));
      stat(__filename, &v30);
      st_size = v30.st_size;
      v10 = (UInt8 *)malloc_type_malloc(v30.st_size, 0x4B6237C2uLL);
      if (v10)
      {
        v11 = fopen(__filename, "r");
        if (v11)
        {
          if (fread(v10, 1uLL, st_size, v11) == st_size)
          {
            v12 = CFDataCreate(0, v10, st_size);
            if (v12)
            {
              ImageIO_saveImageData("imageURL", v12);
              CFRelease(v12);
            }
          }
          fclose(v11);
        }
        free(v10);
      }
    }
    goto LABEL_14;
  }
  if (v6)
  {
LABEL_14:
    *(_QWORD *)__filename = 0;
    v32 = 0;
    v33 = 0;
    IIOString::IIOString((IIOString *)__filename, v6);
    propertyValueTypeRefPtr = *MEMORY[0x1E0C9AE40];
    v13 = propertyValueTypeRefPtr;
    v14 = (IIO_ReaderHandler *)CFURLCopyResourcePropertyForKey(a2, (CFStringRef)*MEMORY[0x1E0C9B520], &propertyValueTypeRefPtr, 0);
    v15 = propertyValueTypeRefPtr;
    if (v13 == propertyValueTypeRefPtr)
    {
      v14 = (IIO_ReaderHandler *)CFURLCopyResourcePropertyForKey(a2, (CFStringRef)*MEMORY[0x1E0C9B530], &propertyValueTypeRefPtr, 0);
      v15 = propertyValueTypeRefPtr;
    }
    if (v13 == v15)
    {
      memset(&v30, 0, 24);
      IIOString::IIOString((IIOString *)&v30, v6);
      v21 = (const char *)IIOString::utf8String((IIOString *)&v30);
      LogError("IIOImageSource", 439, "*** ERROR: can't open '%s'  (fileExists == false)\n", v21);
      *((_DWORD *)this + 82) = -1;
      IIOString::~IIOString((IIOString *)&v30);
    }
    else
    {
      if (!*((_QWORD *)this + 7))
      {
        ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(v14);
        v17 = IIO_ReaderHandler::readerForPathExtension(ReaderHandler, v8);
        v18 = v17;
        if (!v17
          || (v19 = (const __CFString *)IIO_Reader::utType(v17), CFStringCompare(v19, CFSTR("public.tiff"), 0)))
        {
          IIOImageSource::setHintReader(this, v18);
        }
      }
      v20 = CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v6, kCFURLPOSIXPathStyle, 0);
      if (v20)
      {
        IIOImageSource::updateMemoryMapFlagForProtectionClass((uint64_t)this, (IIOString *)__filename);
        *((_QWORD *)this + 2) = CGImageReadCreateWithURL(*((_QWORD *)this + 1), v20, (unsigned __int8 *)1, *((unsigned __int8 *)this + 48), *((unsigned __int8 *)this + 49));
        CFRelease(v20);
      }
      else
      {
        _cg_jpeg_mem_term("IIOImageSource", 470, "CGImageReadCreateWithURL returned nil.\n");
        *((_DWORD *)this + 82) = -3;
      }
    }
    IIOString::~IIOString((IIOString *)__filename);
    CFRelease(v6);
    goto LABEL_26;
  }
  if (!*((_QWORD *)this + 7))
  {
    v22 = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(v7);
    v23 = IIO_ReaderHandler::readerForPathExtension(v22, v8);
    IIOImageSource::setHintReader(this, v23);
  }
  v24 = (IIOImageRead *)IIOCreateDataWithContentsOfURL(a2);
  if (v24)
  {
    *((_QWORD *)this + 2) = CGImageReadCreateWithData(*((_QWORD *)this + 1), v24, (__CFData *)1);
    CFRelease(v24);
  }
  else
  {
    v25 = CFURLCopyScheme(a2);
    v26 = v25;
    if (!v25)
      goto LABEL_37;
    v27 = CFStringCompare(v25, CFSTR("assets-library"), 0);
    if (v27 == kCFCompareEqualTo)
      LogError("IIOImageSource", 499, "*** ERROR: cannot handle this URL ('assets-library' scheme is not supported).\n");
    CFRelease(v26);
    if (v27 == kCFCompareEqualTo)
    {
      v28 = -2;
    }
    else
    {
LABEL_37:
      _cg_jpeg_mem_term("IIOImageSource", 510, "*** ERROR: IIOCreateDataWithContentsOfURL returned nil.\n");
      v28 = -4;
    }
    *((_DWORD *)this + 82) = v28;
  }
LABEL_26:
  if (v8)
    CFRelease(v8);
}

void sub_187E72E2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  uint64_t v30;
  void **v31;
  void **v32;
  void *v34;
  void *v35;

  v34 = *v32;
  if (*v32)
  {
    *(_QWORD *)(v30 + 184) = v34;
    operator delete(v34);
  }
  v35 = *v31;
  if (*v31)
  {
    *(_QWORD *)(v30 + 128) = v35;
    operator delete(v35);
  }
  _Unwind_Resume(exception_object);
}

CFStringRef IIO_CFURLCopyResolvedFileSystemPath(const __CFURL *a1)
{
  const __CFString *v2;
  const __CFString *v3;
  CFComparisonResult v4;
  const __CFURL *v6;
  const __CFURL *v7;
  CFStringRef v8;

  if (!a1)
    return 0;
  v2 = CFURLCopyScheme(a1);
  if (!v2)
    return 0;
  v3 = v2;
  v4 = CFStringCompare(v2, CFSTR("file"), 0);
  CFRelease(v3);
  if (v4)
    return 0;
  v6 = CFURLCopyAbsoluteURL(a1);
  if (!v6)
    return 0;
  v7 = v6;
  v8 = CFURLCopyFileSystemPath(v6, kCFURLPOSIXPathStyle);
  CFRelease(v7);
  return v8;
}

void IIOImageSource::IIOImageSource(IIOImageSource *this, const __CFData *a2, IIODictionary *a3)
{
  *(_QWORD *)this = &off_1E1BAE3E0;
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 17) = 0;
  *((_QWORD *)this + 22) = 0;
  *((_QWORD *)this + 23) = 0;
  *((_QWORD *)this + 24) = 0;
  IIOImageSource::setup((uint64_t)this, 1);
  if (a3)
    IIOImageSource::extractOptions(this, a3);
  *((_QWORD *)this + 2) = CGImageReadCreateWithData(*((_QWORD *)this + 1), a2, (__CFData *)1);
  if ((gIIODebugFlags & 0x10000000) != 0)
    ImageIO_saveImageData("imageData", a2);
}

void sub_187E72FE0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void *v5;
  void *v6;

  v5 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 184) = v5;
    operator delete(v5);
  }
  v6 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 128) = v6;
    operator delete(v6);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CGImageReadRefCreateWith_ImageRead(IIOImageRead *a1)
{
  uint64_t Instance;
  uint64_t v3;
  unint64_t v4;

  if (CGImageReadGetTypeID::once != -1)
    dispatch_once(&CGImageReadGetTypeID::once, &__block_literal_global_74);
  Instance = _CFRuntimeCreateInstance();
  v3 = Instance;
  *(_DWORD *)(Instance + 16) = 1;
  do
    v4 = __ldxr(&gReadRefCount);
  while (__stxr(v4 + 1, &gReadRefCount));
  *(_QWORD *)(Instance + 24) = a1;
  *((_QWORD *)a1 + 1) = Instance;
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageReadRefCreate", (CFTypeRef)Instance, 0, -1, 0);
  return v3;
}

CFMutableArrayRef IIOImageSource::setup(uint64_t a1, int a2)
{
  CFMutableArrayRef result;
  const __CFAllocator *v5;
  const CFArrayCallBacks *v6;

  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 48) = -16711679;
  *(_WORD *)(a1 + 52) = -255;
  *(_BYTE *)(a1 + 54) = a2;
  *(_QWORD *)(a1 + 56) = 0;
  *(_WORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 88) = -5;
  *(_DWORD *)(a1 + 328) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 200), 0);
  result = (CFMutableArrayRef)pthread_mutex_init((pthread_mutex_t *)(a1 + 264), 0);
  *(_QWORD *)(a1 + 336) = a1;
  *(_QWORD *)(a1 + 344) = a1;
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 144) = 0;
  if (a2 != 8)
  {
    v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    *(_QWORD *)(a1 + 160) = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B3B0]);
    v6 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
    *(_QWORD *)(a1 + 144) = CFArrayCreateMutable(v5, 0, MEMORY[0x1E0C9B378]);
    *(_QWORD *)(a1 + 152) = CFArrayCreateMutable(v5, 0, v6);
    result = CFArrayCreateMutable(v5, 0, v6);
    *(_QWORD *)(a1 + 168) = result;
  }
  return result;
}

uint64_t CGImageReadCreateWithData(uint64_t a1, IIOImageRead *this, __CFData *a3)
{
  uint64_t v4;
  IIOImageRead *v5;
  pthread_mutex_t *v6;

  if (!this)
    return 0;
  v4 = IIOImageRead::CreateWithData(this, a3);
  if (!v4)
    return 0;
  v5 = (IIOImageRead *)v4;
  v6 = (pthread_mutex_t *)(v4 + 376);
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 376));
  IIOImageRead::setISR(v5, a1);
  pthread_mutex_unlock(v6);
  return CGImageReadRefCreateWith_ImageRead(v5);
}

uint64_t IIOImageRead::CreateWithData(IIOImageRead *this, const __CFData *a2)
{
  char v2;
  uint64_t v4;

  v2 = (char)a2;
  if (copyInputDataCheck != -1)
    dispatch_once(&copyInputDataCheck, &__block_literal_global_7);
  v4 = operator new();
  IIOImageRead::IIOImageRead(v4, this, 1, v2);
  return v4;
}

void sub_187E732D4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10F1C405FDDC6B3);
  _Unwind_Resume(a1);
}

uint64_t IIOImageRead::IIOImageRead(uint64_t a1, const __CFData *a2, int a3, char a4)
{
  *(_QWORD *)a1 = &off_1E1BAC230;
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 248) = 0;
  *(_QWORD *)(a1 + 240) = a1 + 248;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 256) = 0;
  *(_QWORD *)(a1 + 296) = 0;
  *(_QWORD *)(a1 + 304) = 0;
  *(_QWORD *)(a1 + 288) = 0;
  IIOImageRead::setup(a1, a3);
  *(_BYTE *)(a1 + 64) = a4;
  *(_BYTE *)(a1 + 65) = a4 ^ 1;
  if (gCopyInputData)
  {
    *(_QWORD *)(a1 + 32) = CFDataCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2);
    if ((gIIODebugFlags & 0x80000000000) != 0)
      ImageIOLog("D   %s:%d CFDataCreateCopy %p\n");
  }
  else
  {
    *(_QWORD *)(a1 + 32) = CFRetain(a2);
    if ((gIIODebugFlags & 0x80000000000) != 0)
      ImageIOLog("D   %s:%d CFRetain %p\n");
  }
  *(_QWORD *)(a1 + 80) = CFDataGetLength(a2);
  return a1;
}

void sub_187E7341C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;
  _QWORD **v4;
  void **v5;
  void *v7;
  void *v8;

  v7 = *v5;
  if (*v5)
  {
    *(_QWORD *)(v1 + 296) = v7;
    operator delete(v7);
  }
  std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::destroy(v2, *v4);
  v8 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 160) = v8;
    operator delete(v8);
  }
  _Unwind_Resume(a1);
}

const char *IIOImageRead::setup(uint64_t a1, int a2)
{
  const char *result;

  *(_DWORD *)(a1 + 72) = a2;
  *(_BYTE *)(a1 + 64) = 0;
  *(_BYTE *)(a1 + 71) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = -1;
  *(_QWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 66) = 0;
  *(_DWORD *)(a1 + 440) = 0;
  *(_QWORD *)(a1 + 448) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_QWORD *)(a1 + 272) = 0;
  *(_QWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 264) = 0;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 176), 0);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 88), 0);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 376), 0);
  result = (const char *)pthread_mutex_init((pthread_mutex_t *)(a1 + 312), 0);
  *(_BYTE *)(a1 + 456) = -1;
  if (!gImageBlockCache)
  {
    result = CGImageReadCreateImageBlockCache((cache_s **)&gImageBlockCache);
    if ((gIIODebugFlags & 0x200) != 0)
      result = ImageIOLog("    created global image cache %p\n", (const void *)gImageBlockCache);
  }
  *(_QWORD *)(a1 + 464) = a1;
  *(_QWORD *)(a1 + 472) = a1;
  return result;
}

IIO_Reader *IIO_ReaderHandler::readerForPathExtension(IIO_ReaderHandler *this, CFStringRef theString)
{
  _QWORD *v3;
  _QWORD *v4;
  __int128 v6;
  char v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v6 = xmmword_18822ABA2;
  v7 = 0;
  if (theString && CFStringGetCString(theString, (char *)&v6 + 1, 15, 0x600u))
  {
    if (!strcasecmp((const char *)&v6, ".tif"))
      return IIO_ReaderHandler::readerForUTType(this, CFSTR("public.tiff"));
    v4 = (_QWORD *)*((_QWORD *)this + 2);
    v3 = (_QWORD *)*((_QWORD *)this + 3);
    while (v4 != v3)
    {
      if ((*(unsigned int (**)(_QWORD, __int128 *))(*(_QWORD *)*v4 + 144))(*v4, &v6))
        return (IIO_Reader *)*v4;
      ++v4;
    }
  }
  return 0;
}

const char *IIO_Reader::matchesExtension(IIO_Reader *this, char *a2)
{
  const char *result;

  result = (const char *)*((_QWORD *)this + 2);
  if (result)
    return (const char *)(strcasestr(result, a2) != 0);
  return result;
}

IIOImageRead *IIOImageRead::CreateWithURL(IIOImageRead *this, const __CFURL *a2, __CFString *__s1, unsigned __int8 *a4, int a5, int a6)
{
  char v8;
  char *v11;
  int v12;
  int v13;
  int v14;
  IIOXPCClient *v15;
  IIOImageRead *st_size;
  int v17;
  const __CFData *v18;
  _BOOL4 v19;
  CFStringRef v20;
  int v21;
  int *v22;
  char *v23;
  const char *v24;
  char v25;
  int v26;
  int *v27;
  char *v28;
  BOOL v29;
  IIOImageRead *v30;
  unint64_t v32;
  _BYTE v34[24];
  stat v35;

  v8 = (char)a4;
  v11 = strstr((char *)__s1, "/var/mnt/");
  if (v11)
    v12 = 0;
  else
    v12 = a6;
  if (v11)
    v13 = 0;
  else
    v13 = a5;
  v14 = open((const char *)__s1, 0, 0);
  kdebug_trace();
  if ((gIIODebugFlags & 0x200000000000) != 0)
    ImageIOLog(">>> %s: opening file [%d] '%s'\n", "CreateWithURL", v14, (const char *)__s1);
  memset(&v35, 0, sizeof(v35));
  if (v14 < 0)
  {
    if (this)
    {
      v20 = CFCopyDescription(this);
      v21 = *__error();
      v22 = __error();
      v23 = strerror(*v22);
      IIOString::IIOString((IIOString *)v34, v20);
      v24 = (const char *)IIOString::utf8String((IIOString *)v34);
      LogError("CreateWithURL", 342, "*** ERROR: err=%d (%s) - could not open '%s'\n", v21, v23, v24);
      IIOString::~IIOString((IIOString *)v34);
      CFRelease(v20);
    }
    else
    {
      v26 = *__error();
      v27 = __error();
      v28 = strerror(*v27);
      LogError("CreateWithURL", 346, "*** ERROR: err=%d (%s) - could not open '%s'\n", v26, v28, (const char *)__s1);
    }
    return 0;
  }
  v15 = (IIOXPCClient *)fstat(v14, &v35);
  if ((v15 & 0x80000000) != 0 || (v35.st_mode & 0xF000) != 0x8000)
  {
    st_size = 0;
  }
  else
  {
    st_size = (IIOImageRead *)v35.st_size;
    if (v35.st_size)
    {
      if (v13)
      {
        v15 = _CFDataCreateWithMappedFile(v14, (char *)__s1, &v35, v12);
        if (v15)
          v17 = 5;
        else
          v17 = 0;
        if (v15)
          v18 = v15;
        else
          v18 = 0;
        v19 = v15 != 0;
      }
      else
      {
        v17 = 0;
        v18 = 0;
        v19 = 0;
      }
      if (IIOImageRead::CreateWithURL(__CFURL const*,__CFString const*,unsigned char *,BOOL,BOOL,BOOL)::onceToken != -1)
        dispatch_once(&IIOImageRead::CreateWithURL(__CFURL const*,__CFString const*,unsigned char *,BOOL,BOOL,BOOL)::onceToken, &__block_literal_global_31);
      v32 = (unint64_t)st_size;
      if (IIOImageRead::CreateWithURL(__CFURL const*,__CFString const*,unsigned char *,BOOL,BOOL,BOOL)::useSystemPath)
      {
        if (!strncmp((const char *)__s1, "/System", 7uLL))
        {
          if (HIBYTE(__s1->isa))
            v29 = HIBYTE(__s1->isa) == 47;
          else
            v29 = 1;
          v25 = v29;
        }
        else
        {
          v25 = 0;
        }
      }
      else
      {
        if (!IIOXPCClient::CanCheckTrustedURL(v15)
          || (rootless_trusted_by_self_token(), !rootless_verify_trusted_by_self_token()))
        {
          v25 = 0;
LABEL_43:
          v30 = (IIOImageRead *)operator new();
          st_size = v30;
          if (v18)
          {
            IIOImageRead::IIOImageRead((uint64_t)v30, v18, v17, v19, v25, v8);
            CFRelease(v18);
          }
          else
          {
            IIOImageRead::IIOImageRead(v30, v14, (const char *)__s1, v32, v25, v8);
            v14 = -1;
          }
          IIOImageRead::setURLPath(st_size, a2);
          IIOImageRead::setURL(st_size, this);
          *((_BYTE *)st_size + 68) = v12;
          if (v14 < 0)
            return st_size;
          *((_BYTE *)st_size + 66) = 0;
          goto LABEL_48;
        }
        strncmp((const char *)__s1, "/System", 7uLL);
        v25 = 1;
      }
      kdebug_trace();
      goto LABEL_43;
    }
  }
LABEL_48:
  if ((gIIODebugFlags & 0x200000000000) != 0)
    ImageIOLog("<<< %s: closing file [%d] '%s'\n", "CreateWithURL", v14, (const char *)__s1);
  kdebug_trace();
  close(v14);
  return st_size;
}

void sub_187E73A30(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10F1C405FDDC6B3);
  _Unwind_Resume(a1);
}

CFDataRef _CFDataCreateWithMappedFile(int a1, char *a2, stat *a3, int a4)
{
  void *st_size;
  int v9;
  const UInt8 *v10;
  const UInt8 *v11;
  const __CFAllocator *v12;
  const __CFAllocator *v13;
  CFDataRef v14;
  int v15;
  int *v16;
  char *v17;
  CFAllocatorContext context;

  st_size = (void *)a3->st_size;
  if (!ERROR_ImageIO_FileIsNotReadable(a1, a2))
    return 0;
  if (a4)
    v9 = 16385;
  else
    v9 = 16386;
  v10 = (const UInt8 *)mmap(0, a3->st_size, 1, v9, a1, 0);
  if (v10 == (const UInt8 *)-1)
  {
    v15 = *__error();
    v16 = __error();
    v17 = strerror(*v16);
    LogFault("_CFDataCreateWithMappedFile", 199, "could not mmap '%s':  error: %d (%s)\n", a2, v15, v17);
    return 0;
  }
  v11 = v10;
  kdebug_trace();
  context.version = 0;
  memset(&context.retain, 0, 40);
  context.info = st_size;
  context.deallocate = (CFAllocatorDeallocateCallBack)_mappedDeallocate;
  context.preferredSize = 0;
  v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v13 = CFAllocatorCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], &context);
  v14 = CFDataCreateWithBytesNoCopy(v12, v11, (CFIndex)st_size, v13);
  CFRelease(v13);
  if ((gIIODebugFlags & 0x100000000000) != 0)
  {
    ImageIOLog("   ------------------------------------------------------\n");
    if ((gIIODebugFlags & 0x100000000000) != 0)
    {
      ImageIOLog("    %s:%d   mmap    prt: %p  size: %lld  <CFDataRef:%p>  path: '%s'\n", "_CFDataCreateWithMappedFile", 208, v11, a3->st_size, v14, a2);
      if ((gIIODebugFlags & 0x100000000000) != 0)
        ImageIOLog("   ------------------------------------------------------\n");
    }
  }
  return v14;
}

uint64_t ERROR_ImageIO_FileIsNotReadable(int a1, char *a2)
{
  const char *v2;
  int v3;
  int *v4;
  char *v5;
  char __buf;
  char *v8;
  int v9;
  char v10;

  v9 = a1;
  v8 = a2;
  __buf = 0;
  if (pread(a1, &__buf, 1uLL, 0) < 0)
  {
    v2 = v8;
    v3 = *__error();
    v4 = __error();
    v5 = strerror(*v4);
    LogFault("ERROR_ImageIO_FileIsNotReadable", 132, "*** %s path: '%s' - cannot not read first byte of file - error: %d (%s)\n", "ERROR_ImageIO_FileIsNotReadable", v2, v3, v5);
    v10 = 0;
  }
  else
  {
    v10 = 1;
  }
  return v10 & 1;
}

uint64_t IIOXPCClient::ProcessSupportsOOP(IIOXPCClient *this)
{
  if ((IIO_XPCServer() & 1) != 0)
    return 0;
  if (IIOXPCClient::GetIIOXPCClient(void)::xpcClientCreate != -1)
    dispatch_once(&IIOXPCClient::GetIIOXPCClient(void)::xpcClientCreate, &__block_literal_global_155);
  return IIOXPCClient::processSupportsOOPCheckOnce((IIOXPCClient *)IIOXPCClient::GetIIOXPCClient(void)::gIIOXPCClient);
}

CFTypeRef IIOImageRead::setURL(IIOImageRead *this, CFTypeRef cf)
{
  const void *v4;
  CFTypeRef result;

  v4 = (const void *)*((_QWORD *)this + 6);
  if (v4)
    CFRelease(v4);
  result = CFRetain(cf);
  *((_QWORD *)this + 6) = result;
  return result;
}

CFTypeRef IIOImageRead::setURLPath(IIOImageRead *this, CFTypeRef cf)
{
  const void *v4;
  CFTypeRef result;

  v4 = (const void *)*((_QWORD *)this + 7);
  if (v4)
    CFRelease(v4);
  result = CFRetain(cf);
  *((_QWORD *)this + 7) = result;
  return result;
}

_QWORD *IIOImageSource::setHintReader(_QWORD *this, IIO_Reader *a2)
{
  _QWORD *v2;
  const void *v3;

  this[9] = a2;
  if (a2)
  {
    v2 = this;
    if (!this[7])
    {
      v3 = (const void *)IIO_Reader::utType(a2);
      this = CFRetain(v3);
      v2[7] = this;
    }
  }
  return this;
}

uint64_t CGImageReadCreateWithProvider(uint64_t a1, IIOImageRead *this, CGDataProvider *a3)
{
  IIOImageRead *v4;
  IIOImageRead *v5;
  pthread_mutex_t *v6;

  if (!this)
    return 0;
  v4 = IIOImageRead::CreateWithDataProvider(this, a3);
  if (!v4)
    return 0;
  v5 = v4;
  v6 = (pthread_mutex_t *)((char *)v4 + 376);
  pthread_mutex_lock((pthread_mutex_t *)((char *)v4 + 376));
  IIOImageRead::setISR(v5, a1);
  pthread_mutex_unlock(v6);
  return CGImageReadRefCreateWith_ImageRead(v5);
}

IIOImageRead *IIOImageRead::CreateWithDataProvider(IIOImageRead *this, CGDataProvider *a2)
{
  char v2;
  uint64_t SizeOfData;
  CFIndex v5;
  const __CFData *v6;
  IIOImageRead *v7;
  uint64_t v8;
  const UInt8 *v9;
  const __CFAllocator *v10;
  const __CFAllocator *v11;
  const __CFAllocator *v12;
  CFAllocatorContext context;

  v2 = (char)a2;
  if (copyInputDataCheck == -1)
  {
    if (!this)
      goto LABEL_14;
  }
  else
  {
    dispatch_once(&copyInputDataCheck, &__block_literal_global_83);
    if (!this)
      goto LABEL_14;
  }
  SizeOfData = CGDataProviderGetSizeOfData();
  if (SizeOfData == -1)
    goto LABEL_6;
  v5 = SizeOfData;
  if (!SizeOfData)
  {
LABEL_14:
    v7 = (IIOImageRead *)operator new();
    IIOImageRead::IIOImageRead(v7, this, v2);
    return v7;
  }
  if (!gCopyInputData)
  {
    v8 = CGDataProviderRetainBytePtr();
    if (v8)
    {
      v9 = (const UInt8 *)v8;
      context.version = 0;
      context.info = this;
      context.retain = (CFAllocatorRetainCallBack)_providerRetain;
      context.release = (CFAllocatorReleaseCallBack)_providerRelease;
      memset(&context.copyDescription, 0, 40);
      v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v11 = CFAllocatorCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], &context);
      if (v11)
      {
        v12 = v11;
        v6 = CFDataCreateWithBytesNoCopy(v10, v9, v5, v11);
        CFRelease(v12);
        if (v6)
          goto LABEL_7;
      }
      else
      {
        CGDataProviderReleaseBytePtr();
      }
    }
  }
LABEL_6:
  v6 = CGDataProviderCopyData(this);
  if (!v6)
    goto LABEL_14;
LABEL_7:
  v7 = (IIOImageRead *)operator new();
  IIOImageRead::IIOImageRead((uint64_t)v7, v6, 4, v2);
  CFRelease(v6);
  return v7;
}

void sub_187E73FB4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10F1C405FDDC6B3);
  _Unwind_Resume(a1);
}

const char *CGImageReadCreateImageBlockCache(cache_s **cache_out)
{
  const char *result;

  result = (const char *)cache_create("com.apple.ImageIO.imageblockcache", &ImageIOCacheAttributes, cache_out);
  if ((~(_DWORD)gIIODebugFlags & 0x300) == 0)
    return ImageIOLog("    cache_create 'com.apple.ImageIO.imageblockcache' %p\n", cache_out);
  return result;
}

uint64_t IIOLockDownModeEnabled()
{
  if (IIOLockDownModeEnabled::once != -1)
    dispatch_once(&IIOLockDownModeEnabled::once, &__block_literal_global_15);
  return IIOLockDownModeEnabled::lockDownModeEnabled;
}

__CFArray *IIO_ReaderHandler::copyTypeIdentifiers(IIO_ReaderHandler *this)
{
  __CFArray *Mutable;
  IIO_Reader **v3;
  IIO_Reader **v4;
  const void *v5;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  v4 = (IIO_Reader **)*((_QWORD *)this + 2);
  v3 = (IIO_Reader **)*((_QWORD *)this + 3);
  while (v4 != v3)
  {
    if (IIO_Reader::addToTypeIdentifiers(*v4))
    {
      v5 = (const void *)IIO_Reader::utType(*v4);
      CFArrayAppendValue(Mutable, v5);
    }
    ++v4;
  }
  return Mutable;
}

uint64_t IIO_Reader::utType(IIO_Reader *this)
{
  return **((_QWORD **)this + 1);
}

uint64_t IIO_Reader::addToTypeIdentifiers(IIO_Reader *this)
{
  return *((unsigned __int8 *)this + 48);
}

uint64_t IIOImageSource::cacheImmediately(IIOImageSource *this, unint64_t a2, IIODictionary *a3, CGImage *a4)
{
  uint64_t result;

  result = CGImageGetImageProvider();
  if (result)
  {
    result = IIOReadPluginFromImageProvider();
    if (result)
      return (*(uint64_t (**)(uint64_t, _QWORD, CGImage *))(*(_QWORD *)result + 152))(result, *((_QWORD *)a3 + 1), a4);
  }
  return result;
}

uint64_t IIOReadPluginFromImageProvider()
{
  IIOImagePlus **Info;

  Info = (IIOImagePlus **)CGImageProviderGetInfo();
  return IIOImagePlus::getMetadata(*Info);
}

void IIOReadPlugin::cacheImmediately(IIOReadPlugin *this, const __CFDictionary *a2, CGImageRef image)
{
  size_t Width;
  size_t Height;
  __CFDictionary *Mutable;
  CGColorSpace *ColorSpace;
  CGColorSpaceModel Model;
  double Current;
  const void **v12;
  const void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  void *v17;
  const void *v18;
  const void *v19;
  void *v20;
  __CFDictionary *v21;
  const __CFString *v22;
  double v24;
  double v25;
  int v26;
  unsigned int v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  unsigned int v31;
  int v32;
  uint64_t v33;
  unsigned int v34;
  int v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  _QWORD block[13];
  void *value;

  Width = CGImageGetWidth(image);
  Height = CGImageGetHeight(image);
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  ColorSpace = CGImageGetColorSpace(image);
  Model = CGColorSpaceGetModel(ColorSpace);
  value = 0;
  Current = CFAbsoluteTimeGetCurrent();
  v12 = (const void **)MEMORY[0x1E0C9AE50];
  if (Model == kCGColorSpaceModelRGB)
  {
    v13 = (const void *)*MEMORY[0x1E0C9DAB0];
    if (a2 && CFDictionaryGetValueIfPresent(a2, (const void *)*MEMORY[0x1E0C9DAB0], (const void **)&value))
    {
      CFDictionaryAddValue(Mutable, v13, value);
      goto LABEL_7;
    }
    CFDictionaryAddValue(Mutable, v13, (const void *)*MEMORY[0x1E0C9DAA8]);
  }
  if (!a2)
  {
    v22 = (const __CFString *)*MEMORY[0x1E0C9DAC0];
    v20 = (void *)*v12;
    v21 = Mutable;
    goto LABEL_21;
  }
LABEL_7:
  v14 = (const void *)*MEMORY[0x1E0C9DA90];
  if (CFDictionaryGetValueIfPresent(a2, (const void *)*MEMORY[0x1E0C9DA90], (const void **)&value))
    CFDictionaryAddValue(Mutable, v14, value);
  v15 = (const void *)*MEMORY[0x1E0C9DA98];
  if (CFDictionaryGetValueIfPresent(a2, (const void *)*MEMORY[0x1E0C9DA98], (const void **)&value))
    CFDictionaryAddValue(Mutable, v15, value);
  v16 = (const void *)*MEMORY[0x1E0C9DAC0];
  if (CFDictionaryGetValueIfPresent(a2, (const void *)*MEMORY[0x1E0C9DAC0], (const void **)&value))
    v17 = value;
  else
    v17 = (void *)*v12;
  CFDictionaryAddValue(Mutable, v16, v17);
  v18 = (const void *)*MEMORY[0x1E0C9DAA0];
  if (CFDictionaryGetValueIfPresent(a2, (const void *)*MEMORY[0x1E0C9DAA0], (const void **)&value))
    CFDictionaryAddValue(Mutable, v18, value);
  v19 = (const void *)*MEMORY[0x1E0C9DAB8];
  if (CFDictionaryGetValueIfPresent(a2, (const void *)*MEMORY[0x1E0C9DAB8], (const void **)&value))
    CFDictionaryAddValue(Mutable, v19, value);
  if (CFDictionaryGetValueIfPresent(a2, CFSTR("kCGImageBlockIOSurfaceOptimizedRequest"), (const void **)&value))
  {
    v20 = value;
    v21 = Mutable;
    v22 = CFSTR("kCGImageBlockIOSurfaceOptimizedRequest");
LABEL_21:
    CFDictionaryAddValue(v21, v22, v20);
  }
  CFDictionaryAddValue(Mutable, CFSTR("kCGImageBlockPreHeating"), *v12);
  if ((gIIODebugFlags & 0x300) == 0x100 || (gIIODebugFlags & 0x400000000000) != 0)
    ImageIOLog("::: pre-caching:     rect=(%5g, %5g, %5g, %5g)\n", 0.0, 0.0, (double)Width, (double)Height);
  if (IIOReadPlugin::cacheImmediately(__CFDictionary const*,CGImage *)::onceToken != -1)
    dispatch_once(&IIOReadPlugin::cacheImmediately(__CFDictionary const*,CGImage *)::onceToken, &__block_literal_global_170);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___ZN13IIOReadPlugin16cacheImmediatelyEPK14__CFDictionaryP7CGImage_block_invoke_2;
  block[3] = &__block_descriptor_tmp_172;
  block[4] = this;
  block[5] = image;
  block[6] = 0;
  block[7] = 0;
  *(double *)&block[8] = (double)Width;
  *(double *)&block[9] = (double)Height;
  *(double *)&block[10] = (double)Width;
  *(double *)&block[11] = (double)Height;
  block[12] = Mutable;
  dispatch_sync((dispatch_queue_t)IIOReadPlugin::cacheImmediately(__CFDictionary const*,CGImage *)::cacheQueue, block);
  CFRelease(Mutable);
  v24 = CFAbsoluteTimeGetCurrent();
  if ((gIIODebugFlags & 0xC) != 0)
  {
    v25 = v24;
    v26 = *((_DWORD *)this + 51);
    v27 = v26 >> 24;
    v28 = MEMORY[0x1E0C80978];
    if (v26 < 0)
      v29 = __maskrune(v26 >> 24, 0x40000uLL);
    else
      v29 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v27 + 60) & 0x40000;
    if (v29)
      v30 = v27;
    else
      v30 = 46;
    v31 = v26 << 8 >> 24;
    if (v26 << 8 < 0)
      v32 = __maskrune(v26 << 8 >> 24, 0x40000uLL);
    else
      v32 = *(_DWORD *)(v28 + 4 * v31 + 60) & 0x40000;
    if (v32)
      v33 = v31;
    else
      v33 = 46;
    v34 = (__int16)v26 >> 8;
    if (v26 << 16 < 0)
      v35 = __maskrune((__int16)v26 >> 8, 0x40000uLL);
    else
      v35 = *(_DWORD *)(v28 + 4 * v34 + 60) & 0x40000;
    if (v35)
      v36 = v34;
    else
      v36 = 46;
    if ((v26 << 24) <= 0x7F000000)
      v37 = *(_DWORD *)(v28 + 4 * (char)v26 + 60) & 0x40000;
    else
      v37 = __maskrune((char)v26, 0x40000uLL);
    if (v37)
      v38 = (char)v26;
    else
      v38 = 46;
    ImageIOLog("    '%c%c%c%c' cacheImmediately\ttime: %g ms\n", v30, v33, v36, v38, (v25 - Current) * 1000.0);
  }
}

uint64_t CommonASTCReadPlugin::cacheImmediately(CommonASTCReadPlugin *this, const __CFDictionary *a2, CGImage *a3)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, const __CFDictionary *, CGImage *))(**((_QWORD **)this + 59) + 32))(*((_QWORD *)this + 59), *((_QWORD *)this + 3), a2, a3);
}

uint64_t ASTCTextureImp::cacheImmediately(ASTCTextureImp *this, IIOImageReadSession *a2, const __CFDictionary *a3, CGImage *a4)
{
  pthread_mutex_t *v6;

  v6 = (pthread_mutex_t *)((char *)this + 168);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 168));
  if (!*((_QWORD *)this + 10))
  {
    if (*((_BYTE *)this + 41))
    {
      if (*((_BYTE *)this + 40))
        LogError("cacheImmediately", 751, "*** pre-twiddled LZFSE compressed ASTC is not supported\n");
      else
        ASTCTextureImp::createTwiddledDataFromTwiddled(this, a2);
    }
    else if (*((_BYTE *)this + 40))
    {
      ASTCTextureImp::createTwiddledDataFromLinearLZFSE(this, a2, 0);
    }
    else
    {
      ASTCTextureImp::createTwiddledDataFromLinear((char *)this, a2, 0);
    }
  }
  return pthread_mutex_unlock(v6);
}

void ASTCReadPlugin::addImageTypeIdentifier(ASTCReadPlugin *this, CGImage *a2, const __CFString *a3, int a4)
{
  _BYTE v6[16];

  if (*((_BYTE *)this + 504))
  {
    CGImageSetProperty();
    IIOString::IIOString((IIOString *)v6, 0x4B545820u);
  }
  else
  {
    CGImageSetProperty();
    IIOString::IIOString((IIOString *)v6, *((_DWORD *)this + 51));
  }
  CGImageSetProperty();
  IIOString::~IIOString((IIOString *)v6);
  IIONumber::IIONumber((IIONumber *)v6, a4);
  CGImageSetProperty();
  IIONumber::~IIONumber((IIONumber *)v6);
}

void sub_187E74770(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t _CGImageReadFinalize(_QWORD *a1)
{
  unint64_t v2;
  uint64_t v3;
  const void *v4;
  uint64_t result;
  char __str[16];
  __int128 v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  do
    v2 = __ldxr(&gReadRefCount);
  while (__stxr(v2 - 1, &gReadRefCount));
  if ((gIIODebugFlags & 0xC000) != 0)
  {
    *(_OWORD *)__str = 0u;
    v7 = 0u;
    v3 = a1[3];
    v4 = v3 ? (const void *)~*(_QWORD *)(v3 + 16) : 0;
    snprintf(__str, 0x20uLL, "(%p)", a1);
    if ((unsigned __int16)gIIODebugFlags >> 14)
      ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "_CGImageReadFinalize", v4, __str, -1, 0);
  }
  result = a1[3];
  if (result)
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  a1[2] = 0;
  a1[3] = 0;
  return result;
}

void IIOImageRead::~IIOImageRead(IIOImageRead *this)
{
  IIOImageRead::~IIOImageRead(this);
  JUMPOUT(0x18D761C30);
}

{
  char *v2;
  _QWORD *v3;
  __int128 *v4;
  __int128 *v5;
  int v6;
  __int128 v7;
  __int128 v8;
  char *DebugStringFromKey;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  void *v14;
  const void *v15;
  const void *v16;
  const void *v17;
  const void *v18;
  void *v19;
  void *v20;
  __int128 key;
  _BYTE v22[28];

  *(_QWORD *)this = &off_1E1BAC230;
  v2 = (char *)this + 240;
  v3 = (_QWORD *)((char *)this + 248);
  std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::destroy((uint64_t)this + 240, *((_QWORD **)this + 31));
  *((_QWORD *)this + 30) = v3;
  *((_QWORD *)this + 32) = 0;
  *v3 = 0;
  if ((gIIODebugFlags & 0x200) != 0)
    ImageIOLog(">>> _cache_keys - deleting %d entries\n", -1171354717 * ((uint64_t)(*((_QWORD *)this + 37) - *((_QWORD *)this + 36)) >> 2));
  v5 = (__int128 *)*((_QWORD *)this + 36);
  v4 = (__int128 *)*((_QWORD *)this + 37);
  if (v4 != v5)
  {
    v6 = 0;
    do
    {
      *(_OWORD *)&v22[12] = 0u;
      key = 0u;
      *(_OWORD *)v22 = 0u;
      v7 = *v5;
      v8 = v5[1];
      *(_OWORD *)&v22[12] = *(__int128 *)((char *)v5 + 28);
      key = v7;
      *(_OWORD *)v22 = v8;
      if ((gIIODebugFlags & 0x200) != 0)
      {
        DebugStringFromKey = createDebugStringFromKey((uint64_t)&key);
        v10 = DebugStringFromKey;
        if (DebugStringFromKey)
        {
          ImageIOLog("--- #%d cache_remove             %p key: %s\n", v6++, (const void *)gImageBlockCache, DebugStringFromKey);
          free(v10);
        }
      }
      cache_remove((cache_t *)gImageBlockCache, &key);
      v5 = (__int128 *)((char *)v5 + 44);
    }
    while (v5 != v4);
  }
  if ((gIIODebugFlags & 0x200) != 0)
    cache_print();
  v11 = *((_QWORD *)this + 19);
  v12 = *((_QWORD *)this + 20);
  while (v11 != v12)
  {
    (*(void (**)(_QWORD))(v11 + 8))(*(_QWORD *)v11);
    v11 += 24;
  }
  if (*((_BYTE *)this + 66))
  {
    v13 = *((_DWORD *)this + 6);
    if ((v13 & 0x80000000) == 0)
    {
      if ((gIIODebugFlags & 0x200000000000) != 0)
        ImageIOLog("<<< _CGImageReadFinalize <IIOImageRead: %p>: closing file %d\n", this, v13);
      kdebug_trace();
      close(*((_DWORD *)this + 6));
      *((_BYTE *)this + 66) = 0;
    }
  }
  *((_DWORD *)this + 6) = -1;
  v14 = (void *)*((_QWORD *)this + 33);
  if (v14)
    free(v14);
  v15 = (const void *)*((_QWORD *)this + 5);
  if (v15)
    CFRelease(v15);
  *((_QWORD *)this + 5) = 0;
  v16 = (const void *)*((_QWORD *)this + 4);
  if (v16)
    CFRelease(v16);
  *((_QWORD *)this + 4) = 0;
  v17 = (const void *)*((_QWORD *)this + 6);
  if (v17)
    CFRelease(v17);
  *((_QWORD *)this + 6) = 0;
  v18 = (const void *)*((_QWORD *)this + 7);
  if (v18)
    CFRelease(v18);
  *((_QWORD *)this + 7) = 0;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 176));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 88));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 376));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 312));
  v19 = (void *)*((_QWORD *)this + 36);
  if (v19)
  {
    *((_QWORD *)this + 37) = v19;
    operator delete(v19);
  }
  std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::destroy((uint64_t)v2, *((_QWORD **)this + 31));
  v20 = (void *)*((_QWORD *)this + 19);
  if (v20)
  {
    *((_QWORD *)this + 20) = v20;
    operator delete(v20);
  }
}

void std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::destroy(a1, a2[1]);
    std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::shared_ptr<IIOBaseObject>>,0>((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void GlobalHEIFInfo::~GlobalHEIFInfo(GlobalHEIFInfo *this)
{
  GlobalHEIFInfo::~GlobalHEIFInfo(this);
  JUMPOUT(0x18D761C30);
}

{
  const void *v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unsigned int v6;
  uint64_t v7;
  _BYTE *v8;
  _BYTE *v9;
  unint64_t v10;
  unsigned int v11;
  uint64_t v12;
  void *v13;

  *(_QWORD *)this = &off_1E1BAE118;
  v2 = (const void *)*((_QWORD *)this + 7);
  if (v2)
  {
    CFRelease(v2);
    *((_QWORD *)this + 7) = 0;
  }
  v4 = *((_QWORD *)this + 1);
  v3 = *((_QWORD *)this + 2);
  if (v3 != v4)
  {
    v5 = 0;
    v6 = 1;
    do
    {
      v7 = *(_QWORD *)(v4 + 8 * v5);
      if (v7)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
        v4 = *((_QWORD *)this + 1);
        v3 = *((_QWORD *)this + 2);
      }
      v5 = v6++;
    }
    while (v5 < (v3 - v4) >> 3);
  }
  v8 = (_BYTE *)*((_QWORD *)this + 4);
  v9 = (_BYTE *)*((_QWORD *)this + 5);
  if (v9 == v8)
  {
    v8 = (_BYTE *)*((_QWORD *)this + 5);
    if (v9)
    {
LABEL_14:
      *((_QWORD *)this + 5) = v8;
      operator delete(v8);
    }
  }
  else
  {
    v10 = 0;
    v11 = 1;
    do
    {
      v12 = *(_QWORD *)&v8[8 * v10];
      if (v12)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
        v8 = (_BYTE *)*((_QWORD *)this + 4);
        v9 = (_BYTE *)*((_QWORD *)this + 5);
      }
      v10 = v11++;
    }
    while (v10 < (v9 - v8) >> 3);
    if (v8)
      goto LABEL_14;
  }
  v13 = (void *)*((_QWORD *)this + 1);
  if (v13)
  {
    *((_QWORD *)this + 2) = v13;
    operator delete(v13);
  }
}

void HEIFMainImage::~HEIFMainImage(HEIFMainImage *this)
{
  HEIFMainImage::~HEIFMainImage(this);
  JUMPOUT(0x18D761C30);
}

{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  const void *v14;
  CGColorSpace *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;

  *(_QWORD *)this = &off_1E1BACC68;
  v2 = (_QWORD *)*((_QWORD *)this + 1);
  v3 = (_QWORD *)*((_QWORD *)this + 2);
  if (v2 != v3)
  {
    do
    {
      if (*v2)
        (*(void (**)(_QWORD))(*(_QWORD *)*v2 + 8))(*v2);
      ++v2;
    }
    while (v2 != v3);
    v2 = (_QWORD *)*((_QWORD *)this + 1);
  }
  *((_QWORD *)this + 2) = v2;
  v4 = (_QWORD *)*((_QWORD *)this + 4);
  v5 = (_QWORD *)*((_QWORD *)this + 5);
  if (v4 != v5)
  {
    do
    {
      if (*v4)
        (*(void (**)(_QWORD))(*(_QWORD *)*v4 + 8))(*v4);
      ++v4;
    }
    while (v4 != v5);
    v4 = (_QWORD *)*((_QWORD *)this + 4);
  }
  *((_QWORD *)this + 5) = v4;
  v6 = (_QWORD *)*((_QWORD *)this + 7);
  v7 = (_QWORD *)*((_QWORD *)this + 8);
  if (v6 != v7)
  {
    do
    {
      if (*v6)
        (*(void (**)(_QWORD))(*(_QWORD *)*v6 + 8))(*v6);
      ++v6;
    }
    while (v6 != v7);
    v6 = (_QWORD *)*((_QWORD *)this + 7);
  }
  *((_QWORD *)this + 8) = v6;
  v8 = (_QWORD *)*((_QWORD *)this + 10);
  v9 = (_QWORD *)*((_QWORD *)this + 11);
  if (v8 != v9)
  {
    do
    {
      if (*v8)
        (*(void (**)(_QWORD))(*(_QWORD *)*v8 + 8))(*v8);
      ++v8;
    }
    while (v8 != v9);
    v8 = (_QWORD *)*((_QWORD *)this + 10);
  }
  *((_QWORD *)this + 11) = v8;
  v10 = (_QWORD *)*((_QWORD *)this + 16);
  v11 = (_QWORD *)*((_QWORD *)this + 17);
  if (v10 != v11)
  {
    do
    {
      if (*v10)
        (*(void (**)(_QWORD))(*(_QWORD *)*v10 + 8))(*v10);
      ++v10;
    }
    while (v10 != v11);
    v10 = (_QWORD *)*((_QWORD *)this + 16);
  }
  *((_QWORD *)this + 17) = v10;
  v12 = (_QWORD *)*((_QWORD *)this + 13);
  v13 = (_QWORD *)*((_QWORD *)this + 14);
  if (v12 != v13)
  {
    do
    {
      if (*v12)
        (*(void (**)(_QWORD))(*(_QWORD *)*v12 + 8))(*v12);
      ++v12;
    }
    while (v12 != v13);
    v12 = (_QWORD *)*((_QWORD *)this + 13);
  }
  *((_QWORD *)this + 14) = v12;
  v14 = (const void *)*((_QWORD *)this + 36);
  if (v14)
    CFRelease(v14);
  v15 = (CGColorSpace *)*((_QWORD *)this + 37);
  if (v15)
    CGColorSpaceRelease(v15);
  v16 = (void *)*((_QWORD *)this + 16);
  if (v16)
  {
    *((_QWORD *)this + 17) = v16;
    operator delete(v16);
  }
  v17 = (void *)*((_QWORD *)this + 13);
  if (v17)
  {
    *((_QWORD *)this + 14) = v17;
    operator delete(v17);
  }
  v18 = (void *)*((_QWORD *)this + 10);
  if (v18)
  {
    *((_QWORD *)this + 11) = v18;
    operator delete(v18);
  }
  v19 = (void *)*((_QWORD *)this + 7);
  if (v19)
  {
    *((_QWORD *)this + 8) = v19;
    operator delete(v19);
  }
  v20 = (void *)*((_QWORD *)this + 4);
  if (v20)
  {
    *((_QWORD *)this + 5) = v20;
    operator delete(v20);
  }
  v21 = (void *)*((_QWORD *)this + 1);
  if (v21)
  {
    *((_QWORD *)this + 2) = v21;
    operator delete(v21);
  }
}

uint64_t globalHEIFInfoReleaseProc(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void HEIFExif::~HEIFExif (HEIFExif *this)
{
  *(_QWORD *)this = &off_1E1BB2B00;
  JUMPOUT(0x18D761C30);
}

{
  *(_QWORD *)this = &off_1E1BB2B00;
}

void HEIFAuxImage::~HEIFAuxImage(HEIFAuxImage *this)
{
  HEIFAuxImage::~HEIFAuxImage(this);
  JUMPOUT(0x18D761C30);
}

{
  const void *v2;

  *(_QWORD *)this = &off_1E1BAC1F0;
  v2 = (const void *)*((_QWORD *)this + 7);
  if (v2)
    CFRelease(v2);
  *((_QWORD *)this + 7) = 0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 8) = 0u;
}

void GlobalTIFFInfo::~GlobalTIFFInfo(GlobalTIFFInfo *this)
{
  GlobalTIFFInfo::~GlobalTIFFInfo(this);
  JUMPOUT(0x18D761C30);
}

{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_1E1BAE138;
  v2 = (void *)*((_QWORD *)this + 5);
  if (v2)
  {
    *((_QWORD *)this + 6) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 2);
  if (v3)
  {
    *((_QWORD *)this + 3) = v3;
    operator delete(v3);
  }
}

uint64_t ReleaseTIFFGlobalInfo(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void GlobalGIFInfo::~GlobalGIFInfo(GlobalGIFInfo *this)
{
  GlobalGIFInfo::~GlobalGIFInfo(this);
  JUMPOUT(0x18D761C30);
}

{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = &off_1E1BACBE8;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 8));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 72));
  v2 = *((_QWORD *)this + 22);
  *((_QWORD *)this + 22) = 0;
  if (v2)
    std::default_delete<IIOColorMap>::operator()[abi:ne180100]((uint64_t)this + 176, v2);
  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100]((uint64_t)this + 160);
  v3 = (void *)*((_QWORD *)this + 17);
  if (v3)
  {
    *((_QWORD *)this + 18) = v3;
    operator delete(v3);
  }
}

uint64_t globalGIFInfoReleaseProc(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void GlobalPNGInfo::~GlobalPNGInfo(GlobalPNGInfo *this)
{
  GlobalPNGInfo::~GlobalPNGInfo(this);
  JUMPOUT(0x18D761C30);
}

{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_1E1BACC28;
  v2 = (void *)*((_QWORD *)this + 8);
  if (v2 && *((_BYTE *)this + 72))
    free(v2);
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 80));
  v3 = (void *)*((_QWORD *)this + 1);
  if (v3)
  {
    *((_QWORD *)this + 2) = v3;
    operator delete(v3);
  }
}

uint64_t globalPNGInfoReleaseProc(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

BOOL StartNamespaceDeclHandler(_BOOL8 result, char *a2, char *__s1)
{
  char *v3;
  uint64_t v5;
  unsigned int *v6;
  char *v7;
  XMP_NamespaceTable *v8;

  if (a2)
    v3 = a2;
  else
    v3 = "_dflt_";
  if (__s1)
  {
    v5 = result;
    if (!strcmp(__s1, "http://purl.org/dc/1.1/"))
      v7 = "http://purl.org/dc/elements/1.1/";
    else
      v7 = __s1;
    v8 = *(XMP_NamespaceTable **)(v5 + 256);
    if (v8 == (XMP_NamespaceTable *)sRegisteredNamespaces)
      return XMPMeta::RegisterNamespace((XMPMeta *)v7, v3, 0, 0, v6);
    else
      return XMP_NamespaceTable::Define(v8, v7, v3, 0, 0);
  }
  return result;
}

uint64_t ASTCReadPlugin::initialize(ASTCReadPlugin *this, IIODictionary *a2)
{
  const void *v3;
  ASTCTextureImp *v4;
  unint64_t v5;
  unsigned int v6;
  IIODictionary *v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  unsigned __int8 *v13;
  unsigned int v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  unsigned int v18;
  unint64_t v19;
  unint64_t v20;
  unsigned int Uint32ForKey;
  double v22;
  int v23;
  int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  __int32 v34;
  unint64_t v35;
  unint64_t v36;
  unsigned int v37;
  BOOL v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char isInputLZFSECompressed;
  unint64_t v44;
  char v45;
  unsigned int v46;
  __int16 v47;
  unint64_t v48;
  unint64_t v49;
  uint64_t v50;
  int v51;
  int v52;
  unsigned __int8 *v53;
  unsigned int v54;
  unsigned int v55;
  unint64_t v56;
  unint64_t v57;
  int v58;
  uint64_t v59;
  unint64_t v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unsigned int v65;
  uint64_t v66;
  int v67;
  unsigned int v68;
  unsigned int v69;
  int v70;
  char v71;
  unint64_t v72;
  IIOImageReadSession *v73;
  unint64_t Properties;
  uint64_t v75;
  unsigned int v76;
  int v77;
  uint64_t v78;
  unsigned int v79;
  int v80;
  uint64_t v81;
  unsigned int v82;
  int v83;
  uint64_t v84;
  int v85;
  unsigned int v86;
  int v87;
  uint64_t v88;
  unsigned int v89;
  int v90;
  uint64_t v91;
  unsigned int v92;
  int v93;
  unsigned int v94;
  int v95;
  uint64_t v96;
  uint64_t v97;
  unsigned int v98;
  char *v99;
  __int16 v100;
  char v101[7];
  unsigned __int8 v102;
  _BYTE v103[24];
  _BYTE v104[24];
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  uint64_t v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  int8x16_t __dst;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  uint64_t v119;

  v119 = *MEMORY[0x1E0C80C00];
  v3 = (const void *)*((_QWORD *)this + 59);
  if (v3)
  else
    v4 = 0;
  v109 = 0;
  v107 = 0u;
  v108 = 0u;
  v105 = 0u;
  v106 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v105, *((IIOImageReadSession **)this + 3));
  if (!*((_BYTE *)this + 341))
    goto LABEL_128;
  v5 = v106;
  if (IIOScanner::getBytesAtOffset((IIOScanner *)&v105, (char *)this + 488, *((_QWORD *)this + 24), 0x10uLL) != 16)
    goto LABEL_128;
  if (*((_DWORD *)this + 122) == 1554098963)
  {
    *((_WORD *)this + 252) = 0;
    v9 = *((unsigned __int8 *)this + 492);
    v10 = *((unsigned __int8 *)this + 493) | (v9 << 8);
    if (v10 > 2055)
    {
      if (v10 <= 3081)
      {
        switch(v10)
        {
          case 2565:
            v11 = 213;
            goto LABEL_63;
          case 2566:
            v11 = 214;
            goto LABEL_63;
          case 2567:
          case 2569:
            goto LABEL_57;
          case 2568:
            v11 = 215;
            goto LABEL_63;
          case 2570:
            v11 = 216;
            goto LABEL_63;
          default:
            if (v10 != 2056)
              goto LABEL_57;
            v11 = 212;
            break;
        }
        goto LABEL_63;
      }
      if (v10 == 3082)
      {
        v11 = 217;
        goto LABEL_63;
      }
      if (v10 == 3084)
      {
        v11 = 218;
        goto LABEL_63;
      }
    }
    else if (v10 <= 1540)
    {
      switch(v10)
      {
        case 1028:
          v11 = 204;
          goto LABEL_63;
        case 1284:
          v11 = 205;
          goto LABEL_63;
        case 1285:
          v11 = 206;
          goto LABEL_63;
      }
    }
    else if (v10 > 2052)
    {
      if (v10 == 2053)
      {
        v11 = 210;
        goto LABEL_63;
      }
      if (v10 == 2054)
      {
        v11 = 211;
        goto LABEL_63;
      }
    }
    else
    {
      if (v10 == 1541)
      {
        v11 = 207;
        goto LABEL_63;
      }
      if (v10 == 1542)
      {
        v11 = 208;
LABEL_63:
        *((_DWORD *)this + 112) = v11;
        *((_QWORD *)this + 24) = 16;
        ASTCTextureImp::setTextureBaseOffset((uint64_t)v4, 16);
        v23 = *(unsigned __int16 *)((char *)this + 495) | (*((unsigned __int8 *)this + 497) << 16);
        *((_DWORD *)this + 109) = v23;
        v24 = *((unsigned __int16 *)this + 249) | (*((unsigned __int8 *)this + 500) << 16);
        *((_DWORD *)this + 110) = v24;
        *((_DWORD *)this + 111) = *(unsigned __int16 *)((char *)this + 501) | (*((unsigned __int8 *)this + 503) << 16);
        v25 = *((unsigned __int8 *)this + 492);
        v26 = (v23 + v25 - 1) / v25;
        *((_DWORD *)this + 113) = v26;
        v27 = *((unsigned __int8 *)this + 493);
        v28 = (v24 + v27 - 1) / v27;
        *((_DWORD *)this + 114) = v28;
        v29 = 16 * v26 * v28;
        if (*((_QWORD *)this + 23) >= (unint64_t)(*((_QWORD *)this + 24) + v29))
        {
          v30 = *((_QWORD *)this + 7);
          IIONumber::IIONumber((IIONumber *)v104, 4);
          IIODictionary::setObjectForKey(v30, (uint64_t)v104, CFSTR("Orientation"));
          IIONumber::~IIONumber((IIONumber *)v104);
          goto LABEL_66;
        }
        _cg_jpeg_mem_term("initialize", 364, "*** bad ASTC %dx%d data [%d x %d] vs. %ld bytes - expected %ld bytes\n", v25, v27, v23, v24, *((_QWORD *)this + 23), v29);
LABEL_128:
        kdebug_trace();
        v63 = 4294967246;
        goto LABEL_129;
      }
    }
LABEL_57:
    LogError("initialize", 343, "*** can't handle ASTC image with block dimension (%d/%d/%d)\n", v9, *((unsigned __int8 *)this + 493), *((unsigned __int8 *)this + 494));
    goto LABEL_128;
  }
  v117 = 0u;
  v118 = 0u;
  __dst = 0u;
  v116 = 0u;
  if (IIOScanner::getBytesAtOffset((IIOScanner *)&v105, &__dst, *((_QWORD *)this + 24), 0x40uLL) != 64)
    goto LABEL_128;
  if (!IsKTXHeader(&__dst))
  {
    v113 = 0u;
    v114 = 0u;
    v111 = 0u;
    v112 = 0u;
    v110 = 0u;
    if (IIOScanner::getBytesAtOffset((IIOScanner *)&v105, &v110, *((_QWORD *)this + 24), 0x50uLL) != 80
      || !IsKTX2Header(&v110))
    {
      goto LABEL_128;
    }
    if ((unint64_t)v106 <= v112)
    {
      _cg_jpeg_mem_term("initialize", 491, "*** ERROR: Invalid numberOfArrayElements (%d).");
      goto LABEL_128;
    }
    if ((unint64_t)v106 <= v113)
    {
      _cg_jpeg_mem_term("initialize", 492, "*** ERROR: Invalid dfdOffset (%d).");
      goto LABEL_128;
    }
    if ((unint64_t)v106 <= DWORD1(v113))
    {
      _cg_jpeg_mem_term("initialize", 493, "*** ERROR: Invalid dfdLength (%d).");
      goto LABEL_128;
    }
    if ((unint64_t)v106 <= DWORD2(v113))
    {
      _cg_jpeg_mem_term("initialize", 494, "*** ERROR: Invalid kvdOffset (%d).");
      goto LABEL_128;
    }
    if ((unint64_t)v106 <= HIDWORD(v113))
    {
      _cg_jpeg_mem_term("initialize", 495, "*** ERROR: Invalid kvdLength (%d).");
      goto LABEL_128;
    }
    if ((unint64_t)v114 >= (unint64_t)v106)
    {
      _cg_jpeg_mem_term("initialize", 496, "*** ERROR: Invalid scgdOffset (%d).");
      goto LABEL_128;
    }
    if (*((_QWORD *)&v114 + 1) >= (unint64_t)v106)
    {
      _cg_jpeg_mem_term("initialize", 497, "*** ERROR: Invalid scgdLength (%d).");
      goto LABEL_128;
    }
    *((_WORD *)this + 252) = 256;
    if (v5 <= DWORD1(v111) || v5 <= DWORD2(v111) || DWORD2(v112) > 0x10)
      goto LABEL_128;
    v12 = ASTCTextureImp::MetalFormatForVulkanFormat((ASTCTextureImp *)HIDWORD(v110));
    *((_DWORD *)this + 112) = v12;
    if ((v12 - 222) <= 0xE)
    {
      ASTCTextureImp::set_needs_hdr((uint64_t)v4, 1);
      v12 = *((unsigned int *)this + 112);
    }
    *((_BYTE *)this + 344) = 0;
    v15 = DWORD1(v111);
    v14 = DWORD2(v111);
    *((_DWORD *)this + 109) = DWORD1(v111);
    *((_DWORD *)this + 110) = v14;
    *((_DWORD *)this + 111) = 1;
    v16 = *((_DWORD *)this + 52);
    v101[0] = 0;
    v102 = 0;
    ASTCTextureImp::GetXYdimFromMetalFormat(v12, v101, &v102, v13);
    v17 = v101[0];
    if (!v101[0])
      goto LABEL_128;
    *((_BYTE *)this + 492) = v101[0];
    v18 = v102;
    *((_BYTE *)this + 493) = v102;
    *((_BYTE *)this + 494) = 1;
    *(_WORD *)((char *)this + 495) = v15 >> v16;
    *((_BYTE *)this + 497) = v15 >> v16 >> 16;
    *((_WORD *)this + 249) = v14 >> v16;
    *((_BYTE *)this + 500) = v14 >> v16 >> 16;
    *(_WORD *)((char *)this + 501) = 1;
    *((_BYTE *)this + 503) = 0;
    v19 = (v17 + *((_DWORD *)this + 109) - 1) / v17;
    *((_DWORD *)this + 113) = v19;
    v20 = (v18 + *((_DWORD *)this + 110) - 1) / v18;
    *((_DWORD *)this + 114) = v20;
    if (v5 < v19 || v5 < v20)
      goto LABEL_128;
    goto LABEL_66;
  }
  *((_WORD *)this + 252) = 1;
  SwapKTXHeader(&__dst);
  *((_WORD *)this + 159) = 0;
  v6 = IIODictionary::containsKey(*((IIODictionary **)this + 6), CFSTR("kCGImageSourceMipmapLevel"));
  v7 = (IIODictionary *)*((_QWORD *)this + 6);
  if (v6)
  {
    LOWORD(v8) = (unsigned __int16)IIODictionary::getUint32ForKey(v7, CFSTR("kCGImageSourceMipmapLevel"));
  }
  else
  {
    if ((IIODictionary::containsKey(v7, CFSTR("kCGImageSourceSubsampleFactor")) & 1) == 0)
    {
      LOWORD(v8) = *((_WORD *)this + 159);
      goto LABEL_107;
    }
    Uint32ForKey = IIODictionary::getUint32ForKey(*((IIODictionary **)this + 6), CFSTR("kCGImageSourceSubsampleFactor"));
    if (Uint32ForKey)
      v22 = log2((double)Uint32ForKey);
    else
      v22 = 0.0;
    v8 = (int)v22;
  }
  *((_WORD *)this + 159) = v8;
LABEL_107:
  v46 = DWORD2(v118);
  if (DWORD2(v118) <= (unsigned __int16)v8)
  {
    v47 = WORD4(v118) - 1;
    if (!DWORD2(v118))
      v47 = 0;
    *((_WORD *)this + 159) = v47;
  }
  else
  {
    LOBYTE(v47) = v8;
  }
  v48 = (DWORD1(v117) >> v47);
  v49 = (DWORD2(v117) >> v47);
  *((_DWORD *)this + 57) = v48;
  *((_DWORD *)this + 58) = v49;
  if (v46 > 0x10 || v5 <= v48 || v5 <= v49)
    goto LABEL_128;
  if (DWORD1(v118) != 1 && DWORD1(v118) != 6)
  {
    _cg_jpeg_mem_term("initialize", 408, "*** Error: invalid numberOfFaces (%ld)", DWORD1(v118));
    goto LABEL_128;
  }
  if (HIDWORD(v117) > 0x1F)
    goto LABEL_128;
  v50 = ASTCTextureImp::MetalFormatForGLFormat((ASTCTextureImp *)HIDWORD(v116));
  *((_DWORD *)this + 112) = v50;
  *((_BYTE *)this + 344) = __dst.i32[3] == 67305985;
  v52 = *((_DWORD *)this + 57);
  v51 = *((_DWORD *)this + 58);
  *((_DWORD *)this + 109) = v52;
  *((_DWORD *)this + 110) = v51;
  *((_DWORD *)this + 111) = 1;
  LOBYTE(v110) = 0;
  v101[0] = 0;
  ASTCTextureImp::GetXYdimFromMetalFormat(v50, &v110, (unsigned __int8 *)v101, v53);
  v54 = v110;
  if (!(_BYTE)v110)
    goto LABEL_128;
  *((_BYTE *)this + 492) = v110;
  v55 = v101[0];
  *((_BYTE *)this + 493) = v101[0];
  *((_BYTE *)this + 494) = 1;
  *(_WORD *)((char *)this + 495) = v52;
  *((_BYTE *)this + 497) = BYTE2(v52);
  *((_WORD *)this + 249) = v51;
  *((_BYTE *)this + 500) = BYTE2(v51);
  *(_WORD *)((char *)this + 501) = 1;
  *((_BYTE *)this + 503) = 0;
  v56 = (v54 + *((_DWORD *)this + 109) - 1) / v54;
  *((_DWORD *)this + 113) = v56;
  v57 = (v55 + *((_DWORD *)this + 110) - 1) / v55;
  *((_DWORD *)this + 114) = v57;
  if (v5 < v56 || v5 < v57 || !ASTCReadPlugin::extractMetadata((uint64_t)this, (uint64_t)&__dst))
    goto LABEL_128;
  v58 = *((unsigned __int8 *)this + 509);
  if (v58 != 255)
  {
    v59 = *((_QWORD *)this + 7);
    IIONumber::IIONumber((IIONumber *)v103, v58);
    IIODictionary::setObjectForKey(v59, (uint64_t)v103, CFSTR("Orientation"));
    IIONumber::~IIONumber((IIONumber *)v103);
  }
  v60 = HIDWORD(v118) + 64;
  *((_QWORD *)this + 24) = v60;
  v61 = ASTCReadPlugin::calculateKTXOffsetToRequestedImage((uint64_t)this, (uint64_t)&__dst, v60);
  *((_QWORD *)this + 24) = v61;
  ASTCTextureImp::setTextureBaseOffset((uint64_t)v4, v61);
  if (!*((_BYTE *)this + 508))
  {
    v62 = (16 * *((_DWORD *)this + 113) * *((_DWORD *)this + 114));
    if (*((_QWORD *)this + 23) < (unint64_t)(*((_QWORD *)this + 24) + v62))
    {
      _cg_jpeg_mem_term("initialize", 475, "*** bad KTX/ASTC %dx%d data [%d x %d] vs. %ld bytes - expected %ld bytes\n", *((unsigned __int8 *)this + 492), *((unsigned __int8 *)this + 493), *((_DWORD *)this + 109), *((_DWORD *)this + 110), *((_QWORD *)this + 23), v62);
      goto LABEL_128;
    }
  }
LABEL_66:
  ASTCTextureImp::setTextureDimension((uint64_t)v4, *((_DWORD *)this + 109), *((_DWORD *)this + 110));
  ASTCTextureImp::setMetalFormat((uint64_t)v4, *((_DWORD *)this + 112));
  ASTCTextureImp::setDim(v4, *((unsigned __int8 *)this + 492), *((unsigned __int8 *)this + 493));
  ASTCTextureImp::setBlocks((uint64_t)v4, *((_DWORD *)this + 113), *((_DWORD *)this + 114));
  if (*((_BYTE *)this + 504))
  {
    IIOScanner::seek((IIOScanner *)&v105, *((_QWORD *)this + 24));
    if (IIOScanner::getVal32((IIOScanner *)&v105) == 1397119564)
    {
      v31 = *((_QWORD *)this + 24);
    }
    else
    {
      IIOScanner::getVal32((IIOScanner *)&v105);
      v31 = *((_QWORD *)this + 24) + 4;
    }
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      ImageIOLog("    KTX with LZFSE compressed ASTC data\n");
      if ((gIIODebugFlags & 0x30000) != 0)
      {
        ImageIOLog("                    lzfseOffset: %d\n", v31);
        if ((gIIODebugFlags & 0x30000) != 0)
          ImageIOLog("                        _rpd._offset: %d\n", *((_QWORD *)this + 24));
      }
    }
  }
  else
  {
    v31 = 16;
  }
  if (!*((_BYTE *)this + 505))
  {
    IIOScanner::seek((IIOScanner *)&v105, v31);
    if (IIOScanner::getVal32((IIOScanner *)&v105) == 1397119564)
    {
      ASTCTextureImp::setInputIsLZFSECompressed((uint64_t)v4, 1);
      LODWORD(v110) = 0;
      v32 = v31 + 4;
      IIOScanner::getBytesAtOffset((IIOScanner *)&v105, &v110, v31 + 4, 4uLL);
      ASTCTextureImp::setCompressedLZFSESize((uint64_t)v4, v110);
      v33 = v31 + 8;
      ASTCTextureImp::setCompressedLZFSEDataOffset((uint64_t)v4, v33);
      if ((gIIODebugFlags & 0x30000) != 0)
      {
        ImageIOLog("                      lzfseSize: %d\n", (_DWORD)v110);
        if ((gIIODebugFlags & 0x30000) != 0)
          ImageIOLog("                lzfseDataOffset: %d\n", v33);
      }
      if (v110 >= 9)
      {
        __dst.i32[0] = 0;
        *(_DWORD *)v101 = 0;
        IIOScanner::getBytesAtOffset((IIOScanner *)&v105, &__dst, v33, 4uLL);
        IIOScanner::getBytesAtOffset((IIOScanner *)&v105, v101, v32 + v110, 4uLL);
        v34 = __dst.i32[0];
        if (__dst.i32[0] != 846755426 || *(_DWORD *)v101 != 611874402)
        {
          v65 = __dst.i32[0] >> 24;
          v66 = MEMORY[0x1E0C80978];
          if (__dst.i32[0] < 0)
          {
            v67 = __maskrune(v65, 0x40000uLL);
            v34 = __dst.i32[0];
            v65 = __dst.i32[0] >> 24;
          }
          else
          {
            v67 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v65 + 60) & 0x40000;
          }
          if (v67)
            v75 = v65;
          else
            v75 = 46;
          v76 = v34 << 8 >> 24;
          if (v34 << 8 < 0)
          {
            v77 = __maskrune(v76, 0x40000uLL);
            v34 = __dst.i32[0];
            v76 = __dst.i32[0] << 8 >> 24;
          }
          else
          {
            v77 = *(_DWORD *)(v66 + 4 * v76 + 60) & 0x40000;
          }
          if (v77)
            v78 = v76;
          else
            v78 = 46;
          v79 = (__int16)v34 >> 8;
          if (v34 << 16 < 0)
          {
            v80 = __maskrune(v79, 0x40000uLL);
            v34 = __dst.i32[0];
            v79 = __dst.i16[0] >> 8;
          }
          else
          {
            v80 = *(_DWORD *)(v66 + 4 * v79 + 60) & 0x40000;
          }
          if (v80)
            v81 = v79;
          else
            v81 = 46;
          v82 = (char)v34;
          if ((v34 << 24) <= 0x7F000000)
          {
            v83 = *(_DWORD *)(v66 + 4 * (char)v34 + 60) & 0x40000;
          }
          else
          {
            v83 = __maskrune((char)v34, 0x40000uLL);
            v82 = __dst.i8[0];
          }
          if (v83)
            v84 = v82;
          else
            v84 = 46;
          v85 = *(_DWORD *)v101;
          v86 = v101[3];
          if ((*(_DWORD *)v101 & 0x80000000) != 0)
          {
            v87 = __maskrune(v101[3], 0x40000uLL);
            v85 = *(_DWORD *)v101;
            v86 = v101[3];
          }
          else
          {
            v87 = *(_DWORD *)(v66 + 4 * v101[3] + 60) & 0x40000;
          }
          if (v87)
            v88 = v86;
          else
            v88 = 46;
          v89 = v85 << 8 >> 24;
          if (v85 << 8 < 0)
          {
            v90 = __maskrune(v89, 0x40000uLL);
            v85 = *(_DWORD *)v101;
            v89 = v101[2];
          }
          else
          {
            v90 = *(_DWORD *)(v66 + 4 * v89 + 60) & 0x40000;
          }
          if (v90)
            v91 = v89;
          else
            v91 = 46;
          v92 = (__int16)v85 >> 8;
          if (v85 << 16 < 0)
          {
            v93 = __maskrune(v92, 0x40000uLL);
            v85 = *(_DWORD *)v101;
          }
          else
          {
            v93 = *(_DWORD *)(v66 + 4 * v92 + 60) & 0x40000;
          }
          v94 = (char)v85;
          if ((v85 << 24) <= 0x7F000000)
          {
            v95 = *(_DWORD *)(v66 + 4 * (char)v85 + 60) & 0x40000;
          }
          else
          {
            v95 = __maskrune((char)v85, 0x40000uLL);
            v94 = v101[0];
          }
          LODWORD(v96) = (__int16)v85 >> 8;
          if (v93)
            v96 = v96;
          else
            v96 = 46;
          if (v95)
            v97 = v94;
          else
            v97 = 46;
          _cg_jpeg_mem_term("initialize", 624, "    ERROR: bad LZFSE data (does not start/end with 'bvx2'/'bvx$'  [%c%c%c%c][%c%c%c%c])\n", v75, v78, v81, v84, v88, v91, v96, v97);
          goto LABEL_128;
        }
      }
    }
  }
  v35 = *((unsigned __int8 *)this + 492);
  v36 = *((unsigned __int8 *)this + 493);
  v37 = *((unsigned __int8 *)this + 494);
  if ((v35 - 13) < 0xFFFFFFF6
    || v36 < 3
    || v36 > 0xC
    || (v37 < 3 ? (v38 = v37 == 1) : (v38 = 1), v38 ? (v39 = 0) : (v39 = 1), v37 > 0xC || v39))
  {
    _cg_jpeg_mem_term("initialize", 641, "xyz-dim not supported:  xdim:%d  ydim:%d  zdim:%d\n", v35, *((unsigned __int8 *)this + 493), v37);
    goto LABEL_128;
  }
  v40 = v106 - *((_QWORD *)this + 24);
  if (v40 < 0)
  {
    _cg_jpeg_mem_term("initialize", 649, "bad file _offset: %ld  fileSize: %ld\n", *((_QWORD *)this + 24), (_QWORD)v106);
    goto LABEL_128;
  }
  v41 = *((unsigned int *)this + 109);
  v42 = *((unsigned int *)this + 110);
  isInputLZFSECompressed = ASTCTextureImp::isInputLZFSECompressed(v4);
  v44 = 16 * (v35 + v41 - 1) / v35 * ((v36 + v42 - 1) / v36);
  if (v44 <= v40)
    v45 = 1;
  else
    v45 = isInputLZFSECompressed;
  if ((v45 & 1) == 0)
  {
    _cg_jpeg_mem_term("initialize", 662, "bad file size:  xdim:%d  ydim:%d  zdim:%d  size:%dx%d  dataSize:%d  expected:%d\n", v35, v36, v37, *((_DWORD *)this + 109), *((_DWORD *)this + 110), v40, v44);
    goto LABEL_128;
  }
  if ((*(unsigned __int16 *)((char *)this + 501) | (*((unsigned __int8 *)this + 503) << 16)) >= 2u)
  {
    _cg_jpeg_mem_term("initialize", 675, "zsize '%d' not supported\n", *(unsigned __int16 *)((char *)this + 501) | (*((unsigned __int8 *)this + 503) << 16));
    goto LABEL_128;
  }
  v68 = *(unsigned __int16 *)((char *)this + 495) | (*((unsigned __int8 *)this + 497) << 16);
  v69 = *((unsigned __int16 *)this + 249) | (*((unsigned __int8 *)this + 500) << 16);
  if (v68 && ((v68 * (unint64_t)v69) & 0xFFFFFFFF00000000) != 0)
  {
    _cg_jpeg_mem_term("initialize", 681, "overflow: xsize: %d    ysize: %d\n", *(unsigned __int16 *)((char *)this + 495) | (*((unsigned __int8 *)this + 497) << 16), v69);
    goto LABEL_128;
  }
  *((_DWORD *)this + 57) = v68;
  *((_DWORD *)this + 58) = v69;
  *((_DWORD *)this + 60) = 2097160;
  *((_WORD *)this + 122) = 4;
  *((_DWORD *)this + 81) = 1380401696;
  v70 = *((unsigned __int8 *)this + 507);
  if (v70 == 255)
    v71 = 3;
  else
    v71 = v70 & 0x1F;
  *((_BYTE *)this + 246) = v71;
  *((_QWORD *)this + 20) = 0;
  v72 = *((char *)this + 506);
  if (v72 <= 4)
    *((_QWORD *)this + 20) = CGColorSpaceCreateWithName(**((CFStringRef **)&unk_1E1BCA610 + v72));
  *((_DWORD *)this + 59) = 4 * v68;
  *((_BYTE *)this + 346) = 0;
  if (*((_QWORD *)this + 3))
  {
    if ((ASTCTextureImp::isInputLZFSECompressed(v4) & 1) == 0
      && (ASTCTextureImp::isInputPreTwiddled(v4) & 1) == 0
      && *((unsigned __int8 *)this + 507) == 255
      && *((unsigned __int8 *)this + 506) == 255
      && !*((_BYTE *)this + 505))
    {
      v110 = 0uLL;
      v73 = (IIOImageReadSession *)*((_QWORD *)this + 3);
      Properties = IIOImagePlus::getProperties(v4);
      if (IIOImageReadSession::getBytesAtOffset(v73, &v110, Properties, 0x10uLL) == 16)
      {
        if ((v110 & 0x1FF) == 0x1FC)
        {
          ASTCTextureImp::set_needs_hdr((uint64_t)v4, (v110 & 0x200) != 0);
        }
        else
        {
          v98 = (v110 >> 13) & 0xF;
          if ((v110 & 0x1800) != 0)
            v98 = (v110 >> 23) & 0x3F;
          if ((v98 & 0x3E) == 0xE || v98 == 11 || v98 == 7 || (v98 & 0x3E) == 2)
            ASTCTextureImp::set_needs_hdr((uint64_t)v4, 1);
        }
      }
    }
  }
  if (ASTCTextureImp::needs_hdr(v4))
  {
    *((_BYTE *)this + 345) = 1;
    *((_DWORD *)this + 59) = 8 * v68;
    *((_DWORD *)this + 60) = 4194320;
    *((_BYTE *)this + 247) = 1;
    if (!*((_QWORD *)this + 20))
      *((_QWORD *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D958]);
  }
  v99 = getenv("IIO_useV3");
  if (v99 && !atoi(v99))
    v100 = 1;
  else
    v100 = 13;
  v63 = 0;
  *((_WORD *)this + 188) = v100;
LABEL_129:
  IIOScanner::~IIOScanner((IIOScanner *)&v105);
  return v63;
}

void sub_187E76150(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_list va;

  va_start(va, a17);
  IIOScanner::~IIOScanner((IIOScanner *)va);
  _Unwind_Resume(a1);
}

uint64_t ATXReadPlugin::initialize(ATXReadPlugin *this, IIODictionary *a2)
{
  const void *v3;
  ASTCTextureImp *v4;
  unsigned __int8 *v5;
  char v6;
  uint64_t v7;
  ASTCTextureImp *v8;
  unint64_t v9;
  unint64_t v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unint64_t v19;
  int v20;
  char v21;
  int v22;
  int v23;
  int v24;
  int v25;
  unsigned int v26;
  uint64_t v27;
  unsigned int v28;
  ASTCTwiddler *v29;
  __n128 v31;
  int v32;
  int v34;
  int v35;
  int v36;
  char *v37;
  _QWORD v38[8];
  _QWORD v39[3];
  char v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  __n128 (*v44)(uint64_t, uint64_t);
  void (*v45)(uint64_t);
  _BYTE v46[64];
  uint64_t v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52;
  unsigned __int8 v53[8];
  unint64_t v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v3 = (const void *)*((_QWORD *)this + 59);
  if (v3)
  else
    v4 = 0;
  v52 = 0;
  v50 = 0u;
  v51 = 0u;
  v48 = 0u;
  v49 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v48, *((IIOImageReadSession **)this + 3));
  if (*((_BYTE *)this + 341))
  {
    v5 = (unsigned __int8 *)*((_QWORD *)&v48 + 1);
    v6 = *(_DWORD *)(*((_QWORD *)&v48 + 1) + 4) == 169478669;
    *((_BYTE *)this + 344) = v6;
    v41 = 0;
    v42 = &v41;
    v43 = 0x7002000000;
    v44 = __Block_byref_object_copy__0;
    v45 = __Block_byref_object_dispose__0;
    memset(v46, 0, sizeof(v46));
    v47 = 0;
    IIOScanner::IIOScanner((IIOScanner *)v46, v5, v49, v6);
    v39[0] = 0;
    v39[1] = v39;
    v39[2] = 0x2000000000;
    v40 = 0;
    *((_QWORD *)this + 72) = 0;
    v38[0] = MEMORY[0x1E0C809B0];
    v38[1] = 0x40000000;
    v38[2] = ___ZN13ATXReadPlugin10initializeEP13IIODictionary_block_invoke;
    v38[3] = &unk_1E1BBCFB0;
    v38[4] = v39;
    v38[5] = &v41;
    v38[6] = this;
    v38[7] = v4;
    v7 = IterateChunks((IIOScanner *)(v42 + 5), (uint64_t)v38);
    if ((_DWORD)v7)
    {
      kdebug_trace();
      goto LABEL_69;
    }
    v8 = (ASTCTextureImp *)*((unsigned int *)this + 126);
    v9 = *((_QWORD *)this + 73);
    if ((_DWORD)v8 == 1714434612)
    {
      if (v9 <= 0x18)
      {
        IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
        LogError("initialize", 327, "*** bad ATX file '420f' [%d bytes]\n");
        goto LABEL_69;
      }
      v10 = *((_QWORD *)this + 76);
      if (v10 <= 0x18)
      {
        IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
        LogError("initialize", 328, "*** bad ATX file '420f' [%d bytes]\n");
        goto LABEL_69;
      }
      v11 = *((_DWORD *)this + 148);
      v12 = *((_DWORD *)this + 128);
      if (v11 < v12)
      {
        LogError("initialize", 330, "*** bad ATX '420f' Y plane (%d vs %d)\n");
        goto LABEL_69;
      }
      v13 = *((_DWORD *)this + 149);
      v14 = *((_DWORD *)this + 129);
      if (v13 < v14)
      {
        LogError("initialize", 331, "*** bad ATX '420f' Y plane (%d vs %d)\n");
        goto LABEL_69;
      }
      v15 = *((_DWORD *)this + 150);
      if (v15 < v11)
      {
        LogError("initialize", 332, "*** bad ATX '420f' Y-rowBytes too small (%d < %d)\n");
        goto LABEL_69;
      }
      if (v15 > v11 + 32)
      {
        LogError("initialize", 333, "*** bad ATX '420f' Y-rowBytes too big (%d < %d)\n");
        goto LABEL_69;
      }
      v16 = *((_DWORD *)this + 154);
      if (v16 < v12 >> 1)
      {
        v35 = 335;
      }
      else
      {
        v17 = *((_DWORD *)this + 155);
        if (v17 >= v14 >> 1)
        {
          v18 = *((_DWORD *)this + 156);
          if (v18 < v16)
          {
            LogError("initialize", 337, "*** bad ATX '420f' CbCr-rowBytes too small (%d < %d)\n");
          }
          else if (v18 > v16 + 32)
          {
            LogError("initialize", 338, "*** bad ATX '420f' CbCr-rowBytes too big (%d < %d)\n");
          }
          else if (v11 > 0x4E20)
          {
            LogError("initialize", 340, "*** bad ATX '420f' width: %d\n");
          }
          else if (v13 >= 0x4E21)
          {
            LogError("initialize", 341, "*** bad ATX '420f' height: %d\n");
          }
          else if (v11 > 2 * v16 + 32)
          {
            LogError("initialize", 342, "*** bad ATX '420f' width:   Y: %d CbCr:%d\n");
          }
          else if (v13 > 2 * v17 + 32)
          {
            LogError("initialize", 343, "*** bad ATX '420f' height:   Y: %d CbCr:%d\n");
          }
          else
          {
            if (*((_BYTE *)this + 632))
            {
LABEL_25:
              *((_WORD *)this + 188) = 12;
LABEL_57:
              *((_DWORD *)this + 57) = v12;
              *((_DWORD *)this + 58) = v14;
              *((_WORD *)this + 120) = 8;
              *((_DWORD *)this + 59) = 4 * v12;
              *(_DWORD *)((char *)this + 242) = 262176;
              switch(*((_DWORD *)this + 141))
              {
                case 0:
                  *((_QWORD *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
                  if ((gIIODebugFlags & 0x30000) != 0)
                    ImageIOLog("     colorspace: kCGColorSpaceSRGB (gray)\n");
                  break;
                case 1:
                  *((_QWORD *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
                  if ((gIIODebugFlags & 0x30000) != 0)
                    ImageIOLog("     colorspace: kCGColorSpaceSRGB\n");
                  break;
                case 2:
                  *((_QWORD *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D8F8]);
                  if ((gIIODebugFlags & 0x30000) != 0)
                    ImageIOLog("     colorspace: kCGColorSpaceAdobeRGB1998\n");
                  break;
                case 3:
                  *((_QWORD *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D908]);
                  if ((gIIODebugFlags & 0x30000) != 0)
                    ImageIOLog("     colorspace: kCGColorSpaceDisplayP3\n");
                  break;
                case 4:
                  *((_QWORD *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D960]);
                  if ((gIIODebugFlags & 0x30000) != 0)
                    ImageIOLog("     colorspace: kCGColorSpaceExtendedSRGB\n");
                  break;
                default:
                  break;
              }
              *((_DWORD *)this + 81) = 1380401696;
              v32 = *((_DWORD *)this + 142) & 0x1F;
              *((_DWORD *)this + 142) = v32;
              *((_BYTE *)this + 246) = v32;
              *((_BYTE *)this + 278) = v32;
              *((_BYTE *)this + 346) = 0;
              *((_DWORD *)this + 59) = 4 * *((_DWORD *)this + 57);
              *((_BYTE *)this + 350) = 1;
              goto LABEL_69;
            }
            if (v9 + v13 * v11 >= v10)
            {
              v36 = 353;
            }
            else
            {
              v19 = v16 * (unint64_t)v17;
              if ((v19 & 0xFFFFFFFF00000000) != 0)
              {
                v36 = 356;
              }
              else
              {
                if (v10 + v19 < (unint64_t)v49)
                  goto LABEL_25;
                v36 = 357;
              }
            }
            LogError("initialize", v36, "*** bad ATX '420f'\n");
          }
LABEL_69:
          _Block_object_dispose(v39, 8);
          _Block_object_dispose(&v41, 8);
          IIOScanner::~IIOScanner((IIOScanner *)v46);
          goto LABEL_70;
        }
        v35 = 336;
      }
      LogError("initialize", v35, "*** bad ATX '420f' CbCr plane (%d vs %d)\n");
      goto LABEL_69;
    }
    if (v9)
    {
      v34 = 363;
    }
    else
    {
      if (!*((_QWORD *)this + 76))
      {
        if (!*((_QWORD *)this + 72))
        {
          IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
          LogError("initialize", 366, "*** bad ATX file [%d bytes]\n");
          goto LABEL_69;
        }
        *((_DWORD *)this + 112) = ASTCTextureImp::MetalFormatForGLFormat(v8);
        v20 = *((_DWORD *)this + 126);
        v21 = 4;
        if (v20 > 37839)
        {
          if (v20 == 37840)
            goto LABEL_37;
          v22 = 37847;
        }
        else
        {
          if (v20 == 37808)
            goto LABEL_37;
          v22 = 37815;
        }
        if (v20 != v22)
          goto LABEL_69;
        v21 = 8;
LABEL_37:
        *((_BYTE *)this + 572) = v21;
        *((_BYTE *)this + 573) = v21;
        *((_BYTE *)this + 574) = 1;
        v23 = *((_DWORD *)this + 128);
        *((_DWORD *)this + 109) = v23;
        v24 = *((_DWORD *)this + 129);
        *((_DWORD *)this + 110) = v24;
        ASTCTextureImp::setTextureDimension((uint64_t)v4, v23, v24);
        ASTCTextureImp::setMetalFormat((uint64_t)v4, *((_DWORD *)this + 112));
        if (ASTCTextureImp::isInputPreTwiddled(v4))
        {
          v25 = *((unsigned __int8 *)this + 573) | (16 * *((unsigned __int8 *)this + 572));
          if (v25 == 136)
            v26 = 37815;
          else
            v26 = 0;
          if (v25 == 68)
            v27 = 37808;
          else
            v27 = v26;
          v28 = ASTCTextureImp::MetalFormatForGLFormat((ASTCTextureImp *)v27);
          v29 = (ASTCTwiddler *)operator new();
          ASTCTwiddler::ASTCTwiddler(v29, v28, *((unsigned int *)this + 128), *((unsigned int *)this + 129), 1uLL, 0);
          *(_QWORD *)v53 = 0;
          v54 = 0;
          ASTCTwiddler::getWatermark(v29, v53);
          if (*(_QWORD *)v53 == *(_QWORD *)((char *)this + 548) && v54 == *(_QWORD *)((char *)this + 556))
          {
            v31 = _cg_jpeg_mem_term("initialize", 414, "watermark OK\n");
          }
          else
          {
            v37 = 0;
            asprintf(&v37, "got: %016llX %016llX expected: %016llX %016llX", bswap64(*(_QWORD *)((char *)this + 548)), bswap64(*(_QWORD *)((char *)this + 556)), bswap64(*(unint64_t *)v53), bswap64(v54));
            if (v37)
            {
              LogError("initialize", 430, "*** ASTC watermark ERROR (%s) the image was created on a different hardware\n", v37);
              free(v37);
              (*(void (**)(ASTCTwiddler *))(*(_QWORD *)v29 + 8))(v29);
              goto LABEL_69;
            }
          }
          (*(void (**)(ASTCTwiddler *, __n128))(*(_QWORD *)v29 + 8))(v29, v31);
        }
        *((_DWORD *)this + 113) = (*((_DWORD *)this + 109) + *((unsigned __int8 *)this + 572) - 1)
                                / *((unsigned __int8 *)this + 572);
        *((_DWORD *)this + 114) = (*((_DWORD *)this + 110) + *((unsigned __int8 *)this + 573) - 1)
                                / *((unsigned __int8 *)this + 573);
        if ((gIIODebugFlags & 0x30000) != 0)
        {
          ImageIOLog("    %s:\n", "initialize");
          if ((gIIODebugFlags & 0x30000) != 0)
          {
            ImageIOLog("    textureSize: %d x %d\n", *((_DWORD *)this + 109), *((_DWORD *)this + 110));
            if ((gIIODebugFlags & 0x30000) != 0)
              ImageIOLog("         blocks: %d x %d\n", *((_DWORD *)this + 113), *((_DWORD *)this + 114));
          }
        }
        ASTCTextureImp::setDim(v4, *((unsigned __int8 *)this + 572), *((unsigned __int8 *)this + 573));
        ASTCTextureImp::setBlocks((uint64_t)v4, *((_DWORD *)this + 113), *((_DWORD *)this + 114));
        *((_WORD *)this + 188) = 13;
        v12 = *((_DWORD *)this + 128);
        v14 = *((_DWORD *)this + 129);
        goto LABEL_57;
      }
      v34 = 364;
    }
    LogError("initialize", v34, "*** bad ATX file \n");
    goto LABEL_69;
  }
  v7 = 4294967246;
LABEL_70:
  IIOScanner::~IIOScanner((IIOScanner *)&v48);
  return v7;
}

void sub_187E76A8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  IIOScanner *v27;
  uint64_t v28;

  _Block_object_dispose(&a23, 8);
  _Block_object_dispose(&a27, 8);
  IIOScanner::~IIOScanner(v27);
  IIOScanner::~IIOScanner((IIOScanner *)(v28 - 160));
  _Unwind_Resume(a1);
}

uint64_t ASTCTextureImp::MetalFormatForGLFormat(ASTCTextureImp *this)
{
  if (((_DWORD)this - 37808) > 0x2D)
    return 0;
  else
    return dword_188211754[(int)this - 37808];
}

uint64_t ASTCTextureImp::setBlocks(uint64_t this, int a2, int a3)
{
  *(_DWORD *)(this + 20) = a2;
  *(_DWORD *)(this + 24) = a3;
  return this;
}

float ASTCTextureImp::setDim(ASTCTextureImp *this, int a2, int a3)
{
  float result;

  *((_DWORD *)this + 7) = a2;
  *((_DWORD *)this + 8) = a3;
  result = 128.0 / (double)(a3 * a2);
  *((float *)this + 9) = result;
  return result;
}

uint64_t ASTCTextureImp::setMetalFormat(uint64_t this, int a2)
{
  *(_DWORD *)(this + 96) = a2;
  return this;
}

uint64_t ASTCTextureImp::isInputPreTwiddled(ASTCTextureImp *this)
{
  return *((unsigned __int8 *)this + 41);
}

uint64_t ASTCTextureImp::setTextureDimension(uint64_t this, int a2, int a3)
{
  *(_DWORD *)(this + 100) = a2;
  *(_DWORD *)(this + 104) = a3;
  return this;
}

void ASTCTextureImp::~ASTCTextureImp(ASTCTextureImp *this)
{
  void *v2;
  void *v3;
  uint64_t v4;
  IIOImageRead **Source;
  uint64_t v6;
  const void *v7;
  uint64_t v8;
  const char *v9;

  *(_QWORD *)this = &off_1E1BADFA8;
  v2 = (void *)*((_QWORD *)this + 7);
  if (v2 && !*((_BYTE *)this + 43))
    free(v2);
  *((_QWORD *)this + 7) = 0;
  v3 = (void *)*((_QWORD *)this + 9);
  if (v3)
    free(v3);
  *((_QWORD *)this + 9) = 0;
  if (*((_QWORD *)this + 16))
  {
    v4 = *((_QWORD *)this + 17);
    if (v4)
    {
      Source = (IIOImageRead **)CGImageSourceGetSource(v4);
      if (Source)
        IIOImageReadSession::releaseBytePointer(Source, *((void **)this + 16));
    }
    *((_QWORD *)this + 16) = 0;
  }
  v6 = *((_QWORD *)this + 30);
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  *((_QWORD *)this + 30) = 0;
  v7 = (const void *)*((_QWORD *)this + 17);
  if (v7)
    CFRelease(v7);
  *((_QWORD *)this + 17) = 0;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 168));
  _cg_jpeg_mem_term(this, v8, v9);
}

{
  ASTCTextureImp::~ASTCTextureImp(this);
  JUMPOUT(0x18D761C30);
}

void ASTCTwiddler::~ASTCTwiddler(ASTCTwiddler *this)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 1);
  *(_QWORD *)this = &off_1E1BAC030;
  *((_QWORD *)this + 1) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  JUMPOUT(0x18D761C30);
}

{
  uint64_t v2;

  v2 = *((_QWORD *)this + 1);
  *(_QWORD *)this = &off_1E1BAC030;
  *((_QWORD *)this + 1) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
}

void ASTCTwiddler::ASTCTwiddlerImpl::~ASTCTwiddlerImpl(ASTCTwiddler::ASTCTwiddlerImpl *this)
{
  ASTCTwiddler::ASTCTwiddlerImpl::~ASTCTwiddlerImpl(this);
  JUMPOUT(0x18D761C30);
}

{
  unint64_t v2;

  *(_QWORD *)this = &off_1E1BB3178;

  *((_QWORD *)this + 7) = 0;
  v2 = *((_QWORD *)this + 5);
  if (v2)
    _ImageIO_Free(v2, *((_QWORD *)this + 6));
  *((_QWORD *)this + 5) = 0;
}

uint64_t _ImageIO_Free(unint64_t a1, size_t a2)
{
  unint64_t v4;
  unint64_t v6;
  unint64_t *v7;

  pthread_mutex_lock(&gImageIOMemoryHashLock);
  if (gMemoryHashCreateOnce != -1)
    dispatch_once(&gMemoryHashCreateOnce, &__block_literal_global_30);
  if (!a2)
  {
    v6 = ~a1;
    v7 = &v6;
    a2 = std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>((uint64_t **)(gIIOMemoryHash + 8), &v6, (uint64_t)&std::piecewise_construct, (uint64_t **)&v7)[5];
  }
  v4 = IIOMemoryHash::remove((uint64_t **)gIIOMemoryHash, a1);
  if (v4 != a2)
  {
    if (v4 > a2)
      a2 = v4;
    else
      LogFault("_ImageIO_Free", 529, "*** ptr %p got double released??? (%ld bytes)   hash: %ld\n", (const void *)a1, a2, v4);
  }
  ImageIORecordMemory(a1, -(uint64_t)a2);
  munmap((void *)a1, a2);
  return pthread_mutex_unlock(&gImageIOMemoryHashLock);
}

uint64_t IIOMemoryHash::remove(uint64_t **this, unint64_t a2)
{
  char *v2;
  uint64_t v3;
  unint64_t v5;
  unint64_t *v6;

  v5 = ~a2;
  v2 = (char *)(this + 1);
  v6 = &v5;
  v3 = std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(this + 1, &v5, (uint64_t)&std::piecewise_construct, (uint64_t **)&v6)[5];
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__erase_unique<unsigned long>((uint64_t)v2, &v5);
  return v3;
}

void TIFFReadPlugin::isValidIFD(uint64_t a1, unint64_t a2, unsigned int a3, unint64_t a4, uint64_t a5, int a6)
{
  size_t IFDCount;
  unint64_t v11;
  unsigned __int16 *v12;
  uint64_t v13;
  unint64_t v14;
  __int128 v15;
  unint64_t v16;
  unsigned __int16 *v17;
  unsigned int v18;
  unint64_t v19;
  unsigned int v20;
  unsigned int v21;
  unint64_t v22;
  unsigned __int16 *v23;
  unint64_t v24;
  unsigned __int16 *v25;
  _QWORD *v26;
  int v27;
  int v28;
  unsigned __int16 *v29;
  unint64_t v30;
  unsigned __int16 *v31;
  int v32;
  uint64_t v33;
  unint64_t *v34;
  uint64_t v35;
  int v36;
  BOOL v37;
  unsigned int v38;
  unint64_t v40;
  unsigned __int16 *v41;
  uint64_t v42;
  _QWORD *v43;
  int v44;
  unint64_t v47;
  _QWORD *v48;
  _QWORD *v49;
  unint64_t v50;
  BOOL v51;
  _QWORD *v52;
  _DWORD *v53;
  _DWORD *exception;
  unint64_t v55;
  unsigned int v56;
  unsigned __int16 *v59;
  unint64_t v60;
  unsigned int v61;

  IIOScanner::seek((IIOScanner *)a2, a4);
  IFDCount = IIOScanner::getIFDCount((IIOScanner *)a2);
  v11 = IFDCount;
  if (IFDCount)
  {
    if (IFDCount >= 0x65)
    {
      _cg_jpeg_mem_term("isValidIFD", 233, "*** ERROR: invalid ifdCount (%lld)\n", IFDCount);
      ++*(_WORD *)(a5 + 4);
      exception = __cxa_allocate_exception(4uLL);
      *exception = -1;
      __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
    }
    v12 = (unsigned __int16 *)malloc_type_calloc(IFDCount, 0x14uLL, 0x1000040A86A77D5uLL);
    v13 = (uint64_t)v12;
    v59 = v12;
    v14 = v11;
    do
    {
      if (a3)
      {
        IIOScanner::getBigTiffTag(a2, v13);
      }
      else
      {
        v61 = 0;
        v60 = 0;
        IIOScanner::getTiffTag(a2, (uint64_t)&v60);
        if (*(_DWORD *)(a2 + 64))
        {
          v53 = __cxa_allocate_exception(4uLL);
          *v53 = -1;
          __cxa_throw(v53, MEMORY[0x1E0DE4EF0], 0);
        }
        *(_DWORD *)v13 = v60;
        *(_QWORD *)&v15 = HIDWORD(v60);
        *((_QWORD *)&v15 + 1) = v61;
        *(_OWORD *)(v13 + 4) = v15;
      }
      v13 += 20;
      --v14;
    }
    while (v14);
    if (a6)
      v16 = 0;
    else
      v16 = *(_QWORD *)(a2 + 24);
    if (v11 >= 2)
    {
      v17 = v12 + 10;
      v18 = *v12;
      v19 = v11 - 1;
      do
      {
        v21 = *v17;
        v17 += 10;
        v20 = v21;
        if (v18 > v21)
          ++*(_WORD *)a5;
        v18 = v20;
        --v19;
      }
      while (v19);
    }
    if (v11 != 1)
    {
      v22 = 0;
      v23 = v12;
      v24 = v11;
      do
      {
        if (v22 < v11)
        {
          v25 = &v12[10 * v22];
          v28 = *v25;
          v26 = v25 + 6;
          v27 = v28;
          v29 = v23;
          v30 = v24;
          v31 = v23;
          do
          {
            v32 = *v31;
            v31 += 10;
            if (v27 == v32 && *v26 != *(_QWORD *)(v29 + 6))
              ++*(_WORD *)(a5 + 2);
            v29 = v31;
            --v30;
          }
          while (v30);
        }
        ++v22;
        --v24;
        v23 += 10;
      }
      while (v22 != v11 - 1);
    }
    if (v11 <= 1)
      v33 = 1;
    else
      v33 = v11;
    v34 = (unint64_t *)(v12 + 2);
    v35 = v33;
    do
    {
      v36 = *((unsigned __int16 *)v34 - 2);
      v37 = (v36 - 256) > 0x28 || ((1 << v36) & 0x1001C6400C3) == 0;
      v38 = v36 - 40961;
      if (v37 && v38 >= 3)
        v40 = 0xFFFFFFFFLL;
      else
        v40 = 1;
      if (*v34 > v40 && *v34 >= 5)
        ++*(_WORD *)(a5 + 4);
      v34 = (unint64_t *)((char *)v34 + 20);
      --v35;
    }
    while (v35);
    v55 = v16;
    v56 = a3;
    v41 = v12;
    v42 = 0;
    v43 = (_QWORD *)(a5 + 16);
    do
    {
      v44 = v59[10 * v42];
      if (v44 == 34665 || v44 == 40965 || v44 == 34853)
      {
        v47 = *(_QWORD *)&v41[10 * v42 + 6];
        if (v47 == a4)
        {
          ++*(_WORD *)(a5 + 6);
        }
        else
        {
          v60 = *(_QWORD *)&v41[10 * v42 + 6];
          v48 = (_QWORD *)*v43;
          if (!*v43)
            goto LABEL_65;
          v49 = (_QWORD *)(a5 + 16);
          do
          {
            v50 = v48[4];
            v51 = v50 >= v47;
            if (v50 >= v47)
              v52 = v48;
            else
              v52 = v48 + 1;
            if (v51)
              v49 = v48;
            v48 = (_QWORD *)*v52;
          }
          while (*v52);
          if (v49 != v43 && v47 >= v49[4])
          {
            ++*(_WORD *)(a5 + 2);
          }
          else
          {
LABEL_65:
            std::__tree<unsigned long long>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>((uint64_t **)(a5 + 8), &v60, (uint64_t *)&v60);
            TIFFReadPlugin::isValidIFD(a1, a2, v56, v60, a5, (a6 + 1));
          }
        }
      }
      ++v42;
    }
    while (v42 != v33);
    free(v59);
    if (v55)
      IIOScanner::seek((IIOScanner *)a2, v55);
  }
}

void sub_187E77234(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187E7719CLL);
}

uint64_t IIOScanner::getTiffTag(uint64_t this, uint64_t a2)
{
  uint64_t v3;
  IIOScanner *Val32;
  int v5;
  int v6;
  int v7;
  char v8;
  _DWORD *exception;

  if (a2)
  {
    v3 = this;
    if ((unint64_t)(*(_QWORD *)(this + 24) + 12) >= *(_QWORD *)(this + 16))
    {
      *(_DWORD *)(a2 + 8) = 0;
      *(_QWORD *)a2 = 0;
      LogError("getTiffTag", 348, "*** IIOScanner::getTiffTag reached EOF\n");
      *(_DWORD *)(v3 + 64) = -39;
      exception = __cxa_allocate_exception(4uLL);
      *exception = -39;
      __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
    }
    *(_WORD *)a2 = IIOScanner::getVal16((IIOScanner *)this);
    *(_WORD *)(a2 + 2) = IIOScanner::getVal16((IIOScanner *)v3);
    Val32 = (IIOScanner *)IIOScanner::getVal32((IIOScanner *)v3);
    *(_DWORD *)(a2 + 4) = (_DWORD)Val32;
    v5 = IIOScanner::sizeForTypeAndCount(Val32, *(unsigned __int16 *)(a2 + 2), Val32);
    this = IIOScanner::getVal32((IIOScanner *)v3);
    v6 = v5 - 1;
    if ((v5 - 1) <= 2)
    {
      v7 = dword_18822E4C0[v6];
      v8 = 24 - 8 * v6;
      if (*(_BYTE *)(v3 + 68))
        v8 = 0;
      this = (this >> v8) & v7;
    }
    *(_DWORD *)(a2 + 8) = this;
  }
  return this;
}

uint64_t IIOScanner::sizeForTypeAndCount(IIOScanner *this, int a2, uint64_t a3)
{
  uint64_t result;

  result = a3;
  switch(a2)
  {
    case 0:
      result = 0;
      break;
    case 3:
    case 8:
      result = 2 * a3;
      break;
    case 4:
    case 9:
    case 11:
    case 13:
      result = 4 * a3;
      break;
    case 5:
    case 10:
    case 12:
    case 16:
    case 17:
    case 18:
      result = 8 * a3;
      break;
    default:
      return result;
  }
  return result;
}

void EnumerateExifDataUsingBlock(const char *a1, int a2, uint64_t a3)
{
  const char *v5;
  uint64_t v6;
  BOOL v7;
  unsigned __int8 *v8;
  int v9;
  _QWORD *v10;
  int v11;
  unsigned int Val32;
  int v13;
  char v14;
  char v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  _QWORD *v19;
  unint64_t v20;
  _QWORD *v21;
  int Val16;
  int v23;
  char v24;
  unint64_t v25;
  int v26;
  uint64_t v27;
  unsigned int v28;
  char v29;
  unint64_t v30;
  unint64_t v31;
  int v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  uint64_t v39;
  uint64_t *v40;
  _QWORD v41[2];
  char v42;
  uint64_t v43[2];

  v5 = a1;
  v42 = 0;
  v41[0] = 0;
  v41[1] = 0;
  v40 = v41;
  LODWORD(v6) = 6;
  if (*(unsigned __int8 *)a1 == 255)
  {
    v7 = *((unsigned __int8 *)a1 + 1) == 225;
    a1 += 4 * v7;
    if (v7)
      LODWORD(v6) = 10;
    else
      LODWORD(v6) = 6;
  }
  if (!strncmp(a1, "Exif", 4uLL))
    v6 = v6;
  else
    v6 = 0;
  v43[0] = 0;
  v8 = (unsigned __int8 *)&v5[v6];
  v9 = v5[v6];
  if (v9 != 73)
  {
    v10 = 0;
    if (v9 != 77)
      goto LABEL_64;
    if (v5[v6 | 1] == 77)
    {
      v11 = 1;
      goto LABEL_14;
    }
LABEL_61:
    v10 = 0;
    goto LABEL_64;
  }
  if (v5[v6 | 1] != 73)
    goto LABEL_61;
  v11 = 0;
LABEL_14:
  v39 = 0;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v35, v8, (a2 - v6), v11 ^ 1);
  IIOScanner::skip((uint64_t)&v35, 4);
  Val32 = IIOScanner::getVal32((IIOScanner *)&v35);
  IIOScanner::seek((IIOScanner *)&v35, Val32);
  v13 = 0;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v14 = 0;
  if (v11)
    v15 = 16;
  else
    v15 = 0;
  v29 = v15;
  while (1)
  {
    v43[0] = *((_QWORD *)&v36 + 1);
    v16 = (_QWORD *)v41[0];
    if (v41[0])
    {
      v17 = v41;
      do
      {
        v18 = v16;
        v19 = v17;
        v20 = v16[4];
        v21 = v16 + 1;
        if (v20 <= *((_QWORD *)&v36 + 1))
        {
          v21 = v18;
          v17 = v18;
        }
        v16 = (_QWORD *)*v21;
      }
      while (v16);
      if (v17 != v41)
      {
        if (v20 > *((_QWORD *)&v36 + 1))
          v18 = v19;
        if (*((_QWORD *)&v36 + 1) <= v18[4])
          break;
      }
    }
    std::__tree<unsigned long long,std::greater<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(&v40, (unint64_t *)v43, v43);
    Val16 = IIOScanner::getVal16((IIOScanner *)&v35);
    if (Val16)
    {
      v23 = 0;
      v24 = v14 | v29;
      while (2)
      {
        v33 = 0u;
        v34 = 0u;
        BYTE8(v34) = v24;
        v25 = *((_QWORD *)&v36 + 1);
        WORD4(v33) = IIOScanner::getVal16((IIOScanner *)&v35);
        WORD5(v33) = IIOScanner::getVal16((IIOScanner *)&v35);
        v26 = IIOScanner::getVal32((IIOScanner *)&v35);
        HIDWORD(v33) = v26;
        switch(WORD5(v33))
        {
          case 1:
          case 2:
          case 7:
            goto LABEL_33;
          case 3:
            LOWORD(v26) = 2 * v26;
            goto LABEL_33;
          case 4:
          case 9:
            LOWORD(v26) = 4 * v26;
            goto LABEL_33;
          case 5:
          case 0xA:
            LOWORD(v26) = 8 * v26;
LABEL_33:
            DWORD1(v34) = (unsigned __int16)v26;
            if ((unsigned __int16)v26 >= 4u)
            {
              LODWORD(v34) = IIOScanner::getVal32((IIOScanner *)&v35);
              goto LABEL_45;
            }
            if ((unsigned __int16)v26 == 2)
            {
              LODWORD(v34) = IIOScanner::getVal16((IIOScanner *)&v35);
              v27 = 2;
            }
            else
            {
              if ((unsigned __int16)v26 != 1)
                goto LABEL_43;
              LODWORD(v34) = IIOScanner::getVal8((IIOScanner *)&v35);
              v27 = 3;
            }
            goto LABEL_44;
          default:
            if (!WORD4(v33) && v23 + 1 == Val16)
            {
              IIOScanner::seek((IIOScanner *)&v35, v25);
              ++v23;
              goto LABEL_54;
            }
            DWORD1(v34) = 0;
LABEL_43:
            v27 = 4;
LABEL_44:
            IIOScanner::skip((uint64_t)&v35, v27);
LABEL_45:
            *(_QWORD *)&v33 = v25;
            if (WORD4(v33) == 34853)
            {
              v31 = v34;
              v32 = 34853;
              if (!a3)
                goto LABEL_52;
LABEL_51:
              (*(void (**)(uint64_t, __int128 *, uint64_t, char *))(a3 + 16))(a3, &v33, v6, &v42);
              goto LABEL_52;
            }
            if (WORD4(v33) == 34665)
            {
              v30 = v34;
              v13 = 34665;
            }
            if (a3)
              goto LABEL_51;
LABEL_52:
            if (v42)
              goto LABEL_63;
            ++v23;
LABEL_54:
            if (v23 == Val16)
              break;
            continue;
        }
        break;
      }
    }
    v28 = IIOScanner::getVal32((IIOScanner *)&v35);
    if (v28)
    {
      v14 = 1;
      IIOScanner::seek((IIOScanner *)&v35, v28);
    }
    else if (v13)
    {
      v14 = 2;
      IIOScanner::seek((IIOScanner *)&v35, v30);
      v13 = 0;
    }
    else
    {
      if (!v32)
        goto LABEL_63;
      v14 = 3;
      IIOScanner::seek((IIOScanner *)&v35, v31);
      v13 = 0;
      v32 = 0;
    }
  }
  _cg_jpeg_mem_term("EnumerateExifDataUsingBlock", 4803, "*** ERROR: cycle in IDF offsets [offset %ld was already processed]\n", *((_QWORD *)&v36 + 1));
LABEL_63:
  IIOScanner::~IIOScanner((IIOScanner *)&v35);
  v10 = (_QWORD *)v41[0];
LABEL_64:
  std::__tree<unsigned long long>::destroy((uint64_t)&v40, v10);
}

void sub_187E77790(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<unsigned long long>::destroy(v1 - 128, *(_QWORD **)(v1 - 120));
  _Unwind_Resume(a1);
}

#error "187E777D0: call analysis failed (funcsize=10)"

void sub_187E777DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  IIOScanner::~IIOScanner((IIOScanner *)va);
  JUMPOUT(0x187E77794);
}

uint64_t IIOScanner::getVal16(IIOScanner *this)
{
  uint64_t v1;
  unsigned int v2;
  unsigned int v3;
  _DWORD *exception;

  v1 = *((_QWORD *)this + 3);
  if ((unint64_t)(v1 + 1) >= *((_QWORD *)this + 2))
  {
    LogError("getVal16", 178, "*** IIOScanner::getVal16 reached EOF\n");
    *((_DWORD *)this + 16) = -39;
    exception = __cxa_allocate_exception(4uLL);
    *exception = -39;
    __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
  }
  v2 = *(unsigned __int16 *)(*((_QWORD *)this + 1) + v1);
  v3 = bswap32(v2) >> 16;
  if (!*((_BYTE *)this + 68))
    LOWORD(v2) = v3;
  *((_QWORD *)this + 3) = v1 + 2;
  return (unsigned __int16)v2;
}

void std::__tree<unsigned long long>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<unsigned long long>::destroy(a1, *a2);
    std::__tree<unsigned long long>::destroy(a1, a2[1]);
    operator delete(a2);
  }
}

uint64_t ___ZN13PNGReadPlugin24AddOrientationToMetadataEP13IIODictionaryS1_P15CGImageMetadataP14png_struct_defP12png_info_def_block_invoke_2(uint64_t result, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  if (*(_WORD *)(a2 + 8) == 274)
  {
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *(_DWORD *)(a2 + 16);
    *a4 = 1;
  }
  return result;
}

void ___ZN19AppleJPEGReadPlugin12readExifDataEP13IIODictionarybb_block_invoke(uint64_t a1, uint64_t a2, unsigned int a3)
{
  unsigned int v5;
  int v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CGImageMetadataTag *v10;
  uint64_t v11;
  CGImageMetadataTag *v12;
  uint64_t v13;
  int v14;
  CGImageMetadataTag *v15;
  uint64_t v16;
  CGImageMetadataTag *v17;
  _BYTE v18[16];
  CFTypeRef value;
  _QWORD v20[2];

  v20[1] = *MEMORY[0x1E0C80C00];
  v5 = *(unsigned __int16 *)(a2 + 8);
  if (v5 > 0x200)
  {
    if (v5 == 513)
    {
      if ((*(_BYTE *)(a1 + 80) & 4) != 0)
      {
        v16 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
        if (!*(_QWORD *)(v16 + 24))
        {
          *(_QWORD *)(v16 + 24) = *(unsigned int *)(a2 + 16) + (unint64_t)a3 + *(_QWORD *)(a1 + 72) + 10;
          IIONumber::IIONumber((IIONumber *)v18, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
          v17 = CGImageMetadataTagCreate(CFSTR("http://ns.adobe.com/tiff/1.0/"), CFSTR("iio"), CFSTR("JPEGInterchangeFormat"), kCGImageMetadataTypeDefault, value);
          IIONumber::~IIONumber((IIONumber *)v18);
          if (v17)
          {
            CGImageMetadataSetTagWithPath(*(CGMutableImageMetadataRef *)(a1 + 64), 0, CFSTR("iio:JPEGInterchangeFormat"), v17);
            CFRelease(v17);
          }
        }
      }
    }
    else if (v5 == 514 && (*(_BYTE *)(a1 + 80) & 4) != 0)
    {
      v11 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
      if (!*(_DWORD *)(v11 + 24))
      {
        *(_DWORD *)(v11 + 24) = *(_DWORD *)(a2 + 16);
        IIONumber::IIONumber((IIONumber *)v18, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24));
        v12 = CGImageMetadataTagCreate(CFSTR("http://ns.adobe.com/tiff/1.0/"), CFSTR("iio"), CFSTR("JPEGInterchangeFormatLength"), kCGImageMetadataTypeDefault, value);
        IIONumber::~IIONumber((IIONumber *)v18);
        if (v12)
        {
          CGImageMetadataSetTagWithPath(*(CGMutableImageMetadataRef *)(a1 + 64), 0, CFSTR("iio:JPEGInterchangeFormatLength"), v12);
          CFRelease(v12);
        }
      }
    }
  }
  else if (v5 - 282 >= 2)
  {
    if (v5 == 274)
    {
      v13 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      if (!*(_DWORD *)(v13 + 24))
      {
        v14 = *(_DWORD *)(a2 + 16);
        if ((v14 - 1) <= 7)
        {
          *(_DWORD *)(v13 + 24) = v14;
          IIONumber::IIONumber((IIONumber *)v18, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
          v15 = CGImageMetadataTagCreate(CFSTR("http://ns.adobe.com/tiff/1.0/"), CFSTR("tiff"), CFSTR("Orientation"), kCGImageMetadataTypeDefault, value);
          IIONumber::~IIONumber((IIONumber *)v18);
          if (v15)
          {
            CGImageMetadataSetTagWithPath(*(CGMutableImageMetadataRef *)(a1 + 64), 0, CFSTR("tiff:Orientation"), v15);
            CFRelease(v15);
          }
        }
      }
    }
  }
  else
  {
    v6 = a3 + *(_DWORD *)(a2 + 16) + *(_DWORD *)(a1 + 72);
    v7 = (v6 + 10);
    if (v6 == -10)
      return;
    v8 = *(_QWORD *)(a1 + 56);
    v20[0] = 0;
    IIOImageReadSession::getBytesAtOffset(*(IIOImageReadSession **)(v8 + 24), v20, v7, 8uLL);
    v20[0] = _byteswap_uint64(__PAIR64__(v20[0], HIDWORD(v20[0])));
    v9 = (uint64_t)((double)LODWORD(v20[0]) / (double)HIDWORD(v20[0]));
    if (*(_WORD *)(a2 + 8) == 282)
    {
      IIONumber::IIONumber((IIONumber *)v18, v9);
      v10 = CGImageMetadataTagCreate(CFSTR("http://ns.adobe.com/tiff/1.0/"), CFSTR("tiff"), CFSTR("XResolution"), kCGImageMetadataTypeDefault, value);
      IIONumber::~IIONumber((IIONumber *)v18);
      if (!v10)
        return;
      CGImageMetadataSetTagWithPath(*(CGMutableImageMetadataRef *)(a1 + 64), 0, CFSTR("tiff:XResolution"), v10);
    }
    else
    {
      IIONumber::IIONumber((IIONumber *)v18, v9);
      v10 = CGImageMetadataTagCreate(CFSTR("http://ns.adobe.com/tiff/1.0/"), CFSTR("tiff"), CFSTR("YResolution"), kCGImageMetadataTypeDefault, value);
      IIONumber::~IIONumber((IIONumber *)v18);
      if (!v10)
        return;
      CGImageMetadataSetTagWithPath(*(CGMutableImageMetadataRef *)(a1 + 64), 0, CFSTR("tiff:YResolution"), v10);
    }
    CFRelease(v10);
  }
}

void sub_187E77C80(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<unsigned long long,std::greater<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(uint64_t **a1, unint64_t *a2, uint64_t *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  unint64_t v7;
  uint64_t **v8;
  unint64_t v9;
  uint64_t *v10;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    v7 = *a2;
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v9 = v5[4];
        if (v7 <= v9)
          break;
        v5 = *v8;
        v6 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (v9 <= v7)
        break;
      v5 = v8[1];
      if (!v5)
      {
        v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v8 = a1 + 1;
LABEL_10:
    v10 = (uint64_t *)operator new(0x28uLL);
    v10[4] = *a3;
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__insert_node_at(a1, (uint64_t)v8, v6, v10);
    return v10;
  }
  return (uint64_t *)v8;
}

uint64_t IterateChunks(IIOScanner *a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t Val32;
  uint64_t v6;
  unint64_t v7;
  uint64_t result;
  unsigned int v9;

  IIOScanner::seek(a1, 8uLL);
  v4 = *((_QWORD *)a1 + 3);
  Val32 = IIOScanner::getVal32(a1);
  v6 = bswap32(IIOScanner::getVal32(a1));
  v7 = *((_QWORD *)a1 + 2);
  do
  {
    if (v7 <= v4)
      break;
    result = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, uint64_t))(a2 + 16))(a2, v4, Val32, v6);
    if ((_DWORD)result)
      return result;
    if (*((_QWORD *)a1 + 3) + (unint64_t)Val32 > *((_QWORD *)a1 + 2))
      break;
    IIOScanner::skip((uint64_t)a1, Val32);
    v4 = *((_QWORD *)a1 + 3);
    Val32 = IIOScanner::getVal32(a1);
    result = 4294967246;
    if (*((_QWORD *)a1 + 3) + 4 > v7 || v7 < Val32)
      return result;
    v9 = IIOScanner::getVal32(a1);
    v6 = bswap32(v9);
  }
  while (v9 != 541347397);
  return 0;
}

void sub_187E77E48(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187E77E34);
}

uint64_t IIO_Reader_HEIF::testHeader(uint64_t a1, unsigned __int8 *a2, unint64_t a3, uint64_t a4, unsigned int a5)
{
  __CFString **v5;
  unsigned int Val32;
  int v9;
  unsigned int v10;
  int v11;
  int v12;
  __CFString **v13;
  int v14;
  int v15;
  int v16;
  unsigned int v19;
  int v20;
  __CFString **v21;
  _OWORD v23[4];
  uint64_t v24;

  v5 = *(__CFString ***)(a1 + 8);
  if (v5 == kCGImageTypeIdentifierJPEG)
  {
    if (((a5 >> 3) & 3) != 0)
      v15 = -1;
    else
      v15 = 0;
    if (((a5 >> 3) & 3) == 1)
      v16 = 1;
    else
      v16 = v15;
    if (v16)
    {
      if (v16 == 255
        && *a2 == 255
        && a2[1] == 216
        && a2[2] == 255
        && a2[3] == 224
        && !a2[4]
        && a2[5] == 20
        && a2[20] == 65
        && a2[21] == 77
        && a2[22] == 80
        && a2[23] == 70)
      {
        return 1;
      }
    }
    else if (*a2 == 255 && a2[1] == 216 && a2[2] == 255)
    {
      return 1;
    }
  }
  else
  {
    if (v5 != kCGImageTypeIdentifierJPEGXL)
    {
      v24 = 0;
      memset(v23, 0, sizeof(v23));
      IIOScanner::IIOScanner((IIOScanner *)v23, a2, a3, 0);
      Val32 = IIOScanner::getVal32((IIOScanner *)v23);
      v9 = IIOScanner::getVal32((IIOScanner *)v23);
      if (Val32 >= a3)
        v10 = a3;
      else
        v10 = Val32;
      if (v9 != 1718909296)
      {
LABEL_78:
        IIOScanner::~IIOScanner((IIOScanner *)v23);
        return 0;
      }
      v11 = IIOScanner::getVal32((IIOScanner *)v23);
      v12 = v11;
      v13 = *(__CFString ***)(a1 + 8);
      if (v13 == kCGImageTypeIdentifierAVCI)
      {
        v14 = 1635148649;
        goto LABEL_53;
      }
      if (v13 == kCGImageTypeIdentifierHEIC)
      {
        if (v11 != 1751476579)
        {
          v14 = 1751476600;
          goto LABEL_53;
        }
      }
      else if (v13 == kCGImageTypeIdentifierHEICS)
      {
        if (v11 != 1751476600)
        {
          v14 = 1836279345;
          goto LABEL_53;
        }
      }
      else
      {
        if (v13 != kCGImageTypeIdentifierHEIF)
        {
          if (v13 == kCGImageTypeIdentifierAVIF)
          {
            v14 = 1635150182;
          }
          else
          {
            if (v13 != kCGImageTypeIdentifierAVIS)
            {
LABEL_56:
              IIOScanner::getVal32((IIOScanner *)v23);
              if (v10 >= 0x11 && v10 - 16 >= 4)
              {
                v19 = (v10 - 16) >> 2;
                while (1)
                {
                  v20 = IIOScanner::getVal32((IIOScanner *)v23);
                  v21 = *(__CFString ***)(a1 + 8);
                  if (v21 == kCGImageTypeIdentifierAVCI)
                  {
                    if (v20 == 1635148649)
                      goto LABEL_54;
                  }
                  else if (v21 != kCGImageTypeIdentifierHEIC || v12 == 1836279345)
                  {
                    if (v21 == kCGImageTypeIdentifierHEICS)
                    {
                      if (v20 == 1751476600 || v20 == 1836279345)
                        goto LABEL_54;
                    }
                    else if (v21 == kCGImageTypeIdentifierHEIF && (v20 == 1785750887 || v20 == 1835623985))
                    {
                      goto LABEL_54;
                    }
                  }
                  else if (v20 == 1751476579 || v20 == 1751476600)
                  {
                    goto LABEL_54;
                  }
                  if (!--v19)
                    goto LABEL_78;
                }
              }
              goto LABEL_78;
            }
            v14 = 1635150195;
          }
LABEL_53:
          if (v11 == v14)
            goto LABEL_54;
          goto LABEL_56;
        }
        if (v11 != 1785750887)
        {
          v14 = 1835623985;
          goto LABEL_53;
        }
      }
LABEL_54:
      IIOScanner::~IIOScanner((IIOScanner *)v23);
      return 1;
    }
    if (a3 >= 0xC)
    {
      if (*(_WORD *)a2 == 2815)
        return 1;
      if (*(_QWORD *)a2 == 0x204C584A0C000000 && *((_DWORD *)a2 + 2) == 176622093)
        return 1;
    }
  }
  return 0;
}

void sub_187E78210(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  IIOScanner::~IIOScanner((IIOScanner *)&a9);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187E781ECLL);
}

uint64_t IIOScanner::getVal32(IIOScanner *this)
{
  uint64_t v1;
  uint64_t v2;
  unsigned int v3;
  _DWORD *exception;

  v1 = *((_QWORD *)this + 3);
  if ((unint64_t)(v1 + 3) >= *((_QWORD *)this + 2))
  {
    LogError("getVal32", 216, "*** IIOScanner::getVal32 reached EOF\n");
    *((_DWORD *)this + 16) = -39;
    exception = __cxa_allocate_exception(4uLL);
    *exception = -39;
    __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
  }
  LODWORD(v2) = *(_DWORD *)(*((_QWORD *)this + 1) + v1);
  v3 = bswap32(v2);
  if (*((_BYTE *)this + 68))
    v2 = v2;
  else
    v2 = v3;
  *((_QWORD *)this + 3) = v1 + 4;
  return v2;
}

void IIOScanner::~IIOScanner(IIOScanner *this)
{
  void *v1;
  IIOImageRead **v2;

  *(_QWORD *)this = &off_1E1BAB4D8;
  if (*((_QWORD *)this + 1))
  {
    v1 = (void *)*((_QWORD *)this + 6);
    if (v1)
    {
      v2 = (IIOImageRead **)*((_QWORD *)this + 7);
      if (v2)
        IIOImageReadSession::releaseBytePointer(v2, v1);
    }
  }
}

{
  IIOScanner::~IIOScanner(this);
  JUMPOUT(0x18D761C30);
}

void IIOScanner::IIOScanner(IIOScanner *this, unsigned __int8 *a2, uint64_t a3, char a4)
{
  uint64_t v5;

  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *(_QWORD *)this = &off_1E1BAB4D8;
  *((_QWORD *)this + 1) = a2;
  if ((a3 & 0x800000000) != 0 || a2 == 0)
    v5 = 0;
  else
    v5 = a3;
  *((_QWORD *)this + 2) = v5;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_BYTE *)this + 68) = a4;
  *((_DWORD *)this + 16) = 0;
}

uint64_t IIOScanner::skip(uint64_t this, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  _DWORD *exception;

  v2 = *(_QWORD *)(this + 16);
  v3 = *(_QWORD *)(this + 24) + a2;
  if (v3 >= v2)
  {
    *(_QWORD *)(this + 24) = v2;
    v4 = this;
    LogError("skip", 415, "*** IIOScanner::skip reached EOF\n");
    *(_DWORD *)(v4 + 64) = -39;
    exception = __cxa_allocate_exception(4uLL);
    *exception = -39;
    __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
  }
  *(_QWORD *)(this + 24) = v3;
  return this;
}

void IIOImageReadSession::releaseBytePointer(IIOImageRead **this, void *a2)
{
  IIOImageRead::releaseBytePointer(this[4], a2);
}

unint64_t IIOScanner::seek(IIOScanner *this, unint64_t a2)
{
  unint64_t v2;
  _DWORD *exception;

  v2 = *((_QWORD *)this + 2);
  if (v2 <= a2)
  {
    *((_QWORD *)this + 3) = v2;
    LogError("seek", 431, "*** IIOScanner::seek reached EOF\n");
    *((_DWORD *)this + 16) = -39;
    exception = __cxa_allocate_exception(4uLL);
    *exception = -39;
    __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
  }
  *((_QWORD *)this + 3) = a2;
  *((_DWORD *)this + 16) = 0;
  return a2;
}

uint64_t ___ZN14IIO_Reader_ATX13getImageCountEP19IIOImageReadSessionP13IIODictionaryP19CGImageSourceStatusPj_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t result;
  uint64_t v6;
  _DWORD *v7;
  _DWORD *v8;
  _DWORD *v9;
  _OWORD v10[2];
  __int128 v11;
  __int128 v12;
  __int128 v13;
  int v14;
  uint64_t v15;

  result = 0;
  v15 = *MEMORY[0x1E0C80C00];
  if (a4 <= 1212498243)
  {
    if (a4 != 875704410 && a4 != 875704422 && a4 != 1095980099)
      return result;
    goto LABEL_13;
  }
  if (a4 == 1634956387 || a4 == 1280984659)
  {
LABEL_13:
    v8 = *(_DWORD **)(a1 + 40);
    if (v8)
    {
      result = 0;
      *v8 = 1;
      return result;
    }
    return 0;
  }
  if (a4 != 1212498244)
    return result;
  v14 = 0;
  v12 = 0u;
  v13 = 0u;
  v11 = 0u;
  memset(v10, 0, sizeof(v10));
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (!*(_BYTE *)(v6 + 24))
  {
    *(_BYTE *)(v6 + 24) = 1;
    IIOScanner::copyBytes(*(_QWORD **)(a1 + 48), v10, 0x54uLL);
    if (HIDWORD(v11))
    {
      v9 = *(_DWORD **)(a1 + 40);
      if (v9)
      {
        result = 0;
        *v9 = HIDWORD(v11);
        return result;
      }
    }
    return 0;
  }
  v7 = *(_DWORD **)(a1 + 40);
  if (v7)
    *v7 = 0;
  return 4294967246;
}

uint64_t ___ZN13ATXReadPlugin10initializeEP13IIODictionary_block_invoke(_QWORD *a1, uint64_t a2, int a3, int a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int Val32AtPosition;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;

  v6 = 0;
  v7 = a1[6];
  if (a4 <= 1212498243)
  {
    if (a4 == 875704410)
      goto LABEL_38;
    if (a4 != 875704422)
    {
      if (a4 == 1095980099)
      {
        if (*(_DWORD *)(v7 + 540))
        {
          _cg_jpeg_mem_term("initialize_block_invoke", 179, "*** ERROR: lzfseCompressed mismatch\n");
          return 4294967246;
        }
        *(_QWORD *)(v7 + 576) = a2;
        v14 = a1[7];
        v15 = a2 + 12;
        goto LABEL_27;
      }
      return v6;
    }
    if (*(_DWORD *)(v7 + 504) != 1714434612)
    {
      _cg_jpeg_mem_term("initialize_block_invoke", 233, "*** ERROR: bad _atxHeader.glInternalFormat 0x%08X\n");
      return 4294967246;
    }
    v9 = bswap32(IIOScanner::getVal32AtPosition((IIOScanner *)(*(_QWORD *)(a1[5] + 8) + 40), a2 + 8));
    if (v9 == 1128813133)
    {
      *(_QWORD *)(v7 + 608) = a2 + 24;
      *(_DWORD *)(v7 + 616) = IIOScanner::getVal32AtPosition((IIOScanner *)(*(_QWORD *)(a1[5] + 8) + 40), a2 + 12);
      *(_DWORD *)(v7 + 620) = IIOScanner::getVal32AtPosition((IIOScanner *)(*(_QWORD *)(a1[5] + 8) + 40), a2 + 16);
      Val32AtPosition = IIOScanner::getVal32AtPosition((IIOScanner *)(*(_QWORD *)(a1[5] + 8) + 40), a2 + 20);
      *(_DWORD *)(v7 + 624) = Val32AtPosition;
      if (Val32AtPosition < *(_DWORD *)(v7 + 616) || Val32AtPosition < *(_DWORD *)(v7 + 620))
      {
        _cg_jpeg_mem_term("initialize_block_invoke", 260, "*** ERROR: bad geometry %dx%d - rb: %d\n");
        goto LABEL_36;
      }
    }
    else if (v9 == 1280658753)
    {
      *(_QWORD *)(v7 + 584) = a2 + 24;
      *(_DWORD *)(v7 + 592) = IIOScanner::getVal32AtPosition((IIOScanner *)(*(_QWORD *)(a1[5] + 8) + 40), a2 + 12);
      *(_DWORD *)(v7 + 596) = IIOScanner::getVal32AtPosition((IIOScanner *)(*(_QWORD *)(a1[5] + 8) + 40), a2 + 16);
      v10 = IIOScanner::getVal32AtPosition((IIOScanner *)(*(_QWORD *)(a1[5] + 8) + 40), a2 + 20);
      *(_DWORD *)(v7 + 600) = v10;
      if (v10 < *(_DWORD *)(v7 + 592) || v10 < *(_DWORD *)(v7 + 596))
      {
        _cg_jpeg_mem_term("initialize_block_invoke", 248, "*** ERROR: bad geometry %dx%d - rb: %d\n");
LABEL_36:
        v6 = 4294967246;
        goto LABEL_38;
      }
    }
    v6 = 0;
LABEL_38:
    if (*(_DWORD *)(v7 + 504) == 1714434612)
    {
      v20 = bswap32(IIOScanner::getVal32AtPosition((IIOScanner *)(*(_QWORD *)(a1[5] + 8) + 40), a2 + 8));
      if (v20 == 1667789421)
      {
        *(_BYTE *)(v7 + 632) = 1;
        *(_QWORD *)(v7 + 608) = a2 + 24;
        *(_DWORD *)(v7 + 616) = IIOScanner::getVal32AtPosition((IIOScanner *)(*(_QWORD *)(a1[5] + 8) + 40), a2 + 12);
        *(_DWORD *)(v7 + 620) = IIOScanner::getVal32AtPosition((IIOScanner *)(*(_QWORD *)(a1[5] + 8) + 40), a2 + 16);
        *(_DWORD *)(v7 + 624) = IIOScanner::getVal32AtPosition((IIOScanner *)(*(_QWORD *)(a1[5] + 8) + 40), a2 + 20);
        *(_DWORD *)(v7 + 628) = IIOScanner::getVal32AtPosition((IIOScanner *)(*(_QWORD *)(a1[5] + 8) + 40), a2 + 28);
        v22 = *(_DWORD *)(v7 + 624);
        if (v22 >= *(_DWORD *)(v7 + 616) && v22 >= *(_DWORD *)(v7 + 620))
          return v6;
        _cg_jpeg_mem_term("initialize_block_invoke", 303, "*** ERROR: bad geometry %dx%d - rb: %d\n");
      }
      else
      {
        if (v20 != 1819635041)
          return v6;
        *(_BYTE *)(v7 + 632) = 1;
        *(_QWORD *)(v7 + 584) = a2 + 24;
        *(_DWORD *)(v7 + 592) = IIOScanner::getVal32AtPosition((IIOScanner *)(*(_QWORD *)(a1[5] + 8) + 40), a2 + 12);
        *(_DWORD *)(v7 + 596) = IIOScanner::getVal32AtPosition((IIOScanner *)(*(_QWORD *)(a1[5] + 8) + 40), a2 + 16);
        *(_DWORD *)(v7 + 600) = IIOScanner::getVal32AtPosition((IIOScanner *)(*(_QWORD *)(a1[5] + 8) + 40), a2 + 20);
        *(_DWORD *)(v7 + 604) = IIOScanner::getVal32AtPosition((IIOScanner *)(*(_QWORD *)(a1[5] + 8) + 40), a2 + 28);
        v21 = *(_DWORD *)(v7 + 600);
        if (v21 >= *(_DWORD *)(v7 + 592) && v21 >= *(_DWORD *)(v7 + 596))
          return v6;
        _cg_jpeg_mem_term("initialize_block_invoke", 289, "*** ERROR: bad geometry %dx%d - rb: %d\n");
      }
    }
    else
    {
      _cg_jpeg_mem_term("initialize_block_invoke", 273, "*** ERROR: bad _atxHeader.glInternalFormat 0x%08X\n");
    }
    return 4294967246;
  }
  switch(a4)
  {
    case 1634956387:
      if (*(_DWORD *)(v7 + 540))
      {
        _cg_jpeg_mem_term("initialize_block_invoke", 212, "*** ERROR: lzfseCompressed mismatch\n");
        return 4294967246;
      }
      *(_QWORD *)(v7 + 576) = a2;
      ASTCTextureImp::setInputIsPreTwiddled(a1[7], 1);
      ASTCTextureImp::setTextureBaseOffset(a1[7], a2 + 12);
      v16 = IIOScanner::getVal32AtPosition((IIOScanner *)(*(_QWORD *)(a1[5] + 8) + 40), a2 + 8);
      ASTCTextureImp::setLock_blockSize(a1[7], v16);
      ASTCTextureImp::setLock_dataSize(a1[7], v16);
      ASTCTextureImp::setLock_blockOffset(a1[7], 0);
      return 0;
    case 1280984659:
      if (!*(_DWORD *)(v7 + 540))
      {
        _cg_jpeg_mem_term("initialize_block_invoke", 194, "*** ERROR: lzfseCompressed mismatch\n");
        return 4294967246;
      }
      ASTCTextureImp::setInputIsLZFSECompressed(a1[7], 1);
      v12 = a1[7];
      v13 = IIOScanner::getVal32AtPosition((IIOScanner *)(*(_QWORD *)(a1[5] + 8) + 40), a2 + 8);
      ASTCTextureImp::setCompressedLZFSESize(v12, v13);
      ASTCTextureImp::setCompressedLZFSEDataOffset(a1[7], a2 + 12);
      *(_QWORD *)(v7 + 576) = a2;
      v14 = a1[7];
      v15 = a2;
LABEL_27:
      ASTCTextureImp::setTextureBaseOffset(v14, v15);
      return 0;
    case 1212498244:
      v8 = *(_QWORD *)(a1[4] + 8);
      if (!*(_BYTE *)(v8 + 24))
      {
        *(_BYTE *)(v8 + 24) = 1;
        return ATXReadPlugin::readHeader((ATXReadPlugin *)v7, (IIOScanner *)(*(_QWORD *)(a1[5] + 8) + 40), a3);
      }
      _cg_jpeg_mem_term("initialize_block_invoke", 162, "*** ERROR: found multiple headers in ATX file\n");
      return 4294967246;
  }
  return v6;
}

_QWORD *IIOScanner::copyBytes(_QWORD *this, void *__dst, size_t a3)
{
  uint64_t v3;

  v3 = this[3];
  if (v3 + a3 < this[2])
    return memcpy(__dst, (const void *)(this[1] + v3), a3);
  return this;
}

uint64_t IIOScanner::getVal32AtPosition(IIOScanner *this, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  _DWORD *exception;

  if ((unint64_t)(a2 + 3) >= *((_QWORD *)this + 2))
  {
    LogError("getVal32AtPosition", 274, "*** IIOScanner::getVal32AtPosition reached EOF\n");
    *((_DWORD *)this + 16) = -39;
    exception = __cxa_allocate_exception(4uLL);
    *exception = -39;
    __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
  }
  v2 = *(_DWORD *)(*((_QWORD *)this + 1) + a2);
  v3 = bswap32(v2);
  if (*((_BYTE *)this + 68))
    return v2;
  else
    return v3;
}

uint64_t ASTCTextureImp::setTextureBaseOffset(uint64_t this, uint64_t a2)
{
  *(_QWORD *)(this + 112) = a2;
  return this;
}

uint64_t ATXReadPlugin::readHeader(ATXReadPlugin *this, IIOScanner *a2, int a3)
{
  int8x16_t v4;
  int8x16_t v5;
  int8x16_t v6;
  uint8x8_t v7;

  if (a3 != 84)
    return 4294967246;
  IIOScanner::copyBytes(a2, (char *)this + 488, 0x54uLL);
  if (*((_DWORD *)this + 122) != 1)
  {
    _cg_jpeg_mem_term("readHeader", 65, "*** ERROR: unsupported ATX version [%d]\n");
    return 4294967246;
  }
  if ((*((_DWORD *)this + 130) - 33) <= 0xFFFFFFDF)
  {
    _cg_jpeg_mem_term("readHeader", 66, "*** ERROR: unsupported ATX pixelDepth [%d]\n");
    return 4294967246;
  }
  if (*((_DWORD *)this + 136) > 8u)
  {
    _cg_jpeg_mem_term("readHeader", 67, "*** ERROR: unsupported ATX orientation [%d]\n");
    return 4294967246;
  }
  v4.i64[0] = 0x5555555555555555;
  v4.i64[1] = 0x5555555555555555;
  v5 = vceqq_s8(*(int8x16_t *)((char *)this + 548), v4);
  v4.i8[1] = 2;
  v6 = vandq_s8(v5, (int8x16_t)xmmword_188210E80);
  v4.i8[0] = vaddv_s8(*(int8x8_t *)v6.i8);
  v6.i64[0] = vextq_s8(v6, v6, 8uLL).u64[0];
  v6.i8[0] = vaddv_s8(*(int8x8_t *)v6.i8);
  v6.i32[0] = (unsigned __int16)(v4.i16[0] | (v6.i16[0] << 8));
  v7 = (uint8x8_t)vcnt_s8(*(int8x8_t *)v6.i8);
  v7.i16[0] = vaddlv_u8(v7);
  if (v7.i32[0] >= 4u && v7.i32[0] != 16)
  {
    _cg_jpeg_mem_term("readHeader", 75, "*** ERROR: invalid watermark [%d]\n");
    return 4294967246;
  }
  if (*((_DWORD *)this + 142) >= 7u)
  {
    _cg_jpeg_mem_term("readHeader", 77, "*** ERROR: unsupported alpha [%d]\n");
    return 4294967246;
  }
  return 0;
}

uint64_t ASTCTextureImp::setCompressedLZFSEDataOffset(uint64_t this, uint64_t a2)
{
  *(_QWORD *)(this + 48) = a2;
  return this;
}

uint64_t ASTCTextureImp::setInputIsLZFSECompressed(uint64_t this, char a2)
{
  *(_BYTE *)(this + 40) = a2;
  return this;
}

uint64_t ASTCTextureImp::setCompressedLZFSESize(uint64_t this, int a2)
{
  *(_DWORD *)(this + 44) = a2;
  return this;
}

unint64_t IIOScanner::getIFDCount(IIOScanner *this)
{
  if (*((_DWORD *)this + 8) == 4)
    return IIOScanner::getVal16(this);
  else
    return IIOScanner::getVal64(this);
}

size_t IIOScanner::getBytesAtOffset(IIOScanner *this, void *__dst, uint64_t a3, size_t __n)
{
  size_t v4;

  if (__n + a3 > *((_QWORD *)this + 2))
    return 0;
  v4 = __n;
  memcpy(__dst, (const void *)(*((_QWORD *)this + 1) + a3), __n);
  return v4;
}

uint64_t ASTCTextureImp::isInputLZFSECompressed(ASTCTextureImp *this)
{
  return *((unsigned __int8 *)this + 40);
}

int8x16_t SwapKTXHeader(int8x16_t *a1)
{
  int8x16_t v1;
  int8x16_t result;

  if (a1->i32[3] != 67305985)
  {
    v1 = vrev32q_s8(a1[2]);
    a1[1] = vrev32q_s8(a1[1]);
    a1[2] = v1;
    result = vrev32q_s8(a1[3]);
    a1[3] = result;
  }
  return result;
}

uint64_t ASTCTextureImp::needs_hdr(ASTCTextureImp *this)
{
  return *((unsigned __int8 *)this + 42);
}

uint64_t ASTCTextureImp::GetXYdimFromMetalFormat(uint64_t this, _BYTE *a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  int v4;
  char v5;
  unsigned __int8 v6;

  v4 = this - 186;
  if ((this - 186) > 0x32)
  {
    v5 = 0;
    v6 = 0;
  }
  else
  {
    v5 = byte_1882118D8[v4];
    v6 = byte_18821190B[v4];
  }
  *a2 = v5;
  *a3 = v6;
  return this;
}

uint64_t ASTCTextureImp::setInputIsPreTwiddled(uint64_t this, char a2)
{
  *(_BYTE *)(this + 41) = a2;
  return this;
}

uint64_t ASTCTextureImp::setLock_blockOffset(uint64_t this, uint64_t a2)
{
  *(_QWORD *)(this + 152) = a2;
  return this;
}

uint64_t ASTCTextureImp::setLock_blockSize(uint64_t this, uint64_t a2)
{
  *(_QWORD *)(this + 160) = a2;
  return this;
}

uint64_t ASTCTextureImp::setLock_dataSize(uint64_t this, uint64_t a2)
{
  *(_QWORD *)(this + 144) = a2;
  return this;
}

uint64_t ASTCTwiddler::getWatermark(ASTCTwiddler *this, unsigned __int8 *a2)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v5;

  v2 = *((_QWORD *)this + 1);
  if (!v2)
    return 0;
  result = *(_QWORD *)(v2 + 56);
  if (result)
  {
    *(_QWORD *)a2 = objc_msgSend((id)result, "watermark");
    *((_QWORD *)a2 + 1) = v5;
    return 1;
  }
  return result;
}

void imageio_key_release(void *a1, void *a2)
{
  if ((gIIODebugFlags & 0x200) != 0)
    ImageIOLog("    imageio_key_release    key: %p   user_data: %p\n", a1, a2);
  free(a1);
}

void RDF_Parser::ResourcePropertyElement(RDF_Parser *this, XMP_Node *a2, const XML_Node *a3, int a4)
{
  char *v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v11;
  XMP_Node *v12;
  const XML_Node **v13;
  const XML_Node **i;
  const XML_Node *v15;
  _QWORD *v16;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  XML_Node **v22;
  XML_Node **v23;
  XML_Node *v24;
  int **v25;
  int v26;
  BOOL v28;
  int *v29;
  int v30;
  int v31;
  int v33;
  const char *v34;
  XML_Node *v37;
  std::string::size_type v38;
  std::string::size_type v39;
  _QWORD *v40;
  uint64_t v41;
  int v42;
  XML_Node **v43;
  XML_Node *v44;
  void *__p[2];
  uint64_t v46;
  std::string v47;

  if (a4)
  {
    v6 = (char *)a3 + 40;
    v7 = *((char *)a3 + 63);
    if (v7 < 0)
    {
      if (*((_QWORD *)a3 + 6) != 10)
        goto LABEL_11;
      v6 = *(char **)v6;
    }
    else if (v7 != 10)
    {
      goto LABEL_11;
    }
    v8 = *(_QWORD *)v6;
    v9 = *((unsigned __int16 *)v6 + 4);
    if (v8 == 0x676E6168633A5869 && v9 == 29541)
      return;
  }
LABEL_11:
  v11 = RDF_Parser::AddChildNode(this, a2, a3, "", a4);
  if (!v11)
    return;
  v12 = (XMP_Node *)v11;
  v13 = (const XML_Node **)*((_QWORD *)a3 + 13);
  for (i = (const XML_Node **)*((_QWORD *)a3 + 14); v13 != i; ++v13)
  {
    v15 = *v13;
    v16 = (_QWORD *)((char *)*v13 + 40);
    if (*((char *)*v13 + 63) < 0)
    {
      v18 = *((_QWORD *)v15 + 6);
      if (v18 == 6)
      {
        v16 = (_QWORD *)*v16;
LABEL_23:
        v19 = *(_DWORD *)v16;
        v20 = *((unsigned __int16 *)v16 + 2);
        if (v19 == 979788914 && v20 == 17481)
          continue;
        goto LABEL_27;
      }
      if (v18 == 8 && *(_QWORD *)*v16 == 0x676E616C3A6C6D78)
      {
LABEL_30:
        RDF_Parser::AddQualifierNode(this, v12, v15);
        continue;
      }
    }
    else
    {
      v17 = *((unsigned __int8 *)*v13 + 63);
      if (v17 == 6)
        goto LABEL_23;
      if (v17 == 8 && *v16 == 0x676E616C3A6C6D78)
        goto LABEL_30;
    }
LABEL_27:
    *(_OWORD *)&v47.__r_.__value_.__r.__words[1] = (unint64_t)"Invalid attribute for resource property element";
    v47.__r_.__value_.__r.__words[0] = 202;
    GenericErrorCallback::NotifyClient(*(_QWORD *)this, 0, (unsigned int *)&v47, 0);
  }
  v23 = (XML_Node **)*((_QWORD *)a3 + 16);
  v22 = (XML_Node **)*((_QWORD *)a3 + 17);
  if (v23 != v22)
  {
    while (XML_Node::IsWhitespaceNode(*v23))
    {
      if (++v23 == v22)
        goto LABEL_53;
    }
  }
  if (v23 == v22)
  {
LABEL_53:
    v47.__r_.__value_.__r.__words[2] = 0;
    v34 = "Missing child of resource property element";
LABEL_90:
    v47.__r_.__value_.__l.__size_ = (std::string::size_type)v34;
    v47.__r_.__value_.__r.__words[0] = 202;
    GenericErrorCallback::NotifyClient(*(_QWORD *)this, 0, (unsigned int *)&v47, 0);
    return;
  }
  v24 = *v23;
  if (*((_BYTE *)*v23 + 8) != 1)
  {
    v47.__r_.__value_.__r.__words[2] = 0;
    v34 = "Children of resource property element must be XML elements";
    goto LABEL_90;
  }
  v25 = (int **)((char *)v24 + 40);
  v26 = *((char *)v24 + 63);
  if ((v26 & 0x80000000) == 0)
  {
    if (v26 != 7)
      goto LABEL_66;
    if (*(_DWORD *)v25 != 979788914 || *(_DWORD *)((char *)v24 + 43) != 1734427194)
    {
      v28 = *(_DWORD *)v25 == 979788914 && *(_DWORD *)((char *)v24 + 43) == 1902465850;
      v29 = (int *)((char *)v24 + 40);
      if (!v28)
        goto LABEL_47;
LABEL_65:
      v33 = *((_DWORD *)v12 + 2) | 0x600;
      goto LABEL_70;
    }
LABEL_69:
    v33 = *((_DWORD *)v12 + 2) | 0x200;
    goto LABEL_70;
  }
  if (*((_QWORD *)v24 + 6) != 7)
    goto LABEL_66;
  v29 = *v25;
  if (**v25 == 979788914 && *(int *)((char *)*v25 + 3) == 1734427194)
    goto LABEL_69;
  if (*v29 == 979788914 && *(int *)((char *)v29 + 3) == 1902465850)
    goto LABEL_65;
LABEL_47:
  v30 = *v29;
  v31 = *(int *)((char *)v29 + 3);
  if (v30 == 979788914 && v31 == 1953251642)
  {
    v33 = *((_DWORD *)v12 + 2) | 0xE00;
LABEL_70:
    *((_DWORD *)v12 + 2) = v33;
    goto LABEL_82;
  }
LABEL_66:
  if (std::operator!=[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v25, "rdf:Description"))
  {
    memset(&v47, 0, sizeof(v47));
    v37 = *v23;
    if (*((char *)*v23 + 39) < 0)
      std::string::__init_copy_ctor_external(&v47, *((const std::string::value_type **)v37 + 2), *((_QWORD *)v37 + 3));
    else
      v47 = *(std::string *)((char *)v37 + 16);
    v38 = std::string::find((const std::string *)((char *)*v23 + 40), 58, 0);
    v39 = v38;
    if (v38 == -1)
    {
      __p[0] = (void *)203;
      __p[1] = "All XML elements must be in a namespace";
      v46 = 0;
      GenericErrorCallback::NotifyClient(*(_QWORD *)this, 0, (unsigned int *)__p, 0);
    }
    else
    {
      std::string::append(&v47, (const std::string *)((char *)*v23 + 40), v38 + 1, 0xFFFFFFFFFFFFFFFFLL);
      v40 = std::string::basic_string[abi:ne180100]<0>(__p, "rdf:type");
      v41 = RDF_Parser::AddQualifierNode((uint64_t)v40, (uint64_t)v12, (uint64_t)__p, (__int128 *)&v47);
      if (SHIBYTE(v46) < 0)
        operator delete(__p[0]);
      if (v41)
        *(_DWORD *)(v41 + 8) |= 2u;
    }
    if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v47.__r_.__value_.__l.__data_);
    if (v39 == -1)
      return;
  }
  *((_DWORD *)v12 + 2) |= 0x100u;
  v24 = *v23;
LABEL_82:
  RDF_Parser::NodeElement(this, v12, v24, 0);
  v42 = *((_DWORD *)v12 + 2);
  if ((v42 & 0x10000000) != 0)
  {
    RDF_Parser::FixupQualifiedNode(this, v12);
  }
  else if ((v42 & 0x800) != 0)
  {
    DetectAltText((std::string *)v12);
  }
  v43 = v23 + 1;
  while (v43 != v22)
  {
    v44 = *v43++;
    if (!XML_Node::IsWhitespaceNode(v44))
    {
      v47.__r_.__value_.__r.__words[2] = 0;
      v34 = "Invalid child of resource property element";
      goto LABEL_90;
    }
  }
}

void sub_187E79364(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void WXMPMeta_ParseFromBuffer_1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  XMP_ReadWriteLock *v10;

  v10 = (XMP_ReadWriteLock *)(a1 + 16);
  XMP_ReadWriteLock::Acquire((pthread_rwlock_t *)(a1 + 16), 1);
  *a5 = 0;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 200))(a1, a2, a3, a4);
  XMP_AutoLock::~XMP_AutoLock(&v10);
}

uint64_t XMPMeta::ParseFromBuffer(XMPMeta *this, char *__s1, unsigned int a3, char a4)
{
  unsigned int v5;
  int v8;
  uint64_t result;
  ExpatAdapter *v10;
  char v11;
  uint64_t v12;
  _QWORD *exception;

  v5 = a3;
  if (!__s1 && a3)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 4;
    exception[1] = "Null parse buffer";
    *((_BYTE *)exception + 16) = 0;
  }
  if (a3 == -1)
  {
    if (__s1)
    {
      v12 = 0;
      v5 = -1;
      while (__s1[v12])
      {
        if (++v12 == 0xFFFFFFFFLL)
          goto LABEL_4;
      }
      v5 = v12;
    }
    else
    {
      v5 = 0;
    }
  }
LABEL_4:
  v8 = a4 & 2;
  if (!*((_QWORD *)this + 43))
  {
    result = (uint64_t)XMP_Node::ClearNode((XMPMeta *)((char *)this + 224));
    if (!(v5 | v8))
      return result;
    v10 = XMP_NewExpatAdapter(1);
    *((_QWORD *)this + 43) = v10;
    (*(void (**)(ExpatAdapter *, char *))(*(_QWORD *)v10 + 24))(v10, (char *)this + 352);
  }
  result = XMPMeta::ProcessXMLBuffer(this, __s1, v5, v8 == 0);
  if (v8)
    v11 = 0;
  else
    v11 = result;
  if ((v11 & 1) != 0)
  {
    XMPMeta::ProcessXMLTree(this, a4);
    result = *((_QWORD *)this + 43);
    if (result)
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
    *((_QWORD *)this + 43) = 0;
  }
  return result;
}

void sub_187E795FC(void *a1)
{
  uint64_t v1;
  uint64_t v2;

  __cxa_begin_catch(a1);
  v2 = *(_QWORD *)(v1 + 344);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  *(_QWORD *)(v1 + 344) = 0;
  __cxa_rethrow();
}

void sub_187E79620(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

_QWORD *XMP_Node::ClearNode(XMP_Node *this)
{
  *((_DWORD *)this + 2) = 0;
  std::string::erase((std::string *)((char *)this + 16), 0, 0xFFFFFFFFFFFFFFFFLL);
  std::string::erase((std::string *)((char *)this + 40), 0, 0xFFFFFFFFFFFFFFFFLL);
  XMP_Node::RemoveChildren(this);
  return XMP_Node::RemoveQualifiers(this);
}

uint64_t XMPMeta::ProcessXMLBuffer(XMPMeta *this, char *__s1, unsigned int a3, uint64_t a4)
{
  unsigned int v5;
  char *v6;
  uint64_t v8;
  int v9;
  uint64_t v10;
  unint64_t v11;
  const unsigned __int8 *v12;
  size_t v13;
  size_t v14;
  size_t v15;
  unint64_t v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  size_t v20;
  unint64_t v21;
  size_t v22;
  uint64_t result;
  _QWORD *exception;

  v5 = a3;
  v6 = __s1;
  v8 = *((_QWORD *)this + 43);
  v9 = *(_DWORD *)(v8 + 200);
  if (v9 == -1)
  {
    v10 = *(_QWORD *)(v8 + 208);
    if (a3 < 0x10 || v10)
    {
      if (16 - v10 >= (unint64_t)a3)
        v13 = a3;
      else
        v13 = 16 - v10;
      memcpy((void *)(v8 + v10 + 216), __s1, v13);
      v11 = *(_QWORD *)(v8 + 208) + v13;
      *(_QWORD *)(v8 + 208) = v11;
      if ((a4 & 1) == 0 && v11 < 0x10)
        return 0;
      v5 -= v13;
      v6 += v13;
      v12 = (const unsigned __int8 *)(v8 + 216);
    }
    else
    {
      v11 = a3;
      v12 = (const unsigned __int8 *)v6;
    }
    v9 = DetermineInputEncoding(v12, v11);
    *(_DWORD *)(v8 + 200) = v9;
  }
  v14 = *(_QWORD *)(v8 + 208);
  if (v9)
  {
    if (v14)
      (*(void (**)(uint64_t, uint64_t, size_t, _QWORD))(*(_QWORD *)v8 + 16))(v8, v8 + 216, v14, 0);
    (*(void (**)(uint64_t, char *, _QWORD, uint64_t))(*(_QWORD *)v8 + 16))(v8, v6, v5, a4);
    return 1;
  }
  if (!v14)
  {
LABEL_30:
    v21 = ProcessUTF8Portion(*((XMLParserAdapter **)this + 43), v6, v5, a4);
    v22 = v5 - v21;
    if (v5 > v21)
    {
      if ((_DWORD)a4)
        XMPMeta::ProcessXMLBuffer();
      if (v22 >= 0x11)
      {
        exception = __cxa_allocate_exception(0x18uLL);
        *(_DWORD *)exception = 9;
        exception[1] = "Parser bytesLeft too large";
        *((_BYTE *)exception + 16) = 0;
      }
      memcpy((void *)(v8 + 216), &v6[v21], v22);
      result = 0;
      *(_QWORD *)(v8 + 208) = v22;
      return result;
    }
    return 1;
  }
  while (1)
  {
    if (16 - v14 >= v5)
      v15 = v5;
    else
      v15 = 16 - v14;
    memcpy((void *)(v8 + v14 + 216), v6, v15);
    v16 = *(_QWORD *)(v8 + 208) + v15;
    *(_QWORD *)(v8 + 208) = v16;
    if ((a4 & 1) == 0 && v16 < 0x10)
      return 0;
    v17 = v5 - v15;
    v18 = ProcessUTF8Portion(*((XMLParserAdapter **)this + 43), (char *)(v8 + 216), v16, a4);
    v19 = *(_QWORD *)(v8 + 208);
    v20 = v19 - v18;
    if (v19 == v18)
    {
      v6 += v15;
LABEL_29:
      *(_QWORD *)(v8 + 208) = 0;
      v5 = v17;
      goto LABEL_30;
    }
    if (v20 <= v15)
    {
      v6 = &v6[v15 - v20];
      v17 += v20;
      goto LABEL_29;
    }
    if (!v17)
      break;
    v14 = v19 - v15;
    *(_QWORD *)(v8 + 208) = v19 - v15;
    if (v19 == v15)
      goto LABEL_30;
  }
  if ((_DWORD)a4)
    XMPMeta::ProcessXMLBuffer();
  *(_QWORD *)(v8 + 208) = v20;
  memcpy((void *)(v8 + 216), (const void *)(v8 + v18 + 216), v20);
  return 0;
}

void XMPMeta::ProcessXMLTree(XMPMeta *this, char a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  XMPMeta::ErrorCallbackInfo *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  int v21;
  BOOL v22;
  uint64_t *v23;
  int v24;
  BOOL v25;

  v4 = (_QWORD *)*((_QWORD *)this + 43);
  if (v4[24] < 2uLL)
  {
    v5 = v4[23];
    if (!v5)
      return;
  }
  else
  {
    v5 = PickBestRoot((const XML_Node *)(v4 + 1), a2);
    if (!v5)
      return;
  }
  v6 = v5 + 40;
  v7 = *(char *)(v5 + 63);
  if (v7 < 0)
  {
    if (*(_QWORD *)(v5 + 48) != 7)
      goto LABEL_42;
    v6 = *(_QWORD *)v6;
  }
  else if (v7 != 7)
  {
    goto LABEL_42;
  }
  v8 = *(_DWORD *)v6;
  v9 = *(_DWORD *)(v6 + 3);
  if (v8 != 979788914 || v9 != 1178882618)
LABEL_42:
    XMPMeta::ProcessXMLTree();
  if ((a2 & 1) == 0)
    goto LABEL_16;
  v19 = *(_QWORD *)(v5 + 96);
  if (!v19)
    return;
  v20 = (uint64_t *)(v19 + 40);
  v21 = *(char *)(v19 + 63);
  if (v21 < 0)
  {
    if (*(_QWORD *)(v19 + 48) != 9)
      return;
    v20 = (uint64_t *)*v20;
  }
  else if (v21 != 9)
  {
    return;
  }
  v22 = *v20 == 0x74656D706D783A78 && *((_BYTE *)v20 + 8) == 97;
  if (v22
    || ((v23 = (uint64_t *)*v20, v24 = *((unsigned __int8 *)v20 + 8), v23 == (uint64_t *)0x74656D7061783A78)
      ? (v25 = v24 == 97)
      : (v25 = 0),
        v25))
  {
LABEL_16:
    XMPMeta::ProcessRDF((size_t *)this, (const XML_Node *)v5);
    NormalizeDCArrays((char **)this + 28);
    if ((*((_BYTE *)this + 234) & 2) != 0)
      MoveExplicitAliases((XMPMeta *)((char *)this + 224), a2, (XMPMeta *)((char *)this + 352));
    TouchUpDataModel(this, v11);
    v12 = *((_QWORD *)this + 37);
    v13 = *((_QWORD *)this + 38);
    if (v13 != v12)
    {
      v14 = 0;
      do
      {
        v15 = *(_QWORD **)(v12 + 8 * v14);
        if (v15[10] == v15[9])
        {
          (*(void (**)(_QWORD *))(*v15 + 8))(v15);
          v12 = *((_QWORD *)this + 37);
          v16 = *((_QWORD *)this + 38);
          v17 = v12 + 8 * v14;
          v18 = v16 - (v17 + 8);
          if (v16 != v17 + 8)
          {
            memmove((void *)(v12 + 8 * v14), (const void *)(v17 + 8), v16 - (v17 + 8));
            v12 = *((_QWORD *)this + 37);
          }
          v13 = v17 + v18;
          *((_QWORD *)this + 38) = v17 + v18;
        }
        else
        {
          ++v14;
        }
      }
      while (v14 < (v13 - v12) >> 3);
    }
  }
}

void XMPMeta::ProcessRDF(size_t *this, const XML_Node *a2)
{
  char *v2;

  v2 = (char *)(this + 44);
  RDF_Parser::RDF((RDF *)&v2, this + 28, a2);
}

uint64_t XMLParserAdapter::SetErrorCallback(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 232) = a2;
  return result;
}

void ExpatAdapter::~ExpatAdapter(ExpatAdapter *this)
{
  ExpatAdapter::~ExpatAdapter(this);
  JUMPOUT(0x18D761C30);
}

{
  XML_ParserStruct *v2;
  uint64_t v3;
  BOOL v4;

  *(_QWORD *)this = &off_1E1BAC1B8;
  v2 = (XML_ParserStruct *)*((_QWORD *)this + 31);
  if (v2)
    XML_ParserFree(v2);
  *((_QWORD *)this + 31) = 0;
  v3 = *((_QWORD *)this + 32);
  if (v3)
    v4 = v3 == sRegisteredNamespaces;
  else
    v4 = 1;
  if (!v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  *((_QWORD *)this + 32) = 0;
  XMLParserAdapter::~XMLParserAdapter(this);
}

uint64_t XMPIterator::Terminate(XMPIterator *this)
{
  uint64_t result;

  result = sDummySchema;
  if (sDummySchema)
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)sDummySchema + 8))(sDummySchema);
  sDummySchema = 0;
  return result;
}

void XMP_Node::~XMP_Node(XMP_Node *this)
{
  XMP_Node::~XMP_Node(this);
  JUMPOUT(0x18D761C30);
}

{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_1E1BB2CB8;
  XMP_Node::RemoveChildren(this);
  XMP_Node::RemoveQualifiers(this);
  v2 = (void *)*((_QWORD *)this + 12);
  if (v2)
  {
    *((_QWORD *)this + 13) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 9);
  if (v3)
  {
    *((_QWORD *)this + 10) = v3;
    operator delete(v3);
  }
  if (*((char *)this + 63) < 0)
    operator delete(*((void **)this + 5));
  if (*((char *)this + 39) < 0)
    operator delete(*((void **)this + 2));
}

_QWORD *XMP_Node::RemoveQualifiers(_QWORD *this)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v1 = this;
  v2 = this[13];
  v3 = v2 - this[12];
  if (v3)
  {
    v4 = 0;
    if ((unint64_t)(v3 >> 3) <= 1)
      v5 = 1;
    else
      v5 = v3 >> 3;
    do
    {
      this = *(_QWORD **)(v1[12] + 8 * v4);
      if (this)
        this = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*this + 8))(this);
      ++v4;
    }
    while (v5 != v4);
    v2 = v1[12];
  }
  v1[13] = v2;
  return this;
}

_QWORD *XMP_Node::RemoveChildren(_QWORD *this)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v1 = this;
  v2 = this[10];
  v3 = v2 - this[9];
  if (v3)
  {
    v4 = 0;
    if ((unint64_t)(v3 >> 3) <= 1)
      v5 = 1;
    else
      v5 = v3 >> 3;
    do
    {
      this = *(_QWORD **)(v1[9] + 8 * v4);
      if (this)
        this = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*this + 8))(this);
      ++v4;
    }
    while (v5 != v4);
    v2 = v1[9];
  }
  v1[10] = v2;
  return this;
}

void RDF_Parser::RDF(RDF *this, size_t *a2, const XML_Node *a3)
{
  _QWORD v6[3];

  if (*((_QWORD *)a3 + 13) != *((_QWORD *)a3 + 14))
  {
    v6[0] = 202;
    v6[1] = "Invalid attributes of rdf:RDF element";
    v6[2] = 0;
    GenericErrorCallback::NotifyClient(*(_QWORD *)this, 0, (unsigned int *)v6, 0);
  }
  RDF_Parser::NodeElementList(this, a2, a3, 1);
}

void RDF_Parser::NodeElementList(RDF_Parser *this, size_t *a2, const XML_Node *a3, char a4)
{
  const XML_Node **v4;
  const XML_Node **i;

  if ((a4 & 1) == 0)
    RDF_Parser::NodeElementList();
  v4 = (const XML_Node **)*((_QWORD *)a3 + 16);
  for (i = (const XML_Node **)*((_QWORD *)a3 + 17); v4 != i; ++v4)
  {
    if (!XML_Node::IsWhitespaceNode(*v4))
      RDF_Parser::NodeElement(this, a2, *v4, 1);
  }
}

void RDF_Parser::PropertyElementList(RDF_Parser *this, XMP_Node *a2, const XML_Node *a3, int a4)
{
  const XML_Node **v4;
  const XML_Node **i;
  _QWORD v9[3];

  v4 = (const XML_Node **)*((_QWORD *)a3 + 16);
  for (i = (const XML_Node **)*((_QWORD *)a3 + 17); v4 != i; ++v4)
  {
    if (!XML_Node::IsWhitespaceNode(*v4))
    {
      if (*((_BYTE *)*v4 + 8) == 1)
      {
        RDF_Parser::PropertyElement(this, a2, *v4, a4);
      }
      else
      {
        v9[1] = "Expected property element node not found";
        v9[2] = 0;
        v9[0] = 202;
        GenericErrorCallback::NotifyClient(*(_QWORD *)this, 0, (unsigned int *)v9, 0);
      }
    }
  }
}

BOOL XML_Node::IsWhitespaceNode(XML_Node *this)
{
  unint64_t i;
  unint64_t v2;
  BOOL v3;
  _BOOL8 v4;
  char *v5;
  unsigned int v6;
  BOOL v7;
  uint64_t v8;

  if (*((_BYTE *)this + 8) != 3)
    return 0;
  for (i = 0; ; ++i)
  {
    v2 = *((unsigned __int8 *)this + 87);
    if ((*((_BYTE *)this + 87) & 0x80) != 0)
      v2 = *((_QWORD *)this + 9);
    v3 = i >= v2;
    v4 = i >= v2;
    if (v3)
      break;
    v5 = (char *)this + 64;
    if ((*((_BYTE *)this + 87) & 0x80) != 0)
      v5 = (char *)*((_QWORD *)this + 8);
    v6 = v5[i];
    v7 = v6 > 0x20;
    v8 = (1 << v6) & 0x100002600;
    if (v7 || v8 == 0)
      break;
  }
  return v4;
}

void RDF_Parser::PropertyElement(RDF_Parser *this, XMP_Node *a2, const XML_Node *a3, int a4)
{
  unsigned int RDFTermKind;
  unsigned int v10;
  const char *v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v18;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int **v26;
  int v27;
  int *v28;
  int v31;
  int v32;
  _QWORD v34[2];
  uint64_t v35;

  RDFTermKind = GetRDFTermKind((uint64_t)a3 + 40);
  if (RDFTermKind > 9 || RDFTermKind - 9 >= 0xFFFFFFF8)
  {
    v35 = 0;
    v10 = 202;
    v11 = "Invalid property element name";
    goto LABEL_7;
  }
  v13 = (uint64_t *)*((_QWORD *)a3 + 13);
  v12 = (uint64_t *)*((_QWORD *)a3 + 14);
  if ((unint64_t)((char *)v12 - (char *)v13) > 0x18)
    goto LABEL_9;
  if (v13 == v12)
  {
LABEL_29:
    v20 = *((_QWORD *)a3 + 16);
    v21 = *((_QWORD *)a3 + 17);
    if (v20 == v21)
      goto LABEL_9;
    while (*(_BYTE *)(*(_QWORD *)v20 + 8) == 3)
    {
      v20 += 8;
      if (v20 == v21)
        goto LABEL_60;
    }
    if (v20 != v21)
    {
      RDF_Parser::ResourcePropertyElement(this, a2, a3, a4);
      return;
    }
    goto LABEL_60;
  }
  while (1)
  {
    v14 = *v13;
    v15 = *v13 + 40;
    v16 = *(unsigned __int8 *)(*v13 + 63);
    if ((*(char *)(*v13 + 63) & 0x80000000) == 0)
    {
      switch(*(_BYTE *)(*v13 + 63))
      {
        case 6:
          if (*(_DWORD *)v15 == 979788914 && *(_WORD *)(*v13 + 44) == 17481)
            goto LABEL_28;
          goto LABEL_38;
        case 8:
          if (*(_QWORD *)v15 == 0x676E616C3A6C6D78)
            goto LABEL_28;
LABEL_38:
          if (v16 == 12)
            goto LABEL_48;
          if (v16 == 13)
            goto LABEL_40;
          goto LABEL_9;
        case 0xC:
LABEL_48:
          if (*(_QWORD *)v15 != 0x617461643A666472 || *(_DWORD *)(*v13 + 48) != 1701869940)
            goto LABEL_9;
          goto LABEL_60;
        case 0xD:
          goto LABEL_40;
        default:
          goto LABEL_9;
      }
    }
    v18 = *(_QWORD *)(v14 + 48);
    if (v18 == 6)
      break;
    if (v18 != 8 || **(_QWORD **)v15 != 0x676E616C3A6C6D78)
      goto LABEL_35;
LABEL_28:
    if (++v13 == v12)
      goto LABEL_29;
  }
  if (**(_DWORD **)v15 == 979788914 && *(_WORD *)(*(_QWORD *)v15 + 4) == 17481)
    goto LABEL_28;
LABEL_35:
  v22 = *(_QWORD *)(v14 + 48);
  if (v22 != 12)
  {
LABEL_36:
    if (v22 != 13)
      goto LABEL_9;
    v15 = *(_QWORD *)v15;
LABEL_40:
    v23 = *(_QWORD *)v15;
    v24 = *(_QWORD *)(v15 + 5);
    if (v23 != 0x737261703A666472 || v24 != 0x6570795465737261)
      goto LABEL_9;
    v26 = (int **)(v14 + 64);
    v27 = *(char *)(v14 + 87);
    if (v27 < 0)
    {
      if (*(_QWORD *)(v14 + 72) != 7)
        goto LABEL_67;
      v28 = *v26;
    }
    else
    {
      v28 = (int *)(v14 + 64);
      if (v27 != 7)
        goto LABEL_67;
    }
    v31 = *v28;
    v32 = *(int *)((char *)v28 + 3);
    if (v31 == 1702127948 && v32 == 1818325605)
    {
      v35 = 0;
      v10 = 203;
      v11 = "ParseTypeLiteral property element not allowed";
    }
    else
    {
LABEL_67:
      if (std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v26, "Resource"))
      {
        RDF_Parser::ParseTypeResourcePropertyElement(this, a2, (const XML_Node ***)a3, a4);
        return;
      }
      v35 = 0;
      if (std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v26, "Collection"))
      {
        v10 = 203;
        v11 = "ParseTypeCollection property element not allowed";
      }
      else
      {
        v10 = 203;
        v11 = "ParseTypeOther property element not allowed";
      }
    }
LABEL_7:
    v34[1] = v11;
    v34[0] = v10;
    GenericErrorCallback::NotifyClient(*(_QWORD *)this, 0, (unsigned int *)v34, 0);
    return;
  }
  if (**(_QWORD **)v15 == 0x617461643A666472 && *(_DWORD *)(*(_QWORD *)v15 + 8) == 1701869940)
  {
LABEL_60:
    RDF_Parser::LiteralPropertyElement(this, a2, (const XML_Node ***)a3, a4);
    return;
  }
  if ((v16 & 0x80) != 0)
    goto LABEL_36;
LABEL_9:
  RDF_Parser::EmptyPropertyElement(this, a2, a3, a4);
}

void RDF_Parser::NodeElement(RDF_Parser *this, size_t *a2, const XML_Node *a3, int a4)
{
  int RDFTermKind;
  unsigned int v9;
  const char *v10;
  _QWORD v11[2];
  uint64_t v12;

  RDFTermKind = GetRDFTermKind((uint64_t)a3 + 40);
  if ((RDFTermKind & 7) != 0)
  {
    v12 = 0;
    v9 = 202;
    v10 = "Node element must be rdf:Description or typedNode";
LABEL_6:
    v11[1] = v10;
    v11[0] = v9;
    GenericErrorCallback::NotifyClient(*(_QWORD *)this, 0, (unsigned int *)v11, 0);
    return;
  }
  if (!RDFTermKind && a4)
  {
    v12 = 0;
    v9 = 203;
    v10 = "Top level typedNode not allowed";
    goto LABEL_6;
  }
  RDF_Parser::NodeElementAttrs((uint64_t)this, a2, a3, a4);
  RDF_Parser::PropertyElementList(this, (XMP_Node *)a2, a3, a4);
}

void RDF_Parser::LiteralPropertyElement(RDF_Parser *this, XMP_Node *a2, const XML_Node ***a3, int a4)
{
  uint64_t v6;
  uint64_t v7;
  const XML_Node **v8;
  const XML_Node **i;
  const XML_Node *v10;
  _DWORD *v11;
  int v12;
  uint64_t v13;
  uint64_t v15;
  int v16;
  const XML_Node **v19;
  const XML_Node **v20;
  std::string::size_type v21;
  const XML_Node *v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  const std::string::value_type *v26;
  const std::string::value_type *v27;
  std::string::size_type v28;
  std::string::size_type v29;
  const std::string::value_type *v30;
  std::string::size_type v31;
  uint64_t v32;
  const char *v33;
  uint64_t v34;

  v6 = RDF_Parser::AddChildNode(this, a2, (const XML_Node *)a3, "", a4);
  if (v6)
  {
    v7 = v6;
    v8 = a3[13];
    for (i = a3[14]; v8 != i; ++v8)
    {
      v10 = *v8;
      v11 = (_DWORD *)((char *)*v8 + 40);
      if (*((char *)*v8 + 63) < 0)
      {
        v13 = *((_QWORD *)v10 + 6);
        if (v13 == 6)
        {
          if (**(_DWORD **)v11 == 979788914 && *(_WORD *)(*(_QWORD *)v11 + 4) == 17481)
            continue;
          v13 = *((_QWORD *)v10 + 6);
        }
        else if (v13 == 8 && **(_QWORD **)v11 == 0x676E616C3A6C6D78)
        {
LABEL_35:
          RDF_Parser::AddQualifierNode(this, (XMP_Node *)v7, v10);
          continue;
        }
        if (v13 == 12)
        {
          v11 = *(_DWORD **)v11;
LABEL_19:
          v15 = *(_QWORD *)v11;
          v16 = v11[2];
          if (v15 == 0x617461643A666472 && v16 == 1701869940)
            continue;
        }
      }
      else
      {
        v12 = *((unsigned __int8 *)*v8 + 63);
        switch(v12)
        {
          case 6:
            if (*v11 == 979788914 && *((_WORD *)*v8 + 22) == 17481)
              continue;
            break;
          case 8:
            if (*(_QWORD *)v11 == 0x676E616C3A6C6D78)
              goto LABEL_35;
            break;
          case 12:
            goto LABEL_19;
        }
      }
      v33 = "Invalid attribute for literal property element";
      v34 = 0;
      v32 = 202;
      GenericErrorCallback::NotifyClient(*(_QWORD *)this, 0, (unsigned int *)&v32, 0);
    }
    v20 = a3[16];
    v19 = a3[17];
    if (v20 == v19)
    {
      v21 = 0;
    }
    else
    {
      v21 = 0;
      do
      {
        v22 = *v20;
        if (*((_BYTE *)*v20 + 8) == 3)
        {
          if (*((char *)v22 + 87) < 0)
            v23 = *((_QWORD *)v22 + 9);
          else
            v23 = *((unsigned __int8 *)v22 + 87);
          v21 += v23;
        }
        else
        {
          v33 = "Invalid child of literal property element";
          v34 = 0;
          v32 = 202;
          GenericErrorCallback::NotifyClient(*(_QWORD *)this, 0, (unsigned int *)&v32, 0);
        }
        ++v20;
      }
      while (v20 != v19);
    }
    std::string::reserve((std::string *)(v7 + 40), v21);
    v24 = (uint64_t *)a3[16];
    while (v24 != (uint64_t *)v19)
    {
      v25 = *v24++;
      v26 = (const std::string::value_type *)(v25 + 64);
      v27 = *(const std::string::value_type **)(v25 + 64);
      v28 = *(unsigned __int8 *)(v25 + 87);
      v29 = *(_QWORD *)(v25 + 72);
      if ((v28 & 0x80u) == 0)
        v30 = v26;
      else
        v30 = v27;
      if ((v28 & 0x80u) == 0)
        v31 = v28;
      else
        v31 = v29;
      std::string::append((std::string *)(v7 + 40), v30, v31);
    }
  }
}

uint64_t DetermineInputEncoding(const unsigned __int8 *a1, unint64_t a2)
{
  uint64_t result;
  int v4;
  BOOL v5;
  unsigned int v6;

  if (a2 < 2)
    return 0;
  v4 = *a1;
  if (!*a1)
  {
    result = 2;
    if (a2 < 4)
      return result;
    v5 = a1[1] == 0;
    v6 = 4;
    goto LABEL_15;
  }
  if ((v4 & 0x80) != 0)
  {
    if (v4 != 239)
    {
      if (v4 == 254)
        return 2;
      goto LABEL_13;
    }
    return 0;
  }
  if (a1[1])
    return 0;
LABEL_13:
  result = 3;
  if (a2 < 4)
    return result;
  v5 = a1[2] == 0;
  v6 = 5;
LABEL_15:
  if (v5)
    return v6;
  else
    return result;
}

uint64_t ProcessUTF8Portion(XMLParserAdapter *a1, char *__s1, uint64_t a3, int a4)
{
  uint64_t v5;
  char *v8;
  char *v9;
  char *v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  BOOL v17;
  int v18;
  char *v20;
  int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned __int8 v24;
  unsigned __int8 v25;
  unsigned __int8 *v26;
  int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  char v31;
  unsigned __int8 *v32;
  unsigned __int8 *v33;
  unsigned __int8 v34;
  unsigned __int8 *v35;
  int64_t v36;
  int v37;
  uint64_t v38;
  char *v39;
  char v40;

  v5 = a3;
  v8 = &__s1[a3];
  if (a3 >= 1)
  {
    v9 = __s1;
    v10 = __s1;
    while (1)
    {
      v11 = *v9;
      if (v11 != 38 && v11 - 127 > 0xFFFFFFA0)
        goto LABEL_30;
      if ((v11 & 0x80) != 0)
        break;
      if (v11 < 0x20 || v11 == 127)
      {
        v17 = v11 > 0xD;
        v18 = (1 << v11) & 0x2600;
        if (!v17 && v18 != 0)
          goto LABEL_30;
        (*(void (**)(XMLParserAdapter *, char *, int64_t, _QWORD))(*(_QWORD *)a1 + 16))(a1, v10, v9 - v10, 0);
        (*(void (**)(XMLParserAdapter *, const char *, uint64_t, _QWORD))(*(_QWORD *)a1 + 16))(a1, " ", 1, 0);
        goto LABEL_29;
      }
      if (v11 != 38)
        ProcessUTF8Portion();
      if ((unint64_t)(v8 - v9) >= 5)
      {
        if (strncmp(v9, "&#x", 3uLL))
          goto LABEL_30;
        v20 = v9 + 3;
        v21 = v9[3];
        v22 = v21 - 48;
        v23 = v21 - 65;
        if ((v21 - 97) <= 5)
          v24 = v21 - 87;
        else
          v24 = 0;
        if ((v21 - 97) <= 5)
          v20 = v9 + 4;
        v25 = v21 - 55;
        if (v23 <= 5)
          v20 = v9 + 4;
        else
          v25 = v24;
        if (v22 > 9)
        {
          v26 = (unsigned __int8 *)v20;
        }
        else
        {
          v25 = v22;
          v26 = (unsigned __int8 *)(v9 + 4);
        }
        v27 = *v26;
        v28 = v27 - 48;
        v29 = v27 - 65;
        v30 = v27 - 97;
        v31 = v27 + 16 * v25;
        if (v30 > 5)
        {
          v32 = v26;
        }
        else
        {
          v25 = v31 - 87;
          v32 = v26 + 1;
        }
        if (v29 > 5)
        {
          v33 = v32;
        }
        else
        {
          v25 = v31 - 55;
          v33 = v26 + 1;
        }
        v34 = v31 - 48;
        if (v28 <= 9)
        {
          v35 = v26 + 1;
        }
        else
        {
          v34 = v25;
          v35 = v33;
        }
        if (v35 != (unsigned __int8 *)v8)
        {
          if (*v35 != 59)
            goto LABEL_30;
          v36 = v35 - (unsigned __int8 *)v9;
          v37 = v36 + 1;
          if ((unint64_t)(v36 + 1) < 5 || v34 <= 0xDu && ((1 << v34) & 0x2600) != 0)
            goto LABEL_30;
          if ((v37 & 0x80000000) == 0)
          {
            if ((_DWORD)v36 != -1)
            {
              (*(void (**)(XMLParserAdapter *, char *, int64_t, _QWORD))(*(_QWORD *)a1 + 16))(a1, v10, v9 - v10, 0);
              (*(void (**)(XMLParserAdapter *, const char *, uint64_t, _QWORD))(*(_QWORD *)a1 + 16))(a1, " ", 1, 0);
              v10 = &v9[v37];
              v9 = v10 - 1;
            }
            goto LABEL_30;
          }
        }
      }
      if ((a4 & 1) == 0)
        goto LABEL_72;
LABEL_30:
      if (++v9 >= v8)
        goto LABEL_66;
    }
    if (v11 >= 0xC0)
    {
      v12 = 4 * (v11 & 0x3F);
      v13 = 2;
      if (v12 >= 0x80)
      {
        do
        {
          ++v13;
          v12 = (2 * v12) & 0xF8;
        }
        while (v12 > 0x7F);
      }
      if (&v9[v13] <= v8)
      {
        v38 = v13 - 1;
        v39 = v9 + 1;
        while (1)
        {
          v40 = *v39++;
          if ((v40 & 0xC0) != 0x80)
            break;
          if (!--v38)
          {
            v9 += v13 - 1;
            goto LABEL_30;
          }
        }
      }
      else if ((a4 & 1) == 0)
      {
LABEL_72:
        (*(void (**)(XMLParserAdapter *, char *, int64_t, _QWORD))(*(_QWORD *)a1 + 16))(a1, v10, v9 - v10, 0);
        return v9 - __s1;
      }
    }
    (*(void (**)(XMLParserAdapter *, char *, int64_t, _QWORD))(*(_QWORD *)a1 + 16))(a1, v10, v9 - v10, 0);
    v14 = 0;
    v15 = kReplaceLatin1[*v9 - 128];
    while (v15[v14])
    {
      ++v14;
      v16 = 0xFFFFFFFFLL;
      if (v14 == 0xFFFFFFFFLL)
        goto LABEL_28;
    }
    v16 = v14;
LABEL_28:
    (*(void (**)(XMLParserAdapter *, char *, uint64_t, _QWORD))(*(_QWORD *)a1 + 16))(a1, v15, v16, 0);
LABEL_29:
    v10 = v9 + 1;
    goto LABEL_30;
  }
  v10 = __s1;
  v9 = __s1;
LABEL_66:
  if (v9 != v8)
    ProcessUTF8Portion();
  if (v10 < v8)
    (*(void (**)(XMLParserAdapter *, char *, int64_t, _QWORD))(*(_QWORD *)a1 + 16))(a1, v10, v8 - v10, 0);
  if (a4)
    (*(void (**)(XMLParserAdapter *, const char *, uint64_t, uint64_t))(*(_QWORD *)a1 + 16))(a1, " ", 1, 1);
  return v5;
}

uint64_t ExpatAdapter::ParseBuffer(uint64_t this, const char *a2, uint64_t a3, int a4)
{
  uint64_t v4;
  XML_ParserStruct *v5;
  _QWORD v6[3];

  v4 = this;
  if (a3 || a4)
  {
    if (!a3)
      a2 = " ";
    v5 = *(XML_ParserStruct **)(this + 248);
    if (!a3)
      LODWORD(a3) = 1;
    this = XML_Parse(v5, a2, a3, a4);
    if ((_DWORD)this != 1)
    {
      v6[0] = 201;
      v6[1] = "XML parsing failure";
      v6[2] = 0;
      return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD *))(*(_QWORD *)v4 + 32))(v4, 0, v6);
    }
  }
  return this;
}

void NormalizeDCArrays(char **a1)
{
  uint64_t SchemaNode;
  XMP_Node *v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char **v8;
  int v9;
  int v10;
  BOOL v11;
  int v12;
  uint64_t v13;
  uint64_t *v21;
  unsigned int v23;
  uint64_t v27;
  BOOL v28;
  uint64_t v29;
  uint64_t v31;
  uint64_t v32;
  int v34;
  XMP_Node *v35;
  XMP_Node *v36;
  char *v37;
  unint64_t v38;
  _QWORD *v39;
  _QWORD *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  char *v46;
  char *v47;
  char *v48;
  char *v49;
  uint64_t v50;
  XMP_Node *v51;
  char *v52;
  unint64_t v53;
  char *v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  _QWORD *v59;
  char *v60;
  char *v61;
  _QWORD *v62;
  uint64_t v63;
  XMP_Node *v64;

  SchemaNode = FindSchemaNode(a1, "http://purl.org/dc/elements/1.1/", 0, 0, 0, 0);
  if (SchemaNode)
  {
    v2 = (XMP_Node *)SchemaNode;
    v3 = *(_QWORD *)(SchemaNode + 80) - *(_QWORD *)(SchemaNode + 72);
    if (v3)
    {
      v4 = 0;
      v5 = v3 >> 3;
      if (v5 <= 1)
        v6 = 1;
      else
        v6 = v5;
      do
      {
        v7 = *(_QWORD *)(*((_QWORD *)v2 + 9) + 8 * v4);
        if ((*(_BYTE *)(v7 + 9) & 0x1F) != 0)
          goto LABEL_7;
        v8 = (char **)(v7 + 16);
        if ((*(char *)(v7 + 39) & 0x80000000) == 0)
        {
          v9 = *(unsigned __int8 *)(v7 + 39);
          switch(*(_BYTE *)(v7 + 39))
          {
            case 7:
              v10 = *(_DWORD *)(v7 + 19);
              v11 = *(_DWORD *)v8 == 1681548132;
              v12 = 1702125924;
              goto LABEL_60;
            case 8:
              goto LABEL_76;
            case 9:
LABEL_71:
              if (*v8 == (char *)0x74686769723A6364 && *(_BYTE *)(v7 + 24) == 115)
                goto LABEL_77;
              if (v9 != 8)
                goto LABEL_95;
LABEL_76:
              if (*v8 == (char *)0x656C7469743A6364)
                goto LABEL_77;
              goto LABEL_95;
            case 0xA:
              v10 = *(unsigned __int16 *)(v7 + 24);
              v11 = *v8 == (char *)0x74616572633A6364;
              v12 = 29295;
LABEL_60:
              if (!v11 || v10 != v12)
                goto LABEL_95;
              goto LABEL_65;
            case 0xB:
LABEL_84:
              v27 = *(_QWORD *)(v7 + 19);
              v28 = *v8 == (char *)0x75676E616C3A6364;
              v29 = 0x65676175676E616CLL;
              goto LABEL_86;
            case 0xC:
LABEL_85:
              v27 = *(unsigned int *)(v7 + 24);
              v28 = *v8 == (char *)0x696C6275703A6364;
              v29 = 1919248499;
LABEL_86:
              if (v28 && v27 == v29)
                goto LABEL_97;
              v21 = (uint64_t *)(v7 + 16);
              if (v9 == 11)
                goto LABEL_91;
              goto LABEL_95;
            case 0xE:
              if (*v8 != (char *)0x72637365643A6364 || *(_QWORD *)(v7 + 22) != 0x6E6F697470697263)
              {
                switch(*(_BYTE *)(v7 + 39))
                {
                  case 8:
                    goto LABEL_76;
                  case 9:
                    goto LABEL_71;
                  case 0xB:
                    goto LABEL_84;
                  case 0xC:
                    goto LABEL_85;
                  case 0xE:
                    if (*v8 == (char *)0x72746E6F633A6364 && *(_QWORD *)(v7 + 22) == 0x726F747562697274)
                      goto LABEL_97;
                    if (v9 == 12)
                      goto LABEL_85;
                    if (v9 == 11)
                      goto LABEL_84;
                    goto LABEL_95;
                  default:
                    goto LABEL_95;
                }
              }
              goto LABEL_77;
            default:
              goto LABEL_95;
          }
        }
        v13 = *(_QWORD *)(v7 + 24);
        if (v13 == 7)
        {
          if (*(_DWORD *)*v8 != 1681548132 || *(_DWORD *)(*v8 + 3) != 1702125924)
          {
            v13 = *(_QWORD *)(v7 + 24);
LABEL_24:
            if (v13 == 14)
            {
              if (*(_QWORD *)*v8 != 0x72637365643A6364 || *(_QWORD *)(*v8 + 6) != 0x6E6F697470697263)
              {
                v13 = *(_QWORD *)(v7 + 24);
                goto LABEL_30;
              }
LABEL_77:
              v23 = 4096;
              goto LABEL_98;
            }
LABEL_30:
            if (v13 == 9)
            {
              if (*(_QWORD *)*v8 == 0x74686769723A6364 && (*v8)[8] == 115)
                goto LABEL_77;
              v13 = *(_QWORD *)(v7 + 24);
            }
            if (v13 != 8)
              goto LABEL_39;
            if (*(_QWORD *)*v8 != 0x656C7469743A6364)
            {
              v13 = *(_QWORD *)(v7 + 24);
LABEL_39:
              if (v13 == 14)
              {
                if (*(_QWORD *)*v8 != 0x72746E6F633A6364 || *(_QWORD *)(*v8 + 6) != 0x726F747562697274)
                {
                  v13 = *(_QWORD *)(v7 + 24);
                  goto LABEL_45;
                }
LABEL_97:
                v23 = 512;
                goto LABEL_98;
              }
LABEL_45:
              if (v13 == 11)
              {
                if (*(_QWORD *)*v8 == 0x75676E616C3A6364 && *(_QWORD *)(*v8 + 3) == 0x65676175676E616CLL)
                  goto LABEL_97;
                v13 = *(_QWORD *)(v7 + 24);
              }
              if (v13 == 12)
              {
                if (*(_QWORD *)*v8 == 0x696C6275703A6364 && *((_DWORD *)*v8 + 2) == 1919248499)
                  goto LABEL_97;
                v13 = *(_QWORD *)(v7 + 24);
              }
              if (v13 != 11)
                goto LABEL_95;
              v21 = (uint64_t *)*v8;
LABEL_91:
              v31 = *v21;
              v32 = *(uint64_t *)((char *)v21 + 3);
              if (v31 != 0x74616C65723A6364 || v32 != 0x6E6F6974616C6572)
              {
LABEL_95:
                if (!std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((_QWORD *)(v7 + 16), "dc:subject")&& !std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((_QWORD *)(v7 + 16), "dc:type"))
                {
                  goto LABEL_7;
                }
              }
              goto LABEL_97;
            }
            goto LABEL_77;
          }
        }
        else
        {
          if (v13 != 10)
            goto LABEL_24;
          if (*(_QWORD *)*v8 != 0x74616572633A6364 || *((_WORD *)*v8 + 4) != 29295)
            goto LABEL_24;
        }
LABEL_65:
        v23 = 1024;
LABEL_98:
        v34 = VerifySetOptions(v23, 0);
        v35 = (XMP_Node *)operator new();
        v36 = v35;
        v37 = (char *)(v7 + 16);
        if (*(char *)(v7 + 39) < 0)
          v37 = *v8;
        XMP_Node::XMP_Node(v35, v2, v37, v34);
        *(_QWORD *)(*((_QWORD *)v2 + 9) + 8 * v4) = v36;
        if (*(char *)(v7 + 63) < 0)
        {
          if (*(_QWORD *)(v7 + 48))
          {
LABEL_102:
            v38 = *((_QWORD *)v36 + 11);
            v39 = (_QWORD *)*((_QWORD *)v36 + 10);
            if ((unint64_t)v39 >= v38)
            {
              v41 = *((_QWORD *)v36 + 9);
              v42 = ((uint64_t)v39 - v41) >> 3;
              if ((unint64_t)(v42 + 1) >> 61)
                std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
              v43 = v38 - v41;
              v44 = v43 >> 2;
              if (v43 >> 2 <= (unint64_t)(v42 + 1))
                v44 = v42 + 1;
              if ((unint64_t)v43 >= 0x7FFFFFFFFFFFFFF8)
                v45 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v45 = v44;
              if (v45)
                v46 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)v36 + 88, v45);
              else
                v46 = 0;
              v47 = &v46[8 * v42];
              *(_QWORD *)v47 = v7;
              v40 = v47 + 8;
              v49 = (char *)*((_QWORD *)v36 + 9);
              v48 = (char *)*((_QWORD *)v36 + 10);
              if (v48 != v49)
              {
                do
                {
                  v50 = *((_QWORD *)v48 - 1);
                  v48 -= 8;
                  *((_QWORD *)v47 - 1) = v50;
                  v47 -= 8;
                }
                while (v48 != v49);
                v48 = (char *)*((_QWORD *)v36 + 9);
              }
              *((_QWORD *)v36 + 9) = v47;
              *((_QWORD *)v36 + 10) = v40;
              *((_QWORD *)v36 + 11) = &v46[8 * v45];
              if (v48)
                operator delete(v48);
            }
            else
            {
              *v39 = v7;
              v40 = v39 + 1;
            }
            *((_QWORD *)v36 + 10) = v40;
            *(_QWORD *)(v7 + 64) = v36;
            MEMORY[0x18D761A14](v7 + 16, "[]");
            if ((v34 & 0x1000) != 0 && (*(_BYTE *)(v7 + 8) & 0x40) == 0)
            {
              v64 = 0;
              v51 = (XMP_Node *)operator new();
              XMP_Node::XMP_Node(v51, (XMP_Node *)v7, "xml:lang", "x-default", 32);
              v52 = *(char **)(v7 + 96);
              v64 = v51;
              *(_DWORD *)(v7 + 8) |= 0x50u;
              if (v52 == *(char **)(v7 + 104))
              {
                v53 = *(_QWORD *)(v7 + 112);
                if ((unint64_t)v52 >= v53)
                {
                  v55 = v53 - (_QWORD)v52;
                  v56 = v55 >> 2;
                  if ((unint64_t)(v55 >> 2) <= 1)
                    v56 = 1;
                  if ((unint64_t)v55 >= 0x7FFFFFFFFFFFFFF8)
                    v57 = 0x1FFFFFFFFFFFFFFFLL;
                  else
                    v57 = v56;
                  v59 = std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>(v7 + 112, v57);
                  *v59 = v64;
                  v54 = (char *)(v59 + 1);
                  v61 = *(char **)(v7 + 96);
                  v60 = *(char **)(v7 + 104);
                  v62 = v59;
                  if (v60 != v61)
                  {
                    do
                    {
                      v63 = *((_QWORD *)v60 - 1);
                      v60 -= 8;
                      *--v62 = v63;
                    }
                    while (v60 != v61);
                    v60 = *(char **)(v7 + 96);
                  }
                  *(_QWORD *)(v7 + 96) = v62;
                  *(_QWORD *)(v7 + 104) = v54;
                  *(_QWORD *)(v7 + 112) = &v59[v58];
                  if (v60)
                    operator delete(v60);
                }
                else
                {
                  *(_QWORD *)v52 = v51;
                  v54 = v52 + 8;
                }
                *(_QWORD *)(v7 + 104) = v54;
              }
              else
              {
                std::vector<XMP_Node *>::insert(v7 + 96, v52, (char *)&v64);
              }
            }
            goto LABEL_7;
          }
        }
        else if (*(_BYTE *)(v7 + 63))
        {
          goto LABEL_102;
        }
        (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
LABEL_7:
        ++v4;
      }
      while (v4 != v6);
    }
  }
}

void sub_187E7B1F4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10B3C407D34617ELL);
  _Unwind_Resume(a1);
}

ExpatAdapter *XMP_NewExpatAdapter(int a1)
{
  ExpatAdapter *v2;

  v2 = (ExpatAdapter *)operator new();
  ExpatAdapter::ExpatAdapter(v2, a1);
  return v2;
}

void sub_187E7B268(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10B3C4056A07C3ELL);
  _Unwind_Resume(a1);
}

void ExpatAdapter::ExpatAdapter(ExpatAdapter *this, int a2)
{
  char *v4;
  char **v5;
  XML_Parser *v6;
  XML_ParserStruct *NS;
  XMP_NamespaceTable *v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  _QWORD v22[3];

  *(_QWORD *)this = off_1E1BB0E80;
  v4 = (char *)this + 8;
  XML_Node::XML_Node((ExpatAdapter *)((char *)this + 8), 0, "", 0);
  *((_OWORD *)this + 10) = 0u;
  v5 = (char **)((char *)this + 160);
  *((_QWORD *)this + 24) = 0;
  *((_OWORD *)this + 11) = 0u;
  *((_DWORD *)this + 50) = -1;
  *((_QWORD *)this + 26) = 0;
  *((_QWORD *)this + 31) = 0;
  v6 = (XML_Parser *)((char *)this + 248);
  *((_QWORD *)this + 29) = 0;
  *((_QWORD *)this + 30) = 0;
  *(_QWORD *)this = &off_1E1BAC1B8;
  *((_QWORD *)this + 32) = 0;
  *((_QWORD *)this + 33) = 0;
  NS = XML_ParserCreateNS(0, 64);
  *((_QWORD *)this + 31) = NS;
  if (NS)
  {
    if (a2)
    {
      v8 = (XMP_NamespaceTable *)sRegisteredNamespaces;
    }
    else
    {
      v8 = (XMP_NamespaceTable *)operator new();
      XMP_NamespaceTable::XMP_NamespaceTable(v8, (const XMP_NamespaceTable *)sRegisteredNamespaces);
      NS = *v6;
    }
    *((_QWORD *)this + 32) = v8;
    XML_SetUserData(NS, this);
    XML_SetNamespaceDeclHandler(*v6, (XML_StartNamespaceDeclHandler)StartNamespaceDeclHandler, (XML_EndNamespaceDeclHandler)EndNamespaceDeclHandler);
    XML_SetElementHandler(*v6, (XML_StartElementHandler)StartElementHandler, (XML_EndElementHandler)EndElementHandler);
    XML_SetCharacterDataHandler(*v6, (XML_CharacterDataHandler)CharacterDataHandler);
    XML_SetCdataSectionHandler(*v6, (XML_StartCdataSectionHandler)StartCdataSectionHandler, (XML_EndCdataSectionHandler)EndCdataSectionHandler);
    XML_SetProcessingInstructionHandler(*v6, (XML_ProcessingInstructionHandler)ProcessingInstructionHandler);
    XML_SetCommentHandler(*v6, (XML_CommentHandler)CommentHandler);
    v9 = *((_QWORD *)this + 22);
    v10 = (_QWORD *)*((_QWORD *)this + 21);
    if ((unint64_t)v10 >= v9)
    {
      v12 = ((char *)v10 - *v5) >> 3;
      if ((unint64_t)(v12 + 1) >> 61)
        std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
      v13 = v9 - (_QWORD)*v5;
      v14 = v13 >> 2;
      if (v13 >> 2 <= (unint64_t)(v12 + 1))
        v14 = v12 + 1;
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8)
        v15 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v15 = v14;
      if (v15)
        v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 176, v15);
      else
        v16 = 0;
      v17 = &v16[8 * v12];
      v18 = &v16[8 * v15];
      *(_QWORD *)v17 = v4;
      v11 = v17 + 8;
      v20 = (char *)*((_QWORD *)this + 20);
      v19 = (char *)*((_QWORD *)this + 21);
      if (v19 != v20)
      {
        do
        {
          v21 = *((_QWORD *)v19 - 1);
          v19 -= 8;
          *((_QWORD *)v17 - 1) = v21;
          v17 -= 8;
        }
        while (v19 != v20);
        v19 = *v5;
      }
      *((_QWORD *)this + 20) = v17;
      *((_QWORD *)this + 21) = v11;
      *((_QWORD *)this + 22) = v18;
      if (v19)
        operator delete(v19);
    }
    else
    {
      *v10 = v4;
      v11 = v10 + 1;
    }
    *((_QWORD *)this + 21) = v11;
  }
  else
  {
    v22[0] = 15;
    v22[1] = "Failure creating Expat parser";
    v22[2] = 0;
    (*(void (**)(ExpatAdapter *, uint64_t, _QWORD *))(*(_QWORD *)this + 32))(this, 3, v22);
  }
}

void sub_187E7B4F0(_Unwind_Exception *a1)
{
  XMLParserAdapter *v1;
  uint64_t v2;

  MEMORY[0x18D761C30](v2, 0x10A1C40F44AF5F3);
  XMLParserAdapter::~XMLParserAdapter(v1);
  _Unwind_Resume(a1);
}

void XMLParserAdapter::~XMLParserAdapter(XMLParserAdapter *this)
{
  void *v2;

  *(_QWORD *)this = off_1E1BB0E80;
  v2 = (void *)*((_QWORD *)this + 20);
  if (v2)
  {
    *((_QWORD *)this + 21) = v2;
    operator delete(v2);
  }
  XML_Node::~XML_Node((XMLParserAdapter *)((char *)this + 8));
}

void XML_Node::~XML_Node(XML_Node *this)
{
  XML_Node::~XML_Node(this);
  JUMPOUT(0x18D761C30);
}

{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_1E1BB2B80;
  XML_Node::RemoveAttrs(this);
  XML_Node::RemoveContent(this);
  v2 = (void *)*((_QWORD *)this + 16);
  if (v2)
  {
    *((_QWORD *)this + 17) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 13);
  if (v3)
  {
    *((_QWORD *)this + 14) = v3;
    operator delete(v3);
  }
  if (*((char *)this + 87) < 0)
    operator delete(*((void **)this + 8));
  if (*((char *)this + 63) < 0)
    operator delete(*((void **)this + 5));
  if (*((char *)this + 39) < 0)
    operator delete(*((void **)this + 2));
}

_QWORD *XML_Node::RemoveContent(_QWORD *this)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v1 = this;
  v2 = this[17];
  v3 = v2 - this[16];
  if (v3)
  {
    v4 = 0;
    if ((unint64_t)(v3 >> 3) <= 1)
      v5 = 1;
    else
      v5 = v3 >> 3;
    do
    {
      this = *(_QWORD **)(v1[16] + 8 * v4);
      if (this)
        this = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*this + 8))(this);
      ++v4;
    }
    while (v5 != v4);
    v2 = v1[16];
  }
  v1[17] = v2;
  return this;
}

_QWORD *XML_Node::RemoveAttrs(_QWORD *this)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v1 = this;
  v2 = this[14];
  v3 = v2 - this[13];
  if (v3)
  {
    v4 = 0;
    if ((unint64_t)(v3 >> 3) <= 1)
      v5 = 1;
    else
      v5 = v3 >> 3;
    do
    {
      this = *(_QWORD **)(v1[13] + 8 * v4);
      if (this)
        this = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*this + 8))(this);
      ++v4;
    }
    while (v5 != v4);
    v2 = v1[13];
  }
  v1[14] = v2;
  return this;
}

void ProcessingInstructionHandler(_QWORD *a1, char *__s1, const char *a3)
{
  XML_Node *v6;
  XML_Node *v7;
  const char *v8;
  unint64_t v9;
  XML_Node **v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  XML_Node **v18;
  char *v19;
  char *v20;
  char *v21;
  XML_Node *v22;

  if (!__s1)
    ProcessingInstructionHandler();
  if (!strcmp(__s1, "xpacket"))
  {
    v6 = *(XML_Node **)(a1[21] - 8);
    v7 = (XML_Node *)operator new();
    XML_Node::XML_Node(v7, v6, __s1, 4);
    if (a3)
      v8 = a3;
    else
      v8 = "";
    MEMORY[0x18D761A14]((char *)v7 + 64, v8);
    v9 = *((_QWORD *)v6 + 18);
    v10 = (XML_Node **)*((_QWORD *)v6 + 17);
    if ((unint64_t)v10 >= v9)
    {
      v12 = *((_QWORD *)v6 + 16);
      v13 = ((uint64_t)v10 - v12) >> 3;
      if ((unint64_t)(v13 + 1) >> 61)
        std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
      v14 = v9 - v12;
      v15 = v14 >> 2;
      if (v14 >> 2 <= (unint64_t)(v13 + 1))
        v15 = v13 + 1;
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8)
        v16 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v16 = v15;
      if (v16)
        v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)v6 + 144, v16);
      else
        v17 = 0;
      v18 = (XML_Node **)&v17[8 * v13];
      v19 = &v17[8 * v16];
      *v18 = v7;
      v11 = v18 + 1;
      v21 = (char *)*((_QWORD *)v6 + 16);
      v20 = (char *)*((_QWORD *)v6 + 17);
      if (v20 != v21)
      {
        do
        {
          v22 = (XML_Node *)*((_QWORD *)v20 - 1);
          v20 -= 8;
          *--v18 = v22;
        }
        while (v20 != v21);
        v20 = (char *)*((_QWORD *)v6 + 16);
      }
      *((_QWORD *)v6 + 16) = v18;
      *((_QWORD *)v6 + 17) = v11;
      *((_QWORD *)v6 + 18) = v19;
      if (v20)
        operator delete(v20);
    }
    else
    {
      *v10 = v7;
      v11 = v10 + 1;
    }
    *((_QWORD *)v6 + 17) = v11;
  }
}

void sub_187E7B840(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10B3C40BB36A753);
  _Unwind_Resume(a1);
}

void CharacterDataHandler(_QWORD *a1, const char *a2, int a3)
{
  XML_Node *v5;
  XML_Node *v6;
  BOOL v7;
  const char *v8;
  uint64_t v9;
  unint64_t v10;
  XML_Node **v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  XML_Node **v19;
  char *v20;
  char *v21;
  char *v22;
  XML_Node *v23;

  v5 = *(XML_Node **)(a1[21] - 8);
  v6 = (XML_Node *)operator new();
  XML_Node::XML_Node(v6, v5, "", 3);
  if (a2)
    v7 = a3 == 0;
  else
    v7 = 1;
  if (v7)
    v8 = "";
  else
    v8 = a2;
  if (v7)
    v9 = 0;
  else
    v9 = a3;
  MEMORY[0x18D761A20]((char *)v6 + 64, v8, v9);
  v10 = *((_QWORD *)v5 + 18);
  v11 = (XML_Node **)*((_QWORD *)v5 + 17);
  if ((unint64_t)v11 >= v10)
  {
    v13 = *((_QWORD *)v5 + 16);
    v14 = ((uint64_t)v11 - v13) >> 3;
    if ((unint64_t)(v14 + 1) >> 61)
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    v15 = v10 - v13;
    v16 = v15 >> 2;
    if (v15 >> 2 <= (unint64_t)(v14 + 1))
      v16 = v14 + 1;
    if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8)
      v17 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v17 = v16;
    if (v17)
      v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)v5 + 144, v17);
    else
      v18 = 0;
    v19 = (XML_Node **)&v18[8 * v14];
    v20 = &v18[8 * v17];
    *v19 = v6;
    v12 = v19 + 1;
    v22 = (char *)*((_QWORD *)v5 + 16);
    v21 = (char *)*((_QWORD *)v5 + 17);
    if (v21 != v22)
    {
      do
      {
        v23 = (XML_Node *)*((_QWORD *)v21 - 1);
        v21 -= 8;
        *--v19 = v23;
      }
      while (v21 != v22);
      v21 = (char *)*((_QWORD *)v5 + 16);
    }
    *((_QWORD *)v5 + 16) = v19;
    *((_QWORD *)v5 + 17) = v12;
    *((_QWORD *)v5 + 18) = v20;
    if (v21)
      operator delete(v21);
  }
  else
  {
    *v11 = v6;
    v12 = v11 + 1;
  }
  *((_QWORD *)v5 + 17) = v12;
}

void sub_187E7B9A0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10B3C40BB36A753);
  _Unwind_Resume(a1);
}

void StartElementHandler(XMP_NamespaceTable **a1, const char *a2, const char **a3)
{
  const char **v3;
  uint64_t v6;
  _QWORD *v8;
  uint64_t v9;
  const char *v10;
  char **v11;
  const char *v12;
  uint64_t v13;
  _QWORD *v14;
  int v15;
  unint64_t v16;
  uint64_t *v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t *v24;
  char *v25;
  char *v26;
  uint64_t v27;
  const char *v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t *v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  char *v38;
  uint64_t *v39;
  char *v40;
  char *v41;
  char *v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t *v45;
  XMP_NamespaceTable *v46;
  XMP_NamespaceTable *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  char *v52;
  uint64_t *v53;
  XMP_NamespaceTable *v54;
  XMP_NamespaceTable *v55;
  XMP_NamespaceTable *v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  int v60;
  int v61;
  uint64_t v63;
  unint64_t v64;
  _DWORD *exception;
  _QWORD *v66;
  _QWORD v67[3];

  if (!a3)
    StartElementHandler();
  v3 = a3;
  if (*a3)
  {
    v6 = 0;
    while (a3[++v6])
      ;
    if ((v6 & 1) != 0)
    {
      v67[0] = 11;
      v67[1] = "Expat attribute info has odd length";
      v67[2] = 0;
      (*((void (**)(XMP_NamespaceTable **, uint64_t, _QWORD *))*a1 + 4))(a1, 1, v67);
    }
  }
  v8 = (_QWORD *)*((_QWORD *)a1[21] - 1);
  v9 = operator new();
  v66 = v8;
  XML_Node::XML_Node((XML_Node *)v9, (XML_Node *)v8, "", 1);
  SetQualName(a1, a2, (XML_Node *)v9);
  v10 = *v3;
  if (*v3)
  {
    v11 = (char **)(v9 + 104);
    do
    {
      v12 = v3[1];
      v13 = operator new();
      XML_Node::XML_Node((XML_Node *)v13, (XML_Node *)v9, "", 2);
      SetQualName(a1, v10, (XML_Node *)v13);
      MEMORY[0x18D761A14](v13 + 64, v12);
      v14 = (_QWORD *)(v13 + 40);
      v15 = *(char *)(v13 + 63);
      if (v15 < 0)
      {
        if (*(_QWORD *)(v13 + 48) == 8)
        {
          v14 = (_QWORD *)*v14;
LABEL_14:
          if (*v14 == 0x676E616C3A6C6D78)
            NormalizeLangValue((unsigned __int8 *)(v13 + 64));
        }
      }
      else if (v15 == 8)
      {
        goto LABEL_14;
      }
      v17 = *(uint64_t **)(v9 + 112);
      v16 = *(_QWORD *)(v9 + 120);
      if ((unint64_t)v17 >= v16)
      {
        v19 = ((char *)v17 - *v11) >> 3;
        if ((unint64_t)(v19 + 1) >> 61)
          std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
        v20 = v16 - (_QWORD)*v11;
        v21 = v20 >> 2;
        if (v20 >> 2 <= (unint64_t)(v19 + 1))
          v21 = v19 + 1;
        if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8)
          v22 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v22 = v21;
        if (v22)
          v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>(v9 + 120, v22);
        else
          v23 = 0;
        v24 = (uint64_t *)&v23[8 * v19];
        *v24 = v13;
        v18 = v24 + 1;
        v26 = *(char **)(v9 + 104);
        v25 = *(char **)(v9 + 112);
        if (v25 != v26)
        {
          do
          {
            v27 = *((_QWORD *)v25 - 1);
            v25 -= 8;
            *--v24 = v27;
          }
          while (v25 != v26);
          v25 = *v11;
        }
        *(_QWORD *)(v9 + 104) = v24;
        *(_QWORD *)(v9 + 112) = v18;
        *(_QWORD *)(v9 + 120) = &v23[8 * v22];
        if (v25)
          operator delete(v25);
      }
      else
      {
        *v17 = v13;
        v18 = v17 + 1;
      }
      *(_QWORD *)(v9 + 112) = v18;
      v28 = v3[2];
      v3 += 2;
      v10 = v28;
    }
    while (v28);
  }
  v29 = (uint64_t)(v8 + 18);
  v30 = v8[18];
  v31 = (uint64_t *)v8[17];
  if ((unint64_t)v31 >= v30)
  {
    v33 = v66[16];
    v34 = ((uint64_t)v31 - v33) >> 3;
    if ((unint64_t)(v34 + 1) >> 61)
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    v35 = v30 - v33;
    v36 = v35 >> 2;
    if (v35 >> 2 <= (unint64_t)(v34 + 1))
      v36 = v34 + 1;
    if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF8)
      v37 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v37 = v36;
    if (v37)
      v38 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>(v29, v37);
    else
      v38 = 0;
    v39 = (uint64_t *)&v38[8 * v34];
    v40 = &v38[8 * v37];
    *v39 = v9;
    v32 = v39 + 1;
    v42 = (char *)v66[16];
    v41 = (char *)v66[17];
    if (v41 != v42)
    {
      do
      {
        v43 = *((_QWORD *)v41 - 1);
        v41 -= 8;
        *--v39 = v43;
      }
      while (v41 != v42);
      v41 = (char *)v66[16];
    }
    v66[16] = v39;
    v66[17] = v32;
    v66[18] = v40;
    if (v41)
      operator delete(v41);
  }
  else
  {
    *v31 = v9;
    v32 = v31 + 1;
  }
  v66[17] = v32;
  v44 = (unint64_t)a1[22];
  v45 = (uint64_t *)a1[21];
  if ((unint64_t)v45 >= v44)
  {
    v47 = a1[20];
    v48 = ((char *)v45 - (char *)v47) >> 3;
    if ((unint64_t)(v48 + 1) >> 61)
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    v49 = v44 - (_QWORD)v47;
    v50 = v49 >> 2;
    if (v49 >> 2 <= (unint64_t)(v48 + 1))
      v50 = v48 + 1;
    if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF8)
      v51 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v51 = v50;
    if (v51)
      v52 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)(a1 + 22), v51);
    else
      v52 = 0;
    v53 = (uint64_t *)&v52[8 * v48];
    v54 = (XMP_NamespaceTable *)&v52[8 * v51];
    *v53 = v9;
    v46 = (XMP_NamespaceTable *)(v53 + 1);
    v56 = a1[20];
    v55 = a1[21];
    if (v55 != v56)
    {
      do
      {
        v57 = *((_QWORD *)v55 - 1);
        v55 = (XMP_NamespaceTable *)((char *)v55 - 8);
        *--v53 = v57;
      }
      while (v55 != v56);
      v55 = a1[20];
    }
    a1[20] = (XMP_NamespaceTable *)v53;
    a1[21] = v46;
    a1[22] = v54;
    if (v55)
      operator delete(v55);
  }
  else
  {
    *v45 = v9;
    v46 = (XMP_NamespaceTable *)(v45 + 1);
  }
  a1[21] = v46;
  v58 = v9 + 40;
  v59 = *(char *)(v9 + 63);
  if (v59 < 0)
  {
    if (*(_QWORD *)(v9 + 48) != 7)
      goto LABEL_76;
    v58 = *(_QWORD *)v58;
  }
  else if (v59 != 7)
  {
    goto LABEL_76;
  }
  v60 = *(_DWORD *)v58;
  v61 = *(_DWORD *)(v58 + 3);
  if (v60 == 979788914 && v61 == 1178882618)
  {
    v63 = (uint64_t)a1[24] + 1;
    a1[23] = (XMP_NamespaceTable *)v9;
    a1[24] = (XMP_NamespaceTable *)v63;
  }
LABEL_76:
  v64 = (unint64_t)a1[33] + 1;
  a1[33] = (XMP_NamespaceTable *)v64;
  if (v64 >= 0x65)
  {
    exception = __cxa_allocate_exception(4uLL);
    *exception = -1;
    __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
  }
}

void sub_187E7BE18(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10B3C40BB36A753);
  _Unwind_Resume(a1);
}

void XML_Node::XML_Node(XML_Node *this, XML_Node *a2, char *__s, char a4)
{
  *(_QWORD *)this = &off_1E1BB2B80;
  *((_BYTE *)this + 8) = a4;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  std::string::basic_string[abi:ne180100]<0>((_QWORD *)this + 5, __s);
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_QWORD *)this + 12) = a2;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
}

void sub_187E7BEB4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 39) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

std::string *SetQualName(XMP_NamespaceTable **a1, const char *__s, XML_Node *a3)
{
  size_t v6;
  size_t v7;
  const std::string::value_type *v8;
  char *v9;
  int v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v17;
  std::string *result;
  uint64_t v19;
  _QWORD *v20;
  int v21;
  std::string *v22;
  _QWORD *v23;
  uint64_t v24;
  int v26;
  _WORD *v27;
  uint64_t v29;
  const char *v31;
  _QWORD v32[3];
  unsigned int v33;
  char *v34;

  v6 = strlen(__s);
  while (1)
  {
    v7 = v6--;
    if (!v6)
      break;
    if (__s[v7 - 1] == 64)
      goto LABEL_6;
  }
  if (*__s == 64)
  {
LABEL_6:
    v34 = 0;
    v33 = 0;
    v8 = &__s[v7];
    v9 = (char *)a3 + 16;
    MEMORY[0x18D761A20]((char *)a3 + 16, __s);
    v10 = *((unsigned __int8 *)a3 + 39);
    if ((v10 & 0x80) != 0)
    {
      if (*((_QWORD *)a3 + 3) != 23)
        goto LABEL_25;
      v11 = *(uint64_t **)v9;
    }
    else
    {
      v11 = (uint64_t *)((char *)a3 + 16);
      if (v10 != 23)
      {
LABEL_19:
        if (!v10)
          goto LABEL_28;
        goto LABEL_27;
      }
    }
    v12 = *v11;
    v13 = v11[1];
    v14 = *(uint64_t *)((char *)v11 + 15);
    if (v12 == 0x702F2F3A70747468 && v13 == 0x2F67726F2E6C7275 && v14 == 0x2F312E312F63642FLL)
    {
      MEMORY[0x18D761A14]((char *)a3 + 16, "http://purl.org/dc/elements/1.1/");
      v10 = *((unsigned __int8 *)a3 + 39);
      if ((v10 & 0x80) == 0)
        goto LABEL_19;
    }
    else if ((v10 & 0x80) == 0)
    {
      goto LABEL_19;
    }
LABEL_25:
    if (!*((_QWORD *)a3 + 3))
      goto LABEL_28;
    v9 = *(char **)v9;
LABEL_27:
    if (XMP_NamespaceTable::GetPrefix(a1[32], v9, (const char **)&v34, &v33))
    {
LABEL_29:
      *((_QWORD *)a3 + 11) = v33;
      v22 = (std::string *)((char *)a3 + 40);
      MEMORY[0x18D761A14](v22, v34);
      return std::string::append(v22, v8);
    }
LABEL_28:
    v32[0] = 11;
    v32[1] = "Unknown URI in Expat full name";
    v32[2] = 0;
    (*((void (**)(XMP_NamespaceTable **, uint64_t, _QWORD *))*a1 + 4))(a1, 1, v32);
    goto LABEL_29;
  }
  v17 = (char *)a3 + 40;
  result = (std::string *)MEMORY[0x18D761A14]((char *)a3 + 40, __s);
  v19 = *((_QWORD *)a3 + 12);
  v20 = (_QWORD *)(v19 + 40);
  v21 = *(char *)(v19 + 63);
  if (v21 < 0)
  {
    if (*(_QWORD *)(v19 + 48) != 15)
      return result;
    v20 = (_QWORD *)*v20;
  }
  else if (v21 != 15)
  {
    return result;
  }
  v23 = (_QWORD *)*v20;
  v24 = *(_QWORD *)((char *)v20 + 7);
  if (v23 == (_QWORD *)0x637365443A666472 && v24 == 0x6E6F697470697263)
  {
    if (*((char *)a3 + 63) < 0)
    {
      v29 = *((_QWORD *)a3 + 6);
      if (v29 != 2)
      {
        if (v29 != 5)
          return result;
        if (**(_DWORD **)v17 != 1970233953 || *(_BYTE *)(*(_QWORD *)v17 + 4) != 116)
          return result;
        goto LABEL_57;
      }
      v27 = *(_WORD **)v17;
    }
    else
    {
      v26 = *((unsigned __int8 *)a3 + 63);
      v27 = (_WORD *)((char *)a3 + 40);
      if (v26 != 2)
      {
        if (v26 != 5)
          return result;
        if (*(_DWORD *)v17 != 1970233953 || *((_BYTE *)a3 + 44) != 116)
          return result;
LABEL_57:
        MEMORY[0x18D761A14]((char *)a3 + 16, "http://www.w3.org/1999/02/22-rdf-syntax-ns#");
        v31 = "rdf:about";
        goto LABEL_58;
      }
    }
    if (*v27 != 17481)
      return result;
    MEMORY[0x18D761A14]((char *)a3 + 16, "http://www.w3.org/1999/02/22-rdf-syntax-ns#");
    v31 = "rdf:ID";
LABEL_58:
    result = (std::string *)MEMORY[0x18D761A14]((char *)a3 + 40, v31);
    *((_QWORD *)a3 + 11) = 4;
  }
  return result;
}

void ___ZN14TIFFReadPlugin14decodeImageImpEP18IIODecodeParameter12IIOImageTypePP11__IOSurfacePP10__CVBufferPP15CGImageBlockSet_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  char *v5;
  __int128 v6;
  vImagePixelCount v7;
  vImagePixelCount v8;
  size_t v9;
  IIOImageRead *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *TIFFStructure;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char v26;
  char *v27;
  int v28;
  vImage_Buffer dest;
  char *v30;
  __int128 v31;
  int v32;
  int v33;
  int v34;
  int v35;
  char *v36;
  __int128 v37;
  int v38;
  int v39;
  int v40;
  int v41;
  char *v42;
  __int128 v43;
  int v44;
  int v45;
  int v46;
  int v47;
  char *v48;
  __int128 v49;
  int v50;
  int v51;
  int v52;
  int v53;
  char *v54;
  __int128 v55;
  int v56;
  int v57;
  int v58;
  int v59;
  char *v60;
  __int128 v61;
  int v62;
  int v63;
  int v64;
  int v65;
  _OWORD v66[4];
  __int128 v67;
  int v68;
  uint64_t v69;

  v69 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a1 + 40);
  v4 = *(_QWORD *)(a1 + 48) + 40 * a2;
  v5 = *(char **)v4;
  v6 = *(_OWORD *)(v4 + 8);
  v7 = *(unsigned int *)(v4 + 28);
  v68 = *(_DWORD *)(v4 + 24);
  v8 = *(unsigned int *)(v4 + 32);
  v9 = *(unsigned int *)(v4 + 36);
  v67 = v6;
  memset(v66, 0, sizeof(v66));
  v10 = (IIOImageRead *)IIO_Reader::testHeaderSize(*(IIO_Reader **)(v3 + 24));
  IIOImageReadSession::IIOImageReadSession((IIOImageReadSession *)v66, v10);
  TIFFStructure = (_QWORD *)TIFFReadPlugin::loadTIFFStructure((TIFFReadPlugin *)v3, *(GlobalTIFFInfo **)(a1 + 72), (IIOImageReadSession *)v66);
  if (TIFFStructure)
  {
    switch(*(_BYTE *)(v3 + 552))
    {
      case 1:
        v60 = v5;
        v61 = v67;
        v62 = v68;
        v63 = v7;
        v64 = v8;
        v65 = v9;
        v17 = TIFFReadPlugin::decodeSubsampled(v3, (uint64_t)TIFFStructure, (uint64_t *)&v60);
        goto LABEL_11;
      case 2:
        v54 = v5;
        v55 = v67;
        v56 = v68;
        v57 = v7;
        v58 = v8;
        v59 = v9;
        v17 = TIFFReadPlugin::decodeStripChunky(v3, (uint64_t)TIFFStructure, (uint64_t)&v54);
        goto LABEL_11;
      case 3:
        v48 = v5;
        v49 = v67;
        v50 = v68;
        v51 = v7;
        v52 = v8;
        v53 = v9;
        v17 = TIFFReadPlugin::decodeStripPlanar(v3, (uint64_t)TIFFStructure, (uint64_t *)&v48);
        goto LABEL_11;
      case 4:
        v42 = v5;
        v43 = v67;
        v44 = v68;
        v45 = v7;
        v46 = v8;
        v47 = v9;
        v17 = TIFFReadPlugin::decodeTileChunky(v3, (uint64_t)TIFFStructure, (uint64_t)&v42, v11, v12, v13, v14, v15);
        goto LABEL_11;
      case 5:
        v36 = v5;
        v37 = v67;
        v38 = v68;
        v39 = v7;
        v40 = v8;
        v41 = v9;
        v17 = TIFFReadPlugin::decodeTilePlanar(v3, (uint64_t)TIFFStructure, &v36);
        goto LABEL_11;
      case 6:
        v30 = v5;
        v31 = v67;
        v32 = v68;
        v33 = v7;
        v34 = v8;
        v35 = v9;
        v17 = TIFFReadPlugin::decodeRGBAImage(v3, TIFFStructure, (uint64_t)&v30);
LABEL_11:
        *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v17;
        break;
      default:
        LogError("decodeImageImp_block_invoke", 2326, "*** unknown decode mode [%d]\n", &v48);
        break;
    }
    if (!*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24)
      && *(_WORD *)(v3 + 306) == 32
      && *(_WORD *)(v3 + 304) == 8)
    {
      dest.data = v5;
      dest.height = v8;
      dest.width = v7;
      dest.rowBytes = v9;
      if (*(_BYTE *)(v3 + 560))
      {
        if (*(_BYTE *)(v3 + 413))
          vImageUnpremultiplyData_RGBA8888(&dest, &dest, 0x10u);
      }
      else
      {
        if ((_DWORD)v8)
        {
          v25 = 0;
          v26 = 1;
          while (!(_DWORD)v7)
          {
LABEL_24:
            if (++v25 == v8)
            {
              if ((v26 & 1) == 0)
                *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = vImageOverwriteChannelsWithScalar_ARGB8888(0xFFu, &dest, &dest, 1u, 0x10u);
              goto LABEL_27;
            }
          }
          v27 = &v5[(v9 * v25)];
          v28 = v7;
          while (!HIBYTE(*(_DWORD *)v27))
          {
            v26 &= *(_DWORD *)v27 == 0xFFFFFF;
            v27 += 4;
            if (!--v28)
              goto LABEL_24;
          }
        }
LABEL_27:
        if (*(_BYTE *)(v3 + 406) == 1)
          vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
      }
    }
    _cg_TIFFClose((uint64_t)TIFFStructure, v18, v19, v20, v21, v22, v23, v24);
  }
  else
  {
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = -50;
  }
  IIOImageReadSession::~IIOImageReadSession((IIOImageReadSession *)v66);
}

void sub_187E7C4E8(_Unwind_Exception *exception_object, int a2)
{
  uint64_t v2;

  if (a2)
  {
    __cxa_begin_catch(exception_object);
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 32) + 8) + 24) = -50;
    __cxa_end_catch();
    JUMPOUT(0x187E7C4A0);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TIFFReadPlugin::loadTIFFStructure(TIFFReadPlugin *this, GlobalTIFFInfo *a2, IIOImageReadSession *a3)
{
  IOTiffClientData *v6;
  uint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  __int16 v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  __int16 v33;

  v33 = 0;
  if (!a2
    || *((unsigned int *)this + 52) >= (unint64_t)((uint64_t)(*((_QWORD *)a2 + 3) - *((_QWORD *)a2 + 2)) >> 3))
  {
    return 0;
  }
  v6 = (IOTiffClientData *)operator new();
  IOTiffClientData::IOTiffClientData(v6, *((_BYTE *)a2 + 80));
  if (*((_BYTE *)this + 564))
  {
    v7 = *((_QWORD *)a2 + 5);
    v8 = *((unsigned int *)this + 52);
    if (v8 > (*((_QWORD *)a2 + 6) - v7) >> 3)
    {
LABEL_16:
      (*(void (**)(IOTiffClientData *))(*(_QWORD *)v6 + 8))(v6);
      return 0;
    }
    v9 = (_QWORD *)(v7 + 8 * v8);
  }
  else
  {
    v9 = (_QWORD *)(*((_QWORD *)a2 + 2) + 8 * *((unsigned int *)this + 52));
  }
  *((_QWORD *)v6 + 1) = *v9;
  *((_QWORD *)v6 + 2) = a3;
  IIOImageReadSession::rewind((uint64_t)a3);
  v10 = _cg_TIFFClientOpen("tiff data provider decoding", "r", (uint64_t)v6, (uint64_t)myTIFFReadProc, (uint64_t)myTIFFWriteProc, (uint64_t)myTIFFSeekProc, (uint64_t)myTIFFCloseProc, (uint64_t)myTIFFSizeProc, (uint64_t (*)())myTIFFMapFileProc, (uint64_t (*)())myTIFFUnmapFileProc);
  if (!v10)
    goto LABEL_16;
  v17 = v10;
  v18 = *((_DWORD *)this + 52);
  if (v18)
    _cg_TIFFSetDirectory(v10, v18);
  _cg_TIFFGetField(v17, 259, v11, v12, v13, v14, v15, v16, (uint64_t)&v33);
  v25 = v33;
  if ((v33 & 0xFFFE) == 0x808C)
  {
    _cg_TIFFSetField(v17, 65549, v19, v20, v21, v22, v23, v24, 5);
    v25 = v33;
  }
  if ((v25 & 0xFFFE) == 0x8774)
  {
    _cg_TIFFSetField(v17, 65560, v19, v20, v21, v22, v23, v24, 0);
    if (*((_WORD *)this + 229) != 32)
      TIFFReadPlugin::updateTiffStruct((uint64_t)this, v17, v26, v27, v28, v29, v30, v31);
  }
  return v17;
}

void sub_187E7C6F4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C40F2E54FF0);
  _Unwind_Resume(a1);
}

uint64_t TIFFDefaultDirectory(uint64_t a1)
{
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  unsigned int v19;
  char v22;

  v2 = (void *)(a1 + 72);
  v3 = _TIFFGetFields();
  _TIFFSetupFields(a1, (uint64_t)v3, v4, v5, v6, v7, v8, v9, v22);
  _TIFFmemset(v2, 0, 0x188uLL);
  *(_QWORD *)(a1 + 124) = 0x1000100010001;
  *(_QWORD *)(a1 + 132) = 0x10000FFFFFFFFLL;
  *(_DWORD *)(a1 + 168) = 65538;
  *(_OWORD *)(a1 + 96) = xmmword_188210EF0;
  *(_DWORD *)(a1 + 336) = 131074;
  *(_WORD *)(a1 + 340) = 1;
  *(_QWORD *)(a1 + 1248) = _TIFFNoPostDecode;
  *(_QWORD *)(a1 + 1272) = 0;
  *(_QWORD *)(a1 + 1280) = _TIFFVSetField;
  *(_QWORD *)(a1 + 1288) = _TIFFVGetField;
  *(_QWORD *)(a1 + 1296) = 0;
  *(_WORD *)(a1 + 120) = 1;
  *(_QWORD *)(a1 + 112) = 0x1000100000000;
  *(_WORD *)(a1 + 212) = 0;
  *(_QWORD *)(a1 + 216) = 0;
  v16 = *(_QWORD *)(a1 + 1320);
  if (v16)
  {
    v17 = 0;
    v18 = (_QWORD *)(a1 + 1312);
    v19 = 1;
    do
    {
      if (*(_DWORD *)(*v18 + 24 * v17 + 4))
      {
        _TIFFfreeExt(a1, *(char **)(*v18 + 24 * v17 + 16));
        v16 = *(_QWORD *)(a1 + 1320);
      }
      v17 = v19;
    }
    while (v16 > v19++);
    _TIFFfreeExt(a1, *(char **)(a1 + 1312));
    *v18 = 0;
    *(_QWORD *)(a1 + 1320) = 0;
  }
  if (_TIFFextender)
    _TIFFextender(a1);
  _cg_TIFFSetField(a1, 259, v10, v11, v12, v13, v14, v15, 1);
  *(_DWORD *)(a1 + 16) &= 0xFFFFFBF7;
  return 1;
}

uint64_t _TIFFSetupFields(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  unsigned int v14;
  uint64_t v15;
  char *v16;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  if (*(_QWORD *)(a1 + 1256))
  {
    v11 = *(_QWORD *)(a1 + 1264);
    if (v11)
    {
      v12 = 0;
      v13 = (_QWORD *)(a1 + 1256);
      v14 = 1;
      do
      {
        v15 = *(_QWORD *)(*v13 + 8 * v12);
        v16 = *(char **)(v15 + 32);
        if (v16 && *(_WORD *)(v15 + 24) == 65 && *(_DWORD *)(v15 + 12))
        {
          _TIFFfreeExt(a1, v16);
          _TIFFfreeExt(a1, (char *)v15);
          v11 = *(_QWORD *)(a1 + 1264);
        }
        v12 = v14;
      }
      while (v11 > v14++);
      _TIFFfreeExt(a1, *(char **)(a1 + 1256));
      *v13 = 0;
      *(_QWORD *)(a1 + 1264) = 0;
    }
  }
  result = _TIFFMergeFields(a1, *(int **)(a2 + 16), *(unsigned int *)(a2 + 8), a4, a5, a6, a7, a8);
  if (!(_DWORD)result)
    return TIFFErrorExtR(a1, "_TIFFSetupFields", "Setting up field info failed", v19, v20, v21, v22, v23, a9);
  return result;
}

void *_TIFFGetFields()
{
  return &tiffFieldArray;
}

uint64_t _cg_TIFFClose(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t (*v9)(uint64_t);

  if (result)
  {
    v9 = *(uint64_t (**)(uint64_t))(result + 1232);
    v8 = *(_QWORD *)(result + 1200);
    TIFFCleanup(result, (uint64_t)v9, a3, a4, a5, a6, a7, a8);
    return v9(v8);
  }
  return result;
}

void TIFFCleanup(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  BOOL v19;
  unint64_t v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;

  if (*(_DWORD *)(a1 + 12))
    TIFFFlush(a1, a2, a3, a4, a5, a6, a7, a8);
  (*(void (**)(uint64_t))(a1 + 1072))(a1);
  _cg_TIFFFreeDirectory(a1);
  _TIFFCleanupIFDOffsetAndNumberMaps(a1);
  while (1)
  {
    v14 = *(_QWORD *)(a1 + 1304);
    if (!v14)
      break;
    *(_QWORD *)(a1 + 1304) = *(_QWORD *)v14;
    _TIFFfreeExt(a1, *(char **)(v14 + 16));
    _TIFFfreeExt(a1, (char *)v14);
  }
  v15 = *(char **)(a1 + 1120);
  if (v15 && (*(_BYTE *)(a1 + 17) & 2) != 0)
    _TIFFfreeExt(a1, v15);
  if ((*(_BYTE *)(a1 + 17) & 8) != 0)
    (*(void (**)(_QWORD, _QWORD, _QWORD))(a1 + 1192))(*(_QWORD *)(a1 + 1200), *(_QWORD *)(a1 + 1168), *(_QWORD *)(a1 + 1176));
  if (*(_QWORD *)(a1 + 1256) && *(_QWORD *)(a1 + 1264))
  {
    v16 = 0;
    v17 = 1;
    do
    {
      v18 = *(_QWORD *)(*(_QWORD *)(a1 + 1256) + 8 * v16);
      if (*(_QWORD *)(v18 + 32) && *(_WORD *)(v18 + 24) == 65 && TIFFFieldIsAnonymous(v18))
      {
        _TIFFfreeExt(a1, *(char **)(v18 + 32));
        _TIFFfreeExt(a1, (char *)v18);
      }
      v16 = v17;
      v19 = *(_QWORD *)(a1 + 1264) > (unint64_t)v17++;
    }
    while (v19);
    _TIFFfreeExt(a1, *(char **)(a1 + 1256));
  }
  v20 = *(_QWORD *)(a1 + 1320);
  if (v20)
  {
    v21 = 0;
    v22 = 1;
    do
    {
      v23 = *(_QWORD *)(a1 + 1312);
      if (*(_DWORD *)(v23 + 24 * v21 + 4))
      {
        _TIFFfreeExt(a1, *(char **)(v23 + 24 * v21 + 16));
        v20 = *(_QWORD *)(a1 + 1320);
      }
      v21 = v22;
      v19 = v20 > v22++;
    }
    while (v19);
    _TIFFfreeExt(a1, *(char **)(a1 + 1312));
  }
  if (*(_QWORD *)(a1 + 1376))
    TIFFErrorExtR(a1, "TIFFCleanup", "tif_cur_cumulated_mem_alloc = %llu whereas it should be 0", v9, v10, v11, v12, v13, *(_QWORD *)(a1 + 1376));
  _TIFFfreeExt(0, (char *)a1);
}

uint64_t TIFFFieldIsAnonymous(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

void _cg_TIFFFreeDirectory(uint64_t a1)
{
  char *v2;
  char *v3;
  char *v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  char *v20;
  char *v21;
  char *v22;

  _TIFFmemset((void *)(a1 + 72), 0, 0x10uLL);
  v2 = *(char **)(a1 + 144);
  if (v2)
  {
    _TIFFfreeExt(a1, v2);
    *(_QWORD *)(a1 + 144) = 0;
  }
  v3 = *(char **)(a1 + 152);
  if (v3)
  {
    _TIFFfreeExt(a1, v3);
    *(_QWORD *)(a1 + 152) = 0;
  }
  v4 = *(char **)(a1 + 184);
  if (v4)
  {
    _TIFFfreeExt(a1, v4);
    *(_QWORD *)(a1 + 184) = 0;
  }
  v5 = *(char **)(a1 + 192);
  if (v5)
  {
    _TIFFfreeExt(a1, v5);
    *(_QWORD *)(a1 + 192) = 0;
  }
  v6 = *(char **)(a1 + 200);
  if (v6)
  {
    _TIFFfreeExt(a1, v6);
    *(_QWORD *)(a1 + 200) = 0;
  }
  v7 = *(char **)(a1 + 216);
  if (v7)
  {
    _TIFFfreeExt(a1, v7);
    *(_QWORD *)(a1 + 216) = 0;
  }
  v8 = *(char **)(a1 + 328);
  if (v8)
  {
    _TIFFfreeExt(a1, v8);
    *(_QWORD *)(a1 + 328) = 0;
  }
  v9 = *(char **)(a1 + 384);
  if (v9)
  {
    _TIFFfreeExt(a1, v9);
    *(_QWORD *)(a1 + 384) = 0;
  }
  v10 = *(char **)(a1 + 368);
  if (v10)
  {
    _TIFFfreeExt(a1, v10);
    *(_QWORD *)(a1 + 368) = 0;
  }
  v11 = *(char **)(a1 + 344);
  if (v11)
  {
    _TIFFfreeExt(a1, v11);
    *(_QWORD *)(a1 + 344) = 0;
  }
  v12 = *(char **)(a1 + 352);
  if (v12)
  {
    _TIFFfreeExt(a1, v12);
    *(_QWORD *)(a1 + 352) = 0;
  }
  v13 = *(char **)(a1 + 360);
  if (v13)
  {
    _TIFFfreeExt(a1, v13);
    *(_QWORD *)(a1 + 360) = 0;
  }
  v14 = *(char **)(a1 + 232);
  if (v14)
  {
    _TIFFfreeExt(a1, v14);
    *(_QWORD *)(a1 + 232) = 0;
  }
  v15 = *(char **)(a1 + 240);
  if (v15)
  {
    _TIFFfreeExt(a1, v15);
    *(_QWORD *)(a1 + 240) = 0;
  }
  *(_DWORD *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 76) &= 0xFFFFFE7F;
  v16 = *(_DWORD *)(a1 + 408);
  if (v16 >= 1)
  {
    v17 = 0;
    v18 = 16;
    do
    {
      v19 = *(char **)(*(_QWORD *)(a1 + 416) + v18);
      if (v19)
      {
        _TIFFfreeExt(a1, v19);
        v16 = *(_DWORD *)(a1 + 408);
      }
      ++v17;
      v18 += 24;
    }
    while (v17 < v16);
  }
  *(_DWORD *)(a1 + 408) = 0;
  v20 = *(char **)(a1 + 416);
  if (v20)
  {
    _TIFFfreeExt(a1, v20);
    *(_QWORD *)(a1 + 416) = 0;
  }
  v21 = *(char **)(a1 + 400);
  if (v21)
  {
    _TIFFfreeExt(a1, v21);
    *(_QWORD *)(a1 + 400) = 0;
  }
  _TIFFmemset((void *)(a1 + 256), 0, 0x20uLL);
  _TIFFmemset((void *)(a1 + 288), 0, 0x20uLL);
  *(_QWORD *)(a1 + 432) = 0;
  *(_QWORD *)(a1 + 440) = 0;
  v22 = *(char **)(a1 + 456);
  if (v22)
  {
    _TIFFfreeExt(a1, v22);
    *(_QWORD *)(a1 + 456) = 0;
    *(_DWORD *)(a1 + 448) = 0;
  }
}

void _TIFFCleanupIFDOffsetAndNumberMaps(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 48);
  if (v2)
  {
    TIFFHashSetDestroy(v2);
    *(_QWORD *)(a1 + 48) = 0;
  }
  v3 = *(_QWORD *)(a1 + 56);
  if (v3)
  {
    TIFFHashSetDestroy(v3);
    *(_QWORD *)(a1 + 56) = 0;
  }
}

void TIFFHashSetDestroy(uint64_t a1)
{
  int v2;
  uint64_t i;
  uint64_t v4;
  _QWORD *v5;
  void (*v6)(_QWORD);
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;

  if (a1)
  {
    v2 = *(_DWORD *)(a1 + 40);
    if (v2 >= 1)
    {
      for (i = 0; i < v2; *(_QWORD *)(v4 + 8 * i++) = 0)
      {
        v4 = *(_QWORD *)(a1 + 24);
        v5 = *(_QWORD **)(v4 + 8 * i);
        if (v5)
        {
          do
          {
            v6 = *(void (**)(_QWORD))(a1 + 16);
            if (v6)
              v6(*v5);
            v7 = (_QWORD *)v5[1];
            free(v5);
            v5 = v7;
          }
          while (v7);
          v4 = *(_QWORD *)(a1 + 24);
          v2 = *(_DWORD *)(a1 + 40);
        }
      }
    }
    *(_BYTE *)(a1 + 60) = 0;
    free(*(void **)(a1 + 24));
    v8 = *(_QWORD **)(a1 + 48);
    if (v8)
    {
      do
      {
        v9 = (_QWORD *)v8[1];
        free(v8);
        v8 = v9;
      }
      while (v9);
    }
    free((void *)a1);
  }
}

uint64_t TIFFReadPlugin::initialize(TIFFReadPlugin *this, IIODictionary *a2)
{
  int isValidTIFF;
  int v5;
  const __CFDictionary *ObjectForKey;
  const __CFDictionary *v7;
  CFTypeID v8;
  const __CFData *v9;
  unsigned int Uint32ForKey;
  IIOImageRead *v11;
  IIOImageRead *v12;
  IOTiffClientData *v13;
  int v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  unint64_t v20;
  char v21;
  _WORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _WORD *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t updated;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _WORD *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  unsigned int v57;
  int v58;
  __n128 v59;
  uint64_t v60;
  int v61;
  int v62;
  int v63;
  int v64;
  unsigned int v65;
  unsigned int v66;
  unint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  unsigned int v76;
  unsigned int v77;
  int v78;
  char v79;
  int v80;
  int v81;
  int v82;
  BOOL v83;
  char v84;
  unsigned int v85;
  int v86;
  int v87;
  char v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  int v97;
  int v98;
  int v99;
  BOOL v100;
  int v101;
  uint64_t v102;
  uint64_t v104;
  uint64_t v105;
  unsigned __int16 *v106;

  v106 = 0;
  isValidTIFF = *((unsigned __int8 *)this + 355);
  if (isValidTIFF == 255)
  {
    isValidTIFF = TIFFReadPlugin::isValidTIFF(this);
    *((_BYTE *)this + 355) = isValidTIFF;
  }
  if (!isValidTIFF)
  {
    LogError("initialize", 494, "*** invalid TIFF file\n");
    goto LABEL_45;
  }
  IIODictionary::getBoolForKey(*((IIODictionary **)this + 6), CFSTR("kCGImageSourceShouldAllowFloat"));
  v5 = IIOSkipMetadata(*((IIODictionary **)this + 6));
  IIOSkipXMP_and_IPTC(*((IIODictionary **)this + 6));
  ObjectForKey = IIODictionary::getObjectForKey(*((IIODictionary **)this + 6), CFSTR("kCGImageSourceXMPSidecar"));
  if (ObjectForKey)
  {
    v7 = ObjectForKey;
    v8 = CFGetTypeID(ObjectForKey);
    if (v8 == CFDataGetTypeID())
      v9 = v7;
    else
      v9 = 0;
  }
  else
  {
    v9 = 0;
  }
  if (IIODictionary::containsKey(*((IIODictionary **)this + 6), CFSTR("kCGImageSourceSubsampleFactor")))
    Uint32ForKey = IIODictionary::getUint32ForKey(*((IIODictionary **)this + 6), CFSTR("kCGImageSourceSubsampleFactor"));
  else
    Uint32ForKey = 0;
  v11 = IIOImageReadSession::globalInfoForType(*((IIOImageReadSession **)this + 3), 1414088262);
  if (!v11)
  {
    _cg_jpeg_mem_term("initialize", 508, "*** globalInfoForType('TIFF') failed...\n");
    goto LABEL_45;
  }
  v12 = v11;
  if (*((unsigned int *)this + 52) >= (unint64_t)((uint64_t)(*((_QWORD *)v11 + 3) - *((_QWORD *)v11 + 2)) >> 3))
  {
    _cg_jpeg_mem_term("initialize", 510, "*** bad imageOffsets...\n");
    goto LABEL_45;
  }
  v13 = (IOTiffClientData *)operator new();
  IOTiffClientData::IOTiffClientData(v13, *((_BYTE *)v12 + 80));
  v14 = *((unsigned __int8 *)this + 216);
  if (v14 == 2)
  {
    v15 = *((_QWORD *)v12 + 5);
    if (*((_QWORD *)v12 + 6) == v15)
    {
      if (TIFFReadPlugin::initPhotoshopThumbnail(this, *((_QWORD *)v12 + 8), *((_QWORD *)v12 + 9), a2))
      {
        v59 = _cg_jpeg_mem_term("initialize", 533, "*** pugin changed --> initPhotoshopThumbnail...\n");
        v60 = 4294967247;
        goto LABEL_48;
      }
      v59 = _cg_jpeg_mem_term("initialize", 537, "    no thumbnail found\n");
LABEL_47:
      v60 = 4294967246;
LABEL_48:
      if (!*((_QWORD *)this + 55))
        (*(void (**)(IOTiffClientData *, __n128))(*(_QWORD *)v13 + 8))(v13, v59);
      goto LABEL_50;
    }
    v16 = (_QWORD *)(v15 + 8 * *((unsigned int *)this + 52));
  }
  else
  {
    v16 = (_QWORD *)(*((_QWORD *)v12 + 2) + 8 * *((unsigned int *)this + 52));
  }
  v17 = *((_QWORD *)this + 3);
  *((_QWORD *)v13 + 1) = *v16;
  *((_QWORD *)v13 + 2) = v17;
  *((_BYTE *)this + 564) = v14 == 2;
  v18 = _cg_TIFFClientOpen("tiff data provider init", "r", (uint64_t)v13, (uint64_t)myTIFFReadProc, (uint64_t)myTIFFWriteProc, (uint64_t)myTIFFSeekProc, (uint64_t)myTIFFCloseProc, (uint64_t)myTIFFSizeProc, (uint64_t (*)())myTIFFMapFileProc, (uint64_t (*)())myTIFFUnmapFileProc);
  *((_QWORD *)this + 55) = v18;
  if (!v18)
  {
    v59 = _cg_jpeg_mem_term("initialize", 551, "*** TIFFClientOpen failed - NULL _tifPtr\n");
    goto LABEL_47;
  }
  v19 = *((_DWORD *)this + 52);
  if (v19)
    _cg_TIFFSetDirectory(v18, v19);
  v20 = *((_QWORD *)v13 + 1);
  if (!v20)
  {
    _cg_jpeg_mem_term("initialize", 561, "*** invalid idfOffset (NULL)\n");
    goto LABEL_45;
  }
  v21 = IIOMetadataFlagsFromImageSourceOptions(*((IIODictionary **)this + 6));
  ReadTiffMetadata(*((IIOImageReadSession **)this + 3), *((CGImageMetadata **)this + 8), v20, *((unsigned __int8 *)v12 + 8), v9, v21);
  v22 = (_WORD *)((char *)this + 464);
  if (!_cg_TIFFGetField(*((_QWORD *)this + 55), 259, v23, v24, v25, v26, v27, v28, (uint64_t)this + 464))
    *v22 = 1;
  v35 = (_WORD *)((char *)this + 456);
  if (!_cg_TIFFGetFieldDefaulted(*((_QWORD *)this + 55), 262, v29, v30, v31, v32, v33, v34, (uint64_t)this + 456))
  {
    if ((unsigned __int16)*v22 - 3 > 1)
    {
      _cg_jpeg_mem_term("initialize", 577, "*** could not get 'TIFFTAG_PHOTOMETRIC'\n");
      goto LABEL_45;
    }
    _cg_TIFFSetField(*((_QWORD *)this + 55), 262, v36, v37, v38, v39, v40, v41, 1);
  }
  updated = TIFFReadPlugin::updateTiffStruct((uint64_t)this, *((_QWORD *)this + 55), v36, v37, v38, v39, v40, v41);
  if ((_DWORD)updated)
  {
    v104 = updated;
    _cg_jpeg_mem_term("initialize", 584, "*** updateTiffStruct failed (%d)\n");
LABEL_172:
    v60 = v104;
    goto LABEL_50;
  }
  v49 = (_WORD *)((char *)this + 462);
  _cg_TIFFGetFieldDefaulted(*((_QWORD *)this + 55), 338, v43, v44, v45, v46, v47, v48, (uint64_t)this + 462);
  v56 = 0;
  v57 = *((unsigned __int16 *)this + 228);
  if (v57 > 0x8022)
  {
    if (v57 == 32803)
      goto LABEL_59;
    if (v57 == 32844)
    {
      v56 = 0;
      *v35 = 1;
      goto LABEL_59;
    }
    if (v57 != 32845)
      goto LABEL_55;
    if (*((_WORD *)this + 244) == 3)
    {
      v61 = *((unsigned __int16 *)this + 229);
      if (v61 == 16)
      {
        _cg_TIFFSetField(*((_QWORD *)this + 55), 65560, v50, v51, v52, v53, v54, v55, 0);
      }
      else if (v61 == 32)
      {
        _cg_TIFFSetField(*((_QWORD *)this + 55), 65560, v50, v51, v52, v53, v54, v55, 0);
        *((_WORD *)this + 229) = 32;
        *((_WORD *)this + 234) = 3;
      }
      v56 = 1;
      goto LABEL_59;
    }
    _cg_jpeg_mem_term("initialize", 594, "*** ERROR: corrupt logLUV / CIE Log2(L)(u',v') image\n");
LABEL_45:
    v60 = 4294967246;
LABEL_50:
    kdebug_trace();
    return v60;
  }
  if (v57 > 0xA)
    goto LABEL_55;
  if (((1 << v57) & 0x77) != 0)
    goto LABEL_59;
  if (((1 << v57) & 0x700) == 0)
  {
    if (v57 == 3)
    {
      if (*((unsigned __int16 *)this + 229) >= 9u)
      {
        _cg_jpeg_mem_term("initialize", 621, "*** ERROR: PHOTOMETRIC_PALETTE with %d bpc - CoreGraphics requires bpc <=8 for indexed colorspaces\n");
        return 0;
      }
      goto LABEL_56;
    }
LABEL_55:
    _cg_jpeg_mem_term("initialize", 640, "*** ERROR: unexpected TIFFTAG_PHOTOMETRIC [%d]\n", *((unsigned __int16 *)this + 228));
LABEL_56:
    v56 = 0;
    goto LABEL_59;
  }
  v56 = 0;
  v58 = *((unsigned __int16 *)this + 229);
  if (v58 != 8 && v58 != 16)
  {
    _cg_jpeg_mem_term("initialize", 617, "*** LAB requires 8 or 16 bpc -- got %d\n");
    return 0;
  }
LABEL_59:
  v62 = (unsigned __int16)*v22;
  if ((v62 - 32908) < 2)
  {
    _cg_TIFFSetField(*((_QWORD *)this + 55), 65549, v50, v51, v52, v53, v54, v55, 5);
  }
  else
  {
    if ((v62 - 34676) > 1)
      goto LABEL_65;
    if ((unsigned __int16)*v35 != 32845)
    {
      _cg_jpeg_mem_term("initialize", 652, "*** SGILOG/SGILOG24 requires PHOTOMETRIC_LOGLUV (got: %d)\n");
      return 0;
    }
    _cg_TIFFSetField(*((_QWORD *)this + 55), 65560, v50, v51, v52, v53, v54, v55, 0);
  }
  *((_WORD *)this + 229) = 32;
  *((_WORD *)this + 234) = 3;
  v56 = 1;
LABEL_65:
  v63 = *((unsigned __int16 *)this + 244);
  if (v63 == 1)
  {
    if (*v35 == 1)
    {
      v66 = (unsigned __int16)*v22;
      if ((v66 > 8 || ((1 << v66) & 0x1BA) == 0) && v66 != 32773)
        goto LABEL_81;
    }
    else if (!*v35)
    {
      v64 = *((unsigned __int16 *)this + 229);
      if (v64 == 1)
        goto LABEL_81;
      if (v64 == 8)
      {
        v65 = (unsigned __int16)*v22;
        if (v65 == 5 || v65 == 8)
          goto LABEL_81;
      }
      else
      {
        v65 = (unsigned __int16)*v22;
      }
      if (v65 > 0x808B || v65 == 1 || v65 == 32773)
LABEL_81:
        *((_BYTE *)this + 346) = 1;
    }
  }
  if (!*v49)
  {
    v67 = (unsigned __int16)*v35;
    if (v67 <= 3 && dword_1882106F0[v67] + 1 == v63)
      *v49 = 1;
  }
  if (*((_BYTE *)this + 561)
    && ((unsigned __int16)(*v22 + 32626) == 65534 || (unsigned __int16)(*v22 + 32626) == 0xFFFF))
  {
    _cg_jpeg_mem_term("initialize", 724, "*** ERROR: tiled PIXARLOG/PIXARFILM not supported\n", v105, &v106);
    return 0;
  }
  v68 = TIFFReadPlugin::sanityCheck(this);
  if ((_DWORD)v68)
  {
    v104 = v68;
    _cg_jpeg_mem_term("initialize", 730, "*** ERROR: sanityCheck failed (%d)\n");
    goto LABEL_172;
  }
  TIFFReadPlugin::updateSubsample(this, Uint32ForKey);
  v75 = *((_QWORD *)this + 56);
  *(_QWORD *)((char *)this + 228) = v75;
  v76 = *((unsigned __int16 *)this + 244);
  *((_WORD *)this + 122) = v76;
  v77 = *((unsigned __int16 *)this + 229);
  *((_WORD *)this + 120) = v77;
  v78 = *((unsigned __int16 *)this + 230);
  *((_WORD *)this + 121) = v78;
  *((_BYTE *)this + 246) = 0;
  *((_DWORD *)this + 59) = (v75 * v78 + 7) >> 3;
  if (*((_WORD *)this + 234) == 3)
  {
    *((_BYTE *)this + 345) = 1;
    *((_BYTE *)this + 249) = 1;
    if (v77 == 32)
      v79 = 2;
    else
      v79 = 1;
    *((_BYTE *)this + 247) = v79;
    *((_WORD *)this + 136) = v77;
  }
  v80 = (unsigned __int16)*v35;
  if (v80 == 3)
  {
    v76 = 1;
    *((_WORD *)this + 122) = 1;
  }
  *((_BYTE *)this + 344) = 1;
  v81 = *((unsigned __int16 *)this + 233);
  *((_BYTE *)this + 562) = v81 == 2;
  v82 = *((unsigned __int16 *)this + 232);
  if (v82 == 1)
  {
    if (*((_BYTE *)this + 561))
      v83 = 1;
    else
      v83 = v81 == 2;
    v84 = !v83;
  }
  else
  {
    v84 = 0;
  }
  *((_BYTE *)this + 347) = v84;
  v85 = *((unsigned __int16 *)this + 231);
  if (v80 == 2)
  {
    if (!*((_WORD *)this + 231))
    {
      if (v77 <= 8)
      {
        *((_QWORD *)this + 34) = 0x5000400200008;
        *((_DWORD *)this + 67) = (4 * *((_DWORD *)this + 65) + 15) & 0xFFFFFFF0;
      }
      goto LABEL_133;
    }
    if (v77 == 8)
    {
      if (v106)
      {
        v86 = *v106;
        if (v86 == 2)
        {
          v86 = 3;
          *((_BYTE *)this + 246) = 3;
LABEL_162:
          if (v85 >= 2)
          {
LABEL_163:
            if (v76 >= 5)
            {
              *((_WORD *)this + 138) = 4;
              *((_DWORD *)this + 68) = 2097160;
              *((_DWORD *)this + 67) = 4 * v75;
            }
          }
LABEL_128:
          *((_BYTE *)this + 278) = v86;
          goto LABEL_129;
        }
        if (v86 == 1)
        {
          *((_BYTE *)this + 246) = 1;
          *((_BYTE *)this + 560) = 1;
          goto LABEL_162;
        }
      }
      if (v85 != 1)
      {
        v86 = 5;
        *((_BYTE *)this + 246) = 5;
        goto LABEL_163;
      }
      goto LABEL_126;
    }
LABEL_113:
    if (!v106)
      goto LABEL_116;
    v87 = *v106;
    if (v87 == 1)
    {
      v86 = 1;
      *((_BYTE *)this + 246) = 1;
      *((_BYTE *)this + 278) = 1;
      if ((v80 - 8) <= 2)
      {
        *((_BYTE *)this + 246) = 3;
        *((_BYTE *)this + 278) = 3;
        *((_BYTE *)this + 563) = 1;
        goto LABEL_133;
      }
LABEL_129:
      *((_BYTE *)this + 563) = 0;
      if (v80 == 3 && v86 == 1)
      {
        v88 = 3;
        *((_BYTE *)this + 246) = 3;
        goto LABEL_132;
      }
      goto LABEL_133;
    }
    if (v87 != 2)
    {
LABEL_116:
      if (v85 != 1)
      {
        v86 = 5;
LABEL_127:
        *((_BYTE *)this + 246) = v86;
        goto LABEL_128;
      }
    }
LABEL_126:
    v86 = 3;
    goto LABEL_127;
  }
  if (*((_WORD *)this + 231))
    goto LABEL_113;
  if (v80 == 6 && v82 != 7)
  {
    v88 = 5;
LABEL_132:
    *((_BYTE *)this + 278) = v88;
  }
LABEL_133:
  v89 = TIFFReadPlugin::handleColorSpace(this, v5, v69, v70, v71, v72, v73, v74);
  if ((_DWORD)v89)
  {
    v60 = v89;
    _cg_jpeg_mem_term("initialize", 862, "*** ERROR: handleColorSpace failed (%d)\n", v89);
    goto LABEL_50;
  }
  TIFFReadPlugin::calculateBlockCount(this);
  if (*((_DWORD *)this + 26) == 1)
  {
    if (*((_DWORD *)this + 81) == 1380401696)
    {
      v97 = *((unsigned __int16 *)this + 121);
      if (v97 == 32 || v97 == 24)
      {
        *((_DWORD *)this + 68) = 2097160;
        *((_WORD *)this + 138) = 4;
        if (!*((_BYTE *)this + 246))
          *((_BYTE *)this + 278) = 5;
        *((_BYTE *)this + 279) = 0;
        *((_DWORD *)this + 67) = (4 * *((_DWORD *)this + 65) + 15) & 0xFFFFFFF0;
      }
    }
  }
  else
  {
    v98 = *((unsigned __int8 *)this + 247);
    v99 = (v98 << 12) | (*((unsigned __int8 *)this + 248) << 16);
    v100 = *((_BYTE *)this + 249) != 0;
    *((_BYTE *)this + 278) = *((_BYTE *)this + 246) & 0x1F;
    *((_BYTE *)this + 279) = v98 & 7;
    *((_BYTE *)this + 280) = BYTE2(v99) & 0xF;
    *((_BYTE *)this + 281) = v100;
  }
  if (v56)
    TIFFReadPlugin::updateTiffStruct((uint64_t)this, *((_QWORD *)this + 55), v91, v92, v93, v94, v95, v96);
  *((_BYTE *)this + 552) = 2;
  if (*((_WORD *)this + 158))
  {
    LOBYTE(v101) = 1;
LABEL_153:
    *((_BYTE *)this + 552) = v101;
    goto LABEL_154;
  }
  v101 = (unsigned __int16)*v35;
  if (v101 == 6)
    goto LABEL_153;
  if (*((_BYTE *)this + 561))
  {
    if (*((_BYTE *)this + 562))
      LOBYTE(v101) = 5;
    else
      LOBYTE(v101) = 4;
    goto LABEL_153;
  }
  if (*((_BYTE *)this + 562))
  {
    LOBYTE(v101) = 3;
    goto LABEL_153;
  }
LABEL_154:
  if (*((_WORD *)this + 120) == 8)
    *((_BYTE *)this + 350) = 1;
  *((_WORD *)this + 188) = 1;
  v102 = *((_QWORD *)this + 55);
  if (!v102)
    return 0;
  _cg_TIFFClose(v102, v90, v91, v92, v93, v94, v95, v96);
  v60 = 0;
  *((_QWORD *)this + 55) = 0;
  return v60;
}

void sub_187E7D928(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C40F2E54FF0);
  _Unwind_Resume(a1);
}

IIODictionary *IIOMetadataFlagsFromImageSourceOptions(IIODictionary *result)
{
  IIODictionary *v1;
  unsigned int v2;

  if (result)
  {
    v1 = result;
    v2 = IIOSkipMetadata(result);
    if (IIOSkipXMP_and_IPTC(v1))
      v2 |= 2u;
    if (IIODictionary::getBoolForKey(v1, CFSTR("kCGImageSourceAddThumbnailInformation")))
      v2 |= 4u;
    if (IIODictionary::getBoolForKey(v1, CFSTR("kCGImageSourceShouldPreferIPTCToEXIF")))
      return (IIODictionary *)(v2 | 8);
    else
      return (IIODictionary *)v2;
  }
  return result;
}

uint64_t _cg_TIFFClientOpen(const char *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t (*a9)(), uint64_t (*a10)())
{
  return TIFFClientOpenExt(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, 0);
}

uint64_t TIFFClientOpenExt(const char *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t (*a9)(), uint64_t (*a10)(), uint64_t a11)
{
  int v19;
  int v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v28;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t (*v41)();
  uint64_t (*v42)();
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unsigned int v48;
  int v49;
  unsigned __int8 *v50;
  int v51;
  _WORD *v52;
  uint64_t v53;
  uint64_t v54;
  uint8x8_t v55;
  int v56;
  int v57;
  __int16 v58;
  const void *v59;
  _BYTE *v60;
  char *v61;
  int v62;
  int v63;
  unsigned int v64;
  int v65;
  uint64_t v66;
  char v68;
  uint64_t v69;
  _QWORD __dst[2];

  v19 = _TIFFgetMode((_QWORD *)a11, a3, a2, "TIFFClientOpenExt", a5, a6, a7, a8);
  if (v19 == -1)
    return 0;
  v20 = v19;
  v21 = (void *)(strlen(a1) + 1385);
  if (a11)
  {
    v26 = *(_QWORD *)(a11 + 32);
    if (v26 >= 1 && (uint64_t)v21 > v26)
    {
      _TIFFErrorEarly((_QWORD *)a11, a3, "TIFFClientOpenExt", "%s: Memory allocation of %llu bytes is beyond the %llu byte limit defined in open options", v22, v23, v24, v25, (char)a1);
      return 0;
    }
    v28 = *(_QWORD *)(a11 + 40);
    if (v28 >= 1 && (uint64_t)v21 > v28)
    {
      _TIFFErrorEarly((_QWORD *)a11, a3, "TIFFClientOpenExt", "%s: Memory allocation of %llu bytes is beyond the %llu cumulated byte limit defined in open options", v22, v23, v24, v25, (char)a1);
      return 0;
    }
  }
  v69 = a8;
  v30 = _TIFFmalloc(v21);
  v35 = (uint64_t)v30;
  if (!v30)
  {
    _TIFFErrorEarly((_QWORD *)a11, a3, "TIFFClientOpenExt", "%s: Out of memory (TIFF structure)", v31, v32, v33, v34, (char)a1);
    return v35;
  }
  _TIFFmemset(v30, 0, 0x568uLL);
  *(_QWORD *)v35 = v35 + 1384;
  strcpy((char *)(v35 + 1384), a1);
  *(_DWORD *)(v35 + 12) = v20 & 0xFFFFF9FF;
  *(_QWORD *)(v35 + 888) = 0;
  *(_QWORD *)(v35 + 880) = -1;
  *(_DWORD *)(v35 + 876) = -1;
  *(_QWORD *)(v35 + 1200) = a3;
  *(_QWORD *)(v35 + 1208) = a4;
  *(_QWORD *)(v35 + 1216) = a5;
  *(_QWORD *)(v35 + 1224) = a6;
  *(_QWORD *)(v35 + 1232) = a7;
  v41 = _tiffDummyMapProc;
  if (a9)
    v41 = a9;
  *(_QWORD *)(v35 + 1240) = v69;
  *(_QWORD *)(v35 + 1184) = v41;
  v42 = _tiffDummyUnmapProc;
  if (a10)
    v42 = a10;
  *(_QWORD *)(v35 + 1192) = v42;
  if (a11)
  {
    *(_OWORD *)(v35 + 1328) = *(_OWORD *)a11;
    *(_OWORD *)(v35 + 1344) = *(_OWORD *)(a11 + 16);
    *(_OWORD *)(v35 + 1360) = *(_OWORD *)(a11 + 32);
  }
  if (!a4 || !a5 || !a6 || !a7 || !v69)
  {
    TIFFErrorExtR(v35, "TIFFClientOpenExt", "One of the client procedures is NULL pointer.", v36, v37, v38, v39, v40, v68);
    _TIFFfree((void *)v35);
    return 0;
  }
  _TIFFSetDefaultCompressionState(v35);
  if (v20)
    v48 = 1;
  else
    v48 = 2049;
  *(_DWORD *)(v35 + 16) = v48;
  if ((v20 | 2) == 2)
  {
    v48 |= 0x8000u;
    *(_DWORD *)(v35 + 16) = v48;
  }
  LOBYTE(v49) = *a2;
  if (*a2)
  {
    v50 = (unsigned __int8 *)(a2 + 1);
    while (1)
    {
      v49 = (char)v49;
      if ((char)v49 <= 97)
        break;
      if (v49 > 103)
      {
        if (v49 == 104)
        {
          v48 |= 0x10000u;
        }
        else
        {
          if (v49 != 109 || v20)
            goto LABEL_60;
          v48 &= ~0x800u;
        }
        goto LABEL_59;
      }
      if (v49 != 98)
      {
        if (v49 != 99 || v20)
          goto LABEL_60;
        v48 &= ~0x8000u;
        goto LABEL_59;
      }
      if ((v20 & 0x200) != 0)
      {
        v48 |= 0x80u;
LABEL_59:
        *(_DWORD *)(v35 + 16) = v48;
      }
LABEL_60:
      v51 = *v50++;
      LOBYTE(v49) = v51;
      if (!v51)
        goto LABEL_61;
    }
    switch(v49)
    {
      case 'B':
        goto LABEL_50;
      case 'C':
        if (v20)
          goto LABEL_60;
        v48 |= 0x8000u;
        goto LABEL_59;
      case 'D':
        v48 |= 0x1000000u;
        goto LABEL_59;
      case 'E':
      case 'F':
      case 'G':
      case 'I':
      case 'J':
      case 'K':
      case 'N':
        goto LABEL_60;
      case 'H':
        TIFFWarningExtR(v35, a1, "H(ost) mode is deprecated. Since libtiff 4.5.1, it is an alias of 'B' / FILLORDER_MSB2LSB.", v43, v44, v45, v46, v47, v68);
        v48 = *(_DWORD *)(v35 + 16);
LABEL_50:
        v48 = v48 & 0xFFFFFFFC | 1;
        goto LABEL_59;
      case 'L':
        v48 = v48 & 0xFFFFFFFC | 2;
        goto LABEL_59;
      case 'M':
        if (v20)
          goto LABEL_60;
        v48 |= 0x800u;
        break;
      case 'O':
        if (v20)
          goto LABEL_60;
        v48 |= 0x3000000u;
        break;
      default:
        if (v49 != 56 || (v20 & 0x200) == 0)
          goto LABEL_60;
        v48 |= 0x80000u;
        break;
    }
    goto LABEL_59;
  }
LABEL_61:
  if ((v20 & 0x400) != 0
    || (v52 = (_WORD *)(v35 + 856),
        (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(v35 + 1208))(*(_QWORD *)(v35 + 1200), v35 + 856, 8) != 8))
  {
    if (!*(_DWORD *)(v35 + 12))
    {
LABEL_102:
      v61 = "Cannot read TIFF header";
      goto LABEL_103;
    }
    v57 = *(_DWORD *)(v35 + 16);
    if ((v57 & 0x80) != 0)
      v58 = 19789;
    else
      v58 = 18761;
    *(_WORD *)(v35 + 856) = v58;
    v59 = (const void *)(v35 + 856);
    __dst[0] = 0;
    __dst[1] = 0;
    if ((v57 & 0x80000) != 0)
    {
      *(_DWORD *)(v35 + 858) = 524331;
      *(_WORD *)(v35 + 862) = 0;
      *(_QWORD *)(v35 + 864) = 0;
      *(_WORD *)(v35 + 872) = 16;
      _TIFFmemcpy(__dst, v59, 0x10uLL);
      if ((*(_BYTE *)(v35 + 16) & 0x80) != 0)
      {
        TIFFSwabShort((_BYTE *)__dst + 2);
        v60 = (char *)__dst + 4;
        goto LABEL_78;
      }
    }
    else
    {
      *(_WORD *)(v35 + 858) = 42;
      *(_DWORD *)(v35 + 860) = 0;
      *(_WORD *)(v35 + 872) = 8;
      _TIFFmemcpy(__dst, v59, 0x10uLL);
      if ((*(_BYTE *)(v35 + 16) & 0x80) != 0)
      {
        v60 = (char *)__dst + 2;
LABEL_78:
        TIFFSwabShort(v60);
      }
    }
    (*(void (**)(_QWORD, _QWORD, _QWORD))(v35 + 1224))(*(_QWORD *)(v35 + 1200), 0, 0);
    if ((*(uint64_t (**)(_QWORD, _QWORD *, _QWORD))(v35 + 1216))(*(_QWORD *)(v35 + 1200), __dst, *(unsigned __int16 *)(v35 + 872)) == *(unsigned __int16 *)(v35 + 872))
    {
      if (!TIFFDefaultDirectory(v35))
        goto LABEL_104;
      *(_QWORD *)(v35 + 24) = 0;
      *(_QWORD *)(v35 + 40) = 0;
      *(_DWORD *)(v35 + 64) = 0;
      return v35;
    }
    v61 = "Error writing TIFF header";
LABEL_103:
    TIFFErrorExtR(v35, a1, v61, v43, v44, v45, v46, v47, v68);
    goto LABEL_104;
  }
  v56 = (unsigned __int16)*v52;
  if (v56 != 18761)
  {
    if (v56 == 19789)
    {
      *(_DWORD *)(v35 + 16) |= 0x80u;
    }
    else if (v56 != 20549)
    {
      TIFFErrorExtR(v35, a1, "Not a TIFF or MDI file, bad magic number %hu (0x%hx)", v43, v44, v45, v46, v47, *v52);
      goto LABEL_104;
    }
  }
  if ((*(_BYTE *)(v35 + 16) & 0x80) != 0)
    TIFFSwabShort((_BYTE *)(v35 + 858));
  v62 = *(unsigned __int16 *)(v35 + 858);
  if ((v62 & 0xFFFE) != 0x2A)
  {
    TIFFErrorExtR(v35, a1, "Not a TIFF file, bad version number %hu (0x%hx)", v43, v44, v45, v46, v47, *(_WORD *)(v35 + 858));
    goto LABEL_104;
  }
  if (v62 == 42)
  {
    v63 = *(_DWORD *)(v35 + 16);
    if ((v63 & 0x80) != 0)
    {
      TIFFSwabLong((__int32 *)(v35 + 860), v55);
      v63 = *(_DWORD *)(v35 + 16);
    }
    *(_WORD *)(v35 + 872) = 8;
    goto LABEL_91;
  }
  if ((*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(v35 + 1208))(*(_QWORD *)(v35 + 1200), v35 + 864, 8) != 8)
    goto LABEL_102;
  if ((*(_BYTE *)(v35 + 16) & 0x80) != 0)
  {
    TIFFSwabShort((_BYTE *)(v35 + 860));
    TIFFSwabLong8((int8x8_t *)(v35 + 864));
  }
  if (*(_WORD *)(v35 + 860) != 8)
  {
    TIFFErrorExtR(v35, a1, "Not a TIFF file, bad BigTIFF offsetsize %hu (0x%hx)", v43, v44, v45, v46, v47, *(_WORD *)(v35 + 860));
    goto LABEL_104;
  }
  if (*(_WORD *)(v35 + 862))
  {
    TIFFErrorExtR(v35, a1, "Not a TIFF file, bad BigTIFF unused %hu (0x%hx)", v43, v44, v45, v46, v47, *(_WORD *)(v35 + 862));
    goto LABEL_104;
  }
  *(_WORD *)(v35 + 872) = 16;
  v63 = *(_DWORD *)(v35 + 16) | 0x80000;
LABEL_91:
  v64 = v63 | 0x200;
  *(_DWORD *)(v35 + 16) = v63 | 0x200;
  *(_OWORD *)(v35 + 1120) = 0u;
  *(_OWORD *)(v35 + 1136) = 0u;
  *(_QWORD *)(v35 + 1152) = 0;
  v65 = *a2;
  if (v65 == 97)
  {
    if (TIFFDefaultDirectory(v35))
      return v35;
    goto LABEL_104;
  }
  if (v65 != 114)
    goto LABEL_104;
  v66 = (v63 & 0x80000) != 0 ? *(_QWORD *)(v35 + 864) : *(unsigned int *)(v35 + 860);
  *(_QWORD *)(v35 + 32) = v66;
  if ((v63 & 0x800) != 0)
  {
    __dst[0] = 0;
    if ((*(unsigned int (**)(_QWORD, uint64_t, _QWORD *))(v35 + 1184))(*(_QWORD *)(v35 + 1200), v35 + 1168, __dst))
    {
      *(_QWORD *)(v35 + 1176) = __dst[0];
      v64 = *(_DWORD *)(v35 + 16);
    }
    else
    {
      v64 = *(_DWORD *)(v35 + 16) & 0xFFFFF7FF;
      *(_DWORD *)(v35 + 16) = v64;
    }
  }
  if ((v64 & 0x10000) == 0 && !_cg_TIFFReadDirectory(v35))
  {
LABEL_104:
    *(_DWORD *)(v35 + 12) = 0;
    TIFFCleanup(v35, v53, v54, v43, v44, v45, v46, v47);
    return 0;
  }
  return v35;
}

uint64_t _TIFFSetDefaultCompressionState(uint64_t result)
{
  *(_QWORD *)(result + 952) = _TIFFNoFixupTags;
  *(_DWORD *)(result + 944) = 1;
  *(_QWORD *)(result + 960) = _TIFFtrue;
  *(_QWORD *)(result + 968) = _TIFFNoPreCode;
  *(_QWORD *)(result + 1008) = _TIFFNoRowDecode;
  *(_QWORD *)(result + 1024) = _TIFFNoStripDecode;
  *(_QWORD *)(result + 1040) = _TIFFNoTileDecode;
  *(_DWORD *)(result + 984) = 1;
  *(_QWORD *)(result + 976) = _TIFFtrue;
  *(_QWORD *)(result + 992) = _TIFFNoPreCode;
  *(_QWORD *)(result + 1000) = _TIFFtrue;
  *(_QWORD *)(result + 1016) = _TIFFNoRowEncode;
  *(_QWORD *)(result + 1032) = _TIFFNoStripEncode;
  *(_QWORD *)(result + 1048) = _TIFFNoTileEncode;
  *(_QWORD *)(result + 1056) = _TIFFvoid;
  *(_QWORD *)(result + 1064) = _TIFFNoSeek;
  *(_QWORD *)(result + 1072) = _TIFFvoid;
  *(_QWORD *)(result + 1080) = _TIFFDefaultStripSize;
  *(_QWORD *)(result + 1088) = _TIFFDefaultTileSize;
  *(_DWORD *)(result + 16) &= 0xFFFDFEFF;
  return result;
}

uint64_t myTIFFMapFileProc(void *a1, void **a2, unint64_t *a3)
{
  return 0;
}

uint64_t _TIFFgetMode(_QWORD *a1, uint64_t a2, char *a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;

  v8 = *a3;
  if (v8 == 97 || v8 == 119)
  {
    if (*a3 == 119)
      return 1538;
    else
      return 514;
  }
  else if (v8 == 114)
  {
    return 2 * (a3[1] == 43);
  }
  else
  {
    _TIFFErrorEarly(a1, a2, a4, "\"%s\": Bad mode", a5, a6, a7, a8, (char)a3);
    return 0xFFFFFFFFLL;
  }
}

void IOTiffClientData::IOTiffClientData(IOTiffClientData *this, char a2)
{
  *((_BYTE *)this + 34) = a2;
  *(_QWORD *)this = &off_1E1BB0DE8;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_WORD *)this + 16) = 0;
}

uint64_t TIFFReadPlugin::calculateBlockCount(TIFFReadPlugin *this)
{
  uint64_t result;
  int v3;
  unsigned int v4;
  int v5;
  unsigned int v6;

  result = 0;
  v3 = *((_DWORD *)this + 74);
  *((_DWORD *)this + 26) = 1;
  *((_DWORD *)this + 27) = v3;
  v4 = *((_DWORD *)this + 113);
  if (v4 >= 0x801 && v4 * (unint64_t)*((unsigned int *)this + 112) > 0x400000)
  {
    v5 = *((unsigned __int8 *)this + 552);
    if ((v5 - 2) < 2)
    {
      return 0;
    }
    else if ((v5 - 4) > 1)
    {
      return 4294967292;
    }
    else
    {
      result = 0;
      v6 = (*((_DWORD *)this + 130) + 2047) / *((_DWORD *)this + 130) * *((_DWORD *)this + 130);
      *((_DWORD *)this + 26) = (v4 + v6 - 1) / v6;
      *((_DWORD *)this + 27) = v6;
    }
  }
  return result;
}

uint64_t myTIFFCloseProc(void *a1)
{
  if (a1)
    (*(void (**)(void *))(*(_QWORD *)a1 + 8))(a1);
  return 0;
}

void IOTiffClientData::~IOTiffClientData(IOTiffClientData *this)
{
  JUMPOUT(0x18D761C30);
}

uint64_t TIFFReadPlugin::updateTiffStruct(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _WORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  unsigned int v63;
  unsigned int v64;
  unsigned __int16 v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  unsigned int v86;
  unsigned int v87;
  unint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t result;
  int v98;
  int v99;
  uint64_t v100;
  uint64_t v101;

  if (!_cg_TIFFGetField(a2, 256, a3, a4, a5, a6, a7, a8, a1 + 448))
  {
    _cg_jpeg_mem_term("updateTiffStruct", 955, "*** ERROR: could not get TIFFTAG_IMAGEWIDTH\n", v100);
    return 4294967246;
  }
  if (!_cg_TIFFGetField(a2, 257, v10, v11, v12, v13, v14, v15, a1 + 452))
  {
    _cg_jpeg_mem_term("updateTiffStruct", 958, "*** ERROR: could not  get TIFFTAG_IMAGELENGTH\n", v101);
    return 4294967246;
  }
  v22 = (_WORD *)(a1 + 458);
  _cg_TIFFGetFieldDefaulted(a2, 258, v16, v17, v18, v19, v20, v21, a1 + 458);
  _cg_TIFFGetFieldDefaulted(a2, 277, v23, v24, v25, v26, v27, v28, a1 + 488);
  _cg_TIFFGetFieldDefaulted(a2, 284, v29, v30, v31, v32, v33, v34, a1 + 466);
  _cg_TIFFGetFieldDefaulted(a2, 339, v35, v36, v37, v38, v39, v40, a1 + 468);
  *(_QWORD *)(a1 + 480) = _cg_TIFFStripSize64(a2, v41, v42, v43, v44, v45, v46, v47);
  *(_DWORD *)(a1 + 556) = _cg_TIFFNumberOfStrips(a2, v48, v49, v50, v51, v52, v53, v54);
  *(_QWORD *)(a1 + 496) = _cg_TIFFScanlineSize64(a2, v55, v56, v57, v58, v59, v60, v61);
  if (*(_WORD *)(a1 + 468) == 3)
  {
    v62 = (unsigned __int16)*v22;
    if (v62 != 16 && v62 != 32)
    {
      _cg_jpeg_mem_term("updateTiffStruct", 969, "*** floatingPoint TIFF - cannot handle %d bits/component\n");
      return 4294967246;
    }
  }
  v63 = *(unsigned __int16 *)(a1 + 488);
  if (v63 >= 0x21)
  {
    _cg_jpeg_mem_term("updateTiffStruct", 971, "*** samplesPerPixel '%d' not supported (<=32)\n");
    return 4294967246;
  }
  v64 = (unsigned __int16)*v22;
  if (v64 >= 0x21)
  {
    _cg_jpeg_mem_term("updateTiffStruct", 972, "*** bitsPerComponent '%d' not supported (<=32)\n");
    return 4294967246;
  }
  v65 = v63 - *(_WORD *)(a1 + 462);
  if (v65 >= 0x21u)
  {
    _cg_jpeg_mem_term("updateTiffStruct", 975, "*** realsamples '%d' not supported (<=32)\n");
    return 4294967246;
  }
  if (*v22 && !*(_WORD *)(a1 + 460))
    *(_WORD *)(a1 + 460) = v65 * v64;
  v66 = _cg_TIFFIsTiled(*(_QWORD *)(a1 + 440));
  *(_BYTE *)(a1 + 561) = v66 != 0;
  if (v66)
  {
    _cg_TIFFGetField(*(_QWORD *)(a1 + 440), 322, v67, v68, v69, v70, v71, v72, a1 + 516);
    _cg_TIFFGetField(*(_QWORD *)(a1 + 440), 323, v73, v74, v75, v76, v77, v78, a1 + 520);
    v86 = *(_DWORD *)(a1 + 516);
    if ((v86 & 0xF) != 0)
    {
      _cg_jpeg_mem_term("updateTiffStruct", 988, "*** ERROR: tileWidth %d is not a multiple of 16\n");
    }
    else
    {
      v87 = *(_DWORD *)(a1 + 520);
      if ((v87 & 0xF) != 0)
      {
        _cg_jpeg_mem_term("updateTiffStruct", 989, "*** ERROR: tileHeight %d is not a multiple of 16\n");
      }
      else if (v86 <= 0xF)
      {
        _cg_jpeg_mem_term("updateTiffStruct", 990, "unexpected tileWidth: %d\n");
      }
      else if (v87 <= 0xF)
      {
        _cg_jpeg_mem_term("updateTiffStruct", 991, "unexpected tileHeight: %d\n");
      }
      else
      {
        v88 = _cg_TIFFTileSize64(*(_QWORD *)(a1 + 440), v79, v80, v81, v82, v83, v84, v85);
        *(_QWORD *)(a1 + 528) = v88;
        if (v88 <= *(_QWORD *)(a1 + 184))
        {
          v96 = _cg_TIFFTileRowSize64(*(_QWORD *)(a1 + 440), v89, v90, v91, v92, v93, v94, v95);
          result = 0;
          *(_QWORD *)(a1 + 504) = v96;
          return result;
        }
        _cg_jpeg_mem_term("updateTiffStruct", 993, "unexpected tileSize: %ll  d\n", v88);
      }
    }
    return 4294967246;
  }
  _cg_TIFFGetFieldDefaulted(a2, 278, v67, v68, v69, v70, v71, v72, a1 + 472);
  v98 = *(_DWORD *)(a1 + 472);
  v99 = *(_DWORD *)(a1 + 452);
  if (v98 == -1)
  {
    result = 0;
    *(_DWORD *)(a1 + 472) = v99;
  }
  else
  {
    if (v98 > v99)
      _cg_jpeg_mem_term("updateTiffStruct", 1003, "*** NOTE: _tiff._tiffRowsPerStrip: %d   _tiff._tiffHeight: %d\n", *(_DWORD *)(a1 + 472), v99);
    return 0;
  }
  return result;
}

uint64_t _cg_TIFFGetFieldDefaulted(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  return TIFFVGetFieldDefaulted(a1, a2, (uint64_t)&a9);
}

uint64_t _cg_TIFFGetField(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  return TIFFVGetField(a1, a2, (uint64_t)&a9);
}

uint64_t TIFFVGetFieldDefaulted(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD **v20;
  _QWORD **v21;
  uint64_t v22;
  _DWORD *v23;
  void *v24;
  _WORD **v25;
  _WORD **v26;
  int v27;
  unsigned int v28;
  int v29;
  int *v30;
  _WORD **v31;
  char v32;
  _DWORD **v33;
  _DWORD **v34;

  v3 = a2;
  v33 = (_DWORD **)a3;
  result = TIFFVGetField(a1, a2, a3);
  if ((_DWORD)result)
    return 1;
  v12 = a1 + 72;
  if (v3 <= 331)
  {
    if (v3 <= 273)
    {
      if (v3 > 262)
      {
        if (v3 == 263)
        {
          LOWORD(v13) = *(_WORD *)(a1 + 124);
        }
        else
        {
          if (v3 != 266)
            return result;
          LOWORD(v13) = *(_WORD *)(a1 + 126);
        }
      }
      else
      {
        if (v3 == 254)
        {
          v27 = *(_DWORD *)(a1 + 112);
LABEL_56:
          **v33 = v27;
          return 1;
        }
        if (v3 != 258)
          return result;
        LOWORD(v13) = *(_WORD *)(a1 + 116);
      }
    }
    else
    {
      if (v3 <= 295)
      {
        switch(v3)
        {
          case 274:
            LOWORD(v13) = *(_WORD *)(a1 + 128);
            goto LABEL_64;
          case 277:
            LOWORD(v13) = *(_WORD *)(a1 + 130);
            goto LABEL_64;
          case 278:
            v27 = *(_DWORD *)(a1 + 132);
            goto LABEL_56;
          case 280:
            LOWORD(v13) = *(_WORD *)(a1 + 136);
            goto LABEL_64;
          case 281:
            v28 = *(unsigned __int16 *)(a1 + 116);
            if (v28 <= 0x10)
              v29 = ~(-1 << v28);
            else
              LOWORD(v29) = -1;
            if (*(_WORD *)(a1 + 116))
              LOWORD(v13) = v29;
            else
              LOWORD(v13) = 0;
            goto LABEL_64;
          case 284:
            LOWORD(v13) = *(_WORD *)(a1 + 170);
            goto LABEL_64;
          default:
            return result;
        }
        return result;
      }
      if (v3 > 316)
      {
        if (v3 != 317)
        {
          if (v3 != 318)
            return result;
          v23 = *v33;
          v24 = &TIFFVGetFieldDefaulted_whitepoint;
LABEL_33:
          *(_QWORD *)v23 = v24;
          return 1;
        }
        v30 = *(int **)(a1 + 1096);
        if (!v30)
        {
          TIFFErrorExtR(a1, *(const char **)a1, "Cannot get \"Predictor\" tag as plugin is not configured", v7, v8, v9, v10, v11, v32);
          result = 0;
          *(_WORD *)*v33 = 0;
          return result;
        }
        v13 = *v30;
      }
      else
      {
        if (v3 != 296)
        {
          if (v3 != 301)
            return result;
          v14 = *(_QWORD *)(a1 + 344);
          if (!v14)
          {
            if (!TIFFDefaultTransferFunction((_QWORD *)a1, v12, v6, v7, v8, v9, v10, v11))
            {
              TIFFErrorExtR(a1, *(const char **)a1, "No space for \"TransferFunction\" tag", v15, v16, v17, v18, v19, v32);
              return 0;
            }
            v14 = *(_QWORD *)(a1 + 344);
          }
          v20 = (_QWORD **)v33;
          v34 = v33 + 1;
          **v20 = v14;
          if (*(unsigned __int16 *)(a1 + 130) - *(unsigned __int16 *)(a1 + 212) >= 2)
          {
            v21 = (_QWORD **)v34;
            v33 = v34 + 1;
            **v21 = *(_QWORD *)(a1 + 352);
            v22 = *(_QWORD *)(a1 + 360);
LABEL_62:
            *(_QWORD *)*v33 = v22;
          }
          return 1;
        }
        LOWORD(v13) = *(_WORD *)(a1 + 168);
      }
    }
LABEL_64:
    *(_WORD *)*v33 = v13;
    return 1;
  }
  switch(v3)
  {
    case 332:
      result = 1;
      *(_WORD *)*v33 = 1;
      break;
    case 333:
    case 335:
    case 337:
      return result;
    case 334:
      *(_WORD *)*v33 = 4;
      return 1;
    case 336:
      v25 = (_WORD **)v33++;
      **v25 = 0;
      v13 = ~(-1 << *(_WORD *)(a1 + 116));
      goto LABEL_64;
    case 338:
      v26 = (_WORD **)v33++;
      **v26 = *(_WORD *)(a1 + 212);
      v22 = *(_QWORD *)(a1 + 216);
      goto LABEL_62;
    case 339:
      LOWORD(v13) = *(_WORD *)(a1 + 118);
      goto LABEL_64;
    default:
      switch(v3)
      {
        case 529:
          v23 = *v33;
          v24 = &TIFFVGetFieldDefaulted_ycbcrcoeffs;
          goto LABEL_33;
        case 530:
          v31 = (_WORD **)v33++;
          **v31 = *(_WORD *)(a1 + 336);
          LOWORD(v13) = *(_WORD *)(a1 + 338);
          goto LABEL_64;
        case 531:
          LOWORD(v13) = *(_WORD *)(a1 + 340);
          goto LABEL_64;
        case 532:
          v22 = *(_QWORD *)(a1 + 368);
          if (v22)
            goto LABEL_62;
          result = TIFFDefaultRefBlackWhite((_QWORD *)a1, v12, v6, v7, v8, v9, v10, v11);
          if (!(_DWORD)result)
            return result;
          v22 = *(_QWORD *)(a1 + 368);
          break;
        default:
          switch(v3)
          {
            case 32995:
              LOWORD(v13) = *(_WORD *)(a1 + 212) == 1 && **(_WORD **)(a1 + 216) == 1;
              goto LABEL_64;
            case 32996:
              LOWORD(v13) = *(_WORD *)(a1 + 118) - 1;
              goto LABEL_64;
            case 32997:
              v27 = *(_DWORD *)(a1 + 96);
              goto LABEL_56;
            case 32998:
              v27 = *(_DWORD *)(a1 + 108);
              goto LABEL_56;
            default:
              return result;
          }
          return result;
      }
      goto LABEL_62;
  }
  return result;
}

uint64_t TIFFVGetField(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _DWORD *v6;

  v6 = TIFFFindField((_QWORD *)a1, a2, 0);
  if (v6
    && (WORD1(a2)
     || ((*(_DWORD *)(a1 + ((*((unsigned __int16 *)v6 + 12) >> 3) & 0x1FFCLL) + 72) >> *((_WORD *)v6 + 12)) & 1) != 0))
  {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 1288))(a1, a2, a3);
  }
  else
  {
    return 0;
  }
}

uint64_t _TIFFVGetField(uint64_t a1, int a2, double ***a3)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  __int16 v15;
  double *v16;
  double ***v17;
  double ***v18;
  uint64_t v19;
  _WORD **i;
  double **v21;
  __int16 v22;
  int v23;
  int v24;
  double ***v25;
  double ***v26;
  _QWORD **v27;
  _QWORD **v28;
  double ***v29;
  double ***v30;
  double ***v31;
  double v32;
  unint64_t v33;
  double *v34;
  unint64_t v35;
  double v36;
  double v37;
  unint64_t v38;
  double *v39;
  unint64_t v40;
  double v41;
  double v42;
  int v43;
  double ***v44;
  int v45;
  int v46;
  _BYTE *v47;
  uint64_t v48;
  double ***v49;
  int Size;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  _QWORD **v57;

  result = (uint64_t)TIFFFindField((_QWORD *)a1, a2, 0);
  if (result)
  {
    v11 = result;
    v12 = *(unsigned __int16 *)(result + 24);
    if (v12 == 65)
      v13 = 0;
    else
      v13 = a2;
    if (v13 <= 530)
    {
      switch(v13)
      {
        case 254:
          v23 = *(_DWORD *)(a1 + 112);
          goto LABEL_59;
        case 255:
        case 260:
        case 261:
        case 264:
        case 265:
        case 267:
        case 268:
        case 269:
        case 270:
        case 271:
        case 272:
        case 275:
        case 276:
        case 285:
        case 288:
        case 289:
        case 290:
        case 291:
        case 292:
        case 293:
        case 294:
        case 295:
        case 298:
        case 299:
        case 300:
        case 302:
        case 303:
        case 304:
        case 305:
        case 306:
        case 307:
        case 308:
        case 309:
        case 310:
        case 311:
        case 312:
        case 313:
        case 314:
        case 315:
        case 316:
        case 317:
        case 318:
        case 319:
        case 326:
        case 327:
        case 328:
        case 329:
        case 331:
        case 332:
        case 335:
        case 336:
        case 337:
          goto LABEL_21;
        case 256:
          v23 = *(_DWORD *)(a1 + 88);
          goto LABEL_59;
        case 257:
          v23 = *(_DWORD *)(a1 + 92);
          goto LABEL_59;
        case 258:
          v15 = *(_WORD *)(a1 + 116);
          goto LABEL_82;
        case 259:
          v15 = *(_WORD *)(a1 + 120);
          goto LABEL_82;
        case 262:
          v15 = *(_WORD *)(a1 + 122);
          goto LABEL_82;
        case 263:
          v15 = *(_WORD *)(a1 + 124);
          goto LABEL_82;
        case 266:
          v15 = *(_WORD *)(a1 + 126);
          goto LABEL_82;
        case 273:
        case 324:
          _TIFFFillStriles(a1);
          **a3 = *(double **)(a1 + 232);
          v14 = *(_QWORD *)(a1 + 232);
          return v14 != 0;
        case 274:
          v15 = *(_WORD *)(a1 + 128);
          goto LABEL_82;
        case 277:
          v15 = *(_WORD *)(a1 + 130);
          goto LABEL_82;
        case 278:
          v23 = *(_DWORD *)(a1 + 132);
          goto LABEL_59;
        case 279:
        case 325:
          _TIFFFillStriles(a1);
          **a3 = *(double **)(a1 + 240);
          v14 = *(_QWORD *)(a1 + 240);
          return v14 != 0;
        case 280:
          v15 = *(_WORD *)(a1 + 136);
          goto LABEL_82;
        case 281:
          v15 = *(_WORD *)(a1 + 138);
          goto LABEL_82;
        case 282:
          v24 = *(_DWORD *)(a1 + 160);
          goto LABEL_50;
        case 283:
          v24 = *(_DWORD *)(a1 + 164);
          goto LABEL_50;
        case 284:
          v15 = *(_WORD *)(a1 + 170);
          goto LABEL_82;
        case 286:
          v24 = *(_DWORD *)(a1 + 172);
          goto LABEL_50;
        case 287:
          v24 = *(_DWORD *)(a1 + 176);
LABEL_50:
          *(_DWORD *)*a3 = v24;
          return 1;
        case 296:
          v15 = *(_WORD *)(a1 + 168);
          goto LABEL_82;
        case 297:
          v25 = a3++;
          *(_WORD *)*v25 = *(_WORD *)(a1 + 180);
          v15 = *(_WORD *)(a1 + 182);
          goto LABEL_82;
        case 301:
          v26 = a3;
          v57 = a3 + 1;
          **v26 = *(double **)(a1 + 344);
          if (*(unsigned __int16 *)(a1 + 130) - *(unsigned __int16 *)(a1 + 212) >= 2)
          {
            v27 = v57;
            a3 = (double ***)(v57 + 1);
            **v27 = *(_QWORD *)(a1 + 352);
            v16 = *(double **)(a1 + 360);
            goto LABEL_101;
          }
          **v57 = 0;
          *v57[1] = 0;
          break;
        case 320:
          **a3 = *(double **)(a1 + 184);
          v28 = a3 + 1;
          a3 += 2;
          **v28 = *(_QWORD *)(a1 + 192);
          v16 = *(double **)(a1 + 200);
          goto LABEL_101;
        case 321:
          v29 = a3++;
          *(_WORD *)*v29 = *(_WORD *)(a1 + 208);
          v15 = *(_WORD *)(a1 + 210);
          goto LABEL_82;
        case 322:
          v23 = *(_DWORD *)(a1 + 100);
          goto LABEL_59;
        case 323:
          v23 = *(_DWORD *)(a1 + 104);
          goto LABEL_59;
        case 330:
          v30 = a3++;
          *(_WORD *)*v30 = *(_WORD *)(a1 + 320);
          v16 = *(double **)(a1 + 328);
          goto LABEL_101;
        case 333:
          v16 = *(double **)(a1 + 384);
          goto LABEL_101;
        case 334:
          v15 = *(_WORD *)(a1 + 392);
          goto LABEL_82;
        case 338:
          v31 = a3++;
          *(_WORD *)*v31 = *(_WORD *)(a1 + 212);
          v16 = *(double **)(a1 + 216);
          goto LABEL_101;
        case 339:
          v15 = *(_WORD *)(a1 + 118);
          goto LABEL_82;
        case 340:
          v16 = *(double **)(a1 + 144);
          if ((*(_BYTE *)(a1 + 18) & 0x40) != 0)
            goto LABEL_101;
          v32 = *v16;
          v33 = *(unsigned __int16 *)(a1 + 130);
          if (v33 >= 2)
          {
            v34 = v16 + 1;
            v35 = v33 - 1;
            do
            {
              v36 = *v34++;
              v37 = v36;
              if (v36 < v32)
                v32 = v37;
              --v35;
            }
            while (v35);
          }
          goto LABEL_78;
        case 341:
          v16 = *(double **)(a1 + 152);
          if ((*(_BYTE *)(a1 + 18) & 0x40) != 0)
            goto LABEL_101;
          v32 = *v16;
          v38 = *(unsigned __int16 *)(a1 + 130);
          if (v38 >= 2)
          {
            v39 = v16 + 1;
            v40 = v38 - 1;
            do
            {
              v41 = *v39++;
              v42 = v41;
              if (v41 > v32)
                v32 = v42;
              --v40;
            }
            while (v40);
          }
LABEL_78:
          *(double *)*a3 = v32;
          return 1;
        default:
          if (v13 != 530)
            goto LABEL_21;
          v18 = a3++;
          *(_WORD *)*v18 = *(_WORD *)(a1 + 336);
          v15 = *(_WORD *)(a1 + 338);
          goto LABEL_82;
      }
      return 1;
    }
    if (v13 > 32994)
    {
      switch(v13)
      {
        case 32995:
          v15 = *(_WORD *)(a1 + 212) == 1 && **(_WORD **)(a1 + 216) == 1;
          goto LABEL_82;
        case 32996:
          switch(*(_WORD *)(a1 + 118))
          {
            case 1:
              v21 = *a3;
              v22 = 2;
              goto LABEL_86;
            case 2:
              result = 1;
              *(_WORD *)*a3 = 1;
              return result;
            case 3:
              v21 = *a3;
              v22 = 3;
LABEL_86:
              *(_WORD *)v21 = v22;
              break;
            case 4:
              *(_WORD *)*a3 = 0;
              return 1;
            default:
              return 1;
          }
          return 1;
        case 32997:
          v23 = *(_DWORD *)(a1 + 96);
          goto LABEL_59;
        case 32998:
          v23 = *(_DWORD *)(a1 + 108);
LABEL_59:
          *(_DWORD *)*a3 = v23;
          return 1;
        default:
          if (v13 != 33723)
            goto LABEL_21;
          v17 = a3++;
          *(_DWORD *)*v17 = *(_DWORD *)(a1 + 396);
          v16 = *(double **)(a1 + 400);
          goto LABEL_101;
      }
    }
    if (v13 != 531)
    {
      if (v13 == 532)
      {
        v16 = *(double **)(a1 + 368);
LABEL_101:
        **a3 = v16;
        return 1;
      }
LABEL_21:
      if (v12 == 65)
      {
        v19 = *(unsigned int *)(a1 + 408);
        if ((int)v19 >= 1)
        {
          for (i = (_WORD **)(*(_QWORD *)(a1 + 416) + 16); *(_DWORD *)*(i - 2) != a2; i += 3)
          {
            result = 0;
            if (!--v19)
              return result;
          }
          if (*(_BYTE *)(v11 + 27))
          {
            v43 = *((_DWORD *)i - 2);
            v44 = a3++;
            if (*(__int16 *)(v11 + 4) == -3)
              *(_DWORD *)*v44 = v43;
            else
              *(_WORD *)*v44 = v43;
LABEL_100:
            v16 = (double *)*i;
            goto LABEL_101;
          }
          if (*(_DWORD *)v11 != 336 || strcmp(*(const char **)(v11 + 32), "DotRange"))
          {
            v45 = *(_DWORD *)(v11 + 8);
            if (v45 != 2 && *(unsigned __int16 *)(v11 + 4) <= 0xFFFCu)
            {
              v46 = *((_DWORD *)i - 2);
              if (v46 < 2)
              {
                if (v46 == 1)
                {
                  result = 0;
                  v47 = *i;
                  switch(v45)
                  {
                    case 1:
                    case 6:
                    case 7:
                      *(_BYTE *)*a3 = *v47;
                      return 1;
                    case 3:
                    case 8:
                      v15 = *(_WORD *)v47;
                      goto LABEL_82;
                    case 4:
                    case 9:
                    case 13:
                      v23 = *(_DWORD *)v47;
                      goto LABEL_59;
                    case 5:
                    case 10:
                      Size = TIFFFieldSetGetSize(v11);
                      if (Size == 8)
                        goto LABEL_108;
                      *(_DWORD *)*a3 = *(_DWORD *)v47;
                      if (Size != 4)
                        TIFFErrorExtR(a1, "_TIFFVGetField", "Rational2Double: .set_field_type in not 4 but %d", v51, v52, v53, v54, v55, Size);
                      return 1;
                    case 11:
                      v24 = *(_DWORD *)v47;
                      goto LABEL_50;
                    case 12:
LABEL_108:
                      v32 = *(double *)v47;
                      goto LABEL_78;
                    case 16:
                    case 17:
                    case 18:
                      v16 = *(double **)v47;
                      goto LABEL_101;
                    default:
                      return result;
                  }
                }
                _TIFFVGetField_cold_1();
              }
            }
            goto LABEL_100;
          }
          v48 = (uint64_t)*i;
          v49 = a3++;
          *(_WORD *)*v49 = **i;
          v15 = *(_WORD *)(v48 + 2);
LABEL_82:
          *(_WORD *)*a3 = v15;
          return 1;
        }
      }
      else
      {
        TIFFErrorExtR(a1, "_TIFFVGetField", "%s: Invalid %stag \"%s\" (not supported by codec)", v6, v7, v8, v9, v10, *(_QWORD *)a1);
      }
      return 0;
    }
    v15 = *(_WORD *)(a1 + 340);
    goto LABEL_82;
  }
  return result;
}

uint64_t _cg_TIFFNumberOfStrips(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  char vars0;

  v8 = *(_DWORD *)(a1 + 132);
  if (v8 == -1)
  {
    v9 = 1;
  }
  else
  {
    if (!v8)
    {
      TIFFWarningExtR(a1, "TIFFNumberOfStrips", "RowsPerStrip is zero", a4, a5, a6, a7, a8, vars0);
      return 0;
    }
    v9 = 0;
    v10 = *(_DWORD *)(a1 + 92);
    if (v10 < -v8)
      v9 = (v8 + v10 - 1) / v8;
  }
  if (*(_WORD *)(a1 + 170) == 2)
    return _TIFFMultiply32(a1, v9, *(unsigned __int16 *)(a1 + 130), "TIFFNumberOfStrips", a5, a6, a7, a8);
  return v9;
}

uint64_t _TIFFMergeFields(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  char *v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char v22;

  v8 = a3;
  *(_QWORD *)(a1 + 1272) = 0;
  v11 = *(char **)(a1 + 1256);
  if (v11 && (v12 = *(_QWORD *)(a1 + 1264)) != 0)
    v13 = _TIFFCheckRealloc((const char **)a1, v11, v12 + a3, 8, (uint64_t)"for fields array", a6, a7, a8);
  else
    v13 = _TIFFCheckMalloc((const char **)a1, a3, 8, (uint64_t)"for fields array", a5, a6, a7, a8);
  *(_QWORD *)(a1 + 1256) = v13;
  if (v13)
  {
    if ((_DWORD)v8)
    {
      v19 = v8;
      do
      {
        if (!TIFFFindField((_QWORD *)a1, *a2, 0))
        {
          v20 = *(_QWORD *)(a1 + 1264);
          *(_QWORD *)(*(_QWORD *)(a1 + 1256) + 8 * v20) = a2;
          *(_QWORD *)(a1 + 1264) = v20 + 1;
        }
        a2 += 12;
        --v19;
      }
      while (v19);
      v13 = *(_QWORD **)(a1 + 1256);
    }
    qsort(v13, *(_QWORD *)(a1 + 1264), 8uLL, (int (__cdecl *)(const void *, const void *))tagCompare);
  }
  else
  {
    TIFFErrorExtR(a1, "_TIFFMergeFields", "Failed to allocate fields array", v14, v15, v16, v17, v18, v22);
    return 0;
  }
  return v8;
}

_DWORD *TIFFFindField(_QWORD *a1, int a2, int a3)
{
  _DWORD *result;
  const void *v5;
  _OWORD *__key;
  _OWORD v7[3];

  memset(v7, 0, sizeof(v7));
  __key = v7;
  result = (_DWORD *)a1[159];
  if (!result || *result != a2 || a3 && result[2] != a3)
  {
    v5 = (const void *)a1[157];
    if (v5)
    {
      LODWORD(v7[0]) = a2;
      DWORD2(v7[0]) = a3;
      result = bsearch(&__key, v5, a1[158], 8uLL, (int (__cdecl *)(const void *, const void *))tagCompare);
      if (result)
        result = *(_DWORD **)result;
      a1[159] = result;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t _cg_TIFFIsTiled(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 16) >> 10) & 1;
}

uint64_t TIFFReadPlugin::handleColorSpace(TIFFReadPlugin *this, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  uint64_t result;
  CGColorSpace *v16;
  CGColorSpaceModel Model;
  CGColorSpaceModel v18;
  int v19;
  unsigned int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  unsigned int v24;
  int v25;
  uint64_t v26;
  unsigned int v27;
  int v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  int v32;
  unsigned int v33;
  int v34;
  uint64_t v35;
  unsigned int v36;
  int v37;
  uint64_t v38;
  unsigned int v39;
  int v40;
  uint64_t v41;
  int v42;
  CGColorSpaceRef ColorSpaceFromMetadata;
  const __CFDictionary *TopLevelTag;
  const __CFString *Value;
  unint64_t v46;
  unsigned __int8 *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unsigned __int16 *v54;
  CGFloat v55;
  CGFloat v56;
  uint64_t v57;
  uint64_t v58;
  unsigned int v59;
  unsigned __int8 *v60;
  unsigned int v61;
  unsigned int v62;
  CGColorSpace *v63;
  size_t v64;
  CGColorSpaceRef Lab;
  CGColorSpaceRef v66;
  unsigned int length;
  _OWORD length_4[2];
  CGFloat blackPoint[3];
  CGFloat whitePoint[2];
  uint64_t v71;
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  v10 = 1380401696;
  length = 0;
  v11 = *((unsigned __int16 *)this + 244);
  v12 = *((unsigned __int16 *)this + 231);
  *((_DWORD *)this + 81) = 0;
  v13 = v11 - v12;
  switch(*((_WORD *)this + 228))
  {
    case 0:
    case 1:
      if (v13 != 1)
        goto LABEL_5;
      v10 = 1196573017;
      goto LABEL_21;
    case 2:
LABEL_5:
      if (v13 == 3)
        goto LABEL_21;
      goto LABEL_17;
    case 3:
      if (v13 == 1)
        goto LABEL_21;
      goto LABEL_17;
    case 4:
    case 7:
      goto LABEL_17;
    case 5:
      if (v13 != 4)
        goto LABEL_17;
      v10 = 1129142603;
      goto LABEL_21;
    case 6:
      if (v13 != 3)
        goto LABEL_17;
      v14 = *((unsigned __int16 *)this + 232);
      if (v14 == 1)
        goto LABEL_21;
      if (v14 == 7)
      {
        *((_DWORD *)this + 81) = 1380401696;
        _cg_TIFFSetField(*((_QWORD *)this + 55), 65538, a3, a4, a5, a6, a7, a8, 1);
        *((_WORD *)this + 228) = 2;
        if (*((_DWORD *)this + 81))
          goto LABEL_22;
      }
LABEL_17:
      _cg_jpeg_mem_term("handleColorSpace", 1089, "*** unsupported colormodel (0)\n");
      return 4294967246;
    case 8:
    case 9:
    case 0xA:
      if (v13 != 3)
        goto LABEL_17;
      v10 = 1281450528;
LABEL_21:
      *((_DWORD *)this + 81) = v10;
LABEL_22:
      _cg_TIFFGetField(*((_QWORD *)this + 55), 34675, a3, a4, a5, a6, a7, a8, (uint64_t)&length);
      if (!length)
        goto LABEL_75;
      v16 = (CGColorSpace *)CGColorSpaceCreateWithCopyOfData(0, length);
      *((_QWORD *)this + 20) = v16;
      Model = CGColorSpaceGetModel(v16);
      v18 = Model;
      v19 = Model > kCGColorSpaceModelXYZ ? 1061109567 : *(_DWORD *)&aYargBgrkymcBal_0[4 * Model];
      if (v19 == *((_DWORD *)this + 81))
        goto LABEL_75;
      v20 = Model >> 24;
      v21 = MEMORY[0x1E0C80978];
      if (Model < 0)
        v22 = __maskrune(Model >> 24, 0x40000uLL);
      else
        v22 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v20 + 60) & 0x40000;
      if (v22)
        v23 = v20;
      else
        v23 = 46;
      v24 = v18 << 8 >> 24;
      if (v18 << 8 < 0)
        v25 = __maskrune(v18 << 8 >> 24, 0x40000uLL);
      else
        v25 = *(_DWORD *)(v21 + 4 * v24 + 60) & 0x40000;
      if (v25)
        v26 = v24;
      else
        v26 = 46;
      v27 = (__int16)v18 >> 8;
      if (v18 << 16 < 0)
        v28 = __maskrune((__int16)v18 >> 8, 0x40000uLL);
      else
        v28 = *(_DWORD *)(v21 + 4 * v27 + 60) & 0x40000;
      if (v28)
        v29 = v27;
      else
        v29 = 46;
      if ((v18 << 24) <= 0x7F000000)
        v30 = *(_DWORD *)(v21 + 4 * (char)v18 + 60) & 0x40000;
      else
        v30 = __maskrune((char)v18, 0x40000uLL);
      if (v30)
        v31 = (char)v18;
      else
        v31 = 46;
      v32 = *((_DWORD *)this + 81);
      v33 = v32 >> 24;
      if (v32 < 0)
      {
        v34 = __maskrune(v33, 0x40000uLL);
        v32 = *((_DWORD *)this + 81);
      }
      else
      {
        v34 = *(_DWORD *)(v21 + 4 * v33 + 60) & 0x40000;
      }
      if (v34)
        v35 = (v32 >> 24);
      else
        v35 = 46;
      v36 = v32 << 8 >> 24;
      if (v32 << 8 < 0)
      {
        v37 = __maskrune(v36, 0x40000uLL);
        v32 = *((_DWORD *)this + 81);
      }
      else
      {
        v37 = *(_DWORD *)(v21 + 4 * v36 + 60) & 0x40000;
      }
      if (v37)
        v38 = (v32 << 8 >> 24);
      else
        v38 = 46;
      v39 = (__int16)v32 >> 8;
      if (v32 << 16 < 0)
      {
        v40 = __maskrune(v39, 0x40000uLL);
        v32 = *((_DWORD *)this + 81);
      }
      else
      {
        v40 = *(_DWORD *)(v21 + 4 * v39 + 60) & 0x40000;
      }
      if (v40)
        v41 = ((__int16)v32 >> 8);
      else
        v41 = 46;
      if ((v32 << 24) <= 0x7F000000)
      {
        if ((*(_DWORD *)(v21 + 4 * (char)v32 + 60) & 0x40000) != 0)
          goto LABEL_71;
      }
      else if (__maskrune((char)v32, 0x40000uLL))
      {
LABEL_71:
        v42 = *((_DWORD *)this + 81);
        goto LABEL_74;
      }
      LOBYTE(v42) = 46;
LABEL_74:
      LogError("handleColorSpace", 1125, "*** embeded '%c%c%c%c' ColorSync profile doesn't match image '%c%c%c%c'\n", v23, v26, v29, v31, v35, v38, v41, (char)v42);
      *((_QWORD *)this + 20) = 0;
LABEL_75:
      if (!*((_QWORD *)this + 20) && *((_DWORD *)this + 81) == 1380401696)
      {
        LOBYTE(length_4[0]) = 0;
        ColorSpaceFromMetadata = createColorSpaceFromMetadata(*((const __CFDictionary **)this + 8), a2, length_4);
        *((_QWORD *)this + 20) = ColorSpaceFromMetadata;
        if (LOBYTE(length_4[0]))
          *((_WORD *)this + 164) = 1;
        if (!ColorSpaceFromMetadata && *((_DWORD *)this + 81) == 1380401696)
        {
          TopLevelTag = CGImageMetadataGetTopLevelTag(*((const __CFDictionary **)this + 8), (uint64_t)CFSTR("http://ns.adobe.com/exif/1.0/"), (uint64_t)CFSTR("ColorSpace"));
          if (TopLevelTag)
          {
            Value = (const __CFString *)CGImageMetadataTagGetValue((uint64_t)TopLevelTag);
            if (Value)
            {
              if (CFStringGetIntValue(Value) == 1)
                *((_QWORD *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
            }
          }
        }
      }
      if (*((_WORD *)this + 228) != 3)
        goto LABEL_98;
      v46 = *((unsigned __int16 *)this + 229);
      if (v46 > 8)
      {
        _cg_jpeg_mem_term("handleColorSpace", 1195, "*** can't handle PHOTOMETRIC_PALETTE with more than 8 bit...\n");
        return 4294967246;
      }
      v47 = (unsigned __int8 *)malloc_type_calloc(3uLL, 0x100uLL, 0xDDE053B2uLL);
      *(_QWORD *)&length_4[0] = 0;
      whitePoint[0] = 0.0;
      blackPoint[0] = 0.0;
      _cg_TIFFGetField(*((_QWORD *)this + 55), 320, v48, v49, v50, v51, v52, v53, (uint64_t)length_4);
      v54 = *(unsigned __int16 **)&length_4[0];
      if (!*(_QWORD *)&length_4[0])
      {
        _cg_jpeg_mem_term("handleColorSpace", 1171, "*** ERROR: TIFFGetField 'TIFFTAG_COLORMAP' failed (paletteR is NULL)\n");
        return 4294967246;
      }
      v55 = whitePoint[0];
      if (!*(_QWORD *)&whitePoint[0])
      {
        _cg_jpeg_mem_term("handleColorSpace", 1172, "*** ERROR: TIFFGetField 'TIFFTAG_COLORMAP' failed (paletteG is NULL)\n");
        return 4294967246;
      }
      v56 = blackPoint[0];
      if (!*(_QWORD *)&blackPoint[0])
      {
        _cg_jpeg_mem_term("handleColorSpace", 1173, "*** ERROR: TIFFGetField 'TIFFTAG_COLORMAP' failed (paletteB is NULL)\n");
        return 4294967246;
      }
      v57 = 0;
      v58 = 1 << v46;
      do
      {
        v59 = *v54++;
        v60 = &v47[v57];
        *v60 = ((255 - (((unint64_t)v59 + 128) >> 8)) >> 31) | ((unsigned __int16)(v59 + 128) >> 8);
        v61 = (unsigned __int16)**(_WORD **)&v55;
        *(_QWORD *)&v55 += 2;
        v60[1] = ((255 - (((unint64_t)v61 + 128) >> 8)) >> 31) | ((unsigned __int16)(v61 + 128) >> 8);
        v62 = (unsigned __int16)**(_WORD **)&v56;
        *(_QWORD *)&v56 += 2;
        v60[2] = ((255 - (((unint64_t)v62 + 128) >> 8)) >> 31) | ((unsigned __int16)(v62 + 128) >> 8);
        v57 += 3;
      }
      while (3 * (1 << v46) != v57);
      v63 = (CGColorSpace *)*((_QWORD *)this + 20);
      if (!v63)
        v63 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
      if ((unint64_t)(v58 - 1) >= 0xFF)
        v64 = 255;
      else
        v64 = v58 - 1;
      *((_QWORD *)this + 20) = CGColorSpaceCreateIndexed(v63, v64, v47);
      free(v47);
      CFRelease(v63);
LABEL_98:
      Lab = (CGColorSpaceRef)*((_QWORD *)this + 20);
      if (!Lab)
      {
        if (*((_DWORD *)this + 81) == 1281450528)
        {
          *(_OWORD *)whitePoint = xmmword_188210610;
          v71 = 0x3FEA6594AF4F0D84;
          memset(blackPoint, 0, sizeof(blackPoint));
          length_4[0] = xmmword_188210628;
          length_4[1] = unk_188210638;
          Lab = CGColorSpaceCreateLab(whitePoint, blackPoint, (const CGFloat *)length_4);
          *((_QWORD *)this + 20) = Lab;
        }
        else
        {
          Lab = 0;
        }
      }
      if (*((_BYTE *)this + 345))
      {
        if (Lab)
          return 0;
        goto LABEL_108;
      }
      result = 0;
      if (*((_BYTE *)this + 566) && !Lab)
      {
LABEL_108:
        v66 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D958]);
        result = 0;
        *((_QWORD *)this + 20) = v66;
      }
      return result;
    default:
      if (*((unsigned __int16 *)this + 228) == 32845)
        goto LABEL_21;
      goto LABEL_17;
  }
}

uint64_t TIFFReadPlugin::updateSubsample(TIFFReadPlugin *this, unsigned int a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  double v5;
  int v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned __int16 v11;
  _BOOL4 v12;
  unsigned __int16 v13;
  unsigned int v14;
  unsigned int v15;

  *((_WORD *)this + 158) = 0;
  v2 = *((_DWORD *)this + 112);
  v3 = *((_DWORD *)this + 113);
  *((_DWORD *)this + 57) = v2;
  *((_DWORD *)this + 58) = v3;
  *((_DWORD *)this + 65) = v2;
  *((_DWORD *)this + 66) = v3;
  if (!a2)
  {
    v4 = *((_DWORD *)this + 53);
    if (v4)
    {
      v5 = (double)v2 / (double)v4;
      if (v5 <= (double)v3 / (double)v4)
        v5 = (double)v3 / (double)v4;
      a2 = v5;
    }
    else
    {
      a2 = 0;
    }
  }
  if ((gIIODebugFlags & 0x200000000) != 0)
    v6 = 1;
  else
    v6 = a2;
  v7 = *((unsigned __int16 *)this + 228);
  if (v7 == 6)
    v8 = 1;
  else
    v8 = v6;
  if (v2 >= v3)
    v9 = v3;
  else
    v9 = v2;
  if (v8 <= v9 && v8 >= 2)
  {
    v11 = *((_WORD *)this + 229);
    v12 = ((v11 - 8) & 0xFFF7) == 0
       && ((v13 = v7 - 3, v13 >= 8u) || ((0xE1u >> v13) & 1) == 0)
       && *((unsigned __int16 *)this + 244) - 1 < 5;
    if (!*((_BYTE *)this + 561)
      && *((_WORD *)this + 233) != 2
      && (*((_WORD *)this + 229) == 16 || *((_WORD *)this + 229) == 8)
      && v12)
    {
      if (*((_BYTE *)this + 216) == 3)
      {
        v14 = *((_DWORD *)this + 53);
        if (v14)
        {
          if (v14 >= (v2 + 31) >> 5 && v14 >= (v3 + 31) >> 5)
          {
            if (v14 >= (v2 + 15) >> 4 && v14 >= (v3 + 15) >> 4)
            {
              if (v14 >= (v2 + 7) >> 3 && v14 >= (v3 + 7) >> 3)
              {
                if (v14 >= (v2 + 3) >> 2 && v14 >= (v3 + 3) >> 2)
                {
                  if (v14 >= (v2 + 1) >> 1)
                  {
                    if (v14 >= (v3 + 1) >> 1)
                      v15 = 1;
                    else
                      v15 = 2;
                  }
                  else
                  {
                    v15 = 2;
                  }
                }
                else
                {
                  v15 = 4;
                }
                goto LABEL_56;
              }
LABEL_52:
              v15 = 8;
              goto LABEL_56;
            }
LABEL_50:
            v15 = 16;
            goto LABEL_56;
          }
LABEL_48:
          v15 = 32;
          goto LABEL_56;
        }
        v15 = 1;
      }
      else if (v8 <= 0x7F)
      {
        if (v8 <= 0x3F)
        {
          if (v8 <= 0x1F)
          {
            if (v8 <= 0xF)
            {
              if (v8 <= 7)
              {
                if (v8 <= 3)
                  v15 = 2;
                else
                  v15 = 4;
                goto LABEL_56;
              }
              goto LABEL_52;
            }
            goto LABEL_50;
          }
          goto LABEL_48;
        }
        v15 = 64;
      }
      else
      {
        v15 = 128;
      }
LABEL_56:
      *((_WORD *)this + 158) = v15;
      *((_DWORD *)this + 65) = v2 / v15;
      *((_DWORD *)this + 66) = v3 / v15;
      *((_DWORD *)this + 67) = ((v2 * v11 * *((unsigned __int16 *)this + 244) + 7) >> 3) / v15;
    }
  }
  return 0;
}

uint64_t TIFFReadPlugin::sanityCheck(TIFFReadPlugin *this)
{
  unsigned int v2;
  unsigned int v3;
  unint64_t Size;
  unsigned int v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  int v10;
  unint64_t v11;
  uint64_t v12;

  v2 = *((_DWORD *)this + 112);
  if (v2 <= 0x3E8)
  {
    v3 = *((_DWORD *)this + 113);
    if (v3 <= 0x3E8)
      return 0;
  }
  else
  {
    v3 = *((_DWORD *)this + 113);
    if (v2 > 0x30D40)
      goto LABEL_6;
  }
  if (v3 > 0x30D40)
  {
LABEL_6:
    LogError("sanityCheck", 1364, "image too large (%ld x %ld)\n");
    return 4294967246;
  }
  Size = (unint64_t)IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
  v6 = *((_DWORD *)this + 112);
  v7 = *((unsigned __int16 *)this + 229);
  v8 = *((unsigned __int16 *)this + 244) * (unint64_t)v6 * v7;
  v9 = (v8 + 7) >> 3;
  v10 = *((unsigned __int16 *)this + 232);
  if (v10 == 1)
  {
    if (v9 > Size)
    {
      _cg_jpeg_mem_term("sanityCheck", 1376, "oneRow > imageSize (%ld > %ld)\n");
      return 4294967246;
    }
    if (v9 * *((unsigned int *)this + 113) > Size && *((_WORD *)this + 228) != 6)
    {
      _cg_jpeg_mem_term("sanityCheck", 1381, "oneRow * height > imageSize (%ld > %ld)\n");
      return 4294967246;
    }
  }
  if (*((_BYTE *)this + 561))
  {
    if (Size <= (*((_DWORD *)this + 113) + *((_DWORD *)this + 130) - 1)
               * ((v6 + *((_DWORD *)this + 129) - 1)
                / *((_DWORD *)this + 129))
               / *((_DWORD *)this + 130))
    {
      LogError("sanityCheck", 1391, "ERROR: too many tiles (%ld)\n");
      return 4294967246;
    }
    if (Size <= *(unsigned int *)(*((_QWORD *)this + 55) + 228))
    {
      LogError("sanityCheck", 1392, "ERROR: too many tiles (%ld)\n");
      return 4294967246;
    }
  }
  if (v10 == 5)
  {
    v11 = (v8 + 7) / 0x1F40;
    if (v8 < 0x1F39)
      v11 = 1;
    v12 = *((unsigned int *)this + 113);
    if (Size < v11 * v12
      && *((_BYTE *)this + 341)
      && ((unint64_t)(float)((float)((float)v9 * (float)v12) / (float)Size) >> 4 > 0x270
       || (_DWORD)v7 != 1))
    {
      return 4294967246;
    }
  }
  return 0;
}

uint64_t _CGImageReadSessionFinalize(_QWORD *a1)
{
  unint64_t v2;
  uint64_t result;

  do
    v2 = __ldxr(&gReadSessionCount);
  while (__stxr(v2 - 1, &gReadSessionCount));
  result = a1[3];
  if (result)
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  a1[2] = 0;
  a1[3] = 0;
  return result;
}

void IIOImageReadSession::~IIOImageReadSession(IIOImageReadSession *this)
{
  IIOImageReadSession::~IIOImageReadSession(this);
  JUMPOUT(0x18D761C30);
}

{
  const void *v1;
  _QWORD *v2;

  *((_QWORD *)this + 5) = 0;
  *(_QWORD *)this = &off_1E1BB1BD0;
  *((_QWORD *)this + 1) = 0;
  v2 = (_QWORD *)((char *)this + 24);
  v1 = (const void *)*((_QWORD *)this + 3);
  if (v1)
    CFRelease(v1);
  *v2 = 0;
  v2[1] = 0;
}

uint64_t imageio_value_release(void *a1, void *a2)
{
  if ((gIIODebugFlags & 0x200) != 0)
    ImageIOLog("    imageio_value_release ptr: %p   userData: %p\n", a1, a2);
  return _ImageIO_Free((unint64_t)a1, (size_t)a2);
}

uint64_t IIOImageRead::setCachedImageBlockData(uint64_t a1, __int128 *a2, void *a3, cache_cost_t a4)
{
  pthread_mutex_t *v8;
  char *DebugStringFromKey;
  char *v10;
  __int128 *v11;
  __int128 *v12;
  __int128 v13;
  __int128 v14;
  char *v15;
  char *v16;
  _OWORD *v17;
  unint64_t v18;
  __int128 v19;
  __int128 v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  char *v27;
  char *v28;
  char *v29;
  __int128 v30;
  __int128 v31;
  char *v32;
  char *v33;
  __int128 v34;
  __int128 v35;
  __int128 v37;
  _BYTE v38[28];

  v8 = (pthread_mutex_t *)(a1 + 312);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 312));
  cache_set_and_retain((cache_t *)gImageBlockCache, a2, a3, a4);
  DebugStringFromKey = createDebugStringFromKey((uint64_t)a2);
  if (DebugStringFromKey)
  {
    v10 = DebugStringFromKey;
    ImageIOLog("ADD cache_set_and_retain:  %p:   data: %12p key: %s  (size=%ld) \n", (const void *)gImageBlockCache, a3, DebugStringFromKey, a4);
    free(v10);
  }
  v11 = *(__int128 **)(a1 + 288);
  v12 = *(__int128 **)(a1 + 296);
  while (v11 != v12)
  {
    v13 = *v11;
    v14 = v11[1];
    *(_OWORD *)&v38[12] = *(__int128 *)((char *)v11 + 28);
    v37 = v13;
    *(_OWORD *)v38 = v14;
    if (imageio_key_is_equal((char *)&v37, (char *)a2, 0))
      return pthread_mutex_unlock(v8);
    v11 = (__int128 *)((char *)v11 + 44);
  }
  v15 = createDebugStringFromKey((uint64_t)a2);
  if (v15)
  {
    v16 = v15;
    ImageIOLog("+++ setCachedImageBlockData adding new key: %p:   data: %12p key: %s  (size=%ld) \n", (const void *)gImageBlockCache, a3, v15, a4);
    free(v16);
  }
  v17 = *(_OWORD **)(a1 + 296);
  v18 = *(_QWORD *)(a1 + 304);
  if ((unint64_t)v17 >= v18)
  {
    v22 = *(_QWORD *)(a1 + 288);
    v23 = 0x2E8BA2E8BA2E8BA3 * (((uint64_t)v17 - v22) >> 2);
    v24 = v23 + 1;
    if ((unint64_t)(v23 + 1) > 0x5D1745D1745D174)
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    v25 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v18 - v22) >> 2);
    if (2 * v25 > v24)
      v24 = 2 * v25;
    if (v25 >= 0x2E8BA2E8BA2E8BALL)
      v26 = 0x5D1745D1745D174;
    else
      v26 = v24;
    if (v26)
      v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<imageio_key>>(a1 + 304, v26);
    else
      v27 = 0;
    v28 = &v27[44 * v23];
    v29 = &v27[44 * v26];
    v30 = *a2;
    v31 = a2[1];
    *(_OWORD *)(v28 + 28) = *(__int128 *)((char *)a2 + 28);
    *(_OWORD *)v28 = v30;
    *((_OWORD *)v28 + 1) = v31;
    v21 = v28 + 44;
    v33 = *(char **)(a1 + 288);
    v32 = *(char **)(a1 + 296);
    if (v32 != v33)
    {
      do
      {
        v34 = *(_OWORD *)(v32 - 44);
        v35 = *(_OWORD *)(v32 - 28);
        *((_OWORD *)v28 - 1) = *((_OWORD *)v32 - 1);
        *(_OWORD *)(v28 - 28) = v35;
        *(_OWORD *)(v28 - 44) = v34;
        v28 -= 44;
        v32 -= 44;
      }
      while (v32 != v33);
      v32 = *(char **)(a1 + 288);
    }
    *(_QWORD *)(a1 + 288) = v28;
    *(_QWORD *)(a1 + 296) = v21;
    *(_QWORD *)(a1 + 304) = v29;
    if (v32)
      operator delete(v32);
  }
  else
  {
    v19 = *a2;
    v20 = a2[1];
    *(_OWORD *)((char *)v17 + 28) = *(__int128 *)((char *)a2 + 28);
    *v17 = v19;
    v17[1] = v20;
    v21 = (char *)v17 + 44;
  }
  *(_QWORD *)(a1 + 296) = v21;
  return pthread_mutex_unlock(v8);
}

void PNGReadPlugin::DecodeFrameInterlaced(IIOImageReadSession *a1, uint64_t a2, _BYTE *a3, _QWORD *a4)
{
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  void *v11;
  unsigned int *v12;
  unint64_t v13;
  int v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  unsigned int v18;
  int v19;
  uint64_t v20;
  unsigned int v21;
  int v22;
  uint64_t v23;
  unsigned int v24;
  int v25;
  uint64_t v26;
  int v27;
  unsigned int v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  unsigned int v32;
  int v33;
  uint64_t v34;
  unsigned int v35;
  int v36;
  uint64_t v37;
  unsigned int v38;
  int v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  char *v46;
  int v47;
  char *v48;
  void *v50;
  _QWORD *v51;

  v50 = 0;
  v7 = *(unsigned int *)(a2 + 48);
  v51 = 0;
  v8 = a4[6];
  v9 = _cg_png_create_read_struct("1.6.43", 0, (uint64_t)handle_error, (uint64_t)handle_warning);
  v51 = v9;
  if (v9)
  {
    v10 = v9;
    _cg_png_create_info_struct((uint64_t)v9);
    v50 = v11;
    if (!v11)
      goto LABEL_79;
    v12 = (unsigned int *)v11;
    _cg_png_set_option((uint64_t)v10, 2u, 3);
    _cg_png_set_benign_errors((uint64_t)v10, 1);
    v13 = *(_QWORD *)(a2 + 8);
    if (v13)
      IIOImageReadSession::seek(a1, v13, 0);
    else
      IIOImageReadSession::rewind((uint64_t)a1);
    _cg_png_set_read_fn(v10, (uint64_t)a1, (size_t (*)(size_t, void *, size_t))read_fn);
    if (!*(_BYTE *)(a2 + 157))
    {
      _cg_png_set_palette_to_rgb((uint64_t)v10);
      if ((gIIODebugFlags & 0x20000) != 0)
      {
        v14 = *(_DWORD *)(a2 + 20);
        v15 = v14 >> 24;
        if (v14 < 0)
        {
          v16 = __maskrune(v15, 0x40000uLL);
          v14 = *(_DWORD *)(a2 + 20);
          v15 = v14 >> 24;
        }
        else
        {
          v16 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v15 + 60) & 0x40000;
        }
        if (v16)
          v17 = v15;
        else
          v17 = 46;
        v18 = v14 << 8 >> 24;
        if (v14 << 8 < 0)
        {
          v19 = __maskrune(v18, 0x40000uLL);
          v14 = *(_DWORD *)(a2 + 20);
          v18 = v14 << 8 >> 24;
        }
        else
        {
          v19 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v18 + 60) & 0x40000;
        }
        if (v19)
          v20 = v18;
        else
          v20 = 46;
        v21 = (__int16)v14 >> 8;
        if (v14 << 16 < 0)
        {
          v22 = __maskrune(v21, 0x40000uLL);
          v14 = *(_DWORD *)(a2 + 20);
          v21 = (__int16)v14 >> 8;
        }
        else
        {
          v22 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v21 + 60) & 0x40000;
        }
        if (v22)
          v23 = v21;
        else
          v23 = 46;
        v24 = (char)v14;
        if ((v14 << 24) <= 0x7F000000)
        {
          v25 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v14 + 60) & 0x40000;
        }
        else
        {
          v25 = __maskrune((char)v14, 0x40000uLL);
          v24 = *(char *)(a2 + 20);
        }
        if (v25)
          v26 = v24;
        else
          v26 = 46;
        ImageIOLog("♦️  '%c%c%c%c' %d: png_set_palette_to_rgb\n", v17, v20, v23, v26, 4614);
      }
    }
    _cg_png_set_expand_gray_1_2_4_to_8((uint64_t)v10);
    if ((gIIODebugFlags & 0x20000) != 0)
    {
      v27 = *(_DWORD *)(a2 + 20);
      v28 = v27 >> 24;
      v29 = MEMORY[0x1E0C80978];
      if (v27 < 0)
      {
        v30 = __maskrune(v28, 0x40000uLL);
        v27 = *(_DWORD *)(a2 + 20);
        v28 = v27 >> 24;
      }
      else
      {
        v30 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v28 + 60) & 0x40000;
      }
      if (v30)
        v31 = v28;
      else
        v31 = 46;
      v32 = v27 << 8 >> 24;
      if (v27 << 8 < 0)
      {
        v33 = __maskrune(v32, 0x40000uLL);
        v27 = *(_DWORD *)(a2 + 20);
        v32 = v27 << 8 >> 24;
      }
      else
      {
        v33 = *(_DWORD *)(v29 + 4 * v32 + 60) & 0x40000;
      }
      if (v33)
        v34 = v32;
      else
        v34 = 46;
      v35 = (__int16)v27 >> 8;
      if (v27 << 16 < 0)
      {
        v36 = __maskrune(v35, 0x40000uLL);
        v27 = *(_DWORD *)(a2 + 20);
        v35 = (__int16)v27 >> 8;
      }
      else
      {
        v36 = *(_DWORD *)(v29 + 4 * v35 + 60) & 0x40000;
      }
      if (v36)
        v37 = v35;
      else
        v37 = 46;
      v38 = (char)v27;
      if ((v27 << 24) <= 0x7F000000)
      {
        v39 = *(_DWORD *)(v29 + 4 * (char)v27 + 60) & 0x40000;
      }
      else
      {
        v39 = __maskrune((char)v27, 0x40000uLL);
        v38 = *(char *)(a2 + 20);
      }
      if (v39)
        v40 = v38;
      else
        v40 = 46;
      ImageIOLog("♦️  '%c%c%c%c' %d: png_set_expand_gray_1_2_4_to_8\n", v31, v34, v37, v40, 4617);
    }
    _cg_png_set_keep_unknown_chunks_sized((uint64_t)v10, 3u, "CgBI", 4);
    _cg_png_set_read_user_chunk_fn((uint64_t)v10, (uint64_t)a3, (uint64_t)PNGReadPlugin::Read_user_chunk_callback);
    _cg_png_read_info((uLong)v10, v12);
    v41 = _cg_png_set_interlace_handling((uint64_t)v10);
    if (*(_BYTE *)(a2 + 63) == 1)
      _cg_png_set_swap((uint64_t)v10);
    PNGReadPlugin::Update_png_struct(a2, a3, (uint64_t)v10, v12);
    if (v41 >= 1)
    {
      v42 = 0;
      v43 = -1;
      do
      {
        if ((_DWORD)v7)
        {
          v44 = 0;
          v45 = (char *)a4[5];
          do
          {
            if (*(_BYTE *)(a2 + 157))
              v46 = v45;
            else
              v46 = 0;
            if (*(_BYTE *)(a2 + 157))
              v47 = v8;
            else
              v47 = 0;
            if (*(_BYTE *)(a2 + 157))
              v48 = 0;
            else
              v48 = v45;
            _cg_png_read_row_sized((uLong)v10, v46, v47, v48);
            v45 += v8;
            if (v43 <= v44)
              v43 = v44 + 1;
            ++v44;
          }
          while (v7 != v44);
        }
        ++v42;
      }
      while (v42 != v41);
    }
    else
    {
LABEL_79:
      v43 = -1;
    }
    _cg_png_destroy_read_struct((uint64_t *)&v51, &v50, 0);
  }
  else
  {
    v43 = -1;
  }
  a4[8] = v43 & ~(v43 >> 63);
}

void sub_187E806A0(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  uint64_t v16;

  __cxa_begin_catch(a1);
  imagePNG_error_break(v16);
  _cg_png_get_height(a16);
  _cg_png_get_current_row_number(a16);
  __cxa_end_catch();
  if (!a16)
    JUMPOUT(0x187E80670);
  JUMPOUT(0x187E80660);
}

void sub_187E806F0(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t png_read_finish_IDAT(uint64_t result)
{
  uint64_t v1;
  int v2;

  v1 = result;
  if ((*(_BYTE *)(result + 80) & 8) == 0)
  {
    result = png_read_IDAT_data(result, 0);
    *(_QWORD *)(v1 + 120) = 0;
    v2 = *(_DWORD *)(v1 + 80);
    if ((v2 & 8) == 0)
    {
      *(_DWORD *)(v1 + 76) |= 8u;
      *(_DWORD *)(v1 + 80) = v2 | 8;
    }
  }
  if (*(_DWORD *)(v1 + 92) == 1229209940)
  {
    *(_QWORD *)(v1 + 92) = 0;
    *(_QWORD *)(v1 + 100) = 0;
    return png_crc_finish(v1, *(unsigned int *)(v1 + 360));
  }
  return result;
}

uint64_t _cg_png_set_expand_gray_1_2_4_to_8(uint64_t result)
{
  int v1;

  if (result)
  {
    v1 = *(_DWORD *)(result + 80);
    if ((v1 & 0x40) != 0)
    {
      return png_app_error(result, "invalid after png_start_read_image or png_read_update_info");
    }
    else
    {
      *(_DWORD *)(result + 80) = v1 | 0x4000;
      *(_DWORD *)(result + 88) |= 0x1000u;
    }
  }
  return result;
}

uint64_t png_decompress_chunk(uint64_t a1, int a2, unsigned int a3, unint64_t *a4)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  unint64_t v14;
  size_t v15;
  _BYTE *v16;
  _BYTE *v17;
  void *v18;
  int v20;

  v8 = *(_QWORD *)(a1 + 888);
  if (v8 + 1 > 1)
  {
    v9 = a3 + 1;
    if (v8 < v9)
    {
      v12 = 4294967292;
      png_zstream_error(a1, -4);
      return v12;
    }
  }
  else
  {
    v9 = a3 + 1;
    v8 = -1;
  }
  v10 = v8 - v9;
  if (v10 < *a4)
    *a4 = v10;
  v11 = png_inflate_claim(a1, *(_DWORD *)(a1 + 312));
  if (!v11)
  {
    v13 = a2 - a3;
    v20 = a2 - a3;
    v12 = png_inflate(a1, *(unsigned int *)(a1 + 312));
    if ((_DWORD)v12 == 1)
    {
      if (inflateReset((z_streamp)(a1 + 96)))
      {
        png_zstream_error(a1, 1);
        v12 = 4294967289;
      }
      else
      {
        v14 = *a4;
        v15 = a3 + *a4 + 1;
        v16 = png_malloc_base(a1, v15);
        if (v16)
        {
          v17 = v16;
          bzero(v16, v15);
          v12 = png_inflate(a1, *(unsigned int *)(a1 + 312));
          if ((_DWORD)v12 == 1)
          {
            if (v14 == *a4)
            {
              v17[v14 + a3] = 0;
              v18 = *(void **)(a1 + 936);
              if (a3)
                memcpy(v17, *(const void **)(a1 + 936), a3);
              *(_QWORD *)(a1 + 936) = v17;
              *(_QWORD *)(a1 + 944) = v15;
              png_free(a1, v18);
              if (v13 != v20)
                png_chunk_benign_error(a1, "extra compressed data");
              v12 = 1;
              goto LABEL_25;
            }
            v12 = 4294967289;
          }
          png_free(a1, v17);
        }
        else
        {
          v12 = 4294967292;
          png_zstream_error(a1, -4);
        }
      }
    }
LABEL_25:
    *(_DWORD *)(a1 + 92) = 0;
    return v12;
  }
  if (v11 == 1)
    return 4294967289;
  else
    return v11;
}

uint64_t png_inflate(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _DWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  int v8;
  _QWORD *v9;
  uint64_t v10;
  _DWORD *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  _BYTE v21[4096];
  uint64_t v22;

  v2 = MEMORY[0x1E0C80A78](a1, a2);
  v7 = v2;
  v22 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(v2 + 92) == v8)
  {
    v9 = v6;
    v10 = v5;
    v11 = v4;
    v12 = *v6;
    v13 = *v4;
    *(_QWORD *)(v2 + 96) = v3;
    *(_DWORD *)(v2 + 104) = 0;
    *(_DWORD *)(v2 + 128) = 0;
    if (v5)
      *(_QWORD *)(v2 + 120) = v5;
    do
    {
      bzero(v21, 0x1000uLL);
      *(_DWORD *)(v7 + 104) += v13;
      if (v10)
      {
        LODWORD(v14) = -1;
      }
      else
      {
        *(_QWORD *)(v7 + 120) = v21;
        LODWORD(v14) = 4096;
      }
      v15 = v12 + *(unsigned int *)(v7 + 128);
      if (v15 >= v14)
        v14 = v14;
      else
        v14 = v15;
      *(_DWORD *)(v7 + 128) = v14;
      v12 = v15 - v14;
      v16 = png_zlib_inflate(v7, 4 * (v15 == v14));
      v13 = 0;
    }
    while (!(_DWORD)v16);
    v17 = v16;
    if (!v10)
      *(_QWORD *)(v7 + 120) = 0;
    v18 = *(_DWORD *)(v7 + 104);
    v19 = v12 + *(unsigned int *)(v7 + 128);
    if (v19)
      *v9 -= v19;
    if (v18)
      *v11 -= v18;
    png_zstream_error(v7, v16);
  }
  else
  {
    *(_QWORD *)(v2 + 144) = "zstream unclaimed";
    return 4294967294;
  }
  return v17;
}

void _cg_png_set_iCCP(_QWORD *a1, uint64_t a2, char *a3, int a4, unsigned int *a5, unint64_t a6)
{
  int v11;
  size_t v12;
  _QWORD *v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v16;
  char *v17;

  if (a1 && a2 && a3 && a5)
  {
    if (a4)
      png_app_error((uint64_t)a1, "Invalid iCCP compression method");
    v11 = png_colorspace_set_ICC((uint64_t)a1, a2 + 52, a3, a6, a5, *(_BYTE *)(a2 + 37));
    png_colorspace_sync_info((uint64_t)a1, a2);
    if (v11)
    {
      *(_WORD *)(a2 + 126) |= 0x18u;
      v12 = strlen(a3) + 1;
      v13 = png_malloc_warn(a1, v12);
      if (v13)
      {
        v14 = v13;
        memcpy(v13, a3, v12);
        v15 = png_malloc_warn(a1, a6);
        if (v15)
        {
          v16 = v15;
          memcpy(v15, a5, a6);
          png_free_data((uint64_t)a1, a2, 0x10u, 0);
          *(_DWORD *)(a2 + 144) = a6;
          *(_QWORD *)(a2 + 128) = v14;
          *(_QWORD *)(a2 + 136) = v16;
          *(_DWORD *)(a2 + 300) |= 0x10u;
          *(_DWORD *)(a2 + 8) |= 0x1000u;
          return;
        }
        png_free((uint64_t)a1, v14);
        v17 = "Insufficient memory to process iCCP profile";
      }
      else
      {
        v17 = "Insufficient memory to process iCCP chunk";
      }
      png_benign_error((uint64_t)a1, v17);
    }
  }
}

uint64_t png_colorspace_set_ICC(uint64_t a1, uint64_t a2, _BYTE *a3, unint64_t a4, unsigned int *a5, char a6)
{
  unsigned int v6;
  uint64_t result;

  if (*(__int16 *)(a2 + 74) < 0)
    return 0;
  v6 = a4;
  if (a4 <= 0x83)
  {
    png_icc_profile_error(a1, a2, a3, a4, "too short");
    return 0;
  }
  result = png_icc_check_header(a1, a2, a3, a4, (uint64_t)a5, a6);
  if ((_DWORD)result)
  {
    result = png_icc_check_tag_table(a1, a2, a3, v6, (uint64_t)a5);
    if ((_DWORD)result)
    {
      png_icc_set_sRGB(a1, a2, a5, 0);
      return 1;
    }
  }
  return result;
}

void png_handle_iCCP(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  const char *v8;
  int v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  size_t v18;
  uint64_t v19;
  unint64_t v20;
  int v21;
  int v22;
  int v23;
  unsigned int v24;
  _OWORD *buffer;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  void *v33;
  unsigned int *v34;
  unint64_t v35;
  unsigned int v36;
  Bytef v37[4096];
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  int v46;
  _OWORD __src[5];
  char v48;
  uint64_t v49;

  v2 = MEMORY[0x1E0C80A78](a1, a2);
  v5 = v2;
  v49 = *MEMORY[0x1E0C80C00];
  v36 = v4;
  v6 = *(_DWORD *)(v2 + 76);
  if ((v6 & 1) == 0)
    png_chunk_error((void (**)(void))v2, "missing IHDR");
  v7 = v4;
  if ((v6 & 6) != 0)
  {
    png_crc_finish(v2, v4);
    v8 = "out of place";
LABEL_6:
    png_chunk_benign_error(v5, v8);
    return;
  }
  if (v4 <= 0xD)
  {
    png_crc_finish(v2, v4);
    v8 = "too short";
    goto LABEL_6;
  }
  v9 = *(__int16 *)(v2 + 1074);
  if (v9 < 0)
  {
    png_crc_finish(v2, v4);
    return;
  }
  v10 = v3;
  if ((v9 & 4) == 0)
  {
    v48 = 0;
    memset(__src, 0, sizeof(__src));
    if (v4 >= 0x51)
      v11 = 81;
    else
      v11 = v4;
    png_crc_read(v2, (Bytef *)__src, v11);
    v12 = v7 - v11;
    v36 = v12;
    if (v12 < 0xB)
    {
      png_crc_finish(v5, v12);
      v13 = "too short";
      v14 = v5;
      goto LABEL_31;
    }
    v16 = 0;
    if (v7 >= 0x50)
      v17 = 80;
    else
      v17 = v7;
    while (*((_BYTE *)__src + v16))
    {
      if (v17 == ++v16)
        goto LABEL_23;
    }
    LODWORD(v17) = v16;
LABEL_23:
    if ((v17 - 1) > 0x4E)
    {
      v15 = "bad keyword";
      goto LABEL_28;
    }
    v18 = v17 + 1;
    if (v18 >= v11 || *((_BYTE *)__src + v18))
    {
      v15 = "bad compression method";
      goto LABEL_28;
    }
    if (png_inflate_claim(v5, 1766015824))
    {
      v15 = *(const char **)(v5 + 144);
      goto LABEL_28;
    }
    v19 = (v17 + 2);
    v46 = 0;
    v45 = 0u;
    v44 = 0u;
    v43 = 0u;
    v42 = 0u;
    v41 = 0u;
    v40 = 0u;
    v39 = 0u;
    v38 = 0u;
    bzero(v37, 0x1000uLL);
    v35 = 132;
    *(_QWORD *)(v5 + 96) = (char *)__src + v19;
    *(_DWORD *)(v5 + 104) = v11 - v19;
    png_inflate_read(v5, v37, &v36, (uint64_t)&v38, (uint64_t *)&v35, 0);
    if (v35)
      goto LABEL_36;
    v20 = bswap32(v38);
    if (!png_icc_check_length(v5, v5 + 1000, __src, v20)
      || !png_icc_check_header(v5, v5 + 1000, __src, v20, (uint64_t)&v38, *(_BYTE *)(v5 + 391)))
    {
      goto LABEL_45;
    }
    v21 = v46;
    v22 = BYTE1(v46);
    v23 = BYTE2(v46);
    v24 = HIBYTE(v46);
    buffer = png_read_buffer(v5, v20, 2);
    if (!buffer)
    {
      v15 = "out of memory";
      goto LABEL_46;
    }
    v26 = v45;
    buffer[6] = v44;
    buffer[7] = v26;
    *((_DWORD *)buffer + 32) = v46;
    v27 = v41;
    buffer[2] = v40;
    buffer[3] = v27;
    v28 = v43;
    buffer[4] = v42;
    buffer[5] = v28;
    v29 = v39;
    *buffer = v38;
    buffer[1] = v29;
    v30 = 12 * ((v21 << 24) | (v22 << 16) | (v23 << 8) | v24);
    v34 = (unsigned int *)buffer;
    v35 = v30;
    v31 = (char *)buffer + 132;
    png_inflate_read(v5, v37, &v36, (uint64_t)buffer + 132, (uint64_t *)&v35, 0);
    if (v35)
      goto LABEL_36;
    if (!png_icc_check_tag_table(v5, v5 + 1000, __src, v20, (uint64_t)v34))
    {
LABEL_45:
      v15 = 0;
      goto LABEL_46;
    }
    v35 = v20 - v30 - 132;
    png_inflate_read(v5, v37, &v36, (uint64_t)&v31[v30], (uint64_t *)&v35, 1);
    v32 = v36;
    if (v36)
    {
      if ((*(_BYTE *)(v5 + 82) & 0x10) == 0)
      {
        v15 = "extra compressed data";
        goto LABEL_46;
      }
      if (!v35)
      {
        png_chunk_warning(v5, "extra compressed data");
        goto LABEL_52;
      }
    }
    else if (!v35)
    {
LABEL_52:
      png_crc_finish(v5, v32);
      png_icc_set_sRGB(v5, v5 + 1000, v34, *(_QWORD *)(v5 + 192));
      if (v10)
      {
        png_free_data(v5, v10, 0x10u, 0);
        v33 = png_malloc_base(v5, v18);
        *(_QWORD *)(v10 + 128) = v33;
        if (!v33)
        {
          *(_WORD *)(v5 + 1074) |= 0x8000u;
          png_colorspace_sync(v5, v10);
          *(_DWORD *)(v5 + 92) = 0;
          v15 = "out of memory";
          goto LABEL_29;
        }
        memcpy(v33, __src, v18);
        *(_DWORD *)(v10 + 144) = v20;
        *(_QWORD *)(v10 + 136) = v34;
        *(_QWORD *)(v5 + 936) = 0;
        *(_DWORD *)(v10 + 300) |= 0x10u;
        *(_DWORD *)(v10 + 8) |= 0x1000u;
        png_colorspace_sync(v5, v10);
      }
      *(_DWORD *)(v5 + 92) = 0;
      *(_QWORD *)(v5 + 96) = 0;
      return;
    }
LABEL_36:
    v15 = *(const char **)(v5 + 144);
LABEL_46:
    *(_DWORD *)(v5 + 92) = 0;
    goto LABEL_28;
  }
  v15 = "too many profiles";
LABEL_28:
  png_crc_finish(v5, v36);
LABEL_29:
  *(_WORD *)(v5 + 1074) |= 0x8000u;
  png_colorspace_sync(v5, v10);
  *(_QWORD *)(v5 + 96) = 0;
  if (!v15)
    return;
  v14 = v5;
  v13 = v15;
LABEL_31:
  png_chunk_benign_error(v14, v13);
}

uint64_t png_zstream_error(uint64_t result, int a2)
{
  const char *v2;

  if (!*(_QWORD *)(result + 144))
  {
    if ((a2 + 7) > 9)
      v2 = "unexpected zlib return code";
    else
      v2 = off_1E1BC95E8[a2 + 7];
    *(_QWORD *)(result + 144) = v2;
  }
  return result;
}

uint64_t png_inflate_read(uint64_t result, Bytef *a2, unsigned int *a3, uint64_t a4, uint64_t *a5, int a6)
{
  uint64_t v6;
  int v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;

  v6 = result;
  if (*(_DWORD *)(result + 92) == *(_DWORD *)(result + 312))
  {
    *(_QWORD *)(result + 120) = a4;
    *(_DWORD *)(result + 128) = 0;
    if (a6)
      v10 = 4;
    else
      v10 = 2;
    v11 = 4096;
    while (1)
    {
      if (!*(_DWORD *)(v6 + 104))
      {
        if (v11 >= *a3)
          v11 = *a3;
        *a3 -= v11;
        if (v11)
          png_crc_read(v6, a2, v11);
        *(_QWORD *)(v6 + 96) = a2;
        *(_DWORD *)(v6 + 104) = v11;
      }
      if (!*(_DWORD *)(v6 + 128))
      {
        if ((unint64_t)*a5 >= 0xFFFFFFFF)
          v12 = 0xFFFFFFFFLL;
        else
          v12 = *a5;
        *a5 -= v12;
        *(_DWORD *)(v6 + 128) = v12;
      }
      v13 = *a3 ? 0 : v10;
      v14 = png_zlib_inflate(v6, v13);
      if (v14)
        break;
      if (!*a5 && !*(_DWORD *)(v6 + 128))
      {
        v15 = 0;
        goto LABEL_26;
      }
    }
    v15 = *a5 + *(unsigned int *)(v6 + 128);
LABEL_26:
    *a5 = v15;
    *(_DWORD *)(v6 + 128) = 0;
    return png_zstream_error(v6, v14);
  }
  else
  {
    *(_QWORD *)(result + 144) = "zstream unclaimed";
  }
  return result;
}

uint64_t png_handle_tEXt(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3;
  int v6;
  int v7;
  uint64_t result;
  const char *v9;
  int v10;
  Bytef *buffer;
  Bytef *v12;
  uint64_t v13;
  Bytef *v15;
  _QWORD v16[2];
  const char *v17;
  size_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v3 = a3;
  v6 = *(_DWORD *)(a1 + 884);
  if (v6)
  {
    v7 = v6 - 1;
    if (!v7)
      return png_crc_finish(a1, a3);
    *(_DWORD *)(a1 + 884) = v7;
    if (v7 == 1)
    {
      png_crc_finish(a1, a3);
      v9 = "no space in chunk cache";
      return png_chunk_benign_error(a1, v9);
    }
  }
  v10 = *(_DWORD *)(a1 + 76);
  if ((v10 & 1) == 0)
    png_chunk_error((void (**)(void))a1, "missing IHDR");
  if ((v10 & 4) != 0)
    *(_DWORD *)(a1 + 76) = v10 | 8;
  buffer = (Bytef *)png_read_buffer(a1, (a3 + 1), 1);
  if (!buffer)
  {
    v9 = "out of memory";
    return png_chunk_benign_error(a1, v9);
  }
  v12 = buffer;
  png_crc_read(a1, buffer, v3);
  result = png_crc_finish(a1, 0);
  if (!(_DWORD)result)
  {
    v13 = 0;
    v12[v3] = 0;
    while (v12[v13++])
      ;
    if (v3 + 1 == v13)
      v15 = v12;
    else
      v15 = v12 + 1;
    v16[1] = v12;
    v16[0] = 0xFFFFFFFFLL;
    v20 = 0;
    v21 = 0;
    v19 = 0;
    v17 = (const char *)&v15[v13 - 1];
    v18 = strlen(v17);
    result = png_set_text_2((void (**)(void))a1, a2, (uint64_t)v16, 1);
    if ((_DWORD)result)
      return png_warning(a1, "Insufficient memory to process text chunk");
  }
  return result;
}

uint64_t png_handle_iTXt(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  int v7;
  uint64_t result;
  const char *v9;
  int v10;
  Bytef *buffer;
  Bytef *v12;
  uint64_t v13;
  const char *v14;
  Bytef *v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  Bytef *v20;
  int v21;
  unsigned int v23;
  unint64_t v24;
  int v25;
  _QWORD v26[7];
  unint64_t v27;

  v6 = *(_DWORD *)(a1 + 884);
  if (v6)
  {
    v7 = v6 - 1;
    if (!v7)
      return png_crc_finish(a1, a3);
    *(_DWORD *)(a1 + 884) = v7;
    if (v7 == 1)
    {
      png_crc_finish(a1, a3);
      v9 = "no space in chunk cache";
      return png_chunk_benign_error(a1, v9);
    }
  }
  v10 = *(_DWORD *)(a1 + 76);
  if ((v10 & 1) == 0)
    png_chunk_error((void (**)(void))a1, "missing IHDR");
  if ((v10 & 4) != 0)
    *(_DWORD *)(a1 + 76) = v10 | 8;
  buffer = (Bytef *)png_read_buffer(a1, (a3 + 1), 1);
  if (!buffer)
  {
    png_crc_finish(a1, a3);
    v9 = "out of memory";
    return png_chunk_benign_error(a1, v9);
  }
  v12 = buffer;
  png_crc_read(a1, buffer, a3);
  result = png_crc_finish(a1, 0);
  if (!(_DWORD)result)
  {
    if (!(_DWORD)a3)
      goto LABEL_17;
    v13 = 0;
    while (v12[v13])
    {
      if (a3 == ++v13)
      {
        LODWORD(v13) = a3;
        break;
      }
    }
    if ((v13 - 80) < 0xFFFFFFB1)
    {
LABEL_17:
      v14 = "bad keyword";
      return png_chunk_benign_error(a1, v14);
    }
    if ((int)v13 + 5 > a3)
    {
      v14 = "truncated";
      return png_chunk_benign_error(a1, v14);
    }
    v15 = &v12[v13];
    v16 = v15[1];
    if (v15[1] && (v16 != 1 || v15[2]))
    {
      v14 = "bad compression info";
      return png_chunk_benign_error(a1, v14);
    }
    v17 = (v13 + 3);
    v18 = v17;
    while (v12[v18])
    {
      if ((_DWORD)a3 == (_DWORD)++v18)
      {
        LODWORD(v18) = a3;
        break;
      }
    }
    v19 = v18 + 1;
    if ((int)v18 + 1 >= a3)
    {
      v21 = v18 + 1;
    }
    else
    {
      v20 = &v12[v19];
      v21 = v18 + 1;
      while (*v20++)
      {
        if ((_DWORD)a3 == ++v21)
        {
          v21 = a3;
          break;
        }
      }
    }
    v23 = v21 + 1;
    if (v16 || a3 < v23)
    {
      v14 = "truncated";
      if (!v16 || a3 <= v23)
        return png_chunk_benign_error(a1, v14);
      v27 = -1;
      if (png_decompress_chunk(a1, a3, v21 + 1, &v27) == 1)
      {
        v12 = *(Bytef **)(a1 + 936);
      }
      else
      {
        v14 = *(const char **)(a1 + 144);
        if (v14)
          return png_chunk_benign_error(a1, v14);
      }
    }
    else
    {
      v27 = a3 - v23;
    }
    v26[0] = 0;
    v24 = v27;
    v12[v27 + v23] = 0;
    if (v16)
      v25 = 2;
    else
      v25 = 1;
    LODWORD(v26[0]) = v25;
    v26[5] = &v12[v17];
    v26[6] = &v12[v19];
    v26[1] = v12;
    v26[2] = &v12[v23];
    v26[3] = 0;
    v26[4] = v24;
    result = png_set_text_2((void (**)(void))a1, a2, (uint64_t)v26, 1);
    if ((_DWORD)result)
    {
      v14 = "insufficient memory";
      return png_chunk_benign_error(a1, v14);
    }
  }
  return result;
}

void *png_read_buffer(uint64_t a1, size_t size, int a3)
{
  void *v6;
  void *v7;

  v6 = *(void **)(a1 + 936);
  if (v6)
  {
    if (*(_QWORD *)(a1 + 944) >= size)
      return v6;
    *(_QWORD *)(a1 + 936) = 0;
    *(_QWORD *)(a1 + 944) = 0;
    png_free(a1, v6);
  }
  v7 = png_malloc_base(a1, size);
  if (v7)
  {
    v6 = v7;
    bzero(v7, size);
    *(_QWORD *)(a1 + 936) = v6;
    *(_QWORD *)(a1 + 944) = size;
  }
  else
  {
    if (a3 <= 1)
    {
      if (!a3)
        png_chunk_error((void (**)(void))a1, "insufficient memory to read chunk");
      png_chunk_warning(a1, "insufficient memory to read chunk");
    }
    return 0;
  }
  return v6;
}

double _cg_png_create_info_struct(uint64_t a1)
{
  _QWORD *v1;
  double result;

  if (a1)
  {
    v1 = png_malloc_base(a1, 0x188uLL);
    if (v1)
    {
      v1[48] = 0;
      result = 0.0;
      *((_OWORD *)v1 + 22) = 0u;
      *((_OWORD *)v1 + 23) = 0u;
      *((_OWORD *)v1 + 20) = 0u;
      *((_OWORD *)v1 + 21) = 0u;
      *((_OWORD *)v1 + 18) = 0u;
      *((_OWORD *)v1 + 19) = 0u;
      *((_OWORD *)v1 + 16) = 0u;
      *((_OWORD *)v1 + 17) = 0u;
      *((_OWORD *)v1 + 14) = 0u;
      *((_OWORD *)v1 + 15) = 0u;
      *((_OWORD *)v1 + 12) = 0u;
      *((_OWORD *)v1 + 13) = 0u;
      *((_OWORD *)v1 + 10) = 0u;
      *((_OWORD *)v1 + 11) = 0u;
      *((_OWORD *)v1 + 8) = 0u;
      *((_OWORD *)v1 + 9) = 0u;
      *((_OWORD *)v1 + 6) = 0u;
      *((_OWORD *)v1 + 7) = 0u;
      *((_OWORD *)v1 + 4) = 0u;
      *((_OWORD *)v1 + 5) = 0u;
      *((_OWORD *)v1 + 2) = 0u;
      *((_OWORD *)v1 + 3) = 0u;
      *(_OWORD *)v1 = 0u;
      *((_OWORD *)v1 + 1) = 0u;
    }
  }
  return result;
}

void *png_malloc_base(uint64_t a1, size_t size)
{
  uint64_t (*v2)(void);

  if (!size)
    return 0;
  if (a1)
  {
    v2 = *(uint64_t (**)(void))(a1 + 824);
    if (v2)
      return (void *)v2();
  }
  return malloc_type_malloc(size, 0xB622AF59uLL);
}

uint64_t png_set_text_2(void (**a1)(void), uint64_t a2, uint64_t a3, signed int a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v9;
  unsigned int v10;
  char *v11;
  char *v12;
  uint64_t v13;
  const char **v14;
  const char *v15;
  int v16;
  uint64_t v17;
  int v18;
  size_t v19;
  const char *v20;
  size_t v21;
  size_t v22;
  const char *v23;
  size_t v24;
  size_t v25;
  size_t v26;
  void *v27;
  _QWORD *v28;
  uint64_t v29;
  void *v30;
  int v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  void **v37;
  size_t v38;
  size_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  size_t __n;

  v4 = 0;
  if (!a3)
    return v4;
  v5 = (uint64_t)a1;
  if (!a1)
    return v4;
  v6 = a2;
  if (!a2 || a4 < 1)
    return v4;
  v9 = *(_DWORD *)(a2 + 148);
  if ((int)(*(_DWORD *)(a2 + 152) - v9) < a4)
  {
    if ((v9 ^ 0x7FFFFFFF) < a4
      || ((int)(v9 + a4) >= 2147483639 ? (v10 = 0x7FFFFFFF) : (v10 = ((v9 + a4) & 0xFFFFFFF8) + 8),
          (v11 = png_realloc_array(a1, *(const void **)(a2 + 160), v9, v10 - v9, 0x38uLL)) == 0))
    {
      v41 = "too many text chunks";
      v4 = 1;
      v42 = v5;
      goto LABEL_46;
    }
    v12 = v11;
    png_free(v5, *(void **)(v6 + 160));
    *(_QWORD *)(v6 + 160) = v12;
    *(_DWORD *)(v6 + 300) |= 0x4000u;
    *(_DWORD *)(v6 + 152) = v10;
  }
  v13 = a4;
  v14 = (const char **)(a3 + 48);
  v46 = v5;
  v44 = v6;
  while (1)
  {
    v15 = *(v14 - 5);
    if (v15)
      break;
LABEL_42:
    v14 += 7;
    if (!--v13)
      return 0;
  }
  v16 = *((_DWORD *)v14 - 12);
  if ((v16 - 3) <= 0xFFFFFFFB)
  {
    png_chunk_report(v5, "text compression mode is out of range", 1);
    goto LABEL_42;
  }
  v17 = *(_QWORD *)(v6 + 160);
  v18 = *(_DWORD *)(v6 + 148);
  v19 = strlen(v15);
  if (v16 < 1)
  {
    v21 = 0;
LABEL_23:
    v22 = 0;
    goto LABEL_24;
  }
  v20 = *(v14 - 1);
  if (v20)
    v21 = strlen(v20);
  else
    v21 = 0;
  if (!*v14)
    goto LABEL_23;
  v22 = strlen(*v14);
LABEL_24:
  v23 = *(v14 - 4);
  if (v23 && *v23)
  {
    v24 = v22;
    v25 = strlen(v23);
    v22 = v24;
  }
  else
  {
    v25 = 0;
    if (v16 < 1)
      v16 = -1;
    else
      v16 = 1;
  }
  v45 = v17 + 56 * v18;
  *(_DWORD *)v45 = v16;
  v26 = v22;
  __n = v25;
  v27 = png_malloc_base(v46, v19 + v21 + v22 + v25 + 4);
  *(_QWORD *)(v45 + 8) = v27;
  v28 = (_QWORD *)(v45 + 8);
  if (v27)
  {
    v29 = v17;
    memcpy(v27, *(v14 - 5), v19);
    *(_BYTE *)(*v28 + v19) = 0;
    if (*((int *)v14 - 12) < 1)
    {
      v31 = v18;
      v34 = v29 + 56 * v18;
      *(_QWORD *)(v34 + 40) = 0;
      *(_QWORD *)(v34 + 48) = 0;
      v26 = v19;
    }
    else
    {
      v30 = (void *)(*v28 + v19 + 1);
      v31 = v18;
      v32 = v29 + 56 * v18;
      *(_QWORD *)(v32 + 40) = v30;
      memcpy(v30, *(v14 - 1), v21);
      *(_BYTE *)(*(_QWORD *)(v32 + 40) + v21) = 0;
      v33 = (void *)(*(_QWORD *)(v32 + 40) + v21 + 1);
      *(_QWORD *)(v32 + 48) = v33;
      v28 = (_QWORD *)(v32 + 48);
      memcpy(v33, *v14, v26);
      *(_BYTE *)(*v28 + v26) = 0;
    }
    v6 = v44;
    v35 = (void *)(*v28 + v26 + 1);
    v36 = v29 + 56 * v31;
    *(_QWORD *)(v36 + 16) = v35;
    v37 = (void **)(v36 + 16);
    v38 = __n;
    if (__n)
    {
      memcpy(v35, *(v14 - 4), __n);
      v38 = __n;
      v35 = *v37;
    }
    v5 = v46;
    *((_BYTE *)v35 + v38) = 0;
    if (*(int *)v45 <= 0)
      v39 = v38;
    else
      v39 = 0;
    if (*(int *)v45 <= 0)
      v38 = 0;
    v40 = v29 + 56 * v31;
    *(_QWORD *)(v40 + 24) = v39;
    *(_QWORD *)(v40 + 32) = v38;
    ++*(_DWORD *)(v44 + 148);
    goto LABEL_42;
  }
  v41 = "text chunk: out of memory";
  v4 = 1;
  v42 = v46;
LABEL_46:
  png_chunk_report(v42, v41, 1);
  return v4;
}

uint64_t png_icc_set_sRGB(uint64_t result, uint64_t a2, unsigned int *a3, uLong a4)
{
  uint64_t v6;
  uint64_t v7;
  uInt v8;
  unsigned int v9;
  unsigned int v10;
  uLong v11;
  uLong v12;

  if ((~*(_DWORD *)(result + 680) & 0x30) != 0)
  {
    v6 = result;
    v7 = 0;
    v8 = 0;
    v9 = bswap32(a3[21]);
    v10 = 0x10000;
    while (1)
    {
      if (v9 == png_sRGB_checks[v7 + 3]
        && bswap32(a3[22]) == png_sRGB_checks[v7 + 4]
        && bswap32(a3[23]) == png_sRGB_checks[v7 + 5]
        && bswap32(a3[24]) == png_sRGB_checks[v7 + 6])
      {
        if (!v8)
        {
          v8 = bswap32(*a3);
          v10 = bswap32(a3[16]);
        }
        if (v8 == png_sRGB_checks[v7 + 2] && v10 == HIWORD(png_sRGB_checks[v7 + 7]))
          break;
      }
      v7 += 8;
      if (v7 == 40)
        return result;
    }
    if (!a4)
    {
      v11 = adler32(0, 0, 0);
      a4 = adler32(v11, (const Bytef *)a3, v8);
    }
    if (a4 == png_sRGB_checks[v7]
      && (v12 = crc32(0, 0, 0), crc32(v12, (const Bytef *)a3, v8) == png_sRGB_checks[v7 + 1]))
    {
      return png_colorspace_set_sRGB(v6, a2, bswap32(a3[16]));
    }
    else
    {
      return png_chunk_report(v6, "Not recognizing known sRGB profile that has been edited", 0);
    }
  }
  return result;
}

uint64_t png_icc_check_tag_table(uint64_t a1, uint64_t a2, _BYTE *a3, unsigned int a4, uint64_t a5)
{
  unsigned int v5;
  uint64_t i;
  unint64_t v11;
  unsigned int v12;
  BOOL v13;
  unsigned int v14;

  v5 = bswap32(*(_DWORD *)(a5 + 128));
  if (!v5)
    return 1;
  for (i = a5 + 132; ; i += 12)
  {
    v11 = bswap32(*(_DWORD *)i);
    v12 = _byteswap_ulong(*(_DWORD *)(i + 4));
    v13 = a4 >= v12;
    v14 = a4 - v12;
    if (!v13 || bswap32(*(_DWORD *)(i + 8)) > v14)
      break;
    if ((*(_BYTE *)(i + 7) & 3) != 0)
      png_icc_profile_error(a1, 0, a3, v11, "ICC profile tag start not a multiple of 4");
    if (!--v5)
      return 1;
  }
  png_icc_profile_error(a1, a2, a3, v11, "ICC profile tag outside profile");
  return 0;
}

uint64_t png_icc_check_header(uint64_t a1, uint64_t a2, _BYTE *a3, unint64_t a4, uint64_t a5, char a6)
{
  _BYTE *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  char *v12;
  uint64_t result;
  unint64_t v16;
  int v17;
  char *v18;
  uint64_t v19;
  _BYTE *v20;

  v6 = a3;
  v7 = a2;
  v8 = a1;
  v9 = bswap32(*(_DWORD *)a5);
  if ((_DWORD)v9 != (_DWORD)a4)
  {
    v12 = "length does not match profile";
LABEL_13:
    a4 = v9;
    goto LABEL_14;
  }
  if ((a4 & 3) != 0 && *(unsigned __int8 *)(a5 + 8) >= 4u)
  {
    a4 = a4;
    v12 = "invalid length";
LABEL_5:
    a1 = v8;
    a2 = v7;
    a3 = v6;
LABEL_14:
    png_icc_profile_error(a1, a2, a3, a4, v12);
    return 0;
  }
  v9 = bswap32(*(_DWORD *)(a5 + 128));
  if (v9 > 0x1555554A || 12 * (int)v9 + 132 > a4)
  {
    v12 = "tag count too large";
    goto LABEL_13;
  }
  a4 = bswap32(*(_DWORD *)(a5 + 64));
  if (a4 >= 0xFFFF)
  {
    v12 = "invalid rendering intent";
    goto LABEL_5;
  }
  if (a4 >= 4)
    png_icc_profile_error(a1, 0, a3, a4, "intent outside defined range");
  a4 = bswap32(*(_DWORD *)(a5 + 36));
  if ((_DWORD)a4 != 1633907568)
  {
    v12 = "invalid signature";
    goto LABEL_5;
  }
  if (*(_QWORD *)(a5 + 68) != 0x100D6F60000 || *(_DWORD *)(a5 + 76) != 768802816)
    png_icc_profile_error(v8, 0, v6, 0, "PCS illuminant is not D50");
  a4 = bswap32(*(_DWORD *)(a5 + 16));
  if ((_DWORD)a4 == 1196573017)
  {
    if ((a6 & 2) != 0)
    {
      v12 = "Gray color space not permitted on RGB PNG";
      a1 = v8;
      a2 = v7;
      a3 = v6;
      a4 = 1196573017;
      goto LABEL_14;
    }
  }
  else
  {
    if ((_DWORD)a4 != 1380401696)
    {
      v12 = "invalid ICC profile color space";
      goto LABEL_5;
    }
    if ((a6 & 2) == 0)
    {
      v12 = "RGB color space not permitted on grayscale PNG";
      a1 = v8;
      a2 = v7;
      a3 = v6;
      a4 = 1380401696;
      goto LABEL_14;
    }
  }
  v16 = bswap32(*(_DWORD *)(a5 + 12));
  if ((int)v16 <= 1852662635)
  {
    if ((_DWORD)v16 == 1633842036)
    {
      v12 = "invalid embedded Abstract ICC profile";
      a1 = v8;
      a2 = v7;
      a3 = v6;
      a4 = 1633842036;
      goto LABEL_14;
    }
    if ((_DWORD)v16 == 1818848875)
    {
      v12 = "unexpected DeviceLink ICC profile class";
      a1 = v8;
      a2 = v7;
      a3 = v6;
      a4 = 1818848875;
      goto LABEL_14;
    }
    v17 = 1835955314;
  }
  else if ((int)v16 > 1935896177)
  {
    if ((_DWORD)v16 == 1935896178)
      goto LABEL_47;
    v17 = 1936744803;
  }
  else
  {
    if ((_DWORD)v16 == 1852662636)
    {
      v18 = "unexpected NamedColor ICC profile class";
      v19 = v8;
      v20 = v6;
      v16 = 1852662636;
      goto LABEL_46;
    }
    v17 = 1886549106;
  }
  if ((_DWORD)v16 != v17)
  {
    v18 = "unrecognized ICC profile class";
    v19 = v8;
    v20 = v6;
LABEL_46:
    png_icc_profile_error(v19, 0, v20, v16, v18);
  }
LABEL_47:
  a4 = bswap32(*(_DWORD *)(a5 + 20));
  result = 1;
  if ((_DWORD)a4 != 1281450528 && (_DWORD)a4 != 1482250784)
  {
    v12 = "unexpected ICC PCS encoding";
    goto LABEL_5;
  }
  return result;
}

uint64_t png_icc_check_length(uint64_t a1, uint64_t a2, _BYTE *a3, unint64_t a4)
{
  char *v4;
  unint64_t v5;

  if (a4 <= 0x83)
  {
    a4 = a4;
    v4 = "too short";
LABEL_6:
    png_icc_profile_error(a1, a2, a3, a4, v4);
    return 0;
  }
  v5 = *(_QWORD *)(a1 + 888);
  if (v5 && v5 < a4)
  {
    a4 = a4;
    v4 = "exceeds application limits";
    goto LABEL_6;
  }
  return 1;
}

uint64_t AppleJPEGReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, _QWORD *a4, uint64_t a5, uint64_t *a6)
{
  int v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  AppleJPEGReadPlugin *v23;
  __IOSurface *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v37;
  uint64_t v38;

  if ((gIIODebugFlags & 0x20000) != 0)
  {
    v11 = *((_DWORD *)this + 51);
    v12 = v11 >> 24;
    v13 = MEMORY[0x1E0C80978];
    if (v11 < 0)
    {
      v14 = __maskrune(v12, 0x40000uLL);
      v11 = *((_DWORD *)this + 51);
    }
    else
    {
      v14 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v12 + 60) & 0x40000;
    }
    if (v14)
      v15 = (v11 >> 24);
    else
      v15 = 46;
    v16 = v11 << 8 >> 24;
    if (v11 << 8 < 0)
    {
      v17 = __maskrune(v16, 0x40000uLL);
      v11 = *((_DWORD *)this + 51);
    }
    else
    {
      v17 = *(_DWORD *)(v13 + 4 * v16 + 60) & 0x40000;
    }
    if (v17)
      v18 = (v11 << 8 >> 24);
    else
      v18 = 46;
    v19 = (__int16)v11 >> 8;
    if (v11 << 16 < 0)
    {
      v20 = __maskrune(v19, 0x40000uLL);
      v11 = *((_DWORD *)this + 51);
    }
    else
    {
      v20 = *(_DWORD *)(v13 + 4 * v19 + 60) & 0x40000;
    }
    if (v20)
      v21 = ((__int16)v11 >> 8);
    else
      v21 = 46;
    if ((v11 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v13 + 4 * (char)v11 + 60) & 0x40000) != 0)
        goto LABEL_22;
    }
    else if (__maskrune((char)v11, 0x40000uLL))
    {
LABEL_22:
      v22 = *((char *)this + 204);
LABEL_25:
      ImageIOLog("♦️  '%c%c%c%c' [%s] %s\n", v15, v18, v21, v22, iioTypeStr[a3], "virtual OSStatus AppleJPEGReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      goto LABEL_26;
    }
    v22 = 46;
    goto LABEL_25;
  }
LABEL_26:
  v23 = (AppleJPEGReadPlugin *)IIOReadPlugin::debugDecodeImage(this, a2);
  if (a3 == 3)
  {
    v26 = *((_QWORD *)a2 + 1);
    v27 = *((_QWORD *)a2 + 2);
    v28 = *((double *)a2 + 3);
    v29 = *((double *)a2 + 4);
    v30 = *((double *)a2 + 5);
    v31 = *((double *)a2 + 6);
    v32 = *((double *)a2 + 7);
    v33 = *((double *)a2 + 8);
    v34 = IIOImageSource::reader(a2);
    v35 = (*(uint64_t (**)(IIOReadPlugin *, uint64_t, uint64_t, uint64_t, double, double, double, double, double, double))(*(_QWORD *)this + 200))(this, v26, v27, v34, v28, v29, v30, v31, v32, v33);
    v25 = 4294967246;
    if (a6)
    {
      *a6 = v35;
      if (v35)
        return 0;
      else
        return 4294967246;
    }
    return v25;
  }
  if (a3 != 1)
  {
    _cg_jpeg_mem_term("decodeImageImp", 2831, "*** ERROR: imageType '%d' not handled\n", a3);
    return 4294967246;
  }
  if (!a4)
    return 4294967246;
  if (*a4)
  {
    AppleJPEGReadPlugin::decodeIntoIOSurface(v23, a2, v24);
    v25 = 4294967246;
    _cg_jpeg_mem_term("decodeImageImp", 2812, "*** decodeIntoIOSurface - err = %d\n", -50);
    return v25;
  }
  v37 = *((_QWORD *)a2 + 2);
  v38 = IIOImageSource::reader(a2);
  return (*(uint64_t (**)(IIOReadPlugin *, uint64_t, uint64_t, _QWORD *, _QWORD))(*(_QWORD *)this + 216))(this, v37, v38, a4, 0);
}

uint64_t PNGReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4, uint64_t a5, uint64_t *a6)
{
  int v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  const void *v24;
  const void *v25;
  double v26;
  double v27;
  double v28;
  double v29;
  uint64_t v30;
  uint64_t v31;
  const void *v32;
  const void *v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  void *BaseAddress;
  size_t Height;
  size_t BytesPerRow;
  uint64_t v43;
  double v44;
  double v45;
  uint64_t v46;
  const void *Data;

  if ((gIIODebugFlags & 0x20000) != 0)
  {
    v11 = *((_DWORD *)this + 51);
    v12 = v11 >> 24;
    v13 = MEMORY[0x1E0C80978];
    if (v11 < 0)
    {
      v14 = __maskrune(v12, 0x40000uLL);
      v11 = *((_DWORD *)this + 51);
    }
    else
    {
      v14 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v12 + 60) & 0x40000;
    }
    if (v14)
      v15 = (v11 >> 24);
    else
      v15 = 46;
    v16 = v11 << 8 >> 24;
    if (v11 << 8 < 0)
    {
      v17 = __maskrune(v16, 0x40000uLL);
      v11 = *((_DWORD *)this + 51);
    }
    else
    {
      v17 = *(_DWORD *)(v13 + 4 * v16 + 60) & 0x40000;
    }
    if (v17)
      v18 = (v11 << 8 >> 24);
    else
      v18 = 46;
    v19 = (__int16)v11 >> 8;
    if (v11 << 16 < 0)
    {
      v20 = __maskrune(v19, 0x40000uLL);
      v11 = *((_DWORD *)this + 51);
    }
    else
    {
      v20 = *(_DWORD *)(v13 + 4 * v19 + 60) & 0x40000;
    }
    if (v20)
      v21 = ((__int16)v11 >> 8);
    else
      v21 = 46;
    if ((v11 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v13 + 4 * (char)v11 + 60) & 0x40000) != 0)
        goto LABEL_22;
    }
    else if (__maskrune((char)v11, 0x40000uLL))
    {
LABEL_22:
      v22 = *((char *)this + 204);
LABEL_25:
      ImageIOLog("♦️  '%c%c%c%c' [%s] %s\n", v15, v18, v21, v22, iioTypeStr[a3], "virtual OSStatus PNGReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      goto LABEL_26;
    }
    v22 = 46;
    goto LABEL_25;
  }
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  *((_DWORD *)this + 52) = *((_QWORD *)a2 + 9);
  *((_DWORD *)this + 26) = 1;
  v23 = *((unsigned __int8 *)this + 440);
  if (v23 == 3)
  {
    v32 = (const void *)*((_QWORD *)a2 + 1);
    v33 = (const void *)*((_QWORD *)a2 + 2);
    v34 = *((double *)a2 + 3);
    v35 = *((double *)a2 + 4);
    v36 = *((double *)a2 + 5);
    v37 = *((double *)a2 + 6);
    v38 = *((double *)a2 + 7);
    v39 = *((double *)a2 + 8);
    IIOImageSource::reader(a2);
    v30 = (uint64_t)PNGReadPlugin::copyImageBlockSetAPNG((uint64_t)this, v32, v33, v34, v35, v36, v37, v38, v39);
    goto LABEL_33;
  }
  if (v23 == 2)
  {
    IIOImageSource::reader(a2);
    PNGReadPlugin::copyImageBlockSetInterlaced((uint64_t)this);
    goto LABEL_31;
  }
  if (v23 != 1)
  {
LABEL_31:
    v31 = 0;
    goto LABEL_34;
  }
  v24 = (const void *)*((_QWORD *)a2 + 1);
  v25 = (const void *)*((_QWORD *)a2 + 2);
  v26 = *((double *)a2 + 3);
  v27 = *((double *)a2 + 4);
  v28 = *((double *)a2 + 5);
  v29 = *((double *)a2 + 6);
  IIOImageSource::reader(a2);
  v30 = PNGReadPlugin::copyImageBlockSetStandard((uint64_t)this, v24, v25, v26, v27, v28, v29);
LABEL_33:
  v31 = v30;
LABEL_34:
  if (a3 == 1)
  {
    if (v31 && CGImageBlockSetGetCount() == 1 || *((_DWORD *)this + 26) == 1)
    {
      if (!a4 || !*a4)
      {
        v43 = 0;
        goto LABEL_58;
      }
      if (IOSurfaceLock(*a4, 0, 0))
      {
        v43 = 4294967246;
      }
      else
      {
        BaseAddress = IOSurfaceGetBaseAddress(*a4);
        IOSurfaceGetWidth(*a4);
        Height = IOSurfaceGetHeight(*a4);
        BytesPerRow = IOSurfaceGetBytesPerRow(*a4);
        if (v31)
          CGImageBlockSetGetImageBlock();
        CGImageBlockGetRect();
        v45 = v44;
        v46 = CGImageBlockGetBytesPerRow();
        Data = (const void *)CGImageBlockGetData();
        if (BytesPerRow == v46 && Height == (unint64_t)v45)
          memcpy(BaseAddress, Data, BytesPerRow * Height);
        else
          _cg_jpeg_mem_term("decodeImageImp", 3529, "*** ERROR: cannot copy into IOSurface\n");
        v43 = 0;
      }
    }
    else
    {
      v43 = 4294967246;
      if (!a4)
        goto LABEL_58;
    }
    goto LABEL_56;
  }
  v43 = 4294967246;
  if (a3 == 3 && a6)
  {
    v43 = 0;
    *a6 = v31;
    v31 = 0;
  }
  if (a4)
  {
LABEL_56:
    if (*a4)
      IOSurfaceUnlock(*a4, 0, 0);
  }
LABEL_58:
  if (v31)
    CGImageBlockSetRelease();
  return v43;
}

void sub_187E82948(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187E82778);
}

const char *IIOReadPlugin::debugCopyBlockSet(const char *result, const void *a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  const char *v15;
  uint64_t PixelSize;
  double v17;
  double v18;
  double v19;
  double v20;
  int v21;
  unsigned int v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  unsigned int v26;
  int v27;
  uint64_t v28;
  unsigned int v29;
  int v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  const char *v34;
  int v35;
  const char *v36;
  int v37;
  const char *v38;
  int v39;
  const char *v40;
  int v41;
  const char *v42;

  if (result[177])
  {
    v15 = result;
    PixelSize = CGImageProviderGetPixelSize();
    CGImageProviderGetSize();
    v18 = v17;
    v20 = v19;
    v21 = *((_DWORD *)v15 + 51);
    ImageIOLog("===================================================================================================\n");
    v22 = v21 >> 24;
    v23 = MEMORY[0x1E0C80978];
    if (v21 < 0)
      v24 = __maskrune(v21 >> 24, 0x40000uLL);
    else
      v24 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v22 + 60) & 0x40000;
    if (v24)
      v25 = v22;
    else
      v25 = 46;
    v26 = v21 << 8 >> 24;
    if (v21 << 8 < 0)
      v27 = __maskrune(v21 << 8 >> 24, 0x40000uLL);
    else
      v27 = *(_DWORD *)(v23 + 4 * v26 + 60) & 0x40000;
    if (v27)
      v28 = v26;
    else
      v28 = 46;
    v29 = (__int16)v21 >> 8;
    if (v21 << 16 < 0)
      v30 = __maskrune((__int16)v21 >> 8, 0x40000uLL);
    else
      v30 = *(_DWORD *)(v23 + 4 * v29 + 60) & 0x40000;
    if (v30)
      v31 = v29;
    else
      v31 = 46;
    if ((v21 << 24) <= 0x7F000000)
      v32 = *(_DWORD *)(v23 + 4 * (char)v21 + 60) & 0x40000;
    else
      v32 = __maskrune((char)v21, 0x40000uLL);
    if (v32)
      v33 = (char)v21;
    else
      v33 = 46;
    ImageIOLog(">>> CGImageBlockSet - %c%c%c%c\n", v25, v28, v31, v33);
    ImageIOLog("                         plugin: %p\n", v15);
    ImageIOLog("                          index: %d\n", *((_DWORD *)v15 + 52));
    ImageIOLog("                     sourceRect: {%g, %g, %g, %g}\n", a3, a4, a5, a6);
    ImageIOLog("               destionationSize: {%g, %g}\n", a7, a8);
    ImageIOLog("                      imageSize: {%d, %d}\n", (int)v18, (int)v20);
    ImageIOLog("                       provider: %p\n", a2);
    ImageIOLog("                      pixelSize: %zu\n", PixelSize);
    ImageIOLog("                        session: %p\n", *((const void **)v15 + 3));
    ImageIOLog("                subsampleFactor: %d\n", *((unsigned __int16 *)v15 + 158));
    if (*((_DWORD *)v15 + 73) > *((_DWORD *)v15 + 65))
    {
      if (*((unsigned __int16 *)v15 + 158) <= 1u)
        v34 = "";
      else
        v34 = "SUBSAMPLING ISSUE";
      _cg_jpeg_mem_term("debugCopyBlockSet", 1491, "*** _rpd._blockGeo seem to be wrong %s\n", v34);
    }
    if (*((unsigned __int8 *)v15 + 409) != 255)
      ImageIOLog("               addressAlignment: %d\n", *((_QWORD *)v15 + 48));
    if (*((_QWORD *)v15 + 49) != -1)
      ImageIOLog("              rowBytesAlignment: %d\n", *((_QWORD *)v15 + 49));
    if (*((unsigned __int8 *)v15 + 408) != 255)
      ImageIOLog("                      singleton: YES\n");
    v35 = *((unsigned __int8 *)v15 + 404);
    if (v35 != 255)
    {
      if (v35 == 1)
        v36 = "YES";
      else
        v36 = "NO";
      ImageIOLog("                   format_BGRx8: %s\n", v36);
    }
    v37 = *((unsigned __int8 *)v15 + 406);
    if (v37 != 255)
    {
      if (v37 == 1)
        v38 = "YES";
      else
        v38 = "NO";
      ImageIOLog("              premultiplication: %s\n", v38);
    }
    v39 = *((unsigned __int8 *)v15 + 411);
    if (v39 != 255)
    {
      if (v39 == 1)
        v40 = "YES";
      else
        v40 = "NO";
      ImageIOLog("      cacheImmediatelyRequested: %s\n", v40);
    }
    v41 = *((unsigned __int8 *)v15 + 407);
    if (v41 != 255)
    {
      if (v41 == 1)
        v42 = "YES";
      else
        v42 = "NO";
      ImageIOLog("                 readOnlyBlocks: %s\n", v42);
    }
    return ImageIOLog("\n");
  }
  return result;
}

const char *IIOReadPlugin::debugDecodeImage(IIOReadPlugin *this, IIODecodeParameter *a2)
{
  const __CFDictionary *v5;

  if ((gIIODebugFlags & 0x20000) == 0)
    return IIOReadPlugin::debugCopyBlockSet((const char *)this, *((const void **)a2 + 2), *((double *)a2 + 3), *((double *)a2 + 4), *((double *)a2 + 5), *((double *)a2 + 6), *((double *)a2 + 7), *((double *)a2 + 8));
  ImageIOLog("    debugDecodeImage\n");
  IIOImageSource::reader(a2);
  IIOReadPlugin::printRequests(this, v5);
  return IIOReadPlugin::debugGeometry((uint64_t)this, 0, 0);
}

uint64_t IIOImageSource::reader(IIOImageSource *this)
{
  return *((_QWORD *)this + 10);
}

uint64_t PNGReadPlugin::copyImageBlockSetStandard(uint64_t a1, const void *a2, const void *a3, double a4, double a5, double a6, double a7)
{
  double v7;
  const void *v12;
  unsigned int v14;
  uint64_t v15;
  uint64_t Property;
  BOOL v18;
  const void *v19;
  size_t v20;
  uint64_t v21;
  double v22;
  double v23;
  double v24;
  int CachedBlocks;
  unint64_t v26;
  int v27;
  IIOImageRead **v28;
  IIOImageReadSession *v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _BOOL4 v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  CGRect *v37;
  uint64_t v38;
  double v39;
  double v40;
  double v41;
  size_t v42;
  int64_t v43;
  unsigned __int8 *v44;
  uint64_t v45;
  uint64_t v46;
  IIOImageRead *v47;
  unint64_t v48;
  double v49;
  BOOL v50;
  uint64_t v51;
  double v52;
  double v53;
  double v54;
  double v55;
  double v56;
  double v57;
  unint64_t v58;
  double v59;
  const char **v60;
  uint64_t v62;
  uint64_t v63;
  _BOOL4 v64;
  __int128 v66;
  uint64_t v67;
  _QWORD v68[8];
  __int128 v69;
  uint64_t v70;
  size_t v71;
  void **v72[2];
  CGRect v73;
  CGRect v74;
  CGRect v75;
  CGRect v76;

  v12 = a3;
  v71 = 0;
  v14 = *(unsigned __int16 *)(a1 + 316);
  if (*(_BYTE *)(a1 + 406) == 1)
  {
    v15 = *MEMORY[0x1E0C9AE50];
    Property = CGImageProviderGetProperty();
    v12 = a3;
    if (v15 == Property)
      return 0;
  }
  if (!*(_BYTE *)(a1 + 414))
    return 0;
  v33 = !*(_BYTE *)(a1 + 498)
     && (v14 <= 1 ? (v18 = *(_QWORD *)(a1 + 488) == 0) : (v18 = 1), !v18)
     && *(_BYTE *)(a1 + 341) != 0;
  v19 = v12;
  CGImageProviderSetProperty();
  if (*(_BYTE *)(a1 + 177))
  {
    ImageIOLog(">>> copyImageBlockSetPNG   info: %p\n", a2);
    ImageIOLog("                       provider: %p\n", v19);
    ImageIOLog("                        session: %p\n", *(const void **)(a1 + 24));
    ImageIOLog("                     sourceRect: (%5g, %5g, %5g, %5g)\n", a4, a5, a6, a7);
  }
  v63 = (uint64_t)v19;
  v20 = *(unsigned int *)(a1 + 104);
  if (!(_DWORD)v20 || v33 && ((_DWORD)v20 != 1 || *(_DWORD *)(a1 + 296) != *(_DWORD *)(a1 + 232)))
    return 0;
  v21 = *(unsigned int *)(a1 + 112);
  if (*(_BYTE *)(a1 + 177))
  {
    ImageIOLog("                  imageRowBytes: %6d\n", *(_DWORD *)(a1 + 300));
    ImageIOLog("               bitsPerComponent: %6d\n", *(unsigned __int16 *)(a1 + 240));
    ImageIOLog("                 isLittleEndian: %6d\n", *(unsigned __int8 *)(a1 + 344));
    ImageIOLog("                    blockHeight: %6d\n", *(_DWORD *)(a1 + 296));
    ImageIOLog("                     blockCount: %6d\n", *(_DWORD *)(a1 + 104));
    ImageIOLog("                     startBlock: %6d\n", *(_DWORD *)(a1 + 112));
    ImageIOLog("                       endBlock: %6d\n", *(_DWORD *)(a1 + 116));
    v20 = *(unsigned int *)(a1 + 104);
  }
  IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, v20);
  CachedBlocks = IIOReadPlugin::getCachedBlocks((IIOReadPlugin *)a1, v22, v23, v24);
  v27 = CachedBlocks;
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("     numberOfBlocksLeftToDecode: %d\n", CachedBlocks);
  if (!v27)
  {
    LOBYTE(v64) = 0;
    goto LABEL_47;
  }
  v28 = *(IIOImageRead ***)(a1 + 24);
  if (v28)
  {
    v64 = IIOImageReadSession::mapData(v28);
    v29 = *(IIOImageReadSession **)(a1 + 24);
    if (v29)
    {
      v30 = *(_QWORD *)(a1 + 192);
      v31 = v21;
      if (v30)
        IIOImageReadSession::seek(v29, v30, 0);
      else
        IIOImageReadSession::rewind((uint64_t)v29);
    }
    else
    {
      v31 = v21;
    }
  }
  else
  {
    v31 = v21;
    v64 = 0;
  }
  v34 = *(unsigned int *)(a1 + 112);
  if (v34 >= *(_DWORD *)(a1 + 116))
  {
LABEL_47:
    v55 = *(double *)(a1 + 120);
    v56 = *(double *)(a1 + 128);
    v57 = *(double *)(a1 + 144);
    if (v57 == 0.0)
    {
      _cg_jpeg_mem_term("copyImageBlockSetStandard", 3182, ": pngCreateBlockSet - error while decoding PNG image rect: (%5g, %5g, %5g, %5g)\n", v55, v56, *(double *)(a1 + 136), v57);
    }
    else if (v63)
    {
      v58 = *(unsigned int *)(a1 + 104);
      if ((_DWORD)v58)
      {
        v32 = IIOReadPlugin::imageBlockSetCreate(a1, v63, v58, *(double *)(a1 + 136), v57, v55, v56, *(double *)(a1 + 136), *(double *)(a1 + 144), *(_QWORD *)(a1 + 96), a2);
        goto LABEL_66;
      }
    }
LABEL_65:
    v32 = 0;
LABEL_66:
    if (v64)
    {
LABEL_67:
      v60 = *(const char ***)(a1 + 24);
      if (v60)
        IIOImageReadSession::unmapData(v60);
    }
    return v32;
  }
  v62 = v31;
  v35 = -8 * v31;
  v36 = -v31;
  v37 = (CGRect *)MEMORY[0x1E0C9D628];
  while (1)
  {
    if (*(_QWORD *)(*(_QWORD *)(a1 + 96) + v35 + 8 * v34))
      _cg_jpeg_mem_term("copyImageBlockSetStandard", 3103, "*** _blockArray[%d] was cached - and already allocated\n", v36 + v34);
    v38 = *(unsigned int *)(a1 + 296);
    v39 = (double)(unint64_t)(v34 * v38);
    LODWORD(v7) = *(_DWORD *)(a1 + 292);
    LODWORD(v26) = *(_DWORD *)(a1 + 232);
    v40 = (double)v26;
    v41 = (double)v38 + v39 <= v40 ? (double)v38 : v40 - v39;
    v42 = *(unsigned int *)(a1 + 300) * (unint64_t)v38;
    v43 = _ImageIO_Malloc(v42, *(_QWORD *)(a1 + 384), &v71, (uint64_t)kImageMalloc_PNG_Data[0], *(_DWORD *)(a1 + 432), 0, 0);
    if (!v43)
      break;
    v44 = (unsigned __int8 *)v43;
    v45 = *(_QWORD *)(a1 + 384);
    if (v45 && v43 % v45)
      goto LABEL_64;
    bzero((void *)v43, v42);
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("                   reading rows: %d ... %d\n", (unint64_t)v39, (unint64_t)(v41 + v39));
    v7 = (double)*(unint64_t *)&v7;
    v46 = *(unsigned int *)(a1 + 300);
    v68[0] = v34;
    v68[1] = 0;
    *(double *)&v68[2] = v39;
    *(double *)&v68[3] = v7;
    *(double *)&v68[4] = v41;
    v68[5] = v44;
    v68[6] = v46;
    v68[7] = v42;
    v69 = 0u;
    v70 = 0;
    v67 = 0;
    v66 = 0u;
    std::vector<IIODecodeFrameParams>::vector(&v66, 1uLL, (uint64_t)v68);
    v47 = (IIOImageRead *)IIO_Reader::testHeaderSize(*(IIO_Reader **)(a1 + 24));
    PNGReadPlugin::DecodeUncomposedFrames(v47, 0, a1 + 184, (_BYTE *)(a1 + 440), (uint64_t **)&v66);
    v48 = *(_QWORD *)(v66 + 64);
    v49 = (double)v48;
    if (v41 != (double)v48)
    {
      _cg_jpeg_mem_term("copyImageBlockSetStandard", 3149, "*** ERROR: incomplete decode - got %d of %g rows\n", v48, v41);
      v72[0] = (void **)&v66;
      std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100](v72);
      IIODecodeFrameParams::~IIODecodeFrameParams((IIODecodeFrameParams *)v68);
      breakOnPngError();
      if (*(_BYTE *)(a1 + 177))
      {
        ImageIOLog("    got a PNG error  (success = %d)  sourceRect: (%5g, %5g, %5g, %5g)\n", 0, a4, a5, a6, a7);
        ImageIOLog("                    imageData = %p [%zu]\n", v44, (*(_DWORD *)(a1 + 300) * *(_DWORD *)(a1 + 296)));
        ImageIOLog("                    blockLoop = %ld\n", v34);
        ImageIOLog("                  _blockEnd-1 = %ld\n", *(unsigned int *)(a1 + 116) - 1);
        ImageIOLog("                          row = %ld\n", 0);
        ImageIOLog("                       endRow = %ld\n", (unint64_t)(v41 + v39));
        ImageIOLog("                    rowsValid = %ld\n", 0);
        ImageIOLog("               blockRowsValid = %ld\n", v48);
        ImageIOLog("                    blockRect = {%5g, %5g, %5g, %5g}\n", 0.0, v39, v7, v41);
      }
      if (v48 && v41 > v49)
      {
        if ((IIOImageReadSession::isFinal(*(IIOImageReadSession **)(a1 + 24)) & (v41 - v49 > 2.0)) != 0)
          v59 = (double)v48;
        else
          v59 = v41;
        if (v59 != 0.0)
        {
          PNGReadPlugin::postProcess((PNGReadPlugin *)a1, v44);
          v74.origin.x = 0.0;
          v74.origin.y = v39;
          v74.size.width = v7;
          v74.size.height = v59;
          *(_QWORD *)(*(_QWORD *)(a1 + 96) - 8 * v62 + 8 * v34) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, v44, v71, v74, *(unsigned int *)(a1 + 300), 0);
          v75.origin.x = 0.0;
          v75.origin.y = v39;
          v75.size.width = v7;
          v75.size.height = v59;
          AddSubRect((CGRect *)(a1 + 120), v75);
          goto LABEL_47;
        }
        _cg_jpeg_mem_term("copyImageBlockSetStandard", 3239, ": error while decoding PNG image rect: (%5g, %5g, %5g, %5g)\n", 0.0, v39, v7, v59);
      }
LABEL_64:
      _ImageIO_Free((unint64_t)v44, v71);
      goto LABEL_65;
    }
    PNGReadPlugin::postProcess((PNGReadPlugin *)a1, v44);
    v73.origin.x = 0.0;
    v73.origin.y = v39;
    v73.size.width = v7;
    v73.size.height = v41;
    *(_QWORD *)(*(_QWORD *)(a1 + 96) + v35 + 8 * v34) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, v44, v71, v73, *(unsigned int *)(a1 + 300), *(unsigned __int8 *)(a1 + 343));
    v50 = CGRectEqualToRect(*(CGRect *)(a1 + 120), *v37);
    v51 = 0;
    if (!v50)
    {
      v76.origin.x = 0.0;
      v76.origin.y = v39;
      v76.size.width = v7;
      v76.size.height = v41;
      *(CGRect *)&v51 = CGRectUnion(*(CGRect *)(a1 + 120), v76);
      v39 = v52;
      v7 = v53;
      v41 = v54;
    }
    *(_QWORD *)(a1 + 120) = v51;
    *(double *)(a1 + 128) = v39;
    *(double *)(a1 + 136) = v7;
    *(double *)(a1 + 144) = v41;
    v72[0] = (void **)&v66;
    std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100](v72);
    IIODecodeFrameParams::~IIODecodeFrameParams((IIODecodeFrameParams *)v68);
    if (++v34 >= (unint64_t)*(unsigned int *)(a1 + 116))
      goto LABEL_47;
  }
  v32 = 0;
  if (v64)
    goto LABEL_67;
  return v32;
}

void sub_187E83534(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  uint64_t v12;
  uint64_t v14;
  va_list va;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a12);
  va_start(va, a12);
  v14 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  *(_QWORD *)(v12 - 160) = va;
  std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100]((void ***)(v12 - 160));
  IIODecodeFrameParams::~IIODecodeFrameParams((IIODecodeFrameParams *)va1);
  _Unwind_Resume(a1);
}

uint64_t IIOReadPlugin::imageBlockSetCreate(uint64_t a1, uint64_t a2, unint64_t a3, double a4, double a5, double a6, double a7, double a8, double a9, uint64_t a10, const void *a11)
{
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;

  if (a9 != a5)
    _cg_jpeg_mem_term("imageBlockSetCreate", 1999, "*** buffer height mismatch: rect:{%g,%g,%g,%g}  size:{%g,%g}\n", a6, a7, a8, a9, a4, a5);
  if (a8 != a4)
    _cg_jpeg_mem_term("imageBlockSetCreate", 2001, "*** buffer width mismatch: rect:{%g,%g,%g,%g}  size:{%g,%g}\n", a6, a7, a8, a9, a4, a5);
  v21 = CGImageBlockSetCreate();
  if (!(a2 | v21))
    LogError("imageBlockSetCreate", 2006, "*** ERROR: CGImageBlockSetCreate returned NULL - called with NULL provider\n");
  v22 = gIIODebugFlags;
  if ((gIIODebugFlags & 0xC00) != 0 || *(_BYTE *)(a1 + 177))
  {
    do
      v23 = __ldxr((unsigned int *)&gBlockSetCount);
    while (__stxr(v23 + 1, (unsigned int *)&gBlockSetCount));
    v24 = 115;
    if (a3 == 1)
      v24 = 32;
    ImageIOLog("    CGImageBlockSetCreate:    %14p - info: %14p                        S-[%2ld] %2ld block%c\n", (const void *)v21, a11, gBlockSetCount, a3, v24);
    v22 = gIIODebugFlags;
    if ((gIIODebugFlags & 0x800) != 0)
    {
      IIODebug_ShowBacktrace(2);
      v22 = gIIODebugFlags;
    }
  }
  if ((v22 & 0x40000000000) != 0)
    IIOReadPlugin::debugBlockSetAlpha(a1, a2, a3);
  if (!v21)
    _cg_jpeg_mem_term("imageBlockSetCreate", 2023, "*** CGImageBlockSetCreate returned nil rect:{%g,%g,%g,%g}  size:{%g,%g}\n", a6, a7, a8, a9, a4, a5);
  return v21;
}

uint64_t IIOReadPlugin::getCachedBlocks(IIOReadPlugin *this, double a2, double a3, double a4)
{
  uint64_t v4;
  unint64_t v5;
  unsigned int v7;
  unint64_t v8;
  unint64_t v9;
  CGRect *v10;
  uint64_t *v11;
  unsigned int v12;
  unsigned int v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  uint64_t v19;
  double v20;
  double v21;
  uint64_t *v22;
  int v23;
  _BOOL4 CachedImageBlockData;
  unint64_t v25;
  unint64_t v26;
  double v27;
  unsigned int v28;
  double v29;
  double v30;
  void *v31;
  const void *v32;
  vImagePixelCount v33;
  size_t v34;
  int PluginType;
  int v36;
  unsigned int v37;
  uint64_t v38;
  int v39;
  uint64_t v41;
  unsigned int v42;
  int v43;
  uint64_t v44;
  unsigned int v45;
  int v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  int v50;
  int v51;
  int v52;
  int v53;
  unsigned int v54;
  int v55;
  uint64_t v56;
  unsigned int v57;
  int v58;
  uint64_t v59;
  unsigned int v60;
  int v61;
  uint64_t v62;
  int v63;
  int v64;
  int v65;
  double v66;
  double v67;
  double v68;
  double v69;
  _QWORD *v70;
  uint64_t v71;
  unsigned int v73;
  uint64_t v74;
  int v75;
  int v76;
  uint64_t v77;
  int v78;
  uint64_t v79;
  int v80;
  int v81;
  int v82;
  int v83;
  int v84;
  void *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  char *v90;
  size_t v91;
  uint8_t permuteMap[4];
  vImage_Buffer dest;
  vImage_Buffer src;
  _QWORD v95[5];
  __int128 v96;
  _OWORD v97[2];
  _OWORD v98[3];
  size_t v99;
  void *v100[3];
  CGRect v101;
  CGRect v102;
  CGRect v103;

  v4 = *((unsigned int *)this + 26);
  v99 = 0;
  v100[0] = 0;
  HIDWORD(v5) = 0;
  memset(v98, 0, 44);
  if (*((_QWORD *)this + 12))
  {
    v7 = *((_DWORD *)this + 58);
    if (v7 != 1 && (v7 > 9 || *((_DWORD *)this + 57) >= 0xAu))
    {
      v9 = *((unsigned int *)this + 28);
      v8 = *((unsigned int *)this + 29);
      if (v9 < v8)
      {
        v73 = v4;
        v10 = (CGRect *)MEMORY[0x1E0C9D628];
        v11 = &gIIODebugFlags;
        while (1)
        {
          v12 = *((_DWORD *)this + 93);
          if (v12)
            *((_DWORD *)this + 74) = v12;
          else
            v12 = *((_DWORD *)this + 74);
          v13 = v12 * v9;
          *((_DWORD *)this + 72) = v12 * v9;
          LODWORD(v5) = *((_DWORD *)this + 71);
          v14 = (double)(v12 * v9);
          v15 = (double)v5;
          LODWORD(v5) = *((_DWORD *)this + 73);
          v16 = (double)v5;
          LODWORD(a4) = *((_DWORD *)this + 58);
          v17 = (double)*(unint64_t *)&a4;
          if ((double)v12 + v14 <= v17)
            v18 = (double)v12;
          else
            v18 = v17 - (double)v13;
          IIOReadPlugin::updateImageIOCacheKey((uint64_t)this, (uint64_t)v98, *((_DWORD *)this + 75), v15, (double)v13, v16, v18);
          if (IIOImageRead::getCachedImageBlockData(*((_QWORD *)this + 4), v98, v100))
          {
            v19 = *((_QWORD *)this + 4);
            v95[0] = MEMORY[0x1E0C809B0];
            v95[1] = 0x40000000;
            v95[2] = ___ZN13IIOReadPlugin15getCachedBlocksEv_block_invoke;
            v95[3] = &__block_descriptor_tmp_161;
            v95[4] = this;
            v96 = v98[0];
            v97[0] = v98[1];
            *(_OWORD *)((char *)v97 + 12) = *(_OWORD *)((char *)&v98[1] + 12);
            IIOImageRead::enumerateCacheKeysWithBlock(v19, (uint64_t)v95);
            v101.origin.x = v15;
            v101.origin.y = v14;
            v101.size.width = v16;
            v101.size.height = v18;
            *(_QWORD *)(*((_QWORD *)this + 12) - 8 * *((unsigned int *)this + 28) + 8 * v9) = IIOReadPlugin::createImageBlock(this, v100[0], 0, v101, *((unsigned int *)this+ 75), 1);
            if (!CGRectEqualToRect(*(CGRect *)((char *)this + 120), *v10))
            {
              v102.origin.x = v15;
              v102.origin.y = v14;
              v102.size.width = v16;
              v102.size.height = v18;
              *(CGRect *)(&a4 - 2) = CGRectUnion(*(CGRect *)((char *)this + 120), v102);
              v15 = *(double *)&v5;
              v14 = v20;
              v16 = a4;
              v18 = v21;
            }
            *((double *)this + 15) = v15;
            *((double *)this + 16) = v14;
            *((double *)this + 17) = v16;
            *((double *)this + 18) = v18;
            if ((*v11 & 0x300) == 0x100 || (*v11 & 0x400000000000) != 0)
              ImageIOLog("::: cache  hit:      rect=(%5d, %5d, %5d, %5d)   rb=%d   imageData=%p\n");
          }
          else if (IIOReadPlugin::toggleCacheKey((uint64_t)this, (uint64_t)v98))
          {
            v22 = v11;
            v23 = *((unsigned __int8 *)this + 404);
            *((_BYTE *)this + 404) = v23 != 1;
            CachedImageBlockData = IIOImageRead::getCachedImageBlockData(*((_QWORD *)this + 4), v98, v100);
            *((_BYTE *)this + 404) = v23;
            if (!CachedImageBlockData)
            {
              v4 = v73;
              goto LABEL_106;
            }
            LODWORD(v16) = *((_DWORD *)this + 71);
            LODWORD(v25) = *((_DWORD *)this + 72);
            v27 = (double)v25;
            LODWORD(v18) = *((_DWORD *)this + 73);
            v28 = *((_DWORD *)this + 74);
            LODWORD(v26) = *((_DWORD *)this + 58);
            v29 = (double)v26;
            if ((double)v25 + (double)v28 <= v29)
              v30 = (double)v28;
            else
              v30 = v29 - v27;
            v91 = *((unsigned int *)this + 75) * (unint64_t)v28;
            v31 = (void *)_ImageIO_Malloc(v91, *((_QWORD *)this + 48), &v99, (uint64_t)"ImageIOGetCachedBlocks", *((_DWORD *)this + 108), 0, 0);
            v11 = v22;
            if (v31)
            {
              v32 = v31;
              v33 = *((unsigned int *)this + 74);
              src.data = v100[0];
              src.height = v33;
              v34 = *((unsigned int *)this + 75);
              src.width = *((unsigned int *)this + 73);
              src.rowBytes = v34;
              dest.data = v31;
              dest.height = v33;
              dest.width = src.width;
              dest.rowBytes = v34;
              *(_DWORD *)permuteMap = 50331906;
              PluginType = IIOImagePlus::readPluginType(*((IIOImagePlus **)this + 2));
              v36 = PluginType;
              v90 = (char *)gCrashMessage;
              v37 = PluginType >> 24;
              if (PluginType < 0)
              {
                v39 = __maskrune(PluginType >> 24, 0x40000uLL);
                v38 = MEMORY[0x1E0C80978];
              }
              else
              {
                v38 = MEMORY[0x1E0C80978];
                v39 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v37 + 60) & 0x40000;
              }
              if (v39)
                v41 = v37;
              else
                v41 = 46;
              v89 = v41;
              v42 = v36 << 8 >> 24;
              if (v36 << 8 < 0)
                v43 = __maskrune(v36 << 8 >> 24, 0x40000uLL);
              else
                v43 = *(_DWORD *)(v38 + 4 * v42 + 60) & 0x40000;
              if (v43)
                v44 = v42;
              else
                v44 = 46;
              v88 = v44;
              v45 = (__int16)v36 >> 8;
              if (v36 << 16 < 0)
                v46 = __maskrune((__int16)v36 >> 8, 0x40000uLL);
              else
                v46 = *(_DWORD *)(v38 + 4 * v45 + 60) & 0x40000;
              if (v46)
                v47 = v45;
              else
                v47 = 46;
              v87 = v47;
              if ((v36 << 24) <= 0x7F000000)
                v48 = *(_DWORD *)(v38 + 4 * (char)v36 + 60) & 0x40000;
              else
                v48 = __maskrune((char)v36, 0x40000uLL);
              if (v48)
                v49 = (char)v36;
              else
                v49 = 46;
              v85 = v100[0];
              v86 = v49;
              v84 = DWORD2(v98[2]);
              v83 = *((_DWORD *)this + 73);
              v82 = *((_DWORD *)this + 74);
              v81 = *((_DWORD *)this + 75);
              v75 = *((unsigned __int8 *)this + 312);
              v50 = *((unsigned __int8 *)this + 311);
              v51 = *((_BYTE *)this + 313) != 0;
              v52 = *((unsigned __int8 *)this + 310);
              v80 = *((unsigned __int16 *)this + 158);
              v78 = *((char *)this + 410);
              v79 = *((_QWORD *)this + 49);
              v53 = *((_DWORD *)this + 100);
              v54 = v53 >> 24;
              v76 = *((char *)this + 409);
              v77 = *((_QWORD *)this + 48);
              if (v53 < 0)
              {
                v55 = __maskrune(v54, 0x40000uLL);
                v53 = *((_DWORD *)this + 100);
              }
              else
              {
                v55 = *(_DWORD *)(v38 + 4 * v54 + 60) & 0x40000;
              }
              LODWORD(v56) = v53 >> 24;
              if (v55)
                v56 = v56;
              else
                v56 = 46;
              v74 = v56;
              v57 = v53 << 8 >> 24;
              if (v53 << 8 < 0)
              {
                v58 = __maskrune(v57, 0x40000uLL);
                v53 = *((_DWORD *)this + 100);
              }
              else
              {
                v58 = *(_DWORD *)(v38 + 4 * v57 + 60) & 0x40000;
              }
              if (v58)
                v59 = (v53 << 8 >> 24);
              else
                v59 = 46;
              v60 = (__int16)v53 >> 8;
              if (v53 << 16 < 0)
              {
                v61 = __maskrune(v60, 0x40000uLL);
                v53 = *((_DWORD *)this + 100);
              }
              else
              {
                v61 = *(_DWORD *)(v38 + 4 * v60 + 60) & 0x40000;
              }
              if (v61)
                v62 = ((__int16)v53 >> 8);
              else
                v62 = 46;
              if ((v53 << 24) <= 0x7F000000)
                v63 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v53 + 60) & 0x40000;
              else
                v63 = __maskrune((char)v53, 0x40000uLL);
              v64 = (v50 << 12) | (v75 << 16) | (v51 << 8) | v52;
              if (v63)
                v65 = *((_DWORD *)this + 100);
              else
                LOBYTE(v65) = 46;
              v11 = v22;
              snprintf(v90, 0x200uLL, "ImageIO: getCachedBlocks[%c%c%c%c]-permuteChannels srcData=%p(%d)  dstData=%p(%ld)  w=%d  h=%d  rb=%d  bmi=0x%08x  sub=%d  rbAlign=%ld(%d)  addrAlign=%ld(%d) format='%c%c%c%c'(%d)\n", v89, v88, v87, v86, v85, v84, v32, v91, v83, v82, v81, v64, v80, v79, v78,
                v77,
                v76,
                v74,
                v59,
                v62,
                (char)v65,
                *((char *)this + 404));
              qword_1ECDD8318 = gCrashMessage;
              vImagePermuteChannels_ARGB8888(&src, &dest, permuteMap, 0x10u);
              qword_1ECDD8318 = 0;
              v10 = (CGRect *)MEMORY[0x1E0C9D628];
              if (*((unsigned __int8 *)this + 246) - 3 <= 1)
              {
                if (*((_BYTE *)this + 404))
                {
                  if (*((_BYTE *)this + 404) == 1)
                    vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
                }
                else
                {
                  vImageUnpremultiplyData_RGBA8888(&dest, &dest, 0x10u);
                }
              }
              v66 = (double)*(unint64_t *)&v16;
              v67 = (double)*(unint64_t *)&v18;
              CGImageReadSessionReleaseCachedImageBlockData(v100[0]);
              *(_QWORD *)(*((_QWORD *)this + 12) - 8 * *((unsigned int *)this + 28) + 8 * v9) = IIO_ImageBlockCreate((unint64_t)v32, *((unsigned int *)this + 75), 0, v66, v27, v67, v30);
              if ((*((_BYTE *)v22 + 1) & 8) != 0)
                ImageIOLog("   CGImageBlockCreate-cache2     rect: (%5g, %5g, %5g, %5g)    rowBytes: %6d    imageData = %p  (found in cache)\n", v66, v27, v67, v30, *((_DWORD *)this + 75), v100[0]);
              if (!CGRectEqualToRect(*(CGRect *)((char *)this + 120), *v10))
              {
                v103.origin.x = v66;
                v103.origin.y = v27;
                v103.size.width = v67;
                v103.size.height = v30;
                *(CGRect *)(&a4 - 2) = CGRectUnion(*(CGRect *)((char *)this + 120), v103);
                v66 = *(double *)&v5;
                v27 = v68;
                v67 = a4;
                v30 = v69;
              }
              *((double *)this + 15) = v66;
              *((double *)this + 16) = v27;
              *((double *)this + 17) = v67;
              *((double *)this + 18) = v30;
              if ((*v22 & 0x300) == 0x100 || (*v22 & 0x400000000000) != 0)
                ImageIOLog("::: cache  hit RGB <-> BGR:      rect=(%5d, %5d, %5d, %5d)   rb=%d   imageData=%p\n");
            }
          }
          else if ((*v11 & 0x300) == 0x100 || (*v11 & 0x400000000000) != 0)
          {
            ImageIOLog("### cache miss:      rect=(%5d, %5d, %5d, %5d)\n");
          }
          ++v9;
          v8 = *((unsigned int *)this + 29);
          if (v9 >= v8)
          {
            LODWORD(v9) = *((_DWORD *)this + 28);
            break;
          }
        }
      }
      if (v8 <= v9)
      {
        LODWORD(v71) = v9;
      }
      else
      {
        v70 = (_QWORD *)*((_QWORD *)this + 12);
        v71 = v9;
        while (*v70)
        {
          ++v71;
          ++v70;
          if (v8 == v71)
          {
            LODWORD(v71) = v8;
            goto LABEL_103;
          }
        }
        v8 = (v8 - 1);
        if (v8 > v9)
        {
          while (*(_QWORD *)(*((_QWORD *)this + 12) - 8 * v9 + 8 * v8))
          {
            if (--v8 <= v9)
            {
              LODWORD(v8) = v9;
              break;
            }
          }
        }
        LODWORD(v8) = v8 + 1;
        *((_DWORD *)this + 29) = v8;
      }
LABEL_103:
      *((_DWORD *)this + 28) = v71;
      v4 = (v8 - v71);
      if ((_DWORD)v8 == (_DWORD)v71)
        ++*((_QWORD *)this + 53);
    }
  }
LABEL_106:
  IIO_XPCServer();
  return v4;
}

BOOL IIOImageRead::getCachedImageBlockData(uint64_t a1, _DWORD *a2, void **a3)
{
  int v5;
  char *DebugStringFromKey;
  char *v7;

  v5 = cache_get_and_retain((cache_t *)gImageBlockCache, a2, a3);
  if (*a3 && !a2[10])
    a2[10] = IOMemorySizeLookup((uint64_t)*a3);
  DebugStringFromKey = createDebugStringFromKey((uint64_t)a2);
  if (DebugStringFromKey)
  {
    v7 = DebugStringFromKey;
    if (v5)
      ImageIOLog("MIS cache_get_and_retain:  %p:   data: %12p key: %s  NOT FOUND\n");
    else
      ImageIOLog("FND cache_get_and_retain:  %p:   data: %12p key: %s\n");
    free(v7);
  }
  return v5 == 0;
}

char *createDebugStringFromKey(uint64_t a1)
{
  const void *v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  int v10;
  uint64_t v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;

  v20 = 0;
  if ((gIIODebugFlags & 0x400000000300) == 0)
    return 0;
  v2 = *(const void **)a1;
  v3 = *(_DWORD *)(a1 + 8);
  v4 = *(_DWORD *)(a1 + 12);
  v5 = *(_DWORD *)(a1 + 16);
  v6 = *(_DWORD *)(a1 + 20);
  v7 = *(_DWORD *)(a1 + 24);
  v8 = v7 >> 24;
  v9 = MEMORY[0x1E0C80978];
  if (v7 < 0)
  {
    v10 = __maskrune(v8, 0x40000uLL);
    v7 = *(_DWORD *)(a1 + 24);
  }
  else
  {
    v10 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v8 + 60) & 0x40000;
  }
  if (v10)
    v12 = (v7 >> 24);
  else
    v12 = 46;
  v13 = v7 << 8 >> 24;
  if (v7 << 8 < 0)
  {
    v14 = __maskrune(v13, 0x40000uLL);
    v7 = *(_DWORD *)(a1 + 24);
  }
  else
  {
    v14 = *(_DWORD *)(v9 + 4 * v13 + 60) & 0x40000;
  }
  if (v14)
    v15 = (v7 << 8 >> 24);
  else
    v15 = 46;
  v16 = (__int16)v7 >> 8;
  if (v7 << 16 < 0)
  {
    v17 = __maskrune(v16, 0x40000uLL);
    v7 = *(_DWORD *)(a1 + 24);
  }
  else
  {
    v17 = *(_DWORD *)(v9 + 4 * v16 + 60) & 0x40000;
  }
  if (v17)
    v18 = ((__int16)v7 >> 8);
  else
    v18 = 46;
  if ((v7 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v9 + 4 * (char)v7 + 60) & 0x40000) != 0)
      goto LABEL_23;
LABEL_25:
    v19 = 46;
    goto LABEL_26;
  }
  if (!__maskrune((char)v7, 0x40000uLL))
    goto LABEL_25;
LABEL_23:
  v19 = *(char *)(a1 + 24);
LABEL_26:
  asprintf(&v20, "'%p [%d,%d,%d,%d] '%c%c%c%c' #=%d rb=%6d rba=%3d sub=%2d float=%2d bpc=%2d'", v2, v3, v4, v5, v6, v12, v15, v18, v19, (unsigned __int16)*(_QWORD *)(a1 + 28), *(_DWORD *)(a1 + 36), WORD1(*(_QWORD *)(a1 + 28)), BYTE4(*(_QWORD *)(a1 + 28)), (unsigned __int16)WORD2(*(_QWORD *)(a1 + 28)) >> 8, BYTE6(*(_QWORD *)(a1 + 28)));
  return v20;
}

const void *IIOReadPlugin::createImageBlock(IIOReadPlugin *this, void *a2, mach_vm_size_t a3, CGRect a4, unint64_t a5, int a6)
{
  double height;
  double width;
  double y;
  double x;
  const char *v15;
  const void *v16;
  int v17;
  const void *v18;
  unsigned int v19;
  __int128 v21[3];

  height = a4.size.height;
  width = a4.size.width;
  y = a4.origin.y;
  x = a4.origin.x;
  if (IIOReadPlugin::readOnlyRequested(this))
    ImageIO_make_read_only((mach_vm_address_t)a2, a3);
  if (!a3 || !*((_BYTE *)this + 341) || !a6)
  {
LABEL_10:
    if (a2)
      goto LABEL_11;
LABEL_26:
    LogError("createImageBlock", 2455, "*** ERROR: CGImageBlockCreate {%g, %g, %g, %g} - data is NULL\n");
    return 0;
  }
  if (*((_DWORD *)this + 73) > 0xFu || *((_DWORD *)this + 74) >= 0x10u || *((_QWORD *)this + 52) >= 5uLL)
  {
    memset(v21, 0, 44);
    IIOReadPlugin::updateImageIOCacheKey((uint64_t)this, (uint64_t)v21, a5, x, y, width, height);
    DWORD2(v21[2]) = a3;
    IIOImageRead::setCachedImageBlockData(*((_QWORD *)this + 4), v21, a2, a3);
    goto LABEL_10;
  }
  if (!a2)
    goto LABEL_26;
LABEL_11:
  if (!a5)
  {
    LogError("createImageBlock", 2456, "*** ERROR: CGImageBlockCreate {%g, %g, %g, %g} - bytesPerRow is zero\n");
    return 0;
  }
  if (!a3)
  {
    v16 = (const void *)IOMemorySizeLookup((uint64_t)a2);
    v15 = "cached";
    goto LABEL_16;
  }
  if (height * (double)a5 > (double)a3)
  {
    LogError("createImageBlock", 2460, "*** ERROR: CGImageBlockCreate dataSize too small: %ld < %lld\n");
    return 0;
  }
  v15 = "";
  v16 = (const void *)a3;
LABEL_16:
  if ((gIIODebugFlags & 0x4000000000) != 0)
  {
    v17 = IIOHashForBuffer(a2, a3, 0);
    ImageIOLog("#️⃣ hash {%g,%g,%g,%g} rb: %d   ptr: %p   size: %ld  '%016x'\n", x, y, width, height, a5, a2, a3, v17);
  }
  v18 = (const void *)CGImageBlockCreate();
  if ((gIIODebugFlags & 0xC00) != 0)
  {
    do
      v19 = __ldxr((unsigned int *)&gBlockCount);
    while (__stxr(v19 + 1, (unsigned int *)&gBlockCount));
    ImageIOLog("    CGImageBlockCreate:       %14p - info: %14p  data: %14p  B-[%2ld]  rb: %8ld  r:(%4g,%4g,%4g,%4g) %s\n", v18, v16, a2, gBlockCount, a5, x, y, width, height, v15);
    if ((gIIODebugFlags & 0x800) != 0)
      IIODebug_ShowBacktrace(2);
  }
  if (*((_BYTE *)this + 176))
    IIOReadPlugin::debugWriteImageBlocks(this, a2, *((unsigned int *)this + 74), ++IIOReadPlugin::createImageBlock(void *,unsigned long,CGRect,unsigned long,BOOL)::uniqueBlockID, width, height, *((unsigned int *)this + 75), *((unsigned __int16 *)this + 152), (*((unsigned __int8 *)this + 311) << 12) | (*((unsigned __int8 *)this + 312) << 16) | ((*((_BYTE *)this + 313) != 0) << 8) | *((unsigned __int8 *)this + 310));
  return v18;
}

uint64_t IOMemorySizeLookup(uint64_t a1)
{
  uint64_t v1;
  unint64_t v3;
  unint64_t *v4;

  v1 = a1;
  if (a1)
  {
    pthread_mutex_lock(&gImageIOMemoryHashLock);
    if (gMemoryHashCreateOnce != -1)
      dispatch_once(&gMemoryHashCreateOnce, &__block_literal_global_30);
    v3 = ~v1;
    v4 = &v3;
    v1 = std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>((uint64_t **)(gIIOMemoryHash + 8), &v3, (uint64_t)&std::piecewise_construct, (uint64_t **)&v4)[5];
    pthread_mutex_unlock(&gImageIOMemoryHashLock);
  }
  return v1;
}

BOOL IIOReadPlugin::readOnlyRequested(IIOReadPlugin *this)
{
  _BOOL8 result;

  result = *((unsigned __int8 *)this + 407) == 1;
  if ((gIIODebugFlags & 0x400000000000) != 0)
  {
    if (IIOReadPlugin::readOnlyRequested(void)::onceToken == -1)
    {
      return 0;
    }
    else
    {
      dispatch_once(&IIOReadPlugin::readOnlyRequested(void)::onceToken, &__block_literal_global_12);
      return 0;
    }
  }
  return result;
}

uint64_t CGImageReadSessionReleaseCachedImageBlockData(void *value)
{
  if ((gIIODebugFlags & 0x200) != 0)
    _cg_jpeg_mem_term("CGImageReadSessionReleaseCachedImageBlockData", 555, "    cache_release_value:   %p:   data: %12p\n", (const void *)gImageBlockCache, value);
  return cache_release_value((cache_t *)gImageBlockCache, value);
}

uint64_t IIOImageReadSession::rewind(uint64_t this)
{
  *(_QWORD *)(this + 40) = 0;
  return this;
}

BOOL IIOImageReadSession::mapData(IIOImageRead **this)
{
  return IIOImageRead::mapData(this[4]);
}

BOOL IIOImageRead::mapData(IIOImageRead *this)
{
  const __CFData *v2;
  uint64_t v3;
  CFIndex Length;
  const __CFData *v5;
  uint64_t v6;
  CFIndex v7;
  int v8;
  CFIndex v9;
  int v11;
  BOOL v12;

  v12 = 0;
  v11 = 0;
  if ((gIIODebugFlags & 0x100000000000) != 0)
    ImageIOLog("    %s:   <IIOImageRead: %p> mmapping data    <CFData:%p>  count: %d\n", "mapData", this, *((const void **)this + 4), *((_DWORD *)this + 110));
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 376));
  if (*((_BYTE *)this + 67))
  {
    if (*((_QWORD *)this + 4))
    {
      IIOImageRead::validateFileSize(this);
    }
    else
    {
      v2 = IIOImageRead::createDataWithMappedFile(this, &v12, &v11);
      *((_QWORD *)this + 4) = v2;
      if ((gIIODebugFlags & 0x80000000000) == 0)
        goto LABEL_9;
      ImageIOLog("D   %s:%d createDataWithMappedFile %p\n", "mapData", 954, v2);
    }
    v2 = (const __CFData *)*((_QWORD *)this + 4);
LABEL_9:
    if (v2)
    {
      v3 = *((_QWORD *)this + 10);
      Length = CFDataGetLength(v2);
      v5 = (const __CFData *)*((_QWORD *)this + 4);
      if (v3 != Length)
      {
        v6 = *((_QWORD *)this + 10);
        v7 = CFDataGetLength(v5);
        LogFault("mapData", 962, "*** ImageIO - mmapped file changed (old: %ld  new: %ld)\n", v6, v7);
        *((_QWORD *)this + 10) = CFDataGetLength(*((CFDataRef *)this + 4));
        v5 = (const __CFData *)*((_QWORD *)this + 4);
      }
      if (v5)
      {
        v8 = *((_DWORD *)this + 110) + 1;
        *((_DWORD *)this + 110) = v8;
        if ((gIIODebugFlags & 0x100000000000) != 0)
        {
          v9 = CFGetRetainCount(v5);
          ImageIOLog("    %s:                  new count: %d   (rc=%ld)\n", "mapData", v8, v9);
        }
      }
    }
  }
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 376));
  return v12;
}

memory_object_offset_t _ImageIO_Malloc(size_t a1, uint64_t a2, size_t *a3, uint64_t a4, task_t a5, const char *a6, int a7)
{
  mach_vm_size_t *v13;
  unsigned __int8 v14;
  size_t v15;
  void *v16;
  memory_object_offset_t v17;
  vm_map_t *v18;
  mach_error_t memory_entry_64;
  size_t v20;
  size_t v21;
  mach_error_t v22;
  char *v23;
  size_t size;
  memory_object_offset_t v26;
  mach_port_t object_handle[2];

  pthread_mutex_lock(&gImageIOMemoryHashLock);
  v13 = (mach_vm_size_t *)MEMORY[0x1E0C85AD8];
  size = (a1 + *MEMORY[0x1E0C85AD8] - 1) & -*MEMORY[0x1E0C85AD8];
  {
    _ImageIO_Malloc::useGuardPages = _os_feature_enabled_impl();
  }
  v15 = size;
  if (_ImageIO_Malloc::useGuardPages)
  {
    v15 = size + *v13;
    size = v15;
  }
  if (v15 >= a1)
  {
    v16 = mmap(0, v15, 3, 4097, 1174405122, 0);
    if (v16 != (void *)-1)
    {
      v17 = (memory_object_offset_t)v16;
      v18 = (vm_map_t *)MEMORY[0x1E0C83DA0];
      if (_ImageIO_Malloc::useGuardPages)
        mach_vm_protect(*MEMORY[0x1E0C83DA0], (mach_vm_address_t)v16 + v15 - *v13, *v13, 1, 0);
      if (a5)
      {
        object_handle[0] = 0;
        memory_entry_64 = mach_make_memory_entry_64(*v18, &size, v17, 3, object_handle, 0);
        if (!memory_entry_64)
        {
          v22 = mach_memory_entry_ownership(object_handle[0], a5, -1, 0);
          if (v22)
          {
            v23 = mach_error_string(v22);
            LogError(a6, a7, "*** ERROR: mach_memory_entry_ownership: %s", v23);
          }
          mach_port_deallocate(*v18, object_handle[0]);
          if (!a4)
          {
LABEL_16:
            if (gMemoryHashCreateOnce == -1)
            {
              if (v17)
              {
LABEL_18:
                v20 = size;
                v26 = ~v17;
                *(_QWORD *)object_handle = &v26;
                std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>((uint64_t **)(gIIOMemoryHash + 8), &v26, (uint64_t)&std::piecewise_construct, (uint64_t **)object_handle)[5] = v20;
                v21 = size;
                *a3 = size;
                ImageIORecordMemory(v17, v21);
                goto LABEL_25;
              }
            }
            else
            {
              dispatch_once(&gMemoryHashCreateOnce, &__block_literal_global_30);
              if (v17)
                goto LABEL_18;
            }
            *a3 = 0;
            goto LABEL_25;
          }
LABEL_15:
          __CFSetLastAllocationEventName();
          goto LABEL_16;
        }
        mach_error_string(memory_entry_64);
        LogError(a6, a7, "*** ERROR: mach_make_memory_entry_64: %s");
      }
      else if (IIO_XPCServer())
      {
        LogError(a6, a7, "*** ERROR: OWNERLESS SERVER ALLOCATION: %s, %llu bytes");
      }
      if (!a4)
        goto LABEL_16;
      goto LABEL_15;
    }
  }
  v17 = 0;
LABEL_25:
  pthread_mutex_unlock(&gImageIOMemoryHashLock);
  return v17;
}

void sub_187E84AC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

const char *ImageIORecordMemory(uint64_t a1, uint64_t a2)
{
  const char *result;

  gImageIOBlockMemorySize += a2;
  if ((gIIODebugFlags & 3) != 0)
  {
    if (a2 < 1)
    {
      if (a2 < 0)
        result = ImageIOLog("ImageIO_Free:          %14p  [%12ld] total: %12ld  %s %s  %s:%d\n");
      else
        result = ImageIOLog("ImageIO_Malloc/Free:   %14p  [%12ld] total: %12ld  %s   %s:%d\n");
    }
    else
    {
      result = ImageIOLog("ImageIO_Malloc:        %14p  [%12ld] total: %12ld  %s  %s:%d\n");
    }
    if ((~(_BYTE)gIIODebugFlags & 3) == 0)
      return IIODebug_ShowBacktrace(2);
  }
  return result;
}

uint64_t IIOReadPlugin::toggleCacheKey(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  unsigned int v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  BOOL v20;
  int v21;
  uint64_t v22;

  if (*(_WORD *)(a1 + 306) != 32
    || *(_WORD *)(a1 + 304) != 8
    || *(_DWORD *)(a1 + 320) != 1
    || *(_DWORD *)(a1 + 228) != *(_DWORD *)(a1 + 292)
    || *(_DWORD *)(a1 + 232) != *(_DWORD *)(a1 + 296))
  {
    return 0;
  }
  result = 0;
  v4 = 1111970369;
  v5 = *(unsigned int *)(a2 + 24);
  if ((int)v5 > 1380401728)
  {
    if ((_DWORD)v5 != 1380401729)
    {
      if ((_DWORD)v5 != 1380401752)
        return result;
      v4 = 1111970392;
    }
  }
  else if ((_DWORD)v5 == 1111970369)
  {
    v4 = 1380401729;
  }
  else
  {
    if ((_DWORD)v5 != 1111970392)
      return result;
    v4 = 1380401752;
  }
  if ((gIIODebugFlags & 0x300) != 0)
  {
    v6 = MEMORY[0x1E0C80978];
    if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (v5 >> 24) + 60) & 0x40000) != 0)
      v7 = HIBYTE(*(_DWORD *)(a2 + 24));
    else
      v7 = 46;
    v8 = (int)((_DWORD)v5 << 8) >> 24;
    if ((((_DWORD)v5 << 8) & 0x80000000) != 0)
    {
      v9 = __maskrune(v8, 0x40000uLL);
      LODWORD(v5) = *(_DWORD *)(a2 + 24);
    }
    else
    {
      v9 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v8 + 60) & 0x40000;
    }
    if (v9)
      v10 = ((int)((_DWORD)v5 << 8) >> 24);
    else
      v10 = 46;
    v11 = (__int16)v5 >> 8;
    if ((((_DWORD)v5 << 16) & 0x80000000) != 0)
    {
      v12 = __maskrune(v11, 0x40000uLL);
      LODWORD(v5) = *(_DWORD *)(a2 + 24);
    }
    else
    {
      v12 = *(_DWORD *)(v6 + 4 * v11 + 60) & 0x40000;
    }
    if (v12)
      v13 = ((__int16)v5 >> 8);
    else
      v13 = 46;
    if ((_DWORD)v5 << 24 <= 0x7F000000u)
      v14 = *(_DWORD *)(v6 + 4 * (char)v5 + 60) & 0x40000;
    else
      v14 = __maskrune((char)v5, 0x40000uLL);
    v15 = 46;
    if (v14)
      v16 = *(char *)(a2 + 24);
    else
      v16 = 46;
    LODWORD(v17) = HIBYTE(v4);
    v18 = v6 + 60;
    if ((*(_DWORD *)(v6 + 60 + 4 * HIBYTE(v4)) & 0x40000) != 0)
      v17 = v17;
    else
      v17 = 46;
    LODWORD(v19) = (v4 >> 8) & 0x52;
    v20 = (*(_DWORD *)(v18 + 4 * v19) & 0x40000) == 0;
    v21 = *(_DWORD *)(v18 + 4 * (v4 & 0x59));
    if (v20)
      v19 = 46;
    else
      v19 = v19;
    if ((v21 & 0x40000) != 0)
      v22 = v4 & 0x59;
    else
      v22 = 46;
    if ((*(_DWORD *)(v6 + 344) & 0x40000) != 0)
      v15 = 71;
    ImageIOLog("::: found '%c%c%c%c' - checking alternate '%c%c%c%c'\n", v7, v10, v13, v16, v17, v15, v19, v22);
  }
  *(_DWORD *)(a2 + 24) = v4;
  return 1;
}

void IIODecodeFrameParams::~IIODecodeFrameParams(IIODecodeFrameParams *this)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *((_QWORD *)this + 10);
  if (v1)
  {
    v2 = *(_QWORD *)(v1 + 16);
    *(_QWORD *)(v1 + 16) = 0;
    if (v2)
      MEMORY[0x18D761C18](v2, 0x1000C8033FC2DF1);
    MEMORY[0x18D761C30](v1, 0x1020C40D090CC53);
  }
}

_QWORD *std::vector<IIODecodeFrameParams>::vector(_QWORD *a1, unint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<IIODecodeFrameParams>::__vallocate[abi:ne180100](a1, a2);
    v6 = a1[1];
    v7 = 88 * a2;
    v8 = v6 + 88 * a2;
    do
    {
      v9 = *(_OWORD *)(a3 + 16);
      *(_OWORD *)v6 = *(_OWORD *)a3;
      *(_OWORD *)(v6 + 16) = v9;
      v10 = *(_OWORD *)(a3 + 32);
      v11 = *(_OWORD *)(a3 + 48);
      v12 = *(_OWORD *)(a3 + 64);
      *(_QWORD *)(v6 + 80) = *(_QWORD *)(a3 + 80);
      *(_OWORD *)(v6 + 48) = v11;
      *(_OWORD *)(v6 + 64) = v12;
      *(_OWORD *)(v6 + 32) = v10;
      v6 += 88;
      v7 -= 88;
    }
    while (v7);
    a1[1] = v8;
  }
  return a1;
}

void sub_187E84F4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void PNGReadPlugin::DecodeUncomposedFrames(IIOImageRead *a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t **a5)
{
  int v9;
  double v10;
  double v11;
  double v12;
  size_t v13;
  _QWORD block[9];
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;

  v9 = *a4;
  if (v9 == 3)
  {
    v13 = 0x2E8BA2E8BA2E8BA3 * (a5[1] - *a5);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ___ZN13PNGReadPlugin22DecodeUncomposedFramesEP12IIOImageReadP13GlobalPNGInfoRK14ReadPluginDataRK13PNGPluginDataRNSt3__16vectorI20IIODecodeFrameParamsNSA_9allocatorISC_EEEE_block_invoke;
    block[3] = &__block_descriptor_tmp_151;
    block[4] = a1;
    block[5] = a2;
    block[6] = a3;
    block[7] = a4;
    block[8] = a5;
    dispatch_apply(v13, 0, block);
  }
  else
  {
    if (v9 == 2)
    {
      v17 = 0u;
      v18 = 0u;
      v15 = 0u;
      v16 = 0u;
      IIOImageReadSession::IIOImageReadSession((IIOImageReadSession *)&v15, a1);
      PNGReadPlugin::DecodeFrameInterlaced((IIOImageReadSession *)&v15, a3, a4, *a5);
    }
    else
    {
      if (v9 != 1)
        return;
      v17 = 0u;
      v18 = 0u;
      v15 = 0u;
      v16 = 0u;
      IIOImageReadSession::IIOImageReadSession((IIOImageReadSession *)&v15, a1);
      PNGReadPlugin::DecodeFrameStandard((IIOImageReadSession *)&v15, a3, (uint64_t)a4, *a5, v10, v11, v12);
    }
    IIOImageReadSession::~IIOImageReadSession((IIOImageReadSession *)&v15);
  }
}

void sub_187E85080(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  IIOImageReadSession::~IIOImageReadSession((IIOImageReadSession *)va);
  _Unwind_Resume(a1);
}

void IIOImageReadSession::IIOImageReadSession(IIOImageReadSession *this, IIOImageRead *a2)
{
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E1BB1BD0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 4) = a2;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = this;
  *((_QWORD *)this + 7) = this;
}

uint64_t PNGReadPlugin::postProcess(PNGReadPlugin *this, unsigned __int8 *a2)
{
  vImagePixelCount v4;
  size_t v5;
  BOOL v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  int v10;
  int v11;
  unsigned int v12;
  int v13;
  int v14;
  unsigned int v15;
  int v16;
  int v17;
  unsigned int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  int v32;
  unsigned int v33;
  int v34;
  uint64_t v35;
  unsigned int v36;
  int v37;
  uint64_t v38;
  unsigned int v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  int v44;
  uint64_t v45;
  unsigned int v46;
  int v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  int v51;
  unsigned int v52;
  int v53;
  uint64_t v54;
  unsigned int v55;
  int v56;
  uint64_t v57;
  unsigned int v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  unsigned int v62;
  int v63;
  uint64_t v64;
  unsigned int v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  unsigned int v69;
  int v70;
  uint64_t v71;
  unsigned int v72;
  int v73;
  uint64_t v74;
  uint8_t permuteMap[4];
  vImage_Buffer dest;

  if (*((_WORD *)this + 153) == 32 && *((_WORD *)this + 152) == 8 && *((_DWORD *)this + 100) != 1768842360)
  {
    v4 = *((unsigned int *)this + 74);
    dest.data = a2;
    dest.height = v4;
    v5 = *((unsigned int *)this + 75);
    dest.width = *((unsigned int *)this + 73);
    dest.rowBytes = v5;
    v6 = (*((_DWORD *)this + 120) & 0x1Fu) - 1 >= 2 && *((_BYTE *)this + 406) != 0;
    if (*((_BYTE *)this + 413) || *((_BYTE *)this + 512) == 1)
      v6 = 0;
    if (*((_BYTE *)this + 475))
    {
      if (*((_BYTE *)this + 405))
      {
        *(_DWORD *)permuteMap = 50331906;
        vImagePermuteChannels_ARGB8888(&dest, &dest, permuteMap, 0x10u);
        if ((gIIODebugFlags & 0x20000) != 0)
        {
          v7 = *((_DWORD *)this + 51);
          v8 = v7 >> 24;
          v9 = MEMORY[0x1E0C80978];
          if (v7 < 0)
          {
            v20 = MEMORY[0x1E0C80978];
            v10 = __maskrune(v8, 0x40000uLL);
            v9 = v20;
            v7 = *((_DWORD *)this + 51);
          }
          else
          {
            v10 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v8 + 60) & 0x40000;
          }
          if (v10)
            v21 = (v7 >> 24);
          else
            v21 = 46;
          v22 = v7 << 8 >> 24;
          if (v7 << 8 < 0)
          {
            v24 = v9;
            v23 = __maskrune(v22, 0x40000uLL);
            v9 = v24;
            v7 = *((_DWORD *)this + 51);
          }
          else
          {
            v23 = *(_DWORD *)(v9 + 4 * v22 + 60) & 0x40000;
          }
          if (v23)
            v25 = (v7 << 8 >> 24);
          else
            v25 = 46;
          v26 = (__int16)v7 >> 8;
          if (v7 << 16 < 0)
          {
            v28 = v9;
            v27 = __maskrune(v26, 0x40000uLL);
            v9 = v28;
            v7 = *((_DWORD *)this + 51);
          }
          else
          {
            v27 = *(_DWORD *)(v9 + 4 * v26 + 60) & 0x40000;
          }
          if (v27)
            v29 = ((__int16)v7 >> 8);
          else
            v29 = 46;
          if ((v7 << 24) <= 0x7F000000)
            v30 = *(_DWORD *)(v9 + 4 * (char)v7 + 60) & 0x40000;
          else
            v30 = __maskrune((char)v7, 0x40000uLL);
          if (v30)
            v31 = *((char *)this + 204);
          else
            v31 = 46;
          ImageIOLog("♦️  '%c%c%c%c' %d: vImagePermuteChannels_ARGB8888 {2,1,0,3}\n", v21, v25, v29, v31, 3391);
        }
        if (*((_BYTE *)this + 512) == 1 && *((_BYTE *)this + 404) != 1)
        {
          vImageUnpremultiplyData_RGBA8888(&dest, &dest, 0x10u);
          if ((gIIODebugFlags & 0x20000) != 0)
          {
            v32 = *((_DWORD *)this + 51);
            v33 = v32 >> 24;
            if (v32 < 0)
            {
              v34 = __maskrune(v33, 0x40000uLL);
              v32 = *((_DWORD *)this + 51);
            }
            else
            {
              v34 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v33 + 60) & 0x40000;
            }
            if (v34)
              v54 = (v32 >> 24);
            else
              v54 = 46;
            v55 = v32 << 8 >> 24;
            if (v32 << 8 < 0)
            {
              v56 = __maskrune(v55, 0x40000uLL);
              v32 = *((_DWORD *)this + 51);
            }
            else
            {
              v56 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v55 + 60) & 0x40000;
            }
            if (v56)
              v57 = (v32 << 8 >> 24);
            else
              v57 = 46;
            v58 = (__int16)v32 >> 8;
            if (v32 << 16 < 0)
            {
              v59 = __maskrune(v58, 0x40000uLL);
              v32 = *((_DWORD *)this + 51);
            }
            else
            {
              v59 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v58 + 60) & 0x40000;
            }
            if (v59)
              v60 = ((__int16)v32 >> 8);
            else
              v60 = 46;
            if ((v32 << 24) > 0x7F000000)
              __maskrune((char)v32, 0x40000uLL);
            ImageIOLog("♦️  '%c%c%c%c' %d: vImageUnpremultiplyData_RGBA8888 [%02X,%02X,%02X,%02X] -> [%02X,%02X,%02X,%02X]\n", v54, v57, v60);
          }
        }
      }
      else if (*((_BYTE *)this + 512) == 1 && *((_BYTE *)this + 404) != 1)
      {
        vImageUnpremultiplyData_RGBA8888(&dest, &dest, 0x10u);
        if ((gIIODebugFlags & 0x20000) != 0)
        {
          v14 = *((_DWORD *)this + 51);
          v15 = v14 >> 24;
          if (v14 < 0)
          {
            v16 = __maskrune(v15, 0x40000uLL);
            v14 = *((_DWORD *)this + 51);
          }
          else
          {
            v16 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v15 + 60) & 0x40000;
          }
          if (v16)
            v68 = (v14 >> 24);
          else
            v68 = 46;
          v69 = v14 << 8 >> 24;
          if (v14 << 8 < 0)
          {
            v70 = __maskrune(v69, 0x40000uLL);
            v14 = *((_DWORD *)this + 51);
          }
          else
          {
            v70 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v69 + 60) & 0x40000;
          }
          if (v70)
            v71 = (v14 << 8 >> 24);
          else
            v71 = 46;
          v72 = (__int16)v14 >> 8;
          if (v14 << 16 < 0)
          {
            v73 = __maskrune(v72, 0x40000uLL);
            v14 = *((_DWORD *)this + 51);
          }
          else
          {
            v73 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v72 + 60) & 0x40000;
          }
          if (v73)
            v74 = ((__int16)v14 >> 8);
          else
            v74 = 46;
          if ((v14 << 24) > 0x7F000000)
            __maskrune((char)v14, 0x40000uLL);
          ImageIOLog("♦️  '%c%c%c%c' %d: vImageUnpremultiplyData_BGRA8888 [%02X,%02X,%02X,%02X] -> [%02X,%02X,%02X,%02X]\n", v68, v71, v74);
        }
      }
    }
    else if (*((_BYTE *)this + 405))
    {
      if (v6 || *((_BYTE *)this + 406) == 1)
      {
        vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
        if ((gIIODebugFlags & 0x20000) != 0)
        {
          v11 = *((_DWORD *)this + 51);
          v12 = v11 >> 24;
          if (v11 < 0)
          {
            v13 = __maskrune(v12, 0x40000uLL);
            v11 = *((_DWORD *)this + 51);
          }
          else
          {
            v13 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v12 + 60) & 0x40000;
          }
          if (v13)
            v35 = (v11 >> 24);
          else
            v35 = 46;
          v36 = v11 << 8 >> 24;
          if (v11 << 8 < 0)
          {
            v37 = __maskrune(v36, 0x40000uLL);
            v11 = *((_DWORD *)this + 51);
          }
          else
          {
            v37 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v36 + 60) & 0x40000;
          }
          if (v37)
            v38 = (v11 << 8 >> 24);
          else
            v38 = 46;
          v39 = (__int16)v11 >> 8;
          if (v11 << 16 < 0)
          {
            v40 = __maskrune(v39, 0x40000uLL);
            v11 = *((_DWORD *)this + 51);
          }
          else
          {
            v40 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v39 + 60) & 0x40000;
          }
          if (v40)
            v41 = ((__int16)v11 >> 8);
          else
            v41 = 46;
          if ((v11 << 24) > 0x7F000000)
            __maskrune((char)v11, 0x40000uLL);
          ImageIOLog("♦️  '%c%c%c%c' %d: vImagePremultiplyData_RGBA8888 [%02X,%02X,%02X,%02X] -> [%02X,%02X,%02X,%02X]\n", v35, v38, v41);
        }
      }
    }
    else
    {
      *(_DWORD *)permuteMap = 50331906;
      vImagePermuteChannels_ARGB8888(&dest, &dest, permuteMap, 0x10u);
      if ((gIIODebugFlags & 0x20000) != 0)
      {
        v17 = *((_DWORD *)this + 51);
        v18 = v17 >> 24;
        if (v17 < 0)
        {
          v19 = __maskrune(v18, 0x40000uLL);
          v17 = *((_DWORD *)this + 51);
        }
        else
        {
          v19 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v18 + 60) & 0x40000;
        }
        if (v19)
          v42 = (v17 >> 24);
        else
          v42 = 46;
        v43 = v17 << 8 >> 24;
        if (v17 << 8 < 0)
        {
          v44 = __maskrune(v43, 0x40000uLL);
          v17 = *((_DWORD *)this + 51);
        }
        else
        {
          v44 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v43 + 60) & 0x40000;
        }
        if (v44)
          v45 = (v17 << 8 >> 24);
        else
          v45 = 46;
        v46 = (__int16)v17 >> 8;
        if (v17 << 16 < 0)
        {
          v47 = __maskrune(v46, 0x40000uLL);
          v17 = *((_DWORD *)this + 51);
        }
        else
        {
          v47 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v46 + 60) & 0x40000;
        }
        if (v47)
          v48 = ((__int16)v17 >> 8);
        else
          v48 = 46;
        if ((v17 << 24) <= 0x7F000000)
          v49 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v17 + 60) & 0x40000;
        else
          v49 = __maskrune((char)v17, 0x40000uLL);
        if (v49)
          v50 = *((char *)this + 204);
        else
          v50 = 46;
        ImageIOLog("♦️  '%c%c%c%c' %d: vImagePermuteChannels_ARGB8888 {2,1,0,3}\n", v42, v45, v48, v50, 3418);
      }
      if (*((_BYTE *)this + 406) == 1)
      {
        vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
        if ((gIIODebugFlags & 0x20000) != 0)
        {
          v51 = *((_DWORD *)this + 51);
          v52 = v51 >> 24;
          if (v51 < 0)
          {
            v53 = __maskrune(v52, 0x40000uLL);
            v51 = *((_DWORD *)this + 51);
          }
          else
          {
            v53 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v52 + 60) & 0x40000;
          }
          if (v53)
            v61 = (v51 >> 24);
          else
            v61 = 46;
          v62 = v51 << 8 >> 24;
          if (v51 << 8 < 0)
          {
            v63 = __maskrune(v62, 0x40000uLL);
            v51 = *((_DWORD *)this + 51);
          }
          else
          {
            v63 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v62 + 60) & 0x40000;
          }
          if (v63)
            v64 = (v51 << 8 >> 24);
          else
            v64 = 46;
          v65 = (__int16)v51 >> 8;
          if (v51 << 16 < 0)
          {
            v66 = __maskrune(v65, 0x40000uLL);
            v51 = *((_DWORD *)this + 51);
          }
          else
          {
            v66 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v65 + 60) & 0x40000;
          }
          if (v66)
            v67 = ((__int16)v51 >> 8);
          else
            v67 = 46;
          if ((v51 << 24) > 0x7F000000)
            __maskrune((char)v51, 0x40000uLL);
          ImageIOLog("♦️  '%c%c%c%c' %d: vImagePremultiplyData_BGRA8888 [%02X,%02X,%02X,%02X] -> [%02X,%02X,%02X,%02X]\n", v61, v64, v67);
        }
      }
    }
  }
  return 0;
}

void PNGReadPlugin::DecodeFrameStandard(IIOImageReadSession *a1, uint64_t a2, uint64_t a3, uint64_t *a4, double a5, double a6, double a7)
{
  uint64_t v8;
  _BOOL4 v10;
  unint64_t v11;
  unsigned int *v12;
  BOOL v14;
  unint64_t StatusReg;
  int v16;
  BOOL v17;
  int v18;
  int *v19;
  uint64_t v20;
  int v21;
  char v22;
  int v23;
  uint64_t v24;
  double v25;
  double v26;
  double v27;
  size_t v28;
  uint64_t *v29;
  int v30;
  unint64_t v31;
  _QWORD *v32;
  unsigned int *v33;
  unsigned int *v34;
  char *v35;
  unint64_t v36;
  int v37;
  unsigned int v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  unsigned int v42;
  int v43;
  uint64_t v44;
  unsigned int v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  unsigned int v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t rowbytes;
  unint64_t v56;
  uint64_t v57;
  size_t v58;
  char *v59;
  uint64_t v60;
  unint64_t v61;
  BOOL v62;
  int v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t v66;
  void *v67;
  size_t v68;
  double v69;
  double v70;
  int v71;
  unint64_t v72;
  int v74;
  __int16 v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  char *v82;
  uint64_t v84;
  unsigned __int8 *v86;
  uint64_t v87;
  _OWORD v88[3];
  unsigned int v89;
  unsigned int *v90;
  _QWORD *v91;
  _QWORD block[11];
  uint64_t v93;
  uint64_t *v94;
  uint64_t v95;
  int v96;
  uint64_t v97;
  uint64_t *v98;
  uint64_t v99;
  unsigned int v100;
  uint64_t v101;
  uint64_t *v102;
  uint64_t v103;
  int v104;

  v8 = a2;
  v10 = 0;
  v11 = *(unsigned __int16 *)(a2 + 132);
  v101 = 0;
  v102 = &v101;
  v103 = 0x2000000000;
  v104 = 0;
  v97 = 0;
  v98 = &v97;
  v99 = 0x2000000000;
  v100 = 0;
  v12 = *(unsigned int **)(a3 + 48);
  v14 = v11 >= 2 || *(_BYTE *)(a3 + 58) != 0 || v12 == 0;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  v16 = !v14;
  v17 = *(_BYTE *)(a2 + 157) == 0;
  v18 = v16 ^ 1;
  if (*(_BYTE *)(a2 + 157))
    v18 = 1;
  v19 = &v104;
  v93 = 0;
  v94 = &v93;
  v95 = 0x2000000000;
  v96 = -40;
  v20 = *a4;
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), StatusReg);
  if (v17)
    v21 = 0;
  else
    v21 = v18;
  v22 = v21 ^ 1;
  if (*(_BYTE *)(a3 + 19) == 3)
    v23 = v21 ^ 1;
  else
    v23 = 1;
  if ((v22 & 1) == 0 && v23)
    v10 = *v12 > 1;
  v87 = a4[5];
  v24 = *(unsigned int *)(a2 + 112);
  v25 = (double)(v20 * v24);
  LODWORD(a7) = *(_DWORD *)(a2 + 48);
  v26 = (double)*(unint64_t *)&a7;
  if ((double)v24 + v25 <= v26)
    v27 = (double)v24;
  else
    v27 = v26 - v25;
  if (!v10 || *(_BYTE *)(a3 + 57))
    goto LABEL_29;
  v96 = 0;
  v100 = v12[4];
  v28 = *v12;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___ZN13PNGReadPlugin19DecodeFrameStandardEP19IIOImageReadSessionRK14ReadPluginDataRK13PNGPluginDataR20IIODecodeFrameParams_block_invoke;
  block[3] = &unk_1E1BC1FE0;
  block[8] = a1;
  block[9] = a2;
  block[10] = v87;
  block[4] = &v101;
  block[5] = &v97;
  block[6] = &v93;
  block[7] = a3;
  dispatch_apply(v28, 0, block);
  v29 = v102;
  v19 = (int *)(v102 + 3);
  v30 = *((_DWORD *)v102 + 6);
  if (v30 <= *((_DWORD *)v98 + 6))
    v30 = *((_DWORD *)v98 + 6);
  *v19 = v30;
  if (*((_DWORD *)v94 + 6))
  {
LABEL_29:
    v31 = (unint64_t)(v27 + v25);
    *v19 = 0;
    v32 = _cg_png_create_read_struct("1.6.43", 0, (uint64_t)handle_error, (uint64_t)handle_warning);
    v91 = v32;
    _cg_png_create_info_struct((uint64_t)v32);
    v34 = v33;
    v35 = 0;
    v90 = v33;
    if (v32 && v33)
    {
      _cg_png_set_option((uint64_t)v32, 2u, 3);
      _cg_png_set_benign_errors((uint64_t)v32, 1);
      v36 = *(_QWORD *)(v8 + 8);
      if (v36)
        IIOImageReadSession::seek(a1, v36, 0);
      else
        IIOImageReadSession::rewind((uint64_t)a1);
      _cg_png_set_read_fn(v32, (uint64_t)a1, (size_t (*)(size_t, void *, size_t))read_fn);
      _cg_png_set_keep_unknown_chunks_sized((uint64_t)v32, 3u, "CgBI", 4);
      *(_BYTE *)(a3 + 56) = 0;
      _cg_png_set_read_user_chunk_fn((uint64_t)v32, a3, (uint64_t)PNGReadPlugin::Read_user_chunk_callback);
      _cg_png_read_info((uLong)v32, v34);
      PNGReadPlugin::Validate_png_info((uint64_t)v32, (uint64_t)v34, a3);
      if (*(_BYTE *)(a3 + 27))
      {
        _cg_png_set_add_alpha((uint64_t)v32, 255, 1);
        if ((gIIODebugFlags & 0x20000) != 0)
        {
          v37 = *(_DWORD *)(v8 + 20);
          v38 = v37 >> 24;
          v39 = MEMORY[0x1E0C80978];
          if (v37 < 0)
          {
            v40 = __maskrune(v38, 0x40000uLL);
            v37 = *(_DWORD *)(v8 + 20);
            v38 = v37 >> 24;
          }
          else
          {
            v40 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v38 + 60) & 0x40000;
          }
          if (v40)
            v41 = v38;
          else
            v41 = 46;
          v84 = v41;
          v42 = v37 << 8 >> 24;
          if (v37 << 8 < 0)
          {
            v43 = __maskrune(v42, 0x40000uLL);
            v37 = *(_DWORD *)(v8 + 20);
            v42 = v37 << 8 >> 24;
          }
          else
          {
            v43 = *(_DWORD *)(v39 + 4 * v42 + 60) & 0x40000;
          }
          if (v43)
            v44 = v42;
          else
            v44 = 46;
          v45 = (__int16)v37 >> 8;
          if (v37 << 16 < 0)
          {
            v47 = __maskrune(v45, 0x40000uLL);
            v46 = v39;
            v37 = *(_DWORD *)(v8 + 20);
            v45 = (__int16)v37 >> 8;
          }
          else
          {
            v46 = v39;
            v47 = *(_DWORD *)(v39 + 4 * v45 + 60) & 0x40000;
          }
          if (v47)
            v48 = v45;
          else
            v48 = 46;
          v49 = (char)v37;
          if ((v37 << 24) <= 0x7F000000)
          {
            v50 = *(_DWORD *)(v46 + 4 * (char)v37 + 60) & 0x40000;
          }
          else
          {
            v50 = __maskrune((char)v37, 0x40000uLL);
            v49 = *(char *)(v8 + 20);
          }
          if (v50)
            v51 = v49;
          else
            v51 = 46;
          ImageIOLog("♦️  '%c%c%c%c' %d: png_set_add_alpha: PNG_FILLER_AFTER\n", v84, v44, v48, v51, 4398);
        }
      }
      if (*(_BYTE *)(v8 + 63) == 1)
        _cg_png_set_swap((uint64_t)v32);
      PNGReadPlugin::Update_png_struct(v8, (_BYTE *)a3, (uint64_t)v32, v34);
      if (v20)
      {
        if (v11 <= 1)
          v52 = 1;
        else
          v52 = v11;
        v53 = v20 * v52 * *(unsigned int *)(v8 + 112);
        if ((gIIODebugFlags & 0x30000) != 0)
          ImageIOLog("    skipping rows %4d through %4d\n", 0, v53);
        if (v53)
        {
          v54 = v53;
          do
          {
            _cg_png_read_row_sized((uLong)v32, 0, 0, 0);
            --v54;
          }
          while (v54);
        }
      }
      v89 = 1;
      rowbytes = _cg_png_get_rowbytes((uint64_t)v32, (uint64_t)v34);
      v56 = rowbytes;
      if (v11 >= 2)
      {
        if (v11 > 0x100)
          v57 = 1;
        else
          v57 = 0x100 / v11;
        v89 = v57;
        v58 = rowbytes * v11 * v57;
      }
      else
      {
        LODWORD(v57) = 1;
        v58 = rowbytes;
      }
      v59 = (char *)malloc_type_calloc(v58, 1uLL, 0x8A132A07uLL);
      v35 = v59;
      if (v11 >= 2)
      {
        v86 = (unsigned __int8 *)v59;
        v69 = (double)v11 * v25;
        v70 = (double)(unint64_t)v69 + v27 * (double)v11;
        v71 = *(_DWORD *)(v8 + 44);
        if ((unint64_t)v70 >= *(unsigned int *)(v8 + 48))
          v72 = *(unsigned int *)(v8 + 48);
        else
          v72 = (unint64_t)v70;
        if (*(_BYTE *)(v8 + 62) == 1 && *(_BYTE *)(a3 + 35) == 0)
          v74 = 3;
        else
          v74 = *(unsigned __int8 *)(v8 + 62);
        v75 = *(_WORD *)(v8 + 92);
        memset(v88, 0, sizeof(v88));
        IIOSubsampler::IIOSubsampler((IIOSubsampler *)v88, v71, v56, v74, *(_WORD *)(v8 + 56), v75, *(_WORD *)(v8 + 132), 0, *(_DWORD *)(v8 + 108), *(_DWORD *)(v8 + 116));
        v76 = (unint64_t)v69;
        if (v72 > (unint64_t)v69)
        {
          v77 = 0;
          do
          {
            v78 = v8;
            v79 = v76 + (v57 * v11);
            if (v79 > v72)
            {
              v57 = (v72 - v76) / v11;
              v89 = v57;
              v79 = v72;
            }
            v80 = v11;
            v81 = v76 - v79;
            if (v76 < v79)
            {
              v82 = (char *)v86;
              do
              {
                _cg_png_read_row_sized((uLong)v32, v82, v56, 0);
                v82 += v56;
              }
              while (!__CFADD__(v81++, 1));
              LODWORD(v57) = v89;
              v76 = v79;
            }
            v11 = v80;
            IIOSubsampler::subsample((IIOSubsampler *)v88, v86, v57 * v80, (unsigned __int8 *)(v87 + v77 * *(unsigned int *)(v78 + 116)), &v89);
            LODWORD(v57) = v89;
            v77 += v89;
            *((_DWORD *)v102 + 6) += v89;
            v8 = v78;
          }
          while (v76 < v72);
        }
        IIOSubsampler::~IIOSubsampler((IIOSubsampler *)v88);
        v35 = (char *)v86;
      }
      else
      {
        v60 = 0;
        if (*(unsigned __int16 *)(v8 + 56) <= 7u
          && *(_BYTE *)(a3 + 19) == 3
          && !*(_BYTE *)(a3 + 28)
          && *(_BYTE *)(v8 + 220) != 1)
        {
          v60 = operator new();
          IIOPixelConverterIndexed::IIOPixelConverterIndexed(v60, 12, 1, *(unsigned __int8 *)(v8 + 56), 12, 8, 0, 0);
        }
        v61 = (unint64_t)v25;
        if (v60)
          v62 = 0;
        else
          v62 = v58 == a4[6];
        v63 = v62;
        v64 = v31 - v61;
        if (v31 > v61)
        {
          v65 = 0;
          do
          {
            v66 = *(unsigned int *)(v8 + 116);
            v67 = (void *)(v87 + v65 * v66);
            if (v63)
            {
              _cg_png_read_row_sized((uLong)v32, (char *)(v87 + v65 * v66), v56, 0);
            }
            else
            {
              _cg_png_read_row_sized((uLong)v32, v35, v56, 0);
              if (v60)
              {
                (*(void (**)(uint64_t, char *, void *, _QWORD))(*(_QWORD *)v60 + 24))(v60, v35, v67, *(unsigned int *)(v8 + 108));
              }
              else
              {
                if (v56 >= *(unsigned int *)(v8 + 116))
                  v68 = *(unsigned int *)(v8 + 116);
                else
                  v68 = v56;
                memcpy(v67, v35, v68);
              }
            }
            ++*((_DWORD *)v102 + 6);
            ++v65;
          }
          while (v64 != v65);
        }
        if (v60)
          (*(void (**)(uint64_t))(*(_QWORD *)v60 + 8))(v60);
      }
    }
    _cg_png_destroy_read_struct((uint64_t *)&v91, (void **)&v90, 0);
    if (v35)
      free(v35);
    v29 = v102;
  }
  a4[8] = *((int *)v29 + 6);
  _Block_object_dispose(&v93, 8);
  _Block_object_dispose(&v97, 8);
  _Block_object_dispose(&v101, 8);
}

void sub_187E86220(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28)
{
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v32;
  unint64_t v33;

  MEMORY[0x18D761C30](v28, 0x10F1C4050BC5624);
  __cxa_begin_catch(a1);
  imagePNG_error_break(a28);
  v32 = *(_QWORD *)(v30 - 128);
  v33 = *(int *)(v32 + 24);
  if ((int)v33 >= 1 && v29 > v33)
    *(_DWORD *)(v32 + 24) = v29;
  __cxa_end_catch();
  JUMPOUT(0x187E861ACLL);
}

void sub_187E862E4(_Unwind_Exception *a1)
{
  uint64_t v1;

  __cxa_end_catch();
  _Block_object_dispose((const void *)(v1 - 200), 8);
  _Block_object_dispose((const void *)(v1 - 168), 8);
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

void IIOImageRead::validateFileSize(IIOImageRead *this)
{
  const __CFURL *v2;
  CFStringRef v3;
  CFStringRef v4;
  off_t st_size;
  CFIndex Length;
  stat v7;
  char v8[1024];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  memset(&v7, 0, sizeof(v7));
  v2 = (const __CFURL *)*((_QWORD *)this + 6);
  if (v2)
  {
    v3 = IIO_CFURLCopyResolvedFileSystemPath(v2);
    if (v3)
    {
      v4 = v3;
      bzero(v8, 0x400uLL);
      if (_CFStringGetFileSystemRepresentation())
      {
        if (!stat(v8, &v7))
        {
          st_size = v7.st_size;
          if (st_size != CFDataGetLength(*((CFDataRef *)this + 4)))
          {
            Length = CFDataGetLength(*((CFDataRef *)this + 4));
            LogFault("validateFileSize", 1717, "*** ImageIO - mmapped file changed (old: %ld  new: %ld)\n", Length, v7.st_size);
          }
        }
      }
      else
      {
        LogError("validateFileSize", 1711, "*** ERROR: cannot get URL path\n");
      }
      CFRelease(v4);
    }
    else
    {
      LogError("validateFileSize", 1708, "*** ERROR: cannot resolve URL\n");
    }
  }
}

uint64_t AppleJPEGReadPlugin::copyImageBlockSetImp(uint64_t a1, const void *a2, const void *a3, __CFDictionary *a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  unint64_t v18;
  unint64_t v19;
  double v20;
  double v21;
  double v22;
  double v23;
  const __CFString *v24;
  const __CFDictionary *Uint64ForKey;
  uint64_t v26;
  unint64_t v27;
  __int128 *v28;
  __int128 v29;
  uint64_t v30;
  uint64_t ImageBlockSetWithHardwareDecode;
  int v32;
  __int128 v33;
  _BOOL4 v34;
  int v35;
  __int128 v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int v39;
  double v40;
  double v41;
  unsigned int v43;
  unsigned int v45;
  unsigned int v46;
  BOOL v48;
  unint64_t v49;
  int v50;
  __int128 v51;
  unint64_t v52;
  int v53;
  BOOL v54;
  int v55;
  unsigned int v56;
  unsigned int v57;
  unint64_t v58;
  int v59;
  double v60;
  unint64_t v61;
  int v62;
  int v63;
  int v64;
  uint64_t PixelSize;
  uint64_t v66;
  double v67;
  double v68;
  double v69;
  IIOImageRead **v70;
  unsigned int v71;
  const char *v72;
  size_t v73;
  uint64_t v74;
  int v75;
  unint64_t v76;
  CGRect *v77;
  int v78;
  int v79;
  int v80;
  int v81;
  __n128 v82;
  double x;
  double y;
  double width;
  unsigned int v86;
  double height;
  int v88;
  int v89;
  int v90;
  int v91;
  AppleJPEGReadPlugin *output_dimensions;
  int v93;
  uint64_t v94;
  size_t v95;
  size_t v96;
  void *v97;
  int v98;
  uint64_t v99;
  uint64_t v100;
  _BOOL4 v101;
  uint64_t v102;
  unint64_t v103;
  const char *v104;
  __int128 v105;
  const char **v106;
  uint64_t v108;
  int *v110;
  _BOOL4 v112;
  unsigned int v113;
  _QWORD v114[3];
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  int v119;
  uint64_t v120;
  uint64_t v121;
  size_t v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  uint64_t v132;
  void *v133;
  size_t v134;
  size_t v135;
  _QWORD v136[7];
  CGRect v137;
  CGRect v138;
  CGRect v139;
  CGRect v140;

  v136[4] = *MEMORY[0x1E0C80C00];
  v135 = 0;
  v133 = 0;
  v134 = 0;
  v132 = 0;
  v130 = 0u;
  v131 = 0u;
  v128 = 0u;
  v129 = 0u;
  v126 = 0u;
  v127 = 0u;
  v124 = 0u;
  v125 = 0u;
  v123 = 0u;
  v121 = 0;
  v122 = 0;
  v120 = 0;
  v119 = 0;
  v117 = 0u;
  v118 = 0u;
  v115 = 0u;
  v116 = 0u;
  memset(v114, 0, sizeof(v114));
  IIODictionary::IIODictionary((IIODictionary *)v114, a4);
  AppleJPEGReadPlugin::appleJPEGDecodeSetup((_QWORD *)a1);
  v113 = *(unsigned __int16 *)(a1 + 316);
  if (!a3)
  {
    LODWORD(v18) = *(_DWORD *)(a1 + 228);
    LODWORD(v19) = *(_DWORD *)(a1 + 232);
    v21 = (double)v18;
    v23 = (double)v19;
    if (*(_QWORD *)(a1 + 504))
      goto LABEL_3;
LABEL_27:
    _cg_jpeg_mem_term("copyImageBlockSetImp", 2886, "*** applejpeg_decode_session is nil");
LABEL_28:
    v32 = 0;
    goto LABEL_209;
  }
  CGImageProviderGetSize();
  v21 = v20;
  v23 = v22;
  if (!*(_QWORD *)(a1 + 504))
    goto LABEL_27;
LABEL_3:
  if (!*(_BYTE *)(a1 + 679))
  {
    HIDWORD(v120) = AppleJPEGReadPlugin::appleJPEGDecodeOpen((AppleJPEGReadPlugin *)a1);
    HIDWORD(v120) = applejpeg_decode_get_image_info();
    if (HIDWORD(v120))
      goto LABEL_28;
  }
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("    %s:%d: Entering\n", "copyImageBlockSetImp", 2898);
  IIOReadPlugin::debugCopyBlockSet((const char *)a1, a3, a5, a6, a7, a8, a9, a10);
  if (IIODictionary::containsKey((IIODictionary *)v114, CFSTR("kCGImageBlockPreHeating")))
    *(_BYTE *)(a1 + 497) = IIODictionary::getBoolForKey((IIODictionary *)v114, CFSTR("kCGImageBlockPreHeating"));
  v24 = (const __CFString *)*MEMORY[0x1E0C9DAC8];
  if (!IIODictionary::containsKey((IIODictionary *)v114, (const __CFString *)*MEMORY[0x1E0C9DAC8]))
    goto LABEL_21;
  Uint64ForKey = IIODictionary::getUint64ForKey((IIODictionary *)v114, v24);
  if ((unint64_t)Uint64ForKey - 1 >= 0xFF)
    v27 = (unint64_t)Uint64ForKey;
  else
    v27 = 256;
  v28 = (__int128 *)(a1 + 284);
  if (v27 > *(unsigned int *)(a1 + 292) || v27 > *(unsigned int *)(a1 + 296))
  {
    LODWORD(v136[0]) = 0;
    v29 = *(_OWORD *)(a1 + 300);
    v117 = *v28;
    v118 = v29;
LABEL_16:
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("    decoding single tile: {%g,%g,%g,%g} {%g,%g}\n", a5, a6, a7, a8, a9, a10);
    v30 = AppleJPEGReadPlugin::copyImageBlockSetSingleTile(a1, a2, a3, a5, a6, a7, a8, a9, a10, v26, v136);
    goto LABEL_19;
  }
  LODWORD(v136[0]) = 0;
  v51 = *(_OWORD *)(a1 + 300);
  v117 = *v28;
  v118 = v51;
  if (!v27)
    goto LABEL_16;
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("    decoding multi tiles [%d]: {%g,%g,%g,%g} {%g,%g}\n", v27, a5, a6, a7, a8, a9, a10);
  v30 = AppleJPEGReadPlugin::copyImageBlockSetTiles(a1, a2, a3, v27, v136, a5, a6, a7, a8, a9, a10);
LABEL_19:
  ImageBlockSetWithHardwareDecode = v30;
  v32 = 0;
  v33 = v118;
  *v28 = v117;
  *(_OWORD *)(a1 + 300) = v33;
  if (!v30)
  {
    v34 = 0;
    if (LODWORD(v136[0]) == 1)
      goto LABEL_202;
LABEL_21:
    v35 = *(unsigned __int16 *)(a1 + 308);
    if (*(_BYTE *)(a1 + 348))
    {
      if ((gIIODebugFlags & 0x30000) != 0)
        ImageIOLog("RB  multi-res: original subsampleFactor: %d\n", v113);
      v36 = *(_OWORD *)(a1 + 300);
      v115 = *(_OWORD *)(a1 + 284);
      v116 = v36;
      if (v113 < 2)
      {
        v37 = v21;
        v38 = v23;
      }
      else
      {
        v37 = *(_DWORD *)(a1 + 600);
        v38 = *(_DWORD *)(a1 + 604);
      }
      v39 = v37 >> 3;
      v40 = (double)(v37 >> 3);
      v41 = (double)(v38 >> 3);
      if (a9 > v40 || a10 > v41)
      {
        v43 = v37 >> 2;
        v40 = (double)(v37 >> 2);
        v41 = (double)(v38 >> 2);
        if (a9 > v40 || a10 > v41)
        {
          v45 = v37 >> 1;
          v40 = (double)v45;
          v46 = v38 >> 1;
          v41 = (double)v46;
          v48 = a9 > (double)v45 || a10 > v41 || v113 == 2;
          if (!v48)
          {
            *(_WORD *)(a1 + 316) = 2;
            *(_DWORD *)(a1 + 292) = v45;
            *(_DWORD *)(a1 + 296) = v46;
            v49 = v45 * (unint64_t)((*(unsigned __int16 *)(a1 + 240) + 7) >> 3 << (2 * (v35 != 1)));
            v48 = (v49 & 0xFFFFFFFF00000000) == 0;
            v50 = (v49 + 15) & 0xFFFFFFF0;
            if (!v48)
              v50 = 0;
            *(_DWORD *)(a1 + 300) = v50;
            if ((gIIODebugFlags & 0x30000) != 0)
              ImageIOLog("RB  multi-res: new subsampleFactor 2:  rb=%d\n", v50);
            goto LABEL_72;
          }
        }
        else if (v113 != 4)
        {
          *(_WORD *)(a1 + 316) = 4;
          *(_DWORD *)(a1 + 292) = v43;
          *(_DWORD *)(a1 + 296) = v38 >> 2;
          v61 = v43 * (unint64_t)((*(unsigned __int16 *)(a1 + 240) + 7) >> 3 << (2 * (v35 != 1)));
          v48 = (v61 & 0xFFFFFFFF00000000) == 0;
          v62 = (v61 + 15) & 0xFFFFFFF0;
          if (!v48)
            v62 = 0;
          *(_DWORD *)(a1 + 300) = v62;
          if ((gIIODebugFlags & 0x30000) != 0)
            ImageIOLog("RB  multi-res: new subsampleFactor 4:  rb=%d\n", v62);
          goto LABEL_72;
        }
      }
      else if (v113 != 8)
      {
        *(_WORD *)(a1 + 316) = 8;
        *(_DWORD *)(a1 + 292) = v39;
        *(_DWORD *)(a1 + 296) = v38 >> 3;
        v52 = v39 * (unint64_t)((*(unsigned __int16 *)(a1 + 240) + 7) >> 3 << (2 * (v35 != 1)));
        v48 = (v52 & 0xFFFFFFFF00000000) == 0;
        v53 = (v52 + 15) & 0xFFFFFFF0;
        if (!v48)
          v53 = 0;
        *(_DWORD *)(a1 + 300) = v53;
        if ((gIIODebugFlags & 0x30000) != 0)
          ImageIOLog("RB  multi-res: new subsampleFactor 8:  rb=%d\n", v53);
LABEL_72:
        v55 = *(_DWORD *)(a1 + 300);
        v32 = 1;
        v23 = v41;
        v60 = v40;
LABEL_73:
        if (!*(_BYTE *)(a1 + 341))
        {
          *(_BYTE *)(a1 + 496) = 0;
          if ((gIIODebugFlags & 0x1000000000) != 0)
            ImageIOLog("H   Skipping HW decode - image is not final\n");
        }
        if (*(_DWORD *)(a1 + 608) == 1)
        {
          *(_BYTE *)(a1 + 496) = 0;
          if ((gIIODebugFlags & 0x1000000000) != 0)
            ImageIOLog("H   Skipping HW decode - APPLEJPEG_JPEG_PROGRESSIVE\n");
        }
        if (a10 < v23)
          v63 = 1;
        else
          v63 = v32;
        if (v63)
          a8 = v23;
        v64 = *(unsigned __int8 *)(a1 + 408);
        CGImageProviderGetPixelSize();
        if ((ImageIOShouldAllowFullsizeDecode() & 1) != 0)
        {
          if (v64 == 1)
          {
            v110 = (int *)(a1 + 372);
            *(_QWORD *)(a1 + 368) = 0;
            goto LABEL_95;
          }
          if (!*(_BYTE *)(a1 + 341))
          {
            v75 = *(_DWORD *)(a1 + 608);
            v110 = (int *)(a1 + 372);
            *(_QWORD *)(a1 + 368) = 0;
            if (v75 == 1)
              goto LABEL_95;
            goto LABEL_93;
          }
LABEL_92:
          v110 = (int *)(a1 + 372);
          *(_QWORD *)(a1 + 368) = 0;
LABEL_93:
          if (!*(_BYTE *)(a1 + 496))
          {
            v137.origin.x = a5;
            v137.origin.y = a6;
            v137.size.width = v60;
            v137.size.height = a8;
            IIOReadPlugin::optInForBandedDecoding((IIOReadPlugin *)a1, v137);
          }
LABEL_95:
          v66 = *(unsigned int *)(a1 + 112);
          *(_DWORD *)(a1 + 284) = 0;
          *(_DWORD *)(a1 + 288) = *(_DWORD *)(a1 + 296) * v66;
          HIDWORD(v120) = IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, *(unsigned int *)(a1 + 104));
          if (!HIDWORD(v120))
          {
            if (!IIOReadPlugin::getCachedBlocks((IIOReadPlugin *)a1, v67, v68, v69))
            {
              v34 = 0;
              v71 = 0;
LABEL_191:
              if (*(_BYTE *)(a1 + 341))
                AppleJPEGReadPlugin::save_index_table((AppleJPEGReadPlugin *)a1);
              if (!v71)
              {
                v102 = *(_QWORD *)(a1 + 16);
                if (v102)
                  IIOImagePlus::setStatus(v102, kCGImageStatusComplete);
              }
              ImageBlockSetWithHardwareDecode = 0;
              if (!a3)
                goto LABEL_202;
              v103 = *(unsigned int *)(a1 + 104);
              if (!(_DWORD)v103)
                goto LABEL_202;
              ImageBlockSetWithHardwareDecode = IIOReadPlugin::imageBlockSetCreate(a1, (uint64_t)a3, v103, v60, v23, *(double *)(a1 + 120), *(double *)(a1 + 128), *(double *)(a1 + 136), *(double *)(a1 + 144), *(_QWORD *)(a1 + 96), a2);
LABEL_203:
              IIOReadPlugin::freeBlockArray((IIOReadPlugin *)a1);
              goto LABEL_204;
            }
            v70 = *(IIOImageRead ***)(a1 + 24);
            if (v70)
              v112 = IIOImageReadSession::mapData(v70);
            else
              v112 = 0;
            if (*(_BYTE *)(a1 + 673) && *(_BYTE *)(a1 + 674) != 1)
              *(_BYTE *)(a1 + 496) = 0;
            if ((gIIODebugFlags & 0x1000000000) != 0)
            {
              if (*(_BYTE *)(a1 + 496))
                v72 = "YES";
              else
                v72 = "NO";
              ImageIOLog("H   %s: image size: {%d, %d}  block size: {%d, %d}   rb: %d    subsample: %d    useHW: %s\n", "copyImageBlockSetImp", *(_DWORD *)(a1 + 228), *(_DWORD *)(a1 + 232), *(_DWORD *)(a1 + 292), *(_DWORD *)(a1 + 296), *(_DWORD *)(a1 + 300), *(unsigned __int16 *)(a1 + 316), v72);
            }
            if (!*(_BYTE *)(a1 + 496))
            {
LABEL_127:
              v76 = *(unsigned int *)(a1 + 112);
              if (v76 < *(_DWORD *)(a1 + 116))
              {
                v71 = 0;
                v108 = -8 * v66;
                v77 = (CGRect *)MEMORY[0x1E0C9D628];
                while (1)
                {
                  v78 = *v110;
                  if (*v110)
                    *(_DWORD *)(a1 + 296) = v78;
                  else
                    v78 = *(_DWORD *)(a1 + 296);
                  *(_DWORD *)(a1 + 288) = v78 * v76;
                  applejpeg_decode_clear_options();
                  v79 = applejpeg_decode_set_option_outformat();
                  HIDWORD(v120) = v79;
                  if (v79)
                    _cg_jpeg_mem_term("copyImageBlockSetImp", 3147, "    applejpeg_decode_set_option_outformat: err = %d\n", v79);
                  v80 = applejpeg_decode_set_option_outsize();
                  HIDWORD(v120) = v80;
                  if (v80)
                    _cg_jpeg_mem_term("copyImageBlockSetImp", 3160, "    applejpeg_decode_set_option_outsize err = %d\n", v80);
                  v136[0] = *(unsigned int *)(a1 + 300);
                  v136[1] = v136[0];
                  v136[2] = v136[0];
                  v136[3] = v136[0];
                  v81 = applejpeg_decode_set_option_stride();
                  HIDWORD(v120) = v81;
                  if (v81)
                    v82 = _cg_jpeg_mem_term("copyImageBlockSetImp", 3168, "    applejpeg_decode_set_option_stride err = %d\n", v81);
                  v82.n128_u32[0] = *(_DWORD *)(a1 + 284);
                  x = (double)v82.n128_u64[0];
                  v82.n128_u32[0] = *(_DWORD *)(a1 + 288);
                  y = (double)v82.n128_u64[0];
                  v82.n128_u32[0] = *(_DWORD *)(a1 + 292);
                  width = (double)v82.n128_u64[0];
                  v86 = *(_DWORD *)(a1 + 296);
                  height = y + (double)v86 <= v23 ? (double)v86 : v23 - y;
                  if (*(_DWORD *)(a1 + 104) <= 1u && v86 == *(_DWORD *)(a1 + 264))
                  {
                    if (*(unsigned __int16 *)(a1 + 316) <= 1u)
                    {
                      v88 = applejpeg_decode_set_option_outsize();
                      HIDWORD(v120) = v88;
                      if (v88)
                        _cg_jpeg_mem_term("copyImageBlockSetImp", 3204, "    applejpeg_decode_set_option_outsize err = %d\n", v88);
                    }
                  }
                  else
                  {
                    v89 = applejpeg_decode_set_option_crop();
                    HIDWORD(v120) = v89;
                    if (v89)
                      _cg_jpeg_mem_term("copyImageBlockSetImp", 3195, "    applejpeg_decode_set_option_crop err = %d\n", v89);
                  }
                  if (*(_BYTE *)(a1 + 341))
                    AppleJPEGReadPlugin::create_or_restoreIndexTable(a1);
                  if (*(char *)(a1 + 677) != -1)
                    applejpeg_decode_set_option_force_app14();
                  applejpeg_decode_set_option_error_fill();
                  v90 = applejpeg_decode_set_option_mosquito_spray();
                  HIDWORD(v120) = v90;
                  if (v90)
                    _cg_jpeg_mem_term("copyImageBlockSetImp", 3249, "    applejpeg_decode_set_option_mosquito_spray err = %d\n", v90);
                  v91 = applejpeg_decode_set_option_multithread();
                  HIDWORD(v120) = v91;
                  if (v91)
                    _cg_jpeg_mem_term("copyImageBlockSetImp", 3256, "    applejpeg_decode_set_option_multithread err = %d\n", v91);
                  output_dimensions = (AppleJPEGReadPlugin *)applejpeg_decode_get_output_dimensions();
                  v93 = (int)output_dimensions;
                  HIDWORD(v120) = (_DWORD)output_dimensions;
                  if ((_DWORD)output_dimensions)
                    break;
                  applejpeg_decode_get_output_buffer_size();
                  v94 = *(unsigned int *)(a1 + 300);
                  if (v121 != v94)
                  {
                    _cg_jpeg_mem_term("copyImageBlockSetImp", 3274, "*** ERROR: get_output_buffer_size rb=%d  blockGeo.rb=%d\n", v121, v94);
                    v94 = *(unsigned int *)(a1 + 300);
                  }
                  v95 = v122;
                  v96 = v94 * v119;
                  if (v122 < v96)
                  {
                    v122 = v96;
                    v95 = v96;
                  }
                  if ((gIIODebugFlags & 0x30000) != 0)
                  {
                    ImageIOLog("    %s:%d: applejpeg_decode_get_output_buffer_size:%ld rowB:%ld size:%ldx%ld\n", "copyImageBlockSetImp", 3279, v95, v121, (int)v120, v119);
                    v95 = v122;
                  }
                  v97 = (void *)_ImageIO_Malloc(v95, *(_QWORD *)(a1 + 384), &v135, (uint64_t)kImageMalloc_APPLEJPEG_Data[0], *(_DWORD *)(a1 + 432), 0, 0);
                  if (!v97)
                    goto LABEL_201;
                  if ((gIIODebugFlags & 0x30000) != 0)
                    ImageIOLog("    %s:%d: Got outbuf\n", "copyImageBlockSetImp", 3292);
                  v133 = v97;
                  v134 = v122;
                  v98 = applejpeg_decode_image_all();
                  HIDWORD(v120) = v98;
                  if (v98)
                  {
                    if ((gIIODebugFlags & 0x30000) != 0)
                    {
                      ImageIOLog("    %s:%d: Decode error %d\n", "copyImageBlockSetImp", 3299, v98);
                      v98 = HIDWORD(v120);
                    }
                    if (v98 == -2)
                    {
                      *(_BYTE *)(a1 + 343) = 0;
                      v71 = 5;
                    }
                    else
                    {
                      if (v98 != 9 && v98 != -1)
                        goto LABEL_201;
                      ++v71;
                      *(_BYTE *)(a1 + 343) = 0;
                      v99 = *(_QWORD *)(a1 + 16);
                      if (v99)
                        IIOImagePlus::setStatus(v99, (CGImageSourceStatus)-6);
                    }
                  }
                  if (!*(_BYTE *)(a1 + 341) && v71)
                  {
                    *(_BYTE *)(a1 + 343) = 0;
                    v100 = *(_QWORD *)(a1 + 16);
                    if (v100)
                      IIOImagePlus::setStatus(v100, (CGImageSourceStatus)-6);
                    v71 = 5;
                  }
                  if ((gIIODebugFlags & 0x30000) != 0)
                    ImageIOLog("    %s:%d: Decoded image\n", "copyImageBlockSetImp", 3328);
                  if (appleJPEGTintCheck != -1)
                    dispatch_once(&appleJPEGTintCheck, &__block_literal_global_32);
                  v138.origin.x = x;
                  v138.origin.y = y;
                  v138.size.width = width;
                  v138.size.height = height;
                  *(_QWORD *)(*(_QWORD *)(a1 + 96) + v108 + 8 * v76) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, v97, v135, v138, *(unsigned int *)(a1 + 300), *(unsigned __int8 *)(a1 + 343));
                  if (!CGRectEqualToRect(*(CGRect *)(a1 + 120), *v77))
                  {
                    v140.origin.x = x;
                    v140.origin.y = y;
                    v140.size.width = width;
                    v140.size.height = height;
                    v139 = CGRectUnion(*(CGRect *)(a1 + 120), v140);
                    x = v139.origin.x;
                    y = v139.origin.y;
                    width = v139.size.width;
                    height = v139.size.height;
                  }
                  *(double *)(a1 + 120) = x;
                  *(double *)(a1 + 128) = y;
                  *(double *)(a1 + 136) = width;
                  *(double *)(a1 + 144) = height;
                  ++v76;
                  v101 = v112;
                  if (v76 >= *(unsigned int *)(a1 + 116) || v71 >= 5)
                    goto LABEL_190;
                }
                v104 = AppleJPEGReadPlugin::appleJPEGErrorString(output_dimensions, (int)output_dimensions);
                _cg_jpeg_mem_term("copyImageBlockSetImp", 3264, "*** ERROR: applejpeg_decode_get_output_dimensions - error %d (%s)\n", v93, v104);
                if ((gIIODebugFlags & 0x30000) != 0)
                  ImageIOLog("    %s:%d: Options error %d\n", "copyImageBlockSetImp", 3265, HIDWORD(v120));
LABEL_201:
                ImageBlockSetWithHardwareDecode = 0;
                v34 = v112;
LABEL_202:
                if (!a3)
                  goto LABEL_204;
                goto LABEL_203;
              }
              v71 = 0;
              v101 = v112;
LABEL_190:
              v34 = v101;
              goto LABEL_191;
            }
            ImageBlockSetWithHardwareDecode = AppleJPEGReadPlugin::createImageBlockSetWithHardwareDecode((unsigned __int8 *)a1, a2, (uint64_t)a3, a4, (int *)&v120 + 1);
            v34 = v112;
            if (ImageBlockSetWithHardwareDecode)
              goto LABEL_202;
            v73 = *(unsigned int *)(a1 + 104);
            v74 = *(_QWORD *)(a1 + 96);
            if ((_DWORD)v73)
            {
              if (!a3 && v74 && !HIDWORD(v120))
              {
                ImageBlockSetWithHardwareDecode = 0;
                if ((v32 & 1) == 0)
                  goto LABEL_116;
LABEL_205:
                v105 = v116;
                *(_OWORD *)(a1 + 284) = v115;
                *(_OWORD *)(a1 + 300) = v105;
                *(_WORD *)(a1 + 316) = v113;
                if (!v34)
                  goto LABEL_208;
                goto LABEL_206;
              }
              if (v74)
                goto LABEL_124;
            }
            else
            {
              if (v74)
              {
LABEL_124:
                if ((gIIODebugFlags & 0x1000000000) != 0)
                  ImageIOLog("H   Hardware blockset is NULL, falling back to software decode.  (RB: %d\n", v55);
                *(_BYTE *)(a1 + 680) = 1;
                *(_BYTE *)(a1 + 496) = 0;
                goto LABEL_127;
              }
              v73 = 1;
              *(_DWORD *)(a1 + 104) = 1;
            }
            HIDWORD(v120) = IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, v73);
            goto LABEL_124;
          }
          goto LABEL_209;
        }
        *(_BYTE *)(a1 + 496) = 0;
        if ((gIIODebugFlags & 0x1000000000) != 0)
        {
          PixelSize = CGImageProviderGetPixelSize();
          ImageIOLog("H   Disabling hardware decode, image is too large (%g MB).\n", v60 * v23 * (double)(unint64_t)PixelSize * 0.000000953674316);
        }
        if (v64 != 1)
          goto LABEL_92;
        _cg_jpeg_mem_term("copyImageBlockSetImp", 3042, "Rejecting singleton request - image is too large\n");
LABEL_209:
        v34 = 0;
        ImageBlockSetWithHardwareDecode = 0;
        if (a3)
          goto LABEL_203;
        goto LABEL_204;
      }
    }
    v54 = v35 != 1;
    v55 = *(_DWORD *)(a1 + 300);
    v56 = (*(unsigned __int16 *)(a1 + 240) + 7) >> 3 << (2 * v54);
    v57 = *(_DWORD *)(a1 + 292);
    v58 = v57 * (unint64_t)v56;
    v48 = (v58 & 0xFFFFFFFF00000000) == 0;
    v59 = (v58 + 15) & 0xFFFFFFF0;
    if (!v48)
      v59 = 0;
    if (v55 != v59)
      LogFault("copyImageBlockSetImp", 3012, "🔺 IIO-ERROR: img: {%d x %d}  blockGeoRB: %d   tempRB: %d   unadjRB: %d   subSample: %d\n", v57, *(_DWORD *)(a1 + 296), v55, v59, *(_DWORD *)(a1 + 300), *(unsigned __int16 *)(a1 + 316));
    v32 = 0;
    v60 = v21;
    goto LABEL_73;
  }
  v34 = 0;
  if (a3)
    goto LABEL_203;
LABEL_204:
  if (v32)
    goto LABEL_205;
LABEL_116:
  *(_WORD *)(a1 + 316) = v113;
  if (!v34)
    goto LABEL_208;
LABEL_206:
  v106 = *(const char ***)(a1 + 24);
  if (v106)
    IIOImageReadSession::unmapData(v106);
LABEL_208:
  IIODictionary::~IIODictionary((IIODictionary *)v114);
  return ImageBlockSetWithHardwareDecode;
}

void sub_187E87380(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_list va;

  va_start(va, a14);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOSubsampler::subsample(IIOSubsampler *this, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int *a5)
{
  int v6;
  int v7;
  uint64_t v8;
  __int128 v9;
  vImagePixelCount v10;
  uint64_t v11;
  vImage_Error v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  __int128 v17;
  vImagePixelCount v18;
  uint64_t v19;
  uint64_t v21;
  __int128 v22;
  vImagePixelCount v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  __int128 v27;
  vImagePixelCount v28;
  uint64_t v29;
  uint64_t v30;
  __int128 v31;
  vImagePixelCount v32;
  uint64_t v33;
  uint64_t v34;
  __int128 v35;
  vImagePixelCount v36;
  uint64_t v37;
  vImage_Buffer v38;
  vImage_Buffer v39;

  switch(*((_WORD *)this + 13))
  {
    case 1:
      v6 = *((unsigned __int16 *)this + 12);
      if (v6 == 16)
      {
        if (IIOSubsampler::subsampleGray16(this, a2, a3, a4, a5))
          goto LABEL_32;
      }
      else if (v6 != 8 || IIOSubsampler::subsampleGray8(this, a2, a3, a4, a5))
      {
        goto LABEL_32;
      }
      return 1;
    case 2:
      v7 = *((unsigned __int16 *)this + 12);
      if (v7 == 16)
      {
        v39.data = a2;
        v39.height = a3;
        v21 = *((_QWORD *)this + 1);
        *(_QWORD *)&v22 = v21;
        *((_QWORD *)&v22 + 1) = HIDWORD(v21);
        *(_OWORD *)&v39.width = v22;
        v23 = *a5;
        v38.data = a4;
        v38.height = v23;
        v24 = *((_QWORD *)this + 4);
        *(_QWORD *)&v22 = v24;
        *((_QWORD *)&v22 + 1) = HIDWORD(v24);
        *(_OWORD *)&v38.width = v22;
        v25 = 2;
        goto LABEL_31;
      }
      if (v7 != 8)
        goto LABEL_32;
      v39.data = a2;
      v39.height = a3;
      v8 = *((_QWORD *)this + 1);
      *(_QWORD *)&v9 = v8;
      *((_QWORD *)&v9 + 1) = HIDWORD(v8);
      *(_OWORD *)&v39.width = v9;
      v10 = *a5;
      v38.data = a4;
      v38.height = v10;
      v11 = *((_QWORD *)this + 4);
      *(_QWORD *)&v9 = v11;
      *((_QWORD *)&v9 + 1) = HIDWORD(v11);
      *(_OWORD *)&v38.width = v9;
      v12 = 2;
      goto LABEL_22;
    case 3:
      v13 = *((unsigned __int16 *)this + 12);
      if (v13 == 32)
      {
        v39.data = a2;
        v39.height = a3;
        v30 = *((_QWORD *)this + 1);
        *(_QWORD *)&v31 = v30;
        *((_QWORD *)&v31 + 1) = HIDWORD(v30);
        *(_OWORD *)&v39.width = v31;
        v32 = *a5;
        v38.data = a4;
        v38.height = v32;
        v33 = *((_QWORD *)this + 4);
        *(_QWORD *)&v31 = v33;
        *((_QWORD *)&v31 + 1) = HIDWORD(v33);
        *(_OWORD *)&v38.width = v31;
        if (IIOSubsampler::scale32bitChannels(this, &v39, &v38, 3))
          goto LABEL_32;
        return 1;
      }
      if (v13 == 16)
      {
        v39.data = a2;
        v39.height = a3;
        v34 = *((_QWORD *)this + 1);
        *(_QWORD *)&v35 = v34;
        *((_QWORD *)&v35 + 1) = HIDWORD(v34);
        *(_OWORD *)&v39.width = v35;
        v36 = *a5;
        v38.data = a4;
        v38.height = v36;
        v37 = *((_QWORD *)this + 4);
        *(_QWORD *)&v35 = v37;
        *((_QWORD *)&v35 + 1) = HIDWORD(v37);
        *(_OWORD *)&v38.width = v35;
        v25 = 3;
        goto LABEL_31;
      }
      if (v13 == 8 && !IIOSubsampler::subsampleRGB888(this, a2, a3, a4, a5))
        return 1;
      goto LABEL_32;
    case 4:
      v14 = *((unsigned __int16 *)this + 12);
      if (v14 == 32)
      {
        if (IIOSubsampler::subsampleRGBA32(this, a2, a3, a4, a5))
          goto LABEL_32;
      }
      else if (v14 == 16)
      {
        if (IIOSubsampler::subsampleRGBA16(this, a2, a3, a4, a5))
          goto LABEL_32;
      }
      else if (v14 != 8 || IIOSubsampler::subsampleRGBA8888(this, a2, a3, a4, a5))
      {
        goto LABEL_32;
      }
      return 1;
    case 5:
      v15 = *((unsigned __int16 *)this + 12);
      if (v15 == 16)
      {
        v39.data = a2;
        v39.height = a3;
        v26 = *((_QWORD *)this + 1);
        *(_QWORD *)&v27 = v26;
        *((_QWORD *)&v27 + 1) = HIDWORD(v26);
        *(_OWORD *)&v39.width = v27;
        v28 = *a5;
        v38.data = a4;
        v38.height = v28;
        v29 = *((_QWORD *)this + 4);
        *(_QWORD *)&v27 = v29;
        *((_QWORD *)&v27 + 1) = HIDWORD(v29);
        *(_OWORD *)&v38.width = v27;
        v25 = 5;
LABEL_31:
        if (!IIOSubsampler::scale16bitChannels(this, &v39, &v38, v25))
          return 1;
      }
      else if (v15 == 8)
      {
        v39.data = a2;
        v39.height = a3;
        v16 = *((_QWORD *)this + 1);
        *(_QWORD *)&v17 = v16;
        *((_QWORD *)&v17 + 1) = HIDWORD(v16);
        *(_OWORD *)&v39.width = v17;
        v18 = *a5;
        v38.data = a4;
        v38.height = v18;
        v19 = *((_QWORD *)this + 4);
        *(_QWORD *)&v17 = v19;
        *((_QWORD *)&v17 + 1) = HIDWORD(v19);
        *(_OWORD *)&v38.width = v17;
        v12 = 5;
LABEL_22:
        if (!IIOSubsampler::scale8bitChannels(this, &v39, &v38, v12))
          return 1;
      }
LABEL_32:
      if (!*((_BYTE *)this + 41))
      {
        *((_BYTE *)this + 41) = 1;
        _cg_jpeg_mem_term("subsample", 745, "*** ERROR subsample #channels: %d    bitsPerComponent: %d not handled\n", *((unsigned __int16 *)this + 13), *((unsigned __int16 *)this + 12));
      }
      return 0;
    default:
      goto LABEL_32;
  }
}

vImage_Error IIOSubsampler::subsampleRGBA8888(IIOSubsampler *this, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int *a5)
{
  size_t v6;
  vImagePixelCount v7;
  uint64_t v8;
  __int128 v9;
  int v10;
  void *v12;
  void *v13;
  vImage_Error v14;
  vImage_Error v15;
  vImage_Error v16;
  vImage_Error v17;
  int v18;
  vImage_Error v19;
  vImage_Error v20;
  uint8_t permuteMap[4];
  vImage_Buffer dest;
  vImage_Buffer v24;
  vImage_Buffer src;

  src.data = a2;
  src.height = a3;
  v6 = *((unsigned int *)this + 3);
  src.width = *((unsigned int *)this + 2);
  src.rowBytes = v6;
  v7 = *a5;
  v24.data = a4;
  v24.height = v7;
  v8 = *((_QWORD *)this + 4);
  *(_QWORD *)&v9 = v8;
  *((_QWORD *)&v9 + 1) = HIDWORD(v8);
  *(_OWORD *)&v24.width = v9;
  dest = src;
  v10 = *((_DWORD *)this + 5);
  if ((v10 - 1) > 1)
  {
    v13 = 0;
  }
  else
  {
    v12 = malloc_type_malloc(v6 * a3, 0x1FAB4A1BuLL);
    if (!v12)
    {
      LogError("subsampleRGBA8888", 430, "*** ERROR: failed to allocte temp (%d bytes)\n", *((_DWORD *)this + 3) * a3);
      return 0;
    }
    v13 = v12;
    dest.data = v12;
    v10 = *((_DWORD *)this + 5);
  }
  if (v10 == 1)
  {
    v16 = vImageUnpremultiplyData_RGBA8888(&src, &dest, 0x10u);
    if (v16)
    {
      v15 = v16;
      IIO_vImageErrorString(v16);
      LogError("subsampleRGBA8888", 442, "*** ERROR: vImageUnpremultiplyData_RGBA8888 err = %ld (%s)\n");
      goto LABEL_25;
    }
  }
  else if (v10 == 2)
  {
    v14 = vImageUnpremultiplyData_ARGB8888(&src, &dest, 0x10u);
    if (v14)
    {
      v15 = v14;
      IIO_vImageErrorString(v14);
      LogError("subsampleRGBA8888", 437, "*** ERROR: vImageUnpremultiplyData_ARGB8888 err = %ld (%s)\n");
      goto LABEL_25;
    }
  }
  v17 = vImageScale_ARGB8888(&dest, &v24, 0, 0x20u);
  if (v17)
  {
    v15 = v17;
    IIO_vImageErrorString(v17);
    LogError("subsampleRGBA8888", 446, "*** ERROR: vImageScale_ARGB8888 err = %ld (%s)\n");
    goto LABEL_25;
  }
  v18 = *((_DWORD *)this + 5);
  if (v18 == 1)
  {
    v20 = vImagePremultiplyData_RGBA8888(&v24, &v24, 0x10u);
    if (!v20)
      goto LABEL_16;
    v15 = v20;
    IIO_vImageErrorString(v20);
    LogError("subsampleRGBA8888", 456, "*** ERROR: vImagePremultiplyData_RGBA8888 err = %ld (%s)\n");
LABEL_25:
    if (!v13)
      return v15;
    goto LABEL_19;
  }
  if (v18 == 2)
  {
    v19 = vImagePremultiplyData_ARGB8888(&v24, &v24, 0x10u);
    if (v19)
    {
      v15 = v19;
      IIO_vImageErrorString(v19);
      LogError("subsampleRGBA8888", 451, "*** ERROR: vImagePremultiplyData_ARGB8888 err = %ld (%s)\n");
      goto LABEL_25;
    }
  }
LABEL_16:
  if ((*((_WORD *)this + 15) & 2) != 0)
  {
    *(_DWORD *)permuteMap = 50331906;
    vImagePermuteChannels_ARGB8888(&v24, &v24, permuteMap, 0x10u);
  }
  v15 = 0;
  if (v13)
LABEL_19:
    free(v13);
  return v15;
}

__n128 AppleJPEGReadPlugin::save_index_table(AppleJPEGReadPlugin *this)
{
  size_t ra_table_sz;
  __n128 result;
  AppleJPEGReadPlugin *v4;
  int v5;
  const char *v6;

  if (!*((_QWORD *)this + 79))
  {
    ra_table_sz = (int)applejpeg_decode_get_ra_table_sz();
    *((_QWORD *)this + 80) = (int)ra_table_sz;
    if ((_DWORD)ra_table_sz)
    {
      *((_QWORD *)this + 79) = malloc_type_malloc(ra_table_sz, 0x3B70D5EDuLL);
      v4 = (AppleJPEGReadPlugin *)applejpeg_decode_dump_ra_table();
      if ((_DWORD)v4)
      {
        v5 = (int)v4;
        v6 = AppleJPEGReadPlugin::appleJPEGErrorString(v4, (int)v4);
        return _cg_jpeg_mem_term("save_index_table", 273, "err = %d '%s'\n", v5, v6);
      }
    }
  }
  return result;
}

uint64_t _cg_png_set_swap(uint64_t result)
{
  if (result)
  {
    if (*(_BYTE *)(result + 392) == 16)
      *(_DWORD *)(result + 88) |= 0x10u;
  }
  return result;
}

__n128 AppleJPEGReadPlugin::create_or_restoreIndexTable(uint64_t a1)
{
  AppleJPEGReadPlugin *v1;
  __n128 result;
  AppleJPEGReadPlugin *v3;

  if (*(_QWORD *)(a1 + 632) && *(_QWORD *)(a1 + 640))
  {
    v1 = (AppleJPEGReadPlugin *)applejpeg_decode_set_ra_table();
    if ((_DWORD)v1)
    {
      AppleJPEGReadPlugin::appleJPEGErrorString(v1, (int)v1);
      return _cg_jpeg_mem_term("create_or_restoreIndexTable", 248, "    applejpeg_decode_set_ra_table err = %d '%s'\n");
    }
  }
  else
  {
    v3 = (AppleJPEGReadPlugin *)applejpeg_decode_set_option_buildindex();
    if ((_DWORD)v3)
    {
      AppleJPEGReadPlugin::appleJPEGErrorString(v3, (int)v3);
      return _cg_jpeg_mem_term("create_or_restoreIndexTable", 255, "    applejpeg_decode_set_option_buildindex err = %d '%s'\n");
    }
  }
  return result;
}

CGFloat IIOReadPlugin::optInForBandedDecoding(IIOReadPlugin *this, CGRect a2)
{
  unsigned int v2;
  unint64_t height;
  unint64_t v4;
  BOOL v5;
  double v6;
  unsigned int v7;
  unint64_t v8;
  unint64_t v9;
  CGFloat v10;
  unint64_t v11;
  CGFloat v12;

  if (*((_BYTE *)this + 408) != 1 && (*((_DWORD *)this + 59) * *((_DWORD *)this + 58)) >> 24)
  {
    *((_DWORD *)this + 92) = a2.size.width;
    v2 = *((_DWORD *)this + 75);
    if (a2.size.height * (double)v2 >= 16777216.0)
    {
      v5 = v2 >= 0x1000001;
      height = (0x1000000 / v2 + 7) & 0x3FFFFF8;
      v6 = fmin(a2.size.height, 32.0);
      if (v5)
        height = (unint64_t)v6;
      if (!height)
        goto LABEL_12;
      v4 = *((_QWORD *)this + 45);
      if (v4 < 2)
      {
        v8 = (unint64_t)(a2.size.height / (double)height);
        if (a2.size.height > (double)(height * v8))
        {
          v9 = v8 + 1;
          v10 = a2.size.height / (double)v9;
          height = (unint64_t)v10 - 1;
          v11 = (unint64_t)v10 * v9;
          do
          {
            v12 = (double)v11;
            LODWORD(height) = height + 1;
            v11 += v9;
          }
          while (a2.size.height > v12);
        }
        goto LABEL_12;
      }
    }
    else
    {
      height = (unint64_t)a2.size.height;
      v4 = *((_QWORD *)this + 45);
      if (v4 < 2)
        goto LABEL_12;
    }
    height = (v4 + height - 1) / v4 * v4;
LABEL_12:
    *((_DWORD *)this + 93) = height;
    *((_DWORD *)this + 74) = height;
    v7 = (a2.origin.y / (double)height);
    a2.origin.x = (a2.origin.y
                 + a2.size.height
                 - (double)(height * v7)
                 + (double)(height - 1))
                / (double)height;
    *((_DWORD *)this + 26) = a2.origin.x;
    *((_DWORD *)this + 28) = v7;
    *((_DWORD *)this + 29) = a2.origin.x + v7;
  }
  return a2.origin.x;
}

void *ImageIO_FileIsNotReadable(unsigned __int8 *a1, size_t a2)
{
  _BYTE __b[4];
  size_t __n;
  const void *v5;

  v5 = a1;
  __n = a2;
  memset(__b, 0, sizeof(__b));
  return memcpy(__b, v5, __n);
}

uint64_t IIOImagePlus::readPluginType(IIOImagePlus *this)
{
  return *((unsigned int *)this + 44);
}

void IIOSubsampler::IIOSubsampler(IIOSubsampler *this, int a2, int a3, int a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8, unsigned int a9, unsigned int a10)
{
  *(_QWORD *)this = &off_1E1BACF08;
  *((_DWORD *)this + 2) = a2;
  *((_DWORD *)this + 3) = a3;
  *((_DWORD *)this + 4) = a4;
  *((_DWORD *)this + 5) = a4 & 0x1F;
  *((_BYTE *)this + 40) = BYTE1(a4) & 1;
  *((_WORD *)this + 12) = a5;
  *((_WORD *)this + 13) = a6;
  *((_WORD *)this + 14) = a7;
  *((_WORD *)this + 15) = a8;
  *((_DWORD *)this + 8) = a9;
  *((_DWORD *)this + 9) = a10;
  *((_BYTE *)this + 41) = 0;
}

uint64_t PNGReadPlugin::copyImageBlockSetInterlaced(uint64_t a1)
{
  double v1;
  uint64_t v3;
  double v4;
  double v5;
  double v6;
  unint64_t v7;
  IIOImageRead **v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CGRect *v12;
  uint64_t v13;
  double v14;
  double v15;
  double v16;
  size_t v17;
  unsigned __int8 *v18;
  unsigned __int8 *v19;
  uint64_t v20;
  IIOImageRead *v21;
  uint64_t v22;
  _BOOL4 v23;
  BOOL v24;
  uint64_t v25;
  double v26;
  double v27;
  double v28;
  int v29;
  uint64_t v30;
  const char **v31;
  _BOOL4 v33;
  __int128 v34;
  uint64_t v35;
  _QWORD v36[8];
  __int128 v37;
  uint64_t v38;
  unint64_t v39;
  void **v40[2];
  CGRect v41;
  CGRect v42;

  v39 = 0;
  CGImageProviderSetProperty();
  v3 = *(unsigned int *)(a1 + 112);
  IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, *(unsigned int *)(a1 + 104));
  if (IIOReadPlugin::getCachedBlocks((IIOReadPlugin *)a1, v4, v5, v6))
  {
    v8 = *(IIOImageRead ***)(a1 + 24);
    if (v8)
      v33 = IIOImageReadSession::mapData(v8);
    else
      v33 = 0;
    v9 = *(unsigned int *)(a1 + 112);
    if (v9 < *(_DWORD *)(a1 + 116))
    {
      v10 = -8 * v3;
      v11 = -v3;
      v12 = (CGRect *)MEMORY[0x1E0C9D628];
      do
      {
        if (*(_QWORD *)(*(_QWORD *)(a1 + 96) + v10 + 8 * v9))
          _cg_jpeg_mem_term("copyImageBlockSetInterlaced", 3299, "*** _blockArray[%d] was cached - and already allocated\n", v11 + v9);
        v13 = *(unsigned int *)(a1 + 296);
        v14 = (double)(v9 * v13);
        LODWORD(v1) = *(_DWORD *)(a1 + 292);
        LODWORD(v7) = *(_DWORD *)(a1 + 232);
        v15 = (double)v7;
        v16 = (double)v13 + v14 <= v15 ? (double)v13 : v15 - v14;
        v17 = *(unsigned int *)(a1 + 300) * (unint64_t)v13;
        v18 = (unsigned __int8 *)_ImageIO_Malloc(v17, *(_QWORD *)(a1 + 384), &v39, (uint64_t)kImageMalloc_PNG_Data[0], *(_DWORD *)(a1 + 432), 0, 0);
        if (!v18)
          break;
        v19 = v18;
        v1 = (double)*(unint64_t *)&v1;
        bzero(v18, v17);
        v20 = *(unsigned int *)(a1 + 300);
        v36[0] = v9;
        v36[1] = 0;
        *(double *)&v36[2] = v14;
        *(double *)&v36[3] = v1;
        *(double *)&v36[4] = v16;
        v36[5] = v19;
        v36[6] = v20;
        v36[7] = v17;
        v37 = 0u;
        v38 = 0;
        v35 = 0;
        v34 = 0u;
        std::vector<IIODecodeFrameParams>::vector(&v34, 1uLL, (uint64_t)v36);
        v21 = (IIOImageRead *)IIO_Reader::testHeaderSize(*(IIO_Reader **)(a1 + 24));
        PNGReadPlugin::DecodeUncomposedFrames(v21, 0, a1 + 184, (_BYTE *)(a1 + 440), (uint64_t **)&v34);
        v22 = *(_QWORD *)(v34 + 64);
        if (!v22)
        {
          v29 = *(_DWORD *)(a1 + 104);
          if (v29)
            *(_DWORD *)(a1 + 104) = v29 - 1;
          _ImageIO_Free((unint64_t)v19, v39);
          v30 = *(_QWORD *)(a1 + 16);
          if (v30)
            IIOImagePlus::setStatus(v30, (CGImageSourceStatus)-6);
          v40[0] = (void **)&v34;
          std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100](v40);
          IIODecodeFrameParams::~IIODecodeFrameParams((IIODecodeFrameParams *)v36);
          break;
        }
        PNGReadPlugin::postProcess((PNGReadPlugin *)a1, v19);
        if (*(_BYTE *)(a1 + 343))
          v23 = v22 >= *(unsigned int *)(a1 + 232);
        else
          v23 = 0;
        v41.origin.x = 0.0;
        v41.origin.y = v14;
        v41.size.width = v1;
        v41.size.height = v16;
        *(_QWORD *)(*(_QWORD *)(a1 + 96) + v10 + 8 * v9) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, v19, v39, v41, *(unsigned int *)(a1 + 300), v23);
        v24 = CGRectEqualToRect(*(CGRect *)(a1 + 120), *v12);
        v25 = 0;
        if (!v24)
        {
          v42.origin.x = 0.0;
          v42.origin.y = v14;
          v42.size.width = v1;
          v42.size.height = v16;
          *(CGRect *)&v25 = CGRectUnion(*(CGRect *)(a1 + 120), v42);
          v14 = v26;
          v1 = v27;
          v16 = v28;
        }
        *(_QWORD *)(a1 + 120) = v25;
        *(double *)(a1 + 128) = v14;
        *(double *)(a1 + 136) = v1;
        *(double *)(a1 + 144) = v16;
        v40[0] = (void **)&v34;
        std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100](v40);
        IIODecodeFrameParams::~IIODecodeFrameParams((IIODecodeFrameParams *)v36);
        ++v9;
      }
      while (v9 < *(unsigned int *)(a1 + 116));
    }
    if (v33)
    {
      v31 = *(const char ***)(a1 + 24);
      if (v31)
        IIOImageReadSession::unmapData(v31);
    }
  }
  if (*(_BYTE *)(a1 + 177))
  {
    ImageIOLog("<<< copyImageBlockSetInterlaced - PNG  [%p]\n", 0);
    ImageIOLog("===================================================================================================\n");
  }
  return 0;
}

void sub_187E87F94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v4;
  uint64_t v6;
  va_list va;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  *(_QWORD *)(v4 - 128) = va;
  std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100]((void ***)(v4 - 128));
  IIODecodeFrameParams::~IIODecodeFrameParams((IIODecodeFrameParams *)va1);
  _Unwind_Resume(a1);
}

uint64_t ByteCountLooksBad(uint64_t a1)
{
  unint64_t v2;
  uint64_t result;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;

  v2 = _TIFFGetStrileOffsetOrByteCountValue(a1, 0);
  result = _TIFFGetStrileOffsetOrByteCountValue(a1, 0);
  if (result)
  {
    if (!v2)
      return 1;
    if (*(_WORD *)(a1 + 120) != 1)
      return 0;
    v4 = result;
    v5 = (*(uint64_t (**)(_QWORD))(a1 + 1240))(*(_QWORD *)(a1 + 1200));
    if (v5 >= v4 && v2 > v5 - v4)
      return 1;
    if (*(_DWORD *)(a1 + 12))
      return 0;
    v13 = _cg_TIFFScanlineSize64(a1, v6, v7, v8, v9, v10, v11, v12);
    v14 = *(unsigned int *)(a1 + 92);
    if (!(_DWORD)v14)
      return 0;
    v15 = v13;
    v16 = (*(unsigned int *)(a1 + 92) * (unsigned __int128)v13) >> 64;
    result = 1;
    if (!v16 && v2 >= v15 * v14)
      return 0;
  }
  return result;
}

uint64_t IIO_Reader_ATX::getImageCount(IIO_Reader_ATX *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  IIOScanner *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[7];
  _QWORD v12[3];
  char v13;

  v7 = (IIOScanner *)operator new();
  IIOScanner::IIOScanner(v7, a2);
  if (a5)
    *a5 = 0;
  v8 = *((_QWORD *)v7 + 1);
  if (v8 && *((_QWORD *)v7 + 2) >= 0x5DuLL)
  {
    IIOScanner::validateBuffer((unsigned __int8 **)v7, "Checking ATX buffer");
    GlobalHEIFInfo::setShouldExposeMultiFrameContents((uint64_t)v7, *(_DWORD *)(v8 + 4) == 169478669);
    v12[0] = 0;
    v12[1] = v12;
    v12[2] = 0x2000000000;
    v13 = 0;
    v11[0] = MEMORY[0x1E0C809B0];
    v11[1] = 0x40000000;
    v11[2] = ___ZN14IIO_Reader_ATX13getImageCountEP19IIOImageReadSessionP13IIODictionaryP19CGImageSourceStatusPj_block_invoke;
    v11[3] = &unk_1E1BBD3A8;
    v11[4] = v12;
    v11[5] = a5;
    v11[6] = v7;
    v9 = IterateChunks(v7, (uint64_t)v11);
    _Block_object_dispose(v12, 8);
  }
  else
  {
    v9 = 4294967246;
  }
  (*(void (**)(IIOScanner *))(*(_QWORD *)v7 + 8))(v7);
  return v9;
}

void sub_187E881B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ReadMetadataRtnl(uint64_t a1, IIOImageReadSession *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, int a7, uint64_t a8, char a9)
{
  unsigned int *v16;
  unsigned int v17;
  unint64_t BytesAtOffset;
  unsigned int v19;
  unint64_t v20;
  BOOL v21;
  const __CFAllocator **v22;
  CFMutableArrayRef Mutable;
  __CFArray *v24;
  const void *v25;
  int v26;
  unint64_t v27;
  const __CFAllocator *v28;
  unsigned int *v29;
  CFStringRef v30;
  unint64_t v31;
  const __CFString *v32;
  CGImageMetadataType v33;
  CGImageMetadataTagRef v34;
  CGImageMetadataType type;
  const __CFString *v36;
  uint64_t v37;
  const __CFString *prefix;

  v16 = (unsigned int *)malloc_type_calloc(*(unsigned int *)(a8 + 4), 8uLL, 0x1BB58547uLL);
  v17 = *(_DWORD *)(a8 + 8);
  if (a9)
  {
    v17 = bswap32(v17);
    *(_DWORD *)(a8 + 8) = v17;
  }
  BytesAtOffset = IIOImageReadSession::getBytesAtOffset(a2, v16, v17, (8 * *(_DWORD *)(a8 + 4)));
  v19 = *(_DWORD *)(a8 + 4);
  if (BytesAtOffset == 8 * v19)
  {
    if ((v19 & 0x7FFFFFFF) != 0 && a9)
    {
      v20 = 0;
      do
      {
        v16[v20] = bswap32(v16[v20]);
        ++v20;
        v19 = *(_DWORD *)(a8 + 4);
      }
      while (v20 < 2 * v19);
    }
    v21 = v19 <= 1 && a7 == 0;
    v22 = (const __CFAllocator **)MEMORY[0x1E0C9AE00];
    if (v21)
    {
      if (!v19)
        goto LABEL_30;
      v37 = a1;
      prefix = a4;
      v36 = a5;
      v25 = a6;
      v24 = 0;
      v26 = 1;
    }
    else
    {
      Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
      v24 = Mutable;
      if (!*(_DWORD *)(a8 + 4))
      {
        if (!Mutable)
          goto LABEL_30;
        v33 = kCGImageMetadataTypeArrayOrdered;
        v32 = a3;
        goto LABEL_27;
      }
      v37 = a1;
      prefix = a4;
      v36 = a5;
      v25 = a6;
      v26 = 3;
    }
    type = v26;
    v27 = 0;
    v28 = *v22;
    v29 = v16 + 1;
    do
    {
      v30 = CFStringCreateWithFormat(v28, 0, CFSTR("%u/%u"), *(v29 - 1), *v29);
      if ((a7 & 1) != 0 || (v31 = *(unsigned int *)(a8 + 4), v31 >= 2))
      {
        CFArrayAppendValue(v24, v30);
        CFRelease(v30);
        v30 = 0;
        v31 = *(unsigned int *)(a8 + 4);
      }
      v29 += 2;
      ++v27;
    }
    while (v27 < v31);
    a6 = v25;
    a4 = prefix;
    if (!v24)
    {
      a1 = v37;
      if (!v30)
        goto LABEL_30;
      v34 = CGImageMetadataTagCreate(a3, prefix, v36, type, v30);
      goto LABEL_28;
    }
    a5 = v36;
    a1 = v37;
    v32 = a3;
    v33 = type;
LABEL_27:
    v34 = CGImageMetadataTagCreate(v32, a4, a5, v33, v24);
    v30 = (CFStringRef)v24;
LABEL_28:
    CFRelease(v30);
    if (v34)
    {
      CGImageMetadataAddTagWithKey(a1, a6, v34);
      CFRelease(v34);
    }
  }
LABEL_30:
  free(v16);
}

AppleJPEGReadPlugin *AppleJPEGReadPlugin::appleJPEGDecodeOpen(AppleJPEGReadPlugin *this)
{
  IIOImageRead *Size;
  AppleJPEGReadPlugin *v3;
  AppleJPEGReadPlugin *v4;
  const char *v5;

  Size = (IIOImageRead *)*((_QWORD *)this + 58);
  if (!Size)
    Size = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
  *((_QWORD *)this + 73) = Size;
  *((_QWORD *)this + 67) = iioReadCallback;
  *((_QWORD *)this + 70) = iioRewindCallback;
  *((_QWORD *)this + 69) = iioSkipCallback;
  *((_QWORD *)this + 71) = (char *)this + 648;
  v3 = (AppleJPEGReadPlugin *)applejpeg_decode_open_file();
  v4 = v3;
  if ((_DWORD)v3)
  {
    v5 = AppleJPEGReadPlugin::appleJPEGErrorString(v3, (int)v3);
    _cg_jpeg_mem_term("appleJPEGDecodeOpen", 1317, "*** ERROR: applejpeg_decode_open_file returned: %d '%s'\n", (_DWORD)v4, v5);
  }
  return v4;
}

uint64_t IIONumber::uint32Num(IIONumber *this)
{
  const __CFNumber *v2;
  double v4;
  uint64_t v5;
  unsigned int valuePtr;

  valuePtr = 0;
  v2 = (const __CFNumber *)*((_QWORD *)this + 2);
  if (!v2)
    goto LABEL_9;
  if (CFNumberGetValue(v2, kCFNumberSInt32Type, &valuePtr))
    return valuePtr;
  v5 = 0;
  if (CFNumberGetValue(*((CFNumberRef *)this + 2), kCFNumberLongType, &v5))
    return v5;
  if (CFNumberIsFloatType(*((CFNumberRef *)this + 2)))
  {
    v4 = 0.0;
    if (CFNumberGetValue(*((CFNumberRef *)this + 2), kCFNumberDoubleType, &v4))
      return v4;
  }
LABEL_9:
  LogError("uint32Num", 350, "CFNumberGetValue/uint32_t failed\n");
  return 0;
}

void IIOScanner::IIOScanner(IIOScanner *this, IIOImageReadSession *a2)
{
  IIOImageRead *Size;

  *(_QWORD *)this = &off_1E1BAB4D8;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = a2;
  if (a2)
  {
    *((_QWORD *)this + 1) = IIOImageReadSession::retainBytePointer(a2, (const __CFData **)this + 6, 1);
    Size = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 7));
  }
  else
  {
    Size = 0;
    *((_QWORD *)this + 1) = 0;
  }
  *((_QWORD *)this + 2) = Size;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_BYTE *)this + 68) = 1;
  *((_DWORD *)this + 16) = 0;
}

IIOImageRead *IIOImageReadSession::retainBytePointer(IIOImageReadSession *this, const __CFData **a2, int a3)
{
  IIOImageRead *result;

  result = (IIOImageRead *)*((_QWORD *)this + 4);
  if (result)
    return (IIOImageRead *)IIOImageRead::retainBytePointer(result, a2, a3);
  return result;
}

void ReadMetadataShort(uint64_t a1, IIOImageReadSession *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, int a7, uint64_t a8, uint64_t a9, char a10)
{
  size_t v15;
  _BYTE *v16;
  unsigned int *v17;
  _BYTE *v18;
  unint64_t v19;
  unsigned int v20;
  unint64_t BytesAtOffset;
  BOOL v22;
  const __CFAllocator **v23;
  CFMutableArrayRef Mutable;
  __CFArray *v25;
  int v26;
  unint64_t v27;
  const __CFAllocator *v28;
  unsigned int v29;
  unsigned int v30;
  CFStringRef v31;
  unint64_t v32;
  CGImageMetadataType v33;
  CGImageMetadataTagRef v34;
  CGImageMetadataType type;
  uint64_t v36;
  const void *v37;

  v15 = *(unsigned int *)(a8 + 4);
  if (v15 < 3)
  {
    v16 = 0;
  }
  else
  {
    v16 = malloc_type_calloc(v15, 2uLL, 0x1000040BDFB0063uLL);
    LODWORD(v15) = *(_DWORD *)(a8 + 4);
  }
  v17 = (unsigned int *)(a8 + 8);
  if (v15 <= 2)
    v18 = (_BYTE *)(a8 + 8);
  else
    v18 = v16;
  v19 = (2 * v15);
  if (v19 < 5)
    goto LABEL_11;
  v20 = *v17;
  if (a10)
  {
    v20 = bswap32(v20);
    *v17 = v20;
  }
  BytesAtOffset = IIOImageReadSession::getBytesAtOffset(a2, v16, a9 + v20, v19);
  LODWORD(v15) = *(_DWORD *)(a8 + 4);
  if (BytesAtOffset == 2 * (_DWORD)v15)
  {
LABEL_11:
    v22 = v15 <= 1 && a7 == 0;
    v23 = (const __CFAllocator **)MEMORY[0x1E0C9AE00];
    if (v22)
    {
      if (!(_DWORD)v15)
        goto LABEL_35;
      v36 = a1;
      v37 = a6;
      v25 = 0;
      v26 = 1;
    }
    else
    {
      Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
      v25 = Mutable;
      if (!*(_DWORD *)(a8 + 4))
      {
        if (!Mutable)
          goto LABEL_35;
        v33 = kCGImageMetadataTypeArrayOrdered;
        goto LABEL_32;
      }
      v36 = a1;
      v37 = a6;
      v26 = 3;
    }
    type = v26;
    v27 = 0;
    v28 = *v23;
    do
    {
      v29 = *(unsigned __int16 *)&v18[2 * v27];
      v30 = bswap32(v29) >> 16;
      if (a10)
        LOWORD(v29) = v30;
      v31 = CFStringCreateWithFormat(v28, 0, CFSTR("%d"), (unsigned __int16)v29);
      if ((a7 & 1) != 0 || (v32 = *(unsigned int *)(a8 + 4), v32 >= 2))
      {
        CFArrayAppendValue(v25, v31);
        CFRelease(v31);
        v31 = 0;
        v32 = *(unsigned int *)(a8 + 4);
      }
      ++v27;
    }
    while (v27 < v32);
    a1 = v36;
    a6 = v37;
    if (!v25)
    {
      if (!v31)
        goto LABEL_35;
      v34 = CGImageMetadataTagCreate(a3, a4, a5, type, v31);
      goto LABEL_33;
    }
    v33 = type;
LABEL_32:
    v34 = CGImageMetadataTagCreate(a3, a4, a5, v33, v25);
    v31 = (CFStringRef)v25;
LABEL_33:
    CFRelease(v31);
    if (v34)
    {
      CGImageMetadataAddTagWithKey(a1, a6, v34);
      CFRelease(v34);
    }
  }
LABEL_35:
  if (v16)
    free(v16);
}

CGMutableImageMetadataRef CreateMetadataFromDatablock(IIOImageReadSession *a1, unsigned __int16 *a2, unint64_t a3, unsigned int a4, const __CFData *a5, char a6)
{
  unsigned int v9;
  unint64_t v10;
  unint64_t BytesAtOffset;
  unsigned int v12;
  IIOImageReadSession *v13;
  unsigned int v14;
  unsigned int *v15;
  unint64_t v16;
  unsigned int v17;
  BOOL v18;
  IIODictionary *v19;
  uint64_t *v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned __int16 *v24;
  int v25;
  uint64_t v26;
  int v27;
  unsigned __int16 *v28;
  int v29;
  unsigned int v30;
  int v32;
  int v33;
  int v34;
  int v35;
  unsigned int v36;
  uint64_t v37;
  const __CFString **v38;
  const __CFString *v39;
  const __CFString **v40;
  const __CFString *v41;
  const __CFString **v42;
  const void *v43;
  void (*v44)(CGMutableImageMetadataRef, IIOImageReadSession *, const __CFString *, const __CFString *, const __CFString *, const void *, unsigned __int16 *, _QWORD, int);
  unsigned int v45;
  int v46;
  unsigned int v47;
  int v48;
  int v49;
  const __CFDictionary *MetadataFromDatablock;
  const __CFDictionary *v51;
  CGImageMetadataTag *TopLevelTag;
  const __CFArray *v53;
  const __CFArray *v54;
  CFTypeID v55;
  const void *ValueAtIndex;
  const void *DefaultString;
  CGImageMetadataTagRef v58;
  unsigned int v59;
  unsigned int v60;
  unint64_t v61;
  unint64_t v62;
  char *v63;
  unint64_t v64;
  uint64_t v65;
  size_t v66;
  unsigned int v67;
  CGImageMetadata *MetadataFromIPTCDatabuffer;
  const __CFDictionary *v69;
  const __CFDictionary *v70;
  uint64_t Source;
  uint64_t v72;
  const __CFString *v73;
  const __CFString *v74;
  unsigned int v75;
  unsigned __int8 *ASCIIString;
  unsigned __int8 *v77;
  int v78;
  CFStringEncoding v79;
  uint64_t v81;
  const void *v82;
  unsigned __int8 *v83;
  CFTypeRef *PropertiesFromAppleMakerNote;
  const void *v85;
  CGImageMetadataTagRef v86;
  unsigned int v87;
  unsigned int *v88;
  unint64_t v89;
  unsigned int v90;
  unsigned int v91;
  unsigned int *v92;
  unsigned int v93;
  unsigned int v94;
  unsigned int v95;
  const __CFAllocator *v96;
  unsigned int *v97;
  int v98;
  CFStringRef v99;
  CGImageMetadataTagRef v100;
  CGImageMetadataTagRef v101;
  unsigned int v102;
  unsigned int v103;
  unsigned int v104;
  CFStringRef v105;
  CFStringRef v106;
  CGImageMetadataTagRef v107;
  CGImageMetadataTagRef v108;
  char *v109;
  CGImageMetadata *MetadataFromXMPBuffer;
  const char *BytePtr;
  CFIndex Length;
  CGImageMetadata *MetadataFromXMPSidecarData;
  int v115;
  uint64_t v116;
  uint64_t v117;
  const __CFDictionary *v118;
  const __CFDictionary *value;
  CFStringRef valuea;
  const __CFAllocator *alloc;
  size_t size;
  unsigned int v123;
  const __CFString *v124;
  const __CFDictionary *v125;
  uint64_t v126;
  unint64_t v127;
  IIODictionary *v128;
  unsigned int v130;
  CGMutableImageMetadataRef Mutable;
  unsigned int *v133;
  IIOImageReadSession *v135;
  unsigned int MetadataLong;
  unsigned __int16 v137;
  __int128 v138;
  uint64_t v139;
  uint64_t v140;

  v140 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  v137 = 0;
  MetadataLong = 0;
  v130 = IIOImageReadSession::getSize(a1);
  Mutable = CGImageMetadataCreateMutable();
  v135 = a1;
  if (IIOImageReadSession::getBytesAtOffset(a1, &v137, a3, 2uLL) == 2)
  {
    v9 = v137;
    if (a4)
    {
      v9 = __rev16(v137);
      v137 = v9;
    }
    if ((unsigned __int16)(v9 - 255) >= 0xFF02u)
    {
      v133 = (unsigned int *)malloc_type_calloc(v9, 0xCuLL, 0x2EA37F57uLL);
      if (v133)
      {
        v10 = a3 + 2;
        BytesAtOffset = IIOImageReadSession::getBytesAtOffset(a1, v133, v10, 12 * v137);
        v12 = v137;
        if (BytesAtOffset != 12 * v137)
        {
          v19 = 0;
          goto LABEL_300;
        }
        if (v137)
        {
          v13 = a1;
          if (a4)
          {
            v14 = 0;
            v15 = v133;
            do
            {
              *(_WORD *)v15 = bswap32(*(unsigned __int16 *)v15) >> 16;
              *((_WORD *)v15 + 1) = bswap32(*((unsigned __int16 *)v15 + 1)) >> 16;
              v15[1] = bswap32(v15[1]);
              ++v14;
              v12 = v137;
              v15 += 3;
            }
            while (v14 < v137);
          }
        }
        else
        {
          v13 = a1;
        }
        if ((a6 & 4) == 0
          || ((v16 = IIOImageReadSession::getBytesAtOffset(v13, &MetadataLong, v10 + 12 * v12, 4uLL),
               v17 = MetadataLong,
               v16 == 4)
            ? (v18 = MetadataLong == 0)
            : (v18 = 1),
              v18))
        {
          v127 = 0;
        }
        else
        {
          if (a4)
          {
            v17 = bswap32(MetadataLong);
            MetadataLong = v17;
          }
          v127 = v17;
        }
        if ((a6 & 8) != 0)
        {
          v19 = (IIODictionary *)operator new();
          IIODictionary::IIODictionary(v19);
          IIODictionary::setObjectForKey(v19, (const void *)*MEMORY[0x1E0C9AE50], CFSTR("kCGImageSourceShouldPreferIPTCToEXIF"));
        }
        else
        {
          v19 = 0;
        }
        if (a2 == (unsigned __int16 *)&tagdefsGPS && v137 < 2u)
        {
LABEL_300:
          free(v133);
        }
        else
        {
          v128 = v19;
          if (a2 == (unsigned __int16 *)&tagdefsIFD0)
          {
            if (gInitializeTagKeyCacheIFD0Mutex != -1)
              dispatch_once(&gInitializeTagKeyCacheIFD0Mutex, &__block_literal_global_10);
            v20 = &IFD0TagKeys;
          }
          else if (a2 == (unsigned __int16 *)&tagdefsIFD1)
          {
            if (gInitializeTagKeyCacheIFD1Mutex != -1)
              dispatch_once(&gInitializeTagKeyCacheIFD1Mutex, &__block_literal_global_49);
            v20 = &IFD1TagKeys;
          }
          else if (a2 == (unsigned __int16 *)&tagdefsExif)
          {
            if (gInitializeTagKeyCacheExifMutex != -1)
              dispatch_once(&gInitializeTagKeyCacheExifMutex, &__block_literal_global_51);
            v20 = &ExifTagKeys;
          }
          else
          {
            if (a2 != (unsigned __int16 *)&tagdefsGPS)
            {
              _cg_jpeg_mem_term("CreateMetadataFromDatablock", 2025, "*** ERROR: unexpected tagTable?\n");
              goto LABEL_299;
            }
            if (gInitializeTagKeyCacheGPSMutex != -1)
              dispatch_once(&gInitializeTagKeyCacheGPSMutex, &__block_literal_global_53);
            v20 = &GPSTagKeys;
          }
          if (v137)
          {
            v21 = 0;
            v22 = 0;
            size = 0;
            v123 = 0;
            v23 = 0;
            v126 = *v20;
            alloc = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
            v24 = (unsigned __int16 *)v133;
            while (1)
            {
              v25 = *a2;
              if (v25 == 0xFFFF)
                goto LABEL_52;
              v26 = 0;
              v27 = *v24;
              v28 = a2 + 16;
              while (v25 != v27)
              {
                ++v26;
                v25 = v28[12];
                v28 += 28;
                if (v25 == 0xFFFF)
                  goto LABEL_52;
              }
              v29 = *(v28 - 15);
              if (*(v28 - 15))
              {
                v30 = v24[1];
                if (v30 != v29 && (v29 != 32771 || (unsigned __int16)(v30 - 3) >= 2u))
                {
                  switch(*(v28 - 15))
                  {
                    case 0x8001u:
                      if ((unsigned __int16)(v30 - 1) < 2u)
                        goto LABEL_81;
                      goto LABEL_212;
                    case 0x8002u:
                      if ((v30 | 2) == 3)
                        goto LABEL_81;
                      goto LABEL_212;
                    case 0x8004u:
                      if (v30 == 3 || v30 == 5)
                        goto LABEL_81;
                      goto LABEL_212;
                    case 0x8005u:
                      if (v30 > 7)
                        goto LABEL_212;
                      v32 = 1 << v30;
                      v33 = 134;
                      break;
                    case 0x8006u:
                      if ((unsigned __int16)(v30 - 3) < 3u)
                        goto LABEL_81;
                      goto LABEL_212;
                    case 0x8007u:
                      if (v30 == 5 || v30 == 10)
                        goto LABEL_81;
                      goto LABEL_212;
                    case 0x8008u:
                      if (v30 > 7)
                        goto LABEL_212;
                      v32 = 1 << v30;
                      v33 = 150;
                      break;
                    case 0x8009u:
                      if (v30 > 0x12)
                        goto LABEL_212;
                      v32 = 1 << v30;
                      v33 = 270352;
                      break;
                    case 0x800Au:
                      if (v30 == 1 || v30 == 7)
                        goto LABEL_81;
                      goto LABEL_212;
                    default:
                      goto LABEL_212;
                  }
                  if ((v32 & v33) == 0)
                  {
LABEL_212:
                    _cg_jpeg_mem_term("FindTagDef", 544, "*** tag '%04X'  type mismatch:   expected: %04X  got: %04X\n", v27, *(v28 - 15), v30);
                    goto LABEL_52;
                  }
                }
              }
LABEL_81:
              v34 = *(v28 - 14);
              if (*(v28 - 14))
              {
                v35 = *((_DWORD *)v24 + 1);
                if (v35 == v34)
                {
                  v36 = *(v28 - 14);
                }
                else
                {
                  if (v29 != 2 || v24[1] != 2)
                    goto LABEL_52;
                  if (v34 == 2 && v35 == 1)
                  {
                    v36 = 2;
                  }
                  else
                  {
                    if (v34 != 20 || v35 != 19)
                      goto LABEL_52;
                    v36 = 20;
                  }
                  v26 = 0xFFFFFFFFLL;
                }
              }
              else
              {
                v36 = 0;
              }
              v37 = *((_QWORD *)v28 + 1);
              if (!v37)
                ++v22;
              if (v36 > v130)
                ++v21;
              if (v22 >= 0x2B)
              {
                LogError("CreateMetadataFromDatablock", 2059, "*** ERROR: corrupt metadata input - too many invalid tag-IDs\n");
                goto LABEL_244;
              }
              if (v21 >= 0x2B)
              {
                LogError("CreateMetadataFromDatablock", 2064, "*** ERROR: corrupt metadata input - too many invalid tag counts\n");
                goto LABEL_244;
              }
              v38 = (const __CFString **)*((_QWORD *)v28 + 2);
              if ((unint64_t)v38 | v37)
              {
                if (!v38)
                  v38 = (const __CFString **)*((_QWORD *)v28 + 1);
                v39 = *v38;
              }
              else
              {
                v39 = 0;
              }
              v40 = (const __CFString **)*((_QWORD *)v28 - 2);
              if (v40)
                v41 = *v40;
              else
                v41 = 0;
              v42 = (const __CFString **)*((_QWORD *)v28 - 1);
              if (v42)
                v124 = *v42;
              else
                v124 = 0;
              v43 = 0;
              if ((v26 & 0x80000000) == 0 && v126)
                v43 = *(const void **)(v126 + 8 * v26);
              if ((a6 & 1) != 0)
              {
                if (v27 == 274)
                {
                  v47 = *((_DWORD *)v24 + 2);
                  if (a4)
                  {
                    if ((unsigned __int16)((bswap32(v47) >> 16) - 9) < 0xFFF8u)
                    {
                      v48 = 256;
                      goto LABEL_147;
                    }
                  }
                  else if ((unsigned __int16)(v47 - 9) <= 0xFFF7u)
                  {
                    v48 = 1;
LABEL_147:
                    *((_DWORD *)v24 + 2) = v48;
                  }
                  if (v24[1] != 3 || *((_DWORD *)v24 + 1) > 0x28u)
                    goto LABEL_52;
                  ReadMetadataShort((uint64_t)Mutable, v135, v41, v124, v39, v43, v34 != 1, (uint64_t)v24, 0, a4);
                  v27 = *v24;
                }
                if ((v27 & 0xFFFE) != 0x11A)
                  goto LABEL_154;
                if (v24[1] == 5)
                {
                  ReadMetadataRtnl((uint64_t)Mutable, v135, v41, v124, v39, v43, *(v28 - 14) != 1, (uint64_t)v24, a4);
                  v27 = *v24;
LABEL_154:
                  if (v27 == 296 && v24[1] == 3)
                    ReadMetadataShort((uint64_t)Mutable, v135, v41, v124, v39, v43, *(v28 - 14) != 1, (uint64_t)v24, 0, a4);
                  goto LABEL_52;
                }
                goto LABEL_52;
              }
              if ((a6 & 2) != 0)
              {
                if (*v24 <= 0x8768u)
                {
                  if (v27 == 700)
                    goto LABEL_52;
                  v49 = 33723;
                }
                else
                {
                  if (v27 == 34665 || v27 == 34853)
                    goto LABEL_52;
                  v49 = 37500;
                }
                if (v27 == v49)
                  goto LABEL_52;
              }
              if (a2 == (unsigned __int16 *)&tagdefsIFD0 && v27 == 700)
              {
                v123 = *((_DWORD *)v24 + 2);
                if (a4)
                {
                  v123 = bswap32(v123);
                  *((_DWORD *)v24 + 2) = v123;
                }
                size = *((unsigned int *)v24 + 1);
                goto LABEL_117;
              }
              if (*v24 > 0x8824u)
                break;
              if (v27 == 33723)
              {
                if (a2 == (unsigned __int16 *)&tagdefsIFD0 && (*((_DWORD *)v24 + 1) - 1) <= 0xF423F)
                {
                  v65 = v24[1];
                  if (v65 > 0xA)
                    goto LABEL_52;
                  v66 = GetSizeForTiffType(v65) * *((unsigned int *)v24 + 1);
                  v63 = (char *)malloc_type_malloc(v66, 0xC0BA3595uLL);
                  if (!v63)
                    goto LABEL_52;
                  v67 = *((_DWORD *)v24 + 2);
                  if (a4)
                  {
                    v67 = bswap32(v67);
                    *((_DWORD *)v24 + 2) = v67;
                  }
                  if (IIOImageReadSession::getBytesAtOffset(v135, v63, v67, v66) == v66)
                  {
                    MetadataFromIPTCDatabuffer = CreateMetadataFromIPTCDatabuffer(v63, v66);
                    if (MetadataFromIPTCDatabuffer)
                    {
                      metadataSetUnspecifiedSource((uint64_t)Mutable, 2);
                      metadataSetSource((uint64_t)MetadataFromIPTCDatabuffer, 4);
                      CGImageMetadataMerge((uint64_t)Mutable, (uint64_t)MetadataFromIPTCDatabuffer, v128);
                      CFRelease(MetadataFromIPTCDatabuffer);
                    }
                  }
                  goto LABEL_224;
                }
                goto LABEL_117;
              }
              if (v27 != 34665)
                goto LABEL_117;
              MetadataLong = ReadMetadataLong((uint64_t)Mutable, v135, v41, v124, v39, v43, 0, (uint64_t)v24, a4);
              MetadataFromDatablock = (const __CFDictionary *)CreateMetadataFromDatablock(v135, &tagdefsExif, MetadataLong, a4, a5, 0);
              v51 = MetadataFromDatablock;
              if (MetadataFromDatablock)
              {
                TopLevelTag = CGImageMetadataGetTopLevelTag(MetadataFromDatablock, (uint64_t)CFSTR("http://ns.adobe.com/exif/1.0/"), (uint64_t)CFSTR("ISOSpeedRatings"));
                if (TopLevelTag)
                {
                  v53 = (const __CFArray *)CGImageMetadataTagCopyValue(TopLevelTag);
                  v54 = v53;
                  if (v53)
                  {
                    v55 = CFGetTypeID(v53);
                    if (v55 == CFArrayGetTypeID() && CFArrayGetCount(v54) >= 1 && CFArrayGetCount(v54) == 1)
                    {
                      ValueAtIndex = CFArrayGetValueAtIndex(v54, 0);
                      DefaultString = CGImageMetadataGetDefaultString(ValueAtIndex);
                      v58 = CGImageMetadataTagCreate(CFSTR("http://cipa.jp/exif/1.0/"), CFSTR("exifEX"), CFSTR("PhotographicSensitivity"), kCGImageMetadataTypeString, DefaultString);
                      if (v58)
                      {
                        CGImageMetadataAddTag((uint64_t)v51, v58);
                        CFRelease(v58);
                      }
                    }
                    CFRelease(v54);
                  }
                }
LABEL_144:
                CGImageMetadataMerge((uint64_t)Mutable, (uint64_t)v51, v128);
                CFRelease(v51);
              }
LABEL_52:
              ++v23;
              v24 += 6;
              if (v23 >= v137)
                goto LABEL_244;
            }
            if (v27 == 34853)
            {
              MetadataLong = ReadMetadataLong((uint64_t)Mutable, v135, v41, v124, v39, v43, 0, (uint64_t)v24, a4);
              v69 = (const __CFDictionary *)CreateMetadataFromDatablock(v135, &tagdefsGPS, MetadataLong, a4, a5, 0);
              v51 = v69;
              if (!v69)
                goto LABEL_52;
              v70 = CGImageMetadataGetTopLevelTag(v69, (uint64_t)CFSTR("http://ns.adobe.com/exif/1.0/"), (uint64_t)CFSTR("GPSLatitude"));
              value = CGImageMetadataGetTopLevelTag(v51, (uint64_t)CFSTR("http://ns.adobe.com/exif/1.0/"), (uint64_t)CFSTR("GPSLatitudeRef"));
              v125 = CGImageMetadataGetTopLevelTag(v51, (uint64_t)CFSTR("http://ns.adobe.com/exif/1.0/"), (uint64_t)CFSTR("GPSLongitude"));
              v118 = CGImageMetadataGetTopLevelTag(v51, (uint64_t)CFSTR("http://ns.adobe.com/exif/1.0/"), (uint64_t)CFSTR("GPSLongitudeRef"));
              Source = CGImageSourceGetSource((uint64_t)v70);
              v72 = CGImageSourceGetSource((uint64_t)value);
              v117 = CGImageSourceGetSource((uint64_t)v125);
              v116 = CGImageSourceGetSource((uint64_t)v118);
              if (v70)
              {
                if (value)
                {
                  v73 = CFStringCreateWithFormat(alloc, 0, CFSTR("%@%@"), *(_QWORD *)(Source + 48), *(_QWORD *)(v72 + 48));
                  if (v73)
                  {
                    CGImageMetadataTagSetValue((uint64_t)v70, v73);
                    CGImageMetadataRemoveTag((uint64_t)v51, (uint64_t)value);
                    CFRelease(v73);
                  }
                }
              }
              if (v125)
              {
                if (v118)
                {
                  v74 = CFStringCreateWithFormat(alloc, 0, CFSTR("%@%@"), *(_QWORD *)(v117 + 48), *(_QWORD *)(v116 + 48));
                  if (v74)
                  {
                    CGImageMetadataTagSetValue((uint64_t)v125, v74);
                    CGImageMetadataRemoveTag((uint64_t)v51, (uint64_t)v118);
                    CFRelease(v74);
                  }
                }
              }
              goto LABEL_144;
            }
            if (v27 == 37500 && *((_DWORD *)v24 + 1) >= 5u)
            {
              v59 = *((_DWORD *)v24 + 2);
              v60 = bswap32(v59);
              if (a4)
                v61 = v60;
              else
                v61 = v59;
              v62 = GetSizeForTiffType(v24[1]) * *((unsigned int *)v24 + 1);
              if (!v62)
                goto LABEL_52;
              if (v62 >= v130)
              {
                _cg_jpeg_mem_term("CreateMetadataFromDatablock", 2221, "*** ERROR: Bad makerNoteSize: %d >= fileSize: %d\n", v62, v130);
                goto LABEL_52;
              }
              v63 = (char *)malloc_type_calloc(v62, 1uLL, 0x3A8858BAuLL);
              if (v63)
              {
                v64 = IIOImageReadSession::getBytesAtOffset(v135, v63, v61, v62);
                if (v64 != v62)
                {
                  _cg_jpeg_mem_term("CreateMetadataFromDatablock", 2226, "*** ERROR: failed to read makerNote (expected: %d, got: %d bytes)\n", v62, v64);
                  goto LABEL_52;
                }
                if (v62 < 0x20)
                {
                  if (v62 >= 0xA)
                    goto LABEL_217;
                  goto LABEL_221;
                }
                if (!strncmp(v63 + 4, "iOS ", 4uLL))
                  goto LABEL_224;
LABEL_217:
                if (*(_QWORD *)v63 == 0x4F6920656C707041 && *((_WORD *)v63 + 4) == 83)
                {
                  PropertiesFromAppleMakerNote = (CFTypeRef *)CreatePropertiesFromAppleMakerNote((unsigned __int8 *)v63, v62);
                  if (PropertiesFromAppleMakerNote)
                  {
                    v85 = (const void *)*((_QWORD *)Mutable + 6);
                    if (v85)
                      CFRelease(v85);
                    *((_QWORD *)Mutable + 6) = CFRetain(PropertiesFromAppleMakerNote[1]);
                    (*((void (**)(CFTypeRef *))*PropertiesFromAppleMakerNote + 1))(PropertiesFromAppleMakerNote);
                  }
                }
                else
                {
LABEL_221:
                  v138 = 0uLL;
                  v139 = 0;
                  IIODictionary::IIODictionary((IIODictionary *)&v138);
                  v81 = IIOImageSource::cf(v135);
                  call_RAWCamera_readMakerNoteProps(v81, (IIODictionary *)&v138, v61, v62, a4);
                  v82 = (const void *)*((_QWORD *)Mutable + 6);
                  if (v82)
                    CFRelease(v82);
                  *((_QWORD *)Mutable + 6) = CFRetain(*((CFTypeRef *)&v138 + 1));
                  IIODictionary::~IIODictionary((IIODictionary *)&v138);
                }
LABEL_224:
                v83 = (unsigned __int8 *)v63;
LABEL_240:
                free(v83);
                goto LABEL_52;
              }
              goto LABEL_52;
            }
LABEL_117:
            v44 = *(void (**)(CGMutableImageMetadataRef, IIOImageReadSession *, const __CFString *, const __CFString *, const __CFString *, const void *, unsigned __int16 *, _QWORD, int))v28;
            if (!*(_QWORD *)v28 && !v39 && !v41)
              goto LABEL_52;
            if (v27 == 274)
            {
              v45 = *((_DWORD *)v24 + 2);
              if (a4)
              {
                if ((unsigned __int16)((bswap32(v45) >> 16) - 9) >= 0xFFF8u)
                  goto LABEL_200;
                v46 = 256;
              }
              else
              {
                if ((unsigned __int16)(v45 - 9) > 0xFFF7u)
                  goto LABEL_200;
                v46 = 1;
              }
              *((_DWORD *)v24 + 2) = v46;
            }
LABEL_200:
            if (v44)
            {
              LOBYTE(v115) = a4;
              v44(Mutable, v135, v41, v124, v39, v43, v24, 0, v115);
            }
            else
            {
              v75 = *((_DWORD *)v24 + 1);
              if ((v75 - 1) >> 4 > 0x270 || v24[1] != 2)
              {
                switch(v24[1])
                {
                  case 1u:
                    if (v75 <= 0x28)
                      ReadMetadataByte((uint64_t)Mutable, v135, v41, v124, v39, v43, v34 != 1, (uint64_t)v24, 0, a4);
                    break;
                  case 3u:
                    if (v75 <= 0x28)
                      ReadMetadataShort((uint64_t)Mutable, v135, v41, v124, v39, v43, v34 != 1, (uint64_t)v24, 0, a4);
                    break;
                  case 4u:
                    if (v75 <= 0x28)
                      ReadMetadataLong((uint64_t)Mutable, v135, v41, v124, v39, v43, v34 != 1, (uint64_t)v24, a4);
                    break;
                  case 5u:
                    ReadMetadataRtnl((uint64_t)Mutable, v135, v41, v124, v39, v43, v34 != 1, (uint64_t)v24, a4);
                    break;
                  case 0xAu:
                    ReadMetadataSRtnl((uint64_t)Mutable, v135, v41, v124, v39, v43, v34 != 1, (uint64_t)v24, a4);
                    break;
                  default:
                    goto LABEL_52;
                }
                goto LABEL_52;
              }
              ASCIIString = (unsigned __int8 *)ReadAndCreateASCIIString(v135, v24, 0, a4);
              v77 = ASCIIString;
              if (ASCIIString)
              {
                if (*ASCIIString && !onlyspaces(ASCIIString))
                {
                  v78 = stringType(v77, *((_DWORD *)v24 + 1));
                  if (v78 == 1)
                  {
                    v79 = 134217984;
LABEL_236:
                    valuea = CFStringCreateWithCString(alloc, (const char *)v77, v79);
                    if (valuea)
                    {
                      v86 = CGImageMetadataTagCreate(v41, v124, v39, kCGImageMetadataTypeString, valuea);
                      CFRelease(valuea);
                      if (v86)
                      {
                        CGImageMetadataAddTagWithKey((uint64_t)Mutable, v43, v86);
                        CFRelease(v86);
                      }
                    }
                  }
                  else if (!v78)
                  {
                    v79 = 1536;
                    goto LABEL_236;
                  }
                }
                v83 = v77;
                goto LABEL_240;
              }
            }
            goto LABEL_52;
          }
          v123 = 0;
          size = 0;
LABEL_244:
          if (!v127)
            goto LABEL_288;
          if (IIOImageReadSession::getBytesAtOffset(v135, &v137, v127, 2uLL) != 2)
            goto LABEL_299;
          v87 = v137;
          if (a4)
          {
            v87 = __rev16(v137);
            v137 = v87;
          }
          v19 = v128;
          if (v87 > 0xFE)
            goto LABEL_300;
          if (!v87)
            goto LABEL_288;
          v88 = (unsigned int *)reallocf(v133, 12 * v87);
          if (v88)
          {
            v133 = v88;
            v89 = IIOImageReadSession::getBytesAtOffset(v135, v88, v127 + 2, 12 * v137);
            v90 = v137;
            if (v89 != 12 * v137)
              goto LABEL_299;
            if (v137 && a4)
            {
              v91 = 0;
              v92 = v133;
              do
              {
                *(_WORD *)v92 = bswap32(*(unsigned __int16 *)v92) >> 16;
                *((_WORD *)v92 + 1) = bswap32(*((unsigned __int16 *)v92 + 1)) >> 16;
                *(int8x8_t *)(v92 + 1) = vrev32_s8(*(int8x8_t *)(v92 + 1));
                ++v91;
                v92 += 3;
              }
              while (v91 < v90);
            }
            else if (!v137)
            {
              goto LABEL_288;
            }
            v93 = 0;
            v94 = 0;
            v95 = 0;
            v96 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
            v97 = v133 + 2;
            while (1)
            {
              v98 = *((unsigned __int16 *)v97 - 4);
              if (v98 == 514)
              {
                v94 = *v97;
                v99 = CFStringCreateWithFormat(v96, 0, CFSTR("%d"), *v97);
                if (v99)
                {
                  v100 = CGImageMetadataTagCreate(CFSTR("http://ns.apple.com/ImageIO/1.0/"), CFSTR("iio"), CFSTR("JPEGInterchangeFormatLength"), kCGImageMetadataTypeString, v99);
                  goto LABEL_265;
                }
              }
              else if (v98 == 513)
              {
                v93 = *v97 + 12;
                v99 = CFStringCreateWithFormat(v96, 0, CFSTR("%d"), v93);
                if (v99)
                {
                  v100 = CGImageMetadataTagCreate(CFSTR("http://ns.apple.com/ImageIO/1.0/"), CFSTR("iio"), CFSTR("JPEGInterchangeFormat"), kCGImageMetadataTypeString, v99);
LABEL_265:
                  v101 = v100;
                  if (v100)
                  {
                    CGImageMetadataAddTag((uint64_t)Mutable, v100);
                    CFRelease(v101);
                  }
                  CFRelease(v99);
                }
              }
              ++v95;
              v97 += 3;
              if (v95 >= v137)
              {
                if (v94 && v93)
                {
                  WORD4(v138) = 0;
                  *(_QWORD *)&v138 = 0;
                  if (IIOImageReadSession::getBytesAtOffset(v135, &v138, v93 - 12, 2uLL) != 2)
                    goto LABEL_299;
                  if (bswap32((unsigned __int16)v138) >> 16 == 65496)
                  {
                    v102 = v93 - 10;
                    while (IIOImageReadSession::getBytesAtOffset(v135, &v138, v102, 0xAuLL) == 10)
                    {
                      v103 = __rev16((unsigned __int16)v138);
                      if (v103 == 65472)
                      {
                        v104 = *(unsigned __int16 *)((char *)&v138 + 5);
                        v105 = CFStringCreateWithFormat(v96, 0, CFSTR("%zu"), __rev16(*(unsigned __int16 *)((char *)&v138 + 7)));
                        v106 = CFStringCreateWithFormat(v96, 0, CFSTR("%zu"), __rev16(v104));
                        if (v105)
                        {
                          v107 = CGImageMetadataTagCreate(CFSTR("http://ns.apple.com/ImageIO/1.0/"), CFSTR("iio"), CFSTR("JPEGInterchangeFormatWidth"), kCGImageMetadataTypeString, v105);
                          if (v107)
                          {
                            CGImageMetadataAddTag((uint64_t)Mutable, v107);
                            CFRelease(v107);
                          }
                          CFRelease(v105);
                        }
                        if (v106)
                        {
                          v108 = CGImageMetadataTagCreate(CFSTR("http://ns.apple.com/ImageIO/1.0/"), CFSTR("iio"), CFSTR("JPEGInterchangeFormatHeight"), kCGImageMetadataTypeString, v106);
                          if (v108)
                          {
                            CGImageMetadataAddTag((uint64_t)Mutable, v108);
                            CFRelease(v108);
                          }
                          CFRelease(v106);
                        }
                        goto LABEL_288;
                      }
                      v102 += (bswap32(WORD1(v138)) >> 16) + 2;
                      if (v103 == 65498)
                        goto LABEL_288;
                    }
LABEL_299:
                    v19 = v128;
                    goto LABEL_300;
                  }
                }
LABEL_288:
                metadataSetUnspecifiedSource((uint64_t)Mutable, 2);
                v109 = 0;
                if (v123 && size)
                {
                  v109 = (char *)malloc_type_malloc(size, 0xE202211FuLL);
                  if (!v109)
                    goto LABEL_299;
                  if (IIOImageReadSession::getBytesAtOffset(v135, v109, v123, size) == size)
                  {
                    MetadataFromXMPBuffer = CreateMetadataFromXMPBuffer(v109, size);
                    if (MetadataFromXMPBuffer)
                    {
                      CGImageMetadataMerge((uint64_t)Mutable, (uint64_t)MetadataFromXMPBuffer, v128);
                      CFRelease(MetadataFromXMPBuffer);
                    }
                    goto LABEL_294;
                  }
                }
                else
                {
LABEL_294:
                  if (a5)
                  {
                    BytePtr = (const char *)CFDataGetBytePtr(a5);
                    Length = CFDataGetLength(a5);
                    MetadataFromXMPSidecarData = CreateMetadataFromXMPSidecarData(BytePtr, Length);
                    if (MetadataFromXMPSidecarData)
                    {
                      CGImageMetadataMerge((uint64_t)Mutable, (uint64_t)MetadataFromXMPSidecarData, v128);
                      CFRelease(MetadataFromXMPSidecarData);
                    }
                  }
                  if (!v109)
                    goto LABEL_299;
                }
                free(v109);
                goto LABEL_299;
              }
            }
          }
        }
        if (v19)
          (*(void (**)(IIODictionary *))(*(_QWORD *)v19 + 8))(v19);
      }
    }
  }
  return Mutable;
}

void sub_187E89DD8(_Unwind_Exception *a1)
{
  uint64_t v1;

  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 120));
  _Unwind_Resume(a1);
}

__CFArray *ReadMetadataLong(uint64_t a1, IIOImageReadSession *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, int a7, uint64_t a8, char a9)
{
  size_t v16;
  unsigned int *v17;
  unsigned int *v18;
  unsigned int *v19;
  unint64_t BytesAtOffset;
  unsigned int v21;
  unsigned int v22;
  __CFArray *v23;
  unsigned int v24;
  const __CFAllocator **v25;
  int v26;
  CFMutableArrayRef Mutable;
  unint64_t v28;
  const __CFAllocator *v29;
  uint64_t v30;
  unsigned int v31;
  CFStringRef v32;
  unint64_t v33;
  CGImageMetadataType v34;
  CGImageMetadataTagRef v35;
  uint64_t v37;
  const void *v38;
  CGImageMetadataType type;
  const __CFString *name;
  const __CFString *v41;

  v16 = *(unsigned int *)(a8 + 4);
  if (v16 < 2)
  {
    v17 = 0;
  }
  else
  {
    v17 = (unsigned int *)malloc_type_calloc(v16, 4uLL, 0x100004052888210uLL);
    LODWORD(v16) = *(_DWORD *)(a8 + 4);
  }
  v18 = (unsigned int *)(a8 + 8);
  if (v16 <= 1)
    v19 = (unsigned int *)(a8 + 8);
  else
    v19 = v17;
  BytesAtOffset = (4 * v16);
  if (BytesAtOffset >= 5)
  {
    v21 = *v18;
    if (a9)
    {
      v21 = bswap32(v21);
      *v18 = v21;
    }
    BytesAtOffset = IIOImageReadSession::getBytesAtOffset(a2, v17, v21, BytesAtOffset);
  }
  if (a3 || a4 || a5)
  {
    v24 = *(_DWORD *)(a8 + 4);
    if (BytesAtOffset == 4 * v24)
    {
      v41 = a4;
      v25 = (const __CFAllocator **)MEMORY[0x1E0C9AE00];
      if (v24 > 1 || a7)
      {
        Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
        v23 = Mutable;
        if (!*(_DWORD *)(a8 + 4))
        {
          if (!Mutable)
            goto LABEL_42;
          v37 = a1;
          v38 = a6;
          v34 = kCGImageMetadataTypeArrayOrdered;
          goto LABEL_38;
        }
        name = a5;
        v37 = a1;
        v38 = a6;
        v26 = 3;
      }
      else
      {
        if (!v24)
          goto LABEL_41;
        name = a5;
        v37 = a1;
        v38 = a6;
        v23 = 0;
        v26 = 1;
      }
      type = v26;
      v28 = 0;
      v29 = *v25;
      do
      {
        LODWORD(v30) = v19[v28];
        v31 = bswap32(v30);
        if (a9)
          v30 = v31;
        else
          v30 = v30;
        v32 = CFStringCreateWithFormat(v29, 0, CFSTR("%d"), v30);
        if ((a7 & 1) != 0 || (v33 = *(unsigned int *)(a8 + 4), v33 >= 2))
        {
          CFArrayAppendValue(v23, v32);
          CFRelease(v32);
          v32 = 0;
          v33 = *(unsigned int *)(a8 + 4);
        }
        ++v28;
      }
      while (v28 < v33);
      if (v23)
      {
        a5 = name;
        v34 = type;
LABEL_38:
        v35 = CGImageMetadataTagCreate(a3, v41, a5, v34, v23);
        v32 = (CFStringRef)v23;
LABEL_39:
        CFRelease(v32);
        if (v35)
        {
          CGImageMetadataAddTagWithKey(v37, v38, v35);
          CFRelease(v35);
        }
        goto LABEL_41;
      }
      if (v32)
      {
        v35 = CGImageMetadataTagCreate(a3, v41, name, type, v32);
        goto LABEL_39;
      }
    }
LABEL_41:
    v23 = 0;
    goto LABEL_42;
  }
  v22 = bswap32(*v19);
  if (a9)
    v23 = (__CFArray *)v22;
  else
    v23 = (__CFArray *)*v19;
LABEL_42:
  if (v17)
    free(v17);
  return v23;
}

CGImageMetadataTagRef CGImageMetadataTagCreate(CFStringRef xmlns, CFStringRef prefix, CFStringRef name, CGImageMetadataType type, CFTypeRef value)
{
  const char *v10;
  CFTypeID v11;
  CFTypeID v12;
  CFTypeID TypeID;
  uint64_t Instance;
  CFTypeID v15;
  CFTypeID v16;
  CFTypeID v17;
  CFTypeID v18;
  CFTypeID v19;
  CFTypeID v20;
  CFTypeID v21;
  unint64_t v22;
  IIOMetadata_Tag *v23;
  CFTypeID v25;
  CFTypeID v26;
  _BYTE v27[24];

  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0)
  {
    IIOString::IIOString((IIOString *)v27, name);
    v10 = (const char *)IIOString::utf8String((IIOString *)v27);
    ImageIODebugOptions(3, "A", "CGImageMetadataTagCreate", 0, v10, -1, 0);
    IIOString::~IIOString((IIOString *)v27);
  }
  if (!xmlns)
    return 0;
  v11 = CFGetTypeID(xmlns);
  if (v11 != CFStringGetTypeID())
    return 0;
  if (prefix)
  {
    v12 = CFGetTypeID(prefix);
    TypeID = CFStringGetTypeID();
    Instance = 0;
    if (!name || v12 != TypeID)
      return (CGImageMetadataTagRef)Instance;
  }
  else if (!name)
  {
    return 0;
  }
  v15 = CFGetTypeID(name);
  v16 = CFStringGetTypeID();
  Instance = 0;
  if (!value || v15 != v16)
    return (CGImageMetadataTagRef)Instance;
  v17 = CFGetTypeID(value);
  if (v17 != CFStringGetTypeID())
  {
    v18 = CFGetTypeID(value);
    if (v18 != CFNumberGetTypeID())
    {
      v19 = CFGetTypeID(value);
      if (v19 != CFBooleanGetTypeID())
      {
        v20 = CFGetTypeID(value);
        if (v20 != CFArrayGetTypeID())
        {
          v21 = CFGetTypeID(value);
          if (v21 != CFNullGetTypeID())
          {
            v25 = CFGetTypeID(value);
            v26 = CFDictionaryGetTypeID();
            Instance = 0;
            if (type > kCGImageMetadataTypeStructure || v25 != v26)
              return (CGImageMetadataTagRef)Instance;
            goto LABEL_18;
          }
        }
      }
    }
  }
  if (type > kCGImageMetadataTypeStructure)
    return 0;
LABEL_18:
  if (CGImageMetadataTagGetTypeID::once != -1)
    dispatch_once(&CGImageMetadataTagGetTypeID::once, &__block_literal_global_33);
  Instance = _CFRuntimeCreateInstance();
  *(_DWORD *)(Instance + 16) = 1;
  do
    v22 = __ldxr(&gMDTCount);
  while (__stxr(v22 + 1, &gMDTCount));
  v23 = (IIOMetadata_Tag *)operator new();
  IIOMetadata_Tag::IIOMetadata_Tag(v23, xmlns, prefix, name, type, (__CFString *)value);
  *(_QWORD *)(Instance + 24) = v23;
  *((_QWORD *)v23 + 1) = Instance;
  return (CGImageMetadataTagRef)Instance;
}

void sub_187E8A2E8(void *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C406EDB48BALL);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187E8A288);
}

void sub_187E8A31C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void IIOMetadata_Tag::IIOMetadata_Tag(IIOMetadata_Tag *this, const __CFString *a2, const __CFString *a3, const __CFString *a4, int a5, __CFString *a6)
{
  CFStringRef *v12;
  const __CFAllocator *v13;
  const __CFString *Copy;
  IIOMetadata_Tag *TypeID;
  const __CFString *v16;
  CFTypeID v17;
  CFTypeID v18;
  CFTypeID v19;
  CFStringRef v20;
  CFTypeID v21;
  CFTypeID v22;
  _DWORD *exception;

  *(_QWORD *)this = &off_1E1BB0250;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((_DWORD *)this + 10) = -1;
  *((_QWORD *)this + 6) = 0;
  v12 = (CFStringRef *)((char *)this + 48);
  *((_DWORD *)this + 17) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_BYTE *)this + 64) = 0;
  v13 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Copy = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2);
  *((_QWORD *)this + 2) = Copy;
  if (!a3)
  {
    a3 = CGImageMetadataDefaultPrefixForNamespace(Copy);
    if (!a3)
    {
LABEL_15:
      exception = __cxa_allocate_exception(4uLL);
      *exception = -1;
      __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
    }
  }
  *((_QWORD *)this + 3) = CFStringCreateCopy(v13, a3);
  TypeID = (IIOMetadata_Tag *)CFStringCreateCopy(v13, a4);
  *((_QWORD *)this + 4) = TypeID;
  if (a5)
    goto LABEL_8;
  v17 = CFGetTypeID(a6);
  TypeID = (IIOMetadata_Tag *)CFStringGetTypeID();
  if ((IIOMetadata_Tag *)v17 == TypeID
    || (v18 = CFGetTypeID(a6), TypeID = (IIOMetadata_Tag *)CFNumberGetTypeID(), (IIOMetadata_Tag *)v18 == TypeID)
    || (v19 = CFGetTypeID(a6), TypeID = (IIOMetadata_Tag *)CFBooleanGetTypeID(), (IIOMetadata_Tag *)v19 == TypeID))
  {
    a5 = 1;
LABEL_8:
    *((_DWORD *)this + 10) = a5;
    goto LABEL_9;
  }
  v21 = CFGetTypeID(a6);
  TypeID = (IIOMetadata_Tag *)CFArrayGetTypeID();
  if ((IIOMetadata_Tag *)v21 == TypeID)
  {
    a5 = 3;
    goto LABEL_8;
  }
  v22 = CFGetTypeID(a6);
  TypeID = (IIOMetadata_Tag *)CFDictionaryGetTypeID();
  if ((IIOMetadata_Tag *)v22 == TypeID)
  {
    a5 = 6;
    goto LABEL_8;
  }
LABEL_9:
  v20 = IIOMetadata_Tag::copyTagValue(TypeID, a2, a3, v16, a6, 0);
  *v12 = v20;
  if (!v20)
    goto LABEL_15;
  *((_BYTE *)this + 64) = 1;
}

CFStringRef IIOMetadata_Tag::copyTagValue(IIOMetadata_Tag *this, const __CFString *a2, const __CFString *a3, const __CFString *a4, __CFString *cf, int a6)
{
  __CFString *MutableCopy;
  CFTypeID v10;
  CFTypeID v12;
  CFTypeID v13;
  CFTypeID v14;
  CFTypeID v15;
  uint64_t Count;
  const __CFAllocator *v17;
  CFIndex i;
  _QWORD *ValueAtIndex;
  CFTypeID v20;
  const __CFString *v21;
  const __CFString *v22;
  CGImageMetadataTagRef DeepCopy;
  uint64_t v24;
  uint64_t v25;
  const __CFString *v26;
  CFTypeID v27;
  IIOMetadata_Tag *v28;
  CFTypeID v29;
  CFIndex v30;
  const void **v31;
  const void **v32;
  const __CFString *v33;
  _QWORD *v34;
  CFTypeID v35;
  CGImageMetadataTagRef v36;
  CGImageMetadataTagRef v37;
  BOOL v38;
  uint64_t v39;
  uint64_t v40;
  const __CFString *v41;
  CFTypeID v42;
  IIOMetadata_Tag *v43;
  CFStringRef v44;
  const char *v45;
  const void **v46;
  const void **v47;
  _BYTE v48[24];

  MutableCopy = cf;
  v10 = CFGetTypeID(cf);
  if (v10 == CFNullGetTypeID())
    return MutableCopy;
  v12 = CFGetTypeID(MutableCopy);
  if (v12 == CFStringGetTypeID())
    return CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], MutableCopy);
  v13 = CFGetTypeID(MutableCopy);
  if (v13 == CFNumberGetTypeID())
    return CGImageMetadataCreateSimpleStringFromCFValue(MutableCopy, 1);
  v14 = CFGetTypeID(MutableCopy);
  if (v14 != CFBooleanGetTypeID())
  {
    v15 = CFGetTypeID(MutableCopy);
    if (v15 == CFArrayGetTypeID())
    {
      Count = CFArrayGetCount((CFArrayRef)MutableCopy);
      v17 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      MutableCopy = (__CFString *)CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], Count, (CFArrayRef)MutableCopy);
      if (Count >= 1)
      {
        for (i = 0; Count != i; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)MutableCopy, i);
          v20 = CFGetTypeID(ValueAtIndex);
          if (v20 == CFStringGetTypeID())
          {
            v21 = CFStringCreateWithFormat(v17, 0, CFSTR("[%ld]"), i);
            if (!v21)
              continue;
            v22 = v21;
            DeepCopy = CGImageMetadataTagCreate(a2, a3, v21, kCGImageMetadataTypeString, ValueAtIndex);
            CFRelease(v22);
            if (!DeepCopy)
              continue;
          }
          else
          {
            if (!ValueAtIndex || !a6)
              continue;
            v27 = CFGetTypeID(ValueAtIndex);
            if (CGImageMetadataTagGetTypeID::once != -1)
              dispatch_once(&CGImageMetadataTagGetTypeID::once, &__block_literal_global_33);
            if (v27 != CGImageMetadataTagGetTypeID::id)
              continue;
            v28 = (IIOMetadata_Tag *)ValueAtIndex[3];
            if (!v28)
              continue;
            DeepCopy = IIOMetadata_Tag::createDeepCopy(v28, v24, v25, v26);
            if (!DeepCopy)
              continue;
          }
          CFArraySetValueAtIndex((CFMutableArrayRef)MutableCopy, i, DeepCopy);
          CFRelease(DeepCopy);
        }
      }
      return MutableCopy;
    }
    v29 = CFGetTypeID(MutableCopy);
    if (v29 != CFDictionaryGetTypeID())
    {
      v44 = CFCopyDescription(MutableCopy);
      IIOString::IIOString((IIOString *)v48, v44);
      v45 = (const char *)IIOString::utf8String((IIOString *)v48);
      LogError("copyTagValue", 386, "*** ERROR: copyTagValue not handled for %s\n", v45);
      IIOString::~IIOString((IIOString *)v48);
      return 0;
    }
    v30 = CFDictionaryGetCount((CFDictionaryRef)MutableCopy);
    MutableCopy = (__CFString *)CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v30, (CFDictionaryRef)MutableCopy);
    v31 = (const void **)malloc_type_calloc(8uLL, v30, 0x9A1BD4F9uLL);
    v32 = (const void **)malloc_type_calloc(8uLL, v30, 0x34D33DFuLL);
    CFDictionaryGetKeysAndValues((CFDictionaryRef)MutableCopy, v31, v32);
    v46 = v31;
    v47 = v32;
    if (v30 < 1)
    {
      if (v31)
LABEL_44:
        free(v46);
      if (v47)
        free(v47);
      return MutableCopy;
    }
    while (1)
    {
      v33 = (const __CFString *)*v31;
      v34 = *v32;
      v35 = CFGetTypeID(*v32);
      if (v35 == CFStringGetTypeID())
      {
        v36 = CGImageMetadataTagCreate(a2, a3, v33, kCGImageMetadataTypeString, v34);
      }
      else
      {
        if (v34)
          v38 = a6 == 0;
        else
          v38 = 1;
        if (v38)
          goto LABEL_40;
        v42 = CFGetTypeID(v34);
        if (CGImageMetadataTagGetTypeID::once != -1)
          dispatch_once(&CGImageMetadataTagGetTypeID::once, &__block_literal_global_33);
        if (v42 != CGImageMetadataTagGetTypeID::id)
          goto LABEL_40;
        v43 = (IIOMetadata_Tag *)v34[3];
        if (!v43)
          goto LABEL_40;
        v36 = IIOMetadata_Tag::createDeepCopy(v43, v39, v40, v41);
      }
      v37 = v36;
      if (v36)
      {
        CFDictionarySetValue((CFMutableDictionaryRef)MutableCopy, v33, v36);
        CFRelease(v37);
      }
LABEL_40:
      ++v32;
      ++v31;
      if (!--v30)
        goto LABEL_44;
    }
  }
  return CGImageMetadataCreateSimpleStringFromCFValue(MutableCopy, 0);
}

void sub_187E8A8F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void CGImageMetadataAddTagWithKey(uint64_t a1, const void *a2, const void *a3)
{
  if (a1 && a3)
  {
    if (a2)
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), a2, a3);
    else
      CGImageMetadataAddTag(a1, a3);
  }
}

uint64_t IIO_Reader_PNG::getImageCount(IIO_Reader_PNG *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  unint64_t v6;
  char v7;
  unsigned int v8;
  unint64_t v9;
  unsigned int v10;
  unsigned int v11;
  unint64_t v12;
  unsigned int v14;
  IIOImageRead *v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  unint64_t v20;
  unsigned int v21;
  unsigned int v22;
  unint64_t v23;
  int v24;
  int v25;
  unsigned int v26;
  unsigned int v27;
  int v28;
  uint64_t v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  IIOImageRead *Size;
  unsigned int v35;
  _OWORD v36[3];
  _QWORD v37[2];

  v37[1] = *MEMORY[0x1E0C80C00];
  v37[0] = 0;
  Size = IIOImageReadSession::getSize(a2);
  if (IIOImageReadSession::getBytesAtOffset(a2, v37, 8uLL, 8uLL) != 8)
    goto LABEL_13;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v35 = 0;
  v9 = 8;
  while (1)
  {
    v10 = bswap32(v37[0]);
    v11 = bswap32(HIDWORD(v37[0]));
    if (v11 == 1229209940)
    {
      v12 = 1;
      if ((v6 & 1) != 0)
        goto LABEL_14;
      goto LABEL_12;
    }
    if (v11 == 1229472850)
    {
      if ((v7 & 1) != 0)
      {
        _cg_jpeg_mem_term("getImageCount", 296, "*** ERROR: bad PNG - multiple 'IHDR' chunks in PNG are not allowed\n");
        goto LABEL_20;
      }
      if (IIOImageReadSession::getBytesAtOffset(a2, v37, v9 + 8, 8uLL) != 8)
        goto LABEL_13;
      v35 = bswap32(v37[0]);
      v8 = bswap32(HIDWORD(v37[0]));
      v7 = 1;
      goto LABEL_10;
    }
    if (v11 == 1633899596)
      break;
LABEL_10:
    v12 = v6;
LABEL_12:
    v9 += v10 + 12;
    v6 = v12;
    if (IIOImageReadSession::getBytesAtOffset(a2, v37, v9, 8uLL) != 8)
      goto LABEL_13;
  }
  if ((v6 & 1) != 0)
  {
    _cg_jpeg_mem_term("getImageCount", 319, "*** ERROR: bad 'acTL' chunk (after 'IDAT')\n");
    goto LABEL_20;
  }
  if (IIOImageReadSession::getBytesAtOffset(a2, v37, v9 + 8, 8uLL) != 8)
  {
LABEL_13:
    LODWORD(v12) = 1;
    goto LABEL_14;
  }
  v12 = bswap32(v37[0]);
  if (v12 > (unint64_t)Size / 0x22)
  {
LABEL_20:
    LODWORD(v12) = 0;
    goto LABEL_14;
  }
  v14 = HIDWORD(v37[0]);
  v15 = IIOImageReadSession::globalInfoForType(a2, 1095781959);
  v16 = (uint64_t)v15;
  if (v15)
  {
    std::vector<fcTL_CHUNK>::resize((uint64_t)v15 + 8, 0);
  }
  else
  {
    v16 = operator new();
    GlobalPNGInfo::GlobalPNGInfo((GlobalPNGInfo *)v16);
    IIOImageReadSession::setGlobalInfo((IIOImageRead **)a2, 1095781959, (void *)v16, (void (*)(void *))globalPNGInfoReleaseProc);
  }
  *(_DWORD *)(v16 + 40) = v12;
  *(_DWORD *)(v16 + 44) = bswap32(v14);
  std::vector<fcTL_CHUNK>::resize(v16 + 8, v12);
  v17 = 0;
  v32 = 0;
  v18 = 0;
  v19 = 0;
  *(_DWORD *)(v16 + 32) = v35;
  *(_DWORD *)(v16 + 36) = v8;
  v20 = v9 + v10 + 12;
  memset(v36, 0, 34);
  while (2)
  {
    if (v12 <= v19)
      goto LABEL_52;
    if (IIOImageReadSession::getBytesAtOffset(a2, v37, v20, 8uLL) != 8)
    {
      ++v19;
      v18 = v12;
      goto LABEL_42;
    }
    v21 = v37[0];
    v22 = bswap32(HIDWORD(v37[0]));
    if (v22 == 1717846356)
    {
      ++v32;
      goto LABEL_41;
    }
    if (v22 != 1717785676)
      goto LABEL_41;
    IIOImageReadSession::getBytesAtOffset(a2, v36, v20 + 8, 0x22uLL);
    ++v17;
    *(_QWORD *)((char *)&v36[1] + 10) = v20;
    v23 = bswap32(v36[0]);
    LODWORD(v36[0]) = v23;
    if (v17 + v32 > v23)
    {
      v24 = bswap32(DWORD1(v36[0]));
      v25 = bswap32(DWORD2(v36[0]));
      *(_QWORD *)((char *)v36 + 4) = __PAIR64__(v25, v24);
      v26 = bswap32(HIDWORD(v36[0]));
      v27 = bswap32(v36[1]);
      HIDWORD(v36[0]) = v26;
      LODWORD(v36[1]) = v27;
      WORD2(v36[1]) = bswap32(WORD2(v36[1])) >> 16;
      v28 = WORD3(v36[1]);
      WORD3(v36[1]) = __rev16(WORD3(v36[1]));
      if ((v26 & 0x80000000) != 0 || (v27 & 0x80000000) != 0 || v24 < 1 || v25 < 1 || v26 + v24 > v35 || v27 + v25 > v8)
      {
        if (v18)
          LODWORD(v12) = v18 - 1;
        else
          LODWORD(v12) = 0;
        _cg_jpeg_mem_term("getImageCount", 420, "*** bad dimensions: PNG: %dx%d\n", v35, v8);
        _cg_jpeg_mem_term("getImageCount", 421, "    frame[%d]: {%d, %d, %d, %d}\n", v12, HIDWORD(v36[0]), LODWORD(v36[1]), DWORD1(v36[0]), DWORD2(v36[0]));
        goto LABEL_50;
      }
      if (!v28)
        strcpy((char *)&v36[1] + 6, "d");
      v29 = *(_QWORD *)(v16 + 8) + 34 * v18;
      v30 = v36[0];
      v31 = v36[1];
      *(_WORD *)(v29 + 32) = v36[2];
      *(_OWORD *)v29 = v30;
      *(_OWORD *)(v29 + 16) = v31;
      ++v18;
      ++v19;
LABEL_41:
      v20 += bswap32(v21) + 12;
LABEL_42:
      if (v20 > (unint64_t)Size)
      {
        if (v18)
          LODWORD(v12) = v18 - 1;
        else
          LODWORD(v12) = 0;
LABEL_50:
        *(_DWORD *)(v16 + 40) = v12;
        goto LABEL_14;
      }
      continue;
    }
    break;
  }
  _cg_jpeg_mem_term("getImageCount", 384, "*** bad fcTL.sequence_number: %d/%d\n", v23, v12);
  *(_DWORD *)(v16 + 40) = 1;
  std::vector<fcTL_CHUNK>::resize(v16 + 8, 1uLL);
  LODWORD(v12) = 1;
LABEL_52:
  if (v19 != v18)
  {
    _cg_jpeg_mem_term("getImageCount", 483, "frameLoop != fcTL_index (%d != %d) --> error while decoding frames\n", v19, v18);
    *(_DWORD *)(v16 + 40) = v18;
  }
LABEL_14:
  if (a5)
    *a5 = v12;
  return 0;
}

void sub_187E8ADEC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10B1C402BA5416ELL);
  _Unwind_Resume(a1);
}

IIOImageRead *IIOImageReadSession::getSize(IIOImageReadSession *this)
{
  IIOImageRead *result;

  result = (IIOImageRead *)*((_QWORD *)this + 4);
  if (result)
    return (IIOImageRead *)IIOImageRead::getSize(result);
  return result;
}

CFStringRef CGImageMetadataCreateSimpleStringFromCFValue(CFStringRef result, uint64_t a2)
{
  const __CFString *v3;
  CFTypeID v4;
  const __CFAllocator *v5;
  const __CFString *v6;
  CFTypeID v7;
  int Value;
  CFTypeID v9;
  const __CFAllocator *v10;
  double v11;
  CFTypeID v12;
  uint64_t Count;
  const __CFAllocator *v14;
  __CFArray *v15;
  CFIndex i;
  const void *ValueAtIndex;
  const void *SimpleStringFromCFValue;
  const void *v19;
  CFStringRef v20;
  const __CFNumber *v21;
  CFNumberType v22;
  double v23;
  const __CFAllocator *v24;
  uint64_t v25;
  const __CFNumber *v26;
  CFNumberType v27;
  const __CFAllocator *v28;
  double v29;
  const __CFNumber *v30;
  CFNumberType v31;
  const __CFAllocator *v32;
  double v33;
  double v34;
  uint64_t v35;
  uint64_t v36;
  double v37;
  uint64_t v38;
  unsigned int v39[2];
  double valuePtr;

  if (result)
  {
    v3 = result;
    v4 = CFGetTypeID(result);
    if (v4 == CFStringGetTypeID())
    {
      v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v6 = v3;
      return CFStringCreateCopy(v5, v6);
    }
    v7 = CFGetTypeID(v3);
    if (v7 == CFBooleanGetTypeID())
    {
      Value = CFBooleanGetValue((CFBooleanRef)v3);
      v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      if (Value == 1)
        v6 = CFSTR("True");
      else
        v6 = CFSTR("False");
      return CFStringCreateCopy(v5, v6);
    }
    v9 = CFGetTypeID(v3);
    if (v9 == CFNumberGetTypeID())
    {
      switch(CFNumberGetType((CFNumberRef)v3))
      {
        case kCFNumberSInt8Type:
          LOBYTE(valuePtr) = 0;
          if (!CFNumberGetValue((CFNumberRef)v3, kCFNumberSInt8Type, &valuePtr))
            return 0;
          v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          *(_QWORD *)&v11 = SLOBYTE(valuePtr);
          goto LABEL_54;
        case kCFNumberSInt16Type:
          LOWORD(valuePtr) = 0;
          if (!CFNumberGetValue((CFNumberRef)v3, kCFNumberSInt16Type, &valuePtr))
            return 0;
          v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          *(_QWORD *)&v11 = SLOWORD(valuePtr);
          goto LABEL_54;
        case kCFNumberSInt32Type:
          LODWORD(valuePtr) = 0;
          if (!CFNumberGetValue((CFNumberRef)v3, kCFNumberSInt32Type, &valuePtr))
            return 0;
          v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          *(_QWORD *)&v11 = SLODWORD(valuePtr);
          goto LABEL_54;
        case kCFNumberSInt64Type:
          valuePtr = 0.0;
          v21 = (const __CFNumber *)v3;
          v22 = kCFNumberSInt64Type;
          goto LABEL_43;
        case kCFNumberFloat32Type:
          LODWORD(valuePtr) = 0;
          if (!CFNumberGetValue((CFNumberRef)v3, kCFNumberFloat32Type, &valuePtr))
            return 0;
          if ((_DWORD)a2 == 2)
            goto LABEL_63;
          if ((_DWORD)a2 == 1)
            goto LABEL_48;
          *(_QWORD *)v39 = 0;
          v23 = *(float *)&valuePtr;
          goto LABEL_67;
        case kCFNumberFloat64Type:
          valuePtr = 0.0;
          if (!CFNumberGetValue((CFNumberRef)v3, kCFNumberFloat64Type, &valuePtr))
            return 0;
          if ((_DWORD)a2 == 2)
            goto LABEL_62;
          if ((_DWORD)a2 == 1)
            return CFStringCreateWithFormat(0, 0, CFSTR("%@"), v3, v38, *(_QWORD *)v39);
          *(_QWORD *)v39 = 0;
          v23 = valuePtr;
LABEL_67:
          SRationalApprox(v23, (int *)&v39[1], v39);
          LODWORD(v35) = v39[0];
          if (!v39[0])
            return 0;
          if ((_DWORD)a2 != 4 || v39[0] != 1)
          {
            LODWORD(v36) = v39[1];
            if ((int)v39[1] >= 2 && v39[1] < v39[0] && v39[1] + v39[0] / v39[1] * v39[1] - v39[0] == 1)
            {
              LODWORD(v35) = (v39[0] + 1) / v39[1];
              LODWORD(v36) = 1;
              v39[0] = v35;
              v39[1] = 1;
            }
            v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
            v36 = (int)v36;
            v35 = v35;
            return CFStringCreateWithFormat(v10, 0, CFSTR("%ld/%ld"), v36, v35, *(_QWORD *)v39);
          }
          v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          *(_QWORD *)&v11 = (int)v39[1];
LABEL_54:
          v37 = v11;
          return CFStringCreateWithFormat(v10, 0, CFSTR("%ld"), *(_QWORD *)&v37, v38, *(_QWORD *)v39);
        case kCFNumberCharType:
          LOBYTE(valuePtr) = 0;
          if (!CFNumberGetValue((CFNumberRef)v3, kCFNumberCharType, &valuePtr))
            return 0;
          v24 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          v25 = SLOBYTE(valuePtr);
          return CFStringCreateWithFormat(v24, 0, CFSTR("%d"), v25, v38, *(_QWORD *)v39);
        case kCFNumberShortType:
          LOWORD(valuePtr) = 0;
          if (!CFNumberGetValue((CFNumberRef)v3, kCFNumberShortType, &valuePtr))
            return 0;
          v24 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          v25 = SLOWORD(valuePtr);
          return CFStringCreateWithFormat(v24, 0, CFSTR("%d"), v25, v38, *(_QWORD *)v39);
        case kCFNumberIntType:
          LODWORD(valuePtr) = 0;
          if (!CFNumberGetValue((CFNumberRef)v3, kCFNumberIntType, &valuePtr))
            return 0;
          v24 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          v25 = LODWORD(valuePtr);
          return CFStringCreateWithFormat(v24, 0, CFSTR("%d"), v25, v38, *(_QWORD *)v39);
        case kCFNumberLongType:
          valuePtr = 0.0;
          v26 = (const __CFNumber *)v3;
          v27 = kCFNumberLongType;
          goto LABEL_52;
        case kCFNumberLongLongType:
          valuePtr = 0.0;
          v21 = (const __CFNumber *)v3;
          v22 = kCFNumberLongLongType;
LABEL_43:
          if (!CFNumberGetValue(v21, v22, &valuePtr))
            return 0;
          return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%lld"), *(_QWORD *)&valuePtr, v38, *(_QWORD *)v39);
        case kCFNumberFloatType:
          LODWORD(valuePtr) = 0;
          if (!CFNumberGetValue((CFNumberRef)v3, kCFNumberFloatType, &valuePtr))
            return 0;
          if ((_DWORD)a2 == 2)
          {
LABEL_63:
            v32 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
            v33 = *(float *)&valuePtr;
            return CFStringCreateWithFormat(v32, 0, CFSTR("%g"), *(_QWORD *)&v33, v38, *(_QWORD *)v39);
          }
          if ((_DWORD)a2 == 1)
          {
LABEL_48:
            v28 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
            v29 = *(float *)&valuePtr;
            return CFStringCreateWithFormat(v28, 0, CFSTR("%f"), *(_QWORD *)&v29, v38, *(_QWORD *)v39);
          }
          *(_QWORD *)v39 = 0;
          v34 = *(float *)&valuePtr;
          goto LABEL_72;
        case kCFNumberDoubleType:
          valuePtr = 0.0;
          v30 = (const __CFNumber *)v3;
          v31 = kCFNumberDoubleType;
          goto LABEL_57;
        case kCFNumberCFIndexType:
          valuePtr = 0.0;
          v26 = (const __CFNumber *)v3;
          v27 = kCFNumberCFIndexType;
          goto LABEL_52;
        case kCFNumberNSIntegerType:
          valuePtr = 0.0;
          v26 = (const __CFNumber *)v3;
          v27 = kCFNumberNSIntegerType;
LABEL_52:
          if (!CFNumberGetValue(v26, v27, &valuePtr))
            return 0;
          v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          v11 = valuePtr;
          goto LABEL_54;
        case kCFNumberCGFloatType:
          valuePtr = 0.0;
          v30 = (const __CFNumber *)v3;
          v31 = kCFNumberCGFloatType;
LABEL_57:
          if (!CFNumberGetValue(v30, v31, &valuePtr))
            return 0;
          if ((_DWORD)a2 == 2)
          {
LABEL_62:
            v32 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
            v33 = valuePtr;
            return CFStringCreateWithFormat(v32, 0, CFSTR("%g"), *(_QWORD *)&v33, v38, *(_QWORD *)v39);
          }
          if ((_DWORD)a2 == 1)
          {
            v28 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
            v29 = valuePtr;
            return CFStringCreateWithFormat(v28, 0, CFSTR("%f"), *(_QWORD *)&v29, v38, *(_QWORD *)v39);
          }
          *(_QWORD *)v39 = 0;
          v34 = valuePtr;
LABEL_72:
          SRationalApprox(v34, (int *)&v39[1], v39);
          v35 = v39[0];
          if (v39[0])
          {
            v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
            v36 = (int)v39[1];
            if ((_DWORD)a2 != 4 || v39[0] != 1)
              return CFStringCreateWithFormat(v10, 0, CFSTR("%ld/%ld"), v36, v35, *(_QWORD *)v39);
            *(_QWORD *)&v37 = (int)v39[1];
            return CFStringCreateWithFormat(v10, 0, CFSTR("%ld"), *(_QWORD *)&v37, v38, *(_QWORD *)v39);
          }
          break;
        default:
          return 0;
      }
      return 0;
    }
    v12 = CFGetTypeID(v3);
    if (v12 != CFArrayGetTypeID())
      return 0;
    Count = CFArrayGetCount((CFArrayRef)v3);
    v14 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    result = (CFStringRef)CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], Count, MEMORY[0x1E0C9B378]);
    if (result)
    {
      v15 = (__CFArray *)result;
      if (Count >= 1)
      {
        for (i = 0; i != Count; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v3, i);
          SimpleStringFromCFValue = (const void *)CGImageMetadataCreateSimpleStringFromCFValue(ValueAtIndex, a2);
          if (SimpleStringFromCFValue)
          {
            v19 = SimpleStringFromCFValue;
            CFArraySetValueAtIndex(v15, i, SimpleStringFromCFValue);
            CFRelease(v19);
          }
        }
      }
      v20 = CFStringCreateByCombiningStrings(v14, v15, CFSTR("; "));
      CFRelease(v15);
      return v20;
    }
  }
  return result;
}

uint64_t GlobalHEIFInfo::setPrimaryImageIndex(uint64_t this, unsigned int a2)
{
  if (a2 < (unint64_t)((uint64_t)(*(_QWORD *)(this + 16) - *(_QWORD *)(this + 8)) >> 3))
    *(_DWORD *)(this + 64) = a2;
  return this;
}

void GlobalHEIFInfo::addHEIFMainImage(GlobalHEIFInfo *this, HEIFMainImage *a2)
{
  char *v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  void **v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v6 = *((_QWORD *)this + 3);
  v4 = (char *)this + 24;
  v5 = v6;
  v7 = (_QWORD *)*((_QWORD *)v4 - 1);
  if ((unint64_t)v7 >= v6)
  {
    v9 = (void **)(v4 - 16);
    v10 = *((_QWORD *)v4 - 2);
    v11 = ((uint64_t)v7 - v10) >> 3;
    if ((unint64_t)(v11 + 1) >> 61)
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    v12 = v5 - v10;
    v13 = v12 >> 2;
    if (v12 >> 2 <= (unint64_t)(v11 + 1))
      v13 = v11 + 1;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
      v14 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v14 = v13;
    if (v14)
      v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)v4, v14);
    else
      v15 = 0;
    v16 = &v15[8 * v11];
    v17 = &v15[8 * v14];
    *(_QWORD *)v16 = a2;
    v8 = v16 + 8;
    v19 = (char *)*((_QWORD *)this + 1);
    v18 = (char *)*((_QWORD *)this + 2);
    if (v18 != v19)
    {
      do
      {
        v20 = *((_QWORD *)v18 - 1);
        v18 -= 8;
        *((_QWORD *)v16 - 1) = v20;
        v16 -= 8;
      }
      while (v18 != v19);
      v18 = (char *)*v9;
    }
    *((_QWORD *)this + 1) = v16;
    *((_QWORD *)this + 2) = v8;
    *((_QWORD *)this + 3) = v17;
    if (v18)
      operator delete(v18);
  }
  else
  {
    *v7 = a2;
    v8 = v7 + 1;
  }
  *((_QWORD *)this + 2) = v8;
}

uint64_t IIOImageRead::trustedURL(IIOImageRead *this)
{
  return *((unsigned __int8 *)this + 71);
}

IIOImageRead *myTIFFSizeProc(IIOImageReadSession **a1)
{
  IIOImageWriteSession *v2;

  if (!a1)
    return 0;
  if (a1[2])
    return IIOImageReadSession::getSize(a1[2]);
  v2 = a1[3];
  if (v2)
    return (IIOImageRead *)IIOImageWriteSession::getSize(v2);
  else
    return 0;
}

void std::vector<fcTL_CHUNK>::__append(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  char *v14;
  char *v15;
  size_t v16;
  char *v17;
  char *v18;
  char *v19;
  __int128 v20;
  __int128 v21;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (0xF0F0F0F0F0F0F0F1 * ((v6 - v7) >> 1) >= a2)
  {
    if (a2)
    {
      v13 = 34 * ((34 * a2 - 34) / 0x22) + 34;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xF0F0F0F0F0F0F0F1 * ((v7 - (_BYTE *)*a1) >> 1);
    v9 = v8 + a2;
    if (v8 + a2 > 0x787878787878787)
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    v10 = 0xF0F0F0F0F0F0F0F1 * ((v5 - (_BYTE *)*a1) >> 1);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x3C3C3C3C3C3C3C3)
      v11 = 0x787878787878787;
    else
      v11 = v9;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<fcTL_CHUNK>>(v4, v11);
    else
      v12 = 0;
    v14 = &v12[34 * v8];
    v15 = &v12[34 * v11];
    v16 = 34 * ((34 * a2 - 34) / 0x22) + 34;
    bzero(v14, v16);
    v17 = &v14[v16];
    v19 = (char *)*a1;
    v18 = (char *)a1[1];
    if (v18 != *a1)
    {
      do
      {
        v20 = *(_OWORD *)(v18 - 34);
        v21 = *(_OWORD *)(v18 - 18);
        *((_WORD *)v14 - 1) = *((_WORD *)v18 - 1);
        *(_OWORD *)(v14 - 18) = v21;
        *(_OWORD *)(v14 - 34) = v20;
        v14 -= 34;
        v18 -= 34;
      }
      while (v18 != v19);
      v18 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v17;
    a1[2] = v15;
    if (v18)
      operator delete(v18);
  }
}

void std::vector<fcTL_CHUNK>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;

  v2 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 1);
  v3 = a2 >= v2;
  v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<fcTL_CHUNK>::__append((void **)a1, v4);
  }
  else if (!v3)
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 34 * a2;
  }
}

void GlobalPNGInfo::GlobalPNGInfo(GlobalPNGInfo *this)
{
  *(_QWORD *)this = &off_1E1BACC28;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 80), 0);
  *((_QWORD *)this + 8) = 0;
  *((_BYTE *)this + 72) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_DWORD *)this + 14) = 0;
}

void sub_187E8B748(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void *v5;

  v3 = v2;
  v5 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 16) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CGColorSpaceCreateWithCopyOfData(UInt8 *bytes, unint64_t length)
{
  CFDataRef v2;
  CFDataRef v3;
  uint64_t v4;

  if (!bytes)
    return 0;
  if (length < 0xFB)
    return 0;
  v2 = CFDataCreate(0, bytes, length);
  if (!v2)
    return 0;
  v3 = v2;
  v4 = MEMORY[0x18D760CAC]();
  CFRelease(v3);
  return v4;
}

uint64_t _CGImageDestinationFinalize(_QWORD *a1)
{
  unint64_t v2;
  uint64_t result;

  do
    v2 = __ldxr(&gIDRCount);
  while (__stxr(v2 - 1, &gIDRCount));
  result = a1[3];
  if (result)
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  a1[2] = 0;
  a1[3] = 0;
  return result;
}

void IIOImageDestination::~IIOImageDestination(IIOImageDestination *this)
{
  IIOImageDestination::~IIOImageDestination(this);
  JUMPOUT(0x18D761C30);
}

{
  const void *v2;
  _QWORD *v3;
  const void *v4;
  uint64_t v5;
  const void *v6;
  CGImageRef *i;
  _QWORD *j;
  _QWORD *v9;
  CGImage *v10;
  uint64_t v11;
  const void *v12;
  void *v13;
  void *v14;

  *(_QWORD *)this = &off_1E1BB1BB0;
  v3 = (_QWORD *)((char *)this + 16);
  v2 = (const void *)*((_QWORD *)this + 2);
  if (v2)
    CFRelease(v2);
  *v3 = 0;
  v3[1] = 0;
  v4 = (const void *)*((_QWORD *)this + 20);
  if (v4)
    CFRelease(v4);
  *((_QWORD *)this + 20) = 0;
  v5 = *((_QWORD *)this + 11);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  *((_QWORD *)this + 11) = 0;
  v6 = (const void *)*((_QWORD *)this + 12);
  if (v6)
    CFRelease(v6);
  *((_QWORD *)this + 12) = 0;
  for (i = (CGImageRef *)*((_QWORD *)this + 13); i != *((CGImageRef **)this + 14); ++i)
    CGImageRelease(*i);
  v9 = (_QWORD *)*((_QWORD *)this + 16);
  for (j = (_QWORD *)*((_QWORD *)this + 17); v9 != j; ++v9)
  {
    if (*v9)
    {
      (*(void (**)(_QWORD))(*(_QWORD *)*v9 + 8))(*v9);
      j = (_QWORD *)*((_QWORD *)this + 17);
    }
  }
  v10 = (CGImage *)*((_QWORD *)this + 21);
  if (v10)
  {
    CGImageRelease(v10);
    *((_QWORD *)this + 21) = 0;
  }
  v11 = *((_QWORD *)this + 4);
  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
  *((_QWORD *)this + 4) = 0;
  v12 = (const void *)*((_QWORD *)this + 19);
  if (v12)
    CFRelease(v12);
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0;
  v13 = (void *)*((_QWORD *)this + 16);
  if (v13)
  {
    *((_QWORD *)this + 17) = v13;
    operator delete(v13);
  }
  v14 = (void *)*((_QWORD *)this + 13);
  if (v14)
  {
    *((_QWORD *)this + 14) = v14;
    operator delete(v14);
  }
}

char *CreateExifBufferFromPropertiesJPEG(IIODictionary *a1, uint64_t a2, unsigned int a3, CGColorSpace *a4, const __CFData *a5, const __CFString *a6, unint64_t *a7)
{
  uint64_t v7;
  uint64_t *v8;
  uint64_t *v9;
  const void *v10;
  const void *v11;
  const __CFData *v12;
  const __CFData *v13;
  CGColorSpace *v14;
  CGColorSpace *v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  IIODictionary *v20;
  CGColorSpace *v21;
  const __CFDictionary *ObjectForKey;
  IIODictionary *v23;
  const __CFDictionary *v24;
  IIODictionary *v25;
  IIODictionary *v26;
  const __CFDictionary *v27;
  const __CFDictionary *v28;
  const __CFDictionary *v29;
  const __CFDictionary *v30;
  const __CFDictionary *v31;
  const __CFDictionary *v32;
  const __CFDictionary *v33;
  const __CFDictionary *v34;
  const __CFDictionary *v35;
  CFTypeID v36;
  const __CFDictionary *ObjectForKeyGroup;
  const __CFDictionary *v38;
  const __CFDictionary *v39;
  const __CFDictionary *v40;
  __CFDictionary *v41;
  IIODictionary *v42;
  uint64_t v43;
  unsigned __int16 *v44;
  const __CFString **v45;
  const __CFString *v46;
  unint64_t valid;
  unsigned __int16 **v48;
  uint64_t *v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  unsigned __int16 *v53;
  int v54;
  const __CFString **v55;
  const __CFString *v56;
  unint64_t v57;
  const char *v58;
  _QWORD *v59;
  _QWORD *v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  __int16 *v64;
  const __CFString **v65;
  const __CFString *v66;
  unint64_t v67;
  _QWORD *v68;
  _QWORD *v69;
  int v70;
  uint64_t v71;
  __int16 *v72;
  const __CFString **v73;
  const __CFString *v74;
  unint64_t v75;
  _QWORD *v76;
  _QWORD *v77;
  int v78;
  uint64_t v79;
  char *v80;
  IIODictionary *v81;
  IIODictionary *v82;
  IIODictionary *v83;
  IIODictionary *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  CFIndex v90;
  char *v91;
  char v92;
  char *v93;
  unsigned __int8 *v94;
  unint64_t *v95;
  unsigned __int16 *v96;
  unsigned int v97;
  int v98;
  int v99;
  unint64_t v101;
  uint64_t v102;
  unsigned __int8 *v103;
  uint64_t *v104;
  unsigned __int8 *v105;
  unsigned __int16 *v106;
  unsigned int v107;
  unsigned int v108;
  unsigned int v110;
  uint64_t v111;
  uint64_t v112;
  unsigned __int8 *v113;
  unint64_t *v114;
  unsigned __int16 *v115;
  unsigned int v116;
  unsigned int v117;
  unint64_t v118;
  unsigned int v119;
  uint64_t v120;
  uint64_t v121;
  unsigned int v122;
  unsigned __int8 *v123;
  unint64_t *v124;
  unsigned __int16 *v125;
  unsigned int v126;
  int v127;
  unsigned int v128;
  unint64_t v129;
  unsigned int v130;
  uint64_t v131;
  const __CFArray *theArray;
  CFTypeID v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  const UInt8 *__src;
  uint64_t v142;
  uint64_t v143;
  uint64_t *v144;
  char *v145;
  CFIndex __n;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  unsigned int v150;
  IIODictionary *v151;
  IIODictionary *v152;
  uint64_t v153;
  IIODictionary *v154;
  IIODictionary *v155;
  _BYTE v156[24];
  _BYTE v157[24];
  _BYTE v158[24];
  _BYTE v159[24];
  _BYTE v160[24];
  _BYTE v161[24];
  _BYTE v162[24];
  _BYTE v163[24];
  __int128 v164;
  _OWORD v165[23];
  _BYTE v166[16];
  uint64_t v167;
  _BYTE v168[16];
  uint64_t v169;
  _BYTE v170[16];
  _QWORD v171[136];

  v7 = MEMORY[0x1E0C80A78](a1, a2);
  v9 = v8;
  v11 = v10;
  v13 = v12;
  v15 = v14;
  v17 = v16;
  v19 = v18;
  v20 = (IIODictionary *)v7;
  v171[134] = *MEMORY[0x1E0C80C00];
  bzero(v170, 0x440uLL);
  bzero(v168, 0x9A0uLL);
  bzero(v166, 0x420uLL);
  v164 = 0u;
  memset(v165, 0, sizeof(v165));
  if (!v20)
  {
    v79 = 0;
    v80 = 0;
    if (v9)
      goto LABEL_215;
    return v80;
  }
  v21 = v15;
  ObjectForKey = IIODictionary::getObjectForKey(v20, CFSTR("{TIFF}"));
  v23 = (IIODictionary *)operator new();
  v155 = v23;
  v150 = v17;
  if (ObjectForKey)
    IIODictionary::IIODictionary(v23, ObjectForKey, 0);
  else
    IIODictionary::IIODictionary(v23);
  v24 = IIODictionary::getObjectForKey(v20, CFSTR("{Exif}"));
  v25 = (IIODictionary *)operator new();
  v26 = v25;
  v144 = v9;
  if (v24)
    IIODictionary::IIODictionary(v25, v24, 0);
  else
    IIODictionary::IIODictionary(v25);
  if (CFEqual(v11, CFSTR("public.jpeg")) && IIODictionary::containsKey(v155, CFSTR("Compression")))
    IIODictionary::removeObjectForKey(v155, CFSTR("Compression"));
  v154 = v26;
  if (IIODictionary::containsKey(v20, CFSTR("Orientation")))
  {
    v27 = IIODictionary::getObjectForKey(v20, CFSTR("Orientation"));
    IIODictionary::setObjectForKey(v155, v27, CFSTR("Orientation"));
  }
  if (IIODictionary::containsKey(v20, CFSTR("DPIWidth"))
    && IIODictionary::containsKey(v20, CFSTR("DPIHeight")))
  {
    if ((IIODictionary::containsKey(v155, CFSTR("XResolution")) & 1) == 0
      && (IIODictionary::containsKey(v155, CFSTR("YResolution")) & 1) == 0)
    {
      IIONumber::IIONumber((IIONumber *)v163, 2);
      IIODictionary::setObjectForKey((uint64_t)v155, (uint64_t)v163, CFSTR("ResolutionUnit"));
      IIONumber::~IIONumber((IIONumber *)v163);
    }
    v28 = IIODictionary::getObjectForKey(v20, CFSTR("DPIWidth"));
    IIODictionary::setObjectForKey(v155, v28, CFSTR("XResolution"));
    v29 = IIODictionary::getObjectForKey(v20, CFSTR("DPIHeight"));
    IIODictionary::setObjectForKey(v155, v29, CFSTR("YResolution"));
  }
  if (v13)
  {
    __src = CFDataGetBytePtr(v13);
    __n = CFDataGetLength(v13);
    v152 = (IIODictionary *)operator new();
    IIODictionary::IIODictionary(v152);
    IIONumber::IIONumber((IIONumber *)v162, 6);
    IIODictionary::setObjectForKey((uint64_t)v152, (uint64_t)v162, CFSTR("Compression"));
    IIONumber::~IIONumber((IIONumber *)v162);
    if (IIODictionary::containsKey(v155, CFSTR("Orientation")))
    {
      v30 = IIODictionary::getObjectForKey(v155, CFSTR("Orientation"));
      IIODictionary::setObjectForKey(v152, v30, CFSTR("Orientation"));
    }
    if (IIODictionary::containsKey(v155, CFSTR("XResolution")))
    {
      v31 = IIODictionary::getObjectForKey(v155, CFSTR("XResolution"));
      IIODictionary::setObjectForKey(v152, v31, CFSTR("XResolution"));
    }
    if (IIODictionary::containsKey(v155, CFSTR("YResolution")))
    {
      v32 = IIODictionary::getObjectForKey(v155, CFSTR("YResolution"));
      IIODictionary::setObjectForKey(v152, v32, CFSTR("YResolution"));
    }
    if (IIODictionary::containsKey(v155, CFSTR("ResolutionUnit")))
    {
      v33 = IIODictionary::getObjectForKey(v155, CFSTR("ResolutionUnit"));
      IIODictionary::setObjectForKey(v152, v33, CFSTR("ResolutionUnit"));
    }
    IIONumber::IIONumber((IIONumber *)v161, 3405695742);
    IIODictionary::setObjectForKey((uint64_t)v152, (uint64_t)v161, CFSTR("JPEGInterchangeFormat"));
    IIONumber::~IIONumber((IIONumber *)v161);
    IIONumber::IIONumber((IIONumber *)v160, __n);
    IIODictionary::setObjectForKey((uint64_t)v152, (uint64_t)v160, CFSTR("JPEGInterchangeFormatLength"));
    IIONumber::~IIONumber((IIONumber *)v160);
  }
  else
  {
    v152 = 0;
    __n = 0;
    __src = 0;
  }
  if (IIODictionary::containsKey(v20, CFSTR("{MakerApple}")))
  {
    v34 = IIODictionary::getObjectForKey(v20, CFSTR("{MakerApple}"));
    IIODictionary::setObjectForKey(v26, v34, CFSTR("MakerNote"));
  }
  else
  {
    v35 = IIODictionary::getObjectForKey(v26, CFSTR("MakerNote"));
    if (v35)
    {
      v36 = CFGetTypeID(v35);
      if (v36 != CFStringGetTypeID())
        IIODictionary::removeObjectForKey(v26, CFSTR("MakerNote"));
    }
  }
  if (v19)
  {
    IIONumber::IIONumber((IIONumber *)v159, v19);
    IIODictionary::setObjectForKey((uint64_t)v26, (uint64_t)v159, CFSTR("PixelXDimension"));
    IIONumber::~IIONumber((IIONumber *)v159);
  }
  else if (IIODictionary::containsKeyGroup(v20, CFSTR("PixelXDimension"), CFSTR("{Exif}")))
  {
    ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup(v20, CFSTR("PixelXDimension"), CFSTR("{Exif}"));
    IIODictionary::setObjectForKey(v26, ObjectForKeyGroup, CFSTR("PixelXDimension"));
  }
  if (v150)
  {
    IIONumber::IIONumber((IIONumber *)v158, v150);
    IIODictionary::setObjectForKey((uint64_t)v26, (uint64_t)v158, CFSTR("PixelYDimension"));
    IIONumber::~IIONumber((IIONumber *)v158);
  }
  else if (IIODictionary::containsKeyGroup(v20, CFSTR("PixelYDimension"), CFSTR("{Exif}")))
  {
    v38 = IIODictionary::getObjectForKeyGroup(v20, CFSTR("PixelYDimension"), CFSTR("{Exif}"));
    IIODictionary::setObjectForKey(v26, v38, CFSTR("PixelYDimension"));
  }
  if (v21)
  {
    if (IIO_CGColorSpaceNameMatchesName(v21, (const __CFString *)*MEMORY[0x1E0C9DA10]))
    {
      IIONumber::IIONumber((IIONumber *)v157, 1);
      IIODictionary::setObjectForKey((uint64_t)v26, (uint64_t)v157, CFSTR("ColorSpace"));
      IIONumber::~IIONumber((IIONumber *)v157);
    }
    else if (IIODictionary::containsKey(v26, CFSTR("ColorSpace")))
    {
      IIODictionary::removeObjectForKey(v26, CFSTR("ColorSpace"));
    }
  }
  else if (IIODictionary::containsKeyGroup(v20, CFSTR("ColorSpace"), CFSTR("{Exif}")))
  {
    v39 = IIODictionary::getObjectForKeyGroup(v20, CFSTR("ColorSpace"), CFSTR("{Exif}"));
    IIODictionary::setObjectForKey(v26, v39, CFSTR("ColorSpace"));
  }
  v40 = IIODictionary::getObjectForKey(v20, CFSTR("{GPS}"));
  v41 = v40;
  v42 = 0;
  if (v40 && v40 != (const __CFDictionary *)*MEMORY[0x1E0C9B0D0])
  {
    v42 = (IIODictionary *)operator new();
    IIODictionary::IIODictionary(v42, v41);
  }
  v151 = v42;
  v153 = 0;
  v43 = 0;
  v44 = tagdefsIFD0;
  do
  {
    v45 = (const __CFString **)*((_QWORD *)v44 + 5);
    if (v45)
      v46 = (const __CFString *)IIODictionary::getObjectForKey(v155, *v45);
    else
      v46 = 0;
    valid = validValueForKey(v44, v46);
    if (valid)
    {
      v48 = (unsigned __int16 **)&v170[32 * v43];
      *v48 = v44;
      v48[1] = (unsigned __int16 *)v46;
      v48[2] = (unsigned __int16 *)valid;
      v48[3] = 0;
      v49 = (uint64_t *)(v48 + 3);
      if (valid >= 5)
      {
        *v49 = v153;
        v153 += valid + (valid & 1);
      }
      ++v43;
    }
    v50 = (__int16)v44[28];
    v44 += 28;
  }
  while (v50 != -1);
  v51 = 0;
  v52 = 0;
  v53 = (unsigned __int16 *)&tagdefsExif;
  v54 = 33434;
  do
  {
    v55 = (const __CFString **)*((_QWORD *)v53 + 5);
    if (v55)
    {
      v56 = (const __CFString *)IIODictionary::getObjectForKey(v26, *v55);
      v57 = validValueForKey(v53, v56);
      if (!v57)
      {
        if (v56)
        {
          IIOString::IIOString((IIOString *)v156, *v55);
          v58 = (const char *)IIOString::utf8String((IIOString *)v156);
          _cg_jpeg_mem_term("CreateExifBufferFromPropertiesJPEG", 3993, "Invalid value (%p) for tag 0x%04X  '%s'\n", v56, v54, v58);
          IIOString::~IIOString((IIOString *)v156);
        }
        goto LABEL_72;
      }
    }
    else
    {
      v57 = validValueForKey(v53, 0);
      if (!v57)
        goto LABEL_72;
      v56 = 0;
    }
    v59 = &v168[32 * v52];
    *v59 = v53;
    v59[1] = v56;
    v59[2] = v57;
    v59[3] = 0;
    v60 = v59 + 3;
    if (v57 >= 5)
    {
      *v60 = v51;
      v51 += v57 + (v57 & 1);
    }
    ++v52;
LABEL_72:
    v61 = v53[28];
    v53 += 28;
    v54 = v61;
  }
  while (v61 != 0xFFFF);
  if (v151)
  {
    v62 = 0;
    v63 = 0;
    v64 = (__int16 *)&tagdefsGPS;
    do
    {
      v65 = (const __CFString **)*((_QWORD *)v64 + 5);
      if (v65)
        v66 = (const __CFString *)IIODictionary::getObjectForKey(v151, *v65);
      else
        v66 = 0;
      v67 = validValueForKey((unsigned __int16 *)v64, v66);
      if (v67)
      {
        v68 = &v166[32 * v63];
        *v68 = v64;
        v68[1] = v66;
        v68[2] = v67;
        v68[3] = 0;
        v69 = v68 + 3;
        if (v67 >= 5)
        {
          *v69 = v62;
          v62 += v67 + (v67 & 1);
        }
        ++v63;
      }
      v70 = v64[28];
      v64 += 28;
    }
    while (v70 != -1);
  }
  else
  {
    v63 = 0;
    v62 = 0;
  }
  if (!v152)
  {
    v71 = 0;
    v149 = 0;
    if (v43)
      goto LABEL_101;
    goto LABEL_98;
  }
  v149 = 0;
  v71 = 0;
  v72 = (__int16 *)&tagdefsIFD1;
  do
  {
    v73 = (const __CFString **)*((_QWORD *)v72 + 5);
    if (v73)
      v74 = (const __CFString *)IIODictionary::getObjectForKey(v152, *v73);
    else
      v74 = 0;
    v75 = validValueForKey((unsigned __int16 *)v72, v74);
    if (v75)
    {
      v76 = &v165[2 * v71 - 1];
      *v76 = v72;
      v76[1] = v74;
      v76[2] = v75;
      v76[3] = 0;
      v77 = v76 + 3;
      if (v75 >= 5)
      {
        *v77 = v149;
        v149 += v75 + (v75 & 1);
      }
      ++v71;
    }
    v78 = v72[28];
    v72 += 28;
  }
  while (v78 != -1);
  if (!v43)
  {
LABEL_98:
    if (v52 || v63)
      goto LABEL_101;
    v79 = 0;
    v80 = 0;
    v9 = v144;
    v82 = v154;
    v81 = v155;
    v84 = v151;
    v83 = v152;
    goto LABEL_210;
  }
LABEL_101:
  v85 = 6;
  if (v52)
    v85 = 18;
  v86 = v85 + 12 * v43;
  v148 = 12 * v52 + 6;
  v87 = v148 + v51;
  if (!v52)
    v87 = 0;
  if (v63)
    v86 += 12;
  v143 = v86;
  v88 = v86 + v153;
  if (v63)
    v89 = 12 * v63 + 6 + v62;
  else
    v89 = 0;
  v138 = 12 * v71 + 6;
  v139 = v87;
  v90 = v149 + __n + v138;
  if (!v71)
    v90 = 0;
  v142 = v86 + v153;
  v140 = v89;
  v147 = v88 + v87;
  v135 = v88 + v87 + v89 + 14;
  v136 = 12 * v63 + 6;
  v137 = v135 + v90;
  v91 = (char *)malloc_type_calloc(1uLL, v135 + v90, 0xE5106A40uLL);
  v145 = v91;
  if (v91)
  {
    if (v52)
      v92 = v43 + 1;
    else
      v92 = v43;
    *(_QWORD *)v91 = *(_QWORD *)"Exif";
    *(_QWORD *)(v91 + 6) = 0x80000002A004D4DLL;
    if (v63)
      ++v92;
    v91[15] = v92;
    if (v43)
    {
      v93 = v91 + 6;
      v94 = (unsigned __int8 *)(v91 + 24);
      v95 = v171;
      do
      {
        v96 = (unsigned __int16 *)*(v95 - 2);
        v97 = *v96;
        v98 = v96[1];
        if (v98 == 32771)
          v99 = 4;
        else
          v99 = v98;
        *((_WORD *)v94 - 4) = __rev16(v97);
        *((_WORD *)v94 - 3) = __rev16(v99);
        if (v99 == 7 || v99 == 2)
        {
          v101 = *v95;
          *((_DWORD *)v94 - 1) = bswap32(*v95);
        }
        else
        {
          *((_DWORD *)v94 - 1) = 0x1000000;
          v101 = *v95;
        }
        if (v101 < 5)
        {
          *(_DWORD *)v94 = 0;
          WriteValueForTagID((const __CFString *)*(v95 - 1), v101, v97, v99, 0, v94);
        }
        else
        {
          v102 = v143 + 8 + v95[1];
          *(_DWORD *)v94 = bswap32(v102);
          WriteValueForTagID((const __CFString *)*(v95 - 1), v101, v97, v99, 0, (unsigned __int8 *)&v93[v102]);
        }
        v94 += 12;
        v95 += 4;
        --v43;
      }
      while (v43);
      v103 = v94 - 8;
      if (v52)
      {
LABEL_134:
        *(_QWORD *)v103 = 0x100000004006987;
        *((_DWORD *)v103 + 2) = bswap32(v142 + 8);
        v103 += 12;
      }
    }
    else
    {
      v103 = (unsigned __int8 *)(v91 + 16);
      if (v52)
        goto LABEL_134;
    }
    if (v63)
    {
      *(_QWORD *)v103 = 0x100000004002588;
      *((_DWORD *)v103 + 2) = bswap32(v147 + 8);
      v103 += 12;
    }
    if (v71)
      *(_DWORD *)v103 = bswap32(v147 + v140 + 8);
    if (v52)
    {
      v145[v142 + 15] = v52;
      v104 = &v169;
      v105 = (unsigned __int8 *)&v145[v143 + 24 + v153];
      do
      {
        v106 = (unsigned __int16 *)*(v104 - 2);
        v107 = *v106;
        if (v106[1] == 32771)
          v108 = 4;
        else
          v108 = v106[1];
        *((_WORD *)v105 - 4) = __rev16(v107);
        *((_WORD *)v105 - 3) = __rev16(v108);
        if (v107 == 36864 || v107 == 37121)
        {
          v110 = 0x4000000;
        }
        else if (v107 == 42081)
        {
          v110 = 0x2000000;
        }
        else
        {
          if (v108 > 0xA)
            goto LABEL_157;
          if (((1 << v108) & 0x86) != 0)
          {
            v110 = bswap32(*(_DWORD *)v104);
          }
          else
          {
            if (((1 << v108) & 0x420) == 0)
            {
LABEL_157:
              if (v106[2]
                || (theArray = (const __CFArray *)*(v104 - 1), v134 = CFGetTypeID(theArray), v134 != CFArrayGetTypeID()))
              {
                v110 = 0x1000000;
              }
              else
              {
                v110 = bswap32(CFArrayGetCount(theArray));
              }
              goto LABEL_161;
            }
            v110 = bswap32((unint64_t)*v104 >> 3);
          }
        }
LABEL_161:
        *((_DWORD *)v105 - 1) = v110;
        v111 = *v104;
        if ((unint64_t)*v104 < 5)
        {
          *(_DWORD *)v105 = 0;
          WriteValueForTagID((const __CFString *)*(v104 - 1), v111, v107, v108, 0, v105);
        }
        else
        {
          v112 = v142 + v148 + 8 + v104[1];
          *(_DWORD *)v105 = bswap32(v112);
          WriteValueForTagID((const __CFString *)*(v104 - 1), v111, v107, v108, 0, (unsigned __int8 *)&v145[v112 + 6]);
        }
        v104 += 4;
        v105 += 12;
        --v52;
      }
      while (v52);
    }
    if (v63)
    {
      v145[v147 + 15] = v63;
      v113 = (unsigned __int8 *)&v145[v153 + 24 + v143 + v139];
      v114 = (unint64_t *)&v167;
      do
      {
        v115 = (unsigned __int16 *)*(v114 - 2);
        v116 = *v115;
        v117 = v115[1];
        if (v117 >= 0xB)
        {
          if (v117 == 32775)
          {
            *((_WORD *)v113 - 4) = __rev16(v116);
            *((_WORD *)v113 - 3) = 1280;
            v117 = 5;
LABEL_177:
            v118 = *v114;
            v119 = bswap32(*v114 >> 3);
            goto LABEL_178;
          }
          if (v117 == 32771)
          {
            *((_WORD *)v113 - 4) = __rev16(v116);
            *((_WORD *)v113 - 3) = 1024;
            v117 = 4;
LABEL_179:
            *((_DWORD *)v113 - 1) = 0x1000000;
            v118 = *v114;
            goto LABEL_180;
          }
          _cg_jpeg_mem_term("CreateExifBufferFromPropertiesJPEG", 4289, "*** tagType '%d' [0x%04X] not handled\n", v117, v117);
        }
        *((_WORD *)v113 - 4) = __rev16(v116);
        *((_WORD *)v113 - 3) = __rev16(v117);
        if (v117 > 0xA)
          goto LABEL_179;
        if (((1 << v117) & 0x86) == 0)
        {
          if (((1 << v117) & 0x420) == 0)
            goto LABEL_179;
          goto LABEL_177;
        }
        v118 = *v114;
        v119 = bswap32(*v114);
LABEL_178:
        *((_DWORD *)v113 - 1) = v119;
LABEL_180:
        if (v118 < 5)
        {
          *(_DWORD *)v113 = 0;
          WriteValueForTagID((const __CFString *)*(v114 - 1), v118, v116, v117, 0, v113);
        }
        else
        {
          v120 = v147 + v136 + 8 + v114[1];
          *(_DWORD *)v113 = bswap32(v120);
          WriteValueForTagID((const __CFString *)*(v114 - 1), v118, v116, v117, 0, (unsigned __int8 *)&v145[v120 + 6]);
        }
        v113 += 12;
        v114 += 4;
        --v63;
      }
      while (v63);
    }
    if (v71)
    {
      v145[v147 + 15 + v140] = v71;
      v121 = (uint64_t)&v145[v142 + 16 + v139 + v140];
      v122 = bswap32(v147 + v140 + 8 + v149 + v138);
      v123 = (unsigned __int8 *)&v145[v139 + 24 + v143 + v140 + v153];
      v124 = (unint64_t *)v165;
      while (1)
      {
        v125 = (unsigned __int16 *)*(v124 - 2);
        v126 = *v125;
        v127 = v125[1];
        v128 = v127 == 32771 ? 4 : v127;
        *((_WORD *)v123 - 4) = __rev16(v126);
        *(_WORD *)(v121 + 2) = __rev16(v128);
        if (v128 > 0xA)
          break;
        if (((1 << v128) & 0x86) != 0)
        {
          v129 = *v124;
          v130 = bswap32(*v124);
        }
        else
        {
          if (((1 << v128) & 0x420) == 0)
            break;
          v129 = *v124;
          v130 = bswap32(*v124 >> 3);
        }
        *((_DWORD *)v123 - 1) = v130;
LABEL_195:
        if (v129 < 5)
        {
          *(_DWORD *)v123 = 0;
          WriteValueForTagID((const __CFString *)*(v124 - 1), v129, v126, v128, 0, v123);
        }
        else
        {
          v131 = v147 + v140 + 8 + v138 + v124[1];
          *(_DWORD *)v123 = bswap32(v131);
          WriteValueForTagID((const __CFString *)*(v124 - 1), v129, v126, v128, 0, (unsigned __int8 *)&v145[v131 + 6]);
        }
        if (v126 == 513)
          *(_DWORD *)v123 = v122;
        v121 += 12;
        v123 += 12;
        v124 += 4;
        if (!--v71)
          goto LABEL_203;
      }
      *((_DWORD *)v123 - 1) = 0x1000000;
      v129 = *v124;
      goto LABEL_195;
    }
LABEL_203:
    if (__n)
    {
      v80 = v145;
      memcpy(&v145[v138 + v135 + v149], __src, __n);
      goto LABEL_205;
    }
    v9 = v144;
    v80 = v145;
  }
  else
  {
    v80 = 0;
LABEL_205:
    v9 = v144;
  }
  v82 = v154;
  v81 = v155;
  v84 = v151;
  v83 = v152;
  v79 = v137;
LABEL_210:
  (*(void (**)(IIODictionary *))(*(_QWORD *)v81 + 8))(v81);
  (*(void (**)(IIODictionary *))(*(_QWORD *)v82 + 8))(v82);
  if (v83)
    (*(void (**)(IIODictionary *))(*(_QWORD *)v83 + 8))(v83);
  if (v84)
    (*(void (**)(IIODictionary *))(*(_QWORD *)v84 + 8))(v84);
  if (v9)
LABEL_215:
    *v9 = v79;
  return v80;
}

void sub_187E8CAA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,char a56)
{
  IIONumber::~IIONumber((IIONumber *)&a56);
  _Unwind_Resume(a1);
}

CFIndex validValueForKey(unsigned __int16 *a1, const __CFString *cf)
{
  CFIndex v2;
  CFTypeID v5;
  CFIndex Count;
  uint64_t v7;
  const void *ValueAtIndex;
  CFTypeID v9;
  uint64_t v10;
  char v11;
  CFIndex v12;
  CFTypeID v13;
  CFTypeID TypeID;
  _BOOL4 v15;
  CFTypeID v16;
  int v17;
  unsigned int v18;
  CFTypeID v19;
  CFTypeID v20;
  CFTypeID v21;
  int v22;
  unsigned int v23;
  CFTypeID v24;
  char v25;
  int v26;
  unint64_t v27;
  _BOOL8 v28;
  int v29;
  _BOOL4 v30;
  uint64_t v31;
  BOOL v32;
  int v33;
  CFIndex Length;
  CFIndex v35;
  CFTypeID v36;
  CFIndex v38;
  CFIndex v39;
  unsigned int v40;
  uint64_t v41;
  _BOOL8 v42;
  int v43;
  _BOOL4 v44;
  unsigned int v45;
  unint64_t v46;
  _BOOL8 v47;
  int v48;
  _BOOL4 v49;
  uint64_t v50;
  unint64_t v51;
  _BOOL8 v52;
  int v53;
  _BOOL4 v54;
  uint64_t v55;
  _QWORD v56[5];
  CFIndex v57[3];
  CFIndex usedBufLen;
  CFIndex *p_usedBufLen;
  uint64_t v60;
  uint64_t v61;
  CFRange v62;
  CFRange v63;
  CFRange v64;
  CFRange v65;
  CFRange v66;
  CFRange v67;
  CFRange v68;

  v2 = 0;
  if (!a1 || !cf)
    return v2;
  v5 = CFGetTypeID(cf);
  if (v5 == CFArrayGetTypeID() && (Count = CFArrayGetCount((CFArrayRef)cf)) != 0)
  {
    v7 = Count;
    if (Count < 1)
    {
      v11 = 1;
      v15 = 1;
    }
    else
    {
      ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)cf, 0);
      v9 = CFGetTypeID(ValueAtIndex);
      if (v9 == CFNumberGetTypeID())
      {
        v10 = 1;
        v11 = 1;
        do
        {
          v12 = v10;
          if (CFNumberIsFloatType((CFNumberRef)ValueAtIndex))
            v11 = 0;
          if (v7 == v12)
            break;
          ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)cf, v12);
          v13 = CFGetTypeID(ValueAtIndex);
          TypeID = CFNumberGetTypeID();
          v10 = v12 + 1;
        }
        while (v13 == TypeID);
        v15 = v12 >= v7;
      }
      else
      {
        v15 = 0;
        v11 = 1;
      }
    }
    v18 = v11 & 1;
    v17 = 1;
  }
  else
  {
    v16 = CFGetTypeID(cf);
    v17 = 0;
    if (v16 == CFNumberGetTypeID())
    {
      v7 = 0;
      v18 = CFNumberIsFloatType((CFNumberRef)cf) == 0;
      v15 = 1;
    }
    else
    {
      v7 = 0;
      v15 = 0;
      v18 = 1;
    }
  }
  v19 = CFGetTypeID(cf);
  v20 = CFStringGetTypeID();
  v21 = v20;
  v22 = a1[2];
  if (v22 == 4)
  {
    v23 = *a1;
    if (a1[1] == 7)
    {
      switch(v23)
      {
        case 0xA000u:
          goto LABEL_24;
        case 0x9101u:
          return 4;
        case 0x9000u:
LABEL_24:
          if (v18)
          {
            if (v7 <= 1)
            {
              v2 = 0;
              if (v23 == 36864 && v19 == v20)
                return CFStringGetLength(cf) == 4;
              return v2;
            }
            return 4;
          }
          break;
      }
    }
  }
  else
  {
    v23 = *a1;
  }
  if (v23 == 42082)
  {
    v25 = !v15;
    if (v7 < 7)
      v25 = 1;
    if ((v25 & 1) == 0)
    {
      if ((unint64_t)v7 < 8)
        return 56;
      if (v7 == 8)
        return 58;
      return 8 * v7 - 12;
    }
    return 0;
  }
  if (v23 != 41995)
  {
    if (v22 == 4)
    {
      v26 = a1[1];
      if (!v23 && v26 == 1 && ((v18 ^ 1) & 1) == 0)
        return 4 * (v7 > 1);
LABEL_74:
      if (v26 == 7)
      {
        if (v23 == 37510 && v19 == v20)
        {
          Length = CFStringGetLength(cf);
          usedBufLen = 0;
          if (Length
            && (v62.location = 0,
                v62.length = Length,
                CFStringGetBytes(cf, v62, 0x600u, 0, 0, 0, 0, &usedBufLen) < 1))
          {
            v66.location = 0;
            v66.length = Length;
            CFStringGetBytes(cf, v66, 0x100u, 0x3Fu, 1u, 0, 0, &usedBufLen);
          }
          else
          {
            v63.location = 0;
            v63.length = Length;
            CFStringGetBytes(cf, v63, 0x600u, 0x3Fu, 0, 0, 0, &usedBufLen);
          }
          v38 = usedBufLen;
          v39 = usedBufLen + 8;
LABEL_151:
          if (v38)
            return v39;
          else
            return 0;
        }
        if (v23 == 37500 && v19 == v20)
        {
          v35 = CFStringGetLength(cf);
          usedBufLen = 0;
          if (v35
            && (v64.location = 0, v64.length = v35, CFStringGetBytes(cf, v64, 0x600u, 0, 0, 0, 0, &usedBufLen) < 1))
          {
            v68.location = 0;
            v68.length = v35;
            CFStringGetBytes(cf, v68, 0x100u, 0x3Fu, 1u, 0, 0, &usedBufLen);
          }
          else
          {
            v65.location = 0;
            v65.length = v35;
            CFStringGetBytes(cf, v65, 0x600u, 0x3Fu, 0, 0, 0, &usedBufLen);
          }
          v38 = usedBufLen;
          v39 = usedBufLen + 44;
          goto LABEL_151;
        }
        if (v23 != 37500)
          goto LABEL_97;
        v36 = CFGetTypeID(cf);
        if (v36 == CFDictionaryGetTypeID())
          return AppleMakerNoteGetLength((const __CFDictionary *)cf);
        v26 = a1[1];
        if (v26 == 7)
        {
LABEL_97:
          if ((*a1 & 0xFFFE) == 0xA300)
            return v18;
          else
            return 0;
        }
      }
      goto LABEL_100;
    }
    v26 = a1[1];
    if (v22 != 3)
      goto LABEL_74;
    if (v26 == 5)
    {
      if (v7)
        goto LABEL_49;
      if (v23 == 7 && v19 == v20)
        return 24;
      if (!v15)
      {
        v7 = 0;
        goto LABEL_49;
      }
    }
    else
    {
      if (v7)
        v32 = 0;
      else
        v32 = v26 == 32775;
      v33 = !v32;
      if (v32 && v23 == 7 && v19 == v20)
        return 24;
      if (((v33 | !v15) & 1) != 0)
        goto LABEL_74;
    }
    if (v23 > 0x16 || ((1 << v23) & 0x500014) == 0)
    {
LABEL_100:
      if (v26 == 2 && v19 == v21)
      {
        v67.length = CFStringGetLength(cf);
        usedBufLen = 0;
        v67.location = 0;
        CFStringGetBytes(cf, v67, 0x8000100u, 0x3Fu, 0, 0, 0, &usedBufLen);
        if (usedBufLen)
          return usedBufLen + 1;
        else
          return 0;
      }
      if (v26 == 1)
        v40 = v18;
      else
        v40 = 0;
      if (v40 == 1)
      {
        v41 = a1[2];
        v42 = v41 == 1;
        if (a1[2])
          v43 = 0;
        else
          v43 = v17;
        v44 = v7 == v41 && v41 != 0;
        if (v43 | v44)
          return v7;
        else
          return v42;
      }
      if (v26 == 3)
        v45 = v18;
      else
        v45 = 0;
      if (v45 == 1)
      {
        v46 = a1[2];
        v47 = v46 == 1;
        if (a1[2])
          v48 = 0;
        else
          v48 = v17;
        v49 = v7 == v46 && v46 > 1;
        if (v48 | v49)
          v50 = v7;
        else
          v50 = v47;
        return 2 * v50;
      }
      v2 = 0;
      if (v26 <= 9)
      {
        if (v26 != 4)
        {
          if (v26 != 5)
            return v2;
          goto LABEL_49;
        }
LABEL_138:
        if (v18)
        {
          v51 = a1[2];
          v52 = v51 == 1;
          if (a1[2])
            v53 = 0;
          else
            v53 = v17;
          v54 = v7 == v51 && v51 > 1;
          if (v53 | v54)
            v55 = v7;
          else
            v55 = v52;
          return 4 * v55;
        }
        return 0;
      }
      if (v26 != 10)
      {
        if (v26 != 32771)
          return v2;
        goto LABEL_138;
      }
LABEL_49:
      if (v15)
      {
        v27 = a1[2];
        v28 = v27 == 1;
        if (a1[2])
          v29 = 0;
        else
          v29 = v17;
        v30 = v7 == v27 && v27 > 1;
        if (v29 | v30)
          v31 = v7;
        else
          v31 = v28;
        return 8 * v31;
      }
      return 0;
    }
    return 24;
  }
  v24 = CFGetTypeID(cf);
  if (v24 != CFArrayGetTypeID())
    return 0;
  usedBufLen = 0;
  p_usedBufLen = &usedBufLen;
  v60 = 0x2000000000;
  v61 = 4;
  memset(v57, 0, sizeof(v57));
  IIOArray::IIOArray((IIOArray *)v57, (const __CFArray *)cf);
  v56[0] = MEMORY[0x1E0C809B0];
  v56[1] = 0x40000000;
  v56[2] = ___ZL16validValueForKeyPK6tagdefPKv_block_invoke;
  v56[3] = &unk_1E1BC4A08;
  v56[4] = &usedBufLen;
  IIOArray::enumerate((uint64_t)v57, (uint64_t)v56);
  v2 = p_usedBufLen[3];
  IIOArray::~IIOArray((IIOArray *)v57);
  _Block_object_dispose(&usedBufLen, 8);
  return v2;
}

void sub_187E8D28C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v9;
  va_list va;
  uint64_t v11;
  uint64_t v12;
  va_list va1;

  va_start(va1, a8);
  va_start(va, a8);
  v9 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  IIOArray::~IIOArray((IIOArray *)va);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t _CGImagePlusFinalize(_QWORD *a1)
{
  unint64_t v2;
  const void *v3;
  uint64_t result;
  char __str[16];
  __int128 v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  do
    v2 = __ldxr(&gImagePlusCount);
  while (__stxr(v2 - 1, &gImagePlusCount));
  if ((gIIODebugFlags & 0xC000) != 0)
  {
    *(_OWORD *)__str = 0u;
    v6 = 0u;
    v3 = a1[3] ? (const void *)IIOLookupISR() : 0;
    snprintf(__str, 0x20uLL, "(%p)", a1);
    if ((unsigned __int16)gIIODebugFlags >> 14)
      ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "_CGImagePlusFinalize", v3, __str, -1, 0);
  }
  result = a1[3];
  if (result)
  {
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
    a1[3] = 0;
  }
  return result;
}

void IIOImagePlus::~IIOImagePlus(IIOImagePlus *this)
{
  IIOImagePlus::~IIOImagePlus(this);
  JUMPOUT(0x18D761C30);
}

{
  CGColorSpace *v2;
  uint64_t v3;
  const void *v4;
  const void *v5;
  uint64_t v6;
  const void *v7;
  const CGPath *v8;
  uint64_t v9;

  *(_QWORD *)this = &off_1E1BAC210;
  pthread_mutex_lock(&ipGeomLock);
  v2 = (CGColorSpace *)*((_QWORD *)this + 11);
  *((_QWORD *)this + 11) = 0;
  if (v2)
    CGColorSpaceRelease(v2);
  pthread_mutex_unlock(&ipGeomLock);
  v3 = *((_QWORD *)this + 14);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  *((_QWORD *)this + 14) = 0;
  v4 = (const void *)*((_QWORD *)this + 15);
  if (v4)
  {
    CFRelease(v4);
    *((_QWORD *)this + 15) = 0;
  }
  v5 = (const void *)*((_QWORD *)this + 19);
  if (v5)
  {
    CFRelease(v5);
    *((_QWORD *)this + 19) = 0;
  }
  *((_QWORD *)this + 18) = 0;
  *((_QWORD *)this + 16) = 0;
  if ((*((_BYTE *)this + 192) & 0x20) != 0)
  {
    v6 = CGImageReadSessionGetRead(*((_QWORD *)this + 3));
    if (v6)
      IIOImageRead::removeCacheKey(v6, *((_QWORD *)this + 26));
  }
  v7 = (const void *)*((_QWORD *)this + 3);
  if (v7)
    CFRelease(v7);
  v8 = (const CGPath *)*((_QWORD *)this + 23);
  if (v8)
    CGPathRelease(v8);
  v9 = *((_QWORD *)this + 25);
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  *((_QWORD *)this + 25) = 0;
}

void WriteValueForTagID(const __CFString *a1, uint64_t a2, int a3, int a4, int a5, unsigned __int8 *a6)
{
  CFTypeID v12;
  CFTypeID TypeID;
  CFIndex Count;
  const __CFNumber *v15;
  const __CFNumber *v16;
  const __CFNumber *v17;
  const __CFNumber *v18;
  int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned __int8 v22;
  unsigned int v23;
  unsigned int v24;
  unsigned __int8 v25;
  const __CFNumber *ValueAtIndex;
  const __CFNumber *v27;
  const __CFNumber *v28;
  const __CFNumber *v29;
  unsigned __int8 v30;
  unsigned __int8 v31;
  int v32;
  CFTypeID v33;
  const char *CStringPtr;
  unsigned __int8 *v35;
  double v36;
  unsigned int v37;
  unsigned int v38;
  unsigned __int8 v39;
  unsigned int v40;
  unsigned int v41;
  unsigned __int8 v42;
  unsigned int v43;
  CFTypeID v44;
  CFIndex Length;
  CFIndex v46;
  const __CFNumber *v47;
  const __CFNumber *v48;
  const __CFNumber *v49;
  char v50;
  int v51;
  CFIndex v52;
  unsigned __int8 *i;
  const void *v54;
  CFTypeID v55;
  CFTypeID v56;
  const char *v57;
  uint64_t v58;
  unsigned __int8 v59;
  unsigned int v60;
  unsigned int v61;
  unsigned __int8 v62;
  unsigned int v63;
  unsigned int v64;
  unsigned __int8 v65;
  CFTypeID v66;
  size_t v67;
  unsigned int v68;
  unsigned int v69;
  unsigned __int8 v70;
  unsigned int v71;
  unsigned int v72;
  unsigned __int8 v73;
  unsigned int v74;
  unsigned int v75;
  unsigned __int8 v76;
  unsigned int v77;
  unsigned int v78;
  unsigned __int8 v79;
  CFIndex v80;
  CFIndex MaximumSizeForEncoding;
  CFIndex j;
  const __CFNumber *v83;
  unint64_t v84;
  UInt8 *v85;
  CFStringEncoding v86;
  double v87;
  unsigned int v88;
  unsigned int v89;
  unsigned __int8 v90;
  unsigned __int8 v91;
  unsigned int v92;
  unsigned int v93;
  unsigned __int8 v94;
  unsigned __int8 v95;
  unsigned __int8 v96;
  unsigned __int8 v97;
  unsigned int v98;
  unsigned int v99;
  unsigned __int8 v100;
  unsigned int v101;
  unsigned int v102;
  unsigned __int8 v103;
  CFIndex v104;
  unsigned __int8 *v105;
  const __CFNumber *v106;
  int v107;
  int v108;
  int v109;
  int v110;
  int v111;
  int v112;
  int v113;
  int v114;
  CFIndex v115;
  unsigned __int8 *v116;
  const __CFNumber *v117;
  unsigned int v118;
  unsigned int v119;
  unsigned int v120;
  unsigned int v121;
  unsigned __int8 v122;
  unsigned __int8 v123;
  CFIndex v124;
  int v125;
  const __CFNumber *v126;
  unint64_t v127;
  unsigned __int8 *v128;
  unsigned __int8 v129;
  unsigned __int8 v130;
  int v131;
  int v132;
  int v133;
  int v134;
  unsigned __int8 *v135;
  unsigned int v136;
  unsigned int v137;
  unsigned int v138;
  unsigned int v139;
  unsigned __int8 *v140;
  CFStringEncoding v141;
  CFIndex v142;
  unsigned __int8 *v143;
  const __CFNumber *v144;
  int v145;
  int v146;
  unint64_t v147;
  unint64_t v148;
  unint64_t v149;
  int v150;
  unint64_t v151;
  int v152;
  _QWORD v153[7];
  CFIndex usedBufLen[3];
  double v155;
  unsigned int v156;
  double valuePtr;
  double *p_valuePtr;
  uint64_t v159;
  int v160;
  uint64_t v161;
  CFRange v162;
  CFRange v163;
  CFRange v164;
  CFRange v165;
  CFRange v166;
  CFRange v167;
  CFRange v168;
  CFRange v169;

  v161 = *MEMORY[0x1E0C80C00];
  if (!a1 || !a6)
    return;
  v12 = CFGetTypeID(a1);
  TypeID = CFArrayGetTypeID();
  if (v12 == TypeID)
    Count = CFArrayGetCount((CFArrayRef)a1);
  else
    Count = 1;
  if (a4 == 7)
  {
    if (a3 <= 37499)
    {
      if (a3 != 36864)
      {
        if (a3 != 37121)
        {
LABEL_73:
          if ((a3 & 0xFFFE) == 0xA300)
          {
            LOBYTE(valuePtr) = 0;
            if (CFNumberGetValue((CFNumberRef)a1, kCFNumberCharType, &valuePtr))
              *a6 = LOBYTE(valuePtr);
            return;
          }
          goto LABEL_192;
        }
        v156 = 0;
        LODWORD(valuePtr) = 0;
        LODWORD(usedBufLen[0]) = 0;
        LODWORD(v155) = 0;
        if (Count == 4)
        {
          ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, 0);
          CFNumberGetValue(ValueAtIndex, kCFNumberIntType, &valuePtr);
          v27 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, 1);
          CFNumberGetValue(v27, kCFNumberIntType, usedBufLen);
          v28 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, 2);
          CFNumberGetValue(v28, kCFNumberIntType, &v155);
          v29 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, 3);
          CFNumberGetValue(v29, kCFNumberIntType, &v156);
          LOBYTE(v19) = v156;
          v30 = LOBYTE(valuePtr);
          v31 = usedBufLen[0];
          LOBYTE(v32) = LOBYTE(v155);
        }
        else
        {
          LOBYTE(v19) = 0;
          LOBYTE(v32) = 3;
          v31 = 2;
          v30 = 1;
        }
        *a6 = v30;
        a6[1] = v31;
        goto LABEL_108;
      }
    }
    else
    {
      if (a3 == 37500)
      {
        v44 = CFGetTypeID(a1);
        if (v44 == CFStringGetTypeID())
        {
          valuePtr = 0.0;
          Length = CFStringGetLength(a1);
          *(_WORD *)a6 = -7681;
          a6[2] = (unsigned __int16)(Length + 44) >> 8;
          a6[3] = Length + 44;
          *(_QWORD *)(a6 + 18) = 0x70086920100;
          *(_OWORD *)(a6 + 4) = *(_OWORD *)"iOS ";
          a6[26] = (unsigned __int16)(Length + 8) >> 8;
          a6[27] = Length + 8;
          *(_QWORD *)(a6 + 28) = 436207616;
          if (Length
            && (v163.location = 0,
                v163.length = Length,
                CFStringGetBytes(a1, v163, 0x600u, 0, 0, 0, 30000, (CFIndex *)&valuePtr) < 1))
          {
            *(_QWORD *)(a6 + 36) = 0x45444F43494E55;
            if (a5)
              v141 = 335544576;
            else
              v141 = 268435712;
            v169.location = 0;
            v169.length = Length;
            CFStringGetBytes(a1, v169, v141, 0x3Fu, 1u, a6 + 44, 30000, (CFIndex *)&valuePtr);
          }
          else
          {
            *(_QWORD *)(a6 + 36) = 0x4949435341;
            v164.location = 0;
            v164.length = Length;
            CFStringGetBytes(a1, v164, 0x600u, 0x3Fu, 0, a6 + 44, 30000, (CFIndex *)&valuePtr);
          }
          return;
        }
        v66 = CFGetTypeID(a1);
        if (v66 == CFDictionaryGetTypeID())
        {
          v67 = AppleMakerNoteGetLength((const __CFDictionary *)a1);
          AppleMakerNoteWriteToBuffer((const __CFDictionary *)a1, a6, v67, a5);
          return;
        }
        a3 = 37500;
        goto LABEL_201;
      }
      if (a3 == 37510)
      {
        v46 = CFStringGetLength(a1);
        valuePtr = 0.0;
        if (v46
          && (v165.location = 0,
              v165.length = v46,
              CFStringGetBytes(a1, v165, 0x600u, 0, 0, 0, 0, (CFIndex *)&valuePtr) < 1))
        {
          *(_QWORD *)a6 = 0x45444F43494E55;
          v85 = a6 + 8;
          if (a5)
            v86 = 335544576;
          else
            v86 = 268435712;
          v168.location = 0;
          v168.length = v46;
          CFStringGetBytes(a1, v168, v86, 0x3Fu, 1u, v85, v46, (CFIndex *)&valuePtr);
        }
        else
        {
          *(_QWORD *)a6 = 0x4949435341;
          v166.location = 0;
          v166.length = v46;
          CFStringGetBytes(a1, v166, 0x600u, 0x3Fu, 0, a6 + 8, v46, (CFIndex *)&valuePtr);
        }
        return;
      }
      if (a3 != 40960)
        goto LABEL_73;
    }
    LODWORD(valuePtr) = 0;
    LODWORD(usedBufLen[0]) = 0;
    LODWORD(v155) = 0;
    v33 = CFStringGetTypeID();
    if (v33 == CFGetTypeID(a1))
    {
      CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
      if (!CStringPtr)
        return;
      v35 = (unsigned __int8 *)CStringPtr;
      if (strlen(CStringPtr) != 4)
        return;
      *a6 = *v35;
      a6[1] = v35[1];
      a6[2] = v35[2];
      LOBYTE(v19) = v35[3];
LABEL_109:
      a6[3] = v19;
      return;
    }
    if (Count < 1
      || (v47 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, 0)) == 0
      || !CFNumberGetValue(v47, kCFNumberIntType, &valuePtr))
    {
      LODWORD(valuePtr) = 0;
    }
    if (Count < 2
      || (v48 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, 1)) == 0
      || !CFNumberGetValue(v48, kCFNumberIntType, usedBufLen))
    {
      LODWORD(usedBufLen[0]) = 0;
    }
    if (Count >= 3
      && (v49 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, 2)) != 0
      && CFNumberGetValue(v49, kCFNumberIntType, &v155))
    {
      v19 = SLODWORD(v155) % 10 + 48;
    }
    else
    {
      LOBYTE(v19) = 48;
    }
    v50 = LOBYTE(valuePtr);
    v51 = SLODWORD(valuePtr) / 10;
    *a6 = SLODWORD(valuePtr) / 10 % 10 + 48;
    a6[1] = v50 - 10 * v51 + 48;
    v32 = SLODWORD(usedBufLen[0]) % 10 + 48;
LABEL_108:
    a6[2] = v32;
    goto LABEL_109;
  }
  if (!a3 && a4 == 1)
  {
    v156 = 0;
    LODWORD(valuePtr) = 0;
    LODWORD(usedBufLen[0]) = 0;
    LODWORD(v155) = 0;
    if (Count < 1
      || (v15 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, 0)) == 0
      || !CFNumberGetValue(v15, kCFNumberIntType, &valuePtr))
    {
      LODWORD(valuePtr) = 0;
    }
    if (Count < 2
      || (v16 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, 1)) == 0
      || !CFNumberGetValue(v16, kCFNumberIntType, usedBufLen))
    {
      LODWORD(usedBufLen[0]) = 0;
    }
    if (Count < 3
      || (v17 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, 2)) == 0
      || !CFNumberGetValue(v17, kCFNumberIntType, &v155))
    {
      LODWORD(v155) = 0;
    }
    if (Count >= 4
      && (v18 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, 3)) != 0
      && CFNumberGetValue(v18, kCFNumberIntType, &v156))
    {
      v19 = (int)v156 % 10;
    }
    else
    {
      LOBYTE(v19) = 0;
    }
    *a6 = LOBYTE(valuePtr)
        - 10 * (((unint64_t)(1717986919 * SLODWORD(valuePtr)) >> 34) + (1717986919 * SLODWORD(valuePtr) < 0));
    a6[1] = LOBYTE(usedBufLen[0])
          - 10
          * (((unint64_t)(1717986919 * SLODWORD(usedBufLen[0])) >> 34)
           + (1717986919 * SLODWORD(usedBufLen[0]) < 0));
    v32 = SLODWORD(v155) % 10;
    goto LABEL_108;
  }
  if (a3 == 7 && a4 == 5)
  {
    LODWORD(p_valuePtr) = 0;
    valuePtr = 0.0;
    v162.length = CFStringGetLength(a1);
    usedBufLen[0] = 0;
    v162.location = 0;
    CFStringGetBytes(a1, v162, 0x600u, 0x3Fu, 0, (UInt8 *)&valuePtr, 11, usedBufLen);
    if (usedBufLen[0] == 11 && BYTE2(valuePtr) == 58 && BYTE5(valuePtr) == 58 && p_valuePtr == 46)
    {
      v20 = SBYTE1(valuePtr) + 10 * SLOBYTE(valuePtr) - 528;
      v21 = HIWORD(v20);
      if (a5)
      {
        v22 = 0;
        v23 = v20 >> 8;
        LOBYTE(v24) = BYTE1(valuePtr) + 10 * LOBYTE(valuePtr) - 16;
        v20 >>= 24;
        v25 = 1;
      }
      else
      {
        v25 = 0;
        v24 = HIBYTE(v20);
        v23 = HIWORD(v20);
        v21 = v20 >> 8;
        v22 = 1;
      }
      *a6 = v24;
      a6[1] = v23;
      a6[2] = v21;
      a6[3] = v20;
      a6[4] = v25;
      *(_WORD *)(a6 + 5) = 0;
      a6[7] = v22;
      v68 = SBYTE4(valuePtr) + 10 * SBYTE3(valuePtr) - 528;
      v69 = HIWORD(v68);
      if (a5)
      {
        v70 = 0;
        v71 = v68 >> 8;
        LOBYTE(v72) = BYTE4(valuePtr) + 10 * BYTE3(valuePtr) - 16;
        v68 >>= 24;
        v73 = 1;
      }
      else
      {
        v73 = 0;
        v72 = HIBYTE(v68);
        v71 = HIWORD(v68);
        v69 = v68 >> 8;
        v70 = 1;
      }
      a6[8] = v72;
      a6[9] = v71;
      a6[10] = v69;
      a6[11] = v68;
      a6[12] = v73;
      *(_WORD *)(a6 + 13) = 0;
      a6[15] = v70;
      v74 = 100 * SHIBYTE(valuePtr) + 1000 * SBYTE6(valuePtr) + 10 * SBYTE1(p_valuePtr) + SBYTE2(p_valuePtr) - 53328;
      v75 = HIWORD(v74);
      if (a5)
      {
        v76 = 0;
        v77 = HIWORD(v74);
        v75 = v74 >> 8;
        v78 = HIBYTE(v74);
        v79 = 100;
      }
      else
      {
        v79 = 0;
        v77 = v74 >> 8;
        LOBYTE(v78) = 100 * HIBYTE(valuePtr) - 24 * BYTE6(valuePtr) + 10 * BYTE1(p_valuePtr) + BYTE2(p_valuePtr) - 80;
        v74 >>= 24;
        v76 = 100;
      }
    }
    else
    {
      if (usedBufLen[0] != 8 || BYTE2(valuePtr) != 58 || BYTE5(valuePtr) != 58)
        return;
      v60 = SBYTE1(valuePtr) + 10 * SLOBYTE(valuePtr) - 528;
      v61 = HIWORD(v60);
      if (a5)
      {
        v62 = 0;
        v63 = v60 >> 8;
        LOBYTE(v64) = BYTE1(valuePtr) + 10 * LOBYTE(valuePtr) - 16;
        v60 >>= 24;
        v65 = 1;
      }
      else
      {
        v65 = 0;
        v64 = HIBYTE(v60);
        v63 = HIWORD(v60);
        v61 = v60 >> 8;
        v62 = 1;
      }
      *a6 = v64;
      a6[1] = v63;
      a6[2] = v61;
      a6[3] = v60;
      a6[4] = v65;
      *(_WORD *)(a6 + 5) = 0;
      a6[7] = v62;
      v98 = SBYTE4(valuePtr) + 10 * SBYTE3(valuePtr) - 528;
      v99 = HIWORD(v98);
      if (a5)
      {
        v100 = 0;
        v101 = v98 >> 8;
        LOBYTE(v102) = BYTE4(valuePtr) + 10 * BYTE3(valuePtr) - 16;
        v98 >>= 24;
        v103 = 1;
      }
      else
      {
        v103 = 0;
        v102 = HIBYTE(v98);
        v101 = HIWORD(v98);
        v99 = v98 >> 8;
        v100 = 1;
      }
      a6[8] = v102;
      a6[9] = v101;
      a6[10] = v99;
      a6[11] = v98;
      a6[12] = v103;
      *(_WORD *)(a6 + 13) = 0;
      a6[15] = v100;
      v74 = SHIBYTE(valuePtr) + 10 * SBYTE6(valuePtr) - 528;
      v75 = HIWORD(v74);
      if (a5)
      {
        v76 = 0;
        v77 = HIWORD(v74);
        v75 = v74 >> 8;
        v78 = HIBYTE(v74);
        v79 = 1;
      }
      else
      {
        v79 = 0;
        v77 = v74 >> 8;
        LOBYTE(v78) = HIBYTE(valuePtr) + 10 * BYTE6(valuePtr) - 16;
        v74 >>= 24;
        v76 = 1;
      }
    }
    a6[16] = v74;
    a6[17] = v75;
    a6[18] = v77;
    a6[19] = v78;
    a6[20] = v79;
    *(_WORD *)(a6 + 21) = 0;
    a6[23] = v76;
    return;
  }
  switch(a4)
  {
    case 5:
      if (a3 <= 0x16 && ((1 << a3) & 0x500014) != 0)
      {
        valuePtr = 0.0;
        if (CFNumberGetValue((CFNumberRef)a1, kCFNumberDoubleType, &valuePtr))
        {
          v36 = valuePtr;
          v37 = valuePtr;
          v38 = valuePtr >> 16;
          if (a5)
          {
            v39 = 0;
            v40 = v37 >> 8;
            v41 = HIBYTE(v37);
            v42 = 1;
            v43 = valuePtr;
          }
          else
          {
            v42 = 0;
            v43 = HIBYTE(v37);
            v40 = HIWORD(v37);
            v38 = v37 >> 8;
            v39 = 1;
            v41 = valuePtr;
          }
          *a6 = v43;
          a6[1] = v40;
          a6[2] = v38;
          a6[3] = v41;
          a6[4] = v42;
          *(_WORD *)(a6 + 5) = 0;
          a6[7] = v39;
          v87 = (v36 - (double)v37) * 60.0;
          v88 = v87 >> 16;
          v89 = v87 >> 24;
          if (a5)
            v90 = v87;
          else
            v90 = v87 >> 24;
          if (a5)
            v91 = (unsigned __int16)v87 >> 8;
          else
            v91 = v87 >> 16;
          if (!a5)
          {
            LOBYTE(v88) = (unsigned __int16)v87 >> 8;
            LOBYTE(v89) = v87;
          }
          a6[8] = v90;
          a6[9] = v91;
          a6[10] = v88;
          a6[11] = v89;
          a6[12] = a5 != 0;
          *(_WORD *)(a6 + 13) = 0;
          a6[15] = a5 == 0;
          v92 = ((v87 - (double)v87) * 60.0 * 100.0 + 0.5);
          v93 = HIWORD(v92);
          if (a5)
            v94 = ((v87 - (double)v87) * 60.0 * 100.0 + 0.5);
          else
            v94 = ((v87 - (double)v87) * 60.0 * 100.0 + 0.5) >> 24;
          if (a5)
            v95 = (unsigned __int16)((v87 - (double)v87) * 60.0 * 100.0 + 0.5) >> 8;
          else
            v95 = ((v87 - (double)v87) * 60.0 * 100.0 + 0.5) >> 16;
          a6[16] = v94;
          if (a5)
          {
            LOBYTE(v92) = ((v87 - (double)v87) * 60.0 * 100.0 + 0.5) >> 24;
            v96 = 100;
          }
          else
          {
            LOBYTE(v93) = (unsigned __int16)((v87 - (double)v87) * 60.0 * 100.0 + 0.5) >> 8;
            v96 = 0;
          }
          a6[17] = v95;
          a6[18] = v93;
          if (a5)
            v97 = 0;
          else
            v97 = 100;
          a6[19] = v92;
          a6[20] = v96;
          *(_WORD *)(a6 + 21) = 0;
          a6[23] = v97;
        }
      }
      else if (Count >= 1)
      {
        v104 = 0;
        v105 = a6 + 3;
        do
        {
          v106 = (const __CFNumber *)a1;
          if (v12 == TypeID)
            v106 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, v104);
          valuePtr = 0.0;
          if (CFNumberGetValue(v106, kCFNumberDoubleType, &valuePtr))
          {
            LODWORD(usedBufLen[0]) = 0;
            LODWORD(v155) = 0;
            URationalApprox(valuePtr, usedBufLen, (unsigned int *)&v155);
            LOBYTE(v107) = usedBufLen[0];
            v108 = HIWORD(LODWORD(usedBufLen[0]));
            LOBYTE(v109) = LOBYTE(v155);
            v110 = HIWORD(LODWORD(v155));
            v111 = LODWORD(usedBufLen[0]) >> 8;
            v112 = LODWORD(v155) >> 8;
            if (a5)
            {
              LOBYTE(v113) = usedBufLen[0];
              v107 = HIBYTE(LODWORD(usedBufLen[0]));
              LOBYTE(v114) = LOBYTE(v155);
              v109 = HIBYTE(LODWORD(v155));
            }
            else
            {
              v113 = HIBYTE(LODWORD(usedBufLen[0]));
              v111 = HIWORD(LODWORD(usedBufLen[0]));
              v108 = LODWORD(usedBufLen[0]) >> 8;
              v114 = HIBYTE(LODWORD(v155));
              v112 = HIWORD(LODWORD(v155));
              v110 = LODWORD(v155) >> 8;
            }
            *(v105 - 3) = v113;
            *(v105 - 2) = v111;
            *(v105 - 1) = v108;
            *v105 = v107;
            v105[1] = v114;
            v105[2] = v112;
            v105[3] = v110;
            v105[4] = v109;
          }
          ++v104;
          v105 += 8;
        }
        while (Count != v104);
      }
      return;
    case 2:
      v80 = CFStringGetLength(a1);
      MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(v80, 0x8000100u);
      valuePtr = 0.0;
      v167.location = 0;
      v167.length = v80;
      CFStringGetBytes(a1, v167, 0x8000100u, 0x3Fu, 0, a6, MaximumSizeForEncoding + 1, (CFIndex *)&valuePtr);
      a6[*(_QWORD *)&valuePtr] = 0;
      return;
    case 3:
      if (Count < 1)
        return;
      v52 = 0;
      for (i = a6 + 1; ; i += 2)
      {
        v54 = a1;
        if (v12 == TypeID)
          v54 = CFArrayGetValueAtIndex((CFArrayRef)a1, v52);
        usedBufLen[0] = 0;
        v55 = CFGetTypeID(v54);
        if (v55 == CFNumberGetTypeID())
        {
          if (CFNumberGetValue((CFNumberRef)v54, kCFNumberLongType, usedBufLen))
            goto LABEL_89;
        }
        else
        {
          v56 = CFGetTypeID(v54);
          if (v56 == CFStringGetTypeID())
          {
            valuePtr = 0.0;
            p_valuePtr = 0;
            v159 = 0;
            IIOString::IIOString((IIOString *)&valuePtr, v54);
            v57 = (const char *)IIOString::utf8String((IIOString *)&valuePtr);
            usedBufLen[0] = atol(v57);
            IIOString::~IIOString((IIOString *)&valuePtr);
LABEL_89:
            v58 = usedBufLen[0];
            if (usedBufLen[0] <= -32768)
              v58 = -32768;
            if (v58 >= 0xFFFF)
              LOWORD(v58) = -1;
            if (a5)
              v59 = v58;
            else
              v59 = BYTE1(v58);
            if (a5)
              LOBYTE(v58) = BYTE1(v58);
            *(i - 1) = v59;
            *i = v58;
          }
        }
        if (Count == ++v52)
          return;
      }
      break;
  }
  switch(a4)
  {
    case 1:
      if (Count >= 1)
      {
        for (j = 0; j != Count; ++j)
        {
          v83 = (const __CFNumber *)a1;
          if (v12 == TypeID)
            v83 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, j);
          valuePtr = 0.0;
          if (CFNumberGetValue(v83, kCFNumberLongType, &valuePtr))
          {
            v84 = *(_QWORD *)&valuePtr & ~(*(uint64_t *)&valuePtr >> 63);
            if (v84 >= 0xFF)
              LOBYTE(v84) = -1;
            a6[j] = v84;
          }
        }
      }
      return;
    case 32771:
      goto LABEL_181;
    case 10:
      if (Count >= 1)
      {
        v142 = 0;
        v143 = a6 + 3;
        do
        {
          v144 = (const __CFNumber *)a1;
          if (v12 == TypeID)
            v144 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, v142);
          v155 = 0.0;
          if (CFNumberGetValue(v144, kCFNumberDoubleType, &v155))
          {
            valuePtr = 0.0;
            usedBufLen[0] = 0;
            RationalApprox(v155, 0x7FFFFFFFLL, (uint64_t *)&valuePtr, usedBufLen);
            LOBYTE(v145) = usedBufLen[0];
            v146 = HIWORD(LODWORD(usedBufLen[0]));
            LOBYTE(v147) = LOBYTE(valuePtr);
            LODWORD(v148) = HIWORD(LODWORD(valuePtr));
            v149 = *(_QWORD *)&valuePtr >> 8;
            v150 = LODWORD(usedBufLen[0]) >> 8;
            if (a5)
            {
              LOBYTE(v151) = LOBYTE(valuePtr);
              v147 = *(_QWORD *)&valuePtr >> 24;
              LOBYTE(v152) = usedBufLen[0];
              v145 = HIBYTE(LODWORD(usedBufLen[0]));
            }
            else
            {
              v151 = *(_QWORD *)&valuePtr >> 24;
              LODWORD(v149) = HIWORD(LODWORD(valuePtr));
              v148 = *(_QWORD *)&valuePtr >> 8;
              v152 = HIBYTE(LODWORD(usedBufLen[0]));
              v150 = HIWORD(LODWORD(usedBufLen[0]));
              v146 = LODWORD(usedBufLen[0]) >> 8;
            }
            *(v143 - 3) = v151;
            *(v143 - 2) = v149;
            *(v143 - 1) = v148;
            *v143 = v147;
            v143[1] = v152;
            v143[2] = v150;
            v143[3] = v146;
            v143[4] = v145;
          }
          ++v142;
          v143 += 8;
        }
        while (Count != v142);
      }
      return;
    case 4:
LABEL_181:
      if (Count >= 1)
      {
        v115 = 0;
        v116 = a6 + 3;
        do
        {
          v117 = (const __CFNumber *)a1;
          if (v12 == TypeID)
            v117 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, v115);
          valuePtr = 0.0;
          if (CFNumberGetValue(v117, kCFNumberLongType, &valuePtr))
          {
            LOBYTE(v118) = LOBYTE(valuePtr);
            v119 = HIWORD(LODWORD(valuePtr));
            v120 = LODWORD(valuePtr) >> 8;
            if (a5)
            {
              LOBYTE(v121) = LOBYTE(valuePtr);
              v118 = HIBYTE(LODWORD(valuePtr));
            }
            else
            {
              v121 = HIBYTE(LODWORD(valuePtr));
              v120 = HIWORD(LODWORD(valuePtr));
              v119 = LODWORD(valuePtr) >> 8;
            }
            *(v116 - 3) = v121;
            *(v116 - 2) = v120;
            *(v116 - 1) = v119;
            *v116 = v118;
          }
          ++v115;
          v116 += 4;
        }
        while (Count != v115);
      }
      return;
  }
LABEL_192:
  if (a3 != 42082)
  {
    if (a3 == 41995)
    {
      if (v12 == TypeID)
      {
        *a6 = a5;
        a6[1] = a5 ^ 1;
        v122 = BYTE1(Count);
        if (a5)
          v123 = Count;
        else
          v123 = BYTE1(Count);
        if (!a5)
          v122 = Count;
        a6[2] = v123;
        a6[3] = v122;
        valuePtr = 0.0;
        p_valuePtr = &valuePtr;
        v159 = 0x2000000000;
        v160 = 4;
        memset(usedBufLen, 0, sizeof(usedBufLen));
        IIOArray::IIOArray((IIOArray *)usedBufLen, (const __CFArray *)a1);
        v153[0] = MEMORY[0x1E0C809B0];
        v153[1] = 0x40000000;
        v153[2] = ___ZL18WriteValueForTagIDPKvmttbPh_block_invoke;
        v153[3] = &unk_1E1BC4A40;
        v153[4] = &valuePtr;
        v153[5] = a2;
        v153[6] = a6;
        IIOArray::enumerate((uint64_t)usedBufLen, (uint64_t)v153);
        IIOArray::~IIOArray((IIOArray *)usedBufLen);
        _Block_object_dispose(&valuePtr, 8);
      }
      return;
    }
LABEL_201:
    _cg_jpeg_mem_term("WriteValueForTagID", 3707, "*** did not handle '%4X'\n", a3);
    return;
  }
  if (v12 == TypeID && Count >= 8)
  {
    v124 = 0;
    v125 = 0;
    do
    {
      v126 = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)a1, v124);
      valuePtr = 0.0;
      LODWORD(usedBufLen[0]) = 0;
      v127 = v124 - 7;
      if (v127 > 1)
      {
        if (CFNumberGetValue(v126, kCFNumberDoubleType, &valuePtr))
        {
          LODWORD(v155) = 0;
          v156 = 0;
          URationalApprox(valuePtr, &v155, &v156);
          LOBYTE(v131) = LOBYTE(v155);
          v132 = HIWORD(LODWORD(v155));
          v133 = LODWORD(v155) >> 8;
          if (a5)
          {
            LOBYTE(v134) = LOBYTE(v155);
            v131 = HIBYTE(LODWORD(v155));
          }
          else
          {
            v134 = HIBYTE(LODWORD(v155));
            v133 = HIWORD(LODWORD(v155));
            v132 = LODWORD(v155) >> 8;
          }
          v135 = &a6[v125];
          *v135 = v134;
          v135[1] = v133;
          v136 = v156;
          v137 = HIWORD(v156);
          v135[2] = v132;
          v135[3] = v131;
          v138 = v136 >> 8;
          if (a5)
          {
            LOBYTE(v139) = v136;
            v136 >>= 24;
          }
          else
          {
            v139 = HIBYTE(v136);
            LOBYTE(v138) = v137;
            v137 = v136 >> 8;
          }
          v140 = &a6[v125 + 4];
          *v140 = v139;
          v140[1] = v138;
          v140[2] = v137;
          v140[3] = v136;
          v125 += 8;
        }
      }
      else if (CFNumberGetValue(v126, kCFNumberIntType, usedBufLen))
      {
        v128 = &a6[v125];
        v129 = usedBufLen[0];
        if (a5)
          v130 = usedBufLen[0];
        else
          v130 = BYTE1(usedBufLen[0]);
        if (a5)
          v129 = BYTE1(usedBufLen[0]);
        *v128 = v130;
        v128[1] = v129;
        v125 += 2;
      }
      v124 = v127 + 8;
    }
    while (v124 != Count);
  }
}

void sub_187E8E6FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  IIOArray::~IIOArray((IIOArray *)va);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

BOOL IIO_CGColorSpaceNameMatchesName(CGColorSpace *a1, const __CFString *a2)
{
  const __CFString *v3;
  const __CFString *v4;
  _BOOL8 v5;

  v3 = CGColorSpaceCopyName(a1);
  if (!v3)
    return 0;
  v4 = v3;
  v5 = CFStringCompare(v3, a2, 0) == kCFCompareEqualTo;
  CFRelease(v4);
  return v5;
}

_DWORD *URationalApprox(double a1, _DWORD *result, unsigned int *a3)
{
  _DWORD *v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;

  v4 = result;
  if (a1 <= 0.0)
  {
    v5 = 0;
    v6 = 1;
  }
  else
  {
    v7 = 0;
    v8 = 0;
    result = (_DWORD *)RationalApprox(a1, 0xFFFFFFFFLL, &v8, &v7);
    v5 = v8;
    v6 = v7;
  }
  *v4 = v5;
  *a3 = v6;
  return result;
}

uint64_t RationalApprox(double a1, uint64_t result, uint64_t *a3, uint64_t *a4)
{
  double v4;
  uint64_t v5;
  int v7;
  uint64_t v8;
  double v9;
  double v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v15;
  BOOL v16;
  BOOL v18;
  uint64_t v19;
  BOOL v20;
  BOOL v21;

  if ((double)result <= a1)
  {
    v8 = 1;
  }
  else if ((double)-result >= a1)
  {
    v8 = 1;
    result = -result;
  }
  else
  {
    v4 = -a1;
    if (a1 >= 0.0)
      v4 = a1;
    v5 = (uint64_t)v4;
    if ((uint64_t)v4 > result || result < 1)
    {
      v12 = 0;
      v8 = 1;
    }
    else
    {
      v7 = 0;
      v8 = 0;
      v9 = v4 - (double)v5;
      v10 = 1.0;
      v11 = 1;
      v12 = 1;
      while (1)
      {
        v13 = v7 - 1;
        if (v7)
        {
          if (v10 > v9 * 100000.0)
            break;
        }
        if (v10 > v9 * (double)result && v7 == 0)
          break;
        v15 = (uint64_t)(v10 / v9);
        v8 += v11 * v15;
        v12 += v5 * v15;
        v16 = v4 / ((double)v5 / (double)v11) >= 1.0 && v12 <= result;
        if (!v16 || v8 > result)
          break;
        v10 = v10 - (double)(uint64_t)(v10 / v9) * v9;
        if (v9 <= v10 * 100000.0)
        {
          v18 = (double)v12 / (double)v8 / v4 < 1.0 || v7 == -9;
          v19 = (uint64_t)(v9 / v10);
          v9 = v9 - (double)v19 * v10;
          v11 += v8 * v19;
          v5 += v12 * v19;
          v20 = !v18 && v5 <= result;
          v21 = v20 && v11 <= result;
          v7 = v13;
          if (v21)
            continue;
        }
        goto LABEL_40;
      }
      v12 = v5;
      v8 = v11;
    }
LABEL_40:
    if (a1 >= 0.0)
      result = v12;
    else
      result = -v12;
  }
  *a3 = result;
  *a4 = v8;
  return result;
}

const char *IIOReadPlugin::ImageBlockReleaseNonCached(const char *result, const void *a2)
{
  size_t v3;
  unint64_t Data;

  v3 = (size_t)result;
  if ((gIIODebugFlags & 0xC00) != 0)
    result = IIO_ImageBlockReleased(result, a2);
  if (a2)
  {
    Data = CGImageBlockGetData();
    return (const char *)_ImageIO_Free(Data, v3);
  }
  return result;
}

CFArrayRef CGImageSourceCopyTypeIdentifiers(void)
{
  IIO_ReaderHandler *v0;
  IIO_ReaderHandler *ReaderHandler;
  __CFArray *v2;

  kdebug_trace();
  IIOInitDebugFlags();
  v0 = (IIO_ReaderHandler *)((gIIODebugFlags >> 12) & 3);
  if ((_DWORD)v0)
    ImageIODebugOptions((int)v0, "A", "CGImageSourceCopyTypeIdentifiers", 0, 0, -1, 0);
  ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(v0);
  v2 = IIO_ReaderHandler::copyTypeIdentifiers(ReaderHandler);
  kdebug_trace();
  return v2;
}

uint64_t IIO_ReaderHandler::setAllowableTypes(uint64_t **this, const __CFArray *a2)
{
  IIOArray *v3;
  __CFArray *v4;
  int Count;
  int v6;
  uint64_t *v7;
  uint64_t v8;
  const void *v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD v16[6];
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  int v20;
  _QWORD v21[3];

  memset(v21, 0, sizeof(v21));
  v3 = IIOArray::IIOArray((IIOArray *)v21, a2);
  IIOArray::getCount(v3);
  kdebug_trace();
  v17 = 0;
  v18 = &v17;
  v19 = 0x2000000000;
  v20 = 0;
  if (IIOArray::getCount((IIOArray *)v21))
  {
    v4 = IIO_ReaderHandler::copyTypeIdentifiers((IIO_ReaderHandler *)this);
    Count = CFArrayGetCount(v4);
    v16[0] = MEMORY[0x1E0C809B0];
    v16[1] = 0x40000000;
    v16[2] = ___ZN17IIO_ReaderHandler17setAllowableTypesEPK9__CFArray_block_invoke;
    v16[3] = &unk_1E1BC96D0;
    v16[4] = &v17;
    v16[5] = v4;
    IIOArray::enumerate((uint64_t)v21, (uint64_t)v16);
    CFRelease(v4);
    v6 = Count;
  }
  else
  {
    LogWarning("setAllowableTypes", 1249, "*** 'CGImageSourceSetAllowableTypes' -> disabling all image decoding\n");
    v6 = 0;
  }
  v7 = this[2];
  v8 = 4294967230;
  if (v7 != this[3])
  {
    do
    {
      v9 = (const void *)IIO_Reader::utType((IIO_Reader *)*v7);
      if ((IIOArray::containsValue((IIOArray *)v21, v9) & 1) != 0)
      {
        ++v7;
        v10 = this[3];
      }
      else
      {
        std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::unique_ptr<IIO_Reader> *,std::unique_ptr<IIO_Reader> *,std::unique_ptr<IIO_Reader> *,0>(v7 + 1, this[3], v7);
        v10 = v11;
        v12 = this[3];
        while (v12 != v10)
        {
          v14 = *--v12;
          v13 = v14;
          *v12 = 0;
          if (v14)
            (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
        }
        v8 = 0;
        this[3] = v10;
      }
    }
    while (v7 != v10);
  }
  if (v6)
    _cg_jpeg_mem_term("setAllowableTypes", 1283, "*** 'CGImageSourceSetAllowableTypes' - original: %d  new: %d (removed %d)\n", v6, *((_DWORD *)v18 + 6), v6 - *((_DWORD *)v18 + 6));
  kdebug_trace();
  _Block_object_dispose(&v17, 8);
  IIOArray::~IIOArray((IIOArray *)v21);
  return v8;
}

void sub_187E8EDC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  uint64_t v10;
  va_list va;

  va_start(va, a10);
  _Block_object_dispose(va, 8);
  IIOArray::~IIOArray((IIOArray *)(v10 - 72));
  _Unwind_Resume(a1);
}

const __CFArray *IIOArray::containsValue(IIOArray *this, const void *a2)
{
  const __CFArray *result;
  CFRange v5;

  result = (const __CFArray *)*((_QWORD *)this + 1);
  if (result)
  {
    v5.length = CFArrayGetCount(result);
    v5.location = 0;
    return (const __CFArray *)(CFArrayContainsValue(*((CFArrayRef *)this + 1), v5, a2) != 0);
  }
  return result;
}

void IIOReader_RawCamera::~IIOReader_RawCamera(IIOReader_RawCamera *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

void IIO_Reader_HEIF::~IIO_Reader_HEIF(IIO_Reader_HEIF *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

void IIO_Reader_PVR::~IIO_Reader_PVR(IIO_Reader_PVR *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

void IIO_Reader_BC::~IIO_Reader_BC(IIO_Reader_BC *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

void IIO_Reader_ASTC::~IIO_Reader_ASTC(IIO_Reader_ASTC *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

void IIO_Reader_ETC::~IIO_Reader_ETC(IIO_Reader_ETC *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

void IIO_Reader_OpenEXR::~IIO_Reader_OpenEXR(IIO_Reader_OpenEXR *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

void IIO_Reader_KTX2::~IIO_Reader_KTX2(IIO_Reader_KTX2 *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

void IIO_Reader_ICNS::~IIO_Reader_ICNS(IIO_Reader_ICNS *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

void IIO_Reader_TGA::~IIO_Reader_TGA(IIO_Reader_TGA *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

void IIO_Reader_RAD::~IIO_Reader_RAD(IIO_Reader_RAD *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

void IIO_Reader_PSD::~IIO_Reader_PSD(IIO_Reader_PSD *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

void IIO_Reader_PDF::~IIO_Reader_PDF(IIO_Reader_PDF *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

void IIO_Reader_PBM::~IIO_Reader_PBM(IIO_Reader_PBM *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

void IIO_Reader_AI::~IIO_Reader_AI(IIO_Reader_AI *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

void IIO_Reader_KTX::~IIO_Reader_KTX(IIO_Reader_KTX *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

void IIO_Reader_ATX::~IIO_Reader_ATX(IIO_Reader_ATX *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

void IIO_Reader_CUR::~IIO_Reader_CUR(IIO_Reader_CUR *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

void IIO_Reader_AppleJPEG::~IIO_Reader_AppleJPEG(IIO_Reader_AppleJPEG *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

void IIO_Reader_LibJPEG::~IIO_Reader_LibJPEG(IIO_Reader_LibJPEG *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

void IIO_Reader_WebP::~IIO_Reader_WebP(IIO_Reader_WebP *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

void IIO_Reader_TIFF::~IIO_Reader_TIFF(IIO_Reader_TIFF *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

void IIO_Reader_PNG::~IIO_Reader_PNG(IIO_Reader_PNG *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

void IIO_Reader_MPO::~IIO_Reader_MPO(IIO_Reader_MPO *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

void IIO_Reader_JP2::~IIO_Reader_JP2(IIO_Reader_JP2 *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

void IIO_Reader_ICO::~IIO_Reader_ICO(IIO_Reader_ICO *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

void IIO_Reader_GIF::~IIO_Reader_GIF(IIO_Reader_GIF *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

void IIO_Reader_BMP::~IIO_Reader_BMP(IIO_Reader_BMP *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

const char *LogWarning(const char *result, int a2, const char *a3, ...)
{
  va_list va;

  va_start(va, a3);
  if (gImageIOLogProc)
    return (const char *)gImageIOLogProc(0, 0, result, a2, a3, va);
  return result;
}

void ImageIOLogger(int a1, const char *a2, const char *a3, int a4, const char *a5, va_list a6)
{
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;
  os_log_type_t v13;
  NSObject *v14;
  NSObject *v15;
  uint64_t v16;
  char *v17;
  char *v18;
  uint8_t buf[4];
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (ImageIOLogger(int,char const*,char const*,int,char const*,char *)::once != -1)
    dispatch_once(&ImageIOLogger(int,char const*,char const*,int,char const*,char *)::once, &__block_literal_global_27);
  v17 = 0;
  v18 = 0;
  if (a3)
  {
    asprintf(&v18, "%s%s:%d: %s");
  }
  else if (a2)
  {
    asprintf(&v18, "%s: %s");
  }
  else
  {
    asprintf(&v18, "%s");
  }
  vasprintf(&v17, v18, a6);
  if (a1 <= 1)
  {
    if (a1)
    {
      if (a1 != 1)
        goto LABEL_25;
      v11 = gIIO_Log;
      if (!os_log_type_enabled((os_log_t)gIIO_Log, OS_LOG_TYPE_INFO))
        goto LABEL_25;
      *(_DWORD *)buf = 136446210;
      v20 = v17;
      v12 = v11;
      v13 = OS_LOG_TYPE_INFO;
    }
    else
    {
      v16 = gIIO_Log;
      if (!os_log_type_enabled((os_log_t)gIIO_Log, OS_LOG_TYPE_DEFAULT))
        goto LABEL_25;
      *(_DWORD *)buf = 136446210;
      v20 = v17;
      v12 = v16;
      v13 = OS_LOG_TYPE_DEFAULT;
    }
    _os_log_impl(&dword_187E34000, v12, v13, "%{public}s\n", buf, 0xCu);
    goto LABEL_25;
  }
  switch(a1)
  {
    case 2:
      v14 = gIIO_Log;
      if (os_log_type_enabled((os_log_t)gIIO_Log, OS_LOG_TYPE_DEBUG))
        ImageIOLogger((uint64_t *)&v17, v14);
      break;
    case 16:
      v15 = gIIO_Log;
      if (os_log_type_enabled((os_log_t)gIIO_Log, OS_LOG_TYPE_ERROR))
        ImageIOLogger((uint64_t *)&v17, v15);
      break;
    case 17:
      v10 = gIIO_Log;
      if (os_log_type_enabled((os_log_t)gIIO_Log, OS_LOG_TYPE_FAULT))
        ImageIOLogger((uint64_t *)&v17, v10);
      break;
  }
LABEL_25:
  free(v17);
  free(v18);
}

const char *_mappedDeallocate(void *a1, void *a2)
{
  const char *result;
  int *v5;
  char *v6;

  if (munmap(a1, (size_t)a2) < 0)
  {
    v5 = __error();
    v6 = strerror(*v5);
    return LogFault("_mappedDeallocate", 78, "Failed to unmap data (%p; 0x%lx): %s.\n", a1, a2, v6);
  }
  else
  {
    result = (const char *)kdebug_trace();
    if ((gIIODebugFlags & 0x100000000000) != 0)
    {
      result = ImageIOLog("   ------------------------------------------------------\n");
      if ((gIIODebugFlags & 0x100000000000) != 0)
      {
        result = ImageIOLog("    %s:%d             munmap   ptr: %p  size: %ld\n", "_mappedDeallocate", 84, a1, a2);
        if ((gIIODebugFlags & 0x100000000000) != 0)
          return ImageIOLog("   ------------------------------------------------------\n");
      }
    }
  }
  return result;
}

uint64_t RDF_Parser::EmptyPropertyElement(RDF_Parser *this, XMP_Node *a2, const XML_Node *a3, int a4)
{
  unsigned int v5;
  const char *v6;
  uint64_t result;
  uint64_t *v9;
  uint64_t *v10;
  char v11;
  int v12;
  char v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v19;
  BOOL v20;
  BOOL v21;
  XMP_Node *v22;
  int v23;
  char v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t v27;
  _QWORD *v28;
  int v29;
  char *v30;
  uint64_t v33;
  const char *v34;
  uint64_t v35;

  if (*((_QWORD *)a3 + 16) != *((_QWORD *)a3 + 17))
  {
    v35 = 0;
    v5 = 202;
    v6 = "Nested content not allowed with rdf:resource or property attributes";
    goto LABEL_3;
  }
  v9 = (uint64_t *)*((_QWORD *)a3 + 13);
  v10 = (uint64_t *)*((_QWORD *)a3 + 14);
  if (v9 == v10)
  {
    v15 = 0;
    v14 = 0;
    v12 = 0;
    v11 = 0;
LABEL_38:
    result = RDF_Parser::AddChildNode(this, a2, a3, "", a4);
    if (!result)
      return result;
    v22 = (XMP_Node *)result;
    if (((v14 | v12) & 1) != 0)
    {
      result = (uint64_t)std::string::operator=((std::string *)(result + 40), (const std::string *)(v15 + 64));
      if ((v14 & 1) == 0)
      {
        v23 = 2;
LABEL_44:
        v24 = (v14 | v12) ^ 1;
        *((_DWORD *)v22 + 2) |= v23;
LABEL_46:
        v26 = (uint64_t *)*((_QWORD *)a3 + 13);
        v25 = (uint64_t *)*((_QWORD *)a3 + 14);
        if (v26 == v25)
          return result;
        while (*v26 == v15)
        {
LABEL_62:
          if (++v26 == v25)
            return result;
        }
        result = GetRDFTermKind(*v26 + 40);
        switch((int)result)
        {
          case 0:
            v27 = *v26;
            if ((v24 & 1) == 0)
              goto LABEL_55;
            v28 = (_QWORD *)(v27 + 40);
            v29 = *(char *)(v27 + 63);
            if (v29 < 0)
            {
              if (*(_QWORD *)(v27 + 48) != 8)
              {
LABEL_59:
                v30 = (char *)(v27 + 64);
                if (*(char *)(v27 + 87) < 0)
                  v30 = *(char **)v30;
                result = RDF_Parser::AddChildNode(this, v22, (const XML_Node *)v27, v30, 0);
                goto LABEL_62;
              }
              v28 = (_QWORD *)*v28;
            }
            else if (v29 != 8)
            {
              goto LABEL_59;
            }
            if (*v28 == 0x676E616C3A6C6D78)
              goto LABEL_55;
            goto LABEL_59;
          case 2:
          case 6:
            goto LABEL_62;
          case 5:
            v27 = *v26;
LABEL_55:
            result = RDF_Parser::AddQualifierNode(this, v22, (const XML_Node *)v27);
            goto LABEL_62;
          default:
            v34 = "Unrecognized attribute of empty property element";
            v35 = 0;
            v33 = 202;
            result = GenericErrorCallback::NotifyClient(*(_QWORD *)this, 0, (unsigned int *)&v33, 0);
            goto LABEL_62;
        }
      }
    }
    else if ((v11 & 1) != 0)
    {
      v23 = 256;
      goto LABEL_44;
    }
    v24 = 0;
    goto LABEL_46;
  }
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  while (2)
  {
    switch(GetRDFTermKind(*v9 + 40))
    {
      case 0u:
        v16 = *v9 + 40;
        if ((*(char *)(*v9 + 63) & 0x80000000) == 0)
        {
          v17 = *(unsigned __int8 *)(*v9 + 63);
          if (v17 != 8)
          {
            if (v17 == 9 && *(_QWORD *)v16 == 0x756C61763A666472 && *(_BYTE *)(*v9 + 48) == 101)
              goto LABEL_35;
            goto LABEL_31;
          }
LABEL_30:
          v21 = *(_QWORD *)v16 != 0x676E616C3A6C6D78;
LABEL_32:
          v11 |= v21;
LABEL_33:
          if (++v9 == v10)
            goto LABEL_38;
          continue;
        }
        v19 = *(_QWORD *)(*v9 + 48);
        if (v19 == 8)
        {
          v16 = *(_QWORD *)v16;
          goto LABEL_30;
        }
        if (v19 != 9
          || (**(_QWORD **)v16 == 0x756C61763A666472 ? (v20 = *(_BYTE *)(*(_QWORD *)v16 + 8) == 101) : (v20 = 0),
              !v20))
        {
LABEL_31:
          v21 = 1;
          goto LABEL_32;
        }
LABEL_35:
        if ((v12 & 1) == 0)
        {
          v12 = 0;
          v14 = 1;
          v15 = *v9;
          goto LABEL_33;
        }
LABEL_66:
        v35 = 0;
        v5 = 203;
        v6 = "Empty property element can't have both rdf:value and rdf:resource";
LABEL_3:
        v34 = v6;
        v33 = v5;
        return GenericErrorCallback::NotifyClient(*(_QWORD *)this, 0, (unsigned int *)&v33, 0);
      case 2u:
        goto LABEL_33;
      case 5u:
        if ((v13 & 1) != 0)
          goto LABEL_64;
        if ((v14 & 1) != 0)
          goto LABEL_66;
        v14 = 0;
        v13 = 0;
        v15 = *v9;
        v12 = 1;
        goto LABEL_33;
      case 6u:
        if ((v12 & 1) != 0)
        {
LABEL_64:
          v35 = 0;
          v5 = 202;
          v6 = "Empty property element can't have both rdf:resource and rdf:nodeID";
          goto LABEL_3;
        }
        v12 = 0;
        v13 = 1;
        goto LABEL_33;
      default:
        v35 = 0;
        v5 = 202;
        v6 = "Unrecognized attribute of empty property element";
        goto LABEL_3;
    }
  }
}

uint64_t RDF_Parser::NodeElementAttrs(uint64_t this, size_t *a2, const XML_Node *a3, int a4)
{
  const XML_Node **v4;
  const XML_Node **v5;
  RDF_Parser *v8;
  int v9;
  uint64_t v11;
  size_t v12;
  char *v13;
  const char *v14;
  const XML_Node *v15;
  const std::string *v16;
  uint64_t v17;
  size_t v18;
  uint64_t v19;
  std::string *v20;
  std::string *v21;
  uint64_t v22;
  const char *v23;
  uint64_t v24;

  v4 = (const XML_Node **)*((_QWORD *)a3 + 13);
  v5 = (const XML_Node **)*((_QWORD *)a3 + 14);
  if (v4 != v5)
  {
    v8 = (RDF_Parser *)this;
    v9 = 0;
    v21 = (std::string *)(a2 + 2);
    while (1)
    {
      this = GetRDFTermKind((uint64_t)*v4 + 40);
      if ((this - 2) >= 2)
      {
        if (!(_DWORD)this)
        {
          v13 = (char *)*v4 + 64;
          if (*((char *)*v4 + 87) < 0)
            v13 = *(char **)v13;
          this = RDF_Parser::AddChildNode(v8, (XMP_Node *)a2, *v4, v13, a4);
          goto LABEL_21;
        }
        if ((_DWORD)this != 6)
          break;
      }
      if ((v9 & 0x4C) == 0)
      {
        v9 |= 1 << this;
        if ((_DWORD)this != 3 || a4 == 0)
          goto LABEL_21;
        if (a2[8])
          RDF_Parser::NodeElementAttrs();
        v11 = *((unsigned __int8 *)a2 + 39);
        if (*((char *)a2 + 39) < 0)
          v12 = a2[3];
        else
          v12 = *((unsigned __int8 *)a2 + 39);
        v15 = *v4;
        v16 = (const std::string *)((char *)*v4 + 64);
        if (!v12)
        {
          this = (uint64_t)std::string::operator=(v21, v16);
          goto LABEL_21;
        }
        v17 = *((unsigned __int8 *)v15 + 87);
        if (*((char *)v15 + 87) < 0)
        {
          if (!*((_QWORD *)v15 + 9))
            goto LABEL_21;
        }
        else if (!*((_BYTE *)v15 + 87))
        {
          goto LABEL_21;
        }
        if ((v11 & 0x80u) == 0)
          v18 = *((unsigned __int8 *)a2 + 39);
        else
          v18 = a2[3];
        v19 = *((_QWORD *)v15 + 9);
        if ((v17 & 0x80u) == 0)
          v19 = v17;
        if (v18 == v19)
        {
          if ((v17 & 0x80u) != 0)
            v16 = (const std::string *)v16->__r_.__value_.__r.__words[0];
          if ((v11 & 0x80) != 0)
          {
            this = memcmp(v21->__r_.__value_.__l.__data_, v16, a2[3]);
            if (!(_DWORD)this)
              goto LABEL_21;
          }
          else
          {
            if (!*((_BYTE *)a2 + 39))
              goto LABEL_21;
            v20 = v21;
            while (v20->__r_.__value_.__s.__data_[0] == v16->__r_.__value_.__s.__data_[0])
            {
              v20 = (std::string *)((char *)v20 + 1);
              v16 = (const std::string *)((char *)v16 + 1);
              if (!--v11)
                goto LABEL_21;
            }
          }
        }
        v24 = 0;
        v22 = 203;
        v14 = "Mismatched top level rdf:about values";
        goto LABEL_19;
      }
      v23 = "Mutally exclusive about, ID, nodeID attributes";
      v24 = 0;
      v22 = 202;
LABEL_20:
      this = GenericErrorCallback::NotifyClient(*(_QWORD *)v8, 0, (unsigned int *)&v22, 0);
LABEL_21:
      if (++v4 == v5)
        return this;
    }
    v24 = 0;
    v22 = 202;
    v14 = "Invalid nodeElement attribute";
LABEL_19:
    v23 = v14;
    goto LABEL_20;
  }
  return this;
}

uint64_t GetRDFTermKind(uint64_t a1)
{
  unsigned int v2;
  const char *v4;
  unint64_t v6;
  const char *v7;

  if (*(char *)(a1 + 23) < 0)
  {
    v6 = *(_QWORD *)(a1 + 8);
    if (v6 <= 4)
      return 0;
    v7 = *(const char **)a1;
    if (strncmp(*(const char **)a1, "rdf:", 4uLL))
      return 0;
    if (v6 == 6 && *(_DWORD *)v7 == 979788914 && *((_WORD *)v7 + 2) == 26988)
      return 9;
    if (v6 == 13)
    {
      if (**(_QWORD **)a1 == 0x737261703A666472 && *(_QWORD *)(*(_QWORD *)a1 + 5) == 0x6570795465737261)
        return 4;
      v6 = *(_QWORD *)(a1 + 8);
    }
    if (v6 == 15)
    {
      if (**(_QWORD **)a1 == 0x637365443A666472 && *(_QWORD *)(*(_QWORD *)a1 + 7) == 0x6E6F697470697263)
        return 8;
      v6 = *(_QWORD *)(a1 + 8);
    }
    if (v6 == 9)
    {
      v4 = *(const char **)a1;
      goto LABEL_47;
    }
  }
  else
  {
    v2 = *(unsigned __int8 *)(a1 + 23);
    if (v2 < 5 || *(_DWORD *)a1 != 979788914)
      return 0;
    v4 = (const char *)a1;
    switch(*(_BYTE *)(a1 + 23))
    {
      case 6:
        if (*(_DWORD *)a1 != 979788914 || *(_WORD *)(a1 + 4) != 26988)
          goto LABEL_51;
        return 9;
      case 9:
        goto LABEL_47;
      case 0xD:
        if (*(_QWORD *)a1 == 0x737261703A666472 && *(_QWORD *)(a1 + 5) == 0x6570795465737261)
          return 4;
        break;
      case 0xF:
        if (*(_QWORD *)a1 == 0x637365443A666472 && *(_QWORD *)(a1 + 7) == 0x6E6F697470697263)
          return 8;
        break;
      default:
        goto LABEL_51;
    }
    v4 = (const char *)a1;
    if (v2 == 9)
    {
LABEL_47:
      if (*(_QWORD *)v4 == 0x756F62613A666472 && v4[8] == 116)
        return 3;
    }
  }
LABEL_51:
  if (std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((_QWORD *)a1, "rdf:resource"))
    return 5;
  if (std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((_QWORD *)a1, "rdf:RDF"))
    return 1;
  if (std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((_QWORD *)a1, "rdf:ID"))
    return 2;
  if (std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((_QWORD *)a1, "rdf:nodeID"))
    return 6;
  if (std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((_QWORD *)a1, "rdf:datatype"))
    return 7;
  if (std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((_QWORD *)a1, "rdf:aboutEach"))
    return 10;
  if (std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((_QWORD *)a1, "rdf:aboutEachPrefix"))
  {
    return 11;
  }
  if (std::operator==[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((_QWORD *)a1, "rdf:bagID"))
    return 12;
  return 0;
}

void TouchUpDataModel(XMPMeta *a1, XMPMeta::ErrorCallbackInfo *a2)
{
  char **v3;
  uint64_t SchemaNode;
  uint64_t v5;
  uint64_t ChildNode;
  std::string *v7;
  int v8;
  char *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  XMP_Node *v14;
  XMP_Node *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  XMP_Node *v20;
  unint64_t v21;
  XMP_Node **v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;
  XMP_Node **v30;
  char *v31;
  char *v32;
  char *v33;
  XMP_Node *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  const std::string::value_type *v41;
  int v42;
  uint64_t v43;
  _QWORD *v44;
  uint64_t v45;
  unsigned __int8 **v46;
  std::string::size_type v47;
  char *v48;
  uint64_t v49;
  char *v50;
  void *v51;
  char *v52;
  std::string::size_type v53;
  int v54;
  const std::string::value_type *v55;
  std::string::size_type v56;
  unsigned __int8 *v57;
  uint64_t v58;
  uint64_t v59;
  std::string::size_type v60;
  unsigned __int8 *v61;
  unsigned __int8 *v62;
  int v63;
  const std::string::value_type *v64;
  std::string::size_type v65;
  uint64_t v66;
  uint64_t v67;
  std::string *v68;
  uint64_t v69;
  const char *v70;
  unint64_t v71;
  BOOL v72;
  int v73;
  unsigned int v74;
  unsigned int v75;
  uint64_t Node;
  _QWORD *v78;
  size_t v80;
  size_t v81;
  _QWORD *exception;
  _OWORD v84[2];
  uint64_t v85;
  void *__p[2];
  __int128 v87;
  uint64_t v88;

  v3 = (char **)((char *)a1 + 224);
  SchemaNode = FindSchemaNode((char **)a1 + 28, "http://ns.adobe.com/exif/1.0/", 0, 0, 0, 0);
  if (SchemaNode)
  {
    v5 = SchemaNode;
    ChildNode = FindChildNode(SchemaNode, "exif:GPSTimeStamp", 0, 0);
    if (ChildNode)
    {
      v7 = (std::string *)(ChildNode + 40);
      v88 = 0;
      *(_OWORD *)__p = 0u;
      v87 = 0u;
      v8 = *(char *)(ChildNode + 63);
      v9 = (char *)(ChildNode + 40);
      if (v8 < 0)
        v9 = (char *)v7->__r_.__value_.__r.__words[0];
      XMPUtils::ConvertToDate(v9, (uint64_t)__p);
      if (!LODWORD(__p[0]) && __PAIR64__(HIDWORD(__p[0]), 0) == LODWORD(__p[1]))
      {
        v10 = FindChildNode(v5, "exif:DateTimeOriginal", 0, 0);
        if (v10 || (v10 = FindChildNode(v5, "exif:DateTimeDigitized", 0, 0)) != 0)
        {
          v11 = (char *)(v10 + 40);
          v85 = 0;
          memset(v84, 0, sizeof(v84));
          if (*(char *)(v10 + 63) < 0)
            v11 = *(char **)v11;
          XMPUtils::ConvertToDate(v11, (uint64_t)v84);
          __p[0] = *(void **)&v84[0];
          LODWORD(__p[1]) = DWORD2(v84[0]);
          XMPUtils::ConvertFromDate((__int128 *)__p, v7);
        }
      }
    }
    v12 = FindChildNode(v5, "exif:UserComment", 0, 0);
    if (v12)
    {
      v13 = v12;
      if ((*(_BYTE *)(v12 + 9) & 0x1F) == 0)
      {
        v14 = (XMP_Node *)operator new();
        v15 = v14;
        v16 = (char *)(v13 + 40);
        if (*(char *)(v13 + 63) < 0)
          v16 = *(char **)(v13 + 40);
        XMP_Node::XMP_Node(v14, (XMP_Node *)v13, "[]", v16, *(_DWORD *)(v13 + 8));
        v17 = *((_QWORD *)v15 + 12);
        *((_QWORD *)v15 + 12) = *(_QWORD *)(v13 + 96);
        *(_QWORD *)(v13 + 96) = v17;
        v18 = *((_QWORD *)v15 + 13);
        *((_QWORD *)v15 + 13) = *(_QWORD *)(v13 + 104);
        *(_QWORD *)(v13 + 104) = v18;
        v19 = *((_QWORD *)v15 + 14);
        *((_QWORD *)v15 + 14) = *(_QWORD *)(v13 + 112);
        *(_QWORD *)(v13 + 112) = v19;
        if ((*((_BYTE *)v15 + 8) & 0x40) == 0)
        {
          __p[0] = 0;
          v20 = (XMP_Node *)operator new();
          XMP_Node::XMP_Node(v20, v15, "xml:lang", "x-default", 32);
          __p[0] = v20;
          std::vector<XMP_Node *>::insert((uint64_t)v15 + 96, *((char **)v15 + 12), (char *)__p);
          *((_DWORD *)v15 + 2) |= 0x50u;
        }
        std::string::erase((std::string *)(v13 + 40), 0, 0xFFFFFFFFFFFFFFFFLL);
        v21 = *(_QWORD *)(v13 + 88);
        *(_DWORD *)(v13 + 8) = 7680;
        v22 = *(XMP_Node ***)(v13 + 80);
        if ((unint64_t)v22 >= v21)
        {
          v24 = *(_QWORD *)(v13 + 72);
          v25 = ((uint64_t)v22 - v24) >> 3;
          if ((unint64_t)(v25 + 1) >> 61)
            std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
          v26 = v21 - v24;
          v27 = v26 >> 2;
          if (v26 >> 2 <= (unint64_t)(v25 + 1))
            v27 = v25 + 1;
          if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8)
            v28 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v28 = v27;
          if (v28)
            v29 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>(v13 + 88, v28);
          else
            v29 = 0;
          v30 = (XMP_Node **)&v29[8 * v25];
          v31 = &v29[8 * v28];
          *v30 = v15;
          v23 = v30 + 1;
          v33 = *(char **)(v13 + 72);
          v32 = *(char **)(v13 + 80);
          if (v32 != v33)
          {
            do
            {
              v34 = (XMP_Node *)*((_QWORD *)v32 - 1);
              v32 -= 8;
              *--v30 = v34;
            }
            while (v32 != v33);
            v32 = *(char **)(v13 + 72);
          }
          *(_QWORD *)(v13 + 72) = v30;
          *(_QWORD *)(v13 + 80) = v23;
          *(_QWORD *)(v13 + 88) = v31;
          if (v32)
            operator delete(v32);
        }
        else
        {
          *v22 = v15;
          v23 = v22 + 1;
        }
        *(_QWORD *)(v13 + 80) = v23;
      }
    }
  }
  v35 = FindSchemaNode(v3, "http://ns.adobe.com/xmp/1.0/DynamicMedia/", 0, 0, 0, 0);
  if (v35)
  {
    v36 = FindChildNode(v35, "xmpDM:copyright", 0, 0);
    if (v36)
    {
      v37 = v36;
      v38 = FindSchemaNode(v3, "http://purl.org/dc/elements/1.1/", 1, 0, 0, 0);
      v39 = FindChildNode(v38, "dc:rights", 0, 0);
      v40 = v39;
      v41 = (const std::string::value_type *)(v37 + 40);
      if (!v39 || *(_QWORD *)(v39 + 72) == *(_QWORD *)(v39 + 80))
      {
        std::string::insert((std::string *)(v37 + 40), 0, "\n\n");
        if (*(char *)(v37 + 63) < 0)
          v41 = *(const std::string::value_type **)v41;
        (*(void (**)(XMPMeta *, const char *, const char *, const char *, const char *, const std::string::value_type *, _QWORD))(*(_QWORD *)a1 + 128))(a1, "http://purl.org/dc/elements/1.1/", "rights", "", "x-default", v41, 0);
        goto LABEL_91;
      }
      __p[0] = 0;
      __p[1] = 0;
      *(_QWORD *)&v87 = 0;
      std::string::basic_string[abi:ne180100]<0>(__p, "x-default");
      v42 = LookupLangItem(v40, (unsigned __int8 **)__p);
      if (v42 < 0)
      {
        v43 = **(_QWORD **)(v40 + 72);
        v44 = (_QWORD *)(v43 + 40);
        if (*(char *)(v43 + 63) < 0)
          v44 = (_QWORD *)*v44;
        (*(void (**)(XMPMeta *, const char *, const char *, const char *, const char *, _QWORD *, _QWORD))(*(_QWORD *)a1 + 128))(a1, "http://purl.org/dc/elements/1.1/", "rights", "", "x-default", v44, 0);
        v42 = LookupLangItem(v40, (unsigned __int8 **)__p);
      }
      if (v42)
        __assert_rtn("MigrateAudioCopyright", "XMPMeta-Parse.cpp", 538, "xdIndex == 0");
      v45 = **(_QWORD **)(v40 + 72);
      v46 = (unsigned __int8 **)(v45 + 40);
      v47 = *(unsigned __int8 *)(v45 + 63);
      if (*(char *)(v45 + 63) < 0)
      {
        v48 = *(char **)(v45 + 40);
        v49 = *(_QWORD *)(v45 + 48);
      }
      else
      {
        v48 = (char *)(v45 + 40);
        v49 = *(unsigned __int8 *)(v45 + 63);
      }
      if (v49 >= 2)
      {
        v50 = &v48[v49];
        v51 = v48;
        while (1)
        {
          v52 = (char *)memchr(v51, 10, v49 - 1);
          if (!v52)
            goto LABEL_65;
          if (*(_WORD *)v52 == 2570)
            break;
          v51 = v52 + 1;
          v49 = v50 - (_BYTE *)v51;
          if (v50 - (_BYTE *)v51 < 2)
            goto LABEL_65;
        }
        if (v52 != v50 && (((_DWORD)v52 - (_DWORD)v48) & 0x80000000) == 0)
        {
          v53 = ((_DWORD)v52 - (_DWORD)v48) + 2;
          v54 = *(char *)(v37 + 63);
          v55 = *(const std::string::value_type **)(v37 + 40);
          if (v54 >= 0)
            v56 = *(unsigned __int8 *)(v37 + 63);
          else
            v56 = *(_QWORD *)(v37 + 48);
          if ((v47 & 0x80) != 0)
          {
            v47 = *(_QWORD *)(v45 + 48);
            if (v56 == -1 || v47 < v53)
LABEL_136:
              std::string::__throw_out_of_range[abi:ne180100]();
            v57 = *v46;
          }
          else
          {
            if (v53 > v47)
              goto LABEL_136;
            v57 = (unsigned __int8 *)(v45 + 40);
            if (v56 == -1)
              goto LABEL_136;
          }
          v80 = v47 - v53;
          if (v54 < 0)
            v41 = v55;
          if (v80 >= v56)
            v81 = v56;
          else
            v81 = v80;
          if (memcmp(&v57[v53], v41, v81) || v80 != v56)
            std::string::replace((std::string *)(v45 + 40), v53, 0xFFFFFFFFFFFFFFFFLL, v41, v56);
          goto LABEL_89;
        }
      }
LABEL_65:
      v58 = *(unsigned __int8 *)(v37 + 63);
      if ((v58 & 0x80u) == 0)
        v59 = *(unsigned __int8 *)(v37 + 63);
      else
        v59 = *(_QWORD *)(v37 + 48);
      if ((v47 & 0x80u) == 0)
        v60 = v47;
      else
        v60 = *(_QWORD *)(v45 + 48);
      if (v59 == v60)
      {
        if ((v47 & 0x80u) == 0)
          v61 = (unsigned __int8 *)(v45 + 40);
        else
          v61 = *v46;
        if ((v58 & 0x80) != 0)
        {
          if (!memcmp(*(const void **)v41, v61, *(_QWORD *)(v37 + 48)))
            goto LABEL_89;
        }
        else
        {
          if (!*(_BYTE *)(v37 + 63))
            goto LABEL_89;
          v62 = (unsigned __int8 *)(v37 + 40);
          while (*v62 == *v61)
          {
            ++v62;
            ++v61;
            if (!--v58)
              goto LABEL_89;
          }
        }
      }
      std::string::append((std::string *)(v45 + 40), "\n\n");
      v63 = *(char *)(v37 + 63);
      if (v63 >= 0)
        v64 = (const std::string::value_type *)(v37 + 40);
      else
        v64 = *(const std::string::value_type **)(v37 + 40);
      if (v63 >= 0)
        v65 = *(unsigned __int8 *)(v37 + 63);
      else
        v65 = *(_QWORD *)(v37 + 48);
      std::string::append((std::string *)(v45 + 40), v64, v65);
LABEL_89:
      if (SBYTE7(v87) < 0)
        operator delete(__p[0]);
LABEL_91:
      (*(void (**)(XMPMeta *, const char *, const char *))(*(_QWORD *)a1 + 80))(a1, "http://ns.adobe.com/xmp/1.0/DynamicMedia/", "copyright");
    }
  }
  v66 = FindSchemaNode(v3, "http://purl.org/dc/elements/1.1/", 0, 0, 0, 0);
  if (v66)
  {
    v67 = FindChildNode(v66, "dc:subject", 0, 0);
    if (v67)
      *(_DWORD *)(v67 + 8) &= 0xFFFFE3FF;
  }
  RepairAltText(v3, "http://purl.org/dc/elements/1.1/", "dc:description");
  RepairAltText(v3, "http://purl.org/dc/elements/1.1/", "dc:rights");
  RepairAltText(v3, "http://purl.org/dc/elements/1.1/", "dc:title");
  RepairAltText(v3, "http://ns.adobe.com/xap/1.0/rights/", "xmpRights:UsageTerms");
  RepairAltText(v3, "http://ns.adobe.com/exif/1.0/", "exif:UserComment");
  v68 = (std::string *)((char *)a1 + 240);
  if (*((char *)a1 + 263) < 0)
  {
    v69 = *((_QWORD *)a1 + 31);
    if (!v69)
      return;
    v70 = (const char *)v68->__r_.__value_.__r.__words[0];
    if (!strncmp(v68->__r_.__value_.__l.__data_, "uuid:", 5uLL))
      goto LABEL_114;
  }
  else
  {
    v69 = *((unsigned __int8 *)a1 + 263);
    if (!*((_BYTE *)a1 + 263))
      return;
    if (!strncmp((const char *)a1 + 240, "uuid:", 5uLL))
      goto LABEL_114;
    v70 = (char *)a1 + 240;
  }
  if (v69 == 36)
  {
    v71 = 0;
    v72 = 1;
    while (1)
    {
      v73 = v70[v71];
      if (v73 == 45)
      {
        if (v71 > 0x17 || ((1 << v71) & 0x842100) == 0)
          return;
      }
      else
      {
        v74 = v73 - 48;
        v75 = v73 - 97;
        if (v74 >= 0xA && v75 > 0x19)
        {
          if (!v72)
          {
LABEL_114:
            __p[0] = 0;
            __p[1] = 0;
            *(_QWORD *)&v87 = 0;
            ExpandXPath("http://ns.adobe.com/xap/1.0/mm/", "InstanceID", (uint64_t *)__p);
            Node = FindNode(v3, (const void ***)__p, 1, 0, 0);
            v78 = (_QWORD *)Node;
            if (!Node)
            {
              exception = __cxa_allocate_exception(0x18uLL);
              *(_DWORD *)exception = 9;
              exception[1] = "Failure creating xmpMM:InstanceID";
              *((_BYTE *)exception + 16) = 0;
            }
            *(_DWORD *)(Node + 8) = 0;
            std::string::operator=((std::string *)(Node + 40), v68);
            XMP_Node::RemoveChildren(v78);
            XMP_Node::RemoveQualifiers(v78);
            std::string::erase(v68, 0, 0xFFFFFFFFFFFFFFFFLL);
            *(_QWORD *)&v84[0] = __p;
            std::vector<XPathStepInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)v84);
          }
          return;
        }
      }
      v72 = v71++ < 0x23;
      if (v71 == 36)
        goto LABEL_114;
    }
  }
}

void sub_187E907A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint64_t v20;

  MEMORY[0x18D761C30](v20, 0x10B3C407D34617ELL);
  _Unwind_Resume(a1);
}

void RepairAltText(char **a1, char *a2, char *a3)
{
  uint64_t SchemaNode;
  uint64_t ChildNode;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  XMP_Node *v15;
  XMP_Node **v16;
  unint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  char *v24;
  char *v25;
  _QWORD *v26;
  uint64_t v27;
  XMP_Node *v28;

  SchemaNode = FindSchemaNode(a1, a2, 0, 0, 0, 0);
  if (SchemaNode)
  {
    ChildNode = FindChildNode(SchemaNode, a3, 0, 0);
    if (ChildNode)
    {
      v6 = ChildNode;
      if ((*(_DWORD *)(ChildNode + 8) & 0x1200) == 0x200)
      {
        *(_DWORD *)(ChildNode + 8) |= 0x1C00u;
        v7 = ((*(_QWORD *)(ChildNode + 80) - *(_QWORD *)(ChildNode + 72)) >> 3) - 1;
        if (v7 >= 0)
        {
          while (1)
          {
            v8 = v7;
            v9 = *(_QWORD *)(*(_QWORD *)(v6 + 72) + 8 * v7);
            v10 = *(_DWORD *)(v9 + 8);
            if ((v10 & 0x1F00) != 0)
              goto LABEL_6;
            if ((v10 & 0x40) == 0)
              break;
LABEL_30:
            v7 = v8 - 1;
            if ((int)v8 <= 0)
              return;
          }
          if (*(char *)(v9 + 63) < 0)
          {
            if (*(_QWORD *)(v9 + 48))
            {
LABEL_14:
              v28 = 0;
              v15 = (XMP_Node *)operator new();
              XMP_Node::XMP_Node(v15, (XMP_Node *)v9, "xml:lang", "x-repair", 32);
              v28 = v15;
              v16 = *(XMP_Node ***)(v9 + 96);
              if (v16 == *(XMP_Node ***)(v9 + 104))
              {
                v17 = *(_QWORD *)(v9 + 112);
                if ((unint64_t)v16 >= v17)
                {
                  v19 = v17 - (_QWORD)v16;
                  v20 = v19 >> 2;
                  if ((unint64_t)(v19 >> 2) <= 1)
                    v20 = 1;
                  if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
                    v21 = 0x1FFFFFFFFFFFFFFFLL;
                  else
                    v21 = v20;
                  v23 = std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>(v9 + 112, v21);
                  *v23 = v28;
                  v18 = v23 + 1;
                  v25 = *(char **)(v9 + 96);
                  v24 = *(char **)(v9 + 104);
                  v26 = v23;
                  if (v24 != v25)
                  {
                    do
                    {
                      v27 = *((_QWORD *)v24 - 1);
                      v24 -= 8;
                      *--v26 = v27;
                    }
                    while (v24 != v25);
                    v24 = *(char **)(v9 + 96);
                  }
                  *(_QWORD *)(v9 + 96) = v26;
                  *(_QWORD *)(v9 + 104) = v18;
                  *(_QWORD *)(v9 + 112) = &v23[v22];
                  if (v24)
                    operator delete(v24);
                }
                else
                {
                  *v16 = v15;
                  v18 = v16 + 1;
                }
                *(_QWORD *)(v9 + 104) = v18;
              }
              else
              {
                std::vector<XMP_Node *>::insert(v9 + 96, *(char **)(v9 + 96), (char *)&v28);
              }
              *(_DWORD *)(v9 + 8) |= 0x50u;
              goto LABEL_30;
            }
          }
          else if (*(_BYTE *)(v9 + 63))
          {
            goto LABEL_14;
          }
LABEL_6:
          (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
          v11 = *(_QWORD *)(v6 + 72);
          v12 = *(_QWORD *)(v6 + 80);
          v13 = v11 + 8 * v8;
          v14 = v12 - (v13 + 8);
          if (v12 != v13 + 8)
            memmove((void *)(v11 + 8 * v8), (const void *)(v13 + 8), v12 - (v13 + 8));
          *(_QWORD *)(v6 + 80) = v13 + v14;
          goto LABEL_30;
        }
      }
    }
  }
}

void sub_187E90A68(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10B3C407D34617ELL);
  _Unwind_Resume(a1);
}

uint64_t RDF_Parser::AddChildNode(RDF_Parser *this, XMP_Node *a2, const XML_Node *a3, char *a4, int a5)
{
  uint64_t v6;
  int v7;
  char v8;
  XMP_Node *v10;
  const void **v11;
  int v12;
  _BOOL4 v13;
  _BOOL4 v15;
  unsigned int v16;
  const char *v17;
  uint64_t v18;
  char *v19;
  int v23;
  char *v24;
  uint64_t SchemaNode;
  int v26;
  int v27;
  uint64_t v28;
  const char *v29;
  unint64_t v30;
  const void **v31;
  uint64_t v32;
  unint64_t v33;
  int v34;
  XMP_Node *v36;
  XMP_Node **v37;
  unint64_t v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  char *v45;
  XMP_Node **v46;
  char *v47;
  char *v48;
  char *v49;
  XMP_Node *v50;
  _QWORD v52[2];
  uint64_t v53;

  v6 = *((unsigned __int8 *)a3 + 39);
  v7 = (char)v6;
  if ((v6 & 0x80u) != 0)
    v6 = *((_QWORD *)a3 + 3);
  if (v6)
  {
    v8 = a5;
    v10 = a2;
    v11 = (const void **)((char *)a3 + 40);
    if (*((char *)a3 + 63) < 0)
    {
      v19 = (char *)*((_QWORD *)a3 + 5);
      v18 = *((_QWORD *)a3 + 6);
      v15 = v18 == 6 && *(_DWORD *)v19 == 979788914 && *((_WORD *)v19 + 2) == 26988;
      v13 = v18 == 9 && *(_QWORD *)v19 == 0x756C61763A666472 && v19[8] == 101;
    }
    else
    {
      v12 = *((unsigned __int8 *)a3 + 63);
      if (v12 == 9)
      {
        v15 = 0;
        v13 = *v11 == (const void *)0x756C61763A666472 && *((_BYTE *)a3 + 48) == 101;
      }
      else if (v12 == 6)
      {
        v13 = 0;
        v15 = *(_DWORD *)v11 == 979788914 && *((_WORD *)a3 + 22) == 26988;
      }
      else
      {
        v13 = 0;
        v15 = 0;
      }
      v19 = (char *)a3 + 40;
    }
    v23 = *((_DWORD *)a2 + 2);
    if (!a5)
      goto LABEL_51;
    if (*((_QWORD *)a2 + 8))
      RDF_Parser::AddChildNode();
    if (v7 >= 0)
      v24 = (char *)a3 + 16;
    else
      v24 = (char *)*((_QWORD *)a3 + 2);
    SchemaNode = FindSchemaNode((char **)v10, v24, 1, 0, 0, 0);
    v10 = (XMP_Node *)SchemaNode;
    v26 = *(_DWORD *)(SchemaNode + 8);
    if ((v26 & 0x8000) != 0)
      *(_DWORD *)(SchemaNode + 8) = v26 ^ 0x8000;
    if (sRegisteredAliasMap + 8 == std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::find<std::string>(sRegisteredAliasMap, v11))
    {
LABEL_51:
      v27 = 0;
      if (!v15)
        goto LABEL_47;
    }
    else
    {
      *(_DWORD *)(*((_QWORD *)v10 + 8) + 8) |= 0x20000u;
      v27 = 0x10000;
      if (!v15)
      {
LABEL_47:
        if ((v23 & 0x200) == 0)
        {
          if (!v13)
          {
            if (FindChildNode((uint64_t)v10, v19, 0, 0))
            {
              v53 = 0;
              v16 = 203;
              v17 = "Duplicate property or field node";
              goto LABEL_77;
            }
LABEL_80:
            v36 = (XMP_Node *)operator new();
            XMP_Node::XMP_Node(v36, v10, v19, a4, v27);
            v52[0] = v36;
            if (v13)
            {
              v37 = (XMP_Node **)*((_QWORD *)v10 + 9);
              if (v37 != *((XMP_Node ***)v10 + 10))
              {
                std::vector<XMP_Node *>::insert((uint64_t)v10 + 72, *((char **)v10 + 9), (char *)v52);
                return v52[0];
              }
            }
            else
            {
              v37 = (XMP_Node **)*((_QWORD *)v10 + 10);
            }
            v38 = *((_QWORD *)v10 + 11);
            if ((unint64_t)v37 >= v38)
            {
              v40 = *((_QWORD *)v10 + 9);
              v41 = ((uint64_t)v37 - v40) >> 3;
              if ((unint64_t)(v41 + 1) >> 61)
                std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
              v42 = v38 - v40;
              v43 = v42 >> 2;
              if (v42 >> 2 <= (unint64_t)(v41 + 1))
                v43 = v41 + 1;
              if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFF8)
                v44 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v44 = v43;
              if (v44)
                v45 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)v10 + 88, v44);
              else
                v45 = 0;
              v46 = (XMP_Node **)&v45[8 * v41];
              v47 = &v45[8 * v44];
              *v46 = v36;
              v39 = v46 + 1;
              v49 = (char *)*((_QWORD *)v10 + 9);
              v48 = (char *)*((_QWORD *)v10 + 10);
              if (v48 != v49)
              {
                do
                {
                  v50 = (XMP_Node *)*((_QWORD *)v48 - 1);
                  v48 -= 8;
                  *--v46 = v50;
                }
                while (v48 != v49);
                v48 = (char *)*((_QWORD *)v10 + 9);
              }
              *((_QWORD *)v10 + 9) = v46;
              *((_QWORD *)v10 + 10) = v39;
              *((_QWORD *)v10 + 11) = v47;
              if (v48)
                operator delete(v48);
            }
            else
            {
              *v37 = v36;
              v39 = v37 + 1;
            }
            *((_QWORD *)v10 + 10) = v39;
            return v52[0];
          }
LABEL_74:
          if ((v8 & 1) != 0 || (v34 = *((_DWORD *)v10 + 2), (v34 & 0x100) == 0))
          {
            v53 = 0;
            v16 = 202;
            v17 = "Misplaced rdf:value element";
            goto LABEL_77;
          }
          *((_DWORD *)v10 + 2) = v34 | 0x10000000;
          goto LABEL_80;
        }
        v28 = *((unsigned __int8 *)a3 + 63);
        if (*((char *)a3 + 63) < 0)
        {
          if (*((_QWORD *)a3 + 6) < 6uLL)
          {
LABEL_60:
            v53 = 0;
            v16 = 202;
            v17 = "Array items cannot have arbitrary child names";
            goto LABEL_77;
          }
          v29 = (const char *)*v11;
        }
        else
        {
          v29 = (const char *)v11;
          if (v28 < 6)
            goto LABEL_60;
        }
        if (strncmp(v29, "rdf:_", 5uLL))
          goto LABEL_60;
        v30 = (v28 & 0x80u) == 0 ? v28 : *((_QWORD *)a3 + 6);
        if (v30 >= 6)
        {
          v31 = (v28 & 0x80u) == 0 ? v11 : (const void **)*v11;
          if (*((unsigned __int8 *)v31 + 5) - 58 < 0xFFFFFFF6)
            goto LABEL_60;
          v32 = 6;
          do
          {
            v33 = v32;
            if (v30 == v32)
              break;
            ++v32;
          }
          while (*((unsigned __int8 *)v31 + v33) - 58 > 0xFFFFFFF5);
          if (v33 < v30)
            goto LABEL_60;
        }
LABEL_73:
        v19 = "[]";
        if (!v13)
          goto LABEL_80;
        goto LABEL_74;
      }
    }
    if ((v23 & 0x200) == 0)
    {
      v53 = 0;
      v16 = 202;
      v17 = "Misplaced rdf:li element";
      goto LABEL_77;
    }
    goto LABEL_73;
  }
  v53 = 0;
  v16 = 202;
  v17 = "XML namespace required for all elements and attributes";
LABEL_77:
  v52[1] = v17;
  v52[0] = v16;
  GenericErrorCallback::NotifyClient(*(_QWORD *)this, 0, (unsigned int *)v52, 0);
  return 0;
}

void sub_187E90F00(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10B3C407D34617ELL);
  _Unwind_Resume(a1);
}

uint64_t FindNode(char **a1, const void ***a2, int a3, int a4, char **a5)
{
  const void **v10;
  const void **v11;
  uint64_t v12;
  uint64_t result;
  int v14;
  char *v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  _QWORD *v20;
  uint64_t SchemaNode;
  int v22;
  int v23;
  unint64_t v24;
  int v25;
  uint64_t v27;
  int v28;
  unint64_t v29;
  int v30;
  _QWORD *exception;
  char *v32;

  v32 = 0;
  if (a4 && (a3 & 1) == 0)
    FindNode();
  v10 = *a2;
  v11 = a2[1];
  if (*a2 == v11)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 102;
    exception[1] = "Empty XPath";
    *((_BYTE *)exception + 16) = 0;
  }
  v12 = (char *)v11 - (char *)v10;
  if (((_BYTE)v10[7] & 0x10) != 0)
  {
    v17 = std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::find<std::string>(sRegisteredAliasMap, v10 + 4);
    if (sRegisteredAliasMap + 8 == v17)
      FindNode();
    v18 = v17;
    v20 = (_QWORD *)(v17 + 56);
    v19 = *(char **)(v17 + 56);
    if (v19[23] < 0)
      v19 = *(char **)v19;
    SchemaNode = FindSchemaNode(a1, v19, a3, (uint64_t **)&v32, 0, 0);
    if (SchemaNode)
    {
      v22 = *(_DWORD *)(SchemaNode + 8);
      if ((v22 & 0x8000) != 0)
      {
        *(_DWORD *)(SchemaNode + 8) = v22 ^ 0x8000;
        v15 = v32;
        v23 = 1;
      }
      else
      {
        v15 = 0;
        v23 = 0;
      }
      result = FollowXPathStep(SchemaNode, v20, 1, a3, &v32, 0);
      if (!result)
        goto LABEL_44;
      v25 = *(_DWORD *)(result + 8);
      if ((v25 & 0x8000) != 0)
      {
        *(_DWORD *)(result + 8) = v25 ^ 0x8000;
        if ((unint64_t)v12 >= 0x41 && (v25 & 0x1F00) == 0 && ((_DWORD)(*a2)[11] & 0xF) == 1)
          *(_DWORD *)(result + 8) = v25 ^ 0x8000 | 0x100;
        if ((v22 & 0x8000) == 0)
          v15 = v32;
        v23 = 1;
      }
      if ((*(_DWORD *)(*v20 + 56) & 0x1E00) != 0 && (*(_DWORD *)(*v20 + 56) & 0x200) == 0)
        FindNode();
      v27 = *(_QWORD *)(v18 + 64) - *v20;
      if ((*(_DWORD *)(*v20 + 56) & 0x1E00) != 0)
      {
        if (v27 == 96)
        {
          result = FollowXPathStep(result, v20, 2, a3, &v32, 1);
          if (result)
          {
            v28 = *(_DWORD *)(result + 8);
            if ((v28 & 0x8000) != 0)
            {
              *(_DWORD *)(result + 8) = v28 ^ 0x8000;
              if ((unint64_t)v12 >= 0x41 && (v28 & 0x1F00) == 0 && ((_DWORD)(*a2)[11] & 0xF) == 1)
                *(_DWORD *)(result + 8) = v28 ^ 0x8000 | 0x100;
              if (!v23)
                v15 = v32;
              v23 = 1;
            }
            goto LABEL_50;
          }
LABEL_44:
          v16 = v23 != 0;
LABEL_45:
          if (a3)
            FindNode();
          if (v16)
            DeleteSubtree(v15);
          return 0;
        }
      }
      else if (v27 == 64)
      {
LABEL_50:
        v16 = v23 != 0;
        v24 = 2;
LABEL_51:
        v29 = v12 >> 5;
        if (v24 >= v29)
        {
LABEL_63:
          if (result != *(_QWORD *)v32)
            FindNode();
          if (v16)
            *(_DWORD *)(result + 8) |= a4;
          if (a5)
            *a5 = v32;
          return result;
        }
        while (1)
        {
          result = FollowXPathStep(result, a2, v24, a3, &v32, 0);
          if (!result)
            goto LABEL_45;
          v30 = *(_DWORD *)(result + 8);
          if ((v30 & 0x8000) != 0)
          {
            *(_DWORD *)(result + 8) = v30 ^ 0x8000;
            if (++v24 < v29 && (v30 & 0x1F00) == 0 && ((uint64_t)(*a2)[4 * v24 + 3] & 0xF) == 1)
              *(_DWORD *)(result + 8) = v30 ^ 0x8000 | 0x100;
            if (!v16)
              v15 = v32;
            v16 = 1;
          }
          else
          {
            ++v24;
          }
          if (v24 == v29)
            goto LABEL_63;
        }
      }
      FindNode();
    }
    v15 = 0;
    v23 = 0;
    goto LABEL_44;
  }
  if (*((char *)v10 + 23) < 0)
    v10 = (const void **)*v10;
  result = FindSchemaNode(a1, (char *)v10, a3, (uint64_t **)&v32, 0, 0);
  if (result)
  {
    v14 = *(_DWORD *)(result + 8);
    if ((v14 & 0x8000) != 0)
    {
      *(_DWORD *)(result + 8) = v14 ^ 0x8000;
      v15 = v32;
      v16 = 1;
    }
    else
    {
      v15 = 0;
      v16 = 0;
    }
    v24 = 1;
    goto LABEL_51;
  }
  return result;
}

void sub_187E912A0(void *a1)
{
  char *v1;
  char v2;

  __cxa_begin_catch(a1);
  if ((v2 & 1) != 0)
    DeleteSubtree(v1);
  __cxa_rethrow();
}

void sub_187E912B8(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t FindSchemaNode(char **a1, char *__s, int a3, uint64_t **a4, uint64_t (*a5)(uint64_t, char *, _BYTE *, _BYTE *), uint64_t a6)
{
  char **v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t i;
  uint64_t v15;
  _QWORD *v16;
  size_t v17;
  unsigned int *v18;
  char NamespacePrefix;
  uint64_t **v20;
  unint64_t v21;
  uint64_t *v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  char *v28;
  uint64_t *v29;
  char *v30;
  char *v31;
  char *v32;
  uint64_t v33;
  _BYTE v36[12];

  if (a1[8])
    FindSchemaNode();
  v12 = (uint64_t *)a1[9];
  v11 = a1 + 9;
  v13 = a1[10] - (char *)v12;
  if (v13)
  {
    for (i = v13 >> 3; i; --i)
    {
      v15 = *v12;
      if (*(char ***)(*v12 + 64) != a1)
        FindSchemaNode();
      v16 = (_QWORD *)(v15 + 16);
      v17 = strlen(__s);
      if (*(char *)(v15 + 39) < 0)
      {
        if (v17 != *(_QWORD *)(v15 + 24))
          goto LABEL_13;
        if (v17 == -1)
LABEL_47:
          std::string::__throw_out_of_range[abi:ne180100]();
        v16 = (_QWORD *)*v16;
      }
      else
      {
        if (v17 != *(unsigned __int8 *)(v15 + 39))
          goto LABEL_13;
        if (v17 == -1)
          goto LABEL_47;
      }
      if (!memcmp(v16, __s, v17))
      {
        v20 = a4;
        if (!a4)
          return v15;
LABEL_41:
        *v20 = v12;
        if (v15 != *v12)
          FindSchemaNode();
        return v15;
      }
LABEL_13:
      ++v12;
    }
  }
  if (!a3)
    return 0;
  v15 = operator new();
  XMP_Node::XMP_Node((XMP_Node *)v15, (XMP_Node *)a1, __s, -2147450880);
  memset(v36, 0, sizeof(v36));
  if (a5 && a6)
    NamespacePrefix = a5(a6, __s, &v36[4], v36);
  else
    NamespacePrefix = XMPMeta::GetNamespacePrefix((XMPMeta *)__s, (const char **)&v36[4], (const char **)v36, v18);
  if ((NamespacePrefix & 1) == 0)
    __assert_rtn("FindSchemaNode", "XMPCore_Impl.cpp", 860, "found");
  MEMORY[0x18D761A20](v15 + 40, *(_QWORD *)&v36[4], *(unsigned int *)v36);
  v21 = (unint64_t)a1[11];
  v22 = (uint64_t *)a1[10];
  if ((unint64_t)v22 >= v21)
  {
    v24 = ((char *)v22 - *v11) >> 3;
    if ((unint64_t)(v24 + 1) >> 61)
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    v25 = v21 - (_QWORD)*v11;
    v26 = v25 >> 2;
    if (v25 >> 2 <= (unint64_t)(v24 + 1))
      v26 = v24 + 1;
    if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8)
      v27 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v27 = v26;
    if (v27)
      v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)(a1 + 11), v27);
    else
      v28 = 0;
    v29 = (uint64_t *)&v28[8 * v24];
    v30 = &v28[8 * v27];
    *v29 = v15;
    v23 = (char *)(v29 + 1);
    v32 = a1[9];
    v31 = a1[10];
    if (v31 != v32)
    {
      do
      {
        v33 = *((_QWORD *)v31 - 1);
        v31 -= 8;
        *--v29 = v33;
      }
      while (v31 != v32);
      v31 = *v11;
    }
    a1[9] = (char *)v29;
    a1[10] = v23;
    a1[11] = v30;
    v20 = a4;
    if (v31)
      operator delete(v31);
  }
  else
  {
    *v22 = v15;
    v23 = (char *)(v22 + 1);
    v20 = a4;
  }
  a1[10] = v23;
  if (v20)
  {
    v12 = (uint64_t *)(v23 - 8);
    goto LABEL_41;
  }
  return v15;
}

void sub_187E91554(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10B3C407D34617ELL);
  _Unwind_Resume(a1);
}

void sub_187E91578(void *a1)
{
  uint64_t v1;

  __cxa_begin_catch(a1);
  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  __cxa_rethrow();
}

void sub_187E91594()
{
  __cxa_end_catch();
  JUMPOUT(0x187E9159CLL);
}

uint64_t FollowXPathStep(uint64_t a1, _QWORD *a2, uint64_t a3, int a4, char **a5, int a6)
{
  uint64_t v6;
  _DWORD *v7;
  int v8;
  char **v9;
  int v10;
  uint64_t result;
  int v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  _BYTE *v17;
  _QWORD *v18;
  const char *v20;
  std::string *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  int v25;
  char *v26;
  int v27;
  int v28;
  char **v29;
  uint64_t v30;
  unint64_t v32;
  XMP_Node **v33;
  _QWORD *v34;
  uint64_t v35;
  uint64_t v36;
  unsigned __int8 *v37;
  std::string::size_type size;
  std::string *p_p;
  _QWORD *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  const void **v48;
  unsigned __int8 *v49;
  uint64_t v50;
  uint64_t v51;
  const void **v52;
  std::string *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  char *v58;
  XMP_Node **v59;
  char *v60;
  char *v61;
  char *v62;
  XMP_Node *v63;
  BOOL v64;
  uint64_t v65;
  int v66;
  BOOL v67;
  int v69;
  _DWORD *v70;
  XMP_Node *v71;
  XMP_Node *v72;
  unint64_t v73;
  XMP_Node **v74;
  _QWORD *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  unint64_t v80;
  char *v81;
  XMP_Node **v82;
  char *v83;
  char *v84;
  char *v85;
  XMP_Node *v86;
  uint64_t *v87;
  unint64_t v88;
  _QWORD *v89;
  uint64_t v90;
  uint64_t v91;
  unint64_t v92;
  _QWORD *v93;
  uint64_t v94;
  _QWORD *v95;
  char *v96;
  char *v97;
  uint64_t v98;
  int v99;
  int v100;
  const char *v101;
  _QWORD *exception;
  const char *v103;
  int v104;
  char **v105;
  uint64_t v106;
  std::string *v107;
  int v109;
  uint64_t v110;
  uint64_t v112;
  std::string::size_type v113;
  XMP_Node *__s2;
  unsigned __int8 *__s2a;
  std::string __p;
  void *v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;

  v120 = 0;
  v6 = *a2 + 32 * a3;
  v7 = (_DWORD *)(v6 + 24);
  v8 = *(_DWORD *)(v6 + 24) & 0xF;
  if ((v8 - 7) <= 0xFFFFFFF9)
    FollowXPathStep();
  v9 = a5;
  v10 = a4;
  if (v8 == 2)
  {
    if (*(char *)(v6 + 23) < 0)
      v6 = *(_QWORD *)v6;
    if (*(_BYTE *)v6 != 63)
      FollowXPathStep();
    result = (uint64_t)FindQualifierNode(a1, (char *)(v6 + 1), a4, a5);
    goto LABEL_11;
  }
  if (v8 == 1)
  {
    if (*(char *)(v6 + 23) < 0)
      v6 = *(_QWORD *)v6;
    result = FindChildNode(a1, (char *)v6, a4, (uint64_t **)a5);
LABEL_11:
    v120 = result;
    goto LABEL_12;
  }
  if ((*(_BYTE *)(a1 + 9) & 2) == 0)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 102;
    v103 = "Indexing applied to non-array";
    goto LABEL_193;
  }
  v13 = a6;
  v14 = a3;
  switch(v8)
  {
    case 3:
      v15 = *(unsigned __int8 *)(v6 + 23);
      if (*(char *)(v6 + 23) < 0)
      {
        v16 = *(_QWORD *)(v6 + 8) - 1;
        if (v16 <= 1)
          goto LABEL_188;
        v17 = *(_BYTE **)v6;
      }
      else
      {
        v16 = v15 - 1;
        v17 = (_BYTE *)(*a2 + 32 * a3);
        if ((unint64_t)(v15 - 1) <= 1)
          goto LABEL_188;
      }
      if (*v17 != 91
        || ((v15 & 0x80u) == 0 ? (v23 = *a2 + 32 * a3) : (v23 = *(_QWORD *)v6), *(_BYTE *)(v23 + v16) != 93))
      {
LABEL_188:
        FollowXPathStep();
      }
      v24 = v16 - 1;
      if (!v24)
        goto LABEL_195;
      v25 = 0;
      v26 = (char *)(v23 + 1);
      do
      {
        v28 = *v26++;
        v27 = v28;
        if ((v28 - 48) >= 0xA)
          FollowXPathStep();
        v25 = v27 + 10 * v25 - 48;
        if (v25 < 0)
        {
          exception = __cxa_allocate_exception(0x18uLL);
          *(_DWORD *)exception = 102;
          v103 = "Array index overflow";
          goto LABEL_193;
        }
        --v24;
      }
      while (v24);
      if (!v25)
      {
LABEL_195:
        exception = __cxa_allocate_exception(0x18uLL);
        *(_DWORD *)exception = 102;
        v103 = "Array index must be larger than zero";
LABEL_193:
        exception[1] = v103;
        *((_BYTE *)exception + 16) = 0;
      }
      LODWORD(v22) = v25 - 1;
      v29 = (char **)(a1 + 72);
      v30 = (*(_QWORD *)(a1 + 80) - *(_QWORD *)(a1 + 72)) >> 3;
      if (v25 - 1 == (_DWORD)v30 && a4 != 0)
      {
        __s2 = (XMP_Node *)operator new();
        XMP_Node::XMP_Node(__s2, (XMP_Node *)a1, "[]", 0x8000);
        v32 = *(_QWORD *)(a1 + 88);
        v33 = *(XMP_Node ***)(a1 + 80);
        if ((unint64_t)v33 >= v32)
        {
          v54 = ((char *)v33 - *v29) >> 3;
          if ((unint64_t)(v54 + 1) >> 61)
            std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
          v55 = v32 - (_QWORD)*v29;
          v56 = v55 >> 2;
          if (v55 >> 2 <= (unint64_t)(v54 + 1))
            v56 = v54 + 1;
          if ((unint64_t)v55 >= 0x7FFFFFFFFFFFFFF8)
            v57 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v57 = v56;
          if (v57)
            v58 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>(a1 + 88, v57);
          else
            v58 = 0;
          v59 = (XMP_Node **)&v58[8 * v54];
          v60 = &v58[8 * v57];
          *v59 = __s2;
          v34 = v59 + 1;
          v62 = *(char **)(a1 + 72);
          v61 = *(char **)(a1 + 80);
          if (v61 != v62)
          {
            do
            {
              v63 = (XMP_Node *)*((_QWORD *)v61 - 1);
              v61 -= 8;
              *--v59 = v63;
            }
            while (v61 != v62);
            v61 = *v29;
          }
          *(_QWORD *)(a1 + 72) = v59;
          *(_QWORD *)(a1 + 80) = v34;
          *(_QWORD *)(a1 + 88) = v60;
          if (v61)
            operator delete(v61);
        }
        else
        {
          *v33 = __s2;
          v34 = v33 + 1;
        }
        *(_QWORD *)(a1 + 80) = v34;
        v30 = ((unint64_t)v34 - *(_QWORD *)(a1 + 72)) >> 3;
        v13 = a6;
      }
      v64 = v25 <= (int)v30;
      v14 = a3;
      if (v64)
        goto LABEL_120;
      LODWORD(v22) = -1;
LABEL_123:
      if ((_DWORD)v22 == -1)
      {
        if (v10)
        {
          LODWORD(v22) = -1;
          if (v8 == 5)
          {
            if (v13)
            {
              if ((*(_BYTE *)(a1 + 9) & 0x10) == 0)
                FollowXPathStep();
              if (v14 != 2)
                goto LABEL_190;
              v66 = *(char *)(v6 + 23);
              if (v66 < 0)
              {
                if (*(_QWORD *)(v6 + 8) != 23)
                  goto LABEL_190;
                v6 = *(_QWORD *)v6;
              }
              else if (v66 != 23)
              {
                goto LABEL_190;
              }
              v67 = *(_QWORD *)v6 == 0x616C3A6C6D783F5BLL && *(_QWORD *)(v6 + 8) == 0x65642D78223D676ELL;
              if (!v67 || *(_QWORD *)(v6 + 15) != 0x5D22746C75616665)
LABEL_190:
                FollowXPathStep();
              v69 = v10;
              v70 = v7;
              v71 = (XMP_Node *)operator new();
              XMP_Node::XMP_Node(v71, (XMP_Node *)a1, "[]", 32848);
              v120 = (uint64_t)v71;
              v72 = (XMP_Node *)operator new();
              XMP_Node::XMP_Node(v72, v71, "xml:lang", "x-default", 32);
              v73 = *((_QWORD *)v71 + 14);
              v74 = (XMP_Node **)*((_QWORD *)v71 + 13);
              if ((unint64_t)v74 >= v73)
              {
                v76 = *((_QWORD *)v71 + 12);
                v77 = ((uint64_t)v74 - v76) >> 3;
                if ((unint64_t)(v77 + 1) >> 61)
                  std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
                v78 = v73 - v76;
                v79 = v78 >> 2;
                if (v78 >> 2 <= (unint64_t)(v77 + 1))
                  v79 = v77 + 1;
                if ((unint64_t)v78 >= 0x7FFFFFFFFFFFFFF8)
                  v80 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v80 = v79;
                if (v80)
                  v81 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)v71 + 112, v80);
                else
                  v81 = 0;
                v82 = (XMP_Node **)&v81[8 * v77];
                v83 = &v81[8 * v80];
                *v82 = v72;
                v75 = v82 + 1;
                v85 = (char *)*((_QWORD *)v71 + 12);
                v84 = (char *)*((_QWORD *)v71 + 13);
                if (v84 != v85)
                {
                  do
                  {
                    v86 = (XMP_Node *)*((_QWORD *)v84 - 1);
                    v84 -= 8;
                    *--v82 = v86;
                  }
                  while (v84 != v85);
                  v84 = (char *)*((_QWORD *)v71 + 12);
                }
                *((_QWORD *)v71 + 12) = v82;
                *((_QWORD *)v71 + 13) = v75;
                *((_QWORD *)v71 + 14) = v83;
                if (v84)
                  operator delete(v84);
              }
              else
              {
                *v74 = v72;
                v75 = v74 + 1;
              }
              *((_QWORD *)v71 + 13) = v75;
              v87 = *(uint64_t **)(a1 + 72);
              if (v87 == *(uint64_t **)(a1 + 80))
              {
                v88 = *(_QWORD *)(a1 + 88);
                if ((unint64_t)v87 >= v88)
                {
                  v90 = v88 - (_QWORD)v87;
                  v91 = v90 >> 2;
                  if ((unint64_t)(v90 >> 2) <= 1)
                    v91 = 1;
                  if ((unint64_t)v90 >= 0x7FFFFFFFFFFFFFF8)
                    v92 = 0x1FFFFFFFFFFFFFFFLL;
                  else
                    v92 = v91;
                  v93 = std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>(a1 + 88, v92);
                  v95 = &v93[v94];
                  *v93 = v120;
                  v89 = v93 + 1;
                  v97 = *(char **)(a1 + 72);
                  v96 = *(char **)(a1 + 80);
                  if (v96 != v97)
                  {
                    do
                    {
                      v98 = *((_QWORD *)v96 - 1);
                      v96 -= 8;
                      *--v93 = v98;
                    }
                    while (v96 != v97);
                    v96 = *(char **)(a1 + 72);
                  }
                  *(_QWORD *)(a1 + 72) = v93;
                  *(_QWORD *)(a1 + 80) = v89;
                  *(_QWORD *)(a1 + 88) = v95;
                  v7 = v70;
                  if (v96)
                    operator delete(v96);
                }
                else
                {
                  *v87 = v120;
                  v89 = v87 + 1;
                  v7 = v70;
                }
                v10 = v69;
                LODWORD(v22) = 0;
                *(_QWORD *)(a1 + 80) = v89;
              }
              else
              {
                std::vector<XMP_Node *>::insert(a1 + 72, *(char **)(a1 + 72), (char *)&v120);
                LODWORD(v22) = 0;
                v7 = v70;
                v10 = v69;
              }
            }
          }
        }
      }
LABEL_173:
      result = v120;
      if (!v9 || !v120)
      {
LABEL_12:
        if (result)
          goto LABEL_176;
        if (v10)
          FollowXPathStep();
        return 0;
      }
      *v9 = (char *)(*(_QWORD *)(a1 + 72) + 8 * (int)v22);
LABEL_176:
      v99 = *(_DWORD *)(result + 8);
      if ((v99 & 0x8000) != 0)
        *(_DWORD *)(result + 8) = *v7 & 0x1E00 | v99;
      if (v9 && result != *(_QWORD *)*v9)
        FollowXPathStep();
      return result;
    case 4:
      LODWORD(v22) = ((*(_QWORD *)(a1 + 80) - *(_QWORD *)(a1 + 72)) >> 3) - 1;
      goto LABEL_120;
    case 5:
      v117 = 0;
      v118 = 0;
      v119 = 0;
      memset(&__p, 0, sizeof(__p));
      SplitNameAndValue(v6, (uint64_t)&v117, &__p);
      if (SHIBYTE(v119) < 0)
      {
        if (v118 != 8)
          goto LABEL_56;
        v18 = v117;
      }
      else
      {
        if (HIBYTE(v119) != 8)
          goto LABEL_56;
        v18 = &v117;
      }
      if (*v18 == 0x676E616C3A6C6D78)
      {
        NormalizeLangValue((unsigned __int8 *)&__p);
        LODWORD(v22) = LookupLangItem(a1, (unsigned __int8 **)&__p);
        goto LABEL_107;
      }
LABEL_56:
      v110 = *(_QWORD *)(a1 + 72);
      v35 = *(_QWORD *)(a1 + 80) - v110;
      if (!v35)
      {
        LODWORD(v22) = -1;
        goto LABEL_107;
      }
      v109 = v13;
      v112 = v14;
      v104 = v10;
      v105 = v9;
      v22 = 0;
      if (v119 >= 0)
        v36 = HIBYTE(v119);
      else
        v36 = v118;
      v37 = (unsigned __int8 *)&v117;
      if (v119 < 0)
        v37 = (unsigned __int8 *)v117;
      __s2a = v37;
      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        size = __p.__r_.__value_.__l.__size_;
      v113 = size;
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      v106 = v35 >> 3;
      v107 = p_p;
      while (1)
      {
        v40 = *(_QWORD **)(v110 + 8 * v22);
        if (v40[8] != a1)
        {
          v100 = 357;
          v101 = "currItem->parent == arrayNode";
LABEL_184:
          __assert_rtn("LookupQualSelector", "XMPCore_Impl.cpp", v100, v101);
        }
        v41 = v40[12];
        v42 = v40[13] - v41;
        if (v42)
          break;
LABEL_94:
        if (++v22 == v106)
        {
          LODWORD(v22) = -1;
LABEL_96:
          v7 = (_DWORD *)(v6 + 24);
          v9 = v105;
          v10 = v104;
          v14 = v112;
          v13 = v109;
LABEL_107:
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
            operator delete(__p.__r_.__value_.__l.__data_);
          if (SHIBYTE(v119) < 0)
LABEL_110:
            operator delete(v117);
LABEL_120:
          if ((v22 & 0x80000000) != 0)
            goto LABEL_123;
          v65 = *(_QWORD *)(a1 + 72);
          if ((int)v22 <= (int)((unint64_t)(*(_QWORD *)(a1 + 80) - v65) >> 3))
            v120 = *(_QWORD *)(v65 + 8 * v22);
          goto LABEL_173;
        }
      }
      v43 = 0;
      v44 = v42 >> 3;
      while (1)
      {
        v45 = *(_QWORD *)(v41 + 8 * v43);
        if (*(_QWORD **)(v45 + 64) != v40)
        {
          v100 = 362;
          v101 = "currQual->parent == currItem";
          goto LABEL_184;
        }
        v46 = *(unsigned __int8 *)(v45 + 39);
        if ((v46 & 0x80u) == 0)
          v47 = *(unsigned __int8 *)(v45 + 39);
        else
          v47 = *(_QWORD *)(v45 + 24);
        if (v47 == v36)
        {
          v48 = (const void **)(v45 + 16);
          if ((v46 & 0x80) != 0)
          {
            if (!memcmp(*v48, __s2a, *(_QWORD *)(v45 + 24)))
            {
LABEL_82:
              v50 = *(unsigned __int8 *)(v45 + 63);
              if ((v50 & 0x80u) == 0)
                v51 = *(unsigned __int8 *)(v45 + 63);
              else
                v51 = *(_QWORD *)(v45 + 48);
              if (v51 == v113)
              {
                v52 = (const void **)(v45 + 40);
                if ((v50 & 0x80) != 0)
                {
                  if (!memcmp(*v52, v107, *(_QWORD *)(v45 + 48)))
                    goto LABEL_96;
                }
                else
                {
                  if (!*(_BYTE *)(v45 + 63))
                    goto LABEL_96;
                  v53 = v107;
                  while (*(unsigned __int8 *)v52 == v53->__r_.__value_.__s.__data_[0])
                  {
                    v52 = (const void **)((char *)v52 + 1);
                    v53 = (std::string *)((char *)v53 + 1);
                    if (!--v50)
                      goto LABEL_96;
                  }
                }
              }
            }
          }
          else
          {
            if (!*(_BYTE *)(v45 + 39))
              goto LABEL_82;
            v49 = __s2a;
            while (*(unsigned __int8 *)v48 == *v49)
            {
              v48 = (const void **)((char *)v48 + 1);
              ++v49;
              if (!--v46)
                goto LABEL_82;
            }
          }
        }
        if (++v43 == v44)
          goto LABEL_94;
      }
    case 6:
      v117 = 0;
      v118 = 0;
      v119 = 0;
      memset(&__p, 0, sizeof(__p));
      SplitNameAndValue(v6, (uint64_t)&v117, &__p);
      if (v119 >= 0)
        v20 = (const char *)&v117;
      else
        v20 = (const char *)v117;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v21 = &__p;
      else
        v21 = (std::string *)__p.__r_.__value_.__r.__words[0];
      LODWORD(v22) = LookupFieldSelector((const XMP_Node *)a1, v20, (const char *)v21);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      v10 = a4;
      if (SHIBYTE(v119) < 0)
        goto LABEL_110;
      goto LABEL_120;
    default:
      exception = __cxa_allocate_exception(0x18uLL);
      *(_DWORD *)exception = 9;
      v103 = "Unknown array indexing step in FollowXPathStep";
      goto LABEL_193;
  }
}

void sub_187E91F24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  uint64_t v31;

  MEMORY[0x18D761C30](v31, 0x10B3C407D34617ELL);
  _Unwind_Resume(a1);
}

uint64_t FindChildNode(uint64_t a1, char *__s, int a3, uint64_t **a4)
{
  int v8;
  char **v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t i;
  uint64_t v13;
  _QWORD *v14;
  size_t v15;
  unint64_t v16;
  uint64_t *v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t *v24;
  char *v25;
  char *v26;
  char *v27;
  uint64_t v28;
  _QWORD *exception;
  const char *v31;

  v8 = *(_DWORD *)(a1 + 8);
  if ((v8 & 0x80000100) == 0)
  {
    if ((v8 & 0x8000) != 0)
    {
      if ((v8 & 0x200) != 0)
      {
        exception = __cxa_allocate_exception(0x18uLL);
        *(_DWORD *)exception = 102;
        v31 = "Named children not allowed for arrays";
      }
      else
      {
        if ((a3 & 1) != 0)
        {
          *(_DWORD *)(a1 + 8) = v8 | 0x100;
          goto LABEL_6;
        }
        exception = __cxa_allocate_exception(0x18uLL);
        *(_DWORD *)exception = 9;
        v31 = "Parent is new implicit node, but createNodes is false";
      }
    }
    else
    {
      exception = __cxa_allocate_exception(0x18uLL);
      *(_DWORD *)exception = 102;
      v31 = "Named children only allowed for schemas and structs";
    }
    exception[1] = v31;
    *((_BYTE *)exception + 16) = 0;
  }
LABEL_6:
  v10 = *(uint64_t **)(a1 + 72);
  v9 = (char **)(a1 + 72);
  v11 = *(_QWORD *)(a1 + 80) - (_QWORD)v10;
  if (v11)
  {
    for (i = v11 >> 3; i; --i)
    {
      v13 = *v10;
      if (*(_QWORD *)(*v10 + 64) != a1)
        FindChildNode();
      v14 = (_QWORD *)(v13 + 16);
      v15 = strlen(__s);
      if (*(char *)(v13 + 39) < 0)
      {
        if (v15 != *(_QWORD *)(v13 + 24))
          goto LABEL_17;
        if (v15 == -1)
LABEL_44:
          std::string::__throw_out_of_range[abi:ne180100]();
        v14 = (_QWORD *)*v14;
      }
      else
      {
        if (v15 != *(unsigned __int8 *)(v13 + 39))
          goto LABEL_17;
        if (v15 == -1)
          goto LABEL_44;
      }
      if (!memcmp(v14, __s, v15))
      {
        if (!a4)
          return v13;
LABEL_40:
        *a4 = v10;
        if (v13 != *v10)
          FindChildNode();
        return v13;
      }
LABEL_17:
      ++v10;
    }
  }
  if (!a3)
    return 0;
  v13 = operator new();
  XMP_Node::XMP_Node((XMP_Node *)v13, (XMP_Node *)a1, __s, 0x8000);
  v16 = *(_QWORD *)(a1 + 88);
  v17 = *(uint64_t **)(a1 + 80);
  if ((unint64_t)v17 >= v16)
  {
    v19 = ((char *)v17 - *v9) >> 3;
    if ((unint64_t)(v19 + 1) >> 61)
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    v20 = v16 - (_QWORD)*v9;
    v21 = v20 >> 2;
    if (v20 >> 2 <= (unint64_t)(v19 + 1))
      v21 = v19 + 1;
    if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8)
      v22 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v22 = v21;
    if (v22)
      v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>(a1 + 88, v22);
    else
      v23 = 0;
    v24 = (uint64_t *)&v23[8 * v19];
    v25 = &v23[8 * v22];
    *v24 = v13;
    v18 = v24 + 1;
    v27 = *(char **)(a1 + 72);
    v26 = *(char **)(a1 + 80);
    if (v26 != v27)
    {
      do
      {
        v28 = *((_QWORD *)v26 - 1);
        v26 -= 8;
        *--v24 = v28;
      }
      while (v26 != v27);
      v26 = *v9;
    }
    *(_QWORD *)(a1 + 72) = v24;
    *(_QWORD *)(a1 + 80) = v18;
    *(_QWORD *)(a1 + 88) = v25;
    if (v26)
      operator delete(v26);
  }
  else
  {
    *v17 = v13;
    v18 = v17 + 1;
  }
  *(_QWORD *)(a1 + 80) = v18;
  if (a4)
  {
    v10 = v18 - 1;
    goto LABEL_40;
  }
  return v13;
}

void sub_187E9220C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10B3C407D34617ELL);
  _Unwind_Resume(a1);
}

void XMP_Node::XMP_Node(XMP_Node *this, XMP_Node *a2, char *__s, char *a4, int a5)
{
  const std::string *v8;
  int v9;
  const std::string *v10;

  *((_DWORD *)this + 2) = a5;
  *(_QWORD *)this = &off_1E1BB2CB8;
  v8 = (const std::string *)((char *)this + 16);
  std::string::basic_string[abi:ne180100]<0>((_QWORD *)this + 2, __s);
  std::string::basic_string[abi:ne180100]<0>((_QWORD *)this + 5, a4);
  *(_OWORD *)((char *)this + 72) = 0u;
  *((_QWORD *)this + 8) = a2;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  if (std::string::find(v8, 58, 0) != -1)
    return;
  v9 = *((char *)this + 39);
  if (v9 < 0)
  {
    if (*((_QWORD *)this + 3) != 2)
      goto LABEL_8;
    v10 = (const std::string *)v8->__r_.__value_.__r.__words[0];
LABEL_7:
    if (LOWORD(v10->__r_.__value_.__l.__data_) == 23899)
      return;
    goto LABEL_8;
  }
  v10 = v8;
  if (v9 == 2)
    goto LABEL_7;
LABEL_8:
  if ((*((_DWORD *)this + 2) & 0x80000000) == 0)
  {
    if (*((_QWORD *)this + 8))
      __assert_rtn("XMP_Node", "XMPCore_Impl.hpp", 348, "(name.find(':') != XMP_VarString::npos) || (name == \"[]\") || (options & ((XMP_OptionBits)0x80000000UL)) || (parent == 0)");
  }
}

void sub_187E92334(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 39) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

void XMP_Node::XMP_Node(XMP_Node *this, XMP_Node *a2, char *__s, int a4)
{
  _WORD **v6;
  const std::string *v7;
  int v8;
  _WORD *v9;

  *(_QWORD *)this = &off_1E1BB2CB8;
  *((_DWORD *)this + 2) = a4;
  v6 = (_WORD **)((char *)this + 16);
  v7 = (const std::string *)std::string::basic_string[abi:ne180100]<0>((_QWORD *)this + 2, __s);
  *(_OWORD *)((char *)this + 72) = 0u;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = a2;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  if (std::string::find(v7, 58, 0) != -1)
    return;
  v8 = *((char *)this + 39);
  if (v8 < 0)
  {
    if (*((_QWORD *)this + 3) != 2)
      goto LABEL_8;
    v9 = *v6;
LABEL_7:
    if (*v9 == 23899)
      return;
    goto LABEL_8;
  }
  v9 = v6;
  if (v8 == 2)
    goto LABEL_7;
LABEL_8:
  if ((*((_DWORD *)this + 2) & 0x80000000) == 0)
  {
    if (*((_QWORD *)this + 8))
      __assert_rtn("XMP_Node", "XMPCore_Impl.hpp", 326, "(name.find(':') != XMP_VarString::npos) || (name == \"[]\") || (options & ((XMP_OptionBits)0x80000000UL)) || (parent == 0)");
  }
}

void sub_187E9247C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void **v4;
  void *v6;
  void *v7;

  v6 = *(void **)(v1 + 96);
  if (v6)
  {
    *(_QWORD *)(v1 + 104) = v6;
    operator delete(v6);
  }
  v7 = *v4;
  if (*v4)
  {
    *(_QWORD *)(v1 + 80) = v7;
    operator delete(v7);
  }
  if (*(char *)(v1 + 63) < 0)
    operator delete(*v3);
  if (*(char *)(v1 + 39) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

uint64_t GIFReadPlugin::initialize(GIFReadPlugin *this, IIODictionary *a2)
{
  IIODictionary *v3;
  IIODictionary *v4;
  uint64_t v5;
  uint64_t v6;
  __int16 *v7;
  IIOImageRead *v8;
  IIOImageRead *v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  _DWORD *v18;
  char v19;
  char v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t Extension;
  unsigned int v25;
  int v26;
  char v27;
  char v28;
  int v29;
  int v30;
  char v31;
  char v32;
  BOOL v33;
  IIOImageReadSession *v34;
  unint64_t v35;
  UInt8 *v36;
  int v37;
  UInt8 *v38;
  unsigned __int8 *v39;
  uint64_t v40;
  unsigned int v41;
  int v42;
  int v43;
  _BYTE v44[24];
  _BYTE v45[24];
  _BYTE v46[24];
  _BYTE v47[24];
  _BYTE v48[24];
  unsigned __int8 *v49;
  unsigned __int16 v50;
  unsigned __int16 v51;
  unsigned __int16 v52;
  unsigned __int16 v53;
  unsigned __int16 v54;
  unsigned __int16 v55;
  int v56;
  unsigned int v57;
  __int16 v58;
  int v59[3];

  v59[0] = 0;
  v3 = (IIODictionary *)*((_QWORD *)this + 6);
  v4 = (IIODictionary *)*((_QWORD *)this + 7);
  *((_BYTE *)this + 441) = IIODictionary::getBoolForKey(v3, CFSTR("IIO_SKIP_GIF_COMPOSING"));
  IIOSkipMetadata(v3);
  IIOSkipXMP_and_IPTC(v3);
  v5 = *((_QWORD *)this + 3);
  if (!v5)
    goto LABEL_33;
  v6 = _cg_DGifOpen(v5, (int (*)(uint64_t, _DWORD *, uint64_t))gifRead, v59);
  if (!v6)
    goto LABEL_33;
  v7 = (__int16 *)v6;
  v8 = IIOImageReadSession::globalInfoForType(*((IIOImageReadSession **)this + 3), 1195984416);
  if (!v8)
  {
    _cg_jpeg_mem_term("initialize", 319, "globalGifInfo is NULL\n");
LABEL_32:
    _cg_DGifCloseFile((uint64_t)v7, 0);
LABEL_33:
    Extension = 4294967246;
LABEL_34:
    kdebug_trace();
    return Extension;
  }
  v9 = v8;
  v10 = *((_DWORD *)this + 52);
  if (v10 >= GlobalGIFInfo::frameCount(v8))
  {
    GlobalGIFInfo::frameCount(v9);
    _cg_jpeg_mem_term("initialize", 320, "_rpd._index<count (%d<%d)\n");
    goto LABEL_32;
  }
  if (GlobalGIFInfo::frameCount(v9) >= 6)
    *((_BYTE *)this + 442) = 1;
  *((_DWORD *)this + 60) = 2097160;
  *((_DWORD *)this + 81) = 1380401696;
  *((_BYTE *)this + 344) = 0;
  *((_BYTE *)this + 346) = 0;
  *((_DWORD *)this + 57) = *v7;
  *((_DWORD *)this + 58) = v7[1];
  v11 = GlobalGIFInfo::frameCount(v9);
  if (v11 >= 2)
  {
    v16 = *((_DWORD *)this + 57);
    v17 = *((_DWORD *)this + 58);
  }
  else
  {
    GlobalGIFInfo::getFrameInfoAtIndex(v9, 0, (uint64_t)&v49);
    v12 = v50;
    v13 = v51;
    v14 = v52;
    v15 = v53;
    v16 = *((_DWORD *)this + 57);
    if (!v16 && !*((_DWORD *)this + 58) && !v51 && !v50)
    {
      *((_DWORD *)this + 57) = v52;
      *((_DWORD *)this + 58) = v15;
      v16 = v14;
    }
    if (!v13 && !v12 && v16 > v14 && *((_DWORD *)this + 58) > v15
      || v16 > 0x800
      || (v17 = *((_DWORD *)this + 58), v17 >= 0x801))
    {
      *((_DWORD *)this + 57) = v14;
      *((_DWORD *)this + 58) = v15;
      v16 = v14;
      v17 = v15;
    }
  }
  if (4 * v11 * v17 * v16 >= 0x1E8481)
    *((_BYTE *)this + 343) = 0;
  v18 = (_DWORD *)*((_QWORD *)v9 + 22);
  if (v18)
    v19 = *v18 == 2;
  else
    v19 = 0;
  if (v7[1] * (uint64_t)*v7 > (unint64_t)((1100
                                                * (_QWORD)IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3))) << v19))
  {
    if (*((_BYTE *)this + 341))
      LogError("initialize", 397, "malformed GIF file (%d x %d) - [canvasSize: %ld  fileSize: %ld   ratio: %d]  \n");
    goto LABEL_32;
  }
  v20 = v19;
  GlobalGIFInfo::getFrameInfoAtIndex(v9, *((unsigned int *)this + 52), (uint64_t)&v49);
  v21 = v52;
  v22 = v53;
  if (v53 * (unint64_t)v52 > (1100 * (unint64_t)v57) << v20)
  {
    if (*((_BYTE *)this + 341))
      LogError("initialize", 411, "malformed GIF frame#%ld (%d x %d) - [canvasSize: %ld  frameDataSize: %ld   adjustment: %d]\n", *((unsigned int *)this + 52));
    goto LABEL_32;
  }
  v25 = v55;
  v26 = v56;
  v27 = v58;
  if (*((_BYTE *)this + 441))
  {
    v28 = v58;
    v41 = v55;
    v42 = v56;
    v29 = v51;
    v30 = v54;
    IIONumber::IIONumber((IIONumber *)v48, v50);
    IIODictionary::setObjectForKeyGroup(v4, (uint64_t)v48, CFSTR("xOffset"), CFSTR("{GIF}"));
    IIONumber::~IIONumber((IIONumber *)v48);
    IIONumber::IIONumber((IIONumber *)v47, v29);
    IIODictionary::setObjectForKeyGroup(v4, (uint64_t)v47, CFSTR("yOffset"), CFSTR("{GIF}"));
    IIONumber::~IIONumber((IIONumber *)v47);
    IIONumber::IIONumber((IIONumber *)v46, v21);
    IIODictionary::setObjectForKeyGroup(v4, (uint64_t)v46, CFSTR("width"), CFSTR("{GIF}"));
    v27 = v28;
    IIONumber::~IIONumber((IIONumber *)v46);
    IIONumber::IIONumber((IIONumber *)v45, v22);
    IIODictionary::setObjectForKeyGroup(v4, (uint64_t)v45, CFSTR("height"), CFSTR("{GIF}"));
    IIONumber::~IIONumber((IIONumber *)v45);
    IIONumber::IIONumber((IIONumber *)v44, v30);
    IIODictionary::setObjectForKeyGroup(v4, (uint64_t)v44, CFSTR("disposeOp"), CFSTR("{GIF}"));
    IIONumber::~IIONumber((IIONumber *)v44);
    v25 = v41;
    v26 = v42;
  }
  *((_DWORD *)this + 59) = (4 * *((_DWORD *)this + 57) + 15) & 0xFFFFFFF0;
  if ((v27 & 2) != 0)
    v31 = 3;
  else
    v31 = 5;
  *((_BYTE *)this + 246) = v31;
  *((_WORD *)this + 122) = 4;
  if (*((_DWORD *)this + 52) && (v27 & 2) == 0)
  {
    GlobalGIFInfo::getFrameInfoAtIndex(v9, 0, (uint64_t)&v49);
    if ((v58 & 2) != 0)
    {
      v31 = 3;
      *((_BYTE *)this + 246) = 3;
    }
    else
    {
      v31 = *((_BYTE *)this + 246) & 0x1F;
    }
  }
  *((_BYTE *)this + 247) = 0;
  v32 = *((_BYTE *)this + 248);
  v33 = *((_BYTE *)this + 249) != 0;
  *((_BYTE *)this + 278) = v31;
  *((_BYTE *)this + 279) = 0;
  *((_BYTE *)this + 280) = v32 & 0xF;
  *((_BYTE *)this + 281) = v33;
  *((_BYTE *)this + 350) = 1;
  if (IIOImageDestination::resizeImageMaxPixelSize(v9))
  {
    v49 = 0;
    v43 = 0;
    v34 = (IIOImageReadSession *)*((_QWORD *)this + 3);
    v35 = IIOImageDestination::resizeImageMaxPixelSize(v9);
    IIOImageReadSession::seek(v34, v35, 0);
    Extension = _cg_DGifGetExtension((uint64_t)v7, &v43, (uint64_t)&v49);
    if (!(_DWORD)Extension)
    {
      _cg_jpeg_mem_term("initialize", 451, "    GIF-ERROR: DGifGetExtension (%d)\n", 0);
      v36 = 0;
      goto LABEL_63;
    }
    v36 = (UInt8 *)malloc_type_malloc(0, 0x6D8508C1uLL);
    if (!v36)
      goto LABEL_63;
    v37 = 0;
    while (v49)
    {
      if (v36)
      {
        v38 = (UInt8 *)reallocf(v36, *v49 + (uint64_t)v37);
        v36 = v38;
        if (!v38)
        {
          _cg_jpeg_mem_term("initialize", 462, "    GIF-ERROR: realloc(%d) failed\n");
          goto LABEL_63;
        }
        v39 = v49;
        memcpy(&v38[v37], v49 + 1, *v49);
        v37 += *v39;
      }
      Extension = _cg_DGifGetExtensionNext((uint64_t)v7, (uint64_t)&v49);
      if (!(_DWORD)Extension)
      {
        _cg_jpeg_mem_term("initialize", 468, "    GIF-ERROR: DGifGetExtensionNext (%d)\n");
        goto LABEL_63;
      }
    }
    v40 = CGColorSpaceCreateWithCopyOfData(v36 + 11, v37 - 11);
    if (v40)
      goto LABEL_60;
  }
  else
  {
    v36 = 0;
  }
  v40 = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
LABEL_60:
  *((_QWORD *)this + 20) = v40;
  *((_QWORD *)this + 45) = 1;
  *((_DWORD *)this + 109) = v26;
  if ((v27 & 8) != 0)
    IIO_addDelayTimeToDictionary(v25, v4, CFSTR("{GIF}"));
  Extension = 0;
  *((_WORD *)this + 188) = 1;
LABEL_63:
  if (v36)
    free(v36);
  _cg_DGifCloseFile((uint64_t)v7, 0);
  if ((_DWORD)Extension)
    goto LABEL_34;
  return Extension;
}

void sub_187E92B38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t GlobalGIFInfo::frameCount(GlobalGIFInfo *this)
{
  return -858993459 * ((*((_QWORD *)this + 18) - *((_QWORD *)this + 17)) >> 3);
}

void IIO_addDelayTimeToDictionary(unsigned int a1, IIODictionary *a2, const __CFString *a3)
{
  unsigned int v5;
  double v6;
  double v8;
  IIONumber *v9;
  double v10;
  _BYTE v11[24];
  _BYTE v12[24];
  _BYTE v13[24];
  _BYTE v14[24];

  if (a1 >= 2)
    v5 = a1;
  else
    v5 = 10;
  v6 = (double)v5 / 100.0;
  if (a3)
  {
    IIONumber::IIONumber((IIONumber *)v14, v6);
    IIODictionary::setObjectForKeyGroup(a2, (uint64_t)v14, CFSTR("DelayTime"), a3);
    IIONumber::~IIONumber((IIONumber *)v14);
    v8 = (double)a1 / 100.0;
    v9 = (IIONumber *)v12;
    IIONumber::IIONumber((IIONumber *)v12, v8);
    IIODictionary::setObjectForKeyGroup(a2, (uint64_t)v12, CFSTR("UnclampedDelayTime"), a3);
  }
  else
  {
    IIONumber::IIONumber((IIONumber *)v13, v6);
    IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v13, CFSTR("DelayTime"));
    IIONumber::~IIONumber((IIONumber *)v13);
    v10 = (double)a1 / 100.0;
    v9 = (IIONumber *)v11;
    IIONumber::IIONumber((IIONumber *)v11, v10);
    IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v11, CFSTR("UnclampedDelayTime"));
  }
  IIONumber::~IIONumber(v9);
}

void sub_187E92CB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  IIONumber::~IIONumber((IIONumber *)&a9);
  _Unwind_Resume(a1);
}

uint64_t _cg_DGifOpen(uint64_t a1, int (*a2)(uint64_t, _DWORD *, uint64_t), int *a3)
{
  _OWORD *v6;
  uint64_t v7;
  char *v8;
  _BYTE *v9;
  size_t v10;
  int v11;
  int v13;
  _DWORD __ptr[2];

  v6 = malloc_type_malloc(0x70uLL, 0x10A00402F952F05uLL);
  if (v6)
  {
    v7 = (uint64_t)v6;
    v6[5] = 0u;
    v6[6] = 0u;
    v6[3] = 0u;
    v6[4] = 0u;
    v6[1] = 0u;
    v6[2] = 0u;
    *v6 = 0u;
    v8 = (char *)malloc_type_calloc(1uLL, 0x4150uLL, 0x10A0040B4BDD98EuLL);
    if (!v8)
    {
      if (a3)
        *a3 = 109;
      goto LABEL_22;
    }
    v9 = v8;
    *(_DWORD *)((char *)__ptr + 3) = 0;
    __ptr[0] = 0;
    bzero(v8 + 4, 0x414CuLL);
    *(_QWORD *)(v7 + 96) = v9;
    *(_DWORD *)v9 = 8;
    *((_QWORD *)v9 + 6) = a2;
    *(_QWORD *)(v7 + 88) = a1;
    *(_BYTE *)(v7 + 104) = 0;
    if (a2)
      v10 = a2(v7, __ptr, 6);
    else
      v10 = fread(__ptr, 1uLL, 6uLL, 0);
    if (v10 != 6)
    {
      if (a3)
      {
        v13 = 102;
        goto LABEL_20;
      }
LABEL_21:
      free(v9);
LABEL_22:
      free((void *)v7);
      return 0;
    }
    BYTE2(__ptr[1]) = 0;
    if (LOWORD(__ptr[0]) != 18759 || BYTE2(__ptr[0]) != 70)
    {
      if (a3)
      {
        v13 = 103;
LABEL_20:
        *a3 = v13;
        goto LABEL_21;
      }
      goto LABEL_21;
    }
    if (_cg_DGifGetScreenDesc(v7))
    {
      *(_DWORD *)(v7 + 80) = 0;
      v9[16712] = HIBYTE(__ptr[0]) == 57;
      return v7;
    }
    free(v9);
    free((void *)v7);
    if (!a3)
      return 0;
    v7 = 0;
    v11 = 104;
  }
  else
  {
    if (!a3)
      return 0;
    v7 = 0;
    v11 = 109;
  }
  *a3 = v11;
  return v7;
}

uint64_t _cg_DGifCloseFile(uint64_t a1, _DWORD *a2)
{
  void **v4;
  void **v5;
  FILE **v6;

  if (*(_BYTE *)(a1 + 104))
    return 0;
  *(_BYTE *)(a1 + 104) = 1;
  if (!*(_QWORD *)(a1 + 96))
    return 0;
  v4 = *(void ***)(a1 + 48);
  if (v4)
  {
    _cg_GifFreeMapObject(v4);
    *(_QWORD *)(a1 + 48) = 0;
  }
  v5 = *(void ***)(a1 + 16);
  if (v5)
  {
    _cg_GifFreeMapObject(v5);
    *(_QWORD *)(a1 + 16) = 0;
  }
  if (*(_QWORD *)(a1 + 56))
  {
    GifFreeSavedImages(a1);
    *(_DWORD *)(a1 + 24) = 0;
    *(_QWORD *)(a1 + 56) = 0;
  }
  GifFreeExtensionFromGifFile(a1);
  v6 = *(FILE ***)(a1 + 96);
  if ((*(_WORD *)v6 & 8) == 0)
  {
    if (a2)
      *a2 = 111;
LABEL_17:
    free(v6);
    free((void *)a1);
    return 0;
  }
  if (v6[5])
  {
    if (fclose(v6[5]))
    {
      if (a2)
        *a2 = 110;
      v6 = *(FILE ***)(a1 + 96);
      goto LABEL_17;
    }
    v6 = *(FILE ***)(a1 + 96);
  }
  free(v6);
  free((void *)a1);
  if (a2)
    *a2 = 0;
  return 1;
}

uint64_t _cg_DGifGetScreenDesc(uint64_t a1)
{
  uint64_t result;
  int v3;
  uint64_t v4;
  int (*v5)(uint64_t, __int16 *, uint64_t);
  size_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int (*v11)(uint64_t);
  BOOL v12;
  size_t v13;
  __int16 __ptr;
  char v15;

  v15 = 0;
  __ptr = 0;
  if ((**(_WORD **)(a1 + 96) & 8) == 0)
  {
    result = 0;
    v3 = 111;
LABEL_3:
    *(_DWORD *)(a1 + 80) = v3;
    return result;
  }
  result = DGifGetWord(a1, (_WORD *)a1);
  if ((_DWORD)result)
  {
    result = DGifGetWord(a1, (_WORD *)(a1 + 2));
    if ((_DWORD)result)
    {
      v4 = *(_QWORD *)(a1 + 96);
      v5 = *(int (**)(uint64_t, __int16 *, uint64_t))(v4 + 48);
      if (v5)
        v6 = v5(a1, &__ptr, 3);
      else
        v6 = fread(&__ptr, 1uLL, 3uLL, *(FILE **)(v4 + 40));
      if (v6 == 3)
      {
        v7 = (char)__ptr;
        *(_WORD *)(a1 + 4) = (((char)__ptr >> 4) & 7) + 1;
        *(_WORD *)(a1 + 6) = HIBYTE(__ptr);
        *(_BYTE *)(a1 + 8) = v15;
        if ((v7 & 0x80000000) == 0)
        {
          *(_QWORD *)(a1 + 16) = 0;
          return 1;
        }
        result = (uint64_t)_cg_GifMakeMapObject(1 << ((v7 & 7) + 1), 0);
        *(_QWORD *)(a1 + 16) = result;
        if (!result)
        {
          v3 = 109;
          goto LABEL_3;
        }
        *(_BYTE *)(result + 8) = (v7 & 8) != 0;
        v8 = *(int *)result;
        v9 = 3 * v8;
        v10 = *(_QWORD *)(a1 + 96);
        v11 = *(int (**)(uint64_t))(v10 + 48);
        if (!v11)
        {
          v9 = (int)v9;
          v13 = fread(*(void **)(result + 16), 1uLL, (int)v9, *(FILE **)(v10 + 40));
LABEL_24:
          if (v13 != v9)
          {
            _cg_GifFreeMapObject(*(void ***)(a1 + 16));
            result = 0;
            *(_QWORD *)(a1 + 16) = 0;
            v3 = 102;
            goto LABEL_3;
          }
          return 1;
        }
        if (*(_QWORD *)(result + 16))
          v12 = (int)v8 < 1;
        else
          v12 = 0;
        if (!v12)
        {
          v13 = v11(a1);
          goto LABEL_24;
        }
        __break(0x5519u);
      }
      else
      {
        *(_DWORD *)(a1 + 80) = 102;
        _cg_GifFreeMapObject(*(void ***)(a1 + 16));
        result = 0;
        *(_QWORD *)(a1 + 16) = 0;
      }
    }
  }
  return result;
}

char *_cg_DGifGetImageDesc(uint64_t a1)
{
  uint64_t v2;
  char *result;
  int v4;
  __int128 *v5;
  uint64_t v6;
  int (*v7)(uint64_t, __int16 *, uint64_t);
  size_t v8;
  char v9;
  void **v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int (*v14)(uint64_t);
  size_t v15;
  uint64_t v16;
  int v17;
  char *v18;
  int v19;
  char *v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  __int128 v24;
  uint64_t v25;
  int v26;
  char *v27;
  BOOL v28;
  _BOOL4 v29;
  char *v30;
  __int16 __ptr;
  char v32;

  v32 = 0;
  __ptr = 0;
  v2 = *(_QWORD *)(a1 + 96);
  if ((*(_WORD *)v2 & 8) == 0)
  {
    result = 0;
    v4 = 111;
LABEL_3:
    *(_DWORD *)(a1 + 80) = v4;
    return result;
  }
  v5 = (__int128 *)(a1 + 32);
  result = (char *)DGifGetWord(a1, (_WORD *)(a1 + 32));
  if ((_DWORD)result)
  {
    result = (char *)DGifGetWord(a1, (_WORD *)(a1 + 34));
    if ((_DWORD)result)
    {
      result = (char *)DGifGetWord(a1, (_WORD *)(a1 + 36));
      if ((_DWORD)result)
      {
        result = (char *)DGifGetWord(a1, (_WORD *)(a1 + 38));
        if ((_DWORD)result)
        {
          v6 = *(_QWORD *)(a1 + 96);
          v7 = *(int (**)(uint64_t, __int16 *, uint64_t))(v6 + 48);
          if (v7)
            v8 = v7(a1, &__ptr, 1);
          else
            v8 = fread(&__ptr, 1uLL, 1uLL, *(FILE **)(v6 + 40));
          if (v8 == 1)
          {
            v9 = __ptr;
            *(_BYTE *)(a1 + 40) = (__ptr & 0x40) != 0;
            v10 = *(void ***)(a1 + 48);
            if (v10)
            {
              _cg_GifFreeMapObject(v10);
              *(_QWORD *)(a1 + 48) = 0;
              if ((__ptr & 0x80) == 0)
                goto LABEL_25;
            }
            else if ((v9 & 0x80) == 0)
            {
              goto LABEL_25;
            }
            result = _cg_GifMakeMapObject(1 << ((v9 & 7) + 1), 0);
            *(_QWORD *)(a1 + 48) = result;
            if (!result)
              goto LABEL_54;
            v11 = *(_DWORD *)result;
            v12 = (3 * *(_DWORD *)result);
            v13 = *(_QWORD *)(a1 + 96);
            v14 = *(int (**)(uint64_t))(v13 + 48);
            if (v14)
            {
              if (*((_QWORD *)result + 2) && v11 < 1)
                goto LABEL_55;
              v15 = v14(a1);
            }
            else
            {
              v15 = fread(*((void **)result + 2), 1uLL, (3 * v11), *(FILE **)(v13 + 40));
            }
            if (v15 == v12)
            {
LABEL_25:
              result = *(char **)(a1 + 56);
              if (result)
              {
                v16 = *(unsigned int *)(a1 + 24);
                if ((int)v16 < 1)
                  goto LABEL_55;
                result = (char *)reallocarray(result, v16 + 1, 0x38uLL);
                if (!result)
                {
LABEL_54:
                  v4 = 109;
                  goto LABEL_3;
                }
                v17 = *(_DWORD *)(a1 + 24);
                if ((int)v16 < v17 || v17 < -1)
                  goto LABEL_55;
                v18 = result;
                v19 = v17 + 1;
                *(_DWORD *)(a1 + 24) = v19;
                *(_QWORD *)(a1 + 56) = result;
              }
              else
              {
                result = (char *)malloc_type_malloc(0x38uLL, 0x10300409283B079uLL);
                v20 = result + 56;
                if (!result)
                  v20 = 0;
                if (v20 - result < 1)
                  goto LABEL_55;
                v18 = result;
                *(_QWORD *)(a1 + 56) = result;
                v19 = 1;
                *(_DWORD *)(a1 + 24) = 1;
                if (!result)
                {
                  result = 0;
                  *(_DWORD *)(a1 + 24) = 0;
                  *(_QWORD *)(a1 + 56) = 0;
                  goto LABEL_54;
                }
              }
              v21 = v19 - 1;
              v22 = (unint64_t)&v18[56 * v19];
              v23 = (unint64_t)&v18[56 * v21];
              if (v23 >= v22 || v23 < (unint64_t)v18)
                goto LABEL_55;
              v24 = *v5;
              *(_QWORD *)(v23 + 16) = *(_QWORD *)(a1 + 48);
              *(_OWORD *)v23 = v24;
              v25 = *(_QWORD *)(a1 + 48);
              if (!v25)
                goto LABEL_49;
              v26 = *(_DWORD *)v25;
              v27 = *(char **)(v25 + 16);
              if (v27 && v26 < 1)
                goto LABEL_55;
              result = _cg_GifMakeMapObject(*(_DWORD *)v25, v27);
              v28 = result && v26 <= 0;
              v29 = !v28;
              if (v23 + 56 > v22 || !v29)
                goto LABEL_55;
              *(_QWORD *)(v23 + 16) = result;
              if (result)
              {
LABEL_49:
                if (v23 + 56 <= v22)
                {
                  v30 = &v18[56 * v21];
                  *((_QWORD *)v30 + 6) = 0;
                  *((_QWORD *)v30 + 3) = 0;
                  *((_QWORD *)v30 + 4) = 0;
                  *((_DWORD *)v30 + 10) = 0;
                  *(_QWORD *)(v2 + 32) = *(__int16 *)(a1 + 38) * (uint64_t)*(__int16 *)(a1 + 36);
                  return (char *)DGifSetupDecompress(a1);
                }
LABEL_55:
                __break(0x5519u);
                return result;
              }
              goto LABEL_54;
            }
            _cg_GifFreeMapObject(*(void ***)(a1 + 48));
            result = 0;
            *(_DWORD *)(a1 + 80) = 102;
          }
          else
          {
            *(_DWORD *)(a1 + 80) = 102;
            _cg_GifFreeMapObject(*(void ***)(a1 + 48));
            result = 0;
          }
          *(_QWORD *)(a1 + 48) = 0;
        }
      }
    }
  }
  return result;
}

uint64_t DGifGetWord(uint64_t a1, _WORD *a2)
{
  uint64_t v4;
  int (*v5)(uint64_t, __int16 *, uint64_t);
  size_t v6;
  uint64_t result;
  __int16 __ptr;

  __ptr = 0;
  v4 = *(_QWORD *)(a1 + 96);
  v5 = *(int (**)(uint64_t, __int16 *, uint64_t))(v4 + 48);
  if (v5)
    v6 = v5(a1, &__ptr, 2);
  else
    v6 = fread(&__ptr, 1uLL, 2uLL, *(FILE **)(v4 + 40));
  if (v6 == 2)
  {
    *a2 = __ptr;
    return 1;
  }
  else
  {
    result = 0;
    *(_DWORD *)(a1 + 80) = 102;
  }
  return result;
}

char *_cg_GifMakeMapObject(int a1, char *a2)
{
  unsigned int v4;
  int v5;
  _QWORD *v6;
  char *result;
  size_t v8;
  char *v9;
  unsigned int v10;

  v4 = 1;
  do
  {
    v5 = 1 << v4;
    if (v4 > 8)
      break;
    ++v4;
  }
  while (v5 < a1);
  if (v5 != a1)
    return 0;
  v6 = malloc_type_malloc(0x18uLL, 0x1020040D090CC53uLL);
  if (!v6)
    return (char *)v6;
  result = (char *)malloc_type_calloc(a1, 3uLL, 0x100004033FC2DF1uLL);
  v8 = 3 * a1;
  v9 = &result[v8];
  if (!result)
    v9 = 0;
  if (result <= v9 && (a1 & 0x80000000) == 0 && (uint64_t)(0xAAAAAAAAAAAAAAABLL * (v9 - result)) >= a1)
  {
    v6[2] = result;
    *(_DWORD *)v6 = a1;
    if (result)
    {
      v10 = 0;
      do
        ++v10;
      while (v10 <= 8 && 1 << v10 < a1);
      *((_DWORD *)v6 + 1) = v10;
      *((_BYTE *)v6 + 8) = 0;
      if (!a2)
        return (char *)v6;
      if (&a2[v8] >= a2)
      {
        memcpy(result, a2, v8);
        return (char *)v6;
      }
      goto LABEL_21;
    }
    free(v6);
    return 0;
  }
LABEL_21:
  __break(0x5519u);
  return result;
}

uint64_t DGifSetupDecompress(uint64_t a1)
{
  uint64_t v2;
  unsigned int (*v3)(uint64_t, unsigned __int8 *, uint64_t);
  __int16 v4;
  uint64_t v5;
  __int16 v6;
  unsigned __int8 __ptr;

  __ptr = 0;
  v2 = *(_QWORD *)(a1 + 96);
  v3 = *(unsigned int (**)(uint64_t, unsigned __int8 *, uint64_t))(v2 + 48);
  if (v3)
  {
    if (v3(a1, &__ptr, 1))
      goto LABEL_3;
    return 0;
  }
  if (!fread(&__ptr, 1uLL, 1uLL, *(FILE **)(v2 + 40)))
    return 0;
LABEL_3:
  v4 = __ptr;
  if (__ptr < 9u)
  {
    *(_BYTE *)(v2 + 64) = 0;
    *(_WORD *)(v2 + 4) = v4;
    v5 = 1;
    *(_WORD *)(v2 + 6) = 1 << v4;
    *(_WORD *)(v2 + 8) = (1 << v4) + 1;
    *(_WORD *)(v2 + 10) = (1 << v4) + 2;
    v6 = v4 + 1;
    *(_WORD *)(v2 + 12) = v6;
    *(_WORD *)(v2 + 14) = 1 << v6;
    *(_DWORD *)(v2 + 20) = 0;
    *(_WORD *)(v2 + 16) = 4112;
    *(_QWORD *)(v2 + 24) = 0;
    memset((void *)(v2 + 8512), 16, 0x2000uLL);
  }
  else
  {
    v5 = 0;
    *(_DWORD *)(a1 + 80) = 102;
  }
  return v5;
}

void *reallocarray(void *a1, unint64_t a2, unint64_t a3)
{
  int *v3;
  void *result;
  uint64_t v5;

  if (a2 && (a3 | a2) >> 32 && !is_mul_ok(a2, a3))
  {
    v3 = __error();
    result = 0;
    *v3 = 12;
  }
  else
  {
    v5 = a3 * a2;
    result = malloc_type_realloc(a1, a3 * a2, 0x198D5A97uLL);
    if (v5 <= 0 && result != 0)
      __break(0x5519u);
  }
  return result;
}

void _cg_GifFreeMapObject(void **a1)
{
  if (a1)
  {
    free(a1[2]);
    free(a1);
  }
}

void GifFreeExtensionFromGifFile(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *(void **)(a1 + 72);
  if (v2)
  {
    if (*(int *)(a1 + 64) >= 1)
    {
      v3 = 0;
      v4 = 8;
      do
      {
        free(*(void **)(*(_QWORD *)(a1 + 72) + v4));
        ++v3;
        v4 += 24;
      }
      while (v3 < *(int *)(a1 + 64));
      v2 = *(void **)(a1 + 72);
    }
    free(v2);
    *(_DWORD *)(a1 + 64) = 0;
    *(_QWORD *)(a1 + 72) = 0;
  }
}

void GifFreeSavedImages(uint64_t a1)
{
  void *v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  void **v6;
  void *v7;

  if (a1)
  {
    v2 = *(void **)(a1 + 56);
    if (v2)
    {
      v3 = (unint64_t)v2 + 56 * *(int *)(a1 + 24);
      if ((unint64_t)v2 >= v3)
      {
LABEL_14:
        free(v2);
        *(_DWORD *)(a1 + 24) = 0;
        *(_QWORD *)(a1 + 56) = 0;
      }
      else
      {
        v4 = *(_QWORD *)(a1 + 56);
        while ((unint64_t)v2 <= v4)
        {
          v5 = v4 + 56;
          if (v4 + 56 > v3)
            break;
          v6 = *(void ***)(v4 + 16);
          if (v6)
          {
            free(v6[2]);
            free(v6);
            *(_QWORD *)(v4 + 16) = 0;
          }
          v7 = *(void **)(v4 + 32);
          if (v7)
            free(v7);
          if (v4 >= v3)
            break;
          GifFreeExtensionFromSavedImage(v4);
          v4 += 56;
          if (v5 >= *(_QWORD *)(a1 + 56) + 56 * *(int *)(a1 + 24))
          {
            v2 = *(void **)(a1 + 56);
            goto LABEL_14;
          }
        }
        __break(0x5519u);
      }
    }
  }
}

void GifFreeExtensionFromSavedImage(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *(void **)(a1 + 48);
  if (v2)
  {
    if (*(int *)(a1 + 40) >= 1)
    {
      v3 = 0;
      v4 = 8;
      do
      {
        free(*(void **)(*(_QWORD *)(a1 + 48) + v4));
        ++v3;
        v4 += 24;
      }
      while (v3 < *(int *)(a1 + 40));
      v2 = *(void **)(a1 + 48);
    }
    free(v2);
    *(_DWORD *)(a1 + 40) = 0;
    *(_QWORD *)(a1 + 48) = 0;
  }
}

uint64_t IIOImageDestination::resizeImageMaxPixelSize(IIOImageDestination *this)
{
  return *((_QWORD *)this + 23);
}

CGImage *CGImageCopySourceData(CGImage *a1)
{
  const __CFData *Property;
  IIOImageRead *Source;
  const __CFData *v4;
  size_t Width;
  size_t Height;
  UInt8 buffer[8];
  CFRange v9;

  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageCopySourceData", 0, 0, -1, 0);
  kdebug_trace();
  if (!a1)
    goto LABEL_11;
  Property = (const __CFData *)CGImageGetProperty();
  *(_QWORD *)buffer = 0;
  if (Property)
  {
    v9.location = 0;
    v9.length = 8;
    CFDataGetBytes(Property, v9, buffer);
    if (!*(_QWORD *)buffer)
      return 0;
    Source = (IIOImageRead *)CGImageSourceGetSource(*(uint64_t *)buffer);
    if (Source)
    {
      v4 = IIOImageRead::copyData(Source);
      a1 = v4;
      if (v4)
        CFDataGetLength(v4);
      goto LABEL_11;
    }
  }
  else
  {
    Width = CGImageGetWidth(a1);
    Height = CGImageGetHeight(a1);
    _cg_jpeg_mem_term("CGImageCopySourceData", 2793, "*** ERROR: cannot get CGImageReadRef from image (%ldx%ld)\n", Width, Height);
  }
  a1 = 0;
LABEL_11:
  kdebug_trace();
  return a1;
}

const __CFData *IIOImageRead::copyData(IIOImageRead *this)
{
  int v2;
  const void *v3;
  CFDataRef v4;
  size_t v6;
  UInt8 *v7;
  CFIndex BytesAtOffset;
  const __CFAllocator *v9;
  const __CFAllocator *v10;
  CGDataProvider *v11;
  CFAllocatorContext v12;
  int v13;

  v13 = 0;
  v2 = *((unsigned __int8 *)this + 67);
  v3 = (const void *)*((_QWORD *)this + 4);
  if (v2)
  {
    if (!v3)
      return IIOImageRead::createDataWithMappedFile(this, 0, &v13);
    return (const __CFData *)CFRetain(v3);
  }
  if (v3)
    return (const __CFData *)CFRetain(v3);
  if (*((_DWORD *)this + 6) != -1)
  {
    v6 = *((_QWORD *)this + 10);
    if (v6)
    {
      v7 = (UInt8 *)malloc_type_malloc(v6, 0xFC25250EuLL);
      BytesAtOffset = IIOImageRead::getBytesAtOffset(this, v7, 0, *((_QWORD *)this + 10));
      *(_OWORD *)&v12.reallocate = unk_1E1BC99D8;
      v12.preferredSize = 0;
      memset(&v12, 0, 48);
      v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v10 = CFAllocatorCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], &v12);
      v4 = CFDataCreateWithBytesNoCopy(v9, v7, BytesAtOffset, v10);
      CFRelease(v10);
      return v4;
    }
    return 0;
  }
  v11 = (CGDataProvider *)*((_QWORD *)this + 5);
  if (!v11)
    return 0;
  return CGDataProviderCopyData(v11);
}

void HEIFReadPlugin::updateHardwareDecodeOptions(IIODictionary **this, IIODictionary *a2, const __CFDictionary **a3)
{
  int v6;
  int v7;
  int v8;
  IIONumber *v9;
  int v10;
  int v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  _BYTE v24[24];
  _BYTE v25[24];
  _BYTE v26[24];
  _BYTE v27[24];

  v6 = IIO_HardwareDecoderDefaultValue();
  if (HEIFReadPlugin::getEnableRestrictedDecodingFlag(this, (IIODictionary *)a3))
  {
    if (!gFunc_VTAreVideoDecodersRunningInProcess())
      LogError("updateHardwareDecodeOptions", 1279, "*** ERROR: kCGImageSourceEnableRestrictedDecoding was requested, but VTRestrictVideoDecoders() was not called.\n");
    IIODictionary::setObjectForKey(a2, (const void *)*MEMORY[0x1E0C9AE50], *(const __CFString **)gIIO_kCMPhotoDecompressionOption_RestrictedDecoding);
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      ImageIOLog("***************************************************************\n");
      if ((gIIODebugFlags & 0x30000) != 0)
      {
        ImageIOLog("*** kCMPhotoDecompressionOption_RestrictedDecoding enabled ***\n");
        if ((gIIODebugFlags & 0x30000) != 0)
          ImageIOLog("***************************************************************\n");
      }
    }
    goto LABEL_27;
  }
  if (!v6)
    goto LABEL_22;
  if (v6 == 255)
  {
    if (IIODictionary::containsKey((IIODictionary *)a3, CFSTR("kCGImageSourceUseHardwareAcceleration")))
    {
      if (!IIODictionary::getBoolForKey((IIODictionary *)a3, CFSTR("kCGImageSourceUseHardwareAcceleration")))
        goto LABEL_22;
      LOBYTE(v6) = 1;
    }
    else
    {
      LOBYTE(v6) = -1;
    }
  }
  v7 = IIOHardwareDecodingEnabledFlag();
  v8 = (char)v6;
  if (!v7)
    v8 = 0;
  switch(v8)
  {
    case 1:
      v10 = *((_DWORD *)this + 51);
      if (v10 == 1096173907 || v10 == 1096173894)
      {
        if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild())
        {
          v11 = *((_DWORD *)this + 51);
          v12 = v11 >> 24;
          v13 = MEMORY[0x1E0C80978];
          if (v11 < 0)
          {
            v14 = __maskrune(v12, 0x40000uLL);
            v11 = *((_DWORD *)this + 51);
          }
          else
          {
            v14 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v12 + 60) & 0x40000;
          }
          if (v14)
            v15 = (v11 >> 24);
          else
            v15 = 46;
          v16 = v11 << 8 >> 24;
          if (v11 << 8 < 0)
          {
            v17 = __maskrune(v16, 0x40000uLL);
            v11 = *((_DWORD *)this + 51);
          }
          else
          {
            v17 = *(_DWORD *)(v13 + 4 * v16 + 60) & 0x40000;
          }
          if (v17)
            v18 = (v11 << 8 >> 24);
          else
            v18 = 46;
          v19 = (__int16)v11 >> 8;
          if (v11 << 16 < 0)
          {
            v20 = __maskrune(v19, 0x40000uLL);
            v11 = *((_DWORD *)this + 51);
          }
          else
          {
            v20 = *(_DWORD *)(v13 + 4 * v19 + 60) & 0x40000;
          }
          if (v20)
            v21 = ((__int16)v11 >> 8);
          else
            v21 = 46;
          if ((v11 << 24) <= 0x7F000000)
            v22 = *(_DWORD *)(v13 + 4 * (char)v11 + 60) & 0x40000;
          else
            v22 = __maskrune((char)v11, 0x40000uLL);
          if (v22)
            v23 = *((char *)this + 204);
          else
            v23 = 46;
          ImageIOLog("••• ❓ UseHardwareAcceleration(%c%c%c%c)  | %s:%d\n", v15, v18, v21, v23, "updateHardwareDecodeOptions", 1316);
        }
        IIONumber::IIONumber((IIONumber *)v26, 0);
        IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v26, *(const void **)gIIO_kCMPhotoDecompressionOption_AccelerationMode);
        v9 = (IIONumber *)v26;
      }
      else
      {
        if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild())
          ImageIOLog("••• ✅ UseHardwareAcceleration  | %s:%d\n", "updateHardwareDecodeOptions", 1320);
        IIONumber::IIONumber((IIONumber *)v25, 2);
        IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v25, *(const void **)gIIO_kCMPhotoDecompressionOption_AccelerationMode);
        v9 = (IIONumber *)v25;
      }
      goto LABEL_26;
    case 0:
LABEL_22:
      if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild())
        ImageIOLog("••• ❌ UseHardwareAcceleration  | %s:%d\n", "updateHardwareDecodeOptions", 1325);
      IIONumber::IIONumber((IIONumber *)v24, 1);
      IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v24, *(const void **)gIIO_kCMPhotoDecompressionOption_AccelerationMode);
      v9 = (IIONumber *)v24;
LABEL_26:
      IIONumber::~IIONumber(v9);
      break;
    case -1:
      IIONumber::IIONumber((IIONumber *)v27, 0);
      IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v27, *(const void **)gIIO_kCMPhotoDecompressionOption_AccelerationMode);
      IIONumber::~IIONumber((IIONumber *)v27);
      if ((gIIODebugFlags & 0x4000000000000) != 0)
      {
        if (IIO_OSAppleInternalBuild())
          ImageIOLog("••• ❓ UseHardwareAcceleration  | %s:%d\n");
      }
      break;
  }
LABEL_27:
  BREAK_ON_RESTRICTED_CHECK(*((const __CFDictionary **)this[6] + 1), a3[1]);
}

void sub_187E93FF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t AppleJPEGReadPlugin::initialize(AppleJPEGReadPlugin *this, IIODictionary *a2)
{
  int v4;
  IIODictionary *v5;
  int v6;
  unsigned int v7;
  char v8;
  unsigned int v9;
  CGColorSpace *ObjectForKey;
  CGColorSpace *v11;
  CFStringRef Name;
  const char *v13;
  uint64_t image_info;
  int v15;
  const char *v16;
  unsigned int v18;
  int v19;
  const char *v20;
  int *v21;
  IIOImagePlus *v22;
  uint64_t v23;
  IIOImageSource *Source;
  AppleJPEGReadPlugin *v25;
  int v26;
  uint64_t v27;
  const char *v28;
  const char *v29;
  BOOL v30;
  const char *v31;
  CGImageMetadata *ExifData;
  CGImageMetadata *XMPData;
  CGMutableImageMetadataRef APP13;
  UInt8 *v35;
  unint64_t v36;
  CGColorSpace *v37;
  const __CFString *v38;
  const void **v39;
  const char *v40;
  const __CFString *v41;
  const __CFString *v42;
  int v43;
  int v44;
  __int16 v45;
  unsigned int v46;
  CGColorSpaceRef v47;
  const __CFDictionary *TopLevelTag;
  const __CFString *v49;
  CFStringRef *v50;
  CFDataRef v51;
  char CanBeIgnoredOnSRGBDevice;
  unint64_t v53;
  signed int v54;
  unint64_t v55;
  uint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  __int16 v60;
  char v61;
  char v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v66;
  unsigned int v67;
  char v68;
  BOOL v69;
  const char *v70;
  unint64_t v71;
  const char *v72;
  int precision;
  unsigned int v74;
  __int16 v75;
  unsigned int v76;
  unsigned int v77;
  unint64_t v78;
  int v79;
  int v80;
  unint64_t v81;
  int v82;
  unint64_t v83;
  int v84;
  unint64_t v85;
  uint64_t v86;
  __int128 v87;
  unsigned int chroma_subsampling;
  _BOOL4 BoolForKey;
  const char *v90;
  int v91;
  int v92;
  unint64_t v93;
  int v94;
  BOOL v96;
  int v97;
  __int16 v98;
  char v99;
  IIOImagePlus *v100;
  const __CFDictionary *theData;
  size_t NumberOfComponents;
  uint64_t v103;
  int v104;
  int v105;
  int v106;
  unsigned int Uint32ForKey;
  const __CFDictionary *v108;
  IIODictionary *v109;
  unsigned int v110;
  uint64_t v111;
  uint64_t v112;
  void *value;
  char v114;
  unsigned int v115;
  unint64_t v116;
  _QWORD v117[4];

  v117[2] = *MEMORY[0x1E0C80C00];
  v108 = (const __CFDictionary *)*((_QWORD *)this + 8);
  v116 = 0;
  v115 = 1380401696;
  v114 = 0;
  v4 = IIO_HardwareDecoderDefaultValue();
  v5 = (IIODictionary *)*((_QWORD *)this + 6);
  v109 = (IIODictionary *)*((_QWORD *)this + 7);
  *((_WORD *)this + 336) = 255;
  if (!a2)
  {
    _cg_jpeg_mem_term("initialize", 1399, "*** ERROR: initialize called with NULL initOptions\n");
LABEL_334:
    image_info = 4294967246;
    goto LABEL_32;
  }
  v105 = v4;
  if (IIODictionary::containsKey(a2, CFSTR("NEW_PLUGIN_dataOffset")))
    *((_QWORD *)this + 57) = IIODictionary::getUint32ForKey(a2, CFSTR("NEW_PLUGIN_dataOffset"));
  if (IIODictionary::containsKey(a2, CFSTR("NEW_PLUGIN_dataSize")))
    *((_QWORD *)this + 58) = IIODictionary::getUint32ForKey(a2, CFSTR("NEW_PLUGIN_dataSize"));
  v6 = IIOSkipMetadata(v5);
  v104 = IIOSkipXMP_and_IPTC(v5);
  if (IIODictionary::containsKey(v5, CFSTR("kCGImageSourceXMPSidecar")))
    theData = IIODictionary::getObjectForKey(v5, CFSTR("kCGImageSourceXMPSidecar"));
  else
    theData = 0;
  v7 = IIODictionary::containsKey(v5, CFSTR("kCGImageSourceDecodeRequest"));
  if (*((unsigned __int8 *)this + 216) < 2u)
    v8 = 1;
  else
    v8 = v6;
  if ((v8 & 1) == 0)
  {
    if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild())
      ImageIOLog("••• Ⓜ️  skipping metadata for thumbnail creation\n");
    v6 = 1;
  }
  Uint32ForKey = IIODictionary::getUint32ForKey(v5, CFSTR("kCGImageSourceSubsampleFactor"));
  v110 = IIODictionary::containsKey(v5, CFSTR("kCGImageSourceColorTransform"));
  if (v110)
  {
    v9 = IIODictionary::getUint32ForKey(v5, CFSTR("kCGImageSourceColorTransform"));
    v103 = v9;
    if ((gIIODebugFlags & 0x8000300000) != 0)
      ImageIOLog("COL      pdfColorTransform: %d\n", v9);
  }
  else
  {
    v103 = -1;
  }
  if (IIODictionary::containsKey(v5, CFSTR("kCGImageSourceColorTransformSpace"))
    && (ObjectForKey = IIODictionary::getObjectForKey(v5, CFSTR("kCGImageSourceColorTransformSpace"))) != 0)
  {
    v11 = ObjectForKey;
    NumberOfComponents = CGColorSpaceGetNumberOfComponents(ObjectForKey);
    if ((gIIODebugFlags & 0x8000300000) != 0)
    {
      Name = CGColorSpaceGetName(v11);
      IIOString::IIOString((IIOString *)&v111, Name);
      v13 = (const char *)IIOString::utf8String((IIOString *)&v111);
      ImageIOLog("COL pdfColorTransformSpace: %s\n", v13);
      IIOString::~IIOString((IIOString *)&v111);
    }
    v106 = 1;
  }
  else
  {
    v106 = 0;
    NumberOfComponents = 0;
  }
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("    %s:%d: Entering\n", "initialize", 1439);
  if (IIODictionary::getBoolForKey(v5, CFSTR("IMAGEIO_USE_LIBJPEG")))
  {
    _cg_jpeg_mem_term("initialize", 1445, "*** IMAGEIO_USE_LIBJPEG --> switching to libJPEG\n");
    IIONumber::IIONumber((IIONumber *)&v111, 1279938631);
    IIODictionary::setObjectForKey(a2, value, CFSTR("NEW_PLUGIN_ostype"));
    IIONumber::~IIONumber((IIONumber *)&v111);
    IIONumber::IIONumber((IIONumber *)&v111, *((_QWORD *)this + 24));
    IIODictionary::setObjectForKey(a2, value, CFSTR("NEW_PLUGIN_dataOffset"));
    IIONumber::~IIONumber((IIONumber *)&v111);
    kdebug_trace();
LABEL_31:
    image_info = 4294967247;
    goto LABEL_32;
  }
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("    %s:%d: Got session\n", "initialize", 1456);
  if (IIOImageReadSession::seek(*((IIOImageReadSession **)this + 3), *((_QWORD *)this + 24), 0) != *((_QWORD *)this + 24))
    goto LABEL_334;
  if (IIODictionary::containsKey(v5, CFSTR("kCGImageSourcePreferredThreadCount")))
  {
    v18 = IIODictionary::getUint32ForKey(v5, CFSTR("kCGImageSourcePreferredThreadCount"));
    v19 = v18;
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("    %s:%d: Got preferred theadCount == %d\n", "initialize", 1464, v18);
  }
  else
  {
    v19 = 1;
  }
  if (IIODictionary::containsKey(v5, CFSTR("kCGImageSourceEnableMosquitoNoiseFiltering")))
    *((_BYTE *)this + 672) = IIODictionary::getBoolForKey(v5, CFSTR("kCGImageSourceEnableMosquitoNoiseFiltering"));
  *((_BYTE *)this + 675) = v19;
  AppleJPEGReadPlugin::appleJPEGDecodeSetup(this);
  if (!*((_QWORD *)this + 63))
  {
    _cg_jpeg_mem_term("initialize", 1476, "*** applejpeg_decode_session is nil");
    goto LABEL_334;
  }
  if ((gIIODebugFlags & 0x30000) != 0)
  {
    ImageIOLog("    %s:%d: Got ajd_session\n", "initialize", 1478);
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      v20 = "";
      if (!*((_BYTE *)this + 341))
        v20 = "not ";
      ImageIOLog("    %s:%d: Session is %sfinal/numThreads=%d\n", "initialize", 1479, v20, v19);
    }
  }
  if (*((_BYTE *)this + 679)
    || (IIOImageReadSession::seek(*((IIOImageReadSession **)this + 3), *((_QWORD *)this + 57), 0),
        v25 = AppleJPEGReadPlugin::appleJPEGDecodeOpen(this),
        image_info = (uint64_t)v25,
        !(_DWORD)v25))
  {
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("    %s:%d: Opened file\n", "initialize", 1513);
    v21 = (int *)((char *)this + 592);
    image_info = applejpeg_decode_get_image_info();
    if ((_DWORD)image_info)
      goto LABEL_32;
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("    %s:%d: Got imageinfo {%d,%d}\n", "initialize", 1518, *((_DWORD *)this + 150), *((_DWORD *)this + 151));
    if (*((_DWORD *)this + 153) == 1
      && ((IIODictionary::getBoolForKey(a2, CFSTR("OriginalPluginWasMPO")) | v7 ^ 1) & 1) == 0)
    {
      v22 = (IIOImagePlus *)*((_QWORD *)this + 2);
      if (v22
        && (v23 = IIOImagePlus::isr(v22), (Source = (IIOImageSource *)CGImageSourceGetSource(v23)) != 0)
        && IIOImageSource::ignoreJPEGAuxImagesRequest(Source) == 1)
      {
        LogError("initialize", 1548, "*** NOTE: dropping 'kCGImageSourceDecodeRequest' since 'kCGImageSourceIgnoreJPEGAuxImages' was requested\n");
      }
      else if (AppleJPEGReadPlugin::containsGainMap(this))
      {
        _cg_jpeg_mem_term("initialize", 1537, "*** kCGImageSourceDecodeRequest --> switching to HEIFPlugin\n");
        IIONumber::IIONumber((IIONumber *)&v111, 1212500291);
        IIODictionary::setObjectForKey(a2, value, CFSTR("NEW_PLUGIN_ostype"));
        IIONumber::~IIONumber((IIONumber *)&v111);
        IIONumber::IIONumber((IIONumber *)&v111, *((_QWORD *)this + 24));
        IIODictionary::setObjectForKey(a2, value, CFSTR("NEW_PLUGIN_dataOffset"));
        IIONumber::~IIONumber((IIONumber *)&v111);
        IIONumber::IIONumber((IIONumber *)&v111, *((_QWORD *)this + 23));
        IIODictionary::setObjectForKey(a2, value, CFSTR("NEW_PLUGIN_dataSize"));
        IIONumber::~IIONumber((IIONumber *)&v111);
        kdebug_trace();
        goto LABEL_31;
      }
    }
    if (v110)
    {
      v111 = 0;
      v112 = 0;
      if (*v21 >= 1)
      {
        v26 = 0;
        while (1)
        {
          applejpeg_decode_get_segment_info();
          if (v111 == 238)
            break;
          if (++v26 >= *v21)
            goto LABEL_90;
        }
        *((_BYTE *)this + 673) = 1;
        if (HIDWORD(v111) == 14)
        {
          *(_QWORD *)((char *)v117 + 6) = 0;
          v117[0] = 0;
          IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v117, v112 + 2, 0xEuLL);
          v30 = *(_DWORD *)((char *)v117 + 2) == 1651467329 && BYTE6(v117[0]) == 101;
          if (v30)
            *((_BYTE *)this + 674) = BYTE5(v117[1]);
        }
      }
LABEL_90:
      if ((gIIODebugFlags & 0x8000300000) != 0)
      {
        if (*((_BYTE *)this + 673))
          v31 = "true";
        else
          v31 = "false";
        ImageIOLog("COL         hasApp14Marker: %s\n", v31);
      }
    }
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("    %s:%d: handling metadata\n", "initialize", 1578);
    if (!*((_QWORD *)this + 24))
    {
      if (!AppleJPEGReadPlugin::readJFIFData((IIOImageReadSession **)this, v109))
      {
LABEL_329:
        image_info = 0;
        goto LABEL_32;
      }
      ExifData = AppleJPEGReadPlugin::readExifData((IIOImageReadSession **)this, v5);
      XMPData = ExifData;
      if (v6 | v104)
      {
        CGImageMetadataMerge((uint64_t)v108, (uint64_t)ExifData, 0);
        if (!XMPData)
          goto LABEL_109;
LABEL_108:
        CFRelease(XMPData);
        goto LABEL_109;
      }
      if (ExifData)
      {
        CGImageMetadataMerge((uint64_t)v108, (uint64_t)ExifData, v5);
        CFRelease(XMPData);
      }
      APP13 = AppleJPEGReadPlugin::readAPP13((IIOImageReadSession **)this);
      if (APP13)
      {
        CGImageMetadataMerge((uint64_t)v108, (uint64_t)APP13, v5);
        CFRelease(APP13);
      }
      XMPData = AppleJPEGReadPlugin::readXMPData((IIOImageReadSession **)this, theData);
      if (XMPData)
      {
        CGImageMetadataMerge((uint64_t)v108, (uint64_t)XMPData, v5);
        goto LABEL_108;
      }
    }
LABEL_109:
    if (*((_DWORD *)this + 152) == 1)
      IIODictionary::setObjectForKeyGroup(v109, (const void *)*MEMORY[0x1E0C9AE50], CFSTR("IsProgressive"), CFSTR("{JFIF}"));
    if (IIODictionary::getBoolForKey(v5, CFSTR("kCGImageSourceAddJPEGQualityInformation")))
      AppleJPEGReadPlugin::readQualityPropertiesFromJPEG((uint64_t)this, *((_QWORD *)this + 63), v109);
    else
      *((_BYTE *)this + 676) = applejpeg_decode_get_chroma_subsampling();
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("    %s:%d: handling colorspace\n", "initialize", 1647);
    v35 = (UInt8 *)AppleJPEGReadPlugin::readICCData((IIOImageReadSession **)this, 0, *((_QWORD *)this + 24), &v116, &v115);
    if (v35 && (v36 = v116) != 0)
    {
      if (IIODictionary::getBoolForKey(v5, CFSTR("kCGImageSourceKeepOriginalProfile"))
        || (pthread_once(&gDisplayCheck, (void (*)(void))displayCheck), gIsWideGamutDisplay)
        || (v51 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v35, v36, (CFAllocatorRef)*MEMORY[0x1E0C9AE20])) == 0|| (CanBeIgnoredOnSRGBDevice = ColorSyncDataCanBeIgnoredOnSRGBDevice(), CFRelease(v51), (CanBeIgnoredOnSRGBDevice & 1) == 0))
      {
        v37 = (CGColorSpace *)CGColorSpaceCreateWithCopyOfData(v35, v36);
      }
      else
      {
        v37 = 0;
      }
      free(v35);
      v38 = (const __CFString *)*((_QWORD *)this + 55);
      if (!v38)
        goto LABEL_128;
      v39 = (const void **)((char *)this + 440);
      if (v37)
      {
        CGColorSpaceRelease(v37);
        v38 = (const __CFString *)*v39;
      }
    }
    else
    {
      v38 = (const __CFString *)*((_QWORD *)this + 55);
      if (!v38)
      {
        v37 = 0;
        goto LABEL_135;
      }
      v39 = (const void **)((char *)this + 440);
    }
    v37 = CGColorSpaceCreateWithName(v38);
    if ((gIIODebugFlags & 0x8000300000) != 0)
    {
      IIOString::IIOString((IIOString *)&v111, *v39);
      v40 = (const char *)IIOString::utf8String((IIOString *)&v111);
      ImageIOLog("COL using namedColorSpace '%s'\n", v40);
      IIOString::~IIOString((IIOString *)&v111);
    }
LABEL_128:
    if (v37)
    {
      v41 = CGColorSpaceGetName(v37);
      v42 = v41;
      if (v41 && (CFStringFind(v41, CFSTR("PQ"), 1uLL).length || CFStringFind(v42, CFSTR("HLG"), 1uLL).length))
      {
        IIONumber::IIONumber((IIONumber *)&v111, 1212500291);
        IIODictionary::setObjectForKey(a2, value, CFSTR("NEW_PLUGIN_ostype"));
        IIONumber::~IIONumber((IIONumber *)&v111);
        IIONumber::IIONumber((IIONumber *)&v111, 0);
        IIODictionary::setObjectForKey(a2, value, CFSTR("NEW_PLUGIN_dataOffset"));
        IIONumber::~IIONumber((IIONumber *)&v111);
        kdebug_trace();
        image_info = 4294967247;
LABEL_172:
        CGColorSpaceRelease(v37);
        goto LABEL_32;
      }
      v43 = 0;
LABEL_136:
      v44 = *((_DWORD *)this + 153);
      if ((v44 - 3) < 3)
      {
        *((_WORD *)this + 122) = 4;
        v115 = 1129142603;
        goto LABEL_143;
      }
      if ((v44 - 1) >= 2)
      {
        if (v44)
          goto LABEL_143;
        v115 = 1196573017;
        v45 = 1;
      }
      else
      {
        v115 = 1380401696;
        v45 = 3;
      }
      *((_WORD *)this + 122) = v45;
LABEL_143:
      if (!v43)
        goto LABEL_164;
      v46 = v115;
      if (v115 == 1380401696)
      {
        v47 = createColorSpaceFromMetadata(v108, v6, &v114);
        v37 = v47;
        if (v114)
          *((_WORD *)this + 164) = 1;
        if (v47)
          goto LABEL_164;
      }
      TopLevelTag = CGImageMetadataGetTopLevelTag(v108, (uint64_t)CFSTR("http://ns.adobe.com/exif/1.0/"), (uint64_t)CFSTR("ColorSpace"));
      if (TopLevelTag)
      {
        v49 = (const __CFString *)CGImageMetadataTagGetValue((uint64_t)TopLevelTag);
        if (v49)
        {
          if (CFStringGetIntValue(v49) == 1)
          {
            v37 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
            if (v37)
              goto LABEL_164;
          }
        }
      }
      switch(v46)
      {
        case 0x52474220u:
          v50 = (CFStringRef *)MEMORY[0x1E0C9DA10];
          break;
        case 0x47524159u:
          v50 = (CFStringRef *)MEMORY[0x1E0C9D978];
          break;
        case 0x434D594Bu:
          v50 = (CFStringRef *)MEMORY[0x1E0C9D968];
          break;
        default:
          v37 = 0;
          goto LABEL_164;
      }
      v37 = CGColorSpaceCreateWithName(*v50);
LABEL_164:
      if ((gIIODebugFlags & 0x30000) != 0)
        ImageIOLog("    %s:%d: handling subsampling\n", "initialize", 1791);
      v53 = *((int *)this + 150);
      v54 = *((_DWORD *)this + 151);
      v55 = v54;
      if (v53 > 0x2710 || v54 >= 0x2711)
      {
        if (!is_mul_ok(v53, v54))
          goto LABEL_171;
        v56 = (int)v53 * (uint64_t)v54;
        v57 = *((_QWORD *)this + 23);
        if ((double)v57 / (double)(unint64_t)v56 < 0.003)
        {
          _cg_jpeg_mem_term("initialize", 1806, "*** pixelCount: %ld   fileSize: %d    ratio: %g\n", (int)v53 * (uint64_t)(int)v55, v57, (double)v57 / (double)(unint64_t)v56);
          goto LABEL_171;
        }
      }
      LOWORD(v58) = Uint32ForKey;
      if (v53 >= v55)
        v59 = v55;
      else
        v59 = *((int *)this + 150);
      if (v59 < Uint32ForKey)
        goto LABEL_177;
      if (Uint32ForKey < 2)
      {
        if (*((unsigned __int8 *)this + 216) >= 2u)
        {
          v63 = *((unsigned int *)this + 53);
          if ((_DWORD)v63)
          {
            if (v53 <= v55)
              v64 = v55;
            else
              v64 = *((int *)this + 150);
            if (v64 < v63)
              v63 = v64;
            *((_DWORD *)this + 53) = v63;
            if (v63 <= (v53 + 7) >> 3 || v63 <= (v55 + 7) >> 3)
            {
              v58 = 8;
            }
            else if (v63 <= (v53 + 3) >> 2 || v63 <= (v55 + 3) >> 2)
            {
              v58 = 4;
            }
            else if (v63 <= (v53 + 1) >> 1 || v63 <= (v55 + 1) >> 1)
            {
              v58 = 2;
            }
            else
            {
              v58 = 1;
            }
            if (v58 > v55 || v58 > v53)
              v66 = 1;
            else
              v66 = v58;
            if (v66 < 2)
            {
LABEL_177:
              LOWORD(v58) = 1;
              goto LABEL_217;
            }
            if ((gIIODebugFlags & 0x30000) != 0
              && (ImageIOLog("    subsampling '%d' for thumnnail creation:\n", v66), (gIIODebugFlags & 0x30000) != 0)
              && (ImageIOLog("    original size: %d x %d\n", v53, v55), (gIIODebugFlags & 0x30000) != 0))
            {
              ImageIOLog("      scaled size: %g x %g\n", (float)((float)v53 / (float)v66), (float)((float)v55 / (float)v66));
              v53 /= v66;
              v55 /= v66;
              if ((gIIODebugFlags & 0x30000) != 0)
                ImageIOLog("       subsampled: %d x %d\n", v53, v55);
            }
            else
            {
              v53 /= v66;
              v55 /= v66;
            }
          }
        }
      }
      else
      {
        v60 = 2;
        if (Uint32ForKey > 3)
          v60 = 4;
        v61 = 1;
        if (Uint32ForKey > 3)
          v61 = 2;
        if (Uint32ForKey <= 7)
          LOWORD(v58) = v60;
        else
          LOWORD(v58) = 8;
        v62 = 3;
        if (Uint32ForKey <= 7)
          v62 = v61;
        v53 >>= v62;
        v55 >>= v62;
      }
LABEL_217:
      if (!v53 || !v55)
      {
LABEL_171:
        image_info = 0;
        if (!v37)
          goto LABEL_32;
        goto LABEL_172;
      }
      *((_WORD *)this + 158) = v58;
      *((_BYTE *)this + 678) = 1;
      v67 = v115;
      if (v115 == 1380401696)
      {
        if (*((_BYTE *)this + 341))
        {
          v68 = 5;
        }
        else
        {
          *((_BYTE *)this + 678) = 0;
          v68 = 3;
        }
      }
      else
      {
        v68 = 0;
      }
      if ((gIIODebugFlags & 0x30000) != 0)
        ImageIOLog("    %s:%d: handling ColorTransform\n", "initialize", 1901);
      v69 = v67 == 1129142603;
      *((_BYTE *)this + 677) = -1;
      if (!v110)
      {
LABEL_255:
        precision = applejpeg_decode_get_precision();
        if (precision == 12)
          v74 = 16;
        else
          v74 = 8;
        *((_WORD *)this + 120) = v74;
        *((_WORD *)this + 136) = v74;
        if (v67 == 1196573017)
          v75 = 1;
        else
          v75 = 4;
        *((_WORD *)this + 122) = v75;
        v76 = v74 << (2 * (v67 != 1196573017));
        *((_WORD *)this + 121) = v76;
        *((_QWORD *)this + 20) = v37;
        *((_DWORD *)this + 81) = v67;
        *((_BYTE *)this + 246) = v68;
        *(_WORD *)((char *)this + 247) = 0;
        *((_BYTE *)this + 249) = 0;
        if (v67 == 1129142603)
        {
          v77 = v74 >> 1;
        }
        else
        {
          if (v67 != 1196573017)
          {
            if (precision == 12)
              v80 = 4;
            else
              v80 = 3;
            v81 = v53 * (unint64_t)(v80 * (v74 >> 3));
            v30 = (v81 & 0xFFFFFFFF00000000) == 0;
            v82 = (v81 + 15) & 0xFFFFFFF0;
            if (!v30)
              v82 = 0;
            *((_DWORD *)this + 59) = v82;
            *((_BYTE *)this + 344) = 0;
            *((_BYTE *)this + 346) = v69;
            if (v67 == 1380401696)
            {
              v83 = v53 * (unint64_t)(v74 >> 1);
              v30 = (v83 & 0xFFFFFFFF00000000) == 0;
              v84 = (v83 + 15) & 0xFFFFFFF0;
              if (!v30)
                v84 = 0;
              *((_DWORD *)this + 59) = v84;
              *((_BYTE *)this + 278) = v68;
              *(_WORD *)((char *)this + 279) = 0;
              *((_BYTE *)this + 281) = 0;
              *((_WORD *)this + 136) = v74;
              *((_WORD *)this + 137) = v76;
              *((_WORD *)this + 138) = v75;
              *((_DWORD *)this + 67) = v84;
              *((_BYTE *)this + 350) = 1;
            }
LABEL_278:
            if (v106)
            {
              image_info = 0;
              v85 = 3;
              if (v67 == 1196573017)
                v85 = 1;
              if (v85 > NumberOfComponents || NumberOfComponents > v85 + 1)
                goto LABEL_32;
            }
            if ((gIIODebugFlags & 0x80000000) == 0)
              *((_BYTE *)this + 348) = 1;
            *((_DWORD *)this + 57) = v53;
            *((_DWORD *)this + 58) = v55;
            *((_QWORD *)this + 45) = 1;
            v86 = *((_QWORD *)this + 75);
            *(_QWORD *)&v87 = (int)v86;
            *((_QWORD *)&v87 + 1) = SHIDWORD(v86);
            *((_OWORD *)this + 30) = v87;
            chroma_subsampling = applejpeg_decode_get_chroma_subsampling();
            if (chroma_subsampling <= 4 && ((0x1Bu >> chroma_subsampling) & 1) != 0)
              *((_DWORD *)this + 84) = dword_18822C32C[chroma_subsampling];
            if (IIODictionary::containsKey(v5, CFSTR("kCGImageSourceUseHardwareAcceleration")))
            {
              BoolForKey = IIODictionary::getBoolForKey(v5, CFSTR("kCGImageSourceUseHardwareAcceleration"));
              if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild())
              {
                v90 = "❌";
                if (BoolForKey)
                  v90 = "✅";
                ImageIOLog("••• %s UseHardwareAcceleration  | %s:%d\n", v90, "initialize", 2100);
              }
            }
            else
            {
              if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild())
                ImageIOLog("••• ❓ UseHardwareAcceleration  | %s:%d\n", "initialize", 2103);
              BoolForKey = 1;
            }
            if (v105)
            {
              if (v105 == 1)
                BoolForKey = 1;
              v91 = 0;
              v92 = *((unsigned __int8 *)this + 677);
              if (v92 != 255 || *((_DWORD *)this + 152) == 1 || !BoolForKey)
                goto LABEL_307;
              v91 = IIOHardwareDecodingEnabledFlag();
            }
            else
            {
              v91 = 0;
            }
            v92 = *((unsigned __int8 *)this + 677);
LABEL_307:
            *((_BYTE *)this + 496) = v91;
            v93 = *((unsigned int *)this + 57)
                * (unint64_t)((*((unsigned __int16 *)this + 120) + 7) >> 3 << (2
                                                                                                  * (*((_WORD *)this + 121) != 8)));
            v30 = (v93 & 0xFFFFFFFF00000000) == 0;
            v94 = (v93 + 15) & 0xFFFFFFF0;
            if (!v30)
              v94 = 0;
            *((_DWORD *)this + 67) = v94;
            v96 = v67 != 1129142603 && *((_BYTE *)this + 341) != 0 && v92 == 255;
            v97 = v96;
            v98 = 1;
            if (v96)
            {
              if (v91)
                v99 = 3;
              else
                v99 = 4;
              *((_BYTE *)this + 449) = v99;
              v98 = 12;
            }
            *((_BYTE *)this + 448) = 1;
            *((_WORD *)this + 188) = v98;
            v100 = (IIOImagePlus *)*((_QWORD *)this + 2);
            if (v100 && IIOImagePlus::sourceImageProvider(v100))
              CGImageProviderSetProperty();
            if ((gIIODebugFlags & 0x30000) != 0)
              ImageIOLog("    %s:%d: useVersion3: %d\n", "initialize", 2179, v97);
            goto LABEL_329;
          }
          v77 = v74 >> 3;
        }
        v78 = v53 * (unint64_t)v77;
        if ((v78 & 0xFFFFFFFF00000000) != 0)
          v79 = 0;
        else
          v79 = (v78 + 15) & 0xFFFFFFF0;
        *((_DWORD *)this + 59) = v79;
        *((_BYTE *)this + 344) = 0;
        *((_BYTE *)this + 346) = v69;
        goto LABEL_278;
      }
      if (v103 == 2)
      {
        if (v67 == 1129142603)
        {
          v69 = *((_BYTE *)this + 673) == 0;
          if ((gIIODebugFlags & 0x8000300000) != 0)
          {
            if (*((_BYTE *)this + 673))
              v70 = "false";
            else
              v70 = "true";
            ImageIOLog("COL           shouldInvert: %s\n", v70);
          }
          goto LABEL_248;
        }
        goto LABEL_247;
      }
      if (v103 == 1)
      {
        if ((gIIODebugFlags & 0x8000300000) != 0)
          ImageIOLog("COL           shouldInvert: true\n");
        goto LABEL_241;
      }
      if (v103)
      {
LABEL_248:
        if ((gIIODebugFlags & 0x8000000000) != 0)
        {
          v71 = *((char *)this + 677);
          v72 = v71 > 2 ? "" : off_1E1BC9BE0[v71];
          ImageIOLog("COL           _aj._force_app14: %s\n", v72);
          if ((gIIODebugFlags & 0x8000300000) != 0)
          {
            ImageIOLog("COL              dimension: %d x %d\n", v53, v55);
            if ((gIIODebugFlags & 0x8000300000) != 0)
              ImageIOLog("COL\n");
          }
        }
        goto LABEL_255;
      }
      if (v67 == 1129142603)
      {
        if ((gIIODebugFlags & 0x8000300000) != 0)
          ImageIOLog("COL           shouldInvert: true (icSigCmykData)\n");
LABEL_241:
        v69 = 1;
        goto LABEL_248;
      }
      if (*((_BYTE *)this + 673))
      {
        if ((gIIODebugFlags & 0x8000300000) != 0)
          goto LABEL_246;
      }
      else
      {
        *((_BYTE *)this + 677) = 0;
        if ((gIIODebugFlags & 0x8000300000) != 0)
LABEL_246:
          ImageIOLog("COL           shouldInvert: %s\n", "false");
      }
LABEL_247:
      v69 = 0;
      goto LABEL_248;
    }
LABEL_135:
    v43 = 1;
    goto LABEL_136;
  }
  if ((_DWORD)v25 == 3)
  {
    if (*((_BYTE *)this + 341))
    {
      _cg_jpeg_mem_term("initialize", 1493, "*** AppleJPEG returned APPLEJPEG_ERR_UNSUPPORTED falling back to libJPEG\n");
      IIONumber::IIONumber((IIONumber *)&v111, 1279938631);
      IIODictionary::setObjectForKey(a2, value, CFSTR("NEW_PLUGIN_ostype"));
      IIONumber::~IIONumber((IIONumber *)&v111);
      IIONumber::IIONumber((IIONumber *)&v111, *((_QWORD *)this + 24));
      IIODictionary::setObjectForKey(a2, value, CFSTR("NEW_PLUGIN_dataOffset"));
      IIONumber::~IIONumber((IIONumber *)&v111);
      kdebug_trace();
      goto LABEL_31;
    }
    _cg_jpeg_mem_term("initialize", 1502, "*** AppleJPEG returned APPLEJPEG_ERR_UNSUPPORTED -- NOT falling back to libJPEG --> _rpd._isFinal==NO\n");
    image_info = 3;
  }
  else
  {
    v27 = gIIODebugFlags & 0x30000;
    v28 = AppleJPEGReadPlugin::appleJPEGErrorString(v25, (int)v25);
    v29 = v28;
    if (v27)
      ImageIOLog("    %s:%d: applejpeg_decode_open_file failed (%d) %s\n", "initialize", 1508, image_info, v28);
    _cg_jpeg_mem_term("initialize", 1509, "applejpeg_decode_open_file failed (%d) '%s'\n", image_info, v29);
  }
LABEL_32:
  v15 = gIIODebugFlags;
  if ((gIIODebugFlags & 0x1000000000) != 0)
  {
    v16 = "YES";
    if (!*((_BYTE *)this + 496))
      v16 = "NO";
    ImageIOLog("H   %s: image size: {%d, %d} rb: %d    subsample: %d    useHW: %s\n", "initialize", *((_DWORD *)this + 57), *((_DWORD *)this + 58), *((_DWORD *)this + 59), *((unsigned __int16 *)this + 158), v16);
    v15 = gIIODebugFlags;
  }
  if ((*(_QWORD *)&v15 & 0x30000) != 0)
    ImageIOLog("    %s:%d: returning err: %d\n", "initialize", 2187, image_info);
  if ((_DWORD)image_info)
    kdebug_trace();
  return image_info;
}

void sub_187E956D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_list va;

  va_start(va, a16);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t PNGReadPlugin::AddOrientationToMetadata(uint64_t a1, uint64_t a2, CGImageMetadata *a3, uint64_t a4, uint64_t a5)
{
  int text_count;
  int v9;
  unsigned int i;
  const char *text_entry;
  const char *v12;
  const char *v13;
  unint64_t v14;
  unint64_t v15;
  int v16;
  uint64_t v17;
  size_t v18;
  char *v19;
  const char *v20;
  int v21;
  size_t v22;
  int v23;
  int v24;
  CGImageMetadataTag *v25;
  CGImageMetadata *v27;
  char *__s1[3];
  _QWORD v29[5];
  _QWORD v30[5];
  char *__endptr;
  uint64_t v32;
  size_t v33;
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  int v37;

  text_count = _cg_png_get_text_count(a4, a5);
  v34 = 0;
  v35 = &v34;
  v36 = 0x2000000000;
  v37 = 0;
  if (text_count < 1)
    goto LABEL_23;
  v9 = text_count;
  v27 = a3;
  for (i = 0; i != v9; ++i)
  {
    __s1[0] = 0;
    v32 = 0;
    v33 = 0;
    text_entry = (const char *)_cg_png_get_text_entry(a4, a5, i, __s1, &v32, &v33);
    v12 = __s1[0];
    if (!strncmp(__s1[0], "Raw profile type exif", 0x15uLL) || !strncmp(v12, "Raw profile type xmp", 0x14uLL))
    {
      __endptr = 0;
      if (*text_entry == 10)
      {
        v13 = text_entry + 1;
        v14 = v32 - 1;
        do
        {
          v15 = v14;
          v16 = *(unsigned __int8 *)v13;
          if (!*v13)
            break;
          ++v13;
          --v14;
        }
        while (v16 != 10);
        v17 = strtol(v13, &__endptr, 10);
        if ((int)v17 <= v15)
        {
          v18 = v17;
          v19 = (char *)PNGReadPlugin::HexString2bin((PNGReadPlugin *)__endptr, (int)v17);
          if (v19)
          {
            v20 = __s1[0];
            if (!strncmp(__s1[0], "Raw profile type exif", 0x15uLL))
            {
              v30[0] = MEMORY[0x1E0C809B0];
              v30[1] = 0x40000000;
              v30[2] = ___ZN13PNGReadPlugin24AddOrientationToMetadataEP13IIODictionaryS1_P15CGImageMetadataP14png_struct_defP12png_info_def_block_invoke;
              v30[3] = &unk_1E1BBCED0;
              v30[4] = &v34;
              EnumerateExifDataUsingBlock(v19, v18, (uint64_t)v30);
            }
            else if (!strncmp(v20, "Raw profile type xmp", 0x14uLL) && !*((_DWORD *)v35 + 6))
            {
              v21 = IIOGetOrientationFromXMPData(v19, v18);
              *((_DWORD *)v35 + 6) = v21;
            }
            free(v19);
          }
        }
      }
    }
    v22 = v33;
    if (v33 && !strncmp(__s1[0], "XML:com.adobe.xmp", 0x11uLL) && !*((_DWORD *)v35 + 6))
    {
      v23 = IIOGetOrientationFromXMPData(text_entry, v22);
      *((_DWORD *)v35 + 6) = v23;
    }
  }
  v24 = *((_DWORD *)v35 + 6);
  a3 = v27;
  if (!v24)
  {
LABEL_23:
    LODWORD(v33) = 0;
    __s1[0] = 0;
    if (_cg_png_get_eXIf_1(a4, a5, &v33, __s1))
    {
      v29[0] = MEMORY[0x1E0C809B0];
      v29[1] = 0x40000000;
      v29[2] = ___ZN13PNGReadPlugin24AddOrientationToMetadataEP13IIODictionaryS1_P15CGImageMetadataP14png_struct_defP12png_info_def_block_invoke_2;
      v29[3] = &unk_1E1BC1F70;
      v29[4] = &v34;
      EnumerateExifDataUsingBlock(__s1[0], v33, (uint64_t)v29);
    }
    v24 = *((_DWORD *)v35 + 6);
  }
  if ((v24 - 1) <= 7)
  {
    IIONumber::IIONumber((IIONumber *)__s1, v24);
    v25 = CGImageMetadataTagCreate(CFSTR("http://ns.adobe.com/tiff/1.0/"), CFSTR("tiff"), CFSTR("Orientation"), kCGImageMetadataTypeDefault, __s1[2]);
    IIONumber::~IIONumber((IIONumber *)__s1);
    if (v25)
    {
      CGImageMetadataSetTagWithPath(a3, 0, CFSTR("tiff:Orientation"), v25);
      CFRelease(v25);
    }
  }
  _Block_object_dispose(&v34, 8);
  return 0;
}

void sub_187E95A64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  IIONumber::~IIONumber((IIONumber *)&a10);
  _Block_object_dispose(&a26, 8);
  _Unwind_Resume(a1);
}

uint64_t PNGReadPlugin::HandlePNGMetadata(IIODictionary *a1, IIODictionary *a2, _QWORD *a3, uint64_t a4, uint64_t a5)
{
  int v10;
  const __CFDictionary *ObjectForKey;
  const __CFData *v12;
  const char *BytePtr;
  CFIndex Length;
  CGImageMetadata *MetadataFromXMPSidecarData;
  int text_count;
  int v17;
  unsigned int v18;
  const char *text_entry;
  char *v20;
  unint64_t v21;
  char *v22;
  PNGReadPlugin *v23;
  IIODictionary *v24;
  UInt8 *v25;
  unsigned int v26;
  const char *v27;
  char *v28;
  char *v29;
  int v30;
  size_t v31;
  char *v32;
  char *v33;
  char *v34;
  int v35;
  char v36;
  CGMutableImageMetadataRef MetadataFromDatabuffer;
  CGMutableImageMetadataRef v38;
  CGImageMetadata *MetadataFromXMPBuffer;
  CGMutableImageMetadataRef v40;
  CGMutableImageMetadataRef v41;
  void *TagWithPath;
  char v43;
  const __CFDictionary *v44;
  void *v45;
  const void *Value;
  const void *TagMatchingImageProperty;
  const void *DefaultString;
  const void *v49;
  const void *v50;
  const void *v51;
  const void *v52;
  uint64_t v53;
  const void *v54;
  const void *v55;
  CFTypeID v56;
  IIODictionary *v57;
  const void *v58;
  CFTypeID v59;
  const void *ValueAtIndex;
  PNGReadPlugin *v62;
  uint64_t v63;
  char v64;
  char *__endptr;
  char *v66;
  unint64_t v67;
  char *__s1;
  unsigned __int8 *v69;
  unsigned int v70;

  v10 = IIOSkipMetadata(a1);
  v64 = IIOSkipXMP_and_IPTC(a1);
  if ((v64 & 1) == 0)
  {
    ObjectForKey = IIODictionary::getObjectForKey(a1, CFSTR("kCGImageSourceXMPSidecar"));
    if (ObjectForKey)
    {
      v12 = ObjectForKey;
      BytePtr = (const char *)CFDataGetBytePtr(ObjectForKey);
      Length = CFDataGetLength(v12);
      MetadataFromXMPSidecarData = CreateMetadataFromXMPSidecarData(BytePtr, Length);
      CGImageMetadataMerge((uint64_t)a3, (uint64_t)MetadataFromXMPSidecarData, 0);
      if (MetadataFromXMPSidecarData)
        CFRelease(MetadataFromXMPSidecarData);
      goto LABEL_48;
    }
  }
  v62 = a2;
  v63 = (uint64_t)a3;
  v70 = 0;
  v69 = 0;
  text_count = _cg_png_get_text_count(a4, a5);
  if (text_count >= 1)
  {
    v17 = text_count;
    v18 = 0;
    while (1)
    {
      v67 = 0;
      __s1 = 0;
      v66 = 0;
      text_entry = (const char *)_cg_png_get_text_entry(a4, a5, v18, &__s1, &v66, &v67);
      v20 = __s1;
      if (!strncmp(__s1, "Raw profile type exif", 0x15uLL)
        || !strncmp(v20, "Raw profile type iptc", 0x15uLL)
        || !strncmp(v20, "Raw profile type xmp", 0x14uLL)
        || !strncmp(v20, "Raw profile type icc", 0x14uLL)
        || !strncmp(v20, "Raw profile type icm", 0x14uLL))
      {
        break;
      }
      v21 = v67;
      if (v67)
      {
        if (!strncmp(v20, "XML:com.adobe.xmp", 0x11uLL))
        {
          if ((v64 & 1) == 0
            && (!IIODictionary::containsKey(a1, CFSTR("kCGImageSourceSkipXMPIfLargerThanSize"))
             || v21 <= IIODictionary::getUint32ForKey(a1, CFSTR("kCGImageSourceSkipXMPIfLargerThanSize"))))
          {
            MetadataFromXMPBuffer = CreateMetadataFromXMPBuffer(text_entry, v21);
            CGImageMetadataMerge(v63, (uint64_t)MetadataFromXMPBuffer, 0);
            if (MetadataFromXMPBuffer)
              CFRelease(MetadataFromXMPBuffer);
          }
          goto LABEL_33;
        }
        v22 = v66;
        v23 = v62;
        v24 = (IIODictionary *)v20;
        v25 = (UInt8 *)text_entry;
        v26 = v21;
        goto LABEL_32;
      }
      v22 = v66;
      if (v66)
      {
        v23 = v62;
        v24 = (IIODictionary *)v20;
        v25 = (UInt8 *)text_entry;
        v26 = 0;
LABEL_32:
        PNGReadPlugin::AddTextChunkToProperties(v23, v24, v25, v22, v26);
      }
LABEL_33:
      if (++v18 == v17)
        goto LABEL_40;
    }
    __endptr = 0;
    if (*text_entry != 10)
      goto LABEL_33;
    v27 = text_entry + 1;
    v28 = v66 - 1;
    do
    {
      v29 = v28;
      v30 = *(unsigned __int8 *)v27;
      if (!*v27)
        break;
      ++v27;
      --v28;
    }
    while (v30 != 10);
    v31 = (int)strtol(v27, &__endptr, 10);
    if (v31 > (unint64_t)v29)
      goto LABEL_33;
    v32 = (char *)PNGReadPlugin::HexString2bin((PNGReadPlugin *)__endptr, v31);
    if (!v32)
      goto LABEL_33;
    v33 = v32;
    v34 = __s1;
    if (!strncmp(__s1, "Raw profile type exif", 0x15uLL))
    {
      MetadataFromDatabuffer = CreateMetadataFromDatabuffer(v33, v31, 0);
    }
    else
    {
      v35 = strncmp(v34, "Raw profile type xmp", 0x14uLL);
      v36 = v64;
      if (v35)
        v36 = 1;
      if ((v36 & 1) != 0)
        goto LABEL_29;
      MetadataFromDatabuffer = CreateMetadataFromXMPBuffer(v33, v31);
    }
    v38 = MetadataFromDatabuffer;
    if (MetadataFromDatabuffer)
    {
      CGImageMetadataMerge(v63, (uint64_t)MetadataFromDatabuffer, a1);
      CFRelease(v38);
    }
LABEL_29:
    free(v33);
    goto LABEL_33;
  }
LABEL_40:
  a3 = (_QWORD *)v63;
  if (_cg_png_get_eXIf_1(a4, a5, &v70, &v69))
  {
    v40 = CreateMetadataFromDatabuffer((const char *)v69, v70, 0);
    if (v40)
    {
      v41 = v40;
      if (v10)
      {
        TagWithPath = CGImageMetadataGetTagWithPath(v40, 0, CFSTR("tiff:Orientation"));
        if (TagWithPath)
          CGImageMetadataAddTag(v63, TagWithPath);
      }
      else
      {
        CGImageMetadataMerge(v63, (uint64_t)v40, a1);
      }
      CFRelease(v41);
    }
  }
  a2 = v62;
LABEL_48:
  if (a3)
    v43 = v10;
  else
    v43 = 1;
  if ((v43 & 1) == 0)
  {
    v44 = (const __CFDictionary *)a3[3];
    if (v44)
    {
      if (CFDictionaryGetCount(v44) >= 1)
      {
        v45 = CGImageMetadataGetTagWithPath(a3, 0, CFSTR("xmp:CreatorTool"));
        if (v45)
        {
          Value = (const void *)CGImageMetadataTagGetValue((uint64_t)v45);
          IIODictionary::setObjectForKeyGroup(a2, Value, CFSTR("Software"), CFSTR("{PNG}"));
        }
        IIODictionary::removeObjectForKey(a2, CFSTR("{TIFF}"));
        TagMatchingImageProperty = (const void *)CGImageMetadataGetTagMatchingImageProperty(a3, CFSTR("{IPTC}"), CFSTR("Caption/Abstract"));
        DefaultString = CGImageMetadataGetDefaultString(TagMatchingImageProperty);
        if (DefaultString)
          IIODictionary::setObjectForKeyGroup(a2, DefaultString, CFSTR("Description"), CFSTR("{PNG}"));
        v49 = (const void *)CGImageMetadataGetTagMatchingImageProperty(a3, CFSTR("{IPTC}"), CFSTR("CopyrightNotice"));
        v50 = CGImageMetadataGetDefaultString(v49);
        if (v50)
          IIODictionary::setObjectForKeyGroup(a2, v50, CFSTR("Copyright"), CFSTR("{PNG}"));
        v51 = (const void *)CGImageMetadataGetTagMatchingImageProperty(a3, CFSTR("{IPTC}"), CFSTR("ObjectName"));
        v52 = CGImageMetadataGetDefaultString(v51);
        if (v52)
          IIODictionary::setObjectForKeyGroup(a2, v52, CFSTR("Title"), CFSTR("{PNG}"));
        v53 = CGImageMetadataGetTagMatchingImageProperty(a3, CFSTR("{IPTC}"), CFSTR("Byline"));
        v54 = (const void *)CGImageMetadataTagGetValue(v53);
        if (v54)
        {
          v55 = v54;
          v56 = CFGetTypeID(v54);
          if (v56 == CFStringGetTypeID())
          {
            v57 = a2;
            v58 = v55;
LABEL_68:
            IIODictionary::setObjectForKeyGroup(v57, v58, CFSTR("Author"), CFSTR("{PNG}"));
            return 0;
          }
          v59 = CFGetTypeID(v55);
          if (v59 == CFArrayGetTypeID() && CFArrayGetCount((CFArrayRef)v55) >= 1)
          {
            ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v55, 0);
            v58 = (const void *)CGImageMetadataTagGetValue((uint64_t)ValueAtIndex);
            v57 = a2;
            goto LABEL_68;
          }
        }
      }
    }
  }
  return 0;
}

uint64_t CGImageMetadataGetTagMatchingImageProperty(const void *a1, const void *a2, const void *a3)
{
  CFTypeID v6;
  CFTypeID v7;
  CFTypeID TypeID;
  CFTypeID v9;
  uint64_t v10;
  _QWORD v12[8];
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;

  v13 = 0;
  v14 = &v13;
  v15 = 0x2000000000;
  v16 = 0;
  if (a1)
  {
    v6 = CFGetTypeID(a1);
    if (CGImageMetadataGetTypeID::once == -1)
    {
      if (!a2)
        goto LABEL_9;
    }
    else
    {
      dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_20);
      if (!a2)
        goto LABEL_9;
    }
    if (v6 == CGImageMetadataGetTypeID::id)
    {
      v7 = CFGetTypeID(a2);
      TypeID = CFStringGetTypeID();
      if (a3)
      {
        if (v7 == TypeID)
        {
          v9 = CFGetTypeID(a3);
          if (v9 == CFStringGetTypeID())
          {
            v12[0] = MEMORY[0x1E0C809B0];
            v12[1] = 0x40000000;
            v12[2] = __CGImageMetadataGetTagMatchingImageProperty_block_invoke;
            v12[3] = &unk_1E1BC4E88;
            v12[4] = &v13;
            v12[5] = a2;
            v12[6] = a3;
            v12[7] = a1;
            XMPMappingIterateUsingBlock((uint64_t)v12);
          }
        }
      }
    }
  }
LABEL_9:
  v10 = v14[3];
  _Block_object_dispose(&v13, 8);
  return v10;
}

void sub_187E96168(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

const __CFDictionary *XMPMappingIterateUsingBlock(uint64_t a1)
{
  return XMPMappingIteratePropertiesUsingBlock(0, a1);
}

uint64_t _cg_png_get_text_count(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = 0;
  if (a1)
  {
    if (a2)
      return *(unsigned int *)(a2 + 148);
  }
  return result;
}

uint64_t _cg_png_get_eXIf_1(uint64_t a1, uint64_t a2, _DWORD *a3, _QWORD *a4)
{
  uint64_t result;

  result = 0;
  if (a1)
  {
    if (a2)
    {
      result = 0;
      if (a4)
      {
        if ((*(_DWORD *)(a2 + 8) & 0x10000) != 0)
        {
          *a3 = *(_DWORD *)(a2 + 236);
          *a4 = *(_QWORD *)(a2 + 240);
          return 0x10000;
        }
      }
    }
  }
  return result;
}

const void *CGImageMetadataGetDefaultString(const void *result)
{
  const void *v1;
  CFTypeID v2;
  CFTypeID v3;
  const void *ValueAtIndex;
  CFTypeID v5;
  CFTypeID v6;

  if (result)
  {
    v1 = result;
    v2 = CFGetTypeID(result);
    if (v2 == CGImageMetadataTagGetTypeID())
    {
      v1 = *(const void **)(CGImageSourceGetSource((uint64_t)v1) + 48);
      if (!v1)
        return 0;
    }
    v3 = CFGetTypeID(v1);
    if (v3 == CFArrayGetTypeID()
      && CFArrayGetCount((CFArrayRef)v1) >= 1
      && (ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v1, 0), (v1 = ValueAtIndex) != 0)
      && (v5 = CFGetTypeID(ValueAtIndex), v5 == CGImageMetadataTagGetTypeID())
      && (v1 = *(const void **)(CGImageSourceGetSource((uint64_t)v1) + 48)) == 0)
    {
      return 0;
    }
    else
    {
      v6 = CFGetTypeID(v1);
      if (v6 == CFStringGetTypeID())
        return v1;
      else
        return 0;
    }
  }
  return result;
}

uint64_t CGImageMetadataTagGetValue(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    v1 = *(_QWORD *)(result + 24);
    if (v1)
      return *(_QWORD *)(v1 + 48);
    else
      return 0;
  }
  return result;
}

CGMutableImageMetadataRef CreateMetadataFromDatabuffer(const char *a1, unint64_t a2, char a3)
{
  unsigned int v3;
  CGMutableImageMetadataRef MetadataFromDatablock;
  int v8;
  unsigned int v9;
  uint64_t v10;
  unsigned __int8 *v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  const void *v15;
  const void *v16;
  _QWORD *v17;
  const void *v18;
  IIOImageReadSession *Source;

  if (!a1)
    return 0;
  v3 = a2;
  if (a2 <= 0xD)
  {
    _cg_jpeg_mem_term("CreateMetadataFromDatabuffer", 2575, "*** ERROR bad metadata length (%d bytes)\n", a2);
    return 0;
  }
  v8 = strncmp(a1, "Exif", 4uLL);
  v9 = v3 - 6;
  if (v8)
    v9 = v3;
  v10 = 6;
  if (v8)
    v10 = 0;
  v11 = (unsigned __int8 *)&a1[v10];
  v12 = a1[v10];
  if (v12 == 73)
  {
    if (v11[1] != 73 || v11[2] != 42 || v11[3])
      return 0;
    v14 = 0;
    v13 = *((_DWORD *)v11 + 1);
  }
  else
  {
    MetadataFromDatablock = 0;
    if (v12 != 77)
      return MetadataFromDatablock;
    if (v11[1] != 77 || v11[2] || v11[3] != 42)
      return 0;
    v13 = bswap32(*((_DWORD *)v11 + 1));
    v14 = 1;
  }
  v15 = (const void *)CGImageReadCreateWithDataForMetadata(v11, v9);
  if (!v15)
    return 0;
  v16 = v15;
  v17 = CGImageReadSessionCreate(v15);
  if (v17)
  {
    v18 = v17;
    Source = (IIOImageReadSession *)CGImageSourceGetSource((uint64_t)v17);
    MetadataFromDatablock = CreateMetadataFromDatablock(Source, tagdefsIFD0, v13, v14, 0, a3);
    CFRelease(v18);
  }
  else
  {
    MetadataFromDatablock = 0;
  }
  CFRelease(v16);
  return MetadataFromDatablock;
}

uint64_t CGImageReadCreateWithDataForMetadata(const UInt8 *a1, unsigned int a2)
{
  uint64_t v4;

  v4 = operator new();
  IIOImageRead::IIOImageRead(v4, a1, a2, 2, 1);
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 376));
  IIOImageRead::setISR((IIOImageRead *)v4, 0);
  pthread_mutex_unlock((pthread_mutex_t *)(v4 + 376));
  return CGImageReadRefCreateWith_ImageRead((IIOImageRead *)v4);
}

void sub_187E964A0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10F1C405FDDC6B3);
  _Unwind_Resume(a1);
}

_QWORD *AppleJPEGReadPlugin::appleJPEGDecodeSetup(_QWORD *this)
{
  _QWORD *v1;

  if (!this[63])
  {
    v1 = this;
    this[81] = this[3];
    this[82] = this[24];
    this[83] = this[58];
    this[66] = 0;
    this[64] = iio_jpeg_Malloc;
    this[65] = iio_jpeg_Free;
    this = (_QWORD *)applejpeg_decode_create();
    v1[63] = this;
    *((_BYTE *)v1 + 679) = 0;
  }
  return this;
}

uint64_t IIO_HardwareDecoderDefaultValue()
{
  if (IIO_HardwareDecoderDefaultValue::onceToken != -1)
    dispatch_once(&IIO_HardwareDecoderDefaultValue::onceToken, &__block_literal_global_22);
  return IIO_HardwareDecoderDefaultValue::hwDecoderDefaultValue;
}

uint64_t _cg_png_get_text_entry(uint64_t a1, uint64_t a2, unsigned int a3, _QWORD *a4, _QWORD *a5, _QWORD *a6)
{
  uint64_t v6;
  uint64_t result;

  if (a1 && a2 && *(_DWORD *)(a2 + 148) > a3)
  {
    if (a4)
      *a4 = *(_QWORD *)(*(_QWORD *)(a2 + 160) + 56 * a3 + 8);
    if (a5)
      *a5 = *(_QWORD *)(*(_QWORD *)(a2 + 160) + 56 * a3 + 24);
    v6 = *(_QWORD *)(a2 + 160);
    if (a6)
      *a6 = *(_QWORD *)(v6 + 56 * a3 + 32);
    return *(_QWORD *)(v6 + 56 * a3 + 16);
  }
  else
  {
    if (a4)
      *a4 = 0;
    if (a5)
      *a5 = 0;
    result = 0;
    if (a6)
      *a6 = 0;
  }
  return result;
}

uint64_t IIOHardwareDecodingEnabledFlag()
{
  return (gPermissions >> 3) & 1;
}

CGColorSpaceRef createColorSpaceFromMetadata(const __CFDictionary *a1, int a2, _BYTE *a3)
{
  const __CFDictionary *TopLevelTag;
  const __CFString *Source;
  float v8;
  const __CFString *v9;
  float v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  float v20;
  float v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  double v25;

  v23 = 0;
  v24 = 0;
  v22 = 0;
  v21 = 0.0;
  v20 = 0.0;
  v25 = 0.0;
  TopLevelTag = CGImageMetadataGetTopLevelTag(a1, (uint64_t)CFSTR("http://cipa.jp/exif/1.0/"), (uint64_t)CFSTR("Gamma"));
  Source = (const __CFString *)CGImageSourceGetSource((uint64_t)TopLevelTag);
  v8 = 0.0;
  if (Source)
  {
    v9 = Source;
    Source = (const __CFString *)Source[1].data;
    if (Source)
    {
      if (LODWORD(v9[1].info) == 1)
      {
        LODWORD(Source) = GetDoubleFromPropertyValue(Source, &v25);
        v8 = v25;
      }
      else
      {
        LODWORD(Source) = 0;
      }
    }
  }
  if ((a2 & ~(_DWORD)Source) != 0)
    v10 = 2.2;
  else
    v10 = v8;
  if ((Source & 1) == 0 && !a2)
    return 0;
  CGImageMetadataGetFloatAtIndex(a1, CFSTR("http://ns.adobe.com/tiff/1.0/"), CFSTR("WhitePoint"), 0, (float *)&v24 + 1);
  if (!v11)
    return 0;
  CGImageMetadataGetFloatAtIndex(a1, CFSTR("http://ns.adobe.com/tiff/1.0/"), CFSTR("WhitePoint"), 1u, (float *)&v24);
  if (!v12)
    return 0;
  CGImageMetadataGetFloatAtIndex(a1, CFSTR("http://ns.adobe.com/tiff/1.0/"), CFSTR("PrimaryChromaticities"), 0, (float *)&v23 + 1);
  if (!v13)
    return 0;
  CGImageMetadataGetFloatAtIndex(a1, CFSTR("http://ns.adobe.com/tiff/1.0/"), CFSTR("PrimaryChromaticities"), 1u, (float *)&v23);
  if (!v14)
    return 0;
  CGImageMetadataGetFloatAtIndex(a1, CFSTR("http://ns.adobe.com/tiff/1.0/"), CFSTR("PrimaryChromaticities"), 2u, (float *)&v22 + 1);
  if (!v15)
    return 0;
  CGImageMetadataGetFloatAtIndex(a1, CFSTR("http://ns.adobe.com/tiff/1.0/"), CFSTR("PrimaryChromaticities"), 3u, (float *)&v22);
  if (!v16)
    return 0;
  CGImageMetadataGetFloatAtIndex(a1, CFSTR("http://ns.adobe.com/tiff/1.0/"), CFSTR("PrimaryChromaticities"), 4u, &v21);
  if (!v17)
    return 0;
  CGImageMetadataGetFloatAtIndex(a1, CFSTR("http://ns.adobe.com/tiff/1.0/"), CFSTR("PrimaryChromaticities"), 5u, &v20);
  if (!v18)
    return 0;
  if (!IIOChromaticitiesMatchAdobeRGB(*((float *)&v24 + 1), *(float *)&v24, *((float *)&v23 + 1), *(float *)&v23, *((float *)&v22 + 1), *(float *)&v22, v21, v20, v10))return CGColorSpaceCreateCalRGB(*((float *)&v24 + 1), *(float *)&v24, *((float *)&v23 + 1), *(float *)&v23, *((float *)&v22 + 1), *(float *)&v22, v21, v20, v10);
  if (a3)
    *a3 = 1;
  return CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D8F8]);
}

uint64_t AppleJPEGReadPlugin::readJFIFData(IIOImageReadSession **this, IIODictionary *a2)
{
  unint64_t v4;
  unsigned int v5;
  uint64_t v6;
  unint64_t BytesAtOffset;
  unint64_t v9;
  float v10;
  float v11;
  unint64_t v12;
  _BYTE v13[24];
  _BYTE v14[24];
  _BYTE v15[24];
  _BYTE v16[24];
  _BYTE v17[24];
  _BYTE v18[24];
  _BYTE v19[24];
  _BYTE v20[24];
  CFMutableArrayRef v21;
  const void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD v26[2];

  v26[1] = *MEMORY[0x1E0C80C00];
  v24 = 0;
  v25 = 0;
  if (!a2)
    return 1;
  v26[0] = 0;
  if (IIOImageReadSession::getBytesAtOffset(this[3], v26, 2uLL, 8uLL) != 8)
    return 0;
  v4 = 2;
  while (1)
  {
    v5 = __rev16(LOWORD(v26[0]));
    if (v5 != 0xFFFF)
      break;
    LODWORD(v6) = 0;
    --v4;
LABEL_9:
    v4 += v6 + 2;
    if (IIOImageReadSession::getBytesAtOffset(this[3], v26, v4, 8uLL) != 8)
      return 0;
  }
  if (v5 == 65498)
    return 1;
  v6 = __rev16(WORD1(v26[0]));
  if (v5 != 65504)
    goto LABEL_9;
  if (v6 > 0xF)
  {
    BytesAtOffset = IIOImageReadSession::getBytesAtOffset(this[3], &v24, v4 + 4, 0x10uLL);
    if (BytesAtOffset != v6)
    {
      if (BytesAtOffset + 4 != v6)
      {
        _cg_jpeg_mem_term("readJFIFData", 485, "bad APP0 marker: tagSize: %d  expected: %d\n", v6, 16);
        return 1;
      }
      _cg_jpeg_mem_term("readJFIFData", 482, "*** APP0 marker indicating depth/disparity...\n");
    }
    WORD2(v24) = bswap32(WORD2(v24)) >> 16;
    LOWORD(v25) = bswap32((unsigned __int16)v25) >> 16;
    WORD1(v25) = bswap32(WORD1(v25)) >> 16;
    v21 = 0;
    v22 = 0;
    v23 = 0;
    IIOArray::IIOArray((IIOArray *)&v21);
    IIONumber::IIONumber((IIONumber *)v20, WORD2(v24));
    IIOArray::addObject(&v21, (uint64_t)v20);
    IIONumber::~IIONumber((IIONumber *)v20);
    IIONumber::IIONumber((IIONumber *)v19, BYTE6(v24) >> 4);
    IIOArray::addObject(&v21, (uint64_t)v19);
    IIONumber::~IIONumber((IIONumber *)v19);
    IIONumber::IIONumber((IIONumber *)v18, BYTE6(v24) & 0xF);
    IIOArray::addObject(&v21, (uint64_t)v18);
    IIONumber::~IIONumber((IIONumber *)v18);
    IIODictionary::setObjectForKeyGroup(a2, v22, CFSTR("JFIFVersion"), CFSTR("{JFIF}"));
    IIONumber::IIONumber((IIONumber *)v17, (unsigned __int16)v25);
    IIODictionary::setObjectForKeyGroup(a2, (uint64_t)v17, CFSTR("XDensity"), CFSTR("{JFIF}"));
    IIONumber::~IIONumber((IIONumber *)v17);
    IIONumber::IIONumber((IIONumber *)v16, WORD1(v25));
    IIODictionary::setObjectForKeyGroup(a2, (uint64_t)v16, CFSTR("YDensity"), CFSTR("{JFIF}"));
    IIONumber::~IIONumber((IIONumber *)v16);
    IIONumber::IIONumber((IIONumber *)v15, HIBYTE(v24));
    IIODictionary::setObjectForKeyGroup(a2, (uint64_t)v15, CFSTR("DensityUnit"), CFSTR("{JFIF}"));
    IIONumber::~IIONumber((IIONumber *)v15);
    if (HIBYTE(v24) == 2)
    {
      LOWORD(v9) = v25;
      *(double *)&v12 = (double)v9 * 2.54;
      v10 = *(double *)&v12;
      LOWORD(v12) = WORD1(v25);
      v11 = (double)v12 * 2.54;
    }
    else
    {
      v10 = 0.0;
      v11 = 0.0;
      if (HIBYTE(v24) == 1)
      {
        LOWORD(v9) = v25;
        v10 = (float)v9;
        LOWORD(v9) = WORD1(v25);
        v11 = (float)v9;
      }
    }
    if (ValidDPI(v10) && ValidDPI(v11))
    {
      IIONumber::IIONumber((IIONumber *)v14, v10);
      IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v14, CFSTR("DPIWidth"));
      IIONumber::~IIONumber((IIONumber *)v14);
      IIONumber::IIONumber((IIONumber *)v13, v11);
      IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v13, CFSTR("DPIHeight"));
      IIONumber::~IIONumber((IIONumber *)v13);
    }
    IIOArray::~IIOArray((IIOArray *)&v21);
    return 1;
  }
  if (bswap32(HIDWORD(v26[0])) != 1246120262)
    return 1;
  _cg_jpeg_mem_term("readJFIFData", 470, "bad APP0-JFIF marker: tagSize: %d  expected: %d\n", v6, 16);
  return 0;
}

void sub_187E96C1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v4;
  va_list va;

  va_start(va, a4);
  IIONumber::~IIONumber((IIONumber *)va);
  IIOArray::~IIOArray((IIOArray *)(v4 - 136));
  _Unwind_Resume(a1);
}

BOOL ValidDPI(float a1)
{
  _BOOL4 v1;

  v1 = a1 >= 10.0;
  if (a1 > 4800.0)
    v1 = 0;
  return (LODWORD(a1) & 0x7FFFFFFFu) < 0x7F800000 && v1;
}

void IIOArray::IIOArray(IIOArray *this)
{
  *(_QWORD *)this = &off_1E1BB2B40;
  *((_QWORD *)this + 1) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  *((_BYTE *)this + 16) = 1;
}

void IIOArray::IIOArray(IIOArray *this, CFTypeRef cf)
{
  CFTypeID v4;
  CFTypeRef v5;
  char v6;

  *(_QWORD *)this = &off_1E1BB2B40;
  if (cf)
  {
    v4 = CFGetTypeID(cf);
    if (v4 == CFArrayGetTypeID())
    {
      v5 = CFRetain(cf);
      v6 = 0;
      *((_QWORD *)this + 1) = v5;
    }
    else
    {
      IIOLogTypeMismatch(cf, "IIOArray", "CFArrayRef");
      v6 = 0;
      *((_QWORD *)this + 1) = 0;
    }
  }
  else
  {
    *((_QWORD *)this + 1) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
    v6 = 1;
  }
  *((_BYTE *)this + 16) = v6;
}

{
  CFTypeID v4;
  void *Mutable;
  char v6;

  *(_QWORD *)this = &off_1E1BB2B40;
  if (cf)
  {
    v4 = CFGetTypeID(cf);
    if (v4 != CFArrayGetTypeID())
    {
      IIOLogTypeMismatch(cf, "IIOArray", "CFArrayRef");
      v6 = 0;
      *((_QWORD *)this + 1) = 0;
      goto LABEL_7;
    }
    Mutable = (void *)CFRetain(cf);
  }
  else
  {
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  }
  *((_QWORD *)this + 1) = Mutable;
  v6 = 1;
LABEL_7:
  *((_BYTE *)this + 16) = v6;
}

const __CFArray *IIOArray::getCount(IIOArray *this)
{
  const __CFArray *result;

  result = (const __CFArray *)*((_QWORD *)this + 1);
  if (result)
    return (const __CFArray *)CFArrayGetCount(result);
  return result;
}

uint64_t IIOArray::getUint32AtIndex(IIOArray *this, CFIndex a2)
{
  const __CFArray *v2;
  const void *ValueAtIndex;
  uint64_t v4;
  _BYTE v6[24];

  v2 = (const __CFArray *)*((_QWORD *)this + 1);
  if (!v2)
    return 0;
  ValueAtIndex = CFArrayGetValueAtIndex(v2, a2);
  IIONumber::IIONumber((IIONumber *)v6, ValueAtIndex);
  v4 = IIONumber::uint32Num((IIONumber *)v6);
  IIONumber::~IIONumber((IIONumber *)v6);
  return v4;
}

void sub_187E96E90(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

CGImageMetadata *AppleJPEGReadPlugin::readExifData(IIOImageReadSession **this, IIODictionary *a2)
{
  uint64_t v4;
  unint64_t i;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  _BYTE *v9;
  CGImageMetadata *Mutable;
  const __CFDictionary *TopLevelTag;
  uint64_t v12;
  const __CFString *v13;
  SInt32 IntValue;
  unint64_t v15;
  const __CFString *v16;
  const __CFDictionary *v17;
  const __CFDictionary *v18;
  const __CFDictionary *v19;
  const __CFDictionary *v20;
  uint64_t v22;
  int Val16;
  unsigned int v24;
  int v25;
  int v26;
  CGImageMetadataTag *v27;
  CGImageMetadataTag *v28;
  char v29;
  _BYTE v30[16];
  CFTypeRef value;
  _OWORD v32[4];
  uint64_t v33;
  _QWORD v34[10];
  unsigned int v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  _QWORD v44[3];
  int v45;
  int v46;
  unsigned __int16 v47;
  int v48;

  v29 = 0;
  v48 = 0;
  v47 = 0;
  v46 = 0;
  v44[0] = 0;
  v44[1] = v44;
  v44[2] = 0x2000000000;
  v45 = 0;
  v40 = 0;
  v41 = &v40;
  v42 = 0x2000000000;
  v43 = 0;
  v4 = 2;
  v36 = 0;
  v37 = &v36;
  v38 = 0x2000000000;
  v39 = 0;
  while (2)
  {
    for (i = v4 + 10; ; ++i)
    {
      if (IIOImageReadSession::getBytesAtOffset(this[3], &v48, i - 10, 4uLL) != 4)
        goto LABEL_21;
      v6 = bswap32((unsigned __int16)v48) >> 16;
      if (v6 != 0xFFFF)
        break;
    }
    if (v6 == 65498)
      goto LABEL_21;
    v7 = __rev16(HIWORD(v48));
    if (v6 == 65504)
    {
      v29 = 1;
      goto LABEL_14;
    }
    if (v6 != 65505 || v7 < 0xB)
      goto LABEL_14;
    if (IIOImageReadSession::getBytesAtOffset(this[3], &v46, i - 6, 6uLL) != 6)
    {
LABEL_21:
      Mutable = 0;
      goto LABEL_22;
    }
    if (v46 ^ 0x66697845 | v47)
    {
LABEL_14:
      v4 = i + v7 - 8;
      continue;
    }
    break;
  }
  if (v7 < 0x15)
    goto LABEL_21;
  v8 = IIOMetadataFlagsFromImageSourceOptions(a2);
  v9 = malloc_type_malloc(v7 - 6, 0xDAFC518EuLL);
  if (!v9)
    goto LABEL_21;
  if (IIOImageReadSession::getBytesAtOffset(this[3], v9, i, v7 - 6) != v7 - 6)
  {
    free(v9);
    goto LABEL_21;
  }
  if ((v8 & 1) != 0)
  {
    Mutable = CGImageMetadataCreateMutable();
    v34[0] = MEMORY[0x1E0C809B0];
    v34[1] = 0x40000000;
    v34[2] = ___ZN19AppleJPEGReadPlugin12readExifDataEP13IIODictionarybb_block_invoke;
    v34[3] = &unk_1E1BBD338;
    v34[8] = Mutable;
    v34[9] = i - 10;
    v35 = v8;
    v34[4] = v44;
    v34[5] = &v40;
    v34[6] = &v36;
    v34[7] = this;
    EnumerateExifDataUsingBlock(v9, v7 - 6, (uint64_t)v34);
    if (v41[3] && *((_DWORD *)v37 + 6))
    {
      v33 = 0;
      memset(v32, 0, sizeof(v32));
      IIOScanner::IIOScanner((IIOScanner *)v32, v9, v7 - 6, 0);
      v22 = v41[3];
      if (v22 - IIOScanner::seek((IIOScanner *)v32, v22 - i) == i
        && IIOScanner::getVal16((IIOScanner *)v32) == 65496
        && !(_DWORD)v33)
      {
        while (1)
        {
          Val16 = IIOScanner::getVal16((IIOScanner *)v32);
          v24 = IIOScanner::getVal16((IIOScanner *)v32);
          if (Val16 == 65472)
            break;
          IIOScanner::skip((uint64_t)v32, v24 - 2);
          if (Val16 == 65498 || (_DWORD)v33)
            goto LABEL_37;
        }
        IIOScanner::skip((uint64_t)v32, 1);
        v25 = IIOScanner::getVal16((IIOScanner *)v32);
        v26 = IIOScanner::getVal16((IIOScanner *)v32);
        IIONumber::IIONumber((IIONumber *)v30, v26);
        v27 = CGImageMetadataTagCreate(CFSTR("http://ns.adobe.com/tiff/1.0/"), CFSTR("iio"), CFSTR("JPEGInterchangeFormatWidth"), kCGImageMetadataTypeDefault, value);
        IIONumber::~IIONumber((IIONumber *)v30);
        if (v27)
        {
          CGImageMetadataSetTagWithPath(Mutable, 0, CFSTR("iio:JPEGInterchangeFormatWidth"), v27);
          CFRelease(v27);
        }
        IIONumber::IIONumber((IIONumber *)v30, v25);
        v28 = CGImageMetadataTagCreate(CFSTR("http://ns.adobe.com/tiff/1.0/"), CFSTR("iio"), CFSTR("JPEGInterchangeFormatHeight"), kCGImageMetadataTypeDefault, value);
        IIONumber::~IIONumber((IIONumber *)v30);
        if (v28)
        {
          CGImageMetadataSetTagWithPath(Mutable, 0, CFSTR("iio:JPEGInterchangeFormatHeight"), v28);
          CFRelease(v28);
        }
      }
LABEL_37:
      IIOScanner::~IIOScanner((IIOScanner *)v32);
    }
  }
  else
  {
    Mutable = CreateMetadataFromDatabuffer(v9, v7 - 6, v8);
  }
  free(v9);
LABEL_22:
  if ((v29 & 1) != 0)
  {
    TopLevelTag = CGImageMetadataGetTopLevelTag(Mutable, (uint64_t)CFSTR("http://ns.apple.com/ImageIO/1.0/"), (uint64_t)CFSTR("JPEGInterchangeFormat"));
    v12 = (uint64_t)TopLevelTag;
    if (TopLevelTag)
    {
      v13 = (const __CFString *)CGImageMetadataTagGetValue((uint64_t)TopLevelTag);
      IntValue = CFStringGetIntValue(v13);
      v41[3] = IntValue;
      LOWORD(v32[0]) = 0;
      IIOImageReadSession::getBytesAtOffset(this[3], v32, IntValue, 2uLL);
      if (LOWORD(v32[0]) != 55551 && LOWORD(v32[0]) != 65496)
      {
        v15 = v41[3] + 18;
        v41[3] = v15;
        IIOImageReadSession::getBytesAtOffset(this[3], v32, v15, 2uLL);
        if (LOWORD(v32[0]) == 65496 || LOWORD(v32[0]) == 55551)
        {
          v16 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%lld"), v41[3]);
          if (v16)
          {
            CGImageMetadataTagSetValue(v12, v16);
            CFRelease(v16);
          }
        }
        else
        {
          v17 = CGImageMetadataGetTopLevelTag(Mutable, (uint64_t)CFSTR("http://ns.apple.com/ImageIO/1.0/"), (uint64_t)CFSTR("JPEGInterchangeFormat"));
          CGImageMetadataRemoveTag((uint64_t)Mutable, (uint64_t)v17);
          v18 = CGImageMetadataGetTopLevelTag(Mutable, (uint64_t)CFSTR("http://ns.apple.com/ImageIO/1.0/"), (uint64_t)CFSTR("JPEGInterchangeFormatLength"));
          CGImageMetadataRemoveTag((uint64_t)Mutable, (uint64_t)v18);
          v19 = CGImageMetadataGetTopLevelTag(Mutable, (uint64_t)CFSTR("http://ns.apple.com/ImageIO/1.0/"), (uint64_t)CFSTR("JPEGInterchangeFormatWidth"));
          CGImageMetadataRemoveTag((uint64_t)Mutable, (uint64_t)v19);
          v20 = CGImageMetadataGetTopLevelTag(Mutable, (uint64_t)CFSTR("http://ns.apple.com/ImageIO/1.0/"), (uint64_t)CFSTR("JPEGInterchangeFormatHeight"));
          CGImageMetadataRemoveTag((uint64_t)Mutable, (uint64_t)v20);
        }
      }
    }
  }
  _Block_object_dispose(&v36, 8);
  _Block_object_dispose(&v40, 8);
  _Block_object_dispose(v44, 8);
  return Mutable;
}

void sub_187E97450(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  CGImageMetadata *v4;
  va_list va;

  va_start(va, a4);
  IIONumber::~IIONumber((IIONumber *)va);
  __cxa_begin_catch(a1);
  CGImageMetadataRemoveTagWithPath(v4, 0, CFSTR("iio:JPEGInterchangeFormatWidth"));
  CGImageMetadataRemoveTagWithPath(v4, 0, CFSTR("iio:JPEGInterchangeFormatHeight"));
  __cxa_end_catch();
  JUMPOUT(0x187E97300);
}

void sub_187E974C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  IIOScanner::~IIOScanner((IIOScanner *)va);
  JUMPOUT(0x187E974F8);
}

void sub_187E974F4(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 200), 8);
  _Block_object_dispose((const void *)(v1 - 168), 8);
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

_DWORD *AppleJPEGReadPlugin::readICCData(IIOImageReadSession **this, unint64_t a2, uint64_t a3, unint64_t *a4, unsigned int *a5)
{
  unint64_t v8;
  _DWORD *v9;
  unint64_t v10;
  unsigned int v11;
  size_t v12;
  _BYTE *v13;
  _QWORD *v14;
  int v15;
  unsigned int v16;
  unsigned int *v18;
  size_t v19;
  unint64_t v20;
  int v21;
  unint64_t v22;
  int v25;

  v8 = a3 + 2;
  *a4 = 0;
  if (a2)
  {
    v9 = 0;
    if (v8 > a2)
      return v9;
  }
  v10 = 0;
  v9 = 0;
  v25 = 0;
  while (IIOImageReadSession::getBytesAtOffset(this[3], &v25, v8, 4uLL) == 4)
  {
    v11 = bswap32((unsigned __int16)v25) >> 16;
    v12 = bswap32(HIWORD(v25)) >> 16;
    if ((unsigned __int16)(v11 + 64) > 2u)
    {
      if (v11 != 65506)
      {
        if (v11 == 65498)
          break;
        goto LABEL_31;
      }
      if (v12 < 0x10)
        break;
      v14 = malloc_type_malloc(v12, 0xDAFC35B8uLL);
      if (IIOImageReadSession::getBytesAtOffset(this[3], v14, v8 + 4, v12) != v12)
      {
        if (!v14)
          break;
LABEL_35:
        free(v14);
        break;
      }
      if (*v14 == 0x464F52505F434349 && *(_QWORD *)((char *)v14 + 3) == 0x454C49464F52505FLL)
      {
        v18 = a5;
        v19 = v12 - 16;
        if (v9)
        {
          v20 = v19 + v10;
          v9 = reallocf(v9, v19 + v10);
        }
        else
        {
          v9 = malloc_type_malloc(v12 - 16, 0xD9E69E15uLL);
          v20 = v19 + v10;
        }
        memcpy((char *)v9 + v10, (char *)v14 + 14, v12 - 16);
        v10 = v20;
        a5 = v18;
      }
      goto LABEL_30;
    }
    if (v12 < 6)
      goto LABEL_31;
    v13 = malloc_type_malloc(v12, 0x735B48ADuLL);
    if (!v13)
      break;
    v14 = v13;
    if (IIOImageReadSession::getBytesAtOffset(this[3], v13, v8 + 4, v12) != v12)
      goto LABEL_35;
    v15 = *((unsigned __int8 *)v14 + 5);
    switch(v15)
    {
      case 1:
        v16 = 1196573017;
        goto LABEL_27;
      case 4:
        v16 = 1129142603;
        goto LABEL_27;
      case 3:
        v16 = 1380401696;
LABEL_27:
        *a5 = v16;
        break;
    }
LABEL_30:
    free(v14);
LABEL_31:
    v8 += v12 + 2;
    if (a2 && v8 > a2)
      break;
  }
  if (v9)
  {
    *a4 = v10;
    if (v10 >= 0x80)
    {
      v21 = v9[9];
      v22 = bswap32(*v9);
      if (v10 < v22)
        LogError("readICCData", 1270, "Embedded profile header length is greater than data length.\n");
      if (v21 == 1886610273)
      {
        if (*a4 >= v22)
          return v9;
      }
      else
      {
        LogError("readICCData", 1272, "Embedded profile signature is not valid.\n");
      }
    }
    free(v9);
    v9 = 0;
    *a4 = 0;
  }
  return v9;
}

uint64_t IIOImagePlus::sourceImageProvider(IIOImagePlus *this)
{
  return *((_QWORD *)this + 18);
}

float CGImageMetadataGetFloatAtIndex(const CGImageMetadata *a1, const __CFString *a2, const __CFString *a3, unsigned int a4, float *a5)
{
  const __CFDictionary *TopLevelTag;
  uint64_t Source;
  float result;
  const __CFArray *v10;
  const __CFString *ValueAtIndex;
  double v12;

  v12 = 0.0;
  TopLevelTag = CGImageMetadataGetTopLevelTag(a1, (uint64_t)a2, (uint64_t)a3);
  Source = CGImageSourceGetSource((uint64_t)TopLevelTag);
  if (Source)
  {
    v10 = *(const __CFArray **)(Source + 48);
    if (v10)
    {
      if (*(_DWORD *)(Source + 40) == 3 && CFArrayGetCount(*(CFArrayRef *)(Source + 48)) > a4)
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v10, a4);
        if (ValueAtIndex)
          GetDoubleFromPropertyValue(ValueAtIndex, &v12);
      }
    }
  }
  if (a5)
  {
    result = v12;
    *a5 = result;
  }
  return result;
}

CGImageMetadata *CreateMetadataFromXMPBuffer(const char *a1, uint64_t a2)
{
  return CreateMetadataFromXMPBufferInternal(a1, a2, 0, 0, 8);
}

void PNGReadPlugin::AddTextChunkToProperties(PNGReadPlugin *this, IIODictionary *a2, UInt8 *bytes, char *a4, unsigned int a5)
{
  const __CFAllocator *v9;
  CFIndex v10;
  const __CFString *v11;
  CFStringRef v12;
  const __CFString **v13;

  if (bytes)
  {
    if (a4)
      a5 = a4;
    v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v10 = a5;
    v11 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], bytes, a5, 0x8000100u, 0);
    if (v11)
    {
      v12 = v11;
      if (CFStringGetLength(v11))
        goto LABEL_9;
      CFRelease(v12);
    }
    v12 = CFStringCreateWithBytes(v9, bytes, v10, 0x600u, 0);
    if (v12)
    {
LABEL_9:
      if (!strncmp((const char *)a2, "Author", 6uLL))
      {
        v13 = (const __CFString **)&kCGImagePropertyPNGAuthor;
      }
      else if (!strncmp((const char *)a2, "Comment", 7uLL))
      {
        v13 = (const __CFString **)&kCGImagePropertyPNGComment;
      }
      else if (!strncmp((const char *)a2, "Copyright", 9uLL))
      {
        v13 = (const __CFString **)&kCGImagePropertyPNGCopyright;
      }
      else if (!strncmp((const char *)a2, "CreationTime", 0xCuLL))
      {
        v13 = (const __CFString **)&kCGImagePropertyPNGCreationTime;
      }
      else if (!strncmp((const char *)a2, "Description", 0xBuLL))
      {
        v13 = (const __CFString **)&kCGImagePropertyPNGDescription;
      }
      else if (!strncmp((const char *)a2, "Disclaimer", 0xAuLL))
      {
        v13 = (const __CFString **)&kCGImagePropertyPNGDisclaimer;
      }
      else if (!strncmp((const char *)a2, "ModificationTime", 0x10uLL))
      {
        v13 = (const __CFString **)&kCGImagePropertyPNGModificationTime;
      }
      else if (!strncmp((const char *)a2, "Software", 8uLL))
      {
        v13 = (const __CFString **)&kCGImagePropertyPNGSoftware;
      }
      else if (!strncmp((const char *)a2, "Source", 6uLL))
      {
        v13 = (const __CFString **)&kCGImagePropertyPNGSource;
      }
      else if (!strncmp((const char *)a2, "Title", 5uLL))
      {
        v13 = (const __CFString **)&kCGImagePropertyPNGTitle;
      }
      else
      {
        if (strncmp((const char *)a2, "Warning", 7uLL))
          goto LABEL_34;
        v13 = (const __CFString **)&kCGImagePropertyPNGWarning;
      }
      if (*v13)
      {
        IIODictionary::setObjectForKeyGroup(this, v12, *v13, CFSTR("{PNG}"));
LABEL_35:
        CFRelease(v12);
        return;
      }
LABEL_34:
      _cg_jpeg_mem_term("AddTextChunkToProperties", 1069, "PNG - not handling:      key: %s\n", (const char *)a2);
      _cg_jpeg_mem_term("AddTextChunkToProperties", 1070, "                        text: %s\n", (const char *)bytes);
      goto LABEL_35;
    }
  }
}

CGMutableImageMetadataRef AppleJPEGReadPlugin::readAPP13(IIOImageReadSession **this)
{
  CGMutableImageMetadataRef Mutable;
  unint64_t v3;
  void *v4;
  unint64_t v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v9;
  void *TagWithPath;
  uint64_t v12;
  const CGPath *Value;
  IIOImagePlus *v14;
  const CGPath *v15;
  int v16;
  _QWORD v17[3];

  v17[2] = *MEMORY[0x1E0C80C00];
  v16 = 0;
  *(_QWORD *)((char *)v17 + 6) = 0;
  v17[0] = 0;
  Mutable = 0;
  if (IIOImageReadSession::getBytesAtOffset(this[3], &v16, 2uLL, 4uLL) != 4)
    return Mutable;
  v3 = 0;
  v4 = 0;
  v5 = 2;
  while (1)
  {
    v6 = bswap32((unsigned __int16)v16) >> 16;
    v7 = bswap32(HIWORD(v16)) >> 16;
    if (v6 == 65517)
    {
      if (v7 >= 0xF)
      {
        if (IIOImageReadSession::getBytesAtOffset(this[3], v17, v5 + 4, 0xEuLL) != 14)
          goto LABEL_21;
        if (v17[0] == 0x6F68736F746F6850 && *(_QWORD *)((char *)v17 + 6) == 0x302E3320706F68)
        {
          if (v7 < 0x11)
            goto LABEL_21;
          v9 = (v7 - 16);
          v4 = reallocf(v4, v9 + v3);
          if (v4)
          {
            if (IIOImageReadSession::getBytesAtOffset(this[3], (_BYTE *)v4 + v3, v5 + 18, (v7 - 16)) != v9)
            {
              Mutable = 0;
LABEL_22:
              free(v4);
              return Mutable;
            }
            v3 += v9;
          }
        }
      }
      goto LABEL_18;
    }
    if (v6 == 0xFFFF)
    {
      ++v5;
      goto LABEL_20;
    }
    if (v6 == 65498)
      break;
LABEL_18:
    v5 += v7 + 2;
LABEL_20:
    if (IIOImageReadSession::getBytesAtOffset(this[3], &v16, v5, 4uLL) != 4)
    {
LABEL_21:
      Mutable = 0;
      if (!v4)
        return Mutable;
      goto LABEL_22;
    }
  }
  if (v4)
  {
    Mutable = CGImageMetadataCreateMutable();
    ReadPhotoshopImageResource((uint64_t)Mutable, (uint64_t)v4, v3);
    if (Mutable)
    {
      TagWithPath = CGImageMetadataGetTagWithPath(Mutable, 0, CFSTR("iio:PSIRClippingPath"));
      if (TagWithPath)
      {
        v12 = (uint64_t)TagWithPath;
        Value = (const CGPath *)CGImageMetadataTagGetValue((uint64_t)TagWithPath);
        if (Value)
        {
          v14 = this[2];
          v15 = CGPathRetain(Value);
          IIOImagePlus::setClipPath(v14, v15);
        }
        CGImageMetadataRemoveTag((uint64_t)Mutable, v12);
      }
    }
    goto LABEL_22;
  }
  return 0;
}

CGImageMetadata *AppleJPEGReadPlugin::readXMPData(IIOImageReadSession **this, CFDataRef theData)
{
  const char *BytePtr;
  CFIndex Length;
  CGImageMetadata *MetadataFromExtendedXMPData;
  char *v8;
  size_t v9;
  _BYTE *v10;
  unint64_t v11;
  unsigned int v12;
  unsigned int v13;
  BOOL v15;
  size_t v16;
  unsigned int v17;
  BOOL v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  char v24;
  uint64_t v25;
  int v26;
  unsigned int v27;
  int v28;
  __int128 v29;
  __int128 v30;
  _OWORD __s1[5];
  uint64_t v32;
  uint64_t v33;
  _QWORD v34[2];
  __int128 v35;
  _BYTE v36[19];
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  if (theData)
  {
    BytePtr = (const char *)CFDataGetBytePtr(theData);
    Length = CFDataGetLength(theData);
    return CreateMetadataFromXMPSidecarData(BytePtr, Length);
  }
  v35 = 0u;
  memset(v36, 0, sizeof(v36));
  v28 = 0;
  v32 = 0;
  v33 = 0;
  memset(v34, 0, 14);
  memset(__s1, 0, 75);
  MetadataFromExtendedXMPData = 0;
  if (IIOImageReadSession::getBytesAtOffset(this[3], &v28, 2uLL, 4uLL) != 4)
    return MetadataFromExtendedXMPData;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v8 = 0;
  LODWORD(v9) = 0;
  v10 = 0;
  v11 = 2;
  while (1)
  {
    v12 = bswap32((unsigned __int16)v28) >> 16;
    v13 = bswap32(HIWORD(v28)) >> 16;
    if (v12 != 65505)
    {
      if (v12 == 65498)
        goto LABEL_42;
      goto LABEL_41;
    }
    if (v13 >= 0x1E)
      break;
LABEL_41:
    v11 += v13 + 2;
    if (IIOImageReadSession::getBytesAtOffset(this[3], &v28, v11, 4uLL) != 4)
    {
LABEL_42:
      if (!v8)
        goto LABEL_50;
      goto LABEL_43;
    }
  }
  if (IIOImageReadSession::getBytesAtOffset(this[3], &v32, v11 + 4, 0x1EuLL) != 30)
    goto LABEL_42;
  v15 = v32 == 0x6E2F2F3A70747468 && v33 == 0x2E65626F64612E73 && v34[0] == 0x2F7061782F6D6F63;
  if (v15 && BYTE5(v34[1]) == 60)
  {
    v9 = v13 - 31;
    v10 = reallocf(v10, v9);
    if (IIOImageReadSession::getBytesAtOffset(this[3], v10, v11 + 33, v9) != v9)
      goto LABEL_42;
    goto LABEL_41;
  }
  if (v13 < 0x4C)
    goto LABEL_41;
  if (IIOImageReadSession::getBytesAtOffset(this[3], __s1, v11 + 4, 0x4BuLL) != 75)
    goto LABEL_42;
  if (strcmp((const char *)__s1, "http://ns.adobe.com/xmp/extension/"))
    goto LABEL_41;
  v23 = v8;
  v29 = 0u;
  v30 = 0u;
  IIOImageReadSession::getBytesAtOffset(this[3], &v29, v11 + 39, 0x20uLL);
  v27 = 0;
  IIOImageReadSession::getBytesAtOffset(this[3], &v27, v11 + 71, 4uLL);
  v16 = bswap32(v27);
  v27 = 0;
  IIOImageReadSession::getBytesAtOffset(this[3], &v27, v11 + 75, 4uLL);
  v17 = v27;
  if ((v24 & 1) != 0
    || (v35 = v29, *(_OWORD *)v36 = v30, v26 = v16, (v23 = (char *)malloc_type_calloc(1uLL, v16, 0x5BBD479CuLL)) != 0))
  {
    v20 = (_QWORD)v35 == (_QWORD)v29
       && *((_QWORD *)&v35 + 1) == *((_QWORD *)&v29 + 1)
       && *(_QWORD *)v36 == (_QWORD)v30
       && *(_QWORD *)&v36[8] == *((_QWORD *)&v30 + 1);
    if (v20 && (_DWORD)v16 == v26)
    {
      v21 = bswap32(v17);
      v22 = v13 - 77;
      if (v21 + (unint64_t)v22 > v16)
        goto LABEL_49;
      IIOImageReadSession::getBytesAtOffset(this[3], &v23[v21], v11 + 79, v13 - 77);
      v25 += v22;
    }
    v24 = 1;
    v8 = v23;
    goto LABEL_41;
  }
  v23 = 0;
LABEL_49:
  v26 = v16;
  v8 = v23;
  if (v23)
  {
LABEL_43:
    if (!v26 || v25 != v26 || !v10 || !(_DWORD)v9)
      goto LABEL_50;
    MetadataFromExtendedXMPData = CreateMetadataFromExtendedXMPData(v10, v9, v8, v25);
    free(v10);
    goto LABEL_57;
  }
LABEL_50:
  if (v10 && (_DWORD)v9)
  {
    MetadataFromExtendedXMPData = CreateMetadataFromXMPBuffer(v10, v9);
    free(v10);
    if (!v8)
      return MetadataFromExtendedXMPData;
    goto LABEL_57;
  }
  if (v10)
    free(v10);
  MetadataFromExtendedXMPData = 0;
  if (v8)
LABEL_57:
    free(v8);
  return MetadataFromExtendedXMPData;
}

uint64_t IIOGetOrientationFromXMPData(const char *a1, size_t __len)
{
  uint64_t v3;
  char *v4;
  unsigned __int8 *v5;
  uint64_t v6;
  int v7;
  unsigned int v8;

  v3 = __len;
  v4 = strnstr(a1, "tiff:Orientation", __len);
  if (!v4)
    return 1;
  v5 = (unsigned __int8 *)(v4 + 16);
  if (v4 + 16 >= &a1[v3])
  {
LABEL_6:
    v8 = 1;
  }
  else
  {
    v6 = &a1[v3] - v4 - 16;
    while (1)
    {
      v7 = *v5;
      if ((v7 - 58) >= 0xFFFFFFF6)
        break;
      ++v5;
      if (!--v6)
        goto LABEL_6;
    }
    v8 = v7 - 48;
  }
  if (v8 - 9 < 0xFFFFFFF8)
    return 1;
  else
    return v8;
}

void HEIFAuxImage::HEIFAuxImage(HEIFAuxImage *this, const __CFDictionary *a2, const __CFDictionary *a3, int a4)
{
  _DWORD *v7;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v9;
  const __CFDictionary *ObjectForKey;
  unsigned int v11;
  unsigned int v12;
  int v13;
  const char *v14;
  unsigned int Uint32ForKey;
  unsigned int v16;
  int v17;
  const char *v18;
  CFTypeID v19;
  CFArrayRef v20[3];
  CFArrayRef theArray;
  void *value;
  _QWORD v23[3];

  *(_QWORD *)this = &off_1E1BAC1F0;
  memset(v23, 0, sizeof(v23));
  IIODictionary::IIODictionary((IIODictionary *)v23, a2);
  *(_OWORD *)((char *)this + 8) = 0u;
  v7 = (_DWORD *)((char *)this + 8);
  *((_QWORD *)this + 7) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((_DWORD *)this + 8) = a4;
  if (!a3)
  {
    ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v23, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryTypeURN);
    *v7 = IIODictionary::getUint32ForKeyGroup((IIODictionary *)v23, CFSTR("Width"), *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_Dimensions);
    *((_DWORD *)this + 3) = IIODictionary::getUint32ForKeyGroup((IIODictionary *)v23, CFSTR("Height"), *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_Dimensions);
    *((_DWORD *)this + 4) = IIODictionary::getUint32ForKey((IIODictionary *)v23, CFSTR("Orientation"));
    *((float *)this + 11) = IIODictionary::getFloatForKey((IIODictionary *)v23, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_MeteorHeadroomFromMakerNote);
    *((float *)this + 12) = IIODictionary::getFloatForKey((IIODictionary *)v23, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_MeteorHeadroomFromProperties);
    *((_DWORD *)this + 10) = IIODictionary::getUint32ForKey((IIODictionary *)v23, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryNativePixelFormat);
    Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v23, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryType);
    *((_DWORD *)this + 7) = Uint32ForKey;
    if (Uint32ForKey == 3)
    {
      if (!ObjectForKey)
      {
        _cg_jpeg_mem_term("HEIFAuxImage", 1100, "*** ERROR: 'kCMPhotoDecompressionContainerDescription_AuxiliaryTypeURN' is NULL - for 'kCMPhotoAuxiliaryImageType_Alpha'\n");
        ObjectForKey = *(const __CFDictionary **)gIIO_kCMPhotoAuxiliaryImageTypeURN_MIAF_Alpha;
      }
      v16 = IIODictionary::getUint32ForKey((IIODictionary *)v23, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_AlphaPremultiplication);
      if (v16)
        v17 = v16 == 1;
      else
        v17 = 3;
      *((_DWORD *)this + 9) = v17;
      v18 = IIO_AlphaInfoString(v17);
      _cg_jpeg_mem_term("HEIFAuxImage", 1110, "    HEIFAuxImage: alpha: %s\n", v18);
    }
    if (!ObjectForKey)
    {
      ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v23, CFSTR("URI"));
      if (!ObjectForKey)
        goto LABEL_27;
      *((_DWORD *)this + 7) = 99;
    }
    goto LABEL_25;
  }
  value = 0;
  CFDictionaryGetValueIfPresent(a3, *(const void **)gIIO_kCMPhotoDecompressionContainerDescription_MainImages, (const void **)&value);
  if (value)
  {
    if (CFArrayGetCount((CFArrayRef)value))
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)value, 0);
      theArray = 0;
      CFDictionaryGetValueIfPresent(ValueAtIndex, *(const void **)gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryImages, (const void **)&theArray);
      if (theArray)
      {
        if (CFArrayGetCount(theArray))
        {
          v9 = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, 0);
          memset(v20, 0, sizeof(v20));
          IIODictionary::IIODictionary((IIODictionary *)v20, v9);
          ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v20, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryTypeURN);
          v11 = IIODictionary::getUint32ForKey((IIODictionary *)v20, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryType);
          *((_DWORD *)this + 7) = v11;
          if (v11 == 3)
          {
            if (!ObjectForKey)
            {
              _cg_jpeg_mem_term("HEIFAuxImage", 1062, "*** ERROR: 'kCMPhotoDecompressionContainerDescription_AuxiliaryTypeURN' is NULL - for 'kCMPhotoAuxiliaryImageType_Alpha'\n");
              ObjectForKey = *(const __CFDictionary **)gIIO_kCMPhotoAuxiliaryImageTypeURN_MIAF_Alpha;
            }
            v12 = IIODictionary::getUint32ForKey((IIODictionary *)v23, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_AlphaPremultiplication);
            if (v12)
              v13 = v12 == 1;
            else
              v13 = 3;
            *((_DWORD *)this + 9) = v13;
            v14 = IIO_AlphaInfoString(v13);
            _cg_jpeg_mem_term("HEIFAuxImage", 1072, "    HEIFAuxImage: alpha: %s\n", v14);
          }
          *v7 = IIODictionary::getUint32ForKeyGroup((IIODictionary *)v20, CFSTR("Width"), *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_Dimensions);
          *((_DWORD *)this + 3) = IIODictionary::getUint32ForKeyGroup((IIODictionary *)v20, CFSTR("Height"), *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_Dimensions);
          *((_DWORD *)this + 4) = IIODictionary::getUint32ForKey((IIODictionary *)v20, CFSTR("Orientation"));
          *((_DWORD *)this + 10) = IIODictionary::getUint32ForKey((IIODictionary *)v20, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryNativePixelFormat);
          IIODictionary::~IIODictionary((IIODictionary *)v20);
          if (ObjectForKey)
          {
LABEL_25:
            v19 = CFGetTypeID(ObjectForKey);
            if (v19 == CFStringGetTypeID())
              *((_QWORD *)this + 7) = CFRetain(ObjectForKey);
          }
        }
      }
    }
  }
LABEL_27:
  *((_DWORD *)this + 5) = IIODictionary::getUint32ForKey((IIODictionary *)v23, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_DataLength);
  *((_DWORD *)this + 6) = IIODictionary::getUint32ForKey((IIODictionary *)v23, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_DataOffset);
  IIODictionary::~IIODictionary((IIODictionary *)v23);
}

void sub_187E986C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

IIO_Reader *IIO_ReaderHandler::typeForData(IIO_Reader ***a1, CFDataRef theData, const __CFString *a3, unsigned int a4, _BYTE *a5)
{
  const UInt8 *BytePtr;
  CFIndex Length;
  IIO_Reader *result;

  if (theData)
  {
    if (a5)
      *a5 = 1;
    BytePtr = CFDataGetBytePtr(theData);
    Length = CFDataGetLength(theData);
    result = IIO_ReaderHandler::typeForBytes(a1, (uint64_t)BytePtr, Length, a3, a4);
    if (a5)
    {
      if (result)
        *a5 = 0;
    }
  }
  else
  {
    LogError("typeForData", 747, "*** ERROR: data parameter is nil\n");
    return 0;
  }
  return result;
}

IIO_Reader *IIO_ReaderHandler::typeForBytes(IIO_Reader ***a1, uint64_t a2, unint64_t a3, const __CFString *a4, unsigned int a5)
{
  IIO_Reader *result;
  int v6;

  v6 = 0;
  result = IIO_ReaderHandler::readerForBytesImp(a1, a2, a3, a4, a3, a5, 0, &v6);
  if (result)
    return (IIO_Reader *)IIO_Reader::utType(result);
  return result;
}

void IIOImageDestination::IIOImageDestination(IIOImageDestination *this, const __CFURL *a2, IIO_Writer *a3, const __CFString *a4, uint64_t a5, IIODictionary *a6)
{
  const __CFURL *v11;

  *(_QWORD *)this = &off_1E1BB1BB0;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  IIOImageDestination::setup(this, 3);
  IIODictionary::getBoolForKey(a6, CFSTR("kCGImageDestinationShouldHideExtension"));
  v11 = CGImageWriteSessionCreateWithURL(a2);
  *((_QWORD *)this + 2) = v11;
  if (v11)
  {
    *((_QWORD *)this + 3) = CGImageSourceGetSource((uint64_t)v11);
    *((_QWORD *)this + 8) = a3;
    *((_QWORD *)this + 9) = IIO_Writer::utType(a3);
    *((_QWORD *)this + 5) = a5;
    IIOImageDestination::setProperties(this, (const __CFDictionary **)a6);
  }
  else
  {
    *((_DWORD *)this + 57) = -1;
  }
}

void sub_187E9893C(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  void **v2;
  void *v4;
  void *v5;

  v4 = (void *)v1[16];
  if (v4)
  {
    v1[17] = v4;
    operator delete(v4);
  }
  v5 = *v2;
  if (*v2)
  {
    v1[14] = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

CGImageDestinationRef CGImageDestinationCreateWithData(CFMutableDataRef data, CFStringRef type, size_t count, CFDictionaryRef options)
{
  CFTypeID v8;
  CFTypeID v9;
  CFTypeID v10;
  unsigned int v11;
  IIO_WriterHandler *v12;
  IIO_WriterHandler *WriterHandler;
  IIODictionary *v14;
  IIO_Reader *WriterForType;
  uint64_t v16;
  const __CFString *v17;
  CGImageDestination *v18;
  IIO_Reader *v20;
  char buffer[16];
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  kdebug_trace();
  IIOInitDebugFlags();
  if (!data)
  {
    LogError("CGImageDestinationCreateWithData", 4867, "*** ERROR: CGImageDestinationCreateWithData: data is nil\n");
    goto LABEL_17;
  }
  if (!type)
  {
    LogError("CGImageDestinationCreateWithData", 4868, "*** ERROR: CGImageDestinationCreateWithData: type is nil\n");
    goto LABEL_17;
  }
  if (!count)
    LogError("CGImageDestinationCreateWithData", 4870, "*** ERROR: CGImageDestinationCreateWithData: invalid capacity (%zu)\n", 0);
  v8 = CFGetTypeID(data);
  if (v8 != CFDataGetTypeID())
  {
    LogError("CGImageDestinationCreateWithData", 4871, "*** ERROR: CGImageDestinationCreateWithData: data is not a CFMutableDataRef\n");
    goto LABEL_17;
  }
  v9 = CFGetTypeID(type);
  if (v9 != CFStringGetTypeID())
  {
    LogError("CGImageDestinationCreateWithData", 4872, "*** ERROR: CGImageDestinationCreateWithData: type is not a CFStringRef\n");
    goto LABEL_17;
  }
  if (options)
  {
    v10 = CFGetTypeID(options);
    if (v10 != CFDictionaryGetTypeID())
    {
      LogError("CGImageDestinationCreateWithData", 4875, "*** ERROR: CGImageDestinationCreateWithData: options parameter is not a CFDictionaryRef - ignoring\n");
      options = 0;
    }
  }
  if ((gIIODebugFlags & 0x3000) != 0)
  {
    v23 = 0u;
    v24 = 0u;
    *(_OWORD *)buffer = 0u;
    v22 = 0u;
    CFStringGetCString(type, buffer, 64, 0x600u);
    v11 = (gIIODebugFlags >> 12) & 3;
    if (v11)
      ImageIODebugOptions(v11, "A", "CGImageDestinationCreateWithData", 0, buffer, -1, options);
  }
  memset(buffer, 0, sizeof(buffer));
  *(_QWORD *)&v22 = 0;
  v12 = IIODictionary::IIODictionary((IIODictionary *)buffer, options);
  WriterHandler = (IIO_WriterHandler *)IIO_WriterHandler::GetWriterHandler(v12);
  WriterForType = IIO_WriterHandler::findWriterForType(WriterHandler, type, (const __CFString *)count, (IIODictionary *)buffer, v14);
  if (!WriterForType)
    goto LABEL_16;
  v16 = operator new();
  IIOImageDestination::IIOImageDestination((IIOImageDestination *)v16, data, WriterForType, v17, count, (const __CFDictionary **)buffer);
  if (*(_DWORD *)(v16 + 228))
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v16 + 8))(v16);
LABEL_16:
    IIODictionary::~IIODictionary((IIODictionary *)buffer);
    LogError("CGImageDestinationCreateWithData", 4891, "*** ERROR: CGImageDestinationCreateWithData: failed to create 'CGImageDestinationRef'\n");
    goto LABEL_17;
  }
  IIODictionary::~IIODictionary((IIODictionary *)buffer);
  v18 = (CGImageDestination *)CGImageDestinationRefCreateWith_ImageDestination((IIOImageDestination *)v16);
  v20 = *(IIO_Reader **)(v16 + 64);
  if (v20)
  {
    IIO_Reader::osType(v20);
    if (v18)
      goto LABEL_20;
  }
  else if (v18)
  {
    goto LABEL_20;
  }
  LogError("CGImageDestinationCreateWithData", 4888, "*** ERROR: CGImageDestinationCreateWithData: failed to create 'CGImageDestinationRef' object\n");
LABEL_17:
  if ((gIIODebugFlags & 0x800000000000) != 0)
    ImageIOLog("∆∆∆ ISSUE: %s:%d:  %s\n", "CGImageDestinationCreateWithData", 4894, "could not create CGImageDestinationRef");
  kdebug_trace();
  v18 = 0;
LABEL_20:
  kdebug_trace();
  return v18;
}

void sub_187E98CC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v5;
  va_list va;

  va_start(va, a5);
  MEMORY[0x18D761C30](v5, 0x10E1C40255C1624);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

CFArrayRef CGImageDestinationCopyTypeIdentifiers(void)
{
  IIO_WriterHandler *v0;
  IIO_WriterHandler *WriterHandler;
  __CFArray *v2;

  kdebug_trace();
  IIOInitDebugFlags();
  v0 = (IIO_WriterHandler *)((gIIODebugFlags >> 12) & 3);
  if ((_DWORD)v0)
    ImageIODebugOptions((int)v0, "A", "CGImageDestinationCopyTypeIdentifiers", 0, 0, -1, 0);
  WriterHandler = (IIO_WriterHandler *)IIO_WriterHandler::GetWriterHandler(v0);
  v2 = IIO_WriterHandler::copyTypeIdentifiers(WriterHandler);
  kdebug_trace();
  return v2;
}

uint64_t IIO_WriterHandler::GetWriterHandler(IIO_WriterHandler *this)
{
  if (IIO_WriterHandler::GetWriterHandler(void)::writerHandlerCreate != -1)
    dispatch_once(&IIO_WriterHandler::GetWriterHandler(void)::writerHandlerCreate, &__block_literal_global_14);
  return IIO_WriterHandler::GetWriterHandler(void)::gIIO_WriterHandler;
}

IIO_Writer *IIO_WriterHandler::getWriterForType(IIO_WriterHandler *this, const __CFString *a2, const __CFString *a3)
{
  IIO_Writer **v3;
  const __CFString *v6;

  v3 = (IIO_Writer **)*((_QWORD *)this + 1);
  if (v3 == *((IIO_Writer ***)this + 2))
    return 0;
  while (1)
  {
    v6 = (const __CFString *)IIO_Writer::utType(*v3);
    if (CFStringCompare(v6, a2, 0) == kCFCompareEqualTo)
      break;
    if (++v3 == *((IIO_Writer ***)this + 2))
      return 0;
  }
  return *v3;
}

__CFArray *IIO_WriterHandler::copyTypeIdentifiers(IIO_WriterHandler *this)
{
  __CFArray *Mutable;
  IIO_Writer **i;
  const void *v4;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  for (i = (IIO_Writer **)*((_QWORD *)this + 1); i != *((IIO_Writer ***)this + 2); ++i)
  {
    if (IIO_Writer::addToTypeIdentifiers(*i))
    {
      v4 = (const void *)IIO_Writer::utType(*i);
      CFArrayAppendValue(Mutable, v4);
    }
  }
  return Mutable;
}

uint64_t IIO_Writer::utType(IIO_Writer *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 2);
  if (!result)
    return **((_QWORD **)this + 1);
  return result;
}

uint64_t IIO_Writer::addToTypeIdentifiers(IIO_Writer *this)
{
  return *((unsigned __int8 *)this + 44);
}

uint64_t CGImageDestinationRefCreateWith_ImageDestination(IIOImageDestination *a1)
{
  uint64_t result;
  unint64_t v3;

  if (CGImageDestinationGetTypeID::once != -1)
    dispatch_once(&CGImageDestinationGetTypeID::once, &__block_literal_global_24);
  result = _CFRuntimeCreateInstance();
  *(_DWORD *)(result + 16) = 1;
  do
    v3 = __ldxr(&gIDRCount);
  while (__stxr(v3 + 1, &gIDRCount));
  *(_QWORD *)(result + 24) = a1;
  *((_QWORD *)a1 + 1) = result;
  return result;
}

uint64_t PNGWritePlugin::writeEpilogue(PNGWritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3)
{
  void (**v4)(void);
  uint64_t *v5;
  uint64_t v6;
  void **v7;
  uint64_t v8;
  void **v9;

  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("    writeEpilogue\n", a2, a3);
  v5 = (uint64_t *)((char *)this + 40);
  v4 = (void (**)(void))*((_QWORD *)this + 5);
  if (v4)
  {
    v8 = *((_QWORD *)this + 6);
    v7 = (void **)((char *)this + 48);
    v6 = v8;
    if (v8)
    {
      _cg_png_write_end(v4, v6);
      if (*v7)
        v9 = v7;
      else
        v9 = 0;
      _cg_png_destroy_write_struct(v5, v9);
      *v5 = 0;
      v5[1] = 0;
    }
  }
  return 0;
}

void (**png_write_IEND(uint64_t a1))(void)
{
  void (**result)(void);

  result = _cg_png_write_complete_chunk((void (**)(void))a1, 1229278788, 0, 0);
  *(_DWORD *)(a1 + 76) |= 0x10u;
  return result;
}

void (**_cg_png_write_end(void (**result)(void), uint64_t a2))(void)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  const char *v8;

  if (!result)
    return result;
  v2 = (uint64_t)result;
  if ((*((_BYTE *)result + 76) & 4) == 0)
  {
    v8 = "No IDATs written into file";
    goto LABEL_31;
  }
  if (*((_BYTE *)result + 391) == 3 && *((_DWORD *)result + 95) >= (int)*((unsigned __int16 *)result + 188))
    png_benign_error((uint64_t)result, "Wrote palette index exceeding num_palette");
  if (*(_DWORD *)(v2 + 812) != *(_DWORD *)(v2 + 808))
  {
    v8 = "Not enough frames written";
LABEL_31:
    _cg_png_error((void (**)(void))v2, v8);
  }
  if (a2)
  {
    if ((*(_BYTE *)(a2 + 9) & 2) != 0 && (*(_BYTE *)(v2 + 77) & 2) == 0)
      png_write_tIME((void (**)(void))v2, (unsigned __int16 *)(a2 + 168));
    if (*(int *)(a2 + 148) >= 1)
    {
      v4 = 0;
      v5 = 0;
      v6 = *(_QWORD *)(a2 + 160);
      do
      {
        v7 = *(_DWORD *)(v6 + v4);
        if (v7 < 1)
        {
          if ((v7 & 0x80000000) == 0)
          {
            png_write_zTXt(v2, *(unsigned __int8 **)(v6 + v4 + 8), *(char **)(v6 + v4 + 16), 0);
            v6 = *(_QWORD *)(a2 + 160);
LABEL_18:
            *(_DWORD *)(v6 + v4) = -2;
            goto LABEL_19;
          }
          if (v7 != -1)
            goto LABEL_19;
          png_write_tEXt((void (**)(void))v2, *(unsigned __int8 **)(v6 + v4 + 8), *(char **)(v6 + v4 + 16));
          v6 = *(_QWORD *)(a2 + 160);
        }
        else
        {
          png_write_iTXt(v2, v7, *(unsigned __int8 **)(v6 + v4 + 8), *(char **)(v6 + v4 + 40), *(char **)(v6 + v4 + 48), *(char **)(v6 + v4 + 16));
          v6 = *(_QWORD *)(a2 + 160);
          if (*(_DWORD *)(v6 + v4) != -1)
            goto LABEL_18;
        }
        *(_DWORD *)(v6 + v4) = -3;
LABEL_19:
        ++v5;
        v4 += 56;
      }
      while (v5 < *(int *)(a2 + 148));
    }
    if ((*(_BYTE *)(a2 + 10) & 1) != 0 && (*(_BYTE *)(v2 + 77) & 0x40) == 0)
      png_write_eXIf(v2, *(Bytef **)(a2 + 240), *(_DWORD *)(a2 + 236));
    write_unknown_chunks(v2, a2, 8u);
  }
  *(_DWORD *)(v2 + 76) |= 8u;
  return png_write_IEND(v2);
}

BOOL CGImageDestinationFinalize(CGImageDestinationRef idst)
{
  unsigned int v2;
  CFTypeID v3;
  uint64_t v4;
  int v5;
  IIO_Reader *v6;
  unint64_t v8;

  kdebug_trace();
  v2 = (gIIODebugFlags >> 12) & 3;
  if (v2)
    ImageIODebugOptions(v2, "A", "CGImageDestinationFinalize", idst, 0, -1, 0);
  v8 = 0;
  if (!idst)
  {
    LogError("CGImageDestinationFinalize", 5311, "*** ERROR: CGImageDestinationFinalize: destination is nil\n");
    goto LABEL_13;
  }
  v3 = CFGetTypeID(idst);
  if (CGImageDestinationGetTypeID::once != -1)
    dispatch_once(&CGImageDestinationGetTypeID::once, &__block_literal_global_24);
  if (v3 != CGImageDestinationGetTypeID::id)
  {
    LogError("CGImageDestinationFinalize", 5312, "*** ERROR: CGImageDestinationFinalize: destination is not a CGImageDestinationRef\n");
    goto LABEL_13;
  }
  v4 = *((_QWORD *)idst + 3);
  if (!v4)
  {
LABEL_13:
    v5 = -50;
    goto LABEL_14;
  }
  v5 = IIOImageDestination::finalizeDestination(*((IIOImageDestination **)idst + 3), (CFIndex *)&v8);
  v6 = *(IIO_Reader **)(v4 + 64);
  if (v6)
    IIO_Reader::osType(v6);
LABEL_14:
  if ((gIIODebugFlags & 0x800000000000) != 0 && v5)
  {
    ImageIOLog("∆∆∆ ISSUE: %s:%d:  %s\n", "CGImageDestinationFinalize", 5324, "finalize failed");
  }
  else if (!v5)
  {
    goto LABEL_19;
  }
  kdebug_trace();
LABEL_19:
  kdebug_trace();
  return v5 == 0;
}

uint64_t IIOGeneric_Writer::write(IIOGeneric_Writer *this, void *a2, void *a3)
{
  uint64_t (*v3)(void *, void *, _QWORD, _QWORD);

  v3 = (uint64_t (*)(void *, void *, _QWORD, _QWORD))*((_QWORD *)this + 6);
  if (v3)
    return v3(a2, a3, 0, 0);
  else
    return 4294967246;
}

uint64_t PNGWritePlugin::WriteProc(PNGWritePlugin *this, IIOImageDestination *a2, void *a3, void *a4, void *a5)
{
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  _OWORD v9[2];
  __int128 v10;
  __int128 v11;
  _OWORD v12[2];
  __int128 v13;
  __int128 v14;

  v13 = 0u;
  v14 = 0u;
  memset(v12, 0, sizeof(v12));
  v10 = 0u;
  v11 = 0u;
  memset(v9, 0, sizeof(v9));
  IIOWritePlugin::IIOWritePlugin((IIOWritePlugin *)v9, this, a2, 0x15u);
  memset(v12, 0, 21);
  *(_DWORD *)((char *)&v14 + 9) = 1;
  v11 = 0uLL;
  *(_QWORD *)&v9[0] = &off_1E1BAFBE8;
  *((_QWORD *)&v10 + 1) = 0;
  *((_QWORD *)&v13 + 1) = 0;
  *(_QWORD *)&v14 = 0;
  v5 = PNGWritePlugin::writeAll((PNGWritePlugin *)v9);
  PNGWritePlugin::~PNGWritePlugin((PNGWritePlugin *)v9, v6, v7);
  return v5;
}

void sub_187E9945C(void *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  PNGWritePlugin::~PNGWritePlugin((PNGWritePlugin *)&a9, a2, a3);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187E99448);
}

uint64_t PNGWritePlugin::writePrologue(PNGWritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3)
{
  unsigned int AlphaInfo;
  _BOOL4 v7;
  _BOOL4 v8;
  int v9;
  unsigned int v10;
  int v11;
  uint64_t v12;
  CGColorSpace *SourceGeomColorSpace;
  uint64_t result;
  size_t NumberOfComponents;
  CGColorSpaceModel Model;
  int Type;
  BOOL v18;
  int v19;
  CGColorSpace *BaseColorSpace;
  size_t v21;
  size_t ColorTableCount;
  uint8_t *v23;
  size_t v24;
  unsigned int appleflags;
  unsigned int v26;
  unsigned __int8 v27;
  uint64_t v28;
  unsigned __int8 v30;
  int v31;
  _QWORD *v32;
  uint64_t v33;
  const __CFDictionary *ObjectForKeyGroup;
  const __CFData *v35;
  const UInt8 *BytePtr;
  unsigned int Length;
  unsigned __int8 v38;
  unsigned int v39;
  float FloatForKey;
  float v41;
  const __CFNumber *Property;
  double v43;
  int v44;
  float FloatForKeyGroup;
  double v46;
  const __CFDictionary *v47;
  double DoubleAtIndex;
  double v49;
  double v50;
  double v51;
  double v52;
  double v53;
  double v54;
  double v55;
  char *ExifBufferFromPropertiesJPEG;
  char *v57;
  const __CFDictionary *ObjectForKey;
  uint64_t v59;
  const void *v60;
  const __CFData *XMPData;
  const UInt8 *v62;
  const UInt8 *v63;
  CFIndex v64;
  size_t v65;
  void *v66;
  void *v67;
  char v68;
  int CICPInfo;
  CGImage *Ref;
  CGColorRenderingIntent RenderingIntent;
  ColorSyncProfileRef v72;
  ColorSyncProfileRef v73;
  const ColorSyncProfile *SanitizedCopy;
  BOOL v75;
  unsigned int *v76;
  CFIndex v77;
  unint64_t v78;
  CFStringRef Name;
  IIOString *v80;
  IIOString *v81;
  CGImage *v82;
  __int32 v83;
  unsigned int v84;
  _QWORD *v85;
  uint64_t v86;
  char *v87;
  unsigned int Uint32ForKeyGroup;
  uint64_t v89;
  int v90;
  int v91;
  unsigned int v92;
  unsigned int v93;
  _BOOL4 v94;
  uint64_t v95;
  int v96;
  unsigned int v97;
  BOOL v98;
  int v99;
  int v100;
  CFErrorRef error;
  char v102;
  unint64_t v103[2];
  __int128 v104;
  __int128 v105;
  uint64_t v106;
  double valuePtr;
  CFDataRef data;

  data = 0;
  AlphaInfo = IIOImagePixelDataProvider::getAlphaInfo(a2);
  v92 = AlphaInfo;
  if (AlphaInfo)
  {
    if (AlphaInfo < 5)
    {
      v7 = 1;
      v8 = 1;
      goto LABEL_7;
    }
    v9 = *((unsigned __int8 *)this + 121);
    v7 = 1;
  }
  else
  {
    v9 = *((unsigned __int8 *)this + 121);
    v7 = *((_BYTE *)this + 121) == 0;
  }
  v8 = v9 == 0;
LABEL_7:
  v94 = v8;
  valuePtr = 0.0;
  IIOImageSource::imageReadRef(a2);
  CGImageGetImageProvider();
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("    writePrologue\n");
  v10 = *((_DWORD *)this + 18);
  v11 = *((_DWORD *)this + 19);
  v95 = IIOImageSource::count(a2);
  v97 = IIO_Reader::testHeaderSize(a2);
  v12 = IIOImagePlus::sourceImageProvider(a2);
  SourceGeomColorSpace = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(a2);
  result = 4294967246;
  if (v12 && SourceGeomColorSpace)
  {
    v93 = v10;
    NumberOfComponents = CGColorSpaceGetNumberOfComponents(SourceGeomColorSpace);
    Model = CGColorSpaceGetModel(SourceGeomColorSpace);
    Type = CGColorSpaceGetType();
    if (*((_BYTE *)this + 124))
      v18 = Type == 7;
    else
      v18 = 0;
    v19 = !v18;
    v99 = v11;
    if (v18)
    {
      BaseColorSpace = CGColorSpaceGetBaseColorSpace(SourceGeomColorSpace);
      v21 = CGColorSpaceGetNumberOfComponents(BaseColorSpace);
      ColorTableCount = CGColorSpaceGetColorTableCount(SourceGeomColorSpace);
      *((_QWORD *)this + 13) = ColorTableCount;
      v23 = (uint8_t *)malloc_type_malloc(ColorTableCount * v21, 0x100004077774924uLL);
      *((_QWORD *)this + 14) = v23;
      CGColorSpaceGetColorTable(SourceGeomColorSpace, v23);
      SourceGeomColorSpace = CGColorSpaceGetBaseColorSpace(SourceGeomColorSpace);
      CGColorSpaceGetType();
      Model = CGColorSpaceGetModel(SourceGeomColorSpace);
    }
    v24 = NumberOfComponents + v7;
    appleflags = _cg_png_get_appleflags((uint64_t)a2);
    v26 = _cg_GifLastError((uint64_t)a2);
    if (v24 - 5 >= 0xFFFFFFFFFFFFFFFCLL)
    {
      v27 = v26;
      v28 = appleflags;
      if (appleflags == 24 && *((_BYTE *)this + 121) == 0)
        v28 = 32;
      if (v24 * v26 == v28)
      {
        if (v99)
        {
          if (((v19 | !v7) & 1) != 0)
            goto LABEL_29;
          goto LABEL_43;
        }
        v32 = _cg_png_create_write_struct("1.6.43", 0, (uint64_t)handle_write_error, (uint64_t)handle_write_warning);
        *((_QWORD *)this + 5) = v32;
        if (v32)
        {
          _cg_png_set_compression_level((uint64_t)v32, 1);
          _cg_png_create_info_struct(*((_QWORD *)this + 5));
          *((_QWORD *)this + 6) = v33;
          if (v33)
          {
            _cg_png_set_option(*((_QWORD *)this + 5), 2u, 3);
            _cg_png_set_benign_errors(*((_QWORD *)this + 5), 1);
            if (((v19 | !v7) & 1) != 0)
            {
              if (*((_BYTE *)this + 124))
              {
                _cg_png_set_PLTE(*((void (***)(void))this + 5), *((_QWORD *)this + 6), *((const void **)this + 14), *((_DWORD *)this + 26));
                ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup(a3, CFSTR("kCGImagePropertyPNGTransparency"), CFSTR("{PNG}"));
                if (ObjectForKeyGroup)
                {
                  v35 = ObjectForKeyGroup;
                  BytePtr = CFDataGetBytePtr(ObjectForKeyGroup);
                  Length = CFDataGetLength(v35);
                  if (*((_QWORD *)this + 13) == Length)
                    _cg_png_set_tRNS(*((_QWORD *)this + 5), *((_QWORD *)this + 6), BytePtr, Length, 0);
                }
                v31 = 0;
                v91 = 0;
                v30 = 3;
LABEL_49:
                if (IIODictionary::containsKeyGroup(a3, CFSTR("InterlaceType"), CFSTR("{PNG}")))
                  v38 = IIODictionary::getUint32ForKeyGroup(a3, CFSTR("InterlaceType"), CFSTR("{PNG}")) != 0;
                else
                  v38 = 0;
                v39 = v97;
                _cg_png_set_IHDR(*((_QWORD *)this + 5), *((_QWORD *)this + 6), v95, v97, v27, v30, v38, 0, 0);
                if (IIODictionary::containsKey(a3, CFSTR("DPIWidth"))
                  && IIODictionary::containsKey(a3, CFSTR("DPIHeight")))
                {
                  FloatForKey = IIODictionary::getFloatForKey(a3, CFSTR("DPIWidth"));
                  v41 = IIODictionary::getFloatForKey(a3, CFSTR("DPIHeight"));
                  _cg_png_set_pHYs(*((_QWORD *)this + 5), *((_QWORD *)this + 6), vcvtms_u32_f32((float)(FloatForKey / 0.0254) + 0.5), vcvtms_u32_f32((float)(v41 / 0.0254) + 0.5), 1);
                }
                Property = (const __CFNumber *)CGImageProviderGetProperty();
                if (Property)
                  CFNumberGetValue(Property, kCFNumberDoubleType, &valuePtr);
                v43 = 0.0;
                v44 = v99;
                if (IIODictionary::containsKeyGroup(a3, CFSTR("Gamma"), CFSTR("{PNG}")))
                {
                  FloatForKeyGroup = IIODictionary::getFloatForKeyGroup(a3, CFSTR("Gamma"), CFSTR("{PNG}"));
                  if (FloatForKeyGroup > 0.0)
                  {
                    v46 = FloatForKeyGroup;
                    if (FloatForKeyGroup <= 21474.83)
                    {
                      if (FloatForKeyGroup != 0.0)
                      {
                        _cg_png_set_gAMA(*((void (***)(void))this + 5), *((_QWORD *)this + 6), FloatForKeyGroup);
                        v98 = valuePtr == v46;
                        goto LABEL_67;
                      }
                      v43 = FloatForKeyGroup;
                    }
                  }
                }
                if (valuePtr == 0.0)
                {
                  v98 = 0;
                }
                else
                {
                  _cg_png_set_gAMA(*((void (***)(void))this + 5), *((_QWORD *)this + 6), valuePtr);
                  v98 = 1;
                }
                v46 = v43;
LABEL_67:
                if (IIODictionary::containsKeyGroup(a3, CFSTR("Chromaticities"), CFSTR("{PNG}")))
                {
                  v47 = IIODictionary::getObjectForKeyGroup(a3, CFSTR("Chromaticities"), CFSTR("{PNG}"));
                  v103[0] = 0;
                  v103[1] = 0;
                  *(_QWORD *)&v104 = 0;
                  IIOArray::IIOArray((IIOArray *)v103, v47);
                  if (IIOArray::getCount((IIOArray *)v103) >= 8)
                  {
                    DoubleAtIndex = IIOArray::getDoubleAtIndex((IIOArray *)v103, 0);
                    v49 = IIOArray::getDoubleAtIndex((IIOArray *)v103, 1);
                    v50 = IIOArray::getDoubleAtIndex((IIOArray *)v103, 2);
                    v51 = IIOArray::getDoubleAtIndex((IIOArray *)v103, 3);
                    v52 = IIOArray::getDoubleAtIndex((IIOArray *)v103, 4);
                    v53 = IIOArray::getDoubleAtIndex((IIOArray *)v103, 5);
                    v54 = IIOArray::getDoubleAtIndex((IIOArray *)v103, 6);
                    v55 = IIOArray::getDoubleAtIndex((IIOArray *)v103, 7);
                    _cg_png_set_cHRM(*((void (***)(void))this + 5), *((_QWORD *)this + 6), DoubleAtIndex, v49, v50, v51, v52, v53, v54, v55);
                  }
                  IIOArray::~IIOArray((IIOArray *)v103);
                }
                if (v99)
                  goto LABEL_115;
                v103[0] = 0;
                ExifBufferFromPropertiesJPEG = CreateExifBufferFromPropertiesJPEG(a3, v95, v39, SourceGeomColorSpace, 0, CFSTR("public.jpeg"), v103);
                if (ExifBufferFromPropertiesJPEG)
                {
                  v57 = ExifBufferFromPropertiesJPEG;
                  if (v103[0] >= 7)
                    _cg_png_set_eXIf_1(*((_QWORD *)this + 5), *((_QWORD *)this + 6), (LODWORD(v103[0]) - 6), ExifBufferFromPropertiesJPEG + 6);
                  free(v57);
                }
                ObjectForKey = IIODictionary::getObjectForKey(a3, CFSTR("{MetaData}"));
                v59 = CGImageMetadataCreateFromLegacyProps(a3);
                v60 = (const void *)v59;
                if (ObjectForKey)
                {
                  if (v59)
                  {
                    CGImageMetadataMerge((uint64_t)ObjectForKey, v59, 0);
                    CFRelease(v60);
                  }
                  CFRetain(ObjectForKey);
                }
                else
                {
                  ObjectForKey = (const __CFDictionary *)v59;
                  if (!v59)
                    goto LABEL_87;
                }
                XMPData = CGImageMetadataCreateXMPData(ObjectForKey, 0);
                CFRelease(ObjectForKey);
                if (XMPData)
                {
                  v96 = v31;
                  v106 = 0;
                  v104 = 0u;
                  v105 = 0u;
                  *(_OWORD *)v103 = 0u;
                  v62 = CFDataGetBytePtr(XMPData);
                  if (v62)
                  {
                    v63 = v62;
                    v64 = CFDataGetLength(XMPData);
                    if (v64)
                    {
                      v65 = v64;
                      v66 = malloc_type_calloc(v64 + 1, 1uLL, 0xDBD2F272uLL);
                      if (v66)
                      {
                        v67 = v66;
                        memcpy(v66, v63, v65);
                        LODWORD(v103[0]) = 1;
                        v103[1] = (unint64_t)"XML:com.adobe.xmp";
                        v104 = (unint64_t)v67;
                        v105 = v65;
                        v106 = 0;
                        _cg_png_set_text(*((void (***)(void))this + 5), *((_QWORD *)this + 6), (uint64_t)v103, 1);
                        free(v67);
                      }
                    }
                  }
                  CFRelease(XMPData);
                  v44 = v99;
                  v31 = v96;
                }
LABEL_87:
                v68 = v98;
                if (*((_BYTE *)this + 124))
                  v68 = 1;
                if ((v68 & 1) == 0)
                {
                  v102 = 0;
                  error = 0;
                  v100 = 0;
                  CICPInfo = CGColorSpaceGetCICPInfo();
                  Ref = (CGImage *)IIOImageSource::imageReadRef(a2);
                  RenderingIntent = CGImageGetRenderingIntent(Ref);
                  data = CGColorSpaceCopyData(SourceGeomColorSpace, RenderingIntent);
                  if (data)
                  {
                    v72 = ColorSyncProfileCreate(data, &error);
                    if (v72)
                    {
                      v73 = v72;
                      SanitizedCopy = (const ColorSyncProfile *)ColorSyncProfileCreateSanitizedCopy();
                      CFRelease(v73);
                    }
                    else
                    {
                      SanitizedCopy = 0;
                    }
                    CFRelease(data);
                    data = 0;
                    v75 = SanitizedCopy == 0;
                    if (SanitizedCopy && !v102)
                    {
                      data = ColorSyncProfileCopyData(SanitizedCopy, &error);
                      if (data)
                      {
                        v76 = (unsigned int *)CFDataGetBytePtr(data);
                        v77 = CFDataGetLength(data);
                        if (v76)
                        {
                          v78 = v77;
                          if (v77)
                          {
                            Name = CGColorSpaceGetName(SourceGeomColorSpace);
                            v80 = (IIOString *)operator new();
                            v81 = v80;
                            if (Name)
                              IIOString::IIOString(v80, Name);
                            else
                              IIOString::IIOString(v80, "ICC Profile");
                            v85 = (_QWORD *)*((_QWORD *)this + 5);
                            v86 = *((_QWORD *)this + 6);
                            v87 = (char *)IIOString::utf8String(v81);
                            _cg_png_set_iCCP(v85, v86, v87, 0, v76, v78);
                            (*(void (**)(IIOString *))(*(_QWORD *)v81 + 8))(v81);
                            v44 = v99;
                            if (CICPInfo)
                            {
                              *((_QWORD *)&v104 + 1) = 1;
                              v103[0] = 1346586979;
                              v103[1] = (unint64_t)&v100;
                              *(_QWORD *)&v104 = 4;
                              _cg_png_set_keep_unknown_chunks(*((_QWORD *)this + 5), 3, 0, 0);
                              _cg_png_set_unknown_chunks(*((void (***)(void))this + 5), *((_QWORD *)this + 6), (uint64_t)v103, 1);
                            }
                          }
                        }
                        CFRelease(data);
                        data = 0;
                      }
LABEL_114:
                      CFRelease(SanitizedCopy);
                      goto LABEL_115;
                    }
                  }
                  else
                  {
                    SanitizedCopy = 0;
                    v75 = 1;
                  }
                  if ((v31 | v91) == 1 && v46 == 0.0)
                  {
                    v82 = (CGImage *)IIOImageSource::imageReadRef(a2);
                    v83 = CGImageGetRenderingIntent(v82) - 1;
                    if (v83 > 3)
                      v84 = 0;
                    else
                      v84 = dword_188211BA0[v83];
                    _cg_png_set_sRGB(*((_QWORD *)this + 5), *((_QWORD *)this + 6), v84);
                  }
                  if (!v75)
                    goto LABEL_114;
                }
LABEL_115:
                if (IIODictionary::containsKeyGroup(a3, CFSTR("kCGImagePropertyPNGCompressionFilter"), CFSTR("{PNG}")))
                {
                  Uint32ForKeyGroup = IIODictionary::getUint32ForKeyGroup(a3, CFSTR("kCGImagePropertyPNGCompressionFilter"), CFSTR("{PNG}"));
                  if (Uint32ForKeyGroup <= 0xF8)
                  {
                    _cg_png_set_filter(*((_QWORD *)this + 5), 0, Uint32ForKeyGroup);
                    _cg_png_set_compression_strategy(*((_QWORD *)this + 5), 1);
                  }
                }
                _cg_png_set_write_fn(*((_QWORD **)this + 5), *((_QWORD *)this + 2), (size_t (*)(size_t, void *, size_t))write_fn, (uint64_t (*)(uint64_t))flush_fn);
                if (v44 || v93 < 2)
                {
                  if (v44)
                    return 0;
                }
                else
                {
                  _cg_png_set_acTL(*((_QWORD *)this + 5), *((_DWORD **)this + 6), *((_DWORD *)this + 18), *((_DWORD *)this + 20));
                }
                _cg_png_write_info(*((_QWORD *)this + 5), *((_QWORD *)this + 6));
                if (!v94)
                {
                  if (v92 == 6)
                  {
                    v89 = *((_QWORD *)this + 5);
                    v90 = 0;
                    goto LABEL_127;
                  }
                  if (v92 == 5)
                  {
                    v89 = *((_QWORD *)this + 5);
                    v90 = 1;
LABEL_127:
                    _cg_png_set_filler(v89, 0, v90);
                  }
                }
                return 0;
              }
LABEL_29:
              v30 = 2;
              if (Model == kCGColorSpaceModelIndexed || Model == kCGColorSpaceModelRGB)
              {
                v31 = !v94;
                if (v94)
                  v30 = 6;
                else
                  v30 = 2;
                v91 = v94;
              }
              else if (Model)
              {
                v91 = 0;
                v31 = 1;
              }
              else
              {
                v31 = 0;
                v91 = 0;
                if (v94)
                  v30 = 4;
                else
                  v30 = 0;
              }
              goto LABEL_49;
            }
LABEL_43:
            v31 = 0;
            *((_BYTE *)this + 84) = v27;
            v91 = 1;
            *((_BYTE *)this + 122) = 1;
            v30 = 6;
            v27 = 8;
            goto LABEL_49;
          }
        }
        else
        {
          _cg_jpeg_mem_term("writePrologue", 620, "    png_create_write_struct failed -- _png_ptr is NULL\n");
        }
      }
    }
    return 4294967246;
  }
  return result;
}

void sub_187E99F74(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0xF1C40AFE2EBACLL);
  _Unwind_Resume(a1);
}

uint64_t PNGReadPlugin::Update_png_struct(uint64_t a1, _BYTE *a2, uint64_t a3, unsigned int *a4)
{
  int v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  int v20;
  uint64_t v21;
  int v22;
  int v23;

  if (a2[32])
  {
    _cg_png_set_palette_to_rgb(a3);
    if ((gIIODebugFlags & 0x20000) != 0)
    {
      v8 = *(_DWORD *)(a1 + 20);
      v9 = v8 >> 24;
      v10 = MEMORY[0x1E0C80978];
      if (v8 < 0)
      {
        v11 = __maskrune(v9, 0x40000uLL);
        v8 = *(_DWORD *)(a1 + 20);
        v9 = v8 >> 24;
      }
      else
      {
        v11 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v9 + 60) & 0x40000;
      }
      if (v11)
        v12 = v9;
      else
        v12 = 46;
      v13 = v8 << 8 >> 24;
      if (v8 << 8 < 0)
      {
        v14 = __maskrune(v13, 0x40000uLL);
        v8 = *(_DWORD *)(a1 + 20);
        v13 = v8 << 8 >> 24;
      }
      else
      {
        v14 = *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
      }
      if (v14)
        v15 = v13;
      else
        v15 = 46;
      v16 = (__int16)v8 >> 8;
      if (v8 << 16 < 0)
      {
        v17 = __maskrune(v16, 0x40000uLL);
        v8 = *(_DWORD *)(a1 + 20);
        v16 = (__int16)v8 >> 8;
      }
      else
      {
        v17 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
      }
      if (v17)
        v18 = v16;
      else
        v18 = 46;
      v19 = (char)v8;
      if ((v8 << 24) <= 0x7F000000)
      {
        v20 = *(_DWORD *)(v10 + 4 * (char)v8 + 60) & 0x40000;
      }
      else
      {
        v20 = __maskrune((char)v8, 0x40000uLL);
        v19 = *(char *)(a1 + 20);
      }
      if (v20)
        v21 = v19;
      else
        v21 = 46;
      ImageIOLog("♦️  '%c%c%c%c' %d: png_set_palette_to_rgb\n", v12, v15, v18, v21, 2552);
    }
  }
  if (!a2[19] && _cg_png_get_bit_depth(a3, (uint64_t)a4) <= 7)
    _cg_png_set_expand_gray_1_2_4_to_8(a3);
  if (a2[28])
  {
    _cg_png_set_palette_to_rgb(a3);
  }
  else if (a2[27])
  {
    _cg_png_set_add_alpha(a3, 255, 1);
    if ((gIIODebugFlags & 0x20000) != 0)
    {
      v22 = *(_DWORD *)(a1 + 20);
      if (v22 < 0)
      {
        __maskrune(v22 >> 24, 0x40000uLL);
        v22 = *(_DWORD *)(a1 + 20);
      }
      if (v22 << 8 < 0)
      {
        __maskrune(v22 << 8 >> 24, 0x40000uLL);
        v22 = *(_DWORD *)(a1 + 20);
      }
      if (v22 << 16 < 0)
      {
        __maskrune((__int16)v22 >> 8, 0x40000uLL);
        v22 = *(_DWORD *)(a1 + 20);
      }
      if ((v22 << 24) > 0x7F000000)
        __maskrune((char)v22, 0x40000uLL);
      ImageIOLog("♦️  '%c%c%c%c' %d: png_set_add_alpha: PNG_FILLER_AFTER\n");
    }
  }
  else if (a2[26])
  {
    _cg_png_set_filler(a3, 255, 0);
    if ((gIIODebugFlags & 0x20000) != 0)
    {
      v23 = *(_DWORD *)(a1 + 20);
      if (v23 < 0)
      {
        __maskrune(v23 >> 24, 0x40000uLL);
        v23 = *(_DWORD *)(a1 + 20);
      }
      if (v23 << 8 < 0)
      {
        __maskrune(v23 << 8 >> 24, 0x40000uLL);
        v23 = *(_DWORD *)(a1 + 20);
      }
      if (v23 << 16 < 0)
      {
        __maskrune((__int16)v23 >> 8, 0x40000uLL);
        v23 = *(_DWORD *)(a1 + 20);
      }
      if ((v23 << 24) > 0x7F000000)
        __maskrune((char)v23, 0x40000uLL);
      ImageIOLog("♦️  '%c%c%c%c' %d: png_set_filler: PNG_FILLER_BEFORE\n");
    }
  }
  return _cg_png_read_update_info(a3, a4);
}

uint64_t _cg_png_set_add_alpha(uint64_t result, __int16 a2, int a3)
{
  uint64_t v3;
  int v4;

  if (result)
  {
    v3 = result;
    result = _cg_png_set_filler(result, a2, a3);
    v4 = *(_DWORD *)(v3 + 88);
    if ((v4 & 0x8000) != 0)
      *(_DWORD *)(v3 + 88) = v4 | 0x1000000;
  }
  return result;
}

uint64_t _cg_png_set_filler(uint64_t result, __int16 a2, int a3)
{
  char v3;
  int v4;
  unsigned int v5;
  char *v6;

  if (!result)
    return result;
  if ((*(_BYTE *)(result + 77) & 0x80) == 0)
  {
    if (*(_BYTE *)(result + 391))
    {
      if (*(_BYTE *)(result + 391) == 2)
      {
        v3 = 4;
LABEL_9:
        *(_BYTE *)(result + 396) = v3;
        goto LABEL_10;
      }
      v6 = "png_set_filler: inappropriate color type";
    }
    else
    {
      if (*(unsigned __int8 *)(result + 392) >= 8u)
      {
        v3 = 2;
        goto LABEL_9;
      }
      v6 = "png_set_filler is invalid for low bit depth gray output";
    }
    return png_app_error(result, v6);
  }
  *(_WORD *)(result + 402) = a2;
LABEL_10:
  *(_DWORD *)(result + 88) |= 0x8000u;
  v4 = *(_DWORD *)(result + 80);
  if (a3 == 1)
    v5 = v4 | 0x80;
  else
    v5 = v4 & 0xFFFFFF7F;
  *(_DWORD *)(result + 80) = v5;
  return result;
}

uint64_t IIOImageSource::imageReadRef(IIOImageSource *this)
{
  return *((_QWORD *)this + 2);
}

uint64_t write_unknown_chunks(uint64_t result, uint64_t a2, unsigned __int8 a3)
{
  uint64_t v3;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;

  v3 = *(int *)(a2 + 312);
  if ((int)v3 > 0)
  {
    v5 = result;
    v6 = *(_QWORD *)(a2 + 304);
    v7 = v6 + 32 * v3;
    do
    {
      if ((*(_BYTE *)(v6 + 24) & a3) != 0)
      {
        result = png_handle_as_unknown(v5, (_DWORD *)v6);
        if ((_DWORD)result != 1
          && ((_DWORD)result == 3 || (*(_BYTE *)(v6 + 3) & 0x20) != 0 || !(_DWORD)result && *(_DWORD *)(v5 + 736) == 3))
        {
          v8 = *(_QWORD *)(v6 + 16);
          if (!v8)
          {
            png_warning(v5, "Writing zero-length unknown chunk");
            v8 = *(_QWORD *)(v6 + 16);
          }
          result = (uint64_t)_cg_png_write_chunk((void (**)(void))v5, (unsigned int *)v6, *(Bytef **)(v6 + 8), v8);
        }
      }
      v6 += 32;
    }
    while (v6 < v7);
  }
  return result;
}

uint64_t _cg_GifLastError(uint64_t a1)
{
  return *(unsigned int *)(a1 + 80);
}

const __CFString *IIOString::utf8String(IIOString *this)
{
  const __CFString *result;

  result = (const __CFString *)*((_QWORD *)this + 2);
  if (result)
  {
    result = (const __CFString *)CFStringGetCStringPtr(result, 0x8000100u);
    if (!result)
    {
      result = (const __CFString *)*((_QWORD *)this + 1);
      if (!result)
      {
        result = (const __CFString *)IIOString::createUTF8String(this);
        *((_QWORD *)this + 1) = result;
      }
    }
  }
  return result;
}

_QWORD *png_create_write_struct_2(_BYTE *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  _QWORD *png_struct;
  _QWORD *v8;

  png_struct = png_create_png_struct(a1, a2, a3, a4, a5, a6, a7);
  v8 = png_struct;
  if (png_struct)
  {
    *(_OWORD *)(png_struct + 27) = xmmword_188211290;
    *((_DWORD *)png_struct + 64) = 0;
    png_struct[31] = 0x80000000FLL;
    *(_OWORD *)(png_struct + 29) = xmmword_1882112A0;
    *((_DWORD *)png_struct + 20) |= 0x200000u;
    _cg_png_set_write_fn(png_struct, 0, 0, 0);
  }
  return v8;
}

uint64_t _cg_png_write_info(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t i;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;

  if (!result || !a2)
    return result;
  v3 = result;
  png_write_info_before_PLTE(result, a2);
  v4 = *(_DWORD *)(a2 + 8);
  if ((v4 & 8) != 0)
  {
    png_write_PLTE(v3, *(_QWORD *)(a2 + 24), *(unsigned __int16 *)(a2 + 32));
    v4 = *(_DWORD *)(a2 + 8);
    if ((v4 & 0x10) == 0)
      goto LABEL_6;
  }
  else
  {
    if (*(_BYTE *)(a2 + 37) == 3)
      _cg_png_error((void (**)(void))v3, "Valid palette required for paletted images");
    if ((v4 & 0x10) == 0)
    {
LABEL_6:
      if ((v4 & 0x20) == 0)
        goto LABEL_7;
      goto LABEL_27;
    }
  }
  if ((*(_BYTE *)(v3 + 90) & 8) != 0 && *(_BYTE *)(a2 + 37) == 3)
  {
    v5 = *(unsigned __int16 *)(a2 + 34) >= 0x100u ? 256 : *(unsigned __int16 *)(a2 + 34);
    if ((_DWORD)v5)
    {
      for (i = 0; i != v5; ++i)
        *(_BYTE *)(*(_QWORD *)(a2 + 184) + i) = ~*(_BYTE *)(*(_QWORD *)(a2 + 184) + i);
    }
  }
  png_write_tRNS(v3, *(Bytef **)(a2 + 184), (unsigned __int16 *)(a2 + 192), *(unsigned __int16 *)(a2 + 34), *(unsigned __int8 *)(a2 + 37));
  v4 = *(_DWORD *)(a2 + 8);
  if ((v4 & 0x20) == 0)
  {
LABEL_7:
    if ((v4 & 0x10000) == 0)
      goto LABEL_8;
    goto LABEL_28;
  }
LABEL_27:
  png_write_bKGD(v3, (unsigned __int8 *)(a2 + 202), *(unsigned __int8 *)(a2 + 37));
  v4 = *(_DWORD *)(a2 + 8);
  if ((v4 & 0x10000) == 0)
  {
LABEL_8:
    if ((v4 & 0x40) == 0)
      goto LABEL_9;
    goto LABEL_29;
  }
LABEL_28:
  png_write_eXIf(v3, *(Bytef **)(a2 + 240), *(_DWORD *)(a2 + 236));
  *(_DWORD *)(v3 + 76) |= 0x4000u;
  v4 = *(_DWORD *)(a2 + 8);
  if ((v4 & 0x40) == 0)
  {
LABEL_9:
    if ((v4 & 0x100) == 0)
      goto LABEL_10;
    goto LABEL_30;
  }
LABEL_29:
  png_write_hIST(v3, *(unsigned __int16 **)(a2 + 256), *(unsigned __int16 *)(a2 + 32));
  v4 = *(_DWORD *)(a2 + 8);
  if ((v4 & 0x100) == 0)
  {
LABEL_10:
    if ((v4 & 0x400) == 0)
      goto LABEL_11;
    goto LABEL_31;
  }
LABEL_30:
  png_write_oFFs((void (**)(void))v3, *(unsigned int *)(a2 + 212), *(unsigned int *)(a2 + 216), *(unsigned __int8 *)(a2 + 220));
  v4 = *(_DWORD *)(a2 + 8);
  if ((v4 & 0x400) == 0)
  {
LABEL_11:
    if ((v4 & 0x4000) == 0)
      goto LABEL_12;
    goto LABEL_32;
  }
LABEL_31:
  png_write_pCAL((void (**)(void))v3, *(unsigned __int8 **)(a2 + 264), *(_DWORD *)(a2 + 272), *(_DWORD *)(a2 + 276), *(unsigned __int8 *)(a2 + 296), *(unsigned __int8 *)(a2 + 297), *(const char **)(a2 + 280), *(const char ***)(a2 + 288));
  v4 = *(_DWORD *)(a2 + 8);
  if ((v4 & 0x4000) == 0)
  {
LABEL_12:
    if ((v4 & 0x80) == 0)
      goto LABEL_13;
    goto LABEL_33;
  }
LABEL_32:
  png_write_sCAL_s((void (**)(void))v3, *(_BYTE *)(a2 + 332), *(char **)(a2 + 336), *(const char **)(a2 + 344));
  v4 = *(_DWORD *)(a2 + 8);
  if ((v4 & 0x80) == 0)
  {
LABEL_13:
    if ((v4 & 0x200) == 0)
      goto LABEL_14;
    goto LABEL_34;
  }
LABEL_33:
  png_write_pHYs((void (**)(void))v3, *(_DWORD *)(a2 + 224), *(_DWORD *)(a2 + 228), *(unsigned __int8 *)(a2 + 232));
  v4 = *(_DWORD *)(a2 + 8);
  if ((v4 & 0x200) == 0)
  {
LABEL_14:
    if ((v4 & 0x2000) == 0)
      goto LABEL_38;
LABEL_35:
    if (*(int *)(a2 + 328) >= 1)
    {
      v7 = 0;
      v8 = 0;
      do
      {
        png_write_sPLT((void (**)(void))v3, *(_QWORD *)(a2 + 320) + v7);
        ++v8;
        v7 += 40;
      }
      while (v8 < *(int *)(a2 + 328));
    }
    goto LABEL_38;
  }
LABEL_34:
  png_write_tIME((void (**)(void))v3, (unsigned __int16 *)(a2 + 168));
  *(_DWORD *)(v3 + 76) |= 0x200u;
  if ((*(_DWORD *)(a2 + 8) & 0x2000) != 0)
    goto LABEL_35;
LABEL_38:
  if (*(int *)(a2 + 148) >= 1)
  {
    v9 = 0;
    v10 = 0;
    v11 = *(_QWORD *)(a2 + 160);
    while (1)
    {
      v12 = *(_DWORD *)(v11 + v9);
      if (v12 >= 1)
        break;
      if (v12 == -1)
      {
        png_write_tEXt((void (**)(void))v3, *(unsigned __int8 **)(v11 + v9 + 8), *(char **)(v11 + v9 + 16));
        v11 = *(_QWORD *)(a2 + 160);
LABEL_48:
        *(_DWORD *)(v11 + v9) = -3;
        goto LABEL_49;
      }
      if (!v12)
      {
        png_write_zTXt(v3, *(unsigned __int8 **)(v11 + v9 + 8), *(char **)(v11 + v9 + 16), 0);
        v11 = *(_QWORD *)(a2 + 160);
LABEL_46:
        *(_DWORD *)(v11 + v9) = -2;
      }
LABEL_49:
      ++v10;
      v9 += 56;
      if (v10 >= *(int *)(a2 + 148))
        return write_unknown_chunks(v3, a2, 2u);
    }
    png_write_iTXt(v3, v12, *(unsigned __int8 **)(v11 + v9 + 8), *(char **)(v11 + v9 + 40), *(char **)(v11 + v9 + 48), *(char **)(v11 + v9 + 16));
    v11 = *(_QWORD *)(a2 + 160);
    if (*(_DWORD *)(v11 + v9) == -1)
      goto LABEL_48;
    goto LABEL_46;
  }
  return write_unknown_chunks(v3, a2, 2u);
}

uint64_t png_write_info_before_PLTE(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  __int16 v4;
  int v5;

  if (!result)
    return result;
  if (!a2)
    return result;
  v3 = result;
  if ((*(_BYTE *)(result + 77) & 4) != 0)
    return result;
  png_write_sig(result);
  if ((*(_BYTE *)(v3 + 77) & 0x10) != 0 && *(_DWORD *)(v3 + 760))
  {
    png_warning(v3, "MNG features are not allowed in a PNG datastream");
    *(_DWORD *)(v3 + 760) = 0;
  }
  png_write_IHDR(v3, *(_DWORD *)a2, *(_DWORD *)(a2 + 4), *(unsigned __int8 *)(a2 + 36), *(unsigned __int8 *)(a2 + 37), *(unsigned __int8 *)(a2 + 38), *(unsigned __int8 *)(a2 + 39), *(unsigned __int8 *)(a2 + 40));
  if ((*(_BYTE *)(a2 + 10) & 2) != 0)
    png_write_acTL(v3, *(_DWORD *)(a2 + 360), *(_DWORD *)(a2 + 364));
  v4 = *(_WORD *)(a2 + 126);
  if ((v4 & 0x8008) == 8)
  {
    if ((*(_BYTE *)(a2 + 8) & 1) == 0)
      goto LABEL_13;
    png_write_gAMA_fixed((void (**)(void))v3, *(_DWORD *)(a2 + 52));
    v4 = *(_WORD *)(a2 + 126);
  }
  if ((v4 & 0x8000) == 0)
  {
LABEL_13:
    v5 = *(_DWORD *)(a2 + 8);
    if ((v5 & 0x1000) != 0)
    {
      if ((v5 & 0x800) != 0)
        png_app_warning(v3, "profile matches sRGB but writing iCCP instead");
      png_write_iCCP(v3, *(unsigned __int8 **)(a2 + 128), *(_QWORD *)(a2 + 136));
    }
    else if ((v5 & 0x800) != 0)
    {
      png_write_sRGB((void (**)(void))v3, *(unsigned __int16 *)(a2 + 124));
    }
  }
  if ((*(_BYTE *)(a2 + 8) & 2) != 0)
    png_write_sBIT(v3, (unsigned __int8 *)(a2 + 176), *(unsigned __int8 *)(a2 + 37));
  if ((*(_WORD *)(a2 + 126) & 0x8010) == 0x10 && (*(_BYTE *)(a2 + 8) & 4) != 0)
    png_write_cHRM_fixed((void (**)(void))v3, (unsigned int *)(a2 + 56));
  result = write_unknown_chunks(v3, a2, 1u);
  *(_DWORD *)(v3 + 76) |= 0x400u;
  return result;
}

uint64_t png_write_sig(uint64_t a1)
{
  uint64_t result;

  *(_DWORD *)(a1 + 956) = 18;
  result = png_write_data(a1);
  if (*(unsigned __int8 *)(a1 + 397) <= 2u)
    *(_DWORD *)(a1 + 76) |= 0x1000u;
  return result;
}

void (**png_write_IHDR(uint64_t a1, unsigned int a2, int a3, unsigned int a4, int a5, int a6, int a7, unsigned int a8))(void)
{
  Bytef v12;
  char v15;
  const char *v16;
  BOOL v18;
  char v19;
  unint64_t v20;
  void (**result)(void);
  char v22;
  Bytef v23[16];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v12 = a4;
  switch(a5)
  {
    case 0:
      if (a4 <= 0x10)
      {
        v15 = 1;
        if (((1 << a4) & 0x10116) != 0)
          goto LABEL_16;
      }
      v16 = "Invalid bit depth for grayscale image";
      goto LABEL_45;
    case 2:
      v15 = 3;
      if (a4 == 8 || a4 == 16)
        goto LABEL_16;
      v16 = "Invalid bit depth for RGB image";
      goto LABEL_45;
    case 3:
      if (a4 - 1 >= 8 || ((0x8Bu >> (a4 - 1)) & 1) == 0)
      {
        v16 = "Invalid bit depth for paletted image";
LABEL_45:
        _cg_png_error((void (**)(void))a1, v16);
      }
      v15 = 1;
LABEL_16:
      *(_BYTE *)(a1 + 395) = v15;
      if (a6)
        png_warning(a1, "Invalid compression type specified");
      if ((*(_BYTE *)(a1 + 760) & 4) == 0 || (*(_BYTE *)(a1 + 77) & 0x10) != 0)
      {
        if (!a7)
          goto LABEL_31;
        goto LABEL_30;
      }
      v18 = (a5 & 0xFFFFFFFB) != 2 || a7 != 64;
      if (a7 && v18)
      {
LABEL_30:
        png_warning(a1, "Invalid filter type specified");
        LOBYTE(a7) = 0;
      }
LABEL_31:
      if (a8 >= 2)
      {
        png_warning(a1, "Invalid interlace type specified");
        LOBYTE(a8) = 1;
      }
      *(_BYTE *)(a1 + 392) = v12;
      *(_BYTE *)(a1 + 391) = a5;
      *(_BYTE *)(a1 + 388) = a8;
      *(_BYTE *)(a1 + 764) = a7;
      *(_BYTE *)(a1 + 872) = 0;
      *(_DWORD *)(a1 + 280) = a2;
      *(_DWORD *)(a1 + 284) = a3;
      v19 = *(_BYTE *)(a1 + 395);
      *(_BYTE *)(a1 + 394) = v19 * v12;
      v20 = a2 * (unint64_t)((v19 * v12) >> 3);
      if ((v19 * v12) < 8u)
        v20 = ((v19 * v12) * (unint64_t)a2 + 7) >> 3;
      *(_QWORD *)(a1 + 296) = v20;
      *(_DWORD *)(a1 + 292) = a2;
      *(_BYTE *)(a1 + 393) = v12;
      *(_BYTE *)(a1 + 396) = v19;
      v23[0] = HIBYTE(a2);
      v23[1] = BYTE2(a2);
      v23[2] = BYTE1(a2);
      v23[3] = a2;
      v23[4] = HIBYTE(a3);
      v23[5] = BYTE2(a3);
      v23[6] = BYTE1(a3);
      v23[7] = a3;
      v23[8] = v12;
      v23[9] = a5;
      v23[10] = 0;
      v23[11] = a7;
      v23[12] = a8;
      result = _cg_png_write_complete_chunk((void (**)(void))a1, 1229472850, v23, 0xDuLL);
      *(_DWORD *)(a1 + 776) = a2;
      *(_DWORD *)(a1 + 780) = a3;
      if (!*(_BYTE *)(a1 + 390))
      {
        v22 = 8;
        if (*(_BYTE *)(a1 + 391) != 3)
        {
          if (*(unsigned __int8 *)(a1 + 392) < 8u)
            v22 = 8;
          else
            v22 = -8;
        }
        *(_BYTE *)(a1 + 390) = v22;
      }
      *(_DWORD *)(a1 + 76) = 1;
      return result;
    case 4:
      v15 = 2;
      if (a4 == 8 || a4 == 16)
        goto LABEL_16;
      v16 = "Invalid bit depth for grayscale+alpha image";
      goto LABEL_45;
    case 6:
      v15 = 4;
      if (a4 == 8 || a4 == 16)
        goto LABEL_16;
      v16 = "Invalid bit depth for RGBA image";
      goto LABEL_45;
    default:
      v16 = "Invalid image color type specified";
      goto LABEL_45;
  }
}

uint64_t _cg_png_set_compression_level(uint64_t result, int a2)
{
  if (result)
    *(_DWORD *)(result + 220) = a2;
  return result;
}

_QWORD *_cg_png_create_write_struct(_BYTE *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return png_create_write_struct_2(a1, a2, a3, a4, 0, 0, 0);
}

uint64_t IIOImagePixelDataProvider::getAlphaInfo(IIOImagePixelDataProvider *this)
{
  return *((_DWORD *)this + 24) & 0x1F;
}

uint64_t PNGWritePlugin::writeAll(PNGWritePlugin *this)
{
  unsigned int ImageCount;
  IIODictionary *ContainerProperties;
  IIOImagePixelDataProvider *PixelDataProviderAtIndex;
  IIOImageSource *v5;
  _BOOL4 hasAlpha;
  IIODictionary *PropertiesAtIndex;
  IIOImageSource *v8;
  CGImage *Ref;
  uint64_t v10;
  IIOImageSource *v11;
  IIO_Reader *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  CFIndex v18;
  IIOImagePixelDataProvider *v19;
  CGImage *v20;
  CGColorSpace *ColorSpace;
  int ColorTableCount;
  CGColorSpace *BaseColorSpace;
  int NumberOfComponents;
  uint8_t *v25;
  CFIndex v26;
  IIOImageSource *v27;
  CGImage *v28;
  CGColorSpace *v29;
  int v30;
  CGColorSpace *v31;
  int v32;
  size_t v33;
  uint8_t *v34;
  int v35;
  int v36;
  uint64_t result;
  IIOImagePixelDataProvider *v38;
  IIODictionary *v39;
  int v40;
  unint64_t v41;
  uint64_t v42;

  ImageCount = IIOWritePlugin::getImageCount((IIOImageDestination **)this);
  *((_DWORD *)this + 18) = ImageCount;
  if (ImageCount)
  {
    ContainerProperties = (IIODictionary *)IIOWritePlugin::getContainerProperties((IIOImagePlus **)this);
    *((_BYTE *)this + 121) = 1;
    PixelDataProviderAtIndex = (IIOImagePixelDataProvider *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, 0);
    v5 = PixelDataProviderAtIndex;
    if (PixelDataProviderAtIndex)
    {
      hasAlpha = IIOImagePixelDataProvider::hasAlpha(PixelDataProviderAtIndex);
      PropertiesAtIndex = (IIODictionary *)IIOWritePlugin::getPropertiesAtIndex((IIOImageDestination **)this, 0);
      *((_QWORD *)this + 11) = IIOImageSource::count(v5);
      *((_QWORD *)this + 12) = IIO_Reader::testHeaderSize(v5);
      *((_DWORD *)this + 19) = 0;
      if (*((_DWORD *)this + 18) == 1)
      {
        v8 = (IIOImageSource *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, 0);
        Ref = (CGImage *)IIOImageSource::imageReadRef(v8);
        CGImageGetColorSpace(Ref);
        if (CGColorSpaceGetType() == 7)
          *((_BYTE *)this + 124) = 1;
      }
      else
      {
        if (IIODictionary::containsKeyGroup(ContainerProperties, CFSTR("LoopCount"), CFSTR("{PNG}")))
          *((_DWORD *)this + 20) = IIODictionary::getUint32ForKeyGroup(ContainerProperties, CFSTR("LoopCount"), CFSTR("{PNG}"));
        if (*((_DWORD *)this + 18) >= 2u)
        {
          v10 = 0;
          while (1)
          {
            v11 = (IIOImageSource *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, v10 + 1);
            v12 = v11;
            if (v11)
            {
              v13 = *((_QWORD *)this + 11);
              if (v13 != IIOImageSource::count(v11))
                break;
              v14 = *((_QWORD *)this + 12);
              if (v14 != IIO_Reader::testHeaderSize(v12))
                break;
            }
            v15 = *((unsigned int *)this + 18);
            v16 = v10 + 2;
            ++v10;
            if (v16 >= v15)
              goto LABEL_18;
          }
          LODWORD(v15) = v10 + 1;
          v17 = 115;
          if (!(_DWORD)v10)
            v17 = 32;
          _cg_jpeg_mem_term("writeAll", 1547, "*** ERROR trying to write APNG with %d frames - but frame sizes do not match. Writing %d frame%c.\n", *((_DWORD *)this + 18), v10 + 1, v17);
          *((_DWORD *)this + 18) = v15;
LABEL_18:
          if (v15 >= 2)
          {
            v18 = 1;
            while (1)
            {
              v19 = (IIOImagePixelDataProvider *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, v18);
              if (hasAlpha != IIOImagePixelDataProvider::hasAlpha(v19))
                break;
              if (++v18 >= (unint64_t)*((unsigned int *)this + 18))
                goto LABEL_24;
            }
            *((_BYTE *)this + 121) = 0;
          }
        }
LABEL_24:
        v8 = (IIOImageSource *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, 0);
        v20 = (CGImage *)IIOImageSource::imageReadRef(v8);
        ColorSpace = CGImageGetColorSpace(v20);
        if (CGColorSpaceGetType() == 7)
        {
          ColorTableCount = CGColorSpaceGetColorTableCount(ColorSpace);
          BaseColorSpace = CGColorSpaceGetBaseColorSpace(ColorSpace);
          NumberOfComponents = CGColorSpaceGetNumberOfComponents(BaseColorSpace);
          v25 = (uint8_t *)malloc_type_malloc((NumberOfComponents * ColorTableCount), 0x7B3D0469uLL);
          if (v25)
          {
            CGColorSpaceGetColorTable(ColorSpace, v25);
            *((_BYTE *)this + 124) = 1;
            if (*((_DWORD *)this + 18) < 2u)
              goto LABEL_39;
            v26 = 1;
            while (1)
            {
              v27 = (IIOImageSource *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, v26);
              v28 = (CGImage *)IIOImageSource::imageReadRef(v27);
              v29 = CGImageGetColorSpace(v28);
              if (CGColorSpaceGetType() != 7)
              {
                *((_BYTE *)this + 124) = 0;
                _cg_jpeg_mem_term("writeAll", 1600, "*** writing indexed color APNG - image #d has no color palette\n", v26);
                goto LABEL_39;
              }
              v30 = CGColorSpaceGetColorTableCount(v29);
              v31 = CGColorSpaceGetBaseColorSpace(v29);
              v32 = CGColorSpaceGetNumberOfComponents(v31);
              if (v30 != ColorTableCount || v32 != NumberOfComponents)
                break;
              v33 = (v32 * v30);
              v34 = (uint8_t *)malloc_type_malloc(v33, 0xE26B8728uLL);
              if (!v34 || (CGColorSpaceGetColorTable(v29, v34), v35 = memcmp(v34, v25, v33), free(v34), v35))
              {
                *((_BYTE *)this + 124) = 0;
                goto LABEL_39;
              }
              if (++v26 >= (unint64_t)*((unsigned int *)this + 18))
                goto LABEL_39;
            }
            *((_BYTE *)this + 124) = 0;
            v36 = CGColorSpaceGetColorTableCount(v29);
            _cg_jpeg_mem_term("writeAll", 1609, "*** writing indexed color APNG - image #%d: color palette mismatch (%d entries expected, got %d)\n", v26, ColorTableCount, v36);
LABEL_39:
            free(v25);
          }
          else
          {
            *((_BYTE *)this + 124) = 0;
          }
        }
      }
      result = PNGWritePlugin::writePrologue(this, v8, PropertiesAtIndex);
      if ((_DWORD)result)
        return result;
      v40 = *((_DWORD *)this + 18);
      if (v40 == 1)
      {
        PNGWritePlugin::writePNG(this, v8, PropertiesAtIndex);
LABEL_56:
        PNGWritePlugin::writeEpilogue(this, v38, v39);
        return 0;
      }
      if (*((_BYTE *)this + 121))
      {
        if (!v40)
          goto LABEL_56;
      }
      else
      {
        _cg_jpeg_mem_term("writeAll", 1653, "alpha mismatch - convert all frames to have alpha\n");
        if (!*((_DWORD *)this + 18))
          goto LABEL_56;
      }
      v41 = 0;
      while (1)
      {
        if ((gIIODebugFlags & 0x30000) != 0)
          ImageIOLog("    ==== writing APNG frame #%zu =================\n", v41);
        if (v41)
        {
          v8 = (IIOImageSource *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, v41);
          v42 = IIOWritePlugin::getPropertiesAtIndex((IIOImageDestination **)this, v41);
          if (!v8)
            return 4294967292;
          PropertiesAtIndex = (IIODictionary *)v42;
          *((_BYTE *)this + 120) = IIOImagePixelDataProvider::hasAlpha(v8);
        }
        else if (IIODictionary::containsKey(PropertiesAtIndex, CFSTR("kCGImageDestinationOptimizeForSize")))
        {
          *((_BYTE *)this + 123) = IIODictionary::getBoolForKey(PropertiesAtIndex, CFSTR("kCGImageDestinationOptimizeForSize"));
        }
        *((_DWORD *)this + 19) = v41;
        PNGWritePlugin::writeAPNGFrame(this, v8, PropertiesAtIndex);
        _cg_png_reset_write(*((void ***)this + 5));
        if (++v41 >= *((unsigned int *)this + 18))
          goto LABEL_56;
      }
    }
  }
  return 4294967246;
}

void sub_187E9B3A4(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t IIOImageDestination::getPixelProviderAtIndex(CFArrayRef *this, CFIndex a2)
{
  unsigned int Count;
  _QWORD *ValueAtIndex;
  BOOL v6;
  uint64_t result;

  Count = CFArrayGetCount(this[12]);
  if (a2 < Count)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(this[12], a2);
    if (ValueAtIndex)
      v6 = ValueAtIndex == (_QWORD *)*MEMORY[0x1E0C9B0D0];
    else
      v6 = 1;
    if (!v6)
      return ValueAtIndex[3];
    return 0;
  }
  result = 0;
  if (a2 && Count)
  {
    _cg_jpeg_mem_term("getPixelProviderAtIndex", 4161, "*** getImageMetadataAtIndex index (%d) larger than arrayCount (%d)\n", a2, Count);
    return 0;
  }
  return result;
}

uint64_t IIOWritePlugin::getPixelDataProviderAtIndex(CFArrayRef **this, CFIndex a2)
{
  return IIOImageDestination::getPixelProviderAtIndex(this[3], a2);
}

BOOL IIOImagePixelDataProvider::hasAlpha(IIOImagePixelDataProvider *this)
{
  return (*((_DWORD *)this + 24) & 0x1Fu) - 1 < 4;
}

uint64_t IIOImageDestination::getImagePropertiesAtIndex(IIOImageDestination *this, unint64_t a2)
{
  uint64_t v2;
  unint64_t v3;

  v2 = *((_QWORD *)this + 16);
  v3 = (*((_QWORD *)this + 17) - v2) >> 3;
  if (v3 > a2)
    return *(_QWORD *)(v2 + 8 * a2);
  _cg_jpeg_mem_term("getImagePropertiesAtIndex", 4241, "*** ERROR: IIOImageDestination::getImagePropertiesAtIndex - index (%d) larger than vector size (%d)\n", a2, v3);
  return 0;
}

void IIOWritePlugin::IIOWritePlugin(IIOWritePlugin *this, IIOImageWriteSession *a2, IIOImageDestination *a3, unsigned int a4)
{
  char v4;

  v4 = a4;
  *(_QWORD *)this = off_1E1BAE400;
  *((_DWORD *)this + 8) = IIOPluginIndexToOSType(a4);
  *((_QWORD *)this + 2) = a2;
  *((_QWORD *)this + 3) = a3;
  *((_BYTE *)this + 36) = v4;
  *((_BYTE *)this + 37) = IIOPluginShouldDebugWriteImageBlocks();
}

uint64_t IIOWritePlugin::getContainerProperties(IIOImagePlus **this)
{
  return IIOImagePlus::getSourceGeomColorSpace(this[3]);
}

uint64_t IIOWritePlugin::getPropertiesAtIndex(IIOImageDestination **this, unint64_t a2)
{
  return IIOImageDestination::getImagePropertiesAtIndex(this[3], a2);
}

const __CFArray *IIOWritePlugin::getImageCount(IIOImageDestination **this)
{
  return IIOImageDestination::pixelProviderCount(this[3]);
}

const __CFArray *IIOImageDestination::pixelProviderCount(IIOImageDestination *this)
{
  const __CFArray *result;

  result = (const __CFArray *)*((_QWORD *)this + 12);
  if (result)
    return (const __CFArray *)CFArrayGetCount(result);
  return result;
}

uint64_t IIOPluginIndexToOSType(unsigned int a1)
{
  if (a1 > 0x1F)
    return 757935405;
  else
    return *(unsigned int *)&aLlakrwfctsaXta[4 * (char)a1];
}

__CFData *CGColorSpaceCopyData(CGColorSpace *a1, int a2)
{
  CGColorSpace *BaseColorSpace;
  unsigned int Type;
  __CFData *v5;
  const __CFData *v6;
  const __CFData *v7;
  int v8;
  const __CFData *MutableCopy;

  if (!a1)
    return 0;
  BaseColorSpace = a1;
  while (1)
  {
    Type = CGColorSpaceGetType();
    if (Type != 7)
      break;
    BaseColorSpace = CGColorSpaceGetBaseColorSpace(BaseColorSpace);
    if (!BaseColorSpace)
      return 0;
  }
  v5 = 0;
  if (Type <= 0xA && ((1 << Type) & 0x578) != 0)
  {
    v6 = CGColorSpaceCopyICCData(BaseColorSpace);
    if (v6)
    {
      v7 = v6;
      if (bswap32(*((_DWORD *)CFDataGetBytePtr(v6) + 16)) == a2)
      {
        v5 = (__CFData *)CFRetain(v7);
      }
      else
      {
        if (a2 == 4)
          v8 = 0x2000000;
        else
          v8 = (a2 == 2) << 24;
        MutableCopy = CFDataCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v7);
        v5 = MutableCopy;
        if (MutableCopy && CFDataGetLength(MutableCopy) >= 68)
          *((_DWORD *)CFDataGetMutableBytePtr(v5) + 16) = v8;
      }
      CFRelease(v7);
      return v5;
    }
    return 0;
  }
  return v5;
}

void _cg_png_destroy_write_struct(uint64_t *a1, void **a2)
{
  uint64_t v3;

  if (a1)
  {
    v3 = *a1;
    if (*a1)
    {
      _cg_png_destroy_info_struct(*a1, a2);
      *a1 = 0;
      if ((*(_BYTE *)(v3 + 80) & 2) != 0)
        deflateEnd((z_streamp)(v3 + 96));
      png_free_buffer_list(v3, (_QWORD **)(v3 + 208));
      png_free(v3, *(void **)(v3 + 328));
      *(_QWORD *)(v3 + 328) = 0;
      png_free(v3, *(void **)(v3 + 320));
      png_free(v3, *(void **)(v3 + 336));
      png_free(v3, *(void **)(v3 + 344));
      *(_QWORD *)(v3 + 320) = 0;
      *(_QWORD *)(v3 + 336) = 0;
      *(_QWORD *)(v3 + 344) = 0;
      png_free(v3, *(void **)(v3 + 744));
      *(_QWORD *)(v3 + 744) = 0;
      png_destroy_png_struct((void *)v3);
    }
  }
}

void png_free_buffer_list(uint64_t a1, _QWORD **a2)
{
  _QWORD *v3;
  _QWORD *v5;

  v3 = *a2;
  if (v3)
  {
    *a2 = 0;
    do
    {
      v5 = (_QWORD *)*v3;
      png_free(a1, v3);
      v3 = v5;
    }
    while (v5);
  }
}

uint64_t IIOImageWriteSession::finalize(IIOImageWriteSession *this, int a2)
{
  const __CFString *v4;
  CFIndex MaximumSizeOfFileSystemRepresentation;
  std::__fs::filesystem::path *v6;
  std::__fs::filesystem::path *v7;
  const __CFString *v8;
  CFIndex v9;
  __CFData *v10;
  uint64_t v11;
  FILE *v12;
  std::error_code *v13;
  int v14;
  int *v15;
  char *v16;
  int *v17;
  __CFData *v18;
  UInt8 *MutableBytePtr;
  uint64_t v20;
  UInt8 *v21;
  uint64_t v22;

  v4 = (const __CFString *)*((_QWORD *)this + 5);
  if (v4)
  {
    MaximumSizeOfFileSystemRepresentation = CFStringGetMaximumSizeOfFileSystemRepresentation(v4);
    v6 = (std::__fs::filesystem::path *)malloc_type_malloc(MaximumSizeOfFileSystemRepresentation, 0xA4F987FAuLL);
    if (!CFStringGetFileSystemRepresentation(*((CFStringRef *)this + 5), (char *)v6, MaximumSizeOfFileSystemRepresentation))
    {
      v7 = 0;
      goto LABEL_36;
    }
  }
  else
  {
    v6 = 0;
  }
  v8 = (const __CFString *)*((_QWORD *)this + 6);
  if (v8)
  {
    v9 = CFStringGetMaximumSizeOfFileSystemRepresentation(v8);
    v7 = (std::__fs::filesystem::path *)malloc_type_malloc(v9, 0x747BEA1EuLL);
    if (!CFStringGetFileSystemRepresentation(*((CFStringRef *)this + 6), (char *)v7, v9))
      goto LABEL_36;
    if (a2)
    {
      if (v7)
      {
        unlink((const char *)v7);
        goto LABEL_14;
      }
      goto LABEL_11;
    }
  }
  else
  {
    if (a2)
    {
LABEL_11:
      v10 = (__CFData *)*((_QWORD *)this + 3);
      if (v10)
        CFDataSetLength(v10, 0);
      v7 = 0;
      goto LABEL_14;
    }
    v7 = 0;
  }
  if (!*((_QWORD *)this + 5))
  {
    if (!*((_QWORD *)this + 2))
      goto LABEL_14;
    v18 = (__CFData *)*((_QWORD *)this + 3);
    if (!v18)
      goto LABEL_14;
    if (!*((_QWORD *)this + 7))
      goto LABEL_14;
    MutableBytePtr = CFDataGetMutableBytePtr(v18);
    v20 = *((_QWORD *)this + 7);
    if (!v20)
      goto LABEL_14;
    v21 = MutableBytePtr;
    while (1)
    {
      v22 = CGDataConsumerPutBytes();
      if (!v22)
        break;
      v21 += v22;
      v20 -= v22;
      if (!v20)
        goto LABEL_14;
    }
    LogError("finalize", 429, "*** ERROR: Could not write any more data to the consumer\n");
LABEL_36:
    v11 = 4294967246;
    if (!v6)
      goto LABEL_38;
    goto LABEL_37;
  }
  v12 = (FILE *)*((_QWORD *)this + 4);
  if (v12)
  {
    if ((gIIODebugFlags & 0x200000000000) != 0)
    {
      ImageIOLog("<<< CGImageWriteSessionFinalize: [%p] closing FILE* %p\n", this, v12);
      v12 = (FILE *)*((_QWORD *)this + 4);
    }
    fclose(v12);
    *((_BYTE *)this + 73) = 0;
  }
  *((_QWORD *)this + 4) = 0;
  if (v6)
  {
    if (v7)
    {
      if (strcmp((const char *)v7, (const char *)v6))
      {
        rename(v7, v6, v13);
        if (v14)
        {
          v15 = __error();
          v16 = strerror(*v15);
          v17 = __error();
          LogError("finalize", 413, "*** ERROR: rename (\"%s\" to \"%s\") failed: '%s' (%d)\n", (const char *)v7, (const char *)v6, v16, *v17);
          unlink((const char *)v7);
          v11 = 4294967246;
          goto LABEL_37;
        }
      }
    }
  }
LABEL_14:
  v11 = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  if (v6)
LABEL_37:
    free(v6);
LABEL_38:
  if (v7)
    free(v7);
  return v11;
}

void PNGWritePlugin::~PNGWritePlugin(PNGWritePlugin *this, uint64_t a2, const char *a3)
{
  void *v4;
  void *v5;
  void **v6;

  *(_QWORD *)this = &off_1E1BAFBE8;
  v4 = (void *)*((_QWORD *)this + 7);
  if (v4)
    free(v4);
  v5 = (void *)*((_QWORD *)this + 14);
  if (v5)
    free(v5);
  if (*((_QWORD *)this + 5))
  {
    _cg_jpeg_mem_term("~PNGWritePlugin", 158, "*** PNGWritePlugin::~PNGWritePlugin -- cleaning up '_png_ptr' -- should have been done in writeEpilogue\n");
    if (*((_QWORD *)this + 6))
      v6 = (void **)((char *)this + 48);
    else
      v6 = 0;
    _cg_png_destroy_write_struct((uint64_t *)this + 5, v6);
    *((_QWORD *)this + 5) = 0;
    *((_QWORD *)this + 6) = 0;
  }
  _cg_jpeg_mem_term(this, a2, a3);
}

{
  PNGWritePlugin::~PNGWritePlugin(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

uint64_t CGImageWriteSessionFinalize(uint64_t a1, int a2)
{
  IIOImageWriteSession *v2;

  if (a1 && (v2 = *(IIOImageWriteSession **)(a1 + 24)) != 0)
    return IIOImageWriteSession::finalize(v2, a2);
  else
    return 4294967246;
}

uint64_t _cg_png_set_filter(uint64_t result, int a2, unsigned int a3)
{
  unsigned int v3;
  uint64_t v4;
  int v5;
  char v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  BOOL v10;
  unint64_t v11;
  unint64_t v12;
  size_t v13;

  if (result)
  {
    v3 = a3;
    v4 = result;
    v5 = (*(unsigned __int8 *)(result + 760) >> 2) & 1;
    if (a2 != 64)
      v5 = 0;
    if (a2 && !v5)
      _cg_png_error((void (**)(void))result, "Unknown custom filter method");
    v6 = 8;
    switch((char)a3)
    {
      case 0:
        break;
      case 1:
        v6 = 16;
        break;
      case 2:
        v6 = 32;
        break;
      case 3:
        v6 = 64;
        break;
      case 4:
        v6 = 0x80;
        break;
      case 5:
      case 6:
      case 7:
        result = png_app_error(result, "Unknown row filter for method 0");
        v6 = 8;
        break;
      default:
        v6 = a3;
        break;
    }
    *(_BYTE *)(v4 + 390) = v6;
    if (*(_QWORD *)(v4 + 328))
    {
      if (*(_DWORD *)(v4 + 284) == 1)
        v7 = v3 & 0xFFFFFF1F;
      else
        v7 = v3;
      if (*(_DWORD *)(v4 + 280) == 1)
        v3 = v7 & 0xFFFFFF2F;
      else
        v3 = v7;
      if ((v3 & 0xE0) != 0 && !*(_QWORD *)(v4 + 320))
      {
        result = png_app_warning(v4, "png_set_filter: UP/AVG/PAETH cannot be added after start");
        v3 &= 0xFFFFFF1F;
      }
      v8 = *(unsigned __int8 *)(v4 + 393) * *(unsigned __int8 *)(v4 + 396);
      v9 = *(_DWORD *)(v4 + 280);
      v10 = v8 >= 8;
      v11 = (v9 * (unint64_t)v8 + 7) >> 3;
      v12 = v9 * (unint64_t)(v8 >> 3);
      if (!v10)
        v12 = v11;
      v13 = v12 + 1;
      if (!*(_QWORD *)(v4 + 336))
      {
        result = (uint64_t)png_malloc((void (**)(void))v4, v13);
        *(_QWORD *)(v4 + 336) = result;
      }
      if (((v3 >> 4) & 1) + ((v3 >> 5) & 1) + ((v3 >> 6) & 1) + ((v3 >> 7) & 1) >= 2 && !*(_QWORD *)(v4 + 344))
      {
        result = (uint64_t)png_malloc((void (**)(void))v4, v13);
        *(_QWORD *)(v4 + 344) = result;
      }
    }
    *(_BYTE *)(v4 + 390) = v3;
  }
  return result;
}

uint64_t _cg_png_set_compression_strategy(uint64_t result, int a2)
{
  if (result)
  {
    *(_DWORD *)(result + 80) |= 1u;
    *(_DWORD *)(result + 236) = a2;
  }
  return result;
}

void IIOImageDestination::IIOImageDestination(IIOImageDestination *this, __CFData *a2, IIO_Writer *a3, const __CFString *a4, uint64_t a5, const __CFDictionary **a6)
{
  uint64_t v11;

  *(_QWORD *)this = &off_1E1BB1BB0;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  IIOImageDestination::setup(this, 1);
  v11 = CGImageWriteSessionCreateWithMutableData(a2);
  *((_QWORD *)this + 2) = v11;
  *((_QWORD *)this + 3) = CGImageSourceGetSource(v11);
  *((_QWORD *)this + 8) = a3;
  *((_QWORD *)this + 9) = IIO_Writer::utType(a3);
  *((_QWORD *)this + 5) = a5;
  IIOImageDestination::setProperties(this, a6);
}

void sub_187E9BCA8(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  void **v2;
  void *v4;
  void *v5;

  v4 = (void *)v1[16];
  if (v4)
  {
    v1[17] = v4;
    operator delete(v4);
  }
  v5 = *v2;
  if (*v2)
  {
    v1[14] = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

CFMutableArrayRef IIOImageDestination::setup(CFMutableArrayRef result, int a2)
{
  CFMutableArrayRef v2;

  *(_OWORD *)((char *)result + 72) = 0u;
  *(_OWORD *)((char *)result + 56) = 0u;
  *(_OWORD *)((char *)result + 40) = 0u;
  *(_OWORD *)((char *)result + 24) = 0u;
  *(_OWORD *)((char *)result + 8) = 0u;
  *((_OWORD *)result + 10) = 0u;
  *((_OWORD *)result + 11) = 0u;
  *(_DWORD *)((char *)result + 222) = 0;
  *((_BYTE *)result + 226) = 0;
  *((_BYTE *)result + 192) = a2;
  *((_DWORD *)result + 57) = 0;
  *((_QWORD *)result + 19) = 0;
  *((_QWORD *)result + 29) = result;
  *((_QWORD *)result + 30) = result;
  *((_DWORD *)result + 51) = 0;
  *((_DWORD *)result + 52) = 0;
  *((_WORD *)result + 106) = 0;
  *((_BYTE *)result + 216) = 0;
  *((_QWORD *)result + 11) = 0;
  *((_QWORD *)result + 12) = 0;
  *((_DWORD *)result + 49) = 0;
  if (a2 != 5)
  {
    v2 = result;
    result = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
    *((_QWORD *)v2 + 12) = result;
  }
  return result;
}

void IIOImageDestination::setProperties(IIOImageDestination *this, const __CFDictionary **a2)
{
  const __CFArray *v4;
  uint64_t v5;
  IIODictionary *v6;
  _BYTE v7[24];

  if (*((_QWORD *)this + 2))
  {
    if (*((_BYTE *)this + 225))
    {
      LogError("setProperties", 1960, "*** ERROR: image destination was already finalized\n");
    }
    else
    {
      v4 = (const __CFArray *)*((_QWORD *)this + 12);
      if (v4 && CFArrayGetCount(v4))
      {
        LogError("setProperties", 1961, "*** ERROR: image destination cannot be changed once an image was added\n");
      }
      else
      {
        if (a2)
        {
          v5 = *((_QWORD *)this + 11);
          if (v5)
            (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
          v6 = (IIODictionary *)operator new();
          IIODictionary::IIODictionary(v6, a2[1], 1);
        }
        else
        {
          v6 = (IIODictionary *)operator new();
          IIODictionary::IIODictionary(v6);
        }
        *((_QWORD *)this + 11) = v6;
        IIONumber::IIONumber((IIONumber *)v7, *((_QWORD *)this + 5));
        IIODictionary::setObjectForKey((uint64_t)v6, (uint64_t)v7, CFSTR("capacity"));
        IIONumber::~IIONumber((IIONumber *)v7);
      }
    }
  }
  else
  {
    LogError("setProperties", 1959, "*** ERROR: cannot set properties - invalid image destination\n");
  }
}

void sub_187E9BE98(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

uint64_t CGImageWriteSessionCreateWith_wSession(IIOImageWriteSession *a1)
{
  uint64_t result;
  unint64_t v3;

  if (CGImageWriteSessionGetTypeID::once != -1)
    dispatch_once(&CGImageWriteSessionGetTypeID::once, &__block_literal_global_7);
  result = _CFRuntimeCreateInstance();
  *(_DWORD *)(result + 16) = 1;
  do
    v3 = __ldxr(&gWriteSessionCount);
  while (__stxr(v3 + 1, &gWriteSessionCount));
  *(_QWORD *)(result + 24) = a1;
  return result;
}

float IIODictionary::getFloatFromValue(IIODictionary *this, const __CFString *cf)
{
  float v2;
  CFTypeID v4;
  CFTypeID v5;
  float valuePtr;

  valuePtr = 0.0;
  v2 = 0.0;
  if (cf)
  {
    v4 = CFGetTypeID(cf);
    if (v4 == CFNumberGetTypeID())
    {
      CFNumberGetValue((CFNumberRef)cf, kCFNumberFloatType, &valuePtr);
      return valuePtr;
    }
    else
    {
      v5 = CFGetTypeID(cf);
      if (v5 == CFStringGetTypeID())
        return CFStringGetDoubleValue(cf);
    }
  }
  return v2;
}

float IIODictionary::getFloatForKey(IIODictionary *this, const __CFString *a2)
{
  const __CFDictionary *v2;
  IIODictionary *Value;

  v2 = (const __CFDictionary *)*((_QWORD *)this + 1);
  if (!v2)
    return 0.0;
  Value = (IIODictionary *)CFDictionaryGetValue(v2, a2);
  return IIODictionary::getFloatFromValue(Value, (const __CFString *)Value);
}

void (**png_write_pHYs(void (**a1)(void), int a2, int a3, int a4))(void)
{
  Bytef v4;
  Bytef v9[9];
  uint64_t v10;

  v4 = a4;
  v10 = *MEMORY[0x1E0C80C00];
  if (a4 >= 2)
    png_warning((uint64_t)a1, "Unrecognized unit type for pHYs chunk");
  v9[0] = HIBYTE(a2);
  v9[1] = BYTE2(a2);
  v9[2] = BYTE1(a2);
  v9[3] = a2;
  v9[4] = HIBYTE(a3);
  v9[5] = BYTE2(a3);
  v9[6] = BYTE1(a3);
  v9[7] = a3;
  v9[8] = v4;
  return _cg_png_write_complete_chunk(a1, 1883789683, v9, 9uLL);
}

void (**png_write_sRGB(void (**a1)(void), int a2))(void)
{
  Bytef v2;
  Bytef v5;

  v2 = a2;
  if (a2 >= 4)
    png_warning((uint64_t)a1, "Invalid sRGB rendering intent specified");
  v5 = v2;
  return _cg_png_write_complete_chunk(a1, 1934772034, &v5, 1uLL);
}

void _cg_png_set_sRGB(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (a1)
  {
    if (a2)
    {
      png_colorspace_set_sRGB(a1, a2 + 52, a3);
      png_colorspace_sync_info(a1, a2);
    }
  }
}

const __CFURL *CGImageWriteSessionCreateWithURL(const __CFURL *a1)
{
  const __CFURL *v1;
  CFTypeID v2;
  CFStringRef v3;
  const __CFString *v4;
  CFStringRef v5;
  CGDataConsumerRef v6;
  uint64_t v7;
  stat v9;
  UInt8 buffer[1026];
  uint64_t v11;

  v1 = a1;
  v11 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = CFURLGetTypeID();
    if (v2 == CFGetTypeID(v1))
    {
      v3 = IIO_CFURLCopyResolvedFileSystemPath(v1);
      if (v3)
      {
        v4 = v3;
        bzero(buffer, 0x402uLL);
        if (!CFURLGetFileSystemRepresentation(v1, 1u, buffer, 1026))
        {
          LogError("CGImageWriteSessionCreateWithURL", 775, "*** ERROR: invalid URL - CFURLGetFileSystemRepresentation failed\n");
          goto LABEL_14;
        }
        memset(&v9, 0, sizeof(v9));
        if (!stat((const char *)buffer, &v9) && (v9.st_mode & 0xF000) == 0x4000)
        {
          LogError("CGImageWriteSessionCreateWithURL", 782, "*** ERROR: invalid URL (directory vs. file)\n");
LABEL_14:
          v1 = 0;
          goto LABEL_15;
        }
        v7 = CGImageWriteSessionCreateWithFile(v4);
LABEL_12:
        v1 = (const __CFURL *)v7;
LABEL_15:
        CFRelease(v4);
        return v1;
      }
      v5 = CFURLCopyScheme(v1);
      if (v5)
      {
        CFRelease(v5);
        v6 = CGDataConsumerCreateWithURL(v1);
        if (v6)
        {
          v4 = (const __CFString *)v6;
          v7 = CGImageWriteSessionCreateWithConsumer(v6);
          goto LABEL_12;
        }
        LogError("CGImageWriteSessionCreateWithURL", 795, "*** ERROR: invalid URL - CGDataConsumerCreateWithURL failed\n");
      }
      else
      {
        LogError("CGImageWriteSessionCreateWithURL", 791, "*** ERROR: invalid URL - cannot copy scheme\n");
      }
    }
    return 0;
  }
  return v1;
}

uint64_t IIO_Reader_PNG::updateSourceProperties(IIO_Reader_PNG *this, IIOImageReadSession *a2, IIODictionary *a3, IIODictionary *a4, IIODictionary *a5, CGImageSourceStatus *a6)
{
  _BOOL4 BoolForKey;
  char v8;
  unint64_t v9;
  unsigned int v10;
  unsigned int v12;
  IIOImageRead *v13;
  uint64_t v14;
  uint64_t i;
  unsigned int v16;
  unsigned int v17;
  float v18;
  char v19;
  const void **v20;
  const void **v21;
  CGImageMetadata *Mutable;
  CFDataRef v23;
  const __CFString *v27;
  void *v29[2];
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  CFMutableArrayRef Size;
  void *v35[2];
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  CGColorSpace *v50;
  _QWORD v51[3];
  _QWORD v52[3];
  _BYTE v53[24];
  _BYTE v54[24];
  _BYTE v55[24];
  _QWORD v56[4];

  v56[1] = *MEMORY[0x1E0C80C00];
  if (a4)
    BoolForKey = IIODictionary::getBoolForKey(a4, CFSTR("kCGImageSourcePropertiesIncludeColorInfo"));
  else
    BoolForKey = 0;
  v56[0] = 0;
  if (IIOImageReadSession::getBytesAtOffset(a2, v56, 8uLL, 8uLL) != 8)
  {
    v27 = 0;
    v8 = -1;
    goto LABEL_21;
  }
  v27 = 0;
  v8 = -1;
  v9 = 8;
  while (1)
  {
    v10 = v56[0];
    if (HIDWORD(v56[0]) != 1380206665 || !BoolForKey)
      break;
    LOWORD(Size) = 0;
    if (IIOImageReadSession::getBytesAtOffset(a2, &Size, v9 + 16, 2uLL) != 2)
      goto LABEL_21;
    switch(BYTE1(Size))
    {
      case 0:
      case 4:
        v27 = CFSTR("Gray");
        break;
      case 2:
      case 3:
      case 6:
        v27 = CFSTR("RGB");
        break;
      default:
        break;
    }
    v8 = (BYTE1(Size) & 0xFD) == 4;
LABEL_18:
    v9 += bswap32(v10) + 12;
    if (IIOImageReadSession::getBytesAtOffset(a2, v56, v9, 8uLL) != 8)
      goto LABEL_21;
  }
  v12 = bswap32(HIDWORD(v56[0]));
  if (v12 == 1229209940)
    goto LABEL_21;
  if (v12 != 1633899596)
    goto LABEL_18;
  if (IIOImageReadSession::getBytesAtOffset(a2, v56, v9 + 8, 8uLL) == 8)
  {
    IIONumber::IIONumber((IIONumber *)&Size, bswap32(HIDWORD(v56[0])));
    IIODictionary::setObjectForKeyGroup(a3, v35[1], CFSTR("LoopCount"), CFSTR("{PNG}"));
    IIONumber::~IIONumber((IIONumber *)&Size);
  }
LABEL_21:
  v13 = IIOImageReadSession::globalInfoForType(a2, 1095781959);
  if (v13
    || (LODWORD(Size) = 0,
        LODWORD(v29[0]) = 0,
        (*(void (**)(IIO_Reader_PNG *, IIOImageReadSession *, IIODictionary *, CFMutableArrayRef *, void **))(*(_QWORD *)this + 32))(this, a2, a4, &Size, v29), (v13 = IIOImageReadSession::globalInfoForType(a2, 1095781959)) != 0))
  {
    IIONumber::IIONumber((IIONumber *)v55, *((_DWORD *)v13 + 8));
    IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v55, CFSTR("CanvasPixelWidth"), CFSTR("{PNG}"));
    IIONumber::~IIONumber((IIONumber *)v55);
    IIONumber::IIONumber((IIONumber *)v54, *((_DWORD *)v13 + 9));
    IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v54, CFSTR("CanvasPixelHeight"), CFSTR("{PNG}"));
    IIONumber::~IIONumber((IIONumber *)v54);
    Size = 0;
    v35[0] = 0;
    v35[1] = 0;
    IIOArray::IIOArray((IIOArray *)&Size);
    v14 = *((_QWORD *)v13 + 1);
    for (i = *((_QWORD *)v13 + 2); v14 != i; v14 += 34)
    {
      v16 = *(unsigned __int16 *)(v14 + 20);
      v17 = *(unsigned __int16 *)(v14 + 22);
      v29[0] = 0;
      v29[1] = 0;
      *(_QWORD *)&v30 = 0;
      IIODictionary::IIODictionary((IIODictionary *)v29);
      v18 = (float)v16 / (float)v17;
      if (v18 < 0.05)
        v18 = 0.05;
      IIONumber::IIONumber((IIONumber *)v53, v18);
      IIODictionary::setObjectForKey((uint64_t)v29, (uint64_t)v53, CFSTR("DelayTime"));
      IIONumber::~IIONumber((IIONumber *)v53);
      IIOArray::addObject(&Size, v29[1]);
      IIODictionary::~IIODictionary((IIODictionary *)v29);
    }
    IIODictionary::setObjectForKeyGroup(a3, v35[0], CFSTR("FrameInfo"), CFSTR("{PNG}"));
    IIOArray::~IIOArray((IIOArray *)&Size);
    v19 = 1;
    if (BoolForKey)
    {
LABEL_28:
      v20 = (const void **)MEMORY[0x1E0C9AE50];
      if (v8 != -1)
      {
        v21 = (const void **)MEMORY[0x1E0C9AE40];
        if (v8)
          v21 = (const void **)MEMORY[0x1E0C9AE50];
        IIODictionary::setObjectForKeyGroup(a3, *v21, CFSTR("kCGImageSourcePropertyHasAlpha"), CFSTR("{PNG}"));
      }
      if (v27)
        IIODictionary::setObjectForKeyGroup(a3, v27, CFSTR("kCGImageSourcePropertyColorModel"), CFSTR("{PNG}"));
      memset(v52, 0, sizeof(v52));
      IIODictionary::IIODictionary((IIODictionary *)v52);
      memset(v51, 0, sizeof(v51));
      IIODictionary::IIODictionary((IIODictionary *)v51);
      v50 = 0;
      v49 = 0u;
      v48 = 0u;
      v47 = 0u;
      v46 = 0u;
      v45 = 0u;
      v44 = 0u;
      v43 = 0u;
      v42 = 0u;
      v41 = 0u;
      v40 = 0u;
      v39 = 0u;
      v38 = 0u;
      v37 = 0u;
      *(_OWORD *)v35 = 0u;
      v36 = 0u;
      IIODictionary::setObjectForKey((IIODictionary *)v52, *v20, CFSTR("kCGImageSourceSkipMetadata"));
      Mutable = CGImageMetadataCreateMutable();
      v32 = 0u;
      v33 = 0u;
      v30 = 0u;
      v31 = 0u;
      *(_OWORD *)v29 = 0u;
      BYTE14(v30) = v19;
      Size = IIOImageReadSession::getSize(a2);
      BYTE5(v44) = IIOImageReadSession::isFinal(a2);
      IIOImageReadSession::rewind((uint64_t)a2);
      PNGReadPlugin::InitializePluginData(a2, (IIODictionary *)v52, (IIODictionary *)v51, Mutable, &v50, (uint64_t)&Size, (uint64_t)v29, 0);
      if (v50)
      {
        v23 = CGColorSpaceCopyICCData(v50);
        if (v23)
        {
          IIODictionary::setObjectForKeyGroup(a3, v23, CFSTR("kCGImageSourceColorSpace"), CFSTR("{PNG}"));
          CFRelease(v23);
        }
        CFRelease(v50);
      }
      if (Mutable)
        CFRelease(Mutable);
      IIODictionary::~IIODictionary((IIODictionary *)v51);
      IIODictionary::~IIODictionary((IIODictionary *)v52);
    }
  }
  else
  {
    v19 = 0;
    if (BoolForKey)
      goto LABEL_28;
  }
  return 0;
}

void sub_187E9C894(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  IIONumber::~IIONumber((IIONumber *)&a26);
  _Unwind_Resume(a1);
}

void IIOArray::addObject(CFMutableArrayRef *this, const void *a2)
{
  if (a2 && this[1])
  {
    if (*((_BYTE *)this + 16))
      CFArrayAppendValue(this[1], a2);
    else
      LogError("addObject", 630, "IIOArray -- addObject for immutable array\n");
  }
}

uint64_t HEIFReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, __IOSurface **a4, uint64_t a5, uint64_t *a6)
{
  int v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  IIOImageRead *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;

  *((_DWORD *)this + 52) = *((_QWORD *)a2 + 9);
  *((_BYTE *)this + 343) = 0;
  *((_BYTE *)this + 408) = 1;
  *((_DWORD *)this + 26) = 1;
  if ((gIIODebugFlags & 0x20000) != 0)
  {
    v11 = *((_DWORD *)this + 51);
    v12 = v11 >> 24;
    v13 = MEMORY[0x1E0C80978];
    if (v11 < 0)
    {
      v14 = __maskrune(v12, 0x40000uLL);
      v11 = *((_DWORD *)this + 51);
    }
    else
    {
      v14 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v12 + 60) & 0x40000;
    }
    if (v14)
      v15 = (v11 >> 24);
    else
      v15 = 46;
    v16 = v11 << 8 >> 24;
    if (v11 << 8 < 0)
    {
      v17 = __maskrune(v16, 0x40000uLL);
      v11 = *((_DWORD *)this + 51);
    }
    else
    {
      v17 = *(_DWORD *)(v13 + 4 * v16 + 60) & 0x40000;
    }
    if (v17)
      v18 = (v11 << 8 >> 24);
    else
      v18 = 46;
    v19 = (__int16)v11 >> 8;
    if (v11 << 16 < 0)
    {
      v20 = __maskrune(v19, 0x40000uLL);
      v11 = *((_DWORD *)this + 51);
    }
    else
    {
      v20 = *(_DWORD *)(v13 + 4 * v19 + 60) & 0x40000;
    }
    if (v20)
      v21 = ((__int16)v11 >> 8);
    else
      v21 = 46;
    if ((v11 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v13 + 4 * (char)v11 + 60) & 0x40000) != 0)
        goto LABEL_22;
    }
    else if (__maskrune((char)v11, 0x40000uLL))
    {
LABEL_22:
      v22 = *((char *)this + 204);
LABEL_25:
      ImageIOLog("♦️  '%c%c%c%c' [%s] %s\n", v15, v18, v21, v22, iioTypeStr[a3], "virtual OSStatus HEIFReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      goto LABEL_26;
    }
    v22 = 46;
    goto LABEL_25;
  }
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  v23 = IIOImageReadSession::globalInfoForType(*((IIOImageReadSession **)this + 3), 1212500294);
  if (!v23)
  {
    _cg_jpeg_mem_term("decodeImageImp", 2960, "*** ERROR: globalHEIFInfo is NULL\n");
    return 4294967246;
  }
  *((_DWORD *)this + 124) = GlobalHEIFInfo::resolvedIndexForIndex(v23, *((unsigned int *)this + 52));
  if (a3 == 3)
  {
    v25 = *((_QWORD *)a2 + 1);
    v26 = *((_QWORD *)a2 + 2);
    v27 = *((double *)a2 + 3);
    v28 = *((double *)a2 + 4);
    v29 = *((double *)a2 + 5);
    v30 = *((double *)a2 + 6);
    v31 = *((double *)a2 + 7);
    v32 = *((double *)a2 + 8);
    v33 = IIOImageSource::reader(a2);
    v34 = (*(uint64_t (**)(IIOReadPlugin *, uint64_t, uint64_t, uint64_t, double, double, double, double, double, double))(*(_QWORD *)this + 200))(this, v25, v26, v33, v27, v28, v29, v30, v31, v32);
    if (a6)
    {
      v24 = 0;
      *a6 = v34;
      return v24;
    }
    return 4294967246;
  }
  if (a3 != 1 || !a4)
    return 4294967246;
  if (*a4)
  {
    v24 = HEIFReadPlugin::decodeIntoIOSurface(this, a2, *a4);
    if ((gIIODebugFlags & 0x2000000) != 0)
      LogSurfaceFormat(*a4, "*ioSurface", "decodeImageImp", 2970);
    if ((_DWORD)v24)
      _cg_jpeg_mem_term("decodeImageImp", 2972, "*** decodeIntoIOSurface - err = %d\n", v24);
  }
  else
  {
    v35 = *((_QWORD *)a2 + 2);
    v36 = IIOImageSource::reader(a2);
    v24 = (*(uint64_t (**)(IIOReadPlugin *, uint64_t, uint64_t, __IOSurface **, _QWORD))(*(_QWORD *)this + 216))(this, v35, v36, a4, 0);
    if ((gIIODebugFlags & 0x2000000) != 0)
      LogSurfaceFormat(*a4, "*ioSurface", "decodeImageImp", 2978);
  }
  return v24;
}

uint64_t HEIFReadPlugin::copyImageBlockSetImp(uint64_t a1, const void *a2, const void *a3, __CFDictionary *a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  IIOImageRead *v19;
  const __CFString **v20;
  const __CFString *v21;
  const void *v22;
  unsigned int Uint32ForKey;
  uint64_t v24;
  unsigned int v25;
  _OWORD *v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  __int128 v30;
  int BlockArray;
  double v32;
  double v33;
  double v34;
  double v35;
  IIOImageRead **v36;
  _BOOL4 v37;
  int v38;
  uint64_t v39;
  unsigned int v40;
  double v41;
  double v42;
  double v43;
  unsigned int v44;
  int v45;
  const char *v46;
  BOOL v47;
  uint64_t v48;
  double v49;
  double v50;
  IIOImageRead *Size;
  IIOImageRead *v52;
  const UInt8 *v53;
  uint64_t v54;
  CFDataRef v55;
  int v56;
  const char *v57;
  HEIFMainImage *v58;
  int v59;
  int DecodePixelFormatForBitDepth;
  int v61;
  BOOL v62;
  int v63;
  int v64;
  __n128 v65;
  int v66;
  int v67;
  const char *v68;
  int v69;
  double v70;
  int v71;
  CFTypeRef *v72;
  __IOSurface *IOSurface;
  __IOSurface *v74;
  int PixelFormatForBitDepth;
  uint64_t v76;
  __IOSurface *SurfaceWithGainMapApplied;
  __IOSurface *v78;
  __IOSurface *v79;
  __IOSurface *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  __IOSurface *SurfaceWithToneMapApplied;
  int IsPlanar;
  int PixelFormatType;
  int v88;
  unsigned int v89;
  int v90;
  char *BaseAddress;
  unint64_t BytesPerRow;
  unint64_t Height;
  int Width;
  size_t v95;
  unsigned int v96;
  __n128 v97;
  char *v98;
  unsigned int i;
  unsigned int v100;
  char *v101;
  size_t v102;
  int8x16_t v103;
  uint64_t v104;
  unsigned int v105;
  int v106;
  uint64_t v107;
  unsigned int v108;
  int v109;
  int v110;
  uint64_t v111;
  uint64_t v112;
  __n128 v113;
  IIOImageRead **v114;
  unint64_t v115;
  int v116;
  BOOL v118;
  HEIFMainImage *HEIFMainImageAtIndex;
  HEIFMainImage *v120;
  unsigned int TileWidth;
  int TileLength;
  uint64_t v123;
  unsigned int v124;
  __int128 v125;
  __int128 v126;
  _BOOL4 v127;
  const char **v128;
  __int128 v130;
  const void *v131;
  _QWORD *v132;
  void *value;
  _BOOL4 v134;
  const void *v135;
  const __CFAllocator *v136;
  const __CFAllocator *v137;
  char v138;
  int v139;
  const __CFData *v140;
  uint64_t v141;
  char *v142;
  uint8_t permuteMap[4];
  _BYTE v144[24];
  CFTypeRef cf;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  void *v149;
  int v150;
  CFTypeRef v151;
  CFTypeRef v152;
  CFTypeRef v153;
  vImage_Buffer dest;
  const __CFDictionary *v155[3];
  size_t v156[3];
  CGRect v157;
  CGRect v158;

  memset(v155, 0, sizeof(v155));
  v156[0] = 0;
  IIODictionary::IIODictionary((IIODictionary *)v155, a4);
  if (!*(_QWORD *)(a1 + 24))
  {
    v29 = 0;
    goto LABEL_204;
  }
  IIO_LoadHEIFSymbols();
  v19 = IIOImageReadSession::globalInfoForType(*(IIOImageReadSession **)(a1 + 24), 1212500294);
  if (GlobalHEIFInfo::hasHEIFSequence(v19))
    v139 = IIOImageRead::trustedURL(v19);
  else
    v139 = 0;
  IIOReadPlugin::debugCopyBlockSet((const char *)a1, a3, a5, a6, a7, a8, a9, a10);
  v20 = (const __CFString **)MEMORY[0x1E0C9DAC8];
  if (*(_BYTE *)(a1 + 484) || *(_BYTE *)(a1 + 485))
  {
    *(_BYTE *)(a1 + 343) = 1;
    v21 = *v20;
  }
  else
  {
    v116 = *(unsigned __int8 *)(a1 + 408);
    v118 = a8 != a10 || a7 != a9 || v116 == 1;
    v21 = (const __CFString *)*MEMORY[0x1E0C9DAC8];
    if (v118
      && v116 != 1
      && (IIODictionary::containsKey((IIODictionary *)v155, (const __CFString *)*MEMORY[0x1E0C9DAC8]) & 1) == 0
      && !*(_BYTE *)(a1 + 491))
    {
      HEIFMainImageAtIndex = (HEIFMainImage *)GlobalHEIFInfo::getHEIFMainImageAtIndex(v19, *(_DWORD *)(a1 + 496));
      if (!*(_BYTE *)(a1 + 490) && *(unsigned __int16 *)(a1 + 316) <= 1u)
      {
        v120 = HEIFMainImageAtIndex;
        TileWidth = HEIFMainImage::getTileWidth(HEIFMainImageAtIndex);
        TileLength = HEIFMainImage::getTileLength(v120);
        if (TileWidth)
        {
          if (TileLength)
          {
            if (TileWidth != *(_DWORD *)(a1 + 292))
            {
              v124 = *(_DWORD *)(a1 + 296);
              if (TileLength != v124 && *(unsigned int *)(a1 + 300) * (unint64_t)v124 >= 0x1000001)
              {
                LODWORD(v146) = 0;
                v125 = *(_OWORD *)(a1 + 300);
                *(_OWORD *)&dest.data = *(_OWORD *)(a1 + 284);
                *(_OWORD *)&dest.width = v125;
                if ((gIIODebugFlags & 0x30000) != 0)
                  ImageIOLog("    decoding multi tiles: {%g,%g,%g,%g} {%g,%g} - subsample: %d\n", a5, a6, a7, a8, a9, a10, *(unsigned __int16 *)(a1 + 316));
                v29 = HEIFReadPlugin::copyImageBlockSetTiles(a1, a2, (uint64_t)a3, v155, TileWidth, a5, a6, a7, a8, v123, &v146);
                v126 = *(_OWORD *)&dest.width;
                *(_OWORD *)(a1 + 284) = *(_OWORD *)&dest.data;
                *(_OWORD *)(a1 + 300) = v126;
                if (v29 || (_DWORD)v146 == 1)
                  goto LABEL_204;
                _cg_jpeg_mem_term("copyImageBlockSetImp", 1965, "*** ERROR: tiled decoding failed - falling back to standard decode\n");
              }
            }
          }
        }
      }
    }
  }
  if (IIODictionary::containsKey((IIODictionary *)v155, v21) && !*(_BYTE *)(a1 + 484))
  {
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("    got 'kCGImageBlockTileRequest'\n");
    v22 = a2;
    Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v155, v21);
    if (Uint32ForKey - 1 >= 0xFF)
      v25 = Uint32ForKey;
    else
      v25 = 256;
    v26 = (_OWORD *)(a1 + 284);
    if (v25 <= *(_DWORD *)(a1 + 292) && v25 <= *(_DWORD *)(a1 + 296))
    {
      v130 = *(_OWORD *)(a1 + 300);
      *(_OWORD *)&dest.data = *v26;
      *(_OWORD *)&dest.width = v130;
      LODWORD(v146) = 0;
      if (v25)
      {
        if ((gIIODebugFlags & 0x30000) != 0)
          ImageIOLog("    decoding multi tiles [%d]: {%g,%g,%g,%g} {%g,%g}\n", v25, a5, a6, a7, a8, a9, a10);
        v28 = HEIFReadPlugin::copyImageBlockSetTiles(a1, v22, (uint64_t)a3, v155, v25, a5, a6, a7, a8, v24, &v146);
LABEL_21:
        v29 = v28;
        v30 = *(_OWORD *)&dest.width;
        *v26 = *(_OWORD *)&dest.data;
        *(_OWORD *)(a1 + 300) = v30;
        if (!v28 && (_DWORD)v146 != 1)
        {
          *(_DWORD *)(a1 + 104) = 1;
          a2 = v22;
          goto LABEL_24;
        }
LABEL_204:
        v127 = 0;
        if (!a3)
          goto LABEL_195;
        goto LABEL_194;
      }
    }
    else
    {
      v27 = *(_OWORD *)(a1 + 300);
      *(_OWORD *)&dest.data = *v26;
      *(_OWORD *)&dest.width = v27;
      LODWORD(v146) = 0;
    }
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("    decoding single tile: {%g,%g,%g,%g} {%g,%g}\n", a5, a6, a7, a8, a9, a10);
    v28 = HEIFReadPlugin::copyImageBlockSetSingleTile(a1, v22, (uint64_t)a3, v155, &v146, a5, a6, a7, a8);
    goto LABEL_21;
  }
LABEL_24:
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("    _blockCount = %d\n", *(_DWORD *)(a1 + 104));
  v141 = *(unsigned int *)(a1 + 112);
  IIOReadPlugin::debugCopyBlockSet((const char *)a1, a3, a5, a6, a7, a8, a9, a10);
  BlockArray = IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, *(unsigned int *)(a1 + 104));
  if (IIOReadPlugin::getCachedBlocks((IIOReadPlugin *)a1, v32, v33, v34))
  {
    v36 = *(IIOImageRead ***)(a1 + 24);
    v135 = a3;
    if (v36)
      v134 = IIOImageReadSession::mapData(v36);
    else
      v134 = 0;
    v39 = *(unsigned int *)(a1 + 112);
    if (v39 < *(_DWORD *)(a1 + 116))
    {
      v142 = 0;
      v140 = 0;
      v132 = (_QWORD *)(a1 + 292);
      v138 = 1;
      v137 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v136 = (const __CFAllocator *)*MEMORY[0x1E0C9AE20];
      value = (void *)*MEMORY[0x1E0C9AE40];
      while (1)
      {
        if (*(_QWORD *)(*(_QWORD *)(a1 + 96) + 8 * (v39 - v141)))
          _cg_jpeg_mem_term("copyImageBlockSetImp", 2023, "*** _blockArray[%d] was cached - and already allocated\n", v39 - v141);
        v40 = *(_DWORD *)(a1 + 296);
        v41 = (double)(v40 * v39);
        LODWORD(a8) = *(_DWORD *)(a1 + 292);
        LODWORD(v35) = *(_DWORD *)(a1 + 264);
        v42 = (double)*(unint64_t *)&v35;
        v43 = (double)v40 + v41 <= v42 ? (double)v40 : v42 - (double)(v40 * v39);
        v44 = *(_DWORD *)(a1 + 300);
        v153 = 0;
        v45 = IIOCreateCMPhotoDecompressionSession((uint64_t)&v153);
        BlockArray = v45;
        if (!v45)
          break;
        v46 = IIOCMErrorString(v45);
        _cg_jpeg_mem_term("copyImageBlockSetImp", 2052, "*** CMPhotoDecompressionSessionCreate  err = %s [%d]\n", v46, BlockArray);
LABEL_41:
        a8 = (double)*(unint64_t *)&a8;
        v157.origin.x = 0.0;
        v157.origin.y = v41;
        v157.size.width = a8;
        v157.size.height = v43;
        *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8 * (v39 - v141)) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, v142, v156[0], v157, *(unsigned int *)(a1 + 300), *(unsigned __int8 *)(a1 + 343));
        v47 = CGRectEqualToRect(*(CGRect *)(a1 + 120), *MEMORY[0x1E0C9D628]);
        v48 = 0;
        if (!v47)
        {
          v158.origin.x = 0.0;
          v158.origin.y = v41;
          v158.size.width = a8;
          v158.size.height = v43;
          *(CGRect *)(&v35 - 2) = CGRectUnion(*(CGRect *)(a1 + 120), v158);
          v41 = v49;
          a8 = v35;
          v43 = v50;
        }
        *(_QWORD *)(a1 + 120) = v48;
        *(double *)(a1 + 128) = v41;
        *(double *)(a1 + 136) = a8;
        *(double *)(a1 + 144) = v43;
        if (++v39 >= (unint64_t)*(unsigned int *)(a1 + 116))
          goto LABEL_160;
      }
      v151 = 0;
      v152 = 0;
      v150 = 0;
      v149 = 0;
      Size = IIOImageReadSession::getSize(*(IIOImageReadSession **)(a1 + 24));
      v52 = IIOImageReadSession::retainBytePointer(*(IIOImageReadSession **)(a1 + 24), (const __CFData **)&v149, 1);
      v53 = (const UInt8 *)v52;
      if (!v52)
      {
        LogError("copyImageBlockSetImp", 2068, "*** ERROR: retainBytePointer failed\n");
        a3 = v135;
        v37 = v134;
        goto LABEL_190;
      }
      v54 = *(_QWORD *)(a1 + 456);
      v55 = v140;
      if (v54)
      {
        if (*(_QWORD *)(a1 + 464))
          Size = *(IIOImageRead **)(a1 + 464);
        else
          v54 = 0;
        v53 = (const UInt8 *)v52 + v54;
      }
      if (!v140)
      {
        v55 = CFDataCreateWithBytesNoCopy(v137, v53, (CFIndex)Size, v136);
        if (!v55)
        {
          v140 = 0;
          BlockArray = 0;
          goto LABEL_156;
        }
      }
      v140 = v55;
      v56 = gFunc_CMPhotoDecompressionSessionCreateContainer(v153, 0, v55, &v150, &v152);
      BlockArray = v56;
      if (v56)
      {
        v57 = IIOCMErrorString(v56);
        _cg_jpeg_mem_term("copyImageBlockSetImp", 2087, "*** CMPhotoDecompressionSessionCreateContainer  err = %s [%d]\n", v57, BlockArray);
LABEL_156:
        CFRelease(v153);
        if (v149)
        {
          v114 = *(IIOImageRead ***)(a1 + 24);
          if (v114)
            IIOImageReadSession::releaseBytePointer(v114, v149);
        }
        goto LABEL_41;
      }
      v146 = 0;
      v147 = 0;
      v148 = 0;
      IIODictionary::IIODictionary((IIODictionary *)&v146);
      HEIFReadPlugin::updateHardwareDecodeOptions((IIODictionary **)a1, (IIODictionary *)&v146, v155);
      cf = 0;
      if (*(_BYTE *)(a1 + 485))
      {
        v58 = (HEIFMainImage *)GlobalHEIFInfo::getHEIFMainImageAtIndex(v19, *(_DWORD *)(a1 + 496));
        v59 = HEIFMainImage::bitDepth(v58);
        DecodePixelFormatForBitDepth = HEIFReadPlugin::getDecodePixelFormatForBitDepth((HEIFReadPlugin *)a1, v59);
        goto LABEL_68;
      }
      if (!*(_BYTE *)(a1 + 484))
      {
        DecodePixelFormatForBitDepth = HEIFReadPlugin::getPixelFormatForBitDepth((HEIFReadPlugin *)a1, *(unsigned __int16 *)(a1 + 304), *(IIODictionary **)(a1 + 48));
        goto LABEL_68;
      }
      v61 = *(_DWORD *)(a1 + 324);
      if (v61 == 1196573017)
      {
        v62 = *(_BYTE *)(a1 + 492) == 0;
        v63 = 843264310;
        v64 = 1278226742;
      }
      else
      {
        if (v61 != 1380401696)
        {
          DecodePixelFormatForBitDepth = 0;
          goto LABEL_68;
        }
        v62 = *(_BYTE *)(a1 + 492) == 0;
        v63 = 1815491698;
        v64 = 2019963440;
      }
      if (v62)
        DecodePixelFormatForBitDepth = v64;
      else
        DecodePixelFormatForBitDepth = v63;
LABEL_68:
      IIONumber::IIONumber((IIONumber *)v144, DecodePixelFormatForBitDepth);
      IIODictionary::setObjectForKey((uint64_t)&v146, (uint64_t)v144, *(const void **)gIIO_kCMPhotoDecompressionOption_OutputPixelFormat);
      IIONumber::~IIONumber((IIONumber *)v144);
      IIODictionary::setObjectForKey((IIODictionary *)&v146, value, *(const __CFString **)gIIO_kCMPhotoDecompressionOption_ApplyTransform);
      HEIFReadPlugin::updateCreateImageOptions((HEIFReadPlugin *)a1, (IIODictionary *)&v146, *(IIODictionary **)(a1 + 48));
      if (v139)
      {
        v66 = gFunc_CMPhotoDecompressionContainerCreateSequenceContainer(v152, 0, 0, &v151);
        v67 = v66;
        if (v66)
        {
          v68 = IIOCMErrorString(v66);
          v65 = _cg_jpeg_mem_term("copyImageBlockSetImp", 2124, "*** CMPhotoDecompressionSessionCreateContainer[sequence] err = %s [%d]\n", v68, v67);
        }
        if (*(unsigned __int8 *)(a1 + 216) < 2u || *(_BYTE *)(a1 + 490))
        {
          v69 = gFunc_CMPhotoDecompressionContainerCreateImageForIndex(v151, *(unsigned int *)(a1 + 496), v147, 2, &cf, v65);
          BlockArray = v69;
          if (v69)
          {
            *(_QWORD *)&v70 = _cg_jpeg_mem_term("copyImageBlockSetImp", 2141, "CMPhotoDecompressionContainerCreateImageForIndex(%s)  err=%d\n", (const char *)*(unsigned int *)(a1 + 496), v69).n128_u64[0];
            goto LABEL_75;
          }
          goto LABEL_84;
        }
        v72 = &v151;
      }
      else
      {
        if (*(unsigned __int8 *)(a1 + 216) < 2u || *(_BYTE *)(a1 + 490))
        {
          v71 = gFunc_CMPhotoDecompressionContainerCreateImageForIndex(v152, *(unsigned int *)(a1 + 496), v147, 2, &cf, v65);
          goto LABEL_83;
        }
        v72 = &v152;
      }
      v71 = gFunc_CMPhotoDecompressionContainerCreateThumbnailImageForIndex(*v72, *(unsigned int *)(a1 + 496), 0, v147, 2, &cf, v65);
LABEL_83:
      BlockArray = v71;
      if (v71)
      {
LABEL_75:
        if (BlockArray == -15470)
        {
          LogError("copyImageBlockSetImp", 2193, "*** ERROR: CMPhotoDecompressionContainerCreateImageForIndex failed (kCMPhotoError_XPCError) - mediaserverd is not running? - no way to decode a HEIC\n", v70);
          v138 = 0;
          BlockArray = -15470;
        }
LABEL_153:
        if (v151)
          CFRelease(v151);
        CFRelease(v152);
        IIODictionary::~IIODictionary((IIODictionary *)&v146);
        goto LABEL_156;
      }
LABEL_84:
      if (*(_BYTE *)(a1 + 484))
      {
        if ((gIIODebugFlags & 0x300000) != 0)
          ImageIOLog("☀️  _requestedApplyGainMap --> createSurfaceWithGainMapApplied\n");
        IOSurface = (__IOSurface *)gFunc_CVPixelBufferGetIOSurface(cf);
        v74 = IOSurface;
        if ((gIIODebugFlags & 0x2000000) != 0)
          LogSurfaceFormat(IOSurface, "surface", "copyImageBlockSetImp", 2214);
        PixelFormatForBitDepth = HEIFReadPlugin::getPixelFormatForBitDepth((HEIFReadPlugin *)a1, *(unsigned __int16 *)(a1 + 304), *(IIODictionary **)(a1 + 48));
        if (PixelFormatForBitDepth == 1815491698)
        {
          if (*(_BYTE *)(a1 + 313))
            PixelFormatForBitDepth = 1380411457;
          else
            PixelFormatForBitDepth = 1815491698;
        }
        *(_DWORD *)(a1 + 440) = PixelFormatForBitDepth;
        SurfaceWithGainMapApplied = HEIFReadPlugin::createSurfaceWithGainMapApplied(a1, (uint64_t)v152, v76, v19, v74);
        v78 = SurfaceWithGainMapApplied;
        if (!SurfaceWithGainMapApplied)
          goto LABEL_106;
        if ((gIIODebugFlags & 0x2000000) != 0)
          LogSurfaceFormat(SurfaceWithGainMapApplied, "outputSurface", "copyImageBlockSetImp", 2223);
      }
      else
      {
        if (!*(_BYTE *)(a1 + 485))
          goto LABEL_106;
        if ((gIIODebugFlags & 0x300000) != 0)
          ImageIOLog("☀️  _requestedApplyToneMap --> createSurfaceWithToneMapApplied\n");
        v79 = (__IOSurface *)gFunc_CVPixelBufferGetIOSurface(cf);
        v80 = v79;
        if ((gIIODebugFlags & 0x2000000) != 0)
          LogSurfaceFormat(v79, "surface", "copyImageBlockSetImp", 2236);
        v81 = HEIFReadPlugin::getPixelFormatForBitDepth((HEIFReadPlugin *)a1, *(unsigned __int16 *)(a1 + 304), *(IIODictionary **)(a1 + 48));
        SurfaceWithToneMapApplied = HEIFReadPlugin::createSurfaceWithToneMapApplied(v81, v82, v83, v84, v80, v81, *(const __CFString **)(a1 + 512), *(unsigned __int8 *)(a1 + 489));
        v78 = SurfaceWithToneMapApplied;
        if (!SurfaceWithToneMapApplied)
          goto LABEL_106;
        if ((gIIODebugFlags & 0x2000000) != 0)
          LogSurfaceFormat(SurfaceWithToneMapApplied, "outputSurface", "copyImageBlockSetImp", 2242);
      }
      dest.data = 0;
      gFunc_CVPixelBufferCreateWithIOSurface(0, v78, 0, &dest);
      CFRelease(v78);
      CFRelease(cf);
      cf = dest.data;
LABEL_106:
      v142 = (char *)_ImageIO_Malloc(v44 * (unint64_t)v40, *(_QWORD *)(a1 + 384), v156, (uint64_t)kImageMalloc_HEIF_Data[0], *(_DWORD *)(a1 + 432), 0, 0);
      if (!v142)
      {
        _cg_jpeg_mem_term("copyImageBlockSetImp", 2256, "failed to alloc imageData (%ld bytes)\n", v44 * (unint64_t)v40);
        IIODictionary::~IIODictionary((IIODictionary *)&v146);
        a3 = v135;
        v37 = v134;
        goto LABEL_190;
      }
      gFunc_CVPixelBufferLockBaseAddress(cf, 0);
      IsPlanar = gFunc_CVPixelBufferIsPlanar(cf);
      PixelFormatType = gFunc_CVPixelBufferGetPixelFormatType(cf);
      v88 = PixelFormatType;
      if (IsPlanar)
      {
        v89 = PixelFormatType >> 24;
        if (PixelFormatType < 0)
          v90 = __maskrune(PixelFormatType >> 24, 0x40000uLL);
        else
          v90 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v89 + 60) & 0x40000;
        if (v90)
          v104 = v89;
        else
          v104 = 46;
        v105 = v88 << 8 >> 24;
        if (v88 << 8 < 0)
          v106 = __maskrune(v88 << 8 >> 24, 0x40000uLL);
        else
          v106 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v105 + 60) & 0x40000;
        if (v106)
          v107 = v105;
        else
          v107 = 46;
        v108 = (__int16)v88 >> 8;
        if (v88 << 16 < 0)
          v109 = __maskrune((__int16)v88 >> 8, 0x40000uLL);
        else
          v109 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v108 + 60) & 0x40000;
        if ((v88 << 24) <= 0x7F000000)
          v110 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v88 + 60) & 0x40000;
        else
          v110 = __maskrune((char)v88, 0x40000uLL);
        if (v109)
          v111 = v108;
        else
          v111 = 46;
        if (v110)
          v112 = (char)v88;
        else
          v112 = 46;
        LogError("copyImageBlockSetImp", 2267, "*** 'BGRA' request returned planar data - not handled '%c%c%c%c'\n", v104, v107, v111, v112);
      }
      else
      {
        BaseAddress = (char *)gFunc_CVPixelBufferGetBaseAddress(cf);
        BytesPerRow = gFunc_CVPixelBufferGetBytesPerRow(cf);
        Height = gFunc_CVPixelBufferGetHeight(cf);
        v131 = a2;
        Width = gFunc_CVPixelBufferGetWidth(cf);
        if (BytesPerRow >= *(unsigned int *)(a1 + 300))
          v95 = *(unsigned int *)(a1 + 300);
        else
          v95 = BytesPerRow;
        if (Height >= *(unsigned int *)(a1 + 296))
          v96 = *(_DWORD *)(a1 + 296);
        else
          v96 = Height;
        *gCrashMessage = 0;
        snprintf(gCrashMessage, 0x200uLL, "ImageIO: copyImageBlockSetImp: pixelBuf: %dx%d (rb:%d)  blockSet: %dx%d (rb:%d)  src: %p  dst: %p\n", *(_DWORD *)(a1 + 292), *(_DWORD *)(a1 + 296), *(_DWORD *)(a1 + 300), Width, Height, BytesPerRow, BaseAddress, v142);
        qword_1ECDD8318 = gCrashMessage;
        v98 = v142;
        for (i = v96; i; --i)
        {
          memcpy(v98, BaseAddress, v95);
          v98 += *(unsigned int *)(a1 + 300);
          BaseAddress += BytesPerRow;
        }
        v100 = *(_DWORD *)(a1 + 296);
        a2 = v131;
        if (v100 > v96)
        {
          v101 = &BaseAddress[-BytesPerRow];
          do
          {
            memcpy(v98, v101, v95);
            v98 += *(unsigned int *)(a1 + 300);
            ++v96;
            v100 = *(_DWORD *)(a1 + 296);
          }
          while (v96 < v100);
        }
        qword_1ECDD8318 = 0;
        if (v88 == 1111970369)
        {
          if (!*(_BYTE *)(a1 + 405))
            goto LABEL_209;
          if ((gIIODebugFlags & 0x30000) != 0)
          {
            ImageIOLog("    vImagePermuteChannels_ARGB8888:   BGRX -> RGBX\n");
            v100 = *(_DWORD *)(a1 + 296);
          }
          dest.data = v142;
          dest.height = v100;
          v102 = *(unsigned int *)(a1 + 300);
          dest.width = *(unsigned int *)(a1 + 292);
          dest.rowBytes = v102;
          *(_DWORD *)permuteMap = 50331906;
          vImagePermuteChannels_ARGB8888(&dest, &dest, permuteMap, 0x10u);
          if (!*(_BYTE *)(a1 + 405))
          {
LABEL_209:
            if (*(_BYTE *)(a1 + 492) && !*(_BYTE *)(a1 + 493))
            {
              dest.data = v142;
              v103.i64[0] = *v132;
              v103.i64[1] = HIDWORD(*v132);
              *(int8x16_t *)&dest.height = vextq_s8(v103, v103, 8uLL);
              dest.rowBytes = *(unsigned int *)(a1 + 300);
              vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
            }
          }
        }
      }
      v113.n128_f64[0] = gFunc_CVPixelBufferUnlockBaseAddress(cf, 0, v97);
      gFunc_CVPixelBufferRelease(v113);
      BlockArray = 0;
      goto LABEL_153;
    }
    v140 = 0;
    v138 = 1;
LABEL_160:
    v38 = v138 & 1;
    a3 = v135;
    v37 = v134;
    if (BlockArray)
    {
LABEL_190:
      v29 = 0;
      goto LABEL_191;
    }
  }
  else
  {
    v140 = 0;
    v37 = 0;
    v38 = 1;
    if (BlockArray)
      goto LABEL_190;
  }
  v29 = 0;
  v115 = *(unsigned int *)(a1 + 104);
  if (!a3)
    v38 = 0;
  if ((_DWORD)v115 && v38)
    v29 = IIOReadPlugin::imageBlockSetCreate(a1, (uint64_t)a3, v115, *(double *)(a1 + 136), *(double *)(a1 + 144), *(double *)(a1 + 120), *(double *)(a1 + 128), *(double *)(a1 + 136), *(double *)(a1 + 144), *(_QWORD *)(a1 + 96), a2);
LABEL_191:
  v127 = v37;
  if (v140)
    CFRelease(v140);
  if (a3)
LABEL_194:
    IIOReadPlugin::freeBlockArray((IIOReadPlugin *)a1);
LABEL_195:
  if (v127)
  {
    v128 = *(const char ***)(a1 + 24);
    if (v128)
      IIOImageReadSession::unmapData(v128);
  }
  IIODictionary::~IIODictionary((IIODictionary *)v155);
  return v29;
}

void sub_187E9DD04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  uint64_t v35;

  IIODictionary::~IIODictionary((IIODictionary *)&a35);
  IIODictionary::~IIODictionary((IIODictionary *)(v35 - 176));
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_HEIF::getImageCount(IIO_Reader_HEIF *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  GlobalHEIFInfo *v9;
  int v10;
  unsigned int NumberOfMainImages;
  uint64_t v12;
  char BoolForKey;
  char v15;

  IIO_LoadHEIFSymbols();
  v9 = IIOImageReadSession::globalInfoForType(a2, 1212500294);
  if (!v9)
  {
    v9 = (GlobalHEIFInfo *)operator new();
    GlobalHEIFInfo::GlobalHEIFInfo(v9);
    IIOImageReadSession::setGlobalInfo((IIOImageRead **)a2, 1212500294, v9, (void (*)(void *))globalHEIFInfoReleaseProc);
    if (a3)
    {
      if (IIODictionary::containsKey(a3, "shouldExposeMultiFrameContents"))
      {
        BoolForKey = IIODictionary::getBoolForKey(a3, CFSTR("shouldExposeMultiFrameContents"));
        GlobalHEIFInfo::setShouldExposeMultiFrameContents((uint64_t)v9, BoolForKey);
      }
      if (IIODictionary::containsKey(a3, "useImageSequence"))
      {
        v15 = IIODictionary::getBoolForKey(a3, CFSTR("useImageSequence"));
        GlobalHEIFInfo::setUseHEIFSequence((uint64_t)v9, v15);
      }
    }
  }
  v10 = (*(uint64_t (**)(IIO_Reader_HEIF *, GlobalHEIFInfo *, IIOImageReadSession *, IIODictionary *))(*(_QWORD *)this + 272))(this, v9, a2, a3);
  if (v10 << 16)
  {
    v12 = (__int16)v10;
    LogError("getImageCount", 1123, "*** ERROR: extractImageInfo failed: %d\n", (__int16)v10);
    NumberOfMainImages = 0;
    if (!a5)
      return v12;
    goto LABEL_4;
  }
  NumberOfMainImages = GlobalHEIFInfo::getNumberOfMainImages(v9);
  v12 = 0;
  if (a5)
LABEL_4:
    *a5 = NumberOfMainImages;
  return v12;
}

void sub_187E9DF1C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40D222D63DLL);
  _Unwind_Resume(a1);
}

uint64_t GlobalHEIFInfo::getNumberOfMainImages(GlobalHEIFInfo *this)
{
  uint64_t v1;

  v1 = (*((_QWORD *)this + 2) - *((_QWORD *)this + 1)) >> 3;
  if (*((_BYTE *)this + 68))
    return v1;
  else
    return (_DWORD)v1 != 0;
}

BOOL IIODictionary::containsKey(IIODictionary *this, const char *a2)
{
  const __CFDictionary *v3;
  _BOOL8 v4;
  _BYTE v6[16];
  void *key;

  IIOString::IIOString((IIOString *)v6, a2);
  v3 = (const __CFDictionary *)*((_QWORD *)this + 1);
  if (v3)
    v4 = CFDictionaryContainsKey(v3, key) != 0;
  else
    v4 = 0;
  IIOString::~IIOString((IIOString *)v6);
  return v4;
}

void sub_187E9DFBC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void IIOString::IIOString(IIOString *this, const char *a2)
{
  CFStringRef v3;

  *(_QWORD *)this = &off_1E1BB2F80;
  *((_QWORD *)this + 1) = 0;
  if (a2)
  {
    v3 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, 0x8000100u);
  }
  else
  {
    LogWarning("IIOString", 453, "IIOString -- 'str' is nil\n");
    v3 = 0;
  }
  *((_QWORD *)this + 2) = v3;
}

uint64_t IIOImageReadSession::setGlobalInfo(IIOImageRead **this, int a2, void *a3, void (*a4)(void *))
{
  return IIOImageRead::setGlobalInfoPtr(this[4], a2, a3, a4);
}

uint64_t IIOImageRead::setGlobalInfoPtr(IIOImageRead *this, int a2, void *a3, void (*a4)(void *))
{
  pthread_mutex_t *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  char *v22;
  __int128 v23;

  v8 = (pthread_mutex_t *)((char *)this + 88);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 88));
  v9 = *((_QWORD *)this + 19);
  v10 = *((_QWORD *)this + 20);
  if (v9 == v10)
  {
LABEL_5:
    v12 = *((_QWORD *)this + 21);
    if (v10 >= v12)
    {
      v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - v9) >> 3);
      v15 = v14 + 1;
      if (v14 + 1 > 0xAAAAAAAAAAAAAAALL)
        std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
      v16 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v12 - v9) >> 3);
      if (2 * v16 > v15)
        v15 = 2 * v16;
      if (v16 >= 0x555555555555555)
        v17 = 0xAAAAAAAAAAAAAAALL;
      else
        v17 = v15;
      if (v17)
        v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)this + 168, v17);
      else
        v18 = 0;
      v19 = &v18[24 * v14];
      v20 = &v18[24 * v17];
      *(_QWORD *)v19 = a3;
      *((_QWORD *)v19 + 1) = a4;
      *((_DWORD *)v19 + 4) = a2;
      *((_DWORD *)v19 + 5) = 0;
      v13 = v19 + 24;
      v22 = (char *)*((_QWORD *)this + 19);
      v21 = (char *)*((_QWORD *)this + 20);
      if (v21 != v22)
      {
        do
        {
          v23 = *(_OWORD *)(v21 - 24);
          *((_QWORD *)v19 - 1) = *((_QWORD *)v21 - 1);
          *(_OWORD *)(v19 - 24) = v23;
          v19 -= 24;
          v21 -= 24;
        }
        while (v21 != v22);
        v21 = (char *)*((_QWORD *)this + 19);
      }
      *((_QWORD *)this + 19) = v19;
      *((_QWORD *)this + 20) = v13;
      *((_QWORD *)this + 21) = v20;
      if (v21)
        operator delete(v21);
    }
    else
    {
      *(_QWORD *)v10 = a3;
      *(_QWORD *)(v10 + 8) = a4;
      v13 = (char *)(v10 + 24);
      *(_DWORD *)(v10 + 16) = a2;
      *(_DWORD *)(v10 + 20) = 0;
    }
    *((_QWORD *)this + 20) = v13;
  }
  else
  {
    v11 = *((_QWORD *)this + 19);
    while (*(_DWORD *)(v11 + 16) != a2)
    {
      v11 += 24;
      if (v11 == v10)
        goto LABEL_5;
    }
    (*(void (**)(_QWORD))(v11 + 8))(*(_QWORD *)v11);
    *(_QWORD *)v11 = a3;
    *(_QWORD *)(v11 + 8) = a4;
    *(_DWORD *)(v11 + 16) = a2;
    *(_DWORD *)(v11 + 20) = 0;
  }
  return pthread_mutex_unlock(v8);
}

uint64_t HEIFReadPlugin::initialize(HEIFReadPlugin *this, IIODictionary *a2)
{
  IIODictionary *v3;
  CGImageMetadata *v4;
  unsigned int v5;
  const __CFDictionary *ObjectForKey;
  const __CFDictionary *v7;
  CFTypeID v8;
  const __CFData *v9;
  const __CFString *v10;
  BOOL v11;
  unint64_t Uint32ForKey;
  IIOImageRead *v13;
  const __CFData *v14;
  uint64_t v15;
  int v16;
  unsigned int v17;
  int v18;
  GlobalHEIFInfo *v19;
  unsigned int v20;
  HEIFMainImage *HEIFMainImageAtIndex;
  HEIFMainImage *v22;
  HEIFGroupItem *HEIFThumbnailImageAtIndex;
  IIO_Reader *v24;
  int v25;
  unsigned int v26;
  uint64_t v27;
  unsigned int v28;
  int v29;
  uint64_t v30;
  unsigned int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  __int16 v35;
  IIOImageRead *Size;
  IIOImageRead *v37;
  const UInt8 *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t ExpectedWidthAndHeightForSubsampling;
  unsigned int v42;
  float v43;
  float v44;
  float v45;
  float v46;
  const __CFString *ColorSpaceName;
  CGColorSpace *v48;
  CGColorSpace *ColorSpace;
  int v50;
  unsigned int v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  unsigned int v55;
  int v56;
  uint64_t v57;
  unsigned int v58;
  int v59;
  uint64_t v60;
  int v61;
  CFStringRef Name;
  IIOString *v63;
  const char *v64;
  int v65;
  int StereoAggressorCount;
  int v67;
  unsigned int i;
  int NumberOfAuxImages;
  int v70;
  unsigned int j;
  IIOImageWriteSession *HEIFAuxImageAtIndex;
  const __CFString *v73;
  int v74;
  IIOImageRead *v75;
  int v76;
  _BOOL4 EnableRestrictedDecodingFlag;
  char v78;
  __int16 v79;
  int v80;
  int v81;
  unsigned int v82;
  char v83;
  unsigned int v84;
  int v85;
  int v86;
  int v87;
  int v88;
  int v89;
  const char *v90;
  IIOImageRead *v91;
  IIOImageRead *v92;
  const UInt8 *v93;
  uint64_t v94;
  int v95;
  int v96;
  const char *v97;
  int v98;
  int ImageGeometryForIndexWithOptions;
  int v100;
  const char *v101;
  unsigned int v102;
  const void *v103;
  IIOImageSource *HEIFExifPayloadAtIndex;
  IIOImageSource *v105;
  uint64_t (*v106)(CFTypeRef, uint64_t, uint64_t, _QWORD, unsigned int *, const __CFData **);
  CFTypeRef v107;
  uint64_t v108;
  uint64_t Ref;
  int v110;
  int v111;
  const char *v112;
  const UInt8 *BytePtr;
  unsigned int Length;
  CGMutableImageMetadataRef MetadataFromDatabuffer;
  CGImageMetadata *v116;
  __CFDictionary *v117;
  IIODictionary *v118;
  int TileWidth;
  CGImageMetadataTag *v120;
  CGImageMetadataTag *v121;
  const char *v122;
  CFIndex v123;
  CGImageMetadata *MetadataFromXMPSidecarData;
  CFDataRef v125;
  IIOImageSource *HEIFXMPPayloadAtIndex;
  IIOImageSource *v127;
  void *v128;
  CFTypeRef v129;
  uint64_t v130;
  uint64_t v131;
  int v132;
  int v133;
  const char *v134;
  const char *v135;
  unsigned int v136;
  CGImageMetadata *MetadataFromXMPBuffer;
  const CFStringRef *v138;
  const __CFString *v139;
  double FrameDuration;
  IIODictionary *v141;
  double v142;
  IIODictionary *v143;
  HEIFItem *HEIFItemPayloadAtIndex;
  int v145;
  int v146;
  const char *v147;
  int v148;
  int v149;
  int v150;
  int DecodePixelFormatForBitDepth;
  int v152;
  int v153;
  const char *v154;
  IIODictionary *v155;
  const __CFDictionary *v156;
  int v157;
  char v158;
  const __CFString *v159;
  const __CFDictionary *v160;
  CGImageMetadataTag *v161;
  int v162;
  uint64_t v163;
  int v164;
  IIOImageRead **v165;
  CGImageMetadata *metadata;
  const __CFData *theData;
  BOOL v169;
  const __CFData *v170;
  IIOImageRead *v171;
  unsigned int v172;
  unsigned int TileLength;
  _BYTE v174[24];
  CFTypeRef cf;
  _BYTE v176[24];
  uint64_t v177;
  uint64_t v178;
  _BYTE v179[24];
  _BYTE v180[24];
  unsigned int v181[2];
  uint64_t v182;
  const void *v183;
  const __CFData *v184;
  unsigned int v185;
  uint64_t v186;
  CFTypeRef v187;
  CFTypeRef v188;
  unsigned int v189[2];
  uint64_t v190;
  CFTypeRef v191;
  void *v192;
  CFTypeRef v193[2];

  v3 = (IIODictionary *)*((_QWORD *)this + 6);
  v4 = (CGImageMetadata *)*((_QWORD *)this + 8);
  v192 = 0;
  v193[0] = 0;
  v5 = IIODictionary::containsKey(v3, CFSTR("kCGImageSourceDecodeRequest"));
  ObjectForKey = IIODictionary::getObjectForKey(v3, CFSTR("kCGImageSourceXMPSidecar"));
  if (ObjectForKey)
  {
    v7 = ObjectForKey;
    v8 = CFGetTypeID(ObjectForKey);
    if (v8 == CFDataGetTypeID())
      v9 = v7;
    else
      v9 = 0;
    if (v5)
      goto LABEL_6;
  }
  else
  {
    v9 = 0;
    if (v5)
    {
LABEL_6:
      v10 = (const __CFString *)IIODictionary::getObjectForKey(v3, CFSTR("kCGImageSourceDecodeRequest"));
      v11 = CFStringCompare(v10, CFSTR("kCGImageSourceDecodeToHDR"), 0) == kCFCompareEqualTo;
      goto LABEL_9;
    }
  }
  v11 = 0;
LABEL_9:
  if (IIODictionary::containsKey(v3, CFSTR("kCGImageSourceTiledDownsamplingMode")))
    *((_DWORD *)this + 119) = IIODictionary::getUint32ForKey(v3, CFSTR("kCGImageSourceTiledDownsamplingMode"));
  if (IIODictionary::containsKey(v3, CFSTR("kCGImageSourceSubsampleFactor")))
    Uint32ForKey = IIODictionary::getUint32ForKey(v3, CFSTR("kCGImageSourceSubsampleFactor"));
  else
    Uint32ForKey = 0;
  IIO_LoadHEIFSymbols();
  v13 = IIOImageReadSession::globalInfoForType(*((IIOImageReadSession **)this + 3), 1212500294);
  if (!v13)
  {
    kdebug_trace();
    LogError("initialize", 498, "*** ERROR: globalHEIFInfo was not set in IIO_Reader_HEIF::updateSourceProperties or IIO_Reader_HEIF::getImageCount\n");
LABEL_16:
    v14 = 0;
    v15 = 4294967246;
    goto LABEL_17;
  }
  v19 = v13;
  if (!GlobalHEIFInfo::getNumberOfMainImages(v13))
  {
    _cg_jpeg_mem_term("initialize", 499, "*** no main image??? (globalHEIFInfo->getNumberOfMainImages() is 0)\n");
    goto LABEL_16;
  }
  v20 = GlobalHEIFInfo::resolvedIndexForIndex(v19, *((unsigned int *)this + 52));
  *((_DWORD *)this + 124) = v20;
  HEIFMainImageAtIndex = (HEIFMainImage *)GlobalHEIFInfo::getHEIFMainImageAtIndex(v19, v20);
  if (!HEIFMainImageAtIndex)
  {
    _cg_jpeg_mem_term("initialize", 504, "*** ERROR: could not get mainImage[%d]\n");
    goto LABEL_16;
  }
  v22 = HEIFMainImageAtIndex;
  *((_WORD *)this + 158) = 0;
  theData = v9;
  v172 = v5;
  if (*((unsigned __int8 *)this + 216) >= 2u)
  {
    HEIFThumbnailImageAtIndex = (HEIFGroupItem *)HEIFMainImage::getHEIFThumbnailImageAtIndex(HEIFMainImageAtIndex, 0);
    if (HEIFThumbnailImageAtIndex)
    {
      v24 = HEIFThumbnailImageAtIndex;
      *((_DWORD *)this + 57) = HEIFGroupItem::getGroupType(HEIFThumbnailImageAtIndex);
      *((_DWORD *)this + 58) = TIFFFieldIsAnonymous((uint64_t)v24);
      IIO_Reader::osType(v24);
      HEIFThumbnailImage::dataLength(v24);
      v25 = *((_DWORD *)this + 53);
      if (!v25)
        goto LABEL_69;
      v26 = *((_DWORD *)this + 57);
      if (v26 <= *((_DWORD *)this + 58))
        v26 = *((_DWORD *)this + 58);
      if (v26 == v25)
        goto LABEL_69;
    }
    goto LABEL_31;
  }
  if (*((_DWORD *)this + 53)
    && (HEIFMainImage::width(HEIFMainImageAtIndex) > *((_DWORD *)this + 53)
     || HEIFMainImage::height(v22) > *((_DWORD *)this + 53)))
  {
LABEL_31:
    v14 = 0;
    *((_BYTE *)this + 490) = 1;
    goto LABEL_70;
  }
  *((_DWORD *)this + 57) = HEIFMainImage::width(v22);
  *((_DWORD *)this + 58) = HEIFMainImage::height(v22);
  if (Uint32ForKey < 2)
  {
LABEL_69:
    v14 = 0;
    goto LABEL_70;
  }
  if (Uint32ForKey <= 3)
    v35 = 2;
  else
    v35 = 4;
  if (Uint32ForKey > 7)
    v35 = 8;
  *((_WORD *)this + 158) = v35;
  Size = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
  v37 = IIOImageReadSession::retainBytePointer(*((IIOImageReadSession **)this + 3), (const __CFData **)&v192, 1);
  if (!v37)
  {
    LogError("initialize", 555, "*** ERROR: retainBytePointer failed\n");
    goto LABEL_16;
  }
  v38 = (const UInt8 *)v37;
  v39 = *((_QWORD *)this + 57);
  if (v39)
  {
    v40 = *((_QWORD *)this + 58);
    if (!v40)
      v39 = 0;
    v38 = (const UInt8 *)v37 + v39;
    if (v40)
      Size = (IIOImageRead *)*((_QWORD *)this + 58);
  }
  v14 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v38, (CFIndex)Size, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  v189[0] = 0;
  v181[0] = 0;
  ExpectedWidthAndHeightForSubsampling = HEIFReadPlugin::getExpectedWidthAndHeightForSubsampling(this, v14, *((unsigned int *)this + 124), *((unsigned __int16 *)this + 158), v189, v181);
  if ((_DWORD)ExpectedWidthAndHeightForSubsampling)
  {
    v15 = ExpectedWidthAndHeightForSubsampling;
    LogError("initialize", 571, "*** ERROR: _getExpectedWidthAndHeightForSubsampling failed\n");
LABEL_17:
    v16 = *((_DWORD *)this + 51);
    v17 = v16 >> 24;
    if (v16 < 0)
    {
      v18 = __maskrune(v17, 0x40000uLL);
      v16 = *((_DWORD *)this + 51);
    }
    else
    {
      v18 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v17 + 60) & 0x40000;
    }
    if (v18)
      v27 = (v16 >> 24);
    else
      v27 = 46;
    v28 = v16 << 8 >> 24;
    if (v16 << 8 < 0)
    {
      v29 = __maskrune(v28, 0x40000uLL);
      v16 = *((_DWORD *)this + 51);
    }
    else
    {
      v29 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v28 + 60) & 0x40000;
    }
    if (v29)
      v30 = (v16 << 8 >> 24);
    else
      v30 = 46;
    v31 = (__int16)v16 >> 8;
    if (v16 << 16 < 0)
    {
      v32 = __maskrune(v31, 0x40000uLL);
      v16 = *((_DWORD *)this + 51);
    }
    else
    {
      v32 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v31 + 60) & 0x40000;
    }
    if (v32)
      v33 = ((__int16)v16 >> 8);
    else
      v33 = 46;
    if ((v16 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v16 + 60) & 0x40000) != 0)
        goto LABEL_50;
    }
    else if (__maskrune((char)v16, 0x40000uLL))
    {
LABEL_50:
      v34 = *((char *)this + 204);
      goto LABEL_53;
    }
    v34 = 46;
LABEL_53:
    _cg_jpeg_mem_term("initialize", 1104, "*** ERROR: '%c%c%c%c'-initialize failed [%d]\n", v27, v30, v33, v34, v15);
    kdebug_trace();
    if (!v14)
      goto LABEL_269;
    goto LABEL_268;
  }
  if ((gIIODebugFlags & 0x30000) != 0)
  {
    ImageIOLog("    getExpectedWidthAndHeightForSubsampling:    subSampleFactor: %d  size: %d x %d\n", *((unsigned __int16 *)this + 158), v189[0], v181[0]);
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("                                           :    original size: %d x %d\n", *((_DWORD *)this + 57), *((_DWORD *)this + 58));
  }
  v102 = v181[0];
  *((_DWORD *)this + 57) = v189[0];
  *((_DWORD *)this + 58) = v102;
LABEL_70:
  v42 = *((_DWORD *)this + 53);
  if (v42 && *((_BYTE *)this + 490))
  {
    v43 = (float)v42 / (float)HEIFMainImage::width(v22);
    v44 = (float)*((unsigned int *)this + 53);
    v45 = v44 / (float)HEIFMainImage::height(v22);
    if (v43 < v45)
      v45 = v43;
    if (v45 <= 1.0)
      v46 = v45;
    else
      v46 = 1.0;
    *((_DWORD *)this + 57) = (float)(v46 * (float)HEIFMainImage::width(v22));
    *((_DWORD *)this + 58) = (float)(v46 * (float)HEIFMainImage::height(v22)) & 0xFFFFFFFE;
  }
  ColorSpaceName = (const __CFString *)HEIFMainImage::getColorSpaceName(v22);
  if (ColorSpaceName)
  {
    v48 = CGColorSpaceCreateWithName(ColorSpaceName);
  }
  else
  {
    ColorSpace = (CGColorSpace *)HEIFMainImage::getColorSpace(v22);
    v48 = CGColorSpaceRetain(ColorSpace);
  }
  metadata = v4;
  v171 = v19;
  *((_QWORD *)this + 20) = v48;
  if (!v48)
  {
    v48 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
    *((_QWORD *)this + 20) = v48;
  }
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    v50 = *((_DWORD *)this + 51);
    v51 = v50 >> 24;
    v52 = MEMORY[0x1E0C80978];
    if (v50 < 0)
    {
      v53 = __maskrune(v51, 0x40000uLL);
      v50 = *((_DWORD *)this + 51);
    }
    else
    {
      v53 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v51 + 60) & 0x40000;
    }
    if (v53)
      v54 = (v50 >> 24);
    else
      v54 = 46;
    v55 = v50 << 8 >> 24;
    if (v50 << 8 < 0)
    {
      v56 = __maskrune(v55, 0x40000uLL);
      v50 = *((_DWORD *)this + 51);
    }
    else
    {
      v56 = *(_DWORD *)(v52 + 4 * v55 + 60) & 0x40000;
    }
    if (v56)
      v57 = (v50 << 8 >> 24);
    else
      v57 = 46;
    v58 = (__int16)v50 >> 8;
    if (v50 << 16 < 0)
    {
      v59 = __maskrune(v58, 0x40000uLL);
      v50 = *((_DWORD *)this + 51);
    }
    else
    {
      v59 = *(_DWORD *)(v52 + 4 * v58 + 60) & 0x40000;
    }
    if (v59)
      v60 = ((__int16)v50 >> 8);
    else
      v60 = 46;
    if ((v50 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v52 + 4 * (char)v50 + 60) & 0x40000) != 0)
        goto LABEL_104;
    }
    else if (__maskrune((char)v50, 0x40000uLL))
    {
LABEL_104:
      v61 = *((_DWORD *)this + 51);
LABEL_107:
      Name = CGColorSpaceGetName(*((CGColorSpaceRef *)this + 20));
      v63 = IIOString::IIOString((IIOString *)v189, Name);
      v64 = (const char *)IIOString::utf8String(v63);
      ImageIOLog("COL '%c%c%c%c' %s:%d using colorSpace: '%s'\n", v54, v57, v60, (char)v61, "initialize", 609, v64);
      IIOString::~IIOString((IIOString *)v189);
      v48 = (CGColorSpace *)*((_QWORD *)this + 20);
      goto LABEL_108;
    }
    LOBYTE(v61) = 46;
    goto LABEL_107;
  }
LABEL_108:
  if (CGColorSpaceGetModel(v48) == kCGColorSpaceModelRGB)
    v65 = 1380401696;
  else
    v65 = 1196573017;
  *((_DWORD *)this + 81) = v65;
  *((_WORD *)this + 246) = 0;
  StereoAggressorCount = HEIFGroupItem::getStereoAggressorCount(v22);
  if (StereoAggressorCount)
  {
    v67 = StereoAggressorCount;
    for (i = 0; i != v67; ++i)
    {
      if (HEIFMainImage::getHEIFAlternateImageAtIndex(v22, i))
        *((_BYTE *)this + 487) = 1;
    }
  }
  NumberOfAuxImages = HEIFMainImage::getNumberOfAuxImages(v22);
  if (NumberOfAuxImages)
  {
    v70 = NumberOfAuxImages;
    v169 = v11;
    for (j = 0; j != v70; ++j)
    {
      HEIFAuxImageAtIndex = (IIOImageWriteSession *)HEIFMainImage::getHEIFAuxImageAtIndex(v22, j);
      v73 = (const __CFString *)IIOImageWriteSession::getSize(HEIFAuxImageAtIndex);
      if (HEIFAuxImage::auxiliaryType(HEIFAuxImageAtIndex) == 3)
      {
        v74 = HEIFAuxImage::auxiliaryAlpha(HEIFAuxImageAtIndex);
        if (!v74)
        {
          _cg_jpeg_mem_term("initialize", 640, "*** ERROR: image has alpha plane, but auxImage alpha is 'kCGImageAlphaNone'?\n");
          LOBYTE(v74) = 3;
        }
        *((_BYTE *)this + 246) = v74 & 0x1F;
        *((_BYTE *)this + 493) = HEIFAuxImage::auxiliaryAlpha(HEIFAuxImageAtIndex) == 1;
        *((_DWORD *)this + 120) = HEIFAuxImage::auxiliaryPixelFormat(HEIFAuxImageAtIndex);
        *((_BYTE *)this + 492) = 1;
      }
      else if (v73
             && CFStringCompare(v73, *(CFStringRef *)gIIO_kCMPhotoAuxiliaryImageTypeURN_HDRGainMap, 0) == kCFCompareEqualTo)
      {
        *((_BYTE *)this + 486) = 1;
      }
    }
    v75 = v171;
    v11 = v169;
    if (!*((_BYTE *)this + 492))
      *((_BYTE *)this + 246) = 5;
  }
  else if (*((_DWORD *)this + 81) == 1380401696)
  {
    v76 = HEIFMainImage::bitDepth(v22);
    *((_BYTE *)this + 246) = 5;
    v75 = v171;
    if (v76 == 10)
    {
      *((_WORD *)this + 139) = 5;
      *((_WORD *)this + 155) = 5;
      *((_BYTE *)this + 247) = 0;
    }
  }
  else
  {
    *((_BYTE *)this + 246) = 0;
    v75 = v171;
  }
  *((_WORD *)this + 120) = HEIFMainImage::bitDepth(v22);
  EnableRestrictedDecodingFlag = HEIFReadPlugin::getEnableRestrictedDecodingFlag((IIODictionary **)this, v3);
  if (*((_DWORD *)this + 81) != 1196573017)
  {
    *((_WORD *)this + 122) = 4;
    if (v11)
    {
      if (!EnableRestrictedDecodingFlag)
      {
        v82 = *((unsigned __int16 *)this + 120);
LABEL_149:
        if (v82 != 10 || *((_BYTE *)this + 492))
        {
          *((_DWORD *)this + 60) = 4194320;
          LOWORD(v81) = 64;
          goto LABEL_152;
        }
        *((_DWORD *)this + 60) = 2097162;
        *((_BYTE *)this + 248) = 3;
        *((_BYTE *)this + 280) = 3;
        *((_BYTE *)this + 312) = 3;
LABEL_148:
        LOWORD(v81) = 32;
        goto LABEL_152;
      }
    }
    else
    {
      v82 = *((unsigned __int16 *)this + 120);
      v83 = v82 < 9 || EnableRestrictedDecodingFlag;
      if ((v83 & 1) == 0)
        goto LABEL_149;
    }
    *((_DWORD *)this + 60) = 2097160;
    goto LABEL_148;
  }
  v78 = *((_BYTE *)this + 492);
  if (v78)
    v79 = 2;
  else
    v79 = 1;
  *((_WORD *)this + 122) = v79;
  if (*((unsigned __int16 *)this + 120) <= 8u)
    v80 = 8;
  else
    v80 = 16;
  *((_WORD *)this + 120) = v80;
  v81 = v80 << v78;
  *((_WORD *)this + 121) = v81;
LABEL_152:
  v84 = (*((_DWORD *)this + 57) * ((unsigned __int16)v81 >> 3) + 15) & 0xFFFFFFF0;
  *((_DWORD *)this + 59) = v84;
  *((_DWORD *)this + 67) = v84;
  v85 = IIOSkipMetadata(v3);
  v86 = IIOSkipXMP_and_IPTC(v3);
  if (*((unsigned __int8 *)this + 216) < 2u)
    v87 = 1;
  else
    v87 = v85;
  if (((v87 | v172) & 1) == 0)
  {
    if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild())
      ImageIOLog("••• Ⓜ️  skipping metadata for thumbnail creation\n");
    v85 = 1;
  }
  v88 = IIOCreateCMPhotoDecompressionSession((uint64_t)v193);
  if (v88)
  {
    v89 = v88;
    v90 = IIOCMErrorString(v88);
    LogError("initialize", 749, "*** CMPhotoDecompressionSessionCreate  err = %s [%d]\n", v90, v89);
    goto LABEL_249;
  }
  v187 = 0;
  v188 = 0;
  v186 = 1;
  if (v14)
    goto LABEL_170;
  v91 = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
  v92 = IIOImageReadSession::retainBytePointer(*((IIOImageReadSession **)this + 3), (const __CFData **)&v192, 1);
  if (!v92)
  {
    LogError("initialize", 764, "*** ERROR: retainBytePointer failed\n");
    v15 = 0;
    goto LABEL_269;
  }
  v93 = (const UInt8 *)v92;
  v94 = *((_QWORD *)this + 57);
  if (v94)
  {
    if (*((_QWORD *)this + 58))
      v91 = (IIOImageRead *)*((_QWORD *)this + 58);
    else
      v94 = 0;
    v93 = (const UInt8 *)v92 + v94;
  }
  v14 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v93, (CFIndex)v91, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  if (v14)
  {
LABEL_170:
    v95 = gFunc_CMPhotoDecompressionSessionCreateContainer(v193[0], 0, v14, (char *)&v186 + 4, &v188);
    if (v95)
    {
      v96 = v95;
      v97 = IIOCMErrorString(v95);
      LogError("initialize", 781, "*** CMPhotoDecompressionSessionCreateContainer  err = %s [%d]\n", v97, v96);
      goto LABEL_248;
    }
    v170 = v14;
    if (GlobalHEIFInfo::hasHEIFSequence(v75))
      v98 = IIOImageRead::trustedURL(v75);
    else
      v98 = 0;
    v185 = 0;
    v184 = 0;
    if (v85)
    {
      ImageGeometryForIndexWithOptions = gFunc_CMPhotoDecompressionContainerGetImageGeometryForIndexWithOptions(v188, *((unsigned int *)this + 124), 0, 0, 0, &v186);
      if (ImageGeometryForIndexWithOptions)
      {
        v100 = ImageGeometryForIndexWithOptions;
        v101 = IIOCMErrorString(ImageGeometryForIndexWithOptions);
        LogError("initialize", 805, "*** CMPhotoDecompressionContainerGetImageGeometryForIndexWithOptions  err = %s [%d]\n", v101, v100);
        goto LABEL_224;
      }
      *(_QWORD *)v189 = 0;
      v190 = 0;
      v191 = 0;
      IIODictionary::IIODictionary((IIODictionary *)v189);
      IIONumber::IIONumber((IIONumber *)v181, v186);
      IIODictionary::setObjectForKeyGroup((IIODictionary *)v189, v183, CFSTR("Orientation"), CFSTR("{TIFF}"));
      IIONumber::~IIONumber((IIONumber *)v181);
      v103 = (const void *)CGImageMetadataCreateFromLegacyProps((IIODictionary *)v189);
      CGImageMetadataMerge((uint64_t)metadata, (uint64_t)v103, 0);
      if (v103)
      {
        CFRelease(v103);
        IIODictionary::~IIODictionary((IIODictionary *)v189);
        goto LABEL_224;
      }
      IIODictionary::~IIODictionary((IIODictionary *)v189);
    }
    HEIFExifPayloadAtIndex = (IIOImageSource *)HEIFMainImage::getHEIFExifPayloadAtIndex(v22, 0);
    if (HEIFExifPayloadAtIndex)
    {
      v105 = HEIFExifPayloadAtIndex;
      v106 = (uint64_t (*)(CFTypeRef, uint64_t, uint64_t, _QWORD, unsigned int *, const __CFData **))gFunc_CMPhotoDecompressionContainerCopyExifForIndexWithOptions;
      v107 = v188;
      v108 = IIOImageSource::cf(HEIFExifPayloadAtIndex);
      Ref = IIOImageSource::imageReadRef(v105);
      v110 = v106(v107, v108, Ref, 0, &v185, &v184);
      if (v110)
      {
        v111 = v110;
        v112 = IIOCMErrorString(v110);
        LogError("initialize", 832, "*** CMPhotoDecompressionContainerCopyExifForIndexWithOptions  err = %s [%d]\n", v112, v111);
        v75 = v171;
      }
      else
      {
        BytePtr = CFDataGetBytePtr(v184);
        Length = CFDataGetLength(v184);
        v75 = v171;
        if (Length > v185)
        {
          MetadataFromDatabuffer = CreateMetadataFromDatabuffer((const char *)&BytePtr[v185], Length - v185, 0);
          v116 = MetadataFromDatabuffer;
          if (MetadataFromDatabuffer)
          {
            v117 = (__CFDictionary *)*((_QWORD *)MetadataFromDatabuffer + 6);
            if (v117)
            {
              *(_QWORD *)v189 = 0;
              v190 = 0;
              v191 = 0;
              v118 = IIODictionary::IIODictionary((IIODictionary *)v189, v117);
              *((float *)this + 125) = IIODictionary::getFloatForKeyGroup(v118, CFSTR("33"), CFSTR("{MakerApple}"));
              *((float *)this + 126) = IIODictionary::getFloatForKeyGroup((IIODictionary *)v189, CFSTR("48"), CFSTR("{MakerApple}"));
              IIODictionary::~IIODictionary((IIODictionary *)v189);
            }
          }
          if (HEIFMainImage::isTiled(v22))
          {
            TileWidth = HEIFMainImage::getTileWidth(v22);
            TileLength = HEIFMainImage::getTileLength(v22);
            IIONumber::IIONumber((IIONumber *)v189, TileWidth);
            v120 = CGImageMetadataTagCreate(CFSTR("http://ns.adobe.com/tiff/1.0/"), CFSTR("tiff"), CFSTR("TileWidth"), kCGImageMetadataTypeDefault, v191);
            IIONumber::~IIONumber((IIONumber *)v189);
            if (v120)
            {
              CGImageMetadataSetTagWithPath(v116, 0, CFSTR("tiff:TileWidth"), v120);
              CFRelease(v120);
            }
            IIONumber::IIONumber((IIONumber *)v189, TileLength);
            v75 = v171;
            v121 = CGImageMetadataTagCreate(CFSTR("http://ns.adobe.com/tiff/1.0/"), CFSTR("tiff"), CFSTR("TileLength"), kCGImageMetadataTypeDefault, v191);
            IIONumber::~IIONumber((IIONumber *)v189);
            if (v121)
            {
              CGImageMetadataSetTagWithPath(v116, 0, CFSTR("tiff:TileLength"), v121);
              CFRelease(v121);
            }
          }
          CGImageMetadataMerge((uint64_t)metadata, (uint64_t)v116, 0);
          if (v116)
            CFRelease(v116);
        }
        if (v184)
          CFRelease(v184);
      }
    }
    if (v86)
    {
      if ((v85 & 1) == 0)
        CGImageMetadataRemoveTagWithPath(metadata, 0, CFSTR("dc:creator"));
      goto LABEL_215;
    }
    if (theData)
    {
      v122 = (const char *)CFDataGetBytePtr(theData);
      v123 = CFDataGetLength(theData);
      MetadataFromXMPSidecarData = CreateMetadataFromXMPSidecarData(v122, v123);
      CGImageMetadataMerge((uint64_t)metadata, (uint64_t)MetadataFromXMPSidecarData, 0);
      if (!MetadataFromXMPSidecarData)
      {
LABEL_215:
        if (v98)
        {
          if (*((_DWORD *)this + 51) == 1096173907)
            v138 = &kCGImagePropertyAVISDictionary;
          else
            v138 = &kCGImagePropertyHEICSDictionary;
          v139 = *v138;
          FrameDuration = HEIFMainImage::getFrameDuration(v22);
          v141 = (IIODictionary *)*((_QWORD *)this + 7);
          IIONumber::IIONumber((IIONumber *)v180, FrameDuration);
          IIODictionary::setObjectForKeyGroup(v141, (uint64_t)v180, CFSTR("UnclampedDelayTime"), v139);
          IIONumber::~IIONumber((IIONumber *)v180);
          v142 = 0.1;
          if (FrameDuration >= 0.1)
            v142 = FrameDuration;
          v143 = (IIODictionary *)*((_QWORD *)this + 7);
          IIONumber::IIONumber((IIONumber *)v179, v142);
          IIODictionary::setObjectForKeyGroup(v143, (uint64_t)v179, CFSTR("DelayTime"), v139);
          IIONumber::~IIONumber((IIONumber *)v179);
        }
        HEIFItemPayloadAtIndex = (HEIFItem *)HEIFMainImage::getHEIFItemPayloadAtIndex(v22, 0);
        if (HEIFItemPayloadAtIndex)
          HEIFItem::updateProperties(HEIFItemPayloadAtIndex, *((IIODictionary **)this + 7));
LABEL_224:
        v177 = 0;
        v178 = 0;
        if (v98)
        {
          v145 = gFunc_CMPhotoDecompressionContainerCreateSequenceContainer(v188, 0, 0, &v187);
          if (v145)
          {
            v146 = v145;
            v147 = IIOCMErrorString(v145);
            LogError("initialize", 961, "*** CMPhotoDecompressionContainerCreateSequenceContainer  err = %s [%d]\n", v147, v146);
          }
          v148 = gFunc_CMPhotoDecompressionContainerGetImageGeometryForIndexWithOptions(v187, *((unsigned int *)this + 124), 0, &v178, &v177, &v186);
          v14 = v170;
          if (v148)
          {
            IIOCMErrorString(v148);
            LogError("initialize", 964, "*** CMPhotoDecompressionContainerGetImageGeometryForIndexWithOptions  err = %s [%d]\n");
LABEL_231:
            LODWORD(v186) = 0;
LABEL_232:
            if (IIODictionary::getBoolForKey(v3, CFSTR("kCGImageSourceCreateThumbnailWithTransform"))
              && (v186 - 5) <= 3)
            {
              *(int32x2_t *)((char *)this + 260) = vrev64_s32(*(int32x2_t *)((char *)this + 228));
            }
            if (IIODictionary::containsKey(v3, CFSTR("kCGImageSourceDecodeRequest")))
            {
              *(_QWORD *)v189 = 0;
              v190 = 0;
              v191 = 0;
              IIODictionary::IIODictionary((IIODictionary *)v189);
              v150 = HEIFMainImage::bitDepth(v22);
              DecodePixelFormatForBitDepth = HEIFReadPlugin::getDecodePixelFormatForBitDepth(this, v150);
              IIONumber::IIONumber((IIONumber *)v176, DecodePixelFormatForBitDepth);
              IIODictionary::setObjectForKey((uint64_t)v189, (uint64_t)v176, *(const void **)gIIO_kCMPhotoDecompressionOption_OutputPixelFormat);
              IIONumber::~IIONumber((IIONumber *)v176);
              HEIFReadPlugin::updateCreateImageOptions(this, (IIODictionary *)v189, v3);
              cf = 0;
              v152 = gFunc_CMPhotoDecompressionContainerCreateOutputBufferAttributesForImageIndex(v188, *((unsigned int *)this + 124), v190, &cf);
              v153 = v152;
              if (v152)
              {
                v154 = IIOCMErrorString(v152);
                LogError("initialize", 1019, "*** CMPhotoDecompressionContainerCreateOutputBufferAttributesForImageIndex  err = %s [%d]\n", v154, v153);
              }
              if (cf)
              {
                *(_QWORD *)v181 = 0;
                v182 = 0;
                v183 = 0;
                IIODictionary::IIODictionary((IIODictionary *)v181);
                IIODictionary::appendDictionary(v155, (const __CFDictionary *)cf);
                if ((IIODictionary::containsKey((IIODictionary *)v181, *(const __CFString **)gIIO_kCVPixelBufferPixelFormatTypeKey) & 1) == 0)
                {
                  v156 = IIODictionary::getObjectForKey((IIODictionary *)v189, *(const __CFString **)gIIO_kCMPhotoDecompressionOption_OutputPixelFormat);
                  IIODictionary::setObjectForKey((IIODictionary *)v181, v156, *(const __CFString **)gIIO_kCVPixelBufferPixelFormatTypeKey);
                  if ((gIIODebugFlags & 0x2000000) != 0)
                  {
                    v157 = IIODictionary::getUint32ForKey((IIODictionary *)v181, *(const __CFString **)gIIO_kCVPixelBufferPixelFormatTypeKey);
                    LogPixelFormat(v157, "initialize", 1027);
                  }
                }
                HEIFReadPlugin::handleDecodeRequest(this, v3, (IIODictionary *)v181);
                CFRelease(cf);
                IIODictionary::~IIODictionary((IIODictionary *)v181);
              }
              IIODictionary::~IIODictionary((IIODictionary *)v189);
            }
            if (v187)
              CFRelease(v187);
            if (v188)
              CFRelease(v188);
            goto LABEL_248;
          }
        }
        else
        {
          v149 = gFunc_CMPhotoDecompressionContainerGetImageGeometryForIndexWithOptions(v188, *((unsigned int *)this + 124), 0, &v178, &v177, &v186);
          v14 = v170;
          if (v149)
          {
            IIOCMErrorString(v149);
            LogError("initialize", 969, "*** CMPhotoDecompressionContainerGetImageGeometryForIndexWithOptions  err = %s [%d]\n");
            goto LABEL_231;
          }
        }
        if ((_DWORD)v186)
        {
          IIONumber::IIONumber((IIONumber *)v189, v186);
          v161 = CGImageMetadataTagCreate(CFSTR("http://ns.adobe.com/tiff/1.0/"), CFSTR("tiff"), CFSTR("TileLength"), kCGImageMetadataTypeDefault, v191);
          IIONumber::~IIONumber((IIONumber *)v189);
          v75 = v171;
          if (v161)
          {
            CGImageMetadataSetTagWithPath(metadata, 0, CFSTR("tiff:Orientation"), v161);
            CFRelease(v161);
          }
        }
        goto LABEL_232;
      }
      v125 = MetadataFromXMPSidecarData;
    }
    else
    {
      *(_QWORD *)v189 = 0;
      HEIFXMPPayloadAtIndex = (IIOImageSource *)HEIFMainImage::getHEIFXMPPayloadAtIndex(v22, 0);
      if (!HEIFXMPPayloadAtIndex)
        goto LABEL_215;
      v127 = HEIFXMPPayloadAtIndex;
      v128 = gFunc_CMPhotoDecompressionContainerCopyXMPForIndexWithOptions;
      v129 = v188;
      v130 = IIOImageSource::cf(HEIFXMPPayloadAtIndex);
      v131 = IIOImageSource::imageReadRef(v127);
      v132 = ((uint64_t (*)(CFTypeRef, uint64_t, uint64_t, _QWORD, _QWORD, unsigned int *))v128)(v129, v130, v131, 0, 0, v189);
      if (v132)
      {
        v133 = v132;
        v134 = IIOCMErrorString(v132);
        LogError("initialize", 914, "*** CMPhotoDecompressionContainerCopyXMPForIndexWithOptions  err = %s [%d]\n", v134, v133);
      }
      else
      {
        v135 = (const char *)CFDataGetBytePtr(*(CFDataRef *)v189);
        v136 = CFDataGetLength(*(CFDataRef *)v189);
        MetadataFromXMPBuffer = CreateMetadataFromXMPBuffer(v135, v136);
        CGImageMetadataMerge((uint64_t)metadata, (uint64_t)MetadataFromXMPBuffer, 0);
        if (MetadataFromXMPBuffer)
          CFRelease(MetadataFromXMPBuffer);
      }
      v125 = *(CFDataRef *)v189;
      v75 = v171;
      if (!*(_QWORD *)v189)
        goto LABEL_215;
    }
    CFRelease(v125);
    goto LABEL_215;
  }
LABEL_248:
  CFRelease(v193[0]);
LABEL_249:
  *((_BYTE *)this + 352) = 0;
  v158 = CGColorSpaceContainsFlexGTCInfo();
  *((_BYTE *)this + 351) = v158;
  if ((v158 & 1) == 0 && (*((_BYTE *)this + 487) || *((_BYTE *)this + 486)))
  {
    v159 = (const __CFString *)IIODictionary::getObjectForKey(v3, CFSTR("kCGImageSourceDecodeRequest"));
    if (v159)
    {
      if (CFStringCompare(v159, CFSTR("kCGImageSourceDecodeToHDR"), 0) == kCFCompareEqualTo)
      {
        v160 = IIODictionary::getObjectForKey(v3, CFSTR("kCGImageSourceDecodeRequestOptions"));
        *(_QWORD *)v189 = 0;
        v190 = 0;
        v191 = 0;
        IIODictionary::IIODictionary((IIODictionary *)v189, v160);
        if (*((_BYTE *)this + 488))
        {
          if (CGColorSpaceIsPQBased(*((CGColorSpaceRef *)this + 20)))
          {
            *((_BYTE *)this + 352) = 1;
            IIOReadPlugin::updateColorSpace((uint64_t)this, 0);
          }
          else
          {
            *((_BYTE *)this + 488) = 0;
          }
        }
        IIODictionary::~IIODictionary((IIODictionary *)v189);
      }
    }
  }
  *((_WORD *)this + 188) = 12;
  v162 = HEIFMainImage::bitDepth(v22);
  if (v162 != *((unsigned __int16 *)this + 120))
  {
    v163 = *((_QWORD *)this + 7);
    IIONumber::IIONumber((IIONumber *)v174, v162);
    IIODictionary::setObjectForKey(v163, (uint64_t)v174, CFSTR("Depth"));
    IIONumber::~IIONumber((IIONumber *)v174);
  }
  if (GlobalHEIFInfo::shouldExposeMultiFrameContents(v75))
  {
    v164 = *((_DWORD *)this + 52);
    if (v164 == GlobalHEIFInfo::getPrimaryImageIndex(v75))
      IIODictionary::setObjectForKey(*((IIODictionary **)this + 7), (const void *)*MEMORY[0x1E0C9AE50], CFSTR("PrimaryImage"));
  }
  v15 = 0;
  if (v14)
LABEL_268:
    CFRelease(v14);
LABEL_269:
  if (v192)
  {
    v165 = (IIOImageRead **)*((_QWORD *)this + 3);
    if (v165)
      IIOImageReadSession::releaseBytePointer(v165, v192);
  }
  return v15;
}

void sub_187E9F764(_Unwind_Exception *a1)
{
  uint64_t v1;

  IIONumber::~IIONumber((IIONumber *)(v1 - 144));
  _Unwind_Resume(a1);
}

void IIODictionary::setObjectForKeyGroup(IIODictionary *this, const void *a2, const __CFString *a3, const __CFString *a4)
{
  __CFDictionary *GroupForKey;

  if (a3)
  {
    if (a4)
    {
      if (*((_QWORD *)this + 1))
      {
        GroupForKey = IIODictionary::getGroupForKey(this, a4, 1);
        if (GroupForKey)
        {
          if (a2)
            CFDictionarySetValue(GroupForKey, a3, a2);
          else
            CFDictionaryRemoveValue(GroupForKey, a3);
        }
      }
    }
  }
}

uint64_t HEIFMainImage::bitDepth(HEIFMainImage *this)
{
  return *((unsigned int *)this + 43);
}

void IIO_LoadHEIFSymbols()
{
  if (gLoadCMPhotoSymbolsInitOnce != -1)
    dispatch_once(&gLoadCMPhotoSymbolsInitOnce, &__block_literal_global_5);
  if (gLoadCoreVideoSymbolsInitOnce != -1)
    dispatch_once(&gLoadCoreVideoSymbolsInitOnce, &__block_literal_global_7_0);
  if (gLoadCoreMediaSymbolsInitOnce != -1)
    dispatch_once(&gLoadCoreMediaSymbolsInitOnce, &__block_literal_global_9_0);
  if (gLoadVideoToolboxSymbolsInitOnce != -1)
    dispatch_once(&gLoadVideoToolboxSymbolsInitOnce, &__block_literal_global_11);
}

BOOL HEIFReadPlugin::getEnableRestrictedDecodingFlag(IIODictionary **this, IIODictionary *a2)
{
  _BOOL8 BoolForKey;
  const char *v5;
  int v6;

  if ((IIORestrictedDecodingEnabledFlag() & 1) != 0)
    return 1;
  if (!IIODictionary::getCount(a2))
    return 0;
  if (IIODictionary::containsKey(a2, CFSTR("kCGImageSourceEnableRestrictedDecoding")))
  {
    BoolForKey = IIODictionary::getBoolForKey(a2, CFSTR("kCGImageSourceEnableRestrictedDecoding"));
    if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild())
    {
      v5 = "❌";
      if (BoolForKey)
        v5 = "✅";
      v6 = 1253;
LABEL_16:
      ImageIOLog("••• %s EnableRestrictedDecoding  | %s:%d\n", v5, "getEnableRestrictedDecodingFlag", v6);
      return BoolForKey;
    }
    return BoolForKey;
  }
  if (!IIODictionary::containsKey(this[6], CFSTR("kCGImageSourceEnableRestrictedDecoding")))
  {
    if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild())
      ImageIOLog("••• ❓ EnableRestrictedDecoding  | %s:%d\n", "getEnableRestrictedDecodingFlag", 1261);
    return 0;
  }
  BoolForKey = IIODictionary::getBoolForKey(this[6], CFSTR("kCGImageSourceEnableRestrictedDecoding"));
  if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild())
  {
    v5 = "❌";
    if (BoolForKey)
      v5 = "✅";
    v6 = 1258;
    goto LABEL_16;
  }
  return BoolForKey;
}

uint64_t IIORestrictedDecodingEnabledFlag()
{
  return (gPermissions >> 4) & 1;
}

uint64_t GlobalHEIFInfo::resolvedIndexForIndex(GlobalHEIFInfo *this, uint64_t a2)
{
  if (!*((_BYTE *)this + 68))
    return *((unsigned int *)this + 16);
  return a2;
}

uint64_t GlobalHEIFInfo::hasHEIFSequence(GlobalHEIFInfo *this)
{
  return *((unsigned __int8 *)this + 69);
}

uint64_t HEIFMainImage::getNumberOfAuxImages(HEIFMainImage *this)
{
  return (*((_QWORD *)this + 5) - *((_QWORD *)this + 4)) >> 3;
}

uint64_t GlobalHEIFInfo::getHEIFMainImageAtIndex(GlobalHEIFInfo *this, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = a2;
  v3 = *((_QWORD *)this + 1);
  if (a2 >= (unint64_t)((*((_QWORD *)this + 2) - v3) >> 3))
    return 0;
  if (!*((_BYTE *)this + 68))
    v2 = *((unsigned int *)this + 16);
  return *(_QWORD *)(v3 + 8 * v2);
}

uint64_t HEIFMainImage::height(HEIFMainImage *this)
{
  return *((unsigned int *)this + 42);
}

uint64_t HEIFMainImage::width(HEIFMainImage *this)
{
  return *((unsigned int *)this + 41);
}

uint64_t HEIFMainImage::getColorSpaceName(HEIFMainImage *this)
{
  return *((_QWORD *)this + 36);
}

uint64_t GlobalHEIFInfo::shouldExposeMultiFrameContents(GlobalHEIFInfo *this)
{
  return *((unsigned __int8 *)this + 68);
}

uint64_t GlobalHEIFInfo::getPrimaryImageIndex(GlobalHEIFInfo *this)
{
  return *((unsigned int *)this + 16);
}

void GlobalHEIFInfo::GlobalHEIFInfo(GlobalHEIFInfo *this)
{
  char *v2;

  *(_QWORD *)this = &off_1E1BAE118;
  *(_OWORD *)((char *)this + 8) = 0u;
  v2 = (char *)this + 32;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  std::vector<_APPx *>::resize((uint64_t)this + 8, 0);
  std::vector<_APPx *>::resize((uint64_t)v2, 0);
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
}

void sub_187E9FB84(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void **v4;
  void *v6;
  void *v7;

  v4 = v3;
  v6 = *v4;
  if (*v4)
  {
    *(_QWORD *)(v1 + 40) = v6;
    operator delete(v6);
  }
  v7 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 16) = v7;
    operator delete(v7);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<_APPx *>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 8 * a2;
  }
  else
  {
    std::vector<_APPx *>::__append((void **)a1, a2 - v2);
  }
}

uint64_t GlobalHEIFInfo::setShouldExposeMultiFrameContents(uint64_t this, char a2)
{
  *(_BYTE *)(this + 68) = a2;
  return this;
}

uint64_t GlobalHEIFInfo::setUseHEIFSequence(uint64_t this, char a2)
{
  *(_BYTE *)(this + 71) = a2;
  return this;
}

void HEIFReadPlugin::updateCreateImageOptions(HEIFReadPlugin *this, IIODictionary *a2, IIODictionary *a3)
{
  int v6;
  int v8;
  IIONumber *v9;
  IIOImageRead *v10;
  HEIFMainImage *HEIFMainImageAtIndex;
  unsigned int v12;
  unsigned int v13;
  HEIFMainImage *v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  _BOOL4 BoolForKey;
  const void **v20;
  _BYTE v21[24];
  _BYTE v22[24];
  _BYTE v23[24];
  _BYTE v24[24];

  v6 = *((_DWORD *)this + 53);
  if (*((unsigned __int8 *)this + 216) <= 1u && v6 == 0)
  {
    if (!*((_WORD *)this + 158))
      goto LABEL_21;
    v10 = IIOImageReadSession::globalInfoForType(*((IIOImageReadSession **)this + 3), 1212500294);
    HEIFMainImageAtIndex = (HEIFMainImage *)GlobalHEIFInfo::getHEIFMainImageAtIndex(v10, *((_DWORD *)this + 124));
    if (*((_BYTE *)this + 340))
    {
      v12 = *((_DWORD *)this + 73);
      if (v12)
      {
        if (v12 <= *((_DWORD *)this + 74))
          v13 = *((_DWORD *)this + 74);
        else
          v13 = *((_DWORD *)this + 73);
      }
      else
      {
        v17 = *((_DWORD *)this + 57);
        if (v17 <= *((_DWORD *)this + 58))
          v17 = *((_DWORD *)this + 58);
        v13 = v17 / *((unsigned __int16 *)this + 158);
      }
    }
    else
    {
      v14 = HEIFMainImageAtIndex;
      v15 = HEIFMainImage::width(HEIFMainImageAtIndex) / *((unsigned __int16 *)this + 158);
      if (v15 <= HEIFMainImage::height(v14) / *((unsigned __int16 *)this + 158))
        v16 = HEIFMainImage::height(v14);
      else
        v16 = HEIFMainImage::width(v14);
      v13 = v16 / *((unsigned __int16 *)this + 158);
    }
    IIONumber::IIONumber((IIONumber *)v22, v13);
    IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v22, *(const void **)gIIO_kCMPhotoDecompressionOption_MaxPixelSize);
    IIONumber::~IIONumber((IIONumber *)v22);
    v18 = *((_DWORD *)this + 119);
    v9 = (IIONumber *)v21;
    IIONumber::IIONumber((IIONumber *)v21, v18);
    IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v21, *(const void **)gIIO_kCMPhotoDecompressionOption_TiledDownsampling);
  }
  else
  {
    IIONumber::IIONumber((IIONumber *)v24, v6);
    IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v24, *(const void **)gIIO_kCMPhotoDecompressionOption_MaxPixelSize);
    IIONumber::~IIONumber((IIONumber *)v24);
    v8 = *((_DWORD *)this + 119);
    v9 = (IIONumber *)v23;
    IIONumber::IIONumber((IIONumber *)v23, v8);
    IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v23, *(const void **)gIIO_kCMPhotoDecompressionOption_TiledDownsampling);
  }
  IIONumber::~IIONumber(v9);
LABEL_21:
  BoolForKey = IIODictionary::getBoolForKey(a3, CFSTR("kCGImageSourceCreateThumbnailWithTransform"));
  v20 = (const void **)MEMORY[0x1E0C9AE50];
  if (!BoolForKey)
    v20 = (const void **)MEMORY[0x1E0C9AE40];
  IIODictionary::setObjectForKey(a2, *v20, *(const __CFString **)gIIO_kCMPhotoDecompressionOption_ApplyTransform);
}

void sub_187E9FDE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  IIONumber::~IIONumber((IIONumber *)&a9);
  _Unwind_Resume(a1);
}

uint64_t HEIFMainImage::getHEIFAuxImageAtIndex(HEIFMainImage *this, unsigned int a2)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 4);
  if (a2 >= (unint64_t)((*((_QWORD *)this + 5) - v2) >> 3))
    return 0;
  else
    return *(_QWORD *)(v2 + 8 * a2);
}

uint64_t HEIFAuxImage::auxiliaryPixelFormat(HEIFAuxImage *this)
{
  return *((unsigned int *)this + 10);
}

uint64_t HEIFAuxImage::auxiliaryType(HEIFAuxImage *this)
{
  return *((unsigned int *)this + 7);
}

uint64_t HEIFAuxImage::auxiliaryAlpha(HEIFAuxImage *this)
{
  return *((unsigned int *)this + 9);
}

BOOL HEIFMainImage::isTiled(HEIFMainImage *this)
{
  return *((_DWORD *)this + 47) && *((_DWORD *)this + 48) != 0;
}

uint64_t HEIFMainImage::getHEIFItemPayloadAtIndex(HEIFMainImage *this, unsigned int a2)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 16);
  if (a2 >= (unint64_t)((*((_QWORD *)this + 17) - v2) >> 3))
    return 0;
  else
    return *(_QWORD *)(v2 + 8 * a2);
}

uint64_t HEIFMainImage::getHEIFExifPayloadAtIndex(HEIFMainImage *this, unsigned int a2)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 10);
  if (a2 >= (unint64_t)((*((_QWORD *)this + 11) - v2) >> 3))
    return 0;
  else
    return *(_QWORD *)(v2 + 8 * a2);
}

uint64_t HEIFMainImage::getHEIFXMPPayloadAtIndex(HEIFMainImage *this, unsigned int a2)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 13);
  if (a2 >= (unint64_t)((*((_QWORD *)this + 14) - v2) >> 3))
    return 0;
  else
    return *(_QWORD *)(v2 + 8 * a2);
}

uint64_t HEIFMainImage::getTileLength(HEIFMainImage *this)
{
  return *((unsigned int *)this + 48);
}

uint64_t HEIFMainImage::getTileWidth(HEIFMainImage *this)
{
  return *((unsigned int *)this + 47);
}

void AdobeXMPCore_Int::ICoreConfigurationManager_I::DestroyCoreConfigurationManager(AdobeXMPCore_Int::ICoreConfigurationManager_I *this)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;
  uint64_t v4;
  std::__shared_weak_count *v5;

  AdobeXMPCore_Int::ManageCoreConfigurationManager((AdobeXMPCore_Int *)1, &v4);
  v1 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void AdobeXMPCore_Int::ManageCoreConfigurationManager(AdobeXMPCore_Int *this@<X0>, _QWORD *a2@<X8>)
{
  unsigned __int8 v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  std::__shared_weak_count *v15;

  if ((v3 & 1) == 0)
  {
    v12 = (int)this;
    LODWORD(this) = v12;
    if (v13)
    {
      __cxa_atexit((void (*)(void *))std::shared_ptr<AdobeXMPCore::ICoreConfigurationManager_v1>::~shared_ptr[abi:ne180100], &AdobeXMPCore_Int::ManageCoreConfigurationManager(BOOL)::sCoreConfigurationManager, &dword_187E34000);
      LODWORD(this) = v12;
    }
  }
  if ((_DWORD)this)
  {
    std::shared_ptr<AdobeXMPCore::INode_v1>::reset[abi:ne180100](&AdobeXMPCore_Int::ManageCoreConfigurationManager(BOOL)::sCoreConfigurationManager);
  }
  else if (!AdobeXMPCore_Int::ManageCoreConfigurationManager(BOOL)::sCoreConfigurationManager)
  {
    v7 = AdobeXMPCore_Int::MemoryManagedObject::operator new((AdobeXMPCore_Int::MemoryManagedObject *)0x38);
    *(_QWORD *)(v7 + 16) = &unk_1E1BA38E8;
    *(_QWORD *)v7 = &unk_1E1BA4118;
    *(_QWORD *)(v7 + 8) = off_1E1BA3820;
    *(_QWORD *)(v7 + 40) = 0;
    *(_QWORD *)(v7 + 48) = 0;
    *(_QWORD *)(v7 + 32) = off_1E1BA40B8;
    v8 = (_QWORD *)AdobeXMPCore_Int::ConfigurationManagerImpl::ConfigurationManagerImpl(v7 + 16, (uint64_t *)&off_1E1BAB0D8);
    *(_QWORD *)v7 = off_1E1BBAD20;
    *(_QWORD *)(v7 + 8) = off_1E1BBADD8;
    *v8 = &unk_1E1BBAEB8;
    *(_QWORD *)(v7 + 32) = off_1E1BBAF80;
    AdobeXMPCore_Int::MakeUncheckedSharedPointer<AdobeXMPCore_Int::CoreConfigurationManagerImpl>((char *)v7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/ImageIO/XMP-Toolkit-SDK/XMPCore/source/CoreConfigurationManagerImpl.cpp", 28, 1, &v14);
    std::shared_ptr<AdobeXMPCore::ICoreConfigurationManager_v1>::operator=[abi:ne180100]<AdobeXMPCore_Int::CoreConfigurationManagerImpl,void>(&AdobeXMPCore_Int::ManageCoreConfigurationManager(BOOL)::sCoreConfigurationManager, (uint64_t)&v14);
    v9 = v15;
    if (v15)
    {
      p_shared_owners = (unint64_t *)&v15->__shared_owners_;
      do
        v11 = __ldaxr(p_shared_owners);
      while (__stlxr(v11 - 1, p_shared_owners));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }
  v4 = unk_1ECDD9070;
  *a2 = AdobeXMPCore_Int::ManageCoreConfigurationManager(BOOL)::sCoreConfigurationManager;
  a2[1] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
}

uint64_t _CGImagePixelDataProviderFinalize(_QWORD *a1)
{
  unint64_t v2;
  uint64_t result;

  do
    v2 = __ldxr(&gPDPCount);
  while (__stxr(v2 - 1, &gPDPCount));
  result = a1[3];
  if (result)
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  a1[2] = 0;
  a1[3] = 0;
  return result;
}

void IIOImagePixelDataProvider::~IIOImagePixelDataProvider(IIOImagePixelDataProvider *this)
{
  IIOImagePixelDataProvider::~IIOImagePixelDataProvider(this);
  JUMPOUT(0x18D761C30);
}

{
  CGImage *v2;
  CGColorSpace *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  vImageConverter *v7;
  void *v8;

  *(_QWORD *)this = &off_1E1BB2590;
  if (*((_QWORD *)this + 30))
    CGAccessSessionRelease();
  v2 = (CGImage *)*((_QWORD *)this + 2);
  if (v2)
    CGImageRelease(v2);
  v3 = (CGColorSpace *)*((_QWORD *)this + 11);
  if (v3)
    CGColorSpaceRelease(v3);
  v4 = (const void *)*((_QWORD *)this + 25);
  if (v4)
    CFRelease(v4);
  v5 = (const void *)*((_QWORD *)this + 23);
  if (v5)
    CFRelease(v5);
  if (*((_QWORD *)this + 24))
    CGImageBlockSetRelease();
  v6 = (const void *)*((_QWORD *)this + 26);
  if (v6)
    CFRelease(v6);
  v7 = (vImageConverter *)*((_QWORD *)this + 15);
  if (v7)
    vImageConverter_Release(v7);
  v8 = (void *)*((_QWORD *)this + 28);
  if (v8)
    free(v8);
}

void ___ZN17IIO_WriterHandler16GetWriterHandlerEv_block_invoke()
{
  IIO_WriterHandler *v0;

  v0 = (IIO_WriterHandler *)operator new();
  IIO_WriterHandler::IIO_WriterHandler(v0);
  IIO_WriterHandler::GetWriterHandler(void)::gIIO_WriterHandler = (uint64_t)v0;
}

void sub_187EA0278(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x81C4018A671A6);
  _Unwind_Resume(a1);
}

void IIO_WriterHandler::IIO_WriterHandler(IIO_WriterHandler *this)
{
  double Current;
  double v3;

  *(_QWORD *)this = &off_1E1BB10F0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  Current = CFAbsoluteTimeGetCurrent();
  IIO_WriterHandler::buildWriterList(this);
  v3 = CFAbsoluteTimeGetCurrent();
  if ((gIIODebugFlags & 0xC) != 0)
    ImageIOLog("    IIO_WriterHandler::buildWriterList: %g ms\n", (v3 - Current) * 1000.0);
}

void sub_187EA0334(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 16) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void IIO_WriterHandler::buildWriterList(IIO_WriterHandler *this)
{
  IIO_Writer *Writer_AppleJPEG;
  IIO_Writer *v3;
  unint64_t v4;
  IIO_Writer **v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  IIO_Writer **v13;
  char *v14;
  char *v15;
  char *v16;
  IIO_Writer *v17;
  uint64_t Writer_PNG;
  uint64_t v19;
  unint64_t v20;
  uint64_t *v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  char *v28;
  uint64_t *v29;
  char *v30;
  char *v31;
  char *v32;
  uint64_t v33;
  IIO_Writer *Writer_GIF;
  IIO_Writer *v35;
  unint64_t v36;
  IIO_Writer **v37;
  _QWORD *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  char *v44;
  IIO_Writer **v45;
  char *v46;
  char *v47;
  char *v48;
  IIO_Writer *v49;
  IIO_Writer *Writer_TIFF;
  IIO_Writer *v51;
  unint64_t v52;
  IIO_Writer **v53;
  _QWORD *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  char *v60;
  IIO_Writer **v61;
  char *v62;
  char *v63;
  char *v64;
  IIO_Writer *v65;
  uint64_t Writer_JP2;
  uint64_t v67;
  unint64_t v68;
  uint64_t *v69;
  _QWORD *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  char *v76;
  uint64_t *v77;
  char *v78;
  char *v79;
  char *v80;
  uint64_t v81;
  uint64_t Writer_ATX;
  uint64_t v83;
  unint64_t v84;
  uint64_t *v85;
  _QWORD *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  unint64_t v91;
  char *v92;
  uint64_t *v93;
  char *v94;
  char *v95;
  char *v96;
  uint64_t v97;
  uint64_t Writer_KTX;
  uint64_t v99;
  unint64_t v100;
  uint64_t *v101;
  _QWORD *v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  unint64_t v107;
  char *v108;
  uint64_t *v109;
  char *v110;
  char *v111;
  char *v112;
  uint64_t v113;
  uint64_t Writer_KTX2;
  uint64_t v115;
  unint64_t v116;
  uint64_t *v117;
  _QWORD *v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  unint64_t v123;
  char *v124;
  uint64_t *v125;
  char *v126;
  char *v127;
  char *v128;
  uint64_t v129;
  IIO_Writer *Writer_ASTC;
  IIO_Writer *v131;
  unint64_t v132;
  IIO_Writer **v133;
  _QWORD *v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  unint64_t v139;
  char *v140;
  IIO_Writer **v141;
  char *v142;
  char *v143;
  char *v144;
  IIO_Writer *v145;
  IIO_Writer *Writer_BC;
  IIO_Writer *v147;
  unint64_t v148;
  IIO_Writer **v149;
  _QWORD *v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  unint64_t v155;
  char *v156;
  IIO_Writer **v157;
  char *v158;
  char *v159;
  char *v160;
  IIO_Writer *v161;
  IIO_Writer *Writer_AVCI;
  IIO_Writer *v163;
  unint64_t v164;
  IIO_Writer **v165;
  _QWORD *v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  unint64_t v171;
  char *v172;
  IIO_Writer **v173;
  char *v174;
  char *v175;
  char *v176;
  IIO_Writer *v177;
  IIO_Writer *Writer_HEIC;
  IIO_Writer *v179;
  unint64_t v180;
  IIO_Writer **v181;
  _QWORD *v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  unint64_t v187;
  char *v188;
  IIO_Writer **v189;
  char *v190;
  char *v191;
  char *v192;
  IIO_Writer *v193;
  IIO_Writer *Writer_HEIC_JPEG;
  IIO_Writer *v195;
  unint64_t v196;
  IIO_Writer **v197;
  _QWORD *v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  unint64_t v203;
  char *v204;
  IIO_Writer **v205;
  char *v206;
  char *v207;
  char *v208;
  IIO_Writer *v209;
  IIO_Writer *Writer_HEICS;
  IIO_Writer *v211;
  unint64_t v212;
  IIO_Writer **v213;
  _QWORD *v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  unint64_t v219;
  char *v220;
  IIO_Writer **v221;
  char *v222;
  char *v223;
  char *v224;
  IIO_Writer *v225;
  IIO_Writer *Writer_ICO;
  IIO_Writer *v227;
  unint64_t v228;
  IIO_Writer **v229;
  _QWORD *v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  unint64_t v235;
  char *v236;
  IIO_Writer **v237;
  char *v238;
  char *v239;
  char *v240;
  IIO_Writer *v241;
  IIO_Writer *Writer_BMP;
  IIO_Writer *v243;
  unint64_t v244;
  IIO_Writer **v245;
  _QWORD *v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  unint64_t v251;
  char *v252;
  IIO_Writer **v253;
  char *v254;
  char *v255;
  char *v256;
  IIO_Writer *v257;
  uint64_t Writer_ICNS;
  uint64_t v259;
  unint64_t v260;
  uint64_t *v261;
  _QWORD *v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  unint64_t v267;
  char *v268;
  uint64_t *v269;
  char *v270;
  char *v271;
  char *v272;
  uint64_t v273;
  uint64_t Writer_PSD;
  uint64_t v275;
  unint64_t v276;
  uint64_t *v277;
  _QWORD *v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  unint64_t v283;
  char *v284;
  uint64_t *v285;
  char *v286;
  char *v287;
  char *v288;
  uint64_t v289;
  IIO_Writer *Writer_PDF;
  IIO_Writer *v291;
  unint64_t v292;
  IIO_Writer **v293;
  _QWORD *v294;
  uint64_t v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  unint64_t v299;
  char *v300;
  IIO_Writer **v301;
  char *v302;
  char *v303;
  char *v304;
  IIO_Writer *v305;
  uint64_t v306;
  uint64_t v307;
  unint64_t v308;
  uint64_t *v309;
  _QWORD *v310;
  uint64_t v311;
  uint64_t v312;
  uint64_t v313;
  uint64_t v314;
  unint64_t v315;
  char *v316;
  uint64_t *v317;
  char *v318;
  char *v319;
  char *v320;
  uint64_t v321;
  IIO_Writer *Writer_TGA;
  IIO_Writer *v323;
  unint64_t v324;
  IIO_Writer **v325;
  _QWORD *v326;
  uint64_t v327;
  uint64_t v328;
  uint64_t v329;
  uint64_t v330;
  unint64_t v331;
  char *v332;
  IIO_Writer **v333;
  char *v334;
  char *v335;
  char *v336;
  IIO_Writer *v337;
  uint64_t Writer_EXR;
  uint64_t v339;
  unint64_t v340;
  uint64_t *v341;
  _QWORD *v342;
  uint64_t v343;
  uint64_t v344;
  uint64_t v345;
  uint64_t v346;
  unint64_t v347;
  char *v348;
  uint64_t *v349;
  char *v350;
  char *v351;
  char *v352;
  uint64_t v353;
  uint64_t Writer_PBM;
  uint64_t v355;
  unint64_t v356;
  uint64_t *v357;
  _QWORD *v358;
  uint64_t v359;
  uint64_t v360;
  uint64_t v361;
  uint64_t v362;
  unint64_t v363;
  char *v364;
  uint64_t *v365;
  char *v366;
  char *v367;
  char *v368;
  uint64_t v369;
  uint64_t Writer_PVR;
  uint64_t v371;
  unint64_t v372;
  uint64_t *v373;
  _QWORD *v374;
  uint64_t v375;
  uint64_t v376;
  uint64_t v377;
  uint64_t v378;
  unint64_t v379;
  char *v380;
  uint64_t *v381;
  char *v382;
  char *v383;
  char *v384;
  uint64_t v385;

  IIOInitDebugFlags();
  Writer_AppleJPEG = CreateWriter_AppleJPEG();
  if (Writer_AppleJPEG)
  {
    v3 = Writer_AppleJPEG;
    v4 = *((_QWORD *)this + 3);
    v5 = (IIO_Writer **)*((_QWORD *)this + 2);
    if ((unint64_t)v5 >= v4)
    {
      v7 = *((_QWORD *)this + 1);
      v8 = ((uint64_t)v5 - v7) >> 3;
      if ((unint64_t)(v8 + 1) >> 61)
        goto LABEL_434;
      v9 = v4 - v7;
      v10 = v9 >> 2;
      if (v9 >> 2 <= (unint64_t)(v8 + 1))
        v10 = v8 + 1;
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8)
        v11 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v11 = v10;
      if (v11)
        v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 24, v11);
      else
        v12 = 0;
      v13 = (IIO_Writer **)&v12[8 * v8];
      v14 = &v12[8 * v11];
      *v13 = v3;
      v6 = v13 + 1;
      v16 = (char *)*((_QWORD *)this + 1);
      v15 = (char *)*((_QWORD *)this + 2);
      if (v15 != v16)
      {
        do
        {
          v17 = (IIO_Writer *)*((_QWORD *)v15 - 1);
          v15 -= 8;
          *--v13 = v17;
        }
        while (v15 != v16);
        v15 = (char *)*((_QWORD *)this + 1);
      }
      *((_QWORD *)this + 1) = v13;
      *((_QWORD *)this + 2) = v6;
      *((_QWORD *)this + 3) = v14;
      if (v15)
        operator delete(v15);
    }
    else
    {
      *v5 = Writer_AppleJPEG;
      v6 = v5 + 1;
    }
    *((_QWORD *)this + 2) = v6;
  }
  Writer_PNG = CreateWriter_PNG();
  if (Writer_PNG)
  {
    v19 = Writer_PNG;
    v20 = *((_QWORD *)this + 3);
    v21 = (uint64_t *)*((_QWORD *)this + 2);
    if ((unint64_t)v21 >= v20)
    {
      v23 = *((_QWORD *)this + 1);
      v24 = ((uint64_t)v21 - v23) >> 3;
      if ((unint64_t)(v24 + 1) >> 61)
        goto LABEL_434;
      v25 = v20 - v23;
      v26 = v25 >> 2;
      if (v25 >> 2 <= (unint64_t)(v24 + 1))
        v26 = v24 + 1;
      if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8)
        v27 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v27 = v26;
      if (v27)
        v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 24, v27);
      else
        v28 = 0;
      v29 = (uint64_t *)&v28[8 * v24];
      v30 = &v28[8 * v27];
      *v29 = v19;
      v22 = v29 + 1;
      v32 = (char *)*((_QWORD *)this + 1);
      v31 = (char *)*((_QWORD *)this + 2);
      if (v31 != v32)
      {
        do
        {
          v33 = *((_QWORD *)v31 - 1);
          v31 -= 8;
          *--v29 = v33;
        }
        while (v31 != v32);
        v31 = (char *)*((_QWORD *)this + 1);
      }
      *((_QWORD *)this + 1) = v29;
      *((_QWORD *)this + 2) = v22;
      *((_QWORD *)this + 3) = v30;
      if (v31)
        operator delete(v31);
    }
    else
    {
      *v21 = Writer_PNG;
      v22 = v21 + 1;
    }
    *((_QWORD *)this + 2) = v22;
  }
  Writer_GIF = CreateWriter_GIF();
  if (Writer_GIF)
  {
    v35 = Writer_GIF;
    v36 = *((_QWORD *)this + 3);
    v37 = (IIO_Writer **)*((_QWORD *)this + 2);
    if ((unint64_t)v37 >= v36)
    {
      v39 = *((_QWORD *)this + 1);
      v40 = ((uint64_t)v37 - v39) >> 3;
      if ((unint64_t)(v40 + 1) >> 61)
        goto LABEL_434;
      v41 = v36 - v39;
      v42 = v41 >> 2;
      if (v41 >> 2 <= (unint64_t)(v40 + 1))
        v42 = v40 + 1;
      if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFF8)
        v43 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v43 = v42;
      if (v43)
        v44 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 24, v43);
      else
        v44 = 0;
      v45 = (IIO_Writer **)&v44[8 * v40];
      v46 = &v44[8 * v43];
      *v45 = v35;
      v38 = v45 + 1;
      v48 = (char *)*((_QWORD *)this + 1);
      v47 = (char *)*((_QWORD *)this + 2);
      if (v47 != v48)
      {
        do
        {
          v49 = (IIO_Writer *)*((_QWORD *)v47 - 1);
          v47 -= 8;
          *--v45 = v49;
        }
        while (v47 != v48);
        v47 = (char *)*((_QWORD *)this + 1);
      }
      *((_QWORD *)this + 1) = v45;
      *((_QWORD *)this + 2) = v38;
      *((_QWORD *)this + 3) = v46;
      if (v47)
        operator delete(v47);
    }
    else
    {
      *v37 = Writer_GIF;
      v38 = v37 + 1;
    }
    *((_QWORD *)this + 2) = v38;
  }
  Writer_TIFF = CreateWriter_TIFF();
  if (Writer_TIFF)
  {
    v51 = Writer_TIFF;
    v52 = *((_QWORD *)this + 3);
    v53 = (IIO_Writer **)*((_QWORD *)this + 2);
    if ((unint64_t)v53 >= v52)
    {
      v55 = *((_QWORD *)this + 1);
      v56 = ((uint64_t)v53 - v55) >> 3;
      if ((unint64_t)(v56 + 1) >> 61)
        goto LABEL_434;
      v57 = v52 - v55;
      v58 = v57 >> 2;
      if (v57 >> 2 <= (unint64_t)(v56 + 1))
        v58 = v56 + 1;
      if ((unint64_t)v57 >= 0x7FFFFFFFFFFFFFF8)
        v59 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v59 = v58;
      if (v59)
        v60 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 24, v59);
      else
        v60 = 0;
      v61 = (IIO_Writer **)&v60[8 * v56];
      v62 = &v60[8 * v59];
      *v61 = v51;
      v54 = v61 + 1;
      v64 = (char *)*((_QWORD *)this + 1);
      v63 = (char *)*((_QWORD *)this + 2);
      if (v63 != v64)
      {
        do
        {
          v65 = (IIO_Writer *)*((_QWORD *)v63 - 1);
          v63 -= 8;
          *--v61 = v65;
        }
        while (v63 != v64);
        v63 = (char *)*((_QWORD *)this + 1);
      }
      *((_QWORD *)this + 1) = v61;
      *((_QWORD *)this + 2) = v54;
      *((_QWORD *)this + 3) = v62;
      if (v63)
        operator delete(v63);
    }
    else
    {
      *v53 = Writer_TIFF;
      v54 = v53 + 1;
    }
    *((_QWORD *)this + 2) = v54;
  }
  Writer_JP2 = CreateWriter_JP2();
  if (Writer_JP2)
  {
    v67 = Writer_JP2;
    v68 = *((_QWORD *)this + 3);
    v69 = (uint64_t *)*((_QWORD *)this + 2);
    if ((unint64_t)v69 >= v68)
    {
      v71 = *((_QWORD *)this + 1);
      v72 = ((uint64_t)v69 - v71) >> 3;
      if ((unint64_t)(v72 + 1) >> 61)
        goto LABEL_434;
      v73 = v68 - v71;
      v74 = v73 >> 2;
      if (v73 >> 2 <= (unint64_t)(v72 + 1))
        v74 = v72 + 1;
      if ((unint64_t)v73 >= 0x7FFFFFFFFFFFFFF8)
        v75 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v75 = v74;
      if (v75)
        v76 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 24, v75);
      else
        v76 = 0;
      v77 = (uint64_t *)&v76[8 * v72];
      v78 = &v76[8 * v75];
      *v77 = v67;
      v70 = v77 + 1;
      v80 = (char *)*((_QWORD *)this + 1);
      v79 = (char *)*((_QWORD *)this + 2);
      if (v79 != v80)
      {
        do
        {
          v81 = *((_QWORD *)v79 - 1);
          v79 -= 8;
          *--v77 = v81;
        }
        while (v79 != v80);
        v79 = (char *)*((_QWORD *)this + 1);
      }
      *((_QWORD *)this + 1) = v77;
      *((_QWORD *)this + 2) = v70;
      *((_QWORD *)this + 3) = v78;
      if (v79)
        operator delete(v79);
    }
    else
    {
      *v69 = Writer_JP2;
      v70 = v69 + 1;
    }
    *((_QWORD *)this + 2) = v70;
  }
  Writer_ATX = CreateWriter_ATX();
  if (Writer_ATX)
  {
    v83 = Writer_ATX;
    v84 = *((_QWORD *)this + 3);
    v85 = (uint64_t *)*((_QWORD *)this + 2);
    if ((unint64_t)v85 >= v84)
    {
      v87 = *((_QWORD *)this + 1);
      v88 = ((uint64_t)v85 - v87) >> 3;
      if ((unint64_t)(v88 + 1) >> 61)
        goto LABEL_434;
      v89 = v84 - v87;
      v90 = v89 >> 2;
      if (v89 >> 2 <= (unint64_t)(v88 + 1))
        v90 = v88 + 1;
      if ((unint64_t)v89 >= 0x7FFFFFFFFFFFFFF8)
        v91 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v91 = v90;
      if (v91)
        v92 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 24, v91);
      else
        v92 = 0;
      v93 = (uint64_t *)&v92[8 * v88];
      v94 = &v92[8 * v91];
      *v93 = v83;
      v86 = v93 + 1;
      v96 = (char *)*((_QWORD *)this + 1);
      v95 = (char *)*((_QWORD *)this + 2);
      if (v95 != v96)
      {
        do
        {
          v97 = *((_QWORD *)v95 - 1);
          v95 -= 8;
          *--v93 = v97;
        }
        while (v95 != v96);
        v95 = (char *)*((_QWORD *)this + 1);
      }
      *((_QWORD *)this + 1) = v93;
      *((_QWORD *)this + 2) = v86;
      *((_QWORD *)this + 3) = v94;
      if (v95)
        operator delete(v95);
    }
    else
    {
      *v85 = Writer_ATX;
      v86 = v85 + 1;
    }
    *((_QWORD *)this + 2) = v86;
  }
  Writer_KTX = CreateWriter_KTX();
  if (Writer_KTX)
  {
    v99 = Writer_KTX;
    v100 = *((_QWORD *)this + 3);
    v101 = (uint64_t *)*((_QWORD *)this + 2);
    if ((unint64_t)v101 >= v100)
    {
      v103 = *((_QWORD *)this + 1);
      v104 = ((uint64_t)v101 - v103) >> 3;
      if ((unint64_t)(v104 + 1) >> 61)
        goto LABEL_434;
      v105 = v100 - v103;
      v106 = v105 >> 2;
      if (v105 >> 2 <= (unint64_t)(v104 + 1))
        v106 = v104 + 1;
      if ((unint64_t)v105 >= 0x7FFFFFFFFFFFFFF8)
        v107 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v107 = v106;
      if (v107)
        v108 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 24, v107);
      else
        v108 = 0;
      v109 = (uint64_t *)&v108[8 * v104];
      v110 = &v108[8 * v107];
      *v109 = v99;
      v102 = v109 + 1;
      v112 = (char *)*((_QWORD *)this + 1);
      v111 = (char *)*((_QWORD *)this + 2);
      if (v111 != v112)
      {
        do
        {
          v113 = *((_QWORD *)v111 - 1);
          v111 -= 8;
          *--v109 = v113;
        }
        while (v111 != v112);
        v111 = (char *)*((_QWORD *)this + 1);
      }
      *((_QWORD *)this + 1) = v109;
      *((_QWORD *)this + 2) = v102;
      *((_QWORD *)this + 3) = v110;
      if (v111)
        operator delete(v111);
    }
    else
    {
      *v101 = Writer_KTX;
      v102 = v101 + 1;
    }
    *((_QWORD *)this + 2) = v102;
  }
  Writer_KTX2 = CreateWriter_KTX2();
  if (Writer_KTX2)
  {
    v115 = Writer_KTX2;
    v116 = *((_QWORD *)this + 3);
    v117 = (uint64_t *)*((_QWORD *)this + 2);
    if ((unint64_t)v117 >= v116)
    {
      v119 = *((_QWORD *)this + 1);
      v120 = ((uint64_t)v117 - v119) >> 3;
      if ((unint64_t)(v120 + 1) >> 61)
        goto LABEL_434;
      v121 = v116 - v119;
      v122 = v121 >> 2;
      if (v121 >> 2 <= (unint64_t)(v120 + 1))
        v122 = v120 + 1;
      if ((unint64_t)v121 >= 0x7FFFFFFFFFFFFFF8)
        v123 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v123 = v122;
      if (v123)
        v124 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 24, v123);
      else
        v124 = 0;
      v125 = (uint64_t *)&v124[8 * v120];
      v126 = &v124[8 * v123];
      *v125 = v115;
      v118 = v125 + 1;
      v128 = (char *)*((_QWORD *)this + 1);
      v127 = (char *)*((_QWORD *)this + 2);
      if (v127 != v128)
      {
        do
        {
          v129 = *((_QWORD *)v127 - 1);
          v127 -= 8;
          *--v125 = v129;
        }
        while (v127 != v128);
        v127 = (char *)*((_QWORD *)this + 1);
      }
      *((_QWORD *)this + 1) = v125;
      *((_QWORD *)this + 2) = v118;
      *((_QWORD *)this + 3) = v126;
      if (v127)
        operator delete(v127);
    }
    else
    {
      *v117 = Writer_KTX2;
      v118 = v117 + 1;
    }
    *((_QWORD *)this + 2) = v118;
  }
  Writer_ASTC = CreateWriter_ASTC();
  if (Writer_ASTC)
  {
    v131 = Writer_ASTC;
    v132 = *((_QWORD *)this + 3);
    v133 = (IIO_Writer **)*((_QWORD *)this + 2);
    if ((unint64_t)v133 >= v132)
    {
      v135 = *((_QWORD *)this + 1);
      v136 = ((uint64_t)v133 - v135) >> 3;
      if ((unint64_t)(v136 + 1) >> 61)
        goto LABEL_434;
      v137 = v132 - v135;
      v138 = v137 >> 2;
      if (v137 >> 2 <= (unint64_t)(v136 + 1))
        v138 = v136 + 1;
      if ((unint64_t)v137 >= 0x7FFFFFFFFFFFFFF8)
        v139 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v139 = v138;
      if (v139)
        v140 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 24, v139);
      else
        v140 = 0;
      v141 = (IIO_Writer **)&v140[8 * v136];
      v142 = &v140[8 * v139];
      *v141 = v131;
      v134 = v141 + 1;
      v144 = (char *)*((_QWORD *)this + 1);
      v143 = (char *)*((_QWORD *)this + 2);
      if (v143 != v144)
      {
        do
        {
          v145 = (IIO_Writer *)*((_QWORD *)v143 - 1);
          v143 -= 8;
          *--v141 = v145;
        }
        while (v143 != v144);
        v143 = (char *)*((_QWORD *)this + 1);
      }
      *((_QWORD *)this + 1) = v141;
      *((_QWORD *)this + 2) = v134;
      *((_QWORD *)this + 3) = v142;
      if (v143)
        operator delete(v143);
    }
    else
    {
      *v133 = Writer_ASTC;
      v134 = v133 + 1;
    }
    *((_QWORD *)this + 2) = v134;
  }
  Writer_BC = CreateWriter_BC();
  if (Writer_BC)
  {
    v147 = Writer_BC;
    v148 = *((_QWORD *)this + 3);
    v149 = (IIO_Writer **)*((_QWORD *)this + 2);
    if ((unint64_t)v149 >= v148)
    {
      v151 = *((_QWORD *)this + 1);
      v152 = ((uint64_t)v149 - v151) >> 3;
      if ((unint64_t)(v152 + 1) >> 61)
        goto LABEL_434;
      v153 = v148 - v151;
      v154 = v153 >> 2;
      if (v153 >> 2 <= (unint64_t)(v152 + 1))
        v154 = v152 + 1;
      if ((unint64_t)v153 >= 0x7FFFFFFFFFFFFFF8)
        v155 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v155 = v154;
      if (v155)
        v156 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 24, v155);
      else
        v156 = 0;
      v157 = (IIO_Writer **)&v156[8 * v152];
      v158 = &v156[8 * v155];
      *v157 = v147;
      v150 = v157 + 1;
      v160 = (char *)*((_QWORD *)this + 1);
      v159 = (char *)*((_QWORD *)this + 2);
      if (v159 != v160)
      {
        do
        {
          v161 = (IIO_Writer *)*((_QWORD *)v159 - 1);
          v159 -= 8;
          *--v157 = v161;
        }
        while (v159 != v160);
        v159 = (char *)*((_QWORD *)this + 1);
      }
      *((_QWORD *)this + 1) = v157;
      *((_QWORD *)this + 2) = v150;
      *((_QWORD *)this + 3) = v158;
      if (v159)
        operator delete(v159);
    }
    else
    {
      *v149 = Writer_BC;
      v150 = v149 + 1;
    }
    *((_QWORD *)this + 2) = v150;
  }
  Writer_AVCI = CreateWriter_AVCI();
  if (Writer_AVCI)
  {
    v163 = Writer_AVCI;
    v164 = *((_QWORD *)this + 3);
    v165 = (IIO_Writer **)*((_QWORD *)this + 2);
    if ((unint64_t)v165 >= v164)
    {
      v167 = *((_QWORD *)this + 1);
      v168 = ((uint64_t)v165 - v167) >> 3;
      if ((unint64_t)(v168 + 1) >> 61)
        goto LABEL_434;
      v169 = v164 - v167;
      v170 = v169 >> 2;
      if (v169 >> 2 <= (unint64_t)(v168 + 1))
        v170 = v168 + 1;
      if ((unint64_t)v169 >= 0x7FFFFFFFFFFFFFF8)
        v171 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v171 = v170;
      if (v171)
        v172 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 24, v171);
      else
        v172 = 0;
      v173 = (IIO_Writer **)&v172[8 * v168];
      v174 = &v172[8 * v171];
      *v173 = v163;
      v166 = v173 + 1;
      v176 = (char *)*((_QWORD *)this + 1);
      v175 = (char *)*((_QWORD *)this + 2);
      if (v175 != v176)
      {
        do
        {
          v177 = (IIO_Writer *)*((_QWORD *)v175 - 1);
          v175 -= 8;
          *--v173 = v177;
        }
        while (v175 != v176);
        v175 = (char *)*((_QWORD *)this + 1);
      }
      *((_QWORD *)this + 1) = v173;
      *((_QWORD *)this + 2) = v166;
      *((_QWORD *)this + 3) = v174;
      if (v175)
        operator delete(v175);
    }
    else
    {
      *v165 = Writer_AVCI;
      v166 = v165 + 1;
    }
    *((_QWORD *)this + 2) = v166;
  }
  Writer_HEIC = CreateWriter_HEIC();
  if (Writer_HEIC)
  {
    v179 = Writer_HEIC;
    v180 = *((_QWORD *)this + 3);
    v181 = (IIO_Writer **)*((_QWORD *)this + 2);
    if ((unint64_t)v181 >= v180)
    {
      v183 = *((_QWORD *)this + 1);
      v184 = ((uint64_t)v181 - v183) >> 3;
      if ((unint64_t)(v184 + 1) >> 61)
        goto LABEL_434;
      v185 = v180 - v183;
      v186 = v185 >> 2;
      if (v185 >> 2 <= (unint64_t)(v184 + 1))
        v186 = v184 + 1;
      if ((unint64_t)v185 >= 0x7FFFFFFFFFFFFFF8)
        v187 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v187 = v186;
      if (v187)
        v188 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 24, v187);
      else
        v188 = 0;
      v189 = (IIO_Writer **)&v188[8 * v184];
      v190 = &v188[8 * v187];
      *v189 = v179;
      v182 = v189 + 1;
      v192 = (char *)*((_QWORD *)this + 1);
      v191 = (char *)*((_QWORD *)this + 2);
      if (v191 != v192)
      {
        do
        {
          v193 = (IIO_Writer *)*((_QWORD *)v191 - 1);
          v191 -= 8;
          *--v189 = v193;
        }
        while (v191 != v192);
        v191 = (char *)*((_QWORD *)this + 1);
      }
      *((_QWORD *)this + 1) = v189;
      *((_QWORD *)this + 2) = v182;
      *((_QWORD *)this + 3) = v190;
      if (v191)
        operator delete(v191);
    }
    else
    {
      *v181 = Writer_HEIC;
      v182 = v181 + 1;
    }
    *((_QWORD *)this + 2) = v182;
  }
  Writer_HEIC_JPEG = CreateWriter_HEIC_JPEG();
  if (Writer_HEIC_JPEG)
  {
    v195 = Writer_HEIC_JPEG;
    v196 = *((_QWORD *)this + 3);
    v197 = (IIO_Writer **)*((_QWORD *)this + 2);
    if ((unint64_t)v197 >= v196)
    {
      v199 = *((_QWORD *)this + 1);
      v200 = ((uint64_t)v197 - v199) >> 3;
      if ((unint64_t)(v200 + 1) >> 61)
        goto LABEL_434;
      v201 = v196 - v199;
      v202 = v201 >> 2;
      if (v201 >> 2 <= (unint64_t)(v200 + 1))
        v202 = v200 + 1;
      if ((unint64_t)v201 >= 0x7FFFFFFFFFFFFFF8)
        v203 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v203 = v202;
      if (v203)
        v204 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 24, v203);
      else
        v204 = 0;
      v205 = (IIO_Writer **)&v204[8 * v200];
      v206 = &v204[8 * v203];
      *v205 = v195;
      v198 = v205 + 1;
      v208 = (char *)*((_QWORD *)this + 1);
      v207 = (char *)*((_QWORD *)this + 2);
      if (v207 != v208)
      {
        do
        {
          v209 = (IIO_Writer *)*((_QWORD *)v207 - 1);
          v207 -= 8;
          *--v205 = v209;
        }
        while (v207 != v208);
        v207 = (char *)*((_QWORD *)this + 1);
      }
      *((_QWORD *)this + 1) = v205;
      *((_QWORD *)this + 2) = v198;
      *((_QWORD *)this + 3) = v206;
      if (v207)
        operator delete(v207);
    }
    else
    {
      *v197 = Writer_HEIC_JPEG;
      v198 = v197 + 1;
    }
    *((_QWORD *)this + 2) = v198;
  }
  Writer_HEICS = CreateWriter_HEICS();
  if (Writer_HEICS)
  {
    v211 = Writer_HEICS;
    v212 = *((_QWORD *)this + 3);
    v213 = (IIO_Writer **)*((_QWORD *)this + 2);
    if ((unint64_t)v213 >= v212)
    {
      v215 = *((_QWORD *)this + 1);
      v216 = ((uint64_t)v213 - v215) >> 3;
      if ((unint64_t)(v216 + 1) >> 61)
        goto LABEL_434;
      v217 = v212 - v215;
      v218 = v217 >> 2;
      if (v217 >> 2 <= (unint64_t)(v216 + 1))
        v218 = v216 + 1;
      if ((unint64_t)v217 >= 0x7FFFFFFFFFFFFFF8)
        v219 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v219 = v218;
      if (v219)
        v220 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 24, v219);
      else
        v220 = 0;
      v221 = (IIO_Writer **)&v220[8 * v216];
      v222 = &v220[8 * v219];
      *v221 = v211;
      v214 = v221 + 1;
      v224 = (char *)*((_QWORD *)this + 1);
      v223 = (char *)*((_QWORD *)this + 2);
      if (v223 != v224)
      {
        do
        {
          v225 = (IIO_Writer *)*((_QWORD *)v223 - 1);
          v223 -= 8;
          *--v221 = v225;
        }
        while (v223 != v224);
        v223 = (char *)*((_QWORD *)this + 1);
      }
      *((_QWORD *)this + 1) = v221;
      *((_QWORD *)this + 2) = v214;
      *((_QWORD *)this + 3) = v222;
      if (v223)
        operator delete(v223);
    }
    else
    {
      *v213 = Writer_HEICS;
      v214 = v213 + 1;
    }
    *((_QWORD *)this + 2) = v214;
  }
  Writer_ICO = CreateWriter_ICO();
  if (Writer_ICO)
  {
    v227 = Writer_ICO;
    v228 = *((_QWORD *)this + 3);
    v229 = (IIO_Writer **)*((_QWORD *)this + 2);
    if ((unint64_t)v229 >= v228)
    {
      v231 = *((_QWORD *)this + 1);
      v232 = ((uint64_t)v229 - v231) >> 3;
      if ((unint64_t)(v232 + 1) >> 61)
        goto LABEL_434;
      v233 = v228 - v231;
      v234 = v233 >> 2;
      if (v233 >> 2 <= (unint64_t)(v232 + 1))
        v234 = v232 + 1;
      if ((unint64_t)v233 >= 0x7FFFFFFFFFFFFFF8)
        v235 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v235 = v234;
      if (v235)
        v236 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 24, v235);
      else
        v236 = 0;
      v237 = (IIO_Writer **)&v236[8 * v232];
      v238 = &v236[8 * v235];
      *v237 = v227;
      v230 = v237 + 1;
      v240 = (char *)*((_QWORD *)this + 1);
      v239 = (char *)*((_QWORD *)this + 2);
      if (v239 != v240)
      {
        do
        {
          v241 = (IIO_Writer *)*((_QWORD *)v239 - 1);
          v239 -= 8;
          *--v237 = v241;
        }
        while (v239 != v240);
        v239 = (char *)*((_QWORD *)this + 1);
      }
      *((_QWORD *)this + 1) = v237;
      *((_QWORD *)this + 2) = v230;
      *((_QWORD *)this + 3) = v238;
      if (v239)
        operator delete(v239);
    }
    else
    {
      *v229 = Writer_ICO;
      v230 = v229 + 1;
    }
    *((_QWORD *)this + 2) = v230;
  }
  Writer_BMP = CreateWriter_BMP();
  if (Writer_BMP)
  {
    v243 = Writer_BMP;
    v244 = *((_QWORD *)this + 3);
    v245 = (IIO_Writer **)*((_QWORD *)this + 2);
    if ((unint64_t)v245 >= v244)
    {
      v247 = *((_QWORD *)this + 1);
      v248 = ((uint64_t)v245 - v247) >> 3;
      if ((unint64_t)(v248 + 1) >> 61)
        goto LABEL_434;
      v249 = v244 - v247;
      v250 = v249 >> 2;
      if (v249 >> 2 <= (unint64_t)(v248 + 1))
        v250 = v248 + 1;
      if ((unint64_t)v249 >= 0x7FFFFFFFFFFFFFF8)
        v251 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v251 = v250;
      if (v251)
        v252 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 24, v251);
      else
        v252 = 0;
      v253 = (IIO_Writer **)&v252[8 * v248];
      v254 = &v252[8 * v251];
      *v253 = v243;
      v246 = v253 + 1;
      v256 = (char *)*((_QWORD *)this + 1);
      v255 = (char *)*((_QWORD *)this + 2);
      if (v255 != v256)
      {
        do
        {
          v257 = (IIO_Writer *)*((_QWORD *)v255 - 1);
          v255 -= 8;
          *--v253 = v257;
        }
        while (v255 != v256);
        v255 = (char *)*((_QWORD *)this + 1);
      }
      *((_QWORD *)this + 1) = v253;
      *((_QWORD *)this + 2) = v246;
      *((_QWORD *)this + 3) = v254;
      if (v255)
        operator delete(v255);
    }
    else
    {
      *v245 = Writer_BMP;
      v246 = v245 + 1;
    }
    *((_QWORD *)this + 2) = v246;
  }
  Writer_ICNS = CreateWriter_ICNS();
  if (Writer_ICNS)
  {
    v259 = Writer_ICNS;
    v260 = *((_QWORD *)this + 3);
    v261 = (uint64_t *)*((_QWORD *)this + 2);
    if ((unint64_t)v261 >= v260)
    {
      v263 = *((_QWORD *)this + 1);
      v264 = ((uint64_t)v261 - v263) >> 3;
      if ((unint64_t)(v264 + 1) >> 61)
        goto LABEL_434;
      v265 = v260 - v263;
      v266 = v265 >> 2;
      if (v265 >> 2 <= (unint64_t)(v264 + 1))
        v266 = v264 + 1;
      if ((unint64_t)v265 >= 0x7FFFFFFFFFFFFFF8)
        v267 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v267 = v266;
      if (v267)
        v268 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 24, v267);
      else
        v268 = 0;
      v269 = (uint64_t *)&v268[8 * v264];
      v270 = &v268[8 * v267];
      *v269 = v259;
      v262 = v269 + 1;
      v272 = (char *)*((_QWORD *)this + 1);
      v271 = (char *)*((_QWORD *)this + 2);
      if (v271 != v272)
      {
        do
        {
          v273 = *((_QWORD *)v271 - 1);
          v271 -= 8;
          *--v269 = v273;
        }
        while (v271 != v272);
        v271 = (char *)*((_QWORD *)this + 1);
      }
      *((_QWORD *)this + 1) = v269;
      *((_QWORD *)this + 2) = v262;
      *((_QWORD *)this + 3) = v270;
      if (v271)
        operator delete(v271);
    }
    else
    {
      *v261 = Writer_ICNS;
      v262 = v261 + 1;
    }
    *((_QWORD *)this + 2) = v262;
  }
  Writer_PSD = CreateWriter_PSD();
  if (Writer_PSD)
  {
    v275 = Writer_PSD;
    v276 = *((_QWORD *)this + 3);
    v277 = (uint64_t *)*((_QWORD *)this + 2);
    if ((unint64_t)v277 >= v276)
    {
      v279 = *((_QWORD *)this + 1);
      v280 = ((uint64_t)v277 - v279) >> 3;
      if ((unint64_t)(v280 + 1) >> 61)
        goto LABEL_434;
      v281 = v276 - v279;
      v282 = v281 >> 2;
      if (v281 >> 2 <= (unint64_t)(v280 + 1))
        v282 = v280 + 1;
      if ((unint64_t)v281 >= 0x7FFFFFFFFFFFFFF8)
        v283 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v283 = v282;
      if (v283)
        v284 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 24, v283);
      else
        v284 = 0;
      v285 = (uint64_t *)&v284[8 * v280];
      v286 = &v284[8 * v283];
      *v285 = v275;
      v278 = v285 + 1;
      v288 = (char *)*((_QWORD *)this + 1);
      v287 = (char *)*((_QWORD *)this + 2);
      if (v287 != v288)
      {
        do
        {
          v289 = *((_QWORD *)v287 - 1);
          v287 -= 8;
          *--v285 = v289;
        }
        while (v287 != v288);
        v287 = (char *)*((_QWORD *)this + 1);
      }
      *((_QWORD *)this + 1) = v285;
      *((_QWORD *)this + 2) = v278;
      *((_QWORD *)this + 3) = v286;
      if (v287)
        operator delete(v287);
    }
    else
    {
      *v277 = Writer_PSD;
      v278 = v277 + 1;
    }
    *((_QWORD *)this + 2) = v278;
  }
  Writer_PDF = CreateWriter_PDF();
  if (Writer_PDF)
  {
    v291 = Writer_PDF;
    v292 = *((_QWORD *)this + 3);
    v293 = (IIO_Writer **)*((_QWORD *)this + 2);
    if ((unint64_t)v293 >= v292)
    {
      v295 = *((_QWORD *)this + 1);
      v296 = ((uint64_t)v293 - v295) >> 3;
      if ((unint64_t)(v296 + 1) >> 61)
        goto LABEL_434;
      v297 = v292 - v295;
      v298 = v297 >> 2;
      if (v297 >> 2 <= (unint64_t)(v296 + 1))
        v298 = v296 + 1;
      if ((unint64_t)v297 >= 0x7FFFFFFFFFFFFFF8)
        v299 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v299 = v298;
      if (v299)
        v300 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 24, v299);
      else
        v300 = 0;
      v301 = (IIO_Writer **)&v300[8 * v296];
      v302 = &v300[8 * v299];
      *v301 = v291;
      v294 = v301 + 1;
      v304 = (char *)*((_QWORD *)this + 1);
      v303 = (char *)*((_QWORD *)this + 2);
      if (v303 != v304)
      {
        do
        {
          v305 = (IIO_Writer *)*((_QWORD *)v303 - 1);
          v303 -= 8;
          *--v301 = v305;
        }
        while (v303 != v304);
        v303 = (char *)*((_QWORD *)this + 1);
      }
      *((_QWORD *)this + 1) = v301;
      *((_QWORD *)this + 2) = v294;
      *((_QWORD *)this + 3) = v302;
      if (v303)
        operator delete(v303);
    }
    else
    {
      *v293 = Writer_PDF;
      v294 = v293 + 1;
    }
    *((_QWORD *)this + 2) = v294;
  }
  v306 = IIOLookupISR();
  if (v306)
  {
    v307 = v306;
    v308 = *((_QWORD *)this + 3);
    v309 = (uint64_t *)*((_QWORD *)this + 2);
    if ((unint64_t)v309 >= v308)
    {
      v311 = *((_QWORD *)this + 1);
      v312 = ((uint64_t)v309 - v311) >> 3;
      if ((unint64_t)(v312 + 1) >> 61)
        goto LABEL_434;
      v313 = v308 - v311;
      v314 = v313 >> 2;
      if (v313 >> 2 <= (unint64_t)(v312 + 1))
        v314 = v312 + 1;
      if ((unint64_t)v313 >= 0x7FFFFFFFFFFFFFF8)
        v315 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v315 = v314;
      if (v315)
        v316 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 24, v315);
      else
        v316 = 0;
      v317 = (uint64_t *)&v316[8 * v312];
      v318 = &v316[8 * v315];
      *v317 = v307;
      v310 = v317 + 1;
      v320 = (char *)*((_QWORD *)this + 1);
      v319 = (char *)*((_QWORD *)this + 2);
      if (v319 != v320)
      {
        do
        {
          v321 = *((_QWORD *)v319 - 1);
          v319 -= 8;
          *--v317 = v321;
        }
        while (v319 != v320);
        v319 = (char *)*((_QWORD *)this + 1);
      }
      *((_QWORD *)this + 1) = v317;
      *((_QWORD *)this + 2) = v310;
      *((_QWORD *)this + 3) = v318;
      if (v319)
        operator delete(v319);
    }
    else
    {
      *v309 = v306;
      v310 = v309 + 1;
    }
    *((_QWORD *)this + 2) = v310;
  }
  Writer_TGA = CreateWriter_TGA();
  if (Writer_TGA)
  {
    v323 = Writer_TGA;
    v324 = *((_QWORD *)this + 3);
    v325 = (IIO_Writer **)*((_QWORD *)this + 2);
    if ((unint64_t)v325 >= v324)
    {
      v327 = *((_QWORD *)this + 1);
      v328 = ((uint64_t)v325 - v327) >> 3;
      if ((unint64_t)(v328 + 1) >> 61)
        goto LABEL_434;
      v329 = v324 - v327;
      v330 = v329 >> 2;
      if (v329 >> 2 <= (unint64_t)(v328 + 1))
        v330 = v328 + 1;
      if ((unint64_t)v329 >= 0x7FFFFFFFFFFFFFF8)
        v331 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v331 = v330;
      if (v331)
        v332 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 24, v331);
      else
        v332 = 0;
      v333 = (IIO_Writer **)&v332[8 * v328];
      v334 = &v332[8 * v331];
      *v333 = v323;
      v326 = v333 + 1;
      v336 = (char *)*((_QWORD *)this + 1);
      v335 = (char *)*((_QWORD *)this + 2);
      if (v335 != v336)
      {
        do
        {
          v337 = (IIO_Writer *)*((_QWORD *)v335 - 1);
          v335 -= 8;
          *--v333 = v337;
        }
        while (v335 != v336);
        v335 = (char *)*((_QWORD *)this + 1);
      }
      *((_QWORD *)this + 1) = v333;
      *((_QWORD *)this + 2) = v326;
      *((_QWORD *)this + 3) = v334;
      if (v335)
        operator delete(v335);
    }
    else
    {
      *v325 = Writer_TGA;
      v326 = v325 + 1;
    }
    *((_QWORD *)this + 2) = v326;
  }
  Writer_EXR = CreateWriter_EXR();
  if (Writer_EXR)
  {
    v339 = Writer_EXR;
    v340 = *((_QWORD *)this + 3);
    v341 = (uint64_t *)*((_QWORD *)this + 2);
    if ((unint64_t)v341 >= v340)
    {
      v343 = *((_QWORD *)this + 1);
      v344 = ((uint64_t)v341 - v343) >> 3;
      if ((unint64_t)(v344 + 1) >> 61)
        goto LABEL_434;
      v345 = v340 - v343;
      v346 = v345 >> 2;
      if (v345 >> 2 <= (unint64_t)(v344 + 1))
        v346 = v344 + 1;
      if ((unint64_t)v345 >= 0x7FFFFFFFFFFFFFF8)
        v347 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v347 = v346;
      if (v347)
        v348 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 24, v347);
      else
        v348 = 0;
      v349 = (uint64_t *)&v348[8 * v344];
      v350 = &v348[8 * v347];
      *v349 = v339;
      v342 = v349 + 1;
      v352 = (char *)*((_QWORD *)this + 1);
      v351 = (char *)*((_QWORD *)this + 2);
      if (v351 != v352)
      {
        do
        {
          v353 = *((_QWORD *)v351 - 1);
          v351 -= 8;
          *--v349 = v353;
        }
        while (v351 != v352);
        v351 = (char *)*((_QWORD *)this + 1);
      }
      *((_QWORD *)this + 1) = v349;
      *((_QWORD *)this + 2) = v342;
      *((_QWORD *)this + 3) = v350;
      if (v351)
        operator delete(v351);
    }
    else
    {
      *v341 = Writer_EXR;
      v342 = v341 + 1;
    }
    *((_QWORD *)this + 2) = v342;
  }
  Writer_PBM = CreateWriter_PBM();
  if (Writer_PBM)
  {
    v355 = Writer_PBM;
    v356 = *((_QWORD *)this + 3);
    v357 = (uint64_t *)*((_QWORD *)this + 2);
    if ((unint64_t)v357 >= v356)
    {
      v359 = *((_QWORD *)this + 1);
      v360 = ((uint64_t)v357 - v359) >> 3;
      if ((unint64_t)(v360 + 1) >> 61)
        goto LABEL_434;
      v361 = v356 - v359;
      v362 = v361 >> 2;
      if (v361 >> 2 <= (unint64_t)(v360 + 1))
        v362 = v360 + 1;
      if ((unint64_t)v361 >= 0x7FFFFFFFFFFFFFF8)
        v363 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v363 = v362;
      if (v363)
        v364 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 24, v363);
      else
        v364 = 0;
      v365 = (uint64_t *)&v364[8 * v360];
      v366 = &v364[8 * v363];
      *v365 = v355;
      v358 = v365 + 1;
      v368 = (char *)*((_QWORD *)this + 1);
      v367 = (char *)*((_QWORD *)this + 2);
      if (v367 != v368)
      {
        do
        {
          v369 = *((_QWORD *)v367 - 1);
          v367 -= 8;
          *--v365 = v369;
        }
        while (v367 != v368);
        v367 = (char *)*((_QWORD *)this + 1);
      }
      *((_QWORD *)this + 1) = v365;
      *((_QWORD *)this + 2) = v358;
      *((_QWORD *)this + 3) = v366;
      if (v367)
        operator delete(v367);
    }
    else
    {
      *v357 = Writer_PBM;
      v358 = v357 + 1;
    }
    *((_QWORD *)this + 2) = v358;
  }
  Writer_PVR = CreateWriter_PVR();
  if (!Writer_PVR)
    return;
  v371 = Writer_PVR;
  v372 = *((_QWORD *)this + 3);
  v373 = (uint64_t *)*((_QWORD *)this + 2);
  if ((unint64_t)v373 >= v372)
  {
    v375 = *((_QWORD *)this + 1);
    v376 = ((uint64_t)v373 - v375) >> 3;
    if (!((unint64_t)(v376 + 1) >> 61))
    {
      v377 = v372 - v375;
      v378 = v377 >> 2;
      if (v377 >> 2 <= (unint64_t)(v376 + 1))
        v378 = v376 + 1;
      if ((unint64_t)v377 >= 0x7FFFFFFFFFFFFFF8)
        v379 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v379 = v378;
      if (v379)
        v380 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)this + 24, v379);
      else
        v380 = 0;
      v381 = (uint64_t *)&v380[8 * v376];
      v382 = &v380[8 * v379];
      *v381 = v371;
      v374 = v381 + 1;
      v384 = (char *)*((_QWORD *)this + 1);
      v383 = (char *)*((_QWORD *)this + 2);
      if (v383 != v384)
      {
        do
        {
          v385 = *((_QWORD *)v383 - 1);
          v383 -= 8;
          *--v381 = v385;
        }
        while (v383 != v384);
        v383 = (char *)*((_QWORD *)this + 1);
      }
      *((_QWORD *)this + 1) = v381;
      *((_QWORD *)this + 2) = v374;
      *((_QWORD *)this + 3) = v382;
      if (v383)
        operator delete(v383);
      goto LABEL_432;
    }
LABEL_434:
    std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
  }
  *v373 = Writer_PVR;
  v374 = v373 + 1;
LABEL_432:
  *((_QWORD *)this + 2) = v374;
}

IIO_Writer *CreateWriter_ASTC(void)
{
  IIO_Writer *v0;

  v0 = (IIO_Writer *)operator new();
  IIO_Writer::IIO_Writer(v0, (const __CFString *const *)kCGImageTypeIdentifierASTC, 1095980099, 1, 704989189);
  *(_QWORD *)v0 = off_1E1BB0938;
  return v0;
}

void sub_187EA1528(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C409ED2048DLL);
  _Unwind_Resume(a1);
}

IIO_Writer *CreateWriter_TGA(void)
{
  IIO_Writer *v0;

  v0 = (IIO_Writer *)operator new();
  IIO_Writer::IIO_Writer(v0, (const __CFString *const *)kCGImageTypeIdentifierTGA, 1413955872, 1, 150996993);
  *(_QWORD *)v0 = off_1E1BAF7A8;
  return v0;
}

void sub_187EA15B0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C409ED2048DLL);
  _Unwind_Resume(a1);
}

IIO_Writer *CreateWriter_PDF(void)
{
  IIO_Writer *v0;

  v0 = (IIO_Writer *)operator new();
  IIO_Writer::IIO_Writer(v0, (const __CFString *const *)kCGImageTypeIdentifierPDF, 1346651680, -1, 2131099519);
  *(_QWORD *)v0 = off_1E1BAF758;
  return v0;
}

void sub_187EA1638(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C409ED2048DLL);
  _Unwind_Resume(a1);
}

uint64_t CreateWriter_KTX(void)
{
  uint64_t v0;

  v0 = operator new();
  IIOGeneric_Writer::IIOGeneric_Writer(v0, &CGImagePluginInfo_ktx, 1263818784);
  return v0;
}

void sub_187EA16A8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C4021BA897DLL);
  _Unwind_Resume(a1);
}

IIO_Writer *CreateWriter_HEIC_JPEG(void)
{
  IIO_Writer *v0;

  IIODetermineHEIFSupport();
  v0 = (IIO_Writer *)operator new();
  IIO_Writer::IIO_Writer(v0, (const __CFString *const *)kCGImageTypeIdentifierHEIC, 1212500291, 1, 688785413);
  *(_QWORD *)v0 = &off_1E1BB0988;
  *((_QWORD *)v0 + 2) = CFSTR("public.jpeg");
  IIO_Writer::setAddToTypeIdentifiers((uint64_t)v0, 0);
  return v0;
}

void sub_187EA1750(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C409ED2048DLL);
  _Unwind_Resume(a1);
}

uint64_t IIO_Writer::setAddToTypeIdentifiers(uint64_t this, char a2)
{
  *(_BYTE *)(this + 44) = a2;
  return this;
}

IIO_Writer *CreateWriter_AppleJPEG(void)
{
  IIO_Writer *v0;

  v0 = (IIO_Writer *)operator new();
  IIO_Writer::IIO_Writer(v0, (const __CFString *const *)kCGImageTypeIdentifierJPEG, 1246774599, 1, 554043399);
  *(_QWORD *)v0 = off_1E1BB2100;
  return v0;
}

void sub_187EA17E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C409ED2048DLL);
  _Unwind_Resume(a1);
}

void IIO_Writer::IIO_Writer(IIO_Writer *this, const __CFString *const *a2, int a3, uint64_t a4, int a5)
{
  *(_QWORD *)this = off_1E1BAB618;
  *((_QWORD *)this + 1) = a2;
  *((_DWORD *)this + 6) = a3;
  *((_QWORD *)this + 4) = a4;
  *((_DWORD *)this + 10) = a5;
  *((_BYTE *)this + 44) = 1;
  *((_QWORD *)this + 2) = 0;
}

IIO_Writer *CreateWriter_HEICS(void)
{
  IIO_Writer *v0;

  IIODetermineHEIFSupport();
  if (!gHEIF_HEVC_EncodingSupported)
    return 0;
  v0 = (IIO_Writer *)operator new();
  IIO_Writer::IIO_Writer(v0, (const __CFString *const *)kCGImageTypeIdentifierHEIC, 1212500291, -1, 688785413);
  *(_QWORD *)v0 = &off_1E1BB0988;
  *((_QWORD *)v0 + 2) = CFSTR("public.heics");
  return v0;
}

void sub_187EA18BC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C409ED2048DLL);
  _Unwind_Resume(a1);
}

uint64_t CreateReader_AVCI(void)
{
  uint64_t v0;

  IIODetermineHEIFSupport();
  if (!gHEIF_AVCI_DecodingSupported)
    return 0;
  v0 = operator new();
  IIO_Reader::IIO_Reader((IIO_Reader *)v0, (const __CFString *const *)kCGImageTypeIdentifierAVCI, ".avci.", 1096172361, 64, 0);
  *(_QWORD *)v0 = &off_1E1BB0390;
  *(_BYTE *)(v0 + 48) = *(_QWORD *)(v0 + 8) != (_QWORD)kCGImageTypeIdentifierJPEG;
  return v0;
}

void sub_187EA197C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

void IIODetermineHEIFSupport(void)
{
  IIO_LoadCMPhotoSymbols();
  if (gHEIFDecoderEncoderCheckInitOnce != -1)
    dispatch_once(&gHEIFDecoderEncoderCheckInitOnce, &__block_literal_global_39);
}

void IIO_LoadCMPhotoSymbols()
{
  if (gLoadCMPhotoSymbolsInitOnce != -1)
    dispatch_once(&gLoadCMPhotoSymbolsInitOnce, &__block_literal_global_3_0);
}

IIO_Reader *CreateReader_AI(void)
{
  IIO_Reader *v0;

  v0 = (IIO_Reader *)operator new();
  IIO_Reader::IIO_Reader(v0, (const __CFString *const *)kCGImageTypeIdentifierAI, ".ai.", 1095311392, 10, 0);
  *(_QWORD *)v0 = &off_1E1BACF28;
  IIO_Reader::setAddToTypeIdentifiers((uint64_t)v0, 0);
  return v0;
}

void sub_187EA1A78(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

IIO_Reader *CreateReader_KTX2_BC(void)
{
  IIO_Reader *v0;

  v0 = (IIO_Reader *)operator new();
  IIO_Reader::IIO_Reader(v0, (const __CFString *const *)kCGImageTypeIdentifierKTX2, ".ktx2.", 1261584963, 32, 0);
  *(_QWORD *)v0 = &off_1E1BAD048;
  IIO_Reader::setAddToTypeIdentifiers((uint64_t)v0, 0);
  return v0;
}

void sub_187EA1B10(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader::setAddToTypeIdentifiers(uint64_t this, char a2)
{
  *(_BYTE *)(this + 48) = a2;
  return this;
}

IIO_Reader *CreateReader_BMP(void)
{
  IIO_Reader *v0;

  v0 = (IIO_Reader *)operator new();
  IIO_Reader::IIO_Reader(v0, (const __CFString *const *)kCGImageTypeIdentifierBMP, ".bmp.", 1112363040, 18, 0);
  *(_QWORD *)v0 = &off_1E1BAE588;
  return v0;
}

void sub_187EA1BA4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10D1C405DC8C238);
  _Unwind_Resume(a1);
}

