uint64_t jx_codestream_source::donate_codestream_box(jx_codestream_source *this, jp2_input_box *a2)
{
  char *v3;
  uint64_t v4;
  uint64_t result;
  uint64_t v6;

  v3 = (char *)this + 544;
  v4 = *((_QWORD *)this + 69);
  if (v4 < 0)
  {
    if (!*(_QWORD *)v3)
      goto LABEL_4;
LABEL_13:
    jx_codestream_source::donate_codestream_box();
  }
  if (v4 || *((_DWORD *)this + 140))
    goto LABEL_13;
LABEL_4:
  jp2_input_box::transplant((jx_codestream_source *)((char *)this + 568), a2);
  *(_OWORD *)v3 = *((_OWORD *)this + 36);
  *((_DWORD *)v3 + 4) = *((_DWORD *)this + 148);
  if (*((_DWORD *)this + 154) != 1718903404
    || (result = jx_codestream_source::parse_fragment_list(this), (_DWORD)result))
  {
    v6 = *((_QWORD *)this + 76);
    result = !v6
          || !*(_QWORD *)(v6 + 32)
          || jp2_input_box::set_codestream_scope((jx_codestream_source *)((char *)this + 568), 0, 1);
    *((_BYTE *)this + 21) = result;
  }
  return result;
}

uint64_t jx_codestream_source::parse_fragment_list(jx_codestream_source *this)
{
  uint64_t result;
  jp2_input_box *v3;
  jx_fragment_list *v4;

  if (*((_QWORD *)this + 106))
    return 1;
  if (*((_DWORD *)this + 154) != 1718903404)
    jx_codestream_source::parse_fragment_list();
  if (*((_BYTE *)this + 150))
    return 0;
  result = jp2_input_box::is_complete((jx_codestream_source *)((char *)this + 568));
  if ((_DWORD)result)
  {
    while (1)
    {
      if (!*((_BYTE *)this + 334))
      {
        result = jp2_input_box::open((jx_codestream_source *)((char *)this + 208), (jx_codestream_source *)((char *)this + 568));
        if (!(_DWORD)result)
          break;
      }
      v3 = (jx_codestream_source *)((char *)this + 208);
      if (*((_DWORD *)this + 64) == 1718383476)
      {
        result = jp2_input_box::is_complete(v3);
        if (!(_DWORD)result)
          return result;
        v4 = (jx_fragment_list *)operator new();
        *((_QWORD *)v4 + 1) = 0;
        *((_QWORD *)v4 + 2) = 0;
        *(_QWORD *)v4 = 0;
        *((_QWORD *)this + 106) = v4;
        jx_fragment_list::init(v4, (jx_codestream_source *)((char *)this + 208));
        jp2_input_box::close((jx_codestream_source *)((char *)this + 208));
        jpx_input_box::close((jx_codestream_source *)((char *)this + 568));
        jpx_input_box::open_as((uint64_t)this + 568, *((_QWORD *)this + 106), *(_QWORD *)this + 656, *((_QWORD *)this + 1), 1785737827);
        return 1;
      }
      jp2_input_box::close(v3);
    }
  }
  return result;
}

BOOL jx_source::test_box_filter(jx_source *this, int a2)
{
  unint64_t v2;
  _DWORD *v3;
  uint64_t v5;
  unint64_t v6;
  int v7;

  if (a2 == 1634955107)
    return 1;
  v2 = *((unsigned int *)this + 569);
  if (!(_DWORD)v2)
    return 1;
  if ((int)v2 < 1)
    return 0;
  v3 = (_DWORD *)*((_QWORD *)this + 285);
  if (*v3 == a2)
    return 1;
  v5 = 1;
  do
  {
    v6 = v5;
    if (v2 == v5)
      break;
    v7 = v3[v5++];
  }
  while (v7 != a2);
  return v6 < v2;
}

uint64_t jpx_codestream_source::get_codestream_id(jpx_codestream_source *this)
{
  uint64_t v1;

  v1 = *(_QWORD *)this;
  if (!*(_QWORD *)this || !*(_BYTE *)(v1 + 20))
    jpx_codestream_source::get_codestream_id();
  return *(unsigned int *)(v1 + 16);
}

uint64_t jx_codestream_source::is_stream_ready(jx_codestream_source *this)
{
  uint64_t result;
  uint64_t v3;

  if (*((_DWORD *)this + 154) == 1718903404)
    return jx_codestream_source::parse_fragment_list(this);
  if (*((_BYTE *)this + 21))
    return 1;
  if (!*((_BYTE *)this + 694))
    return 0;
  v3 = *((_QWORD *)this + 76);
  if (v3
    && *(_QWORD *)(v3 + 32)
    && !jp2_input_box::set_codestream_scope((jx_codestream_source *)((char *)this + 568), *((int *)this + 4), 1))
  {
    return *((_BYTE *)this + 21) != 0;
  }
  result = 1;
  *((_BYTE *)this + 21) = 1;
  return result;
}

char *jpx_codestream_source::access_dimensions(jx_codestream_source **this, int a2)
{
  jx_codestream_source *v2;
  char *v3;
  kdu_compressed_source *v5;
  kdu_compressed_source *v6;
  kdu_params *v7;
  kd_codestream *v9;
  char *v10;

  v2 = *this;
  if (!*this || !*((_BYTE *)v2 + 20))
    jpx_codestream_source::access_dimensions();
  v3 = (char *)v2 + 392;
  v10 = (char *)v2 + 392;
  if (a2)
  {
    if (!*((_BYTE *)v2 + 433))
    {
      v5 = jpx_codestream_source::open_stream(this, 0);
      if (v5)
      {
        v6 = v5;
        v9 = 0;
        kdu_codestream::create(&v9, v5);
        v7 = (kdu_params *)kdu_codestream::access_siz((kdu_codestream *)&v9);
        jp2_dimensions::finalize_compatibility((uint64_t)&v10, v7);
        if (v9)
          kdu_codestream::destroy(&v9);
        (*(void (**)(kdu_compressed_source *))(*(_QWORD *)v6 + 16))(v6);
        *((_BYTE *)*this + 433) = 1;
        return v10;
      }
    }
  }
  return v3;
}

jpx_input_box *jpx_codestream_source::open_stream(jx_codestream_source **this, jpx_input_box *a2)
{
  jx_codestream_source *v3;
  jx_codestream_source *v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v9;
  uint64_t v10;
  _OWORD v11[2];
  uint64_t v12;

  v3 = *this;
  if (!v3)
    jpx_codestream_source::open_stream();
  if (!jx_codestream_source::is_stream_ready(v3))
    return 0;
  v5 = *this;
  if (a2)
    goto LABEL_8;
  if (*((_BYTE *)v5 + 22))
  {
    if (*((_BYTE *)v5 + 694))
    {
      v12 = 0;
      memset(v11, 0, sizeof(v11));
      kdu_error::kdu_error((kdu_error *)v11, "Error in Kakadu File Format Support:\n");
      kdu_error::~kdu_error((kdu_error *)v11);
    }
    a2 = (jx_codestream_source *)((char *)v5 + 568);
LABEL_8:
    v6 = *((_QWORD *)v5 + 106);
    if (v6)
    {
      (*(void (**)(jpx_input_box *, uint64_t, uint64_t, _QWORD, uint64_t))(*(_QWORD *)a2 + 112))(a2, v6, *(_QWORD *)v5 + 656, *((_QWORD *)v5 + 1), 1785737827);
    }
    else
    {
      v7 = *((_QWORD *)v5 + 1);
      v9 = *((_OWORD *)v5 + 34);
      v10 = *((_QWORD *)v5 + 70);
      (*(void (**)(jpx_input_box *, uint64_t, __int128 *))(*(_QWORD *)a2 + 72))(a2, v7, &v9);
    }
    return a2;
  }
  if (!*((_BYTE *)v5 + 694))
    jpx_codestream_source::open_stream();
  a2 = (jx_codestream_source *)((char *)v5 + 568);
  *((_BYTE *)v5 + 22) = 1;
  return a2;
}

void sub_187F86CF0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F86CFC()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t jpx_codestream_source::access_palette(jpx_codestream_source *this)
{
  uint64_t v1;

  v1 = *(_QWORD *)this;
  if (!*(_QWORD *)this || !*(_BYTE *)(v1 + 20))
    jpx_codestream_source::access_palette();
  return v1 + 440;
}

BOOL jx_layer_source::donate_jplh_box(jx_layer_source *this, jp2_input_box *a2)
{
  char *v3;
  uint64_t v4;

  v3 = (char *)this + 568;
  v4 = *((_QWORD *)this + 72);
  if (v4 < 0)
  {
    if (*(_QWORD *)v3)
      goto LABEL_9;
  }
  else if (v4 || *((_DWORD *)this + 146))
  {
LABEL_9:
    jx_layer_source::donate_jplh_box();
  }
  if (*((_BYTE *)this + 142) || *((_BYTE *)this + 510))
    goto LABEL_9;
  jp2_input_box::transplant((jx_layer_source *)((char *)this + 16), a2);
  *(_OWORD *)v3 = *(_OWORD *)((char *)this + 24);
  *((_DWORD *)v3 + 4) = *((_DWORD *)this + 10);
  return jx_layer_source::finish(this);
}

uint64_t jx_layer_source::check_stream_headers(jx_layer_source *this)
{
  uint64_t v2;
  uint64_t v3;
  jx_codestream_source *codestream;
  uint64_t result;

  if (*((_BYTE *)this + 12))
  {
    if (*((int *)this + 191) < 1)
    {
LABEL_7:
      result = 1;
      *((_BYTE *)this + 13) = 1;
      return result;
    }
    v2 = 0;
    v3 = 0;
    while (1)
    {
      codestream = (jx_codestream_source *)jx_source::get_codestream(*(jx_source **)this, *(_DWORD *)(*((_QWORD *)this + 96) + v2));
      if (!codestream)
        jx_layer_source::check_stream_headers();
      if ((jx_codestream_source::is_stream_ready(codestream) & 1) == 0)
        break;
      ++v3;
      v2 += 20;
      if (v3 >= *((int *)this + 191))
        goto LABEL_7;
    }
  }
  return 0;
}

uint64_t jpx_layer_source::get_layer_id(jpx_layer_source *this)
{
  uint64_t v1;

  v1 = *(_QWORD *)this;
  if (!*(_QWORD *)this || !*(_BYTE *)(v1 + 12))
    jpx_layer_source::get_layer_id();
  return *(unsigned int *)(v1 + 8);
}

uint64_t jpx_layer_source::access_colour(jpx_layer_source *this, int a2)
{
  uint64_t v2;
  uint64_t result;

  v2 = *(_QWORD *)this;
  if (!*(_QWORD *)this || !*(_BYTE *)(v2 + 12))
    jpx_layer_source::access_colour();
  result = v2 + 648;
  if (a2 >= 1)
  {
    do
    {
      result = *(_QWORD *)(result + 104);
      if (a2 < 2)
        break;
      --a2;
    }
    while (result);
  }
  return result;
}

uint64_t jpx_layer_source::have_stream_headers(jx_layer_source **this)
{
  jx_layer_source *v1;

  v1 = *this;
  if (!v1)
    jpx_layer_source::have_stream_headers();
  if (*((_BYTE *)v1 + 13))
    return 1;
  else
    return jx_layer_source::check_stream_headers(v1);
}

uint64_t jpx_layer_source::get_codestream_registration(uint64_t *a1, unsigned int a2, _QWORD *a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v5;
  uint64_t v6;

  v5 = *a1;
  if (!*a1 || !*(_BYTE *)(v5 + 12))
    jpx_layer_source::get_codestream_registration();
  *a5 = *(_QWORD *)(v5 + 776);
  if ((a2 & 0x80000000) != 0 || *(_DWORD *)(*a1 + 764) <= (signed int)a2)
    return 0xFFFFFFFFLL;
  v6 = 20 * a2;
  *a3 = *(_QWORD *)(*(_QWORD *)(*a1 + 768) + v6 + 4);
  *a4 = *(_QWORD *)(*(_QWORD *)(*a1 + 768) + v6 + 12);
  return *(unsigned int *)(*(_QWORD *)(*a1 + 768) + v6);
}

void jx_source::jx_source(jx_source *this, jp2_family_src *a2)
{
  unsigned int v4;
  uint64_t v5;

  jp2_input_box::jp2_input_box((jx_source *)((char *)this + 32));
  jp2_input_box::jp2_input_box((jx_source *)((char *)this + 224));
  jp2_input_box::jp2_input_box((jx_source *)((char *)this + 416));
  *((_OWORD *)this + 38) = xmmword_18820CEB0;
  *((_BYTE *)this + 624) = 1;
  *((_DWORD *)this + 157) = 0;
  *((_QWORD *)this + 80) = 0;
  *((_OWORD *)this + 41) = 0u;
  jp2_input_box::jp2_input_box((jx_source *)((char *)this + 680));
  *((_BYTE *)this + 864) = 0;
  *(_QWORD *)((char *)this + 868) = 0;
  *(_QWORD *)((char *)this + 956) = 0;
  *((_QWORD *)this + 121) = 0;
  *((_QWORD *)this + 111) = 0;
  *((_QWORD *)this + 110) = 0;
  *((_BYTE *)this + 896) = 0;
  *(_OWORD *)((char *)this + 904) = 0u;
  *(_OWORD *)((char *)this + 920) = 0u;
  *(_OWORD *)((char *)this + 936) = 0u;
  *(_DWORD *)((char *)this + 951) = 0;
  j2_colour::j2_colour((jx_source *)((char *)this + 976));
  *((_OWORD *)this + 68) = 0u;
  jx_compatibility::jx_compatibility((jx_source *)((char *)this + 1144));
  jx_composition::jx_composition((jx_source *)((char *)this + 1336));
  jx_meta_manager::jx_meta_manager((jx_source *)((char *)this + 1840));
  *(_QWORD *)this = a2;
  v4 = *((_DWORD *)a2 + 18);
  *((_DWORD *)this + 5) = 0;
  *((_DWORD *)this + 6) = 0;
  *((_BYTE *)this + 216) = 0;
  *((_BYTE *)this + 600) = 0;
  *((_BYTE *)this + 408) = 0;
  *((_BYTE *)this + 672) = 0;
  *((_WORD *)this + 8) = 0;
  *((_QWORD *)this + 1) = v4;
  *((_QWORD *)this + 142) = 0;
  *((_OWORD *)this + 70) = 0u;
  *((_OWORD *)this + 69) = 0u;
  *((_QWORD *)this + 231) = this;
  *((_QWORD *)this + 230) = a2;
  v5 = operator new();
  *(_OWORD *)(v5 + 8) = 0u;
  *(_OWORD *)(v5 + 104) = 0u;
  *(_OWORD *)(v5 + 88) = 0u;
  *(_OWORD *)(v5 + 72) = 0u;
  *(_OWORD *)(v5 + 56) = 0u;
  *(_OWORD *)(v5 + 40) = 0u;
  *(_OWORD *)(v5 + 24) = 0u;
  *(_QWORD *)v5 = (char *)this + 1840;
  *((_QWORD *)this + 233) = v5;
  *(_BYTE *)(v5 + 14) = 1;
}

void sub_187F870DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, jp2_input_box *a9, jp2_input_box *a10)
{
  jx_composition *v10;
  jx_meta_manager *v11;
  _QWORD *v12;
  jp2_input_box *v13;
  jp2_input_box *v14;
  j2_palette *v15;
  j2_channels *v16;
  j2_colour *v17;
  jx_compatibility *v18;
  uint64_t v20;
  uint64_t v21;

  jx_meta_manager::~jx_meta_manager(v11);
  jx_composition::~jx_composition(v10);
  jx_compatibility::~jx_compatibility(v18);
  j2_colour::~j2_colour(v17);
  j2_channels::~j2_channels(v16);
  v20 = v12[116];
  if (v20)
    MEMORY[0x18D761C18](v20, 0x1000C808B6DE1C6);
  j2_palette::~j2_palette(v15);
  jp2_input_box::~jp2_input_box(v14);
  j2_data_references::~j2_data_references((j2_data_references *)(v12 + 82));
  v21 = v12[80];
  if (v21)
    MEMORY[0x18D761C18](v21, 0x1000C8052888210);
  jp2_input_box::~jp2_input_box(v13);
  jp2_input_box::~jp2_input_box(a9);
  jp2_input_box::~jp2_input_box(a10);
  _Unwind_Resume(a1);
}

void sub_187F87198()
{
  JUMPOUT(0x187F87154);
}

void sub_187F871A0()
{
  JUMPOUT(0x187F87180);
}

void sub_187F871A8()
{
  JUMPOUT(0x187F87188);
}

void jx_source::~jx_source(jx_source *this)
{
  jx_codestream_source *i;
  jx_layer_source *v3;
  j2_colour *v4;
  uint64_t v5;
  uint64_t v6;

  for (i = (jx_codestream_source *)*((_QWORD *)this + 138); i; i = (jx_codestream_source *)*((_QWORD *)this + 138))
  {
    *((_QWORD *)this + 138) = *((_QWORD *)i + 107);
    jx_codestream_source::~jx_codestream_source(i);
    MEMORY[0x18D761C30]();
  }
  while (1)
  {
    v3 = (jx_layer_source *)*((_QWORD *)this + 139);
    if (!v3)
      break;
    *((_QWORD *)this + 139) = *((_QWORD *)v3 + 100);
    jx_layer_source::~jx_layer_source(v3);
    MEMORY[0x18D761C30]();
  }
  while (1)
  {
    v4 = (j2_colour *)*((_QWORD *)this + 135);
    if (!v4)
      break;
    *((_QWORD *)this + 135) = *((_QWORD *)v4 + 13);
    j2_colour::~j2_colour(v4);
    MEMORY[0x18D761C30]();
  }
  jx_meta_manager::~jx_meta_manager((jx_source *)((char *)this + 1840));
  jx_composition::~jx_composition((jx_source *)((char *)this + 1336));
  jx_compatibility::~jx_compatibility((jx_source *)((char *)this + 1144));
  j2_colour::~j2_colour((jx_source *)((char *)this + 976));
  j2_channels::~j2_channels((jx_source *)((char *)this + 936));
  v5 = *((_QWORD *)this + 116);
  if (v5)
    MEMORY[0x18D761C18](v5, 0x1000C808B6DE1C6);
  j2_palette::~j2_palette((jx_source *)((char *)this + 864));
  jp2_input_box::~jp2_input_box((jx_source *)((char *)this + 680));
  j2_data_references::~j2_data_references((jx_source *)((char *)this + 656));
  v6 = *((_QWORD *)this + 80);
  if (v6)
    MEMORY[0x18D761C18](v6, 0x1000C8052888210);
  jp2_input_box::~jp2_input_box((jx_source *)((char *)this + 416));
  jp2_input_box::~jp2_input_box((jx_source *)((char *)this + 224));
  jp2_input_box::~jp2_input_box((jx_source *)((char *)this + 32));
}

BOOL jx_source::finish_jp2_header_box(jx_source *this)
{
  _BOOL8 result;
  int v3;
  j2_colour *v4;
  j2_colour *v5;
  j2_colour *v6;
  _DWORD *exception;
  j2_palette *v8;
  j2_resolution *v9;
  _OWORD v10[2];
  uint64_t v11;

  if (*((_BYTE *)this + 600))
    return 1;
  while (!*((_BYTE *)this + 408))
  {
    if (*((_BYTE *)this + 216))
      return *((_BYTE *)this + 216) != 0;
    if ((jx_source::parse_next_top_level_box(this, 0) & 1) == 0)
    {
      if (!*((_BYTE *)this + 408))
        return *((_BYTE *)this + 216) != 0;
      break;
    }
  }
  if (!*((_BYTE *)this + 350))
  {
    exception = __cxa_allocate_exception(4uLL);
    *exception = -50;
    __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
  }
  v8 = (jx_source *)((char *)this + 864);
  v9 = (jx_source *)((char *)this + 1088);
  while (*((_BYTE *)this + 542)
       || jp2_input_box::open((jx_source *)((char *)this + 416), (jx_source *)((char *)this + 224)))
  {
    result = jp2_input_box::is_complete((jx_source *)((char *)this + 416));
    v3 = *((_DWORD *)this + 116);
    if (v3 <= 1668246641)
    {
      switch(v3)
      {
        case 1651532643:
          if (!(_DWORD)result)
            return result;
          j2_dimensions::process_bpcc_box((jx_source *)((char *)this + 608), (jx_source *)((char *)this + 416));
          *((_BYTE *)this + 648) = 1;
          break;
        case 1667523942:
          if (!(_DWORD)result)
            return result;
          j2_channels::init((jx_source *)((char *)this + 936), (jx_source *)((char *)this + 416));
          break;
        case 1668112752:
          if (!(_DWORD)result)
            return result;
          j2_component_map::init((jx_source *)((char *)this + 896), (jx_source *)((char *)this + 416));
          break;
        default:
          goto LABEL_32;
      }
    }
    else if (v3 > 1885564017)
    {
      if (v3 == 1885564018)
      {
        if (!(_DWORD)result)
          return result;
        j2_palette::init(v8, (jx_source *)((char *)this + 416));
      }
      else
      {
        if (v3 != 1919251232)
          goto LABEL_32;
        if (!(_DWORD)result)
          return result;
        j2_resolution::init(v9, (jx_source *)((char *)this + 416));
      }
    }
    else if (v3 == 1668246642)
    {
      if (!(_DWORD)result)
        return result;
      v4 = (jx_source *)((char *)this + 976);
      do
      {
        v5 = v4;
        v4 = (j2_colour *)*((_QWORD *)v4 + 13);
      }
      while (v4);
      if (*(_BYTE *)v5)
      {
        v6 = (j2_colour *)operator new();
        j2_colour::j2_colour(v6);
        *((_QWORD *)v5 + 13) = v6;
      }
      else
      {
        v6 = v5;
      }
      j2_colour::init(v6, (jx_source *)((char *)this + 416));
    }
    else if (v3 == 1768449138)
    {
      if (!(_DWORD)result)
        return result;
      j2_dimensions::init((jx_source *)((char *)this + 608), (jx_source *)((char *)this + 416));
    }
    else
    {
LABEL_32:
      if ((jp2_input_box::close((jx_source *)((char *)this + 416)) & 1) == 0)
      {
        v11 = 0;
        memset(v10, 0, sizeof(v10));
        kdu_error::kdu_error((kdu_error *)v10, "Error in Kakadu File Format Support:\n");
        (*(void (**)(_OWORD *, const char *))(*(_QWORD *)&v10[0] + 16))(v10, "sub_box.close failed - corrupt jp2 file");
        kdu_error::~kdu_error((kdu_error *)v10);
      }
    }
  }
  if (!jp2_input_box::is_complete((jx_source *)((char *)this + 224))
    && ((*((_DWORD *)this + 154) & 0x80000000) != 0
     || !*((_BYTE *)this + 648)
     || !*(_BYTE *)v8
     || *((int *)this + 231) < 1
     || !*((_DWORD *)this + 235)
     || !*((_BYTE *)this + 976)
     || *(float *)v9 <= 0.0))
  {
    return 0;
  }
  jp2_input_box::close((jx_source *)((char *)this + 224));
  j2_resolution::finalize((float *)v9);
  result = 1;
  *((_BYTE *)this + 600) = 1;
  return result;
}

void sub_187F8761C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F87628()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void jpx_source::jpx_source(jpx_source *this)
{
  *(_QWORD *)this = &off_1E1BAB908;
  *((_QWORD *)this + 1) = 0;
}

uint64_t jpx_source::open(jpx_source *this, jp2_family_src *a2, char a3)
{
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  _DWORD *v10;
  int v11;
  _DWORD *v12;
  _BYTE *v13;
  unsigned int v14;
  __int128 v15;
  int v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;

  v6 = *((_QWORD *)this + 1);
  if (!v6)
  {
    v6 = operator new();
    jx_source::jx_source((jx_source *)v6, a2);
    *((_QWORD *)this + 1) = v6;
  }
  if (*(_BYTE *)(v6 + 15))
  {
    v19 = 0;
    v17 = 0u;
    v18 = 0u;
    kdu_error::kdu_error((kdu_error *)&v17, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v17);
  }
  if (*(jp2_family_src **)v6 != a2 || *((_DWORD *)a2 + 18) != *(_DWORD *)(v6 + 8))
  {
    jx_source::~jx_source((jx_source *)v6);
    MEMORY[0x18D761C30]();
    v6 = operator new();
    jx_source::jx_source((jx_source *)v6, a2);
    *((_QWORD *)this + 1) = v6;
  }
  if (*(_BYTE *)(v6 + 12))
    goto LABEL_9;
  if (!*(_BYTE *)(v6 + 158))
  {
    v15 = xmmword_18820CDD0;
    v16 = 0;
    if (!jp2_input_box::open((jp2_input_box *)(v6 + 32), (uint64_t)a2, &v15))
      goto LABEL_16;
    v6 = *((_QWORD *)this + 1);
  }
  if (!jp2_input_box::is_complete((jp2_input_box *)(v6 + 32)))
  {
LABEL_16:
    if (!*((_QWORD *)a2 + 4))
    {
      (*(void (**)(jpx_source *))(*(_QWORD *)this + 24))(this);
      if ((a3 & 1) == 0)
      {
        v19 = 0;
        v17 = 0u;
        v18 = 0u;
        kdu_error::kdu_error((kdu_error *)&v17, "Error in Kakadu File Format Support:\n");
        kdu_error::~kdu_error((kdu_error *)&v17);
      }
      return 0xFFFFFFFFLL;
    }
    return 0;
  }
  v14 = 0;
  v8 = *((_QWORD *)this + 1);
  if (*(_DWORD *)(v8 + 80) != 1783636000
    || !jp2_input_box::read((jp2_input_box *)(v8 + 32), &v14)
    || v14 != 218793738
    || (v9 = *((_QWORD *)this + 1), *(_BYTE *)(v9 + 157))
    || *(_QWORD *)(v9 + 120) - *(_QWORD *)(v9 + 168) + *(int *)(v9 + 208))
  {
    (*(void (**)(jpx_source *))(*(_QWORD *)this + 24))(this);
    if ((a3 & 1) == 0)
    {
      v19 = 0;
      v17 = 0u;
      v18 = 0u;
      kdu_error::kdu_error((kdu_error *)&v17, "Error in Kakadu File Format Support:\n");
      kdu_error::~kdu_error((kdu_error *)&v17);
    }
    return 0xFFFFFFFFLL;
  }
  jp2_input_box::close((jp2_input_box *)(v9 + 32));
  v6 = *((_QWORD *)this + 1);
  *(_BYTE *)(v6 + 12) = 1;
LABEL_9:
  if (!*(_BYTE *)(v6 + 13))
  {
    if (!*(_BYTE *)(v6 + 158))
    {
      if (!jp2_input_box::open_next((jp2_input_box *)(v6 + 32)))
      {
LABEL_31:
        if (!*((_QWORD *)a2 + 4))
        {
          (*(void (**)(jpx_source *))(*(_QWORD *)this + 24))(this);
          if ((a3 & 1) == 0)
          {
            v19 = 0;
            v17 = 0u;
            v18 = 0u;
            kdu_error::kdu_error((kdu_error *)&v17, "Error in Kakadu File Format Support:\n");
            kdu_error::~kdu_error((kdu_error *)&v17);
          }
          return 0xFFFFFFFFLL;
        }
        return 0;
      }
      v6 = *((_QWORD *)this + 1);
    }
    if (jp2_input_box::is_complete((jp2_input_box *)(v6 + 32)))
    {
      v10 = (_DWORD *)*((_QWORD *)this + 1);
      if (v10[20] == 1718909296)
      {
        if ((jx_compatibility::init_ftyp((jx_compatibility *)(v10 + 286), (jp2_input_box *)(v10 + 8)) & 1) != 0)
        {
          v6 = *((_QWORD *)this + 1);
          if (*(_BYTE *)(v6 + 158))
            jpx_source::open();
          *(_BYTE *)(v6 + 13) = 1;
          v11 = *(unsigned __int8 *)(v6 + 1144);
          *(_BYTE *)(v6 + 16) = v11;
          if (v11)
            goto LABEL_11;
          goto LABEL_42;
        }
        (*(void (**)(jpx_source *))(*(_QWORD *)this + 24))(this);
        if ((a3 & 1) == 0)
        {
          v19 = 0;
          v17 = 0u;
          v18 = 0u;
          kdu_error::kdu_error((kdu_error *)&v17, "Error in Kakadu File Format Support:\n");
          kdu_error::~kdu_error((kdu_error *)&v17);
        }
      }
      else
      {
        (*(void (**)(jpx_source *))(*(_QWORD *)this + 24))(this);
        if ((a3 & 1) == 0)
        {
          v19 = 0;
          v17 = 0u;
          v18 = 0u;
          kdu_error::kdu_error((kdu_error *)&v17, "Error in Kakadu File Format Support:\n");
          kdu_error::~kdu_error((kdu_error *)&v17);
        }
      }
      return 0xFFFFFFFFLL;
    }
    goto LABEL_31;
  }
  if (*(_BYTE *)(v6 + 16))
  {
LABEL_11:
    result = 1;
    *(_BYTE *)(v6 + 15) = 1;
    return result;
  }
LABEL_42:
  if (*(_BYTE *)(v6 + 14))
    jpx_source::open();
  if (!*(_BYTE *)(v6 + 158))
  {
    if (!jp2_input_box::open_next((jp2_input_box *)(v6 + 32)))
    {
LABEL_48:
      if (*((_QWORD *)a2 + 4))
        return 0;
      (*(void (**)(jpx_source *))(*(_QWORD *)this + 24))(this);
      if ((a3 & 1) == 0)
      {
        v19 = 0;
        v17 = 0u;
        v18 = 0u;
        kdu_error::kdu_error((kdu_error *)&v17, "Error in Kakadu File Format Support:\n");
        kdu_error::~kdu_error((kdu_error *)&v17);
      }
      return 0xFFFFFFFFLL;
    }
    v6 = *((_QWORD *)this + 1);
  }
  if (*(_DWORD *)(v6 + 80) == 1920099697 && !jp2_input_box::is_complete((jp2_input_box *)(v6 + 32)))
    goto LABEL_48;
  v12 = (_DWORD *)*((_QWORD *)this + 1);
  if (v12[20] == 1920099697)
  {
    jx_compatibility::init_rreq((jx_compatibility *)(v12 + 286), (jp2_input_box *)(v12 + 8));
    v13 = (_BYTE *)*((_QWORD *)this + 1);
    v13[14] = 1;
    if (v13[158])
      jpx_source::open();
  }
  else
  {
    jx_source::parse_next_top_level_box((jx_source *)v12, 1);
    v13 = (_BYTE *)*((_QWORD *)this + 1);
  }
  result = 1;
  v13[15] = 1;
  return result;
}

void sub_187F87B60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_187F87B6C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  _Unwind_Exception *v15;

  _Unwind_Resume(v15);
}

BOOL jpx_source::close(jpx_source *this)
{
  jx_source *v2;
  _BOOL8 v3;

  v2 = (jx_source *)*((_QWORD *)this + 1);
  if (!v2)
    return 0;
  v3 = *((_BYTE *)v2 + 15) != 0;
  jx_source::~jx_source(v2);
  MEMORY[0x18D761C30]();
  *((_QWORD *)this + 1) = 0;
  return v3;
}

uint64_t jpx_source::count_codestreams(jpx_source *this, int *a2)
{
  uint64_t v3;
  uint64_t v5;
  int v6;

  v3 = *((_QWORD *)this + 1);
  if (v3 && (v3 = *(unsigned __int8 *)(v3 + 15), (_DWORD)v3))
  {
    while (1)
    {
      v5 = *((_QWORD *)this + 1);
      if (*(_BYTE *)(v5 + 216))
        break;
      if ((jx_source::parse_next_top_level_box((jx_source *)v5, 0) & 1) == 0)
      {
        v5 = *((_QWORD *)this + 1);
        v3 = *(_BYTE *)(v5 + 216) != 0;
        goto LABEL_8;
      }
    }
    v3 = 1;
LABEL_8:
    v6 = *(_DWORD *)(v5 + 20);
  }
  else
  {
    v6 = 0;
  }
  *a2 = v6;
  return v3;
}

uint64_t jpx_source::access_codestream(jpx_source *this, int a2, int a3)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v8;
  uint64_t v9;
  __int128 v11;
  __int128 v12;
  uint64_t v13;

  v3 = *((_QWORD *)this + 1);
  if (!v3)
    return 0;
  v4 = a2;
  v5 = 0;
  if ((a2 & 0x80000000) == 0 && *(_BYTE *)(v3 + 15))
  {
    while (1)
    {
      v8 = *((_QWORD *)this + 1);
      if (*(_DWORD *)(v8 + 20) > v4 || *(_BYTE *)(v8 + 216))
        break;
      if ((jx_source::parse_next_top_level_box((jx_source *)v8, 0) & 1) == 0)
      {
        if (!v4 && *(_BYTE *)(*((_QWORD *)this + 1) + 216))
        {
          v13 = 0;
          v11 = 0u;
          v12 = 0u;
          kdu_error::kdu_error((kdu_error *)&v11, "Error in Kakadu File Format Support:\n");
          (*(void (**)(__int128 *, const char *))(v11 + 16))(&v11, "JPX data source appears to contain no codestreams at all.");
          goto LABEL_24;
        }
        return 0;
      }
    }
    v5 = *(_QWORD *)(v8 + 1104);
    if (v4 >= 1)
    {
      do
      {
        v5 = *(_QWORD *)(v5 + 856);
        --v4;
      }
      while (v4);
    }
    if (!jx_codestream_source::finish((jx_codestream_source *)v5, 1))
    {
      if (!*(_BYTE *)(*((_QWORD *)this + 1) + 216))
        return 0;
      if (*(_BYTE *)(v5 + 20))
      {
        v9 = *(_QWORD *)(v5 + 552);
        if (v9 < 0)
        {
          if (*(_QWORD *)(v5 + 544))
            return 0;
        }
        else if (v9 || *(_DWORD *)(v5 + 560))
        {
          return 0;
        }
      }
      v13 = 0;
      v11 = 0u;
      v12 = 0u;
      kdu_error::kdu_error((kdu_error *)&v11, "Error in Kakadu File Format Support:\n");
      (*(void (**)(__int128 *, const char *))(v11 + 16))(&v11, "JPX data source appears to contain an incomplete codestream.  Specifically, this either means that an embedded contiguous or fragmented codestream has been found without sufficient descriptive metadata, or that a codestream header box has been found without any matching embedded contiguous or fragmented codestream.  Both of these conditions are illegal for JPX and JP2 data sources.");
LABEL_24:
      kdu_error::~kdu_error((kdu_error *)&v11);
    }
    if (a3 && !jx_codestream_source::is_stream_ready((jx_codestream_source *)v5))
      return 0;
  }
  return v5;
}

void sub_187F87E34(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_187F87E40()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

uint64_t jpx_source::access_meta_manager(jpx_source *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 1);
  if (v1)
    return v1 + 1840;
  else
    return 0;
}

void jpx_source::~jpx_source(jpx_source *this)
{
  *(_QWORD *)this = &off_1E1BAB908;
  jpx_source::close(this);
}

{
  *(_QWORD *)this = &off_1E1BAB908;
  jpx_source::close(this);
  JUMPOUT(0x18D761C30);
}

uint64_t jx_frame::reset(jx_frame *this)
{
  uint64_t result;

  *((_DWORD *)this + 3) = 0;
  for (result = *((_QWORD *)this + 3); ; result = *((_QWORD *)this + 3))
  {
    *((_QWORD *)this + 4) = result;
    if (!result)
      break;
    *((_QWORD *)this + 3) = *(_QWORD *)(result + 56);
    MEMORY[0x18D761C30]();
  }
  return result;
}

void jx_metaread::jx_metaread(jx_metaread *this)
{
  uint64_t v2;

  jp2_input_box::jp2_input_box(this);
  jp2_input_box::jp2_input_box((jp2_input_box *)(v2 + 184));
  *((_QWORD *)this + 46) = 0;
  *((_QWORD *)this + 47) = 0;
}

void sub_187F87F88(_Unwind_Exception *a1)
{
  jp2_input_box *v1;

  jp2_input_box::~jp2_input_box(v1);
  _Unwind_Resume(a1);
}

uint64_t jx_roigroup::jx_roigroup(uint64_t a1, uint64_t a2, int a3, int a4)
{
  int v8;
  unsigned int v9;
  int v10;

  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  jp2_output_box::jp2_output_box((jp2_output_box *)(a1 + 48));
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = a4;
  *(_DWORD *)(a1 + 20) = a3;
  v8 = 128 << a3;
  *(_DWORD *)(a1 + 40) = 128 << a3;
  *(_DWORD *)(a1 + 44) = 128 << a3;
  if (a4 >= 1)
  {
    v9 = a4 + 1;
    do
    {
      v8 *= 8;
      --v9;
    }
    while (v9 > 1);
    *(_DWORD *)(a1 + 40) = v8;
    *(_DWORD *)(a1 + 44) = v8;
  }
  v10 = 8 * v8;
  *(_DWORD *)(a1 + 32) = v10;
  *(_DWORD *)(a1 + 36) = v10;
  bzero((void *)(a1 + 128), 0x600uLL);
  return a1;
}

void jx_compatibility::jx_compatibility(jx_compatibility *this)
{
  jp2_output_box::jp2_output_box((jx_compatibility *)((char *)this + 112));
  *(_BYTE *)this = 0;
  *(_QWORD *)((char *)this + 1) = 0x101010101010101;
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  *((_QWORD *)this + 13) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
}

void jx_composition::jx_composition(jx_composition *this)
{
  jp2_output_box::jp2_output_box((jx_composition *)((char *)this + 8));
  jp2_input_box::jp2_input_box((jx_composition *)((char *)this + 88));
  jp2_input_box::jp2_input_box((jx_composition *)((char *)this + 272));
  *((_QWORD *)this + 61) = 0;
  *((_QWORD *)this + 62) = 0;
  *(_BYTE *)this = 0;
  *(_OWORD *)((char *)this + 456) = xmmword_18820EDD0;
  *((_QWORD *)this + 59) = 0;
  *((_QWORD *)this + 60) = 0;
}

void sub_187F880E0(_Unwind_Exception *a1)
{
  jp2_output_box *v1;
  jp2_input_box *v2;

  jp2_input_box::~jp2_input_box(v2);
  jp2_output_box::~jp2_output_box(v1);
  _Unwind_Resume(a1);
}

void jx_composition::~jx_composition(jx_composition *this)
{
  jx_frame *v2;

  v2 = (jx_frame *)*((_QWORD *)this + 59);
  for (*((_QWORD *)this + 60) = v2; v2; *((_QWORD *)this + 60) = v2)
  {
    *((_QWORD *)this + 59) = *((_QWORD *)v2 + 6);
    jx_frame::reset(v2);
    MEMORY[0x18D761C30](v2, 0x1020C406ACA6742);
    v2 = (jx_frame *)*((_QWORD *)this + 59);
  }
  jp2_input_box::~jp2_input_box((jx_composition *)((char *)this + 272));
  jp2_input_box::~jp2_input_box((jx_composition *)((char *)this + 88));
  jp2_output_box::~jp2_output_box((jx_composition *)((char *)this + 8));
}

void jx_compatibility::~jx_compatibility(jx_compatibility *this)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *((_QWORD *)this + 3);
  if (v2)
    MEMORY[0x18D761C18](v2, 0x1000C807733839DLL);
  v3 = *((_QWORD *)this + 13);
  if (v3)
    MEMORY[0x18D761C18](v3, 0x1000C80D990E388);
  jp2_output_box::~jp2_output_box((jx_compatibility *)((char *)this + 112));
}

void j2_data_references::~j2_data_references(j2_data_references *this)
{
  int v2;
  uint64_t v3;
  uint64_t v4;

  if (*((_QWORD *)this + 1))
  {
    v2 = *(_DWORD *)this;
    if (*(int *)this < 1)
      goto LABEL_8;
    v3 = 0;
    do
    {
      v4 = *(_QWORD *)(*((_QWORD *)this + 1) + 8 * v3);
      if (v4)
      {
        MEMORY[0x18D761C18](v4, 0x1000C8077774924);
        v2 = *(_DWORD *)this;
      }
      ++v3;
    }
    while (v3 < v2);
    if (*((_QWORD *)this + 1))
LABEL_8:
      MEMORY[0x18D761C18]();
  }
}

void jx_codestream_source::~jx_codestream_source(jx_codestream_source *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *((_QWORD *)this + 106);
  if (v2)
  {
    v3 = *(_QWORD *)(v2 + 8);
    if (v3)
      MEMORY[0x18D761C18](v3, 0x1000C800CE834B2);
    MEMORY[0x18D761C30](v2, 0x1020C40FBFA920DLL);
  }
  jpx_input_box::~jpx_input_box((jx_codestream_source *)((char *)this + 568));
  v4 = *((_QWORD *)this + 63);
  if (v4)
    MEMORY[0x18D761C18](v4, 0x1000C808B6DE1C6);
  j2_palette::~j2_palette((jx_codestream_source *)((char *)this + 440));
  v5 = *((_QWORD *)this + 53);
  if (v5)
    MEMORY[0x18D761C18](v5, 0x1000C8052888210);
  jp2_input_box::~jp2_input_box((jx_codestream_source *)((char *)this + 208));
  jp2_input_box::~jp2_input_box((jx_codestream_source *)((char *)this + 24));
}

void jx_layer_source::~jx_layer_source(jx_layer_source *this)
{
  j2_colour *i;
  uint64_t v3;

  for (i = (j2_colour *)*((_QWORD *)this + 94); i; i = (j2_colour *)*((_QWORD *)this + 94))
  {
    *((_QWORD *)this + 94) = *((_QWORD *)i + 13);
    j2_colour::~j2_colour(i);
    MEMORY[0x18D761C30]();
  }
  v3 = *((_QWORD *)this + 96);
  if (v3)
    MEMORY[0x18D761C18](v3, 0x1000C80A86A77D5);
  j2_colour::~j2_colour((jx_layer_source *)((char *)this + 648));
  j2_channels::~j2_channels((jx_layer_source *)((char *)this + 608));
  jp2_input_box::~jp2_input_box((jx_layer_source *)((char *)this + 384));
  jp2_input_box::~jp2_input_box((jx_layer_source *)((char *)this + 200));
  jp2_input_box::~jp2_input_box((jx_layer_source *)((char *)this + 16));
}

void jx_layer_source::jx_layer_source(jx_layer_source *this, jx_source *a2, int a3)
{
  jp2_input_box::jp2_input_box((jx_layer_source *)((char *)this + 16));
  jp2_input_box::jp2_input_box((jx_layer_source *)((char *)this + 200));
  jp2_input_box::jp2_input_box((jx_layer_source *)((char *)this + 384));
  *((_QWORD *)this + 71) = 0;
  *((_QWORD *)this + 72) = -1;
  *((_DWORD *)this + 146) = 0;
  *(_QWORD *)((char *)this + 628) = 0;
  *((_QWORD *)this + 80) = 0;
  *((_OWORD *)this + 37) = 0u;
  *((_OWORD *)this + 38) = 0u;
  *(_DWORD *)((char *)this + 623) = 0;
  j2_colour::j2_colour((jx_layer_source *)((char *)this + 648));
  *(_OWORD *)((char *)this + 760) = 0u;
  *(_OWORD *)((char *)this + 776) = 0u;
  *(_QWORD *)this = a2;
  *((_DWORD *)this + 2) = a3;
  *((_WORD *)this + 6) = 0;
  *(_OWORD *)((char *)this + 792) = 0u;
}

void sub_187F88460(_Unwind_Exception *a1)
{
  jp2_input_box *v1;
  jp2_input_box *v2;
  jp2_input_box *v3;
  j2_channels *v4;

  j2_channels::~j2_channels(v4);
  jp2_input_box::~jp2_input_box(v3);
  jp2_input_box::~jp2_input_box(v2);
  jp2_input_box::~jp2_input_box(v1);
  _Unwind_Resume(a1);
}

void jx_codestream_source::jx_codestream_source(jx_codestream_source *this, jx_source *a2, jp2_family_src *a3, int a4, char a5)
{
  uint64_t v10;

  jp2_input_box::jp2_input_box((jx_codestream_source *)((char *)this + 24));
  jp2_input_box::jp2_input_box((jx_codestream_source *)((char *)this + 208));
  *(_OWORD *)((char *)this + 392) = xmmword_18820CEB0;
  *((_BYTE *)this + 408) = 1;
  *((_DWORD *)this + 103) = 0;
  *((_QWORD *)this + 53) = 0;
  *((_BYTE *)this + 440) = 0;
  *(_QWORD *)((char *)this + 444) = 0;
  *((_QWORD *)this + 57) = 0;
  *((_QWORD *)this + 58) = 0;
  *((_BYTE *)this + 472) = 0;
  *((_OWORD *)this + 30) = 0u;
  *((_OWORD *)this + 31) = 0u;
  *((_QWORD *)this + 64) = 0;
  *((_QWORD *)this + 65) = -1;
  *((_DWORD *)this + 132) = 0;
  *((_OWORD *)this + 34) = xmmword_18820CDD0;
  *((_DWORD *)this + 140) = 0;
  jp2_input_box::jp2_input_box((jx_codestream_source *)((char *)this + 568));
  *((_QWORD *)this + 71) = &off_1E1BADE00;
  *((_OWORD *)this + 47) = 0u;
  *((_DWORD *)this + 202) = -1;
  *((_DWORD *)this + 192) = -1;
  *((_QWORD *)this + 105) = 0;
  *(_OWORD *)(v10 + 208) = 0u;
  *(_OWORD *)(v10 + 224) = 0u;
  *((_OWORD *)this + 51) = 0u;
  *((_DWORD *)this + 208) = 0;
  *(_QWORD *)this = a2;
  *((_QWORD *)this + 1) = a3;
  *((_DWORD *)this + 4) = a4;
  *((_BYTE *)this + 23) = a5;
  *((_WORD *)this + 216) = 0;
  *((_WORD *)this + 10) = 0;
  *((_BYTE *)this + 22) = 0;
  *((_QWORD *)this + 67) = 0;
  *((_OWORD *)this + 53) = 0u;
}

void sub_187F885BC(_Unwind_Exception *a1)
{
  jp2_input_box *v1;
  uint64_t v2;
  jp2_input_box *v3;
  _QWORD *v4;
  j2_palette *v5;
  uint64_t v7;

  v7 = *(_QWORD *)(v2 + 504);
  if (v7)
    MEMORY[0x18D761C18](v7, 0x1000C808B6DE1C6);
  jx_codestream_source::jx_codestream_source(v5, v4, v3);
  jp2_input_box::~jp2_input_box(v1);
  _Unwind_Resume(a1);
}

BOOL _cg_jpeg_calc_output_dimensions(uint64_t a1)
{
  int v2;
  void (**v3)(_QWORD);
  int v4;
  int v5;
  _DWORD *v6;
  int v7;
  _DWORD *v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  _BOOL8 result;
  int v19;

  v2 = *(_DWORD *)(a1 + 36);
  if (v2 != 202)
  {
    v3 = *(void (***)(_QWORD))a1;
    *((_DWORD *)v3 + 10) = 21;
    *((_DWORD *)v3 + 12) = v2;
    (**(void (***)(uint64_t))a1)(a1);
  }
  jpeg_core_output_dimensions(a1);
  v4 = *(_DWORD *)(a1 + 56);
  if (v4 >= 1)
  {
    v5 = 0;
    v6 = *(_DWORD **)(a1 + 304);
    do
    {
      v7 = *(_DWORD *)(a1 + 424);
      if (*(_DWORD *)(a1 + 92))
      {
        v6[9] = v7;
        v8 = v6 + 9;
        v9 = *(_DWORD *)(a1 + 428);
      }
      else
      {
        if (*(_DWORD *)(a1 + 100))
          v10 = 8;
        else
          v10 = 4;
        if (v7 <= v10)
        {
          v11 = 1;
          do
          {
            v12 = 2 * v11;
            if (*(_DWORD *)(a1 + 416) % (2 * v11 * v6[2]))
              break;
            v11 *= 2;
          }
          while (v7 * v12 <= v10);
        }
        else
        {
          v11 = 1;
        }
        v7 *= v11;
        v6[9] = v7;
        v8 = v6 + 9;
        v9 = *(_DWORD *)(a1 + 428);
        if (v9 <= v10)
        {
          v13 = 1;
          while (1)
          {
            v15 = 2 * v13;
            if (*(_DWORD *)(a1 + 420) % (2 * v13 * v6[3]))
              goto LABEL_17;
            v13 *= 2;
            if (v9 * v15 > v10)
            {
              v13 = v15;
              goto LABEL_17;
            }
          }
        }
      }
      v13 = 1;
LABEL_17:
      v14 = v9 * v13;
      v6[10] = v9 * v13;
      if (v7 <= 2 * v9 * v13)
      {
        if (v14 > 2 * v7)
          v6[10] = 2 * v7;
      }
      else
      {
        v7 = 2 * v14;
        *v8 = 2 * v14;
      }
      v6[11] = jdiv_round_up((int)v6[2] * (uint64_t)v7 * *(unsigned int *)(a1 + 48), *(int *)(a1 + 556) * (uint64_t)*(int *)(a1 + 416));
      v6[12] = jdiv_round_up((int)v6[10] * (uint64_t)(int)v6[3] * *(unsigned int *)(a1 + 52), *(int *)(a1 + 556) * (uint64_t)*(int *)(a1 + 420));
      ++v5;
      v6 += 24;
      v4 = *(_DWORD *)(a1 + 56);
    }
    while (v5 < v4);
  }
  v16 = *(_DWORD *)(a1 + 64) - 1;
  if (v16 <= 6)
    v4 = dword_18820EE30[v16];
  if (*(_DWORD *)(a1 + 108))
    v17 = 1;
  else
    v17 = v4;
  *(_DWORD *)(a1 + 144) = v4;
  *(_DWORD *)(a1 + 148) = v17;
  result = use_merged_upsample(a1);
  if (result)
    v19 = *(_DWORD *)(a1 + 420);
  else
    v19 = 1;
  *(_DWORD *)(a1 + 152) = v19;
  return result;
}

BOOL use_merged_upsample(uint64_t a1)
{
  _DWORD *v2;
  int v3;
  int v4;

  if (!*(_DWORD *)(a1 + 400)
    && (*(_DWORD *)(a1 + 60) | 4) == 7
    && *(_DWORD *)(a1 + 56) == 3
    && *(_DWORD *)(a1 + 64) == 2
    && *(_DWORD *)(a1 + 144) == 3
    && !*(_DWORD *)(a1 + 396)
    && (v2 = *(_DWORD **)(a1 + 304), v2[2] == 2)
    && v2[26] == 1
    && v2[50] == 1
    && (int)v2[3] <= 2
    && v2[27] == 1
    && v2[51] == 1
    && (v3 = v2[9], v3 == *(_DWORD *)(a1 + 424))
    && v2[33] == v3
    && v2[57] == v3
    && (v4 = v2[10], v4 == *(_DWORD *)(a1 + 428))
    && v2[34] == v4)
  {
    return v2[58] == v4;
  }
  else
  {
    return 0;
  }
}

uint64_t _cg_jinit_master_decompress(uint64_t a1)
{
  uint64_t v2;
  int v3;
  void (**v4)(uint64_t);
  _OWORD *v5;
  uint64_t v6;
  int8x16_t v7;
  int8x16_t v8;
  __int128 v9;
  unsigned int v10;
  int v11;
  void (**v12)(uint64_t);
  void (**v13)(uint64_t);
  _BOOL4 v14;
  void (**v15)(uint64_t);
  _BOOL4 v16;
  uint64_t result;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;

  v2 = (**(uint64_t (***)(void))(a1 + 8))();
  *(_QWORD *)(a1 + 576) = v2;
  *(_QWORD *)v2 = prepare_for_output_pass;
  *(_QWORD *)(v2 + 8) = finish_output_pass;
  *(_DWORD *)(v2 + 16) = 0;
  v3 = *(_DWORD *)(a1 + 296);
  if (v3 != 8)
  {
    v4 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v4 + 10) = 16;
    *((_DWORD *)v4 + 12) = v3;
    (**(void (***)(uint64_t))a1)(a1);
  }
  _cg_jpeg_calc_output_dimensions(a1);
  v5 = (_OWORD *)(**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 1280);
  v6 = 0;
  *v5 = 0u;
  v5[1] = 0u;
  v5[2] = 0u;
  v5[3] = 0u;
  v5[4] = 0u;
  v5[5] = 0u;
  v5[6] = 0u;
  v5[7] = 0u;
  v5[8] = 0u;
  v5[9] = 0u;
  v5[10] = 0u;
  v5[11] = 0u;
  v5[12] = 0u;
  v5[13] = 0u;
  v5[14] = 0u;
  v5[15] = 0u;
  v5[16] = 0u;
  v5[17] = 0u;
  v5[18] = 0u;
  v5[19] = 0u;
  v5[20] = 0u;
  v5[21] = 0u;
  v5[22] = 0u;
  v5[23] = 0u;
  v5[24] = 0u;
  v5[25] = 0u;
  v5[26] = 0u;
  v5[27] = 0u;
  v5[28] = 0u;
  v5[29] = 0u;
  v5[30] = 0u;
  v5[31] = 0u;
  v7 = (int8x16_t)xmmword_18820EE20;
  v8.i64[0] = 0x1010101010101010;
  v8.i64[1] = 0x1010101010101010;
  *(_QWORD *)(a1 + 440) = v5 + 32;
  do
  {
    v5[v6 + 32] = v7;
    ++v6;
    v7 = vaddq_s8(v7, v8);
  }
  while (v6 != 16);
  *(_QWORD *)&v9 = -1;
  *((_QWORD *)&v9 + 1) = -1;
  v5[79] = v9;
  v5[78] = v9;
  v5[77] = v9;
  v5[76] = v9;
  v5[75] = v9;
  v5[74] = v9;
  v5[73] = v9;
  v5[72] = v9;
  v5[71] = v9;
  v5[70] = v9;
  v5[69] = v9;
  v5[68] = v9;
  v5[67] = v9;
  v5[66] = v9;
  v5[65] = v9;
  v5[63] = v9;
  v5[64] = v9;
  v5[61] = v9;
  v5[62] = v9;
  v5[59] = v9;
  v5[60] = v9;
  v5[57] = v9;
  v5[58] = v9;
  v5[55] = v9;
  v5[56] = v9;
  v5[53] = v9;
  v5[54] = v9;
  v5[51] = v9;
  v5[52] = v9;
  v5[49] = v9;
  v5[50] = v9;
  v5[48] = v9;
  if (!*(_DWORD *)(a1 + 140) || (v10 = *(_DWORD *)(a1 + 136)) == 0 || (v11 = *(_DWORD *)(a1 + 144), v11 <= 0))
  {
    v12 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v12 + 10) = 33;
    (*v12)(a1);
    v10 = *(_DWORD *)(a1 + 136);
    v11 = *(_DWORD *)(a1 + 144);
  }
  if (((unint64_t)v10 * v11) >> 32)
  {
    v13 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v13 + 10) = 72;
    (*v13)(a1);
  }
  *(_DWORD *)(v2 + 24) = 0;
  v14 = use_merged_upsample(a1);
  *(_QWORD *)(v2 + 32) = 0;
  *(_DWORD *)(v2 + 28) = v14;
  *(_QWORD *)(v2 + 40) = 0;
  if (*(_DWORD *)(a1 + 108))
  {
    if (!*(_DWORD *)(a1 + 88))
    {
      *(_QWORD *)(a1 + 128) = 0;
      *(_DWORD *)(a1 + 124) = 0;
    }
    if (*(_DWORD *)(a1 + 92))
    {
      v15 = *(void (***)(uint64_t))a1;
      *((_DWORD *)v15 + 10) = 48;
      (*v15)(a1);
    }
    if (*(_DWORD *)(a1 + 144) == 3)
    {
      if (*(_QWORD *)(a1 + 160))
      {
        *(_DWORD *)(a1 + 128) = 1;
      }
      else if (*(_DWORD *)(a1 + 116))
      {
        *(_DWORD *)(a1 + 132) = 1;
      }
      else
      {
        *(_DWORD *)(a1 + 124) = 1;
      }
    }
    else
    {
      *(_QWORD *)(a1 + 124) = 1;
      *(_DWORD *)(a1 + 132) = 0;
      *(_QWORD *)(a1 + 160) = 0;
    }
    if (*(_DWORD *)(a1 + 124))
    {
      _cg_jinit_1pass_quantizer(a1);
      *(_QWORD *)(v2 + 32) = *(_QWORD *)(a1 + 656);
    }
    if (*(_DWORD *)(a1 + 132) || *(_DWORD *)(a1 + 128))
    {
      _cg_jinit_2pass_quantizer(a1);
      *(_QWORD *)(v2 + 40) = *(_QWORD *)(a1 + 656);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 128) = 0;
    *(_DWORD *)(a1 + 124) = 0;
  }
  if (!*(_DWORD *)(a1 + 92))
  {
    if (*(_DWORD *)(v2 + 28))
    {
      _cg_jinit_merged_upsampler(a1);
    }
    else
    {
      _cg_jinit_color_deconverter(a1);
      _cg_jinit_upsampler((uint64_t *)a1);
    }
    _cg_jinit_d_post_controller(a1, *(_DWORD *)(a1 + 132));
  }
  _cg_jinit_inverse_dct(a1);
  if (*(_DWORD *)(a1 + 320))
    jinit_arith_decoder(a1);
  else
    _cg_jinit_huff_decoder(a1);
  if (*(_DWORD *)(*(_QWORD *)(a1 + 608) + 32))
    v16 = 1;
  else
    v16 = *(_DWORD *)(a1 + 88) != 0;
  _cg_jinit_d_coef_controller(a1, v16);
  if (!*(_DWORD *)(a1 + 92))
    _cg_jinit_d_main_controller((uint64_t *)a1, 0);
  (*(void (**)(uint64_t))(*(_QWORD *)(a1 + 8) + 48))(a1);
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 608) + 16))(a1);
  v18 = *(_QWORD *)(a1 + 16);
  if (v18 && !*(_DWORD *)(a1 + 88) && *(_DWORD *)(*(_QWORD *)(a1 + 608) + 32))
  {
    if (*(_DWORD *)(a1 + 316))
      v19 = 3 * *(_DWORD *)(a1 + 56) + 2;
    else
      v19 = *(_DWORD *)(a1 + 56);
    v20 = *(unsigned int *)(a1 + 432);
    *(_QWORD *)(v18 + 8) = 0;
    *(_QWORD *)(v18 + 16) = v19 * v20;
    if (*(_DWORD *)(a1 + 132))
      v21 = 3;
    else
      v21 = 2;
    *(_DWORD *)(v18 + 24) = 0;
    *(_DWORD *)(v18 + 28) = v21;
    ++*(_DWORD *)(v2 + 24);
  }
  return result;
}

uint64_t prepare_for_output_pass(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t result;
  uint64_t v5;
  int v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;

  v2 = a1[72];
  if (*(_DWORD *)(v2 + 16))
  {
    *(_DWORD *)(v2 + 16) = 0;
    (*(void (**)(uint64_t *, _QWORD))a1[82])(a1, 0);
    v3 = 2;
    (*(void (**)(uint64_t *, uint64_t))a1[75])(a1, 2);
LABEL_3:
    result = (*(uint64_t (**)(uint64_t *, uint64_t))a1[73])(a1, v3);
    goto LABEL_7;
  }
  if (*((_DWORD *)a1 + 27) && !a1[20])
  {
    if (*((_DWORD *)a1 + 29) && *((_DWORD *)a1 + 33))
    {
      a1[82] = *(_QWORD *)(v2 + 40);
      *(_DWORD *)(v2 + 16) = 1;
    }
    else if (*((_DWORD *)a1 + 31))
    {
      a1[82] = *(_QWORD *)(v2 + 32);
    }
    else
    {
      v11 = *a1;
      *(_DWORD *)(v11 + 40) = 47;
      (*(void (**)(uint64_t *))v11)(a1);
    }
  }
  (*(void (**)(uint64_t *))a1[79])(a1);
  result = (*(uint64_t (**)(uint64_t *))(a1[74] + 16))(a1);
  if (!*((_DWORD *)a1 + 23))
  {
    if (!*(_DWORD *)(v2 + 28))
      (*(void (**)(uint64_t *))a1[81])(a1);
    (*(void (**)(uint64_t *))a1[80])(a1);
    if (*((_DWORD *)a1 + 27))
      (*(void (**)(uint64_t *, _QWORD))a1[82])(a1, *(unsigned int *)(v2 + 16));
    if (*(_DWORD *)(v2 + 16))
      v10 = 3;
    else
      v10 = 0;
    (*(void (**)(uint64_t *, uint64_t))a1[75])(a1, v10);
    v3 = 0;
    goto LABEL_3;
  }
LABEL_7:
  v5 = a1[2];
  if (v5)
  {
    v6 = *(_DWORD *)(v2 + 24);
    v7 = *(_DWORD *)(v2 + 16) ? 2 : 1;
    v8 = v7 + v6;
    *(_DWORD *)(v5 + 24) = v6;
    *(_DWORD *)(v5 + 28) = v8;
    if (*((_DWORD *)a1 + 22))
    {
      if (!*(_DWORD *)(a1[76] + 36))
      {
        if (*((_DWORD *)a1 + 33))
          v9 = 2;
        else
          v9 = 1;
        *(_DWORD *)(v5 + 28) = v9 + v8;
      }
    }
  }
  return result;
}

uint64_t finish_output_pass(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 576);
  if (*(_DWORD *)(result + 108))
    result = (*(uint64_t (**)(void))(*(_QWORD *)(result + 656) + 16))();
  ++*(_DWORD *)(v1 + 24);
  return result;
}

uint64_t _cg_jpeg_std_error(uint64_t result)
{
  *(_QWORD *)result = error_exit;
  *(_QWORD *)(result + 8) = emit_message;
  *(_QWORD *)(result + 16) = output_message;
  *(_QWORD *)(result + 24) = format_message;
  *(_QWORD *)(result + 32) = reset_error_mgr;
  *(_DWORD *)(result + 128) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(_QWORD *)(result + 136) = 0;
  *(_QWORD *)(result + 144) = _cg_jpeg_std_message_table;
  *(_DWORD *)(result + 152) = 126;
  *(_QWORD *)(result + 160) = 0;
  *(_QWORD *)(result + 168) = 0;
  return result;
}

void error_exit(uint64_t a1)
{
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  _cg_jpeg_destroy(a1);
  exit(1);
}

uint64_t *emit_message(uint64_t *result, int a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *result;
  if (a2 < 0)
  {
    v3 = *(_QWORD *)(v2 + 136);
    if (!v3 || *(int *)(v2 + 128) >= 3)
    {
      result = (uint64_t *)(*(uint64_t (**)(void))(v2 + 16))();
      v3 = *(_QWORD *)(v2 + 136);
    }
    *(_QWORD *)(v2 + 136) = v3 + 1;
  }
  else if (*(_DWORD *)(v2 + 128) >= a2)
  {
    return (uint64_t *)(*(uint64_t (**)(void))(v2 + 16))();
  }
  return result;
}

uint64_t output_message(uint64_t a1)
{
  _OWORD v2[12];
  uint64_t v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v3 = 0;
  memset(v2, 0, sizeof(v2));
  (*(void (**)(uint64_t, _OWORD *))(*(_QWORD *)a1 + 24))(a1, v2);
  return fprintf((FILE *)*MEMORY[0x1E0C80C10], "%s\n", (const char *)v2);
}

uint64_t format_message(uint64_t *a1, char *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  BOOL v6;
  int v7;
  const char **v8;
  const char *v9;
  const char *v10;
  int v11;
  int v12;

  v2 = *a1;
  v3 = *(unsigned int *)(*a1 + 40);
  if ((int)v3 >= 1 && (int)v3 <= *(_DWORD *)(v2 + 152))
  {
    v8 = (const char **)(*(_QWORD *)(v2 + 144) + 8 * v3);
  }
  else
  {
    v4 = *(_QWORD *)(v2 + 160);
    if (!v4)
      goto LABEL_9;
    v5 = *(_DWORD *)(v2 + 168);
    v6 = __OFSUB__((_DWORD)v3, v5);
    v7 = v3 - v5;
    if (v7 < 0 != v6 || (int)v3 > *(_DWORD *)(v2 + 172))
      goto LABEL_9;
    v8 = (const char **)(v4 + 8 * v7);
  }
  v9 = *v8;
  if (!v9)
  {
LABEL_9:
    *(_DWORD *)(v2 + 48) = v3;
    v9 = **(const char ***)(v2 + 144);
  }
  v10 = v9;
  while (1)
  {
    v12 = *(unsigned __int8 *)v10++;
    v11 = v12;
    if (!v12)
      break;
    if (v11 == 37)
    {
      if (*v10 == 115)
        return sprintf(a2, v9, v2 + 48);
      return sprintf(a2, v9, *(unsigned int *)(v2 + 48), *(unsigned int *)(v2 + 52), *(unsigned int *)(v2 + 56), *(unsigned int *)(v2 + 60), *(unsigned int *)(v2 + 64), *(unsigned int *)(v2 + 68), *(unsigned int *)(v2 + 72), *(unsigned int *)(v2 + 76));
    }
  }
  return sprintf(a2, v9, *(unsigned int *)(v2 + 48), *(unsigned int *)(v2 + 52), *(unsigned int *)(v2 + 56), *(unsigned int *)(v2 + 60), *(unsigned int *)(v2 + 64), *(unsigned int *)(v2 + 68), *(unsigned int *)(v2 + 72), *(unsigned int *)(v2 + 76));
}

uint64_t *reset_error_mgr(uint64_t *result)
{
  uint64_t v1;

  v1 = *result;
  *(_QWORD *)(v1 + 136) = 0;
  *(_DWORD *)(v1 + 40) = 0;
  return result;
}

uint64_t _cg_jinit_downsampler(uint64_t *a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  _BYTE *v21;
  uint64_t v22;

  result = (*(uint64_t (**)(void))a1[1])();
  v3 = result;
  a1[68] = result;
  *(_QWORD *)result = start_pass_downsample;
  *(_QWORD *)(result + 8) = sep_downsample;
  *(_DWORD *)(result + 16) = 0;
  if (*((_DWORD *)a1 + 75))
  {
    v4 = *a1;
    *(_DWORD *)(v4 + 40) = 26;
    result = (*(uint64_t (**)(uint64_t *))v4)(a1);
  }
  if (*((int *)a1 + 23) >= 1)
  {
    v5 = 0;
    v6 = v3 + 154;
    v7 = (_DWORD *)(a1[13] + 40);
    v8 = 1;
    while (1)
    {
      v9 = *(v7 - 1) * *(v7 - 8);
      v10 = *((_DWORD *)a1 + 90);
      v11 = *v7 * *(v7 - 7) / *((_DWORD *)a1 + 91);
      v12 = *((_DWORD *)a1 + 88);
      v13 = *((_DWORD *)a1 + 89);
      *(_DWORD *)(v6 + 4 * v5 - 50) = v11;
      v14 = v9 / v10;
      if (v12 == v14 && v13 == v11)
      {
        v15 = v6 + 8 * v5;
        if (*((_DWORD *)a1 + 77))
        {
          *(_QWORD *)(v15 - 130) = fullsize_smooth_downsample;
LABEL_22:
          *(_DWORD *)(v3 + 16) = 1;
          goto LABEL_23;
        }
        *(_QWORD *)(v15 - 130) = fullsize_downsample;
      }
      else
      {
        if (v12 != 2 * v14 || v13 != v11)
        {
          if (v12 != 2 * v14 || v13 != 2 * v11)
          {
            v17 = v12 / v14;
            if (v12 % v14 || (v18 = v13 / v11, v13 % v11))
            {
              v19 = *a1;
              *(_DWORD *)(v19 + 40) = 39;
              result = (*(uint64_t (**)(uint64_t *))v19)(a1);
            }
            else
            {
              v8 = 0;
              *(_QWORD *)(v6 + 8 * v5 - 130) = int_downsample;
              v21 = (_BYTE *)(v6 + v5);
              *(v21 - 10) = v17;
              *v21 = v18;
            }
            goto LABEL_23;
          }
          v20 = v6 + 8 * v5;
          if (!*((_DWORD *)a1 + 77))
          {
            *(_QWORD *)(v20 - 130) = h2v2_downsample;
            goto LABEL_23;
          }
          *(_QWORD *)(v20 - 130) = h2v2_smooth_downsample;
          goto LABEL_22;
        }
        v8 = 0;
        *(_QWORD *)(v6 + 8 * v5 - 130) = h2v1_downsample;
      }
LABEL_23:
      v7 += 24;
      if (++v5 >= *((int *)a1 + 23))
      {
        if (*((_DWORD *)a1 + 77))
        {
          if (!v8)
          {
            v22 = *a1;
            *(_DWORD *)(v22 + 40) = 101;
            return (*(uint64_t (**)(uint64_t *, _QWORD))(v22 + 8))(a1, 0);
          }
        }
        return result;
      }
    }
  }
  return result;
}

uint64_t sep_downsample(uint64_t result, uint64_t a2, unsigned int a3, uint64_t a4, int a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  if (*(int *)(result + 92) >= 1)
  {
    v8 = result;
    v9 = 0;
    v10 = *(_QWORD *)(result + 104);
    v11 = a3;
    v12 = *(_QWORD *)(result + 544) + 104;
    do
    {
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v12 + 8 * v9 - 80))(v8, v10, *(_QWORD *)(a2 + 8 * v9) + 8 * v11, *(_QWORD *)(a4 + 8 * v9) + 8 * (*(_DWORD *)(v12 + 4 * v9) * a5));
      ++v9;
      v10 += 96;
    }
    while (v9 < *(int *)(v8 + 92));
  }
  return result;
}

unsigned __int8 *fullsize_smooth_downsample(unsigned __int8 *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned __int8 *v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  _BYTE *v18;
  _QWORD *v19;
  unsigned __int8 *v20;
  int v21;
  int v22;
  unsigned __int8 *v23;
  int v24;
  _BYTE *v25;
  uint64_t v26;
  unsigned __int8 *v27;
  int v28;

  v6 = result;
  v7 = *(_DWORD *)(a2 + 36) * *(_DWORD *)(a2 + 28);
  v8 = *((_DWORD *)result + 89);
  v9 = *((unsigned int *)result + 12);
  if (v8 >= -1 && v7 - (int)v9 >= 1)
  {
    v11 = (uint64_t *)(a3 - 8);
    v12 = (v8 + 2);
    do
    {
      v13 = *v11++;
      result = (unsigned __int8 *)memset((void *)(v13 + v9), *(unsigned __int8 *)(v13 + v9 - 1), (v7 + ~(_DWORD)v9) + 1);
      --v12;
    }
    while (v12);
    v8 = *((_DWORD *)v6 + 89);
  }
  if (v8 >= 1)
  {
    v14 = 0;
    v15 = *((_DWORD *)v6 + 77);
    v16 = 0x10000 - (v15 << 9);
    v17 = v15 << 6;
    do
    {
      v18 = *(_BYTE **)(a4 + 8 * v14);
      v19 = (_QWORD *)(a3 + 8 * v14);
      result = (unsigned __int8 *)*(v19 - 1);
      ++v14;
      v20 = *(unsigned __int8 **)(a3 + 8 * v14);
      v21 = *(unsigned __int8 *)*v19;
      v22 = *v20 + *result + v21;
      v23 = (unsigned __int8 *)(*v19 + 1);
      v24 = v20[1] + result[1] + *v23;
      *v18 = ((v24 - v21 + 2 * v22) * v17 + v16 * v21 + 0x8000) >> 16;
      v25 = v18 + 1;
      if (v7 != 2)
      {
        v26 = 0;
        v27 = v20 + 2;
        result += 2;
        do
        {
          v28 = v24;
          v24 = v27[v26] + result[v26] + v23[v26 + 1];
          v25[v26] = ((v22 + v28 - v23[v26] + v24) * v17 + v16 * v23[v26] + 0x8000) >> 16;
          ++v26;
          v22 = v28;
        }
        while (v7 - 2 != (_DWORD)v26);
        v25 += v26;
        v23 += v26;
        v22 = v28;
      }
      *v25 = ((v22 + 2 * v24 - *v23) * v17 + v16 * *v23 + 0x8000) >> 16;
    }
    while (v14 < *((int *)v6 + 89));
  }
  return result;
}

void *fullsize_downsample(uint64_t a1, uint64_t a2, char *a3, uint64_t a4)
{
  uint64_t *v4;
  void *result;
  uint64_t v8;
  uint64_t v9;
  int v10;
  size_t v12;
  uint64_t v13;

  v4 = (uint64_t *)a4;
  result = _cg_jcopy_sample_rows(a3, 0, a4, 0, *(_DWORD *)(a1 + 356), *(unsigned int *)(a1 + 48));
  v8 = *(unsigned int *)(a1 + 356);
  v9 = *(unsigned int *)(a1 + 48);
  v10 = *(_DWORD *)(a2 + 36) * *(_DWORD *)(a2 + 28);
  if ((int)v8 >= 1 && v10 - (int)v9 >= 1)
  {
    v12 = (v10 + ~(_DWORD)v9) + 1;
    do
    {
      v13 = *v4++;
      result = memset((void *)(v13 + v9), *(unsigned __int8 *)(v13 + v9 - 1), v12);
      --v8;
    }
    while (v8);
  }
  return result;
}

unsigned int *h2v1_downsample(unsigned int *result, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  unsigned int *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  unsigned __int8 *v15;
  _BYTE *v16;
  int v17;

  v6 = result;
  v7 = *(_DWORD *)(a2 + 36) * *(_DWORD *)(a2 + 28);
  v8 = result[89];
  v9 = result[12];
  if ((int)v8 >= 1 && 2 * v7 - (int)v9 >= 1)
  {
    v11 = a3;
    do
    {
      v12 = *v11++;
      result = (unsigned int *)memset((void *)(v12 + v9), *(unsigned __int8 *)(v12 + v9 - 1), (2 * v7 + ~(_DWORD)v9) + 1);
      --v8;
    }
    while (v8);
    LODWORD(v8) = v6[89];
  }
  if ((int)v8 >= 1)
  {
    v13 = 0;
    do
    {
      if (v7)
      {
        v14 = 0;
        v15 = (unsigned __int8 *)a3[v13];
        v16 = *(_BYTE **)(a4 + 8 * v13);
        v17 = v7;
        do
        {
          *v16++ = (v14 + *v15 + v15[1]) >> 1;
          v14 ^= 1u;
          v15 += 2;
          --v17;
        }
        while (v17);
        LODWORD(v8) = v6[89];
      }
      ++v13;
    }
    while (v13 < (int)v8);
  }
  return result;
}

unsigned int *h2v2_smooth_downsample(unsigned int *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int *v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  int v18;
  _BYTE *v19;
  unsigned __int8 *v20;
  unsigned __int8 *v21;
  unsigned __int8 *v22;
  unsigned __int8 *v23;
  int v24;
  int v25;
  int v26;
  int v27;
  unsigned __int8 *v28;
  unsigned __int8 *v29;
  int v30;
  unsigned __int8 *v31;
  unsigned __int8 *v32;
  _BYTE *v33;
  uint64_t v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;

  v6 = result;
  v7 = *(_DWORD *)(a2 + 36) * *(_DWORD *)(a2 + 28);
  v8 = result[89];
  v9 = result[12];
  if (v8 >= -1 && 2 * v7 - (int)v9 >= 1)
  {
    v11 = (uint64_t *)(a3 - 8);
    v12 = (v8 + 2);
    do
    {
      v13 = *v11++;
      result = (unsigned int *)memset((void *)(v13 + v9), *(unsigned __int8 *)(v13 + v9 - 1), (2 * v7 + ~(_DWORD)v9) + 1);
      --v12;
    }
    while (v12);
    v8 = v6[89];
  }
  if (v8 >= 1)
  {
    v14 = 0;
    v15 = 0;
    v16 = v6[77];
    v17 = -80 * v16 + 0x4000;
    v18 = 16 * v16;
    do
    {
      v19 = *(_BYTE **)(a4 + 8 * v15);
      v21 = *(unsigned __int8 **)(a3 + 8 * v14 - 8);
      v20 = *(unsigned __int8 **)(a3 + 8 * v14);
      v22 = *(unsigned __int8 **)(a3 + ((8 * v14) | 8));
      v14 += 2;
      v23 = *(unsigned __int8 **)(a3 + 8 * v14);
      v24 = *v22 + *v20;
      v25 = v24 + v20[1] + v22[1];
      v26 = *v21;
      v27 = *v23;
      v28 = v20 + 2;
      v29 = v22 + 2;
      v30 = v24 + v26 + v21[1] + v27 + v23[1] + v20[2] + v22[2];
      v31 = v21 + 2;
      v32 = v23 + 2;
      *v19 = ((v27 + v26 + v21[2] + v23[2] + 2 * v30) * v18 + v25 * v17 + 0x8000) >> 16;
      v33 = v19 + 1;
      if (v7 != 2)
      {
        v34 = 2;
        v35 = v7 - 2;
        do
        {
          *v33++ = ((v21[v34 + 2]
                   + v21[v34 - 1]
                   + v23[v34 - 1]
                   + 2
                   * (v21[v34 + 1]
                    + v21[v34]
                    + v23[v34]
                    + v23[v34 + 1]
                    + v20[v34 - 1]
                    + v20[v34 + 2]
                    + v22[v34 - 1]
                    + v22[v34 + 2])
                   + v23[v34 + 2])
                  * v18
                  + (v20[v34 + 1] + v20[v34] + v22[v34] + v22[v34 + 1]) * v17
                  + 0x8000) >> 16;
          v34 += 2;
          --v35;
        }
        while (v35);
        v32 = &v23[v34];
        v31 = &v21[v34];
        v29 = &v22[v34];
        v28 = &v20[v34];
      }
      v36 = v29[1] + v28[1];
      v37 = v36 + *v28 + *v29;
      v38 = v31[1];
      v39 = v32[1];
      v40 = v36 + *v31 + v38 + *v32 + v39 + *(v28 - 1) + *(v29 - 1);
      result = (unsigned int *)*(v32 - 1);
      *v33 = ((v39 + v38 + *(v31 - 1) + result + 2 * v40) * v18 + v37 * v17 + 0x8000) >> 16;
      ++v15;
    }
    while (v14 < (int)v6[89]);
  }
  return result;
}

unsigned int *h2v2_downsample(unsigned int *result, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  unsigned int *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned __int8 *v15;
  unsigned __int8 *v16;
  _BYTE *v17;
  int v18;
  int v19;

  v6 = result;
  v7 = *(_DWORD *)(a2 + 36) * *(_DWORD *)(a2 + 28);
  v8 = result[89];
  v9 = result[12];
  if ((int)v8 >= 1 && 2 * v7 - (int)v9 >= 1)
  {
    v11 = a3;
    do
    {
      v12 = *v11++;
      result = (unsigned int *)memset((void *)(v12 + v9), *(unsigned __int8 *)(v12 + v9 - 1), (2 * v7 + ~(_DWORD)v9) + 1);
      --v8;
    }
    while (v8);
    LODWORD(v8) = v6[89];
  }
  if ((int)v8 >= 1)
  {
    v13 = 0;
    v14 = 0;
    do
    {
      if (v7)
      {
        v15 = *(unsigned __int8 **)((char *)a3 + ((8 * v13) | 8));
        v16 = (unsigned __int8 *)a3[v13];
        v17 = *(_BYTE **)(a4 + 8 * v14);
        v18 = 1;
        v19 = v7;
        do
        {
          result = (unsigned int *)v15[1];
          *v17++ = (v18 + *v16 + v16[1] + *v15 + result) >> 2;
          v18 ^= 3u;
          v16 += 2;
          v15 += 2;
          --v19;
        }
        while (v19);
        LODWORD(v8) = v6[89];
      }
      v13 += 2;
      ++v14;
    }
    while (v13 < (int)v8);
  }
  return result;
}

unsigned __int8 *int_downsample(unsigned __int8 *result, int *a2, uint64_t *a3, uint64_t a4)
{
  unsigned __int8 *v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  int v19;
  _BYTE *v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  unsigned int v24;

  v6 = result;
  v7 = a2[9] * a2[7];
  v8 = *((_QWORD *)result + 68) + a2[1];
  v9 = *(unsigned __int8 *)(v8 + 144);
  v10 = *(unsigned __int8 *)(v8 + 154);
  v11 = *((unsigned int *)result + 89);
  v12 = *((unsigned int *)result + 12);
  if ((int)v11 >= 1 && v7 * v9 - (int)v12 >= 1)
  {
    v14 = a3;
    do
    {
      v15 = *v14++;
      result = (unsigned __int8 *)memset((void *)(v15 + v12), *(unsigned __int8 *)(v15 + v12 - 1), (v7 * v9 + ~(_DWORD)v12) + 1);
      --v11;
    }
    while (v11);
    LODWORD(v11) = *((_DWORD *)v6 + 89);
  }
  if ((int)v11 >= 1)
  {
    v16 = 0;
    v17 = 0;
    do
    {
      if (v7)
      {
        v18 = 0;
        v19 = 0;
        v20 = *(_BYTE **)(a4 + 8 * v17);
        do
        {
          if ((_DWORD)v10)
          {
            v21 = 0;
            v22 = 0;
            do
            {
              if (v9)
              {
                result = (unsigned __int8 *)(a3[v21 + v16] + v18);
                v23 = v9;
                do
                {
                  v24 = *result++;
                  v22 += v24;
                  --v23;
                }
                while (v23);
              }
              ++v21;
            }
            while (v21 != v10);
          }
          else
          {
            v22 = 0;
          }
          *v20++ = (v22 + ((v10 * v9) >> 1)) / (v10 * v9);
          ++v19;
          v18 += v9;
        }
        while (v19 != v7);
        LODWORD(v11) = *((_DWORD *)v6 + 89);
      }
      v16 += v10;
      ++v17;
    }
    while (v16 < (int)v11);
  }
  return result;
}

uint64_t Ktx2LoadLevelFace(int a1, int a2, int a3, int a4, int a5, size_t a6, void *__src, char *a8)
{
  uint64_t result;
  void *v11;
  size_t v12;

  if (!a8)
    return 0;
  result = 0;
  if (!a2 && *(_DWORD *)a8 == a1)
  {
    v11 = *(void **)(a8 + 4);
    if (v11)
    {
      if (*(_QWORD *)(a8 + 12) >= a6)
        v12 = a6;
      else
        v12 = *(_QWORD *)(a8 + 12);
      memcpy(v11, __src, v12);
      result = 0;
      *(_QWORD *)(a8 + 20) = v12;
    }
    else
    {
      return 13;
    }
  }
  return result;
}

BOOL GetKtx2FormatInfo(int a1, _QWORD *a2)
{
  unint64_t v2;
  _BOOL8 result;
  unint64_t v4;
  int *v5;
  int v6;

  if (s_kFormatInfo[0] == a1)
  {
    v2 = 0;
    result = 1;
LABEL_7:
    *a2 = &s_kFormatInfo[8 * v2 + 1];
  }
  else
  {
    v4 = -1;
    v5 = &dword_1EDF012B0;
    while (v4 != 155)
    {
      v6 = *v5;
      v5 += 8;
      ++v4;
      if (v6 == a1)
      {
        result = v4 < 0x9C;
        v2 = v4 + 1;
        goto LABEL_7;
      }
    }
    return 0;
  }
  return result;
}

BOOL IsASTC(int a1)
{
  return (a1 - 157) < 0x1C || (a1 - 1000066000) < 0xE;
}

BOOL IsBCn(int a1)
{
  return (a1 - 131) < 0x10;
}

BOOL IsETC(int a1)
{
  return (a1 - 147) < 0xA;
}

BOOL IsPVRTC1(int a1)
{
  return (a1 & 0xFFFFFFFA) == 1000054000;
}

uint64_t Ktx2GetDataSize(int a1, int a2, int a3)
{
  uint64_t v3;
  int *v4;
  int v5;
  int *v6;
  unint64_t v7;
  _BOOL4 v8;
  unint64_t v9;

  if (s_kFormatInfo[0] == a1)
  {
    v3 = 0;
LABEL_6:
    v6 = &s_kFormatInfo[8 * v3];
    v7 = (a2 + v6[3] - 1) / v6[3] * (unint64_t)((a3 + v6[4] - 1) / v6[4]);
    v8 = (v7 & 0xFFFFFFFF00000000) != 0;
    v9 = v7 * (unint64_t)v6[5];
    if ((v7 & 0xFFFFFFFF00000000) == 0)
      LODWORD(v7) = v9;
    if ((v9 & 0xFFFFFFFF00000000) != 0 || v8)
      return 0;
    else
      return v7;
  }
  else
  {
    v3 = 0;
    v4 = &dword_1EDF012B0;
    while (v3 != 156)
    {
      v5 = *v4;
      v4 += 8;
      ++v3;
      if (v5 == a1)
        goto LABEL_6;
    }
    return 0;
  }
}

uint64_t CreateKTXTexture(IIOImageReadSession *this)
{
  int v1;
  uint64_t v3;
  _OWORD v4[6];
  uint64_t v5;

  v5 = 0;
  memset(v4, 0, sizeof(v4));
  v3 = 0;
  if (!CreateKtxStream((uint64_t)v4, this))
  {
    v1 = ktxTexture2_CreateFromStream((uint64_t (**)(_QWORD, _OWORD *, uint64_t))v4, 0, &v3);
    if (v1)
      _cg_jpeg_mem_term("CreateKTXTexture", 576, "*** ERROR: ktxTexture2_CreateFromStream failed to create ktxTexture2 [%d]\n", v1);
  }
  return v3;
}

uint64_t IIO_Reader_ICO::createReadPlugin(IIO_Reader *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;

  v4 = operator new();
  v5 = IIO_Reader::osType(a1);
  ICOReadPlugin::ICOReadPlugin(v4, a2, v5);
  return v4;
}

void sub_187F89F18(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40F34BEBE8);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_ICO::createReadPlugin(IIO_Reader *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8;
  int v9;

  v8 = operator new();
  v9 = IIO_Reader::osType(a1);
  ICOReadPlugin::ICOReadPlugin(v8, a2, a3, a4, v9);
  return v8;
}

void sub_187F89FB4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40F34BEBE8);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_ICO::getImageCount(IIO_Reader_ICO *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  uint64_t BytesAtOffset;
  uint64_t result;
  int v8;
  __int16 v9;

  if (a5)
    *a5 = 0;
  v9 = 0;
  v8 = 0;
  BytesAtOffset = IIOImageReadSession::getBytesAtOffset(a2, &v8, 0, 6uLL);
  if (BytesAtOffset == 6)
    result = 0;
  else
    result = 4294967246;
  if (a5)
  {
    if (BytesAtOffset == 6)
    {
      result = 0;
      *a5 = v9;
    }
  }
  return result;
}

uint64_t IIO_Reader_ICO::hasCustomImageCountProc(IIO_Reader_ICO *this)
{
  return 1;
}

uint64_t IIO_Reader_CUR::createReadPlugin(IIO_Reader *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;

  v4 = operator new();
  v5 = IIO_Reader::osType(a1);
  ICOReadPlugin::ICOReadPlugin(v4, a2, v5);
  return v4;
}

void sub_187F8A0B4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40F34BEBE8);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_CUR::createReadPlugin(IIO_Reader *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8;
  int v9;

  v8 = operator new();
  v9 = IIO_Reader::osType(a1);
  ICOReadPlugin::ICOReadPlugin(v8, a2, a3, a4, v9);
  return v8;
}

void sub_187F8A150(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40F34BEBE8);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_CUR::getImageCount(IIO_Reader_CUR *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  IIO_ReaderHandler *ReaderHandler;
  IIO_Reader *v10;

  ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(this);
  v10 = IIO_ReaderHandler::readerForType(ReaderHandler, 1229147936);
  return (*(uint64_t (**)(IIO_Reader *, IIOImageReadSession *, IIODictionary *, CGImageSourceStatus *, unsigned int *))(*(_QWORD *)v10 + 32))(v10, a2, a3, a4, a5);
}

uint64_t IIO_Reader_CUR::hasCustomImageCountProc(IIO_Reader_CUR *this)
{
  return 1;
}

uint64_t IIO_Reader_LibJPEG::createReadPlugin(IIO_Reader *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;

  v4 = operator new();
  v5 = IIO_Reader::osType(a1);
  LibJPEGReadPlugin::LibJPEGReadPlugin(v4, a2, v5);
  return v4;
}

void sub_187F8A238(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10F1C40CB8B3A6CLL);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_LibJPEG::createReadPlugin(IIO_Reader *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8;
  int v9;

  v8 = operator new();
  v9 = IIO_Reader::osType(a1);
  LibJPEGReadPlugin::LibJPEGReadPlugin(v8, a2, a3, a4, 0, 0, 1246774599, 0, v9);
  return v8;
}

void sub_187F8A2F0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10F1C40CB8B3A6CLL);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_LibJPEG::initImageAtOffset(IIO_Reader *a1, uint64_t a2, int a3, int a4)
{
  IIOReadPlugin *v8;
  int v9;

  v8 = (IIOReadPlugin *)operator new();
  v9 = IIO_Reader::osType(a1);
  LibJPEGReadPlugin::LibJPEGReadPlugin((uint64_t)v8, a2, a3, 0, 0, 0, 1246774599, 0, v9);
  IIOReadPlugin::setDestMaxPixelSize((uint64_t)v8, a4);
  return IIOReadPlugin::callInitialize(v8);
}

void sub_187F8A3B8(void *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10F1C40CB8B3A6CLL);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187F8A3A0);
}

uint64_t IIO_Reader_LibJPEG::initThumbnail(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  IIOImagePlus *Source;
  IIODictionary *Properties;
  uint64_t Session;
  IIOImageReadSession *v9;
  IIOImageRead *Size;
  unint64_t v11;
  IIOImageRead *v12;
  IIOImageRead *v13;
  unint64_t BytesAtOffset;
  unsigned __int8 *v15;
  uint64_t result;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unsigned __int8 *v22;
  int v23;
  unint64_t v24;
  unsigned int v25;
  unsigned __int8 *v26;
  unsigned __int16 *v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  __int16 v35;
  unsigned int v37;
  unsigned int v38;
  int v39;
  unsigned int v40;
  unsigned int v41;
  unint64_t v42;
  int64_t v43;
  int v44;
  unsigned int v45;
  unsigned int v46;
  uint64_t v48;
  unint64_t v49;
  unsigned __int8 *v50;
  unsigned __int8 *v51;
  unsigned int v52;
  unsigned int v53;
  unsigned int *v54;
  unsigned int v55;
  unsigned int v56;
  unsigned int *v57;
  unsigned int v58;
  __int16 v59;
  unsigned int v60;
  unsigned int v61;
  unsigned int v62;
  unsigned int v63;
  int v64;
  unsigned __int8 *v65;
  unsigned int v66;
  _BYTE v67[24];
  _BYTE v68[24];
  void *v69;

  Source = (IIOImagePlus *)CGImageSourceGetSource(a2);
  Properties = (IIODictionary *)IIOImagePlus::getProperties(Source);
  Session = CGImagePluginGetSession(a2);
  v9 = (IIOImageReadSession *)CGImageSourceGetSource(Session);
  Size = IIOImageReadSession::getSize(v9);
  if (!Session)
    return 4294967245;
  v11 = (unint64_t)Size;
  v69 = 0;
  v12 = IIOImageReadSession::retainBytePointer(v9, (const __CFData **)&v69, 0);
  v13 = v12;
  if (v12)
  {
    BytesAtOffset = v11;
    v15 = (unsigned __int8 *)v12;
  }
  else
  {
    v15 = (unsigned __int8 *)malloc_type_malloc(0x1000uLL, 0x84351B20uLL);
    BytesAtOffset = IIOImageReadSession::getBytesAtOffset(v9, v15, 0, 0x1000uLL);
  }
  if (BytesAtOffset < 0x1000 || *v15 != 255 || v15[1] != 216)
    goto LABEL_18;
  if (v11 - 10 <= 2)
  {
    _cg_jpeg_mem_term("initThumbnail", 133, "*** ERROR: bad APP marker offset (%ld)\n");
  }
  else
  {
    if (v15[2] == 255 && v15[3] == 224)
      v17 = __rev16(*((unsigned __int16 *)v15 + 2)) + 4;
    else
      v17 = 2;
    if (v17 < v11 - 10)
    {
      if (v15[v17] != 255 || v15[v17 + 1] != 225 || strncmp((const char *)&v15[v17 + 4], "Exif", 4uLL))
        goto LABEL_18;
      v21 = (unint64_t)&v15[BytesAtOffset];
      v22 = &v15[v17 + 10];
      v23 = *v22;
      if (v23 == 77)
      {
        if (v22[1] != 77 || v22[2])
          goto LABEL_77;
        v19 = 0;
        if (v22[3] != 42)
          goto LABEL_47;
      }
      else
      {
        if (v23 != 73 || v22[1] != 73 || v22[2] != 42)
          goto LABEL_77;
        v19 = 0;
        if (v22[3])
        {
LABEL_47:
          v20 = 0;
LABEL_78:
          v18 = v17 + 10;
          goto LABEL_20;
        }
      }
      if ((unint64_t)(v22 + 8) > v21)
        goto LABEL_47;
      v19 = 0;
      LODWORD(v24) = *((_DWORD *)v22 + 1);
      v25 = bswap32(v24);
      v24 = v23 == 77 ? v25 : v24;
      if (v24 < 8 || (unint64_t)__rev16(*(unsigned __int16 *)&v15[v17 + 2]) - 4 < v24)
        goto LABEL_47;
      v26 = &v22[v24];
      v27 = (unsigned __int16 *)(v26 + 2);
      if ((unint64_t)(v26 + 2) <= v21)
      {
        v28 = *(unsigned __int16 *)v26;
        v29 = bswap32(v28) >> 16;
        if (v23 == 77)
          v30 = v29;
        else
          v30 = v28;
        if ((BytesAtOffset - v17 - v24 - 12) / 0xC <= (unsigned __int16)v30)
          goto LABEL_77;
        if ((_WORD)v30)
        {
          v65 = &v15[BytesAtOffset];
          v64 = v23;
          do
          {
            if ((unint64_t)(v27 + 1) <= v21)
            {
              v31 = *v27;
              v32 = bswap32(v31) >> 16;
              if (v23 == 77)
                LOWORD(v31) = v32;
            }
            else
            {
              LOWORD(v31) = 0;
            }
            if ((unint64_t)(v27 + 2) <= v21)
            {
              v33 = bswap32(v27[1]) >> 16;
              if (v23 != 77)
                LOWORD(v33) = v27[1];
            }
            else
            {
              LOWORD(v33) = 0;
            }
            if ((unint64_t)(v27 + 4) <= v21)
            {
              v34 = *((_DWORD *)v27 + 1);
              v35 = bswap32(v34);
              if (v23 == 77)
                LOWORD(v34) = v35;
              if ((unsigned __int16)v31 == 274
                && (unsigned __int16)v33 == 3
                && (unsigned __int16)v34 == 1
                && (unint64_t)(v27 + 5) <= v21)
              {
                v37 = v27[4];
                v38 = bswap32(v37) >> 16;
                if (v23 == 77)
                  LOWORD(v37) = v38;
                if ((unsigned __int16)(v37 - 1) <= 7u)
                {
                  v66 = v30;
                  v39 = (unsigned __int16)v37;
                  IIONumber::IIONumber((IIONumber *)v68, (unsigned __int16)v37);
                  IIODictionary::setObjectForKey((uint64_t)Properties, (uint64_t)v68, CFSTR("Orientation"));
                  IIONumber::~IIONumber((IIONumber *)v68);
                  IIONumber::IIONumber((IIONumber *)v67, v39);
                  IIODictionary::setObjectForKeyGroup(Properties, (uint64_t)v67, CFSTR("Orientation"), CFSTR("{TIFF}"));
                  IIONumber::~IIONumber((IIONumber *)v67);
                  v23 = v64;
                  v21 = (unint64_t)v65;
                  v30 = v66;
                }
              }
            }
            --v30;
            v27 += 6;
          }
          while ((_WORD)v30);
        }
      }
      else if (BytesAtOffset - v17 - v24 - 12 < 0xC)
      {
LABEL_77:
        v19 = 0;
        v20 = 0;
        goto LABEL_78;
      }
      if ((unint64_t)(v27 + 2) <= v21)
      {
        v40 = *(_DWORD *)v27;
        v41 = bswap32(*(_DWORD *)v27);
        if (v23 == 77)
          v40 = v41;
        v18 = v17 + 10;
        if (!v40)
          goto LABEL_19;
        v42 = v17 + 10 + v40;
        if (v69)
        {
          if (v11 <= v42 + 2)
            goto LABEL_19;
          v15 = (unsigned __int8 *)v13 + v42;
          v43 = v11 - v42;
        }
        else
        {
          v44 = v23;
          v43 = IIOImageReadSession::getBytesAtOffset(v9, v15, v42, 0x1000uLL);
          if ((unint64_t)v43 < 2)
            goto LABEL_19;
          v23 = v44;
        }
        if (v43 >= 2)
        {
          v45 = *(unsigned __int16 *)v15;
          v46 = bswap32(v45) >> 16;
          if (v23 == 77)
            v45 = v46;
          if ((v43 - 2) / 0xCuLL > (unsigned __int16)v45 && (unsigned __int16)v45 != 0)
          {
            v48 = 0;
            v20 = 0;
            v19 = 0;
            v49 = (unint64_t)&v15[v43];
            do
            {
              v50 = &v15[v48];
              v51 = &v15[v48 + 4];
              if ((unint64_t)v51 <= v49)
              {
                v52 = *((unsigned __int16 *)v50 + 1);
                v53 = bswap32(v52) >> 16;
                if (v23 == 77)
                  LOWORD(v52) = v53;
              }
              else
              {
                LOWORD(v52) = 0;
              }
              v54 = (unsigned int *)(v50 + 6);
              if ((unint64_t)(v50 + 6) <= v49)
              {
                v56 = *(unsigned __int16 *)v51;
                v55 = bswap32(v56) >> 16;
                if (v23 != 77)
                  LOWORD(v55) = v56;
              }
              else
              {
                LOWORD(v55) = 0;
              }
              v57 = (unsigned int *)&v15[v48 + 10];
              if ((unint64_t)v57 <= v49)
              {
                v58 = *v54;
                v59 = bswap32(v58);
                if (v23 != 77)
                  v59 = v58;
                if ((unsigned __int16)v52 == 513 && (unsigned __int16)v55 == 4 && v59 == 1)
                {
                  if ((unint64_t)&v15[v48 + 14] <= v49)
                  {
                    v60 = *v57;
                    v62 = bswap32(v60);
                    if (v23 == 77)
                      v60 = v62;
                  }
                  else
                  {
                    v60 = 0;
                  }
                  v19 = v60;
                }
                else if ((unsigned __int16)v52 == 514 && (unsigned __int16)v55 == 4 && v59 == 1)
                {
                  if ((unint64_t)&v15[v48 + 14] <= v49)
                  {
                    v61 = *v57;
                    v63 = bswap32(v61);
                    if (v23 == 77)
                      v61 = v63;
                  }
                  else
                  {
                    v61 = 0;
                  }
                  v20 = v61;
                }
              }
              --v45;
              v48 += 12;
            }
            while ((_WORD)v45);
            goto LABEL_20;
          }
        }
        goto LABEL_19;
      }
      goto LABEL_77;
    }
    _cg_jpeg_mem_term("initThumbnail", 140, "*** ERROR: bad APP marker offset (%ld)\n");
  }
LABEL_18:
  v18 = 0;
LABEL_19:
  v19 = 0;
  v20 = 0;
LABEL_20:
  if (v69)
    IIOImageReadSession::releaseBytePointer((IIOImageRead **)v9, v69);
  else
    free(v15);
  result = 4294967246;
  if (v19 && v20)
  {
    if (CGImagePluginInitThumbJPEGAtOffset(a2, (IIOImageReadSession *)(v19 + v18), v20, a4))
      return 0;
    else
      return 4294967245;
  }
  return result;
}

void sub_187F8AA40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_LibJPEG::compareOptions(IIO_Reader_LibJPEG *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  unsigned int Uint32ForKey;
  unsigned int v5;
  int v6;
  int v7;
  _BOOL4 v8;
  const __CFDictionary *ObjectForKey;
  const __CFDictionary *v10;
  int v11;
  _BOOL4 v12;
  uint64_t v13;
  _BOOL4 BoolForKey;
  _QWORD v16[3];
  _QWORD v17[3];

  memset(v17, 0, sizeof(v17));
  IIODictionary::IIODictionary((IIODictionary *)v17, a2);
  memset(v16, 0, sizeof(v16));
  IIODictionary::IIODictionary((IIODictionary *)v16, a3);
  Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v17, CFSTR("kCGImageSourceSubsampleFactor"));
  v5 = IIODictionary::getUint32ForKey((IIODictionary *)v16, CFSTR("kCGImageSourceSubsampleFactor"));
  if (Uint32ForKey <= 1)
    v6 = 1;
  else
    v6 = Uint32ForKey;
  if (v5 <= 1)
    v7 = 1;
  else
    v7 = v5;
  if (v6 == v7
    && (v8 = IIODictionary::getBoolForKey((IIODictionary *)v17, CFSTR("kCGImageSourceUseCoreImage")),
        v8 == IIODictionary::getBoolForKey((IIODictionary *)v16, CFSTR("kCGImageSourceUseCoreImage")))
    && (ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v17, CFSTR("kCGImageSourceXMPSidecar")),
        v10 = IIODictionary::getObjectForKey((IIODictionary *)v16, CFSTR("kCGImageSourceXMPSidecar")),
        (ObjectForKey != 0) == (v10 != 0))
    && (!ObjectForKey || !v10 || CFEqual(ObjectForKey, v10))
    && (v11 = IIOSkipMetadata((IIODictionary *)v17), (v11 ^ 1 | IIOSkipMetadata((IIODictionary *)v16)) == 1)
    && (v12 = IIODictionary::getBoolForKey((IIODictionary *)v17, CFSTR("kCGImageSourceAddJPEGQualityInformation")),
        v12 == IIODictionary::getBoolForKey((IIODictionary *)v16, CFSTR("kCGImageSourceAddJPEGQualityInformation"))))
  {
    BoolForKey = IIODictionary::getBoolForKey((IIODictionary *)v17, CFSTR("kCGImageSourceAddThumbnailInformation"));
    v13 = BoolForKey ^ IIODictionary::getBoolForKey((IIODictionary *)v16, CFSTR("kCGImageSourceAddThumbnailInformation")) ^ 1u;
  }
  else
  {
    v13 = 0;
  }
  IIODictionary::~IIODictionary((IIODictionary *)v16);
  IIODictionary::~IIODictionary((IIODictionary *)v17);
  return v13;
}

void sub_187F8AC10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  IIODictionary::~IIODictionary((IIODictionary *)&a9);
  IIODictionary::~IIODictionary((IIODictionary *)&a12);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_LibJPEG::hasCustomCompareOptionsProc(IIO_Reader_LibJPEG *this)
{
  return 1;
}

uint64_t IIO_Reader_LibJPEG::hasCustomThumbnailProc(IIO_Reader_LibJPEG *this)
{
  return 1;
}

void IIOLogTypeMismatch(const void *a1, const char *a2, const char *a3)
{
  CFTypeID v5;
  CFStringRef v6;
  CFStringRef v7;
  const char *v8;
  _QWORD v9[3];

  if (a1)
  {
    v5 = CFGetTypeID(a1);
    v6 = CFCopyTypeIDDescription(v5);
    if (v6)
    {
      v7 = v6;
      memset(v9, 0, sizeof(v9));
      IIOString::IIOString((IIOString *)v9, v6);
      v8 = (const char *)IIOString::utf8String((IIOString *)v9);
      LogError("IIOLogTypeMismatch", 30, "*** ERROR: %s() - bad parameter: expected '%s' -- got '%s'\n", a2, a3, v8);
      CFRelease(v7);
      IIOString::~IIOString((IIOString *)v9);
    }
  }
}

void sub_187F8ACE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t IIONumber::uint8Num(CFNumberRef *this)
{
  unsigned __int8 valuePtr;

  valuePtr = 0;
  if (CFNumberGetValue(this[2], kCFNumberSInt8Type, &valuePtr))
    return valuePtr;
  LogError("uint8Num", 286, "CFNumberGetValue/uint8Num failed\n");
  return 0;
}

uint64_t IIONumber::uint16Num(IIONumber *this)
{
  const __CFNumber *v2;
  int v3;
  CFTypeID v4;
  CFStringRef v5;
  const char *v6;
  double v8[3];
  uint64_t v9;
  int v10;
  __int16 valuePtr;

  valuePtr = 0;
  v2 = (const __CFNumber *)*((_QWORD *)this + 2);
  if (!v2)
    goto LABEL_15;
  if (!CFNumberGetValue(v2, kCFNumberSInt16Type, &valuePtr))
  {
    v10 = 0;
    if (CFNumberGetValue(*((CFNumberRef *)this + 2), kCFNumberSInt32Type, &v10))
      LogError("uint16Num", 301, "CFNumberGetValue/uint16_t failed: %08X\n", v10);
    if (!CFNumberGetValue(*((CFNumberRef *)this + 2), kCFNumberSInt32Type, &valuePtr))
    {
      v9 = 0;
      if (CFNumberGetValue(*((CFNumberRef *)this + 2), kCFNumberLongType, &v9))
      {
        LOWORD(v3) = v9;
        return (unsigned __int16)v3;
      }
      if (CFNumberIsFloatType(*((CFNumberRef *)this + 2)))
      {
        v8[0] = 0.0;
        if (CFNumberGetValue(*((CFNumberRef *)this + 2), kCFNumberDoubleType, v8))
          return (unsigned __int16)v8[0];
      }
      v4 = CFGetTypeID(*((CFTypeRef *)this + 2));
      v5 = CFCopyTypeIDDescription(v4);
      if (v5)
      {
        memset(v8, 0, sizeof(v8));
        IIOString::IIOString((IIOString *)v8, v5);
        v6 = (const char *)IIOString::utf8String((IIOString *)v8);
        LogError("uint16Num", 320, "CFNumberGetValue/uint16_t failed - '%s'\n", v6);
        IIOString::~IIOString((IIOString *)v8);
      }
      else
      {
        LogError("uint16Num", 324, "CFNumberGetValue/uint16_t failed\n");
      }
LABEL_15:
      LOWORD(v3) = 0;
      return (unsigned __int16)v3;
    }
  }
  LOWORD(v3) = valuePtr;
  return (unsigned __int16)v3;
}

void sub_187F8AF04(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

float IIONumber::floatNum(IIONumber *this)
{
  const __CFNumber *v2;
  const __CFNumber *v4;
  double v5;
  float valuePtr;

  valuePtr = 0.0;
  v2 = (const __CFNumber *)*((_QWORD *)this + 2);
  if (v2)
  {
    if (CFNumberGetValue(v2, kCFNumberFloatType, &valuePtr))
      return valuePtr;
    v4 = (const __CFNumber *)*((_QWORD *)this + 2);
    v5 = 0.0;
    if (v4 && CFNumberGetValue(v4, kCFNumberDoubleType, &v5))
      return v5;
  }
  else
  {
    v5 = 0.0;
  }
  LogError("floatNum", 383, "CFNumberGetValue/float failed\n", *(_QWORD *)&v5);
  return 0.0;
}

double IIONumber::doubleNum(IIONumber *this)
{
  const __CFNumber *v1;
  double valuePtr;

  valuePtr = 0.0;
  v1 = (const __CFNumber *)*((_QWORD *)this + 2);
  if (v1 && CFNumberGetValue(v1, kCFNumberDoubleType, &valuePtr))
    return valuePtr;
  LogError("doubleNum", 393, "CFNumberGetValue/double failed\n");
  return 0.0;
}

void IIOString::IIOString(IIOString *this, int a2)
{
  unsigned int v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char __str[4];
  char v17;

  *(_QWORD *)this = &off_1E1BB2F80;
  *((_QWORD *)this + 1) = 0;
  v17 = 0;
  *(_DWORD *)__str = 0;
  v4 = a2 >> 24;
  v5 = MEMORY[0x1E0C80978];
  if (a2 < 0)
    v6 = __maskrune(a2 >> 24, 0x40000uLL);
  else
    v6 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v4 + 60) & 0x40000;
  v7 = a2 << 8 >> 24;
  if (a2 << 8 < 0)
    v8 = __maskrune(a2 << 8 >> 24, 0x40000uLL);
  else
    v8 = *(_DWORD *)(v5 + 4 * v7 + 60) & 0x40000;
  v9 = (__int16)a2 >> 8;
  if (a2 << 16 < 0)
    v10 = __maskrune((__int16)a2 >> 8, 0x40000uLL);
  else
    v10 = *(_DWORD *)(v5 + 4 * v9 + 60) & 0x40000;
  if ((a2 << 24) <= 0x7F000000)
    v11 = *(_DWORD *)(v5 + 4 * (char)a2 + 60) & 0x40000;
  else
    v11 = __maskrune((char)a2, 0x40000uLL);
  if (v10)
    v12 = v9;
  else
    v12 = 46;
  if (v8)
    v13 = v7;
  else
    v13 = 46;
  if (v6)
    v14 = v4;
  else
    v14 = 46;
  if (v11)
    v15 = (char)a2;
  else
    v15 = 46;
  snprintf(__str, 5uLL, "%c%c%c%c", v14, v13, v12, v15);
  *((_QWORD *)this + 2) = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], __str, 0x8000100u);
}

void IIOString::IIOString(IIOString *this, const __CFDictionary *a2, const __CFString *a3, ...)
{
  va_list va;

  va_start(va, a3);
  *(_QWORD *)this = &off_1E1BB2F80;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = CFStringCreateWithFormatAndArguments((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, a3, va);
}

_QWORD *IIOString::IIOString(_QWORD *a1, int a2, CFIndex numBytes, UInt8 *bytes)
{
  const __CFAllocator *v5;
  const __CFData *v6;

  a1[1] = 0;
  a1[2] = 0;
  *a1 = &off_1E1BB2F80;
  if (a2 == 2)
  {
    v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v6 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], bytes, numBytes);
    a1[2] = CFStringCreateFromExternalRepresentation(v5, v6, 0x100u);
    CFRelease(v6);
  }
  else if (!a2)
  {
    a1[2] = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], bytes, numBytes, 0x600u, 0);
  }
  return a1;
}

const __CFString *IIOString::length(IIOString *this)
{
  const __CFString *result;

  result = (const __CFString *)*((_QWORD *)this + 2);
  if (result)
    return (const __CFString *)CFStringGetLength(result);
  return result;
}

const __CFArray *IIOArray::getObjectAtIndex(IIOArray *this, CFIndex a2)
{
  const __CFArray *result;

  result = (const __CFArray *)*((_QWORD *)this + 1);
  if (result)
    return (const __CFArray *)CFArrayGetValueAtIndex(result, a2);
  return result;
}

float IIOArray::getFloatAtIndex(IIOArray *this, CFIndex a2)
{
  const __CFArray *v2;
  const void *ValueAtIndex;
  float v4;
  _BYTE v6[24];

  v2 = (const __CFArray *)*((_QWORD *)this + 1);
  if (!v2)
    return 0.0;
  ValueAtIndex = CFArrayGetValueAtIndex(v2, a2);
  IIONumber::IIONumber((IIONumber *)v6, ValueAtIndex);
  v4 = IIONumber::floatNum((IIONumber *)v6);
  IIONumber::~IIONumber((IIONumber *)v6);
  return v4;
}

void sub_187F8B3D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

double IIOArray::getDoubleAtIndex(IIOArray *this, CFIndex a2)
{
  const __CFArray *v2;
  const void *ValueAtIndex;
  double v4;
  _BYTE v6[24];

  v2 = (const __CFArray *)*((_QWORD *)this + 1);
  if (!v2)
    return 0.0;
  ValueAtIndex = CFArrayGetValueAtIndex(v2, a2);
  IIONumber::IIONumber((IIONumber *)v6, ValueAtIndex);
  v4 = IIONumber::doubleNum((IIONumber *)v6);
  IIONumber::~IIONumber((IIONumber *)v6);
  return v4;
}

void sub_187F8B44C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

void IIODictionary::IIODictionary(IIODictionary *this, const IIODictionary *a2)
{
  const __CFDictionary *v3;
  CFMutableDictionaryRef MutableCopy;

  *(_QWORD *)this = &off_1E1BACDA8;
  v3 = (const __CFDictionary *)*((_QWORD *)a2 + 1);
  if (v3)
    MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v3);
  else
    MutableCopy = 0;
  *((_QWORD *)this + 1) = MutableCopy;
  *((_BYTE *)this + 16) = MutableCopy != 0;
}

uint64_t IIODictionary::copy(CFTypeRef *this)
{
  uint64_t v2;
  CFMutableDictionaryRef Mutable;

  v2 = operator new();
  *(_QWORD *)v2 = &off_1E1BACDA8;
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  *(_QWORD *)(v2 + 8) = Mutable;
  *(_BYTE *)(v2 + 16) = 1;
  CFRelease(Mutable);
  *(_QWORD *)(v2 + 8) = CFRetain(this[1]);
  *(_BYTE *)(v2 + 16) = 0;
  return v2;
}

void sub_187F8B550(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

const __CFDictionary *IIODictionary::getUint32ForKey(IIODictionary *this, const char *a2)
{
  const __CFDictionary *Uint32ForKey;
  _BYTE v5[16];
  __CFString *v6;

  IIOString::IIOString((IIOString *)v5, a2);
  Uint32ForKey = IIODictionary::getUint32ForKey(this, v6);
  IIOString::~IIOString((IIOString *)v5);
  return Uint32ForKey;
}

void sub_187F8B5BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

const __CFDictionary *IIODictionary::getUint64ForKey(IIODictionary *this, const char *a2)
{
  const __CFDictionary *Uint64ForKey;
  _BYTE v5[16];
  __CFString *v6;

  IIOString::IIOString((IIOString *)v5, a2);
  Uint64ForKey = IIODictionary::getUint64ForKey(this, v6);
  IIOString::~IIOString((IIOString *)v5);
  return Uint64ForKey;
}

void sub_187F8B618(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

float IIODictionary::getFloatForKeyGroup(IIODictionary *this, const __CFString *a2, const __CFString *a3)
{
  const __CFDictionary *GroupForKey;
  IIODictionary *Value;

  GroupForKey = IIODictionary::getGroupForKey(this, a3, 0);
  if (!GroupForKey)
    return 0.0;
  Value = (IIODictionary *)CFDictionaryGetValue(GroupForKey, a2);
  return IIODictionary::getFloatFromValue(Value, (const __CFString *)Value);
}

double IIODictionary::getDoubleForKeyGroup(IIODictionary *this, const __CFString *a2, const __CFString *a3)
{
  const __CFDictionary *GroupForKey;
  IIODictionary *Value;

  GroupForKey = IIODictionary::getGroupForKey(this, a3, 0);
  if (!GroupForKey)
    return 0.0;
  Value = (IIODictionary *)CFDictionaryGetValue(GroupForKey, a2);
  return IIODictionary::getDoubleFromValue(Value, (const __CFString *)Value);
}

double IIODictionary::getDoubleFromRationalForKey(IIODictionary *this, const __CFString *a2)
{
  const __CFDictionary *v3;
  double v4;
  const __CFDictionary *v6;
  const void *Value;
  double DoubleAtIndex;
  unsigned int v9;
  _QWORD v11[3];

  v3 = (const __CFDictionary *)*((_QWORD *)this + 1);
  v4 = 0.0;
  if (v3 && CFDictionaryContainsKey(v3, a2))
  {
    memset(v11, 0, sizeof(v11));
    v6 = (const __CFDictionary *)*((_QWORD *)this + 1);
    if (v6)
      Value = CFDictionaryGetValue(v6, a2);
    else
      Value = 0;
    IIOArray::IIOArray((IIOArray *)v11, Value);
    DoubleAtIndex = IIOArray::getDoubleAtIndex((IIOArray *)v11, 0);
    v9 = IIOArray::getDoubleAtIndex((IIOArray *)v11, 1);
    if (v9)
      v4 = (double)DoubleAtIndex / (double)v9;
    else
      v4 = 0.0;
    IIOArray::~IIOArray((IIOArray *)v11);
  }
  return v4;
}

void sub_187F8B774(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOArray::~IIOArray((IIOArray *)va);
  _Unwind_Resume(a1);
}

const void *IIODictionary::getObjectForKey(IIODictionary *this, const char *a2)
{
  const __CFDictionary *v3;
  const void *Value;
  _BYTE v6[16];
  void *key;

  IIOString::IIOString((IIOString *)v6, a2);
  v3 = (const __CFDictionary *)*((_QWORD *)this + 1);
  if (v3)
    Value = CFDictionaryGetValue(v3, key);
  else
    Value = 0;
  IIOString::~IIOString((IIOString *)v6);
  return Value;
}

void sub_187F8B7E0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

const __CFDictionary *IIODictionary::getObjectForKeyGroup(IIODictionary *this, const char *a2, const char *a3)
{
  const __CFString *v5;
  const __CFDictionary *ObjectForKeyGroup;
  _BYTE v8[16];
  __CFString *v9;
  _BYTE v10[16];
  const __CFString *v11;

  IIOString::IIOString((IIOString *)v10, a2);
  v5 = v11;
  IIOString::IIOString((IIOString *)v8, a3);
  ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup(this, v5, v9);
  IIOString::~IIOString((IIOString *)v8);
  IIOString::~IIOString((IIOString *)v10);
  return ObjectForKeyGroup;
}

void sub_187F8B864(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  IIOString::~IIOString((IIOString *)&a9);
  IIOString::~IIOString((IIOString *)&a12);
  _Unwind_Resume(a1);
}

__CFArray *IIODictionary::getArrayObjectForPath(IIODictionary *this, const __CFString *a2)
{
  const __CFAllocator *v3;
  CFArrayRef ArrayBySeparatingStrings;
  const __CFDictionary *v5;
  uint64_t Count;
  CFIndex v7;
  const __CFDictionary *Value;
  uint64_t v9;
  const void *ValueAtIndex;
  CFTypeID TypeID;
  CFTypeID v12;
  __CFArray *Mutable;
  uint64_t v15;
  CFArrayRef theArray;
  uint64_t v17;

  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, CFSTR("."));
  v15 = 0;
  theArray = 0;
  v17 = 0;
  IIOArray::IIOArray((IIOArray *)&v15, ArrayBySeparatingStrings);
  if (theArray
    && (v5 = (const __CFDictionary *)*((_QWORD *)this + 1), (Count = CFArrayGetCount(theArray)) != 0))
  {
    v7 = 0;
    Value = 0;
    v9 = Count - 1;
    while (1)
    {
      if (theArray)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(theArray, v7);
        if (ValueAtIndex)
          Value = (const __CFDictionary *)CFDictionaryGetValue(v5, ValueAtIndex);
      }
      if (!Value || v9 == v7)
        break;
      TypeID = CFDictionaryGetTypeID();
      ++v7;
      v5 = Value;
      if (TypeID != CFGetTypeID(Value))
        goto LABEL_10;
    }
  }
  else
  {
LABEL_10:
    Value = 0;
  }
  CFRelease(ArrayBySeparatingStrings);
  if (Value)
  {
    v12 = CFGetTypeID(Value);
    if (v12 == CFArrayGetTypeID())
    {
      Mutable = Value;
    }
    else
    {
      Mutable = CFArrayCreateMutable(v3, 0, MEMORY[0x1E0C9B378]);
      CFArrayAppendValue(Mutable, Value);
      CFAutorelease(Mutable);
    }
  }
  else
  {
    Mutable = 0;
  }
  IIOArray::~IIOArray((IIOArray *)&v15);
  return Mutable;
}

void sub_187F8B9D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOArray::~IIOArray((IIOArray *)va);
  _Unwind_Resume(a1);
}

__CFArray *IIODictionary::getArrayObjectForPath(IIODictionary *this, const char *a2)
{
  __CFArray *ArrayObjectForPath;
  _BYTE v5[16];
  __CFString *v6;

  IIOString::IIOString((IIOString *)v5, a2);
  ArrayObjectForPath = IIODictionary::getArrayObjectForPath(this, v6);
  IIOString::~IIOString((IIOString *)v5);
  return ArrayObjectForPath;
}

void sub_187F8BA38(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

BOOL IIODictionary::getBoolForKey(IIODictionary *this, const char *a2)
{
  _BOOL8 BoolForKey;
  _BYTE v5[16];
  __CFString *v6;

  IIOString::IIOString((IIOString *)v5, a2);
  BoolForKey = IIODictionary::getBoolForKey(this, v6);
  IIOString::~IIOString((IIOString *)v5);
  return BoolForKey;
}

void sub_187F8BA94(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

const __CFDictionary *IIODictionary::getBoolForKeyGroup(IIODictionary *this, const __CFString *a2, const __CFString *a3)
{
  const __CFDictionary *result;
  IIODictionary *Value;

  result = IIODictionary::getGroupForKey(this, a3, 0);
  if (result)
  {
    Value = (IIODictionary *)CFDictionaryGetValue(result, a2);
    return (const __CFDictionary *)IIODictionary::getBoolFromValue(Value, (const __CFString *)Value);
  }
  return result;
}

void IIODictionary::setObjectForKey(uint64_t a1, uint64_t a2, const char *a3)
{
  __CFDictionary *v3;
  _BYTE v5[16];
  void *key;

  if (a3)
  {
    v3 = *(__CFDictionary **)(a1 + 8);
    if (v3)
    {
      IIOString::IIOString((IIOString *)v5, a3);
      CFDictionarySetValue(v3, key, *(const void **)(a2 + 16));
      IIOString::~IIOString((IIOString *)v5);
    }
  }
}

void sub_187F8BB40(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void IIODictionary::setObjectForKey(IIODictionary *this, const void *a2, const char *a3)
{
  __CFDictionary *v3;
  _BYTE v5[16];
  void *key;

  if (a3)
  {
    v3 = (__CFDictionary *)*((_QWORD *)this + 1);
    if (v3)
    {
      if (a2)
      {
        IIOString::IIOString((IIOString *)v5, a3);
        CFDictionarySetValue(v3, key, a2);
      }
      else
      {
        IIOString::IIOString((IIOString *)v5, a3);
        CFDictionaryRemoveValue(v3, key);
      }
      IIOString::~IIOString((IIOString *)v5);
    }
  }
}

void sub_187F8BBC4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void IIODictionary::setObjectForKeyGroup(IIODictionary *this, const void *a2, const char *a3, const char *a4)
{
  __CFDictionary *GroupForKey;
  _BYTE v8[16];
  void *key;

  if (a3)
  {
    if (a4)
    {
      if (*((_QWORD *)this + 1))
      {
        IIOString::IIOString((IIOString *)v8, a4);
        GroupForKey = IIODictionary::getGroupForKey(this, (const __CFString *)key, 1);
        IIOString::~IIOString((IIOString *)v8);
        if (GroupForKey)
        {
          IIOString::IIOString((IIOString *)v8, a3);
          if (a2)
            CFDictionarySetValue(GroupForKey, key, a2);
          else
            CFDictionaryRemoveValue(GroupForKey, key);
          IIOString::~IIOString((IIOString *)v8);
        }
      }
    }
  }
}

void sub_187F8BC88(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void IIODictionary::removeAllObjects(IIODictionary *this)
{
  __CFDictionary *v1;

  v1 = (__CFDictionary *)*((_QWORD *)this + 1);
  if (v1)
    CFDictionaryRemoveAllValues(v1);
}

void IIODictionary::appendDictionaryNoOverwrite(IIODictionary *this, const __CFDictionary **a2)
{
  __CFDictionary *v2;

  v2 = (__CFDictionary *)*((_QWORD *)this + 1);
  if (v2)
    IIODictionaryAppendDictionary(v2, a2[1], 0);
}

__CFArray *IIOArrayCreateDeepCopy(__CFArray *a1)
{
  uint64_t Count;
  __CFArray *Mutable;
  const void **v4;
  const void **v5;
  CFTypeRef *v6;
  CFTypeID v7;
  CFTypeID TypeID;
  CFTypeRef v9;
  const void *DeepCopy;
  CFTypeID v11;
  const void *v12;
  CFRange v14;

  if (!a1)
    return 0;
  Count = CFArrayGetCount(a1);
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], Count, MEMORY[0x1E0C9B378]);
  if (Mutable)
  {
    v4 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
    if (v4)
    {
      v5 = v4;
      v14.location = 0;
      v14.length = Count;
      CFArrayGetValues(a1, v14, v4);
      if (Count >= 1)
      {
        v6 = v5;
        while (1)
        {
          v7 = CFGetTypeID(*v6);
          TypeID = CFDictionaryGetTypeID();
          v9 = *v6;
          if (v7 == TypeID)
            break;
          v11 = CFGetTypeID(v9);
          if (v11 != CFArrayGetTypeID())
          {
            CFArrayAppendValue(Mutable, *v6);
            goto LABEL_13;
          }
          DeepCopy = (const void *)IIOArrayCreateDeepCopy((__CFArray *)*v6);
          if (DeepCopy)
            goto LABEL_11;
LABEL_13:
          ++v6;
          if (!--Count)
            goto LABEL_14;
        }
        DeepCopy = (const void *)IIODictionaryCreateDeepCopy((const __CFDictionary *)v9);
        if (!DeepCopy)
          goto LABEL_13;
LABEL_11:
        v12 = DeepCopy;
        CFArrayAppendValue(Mutable, DeepCopy);
        CFRelease(v12);
        goto LABEL_13;
      }
LABEL_14:
      free(v5);
    }
  }
  return Mutable;
}

void KTXWritePlugin::~KTXWritePlugin(KTXWritePlugin *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

uint64_t KTXWritePlugin::writeKTXHeader(IIOImageWriteSession *this, unsigned int a2, unsigned int a3, int a4, unsigned int a5, char a6, int a7, int a8, int a9, int a10, char a11, char a12)
{
  char v13;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  __int128 v20;
  char v21;
  char v22;
  char v23[32];
  char v24[32];
  _BYTE v25[23];
  _QWORD __ptr[2];
  int v27;
  int v28;
  int v29;
  int v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v32 = 0u;
  v31 = 0u;
  __ptr[0] = 0xBB31312058544BABLL;
  __ptr[1] = 0x40302010A1A0A0DLL;
  v27 = a7;
  v28 = a8;
  v29 = a9;
  v30 = a10;
  if (a5 <= 4)
    LODWORD(v31) = dword_18820EF2C[a5];
  *(_QWORD *)((char *)&v31 + 4) = __PAIR64__(a3, a2);
  *(_QWORD *)&v32 = 0x100000000;
  HIDWORD(v31) = a4;
  DWORD2(v32) = 1;
  *(_OWORD *)v25 = *(_OWORD *)"KTXorientation";
  strcpy(&v25[15], "S=r,T=d");
  strcpy(v24, "ColorSpace_APPLE");
  v24[17] = a5 + 48;
  v24[18] = 0;
  v18 = 19;
  v19 = 23;
  strcpy(v23, "Compression_APPLE");
  strcpy(&v23[18], "APPL");
  v20 = xmmword_18820EED0;
  v21 = a6 + 48;
  v22 = 0;
  if (a12)
    v13 = 52;
  else
    v13 = 28;
  v16 = 18;
  v17 = 23;
  v15 = 0;
  if (a11)
    v13 += 28;
  HIDWORD(v32) = (v13 + 27) & 0xFC;
  if (IIOImageWriteSession::putBytes(this, __ptr, 0x40uLL) != 64)
    return 4294967246;
  IIOImageWriteSession::putBytes(this, &v19, 4uLL);
  IIOImageWriteSession::putBytes(this, v25, 0x17uLL);
  IIOImageWriteSession::putBytes(this, &v15, (24 - v19));
  if (a12)
  {
    IIOImageWriteSession::putBytes(this, &v18, 4uLL);
    IIOImageWriteSession::putBytes(this, v24, 0x13uLL);
    IIOImageWriteSession::putBytes(this, &v15, (20 - v18));
  }
  if (a11)
  {
    IIOImageWriteSession::putBytes(this, &v17, 4uLL);
    IIOImageWriteSession::putBytes(this, v23, 0x17uLL);
    IIOImageWriteSession::putBytes(this, &v15, (24 - v17));
  }
  IIOImageWriteSession::putBytes(this, &v16, 4uLL);
  IIOImageWriteSession::putBytes(this, &v20, 0x12uLL);
  IIOImageWriteSession::putBytes(this, &v15, (20 - v16));
  return 0;
}

uint64_t KTXWritePlugin::writeOneImage(KTXWritePlugin *this, CGImage *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

uint64_t KTXWritePlugin::writeOne(IIOImageWriteSession **this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  const __CFDictionary *ObjectForKey;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  unsigned int v12;
  unsigned int v13;
  unsigned int Error;
  char AlphaInfo;
  int v16;
  int v17;
  uint64_t v18;
  void *v19;
  size_t size[2];
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;

  if (IIODictionary::containsKey(a3, CFSTR("kCGImagePropertyEncoder")))
  {
    ObjectForKey = IIODictionary::getObjectForKey(a3, CFSTR("kCGImagePropertyEncoder"));
    if (CFEqual(ObjectForKey, CFSTR("kCGImagePropertyPVREncoder")))
    {
      v21 = 0u;
      v22 = 0u;
      *(_OWORD *)size = 0u;
      PVRWritePlugin::PVRWritePlugin((PVRWritePlugin *)size, this[2], this[3], 1);
      v8 = IIOWritePlugin::writeAll((IIOImageDestination **)size);
      PVRWritePlugin::~PVRWritePlugin((PVRWritePlugin *)size);
      return v8;
    }
    if (CFEqual(ObjectForKey, CFSTR("kCGImagePropertyBCEncoder")))
    {
      v24 = 0;
      v22 = 0u;
      v23 = 0u;
      *(_OWORD *)size = 0u;
      v21 = 0u;
      BCWritePlugin::BCWritePlugin((BCWritePlugin *)size, this[2], this[3], 1);
      v8 = IIOWritePlugin::writeAll((IIOImageDestination **)size);
      BCWritePlugin::~BCWritePlugin((BCWritePlugin *)size);
      return v8;
    }
    if (CFEqual(ObjectForKey, CFSTR("kCGImagePropertyASTCEncoder")))
    {
      v24 = 0;
      v22 = 0u;
      v23 = 0u;
      *(_OWORD *)size = 0u;
      v21 = 0u;
      ASTCWritePlugin::ASTCWritePlugin((ASTCWritePlugin *)size, this[2], this[3], 1);
      v8 = IIOWritePlugin::writeAll((IIOImageDestination **)size);
      ASTCWritePlugin::~ASTCWritePlugin((CommonASTCWritePlugin *)size, v9, v10);
      return v8;
    }
  }
  v12 = IIOImageSource::count(a2);
  v13 = IIO_Reader::testHeaderSize(a2);
  Error = _cg_GifLastError((uint64_t)a2);
  AlphaInfo = IIOImagePixelDataProvider::getAlphaInfo(a2);
  if (Error == 16)
    v16 = 5131;
  else
    v16 = 5126;
  if (Error == 16)
    v17 = 34842;
  else
    v17 = 34836;
  v18 = KTXWritePlugin::writeKTXHeader(this[2], v12, v13, 0, 1u, AlphaInfo, v16, Error >> 3, 6408, v17, 0, 0);
  LODWORD(size[0]) = IIOImagePlus::sourceImageProvider(a2) * v13;
  IIOImageWriteSession::putBytes(this[2], size, 4uLL);
  v19 = malloc_type_malloc(LODWORD(size[0]), 0x6343CC92uLL);
  IIOImagePixelDataProvider::getBytes((uint64_t (**)(IIOImagePixelDataProvider *, void *))a2, v19);
  IIOImageWriteSession::putBytes(this[2], v19, LODWORD(size[0]));
  free(v19);
  return v18;
}

void sub_187F8C2DC(_Unwind_Exception *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  ASTCWritePlugin::~ASTCWritePlugin((CommonASTCWritePlugin *)va, a2, a3);
  _Unwind_Resume(a1);
}

uint64_t KTXWritePlugin::WriteProc(KTXWritePlugin *this, IIOImageDestination *a2, void *a3, void *a4, void *a5)
{
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  _OWORD v9[2];
  uint64_t v10;

  v10 = 0;
  memset(v9, 0, sizeof(v9));
  IIOWritePlugin::IIOWritePlugin((IIOWritePlugin *)v9, this, a2, 0xFu);
  *(_QWORD *)&v9[0] = &off_1E1BAFAE0;
  v5 = IIOWritePlugin::writeAll((IIOImageDestination **)v9);
  _cg_jpeg_mem_term(v9, v6, v7);
  return v5;
}

void sub_187F8C374(void *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _cg_jpeg_mem_term(&a9, a2, a3);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187F8C360);
}

uint64_t IIOFrameBufferCreateForBuffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, double a5)
{
  uint64_t Instance;
  uint64_t v11;

  if (IIOFrameBufferGetTypeID_onceToken != -1)
    dispatch_once(&IIOFrameBufferGetTypeID_onceToken, &__block_literal_global_1);
  Instance = _CFRuntimeCreateInstance();
  v11 = Instance;
  if (Instance)
  {
    *(_QWORD *)(Instance + 16) = a1;
    *(_QWORD *)(Instance + 24) = a2;
    *(_QWORD *)(Instance + 32) = a3;
    *(_QWORD *)(Instance + 40) = a4;
    *(double *)(Instance + 48) = a5;
  }
  else
  {
    CFShow(CFSTR("Failed to allocate IIOFrameBufferRef"));
  }
  return v11;
}

CFTypeRef IIOFrameBufferRetain(CFTypeRef cf)
{
  if (cf)
    return CFRetain(cf);
  return cf;
}

void IIOFrameBufferRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

uint64_t IIOFrameBufferGetBuffer(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 16);
  return result;
}

uint64_t IIOFrameBufferGetBufferSize(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 32);
  return result;
}

uint64_t IIOFrameBufferGetFrameIndex(uint64_t a1)
{
  if (a1)
    return *(_QWORD *)(a1 + 40);
  else
    return -1;
}

double IIOFrameBufferGetDelayTime(uint64_t a1)
{
  if (a1)
    return *(double *)(a1 + 48);
  else
    return 0.0;
}

uint64_t IIOGIFFrameGetNumRowsDecoded(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 56);
  return result;
}

uint64_t IIOGIFFrameSetNumRowsDecoded(uint64_t result, uint64_t a2)
{
  if (result)
    *(_QWORD *)(result + 56) = a2;
  return result;
}

uint64_t IIOFrameBufferGetColorTable(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 64);
  return result;
}

_QWORD *IIOFrameBufferSetColorTable(_QWORD *result, _QWORD *cf)
{
  _QWORD *v3;

  if (result)
  {
    v3 = result;
    result = (_QWORD *)result[8];
    if (result != cf)
    {
      if (result)
        CFRelease(result);
      if (cf)
        result = CFRetain(cf);
      else
        result = 0;
      v3[8] = result;
    }
  }
  return result;
}

double iioFrameBufInit(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 64) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

double iioFrameBufFinalize(_QWORD *a1)
{
  unint64_t v2;
  _QWORD *v3;
  const void *v4;
  double result;

  v3 = a1 + 2;
  v2 = a1[2];
  if (v2)
    _ImageIO_Free(v2, a1[3]);
  v4 = (const void *)a1[8];
  if (v4)
    CFRelease(v4);
  v3[6] = 0;
  result = 0.0;
  *((_OWORD *)v3 + 1) = 0u;
  *((_OWORD *)v3 + 2) = 0u;
  *(_OWORD *)v3 = 0u;
  return result;
}

__CFString *iioFrameBufCopyDebugDesc(_QWORD *a1)
{
  __CFString *Mutable;
  CFIndex v3;

  Mutable = CFStringCreateMutable(0, 0);
  v3 = CFGetRetainCount(a1);
  CFStringAppendFormat(Mutable, 0, CFSTR("IIOFrameBuffer %p retainCount: %d\n"), a1, v3);
  CFStringAppendFormat(Mutable, 0, CFSTR("buffer = %p, bufferSize = %ld, frameIndex = %ld, delayTime = %g\n"), a1[2], a1[4], a1[5], a1[6]);
  return Mutable;
}

void PBMWritePlugin::~PBMWritePlugin(PBMWritePlugin *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

uint64_t PBMWritePlugin::write_P1_ASCII(IIOImageWriteSession **this, CGImageRef image, IIODictionary *a3)
{
  size_t Width;
  size_t Height;
  unsigned int v7;
  size_t v8;
  _QWORD v10[6];
  int v11;
  _OWORD v12[14];
  uint64_t v13;
  vImage_CGImageFormat v14;
  char *v15;

  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("%s", "write_P1_ASCII");
  Width = CGImageGetWidth(image);
  Height = CGImageGetHeight(image);
  v7 = Height;
  v15 = 0;
  asprintf(&v15, "P1\n# 1-bit pbm - black&white\n%ld %ld\n", Width, Height);
  if (!v15)
    return 4294967246;
  v8 = strlen(v15);
  IIOImageWriteSession::putBytes(this[2], v15, v8);
  free(v15);
  memset(&v14.bitmapInfo, 0, 24);
  *(_QWORD *)&v14.bitsPerComponent = 0x800000008;
  v14.colorSpace = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D978]);
  CGColorSpaceRelease(v14.colorSpace);
  *(_QWORD *)&v14.bitmapInfo = 0;
  v14.decode = 0;
  v13 = 0;
  memset(v12, 0, sizeof(v12));
  IIOPixelProvider::IIOPixelProvider((IIOPixelProvider *)v12, image, &v14, 0);
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 0x40000000;
  v10[2] = ___ZN14PBMWritePlugin14write_P1_ASCIIEP7CGImageP13IIODictionary_block_invoke;
  v10[3] = &__block_descriptor_tmp_2;
  v10[4] = this;
  v10[5] = "%1d ";
  v11 = 1;
  IIOPixelProvider::iterateOverImage((IIOPixelProvider *)v12, 0, v7, 16, (uint64_t)v10);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)v12);
  return 0;
}

void sub_187F8C82C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)va);
  _Unwind_Resume(a1);
}

size_t ___ZN14PBMWritePlugin14write_P1_ASCIIEP7CGImageP13IIODictionary_block_invoke(size_t result, uint64_t a2, _QWORD *a3)
{
  size_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  size_t v8;
  uint64_t v9;
  _OWORD __ptr[6];
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (a3[1])
  {
    v4 = result;
    v5 = 0;
    v6 = *(_QWORD *)(result + 32);
    v11 = 0;
    memset(__ptr, 0, sizeof(__ptr));
    while (!a3[2])
    {
      v8 = 0;
LABEL_12:
      result = IIOImageWriteSession::putBytes(*(IIOImageWriteSession **)(v6 + 16), __ptr, v8);
      if ((unint64_t)++v5 >= a3[1])
        return result;
    }
    v7 = 0;
    v8 = 0;
    v9 = *a3 + a3[3] * v5;
    while (1)
    {
      result = snprintf((char *)__ptr + v8, 100 - v8, *(const char **)(v4 + 40), *(unsigned __int8 *)(v9 + v7) < 0x81u);
      if ((int)result < 1)
        break;
      v8 += result;
      if (v8 > 100 - 5 * *(_DWORD *)(v4 + 48))
      {
        *((_BYTE *)__ptr + v8 - 1) = 10;
        IIOImageWriteSession::putBytes(*(IIOImageWriteSession **)(v6 + 16), __ptr, v8);
        v8 = 0;
      }
      if ((unint64_t)++v7 >= a3[2])
      {
        if (v8)
          *((_BYTE *)__ptr + v8 - 1) = 10;
        goto LABEL_12;
      }
    }
  }
  return result;
}

uint64_t PBMWritePlugin::write_P2_ASCII(IIOImageWriteSession **this, CGImageRef image, IIODictionary *a3)
{
  size_t Width;
  size_t Height;
  unsigned int BitsPerComponent;
  uint32_t v8;
  int v9;
  size_t v10;
  _QWORD v12[6];
  uint32_t v13;
  int v14;
  _OWORD v15[14];
  uint64_t v16;
  vImage_CGImageFormat v17;
  char *v18;

  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("%s", "write_P2_ASCII");
  Width = CGImageGetWidth(image);
  Height = CGImageGetHeight(image);
  BitsPerComponent = CGImageGetBitsPerComponent(image);
  v18 = 0;
  if (BitsPerComponent <= 0xF)
    v8 = BitsPerComponent;
  else
    v8 = 16;
  if (BitsPerComponent <= 0xF)
    v9 = ~(-1 << BitsPerComponent);
  else
    v9 = 0xFFFF;
  asprintf(&v18, "P2\n# %d-bit pgm - grayscale\n%ld %ld\n%d\n", v8, Width, Height, v9);
  if (!v18)
    return 4294967246;
  v10 = strlen(v18);
  IIOImageWriteSession::putBytes(this[2], v18, v10);
  free(v18);
  memset(&v17.bitmapInfo, 0, 24);
  v17.bitsPerComponent = v8;
  v17.bitsPerPixel = v8;
  v17.colorSpace = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D978]);
  CGColorSpaceRelease(v17.colorSpace);
  *(_QWORD *)&v17.bitmapInfo = 0;
  v17.decode = 0;
  v16 = 0;
  memset(v15, 0, sizeof(v15));
  IIOPixelProvider::IIOPixelProvider((IIOPixelProvider *)v15, image, &v17, 0);
  v12[0] = MEMORY[0x1E0C809B0];
  v12[2] = ___ZN14PBMWritePlugin14write_P2_ASCIIEP7CGImageP13IIODictionary_block_invoke;
  v12[3] = &__block_descriptor_tmp_7;
  v12[1] = 0x40000000;
  v12[4] = this;
  v12[5] = "%3d ";
  v13 = v8;
  v14 = 1;
  IIOPixelProvider::iterateOverImage((IIOPixelProvider *)v15, 0, Height, 16, (uint64_t)v12);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)v15);
  return 0;
}

void sub_187F8CB6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN14PBMWritePlugin14write_P2_ASCIIEP7CGImageP13IIODictionary_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  size_t v11;
  int v12;
  unsigned int v13;
  _OWORD __ptr[6];
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1 + 32);
  result = IIOBitStream::CreateIIOBitStream(*(IIOBitStream **)a3, (void *)(*(_QWORD *)(a3 + 24) * *(_QWORD *)(a3 + 8)), "r", a4);
  if (result)
  {
    v8 = result;
    v15 = 0;
    memset(__ptr, 0, sizeof(__ptr));
    if (*(_QWORD *)(a3 + 8))
    {
      v9 = 0;
      while (!*(_QWORD *)(a3 + 16))
      {
        v11 = 0;
LABEL_14:
        IIOImageWriteSession::putBytes(*(IIOImageWriteSession **)(v6 + 16), __ptr, v11);
        if ((unint64_t)++v9 >= *(_QWORD *)(a3 + 8))
          return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
      }
      v10 = 0;
      v11 = 0;
      while (1)
      {
        v13 = 0;
        if ((*(unsigned int (**)(uint64_t, _QWORD, unsigned int *))(*(_QWORD *)v8 + 24))(v8, *(unsigned __int16 *)(a1 + 48), &v13))
        {
          break;
        }
        v12 = snprintf((char *)__ptr + v11, 100 - v11, *(const char **)(a1 + 40), v13);
        if (v12 < 1)
          break;
        v11 += v12;
        if (v11 > 100 - 5 * *(_DWORD *)(a1 + 52))
        {
          *((_BYTE *)__ptr + v11 - 1) = 10;
          IIOImageWriteSession::putBytes(*(IIOImageWriteSession **)(v6 + 16), __ptr, v11);
          v11 = 0;
        }
        if ((unint64_t)++v10 >= *(_QWORD *)(a3 + 16))
        {
          if (v11)
            *((_BYTE *)__ptr + v11 - 1) = 10;
          goto LABEL_14;
        }
      }
    }
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
  }
  return result;
}

uint64_t PBMWritePlugin::write_P3_ASCII(IIOImageWriteSession **this, CGImageRef image, IIODictionary *a3)
{
  size_t Width;
  size_t Height;
  unsigned int BitsPerComponent;
  uint32_t v8;
  int v9;
  size_t v10;
  _QWORD v12[6];
  uint32_t v13;
  int v14;
  _OWORD v15[14];
  uint64_t v16;
  vImage_CGImageFormat v17;
  char *v18;

  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("%s", "write_P3_ASCII");
  Width = CGImageGetWidth(image);
  Height = CGImageGetHeight(image);
  BitsPerComponent = CGImageGetBitsPerComponent(image);
  v18 = 0;
  if (BitsPerComponent <= 0xF)
    v8 = BitsPerComponent;
  else
    v8 = 16;
  if (BitsPerComponent <= 0xF)
    v9 = ~(-1 << BitsPerComponent);
  else
    v9 = 0xFFFF;
  asprintf(&v18, "P3\n# %d-bit ppm - RGB\n%ld %ld\n%d\n", v8, Width, Height, v9);
  if (!v18)
    return 4294967246;
  v10 = strlen(v18);
  IIOImageWriteSession::putBytes(this[2], v18, v10);
  free(v18);
  memset(&v17.bitmapInfo, 0, 24);
  v17.bitsPerComponent = v8;
  v17.bitsPerPixel = 3 * v8;
  v17.colorSpace = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
  CGColorSpaceRelease(v17.colorSpace);
  *(_QWORD *)&v17.bitmapInfo = 0;
  v17.decode = 0;
  v16 = 0;
  memset(v15, 0, sizeof(v15));
  IIOPixelProvider::IIOPixelProvider((IIOPixelProvider *)v15, image, &v17, 0);
  v12[0] = MEMORY[0x1E0C809B0];
  v12[2] = ___ZN14PBMWritePlugin14write_P3_ASCIIEP7CGImageP13IIODictionary_block_invoke;
  v12[3] = &__block_descriptor_tmp_9;
  v12[1] = 0x40000000;
  v12[4] = this;
  v12[5] = "%3d ";
  v13 = v8;
  v14 = 3;
  IIOPixelProvider::iterateOverImage((IIOPixelProvider *)v15, 0, Height, 16, (uint64_t)v12);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)v15);
  return 0;
}

void sub_187F8CEEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN14PBMWritePlugin14write_P3_ASCIIEP7CGImageP13IIODictionary_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  size_t v11;
  int v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  _OWORD __ptr[6];
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1 + 32);
  v17 = 0;
  memset(__ptr, 0, sizeof(__ptr));
  result = IIOBitStream::CreateIIOBitStream(*(IIOBitStream **)a3, (void *)(*(_QWORD *)(a3 + 24) * *(_QWORD *)(a3 + 8)), "r", a4);
  v8 = result;
  if (*(_QWORD *)(a3 + 8))
  {
    v9 = 0;
    while (!*(_QWORD *)(a3 + 16))
    {
      v11 = 0;
LABEL_16:
      result = IIOImageWriteSession::putBytes(*(IIOImageWriteSession **)(v6 + 16), __ptr, v11);
      if ((unint64_t)++v9 >= *(_QWORD *)(a3 + 8))
        goto LABEL_17;
    }
    v14 = v9;
    v10 = 0;
    v11 = 0;
LABEL_5:
    v12 = 3;
    while (1)
    {
      v15 = 0;
      if ((*(unsigned int (**)(uint64_t, _QWORD, unsigned int *))(*(_QWORD *)v8 + 24))(v8, *(unsigned __int16 *)(a1 + 48), &v15))
      {
        break;
      }
      v13 = snprintf((char *)__ptr + v11, 100 - v11, *(const char **)(a1 + 40), v15);
      if (v13 < 1)
        break;
      v11 += v13;
      if (v11 > 100 - 5 * *(_DWORD *)(a1 + 52))
      {
        *((_BYTE *)__ptr + v11 - 1) = 10;
        IIOImageWriteSession::putBytes(*(IIOImageWriteSession **)(v6 + 16), __ptr, v11);
        v11 = 0;
      }
      if (!--v12)
      {
        if ((unint64_t)++v10 < *(_QWORD *)(a3 + 16))
          goto LABEL_5;
        if (v11)
          *((_BYTE *)__ptr + v11 - 1) = 10;
        v9 = v14;
        goto LABEL_16;
      }
    }
  }
  else
  {
LABEL_17:
    if (!v8)
      return result;
  }
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
}

uint64_t PBMWritePlugin::write_P4_Binary(IIOImageWriteSession **this, CGImageRef image, IIODictionary *a3)
{
  size_t Width;
  size_t Height;
  unsigned int v7;
  size_t v8;
  _QWORD v10[5];
  _OWORD v11[14];
  uint64_t v12;
  vImage_CGImageFormat v13;
  char *v14;
  __int128 v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("%s", "write_P4_Binary");
  Width = CGImageGetWidth(image);
  Height = CGImageGetHeight(image);
  v7 = Height;
  v14 = 0;
  asprintf(&v14, "P4\n# 1-bit pbm - black&white\n%ld %ld\n", Width, Height);
  if (!v14)
    return 4294967246;
  v8 = strlen(v14);
  IIOImageWriteSession::putBytes(this[2], v14, v8);
  free(v14);
  v15 = xmmword_18820EF70;
  memset(&v13.bitmapInfo, 0, 24);
  *(_QWORD *)&v13.bitsPerComponent = 0x100000001;
  v13.colorSpace = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D978]);
  CGColorSpaceRelease(v13.colorSpace);
  *(_QWORD *)&v13.bitmapInfo = 0;
  v13.decode = (const CGFloat *)&v15;
  v12 = 0;
  memset(v11, 0, sizeof(v11));
  IIOPixelProvider::IIOPixelProvider((IIOPixelProvider *)v11, image, &v13, 0);
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 0x40000000;
  v10[2] = ___ZN14PBMWritePlugin15write_P4_BinaryEP7CGImageP13IIODictionary_block_invoke;
  v10[3] = &__block_descriptor_tmp_11_0;
  v10[4] = this;
  IIOPixelProvider::iterateOverImage((IIOPixelProvider *)v11, 0, v7, 16, (uint64_t)v10);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)v11);
  return 0;
}

void sub_187F8D27C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)va);
  _Unwind_Resume(a1);
}

size_t ___ZN14PBMWritePlugin15write_P4_BinaryEP7CGImageP13IIODictionary_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return IIOImageWriteSession::putBytes(*(IIOImageWriteSession **)(*(_QWORD *)(a1 + 32) + 16), *(const void **)a3, *(_QWORD *)(a3 + 8) * *(_QWORD *)(a3 + 24));
}

uint64_t PBMWritePlugin::write_P5_Binary(IIOImageWriteSession **this, CGImageRef image, IIODictionary *a3)
{
  size_t Width;
  size_t Height;
  unsigned int BitsPerComponent;
  unsigned int v8;
  int v9;
  size_t v10;
  uint32_t v11;
  _QWORD v13[5];
  _OWORD v14[14];
  uint64_t v15;
  vImage_CGImageFormat v16;
  char *v17;

  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("%s", "write_P5_Binary");
  Width = CGImageGetWidth(image);
  Height = CGImageGetHeight(image);
  BitsPerComponent = CGImageGetBitsPerComponent(image);
  v17 = 0;
  if (BitsPerComponent <= 0xF)
    v8 = BitsPerComponent;
  else
    v8 = 16;
  if (BitsPerComponent <= 0xF)
    v9 = ~(-1 << BitsPerComponent);
  else
    v9 = 0xFFFF;
  asprintf(&v17, "P5\n# %d-bit ppm - grayscale\n%ld %ld\n%d\n", v8, Width, Height, v9);
  if (!v17)
    return 4294967246;
  v10 = strlen(v17);
  IIOImageWriteSession::putBytes(this[2], v17, v10);
  free(v17);
  memset(&v16.bitmapInfo, 0, 24);
  if (v8 <= 8)
    v11 = 8;
  else
    v11 = 16;
  v16.bitsPerComponent = v11;
  v16.bitsPerPixel = v11;
  v16.colorSpace = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D978]);
  CGColorSpaceRelease(v16.colorSpace);
  memset(&v16.bitmapInfo, 0, 20);
  v15 = 0;
  memset(v14, 0, sizeof(v14));
  IIOPixelProvider::IIOPixelProvider((IIOPixelProvider *)v14, image, &v16, 0);
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 0x40000000;
  v13[2] = ___ZN14PBMWritePlugin15write_P5_BinaryEP7CGImageP13IIODictionary_block_invoke;
  v13[3] = &__block_descriptor_tmp_13_0;
  v13[4] = this;
  IIOPixelProvider::iterateOverImage((IIOPixelProvider *)v14, 0, Height, 16, (uint64_t)v13);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)v14);
  return 0;
}

void sub_187F8D480(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)va);
  _Unwind_Resume(a1);
}

size_t ___ZN14PBMWritePlugin15write_P5_BinaryEP7CGImageP13IIODictionary_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return IIOImageWriteSession::putBytes(*(IIOImageWriteSession **)(*(_QWORD *)(a1 + 32) + 16), *(const void **)a3, *(_QWORD *)(a3 + 8) * *(_QWORD *)(a3 + 24));
}

uint64_t PBMWritePlugin::write_P6_Binary(IIOImageWriteSession **this, CGImageRef image, IIODictionary *a3)
{
  size_t Width;
  size_t Height;
  unsigned int BitsPerComponent;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  size_t v11;
  double v12;
  _QWORD v14[5];
  _OWORD v15[14];
  uint64_t v16;
  vImage_CGImageFormat v17;
  char *v18;
  _QWORD v19[7];

  v19[6] = *MEMORY[0x1E0C80C00];
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("%s", "write_P6_Binary");
  Width = CGImageGetWidth(image);
  Height = CGImageGetHeight(image);
  BitsPerComponent = CGImageGetBitsPerComponent(image);
  v8 = BitsPerComponent;
  v18 = 0;
  if (BitsPerComponent <= 0xF)
    v9 = BitsPerComponent;
  else
    v9 = 16;
  if (BitsPerComponent <= 0xF)
    v10 = ~(-1 << BitsPerComponent);
  else
    v10 = 0xFFFF;
  asprintf(&v18, "P6\n# %d-bit ppm - RGB\n%ld %ld\n%d\n", v9, Width, Height, v10);
  if (!v18)
    return 4294967246;
  v11 = strlen(v18);
  IIOImageWriteSession::putBytes(this[2], v18, v11);
  v12 = (double)v10 / dbl_18820EF60[v9 < 9];
  free(v18);
  v19[0] = 0;
  *(double *)&v19[1] = v12;
  v19[2] = 0;
  *(double *)&v19[3] = v12;
  v19[4] = 0;
  *(double *)&v19[5] = v12;
  memset(&v17.bitmapInfo, 0, 24);
  *(int8x8_t *)&v17.bitsPerComponent = vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v8 > 8), 0x1FuLL)), (int8x8_t)0x3000000010, (int8x8_t)0x1800000008);
  v17.colorSpace = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
  CGColorSpaceRelease(v17.colorSpace);
  *(_QWORD *)&v17.bitmapInfo = 0;
  v17.decode = (const CGFloat *)v19;
  v16 = 0;
  memset(v15, 0, sizeof(v15));
  IIOPixelProvider::IIOPixelProvider((IIOPixelProvider *)v15, image, &v17, 0);
  v14[0] = MEMORY[0x1E0C809B0];
  v14[1] = 0x40000000;
  v14[2] = ___ZN14PBMWritePlugin15write_P6_BinaryEP7CGImageP13IIODictionary_block_invoke;
  v14[3] = &__block_descriptor_tmp_15;
  v14[4] = this;
  IIOPixelProvider::iterateOverImage((IIOPixelProvider *)v15, 0, Height, 16, (uint64_t)v14);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)v15);
  return 0;
}

void sub_187F8D704(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)va);
  _Unwind_Resume(a1);
}

size_t ___ZN14PBMWritePlugin15write_P6_BinaryEP7CGImageP13IIODictionary_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return IIOImageWriteSession::putBytes(*(IIOImageWriteSession **)(*(_QWORD *)(a1 + 32) + 16), *(const void **)a3, *(_QWORD *)(a3 + 8) * *(_QWORD *)(a3 + 24));
}

uint64_t PBMWritePlugin::write_Pf_Binary(IIOImageWriteSession **this, CGImageRef image, IIODictionary *a3)
{
  size_t Width;
  size_t Height;
  unsigned int v7;
  size_t v8;
  uint64_t v9;
  _QWORD v11[5];
  _OWORD v12[14];
  uint64_t v13;
  vImage_CGImageFormat v14;
  char *v15;

  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("%s", "write_Pf_Binary");
  Width = CGImageGetWidth(image);
  Height = CGImageGetHeight(image);
  v7 = Height;
  v15 = 0;
  asprintf(&v15, "Pf\n%ld %ld\n-1\n", Width, Height);
  if (!v15)
    return 4294967246;
  v8 = strlen(v15);
  IIOImageWriteSession::putBytes(this[2], v15, v8);
  free(v15);
  memset(&v14.bitmapInfo, 0, 24);
  *(_QWORD *)&v14.bitsPerComponent = 0x2000000020;
  v14.colorSpace = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D978]);
  CGColorSpaceRelease(v14.colorSpace);
  v14.bitmapInfo = 8448;
  *(_OWORD *)&v14.version = 0uLL;
  v13 = 0;
  memset(v12, 0, sizeof(v12));
  IIOPixelProvider::IIOPixelProvider((IIOPixelProvider *)v12, image, &v14, 0);
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 0x40000000;
  v11[2] = ___ZN14PBMWritePlugin15write_Pf_BinaryEP7CGImageP13IIODictionary_block_invoke;
  v11[3] = &__block_descriptor_tmp_17;
  v11[4] = this;
  v9 = IIOPixelProvider::iterateOverImage((IIOPixelProvider *)v12, 0, v7, 16, (uint64_t)v11);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)v12);
  return v9;
}

void sub_187F8D8E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)va);
  _Unwind_Resume(a1);
}

size_t ___ZN14PBMWritePlugin15write_Pf_BinaryEP7CGImageP13IIODictionary_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return IIOImageWriteSession::putBytes(*(IIOImageWriteSession **)(*(_QWORD *)(a1 + 32) + 16), *(const void **)a3, *(_QWORD *)(a3 + 8) * *(_QWORD *)(a3 + 24));
}

uint64_t PBMWritePlugin::write_PF_Binary(IIOImageWriteSession **this, CGImageRef image, IIODictionary *a3)
{
  size_t Width;
  size_t Height;
  unsigned int v7;
  size_t v8;
  _QWORD v10[5];
  _OWORD v11[14];
  uint64_t v12;
  vImage_CGImageFormat v13;
  char *v14;

  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("%s", "write_PF_Binary");
  Width = CGImageGetWidth(image);
  Height = CGImageGetHeight(image);
  v7 = Height;
  v14 = 0;
  asprintf(&v14, "PF\n%ld %ld\n-1\n", Width, Height);
  if (v14)
  {
    v8 = strlen(v14);
    IIOImageWriteSession::putBytes(this[2], v14, v8);
    free(v14);
    memset(&v13.bitmapInfo, 0, 24);
    *(_QWORD *)&v13.bitsPerComponent = 0x6000000020;
    v13.colorSpace = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
    CGColorSpaceRelease(v13.colorSpace);
    v13.bitmapInfo = 8448;
    *(_OWORD *)&v13.version = 0uLL;
    v12 = 0;
    memset(v11, 0, sizeof(v11));
    IIOPixelProvider::IIOPixelProvider((IIOPixelProvider *)v11, image, &v13, 0);
    v10[0] = MEMORY[0x1E0C809B0];
    v10[1] = 0x40000000;
    v10[2] = ___ZN14PBMWritePlugin15write_PF_BinaryEP7CGImageP13IIODictionary_block_invoke;
    v10[3] = &__block_descriptor_tmp_19;
    v10[4] = this;
    IIOPixelProvider::iterateOverImage((IIOPixelProvider *)v11, 0, v7, 16, (uint64_t)v10);
    IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)v11);
  }
  return 0;
}

void sub_187F8DAA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)va);
  _Unwind_Resume(a1);
}

size_t ___ZN14PBMWritePlugin15write_PF_BinaryEP7CGImageP13IIODictionary_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return IIOImageWriteSession::putBytes(*(IIOImageWriteSession **)(*(_QWORD *)(a1 + 32) + 16), *(const void **)a3, *(_QWORD *)(a3 + 8) * *(_QWORD *)(a3 + 24));
}

uint64_t PBMWritePlugin::writeOneImage(IIOImageWriteSession **this, CGImageRef image, IIODictionary *a3, IIODictionary *a4)
{
  __int16 BitmapInfo;
  CGColorSpace *ColorSpace;
  CGColorSpaceModel Model;
  unsigned int BitsPerComponent;
  IIODictionary *v11;
  _BOOL4 BoolForKey;
  _BOOL4 v15;

  BitmapInfo = CGImageGetBitmapInfo(image);
  ColorSpace = CGImageGetColorSpace(image);
  Model = CGColorSpaceGetModel(ColorSpace);
  BitsPerComponent = CGImageGetBitsPerComponent(image);
  if (IIODictionary::containsKey(a3, CFSTR("kCGImageDestinationOptimizeForSize")))
  {
    BoolForKey = IIODictionary::getBoolForKey(a3, CFSTR("kCGImageDestinationOptimizeForSize"));
    if ((BitmapInfo & 0x100) != 0)
      goto LABEL_3;
  }
  else
  {
    BoolForKey = BitsPerComponent > 8;
    if ((BitmapInfo & 0x100) != 0)
    {
LABEL_3:
      if (Model == kCGColorSpaceModelMonochrome)
        return PBMWritePlugin::write_Pf_Binary(this, image, v11);
      PBMWritePlugin::write_PF_Binary(this, image, v11);
      return 0;
    }
  }
  v15 = BitsPerComponent == 1 && Model == kCGColorSpaceModelMonochrome;
  if (BoolForKey)
  {
    if (v15)
    {
      return PBMWritePlugin::write_P4_Binary(this, image, v11);
    }
    else if (Model)
    {
      return PBMWritePlugin::write_P6_Binary(this, image, v11);
    }
    else
    {
      return PBMWritePlugin::write_P5_Binary(this, image, v11);
    }
  }
  else if (v15)
  {
    return PBMWritePlugin::write_P1_ASCII(this, image, v11);
  }
  else if (Model)
  {
    return PBMWritePlugin::write_P3_ASCII(this, image, v11);
  }
  else
  {
    return PBMWritePlugin::write_P2_ASCII(this, image, v11);
  }
}

uint64_t PBMWritePlugin::WriteProc(PBMWritePlugin *this, IIOImageDestination *a2, void *a3, void *a4, void *a5)
{
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  _OWORD v9[2];
  uint64_t v10;

  v10 = 0;
  memset(v9, 0, sizeof(v9));
  IIOWritePlugin::IIOWritePlugin((IIOWritePlugin *)v9, this, a2, 0x12u);
  *(_QWORD *)&v9[0] = &off_1E1BAFB58;
  v5 = IIOWritePlugin::writeAll((IIOImageDestination **)v9);
  _cg_jpeg_mem_term(v9, v6, v7);
  return v5;
}

void sub_187F8DCBC(void *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _cg_jpeg_mem_term(&a9, a2, a3);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187F8DCA8);
}

uint64_t IIOCreateDataWithContentsOfURL(void *a1)
{
  uint64_t v2;
  uint64_t v4;

  v4 = 0;
  v2 = objc_msgSend(objc_alloc(MEMORY[0x1E0C99D50]), "initWithContentsOfURL:options:error:", a1, 0, &v4);
  if (!v2 && (v4 || IIO_OSAppleInternalBuild()))
  {
    NSLog(CFSTR("*** ERROR: cannot get data from '%@'"), a1);
    NSLog(CFSTR("                 error: %@"), v4);
    NSLog(CFSTR("             isFileURL: %d"), objc_msgSend(a1, "isFileURL"));
    NSLog(CFSTR("    isFileReferenceURL: %d"), objc_msgSend(a1, "isFileReferenceURL"));
    NSLog(CFSTR("               isProxy: %d"), objc_msgSend(a1, "isProxy"));
  }
  return v2;
}

uint64_t IIOIsAppSuspended()
{
  if (IIOIsAppSuspended::once != -1)
    dispatch_once(&IIOIsAppSuspended::once, &__block_literal_global_2);
  if (gSharedApp)
    return (uint64_t)objc_msgSend((id)gSharedApp, sel_isSuspended);
  else
    return 1;
}

uint64_t IIODictionaryIsMutable()
{
  objc_class *v0;
  NSString *v1;

  v0 = (objc_class *)objc_opt_class();
  v1 = NSStringFromClass(v0);
  if (-[NSString isEqualToString:](v1, "isEqualToString:", CFSTR("__NSDictionaryI")))
    return 0;
  if (!-[NSString isEqualToString:](v1, "isEqualToString:", CFSTR("__NSDictionaryM")))
  {
    objc_opt_class();
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0)
    {
      objc_opt_class();
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
        abort();
      return 0;
    }
  }
  return 1;
}

uint64_t RGBColorType::compare(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v7;
  unsigned int v8;
  BOOL v9;
  unsigned int v10;

  v2 = a1[1];
  v3 = a2[1];
  if (v2 > v3)
    return 1;
  if (v2 < v3)
    return 0xFFFFFFFFLL;
  v4 = *a1;
  v5 = *a2;
  if (v4 > v5)
    return 1;
  if (v4 < v5)
    return 0xFFFFFFFFLL;
  v7 = a1[2];
  v8 = a2[2];
  v9 = v7 > v8;
  if (v7 >= v8)
    v10 = 0;
  else
    v10 = -1;
  if (v9)
    return 1;
  else
    return v10;
}

BOOL RGBColorType::isCloseTo(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v2;
  int v3;
  int v4;

  v2 = *a1 - *a2;
  if (v2 < 0)
    v2 = *a2 - *a1;
  if (v2 > 4)
    return 0;
  v3 = a1[1] - a2[1];
  if (v3 < 0)
    v3 = a2[1] - a1[1];
  if (v3 > 4)
    return 0;
  v4 = a1[2] - a2[2];
  if (v4 < 0)
    v4 = a2[2] - a1[2];
  return v4 < 5;
}

BOOL RGBColorMap::equalTo(_QWORD *a1, _QWORD *a2)
{
  uint64_t v2;
  unsigned __int8 *v3;
  unsigned __int8 *v4;
  uint64_t v5;
  int v6;
  _BOOL8 result;
  BOOL v9;

  v2 = *(unsigned int *)a1;
  if (*a1 != *a2)
    return 0;
  if ((int)v2 < 1)
    return 1;
  v3 = (unsigned __int8 *)a1[2];
  v4 = (unsigned __int8 *)a2[2];
  v5 = v2 - 1;
  do
  {
    v6 = RGBColorType::compare(v3, v4);
    result = v6 == 0;
    v9 = v5-- != 0;
    if (v6)
      break;
    v4 += 3;
    v3 += 3;
  }
  while (v9);
  return result;
}

void ColorQuantization::ColorQuantization(ColorQuantization *this)
{
  *(_QWORD *)this = &off_1E1BB0FE8;
}

void ColorQuantization::~ColorQuantization(ColorQuantization *this)
{
  JUMPOUT(0x18D761C30);
}

uint64_t ColorQuantization::hist3d(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, _QWORD *a7, int a8, uint64_t *a9)
{
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t i;
  unint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t result;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char v44;
  uint64_t v45;
  uint64_t v46;
  unsigned __int8 *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unsigned int v51;
  double v52;
  uint64_t v53;
  uint64_t v54;
  _DWORD v55[256];
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v15 = a8 - 1;
  if ((a8 - 1) > 5)
  {
    v53 = 2;
    v54 = 0;
    v16 = 1;
    v17 = 3;
  }
  else
  {
    v16 = qword_18820F000[v15];
    v53 = qword_18820F030[v15];
    v54 = qword_18820EFD0[v15];
    v17 = 4;
  }
  bzero(v55, 0x400uLL);
  for (i = 0; i != 256; ++i)
    v55[i] = i * i;
  v19 = a7[1];
  if (v19)
  {
    v20 = 0;
    v21 = 0;
    v22 = *a7 + v54;
    v24 = a7[2];
    v23 = a7[3];
    v25 = *a7 + v16;
    v26 = *a7 + v53;
    do
    {
      if (v24)
      {
        v27 = 0;
        v28 = 0;
        v29 = a9[5] + 2 * v21;
        do
        {
          v30 = *(unsigned __int8 *)(v25 + v28);
          v31 = *(unsigned __int8 *)(v22 + v28);
          v32 = *(unsigned __int8 *)(v26 + v28);
          v33 = (v30 >> 3)
              + 1
              + 1089 * (v31 >> 3)
              + 32 * ((v30 >> 3) + 1)
              + (v32 >> 3)
              + 1090;
          *(_WORD *)(v29 + 2 * v27) = (v30 >> 3)
                                    + 1
                                    + 1089 * (v31 >> 3)
                                    + 32 * ((v30 >> 3) + 1)
                                    + (v32 >> 3)
                                    + 1090;
          ++a2[v33];
          *(_QWORD *)(a3 + 8 * v33) += v31;
          *(_QWORD *)(a4 + 8 * v33) += v30;
          LODWORD(v31) = v55[v31];
          v34 = *(_QWORD *)(a5 + 8 * v33) + v32;
          LODWORD(v30) = v55[v30];
          LODWORD(v32) = v55[v32];
          *(_QWORD *)(a5 + 8 * v33) = v34;
          v28 += v17;
          ++v27;
          *(double *)(a6 + 8 * v33) = *(double *)(a6 + 8 * v33) + (double)((int)v30 + (int)v31 + (int)v32);
        }
        while (v24 > v27);
        v21 += v27;
      }
      ++v20;
      v22 += v23;
      v25 += v23;
      v26 += v23;
    }
    while (v19 > v20);
  }
  v35 = 0;
  v36 = 35937;
  do
  {
    v38 = *a2++;
    v37 = v38;
    if (v38 > v35)
      v35 = v37;
    --v36;
  }
  while (v36);
  result = 0;
  v40 = v35 + 1;
  v41 = a9[2];
  v42 = a9[3];
  v43 = a9[4];
  v44 = 1;
  v46 = *a9;
  v45 = a9[1];
  do
  {
    v47 = (unsigned __int8 *)&unk_18820EFB0 + 3 * result;
    v48 = *v47;
    v49 = v47[1];
    v50 = v47[2];
    v51 = (v49 >> 3)
        + 1
        + 1089 * (v48 >> 3)
        + 32 * ((v49 >> 3) + 1)
        + (v50 >> 3)
        + 1090;
    *(_QWORD *)(v45 + 8 * v51) = v40;
    *(_QWORD *)(v41 + 8 * v51) = v40 * v48;
    *(_QWORD *)(v42 + 8 * v51) = v40 * v49;
    *(_QWORD *)(v43 + 8 * v51) = v40 * v50;
    v52 = (double)(v55[v49] + v55[v48] + v55[v50]);
    LOBYTE(v48) = v44;
    *(double *)(v46 + 8 * v51) = (double)v40 * v52;
    result = 1;
    v44 = 0;
  }
  while ((v48 & 1) != 0);
  return result;
}

uint64_t *ColorQuantization::m3d(ColorQuantization *this, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, double *a6)
{
  int v6;
  int v7;
  double *v8;
  uint64_t *v9;
  uint64_t *result;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  double v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  double v23;
  uint64_t v24;
  double v25;
  int v26;
  double *v27;
  _OWORD v28[16];
  uint64_t v29;
  _OWORD v30[16];
  uint64_t v31;
  _OWORD v32[16];
  uint64_t v33;
  _OWORD v34[16];
  uint64_t v35;
  _OWORD v36[16];
  uint64_t v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v6 = 1;
  do
  {
    v26 = v6;
    v29 = 0;
    *((_QWORD *)&v28[0] + 1) = 0;
    memset(&v28[1], 0, 240);
    v31 = 0;
    memset(v30, 0, sizeof(v30));
    v33 = 0;
    memset(v32, 0, sizeof(v32));
    v35 = 0;
    memset(v34, 0, sizeof(v34));
    v37 = 0;
    v7 = 1;
    v27 = a6;
    v8 = a6;
    v9 = a5;
    result = a4;
    v11 = a3;
    v12 = a2;
    memset(v36, 0, sizeof(v36));
    do
    {
      v13 = 0;
      v14 = 0;
      v15 = 0;
      v16 = 0;
      v17 = 0;
      v18 = 0.0;
      do
      {
        v17 += v12[v13 + 1123];
        v16 += v11[v13 + 1123];
        v15 += result[v13 + 1123];
        v19 = v9[v13 + 1123];
        v20 = *(_QWORD *)((char *)v36 + v13 * 8 + 8) + v17;
        *(_QWORD *)((char *)v36 + v13 * 8 + 8) = v20;
        v14 += v19;
        v21 = *(_QWORD *)((char *)v34 + v13 * 8 + 8) + v16;
        *(_QWORD *)((char *)v34 + v13 * 8 + 8) = v21;
        v22 = *(_QWORD *)((char *)v32 + v13 * 8 + 8) + v15;
        *(_QWORD *)((char *)v32 + v13 * 8 + 8) = v22;
        v23 = v8[v13 + 1123];
        v24 = *(_QWORD *)((char *)v30 + v13 * 8 + 8) + v14;
        *(_QWORD *)((char *)v30 + v13 * 8 + 8) = v24;
        v18 = v18 + v23;
        v25 = v18 + *(double *)((char *)v28 + v13 * 8 + 8);
        *(double *)((char *)v28 + v13 * 8 + 8) = v25;
        v12[v13 + 1123] = v12[v13 + 34] + v20;
        v11[v13 + 1123] = v11[v13 + 34] + v21;
        result[v13 + 1123] = result[v13 + 34] + v22;
        v9[v13 + 1123] = v9[v13 + 34] + v24;
        v8[v13 + 1123] = v25 + v8[v13 + 34];
        ++v13;
      }
      while (v13 != 32);
      ++v7;
      v12 += 33;
      v11 += 33;
      result += 33;
      v9 += 33;
      v8 += 33;
    }
    while (v7 != 33);
    v6 = v26 + 1;
    a2 += 1089;
    a3 += 1089;
    a4 += 1089;
    a5 += 1089;
    a6 = v27 + 1089;
  }
  while (v26 != 32);
  return result;
}

uint64_t ColorQuantization::vol(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;

  v3 = 1089 * a2[1];
  v4 = 33 * a2[3];
  v6 = a2[4];
  v5 = a2[5];
  v7 = 33 * a2[2];
  v8 = 1089 * *a2;
  return *(_QWORD *)(a3 + 8 * (v4 + v3 + v5))
       + *(_QWORD *)(a3 + 8 * (v7 + v3 + v6))
       - (*(_QWORD *)(a3 + 8 * (v4 + v3 + v6))
        + *(_QWORD *)(a3 + 8 * (v7 + v3 + v5))
        + *(_QWORD *)(a3 + 8 * (v4 + v8 + v5)))
       + *(_QWORD *)(a3 + 8 * (v4 + v8 + v6))
       + *(_QWORD *)(a3 + 8 * (v7 + v8 + v5))
       - *(_QWORD *)(a3 + 8 * (v7 + v8 + v6));
}

uint64_t ColorQuantization::bottom(uint64_t a1, _DWORD *a2, int a3, uint64_t a4)
{
  int v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;

  switch(a3)
  {
    case 0:
      v13 = a2[3];
      v12 = a2[4];
      v14 = v12 + 1089 * a2[1];
      v15 = a2[2];
      v16 = *(_QWORD *)(a4 + 8 * (v14 + v13 + 32 * v13));
      v17 = 1089 * *a2;
      v18 = *(_QWORD *)(a4 + 8 * (33 * v13 + v12 + v17));
      v19 = *(_QWORD *)(a4 + 8 * (v15 + v12 + 32 * v15 + v17));
      v10 = *(_QWORD *)(a4 + 8 * (v14 + v15 + 32 * v15)) + v18;
LABEL_7:
      v11 = v16 + v19;
      return v10 - v11;
    case 1:
      v20 = 33 * a2[2];
      v21 = v20 + 1089 * a2[1];
      v23 = a2[4];
      v22 = a2[5];
      v16 = *(_QWORD *)(a4 + 8 * (v21 + v22));
      v24 = v20 + 1089 * *a2;
      v25 = *(_QWORD *)(a4 + 8 * (v24 + v22));
      v19 = *(_QWORD *)(a4 + 8 * (v24 + v23));
      v10 = *(_QWORD *)(a4 + 8 * (v21 + v23)) + v25;
      goto LABEL_7;
    case 2:
      v4 = 1089 * *a2;
      v5 = a2[3] + v4 + 32 * a2[3];
      v7 = a2[4];
      v6 = a2[5];
      v8 = *(_QWORD *)(a4 + 8 * (v5 + v6));
      v9 = a2[2] + v4 + 32 * a2[2];
      v10 = *(_QWORD *)(a4 + 8 * (v5 + v7)) + *(_QWORD *)(a4 + 8 * (v9 + v6));
      v11 = v8 + *(_QWORD *)(a4 + 8 * (v9 + v7));
      return v10 - v11;
  }
  return 0;
}

uint64_t ColorQuantization::top(uint64_t a1, _DWORD *a2, int a3, int a4, uint64_t a5)
{
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;

  switch(a3)
  {
    case 0:
      v13 = a4 + 1089 * a2[1];
      v15 = a2[2];
      v14 = a2[3];
      v8 = *(_QWORD *)(a5 + 8 * (v13 + v14 + 32 * v14));
      v9 = *(_QWORD *)(a5 + 8 * (v13 + v15 + 32 * v15));
      v16 = 1089 * *a2;
      v11 = *(_QWORD *)(a5 + 8 * (v14 + a4 + 32 * v14 + v16));
      v12 = v15 + a4 + 32 * v15 + v16;
      goto LABEL_6;
    case 1:
      v19 = 33 * a4 + 1089 * a2[1];
      v21 = a2[4];
      v20 = a2[5];
      v22 = 33 * a4 + 1089 * *a2;
      v23 = *(_QWORD *)(a5 + 8 * (v22 + v20));
      v17 = *(_QWORD *)(a5 + 8 * (v22 + v21));
      v18 = *(_QWORD *)(a5 + 8 * (v19 + v20)) - (*(_QWORD *)(a5 + 8 * (v19 + v21)) + v23);
      return v18 + v17;
    case 2:
      v5 = a2[3] + 1089 * a4 + 32 * a2[3];
      v7 = a2[4];
      v6 = a2[5];
      v8 = *(_QWORD *)(a5 + 8 * (v5 + v6));
      v9 = *(_QWORD *)(a5 + 8 * (v5 + v7));
      v10 = a2[2] + 1089 * a4 + 32 * a2[2];
      v11 = *(_QWORD *)(a5 + 8 * (v10 + v6));
      v12 = v10 + v7;
LABEL_6:
      v17 = *(_QWORD *)(a5 + 8 * v12);
      v18 = v8 - (v9 + v11);
      return v18 + v17;
  }
  return 0;
}

double ColorQuantization::variance(uint64_t a1, _DWORD *a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t v6;
  double v7;
  uint64_t v8;
  double v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  double v17;

  v5 = *a3;
  v6 = ColorQuantization::vol(a1, a2, a3[2]);
  v7 = (double)v6;
  v8 = ColorQuantization::vol(v6, a2, a3[3]);
  v9 = (double)v8;
  v10 = ColorQuantization::vol(v8, a2, a3[4]);
  v11 = 1089 * a2[1];
  v12 = 33 * a2[3];
  v14 = a2[4];
  v13 = a2[5];
  v15 = 33 * a2[2];
  v16 = 1089 * *a2;
  v17 = *(double *)(v5 + 8 * (v12 + v11 + v13))
      - *(double *)(v5 + 8 * (v12 + v11 + v14))
      - *(double *)(v5 + 8 * (v15 + v11 + v13))
      + *(double *)(v5 + 8 * (v15 + v11 + v14))
      - *(double *)(v5 + 8 * (v12 + v16 + v13))
      + *(double *)(v5 + 8 * (v12 + v16 + v14))
      + *(double *)(v5 + 8 * (v15 + v16 + v13))
      - *(double *)(v5 + 8 * (v15 + v16 + v14));
  return v17 - (v9 * v9 + v7 * v7 + (double)v10 * (double)v10) / (double)ColorQuantization::vol(v10, a2, a3[1]);
}

double ColorQuantization::maximize(uint64_t a1, _DWORD *a2, int a3, int a4, int a5, int *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, _QWORD *a11)
{
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  double v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;

  v32 = a11[2];
  v16 = ColorQuantization::bottom(a1, a2, a3, v32);
  v30 = a11[3];
  v31 = v16;
  v17 = ColorQuantization::bottom(v16, a2, a3, v30);
  v28 = a11[4];
  v29 = v17;
  v27 = ColorQuantization::bottom(v17, a2, a3, v28);
  v18 = a11[1];
  v19 = ColorQuantization::bottom(v27, a2, a3, v18);
  v26 = a6;
  *a6 = -1;
  v20 = 0.0;
  if (a4 < a5)
  {
    v21 = v19;
    do
    {
      v19 = ColorQuantization::top(v19, a2, a3, a4, v18);
      v22 = v19 + v21;
      if (v19 + v21)
      {
        if (a10 != v22)
        {
          v23 = ColorQuantization::top(v19, a2, a3, a4, v28);
          v24 = ColorQuantization::top(v23, a2, a3, a4, v30);
          v19 = ColorQuantization::top(v24, a2, a3, a4, v32);
          if (((double)(v24 + v29) * (double)(v24 + v29)
              + (double)(v19 + v31) * (double)(v19 + v31)
              + (double)(v23 + v27) * (double)(v23 + v27))
             / (double)v22
             + ((double)(a8 - (v24 + v29)) * (double)(a8 - (v24 + v29))
              + (double)(a7 - (v19 + v31)) * (double)(a7 - (v19 + v31))
              + (double)(a9 - (v23 + v27)) * (double)(a9 - (v23 + v27)))
             / (double)(a10 - v22) > v20)
          {
            *v26 = a4;
            v20 = ((double)(v24 + v29) * (double)(v24 + v29)
                 + (double)(v19 + v31) * (double)(v19 + v31)
                 + (double)(v23 + v27) * (double)(v23 + v27))
                / (double)v22
                + ((double)(a8 - (v24 + v29)) * (double)(a8 - (v24 + v29))
                 + (double)(a7 - (v19 + v31)) * (double)(a7 - (v19 + v31))
                 + (double)(a9 - (v23 + v27)) * (double)(a9 - (v23 + v27)))
                / (double)(a10 - v22);
          }
        }
      }
      ++a4;
    }
    while (a5 != a4);
  }
  return v20;
}

uint64_t ColorQuantization::cut(uint64_t a1, int *a2, _DWORD *a3, _QWORD *a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  double v12;
  uint64_t v13;
  double v14;
  int v15;
  int v16;
  uint64_t v17;
  double v18;
  __int128 v19;
  unsigned int v20;
  int v21;
  int v22;
  unsigned int v24;
  int v25;
  int v26;
  int v27;
  uint64_t v28;

  v28 = 0;
  v27 = 0;
  v7 = ColorQuantization::vol(a1, a2, a4[2]);
  v8 = ColorQuantization::vol(v7, a2, a4[3]);
  v9 = ColorQuantization::vol(v8, a2, a4[4]);
  v10 = ColorQuantization::vol(v9, a2, a4[1]);
  v11 = *a2;
  v26 = a2[1];
  v12 = ColorQuantization::maximize(v10, a2, 2, *a2 + 1, v26, (int *)&v28 + 1, v7, v8, v9, v10, a4);
  v24 = a2[2];
  v25 = a2[3];
  v14 = ColorQuantization::maximize(v13, a2, 1, v24 + 1, v25, (int *)&v28, v7, v8, v9, v10, a4);
  v15 = a2[4];
  v16 = a2[5];
  v18 = ColorQuantization::maximize(v17, a2, 0, v15 + 1, v16, &v27, v7, v8, v9, v10, a4);
  if (v12 < v14 || v12 < v18)
  {
    v21 = v25;
    v22 = v26;
    a3[1] = v26;
    a3[3] = v25;
    a3[5] = v16;
    if (v14 < v12 || v14 < v18)
    {
      v15 = v27;
      a2[5] = v27;
      a3[4] = v15;
      *a3 = v11;
      v20 = v24;
      a3[2] = v24;
      v16 = a3[5];
    }
    else
    {
      v20 = v28;
      a2[3] = v28;
      a3[2] = v20;
      *a3 = v11;
      a3[4] = v15;
      v21 = a3[3];
    }
    goto LABEL_9;
  }
  v11 = HIDWORD(v28);
  if ((v28 & 0x8000000000000000) == 0)
  {
    a3[5] = v16;
    *(_QWORD *)&v19 = __PAIR64__(v24, v26);
    v20 = v24;
    v21 = v25;
    *((_QWORD *)&v19 + 1) = __PAIR64__(v15, v25);
    *a3 = v11;
    *(_OWORD *)(a3 + 1) = v19;
    a2[1] = v11;
    v22 = a3[1];
LABEL_9:
    a2[6] = (a2[3] - a2[2]) * (a2[1] - *a2) * (a2[5] - a2[4]);
    a3[6] = (v21 - v20) * (v22 - v11) * (v16 - v15);
    return 1;
  }
  return 0;
}

void ColorQuantization::mark(uint64_t a1, int *a2, char a3, uint64_t a4)
{
  int v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;

  v4 = *a2;
  v5 = a2[1];
  if (*a2 < v5)
  {
    v6 = a2[3];
    v7 = 1089 * v4 + 1122;
    do
    {
      v8 = a2[2];
      if ((int)v8 < v6)
      {
        LODWORD(v9) = a2[5];
        v10 = v7 + 33 * v8;
        do
        {
          v11 = a2[4];
          if ((int)v11 < (int)v9)
          {
            do
            {
              *(_BYTE *)(a4 + 1 + v10 + v11) = a3;
              v9 = a2[5];
              ++v11;
            }
            while (v11 < v9);
            v6 = a2[3];
          }
          ++v8;
          v10 += 33;
        }
        while (v8 < v6);
        v5 = a2[1];
      }
      ++v4;
      v7 += 1089;
    }
    while (v4 < v5);
  }
}

void ColorQuantization::addColorNode(uint64_t a1, uint64_t a2, __int16 a3, unsigned int a4, unsigned int a5, unsigned int a6, int a7)
{
  uint64_t v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  _OWORD *v16;
  unsigned int v17;
  int v18;
  uint64_t v20;
  _WORD *v21;

  v8 = a2;
  v9 = (a5 >> 6) & 2 | (a4 >> 5) & 4 | (a6 >> 7);
  v10 = a7 - 8;
  if (a7 == 8)
  {
    v11 = a2;
  }
  else
  {
    v12 = a6;
    v13 = a5;
    v14 = a4;
    do
    {
      v15 = v9;
      v11 = *(_QWORD *)(v8 + 8 * v9);
      if (!v11)
      {
        v16 = malloc_type_malloc(0x40uLL, 0x80040A284212CuLL);
        *(_QWORD *)(v8 + 8 * v15) = v16;
        if (!v16)
          return;
        v16[2] = 0u;
        v16[3] = 0u;
        *v16 = 0u;
        v16[1] = 0u;
        v11 = *(_QWORD *)(v8 + 8 * v15);
      }
      v17 = v14 >> 4;
      v14 *= 2;
      v18 = v17 & 4 | (v13 >> 5) & 3;
      v13 *= 2;
      v9 = v18 & 0xFFFFFFFE | (v12 >> 6) & 1;
      v12 *= 2;
      v8 = v11;
    }
    while (!__CFADD__(v10++, 1));
  }
  if (!*(_QWORD *)(v11 + 8 * v9))
  {
    v20 = v9;
    v21 = malloc_type_malloc(2uLL, 0x1000040BDFB0063uLL);
    *(_QWORD *)(v11 + 8 * v20) = v21;
    if (v21)
      *v21 = a3;
  }
}

uint64_t ColorQuantization::lookupColorNode(uint64_t a1, unsigned __int8 *a2, unsigned int a3, unsigned __int8 a4, unsigned int a5, int a6)
{
  unsigned __int8 *v6;
  unint64_t v7;

  while (1)
  {
    v6 = *(unsigned __int8 **)&a2[8 * ((a3 >> 5) & 4 | (a4 >> 6) & 0xFE | (a5 >> 7) & 1)];
    if (!v6)
    {
      v7 = 0;
      do
      {
        v6 = *(unsigned __int8 **)&a2[8 * v7];
        if (v7 > 6)
          break;
        ++v7;
      }
      while (!v6);
    }
    if (a6 == 8)
      break;
    a3 *= 2;
    a4 *= 2;
    ++a6;
    a2 = v6;
    a5 *= 2;
  }
  return *v6;
}

void ColorQuantization::freeColorNodes(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t i;
  void *v7;

  for (i = 0; i != 64; i += 8)
  {
    v7 = *(void **)(a2 + i);
    if (v7)
    {
      if (a3 <= 7)
      {
        ColorQuantization::freeColorNodes(a1);
        v7 = *(void **)(a2 + i);
      }
      free(v7);
    }
  }
}

unint64_t ColorQuantization::reduceColorMap(uint64_t a1, uint64_t a2, unint64_t a3, int a4)
{
  _BYTE *v4;
  unint64_t v5;
  unint64_t v6;

  if (a3)
  {
    v4 = (_BYTE *)(3 * a3 + *(_QWORD *)(a2 + 16) + 2);
    v5 = a3;
    do
    {
      if (*(v4 - 2))
        break;
      if (*(v4 - 1))
        break;
      if (*v4)
        break;
      v4 -= 3;
      --v5;
    }
    while (v5);
  }
  else
  {
    v5 = 0;
  }
  if (v5 + 1 < a3)
    v6 = v5 + 1;
  else
    v6 = a3;
  if (a4)
    return v6;
  else
    return a3;
}

unsigned __int8 *ColorQuantization::sortColorMap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  unsigned __int8 *result;
  __int16 v12;
  unsigned __int8 v13;
  unsigned __int8 v14;
  char v15;
  uint64_t v16;
  int v17;
  int v18;
  unsigned __int8 *v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  __int16 *v23;
  __int16 v24;
  char v25;
  int v26;
  int v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  unsigned __int8 *v31;
  unsigned int v32;
  unsigned int v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  unsigned int v37;
  unsigned int v38;
  unsigned __int8 *v39;
  __int16 *v40;
  __int16 v41;
  unsigned __int8 v42;
  unsigned __int8 v43;
  __int16 v44;

  while (1)
  {
    v5 = a5;
    v6 = a4;
    v7 = a3;
    v8 = a2;
    if ((_DWORD)a5 - (_DWORD)a4 == 1)
      break;
    v16 = a1;
    v17 = a5 + a4;
    if ((int)a5 + (int)a4 < 0 != __OFADD__((_DWORD)a5, (_DWORD)a4))
      ++v17;
    v18 = v17 >> 1;
    v19 = (unsigned __int8 *)(a2 + 3 * (v17 >> 1));
    v20 = *v19;
    v21 = v19[1];
    v22 = v19[2];
    v23 = (__int16 *)(a2 + 3 * (int)a4);
    v24 = *v23;
    v19[2] = *((_BYTE *)v23 + 2);
    *(_WORD *)v19 = v24;
    *(_BYTE *)v23 = v20;
    *((_BYTE *)v23 + 1) = v21;
    *((_BYTE *)v23 + 2) = v22;
    v25 = *(_BYTE *)(a3 + v18);
    *(_BYTE *)(a3 + v18) = *(_BYTE *)(a3 + (int)a4);
    *(_BYTE *)(a3 + (int)a4) = v25;
    v26 = a4 + 1;
    v27 = a5;
    while (1)
    {
      if (v26 <= v27)
      {
        v28 = v27;
        v29 = v27 + 1;
        v30 = v27 - (uint64_t)v26 + 1;
        v31 = (unsigned __int8 *)(v8 + 2 + 3 * v26);
        while (1)
        {
          v32 = *(v31 - 1);
          if (v32 > v21)
            break;
          if (v32 >= v21)
          {
            v33 = *(v31 - 2);
            if (v33 > v20 || v33 >= v20 && *v31 > v22)
              break;
          }
          ++v26;
          v31 += 3;
          if (!--v30)
          {
            v26 = v29;
            break;
          }
        }
      }
      else
      {
        v28 = v27;
      }
      v34 = 0;
      result = (unsigned __int8 *)(v8 + 1 + 3 * v28);
      v35 = -1;
      v36 = v7;
      while (1)
      {
        v37 = *result;
        if (v37 <= v21)
        {
          if (v37 < v21)
            break;
          v38 = *(result - 1);
          if (v38 <= v20 && (v38 < v20 || result[1] <= v22))
            break;
        }
        --v36;
        --v34;
        --v35;
        result -= 3;
      }
      v27 = v28 + v34;
      if (v26 >= (int)v28 + (int)v34)
        break;
      v39 = result - 1;
      v40 = (__int16 *)(v8 + 3 * v26);
      v41 = *v40;
      v42 = *((_BYTE *)v40 + 2);
      v43 = v39[2];
      *v40 = *(_WORD *)v39;
      *((_BYTE *)v40 + 2) = v43;
      *(_WORD *)v39 = v41;
      v39[2] = v42;
      LOBYTE(v39) = *(_BYTE *)(v7 + v26);
      *(_BYTE *)(v7 + v26) = *(_BYTE *)(v36 + v28);
      *(_BYTE *)(v36 + v28) = (_BYTE)v39;
    }
    v44 = *(_WORD *)(result - 1);
    *((_BYTE *)v23 + 2) = result[1];
    *v23 = v44;
    *(result - 1) = v20;
    *result = v21;
    result[1] = v22;
    *(_BYTE *)(v7 + (int)v6) = *(_BYTE *)(v36 + v28);
    *(_BYTE *)(v36 + v28) = v25;
    if ((int)v28 + v35 > (int)v6)
      result = (unsigned __int8 *)ColorQuantization::sortColorMap(v16, v8, v7, v6);
    a4 = v28 + v34 + 1;
    if ((int)a4 >= (int)v5)
      return result;
    a1 = v16;
    a2 = v8;
    a3 = v7;
    a5 = v5;
  }
  v9 = (unsigned __int8 *)(a2 + 3 * (int)a4);
  v10 = (unsigned __int8 *)(a2 + 3 * (int)a5);
  result = (unsigned __int8 *)RGBColorType::compare(v9, v10);
  if ((int)result >= 1)
  {
    v12 = *(_WORD *)v9;
    v13 = v9[2];
    v14 = v10[2];
    *(_WORD *)v9 = *(_WORD *)v10;
    v9[2] = v14;
    *(_WORD *)v10 = v12;
    v10[2] = v13;
    v15 = *(_BYTE *)(v7 + (int)v6);
    *(_BYTE *)(v7 + (int)v6) = *(_BYTE *)(v7 + (int)v5);
    *(_BYTE *)(v7 + (int)v5) = v15;
  }
  return result;
}

void ColorQuantization::quantizeBufferWithCustomColors(uint64_t a1, int a2, int a3, int a4, unsigned __int8 *a5, _BYTE *a6, unsigned __int8 *a7, _BYTE *a8, uint64_t a9)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned __int8 *v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  int i;
  unsigned int v23;
  unsigned int v24;
  unsigned __int8 v25;
  unsigned int v26;
  _OWORD v27[4];

  v15 = a1;
  memset(v27, 0, sizeof(v27));
  if (a4 >= 1)
  {
    v16 = 0;
    v17 = a4;
    v18 = (unsigned __int8 *)(a9 + 2);
    do
    {
      v19 = *(v18 - 2);
      v20 = *(v18 - 1);
      v21 = *v18;
      v18 += 3;
      ColorQuantization::addColorNode(a1, (uint64_t)v27, v16++, v19, v20, v21, 1);
    }
    while (v17 != v16);
  }
  for (i = a3 * a2; i; --i)
  {
    v24 = *a5++;
    v23 = v24;
    LOBYTE(v24) = *a6++;
    v25 = v24;
    v26 = *a7++;
    a1 = ColorQuantization::lookupColorNode(a1, (unsigned __int8 *)v27, v23, v25, v26, 1);
    *a8++ = a1;
  }
  ColorQuantization::freeColorNodes(v15, (uint64_t)v27, 1);
}

uint64_t ColorQuantization::generateFromRGBImageWu(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, _DWORD *a9)
{
  int v9;
  _BYTE *v10;
  _BYTE *v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  size_t v23;
  void *v24;
  void *v25;
  void *v26;
  _BYTE *v27;
  _QWORD *v28;
  double *v29;
  ColorQuantization *v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  int *v35;
  double v36;
  double v37;
  double v38;
  uint64_t v39;
  double v40;
  unsigned __int16 v41;
  uint64_t v42;
  unsigned __int8 *v43;
  uint64_t v44;
  int *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  double v49;
  uint64_t v50;
  int v51;
  int v52;
  _WORD *v53;
  unsigned __int16 v54;
  uint64_t v55;
  int v56;
  int v57;
  BOOL v58;
  _BYTE *v59;
  uint64_t v60;
  char *v61;
  char *v62;
  char *v63;
  char v64;
  char v65;
  char v66;
  int v67;
  _BYTE *v68;
  int i;
  char v70;
  uint64_t v71;
  unsigned __int8 *v72;
  _BYTE *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t j;
  uint64_t v77;
  int k;
  int m;
  uint64_t v81;
  uint64_t v82;
  int v83;
  uint64_t v84;
  int v85;
  int v86;
  uint64_t v87;
  unsigned int v88;
  void *v89;
  void *v90;
  void *v91;
  uint64_t v92;
  int v93;
  void *v94;
  void *v95;
  void *v96;
  void *v97;
  void *v98;
  void *v99;
  uint64_t v100;
  uint64_t v101;
  double v102[256];
  _OWORD v103[16];
  _OWORD v104[16];
  _OWORD v105[16];
  __int128 v106;
  uint64_t v107;
  _DWORD v108[1786];
  uint64_t v109;

  MEMORY[0x1E0C80A78](a1, a2);
  v11 = v10;
  v87 = v12;
  v14 = v13;
  v15 = v9;
  v17 = v16;
  v19 = v18;
  v109 = *MEMORY[0x1E0C80C00];
  v21 = v16[1];
  v20 = v16[2];
  v101 = 0;
  memset(v105, 0, sizeof(v105));
  memset(v104, 0, sizeof(v104));
  memset(v103, 0, sizeof(v103));
  if ((v9 - 1) > 3)
  {
    v82 = 0;
    v22 = 256;
  }
  else
  {
    v82 = qword_18820F060[v9 - 1];
    v22 = 255;
  }
  v88 = v22;
  LOWORD(v101) = v22;
  bzero(&v106, 0x1C00uLL);
  bzero(v102, 0x800uLL);
  v81 = *v17;
  v23 = (v21 * v20);
  v100 = v23;
  v94 = malloc_type_calloc(0x8C61uLL, 8uLL, 0x100004000313F17uLL);
  v24 = malloc_type_calloc(0x8C61uLL, 8uLL, 0x100004000313F17uLL);
  v95 = v24;
  v91 = malloc_type_calloc(0x8C61uLL, 8uLL, 0x100004000313F17uLL);
  v96 = v91;
  v90 = malloc_type_calloc(0x8C61uLL, 8uLL, 0x100004000313F17uLL);
  v97 = v90;
  v89 = malloc_type_calloc(0x8C61uLL, 8uLL, 0x100004000313F17uLL);
  v98 = v89;
  v25 = malloc_type_calloc(2uLL, v23, 0x676D6BE0uLL);
  v26 = v94;
  v99 = v25;
  if (!v94 || !v24 || !v91 || !v90 || !v89)
  {
LABEL_73:
    v77 = 1;
    if (!v26)
      goto LABEL_75;
    goto LABEL_74;
  }
  v27 = v25;
  if (v25)
  {
    v83 = v14;
    v84 = v19;
    v85 = v21;
    v86 = v20;
    v28 = v17;
    v29 = (double *)v94;
    v30 = (ColorQuantization *)ColorQuantization::hist3d((uint64_t)v25, (uint64_t *)v24, (uint64_t)v91, (uint64_t)v90, (uint64_t)v89, (uint64_t)v94, v28, v15, (uint64_t *)&v94);
    v92 = (uint64_t)v24;
    v31 = (uint64_t)ColorQuantization::m3d(v30, (uint64_t *)v24, (uint64_t *)v91, (uint64_t *)v90, (uint64_t *)v89, v29);
    v32 = 0;
    v106 = xmmword_18820EFA0;
    v107 = 0x2000000000;
    v33 = 1;
    while (1)
    {
      v34 = v32;
      v35 = (int *)&v106 + 7 * v32;
      v31 = ColorQuantization::cut(v31, v35, (_DWORD *)&v106 + 7 * v33, &v94);
      if ((_DWORD)v31)
      {
        v36 = 0.0;
        v37 = 0.0;
        if ((int)v108[7 * (int)v34] >= 2)
          v37 = ColorQuantization::variance(v31, v35, (uint64_t *)&v94);
        v102[v34] = v37;
        if ((int)v108[7 * v33] >= 2)
          v36 = ColorQuantization::variance(v31, (_DWORD *)&v106 + 7 * v33, (uint64_t *)&v94);
        v102[v33] = v36;
      }
      else
      {
        v102[v34] = 0.0;
        --v33;
      }
      v38 = v102[0];
      if (v33 < 1)
      {
        v32 = 0;
      }
      else
      {
        v39 = 0;
        v32 = 0;
        do
        {
          v40 = v102[++v39];
          if (v40 > v38)
          {
            v32 = v39;
            v38 = v40;
          }
        }
        while (v33 != v39);
      }
      if (v38 <= 0.0)
        break;
      if (++v33 >= v88)
      {
        v41 = v88;
        goto LABEL_29;
      }
    }
    v41 = v33 + 1;
    LOWORD(v101) = v33 + 1;
LABEL_29:
    free(v29);
    v94 = 0;
    v42 = (uint64_t)malloc_type_calloc(0x8C61uLL, 1uLL, 0x100004077774924uLL);
    if (!v42)
    {
      v77 = 0;
      goto LABEL_75;
    }
    v43 = (unsigned __int8 *)v42;
    v93 = v41;
    if (v41)
    {
      v44 = 0;
      v45 = (int *)&v106;
      do
      {
        ColorQuantization::mark(v42, v45, v44, (uint64_t)v43);
        v42 = ColorQuantization::vol(v46, v45, v92);
        v47 = v42;
        if (v42)
        {
          v48 = ColorQuantization::vol(v42, v45, (uint64_t)v91);
          v49 = (double)v47;
          LODWORD(v47) = (int)((double)v48 / (double)v47 + 0.5);
          v50 = ColorQuantization::vol(v48, v45, (uint64_t)v90);
          v51 = (int)((double)v50 / v49 + 0.5);
          v42 = ColorQuantization::vol(v50, v45, (uint64_t)v89);
          v52 = (int)((double)v42 / v49 + 0.5);
        }
        else
        {
          LOBYTE(v52) = 0;
          LOBYTE(v51) = 0;
        }
        *((_BYTE *)v103 + v44) = v52;
        *((_BYTE *)v104 + v44) = v51;
        *((_BYTE *)v105 + v44++) = v47;
        v45 += 7;
      }
      while (v41 != v44);
    }
    if (v23)
    {
      v53 = v27;
      do
      {
        *v53 = v43[(unsigned __int16)*v53];
        ++v53;
        --v23;
      }
      while (v23);
    }
    *a9 = 0;
    v54 = v41;
    if (v83)
    {
      *a9 = v41;
      v54 = v41 + 1;
      LOWORD(v101) = v41 + 1;
      v55 = 3 * (unsigned __int16)(v41 + 1) + *(_QWORD *)(v87 + 16);
      *(_WORD *)(v55 - 3) = 0;
      *(_BYTE *)(v55 - 1) = 0;
    }
    v56 = 1;
    v57 = v54 - 1;
    if (v54 != 1)
    {
      v56 = 0;
      do
      {
        ++v56;
        v58 = v57 > 1;
        v57 >>= 1;
      }
      while (v58);
    }
    *(_DWORD *)v87 = 1 << v56;
    *(_DWORD *)(v87 + 4) = v56;
    if (v41)
    {
      v59 = *(_BYTE **)(v87 + 16);
      v60 = v41;
      v61 = (char *)v103;
      v62 = (char *)v104;
      v63 = (char *)v105;
      do
      {
        v64 = *v63++;
        *v59 = v64;
        v65 = *v62++;
        v59[1] = v65;
        v66 = *v61++;
        v59[2] = v66;
        v59 += 3;
        --v60;
      }
      while (v60);
    }
    if (v85)
    {
      v67 = 0;
      v68 = v11;
      do
      {
        for (i = v86; i; --i)
        {
          v70 = *v27;
          v27 += 2;
          *v68++ = v70;
        }
        ++v67;
      }
      while (v67 != v85);
    }
    if ((v83 & 1) != 0)
    {
      v71 = v100;
      if (v100 >= 1)
      {
        v72 = (unsigned __int8 *)(v81 + v82);
        v73 = v11;
        do
        {
          if (*v72 <= 0x3Fu)
            *v73 = *a9;
          ++v73;
          v72 += 4;
          --v71;
        }
        while (v71);
      }
    }
    v74 = (unsigned __int16)v101;
    if ((_WORD)v101)
    {
      v75 = 0;
      do
      {
        *((_BYTE *)v105 + v75) = v75;
        ++v75;
      }
      while (v74 != v75);
      ColorQuantization::sortColorMap(v84, *(_QWORD *)(v87 + 16), (uint64_t)v105, 0, (v93 - 1));
      if ((_DWORD)v74)
      {
        for (j = 0; j != v74; ++j)
          *((_BYTE *)v104 + *((unsigned __int8 *)v105 + j)) = j;
      }
      if (!v85)
        goto LABEL_72;
    }
    else
    {
      ColorQuantization::sortColorMap(v84, *(_QWORD *)(v87 + 16), (uint64_t)v105, 0, (v93 - 1));
      if (!v85)
      {
LABEL_72:
        free(v43);
        v26 = v94;
        goto LABEL_73;
      }
    }
    for (k = 0; k != v85; ++k)
    {
      for (m = v86; m; --m)
      {
        *v11 = *((_BYTE *)v104 + *v11);
        ++v11;
      }
    }
    goto LABEL_72;
  }
  v77 = 0;
LABEL_74:
  free(v26);
LABEL_75:
  if (v95)
    free(v95);
  if (v96)
    free(v96);
  if (v97)
    free(v97);
  if (v98)
    free(v98);
  if (v99)
    free(v99);
  return v77;
}

BOOL ColorQuantization::generateFromIndexedImage(int a1, uint64_t a2, CGImage *a3, int a4, int a5, int a6, CGColorSpaceRef space, uint64_t a8, _BYTE *a9, _DWORD *a10)
{
  int v14;
  uint64_t v15;
  CGColorSpace *BaseColorSpace;
  CGColorSpaceModel Model;
  size_t v18;
  size_t ColorTableCount;
  uint8_t *v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint8_t *v25;
  uint64_t v26;
  _BYTE *v27;
  uint8_t *v28;
  uint8_t *v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v35;
  int v36;
  BOOL v37;
  unsigned int BytesPerRow;
  unsigned __int8 *v39;
  uint64_t v40;
  char v41;
  int v42;
  unsigned __int8 *v43;
  uint64_t i;
  int v45;
  char *j;
  char v47;

  if (a4 == 8)
  {
    v14 = *(_DWORD *)(a2 + 16);
    v15 = *(unsigned int *)(a2 + 8);
    BaseColorSpace = CGColorSpaceGetBaseColorSpace(space);
    Model = CGColorSpaceGetModel(BaseColorSpace);
    if (Model == kCGColorSpaceModelRGB)
      v18 = 3;
    else
      v18 = 1;
    ColorTableCount = CGColorSpaceGetColorTableCount(space);
    v20 = (uint8_t *)malloc_type_calloc(ColorTableCount, v18, 0xB1976154uLL);
    CGColorSpaceGetColorTable(space, v20);
    v21 = 256;
    if (ColorTableCount < 0x100)
      v21 = ColorTableCount;
    if (((v21 > 0xFF) & a6) != 0)
      v22 = 255;
    else
      v22 = v21;
    if (v22)
    {
      v23 = 0;
      v24 = 0;
      v25 = v20;
      do
      {
        v26 = *(_QWORD *)(a8 + 16);
        if (Model == kCGColorSpaceModelRGB)
        {
          v27 = (_BYTE *)(v26 + v23);
          *v27 = v20[v23];
          v27[1] = v20[v23 + 1];
          v28 = &v20[3 * v24 + 2];
        }
        else
        {
          v29 = (uint8_t *)(v26 + v23);
          *v29 = *v25;
          v29[1] = *v25;
          v28 = v25;
        }
        *(_BYTE *)(v26 + v23 + 2) = *v28;
        ++v24;
        v23 += 3;
        ++v25;
      }
      while (3 * v22 != v23);
    }
    free(v20);
    v31 = ColorQuantization::reduceColorMap(v30, a8, v22, a6);
    *a10 = 0;
    if ((a6 & 1) != 0)
    {
      *a10 = v31;
      v32 = 3 * v31;
      LODWORD(v31) = v31 + 1;
      v33 = *(_QWORD *)(a8 + 16) + v32;
      *(_WORD *)v33 = 0;
      *(_BYTE *)(v33 + 2) = 0;
    }
    v35 = 1;
    v36 = v31 - 1;
    if ((_DWORD)v31 != 1)
    {
      v35 = 0;
      do
      {
        ++v35;
        v37 = v36 > 1;
        v36 >>= 1;
      }
      while (v37);
    }
    *(_DWORD *)a8 = 1 << v35;
    *(_DWORD *)(a8 + 4) = v35;
    CGImageGetDataProvider(a3);
    BytesPerRow = CGImageGetBytesPerRow(a3);
    v39 = (unsigned __int8 *)malloc_type_malloc(BytesPerRow, 0x4C6ED555uLL);
    if ((a6 & 1) != 0)
    {
      if (v15)
      {
        v40 = 0;
        v41 = 0;
        while (1)
        {
          CGDataProviderGetBytesAtPosition();
          v42 = v14;
          v43 = v39;
          if (v14)
            break;
LABEL_32:
          putchar(10);
          if (++v40 == v15)
            goto LABEL_39;
        }
        while (1)
        {
          *a9++ = *v43;
          if ((v41 & 1) == 0)
          {
            if ((char)v43[1] < 0)
            {
              v41 = 0;
              goto LABEL_29;
            }
            *a10 = *v43;
          }
          v41 = 1;
LABEL_29:
          v43 += 2;
          if (!--v42)
            goto LABEL_32;
        }
      }
    }
    else if (v15)
    {
      for (i = 0; i != v15; ++i)
      {
        CGDataProviderGetBytesAtPosition();
        v45 = v14;
        for (j = (char *)v39; v45; --v45)
        {
          v47 = *j++;
          *a9++ = v47;
        }
      }
    }
LABEL_39:
    free(v39);
    a4 = 8;
  }
  return a4 == 8;
}

uint64_t ColorQuantization::generateFromGrayImage(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, uint64_t a6, uint64_t a7, _BYTE *a8, _DWORD *a9)
{
  int v15;
  size_t v16;
  void *v17;
  const char *v18;
  uint64_t IIOBitStream;
  uint64_t v20;
  unsigned int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  BOOL v26;
  const char *v27;
  uint64_t v28;
  int v29;
  int v30;
  BOOL v31;
  int v32;
  uint64_t i;
  uint64_t v34;
  unsigned int v35;
  _BYTE *v36;
  int v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  int v42;
  _DWORD *v43;
  int v44;
  int v45;
  uint64_t v47;
  void *v48;
  int v49;
  int v50;
  int v51;
  uint64_t v52;
  _DWORD v53[255];
  int v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v15 = *(_DWORD *)(a2 + 16);
  v50 = *(_DWORD *)(a2 + 8);
  v16 = *(unsigned int *)(a2 + 24);
  bzero(v53, 0x400uLL);
  v17 = malloc_type_malloc(v16, 0xFB889D1DuLL);
  if (!v17)
    return 0;
  v48 = v17;
  IIOBitStream = IIOBitStream::CreateIIOBitStream(*(IIOBitStream **)a2, (void *)(*(_QWORD *)(a2 + 24) * *(_QWORD *)(a2 + 8)), "r", v18);
  if (IIOBitStream)
  {
    v20 = IIOBitStream;
    v47 = a2;
    v21 = (a4 < 7) & (0x54u >> a4);
    if (v50)
    {
      v22 = 0;
      while (1)
      {
        v51 = v22;
        if (v15)
          break;
LABEL_20:
        v22 = v51 + 1;
        if (v51 + 1 == v50)
          goto LABEL_21;
      }
      v23 = 0;
      while (1)
      {
        v52 = 0;
        if (v21)
        {
          if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t *))(*(_QWORD *)v20 + 24))(v20, a3, &v52))
            break;
        }
        if ((*(unsigned int (**)(uint64_t, uint64_t, char *))(*(_QWORD *)v20 + 24))(v20, a3, (char *)&v52 + 4)|| a4 <= 5&& ((1 << a4) & 0x2A) != 0&& (*(unsigned int (**)(uint64_t, uint64_t, uint64_t *))(*(_QWORD *)v20 + 24))(v20, a3, &v52))
        {
          break;
        }
        if (!a5 || v52 >= (1 << (a3 - 1)))
        {
          v24 = BYTE4(v52);
          if (a3 <= 7)
          {
            v25 = a3;
            do
            {
              v24 |= (v24 << v25);
              v26 = v25 < 4;
              v25 *= 2;
            }
            while (v26);
          }
          ++v53[v24];
        }
        if (++v23 == v15)
          goto LABEL_20;
      }
LABEL_66:
      v40 = 0;
LABEL_67:
      (*(void (**)(uint64_t))(*(_QWORD *)v20 + 8))(v20);
      goto LABEL_68;
    }
LABEL_21:
    (*(void (**)(uint64_t))(*(_QWORD *)v20 + 8))(v20);
    v28 = 0;
    v29 = 0;
    do
    {
      v30 = v53[v28];
      v31 = v30 == 0;
      if (v30)
        v32 = v29;
      else
        v32 = -1;
      if (!v31)
        ++v29;
      v53[v28++] = v32;
    }
    while (v28 != 256);
    if (a5 && v29 == 256)
    {
      for (i = 1; i != 256; ++i)
        --v53[i];
      v54 = -1;
      v29 = 255;
    }
    v34 = 0;
    v35 = 0;
    do
    {
      if ((v53[v34] & 0x80000000) == 0)
      {
        v36 = (_BYTE *)(*(_QWORD *)(a7 + 16) + 3 * v35);
        *v36 = v34;
        v36[1] = v34;
        v36[2] = v34;
        ++v35;
      }
      ++v34;
    }
    while (v34 != 256);
    if (v35 + 1 <= 0xFF)
      bzero((void *)(*(_QWORD *)(a7 + 16) + 3 * (v35 + 1)), 3 * (254 - v35) + 3);
    *a9 = 0;
    if (a5)
      *a9 = v29++;
    v37 = 1;
    v38 = v29 - 1;
    if (v29 != 1)
    {
      v37 = 0;
      do
      {
        ++v37;
        v26 = v38 > 1;
        v38 >>= 1;
      }
      while (v26);
    }
    *(_DWORD *)a7 = 1 << v37;
    *(_DWORD *)(a7 + 4) = v37;
    v39 = IIOBitStream::CreateIIOBitStream(*(IIOBitStream **)v47, (void *)(*(_QWORD *)(v47 + 24) * *(_QWORD *)(v47 + 8)), "r", v27);
    if (v39)
    {
      v20 = v39;
      v40 = 1;
      if (!v50)
        goto LABEL_67;
      v41 = 0;
      while (1)
      {
        v49 = v41;
        if (v15)
          break;
LABEL_64:
        v41 = v49 + 1;
        if (v49 + 1 == v50)
        {
          v40 = 1;
          goto LABEL_67;
        }
      }
      v42 = 0;
      while (1)
      {
        v52 = 0;
        if (v21 && (*(unsigned int (**)(uint64_t, uint64_t, uint64_t *))(*(_QWORD *)v20 + 24))(v20, a3, &v52)
          || (*(unsigned int (**)(uint64_t, uint64_t, char *))(*(_QWORD *)v20 + 24))(v20, a3, (char *)&v52 + 4)|| a4 <= 5&& ((1 << a4) & 0x2A) != 0&& (*(unsigned int (**)(uint64_t, uint64_t, uint64_t *))(*(_QWORD *)v20 + 24))(v20, a3, &v52))
        {
          goto LABEL_66;
        }
        if (!a5)
          break;
        v43 = a9;
        if (v52 >= (1 << (a3 - 1)))
          break;
LABEL_63:
        *a8++ = *v43;
        if (++v42 == v15)
          goto LABEL_64;
      }
      v44 = HIDWORD(v52);
      if ((_DWORD)a3 == 1)
      {
        v44 = 1 - HIDWORD(v52);
      }
      else if (a3 > 7)
      {
LABEL_62:
        v43 = &v53[v44];
        goto LABEL_63;
      }
      v45 = a3;
      do
      {
        v44 |= v44 << v45;
        v26 = v45 < 4;
        v45 *= 2;
      }
      while (v26);
      goto LABEL_62;
    }
  }
  v40 = 0;
LABEL_68:
  free(v48);
  return v40;
}

uint64_t ColorQuantization::generateFromRGBImage(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, uint64_t a6, uint64_t a7, _BYTE *a8, int *a9)
{
  size_t v13;
  size_t v14;
  unsigned __int8 *v15;
  _BYTE *v16;
  unsigned __int8 *v17;
  _BYTE *v18;
  uint64_t IIOBitStream;
  char v20;
  BOOL v21;
  BOOL v22;
  const char *v23;
  void *v24;
  int v25;
  unsigned int v26;
  BOOL *v27;
  unsigned __int8 *v28;
  unsigned __int8 *v29;
  int v30;
  unsigned int v31;
  int v32;
  int v33;
  BOOL v34;
  int v35;
  int v36;
  int v37;
  int v38;
  _BYTE *v39;
  int v40;
  int v41;
  int v42;
  uint64_t v43;
  int v44;
  int v45;
  int v46;
  _BYTE *v47;
  int v48;
  unsigned __int8 *v52;
  unsigned __int8 *v53;
  _BYTE *v54;
  _BYTE *v55;
  void *v56;
  unsigned int v57;
  int v58;
  unsigned int v59;
  int v60;
  int v61;
  unsigned int v62;
  uint64_t v63;

  v13 = *(unsigned int *)(a2 + 24);
  v57 = *(_DWORD *)(a2 + 8);
  v59 = *(_DWORD *)(a2 + 16);
  v14 = v57 * v59;
  v15 = (unsigned __int8 *)malloc_type_malloc(v14, 0x9A53FCA6uLL);
  v16 = malloc_type_malloc(v14, 0x3BBEF6C6uLL);
  v17 = (unsigned __int8 *)malloc_type_malloc(v14, 0x780AB5A3uLL);
  if (a5)
    v18 = malloc_type_malloc(v14, 0x837D53F4uLL);
  else
    v18 = 0;
  IIOBitStream = 0;
  v56 = 0;
  if (v18)
    v20 = 0;
  else
    v20 = a5;
  if (v15)
    v21 = v16 == 0;
  else
    v21 = 1;
  v22 = v21 || v17 == 0;
  if (v22 || (v20 & 1) != 0)
    goto LABEL_71;
  v55 = v18;
  v24 = malloc_type_malloc(v13, 0x373E776uLL);
  if (v24)
  {
    IIOBitStream = IIOBitStream::CreateIIOBitStream(*(IIOBitStream **)a2, (void *)(*(_QWORD *)(a2 + 24) * *(_QWORD *)(a2 + 8)), "r", v23);
    if (IIOBitStream)
    {
      v56 = v24;
      v52 = v15;
      v53 = v17;
      v54 = v16;
      if (v57)
      {
        v25 = 0;
        v26 = (1 << (a3 - 1));
        v27 = v18;
        v29 = v52;
        v28 = v53;
        while (1)
        {
          v58 = v25;
          if (v59)
            break;
LABEL_45:
          v25 = v58 + 1;
          if (v58 + 1 == v57)
            goto LABEL_46;
        }
        v30 = 0;
        while (1)
        {
          v60 = 0;
          v63 = 0;
          v62 = 255;
          if (a4 <= 6
            && ((1 << a4) & 0x54) != 0
            && (*(unsigned int (**)(uint64_t, uint64_t, unsigned int *))(*(_QWORD *)IIOBitStream + 24))(IIOBitStream, a3, &v62))
          {
            break;
          }
          if ((*(unsigned int (**)(uint64_t, uint64_t, int *))(*(_QWORD *)IIOBitStream + 24))(IIOBitStream, a3, &v60)|| (*(unsigned int (**)(uint64_t, uint64_t, char *))(*(_QWORD *)IIOBitStream + 24))(IIOBitStream, a3, (char *)&v63 + 4)|| (*(unsigned int (**)(uint64_t, uint64_t, uint64_t *))(*(_QWORD *)IIOBitStream + 24))(IIOBitStream, a3, &v63)|| ((a4 < 6) & a4) != 0&& (*(unsigned int (**)(uint64_t, uint64_t, unsigned int *))(*(_QWORD *)IIOBitStream + 24))(IIOBitStream, a3, &v62))
          {
            break;
          }
          v31 = v62;
          if (a5 && v62 < v26)
          {
            LOBYTE(v32) = 0;
            v60 = 0;
            v63 = 0;
          }
          else
          {
            LOBYTE(v32) = v60;
          }
          v32 = v32;
          if (a3 > 7)
          {
            HIDWORD(v63) = BYTE4(v63);
            v37 = v63;
          }
          else
          {
            v33 = a3;
            do
            {
              v32 |= (v32 << v33);
              v34 = v33 < 4;
              v33 *= 2;
            }
            while (v34);
            v35 = BYTE4(v63);
            v36 = a3;
            do
            {
              v35 |= (v35 << v36);
              v34 = v36 < 4;
              v36 *= 2;
            }
            while (v34);
            HIDWORD(v63) = v35;
            v37 = v63;
            v38 = a3;
            do
            {
              v37 |= (v37 << v38);
              v34 = v38 < 4;
              v38 *= 2;
            }
            while (v34);
          }
          LODWORD(v63) = v37;
          *v29++ = v32;
          *v16++ = BYTE4(v63);
          *v28++ = v63;
          if (a5)
            *v27++ = v31 >= v26;
          if (++v30 == v59)
            goto LABEL_45;
        }
        (*(void (**)(uint64_t))(*(_QWORD *)IIOBitStream + 8))(IIOBitStream);
        IIOBitStream = 0;
        v17 = v53;
        v16 = v54;
        v15 = v52;
        v18 = v55;
      }
      else
      {
LABEL_46:
        (*(void (**)(uint64_t))(*(_QWORD *)IIOBitStream + 8))(IIOBitStream);
        v39 = a8;
        if (*(int *)a7 < 1)
        {
          v41 = 1 << a3;
          if ((((_DWORD)a3 == 8) & a5) != 0)
            v41 = 255;
          v61 = v41;
          v15 = v52;
          v17 = v53;
          v16 = v54;
          v18 = v55;
          if (_cg_GifQuantizeBuffer(v59, v57) != 1)
          {
            IIOBitStream = 0;
            goto LABEL_71;
          }
        }
        else
        {
          if (((*(_DWORD *)a7 == 256) & a5) != 0)
            v40 = 255;
          else
            v40 = *(_DWORD *)a7;
          v61 = v40;
          v15 = v52;
          v17 = v53;
          v16 = v54;
          ColorQuantization::quantizeBufferWithCustomColors((uint64_t)&v60, v59, v57, v40, v52, v54, v53, a8, *(_QWORD *)(a7 + 16));
          v18 = v55;
        }
        *a9 = 0;
        v42 = v61;
        if (a5)
        {
          *a9 = v61;
          v61 = v42 + 1;
          v43 = *(_QWORD *)(a7 + 16) + 3 * v42;
          *(_BYTE *)(v43 + 2) = 0;
          *(_WORD *)v43 = 0;
          IIOBitStream = 1;
          if (v42)
          {
            v44 = 0;
            do
            {
              ++v44;
              v34 = v42 > 1;
              v42 >>= 1;
            }
            while (v34);
          }
          else
          {
            v44 = 1;
          }
          *(_DWORD *)a7 = 1 << v44;
          *(_DWORD *)(a7 + 4) = v44;
          if (v57 * v59)
          {
            v47 = v18;
            v48 = v57 * v59;
            do
            {
              if (!*v47)
                *v39 = *a9;
              ++v39;
              ++v47;
              --v48;
            }
            while (v48);
            IIOBitStream = 1;
          }
        }
        else
        {
          IIOBitStream = 1;
          v45 = 1;
          v46 = v61 - 1;
          if (v61 != 1)
          {
            v45 = 0;
            do
            {
              ++v45;
              v34 = v46 > 1;
              v46 >>= 1;
            }
            while (v34);
          }
          *(_DWORD *)a7 = 1 << v45;
          *(_DWORD *)(a7 + 4) = v45;
        }
      }
LABEL_71:
      v24 = v56;
      if (!v15)
        goto LABEL_73;
    }
  }
  else
  {
    IIOBitStream = 0;
  }
  free(v15);
LABEL_73:
  if (v16)
    free(v16);
  if (v17)
    free(v17);
  if (v18)
    free(v18);
  if (v24)
    free(v24);
  return IIOBitStream;
}

void *_TIFFcalloc(size_t a1, size_t a2)
{
  if (a1 && a2)
    return malloc_type_calloc(a1, a2, 0xF58AE365uLL);
  else
    return 0;
}

size_t unixWarningHandler(const char *a1, const char *a2, va_list a3)
{
  FILE **v5;

  v5 = (FILE **)MEMORY[0x1E0C80C10];
  if (a1)
    fprintf((FILE *)*MEMORY[0x1E0C80C10], "%s: ", a1);
  fwrite("Warning, ", 9uLL, 1uLL, *v5);
  vfprintf(*v5, a2, a3);
  return fwrite(".\n", 2uLL, 1uLL, *v5);
}

size_t unixErrorHandler(const char *a1, char *a2, va_list a3)
{
  FILE **v5;

  v5 = (FILE **)MEMORY[0x1E0C80C10];
  if (a1)
    fprintf((FILE *)*MEMORY[0x1E0C80C10], "%s: ", a1);
  vfprintf(*v5, a2, a3);
  return fwrite(".\n", 2uLL, 1uLL, *v5);
}

uint64_t IIO_Reader_MPO::createReadPlugin(IIO_Reader *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;

  v4 = operator new();
  v5 = IIO_Reader::osType(a1);
  MPOReadPlugin::MPOReadPlugin(v4, a2, v5);
  return v4;
}

void sub_187F909E8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40A4B8139ELL);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_MPO::createReadPlugin(IIO_Reader *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8;
  int v9;

  v8 = operator new();
  v9 = IIO_Reader::osType(a1);
  MPOReadPlugin::MPOReadPlugin(v8, a2, a3, a4, v9);
  return v8;
}

void sub_187F90A84(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40A4B8139ELL);
  _Unwind_Resume(a1);
}

IIOImageRead *IIO_Reader_MPO::createGlobalInfoData(IIO_Reader_MPO *this, IIOImageReadSession *a2)
{
  IIOImageRead *result;

  result = IIOImageReadSession::globalInfoForType(a2, *((_DWORD *)this + 6));
  if (result)
    return (IIOImageRead *)GlobalMPOInfo::createDataRepresentation(result);
  return result;
}

uint64_t IIO_Reader_MPO::updateGlobalInfo(IIO_Reader_MPO *this, IIOImageRead **a2, unsigned __int8 *a3, unint64_t a4)
{
  GlobalMPOInfo *v8;

  v8 = (GlobalMPOInfo *)operator new();
  GlobalMPOInfo::GlobalMPOInfo(v8, a3, a4);
  IIOImageReadSession::setGlobalInfo(a2, *((_DWORD *)this + 6), v8, (void (*)(void *))globalMPOInfoReleaseProc);
  return 0;
}

void sub_187F90B50(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C4078B77C84);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_MPO::updateSourceProperties(IIO_Reader_MPO *this, IIOImageReadSession *a2, IIODictionary *a3, IIODictionary *a4, IIODictionary *a5, CGImageSourceStatus *a6)
{
  IIOImageRead *v8;
  int EntryCount;
  _BYTE v11[16];
  void *v12;

  v8 = IIOImageReadSession::globalInfoForType(a2, *((_DWORD *)this + 6));
  if (!v8)
  {
    v8 = (IIOImageRead *)ExamineMPOFile(a2);
    if (!v8)
      return 4294967246;
  }
  IIONumber::IIONumber((IIONumber *)v11, 1);
  IIODictionary::setObjectForKeyGroup(a3, v12, CFSTR("MPFormatVersion"), CFSTR("{MPO}"));
  IIONumber::~IIONumber((IIONumber *)v11);
  EntryCount = GlobalMPOInfo::getEntryCount(v8);
  IIONumber::IIONumber((IIONumber *)v11, EntryCount);
  IIODictionary::setObjectForKeyGroup(a3, v12, CFSTR("MPNumberOfImages"), CFSTR("{MPO}"));
  IIONumber::~IIONumber((IIONumber *)v11);
  return 0;
}

void sub_187F90C40(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_MPO::getImageCount(IIO_Reader_MPO *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  IIOImageRead *v7;
  uint64_t v8;

  v7 = IIOImageReadSession::globalInfoForType(a2, *((_DWORD *)this + 6));
  if (!v7)
  {
    v7 = (IIOImageRead *)ExamineMPOFile(a2);
    if (!v7)
    {
      v8 = 4294967244;
      if (!a5)
        return v8;
      goto LABEL_4;
    }
  }
  LODWORD(v7) = GlobalMPOInfo::getEntryCount(v7);
  v8 = 0;
  if (a5)
LABEL_4:
    *a5 = v7;
  return v8;
}

BOOL IIO_Reader_MPO::compareOptions(IIO_Reader_MPO *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  unsigned int Uint32ForKey;
  unsigned int v5;
  int v6;
  int v7;
  _BOOL8 v8;
  _QWORD v10[3];
  _QWORD v11[3];

  memset(v11, 0, sizeof(v11));
  IIODictionary::IIODictionary((IIODictionary *)v11, a2);
  memset(v10, 0, sizeof(v10));
  IIODictionary::IIODictionary((IIODictionary *)v10, a3);
  Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v11, CFSTR("kCGImageSourceSubsampleFactor"));
  v5 = IIODictionary::getUint32ForKey((IIODictionary *)v10, CFSTR("kCGImageSourceSubsampleFactor"));
  if (Uint32ForKey <= 1)
    v6 = 1;
  else
    v6 = Uint32ForKey;
  if (v5 <= 1)
    v7 = 1;
  else
    v7 = v5;
  v8 = v6 == v7;
  IIODictionary::~IIODictionary((IIODictionary *)v10);
  IIODictionary::~IIODictionary((IIODictionary *)v11);
  return v8;
}

void sub_187F90D50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  IIODictionary::~IIODictionary((IIODictionary *)&a9);
  IIODictionary::~IIODictionary((IIODictionary *)&a12);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_MPO::initThumbnail(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t Session;
  IIOImageReadSession *Source;
  IIOImageRead *v10;
  GlobalMPOInfo *v11;
  _MPEntry *EntryAtIndex;
  _MPEntry *v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  IIOImageRead *v17;
  unsigned __int8 *v18;
  uint64_t result;
  _JPEGFile *v20;
  uint64_t AppMarker;
  _TAGList *v22;
  _TAGList *v23;
  uint64_t TagByID;
  uint64_t v25;
  uint64_t v26;
  void *v27;

  Session = CGImagePluginGetSession(a2);
  Source = (IIOImageReadSession *)CGImageSourceGetSource(Session);
  v10 = IIOImageReadSession::globalInfoForType(Source, *(_DWORD *)(a1 + 24));
  if (!v10)
    return 4294967245;
  v11 = v10;
  if (GlobalMPOInfo::getEntryCount(v10) <= a3)
    return 4294967245;
  EntryAtIndex = (_MPEntry *)GlobalMPOInfo::getEntryAtIndex(v11, a3);
  if (!EntryAtIndex)
    return 4294967245;
  v13 = EntryAtIndex;
  v14 = _MPEntry::imageSize(EntryAtIndex);
  v15 = _MPEntry::imageOffset(v13);
  v16 = v15 ? IIOImageSource::cf(v11) + v15 : 0;
  v27 = 0;
  v17 = IIOImageReadSession::retainBytePointer(Source, (const __CFData **)&v27, 1);
  if (!v17)
    return 4294967245;
  v18 = (unsigned __int8 *)v17 + v16;
  if ((IIOImageRead *)((unint64_t)v17 + v16 + v14) > (IIOImageRead *)((char *)IIOImageReadSession::getSize(Source)
                                                                            + (_QWORD)v17))
  {
    if (v27)
      IIOImageReadSession::releaseBytePointer((IIOImageRead **)Source, v27);
    return 4294967245;
  }
  v20 = (_JPEGFile *)operator new();
  _JPEGFile::_JPEGFile(v20, v18, v14, 0, 0);
  (*(void (**)(_JPEGFile *))(*(_QWORD *)v20 + 16))(v20);
  AppMarker = _JPEGFile::findAppMarker(v20, 65505);
  if (AppMarker)
  {
    v22 = (_TAGList *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)AppMarker + 48))(AppMarker);
    v23 = v22;
    if (v22)
    {
      TagByID = _TAGList::findTagByID(v22, 513);
      v25 = _TAGList::findTagByID(v23, 514);
      v23 = (_TAGList *)(v16 + (*(unsigned int (**)(uint64_t))(*(_QWORD *)TagByID + 64))(TagByID) + 12);
      v26 = (*(unsigned int (**)(uint64_t))(*(_QWORD *)v25 + 64))(v25);
    }
    else
    {
      v26 = 0;
    }
  }
  else
  {
    v26 = 0;
    v23 = 0;
  }
  (*(void (**)(_JPEGFile *))(*(_QWORD *)v20 + 8))(v20);
  if (v27)
    IIOImageReadSession::releaseBytePointer((IIOImageRead **)Source, v27);
  result = 4294967245;
  if (v23 && v26)
  {
    if (IIO_XPCServer())
    {
      ImageIOLog("*********************************************************************\n");
      ImageIOLog("**** __FIXME__ -- swapping the IIOReadPlugin\n");
      ImageIOLog("*********************************************************************\n");
    }
    return CGImagePluginInitJPEGAtOffset(a2, a3, (uint64_t)v23, v26, 1, a4, 1297108768, 0);
  }
  return result;
}

void sub_187F90FD0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x1091C40E2C72B4ELL);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_MPO::hasCustomImageCountProc(IIO_Reader_MPO *this)
{
  return 1;
}

uint64_t IIO_Reader_MPO::hasCustomCompareOptionsProc(IIO_Reader_MPO *this)
{
  return 1;
}

uint64_t IIO_Reader_MPO::hasCustomSourcePropertiesProc(IIO_Reader_MPO *this)
{
  return 1;
}

uint64_t IIO_Reader_MPO::hasCustomThumbnailProc(IIO_Reader_MPO *this)
{
  return 1;
}

void add_points_to_path(CGPath *a1, const CGPoint *a2, unint64_t a3, int a4)
{
  uint64_t v8;
  double *p_y;
  uint64_t v10;
  unint64_t v11;

  if (a3)
  {
    CGPathMoveToPoint(a1, 0, a2[1].x, 1.0 - a2[1].y);
    if (a3 >= 3)
    {
      v8 = 0;
      p_y = &a2[2].y;
      do
      {
        if (a3 - 3 == v8)
          v10 = 0;
        else
          v10 = v8 + 3;
        CGPathAddCurveToPoint(a1, 0, *(p_y - 1), 1.0 - *p_y, a2[v10].x, 1.0 - a2[v10].y, a2[(v8 + 4) % a3].x, 1.0 - a2[(v8 + 4) % a3].y);
        v11 = v8 + 5;
        p_y += 6;
        v8 += 3;
      }
      while (v11 < a3);
    }
    if (a4)
      CGPathCloseSubpath(a1);
  }
}

double read_point(unsigned __int8 *a1, unint64_t *a2)
{
  double result;

  result = (float)((float)(int)bswap32(*(_DWORD *)&a1[*a2 + 4]) * 0.000000059605);
  *a2 += 8;
  return result;
}

_QWORD *KTXReadPlugin::KTXReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  _QWORD *result;

  result = (_QWORD *)IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *result = &off_1E1BAD2D8;
  return result;
}

_QWORD *KTXReadPlugin::KTXReadPlugin(uint64_t a1, uint64_t a2, int a3)
{
  _QWORD *result;

  result = (_QWORD *)IIOReadPlugin::IIOReadPlugin(a1, a2, a3);
  *result = &off_1E1BAD2D8;
  return result;
}

void KTXReadPlugin::~KTXReadPlugin(KTXReadPlugin *this)
{
  IIOReadPlugin::~IIOReadPlugin(this);
  JUMPOUT(0x18D761C30);
}

uint64_t KTXReadPlugin::loadDataFromXPCObject(KTXReadPlugin *this, void *a2)
{
  uint64_t result;
  _OWORD *data;
  _OWORD *v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  size_t length;

  result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!(_DWORD)result)
  {
    length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_ktx", &length);
    if (length == 80)
    {
      v6 = data;
      result = 0;
      *(_OWORD *)((char *)this + 440) = *v6;
      v7 = v6[1];
      v8 = v6[2];
      v9 = v6[4];
      *(_OWORD *)((char *)this + 488) = v6[3];
      *(_OWORD *)((char *)this + 504) = v9;
      *(_OWORD *)((char *)this + 456) = v7;
      *(_OWORD *)((char *)this + 472) = v8;
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t KTXReadPlugin::saveDataToXPCObject(KTXReadPlugin *this, void *a2)
{
  uint64_t v4;

  v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!(_DWORD)v4)
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_ktx", (char *)this + 440, 0x50uLL);
  return v4;
}

uint64_t KTXReadPlugin::initialize(KTXReadPlugin *this, IIODictionary *a2)
{
  char v3;
  unsigned int v4;
  IIODictionary *v5;
  int v6;
  unsigned int Uint32ForKey;
  double v8;
  unsigned int v9;
  __int16 v10;
  uint64_t v11;
  unsigned int v12;
  CFStringRef *v13;
  const char *v14;
  uint64_t v15;
  CFStringRef *v16;
  unsigned int v17;
  uint64_t v18;
  unsigned int v19;
  __int128 v20;
  __int128 v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v26;
  uint64_t v27;
  unsigned int Size;
  _OWORD v29[4];
  uint64_t v30;
  int8x16_t __dst;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v33 = 0u;
  v34 = 0u;
  __dst = 0u;
  v32 = 0u;
  v30 = 0;
  memset(v29, 0, sizeof(v29));
  IIOScanner::IIOScanner((IIOScanner *)v29, *((IIOImageReadSession **)this + 3));
  if (!*((_BYTE *)this + 341) || IIOScanner::getBytesAtOffset((IIOScanner *)v29, &__dst, 0, 0x40uLL) != 64)
    goto LABEL_58;
  SwapKTXHeader(&__dst);
  v3 = __dst.i32[3] == 67305985;
  *((_BYTE *)this + 344) = __dst.i32[3] == 67305985;
  GlobalHEIFInfo::setShouldExposeMultiFrameContents((uint64_t)v29, v3);
  *((_WORD *)this + 159) = 0;
  v4 = IIODictionary::containsKey(*((IIODictionary **)this + 6), CFSTR("kCGImageSourceMipmapLevel"));
  v5 = (IIODictionary *)*((_QWORD *)this + 6);
  if (v4)
  {
    LOWORD(v6) = (unsigned __int16)IIODictionary::getUint32ForKey(v5, CFSTR("kCGImageSourceMipmapLevel"));
  }
  else
  {
    if ((IIODictionary::containsKey(v5, CFSTR("kCGImageSourceSubsampleFactor")) & 1) == 0)
    {
      LOWORD(v6) = *((_WORD *)this + 159);
      goto LABEL_12;
    }
    Uint32ForKey = IIODictionary::getUint32ForKey(*((IIODictionary **)this + 6), CFSTR("kCGImageSourceSubsampleFactor"));
    if (Uint32ForKey)
      v8 = log2((double)Uint32ForKey);
    else
      v8 = 0.0;
    v6 = (int)v8;
  }
  *((_WORD *)this + 159) = v6;
LABEL_12:
  if (DWORD2(v34) <= (unsigned __int16)v6)
  {
    LOWORD(v9) = WORD4(v34) - 1;
    if (!DWORD2(v34))
      LOWORD(v9) = 0;
    *((_WORD *)this + 159) = v9;
    v9 = (unsigned __int16)v9;
  }
  else
  {
    v9 = (unsigned __int16)v6;
  }
  *(uint32x2_t *)((char *)this + 228) = vshl_u32(*(uint32x2_t *)((char *)&v33 + 4), (uint32x2_t)vneg_s32(vdup_n_s32(v9)));
  if ((_DWORD)v32 == 5131)
  {
    *((_BYTE *)this + 345) = 1;
    v10 = 16;
  }
  else
  {
    if ((_DWORD)v32 != 5126)
    {
      *((_WORD *)this + 120) = 8;
      goto LABEL_23;
    }
    *((_BYTE *)this + 345) = 1;
    v10 = 32;
  }
  *((_WORD *)this + 120) = v10;
  *((_BYTE *)this + 249) = 1;
LABEL_23:
  if (SDWORD2(v32) <= 33318)
  {
    switch(DWORD2(v32))
    {
      case 0x1903:
      case 0x1904:
      case 0x1905:
        *((_QWORD *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D930]);
        *((_DWORD *)this + 81) = 1196573017;
        *((_BYTE *)this + 246) = 0;
        v11 = 1;
        *((_BYTE *)this + 249) = 1;
        goto LABEL_28;
      case 0x1906:
        goto LABEL_37;
      case 0x1907:
        v16 = (CFStringRef *)MEMORY[0x1E0C9DA10];
        if (*((_BYTE *)this + 345))
          v16 = (CFStringRef *)MEMORY[0x1E0C9D958];
        *((_QWORD *)this + 20) = CGColorSpaceCreateWithName(*v16);
        *((_DWORD *)this + 81) = 1380401696;
        *((_BYTE *)this + 246) = 5;
        v12 = 4;
        v11 = 3;
        goto LABEL_41;
      case 0x1908:
        goto LABEL_31;
      case 0x1909:
        goto LABEL_27;
      default:
        if (DWORD2(v32))
          goto LABEL_37;
        v14 = "R11_EAC [0x%04X] not handled\n";
        v15 = 245;
        switch(HIDWORD(v32))
        {
          case 0x9270:
            goto LABEL_57;
          case 0x9271:
            _cg_jpeg_mem_term("initialize", 248, "SIGNED_R11_EAC [0x%04X] not handled\n");
            break;
          case 0x9272:
            _cg_jpeg_mem_term("initialize", 251, "RG11_EAC [0x%04X] not handled\n");
            break;
          case 0x9273:
            _cg_jpeg_mem_term("initialize", 254, "SIGNED_RG11_EAC [0x%04X] not handled\n");
            break;
          case 0x9274:
            _cg_jpeg_mem_term("initialize", 257, "RGB8_ETC2 [0x%04X] not handled\n");
            break;
          case 0x9275:
            _cg_jpeg_mem_term("initialize", 260, "SRGB8_ETC2 [0x%04X] not handled\n");
            break;
          case 0x9276:
            _cg_jpeg_mem_term("initialize", 263, "RGB8_PUNCHTHROUGH_ALPHA1_ETC2 [0x%04X] not handled\n");
            break;
          case 0x9277:
            _cg_jpeg_mem_term("initialize", 266, "SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 [0x%04X] not handled\n");
            break;
          case 0x9278:
            _cg_jpeg_mem_term("initialize", 269, "RGBA8_ETC2_EAC [0x%04X] not handled\n");
            break;
          case 0x9279:
            _cg_jpeg_mem_term("initialize", 272, "SRGB8_ALPHA8_ETC2_EAC [0x%04X] not handled\n");
            break;
          default:
            if (HIDWORD(v32) == 36196)
            {
              _cg_jpeg_mem_term("initialize", 276, "GL_ETC1_RGB8_OES [0x%04X] not handled\n");
            }
            else
            {
              v14 = "KTX compressed texture [0x%04X] not handled\n";
              v15 = 280;
LABEL_57:
              _cg_jpeg_mem_term("initialize", v15, v14, HIDWORD(v32));
            }
            break;
        }
        break;
    }
    goto LABEL_58;
  }
  if ((DWORD2(v32) - 36244) >= 3)
  {
    if (DWORD2(v32) == 33319)
    {
      *((_QWORD *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
      *((_DWORD *)this + 81) = 1380401696;
      *((_BYTE *)this + 246) = 5;
      v12 = 4;
      v11 = 2;
      goto LABEL_42;
    }
    if (DWORD2(v32) == 36249)
    {
LABEL_31:
      v13 = (CFStringRef *)MEMORY[0x1E0C9DA10];
      if (*((_BYTE *)this + 345))
        v13 = (CFStringRef *)MEMORY[0x1E0C9D958];
      *((_QWORD *)this + 20) = CGColorSpaceCreateWithName(*v13);
      *((_DWORD *)this + 81) = 1380401696;
      *((_BYTE *)this + 246) = 3;
      v12 = 4;
      v11 = 4;
    }
    else
    {
LABEL_37:
      _cg_jpeg_mem_term("initialize", 287, "*** ERROR: KTX ktxHeader.glFormat [0x%04X] not handled\n", DWORD2(v32));
      v12 = 0;
      v11 = 0;
    }
  }
  else
  {
LABEL_27:
    *((_QWORD *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D978]);
    *((_DWORD *)this + 81) = 1196573017;
    *((_BYTE *)this + 246) = 0;
    v11 = 1;
LABEL_28:
    v12 = 1;
  }
LABEL_41:
  v17 = *((_DWORD *)this + 57);
  v18 = *((unsigned int *)this + 58);
  if (v17 * (unint64_t)v12 * v18 > (unint64_t)IIOImageReadSession::getSize(*((IIOImageReadSession **)this
                                                                                          + 3)))
  {
    v26 = *((unsigned int *)this + 57);
    v27 = *((unsigned int *)this + 58);
    Size = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
    _cg_jpeg_mem_term("initialize", 371, "*** bad KTX: [%ldx%ld] fileSize: %d\n", v26, v27, Size);
LABEL_58:
    kdebug_trace();
    v24 = 4294967246;
    goto LABEL_59;
  }
LABEL_42:
  v19 = *((unsigned __int16 *)this + 120);
  *((_WORD *)this + 121) = v19 * v12;
  *((_WORD *)this + 122) = v12;
  *((_BYTE *)this + 346) = 0;
  v20 = v32;
  *(int8x16_t *)((char *)this + 440) = __dst;
  *(_OWORD *)((char *)this + 456) = v20;
  v21 = v34;
  *(_OWORD *)((char *)this + 472) = v33;
  *(_OWORD *)((char *)this + 488) = v21;
  v22 = *((unsigned int *)this + 57) * (unint64_t)v12;
  if ((v22 & 0xFFFFFFFF00000000) != 0)
    goto LABEL_58;
  v23 = v22 * (unint64_t)(v19 >> 3);
  if ((v23 & 0xFFFFFFFF00000000) != 0)
    goto LABEL_58;
  v24 = 0;
  *((_DWORD *)this + 59) = v23;
  *((_QWORD *)this + 63) = v11;
  *((_QWORD *)this + 64) = v12;
  *((_WORD *)this + 188) = 1;
LABEL_59:
  IIOScanner::~IIOScanner((IIOScanner *)v29);
  return v24;
}

void sub_187F917D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  IIOScanner::~IIOScanner((IIOScanner *)va);
  _Unwind_Resume(a1);
}

uint64_t KTXReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v2;

  v2 = *(__int16 *)(a1 + 376);
  if (v2 == 12)
    return IIOReadPlugin::setupImageProviderCallbackV2(a1, a2, (uint64_t)IIO_Reader::CopyImageBlockSetProc, (uint64_t)IIO_Reader::CopyIOSurfaceProc);
  if (v2 == 1)
    return IIOReadPlugin::setupCallback(a1, a2);
  return 4294967246;
}

unint64_t KTXReadPlugin::calculateOffsetToRequestedImage(KTXReadPlugin *this, unint64_t a2)
{
  int v4;
  unsigned int v5;
  int v6;
  int v7;
  unsigned int v9;

  v4 = *((unsigned __int16 *)this + 159);
  v9 = 0;
  v5 = *((_DWORD *)this + 122);
  if (v4)
  {
    if (v5)
      v6 = 1;
    else
      v6 = *((_DWORD *)this + 123);
    do
    {
      IIOImageReadSession::seek(*((IIOImageReadSession **)this + 3), a2, 0);
      IIOImageReadSession::getBytes(*((IIOImageReadSession **)this + 3), &v9, 4uLL);
      a2 += v9 * v6 + 4;
      --v4;
    }
    while (v4);
  }
  IIOImageReadSession::seek(*((IIOImageReadSession **)this + 3), a2, 0);
  IIOImageReadSession::getBytes(*((IIOImageReadSession **)this + 3), &v9, 4uLL);
  v7 = v9;
  if (v5)
    v7 = v9 / v5;
  return a2 + (*((_DWORD *)this + 52) * v7) + 4;
}

uint64_t KTXReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4)
{
  int v5;
  vImagePixelCount v8;
  vImagePixelCount v9;
  unint64_t v10;
  int v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  vImagePixelCount v15;
  uint64_t v16;
  unsigned int v17;
  vImagePixelCount v18;
  int v19;
  unint64_t v20;
  uint64_t v21;
  unsigned int v22;
  IOSurfaceRef *v23;
  int v24;
  uint64_t v25;
  int v26;
  IIOImageRead **v27;
  char *BaseAddress;
  size_t Height;
  uint64_t BlockArray;
  size_t v31;
  double v32;
  double v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  _BYTE *v37;
  unint64_t v38;
  size_t v39;
  int v40;
  char v41;
  uint64_t j;
  char *v43;
  _BYTE *v44;
  int v45;
  int v46;
  uint64_t k;
  char *v48;
  _BYTE *v49;
  int v50;
  uint64_t i;
  char *v52;
  _BYTE *v53;
  int v54;
  int v55;
  vImagePixelCount v56;
  size_t v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  double v62;
  double v63;
  char v64;
  unint64_t v67;
  vImage_Buffer v68;
  vImage_Buffer dest;
  size_t v70[2];
  CGRect v71;
  CGRect v72;

  v5 = a3;
  v70[0] = 0;
  v8 = *((unsigned int *)this + 65);
  v9 = *((unsigned int *)this + 66);
  v10 = *((_QWORD *)this + 63);
  v67 = *((_QWORD *)this + 64);
  if ((gIIODebugFlags & 0x20000) != 0)
  {
    v11 = *((_DWORD *)this + 51);
    v12 = v11 >> 24;
    v13 = MEMORY[0x1E0C80978];
    if (v11 < 0)
    {
      v14 = __maskrune(v12, 0x40000uLL);
      v11 = *((_DWORD *)this + 51);
    }
    else
    {
      v14 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v12 + 60) & 0x40000;
    }
    v15 = v8;
    if (v14)
      v16 = (v11 >> 24);
    else
      v16 = 46;
    v17 = v11 << 8 >> 24;
    v18 = v9;
    if (v11 << 8 < 0)
    {
      v19 = __maskrune(v17, 0x40000uLL);
      v11 = *((_DWORD *)this + 51);
    }
    else
    {
      v19 = *(_DWORD *)(v13 + 4 * v17 + 60) & 0x40000;
    }
    v20 = v10;
    if (v19)
      v21 = (v11 << 8 >> 24);
    else
      v21 = 46;
    v22 = (__int16)v11 >> 8;
    v23 = a4;
    if (v11 << 16 < 0)
    {
      v24 = __maskrune(v22, 0x40000uLL);
      v11 = *((_DWORD *)this + 51);
    }
    else
    {
      v24 = *(_DWORD *)(v13 + 4 * v22 + 60) & 0x40000;
    }
    if (v24)
      v25 = ((__int16)v11 >> 8);
    else
      v25 = 46;
    if ((v11 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v13 + 4 * (char)v11 + 60) & 0x40000) != 0)
        goto LABEL_22;
    }
    else if (__maskrune((char)v11, 0x40000uLL))
    {
LABEL_22:
      v26 = *((_DWORD *)this + 51);
LABEL_25:
      ImageIOLog("  '%c%c%c%c' [%s] %s\n", v16, v21, v25, (char)v26, iioTypeStr[a3], "virtual OSStatus KTXReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      a4 = v23;
      v10 = v20;
      v9 = v18;
      v8 = v15;
      v5 = a3;
      goto LABEL_26;
    }
    LOBYTE(v26) = 46;
    goto LABEL_25;
  }
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  v27 = (IIOImageRead **)*((_QWORD *)this + 3);
  if (v27)
    IIOImageReadSession::mapData(v27);
  if (v5 == 3)
  {
    BlockArray = IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
    v34 = *((_DWORD *)this + 73);
    v32 = (double)v34;
    v35 = *((_DWORD *)this + 74);
    v33 = (double)v35;
    v36 = ((*((unsigned __int16 *)this + 153) + 7) >> 3) * v34;
    *((_DWORD *)this + 75) = v36;
    v31 = v35 * (unint64_t)v36;
    BaseAddress = (char *)_ImageIO_Malloc(v31, *((_QWORD *)this + 48), v70, (uint64_t)kImageMalloc_KTX_Data[0], *((_DWORD *)this + 108), 0, 0);
  }
  else
  {
    if (v5 != 1 || !a4 || !*a4)
      return 0;
    IOSurfaceLock(*a4, 0, 0);
    BaseAddress = (char *)IOSurfaceGetBaseAddress(*a4);
    Height = IOSurfaceGetHeight(*a4);
    BlockArray = 0;
    v31 = IOSurfaceGetBytesPerRow(*a4) * Height;
    v70[0] = v31;
    v32 = 0.0;
    v33 = 0.0;
  }
  if (BaseAddress)
  {
    if (*((_DWORD *)this + 117) == 37488)
    {
      bzero(BaseAddress, v31);
      v37 = 0;
LABEL_44:
      v41 = 1;
      goto LABEL_71;
    }
    v37 = BaseAddress;
    if (v10 >= v67 || (v37 = malloc_type_calloc(v9, *((unsigned int *)this + 75), 0x473D2CF1uLL)) != 0)
    {
      v38 = KTXReadPlugin::calculateOffsetToRequestedImage(this, *((unsigned int *)this + 125) + 64);
      IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v37, v38, v31);
      if (v10 >= v67)
        goto LABEL_44;
      v39 = *((unsigned int *)this + 75);
      v40 = *((_DWORD *)this + 114);
      if (v40 > 5125)
      {
        if (v40 == 5126)
        {
          if ((_DWORD)v9)
          {
            for (i = 0; i != v9; ++i)
            {
              if ((_DWORD)v8)
              {
                v52 = &BaseAddress[(v39 * i)];
                v53 = &v37[(12 * v8 * i)];
                v54 = v8;
                do
                {
                  v55 = *((_DWORD *)v53 + 2);
                  *(_QWORD *)v52 = *(_QWORD *)v53;
                  *((_DWORD *)v52 + 2) = v55;
                  *((_DWORD *)v52 + 3) = 1065353216;
                  v53 += 12;
                  v52 += 16;
                  --v54;
                }
                while (v54);
              }
            }
          }
          goto LABEL_70;
        }
        if (v40 == 5131)
        {
          if ((_DWORD)v9)
          {
            for (j = 0; j != v9; ++j)
            {
              if ((_DWORD)v8)
              {
                v43 = &BaseAddress[(v39 * j)];
                v44 = &v37[(6 * v8 * j)];
                v45 = v8;
                do
                {
                  v46 = *(_DWORD *)v44;
                  *((_WORD *)v43 + 2) = *((_WORD *)v44 + 2);
                  *(_DWORD *)v43 = v46;
                  *((_WORD *)v43 + 3) = 15360;
                  v44 += 6;
                  v43 += 8;
                  --v45;
                }
                while (v45);
              }
            }
          }
          goto LABEL_70;
        }
      }
      else
      {
        if (v40 == 5120)
        {
          if (*((_DWORD *)this + 116) == 33319 && (_DWORD)v9)
          {
            for (k = 0; k != v9; ++k)
            {
              if ((_DWORD)v8)
              {
                v48 = &BaseAddress[(v39 * k)];
                v49 = &v37[(2 * v8 * k)];
                v50 = v8;
                do
                {
                  *v48 = *v49 ^ 0x80;
                  v48[1] = v49[1] ^ 0x80;
                  *((_WORD *)v48 + 1) = -256;
                  v48 += 4;
                  v49 += 2;
                  --v50;
                }
                while (v50);
              }
            }
          }
          goto LABEL_70;
        }
        if (v40 == 5121)
        {
          dest.data = v37;
          dest.height = v9;
          dest.width = v8;
          dest.rowBytes = (3 * v8 + 3) & 0x7FFFFFFFCLL;
          v68.data = BaseAddress;
          v68.height = v9;
          v68.width = v8;
          v68.rowBytes = v39;
          vImageConvert_RGB888toRGBA8888(&dest, 0, 0xFFu, &v68, 0, 0);
LABEL_70:
          v41 = 0;
LABEL_71:
          if (*((_WORD *)this + 153) == 32 && *((_WORD *)this + 152) == 8)
          {
            v56 = *((unsigned int *)this + 74);
            dest.data = BaseAddress;
            dest.height = v56;
            v57 = *((unsigned int *)this + 75);
            dest.width = *((unsigned int *)this + 73);
            dest.rowBytes = v57;
            if (!*((_BYTE *)this + 405))
            {
              LODWORD(v68.data) = 50331906;
              vImagePermuteChannels_ARGB8888(&dest, &dest, (const uint8_t *)&v68, 0x10u);
            }
            if (*((_BYTE *)this + 406) == 1)
              vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
          }
          if (v5 == 3)
          {
            v58 = *((_QWORD *)this + 64) * v8 * ((unint64_t)*((unsigned __int16 *)this + 152) >> 3);
            *((_DWORD *)this + 75) = v58;
            v59 = 0;
            v71.origin.x = 0.0;
            v71.origin.y = 0.0;
            v71.size.width = v32;
            v71.size.height = v33;
            **((_QWORD **)this + 12) = IIOReadPlugin::createImageBlock(this, BaseAddress, v31, v71, v58, *((unsigned __int8 *)this + 343));
            if (CGRectEqualToRect(*(CGRect *)((char *)this + 120), *MEMORY[0x1E0C9D628]))
            {
              v60 = 0;
            }
            else
            {
              v72.origin.x = 0.0;
              v72.origin.y = 0.0;
              v72.size.width = v32;
              v72.size.height = v33;
              *(CGRect *)(&v60 - 1) = CGRectUnion(*(CGRect *)((char *)this + 120), v72);
              v59 = v61;
              v32 = v62;
              v33 = v63;
            }
            *((_QWORD *)this + 15) = v59;
            *((_QWORD *)this + 16) = v60;
            *((double *)this + 17) = v32;
            *((double *)this + 18) = v33;
          }
          else
          {
            IOSurfaceUnlock(*a4, 0, 0);
          }
          if (v37)
            v64 = v41;
          else
            v64 = 1;
          if ((v64 & 1) == 0)
            free(v37);
          return 0;
        }
      }
      _cg_jpeg_mem_term("decodeImageImp", 661, "*** ERROR: glType 0x%04x not handled\n", *((_DWORD *)this + 114));
      goto LABEL_70;
    }
    if (v5 == 3)
      _ImageIO_Free((unint64_t)BaseAddress, v70[0]);
  }
  return BlockArray;
}

void IIOImageSource::IIOImageSource(IIOImageSource *this, const __CFString *a2, IIODictionary *a3)
{
  const __CFURL *v6;

  *(_QWORD *)this = &off_1E1BAE3E0;
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 17) = 0;
  *((_QWORD *)this + 22) = 0;
  *((_QWORD *)this + 23) = 0;
  *((_QWORD *)this + 24) = 0;
  IIOImageSource::setup((uint64_t)this, 5);
  if (a3)
    IIOImageSource::extractOptions(this, a3);
  v6 = CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, kCFURLPOSIXPathStyle, 0);
  if (v6)
  {
    *((_QWORD *)this + 2) = CGImageReadCreateWithURL(*((_QWORD *)this + 1), v6, (unsigned __int8 *)1, *((unsigned __int8 *)this + 48), *((unsigned __int8 *)this + 49));
    CFRelease(v6);
  }
}

void sub_187F9202C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void *v5;
  void *v6;

  v5 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 184) = v5;
    operator delete(v5);
  }
  v6 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 128) = v6;
    operator delete(v6);
  }
  _Unwind_Resume(exception_object);
}

uint64_t IIOImageSource::updateMemoryMapFlagForProtectionClass(uint64_t this, IIOString *a2)
{
  uint64_t v2;
  const char *v3;
  _QWORD v4[3];
  _OWORD v5[4];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(this + 48))
  {
    v2 = this;
    v3 = (const char *)IIOString::utf8String(a2);
    v4[1] = 0;
    v4[2] = 0;
    memset(v5, 0, sizeof(v5));
    v4[0] = 0x4000000000000005;
    this = getattrlist(v3, v4, v5, 0x40uLL, 1u);
    if (!(_DWORD)this && LODWORD(v5[0]) == 8 && (DWORD1(v5[0]) - 1) <= 1)
      *(_BYTE *)(v2 + 48) = 0;
  }
  return this;
}

uint64_t IIOImageSource::imageRead(IIOImageSource *this)
{
  return CGImageSourceGetSource(*((_QWORD *)this + 2));
}

uint64_t IIOImageSource::lock(IIOImageSource *this)
{
  return pthread_mutex_lock((pthread_mutex_t *)((char *)this + 200));
}

uint64_t IIOImageSource::unlock(IIOImageSource *this)
{
  return pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 200));
}

void IIOImageSource::removeImageFromSet(uint64_t a1, IIOImagePlus **a2, const void *a3)
{
  IIOImagePlus **ImageProvider;
  CFIndex Count;
  const void **v8;
  const void **v9;
  const void **v10;
  IIOImagePlus **v11;

  ImageProvider = (IIOImagePlus **)IIOImagePlus::getImageProvider(a2[3]);
  Count = CFSetGetCount(*(CFSetRef *)(a1 + 160));
  v8 = (const void **)malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
  if (v8)
  {
    v9 = v8;
    CFSetGetValues(*(CFSetRef *)(a1 + 160), v8);
    if (Count >= 1)
    {
      v10 = v9;
      while (*v10 != a3)
      {
        ++v10;
        if (!--Count)
          goto LABEL_15;
      }
      v11 = (IIOImagePlus **)*MEMORY[0x1E0C9B0D0];
      if (ImageProvider && ImageProvider != v11)
        CFRetain(ImageProvider);
      if (a2)
      {
        if (v11 != a2)
          CFRetain(a2);
      }
      CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 160), *v10);
    }
LABEL_15:
    free(v9);
  }
}

const void **IIOImageSource::getAllImagePlusValues(CFArrayRef *this, uint64_t *a2)
{
  uint64_t Count;
  const void **v5;
  CFRange v7;

  Count = CFArrayGetCount(this[18]);
  v5 = (const void **)malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
  if (v5)
  {
    v7.location = 0;
    v7.length = Count;
    CFArrayGetValues(this[18], v7, v5);
  }
  *a2 = Count;
  return v5;
}

uint64_t IIOImageSource::incrementalDataUpdated(IIOImageSource *this)
{
  return *((unsigned __int8 *)this + 33);
}

const char *IIOImageSource::updateDataProvider(IIOImageSource *this, CGDataProvider *a2, CGDataProvider *a3)
{
  IIOImageRead *Source;
  IIOImageRead *v7;
  const char *result;
  CFDataRef v9;
  const __CFData *v10;
  const char *v11;
  const char *v12;

  Source = (IIOImageRead *)CGImageSourceGetSource(*((_QWORD *)this + 2));
  v7 = Source;
  if (Source && IIOImageRead::isFinal(Source))
    return LogError("updateDataProvider", 787, "*** ERROR: image source was already finalized\n");
  if ((gIIODebugFlags & 0x10000000) != 0)
  {
    v9 = CGDataProviderCopyData(a2);
    if (v9)
    {
      v10 = v9;
      if ((_DWORD)a3)
        v11 = "imageDataProviderProg-final";
      else
        v11 = "imageDataProviderProg-part";
      ImageIO_saveImageData(v11, v10);
      CFRelease(v10);
    }
  }
  if (v7)
  {
    result = (const char *)IIOImageRead::updateDataProvider(v7, a2, (int)a3);
  }
  else
  {
    result = (const char *)CGImageReadCreateWithProvider(*((_QWORD *)this + 1), a2, a3);
    *((_QWORD *)this + 2) = result;
  }
  if ((gIIODebugFlags & 0x2000000000) != 0)
  {
    v12 = "NO ";
    if ((_DWORD)a3)
      v12 = "YES";
    result = ImageIOLog("    %s - isr=%p  provider=%p   final=%s\n", "updateDataProvider", *((const void **)this + 1), a2, v12);
  }
  *((_WORD *)this + 16) = 256;
  if ((_DWORD)a3)
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 264));
    *((_DWORD *)this + 22) = 0;
    return (const char *)pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 264));
  }
  return result;
}

uint64_t IIOImageSource::setStatus(IIOImageSource *this, CGImageSourceStatus a2)
{
  pthread_mutex_t *v4;

  v4 = (pthread_mutex_t *)((char *)this + 264);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 264));
  *((_DWORD *)this + 22) = a2;
  return pthread_mutex_unlock(v4);
}

uint64_t IIOImageSource::imageSourceType(IIOImageSource *this)
{
  return *((unsigned __int8 *)this + 54);
}

uint64_t IIOImageSource::imageDataDidNotMatchRequestedHint(IIOImageSource *this)
{
  return *((unsigned __int8 *)this + 65);
}

uint64_t IIOImageSource::errorStatus(IIOImageSource *this)
{
  return *((unsigned int *)this + 82);
}

uint64_t IIOImageSource::shouldExposeMultiFrameContents(IIOImageSource *this)
{
  return *((unsigned __int8 *)this + 50);
}

uint64_t IIOImageSource::useImageSequence(IIOImageSource *this)
{
  return *((unsigned __int8 *)this + 52);
}

uint64_t IIOImageSource::canAnimate(IIO_Reader **this)
{
  const __CFString *v2;
  const __CFString *v3;

  if (!IIOImageSource::bindToReader((IIOImageSource *)this))
    return 4294967292;
  v2 = (const __CFString *)IIO_Reader::utType(this[10]);
  if (!v2)
    return 4294967292;
  v3 = v2;
  if (CFStringCompare(v2, CFSTR("com.compuserve.gif"), 0)
    && CFStringCompare(v3, CFSTR("public.png"), 0)
    && CFStringCompare(v3, CFSTR("public.heics"), 0)
    && CFStringCompare(v3, CFSTR("public.avis"), 0)
    && CFStringCompare(v3, CFSTR("org.webmproject.webp"), 0)
    && CFStringCompare(v3, CFSTR("public.jpeg-xl"), 0))
  {
    return 4294967292;
  }
  else
  {
    return 0;
  }
}

uint64_t IIOImageSource::getType(IIO_Reader **this)
{
  if (IIOImageSource::bindToReader((IIOImageSource *)this))
    return IIO_Reader::utType(this[10]);
  else
    return 0;
}

uint64_t IIOImageSource::isCloudTranscodable(IIO_Reader **this, const __CFDictionary **a2)
{
  const __CFString *v4;
  const __CFString *v5;
  uint64_t v6;
  const __CFDictionary **v8;
  const __CFDictionary **v9;
  const __CFString *ObjectForKey;
  _QWORD v11[3];

  if (!IIOImageSource::bindToReader((IIOImageSource *)this)
    || (v4 = (const __CFString *)IIO_Reader::utType(this[10])) == 0)
  {
    _cg_jpeg_mem_term("isCloudTranscodable", 1150, "*** can't get image source type\n");
    return 4294967292;
  }
  v5 = v4;
  if (CFStringCompare(v4, CFSTR("public.jpeg"), 0))
  {
    if (CFStringCompare(v5, CFSTR("public.heic"), 0) == kCFCompareEqualTo)
      return 0;
    v6 = 4294967292;
    if (CFStringCompare(v5, CFSTR("public.heics"), 0))
    {
      if (CFStringCompare(v5, CFSTR("public.png"), 0))
        return 4294967292;
      else
        return 0;
    }
    return v6;
  }
  v8 = IIOImageSource::copyPropertiesAtIndex((IIOImageSource *)this, 0, a2);
  if (!v8)
    return 4294967292;
  v9 = v8;
  memset(v11, 0, sizeof(v11));
  IIODictionary::IIODictionary((IIODictionary *)v11, (const __CFDictionary *)v8);
  ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey((IIODictionary *)v11, CFSTR("ColorModel"));
  if (CFStringCompare(ObjectForKey, CFSTR("Gray"), 0) && CFStringCompare(ObjectForKey, CFSTR("RGB"), 0))
    v6 = 4294967292;
  else
    v6 = 0;
  CFRelease(v9);
  IIODictionary::~IIODictionary((IIODictionary *)v11);
  return v6;
}

void sub_187F92718(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

CGImage *IIOImageSource::CGImageGetHash(IIOImageSource *this, CGImage *a2)
{
  const __CFNumber *Property;
  CGImage *Hash;
  CGDataProvider *DataProvider;
  IIOImageSource *Mask;
  unint64_t v9;
  CGColorSpace *ColorSpace;
  const __CFData *v11;
  const __CFData *v12;
  CFIndex Length;
  const UInt8 *BytePtr;
  _QWORD v15[3];

  Property = (const __CFNumber *)CGImageGetProperty();
  if (Property)
  {
    IIONumber::IIONumber((IIONumber *)v15, Property);
    Hash = (CGImage *)IIONumber::uint64Num((IIONumber *)v15);
LABEL_3:
    IIONumber::~IIONumber((IIONumber *)v15);
    return Hash;
  }
  DataProvider = CGImageGetDataProvider(this);
  if (!DataProvider)
  {
    _cg_jpeg_mem_term("CGImageGetHash", 1208, "*** ERROR: cannot get CGDataProvider from image\n");
    return 0;
  }
  Hash = (CGImage *)IIOHashForDataProvider(DataProvider, (unint64_t)a2);
  if (Hash)
  {
    Mask = (IIOImageSource *)CGImageGetMask();
    if (Mask)
      Hash = (CGImage *)IIOImageSource::CGImageGetHash(Mask, Hash, v9);
    ColorSpace = CGImageGetColorSpace(this);
    if (CGColorSpaceGetModel(ColorSpace) == kCGColorSpaceModelIndexed)
    {
      v11 = (const __CFData *)CGColorSpaceCopyColorTable();
      if (v11)
      {
        v12 = v11;
        Length = CFDataGetLength(v11);
        BytePtr = CFDataGetBytePtr(v12);
        if (BytePtr && Length)
          Hash = (CGImage *)IIOHashForBuffer(BytePtr, Length, (unint64_t)Hash);
        CFRelease(v12);
      }
    }
    memset(v15, 0, sizeof(v15));
    IIONumber::IIONumber((IIONumber *)v15, (uint64_t)Hash);
    CGImageSetProperty();
    goto LABEL_3;
  }
  return Hash;
}

void sub_187F92874(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

CGImage *IIOImageSource::isColorOptimizedForSharing(CFSetRef *this, const __CFDictionary **a2)
{
  CFIndex Count;
  uint64_t v5;
  const void **v6;
  const void **v7;
  int IsOptimizedForSharing;
  CGImage *result;
  CGImage *v10;
  uint64_t v11;

  Count = CFSetGetCount(this[20]);
  if (Count)
  {
    v5 = Count;
    v6 = (const void **)malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
    if (v6)
    {
      v7 = v6;
      CFSetGetValues(this[20], v6);
      if (v5 < 1)
        IsOptimizedForSharing = 0;
      else
        IsOptimizedForSharing = CGImageIsOptimizedForSharing();
      free(v7);
    }
    else
    {
      IsOptimizedForSharing = 0;
    }
    return (CGImage *)(IsOptimizedForSharing != 0);
  }
  else
  {
    result = IIOImageSource::createImageAtIndex((IIOImageSource *)this, 0, a2, 0);
    if (result)
    {
      v10 = result;
      v11 = CGImageIsOptimizedForSharing();
      CGImageRelease(v10);
      return (CGImage *)v11;
    }
  }
  return result;
}

uint64_t IIOImageSource::copyMetadataAtIndex(IIOImageSource *this, unint64_t a2, const __CFDictionary **a3)
{
  IIOImagePlus **ImagePlus;
  const void *v7;

  if (!IIOImageSource::bindToReader(this))
    return 0;
  ImagePlus = (IIOImagePlus **)IIOImageSource::makeImagePlus(this, a2, a3);
  v7 = ImagePlus
     ? (const void *)IIOImagePlus::getMetadata(ImagePlus[3])
     : IIOImageSource::getImageMetadataAtIndex((CFArrayRef *)this, a2);
  if (!v7 || v7 == (const void *)*MEMORY[0x1E0C9B0D0])
    return 0;
  else
    return CGImageMetadataCreateImmutableCopy((uint64_t)v7);
}

const void *IIOImageSource::getImageMetadataAtIndex(CFArrayRef *this, CFIndex a2)
{
  unsigned int Count;
  const void *result;

  Count = CFArrayGetCount(this[19]);
  if (a2 >= Count)
  {
    _cg_jpeg_mem_term("getImageMetadataAtIndex", 3886, "getImageMetadataAtIndex index (%d) larger than arrayCount (%d)\n", a2, Count);
    return 0;
  }
  else
  {
    result = CFArrayGetValueAtIndex(this[19], a2);
    if (result == (const void *)*MEMORY[0x1E0C9B0D0])
      return 0;
  }
  return result;
}

__CFArray *IIOImageSource::copyMetadataPropertiesAtIndex(IIOImageSource *this, unint64_t a2, const __CFDictionary **a3, unsigned int *a4)
{
  IIOImagePlus **ImagePlus;
  _QWORD *v9;
  uint64_t v10;
  void *TagWithPath;
  const __CFNumber *Value;
  _BYTE v14[24];

  if (!IIOImageSource::bindToReader(this))
    return 0;
  ImagePlus = (IIOImagePlus **)IIOImageSource::makeImagePlus(this, a2, a3);
  v9 = ImagePlus
     ? (_QWORD *)IIOImagePlus::getMetadata(ImagePlus[3])
     : IIOImageSource::getImageMetadataAtIndex((CFArrayRef *)this, a2);
  v10 = (uint64_t)v9;
  if (!v9)
    return 0;
  TagWithPath = CGImageMetadataGetTagWithPath(v9, 0, CFSTR("tiff:Orientation"));
  if (a4)
  {
    Value = (const __CFNumber *)CGImageMetadataTagGetValue((uint64_t)TagWithPath);
    IIONumber::IIONumber((IIONumber *)v14, Value);
    *a4 = IIONumber::uint16Num((IIONumber *)v14);
    IIONumber::~IIONumber((IIONumber *)v14);
  }
  return CGImageMetadataCreateMetadataProperties(v10);
}

void sub_187F92B24(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOImageSource::imageSourceCanBeUsedForJPEGResize(IIO_Reader **this, unsigned int a2)
{
  uint64_t result;
  int v5;
  _BYTE v6[40];

  result = IIOImageSource::bindToReader((IIOImageSource *)this);
  if ((_DWORD)result)
  {
    result = IIO_Reader::utType(this[10]);
    if (result)
    {
      if (CFStringCompare((CFStringRef)result, CFSTR("public.jpeg"), 0))
      {
        result = (uint64_t)IIOImageSource::isRAWFile((IIOImageSource *)this);
        if ((_DWORD)result)
        {
          IIOImageSource::updateThumbnailInfo((IIOImageSource *)this, 0, 0, 0);
          IIOImageSource::getThumbnailInfoAtIndex((uint64_t)this, 0, a2, (uint64_t)v6);
          return v5 == 0;
        }
      }
      else
      {
        return 1;
      }
    }
  }
  return result;
}

BOOL IIOImageSource::imageSourceCanBeUsedForHEICResize(IIO_Reader **this)
{
  const __CFString *v2;

  if (IIOImageSource::bindToReader((IIOImageSource *)this))
    v2 = (const __CFString *)IIO_Reader::utType(this[10]);
  else
    v2 = 0;
  return CFStringCompare(v2, CFSTR("public.heic"), 0) == kCFCompareEqualTo;
}

void ___ZN14IIOImageSource19updateThumbnailInfoEP13IIODictionaryPjS2__block_invoke(uint64_t a1, const __CFDictionary *a2)
{
  _QWORD *v3;
  unsigned int Uint32ForKey;
  unsigned int v5;
  int v6;
  int v7;
  const __CFDictionary *Uint64ForKey;
  unsigned int v9;
  char v10;
  unsigned int v11;
  unsigned int v12;
  BOOL v14;
  BOOL v15;
  unint64_t v16;
  unint64_t v17;
  char *v18;
  int v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  char *v25;
  char *v26;
  char *v27;
  char *v28;
  char *v29;
  __int128 v30;
  __int128 v31;
  char v32;
  unsigned __int8 v33;
  _QWORD v34[3];

  v3 = *(_QWORD **)(a1 + 32);
  memset(v34, 0, sizeof(v34));
  IIODictionary::IIODictionary((IIODictionary *)v34, a2);
  Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v34, CFSTR("Width"));
  v5 = IIODictionary::getUint32ForKey((IIODictionary *)v34, CFSTR("Height"));
  v7 = *(_DWORD *)(a1 + 40);
  v6 = *(_DWORD *)(a1 + 44);
  v33 = IIODictionary::getUint32ForKey((IIODictionary *)v34, CFSTR("Orientation"));
  if (*(_BYTE *)(a1 + 48))
  {
    Uint64ForKey = IIODictionary::getUint64ForKey((IIODictionary *)v34, CFSTR("JPEGOffset"));
    v9 = IIODictionary::getUint32ForKey((IIODictionary *)v34, CFSTR("JPEGLength"));
    v10 = 1;
  }
  else
  {
    Uint64ForKey = IIODictionary::getUint64ForKey((IIODictionary *)v34, CFSTR("ThumbnailOffset"));
    v9 = IIODictionary::getUint32ForKey((IIODictionary *)v34, CFSTR("ThumbnailSize"));
    v10 = 0;
  }
  v11 = *(_DWORD *)(a1 + 40);
  v12 = *(_DWORD *)(a1 + 44);
  v14 = Uint32ForKey == v11 && v5 == v12;
  v15 = vabdd_f64((double)Uint32ForKey / (double)v5, (double)v11 / (double)v12) > 0.02;
  v16 = v3[24];
  v17 = v3[23];
  if (v17 >= v16)
  {
    v32 = v10;
    v19 = v6;
    v20 = v3[22];
    v21 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v17 - v20) >> 3);
    v22 = v21 + 1;
    if (v21 + 1 > 0x666666666666666)
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    v23 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v16 - v20) >> 3);
    if (2 * v23 > v22)
      v22 = 2 * v23;
    if (v23 >= 0x333333333333333)
      v24 = 0x666666666666666;
    else
      v24 = v22;
    if (v24)
      v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOThumbnailInfo>>((uint64_t)(v3 + 24), v24);
    else
      v25 = 0;
    v26 = &v25[40 * v21];
    *(_QWORD *)v26 = Uint64ForKey;
    v27 = &v25[40 * v24];
    *((_DWORD *)v26 + 2) = v9;
    *((_DWORD *)v26 + 3) = Uint32ForKey;
    *((_DWORD *)v26 + 4) = v5;
    *((_DWORD *)v26 + 5) = v7;
    *((_DWORD *)v26 + 6) = v19;
    *((_DWORD *)v26 + 7) = 0;
    v26[32] = v33;
    v26[33] = v32;
    v26[34] = v14;
    v26[35] = v15;
    *((_DWORD *)v26 + 9) = 0;
    v18 = v26 + 40;
    v29 = (char *)v3[22];
    v28 = (char *)v3[23];
    if (v28 != v29)
    {
      do
      {
        v30 = *(_OWORD *)(v28 - 40);
        v31 = *(_OWORD *)(v28 - 24);
        *((_QWORD *)v26 - 1) = *((_QWORD *)v28 - 1);
        *(_OWORD *)(v26 - 24) = v31;
        *(_OWORD *)(v26 - 40) = v30;
        v26 -= 40;
        v28 -= 40;
      }
      while (v28 != v29);
      v28 = (char *)v3[22];
    }
    v3[22] = v26;
    v3[23] = v18;
    v3[24] = v27;
    if (v28)
      operator delete(v28);
  }
  else
  {
    *(_QWORD *)v17 = Uint64ForKey;
    *(_DWORD *)(v17 + 8) = v9;
    *(_DWORD *)(v17 + 12) = Uint32ForKey;
    *(_DWORD *)(v17 + 16) = v5;
    *(_DWORD *)(v17 + 20) = v7;
    *(_DWORD *)(v17 + 24) = v6;
    *(_DWORD *)(v17 + 28) = 0;
    *(_BYTE *)(v17 + 32) = v33;
    *(_BYTE *)(v17 + 33) = v10;
    *(_BYTE *)(v17 + 34) = v14;
    *(_BYTE *)(v17 + 35) = v15;
    v18 = (char *)(v17 + 40);
    *(_DWORD *)(v17 + 36) = 0;
  }
  v3[23] = v18;
  IIODictionary::~IIODictionary((IIODictionary *)v34);
}

void sub_187F92ED4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOImageSource::getImageCacheAtIndex(IIOImageSource *this, unint64_t a2, const __CFDictionary **a3)
{
  if (!IIOImageSource::bindToReader(this))
    return 0;
  IIOImageSource::makeImagePlus(this, a2, a3);
  return IIOLookupISR();
}

__IOSurface *IIOImageSource::createIOSurfaceAtIndex(IIOImageSource *this, unint64_t a2, const __CFDictionary **a3)
{
  _BOOL4 v6;
  unsigned __int8 v7;
  unsigned int Uint32ForKey;
  IIODictionary *v9;
  CGImage *v10;
  CGImage *v11;
  size_t Width;
  size_t Height;
  __IOSurface *IOSurfaceFromBlockSet;
  CGColorSpace *ColorSpace;
  CGColorSpaceModel Model;
  BOOL BoolForKey;
  IIODictionary *v19;
  size_t BitsPerComponent;
  const __CFDictionary *ObjectForKey;
  const __CFDictionary *v22;
  const __CFString *v23;
  const __CFDictionary *v24;
  uint64_t v25;
  CGColorSpace *v26;
  IIOImageSource *v27;
  uint64_t v28;
  CGColorSpace *v29;
  CFTypeRef v30;
  float v31;
  _BYTE v33[16];
  CFTypeRef value;
  _BYTE v35[28];
  int v36;

  v36 = 0;
  v6 = IIODictionary::containsKey((IIODictionary *)a3, "kCGImageSourceSoftmaskData");
  v7 = IIODictionary::containsKey((IIODictionary *)a3, CFSTR("kCGImageSourceColorTransform"));
  if (IIODictionary::containsKey((IIODictionary *)a3, CFSTR("kCGImageSourceThumbnailMaxPixelSize")))
  {
    Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)a3, CFSTR("kCGImageSourceThumbnailMaxPixelSize"));
    v9 = (IIODictionary *)operator new();
    IIODictionary::IIODictionary(v9, a3[1], 0);
    IIODictionary::setObjectForKey(v9, (const void *)*MEMORY[0x1E0C9AE50], CFSTR("kCGImageSourceCreateThumbnailFromImageAlways"));
    v10 = IIOImageSource::createThumbnailAtIndex(this, a2, (const __CFDictionary **)v9, &v36);
    v11 = v10;
    if (v10)
    {
      Width = CGImageGetWidth(v10);
      Height = CGImageGetHeight(v11);
      if (Width > Uint32ForKey || Height > Uint32ForKey)
      {
        CFRelease(v11);
        v11 = 0;
      }
    }
    (*(void (**)(IIODictionary *))(*(_QWORD *)v9 + 8))(v9);
    if (!v11)
      return 0;
LABEL_12:
    ColorSpace = CGImageGetColorSpace(v11);
    Model = CGColorSpaceGetModel(ColorSpace);
    if (Model >= kCGColorSpaceModelCMYK)
    {
      _cg_jpeg_mem_term("createIOSurfaceAtIndex", 3032, "*** ERROR: unsupported colorspace (csm=%d)\n", Model);
    }
    else
    {
      if (IIODictionary::containsKey((IIODictionary *)a3, CFSTR("kCGImageSourceUseNativeSurfaceFormat")))
        BoolForKey = IIODictionary::getBoolForKey((IIODictionary *)a3, CFSTR("kCGImageSourceUseNativeSurfaceFormat"));
      else
        BoolForKey = 0;
      if (CGImageGetImageProvider())
      {
        CGImageProviderGetSize();
        v19 = (IIODictionary *)operator new();
        IIODictionary::IIODictionary(v19);
        BitsPerComponent = CGImageGetBitsPerComponent(v11);
        if (!BoolForKey)
        {
          if (IIODictionary::containsKey((IIODictionary *)a3, CFSTR("kCGImageSurfaceFormatRequest")))
          {
            ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)a3, CFSTR("kCGImageSurfaceFormatRequest"));
            IIODictionary::setObjectForKey(v19, ObjectForKey, CFSTR("kCGImageSurfaceFormatRequest"));
          }
          else if (BitsPerComponent == 8)
          {
            IIONumber::IIONumber((IIONumber *)v35, 1111970369);
            IIODictionary::setObjectForKey((uint64_t)v19, (uint64_t)v35, CFSTR("kCGImageSurfaceFormatRequest"));
            IIONumber::~IIONumber((IIONumber *)v35);
          }
        }
        if (IIODictionary::containsKey((IIODictionary *)a3, CFSTR("kCGImageBlockIOSurfacePromoteToCIF10")))
        {
          v22 = IIODictionary::getObjectForKey((IIODictionary *)a3, CFSTR("kCGImageBlockIOSurfacePromoteToCIF10"));
          IIODictionary::setObjectForKey(v19, v22, CFSTR("kCGImageBlockIOSurfacePromoteToCIF10"));
        }
        v23 = (const __CFString *)*MEMORY[0x1E0C9DA98];
        if (IIODictionary::containsKey((IIODictionary *)a3, (const __CFString *)*MEMORY[0x1E0C9DA98]))
        {
          v24 = IIODictionary::getObjectForKey((IIODictionary *)a3, v23);
          IIODictionary::setObjectForKey(v19, v24, v23);
        }
        if ((v7 & 1) != 0 || (v25 = CGImageProviderCopyIOSurface()) == 0)
        {
          if (BitsPerComponent == 8)
            IIODictionary::setObjectForKey(v19, (const void *)*MEMORY[0x1E0C9AE50], CFSTR("kCGImageBlockIOSurfaceOptimizedRequest"));
          v28 = CGImageProviderCopyImageBlockSetWithOptions();
          if (v28 || (v28 = CGImageProviderCopyImageBlockSetWithOptions()) != 0)
          {
            CGImageBlockSetSetProperty();
            IOSurfaceFromBlockSet = IIO_CreateIOSurfaceFromBlockSet(v28, a3[1]);
            v29 = (CGColorSpace *)CGImageProviderGetColorSpace();
            IIO_IOSurfaceAddColorSpace(IOSurfaceFromBlockSet, v29);
            v27 = (IIOImageSource *)CGImageBlockSetRelease();
            if (!v6)
              goto LABEL_40;
          }
          else
          {
            _cg_jpeg_mem_term("createIOSurfaceAtIndex", 3092, " CGImageProviderCopyImageBlockSetWithOptions returned nil\n");
            IOSurfaceFromBlockSet = 0;
            if (!v6)
            {
LABEL_40:
              (*(void (**)(IIODictionary *))(*(_QWORD *)v19 + 8))(v19);
              if (IOSurfaceFromBlockSet)
              {
LABEL_41:
                v30 = IOSurfaceCopyValue(IOSurfaceFromBlockSet, CFSTR("IOSurfaceContentHeadroom"));
                if (v30)
                {
                  CFRelease(v30);
                }
                else
                {
                  CGImageGetContentHeadroom();
                  if (v31 >= 1.0)
                  {
                    IIONumber::IIONumber((IIONumber *)v33, v31);
                    IOSurfaceSetValue(IOSurfaceFromBlockSet, CFSTR("IOSurfaceContentHeadroom"), value);
                    IIONumber::~IIONumber((IIONumber *)v33);
                  }
                }
              }
LABEL_45:
              CGImageRelease(v11);
              return IOSurfaceFromBlockSet;
            }
          }
        }
        else
        {
          IOSurfaceFromBlockSet = (__IOSurface *)v25;
          v26 = (CGColorSpace *)CGImageProviderGetColorSpace();
          IIO_IOSurfaceAddColorSpace(IOSurfaceFromBlockSet, v26);
          if (!v6)
            goto LABEL_40;
        }
        IIOImageSource::mergeSoftmask(v27, IOSurfaceFromBlockSet, (IIODictionary *)a3);
        IIO_IOSurfacePremultiply(IOSurfaceFromBlockSet);
        goto LABEL_40;
      }
      _cg_jpeg_mem_term("createIOSurfaceAtIndex", 3109, " CGImageGetImageProvider returned NULL, creating IOSurface from CGImage data.\n");
      if (!BoolForKey)
      {
        IOSurfaceFromBlockSet = IIO_CreateIOSurfaceFromImage(v11, 1380401729, 0);
        if (IOSurfaceFromBlockSet)
          goto LABEL_41;
        goto LABEL_45;
      }
    }
    IOSurfaceFromBlockSet = 0;
    goto LABEL_45;
  }
  v11 = IIOImageSource::createImageAtIndex(this, a2, a3, &v36);
  if (v11)
    goto LABEL_12;
  return 0;
}

void sub_187F93450(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

vImage_Error IIOImageSource::mergeSoftmask(IIOImageSource *this, IOSurfaceRef buffer, IIODictionary *a3)
{
  OSType PixelFormat;
  size_t Width;
  size_t Height;
  const __CFData *ObjectForKey;
  unsigned int Uint32ForKey;
  uint64_t v10;
  size_t v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  vImage_Error v16;
  UInt8 *BytePtr;
  void *v18;
  uint64_t i;
  UInt8 *v20;
  unsigned int v21;
  void *v22;
  vImagePixelCount v23;
  vImagePixelCount v24;
  size_t BytesPerRow;
  unint64_t Length;
  vImage_Buffer dest;
  vImage_Buffer src;

  PixelFormat = IOSurfaceGetPixelFormat(buffer);
  if (PixelFormat != 1380401729 && PixelFormat != 1111970369)
    return 0;
  Width = IOSurfaceGetWidth(buffer);
  Height = IOSurfaceGetHeight(buffer);
  BytesPerRow = IOSurfaceGetBytesPerRow(buffer);
  ObjectForKey = (const __CFData *)IIODictionary::getObjectForKey(a3, "kCGImageSourceSoftmaskData");
  Length = CFDataGetLength(ObjectForKey);
  Uint32ForKey = IIODictionary::getUint32ForKey(a3, "kCGImageSourceSoftmaskWidth");
  v10 = Uint32ForKey;
  v11 = IIODictionary::getUint32ForKey(a3, "kCGImageSourceSoftmaskHeight");
  v12 = IIODictionary::getUint32ForKey(a3, "kCGImageSourceSoftmaskRowBytes");
  v13 = IIODictionary::getUint32ForKey(a3, "kCGImageSourceSoftmaskBitsPerComponent");
  v14 = v13;
  if (v13 <= 8 && (v15 = 1, ((1 << v13) & 0x116) != 0))
  {
    v16 = 0;
  }
  else
  {
    _cg_jpeg_mem_term("mergeSoftmask", 3158, "*** ERROR: invalid softmask bitsPerComponent: %d (expected 1,2,4, or 8\n", v13);
    v15 = 0;
    v16 = 4294967246;
  }
  if (v14 <= 8 && ((1 << v14) & 0x116) != 0)
  {
    if (Length < v14 * (unint64_t)v11)
    {
      _cg_jpeg_mem_term("mergeSoftmask", 3163, "*** ERROR: invalid softmask: %ldx%ld  dataSize: %ld\n  expected: %ld   (%d bpc)", Uint32ForKey, v11, Length, v14 * (unint64_t)v11, v14);
      return 4294967246;
    }
  }
  else if (!v15)
  {
    return v16;
  }
  BytePtr = (UInt8 *)CFDataGetBytePtr(ObjectForKey);
  if (v14 > 7)
  {
    v18 = 0;
    if (!(_DWORD)v11)
      goto LABEL_28;
    goto LABEL_23;
  }
  v18 = malloc_type_calloc(Uint32ForKey, v11, 0x81E31976uLL);
  src.data = BytePtr;
  src.height = v11;
  src.width = Uint32ForKey;
  src.rowBytes = v12;
  dest.data = v18;
  dest.height = v11;
  dest.width = Uint32ForKey;
  dest.rowBytes = Uint32ForKey;
  switch(v14)
  {
    case 4u:
      vImageConvert_Planar4toPlanar8(&src, &dest, 0x10u);
      break;
    case 2u:
      vImageConvert_Planar2toPlanar8(&src, &dest, 0x10u);
      break;
    case 1u:
      vImageConvert_Planar1toPlanar8(&src, &dest, 0x10u);
      break;
  }
  BytePtr = (UInt8 *)v18;
  if ((_DWORD)v11)
  {
LABEL_23:
    for (i = 0; i != v11; ++i)
    {
      if (Uint32ForKey)
      {
        v20 = &BytePtr[i * Uint32ForKey];
        v21 = Uint32ForKey;
        do
        {
          *v20 = ~*v20;
          ++v20;
          --v21;
        }
        while (v21);
      }
    }
  }
LABEL_28:
  src.data = BytePtr;
  src.height = v11;
  src.width = Uint32ForKey;
  src.rowBytes = Uint32ForKey;
  if (Width == Uint32ForKey && Height == v11)
  {
    v22 = 0;
    v23 = Height;
    v24 = Width;
  }
  else
  {
    dest = src;
    v22 = malloc_type_calloc(Width, Height, 0x6C617C66uLL);
    src.data = v22;
    src.height = Height;
    src.width = Width;
    src.rowBytes = Width;
    v16 = vImageScale_Planar8(&dest, &src, 0, 0x10u);
    if ((_DWORD)v16)
    {
      _cg_jpeg_mem_term("mergeSoftmask", 3224, "*** ERROR: vImageScale_Planar8 failed - err= %d\n", v16);
      if (!v22)
        goto LABEL_42;
      goto LABEL_41;
    }
    v23 = src.height;
    v24 = src.width;
  }
  if (v24 != Width || v23 != Height)
  {
    _cg_jpeg_mem_term("mergeSoftmask", 3231, "*** ERROR: invalid dimesions:  alpha: %ldx%ld   surface: %ldx%ld", v10, v11, Length, v11 * (unint64_t)v10);
    v16 = 4294967246;
    if (!v22)
      goto LABEL_42;
    goto LABEL_41;
  }
  if (!IOSurfaceLock(buffer, 0, 0))
  {
    dest.data = IOSurfaceGetBaseAddress(buffer);
    dest.height = Height;
    dest.width = Width;
    dest.rowBytes = BytesPerRow;
    v16 = vImageOverwriteChannels_ARGB8888(&src, &dest, &dest, 1u, 0x10u);
    if ((_DWORD)v16)
      _cg_jpeg_mem_term("mergeSoftmask", 3241, "*** ERROR: vImageOverwriteChannels_ARGB8888 failed - err= %d\n", v16);
    vImageClipToAlpha_RGBA8888(&dest, &dest, 0x10u);
    IOSurfaceUnlock(buffer, 0, 0);
    if (!v22)
      goto LABEL_42;
    goto LABEL_41;
  }
  v16 = 0;
  if (v22)
LABEL_41:
    free(v22);
LABEL_42:
  if (v18)
    free(v18);
  return v16;
}

uint64_t ___ZN14IIOImageSource14getCacheValuesEP13IIODictionaryPbS2__block_invoke()
{
  const char *v0;

  v0 = "enabled";
  if ((((unint64_t)gIIODebugFlags >> 30) & 1) == 0)
    v0 = "disabled";
  return _cg_jpeg_mem_term("getCacheValues_block_invoke", 3419, ">>> IMAGEIO_ENABLE_CACHE was set to: %d = caching is %s for all images\n", ((unint64_t)gIIODebugFlags >> 30) & 1, v0);
}

uint64_t IIOImageSource::copyAuxiliaryDataInfoAtIndex(IIOImageSource *this, unint64_t a2, const __CFString *a3, IIODictionary *a4)
{
  const __CFString *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  char v12;
  uint64_t *v13;
  CFStringRef *v14;
  CFComparisonResult v15;
  char v16;
  IIOImagePlus *ImagePlus;
  uint64_t Plugin;
  uint64_t v19;
  uint64_t result;
  uint64_t v22;
  const void *v23;
  const char *v24;
  const __CFDictionary *v25;
  uint64_t v26;
  uint64_t v27;

  IIO_LoadCMPhotoSymbols();
  if (CFStringCompare(CFSTR("kCGImageAuxiliaryDataTypeDisparity"), a3, 0) == kCFCompareEqualTo)
  {
    v8 = *(const __CFString **)gIIO_kCMPhotoAuxiliaryImageTypeURN_Depth;
    v9 = *(_QWORD *)gIIO_kCMPhotoAuxiliaryImageTypeURN_MIAF_Depth;
    v10 = 1;
    goto LABEL_32;
  }
  if (CFStringCompare(CFSTR("kCGImageAuxiliaryDataTypeDepth"), a3, 0) == kCFCompareEqualTo)
  {
    v8 = *(const __CFString **)gIIO_kCMPhotoAuxiliaryImageTypeURN_Depth;
    v9 = *(_QWORD *)gIIO_kCMPhotoAuxiliaryImageTypeURN_MIAF_Depth;
    v10 = 2;
    goto LABEL_32;
  }
  if (CFStringCompare(CFSTR("kCGImageAuxiliaryDataTypeAlpha"), a3, 0) == kCFCompareEqualTo)
  {
    v8 = *(const __CFString **)gIIO_kCMPhotoAuxiliaryImageTypeURN_Alpha;
    v9 = *(_QWORD *)gIIO_kCMPhotoAuxiliaryImageTypeURN_MIAF_Alpha;
    v10 = 3;
    goto LABEL_32;
  }
  if (CFStringCompare(CFSTR("kCGImageAuxiliaryDataTypePortraitEffectsMatte"), a3, 0) == kCFCompareEqualTo)
  {
    v9 = 0;
    v8 = *(const __CFString **)gIIO_kCMPhotoAuxiliaryImageTypeURN_PortraitEffectsMatte;
    v10 = 5;
    goto LABEL_32;
  }
  if (CFStringCompare(CFSTR("kCGImageAuxiliaryDataTypeSemanticSegmentationSkinMatte"), a3, 0))
  {
    if (CFStringCompare(CFSTR("kCGImageAuxiliaryDataTypeSemanticSegmentationHairMatte"), a3, 0))
    {
      if (CFStringCompare(CFSTR("kCGImageAuxiliaryDataTypeSemanticSegmentationTeethMatte"), a3, 0))
      {
        if (CFStringCompare(CFSTR("kCGImageAuxiliaryDataTypeSemanticSegmentationGlassesMatte"), a3, 0))
        {
          if (CFStringCompare(CFSTR("kCGImageAuxiliaryDataTypeSemanticSegmentationSkyMatte"), a3, 0))
          {
            if (CFStringCompare(CFSTR("kCGImageAuxiliaryDataTypeHDRGainMap"), a3, 0))
            {
              v8 = CFSTR("kCGImageAuxiliaryDataTypeISOGainMap");
              if (CFStringCompare(CFSTR("kCGImageAuxiliaryDataTypeISOGainMap"), a3, 0) == kCFCompareEqualTo)
              {
                v9 = 0;
                v10 = 98;
                goto LABEL_32;
              }
              goto LABEL_30;
            }
            v12 = 0;
            v11 = 3;
            v13 = &gIIO_kCMPhotoAuxiliaryImageTypeURN_HDRGainMap;
          }
          else
          {
            v12 = 0;
            v11 = 2;
            v13 = &gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticSkyMatte;
          }
        }
        else
        {
          v12 = 0;
          v11 = 1;
          v13 = &gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticGlassesMatte;
        }
      }
      else
      {
        v11 = 0;
        v12 = 1;
        v13 = &gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticTeethMatte;
      }
    }
    else
    {
      v11 = 0;
      v12 = 1;
      v13 = &gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticHairMatte;
    }
  }
  else
  {
    v11 = 0;
    v12 = 1;
    v13 = &gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticSkinMatte;
  }
  v14 = (CFStringRef *)*v13;
  v8 = *v14;
  if (*v14)
  {
    v15 = CFStringCompare(*v14, CFSTR("FIG_STRING_SYMBOL_NOT_FOUND"), 0);
    if (v15)
      v16 = 1;
    else
      v16 = v12;
    if ((v16 & 1) != 0)
    {
      if (v15)
      {
        v9 = 0;
        v10 = 4;
        goto LABEL_32;
      }
    }
    else
    {
      LogError("copyAuxiliaryDataInfoAtIndex", 3758, "*** ERROR: copyAuxiliaryDataInfoAtIndex - MediaToolbox symbol not found [%d]\n", v11);
    }
LABEL_48:
    v25 = 0;
    v26 = 0;
    v27 = 0;
    IIOString::IIOString((IIOString *)&v25, a3);
    v24 = (const char *)IIOString::utf8String((IIOString *)&v25);
    LogError("copyAuxiliaryDataInfoAtIndex", 3806, "*** ERROR: unsupported auxiliaryDataType: '%s'\n", v24);
    IIOString::~IIOString((IIOString *)&v25);
    return 0;
  }
LABEL_30:
  if ((IIO_OSAppleInternalBuild() & 1) == 0)
    goto LABEL_48;
  v9 = 0;
  v10 = 99;
  v8 = a3;
LABEL_32:
  if (!IIOImageSource::bindToReader(this))
    return 0;
  ImagePlus = (IIOImagePlus *)IIOImageSource::getImagePlus(this, a2);
  if (!ImagePlus)
  {
    v25 = 0;
    v26 = 0;
    v27 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v25);
    v23 = IIOImageSource::makeImagePlus(this, a2, &v25);
    if (v23)
    {
      ImagePlus = (IIOImagePlus *)*((_QWORD *)v23 + 3);
      IIODictionary::~IIODictionary((IIODictionary *)&v25);
      if (ImagePlus)
        goto LABEL_34;
    }
    else
    {
      IIODictionary::~IIODictionary((IIODictionary *)&v25);
    }
    return 0;
  }
LABEL_34:
  Plugin = IIOImagePlus::readPlugin(ImagePlus);
  if (!Plugin)
    goto LABEL_52;
  v19 = Plugin;
  result = (*(uint64_t (**)(uint64_t, uint64_t, const __CFString *, IIODictionary *))(*(_QWORD *)Plugin + 160))(Plugin, v10, v8, a4);
  if (!result && v9 != 0)
    result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, IIODictionary *))(*(_QWORD *)v19 + 160))(v19, v10, v9, a4);
  if (!result)
  {
LABEL_52:
    if ((*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 10) + 192))(*((_QWORD *)this + 10)))
    {
      v22 = IIOImageSource::cf(ImagePlus);
      return (*(uint64_t (**)(_QWORD, uint64_t, unint64_t, const __CFString *))(**((_QWORD **)this + 10)
                                                                                              + 120))(*((_QWORD *)this + 10), v22, a2, a3);
    }
    return 0;
  }
  return result;
}

void sub_187F93D54(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOImageSource::ignoreJPEGAuxImagesRequest(IIOImageSource *this)
{
  return *((char *)this + 51);
}

uint64_t IIOImageSource::animateWithBlock(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t result;

  v6 = operator new();
  IIOImageAnimator::IIOImageAnimator(v6, a1, a3, a2);
  v7 = IIOImageAnimator::setup((IIOImageSource **)v6);
  if ((_DWORD)v7
    || (v7 = IIOImageAnimator::start((IIOImageAnimator *)v6), (_DWORD)v7)
    || (v7 = 0, result = 0, *(_QWORD *)(v6 + 32) == 1))
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
    return v7;
  }
  return result;
}

void sub_187F93E20(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187F93DE8);
}

void sub_187F93E2C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C4081D5CCAALL);
  _Unwind_Resume(a1);
}

IIOImagePlus *IIOImageSource::getAnimationReadPlugin(IIOImageSource *this)
{
  IIOImagePlus *result;

  result = (IIOImagePlus *)IIOImageSource::getImagePlus(this, 0);
  if (result)
    return (IIOImagePlus *)IIOImagePlus::readPlugin(result);
  return result;
}

CFTypeID CGImageSourceGetTypeID(void)
{
  if (CGImageSourceGetTypeID::once != -1)
    dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_139);
  return CGImageSourceGetTypeID::id;
}

CFStringRef _CGImageSourceCopyDescription(_QWORD *a1)
{
  uint64_t v2;
  const char *v3;
  IIO_Reader *v4;
  uint64_t v5;

  if (a1)
  {
    v2 = a1[3];
    v3 = "";
    if (v2)
    {
      if (IIOImageSource::isProxy((IIOImageSource *)a1[3]))
        v3 = "Proxy";
      v4 = *(IIO_Reader **)(v2 + 80);
      if (v4)
      {
        v5 = IIO_Reader::utType(v4);
        if (v5)
          return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<CGImageSource%s: %p> %p '%@'"), v3, a1, v2, v5);
      }
    }
  }
  else
  {
    v2 = 0;
    v3 = "";
  }
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<CGImageSource%s: %p> %p"), v3, a1, v2);
}

CFMutableArrayRef CGImageSourceCopyTypeExtensions(const __CFString *a1)
{
  CFTypeID TypeID;
  CFTypeID v3;
  IIO_ReaderHandler *ReaderHandler;

  IIOInitDebugFlags();
  TypeID = (unsigned __int16)gIIODebugFlags >> 14;
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions(TypeID, "S", "CGImageSourceCopyTypeExtensions", 0, 0, -1, 0);
  if (a1 && (v3 = CFGetTypeID(a1), TypeID = CFStringGetTypeID(), v3 != TypeID))
  {
    LogError("CGImageSourceCopyTypeExtensions", 4254, "*** ERROR: CGImageSourceCopyTypeExtensions: utType is not a CFStringRef\n");
    return 0;
  }
  else
  {
    ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler((IIO_ReaderHandler *)TypeID);
    return IIO_ReaderHandler::copyTypeExtensions(ReaderHandler, a1);
  }
}

const __CFString *CGImageSourceGetTypeWithExtension(const __CFString *a1)
{
  IIO_ReaderHandler *v2;
  IIO_ReaderHandler *ReaderHandler;

  IIOInitDebugFlags();
  v2 = (IIO_ReaderHandler *)((unsigned __int16)gIIODebugFlags >> 14);
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((int)v2, "S", "CGImageSourceGetTypeWithExtension", 0, 0, -1, 0);
  if (!a1)
    return 0;
  ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(v2);
  return IIO_ReaderHandler::typeForPathExtension(ReaderHandler, a1);
}

IIO_Reader *CGImageSourceGetTypeWithDataProvider(uint64_t a1, const __CFString *a2, BOOL *a3)
{
  IIO_ReaderHandler *v6;
  uint64_t ReaderHandler;

  IIOInitDebugFlags();
  v6 = (IIO_ReaderHandler *)((unsigned __int16)gIIODebugFlags >> 14);
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((int)v6, "S", "CGImageSourceGetTypeWithDataProvider", 0, 0, -1, 0);
  ReaderHandler = IIO_ReaderHandler::GetReaderHandler(v6);
  return IIO_ReaderHandler::typeForDataProvider(ReaderHandler, a1, a2, 0, a3);
}

IIO_Reader *CGImageSourceGetTypeWithURL(const void *a1, const __CFString *a2)
{
  IIO_ReaderHandler *v4;
  IIO_ReaderHandler *ReaderHandler;

  IIOInitDebugFlags();
  v4 = (IIO_ReaderHandler *)((unsigned __int16)gIIODebugFlags >> 14);
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((int)v4, "S", "CGImageSourceGetTypeWithURL", 0, 0, -1, 0);
  ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(v4);
  return IIO_ReaderHandler::typeFromURL(ReaderHandler, a1, a2, 0);
}

const void *CGImageSourceCreateWithFile(const __CFString *a1, const void *a2)
{
  CFTypeID v4;
  CFTypeID v5;
  uint64_t v6;
  pthread_mutex_t *v7;
  const void *v8;
  uint64_t v9;
  _QWORD v11[129];

  v11[128] = *MEMORY[0x1E0C80C00];
  IIOInitDebugFlags();
  if (!a1)
  {
    LogError("CGImageSourceCreateWithFile", 4556, "*** ERROR: CGImageSourceCreateWithFile: path is nil\n");
LABEL_16:
    v8 = 0;
    goto LABEL_7;
  }
  v4 = CFGetTypeID(a1);
  if (v4 != CFStringGetTypeID())
  {
    LogError("CGImageSourceCreateWithFile", 4557, "*** ERROR: CGImageSourceCreateWithFile: path is not a CFStringRef\n");
    goto LABEL_16;
  }
  if (a2)
  {
    v5 = CFGetTypeID(a2);
    if (v5 != CFDictionaryGetTypeID())
    {
      LogError("CGImageSourceCreateWithFile", 4560, "*** ERROR: CGImageSourceCreateWithFile: options parameter is not a CFDictionaryRef - ignoring\n");
      a2 = 0;
    }
  }
  memset(v11, 0, 24);
  IIODictionary::IIODictionary((IIODictionary *)v11, (const __CFDictionary *)a2);
  v6 = operator new();
  IIOImageSource::IIOImageSource((IIOImageSource *)v6, a1, (IIODictionary *)v11);
  v7 = (pthread_mutex_t *)(v6 + 200);
  pthread_mutex_lock((pthread_mutex_t *)(v6 + 200));
  v8 = (const void *)CGImageSourceRefCreateWith_ImageSource(v6);
  pthread_mutex_unlock(v7);
  IIODictionary::~IIODictionary((IIODictionary *)v11);
LABEL_7:
  v9 = gIIODebugFlags;
  if ((gIIODebugFlags & 0x3000) != 0)
  {
    bzero(v11, 0x400uLL);
    _CFStringGetFileSystemRepresentation();
    v9 = gIIODebugFlags;
    if ((unsigned __int16)gIIODebugFlags >> 14)
    {
      ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageSourceCreateWithFile", v8, (const char *)v11, -1, (const __CFDictionary *)a2);
      v9 = gIIODebugFlags;
    }
  }
  if ((v9 & 0x800000000000) != 0 && !v8)
    ImageIOLog(" ISSUE: %s:%d:  %s\n", "CGImageSourceCreateWithFile", 4583, "could not create CGImageSourceRef");
  return v8;
}

void sub_187F94360(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v4;
  va_list va;

  va_start(va, a4);
  MEMORY[0x18D761C30](v4, 0x10E1C40B803A584);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void CGImageSourceUpdateDataProvider(CGImageSourceRef isrc, CGDataProviderRef provider, BOOL final)
{
  _BOOL8 v3;
  unsigned int v6;
  CFTypeID v7;
  CFTypeID v8;
  uint64_t v9;
  IIO_Reader *v10;
  IIOImageSource *Source;

  v3 = final;
  kdebug_trace();
  IIOInitDebugFlags();
  v6 = (gIIODebugFlags >> 12) & 3;
  if (v6)
    ImageIODebugOptions(v6, "A", "CGImageSourceUpdateDataProvider", 0, 0, -1, 0);
  if (isrc)
  {
    if (provider)
    {
      v7 = CFGetTypeID(isrc);
      if (CGImageSourceGetTypeID::once != -1)
        dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_139);
      if (v7 == CGImageSourceGetTypeID::id)
      {
        v8 = CFGetTypeID(provider);
        if (v8 == CGDataProviderGetTypeID())
        {
          v9 = *((_QWORD *)isrc + 3);
          if (v9 && !IIOImageSource::isProxy(*((IIOImageSource **)isrc + 3)))
          {
            pthread_mutex_lock((pthread_mutex_t *)(v9 + 200));
            IIOImageSource::updateDataProvider((IIOImageSource *)v9, provider, (CGDataProvider *)v3);
            v10 = *(IIO_Reader **)(v9 + 80);
            if (v10)
              IIO_Reader::osType(v10);
            Source = (IIOImageSource *)CGImageSourceGetSource(*(_QWORD *)(v9 + 16));
            if (Source)
              IIOImageSource::reader(Source);
            pthread_mutex_unlock((pthread_mutex_t *)(v9 + 200));
          }
        }
        else
        {
          LogError("CGImageSourceUpdateDataProvider", 4643, "*** ERROR: CGImageSourceUpdateDataProvider: dataProvider is not a CGDataProviderRef\n");
        }
      }
      else
      {
        LogError("CGImageSourceUpdateDataProvider", 4642, "*** ERROR: CGImageSourceUpdateDataProvider: source is not a CGImageSourceRef\n");
      }
    }
    else
    {
      LogError("CGImageSourceUpdateDataProvider", 4641, "*** ERROR: CGImageSourceUpdateDataProvider: dataProvider is nil\n");
    }
  }
  else
  {
    LogError("CGImageSourceUpdateDataProvider", 4640, "*** ERROR: CGImageSourceUpdateDataProvider: source is nil\n");
  }
  kdebug_trace();
}

uint64_t CGImageSourceAddProperty(uint64_t a1, const __CFString *a2, const __CFString *a3, const void *a4)
{
  IIOImageSource *v8;
  IIO_Reader *v10;

  kdebug_trace();
  IIOInitDebugFlags();
  if (a1 && (v8 = *(IIOImageSource **)(a1 + 24)) != 0 && !IIOImageSource::isProxy(v8))
  {
    IIOImageSource::addProperty(v8, a2, a3, a4);
    v10 = (IIO_Reader *)*((_QWORD *)v8 + 10);
    if (v10)
      IIO_Reader::osType(v10);
  }
  else
  {
    LogError("CGImageSourceAddProperty", 4818, "image source parameter is nil\n");
  }
  return kdebug_trace();
}

CGImage *CGImageSourceIsColorOptimizedForSharing(_QWORD *a1, const void *a2)
{
  int v4;
  CFTypeID v5;
  CFTypeID v6;
  CFSetRef *v7;
  CGImage *v8;
  const __CFDictionary *v10[3];

  IIOInitDebugFlags();
  v4 = (unsigned __int16)gIIODebugFlags >> 14;
  if ((v4 & (gIIODebugFlags >> 12)) != 0)
    ImageIODebugOptions(v4, "A", "CGImageSourceIsColorOptimizedForSharing", a1, 0, -1, 0);
  if (a1)
  {
    v5 = CFGetTypeID(a1);
    if (CGImageSourceGetTypeID::once != -1)
      dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_139);
    if (v5 == CGImageSourceGetTypeID::id)
    {
      if (a2)
      {
        v6 = CFGetTypeID(a2);
        if (v6 != CFDictionaryGetTypeID())
        {
          LogError("CGImageSourceIsColorOptimizedForSharing", 4884, "*** ERROR: CGImageSourceIsColorOptimizedForSharing: options parameter is not a CFDictionaryRef - ignoring\n");
          a2 = 0;
        }
      }
      v7 = (CFSetRef *)a1[3];
      if (v7 && !IIOImageSource::isProxy((IIOImageSource *)v7))
      {
        memset(v10, 0, sizeof(v10));
        IIODictionary::IIODictionary((IIODictionary *)v10, (const __CFDictionary *)a2);
        v8 = IIOImageSource::isColorOptimizedForSharing(v7, v10);
        IIODictionary::~IIODictionary((IIODictionary *)v10);
        return v8;
      }
    }
    else
    {
      LogError("CGImageSourceIsColorOptimizedForSharing", 4881, "*** ERROR: CGImageSourceIsColorOptimizedForSharing: source is not a CGImageSourceRef\n");
    }
  }
  else
  {
    LogError("CGImageSourceIsColorOptimizedForSharing", 4880, "*** ERROR: CGImageSourceIsColorOptimizedForSharing: source is nil\n");
  }
  return 0;
}

void sub_187F947E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void CGImageSourceRemoveCacheAtIndex(CGImageSourceRef isrc, size_t index)
{
  unsigned int v4;
  CFTypeID v5;
  uint64_t v6;
  uint64_t Source;

  kdebug_trace();
  IIOInitDebugFlags();
  v4 = (gIIODebugFlags >> 12) & 3;
  if (v4)
    ImageIODebugOptions(v4, "A", "CGImageSourceRemoveCacheAtIndex", isrc, 0, index, 0);
  if (isrc)
  {
    v5 = CFGetTypeID(isrc);
    if (CGImageSourceGetTypeID::once != -1)
      dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_139);
    if (v5 == CGImageSourceGetTypeID::id)
    {
      if (!CGImageSourceIsProxy((uint64_t)isrc))
      {
        v6 = *((_QWORD *)isrc + 3);
        if (v6)
        {
          Source = CGImageSourceGetSource(*(_QWORD *)(v6 + 16));
          if (Source)
            IIOImageRead::removeCacheKey(Source, index);
        }
      }
    }
    else
    {
      LogError("CGImageSourceRemoveCacheAtIndex", 4912, "*** ERROR: CGImageSourceRemoveCacheAtIndex: source is not a CGImageSourceRef\n");
    }
  }
  else
  {
    LogError("CGImageSourceRemoveCacheAtIndex", 4911, "*** ERROR: CGImageSourceRemoveCacheAtIndex: source is nil\n");
  }
  kdebug_trace();
}

uint64_t IIOPackSrcInputInfo(IIODictionary *a1, unsigned __int16 a2)
{
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  const __CFString *ObjectForKey;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unsigned int Uint32ForKey;

  if (a1)
  {
    if (IIODictionary::containsKey(a1, CFSTR("kCGImageSourceCreateThumbnailFromImageAlways")))
    {
      if (IIODictionary::getBoolForKey(a1, CFSTR("kCGImageSourceCreateThumbnailFromImageAlways")))
        v4 = 0x4000000000000000;
      else
        v4 = 0;
    }
    else
    {
      v4 = 0x8000000000000000;
    }
    if (IIODictionary::containsKey(a1, CFSTR("kCGImageSourceCreateThumbnailFromImageIfAbsent")))
    {
      if (IIODictionary::getBoolForKey(a1, CFSTR("kCGImageSourceCreateThumbnailFromImageIfAbsent")))
        v4 |= 0x1000000000000000uLL;
    }
    else
    {
      v4 |= 0x2000000000000000uLL;
    }
    if (IIODictionary::containsKey(a1, CFSTR("kCGImageSourceCreateThumbnailWithTransform")))
    {
      if (IIODictionary::getBoolForKey(a1, CFSTR("kCGImageSourceCreateThumbnailWithTransform")))
        v4 |= 0x400000000000000uLL;
    }
    else
    {
      v4 |= 0x800000000000000uLL;
    }
    v6 = v4 | (((unint64_t)IIODictionary::getUint32ForKey(a1, CFSTR("Orientation")) & 0xF) << 54);
    v7 = v6 | (((unint64_t)IIODictionary::getUint32ForKeyGroup(a1, CFSTR("Orientation"), CFSTR("{TIFF}")) & 0xF) << 50);
    if (IIODictionary::containsKey(a1, CFSTR("kCGImageSourceSubsampleFactor")))
      v8 = ((unint64_t)IIODictionary::getUint32ForKey(a1, CFSTR("kCGImageSourceSubsampleFactor")) & 0x3F) << 44;
    else
      v8 = 0x3F00000000000;
    v9 = v7 | v8;
    if (IIODictionary::containsKey(a1, CFSTR("kCGImageSourceDecodeRequest")))
    {
      ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey(a1, CFSTR("kCGImageSourceDecodeRequest"));
      if (CFStringCompare(ObjectForKey, CFSTR("kCGImageSourceDecodeToHDR"), 0))
        v11 = (unint64_t)(CFStringCompare(ObjectForKey, CFSTR("kCGImageSourceDecodeToSDR"), 0) == kCFCompareEqualTo) << 41;
      else
        v11 = 0x10000000000;
      v13 = v11 | v9;
      if (IIODictionary::containsKeyGroup(a1, CFSTR("kCGGenerateFlexGTC"), CFSTR("kCGImageSourceDecodeRequestOptions")))
      {
        if (IIODictionary::getBoolForKeyGroup(a1, CFSTR("kCGGenerateFlexGTC"), CFSTR("kCGImageSourceDecodeRequestOptions")))v12 = v13 | 0x4000000000;
        else
          v12 = v13;
      }
      else
      {
        v12 = v13 | 0x8000000000;
      }
    }
    else
    {
      v12 = v9 | 0xF8000000000;
    }
    Uint32ForKey = IIODictionary::getUint32ForKey(a1, CFSTR("kCGImageSourceThumbnailMaxPixelSize"));
    if (!Uint32ForKey)
      Uint32ForKey = IIODictionary::getUint32ForKey(a1, CFSTR("kCGImageDestinationImageMaxPixelSize"));
    v5 = v12 | (Uint32ForKey << 16);
  }
  else
  {
    v5 = 0;
  }
  return v5 | a2;
}

uint64_t CGImageSourceGetImageCacheAtIndex(IIOImageSource **a1, unint64_t a2, const __CFDictionary *a3)
{
  CFTypeID v6;
  CFTypeID v7;
  IIOImageSource *v8;
  uint64_t ImageCacheAtIndex;
  IIO_Reader *v10;
  const __CFDictionary *v12[3];

  IIOInitDebugFlags();
  memset(v12, 0, sizeof(v12));
  IIODictionary::IIODictionary((IIODictionary *)v12, a3);
  IIOPackSrcInputInfo((IIODictionary *)v12, a2);
  kdebug_trace();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageSourceGetImageCacheAtIndex", a1, 0, -1, a3);
  if (!a1)
  {
    LogError("CGImageSourceGetImageCacheAtIndex", 5136, "*** ERROR: CGImageSourceGetImageCacheAtIndex: source is nil\n");
LABEL_12:
    ImageCacheAtIndex = 0;
    goto LABEL_18;
  }
  v6 = CFGetTypeID(a1);
  if (CGImageSourceGetTypeID::once != -1)
    dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_139);
  if (v6 != CGImageSourceGetTypeID::id)
  {
    LogError("CGImageSourceGetImageCacheAtIndex", 5137, "*** ERROR: CGImageSourceGetImageCacheAtIndex: source is not a CGImageSourceRef\n");
    goto LABEL_12;
  }
  if (a3)
  {
    v7 = CFGetTypeID(a3);
    if (v7 != CFDictionaryGetTypeID())
      LogError("CGImageSourceGetImageCacheAtIndex", 5140, "*** ERROR: CGImageSourceGetImageCacheAtIndex: options parameter is not a CFDictionaryRef - ignoring\n");
  }
  v8 = a1[3];
  if (!v8)
  {
    ImageCacheAtIndex = 0;
    goto LABEL_18;
  }
  if (IIOImageSource::isProxy(a1[3]))
    goto LABEL_12;
  if (*((_BYTE *)v8 + 65))
  {
    LogError("CGImageSourceGetImageCacheAtIndex", 5147, "*** ERROR: invalid CGImageSourceRef (non-matching hint)\n");
    goto LABEL_12;
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)v8 + 200));
  ImageCacheAtIndex = IIOImageSource::getImageCacheAtIndex(v8, a2, v12);
  v10 = (IIO_Reader *)*((_QWORD *)v8 + 10);
  if (v10)
    IIO_Reader::osType(v10);
  pthread_mutex_unlock((pthread_mutex_t *)((char *)v8 + 200));
LABEL_18:
  kdebug_trace();
  IIODictionary::~IIODictionary((IIODictionary *)v12);
  return ImageCacheAtIndex;
}

void sub_187F94DAC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

CGImageMetadataRef CGImageSourceCopyMetadataAtIndex(CGImageSourceRef isrc, size_t index, CFDictionaryRef options)
{
  unsigned int v6;
  CFTypeID v7;
  CFTypeID v8;
  uint64_t v9;
  const CGImageMetadata *v10;
  IIO_Reader *v11;
  const __CFDictionary *v13[3];

  kdebug_trace();
  IIOInitDebugFlags();
  v6 = (gIIODebugFlags >> 12) & 3;
  if (v6)
    ImageIODebugOptions(v6, "A", "CGImageSourceCopyMetadataAtIndex", isrc, 0, index, options);
  if (!isrc)
  {
    LogError("CGImageSourceCopyMetadataAtIndex", 5227, "*** ERROR: CGImageSourceCopyMetadataAtIndex: source is nil\n");
LABEL_12:
    v10 = 0;
    goto LABEL_16;
  }
  v7 = CFGetTypeID(isrc);
  if (CGImageSourceGetTypeID::once != -1)
    dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_139);
  if (v7 != CGImageSourceGetTypeID::id)
  {
    LogError("CGImageSourceCopyMetadataAtIndex", 5228, "*** ERROR: CGImageSourceCopyMetadataAtIndex: source is not a CGImageSourceRef\n");
    goto LABEL_12;
  }
  if (options)
  {
    v8 = CFGetTypeID(options);
    if (v8 != CFDictionaryGetTypeID())
    {
      LogError("CGImageSourceCopyMetadataAtIndex", 5231, "*** ERROR: CGImageSourceCopyMetadataAtIndex: options parameter is not a CFDictionaryRef - ignoring\n");
      options = 0;
    }
  }
  v9 = *((_QWORD *)isrc + 3);
  if (!v9 || IIOImageSource::isProxy((IIOImageSource *)v9))
    goto LABEL_12;
  memset(v13, 0, sizeof(v13));
  IIODictionary::IIODictionary((IIODictionary *)v13, options);
  pthread_mutex_lock((pthread_mutex_t *)(v9 + 200));
  v11 = *(IIO_Reader **)(v9 + 80);
  if (v11)
    IIO_Reader::osType(v11);
  v10 = (const CGImageMetadata *)IIOImageSource::copyMetadataAtIndex((IIOImageSource *)v9, index, v13);
  pthread_mutex_unlock((pthread_mutex_t *)(v9 + 200));
  IIODictionary::~IIODictionary((IIODictionary *)v13);
LABEL_16:
  if ((gIIODebugFlags & 0x800000000000) != 0 && !v10)
    ImageIOLog(" ISSUE: %s:%d:  %s\n", "CGImageSourceCopyMetadataAtIndex", 5247, "could not create CGImageMetadataRef");
  kdebug_trace();
  return v10;
}

void sub_187F94FE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

__CFArray *CGImageSourceCopyMetadataPropertiesAtIndex(IIOImageSource **a1, unint64_t a2, const __CFDictionary *a3)
{
  CFTypeID v6;
  CFTypeID v7;
  IIOImageSource *v8;
  __CFArray *v9;
  IIO_Reader *v10;
  const __CFDictionary *v12[3];
  unsigned int v13;

  kdebug_trace();
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageSourceCopyMetadataPropertiesAtIndex", a1, 0, -1, a3);
  if (!a1)
  {
    LogError("CGImageSourceCopyMetadataPropertiesAtIndex", 5267, "*** ERROR: CGImageSourceCopyMetadataPropertiesAtIndex: source is nil\n");
LABEL_12:
    v9 = 0;
    goto LABEL_20;
  }
  v6 = CFGetTypeID(a1);
  if (CGImageSourceGetTypeID::once != -1)
    dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_139);
  if (v6 != CGImageSourceGetTypeID::id)
  {
    LogError("CGImageSourceCopyMetadataPropertiesAtIndex", 5268, "*** ERROR: CGImageSourceCopyMetadataPropertiesAtIndex: source is not a CGImageSourceRef\n");
    goto LABEL_12;
  }
  if (a3)
  {
    v7 = CFGetTypeID(a3);
    if (v7 != CFDictionaryGetTypeID())
    {
      LogError("CGImageSourceCopyMetadataPropertiesAtIndex", 5271, "*** ERROR: CGImageSourceCopyMetadataPropertiesAtIndex: options parameter is not a CFDictionaryRef - ignoring\n");
      a3 = 0;
    }
  }
  v8 = a1[3];
  if (!v8 || IIOImageSource::isProxy(a1[3]))
    goto LABEL_12;
  if (*((_BYTE *)v8 + 65))
  {
    LogError("CGImageSourceCopyMetadataPropertiesAtIndex", 5278, "*** ERROR: invalid CGImageSourceRef (non-matching hint)\n");
    goto LABEL_12;
  }
  v13 = 1;
  pthread_mutex_lock((pthread_mutex_t *)((char *)v8 + 200));
  if (a3)
  {
    memset(v12, 0, sizeof(v12));
    IIODictionary::IIODictionary((IIODictionary *)v12, a3);
    v9 = IIOImageSource::copyMetadataPropertiesAtIndex(v8, a2, v12, &v13);
    IIODictionary::~IIODictionary((IIODictionary *)v12);
  }
  else
  {
    v9 = 0;
  }
  v10 = (IIO_Reader *)*((_QWORD *)v8 + 10);
  if (v10)
    IIO_Reader::osType(v10);
  pthread_mutex_unlock((pthread_mutex_t *)((char *)v8 + 200));
LABEL_20:
  if ((gIIODebugFlags & 0x800000000000) != 0 && !v9)
    ImageIOLog(" ISSUE: %s:%d:  %s\n", "CGImageSourceCopyMetadataPropertiesAtIndex", 5293, "*** ERROR: CGImageSourceCopyMetadataPropertiesAtIndex returned NULL\n");
  kdebug_trace();
  return v9;
}

void sub_187F95268(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

__IOSurface *CGImageSourceCreateIOSurfaceAtIndex(IIOImageSource **a1, unint64_t a2, const __CFDictionary *a3)
{
  CFTypeID v6;
  CFTypeID v7;
  IIOImageSource *v8;
  __IOSurface *IOSurfaceAtIndex;
  IIO_Reader *v11;
  const __CFDictionary *v12[3];

  IIOInitDebugFlags();
  memset(v12, 0, sizeof(v12));
  IIODictionary::IIODictionary((IIODictionary *)v12, a3);
  IIOPackSrcInputInfo((IIODictionary *)v12, a2);
  kdebug_trace();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageSourceCreateIOSurfaceAtIndex", a1, 0, -1, a3);
  if (a1)
  {
    v6 = CFGetTypeID(a1);
    if (CGImageSourceGetTypeID::once != -1)
      dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_139);
    if (v6 == CGImageSourceGetTypeID::id)
    {
      if (a3)
      {
        v7 = CFGetTypeID(a3);
        if (v7 != CFDictionaryGetTypeID())
          LogError("CGImageSourceCreateIOSurfaceAtIndex", 5323, "*** ERROR: CGImageSourceCreateIOSurfaceAtIndex: options parameter is not a CFDictionaryRef - ignoring\n");
      }
      v8 = a1[3];
      if (v8 && !IIOImageSource::isProxy(a1[3]))
      {
        if (*((_BYTE *)v8 + 65))
        {
          LogError("CGImageSourceCreateIOSurfaceAtIndex", 5330, "*** ERROR: invalid CGImageSourceRef (non-matching hint)\n");
        }
        else
        {
          pthread_mutex_lock((pthread_mutex_t *)((char *)v8 + 200));
          IOSurfaceAtIndex = IIOImageSource::createIOSurfaceAtIndex(v8, a2, v12);
          v11 = (IIO_Reader *)*((_QWORD *)v8 + 10);
          if (v11)
            IIO_Reader::osType(v11);
          pthread_mutex_unlock((pthread_mutex_t *)((char *)v8 + 200));
          if (IOSurfaceAtIndex)
          {
            IOSurfaceGetWidth(IOSurfaceAtIndex);
            IOSurfaceGetHeight(IOSurfaceAtIndex);
            IOSurfaceGetPixelFormat(IOSurfaceAtIndex);
            goto LABEL_15;
          }
        }
      }
    }
    else
    {
      LogError("CGImageSourceCreateIOSurfaceAtIndex", 5320, "*** ERROR: CGImageSourceCreateIOSurfaceAtIndex: source is not a CGImageSourceRef\n");
    }
  }
  else
  {
    LogError("CGImageSourceCreateIOSurfaceAtIndex", 5319, "*** ERROR: CGImageSourceCreateIOSurfaceAtIndex: source is nil\n");
  }
  if ((gIIODebugFlags & 0x800000000000) != 0)
    ImageIOLog(" ISSUE: %s:%d:  %s\n", "CGImageSourceCreateIOSurfaceAtIndex", 5344, "could not create IOSurfaceRef");
  IOSurfaceAtIndex = 0;
LABEL_15:
  kdebug_trace();
  IIODictionary::~IIODictionary((IIODictionary *)v12);
  return IOSurfaceAtIndex;
}

void sub_187F954D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

CFDictionaryRef CGImageSourceCopyAuxiliaryDataInfoAtIndex(CGImageSourceRef isrc, size_t index, CFStringRef auxiliaryImageDataType)
{
  return (CFDictionaryRef)CGImageSourceCopyAuxiliaryDataInfoAtIndexWithOptions(isrc, index, auxiliaryImageDataType, 0);
}

const __CFString *CGImageSourceCopyAuxiliaryDataInfoAtIndexWithOptions(_QWORD *a1, unint64_t a2, const __CFString *a3, const __CFDictionary *a4)
{
  unsigned int v8;
  const char *v9;
  CFTypeID v10;
  CFTypeID v11;
  uint64_t v12;
  IIO_Reader *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  IIOInitDebugFlags();
  if (a3 && CFStringCompare(a3, CFSTR("kCGImageAuxiliaryDataTypeHDRGainMap"), 0))
    CFStringCompare(a3, CFSTR("kCGImageAuxiliaryDataTypeISOGainMap"), 0);
  kdebug_trace();
  if ((gIIODebugFlags & 0x3000) != 0)
  {
    v15 = 0;
    v16 = 0;
    v17 = 0;
    IIOString::IIOString((IIOString *)&v15, a3);
    v8 = (gIIODebugFlags >> 12) & 3;
    if (v8)
    {
      v9 = (const char *)IIOString::utf8String((IIOString *)&v15);
      ImageIODebugOptions(v8, "A", "CGImageSourceCopyAuxiliaryDataInfoAtIndexWithOptions", a1, v9, a2, 0);
    }
    IIOString::~IIOString((IIOString *)&v15);
  }
  if (!a1)
  {
    LogError("CGImageSourceCopyAuxiliaryDataInfoAtIndexWithOptions", 5491, "*** ERROR: CGImageSourceCopyAuxiliaryDataInfoAtIndex: source is nil\n");
LABEL_16:
    a3 = 0;
    goto LABEL_22;
  }
  if (!a3)
  {
    LogError("CGImageSourceCopyAuxiliaryDataInfoAtIndexWithOptions", 5492, "*** ERROR: CGImageSourceCopyAuxiliaryDataInfoAtIndex: auxiliaryDataType is nil\n");
    goto LABEL_22;
  }
  v10 = CFGetTypeID(a1);
  if (CGImageSourceGetTypeID::once != -1)
    dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_139);
  if (v10 != CGImageSourceGetTypeID::id)
  {
    LogError("CGImageSourceCopyAuxiliaryDataInfoAtIndexWithOptions", 5493, "*** ERROR: CGImageSourceCopyAuxiliaryDataInfoAtIndex: source is not a CGImageSourceRef\n");
    goto LABEL_16;
  }
  v11 = CFGetTypeID(a3);
  if (v11 != CFStringGetTypeID())
  {
    LogError("CGImageSourceCopyAuxiliaryDataInfoAtIndexWithOptions", 5494, "*** ERROR: CGImageSourceCopyAuxiliaryDataInfoAtIndex: auxiliaryDataType is not a CFStringRef\n");
    goto LABEL_16;
  }
  v12 = a1[3];
  if (!v12 || IIOImageSource::isProxy((IIOImageSource *)v12))
    goto LABEL_16;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v15, a4);
  if (*(_BYTE *)(v12 + 65))
  {
    LogError("CGImageSourceCopyAuxiliaryDataInfoAtIndexWithOptions", 5500, "*** ERROR: invalid CGImageSourceRef (non-matching hint)\n");
    a3 = 0;
  }
  else
  {
    pthread_mutex_lock((pthread_mutex_t *)(v12 + 200));
    a3 = (const __CFString *)IIOImageSource::copyAuxiliaryDataInfoAtIndex((IIOImageSource *)v12, a2, a3, (IIODictionary *)&v15);
    v13 = *(IIO_Reader **)(v12 + 80);
    if (v13)
      IIO_Reader::osType(v13);
    pthread_mutex_unlock((pthread_mutex_t *)(v12 + 200));
  }
  IIODictionary::~IIODictionary((IIODictionary *)&v15);
LABEL_22:
  if ((gIIODebugFlags & 0x800000000000) != 0 && !a3)
    ImageIOLog(" ISSUE: %s:%d:  %s\n", "CGImageSourceCopyAuxiliaryDataInfoAtIndexWithOptions", 5509, "could not create AuxiliaryDataInfo dictionary");
  kdebug_trace();
  return a3;
}

void sub_187F957FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t CGImageSourceIsCloudTranscodable(_QWORD *a1, const __CFDictionary *a2)
{
  uint64_t v4;
  uint64_t isCloudTranscodable;
  pthread_mutex_t *v6;
  const __CFDictionary *v8[3];

  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageSourceIsCloudTranscodable", a1, 0, -1, a2);
  memset(v8, 0, sizeof(v8));
  IIODictionary::IIODictionary((IIODictionary *)v8, a2);
  if (a1)
  {
    v4 = a1[3];
    if (v4 && !IIOImageSource::isProxy((IIOImageSource *)v4))
    {
      v6 = (pthread_mutex_t *)(v4 + 200);
      pthread_mutex_lock((pthread_mutex_t *)(v4 + 200));
      isCloudTranscodable = IIOImageSource::isCloudTranscodable((IIO_Reader **)v4, v8);
      pthread_mutex_unlock(v6);
      goto LABEL_8;
    }
  }
  else
  {
    LogError("CGImageSourceIsCloudTranscodable", 5526, "*** ERROR: CGImageSourceIsCloudTranscodable: source is NULL\n");
  }
  isCloudTranscodable = 4294967292;
LABEL_8:
  IIODictionary::~IIODictionary((IIODictionary *)v8);
  return isCloudTranscodable;
}

void sub_187F95904(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t CGImageSourceCanAnimate(uint64_t a1)
{
  uint64_t v2;
  pthread_mutex_t *v4;
  uint64_t canAnimate;

  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageSourceCanAnimate", 0, 0, -1, 0);
  if (!a1)
  {
    LogError("CGImageSourceCanAnimate", 5554, "*** ERROR: CGImageSourceCanAnimate: source is NULL\n");
    return 4294967292;
  }
  v2 = *(_QWORD *)(a1 + 24);
  if (!v2 || IIOImageSource::isProxy((IIOImageSource *)v2))
    return 4294967292;
  if (*(_BYTE *)(v2 + 65))
  {
    LogError("CGImageSourceCanAnimate", 5559, "*** ERROR: invalid CGImageSourceRef (non-matching hint)\n");
    return 4294967292;
  }
  v4 = (pthread_mutex_t *)(v2 + 200);
  pthread_mutex_lock((pthread_mutex_t *)(v2 + 200));
  canAnimate = IIOImageSource::canAnimate((IIO_Reader **)v2);
  pthread_mutex_unlock(v4);
  return canAnimate;
}

uint64_t CGImageIsDecodable(const __CFDictionary *a1, const __CFDictionary *a2)
{
  CFTypeID v4;
  uint64_t v5;
  _QWORD v7[3];
  _QWORD v8[3];

  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageIsDecodable", 0, 0, -1, a2);
  memset(v8, 0, sizeof(v8));
  IIODictionary::IIODictionary((IIODictionary *)v8, a1);
  memset(v7, 0, sizeof(v7));
  IIODictionary::IIODictionary((IIODictionary *)v7, a2);
  if (!a1)
  {
    LogError("CGImageIsDecodable", 5581, "*** ERROR: CGImageIsDecodable: property dictionary is NULL\n");
LABEL_18:
    v5 = 4294967292;
    goto LABEL_10;
  }
  v4 = CFGetTypeID(a1);
  if (v4 != CFDictionaryGetTypeID())
  {
    LogError("CGImageIsDecodable", 5582, "*** ERROR: CGImageIsDecodable: property parameter is not a CFDictionary\n");
    goto LABEL_18;
  }
  if (!IIODictionary::containsKey((IIODictionary *)v8, CFSTR("ColorModel")))
  {
    _cg_jpeg_mem_term("CGImageIsDecodable", 5584, "*** dictionary contains no 'ColorModel'\n");
    goto LABEL_18;
  }
  if (!IIODictionary::containsKey((IIODictionary *)v8, CFSTR("PixelHeight")))
  {
    _cg_jpeg_mem_term("CGImageIsDecodable", 5585, "*** dictionary contains no 'PixelHeight'\n");
    goto LABEL_18;
  }
  if (!IIODictionary::containsKey((IIODictionary *)v8, CFSTR("PixelWidth")))
  {
    _cg_jpeg_mem_term("CGImageIsDecodable", 5586, "*** dictionary contains no 'PixelWidth'\n");
    goto LABEL_18;
  }
  if ((IIODictionary::containsKey((IIODictionary *)v8, CFSTR("Depth")) & 1) == 0)
  {
    _cg_jpeg_mem_term("CGImageIsDecodable", 5587, "*** dictionary contains no 'Depth'\n");
    goto LABEL_18;
  }
  v5 = 0;
LABEL_10:
  IIODictionary::~IIODictionary((IIODictionary *)v7);
  IIODictionary::~IIODictionary((IIODictionary *)v8);
  return v5;
}

void sub_187F95B7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

CGImage *CGImageGetHash(CGImage *Hash)
{
  kdebug_trace();
  IIOInitDebugFlags();
  if ((~(_DWORD)gIIODebugFlags & 0xC000) == 0)
    ImageIODebugOptions(3, "S", "CGImageGetHash", 0, 0, -1, 0);
  if (Hash)
    Hash = IIOImageSource::CGImageGetHash(Hash, 0);
  else
    _cg_jpeg_mem_term("CGImageGetHash", 5692, "*** ERROR: CGImageGetHash - image is NULL\n");
  kdebug_trace();
  return Hash;
}

uint64_t CGImageSourceDisableRAWDecoding()
{
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageSourceDisableRAWDecoding", 0, 0, -1, 0);
  return IIODisableRAWDecoding();
}

uint64_t CGImageSourceDisableMetadataParsing()
{
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageSourceDisableMetadataParsing", 0, 0, -1, 0);
  return IIODisableMetadataParsing();
}

uint64_t CGImageSourceDisableCaching()
{
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageSourceDisableCaching", 0, 0, -1, 0);
  return IIODisableCaching();
}

uint64_t *std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  _BYTE *v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *((_BYTE *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      v2 = (uint64_t *)a2[2];
      if (*((_BYTE *)v2 + 24))
        return result;
      v3 = (uint64_t *)v2[2];
      v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), v5 = (_BYTE *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            v9 = (uint64_t **)a2[2];
          }
          else
          {
            v9 = (uint64_t **)v2[1];
            v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = v9;
            *v9 = v2;
            v2[2] = (uint64_t)v9;
            v3 = v9[2];
            v2 = (uint64_t *)*v3;
          }
          *((_BYTE *)v9 + 24) = 1;
          *((_BYTE *)v3 + 24) = 0;
          v13 = v2[1];
          *v3 = v13;
          if (v13)
            *(_QWORD *)(v13 + 16) = v3;
          v2[2] = v3[2];
          *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          v11 = a2[1];
          *v2 = v11;
          if (v11)
          {
            *(_QWORD *)(v11 + 16) = v2;
            v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((_BYTE *)a2 + 24) = 1;
        *((_BYTE *)v3 + 24) = 0;
        v2 = (uint64_t *)v3[1];
        v12 = *v2;
        v3[1] = *v2;
        if (v12)
          *(_QWORD *)(v12 + 16) = v3;
        v2[2] = v3[2];
        *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
        *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((_BYTE *)v2 + 24) = 1;
      a2 = v3;
      *((_BYTE *)v3 + 24) = v3 == result;
      *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

uint64_t *std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t *v4;
  int v5;
  uint64_t **v6;
  uint64_t *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t *v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v2 = *a2;
  v3 = a2;
  if (*a2)
  {
    v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      v3 = a2;
      goto LABEL_7;
    }
    do
    {
      v3 = v4;
      v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  v2 = v3[1];
  if (v2)
  {
LABEL_7:
    v5 = 0;
    *(_QWORD *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  v5 = 1;
LABEL_8:
  v6 = (uint64_t **)v3[2];
  v7 = *v6;
  if (*v6 == v3)
  {
    *v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      v7 = 0;
      result = (uint64_t *)v2;
    }
    else
    {
      v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    v9 = a2[2];
    v3[2] = v9;
    *(_QWORD *)(v9 + 8 * (*(_QWORD *)a2[2] != (_QWORD)a2)) = v3;
    v11 = *a2;
    v10 = a2[1];
    *(_QWORD *)(v11 + 16) = v3;
    *v3 = v11;
    v3[1] = v10;
    if (v10)
      *(_QWORD *)(v10 + 16) = v3;
    *((_BYTE *)v3 + 24) = *((_BYTE *)a2 + 24);
    if (result == a2)
      result = v3;
  }
  if (!v8 || !result)
    return result;
  if (!v5)
  {
    *(_BYTE *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    v12 = v7[2];
    if (*(uint64_t **)v12 == v7)
      break;
    if (!*((_BYTE *)v7 + 24))
    {
      *((_BYTE *)v7 + 24) = 1;
      *(_BYTE *)(v12 + 24) = 0;
      v13 = *(uint64_t **)(v12 + 8);
      v14 = *v13;
      *(_QWORD *)(v12 + 8) = *v13;
      if (v14)
        *(_QWORD *)(v14 + 16) = v12;
      v13[2] = *(_QWORD *)(v12 + 16);
      *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v13;
      *v13 = v12;
      *(_QWORD *)(v12 + 16) = v13;
      if (result == (uint64_t *)*v7)
        result = v7;
      v7 = *(uint64_t **)(*v7 + 8);
    }
    v15 = (_QWORD *)*v7;
    if (*v7 && !*((_BYTE *)v15 + 24))
    {
      v16 = (uint64_t *)v7[1];
      if (!v16)
        goto LABEL_56;
LABEL_55:
      if (*((_BYTE *)v16 + 24))
      {
LABEL_56:
        *((_BYTE *)v15 + 24) = 1;
        *((_BYTE *)v7 + 24) = 0;
        v22 = v15[1];
        *v7 = v22;
        if (v22)
          *(_QWORD *)(v22 + 16) = v7;
        v15[2] = v7[2];
        *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v15;
        v15[1] = v7;
        v7[2] = (uint64_t)v15;
        v16 = v7;
      }
      else
      {
        v15 = v7;
      }
      v23 = v15[2];
      *((_BYTE *)v15 + 24) = *(_BYTE *)(v23 + 24);
      *(_BYTE *)(v23 + 24) = 1;
      *((_BYTE *)v16 + 24) = 1;
      v24 = *(uint64_t **)(v23 + 8);
      v25 = *v24;
      *(_QWORD *)(v23 + 8) = *v24;
      if (v25)
        *(_QWORD *)(v25 + 16) = v23;
      v24[2] = *(_QWORD *)(v23 + 16);
      *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
      *v24 = v23;
      goto LABEL_72;
    }
    v16 = (uint64_t *)v7[1];
    if (v16 && !*((_BYTE *)v16 + 24))
      goto LABEL_55;
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      v17 = result;
LABEL_53:
      *((_BYTE *)v17 + 24) = 1;
      return result;
    }
    if (!*((_BYTE *)v17 + 24))
      goto LABEL_53;
LABEL_49:
    v7 = *(uint64_t **)(v17[2] + 8 * (*(_QWORD *)v17[2] == (_QWORD)v17));
  }
  if (!*((_BYTE *)v7 + 24))
  {
    *((_BYTE *)v7 + 24) = 1;
    *(_BYTE *)(v12 + 24) = 0;
    v18 = v7[1];
    *(_QWORD *)v12 = v18;
    if (v18)
      *(_QWORD *)(v18 + 16) = v12;
    v7[2] = *(_QWORD *)(v12 + 16);
    *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v7;
    v7[1] = v12;
    *(_QWORD *)(v12 + 16) = v7;
    if (result == (uint64_t *)v12)
      result = v7;
    v7 = *(uint64_t **)v12;
  }
  v19 = (_QWORD *)*v7;
  if (*v7 && !*((_BYTE *)v19 + 24))
    goto LABEL_68;
  v20 = (uint64_t *)v7[1];
  if (!v20 || *((_BYTE *)v20 + 24))
  {
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (*((_BYTE *)v17 + 24))
      v21 = v17 == result;
    else
      v21 = 1;
    if (v21)
      goto LABEL_53;
    goto LABEL_49;
  }
  if (v19 && !*((_BYTE *)v19 + 24))
  {
LABEL_68:
    v20 = v7;
  }
  else
  {
    *((_BYTE *)v20 + 24) = 1;
    *((_BYTE *)v7 + 24) = 0;
    v26 = *v20;
    v7[1] = *v20;
    if (v26)
      *(_QWORD *)(v26 + 16) = v7;
    v20[2] = v7[2];
    *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v20;
    *v20 = (uint64_t)v7;
    v7[2] = (uint64_t)v20;
    v19 = v7;
  }
  v23 = v20[2];
  *((_BYTE *)v20 + 24) = *(_BYTE *)(v23 + 24);
  *(_BYTE *)(v23 + 24) = 1;
  *((_BYTE *)v19 + 24) = 1;
  v24 = *(uint64_t **)v23;
  v27 = *(_QWORD *)(*(_QWORD *)v23 + 8);
  *(_QWORD *)v23 = v27;
  if (v27)
    *(_QWORD *)(v27 + 16) = v23;
  v24[2] = *(_QWORD *)(v23 + 16);
  *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
  v24[1] = v23;
LABEL_72:
  *(_QWORD *)(v23 + 16) = v24;
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<IIOThumbnailInfo>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x666666666666667)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(40 * a2);
}

void std::__introsort<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *,false>(uint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  __int128 *v14;
  __int128 *v15;
  __int128 v16;
  __int128 v17;
  unsigned int v18;
  uint64_t v19;
  unsigned int v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unsigned int v24;
  unint64_t v25;
  unsigned int v26;
  unint64_t v27;
  __int128 v28;
  __int128 v29;
  unsigned int v30;
  unsigned int v31;
  __int128 *v32;
  __int128 v33;
  __int128 v34;
  BOOL v35;
  uint64_t v36;
  unsigned int v37;
  unint64_t v38;
  unsigned int v39;
  unint64_t v40;
  unint64_t v41;
  unsigned int v42;
  __int128 v43;
  __int128 v44;
  unsigned int v45;
  unsigned int v46;
  __int128 *v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 *v52;
  __int128 *v53;
  __int128 *v54;
  __int128 v55;
  uint64_t v56;
  __int128 v57;
  __int128 v58;
  uint64_t v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  uint64_t v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  unint64_t v68;
  BOOL v70;
  uint64_t v71;
  unint64_t v72;
  unint64_t v73;
  unsigned int v74;
  uint64_t v75;
  uint64_t v76;
  __int128 v77;
  uint64_t v78;
  int64_t v79;
  int64_t v80;
  int64_t v81;
  uint64_t v82;
  unint64_t v83;
  unsigned int v84;
  unsigned int v85;
  unsigned int v86;
  unint64_t v87;
  unint64_t v88;
  __int128 v89;
  __int128 v90;
  uint64_t v91;
  uint64_t v92;
  unsigned int v93;
  unsigned int v94;
  int64_t v95;
  uint64_t v96;
  unint64_t v97;
  uint64_t v98;
  unint64_t v99;
  uint64_t v100;
  uint64_t v101;
  unsigned int v102;
  unsigned int v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  uint64_t v108;
  unint64_t v109;
  unsigned int v110;
  unint64_t v111;
  __int128 v112;
  __int128 v113;
  uint64_t v115;
  unsigned int v116;
  __int128 v117;
  unsigned int v118;
  __int128 v119;
  __int128 v120;
  uint64_t v121;
  uint64_t v122;
  __int128 v123;
  uint64_t v124;
  int v125;
  int v126;
  int v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  int v134;
  int v135;
  int v136;
  __int128 v137;
  __int128 v138;
  __int128 v139;
  __int128 v140;
  __int128 v141;
  __int128 v142;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  __int128 v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  __int128 v150;
  __int128 v151;
  uint64_t v152;
  uint64_t v153;
  __int128 v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;

LABEL_1:
  v8 = a1;
  while (2)
  {
    a1 = v8;
    v9 = a2 - v8;
    v10 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(a2 - v8) >> 3);
    switch(v10)
    {
      case 0:
      case 1:
        return;
      case 2:
        if (*(_DWORD *)(a2 - 28) < *(_DWORD *)(v8 + 12))
        {
          v159 = *(_QWORD *)(v8 + 32);
          v140 = *(_OWORD *)v8;
          v149 = *(_OWORD *)(v8 + 16);
          v50 = *(_OWORD *)(a2 - 40);
          v51 = *(_OWORD *)(a2 - 24);
          *(_QWORD *)(v8 + 32) = *(_QWORD *)(a2 - 8);
          *(_OWORD *)v8 = v50;
          *(_OWORD *)(v8 + 16) = v51;
          *(_QWORD *)(a2 - 8) = v159;
          *(_OWORD *)(a2 - 24) = v149;
          *(_OWORD *)(a2 - 40) = v140;
        }
        return;
      case 3:
        std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>((__int128 *)v8, (__int128 *)(v8 + 40), (__int128 *)(a2 - 40));
        return;
      case 4:
        std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>(v8, v8 + 40, v8 + 80, a2 - 40);
        return;
      case 5:
        v52 = (__int128 *)(v8 + 40);
        v53 = (__int128 *)(v8 + 80);
        v54 = (__int128 *)(v8 + 120);
        std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>(v8, v8 + 40, v8 + 80, v8 + 120);
        if (*(_DWORD *)(a2 - 28) < *(_DWORD *)(v8 + 132))
        {
          v55 = *v54;
          v150 = *(_OWORD *)(v8 + 136);
          v56 = *(_QWORD *)(v8 + 152);
          v57 = *(_OWORD *)(a2 - 24);
          v58 = *(_OWORD *)(a2 - 40);
          *(_QWORD *)(v8 + 152) = *(_QWORD *)(a2 - 8);
          *v54 = v58;
          *(_OWORD *)(v8 + 136) = v57;
          *(_OWORD *)(a2 - 24) = v150;
          *(_QWORD *)(a2 - 8) = v56;
          *(_OWORD *)(a2 - 40) = v55;
          if (*(_DWORD *)(v8 + 132) < *(_DWORD *)(v8 + 92))
          {
            v59 = *(_QWORD *)(v8 + 112);
            v61 = *v53;
            v60 = *(_OWORD *)(v8 + 96);
            v62 = *(_OWORD *)(v8 + 136);
            *v53 = *v54;
            *(_OWORD *)(v8 + 96) = v62;
            *(_QWORD *)(v8 + 112) = *(_QWORD *)(v8 + 152);
            *v54 = v61;
            *(_OWORD *)(v8 + 136) = v60;
            *(_QWORD *)(v8 + 152) = v59;
            if (*(_DWORD *)(v8 + 92) < *(_DWORD *)(v8 + 52))
            {
              v63 = *(_QWORD *)(v8 + 72);
              v65 = *v52;
              v64 = *(_OWORD *)(v8 + 56);
              v66 = *(_OWORD *)(v8 + 96);
              *v52 = *v53;
              *(_OWORD *)(v8 + 56) = v66;
              *(_QWORD *)(v8 + 72) = *(_QWORD *)(v8 + 112);
              *v53 = v65;
              *(_OWORD *)(v8 + 96) = v64;
              *(_QWORD *)(v8 + 112) = v63;
              if (*(_DWORD *)(v8 + 52) < *(_DWORD *)(v8 + 12))
              {
                v160 = *(_QWORD *)(v8 + 32);
                v141 = *(_OWORD *)v8;
                v151 = *(_OWORD *)(v8 + 16);
                v67 = *(_OWORD *)(v8 + 56);
                *(_OWORD *)v8 = *v52;
                *(_OWORD *)(v8 + 16) = v67;
                *(_QWORD *)(v8 + 32) = *(_QWORD *)(v8 + 72);
                *v52 = v141;
                *(_OWORD *)(v8 + 56) = v151;
                *(_QWORD *)(v8 + 72) = v160;
              }
            }
          }
        }
        return;
      default:
        if (v9 <= 959)
        {
          v68 = v8 + 40;
          v70 = v8 == a2 || v68 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v70)
            {
              v71 = 0;
              v72 = v8;
              do
              {
                v73 = v68;
                v74 = *(_DWORD *)(v72 + 52);
                if (v74 < *(_DWORD *)(v72 + 12))
                {
                  v125 = *(_DWORD *)(v73 + 8);
                  v121 = *(_QWORD *)v73;
                  v142 = *(_OWORD *)(v72 + 56);
                  v152 = *(_QWORD *)(v72 + 72);
                  v75 = v71;
                  while (1)
                  {
                    v76 = v8 + v75;
                    v77 = *(_OWORD *)(v8 + v75 + 16);
                    *(_OWORD *)(v76 + 40) = *(_OWORD *)(v8 + v75);
                    *(_OWORD *)(v76 + 56) = v77;
                    *(_QWORD *)(v76 + 72) = *(_QWORD *)(v8 + v75 + 32);
                    if (!v75)
                      break;
                    v75 -= 40;
                    if (v74 >= *(_DWORD *)(v76 - 28))
                    {
                      v78 = v8 + v75 + 40;
                      goto LABEL_80;
                    }
                  }
                  v78 = v8;
LABEL_80:
                  *(_QWORD *)v78 = v121;
                  *(_DWORD *)(v78 + 8) = v125;
                  *(_DWORD *)(v78 + 12) = v74;
                  *(_OWORD *)(v78 + 16) = v142;
                  *(_QWORD *)(v78 + 32) = v152;
                }
                v68 = v73 + 40;
                v71 += 40;
                v72 = v73;
              }
              while (v73 + 40 != a2);
            }
          }
          else if (!v70)
          {
            do
            {
              v115 = v68;
              v116 = *(_DWORD *)(a1 + 52);
              if (v116 < *(_DWORD *)(a1 + 12))
              {
                v127 = *(_DWORD *)(v68 + 8);
                v124 = *(_QWORD *)v68;
                v145 = *(_OWORD *)(a1 + 56);
                v155 = *(_QWORD *)(a1 + 72);
                do
                {
                  v117 = *(_OWORD *)(v68 - 24);
                  *(_OWORD *)v68 = *(_OWORD *)(v68 - 40);
                  *(_OWORD *)(v68 + 16) = v117;
                  *(_QWORD *)(v68 + 32) = *(_QWORD *)(v68 - 8);
                  v118 = *(_DWORD *)(v68 - 68);
                  v68 -= 40;
                }
                while (v116 < v118);
                *(_QWORD *)v68 = v124;
                *(_DWORD *)(v68 + 8) = v127;
                *(_DWORD *)(v68 + 12) = v116;
                *(_QWORD *)(v68 + 32) = v155;
                *(_OWORD *)(v68 + 16) = v145;
              }
              v68 = v115 + 40;
              a1 = v115;
            }
            while (v115 + 40 != a2);
          }
          return;
        }
        if (!a3)
        {
          if (v8 != a2)
          {
            v79 = (unint64_t)(v10 - 2) >> 1;
            v80 = v79;
            do
            {
              v81 = v80;
              if (v79 >= v80)
              {
                v82 = (2 * v80) | 1;
                v83 = v8 + 40 * v82;
                if (2 * v81 + 2 < v10)
                {
                  v84 = *(_DWORD *)(v8 + 40 * v82 + 12);
                  v85 = *(_DWORD *)(v83 + 52);
                  v83 += 40 * (v84 < v85);
                  if (v84 < v85)
                    v82 = 2 * v81 + 2;
                }
                v86 = *(_DWORD *)(v8 + 40 * v81 + 12);
                if (*(_DWORD *)(v83 + 12) >= v86)
                {
                  v87 = v8 + 40 * v81;
                  v126 = *(_DWORD *)(v87 + 8);
                  v122 = *(_QWORD *)v87;
                  v153 = *(_QWORD *)(v87 + 32);
                  v143 = *(_OWORD *)(v87 + 16);
                  do
                  {
                    v88 = v83;
                    v89 = *(_OWORD *)v83;
                    v90 = *(_OWORD *)(v83 + 16);
                    *(_QWORD *)(v87 + 32) = *(_QWORD *)(v83 + 32);
                    *(_OWORD *)v87 = v89;
                    *(_OWORD *)(v87 + 16) = v90;
                    if (v79 < v82)
                      break;
                    v91 = (2 * v82) | 1;
                    v83 = v8 + 40 * v91;
                    v92 = 2 * v82 + 2;
                    if (v92 < v10)
                    {
                      v93 = *(_DWORD *)(v8 + 40 * v91 + 12);
                      v94 = *(_DWORD *)(v83 + 52);
                      v83 += 40 * (v93 < v94);
                      if (v93 < v94)
                        v91 = v92;
                    }
                    v87 = v88;
                    v82 = v91;
                  }
                  while (*(_DWORD *)(v83 + 12) >= v86);
                  *(_QWORD *)v88 = v122;
                  *(_DWORD *)(v88 + 8) = v126;
                  *(_DWORD *)(v88 + 12) = v86;
                  *(_OWORD *)(v88 + 16) = v143;
                  *(_QWORD *)(v88 + 32) = v153;
                }
              }
              v80 = v81 - 1;
            }
            while (v81);
            v95 = v9 / 0x28uLL;
            do
            {
              v96 = 0;
              v161 = *(_QWORD *)(v8 + 32);
              v144 = *(_OWORD *)v8;
              v154 = *(_OWORD *)(v8 + 16);
              v97 = v8;
              do
              {
                v98 = v96 + 1;
                v99 = v97 + 40 * (v96 + 1);
                v100 = (2 * v96) | 1;
                v101 = 2 * v96 + 2;
                if (v101 < v95)
                {
                  v102 = *(_DWORD *)(v97 + 40 * v98 + 12);
                  v103 = *(_DWORD *)(v99 + 52);
                  v99 += 40 * (v102 < v103);
                  if (v102 < v103)
                    v100 = v101;
                }
                v104 = *(_OWORD *)v99;
                v105 = *(_OWORD *)(v99 + 16);
                *(_QWORD *)(v97 + 32) = *(_QWORD *)(v99 + 32);
                *(_OWORD *)v97 = v104;
                *(_OWORD *)(v97 + 16) = v105;
                v97 = v99;
                v96 = v100;
              }
              while (v100 <= (uint64_t)((unint64_t)(v95 - 2) >> 1));
              a2 -= 40;
              if (v99 == a2)
              {
                *(_QWORD *)(v99 + 32) = v161;
                *(_OWORD *)v99 = v144;
                *(_OWORD *)(v99 + 16) = v154;
              }
              else
              {
                v106 = *(_OWORD *)a2;
                v107 = *(_OWORD *)(a2 + 16);
                *(_QWORD *)(v99 + 32) = *(_QWORD *)(a2 + 32);
                *(_OWORD *)v99 = v106;
                *(_OWORD *)(v99 + 16) = v107;
                *(_QWORD *)(a2 + 32) = v161;
                *(_OWORD *)a2 = v144;
                *(_OWORD *)(a2 + 16) = v154;
                v108 = v99 - v8 + 40;
                if (v108 >= 41)
                {
                  v109 = (v108 / 0x28uLL - 2) >> 1;
                  v110 = *(_DWORD *)(v99 + 12);
                  if (*(_DWORD *)(v8 + 40 * v109 + 12) < v110)
                  {
                    v136 = *(_DWORD *)(v99 + 8);
                    v133 = *(_QWORD *)v99;
                    v130 = *(_QWORD *)(v99 + 32);
                    v123 = *(_OWORD *)(v99 + 16);
                    do
                    {
                      v111 = v99;
                      v99 = v8 + 40 * v109;
                      v112 = *(_OWORD *)v99;
                      v113 = *(_OWORD *)(v99 + 16);
                      *(_QWORD *)(v111 + 32) = *(_QWORD *)(v99 + 32);
                      *(_OWORD *)v111 = v112;
                      *(_OWORD *)(v111 + 16) = v113;
                      if (!v109)
                        break;
                      v109 = (v109 - 1) >> 1;
                    }
                    while (*(_DWORD *)(v8 + 40 * v109 + 12) < v110);
                    *(_QWORD *)v99 = v133;
                    *(_DWORD *)(v99 + 8) = v136;
                    *(_DWORD *)(v99 + 12) = v110;
                    *(_QWORD *)(v99 + 32) = v130;
                    *(_OWORD *)(v99 + 16) = v123;
                  }
                }
              }
            }
            while (v95-- > 2);
          }
          return;
        }
        v11 = (unint64_t)v10 >> 1;
        v12 = v8 + 40 * ((unint64_t)v10 >> 1);
        if ((unint64_t)v9 < 0x1401)
        {
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>((__int128 *)v12, (__int128 *)a1, (__int128 *)(a2 - 40));
        }
        else
        {
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>((__int128 *)a1, (__int128 *)v12, (__int128 *)(a2 - 40));
          v13 = 5 * v11;
          v14 = (__int128 *)(a1 + 40 * v11 - 40);
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>((__int128 *)(a1 + 40), v14, (__int128 *)(a2 - 80));
          v15 = (__int128 *)(a1 + 40 + 8 * v13);
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>((__int128 *)(a1 + 80), v15, (__int128 *)(a2 - 120));
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>(v14, (__int128 *)v12, v15);
          v156 = *(_QWORD *)(a1 + 32);
          v137 = *(_OWORD *)a1;
          v146 = *(_OWORD *)(a1 + 16);
          v16 = *(_OWORD *)v12;
          v17 = *(_OWORD *)(v12 + 16);
          *(_QWORD *)(a1 + 32) = *(_QWORD *)(v12 + 32);
          *(_OWORD *)a1 = v16;
          *(_OWORD *)(a1 + 16) = v17;
          *(_QWORD *)(v12 + 32) = v156;
          *(_OWORD *)v12 = v137;
          *(_OWORD *)(v12 + 16) = v146;
        }
        --a3;
        if ((a4 & 1) == 0)
        {
          v18 = *(_DWORD *)(a1 + 12);
          if (*(_DWORD *)(a1 - 28) < v18)
            goto LABEL_11;
          v135 = *(_DWORD *)(a1 + 8);
          v132 = *(_QWORD *)a1;
          v120 = *(_OWORD *)(a1 + 16);
          v129 = *(_QWORD *)(a1 + 32);
          if (v18 >= *(_DWORD *)(a2 - 28))
          {
            v38 = a1 + 40;
            do
            {
              v8 = v38;
              if (v38 >= a2)
                break;
              v39 = *(_DWORD *)(v38 + 12);
              v38 += 40;
            }
            while (v18 >= v39);
          }
          else
          {
            v36 = a1;
            do
            {
              v8 = v36 + 40;
              v37 = *(_DWORD *)(v36 + 52);
              v36 += 40;
            }
            while (v18 >= v37);
          }
          v40 = a2;
          if (v8 < a2)
          {
            v41 = a2;
            do
            {
              v40 = v41 - 40;
              v42 = *(_DWORD *)(v41 - 28);
              v41 -= 40;
            }
            while (v18 < v42);
          }
          while (v8 < v40)
          {
            v158 = *(_QWORD *)(v8 + 32);
            v139 = *(_OWORD *)v8;
            v148 = *(_OWORD *)(v8 + 16);
            v43 = *(_OWORD *)v40;
            v44 = *(_OWORD *)(v40 + 16);
            *(_QWORD *)(v8 + 32) = *(_QWORD *)(v40 + 32);
            *(_OWORD *)v8 = v43;
            *(_OWORD *)(v8 + 16) = v44;
            *(_QWORD *)(v40 + 32) = v158;
            *(_OWORD *)v40 = v139;
            *(_OWORD *)(v40 + 16) = v148;
            do
            {
              v45 = *(_DWORD *)(v8 + 52);
              v8 += 40;
            }
            while (v18 >= v45);
            do
            {
              v46 = *(_DWORD *)(v40 - 28);
              v40 -= 40;
            }
            while (v18 < v46);
          }
          v47 = (__int128 *)(v8 - 40);
          if (v8 - 40 != a1)
          {
            v48 = *v47;
            v49 = *(_OWORD *)(v8 - 24);
            *(_QWORD *)(a1 + 32) = *(_QWORD *)(v8 - 8);
            *(_OWORD *)a1 = v48;
            *(_OWORD *)(a1 + 16) = v49;
          }
          a4 = 0;
          *(_DWORD *)(v8 - 32) = v135;
          *(_QWORD *)v47 = v132;
          *(_DWORD *)(v8 - 28) = v18;
          *(_QWORD *)(v8 - 8) = v129;
          *(_OWORD *)(v8 - 24) = v120;
          continue;
        }
        v18 = *(_DWORD *)(a1 + 12);
LABEL_11:
        v19 = 0;
        v134 = *(_DWORD *)(a1 + 8);
        v131 = *(_QWORD *)a1;
        v128 = *(_QWORD *)(a1 + 32);
        v119 = *(_OWORD *)(a1 + 16);
        do
        {
          v20 = *(_DWORD *)(a1 + v19 + 52);
          v19 += 40;
        }
        while (v20 < v18);
        v21 = a1 + v19;
        v22 = a2;
        if (v19 == 40)
        {
          v25 = a2;
          while (v21 < v25)
          {
            v23 = v25 - 40;
            v26 = *(_DWORD *)(v25 - 28);
            v25 -= 40;
            if (v26 < v18)
              goto LABEL_21;
          }
          v23 = v25;
        }
        else
        {
          do
          {
            v23 = v22 - 40;
            v24 = *(_DWORD *)(v22 - 28);
            v22 -= 40;
          }
          while (v24 >= v18);
        }
LABEL_21:
        if (v21 >= v23)
        {
          v8 = v21;
        }
        else
        {
          v27 = v23;
          v8 = v21;
          do
          {
            v157 = *(_QWORD *)(v8 + 32);
            v138 = *(_OWORD *)v8;
            v147 = *(_OWORD *)(v8 + 16);
            v28 = *(_OWORD *)v27;
            v29 = *(_OWORD *)(v27 + 16);
            *(_QWORD *)(v8 + 32) = *(_QWORD *)(v27 + 32);
            *(_OWORD *)v8 = v28;
            *(_OWORD *)(v8 + 16) = v29;
            *(_QWORD *)(v27 + 32) = v157;
            *(_OWORD *)v27 = v138;
            *(_OWORD *)(v27 + 16) = v147;
            do
            {
              v30 = *(_DWORD *)(v8 + 52);
              v8 += 40;
            }
            while (v30 < v18);
            do
            {
              v31 = *(_DWORD *)(v27 - 28);
              v27 -= 40;
            }
            while (v31 >= v18);
          }
          while (v8 < v27);
        }
        v32 = (__int128 *)(v8 - 40);
        if (v8 - 40 != a1)
        {
          v33 = *v32;
          v34 = *(_OWORD *)(v8 - 24);
          *(_QWORD *)(a1 + 32) = *(_QWORD *)(v8 - 8);
          *(_OWORD *)a1 = v33;
          *(_OWORD *)(a1 + 16) = v34;
        }
        *(_DWORD *)(v8 - 32) = v134;
        *(_QWORD *)v32 = v131;
        *(_DWORD *)(v8 - 28) = v18;
        *(_QWORD *)(v8 - 8) = v128;
        *(_OWORD *)(v8 - 24) = v119;
        if (v21 < v23)
        {
LABEL_34:
          std::__introsort<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *,false>(a1, v8 - 40, a3, a4 & 1);
          a4 = 0;
          continue;
        }
        v35 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>(a1, v8 - 40);
        if (!std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>(v8, a2))
        {
          if (v35)
            continue;
          goto LABEL_34;
        }
        a2 = v8 - 40;
        if (!v35)
          goto LABEL_1;
        return;
    }
  }
}

__int128 *std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>(__int128 *result, __int128 *a2, __int128 *a3)
{
  unsigned int v3;
  unsigned int v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  __int128 v24;
  uint64_t v25;
  __int128 v26;

  v3 = *((_DWORD *)a2 + 3);
  v4 = *((_DWORD *)a3 + 3);
  if (v3 >= *((_DWORD *)result + 3))
  {
    if (v4 < v3)
    {
      v10 = *a2;
      v11 = a2[1];
      v12 = *((_QWORD *)a2 + 4);
      v13 = *((_QWORD *)a3 + 4);
      v14 = a3[1];
      *a2 = *a3;
      a2[1] = v14;
      *((_QWORD *)a2 + 4) = v13;
      *((_QWORD *)a3 + 4) = v12;
      *a3 = v10;
      a3[1] = v11;
      if (*((_DWORD *)a2 + 3) < *((_DWORD *)result + 3))
      {
        v15 = *result;
        v16 = result[1];
        v17 = *((_QWORD *)result + 4);
        v18 = *((_QWORD *)a2 + 4);
        v19 = a2[1];
        *result = *a2;
        result[1] = v19;
        *((_QWORD *)result + 4) = v18;
        *((_QWORD *)a2 + 4) = v17;
        *a2 = v15;
        a2[1] = v16;
      }
    }
  }
  else
  {
    if (v4 >= v3)
    {
      v20 = *result;
      v21 = result[1];
      v22 = *((_QWORD *)result + 4);
      v23 = *((_QWORD *)a2 + 4);
      v24 = a2[1];
      *result = *a2;
      result[1] = v24;
      *((_QWORD *)result + 4) = v23;
      *((_QWORD *)a2 + 4) = v22;
      *a2 = v20;
      a2[1] = v21;
      if (*((_DWORD *)a3 + 3) >= *((_DWORD *)a2 + 3))
        return result;
      v5 = *a2;
      v6 = a2[1];
      v7 = *((_QWORD *)a2 + 4);
      v25 = *((_QWORD *)a3 + 4);
      v26 = a3[1];
      *a2 = *a3;
      a2[1] = v26;
      *((_QWORD *)a2 + 4) = v25;
    }
    else
    {
      v5 = *result;
      v6 = result[1];
      v7 = *((_QWORD *)result + 4);
      v8 = *((_QWORD *)a3 + 4);
      v9 = a3[1];
      *result = *a3;
      result[1] = v9;
      *((_QWORD *)result + 4) = v8;
    }
    *((_QWORD *)a3 + 4) = v7;
    *a3 = v5;
    a3[1] = v6;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  _BOOL8 result;
  __int128 v6;
  __int128 v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  uint64_t v19;
  __int128 *v20;
  __int128 *v21;
  __int128 *v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;

  v4 = 0xCCCCCCCCCCCCCCCDLL * ((a2 - a1) >> 3);
  result = 1;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if (*(_DWORD *)(a2 - 28) < *(_DWORD *)(a1 + 12))
      {
        v6 = *(_OWORD *)a1;
        v7 = *(_OWORD *)(a1 + 16);
        v8 = *(_QWORD *)(a1 + 32);
        v9 = *(_QWORD *)(a2 - 8);
        v10 = *(_OWORD *)(a2 - 24);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 40);
        *(_OWORD *)(a1 + 16) = v10;
        *(_QWORD *)(a1 + 32) = v9;
        *(_QWORD *)(a2 - 8) = v8;
        *(_OWORD *)(a2 - 24) = v7;
        *(_OWORD *)(a2 - 40) = v6;
      }
      return result;
    case 3uLL:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>((__int128 *)a1, (__int128 *)(a1 + 40), (__int128 *)(a2 - 40));
      return 1;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>(a1, a1 + 40, a1 + 80, a2 - 40);
      return 1;
    case 5uLL:
      v20 = (__int128 *)(a1 + 40);
      v21 = (__int128 *)(a1 + 80);
      v22 = (__int128 *)(a1 + 120);
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>(a1, a1 + 40, a1 + 80, a1 + 120);
      if (*(_DWORD *)(a2 - 28) >= *(_DWORD *)(a1 + 132))
        return 1;
      v23 = *v22;
      v24 = *(_OWORD *)(a1 + 136);
      v25 = *(_QWORD *)(a1 + 152);
      v26 = *(_QWORD *)(a2 - 8);
      v27 = *(_OWORD *)(a2 - 24);
      *v22 = *(_OWORD *)(a2 - 40);
      *(_OWORD *)(a1 + 136) = v27;
      *(_QWORD *)(a1 + 152) = v26;
      *(_QWORD *)(a2 - 8) = v25;
      *(_OWORD *)(a2 - 24) = v24;
      *(_OWORD *)(a2 - 40) = v23;
      if (*(_DWORD *)(a1 + 132) >= *(_DWORD *)(a1 + 92))
        return 1;
      v28 = *(_QWORD *)(a1 + 112);
      v30 = *v21;
      v29 = *(_OWORD *)(a1 + 96);
      v31 = *(_OWORD *)(a1 + 136);
      *v21 = *v22;
      *(_OWORD *)(a1 + 96) = v31;
      *(_QWORD *)(a1 + 112) = *(_QWORD *)(a1 + 152);
      *v22 = v30;
      *(_OWORD *)(a1 + 136) = v29;
      *(_QWORD *)(a1 + 152) = v28;
      if (*(_DWORD *)(a1 + 92) >= *(_DWORD *)(a1 + 52))
        return 1;
      v32 = *(_QWORD *)(a1 + 72);
      v34 = *v20;
      v33 = *(_OWORD *)(a1 + 56);
      v35 = *(_OWORD *)(a1 + 96);
      *v20 = *v21;
      *(_OWORD *)(a1 + 56) = v35;
      *(_QWORD *)(a1 + 72) = *(_QWORD *)(a1 + 112);
      *v21 = v34;
      *(_OWORD *)(a1 + 96) = v33;
      *(_QWORD *)(a1 + 112) = v32;
      if (*(_DWORD *)(a1 + 52) >= *(_DWORD *)(a1 + 12))
        return 1;
      v36 = *(_QWORD *)(a1 + 32);
      v38 = *(_OWORD *)a1;
      v37 = *(_OWORD *)(a1 + 16);
      v39 = *(_OWORD *)(a1 + 56);
      *(_OWORD *)a1 = *v20;
      *(_OWORD *)(a1 + 16) = v39;
      *(_QWORD *)(a1 + 32) = *(_QWORD *)(a1 + 72);
      *v20 = v38;
      *(_OWORD *)(a1 + 56) = v37;
      result = 1;
      *(_QWORD *)(a1 + 72) = v36;
      return result;
    default:
      v11 = a1 + 80;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>((__int128 *)a1, (__int128 *)(a1 + 40), (__int128 *)(a1 + 80));
      v12 = a1 + 120;
      if (a1 + 120 == a2)
        return 1;
      v13 = 0;
      v14 = 0;
      break;
  }
  while (1)
  {
    v15 = *(_DWORD *)(v12 + 12);
    if (v15 < *(_DWORD *)(v11 + 12))
    {
      v43 = *(_DWORD *)(v12 + 8);
      v40 = *(_OWORD *)(v12 + 16);
      v41 = *(_QWORD *)(v12 + 32);
      v42 = *(_QWORD *)v12;
      v16 = v13;
      while (1)
      {
        v17 = a1 + v16;
        v18 = *(_OWORD *)(a1 + v16 + 96);
        *(_OWORD *)(v17 + 120) = *(_OWORD *)(a1 + v16 + 80);
        *(_OWORD *)(v17 + 136) = v18;
        *(_QWORD *)(v17 + 152) = *(_QWORD *)(a1 + v16 + 112);
        if (v16 == -80)
          break;
        v16 -= 40;
        if (v15 >= *(_DWORD *)(v17 + 52))
        {
          v19 = a1 + v16 + 120;
          goto LABEL_12;
        }
      }
      v19 = a1;
LABEL_12:
      *(_QWORD *)v19 = v42;
      *(_DWORD *)(v19 + 8) = v43;
      *(_DWORD *)(v19 + 12) = v15;
      *(_OWORD *)(v19 + 16) = v40;
      *(_QWORD *)(v19 + 32) = v41;
      if (++v14 == 8)
        return v12 + 40 == a2;
    }
    v11 = v12;
    v13 += 40;
    v12 += 40;
    if (v12 == a2)
      return 1;
  }
}

__n128 std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __n128 result;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;

  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>((__int128 *)a1, (__int128 *)a2, (__int128 *)a3);
  if (*(_DWORD *)(a4 + 12) < *(_DWORD *)(a3 + 12))
  {
    result = *(__n128 *)a3;
    v9 = *(_OWORD *)(a3 + 16);
    v10 = *(_QWORD *)(a3 + 32);
    v11 = *(_QWORD *)(a4 + 32);
    v12 = *(_OWORD *)(a4 + 16);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(_OWORD *)(a3 + 16) = v12;
    *(_QWORD *)(a3 + 32) = v11;
    *(_QWORD *)(a4 + 32) = v10;
    *(__n128 *)a4 = result;
    *(_OWORD *)(a4 + 16) = v9;
    if (*(_DWORD *)(a3 + 12) < *(_DWORD *)(a2 + 12))
    {
      result = *(__n128 *)a2;
      v13 = *(_OWORD *)(a2 + 16);
      v14 = *(_QWORD *)(a2 + 32);
      v15 = *(_QWORD *)(a3 + 32);
      v16 = *(_OWORD *)(a3 + 16);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)(a2 + 16) = v16;
      *(_QWORD *)(a2 + 32) = v15;
      *(_QWORD *)(a3 + 32) = v14;
      *(__n128 *)a3 = result;
      *(_OWORD *)(a3 + 16) = v13;
      if (*(_DWORD *)(a2 + 12) < *(_DWORD *)(a1 + 12))
      {
        result = *(__n128 *)a1;
        v17 = *(_OWORD *)(a1 + 16);
        v18 = *(_QWORD *)(a1 + 32);
        v19 = *(_QWORD *)(a2 + 32);
        v20 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v20;
        *(_QWORD *)(a1 + 32) = v19;
        *(_QWORD *)(a2 + 32) = v18;
        *(__n128 *)a2 = result;
        *(_OWORD *)(a2 + 16) = v17;
      }
    }
  }
  return result;
}

unint64_t png_safecat(uint64_t a1, unint64_t a2, unint64_t a3, _BYTE *a4)
{
  char v4;
  unsigned __int8 *v5;
  unint64_t v6;
  int v7;
  BOOL v8;

  if (a1 && a3 < a2)
  {
    if (a4 && (v4 = *a4) != 0 && a2 - 1 > a3)
    {
      v5 = a4 + 1;
      do
      {
        *(_BYTE *)(a1 + a3) = v4;
        v6 = a3 + 1;
        v7 = *v5++;
        v4 = v7;
        if (v7)
          v8 = v6 >= a2 - 1;
        else
          v8 = 1;
        ++a3;
      }
      while (!v8);
    }
    else
    {
      v6 = a3;
    }
    *(_BYTE *)(a1 + v6) = 0;
    return v6;
  }
  return a3;
}

unint64_t png_format_number(unint64_t a1, uint64_t a2, int a3, unint64_t a4)
{
  unint64_t v4;
  int v5;
  int v6;
  int v7;
  unint64_t v8;
  unint64_t v9;

  *(_BYTE *)(a2 - 1) = 0;
  v4 = a2 - 1;
  if (v4 > a1)
  {
    v5 = 0;
    v6 = 0;
    v7 = 1;
    while (2)
    {
      if (a4 || v6 < v7)
      {
        switch(a3)
        {
          case 1:
            goto LABEL_7;
          case 2:
            v7 = 2;
LABEL_7:
            v8 = a4 / 0xA;
            *(_BYTE *)--v4 = png_format_number_digits[a4 % 0xA];
            goto LABEL_11;
          case 3:
            goto LABEL_10;
          case 4:
            v7 = 2;
LABEL_10:
            *(_BYTE *)--v4 = png_format_number_digits[a4 & 0xF];
            v8 = a4 >> 4;
LABEL_11:
            ++v6;
            a4 = v8;
            goto LABEL_12;
          case 5:
            v9 = a4 % 0xA;
            if (v5 || v9)
            {
              *(_BYTE *)--v4 = png_format_number_digits[v9];
              v5 = 1;
            }
            else
            {
              v5 = 0;
            }
            v7 = 5;
            a4 /= 0xAuLL;
            goto LABEL_19;
          default:
            a4 = 0;
LABEL_19:
            ++v6;
            if (a3 == 5 && v6 == 5 && v4 > a1)
            {
              if (v5)
              {
                *(_BYTE *)--v4 = 46;
              }
              else
              {
                v5 = 0;
                if (!a4)
                  *(_BYTE *)--v4 = 48;
              }
              v6 = 5;
            }
LABEL_12:
            if (v4 <= a1)
              return v4;
            continue;
        }
      }
      break;
    }
  }
  return v4;
}

uint64_t png_warning_parameter(uint64_t result, int a2, _BYTE *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  unint64_t v6;
  unint64_t v7;

  v3 = (a2 - 1);
  if (v3 <= 7 && result)
  {
    v4 = result + 32 * v3;
    if (a3 && (LOBYTE(v5) = *a3) != 0)
    {
      v6 = 0;
      do
      {
        v7 = v6 + 1;
        *(_BYTE *)(v4 + v6) = v5;
        if (v6 > 0x1D)
          break;
        v5 = a3[++v6];
      }
      while (v5);
    }
    else
    {
      v7 = 0;
    }
    *(_BYTE *)(v4 + v7) = 0;
  }
  return result;
}

_BYTE *png_warning_parameter_signed(uint64_t a1, int a2, int a3, unint64_t a4)
{
  int v4;
  _BYTE *result;
  uint64_t v8;
  uint64_t v9;
  int v10;
  unint64_t v11;
  unint64_t v12;
  _QWORD v13[3];
  uint64_t v14;

  v4 = a4;
  v14 = *MEMORY[0x1E0C80C00];
  memset(v13, 0, sizeof(v13));
  if ((a4 & 0x80000000) == 0)
    a4 = a4;
  else
    a4 = -(int)a4;
  result = (_BYTE *)png_format_number((unint64_t)v13, (uint64_t)&v14, a3, a4);
  if (v4 < 0 && result > (_BYTE *)v13)
    *--result = 45;
  v8 = (a2 - 1);
  if (v8 <= 7 && a1)
  {
    v9 = a1 + 32 * v8;
    LOBYTE(v10) = *result;
    if (*result)
    {
      v11 = 0;
      do
      {
        v12 = v11 + 1;
        *(_BYTE *)(v9 + v11) = v10;
        if (v11 > 0x1D)
          break;
        v10 = result[++v11];
      }
      while (v10);
    }
    else
    {
      v12 = 0;
    }
    *(_BYTE *)(v9 + v12) = 0;
  }
  return result;
}

uint64_t png_formatted_warning(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  unint64_t v3;
  int v4;
  unsigned __int8 *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  unint64_t v10;
  unint64_t v12;
  _OWORD v14[12];
  uint64_t v15;

  v3 = 0;
  v15 = *MEMORY[0x1E0C80C00];
  memset(v14, 0, sizeof(v14));
  while (1)
  {
    v4 = *a3;
    if (!*a3)
      break;
    if (!a2 || v4 != 64)
      goto LABEL_19;
    v5 = a3 + 1;
    v4 = a3[1];
    if (!a3[1])
    {
      LOBYTE(v4) = 64;
LABEL_19:
      v5 = a3;
      goto LABEL_20;
    }
    v6 = 0;
    v7 = a2 - 32;
    do
    {
      v8 = v6 + 1;
      v7 += 32;
      if (v6 == 9)
        break;
      v9 = png_formatted_warning_valid_parameters[v6++];
    }
    while (v9 != v4);
    if (((v8 - 1) & 0xFFFFFFF8) == 0)
    {
      if (v3 <= 0xBE)
      {
        v10 = 0;
        while (*(_BYTE *)(v7 + v10) && v10 <= 0x1F)
        {
          *((_BYTE *)v14 + v3 + v10) = *(_BYTE *)(v7 + v10);
          ++v10;
          if (v3 + v10 == 191)
          {
            v3 = 191;
            goto LABEL_24;
          }
        }
        v3 += v10;
      }
LABEL_24:
      a3 += 2;
      v12 = v3;
      goto LABEL_21;
    }
LABEL_20:
    a3 = v5 + 1;
    v12 = v3 + 1;
    *((_BYTE *)v14 + v3++) = v4;
LABEL_21:
    if (v12 >= 0xBF)
      goto LABEL_26;
  }
  v12 = v3;
LABEL_26:
  *((_BYTE *)v14 + v12) = 0;
  return png_warning(a1, v14);
}

uint64_t png_benign_error(uint64_t a1, char *a2)
{
  int v2;

  v2 = *(_DWORD *)(a1 + 76);
  if ((*(_BYTE *)(a1 + 82) & 0x10) == 0)
  {
    if ((v2 & 0x8000) == 0 || !*(_DWORD *)(a1 + 312))
      _cg_png_error((void (**)(void))a1, a2);
    png_chunk_error((void (**)(void))a1, a2);
  }
  if ((v2 & 0x8000) != 0 && *(_DWORD *)(a1 + 312))
    return png_chunk_warning(a1, a2);
  else
    return png_warning(a1, a2);
}

uint64_t png_chunk_warning(uint64_t a1, const char *a2)
{
  FILE **v4;
  _BYTE v5[214];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    memset(v5, 0, sizeof(v5));
    png_format_buffer(a1, (uint64_t)v5, (uint64_t)a2);
    return png_warning(a1, v5);
  }
  else
  {
    v4 = (FILE **)MEMORY[0x1E0C80C10];
    fprintf((FILE *)*MEMORY[0x1E0C80C10], "libpng warning: %s", a2);
    return fputc(10, *v4);
  }
}

void png_chunk_error(void (**a1)(void), const char *a2)
{
  _OWORD v3[14];

  if (!a1)
    _cg_png_error(0, a2);
  memset(v3, 0, 214);
  png_format_buffer((uint64_t)a1, (uint64_t)v3, (uint64_t)a2);
  _cg_png_error(a1, (const char *)v3);
}

uint64_t png_app_warning(uint64_t a1, char *a2)
{
  if ((*(_BYTE *)(a1 + 82) & 0x20) == 0)
    _cg_png_error((void (**)(void))a1, a2);
  return png_warning(a1, a2);
}

uint64_t png_format_buffer(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  unsigned int v4;
  int i;
  unsigned int v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  _BYTE *v12;
  uint64_t v13;
  uint64_t v14;
  int v15;

  LODWORD(v3) = 0;
  v4 = *(_DWORD *)(result + 312);
  for (i = 24; i != -8; i -= 8)
  {
    v6 = v4 >> i;
    v7 = (v4 >> i);
    v8 = v7 - 123;
    v9 = v7 - 91;
    v10 = (int)v3;
    if (v8 >= 0xFFFFFFC6 && v9 > 5)
    {
      *(_BYTE *)(a2 + (int)v3) = v6;
    }
    else
    {
      v12 = (_BYTE *)(a2 + (int)v3);
      *v12 = 91;
      v12[1] = png_digit[v6 >> 4];
      LODWORD(v3) = v3 + 3;
      v12[2] = png_digit[v6 & 0xF];
      *(_BYTE *)(a2 + v10 + 3) = 93;
    }
    v13 = (int)v3;
    v3 = (int)v3 + 1;
  }
  if (a3)
  {
    v14 = 0;
    *(_BYTE *)(a2 + v3) = 58;
    v15 = v13 + 3;
    *(_BYTE *)(v13 + a2 + 2) = 32;
    LODWORD(v3) = v13 + 198;
    while (*(_BYTE *)(a3 + v14))
    {
      *(_BYTE *)(a2 + v15 + v14) = *(_BYTE *)(a3 + v14);
      if (++v14 == 195)
        goto LABEL_15;
    }
    LODWORD(v3) = v15 + v14;
  }
LABEL_15:
  *(_BYTE *)(a2 + (int)v3) = 0;
  return result;
}

uint64_t png_chunk_benign_error(uint64_t a1, const char *a2)
{
  if ((*(_BYTE *)(a1 + 82) & 0x10) == 0)
    png_chunk_error((void (**)(void))a1, a2);
  return png_chunk_warning(a1, a2);
}

uint64_t png_chunk_report(uint64_t a1, char *a2, int a3)
{
  if ((*(_BYTE *)(a1 + 77) & 0x80) != 0)
  {
    if (a3 > 1)
      return png_chunk_benign_error(a1, a2);
    else
      return png_chunk_warning(a1, a2);
  }
  else if (a3 <= 0)
  {
    return png_app_warning(a1, a2);
  }
  else
  {
    return png_app_error(a1, a2);
  }
}

void png_fixed_error(void (**a1)(void), uint64_t a2)
{
  uint64_t v2;
  _BYTE v3[24];
  _OWORD v4[12];
  int v5;

  LODWORD(v2) = 0;
  memset(v4, 0, sizeof(v4));
  v5 = 0;
  qmemcpy(v3, "fixed point overflow in ", sizeof(v3));
  if (a2)
  {
    v2 = 0;
    do
    {
      if (!*(_BYTE *)(a2 + v2))
        goto LABEL_6;
      *((_BYTE *)v4 + v2) = *(_BYTE *)(a2 + v2);
      ++v2;
    }
    while ((_DWORD)v2 != 195);
    LODWORD(v2) = 195;
  }
LABEL_6:
  v3[v2 + 24] = 0;
  _cg_png_error(a1, v3);
}

uint64_t TIFFFieldSetGetSize(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    v1 = *(int *)(result + 16);
    if (v1 > 0x33)
      return 0;
    else
      return dword_18820F1C4[v1];
  }
  return result;
}

uint64_t TIFFFieldTag(unsigned int *a1)
{
  return *a1;
}

_QWORD *_TIFFCreateAnonField(_QWORD *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  char *v20;

  v8 = a3;
  v11 = _TIFFmallocExt(a1, 48, a3, a4, a5, a6, a7, a8);
  v12 = v11;
  if (v11)
  {
    _TIFFmemset(v11, 0, 0x30uLL);
    v19 = 0;
    *(_DWORD *)v12 = a2;
    *((_DWORD *)v12 + 1) = -131075;
    *((_DWORD *)v12 + 2) = v8;
    *((_DWORD *)v12 + 3) = 1;
    if ((v8 - 1) <= 0x11)
      v19 = dword_18820F294[v8 - 1];
    *((_DWORD *)v12 + 4) = v19;
    *((_DWORD *)v12 + 5) = v19;
    *((_DWORD *)v12 + 6) = 16842817;
    v20 = (char *)_TIFFmallocExt(a1, 32, v13, v14, v15, v16, v17, v18);
    v12[4] = v20;
    if (v20)
    {
      v12[5] = 0;
      snprintf(v20, 0x20uLL, "Tag %d", a2);
    }
    else
    {
      _TIFFfreeExt((uint64_t)a1, (char *)v12);
      return 0;
    }
  }
  return v12;
}

uint64_t CGCreatePNGDataFromSVGData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGCreatePNGDataFromSVGData", 0, 0, -1, 0);
  if (a1)
  {
    if (a3)
      return 4294967292;
    _cg_jpeg_mem_term("CGCreatePNGDataFromSVGData", 293, "*** ERROR: CGCreatePNGDataFromSVGData - pngData is NULL\n");
  }
  else
  {
    _cg_jpeg_mem_term("CGCreatePNGDataFromSVGData", 292, "*** ERROR: CGCreatePNGDataFromSVGData - svgData is NULL\n");
  }
  return 4294967246;
}

_QWORD *PDFReadPlugin::PDFReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  _QWORD *result;

  result = (_QWORD *)IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *result = &off_1E1BAD698;
  result[56] = 0;
  result[57] = 0;
  result[55] = 0;
  return result;
}

_QWORD *PDFReadPlugin::PDFReadPlugin(uint64_t a1, uint64_t a2, int a3)
{
  _QWORD *result;

  result = (_QWORD *)IIOReadPlugin::IIOReadPlugin(a1, a2, a3);
  *result = &off_1E1BAD698;
  result[56] = 0;
  result[57] = 0;
  result[55] = 0;
  return result;
}

void PDFReadPlugin::~PDFReadPlugin(PDFReadPlugin *this)
{
  IIOReadPlugin::~IIOReadPlugin(this);
  JUMPOUT(0x18D761C30);
}

uint64_t PDFReadPlugin::loadDataFromXPCObject(PDFReadPlugin *this, void *a2)
{
  uint64_t result;
  _QWORD *data;
  _QWORD *v6;
  __int128 v7;
  size_t length;

  result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!(_DWORD)result)
  {
    length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_pdf", &length);
    if (length == 24)
    {
      v6 = data;
      result = 0;
      v7 = *(_OWORD *)v6;
      *((_QWORD *)this + 57) = v6[2];
      *(_OWORD *)((char *)this + 440) = v7;
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t PDFReadPlugin::saveDataToXPCObject(PDFReadPlugin *this, void *a2)
{
  uint64_t v4;

  v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!(_DWORD)v4)
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_pdf", (char *)this + 440, 0x18uLL);
  return v4;
}

uint64_t PDFReadPlugin::initialize(IIOImageReadSession **this, IIODictionary *a2)
{
  CGPDFDocument *SessionPDFRef;
  CGPDFDocument *v4;
  CGPDFPage *Page;
  CGPDFPage *v6;
  PDFReadPlugin *RotationAngle;
  int v8;
  double v9;
  double v10;
  double v11;
  double v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  float v17;
  unint64_t v18;
  float v19;
  float v20;
  float v21;
  BOOL v22;
  int v23;
  CFStringRef *v24;
  unsigned int v25;
  IIODictionary *v26;
  char v27;
  uint64_t v28;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;

  v34 = 0;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v30, this[3]);
  *((_QWORD *)&v31 + 1) = 0;
  if ((IIOImageReadSession::isFinal(this[3]) & 1) == 0
    || (SessionPDFRef = CreateSessionPDFRef((off_t *)&v30, 0), (v4 = SessionPDFRef) == 0))
  {
    v28 = 4294967246;
    goto LABEL_47;
  }
  Page = CGPDFDocumentGetPage(SessionPDFRef, (*((_DWORD *)this + 52) + 1));
  v6 = Page;
  if (!Page)
    goto LABEL_40;
  RotationAngle = (PDFReadPlugin *)CGPDFPageGetRotationAngle(Page);
  v8 = (int)RotationAngle;
  PDFReadPlugin::getPageBox(RotationAngle, v6);
  if (((v8 / 90) & 1) != 0)
    v11 = v10;
  else
    v11 = v9;
  if (((v8 / 90) & 1) != 0)
    v12 = v9;
  else
    v12 = v10;
  if (IIODictionary::containsKey(this[6], CFSTR("kCGImageSourceDrawAnnotations")))
    *((_BYTE *)this + 441) = IIODictionary::getBoolForKey(this[6], CFSTR("kCGImageSourceDrawAnnotations"));
  v13 = *((unsigned int *)this + 53);
  if (!(_DWORD)v13)
  {
    _cg_jpeg_mem_term("initialize", 113, "*** ERROR: PDF decode can only be used with 'CGImageSourceCreateThumbnailAtIndex'\n");
LABEL_40:
    v27 = 0;
    v28 = 4294967246;
    goto LABEL_46;
  }
  v14 = (unint64_t)v11;
  v15 = (unint64_t)v12;
  if ((unint64_t)v11 > v13 || v15 > v13)
  {
    v17 = (float)v13;
    if (v14 <= v15)
      v18 = (unint64_t)v12;
    else
      v18 = (unint64_t)v11;
    v19 = v17 / (float)v18;
    v20 = floorf(v19 * (float)v14);
    if (v14 >= v15)
      v20 = v17;
    v21 = floorf(v19 * (float)v15);
    if (v14 > v15)
      v17 = v21;
    if ((unint64_t)v20 <= 1)
      v14 = 1;
    else
      v14 = (unint64_t)v20;
    if ((unint64_t)v17 <= 1)
      v15 = 1;
    else
      v15 = (unint64_t)v17;
  }
  if (v14)
    v22 = v15 == 0;
  else
    v22 = 1;
  if (v22)
    goto LABEL_40;
  *((_DWORD *)this + 57) = v14;
  *((_DWORD *)this + 58) = v15;
  this[30] = (IIOImageReadSession *)0x5000400200008;
  *((_DWORD *)this + 59) = 4 * v14;
  *((_BYTE *)this + 344) = 0;
  *((_BYTE *)this + 346) = 0;
  *((_DWORD *)this + 81) = 1380401696;
  v23 = CGPDFPageContainsWideGamutContent();
  v24 = (CFStringRef *)MEMORY[0x1E0C9D908];
  if (!v23)
    v24 = (CFStringRef *)MEMORY[0x1E0C9DA10];
  this[20] = CGColorSpaceCreateWithName(*v24);
  this[56] = (IIOImageReadSession *)v14;
  this[57] = (IIOImageReadSession *)v15;
  *((_BYTE *)this + 440) = *((_DWORD *)this + 53) != 0;
  v25 = IIODictionary::containsKey(this[6], CFSTR("kCGImageSourceUsePDFBackgroundWhite"));
  v26 = this[6];
  if (v25)
  {
    *((_BYTE *)this + 442) = IIODictionary::getBoolForKey(v26, CFSTR("kCGImageSourceUsePDFBackgroundWhite"));
  }
  else if (IIODictionary::containsKey(v26, CFSTR("kCGImageSourceUsePDFBackgroundBlack")))
  {
    *((_BYTE *)this + 443) = IIODictionary::getBoolForKey(this[6], CFSTR("kCGImageSourceUsePDFBackgroundBlack"));
  }
  else if (*((_DWORD *)this + 53))
  {
    *((_BYTE *)this + 442) = 1;
  }
  v28 = 0;
  v27 = 1;
  this[45] = (IIOImageReadSession *)1;
  *((_WORD *)this + 188) = 1;
LABEL_46:
  CGPDFDocumentRelease(v4);
  if ((v27 & 1) == 0)
LABEL_47:
    kdebug_trace();
  IIOScanner::~IIOScanner((IIOScanner *)&v30);
  return v28;
}

void sub_187F97EA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  IIOScanner::~IIOScanner((IIOScanner *)&a9);
  _Unwind_Resume(a1);
}

double PDFReadPlugin::getPageBox(PDFReadPlugin *this, CGPDFPageRef page)
{
  CGFloat x;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  double result;
  CGRect BoxRect;
  CGRect v9;
  CGRect v10;

  BoxRect = CGPDFPageGetBoxRect(page, kCGPDFCropBox);
  x = BoxRect.origin.x;
  y = BoxRect.origin.y;
  width = BoxRect.size.width;
  height = BoxRect.size.height;
  v10 = CGPDFPageGetBoxRect(page, kCGPDFMediaBox);
  v9.origin.x = x;
  v9.origin.y = y;
  v9.size.width = width;
  v9.size.height = height;
  *(_QWORD *)&result = (unint64_t)CGRectIntersection(v9, v10);
  return result;
}

CGFloat PDFReadPlugin::getPageDrawingTransform@<D0>(PDFReadPlugin *this@<X0>, CGPDFPage *a2@<X1>, CGRect a3@<0:D0, 8:D1, 16:D2, 24:D3>, uint64_t a4@<X8>)
{
  CGFloat x;
  CGFloat v7;
  CGFloat v8;
  CGFloat v9;
  CGFloat v10;
  float MinY;
  float MaxX;
  double MaxY;
  float v14;
  float v15;
  int v16;
  int v17;
  float v18;
  float v19;
  float v20;
  __int128 v21;
  double v22;
  double v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  CGFloat result;
  float v36;
  double MinX;
  float v38;
  CGFloat y;
  CGFloat width;
  CGFloat height;
  CGAffineTransform v42;
  CGAffineTransform v43;
  CGAffineTransform v44;
  CGAffineTransform v45;
  CGAffineTransform v46;
  CGAffineTransform v47;
  CGAffineTransform v48;
  CGAffineTransform t2;
  CGAffineTransform t1;
  CGAffineTransform v51;
  CGRect v52;
  CGRect v53;
  CGRect v54;
  CGRect v55;
  CGRect v56;
  CGRect v57;
  CGRect v58;
  CGRect v59;
  CGRect v60;
  CGRect v61;

  width = a3.size.width;
  height = a3.size.height;
  y = a3.origin.y;
  x = a3.origin.x;
  *(_OWORD *)(a4 + 16) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)a4 = 0u;
  memset(&v51, 0, sizeof(v51));
  v52.origin.x = PDFReadPlugin::getPageBox(this, a2);
  v7 = v52.origin.x;
  v8 = v52.origin.y;
  v9 = v52.size.width;
  v10 = v52.size.height;
  MinX = CGRectGetMinX(v52);
  v53.origin.x = v7;
  v53.origin.y = v8;
  v53.size.width = v9;
  v53.size.height = v10;
  MinY = CGRectGetMinY(v53);
  v36 = MinY;
  v54.origin.x = v7;
  v54.origin.y = v8;
  v54.size.width = v9;
  v54.size.height = v10;
  MaxX = CGRectGetMaxX(v54);
  v55.origin.x = v7;
  v55.origin.y = v8;
  v55.size.width = v9;
  v55.size.height = v10;
  MaxY = CGRectGetMaxY(v55);
  v56.origin.x = v7;
  v56.origin.y = v8;
  v56.size.width = v9;
  v56.size.height = v10;
  v14 = CGRectGetWidth(v56);
  v57.origin.x = v7;
  v57.origin.y = v8;
  v57.size.width = v9;
  v57.size.height = v10;
  v15 = CGRectGetHeight(v57);
  v16 = CGPDFPageGetRotationAngle(a2) % 360;
  v17 = v16 + (v16 < 0 ? 0x168 : 0);
  if (v17 == 90)
  {
    v19 = -v36;
    *(_OWORD *)a4 = xmmword_18820F310;
    *(_OWORD *)(a4 + 16) = xmmword_18820EF70;
    goto LABEL_6;
  }
  if (v17 == 180)
  {
    *(_QWORD *)a4 = 0xBFF0000000000000;
    *(_QWORD *)(a4 + 8) = 0;
    *(_QWORD *)(a4 + 16) = 0;
    *(_QWORD *)(a4 + 24) = 0xBFF0000000000000;
    v19 = MaxX;
    MaxX = MaxY;
  }
  else
  {
    v18 = MinX;
    if (v17 == 270)
    {
      MaxX = -v18;
      *(_OWORD *)a4 = xmmword_18820F320;
      *(_OWORD *)(a4 + 16) = xmmword_18820F330;
      v19 = MaxY;
LABEL_6:
      v20 = v14;
      v14 = v15;
      goto LABEL_10;
    }
    v19 = -v18;
    MaxX = -v36;
    *(_QWORD *)a4 = 0x3FF0000000000000;
    *(_QWORD *)(a4 + 8) = 0;
    *(_QWORD *)(a4 + 16) = 0;
    *(_QWORD *)(a4 + 24) = 0x3FF0000000000000;
  }
  v20 = v15;
LABEL_10:
  v38 = v20;
  *(double *)(a4 + 32) = v19;
  *(double *)(a4 + 40) = MaxX;
  CGAffineTransformMakeTranslation(&v51, (float)(v14 * -0.5), (float)(v20 * -0.5));
  v21 = *(_OWORD *)(a4 + 16);
  *(_OWORD *)&t1.a = *(_OWORD *)a4;
  *(_OWORD *)&t1.c = v21;
  *(_OWORD *)&t1.tx = *(_OWORD *)(a4 + 32);
  t2 = v51;
  CGAffineTransformConcat((CGAffineTransform *)a4, &t1, &t2);
  v58.origin.x = x;
  v58.origin.y = y;
  v58.size.width = width;
  v58.size.height = height;
  v22 = CGRectGetMinX(v58);
  v59.origin.x = x;
  v59.origin.y = y;
  v59.size.width = width;
  v59.size.height = height;
  v23 = CGRectGetMinY(v59);
  v60.origin.x = x;
  v60.origin.y = y;
  v60.size.width = width;
  v60.size.height = height;
  v24 = CGRectGetWidth(v60);
  v61.origin.x = x;
  v61.origin.y = y;
  v61.size.width = width;
  v61.size.height = height;
  v25 = CGRectGetHeight(v61);
  v26 = v24 / v14;
  if ((float)(v24 / v14) < (float)(v25 / v38))
    v26 = v25 / v38;
  CGAffineTransformMakeScale(&v48, v26, v26);
  v51 = v48;
  v29 = *(_OWORD *)(a4 + 16);
  *(_OWORD *)&v47.a = *(_OWORD *)a4;
  *(_OWORD *)&v47.c = v29;
  *(_OWORD *)&v47.tx = *(_OWORD *)(a4 + 32);
  v46 = v48;
  CGAffineTransformConcat(&v48, &v47, &v46);
  v30 = *(_OWORD *)&v48.c;
  *(_OWORD *)a4 = *(_OWORD *)&v48.a;
  *(_OWORD *)(a4 + 16) = v30;
  *(_OWORD *)(a4 + 32) = *(_OWORD *)&v48.tx;
  CGAffineTransformMakeTranslation(&v48, (float)(v24 * 0.5), (float)(v25 * 0.5));
  v51 = v48;
  v31 = *(_OWORD *)(a4 + 16);
  *(_OWORD *)&v45.a = *(_OWORD *)a4;
  *(_OWORD *)&v45.c = v31;
  *(_OWORD *)&v45.tx = *(_OWORD *)(a4 + 32);
  v44 = v48;
  CGAffineTransformConcat(&v48, &v45, &v44);
  v32 = *(_OWORD *)&v48.c;
  *(_OWORD *)a4 = *(_OWORD *)&v48.a;
  *(_OWORD *)(a4 + 16) = v32;
  *(_OWORD *)(a4 + 32) = *(_OWORD *)&v48.tx;
  v28 = v22;
  v27 = v23;
  CGAffineTransformMakeTranslation(&v48, v28, v27);
  v51 = v48;
  v33 = *(_OWORD *)(a4 + 16);
  *(_OWORD *)&v43.a = *(_OWORD *)a4;
  *(_OWORD *)&v43.c = v33;
  *(_OWORD *)&v43.tx = *(_OWORD *)(a4 + 32);
  v42 = v48;
  CGAffineTransformConcat(&v48, &v43, &v42);
  v34 = *(_OWORD *)&v48.c;
  *(_OWORD *)a4 = *(_OWORD *)&v48.a;
  *(_OWORD *)(a4 + 16) = v34;
  result = v48.tx;
  *(_OWORD *)(a4 + 32) = *(_OWORD *)&v48.tx;
  return result;
}

uint64_t PDFReadPlugin::decodeImageData(IIOImageReadSession **this, unsigned __int8 *a2)
{
  size_t v4;
  size_t v5;
  size_t v6;
  CGPDFDocument *SessionPDFRef;
  CGPDFDocument *v8;
  CGPDFPage *Page;
  PDFReadPlugin *v10;
  CGColorSpace *v11;
  uint64_t v12;
  int v13;
  int v14;
  uint32_t v15;
  CGContext *v16;
  CGAffineTransform v18;
  CGAffineTransform v19;
  _OWORD v20[4];
  uint64_t v21;
  CGAffineTransform v22;
  CGRect v23;

  v4 = *((unsigned int *)this + 66);
  v5 = *((unsigned int *)this + 65);
  v6 = *((unsigned int *)this + 75);
  v21 = 0;
  memset(v20, 0, sizeof(v20));
  IIOScanner::IIOScanner((IIOScanner *)v20, this[3]);
  SessionPDFRef = CreateSessionPDFRef((off_t *)v20, 0);
  v8 = SessionPDFRef;
  if (SessionPDFRef)
  {
    Page = CGPDFDocumentGetPage(SessionPDFRef, (*((_DWORD *)this + 52) + 1));
    v10 = (PDFReadPlugin *)pthread_mutex_lock(&PDFReadPlugin::decodeImageData(unsigned char *,unsigned long)::lock);
    v23.size.width = (double)v5;
    v23.size.height = (double)v4;
    v23.origin.x = 0.0;
    v23.origin.y = 0.0;
    PDFReadPlugin::getPageDrawingTransform(v10, Page, v23, (uint64_t)&v19);
    v22 = v19;
    v11 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
    if (v11)
    {
      if (PDFReadPlugin::decodeImageData(unsigned char *,unsigned long)::onceToken != -1)
        dispatch_once(&PDFReadPlugin::decodeImageData(unsigned char *,unsigned long)::onceToken, &__block_literal_global_4);
      if (*((_BYTE *)this + 443))
      {
        bzero(a2, v6 * (unint64_t)v4);
      }
      else if (*((_BYTE *)this + 440) || *((_BYTE *)this + 442))
      {
        memset(a2, 255, v6 * (unint64_t)v4);
      }
      if (*((_BYTE *)this + 440))
        v13 = 5;
      else
        v13 = 1;
      if (*((_BYTE *)this + 440))
        v14 = 8198;
      else
        v14 = 8194;
      if (*((_BYTE *)this + 405))
        v15 = v13;
      else
        v15 = v14;
      v16 = CGBitmapContextCreate(a2, v5, v4, 8uLL, v6, v11, v15);
      if (v16)
      {
        if (*((_BYTE *)this + 440))
          CGContextSetTextGreekingThreshold();
        CGContextSetShouldSmoothFonts(v16, 0);
        v18 = v22;
        CGContextConcatCTM(v16, &v18);
        if (*((_BYTE *)this + 441))
          CGContextDrawPDFPageWithAnnotations();
        else
          CGContextDrawPDFPage(v16, Page);
        CGContextRelease(v16);
        v12 = 0;
      }
      else
      {
        _cg_jpeg_mem_term("decodeImageData", 319, "*** ERROR: CGBitmapContextCreate returned NULL\n");
        v12 = 4294967243;
      }
      CGColorSpaceRelease(v11);
    }
    else
    {
      v12 = 4294967243;
    }
    pthread_mutex_unlock(&PDFReadPlugin::decodeImageData(unsigned char *,unsigned long)::lock);
    CGPDFDocumentRelease(v8);
  }
  else
  {
    _cg_jpeg_mem_term("decodeImageData", 278, "*** could not create PDFDocument\n");
    v12 = 4294967243;
  }
  IIOScanner::~IIOScanner((IIOScanner *)v20);
  return v12;
}

void sub_187F9857C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  IIOScanner::~IIOScanner((IIOScanner *)va);
  _Unwind_Resume(a1);
}

uint64_t PDFReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4)
{
  int v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t BlockArray;
  uint64_t v21;
  void *BaseAddress;
  size_t Height;
  size_t v24;
  double v25;
  double v26;
  unint64_t v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  double v33;
  double v34;
  size_t v36;
  CGRect v37;
  CGRect v38;

  v36 = 0;
  if ((gIIODebugFlags & 0x20000) != 0)
  {
    v8 = *((_DWORD *)this + 51);
    v9 = v8 >> 24;
    v10 = MEMORY[0x1E0C80978];
    if (v8 < 0)
    {
      v11 = __maskrune(v9, 0x40000uLL);
      v8 = *((_DWORD *)this + 51);
    }
    else
    {
      v11 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v9 + 60) & 0x40000;
    }
    if (v11)
      v12 = (v8 >> 24);
    else
      v12 = 46;
    v13 = v8 << 8 >> 24;
    if (v8 << 8 < 0)
    {
      v14 = __maskrune(v13, 0x40000uLL);
      v8 = *((_DWORD *)this + 51);
    }
    else
    {
      v14 = *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
    }
    if (v14)
      v15 = (v8 << 8 >> 24);
    else
      v15 = 46;
    v16 = (__int16)v8 >> 8;
    if (v8 << 16 < 0)
    {
      v17 = __maskrune(v16, 0x40000uLL);
      v8 = *((_DWORD *)this + 51);
    }
    else
    {
      v17 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
    }
    if (v17)
      v18 = ((__int16)v8 >> 8);
    else
      v18 = 46;
    if ((v8 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v10 + 4 * (char)v8 + 60) & 0x40000) != 0)
        goto LABEL_22;
    }
    else if (__maskrune((char)v8, 0x40000uLL))
    {
LABEL_22:
      v19 = *((char *)this + 204);
LABEL_25:
      ImageIOLog("  '%c%c%c%c' [%s] %s\n", v12, v15, v18, v19, iioTypeStr[a3], "virtual OSStatus PDFReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      goto LABEL_26;
    }
    v19 = 46;
    goto LABEL_25;
  }
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  BlockArray = IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
  if (a3 == 3)
  {
    v21 = IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
    LODWORD(v27) = *((_DWORD *)this + 73);
    v26 = (double)v27;
    v28 = *((_DWORD *)this + 74);
    v25 = (double)v28;
    v24 = *((unsigned int *)this + 75) * (unint64_t)v28;
    BaseAddress = (void *)_ImageIO_Malloc(v24, *((_QWORD *)this + 48), &v36, (uint64_t)kImageMalloc_PDF_Data[0], *((_DWORD *)this + 108), 0, 0);
  }
  else
  {
    v21 = BlockArray;
    if (a3 != 1 || !a4 || !*a4)
      return v21;
    IOSurfaceLock(*a4, 0, 0);
    BaseAddress = IOSurfaceGetBaseAddress(*a4);
    Height = IOSurfaceGetHeight(*a4);
    v24 = IOSurfaceGetBytesPerRow(*a4) * Height;
    v36 = v24;
    v25 = 0.0;
    v26 = 0.0;
  }
  if (BaseAddress)
  {
    v29 = (*(uint64_t (**)(IIOReadPlugin *, void *, size_t))(*(_QWORD *)this + 112))(this, BaseAddress, v24);
    if ((_DWORD)v29)
    {
      v21 = v29;
      *((_DWORD *)this + 26) = 0;
      if (a3 == 3)
        _ImageIO_Free((unint64_t)BaseAddress, v36);
    }
    else if (a3 == 3)
    {
      v30 = 0;
      v37.origin.x = 0.0;
      v37.origin.y = 0.0;
      v37.size.width = v26;
      v37.size.height = v25;
      **((_QWORD **)this + 12) = IIOReadPlugin::createImageBlock(this, BaseAddress, v24, v37, *((unsigned int *)this + 75), *((unsigned __int8 *)this + 343));
      if (CGRectEqualToRect(*(CGRect *)((char *)this + 120), *MEMORY[0x1E0C9D628]))
      {
        v31 = 0;
      }
      else
      {
        v38.origin.x = 0.0;
        v38.origin.y = 0.0;
        v38.size.width = v26;
        v38.size.height = v25;
        *(CGRect *)(&v31 - 1) = CGRectUnion(*(CGRect *)((char *)this + 120), v38);
        v30 = v32;
        v26 = v33;
        v25 = v34;
      }
      v21 = 0;
      *((_QWORD *)this + 15) = v30;
      *((_QWORD *)this + 16) = v31;
      *((double *)this + 17) = v26;
      *((double *)this + 18) = v25;
    }
    else
    {
      IOSurfaceUnlock(*a4, 0, 0);
      return 0;
    }
  }
  return v21;
}

double BMPReadPlugin::BMPReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t v5;
  double result;

  v5 = IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *(_QWORD *)v5 = &off_1E1BAC6C8;
  result = 0.0;
  *(_OWORD *)(v5 + 440) = 0u;
  *(_OWORD *)(v5 + 456) = 0u;
  *(_OWORD *)(v5 + 472) = 0u;
  return result;
}

double BMPReadPlugin::BMPReadPlugin(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  double result;

  v3 = IIOReadPlugin::IIOReadPlugin(a1, a2, a3);
  *(_QWORD *)v3 = &off_1E1BAC6C8;
  result = 0.0;
  *(_OWORD *)(v3 + 440) = 0u;
  *(_OWORD *)(v3 + 456) = 0u;
  *(_OWORD *)(v3 + 472) = 0u;
  return result;
}

void BMPReadPlugin::~BMPReadPlugin(BMPReadPlugin *this)
{
  IIOReadPlugin::~IIOReadPlugin(this);
  JUMPOUT(0x18D761C30);
}

uint64_t BMPReadPlugin::loadDataFromXPCObject(BMPReadPlugin *this, void *a2)
{
  uint64_t result;
  __int128 *data;
  __int128 *v6;
  __int128 v7;
  __int128 v8;
  size_t length;

  result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!(_DWORD)result)
  {
    length = 0;
    data = (__int128 *)xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_bmp", &length);
    if (length == 48)
    {
      v6 = data;
      result = 0;
      v7 = *v6;
      v8 = v6[2];
      *(_OWORD *)((char *)this + 456) = v6[1];
      *(_OWORD *)((char *)this + 472) = v8;
      *(_OWORD *)((char *)this + 440) = v7;
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t BMPReadPlugin::saveDataToXPCObject(BMPReadPlugin *this, void *a2)
{
  uint64_t v4;

  v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!(_DWORD)v4)
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_bmp", (char *)this + 440, 0x30uLL);
  return v4;
}

void BMPReadPlugin::debugHeader(uint64_t a1, int *a2)
{
  int v2;

  v2 = *a2;
  if (*a2 > 55)
  {
    if (v2 > 107)
    {
      if (v2 == 108)
      {
        ImageIOLog("bmp v4\n");
      }
      else if (v2 == 124)
      {
        ImageIOLog("bmp v5\n");
      }
    }
    else if (v2 == 56)
    {
      ImageIOLog("bmp v3 with RGBA masks\n");
    }
    else if (v2 == 64)
    {
      ImageIOLog("bmp OS2 v2\n");
    }
  }
  else if (v2 > 39)
  {
    if (v2 == 40)
    {
      ImageIOLog("bmp v3\n");
    }
    else if (v2 == 52)
    {
      ImageIOLog("bmp v3 with RGB masks\n");
    }
  }
  else if (v2 == 12)
  {
    ImageIOLog("bmp OS2 v1\n");
  }
  else if (v2 == 16)
  {
    ImageIOLog("bmp v2\n");
  }
}

uint64_t BMPReadPlugin::readHeader(uint64_t a1, uint64_t a2, IIOScanner *this)
{
  unsigned int Val32;
  uint64_t result;
  unsigned int v8;
  unint64_t v9;
  int v10;
  int Val16;
  uint64_t v12;
  unsigned int v13;
  unint64_t v14;
  unsigned int v15;
  unsigned int v16;
  int v17;

  IIOScanner::seek(this, 0);
  IIOScanner::getVal8(this);
  IIOScanner::getVal8(this);
  Val32 = IIOScanner::getVal32(this);
  IIOScanner::getVal32(this);
  result = IIOScanner::getVal32(this);
  *(_DWORD *)(a1 + 448) = result;
  if ((_DWORD)result)
  {
    v8 = result;
    v9 = *(_QWORD *)(a1 + 184);
    if (v9 <= result)
      return 0;
    if (v9 < Val32)
    {
      _cg_jpeg_mem_term("readHeader", 129, "*** fileHdr.filesize > fileSize (%d > %d) - continuing...\n", Val32, v9);
      v9 = *(_QWORD *)(a1 + 184);
    }
    if (v9 <= 0x1A)
    {
      _cg_jpeg_mem_term("readHeader", 132, "*** fileSize (%d) too small\n");
      return 0;
    }
    if (v8 <= 0x19)
    {
      _cg_jpeg_mem_term("readHeader", 133, "*** dataOffset (%d) too small\n");
      return 0;
    }
    if (v9 <= v8)
    {
      _cg_jpeg_mem_term("readHeader", 134, "*** dataOffset (%d) too big\n");
      return 0;
    }
    v10 = IIOScanner::getVal32(this);
    *(_DWORD *)a2 = v10;
    if (((v10 - 12) > 0x34 || ((1 << (v10 - 12)) & 0x10110010000011) == 0)
      && v10 != 124
      && v10 != 108)
    {
      return 0;
    }
    *(_DWORD *)(a2 + 4) = IIOScanner::getVal32(this);
    *(_DWORD *)(a2 + 8) = IIOScanner::getVal32(this);
    Val16 = IIOScanner::getVal16(this);
    *(_WORD *)(a2 + 12) = Val16;
    if (*(_DWORD *)a2 != 12 && Val16 != 1)
      return 0;
    v12 = IIOScanner::getVal16(this);
    *(_WORD *)(a2 + 14) = v12;
    v13 = *(_DWORD *)a2;
    if (*(_DWORD *)a2 == 12)
    {
      v13 = 12;
      goto LABEL_36;
    }
    if ((_DWORD)v12 != 1)
    {
      if ((_DWORD)v12 == 2 && v13 == 40)
        goto LABEL_20;
      HIDWORD(v14) = v12;
      LODWORD(v14) = ((_DWORD)v12 << 16) - 0x40000;
      v15 = (unsigned __int16)(v14 >> 18);
      if (v15 > 7 || ((1 << v15) & 0xAB) == 0)
      {
        _cg_jpeg_mem_term("readHeader", 165, "*** ERROR: BMP-header-size: %d - does not support bpp: %d\n");
        return 0;
      }
    }
    if (v13 < 0x10)
      goto LABEL_36;
LABEL_20:
    v12 = IIOScanner::getVal32(this);
    *(_DWORD *)(a2 + 16) = v12;
    v13 = *(_DWORD *)a2;
    if (*(_DWORD *)a2 == 40 && (_DWORD)v12 == 3)
    {
      *(_DWORD *)a2 = 52;
    }
    else if (v13 < 0x28)
    {
      goto LABEL_36;
    }
    *(_DWORD *)(a2 + 20) = IIOScanner::getVal32(this);
    *(_DWORD *)(a2 + 24) = IIOScanner::getVal32(this);
    *(_DWORD *)(a2 + 28) = IIOScanner::getVal32(this);
    *(_DWORD *)(a2 + 32) = IIOScanner::getVal32(this);
    v12 = IIOScanner::getVal32(this);
    *(_DWORD *)(a2 + 36) = v12;
    v16 = *(_DWORD *)(a2 + 32);
    if (v16 >= 0x101)
    {
      _cg_jpeg_mem_term("readHeader", 186, "*** ERROR: unsupported number of colors in palette (%d)\n");
    }
    else
    {
      if (v12 <= v16)
      {
        v13 = *(_DWORD *)a2;
        if (*(_DWORD *)a2 == 64)
        {
          v13 = 64;
        }
        else if (v13 >= 0x34)
        {
          *(_DWORD *)(a2 + 40) = IIOScanner::getVal32(this);
          *(_DWORD *)(a2 + 44) = IIOScanner::getVal32(this);
          v12 = IIOScanner::getVal32(this);
          *(_DWORD *)(a2 + 48) = v12;
          v13 = *(_DWORD *)a2;
          if (*(_DWORD *)a2 >= 0x38u)
          {
            v12 = IIOScanner::getVal32(this);
            *(_DWORD *)(a2 + 52) = v12;
            v13 = *(_DWORD *)a2;
            if (*(_DWORD *)a2 >= 0x6Cu)
            {
              *(_DWORD *)(a2 + 56) = IIOScanner::getVal32(this);
              *(_DWORD *)(a2 + 60) = IIOScanner::getVal32(this);
              *(_DWORD *)(a2 + 64) = IIOScanner::getVal32(this);
              *(_DWORD *)(a2 + 68) = IIOScanner::getVal32(this);
              *(_DWORD *)(a2 + 72) = IIOScanner::getVal32(this);
              *(_DWORD *)(a2 + 76) = IIOScanner::getVal32(this);
              *(_DWORD *)(a2 + 80) = IIOScanner::getVal32(this);
              *(_DWORD *)(a2 + 84) = IIOScanner::getVal32(this);
              *(_DWORD *)(a2 + 88) = IIOScanner::getVal32(this);
              *(_DWORD *)(a2 + 92) = IIOScanner::getVal32(this);
              *(_DWORD *)(a2 + 96) = IIOScanner::getVal32(this);
              *(_DWORD *)(a2 + 100) = IIOScanner::getVal32(this);
              v12 = IIOScanner::getVal32(this);
              *(_DWORD *)(a2 + 104) = v12;
              v13 = *(_DWORD *)a2;
              if (*(_DWORD *)a2 >= 0x7Cu)
              {
                *(_DWORD *)(a2 + 108) = IIOScanner::getVal32(this);
                *(_DWORD *)(a2 + 112) = IIOScanner::getVal32(this);
                *(_DWORD *)(a2 + 116) = IIOScanner::getVal32(this);
                v12 = IIOScanner::getVal32(this);
                *(_DWORD *)(a2 + 120) = v12;
                v13 = *(_DWORD *)a2;
              }
            }
          }
        }
LABEL_36:
        *(_DWORD *)(a1 + 452) = v13 + 14;
        if (*(_BYTE *)(a1 + 177))
        {
          BMPReadPlugin::debugHeader(v12, (int *)a2);
          v13 = *(_DWORD *)a2;
        }
        if (v13 == 64)
        {
          v17 = 40;
        }
        else
        {
          if (v13 != 12)
            return 1;
          *(_DWORD *)(a2 + 12) = *(_DWORD *)(a2 + 8);
          *(_WORD *)(a2 + 10) = 0;
          *(_WORD *)(a2 + 8) = *(_WORD *)(a2 + 6);
          *(_WORD *)(a2 + 6) = 0;
          v17 = 16;
        }
        *(_DWORD *)a2 = v17;
        return 1;
      }
      _cg_jpeg_mem_term("readHeader", 187, "*** ERROR: bad number of important colors (%d/%d)\n");
    }
    return 0;
  }
  return result;
}

uint64_t BMPReadPlugin::initialize(BMPReadPlugin *this, IIODictionary *a2)
{
  int v3;
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  float v7;
  float v8;
  float v9;
  float v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  int32x4_t v18;
  int32x4_t v19;
  int32x4_t v20;
  __int8 v21;
  int8x8_t v22;
  unsigned int Uint32ForKey;
  unsigned int v24;
  __int16 *v25;
  __int16 v26;
  unsigned int v27;
  int v28;
  unsigned int v29;
  unint64_t v30;
  unsigned int v31;
  unsigned int v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unsigned int v39;
  unsigned int v40;
  size_t v41;
  unsigned int v42;
  _BOOL4 v43;
  _BOOL4 v44;
  unint64_t v45;
  size_t v46;
  unsigned __int8 *v47;
  int v48;
  uint64_t v49;
  size_t v50;
  uint64_t v51;
  uint64_t v52;
  unsigned __int8 v53;
  unsigned __int8 v54;
  unsigned int v55;
  unsigned int v56;
  BOOL v57;
  char v59;
  CGColorSpace *v60;
  int v61;
  signed int v62;
  int v63;
  int v64;
  unsigned int v65;
  uint64_t v66;
  int8x8_t v68;
  _BYTE v69[24];
  _BYTE v70[24];
  _OWORD v71[4];
  uint64_t v72;
  __int128 v73;
  __int128 v74;
  _OWORD v75[7];

  v74 = 0u;
  memset(v75, 0, 92);
  v73 = 0u;
  v72 = 0;
  memset(v71, 0, sizeof(v71));
  IIOScanner::IIOScanner((IIOScanner *)v71, *((IIOImageReadSession **)this + 3));
  if (*((_BYTE *)this + 341) && (BMPReadPlugin::readHeader((uint64_t)this, (uint64_t)&v73, (IIOScanner *)v71) & 1) != 0)
  {
    v3 = DWORD2(v73);
    v4 = v73;
    if ((SDWORD2(v73) & 0x80000000) == 0)
      v5 = DWORD2(v73);
    else
      v5 = -DWORD2(v73);
    if ((_DWORD)v73 == 40 && (_DWORD)v74 == 3)
      *((_DWORD *)this + 113) = 66;
    v6 = DWORD1(v73);
    bzero((char *)&v73 + v4, 124 - v4);
    if (DWORD2(v74) && HIDWORD(v74))
    {
      v7 = (float)DWORD2(v74) * 0.0254;
      v8 = (float)HIDWORD(v74) * 0.0254;
      if (fabsf(v7 + -72.0) < 0.05)
        v7 = 72.0;
      if (fabsf(v8 + -72.0) < 0.05)
        v8 = 72.0;
      if (fabsf(v7 + -96.0) >= 0.05)
        v9 = v7;
      else
        v9 = 96.0;
      if (fabsf(v8 + -96.0) >= 0.05)
        v10 = v8;
      else
        v10 = 96.0;
      if (ValidDPI(v9) && ValidDPI(v10))
      {
        v11 = *((_QWORD *)this + 7);
        IIONumber::IIONumber((IIONumber *)v70, v9);
        IIODictionary::setObjectForKey(v11, (uint64_t)v70, CFSTR("DPIWidth"));
        IIONumber::~IIONumber((IIONumber *)v70);
        v12 = *((_QWORD *)this + 7);
        IIONumber::IIONumber((IIONumber *)v69, v10);
        IIODictionary::setObjectForKey(v12, (uint64_t)v69, CFSTR("DPIHeight"));
        IIONumber::~IIONumber((IIONumber *)v69);
      }
    }
    *((_DWORD *)this + 57) = v6;
    *((_DWORD *)this + 58) = v5;
    v13 = HIWORD(v73);
    *((_WORD *)this + 121) = HIWORD(v73);
    v14 = v74;
    *((_DWORD *)this + 114) = v74;
    if (v6)
    {
      if (v3 && WORD6(v73) == 1)
      {
        v15 = v73;
        if (v73 < 0x7C)
        {
          if (v73 >= 0x6C && DWORD2(v75[1]) > 1)
            goto LABEL_164;
        }
        else if ((DWORD2(v75[1]) > 4 || DWORD2(v75[1]) == 3) && DWORD2(v75[1]) != 1934772034)
        {
          goto LABEL_164;
        }
        if (v13 <= 15)
        {
          switch(v13)
          {
            case 1:
              if (!v14)
                goto LABEL_73;
              v16 = 1;
              v17 = 353;
              break;
            case 2:
              if (!v14)
                goto LABEL_73;
              v16 = 2;
              v17 = 356;
              break;
            case 4:
              if ((v14 | 2) == 2)
                goto LABEL_73;
              v16 = 4;
              v17 = 359;
              break;
            case 8:
              if (v14 < 2)
                goto LABEL_73;
              v16 = 8;
              v17 = 362;
              break;
            default:
              goto LABEL_164;
          }
          goto LABEL_163;
        }
        switch(v13)
        {
          case 16:
            if (v14)
            {
              if (v14 != 3)
              {
                v16 = 16;
                v17 = 365;
                goto LABEL_163;
              }
              goto LABEL_52;
            }
            goto LABEL_73;
          case 24:
            if (v14)
            {
              v16 = 24;
              v17 = 368;
              goto LABEL_163;
            }
            goto LABEL_58;
          case 32:
            if (v14)
            {
              if (v14 != 3)
              {
                v16 = 32;
                v17 = 371;
LABEL_163:
                _cg_jpeg_mem_term("initialize", v17, "bitsPerPixel: %d   compression: %d\n", v16, v14);
                break;
              }
LABEL_52:
              if (v73 < 0x34)
                break;
              v18.i64[0] = *((_QWORD *)&v75[0] + 1);
              if ((HIDWORD(v75[0]) & DWORD2(v75[0])) != 0
                || (v75[1] & DWORD2(v75[0])) != 0
                || (DWORD1(v75[1]) | LODWORD(v75[1])) & HIDWORD(v75[0]) | DWORD1(v75[1]) & (LODWORD(v75[1]) | DWORD2(v75[0])))
              {
                break;
              }
              v18.i64[1] = *(_QWORD *)&v75[1];
              v19 = (int32x4_t)vbicq_s8((int8x16_t)vpaddlq_u16(vpaddlq_u8((uint8x16_t)vcntq_s8((int8x16_t)v18))), (int8x16_t)vceqzq_s32(v18));
              v20.i32[0] = BMPReadPlugin::countBitsAndCalculateShift(unsigned int,int *,int *)::Mod37BitPosition[(DWORD2(v75[0]) & -DWORD2(v75[0])) % 0x25];
              v20.i32[1] = BMPReadPlugin::countBitsAndCalculateShift(unsigned int,int *,int *)::Mod37BitPosition[(HIDWORD(v75[0]) & -HIDWORD(v75[0])) % 0x25];
              v20.i32[2] = BMPReadPlugin::countBitsAndCalculateShift(unsigned int,int *,int *)::Mod37BitPosition[(v75[1] & -LODWORD(v75[1])) % 0x25];
              v20.i32[3] = BMPReadPlugin::countBitsAndCalculateShift(unsigned int,int *,int *)::Mod37BitPosition[(DWORD1(v75[1]) & -DWORD1(v75[1])) % 0x25];
              *((_BYTE *)this + 485) = v19.i8[8];
              *((_BYTE *)this + 484) = v19.i8[4];
              v21 = v19.i8[12];
              *((_BYTE *)this + 483) = v19.i8[0];
              v22 = vbic_s8((int8x8_t)vadd_s16(vmovn_s32(vaddq_s32(v19, v20)), (int16x4_t)0xF800F800F800F8), (int8x8_t)vmovn_s32(vceqzq_s32(v19)));
              goto LABEL_75;
            }
LABEL_58:
            if (IIODictionary::containsKey(*((IIODictionary **)this + 6), CFSTR("kCGImageSourceSubsampleFactor")))
            {
              Uint32ForKey = IIODictionary::getUint32ForKey(*((IIODictionary **)this + 6), CFSTR("kCGImageSourceSubsampleFactor"));
              *((_WORD *)this + 158) = 1;
              if (v6 >= v5)
                v24 = v5;
              else
                v24 = v6;
              if (Uint32ForKey > v24)
                goto LABEL_73;
              v25 = (__int16 *)((char *)this + 316);
              if (Uint32ForKey >= 2)
              {
                if (Uint32ForKey >= 0x80)
                {
                  v21 = 0;
                  v26 = 128;
LABEL_181:
                  *v25 = v26;
                  goto LABEL_74;
                }
                if (Uint32ForKey >= 0x40)
                {
                  v21 = 0;
                  v26 = 64;
                  goto LABEL_181;
                }
                if (Uint32ForKey >= 0x20)
                {
LABEL_171:
                  v21 = 0;
                  v26 = 32;
                  goto LABEL_181;
                }
                if (Uint32ForKey < 0x10)
                {
                  if (Uint32ForKey < 8)
                  {
                    if (Uint32ForKey < 4)
                      goto LABEL_179;
LABEL_173:
                    v21 = 0;
                    v26 = 4;
                    goto LABEL_181;
                  }
LABEL_169:
                  v21 = 0;
                  v26 = 8;
                  goto LABEL_181;
                }
LABEL_72:
                v21 = 0;
                v26 = 16;
                goto LABEL_181;
              }
            }
            else
            {
              v25 = (__int16 *)((char *)this + 316);
              *((_WORD *)this + 158) = 1;
            }
            if (*((unsigned __int8 *)this + 216) >= 2u)
            {
              v27 = *((_DWORD *)this + 53);
              if (v27)
              {
                if (v27 < v6 >> 5 || v5 >> 5 > v27)
                  goto LABEL_171;
                if (v27 < v6 >> 4)
                  goto LABEL_72;
                if (v27 < v6 >> 3)
                  goto LABEL_169;
                if (v27 < v6 >> 2)
                  goto LABEL_173;
                if (v27 < v6 >> 1)
                {
LABEL_179:
                  v21 = 0;
                  v26 = 2;
                  goto LABEL_181;
                }
              }
              v21 = 0;
              v26 = 1;
              goto LABEL_181;
            }
LABEL_73:
            v21 = 0;
LABEL_74:
            v22 = 0;
LABEL_75:
            v68 = v22;
            v28 = *((_DWORD *)this + 114);
            switch(v28)
            {
              case 0:
              case 3:
                v29 = *((_DWORD *)this + 57);
                v30 = v29 * (unint64_t)*((unsigned __int16 *)this + 121);
                if ((v30 & 0xFFFFFFFF00000000) != 0)
                  goto LABEL_164;
                v31 = ((v30 + 31) >> 3) & 0x1FFFFFFC;
                v32 = *((_DWORD *)this + 58);
                v33 = v32 * (unint64_t)v31;
                if ((v33 & 0xFFFFFFFF00000000) != 0)
                  goto LABEL_164;
                if (!v31)
                {
                  _cg_jpeg_mem_term("initialize", 485, "*** ERROR: %dx%d - bpp=%d compression=%d --> rb=%d\n", v29, v32, *((unsigned __int16 *)this + 121), *((_DWORD *)this + 114), 0);
                  goto LABEL_164;
                }
                v34 = v33;
LABEL_91:
                if (!v34)
                  goto LABEL_164;
                *((_QWORD *)this + 20) = 0;
                *((_DWORD *)this + 81) = 1380401696;
                *((_BYTE *)this + 346) = 0;
                v39 = *((unsigned __int16 *)this + 121);
                if (v39 > 8)
                {
                  switch(v39)
                  {
                    case 0x20u:
                      v47 = 0;
                      *((_WORD *)this + 120) = 8;
                      *((_DWORD *)this + 68) = 2097160;
                      if (v21)
                        v57 = 0;
                      else
                        v57 = v28 == 3;
                      if (v57 || v15 == 40)
                        v59 = 5;
                      else
                        v59 = 3;
                      *((_WORD *)this + 138) = 4;
                      *((_BYTE *)this + 246) = v59;
                      *((_BYTE *)this + 278) = v59;
                      *((_BYTE *)this + 279) = 4;
                      *((_DWORD *)this + 67) = 4 * *((_DWORD *)this + 57);
                      v39 = 32;
                      break;
                    case 0x18u:
                      v47 = 0;
                      *((_WORD *)this + 120) = 8;
                      *((_QWORD *)this + 34) = 0x405000400200008;
                      break;
                    case 0x10u:
                      v47 = 0;
                      *((_WORD *)this + 120) = 8;
                      *((_DWORD *)this + 68) = 2097160;
                      *((_WORD *)this + 138) = 4;
                      *((_BYTE *)this + 278) = 5;
                      v39 = 16;
                      if (v28 == 3 && DWORD1(v75[1]))
                      {
                        v47 = 0;
                        *((_BYTE *)this + 246) = 3;
                      }
                      break;
                    default:
                      v47 = 0;
                      break;
                  }
                  goto LABEL_147;
                }
                *((_DWORD *)this + 68) = 524296;
                *((_WORD *)this + 138) = 1;
                *((_DWORD *)this + 67) = *((_DWORD *)this + 59);
                v40 = 1 << v39;
                if (v15 < 0x11)
                  v41 = 3;
                else
                  v41 = 4;
                v42 = (_DWORD)v41 << v39;
                v43 = LODWORD(v75[0]) != 0;
                v44 = LODWORD(v75[0]) < v40;
                if (v43 && v44)
                  v45 = (LODWORD(v75[0]) * v41);
                else
                  v45 = v42;
                if (v43 && v44)
                  v46 = LODWORD(v75[0]);
                else
                  v46 = v40;
                v47 = (unsigned __int8 *)malloc_type_calloc(v46, v41, 0x3F875340uLL);
                if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v47, *((unsigned int *)this + 113), v45) > v45)
                {
                  if (v47)
                    free(v47);
                  goto LABEL_164;
                }
                v48 = 0;
                v49 = 0;
                v50 = (v46 - 1);
                if (v46 <= 1)
                  v51 = 1;
                else
                  v51 = v46;
                v52 = v51 + 2 * v51;
                do
                {
                  v53 = v47[v48 + 1];
                  v54 = v47[v48];
                  v47[v49] = v47[v48 + 2];
                  v47[(v49 + 1)] = v53;
                  v47[(v49 + 2)] = v54;
                  v49 += 3;
                  v48 += v41;
                }
                while (v52 != v49);
                v55 = v15 + v45 + 14;
                v56 = *((_DWORD *)this + 112);
                if (v56 < v55 && v56 + 4 < v55)
                  *((_DWORD *)this + 112) = v55;
                if ((_DWORD)v46 != 2 || v13 != 1)
                  goto LABEL_144;
                if (*v47 == 255)
                {
                  if (v47[1] == 255 && v47[2] == 255 && !v47[3] && !v47[4] && !v47[5])
                  {
LABEL_182:
                    *((_QWORD *)this + 40) = 0x4752415900000000;
                    if (*v47 == 255 && v47[1] == 255 && v47[2] == 255 && !v47[3] && !v47[4] && !v47[5])
                      *((_BYTE *)this + 346) = 1;
LABEL_146:
                    v39 = *((unsigned __int16 *)this + 121);
                    *((_WORD *)this + 120) = v39;
                    *((_BYTE *)this + 246) = 0;
LABEL_147:
                    *((_BYTE *)this + 344) = 0;
                    if (!*((_DWORD *)this + 59))
                      *((_DWORD *)this + 59) = ((*((_DWORD *)this + 57) * v39 + 31) >> 3) & 0x1FFFFFFC;
                    *((_QWORD *)this + 55) = v34;
                    v61 = DWORD2(v73);
                    *((_BYTE *)this + 460) = SDWORD2(v73) > 0;
                    v62 = *((unsigned __int16 *)this + 158);
                    if (v62 >= 2)
                    {
                      v63 = SDWORD1(v73) / v62;
                      *((_DWORD *)this + 65) = SDWORD1(v73) / v62;
                      v64 = v61 / v62;
                      if (v64 < 0)
                        v64 = -v64;
                      *((_DWORD *)this + 66) = v64;
                      *((_DWORD *)this + 67) = 4 * v63;
                    }
                    *((_QWORD *)this + 45) = 1;
                    if (*((_DWORD *)this + 114) == 3)
                    {
                      *((_OWORD *)this + 29) = *(_OWORD *)((char *)v75 + 8);
                      *((_BYTE *)this + 480) = v68.i8[0];
                      *((_BYTE *)this + 481) = v68.i8[2];
                      *((_BYTE *)this + 482) = v68.i8[4];
                      *((_BYTE *)this + 486) = v68.i8[6];
                      *((_BYTE *)this + 487) = v21;
                    }
                    v65 = v39 / *((unsigned __int16 *)this + 120);
                    *((_WORD *)this + 122) = v65;
                    if (v65 == 1)
                      *((_DWORD *)this + 67) = (*((_DWORD *)this + 57) + 3) & 0xFFFFFFFC;
                    if (*((_WORD *)this + 137) == 32)
                      *((_BYTE *)this + 350) = 1;
                    *((_WORD *)this + 188) = 1;
                    if (v47)
                      free(v47);
                    v66 = 0;
                    goto LABEL_165;
                  }
                }
                else if (!*v47 && !v47[1] && !v47[2] && v47[3] == 255 && v47[4] == 255 && v47[5] == 255)
                {
                  goto LABEL_182;
                }
LABEL_144:
                v60 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
                *((_QWORD *)this + 20) = CGColorSpaceCreateIndexed(v60, v50, v47);
                *((_QWORD *)this + 40) = 0x5247422000000005;
                CGColorSpaceRelease(v60);
                if (*((_WORD *)this + 121) == 8)
                {
                  *((_DWORD *)this + 67) = 4 * *((_DWORD *)this + 57);
                  *(_DWORD *)((char *)this + 274) = 262176;
                }
                goto LABEL_146;
              case 1:
                v34 = DWORD1(v74);
                v35 = *((_QWORD *)this + 23);
                if (!DWORD1(v74) || v35 <= DWORD1(v74))
                  v34 = v35 - *((unsigned int *)this + 112);
                v36 = v6 * (unint64_t)v5;
                if ((v36 & 0xFFFFFFFF00000000) != 0)
                  goto LABEL_164;
                if (35 * v35 > v36)
                  goto LABEL_91;
                _cg_jpeg_mem_term("initialize", 505, "malformed 8bitRLE-BMP?  %ld < (35 * %ld) = %ld   [%g]\n", v6 * (unint64_t)v5, v35, 35 * v35, (double)v36 / (double)v35);
                goto LABEL_164;
              case 2:
                v34 = DWORD1(v74);
                v37 = *((_QWORD *)this + 23);
                if (!DWORD1(v74) || v37 <= DWORD1(v74))
                  v34 = v37 - *((unsigned int *)this + 112);
                v38 = v6 * (unint64_t)v5;
                if ((v38 & 0xFFFFFFFF00000000) != 0)
                  goto LABEL_164;
                if (130 * v37 > v38)
                  goto LABEL_91;
                _cg_jpeg_mem_term("initialize", 496, "malformed 4bitRLE-BMP?\n");
                goto LABEL_164;
              default:
                goto LABEL_164;
            }
        }
      }
    }
  }
LABEL_164:
  kdebug_trace();
  v66 = 4294967246;
LABEL_165:
  IIOScanner::~IIOScanner((IIOScanner *)v71);
  return v66;
}

void sub_187F99B34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  IIOScanner::~IIOScanner((IIOScanner *)va);
  _Unwind_Resume(a1);
}

uint64_t BMPReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v2;

  v2 = *(__int16 *)(a1 + 376);
  if (v2 == 12)
    return IIOReadPlugin::setupImageProviderCallbackV2(a1, a2, (uint64_t)IIO_Reader::CopyImageBlockSetProc, (uint64_t)IIO_Reader::CopyIOSurfaceProc);
  if (v2 == 1)
    return IIOReadPlugin::setupCallback(a1, a2);
  return 4294967246;
}

uint64_t BMPReadPlugin::decodeRLE(BMPReadPlugin *this, unsigned __int8 *a2)
{
  size_t v4;
  char *v5;
  char *v6;
  int64_t BytesAtOffset;
  uint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  unint64_t v14;
  unsigned __int8 *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int64_t v19;
  unint64_t v20;
  unint64_t v21;
  BOOL v22;
  unint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  BOOL v27;
  BOOL v28;
  uint64_t v29;
  unsigned __int8 *v30;
  int v31;
  unsigned int i;
  char v33;
  unsigned int j;
  unint64_t v35;
  char v36;
  unsigned __int8 *v37;
  uint64_t v38;
  unsigned __int8 v39;
  unint64_t v40;
  unint64_t v41;

  if (*((_QWORD *)this + 55) <= 0x400uLL)
    v4 = 1024;
  else
    v4 = *((_QWORD *)this + 55);
  v5 = (char *)malloc_type_calloc(v4, 1uLL, 0x5969A9C3uLL);
  if (v5)
  {
    v6 = v5;
    BytesAtOffset = IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v5, *((unsigned int *)this + 112), *((_QWORD *)this + 55));
    if (BytesAtOffset == *((_QWORD *)this + 55))
    {
      if (*((_BYTE *)this + 460))
        v8 = *((unsigned int *)this + 66) - 1;
      else
        v8 = 0;
      v9 = 0;
      v10 = &v6[BytesAtOffset];
      v11 = v8 * *((unsigned int *)this + 75);
      v12 = BytesAtOffset + (_BYTE)v6;
      v13 = (uint64_t)v6;
LABEL_10:
      v14 = 0;
      v15 = &a2[v11];
      while (1)
      {
        while (1)
        {
          v16 = 0;
          v17 = 0;
          v18 = v13;
          v19 = BytesAtOffset;
          v20 = *((unsigned int *)this + 66);
          v21 = v9;
          do
          {
            v9 = v21;
            v22 = v20 >= v21;
            v23 = v20 - v21;
            if (v23 == 0 || !v22)
              goto LABEL_66;
            v24 = v16;
            if (v19 + v16 < 2)
              goto LABEL_66;
            v25 = *(unsigned __int8 *)(v18 + v17);
            v26 = *(unsigned __int8 *)(v18 + v17 + 1);
            if (*(_BYTE *)(v18 + v17))
              v27 = 0;
            else
              v27 = (_DWORD)v26 == 0;
            if (v27)
            {
              if (*((_BYTE *)this + 460))
                v41 = v23 - 2;
              else
                v41 = v9 + 1;
              ++v9;
              v11 = v41 * *((unsigned int *)this + 75);
              BytesAtOffset = v19 - v17 - 2;
              v13 = v18 + v17 + 2;
              goto LABEL_10;
            }
            v17 += 2;
            v16 -= 2;
            if (v25)
              v28 = 0;
            else
              v28 = (_DWORD)v26 == 1;
            v21 = *((unsigned int *)this + 66);
          }
          while (v28);
          if (!v25 && (_DWORD)v26 == 2)
          {
            v29 = v19 - v17;
            if ((unint64_t)(v19 - v17 + 2) >= 4)
            {
              v30 = (unsigned __int8 *)(v18 + v17);
              v14 += *v30;
              v13 = (uint64_t)(v30 + 2);
              v9 += v30[1];
              BytesAtOffset = v29 - 2;
              continue;
            }
          }
          BytesAtOffset = v19 + v16;
          v13 = v18 + v17;
          v31 = *((_DWORD *)this + 114);
          if (v31 == 1)
            break;
          if (v31 != 2)
            continue;
          if (!v25)
          {
            if ((_DWORD)v26)
            {
              v35 = 0;
              while (v14 + v35 < *((unsigned int *)this + 65))
              {
                if (BytesAtOffset <= v35 >> 1)
                  goto LABEL_66;
                v36 = *(_BYTE *)(v18 + (v35 >> 1) + v17);
                if ((v35 & 1) == 0)
                  v36 = *(_BYTE *)(v18 + (v35 >> 1) + v17) >> 4;
                v15[v14 + v35++] = v36 & 0xF;
                if ((_DWORD)v26 == (_DWORD)v35)
                {
                  v14 += v35;
                  goto LABEL_60;
                }
              }
              v14 += v35;
            }
LABEL_60:
            v40 = (((unint64_t)(v26 + 1) >> 1) & 1) + ((unint64_t)(v26 + 1) >> 1);
            v13 = v18 + v17 + v40;
            goto LABEL_61;
          }
          for (i = 0; i < v25; ++i)
          {
            if (v14 >= *((unsigned int *)this + 65))
              break;
            v33 = (i & 1) != 0 ? v26 : v26 >> 4;
            v15[v14++] = v33 & 0xF;
          }
        }
        if (!v25)
        {
          if (v18 + v26 + v17 > (unint64_t)v10)
            LOBYTE(v26) = v12 - v18 - v17;
          if ((_BYTE)v26)
          {
            LOWORD(v26) = v26;
            v37 = (unsigned __int8 *)(v18 - v24 + 2);
            v38 = v26;
            do
            {
              if (v14 >= *((unsigned int *)this + 65))
                break;
              v39 = *v37++;
              v15[v14++] = v39;
              --v38;
            }
            while (v38);
          }
          else
          {
            LOWORD(v26) = 0;
          }
          v40 = ((_WORD)v26 + 1) & 0x1FE;
          v13 = v18 + v40 + v17;
LABEL_61:
          BytesAtOffset = v19 - v40 - v17;
          continue;
        }
        for (j = 0; j < v25; ++j)
        {
          if (v14 >= *((unsigned int *)this + 65))
            break;
          v15[v14++] = v26;
        }
      }
    }
LABEL_66:
    free(v6);
  }
  return 1;
}

uint64_t BMPReadPlugin::decodeBitField(BMPReadPlugin *this, unsigned __int8 *a2, size_t a3)
{
  _BOOL4 v6;
  _BOOL4 v7;
  size_t v8;
  char *v9;
  char *v10;
  int v11;
  int v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  char *v16;
  unint64_t v17;
  unsigned __int8 *v18;
  unsigned __int8 *v19;
  int v20;
  int v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  unsigned int v32;
  int v33;
  int v34;
  uint64_t v35;
  int v36;
  int v37;
  unsigned __int8 *v38;
  vImagePixelCount v39;
  unint64_t v40;
  char *v41;
  unint64_t v42;
  unsigned __int8 *v43;
  int v44;
  unsigned int v45;
  unsigned int v46;
  unsigned int v47;
  unsigned __int8 v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  unsigned __int8 v52;
  unsigned int v53;
  unsigned int v54;
  unsigned int v55;
  unsigned __int8 v56;
  unsigned int v57;
  int v58;
  unsigned int v59;
  uint64_t v60;
  vImagePixelCount v61;
  size_t v62;
  void *v64;
  uint64_t v65;
  int8x16_t v66;
  vImagePixelCount v67;
  size_t v68;
  uint64_t v69;
  int8x16_t v70;
  vImagePixelCount v71;
  size_t v72;
  vImage_Error v73;
  vImage_Error v74;
  vImage_Buffer v75;
  vImage_Buffer dest;

  v6 = *((_BYTE *)this + 405) != 0;
  v7 = *((_BYTE *)this + 405) == 0;
  if (*((_QWORD *)this + 55) <= 0x400uLL)
    v8 = 1024;
  else
    v8 = *((_QWORD *)this + 55);
  v9 = (char *)malloc_type_calloc(v8, 1uLL, 0xF5DA81FEuLL);
  if (v9)
  {
    v10 = v9;
    if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v9, *((unsigned int *)this + 112), *((_QWORD *)this + 55)) == *((_QWORD *)this + 55))
    {
      v11 = *((unsigned __int16 *)this + 121);
      if (v11 == 32)
      {
        v36 = *((unsigned __int8 *)this + 460);
        v37 = *((_DWORD *)this + 66);
        v38 = a2;
        if (*((_BYTE *)this + 460))
          v38 = &a2[(v37 - 1) * *((_DWORD *)this + 75)];
        if (v37)
        {
          v39 = 0;
          LODWORD(v40) = *((_DWORD *)this + 65);
          v41 = v10;
          do
          {
            if ((_DWORD)v40)
            {
              v42 = 0;
              v43 = v38;
              do
              {
                v44 = *(_DWORD *)&v41[4 * v42];
                v45 = *((_DWORD *)this + 116) & v44;
                v46 = v45 << -*((_BYTE *)this + 480);
                v47 = v45 >> *((_BYTE *)this + 480);
                if (*((char *)this + 480) >= 0)
                  v48 = v47;
                else
                  v48 = v46;
                v43[2 * v7] = v48;
                v49 = *((_DWORD *)this + 117) & v44;
                v50 = v49 << -*((_BYTE *)this + 481);
                v51 = v49 >> *((_BYTE *)this + 481);
                if (*((char *)this + 481) >= 0)
                  v52 = v51;
                else
                  v52 = v50;
                v43[1] = v52;
                v53 = *((_DWORD *)this + 118) & v44;
                v54 = v53 << -*((_BYTE *)this + 482);
                v55 = v53 >> *((_BYTE *)this + 482);
                if (*((char *)this + 482) >= 0)
                  v56 = v55;
                else
                  v56 = v54;
                v43[2 * v6] = v56;
                if (*((_BYTE *)this + 487))
                {
                  if (*((_BYTE *)this + 487) == 1)
                  {
                    if ((*((_DWORD *)this + 119) & v44) != 0)
                      LOBYTE(v57) = -1;
                    else
                      LOBYTE(v57) = 0;
                  }
                  else
                  {
                    v58 = *((char *)this + 486);
                    v59 = *((_DWORD *)this + 119) & v44;
                    if (v58 < 0)
                      v57 = v59 << -(char)v58;
                    else
                      v57 = v59 >> v58;
                  }
                }
                else
                {
                  LOBYTE(v57) = -1;
                }
                v43[3] = v57;
                ++v42;
                v43 += 4;
                v40 = *((unsigned int *)this + 65);
              }
              while (v42 < v40);
              v36 = *((unsigned __int8 *)this + 460);
            }
            v41 += *((unsigned int *)this + 59);
            v60 = *((unsigned int *)this + 75);
            if (v36)
              v60 = -v60;
            v38 += v60;
            ++v39;
            v61 = *((unsigned int *)this + 66);
          }
          while (v39 < v61);
        }
        else
        {
          v61 = 0;
        }
        if (*((_BYTE *)this + 406) == 1)
        {
          dest.data = a2;
          dest.height = v61;
          v62 = *((unsigned int *)this + 75);
          dest.width = *((unsigned int *)this + 65);
          dest.rowBytes = v62;
          vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
        }
      }
      else if (v11 == 16)
      {
        if (*((_DWORD *)this + 116) == 63488
          && *((_DWORD *)this + 117) == 2016
          && *((_DWORD *)this + 118) == 31
          && !*((_BYTE *)this + 487))
        {
          if (*((_BYTE *)this + 460))
          {
            v64 = malloc_type_malloc(a3, 0x1F5C34AEuLL);
            v65 = *(_QWORD *)((char *)this + 228);
            v66.i64[0] = v65;
            v66.i64[1] = HIDWORD(v65);
            *(int8x16_t *)&dest.height = vextq_s8(v66, v66, 8uLL);
            dest.rowBytes = *((unsigned int *)this + 59);
            v67 = *((unsigned int *)this + 74);
            v75.data = v64;
            v75.height = v67;
            v68 = *((unsigned int *)this + 75);
            v75.width = *((unsigned int *)this + 73);
            v75.rowBytes = v68;
            dest.data = v10;
            if (*((_BYTE *)this + 405))
              vImageConvert_RGB565toRGBA8888(0xFFu, &dest, &v75, 0);
            else
              vImageConvert_RGB565toBGRA8888(0xFFu, &dest, &v75, 0);
            dest = v75;
            v75.data = a2;
            v74 = vImageVerticalReflect_ARGB8888(&dest, &v75, 0x10u);
            free(v64);
          }
          else
          {
            v69 = *(_QWORD *)((char *)this + 228);
            v70.i64[0] = v69;
            v70.i64[1] = HIDWORD(v69);
            *(int8x16_t *)&dest.height = vextq_s8(v70, v70, 8uLL);
            dest.rowBytes = *((unsigned int *)this + 59);
            v71 = *((unsigned int *)this + 74);
            v75.data = a2;
            v75.height = v71;
            v72 = *((unsigned int *)this + 75);
            v75.width = *((unsigned int *)this + 73);
            v75.rowBytes = v72;
            dest.data = v10;
            if (*((_BYTE *)this + 405))
              v73 = vImageConvert_RGB565toRGBA8888(0xFFu, &dest, &v75, 0);
            else
              v73 = vImageConvert_RGB565toBGRA8888(0xFFu, &dest, &v75, 0);
            v74 = v73;
          }
          if (v74)
            _cg_jpeg_mem_term("decodeBitField", 997, "    err = %d\n", v74);
        }
        else
        {
          v12 = *((unsigned __int8 *)this + 460);
          v13 = *((_DWORD *)this + 66);
          if (*((_BYTE *)this + 460))
            a2 += ((v13 - 1) * *((_DWORD *)this + 75));
          if (v13)
          {
            v14 = 0;
            LODWORD(v15) = *((_DWORD *)this + 65);
            v16 = v10;
            do
            {
              if ((_DWORD)v15)
              {
                v17 = 0;
                v18 = (unsigned __int8 *)(v16 + 1);
                v19 = a2;
                do
                {
                  v20 = *(v18 - 1);
                  v21 = v20 | (*v18 << 8);
                  v22 = v21 & *((_DWORD *)this + 116);
                  v23 = v21 & *((_DWORD *)this + 117);
                  v24 = *((_DWORD *)this + 118);
                  v25 = v22 << -*((_BYTE *)this + 480);
                  v26 = v22 >> *((_BYTE *)this + 480);
                  if (*((char *)this + 480) < 0)
                    LOBYTE(v26) = v25;
                  v19[2 * v7] = v26;
                  v19[2 * v7] = v26 | (v26 >> (8 - *((_BYTE *)this + 483)));
                  v27 = v24 & v21;
                  v28 = v23 << -*((_BYTE *)this + 481);
                  v29 = v23 >> *((_BYTE *)this + 481);
                  if (*((char *)this + 481) < 0)
                    LOBYTE(v29) = v28;
                  v19[1] = v29;
                  v19[1] = v29 | (v29 >> (8 - *((_BYTE *)this + 484)));
                  v30 = v27 << -*((_BYTE *)this + 482);
                  v31 = v27 >> *((_BYTE *)this + 482);
                  if (*((char *)this + 482) < 0)
                    LOBYTE(v31) = v30;
                  v19[2 * v6] = v31;
                  v19[2 * v6] = v31 | (v31 >> (8 - *((_BYTE *)this + 485)));
                  if (*((_BYTE *)this + 487))
                  {
                    if (*((_BYTE *)this + 487) == 1)
                    {
                      if ((*((_DWORD *)this + 119) & v21) != 0)
                        LOBYTE(v32) = -1;
                      else
                        LOBYTE(v32) = 0;
                    }
                    else
                    {
                      v33 = *((char *)this + 486);
                      v34 = *((_DWORD *)this + 119);
                      if (v33 < 0)
                        v32 = (v34 & v20) << -(char)v33;
                      else
                        v32 = (v34 & v21) >> v33;
                    }
                  }
                  else
                  {
                    LOBYTE(v32) = -1;
                  }
                  v18 += 2;
                  v19[3] = v32;
                  ++v17;
                  v19 += 4;
                  v15 = *((unsigned int *)this + 65);
                }
                while (v17 < v15);
                v12 = *((unsigned __int8 *)this + 460);
              }
              v16 += *((unsigned int *)this + 59);
              v35 = *((unsigned int *)this + 75);
              if (v12)
                v35 = -v35;
              a2 += v35;
              ++v14;
            }
            while (v14 < *((unsigned int *)this + 66));
          }
        }
      }
    }
    free(v10);
  }
  return 1;
}

uint64_t BMPReadPlugin::decodeUncompressed(BMPReadPlugin *this, unsigned __int8 *a2)
{
  char *v4;
  unsigned int v5;
  int v7;
  size_t v8;
  char *v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  unint64_t v13;
  int v14;
  int v15;
  int v16;
  size_t v17;
  char *v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  unsigned int v22;
  _BOOL4 v23;
  _BOOL4 v24;
  int v25;
  size_t v26;
  char *v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  unsigned int v32;
  unsigned __int8 *v33;
  char *v34;
  int v35;
  int v36;
  unsigned int v37;
  int v38;
  char *v39;
  unsigned int v40;
  size_t v41;
  size_t v42;
  unsigned int v43;
  int v44;
  unsigned int v45;
  int v46;
  unsigned int v47;
  int v48;
  vImagePixelCount v49;
  size_t v50;
  unsigned int v51;
  unsigned int v52;
  int v53;
  unsigned int v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  unsigned __int8 *v58;
  char v59;
  unsigned __int8 *v60;
  int v61;
  vImagePixelCount v62;
  size_t v63;
  unsigned int v64;
  unsigned int v65;
  unsigned int v66;
  unsigned __int8 *v67;
  int v69;
  int v70;
  vImage_Buffer dest;
  uint8_t permuteMap[4];
  vImage_Buffer v73;
  vImage_Buffer v74;
  vImage_Buffer src;
  __int128 v76;
  unsigned int v77[3];

  v4 = 0;
  v5 = *((unsigned __int16 *)this + 121);
  if (v5 <= 0xF)
  {
    if (v5 - 1 >= 2 && v5 != 4)
    {
      if (v5 != 8)
        goto LABEL_86;
      v16 = *((_DWORD *)this + 58);
      if (*((_QWORD *)this + 55) <= (unint64_t)(v16 * *((_DWORD *)this + 59)))
        v17 = (v16 * *((_DWORD *)this + 59));
      else
        v17 = *((_QWORD *)this + 55);
      v18 = (char *)malloc_type_calloc(v17, 1uLL, 0x660B1A99uLL);
      if (!v18)
        return 1;
      v4 = v18;
      if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v18, *((unsigned int *)this + 112), v17) != v17)goto LABEL_115;
      v19 = *((_DWORD *)this + 66);
      if (v19)
      {
        v20 = 0;
        v21 = -1;
        do
        {
          v22 = v19 + v21;
          if (!*((_BYTE *)this + 460))
            v22 = v20;
          memcpy(&a2[*((_DWORD *)this + 75) * v22], &v4[*((_DWORD *)this + 59) * v20++], *((unsigned int *)this + 59));
          v19 = *((_DWORD *)this + 66);
          --v21;
        }
        while (v20 < v19);
      }
      goto LABEL_85;
    }
    v7 = *((_DWORD *)this + 58);
    if (*((_QWORD *)this + 55) <= (unint64_t)(v7 * *((_DWORD *)this + 59)))
      v8 = (v7 * *((_DWORD *)this + 59));
    else
      v8 = *((_QWORD *)this + 55);
    v9 = (char *)malloc_type_calloc(v8, 1uLL, 0x2FA52361uLL);
    if (!v9)
      return 1;
    v4 = v9;
    if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v9, *((unsigned int *)this + 112), v8) != v8)goto LABEL_115;
    v10 = *((_DWORD *)this + 81);
    if (v10 == 1380401696)
    {
      if (*((_DWORD *)this + 100) == 1768842360)
      {
        v11 = operator new();
        IIOPixelConverterIndexed::IIOPixelConverterIndexed(v11, 12, *((unsigned __int8 *)this + 244), *((unsigned __int8 *)this + 242), 12, 8, 0, 0);
      }
      else
      {
        v11 = operator new();
        IIOPixelConverterRGB::IIOPixelConverterRGB(v11, 0, *((_BYTE *)this + 244), *((unsigned __int8 *)this + 242), *((unsigned __int8 *)this + 242), *((unsigned __int8 *)this + 242), 0, 0, 8u, 0, 0);
      }
      goto LABEL_79;
    }
    if (v10 == 1196573017)
    {
      v11 = operator new();
      IIOPixelConverterGray::IIOPixelConverterGray(v11, 6, *((_BYTE *)this + 244), *((unsigned __int8 *)this + 242), 0, 6, 8u, 0, 0);
LABEL_79:
      v51 = *((_DWORD *)this + 66);
      if (v51)
      {
        v52 = 0;
        v53 = -1;
        do
        {
          v54 = v51 + v53;
          if (!*((_BYTE *)this + 460))
            v54 = v52;
          (*(void (**)(uint64_t, char *, unsigned __int8 *, _QWORD))(*(_QWORD *)v11 + 24))(v11, &v4[*((_DWORD *)this + 59) * v52++], &a2[*((_DWORD *)this + 75) * v54], *((unsigned int *)this + 65));
          v51 = *((_DWORD *)this + 66);
          --v53;
        }
        while (v52 < v51);
      }
      (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
    }
LABEL_85:
    v5 = *((unsigned __int16 *)this + 121);
    goto LABEL_86;
  }
  if (v5 == 16)
  {
    v23 = *((_BYTE *)this + 405) != 0;
    v24 = *((_BYTE *)this + 405) == 0;
    v25 = *((_DWORD *)this + 58);
    if (*((_QWORD *)this + 55) <= (unint64_t)(v25 * *((_DWORD *)this + 59)))
      v26 = (v25 * *((_DWORD *)this + 59));
    else
      v26 = *((_QWORD *)this + 55);
    v27 = (char *)malloc_type_calloc(v26, 1uLL, 0x35C20FBBuLL);
    if (!v27)
      return 1;
    v4 = v27;
    if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v27, *((unsigned int *)this + 112), v26) != v26)goto LABEL_115;
    v28 = *((_DWORD *)this + 66);
    if (v28)
    {
      v29 = 0;
      v30 = *((_DWORD *)this + 65);
      do
      {
        if (v30)
        {
          v31 = 0;
          v32 = v28 + ~v29;
          if (!*((_BYTE *)this + 460))
            v32 = v29;
          v33 = &a2[*((_DWORD *)this + 75) * v32];
          v34 = &v4[*((_DWORD *)this + 59) * v29 + 1];
          do
          {
            v35 = *v34;
            v36 = *(v34 - 1);
            v33[2 * v24] = (2 * v35) & 0xF8;
            v33[1] = ((v36 | (v35 << 8)) >> 2) & 0xF8;
            v33[2 * v23] = 8 * v36;
            v33[3] = -1;
            ++v31;
            v33 += 4;
            v30 = *((_DWORD *)this + 65);
            v34 += 2;
          }
          while (v31 < v30);
          v28 = *((_DWORD *)this + 66);
        }
        ++v29;
      }
      while (v29 < v28);
    }
    goto LABEL_85;
  }
  if (v5 != 24 && v5 != 32)
  {
LABEL_86:
    if (v5 == 32)
    {
      v55 = *((unsigned __int8 *)this + 246);
      if (v55 != 5 && v55 != 3)
        goto LABEL_103;
    }
    else
    {
      if (v5 != 24
        || *((_BYTE *)this + 246) != 5
        || *((_DWORD *)this + 75) < (4 * *((_DWORD *)this + 65)))
      {
        goto LABEL_114;
      }
      v55 = 5;
    }
    v56 = *((unsigned int *)this + 66);
    if ((_DWORD)v56)
    {
      v57 = 0;
      v58 = a2 + 3;
      v59 = 1;
      do
      {
        if (*((_DWORD *)this + 65))
        {
          v60 = &v58[(*((_DWORD *)this + 75) * v57)];
          v61 = *((_DWORD *)this + 65);
          while (!*v60)
          {
            v60 += 4;
            if (!--v61)
              goto LABEL_101;
          }
          v59 = 0;
        }
LABEL_101:
        ++v57;
      }
      while (v57 != v56);
      if ((v59 & 1) == 0)
      {
LABEL_103:
        if (*((_BYTE *)this + 405) && v55 != 5 && *((_BYTE *)this + 406) == 1)
        {
          v62 = *((unsigned int *)this + 66);
          src.data = a2;
          src.height = v62;
          v63 = *((unsigned int *)this + 75);
          src.width = *((unsigned int *)this + 65);
          src.rowBytes = v63;
          vImagePremultiplyData_RGBA8888(&src, &src, 0x10u);
          if (v4)
            goto LABEL_115;
          return 1;
        }
        goto LABEL_114;
      }
      v64 = 0;
      v65 = *((_DWORD *)this + 65);
      do
      {
        if (v65)
        {
          v66 = 0;
          v67 = &v58[*((_DWORD *)this + 75) * v64];
          do
          {
            *v67 = -1;
            v67 += 4;
            ++v66;
            v65 = *((_DWORD *)this + 65);
          }
          while (v66 < v65);
          LODWORD(v56) = *((_DWORD *)this + 66);
        }
        ++v64;
      }
      while (v64 < v56);
    }
LABEL_114:
    if (v4)
      goto LABEL_115;
    return 1;
  }
  if (*((unsigned __int16 *)this + 158) <= 1u)
    v12 = 1;
  else
    v12 = *((unsigned __int16 *)this + 158);
  *((_WORD *)this + 158) = v12;
  v69 = *((_DWORD *)this + 59);
  LODWORD(v13) = v69 * v12;
  v14 = 1;
  v77[0] = 1;
  if (*((_BYTE *)this + 460))
  {
    v15 = *((_DWORD *)this + 74) - 1;
    v14 = -1;
  }
  else
  {
    v15 = 0;
  }
  v37 = *((_DWORD *)this + 112);
  v38 = *((_DWORD *)this + 75);
  v39 = (char *)malloc_type_calloc(v69 * v12, 1uLL, 0xC1C49B0CuLL);
  if (!v39)
    return 1;
  v4 = v39;
  v70 = v14;
  v76 = 0u;
  memset(&src, 0, sizeof(src));
  IIOSubsampler::IIOSubsampler((IIOSubsampler *)&src, *((_DWORD *)this + 57), *((_DWORD *)this + 59), (*((unsigned __int8 *)this + 247) << 12) | (*((unsigned __int8 *)this + 248) << 16) | ((*((_BYTE *)this + 249) != 0) << 8) | *((unsigned __int8 *)this + 246), *((_WORD *)this + 120), *((_WORD *)this + 121) >> 3, *((_WORD *)this + 158), 2 * (*((_WORD *)this + 121) != 32), *((_DWORD *)this + 73), *((_DWORD *)this + 75));
  v74.data = v4;
  v74.height = 1;
  v40 = *((_DWORD *)this + 58);
  v41 = *((unsigned int *)this + 59);
  v74.width = *((unsigned int *)this + 73);
  v74.rowBytes = v41;
  *(_OWORD *)&v73.data = xmmword_18820C490;
  v42 = *((unsigned int *)this + 75);
  v73.width = v74.width;
  v73.rowBytes = v42;
  if (!v40)
  {
LABEL_71:
    v48 = *((unsigned __int16 *)this + 121);
    if (v48 == 24)
    {
      if (*((_BYTE *)this + 405))
      {
LABEL_77:
        IIOSubsampler::~IIOSubsampler((IIOSubsampler *)&src);
        goto LABEL_85;
      }
    }
    else if (v48 != 32 || !*((_BYTE *)this + 405))
    {
      goto LABEL_77;
    }
    *(_DWORD *)permuteMap = 50331906;
    v49 = *((unsigned int *)this + 74);
    dest.data = a2;
    dest.height = v49;
    v50 = *((unsigned int *)this + 75);
    dest.width = *((unsigned int *)this + 73);
    dest.rowBytes = v50;
    vImagePermuteChannels_ARGB8888(&dest, &dest, permuteMap, 0x10u);
    goto LABEL_77;
  }
  v43 = 0;
  v44 = v15 * v38;
  v45 = v15 + v70;
  v46 = v70 * v38;
  while (1)
  {
    v47 = v12 + v43;
    if (v12 + v43 > v40)
      v12 = v40 - v43;
    v13 = v47 <= v40 ? v13 : (v40 - v43) * v69;
    if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v4, v37, v13) != v13)
      break;
    if (*((unsigned __int16 *)this + 158) >= 2u)
    {
      v77[0] = 1;
      IIOSubsampler::subsample((IIOSubsampler *)&src, (unsigned __int8 *)v4, v12, &a2[v44], v77);
      goto LABEL_68;
    }
    if (*((_WORD *)this + 121) != 32)
    {
      v73.data = &a2[v44];
      vImageConvert_RGB888toBGRA8888(&v74, 0, 0xFFu, &v73, 0, 0x10u);
LABEL_68:
      if ((v45 & 0x80000000) != 0)
        goto LABEL_71;
      goto LABEL_69;
    }
    memcpy(&a2[v44], v4, (4 * *((_DWORD *)this + 73)));
    if ((v45 & 0x80000000) != 0)
      goto LABEL_71;
LABEL_69:
    if (v45 < *((_DWORD *)this + 74))
    {
      v37 += v13;
      v43 += v12;
      v40 = *((_DWORD *)this + 58);
      v44 += v46;
      v45 += v70;
      if (v43 < v40)
        continue;
    }
    goto LABEL_71;
  }
  IIOSubsampler::~IIOSubsampler((IIOSubsampler *)&src);
LABEL_115:
  free(v4);
  return 1;
}

void sub_187F9AB6C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10F1C401865CEE3);
  _Unwind_Resume(a1);
}

uint64_t BMPReadPlugin::decodeImageData(BMPReadPlugin *this, unsigned __int8 *a2, size_t a3)
{
  int v3;

  v3 = *((_DWORD *)this + 114);
  if ((v3 - 1) < 2)
  {
    BMPReadPlugin::decodeRLE(this, a2);
  }
  else if (v3 == 3)
  {
    BMPReadPlugin::decodeBitField(this, a2, a3);
  }
  else if (v3)
  {
    LogError("decodeImageData", 1413, "unknown BMP compression: %d\n", v3);
  }
  else
  {
    BMPReadPlugin::decodeUncompressed(this, a2);
  }
  return 0;
}

uint64_t BMPReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4)
{
  int v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  IIOImageRead **v21;
  _BOOL4 v22;
  uint64_t BlockArray;
  void *BaseAddress;
  size_t Height;
  size_t v26;
  double v27;
  double v28;
  unint64_t v29;
  unsigned int v30;
  uint64_t v31;
  const char **v32;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  double v37;
  double v38;
  unint64_t v39;
  CGRect v40;
  CGRect v41;

  v39 = 0;
  if ((gIIODebugFlags & 0x20000) != 0)
  {
    v8 = *((_DWORD *)this + 51);
    v9 = v8 >> 24;
    v10 = MEMORY[0x1E0C80978];
    if (v8 < 0)
    {
      v11 = __maskrune(v9, 0x40000uLL);
      v8 = *((_DWORD *)this + 51);
    }
    else
    {
      v11 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v9 + 60) & 0x40000;
    }
    if (v11)
      v12 = (v8 >> 24);
    else
      v12 = 46;
    v13 = v8 << 8 >> 24;
    if (v8 << 8 < 0)
    {
      v14 = __maskrune(v13, 0x40000uLL);
      v8 = *((_DWORD *)this + 51);
    }
    else
    {
      v14 = *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
    }
    if (v14)
      v15 = (v8 << 8 >> 24);
    else
      v15 = 46;
    v16 = (__int16)v8 >> 8;
    if (v8 << 16 < 0)
    {
      v17 = __maskrune(v16, 0x40000uLL);
      v8 = *((_DWORD *)this + 51);
    }
    else
    {
      v17 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
    }
    if (v17)
      v18 = ((__int16)v8 >> 8);
    else
      v18 = 46;
    if ((v8 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v10 + 4 * (char)v8 + 60) & 0x40000) != 0)
        goto LABEL_22;
    }
    else if (__maskrune((char)v8, 0x40000uLL))
    {
LABEL_22:
      v19 = *((char *)this + 204);
LABEL_25:
      ImageIOLog("  '%c%c%c%c' [%s] %s\n", v12, v15, v18, v19, iioTypeStr[a3], "virtual OSStatus BMPReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      goto LABEL_26;
    }
    v19 = 46;
    goto LABEL_25;
  }
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  if (!*((_BYTE *)this + 414))
    return 4294967115;
  if (*((unsigned __int16 *)this + 158) >= 2u)
  {
    v20 = (*((_DWORD *)this + 73) * (*((unsigned __int16 *)this + 153) >> 3) + 15) & 0xFFFFFFF0;
    *((_DWORD *)this + 67) = v20;
    *((_DWORD *)this + 75) = v20;
  }
  v21 = (IIOImageRead **)*((_QWORD *)this + 3);
  if (v21)
    v22 = IIOImageReadSession::mapData(v21);
  else
    v22 = 0;
  if (a3 == 3)
  {
    BlockArray = IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
    LODWORD(v29) = *((_DWORD *)this + 73);
    v28 = (double)v29;
    v30 = *((_DWORD *)this + 74);
    v27 = (double)v30;
    v26 = *((unsigned int *)this + 75) * (unint64_t)v30;
    BaseAddress = (void *)_ImageIO_Malloc(v26, *((_QWORD *)this + 48), &v39, (uint64_t)kImageMalloc_BMP_Data[0], *((_DWORD *)this + 108), 0, 0);
  }
  else
  {
    if (a3 != 1 || !a4 || !*a4)
      goto LABEL_46;
    IOSurfaceLock(*a4, 0, 0);
    BaseAddress = IOSurfaceGetBaseAddress(*a4);
    Height = IOSurfaceGetHeight(*a4);
    BlockArray = 0;
    v26 = IOSurfaceGetBytesPerRow(*a4) * Height;
    v39 = v26;
    v27 = 0.0;
    v28 = 0.0;
  }
  if (!BaseAddress)
    goto LABEL_47;
  bzero(BaseAddress, v26);
  v31 = (*(uint64_t (**)(IIOReadPlugin *, void *, unint64_t))(*(_QWORD *)this + 112))(this, BaseAddress, v39);
  if ((_DWORD)v31)
  {
    BlockArray = v31;
    if (a3 == 3)
    {
      _ImageIO_Free((unint64_t)BaseAddress, v39);
      if (!v22)
        return BlockArray;
      goto LABEL_48;
    }
LABEL_47:
    if (!v22)
      return BlockArray;
    goto LABEL_48;
  }
  if (a3 != 3)
  {
    IOSurfaceUnlock(*a4, 0, 0);
LABEL_46:
    BlockArray = 0;
    goto LABEL_47;
  }
  v34 = 0;
  v40.origin.x = 0.0;
  v40.origin.y = 0.0;
  v40.size.width = v28;
  v40.size.height = v27;
  **((_QWORD **)this + 12) = IIOReadPlugin::createImageBlock(this, BaseAddress, v39, v40, *((unsigned int *)this + 75), *((unsigned __int8 *)this + 343));
  if (CGRectEqualToRect(*(CGRect *)((char *)this + 120), *MEMORY[0x1E0C9D628]))
  {
    v35 = 0;
  }
  else
  {
    v41.origin.x = 0.0;
    v41.origin.y = 0.0;
    v41.size.width = v28;
    v41.size.height = v27;
    *(CGRect *)(&v35 - 1) = CGRectUnion(*(CGRect *)((char *)this + 120), v41);
    v34 = v36;
    v28 = v37;
    v27 = v38;
  }
  BlockArray = 0;
  *((_QWORD *)this + 15) = v34;
  *((_QWORD *)this + 16) = v35;
  *((double *)this + 17) = v28;
  *((double *)this + 18) = v27;
  if (v22)
  {
LABEL_48:
    v32 = (const char **)*((_QWORD *)this + 3);
    if (v32)
      IIOImageReadSession::unmapData(v32);
  }
  return BlockArray;
}

uint64_t TIFFReadDirEntryOutputErr(uint64_t a1, int a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;

  if ((_DWORD)a5)
  {
    switch(a2)
    {
      case 1:
        result = TIFFWarningExtR(a1, a3, "Incorrect count for \"%s\"; tag ignored", a4, a5, a6, a7, a8, a4);
        break;
      case 2:
        result = TIFFWarningExtR(a1, a3, "Incompatible type for \"%s\"; tag ignored", a4, a5, a6, a7, a8, a4);
        break;
      case 3:
        result = TIFFWarningExtR(a1, a3, "IO error during reading of \"%s\"; tag ignored", a4, a5, a6, a7, a8, a4);
        break;
      case 4:
        result = TIFFWarningExtR(a1, a3, "Incorrect value for \"%s\"; tag ignored", a4, a5, a6, a7, a8, a4);
        break;
      case 5:
        result = TIFFWarningExtR(a1, a3, "Cannot handle different values per sample for \"%s\"; tag ignored",
                   a4,
                   a5,
                   a6,
                   a7,
                   a8,
                   a4);
        break;
      case 6:
        result = TIFFWarningExtR(a1, a3, "Sanity check on size of \"%s\" value failed; tag ignored",
                   a4,
                   a5,
                   a6,
                   a7,
                   a8,
                   a4);
        break;
      case 7:
        result = TIFFWarningExtR(a1, a3, "Out of memory reading of \"%s\"; tag ignored", a4, a5, a6, a7, a8, a4);
        break;
      default:
        TIFFReadDirEntryOutputErr_cold_2();
    }
  }
  else
  {
    switch(a2)
    {
      case 1:
        result = TIFFErrorExtR(a1, a3, "Incorrect count for \"%s\"", a4, a5, a6, a7, a8, a4);
        break;
      case 2:
        result = TIFFErrorExtR(a1, a3, "Incompatible type for \"%s\"", a4, a5, a6, a7, a8, a4);
        break;
      case 3:
        result = TIFFErrorExtR(a1, a3, "IO error during reading of \"%s\"", a4, a5, a6, a7, a8, a4);
        break;
      case 4:
        result = TIFFErrorExtR(a1, a3, "Incorrect value for \"%s\"", a4, a5, a6, a7, a8, a4);
        break;
      case 5:
        result = TIFFErrorExtR(a1, a3, "Cannot handle different values per sample for \"%s\"", a4, a5, a6, a7, a8, a4);
        break;
      case 6:
        result = TIFFErrorExtR(a1, a3, "Sanity check on size of \"%s\" value failed", a4, a5, a6, a7, a8, a4);
        break;
      case 7:
        result = TIFFErrorExtR(a1, a3, "Out of memory reading of \"%s\"", a4, a5, a6, a7, a8, a4);
        break;
      default:
        TIFFReadDirEntryOutputErr_cold_1();
    }
  }
  return result;
}

uint64_t _TIFFFillStriles(uint64_t a1)
{
  return _TIFFFillStrilesInternal(a1, 1);
}

uint64_t EvaluateIFDdatasizeReading(uint64_t a1, int8x8_t *a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint8x8_t v10;
  int8x8_t v11;
  BOOL v12;
  unint64_t v13;
  int v14;
  unint64_t v15;
  uint64_t v16;
  unsigned __int32 v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int8x8_t *v22;
  char v23;
  unsigned __int32 v24;

  v4 = TIFFDataWidth(a2->u16[1]);
  v11 = a2[1];
  if (v4)
    v12 = ((unint64_t)v4 * (unsigned __int128)(unint64_t)v11) >> 64 == 0;
  else
    v12 = 1;
  if (!v12)
    goto LABEL_11;
  v13 = *(_QWORD *)&v11 * v4;
  v14 = *(_DWORD *)(a1 + 16);
  v15 = 8;
  if ((v14 & 0x80000) == 0)
    v15 = 4;
  if (v13 > v15)
  {
    v16 = *(_QWORD *)(a1 + 440);
    if (__CFADD__(v13, v16))
    {
LABEL_11:
      TIFFErrorExtR(a1, "EvaluateIFDdatasizeReading", "Too large IFD data size", v5, v6, v7, v8, v9, v23);
      return 0;
    }
    *(_QWORD *)(a1 + 440) = v16 + v13;
    if ((v14 & 0x80000) != 0)
    {
      v20 = *(_QWORD *)(a1 + 456);
      v21 = *(unsigned int *)(a1 + 448);
      v22 = (int8x8_t *)(v20 + 16 * v21);
      *v22 = a2[2];
      if ((v14 & 0x80) != 0)
      {
        TIFFSwabLong8(v22);
        v20 = *(_QWORD *)(a1 + 456);
        v21 = *(unsigned int *)(a1 + 448);
      }
    }
    else
    {
      v18 = a2[2].u32[0];
      v24 = v18;
      if ((v14 & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&v24, v10);
        v18 = v24;
      }
      v19 = v18;
      v20 = *(_QWORD *)(a1 + 456);
      v21 = *(unsigned int *)(a1 + 448);
      *(_QWORD *)(v20 + 16 * v21) = v19;
    }
    *(_QWORD *)(v20 + 16 * v21 + 8) = v13;
    *(_DWORD *)(a1 + 448) = v21 + 1;
  }
  return 1;
}

uint64_t TIFFReadDirEntryDoubleArray(uint64_t a1, uint64_t a2, __int32 **a3)
{
  unsigned int v3;
  BOOL v4;
  int v5;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int32 *v17;
  uint64_t v18;
  double *v19;
  double v20;
  double *v21;
  double *v22;
  __int32 *v23;
  unsigned int v24;
  double *v25;
  __int32 *v26;
  unsigned int v27;
  double *v28;
  __int32 *v29;
  unsigned int v30;
  double *v31;
  __int32 *v32;
  unsigned int *v33;
  unsigned int v34;
  int8x8_t v35;
  double *v36;
  __int32 *v37;
  int v38;
  double *v39;
  __int32 *v40;
  int v41;
  double *v42;
  __int32 *v43;
  int v44;
  double *v45;
  __int32 *v46;
  unsigned int *v47;
  int v48;
  int8x8_t v49;
  double *v50;
  int8x8_t *v51;
  unint64_t v52;
  double *v53;
  int8x8_t *v54;
  uint64_t v55;
  double *v56;
  float *v57;
  float v58;
  int8x8_t *v59;
  unsigned int v60;

  v3 = *(unsigned __int16 *)(a2 + 2);
  v4 = v3 > 0x11;
  v5 = (1 << v3) & 0x31F7A;
  if (v4 || v5 == 0)
    return 2;
  v60 = 0;
  v59 = 0;
  result = TIFFReadDirEntryArrayWithLimit(a1, a2, &v60, 8u, (void **)&v59, 0xFFFFFFFFFFFFFFFFLL);
  if ((_DWORD)result || (v17 = (__int32 *)v59) == 0)
  {
    *a3 = 0;
  }
  else if (*(_WORD *)(a2 + 2) == 12)
  {
    if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      TIFFSwabArrayOfLong8(v59, v60);
    result = 0;
    *a3 = v17;
  }
  else
  {
    v18 = v60;
    v19 = (double *)_TIFFmallocExt((_QWORD *)a1, 8 * v60, v11, v12, v13, v14, v15, v16);
    if (v19)
    {
      v21 = v19;
      switch(*(_WORD *)(a2 + 2))
      {
        case 1:
          if ((_DWORD)v18)
          {
            v22 = v19;
            v23 = v17;
            do
            {
              v24 = *(unsigned __int8 *)v23;
              v23 = (__int32 *)((char *)v23 + 1);
              *v22++ = (double)v24;
              LODWORD(v18) = v18 - 1;
            }
            while ((_DWORD)v18);
          }
          break;
        case 3:
          if ((_DWORD)v18)
          {
            v25 = v19;
            v26 = v17;
            do
            {
              if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                TIFFSwabShort(v26);
              v27 = *(unsigned __int16 *)v26;
              v26 = (__int32 *)((char *)v26 + 2);
              *v25++ = (double)v27;
              LODWORD(v18) = v18 - 1;
            }
            while ((_DWORD)v18);
          }
          break;
        case 4:
          if ((_DWORD)v18)
          {
            v28 = v19;
            v29 = v17;
            do
            {
              if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                TIFFSwabLong(v29, *(uint8x8_t *)&v20);
              v30 = *v29++;
              v20 = (double)v30;
              *v28++ = (double)v30;
              LODWORD(v18) = v18 - 1;
            }
            while ((_DWORD)v18);
          }
          break;
        case 5:
          if ((_DWORD)v18)
          {
            v31 = v19;
            v32 = v17;
            do
            {
              if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
              {
                v35 = TIFFSwabLong(v32, *(uint8x8_t *)&v20);
                v33 = (unsigned int *)(v32 + 1);
                v34 = *v32;
                if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                  TIFFSwabLong(v32 + 1, (uint8x8_t)v35);
              }
              else
              {
                v33 = (unsigned int *)(v32 + 1);
                v34 = *v32;
              }
              if (*v33)
                v20 = (double)v34 / (double)*v33;
              else
                v20 = 0.0;
              v32 += 2;
              *v31++ = v20;
              LODWORD(v18) = v18 - 1;
            }
            while ((_DWORD)v18);
          }
          break;
        case 6:
          if ((_DWORD)v18)
          {
            v36 = v19;
            v37 = v17;
            do
            {
              v38 = *(char *)v37;
              v37 = (__int32 *)((char *)v37 + 1);
              *v36++ = (double)v38;
              LODWORD(v18) = v18 - 1;
            }
            while ((_DWORD)v18);
          }
          break;
        case 8:
          if ((_DWORD)v18)
          {
            v39 = v19;
            v40 = v17;
            do
            {
              if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                TIFFSwabShort(v40);
              v41 = *(__int16 *)v40;
              v40 = (__int32 *)((char *)v40 + 2);
              *v39++ = (double)v41;
              LODWORD(v18) = v18 - 1;
            }
            while ((_DWORD)v18);
          }
          break;
        case 9:
          if ((_DWORD)v18)
          {
            v42 = v19;
            v43 = v17;
            do
            {
              if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                TIFFSwabLong(v43, *(uint8x8_t *)&v20);
              v44 = *v43++;
              v20 = (double)v44;
              *v42++ = (double)v44;
              LODWORD(v18) = v18 - 1;
            }
            while ((_DWORD)v18);
          }
          break;
        case 0xA:
          if ((_DWORD)v18)
          {
            v45 = v19;
            v46 = v17;
            do
            {
              if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
              {
                v49 = TIFFSwabLong(v46, *(uint8x8_t *)&v20);
                v47 = (unsigned int *)(v46 + 1);
                v48 = *v46;
                if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                  TIFFSwabLong(v46 + 1, (uint8x8_t)v49);
              }
              else
              {
                v47 = (unsigned int *)(v46 + 1);
                v48 = *v46;
              }
              if (*v47)
                v20 = (double)v48 / (double)*v47;
              else
                v20 = 0.0;
              v46 += 2;
              *v45++ = v20;
              LODWORD(v18) = v18 - 1;
            }
            while ((_DWORD)v18);
          }
          break;
        case 0xB:
          if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
            TIFFSwabArrayOfLong(v17, v18, *(uint8x8_t *)&v20);
          if ((_DWORD)v18)
          {
            v56 = v21;
            v57 = (float *)v17;
            do
            {
              v58 = *v57++;
              *v56++ = v58;
              LODWORD(v18) = v18 - 1;
            }
            while ((_DWORD)v18);
          }
          break;
        case 0x10:
          if ((_DWORD)v18)
          {
            v50 = v19;
            v51 = (int8x8_t *)v17;
            do
            {
              if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                TIFFSwabLong8(v51);
              v52 = (unint64_t)*v51++;
              *v50++ = (double)v52;
              LODWORD(v18) = v18 - 1;
            }
            while ((_DWORD)v18);
          }
          break;
        case 0x11:
          if ((_DWORD)v18)
          {
            v53 = v19;
            v54 = (int8x8_t *)v17;
            do
            {
              if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                TIFFSwabLong8(v54);
              v55 = (uint64_t)*v54++;
              *v53++ = (double)v55;
              LODWORD(v18) = v18 - 1;
            }
            while ((_DWORD)v18);
          }
          break;
        default:
          break;
      }
      _TIFFfreeExt(a1, (char *)v17);
      result = 0;
      *a3 = (__int32 *)v21;
    }
    else
    {
      _TIFFfreeExt(a1, (char *)v17);
      return 7;
    }
  }
  return result;
}

void CalcFinalIFDdatasizeReading(uint64_t a1, unsigned int a2)
{
  int v4;
  unsigned int v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (*(_DWORD *)(a1 + 12))
  {
    qsort(*(void **)(a1 + 456), *(unsigned int *)(a1 + 448), 0x10uLL, (int (__cdecl *)(const void *, const void *))cmpTIFFEntryOffsetAndLength);
    v4 = *(_DWORD *)(a1 + 16);
    v5 = 20;
    if ((v4 & 0x80000) == 0)
      v5 = 12;
    v6 = 6;
    if ((v4 & 0x80000) != 0)
      v6 = 16;
    v7 = v6 + v5 * (unint64_t)a2 + *(_QWORD *)(a1 + 24);
    v8 = *(unsigned int *)(a1 + 448);
    if ((_DWORD)v8)
    {
      v9 = 0;
      v10 = (uint64_t *)(*(_QWORD *)(a1 + 456) + 8);
      do
      {
        v11 = *(v10 - 1);
        if (v11 == v7)
        {
          v12 = *v10;
          v13 = *v10;
        }
        else
        {
          if (v11 != v7 + 1)
            break;
          v12 = *v10;
          v13 = *v10 + 1;
        }
        v10 += 2;
        v9 += v13;
        v7 += v12;
        --v8;
      }
      while (v8);
    }
    else
    {
      v9 = 0;
    }
    v14 = *(_QWORD *)(a1 + 32);
    if (v14)
    {
      if (v14 == v7 + 1)
        ++v9;
    }
    else
    {
      if ((*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(a1 + 1224))(*(_QWORD *)(a1 + 1200), 0, 2) == v7)
      {
        v15 = -1;
LABEL_25:
        *(_QWORD *)(a1 + 440) = v15;
        return;
      }
      v4 = *(_DWORD *)(a1 + 16);
    }
    if ((v4 & 0x80000) != 0)
      v15 = v9 + 20 * a2 + 16;
    else
      v15 = v9 + 12 * a2 + 6;
    goto LABEL_25;
  }
}

uint64_t EstimateStripByteCounts(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  BOOL v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t *v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t i;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  unint64_t *v48;
  unint64_t v49;
  uint64_t v50;
  BOOL v51;
  unint64_t v52;
  int v53;

  if (!_TIFFFillStrilesInternal(a1, 0))
    return 0xFFFFFFFFLL;
  v10 = *(unsigned int *)(a1 + 228);
  if (v10 <= 0xC80000)
  {
    v13 = 0;
  }
  else
  {
    v11 = 8 * v10;
    v13 = (*(uint64_t (**)(_QWORD))(a1 + 1240))(*(_QWORD *)(a1 + 1200));
    if (v11 > v13)
    {
      TIFFWarningExtR(a1, "EstimateStripByteCounts", "Requested memory size for StripByteCounts of %llu is greater than filesize %llu. Memory not allocated", v12, v6, v7, v8, v9, v11);
      return 0xFFFFFFFFLL;
    }
  }
  v14 = *(char **)(a1 + 240);
  if (v14)
    _TIFFfreeExt(a1, v14);
  v15 = _TIFFCheckMalloc((const char **)a1, *(unsigned int *)(a1 + 228), 8, (uint64_t)"for \"StripByteCounts\" array", v6, v7, v8, v9);
  *(_QWORD *)(a1 + 240) = v15;
  if (!v15)
    return 0xFFFFFFFFLL;
  v23 = *(_DWORD *)(a1 + 16);
  if (*(_WORD *)(a1 + 120) == 1)
  {
    if ((v23 & 0x400) != 0)
    {
      v46 = _cg_TIFFTileSize64(a1, v16, v17, v18, v19, v20, v21, v22);
      v47 = *(unsigned int *)(a1 + 228);
      if ((_DWORD)v47)
      {
        v48 = *(unint64_t **)(a1 + 240);
        do
        {
          *v48++ = v46;
          --v47;
        }
        while (v47);
      }
    }
    else
    {
      v24 = _cg_TIFFScanlineSize64(a1, v16, v17, v18, v19, v20, v21, v22);
      v25 = *(unsigned int *)(a1 + 228);
      if ((_DWORD)v25)
      {
        v26 = 0;
        v27 = !is_mul_ok(v24, (*(_DWORD *)(a1 + 92) / *(_DWORD *)(a1 + 224)));
        v28 = v24 * (*(_DWORD *)(a1 + 92) / *(_DWORD *)(a1 + 224));
        v29 = 8 * v25;
        while (!v27)
        {
          *(_QWORD *)(*(_QWORD *)(a1 + 240) + v26) = v28;
          v26 += 8;
          if (v29 == v26)
            goto LABEL_53;
        }
        return 0xFFFFFFFFLL;
      }
    }
  }
  else
  {
    if ((v23 & 0x80000) != 0)
      v30 = 20 * a3 + 32;
    else
      v30 = 12 * a3 + 14;
    if (a3)
    {
      v31 = (unint64_t *)(a2 + 8);
      while (1)
      {
        v32 = TIFFDataWidth(*((unsigned __int16 *)v31 - 3));
        if (!v32)
          break;
        if (!is_mul_ok(v32, *v31))
          return 0xFFFFFFFFLL;
        v38 = *v31 * v32;
        if (v38 >= 9)
          v39 = *v31 * v32;
        else
          v39 = 0;
        if (v38 < 5)
          v38 = 0;
        if ((*(_BYTE *)(a1 + 18) & 8) != 0)
          v38 = v39;
        if (__CFADD__(v38, v30))
          return 0xFFFFFFFFLL;
        v30 += v38;
        --a3;
        v31 += 4;
        if (!(_WORD)a3)
          goto LABEL_32;
      }
      TIFFErrorExtR(a1, "EstimateStripByteCounts", "Cannot determine size of unknown tag type %hu", v33, v34, v35, v36, v37, *((_WORD *)v31 - 3));
      return 0xFFFFFFFFLL;
    }
LABEL_32:
    if (!v13)
      v13 = (*(uint64_t (**)(_QWORD))(a1 + 1240))(*(_QWORD *)(a1 + 1200));
    if (v13 >= v30)
      v40 = v30;
    else
      v40 = 0;
    v41 = v13 - v40;
    if (*(_WORD *)(a1 + 170) == 2)
      v41 /= *(unsigned __int16 *)(a1 + 130);
    v42 = *(unsigned int *)(a1 + 228);
    v43 = *(_QWORD *)(a1 + 240);
    if ((_DWORD)v42)
    {
      for (i = 0; i != v42; ++i)
        *(_QWORD *)(v43 + 8 * i) = v41;
      v45 = i - 1;
    }
    else
    {
      v45 = 0xFFFFFFFFLL;
    }
    v49 = *(_QWORD *)(*(_QWORD *)(a1 + 232) + 8 * v45);
    v50 = *(_QWORD *)(v43 + 8 * v45);
    if (__CFADD__(v50, v49))
      return 0xFFFFFFFFLL;
    if (v50 + v49 > v13)
    {
      v51 = v13 >= v49;
      v52 = v13 - v49;
      if (!v51)
        v52 = 0;
      *(_QWORD *)(v43 + 8 * v45) = v52;
    }
  }
LABEL_53:
  v53 = *(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 72) = v53 | 0x1000000;
  if ((v53 & 0x20000) == 0)
    *(_DWORD *)(a1 + 132) = *(_DWORD *)(a1 + 92);
  return 1;
}

void TryChopUpUncompressedBigTiff(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  unsigned int v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  BOOL v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  int v41;
  unint64_t v42;

  v9 = _cg_TIFFStripSize64(a1, a2, a3, a4, a5, a6, a7, a8);
  if (*(_WORD *)(a1 + 170) != 1)
    TryChopUpUncompressedBigTiff_cold_5();
  if (*(_WORD *)(a1 + 120) != 1)
    TryChopUpUncompressedBigTiff_cold_4();
  if ((*(_DWORD *)(a1 + 16) & 0x8400) != 0x8000)
    TryChopUpUncompressedBigTiff_cold_3();
  v10 = v9;
  if (!(v9 >> 31))
    TryChopUpUncompressedBigTiff_cold_1();
  if (_TIFFGetStrileOffsetOrByteCountValue(a1, 0) || !*(_DWORD *)(a1 + 12))
  {
    v17 = *(_WORD *)(a1 + 122) != 6 || (*(_BYTE *)(a1 + 17) & 0x40) != 0 ? 1 : *(unsigned __int16 *)(a1 + 338);
    v41 = v17;
    v42 = TIFFVStripSize64(a1, v17, v11, v12, v13, v14, v15, v16);
    if (v42 - 0x80000000 >= 0xFFFFFFFF80000001)
    {
      v18 = *(_DWORD *)(a1 + 228);
      if (v18)
      {
        v19 = 0;
        do
        {
          v20 = v18 - 1;
          v21 = _TIFFGetStrileOffsetOrByteCountValue(a1, v19);
          if ((_DWORD)v19 == v20)
          {
            if (v21 < TIFFVStripSize64(a1, (*(_DWORD *)(a1 + 92) - *(_DWORD *)(a1 + 132) * v19), v22, v23, v24, v25, v26, v27))return;
          }
          else
          {
            if (v21 != v10)
              return;
            if ((_DWORD)v19)
            {
              v28 = _TIFFGetStrileOffsetOrByteCountValue(a1, v19);
              v29 = _TIFFGetStrileOffsetOrByteCountValue(a1, (v19 - 1));
              if (v28 != _TIFFGetStrileOffsetOrByteCountValue(a1, (v19 - 1)) + v29)
                return;
            }
          }
          v19 = (v19 + 1);
          v18 = *(_DWORD *)(a1 + 228);
        }
        while (v19 < v18);
        v30 = v18 - 1;
      }
      else
      {
        v30 = 0xFFFFFFFFLL;
      }
      v31 = 0x20000000 / v42;
      if ((0x20000000 / v42) <= 1)
        v31 = 1;
      else
        v31 = v31;
      v32 = v42 * v31;
      if ((v42 * v31) >> 31)
        TryChopUpUncompressedBigTiff_cold_2();
      v33 = (v31 * v41);
      if ((_DWORD)v33)
      {
        v34 = *(_DWORD *)(a1 + 92);
        if (v34 < -(int)v33)
        {
          v35 = v33 + v34 - 1;
          if (v33 <= v35)
          {
            v36 = v35 / v33;
            v37 = v35 / v33 >= 0xF4241 && *(_DWORD *)(a1 + 12) == 0;
            if (!v37
              || (v38 = _TIFFGetStrileOffsetOrByteCountValue(a1, v30),
                  v39 = (*(uint64_t (**)(_QWORD))(a1 + 1240))(*(_QWORD *)(a1 + 1200)),
                  v40 = _TIFFGetStrileOffsetOrByteCountValue(a1, (*(_DWORD *)(a1 + 228) - 1)),
                  v39 >= v38)
              && v40 <= v39 - v38)
            {
              allocChoppedUpStripArrays(a1, v36, v32, v33);
            }
          }
        }
      }
    }
  }
}

BOOL equalFuncOffsetToNumber(_QWORD *a1, _QWORD *a2)
{
  return *a1 == *a2;
}

BOOL equalFuncNumberToOffset(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8);
}

uint64_t _TIFFGetOffsetFromDirNumber(uint64_t a1, unsigned int a2, _QWORD *a3)
{
  uint64_t result;
  _QWORD v5[2];

  result = *(_QWORD *)(a1 + 56);
  if (result)
  {
    v5[0] = 0;
    v5[1] = a2;
    result = (uint64_t)TIFFHashSetLookup(result, (uint64_t)v5);
    if (result)
    {
      *a3 = *(_QWORD *)result;
      return 1;
    }
  }
  return result;
}

uint64_t _TIFFRemoveEntryFromDirectoryListByOffset(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v14;
  uint64_t v15;

  v3 = *(_QWORD *)(a1 + 48);
  if (v3)
  {
    v14 = a2;
    v15 = 0;
    v4 = TIFFHashSetLookup(v3, (uint64_t)&v14);
    if (v4)
    {
      v10 = (uint64_t)v4;
      LODWORD(v15) = *((_DWORD *)v4 + 2);
      v11 = *(_QWORD *)(a1 + 56);
      if (!v11)
      {
        TIFFErrorExtR(a1, "_TIFFRemoveEntryFromDirectoryListByOffset", "Unexpectedly tif_map_dir_number_to_offset is missing but tif_map_dir_offset_to_number exists.", v5, v6, v7, v8, v9, v14);
        return 0;
      }
      v12 = TIFFHashSetLookup(v11, (uint64_t)&v14);
      if (v12)
      {
        TIFFHashSetRemove(*(_QWORD *)(a1 + 56), (uint64_t)v12);
        TIFFHashSetRemove(*(_QWORD *)(a1 + 48), v10);
      }
    }
  }
  return 1;
}

uint64_t TIFFGetStrileOffsetWithErr(uint64_t a1, uint64_t a2)
{
  return _TIFFGetStrileOffsetOrByteCountValue(a1, a2);
}

uint64_t TIFFGetStrileByteCountWithErr(uint64_t a1, uint64_t a2)
{
  return _TIFFGetStrileOffsetOrByteCountValue(a1, a2);
}

uint64_t _TIFFFillStrilesInternal(uint64_t a1, int a2)
{
  int v2;
  char *v5;
  uint64_t v6;
  uint64_t v7;

  v2 = *(_DWORD *)(a1 + 16);
  if ((v2 & 0x5000000) != 0x1000000)
    return 1;
  v6 = a1 + 232;
  v5 = *(char **)(a1 + 232);
  if ((v2 & 0x2000000) != 0)
  {
    _TIFFfreeExt(a1, v5);
    _TIFFfreeExt(a1, *(char **)(a1 + 240));
    *(_QWORD *)v6 = 0;
    *(_QWORD *)(v6 + 8) = 0;
    *(_DWORD *)(v6 + 16) = 0;
    *(_DWORD *)(a1 + 16) &= ~0x2000000u;
  }
  else if (v5)
  {
    return 1;
  }
  if (!*(_QWORD *)(a1 + 264))
    return 0;
  v7 = TIFFFetchStripThing(a1, (unsigned __int16 *)(a1 + 256), *(_DWORD *)(a1 + 228), (_QWORD *)v6);
  if (a2)
  {
    if (TIFFFetchStripThing(a1, (unsigned __int16 *)(a1 + 288), *(_DWORD *)(a1 + 228), (_QWORD *)(a1 + 240)))v7 = v7;
    else
      v7 = 0;
  }
  _TIFFmemset((void *)(a1 + 256), 0, 0x20uLL);
  _TIFFmemset((void *)(a1 + 288), 0, 0x20uLL);
  return v7;
}

uint64_t TIFFReadDirEntryCheckedLong8(uint64_t a1, int8x8_t *a2, int8x8_t *__dst, uint8x8_t a4)
{
  int v5;
  unsigned __int32 v7;
  uint64_t result;
  unsigned __int32 v9;

  v5 = *(_DWORD *)(a1 + 16);
  if ((v5 & 0x80000) != 0)
  {
    *__dst = a2[2];
    if ((v5 & 0x80) == 0)
      return 0;
LABEL_8:
    TIFFSwabLong8(__dst);
    return 0;
  }
  v7 = a2[2].u32[0];
  v9 = v7;
  if ((v5 & 0x80) != 0)
  {
    TIFFSwabLong((__int32 *)&v9, a4);
    v7 = v9;
  }
  result = TIFFReadDirEntryData(a1, v7, 8, __dst);
  if (!(_DWORD)result)
  {
    if ((*(_DWORD *)(a1 + 16) & 0x80) == 0)
      return 0;
    goto LABEL_8;
  }
  return result;
}

uint64_t TIFFReadDirEntryData(uint64_t a1, uint64_t a2, int64_t __n, void *__dst)
{
  if (__n <= 0)
    TIFFReadDirEntryData_cold_1();
  if ((*(_BYTE *)(a1 + 17) & 8) == 0)
  {
    if (_TIFFSeekOK(a1, a2)
      && (*(uint64_t (**)(_QWORD, void *, int64_t))(a1 + 1208))(*(_QWORD *)(a1 + 1200), __dst, __n) == __n)
    {
      return 0;
    }
    return 3;
  }
  if (__CFADD__(__n, a2) || (unint64_t)(__n + a2) > *(_QWORD *)(a1 + 1176))
    return 3;
  _TIFFmemcpy(__dst, (const void *)(*(_QWORD *)(a1 + 1168) + a2), __n);
  return 0;
}

uint64_t cmpTIFFEntryOffsetAndLength(_QWORD *a1, _QWORD *a2)
{
  unsigned int v2;

  if (*a1 >= *a2)
    v2 = 0;
  else
    v2 = -1;
  if (*a1 > *a2)
    return 1;
  else
    return v2;
}

uint64_t TIFFReadDirEntryByteArray(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  unsigned int v3;
  BOOL v4;
  int v5;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  int v18;
  uint64_t v19;
  int v20;
  unsigned int v22;
  char *v23;
  int8x8_t v24;
  char *v25;
  char *v26;
  char *v27;
  unsigned int v28;
  char *v29;
  __int32 *v30;
  __int32 v31;
  char *v32;
  char *v33;
  unsigned int v34;
  char *v35;
  __int32 *v36;
  __int32 v37;
  char *v38;
  int8x8_t *v39;
  int8x8_t v40;
  char *v41;
  int8x8_t *v42;
  int8x8_t v43;
  void *v44;
  unsigned int v45;

  v3 = *(unsigned __int16 *)(a2 + 2);
  v4 = v3 > 0x11;
  v5 = (1 << v3) & 0x303DE;
  if (v4 || v5 == 0)
    return 2;
  v45 = 0;
  v44 = 0;
  v16 = TIFFReadDirEntryArrayWithLimit(a1, a2, &v45, 1u, &v44, 0xFFFFFFFFFFFFFFFFLL);
  if ((_DWORD)v16 || (v17 = (char *)v44) == 0)
  {
    *a3 = 0;
    return v16;
  }
  v18 = *(unsigned __int16 *)(a2 + 2);
  if ((v18 - 1) < 2 || v18 == 7)
    goto LABEL_14;
  if (v18 == 6)
  {
    if (v45)
    {
      v19 = 0;
      while (1)
      {
        v20 = *((unsigned __int8 *)v44 + v19) >> 5;
        if ((v20 & 4) != 0)
          break;
        if (v45 == (_DWORD)++v19)
          goto LABEL_14;
      }
      v16 = v20 & 4;
      _TIFFfreeExt(a1, (char *)v44);
      return v16;
    }
LABEL_14:
    v16 = 0;
    *a3 = v44;
    return v16;
  }
  v22 = v45;
  v23 = (char *)_TIFFmallocExt((_QWORD *)a1, v45, v10, v11, v12, v13, v14, v15);
  if (v23)
  {
    v25 = v23;
    switch(*(_WORD *)(a2 + 2))
    {
      case 3:
        if (!v22)
          goto LABEL_63;
        v26 = v23;
        v27 = v17;
        while (1)
        {
          if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
            TIFFSwabShort(v27);
          v28 = *(unsigned __int16 *)v27;
          if (v28 > 0xFF)
            goto LABEL_64;
          v27 += 2;
          *v26++ = v28;
          if (!--v22)
            goto LABEL_63;
        }
      case 4:
        if (!v22)
          goto LABEL_63;
        v29 = v23;
        v30 = (__int32 *)v17;
        while (1)
        {
          if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
            v24 = TIFFSwabLong(v30, (uint8x8_t)v24);
          v31 = *v30;
          if (*v30 > 0xFF)
            goto LABEL_64;
          ++v30;
          *v29++ = v31;
          if (!--v22)
            goto LABEL_63;
        }
      case 8:
        if (!v22)
          goto LABEL_63;
        v32 = v23;
        v33 = v17;
        while (1)
        {
          if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
            TIFFSwabShort(v33);
          v34 = *(unsigned __int16 *)v33;
          if (v34 > 0xFF)
            goto LABEL_64;
          v33 += 2;
          *v32++ = v34;
          if (!--v22)
            goto LABEL_63;
        }
      case 9:
        if (!v22)
          goto LABEL_63;
        v35 = v23;
        v36 = (__int32 *)v17;
        while (1)
        {
          if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
            v24 = TIFFSwabLong(v36, (uint8x8_t)v24);
          v37 = *v36;
          if (*v36 > 0xFF)
            goto LABEL_64;
          ++v36;
          *v35++ = v37;
          if (!--v22)
            goto LABEL_63;
        }
      case 0x10:
        if (!v22)
          goto LABEL_63;
        v38 = v23;
        v39 = (int8x8_t *)v17;
        while (1)
        {
          if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
            TIFFSwabLong8(v39);
          v40 = *v39;
          if (*(_QWORD *)v39 > 0xFFuLL)
            goto LABEL_64;
          ++v39;
          *v38++ = v40.i8[0];
          if (!--v22)
            goto LABEL_63;
        }
      case 0x11:
        if (!v22)
          goto LABEL_63;
        v41 = v23;
        v42 = (int8x8_t *)v17;
        break;
      default:
        goto LABEL_63;
    }
    while (1)
    {
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
        TIFFSwabLong8(v42);
      v43 = *v42;
      if (*(_QWORD *)v42 > 0xFFuLL)
        break;
      ++v42;
      *v41++ = v43.i8[0];
      if (!--v22)
      {
LABEL_63:
        _TIFFfreeExt(a1, v17);
        v16 = 0;
        *a3 = v25;
        return v16;
      }
    }
LABEL_64:
    _TIFFfreeExt(a1, v17);
    _TIFFfreeExt(a1, v25);
    return 4;
  }
  else
  {
    _TIFFfreeExt(a1, v17);
    return 7;
  }
}

uint64_t TIFFReadDirEntryByte(uint64_t a1, int8x8_t *a2, _BYTE *a3, uint8x8_t a4)
{
  uint64_t result;
  unsigned int v7;
  unsigned int v8;
  int8x8_t __dst;

  if (*(_QWORD *)&a2[1] != 1)
    return 1;
  result = 2;
  switch(a2->i16[1])
  {
    case 1:
    case 7:
      result = 0;
      LOBYTE(v7) = a2[2].i8[0];
      goto LABEL_4;
    case 3:
    case 8:
      v8 = a2[2].u16[0];
      __dst.i16[0] = a2[2].i16[0];
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dst);
        v8 = __dst.u16[0];
      }
      goto LABEL_11;
    case 4:
    case 9:
      v8 = a2[2].u32[0];
      __dst.i32[0] = v8;
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dst, a4);
        v8 = __dst.i32[0];
      }
LABEL_11:
      if (v8 > 0xFF)
        goto LABEL_20;
      result = 0;
      *a3 = v8;
      break;
    case 6:
      v7 = a2[2].u8[0];
      if (((v7 >> 5) & 4) != 0)
        return (v7 >> 5) & 4;
      result = 0;
LABEL_4:
      *a3 = v7;
      return result;
    case 0x10:
      __dst = 0;
      result = TIFFReadDirEntryCheckedLong8(a1, a2, &__dst, a4);
      if (!(_DWORD)result)
        goto LABEL_18;
      return result;
    case 0x11:
      __dst = 0;
      result = TIFFReadDirEntryCheckedLong8(a1, a2, &__dst, a4);
      if (!(_DWORD)result)
      {
LABEL_18:
        if (*(_QWORD *)&__dst > 0xFFuLL)
        {
LABEL_20:
          result = 4;
        }
        else
        {
          result = 0;
          *a3 = __dst.i8[0];
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t TIFFReadDirEntrySbyte(uint64_t a1, int8x8_t *a2, __int8 *a3, uint8x8_t a4)
{
  uint64_t result;
  unsigned int v7;
  unsigned int v8;
  __int8 v9;
  int8x8_t __dst;

  if (*(_QWORD *)&a2[1] != 1)
    return 1;
  result = 2;
  switch(a2->i16[1])
  {
    case 1:
    case 7:
      v7 = a2[2].u8[0];
      if (((v7 >> 5) & 4) == 0)
      {
        result = 0;
        goto LABEL_14;
      }
      return (v7 >> 5) & 4;
    case 3:
      v8 = a2[2].u16[0];
      __dst.i16[0] = a2[2].i16[0];
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dst);
        v8 = __dst.u16[0];
      }
      goto LABEL_11;
    case 4:
      v8 = a2[2].u32[0];
      __dst.i32[0] = v8;
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dst, a4);
        v8 = __dst.i32[0];
      }
LABEL_11:
      if (v8 > 0x7F)
        goto LABEL_25;
      goto LABEL_22;
    case 6:
      result = 0;
      LOBYTE(v7) = a2[2].i8[0];
LABEL_14:
      *a3 = v7;
      return result;
    case 8:
      v8 = a2[2].u16[0];
      __dst.i16[0] = a2[2].i16[0];
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dst);
        v8 = __dst.u16[0];
      }
      if (v8 != (unsigned __int16)(char)v8)
        goto LABEL_25;
      goto LABEL_22;
    case 9:
      v8 = a2[2].u32[0];
      __dst.i32[0] = v8;
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dst, a4);
        v8 = __dst.i32[0];
      }
      if (v8 != (char)v8)
        goto LABEL_25;
LABEL_22:
      result = 0;
      *a3 = v8;
      return result;
    case 0x10:
      __dst = 0;
      result = TIFFReadDirEntryCheckedLong8(a1, a2, &__dst, a4);
      if ((_DWORD)result)
        return result;
      v9 = __dst.i8[0];
      if (*(_QWORD *)&__dst > 0x7FuLL)
        goto LABEL_25;
      goto LABEL_28;
    case 0x11:
      __dst = 0;
      result = TIFFReadDirEntryCheckedLong8(a1, a2, &__dst, a4);
      if ((_DWORD)result)
        return result;
      v9 = __dst.i8[0];
      if (*(_QWORD *)&__dst == __dst.i8[0])
      {
LABEL_28:
        result = 0;
        *a3 = v9;
      }
      else
      {
LABEL_25:
        result = 4;
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t TIFFReadDirEntrySshort(uint64_t a1, int8x8_t *a2, _BYTE *a3, uint8x8_t a4)
{
  uint64_t result;
  __int16 v7;
  unsigned __int32 v8;
  __int16 v9;
  int8x8_t __dst;

  if (*(_QWORD *)&a2[1] != 1)
    return 1;
  result = 2;
  switch(a2->i16[1])
  {
    case 1:
      result = 0;
      v7 = a2[2].u8[0];
      goto LABEL_15;
    case 3:
      v8 = a2[2].u16[0];
      __dst.i16[0] = a2[2].i16[0];
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dst);
        v8 = __dst.u16[0];
      }
      result = (v8 >> 13) & 4;
      if (((v8 >> 13) & 4) == 0)
        goto LABEL_23;
      return result;
    case 4:
      v8 = a2[2].u32[0];
      __dst.i32[0] = v8;
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dst, a4);
        v8 = __dst.i32[0];
      }
      if (v8 >> 15)
        goto LABEL_29;
      goto LABEL_22;
    case 6:
      result = 0;
      v7 = a2[2].i8[0];
LABEL_15:
      *(_WORD *)a3 = v7;
      return result;
    case 8:
      *(_WORD *)a3 = a2[2].i16[0];
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
        TIFFSwabShort(a3);
      return 0;
    case 9:
      v8 = a2[2].u32[0];
      __dst.i32[0] = v8;
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dst, a4);
        v8 = __dst.i32[0];
      }
      if (v8 != (__int16)v8)
        goto LABEL_29;
LABEL_22:
      result = 0;
LABEL_23:
      *(_WORD *)a3 = v8;
      return result;
    case 0x10:
      __dst = 0;
      result = TIFFReadDirEntryCheckedLong8(a1, a2, &__dst, a4);
      if ((_DWORD)result)
        return result;
      v9 = __dst.i16[0];
      if (!(*(_QWORD *)&__dst >> 15))
        goto LABEL_26;
      goto LABEL_29;
    case 0x11:
      __dst = 0;
      result = TIFFReadDirEntryCheckedLong8(a1, a2, &__dst, a4);
      if ((_DWORD)result)
        return result;
      v9 = __dst.i16[0];
      if (*(_QWORD *)&__dst == __dst.i16[0])
      {
LABEL_26:
        result = 0;
        *(_WORD *)a3 = v9;
      }
      else
      {
LABEL_29:
        result = 4;
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t TIFFReadDirEntrySlong(uint64_t a1, int8x8_t *a2, __int32 *a3, uint8x8_t a4)
{
  uint64_t result;
  __int32 v7;
  unsigned __int32 v8;
  __int16 v9;
  __int32 v10;
  int8x8_t __dst;

  if (*(_QWORD *)&a2[1] != 1)
    return 1;
  result = 2;
  switch(a2->i16[1])
  {
    case 1:
      result = 0;
      v7 = a2[2].u8[0];
      goto LABEL_16;
    case 3:
      v8 = a2[2].u16[0];
      __dst.i16[0] = a2[2].i16[0];
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dst);
        v8 = __dst.u16[0];
      }
      result = 0;
      goto LABEL_11;
    case 4:
      v8 = a2[2].u32[0];
      __dst.i32[0] = v8;
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dst, a4);
        v8 = __dst.i32[0];
      }
      result = (v8 >> 29) & 4;
      if (((v8 >> 29) & 4) == 0)
LABEL_11:
        *a3 = v8;
      return result;
    case 6:
      result = 0;
      v7 = a2[2].i8[0];
      goto LABEL_16;
    case 8:
      v9 = a2[2].i16[0];
      __dst.i16[0] = v9;
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dst);
        v9 = __dst.i16[0];
      }
      result = 0;
      v7 = v9;
LABEL_16:
      *a3 = v7;
      return result;
    case 9:
      *a3 = a2[2].i32[0];
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
        TIFFSwabLong(a3, a4);
      return 0;
    case 0x10:
      __dst = 0;
      result = TIFFReadDirEntryCheckedLong8(a1, a2, &__dst, a4);
      if ((_DWORD)result)
        return result;
      v10 = __dst.i32[0];
      if (!(*(_QWORD *)&__dst >> 31))
        goto LABEL_22;
      goto LABEL_25;
    case 0x11:
      __dst = 0;
      result = TIFFReadDirEntryCheckedLong8(a1, a2, &__dst, a4);
      if ((_DWORD)result)
        return result;
      v10 = __dst.i32[0];
      if (*(_QWORD *)&__dst == __dst.i32[0])
      {
LABEL_22:
        result = 0;
        *a3 = v10;
      }
      else
      {
LABEL_25:
        result = 4;
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t TIFFReadDirEntryLong8(uint64_t a1, int8x8_t *a2, int8x8_t *__dst, uint8x8_t a4)
{
  uint64_t result;
  int8x8_t v7;
  unsigned __int32 v8;
  unsigned int v9;
  unsigned __int32 v10;
  int8x8_t __dsta;

  if (*(_QWORD *)&a2[1] != 1)
    return 1;
  result = 2;
  switch(a2->i16[1])
  {
    case 1:
      result = 0;
      v7 = (int8x8_t)a2[2].u8[0];
      goto LABEL_10;
    case 3:
      v8 = a2[2].u16[0];
      __dsta.i16[0] = a2[2].i16[0];
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dsta);
        v8 = __dsta.u16[0];
      }
      goto LABEL_9;
    case 4:
      v8 = a2[2].u32[0];
      __dsta.i32[0] = v8;
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dsta, a4);
        v8 = __dsta.i32[0];
      }
LABEL_9:
      result = 0;
      v7 = (int8x8_t)v8;
      goto LABEL_10;
    case 6:
      v7.i32[0] = a2[2].u8[0];
      if ((((unsigned __int32)v7.i32[0] >> 5) & 4) != 0)
        return ((unsigned __int32)v7.i32[0] >> 5) & 4;
      result = 0;
      v7 = (int8x8_t)v7.i8[0];
      goto LABEL_10;
    case 8:
      v9 = a2[2].u16[0];
      __dsta.i16[0] = a2[2].i16[0];
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dsta);
        v9 = __dsta.u16[0];
      }
      result = (v9 >> 13) & 4;
      if (((v9 >> 13) & 4) != 0)
        return result;
      v7 = (int8x8_t)(__int16)v9;
      goto LABEL_10;
    case 9:
      v10 = a2[2].u32[0];
      __dsta.i32[0] = v10;
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dsta, a4);
        v10 = __dsta.i32[0];
      }
      result = (v10 >> 29) & 4;
      if (((v10 >> 29) & 4) != 0)
        return result;
      v7 = (int8x8_t)(int)v10;
      goto LABEL_10;
    case 0x10:
      return TIFFReadDirEntryCheckedLong8(a1, a2, __dst, a4);
    case 0x11:
      __dsta = 0;
      result = TIFFReadDirEntryCheckedLong8(a1, a2, &__dsta, a4);
      if ((_DWORD)result)
        return result;
      v7 = __dsta;
      if (((*(_QWORD *)&__dsta >> 61) & 4) != 0)
      {
        result = (*(_QWORD *)&__dsta >> 61) & 4;
      }
      else
      {
        result = 0;
LABEL_10:
        *__dst = v7;
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t TIFFReadDirEntrySlong8(uint64_t a1, int8x8_t *a2, int8x8_t *__dst, uint8x8_t a4)
{
  uint64_t result;
  int8x8_t v7;
  unsigned __int32 v8;
  __int16 v9;
  __int32 v10;
  int8x8_t __dsta;

  if (*(_QWORD *)&a2[1] != 1)
    return 1;
  result = 2;
  switch(a2->i16[1])
  {
    case 1:
      result = 0;
      v7 = (int8x8_t)a2[2].u8[0];
      goto LABEL_17;
    case 3:
      v8 = a2[2].u16[0];
      __dsta.i16[0] = a2[2].i16[0];
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dsta);
        v8 = __dsta.u16[0];
      }
      goto LABEL_9;
    case 4:
      v8 = a2[2].u32[0];
      __dsta.i32[0] = v8;
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dsta, a4);
        v8 = __dsta.i32[0];
      }
LABEL_9:
      result = 0;
      v7 = (int8x8_t)v8;
      goto LABEL_17;
    case 6:
      result = 0;
      v7 = (int8x8_t)a2[2].i8[0];
      goto LABEL_17;
    case 8:
      v9 = a2[2].i16[0];
      __dsta.i16[0] = v9;
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dsta);
        v9 = __dsta.i16[0];
      }
      result = 0;
      v7 = (int8x8_t)v9;
      goto LABEL_17;
    case 9:
      v10 = a2[2].i32[0];
      __dsta.i32[0] = v10;
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dsta, a4);
        v10 = __dsta.i32[0];
      }
      result = 0;
      v7 = (int8x8_t)v10;
      goto LABEL_17;
    case 0x10:
      __dsta = 0;
      result = TIFFReadDirEntryCheckedLong8(a1, a2, &__dsta, a4);
      if ((_DWORD)result)
        return result;
      v7 = __dsta;
      if (((*(_QWORD *)&__dsta >> 61) & 4) != 0)
      {
        result = (*(_QWORD *)&__dsta >> 61) & 4;
      }
      else
      {
        result = 0;
LABEL_17:
        *__dst = v7;
      }
      break;
    case 0x11:
      return TIFFReadDirEntryCheckedLong8(a1, a2, __dst, a4);
    default:
      return result;
  }
  return result;
}

uint64_t TIFFReadDirEntryFloat(uint64_t a1, int8x8_t *a2, __int32 *a3, double a4)
{
  uint64_t result;
  unsigned int v7;
  int v8;
  __int16 v9;
  int v10;
  uint64_t __dst;

  if (*(_QWORD *)&a2[1] != 1)
    return 1;
  result = 2;
  switch(a2->i16[1])
  {
    case 1:
      result = 0;
      LOBYTE(a4) = a2[2].i8[0];
      *(float *)&a4 = (float)LODWORD(a4);
      break;
    case 3:
      v7 = a2[2].u16[0];
      LOWORD(__dst) = a2[2].i16[0];
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dst);
        v7 = (unsigned __int16)__dst;
      }
      goto LABEL_9;
    case 4:
      v7 = a2[2].u32[0];
      LODWORD(__dst) = v7;
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dst, *(uint8x8_t *)&a4);
        v7 = __dst;
      }
LABEL_9:
      result = 0;
      *(float *)&a4 = (float)v7;
      break;
    case 5:
      *(double *)&__dst = 0.0;
      result = TIFFReadDirEntryCheckedRational(a1, (uint64_t)a2, (double *)&__dst, *(uint8x8_t *)&a4);
      if (!(_DWORD)result)
        goto LABEL_21;
      return result;
    case 6:
      result = 0;
      v8 = a2[2].i8[0];
      goto LABEL_16;
    case 8:
      v9 = a2[2].i16[0];
      LOWORD(__dst) = v9;
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dst);
        v9 = __dst;
      }
      result = 0;
      v8 = v9;
LABEL_16:
      *(float *)&a4 = (float)v8;
      break;
    case 9:
      v10 = a2[2].i32[0];
      LODWORD(__dst) = v10;
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dst, *(uint8x8_t *)&a4);
        v10 = __dst;
      }
      result = 0;
      *(float *)&a4 = (float)v10;
      break;
    case 0xA:
      *(double *)&__dst = 0.0;
      result = TIFFReadDirEntryCheckedSrational(a1, (uint64_t)a2, (double *)&__dst, *(uint8x8_t *)&a4);
      if ((_DWORD)result)
        return result;
LABEL_21:
      a4 = *(double *)&__dst;
      goto LABEL_29;
    case 0xB:
      LODWORD(a4) = a2[2].i32[0];
      *a3 = LODWORD(a4);
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
        TIFFSwabLong(a3, *(uint8x8_t *)&a4);
      return 0;
    case 0xC:
      *(double *)&__dst = 0.0;
      result = TIFFReadDirEntryCheckedDouble(a1, a2, (int8x8_t *)&__dst, *(uint8x8_t *)&a4);
      if ((_DWORD)result)
        return result;
      a4 = *(double *)&__dst;
      result = 4;
      if (*(double *)&__dst > 3.40282347e38 || *(double *)&__dst < -3.40282347e38)
        return result;
      result = 0;
LABEL_29:
      *(float *)&a4 = a4;
      break;
    case 0x10:
      *(double *)&__dst = 0.0;
      result = TIFFReadDirEntryCheckedLong8(a1, a2, (int8x8_t *)&__dst, *(uint8x8_t *)&a4);
      if ((_DWORD)result)
        return result;
      *(float *)&a4 = (float)(unint64_t)__dst;
      break;
    case 0x11:
      *(double *)&__dst = 0.0;
      result = TIFFReadDirEntryCheckedLong8(a1, a2, (int8x8_t *)&__dst, *(uint8x8_t *)&a4);
      if ((_DWORD)result)
        return result;
      *(float *)&a4 = (float)__dst;
      break;
    default:
      return result;
  }
  *a3 = LODWORD(a4);
  return result;
}

uint64_t TIFFReadDirEntryDouble(uint64_t a1, int8x8_t *a2, double *__dst, double a4)
{
  uint64_t result;
  unsigned int v7;
  double v8;
  int v9;
  __int16 v10;
  int v11;
  double __dsta;

  if (*(_QWORD *)&a2[1] != 1)
    return 1;
  result = 2;
  switch(a2->i16[1])
  {
    case 1:
      result = 0;
      LOBYTE(a4) = a2[2].i8[0];
      goto LABEL_26;
    case 3:
      v7 = a2[2].u16[0];
      LOWORD(__dsta) = a2[2].i16[0];
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dsta);
        v7 = LOWORD(__dsta);
      }
      goto LABEL_9;
    case 4:
      v7 = a2[2].u32[0];
      LODWORD(__dsta) = v7;
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dsta, *(uint8x8_t *)&a4);
        v7 = LODWORD(__dsta);
      }
LABEL_9:
      result = 0;
      v8 = (double)v7;
      break;
    case 5:
      return TIFFReadDirEntryCheckedRational(a1, (uint64_t)a2, __dst, *(uint8x8_t *)&a4);
    case 6:
      result = 0;
      v9 = a2[2].i8[0];
      goto LABEL_15;
    case 8:
      v10 = a2[2].i16[0];
      LOWORD(__dsta) = v10;
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dsta);
        v10 = LOWORD(__dsta);
      }
      result = 0;
      v9 = v10;
LABEL_15:
      v8 = (double)v9;
      break;
    case 9:
      v11 = a2[2].i32[0];
      LODWORD(__dsta) = v11;
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dsta, *(uint8x8_t *)&a4);
        v11 = LODWORD(__dsta);
      }
      result = 0;
      v8 = (double)v11;
      break;
    case 0xA:
      return TIFFReadDirEntryCheckedSrational(a1, (uint64_t)a2, __dst, *(uint8x8_t *)&a4);
    case 0xB:
      LODWORD(a4) = a2[2].i32[0];
      LODWORD(__dsta) = LODWORD(a4);
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dsta, *(uint8x8_t *)&a4);
        LODWORD(a4) = LODWORD(__dsta);
      }
      result = 0;
      v8 = *(float *)&a4;
      break;
    case 0xC:
      return TIFFReadDirEntryCheckedDouble(a1, a2, (int8x8_t *)__dst, *(uint8x8_t *)&a4);
    case 0x10:
      __dsta = 0.0;
      result = TIFFReadDirEntryCheckedLong8(a1, a2, (int8x8_t *)&__dsta, *(uint8x8_t *)&a4);
      if ((_DWORD)result)
        return result;
      a4 = __dsta;
LABEL_26:
      v8 = (double)*(unint64_t *)&a4;
      break;
    case 0x11:
      __dsta = 0.0;
      result = TIFFReadDirEntryCheckedLong8(a1, a2, (int8x8_t *)&__dsta, *(uint8x8_t *)&a4);
      if ((_DWORD)result)
        return result;
      v8 = (double)*(uint64_t *)&__dsta;
      break;
    default:
      return result;
  }
  *__dst = v8;
  return result;
}

uint64_t TIFFReadDirEntryIfd8(uint64_t a1, int8x8_t *a2, int8x8_t *__dst, uint8x8_t a4)
{
  unsigned int v6;
  uint64_t result;
  unsigned __int32 v9;
  unsigned __int32 v11;

  if (*(_QWORD *)&a2[1] != 1)
    return 1;
  v6 = a2->u16[1];
  result = 2;
  if (v6 > 0xF)
  {
    if (v6 == 16 || v6 == 18)
      return TIFFReadDirEntryCheckedLong8(a1, a2, __dst, a4);
  }
  else if (v6 == 4 || v6 == 13)
  {
    v9 = a2[2].u32[0];
    v11 = v9;
    if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
    {
      TIFFSwabLong((__int32 *)&v11, a4);
      v9 = v11;
    }
    result = 0;
    *__dst = (int8x8_t)v9;
  }
  return result;
}

uint64_t TIFFReadDirEntrySbyteArray(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  unsigned int v3;
  BOOL v4;
  int v5;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  int v18;
  uint64_t v19;
  int v20;
  unsigned int v22;
  char *v23;
  int8x8_t v24;
  char *v25;
  char *v26;
  char *v27;
  unsigned int v28;
  char *v29;
  __int32 *v30;
  __int32 v31;
  char *v32;
  char *v33;
  int v34;
  char *v35;
  __int32 *v36;
  __int32 v37;
  char *v38;
  int8x8_t *v39;
  int8x8_t v40;
  char *v41;
  int8x8_t *v42;
  int8x8_t v43;
  void *v44;
  unsigned int v45;

  v3 = *(unsigned __int16 *)(a2 + 2);
  v4 = v3 > 0x11;
  v5 = (1 << v3) & 0x303DA;
  if (v4 || v5 == 0)
    return 2;
  v45 = 0;
  v44 = 0;
  v16 = TIFFReadDirEntryArrayWithLimit(a1, a2, &v45, 1u, &v44, 0xFFFFFFFFFFFFFFFFLL);
  if ((_DWORD)v16 || (v17 = (char *)v44) == 0)
  {
    *a3 = 0;
    return v16;
  }
  v18 = *(unsigned __int16 *)(a2 + 2);
  switch(v18)
  {
    case 7:
      goto LABEL_10;
    case 6:
      goto LABEL_14;
    case 1:
LABEL_10:
      if (v45)
      {
        v19 = 0;
        while (1)
        {
          v20 = *((unsigned __int8 *)v44 + v19) >> 5;
          if ((v20 & 4) != 0)
            break;
          if (v45 == (_DWORD)++v19)
            goto LABEL_14;
        }
        v16 = v20 & 4;
        _TIFFfreeExt(a1, (char *)v44);
        return v16;
      }
LABEL_14:
      v16 = 0;
      *a3 = v44;
      return v16;
  }
  v22 = v45;
  v23 = (char *)_TIFFmallocExt((_QWORD *)a1, v45, v10, v11, v12, v13, v14, v15);
  if (v23)
  {
    v25 = v23;
    switch(*(_WORD *)(a2 + 2))
    {
      case 3:
        if (!v22)
          goto LABEL_63;
        v26 = v23;
        v27 = v17;
        while (1)
        {
          if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
            TIFFSwabShort(v27);
          v28 = *(unsigned __int16 *)v27;
          if (v28 > 0x7F)
            goto LABEL_64;
          v27 += 2;
          *v26++ = v28;
          if (!--v22)
            goto LABEL_63;
        }
      case 4:
        if (!v22)
          goto LABEL_63;
        v29 = v23;
        v30 = (__int32 *)v17;
        while (1)
        {
          if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
            v24 = TIFFSwabLong(v30, (uint8x8_t)v24);
          v31 = *v30;
          if (*v30 > 0x7F)
            goto LABEL_64;
          ++v30;
          *v29++ = v31;
          if (!--v22)
            goto LABEL_63;
        }
      case 8:
        if (!v22)
          goto LABEL_63;
        v32 = v23;
        v33 = v17;
        while (1)
        {
          if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
            TIFFSwabShort(v33);
          v34 = *(unsigned __int16 *)v33;
          if (v34 != (unsigned __int16)(char)v34)
            goto LABEL_64;
          v33 += 2;
          *v32++ = v34;
          if (!--v22)
            goto LABEL_63;
        }
      case 9:
        if (!v22)
          goto LABEL_63;
        v35 = v23;
        v36 = (__int32 *)v17;
        while (1)
        {
          if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
            v24 = TIFFSwabLong(v36, (uint8x8_t)v24);
          v37 = *v36;
          if (v37 != (char)v37)
            goto LABEL_64;
          ++v36;
          *v35++ = v37;
          if (!--v22)
            goto LABEL_63;
        }
      case 0x10:
        if (!v22)
          goto LABEL_63;
        v38 = v23;
        v39 = (int8x8_t *)v17;
        while (1)
        {
          if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
            TIFFSwabLong8(v39);
          v40 = *v39;
          if (*(_QWORD *)v39 > 0x7FuLL)
            goto LABEL_64;
          ++v39;
          *v38++ = v40.i8[0];
          if (!--v22)
            goto LABEL_63;
        }
      case 0x11:
        if (!v22)
          goto LABEL_63;
        v41 = v23;
        v42 = (int8x8_t *)v17;
        break;
      default:
        goto LABEL_63;
    }
    while (1)
    {
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
        TIFFSwabLong8(v42);
      v43 = *v42;
      if (*v42 != v42->i8[0])
        break;
      ++v42;
      *v41++ = v43.i8[0];
      if (!--v22)
      {
LABEL_63:
        _TIFFfreeExt(a1, v17);
        v16 = 0;
        *a3 = v25;
        return v16;
      }
    }
LABEL_64:
    _TIFFfreeExt(a1, v17);
    _TIFFfreeExt(a1, v25);
    return 4;
  }
  else
  {
    _TIFFfreeExt(a1, v17);
    return 7;
  }
}

uint64_t TIFFReadDirEntrySshortArray(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  unsigned int v3;
  BOOL v4;
  int v5;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  int v18;
  unsigned int v19;
  _BYTE *v20;
  int v21;
  unsigned int v22;
  char *v23;
  int8x8_t v24;
  char *v25;
  int v26;
  char *v27;
  char *v28;
  __int16 v29;
  char *v30;
  int8x8_t *v31;
  int8x8_t v32;
  char *v33;
  __int32 *v34;
  __int32 v35;
  char *v36;
  char *v37;
  __int16 v38;
  char *v39;
  __int32 *v40;
  __int32 v41;
  char *v42;
  int8x8_t *v43;
  int8x8_t v44;
  void *v46;
  unsigned int v47;

  v3 = *(unsigned __int16 *)(a2 + 2);
  v4 = v3 > 0x11;
  v5 = (1 << v3) & 0x3035A;
  if (v4 || v5 == 0)
    return 2;
  v47 = 0;
  v46 = 0;
  v16 = TIFFReadDirEntryArrayWithLimit(a1, a2, &v47, 2u, &v46, 0xFFFFFFFFFFFFFFFFLL);
  if ((_DWORD)v16 || (v17 = (char *)v46) == 0)
  {
    *a3 = 0;
  }
  else
  {
    v18 = *(unsigned __int16 *)(a2 + 2);
    if (v18 == 8)
    {
      *a3 = v46;
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
        TIFFSwabArrayOfShort((uint64_t)v17, v47);
      return 0;
    }
    else if (v18 == 3)
    {
      v19 = v47;
      if (v47)
      {
        v20 = v46;
        while (1)
        {
          if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
            TIFFSwabShort(v20);
          v21 = *(unsigned __int16 *)v20 >> 13;
          if ((v21 & 4) != 0)
            break;
          v20 += 2;
          if (!--v19)
            goto LABEL_15;
        }
        v16 = v21 & 4;
        _TIFFfreeExt(a1, v17);
      }
      else
      {
LABEL_15:
        v16 = 0;
        *a3 = v17;
      }
    }
    else
    {
      v22 = v47;
      v23 = (char *)_TIFFmallocExt((_QWORD *)a1, 2 * v47, v10, v11, v12, v13, v14, v15);
      if (v23)
      {
        v25 = v23;
        v26 = *(unsigned __int16 *)(a2 + 2);
        switch(*(_WORD *)(a2 + 2))
        {
          case 1:
            if (v22)
            {
              v27 = v23;
              v28 = v17;
              do
              {
                v29 = *v28++;
                *(_WORD *)v27 = v29;
                v27 += 2;
                --v22;
              }
              while (v22);
            }
            goto LABEL_62;
          case 2:
          case 3:
          case 5:
          case 7:
          case 8:
            goto LABEL_62;
          case 4:
            if (!v22)
              goto LABEL_62;
            v33 = v23;
            v34 = (__int32 *)v17;
            while (1)
            {
              if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                v24 = TIFFSwabLong(v34, (uint8x8_t)v24);
              v35 = *v34;
              if (*v34 >> 15)
                goto LABEL_64;
              ++v34;
              *(_WORD *)v33 = v35;
              v33 += 2;
              if (!--v22)
                goto LABEL_62;
            }
          case 6:
            if (v22)
            {
              v36 = v23;
              v37 = v17;
              do
              {
                v38 = *v37++;
                *(_WORD *)v36 = v38;
                v36 += 2;
                --v22;
              }
              while (v22);
            }
            goto LABEL_62;
          case 9:
            if (!v22)
              goto LABEL_62;
            v39 = v23;
            v40 = (__int32 *)v17;
            break;
          default:
            if (v26 == 16)
            {
              if (!v22)
                goto LABEL_62;
              v42 = v23;
              v43 = (int8x8_t *)v17;
              while (1)
              {
                if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                  TIFFSwabLong8(v43);
                v44 = *v43;
                if (*(unint64_t *)v43 >> 15)
                  break;
                ++v43;
                *(_WORD *)v42 = v44.i16[0];
                v42 += 2;
                if (!--v22)
                  goto LABEL_62;
              }
            }
            else
            {
              if (v26 != 17 || !v22)
                goto LABEL_62;
              v30 = v23;
              v31 = (int8x8_t *)v17;
              while (1)
              {
                if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                  TIFFSwabLong8(v31);
                v32 = *v31;
                if (*v31 != v31->i16[0])
                  break;
                ++v31;
                *(_WORD *)v30 = v32.i16[0];
                v30 += 2;
                if (!--v22)
                  goto LABEL_62;
              }
            }
            goto LABEL_64;
        }
        while (1)
        {
          if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
            v24 = TIFFSwabLong(v40, (uint8x8_t)v24);
          v41 = *v40;
          if (v41 != (__int16)v41)
            break;
          ++v40;
          *(_WORD *)v39 = v41;
          v39 += 2;
          if (!--v22)
          {
LABEL_62:
            _TIFFfreeExt(a1, v17);
            v16 = 0;
            *a3 = v25;
            return v16;
          }
        }
LABEL_64:
        _TIFFfreeExt(a1, v17);
        _TIFFfreeExt(a1, v25);
        return 4;
      }
      else
      {
        _TIFFfreeExt(a1, v17);
        return 7;
      }
    }
  }
  return v16;
}

uint64_t TIFFReadDirEntryLongArray(uint64_t a1, uint64_t a2, __int32 **a3)
{
  unsigned int v3;
  BOOL v4;
  int v5;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int8x8_t v17;
  __int32 *v18;
  int v19;
  unsigned int v20;
  __int32 *v21;
  unsigned int v22;
  unsigned int v23;
  char *v24;
  char *v25;
  int v26;
  char *v27;
  __int32 *v28;
  int v29;
  uint64_t v30;
  char *v31;
  char *v32;
  int8x8_t *v33;
  int8x8_t v34;
  char *v35;
  __int32 *v36;
  int v37;
  char *v38;
  __int32 *v39;
  unsigned int v40;
  char *v41;
  __int32 *v42;
  unsigned int v43;
  char *v44;
  int8x8_t *v45;
  int8x8_t v46;
  __int32 *v48;
  unsigned int v49;

  v3 = *(unsigned __int16 *)(a2 + 2);
  v4 = v3 > 0x11;
  v5 = (1 << v3) & 0x3035A;
  if (v4 || v5 == 0)
    return 2;
  v49 = 0;
  v48 = 0;
  v16 = TIFFReadDirEntryArrayWithLimit(a1, a2, &v49, 4u, (void **)&v48, 0xFFFFFFFFFFFFFFFFLL);
  if ((_DWORD)v16 || (v18 = v48) == 0)
  {
    *a3 = 0;
  }
  else
  {
    v19 = *(unsigned __int16 *)(a2 + 2);
    if (v19 == 4)
    {
      *a3 = v48;
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
        TIFFSwabArrayOfLong(v18, v49, (uint8x8_t)v17);
      return 0;
    }
    else if (v19 == 9)
    {
      v20 = v49;
      if (v49)
      {
        v21 = v48;
        while (1)
        {
          if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
            v17 = TIFFSwabLong(v21, (uint8x8_t)v17);
          v22 = *v21 >> 29;
          if ((v22 & 4) != 0)
            break;
          ++v21;
          if (!--v20)
            goto LABEL_15;
        }
        v16 = v22 & 4;
        v30 = a1;
        v31 = (char *)v18;
LABEL_67:
        _TIFFfreeExt(v30, v31);
      }
      else
      {
LABEL_15:
        v16 = 0;
        *a3 = v18;
      }
    }
    else
    {
      v23 = v49;
      v24 = (char *)_TIFFmallocExt((_QWORD *)a1, 4 * v49, v10, v11, v12, v13, v14, v15);
      if (v24)
      {
        v25 = v24;
        v26 = *(unsigned __int16 *)(a2 + 2);
        switch(*(_WORD *)(a2 + 2))
        {
          case 1:
            if (v23)
            {
              v27 = v24;
              v28 = v18;
              do
              {
                v29 = *(unsigned __int8 *)v28;
                v28 = (__int32 *)((char *)v28 + 1);
                *(_DWORD *)v27 = v29;
                v27 += 4;
                --v23;
              }
              while (v23);
            }
            goto LABEL_62;
          case 2:
          case 4:
          case 5:
          case 7:
            goto LABEL_62;
          case 3:
            if (v23)
            {
              v35 = v24;
              v36 = v18;
              do
              {
                if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                  TIFFSwabShort(v36);
                v37 = *(unsigned __int16 *)v36;
                v36 = (__int32 *)((char *)v36 + 2);
                *(_DWORD *)v35 = v37;
                v35 += 4;
                --v23;
              }
              while (v23);
            }
            goto LABEL_62;
          case 6:
            if (!v23)
              goto LABEL_62;
            v38 = v24;
            v39 = v18;
            while (1)
            {
              v40 = *(char *)v39;
              if (((v40 >> 5) & 4) != 0)
                break;
              v39 = (__int32 *)((char *)v39 + 1);
              *(_DWORD *)v38 = v40;
              v38 += 4;
              if (!--v23)
                goto LABEL_62;
            }
            v16 = (v40 >> 5) & 4;
            goto LABEL_66;
          case 8:
            if (!v23)
              goto LABEL_62;
            v41 = v24;
            v42 = v18;
            while (1)
            {
              if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                TIFFSwabShort(v42);
              v43 = *(__int16 *)v42;
              if (((v43 >> 13) & 4) != 0)
                break;
              v42 = (__int32 *)((char *)v42 + 2);
              *(_DWORD *)v41 = v43;
              v41 += 4;
              if (!--v23)
                goto LABEL_62;
            }
            v16 = (v43 >> 13) & 4;
LABEL_66:
            _TIFFfreeExt(a1, (char *)v18);
            v30 = a1;
            v31 = v25;
            goto LABEL_67;
          default:
            if (v26 == 16)
            {
              if (!v23)
                goto LABEL_62;
              v44 = v24;
              v45 = (int8x8_t *)v18;
              while (1)
              {
                if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                  TIFFSwabLong8(v45);
                v46 = *v45;
                if (HIDWORD(*(unint64_t *)v45))
                  break;
                ++v45;
                *(_DWORD *)v44 = v46.i32[0];
                v44 += 4;
                if (!--v23)
                  goto LABEL_62;
              }
            }
            else
            {
              if (v26 != 17 || !v23)
              {
LABEL_62:
                _TIFFfreeExt(a1, (char *)v18);
                v16 = 0;
                *a3 = (__int32 *)v25;
                return v16;
              }
              v32 = v24;
              v33 = (int8x8_t *)v18;
              while (1)
              {
                if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                  TIFFSwabLong8(v33);
                v34 = *v33;
                if (HIDWORD(*(unint64_t *)v33))
                  break;
                ++v33;
                *(_DWORD *)v32 = v34.i32[0];
                v32 += 4;
                if (!--v23)
                  goto LABEL_62;
              }
            }
            v16 = 4;
            goto LABEL_66;
        }
      }
      _TIFFfreeExt(a1, (char *)v18);
      return 7;
    }
  }
  return v16;
}

uint64_t TIFFReadDirEntrySlongArray(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  unsigned int v3;
  BOOL v4;
  int v5;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int8x8_t v17;
  __int32 *v18;
  int v19;
  unsigned int v20;
  __int32 *v21;
  unsigned int v22;
  unsigned int v23;
  char *v24;
  char *v25;
  int v26;
  char *v27;
  __int32 *v28;
  int v29;
  char *v30;
  int8x8_t *v31;
  int8x8_t v32;
  char *v33;
  __int32 *v34;
  int v35;
  char *v36;
  __int32 *v37;
  int v38;
  char *v39;
  __int32 *v40;
  int v41;
  char *v42;
  int8x8_t *v43;
  int8x8_t v44;
  void *v46;
  unsigned int v47;

  v3 = *(unsigned __int16 *)(a2 + 2);
  v4 = v3 > 0x11;
  v5 = (1 << v3) & 0x3035A;
  if (v4 || v5 == 0)
    return 2;
  v47 = 0;
  v46 = 0;
  v16 = TIFFReadDirEntryArrayWithLimit(a1, a2, &v47, 4u, &v46, 0xFFFFFFFFFFFFFFFFLL);
  if ((_DWORD)v16 || (v18 = (__int32 *)v46) == 0)
  {
    *a3 = 0;
    return v16;
  }
  v19 = *(unsigned __int16 *)(a2 + 2);
  if (v19 == 9)
  {
    *a3 = v46;
    if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      TIFFSwabArrayOfLong(v18, v47, (uint8x8_t)v17);
    return 0;
  }
  if (v19 != 4)
  {
    v23 = v47;
    v24 = (char *)_TIFFmallocExt((_QWORD *)a1, 4 * v47, v10, v11, v12, v13, v14, v15);
    if (!v24)
    {
      _TIFFfreeExt(a1, (char *)v18);
      return 7;
    }
    v25 = v24;
    v26 = *(unsigned __int16 *)(a2 + 2);
    switch(*(_WORD *)(a2 + 2))
    {
      case 1:
        if (v23)
        {
          v27 = v24;
          v28 = v18;
          do
          {
            v29 = *(unsigned __int8 *)v28;
            v28 = (__int32 *)((char *)v28 + 1);
            *(_DWORD *)v27 = v29;
            v27 += 4;
            --v23;
          }
          while (v23);
        }
        goto LABEL_60;
      case 2:
      case 4:
      case 5:
      case 7:
        goto LABEL_60;
      case 3:
        if (v23)
        {
          v33 = v24;
          v34 = v18;
          do
          {
            if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
              TIFFSwabShort(v34);
            v35 = *(unsigned __int16 *)v34;
            v34 = (__int32 *)((char *)v34 + 2);
            *(_DWORD *)v33 = v35;
            v33 += 4;
            --v23;
          }
          while (v23);
        }
        goto LABEL_60;
      case 6:
        if (v23)
        {
          v36 = v24;
          v37 = v18;
          do
          {
            v38 = *(char *)v37;
            v37 = (__int32 *)((char *)v37 + 1);
            *(_DWORD *)v36 = v38;
            v36 += 4;
            --v23;
          }
          while (v23);
        }
        goto LABEL_60;
      case 8:
        if (v23)
        {
          v39 = v24;
          v40 = v18;
          do
          {
            if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
              TIFFSwabShort(v40);
            v41 = *(__int16 *)v40;
            v40 = (__int32 *)((char *)v40 + 2);
            *(_DWORD *)v39 = v41;
            v39 += 4;
            --v23;
          }
          while (v23);
        }
        goto LABEL_60;
      default:
        if (v26 == 16)
        {
          if (v23)
          {
            v42 = v24;
            v43 = (int8x8_t *)v18;
            do
            {
              if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                TIFFSwabLong8(v43);
              v44 = *v43;
              if (*(unint64_t *)v43 >> 31)
                goto LABEL_62;
              ++v43;
              *(_DWORD *)v42 = v44.i32[0];
              v42 += 4;
            }
            while (--v23);
          }
        }
        else if (v26 == 17 && v23)
        {
          v30 = v24;
          v31 = (int8x8_t *)v18;
          while (1)
          {
            if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
              TIFFSwabLong8(v31);
            v32 = *v31;
            if (*v31 != v31->i32[0])
              break;
            ++v31;
            *(_DWORD *)v30 = v32.i32[0];
            v30 += 4;
            if (!--v23)
              goto LABEL_60;
          }
LABEL_62:
          _TIFFfreeExt(a1, (char *)v18);
          _TIFFfreeExt(a1, v25);
          return 4;
        }
LABEL_60:
        _TIFFfreeExt(a1, (char *)v18);
        v16 = 0;
        *a3 = v25;
        return v16;
    }
  }
  v20 = v47;
  if (v47)
  {
    v21 = (__int32 *)v46;
    while (1)
    {
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
        v17 = TIFFSwabLong(v21, (uint8x8_t)v17);
      v22 = *v21 >> 29;
      if ((v22 & 4) != 0)
        break;
      ++v21;
      if (!--v20)
        goto LABEL_15;
    }
    v16 = v22 & 4;
    _TIFFfreeExt(a1, (char *)v18);
  }
  else
  {
LABEL_15:
    v16 = 0;
    *a3 = v18;
  }
  return v16;
}

uint64_t TIFFReadDirEntrySlong8Array(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  unsigned int v3;
  BOOL v4;
  int v5;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int8x8_t *v17;
  int v18;
  unsigned int v19;
  int8x8_t *v20;
  unsigned int v21;
  _QWORD *v22;
  int8x8_t v23;
  _QWORD *v24;
  _QWORD *v25;
  int8x8_t *v26;
  unsigned int v27;
  _QWORD *v28;
  int8x8_t *v29;
  unsigned int v30;
  _QWORD *v31;
  __int32 *v32;
  unsigned __int32 v33;
  _QWORD *v34;
  int8x8_t *v35;
  uint64_t v36;
  _QWORD *v37;
  int8x8_t *v38;
  uint64_t v39;
  _QWORD *v40;
  __int32 *v41;
  uint64_t v42;
  void *v44;
  unsigned int v45;

  v3 = *(unsigned __int16 *)(a2 + 2);
  v4 = v3 > 0x11;
  v5 = (1 << v3) & 0x3035A;
  if (v4 || v5 == 0)
    return 2;
  v45 = 0;
  v44 = 0;
  v16 = TIFFReadDirEntryArrayWithLimit(a1, a2, &v45, 8u, &v44, 0xFFFFFFFFFFFFFFFFLL);
  if ((_DWORD)v16 || (v17 = (int8x8_t *)v44) == 0)
  {
    *a3 = 0;
  }
  else
  {
    v18 = *(unsigned __int16 *)(a2 + 2);
    if (v18 == 17)
    {
      *a3 = v44;
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
        TIFFSwabArrayOfLong8(v17, v45);
      return 0;
    }
    else if (v18 == 16)
    {
      v19 = v45;
      if (v45)
      {
        v20 = (int8x8_t *)v44;
        while (1)
        {
          if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
            TIFFSwabLong8(v20);
          if (((*(unint64_t *)v20 >> 61) & 4) != 0)
            break;
          ++v20;
          if (!--v19)
            goto LABEL_15;
        }
        v16 = (*(unint64_t *)v20 >> 61) & 4;
        _TIFFfreeExt(a1, (char *)v17);
      }
      else
      {
LABEL_15:
        v16 = 0;
        *a3 = v17;
      }
    }
    else
    {
      v21 = v45;
      v22 = _TIFFmallocExt((_QWORD *)a1, 8 * v45, v10, v11, v12, v13, v14, v15);
      if (v22)
      {
        v24 = v22;
        switch(*(_WORD *)(a2 + 2))
        {
          case 1:
            if (v21)
            {
              v25 = v22;
              v26 = v17;
              do
              {
                v27 = v26->u8[0];
                v26 = (int8x8_t *)((char *)v26 + 1);
                *v25++ = v27;
                --v21;
              }
              while (v21);
            }
            break;
          case 3:
            if (v21)
            {
              v28 = v22;
              v29 = v17;
              do
              {
                if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                  TIFFSwabShort(v29);
                v30 = v29->u16[0];
                v29 = (int8x8_t *)((char *)v29 + 2);
                *v28++ = v30;
                --v21;
              }
              while (v21);
            }
            break;
          case 4:
            if (v21)
            {
              v31 = v22;
              v32 = (__int32 *)v17;
              do
              {
                if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                  v23 = TIFFSwabLong(v32, (uint8x8_t)v23);
                v33 = *v32++;
                *v31++ = v33;
                --v21;
              }
              while (v21);
            }
            break;
          case 6:
            if (v21)
            {
              v34 = v22;
              v35 = v17;
              do
              {
                v36 = v35->i8[0];
                v35 = (int8x8_t *)((char *)v35 + 1);
                *v34++ = v36;
                --v21;
              }
              while (v21);
            }
            break;
          case 8:
            if (v21)
            {
              v37 = v22;
              v38 = v17;
              do
              {
                if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                  TIFFSwabShort(v38);
                v39 = v38->i16[0];
                v38 = (int8x8_t *)((char *)v38 + 2);
                *v37++ = v39;
                --v21;
              }
              while (v21);
            }
            break;
          case 9:
            if (v21)
            {
              v40 = v22;
              v41 = (__int32 *)v17;
              do
              {
                if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                  v23 = TIFFSwabLong(v41, (uint8x8_t)v23);
                v42 = *v41++;
                *v40++ = v42;
                --v21;
              }
              while (v21);
            }
            break;
          default:
            break;
        }
        _TIFFfreeExt(a1, (char *)v17);
        v16 = 0;
        *a3 = v24;
      }
      else
      {
        _TIFFfreeExt(a1, (char *)v17);
        return 7;
      }
    }
  }
  return v16;
}

uint64_t TIFFReadDirEntryFloatArray(uint64_t a1, uint64_t a2, int8x8_t **a3)
{
  unsigned int v3;
  BOOL v4;
  int v5;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint8x8_t v17;
  int8x8_t *v18;
  uint64_t v19;
  float *v20;
  int8x8_t v21;
  float *v22;
  float *v23;
  int8x8_t *v24;
  unsigned int v25;
  float *v26;
  int8x8_t *v27;
  unsigned int v28;
  float *v29;
  __int32 *v30;
  unsigned int v31;
  float *v32;
  __int32 *v33;
  unsigned int *v34;
  unsigned int v35;
  float *v36;
  int8x8_t *v37;
  int v38;
  float *v39;
  int8x8_t *v40;
  int v41;
  float *v42;
  __int32 *v43;
  int v44;
  float *v45;
  __int32 *v46;
  unsigned int *v47;
  int v48;
  float *v49;
  int8x8_t *v50;
  unint64_t v51;
  float *v52;
  int8x8_t *v53;
  uint64_t v54;
  float *v55;
  double *v56;
  double v57;
  double v58;
  double v59;
  float v60;
  __int32 *v61;
  unsigned int v62;

  v3 = *(unsigned __int16 *)(a2 + 2);
  v4 = v3 > 0x11;
  v5 = (1 << v3) & 0x31F7A;
  if (v4 || v5 == 0)
    return 2;
  v62 = 0;
  v61 = 0;
  result = TIFFReadDirEntryArrayWithLimit(a1, a2, &v62, 4u, (void **)&v61, 0xFFFFFFFFFFFFFFFFLL);
  if ((_DWORD)result || (v18 = (int8x8_t *)v61) == 0)
  {
    *a3 = 0;
  }
  else if (*(_WORD *)(a2 + 2) == 11)
  {
    if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      TIFFSwabArrayOfLong(v61, v62, v17);
    result = 0;
    *a3 = v18;
  }
  else
  {
    v19 = v62;
    v20 = (float *)_TIFFmallocExt((_QWORD *)a1, 4 * v62, v11, v12, v13, v14, v15, v16);
    if (v20)
    {
      v22 = v20;
      switch(*(_WORD *)(a2 + 2))
      {
        case 1:
          if ((_DWORD)v19)
          {
            v23 = v20;
            v24 = v18;
            do
            {
              v25 = v24->u8[0];
              v24 = (int8x8_t *)((char *)v24 + 1);
              *v23++ = (float)v25;
              LODWORD(v19) = v19 - 1;
            }
            while ((_DWORD)v19);
          }
          break;
        case 3:
          if ((_DWORD)v19)
          {
            v26 = v20;
            v27 = v18;
            do
            {
              if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                TIFFSwabShort(v27);
              v28 = v27->u16[0];
              v27 = (int8x8_t *)((char *)v27 + 2);
              *v26++ = (float)v28;
              LODWORD(v19) = v19 - 1;
            }
            while ((_DWORD)v19);
          }
          break;
        case 4:
          if ((_DWORD)v19)
          {
            v29 = v20;
            v30 = (__int32 *)v18;
            do
            {
              if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                v21 = TIFFSwabLong(v30, (uint8x8_t)v21);
              v31 = *v30++;
              *(float *)v21.i32 = (float)v31;
              *v29++ = (float)v31;
              LODWORD(v19) = v19 - 1;
            }
            while ((_DWORD)v19);
          }
          break;
        case 5:
          if ((_DWORD)v19)
          {
            v32 = v20;
            v33 = (__int32 *)v18;
            do
            {
              if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
              {
                v21 = TIFFSwabLong(v33, (uint8x8_t)v21);
                v34 = (unsigned int *)(v33 + 1);
                v35 = *v33;
                if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                  v21 = TIFFSwabLong(v33 + 1, (uint8x8_t)v21);
              }
              else
              {
                v34 = (unsigned int *)(v33 + 1);
                v35 = *v33;
              }
              if (*v34)
                *(float *)v21.i32 = (float)v35 / (float)*v34;
              else
                v21.i32[0] = 0;
              v33 += 2;
              *v32++ = *(float *)v21.i32;
              LODWORD(v19) = v19 - 1;
            }
            while ((_DWORD)v19);
          }
          break;
        case 6:
          if ((_DWORD)v19)
          {
            v36 = v20;
            v37 = v18;
            do
            {
              v38 = v37->i8[0];
              v37 = (int8x8_t *)((char *)v37 + 1);
              *v36++ = (float)v38;
              LODWORD(v19) = v19 - 1;
            }
            while ((_DWORD)v19);
          }
          break;
        case 8:
          if ((_DWORD)v19)
          {
            v39 = v20;
            v40 = v18;
            do
            {
              if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                TIFFSwabShort(v40);
              v41 = v40->i16[0];
              v40 = (int8x8_t *)((char *)v40 + 2);
              *v39++ = (float)v41;
              LODWORD(v19) = v19 - 1;
            }
            while ((_DWORD)v19);
          }
          break;
        case 9:
          if ((_DWORD)v19)
          {
            v42 = v20;
            v43 = (__int32 *)v18;
            do
            {
              if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                v21 = TIFFSwabLong(v43, (uint8x8_t)v21);
              v44 = *v43++;
              *(float *)v21.i32 = (float)v44;
              *v42++ = (float)v44;
              LODWORD(v19) = v19 - 1;
            }
            while ((_DWORD)v19);
          }
          break;
        case 0xA:
          if ((_DWORD)v19)
          {
            v45 = v20;
            v46 = (__int32 *)v18;
            do
            {
              if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
              {
                v21 = TIFFSwabLong(v46, (uint8x8_t)v21);
                v47 = (unsigned int *)(v46 + 1);
                v48 = *v46;
                if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                  v21 = TIFFSwabLong(v46 + 1, (uint8x8_t)v21);
              }
              else
              {
                v47 = (unsigned int *)(v46 + 1);
                v48 = *v46;
              }
              if (*v47)
                *(float *)v21.i32 = (float)v48 / (float)*v47;
              else
                v21.i32[0] = 0;
              v46 += 2;
              *v45++ = *(float *)v21.i32;
              LODWORD(v19) = v19 - 1;
            }
            while ((_DWORD)v19);
          }
          break;
        case 0xC:
          if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
            TIFFSwabArrayOfLong8(v18, v19);
          if ((_DWORD)v19)
          {
            v55 = v22;
            v56 = (double *)v18;
            do
            {
              v57 = *v56++;
              v58 = v57;
              v59 = 3.40282347e38;
              if (v57 <= 3.40282347e38)
              {
                v59 = v58;
                if (v58 < -3.40282347e38)
                  v59 = -3.40282347e38;
              }
              v60 = v59;
              *v55++ = v60;
              LODWORD(v19) = v19 - 1;
            }
            while ((_DWORD)v19);
          }
          break;
        case 0x10:
          if ((_DWORD)v19)
          {
            v49 = v20;
            v50 = v18;
            do
            {
              if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                TIFFSwabLong8(v50);
              v51 = (unint64_t)*v50++;
              *v49++ = (float)v51;
              LODWORD(v19) = v19 - 1;
            }
            while ((_DWORD)v19);
          }
          break;
        case 0x11:
          if ((_DWORD)v19)
          {
            v52 = v20;
            v53 = v18;
            do
            {
              if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                TIFFSwabLong8(v53);
              v54 = (uint64_t)*v53++;
              *v52++ = (float)v54;
              LODWORD(v19) = v19 - 1;
            }
            while ((_DWORD)v19);
          }
          break;
        default:
          break;
      }
      _TIFFfreeExt(a1, (char *)v18);
      result = 0;
      *a3 = (int8x8_t *)v22;
    }
    else
    {
      _TIFFfreeExt(a1, (char *)v18);
      return 7;
    }
  }
  return result;
}

uint64_t TIFFReadDirEntryIfd8Array(uint64_t a1, uint64_t a2, int8x8_t **a3)
{
  unsigned int v3;
  BOOL v4;
  int v5;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int8x8_t *v17;
  unsigned int v18;
  int8x8_t *v19;
  int8x8_t v20;
  int8x8_t *v21;
  int v22;
  int8x8_t *v23;
  __int32 *v24;
  unsigned __int32 v25;
  int8x8_t *v26;
  unsigned int v27;

  v3 = *(unsigned __int16 *)(a2 + 2);
  v4 = v3 > 0x12;
  v5 = (1 << v3) & 0x52010;
  if (v4 || v5 == 0)
    return 2;
  v27 = 0;
  v26 = 0;
  result = TIFFReadDirEntryArrayWithLimit(a1, a2, &v27, 8u, (void **)&v26, 0xFFFFFFFFFFFFFFFFLL);
  if ((_DWORD)result || (v17 = v26) == 0)
  {
    *a3 = 0;
  }
  else if ((*(unsigned __int16 *)(a2 + 2) | 2) == 0x12)
  {
    *a3 = v26;
    if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      TIFFSwabArrayOfLong8(v17, v27);
    return 0;
  }
  else
  {
    v18 = v27;
    v19 = (int8x8_t *)_TIFFmallocExt((_QWORD *)a1, 8 * v27, v11, v12, v13, v14, v15, v16);
    if (v19)
    {
      v21 = v19;
      v22 = *(unsigned __int16 *)(a2 + 2);
      if ((v22 == 13 || v22 == 4) && v18)
      {
        v23 = v19;
        v24 = (__int32 *)v17;
        do
        {
          if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
            v20 = TIFFSwabLong(v24, (uint8x8_t)v20);
          v25 = *v24++;
          *v23++ = (int8x8_t)v25;
          --v18;
        }
        while (v18);
      }
      _TIFFfreeExt(a1, (char *)v17);
      result = 0;
      *a3 = v21;
    }
    else
    {
      _TIFFfreeExt(a1, (char *)v17);
      return 7;
    }
  }
  return result;
}

uint64_t TIFFReadDirEntryCheckedRational(uint64_t a1, uint64_t a2, double *a3, uint8x8_t a4)
{
  int v5;
  unsigned __int32 v7;
  uint64_t result;
  double v9;
  BOOL v10;
  unsigned __int32 v11;
  uint64_t __dst;

  __dst = 0;
  v5 = *(_DWORD *)(a1 + 16);
  if ((v5 & 0x80000) != 0)
  {
    __dst = *(_QWORD *)(a2 + 16);
    if ((v5 & 0x80) == 0)
    {
LABEL_9:
      v9 = 0.0;
      if ((_DWORD)__dst)
        v10 = HIDWORD(__dst) == 0;
      else
        v10 = 1;
      if (!v10)
        v9 = (double)__dst / (double)HIDWORD(__dst);
      result = 0;
      *a3 = v9;
      return result;
    }
LABEL_8:
    TIFFSwabArrayOfLong((__int32 *)&__dst, 2, a4);
    goto LABEL_9;
  }
  v7 = *(_DWORD *)(a2 + 16);
  v11 = v7;
  if ((v5 & 0x80) != 0)
  {
    TIFFSwabLong((__int32 *)&v11, a4);
    v7 = v11;
  }
  result = TIFFReadDirEntryData(a1, v7, 8, &__dst);
  if (!(_DWORD)result)
  {
    if ((*(_DWORD *)(a1 + 16) & 0x80) == 0)
      goto LABEL_9;
    goto LABEL_8;
  }
  return result;
}

uint64_t TIFFReadDirEntryCheckedSrational(uint64_t a1, uint64_t a2, double *a3, uint8x8_t a4)
{
  int v5;
  unsigned __int32 v7;
  uint64_t result;
  double v9;
  BOOL v10;
  unsigned __int32 v11;
  uint64_t __dst;

  __dst = 0;
  v5 = *(_DWORD *)(a1 + 16);
  if ((v5 & 0x80000) != 0)
  {
    __dst = *(_QWORD *)(a2 + 16);
    if ((v5 & 0x80) == 0)
    {
LABEL_9:
      v9 = 0.0;
      if ((_DWORD)__dst)
        v10 = HIDWORD(__dst) == 0;
      else
        v10 = 1;
      if (!v10)
        v9 = (double)(int)__dst / (double)HIDWORD(__dst);
      result = 0;
      *a3 = v9;
      return result;
    }
LABEL_8:
    TIFFSwabArrayOfLong((__int32 *)&__dst, 2, a4);
    goto LABEL_9;
  }
  v7 = *(_DWORD *)(a2 + 16);
  v11 = v7;
  if ((v5 & 0x80) != 0)
  {
    TIFFSwabLong((__int32 *)&v11, a4);
    v7 = v11;
  }
  result = TIFFReadDirEntryData(a1, v7, 8, &__dst);
  if (!(_DWORD)result)
  {
    if ((*(_DWORD *)(a1 + 16) & 0x80) == 0)
      goto LABEL_9;
    goto LABEL_8;
  }
  return result;
}

uint64_t TIFFReadDirEntryCheckedDouble(uint64_t a1, int8x8_t *a2, int8x8_t *__dst, uint8x8_t a4)
{
  int v5;
  unsigned __int32 v7;
  uint64_t result;
  unsigned __int32 v9;

  v5 = *(_DWORD *)(a1 + 16);
  if ((v5 & 0x80000) != 0)
  {
    *__dst = a2[2];
    if ((v5 & 0x80) == 0)
      return 0;
LABEL_8:
    TIFFSwabLong8(__dst);
    return 0;
  }
  v7 = a2[2].u32[0];
  v9 = v7;
  if ((v5 & 0x80) != 0)
  {
    TIFFSwabLong((__int32 *)&v9, a4);
    v7 = v9;
  }
  result = TIFFReadDirEntryData(a1, v7, 8, __dst);
  if (!(_DWORD)result)
  {
    if ((*(_DWORD *)(a1 + 16) & 0x80) == 0)
      return 0;
    goto LABEL_8;
  }
  return result;
}

void BCTextureImp::~BCTextureImp(BCTextureImp *this, uint64_t a2, const char *a3)
{
  IIOImageRead **Source;
  const void *v5;

  *(_QWORD *)this = &off_1E1BAC170;
  if (*((_QWORD *)this + 3))
  {
    Source = (IIOImageRead **)CGImageSourceGetSource(*((_QWORD *)this + 4));
    if (Source)
      IIOImageReadSession::releaseBytePointer(Source, *((void **)this + 3));
  }
  v5 = (const void *)*((_QWORD *)this + 4);
  if (v5)
    CFRelease(v5);
  *((_QWORD *)this + 4) = 0;
  _cg_jpeg_mem_term(this, a2, a3);
}

{
  BCTextureImp::~BCTextureImp(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

uint64_t BCTextureImp::loadDataFromXPCObject(BCTextureImp *this, xpc_object_t xdict)
{
  const void *data;
  size_t length;

  length = 0;
  data = xpc_dictionary_get_data(xdict, "iio_xpc_plugin_data_bc_imp", &length);
  if (length == 544)
  {
    memcpy((char *)this + 16, data, 0x220uLL);
    *((_QWORD *)this + 3) = 0;
    *((_QWORD *)this + 4) = 0;
    *((_QWORD *)this + 2) = 0;
  }
  return 0;
}

uint64_t BCTextureImp::saveDataToXPCObject(BCTextureImp *this, void *a2)
{
  iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_bc_imp", (char *)this + 16, 0x220uLL);
  return 0;
}

uint64_t BCTextureImp::textureDataLockData(BCTextureImp *this, IIOImageReadSession *a2, unint64_t a3, unint64_t a4, IIOImageRead **a5, unint64_t *a6, unint64_t *a7)
{
  const void *v13;
  uint64_t result;
  char *v15;

  if (!*((_QWORD *)this + 2))
  {
    *((_QWORD *)this + 2) = IIOImageReadSession::retainBytePointer(a2, (const __CFData **)this + 3, 1);
    v13 = (const void *)IIOImageSource::cf(a2);
    *((_QWORD *)this + 4) = v13;
    CFRetain(v13);
    if (!*((_QWORD *)this + 2))
      _cg_jpeg_mem_term("textureDataLockData", 140, "*** Can't access image data\n");
  }
  if (a3 >= 0x1F)
    a3 = 31;
  *a5 = IIOImageReadSession::getSize(a2);
  result = *((_QWORD *)this + 2);
  v15 = (char *)this + 8 * a3 + 16;
  *a6 = *((_QWORD *)v15 + 4);
  *a7 = *((_QWORD *)v15 + 36);
  return result;
}

uint64_t BCReadPlugin::BCReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  __int128 v13;

  v6 = (_QWORD *)IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *v6 = &off_1E1BAC050;
  v7 = (uint64_t)(v6 + 62);
  v6[62] = 0;
  v6[63] = 0;
  v8 = operator new(0x248uLL);
  v8[1] = 0;
  v8[2] = 0;
  *v8 = &off_1E1BBC228;
  *((_DWORD *)v8 + 8) = *(_DWORD *)(a1 + 208);
  v8[3] = &off_1E1BAC170;
  bzero(v8 + 5, 0x220uLL);
  *(_QWORD *)&v13 = v8 + 3;
  *((_QWORD *)&v13 + 1) = v8;
  std::shared_ptr<IIOTextureDataImp>::operator=[abi:ne180100]<BCTextureImp,void>(v7, &v13);
  v9 = (std::__shared_weak_count *)*((_QWORD *)&v13 + 1);
  if (*((_QWORD *)&v13 + 1))
  {
    v10 = (unint64_t *)(*((_QWORD *)&v13 + 1) + 8);
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  *(_QWORD *)(a1 + 488) = 0;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  return a1;
}

void sub_187F9E860(_Unwind_Exception *a1)
{
  IIOReadPlugin *v1;
  uint64_t v2;

  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100](v2);
  IIOReadPlugin::~IIOReadPlugin(v1);
  _Unwind_Resume(a1);
}

uint64_t std::shared_ptr<IIOTextureDataImp>::operator=[abi:ne180100]<BCTextureImp,void>(uint64_t a1, __int128 *a2)
{
  __int128 v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;

  v3 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v4 = *(std::__shared_weak_count **)(a1 + 8);
  *(_OWORD *)a1 = v3;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return a1;
}

uint64_t BCReadPlugin::BCReadPlugin(uint64_t a1, uint64_t a2, int a3)
{
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  __int128 v11;

  v4 = (_QWORD *)IIOReadPlugin::IIOReadPlugin(a1, a2, a3);
  *v4 = &off_1E1BAC050;
  v5 = (uint64_t)(v4 + 62);
  v4[62] = 0;
  v4[63] = 0;
  v6 = operator new(0x248uLL);
  v6[1] = 0;
  v6[2] = 0;
  *v6 = &off_1E1BBC228;
  *((_DWORD *)v6 + 8) = *(_DWORD *)(a1 + 208);
  v6[3] = &off_1E1BAC170;
  bzero(v6 + 5, 0x220uLL);
  *(_QWORD *)&v11 = v6 + 3;
  *((_QWORD *)&v11 + 1) = v6;
  std::shared_ptr<IIOTextureDataImp>::operator=[abi:ne180100]<BCTextureImp,void>(v5, &v11);
  v7 = (std::__shared_weak_count *)*((_QWORD *)&v11 + 1);
  if (*((_QWORD *)&v11 + 1))
  {
    v8 = (unint64_t *)(*((_QWORD *)&v11 + 1) + 8);
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  *(_QWORD *)(a1 + 488) = 0;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  return a1;
}

void sub_187F9E9C8(_Unwind_Exception *a1)
{
  IIOReadPlugin *v1;
  uint64_t v2;

  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100](v2);
  IIOReadPlugin::~IIOReadPlugin(v1);
  _Unwind_Resume(a1);
}

void BCReadPlugin::~BCReadPlugin(BCReadPlugin *this)
{
  const void *v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E1BAC050;
  v2 = (const void *)*((_QWORD *)this + 61);
  if (v2)
    CFRelease(v2);
  v3 = *((_QWORD *)this + 59);
  if (v3)
    (**(void (***)(void))(v3 + 8))();
  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100]((uint64_t)this + 496);
  IIOReadPlugin::~IIOReadPlugin(this);
}

{
  BCReadPlugin::~BCReadPlugin(this);
  JUMPOUT(0x18D761C30);
}

uint64_t BCReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v2;

  v2 = *(__int16 *)(a1 + 376);
  if (v2 == 13)
    return IIOReadPlugin::setupImageProviderCallbackV3(a1, a2, (uint64_t)IIO_Reader::CopyImageBlockSetProc, 0, 0, (uint64_t)IIO_Reader::CopyImageTextureDataProc);
  if (v2 == 1)
    return IIOReadPlugin::setupCallback(a1, a2);
  return 4294967246;
}

uint64_t BCReadPlugin::loadDataFromXPCObject(BCReadPlugin *this, void *a2)
{
  uint64_t result;
  __int128 *data;
  __int128 v6;
  __int128 v7;
  size_t length;

  result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!(_DWORD)result)
  {
    length = 0;
    data = (__int128 *)xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_bc", &length);
    if (length == 48)
    {
      v6 = *data;
      v7 = data[2];
      *(_OWORD *)((char *)this + 456) = data[1];
      *(_OWORD *)((char *)this + 472) = v7;
      *(_OWORD *)((char *)this + 440) = v6;
      *((_QWORD *)this + 59) = 0;
      return (*(uint64_t (**)(_QWORD, void *))(**((_QWORD **)this + 62) + 16))(*((_QWORD *)this + 62), a2);
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t BCReadPlugin::saveDataToXPCObject(BCReadPlugin *this, void *a2)
{
  uint64_t result;

  result = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!(_DWORD)result)
  {
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_bc", (char *)this + 440, 0x30uLL);
    return (*(uint64_t (**)(_QWORD, void *))(**((_QWORD **)this + 62) + 24))(*((_QWORD *)this + 62), a2);
  }
  return result;
}

uint64_t BCReadPlugin::initialize(BCReadPlugin *this, IIODictionary *a2)
{
  uint64_t v3;
  int v4;
  IIOImageRead *v5;
  unint64_t v6;
  double v7;
  __int32 v8;
  int v9;
  const char *v10;
  unsigned int v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  unsigned __int32 v15;
  int v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  __int32 v21;
  IIOImageRead *Size;
  unsigned int v23;
  unint64_t v24;
  int v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unsigned int v33;
  int v34;
  char v35;
  __int16 v36;
  __int16 v37;
  char v38;
  CFStringRef *v39;
  char v40;
  uint64_t v41;
  unsigned int v42;
  unsigned int v43;
  int v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  unsigned int v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unsigned int v52;
  unsigned int v53;
  uint64_t v54;
  unsigned int v55;
  unsigned int v56;
  unint64_t v57;
  uint64_t v58;
  BOOL v59;
  double v60;
  int v61;
  unsigned int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  uint64_t v68;
  int v69;
  uint64_t v70;
  IIOImageRead *v71;
  uint64_t v72;
  int32x2_t v74;
  uint64_t v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  uint64_t v80;
  int __dst;
  unsigned int v82[4];
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  int8x16_t v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  _QWORD v93[6];

  v93[5] = *MEMORY[0x1E0C80C00];
  __dst = 0;
  v80 = 0;
  v78 = 0u;
  v79 = 0u;
  v76 = 0u;
  v77 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v76, *((IIOImageReadSession **)this + 3));
  if (!*((_BYTE *)this + 341))
    goto LABEL_198;
  v3 = *((_QWORD *)this + 62);
  v4 = *((_DWORD *)this + 51);
  switch(v4)
  {
    case 1262633838:
      v89 = 0u;
      v90 = 0u;
      v87 = 0u;
      v88 = 0u;
      if (IIOScanner::getBytesAtOffset((IIOScanner *)&v76, &v87, *((_QWORD *)this + 24), 0x40uLL) == 64)
      {
        SwapKTXHeader(&v87);
        v21 = v87.i32[3];
        *((_DWORD *)this + 113) = HIDWORD(v88);
        *((_BYTE *)this + 344) = v21 == 67305985;
        v74 = *(int32x2_t *)((char *)&v89 + 4);
        Size = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
        LODWORD(v14) = v74.i32[0];
        if ((unint64_t)Size <= v74.u32[0])
        {
          v70 = 557;
        }
        else
        {
          LODWORD(v20) = v74.i32[1];
          if ((unint64_t)Size > v74.u32[1])
          {
            *((uint32x2_t *)this + 57) = vshr_n_u32((uint32x2_t)vadd_s32(v74, (int32x2_t)0x300000003), 2uLL);
            v23 = DWORD2(v90);
            v24 = HIDWORD(v90) + 64;
            *((_QWORD *)this + 24) = v24;
            if (v23 >= 0x1F)
              v25 = 31;
            else
              v25 = v23;
            *((_DWORD *)this + 112) = v25;
            if (v25)
            {
              v26 = 0;
              v27 = v77;
              v28 = v24;
              while (1)
              {
                *(_QWORD *)v82 = 0;
                if (IIOScanner::getBytesAtOffset((IIOScanner *)&v76, v82, v28, 8uLL) != 8)
                  break;
                v29 = v28 + 4;
                v30 = v27 - (v28 + 4);
                if (v27 <= v28 + 4)
                {
                  *((_DWORD *)this + 112) = v26;
                  goto LABEL_58;
                }
                if (*(_QWORD *)v82 < v30)
                  v30 = *(_QWORD *)v82;
                if (v26 <= 0x1F)
                {
                  v31 = v3 + 8 * v26;
                  *(_QWORD *)(v31 + 48) = v29;
                  *(_QWORD *)(v31 + 304) = v30;
                }
                v24 = v30 + v29;
                v28 = ((v30 + 3) & 0xFFFFFFFFFFFFFFFCLL) + v29;
                if (++v26 >= *((unsigned int *)this + 112))
                  goto LABEL_58;
              }
              _cg_jpeg_mem_term("initialize", 576, "*** BC - failed to read %d bytes\n", 8);
              goto LABEL_198;
            }
LABEL_58:
            v32 = *((unsigned int *)this + 115) * (unint64_t)*((unsigned int *)this + 114);
            v33 = BCReadPlugin::bytesPerBlock((BCReadPlugin *)*((unsigned int *)this + 113));
            if (!is_mul_ok(v32, v33))
            {
              _cg_jpeg_mem_term("initialize", 606, "*** ERROR: BC-image too big\n");
              goto LABEL_198;
            }
            if (*(_QWORD *)(v3 + 304) < v32 * v33)
            {
              _cg_jpeg_mem_term("initialize", 608, "*** ERROR: BC-levelSize too small\n");
              goto LABEL_198;
            }
            if (v24 > (unint64_t)IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3)))
            {
              v71 = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
              _cg_jpeg_mem_term("initialize", 609, "***ERROR: BC (KTX) file truncated. File Size: %lu, expected %lu\n", v71, v24);
              goto LABEL_198;
            }
            *((_QWORD *)this + 55) = *(_QWORD *)(v3 + 304);
            *((_QWORD *)this + 24) += 4;
            goto LABEL_62;
          }
          v70 = 558;
        }
        _cg_jpeg_mem_term("initialize", v70, "*** bad dimension: %d x %d  (fileSize: %d)\n", v74.i32[0], v74.i32[1], (_DWORD)Size);
      }
LABEL_198:
      kdebug_trace();
      v41 = 4294967246;
      goto LABEL_199;
    case 1261584963:
      v85 = 0u;
      v86 = 0u;
      v83 = 0u;
      v84 = 0u;
      *(_OWORD *)v82 = 0u;
      if (IIOScanner::getBytesAtOffset((IIOScanner *)&v76, v82, *((_QWORD *)this + 24), 0x50uLL) != 80
        || !IsKTX2Header(v82))
      {
        goto LABEL_198;
      }
      if ((_DWORD)v83 != 1)
      {
        _cg_jpeg_mem_term("initialize", 630, "*** ERROR: Invalid typeSize (%d). typeSize must be 1 for block-compressed or supercompressed formats.");
        goto LABEL_198;
      }
      if ((unint64_t)v77 <= v84)
      {
        _cg_jpeg_mem_term("initialize", 631, "*** ERROR: Invalid numberOfArrayElements (%d).");
        goto LABEL_198;
      }
      if ((unint64_t)v77 <= v85)
      {
        _cg_jpeg_mem_term("initialize", 632, "*** ERROR: Invalid dfdOffset (%d).");
        goto LABEL_198;
      }
      if ((unint64_t)v77 <= DWORD1(v85))
      {
        _cg_jpeg_mem_term("initialize", 633, "*** ERROR: Invalid dfdLength (%d).");
        goto LABEL_198;
      }
      if ((unint64_t)v77 <= DWORD2(v85))
      {
        _cg_jpeg_mem_term("initialize", 634, "*** ERROR: Invalid kvdOffset (%d).");
        goto LABEL_198;
      }
      if ((unint64_t)v77 <= HIDWORD(v85))
      {
        _cg_jpeg_mem_term("initialize", 635, "*** ERROR: Invalid kvdLength (%d).");
        goto LABEL_198;
      }
      if ((unint64_t)v86 >= (unint64_t)v77)
      {
        _cg_jpeg_mem_term("initialize", 636, "*** ERROR: Invalid scgdOffset (%d).");
        goto LABEL_198;
      }
      if (*((_QWORD *)&v86 + 1) >= (unint64_t)v77)
      {
        _cg_jpeg_mem_term("initialize", 637, "*** ERROR: Invalid scgdLength (%d).");
        goto LABEL_198;
      }
      v93[0] = 0;
      v91 = 0u;
      v92 = 0u;
      v89 = 0u;
      v90 = 0u;
      v87 = 0u;
      v88 = 0u;
      v75 = 0;
      if (!CreateKtxStream((uint64_t)&v87, *((IIOImageReadSession **)this + 3)))
      {
        v16 = ktxTexture2_CreateFromStream(&v87, 0, &v75);
        if (v16)
        {
          _cg_jpeg_mem_term("initialize", 646, "*** ERROR: ktxTexture2_CreateFromStream failed [%d]\n", v16);
          goto LABEL_198;
        }
        *((_QWORD *)this + 59) = v75;
        v17 = v82[3];
        *((_DWORD *)this + 120) = v82[3];
        *((_DWORD *)this + 113) = GLFormatForVulkanFormat(v17);
        *((_BYTE *)this + 344) = 0;
        v18 = *(_QWORD *)((char *)&v83 + 4);
        *((uint32x2_t *)this + 57) = vshr_n_u32((uint32x2_t)vadd_s32(*(int32x2_t *)((char *)&v83 + 4), (int32x2_t)0x300000003), 2uLL);
        v19 = DWORD2(v84);
        if (DWORD2(v84) >= 0x1F)
          v19 = 31;
        *((_DWORD *)this + 112) = v19;
        *((_QWORD *)this + 55) = *(_QWORD *)(v3 + 304);
        LODWORD(v20) = HIDWORD(v18);
        LODWORD(v14) = v18;
        goto LABEL_62;
      }
      goto LABEL_198;
    case 1145193326:
      v92 = 0u;
      memset(v93, 0, 28);
      v90 = 0u;
      v91 = 0u;
      v88 = 0u;
      v89 = 0u;
      v87 = 0u;
      memset(v82, 0, sizeof(v82));
      LODWORD(v83) = 0;
      if (IIOScanner::getBytesAtOffset((IIOScanner *)&v76, &__dst, *((_QWORD *)this + 24), 4uLL) != 4)
        goto LABEL_198;
      v5 = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
      if (__dst != 542327876)
        goto LABEL_198;
      v6 = (unint64_t)v5;
      *((_QWORD *)this + 24) = 4;
      if (IIOScanner::getBytesAtOffset((IIOScanner *)&v76, &v87, 4, 0x7CuLL) != 124)
        goto LABEL_198;
      v8 = v87.i32[1];
      if ((v87.i8[4] & 1) != 0)
      {
        v9 = v87.i8[4] & 6;
        v10 = "*** ERROR: ddsHeader.dwFlags is missing 'has_DDSD_WIDTH'\n";
        if ((v87.i8[4] & 2) != 0)
          v11 = 362;
        else
          v11 = 361;
        if ((v87.i8[4] & 2) == 0)
          v10 = "*** ERROR: ddsHeader.dwFlags is missing 'DDSD_HEIGHT'\n";
        if (v9 == 6)
          v12 = 363;
        else
          v12 = v11;
        if (v9 == 6)
          v13 = "*** ERROR: ddsHeader.dwFlags is missing 'DDSD_PIXELFORMAT'\n";
        else
          v13 = v10;
        if ((~v87.i32[1] & 0x1006) == 0)
        {
          *((_QWORD *)this + 24) += 124;
          *((_BYTE *)this + 344) = 0;
          v14 = v87.u32[3];
          if ((v8 & 8) != 0)
          {
            v15 = v88;
          }
          else if ((v87.i32[3] + 3) >= 4)
          {
            v15 = (v87.i32[3] + 3) & 0xFFFFFFFC;
          }
          else
          {
            v15 = 4;
          }
          v20 = v87.u32[2];
          if (v6 <= v87.u32[3])
          {
            v72 = 375;
          }
          else
          {
            if (v6 > v87.u32[2])
            {
              if (v6 <= v15)
              {
                _cg_jpeg_mem_term("initialize", 377, "*** ERROR: bad pitchOrLinearSize: %d  (fileSize: %ld)\n", v15, v6);
                goto LABEL_198;
              }
              *((_DWORD *)this + 114) = (v87.i32[3] + 3) >> 2;
              *((_DWORD *)this + 115) = (v20 + 3) >> 2;
              if ((v8 & 0x20000) != 0)
              {
                v42 = DWORD2(v88);
                if (DWORD2(v88))
                {
                  v43 = v14 <= v20 ? v20 : v14;
                  v7 = log((double)v43) / 0.693147181;
                  if (v42 > v7)
                    *(_QWORD *)&v7 = _cg_jpeg_mem_term("initialize", 386, "*** ERROR: bad dwMipMapCount (%d) max: %d\n", v42, v7).n128_u64[0];
                }
              }
              v44 = bswap32(v92);
              if (v44)
              {
                if (v44 == 1146630448)
                {
                  if (IIOScanner::getBytesAtOffset((IIOScanner *)&v76, v82, *((_QWORD *)this + 24), 0x14uLL) != 20)
                    goto LABEL_198;
                  *((_QWORD *)this + 24) += 20;
                  v47 = dxgi_to_gl(v82[0]);
                  goto LABEL_101;
                }
                if (v44 == 1146639409)
                {
                  v45 = (2 * v14 + 6) & 0x3FFFFFFF8;
                  if (!(_DWORD)v14)
                    v45 = 8;
                  v46 = v45 * v20;
                  if (v6 <= v46 >> 2)
                  {
                    _cg_jpeg_mem_term("initialize", 407, "*** ERROR: corrupt file:  pitch*height: %ld  (fileSize: %ld)\n", v46, v6);
                    goto LABEL_198;
                  }
                }
LABEL_100:
                v47 = fourcc_to_gl(v44);
LABEL_101:
                *((_DWORD *)this + 113) = v47;
                if (!(_DWORD)v47)
                  goto LABEL_198;
LABEL_102:
                v48 = DWORD2(v88);
                if (DWORD2(v88) >= 0x1F)
                  v48 = 31;
                if ((v8 & 0x20000) == 0)
                  v48 = 1;
                *((_DWORD *)this + 112) = v48;
                if (v48 <= 1)
                  v49 = 1;
                else
                  v49 = v48;
                v50 = *((_QWORD *)this + 24);
                v51 = 0;
                v52 = BCReadPlugin::bytesPerBlock((BCReadPlugin *)v47);
                while (1)
                {
                  v53 = (v14 >> v51) + 3;
                  if (v53 <= 7)
                    v54 = 1;
                  else
                    v54 = v53 >> 2;
                  v55 = (v20 >> v51) + 3;
                  if (v55 <= 7)
                    v56 = 1;
                  else
                    v56 = v55 >> 2;
                  v57 = v52 * (unint64_t)v56 * v54;
                  if (v51 <= 0x1F)
                  {
                    v58 = v3 + 8 * v51;
                    *(_QWORD *)(v58 + 48) = v50;
                    *(_QWORD *)(v58 + 304) = v57;
                  }
                  v59 = __CFADD__(v50, v57);
                  v50 += v57;
                  if (v59)
                    goto LABEL_198;
                  if (v50 > (unint64_t)IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3)))
                  {
                    *(_QWORD *)&v60 = _cg_jpeg_mem_term("initialize", 528, "*** WARNING: file truncated. Only the first %lu miplevels of %lu complete\n", v51, *((unsigned int *)this + 112)).n128_u64[0];
                    *((_DWORD *)this + 112) = v51;
                    if ((_DWORD)v51)
                    {
LABEL_123:
                      *((_QWORD *)this + 55) = *(_QWORD *)(v3 + 304);
                      goto LABEL_62;
                    }
                    _cg_jpeg_mem_term("initialize", 533, "*** ERROR: file to small to contain a single image / miplevel\n", v60);
                    goto LABEL_198;
                  }
                  if (v49 == ++v51)
                    goto LABEL_123;
                }
              }
              if ((BYTE12(v91) & 0x40) == 0)
                goto LABEL_100;
              *((_DWORD *)this + 113) = 34952;
              v61 = DWORD1(v92);
              v62 = DWORD2(v92);
              *((_DWORD *)this + 121) = DWORD1(v92);
              v63 = bswap32(v62);
              v64 = bswap32(HIDWORD(v92));
              *((_QWORD *)&v92 + 1) = __PAIR64__(v64, v63);
              v65 = bswap32(v93[0]);
              v66 = bswap32(HIDWORD(v93[0]));
              v93[0] = __PAIR64__(v66, v65);
              if ((v64 & v63) != 0)
              {
                _cg_jpeg_mem_term("initialize", 433, "*** overlapping R-G channels\n", v7);
                goto LABEL_198;
              }
              if ((v65 & v63) != 0)
              {
                _cg_jpeg_mem_term("initialize", 434, "*** overlapping R-B channels\n", v7);
                goto LABEL_198;
              }
              if ((v65 & v64) != 0)
              {
                _cg_jpeg_mem_term("initialize", 435, "*** overlapping G-B channels\n", v7);
                goto LABEL_198;
              }
              if ((v66 & v63) != 0)
              {
                _cg_jpeg_mem_term("initialize", 437, "*** overlapping R-A channels\n", v7);
                goto LABEL_198;
              }
              if ((v66 & v64) != 0)
              {
                _cg_jpeg_mem_term("initialize", 438, "*** overlapping G-A channels\n", v7);
                goto LABEL_198;
              }
              if ((v66 & v65) != 0)
              {
                _cg_jpeg_mem_term("initialize", 439, "*** overlapping B-A channels\n", v7);
                goto LABEL_198;
              }
              v67 = v64 | v63 | v65 | v66;
              if (v61 == 24)
              {
                if (v67 != -256)
                {
                  v68 = 443;
LABEL_201:
                  _cg_jpeg_mem_term("initialize", v68, "*** overlapping RGBA channels?  bitMask: %08X\n", v64 | v63 | v65 | v66);
                  goto LABEL_198;
                }
              }
              else if (v67 != -1)
              {
                v68 = 445;
                goto LABEL_201;
              }
              if (v63 > 65279)
              {
                if (v63 == 65280)
                {
                  v69 = 0x2000000;
                }
                else
                {
                  if (v63 != 16711680)
                    goto LABEL_198;
                  v69 = 0x1000000;
                }
              }
              else if (v63 == -16777216)
              {
                v69 = 0;
              }
              else
              {
                if (v63 != 255)
                  goto LABEL_198;
                v69 = 50331648;
              }
              if (v64 > 65279)
              {
                if (v64 == 65280)
                {
                  v69 |= 0x20000u;
                }
                else
                {
                  if (v64 != 16711680)
                    goto LABEL_198;
                  v69 |= 0x10000u;
                }
              }
              else if (v64 != -16777216)
              {
                if (v64 != 255)
                  goto LABEL_198;
                v69 |= 0x30000u;
              }
              if (v65 > 65279)
              {
                if (v65 == 65280)
                {
                  v69 |= 0x200u;
                }
                else
                {
                  if (v65 != 16711680)
                    goto LABEL_198;
                  v69 |= 0x100u;
                }
              }
              else if (v65 != -16777216)
              {
                if (v65 != 255)
                  goto LABEL_198;
                v69 |= 0x300u;
              }
              if (v66 <= 254)
              {
                if (v66 == -16777216)
                {
LABEL_169:
                  *((_DWORD *)this + 116) = v69;
                  v47 = 34952;
                  goto LABEL_102;
                }
                if (v66)
                  goto LABEL_198;
              }
              else if (v66 != 255)
              {
                if (v66 == 65280)
                {
                  v69 |= 2u;
                }
                else
                {
                  if (v66 != 16711680)
                    goto LABEL_198;
                  v69 |= 1u;
                }
                goto LABEL_169;
              }
              v69 |= 3u;
              goto LABEL_169;
            }
            v72 = 376;
          }
          _cg_jpeg_mem_term("initialize", v72, "*** ERROR: bad dimension: %d x %d  (fileSize: %ld)\n", v87.i32[3], v87.i32[2], v6);
          goto LABEL_198;
        }
      }
      else
      {
        v13 = "*** ERROR: ddsHeader.dwFlags is missing 'DDSD_CAPS'\n";
        v12 = 360;
      }
      _cg_jpeg_mem_term("initialize", v12, v13);
      goto LABEL_198;
  }
  LODWORD(v14) = 0;
  LODWORD(v20) = 0;
LABEL_62:
  *((_DWORD *)this + 57) = v14;
  *((_DWORD *)this + 58) = v20;
  *(int32x2_t *)((char *)this + 292) = vshl_n_s32(*(int32x2_t *)((char *)this + 456), 2uLL);
  v34 = *((_DWORD *)this + 113);
  v35 = 2;
  v36 = 8;
  v37 = 32;
  if (v34 <= 36493)
  {
    if (v34 == 36283)
    {
      *((_DWORD *)this + 81) = 1196573017;
      *((_DWORD *)this + 60) = 524296;
      *((_WORD *)this + 122) = 1;
      *((_BYTE *)this + 247) = 2;
      if (*((_DWORD *)this + 121) == 24)
        v40 = 5;
      else
        v40 = 3;
      *((_BYTE *)this + 246) = v40;
    }
    else
    {
      if (v34 != 36284)
      {
        v38 = 2;
        if (v34 != 36286)
          goto LABEL_69;
        goto LABEL_68;
      }
      *((_BYTE *)this + 345) = 1;
      *((_DWORD *)this + 81) = 1196573017;
      *((_QWORD *)this + 30) = 0x100000100100010;
      LODWORD(v14) = 2 * v14;
    }
    v39 = (CFStringRef *)MEMORY[0x1E0C9D978];
    goto LABEL_76;
  }
  v38 = 2;
  if ((v34 - 36494) < 2)
  {
LABEL_68:
    v35 = 1;
    *((_BYTE *)this + 345) = 1;
    v38 = 3;
    v36 = 16;
    v37 = 64;
  }
LABEL_69:
  *((_DWORD *)this + 81) = 1380401696;
  *((_WORD *)this + 121) = v37;
  *((_WORD *)this + 120) = v36;
  *((_WORD *)this + 122) = 4;
  *((_BYTE *)this + 247) = v35;
  *((_BYTE *)this + 246) = 3;
  LODWORD(v14) = (_DWORD)v14 << v38;
  v39 = (CFStringRef *)MEMORY[0x1E0C9DA10];
LABEL_76:
  *((_DWORD *)this + 59) = v14;
  *((_QWORD *)this + 20) = CGColorSpaceCreateWithName(*v39);
  *((_BYTE *)this + 346) = 0;
  getenv("IIO_useV3");
  *((_WORD *)this + 188) = 1;
  if (*((_BYTE *)this + 177))
    ImageIOLog("    BC:\n");
  v41 = 0;
LABEL_199:
  IIOScanner::~IIOScanner((IIOScanner *)&v76);
  return v41;
}

void sub_187F9F81C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  IIOScanner::~IIOScanner((IIOScanner *)va);
  _Unwind_Resume(a1);
}

uint64_t dxgi_to_gl(int a1)
{
  if ((a1 - 71) > 0x1C)
    return 0;
  else
    return dword_18820F704[a1 - 71];
}

uint64_t fourcc_to_gl(int a1)
{
  if (a1 > 1111700818)
  {
    if (a1 > 1146639410)
    {
      if (a1 == 1146639413)
        return 33779;
      if (a1 == 1146639411)
        return 33778;
    }
    else
    {
      if (a1 == 1111700819)
        return 36286;
      if (a1 == 1146639409)
        return 33777;
    }
    return 0;
  }
  if (a1 == 1096042802)
    return 36285;
  if (a1 != 1111700563)
  {
    if (a1 == 1111700565)
      return 36283;
    return 0;
  }
  return 36284;
}

uint64_t BCReadPlugin::bytesPerBlock(BCReadPlugin *this)
{
  if (((_DWORD)this - 33776) >= 2
    && ((_DWORD)this - 35916) >= 2
    && ((_DWORD)this - 36283) >= 2)
  {
    return 16;
  }
  else
  {
    return 8;
  }
}

uint64_t GLFormatForVulkanFormat(int a1)
{
  if ((a1 - 131) > 0xF)
    return 0;
  else
    return dword_18820F778[a1 - 131];
}

uint64_t BCReadPlugin::decode8888toRGBX(BCReadPlugin *this, IIOImageReadSession *a2, vImage_Buffer *a3, CGImageAlphaInfo a4, _BOOL4 a5)
{
  uint64_t v8;
  unsigned int v9;
  char v10;
  char v11;
  uint64_t v12;
  unint64_t v13;
  size_t v14;
  _BYTE *v15;
  __int128 v16;
  uint64_t v17;
  unsigned int v18;
  BOOL v19;
  uint64_t v20;
  unint64_t v21;
  vImage_Buffer v23;
  vImage_Buffer v24;
  uint8_t permuteMap[4];

  v8 = *((_QWORD *)this + 62);
  v9 = *((_DWORD *)this + 116);
  if (a5)
    v10 = 8;
  else
    v10 = 24;
  if (a5)
    v11 = 24;
  else
    v11 = 8;
  permuteMap[0] = v9 >> v10;
  permuteMap[1] = BYTE2(v9);
  permuteMap[2] = v9 >> v11;
  permuteMap[3] = v9;
  v12 = *((unsigned int *)this + 52);
  if (v12 > 0x1F)
    v13 = 0;
  else
    v13 = *(_QWORD *)(v8 + 8 * v12 + 48);
  if (*((_DWORD *)this + 121) != 24)
  {
    v21 = a3->height * a3->rowBytes;
    if (IIOImageReadSession::getBytesAtOffset(a2, a3->data, v13, v21) != v21)
      return 4294967246;
    vImagePermuteChannels_ARGB8888(a3, a3, permuteMap, 0x10u);
    if (a5)
      vImagePremultiplyData_RGBA8888(a3, a3, 0x10u);
    return 0;
  }
  v14 = 3 * a3->width;
  v15 = malloc_type_malloc(v14, 0xD967CBD0uLL);
  v24.data = v15;
  v24.height = 1;
  v24.rowBytes = v14;
  v16 = *(_OWORD *)&a3->width;
  v24.width = a3->width;
  *(_OWORD *)&v23.data = xmmword_18820C490;
  *(_OWORD *)&v23.width = v16;
  if (!a3->height)
  {
LABEL_15:
    v20 = 0;
    if (!v15)
      return v20;
LABEL_16:
    free(v15);
    return v20;
  }
  v17 = 0;
  v18 = 1;
  while (IIOImageReadSession::getBytesAtOffset(a2, v15, v13, v14) == v14)
  {
    v23.data = (char *)a3->data + a3->rowBytes * v17;
    vImageConvert_RGB888toRGBA8888(&v24, 0, 0xFFu, &v23, a5, 0x10u);
    v17 = v18;
    v19 = a3->height > v18++;
    v13 += v14;
    if (!v19)
      goto LABEL_15;
  }
  v20 = 4294967246;
  if (v15)
    goto LABEL_16;
  return v20;
}

uint64_t BCReadPlugin::decodeDXTCtoRGBX(BCReadPlugin *this, IIOImageReadSession *a2, vImage_Buffer *a3, int a4, int a5)
{
  at_alpha_t v8;
  int v9;
  int v10;
  at_block_format_t v11;
  at_texel_format_t v12;
  uint64_t v13;
  IIOImageRead *v14;
  uint64_t v15;
  uint64_t v16;
  size_t v17;
  uint64_t v18;
  _BYTE *v19;
  IIOImageRead *Size;
  uint64_t v21;
  IIOImageRead *v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t BytesAtOffset;
  void *v26;
  NSObject *v27;
  NSObject *v28;
  vImagePixelCount height;
  size_t rowBytes;
  unint64_t v31;
  unint64_t block_counts;
  unsigned int v33;
  unint64_t v34;
  at_block_features_t v35;
  at_block_features_t v36;
  unint64_t v37;
  unint64_t v38;
  at_error_t v39;
  size_t outSize;
  at_texel_region_t dest;
  at_block_buffer_t src;
  void *v44;
  at_size_t v45;
  at_size_t v46;

  if (a4 > 2)
    v8 = at_alpha_not_premultiplied;
  else
    v8 = dword_18820F7B8[a4];
  v9 = *((_DWORD *)this + 113);
  if (v9 > 36282)
  {
    if (v9 <= 36491)
    {
      v11 = at_block_format_bc4;
      v12 = at_texel_format_l8_unorm;
      switch(v9)
      {
        case 36283:
          goto LABEL_43;
        case 36284:
          v11 = at_block_format_bc4s;
          v12 = at_texel_format_l16_float;
          goto LABEL_43;
        case 36285:
          if (a5)
            v12 = at_texel_format_bgra8_unorm;
          else
            v12 = at_texel_format_rgba8_unorm;
          v11 = at_block_format_bc5;
          goto LABEL_43;
        case 36286:
          v11 = at_block_format_bc5s;
          goto LABEL_42;
        default:
          goto LABEL_76;
      }
    }
    if ((v9 - 36492) >= 2)
    {
      if (v9 == 36494)
      {
        v11 = at_block_format_bc6;
      }
      else
      {
        if (v9 != 36495)
          goto LABEL_76;
        v11 = at_block_format_bc6u;
      }
LABEL_42:
      v12 = at_texel_format_rgba16_float;
      goto LABEL_43;
    }
    if (a5)
      v12 = at_texel_format_bgra8_unorm;
    else
      v12 = at_texel_format_rgba8_unorm;
    v11 = at_block_format_bc7;
  }
  else
  {
    if (v9 > 35915)
    {
      if ((v9 - 35916) >= 2)
      {
        if (v9 != 35918)
        {
          v10 = 35919;
LABEL_15:
          if (v9 == v10)
          {
            if (a5)
              v12 = at_texel_format_bgra8_unorm;
            else
              v12 = at_texel_format_rgba8_unorm;
            v11 = at_block_format_bc3;
            goto LABEL_43;
          }
LABEL_76:
          _cg_jpeg_mem_term("decodeDXTCtoRGBX", 931, "*** BC - unknown GL pixel format\n");
          return 4294967246;
        }
        goto LABEL_28;
      }
    }
    else if ((v9 - 33776) >= 2)
    {
      if (v9 != 33778)
      {
        v10 = 33779;
        goto LABEL_15;
      }
LABEL_28:
      if (a5)
        v12 = at_texel_format_bgra8_unorm;
      else
        v12 = at_texel_format_rgba8_unorm;
      v11 = at_block_format_bc2;
      goto LABEL_43;
    }
    if (a5)
      v12 = at_texel_format_bgra8_unorm;
    else
      v12 = at_texel_format_rgba8_unorm;
    v11 = at_block_format_bc1;
  }
LABEL_43:
  v13 = *((_QWORD *)this + 62);
  v44 = 0;
  v14 = IIOImageReadSession::retainBytePointer(a2, (const __CFData **)&v44, 0);
  v15 = *((unsigned int *)this + 52);
  if (v15 > 0x1F)
  {
    if (!v14)
      goto LABEL_50;
    v17 = 0;
    v18 = 0;
  }
  else
  {
    if (!v14)
      goto LABEL_50;
    v16 = v13 + 8 * v15;
    v17 = *(_QWORD *)(v16 + 304);
    v18 = *(_QWORD *)(v16 + 48);
  }
  v19 = (char *)v14 + v18;
  if ((((unint64_t)v14 + v18) & 0xF) == 0)
  {
    v26 = 0;
    goto LABEL_61;
  }
  IIOImageReadSession::releaseBytePointer((IIOImageRead **)a2, v44);
  v44 = 0;
LABEL_50:
  Size = IIOImageReadSession::getSize(a2);
  v21 = *((unsigned int *)this + 52);
  if (v21 > 0x1F)
    v22 = 0;
  else
    v22 = *(IIOImageRead **)(v13 + 8 * v21 + 48);
  v17 = Size - v22;
  if (Size == v22)
    goto LABEL_59;
  v19 = malloc_type_malloc(Size - v22, 0x2AA7D59BuLL);
  v23 = *((unsigned int *)this + 52);
  if (v23 > 0x1F)
    v24 = 0;
  else
    v24 = *(_QWORD *)(v13 + 8 * v23 + 48);
  BytesAtOffset = IIOImageReadSession::getBytesAtOffset(a2, v19, v24, v17);
  if (v17 != BytesAtOffset)
  {
    _cg_jpeg_mem_term("decodeDXTCtoRGBX", 971, "got: %ld expected: %ld\n", BytesAtOffset, v17);
    v26 = v19;
    if (!v19)
      goto LABEL_73;
    goto LABEL_72;
  }
  v26 = v19;
  if (v19)
  {
LABEL_61:
    v27 = at_encoder_create(v12, v8, v11, v8, 0);
    if (v27)
    {
      v28 = v27;
      height = a3->height;
      dest.texels = a3->data;
      rowBytes = a3->rowBytes;
      dest.validSize.x = a3->width;
      dest.validSize.y = height;
      *((_DWORD *)&dest.validSize + 3) = 0;
      dest.rowBytes = rowBytes;
      dest.validSize.z = 1;
      dest.sliceBytes = 0;
      v31 = *(_QWORD *)&dest.validSize.x;
      *(_QWORD *)&v45.x = *(_QWORD *)&dest.validSize.x;
      v45.z = 1;
      block_counts = (unint64_t)at_encoder_get_block_counts(v27, v45);
      v33 = block_counts;
      v34 = HIDWORD(block_counts);
      src.blocks = v19;
      src.rowBytes = at_encoder_get_block_size(v28) * block_counts;
      src.sliceBytes = v34 * (unint64_t)v33 * at_encoder_get_block_size(v28);
      outSize = 0;
      *(_QWORD *)&v46.x = *(_QWORD *)&dest.validSize.x;
      v46.z = 1;
      v35.bits = at_block_get_features(v11, &src, v46, v17, &outSize, at_flags_default).bits;
      if (outSize > v17)
      {
        v36.bits = v35.bits;
        v37 = HIDWORD(v31);
        _cg_jpeg_mem_term("decodeDXTCtoRGBX", 1002, "*** expected size > file size (%d > %d)\n", outSize, v17);
        v38 = v17 / (v33 << (LODWORD(v36.bits) >> 5)) * ((v36.bits >> 22) & 0xFFF);
        if (v38 >= 0xFFFFFFFF)
          LODWORD(v38) = -1;
        if (v38 >= v37)
          LODWORD(v38) = v37;
        dest.validSize.y = v38;
      }
      v39 = at_encoder_decompress_texels(v28, &src, &dest, at_flags_default);
      if (v39)
        LogError("decodeDXTCtoRGBX", 1015, "at_encoder_decompress_texels returned: %ld\n", v39);
      CFRelease(v28);
    }
    if (!v26)
      goto LABEL_73;
LABEL_72:
    free(v26);
    goto LABEL_73;
  }
LABEL_59:
  _cg_jpeg_mem_term("decodeDXTCtoRGBX", 974, "*** tempLinearBuffer is nil\n");
LABEL_73:
  if (v44)
    IIOImageReadSession::releaseBytePointer((IIOImageRead **)a2, v44);
  return 0;
}

uint64_t BCReadPlugin::decodeDXTCtoRGBX(BCReadPlugin *this, void *a2, size_t a3, vImage_Buffer *a4, unsigned int a5, int a6)
{
  at_alpha_t v9;
  int v10;
  int v11;
  at_block_format_t v12;
  at_texel_format_t v13;
  NSObject *v14;
  NSObject *v15;
  vImagePixelCount height;
  size_t rowBytes;
  unsigned int v18;
  unint64_t block_counts;
  unsigned int v20;
  unint64_t v21;
  at_block_features_t v22;
  at_block_features_t v23;
  unint64_t v24;
  at_error_t v25;
  uint64_t v26;
  size_t outSize;
  at_texel_region_t dest;
  at_block_buffer_t src;
  at_size_t v31;
  at_size_t v32;

  if (a5 > 2)
    v9 = at_alpha_not_premultiplied;
  else
    v9 = dword_18820F7B8[a5];
  v10 = *((_DWORD *)this + 113);
  if (v10 > 36282)
  {
    if (v10 <= 36491)
    {
      v12 = at_block_format_bc4;
      v13 = at_texel_format_l8_unorm;
      switch(v10)
      {
        case 36283:
          goto LABEL_43;
        case 36284:
          v12 = at_block_format_bc4s;
          v13 = at_texel_format_l16_float;
          goto LABEL_43;
        case 36285:
          if (a6)
            v13 = at_texel_format_bgra8_unorm;
          else
            v13 = at_texel_format_rgba8_unorm;
          v12 = at_block_format_bc5;
          goto LABEL_43;
        case 36286:
          v12 = at_block_format_bc5s;
          goto LABEL_42;
        default:
          goto LABEL_54;
      }
    }
    if ((v10 - 36492) >= 2)
    {
      if (v10 == 36494)
      {
        v12 = at_block_format_bc6;
      }
      else
      {
        if (v10 != 36495)
          goto LABEL_54;
        v12 = at_block_format_bc6u;
      }
LABEL_42:
      v13 = at_texel_format_rgba16_float;
      goto LABEL_43;
    }
    if (a6)
      v13 = at_texel_format_bgra8_unorm;
    else
      v13 = at_texel_format_rgba8_unorm;
    v12 = at_block_format_bc7;
  }
  else
  {
    if (v10 > 35915)
    {
      if ((v10 - 35916) >= 2)
      {
        if (v10 != 35918)
        {
          v11 = 35919;
LABEL_15:
          if (v10 == v11)
          {
            if (a6)
              v13 = at_texel_format_bgra8_unorm;
            else
              v13 = at_texel_format_rgba8_unorm;
            v12 = at_block_format_bc3;
            goto LABEL_43;
          }
LABEL_54:
          _cg_jpeg_mem_term("decodeDXTCtoRGBX", 1094, "*** BC - unknown GL pixel format\n");
          return 4294967246;
        }
        goto LABEL_28;
      }
    }
    else if ((v10 - 33776) >= 2)
    {
      if (v10 != 33778)
      {
        v11 = 33779;
        goto LABEL_15;
      }
LABEL_28:
      if (a6)
        v13 = at_texel_format_bgra8_unorm;
      else
        v13 = at_texel_format_rgba8_unorm;
      v12 = at_block_format_bc2;
      goto LABEL_43;
    }
    if (a6)
      v13 = at_texel_format_bgra8_unorm;
    else
      v13 = at_texel_format_rgba8_unorm;
    v12 = at_block_format_bc1;
  }
LABEL_43:
  v14 = at_encoder_create(v13, v9, v12, v9, 0);
  if (!v14)
    return 4294967246;
  v15 = v14;
  height = a4->height;
  dest.texels = a4->data;
  rowBytes = a4->rowBytes;
  dest.validSize.x = a4->width;
  dest.validSize.y = height;
  *((_DWORD *)&dest.validSize + 3) = 0;
  dest.rowBytes = rowBytes;
  dest.validSize.z = 1;
  dest.sliceBytes = 0;
  v18 = height;
  *(_QWORD *)&v31.x = *(_QWORD *)&dest.validSize.x;
  v31.z = 1;
  block_counts = (unint64_t)at_encoder_get_block_counts(v14, v31);
  v20 = block_counts;
  v21 = HIDWORD(block_counts);
  src.blocks = a2;
  src.rowBytes = at_encoder_get_block_size(v15) * block_counts;
  src.sliceBytes = v21 * (unint64_t)v20 * at_encoder_get_block_size(v15);
  outSize = 0;
  *(_QWORD *)&v32.x = *(_QWORD *)&dest.validSize.x;
  v32.z = 1;
  v22.bits = at_block_get_features(v12, &src, v32, a3, &outSize, at_flags_default).bits;
  if (outSize > a3)
  {
    v23.bits = v22.bits;
    _cg_jpeg_mem_term("decodeDXTCtoRGBX", 1137, "*** expected size > file size (%d > %d)\n", outSize, a3);
    v24 = a3 / (v20 << (LODWORD(v23.bits) >> 5)) * ((v23.bits >> 22) & 0xFFF);
    if (v24 >= 0xFFFFFFFF)
      LODWORD(v24) = -1;
    if (v24 >= v18)
      LODWORD(v24) = v18;
    dest.validSize.y = v24;
  }
  v25 = at_encoder_decompress_texels(v15, &src, &dest, at_flags_default);
  if (v25)
  {
    LogError("decodeDXTCtoRGBX", 1150, "at_encoder_decompress_texels returned: %ld\n", v25);
    v26 = 4294967246;
  }
  else
  {
    v26 = 0;
  }
  CFRelease(v15);
  return v26;
}

uint64_t BCReadPlugin::decodeImageImp(uint64_t a1, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4)
{
  int v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  uint64_t BlockArray;
  uint64_t v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  unsigned int v17;
  int v18;
  uint64_t v19;
  int v20;
  IIOImageRead **v21;
  _BOOL4 v22;
  vImagePixelCount v23;
  vImagePixelCount v24;
  size_t v25;
  void *BaseAddress;
  size_t Height;
  CGImageAlphaInfo v28;
  double v29;
  double v30;
  unsigned int v31;
  unint64_t v32;
  unsigned int DataSize;
  _BOOL4 v34;
  uint64_t v35;
  void *v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  int8x16_t v40;
  IIOImageReadSession *v41;
  int v42;
  uint64_t v43;
  const char **v44;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  double v49;
  double v50;
  IOSurfaceRef *v51;
  size_t v52;
  vImage_Buffer dest;
  int v54;
  void *v55;
  uint64_t v56;
  size_t v57;
  size_t v58[2];
  CGRect v59;
  CGRect v60;

  v58[0] = 0;
  if (*(_BYTE *)(a1 + 410) == 1 && *(_QWORD *)(a1 + 392) != 16)
    return 4294967246;
  *(_QWORD *)(a1 + 392) = 16;
  *(_DWORD *)(a1 + 300) = ImageIOAlignRowBytes(*(unsigned int *)(a1 + 300), 0x10uLL);
  if ((gIIODebugFlags & 0x20000) != 0)
  {
    v8 = *(_DWORD *)(a1 + 204);
    v9 = v8 >> 24;
    v10 = MEMORY[0x1E0C80978];
    if (v8 < 0)
    {
      v11 = __maskrune(v9, 0x40000uLL);
      v8 = *(_DWORD *)(a1 + 204);
    }
    else
    {
      v11 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v9 + 60) & 0x40000;
    }
    if (v11)
      v13 = (v8 >> 24);
    else
      v13 = 46;
    v14 = v8 << 8 >> 24;
    if (v8 << 8 < 0)
    {
      v15 = __maskrune(v14, 0x40000uLL);
      v8 = *(_DWORD *)(a1 + 204);
    }
    else
    {
      v15 = *(_DWORD *)(v10 + 4 * v14 + 60) & 0x40000;
    }
    if (v15)
      v16 = (v8 << 8 >> 24);
    else
      v16 = 46;
    v17 = (__int16)v8 >> 8;
    if (v8 << 16 < 0)
    {
      v18 = __maskrune(v17, 0x40000uLL);
      v8 = *(_DWORD *)(a1 + 204);
    }
    else
    {
      v18 = *(_DWORD *)(v10 + 4 * v17 + 60) & 0x40000;
    }
    if (v18)
      v19 = ((__int16)v8 >> 8);
    else
      v19 = 46;
    if ((v8 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v10 + 4 * (char)v8 + 60) & 0x40000) != 0)
        goto LABEL_25;
    }
    else if (__maskrune((char)v8, 0x40000uLL))
    {
LABEL_25:
      v20 = *(_DWORD *)(a1 + 204);
LABEL_28:
      ImageIOLog("  '%c%c%c%c' [%s] %s\n", v13, v16, v19, (char)v20, iioTypeStr[a3], "virtual OSStatus BCReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      goto LABEL_29;
    }
    LOBYTE(v20) = 46;
    goto LABEL_28;
  }
LABEL_29:
  IIOReadPlugin::debugDecodeImage((IIOReadPlugin *)a1, a2);
  v21 = *(IIOImageRead ***)(a1 + 24);
  if (v21)
    v22 = IIOImageReadSession::mapData(v21);
  else
    v22 = 0;
  v23 = *(unsigned int *)(a1 + 292);
  v24 = *(unsigned int *)(a1 + 296);
  v25 = *(unsigned int *)(a1 + 300);
  if (a3 == 3)
  {
    BlockArray = IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, *(unsigned int *)(a1 + 104));
    v31 = *(_DWORD *)(a1 + 296);
    LODWORD(v32) = *(_DWORD *)(a1 + 292);
    v29 = (double)v31;
    v30 = (double)v32;
    v52 = *(unsigned int *)(a1 + 300) * (unint64_t)v31;
    BaseAddress = (void *)_ImageIO_Malloc(v52, *(_QWORD *)(a1 + 384), v58, (uint64_t)kImageMalloc_BC_Data[0], *(_DWORD *)(a1 + 432), 0, 0);
  }
  else
  {
    if (a3 != 1 || !a4 || !*a4)
    {
      BlockArray = 0;
      goto LABEL_68;
    }
    IOSurfaceLock(*a4, 0, 0);
    BaseAddress = IOSurfaceGetBaseAddress(*a4);
    Height = IOSurfaceGetHeight(*a4);
    BlockArray = 0;
    v52 = IOSurfaceGetBytesPerRow(*a4) * Height;
    v58[0] = v52;
    v29 = 0.0;
    v30 = 0.0;
  }
  if (BaseAddress)
  {
    if (*(_DWORD *)(a1 + 204) == 1261584963)
    {
      DataSize = Ktx2GetDataSize(*(_DWORD *)(a1 + 480), v23, v24);
      if (DataSize)
      {
        v51 = a4;
        v34 = v22;
        v35 = DataSize;
        v36 = malloc_type_calloc(DataSize, 1uLL, 0x601E9081uLL);
        v37 = v36;
        if (v36)
        {
          v54 = *(_DWORD *)(a1 + 208);
          v55 = v36;
          v56 = v35;
          v57 = 0;
          v38 = *(_QWORD *)(a1 + 472);
          if (v38)
          {
            v22 = v34;
            if (!(*(unsigned int (**)(void))(*(_QWORD *)(v38 + 8) + 40))())
            {
              dest.data = BaseAddress;
              dest.height = v24;
              dest.width = v23;
              dest.rowBytes = v25;
              if (*(_QWORD *)(a1 + 24))
                BlockArray = BCReadPlugin::decodeDXTCtoRGBX((BCReadPlugin *)a1, v55, v57, &dest, *(unsigned __int8 *)(a1 + 310), *(_BYTE *)(a1 + 405) == 0);
              a4 = v51;
              if (!(_DWORD)BlockArray)
                goto LABEL_48;
LABEL_63:
              *(_DWORD *)(a1 + 104) = 0;
              goto LABEL_64;
            }
          }
          else
          {
            LogFault("decodeImageImp", 1240, "*** _bc._ktxTexture is NULL\n");
            v22 = v34;
          }
          BlockArray = 4294967246;
          goto LABEL_64;
        }
        BlockArray = 4294967188;
        v22 = v34;
      }
      else
      {
        v37 = 0;
        BlockArray = 4294967229;
      }
LABEL_64:
      if (a3 == 3)
        _ImageIO_Free((unint64_t)BaseAddress, v58[0]);
      if (!v37)
        goto LABEL_68;
LABEL_67:
      free(v37);
      goto LABEL_68;
    }
    dest.data = BaseAddress;
    dest.height = v24;
    dest.width = v23;
    dest.rowBytes = v25;
    v41 = *(IIOImageReadSession **)(a1 + 24);
    if (v41)
    {
      v42 = *(unsigned __int8 *)(a1 + 405);
      if (*(_DWORD *)(a1 + 452) == 34952)
        v43 = BCReadPlugin::decode8888toRGBX((BCReadPlugin *)a1, v41, &dest, v28, v42 == 0);
      else
        v43 = BCReadPlugin::decodeDXTCtoRGBX((BCReadPlugin *)a1, v41, &dest, *(unsigned __int8 *)(a1 + 310), v42 == 0);
      BlockArray = v43;
    }
    v37 = 0;
    if (!(_DWORD)BlockArray)
    {
LABEL_48:
      if (*(_WORD *)(a1 + 306) == 32 && *(_WORD *)(a1 + 304) == 8 && *(_BYTE *)(a1 + 406) == 1)
      {
        dest.data = BaseAddress;
        v39 = *(_QWORD *)(a1 + 292);
        v40.i64[0] = v39;
        v40.i64[1] = HIDWORD(v39);
        *(int8x16_t *)&dest.height = vextq_s8(v40, v40, 8uLL);
        dest.rowBytes = *(unsigned int *)(a1 + 300);
        vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
      }
      if (a3 == 3)
      {
        v46 = 0;
        v59.origin.x = 0.0;
        v59.origin.y = 0.0;
        v59.size.width = v30;
        v59.size.height = v29;
        **(_QWORD **)(a1 + 96) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, BaseAddress, v52, v59, *(unsigned int *)(a1 + 300), *(unsigned __int8 *)(a1 + 343));
        if (CGRectEqualToRect(*(CGRect *)(a1 + 120), *MEMORY[0x1E0C9D628]))
        {
          v47 = 0;
        }
        else
        {
          v60.origin.x = 0.0;
          v60.origin.y = 0.0;
          v60.size.width = v30;
          v60.size.height = v29;
          *(CGRect *)(&v47 - 1) = CGRectUnion(*(CGRect *)(a1 + 120), v60);
          v46 = v48;
          v30 = v49;
          v29 = v50;
        }
        BlockArray = 0;
        *(_QWORD *)(a1 + 120) = v46;
        *(_QWORD *)(a1 + 128) = v47;
        *(double *)(a1 + 136) = v30;
        *(double *)(a1 + 144) = v29;
        if (!v37)
          goto LABEL_68;
      }
      else
      {
        IOSurfaceUnlock(*a4, 0, 0);
        BlockArray = 0;
        if (!v37)
          goto LABEL_68;
      }
      goto LABEL_67;
    }
    goto LABEL_63;
  }
LABEL_68:
  if (v22)
  {
    v44 = *(const char ***)(a1 + 24);
    if (v44)
      IIOImageReadSession::unmapData(v44);
  }
  return BlockArray;
}

uint64_t BCReadPlugin::copyImageTextureData(uint64_t a1)
{
  const void *v2;
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  const void *ColorSpace;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v19;
  std::__shared_weak_count *v20;
  _BYTE v21[24];
  _BYTE v22[24];
  _BYTE v23[24];
  _BYTE v24[24];
  _BYTE v25[24];
  _BYTE v26[24];
  _BYTE v27[24];
  _BYTE v28[24];
  _QWORD v29[3];
  __int128 v30;
  __int128 v31;

  v2 = *(const void **)(a1 + 488);
  if (v2)
    goto LABEL_52;
  v30 = xmmword_1E1BC1DC8;
  v31 = *(_OWORD *)off_1E1BC1DD8;
  v3 = IIOImageRead::imageCount(*(IIOImageRead **)(a1 + 32));
  memset(v29, 0, sizeof(v29));
  IIODictionary::IIODictionary((IIODictionary *)v29);
  IIONumber::IIONumber((IIONumber *)v28, *(_DWORD *)(a1 + 228));
  IIODictionary::setObjectForKey((uint64_t)v29, (uint64_t)v28, CFSTR("width"));
  IIONumber::~IIONumber((IIONumber *)v28);
  IIONumber::IIONumber((IIONumber *)v27, *(_DWORD *)(a1 + 232));
  IIODictionary::setObjectForKey((uint64_t)v29, (uint64_t)v27, CFSTR("height"));
  IIONumber::~IIONumber((IIONumber *)v27);
  v4 = *(_DWORD *)(a1 + 452);
  if (v4 > 36282)
  {
    switch(v4)
    {
      case 36492:
      case 36493:
      case 36494:
      case 36495:
        goto LABEL_15;
      default:
        if ((v4 - 36283) < 2)
        {
          v5 = 2;
        }
        else
        {
          if ((v4 - 36285) >= 2)
            goto LABEL_13;
          v5 = 4;
        }
        break;
    }
  }
  else
  {
    v5 = 8;
    if (v4 > 35915)
    {
      if ((v4 - 35916) < 2)
        goto LABEL_16;
      v6 = -35918;
    }
    else
    {
      if ((v4 - 33776) < 2)
        goto LABEL_16;
      v6 = -33778;
    }
    if ((v4 + v6) < 2)
LABEL_15:
      v5 = 16;
    else
LABEL_13:
      v5 = 0;
  }
LABEL_16:
  IIONumber::IIONumber((IIONumber *)v26, v5 * *(_DWORD *)(a1 + 456));
  IIODictionary::setObjectForKey((uint64_t)v29, (uint64_t)v26, CFSTR("rowBytes"));
  IIONumber::~IIONumber((IIONumber *)v26);
  IIONumber::IIONumber((IIONumber *)v25, *(_DWORD *)(a1 + 452));
  IIODictionary::setObjectForKey((uint64_t)v29, (uint64_t)v25, CFSTR("glInternalFormat"));
  IIONumber::~IIONumber((IIONumber *)v25);
  IIONumber::IIONumber((IIONumber *)v24, v3);
  IIODictionary::setObjectForKey((uint64_t)v29, (uint64_t)v24, CFSTR("mipmapLevelCount"));
  IIONumber::~IIONumber((IIONumber *)v24);
  IIONumber::IIONumber((IIONumber *)v23, 1);
  IIODictionary::setObjectForKey((uint64_t)v29, (uint64_t)v23, CFSTR("faceCount"));
  IIONumber::~IIONumber((IIONumber *)v23);
  ColorSpace = (const void *)CGImageProviderGetColorSpace();
  IIODictionary::setObjectForKey((IIODictionary *)v29, ColorSpace, CFSTR("colorSpace"));
  IIODictionary::setObjectForKey((IIODictionary *)v29, (const void *)*MEMORY[0x1E0C9AE40], CFSTR("supportsTiledLayout"));
  IIONumber::IIONumber((IIONumber *)v22, *(_DWORD *)(a1 + 452));
  IIODictionary::setObjectForKey((uint64_t)v29, (uint64_t)v22, CFSTR("pixelFormatGL"));
  IIONumber::~IIONumber((IIONumber *)v22);
  v8 = *(_DWORD *)(a1 + 452);
  if (v8 > 35918)
  {
    switch(v8)
    {
      case 36283:
        v9 = 140;
        break;
      case 36284:
        v9 = 141;
        break;
      case 36285:
        v9 = 142;
        break;
      case 36286:
        v9 = 143;
        break;
      default:
        switch(v8)
        {
          case 36492:
            v9 = 152;
            break;
          case 36493:
            v9 = 153;
            break;
          case 36494:
            v9 = 150;
            break;
          case 36495:
            v9 = 151;
            break;
          default:
            if (v8 != 35919)
              goto LABEL_36;
            v9 = 135;
            break;
        }
        break;
    }
    goto LABEL_43;
  }
  if (v8 <= 33778)
  {
    if ((v8 - 33776) < 2)
    {
      v9 = 130;
      goto LABEL_43;
    }
    if (v8 == 33778)
    {
      v9 = 132;
      goto LABEL_43;
    }
LABEL_36:
    v9 = 0;
    goto LABEL_43;
  }
  if ((v8 - 35916) < 2)
  {
    v9 = 131;
    goto LABEL_43;
  }
  if (v8 == 33779)
  {
    v9 = 134;
    goto LABEL_43;
  }
  if (v8 != 35918)
    goto LABEL_36;
  v9 = 133;
LABEL_43:
  IIONumber::IIONumber((IIONumber *)v21, v9);
  IIODictionary::setObjectForKey((uint64_t)v29, (uint64_t)v21, CFSTR("pixelFormatMetal"));
  IIONumber::~IIONumber((IIONumber *)v21);
  v10 = IIOImageSource::cf(*(IIOImageSource **)(a1 + 32));
  v11 = operator new();
  IIOTextureHandler::IIOTextureHandler(v11, v10);
  *(_QWORD *)(a1 + 488) = CGImageTextureDataCreate();
  v12 = *(std::__shared_weak_count **)(a1 + 504);
  v19 = *(_QWORD *)(a1 + 496);
  v20 = v12;
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }
  IIOTextureHandler::setImp(v11, &v19);
  v15 = v20;
  if (v20)
  {
    v16 = (unint64_t *)&v20->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  IIODictionary::~IIODictionary((IIODictionary *)v29);
  v2 = *(const void **)(a1 + 488);
LABEL_52:
  CFRetain(v2);
  return *(_QWORD *)(a1 + 488);
}

void sub_187FA0D30(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100]((uint64_t)va);
  IIODictionary::~IIODictionary((IIODictionary *)(v2 - 104));
  _Unwind_Resume(a1);
}

uint64_t std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100](uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return a1;
}

void std::__shared_ptr_emplace<BCTextureImp>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E1BBC228;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<BCTextureImp>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E1BBC228;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x18D761C30);
}

uint64_t std::__shared_ptr_emplace<BCTextureImp>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t IIO_Reader_KTX2::createReadPlugin(IIO_Reader *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;

  v4 = operator new();
  v5 = IIO_Reader::osType(a1);
  KTX2ReadPlugin::KTX2ReadPlugin(v4, a2, v5);
  return v4;
}

void sub_187FA0EF0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C4083D79986);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_KTX2::createReadPlugin(IIO_Reader *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8;
  int v9;

  v8 = operator new();
  v9 = IIO_Reader::osType(a1);
  KTX2ReadPlugin::KTX2ReadPlugin(v8, a2, a3, a4, v9);
  return v8;
}

void sub_187FA0F8C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C4083D79986);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_KTX2::getImageCount(IIO_Reader_KTX2 *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  BOOL v11;
  uint64_t v12;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  __int128 __dst;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v18 = 0;
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v14, a2);
  v7 = v15;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  __dst = 0u;
  if (IIOScanner::getBytesAtOffset((IIOScanner *)&v14, &__dst, 0, 0x50uLL) != 80)
  {
    v12 = 4294967246;
    v8 = 1;
    goto LABEL_20;
  }
  if (!(*(unsigned int (**)(IIO_Reader_KTX2 *, __int128 *, uint64_t, _QWORD, _QWORD))(*(_QWORD *)this + 16))(this, &__dst, 80, 0, 0))goto LABEL_19;
  if (HIDWORD(v22) + DWORD2(v22) > v7)
  {
    _cg_jpeg_mem_term("getImageCount", 85, "*** invalid KTX2 file: bytesOfKeyValueData: %d (fileSize: %d)\n");
    goto LABEL_19;
  }
  v8 = DWORD2(v21);
  if (DWORD2(v21))
  {
    v9 = DWORD2(v20);
    if (DWORD1(v20) < DWORD2(v20))
      v9 = DWORD1(v20);
    if (v9)
    {
      v10 = 0;
      do
      {
        ++v10;
        v11 = v9 > 1;
        v9 >>= 1;
      }
      while (v11);
    }
    else
    {
      v10 = 0;
    }
    v12 = 0;
    if (DWORD2(v21) >= v10)
      v8 = v10;
  }
  else
  {
    v12 = 4294967246;
    v8 = 1;
  }
  if (v8 > v7)
  {
    _cg_jpeg_mem_term("getImageCount", 100, "*** invalid KTX2 file: numberOfMipmapLevels: %d (fileSize: %d)\n");
LABEL_19:
    v8 = 0;
    v12 = 4294967246;
  }
LABEL_20:
  if (a5)
    *a5 = v8;
  IIOScanner::~IIOScanner((IIOScanner *)&v14);
  return v12;
}

void sub_187FA1138(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(exception_object);
}

uint64_t IIO_Reader_KTX2::hasCustomImageCountProc(IIO_Reader_KTX2 *this)
{
  return 1;
}

void IIO_Reader::~IIO_Reader(IIO_Reader *this)
{
  JUMPOUT(0x18D761C30);
}

uint64_t IIO_Reader::createReadPlugin()
{
  return 0;
}

{
  return 0;
}

uint64_t IIO_Reader::canDecodeOOP(IIO_Reader *this)
{
  return 1;
}

size_t IIO_Reader::addExtensionsToArray(size_t this, __CFArray *a2)
{
  uint64_t v2;
  const char *v4;
  CFIndex v5;
  const __CFAllocator *v6;
  CFStringRef v7;
  CFStringRef v8;
  CFRange v9;

  v2 = *(_QWORD *)(this + 16);
  if (v2)
  {
    this = strlen(*(const char **)(this + 16));
    if (this >= 3)
    {
      v4 = (const char *)(v2 + 1);
      this = strcspn(v4, ".");
      if (this)
      {
        v5 = this;
        v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        do
        {
          v7 = CFStringCreateWithBytes(v6, (const UInt8 *)v4, v5, 0x600u, 0);
          if (v7)
          {
            v8 = v7;
            v9.length = CFArrayGetCount(a2);
            v9.location = 0;
            if (!CFArrayContainsValue(a2, v9, v8))
              CFArrayAppendValue(a2, v8);
            CFRelease(v8);
          }
          v4 += v5 + 1;
          this = strcspn(v4, ".");
          v5 = this;
        }
        while (this);
      }
    }
  }
  return this;
}

uint64_t IIO_Reader::compareOptions(IIO_Reader *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  return 1;
}

uint64_t IIO_Reader::isReaderForRAWImageFormat(IIO_Reader *this)
{
  return 0;
}

uint64_t IIO_Reader::canCreateCustomThumbnailSizes(IIO_Reader *this)
{
  return 0;
}

uint64_t IIO_Reader::hasCustomCopyAuxiliaryDataProc(IIO_Reader *this)
{
  return 0;
}

uint64_t IIO_Reader::addBasicProperties(IIO_Reader *this, unsigned __int8 *a2, unsigned int a3, __CFDictionary *a4, unsigned int *a5, const __CFData **a6)
{
  return 0;
}

uint64_t IIO_Reader::copyAuxiliaryDataInfo()
{
  return 0;
}

uint64_t IIO_Reader::updateGlobalInfo(IIO_Reader *this, IIOImageReadSession *a2, unsigned __int8 *a3)
{
  return 4294967292;
}

uint64_t IIO_Reader::createGlobalInfoData(IIO_Reader *this, IIOImageReadSession *a2)
{
  return 0;
}

uint64_t IIO_Reader::deserializeGlobalInfo(IIO_Reader *this, unsigned __int8 *a2)
{
  _cg_jpeg_mem_term("deserializeGlobalInfo", 281, "%s is an abstract method and must be overridden by subclasses\n", "deserializeGlobalInfo");
  return 0;
}

uint64_t IIO_Reader::testHeader()
{
  return 0;
}

uint64_t IIO_Reader::xpcGetImageCount(IIO_Reader *this, _xpc_connection_s *a2, void *a3, void *a4)
{
  xpc_object_t source_dict;
  xpc_object_t plugin_dict;
  xpc_object_t v9;
  xpc_object_t v10;
  xpc_object_t v11;
  xpc_object_t GlobalInfo;
  uint64_t v13;
  const __CFData *v14;
  _QWORD v16[3];
  uint64_t v17;
  int64_t value;
  _OWORD v19[4];
  _OWORD v20[30];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (!IIO_XPCServer())
    return 4294967246;
  IIOIncrementImageCountCallCount();
  source_dict = iio_xpc_get_source_dict(a3);
  plugin_dict = iio_xpc_get_plugin_dict(a3);
  v9 = iio_xpc_add_message_dict(a4);
  v10 = iio_xpc_add_source_dict(a4);
  v11 = iio_xpc_add_plugin_dict(a4);
  memset(v20, 0, sizeof(v20));
  IIOImageRead::IIOImageRead((IIOImageRead *)v20, a3);
  memset(v19, 0, sizeof(v19));
  IIOImageReadSession::IIOImageReadSession((IIOImageReadSession *)v19, (IIOImageRead *)v20);
  v17 = 0;
  value = 0;
  GlobalInfo = iio_xpc_dictionary_get_GlobalInfo(plugin_dict, &v17);
  if (v17)
    (*(void (**)(IIO_Reader *, _OWORD *, xpc_object_t))(*(_QWORD *)this + 96))(this, v19, GlobalInfo);
  if (source_dict)
    source_dict = iio_xpc_dictionary_copy_CFDictionary(source_dict, "iio_xpc_src_options");
  memset(v16, 0, sizeof(v16));
  IIODictionary::IIODictionary((IIODictionary *)v16, (const __CFDictionary *)source_dict);
  v13 = (*(uint64_t (**)(IIO_Reader *, _OWORD *, _QWORD *, char *, int64_t *))(*(_QWORD *)this + 32))(this, v19, v16, (char *)&value + 4, &value);
  IIOXPCLog(" xpcGetImageCount - sending %d\n", value);
  xpc_dictionary_set_int64(v10, "iio_xpc_src_status", SHIDWORD(value));
  xpc_dictionary_set_uint64(v10, "iio_xpc_src_image_count", value);
  iio_xpc_dictionary_set_error_code(v9, v13);
  v14 = (const __CFData *)(*(uint64_t (**)(IIO_Reader *, _OWORD *))(*(_QWORD *)this + 104))(this, v19);
  if (v14)
  {
    iio_xpc_dictionary_add_GlobalInfo(v11, v14, *((_DWORD *)this + 6));
    CFRelease(v14);
  }
  if (source_dict)
    CFRelease(source_dict);
  IIODictionary::~IIODictionary((IIODictionary *)v16);
  IIOImageReadSession::~IIOImageReadSession((IIOImageReadSession *)v19);
  IIOImageRead::~IIOImageRead((IIOImageRead *)v20);
  return v13;
}

void sub_187FA1548(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  IIOImageReadSession::~IIOImageReadSession((IIOImageReadSession *)va);
  IIOImageRead::~IIOImageRead((IIOImageRead *)va1);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader::getImageCount(IIO_Reader *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  int v7;
  unsigned int v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  double v19;

  _cg_jpeg_mem_term("getImageCount", 522, "===========================================================\n", a4);
  v7 = *((_DWORD *)this + 6);
  v8 = v7 >> 24;
  v9 = MEMORY[0x1E0C80978];
  if (v7 < 0)
  {
    v10 = __maskrune(v8, 0x40000uLL);
    v7 = *((_DWORD *)this + 6);
  }
  else
  {
    v10 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v8 + 60) & 0x40000;
  }
  if (v10)
    v11 = (v7 >> 24);
  else
    v11 = 46;
  v12 = v7 << 8 >> 24;
  if (v7 << 8 < 0)
  {
    v13 = __maskrune(v12, 0x40000uLL);
    v7 = *((_DWORD *)this + 6);
  }
  else
  {
    v13 = *(_DWORD *)(v9 + 4 * v12 + 60) & 0x40000;
  }
  if (v13)
    v14 = (v7 << 8 >> 24);
  else
    v14 = 46;
  v15 = (__int16)v7 >> 8;
  if (v7 << 16 < 0)
  {
    v16 = __maskrune(v15, 0x40000uLL);
    v7 = *((_DWORD *)this + 6);
  }
  else
  {
    v16 = *(_DWORD *)(v9 + 4 * v15 + 60) & 0x40000;
  }
  if (v16)
    v17 = ((__int16)v7 >> 8);
  else
    v17 = 46;
  if ((v7 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v9 + 4 * (char)v7 + 60) & 0x40000) != 0)
      goto LABEL_21;
  }
  else if (__maskrune((char)v7, 0x40000uLL))
  {
LABEL_21:
    v18 = *((char *)this + 24);
    goto LABEL_24;
  }
  v18 = 46;
LABEL_24:
  *(_QWORD *)&v19 = _cg_jpeg_mem_term("getImageCount", 523, "IIO_Reader [%c%c%c%c] did not implement 'getImageCount'\n", v11, v14, v17, v18).n128_u64[0];
  _cg_jpeg_mem_term("getImageCount", 524, "===========================================================\n", v19);
  if (a5)
    *a5 = 1;
  return 0;
}

uint64_t IIO_Reader::xpcUpdateSourceProperties(IIO_Reader *this, _xpc_connection_s *a2, void *a3, void *a4)
{
  xpc_object_t source_dict;
  xpc_object_t v8;
  xpc_object_t v9;
  const __CFDictionary *v10;
  const __CFDictionary *v11;
  const __CFDictionary *v12;
  uint64_t v13;
  _BYTE value[76];
  _QWORD v16[3];
  _QWORD v17[3];
  _QWORD v18[3];
  _BYTE v19[488];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (!IIO_XPCServer())
    return 4294967292;
  IIOIncrementSourcePropertiesCallCount();
  source_dict = iio_xpc_get_source_dict(a3);
  v8 = iio_xpc_add_message_dict(a4);
  v9 = iio_xpc_add_source_dict(a4);
  v10 = (const __CFDictionary *)iio_xpc_dictionary_copy_CFDictionary(v8, "iio_xpc_msg_call_options");
  memset(v18, 0, sizeof(v18));
  IIODictionary::IIODictionary((IIODictionary *)v18, v10);
  v11 = (const __CFDictionary *)iio_xpc_dictionary_copy_CFDictionary(source_dict, "iio_xpc_src_options");
  memset(v17, 0, sizeof(v17));
  IIODictionary::IIODictionary((IIODictionary *)v17, v11);
  v12 = (const __CFDictionary *)iio_xpc_dictionary_copy_CFDictionary(source_dict, "iio_xpc_src_properties");
  memset(v16, 0, sizeof(v16));
  IIODictionary::IIODictionary((IIODictionary *)v16, v12, 1);
  memset(v19, 0, 480);
  IIOImageRead::IIOImageRead((IIOImageRead *)v19, a3);
  memset(&value[4], 0, 64);
  IIOImageReadSession::IIOImageReadSession((IIOImageReadSession *)&value[4], (IIOImageRead *)v19);
  *(_DWORD *)value = 0;
  v13 = (*(uint64_t (**)(IIO_Reader *, _BYTE *, _QWORD *, _QWORD *, _QWORD *, _BYTE *))(*(_QWORD *)this + 56))(this, &value[4], v16, v17, v18, value);
  if (!(_DWORD)v13)
  {
    IIOXPCLog(" xpcUpdateSourceProperties...\n");
    iio_xpc_dictionary_add_CFDictionary(v9, "iio_xpc_src_properties");
    xpc_dictionary_set_int64(v9, "iio_xpc_src_status", *(int *)value);
  }
  iio_xpc_dictionary_set_error_code(v8, v13);
  if (v10)
    CFRelease(v10);
  if (v11)
    CFRelease(v11);
  if (v12)
    CFRelease(v12);
  IIOImageReadSession::~IIOImageReadSession((IIOImageReadSession *)&value[4]);
  IIOImageRead::~IIOImageRead((IIOImageRead *)v19);
  IIODictionary::~IIODictionary((IIODictionary *)v16);
  IIODictionary::~IIODictionary((IIODictionary *)v17);
  IIODictionary::~IIODictionary((IIODictionary *)v18);
  return v13;
}

void sub_187FA1960(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,char a29)
{
  IIOImageRead::~IIOImageRead((IIOImageRead *)&a29);
  IIODictionary::~IIODictionary((IIODictionary *)&a20);
  IIODictionary::~IIODictionary((IIODictionary *)&a23);
  IIODictionary::~IIODictionary((IIODictionary *)&a26);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader::updateSourceProperties(IIO_Reader *this, IIOImageReadSession *a2, IIODictionary *a3, IIODictionary *a4, IIODictionary *a5, CGImageSourceStatus *a6)
{
  int v7;
  unsigned int v8;
  uint64_t v9;
  int v10;
  unsigned int v11;
  int v12;
  int v13;
  unsigned int v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  ImageIOLog("=======================================================================\n", a2, a3, a4, a5, a6);
  v7 = *((_DWORD *)this + 6);
  v8 = v7 >> 24;
  v9 = MEMORY[0x1E0C80978];
  if (v7 < 0)
  {
    v10 = __maskrune(v8, 0x40000uLL);
    v7 = *((_DWORD *)this + 6);
  }
  else
  {
    v10 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v8 + 60) & 0x40000;
  }
  v11 = v7 << 8 >> 24;
  if (v7 << 8 < 0)
  {
    v12 = __maskrune(v11, 0x40000uLL);
    v13 = *((_DWORD *)this + 6);
  }
  else
  {
    v12 = *(_DWORD *)(v9 + 4 * v11 + 60) & 0x40000;
    v13 = v7;
  }
  v14 = (__int16)v13 >> 8;
  if (v13 << 16 < 0)
  {
    v15 = __maskrune(v14, 0x40000uLL);
    v16 = *((_DWORD *)this + 6);
  }
  else
  {
    v15 = *(_DWORD *)(v9 + 4 * v14 + 60) & 0x40000;
    v16 = v13;
  }
  if ((v16 << 24) <= 0x7F000000)
    v17 = *(_DWORD *)(v9 + 4 * (char)v16 + 60) & 0x40000;
  else
    v17 = __maskrune((char)v16, 0x40000uLL);
  if (v17)
    v18 = *((char *)this + 24);
  else
    v18 = 46;
  LODWORD(v19) = (__int16)v16 >> 8;
  if (v15)
    v19 = v19;
  else
    v19 = 46;
  LODWORD(v20) = v13 << 8 >> 24;
  if (v12)
    v20 = v20;
  else
    v20 = 46;
  if (v10)
    v21 = (v7 >> 24);
  else
    v21 = 46;
  ImageIOLog("IIO_Reader [%c%c%c%c] did not implement 'updateSourceProperties'\n", v21, v20, v19, v18);
  ImageIOLog("=======================================================================\n");
  return 4294967240;
}

uint64_t IIO_Reader::xpcInitImage(IIO_Reader *this, _xpc_connection_s *a2, void *a3, void *a4)
{
  xpc_object_t source_dict;
  xpc_object_t plugin_dict;
  xpc_object_t v9;
  xpc_object_t v10;
  void *v11;
  const UInt8 *DataFromXPCDict;
  const UInt8 *v13;
  _OWORD *data;
  _OWORD *v15;
  const __CFDictionary *v16;
  __int128 v17;
  CGMutableImageMetadataRef Mutable;
  IIOReadPlugin *v19;
  IIOImageSource *v20;
  xpc_object_t GlobalInfo;
  xpc_object_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int Uint32ForKey;
  unsigned int v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  IIO_Reader *v32;
  uint64_t v33;
  unsigned int v34;
  int v35;
  uint64_t v36;
  unsigned int v37;
  int v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  unsigned int v42;
  int v43;
  uint64_t v44;
  unsigned int v45;
  int v46;
  uint64_t v47;
  unsigned int v48;
  int v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  IIO_ReaderHandler *Uint64ForKey;
  IIO_ReaderHandler *ReaderHandler;
  IIO_Reader *v55;
  uint64_t v56;
  CGColorSpace *ColorSpace;
  CFPropertyListRef v58;
  uint64_t v59;
  const __CFData *v60;
  uint64_t Position;
  xpc_object_t XPCObj;
  xpc_object_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  xpc_object_t xdict;
  const __CFDictionary *v71;
  uint64_t v72[3];
  _QWORD v73[3];
  __int128 v74;
  __int128 v75;
  __int128 v76;
  uint64_t v77;
  _QWORD v78[3];
  size_t v79[3];
  size_t length[2];

  if (IIO_XPCServer())
  {
    length[0] = 0;
    IIOIncrementInitImageCallCount();
    source_dict = iio_xpc_get_source_dict(a3);
    plugin_dict = iio_xpc_get_plugin_dict(a3);
    v9 = iio_xpc_add_message_dict(a4);
    v10 = iio_xpc_add_plugin_dict(a4);
    DataFromXPCDict = IIOImageRead::CreateDataFromXPCDict((IIOImageRead *)a3, v11);
    if (DataFromXPCDict)
    {
      v13 = DataFromXPCDict;
      if (!plugin_dict || (data = xpc_dictionary_get_data(plugin_dict, "iio_xpc_plugin_init_data", length)) == 0)
      {
        v30 = 4294967246;
LABEL_18:
        CFRelease(v13);
        return v30;
      }
      v15 = data;
      v16 = (const __CFDictionary *)iio_xpc_dictionary_copy_CFDictionary(source_dict, "iio_xpc_src_options");
      if (length[0] != 56)
      {
        IIOXPCLog("*** data mismatch?\n");
        IIOXPCLog("*** initDataSize: %8ld    sizeof(ReadPluginInitData): %8ld\n", length[0], 56);
        Mutable = 0;
        v30 = 4294967246;
        if (!v16)
          goto LABEL_16;
        goto LABEL_15;
      }
      memset(v79, 0, sizeof(v79));
      IIODictionary::IIODictionary((IIODictionary *)v79, v16);
      memset(v78, 0, sizeof(v78));
      IIODictionary::IIODictionary((IIODictionary *)v78);
      v77 = 0;
      v75 = 0u;
      v76 = 0u;
      v74 = 0u;
      v17 = v15[2];
      v77 = *((_QWORD *)v15 + 6);
      v76 = v17;
      Mutable = CGImageMetadataCreateMutable();
      xdict = v10;
      v71 = v16;
      *(_QWORD *)&v74 = v79;
      *((_QWORD *)&v74 + 1) = v78;
      *(_QWORD *)&v75 = Mutable;
      *((_QWORD *)&v75 + 1) = v13;
      memset(v73, 0, sizeof(v73));
      IIODictionary::IIODictionary((IIODictionary *)v73);
      v19 = (IIOReadPlugin *)(*(uint64_t (**)(IIO_Reader *, __int128 *))(*(_QWORD *)this + 240))(this, &v74);
      v20 = v19;
      if (v19)
      {
        IIOReadPlugin::setUTIWithReader(v19, this);
        v72[0] = 0;
        GlobalInfo = iio_xpc_dictionary_get_GlobalInfo(plugin_dict, v72);
        if (v72[0])
        {
          v22 = GlobalInfo;
          v23 = IIOImageSource::count(v20);
          (*(void (**)(IIO_Reader *, uint64_t, xpc_object_t, uint64_t))(*(_QWORD *)this + 96))(this, v23, v22, v72[0]);
        }
        v24 = (*(uint64_t (**)(IIOImageSource *, _QWORD *))(*(_QWORD *)v20 + 88))(v20, v73);
        v69 = v24;
        if ((_DWORD)v24 == -49)
        {
          v63 = v9;
          v25 = *((_DWORD *)v20 + 51);
          (*(void (**)(IIOImageSource *))(*(_QWORD *)v20 + 8))(v20);
          Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v73, CFSTR("NEW_PLUGIN_ostype"));
          v27 = v25 >> 24;
          v28 = MEMORY[0x1E0C80978];
          if (v25 < 0)
            v29 = __maskrune(v25 >> 24, 0x40000uLL);
          else
            v29 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v27 + 60) & 0x40000;
          if (v29)
            v33 = v27;
          else
            v33 = 46;
          v68 = v33;
          v34 = v25 << 8 >> 24;
          if (v25 << 8 < 0)
            v35 = __maskrune(v25 << 8 >> 24, 0x40000uLL);
          else
            v35 = *(_DWORD *)(v28 + 4 * v34 + 60) & 0x40000;
          if (v35)
            v36 = v34;
          else
            v36 = 46;
          v67 = v36;
          v37 = (__int16)v25 >> 8;
          if (v25 << 16 < 0)
            v38 = __maskrune((__int16)v25 >> 8, 0x40000uLL);
          else
            v38 = *(_DWORD *)(v28 + 4 * v37 + 60) & 0x40000;
          if (v38)
            v39 = v37;
          else
            v39 = 46;
          v66 = v39;
          if ((v25 << 24) <= 0x7F000000)
            v40 = *(_DWORD *)(v28 + 4 * (char)v25 + 60) & 0x40000;
          else
            v40 = __maskrune((char)v25, 0x40000uLL);
          if (v40)
            v41 = (char)v25;
          else
            v41 = 46;
          v65 = v41;
          v42 = Uint32ForKey >> 24;
          if (Uint32ForKey < 0)
            v43 = __maskrune(Uint32ForKey >> 24, 0x40000uLL);
          else
            v43 = *(_DWORD *)(v28 + 4 * v42 + 60) & 0x40000;
          if (v43)
            v44 = v42;
          else
            v44 = 46;
          v64 = v44;
          v45 = Uint32ForKey << 8 >> 24;
          if (Uint32ForKey << 8 < 0)
            v46 = __maskrune(Uint32ForKey << 8 >> 24, 0x40000uLL);
          else
            v46 = *(_DWORD *)(v28 + 4 * v45 + 60) & 0x40000;
          if (v46)
            v47 = v45;
          else
            v47 = 46;
          v48 = (__int16)Uint32ForKey >> 8;
          if (Uint32ForKey << 16 < 0)
            v49 = __maskrune((__int16)Uint32ForKey >> 8, 0x40000uLL);
          else
            v49 = *(_DWORD *)(v28 + 4 * v48 + 60) & 0x40000;
          if ((Uint32ForKey << 24) <= 0x7F000000)
            v50 = *(_DWORD *)(v28 + 4 * (char)Uint32ForKey + 60) & 0x40000;
          else
            v50 = __maskrune((char)Uint32ForKey, 0x40000uLL);
          if (v49)
            v51 = v48;
          else
            v51 = 46;
          if (v50)
            v52 = (char)Uint32ForKey;
          else
            v52 = 46;
          _cg_jpeg_mem_term("xpcInitImage", 1103, "*** NOTE: initialize triggered plugin change from: '%c%c%c%c' to: '%c%c%c%c'\n", v68, v67, v66, v65, v64, v47, v51, v52);
          Uint64ForKey = IIODictionary::getUint64ForKey((IIODictionary *)v73, CFSTR("NEW_PLUGIN_dataOffset"));
          ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(Uint64ForKey);
          v55 = IIO_ReaderHandler::readerForType(ReaderHandler, Uint32ForKey);
          v32 = v55;
          if (v55)
          {
            *((_QWORD *)&v76 + 1) = Uint64ForKey;
            v20 = (IIOImageSource *)(*(uint64_t (**)(IIO_Reader *, __int128 *))(*(_QWORD *)v55 + 240))(v55, &v74);
            IIOReadPlugin::setUTIWithReader(v20, v32);
            if (v25 == 1297108768)
              IIODictionary::setObjectForKey((IIODictionary *)v73, (const void *)*MEMORY[0x1E0C9AE50], CFSTR("OriginalPluginWasMPO"));
            v56 = IIOImageSource::count(v20);
            (*(void (**)(IIO_Reader *, uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v32 + 32))(v32, v56, 0, 0, 0);
            v30 = (*(uint64_t (**)(IIOImageSource *, _QWORD *))(*(_QWORD *)v20 + 88))(v20, v73);
            v9 = v63;
            if (!(_DWORD)v30)
            {
LABEL_73:
              memset(v72, 0, sizeof(v72));
              IIODictionary::IIODictionary((IIODictionary *)v72);
              IIOXPCLog(" xpcInitImage...\n");
              (*(void (**)(IIOImageSource *, xpc_object_t))(*(_QWORD *)v20 + 104))(v20, xdict);
              ColorSpace = (CGColorSpace *)IIOReadPlugin::getColorSpace(v20);
              if (ColorSpace)
              {
                v58 = CGColorSpaceCopyPropertyList(ColorSpace);
                if (v58)
                {
                  IIODictionary::setObjectForKey((IIODictionary *)v72, v58, CFSTR("TEMP_COLORSPACE"));
                  CFRelease(v58);
                }
              }
              if (IIODictionary::getCount((IIODictionary *)v72))
                iio_xpc_dictionary_add_CFDictionary(xdict, "iio_xpc_plugin_header_infoptr");
              if (v69 == -49)
              {
                iio_xpc_dictionary_add_CFDictionary(xdict, "iio_xpc_plugin_type_changed");
                if (!v32)
                {
LABEL_90:
                  iio_xpc_dictionary_add_CFDictionary(xdict, "iio_xpc_plugin_init_properties");
                  Position = IIOImageWriteSession::getPosition(v20);
                  XPCObj = CGImageMetadataCreateXPCObj(Position);
                  if (XPCObj)
                  {
                    xpc_dictionary_set_value(xdict, "iio_xpc_plugin_init_metadata", XPCObj);
                    xpc_release(XPCObj);
                  }
                  IIODictionary::~IIODictionary((IIODictionary *)v72);
                  v30 = 0;
LABEL_83:
                  iio_xpc_dictionary_set_error_code(v9, v30);
                  if (v20)
                    (*(void (**)(IIOImageSource *))(*(_QWORD *)v20 + 8))(v20);
                  IIODictionary::~IIODictionary((IIODictionary *)v73);
                  IIODictionary::~IIODictionary((IIODictionary *)v78);
                  IIODictionary::~IIODictionary((IIODictionary *)v79);
                  v16 = v71;
                  if (!v71)
                    goto LABEL_16;
LABEL_15:
                  CFRelease(v16);
LABEL_16:
                  if (Mutable)
                    CFRelease(Mutable);
                  goto LABEL_18;
                }
                v59 = IIOImageSource::count(v20);
              }
              else
              {
                v59 = IIOImageSource::count(v20);
                v32 = this;
              }
              v60 = (const __CFData *)(*(uint64_t (**)(IIO_Reader *, uint64_t))(*(_QWORD *)v32 + 104))(v32, v59);
              if (v60)
              {
                iio_xpc_dictionary_add_GlobalInfo(xdict, v60, *((_DWORD *)this + 6));
                CFRelease(v60);
              }
              goto LABEL_90;
            }
          }
          else
          {
            v20 = 0;
            v30 = 4294967247;
            v9 = v63;
          }
        }
        else
        {
          v32 = 0;
          v30 = v24;
          if (!(_DWORD)v24)
            goto LABEL_73;
        }
      }
      else
      {
        v30 = 4294967246;
      }
      IIOXPCLog("serverPlugin->initialize returned: %d\n", v30);
      goto LABEL_83;
    }
  }
  return 4294967246;
}

void sub_187FA2220(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,char a30)
{
  uint64_t v30;

  IIODictionary::~IIODictionary((IIODictionary *)&a27);
  IIODictionary::~IIODictionary((IIODictionary *)&a30);
  IIODictionary::~IIODictionary((IIODictionary *)(v30 - 144));
  IIODictionary::~IIODictionary((IIODictionary *)(v30 - 120));
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader::initializeThumbnail(const void ***a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  IIODebugCallbackPriv(*a1[1], "initThumbnail");
  return ((uint64_t (*)(const void ***, uint64_t, uint64_t, uint64_t))(*a1)[11])(a1, a2, a3, a4);
}

float IIO_Reader::updateImageHeadroom(int a1, int a2, int a3, CGColorSpaceRef space)
{
  float v4;
  const __CFString *Name;

  v4 = 0.0;
  if (space)
  {
    Name = CGColorSpaceGetName(space);
    if (Name)
    {
      if (CFStringCompare(Name, (CFStringRef)*MEMORY[0x1E0C9D918], 0))
        return 0.0;
      else
        return 4.99;
    }
  }
  return v4;
}

uint64_t IIO_Reader::initThumbnail()
{
  return 4294967245;
}

uint64_t IIO_Reader::xpcDecodeImage(IIO_Reader *this, _xpc_connection_s *a2, void *a3, void *a4)
{
  xpc_object_t source_dict;
  xpc_object_t plugin_dict;
  xpc_object_t callback_dict;
  xpc_object_t v10;
  xpc_object_t v11;
  void *v12;
  const UInt8 *DataFromXPCDict;
  const __CFDictionary *v14;
  uint64_t v15;
  const __CFDictionary *v16;
  CGMutableImageMetadataRef Mutable;
  uint64_t v18;
  IIOImageSource *v19;
  xpc_object_t GlobalInfo;
  xpc_object_t v21;
  uint64_t v22;
  xpc_object_t v23;
  double CGRect;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  unsigned int uint64;
  uint64_t v36;
  xpc_object_t value;
  BOOL v38;
  xpc_object_t XPCObject;
  int v40;
  unsigned int v41;
  int v42;
  int v43;
  unsigned int v44;
  int v45;
  uint64_t v46;
  unsigned int v47;
  int v48;
  uint64_t v49;
  unsigned int v50;
  int v51;
  uint64_t v52;
  unsigned int v53;
  int v54;
  uint64_t v55;
  unsigned int v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  xpc_object_t v60;
  uint64_t v61;
  const __CFData *v62;
  uint64_t v63;
  uint64_t v64;
  int v65;
  unsigned int v66;
  uint64_t v67;
  int v68;
  uint64_t v69;
  unsigned int v70;
  int v71;
  uint64_t v72;
  unsigned int v73;
  int v74;
  uint64_t v75;
  uint64_t v76;
  xpc_object_t xdict;
  void *v79;
  _OWORD v80[5];
  uint64_t v81;
  _QWORD v82[7];
  _QWORD v83[3];
  _QWORD v84[3];
  uint64_t v85;
  __IOSurface *v86;
  _QWORD v87[4];

  if (!IIO_XPCServer())
    return 4294967246;
  memset(v87, 0, 24);
  IIODictionary::IIODictionary((IIODictionary *)v87);
  v85 = 0;
  v86 = 0;
  IIOIncrementCopyIOSurfaceCallCount();
  source_dict = iio_xpc_get_source_dict(a3);
  plugin_dict = iio_xpc_get_plugin_dict(a3);
  callback_dict = iio_xpc_get_callback_dict(a3);
  v10 = iio_xpc_add_message_dict(a4);
  v11 = iio_xpc_add_callback_dict(a4);
  DataFromXPCDict = IIOImageRead::CreateDataFromXPCDict((IIOImageRead *)a3, v12);
  if (source_dict)
    v14 = (const __CFDictionary *)iio_xpc_dictionary_copy_CFDictionary(source_dict, "iio_xpc_src_options");
  else
    v14 = 0;
  memset(v84, 0, sizeof(v84));
  IIODictionary::IIODictionary((IIODictionary *)v84, v14);
  if (source_dict)
    v16 = (const __CFDictionary *)iio_xpc_dictionary_copy_CFDictionary(source_dict, "iio_xpc_src_properties");
  else
    v16 = 0;
  memset(v83, 0, sizeof(v83));
  IIODictionary::IIODictionary((IIODictionary *)v83, v16);
  if (v16)
    CFRelease(v16);
  Mutable = CGImageMetadataCreateMutable();
  xdict = v11;
  v79 = v10;
  v82[5] = 0;
  v82[6] = 0x10000;
  v82[3] = DataFromXPCDict;
  v82[4] = 0;
  v82[0] = v84;
  v82[1] = v83;
  v82[2] = Mutable;
  v18 = (*(uint64_t (**)(IIO_Reader *, _QWORD *))(*(_QWORD *)this + 240))(this, v82);
  v19 = (IIOImageSource *)v18;
  v15 = 4294967246;
  if (!v18 || !plugin_dict || !callback_dict)
    goto LABEL_83;
  (*(void (**)(uint64_t, xpc_object_t))(*(_QWORD *)v18 + 96))(v18, plugin_dict);
  *(_QWORD *)&v80[0] = 0;
  GlobalInfo = iio_xpc_dictionary_get_GlobalInfo(plugin_dict, (uint64_t *)v80);
  if (*(_QWORD *)&v80[0])
  {
    v21 = GlobalInfo;
    v22 = IIOImageSource::count(v19);
    (*(void (**)(IIO_Reader *, uint64_t, xpc_object_t, _QWORD))(*(_QWORD *)this + 96))(this, v22, v21, *(_QWORD *)&v80[0]);
  }
  v23 = iio_xpc_dictionary_copy_CFDictionary(callback_dict, "iio_xpc_cb_blockset_options");
  CGRect = iio_xpc_dictionary_get_CGRect(callback_dict, "iio_xpc_cb_blockset_cgrect");
  v26 = v25;
  v28 = v27;
  v30 = v29;
  iio_xpc_dictionary_get_CGSize(callback_dict, "iio_xpc_cb_blockset_dest_cgsize");
  v32 = v31;
  v34 = v33;
  if (source_dict)
  {
    uint64 = xpc_dictionary_get_uint64(source_dict, "iio_xpc_src_image_index");
    v36 = xpc_dictionary_get_uint64(source_dict, "iio_xpc_src_image_type");
    if ((_DWORD)v36 == 1)
    {
      value = xpc_dictionary_get_value(callback_dict, "iio_xpc_cb_decode_iosurface");
      v86 = IOSurfaceLookupFromXPCObject(value);
      v38 = v86 != 0;
      v36 = 1;
    }
    else
    {
      v38 = 0;
    }
  }
  else
  {
    uint64 = 0;
    v38 = 0;
    v36 = 3;
  }
  (*(void (**)(IIOImageSource *, xpc_object_t))(*(_QWORD *)v19 + 72))(v19, v23);
  v81 = 0;
  memset(v80, 0, sizeof(v80));
  IIODecodeParameter::IIODecodeParameter((uint64_t)v80, 0, 0, uint64, v23, CGRect, v26, v28, v30, v32, v34);
  v15 = (*(uint64_t (**)(IIOImageSource *, _OWORD *, uint64_t, __IOSurface **, uint64_t *, _QWORD))(*(_QWORD *)v19 + 208))(v19, v80, v36, &v86, &v85, 0);
  if (v23)
    CFRelease(v23);
  if ((_DWORD)v36 == 3)
  {
    v15 = IIOReadPlugin::addImageBlocksToXPCObject(v19, a4);
  }
  else if ((_DWORD)v36 == 1 && v86)
  {
    if (!v38)
    {
      XPCObject = IOSurfaceCreateXPCObject(v86);
      if (XPCObject)
      {
        xpc_dictionary_set_value(xdict, "iio_xpc_cb_decode_iosurface", XPCObject);
        xpc_release(XPCObject);
      }
    }
    CFRelease(v86);
  }
  IIODecodeParameter::~IIODecodeParameter((IIODecodeParameter *)v80);
  if ((_DWORD)v15 != -181)
  {
    if (!(_DWORD)v15)
    {
      v40 = *((_DWORD *)this + 6);
      v41 = v40 >> 24;
      if (v40 < 0)
      {
        v42 = __maskrune(v41, 0x40000uLL);
        v40 = *((_DWORD *)this + 6);
      }
      else
      {
        v42 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v41 + 60) & 0x40000;
      }
      if (v42)
        v46 = (v40 >> 24);
      else
        v46 = 46;
      v47 = v40 << 8 >> 24;
      if (v40 << 8 < 0)
      {
        v48 = __maskrune(v47, 0x40000uLL);
        v40 = *((_DWORD *)this + 6);
      }
      else
      {
        v48 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v47 + 60) & 0x40000;
      }
      if (v48)
        v52 = (v40 << 8 >> 24);
      else
        v52 = 46;
      v53 = (__int16)v40 >> 8;
      if (v40 << 16 < 0)
      {
        v54 = __maskrune(v53, 0x40000uLL);
        v40 = *((_DWORD *)this + 6);
      }
      else
      {
        v54 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v53 + 60) & 0x40000;
      }
      if (v54)
        v58 = ((__int16)v40 >> 8);
      else
        v58 = 46;
      if ((v40 << 24) <= 0x7F000000)
      {
        if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v40 + 60) & 0x40000) != 0)
          goto LABEL_67;
      }
      else if (__maskrune((char)v40, 0x40000uLL))
      {
LABEL_67:
        v59 = *((char *)this + 24);
LABEL_70:
        IIOXPCLog(" xpcDecodeImage [%c%c%c%c]...\n", v46, v52, v58, v59);
        v60 = iio_xpc_add_plugin_dict(a4);
        (*(void (**)(IIOImageSource *, xpc_object_t))(*(_QWORD *)v19 + 104))(v19, v60);
        v61 = IIOImageSource::count(v19);
        v62 = (const __CFData *)(*(uint64_t (**)(IIO_Reader *, uint64_t))(*(_QWORD *)this + 104))(this, v61);
        if (v62)
        {
          iio_xpc_dictionary_add_GlobalInfo(v60, v62, *((_DWORD *)this + 6));
          CFRelease(v62);
        }
        v15 = 0;
        goto LABEL_107;
      }
      v59 = 46;
      goto LABEL_70;
    }
LABEL_83:
    v65 = *((_DWORD *)this + 6);
    v66 = v65 >> 24;
    v67 = MEMORY[0x1E0C80978];
    if (v65 < 0)
    {
      v68 = __maskrune(v66, 0x40000uLL);
      v65 = *((_DWORD *)this + 6);
    }
    else
    {
      v68 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v66 + 60) & 0x40000;
    }
    if (v68)
      v69 = (v65 >> 24);
    else
      v69 = 46;
    v70 = v65 << 8 >> 24;
    if (v65 << 8 < 0)
    {
      v71 = __maskrune(v70, 0x40000uLL);
      v65 = *((_DWORD *)this + 6);
    }
    else
    {
      v71 = *(_DWORD *)(v67 + 4 * v70 + 60) & 0x40000;
    }
    if (v71)
      v72 = (v65 << 8 >> 24);
    else
      v72 = 46;
    v73 = (__int16)v65 >> 8;
    if (v65 << 16 < 0)
    {
      v74 = __maskrune(v73, 0x40000uLL);
      v65 = *((_DWORD *)this + 6);
    }
    else
    {
      v74 = *(_DWORD *)(v67 + 4 * v73 + 60) & 0x40000;
    }
    if (v74)
      v75 = ((__int16)v65 >> 8);
    else
      v75 = 46;
    if ((v65 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v67 + 4 * (char)v65 + 60) & 0x40000) != 0)
        goto LABEL_103;
    }
    else if (__maskrune((char)v65, 0x40000uLL))
    {
LABEL_103:
      v76 = *((char *)this + 24);
LABEL_106:
      IIOXPCLog(" xpcDecodeImage [%c%c%c%c] err=%d)\n", v69, v72, v75, v76, v15);
      goto LABEL_107;
    }
    v76 = 46;
    goto LABEL_106;
  }
  v43 = *((_DWORD *)this + 6);
  v44 = v43 >> 24;
  if (v43 < 0)
  {
    v45 = __maskrune(v44, 0x40000uLL);
    v43 = *((_DWORD *)this + 6);
  }
  else
  {
    v45 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v44 + 60) & 0x40000;
  }
  if (v45)
    v49 = (v43 >> 24);
  else
    v49 = 46;
  v50 = v43 << 8 >> 24;
  if (v43 << 8 < 0)
  {
    v51 = __maskrune(v50, 0x40000uLL);
    v43 = *((_DWORD *)this + 6);
  }
  else
  {
    v51 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v50 + 60) & 0x40000;
  }
  if (v51)
    v55 = (v43 << 8 >> 24);
  else
    v55 = 46;
  v56 = (__int16)v43 >> 8;
  if (v43 << 16 < 0)
  {
    v57 = __maskrune(v56, 0x40000uLL);
    v43 = *((_DWORD *)this + 6);
  }
  else
  {
    v57 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v56 + 60) & 0x40000;
  }
  if (v57)
    v63 = ((__int16)v43 >> 8);
  else
    v63 = 46;
  if ((v43 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v43 + 60) & 0x40000) != 0)
      goto LABEL_79;
LABEL_81:
    v64 = 46;
    goto LABEL_82;
  }
  if (!__maskrune((char)v43, 0x40000uLL))
    goto LABEL_81;
LABEL_79:
  v64 = *((char *)this + 24);
LABEL_82:
  v15 = 4294967115;
  IIOXPCLog(" request not handled [%c%c%c%c] err=%d)\n", v49, v55, v63, v64, -181);
LABEL_107:
  iio_xpc_dictionary_set_error_code(v79, v15);
  if (v14)
    CFRelease(v14);
  if (Mutable)
    CFRelease(Mutable);
  if (DataFromXPCDict)
    CFRelease(DataFromXPCDict);
  if (v19)
    (*(void (**)(IIOImageSource *))(*(_QWORD *)v19 + 8))(v19);
  IIODictionary::~IIODictionary((IIODictionary *)v83);
  IIODictionary::~IIODictionary((IIODictionary *)v84);
  IIODictionary::~IIODictionary((IIODictionary *)v87);
  return v15;
}

void sub_187FA2B84(_Unwind_Exception *a1)
{
  uint64_t v1;

  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 160));
  _Unwind_Resume(a1);
}

void sub_187FA2BA4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  uint64_t v35;

  IIODictionary::~IIODictionary((IIODictionary *)&a35);
  IIODictionary::~IIODictionary((IIODictionary *)(v35 - 200));
  JUMPOUT(0x187FA2BB8);
}

uint64_t IIO_Reader::CopyIOSurfaceProc420f(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  _DWORD *exception;

  v6 = *(_QWORD *)(a1 + 8);
  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(_QWORD *)v6 + 72))(v6, a3))
  {
    exception = __cxa_allocate_exception(4uLL);
    *exception = -1;
    __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
  }
  v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v6 + 232))(v6, a1, a2, a3);
  (*(void (**)(uint64_t))(*(_QWORD *)v6 + 80))(v6);
  return v7;
}

void sub_187FA2C68(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187FA2C30);
}

uint64_t IIO_Reader::CopyIOSurfaceSetProc(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  _DWORD *exception;

  v6 = *(_QWORD *)(a1 + 8);
  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(_QWORD *)v6 + 72))(v6, a3))
  {
    exception = __cxa_allocate_exception(4uLL);
    *exception = -1;
    __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
  }
  v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v6 + 240))(v6, a1, a2, a3);
  (*(void (**)(uint64_t))(*(_QWORD *)v6 + 80))(v6);
  if ((gIIODebugFlags & 0x800000000000) != 0 && !v7)
    ImageIOLog(" ISSUE: %s:%d:  %s\n", "CopyIOSurfaceSetProc", 1682, "could not create CGImageIOSurfaceSetRef");
  return v7;
}

void sub_187FA2D5C(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187FA2CE4);
}

uint64_t IIO_Reader_BMP::createReadPlugin(IIO_Reader *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;

  v4 = operator new();
  v5 = IIO_Reader::osType(a1);
  BMPReadPlugin::BMPReadPlugin(v4, a2, v5);
  return v4;
}

void sub_187FA2DD0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40FF63E5E9);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_BMP::createReadPlugin(IIO_Reader *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8;
  int v9;

  v8 = operator new();
  v9 = IIO_Reader::osType(a1);
  BMPReadPlugin::BMPReadPlugin(v8, a2, a3, a4, v9);
  return v8;
}

void sub_187FA2E6C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40FF63E5E9);
  _Unwind_Resume(a1);
}

BOOL TIFFHashSetEqualPointer(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

BOOL TIFFHashSetRehash(uint64_t a1)
{
  int v2;
  _QWORD *v3;
  int v4;
  uint64_t i;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;

  v2 = anPrimes[*(int *)(a1 + 36)];
  v3 = malloc_type_calloc(v2, 8uLL, 0x2004093837F09uLL);
  if (v3)
  {
    v4 = *(_DWORD *)(a1 + 40);
    if (v4 >= 1)
    {
      for (i = 0; i < v4; ++i)
      {
        v6 = *(_QWORD **)(*(_QWORD *)(a1 + 24) + 8 * i);
        if (v6)
        {
          do
          {
            v7 = (*(uint64_t (**)(_QWORD))a1)(*v6);
            v8 = (_QWORD *)v6[1];
            v6[1] = v3[v7 % v2];
            v3[v7 % v2] = v6;
            v6 = v8;
          }
          while (v8);
          v4 = *(_DWORD *)(a1 + 40);
        }
      }
    }
    free(*(void **)(a1 + 24));
    *(_QWORD *)(a1 + 24) = v3;
    *(_DWORD *)(a1 + 40) = v2;
    *(_BYTE *)(a1 + 60) = 0;
  }
  return v3 != 0;
}

uint64_t TIFFHashSetRemove(uint64_t a1, uint64_t a2)
{
  int v4;
  BOOL v5;
  int v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  void (*v11)(_QWORD);
  int v12;
  uint64_t result;

  if (!a1)
    TIFFHashSetRemove_cold_1();
  v4 = *(_DWORD *)(a1 + 36);
  v5 = __OFSUB__(v4, 1);
  v6 = v4 - 1;
  if (v6 < 0 == v5 && *(_DWORD *)(a1 + 32) <= *(_DWORD *)(a1 + 40) / 2)
  {
    *(_DWORD *)(a1 + 36) = v6;
    if (!TIFFHashSetRehash(a1))
    {
      result = 0;
      ++*(_DWORD *)(a1 + 36);
      return result;
    }
  }
  v7 = (*(uint64_t (**)(uint64_t))a1)(a2) % (unint64_t)*(int *)(a1 + 40);
  v8 = *(_QWORD **)(*(_QWORD *)(a1 + 24) + 8 * (int)v7);
  if (!v8)
    return 0;
  if (((*(uint64_t (**)(_QWORD, uint64_t))(a1 + 8))(*v8, a2) & 1) == 0)
  {
    while (1)
    {
      v10 = v8;
      v8 = (_QWORD *)v8[1];
      if (!v8)
        return 0;
      if (((*(uint64_t (**)(_QWORD, uint64_t))(a1 + 8))(*v8, a2) & 1) != 0)
      {
        v9 = v10 + 1;
        goto LABEL_11;
      }
    }
  }
  v9 = (_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * (int)v7);
LABEL_11:
  *v9 = v8[1];
  v11 = *(void (**)(_QWORD))(a1 + 16);
  if (v11)
    v11(*v8);
  v12 = *(_DWORD *)(a1 + 56);
  if (v12 > 127)
  {
    free(v8);
  }
  else
  {
    v8[1] = *(_QWORD *)(a1 + 48);
    *(_QWORD *)(a1 + 48) = v8;
    *(_DWORD *)(a1 + 56) = v12 + 1;
  }
  --*(_DWORD *)(a1 + 32);
  return 1;
}

uint64_t CGImagePluginGetOptions(uint64_t a1)
{
  return *(_QWORD *)(IIOImagePlus::getOptions(*(IIOImagePlus **)(a1 + 24)) + 8);
}

uint64_t CGImagePluginGetProperties(uint64_t a1)
{
  return *(_QWORD *)(IIOImagePlus::getProperties(*(IIOImagePlus **)(a1 + 24)) + 8);
}

uint64_t CGImagePluginGetMetadata(uint64_t a1)
{
  return IIOImagePlus::getMetadata(*(IIOImagePlus **)(a1 + 24));
}

uint64_t CGImagePluginGetSession(uint64_t a1)
{
  return IIOImageSource::count(*(IIOImageSource **)(a1 + 24));
}

uint64_t CGImagePluginGetMatchToProfileOption(uint64_t a1)
{
  int MatchToProfileOption;
  uint64_t v2;

  MatchToProfileOption = IIOImagePlus::getMatchToProfileOption(*(IIOImagePlus **)(a1 + 24));
  v2 = MEMORY[0x1E0C9AE50];
  if (!MatchToProfileOption)
    v2 = MEMORY[0x1E0C9AE40];
  return *(_QWORD *)v2;
}

void CGImagePluginSetImageBlockProc(uint64_t a1, uint64_t a2, CFTypeRef *a3, uint64_t a4)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  CFTypeRef *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _OWORD v20[2];
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  int v25;
  int v26;
  int v27;
  int v28;

  if (a4)
  {
    v6 = *(_QWORD *)(a2 + 32);
    v7 = *(_DWORD *)(a2 + 40);
    v8 = *(_QWORD *)(a2 + 48);
    v9 = *(_DWORD *)(a2 + 56);
    v10 = *(_QWORD *)(a1 + 24);
    v11 = *(_OWORD *)(a2 + 16);
    v20[0] = *(_OWORD *)a2;
    v20[1] = v11;
    v21 = v6;
    v22 = v7;
    v23 = 0;
    v24 = v8;
    v25 = v9;
    v26 = v9 & 0xF0000;
    v27 = *(_DWORD *)(a2 + 60);
    v28 = 0;
    IIOImagePlus::setGeometry(v10, a3, (uint64_t)v20);
    switch(*(_DWORD *)a4)
    {
      case 0:
        _cg_jpeg_mem_term("CGImagePluginSetImageBlockProc", 186, "*** imageProvider callback version '0' no longer supported\n");
        return;
      case 1:
        v12 = *(_QWORD *)(a4 + 8);
        v13 = *(_QWORD *)(a4 + 16);
        v14 = v10;
        v15 = a3;
        v16 = 1;
        v17 = 0;
        goto LABEL_8;
      case 2:
        v12 = *(_QWORD *)(a4 + 8);
        v17 = *(_QWORD *)(a4 + 16);
        v13 = *(_QWORD *)(a4 + 24);
        v14 = v10;
        v15 = a3;
        v16 = 2;
LABEL_8:
        v18 = 0;
        v19 = 0;
        goto LABEL_10;
      case 3:
        v12 = *(_QWORD *)(a4 + 8);
        v17 = *(_QWORD *)(a4 + 16);
        v18 = *(_QWORD *)(a4 + 24);
        v19 = *(_QWORD *)(a4 + 32);
        v13 = *(_QWORD *)(a4 + 40);
        v14 = v10;
        v15 = a3;
        v16 = 3;
LABEL_10:
        IIOImagePlus::setImageBlockProc(v14, v15, (const void *)v16, v12, v17, v18, v19, v13);
        break;
      default:
        _cg_jpeg_mem_term("CGImagePluginSetImageBlockProc", 205, "*** unknown imageProvider callback version [%d]\n");
        break;
    }
  }
}

CGImageRef CGImagePluginSetImage(uint64_t a1, CGImage *a2)
{
  return IIOImagePlus::setImage(*(CGImageRef **)(a1 + 24), a2);
}

void CGImagePluginSetClipPath(uint64_t a1, const CGPath *a2)
{
  IIOImagePlus::setClipPath(*(IIOImagePlus **)(a1 + 24), a2);
}

uint64_t CGImagePluginSetJpegProvider(uint64_t a1, int a2)
{
  return IIOImagePlus::setJpegProvider(*(_QWORD *)(a1 + 24), a2);
}

__CFData *OFDCreatePDFDataFromURL(const __CFURL *a1)
{
  __CFData *v2;

  pthread_mutex_lock(&OFDCreatePDFDataFromURL::ofdLock);
  v2 = _OFDCreatePDFDataFromURL(a1);
  pthread_mutex_unlock(&OFDCreatePDFDataFromURL::ofdLock);
  return v2;
}

void ASTCWritePlugin::ASTCWritePlugin(ASTCWritePlugin *this, IIOImageWriteSession *a2, IIOImageDestination *a3, char a4)
{
  uint64_t v5;

  CommonASTCWritePlugin::CommonASTCWritePlugin(this, a2, a3, 2u);
  *(_QWORD *)v5 = &off_1E1BB00F8;
  *(_BYTE *)(v5 + 62) = a4;
  *(_BYTE *)(v5 + 60) = a4 ^ 1;
  *(_BYTE *)(v5 + 63) = 1;
  *(_QWORD *)(v5 + 64) = 0;
}

void ASTCWritePlugin::ASTCWritePlugin(CommonASTCWritePlugin *a1, IIOImageWriteSession *a2, IIOImageDestination *a3, uint64_t a4)
{
  uint64_t v5;

  CommonASTCWritePlugin::CommonASTCWritePlugin(a1, a2, a3, 2u);
  *(_QWORD *)v5 = &off_1E1BB00F8;
  *(_WORD *)(v5 + 62) = 256;
  *(_BYTE *)(v5 + 60) = 0;
  *(_QWORD *)(v5 + 64) = a4;
}

void ASTCWritePlugin::~ASTCWritePlugin(CommonASTCWritePlugin *this, uint64_t a2, const char *a3)
{
  *(_QWORD *)this = &off_1E1BB00F8;
  CommonASTCWritePlugin::~CommonASTCWritePlugin(this, a2, a3);
}

void ASTCWritePlugin::~ASTCWritePlugin(ASTCWritePlugin *this, uint64_t a2, const char *a3)
{
  *(_QWORD *)this = &off_1E1BB00F8;
  CommonASTCWritePlugin::~CommonASTCWritePlugin(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

const __CFDictionary *ASTCWritePlugin::handleProperties(ASTCWritePlugin *this, IIODictionary *a2)
{
  const __CFDictionary *result;

  result = CommonASTCWritePlugin::handleProperties(this, a2);
  *((_BYTE *)this + 58) = 0;
  if (a2)
    *((_BYTE *)this + 63) = 1;
  return result;
}

uint64_t ASTCWritePlugin::writeASTCHeader(IIOImageWriteSession **this, int a2, int a3, int a4, char a5, char a6)
{
  int v7;
  char v8;
  char v9;
  char v10;
  __int16 v11;
  char v12;
  __int16 v13;
  char v14;
  __int16 v15;
  char v16;

  v7 = 1554098963;
  v8 = a5;
  v9 = a6;
  v10 = 1;
  v11 = a2;
  v12 = BYTE2(a2);
  v13 = a3;
  v14 = BYTE2(a3);
  v15 = a4;
  v16 = BYTE2(a4);
  if (IIOImageWriteSession::putBytes(this[2], &v7, 0x10uLL) == 64)
    return 0;
  else
    return 4294967246;
}

uint64_t ASTCWritePlugin::writeOneImage(ASTCWritePlugin *this, CGImage *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

uint64_t ASTCWritePlugin::writeOne(ASTCWritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  int AlphaInfo;
  __int16 BitmapInfo;
  void *v8;
  uint64_t Property;
  unsigned int v10;
  const __CFNumber *v11;
  int v12;
  at_alpha_t v13;
  int v14;
  at_block_format_t v15;
  CGColorSpace *SourceGeomColorSpace;
  CGColorSpaceModel Model;
  int Error;
  int v19;
  BOOL v20;
  uint64_t v21;
  uint64_t v22;
  at_texel_format_t v23;
  unsigned int v24;
  unsigned int v25;
  int v26;
  int v27;
  NSObject *v28;
  char v29;
  float v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  void *v34;
  uint64_t v35;
  BOOL is_compression_monolithic;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unsigned int v40;
  uint64_t v41;
  char v42;
  uint64_t v43;
  unint64_t block_counts;
  size_t block_size;
  size_t v46;
  size_t v47;
  char *v48;
  BOOL v49;
  uint64_t v50;
  unsigned int v51;
  unsigned int v52;
  uint64_t v53;
  _BOOL4 LZFSECompressedData;
  _BOOL4 v55;
  int v56;
  char *error_string;
  IIOImageWriteSession *v59;
  unsigned __int8 *v60;
  size_t v61;
  size_t v62;
  char v63;
  int v64;
  at_flags_t v65;
  unsigned int v66;
  NSObject *v67;
  void *v68;
  char *v69;
  unsigned int v70;
  void *v71;
  void *v72;
  int v73;
  int __ptr;
  unint64_t v75;
  unsigned __int8 *v76[2];
  unint64_t v77;
  uint64_t v78;
  __int128 *p_imageSize;
  at_block_buffer_t dest;
  __int128 imageSize;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  _DWORD v86[7];
  uint64_t v87;
  at_size_t v88;

  (*(void (**)(ASTCWritePlugin *, IIODictionary *))(*(_QWORD *)this + 56))(this, a3);
  AlphaInfo = IIOImagePixelDataProvider::getAlphaInfo(a2);
  BitmapInfo = IIOImagePixelDataProvider::getBitmapInfo(a2);
  IIOImageSource::imageReadRef(a2);
  CGImageGetImageProvider();
  v8 = (void *)*MEMORY[0x1E0C9AE50];
  Property = CGImageProviderGetProperty();
  v10 = *((_DWORD *)this + 13);
  if (v8 == (void *)Property)
  {
    v11 = (const __CFNumber *)CGImageProviderGetProperty();
    if (v11)
    {
      IIONumber::IIONumber((IIONumber *)&imageSize, v11);
      v10 = IIONumber::uint32Num((IIONumber *)&imageSize);
      IIONumber::~IIONumber((IIONumber *)&imageSize);
    }
  }
  v12 = 0;
  v13 = at_alpha_premultiplied;
  switch(AlphaInfo)
  {
    case 0:
    case 5:
    case 6:
      goto LABEL_7;
    case 1:
    case 2:
      break;
    case 3:
    case 4:
      v13 = at_alpha_not_premultiplied;
      v12 = 1;
      break;
    default:
      _cg_jpeg_mem_term("writeOne", 179, "### alpha not handled: %X\n", AlphaInfo);
LABEL_7:
      v12 = 0;
      v13 = at_alpha_opaque;
      break;
  }
  v14 = *((_DWORD *)this + 11);
  v68 = (void *)Property;
  v64 = v12;
  if (v14 == 68)
  {
    v63 = 4;
  }
  else
  {
    if (v14 == 136)
    {
      v63 = 8;
      v15 = at_block_format_astc_8x8_ldr;
      goto LABEL_14;
    }
    LogError("writeOne", 202, "blockSize: '%02X' not yet supported - falling back to '44'\n", v14);
    *(_QWORD *)((char *)this + 44) = 0x400000044;
    v63 = 4;
    *((_DWORD *)this + 13) = 4;
  }
  v15 = at_block_format_astc_4x4_ldr;
LABEL_14:
  SourceGeomColorSpace = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(a2);
  Model = CGColorSpaceGetModel(SourceGeomColorSpace);
  Error = _cg_GifLastError((uint64_t)a2);
  v71 = v8;
  v66 = v10;
  if (Model == kCGColorSpaceModelRGB)
  {
    v22 = 7;
    if ((BitmapInfo & 0x100) != 0)
      v22 = 10;
    v20 = Error == 16;
    v19 = (Error == 16) & ((unsigned __int16)(BitmapInfo & 0x100) >> 8);
    v21 = 5;
    goto LABEL_21;
  }
  if (Model)
  {
    LOBYTE(v19) = 0;
    v23 = at_texel_format_invalid;
    Model = kCGColorSpaceModelRGB;
    goto LABEL_28;
  }
  if (Error == 16)
  {
    LOBYTE(v19) = 0;
    Model = kCGColorSpaceModelMonochrome;
    v20 = AlphaInfo == 0;
    v21 = 4;
    v22 = 2;
LABEL_21:
    if (v20)
      v23 = v22;
    else
      v23 = v21;
    goto LABEL_28;
  }
  LOBYTE(v19) = 0;
  Model = kCGColorSpaceModelMonochrome;
  if (AlphaInfo)
    v23 = at_texel_format_la8_unorm;
  else
    v23 = at_texel_format_l8_unorm;
LABEL_28:
  v70 = IIOImageSource::count(a2);
  v24 = IIO_Reader::testHeaderSize(a2);
  if (*((_BYTE *)this + 62))
  {
    if (Model)
    {
      if (IIO_CGColorSpaceNameMatchesName(SourceGeomColorSpace, (const __CFString *)*MEMORY[0x1E0C9D908]))
      {
        v25 = 3;
      }
      else if (IIO_CGColorSpaceNameMatchesName(SourceGeomColorSpace, (const __CFString *)*MEMORY[0x1E0C9D8F8]))
      {
        v25 = 2;
      }
      else
      {
        v25 = 1;
      }
    }
    else
    {
      v25 = 0;
    }
    v26 = 0;
    v27 = *((_DWORD *)this + 11);
    if (v27 > 135)
    {
      if (v27 > 201)
      {
        if (v27 == 202)
        {
          v26 = 37820;
        }
        else if (v27 == 204)
        {
          v26 = 37821;
        }
      }
      else
      {
        switch(v27)
        {
          case 165:
            v26 = 37816;
            break;
          case 166:
          case 168:
            v26 = 37817;
            break;
          case 167:
          case 169:
            break;
          case 170:
            v26 = 37818;
            break;
          default:
            if (v27 == 136)
              v26 = 37815;
            break;
        }
      }
    }
    else if (v27 <= 100)
    {
      switch(v27)
      {
        case 'D':
          v26 = 37808;
          break;
        case 'T':
          v26 = 37809;
          break;
        case 'U':
          v26 = 37810;
          break;
      }
    }
    else if (v27 > 132)
    {
      if (v27 == 133)
      {
        v26 = 37813;
      }
      else if (v27 == 134)
      {
        v26 = 37814;
      }
    }
    else if (v27 == 101)
    {
      v26 = 37811;
    }
    else if (v27 == 102)
    {
      v26 = 37812;
    }
    KTXWritePlugin::writeKTXHeader(*((IIOImageWriteSession **)this + 2), v70, v24, 0, v25, AlphaInfo, 0, 1, 0, v26, *((_BYTE *)this + 57), *((_BYTE *)this + 63));
  }
  v28 = at_encoder_create(v23, v13, v15, v13, 0);
  v87 = 0;
  if (*((_BYTE *)this + 56))
  {
    v29 = v19 ^ 1;
    if (*((_BYTE *)this + 60))
      v29 = 1;
    if ((v29 & 1) == 0)
    {
      v30 = (float)((float)(*((float *)this + 10) / -0.0032) + 1.0) * 100.0;
      v85 = 0u;
      memset(v86, 0, sizeof(v86));
      v83 = 0u;
      v84 = 0u;
      imageSize = 0u;
      v82 = 0u;
      if (astcenc_config_init(3u, *((_DWORD *)this + 12), *((_DWORD *)this + 13), 1u, 0, (uint64_t)&imageSize, v30))
      {
        LogError("writeOne", 323, "*** could not initialize astcenc codec\n");
LABEL_78:
        v34 = 0;
        v72 = 0;
LABEL_79:
        v35 = 0;
        goto LABEL_124;
      }
      v31 = IIOImagePlus::sourceImageProvider(a2);
      v32 = 8 * v70;
      if (v31 != v32)
        ASTCTextureImp::setLock_dataSize((uint64_t)a2, v32);
      if (!*((_BYTE *)this + 61))
      {
        v33 = DWORD1(imageSize);
        DWORD1(imageSize) |= 8u;
        if (v64)
          DWORD1(imageSize) = v33 | 0xC;
      }
      if (astcenc_context_alloc((uint64_t)&imageSize, 1u, &v87))
      {
        LogError("writeOne", 339, "*** could not allocate astcenc context\n");
        goto LABEL_78;
      }
    }
  }
  if (!v28)
  {
    v35 = 0;
    v72 = 0;
    v34 = 0;
    goto LABEL_126;
  }
  is_compression_monolithic = at_encoder_is_compression_monolithic(v28, at_flags_default);
  v37 = IIOImagePlus::sourceImageProvider(a2);
  v38 = v37;
  *(_QWORD *)&v83 = 0;
  imageSize = 0u;
  v82 = 0u;
  memset(&dest, 0, sizeof(dest));
  v77 = 0;
  v78 = 0;
  p_imageSize = 0;
  if (v71 != v68 || is_compression_monolithic)
  {
    v39 = v24;
    v40 = v70;
  }
  else
  {
    v39 = v24;
    v40 = v70;
    if (!*((_BYTE *)this + 60))
    {
      v41 = v66;
      do
      {
        v39 = v41;
        v42 = v41 * v70;
        v41 *= 2;
      }
      while ((v42 & 0xF) != 0);
    }
  }
  v43 = v39 * v37;
  v72 = malloc_type_malloc(v39 * v37, 0xAE4BB495uLL);
  *(_QWORD *)&imageSize = 0;
  *((_QWORD *)&imageSize + 1) = __PAIR64__(v24, v40);
  LODWORD(v82) = 1;
  *((_QWORD *)&v82 + 1) = v38;
  *(_QWORD *)&v83 = 0;
  v77 = __PAIR64__(v24, v40);
  v78 = 0x100000001;
  *(_QWORD *)&v88.x = __PAIR64__(v24, v40);
  v88.z = 1;
  block_counts = (unint64_t)at_encoder_get_block_counts(v28, v88);
  v67 = v28;
  block_size = at_encoder_get_block_size(v28);
  v46 = block_counts * block_size;
  v47 = (HIDWORD(block_counts) * block_counts) * block_size;
  dest.rowBytes = v46;
  dest.sliceBytes = v47;
  v48 = (char *)malloc_type_calloc(v47, 1uLL, 0x5C2AC7E0uLL);
  v34 = v48;
  if (v47)
    v49 = v48 == 0;
  else
    v49 = 1;
  if (v49)
  {
    LogError("writeOne", 395, "*** could not allocate dest buffer [%d bytes]\n", v47);
    v35 = 0;
    goto LABEL_124;
  }
  v69 = v48;
  dest.blocks = v48;
  v50 = 16 * *((unsigned __int8 *)this + 60);
  if (*((_BYTE *)this + 61))
    v50 |= 0x40uLL;
  v65 = v50;
  if (!v24)
  {
LABEL_107:
    v53 = *((_QWORD *)this + 8);
    if (v53)
    {
      v35 = 4294967246;
      v28 = v67;
      v34 = v69;
      if ((*(uint64_t (**)(void))(*(_QWORD *)(v53 + 8) + 24))() == v47)
      {
        if ((*(unsigned int (**)(void))(*(_QWORD *)(*((_QWORD *)this + 8) + 8) + 64))())
          v35 = 4294967246;
        else
          v35 = 0;
      }
      goto LABEL_124;
    }
    v28 = v67;
    v34 = v69;
    if (!*((_BYTE *)this + 62))
    {
      *((_BYTE *)this + 57) = 0;
      ASTCWritePlugin::writeASTCHeader((IIOImageWriteSession **)this, v70, v24, 1, v63, v63);
      IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), v69, v47);
      goto LABEL_79;
    }
    v75 = 0;
    v76[0] = 0;
    if (*((_BYTE *)this + 57))
    {
      LZFSECompressedData = IIOWritePlugin::createLZFSECompressedData(this, (unsigned __int8 *)v69, v47, v76, (unsigned __int8 **)&v75);
      v55 = LZFSECompressedData;
      v56 = v75;
      if (v75 < 9 || *(_DWORD *)v76[0] == 846755426 && *(_DWORD *)&v76[0][v75 - 4] == 611874402)
      {
        if (LZFSECompressedData)
        {
          v35 = 0;
          goto LABEL_135;
        }
      }
      else
      {
        _cg_jpeg_mem_term("writeOne", 490, "    ERROR: bad LZFSE data (does not start/end with 'bvx2'/'bvx$')\n");
        if (v55)
        {
          v35 = 4294967246;
          v56 = v75;
LABEL_135:
          __ptr = v56 + 8;
          IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), &__ptr, 4uLL);
          if ((gIIODebugFlags & 0x30000) != 0)
          {
            ImageIOLog("    KTX with LZFSE compressed ASTC data\n");
            if ((gIIODebugFlags & 0x30000) != 0)
            {
              ImageIOLog("            compressedLZFSEData: %p\n", v76[0]);
              if ((gIIODebugFlags & 0x30000) != 0)
              {
                ImageIOLog("            compressedLZFSESize: %d\n", v75);
                if ((gIIODebugFlags & 0x30000) != 0)
                  ImageIOLog("                           type: 'LZFS'\n");
              }
            }
          }
          v73 = 1397119564;
          IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), &v73, 4uLL);
          IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), &v75, 4uLL);
          v59 = (IIOImageWriteSession *)*((_QWORD *)this + 2);
          v61 = v75;
          v60 = v76[0];
          goto LABEL_146;
        }
      }
    }
    __ptr = v47;
    v62 = IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), &__ptr, 4uLL);
    if (v62 == 4)
      v35 = 0;
    else
      v35 = 4294967246;
    if (v62 != 4)
    {
LABEL_147:
      if (v76[0])
        free(v76[0]);
      goto LABEL_124;
    }
    v59 = (IIOImageWriteSession *)*((_QWORD *)this + 2);
    v60 = (unsigned __int8 *)v69;
    v61 = v47;
LABEL_146:
    IIOImageWriteSession::putBytes(v59, v60, v61);
    goto LABEL_147;
  }
  v51 = 0;
  while (1)
  {
    if (v39 + (unint64_t)v51 > v24)
    {
      v39 = v24 - v51;
      v43 = v38 * v39;
    }
    HIDWORD(imageSize) = v39;
    *(_QWORD *)&imageSize = v72;
    if (IIOImagePixelDataProvider::getBytes((uint64_t (**)(IIOImagePixelDataProvider *, void *))a2, v72) != v43)
    {
      LogError("writeOne", 425, "failed to read %ld bytes\n");
      goto LABEL_122;
    }
    dest.blocks = &v69[dest.rowBytes * (v51 / *((_DWORD *)this + 13))];
    if (!v87)
      break;
    HIDWORD(v77) = v39;
    p_imageSize = &imageSize;
    *(_OWORD *)v76 = xmmword_18820BF90;
    v52 = astcenc_compress_image(v87, (uint64_t)&v77);
    if (v52)
    {
      error_string = astcenc_get_error_string(v52);
      LogError("writeOne", 441, "*** ERROR: astcenc codec compress failed: %s\n", error_string);
      v35 = 0;
      goto LABEL_123;
    }
LABEL_106:
    v51 += v39;
    if (v51 >= v24)
      goto LABEL_107;
  }
  if (at_encoder_compress_texels(v67, (const at_texel_region_t *)&imageSize, &dest, *((float *)this + 10), v65) >= 0.0)
    goto LABEL_106;
  LogError("writeOne", 448, "*** ERROR: at_encoder_compress_texels: %g (%ld)\n");
LABEL_122:
  v35 = 4294967246;
LABEL_123:
  v28 = v67;
  v34 = v69;
LABEL_124:
  if (v28)
    CFRelease(v28);
LABEL_126:
  if (v87)
    astcenc_context_free(v87);
  if (v34)
    free(v34);
  if (v72)
    free(v72);
  return v35;
}

void sub_187FA3EA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  IIONumber::~IIONumber((IIONumber *)&a27);
  _Unwind_Resume(a1);
}

uint64_t ASTCWritePlugin::GetVkFormat(ASTCWritePlugin *this, IIODictionary *a2)
{
  _BOOL4 v3;
  _BOOL4 BoolForKey;
  unsigned int v5;
  unsigned int v6;

  if (IIODictionary::containsKey(this, CFSTR("kCGImagePropertyASTCBlockSize")))
    v3 = IIODictionary::getUint32ForKey(this, CFSTR("kCGImagePropertyASTCBlockSize")) == 136;
  else
    v3 = 0;
  BoolForKey = IIODictionary::getBoolForKey(this, CFSTR("kCGImagePropertyASTCUseHDR"));
  if (BoolForKey)
    v5 = 1000066007;
  else
    v5 = 172;
  if (BoolForKey)
    v6 = 1000066000;
  else
    v6 = 158;
  if (v3)
    return v5;
  else
    return v6;
}

void IIO_Writer_ASTC::~IIO_Writer_ASTC(IIO_Writer_ASTC *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

uint64_t IIO_Writer_ASTC::write(IIO_Writer_ASTC *this, IIOImageWriteSession *a2, IIOImageDestination *a3)
{
  uint64_t v3;
  uint64_t v4;
  const char *v5;
  _OWORD v7[3];
  __int128 v8;
  uint64_t v9;

  v9 = 0;
  v8 = 0u;
  memset(v7, 0, sizeof(v7));
  CommonASTCWritePlugin::CommonASTCWritePlugin((CommonASTCWritePlugin *)v7, a2, a3, 2u);
  *(_QWORD *)&v7[0] = &off_1E1BB00F8;
  HIWORD(v8) = 256;
  BYTE12(v8) = 1;
  v9 = 0;
  v3 = IIOWritePlugin::writeAll((IIOImageDestination **)v7);
  *(_QWORD *)&v7[0] = &off_1E1BB00F8;
  CommonASTCWritePlugin::~CommonASTCWritePlugin((CommonASTCWritePlugin *)v7, v4, v5);
  return v3;
}

void sub_187FA3FE0(void *a1, uint64_t a2, const char *a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  CommonASTCWritePlugin::~CommonASTCWritePlugin((CommonASTCWritePlugin *)&a9, a2, a3);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187FA3FCCLL);
}

uint64_t IIO_Writer::createWritePlugin(IIO_Writer *this, void *a2, void *a3)
{
  return 0;
}

uint64_t IIOFrameBufferQueue::IIOFrameBufferQueue(uint64_t a1, uint64_t a2, unint64_t a3, const void *a4)
{
  void **v7;
  uint64_t v8;
  int v9;
  NSObject *v10;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *(*v16)@<X0>(uint64_t@<X0>, uint64_t@<X8>);
  uint64_t v17;
  uint64_t (*v18)(uint64_t, uint64_t);
  uint64_t v19;
  uint64_t (*v20)();

  *(_QWORD *)a1 = &off_1E1BB1B38;
  *(_QWORD *)(a1 + 8) = 0;
  v7 = (void **)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  v8 = a1 + 16;
  *(_QWORD *)(a1 + 32) = a2;
  *(_BYTE *)(a1 + 40) = 0;
  *(_BYTE *)(a1 + 224) = 0;
  *(_BYTE *)(a1 + 344) = 0;
  *(_QWORD *)(a1 + 408) = 0;
  *(_QWORD *)(a1 + 416) = 0;
  IIO_LoadCoreMediaSymbols();
  if (a4)
    *v7 = _Block_copy(a4);
  *(_DWORD *)(a1 + 24) = 0;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 48), 0);
  pthread_cond_init((pthread_cond_t *)(a1 + 112), 0);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 160), 0);
  pthread_cond_init((pthread_cond_t *)(a1 + 232), 0);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 280), 0);
  pthread_cond_init((pthread_cond_t *)(a1 + 352), 0);
  v12 = 1;
  v13 = a1;
  v14 = 0;
  v15 = 0;
  v16 = getBufferDurationCallback;
  v17 = 0;
  v18 = compareBuffersCallback;
  v19 = 0;
  v20 = getBufferSizeCallback;
  v9 = gFunc_CMBufferQueueCreate(*MEMORY[0x1E0C9AE00], 0, &v12, v8);
  if (v9)
  {
    if ((gIIODebugFlags & 0x1000000000000) != 0)
      ImageIOLog("*** CMBufferQueueCreate failed (status = %d)\n", v9);
  }
  else
  {
    if (a3 <= 1)
      a3 = 1;
    v10 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
    *(_QWORD *)(a1 + 400) = dispatch_queue_create("IIOFrameBufferQueue::producerQueue", v10);
    gFunc_CMBufferQueueInstallTriggerWithIntegerThreshold(*(_QWORD *)(a1 + 16), triggerFiredCallback, a1, 10, a3, a1 + 408);
    gFunc_CMBufferQueueInstallTriggerWithIntegerThreshold(*(_QWORD *)(a1 + 16), triggerFiredCallback, a1, 11, a3 - 1, a1 + 416);
  }
  return a1;
}

const char *getBufferDurationCallback@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return IIOFrameBufferQueue::_getBufferDuration(a1, a2);
}

uint64_t compareBuffersCallback(uint64_t a1, uint64_t a2)
{
  uint64_t FrameIndex;
  uint64_t v4;

  FrameIndex = IIOFrameBufferGetFrameIndex(a1);
  v4 = IIOFrameBufferGetFrameIndex(a2);
  if (FrameIndex < v4)
    return -1;
  else
    return FrameIndex > v4;
}

void IIOFrameBufferQueue::~IIOFrameBufferQueue(NSObject **this)
{
  NSObject *v2;
  NSObject *v3;
  NSObject *v4;

  *this = &off_1E1BB1B38;
  IIOFrameBufferQueue::stop((IIOFrameBufferQueue *)this);
  v2 = this[50];
  if (v2)
    dispatch_release(v2);
  v3 = this[2];
  if (v3)
    CFRelease(v3);
  v4 = this[1];
  if (v4)
    _Block_release(v4);
}

{
  IIOFrameBufferQueue::~IIOFrameBufferQueue(this);
  JUMPOUT(0x18D761C30);
}

uint64_t IIOFrameBufferQueue::stop(IIOFrameBufferQueue *this)
{
  if ((gIIODebugFlags & 0x1000000000000) != 0)
    ImageIOLog("    IIOFrameBufferQueue::stop()\n");
  atomic_store(1u, (unsigned __int8 *)this + 40);
  gFunc_CMBufferQueueReset(*((_QWORD *)this + 2));
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 160));
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 48));
  *((_BYTE *)this + 224) = 1;
  pthread_cond_broadcast((pthread_cond_t *)((char *)this + 232));
  pthread_cond_broadcast((pthread_cond_t *)((char *)this + 112));
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 160));
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 48));
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 280));
  while (*((_BYTE *)this + 344))
    pthread_cond_wait((pthread_cond_t *)((char *)this + 352), (pthread_mutex_t *)((char *)this + 280));
  return pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 280));
}

void IIOFrameBufferQueue::startEnqueueingBuffers(IIOFrameBufferQueue *this, uint64_t a2)
{
  const char *v3;
  int v4;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  _QWORD v11[6];
  _QWORD block[6];

  if (!*((_QWORD *)this + 1))
  {
    v3 = "CreateBuffers block is NULL\n";
    v4 = 85;
    goto LABEL_5;
  }
  if (*((_BYTE *)this + 344))
  {
    v3 = "Error: startEnqueueingBuffers called on already running queue\n";
    v4 = 89;
LABEL_5:
    LogError("startEnqueueingBuffers", v4, v3);
    return;
  }
  v6 = *((_QWORD *)this + 4);
  if (v6 <= a2)
  {
    LogError("startEnqueueingBuffers", 93, "Starting index: (%ld) out of range: (%d, %ld)\n", a2, 0, v6);
  }
  else
  {
    v7 = dispatch_group_create();
    v8 = *((_QWORD *)this + 50);
    v9 = MEMORY[0x1E0C809B0];
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ___ZN19IIOFrameBufferQueue22startEnqueueingBuffersEl_block_invoke;
    block[3] = &__block_descriptor_tmp_5;
    block[4] = this;
    block[5] = a2;
    dispatch_group_async(v7, v8, block);
    v10 = *((_QWORD *)this + 50);
    v11[0] = v9;
    v11[1] = 0x40000000;
    v11[2] = ___ZN19IIOFrameBufferQueue22startEnqueueingBuffersEl_block_invoke_2;
    v11[3] = &__block_descriptor_tmp_6;
    v11[4] = this;
    v11[5] = v7;
    dispatch_group_notify(v7, v10, v11);
  }
}

void ___ZN19IIOFrameBufferQueue22startEnqueueingBuffersEl_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  unsigned __int8 v3;
  unsigned __int8 v4;
  const __CFArray *v5;
  CFIndex Count;
  unsigned __int8 v7;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(_QWORD *)(a1 + 40);
  atomic_store(0, (unsigned __int8 *)(v1 + 40));
  *(_BYTE *)(v1 + 344) = 1;
  v3 = atomic_load((unsigned __int8 *)(v1 + 40));
  if ((v3 & 1) == 0)
  {
    while (1)
    {
      pthread_mutex_lock((pthread_mutex_t *)(v1 + 160));
      while (!*(_BYTE *)(v1 + 224))
        pthread_cond_wait((pthread_cond_t *)(v1 + 232), (pthread_mutex_t *)(v1 + 160));
      pthread_mutex_unlock((pthread_mutex_t *)(v1 + 160));
      v4 = atomic_load((unsigned __int8 *)(v1 + 40));
      if ((v4 & 1) == 0)
      {
        v5 = (const __CFArray *)(*(uint64_t (**)(void))(*(_QWORD *)(v1 + 8) + 16))();
        Count = CFArrayGetCount(v5);
        IIOFrameBufferQueue::_enqueueBuffers((IIOFrameBufferQueue *)v1, v5);
        CFRelease(v5);
        v2 += Count;
        if (v2 >= *(_QWORD *)(v1 + 32))
          break;
      }
      v7 = atomic_load((unsigned __int8 *)(v1 + 40));
      if ((v7 & 1) != 0)
        return;
    }
    gFunc_CMBufferQueueMarkEndOfData(*(_QWORD *)(v1 + 16));
  }
}

uint64_t IIOFrameBufferQueue::_enqueueBuffers(IIOFrameBufferQueue *this, const __CFArray *a2)
{
  pthread_mutex_t *v4;
  _QWORD v6[5];

  v4 = (pthread_mutex_t *)((char *)this + 48);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 48));
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = ___ZN19IIOFrameBufferQueue15_enqueueBuffersEPK9__CFArray_block_invoke;
  v6[3] = &__block_descriptor_tmp_12_0;
  v6[4] = this;
  IIOArrayEnumerateUsingBlock((uint64_t)a2, (uint64_t)v6);
  pthread_cond_broadcast((pthread_cond_t *)((char *)this + 112));
  return pthread_mutex_unlock(v4);
}

void ___ZN19IIOFrameBufferQueue22startEnqueueingBuffersEl_block_invoke_2(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(v2 + 280));
  *(_BYTE *)(v2 + 344) = 0;
  pthread_cond_broadcast((pthread_cond_t *)(v2 + 352));
  pthread_mutex_unlock((pthread_mutex_t *)(v2 + 280));
  dispatch_release(*(dispatch_object_t *)(a1 + 40));
}

const void *IIOFrameBufferQueue::getAndRetainBufferAtIndex(os_unfair_lock_s *this, uint64_t a2)
{
  os_unfair_lock_s *v4;
  const void *HeadBuffer;
  uint64_t FrameIndex;
  const void *v7;
  uint64_t v8;

  if (*(_QWORD *)&this[8]._os_unfair_lock_opaque > a2)
  {
    v4 = this + 6;
    os_unfair_lock_lock(this + 6);
    HeadBuffer = (const void *)IIOFrameBufferQueue::_getHeadBuffer((IIOFrameBufferQueue *)this);
    FrameIndex = IIOFrameBufferGetFrameIndex((uint64_t)HeadBuffer);
    if (FrameIndex <= a2)
    {
      if (FrameIndex != -1 && FrameIndex >= a2)
      {
LABEL_11:
        IIOFrameBufferRetain(HeadBuffer);
        os_unfair_lock_unlock(v4);
        return HeadBuffer;
      }
    }
    else
    {
      if (a2)
        LogWarning("getAndRetainBufferAtIndex", 155, "ImageIO IIOFrameBufferQueue: requesting an out-of-sequence frame\n");
      IIOFrameBufferQueue::stop((IIOFrameBufferQueue *)this);
      IIOFrameBufferQueue::startEnqueueingBuffers((IIOFrameBufferQueue *)this, a2);
    }
    do
    {
      do
      {
        v7 = (const void *)gFunc_CMBufferQueueDequeueAndRetain(*(_QWORD *)&this[4]._os_unfair_lock_opaque);
        IIOFrameBufferRelease(v7);
        HeadBuffer = (const void *)IIOFrameBufferQueue::_getHeadBuffer((IIOFrameBufferQueue *)this);
        v8 = IIOFrameBufferGetFrameIndex((uint64_t)HeadBuffer);
      }
      while (v8 == -1);
    }
    while (v8 < a2);
    goto LABEL_11;
  }
  return 0;
}

uint64_t IIOFrameBufferQueue::_getHeadBuffer(IIOFrameBufferQueue *this)
{
  pthread_mutex_t *v2;

  v2 = (pthread_mutex_t *)((char *)this + 48);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 48));
  while (gFunc_CMBufferQueueIsEmpty(*((_QWORD *)this + 2)))
  {
    if (gFunc_CMBufferQueueIsAtEndOfData(*((_QWORD *)this + 2)))
      break;
    if ((gIIODebugFlags & 0x1000000000000) != 0)
      ImageIOLog("    Starting to wait on _isEmptyCond\n");
    pthread_cond_wait((pthread_cond_t *)((char *)this + 112), v2);
  }
  pthread_mutex_unlock(v2);
  return gFunc_CMBufferQueueGetHead(*((_QWORD *)this + 2));
}

const char *IIOFrameBufferQueue::_getBufferDuration@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  const char *result;

  IIOFrameBufferGetDelayTime(a1);
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  result = (const char *)gFunc_CMTimeMakeWithSeconds(1000);
  if ((gIIODebugFlags & 0x1000000000000) != 0)
  {
    if ((*(_DWORD *)(a2 + 12) & 1) != 0)
      return ImageIOLog("    DelayTime: %g\n");
    else
      return ImageIOLog("*** Failed to create CMTime (%g) for buffer\n");
  }
  return result;
}

uint64_t IIOFrameBufferQueue::_triggerFired(uint64_t this, opaqueCMBufferQueueTriggerToken *a2)
{
  uint64_t v2;
  char v3;
  const char *v4;
  uint64_t BufferCount;

  v2 = this;
  if (*(opaqueCMBufferQueueTriggerToken **)(this + 408) == a2)
  {
    v3 = 1;
    if ((gIIODebugFlags & 0x1000000000000) != 0)
    {
      v4 = "    Trigger fired: _bufferQueueHitLowWaterMarkToken. Count = %ld\n";
LABEL_8:
      BufferCount = gFunc_CMBufferQueueGetBufferCount(*(_QWORD *)(this + 16));
      ImageIOLog(v4, BufferCount);
    }
LABEL_9:
    pthread_mutex_lock((pthread_mutex_t *)(v2 + 160));
    *(_BYTE *)(v2 + 224) = v3;
    pthread_cond_broadcast((pthread_cond_t *)(v2 + 232));
    return pthread_mutex_unlock((pthread_mutex_t *)(v2 + 160));
  }
  if (*(opaqueCMBufferQueueTriggerToken **)(this + 416) == a2)
  {
    v3 = 0;
    if ((gIIODebugFlags & 0x1000000000000) != 0)
    {
      v4 = "    Trigger fired: _bufferQueueClearedLowWaterMarkToken. Count = %ld\n";
      goto LABEL_8;
    }
    goto LABEL_9;
  }
  return this;
}

double PNGReadPlugin::PNGReadPlugin(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  double result;

  v3 = IIOReadPlugin::IIOReadPlugin(a1, a2, a3);
  *(_QWORD *)v3 = &off_1E1BAD7B8;
  result = 0.0;
  *(_OWORD *)(v3 + 440) = 0u;
  *(_OWORD *)(v3 + 456) = 0u;
  *(_OWORD *)(v3 + 472) = 0u;
  *(_OWORD *)(v3 + 488) = 0u;
  *(_OWORD *)(v3 + 504) = 0u;
  return result;
}

uint64_t PNGReadPlugin::loadDataFromXPCObject(PNGReadPlugin *this, void *a2)
{
  uint64_t result;

  result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!(_DWORD)result)
    return PNGReadPlugin::LoadDataFromXPCObject(a2, (PNGReadPlugin *)((char *)this + 440));
  return result;
}

uint64_t PNGReadPlugin::LoadDataFromXPCObject(void *a1, _OWORD *a2)
{
  __int128 *data;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  unsigned int *v9;
  const void *v10;
  void *v11;
  size_t size;
  size_t length;

  length = 0;
  data = (__int128 *)xpc_dictionary_get_data(a1, "iio_xpc_plugin_data_png", &length);
  if (length != 80)
    return 4294967246;
  v5 = data[1];
  v6 = data[2];
  v7 = data[4];
  a2[3] = data[3];
  a2[4] = v7;
  v8 = *data;
  a2[1] = v5;
  a2[2] = v6;
  *a2 = v8;
  *((_QWORD *)a2 + 8) = 0;
  *((_QWORD *)a2 + 6) = 0;
  size = 0;
  v9 = (unsigned int *)xpc_dictionary_get_data(a1, "iio_xpc_plugin_data_png_idot", &size);
  if (v9)
  {
    v10 = v9;
    if (size >= 4 && size == 12 * *v9 + 4)
    {
      v11 = malloc_type_malloc(size, 0xB8E1E74CuLL);
      *((_QWORD *)a2 + 6) = v11;
      memcpy(v11, v10, size);
    }
  }
  return 0;
}

uint64_t PNGReadPlugin::saveDataToXPCObject(PNGReadPlugin *this, void *a2)
{
  uint64_t v4;

  v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!(_DWORD)v4)
    PNGReadPlugin::SaveDataToXPCObject(a2, (char *)this + 440);
  return v4;
}

uint64_t PNGReadPlugin::SaveDataToXPCObject(void *a1, void *buffer)
{
  _DWORD *v4;

  iio_xpc_dictionary_add_databuffer(a1, "iio_xpc_plugin_data_png", buffer, 0x50uLL);
  v4 = (_DWORD *)*((_QWORD *)buffer + 6);
  if (v4)
    iio_xpc_dictionary_add_databuffer(a1, "iio_xpc_plugin_data_png_idot", v4, (12 * *v4 + 4));
  return 0;
}

uint64_t PNGReadPlugin::Read_user_chunkapPD(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  CFIndex v5;

  v3 = *(_QWORD *)(a3 + 16);
  if (v3 >= 0xD)
  {
    v4 = *(_QWORD *)(a3 + 8);
    if (*(_DWORD *)(v4 + 4) == 1953057648)
    {
      v5 = bswap32(*(_DWORD *)(v4 + 8));
      if (v5 + 12 <= v3)
        *(_QWORD *)(a1 + 64) = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)(v4 + 12), v5);
      else
        _cg_jpeg_mem_term("Read_user_chunkapPD", 770, "bad chunk-size in pKit data\n");
    }
  }
  return 1;
}

void *PNGReadPlugin::HexString2bin(PNGReadPlugin *this, size_t size)
{
  void *v4;
  void *v5;
  size_t v6;
  _BYTE *v7;
  int v8;
  char v9;
  char __str[2];
  char v12;
  char *__endptr;

  v4 = malloc_type_malloc(size, 0x55ED00FEuLL);
  v5 = v4;
  if (v4)
  {
    v6 = 0;
    if (size)
    {
      v7 = v4;
      do
      {
        if (!*(_BYTE *)this)
          break;
        __endptr = 0;
        v12 = 0;
        *(_WORD *)__str = 0;
        v8 = *(unsigned __int8 *)this;
        if (v8 != 10)
        {
          v9 = *((_BYTE *)this + 1);
          this = (PNGReadPlugin *)((char *)this + 1);
          __str[0] = v8;
          __str[1] = v9;
          v12 = 0;
          *v7++ = strtol(__str, &__endptr, 16);
          if (__endptr != &v12)
            break;
          ++v6;
        }
        this = (PNGReadPlugin *)((char *)this + 1);
      }
      while (v6 < size);
    }
    if (v6 != size)
    {
      free(v5);
      return 0;
    }
  }
  return v5;
}

uint64_t ___ZN13PNGReadPlugin24AddOrientationToMetadataEP13IIODictionaryS1_P15CGImageMetadataP14png_struct_defP12png_info_def_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t v4;

  if (*(_WORD *)(a2 + 8) == 274)
  {
    v4 = *(_QWORD *)(*(_QWORD *)(result + 32) + 8);
    if (!*(_DWORD *)(v4 + 24))
    {
      *(_DWORD *)(v4 + 24) = *(_DWORD *)(a2 + 16);
      *a4 = 1;
    }
  }
  return result;
}

void handle_error(uint64_t a1, const char *a2)
{
  _DWORD *exception;

  if (a2)
  {
    if (*a2)
      LogError("handle_error", 268, "%s\n", a2);
  }
  exception = __cxa_allocate_exception(4uLL);
  *exception = -1;
  __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
}

uint64_t imagePNG_error_break(uint64_t a1)
{
  uint64_t result;

  LogError("imagePNG_error_break", 384, "*** ERROR: imagePNG_error_break\n");
  *gCrashMessage = 0;
  if (a1)
    result = snprintf(gCrashMessage, 0x200uLL, "*** ERROR: PNG decode  %dx%d  bpc: %d  cs: %d\n", *(_DWORD *)(a1 + 280), *(_DWORD *)(a1 + 284), *(unsigned __int8 *)(a1 + 392), *(unsigned __int8 *)(a1 + 391));
  else
    result = snprintf(gCrashMessage, 0x200uLL, "*** ERROR: PNG decode failed ('png' is NULL)\n");
  qword_1ECDD8318 = gCrashMessage;
  return result;
}

unsigned __int8 *PNGReadPlugin::Compose(unsigned __int8 *__src, char *__dst, unsigned int a3, uint64_t a4, int a5)
{
  unsigned __int8 *v5;
  int v6;
  _BYTE *v7;
  int v8;
  int v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  size_t v13;
  unsigned __int8 *v14;
  _BYTE *v15;
  int v16;
  int v17;
  int v18;
  vImage_Buffer v19;
  vImage_Buffer dest;

  v5 = __src;
  if (*(_BYTE *)(a4 + 126))
  {
    v6 = *(unsigned __int8 *)(a4 + 222);
    if (a5)
    {
      if (a3)
      {
        v7 = __dst + 1;
        do
        {
          v8 = v5[1];
          if (v5[1])
          {
            if (v8 == 255)
            {
              *(_WORD *)(v7 - 1) = *(_WORD *)v5;
            }
            else if (v6 == 1)
            {
              *v7 = v8 + (unsigned __int16)((v8 ^ 0xFF) * *v7 + 127) / 0xFFu;
              *(v7 - 1) = *v5 + (unsigned __int16)((v8 ^ 0xFF) * *(v7 - 1) + 127) / 0xFFu;
            }
            else
            {
              v9 = 255 * v8;
              v10 = (v8 ^ 0xFF) * *v7;
              *(v7 - 1) = (v9 * *v5 + v10 * *(v7 - 1)) / (v10 + v9);
              *v7 = (16843010 * (unint64_t)(v10 + v9)) >> 32;
            }
          }
          v5 += 2;
          v7 += 2;
          --a3;
        }
        while (a3);
      }
    }
    else if (v6 == 1)
    {
      dest.data = __src;
      dest.height = 1;
      dest.width = a3;
      dest.rowBytes = 4 * a3;
      v19.data = __dst;
      v19.height = 1;
      v19.width = a3;
      v19.rowBytes = dest.rowBytes;
      vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
      return (unsigned __int8 *)vImagePremultipliedAlphaBlend_BGRA8888(&dest, &v19, &v19, 0x10u);
    }
    else if (a3)
    {
      v14 = __src + 1;
      v15 = __dst + 1;
      do
      {
        v16 = v14[2];
        if (v14[2])
        {
          if (v16 == 255)
          {
            *(_DWORD *)(v15 - 1) = *(_DWORD *)(v14 - 1);
          }
          else
          {
            v17 = 255 * v16;
            v18 = (v16 ^ 0xFF) * v15[2];
            *(v15 - 1) = (v17 * *(v14 - 1) + v18 * *(v15 - 1)) / (v18 + v17);
            *v15 = (v17 * *v14 + v18 * *v15) / (v18 + v17);
            v15[1] = (v17 * v14[1] + v18 * v15[1]) / (v18 + v17);
            v15[2] = (16843010 * (unint64_t)(v18 + v17)) >> 32;
          }
        }
        v14 += 4;
        v15 += 4;
        --a3;
      }
      while (a3);
    }
  }
  else
  {
    v11 = 3 * a3;
    if (a5)
      v11 = a3;
    v12 = (*(unsigned __int16 *)(a4 + 122) >> 3) * a3;
    if (v11 >= v12)
      v13 = v12;
    else
      v13 = v11;
    return (unsigned __int8 *)memcpy(__dst, __src, v13);
  }
  return __src;
}

const void *PNGReadPlugin::copyImageBlockSetAPNG(uint64_t a1, const void *a2, const void *a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  uint64_t v18;
  IIOImageReadSession *v19;
  IIOImageRead *v20;
  uint64_t v21;
  IIOImageRead **v22;
  _BOOL4 v23;
  int v24;
  unint64_t v25;
  size_t v26;
  size_t v27;
  unint64_t v28;
  unsigned __int8 *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  double v35;
  double v36;
  double v37;
  size_t v38;
  int64_t v39;
  char *v40;
  uint64_t v41;
  unint64_t v42;
  double v43;
  double v44;
  uint64_t v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  size_t v51;
  uint64_t v52;
  int v53;
  size_t v54;
  char *v55;
  CGFloat v56;
  CGFloat v57;
  CGFloat v58;
  CGFloat v59;
  double v60;
  double v61;
  double v62;
  double v63;
  double v64;
  double v65;
  const void *v66;
  const char **v67;
  const void *v69;
  _BOOL4 v70;
  uint64_t v71;
  uint64_t v72;
  char *__dst;
  uint64_t v74;
  unsigned int __n[9];
  size_t v76[2];
  CGRect v77;

  v76[0] = 0;
  memset(__n, 0, sizeof(__n));
  CGImageProviderSetProperty();
  IIOReadPlugin::debugCopyBlockSet((const char *)a1, a3, a4, a5, a6, a7, a8, a9);
  if (*(_DWORD *)(a1 + 104) != 1)
    goto LABEL_81;
  v18 = *(unsigned int *)(a1 + 112);
  IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, 1uLL);
  *(_QWORD *)(a1 + 112) = 0x100000000;
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("     numberOfBlocksLeftToDecode: %d\n", 1);
  v19 = (IIOImageReadSession *)IIOImageSource::count((IIOImageSource *)a1);
  v20 = IIOImageReadSession::globalInfoForType(v19, 1095781959);
  if (!v20)
  {
LABEL_81:
    v23 = 0;
    goto LABEL_82;
  }
  v21 = (uint64_t)v20;
  v22 = *(IIOImageRead ***)(a1 + 24);
  if (v22)
    v23 = IIOImageReadSession::mapData(v22);
  else
    v23 = 0;
  if (*(_BYTE *)(a1 + 466))
  {
    v24 = *(_DWORD *)(a1 + 292);
    if (*(_DWORD *)(a1 + 300) < (4 * v24))
      *(_DWORD *)(a1 + 300) = ImageIOAlignRowBytes((4 * v24), *(_QWORD *)(a1 + 392));
  }
  if (!GlobalPNGInfo::currentBuffer((GlobalPNGInfo *)v21, 0))
  {
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("                  currentBuffer: creating new %d x %d [%d]\n", *(_DWORD *)(a1 + 296), *(_DWORD *)(a1 + 292), *(_DWORD *)(a1 + 300));
    v26 = *(unsigned int *)(a1 + 296);
    v27 = *(unsigned int *)(a1 + 300);
    v28 = v26 * (unint64_t)v27;
    __n[0] = v26 * v27;
    if ((v28 & 0xFFFFFFFF00000000) == 0)
    {
      v29 = (unsigned __int8 *)malloc_type_calloc(v26, v27, 0x431A0903uLL);
      if (v29)
      {
        GlobalPNGInfo::setCurrentBuffer((GlobalPNGInfo *)v21, v29, v28, 1);
        GlobalPNGInfo::setCurrentBufferRowBytes((GlobalPNGInfo *)v21, *(_DWORD *)(a1 + 300));
        GlobalPNGInfo::setCurrentBufferIndex((GlobalPNGInfo *)v21, -1);
        goto LABEL_17;
      }
    }
LABEL_82:
    v66 = 0;
    goto LABEL_72;
  }
LABEL_17:
  v69 = a2;
  v70 = v23;
  v30 = *(unsigned int *)(a1 + 112);
  if (v30 < *(_DWORD *)(a1 + 116))
  {
    v31 = a1 + 184;
    v32 = a1 + 440;
    v71 = v21;
    v72 = v18;
    while (1)
    {
      v33 = v30 - v18;
      if (*(_QWORD *)(*(_QWORD *)(a1 + 96) + 8 * (v30 - v18)))
        _cg_jpeg_mem_term("copyImageBlockSetAPNG", 2680, "*** _blockArray[%d] was cached - and already allocated\n", v30 - v18);
      v34 = *(unsigned int *)(a1 + 296);
      v35 = (double)(unint64_t)(v30 * v34);
      *(_QWORD *)&__n[1] = 0;
      LODWORD(v25) = *(_DWORD *)(a1 + 292);
      v36 = (double)v25;
      *(double *)&__n[3] = v35;
      *(double *)&__n[5] = v36;
      *(double *)&__n[7] = (double)v34;
      LODWORD(v36) = *(_DWORD *)(a1 + 232);
      v37 = (double)*(unint64_t *)&v36;
      if ((double)v34 + v35 > v37)
        *(double *)&__n[7] = v37 - v35;
      v38 = *(unsigned int *)(a1 + 300) * (unint64_t)v34;
      v39 = _ImageIO_Malloc(v38, *(_QWORD *)(a1 + 384), v76, (uint64_t)kImageMalloc_PNG_Data[0], *(_DWORD *)(a1 + 432), 0, 0);
      if (!v39)
      {
        v66 = 0;
        v23 = v70;
        goto LABEL_72;
      }
      v40 = (char *)v39;
      v41 = *(_QWORD *)(a1 + 384);
      if (v41 && v39 % v41)
        goto LABEL_69;
      bzero((void *)v39, v38);
      v42 = PNGReadPlugin::DecodeComposedImage(*(IIO_Reader **)(a1 + 24), v21, v31, v32, (uint64_t)&__n[1], v40, *(unsigned int *)(a1 + 300), *(_DWORD *)(a1 + 432));
      v43 = *(double *)&__n[7];
      if (v42)
        break;
LABEL_56:
      if (v43 != 0.0)
      {
        *(_BYTE *)(a1 + 343) = 0;
        PNGReadPlugin::postProcess((PNGReadPlugin *)a1, (unsigned __int8 *)v40);
        *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8 * v33) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, v40, v76[0], *(CGRect *)&__n[1], *(unsigned int *)(a1 + 300), *(unsigned __int8 *)(a1 + 343));
        v57 = *(double *)&__n[3];
        v56 = *(double *)&__n[1];
        v59 = *(double *)&__n[7];
        v58 = *(double *)&__n[5];
        if (!CGRectEqualToRect(*(CGRect *)(a1 + 120), *MEMORY[0x1E0C9D628]))
        {
          v77.origin.x = v56;
          v77.origin.y = v57;
          v77.size.width = v58;
          v77.size.height = v59;
          *(CGRect *)(&v25 - 1) = CGRectUnion(*(CGRect *)(a1 + 120), v77);
          v56 = v60;
          v57 = *(double *)&v25;
          v58 = v61;
          v59 = v62;
        }
        v40 = 0;
        *(CGFloat *)(a1 + 120) = v56;
        *(CGFloat *)(a1 + 128) = v57;
        *(CGFloat *)(a1 + 136) = v58;
        *(CGFloat *)(a1 + 144) = v59;
      }
      if (++v30 >= (unint64_t)*(unsigned int *)(a1 + 116))
        goto LABEL_63;
    }
    v44 = (double)v42;
    if (*(double *)&__n[7] != (double)v42)
    {
      if (*(double *)&__n[7] > (double)v42)
      {
        *(double *)&__n[7] = (double)v42;
        if ((gIIODebugFlags & 0x30000) != 0)
        {
          ImageIOLog(": error while decoding PNG image rect: (%5g, %5g, %5g, %5g)\n", *(double *)&__n[1], *(double *)&__n[3], *(double *)&__n[5], (double)v42);
          ImageIOLog("          blockLoop = %ld\n", v30);
          ImageIOLog("        _blockEnd-1 = %ld\n", *(unsigned int *)(a1 + 116) - 1);
        }
        v43 = v44;
      }
      goto LABEL_56;
    }
    if (*(_DWORD *)(a1 + 208) >= *(_DWORD *)(v21 + 40))
      goto LABEL_69;
    v74 = v30 - v18;
    __dst = (char *)GlobalPNGInfo::currentBuffer((GlobalPNGInfo *)v21, __n);
    GlobalPNGInfo::setCurrentBufferIndex((GlobalPNGInfo *)v21, *(_DWORD *)(a1 + 208));
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("                  currentBuffer: setting index to %d\n", *(_DWORD *)(a1 + 208));
    if ((v45 = *(_QWORD *)(v21 + 8) + 34 * *(unsigned int *)(a1 + 208), v46 = *(_DWORD *)(v45 + 12), v46 < 0)
      || (v47 = *(_DWORD *)(v45 + 16), v47 < 0)
      || (v49 = *(_DWORD *)(v45 + 4), v48 = *(_DWORD *)(v45 + 8), v50 = *(unsigned __int8 *)(v45 + 24), v49 < 0)
      && v48 < 0
      || v46 + v49 > *(_DWORD *)(a1 + 292)
      || v47 + v48 > *(_DWORD *)(a1 + 296)
      || (v51 = __n[0], v38 > __n[0]))
    {
LABEL_69:
      v66 = 0;
      v23 = v70;
      goto LABEL_71;
    }
    v52 = gIIODebugFlags & 0x30000;
    if (v50 == 2)
    {
      if (v52)
        ImageIOLog("                  currentBuffer: *** currentBuffer not changed [PNG_DISPOSE_OP_PREVIOUS]\n");
    }
    else
    {
      if (v52)
      {
        ImageIOLog("                  currentBuffer: *** imageData to currentBuffer -> memcpy\n");
        v51 = __n[0];
      }
      memcpy(__dst, v40, v51);
      if (v50 == 1)
      {
        if ((gIIODebugFlags & 0x30000) != 0)
          ImageIOLog("                  currentBuffer: dispose background - clearing rect\n");
        v31 = a1 + 184;
        if (v48)
        {
          v53 = *(unsigned __int16 *)(a1 + 306) >> 3;
          v54 = (v49 * v53);
          v55 = &__dst[*(_DWORD *)(a1 + 300) * v47 + v46 * v53];
          do
          {
            bzero(v55, v54);
            v55 += *(unsigned int *)(a1 + 300);
            --v48;
          }
          while (v48);
        }
        v21 = v71;
        v18 = v72;
        goto LABEL_55;
      }
    }
    v21 = v71;
    v18 = v72;
    v31 = a1 + 184;
LABEL_55:
    v32 = a1 + 440;
    v33 = v74;
    goto LABEL_56;
  }
  v40 = 0;
LABEL_63:
  v63 = *(double *)(a1 + 120);
  v64 = *(double *)(a1 + 128);
  v65 = *(double *)(a1 + 144);
  if (v65 != 0.0)
  {
    v23 = v70;
    if (a3)
    {
      v66 = (const void *)IIOReadPlugin::imageBlockSetCreate(a1, (uint64_t)a3, *(unsigned int *)(a1 + 104), *(double *)(a1 + 136), v65, v63, v64, *(double *)(a1 + 136), *(double *)(a1 + 144), *(_QWORD *)(a1 + 96), v69);
      if (!v40)
        goto LABEL_72;
    }
    else
    {
      v66 = 0;
      if (!v40)
        goto LABEL_72;
    }
LABEL_71:
    _ImageIO_Free((unint64_t)v40, v76[0]);
    goto LABEL_72;
  }
  _cg_jpeg_mem_term("copyImageBlockSetAPNG", 2799, ": pngCreateBlockSet - error while decoding PNG image rect: (%5g, %5g, %5g, %5g)\n", v63, v64, *(double *)(a1 + 136), v65);
  v66 = 0;
  v23 = v70;
  if (v40)
    goto LABEL_71;
LABEL_72:
  if (a3)
    IIOReadPlugin::freeBlockArray((IIOReadPlugin *)a1);
  if (v23)
  {
    v67 = *(const char ***)(a1 + 24);
    if (v67)
      IIOImageReadSession::unmapData(v67);
  }
  if (*(_BYTE *)(a1 + 177))
  {
    ImageIOLog("<<< copyImageBlockSetAPNG - PNG  [%p]\n", v66);
    ImageIOLog("===================================================================================================\n");
  }
  return v66;
}

unint64_t PNGReadPlugin::DecodeComposedImage(IIO_Reader *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char *a6, unint64_t a7, task_t a8)
{
  unint64_t v8;
  uint64_t v9;
  double v13;
  int v14;
  IIOFrameBufferQueue *v15;
  unsigned int v16;
  _BYTE *v17;
  unsigned int v18;
  unint64_t v19;
  uint64_t v20;
  unsigned int v21;
  unint64_t v22;
  unsigned int v23;
  uint64_t v24;
  int v25;
  unint64_t v26;
  size_t v27;
  const void *v28;
  unsigned __int8 *v29;
  unsigned __int8 *v30;
  unsigned __int8 *v31;
  IIOImageRead *v32;
  char *v33;
  BOOL v34;
  BOOL v35;
  int v36;
  unsigned __int8 *v37;
  BOOL v38;
  const void *v40;
  const void *v41;
  unsigned int v42;
  uint64_t v43;
  unsigned int v44;
  size_t v45;
  int v46;
  uint64_t v47;
  int v48;
  BOOL v49;
  int v50;
  size_t v51;
  char *v52;
  uint64_t v53;
  const char *v54;
  IIOFrameBufferQueue *v55;
  unint64_t v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  unint64_t v64;
  int v65;
  size_t v66;
  char *v67;
  BOOL v68;
  unint64_t v69;
  unint64_t v70;
  const void *v71;
  unsigned __int8 *Buffer;
  unsigned __int8 *v73;
  unsigned __int8 *v74;
  IIOImageRead *v75;
  _BOOL4 v76;
  _BOOL4 v77;
  _BOOL4 v78;
  char *v79;
  int v80;
  uint64_t v81;
  char *v82;
  uint64_t v84;
  uint64_t v85;
  IIOFrameBufferQueue *v86;
  CFTypeRef v87;
  unsigned int v91;
  IIOFrameBufferQueue *v93;
  unint64_t v94;
  _BOOL4 v95;
  uint64_t v96;
  int v97;
  unint64_t v98;
  unint64_t v99;
  CFTypeRef cf;
  unsigned int cfa;
  size_t __n;
  size_t __na;
  GlobalPNGInfo *v104;
  int v105;
  unsigned int v106;
  unsigned int v107;
  __int128 v108;
  uint64_t v109;
  unsigned int v110[2];
  double v111;
  double v112;
  double v113;
  double v114;
  unsigned __int8 *v115;
  unint64_t v116;
  unint64_t v117;
  __int128 v118;
  uint64_t v119;
  size_t v120;
  void **v121[2];

  v8 = 0;
  v120 = 0;
  if (!a1)
    return v8;
  v9 = a2;
  if (!a2 || !a6)
    return v8;
  v13 = *(double *)(a5 + 24);
  v105 = *(_DWORD *)(a3 + 140);
  v14 = *(unsigned __int8 *)(a3 + 62);
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("                   reading rows: %d ... %d\n", (unint64_t)*(double *)(a5 + 8), (unint64_t)(v13 + *(double *)(a5 + 8)));
  v91 = v14 - 5;
  v99 = ((unint64_t)*(unsigned __int16 *)(a3 + 122) + 7) >> 3;
  v96 = a5;
  v104 = (GlobalPNGInfo *)v9;
  if (*(_BYTE *)(a4 + 20) != 7)
  {
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("    === decoding frame %d ===\n", *(_DWORD *)(a3 + 24));
    v16 = *(_DWORD *)(a3 + 24);
    if (v16
      || !*(_BYTE *)(a4 + 31)
      || 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*(_QWORD *)(v9 + 16) - *(_QWORD *)(v9 + 8)) >> 1) <= 1)
    {
      v17 = (_BYTE *)(a4 + 59);
      if (!*(_BYTE *)(a4 + 59))
      {
        if (!v16)
        {
          v18 = 0;
          goto LABEL_71;
        }
LABEL_58:
        v18 = v16;
        v37 = (unsigned __int8 *)(*(_QWORD *)(v9 + 8) + 34 * v16 + 24);
        do
        {
          if (*((_DWORD *)v37 - 5) == *(_DWORD *)(v9 + 32))
          {
            v38 = *((_DWORD *)v37 - 4) == *(_DWORD *)(v9 + 36) && v37[1] == 0;
            if (v38 && *v37 < 2u)
              break;
          }
          v37 -= 34;
          --v18;
        }
        while (v18);
LABEL_71:
        v110[0] = 0;
        v40 = (const void *)GlobalPNGInfo::currentBuffer((GlobalPNGInfo *)v9, v110);
        v41 = v40;
        if (v16 && v40)
        {
          if ((gIIODebugFlags & 0x30000) != 0)
            ImageIOLog("                      currentBuffer: %p ", v40);
          v42 = GlobalPNGInfo::currentBufferIndex((GlobalPNGInfo *)v9);
          v43 = gIIODebugFlags & 0x30000;
          if (v42 == v16 - 1)
          {
            v44 = v42;
            v45 = (unint64_t)(v13 * (double)a7);
            if (v43)
            {
              v46 = GlobalPNGInfo::currentBufferIndex(v104);
              ImageIOLog("                      currentBuffer: bufferIndex=%d  currentIndex-1=%d\n", v46, v44);
            }
            if (v110[0] == v45)
            {
              memcpy(a6, v41, v45);
              if ((gIIODebugFlags & 0x30000) != 0)
              {
                ImageIOLog("                      currentBuffer: sizes match: %ld\n", v45);
                if ((gIIODebugFlags & 0x30000) != 0)
                  ImageIOLog("                      currentBuffer: *** using currentBuffer -> memcpy\n");
              }
              v47 = *((_QWORD *)v104 + 1) + 34 * v44;
              v48 = *(_DWORD *)(v47 + 8);
              v49 = *(_BYTE *)(v47 + 24) != 1 || v48 == 0;
              v18 = v16;
              if (!v49)
              {
                v50 = *(unsigned __int16 *)(a3 + 122) >> 3;
                v51 = (*(_DWORD *)(v47 + 4) * v50);
                v52 = &a6[*(_DWORD *)(a3 + 116) * *(_DWORD *)(v47 + 16) + *(_DWORD *)(v47 + 12) * v50];
                do
                {
                  bzero(v52, v51);
                  v52 += *(unsigned int *)(a3 + 116);
                  --v48;
                }
                while (v48);
LABEL_19:
                v18 = v16;
              }
            }
            else if ((gIIODebugFlags & 0x30000) != 0)
            {
              ImageIOLog("                  currentBuffer: sizes don't match: buffer=%d  expected = %d\n");
            }
          }
          else if (v43)
          {
            GlobalPNGInfo::currentBufferIndex((GlobalPNGInfo *)v9);
            ImageIOLog("                  currentBuffer: bufferIndex=%d  currentIndex-1=%d -- can't use index\n");
          }
        }
        else
        {
          v53 = gIIODebugFlags & 0x30000;
          if (v40)
          {
            if (v53)
              ImageIOLog("                  currentBuffer: index is 0 - not using currentbufffer\n", v84, v85);
          }
          else if (v53)
          {
            ImageIOLog("                  currentBuffer: buffer is nil / no framebuffer in place\n");
          }
        }
        if ((gIIODebugFlags & 0x30000) != 0)
        {
          v54 = *v17 ? "YES" : "NO";
          ImageIOLog("            prpd._skipComposing: %s\n", v54);
          if ((gIIODebugFlags & 0x30000) != 0)
          {
            ImageIOLog("                     firstIndex: %d\n", v18);
            if ((gIIODebugFlags & 0x30000) != 0)
              ImageIOLog("                   image frames: %d ... %d\n", v18, v16);
          }
        }
        if (*(_BYTE *)(a4 + 37))
          v55 = PNGReadPlugin::EnsureFrameBufferQueueExists(a1, (uint64_t)v104, (__int128 *)a3, (__int128 *)a4, v18, a8);
        else
          v55 = 0;
        if (v18 > v16)
          return 0;
        v86 = v55;
        v8 = 0;
        v56 = v18;
        v98 = v16;
        while (1)
        {
          v57 = *((_QWORD *)v104 + 1) + 34 * v56;
          v58 = *(unsigned int *)(v57 + 8);
          v107 = *(_DWORD *)(v57 + 4);
          v59 = *(unsigned int *)(v57 + 16);
          cfa = *(_DWORD *)(v57 + 12);
          v60 = *(unsigned __int8 *)(v57 + 24);
          v61 = *(unsigned __int8 *)(v57 + 25);
          if ((gIIODebugFlags & 0x30000) != 0)
          {
            v62 = *(unsigned __int16 *)(v57 + 20);
            v63 = *(unsigned __int16 *)(v57 + 22);
            ImageIOLog("    #%d\n", v56);
            if ((gIIODebugFlags & 0x30000) != 0)
            {
              ImageIOLog("                           rect: {%d, %d, %d, %d}\n", cfa, v59, v107, v58);
              if ((gIIODebugFlags & 0x30000) != 0)
              {
                ImageIOLog("                          delay: %d / %d\n", v62, v63);
                if ((gIIODebugFlags & 0x30000) != 0)
                {
                  ImageIOLog("                   f_dispose_op: %d %s\n", v60, off_1E1BC1FB0[v60]);
                  if ((gIIODebugFlags & 0x30000) != 0)
                    ImageIOLog("                     f_blend_op: %d %s\n", v61, off_1E1BC1FC8[v61]);
                }
              }
            }
          }
          v64 = v98;
          if (v56 >= v98 || (_DWORD)v60 != 2)
            break;
LABEL_164:
          v34 = v56++ == v64;
          if (v34)
            return v8;
        }
        if (v56 < v98 && (_DWORD)v60 == 1)
        {
          if ((_DWORD)v58)
          {
            v65 = *(unsigned __int16 *)(a3 + 122) >> 3;
            v66 = v107 * v65;
            v67 = &a6[(*(_DWORD *)(a3 + 116) * v59) + cfa * v65];
            do
            {
              bzero(v67, v66);
              v67 += *(unsigned int *)(a3 + 116);
              --v58;
            }
            while (v58);
          }
          goto LABEL_164;
        }
        if (v107)
          v68 = (_DWORD)v58 == 0;
        else
          v68 = 1;
        if (v68)
        {
          v8 = v59;
          goto LABEL_164;
        }
        v69 = v99 * (unint64_t)v107;
        v70 = *(unsigned int *)(a3 + 116);
        if (v69 < v70)
          v70 = v99 * (unint64_t)v107;
        __na = v70;
        if (v86)
        {
          v71 = IIOFrameBufferQueue::getAndRetainBufferAtIndex((os_unfair_lock_s *)v86, v56);
          if (v71)
          {
            v87 = v71;
            Buffer = (unsigned __int8 *)IIOFrameBufferGetBuffer((uint64_t)v71);
            v94 = 0;
LABEL_139:
            v76 = v61 == 0;
            if (v91 < 0xFFFFFFFC)
              v76 = 1;
            v95 = v76;
            if (v56)
              v77 = v56 == v98;
            else
              v77 = 1;
            if (v56)
              v78 = v91 < 0xFFFFFFFC;
            else
              v78 = 1;
            v79 = &a6[v99 * (unint64_t)cfa];
            if ((_DWORD)v61)
              v80 = v78;
            else
              v80 = 1;
            while (1)
            {
              v81 = *(unsigned int *)(a3 + 116);
              v82 = &v79[v59 * v81];
              if (v77)
                break;
              if ((_DWORD)v60 == 1)
              {
                bzero(&v79[v59 * v81], __na);
                goto LABEL_158;
              }
              if (!(_DWORD)v60)
              {
                if (!v95)
                {
LABEL_156:
                  PNGReadPlugin::Compose(Buffer, v82, v107, a3, v105 == 1196573017);
                  goto LABEL_158;
                }
                goto LABEL_152;
              }
LABEL_158:
              ++v59;
              Buffer += v69;
              if (!--v58)
              {
                if (v87)
                  CFRelease(v87);
                v64 = v98;
                if (v94)
                  _ImageIO_Free(v94, v120);
                v8 = (unint64_t)*(double *)(v96 + 24);
                goto LABEL_164;
              }
            }
            if (!v80)
              goto LABEL_156;
LABEL_152:
            memcpy(v82, Buffer, __na);
            goto LABEL_158;
          }
          _cg_jpeg_mem_term("DecodeComposedImage", 4042, "*** IIOFrameBufferQueue returned NULL for buffer at index: %ld\n");
        }
        else if (is_mul_ok(v58, v69))
        {
          v73 = (unsigned __int8 *)_ImageIO_Malloc(v58 * v69, *(_QWORD *)(a3 + 200), &v120, (uint64_t)kImageMalloc_PNG_Data[0], a8, 0, 0);
          if (v73)
          {
            v74 = v73;
            bzero(v73, v58 * v69);
            v109 = 0;
            *(_QWORD *)v110 = v56;
            v111 = (double)cfa;
            v112 = (double)v59;
            v113 = (double)v107;
            v114 = (double)v58;
            v94 = (unint64_t)v74;
            v115 = v74;
            v116 = v99 * (unint64_t)v107;
            v117 = v69 * v58;
            v118 = 0u;
            v119 = 0;
            v108 = 0u;
            std::vector<IIODecodeFrameParams>::vector(&v108, 1uLL, (uint64_t)v110);
            v75 = (IIOImageRead *)IIO_Reader::testHeaderSize(a1);
            PNGReadPlugin::DecodeUncomposedFrames(v75, (uint64_t)v104, a3, (_BYTE *)a4, (uint64_t **)&v108);
            Buffer = v115;
            v121[0] = (void **)&v108;
            std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100](v121);
            IIODecodeFrameParams::~IIODecodeFrameParams((IIODecodeFrameParams *)v110);
            v87 = 0;
            goto LABEL_139;
          }
          _cg_jpeg_mem_term("DecodeComposedImage", 4055, "*** ImageIO_Malloc failed to alloc %ld bytes\n");
        }
        return v59;
      }
    }
    else
    {
      v17 = (_BYTE *)(a4 + 59);
      v16 = 1;
      if (!*(_BYTE *)(a4 + 59))
        goto LABEL_58;
    }
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("                  currentBuffer: prpd._skipComposing=%d -> skipping currentbufffer\n", 1);
    goto LABEL_19;
  }
  if (*(_BYTE *)(a4 + 37))
    v15 = PNGReadPlugin::EnsureFrameBufferQueueExists(a1, v9, (__int128 *)a3, (__int128 *)a4, 0, a8);
  else
    v15 = 0;
  v19 = 0;
  v8 = 0;
  v93 = v15;
  while (1)
  {
    v20 = *(_QWORD *)(v9 + 8) + 34 * v19;
    v21 = *(_DWORD *)(v20 + 4);
    v22 = *(unsigned int *)(v20 + 8);
    v23 = *(_DWORD *)(v20 + 12);
    v24 = *(unsigned int *)(v20 + 16);
    v25 = *(unsigned __int8 *)(v20 + 24);
    v97 = *(unsigned __int8 *)(v20 + 25);
    v106 = v21;
    v26 = v99 * (unint64_t)v21;
    v27 = v26 >= *(unsigned int *)(a3 + 116) ? *(unsigned int *)(a3 + 116) : v99 * (unint64_t)v21;
    if (v15)
      break;
    if (!is_mul_ok(v22, v26))
      return v8;
    v30 = (unsigned __int8 *)_ImageIO_Malloc(v22 * v26, *(_QWORD *)(a3 + 200), &v120, (uint64_t)kImageMalloc_PNG_Data[0], a8, 0, 0);
    if (!v30)
    {
      _cg_jpeg_mem_term("DecodeComposedImage", 3768, "*** ImageIO_Malloc failed to alloc %ld bytes\n");
      return v8;
    }
    v31 = v30;
    bzero(v30, v22 * v26);
    v109 = 0;
    *(_QWORD *)v110 = v19;
    v111 = (double)v23;
    v112 = (double)v24;
    v113 = (double)v106;
    v114 = (double)v22;
    __n = (size_t)v31;
    v115 = v31;
    v116 = v26;
    v117 = v26 * v22;
    v118 = 0u;
    v119 = 0;
    v108 = 0u;
    std::vector<IIODecodeFrameParams>::vector(&v108, 1uLL, (uint64_t)v110);
    v32 = (IIOImageRead *)IIO_Reader::testHeaderSize(a1);
    PNGReadPlugin::DecodeUncomposedFrames(v32, (uint64_t)v104, a3, (_BYTE *)a4, (uint64_t **)&v108);
    v29 = v115;
    v121[0] = (void **)&v108;
    std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100](v121);
    IIODecodeFrameParams::~IIODecodeFrameParams((IIODecodeFrameParams *)v110);
    cf = 0;
    if ((_DWORD)v22)
    {
LABEL_32:
      v33 = &a6[v99 * (unint64_t)v23];
      if (v19)
        v34 = v97 == 0;
      else
        v34 = 1;
      v35 = !v34 && v91 >= 0xFFFFFFFC;
      v36 = !v35;
      while (v19 != *(_DWORD *)(a3 + 24))
      {
        if (v25 == 1)
        {
          bzero(&v33[v24 * *(unsigned int *)(a3 + 116)], v27);
          goto LABEL_49;
        }
        if (!v25)
        {
          if (!v36)
          {
LABEL_47:
            PNGReadPlugin::Compose(v29, &v33[v24 * *(unsigned int *)(a3 + 116)], v106, a3, v105 == 1196573017);
            goto LABEL_49;
          }
          goto LABEL_43;
        }
LABEL_49:
        ++v24;
        v29 += v26;
        if (!--v22)
          goto LABEL_50;
      }
      if (!v36)
        goto LABEL_47;
LABEL_43:
      memcpy(&v33[v24 * *(unsigned int *)(a3 + 116)], v29, v27);
      goto LABEL_49;
    }
LABEL_50:
    if (cf)
      CFRelease(cf);
    v9 = (uint64_t)v104;
    if (__n)
      _ImageIO_Free(__n, v120);
    v8 = (unint64_t)*(double *)(v96 + 24);
    v35 = v19++ >= *(unsigned int *)(a3 + 24);
    v15 = v93;
    if (v35)
      return v8;
  }
  v28 = IIOFrameBufferQueue::getAndRetainBufferAtIndex((os_unfair_lock_s *)v15, v19);
  if (v28)
  {
    cf = v28;
    v29 = (unsigned __int8 *)IIOFrameBufferGetBuffer((uint64_t)v28);
    __n = 0;
    if ((_DWORD)v22)
      goto LABEL_32;
    goto LABEL_50;
  }
  _cg_jpeg_mem_term("DecodeComposedImage", 3755, "*** IIOFrameBufferQueue returned NULL for buffer at index: %ld\n");
  return v8;
}

void sub_187FA6330(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  IIODecodeFrameParams::~IIODecodeFrameParams((IIODecodeFrameParams *)&a33);
  _Unwind_Resume(a1);
}

void AddSubRect(CGRect *a1, CGRect a2)
{
  CGFloat height;
  CGFloat width;
  CGFloat y;
  CGFloat x;
  CGRect v7;
  CGRect v8;

  height = a2.size.height;
  width = a2.size.width;
  y = a2.origin.y;
  x = a2.origin.x;
  if (!CGRectEqualToRect(*a1, *MEMORY[0x1E0C9D628]))
  {
    v8.origin.x = x;
    v8.origin.y = y;
    v8.size.width = width;
    v8.size.height = height;
    v7 = CGRectUnion(*a1, v8);
    x = v7.origin.x;
    y = v7.origin.y;
    width = v7.size.width;
    height = v7.size.height;
  }
  a1->origin.x = x;
  a1->origin.y = y;
  a1->size.width = width;
  a1->size.height = height;
}

uint64_t breakOnPngError(void)
{
  return _cg_jpeg_mem_term("breakOnPngError", 398, "breakOnPngError\n");
}

IIOFrameBufferQueue *PNGReadPlugin::EnsureFrameBufferQueueExists(IIO_Reader *a1, uint64_t a2, __int128 *a3, __int128 *a4, uint64_t a5, int a6)
{
  uint64_t v12;
  IIOFrameBufferQueue *v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *p_shared_owners;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  uint64_t v36;
  std::__shared_weak_count *v37;
  void *v38[2];
  char v39;
  _QWORD v40[5];
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  uint64_t v56;
  IIO_Reader *v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  int v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 __p;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  uint64_t v84;
  IIOFrameBufferQueue *v85;
  std::__shared_weak_count *v86;

  v85 = 0;
  v86 = 0;
  v12 = IIO_Reader::testHeaderSize(a1);
  std::string::basic_string[abi:ne180100]<0>(&__p, "PNGFrameBufferQueue");
  IIOImageRead::getClientValueForKey(v12, (const void **)&__p, &v85);
  if (SBYTE7(v70) < 0)
    operator delete((void *)__p);
  v13 = v85;
  if (!v85)
  {
    v14 = a3[12];
    v15 = a3[14];
    v82 = a3[13];
    v83 = v15;
    v16 = a3[8];
    v17 = a3[10];
    v18 = a3[11];
    v78 = a3[9];
    v79 = v17;
    v80 = v18;
    v81 = v14;
    v19 = a3[4];
    v20 = a3[6];
    v21 = a3[7];
    v74 = a3[5];
    v75 = v20;
    v76 = v21;
    v77 = v16;
    v22 = *a3;
    v23 = a3[2];
    v24 = a3[3];
    v70 = a3[1];
    v71 = v23;
    v84 = *((_QWORD *)a3 + 30);
    v72 = v24;
    v73 = v19;
    v25 = a4[3];
    v66 = a4[2];
    v67 = v25;
    v68 = a4[4];
    __p = v22;
    v26 = a4[1];
    v64 = *a4;
    v65 = v26;
    v13 = (IIOFrameBufferQueue *)operator new();
    v40[1] = 0x40000000;
    v55 = v83;
    v53 = v81;
    v54 = v82;
    v49 = v77;
    v50 = v78;
    v51 = v79;
    v52 = v80;
    v45 = v73;
    v46 = v74;
    v47 = v75;
    v48 = v76;
    v41 = __p;
    v42 = v70;
    v40[0] = MEMORY[0x1E0C809B0];
    v40[2] = ___ZN13PNGReadPlugin28EnsureFrameBufferQueueExistsEP19IIOImageReadSessionP13GlobalPNGInfoRK14ReadPluginDataRK13PNGPluginDatalj_block_invoke;
    v40[3] = &__block_descriptor_tmp_118;
    v27 = *(unsigned int *)(a2 + 40);
    v40[4] = a2;
    v43 = v71;
    v44 = v72;
    v63 = a6;
    v56 = v84;
    v57 = a1;
    v60 = v66;
    v61 = v67;
    v62 = v68;
    v58 = v64;
    v59 = v65;
    IIOFrameBufferQueue::IIOFrameBufferQueue(v13, v27, 2, v40);
    v28 = IIO_Reader::testHeaderSize(a1);
    std::string::basic_string[abi:ne180100]<0>(v38, "PNGFrameBufferQueue");
    std::shared_ptr<IIOBaseObject>::shared_ptr[abi:ne180100]<IIOFrameBufferQueue,void>(&v36, (uint64_t)v13);
    IIOImageRead::setClientValueForKey(v28, (__int128 *)v38, &v36);
    v29 = v37;
    if (v37)
    {
      p_shared_owners = (unint64_t *)&v37->__shared_owners_;
      do
        v31 = __ldaxr(p_shared_owners);
      while (__stlxr(v31 - 1, p_shared_owners));
      if (!v31)
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
    }
    if (v39 < 0)
      operator delete(v38[0]);
    IIOFrameBufferQueue::startEnqueueingBuffers(v13, a5);
  }
  v32 = v86;
  if (v86)
  {
    v33 = (unint64_t *)&v86->__shared_owners_;
    do
      v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }
  return v13;
}

void sub_187FA66C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  uint64_t v17;

  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  if (a17 < 0)
    operator delete(__p);
  std::shared_ptr<IIOTextureDataImp>::~shared_ptr[abi:ne180100](v17 - 96);
  _Unwind_Resume(a1);
}

void sub_187FA6BE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void **a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  a14 = (void **)&a26;
  std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100](&a14);
  _Unwind_Resume(a1);
}

void handle_error_idot(uint64_t a1, _BYTE *a2)
{
  _DWORD *exception;

  if (a2)
  {
    if (*a2)
      _cg_jpeg_mem_term("handle_error_idot", 278, "PNG-iDOT", "%s\n", a2);
  }
  exception = __cxa_allocate_exception(4uLL);
  *exception = -1;
  __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
}

void PNGReadPlugin::DecodeFrameAPNG(IIOImageReadSession *a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5)
{
  _QWORD *v10;
  unsigned int *v11;
  unsigned int *v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  uint64_t zstream;
  int v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;
  char *v23;
  unsigned int v24;
  __int16 v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int *v29;
  _QWORD *v30;

  v10 = _cg_png_create_read_struct("1.6.43", 0, (uint64_t)handle_error, (uint64_t)handle_warning);
  v30 = v10;
  _cg_png_create_info_struct((uint64_t)v10);
  v12 = v11;
  v29 = v11;
  if (v10 && v11)
  {
    _cg_png_set_option((uint64_t)v10, 2u, 3);
    _cg_png_set_benign_errors((uint64_t)v10, 1);
    _cg_png_set_read_fn(v10, (uint64_t)a1, (size_t (*)(size_t, void *, size_t))read_fn);
    _cg_png_set_keep_unknown_chunks_sized((uint64_t)v10, 3u, "CgBI", 4);
    a4[56] = 0;
    _cg_png_set_read_user_chunk_fn((uint64_t)v10, (uint64_t)a4, (uint64_t)PNGReadPlugin::Read_user_chunk_callback);
    _cg_png_read_info((uLong)v10, v12);
    if (*(_BYTE *)(a3 + 63) == 1)
      _cg_png_set_swap((uint64_t)v10);
    v13 = _cg_png_set_interlace_handling((uint64_t)v10);
    PNGReadPlugin::Update_png_struct(a3, a4, (uint64_t)v10, v12);
    v14 = *(_QWORD *)(a2 + 8) + 34 * *(_QWORD *)a5;
    v16 = *(_DWORD *)(v14 + 4);
    v15 = *(_DWORD *)(v14 + 8);
    if (*(uint64_t *)a5 < 1)
    {
      if (a4[31] && *(_DWORD *)(a3 + 48))
      {
        v24 = 0;
        do
        {
          _cg_png_read_row_sized((uLong)v10, 0, 0, 0);
          ++v24;
        }
        while (v24 < *(_DWORD *)(a3 + 48));
      }
    }
    else
    {
      v17 = *(_DWORD *)v14;
      IIOImageReadSession::seek(a1, *(_QWORD *)(v14 + 26), 0);
      _cg_png_set_num_frames_read((uint64_t)v10, (uint64_t)v12, *(_DWORD *)a5);
      _cg_png_set_next_seq_num((uint64_t)v10, (uint64_t)v12, v17);
      _cg_png_set_zstream_owner((uint64_t)v10, 0);
      zstream = _cg_png_get_zstream((uint64_t)v10);
      *(_QWORD *)zstream = 0;
      *(_DWORD *)(zstream + 8) = 0;
    }
    _cg_png_read_frame_head((uint64_t)v10, v12);
    v27 = 0;
    v28 = 0;
    v26 = 0;
    v25 = 0;
    _cg_png_get_next_frame_fcTL((uint64_t)v10, (uint64_t)v12, (_DWORD *)&v28 + 1, &v28, (_DWORD *)&v27 + 1, &v27, (_WORD *)&v26 + 1, &v26, (_BYTE *)&v25 + 1, &v25);
    if (v28 == __PAIR64__(v16, v15))
    {
      if (v13)
      {
        v19 = 0;
        v20 = *(_QWORD *)(a5 + 48);
        v21 = v15;
        do
        {
          if (v21)
          {
            v22 = 0;
            v23 = *(char **)(a5 + 40);
            do
            {
              _cg_png_read_row_sized((uLong)v10, v23, v20, 0);
              v23 += v20;
              ++v22;
              v15 = v28;
            }
            while (v22 < v28);
            v21 = v28;
          }
          ++v19;
        }
        while (v19 != v13);
      }
      *(_QWORD *)(a5 + 64) = v15;
    }
    else
    {
      LogError("DecodeFrameAPNG", 4784, "fcTL_CHUNK size mismatch\n");
    }
  }
  _cg_png_destroy_read_struct((uint64_t *)&v30, (void **)&v29, 0);
}

void sub_187FA6F50(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  __cxa_begin_catch(a1);
  imagePNG_error_break(a16);
  __cxa_end_catch();
  JUMPOUT(0x187FA6EC4);
}

void sub_187FA6F80(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void ___ZN13PNGReadPlugin22DecodeUncomposedFramesEP12IIOImageReadP13GlobalPNGInfoRK14ReadPluginDataRK13PNGPluginDataRNSt3__16vectorI20IIODecodeFrameParamsNSA_9allocatorISC_EEEE_block_invoke(uint64_t a1, uint64_t a2)
{
  _OWORD v4[4];

  memset(v4, 0, sizeof(v4));
  IIOImageReadSession::IIOImageReadSession((IIOImageReadSession *)v4, *(IIOImageRead **)(a1 + 32));
  PNGReadPlugin::DecodeFrameAPNG((IIOImageReadSession *)v4, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(_BYTE **)(a1 + 56), **(_QWORD **)(a1 + 64) + 88 * a2);
  IIOImageReadSession::~IIOImageReadSession((IIOImageReadSession *)v4);
}

void sub_187FA6FF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  IIOImageReadSession::~IIOImageReadSession((IIOImageReadSession *)&a9);
  _Unwind_Resume(a1);
}

char *std::vector<IIODecodeFrameParams>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0x2E8BA2E8BA2E8BBLL)
    std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIODecodeFrameParams>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[88 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<IIODecodeFrameParams>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x2E8BA2E8BA2E8BBLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(88 * a2);
}

void std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        IIODecodeFrameParams::~IIODecodeFrameParams((IIODecodeFrameParams *)(v4 - 88));
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

_QWORD *std::string::basic_string[abi:ne180100]<0>(_QWORD *a1, char *__s)
{
  size_t v4;
  size_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v5 = v4;
  if (v4 >= 0x17)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((_BYTE *)a1 + 23) = v4;
    v6 = a1;
    if (!v4)
      goto LABEL_9;
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((_BYTE *)v6 + v5) = 0;
  return a1;
}

void std::string::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("basic_string");
}

uint64_t std::__split_buffer<IIODecodeFrameParams>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 88;
    IIODecodeFrameParams::~IIODecodeFrameParams((IIODecodeFrameParams *)(i - 88));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

_QWORD *std::shared_ptr<IIOBaseObject>::shared_ptr[abi:ne180100]<IIOFrameBufferQueue,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_1E1BBC308;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_187FA727C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<IIOFrameBufferQueue *,std::shared_ptr<IIOBaseObject>::__shared_ptr_default_delete<IIOBaseObject,IIOFrameBufferQueue>,std::allocator<IIOFrameBufferQueue>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x18D761C30);
}

uint64_t std::__shared_ptr_pointer<IIOFrameBufferQueue *,std::shared_ptr<IIOBaseObject>::__shared_ptr_default_delete<IIOBaseObject,IIOFrameBufferQueue>,std::allocator<IIOFrameBufferQueue>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t std::__shared_ptr_pointer<IIOFrameBufferQueue *,std::shared_ptr<IIOBaseObject>::__shared_ptr_default_delete<IIOBaseObject,IIOFrameBufferQueue>,std::allocator<IIOFrameBufferQueue>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

BOOL std::type_info::operator==[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  if (v2 == v3)
    return 1;
  if ((v3 & v2) < 0 != __OFSUB__(v2, v3))
    return strcmp((const char *)(v2 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  return 0;
}

uint64_t png_read_filter_row_sub4_a64(uint64_t result, uint64_t a2)
{
  int8x8_t v2;
  int8x8_t v3;
  int8x8_t v4;
  int8x8_t v5;
  unint64_t v6;
  unint64_t v7;
  int8x16_t v8;
  int8x16_t v9;
  int8x8_t v10;
  int8x8_t v11;
  int8x8_t v12;
  int8x8_t v13;
  int8x8_t v14;
  BOOL v15;
  float32x4x4_t v16;

  v6 = *(_QWORD *)(result + 8) + 15;
  if ((v6 & 0xFFFFFFFFFFFFFFC0) != 0)
  {
    v7 = v6 & 0xFFFFFFFFFFFFFFC0;
    v8 = 0uLL;
    do
    {
      v16 = vld4q_f32((const float *)a2);
      v16.val[0] = (float32x4_t)vaddq_s8(v8, (int8x16_t)v16.val[0]);
      v16.val[1] = (float32x4_t)vaddq_s8((int8x16_t)v16.val[0], (int8x16_t)v16.val[1]);
      v16.val[2] = (float32x4_t)vaddq_s8((int8x16_t)v16.val[1], (int8x16_t)v16.val[2]);
      v16.val[3] = (float32x4_t)vaddq_s8((int8x16_t)v16.val[2], (int8x16_t)v16.val[3]);
      v9 = vaddq_s8(vaddq_s8(vextq_s8((int8x16_t)0, (int8x16_t)v16.val[3], 0xCuLL), vextq_s8((int8x16_t)0, (int8x16_t)v16.val[3], 8uLL)), vextq_s8((int8x16_t)0, (int8x16_t)v16.val[3], 4uLL));
      v16.val[0] = (float32x4_t)vaddq_s8(v9, (int8x16_t)v16.val[0]);
      v16.val[1] = (float32x4_t)vaddq_s8(v9, (int8x16_t)v16.val[1]);
      v16.val[2] = (float32x4_t)vaddq_s8(v9, (int8x16_t)v16.val[2]);
      v16.val[3] = (float32x4_t)vaddq_s8(v9, (int8x16_t)v16.val[3]);
      v8 = (int8x16_t)v16.val[3].u32[3];
      vst4q_f32((float *)a2, v16);
      a2 += 64;
      v7 -= 64;
    }
    while (v7);
    v6 &= 0x3Fu;
    v10 = (int8x8_t)*(unsigned int *)(a2 - 4);
  }
  else
  {
    v10 = 0;
  }
  if (v6 >= 0x10)
  {
    v11 = v10;
    do
    {
      v2.i32[0] = *(_DWORD *)a2;
      v3.i32[0] = *(_DWORD *)(a2 + 4);
      v4.i32[0] = *(_DWORD *)(a2 + 8);
      v5.i32[0] = *(_DWORD *)(a2 + 12);
      v12 = vadd_s8(v11, v2);
      v13 = vadd_s8(v12, v3);
      v14 = vadd_s8(v13, v4);
      v11 = vadd_s8(v14, v5);
      *(_DWORD *)a2 = v12.i32[0];
      *(_DWORD *)(a2 + 4) = v13.i32[0];
      *(_DWORD *)(a2 + 8) = v14.i32[0];
      *(_DWORD *)(a2 + 12) = v11.i32[0];
      a2 += 16;
      v15 = v6 >= 0x10;
      v6 -= 16;
    }
    while (v15);
  }
  return result;
}

uint8x16_t png_read_filter_row_avg4_a64(uint64_t a1, unsigned __int32 *a2, __int32 *a3, double a4, double a5, double a6, double a7, int8x16_t a8, int8x16_t a9, int8x16_t a10, int8x16_t a11)
{
  uint8x16_t v11;
  uint8x16_t v12;
  uint8x16_t v13;
  uint8x16_t v14;
  unint64_t v15;
  uint8x16_t v16;
  uint8x16_t result;
  uint8x16_t v18;
  uint8x16_t v19;
  BOOL v20;

  v15 = *(_QWORD *)(a1 + 8) + 15;
  v16 = 0uLL;
  do
  {
    a8.i32[0] = *a2;
    a9.i32[0] = a2[1];
    a10.i32[0] = a2[2];
    a11.i32[0] = a2[3];
    v11.i32[0] = *a3;
    v12.i32[0] = a3[1];
    v13.i32[0] = a3[2];
    v14.i32[0] = a3[3];
    a3 += 4;
    result = (uint8x16_t)vaddq_s8((int8x16_t)vhaddq_u8(v16, v11), a8);
    v18 = (uint8x16_t)vaddq_s8((int8x16_t)vhaddq_u8(result, v12), a9);
    v19 = (uint8x16_t)vaddq_s8((int8x16_t)vhaddq_u8(v18, v13), a10);
    v16 = (uint8x16_t)vaddq_s8((int8x16_t)vhaddq_u8(v19, v14), a11);
    *a2 = result.i32[0];
    a2[1] = v18.i32[0];
    a2[2] = v19.i32[0];
    a2[3] = v16.i32[0];
    a2 += 4;
    v20 = v15 >= 0x10;
    v15 -= 16;
  }
  while (v20);
  return result;
}

uint64_t _CGImagePlusCopyDebugDesc(const void *a1)
{
  return 0;
}

void IIOImagePlus::setClipPath(IIOImagePlus *this, const CGPath *a2)
{
  const CGPath *v4;

  v4 = (const CGPath *)*((_QWORD *)this + 23);
  if (v4)
    CGPathRelease(v4);
  *((_QWORD *)this + 23) = a2;
}

uint64_t IIOImagePlus::setJpegProvider(uint64_t this, int a2)
{
  *(_BYTE *)(this + 192) |= 1u;
  *(_DWORD *)(this + 196) = a2;
  return this;
}

CGImageRef IIOImagePlus::setImage(CGImageRef *this, CGImageRef image)
{
  CGImageRef result;

  CGImageGetWidth(image);
  CGImageGetHeight(image);
  CGImageGetBitsPerComponent(image);
  CGImageGetBitsPerPixel(image);
  CGImageGetBytesPerRow(image);
  CGImageGetColorSpace(image);
  CGImageGetAlphaInfo(image);
  _ImageIsFloat(image);
  _ImageGetEndianInfo(image);
  CGImageRelease(this[16]);
  result = CGImageRetain(image);
  this[16] = result;
  if (*((_DWORD *)this + 34) != -6)
    *((_DWORD *)this + 34) = 0;
  return result;
}

uint64_t IIOImagePlus::setRemoveCacheKey(uint64_t this, int a2)
{
  char v2;

  if (a2)
    v2 = 32;
  else
    v2 = 0;
  *(_BYTE *)(this + 192) = *(_BYTE *)(this + 192) & 0xDF | v2;
  return this;
}

uint64_t IIOImagePlus::setImageIndex(uint64_t this, uint64_t a2)
{
  *(_QWORD *)(this + 208) = a2;
  return this;
}

CFTypeRef IIOImagePlus::setMetadata(IIOImagePlus *this, CFTypeRef cf)
{
  const void *v4;
  CFTypeRef result;

  v4 = (const void *)*((_QWORD *)this + 15);
  if (v4)
    CFRelease(v4);
  result = CFRetain(cf);
  *((_QWORD *)this + 15) = result;
  return result;
}

void IIOImagePlus::clearProperties(IIODictionary **this)
{
  IIODictionary::removeAllObjects(this[14]);
  if (*((_BYTE *)this + 180))
    IIODictionary::setObjectForKey(this[14], (const void *)*MEMORY[0x1E0C955E0], CFSTR("kCGImageSourceColorTransformOption"));
}

void IIOImagePlus::appendProperties(IIODictionary **this, const __CFDictionary **a2)
{
  IIODictionary::appendDictionary(this[14], a2);
}

CGMutableImageMetadataRef IIOImagePlus::clearMetadata(IIOImagePlus *this)
{
  CGMutableImageMetadataRef result;

  result = (CGMutableImageMetadataRef)*((_QWORD *)this + 15);
  if (result)
  {
    CFRelease(result);
    result = CGImageMetadataCreateMutable();
    *((_QWORD *)this + 15) = result;
  }
  return result;
}

uint64_t IIOImagePlus::getMatchToProfileOption(IIOImagePlus *this)
{
  return *((unsigned __int8 *)this + 180);
}

uint64_t IIOImageProviderInfo::CopyIOSurfaceSet(uint64_t *a1, const void *a2, const __CFDictionary *a3)
{
  uint64_t v6;
  uint64_t v7;

  kdebug_trace();
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CopyIOSurfaceSet", a2, 0, -1, a3);
  if (a1)
    v7 = IIOImageProviderInfo::copyIOSurfaceSet(*a1, v6, a3);
  else
    v7 = 0;
  kdebug_trace();
  return v7;
}

uint64_t IIOImagePlus::setReadPluginType(uint64_t this, int a2)
{
  *(_DWORD *)(this + 176) = a2;
  return this;
}

void IIOImageProviderInfo::debugCallbackOptionsResult(int a1, CFDictionaryRef theDict, uint64_t a3)
{
  int64_t Count;
  const void **v5;
  const __CFString *v6;
  const __CFString *v7;
  const __CFString *v8;
  const __CFString *v9;
  CFNumberRef *v10;
  CFStringRef *v11;
  const __CFString *v12;
  const void **v13;
  const void **v14;
  const __CFString *theString2;
  unint64_t valuePtr;

  if (theDict && a3)
  {
    valuePtr = 0;
    Count = CFDictionaryGetCount(theDict);
    v5 = (const void **)malloc_type_calloc(Count, 8uLL, 0x6004044C4A2DFuLL);
    v13 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
    v14 = v5;
    CFDictionaryGetKeysAndValues(theDict, v5, v13);
    if (Count >= 1)
    {
      v6 = (const __CFString *)*MEMORY[0x1E0C9DAB0];
      v7 = (const __CFString *)*MEMORY[0x1E0C9DAC0];
      v8 = (const __CFString *)*MEMORY[0x1E0C9DA90];
      theString2 = (const __CFString *)*MEMORY[0x1E0C9DA98];
      v9 = (const __CFString *)*MEMORY[0x1E0C9DAA8];
      v10 = (CFNumberRef *)v13;
      v11 = (CFStringRef *)v14;
      while (1)
      {
        v12 = *v11;
        if (CFStringCompare(*v11, v6, 0) == kCFCompareEqualTo)
          break;
        if (CFStringCompare(v12, v7, 0) == kCFCompareEqualTo)
        {
          CFNumberGetValue(*v10, kCFNumberLongType, &valuePtr);
          if (valuePtr != 1 || CGImageBlockSetGetCount() == 1)
            goto LABEL_20;
          ImageIOLog("%s", "***************************************************************");
          ImageIOLog("*** bad blockCount: got %ld - expected: 1\n");
          goto LABEL_19;
        }
        if (CFStringCompare(v12, v8, 0))
        {
          if (CFStringCompare(v12, theString2, 0))
            goto LABEL_20;
          CFNumberGetValue(*v10, kCFNumberLongType, &valuePtr);
          CGImageBlockSetGetImageBlock();
          if (!(CGImageBlockGetBytesPerRow() % valuePtr))
            goto LABEL_20;
          ImageIOLog("%s", "***************************************************************");
          ImageIOLog("*** bad rowbytes alignment: %p (%d) is not %ld-byte aligned\n");
          goto LABEL_19;
        }
        CFNumberGetValue(*v10, kCFNumberLongType, &valuePtr);
        CGImageBlockSetGetImageBlock();
        if (CGImageBlockGetData() % valuePtr)
        {
          ImageIOLog("%s", "***************************************************************");
          ImageIOLog("*** bad baseAddressAlignment: %p is not %ld aligned\n");
LABEL_19:
          ImageIOLog("%s", "***************************************************************");
        }
LABEL_20:
        ++v10;
        ++v11;
        if (!--Count)
          goto LABEL_21;
      }
      if (CFStringCompare((CFStringRef)*v10, v9, 0) || CGImageBlockSetGetPixelSize() == 4)
        goto LABEL_20;
      ImageIOLog("%s", "***************************************************************");
      ImageIOLog("*** bad pixelSize: got %ld - expected: 4\n");
      goto LABEL_19;
    }
LABEL_21:
    free(v14);
    free(v13);
  }
}

void IIOImageProviderInfo::logBlockSetDecodingTime(uint64_t a1, uint64_t a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  uint64_t Count;
  uint64_t BytesPerRow;
  const __CFDictionary *v23;
  const void *Value;
  IIOImageRead *v25;
  char *v26;
  int v27;
  unsigned int v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  unsigned int v32;
  int v33;
  uint64_t v34;
  unsigned int v35;
  int v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  const char *v40;
  double v41;
  double v42;

  if (a2)
  {
    if ((gIIODebugFlags & 8) != 0)
      IIODebug_ShowBacktrace(1);
    CGImageBlockSetGetRect();
    v41 = v16;
    v42 = v15;
    v18 = v17;
    v20 = v19;
    Count = CGImageBlockSetGetCount();
    if (Count)
    {
      CGImageBlockSetGetImageBlock();
      BytesPerRow = CGImageBlockGetBytesPerRow();
    }
    else
    {
      BytesPerRow = 0;
    }
    v23 = **(const __CFDictionary ***)(a1 + 112);
    if (v23 && (Value = CFDictionaryGetValue(v23, CFSTR("kImageIOInfoHeader_session"))) != 0)
    {
      v25 = (IIOImageRead *)CGImageReadSessionGetRead((uint64_t)Value);
      v26 = IIOImageRead::copySourceInfo(v25);
    }
    else
    {
      v26 = 0;
    }
    v27 = *(_DWORD *)(a1 + 128);
    v28 = v27 >> 24;
    v29 = MEMORY[0x1E0C80978];
    if (v27 < 0)
      v30 = __maskrune(v27 >> 24, 0x40000uLL);
    else
      v30 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v28 + 60) & 0x40000;
    if (v30)
      v31 = v28;
    else
      v31 = 46;
    v32 = v27 << 8 >> 24;
    if (v27 << 8 < 0)
      v33 = __maskrune(v27 << 8 >> 24, 0x40000uLL);
    else
      v33 = *(_DWORD *)(v29 + 4 * v32 + 60) & 0x40000;
    if (v33)
      v34 = v32;
    else
      v34 = 46;
    v35 = (__int16)v27 >> 8;
    if (v27 << 16 < 0)
      v36 = __maskrune((__int16)v27 >> 8, 0x40000uLL);
    else
      v36 = *(_DWORD *)(v29 + 4 * v35 + 60) & 0x40000;
    if (v36)
      v37 = v35;
    else
      v37 = 46;
    if ((v27 << 24) <= 0x7F000000)
      v38 = *(_DWORD *)(v29 + 4 * (char)v27 + 60) & 0x40000;
    else
      v38 = __maskrune((char)v27, 0x40000uLL);
    if (v38)
      v39 = (char)v27;
    else
      v39 = 46;
    v40 = "";
    if (v26)
      v40 = v26;
    ImageIOLog("    '%c%c%c%c' CopyImageBlockSet\tsRect={%g, %g, %g, %g}\tdSize={%g,%g}\tblkSet={%g, %g, %g, %g}\t#=%2d\trb=%ld\ttime: %g ms\t%s\n", v31, v34, v37, v39, a3, a4, a5, a6, a7, a8, v42, v41, v18, v20, Count, BytesPerRow, *(double *)(a1 + 136) * 1000.0,
      v40);
    if (v26)
      free(v26);
  }
  else
  {
    ImageIOLog("*** CopyImageBlockSet returned NULL\n");
  }
}

void IIOImageProviderInfo::logSurfaceDecodingTime(IIOImageProviderInfo *this, __IOSurface *a2)
{
  const __CFDictionary *v4;
  const void *Value;
  IIOImageRead **Source;
  signed int PixelFormat;
  size_t Width;
  size_t Height;
  int v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  unsigned int v21;
  uint64_t v22;
  int v23;
  int v24;
  int v25;
  unsigned int v26;
  __darwin_ct_rune_t v27;
  int v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const char *v37;
  int v38;
  uint64_t v39;
  int v40;
  int v41;
  int v42;
  char *v43;
  size_t v44;
  size_t v45;
  IIOImageProviderInfo *v46;

  if ((gIIODebugFlags & 8) != 0)
    IIODebug_ShowBacktrace(1);
  v4 = (const __CFDictionary *)**((_QWORD **)this + 14);
  if (v4 && (Value = CFDictionaryGetValue(v4, CFSTR("kImageIOInfoHeader_session"))) != 0)
  {
    Source = (IIOImageRead **)CGImageSourceGetSource((uint64_t)Value);
    v43 = IIOImageReadSession::copySourceInfo(Source);
  }
  else
  {
    v43 = 0;
  }
  PixelFormat = IOSurfaceGetPixelFormat(a2);
  Width = IOSurfaceGetWidth(a2);
  Height = IOSurfaceGetHeight(a2);
  v10 = *((_DWORD *)this + 32);
  v11 = v10 >> 24;
  v12 = MEMORY[0x1E0C80978];
  v44 = Height;
  if (v10 < 0)
  {
    v42 = __maskrune(v11, 0x40000uLL);
    v10 = *((_DWORD *)this + 32);
  }
  else
  {
    v42 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v11 + 60) & 0x40000;
  }
  v13 = v10 << 8 >> 24;
  v45 = Width;
  if (v10 << 8 < 0)
  {
    v41 = __maskrune(v13, 0x40000uLL);
    v14 = *((_DWORD *)this + 32);
  }
  else
  {
    v41 = *(_DWORD *)(v12 + 4 * v13 + 60) & 0x40000;
    v14 = v10;
  }
  v15 = (__int16)v14 >> 8;
  if (v14 << 16 < 0)
  {
    v40 = __maskrune(v15, 0x40000uLL);
    v16 = *((_DWORD *)this + 32);
  }
  else
  {
    v40 = *(_DWORD *)(v12 + 4 * v15 + 60) & 0x40000;
    v16 = v14;
  }
  if ((v16 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v12 + 4 * (char)v16 + 60) & 0x40000) != 0)
      goto LABEL_18;
  }
  else if (__maskrune((char)v16, 0x40000uLL))
  {
LABEL_18:
    v17 = *((char *)this + 128);
    goto LABEL_21;
  }
  v17 = 46;
LABEL_21:
  v39 = v17;
  v18 = PixelFormat >> 24;
  if (PixelFormat < 0)
    v38 = __maskrune(PixelFormat >> 24, 0x40000uLL);
  else
    v38 = *(_DWORD *)(v12 + 4 * v18 + 60) & 0x40000;
  v19 = PixelFormat << 8 >> 24;
  v46 = this;
  if (PixelFormat << 8 < 0)
    v20 = __maskrune(PixelFormat << 8 >> 24, 0x40000uLL);
  else
    v20 = *(_DWORD *)(v12 + 4 * v19 + 60) & 0x40000;
  v21 = (__int16)PixelFormat >> 8;
  v22 = v12;
  if (PixelFormat << 16 < 0)
  {
    v24 = v20;
    v25 = __maskrune((__int16)PixelFormat >> 8, 0x40000uLL);
    v20 = v24;
    v23 = v25;
  }
  else
  {
    v23 = *(_DWORD *)(v12 + 4 * v21 + 60) & 0x40000;
  }
  v26 = (char)PixelFormat;
  if ((PixelFormat << 24) <= 0x7F000000)
  {
    v29 = *(_DWORD *)(v22 + 4 * (char)PixelFormat + 60) & 0x40000;
  }
  else
  {
    v27 = (char)PixelFormat;
    v28 = v20;
    v29 = __maskrune(v27, 0x40000uLL);
    v20 = v28;
  }
  LODWORD(v30) = (__int16)v16 >> 8;
  if (v40)
    v30 = v30;
  else
    v30 = 46;
  LODWORD(v31) = v14 << 8 >> 24;
  if (v41)
    v31 = v31;
  else
    v31 = 46;
  LODWORD(v32) = v10 >> 24;
  if (v42)
    v32 = v32;
  else
    v32 = 46;
  if (v23)
    v33 = v21;
  else
    v33 = 46;
  if (v20)
    v34 = v19;
  else
    v34 = 46;
  if (v38)
    v35 = v18;
  else
    v35 = 46;
  if (v29)
    v36 = v26;
  else
    v36 = 46;
  v37 = "";
  if (v43)
    v37 = v43;
  ImageIOLog("    '%c%c%c%c' CopyIOSurface\tformat=(%c%c%c%c)\tsize=(%zu,%zu)\ttime: %g ms\t%s\n", v32, v31, v30, v39, v35, v34, v33, v36, v45, v44, *((double *)v46 + 17) * 1000.0, v37);
  free(v43);
}

void IIOImageProviderInfo::logSurfaceSetDecodingTime(uint64_t a1)
{
  const __CFDictionary *v2;
  const void *Value;
  __IOSurface *IOSurface;
  signed int PixelFormat;
  size_t Width;
  size_t Height;
  int v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  unsigned int v19;
  uint64_t v20;
  int v21;
  int v22;
  int v23;
  unsigned int v24;
  __darwin_ct_rune_t v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  int v36;
  uint64_t v37;
  int v38;
  int v39;
  int v40;
  char *SessionCopySourceInfo;
  size_t v42;
  size_t v43;
  uint64_t v44;

  if ((gIIODebugFlags & 8) != 0)
    IIODebug_ShowBacktrace(1);
  v2 = **(const __CFDictionary ***)(a1 + 112);
  if (v2 && (Value = CFDictionaryGetValue(v2, CFSTR("kImageIOInfoHeader_session"))) != 0)
    SessionCopySourceInfo = CGImageReadSessionCopySourceInfo((uint64_t)Value);
  else
    SessionCopySourceInfo = 0;
  IOSurface = (__IOSurface *)CGImageSurfaceSetGetIOSurface();
  PixelFormat = IOSurfaceGetPixelFormat(IOSurface);
  Width = IOSurfaceGetWidth(IOSurface);
  Height = IOSurfaceGetHeight(IOSurface);
  v8 = *(_DWORD *)(a1 + 128);
  v9 = v8 >> 24;
  v10 = MEMORY[0x1E0C80978];
  v42 = Height;
  if (v8 < 0)
  {
    v40 = __maskrune(v9, 0x40000uLL);
    v8 = *(_DWORD *)(a1 + 128);
  }
  else
  {
    v40 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v9 + 60) & 0x40000;
  }
  v11 = v8 << 8 >> 24;
  v43 = Width;
  if (v8 << 8 < 0)
  {
    v39 = __maskrune(v11, 0x40000uLL);
    v12 = *(_DWORD *)(a1 + 128);
  }
  else
  {
    v39 = *(_DWORD *)(v10 + 4 * v11 + 60) & 0x40000;
    v12 = v8;
  }
  v13 = (__int16)v12 >> 8;
  if (v12 << 16 < 0)
  {
    v38 = __maskrune(v13, 0x40000uLL);
    v14 = *(_DWORD *)(a1 + 128);
  }
  else
  {
    v38 = *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
    v14 = v12;
  }
  if ((v14 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v10 + 4 * (char)v14 + 60) & 0x40000) != 0)
      goto LABEL_18;
  }
  else if (__maskrune((char)v14, 0x40000uLL))
  {
LABEL_18:
    v15 = *(char *)(a1 + 128);
    goto LABEL_21;
  }
  v15 = 46;
LABEL_21:
  v37 = v15;
  v16 = PixelFormat >> 24;
  if (PixelFormat < 0)
    v36 = __maskrune(PixelFormat >> 24, 0x40000uLL);
  else
    v36 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
  v17 = PixelFormat << 8 >> 24;
  v44 = a1;
  if (PixelFormat << 8 < 0)
    v18 = __maskrune(PixelFormat << 8 >> 24, 0x40000uLL);
  else
    v18 = *(_DWORD *)(v10 + 4 * v17 + 60) & 0x40000;
  v19 = (__int16)PixelFormat >> 8;
  v20 = v10;
  if (PixelFormat << 16 < 0)
  {
    v22 = v18;
    v23 = __maskrune((__int16)PixelFormat >> 8, 0x40000uLL);
    v18 = v22;
    v21 = v23;
  }
  else
  {
    v21 = *(_DWORD *)(v10 + 4 * v19 + 60) & 0x40000;
  }
  v24 = (char)PixelFormat;
  if ((PixelFormat << 24) <= 0x7F000000)
  {
    v27 = *(_DWORD *)(v20 + 4 * (char)PixelFormat + 60) & 0x40000;
  }
  else
  {
    v25 = (char)PixelFormat;
    v26 = v18;
    v27 = __maskrune(v25, 0x40000uLL);
    v18 = v26;
  }
  LODWORD(v28) = (__int16)v14 >> 8;
  if (v38)
    v28 = v28;
  else
    v28 = 46;
  LODWORD(v29) = v12 << 8 >> 24;
  if (v39)
    v29 = v29;
  else
    v29 = 46;
  LODWORD(v30) = v8 >> 24;
  if (v40)
    v30 = v30;
  else
    v30 = 46;
  if (v21)
    v31 = v19;
  else
    v31 = 46;
  if (v18)
    v32 = v17;
  else
    v32 = 46;
  if (v36)
    v33 = v16;
  else
    v33 = 46;
  if (v27)
    v34 = v24;
  else
    v34 = 46;
  v35 = "";
  if (SessionCopySourceInfo)
    v35 = SessionCopySourceInfo;
  ImageIOLog("    '%c%c%c%c' CopyIOSurfaceSet\tformat=(%c%c%c%c)\tsize=(%zu,%zu)\ttime: %g ms\t%s\n", v30, v29, v28, v37, v33, v32, v31, v34, v43, v42, *(double *)(v44 + 136) * 1000.0, v35);
  free(SessionCopySourceInfo);
}

uint64_t IIOImageProviderInfo::copyIOSurfaceSet(uint64_t a1, uint64_t a2, const __CFDictionary *a3)
{
  CFTypeRef *v5;
  const __CFDictionary *v6;
  CFTypeID v7;
  const void *v8;
  const void *Value;
  IIOImageRead *v10;
  const char *v11;
  _BOOL4 v12;
  uint64_t v13;

  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "copyIOSurfaceSet", 0, 0, -1, a3);
  IIOInitDebugFlags();
  if ((gIIODebugFlags & 0xC) != 0)
    *(CFAbsoluteTime *)(a1 + 136) = CFAbsoluteTimeGetCurrent();
  if (*(_QWORD *)(a1 + 232))
  {
    v5 = *(CFTypeRef **)(a1 + 112);
    if (v5)
    {
      v6 = (const __CFDictionary *)*v5;
      if (*v5)
      {
        v7 = CFGetTypeID(*v5);
        if (v7 == CFDictionaryGetTypeID())
        {
          pthread_mutex_lock((pthread_mutex_t *)(a1 + 144));
          v8 = (const void *)*MEMORY[0x1E0C9AE50];
          if (v8 == CFDictionaryGetValue(v6, CFSTR("kImageIOInfoHeader_pluginHandlesReMapping")))
          {
            v12 = 0;
            v11 = 0;
          }
          else
          {
            Value = CFDictionaryGetValue(v6, CFSTR("kImageIOInfoHeader_session"));
            v10 = (IIOImageRead *)CGImageReadSessionGetRead((uint64_t)Value);
            v11 = (const char *)v10;
            if (v10)
              v12 = IIOImageRead::mapData(v10);
            else
              v12 = 0;
          }
          v13 = (*(uint64_t (**)(_QWORD, _QWORD, const __CFDictionary *))(a1 + 232))(*(_QWORD *)(a1 + 112), *(_QWORD *)(a1 + 16), a3);
          if (v13 && (gIIODebugFlags & 0xC) != 0)
          {
            *(CFAbsoluteTime *)(a1 + 136) = CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 136);
            IIOImageProviderInfo::logSurfaceSetDecodingTime(a1);
          }
          if (v12 && v11)
            IIOImageRead::unmapData(v11);
          pthread_mutex_unlock((pthread_mutex_t *)(a1 + 144));
          if (v13)
            return v13;
          goto LABEL_24;
        }
      }
    }
    else
    {
      v6 = 0;
    }
    LogFault("copyIOSurfaceSet", 2434, "header '%p' is not a CFDictionary...\n", v6);
    return 0;
  }
  v13 = 0;
LABEL_24:
  if ((gIIODebugFlags & 0x800000000000) != 0)
  {
    ImageIOLog(" ISSUE: %s:%d:  %s\n", "copyIOSurfaceSet", 2465, "returned ioSurfaceSet is NULL\n");
    return 0;
  }
  return v13;
}

unint64_t IIOPackCopyCallbackInfo(uint64_t a1, CFDictionaryRef theDict)
{
  unint64_t v4;
  int v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t result;

  if (theDict)
  {
    if (CFDictionaryContainsKey(theDict, (const void *)*MEMORY[0x1E0C9DAB0]))
      v4 = 0x4000000000000000;
    else
      v4 = 0x8000000000000000;
    v5 = CFDictionaryContainsKey(theDict, (const void *)*MEMORY[0x1E0C9DAC0]);
    v6 = 0x1000000000000000;
    if (!v5)
      v6 = 0x2000000000000000;
    v7 = v6 | v4;
    if (CFDictionaryContainsKey(theDict, CFSTR("kCGImageBlockIOSurfaceOptimizedRequest")))
      v8 = 0x400000000000000;
    else
      v8 = 0x800000000000000;
    v9 = CFDictionaryContainsKey(theDict, (const void *)*MEMORY[0x1E0C9DAA0]);
    v10 = 0x100000000000000;
    if (!v9)
      v10 = 0x200000000000000;
    v11 = v7 | v8 | v10;
    v12 = CFDictionaryContainsKey(theDict, (const void *)*MEMORY[0x1E0C9DA90]);
    v13 = 0x40000000000000;
    if (!v12)
      v13 = 0x80000000000000;
    v14 = v11 | v13;
    if (CFDictionaryContainsKey(theDict, (const void *)*MEMORY[0x1E0C9DA98]))
    {
      result = v14 | 0x10000000000000;
      if (!a1)
        return result;
    }
    else
    {
      result = v14 | 0x20000000000000;
      if (!a1)
        return result;
    }
  }
  else
  {
    result = 0xAAA0000000000000;
    if (!a1)
      return result;
  }
  result |= ((unint64_t)*(_QWORD *)(a1 + 48) << 32) & 0xFFFF00FFFFFFFFFFLL | ((unint64_t)*(_QWORD *)(a1 + 56) << 40);
  return result;
}

uint64_t CGImageMetadataValueGetTypeID()
{
  unsigned int v0;

  IIOInitDebugFlags();
  v0 = (unsigned __int16)gIIODebugFlags >> 14;
  if (v0 >= 2)
    ImageIODebugOptions(v0, "S", "CGImageMetadataValueGetTypeID", 0, 0, -1, 0);
  if (CGImageMetadataValueGetTypeID::once != -1)
    dispatch_once(&CGImageMetadataValueGetTypeID::once, &__block_literal_global_6);
  return CGImageMetadataValueGetTypeID::id;
}

double _CGImageMetadataValueFinalize(_QWORD *a1)
{
  unsigned int v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  double result;

  v2 = (gIIODebugFlags >> 12) & 3;
  if (v2)
    ImageIODebugOptions(v2, "A", "_CGImageMetadataValueFinalize", 0, 0, -1, 0);
  v3 = (const void *)a1[2];
  if (v3)
    CFRelease(v3);
  a1[2] = 0;
  v4 = (const void *)a1[3];
  if (v4)
    CFRelease(v4);
  a1[3] = 0;
  v5 = (const void *)a1[4];
  if (v5)
    CFRelease(v5);
  a1[4] = 0;
  v6 = (const void *)a1[6];
  if (v6)
    CFRelease(v6);
  a1[6] = 0;
  result = 0.0;
  *((_OWORD *)a1 + 1) = 0u;
  *((_OWORD *)a1 + 2) = 0u;
  return result;
}

CFStringRef _CGImageMetadataCopyDebugDesc(CFTypeRef cf)
{
  const void *v2;
  uint64_t v3;
  CFTypeID v4;
  CFTypeID TypeID;
  CFTypeID v6;
  const __CFAllocator *v7;
  const __CFString *v8;
  const __CFAllocator *v9;
  const __CFAllocator *v11;
  CFStringRef v12;
  const __CFAllocator *v13;
  CFStringRef v14;
  CFTypeRef v15;
  uint64_t v16;
  const void *ValueAtIndex;

  v2 = (const void *)*((_QWORD *)cf + 2);
  if (v2)
  {
    v3 = *((_QWORD *)cf + 6);
    v4 = CFGetTypeID(v2);
    TypeID = CFStringGetTypeID();
    v6 = TypeID;
    if (v3)
    {
      v7 = CFGetAllocator(cf);
      if (v4 == v6)
      {
        v16 = *((_QWORD *)cf + 2);
        ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)cf + 6), 0);
        v15 = cf;
        v8 = CFSTR("<CGImageMetadataValue %p> (value = \"%@\", qualifier = \"%@\")");
      }
      else
      {
        v15 = cf;
        v8 = CFSTR("<CGImageMetadataValue %p> (unimplemented description)");
      }
      return CFStringCreateWithFormat(v7, 0, v8, v15, v16, ValueAtIndex);
    }
    else if (v4 == TypeID)
    {
      v11 = CFGetAllocator(cf);
      return CFStringCreateWithFormat(v11, 0, CFSTR("<CGImageMetadataValue %p> (value = \"%@\")"), cf, *((_QWORD *)cf + 2));
    }
    else
    {
      v12 = CFCopyDescription(*((CFTypeRef *)cf + 2));
      v13 = CFGetAllocator(cf);
      v14 = CFStringCreateWithFormat(v13, 0, CFSTR("<CGImageMetadataValue %p> (value = \"%@\")"), cf, v12);
      CFRelease(v12);
      return v14;
    }
  }
  else
  {
    v9 = CFGetAllocator(cf);
    return CFStringCreateWithFormat(v9, 0, CFSTR("<CGImageMetadataValue %p>  (invalid)"), cf);
  }
}

uint64_t CGImageMetadataValueGetValue(uint64_t a1)
{
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageMetadataValueGetValue", 0, 0, -1, 0);
  if (a1)
    return *(_QWORD *)(a1 + 16);
  else
    return 0;
}

void CGImageMetadataValueAddQualifier(_QWORD *a1, const void *a2)
{
  CFTypeID v4;
  __CFArray *Mutable;

  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageMetadataValueAddQualifier", 0, 0, -1, 0);
  if (a1)
  {
    if (a2)
    {
      v4 = CFGetTypeID(a1);
      if (v4 == CGImageMetadataValueGetTypeID())
      {
        Mutable = (__CFArray *)a1[6];
        if (Mutable
          || (Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]),
              (a1[6] = Mutable) != 0))
        {
          CFArrayAppendValue(Mutable, a2);
        }
      }
    }
  }
}

uint64_t CGImageMetadataValueGetQualifiers(uint64_t a1)
{
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageMetadataValueGetQualifiers", 0, 0, -1, 0);
  if (a1)
    return *(_QWORD *)(a1 + 48);
  else
    return 0;
}

void CGImageMetadataValueSetNamespaceURI(uint64_t a1, const void *a2)
{
  const void *v4;

  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageMetadataValueSetNamespaceURI", 0, 0, -1, 0);
  if (a1)
  {
    v4 = *(const void **)(a1 + 24);
    if (v4)
      CFRelease(v4);
    *(_QWORD *)(a1 + 24) = 0;
    if (a2)
      *(_QWORD *)(a1 + 24) = CFRetain(a2);
  }
}

uint64_t CGImageMetadataValueGetNamespaceURI(uint64_t a1)
{
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageMetadataValueGetNamespaceURI", 0, 0, -1, 0);
  if (a1)
    return *(_QWORD *)(a1 + 24);
  else
    return 0;
}

void CGImageMetadataValueSetSuggestedNamespacePrefix(uint64_t a1, const void *a2)
{
  const void *v4;

  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageMetadataValueSetSuggestedNamespacePrefix", 0, 0, -1, 0);
  if (a1)
  {
    v4 = *(const void **)(a1 + 32);
    if (v4)
      CFRelease(v4);
    *(_QWORD *)(a1 + 32) = 0;
    if (a2)
      *(_QWORD *)(a1 + 32) = CFRetain(a2);
  }
}

uint64_t CGImageMetadataValueGetSuggestedNamespacePrefix(uint64_t a1)
{
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageMetadataValueGetSuggestedNamespacePrefix", 0, 0, -1, 0);
  if (a1)
    return *(_QWORD *)(a1 + 32);
  else
    return 0;
}

void CGImageMetadataValueSetIsAlternate(uint64_t a1, int a2)
{
  int v4;

  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageMetadataValueSetIsAlternate", 0, 0, -1, 0);
  if (a1)
  {
    if (a2)
      v4 = 2048;
    else
      v4 = 0;
    *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 40) & 0xFFFFF7FF | v4;
  }
}

uint64_t CGImageMetadataValueIsAlternate(uint64_t a1)
{
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageMetadataValueIsAlternate", 0, 0, -1, 0);
  if (a1)
    return (*(unsigned __int8 *)(a1 + 41) >> 3) & 1;
  else
    return 0;
}

void CGImageMetadataValueSetIsAlternateText(uint64_t a1, int a2)
{
  int v4;

  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageMetadataValueSetIsAlternateText", 0, 0, -1, 0);
  if (a1)
  {
    if (a2)
      v4 = 4096;
    else
      v4 = 0;
    *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 40) & 0xFFFFEFFF | v4;
  }
}

uint64_t CGImageMetadataValueIsAlternateText(uint64_t a1)
{
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageMetadataValueIsAlternateText", 0, 0, -1, 0);
  if (a1)
    return (*(unsigned __int8 *)(a1 + 41) >> 4) & 1;
  else
    return 0;
}

uint64_t CGImageMetadataValueCreate(const void *a1)
{
  uint64_t Instance;
  CFTypeRef v3;

  if (a1)
  {
    CGImageMetadataValueGetTypeID();
    Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      v3 = CFRetain(a1);
      *(_QWORD *)(Instance + 48) = 0;
      *(_QWORD *)(Instance + 24) = 0;
      *(_QWORD *)(Instance + 32) = 0;
      *(_QWORD *)(Instance + 16) = v3;
      *(_DWORD *)(Instance + 40) = 0;
    }
  }
  else
  {
    LogError("CGImageMetadataValueCreate", 365, "*** ERROR: parameter is NULL\n");
    return 0;
  }
  return Instance;
}

void WBMPReader::~WBMPReader(WBMPReader *this)
{
  JUMPOUT(0x18D761C30);
}

uint64_t WBMPReader::decodeBuffer(WBMPReader *this, vImage_Buffer *a2)
{
  vImagePixelCount width;
  unint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  vImagePixelCount height;
  vImage_Buffer srcs;
  _OWORD v12[5];

  memset(v12, 0, sizeof(v12));
  IIOPixelConverterGray::IIOPixelConverterGray((uint64_t)v12, 6, 1, 1u, 0, 6, 8u, 0, 0);
  width = a2->width;
  v5 = (width + 7) >> 3;
  v7 = *((_DWORD *)this + 4);
  v6 = *((unsigned int *)this + 5);
  if (v6 + (_DWORD)v5 * a2->height <= v7)
  {
    height = a2->height;
LABEL_6:
    srcs.data = (void *)(*((_QWORD *)this + 1) + v6);
    srcs.height = height;
    srcs.width = width;
    srcs.rowBytes = ((width + 7) >> 3);
    v8 = IIOPixelConverterGray::convert((IIOPixelConverterGray *)v12, &srcs, a2);
    goto LABEL_7;
  }
  if (v7 - v6 >= v5)
  {
    height = (v7 - v6) / v5;
    a2->height = height;
    goto LABEL_6;
  }
  v8 = 4294967246;
LABEL_7:
  IIOPixelConverterGray::~IIOPixelConverterGray((IIOPixelConverterGray *)v12);
  return v8;
}

void sub_187FA8F2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  IIOPixelConverterGray::~IIOPixelConverterGray((IIOPixelConverterGray *)va);
  _Unwind_Resume(a1);
}

CGImageRef CGImageCreateWithWBMPData(const __CFData *a1)
{
  const UInt8 *BytePtr;
  unsigned int Length;
  uint64_t v4;
  int v5;
  unint64_t v6;
  unsigned int v7;
  UInt8 v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  UInt8 v14;
  int v15;
  int v16;
  unint64_t v17;
  const UInt8 *v18;
  char v19;
  int v20;
  int v21;
  unint64_t v22;
  const UInt8 *v23;
  char v24;
  int v25;
  vImagePixelCount v26;
  size_t v27;
  vImagePixelCount v28;
  void *v29;
  void *v30;
  CGImageRef v31;
  CGDataProviderRef v33;
  CGDataProvider *v34;
  CGColorSpace *v35;
  vImage_Buffer v36;
  _QWORD v37[2];
  unsigned int v38;
  int v39;
  CGDataProviderDirectCallbacks callbacks;

  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageCreateWithWBMPData", 0, 0, -1, 0);
  *(_OWORD *)&callbacks.version = xmmword_1E1BC2060;
  *(_OWORD *)&callbacks.releaseBytePointer = *(_OWORD *)&off_1E1BC2070;
  callbacks.releaseInfo = releaseInfo;
  BytePtr = CFDataGetBytePtr(a1);
  Length = CFDataGetLength(a1);
  v4 = 0;
  v5 = 0;
  v38 = Length;
  v37[0] = &off_1E1BAB668;
  v37[1] = BytePtr;
  v6 = Length;
  while (Length != v4)
  {
    v7 = v4 + 1;
    v8 = BytePtr[v4];
    v9 = v8 & 0x7F | (v5 << 7);
    ++v4;
    v5 = v9;
    if ((v8 & 0x80) == 0)
    {
      if (v9)
      {
        if (v9 != -1)
          _cg_jpeg_mem_term("CGImageCreateWithWBMPData", 163, "*** unsupported WBMP type [%d]\n", v9);
      }
      else
      {
        v10 = 0;
        v11 = v7;
        if (v7 <= Length)
          v12 = Length;
        else
          v12 = v7;
        while (v11 != v12)
        {
          LODWORD(v13) = v11 + 1;
          v14 = BytePtr[v11];
          v15 = v14 & 0x7F | (v10 << 7);
          ++v11;
          v10 = v15;
          if ((v14 & 0x80) == 0)
          {
            if (v15 != -1)
            {
              v16 = 0;
              if (Length >= (unint64_t)v13)
                v17 = Length - (unint64_t)v13;
              else
                v17 = 0;
              v18 = &BytePtr[v13];
              while (v17)
              {
                v19 = *v18++;
                v20 = v19 & 0x7F | (v16 << 7);
                v13 = (v13 + 1);
                --v17;
                v16 = v20;
                if ((v19 & 0x80) == 0)
                {
                  if (v20 != -1)
                  {
                    v21 = 0;
                    if (v13 > Length)
                      v6 = v13;
                    v22 = v13 - v6;
                    v23 = &BytePtr[v13];
                    while (v22)
                    {
                      v24 = *v23++;
                      v25 = v24 & 0x7F | (v21 << 7);
                      ++v22;
                      LODWORD(v13) = v13 + 1;
                      v21 = v25;
                      if ((v24 & 0x80) == 0)
                      {
                        v39 = v13;
                        if (v25 == -1)
                          return 0;
                        v26 = (unsigned __int16)v20;
                        v27 = ((unsigned __int16)v20 + 7) & 0x1FFF8;
                        v28 = (unsigned __int16)v25;
                        v29 = malloc_type_malloc((unsigned __int16)v25 * v27, 0x3A086DFDuLL);
                        if (!v29)
                          return 0;
                        v30 = v29;
                        memset(v29, 192, (v28 * v27));
                        v36.data = v30;
                        v36.height = v28;
                        v36.width = v26;
                        v36.rowBytes = ((_DWORD)v26 + 7) & 0x1FFF8;
                        if (WBMPReader::decodeBuffer((WBMPReader *)v37, &v36)
                          || (v33 = CGDataProviderCreateDirect(v30, (v28 * v27), &callbacks)) == 0)
                        {
                          free(v30);
                          return 0;
                        }
                        v34 = v33;
                        v35 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D978]);
                        v31 = CGImageCreate(v26, v28, 8uLL, 8uLL, v27, v35, 0, v34, 0, 0, kCGRenderingIntentDefault);
                        if (v31)
                        {
                          CGImageSetProperty();
                          CGImageSetProperty();
                          CGImageSetProperty();
                        }
                        CGDataProviderRelease(v34);
                        CGColorSpaceRelease(v35);
                        return v31;
                      }
                    }
                  }
                  return 0;
                }
              }
            }
            return 0;
          }
        }
      }
      return 0;
    }
  }
  return 0;
}

void sub_187FA9230(_Unwind_Exception *a1)
{
  CGColorSpace *v1;

  CGColorSpaceRelease(v1);
  _Unwind_Resume(a1);
}

size_t getBytesAtPosition(char *a1, void *__dst, uint64_t a3, size_t __n)
{
  memcpy(__dst, &a1[a3], __n);
  return __n;
}

uint64_t TIFFErrorExt(uint64_t result, const char *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;

  v11 = result;
  if (_TIFFerrorHandler)
    result = _TIFFerrorHandler(a2, a3, &a9);
  if (_TIFFerrorHandlerExt)
    return _TIFFerrorHandlerExt(v11, a2, a3, &a9);
  return result;
}

_QWORD *_TIFFErrorEarly(_QWORD *result, uint64_t a2, const char *a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (!result
    || !*result
    || (result = (_QWORD *)((uint64_t (*)(_QWORD, _QWORD, const char *, char *, char *))*result)(0, result[1], a3, a4, &a9), !(_DWORD)result))
  {
    if (_TIFFerrorHandler)
      result = (_QWORD *)_TIFFerrorHandler(a3, a4, &a9);
    if (_TIFFerrorHandlerExt)
      return (_QWORD *)_TIFFerrorHandlerExt(a2, a3, a4, &a9);
  }
  return result;
}

uint64_t TIFFErrorExtR(uint64_t result, const char *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;

  v11 = result;
  if (!result
    || !*(_QWORD *)(result + 1328)
    || (result = (*(uint64_t (**)(uint64_t, _QWORD, const char *, char *, char *))(result + 1328))(result, *(_QWORD *)(result + 1336), a2, a3, &a9), !(_DWORD)result))
  {
    if (_TIFFerrorHandler)
      result = _TIFFerrorHandler(a2, a3, &a9);
    if (_TIFFerrorHandlerExt)
    {
      if (v11)
        v12 = *(_QWORD *)(v11 + 1200);
      else
        v12 = 0;
      return ((uint64_t (*)(uint64_t, const char *, char *, char *))_TIFFerrorHandlerExt)(v12, a2, a3, &a9);
    }
  }
  return result;
}

uint64_t NotConfigured(uint64_t a1)
{
  *(_QWORD *)(a1 + 952) = _notConfigured;
  *(_DWORD *)(a1 + 944) = 0;
  *(_QWORD *)(a1 + 960) = _notConfigured;
  *(_DWORD *)(a1 + 984) = 0;
  *(_QWORD *)(a1 + 976) = _notConfigured;
  return 1;
}

const char *_cg_TIFFIsCODECConfigured(int a1)
{
  const char *result;
  uint64_t (*v2)(uint64_t);

  result = _cg_TIFFFindCODEC(a1);
  if (result)
  {
    v2 = (uint64_t (*)(uint64_t))*((_QWORD *)result + 2);
    if (v2)
      return (const char *)(v2 != NotConfigured);
    else
      return 0;
  }
  return result;
}

uint64_t _notConfigured(uint64_t a1)
{
  const char *v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char __str[8];
  uint64_t v11;
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v2 = _cg_TIFFFindCODEC(*(unsigned __int16 *)(a1 + 120));
  *(_QWORD *)__str = 0;
  v11 = 0;
  v12 = 0;
  v3 = __str;
  snprintf(__str, 0x14uLL, "%hu", *(unsigned __int16 *)(a1 + 120));
  if (v2)
    v3 = *(char **)v2;
  TIFFErrorExtR(a1, *(const char **)a1, "%s compression support is not configured", v4, v5, v6, v7, v8, (char)v3);
  return 0;
}

CGImage *CGImageCreateByConvertingExtendedSRGBToColorspace(CGImage *a1, CGColorSpace *a2, IIODictionary *a3)
{
  double Current;
  CFStringRef *v5;
  unsigned int v6;
  size_t Width;
  size_t Height;
  signed int Uint32ForKey;
  CGColor *ObjectForKey;
  __IOSurface *IOSurfaceWithFormat;
  __IOSurface *v12;
  CGColorSpace *v13;
  CGContext *IOSurfaceContext;
  CGContext *v15;
  double v16;
  double v17;
  CGImageAlphaInfo AlphaInfo;
  CGImage *v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  int v23;
  uint64_t v24;
  unsigned int v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  CGColorSpace *ColorSpace;
  CGImageAlphaInfo v31;
  int v32;
  uint32_t v33;
  IIOColorConverter *v34;
  unint64_t v35;
  size_t BytesPerRow;
  char *BytePtr;
  const __CFData *v38;
  size_t v39;
  char *v40;
  unint64_t v41;
  vImagePixelCount v42;
  unint64_t v43;
  vImagePixelCount v44;
  vImage_Error v45;
  CGImage *v46;
  IIODictionary *v47;
  int v48;
  const __CFNumber *Property;
  CGImage *v50;
  int v51;
  CGColorSpace *v52;
  CGDataProvider *v53;
  unsigned int v54;
  vImage_Error v55;
  void *v57;
  CGColorSpace *v58;
  CGDataProvider *v59;
  const char *v60;
  unsigned int v61;
  int v62;
  uint64_t v63;
  unsigned int v64;
  int v65;
  uint64_t v66;
  unsigned int v67;
  int v68;
  uint64_t v69;
  int v70;
  uint64_t v71;
  CGBitmapInfo BitmapInfo;
  CGBitmapInfo v73;
  char *v74;
  const __CFData *v75;
  __n128 v76;
  unsigned int v77;
  unint64_t v78;
  unint64_t v79;
  CGImageAlphaInfo v80;
  uint32_t v81;
  CGContext *v82;
  CGContext *v83;
  uint64_t v84;
  unsigned int v85;
  unsigned int v86;
  double v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  double v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  int v100;
  int v101;
  const __CFString *name;
  uint64_t v103;
  int v104;
  CGDataProvider *provider;
  vImagePixelCount v108;
  CGColorSpace *v109;
  CGColorSpace *space;
  CGImage *image;
  vImage_Buffer src;
  vImage_Buffer dest;
  vImage_CGImageFormat v114;
  vImage_CGImageFormat v115;
  CGRect v116;
  CGRect v117;
  CGRect v118;
  CGRect v119;

  if ((gIIODebugFlags & 0x400000000) != 0)
    ImageIOLog("    %s\n", "CGImageCreateByConvertingExtendedSRGBToColorspace");
  Current = CFAbsoluteTimeGetCurrent();
  v5 = (CFStringRef *)MEMORY[0x1E0C9D908];
  if ((CGImageCreateByConvertingExtendedSRGBToColorspace(CGImage *,CGColorSpace *,IIODictionary *)::gUseColorConversionCA & 1) == 0)
  {
    if (IIOIsAppSuspended())
    {
      CGImageCreateByConvertingExtendedSRGBToColorspace(CGImage *,CGColorSpace *,IIODictionary *)::gUseColorConversionCA = 1;
    }
    else if ((CGImageCreateByConvertingExtendedSRGBToColorspace(CGImage *,CGColorSpace *,IIODictionary *)::gUseColorConversionCA & 1) == 0)
    {
      v6 = 1111970369;
      Width = CGImageGetWidth(a1);
      Height = CGImageGetHeight(a1);
      if (a3)
      {
        if (IIODictionary::containsKey(a3, CFSTR("Depth")))
        {
          Uint32ForKey = IIODictionary::getUint32ForKey(a3, CFSTR("Depth"));
          v6 = Uint32ForKey == 16 ? 1380411457 : 1111970369;
        }
        else
        {
          Uint32ForKey = 8;
        }
        ObjectForKey = IIODictionary::getObjectForKey(a3, CFSTR("backgroundColor"));
      }
      else
      {
        ObjectForKey = 0;
        Uint32ForKey = 8;
      }
      IOSurfaceWithFormat = IIO_CreateIOSurfaceWithFormat(Width, Height, (Width * 4 * (Uint32ForKey / 8) + 15) & 0xFFFFFFFFFFFFFFF0, v6, 1, 0);
      if (IOSurfaceWithFormat)
      {
        v12 = IOSurfaceWithFormat;
        v13 = CGColorSpaceCreateWithName(*v5);
        IIO_IOSurfaceAddColorSpace(v12, v13);
        IOSurfaceContext = (CGContext *)IIO_CreateIOSurfaceContext(v12, v13);
        v15 = IOSurfaceContext;
        if (!IOSurfaceContext)
          goto LABEL_22;
        if (ObjectForKey)
        {
          CGContextSetFillColorWithColor(IOSurfaceContext, ObjectForKey);
          v16 = (double)Width;
          v17 = (double)Height;
          v116.origin.x = 0.0;
          v116.origin.y = 0.0;
          v116.size.width = (double)Width;
          v116.size.height = (double)Height;
          CGContextFillRect(v15, v116);
        }
        else
        {
          CGContextClear();
          v16 = (double)Width;
          v17 = (double)Height;
        }
        v117.origin.x = 0.0;
        v117.origin.y = 0.0;
        v117.size.width = v16;
        v117.size.height = v17;
        CGContextDrawImage(v15, v117, a1);
        CGContextFlush(v15);
        memset(&v115, 0, 24);
        IIODictionary::IIODictionary((IIODictionary *)&v115);
        AlphaInfo = CGImageGetAlphaInfo(a1);
        IIONumber::IIONumber((IIONumber *)&v114, AlphaInfo);
        IIODictionary::setObjectForKey((uint64_t)&v115, (uint64_t)&v114, CFSTR("CGImageAlphaInfo"));
        IIONumber::~IIONumber((IIONumber *)&v114);
        v19 = CGImageCreateFromIOSurface(v12, v115.colorSpace);
        CGContextRelease(v15);
        IIODictionary::~IIODictionary((IIODictionary *)&v115);
        if (v19)
        {
          CFRelease(v12);
        }
        else
        {
LABEL_22:
          v20 = MEMORY[0x1E0C80978];
          if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * HIBYTE(v6) + 60) & 0x40000) != 0)
            v21 = HIBYTE(v6);
          else
            v21 = 46;
          v22 = (int)(v6 << 8) >> 24;
          if (((v6 << 8) & 0x80000000) != 0)
            v23 = __maskrune((int)(v6 << 8) >> 24, 0x40000uLL);
          else
            v23 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v22 + 60) & 0x40000;
          if (v23)
            v24 = v22;
          else
            v24 = 46;
          v25 = (__int16)v6 >> 8;
          if (((v6 << 16) & 0x80000000) != 0)
            v26 = __maskrune((__int16)v6 >> 8, 0x40000uLL);
          else
            v26 = *(_DWORD *)(v20 + 4 * v25 + 60) & 0x40000;
          if (v26)
            v27 = v25;
          else
            v27 = 46;
          v28 = 65;
          if ((*(_DWORD *)(v20 + 320) & 0x40000) == 0)
            v28 = 46;
          _cg_jpeg_mem_term("CGImageCreateByConvertingExtendedSRGBToColorspace_CA", 170, "CGImageCreateFromIOSurface failed to create a CGImage from a '%c%c%c%c' surface\n", v21, v24, v27, v28);
          IIO_IOSurfaceRelease(v12);
          v19 = 0;
        }
        CGColorSpaceRelease(v13);
        if (v19)
        {
          v29 = 1128341536;
          goto LABEL_131;
        }
      }
    }
  }
  ColorSpace = CGImageGetColorSpace(a1);
  v31 = CGImageGetAlphaInfo(a1);
  if (v31)
    v32 = v31;
  else
    v32 = 5;
  if (v31)
    v33 = 64;
  else
    v33 = 48;
  v115.colorSpace = ColorSpace;
  v115.bitmapInfo = v31 | 0x1100;
  memset(&v115.version, 0, 20);
  *(_QWORD *)&v114.bitsPerComponent = 0x4000000010;
  v114.colorSpace = a2;
  v101 = v32;
  v114.bitmapInfo = v32 | 0x1100;
  memset(&v114.version, 0, 20);
  v115.bitsPerComponent = 16;
  v115.bitsPerPixel = v33;
  v109 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
  name = *v5;
  space = CGColorSpaceCreateWithName(*v5);
  v34 = (IIOColorConverter *)operator new();
  IIOColorConverter::IIOColorConverter(v34, &v115, &v114, v109, space);
  v108 = CGImageGetWidth(a1);
  v35 = CGImageGetHeight(a1);
  BytesPerRow = CGImageGetBytesPerRow(a1);
  provider = CGImageGetDataProvider(a1);
  BytePtr = (char *)CGDataProviderRetainBytePtr();
  image = a1;
  if (BytePtr)
  {
    v38 = 0;
  }
  else
  {
    _cg_jpeg_mem_term("CGImageCreateByConvertingExtendedSRGBToColorspace_vImage", 223, "*** ERROR: CGImageCreateByConvertingExtendedSRGBToColorspace - cannot get bytePtr from srcImage(DP) <CGImageRef: %p>\n", a1);
    if (CGImageGetImageProvider())
    {
      v48 = IIO_CGImageWrapsIOSurface((uint64_t)a1, 0);
      if (v48)
      {
        Property = (const __CFNumber *)CGImageProviderGetProperty();
        v50 = a1;
        memset(&dest, 0, 24);
        IIONumber::IIONumber((IIONumber *)&dest, Property);
        v51 = IIONumber::uint32Num((IIONumber *)&dest);
        IIONumber::~IIONumber((IIONumber *)&dest);
      }
      else
      {
        v51 = 0;
        v50 = a1;
      }
      v104 = CGImageGetWidth(v50);
      v100 = CGImageGetHeight(a1);
      if (v48)
        v60 = "YES";
      else
        v60 = "NO";
      v61 = v51 >> 24;
      if (v51 < 0)
        v62 = __maskrune(v51 >> 24, 0x40000uLL);
      else
        v62 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v61 + 60) & 0x40000;
      if (v62)
        v63 = v61;
      else
        v63 = 46;
      v64 = v51 << 8 >> 24;
      if (v51 << 8 < 0)
        v65 = __maskrune(v51 << 8 >> 24, 0x40000uLL);
      else
        v65 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v64 + 60) & 0x40000;
      if (v65)
        v66 = v64;
      else
        v66 = 46;
      v67 = (__int16)v51 >> 8;
      if (v51 << 16 < 0)
        v68 = __maskrune((__int16)v51 >> 8, 0x40000uLL);
      else
        v68 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v67 + 60) & 0x40000;
      if (v68)
        v69 = v67;
      else
        v69 = 46;
      if ((v51 << 24) <= 0x7F000000)
        v70 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v51 + 60) & 0x40000;
      else
        v70 = __maskrune((char)v51, 0x40000uLL);
      if (v70)
        v71 = (char)v51;
      else
        v71 = 46;
      BitmapInfo = CGImageGetBitmapInfo(image);
      v73 = CGImageGetBitmapInfo(image);
      v74 = IIO_BitmapInfoStringSmall(v73);
      _cg_jpeg_mem_term("CGImageCreateByConvertingExtendedSRGBToColorspace_vImage", 238, "           srcImage (%dx%d): %s  wrapsSurf: %s   format: '%c%c%c%c'  bmi: 0x%08X - %s\n", v104, v100, "(IP)", v60, v63, v66, v69, v71, BitmapInfo, v74);
    }
    v75 = CGDataProviderCopyData(provider);
    v46 = image;
    v38 = v75;
    if (!v75 || (BytePtr = (char *)CFDataGetBytePtr(v75)) == 0)
    {
      v76 = _cg_jpeg_mem_term("CGImageCreateByConvertingExtendedSRGBToColorspace_vImage", 246, "*** ERROR: CGDataProviderCopyData failed - CGImageCreateByConvertingExtendedSRGBToColorspace_vImage returning NULL\n");
      if (v38)
        CFRelease(v38);
      (*(void (**)(IIOColorConverter *, __n128))(*(_QWORD *)v34 + 8))(v34, v76);
      v19 = 0;
      v47 = a3;
      goto LABEL_111;
    }
    _cg_jpeg_mem_term("CGImageCreateByConvertingExtendedSRGBToColorspace_vImage", 252, "           CGImageCreateByConvertingExtendedSRGBToColorspace_vImage falling back to CGDataProviderCopyData\n");
  }
  v39 = 8 * v108;
  v40 = (char *)malloc_type_calloc(v35, 8 * v108, 0x39B7D28DuLL);
  v41 = 0;
  dest.width = v108;
  dest.rowBytes = BytesPerRow;
  src.width = v108;
  src.rowBytes = 8 * v108;
  v42 = (v35 + ((v35 + 127) >> 7) - 1) / ((v35 + 127) >> 7);
  dest.data = BytePtr;
  dest.height = v42;
  v103 = 4 * v108;
  src.data = v40;
  src.height = v42;
  while (1)
  {
    v43 = v41;
    v44 = v35 - v41;
    if (v35 <= v41)
      break;
    dest.data = &BytePtr[v41 * BytesPerRow];
    src.data = &v40[v41 * v39];
    v41 += v42;
    if (v43 + v42 > v35)
    {
      dest.height = v44;
      src.height = v44;
    }
    v45 = IIOColorConverter::colorConvert(v34, &dest, &src);
    if (v45)
    {
      LogError("CGImageCreateByConvertingExtendedSRGBToColorspace_vImage", 284, "*** vImageConvert_AnyToAny failed (%d)\n", v45);
      break;
    }
  }
  (*(void (**)(IIOColorConverter *))(*(_QWORD *)v34 + 8))(v34);
  if (v38)
    CFRelease(v38);
  else
    CGDataProviderReleaseBytePtr();
  v46 = image;
  v47 = a3;
  dest.data = 0;
  dest.height = v35;
  src.data = v40;
  src.height = v35;
  dest.rowBytes = src.rowBytes;
  if (v35 > v43)
    goto LABEL_72;
  if (a3
    && IIODictionary::containsKey(a3, CFSTR("Depth"))
    && IIODictionary::getUint32ForKey(a3, CFSTR("Depth")) == 16)
  {
    src.width *= 4;
    dest.width *= 4;
    dest.data = src.data;
    if (!vImageConvert_16Fto16U(&src, &dest, 0x10u))
    {
      v52 = CGColorSpaceCreateWithName(name);
      v53 = CGDataProviderCreateWithData(0, v40, v35 * v39, (CGDataProviderReleaseDataCallback)releaseBuffer);
      v19 = CGImageCreate(v108, v35, 0x10uLL, 0x40uLL, v39, v52, v101 | 0x1000u, v53, 0, 0, kCGRenderingIntentDefault);
      CGImageSetProperty();
      CGImageSetProperty();
      CGColorSpaceRelease(v52);
      CGDataProviderRelease(v53);
      goto LABEL_111;
    }
LABEL_72:
    if (v40)
      free(v40);
    v19 = 0;
    goto LABEL_111;
  }
  dest.width = 4 * v108;
  dest.rowBytes = 8 * v108;
  src.width = 4 * v108;
  src.rowBytes = 4 * v108;
  dest.data = v40;
  dest.height = 1;
  src.data = v40;
  src.height = 1;
  if (v35)
  {
    v54 = 1;
    do
    {
      v55 = vImageConvert_Planar16FtoPlanar8(&dest, &src, 0x10u);
      dest.data = (char *)dest.data + dest.rowBytes;
      src.data = (char *)src.data + src.rowBytes;
    }
    while (v35 > v54++);
    if (v55)
      goto LABEL_72;
  }
  v57 = reallocf(v40, v35 * v103);
  v58 = CGColorSpaceCreateWithName(name);
  v59 = CGDataProviderCreateWithData(0, v57, v35 * v103, (CGDataProviderReleaseDataCallback)releaseBuffer);
  v19 = CGImageCreate(v108, v35, 8uLL, 0x20uLL, src.rowBytes, v58, v101 | 0x4000u, v59, 0, 0, kCGRenderingIntentDefault);
  CGImageSetProperty();
  CGImageSetProperty();
  CGColorSpaceRelease(v58);
  CGDataProviderRelease(v59);
LABEL_111:
  CGColorSpaceRelease(space);
  CGColorSpaceRelease(v109);
  if (v19)
  {
    v29 = 1984523623;
  }
  else
  {
    if (v47)
    {
      v77 = 8;
      if (IIODictionary::containsKey(v47, CFSTR("Depth")))
      {
        if (IIODictionary::getUint32ForKey(v47, CFSTR("Depth")) == 16)
          v77 = 16;
        else
          v77 = 8;
      }
    }
    else
    {
      v77 = 8;
    }
    v78 = CGImageGetWidth(v46);
    v79 = CGImageGetHeight(v46);
    v80 = CGImageGetAlphaInfo(v46);
    if (v77 == 16)
      v81 = v80 | 0x1000;
    else
      v81 = v80;
    v82 = CGBitmapContextCreate(0, v78, v79, v77, 4 * v78 * (v77 >> 3), a2, v81);
    if (v82)
    {
      v83 = v82;
      if (v81)
      {
        CGContextClear();
      }
      else
      {
        CGContextSetGrayFillColor(v82, 1.0, 1.0);
        v118.origin.x = 0.0;
        v118.origin.y = 0.0;
        v118.size.width = (double)v78;
        v118.size.height = (double)v79;
        CGContextFillRect(v83, v118);
      }
      v119.origin.x = 0.0;
      v119.origin.y = 0.0;
      v119.size.width = (double)v78;
      v119.size.height = (double)v79;
      CGContextDrawImage(v83, v119, v46);
      v19 = CGBitmapContextCreateImage(v83);
      CGContextRelease(v83);
    }
    else
    {
      _cg_jpeg_mem_term("CGImageCreateByConvertingExtendedSRGBToColorspace_CG", 74, "*** ERROR: CGBitmapContextCreate returned NULL\n");
      v19 = 0;
    }
    if (v19)
      v29 = 1128734752;
    else
      v29 = 1163022880;
  }
LABEL_131:
  v84 = gIIODebugFlags;
  v85 = HIBYTE(v29);
  v86 = (v29 >> 8) & 0x7F;
  if ((gIIODebugFlags & 0x20000000000) != 0)
  {
    v87 = (CFAbsoluteTimeGetCurrent() - Current) * 1000.0;
    v88 = MEMORY[0x1E0C80978] + 60;
    if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 60 + 4 * v85) & 0x40000) != 0)
      v89 = v85;
    else
      v89 = 46;
    LODWORD(v90) = HIWORD(v29) & 0x5F;
    if ((*(_DWORD *)(v88 + 4 * v90) & 0x40000) != 0)
      v90 = v90;
    else
      v90 = 46;
    if ((*(_DWORD *)(v88 + 4 * v86) & 0x40000) != 0)
      v91 = v86;
    else
      v91 = 46;
    if ((*(_DWORD *)(v88 + 4 * (v29 & 0x67)) & 0x40000) != 0)
      v92 = v29 & 0x67;
    else
      v92 = 46;
    ImageIOLog("    CGImageCreateByConvertingExtendedSRGBToColorspace - %g ms [%c%c%c%c]\n", v87, v89, v90, v91, v92);
    v84 = gIIODebugFlags;
  }
  if ((v84 & 0x8000300000) != 0)
  {
    v93 = (CFAbsoluteTimeGetCurrent() - Current) * 1000.0;
    v94 = MEMORY[0x1E0C80978] + 60;
    if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 60 + 4 * v85) & 0x40000) != 0)
      v95 = v85;
    else
      v95 = 46;
    LODWORD(v96) = HIWORD(v29) & 0x5F;
    if ((*(_DWORD *)(v94 + 4 * v96) & 0x40000) != 0)
      v96 = v96;
    else
      v96 = 46;
    if ((*(_DWORD *)(v94 + 4 * v86) & 0x40000) != 0)
      v97 = v86;
    else
      v97 = 46;
    if ((*(_DWORD *)(v94 + 4 * (v29 & 0x67)) & 0x40000) != 0)
      v98 = v29 & 0x67;
    else
      v98 = 46;
    ImageIOLog("COL %s - time: %gms [%c%c%c%c]\n", "CGImageCreateByConvertingExtendedSRGBToColorspace", v93, v95, v96, v97, v98);
  }
  return v19;
}

void sub_187FAA2C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,CGColorSpaceRef a27,CGColorSpaceRef space,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
  CGColorSpaceRelease(space);
  CGColorSpaceRelease(a27);
  _Unwind_Resume(a1);
}

CGImageRef CGImageCreateCopyWithBitmapInfo(CGImageRef image, CGColor *a2, size_t a3, unint64_t a4, CGBitmapInfo a5, BOOL a6, CGColorRenderingIntent a7)
{
  size_t BitsPerComponent;
  int AlphaInfo;
  CGColorSpaceRef ColorSpace;
  CGImageRef v17;
  unsigned int v18;
  CGImage *Mask;
  size_t NumberOfComponents;
  _QWORD *v21;
  _QWORD *v22;
  size_t v23;
  CGDataProvider *DataProvider;
  CGDataProvider *v25;
  CGDataProviderRef v26;
  CGImage *v27;
  size_t BytesPerRow;
  const CGFloat *Components;
  uint64_t v30;
  unsigned int v31;
  _BOOL4 v32;
  _BOOL4 v33;
  int v34;
  int v35;
  int v36;
  CGDataProvider *v37;
  CGDataProvider *v38;
  BOOL shouldInterpolate;
  CGColorRenderingIntent intent;
  CGBitmapInfo v42;
  size_t v43;
  CGColorSpace *space;
  size_t Height;
  size_t Width;
  CGDataProviderSequentialCallbacks callbacks;

  if ((gIIODebugFlags & 0x400000000) != 0)
    ImageIOLog("    %s\n", "CGImageCreateCopyWithBitmapInfo");
  Width = CGImageGetWidth(image);
  Height = CGImageGetHeight(image);
  BitsPerComponent = CGImageGetBitsPerComponent(image);
  AlphaInfo = _ImageGetAlphaInfo(image);
  ColorSpace = CGImageGetColorSpace(image);
  *(_OWORD *)&callbacks.version = xmmword_1E1BC2088;
  *(_OWORD *)&callbacks.skipForward = *(_OWORD *)&off_1E1BC2098;
  callbacks.releaseInfo = (CGDataProviderReleaseInfoCallback)alphaProviderReleaseInfo;
  if (_ImageIsFloat(image) != (unsigned __int16)(a5 & 0x100) >> 8 || CGImageGetDecode(image))
    return 0;
  space = ColorSpace;
  v17 = 0;
  if (BitsPerComponent > 0x20 || ((1 << BitsPerComponent) & 0x100010100) == 0)
    return v17;
  if (a4 < (Width * a3 + 7) >> 3)
    return 0;
  v42 = a5;
  v18 = a5 & 0x1F;
  if (!_ValidAlphaInfo(BitsPerComponent, a3, space, v18))
    return 0;
  intent = a7;
  Mask = (CGImage *)CGImageGetMask();
  if (CGImageGetClipPath()
    || CGImageGetMaskingColors()
    || Mask
    && (BitsPerComponent != CGImageGetBitsPerComponent(Mask)
     || Width != CGImageGetWidth(Mask)
     || Height != CGImageGetHeight(Mask)))
  {
    return 0;
  }
  if (a2 && (AlphaInfo - 1) >= 4 && AlphaInfo != 7 && v18 - 1 < 7 && ((0x4Fu >> (v18 - 1)) & 1) != 0)
    return 0;
  shouldInterpolate = a6;
  v43 = a3;
  NumberOfComponents = CGColorSpaceGetNumberOfComponents(space);
  v21 = malloc_type_calloc(0xD8uLL, 1uLL, 0xE54C7E56uLL);
  if (!v21)
    return 0;
  v22 = v21;
  v23 = a4;
  v21[1] = 0;
  DataProvider = CGImageGetDataProvider(image);
  v22[6] = CGDataProviderRetain(DataProvider);
  if (Mask)
  {
    v25 = CGImageGetDataProvider(Mask);
    v26 = CGDataProviderRetain(v25);
    v27 = Mask;
  }
  else
  {
    v26 = 0;
    v27 = image;
  }
  v22[7] = v26;
  v22[11] = Width;
  v22[12] = Height;
  v22[13] = BitsPerComponent;
  v22[14] = NumberOfComponents;
  v22[15] = CGImageGetBitsPerPixel(image);
  v22[16] = CGImageGetBytesPerRow(image);
  *((_DWORD *)v22 + 34) = AlphaInfo;
  v22[18] = _ImageGetEndianInfo(image);
  v22[19] = v43;
  v22[20] = v23;
  *((_DWORD *)v22 + 42) = v18;
  v22[22] = v42 & 0x7000;
  v22[23] = CGImageGetBitsPerPixel(v27);
  if (Mask)
    BytesPerRow = CGImageGetBytesPerRow(Mask);
  else
    BytesPerRow = 0;
  v22[24] = BytesPerRow;
  *((_DWORD *)v22 + 50) = 7;
  v22[26] = _ImageGetEndianInfo(v27);
  v22[8] = a2;
  v22[9] = 0x3FF0000000000000;
  if (a2)
  {
    Components = CGColorGetComponents(a2);
    if (Components)
      v22[9] = *(_QWORD *)Components;
  }
  v30 = v22[7];
  v31 = *((_DWORD *)v22 + 42);
  if (v31 - 5 > 0xFFFFFFFD)
  {
    v32 = 0;
    if (v30)
      goto LABEL_32;
  }
  else
  {
    v32 = (*((_DWORD *)v22 + 34) - 3) < 2;
    if (v30)
      goto LABEL_32;
  }
  if ((*((_DWORD *)v22 + 34) - 1) > 1)
  {
    v33 = 0;
    goto LABEL_33;
  }
LABEL_32:
  v33 = v31 - 3 < 2;
LABEL_33:
  if (v31 <= 6 && ((1 << v31) & 0x61) != 0)
  {
    if (v32)
      v34 = 1;
    else
      v34 = 2;
    if ((*((_DWORD *)v22 + 34) - 1) >= 2)
      v35 = 0;
    else
      v35 = 3;
  }
  else
  {
    v35 = 0;
    if (v32)
      v34 = 1;
    else
      v34 = 2;
  }
  if (v32 || v33)
    v36 = v34;
  else
    v36 = v35;
  *((_DWORD *)v22 + 20) = v36;
  v37 = CGDataProviderCreateSequential(v22, &callbacks);
  if (!v37)
  {
    alphaProviderReleaseInfo(v22);
    return 0;
  }
  v38 = v37;
  v17 = CGImageCreate(Width, Height, BitsPerComponent, v43, v23, space, v42, v37, 0, shouldInterpolate, intent);
  if (v17)
  {
    CGImageSetProperty();
    CGImageSetProperty();
    CGImageSetProperty();
  }
  CFRelease(v38);
  return v17;
}

CGImage *CGImageCreateCopyWithParameters(CGImage *a1, CGColor *a2, _OWORD *a3, unint64_t a4, unint64_t a5, unint64_t a6, size_t a7, unint64_t a8, CGColorSpaceRef space, CGBitmapInfo a10, BOOL a11, CGColorRenderingIntent a12)
{
  uint64_t v18;
  __int128 v19;
  CGImage *v20;
  CGAffineTransform v24;

  kdebug_trace();
  IIOInitDebugFlags();
  v18 = gIIODebugFlags;
  if ((unsigned __int16)gIIODebugFlags >> 14)
  {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageCreateCopyWithParameters", 0, 0, -1, 0);
    v18 = gIIODebugFlags;
  }
  if ((v18 & 0x400000000) != 0)
    ImageIOLog("    %s\n", "CGImageCreateCopyWithParameters");
  v19 = a3[1];
  *(_OWORD *)&v24.a = *a3;
  *(_OWORD *)&v24.c = v19;
  *(_OWORD *)&v24.tx = a3[2];
  v20 = CGImageCreateCopyWithParametersNew(a1, a2, &v24, a4, a5, a6, a7, a8, space, a10, a11, a12, kCGInterpolationDefault, 0);
  kdebug_trace();
  return v20;
}

CGImage *CGImageCreateThumb(CGImage *a1, unint64_t a2)
{
  CGImage *ThumbNew;

  if ((gIIODebugFlags & 0x400000000) != 0)
    ImageIOLog("    %s\n", "CGImageCreateThumb");
  kdebug_trace();
  ThumbNew = CGImageCreateThumbNew(a1, a2, 0, -1, 1);
  kdebug_trace();
  return ThumbNew;
}

CGImage *CGImageCreateThumbNew(CGImage *a1, unint64_t a2, unsigned int a3, int a4, int a5)
{
  uint64_t v9;
  _BOOL4 v10;
  const __CFString *v11;
  CGColorSpace *ColorSpace;
  CGColorSpaceModel Model;
  int Type;
  size_t Width;
  size_t Height;
  float32x2_t v17;
  int32x2_t v18;
  unint64_t v19;
  int8x16_t v20;
  int8x8_t v21;
  float32x2_t v22;
  float64x2_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  uint64x2_t v28;
  double v29;
  float64x2_t v30;
  unint64_t v36;
  unint64_t v37;
  CGFloat v38;
  double *v39;
  CGImageAlphaInfo AlphaInfo;
  const ColorSyncProfile *v41;
  CGBitmapInfo v42;
  size_t BitsPerComponent;
  uint64_t v44;
  CGColorSpace *v45;
  CGImage *v46;
  char v47;
  CGColorSpace *InputColorSpaceForOutputPoppyProfile;
  CGImageRef CopyWithColorSpace;
  CGColorSpaceRef v51;
  int v52;
  _BOOL4 IsOpaque;
  float64x2_t v55;
  CGColorRenderingIntent RenderingIntent;
  CGColorSpace *space;
  CGAffineTransform v58;
  __int128 v59;
  CGColorSpaceRef v60;
  double v61[6];
  double v62;
  uint64_t v63;
  uint64_t v64;
  double v65;
  double v66;
  uint64_t v67;
  double v68;
  uint64_t v69;
  uint64_t v70;
  double v71;
  double v72;
  double v73;
  double v74;
  uint64_t v75;
  uint64_t v76;
  double v77;
  uint64_t v78;
  double v79;
  uint64_t v80;
  double v81;
  double v82;
  uint64_t v83;
  double v84;
  double v85;
  uint64_t v86;
  double v87;
  double v88;
  uint64_t v89;
  uint64_t v90;
  double v91;
  uint64_t v92;
  double v93;
  double v94;
  __int128 v95;
  __int128 v96;
  double v97;
  double v98;
  uint64_t v99;
  double v100;
  uint64_t v101;
  uint64_t v102;

  v102 = *MEMORY[0x1E0C80C00];
  IIOInitDebugFlags();
  v9 = gIIODebugFlags;
  if ((unsigned __int16)gIIODebugFlags >> 14)
  {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageCreateThumbNew", 0, 0, -1, 0);
    v9 = gIIODebugFlags;
  }
  if ((v9 & 0x400000000) != 0)
    ImageIOLog("    %s\n", "CGImageCreateThumbNew");
  v60 = 0;
  v59 = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 8);
  v10 = a5 == 2;
  v11 = (const __CFString *)*MEMORY[0x1E0C9DA10];
  space = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
  if (!a1)
  {
    _cg_jpeg_mem_term("CGImageCreateThumbNew", 958, "*** ERROR: CGImageCreateThumbNew - input image is NULL\n");
LABEL_95:
    v46 = 0;
    goto LABEL_80;
  }
  if (!a2)
  {
    _cg_jpeg_mem_term("CGImageCreateThumbNew", 959, "*** ERROR: CGImageCreateThumbNew - maxSize is 0\n");
    goto LABEL_95;
  }
  ColorSpace = CGImageGetColorSpace(a1);
  Model = CGColorSpaceGetModel(ColorSpace);
  Type = CGColorSpaceGetType();
  RenderingIntent = CGImageGetRenderingIntent(a1);
  IsOpaque = _ImageIsOpaque(a1);
  v52 = _ImageAlphaPosition(a1);
  Width = CGImageGetWidth(a1);
  Height = CGImageGetHeight(a1);
  *(float *)v18.i32 = (float)a2;
  if (Width <= Height)
    v19 = Height;
  else
    v19 = Width;
  v17.f32[0] = *(float *)v18.i32 / (float)v19;
  v20.i64[0] = Width;
  v20.i64[1] = Height;
  v21 = (int8x8_t)vmovn_s64((int64x2_t)vcgtq_u64((uint64x2_t)vextq_s8(v20, v20, 8uLL), (uint64x2_t)v20));
  v22 = vcvt_f32_f64(vcvtq_f64_u64((uint64x2_t)v20));
  v23 = vcvtq_f64_f32((float32x2_t)vbsl_s8(v21, (int8x8_t)vrndm_f32(vmul_n_f32(v22, v17.f32[0])), (int8x8_t)vdup_lane_s32(v18, 0)));
  v24 = (int8x16_t)vdupq_n_s64(a2);
  v25 = (int8x16_t)vcvtq_u64_f64(v23);
  v26 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v24, (uint64x2_t)v25), v25, v24);
  v27 = (int8x16_t)vcgtq_u64((uint64x2_t)v26, (uint64x2_t)vdupq_n_s64(1uLL));
  v28 = (uint64x2_t)vsubq_s64((int64x2_t)vandq_s8(v26, v27), (int64x2_t)vmvnq_s8(v27));
  if (a3 - 9 > 0xFFFFFFF7)
  {
    v61[0] = v17.f32[0];
    if (a3 <= 4)
      v36 = v28.i64[0];
    else
      v36 = v28.u64[1];
    if (a3 <= 4)
      v37 = v28.u64[1];
    else
      v37 = v28.i64[0];
    v61[1] = 0.0;
    v61[2] = 0.0;
    v61[3] = v17.f32[0];
    v61[4] = 0.0;
    v61[5] = 0.0;
    v62 = (float)-v17.f32[0];
    v63 = 0;
    v64 = 0;
    v65 = v17.f32[0];
    v66 = (double)v36;
    v67 = 0;
    v68 = v62;
    v69 = 0;
    v70 = 0;
    v71 = v62;
    v72 = (double)v36;
    v73 = (double)v37;
    v74 = v17.f32[0];
    v75 = 0;
    v76 = 0;
    v77 = v62;
    v78 = 0;
    v79 = (double)v37;
    v80 = 0;
    v81 = v62;
    v82 = v62;
    v83 = 0;
    v84 = (double)v36;
    v85 = (double)v37;
    v86 = 0;
    v87 = v62;
    v88 = v17.f32[0];
    v89 = 0;
    v90 = 0;
    v91 = (double)v37;
    v92 = 0;
    v93 = v17.f32[0];
    v94 = v17.f32[0];
    v96 = 0u;
    v95 = 0u;
    v97 = v17.f32[0];
    v98 = v62;
    v99 = 0;
    v100 = (double)v36;
    v101 = 0;
    v39 = &v61[6 * a3 - 6];
    v29 = *v39;
    v59 = *(_OWORD *)(v39 + 1);
    v38 = v39[3];
    v55 = *(float64x2_t *)(v39 + 4);
  }
  else
  {
    v29 = v17.f32[0];
    v30 = vcvtq_f64_f32(vmls_lane_f32(vcvt_f32_f64(vcvtq_f64_u64(v28)), v22, v17, 0));
    __asm { FMOV            V1.2D, #0.5 }
    v55 = vmulq_f64(v30, _Q1);
    v37 = v28.u64[1];
    v36 = v28.i64[0];
    v38 = v29;
  }
  if (a5 == 1)
  {
    v60 = CGColorSpaceRetain(space);
    AlphaInfo = CGImageGetAlphaInfo(a1);
    v41 = 0;
    if (AlphaInfo)
      v42 = AlphaInfo;
    else
      v42 = 5;
    goto LABEL_23;
  }
  if (Model == kCGColorSpaceModelCMYK)
  {
    if (a5 != 2)
    {
      LOBYTE(v10) = 0;
      v41 = 0;
      v42 = 0;
      v60 = CGColorSpaceRetain(ColorSpace);
LABEL_23:
      BitsPerComponent = 8;
      v44 = 4;
      goto LABEL_66;
    }
    v60 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D968]);
    if ((gIIODebugFlags & 0x8000300000) != 0)
      ImageIOLog("COL converting to GenericCMYK\n");
    v41 = 0;
    v42 = 0;
    v44 = 4;
    goto LABEL_58;
  }
  if (Model == kCGColorSpaceModelMonochrome)
  {
    v42 = !IsOpaque;
    if (IsOpaque)
      v44 = 1;
    else
      v44 = 2;
    if (a5 == 2)
    {
      v60 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D978]);
      if ((gIIODebugFlags & 0x8000300000) != 0)
        ImageIOLog("COL converting to GenericGrayGamma2.2\n");
      v41 = 0;
      goto LABEL_58;
    }
    LOBYTE(v10) = 0;
    v41 = 0;
    v60 = CGColorSpaceRetain(ColorSpace);
LABEL_65:
    BitsPerComponent = 8;
    goto LABEL_66;
  }
  if (Model != kCGColorSpaceModelRGB || Type == 7)
  {
    v45 = CGColorSpaceRetain(ColorSpace);
    v41 = 0;
LABEL_47:
    v60 = v45;
    goto LABEL_48;
  }
  if (a5 != 2)
  {
    v45 = CGColorSpaceRetain(ColorSpace);
    v41 = 0;
    v10 = 0;
    goto LABEL_47;
  }
  if (IIO_CGColorSpaceNameMatchesName(ColorSpace, v11))
  {
    v60 = CGColorSpaceRetain(space);
    if ((gIIODebugFlags & 0x8000300000) != 0)
      ImageIOLog("COL original image is sRGB - not converting\n");
LABEL_86:
    v41 = 0;
    v10 = 0;
    goto LABEL_48;
  }
  if (CGImageIsOptimizedForSharing())
  {
    v51 = CGImageGetColorSpace(a1);
    v60 = (CGColorSpaceRef)CFRetain(v51);
    if ((gIIODebugFlags & 0x8000300000) != 0)
      ImageIOLog("COL original image is already poppy - not converting\n");
    goto LABEL_86;
  }
  if ((gIIODebugFlags & 0x8000300000) != 0)
    ImageIOLog("COL image is outside sRGB - trying to use poppy profile\n");
  v41 = IIO_CreateOutputPoppyProfileForImage(0, a1, &v60);
  if (!v60)
  {
    v60 = CGColorSpaceRetain(space);
    if ((gIIODebugFlags & 0x8000300000) != 0)
      ImageIOLog("COL failed to create poppy profile - falling back to sRGB\n");
  }
  v10 = 1;
LABEL_48:
  if (v52 == -1)
  {
    if (IsOpaque)
      v42 = 6;
    else
      v42 = 2;
    v44 = 4;
    if (!v10)
    {
      LOBYTE(v10) = 0;
      goto LABEL_65;
    }
  }
  else
  {
    if (IsOpaque)
      v42 = 5;
    else
      v42 = 1;
    v44 = 4;
    if (!v10)
      goto LABEL_65;
  }
LABEL_58:
  if (a4 == -1)
  {
    if (CGImageGetBitsPerComponent(a1) > 0xF)
    {
      LOBYTE(v10) = 1;
      BitsPerComponent = 16;
      goto LABEL_66;
    }
    BitsPerComponent = CGImageGetBitsPerComponent(a1);
  }
  else
  {
    BitsPerComponent = a4;
  }
  LOBYTE(v10) = 1;
LABEL_66:
  v58.a = v29;
  *(_OWORD *)&v58.b = v59;
  v58.d = v38;
  *(float64x2_t *)&v58.tx = v55;
  v46 = CGImageCreateCopyWithParametersNew(a1, 0, &v58, v36, v37, BitsPerComponent, BitsPerComponent * v44, v44 * v36 * (BitsPerComponent >> 3), v60, v42, 1, RenderingIntent, kCGInterpolationDefault, v10);
  v47 = !v10;
  if (!v46)
    v47 = 1;
  if ((v47 & 1) == 0 && v41)
  {
    InputColorSpaceForOutputPoppyProfile = (CGColorSpace *)IIO_CreateInputColorSpaceForOutputPoppyProfile();
    if (InputColorSpaceForOutputPoppyProfile)
    {
      if ((gIIODebugFlags & 0x8000300000) != 0)
        ImageIOLog("COL created  profile 'Apple Wide Color Sharing Profile'\n");
      CopyWithColorSpace = CGImageCreateCopyWithColorSpace(v46, InputColorSpaceForOutputPoppyProfile);
      if (CopyWithColorSpace)
        CGImageRelease(v46);
      else
        CopyWithColorSpace = v46;
      CGColorSpaceRelease(InputColorSpaceForOutputPoppyProfile);
      v46 = CopyWithColorSpace;
    }
    goto LABEL_79;
  }
  if (v41)
LABEL_79:
    CFRelease(v41);
LABEL_80:
  if (v60)
    CGColorSpaceRelease(v60);
  CGColorSpaceRelease(space);
  return v46;
}

void sub_187FAB170(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, CGColorSpaceRef space)
{
  CGColorSpaceRelease(space);
  _Unwind_Resume(a1);
}

CGImage *CGImageCreateByScaling(CGImageRef image, unint64_t a2, size_t a3, CGInterpolationQuality a4)
{
  CGColorSpace *ColorSpace;
  uint64_t v8;
  CFTypeID v9;
  CGColorSpace *v10;
  CGColorSpace *BaseColorSpace;
  CGColorSpaceModel Model;
  int BytesPerRow;
  CGImageAlphaInfo AlphaInfo;
  uint64_t ImageProvider;
  int v16;
  int v17;
  unsigned int NumberOfComponents;
  uint64_t v19;
  unsigned int v20;
  IIOSubsampler *v21;
  char *v22;
  uint64_t v23;
  const char *v24;
  IIODictionary *v25;
  int PixelSize;
  int v27;
  IIOSubsampler *v28;
  unsigned int v29;
  unsigned __int8 *Data;
  int v31;
  CGDataProviderRef DataProvider;
  CGDataProviderRef v33;
  unsigned int v34;
  unsigned int v35;
  int v36;
  IIOSubsampler *v37;
  uint64_t v38;
  CGColorSpace *v39;
  uint64_t v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  IIOSubsampler *v47;
  double v48;
  double v49;
  double v50;
  int v51;
  int v52;
  CGBitmapInfo v53;
  unsigned int v54;
  unsigned int v55;
  unint64_t v56;
  unsigned int MinimalPixelSize;
  unint64_t v58;
  size_t v59;
  CGColorRenderingIntent RenderingIntent;
  CGImage *v61;
  CGColorSpace *v62;
  size_t v64;
  unsigned __int8 *v65;
  unsigned __int8 *v66;
  unsigned __int8 *v67;
  CGDataProvider *v68;
  CGFloat *decode;
  unsigned int bitsPerPixel;
  unsigned int bitsPerComponent;
  CGDataProviderRef v72;
  IIOSubsampler *v73;
  unsigned int v74;
  CGBitmapInfo BitmapInfo;
  unint64_t v76;
  unsigned int Height;
  unsigned int Width;
  size_t count;
  CGAffineTransform v81;
  unsigned int v82[4];
  uint64_t v83;

  if (image)
  {
    CGImageGetBitsPerPixel(image);
    CGImageGetBitsPerComponent(image);
    ColorSpace = CGImageGetColorSpace(image);
    CGColorSpaceGetModel(ColorSpace);
    CGImageGetImageProvider();
    CGImageGetContentHeadroom();
    CGImageGetBitmapInfo(image);
    CGImageGetWidth(image);
    CGImageGetHeight(image);
  }
  kdebug_trace();
  IIOInitDebugFlags();
  v8 = gIIODebugFlags;
  if ((unsigned __int16)gIIODebugFlags >> 14)
  {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageCreateByScaling", 0, 0, -1, 0);
    v8 = gIIODebugFlags;
  }
  if ((v8 & 0x400000000) != 0)
    ImageIOLog("    %s\n", "CGImageCreateByScaling");
  if (!image)
  {
    LogError("CGImageCreateByScaling", 1238, "*** ERROR: image is NULL\n", decode);
LABEL_89:
    v61 = 0;
    goto LABEL_68;
  }
  v9 = CFGetTypeID(image);
  if (v9 != CGImageGetTypeID())
  {
    LogError("CGImageCreateByScaling", 1239, "*** ERROR: image is not a CGImageRef\n");
    goto LABEL_89;
  }
  if (!a2 || !a3)
  {
    _cg_jpeg_mem_term("CGImageCreateByScaling", 1240, "*** ERROR: bad image size: %ld x %ld\n", a2, a3);
    goto LABEL_89;
  }
  v10 = CGImageGetColorSpace(image);
  if (!v10)
  {
    LogError("CGImageCreateByScaling", 1244, "*** ERROR: cannot get the colorSpace of the input image (%p)\n");
    goto LABEL_89;
  }
  BaseColorSpace = v10;
  v76 = a2;
  count = a3;
  Model = CGColorSpaceGetModel(v10);
  Width = CGImageGetWidth(image);
  Height = CGImageGetHeight(image);
  BytesPerRow = CGImageGetBytesPerRow(image);
  BitmapInfo = CGImageGetBitmapInfo(image);
  AlphaInfo = CGImageGetAlphaInfo(image);
  ImageProvider = CGImageGetImageProvider();
  v16 = CGImageGetBitsPerComponent(image);
  v17 = CGImageGetBitsPerPixel(image);
  NumberOfComponents = CGColorSpaceGetNumberOfComponents(BaseColorSpace);
  v19 = 0;
  if (AlphaInfo)
    v20 = NumberOfComponents + 1;
  else
    v20 = NumberOfComponents;
  v21 = 0;
  if (a4 == kCGInterpolationNone || Model > kCGColorSpaceModelRGB)
    goto LABEL_30;
  v74 = v20;
  v22 = (char *)gCrashMessage;
  v23 = CGImageGetImageProvider();
  v24 = "IP";
  if (!v23)
    v24 = "DP";
  snprintf(v22, 0x200uLL, "ImageIO: CGImageCreateByScaling: srcImage-(%s): w=%d  h=%d  rb=%d  bmi=0x%08x  bpc=%d  bpp=%d  csm=%d    dstW=%d  dstH=%d\n", v24, Width, Height, BytesPerRow, BitmapInfo, v16, v17, Model, v76, count);
  qword_1ECDD8318 = gCrashMessage;
  if (!ImageProvider)
  {
    DataProvider = CGImageGetDataProvider(image);
    if (DataProvider)
    {
      v33 = DataProvider;
      v34 = CGImageGetBitsPerPixel(image);
      v35 = CGImageGetBitsPerComponent(image);
      v36 = CGImageGetBytesPerRow(image);
      v29 = ((v34 >> 3) * v76 + 7) & 0xFFFFFFF8;
      v37 = (IIOSubsampler *)operator new();
      bitsPerComponent = v35;
      IIOSubsampler::IIOSubsampler(v37, Width, v36, BitmapInfo, v35, v74, 0, 0, v76, v29);
      v38 = CGDataProviderRetainBytePtr();
      v72 = v33;
      v73 = v37;
      bitsPerPixel = v34;
      if (v38)
      {
        Data = (unsigned __int8 *)v38;
        v31 = 0;
        v19 = 0;
      }
      else
      {
        v64 = v36 * Height;
        v65 = (unsigned __int8 *)malloc_type_malloc(v64, 0x1F5E057DuLL);
        Data = v65;
        if (CGAccessSessionCreate())
        {
          CGAccessSessionGetBytes();
          CGAccessSessionRelease();
        }
        else
        {
          memset(v65, 85, v64);
        }
        v19 = 0;
        v31 = 1;
      }
      goto LABEL_73;
    }
    v19 = 0;
LABEL_29:
    v21 = 0;
    qword_1ECDD8318 = 0;
LABEL_30:
    *(_OWORD *)v82 = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 8);
    if (CGColorSpaceGetType() == 7)
    {
      BaseColorSpace = CGColorSpaceGetBaseColorSpace(BaseColorSpace);
      CFRetain(BaseColorSpace);
      v39 = BaseColorSpace;
    }
    else
    {
      v39 = 0;
    }
    v40 = v19;
    v41 = (float)Width;
    v42 = (float)v76 / (float)Width;
    v43 = (float)Height;
    v44 = (float)count / (float)Height;
    if (v42 >= v44)
      v45 = (float)v76 / (float)Width;
    else
      v45 = (float)count / (float)Height;
    if ((float)(v45 * v43) > (float)(count + 1) || (float)(v45 * v41) > (float)(v76 + 1))
    {
      if (v42 <= v44)
        v45 = (float)v76 / (float)Width;
      else
        v45 = (float)count / (float)Height;
    }
    v47 = v21;
    v48 = v45;
    v49 = (float)((float)v76 - (float)(v45 * v41)) * 0.5;
    v50 = (float)((float)count - (float)(v45 * v43)) * 0.5;
    v51 = _ImageGetAlphaInfo(image);
    if (!v51)
    {
      if (CGColorSpaceGetModel(BaseColorSpace) == kCGColorSpaceModelRGB)
        v51 = 5;
      else
        v51 = 0;
    }
    if (v51 == 4)
      v52 = 2;
    else
      v52 = v51;
    if (v51 == 3)
      v53 = 1;
    else
      v53 = v52;
    v54 = CGImageGetBitsPerComponent(image);
    if (v54 <= 0x10)
      v55 = 16;
    else
      v55 = v54;
    if (v54 <= 8)
      v56 = 8;
    else
      v56 = v55;
    MinimalPixelSize = _GetMinimalPixelSize(BaseColorSpace, v56, v53);
    v81.a = v48;
    v58 = (MinimalPixelSize * v76 + 7) >> 3;
    *(_OWORD *)&v81.b = *(_OWORD *)v82;
    v81.d = v48;
    v81.tx = v49;
    v81.ty = v50;
    v59 = MinimalPixelSize;
    RenderingIntent = CGImageGetRenderingIntent(image);
    v61 = CGImageCreateCopyWithParametersNew(image, 0, &v81, v76, count, v56, v59, v58, BaseColorSpace, v53, 1, RenderingIntent, a4, 0);
    v21 = v47;
    v19 = v40;
    goto LABEL_60;
  }
  memset(v82, 0, sizeof(v82));
  v83 = 0;
  IIODictionary::IIODictionary((IIODictionary *)v82);
  IIODictionary::setObjectForKey(v25, (const void *)*MEMORY[0x1E0C9AE50], (const __CFString *)*MEMORY[0x1E0C9DAC0]);
  v19 = CGImageProviderCopyImageBlockSetWithOptions();
  if (!v19 || CGImageBlockSetGetCount() != 1 || !CGImageBlockSetGetImageBlock())
  {
    IIODictionary::~IIODictionary((IIODictionary *)v82);
    goto LABEL_29;
  }
  PixelSize = CGImageBlockSetGetPixelSize();
  v27 = CGImageBlockGetBytesPerRow();
  v28 = (IIOSubsampler *)operator new();
  v29 = ((PixelSize & 0x1FFFFFFF) * v76 + 7) & 0xFFFFFFF8;
  bitsPerPixel = 8 * PixelSize;
  bitsPerComponent = 8 * PixelSize / v74;
  IIOSubsampler::IIOSubsampler(v28, Width, v27, BitmapInfo, bitsPerComponent, v74, 0, 0, v76, v29);
  Data = (unsigned __int8 *)CGImageBlockGetData();
  v73 = v28;
  IIODictionary::~IIODictionary((IIODictionary *)v82);
  v72 = 0;
  v31 = 0;
LABEL_73:
  v66 = (unsigned __int8 *)malloc_type_calloc(count, v29, 0xFF5E74B7uLL);
  if (v66 && (v67 = v66, v82[0] = count, IIOSubsampler::subsample(v73, Data, Height, v66, v82)))
  {
    v68 = CGDataProviderCreateWithData(0, v67, v29 * count, (CGDataProviderReleaseDataCallback)releaseBuffer);
    v61 = CGImageCreate(v76, count, bitsPerComponent, bitsPerPixel, v29, BaseColorSpace, BitmapInfo, v68, 0, 1, kCGRenderingIntentDefault);
    CGDataProviderRelease(v68);
  }
  else
  {
    v61 = 0;
  }
  if (ImageProvider || !v72)
  {
    if (!v31)
      goto LABEL_83;
    goto LABEL_82;
  }
  CGDataProviderReleaseBytePtr();
  if ((v31 & 1) != 0)
LABEL_82:
    free(Data);
LABEL_83:
  v39 = 0;
  qword_1ECDD8318 = 0;
  v21 = v73;
  if (!v61)
    goto LABEL_30;
LABEL_60:
  if (v19)
    CGImageBlockSetRelease();
  if (v21)
    (*(void (**)(IIOSubsampler *))(*(_QWORD *)v21 + 8))(v21);
  if (v39)
    CGColorSpaceRelease(v39);
  if (v61)
  {
    CGImageGetBitsPerPixel(v61);
    CGImageGetBitsPerComponent(v61);
    v62 = CGImageGetColorSpace(v61);
    CGColorSpaceGetModel(v62);
    CGImageGetImageProvider();
    CGImageGetContentHeadroom();
    CGImageGetBitmapInfo(v61);
  }
LABEL_68:
  kdebug_trace();
  return v61;
}

void sub_187FABA94(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v3 = v1;
  MEMORY[0x18D761C30](v3, 0x1081C4078C9819ALL);
  IIODictionary::~IIODictionary((IIODictionary *)(v2 - 144));
  _Unwind_Resume(a1);
}

void releaseBuffer(void *a1, void *a2)
{
  free(a2);
}

CGImage *CGImageCreateByMatchingToColorSpace(CGImage *a1, CGColorSpace *a2)
{
  uint64_t v4;
  CGImage *v5;
  BOOL v6;
  _BOOL4 v7;
  size_t BitsPerComponent;
  size_t Width;
  size_t Height;
  int AlphaInfo;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  BOOL v17;
  CGBitmapInfo v18;
  unint64_t v19;
  size_t MinimalPixelSize;
  CGColorRenderingIntent RenderingIntent;
  CGAffineTransform v23;

  kdebug_trace();
  IIOInitDebugFlags();
  v4 = gIIODebugFlags;
  if ((unsigned __int16)gIIODebugFlags >> 14)
  {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageCreateByMatchingToColorSpace", 0, 0, -1, 0);
    v4 = gIIODebugFlags;
  }
  if ((v4 & 0x400000000) != 0)
    ImageIOLog("    %s\n", "CGImageCreateByMatchingToColorSpace");
  v5 = 0;
  if (a1 && a2)
  {
    v6 = IIO_CGColorSpaceNameMatchesName(a2, (const __CFString *)*MEMORY[0x1E0C9DA10]);
    if (v6)
    {
      v7 = 0;
      BitsPerComponent = 8;
    }
    else
    {
      v7 = CGColorSpaceUsesExtendedRange(a2);
      BitsPerComponent = 0;
    }
    Width = CGImageGetWidth(a1);
    Height = CGImageGetHeight(a1);
    AlphaInfo = _ImageGetAlphaInfo(a1);
    if (!AlphaInfo)
    {
      if (CGColorSpaceGetModel(a2) == kCGColorSpaceModelRGB)
        AlphaInfo = 5;
      else
        AlphaInfo = 0;
    }
    if (AlphaInfo == 3)
      v12 = 1;
    else
      v12 = AlphaInfo;
    if (v12 == 4)
      v13 = 2;
    else
      v13 = v12;
    if (v13 == 6)
    {
      if (CGColorSpaceGetModel(a2))
        v13 = 6;
      else
        v13 = 0;
    }
    if (!v6)
      BitsPerComponent = CGImageGetBitsPerComponent(a1);
    v14 = 16;
    if (BitsPerComponent > 0x10)
      v14 = BitsPerComponent;
    if (BitsPerComponent <= 8)
      v14 = 8;
    v15 = v13 | 0x2100;
    if (BitsPerComponent > 0x1F)
    {
      v16 = BitsPerComponent;
    }
    else
    {
      v15 = v13 | 0x1100;
      v16 = 16;
    }
    v17 = !v7;
    if (v7)
      v18 = v15;
    else
      v18 = v13;
    if (v17)
      v19 = v14;
    else
      v19 = v16;
    MinimalPixelSize = _GetMinimalPixelSize(a2, v19, v18);
    v23.a = 1.0;
    v23.b = 0.0;
    v23.c = 0.0;
    v23.d = 1.0;
    v23.tx = 0.0;
    v23.ty = 0.0;
    RenderingIntent = CGImageGetRenderingIntent(a1);
    v5 = CGImageCreateCopyWithParametersNew(a1, 0, &v23, Width, Height, v19, MinimalPixelSize, (MinimalPixelSize * Width + 7) >> 3, a2, v18, 1, RenderingIntent, kCGInterpolationDefault, 1);
  }
  kdebug_trace();
  return v5;
}

unint64_t alphaProviderGetBytes(_DWORD *a1, _WORD *a2, unint64_t a3)
{
  unint64_t v3;
  unint64_t v5;
  _BOOL4 v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  _BOOL4 v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  unint64_t v21;
  _BOOL4 v22;
  unint64_t v23;
  unint64_t v24;
  void *v25;
  _BOOL4 v26;
  unint64_t v27;
  unint64_t v28;
  void *v29;
  unint64_t v30;
  unint64_t v31;
  unsigned int v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  _WORD *v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  _WORD *v41;
  size_t v42;
  unsigned int *v43;
  size_t v44;
  uint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  uint64_t v52;
  float *v53;
  unint64_t v54;
  unint64_t v55;
  int v56;
  double v57;
  int v58;
  uint64_t v59;
  _WORD *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t v70;
  int v71;
  uint64_t v72;
  _WORD *v73;
  float v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  float v79;
  float v80;
  uint64_t v81;
  uint64_t v82;
  int v83;
  uint64_t v84;
  _WORD *v85;
  unsigned int v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  unsigned int v91;
  unsigned int v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  BOOL v96;
  char v97;
  _WORD *v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  _WORD *v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  unsigned int v109;
  unsigned int v110;
  unsigned int v111;
  uint64_t v112;
  uint64_t v113;
  unsigned int v114;
  unsigned int v115;
  int v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  _WORD *v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  int v127;
  unint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  int v132;
  unint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  _WORD *v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  _WORD *v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  _WORD *v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  _WORD *v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  _WORD *v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  _WORD *v157;
  uint64_t v158;
  uint64_t v159;
  unint64_t v160;
  unint64_t v161;
  _WORD *v162;
  unint64_t v163;
  unsigned int *v164;
  char v166;
  unsigned int v167;
  unint64_t v168;
  unsigned int v169;
  uint64_t v170;
  unsigned int v171;
  unsigned int v172;
  size_t v173;
  size_t count;
  unint64_t v175;
  uint64_t v177;
  unint64_t v178;
  unint64_t v179;
  uint64_t v180;
  _WORD *v182;
  uint64_t v183;
  int v184;
  unint64_t v185;

  v3 = 0;
  if (a1 && a2 && a3)
  {
    LODWORD(v5) = a1[34];
    v6 = v5 < 7;
    v7 = a1[42];
    if (v7 - 2 > 4)
      v8 = 0;
    else
      v8 = qword_1882102E0[v7 - 2];
    v9 = 0;
    v10 = *((_QWORD *)a1 + 14);
    if ((_DWORD)v5 != 2 && (_DWORD)v5 != 4)
    {
      if ((_DWORD)v5 == 6)
        v9 = 0;
      else
        v9 = (char)v10;
    }
    v11 = 0;
    if (v7 != 2 && v7 != 4)
    {
      if (v7 == 6)
        v11 = 0;
      else
        v11 = (char)v10;
    }
    v12 = *((_QWORD *)a1 + 13);
    v13 = *((_QWORD *)a1 + 7);
    v170 = *((_QWORD *)a1 + 14);
    v183 = v11;
    count = *((_QWORD *)a1 + 16);
    v180 = v13;
    if ((v5 - 1) > 6)
      v172 = v13 != 0;
    else
      v172 = (0x4Fu >> (v5 - 1)) | (v13 != 0);
    v173 = *((_QWORD *)a1 + 24);
    v14 = *((_QWORD *)a1 + 15);
    v15 = *((_QWORD *)a1 + 19);
    v175 = *((_QWORD *)a1 + 20);
    v16 = v7 < 8;
    v17 = *((_QWORD *)a1 + 18);
    v18 = 2 * (v17 == 4096);
    if (v17 == 0x2000)
      v18 = 4;
    if (v12 == 16)
      v18 ^= 2u;
    if (v12 == 32)
      v18 ^= 4u;
    v171 = v18;
    if (v12 == 32)
      v19 = 4;
    else
      v19 = 2 * (v12 == 16);
    v20 = *((_QWORD *)a1 + 22);
    v21 = *((_QWORD *)a1 + 23);
    if (v20 == 4096)
      v19 ^= 2u;
    if (v20 == 0x2000)
      v19 ^= 4u;
    v169 = v19;
    if (!*((_QWORD *)a1 + 2))
    {
      v22 = v5 < 7;
      v23 = *((_QWORD *)a1 + 15);
      v184 = a1[34];
      v5 = *((_QWORD *)a1 + 13);
      v24 = *((_QWORD *)a1 + 23);
      v25 = malloc_type_calloc(count, 1uLL, 0xD9D33B85uLL);
      v21 = v24;
      v12 = v5;
      LOBYTE(v5) = v184;
      v14 = v23;
      v16 = v7 < 8;
      v6 = v22;
      *((_QWORD *)a1 + 2) = v25;
    }
    v179 = v15 >> 3;
    if (v180 && !*((_QWORD *)a1 + 3))
    {
      v26 = v6;
      v27 = v14;
      v28 = v21;
      v29 = malloc_type_calloc(v173, 1uLL, 0x64CE0F68uLL);
      v21 = v28;
      v14 = v27;
      v6 = v26;
      *((_QWORD *)a1 + 3) = v29;
    }
    v30 = a3;
    v31 = a3 / v179 * v179;
    if (a3 == a3 % v179)
    {
      return 0;
    }
    else
    {
      v3 = 0;
      v32 = 0x54u >> v5;
      v33 = v12 >> 3;
      v185 = v21 >> 3;
      v178 = v14 >> 3;
      if ((v6 & v32) != 0)
        v34 = v12 >> 3;
      else
        v34 = 0;
      v168 = v34;
      v166 = v16 & (0x9Eu >> v7);
      v167 = v172 & v16 & (0x9Eu >> v7);
      v35 = *(_QWORD *)a1;
      v36 = a2;
      v37 = v175;
      do
      {
        v38 = v35 / v37;
        if (v35 / v37 > *((_QWORD *)a1 + 12))
          break;
        v182 = v36;
        if (!*((_QWORD *)a1 + 4))
          *((_QWORD *)a1 + 4) = CGAccessSessionCreate();
        if (v180 && !*((_QWORD *)a1 + 5))
          *((_QWORD *)a1 + 5) = CGAccessSessionCreate();
        v39 = *((_QWORD *)a1 + 1);
        if (v38 + 1 < v39)
        {
          CGAccessSessionRewind();
          if (*((_QWORD *)a1 + 5))
            CGAccessSessionRewind();
          *((_QWORD *)a1 + 1) = 0;
LABEL_55:
          while (count == CGAccessSessionGetBytes() && (!v180 || v173 == CGAccessSessionGetBytes()))
          {
            v40 = *((_QWORD *)a1 + 1) + 1;
            *((_QWORD *)a1 + 1) = v40;
            if (v40 > v38)
            {
              if ((v171 & 2) != 0 && count >= 2)
              {
                v41 = (_WORD *)*((_QWORD *)a1 + 2);
                if (v41)
                {
                  v42 = count >> 1;
                  do
                  {
                    *v41 = bswap32((unsigned __int16)*v41) >> 16;
                    ++v41;
                    --v42;
                  }
                  while (v42);
                }
              }
              if (v171 >= 4 && count >= 4)
              {
                v43 = (unsigned int *)*((_QWORD *)a1 + 2);
                if (v43)
                {
                  v44 = count >> 2;
                  do
                  {
                    *v43 = bswap32(*v43);
                    ++v43;
                    --v44;
                  }
                  while (v44);
                }
              }
              goto LABEL_69;
            }
          }
          return v3;
        }
        if (v39 <= v38)
          goto LABEL_55;
LABEL_69:
        v45 = *(_QWORD *)a1;
        v37 = v175;
        v46 = *(_QWORD *)a1 % v175;
        v47 = v175 - v46;
        if (v30 < v175 - v46)
          v47 = v30;
        v48 = v46 % v179;
        if (v46 % v179)
        {
          v47 -= v48;
          *(_QWORD *)a1 = v48 + v45;
          v182 = (_WORD *)((char *)v182 + v48);
          v3 += v48;
          v30 -= v48;
          v46 = (v48 + v45) % v175;
        }
        v49 = v46 / v179;
        v50 = v47 / v179 + v49;
        if (v50 >= *((_QWORD *)a1 + 11))
          v51 = *((_QWORD *)a1 + 11);
        else
          v51 = v50;
        v52 = *((_QWORD *)a1 + 2) + v49 * v178;
        if (v180)
          v53 = (float *)(*((_QWORD *)a1 + 3) + v49 * v185);
        else
          v53 = (float *)(v52 + v9 * v33);
        v54 = v51 - v49;
        v55 = v52 + v168;
        v177 = v51;
        switch(v33)
        {
          case 4uLL:
            v71 = a1[20];
            if (v167)
            {
              if (v51 != v49)
              {
                v72 = 0;
                v73 = v182;
                do
                {
                  v74 = *v53;
                  if (v71 == 1)
                  {
                    if (v170)
                    {
                      v75 = 0;
                      v76 = v170;
                      do
                      {
                        *(float *)&v73[2 * v75 + 2 * v8] = v74 * *(float *)(v55 + 4 * v75);
                        ++v75;
                        --v76;
                      }
                      while (v76);
                    }
                  }
                  else if (v71 == 2)
                  {
                    if (v170)
                    {
                      v77 = 0;
                      v78 = v170;
                      do
                      {
                        v79 = *(float *)(v55 + 4 * v77);
                        if (v74 <= v79)
                          v80 = 1.0;
                        else
                          v80 = v79 / v74;
                        *(float *)&v73[2 * v77++ + 2 * v8] = v80;
                        --v78;
                      }
                      while (v78);
                    }
                  }
                  else if (v170)
                  {
                    v81 = 0;
                    v82 = v170;
                    do
                    {
                      *(_DWORD *)&v73[2 * v81 + 2 * v8] = *(_DWORD *)(v55 + 4 * v81);
                      ++v81;
                      --v82;
                    }
                    while (v82);
                  }
                  *(float *)&v73[2 * v183] = v74;
                  v55 += v178;
                  v53 = (float *)((char *)v53 + v185);
                  v73 = (_WORD *)((char *)v73 + v179);
                  ++v72;
                }
                while (v72 != v54);
              }
            }
            else if ((v172 & 1) != 0)
            {
              if (v51 != v49)
              {
                v95 = 0;
                if (v170)
                  v96 = (v71 & 0xFFFFFFFE) == 2;
                else
                  v96 = 1;
                v97 = v96;
                v98 = v182;
                do
                {
                  if (v71 == 1)
                  {
                    if (v170)
                    {
                      v99 = 0;
                      v100 = v170;
                      do
                      {
                        *(float *)&v98[2 * v99 + 2 * v8] = *(float *)(v55 + 4 * v99) * *v53;
                        ++v99;
                        --v100;
                      }
                      while (v100);
                    }
                  }
                  else if ((v97 & 1) == 0)
                  {
                    v101 = 0;
                    v102 = v170;
                    do
                    {
                      *(_DWORD *)&v98[2 * v101 + 2 * v8] = *(_DWORD *)(v55 + 4 * v101);
                      ++v101;
                      --v102;
                    }
                    while (v102);
                  }
                  v55 += v178;
                  v53 = (float *)((char *)v53 + v185);
                  v98 = (_WORD *)((char *)v98 + v179);
                  ++v95;
                }
                while (v95 != v54);
              }
            }
            else if ((v166 & 1) != 0)
            {
              if (v51 != v49)
              {
                v136 = 0;
                v137 = v182;
                do
                {
                  if (v170)
                  {
                    v138 = 0;
                    v139 = v170;
                    do
                    {
                      *(_DWORD *)&v137[2 * v138 + 2 * v8] = *(_DWORD *)(v55 + 4 * v138);
                      ++v138;
                      --v139;
                    }
                    while (v139);
                  }
                  *(_DWORD *)&v137[2 * v183] = 1065353216;
                  v55 += v178;
                  v137 = (_WORD *)((char *)v137 + v179);
                  ++v136;
                }
                while (v136 != v54);
              }
            }
            else if (v51 != v49)
            {
              v148 = 0;
              v149 = v182;
              do
              {
                if (v170)
                {
                  v150 = 0;
                  v151 = v170;
                  do
                  {
                    *(_DWORD *)&v149[2 * v150 + 2 * v8] = *(_DWORD *)(v55 + 4 * v150);
                    ++v150;
                    --v151;
                  }
                  while (v151);
                }
                v55 += v178;
                v149 = (_WORD *)((char *)v149 + v179);
                ++v148;
              }
              while (v148 != v54);
            }
            break;
          case 2uLL:
            v83 = a1[20];
            if (v167)
            {
              if (v51 != v49)
              {
                v84 = 0;
                v85 = v182;
                do
                {
                  v86 = *(unsigned __int16 *)v53;
                  if (v83 == 1)
                  {
                    if (v170)
                    {
                      v87 = 0;
                      v88 = v170;
                      do
                      {
                        v85[v87 + v8] = (0xFFFF * (v86 ^ 0xFFFF) + *(unsigned __int16 *)(v55 + 2 * v87) * v86) / 0xFFFF;
                        ++v87;
                        --v88;
                      }
                      while (v88);
                    }
                  }
                  else if (v83 == 2)
                  {
                    if (v170)
                    {
                      v89 = 0;
                      v90 = v170;
                      do
                      {
                        v91 = *(unsigned __int16 *)(v55 + 2 * v89);
                        if (v86 <= v91)
                          LOWORD(v92) = -1;
                        else
                          v92 = 0xFFFF * v91 / v86;
                        v85[v89 + v8] = v92;
                        ++v89;
                        --v90;
                      }
                      while (v90);
                    }
                  }
                  else if (v170)
                  {
                    v93 = 0;
                    v94 = v170;
                    do
                    {
                      v85[v93 + v8] = *(_WORD *)(v55 + 2 * v93);
                      ++v93;
                      --v94;
                    }
                    while (v94);
                  }
                  v85[v183] = v86;
                  v55 += v178;
                  v53 = (float *)((char *)v53 + v185);
                  v85 = (_WORD *)((char *)v85 + v179);
                  ++v84;
                }
                while (v84 != v54);
              }
            }
            else if ((v172 & 1) != 0)
            {
              if (v51 != v49)
              {
                v103 = 0;
                v104 = v182;
                do
                {
                  switch(v83)
                  {
                    case 1:
                      if (v170)
                      {
                        v105 = 0;
                        v106 = v170;
                        do
                        {
                          v104[v105 + v8] = (*(unsigned __int16 *)v53 * *(unsigned __int16 *)(v55 + 2 * v105)
                                           - (*(unsigned __int16 *)v53 ^ 0xFFFF)
                                           + ((*(unsigned __int16 *)v53 ^ 0xFFFFu) << 16))
                                          / 0xFFFF;
                          ++v105;
                          --v106;
                        }
                        while (v106);
                      }
                      break;
                    case 2:
                      if (v170)
                      {
                        v107 = 0;
                        v108 = v170;
                        do
                        {
                          v109 = *(unsigned __int16 *)(v55 + 2 * v107);
                          v110 = *(unsigned __int16 *)v53;
                          if (v110 <= v109)
                            LOWORD(v111) = -1;
                          else
                            v111 = 0xFFFF * v109 / v110;
                          v104[v107 + v8] = v111;
                          ++v107;
                          --v108;
                        }
                        while (v108);
                      }
                      break;
                    case 3:
                      if (v170)
                      {
                        v112 = 0;
                        v113 = v170;
                        do
                        {
                          v114 = *(unsigned __int16 *)(v55 + 2 * v112);
                          v115 = *(unsigned __int16 *)v53;
                          if (v115 <= v114)
                            v116 = 0xFFFF;
                          else
                            v116 = (unsigned __int16)(0xFFFF * v114 / v115);
                          v104[v112 + v8] = v116;
                          v104[v112 + v8] = (*(unsigned __int16 *)v53 * v116
                                           - (*(unsigned __int16 *)v53 ^ 0xFFFF)
                                           + ((*(unsigned __int16 *)v53 ^ 0xFFFFu) << 16))
                                          / 0xFFFF;
                          ++v112;
                          --v113;
                        }
                        while (v113);
                      }
                      break;
                    default:
                      if (v170)
                      {
                        v117 = 0;
                        v118 = v170;
                        do
                        {
                          v104[v117 + v8] = *(_WORD *)(v55 + 2 * v117);
                          ++v117;
                          --v118;
                        }
                        while (v118);
                      }
                      break;
                  }
                  v55 += v178;
                  v53 = (float *)((char *)v53 + v185);
                  v104 = (_WORD *)((char *)v104 + v179);
                  ++v103;
                }
                while (v103 != v54);
              }
            }
            else if ((v166 & 1) != 0)
            {
              if (v51 != v49)
              {
                v140 = 0;
                v141 = v182;
                do
                {
                  if (v170)
                  {
                    v142 = 0;
                    v143 = v170;
                    do
                    {
                      v141[v142 + v8] = *(_WORD *)(v55 + 2 * v142);
                      ++v142;
                      --v143;
                    }
                    while (v143);
                  }
                  v141[v183] = -1;
                  v55 += v178;
                  v141 = (_WORD *)((char *)v141 + v179);
                  ++v140;
                }
                while (v140 != v54);
              }
            }
            else if (v51 != v49)
            {
              v152 = 0;
              v153 = v182;
              do
              {
                if (v170)
                {
                  v154 = 0;
                  v155 = v170;
                  do
                  {
                    v153[v154 + v8] = *(_WORD *)(v55 + 2 * v154);
                    ++v154;
                    --v155;
                  }
                  while (v155);
                }
                v55 += v178;
                v153 = (_WORD *)((char *)v153 + v179);
                ++v152;
              }
              while (v152 != v54);
            }
            break;
          case 1uLL:
            v56 = a1[20];
            v57 = *((double *)a1 + 9) * 255.0;
            v58 = (int)v57;
            if (v167)
            {
              if (v51 != v49)
              {
                v59 = 0;
                v60 = v182;
                do
                {
                  v61 = *(unsigned __int8 *)v53;
                  if (v56 == 1)
                  {
                    if (v170)
                    {
                      v62 = 0;
                      v63 = v170;
                      do
                      {
                        *((_BYTE *)v60 + v62 + v8) = (257
                                                    * ((v61 ^ 0xFF) * v58
                                                     + *(unsigned __int8 *)(v55 + v62) * (_DWORD)v61)
                                                    + 32896) >> 16;
                        ++v62;
                        --v63;
                      }
                      while (v63);
                    }
                  }
                  else if (v56 == 2)
                  {
                    if (v170)
                    {
                      v64 = 0;
                      v65 = v170;
                      do
                      {
                        v66 = *(unsigned __int8 *)(v55 + v64);
                        v67 = (int)v57;
                        if (v61 > v66)
                        {
                          v68 = (unint64_t)(_inv_alpha[v61] * v66 + 0x8000) >> 16;
                          LOBYTE(v67) = ((255 - v68) >> 31) | v68;
                        }
                        *((_BYTE *)v60 + v64 + v8) = v67;
                        ++v64;
                        --v65;
                      }
                      while (v65);
                    }
                  }
                  else if (v170)
                  {
                    v69 = 0;
                    v70 = v170;
                    do
                    {
                      *((_BYTE *)v60 + v69 + v8) = *(_BYTE *)(v55 + v69);
                      ++v69;
                      --v70;
                    }
                    while (v70);
                  }
                  *((_BYTE *)v60 + v183) = v61;
                  ++v59;
                  v55 += v178;
                  v53 = (float *)((char *)v53 + v185);
                  v60 = (_WORD *)((char *)v60 + v179);
                }
                while (v59 != v54);
              }
            }
            else if ((v172 & 1) != 0)
            {
              if (v51 != v49)
              {
                v119 = 0;
                v120 = v182;
                do
                {
                  v121 = *(unsigned __int8 *)v53;
                  switch(v56)
                  {
                    case 1:
                      if (v170)
                      {
                        v122 = 0;
                        v123 = v170;
                        do
                        {
                          *((_BYTE *)v120 + v122 + v8) = (257
                                                        * ((v121 ^ 0xFF) * v58
                                                         + *(unsigned __int8 *)(v55 + v122) * (_DWORD)v121)
                                                        + 32896) >> 16;
                          ++v122;
                          --v123;
                        }
                        while (v123);
                      }
                      break;
                    case 2:
                      if (v170)
                      {
                        v124 = 0;
                        v125 = v170;
                        do
                        {
                          v126 = *(unsigned __int8 *)(v55 + v124);
                          v127 = (int)v57;
                          if (v121 > v126)
                          {
                            v128 = (unint64_t)(_inv_alpha[v121] * v126 + 0x8000) >> 16;
                            LOBYTE(v127) = ((255 - v128) >> 31) | v128;
                          }
                          *((_BYTE *)v120 + v124 + v8) = v127;
                          ++v124;
                          --v125;
                        }
                        while (v125);
                      }
                      break;
                    case 3:
                      if (v170)
                      {
                        v129 = 0;
                        v130 = v170;
                        do
                        {
                          v131 = *(unsigned __int8 *)(v55 + v129);
                          v132 = (int)v57;
                          if (v121 > v131)
                          {
                            v133 = _inv_alpha[v121] * v131 + 0x8000;
                            v132 = (((255 - (v133 >> 16)) >> 31) | BYTE2(v133));
                          }
                          *((_BYTE *)v120 + v129 + v8) = (257
                                                        * ((v121 ^ 0xFF) * v58 + v132 * (_DWORD)v121)
                                                        + 32896) >> 16;
                          ++v129;
                          --v130;
                        }
                        while (v130);
                      }
                      break;
                    default:
                      if (v170)
                      {
                        v134 = 0;
                        v135 = v170;
                        do
                        {
                          *((_BYTE *)v120 + v134 + v8) = *(_BYTE *)(v55 + v134);
                          ++v134;
                          --v135;
                        }
                        while (v135);
                      }
                      break;
                  }
                  ++v119;
                  v55 += v178;
                  v53 = (float *)((char *)v53 + v185);
                  v120 = (_WORD *)((char *)v120 + v179);
                }
                while (v119 != v54);
              }
            }
            else if ((v166 & 1) != 0)
            {
              if (v51 != v49)
              {
                v144 = 0;
                v145 = v182;
                do
                {
                  if (v170)
                  {
                    v146 = 0;
                    v147 = v170;
                    do
                    {
                      *((_BYTE *)v145 + v146 + v8) = *(_BYTE *)(v55 + v146);
                      ++v146;
                      --v147;
                    }
                    while (v147);
                  }
                  *((_BYTE *)v145 + v183) = -1;
                  ++v144;
                  v55 += v178;
                  v145 = (_WORD *)((char *)v145 + v179);
                }
                while (v144 != v54);
              }
            }
            else if (v51 != v49)
            {
              v156 = 0;
              v157 = v182;
              do
              {
                if (v170)
                {
                  v158 = 0;
                  v159 = v170;
                  do
                  {
                    *((_BYTE *)v157 + v158 + v8) = *(_BYTE *)(v55 + v158);
                    ++v158;
                    --v159;
                  }
                  while (v159);
                }
                ++v156;
                v55 += v178;
                v157 = (_WORD *)((char *)v157 + v179);
              }
              while (v156 != v54);
            }
            break;
        }
        v160 = v54 * v179;
        if ((v169 & 2) != 0 && v182 && v160 >= 2)
        {
          v161 = v160 >> 1;
          v162 = v182;
          do
          {
            *v162 = bswap32((unsigned __int16)*v162) >> 16;
            ++v162;
            --v161;
          }
          while (v161);
        }
        if (v169 >= 4 && v182 && v160 >= 4)
        {
          v163 = v160 >> 2;
          v164 = (unsigned int *)v182;
          do
          {
            *v164 = bswap32(*v164);
            ++v164;
            --v163;
          }
          while (v163);
        }
        if (!v160)
        {
          _cg_jpeg_mem_term("alphaProviderGetBytes", 2306, "bytesRead == 0   (startPixel = %ld    stopPixel = %ld)\n", v49, v177);
          return v3;
        }
        v35 = *(_QWORD *)a1 + v160;
        *(_QWORD *)a1 = v35;
        v36 = (_WORD *)((char *)v182 + v160);
        v3 += v160;
        v30 -= v160;
      }
      while (v3 < v31);
    }
  }
  return v3;
}

uint64_t alphaProviderSkipForward(_QWORD *a1, uint64_t a2)
{
  if (!a1)
    return 0;
  *a1 += a2;
  return a2;
}

void alphaProviderRewind(_QWORD *a1)
{
  void *v2;
  void *v3;

  if (a1)
  {
    if (a1[4])
      CGAccessSessionRelease();
    a1[4] = 0;
    if (a1[5])
      CGAccessSessionRelease();
    a1[5] = 0;
    v2 = (void *)a1[2];
    if (v2)
      free(v2);
    a1[2] = 0;
    v3 = (void *)a1[3];
    if (v3)
      free(v3);
    a1[3] = 0;
    *a1 = 0;
    a1[1] = 0;
  }
}

void alphaProviderReleaseInfo(_QWORD *a1)
{
  const void *v2;
  const void *v3;

  if (a1)
  {
    alphaProviderRewind(a1);
    v2 = (const void *)a1[6];
    if (v2)
      CFRelease(v2);
    a1[6] = 0;
    v3 = (const void *)a1[7];
    if (v3)
      CFRelease(v3);
    free(a1);
  }
}

CGImageRef CGImageCreateCopyWithBitmapInfo_vImage(CGImageRef image, CGColor *a2, uint32_t a3, unint64_t a4, CGBitmapInfo a5, BOOL a6, CGColorRenderingIntent a7)
{
  CGColorSpace *ColorSpace;
  const CGFloat *Components;
  vImage_Buffer buf;
  vImage_CGImageFormat format;
  _OWORD v17[8];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if ((gIIODebugFlags & 0x400000000) != 0)
    ImageIOLog("    %s\n", "CGImageCreateCopyWithBitmapInfo_vImage");
  *((_DWORD *)&format.renderingIntent + 1) = 0;
  format.bitsPerComponent = CGImageGetBitsPerComponent(image);
  format.bitsPerPixel = a3;
  ColorSpace = CGImageGetColorSpace(image);
  format.colorSpace = ColorSpace;
  format.bitmapInfo = a5;
  format.version = 0;
  format.decode = CGImageGetDecode(image);
  format.renderingIntent = a7;
  memset(&buf, 0, sizeof(buf));
  memset(v17, 0, sizeof(v17));
  if (a2 && (CGColorGetColorSpace(a2), CGColorSpaceEqualToColorSpace()))
  {
    Components = CGColorGetComponents(a2);
  }
  else if (IIO_ConvertCGColorToColorComponents(a2, (uint64_t)ColorSpace))
  {
    Components = (const CGFloat *)v17;
  }
  else
  {
    Components = 0;
  }
  if (vImageBuffer_InitWithCGImage(&buf, &format, Components, image, 0))
    return 0;
  else
    return vImageCreateCGImageFromBuffer(&buf, &format, 0, 0, 0x200u, 0);
}

CGImageRef CGImageCreateCopyWithAlphaInfo(CGImage *a1, CGColor *a2, int a3)
{
  uint64_t v6;
  CGColorSpace *ColorSpace;
  size_t BitsPerComponent;
  CGBitmapInfo v9;
  CGColorRenderingIntent RenderingIntent;
  unint64_t v11;
  CGImageRef CopyWithBitmapInfo_vImage;

  kdebug_trace();
  IIOInitDebugFlags();
  v6 = gIIODebugFlags;
  if ((unsigned __int16)gIIODebugFlags >> 14)
  {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageCreateCopyWithAlphaInfo", 0, 0, -1, 0);
    v6 = gIIODebugFlags;
  }
  if ((v6 & 0x400000000) != 0)
    ImageIOLog("    %s\n", "CGImageCreateCopyWithAlphaInfo");
  CGImageGetWidth(a1);
  ColorSpace = CGImageGetColorSpace(a1);
  BitsPerComponent = CGImageGetBitsPerComponent(a1);
  LODWORD(ColorSpace) = _GetMinimalPixelSize(ColorSpace, BitsPerComponent, a3);
  v9 = _ImageGetNonAlphaInfo(a1) | a3;
  CGImageGetShouldInterpolate(a1);
  RenderingIntent = CGImageGetRenderingIntent(a1);
  CopyWithBitmapInfo_vImage = CGImageCreateCopyWithBitmapInfo_vImage(a1, a2, (uint32_t)ColorSpace, v11, v9, 0, RenderingIntent);
  kdebug_trace();
  return CopyWithBitmapInfo_vImage;
}

CFDataRef CGImageIOCreateXMPDataFromMetaData(CFDataRef a1)
{
  unsigned __int8 *v2;
  size_t v4[3];
  size_t size;

  kdebug_trace();
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageIOCreateXMPDataFromMetaData", 0, 0, -1, 0);
  size = 0;
  memset(v4, 0, sizeof(v4));
  IIODictionary::IIODictionary((IIODictionary *)v4);
  if (a1)
  {
    bufferXMPForImageProperties((IIODictionary *)v4, 0, (uint64_t *)&size);
    if ((uint64_t)size >= 1 && (v2 = (unsigned __int8 *)malloc_type_malloc(size, 0x100004077774924uLL)) != 0)
    {
      bufferXMPForImageProperties((IIODictionary *)v4, v2, (uint64_t *)&size);
      a1 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v2, size);
      free(v2);
    }
    else
    {
      a1 = 0;
    }
  }
  kdebug_trace();
  IIODictionary::~IIODictionary((IIODictionary *)v4);
  return a1;
}

void sub_187FAD090(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  IIODictionary::~IIODictionary((IIODictionary *)&a9);
  _Unwind_Resume(a1);
}

void bufferXMPForImageProperties(IIODictionary *a1, unsigned __int8 *a2, uint64_t *a3)
{
  __CFString *v5;
  CFIndex v6;
  unsigned int Uint32ForKey;
  int v9;
  int v10;
  const __CFDictionary *Uint32ForKeyGroup;
  const __CFAllocator *v12;
  __CFString *Mutable;
  uint64_t v14;
  const __CFString *v15;
  const __CFString *v16;
  const __CFString *v17;
  const __CFString *v18;
  CFIndex usedBufLen;
  CFRange v20;

  v5 = 0;
  usedBufLen = 0;
  v6 = 1;
  if (!a1 || !a3)
  {
LABEL_29:
    if (a2)
      goto LABEL_35;
    goto LABEL_33;
  }
  if (IIODictionary::containsKey(a1, CFSTR("Orientation")))
  {
    Uint32ForKey = IIODictionary::getUint32ForKey(a1, CFSTR("Orientation"));
  }
  else
  {
    if (!IIODictionary::containsKeyGroup(a1, CFSTR("Orientation"), CFSTR("{TIFF}")))
    {
      if (!IIODictionary::containsKeyGroup(a1, CFSTR("Orientation"), CFSTR("{TIFF}")))
      {
        v5 = 0;
        goto LABEL_32;
      }
      Uint32ForKey = 0;
      v9 = 0;
      goto LABEL_11;
    }
    Uint32ForKey = IIODictionary::getUint32ForKeyGroup(a1, CFSTR("Orientation"), CFSTR("{TIFF}"));
  }
  v9 = 1;
  if ((IIODictionary::containsKeyGroup(a1, CFSTR("Orientation"), CFSTR("{TIFF}")) & 1) == 0)
  {
    v10 = 0;
    Uint32ForKeyGroup = 0;
    goto LABEL_12;
  }
LABEL_11:
  Uint32ForKeyGroup = IIODictionary::getUint32ForKeyGroup(a1, CFSTR("StarRating"), CFSTR("{IPTC}"));
  v10 = 1;
LABEL_12:
  v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  v5 = Mutable;
  if (!Mutable)
    goto LABEL_32;
  CFStringAppend(Mutable, CFSTR("<x:xmpmeta xmlns:x=\"adobe:ns:meta/\" x:xmptk=\"XMP Core 4.4.0\">\n   <rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\">\n"));
  if (v9)
  {
    if (Uint32ForKey >= 8)
      LODWORD(v14) = 8;
    else
      LODWORD(v14) = Uint32ForKey;
    if (v14 <= 1)
      v14 = 1;
    else
      v14 = v14;
    v15 = CFStringCreateWithFormat(v12, 0, CFSTR("      <rdf:Description rdf:about=\"\" xmlns:tiff=\"http://ns.adobe.com/tiff/1.0/\">\n         <tiff:Orientation>%d</tiff:Orientation>\n      </rdf:Description>\n"), v14);
    if (!v15)
      goto LABEL_32;
    v16 = v15;
    CFStringAppend(v5, v15);
    CFRelease(v16);
  }
  if (!v10)
    goto LABEL_25;
  v17 = CFStringCreateWithFormat(v12, 0, CFSTR("      <rdf:Description rdf:about=\"\" xmlns:xmp=\"http://ns.adobe.com/xap/1.0/\">\n         <xmp:Rating>%d</xmp:Rating>\n      </rdf:Description>\n"), Uint32ForKeyGroup);
  if (!v17)
  {
LABEL_32:
    v6 = 1;
    if (a2)
      goto LABEL_35;
LABEL_33:
    if (a3)
      *a3 = v6;
LABEL_35:
    if (!v5)
      return;
    goto LABEL_36;
  }
  v18 = v17;
  CFStringAppend(v5, v17);
  CFRelease(v18);
LABEL_25:
  CFStringAppend(v5, CFSTR("   </rdf:RDF>\n</x:xmpmeta>"));
  if (!a2)
  {
    usedBufLen = CFStringGetLength(v5);
    v6 = usedBufLen + 1;
    goto LABEL_29;
  }
  v20.length = *a3;
  v20.location = 0;
  CFStringGetBytes(v5, v20, 0x8000100u, 0, 0, a2, *a3, &usedBufLen);
  if (usedBufLen < *a3)
    a2[usedBufLen] = 0;
LABEL_36:
  CFRelease(v5);
}

const __CFData *CGImageCopyJPEGData(CGImage *a1)
{
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageCopyJPEGData", 0, 0, -1, 0);
  return CGImageCopySourceData(a1, CFSTR("public.jpeg"));
}

const __CFData *CGImageCopySourceData(CGImage *a1, const __CFString *a2)
{
  const __CFString *Property;
  __CFData *Mutable;
  CGImageDestination *v6;
  CGImageDestination *v7;
  BOOL v8;
  const __CFData *v9;
  IIOImageRead *Source;
  UInt8 buffer[8];
  CFRange v13;

  if (!a1)
    return 0;
  Property = (const __CFString *)CGImageGetProperty();
  if (!Property)
    return 0;
  Mutable = 0;
  if (CFStringCompare(Property, a2, 0) == kCFCompareEqualTo)
  {
    if (!CGImageGetProperty())
    {
LABEL_8:
      v9 = (const __CFData *)CGImageGetProperty();
      *(_QWORD *)buffer = 0;
      if (v9)
      {
        v13.location = 0;
        v13.length = 8;
        CFDataGetBytes(v9, v13, buffer);
        if (*(_QWORD *)buffer)
        {
          Source = (IIOImageRead *)CGImageSourceGetSource(*(uint64_t *)buffer);
          if (Source)
            return IIOImageRead::copyData(Source);
        }
      }
      return 0;
    }
    Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    v6 = CGImageDestinationCreateWithData(Mutable, a2, 1uLL, 0);
    if (!v6
      || (v7 = v6, CGImageDestinationAddImage(v6, a1, 0), v8 = CGImageDestinationFinalize(v7), CFRelease(v7), !v8))
    {
      CFRelease(Mutable);
      goto LABEL_8;
    }
  }
  return Mutable;
}

const __CFData *CGImageCopyJPEGDataAndColorSpace(CGImage *a1, CGColorSpaceRef *a2)
{
  const __CFData *v4;
  const __CFData *Property;
  IIODictionary *Properties;
  IIODictionary *v7;
  const __CFDictionary *ObjectForKeyGroup;
  float FloatAtIndex;
  float v10;
  const __CFDictionary *v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  CFStringRef *v18;
  const UInt8 *BytePtr;
  unint64_t Length;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  CFDataRef v30;
  CFDataRef v31;
  CGColorSpace *v32;
  CGColorSpace *ColorSpace;
  CGColorSpaceModel Model;
  float FloatForKeyGroup;
  float v36;
  float v37;
  _QWORD v38[3];
  _QWORD v39[3];
  UInt8 buffer[8];
  CFRange v41;

  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageCopyJPEGDataAndColorSpace", 0, 0, -1, 0);
  v4 = CGImageCopySourceData(a1, CFSTR("public.jpeg"));
  if (v4)
  {
    if (!a2)
      return v4;
  }
  else
  {
    v4 = CGImageCopySourceData(a1, CFSTR("public.jpeg-2000"));
    if (!a2)
      return v4;
  }
  *a2 = 0;
  if (!v4)
    return v4;
  *(_QWORD *)buffer = 0;
  Property = (const __CFData *)CGImageGetProperty();
  if (Property)
  {
    v41.location = 0;
    v41.length = 8;
    CFDataGetBytes(Property, v41, buffer);
    if (*(_QWORD *)buffer)
    {
      Properties = (IIODictionary *)IIOImagePlus::getProperties(*(IIOImagePlus **)(*(_QWORD *)buffer + 24));
      if (Properties)
      {
        v7 = Properties;
        if (IIODictionary::containsKeyGroup(Properties, CFSTR("Gamma"), CFSTR("{Exif}")))
        {
          if (IIODictionary::containsKeyGroup(v7, CFSTR("WhitePoint"), CFSTR("{TIFF}"))
            && IIODictionary::containsKeyGroup(v7, CFSTR("PrimaryChromaticities"), CFSTR("{TIFF}")))
          {
            FloatForKeyGroup = IIODictionary::getFloatForKeyGroup(v7, CFSTR("Gamma"), CFSTR("{Exif}"));
            ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup(v7, CFSTR("WhitePoint"), CFSTR("{TIFF}"));
            memset(v39, 0, sizeof(v39));
            IIOArray::IIOArray((IIOArray *)v39, ObjectForKeyGroup);
            FloatAtIndex = IIOArray::getFloatAtIndex((IIOArray *)v39, 0);
            v10 = IIOArray::getFloatAtIndex((IIOArray *)v39, 1);
            v11 = IIODictionary::getObjectForKeyGroup(v7, CFSTR("PrimaryChromaticities"), CFSTR("{TIFF}"));
            memset(v38, 0, sizeof(v38));
            IIOArray::IIOArray((IIOArray *)v38, v11);
            v12 = IIOArray::getFloatAtIndex((IIOArray *)v38, 0);
            v13 = IIOArray::getFloatAtIndex((IIOArray *)v38, 1);
            v14 = IIOArray::getFloatAtIndex((IIOArray *)v38, 2);
            v15 = IIOArray::getFloatAtIndex((IIOArray *)v38, 3);
            v16 = IIOArray::getFloatAtIndex((IIOArray *)v38, 4);
            v17 = IIOArray::getFloatAtIndex((IIOArray *)v38, 5);
            if (IIOChromaticitiesMatchAdobeRGB(FloatAtIndex, v10, v12, v13, v14, v15, v16, v17, FloatForKeyGroup))
            {
              v18 = (CFStringRef *)MEMORY[0x1E0C9D8F8];
            }
            else if (IIOChromaticitiesMatchSRGB(FloatAtIndex, v10, v12, v13, v14, v15, v16, v17, v36))
            {
              v18 = (CFStringRef *)MEMORY[0x1E0C9DA10];
            }
            else
            {
              if (!IIOChromaticitiesMatchLinearSRGB(FloatAtIndex, v10, v12, v13, v14, v15, v16, v17, v37))
              {
LABEL_21:
                IIOArray::~IIOArray((IIOArray *)v38);
                IIOArray::~IIOArray((IIOArray *)v39);
                goto LABEL_22;
              }
              v18 = (CFStringRef *)MEMORY[0x1E0C9DA00];
            }
            *a2 = CGColorSpaceCreateWithName(*v18);
            goto LABEL_21;
          }
        }
      }
    }
  }
LABEL_22:
  if (!*a2)
  {
    BytePtr = CFDataGetBytePtr(v4);
    Length = CFDataGetLength(v4);
    if (Length >= 4 && *BytePtr == 255 && BytePtr[1] == 216 && Length >= 7)
    {
      v21 = __rev16(*((unsigned __int16 *)BytePtr + 1));
      if (v21 != 65498)
      {
        v22 = __rev16(*((unsigned __int16 *)BytePtr + 2));
        v23 = 4;
        if (v21 == 65506)
        {
          v24 = 6;
LABEL_36:
          if (v22 >= 0x11
            && v23 + (unint64_t)v22 < Length
            && !strncmp((const char *)&BytePtr[v24], "ICC_PROFILE", 0xBuLL)
            && v22 != 16)
          {
            v30 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], &BytePtr[v23 + 16], v22 - 16);
            if (v30)
            {
              v31 = v30;
              v32 = (CGColorSpace *)MEMORY[0x18D760CAC]();
              ColorSpace = CGImageGetColorSpace(a1);
              Model = CGColorSpaceGetModel(ColorSpace);
              if (Model == CGColorSpaceGetModel(v32))
                *a2 = v32;
              else
                CGColorSpaceRelease(v32);
              CFRelease(v31);
            }
          }
        }
        else
        {
          while (1)
          {
            v25 = v23 + v22;
            v23 = v25 + 2;
            if (v25 + 2 >= Length)
              break;
            v26 = __rev16(*(unsigned __int16 *)&BytePtr[v25]);
            v24 = v25 + 4;
            if (v25 + 4 >= Length || v26 == 65498)
              break;
            v22 = BytePtr[v25 + 3] | (BytePtr[v23] << 8);
            if (v26 == 65506)
              goto LABEL_36;
          }
        }
      }
    }
  }
  return v4;
}

void sub_187FAD93C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  IIOArray::~IIOArray((IIOArray *)va);
  _Unwind_Resume(a1);
}

CGImageRef CreateImageFromMask(CGImage *a1)
{
  CGColorSpace *v2;
  CGDataProvider *DataProvider;
  const __CFData *v4;
  const __CFData *v5;
  const UInt8 *BytePtr;
  size_t Width;
  size_t Height;
  size_t BytesPerRow;
  size_t v10;
  UInt8 *v11;
  UInt8 *v12;
  uint64_t v13;
  UInt8 *v14;
  uint64_t v15;
  _BYTE *v16;
  size_t v17;
  UInt8 v18;
  const __CFData *v20;
  const __CFData *v21;
  CGDataProvider *v22;
  CGDataProvider *v23;
  CGImageRef v24;

  v2 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D978]);
  if (CGImageGetBitsPerComponent(a1) != 8)
    goto LABEL_17;
  DataProvider = CGImageGetDataProvider(a1);
  if (!DataProvider)
    goto LABEL_17;
  v4 = CGDataProviderCopyData(DataProvider);
  if (!v4)
    goto LABEL_17;
  v5 = v4;
  BytePtr = CFDataGetBytePtr(v4);
  Width = CGImageGetWidth(a1);
  Height = CGImageGetHeight(a1);
  BytesPerRow = CGImageGetBytesPerRow(a1);
  if (CFDataGetLength(v5) < BytesPerRow * Height
    || (v10 = 2 * BytesPerRow, (v11 = (UInt8 *)malloc_type_calloc(2 * BytesPerRow, Height, 0x2AB7C12AuLL)) == 0))
  {
    CFRelease(v5);
LABEL_17:
    v24 = 0;
    goto LABEL_18;
  }
  v12 = v11;
  memcpy(v11, BytePtr, BytesPerRow * Height);
  CFRelease(v5);
  v13 = Height - 1;
  if ((uint64_t)(Height - 1) >= 0)
  {
    v14 = &v12[BytesPerRow * v13];
    v15 = (uint64_t)&v12[2 * BytesPerRow * v13 - 1 + 2 * Width];
    do
    {
      if (((Width - 1) & 0x8000000000000000) == 0)
      {
        v16 = (_BYTE *)v15;
        v17 = Width;
        do
        {
          v18 = v14[v17 - 1];
          *(v16 - 1) = 0;
          *v16 = v18;
          v16 -= 2;
          --v17;
        }
        while (v17);
      }
      v14 -= BytesPerRow;
      v15 -= 2 * BytesPerRow;
    }
    while (v13-- >= 1);
  }
  v20 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v12, v10 * Height);
  if (v20)
  {
    v21 = v20;
    v22 = CGDataProviderCreateWithCFData(v20);
    if (v22)
    {
      v23 = v22;
      v24 = CGImageCreate(Width, Height, 8uLL, 0x10uLL, v10, v2, 3u, v22, 0, 1, kCGRenderingIntentDefault);
      CGImageSetProperty();
      CGImageSetProperty();
      CGDataProviderRelease(v23);
    }
    else
    {
      v24 = 0;
    }
    CFRelease(v21);
  }
  else
  {
    v24 = 0;
  }
  free(v12);
LABEL_18:
  CGColorSpaceRelease(v2);
  return v24;
}

CGImageRef Create1BitImageFromImageRefWithOrientation(CGImage *a1, int a2, unsigned int a3)
{
  CGColorSpace *v6;
  size_t Width;
  size_t Height;
  unint64_t v9;
  CGFloat v10;
  CGFloat v11;
  double v12;
  double v13;
  CGFloat v14;
  CGFloat v15;
  size_t v16;
  size_t v17;
  char *v18;
  CGContext *v19;
  size_t v20;
  char *v21;
  uint64_t i;
  int v23;
  char *v24;
  unsigned __int8 v25;
  size_t v26;
  char *v27;
  unsigned int v28;
  CGDataProvider *v29;
  CGImageRef v30;
  CGAffineTransform transform;
  CGRect v33;
  CGRect v34;

  v6 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D978]);
  Width = CGImageGetWidth(a1);
  Height = CGImageGetHeight(a1);
  v9 = Height;
  v10 = 1.0;
  v11 = 0.0;
  switch(a2)
  {
    case 2:
      v12 = (double)Width;
      v10 = -1.0;
      v13 = 0.0;
      goto LABEL_4;
    case 3:
      v12 = (double)Width;
      v13 = (double)Height;
      v14 = -1.0;
      v15 = 0.0;
      v10 = -1.0;
      break;
    case 4:
      v13 = (double)Height;
      v14 = -1.0;
      v12 = 0.0;
      goto LABEL_7;
    case 5:
      v12 = (double)Height;
      v13 = (double)Width;
      v11 = -1.0;
      v14 = 0.0;
      v15 = -1.0;
      goto LABEL_13;
    case 6:
      v13 = (double)Width;
      v15 = -1.0;
      v11 = 1.0;
      v12 = 0.0;
      goto LABEL_12;
    case 7:
      v11 = 1.0;
      v13 = 0.0;
      v12 = 0.0;
      v14 = 0.0;
      v15 = 1.0;
      goto LABEL_13;
    case 8:
      v12 = (double)Height;
      v15 = 1.0;
      v11 = -1.0;
      v13 = 0.0;
LABEL_12:
      v14 = 0.0;
LABEL_13:
      v10 = 0.0;
      break;
    default:
      v13 = 0.0;
      v12 = 0.0;
LABEL_4:
      v14 = 1.0;
LABEL_7:
      v15 = 0.0;
      break;
  }
  if (a2 >= 5)
    v16 = Width;
  else
    v16 = Height;
  if (a2 >= 5)
    v17 = Height;
  else
    v17 = Width;
  v18 = (char *)malloc_type_calloc(v17, v16, 0xF44CE701uLL);
  v19 = CGBitmapContextCreate(v18, v17, v16, 8uLL, v17, v6, 0);
  if (!v19)
    _cg_jpeg_mem_term("Create1BitImageFromImageRefWithOrientation", 3166, "*** ERROR: CGBitmapContextCreate returned NULL\n");
  v33.size.width = (double)v17;
  v33.size.height = (double)v16;
  v33.origin.x = 0.0;
  v33.origin.y = 0.0;
  CGContextClearRect(v19, v33);
  transform.a = v10;
  transform.b = v15;
  transform.c = v11;
  transform.d = v14;
  transform.tx = v12;
  transform.ty = v13;
  CGContextConcatCTM(v19, &transform);
  v34.size.width = (double)Width;
  v34.size.height = (double)v9;
  v34.origin.x = 0.0;
  v34.origin.y = 0.0;
  CGContextDrawImage(v19, v34, a1);
  v20 = (v17 + 7) >> 3;
  v21 = (char *)malloc_type_calloc(v20, v16, 0xBFD345E9uLL);
  if (v16)
  {
    for (i = 0; i != v16; ++i)
    {
      if (v17)
      {
        v23 = 0;
        v24 = &v18[i * v17];
        v25 = 0x80;
        v26 = v17;
        v27 = &v21[i * v20];
        do
        {
          if (v23 == 8)
          {
            ++v27;
            v25 = 0x80;
          }
          v28 = *v24++;
          if (v28 > a3)
            *v27 |= v25;
          v25 >>= 1;
          if (v23 == 8)
            v23 = 1;
          else
            ++v23;
          --v26;
        }
        while (v26);
      }
    }
  }
  v29 = CGDataProviderCreateWithData(v21, v21, v20 * v16, (CGDataProviderReleaseDataCallback)_CGDataProviderReleaseDataCallback);
  v30 = CGImageCreate(v17, v16, 1uLL, 1uLL, (v17 + 7) >> 3, v6, 0, v29, 0, 0, kCGRenderingIntentDefault);
  CGImageSetProperty();
  CGImageSetProperty();
  CGDataProviderRelease(v29);
  CGContextRelease(v19);
  CGColorSpaceRelease(v6);
  if (v18)
    free(v18);
  return v30;
}

void _CGDataProviderReleaseDataCallback(void *a1, const void *a2)
{
  if (a1)
    free(a1);
}

BOOL CGImageIsInsideSRGB(void *a1)
{
  CFTypeID v2;

  if (a1)
  {
    v2 = CFGetTypeID(a1);
    if (v2 == CGImageGetTypeID())
      return CGImageIsInside_sRGB((CGImage *)a1);
    LogError("CGImageIsInsideSRGB", 3277, "*** ERROR: CGImageIsInsideSRGB: image is not a CGImageRef\n");
  }
  else
  {
    LogError("CGImageIsInsideSRGB", 3276, "*** ERROR: CGImageIsInsideSRGB: image is nil\n");
  }
  return 0;
}

BOOL CGImageIsInside_sRGB(CGImage *a1)
{
  unint64_t Width;
  unint64_t Height;
  CGColorSpace *ColorSpace;
  double Current;
  uint64_t Property;
  uint64_t v7;
  CGColorSpace *v8;
  void *v9;
  CGContext *v10;
  CFAbsoluteTime v11;
  uint64_t v13;
  void *Data;
  size_t BytesPerRow;
  CGDataProviderRef DataProvider;
  size_t v17;
  vImage_Buffer v18;
  CGRect v19;

  Width = CGImageGetWidth(a1);
  Height = CGImageGetHeight(a1);
  ColorSpace = CGImageGetColorSpace(a1);
  Current = CFAbsoluteTimeGetCurrent();
  if ((gIIODebugFlags & 0x400000000) != 0)
    ImageIOLog("    %s\n", "CGImageIsInside_sRGB");
  Property = CGImageGetProperty();
  if (Property)
    return Property == *MEMORY[0x1E0C9AE50];
  if (!IIO_CGColorSpaceNameMatchesName(ColorSpace, (const __CFString *)*MEMORY[0x1E0C9DA10]))
  {
    if (IIO_CGColorSpaceNameMatchesName(ColorSpace, (const __CFString *)*MEMORY[0x1E0C9D908])
      || CGColorSpaceIsWideGamutRGB(ColorSpace))
    {
      v8 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D960]);
      v9 = malloc_type_calloc(Height, 8 * Width, 0xF500D73uLL);
      v10 = CGBitmapContextCreate(v9, Width, Height, 0x10uLL, 8 * Width, v8, 0x1105u);
      if (v10)
      {
        CGContextClear();
        v19.size.width = (double)Width;
        v19.size.height = (double)Height;
        v19.origin.x = 0.0;
        v19.origin.y = 0.0;
        CGContextDrawImage(v10, v19, a1);
        v18.data = v9;
        v18.height = Height;
        v18.width = Width;
        v18.rowBytes = 8 * Width;
        v7 = FP16DataInZeroToOneRange(&v18);
        CGContextRelease(v10);
      }
      else
      {
        v7 = 1;
      }
      free(v9);
      CGColorSpaceRelease(v8);
      goto LABEL_13;
    }
    if (IIO_CGColorSpaceNameMatchesName(ColorSpace, (const __CFString *)*MEMORY[0x1E0C9D960]))
    {
      if (CGImageGetImageProvider())
      {
        v13 = CGImageProviderCopyImageBlockSetWithOptions();
        if (v13)
        {
          if (CGImageBlockSetGetCount())
          {
            CGImageBlockSetGetImageBlock();
            Data = (void *)CGImageBlockGetData();
            BytesPerRow = CGImageBlockGetBytesPerRow();
            CGImageBlockGetRect();
            if (Data)
            {
              DataProvider = 0;
              goto LABEL_27;
            }
          }
        }
      }
      else
      {
        v13 = 0;
      }
      DataProvider = CGImageGetDataProvider(a1);
      Data = (void *)CGDataProviderRetainBytePtr();
      if (!Data)
        _cg_jpeg_mem_term("CGImageIsInside_sRGB", 3382, "*** CGDataProviderRetainBytePtr returned NULL\n");
      CGDataProviderGetSizeOfData();
      v17 = CGImageGetBytesPerRow(a1);
      if (!Data)
      {
        v7 = 1;
        goto LABEL_29;
      }
      BytesPerRow = v17;
LABEL_27:
      v18.data = Data;
      v18.height = Height;
      v18.width = Width;
      v18.rowBytes = BytesPerRow;
      v7 = FP16DataInZeroToOneRange(&v18);
LABEL_29:
      if (v13)
        CGImageBlockSetRelease();
      if (DataProvider)
        CGDataProviderReleaseBytePtr();
      goto LABEL_13;
    }
  }
  v7 = 1;
LABEL_13:
  if ((gIIODebugFlags & 0x20000000000) != 0)
  {
    v11 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("    CGImageIsInside_sRGB - %g ms\n", (v11 - Current) * 1000.0);
  }
  return v7;
}

void sub_187FAE260(_Unwind_Exception *a1)
{
  CGColorSpace *v1;

  CGColorSpaceRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t FP16DataInZeroToOneRange(vImage_Buffer *a1)
{
  char *data;
  vImagePixelCount height;
  uint64_t v3;
  size_t rowBytes;
  vImagePixelCount width;
  uint64_t result;
  uint64_t v7;
  char *v8;
  uint64_t i;

  if (!a1)
    return 1;
  data = (char *)a1->data;
  if (!a1->data)
    return 1;
  height = a1->height;
  if (!height)
    return 1;
  v3 = 0;
  width = a1->width;
  rowBytes = a1->rowBytes;
  result = 1;
  do
  {
    if (width)
    {
      v7 = 0;
      v8 = &data[rowBytes * v3];
      while (2)
      {
        for (i = 0; i != 6; i += 2)
        {
          _H2 = *(_WORD *)&v8[i];
          __asm { FCVT            D2, H2 }
          if (_D2 > 1.003 || _D2 < -0.025)
          {
            if ((gIIODebugFlags & 0x8000300000) != 0)
              ImageIOLog("COL FP16DataInZeroToOneRange: outSide [0..1] range at: [%d,%d] value: %g\n", v7, v3, _D2);
            return 0;
          }
        }
        v8 += 8;
        if (++v7 != width)
          continue;
        break;
      }
    }
    ++v3;
  }
  while (v3 != height);
  return result;
}

CGImageRef IIOImageCreateWithImageAndMaskInterleaved(CGImage *a1, IIODictionary *a2)
{
  uint64_t Mask;
  CGImage *v4;
  int BitsPerComponent;
  vImage_Error v6;
  CGImageRef v7;
  uint32_t v8;
  vImage_Error v9;
  vImage_Error error;
  vImage_CGImageFormat v12;
  vImage_CGImageFormat format;
  vImage_Buffer newSrc;
  vImage_Buffer buf;

  memset(&buf, 0, sizeof(buf));
  memset(&newSrc, 0, sizeof(newSrc));
  memset(&format.bitmapInfo, 0, 24);
  memset(&v12, 0, sizeof(v12));
  Mask = CGImageGetMask();
  if (!Mask)
    return 0;
  v4 = (CGImage *)Mask;
  BitsPerComponent = CGImageGetBitsPerComponent(a1);
  if (BitsPerComponent != 8)
    _cg_jpeg_mem_term("IIOImageCreateWithImageAndMaskInterleaved", 3444, "*** NOTE: CGImage with mask will be converted from %dbpc to 8bpc\n", BitsPerComponent);
  format.bitmapInfo = 3;
  format.colorSpace = CGImageGetColorSpace(a1);
  *(_QWORD *)&format.bitsPerComponent = 0x2000000008;
  v6 = vImageBuffer_InitWithCGImage(&buf, &format, 0, a1, 0);
  v7 = 0;
  error = v6;
  if (!v6)
  {
    v8 = format.bitsPerComponent;
    v12.bitsPerComponent = format.bitsPerComponent;
    v12.colorSpace = CGImageGetColorSpace(v4);
    v12.bitmapInfo = 0;
    v12.bitsPerPixel = v8;
    v7 = 0;
    error = vImageBuffer_InitWithCGImage(&newSrc, &v12, 0, v4, 0);
    if (!error)
    {
      v9 = vImageOverwriteChannels_ARGB8888(&newSrc, &buf, &buf, 1u, 0x10u);
      if (v9 << 32)
        _cg_jpeg_mem_term("IIOImageCreateWithImageAndMaskInterleaved", 3468, "*** ERROR: vImageOverwriteChannels_ARGB8888 failed - err= %d\n", v9);
      error = vImageClipToAlpha_RGBA8888(&buf, &buf, 0x10u);
      v7 = vImageCreateCGImageFromBuffer(&buf, &format, 0, 0, 0, &error);
    }
  }
  if (buf.data)
    free(buf.data);
  if (newSrc.data)
    free(newSrc.data);
  return v7;
}

void GlobalPNGInfo::GlobalPNGInfo(GlobalPNGInfo *this, unsigned __int8 *a2, CFIndex a3)
{
  __CFReadStream *v6;
  __CFReadStream *v7;

  *(_QWORD *)this = &off_1E1BACC28;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 80), 0);
  *((_QWORD *)this + 8) = 0;
  v6 = CFReadStreamCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, a3, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  v7 = v6;
  if (v6)
  {
    if (CFReadStreamOpen(v6))
    {
      GlobalPNGInfo::readFromStream((UInt8 *)this, v7);
      CFReadStreamClose(v7);
    }
    CFRelease(v7);
  }
}

void sub_187FAE5A4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 16) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t GlobalPNGInfo::readFromStream(UInt8 *this, CFReadStreamRef stream)
{
  CFIndex v4;
  uint64_t result;
  CFIndex v6;
  CFIndex v7;
  unint64_t v8;
  unint64_t v9;
  __int128 v10;
  __int128 v11;
  UInt8 *v12;
  CFIndex v13;
  size_t size[2];
  __int128 v15;
  __int16 v16;
  UInt8 buffer[4];
  UInt8 v18[8];
  UInt8 v19[8];
  uint64_t v20;

  *(_QWORD *)v19 = 0;
  v20 = 0;
  *(_QWORD *)v18 = 0;
  *(_DWORD *)buffer = 0;
  if (CFReadStreamRead(stream, buffer, 4) != 4)
    return 4294967260;
  if (*(_DWORD *)buffer != 1112493127)
    return 0;
  if (CFReadStreamRead(stream, this + 32, 28) != 28)
    return 4294967260;
  v4 = CFReadStreamRead(stream, v18, 8);
  result = 4294967260;
  if (v4 == 8 && *(uint64_t *)v18 >= 1)
  {
    v6 = CFReadStreamRead(stream, v19, 8);
    result = 4294967260;
    if (v6 == 8 && (*(_QWORD *)v19 & 0x8000000000000000) == 0)
    {
      v7 = CFReadStreamRead(stream, (UInt8 *)&v20, 8);
      result = 4294967260;
      if (v7 == 8
        && v20 >= 1
        && !__CFADD__(*(_QWORD *)v19, v20)
        && (unint64_t)(*(_QWORD *)v19 + v20) <= *(_QWORD *)v18)
      {
        std::vector<fcTL_CHUNK>::resize((uint64_t)(this + 8), *(unint64_t *)v18);
        if (v20 >= 1)
        {
          v8 = *((_QWORD *)this + 1) + 34 * *(_QWORD *)v19;
          v9 = v8 + 34 * v20;
          do
          {
            v16 = 0;
            *(_OWORD *)size = 0u;
            v15 = 0u;
            if (CFReadStreamRead(stream, (UInt8 *)size, 34) != 34)
              return 4294967260;
            if ((size[1] & 0x8000000000000000) == 0
              && (v15 & 0x80000000) == 0
              && SHIDWORD(size[0]) >= 1
              && SLODWORD(size[1]) >= 1
              && HIDWORD(size[0]) + HIDWORD(size[1]) <= *((_DWORD *)this + 8)
              && LODWORD(size[1]) + (int)v15 <= *((_DWORD *)this + 9))
            {
              v10 = *(_OWORD *)size;
              v11 = v15;
              *(_WORD *)(v8 + 32) = v16;
              *(_OWORD *)v8 = v10;
              *(_OWORD *)(v8 + 16) = v11;
              v8 += 34;
            }
          }
          while (v8 < v9);
        }
        if (CFReadStreamRead(stream, buffer, 4) == 4)
        {
          if (*(_DWORD *)buffer != 1179992675)
            return 0;
          size[0] = 0;
          if (CFReadStreamRead(stream, (UInt8 *)size, 8) == 8)
          {
            if (!size[0])
              return 0;
            if (size[0] != *((_DWORD *)this + 12))
              return 0;
            v12 = (UInt8 *)malloc_type_malloc(size[0], 0xBD7E960uLL);
            *((_QWORD *)this + 8) = v12;
            v13 = CFReadStreamRead(stream, v12, size[0]);
            if (v13 == size[0])
              return 0;
          }
        }
        return 4294967260;
      }
    }
  }
  return result;
}

CFTypeRef GlobalPNGInfo::createDataRepresentation(GlobalPNGInfo *this, const CFRange *a2)
{
  __CFWriteStream *v4;
  __CFWriteStream *v5;
  CFTypeRef v6;

  v4 = CFWriteStreamCreateWithAllocatedBuffers((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
  if (!v4)
    return 0;
  v5 = v4;
  if (CFWriteStreamOpen(v4))
  {
    GlobalPNGInfo::writeToStream(this, v5, a2);
    v6 = CFWriteStreamCopyProperty(v5, (CFStreamPropertyKey)*MEMORY[0x1E0C9B2A8]);
    CFWriteStreamClose(v5);
  }
  else
  {
    v6 = 0;
  }
  CFRelease(v5);
  return v6;
}

uint64_t GlobalPNGInfo::writeToStream(GlobalPNGInfo *this, CFWriteStreamRef stream, const CFRange *a3)
{
  CFIndex *p_length;
  CFIndex length;
  const UInt8 *v9;
  const UInt8 *v10;
  UInt8 v11[8];
  UInt8 v12[12];
  UInt8 buffer[4];

  p_length = &a3->length;
  if (a3->location + a3->length > 0xF0F0F0F0F0F0F0F1
                                 * ((uint64_t)(*((_QWORD *)this + 2) - *((_QWORD *)this + 1)) >> 1))
    return 4294967246;
  *(_DWORD *)buffer = 1112493127;
  CFWriteStreamWrite(stream, buffer, 4);
  CFWriteStreamWrite(stream, (const UInt8 *)this + 32, 28);
  *(_QWORD *)v12 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*((_QWORD *)this + 2) - *((_QWORD *)this + 1)) >> 1);
  CFWriteStreamWrite(stream, v12, 8);
  CFWriteStreamWrite(stream, (const UInt8 *)a3, 8);
  CFWriteStreamWrite(stream, (const UInt8 *)p_length, 8);
  length = a3->length;
  if (length >= 1)
  {
    v9 = (const UInt8 *)(*((_QWORD *)this + 1) + 34 * a3->location);
    v10 = &v9[34 * length];
    do
    {
      CFWriteStreamWrite(stream, v9, 34);
      v9 += 34;
    }
    while (v9 < v10);
  }
  *(_DWORD *)buffer = 1179992675;
  CFWriteStreamWrite(stream, buffer, 4);
  *(_QWORD *)v11 = *((unsigned int *)this + 12);
  if (*(_DWORD *)v11 && !*((_QWORD *)this + 8))
    *(_QWORD *)v11 = 0;
  CFWriteStreamWrite(stream, v11, 8);
  if (*(_QWORD *)v11)
    CFWriteStreamWrite(stream, *((const UInt8 **)this + 8), *(CFIndex *)v11);
  return 0;
}

uint64_t GlobalPNGInfo::currentBuffer(GlobalPNGInfo *this, unsigned int *a2)
{
  pthread_mutex_t *v4;
  uint64_t v5;

  v4 = (pthread_mutex_t *)((char *)this + 80);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 80));
  v5 = *((_QWORD *)this + 8);
  if (a2)
    *a2 = *((_DWORD *)this + 12);
  pthread_mutex_unlock(v4);
  return v5;
}

uint64_t GlobalPNGInfo::setCurrentBuffer(GlobalPNGInfo *this, unsigned __int8 *a2, int a3, char a4)
{
  pthread_mutex_t *v8;

  v8 = (pthread_mutex_t *)((char *)this + 80);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 80));
  *((_QWORD *)this + 8) = a2;
  *((_DWORD *)this + 12) = a3;
  *((_BYTE *)this + 72) = a4;
  return pthread_mutex_unlock(v8);
}

uint64_t GlobalPNGInfo::currentBufferIndex(GlobalPNGInfo *this)
{
  pthread_mutex_t *v2;
  uint64_t v3;

  v2 = (pthread_mutex_t *)((char *)this + 80);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 80));
  v3 = *((unsigned int *)this + 13);
  pthread_mutex_unlock(v2);
  return v3;
}

uint64_t GlobalPNGInfo::setCurrentBufferIndex(GlobalPNGInfo *this, int a2)
{
  pthread_mutex_t *v4;

  v4 = (pthread_mutex_t *)((char *)this + 80);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 80));
  *((_DWORD *)this + 13) = a2;
  return pthread_mutex_unlock(v4);
}

uint64_t GlobalPNGInfo::setCurrentBufferRowBytes(GlobalPNGInfo *this, int a2)
{
  pthread_mutex_t *v4;

  v4 = (pthread_mutex_t *)((char *)this + 80);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 80));
  *((_DWORD *)this + 14) = a2;
  return pthread_mutex_unlock(v4);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<fcTL_CHUNK>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x787878787878788)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(34 * a2);
}

uint64_t IIO_Reader_GIF::createReadPlugin(IIO_Reader *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;

  v4 = operator new();
  v5 = IIO_Reader::osType(a1);
  GIFReadPlugin::GIFReadPlugin(v4, a2, v5);
  return v4;
}

void sub_187FAEC48(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C4034E73E8FLL);
  _Unwind_Resume(a1);
}

IIOImageRead *IIO_Reader_GIF::createGlobalInfoData(IIO_Reader_GIF *this, IIOImageReadSession *a2)
{
  IIOImageRead *result;
  GlobalGIFInfo *v3;
  CFRange v4;

  result = IIOImageReadSession::globalInfoForType(a2, *((_DWORD *)this + 6));
  if (result)
  {
    v3 = result;
    v4.location = 0;
    v4.length = GlobalGIFInfo::frameCount(result);
    return (IIOImageRead *)GlobalGIFInfo::createDataRepresentation(v3, &v4);
  }
  return result;
}

uint64_t IIO_Reader_GIF::updateGlobalInfo(IIO_Reader_GIF *this, IIOImageRead **a2, unsigned __int8 *a3, unint64_t a4)
{
  GlobalGIFInfo *v8;

  v8 = (GlobalGIFInfo *)operator new();
  GlobalGIFInfo::GlobalGIFInfo(v8, a3, a4);
  IIOImageReadSession::setGlobalInfo(a2, *((_DWORD *)this + 6), v8, (void (*)(void *))globalGIFInfoReleaseProc);
  return 0;
}

void sub_187FAED38(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C4062D5A0A4);
  _Unwind_Resume(a1);
}

GlobalGIFInfo *IIO_Reader_GIF::deserializeGlobalInfo(IIO_Reader_GIF *this, unsigned __int8 *a2, unint64_t a3)
{
  GlobalGIFInfo *v5;

  v5 = (GlobalGIFInfo *)operator new();
  GlobalGIFInfo::GlobalGIFInfo(v5, a2, a3);
  return v5;
}

void sub_187FAEDB0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C4062D5A0A4);
  _Unwind_Resume(a1);
}

uint64_t ValidateKTXHeader(_DWORD *a1, unint64_t a2)
{
  unint64_t v3;
  uint64_t result;

  if (!a1 || a1[11] > 0x7Fu)
    return 4294967246;
  v3 = a1[12];
  result = 4294967246;
  if (v3 < a2)
  {
    if (a1[14] <= 0x20u)
      return 0;
    else
      return 4294967246;
  }
  return result;
}

uint64_t iioRewindCallback(void *a1)
{
  IIOImageReadSession::seek(*(IIOImageReadSession **)a1, *((_QWORD *)a1 + 1), 0);
  return 0;
}

BOOL iioWriteCallback(void *__ptr, int a2, IIOImageWriteSession *this)
{
  size_t v4;

  v4 = IIOImageWriteSession::putBytes(this, __ptr, a2);
  if (v4 != a2)
    _cg_jpeg_mem_term("iioWriteCallback", 113, "wrote %ld bytes (expected: %ld)\n", v4, a2);
  return v4 != a2;
}

double JPEGReadPlugin::JPEGReadPlugin(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  double result;

  v3 = IIOReadPlugin::IIOReadPlugin(a1, a2, a3);
  *(_QWORD *)v3 = &off_1E1BAF8A0;
  result = 0.0;
  *(_OWORD *)(v3 + 440) = 0u;
  *(_OWORD *)(v3 + 456) = 0u;
  *(_OWORD *)(v3 + 472) = 0u;
  *(_OWORD *)(v3 + 488) = 0u;
  return result;
}

uint64_t JPEGReadPlugin::loadDataFromXPCObject(JPEGReadPlugin *this, void *a2)
{
  uint64_t result;
  _OWORD *data;
  _OWORD *v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  size_t length;

  result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!(_DWORD)result)
  {
    length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_jpeg", &length);
    if (length == 56)
    {
      v6 = data;
      result = 0;
      v7 = *v6;
      v8 = v6[1];
      v9 = v6[2];
      *((_QWORD *)this + 62) = *((_QWORD *)v6 + 6);
      *((_OWORD *)this + 29) = v8;
      *((_OWORD *)this + 30) = v9;
      *((_OWORD *)this + 28) = v7;
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t JPEGReadPlugin::saveDataToXPCObject(JPEGReadPlugin *this, void *a2)
{
  uint64_t v4;

  v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!(_DWORD)v4)
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_jpeg", (char *)this + 448, 0x38uLL);
  return v4;
}

CFTypeRef JPEGReadPlugin::useNamedColorSpace(JPEGReadPlugin *this, CFTypeRef cf)
{
  const void *v4;
  CFTypeRef result;

  v4 = (const void *)*((_QWORD *)this + 55);
  if (v4)
    CFRelease(v4);
  result = CFRetain(cf);
  *((_QWORD *)this + 55) = result;
  return result;
}

void JPEGWritePlugin::JPEGWritePlugin(JPEGWritePlugin *this, IIOImageWriteSession *a2, IIOImageDestination *a3, unsigned int a4)
{
  _QWORD *v4;

  IIOWritePlugin::IIOWritePlugin(this, a2, a3, a4);
  *v4 = off_1E1BB0A28;
}

CFDataRef JPEGWritePlugin::createLumaQuantizationTableFromImageIOQuality(JPEGWritePlugin *this, float a2, int a3)
{
  float v3;
  double v4;
  uint64_t i;
  unsigned int v6;
  float v7;
  float v8;
  float v9;
  __int128 v10;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  if (a2 >= 0.9944)
  {
    *(_QWORD *)&v10 = 0x101010101010101;
    *((_QWORD *)&v10 + 1) = 0x101010101010101;
    v14 = v10;
    v15 = v10;
    v12 = v10;
    v13 = v10;
  }
  else
  {
    v3 = 0.0;
    v4 = fminf(fmaxf(a2, 0.0), 1.0);
    if (v4 < 0.9944)
      v3 = 200.0 / (v4 * 32.0 * v4 * v4 + 1.0);
    for (i = 0; i != 64; ++i)
    {
      v6 = i;
      if (a3)
        v6 = jpeg_zigzag_order[i];
      v7 = (float)((float)(v3
                         * (float)JPEGWritePlugin::createLumaQuantizationTableFromImageIOQuality(float,BOOL)::std_luma_quant_tbl[i])
                 / 100.0)
         + 0.5;
      v8 = 255.0;
      if (v7 <= 255.0)
        v8 = (float)((float)(v3
                           * (float)JPEGWritePlugin::createLumaQuantizationTableFromImageIOQuality(float,BOOL)::std_luma_quant_tbl[i])
                   / 100.0)
           + 0.5;
      if (v7 >= 1.0)
        v9 = v8;
      else
        v9 = (float)(int)i;
      *((_BYTE *)&v12 + v6) = (int)v9;
    }
  }
  return CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)&v12, 64);
}

CFDataRef JPEGWritePlugin::createChromaQuantizationTableFromImageIOQuality(JPEGWritePlugin *this, float a2, int a3)
{
  float v3;
  double v4;
  uint64_t i;
  unsigned int v6;
  float v7;
  float v8;
  float v9;
  __int128 v10;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  if (a2 >= 0.9944)
  {
    *(_QWORD *)&v10 = 0x101010101010101;
    *((_QWORD *)&v10 + 1) = 0x101010101010101;
    v14 = v10;
    v15 = v10;
    v12 = v10;
    v13 = v10;
  }
  else
  {
    v3 = 0.0;
    v4 = fminf(fmaxf(a2, 0.0), 1.0);
    if (v4 < 0.9944)
      v3 = 200.0 / (v4 * 32.0 * v4 * v4 + 1.0);
    for (i = 0; i != 64; ++i)
    {
      v6 = i;
      if (a3)
        v6 = jpeg_zigzag_order[i];
      v7 = (float)((float)(v3
                         * (float)JPEGWritePlugin::createChromaQuantizationTableFromImageIOQuality(float,BOOL)::std_chroma_quant_tbl[i])
                 / 100.0)
         + 0.5;
      v8 = 255.0;
      if (v7 <= 255.0)
        v8 = (float)((float)(v3
                           * (float)JPEGWritePlugin::createChromaQuantizationTableFromImageIOQuality(float,BOOL)::std_chroma_quant_tbl[i])
                   / 100.0)
           + 0.5;
      if (v7 >= 1.0)
        v9 = v8;
      else
        v9 = (float)(int)i;
      *((_BYTE *)&v12 + v6) = (int)v9;
    }
  }
  return CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)&v12, 64);
}

char *JPEGWritePlugin::CreateExtendedXMPMarkerData(JPEGWritePlugin *this, const __CFData *a2, unsigned int a3, const __CFData *a4, const __CFData *a5, unint64_t *a6)
{
  unsigned int v9;
  const UInt8 *BytePtr;
  size_t Length;
  char *v13;
  char *v14;
  const UInt8 *v15;
  __int128 v16;

  v9 = a2;
  BytePtr = CFDataGetBytePtr(this);
  Length = CFDataGetLength(this);
  v13 = (char *)malloc_type_calloc(1uLL, Length + 75, 0x44339367uLL);
  v14 = v13;
  if (v13)
  {
    qmemcpy(v13, "http://ns.adobe.com/xmp/extension/", 34);
    v15 = CFDataGetBytePtr(a4);
    v16 = *((_OWORD *)v15 + 1);
    *(_OWORD *)(v14 + 35) = *(_OWORD *)v15;
    *(_OWORD *)(v14 + 51) = v16;
    *(_DWORD *)(v14 + 67) = bswap32(v9);
    *(_DWORD *)(v14 + 71) = bswap32(a3);
    memcpy(v14 + 75, BytePtr, Length);
    *(_QWORD *)a5 = Length + 75;
  }
  return v14;
}

uint64_t JPEGWritePlugin::WriteIPTCData(JPEGWritePlugin *this, IIOImageWriteSession *a2, IIOImagePixelDataProvider *a3, IIODictionary *a4)
{
  const __CFDictionary *ObjectForKey;
  const __CFDictionary *v7;
  CFTypeID v8;
  IIODictionary *v9;
  unsigned int v10;
  char *v11;
  char *v12;
  __int16 __ptr;
  char __ptr_2;
  char __ptr_3;
  unint64_t v17;

  v17 = 0;
  if (a3)
  {
    ObjectForKey = IIODictionary::getObjectForKey(a3, CFSTR("{IPTC}"));
    if (ObjectForKey && (v7 = ObjectForKey, v8 = CFGetTypeID(ObjectForKey), v8 == CFDictionaryGetTypeID()))
    {
      v9 = (IIODictionary *)operator new();
      IIODictionary::IIODictionary(v9, v7);
    }
    else
    {
      v9 = 0;
    }
    if (IIODictionary::getCount(a3))
    {
      v10 = IIODictionary::containsKeyGroup(a3, CFSTR("ColorSpace"), CFSTR("{Exif}"));
      if (v10)
        LOBYTE(v10) = IIODictionary::getUint32ForKeyGroup(a3, CFSTR("ColorSpace"), CFSTR("{Exif}")) == 1;
      v11 = CreateIPTCDataFromProperties(v10, v9, &v17);
      if (v11 && v17)
      {
        v12 = v11;
        __ptr = -4609;
        __ptr_2 = (unsigned __int16)(v17 + 2) >> 8;
        __ptr_3 = v17 + 2;
        iioWriteCallback(&__ptr, 4, this);
        iioWriteCallback(v12, v17, this);
        free(v12);
      }
    }
    if (v9)
      (*(void (**)(IIODictionary *))(*(_QWORD *)v9 + 8))(v9);
  }
  return 0;
}

void sub_187FAF4E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

uint64_t JPEGWritePlugin::WriteICCData(JPEGWritePlugin *this, IIOImageWriteSession *a2, unint64_t a3, CGColorSpace *a4)
{
  CGColorSpace *SourceGeomColorSpace;
  CGImage *Ref;
  CGColorRenderingIntent RenderingIntent;
  __CFData *v9;
  const __CFData *v10;
  UInt8 *BytePtr;
  CFIndex Length;
  unint64_t v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  __int16 __ptr;
  char __ptr_2;
  char __ptr_3;
  _WORD v21[8];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  strcpy((char *)v21, "ICC_PROFILE");
  v21[6] = 0;
  if ((unint64_t)a2 | a3)
  {
    SourceGeomColorSpace = (CGColorSpace *)a3;
    if (!a3)
      SourceGeomColorSpace = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(a2);
    if (!IIO_CGColorSpaceNameMatchesName(SourceGeomColorSpace, (const __CFString *)*MEMORY[0x1E0C9DA10]))
    {
      if (a2)
      {
        Ref = (CGImage *)IIOImageSource::imageReadRef(a2);
        RenderingIntent = CGImageGetRenderingIntent(Ref);
      }
      else
      {
        RenderingIntent = kCGRenderingIntentDefault;
      }
      v9 = CGColorSpaceCopyData(SourceGeomColorSpace, RenderingIntent);
      if (v9)
      {
        v10 = v9;
        BytePtr = (UInt8 *)CFDataGetBytePtr(v9);
        Length = CFDataGetLength(v10);
        if (BytePtr)
        {
          v13 = Length;
          if (Length)
          {
            v14 = ((unint64_t)(Length + 65518) * (unsigned __int128)0x11012113324657uLL) >> 64;
            HIBYTE(v21[6]) = (v14 + ((Length + 65518 - v14) >> 1)) >> 15;
            LOBYTE(v21[6]) = 1;
            if (HIBYTE(v21[6]))
            {
              do
              {
                if (v13 >= 0xFFEF)
                  v15 = 65519;
                else
                  v15 = v13;
                __ptr = -7425;
                __ptr_2 = (unsigned __int16)(v15 + 16) >> 8;
                __ptr_3 = v15 + 16;
                iioWriteCallback(&__ptr, 4, this);
                iioWriteCallback(v21, 14, this);
                v13 -= v15;
                iioWriteCallback(BytePtr, v15, this);
                BytePtr += v15;
                v16 = LOBYTE(v21[6]);
                ++LOBYTE(v21[6]);
              }
              while (v16 < HIBYTE(v21[6]));
            }
          }
        }
        CFRelease(v10);
      }
    }
  }
  return 0;
}

uint64_t JPEGWritePlugin::WriteExtendedXMPData(JPEGWritePlugin *this, IIOImageWriteSession *a2, IIODictionary *a3)
{
  const __CFDictionary *ObjectForKey;
  const void *v6;
  unint64_t *v7;
  JPEGWritePlugin *v8;
  CFIndex Length;
  CFIndex v10;
  char *XMPMarkerData;
  char *v12;
  int v13;
  CFIndex v14;
  const UInt8 *BytePtr;
  const UInt8 *v16;
  CFIndex v17;
  const __CFAllocator *v18;
  uint64_t v19;
  CFIndex v20;
  JPEGWritePlugin *v21;
  unint64_t *v22;
  char *ExtendedXMPMarkerData;
  char *v24;
  int v25;
  const void *v27;
  uint64_t v28;
  uint64_t v29;
  int __ptr;
  CFTypeRef v31;
  CFTypeRef cf;
  CFDataRef theData;

  cf = 0;
  theData = 0;
  v31 = 0;
  if (this && a2)
  {
    ObjectForKey = IIODictionary::getObjectForKey(a2, CFSTR("{MetaData}"));
    if (ObjectForKey)
    {
      v6 = ObjectForKey;
      CFRetain(ObjectForKey);
    }
    else
    {
      v6 = (const void *)CGImageMetadataCreateFromLegacyProps(a2);
    }
    if (CGImageMetadataCreateExtendedXMPWithEXIFFiltered((const CGImageMetadata *)v6, &theData, (CFDataRef *)&cf, (CFDataRef *)&v31, 0))
    {
      v8 = theData;
      if (theData)
      {
        Length = CFDataGetLength(theData);
        v8 = theData;
        if (Length >= 65501)
        {
          v10 = CFDataGetLength(theData);
          LogError("WriteExtendedXMPData", 646, "xmpData size exceeds 64KB limit (%ld)\n", v10);
          CFRelease(theData);
          theData = 0;
          if (v6)
            CFRelease(v6);
          if (cf)
          {
            CFRelease(cf);
            cf = 0;
          }
          goto LABEL_32;
        }
      }
      v27 = v6;
      __ptr = 57855;
      v29 = 0;
      XMPMarkerData = JPEGWritePlugin::CreateXMPMarkerData(v8, (const __CFData *)&v29, v7);
      if (XMPMarkerData)
      {
        v12 = XMPMarkerData;
        v13 = v29;
        HIWORD(__ptr) = bswap32(v29 + 2) >> 16;
        iioWriteCallback(&__ptr, 4, this);
        iioWriteCallback(v12, v13, this);
        free(v12);
      }
      if (cf)
      {
        if (v31)
        {
          v14 = CFDataGetLength((CFDataRef)cf);
          BytePtr = CFDataGetBytePtr((CFDataRef)cf);
          if (v14 >= 1)
          {
            v16 = BytePtr;
            v17 = 0;
            v18 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
            v19 = v14;
            do
            {
              if (v19 >= 65000)
                v20 = 65000;
              else
                v20 = v19;
              v21 = CFDataCreate(v18, &v16[v17], v20);
              v28 = 0;
              ExtendedXMPMarkerData = JPEGWritePlugin::CreateExtendedXMPMarkerData(v21, (const __CFData *)v14, v17, (const __CFData *)v31, (const __CFData *)&v28, v22);
              if (ExtendedXMPMarkerData)
              {
                v24 = ExtendedXMPMarkerData;
                v25 = v28;
                HIWORD(__ptr) = bswap32(v28 + 2) >> 16;
                iioWriteCallback(&__ptr, 4, this);
                iioWriteCallback(v24, v25, this);
                free(v24);
              }
              CFRelease(v21);
              v17 += 65000;
              v19 -= 65000;
            }
            while (v17 < v14);
          }
        }
      }
      v6 = v27;
    }
    if (v6)
      CFRelease(v6);
  }
  if (theData)
    CFRelease(theData);
  if (cf)
    CFRelease(cf);
LABEL_32:
  if (v31)
    CFRelease(v31);
  return 0;
}

char *JPEGWritePlugin::CreateXMPMarkerData(JPEGWritePlugin *this, const __CFData *a2, unint64_t *a3)
{
  size_t v5;
  char *v6;
  char *v7;
  const UInt8 *BytePtr;
  size_t Length;

  v5 = CFDataGetLength(this) + 29;
  v6 = (char *)malloc_type_calloc(1uLL, v5, 0x718DBCD5uLL);
  v7 = v6;
  if (v6)
  {
    qmemcpy(v6, "http://ns.adobe.com/xap/1.0/", 28);
    BytePtr = CFDataGetBytePtr(this);
    Length = CFDataGetLength(this);
    memcpy(v7 + 29, BytePtr, Length);
    *(_QWORD *)a2 = v5;
  }
  return v7;
}

uint64_t JPEGWritePlugin::getEncodingHorizontalSubsamplingFactor(JPEGWritePlugin *this, IIODictionary *a2)
{
  float ImageIOCompressionQuality;
  const __CFString *v4;
  uint64_t result;
  unsigned int v6;

  ImageIOCompressionQuality = JPEGWritePlugin::GetImageIOCompressionQuality(a2, a2);
  v4 = CFSTR("ChromaSubsamplingX");
  if (IIODictionary::containsKeyGroup(a2, CFSTR("ChromaSubsamplingX"), CFSTR("{JPEG}")))
  {
    LODWORD(result) = IIODictionary::getUint32ForKeyGroup(a2, CFSTR("ChromaSubsamplingX"), CFSTR("{JPEG}"));
  }
  else if (IIODictionary::containsKey(a2, CFSTR("ChromaSubsamplingX"))
         || (v4 = CFSTR("kCGImageDestinationChromaSubSamplingX"),
             LODWORD(result) = IIODictionary::containsKey(a2, CFSTR("kCGImageDestinationChromaSubSamplingX")), (_DWORD)result))
  {
    LODWORD(result) = IIODictionary::getUint32ForKey(a2, v4);
  }
  if (ImageIOCompressionQuality >= 0.9944)
    v6 = 1;
  else
    v6 = 2;
  if ((result - 1) >= 2)
    return v6;
  else
    return result;
}

float JPEGWritePlugin::GetImageIOCompressionQuality(JPEGWritePlugin *this, IIODictionary *a2)
{
  unsigned int v3;
  float result;

  v3 = IIODictionary::containsKey(this, CFSTR("kCGImageDestinationLossyCompressionQuality"));
  result = 0.75;
  if (v3)
    result = IIODictionary::getFloatForKey(this, CFSTR("kCGImageDestinationLossyCompressionQuality"));
  if (result > 1.0)
    result = 1.0;
  if (result < 0.0)
    return 0.0;
  return result;
}

uint64_t JPEGWritePlugin::getEncodingVerticalSubsamplingFactor(JPEGWritePlugin *this, IIODictionary *a2)
{
  float ImageIOCompressionQuality;
  const __CFString *v4;
  uint64_t result;
  unsigned int v6;

  ImageIOCompressionQuality = JPEGWritePlugin::GetImageIOCompressionQuality(a2, a2);
  v4 = CFSTR("ChromaSubsamplingY");
  if (IIODictionary::containsKeyGroup(a2, CFSTR("ChromaSubsamplingY"), CFSTR("{JPEG}")))
  {
    LODWORD(result) = IIODictionary::getUint32ForKeyGroup(a2, CFSTR("ChromaSubsamplingY"), CFSTR("{JPEG}"));
  }
  else if (IIODictionary::containsKey(a2, CFSTR("ChromaSubsamplingY"))
         || (v4 = CFSTR("kCGImageDestinationChromaSubSamplingY"),
             LODWORD(result) = IIODictionary::containsKey(a2, CFSTR("kCGImageDestinationChromaSubSamplingY")), (_DWORD)result))
  {
    LODWORD(result) = IIODictionary::getUint32ForKey(a2, v4);
  }
  if (ImageIOCompressionQuality >= 0.9944)
    v6 = 1;
  else
    v6 = 2;
  if ((result - 1) >= 2)
    return v6;
  else
    return result;
}

uint64_t JPEGWritePlugin::JPEGQualityFromLossyCompressionQuality(JPEGWritePlugin *this, float a2)
{
  float v2;
  double v3;
  double v4;
  unsigned int v5;

  v2 = 0.0;
  v3 = fminf(fmaxf(a2, 0.0), 1.0);
  if (v3 < 0.9944 && (v2 = 200.0 / (v3 * 32.0 * v3 * v3 + 1.0), v2 >= 100.0))
    v4 = 5000.0 / v2;
  else
    v4 = (200.0 - v2) * 0.5;
  v5 = (int)v4 & ~((int)v4 >> 31);
  if (v5 >= 0x64)
    return 100;
  else
    return v5;
}

BOOL CGImagePluginInitThumbJPEGAtOffsetWithOptions(uint64_t a1, IIOImageReadSession *a2, uint64_t a3, int a4, const __CFDictionary *a5)
{
  const __CFString *ObjectForKey;
  IIO_ReaderHandler *v11;
  IIO_ReaderHandler *v12;
  IIO_Reader *v13;
  IIODictionary *Options;
  IIO_Reader_HEIF *v15;
  IIOReadPlugin *v16;
  _BOOL8 v17;
  _QWORD v19[3];

  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImagePluginInitThumbJPEGAtOffsetWithOptions", 0, 0, -1, a5);
  memset(v19, 0, sizeof(v19));
  IIODictionary::IIODictionary((IIODictionary *)v19, a5);
  if (IIODictionary::containsKey((IIODictionary *)v19, CFSTR("kCGImageSourceCreateThumbnailFromImageAlways")))IIODictionary::getBoolForKey((IIODictionary *)v19, CFSTR("kCGImageSourceCreateThumbnailFromImageAlways"));
  if (IIODictionary::containsKey((IIODictionary *)v19, CFSTR("kCGImageSourceCreateThumbnailFromImageIfAbsent")))IIODictionary::getBoolForKey((IIODictionary *)v19, CFSTR("kCGImageSourceCreateThumbnailFromImageIfAbsent"));
  if (IIODictionary::containsKey((IIODictionary *)v19, CFSTR("kCGImageSourceCreateThumbnailWithTransform")))IIODictionary::getBoolForKey((IIODictionary *)v19, CFSTR("kCGImageSourceCreateThumbnailWithTransform"));
  IIODictionary::getUint32ForKey((IIODictionary *)v19, CFSTR("Orientation"));
  IIODictionary::getUint32ForKeyGroup((IIODictionary *)v19, CFSTR("Orientation"), CFSTR("{TIFF}"));
  if (IIODictionary::containsKey((IIODictionary *)v19, CFSTR("kCGImageSourceSubsampleFactor")))
    IIODictionary::getUint32ForKey((IIODictionary *)v19, CFSTR("kCGImageSourceSubsampleFactor"));
  if (IIODictionary::containsKey((IIODictionary *)v19, CFSTR("kCGImageSourceDecodeRequest")))
  {
    ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey((IIODictionary *)v19, CFSTR("kCGImageSourceDecodeRequest"));
    if (CFStringCompare(ObjectForKey, CFSTR("kCGImageSourceDecodeToHDR"), 0))
      CFStringCompare(ObjectForKey, CFSTR("kCGImageSourceDecodeToSDR"), 0);
    if (IIODictionary::containsKeyGroup((IIODictionary *)v19, CFSTR("kCGGenerateFlexGTC"), CFSTR("kCGImageSourceDecodeRequestOptions")))IIODictionary::getBoolForKeyGroup((IIODictionary *)v19, CFSTR("kCGGenerateFlexGTC"), CFSTR("kCGImageSourceDecodeRequestOptions"));
  }
  if (!IIODictionary::getUint32ForKey((IIODictionary *)v19, CFSTR("kCGImageSourceThumbnailMaxPixelSize")))
    IIODictionary::getUint32ForKey((IIODictionary *)v19, CFSTR("kCGImageDestinationImageMaxPixelSize"));
  kdebug_trace();
  v11 = IIODictionary::getObjectForKey((IIODictionary *)v19, CFSTR("NamedColorSpace"));
  v12 = v11;
  if (a1)
    v13 = *(IIO_Reader **)(a1 + 24);
  else
    v13 = 0;
  if (IIO_ReaderHandler::UseAppleJPEG(v11))
  {
    if (v13
      && (Options = (IIODictionary *)IIOImagePlus::getOptions(v13)) != 0
      && IIODictionary::containsKey(Options, CFSTR("kCGImageSourceDecodeRequest")))
    {
      v15 = (IIO_Reader_HEIF *)IIO_Reader::testHeaderSize(v13);
      if (v15)
        IIO_Reader_HEIF::CreateGlobalHEIFInfoIfNeeded(v15, a2, a3);
      v16 = (IIOReadPlugin *)operator new();
      HEIFReadPlugin::HEIFReadPlugin((uint64_t)v16, a1, 0, (uint64_t)a2, a3, 1, 1246774599);
    }
    else
    {
      v16 = (IIOReadPlugin *)operator new();
      AppleJPEGReadPlugin::AppleJPEGReadPlugin((uint64_t)v16, a1, 0, (uint64_t)a2, a3, 0, 1920231541, 0, 1246774599);
    }
  }
  else
  {
    v16 = (IIOReadPlugin *)operator new();
    LibJPEGReadPlugin::LibJPEGReadPlugin((uint64_t)v16, a1, 0, (uint64_t)a2, a3, 0, 1920231541, 0, 1279938631);
  }
  IIOReadPlugin::setDecodeMode((uint64_t)v16, 2);
  IIOReadPlugin::setDestMaxPixelSize((uint64_t)v16, a4);
  if (v12)
    (*(void (**)(IIOReadPlugin *, IIO_ReaderHandler *))(*(_QWORD *)v16 + 264))(v16, v12);
  v17 = IIOReadPlugin::callInitialize(v16) == 0;
  kdebug_trace();
  IIODictionary::~IIODictionary((IIODictionary *)v19);
  return v17;
}

void sub_187FB0120(void *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40DBAD00F1);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187FB00E0);
}

void sub_187FB019C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

BOOL CGImagePluginInitThumbJPEGAtOffset(uint64_t a1, IIOImageReadSession *a2, uint64_t a3, int a4)
{
  return CGImagePluginInitThumbJPEGAtOffsetWithOptions(a1, a2, a3, a4, 0);
}

BOOL CGImagePluginInitJPEGAtOffset(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, int a7, uint64_t a8)
{
  IIO_ReaderHandler *v16;
  char v17;
  char v18;
  IIOReadPlugin *v19;
  int v20;
  _BOOL8 v21;
  IIOReadPlugin *v23;

  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14)
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImagePluginInitJPEGAtOffset", 0, 0, -1, 0);
  v16 = (IIO_ReaderHandler *)kdebug_trace();
  if (a6)
    v17 = 3;
  else
    v17 = 1;
  if (a5)
    v18 = 2;
  else
    v18 = v17;
  if (!IIO_ReaderHandler::UseAppleJPEG(v16) || a7 == 1095389255 || a7 == 1279869514)
  {
    v19 = (IIOReadPlugin *)operator new();
    LibJPEGReadPlugin::LibJPEGReadPlugin((uint64_t)v19, a1, a2, a3, a4, 0, a7, a8, 1279938631);
    IIOReadPlugin::setDecodeMode((uint64_t)v19, v18);
    IIOReadPlugin::setDestMaxPixelSize((uint64_t)v19, a6);
    v20 = IIOReadPlugin::callInitialize(v19);
  }
  else
  {
    v23 = (IIOReadPlugin *)operator new();
    AppleJPEGReadPlugin::AppleJPEGReadPlugin((uint64_t)v23, a1, a2, a3, a4, 0, a7, a8, 1246774599);
    IIOReadPlugin::setDecodeMode((uint64_t)v23, v18);
    IIOReadPlugin::setDestMaxPixelSize((uint64_t)v23, a6);
    v20 = IIOReadPlugin::callInitialize(v23);
  }
  v21 = v20 == 0;
  kdebug_trace();
  return v21;
}

void sub_187FB03B4(void *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40C020E1A5);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187FB030CLL);
}

void IIOPixelProvider::IIOPixelProvider(IIOPixelProvider *this, CGImageRef image, const vImage_CGImageFormat *a3, IIODictionary *a4)
{
  uint64_t v7;
  __int128 v8;
  IIODictionary *v9;
  IIODictionary *v10;
  const __CFDictionary *v11;

  *(_QWORD *)this = &off_1E1BB0DC8;
  *((_QWORD *)this + 1) = image;
  *((_DWORD *)this + 13) = CGImageGetWidth(image);
  *((_DWORD *)this + 14) = CGImageGetHeight(*((CGImageRef *)this + 1));
  v7 = *(_QWORD *)&a3->renderingIntent;
  v8 = *(_OWORD *)&a3->bitmapInfo;
  *((_OWORD *)this + 7) = *(_OWORD *)&a3->bitsPerComponent;
  *((_OWORD *)this + 8) = v8;
  *((_QWORD *)this + 18) = v7;
  v9 = (IIODictionary *)operator new();
  v10 = v9;
  if (a4)
    v11 = (const __CFDictionary *)*((_QWORD *)a4 + 1);
  else
    v11 = 0;
  IIODictionary::IIODictionary(v9, v11);
  *((_QWORD *)this + 8) = v10;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_DWORD *)this + 12) = 538976288;
  *((_WORD *)this + 89) = 0;
  *((_DWORD *)this + 43) = 0;
  *((_QWORD *)this + 19) = 0;
  __asm { FMOV            V0.2D, #1.0 }
  *(_OWORD *)((char *)this + 184) = _Q0;
  *(_OWORD *)((char *)this + 200) = _Q0;
  *((_QWORD *)this + 27) = 0x3FF0000000000000;
  *((_BYTE *)this + 176) = IIODictionary::getBoolForKey(v10, CFSTR("UseIndexedColorIfAvailable"));
  *((_BYTE *)this + 177) = IIODictionary::getBoolForKey(*((IIODictionary **)this + 8), CFSTR("UseIOSurfaceIfAvailable"));
  *((_DWORD *)this + 43) = IIODictionary::getUint32ForKey(*((IIODictionary **)this + 8), CFSTR("DestinationRowBytes"));
  IIOPixelProvider::setupSrcFormat(this);
}

void sub_187FB052C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

const char *IIOPixelProvider::setupSrcFormat(IIOPixelProvider *this)
{
  uint64_t ImageProvider;
  int v3;
  BOOL v4;
  const char *result;
  unsigned int v6;
  unsigned int v8;

  ImageProvider = CGImageGetImageProvider();
  *((_QWORD *)this + 2) = ImageProvider;
  if (ImageProvider)
  {
    v3 = IIO_CGImageWrapsIOSurface(*((_QWORD *)this + 1), 1);
    if (*((_BYTE *)this + 177))
      v4 = v3 == 0;
    else
      v4 = 1;
    if (!v4)
    {
      *((_DWORD *)this + 56) = 1;
      result = (const char *)IIOPixelProvider::setupSrcFormatUsingIOSurface(this);
      goto LABEL_10;
    }
    *((_QWORD *)this + 2) = 0;
    *((_QWORD *)this + 3) = CGImageGetDataProvider(*((CGImageRef *)this + 1));
    *((_DWORD *)this + 56) = 3;
  }
  else
  {
    *((_DWORD *)this + 56) = 3;
    *((_QWORD *)this + 3) = CGImageGetDataProvider(*((CGImageRef *)this + 1));
  }
  result = (const char *)IIOPixelProvider::setupSrcFormatUsingDataProvider(this);
LABEL_10:
  v6 = *((_DWORD *)this + 43);
  if (v6 <= (*((_DWORD *)this + 13) * *((_DWORD *)this + 29)) >> 3 || v6 == 0)
    v8 = (*((_DWORD *)this + 13) * *((_DWORD *)this + 29)) >> 3;
  else
    v8 = *((_DWORD *)this + 43);
  *((_DWORD *)this + 41) = v8;
  if (!v8)
    return LogError("setupSrcFormat", 111, "*** invalid _dstRowBytes (0)\n");
  return result;
}

void IIOPixelProvider::~IIOPixelProvider(IIOPixelProvider *this)
{
  const void *v2;
  uint64_t v3;
  vImageConverter *v4;

  *(_QWORD *)this = &off_1E1BB0DC8;
  if (*((_QWORD *)this + 4))
    CGAccessSessionRelease();
  v2 = (const void *)*((_QWORD *)this + 5);
  if (v2)
    CFRelease(v2);
  v3 = *((_QWORD *)this + 8);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = (vImageConverter *)*((_QWORD *)this + 19);
  if (v4)
    vImageConverter_Release(v4);
}

{
  IIOPixelProvider::~IIOPixelProvider(this);
  JUMPOUT(0x18D761C30);
}

size_t IIOPixelProvider::setupSrcFormatUsingDataProvider(IIOPixelProvider *this)
{
  size_t result;

  *((_DWORD *)this + 18) = CGImageGetBitsPerComponent(*((CGImageRef *)this + 1));
  *((_DWORD *)this + 19) = CGImageGetBitsPerPixel(*((CGImageRef *)this + 1));
  *((_QWORD *)this + 10) = CGImageGetColorSpace(*((CGImageRef *)this + 1));
  *((_DWORD *)this + 22) = CGImageGetBitmapInfo(*((CGImageRef *)this + 1));
  *((_QWORD *)this + 12) = CGImageGetDecode(*((CGImageRef *)this + 1));
  *((_DWORD *)this + 26) = CGImageGetRenderingIntent(*((CGImageRef *)this + 1));
  *((_DWORD *)this + 23) = 0;
  *((_DWORD *)this + 42) = *((_DWORD *)this + 19) / *((_DWORD *)this + 18);
  result = CGImageGetBytesPerRow(*((CGImageRef *)this + 1));
  *((_DWORD *)this + 40) = result;
  return result;
}

uint64_t IIOPixelProvider::setupSrcFormatUsingIOSurface(IIOPixelProvider *this)
{
  __IOSurface *v2;
  uint64_t result;

  v2 = (__IOSurface *)CGImageProviderCopyIOSurface();
  *((_QWORD *)this + 5) = v2;
  if (!v2)
    return IIOPixelProvider::setupSrcFormatUsingImageProvider(this);
  result = IOSurfaceGetPixelFormat(v2);
  *((_DWORD *)this + 12) = result;
  return result;
}

uint64_t IIOPixelProvider::setupSrcFormatUsingImageProvider(IIOPixelProvider *this)
{
  unsigned int v2;
  uint64_t result;

  v2 = CGImageProviderGetComponentType() - 1;
  if (v2 <= 4)
    *((_DWORD *)this + 18) = *(_DWORD *)&asc_1882105C8[4 * v2];
  *((_DWORD *)this + 19) = 8 * CGImageProviderGetPixelSize();
  *((_QWORD *)this + 10) = CGImageProviderGetColorSpace();
  *((_DWORD *)this + 22) = CGImageGetBitmapInfo(*((CGImageRef *)this + 1));
  *((_QWORD *)this + 12) = CGImageGetDecode(*((CGImageRef *)this + 1));
  result = CGImageGetRenderingIntent(*((CGImageRef *)this + 1));
  *((_DWORD *)this + 26) = result;
  *((_DWORD *)this + 23) = 0;
  *((_DWORD *)this + 42) = *((_DWORD *)this + 19) / *((_DWORD *)this + 18);
  return result;
}

__n128 IIOPixelProvider::createImageConverter(IIOPixelProvider *this)
{
  vImageConverterRef v2;
  __n128 result;
  BOOL v4;
  const char *v5;
  vImage_Error error;

  error = 0;
  v2 = vImageConverter_CreateWithCGImageFormat((const vImage_CGImageFormat *)((char *)this + 72), (const vImage_CGImageFormat *)((char *)this + 112), (const CGFloat *)this + 23, 0x100u, &error);
  *((_QWORD *)this + 19) = v2;
  if (error)
    v4 = 1;
  else
    v4 = v2 == 0;
  if (v4)
  {
    v5 = IIO_vImageErrorString(error);
    return _cg_jpeg_mem_term("createImageConverter", 194, "*** could not create vImageConverter: '%s'\n", v5);
  }
  return result;
}

uint64_t IIOPixelProvider::iterateOverImage(IIOPixelProvider *this, uint64_t a2, unsigned int a3, int a4, uint64_t a5)
{
  unsigned int v5;
  unsigned int v6;
  uint64_t v8;
  vImagePixelCount v10;
  uint64_t v11;
  double v13;
  void *v14;
  vImagePixelCount v15;
  int v16;
  void *v17;
  vImagePixelCount v18;
  uint64_t v19;
  vImage_Buffer *p_srcs;
  vImage_Error v21;
  const char *v22;
  vImage_Buffer dests;
  vImage_Buffer srcs;
  char v26;

  v26 = 0;
  v5 = *((_DWORD *)this + 14);
  if (v5 >= a3)
    v6 = a3;
  else
    v6 = *((_DWORD *)this + 14);
  if (v5 < a2 || v6 < a2)
    return 4294967246;
  LODWORD(v10) = a4;
  v11 = a2;
  srcs.height = 0;
  dests.height = 0;
  if (!*((_QWORD *)this + 19))
  {
    *(_QWORD *)&v13 = IIOPixelProvider::createImageConverter(this).n128_u64[0];
    if (!*((_QWORD *)this + 19))
    {
      ImageIOLog("*** could not create vImageConverter\n", v13);
      return 4294967246;
    }
  }
  v14 = malloc_type_malloc((*((_DWORD *)this + 40) * v10), 0xC35F1C7uLL);
  v15 = *((unsigned int *)this + 13);
  srcs.data = v14;
  srcs.width = v15;
  v16 = *((_DWORD *)this + 41);
  srcs.rowBytes = *((unsigned int *)this + 40);
  v17 = malloc_type_malloc((v16 * v10), 0xCE95637BuLL);
  v18 = *((unsigned int *)this + 13);
  dests.data = v17;
  dests.width = v18;
  dests.rowBytes = *((unsigned int *)this + 41);
  if (v6 <= v11)
  {
    v8 = 4294967246;
    goto LABEL_26;
  }
  while (1)
  {
    if ((int)v11 + (int)v10 <= v6)
      v10 = v10;
    else
      v10 = v6 - v11;
    srcs.height = v10;
    v19 = IIOPixelProvider::fillSourceBuffer(this, v11, &srcs);
    if ((_DWORD)v19)
    {
      v8 = v19;
      _cg_jpeg_mem_term("iterateOverImage", 257, "*** ERROR: fillSourceBuffer failed [%d]\n", v19);
      goto LABEL_26;
    }
    if (*((_BYTE *)this + 178))
    {
      p_srcs = &srcs;
      goto LABEL_19;
    }
    dests.height = v10;
    p_srcs = &dests;
    v21 = iio_vImageConvert_AnyToAny(*((vImageConverterRef *)this + 19), &srcs, &dests, 0, 0x100u);
    v8 = v21;
    if ((_DWORD)v21)
      break;
LABEL_19:
    (*(void (**)(uint64_t, uint64_t, vImage_Buffer *, char *))(a5 + 16))(a5, v11, p_srcs, &v26);
    v8 = 0;
    if (!v26)
    {
      v11 = (v10 + v11);
      if (v11 < v6)
        continue;
    }
    goto LABEL_26;
  }
  v22 = IIO_vImageErrorString((int)v21);
  _cg_jpeg_mem_term("iterateOverImage", 274, "*** ERROR: vImageConvert_AnyToAny failed: '%s'\n", v22);
LABEL_26:
  if (srcs.data)
    free(srcs.data);
  if (dests.data)
    free(dests.data);
  return v8;
}

uint64_t IIOPixelProvider::fillSourceBuffer(IIOPixelProvider *this, int a2, vImage_Buffer *a3)
{
  uint64_t result;
  uint64_t v7;
  size_t v8;

  if (*((_DWORD *)this + 56) != 3)
    return 0;
  if (!*((_QWORD *)this + 4))
    *((_QWORD *)this + 4) = CGAccessSessionCreate();
  result = CGAccessSessionRewind();
  if ((_DWORD)result)
  {
    v7 = (*((_DWORD *)this + 40) * a2);
    if (CGAccessSessionSkipForward() == v7)
    {
      v8 = a3->rowBytes * a3->height;
      if (v8 == CGAccessSessionGetBytes())
        return 0;
      else
        return 4294967257;
    }
    return 0;
  }
  return result;
}

uint64_t IIOPixelProvider::enableIndexColorPassThrough(IIOPixelProvider *this)
{
  *((_BYTE *)this + 178) = 0;
  return 0;
}

uint64_t IIO_Reader_ETC::createReadPlugin(IIO_Reader *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = operator new();
  v5 = IIO_Reader::osType(a1);
  ETCReadPlugin::ETCReadPlugin(v4, a2, v5);
  return v4;
}

void sub_187FB0B94(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40B4801AEALL);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_ETC::createReadPlugin(IIO_Reader *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;

  v8 = operator new();
  v9 = IIO_Reader::osType(a1);
  ETCReadPlugin::ETCReadPlugin(v8, a2, a3, a4, v9);
  return v8;
}

void sub_187FB0C30(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40B4801AEALL);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_ETC::getImageCount(IIO_Reader_ETC *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  if (a5)
    *a5 = 1;
  return 0;
}

uint64_t IIO_Reader_ETC::updateSourceProperties(IIO_Reader_ETC *this, IIOImageReadSession *a2, IIODictionary *a3, IIODictionary *a4, IIODictionary *a5, CGImageSourceStatus *a6)
{
  return 0;
}

double TIFFReadPlugin::TIFFReadPlugin(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  double result;

  v3 = IIOReadPlugin::IIOReadPlugin(a1, a2, a3);
  *(_QWORD *)v3 = &off_1E1BAFD08;
  result = 0.0;
  *(_OWORD *)(v3 + 440) = 0u;
  *(_OWORD *)(v3 + 456) = 0u;
  *(_OWORD *)(v3 + 472) = 0u;
  *(_OWORD *)(v3 + 488) = 0u;
  *(_OWORD *)(v3 + 504) = 0u;
  *(_OWORD *)(v3 + 520) = 0u;
  *(_OWORD *)(v3 + 536) = 0u;
  *(_OWORD *)(v3 + 552) = 0u;
  return result;
}

uint64_t TIFFReadPlugin::loadDataFromXPCObject(TIFFReadPlugin *this, void *a2)
{
  uint64_t result;
  __int128 *data;
  __int128 *v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  size_t length;

  result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!(_DWORD)result)
  {
    length = 0;
    data = (__int128 *)xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_tiff", &length);
    if (length == 128)
    {
      v6 = data;
      result = 0;
      v7 = v6[3];
      v9 = *v6;
      v8 = v6[1];
      *(_OWORD *)((char *)this + 472) = v6[2];
      *(_OWORD *)((char *)this + 488) = v7;
      *(_OWORD *)((char *)this + 440) = v9;
      *(_OWORD *)((char *)this + 456) = v8;
      v10 = v6[4];
      v11 = v6[5];
      v12 = v6[7];
      *(_OWORD *)((char *)this + 536) = v6[6];
      *(_OWORD *)((char *)this + 552) = v12;
      *(_OWORD *)((char *)this + 504) = v10;
      *(_OWORD *)((char *)this + 520) = v11;
      *((_QWORD *)this + 55) = 0;
    }
    else
    {
      _cg_jpeg_mem_term("loadDataFromXPCObject", 192, "*** ERROR: failed to load 'IMAGEIO_PLUGIN_DATA_TIFF'\n");
      return 4294967246;
    }
  }
  return result;
}

uint64_t TIFFReadPlugin::saveDataToXPCObject(TIFFReadPlugin *this, void *a2)
{
  uint64_t v4;

  v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!(_DWORD)v4)
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_tiff", (char *)this + 440, 0x80uLL);
  return v4;
}

BOOL TIFFReadPlugin::initPhotoshopThumbnail(TIFFReadPlugin *this, unint64_t a2, int64_t size, IIODictionary *a4)
{
  unsigned __int8 *v8;
  _BOOL8 inited;
  unint64_t v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  uint64_t v16;
  _BYTE v17[16];
  void *value;

  v8 = (unsigned __int8 *)malloc_type_malloc(size, 0xC368B41BuLL);
  if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v8, a2, size) == size && size >= 6)
  {
    v12 = (unint64_t)&v8[size];
    v13 = v8 + 5;
    v14 = v8;
    while (!strncmp((const char *)v14, "8BIM", 4uLL) && (unint64_t)(v14 + 12) < v12)
    {
      if ((*v13 | (v14[4] << 8)) == 0x40C)
      {
        if ((unint64_t)(v14 + 42) < v12 && v14[40] == 255 && v14[41] == 216)
        {
          v16 = v14 + 40 - v8 + a2;
          inited = CGImagePluginInitJPEGAtOffset(*((_QWORD *)this + 1), 0, v16, (v14[32] << 24) | ((unint64_t)v14[33] << 16) | ((unint64_t)v14[34] << 8) | v14[35], 1, 5000, 1953785973, 0);
          IIONumber::IIONumber((IIONumber *)v17, 1246774599);
          IIODictionary::setObjectForKey(a4, value, CFSTR("NEW_PLUGIN_ostype"));
          IIONumber::~IIONumber((IIONumber *)v17);
          IIONumber::IIONumber((IIONumber *)v17, v16);
          IIODictionary::setObjectForKey(a4, value, CFSTR("NEW_PLUGIN_dataOffset"));
          IIONumber::~IIONumber((IIONumber *)v17);
          goto LABEL_7;
        }
        break;
      }
      inited = 0;
      v14 += _byteswap_ulong(*((_DWORD *)v14 + 2)) + (v14[11] & 1) + 12;
      v13 = v14 + 5;
      if ((unint64_t)(v14 + 5) >= v12)
        goto LABEL_7;
    }
  }
  inited = 0;
LABEL_7:
  if (v8)
    free(v8);
  return inited;
}

void sub_187FB0FA0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t TIFFReadPlugin::decodeSubsampled(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;
  unsigned int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  __int16 v10;
  uint64_t v11;
  __int16 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  unsigned __int8 *v22;
  int v23;
  uint64_t v24;
  size_t v25;
  int v26;
  size_t v27;
  uint64_t v28;
  unsigned __int8 *v29;
  unsigned __int8 *v30;
  int v31;
  size_t v32;
  uint64_t v33;
  unsigned __int8 *v34;
  unsigned __int8 *v35;
  int v36;
  unsigned __int8 *v37;
  unsigned __int8 *v38;
  unsigned int v40;
  uint64_t v41;
  unsigned __int8 *v42;
  unsigned int v43;
  uint64_t v44;
  unsigned int v45;
  unsigned int v47[2];
  _OWORD v48[3];
  unsigned int v49;

  v3 = *(unsigned int *)(a1 + 264);
  if (*(_QWORD *)(a1 + 360) < v3)
    v3 = *(_QWORD *)(a1 + 360);
  v4 = *(unsigned __int16 *)(a1 + 316);
  if (!*(_WORD *)(a1 + 316))
    return 4294967246;
  *(_QWORD *)v47 = *(unsigned int *)(a1 + 236);
  if (v3 <= v4)
  {
    v7 = 2 * v4;
    v6 = 2;
  }
  else
  {
    v6 = v3 / v4;
    v7 = v6 * v4;
  }
  v8 = *(unsigned __int16 *)(a1 + 304);
  v41 = *a3;
  v49 = v6;
  v42 = (unsigned __int8 *)malloc_type_malloc(v47[0] * (unint64_t)v7, 0xDB5FED4FuLL);
  if (!v42)
    return 4294967246;
  v9 = *(unsigned __int16 *)(a1 + 308);
  if (v9 == 4)
  {
    if (*(_WORD *)(a1 + 306) == 32)
    {
      if (*(_BYTE *)(a1 + 405))
        v10 = 1;
      else
        v10 = 3;
    }
    else
    {
      v10 = 1;
    }
  }
  else
  {
    v10 = 0;
  }
  memset(v48, 0, sizeof(v48));
  if (*(unsigned __int16 *)(a1 + 244) >= v9)
    v12 = v9;
  else
    v12 = *(_WORD *)(a1 + 244);
  IIOSubsampler::IIOSubsampler((IIOSubsampler *)v48, *(_DWORD *)(a1 + 228), v47[0], (*(unsigned __int8 *)(a1 + 247) << 12) | (*(unsigned __int8 *)(a1 + 248) << 16) | ((*(_BYTE *)(a1 + 249) != 0) << 8) | *(unsigned __int8 *)(a1 + 246), *(_WORD *)(a1 + 240), v12, *(_WORD *)(a1 + 316), v10, *(_DWORD *)(a1 + 292), *(_DWORD *)(a1 + 300));
  v17 = *(_DWORD *)(a1 + 232);
  if (v17)
  {
    v18 = 0;
    v19 = 0;
    v40 = v7;
    v45 = (v8 + 7) >> 3;
    while (1)
    {
      if (v18 + v7 >= v17)
      {
        v20 = v17 - v18;
        v49 = (v17 - v18) / *(unsigned __int16 *)(a1 + 316);
        if (!v49)
          goto LABEL_45;
      }
      else
      {
        v20 = v7;
        if (!v49)
          goto LABEL_45;
      }
      v44 = v19;
      v43 = v20;
      v21 = v20 + v18;
      if (v18 < v21)
        break;
LABEL_44:
      IIOSubsampler::subsample((IIOSubsampler *)v48, v42, v43, (unsigned __int8 *)(v41 + v44 * *(unsigned int *)(a1 + 300)), &v49);
      v19 = v44 + v49;
      v17 = *(_DWORD *)(a1 + 232);
      v18 = v21;
      v7 = v40;
      if (v21 >= v17)
        goto LABEL_45;
    }
    v22 = v42;
    while (1)
    {
      v23 = _cg_TIFFReadScanline(a2, v22, v18, 0, v13, v14, v15, v16);
      v24 = *(unsigned __int16 *)(a1 + 244);
      v25 = *(unsigned __int16 *)(a1 + 308);
      if (v24 > v25)
      {
        switch(v45)
        {
          case 1u:
            v36 = *(_DWORD *)(a1 + 228);
            if (v36)
            {
              v37 = v22;
              v38 = v22;
              do
              {
                memmove(v37, v38, v25);
                v38 += v24;
                v37 += v25;
                --v36;
              }
              while (v36);
            }
            break;
          case 2u:
            v31 = *(_DWORD *)(a1 + 228);
            if (v31)
            {
              v32 = 2 * v25;
              v33 = 2 * v24;
              v34 = v22;
              v35 = v22;
              do
              {
                memmove(v35, v34, v32);
                v35 += v32;
                v34 += v33;
                --v31;
              }
              while (v31);
            }
            break;
          case 4u:
            v26 = *(_DWORD *)(a1 + 228);
            if (v26)
            {
              v27 = 4 * v25;
              v28 = 4 * v24;
              v29 = v22;
              v30 = v22;
              do
              {
                memmove(v30, v29, v27);
                v30 += v27;
                v29 += v28;
                --v26;
              }
              while (v26);
            }
            break;
        }
      }
      if (v23 == -1)
        break;
      v22 += *(_QWORD *)v47;
      v18 = (v18 + 1);
      if ((_DWORD)v18 == (_DWORD)v21)
        goto LABEL_44;
    }
    _cg_jpeg_mem_term("decodeSubsampled", 1700, "*** ERROR: TIFFReadScanline returned -1\n");
    IIOSubsampler::~IIOSubsampler((IIOSubsampler *)v48);
    v11 = 4294967246;
  }
  else
  {
LABEL_45:
    IIOSubsampler::~IIOSubsampler((IIOSubsampler *)v48);
    v11 = 0;
  }
  free(v42);
  return v11;
}

void sub_187FB12F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  IIOSubsampler::~IIOSubsampler((IIOSubsampler *)va);
  _Unwind_Resume(a1);
}

float *ConvertLineXYZToRGB<float>(float *result, float *a2, int a3)
{
  float v3;
  float v4;
  float v5;

  for (; a3; --a3)
  {
    v3 = result[1] * -1.276 + *result * 2.69 + result[2] * -0.414;
    *a2 = v3;
    v4 = result[1] * 1.978 + *result * -1.022 + result[2] * 0.044;
    a2[1] = v4;
    v5 = result[1] * -0.224 + *result * 0.061 + result[2] * 1.163;
    a2[2] = v5;
    result += 3;
    a2 += 3;
  }
  return result;
}

uint64_t TIFFReadPlugin::decodeStripPlanar(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t PixelConverter;
  char *v10;
  unsigned int v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  unsigned int v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  _BYTE *v32;
  char *v33;
  char v34;
  int v35;
  _WORD *v36;
  __int16 *v37;
  __int16 v38;
  int v39;
  _DWORD *v40;
  int *v41;
  int v42;
  uint64_t v43;
  void *v44;
  void *v45;
  int v47;
  int v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t size;
  unsigned int v53;
  char *v54;
  unsigned int v55;
  uint64_t v56;
  uint64_t v57;
  void *v58;
  int v59;
  uint64_t v60;
  int v61;
  __int128 v62;
  int v63;
  uint64_t v64;

  v5 = a1;
  v64 = *MEMORY[0x1E0C80C00];
  size = *(_QWORD *)(a1 + 480);
  v6 = *(unsigned __int16 *)(a1 + 304);
  v7 = *(unsigned __int16 *)(a1 + 308);
  v49 = *(unsigned int *)(a1 + 472);
  v8 = *((_DWORD *)a3 + 7);
  v61 = 0;
  v60 = 0;
  v62 = xmmword_188210648;
  v63 = 4;
  if (*(_WORD *)(a1 + 274) == 32 && *(_WORD *)(a1 + 272) == 8 && !*(_BYTE *)(a1 + 405))
  {
    LODWORD(v62) = 2;
    DWORD2(v62) = 0;
  }
  v59 = 0;
  LOWORD(v60) = 1542;
  BYTE2(v60) = 0;
  WORD2(v60) = 1;
  HIWORD(v60) = *(_WORD *)(a1 + 240);
  LOWORD(v61) = v6;
  PixelConverter = ImageIOPixelConverter::CreatePixelConverter((uint64_t)&v59);
  v10 = (char *)malloc_type_malloc(size, 0x457A0EE8uLL);
  if (v10)
  {
    v11 = (v6 + 7) >> 3;
    v12 = malloc_type_malloc((v8 * v11 + 15) & 0xFFFFFFF0, 0x4101058FuLL);
    v18 = v12;
    if (v12 && (v20 = *((_DWORD *)a3 + 5), v19 = *((_DWORD *)a3 + 6), v20 < v19))
    {
      v47 = *(unsigned __int16 *)(v5 + 462);
      v48 = *(unsigned __int16 *)(v5 + 488);
      v58 = v12;
      if ((v48 - v47) <= 1)
        v21 = 1;
      else
        v21 = (v48 - v47);
      v50 = v21;
      v51 = a2;
      v54 = v10;
      while (1)
      {
        v55 = v20;
        v22 = v20 + v49;
        if (v48 != v47)
          break;
LABEL_39:
        v20 = v22;
        if (v22 >= v19)
          goto LABEL_40;
      }
      v53 = v20 + v49;
      v23 = 0;
      while (1)
      {
        v56 = v23;
        v24 = *(_DWORD *)(v5 + 472)
            ? _cg_TIFFComputeStrip(a2, v55, (unsigned __int16)v23, v13, v14, v15, v16, v17)
            : 0;
        v25 = v53;
        if (_cg_TIFFReadEncodedStrip(a2, v24, v10, -1, v14, v15, v16, v17) > size)
          break;
        v26 = v5;
        if (v53 >= *((_DWORD *)a3 + 6))
          v25 = *((_DWORD *)a3 + 6);
        v18 = v58;
        if (v55 < v25)
        {
          v57 = *((_DWORD *)&v62 + v56) * v11;
          v27 = v55;
          v28 = v54;
          do
          {
            (*(void (**)(uint64_t, char *, void *, _QWORD))(*(_QWORD *)PixelConverter + 24))(PixelConverter, v28, v18, *(unsigned int *)(v26 + 448));
            v29 = *a3;
            v30 = *((_DWORD *)a3 + 9) * v27;
            if (v11 == 4)
            {
              v39 = *((_DWORD *)a3 + 7);
              v18 = v58;
              if (v39)
              {
                v40 = (_DWORD *)(v29 + v57 + v30);
                v41 = (int *)v58;
                do
                {
                  v42 = *v41++;
                  *v40 = v42;
                  v40 += v7;
                  --v39;
                }
                while (v39);
              }
            }
            else if (v11 == 2)
            {
              v35 = *((_DWORD *)a3 + 7);
              v18 = v58;
              if (v35)
              {
                v36 = (_WORD *)(v29 + v57 + v30);
                v37 = (__int16 *)v58;
                do
                {
                  v38 = *v37++;
                  *v36 = v38;
                  v36 += v7;
                  --v35;
                }
                while (v35);
              }
            }
            else
            {
              v18 = v58;
              if (v11 == 1)
              {
                v31 = *((_DWORD *)a3 + 7);
                if (v31)
                {
                  v32 = (_BYTE *)(v29 + v57 + v30);
                  v33 = (char *)v58;
                  do
                  {
                    v34 = *v33++;
                    *v32 = v34;
                    v32 += v7;
                    --v31;
                  }
                  while (v31);
                }
              }
            }
            v28 += (size / v49);
            ++v27;
          }
          while (v27 < v25);
        }
        v23 = v56 + 1;
        a2 = v51;
        v5 = v26;
        v10 = v54;
        if (v56 + 1 == v50)
        {
          v19 = *((_DWORD *)a3 + 6);
          v22 = v53;
          goto LABEL_39;
        }
      }
      v43 = 4294967246;
      v18 = v58;
    }
    else
    {
LABEL_40:
      v43 = 0;
    }
  }
  else
  {
    v43 = 0;
    v18 = 0;
  }
  if (PixelConverter)
  {
    v44 = v18;
    (*(void (**)(uint64_t))(*(_QWORD *)PixelConverter + 8))(PixelConverter);
    v18 = v44;
  }
  if (v10)
  {
    v45 = v18;
    free(v10);
    v18 = v45;
  }
  if (v18)
    free(v18);
  return v43;
}

uint64_t TIFFReadPlugin::decodeTileChunky(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  size_t v11;
  unsigned int v12;
  size_t v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  char v20;
  uint64_t v21;
  uint64_t PixelConverter;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  char *v26;
  int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  size_t v36;
  int v37;
  char *v38;
  char *v39;
  uint64_t v40;
  char *v41;
  uint64_t v43;
  size_t v44;
  unsigned int v45;
  unsigned int v46;
  char *v47;
  char *v48;
  _QWORD v49[2];

  v9 = a2;
  v11 = _cg_TIFFTileSize64(a2, a2, a3, a4, a5, a6, a7, a8);
  v12 = *(_DWORD *)(a1 + 516);
  if (!v12)
    return 4294967246;
  v13 = v11;
  v14 = *(_DWORD *)(a1 + 448);
  v15 = *(_DWORD *)(a1 + 504);
  v16 = *(_DWORD *)(a1 + 520);
  v48 = (char *)malloc_type_malloc(v11, 0x7B746B45uLL);
  if (!v48)
    return 4294967246;
  v17 = (v12 + v14 - 1) / v12 * v15;
  v47 = (char *)malloc_type_malloc((v17 * v16), 0x72D77F2uLL);
  if (!v47)
  {
    v21 = 4294967246;
    free(v48);
    return v21;
  }
  v49[0] = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
  v49[1] = v18;
  if (*(_WORD *)(a1 + 274) == 32 && *(_WORD *)(a1 + 272) == 8)
  {
    v19 = *(unsigned __int16 *)(a1 + 244);
    if (v19 == 3)
    {
      BYTE6(v49[0]) = -1;
      BYTE4(v49[0]) = 0;
      if (!*(_BYTE *)(a1 + 405))
      {
LABEL_13:
        v20 = 3;
        goto LABEL_14;
      }
      v20 = 2;
LABEL_14:
      BYTE5(v49[0]) = v20;
      goto LABEL_15;
    }
    if (v19 == 4)
    {
      v20 = 2;
      BYTE4(v49[0]) = 2;
      if (!*(_BYTE *)(a1 + 405))
        goto LABEL_13;
      goto LABEL_14;
    }
  }
LABEL_15:
  PixelConverter = ImageIOPixelConverter::CreatePixelConverter((uint64_t)v49);
  v24 = *(_DWORD *)(a3 + 20);
  v23 = *(_DWORD *)(a3 + 24);
  if (v24 >= v23)
  {
    v21 = 0;
  }
  else
  {
    v25 = PixelConverter;
    v43 = v9;
    v44 = v13;
    v26 = &v47[(v17 * v16)];
    v27 = *(_DWORD *)(a1 + 520);
    while (1)
    {
      v28 = v27 + v24;
      v46 = v24;
      v29 = v23 - v24;
      v30 = v28 <= v23 ? v27 : v29;
      if (*(_DWORD *)(a3 + 28))
        break;
LABEL_28:
      if (v46 < v30 + v46)
      {
        v40 = *(_QWORD *)a3 + (v46 - *(_DWORD *)(a3 + 20)) * *(_DWORD *)(a3 + 36);
        v41 = v47;
        do
        {
          (*(void (**)(uint64_t, char *, uint64_t, _QWORD))(*(_QWORD *)v25 + 24))(v25, v41, v40, *(unsigned int *)(a3 + 28));
          v40 += *(unsigned int *)(a3 + 36);
          v41 += v17;
          --v30;
        }
        while (v30);
      }
      v21 = 0;
      v27 = *(_DWORD *)(a1 + 520);
      v24 = v27 + v46;
      v23 = *(_DWORD *)(a3 + 24);
      if (v27 + v46 >= v23)
        goto LABEL_35;
    }
    v31 = 0;
    v32 = 0;
    while (1)
    {
      bzero(v48, v44);
      if (_cg_TIFFReadTile(v9, (unsigned __int8 *)v48, v32, v46, 0, 0, v33, v34) == -1)
        break;
      v35 = v31;
      v36 = *(_QWORD *)(a1 + 504);
      v45 = v31;
      if (v30)
      {
        v37 = 0;
        v38 = v48;
        v39 = &v47[v35];
        while (&v39[v36] <= v26)
        {
          memcpy(v39, v38, v36);
          v36 = *(_QWORD *)(a1 + 504);
          v38 += v36;
          v39 += v17;
          if (++v37 >= v30)
            goto LABEL_27;
        }
        break;
      }
LABEL_27:
      v32 = (*(_DWORD *)(a1 + 516) + v32);
      v31 = v36 + v45;
      v9 = v43;
      if (v32 >= *(_DWORD *)(a3 + 28))
        goto LABEL_28;
    }
    v21 = 4294967246;
  }
LABEL_35:
  free(v48);
  free(v47);
  return v21;
}

uint64_t TIFFReadPlugin::decodeTilePlanar(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  unsigned int v5;
  uint64_t v6;
  unsigned int v7;
  int v8;
  uint64_t PixelConverter;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  int v15;
  int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  char *v28;
  _DWORD *v29;
  unsigned int v30;
  _BYTE *v31;
  char *v32;
  char v33;
  _WORD *v34;
  unsigned int v35;
  __int16 *v36;
  __int16 v37;
  _DWORD *v38;
  unsigned int v39;
  int *v40;
  int v41;
  int v43;
  int v44;
  unsigned int v45;
  uint64_t v46;
  unint64_t v47;
  size_t size;
  unsigned int v50;
  char *v51;
  uint64_t v52;
  unsigned int v53;
  _DWORD *v54;
  unsigned int v55;
  int *v56;
  int v57;
  uint64_t v58;
  int v59;
  __int128 v60;
  int v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  size = *(_QWORD *)(a1 + 528);
  if (!size)
    size = *(_QWORD *)(a1 + 480);
  v5 = (*(unsigned __int16 *)(a1 + 304) + 7) >> 3;
  v6 = *(unsigned __int16 *)(a1 + 308);
  v7 = *(unsigned __int16 *)(a1 + 306) + 7;
  v59 = 0;
  v58 = 0;
  v60 = xmmword_188210648;
  v61 = 4;
  if (*(_WORD *)(a1 + 274) == 32 && !*(_BYTE *)(a1 + 405))
  {
    LODWORD(v60) = 2;
    DWORD2(v60) = 0;
  }
  v45 = v7 >> 3;
  if (*(_DWORD *)(a1 + 516) <= *(_DWORD *)(a1 + 448))
    v8 = *(_DWORD *)(a1 + 448);
  else
    v8 = *(_DWORD *)(a1 + 516);
  if (v5 > 4 || ((1 << v5) & 0x16) == 0)
  {
    LogError("decodeTilePlanar", 2051, "*** ERROR: decodeTilePlanar cannot handle %d bytes/component (%5d bpp)\n", v5, v45);
    return 4294967246;
  }
  v51 = (char *)malloc_type_malloc(size, 0x3FE8C237uLL);
  if (!v51)
    return 4294967246;
  v56 = (int *)malloc_type_malloc((v8 * v45 + 15) & 0xFFFFFFF0, 0x653B9B6AuLL);
  if (!v56)
  {
    free(v51);
    return 4294967246;
  }
  v57 = 0;
  LOWORD(v58) = 1542;
  BYTE2(v58) = 0;
  WORD2(v58) = 1;
  HIWORD(v58) = *(_WORD *)(a1 + 240);
  LOWORD(v59) = *(_WORD *)(a1 + 304);
  BYTE2(v59) = 0;
  PixelConverter = ImageIOPixelConverter::CreatePixelConverter((uint64_t)&v57);
  v11 = 0;
  v13 = a3[5];
  v12 = a3[6];
  if (v13 < v12)
  {
    v14 = PixelConverter;
    v15 = *(unsigned __int16 *)(a1 + 488);
    v16 = *(unsigned __int16 *)(a1 + 462);
    v47 = (unsigned __int16)(v15 - v16);
    v17 = *(_DWORD *)(a1 + 520);
    v54 = a3;
    v18 = a3[7];
    v19 = v18;
    v43 = v16;
    v44 = v15;
    while (1)
    {
      v20 = v12 - v13;
      if (v17 + v13 <= v12)
        v20 = v17;
      v55 = v20;
      if (v19)
        break;
      v13 += v17;
LABEL_49:
      if (v13 >= v12)
      {
        v11 = 0;
        goto LABEL_52;
      }
    }
    v21 = 0;
    v22 = *(_DWORD *)(a1 + 516);
    v53 = v13;
    while (1)
    {
      v23 = v22 + v21;
      v24 = v22 + v21 <= v19 ? v22 : v19 - v21;
      if (v15 != v16)
        break;
LABEL_46:
      v19 = v18;
      v21 = v23;
      if (v23 >= v18)
      {
        v17 = *(_DWORD *)(a1 + 520);
        v12 = v54[6];
        v13 += v17;
        v19 = v18;
        goto LABEL_49;
      }
    }
    v25 = 0;
    v50 = v21;
    v46 = v21 * v45;
    while (1)
    {
      bzero(v51, size);
      v52 = v25;
      if (_cg_TIFFReadTileWithSize(a2, (unsigned __int8 *)v51, size, v50, v53, 0, (unsigned __int16)v25, v26) == -1)
        break;
      if (v55)
      {
        v27 = 0;
        v28 = v51;
        v29 = (_DWORD *)(*(_QWORD *)v54 + v46 + (v53 - v54[5]) * v54[9] + *((_DWORD *)&v60 + v52) * v5);
        do
        {
          (*(void (**)(uint64_t, char *, int *, _QWORD))(*(_QWORD *)v14 + 24))(v14, v28, v56, *(unsigned int *)(a1 + 516));
          if (v5 == 4)
          {
            if (v24)
            {
              v38 = v29;
              v39 = v24;
              v40 = v56;
              do
              {
                v41 = *v40++;
                *v38 = v41;
                v38 += v6;
                --v39;
              }
              while (v39);
            }
          }
          else if (v5 == 2)
          {
            if (v24)
            {
              v34 = v29;
              v35 = v24;
              v36 = (__int16 *)v56;
              do
              {
                v37 = *v36++;
                *v34 = v37;
                v34 += v6;
                --v35;
              }
              while (v35);
            }
          }
          else if (v5 == 1 && v24)
          {
            v30 = v24;
            v31 = v29;
            v32 = (char *)v56;
            do
            {
              v33 = *v32++;
              *v31 = v33;
              v31 += v6;
              --v30;
            }
            while (v30);
          }
          v28 += *(_QWORD *)(a1 + 504);
          v29 = (_DWORD *)((char *)v29 + v54[9]);
          ++v27;
        }
        while (v27 < v55);
      }
      v25 = v52 + 1;
      v13 = v53;
      if (v52 + 1 >= v47)
      {
        v22 = *(_DWORD *)(a1 + 516);
        v18 = v54[7];
        v23 = v22 + v50;
        v16 = v43;
        v15 = v44;
        goto LABEL_46;
      }
    }
    LogError("decodeTilePlanar", 2086, "*** ERROR: TIFFReadTileWithSize failed\n");
    v11 = 4294967246;
  }
LABEL_52:
  free(v51);
  free(v56);
  return v11;
}

uint64_t TIFFReadPlugin::decodeRGBAImage(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  unsigned int v4;
  uint64_t v5;
  unint64_t v6;
  BOOL v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v11;
  int8x16_t v12;
  vImage_Buffer v14;

  v4 = *(_DWORD *)(a1 + 228);
  if (*(unsigned int *)(a1 + 236) * (unint64_t)v4 <= 0xF4240)
  {
    v6 = *(_QWORD *)(a1 + 184);
    v7 = v6 >= 0x400;
    v8 = *(unsigned int *)(a1 + 232) * (unint64_t)v4;
    v9 = 300 * v6;
    v5 = !v7 || v8 > v9;
  }
  else
  {
    v5 = 1;
  }
  if ((_cg_TIFFReadRGBAImageOriented(a2, *(unsigned int *)(a3 + 28), *(unsigned int *)(a3 + 32), *(_QWORD *)a3, 1, v5) & 0x80000000) != 0)
    return 4294967246;
  v14.data = *(void **)a3;
  v11 = *(_QWORD *)(a3 + 28);
  v12.i64[0] = v11;
  v12.i64[1] = HIDWORD(v11);
  *(int8x16_t *)&v14.height = vextq_s8(v12, v12, 8uLL);
  v14.rowBytes = *(unsigned int *)(a3 + 36);
  vImagePermuteChannels_ARGB8888(&v14, &v14, TIFFReadPlugin::decodeRGBAImage(tiff *,IIODecodeInfo)::permuteMap, 0x10u);
  return 0;
}

_QWORD *std::vector<IIODecodeInfo>::__init_with_size[abi:ne180100]<IIODecodeInfo*,IIODecodeInfo*>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<IIODecodeInfo>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_187FB1FC8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<IIODecodeInfo>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0x666666666666667)
    std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOThumbnailInfo>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[40 * v4];
  return result;
}

IIO_Reader *IIOReader_RawCamera::IIOReader_RawCamera(IIO_Reader *a1, uint64_t a2)
{
  uint64_t v4;

  IIO_Reader::IIO_Reader(a1, *(const __CFString *const **)a2, *(const char **)(a2 + 8), 1380013856, *(_QWORD *)(a2 + 16), *(_QWORD *)(a2 + 96));
  *(_QWORD *)v4 = &off_1E1BB1BF0;
  *(_OWORD *)(v4 + 72) = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(v4 + 88) = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(v4 + 104) = *(_OWORD *)(a2 + 56);
  *(_QWORD *)(v4 + 120) = 0;
  IIOReader_RawCamera::createRAWOSType(v4);
  return a1;
}

uint64_t IIOReader_RawCamera::isReaderForRAWImageFormat(IIOReader_RawCamera *this)
{
  return 1;
}

uint64_t IIOReader_RawCamera::callUpdateSourceProperties(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  void (*v7)(uint64_t, uint64_t, uint64_t);

  v7 = *(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 80);
  if (v7)
    v7(a2, a3, a7);
  return 0;
}

uint64_t IIOReader_RawCamera::callGetImageCount(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t (*v5)(uint64_t, uint64_t);

  if (a5)
    *a5 = 0;
  v5 = *(uint64_t (**)(uint64_t, uint64_t))(a1 + 88);
  if (v5)
    return v5(a2, a4);
  else
    return 1;
}

uint64_t IIOReader_RawCamera::compareOptions(IIOReader_RawCamera *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  uint64_t (*v3)(const __CFDictionary *, const __CFDictionary *);

  v3 = (uint64_t (*)(const __CFDictionary *, const __CFDictionary *))*((_QWORD *)this + 12);
  if (v3)
    return v3(a2, a3);
  else
    return 1;
}

uint64_t IIOReader_RawCamera::initImageAtOffset(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int (*v4)(uint64_t, uint64_t, uint64_t);
  uint64_t v9;

  v4 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t))(a1 + 104);
  if (!v4)
    return 4294967246;
  v9 = *(_QWORD *)(a2 + 24);
  if (v9)
  {
    IIOImagePlus::setReadPluginType(v9, *(_DWORD *)(a1 + 24));
    v4 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t))(a1 + 104);
  }
  if (v4(a2, a3, a4))
    return 0;
  else
    return 4294967246;
}

uint64_t IIOReader_RawCamera::initThumbnail(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int (*v4)(uint64_t, uint64_t, uint64_t);
  uint64_t v5;

  v4 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t))(a1 + 112);
  v5 = 4294967245;
  if (v4)
  {
    if (v4(a2, a3, a4))
      return 0;
    else
      return 4294967245;
  }
  return v5;
}

uint64_t IIOReader_RawCamera::canDecodeOOP(IIOReader_RawCamera *this)
{
  return 0;
}

uint64_t IIOReader_RawCamera::copyAuxiliaryDataInfo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t (*v4)(uint64_t, uint64_t, uint64_t);

  v4 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 120);
  if (v4)
    return v4(a2, a3, a4);
  else
    return 0;
}

BOOL IIOReader_RawCamera::hasCustomImageCountProc(IIOReader_RawCamera *this)
{
  return *((_QWORD *)this + 11) != 0;
}

BOOL IIOReader_RawCamera::hasCustomSourcePropertiesProc(IIOReader_RawCamera *this)
{
  return *((_QWORD *)this + 10) != 0;
}

BOOL IIOReader_RawCamera::hasCustomThumbnailProc(IIOReader_RawCamera *this)
{
  return *((_QWORD *)this + 14) != 0;
}

BOOL IIOReader_RawCamera::hasCustomCompareOptionsProc(IIOReader_RawCamera *this)
{
  return *((_QWORD *)this + 12) != 0;
}

BOOL IIOReader_RawCamera::hasCustomCopyAuxiliaryDataProc(IIOReader_RawCamera *this)
{
  return *((_QWORD *)this + 15) != 0;
}

uint64_t TIFFInitOJPEG(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int8x16_t v24;
  char *v25;
  char v27;

  if (a2 != 6)
    TIFFInitOJPEG_cold_1();
  if (!_TIFFMergeFields(a1, ojpegFields, 7, a4, a5, a6, a7, a8))
  {
    v25 = "Merging Old JPEG codec-specific tags failed";
LABEL_7:
    TIFFErrorExtR(a1, "TIFFInitOJPEG", v25, v10, v11, v12, v13, v14, v27);
    return 0;
  }
  v15 = _TIFFmallocExt((_QWORD *)a1, 5776, v9, v10, v11, v12, v13, v14);
  if (!v15)
  {
    v25 = "No space for OJPEG state block";
    goto LABEL_7;
  }
  v16 = v15;
  _TIFFmemset(v15, 0, 0x1690uLL);
  *v16 = a1;
  v17 = 1;
  *((_BYTE *)v16 + 288) = 1;
  *((_WORD *)v16 + 146) = 514;
  _cg_TIFFSetField(a1, 530, v18, v19, v20, v21, v22, v23, 2);
  *(_QWORD *)(a1 + 952) = OJPEGFixupTags;
  *(_QWORD *)(a1 + 960) = OJPEGSetupDecode;
  *(_QWORD *)(a1 + 968) = OJPEGPreDecode;
  *(_QWORD *)(a1 + 1248) = OJPEGPostDecode;
  *(_QWORD *)(a1 + 1008) = OJPEGDecode;
  *(_QWORD *)(a1 + 1024) = OJPEGDecode;
  *(_QWORD *)(a1 + 1040) = OJPEGDecode;
  *(_QWORD *)(a1 + 976) = OJPEGSetupEncode;
  *(_QWORD *)(a1 + 992) = OJPEGPreEncode;
  *(_QWORD *)(a1 + 1000) = OJPEGPostEncode;
  *(_QWORD *)(a1 + 1016) = OJPEGEncode;
  *(_QWORD *)(a1 + 1032) = OJPEGEncode;
  *(_QWORD *)(a1 + 1048) = OJPEGEncode;
  *(_QWORD *)(a1 + 1072) = OJPEGCleanup;
  *(_QWORD *)(a1 + 1096) = v16;
  v24 = *(int8x16_t *)(a1 + 1280);
  *(_QWORD *)(a1 + 1288) = OJPEGVGetField;
  *(int8x16_t *)(v16 + 27) = vextq_s8(v24, v24, 8uLL);
  *(_QWORD *)(a1 + 1280) = OJPEGVSetField;
  v16[29] = *(_QWORD *)(a1 + 1296);
  *(_QWORD *)(a1 + 1296) = OJPEGPrintDir;
  *(_DWORD *)(a1 + 16) |= 0x20000u;
  return v17;
}

uint64_t OJPEGFixupTags()
{
  return 1;
}

uint64_t OJPEGSetupDecode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  TIFFWarningExtR(a1, "OJPEGSetupDecode", "Deprecated and troublesome old-style JPEG compression mode, please convert to new-style JPEG compression and notify vendor of writing software", a4, a5, a6, a7, a8, vars0);
  return 1;
}

uint64_t OJPEGPreDecode(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  unsigned int v30;
  unsigned int v31;
  unsigned int v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t result;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unsigned int v42;
  unsigned int v43;
  int v44;
  unsigned int v45;
  int v46;
  int v47;
  int v48;
  int64_t v49;
  _QWORD *v50;
  uint64_t v51;
  char *v52;
  _QWORD *v53;
  _QWORD *v54;
  uint64_t v55;
  uint64_t v56;
  unsigned int v57;
  int v58;
  unsigned int v59;
  int v60;
  uint64_t v61;
  unsigned int v62;
  uint64_t v63;
  unsigned int v64;
  unsigned int v65;
  int v66;
  unsigned int v67;
  unsigned int v68;
  int v69;
  unsigned int v70;
  unsigned int v71;
  unsigned int v72;
  unsigned int v73;
  const char *v74;
  char *v75;
  uint64_t v76;
  _QWORD *v77;
  int v78;
  unsigned int v79;
  int v80;
  unsigned int v81;
  unsigned int v82;
  unsigned int v83;
  unsigned int v84;
  uint64_t v85;
  char v86;
  unsigned __int8 v87;

  v8 = a2;
  v10 = *(_QWORD *)(a1 + 1096);
  if (!*(_BYTE *)(v10 + 290))
    OJPEGSubsamplingCorrect(a1, a2, a3, a4, a5, a6, a7, a8);
  if (!*(_BYTE *)(v10 + 600))
  {
    v28 = *(_QWORD *)(a1 + 1096);
    if (*(_BYTE *)(v28 + 600))
      OJPEGPreDecode_cold_7();
    v29 = *(_DWORD *)(a1 + 88);
    v30 = *(_DWORD *)(a1 + 92);
    *(_DWORD *)(v28 + 248) = v29;
    *(_DWORD *)(v28 + 252) = v30;
    if ((*(_BYTE *)(a1 + 17) & 4) != 0)
    {
      v29 = *(_DWORD *)(a1 + 100);
      v31 = *(_DWORD *)(a1 + 104);
      v32 = (v31 + v30 - 1) / v31 * v31;
    }
    else
    {
      v31 = *(_DWORD *)(a1 + 132);
      if (v31 == -1)
        v31 = v30;
      v32 = v30;
    }
    *(_DWORD *)(v28 + 256) = v29;
    *(_DWORD *)(v28 + 260) = v31;
    *(_DWORD *)(v28 + 264) = v32;
    v33 = *(unsigned __int16 *)(a1 + 130);
    if (v33 == 3)
    {
      *(_WORD *)(v28 + 268) = 3;
      if (*(_WORD *)(a1 + 170) != 1)
        LOBYTE(v33) = 1;
      *(_BYTE *)(v28 + 270) = v33;
    }
    else
    {
      if (v33 != 1)
      {
        TIFFErrorExtR(a1, "OJPEGReadHeaderInfo", "SamplesPerPixel %hhu not supported for this compression scheme", a4, a5, a6, a7, a8, *(_BYTE *)(v28 + 268));
        return 0;
      }
      *(_WORD *)(v28 + 268) = 1;
      *(_BYTE *)(v28 + 270) = 1;
      *(_WORD *)(v28 + 292) = 257;
    }
    if (v31 < v30)
    {
      v70 = *(unsigned __int8 *)(v28 + 292);
      if (v70 > 4
        || ((1 << v70) & 0x16) == 0
        || (v71 = *(unsigned __int8 *)(v28 + 293), v71 > 4)
        || ((1 << v71) & 0x16) == 0)
      {
        v74 = "OJPEGReadHeaderInfo";
        v75 = "Invalid subsampling values";
        goto LABEL_118;
      }
      v72 = 8 * v71;
      v73 = v31 / (8 * v71);
      if (v31 % v72)
      {
        v74 = "OJPEGReadHeaderInfo";
        v75 = "Incompatible vertical subsampling and image strip/tile length";
        goto LABEL_118;
      }
      *(_WORD *)(v28 + 472) = v73 * ((v29 + 8 * v70 - 1) / (8 * v70));
    }
    result = OJPEGReadHeaderInfoSec(a1, a2, a3, a4, a5, a6, a7, a8);
    if (!(_DWORD)result)
      return result;
    *(_BYTE *)(v28 + 504) = 1;
    *(_QWORD *)(v28 + 508) = *(_QWORD *)(v28 + 1608);
    v85 = *(unsigned __int16 *)(v28 + 1648);
    *(_QWORD *)(v28 + 520) = *(_QWORD *)(v28 + 1624) - v85;
    *(_QWORD *)(v28 + 528) = *(_QWORD *)(v28 + 1640) + v85;
    *(_BYTE *)(v28 + 600) = 1;
  }
  if (!*(_BYTE *)(v10 + 32 * v8 + 504))
  {
    if (!v8)
      OJPEGPreDecode_cold_1();
    if (v8 >= 3)
      OJPEGPreDecode_cold_2();
    v11 = *(_QWORD *)(a1 + 1096);
    if (!*(_BYTE *)(v11 + 504))
      OJPEGPreDecode_cold_3();
    if (*(_BYTE *)(v11 + 32 * v8 + 504))
      OJPEGPreDecode_cold_6();
    v12 = v8;
    do
      v13 = v11 + 32 * --v12;
    while (!*(_BYTE *)(v13 + 504));
    *(_BYTE *)(v11 + 269) = v12;
    *(_QWORD *)(v11 + 1608) = *(_QWORD *)(v13 + 508);
    *(_QWORD *)(v11 + 1624) = *(_QWORD *)(v13 + 520);
    *(_BYTE *)(v11 + 1632) = 0;
    *(_QWORD *)(v11 + 1640) = *(_QWORD *)(v13 + 528);
    *(_WORD *)(v11 + 1648) = 0;
    *(_QWORD *)(v11 + 1656) = 0;
    if (v8 > v12)
    {
      v87 = 0;
      while (OJPEGReadByte(v11, &v87))
      {
        if (v87 == 255)
        {
          do
          {
            if (!OJPEGReadByte(v11, &v87))
              return 0;
          }
          while (v87 == 255);
          if (v87 == 218)
          {
            ++*(_BYTE *)(v11 + 269);
            if (!OJPEGReadHeaderInfoSecStreamSos(a1, v14, v15, v16, v17, v18, v19, v20))
              return 0;
            v21 = *(unsigned __int8 *)(v11 + 269);
            v22 = v11 + 32 * v21;
            *(_BYTE *)(v22 + 504) = 1;
            *(_QWORD *)(v22 + 508) = *(_QWORD *)(v11 + 1608);
            v23 = *(unsigned __int16 *)(v11 + 1648);
            *(_QWORD *)(v22 + 520) = *(_QWORD *)(v11 + 1624) - v23;
            *(_QWORD *)(v22 + 528) = *(_QWORD *)(v11 + 1640) + v23;
            if (v21 >= v8)
              goto LABEL_20;
          }
        }
      }
      return 0;
    }
  }
LABEL_20:
  v24 = 932;
  if ((*(_BYTE *)(a1 + 17) & 4) == 0)
    v24 = 884;
  v25 = *(_DWORD *)(a1 + v24);
  if (!*(_BYTE *)(v10 + 601))
  {
LABEL_28:
    *(_BYTE *)(v10 + 269) = v8;
    *(_WORD *)(v10 + 602) = v8;
    *(_DWORD *)(v10 + 604) = *(_DWORD *)(a1 + 224) * v8;
    if (*(_BYTE *)(v10 + 1632))
    {
      v27 = *(_QWORD *)(v10 + 32 * v8 + 520);
      if (*(_QWORD *)(v10 + 1624) - *(unsigned __int16 *)(v10 + 1648) == v27)
      {
LABEL_42:
        v35 = *(_QWORD *)(a1 + 1096);
        if (*(_BYTE *)(v35 + 608))
          return 0;
        *(_DWORD *)(v35 + 3712) = 0;
        *(_BYTE *)(v35 + 474) = 0;
        _cg_jpeg_std_error(v35 + 616);
        *(_QWORD *)(v35 + 632) = OJPEGLibjpegJpegErrorMgrOutputMessage;
        *(_QWORD *)(v35 + 616) = OJPEGLibjpegJpegErrorMgrErrorExit;
        *(_QWORD *)(v35 + 792) = v35 + 616;
        *(_QWORD *)(v35 + 816) = a1;
        result = jpeg_create_decompress_encap(v35, (char *)(v35 + 792));
        if (!(_DWORD)result)
          return result;
        *(_BYTE *)(v35 + 608) = 1;
        *(_QWORD *)(v35 + 1472) = OJPEGLibjpegJpegSourceMgrInitSource;
        *(_QWORD *)(v35 + 1480) = OJPEGLibjpegJpegSourceMgrFillInputBuffer;
        *(_QWORD *)(v35 + 1488) = OJPEGLibjpegJpegSourceMgrSkipInputData;
        *(_QWORD *)(v35 + 1464) = 0;
        *(_QWORD *)(v35 + 1496) = OJPEGLibjpegJpegSourceMgrResyncToRestart;
        *(_QWORD *)(v35 + 1504) = OJPEGLibjpegJpegSourceMgrTermSource;
        *(_QWORD *)(v35 + 832) = v35 + 1456;
        result = jpeg_read_header_encap(v35, v35 + 792);
        if (!(_DWORD)result)
          return result;
        v42 = *(unsigned __int8 *)(v35 + 270);
        if (*(_BYTE *)(v35 + 294) || v42 < 2)
        {
          *(_QWORD *)(v35 + 852) = 0;
          *(_BYTE *)(v35 + 609) = 1;
          *(_DWORD *)(v35 + 1600) = *(_DWORD *)(v35 + 256) * v42;
          *(_DWORD *)(v35 + 1604) = *(_DWORD *)(v35 + 260);
        }
        else
        {
          *(_DWORD *)(v35 + 884) = 1;
          *(_DWORD *)(v35 + 892) = 0;
          *(_BYTE *)(v35 + 609) = 0;
          if (!*(_BYTE *)(v35 + 1512))
          {
            if (*(_QWORD *)(v35 + 1544))
              OJPEGPreDecode_cold_5();
            if (*(_QWORD *)(v35 + 1584))
              OJPEGPreDecode_cold_4();
            v43 = *(unsigned __int8 *)(v35 + 292);
            if (!*(_BYTE *)(v35 + 292))
              return 0;
            v44 = *(unsigned __int8 *)(v35 + 293);
            if (!*(_BYTE *)(v35 + 293))
              return 0;
            v45 = (*(_DWORD *)(v35 + 256) + 8 * v43 - 1) / (8 * v43) * 8 * v43;
            *(_DWORD *)(v35 + 1516) = v45;
            v46 = 8 * v44;
            *(_DWORD *)(v35 + 1520) = v46;
            v47 = v45 / v43;
            *(_DWORD *)(v35 + 1524) = v47;
            *(_DWORD *)(v35 + 1528) = 8;
            v48 = v45 * v46;
            *(_DWORD *)(v35 + 1532) = v48;
            *(_DWORD *)(v35 + 1536) = 8 * v47;
            v49 = (v48 + 16 * v47);
            *(_DWORD *)(v35 + 1540) = v49;
            v50 = _TIFFcallocExt((_QWORD *)a1, 1, v49, v37, v38, v39, v40, v41);
            *(_QWORD *)(v35 + 1544) = v50;
            if (v50)
            {
              *(_QWORD *)(v35 + 1552) = v50;
              v52 = (char *)v50 + *(unsigned int *)(v35 + 1532);
              *(_QWORD *)(v35 + 1560) = v52;
              *(_QWORD *)(v35 + 1568) = &v52[*(unsigned int *)(v35 + 1536)];
              LODWORD(v52) = *(_DWORD *)(v35 + 1520) + 2 * *(_DWORD *)(v35 + 1528) + 3;
              *(_DWORD *)(v35 + 1576) = (_DWORD)v52;
              v53 = _TIFFmallocExt((_QWORD *)a1, 8 * v52, v51, a4, a5, a6, a7, a8);
              *(_QWORD *)(v35 + 1584) = v53;
              if (v53)
              {
                v54 = v53 + 3;
                *v53 = v53 + 3;
                v55 = *(unsigned int *)(v35 + 1520);
                v53[1] = *(_QWORD *)(v35 + 1584) + 8 * v55 + 24;
                v56 = *(unsigned int *)(v35 + 1528);
                v53[2] = *(_QWORD *)(v35 + 1584) + 8 * v55 + 8 * v56 + 24;
                if ((_DWORD)v55)
                {
                  v57 = 0;
                  v58 = *(_DWORD *)(v35 + 1516);
                  do
                  {
                    *v54++ = *(_QWORD *)(v35 + 1552) + v57;
                    v57 += v58;
                    --v55;
                  }
                  while (v55);
                }
                if ((_DWORD)v56)
                {
                  v59 = 0;
                  v60 = *(_DWORD *)(v35 + 1524);
                  v61 = v56;
                  do
                  {
                    *v54++ = *(_QWORD *)(v35 + 1560) + v59;
                    v59 += v60;
                    --v61;
                  }
                  while (v61);
                  v62 = 0;
                  v63 = 8 * v56;
                  do
                  {
                    *(_QWORD *)((char *)v54 + v61) = *(_QWORD *)(v35 + 1568) + v62;
                    v61 += 8;
                    v62 += v60;
                  }
                  while (v63 != v61);
                }
                v64 = *(_DWORD *)(v35 + 256);
                v65 = *(unsigned __int8 *)(v35 + 292);
                if (v64 % v65)
                  v66 = v64 / v65 + 1;
                else
                  v66 = v64 / v65;
                *(_DWORD *)(v35 + 1592) = v66;
                *(_DWORD *)(v35 + 1596) = 0;
                *(_DWORD *)(v35 + 12) = 0;
                v67 = *(unsigned __int8 *)(v35 + 293);
                *(_DWORD *)(v35 + 1600) = (v67 * v65 + 2) * v66;
                v68 = *(_DWORD *)(v35 + 260);
                if (v68 % v67)
                  v69 = v68 / v67 + 1;
                else
                  v69 = v68 / v67;
                *(_DWORD *)(v35 + 1604) = v69;
                *(_BYTE *)(v35 + 1512) = 1;
                goto LABEL_82;
              }
            }
            v74 = "OJPEGWriteHeaderInfo";
LABEL_117:
            v75 = "Out of memory";
LABEL_118:
            TIFFErrorExtR(a1, v74, v75, a4, a5, a6, a7, a8, v86);
            return 0;
          }
        }
LABEL_82:
        result = jpeg_start_decompress_encap(v35, v35 + 792);
        if (!(_DWORD)result)
          return result;
        if (*(_DWORD *)(v35 + 840) != *(_DWORD *)(v35 + 256))
        {
          TIFFErrorExtR(a1, "OJPEGWriteHeaderInfo", "jpeg_start_decompress() returned image_width = %u, expected %u", a4, a5, a6, a7, a8, *(_DWORD *)(v35 + 840));
          return 0;
        }
        if (*(_QWORD *)(v35 + 1208) != __PAIR64__(*(unsigned __int8 *)(v35 + 293), *(unsigned __int8 *)(v35 + 292)))
        {
          TIFFErrorExtR(a1, "OJPEGWriteHeaderInfo", "jpeg_start_decompress() returned max_h_samp_factor = %d and max_v_samp_factor = %d, expected %hhu and %hhu", a4, a5, a6, a7, a8, *(_DWORD *)(v35 + 1208));
          return 0;
        }
        *(_BYTE *)(v35 + 601) = 1;
        v26 = *(_DWORD *)(v10 + 604);
        goto LABEL_86;
      }
    }
    else
    {
      v27 = *(_QWORD *)(v10 + 32 * v8 + 520);
    }
    v34 = v10 + 32 * v8;
    *(_QWORD *)(v10 + 1608) = *(_QWORD *)(v34 + 508);
    *(_QWORD *)(v10 + 1624) = v27;
    *(_BYTE *)(v10 + 1632) = 0;
    *(_QWORD *)(v10 + 1640) = *(_QWORD *)(v34 + 528);
    *(_WORD *)(v10 + 1648) = 0;
    *(_QWORD *)(v10 + 1656) = 0;
    goto LABEL_42;
  }
  if (*(unsigned __int16 *)(v10 + 602) != v8 || (v26 = *(_DWORD *)(v10 + 604), v26 > v25))
  {
    if (*(_BYTE *)(v10 + 608))
      OJPEGLibjpegSessionAbort(a1);
    *(_BYTE *)(v10 + 601) = 0;
    goto LABEL_28;
  }
LABEL_86:
  *(_DWORD *)(v10 + 1596) = 0;
  if (v26 >= v25)
  {
LABEL_109:
    result = 1;
    *(_DWORD *)(v10 + 8) = 1;
    return result;
  }
  while (1)
  {
    v76 = *(_QWORD *)(a1 + 1096);
    if (*(_BYTE *)(v10 + 609))
    {
      if (!*(_QWORD *)(v76 + 5768))
      {
        v77 = _TIFFmallocExt((_QWORD *)a1, *(unsigned int *)(v76 + 1600), a3, a4, a5, a6, a7, a8);
        *(_QWORD *)(v76 + 5768) = v77;
        if (!v77)
        {
          v74 = "OJPEGPreDecodeSkipScanlines";
          goto LABEL_117;
        }
      }
      if (*(_DWORD *)(v76 + 1604))
      {
        v78 = 0;
        while (1)
        {
          result = jpeg_read_scanlines_encap(v76, v76 + 792, v76 + 5768);
          if (!(_DWORD)result)
            return result;
          if (++v78 >= *(_DWORD *)(v76 + 1604))
            goto LABEL_108;
        }
      }
      goto LABEL_108;
    }
    v79 = *(_DWORD *)(v76 + 1604);
    v80 = *(_DWORD *)(v76 + 1596);
    v81 = *(_DWORD *)(v76 + 1528);
    if (v80)
    {
      if (v79 <= v81 - v80)
      {
        v83 = v80 + v79;
        if (v83 == v81)
          v79 = 0;
        else
          v79 = v83;
LABEL_107:
        *(_DWORD *)(v76 + 1596) = v79;
        goto LABEL_108;
      }
      *(_DWORD *)(v76 + 1596) = 0;
      *(_DWORD *)(v76 + 12) = 0;
      v79 -= v81 - v80;
    }
    if (v79 >= v81)
      break;
LABEL_101:
    if (v79)
    {
      result = jpeg_read_raw_data_encap(v76, v76 + 792, *(_QWORD *)(v76 + 1584), 8 * *(unsigned __int8 *)(v76 + 293));
      if (!(_DWORD)result)
        return result;
      goto LABEL_107;
    }
LABEL_108:
    v84 = *(_DWORD *)(v10 + 604) + 1;
    *(_DWORD *)(v10 + 604) = v84;
    if (v84 >= v25)
      goto LABEL_109;
  }
  while (1)
  {
    result = jpeg_read_raw_data_encap(v76, v76 + 792, *(_QWORD *)(v76 + 1584), 8 * *(unsigned __int8 *)(v76 + 293));
    if (!(_DWORD)result)
      return result;
    v82 = *(_DWORD *)(v76 + 1528);
    v79 -= v82;
    if (v79 < v82)
      goto LABEL_101;
  }
}

uint64_t OJPEGPostDecode(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9;
  unsigned int v10;

  v9 = *(_QWORD *)(result + 1096);
  if (!v9)
    return TIFFErrorExt(*(_QWORD *)(result + 1200), "OJPEGPostDecode", "Cannot perform PostDecode, OJPEGState is NULL", a4, a5, a6, a7, a8, a9);
  v10 = *(_DWORD *)(v9 + 604) + 1;
  *(_DWORD *)(v9 + 604) = v10;
  if (!(v10 % *(_DWORD *)(result + 224)))
  {
    if (!*(_BYTE *)(v9 + 608))
      OJPEGPostDecode_cold_1();
    result = OJPEGLibjpegSessionAbort(result);
    *(_BYTE *)(v9 + 601) = 0;
  }
  return result;
}

uint64_t OJPEGDecode(uint64_t a1, char *a2, int64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t result;
  int64_t v20;
  int64_t v21;
  BOOL v22;
  int v23;
  _BYTE *v24;
  int64_t v25;
  int v26;
  unsigned int v27;
  uint64_t v28;
  char *v29;
  char *v30;
  char *v31;
  _BYTE *v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  int v36;
  char *v37;
  unsigned int v38;
  char v39;
  char v40;
  char v41;
  int64_t v42;
  char v43;
  char *v44;

  v11 = *(_QWORD *)(a1 + 1096);
  if (!*(_DWORD *)(v11 + 8))
  {
    bzero(a2, a3);
    v18 = "Cannot decode: decoder not correctly initialized";
LABEL_9:
    TIFFErrorExtR(a1, "OJPEGDecode", v18, v13, v14, v15, v16, v17, v43);
    return 0;
  }
  if (!*(_BYTE *)(v11 + 608))
  {
    bzero(a2, a3);
    v18 = "Cannot decode: libjpeg_session_active == 0";
    goto LABEL_9;
  }
  if (*(_DWORD *)(v11 + 12))
    goto LABEL_13;
  if (!*(_BYTE *)(v11 + 609))
  {
    if (!(a3 % *(unsigned int *)(v11 + 1600)))
    {
      if (a3 < 1)
        OJPEGDecode_cold_1();
      v23 = *(_DWORD *)(v11 + 1596);
      v24 = a2;
      v25 = a3;
      while (1)
      {
        v26 = *(unsigned __int8 *)(v11 + 293);
        if (!v23)
        {
          if (!jpeg_read_raw_data_encap(v11, v11 + 792, *(_QWORD *)(v11 + 1584), 8 * v26))
          {
            *(_DWORD *)(v11 + 12) = 1;
            goto LABEL_13;
          }
          v23 = *(_DWORD *)(v11 + 1596);
          v26 = *(unsigned __int8 *)(v11 + 293);
        }
        if (*(_DWORD *)(v11 + 1592))
        {
          v27 = 0;
          v28 = (*(_DWORD *)(v11 + 1524) * v23);
          v29 = (char *)(*(_QWORD *)(v11 + 1568) + v28);
          v30 = (char *)(*(_QWORD *)(v11 + 1560) + v28);
          v31 = (char *)(*(_QWORD *)(v11 + 1552) + (v23 * v26 * *(_DWORD *)(v11 + 1516)));
          v32 = v24;
          do
          {
            v33 = *(unsigned __int8 *)(v11 + 293);
            v34 = *(unsigned __int8 *)(v11 + 292);
            if (*(_BYTE *)(v11 + 293))
            {
              v35 = 0;
              v36 = *(unsigned __int8 *)(v11 + 292);
              v37 = v31;
              do
              {
                if (v36)
                {
                  v38 = 0;
                  do
                  {
                    v39 = *v37++;
                    *v32++ = v39;
                    ++v38;
                    v34 = *(unsigned __int8 *)(v11 + 292);
                  }
                  while (v38 < v34);
                  v33 = *(unsigned __int8 *)(v11 + 293);
                  v36 = *(unsigned __int8 *)(v11 + 292);
                }
                v37 += (*(_DWORD *)(v11 + 1516) - v36);
                ++v35;
              }
              while (v35 < v33);
            }
            v31 += v34;
            v40 = *v30++;
            *v32 = v40;
            v41 = *v29++;
            v32[1] = v41;
            v32 += 2;
            ++v27;
          }
          while (v27 < *(_DWORD *)(v11 + 1592));
          v23 = *(_DWORD *)(v11 + 1596);
        }
        if (v23 + 1 == *(_DWORD *)(v11 + 1528))
          v23 = 0;
        else
          ++v23;
        *(_DWORD *)(v11 + 1596) = v23;
        v42 = *(unsigned int *)(v11 + 1600);
        v24 += v42;
        result = 1;
        v22 = v25 <= v42;
        v25 -= v42;
        if (v22)
          return result;
      }
    }
    v12 = "OJPEGDecodeRaw";
LABEL_12:
    TIFFErrorExtR(a1, v12, "Fractional scanline not read", a4, a5, a6, a7, a8, v43);
    goto LABEL_13;
  }
  if (a3 % *(unsigned int *)(v11 + 1600))
  {
    v12 = "OJPEGDecodeScanlines";
    goto LABEL_12;
  }
  if (a3 <= 0)
    OJPEGDecode_cold_2();
  v44 = a2;
  v20 = a3;
  while (jpeg_read_scanlines_encap(v11, v11 + 792, (uint64_t)&v44))
  {
    v21 = *(unsigned int *)(v11 + 1600);
    v44 += v21;
    v22 = v20 <= v21;
    v20 -= v21;
    if (v22)
      return 1;
  }
LABEL_13:
  bzero(a2, a3);
  return 0;
}

uint64_t OJPEGSetupEncode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  TIFFErrorExtR(a1, "OJPEGSetupEncode", "OJPEG encoding not supported; use new-style JPEG compression instead",
    a4,
    a5,
    a6,
    a7,
    a8,
    vars0);
  return 0;
}

uint64_t OJPEGPreEncode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  TIFFErrorExtR(a1, "OJPEGPreEncode", "OJPEG encoding not supported; use new-style JPEG compression instead",
    a4,
    a5,
    a6,
    a7,
    a8,
    vars0);
  return 0;
}

uint64_t OJPEGPostEncode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  TIFFErrorExtR(a1, "OJPEGPostEncode", "OJPEG encoding not supported; use new-style JPEG compression instead",
    a4,
    a5,
    a6,
    a7,
    a8,
    vars0);
  return 0;
}

uint64_t OJPEGEncode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  TIFFErrorExtR(a1, "OJPEGEncode", "OJPEG encoding not supported; use new-style JPEG compression instead",
    a4,
    a5,
    a6,
    a7,
    a8,
    vars0);
  return 0;
}

_QWORD *OJPEGCleanup(_QWORD *result)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  char *v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;

  v1 = result[137];
  if (v1)
  {
    v2 = result;
    v3 = *(_QWORD *)(v1 + 224);
    result[161] = *(_QWORD *)(v1 + 216);
    result[160] = v3;
    result[162] = *(_QWORD *)(v1 + 232);
    v4 = *(char **)(v1 + 376);
    if (v4)
      _TIFFfreeExt((uint64_t)result, v4);
    v5 = *(char **)(v1 + 384);
    if (v5)
      _TIFFfreeExt((uint64_t)v2, v5);
    v6 = *(char **)(v1 + 392);
    if (v6)
      _TIFFfreeExt((uint64_t)v2, v6);
    v7 = *(char **)(v1 + 400);
    if (v7)
      _TIFFfreeExt((uint64_t)v2, v7);
    v8 = *(char **)(v1 + 408);
    if (v8)
      _TIFFfreeExt((uint64_t)v2, v8);
    v9 = *(char **)(v1 + 416);
    if (v9)
      _TIFFfreeExt((uint64_t)v2, v9);
    v10 = *(char **)(v1 + 424);
    if (v10)
      _TIFFfreeExt((uint64_t)v2, v10);
    v11 = *(char **)(v1 + 432);
    if (v11)
      _TIFFfreeExt((uint64_t)v2, v11);
    v12 = *(char **)(v1 + 440);
    if (v12)
      _TIFFfreeExt((uint64_t)v2, v12);
    v13 = *(char **)(v1 + 448);
    if (v13)
      _TIFFfreeExt((uint64_t)v2, v13);
    v14 = *(char **)(v1 + 456);
    if (v14)
      _TIFFfreeExt((uint64_t)v2, v14);
    v15 = *(char **)(v1 + 464);
    if (v15)
      _TIFFfreeExt((uint64_t)v2, v15);
    if (*(_BYTE *)(v1 + 608))
      OJPEGLibjpegSessionAbort((uint64_t)v2);
    v16 = *(char **)(v1 + 1544);
    if (v16)
      _TIFFfreeExt((uint64_t)v2, v16);
    v17 = *(char **)(v1 + 1584);
    if (v17)
      _TIFFfreeExt((uint64_t)v2, v17);
    v18 = *(char **)(v1 + 5768);
    if (v18)
      _TIFFfreeExt((uint64_t)v2, v18);
    _TIFFfreeExt((uint64_t)v2, (char *)v1);
    v2[137] = 0;
    return (_QWORD *)_TIFFSetDefaultCompressionState((uint64_t)v2);
  }
  return result;
}

uint64_t OJPEGVGetField(uint64_t a1, char *a2, _DWORD **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  __int16 v9;
  uint64_t v10;
  uint64_t result;
  _WORD **v12;
  _QWORD **v13;

  v13 = (_QWORD **)a3;
  v8 = *(_QWORD *)(a1 + 1096);
  switch((int)a2)
  {
    case 512:
      v9 = *(unsigned __int8 *)(v8 + 288);
      goto LABEL_14;
    case 513:
      v10 = *(_QWORD *)(v8 + 272);
      goto LABEL_10;
    case 514:
      v10 = *(_QWORD *)(v8 + 280);
      goto LABEL_10;
    case 515:
      v9 = *(_WORD *)(v8 + 472);
      goto LABEL_14;
    case 519:
      v13 = (_QWORD **)(a3 + 1);
      **a3 = *(unsigned __int8 *)(v8 + 295);
      v10 = v8 + 304;
      goto LABEL_10;
    case 520:
      v13 = (_QWORD **)(a3 + 1);
      **a3 = *(unsigned __int8 *)(v8 + 296);
      v10 = v8 + 328;
      goto LABEL_10;
    case 521:
      v13 = (_QWORD **)(a3 + 1);
      **a3 = *(unsigned __int8 *)(v8 + 297);
      v10 = v8 + 352;
LABEL_10:
      **v13 = v10;
      goto LABEL_15;
    case 530:
      if (!*(_BYTE *)(v8 + 290))
        OJPEGSubsamplingCorrect(a1, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
      v12 = (_WORD **)v13++;
      **v12 = *(unsigned __int8 *)(v8 + 292);
      v9 = *(unsigned __int8 *)(v8 + 293);
LABEL_14:
      *(_WORD *)*v13 = v9;
LABEL_15:
      result = 1;
      break;
    default:
      result = (*(uint64_t (**)(void))(v8 + 216))();
      break;
  }
  return result;
}

uint64_t OJPEGVSetField(uint64_t a1, int a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  unsigned int v16;
  uint64_t *v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t *v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t *v23;
  _QWORD *v24;
  uint64_t v25;
  unint64_t v26;
  char v27;

  v9 = *(_QWORD *)(a1 + 1096);
  switch(a2)
  {
    case 512:
      *(_BYTE *)(v9 + 288) = *a3;
      goto LABEL_26;
    case 513:
      *(_QWORD *)(v9 + 272) = *(_QWORD *)a3;
      goto LABEL_26;
    case 514:
      *(_QWORD *)(v9 + 280) = *(_QWORD *)a3;
      goto LABEL_26;
    case 515:
      *(_WORD *)(v9 + 472) = *a3;
      goto LABEL_26;
    case 519:
      v11 = *a3;
      if (!(_DWORD)v11)
        goto LABEL_26;
      if (v11 >= 4)
      {
        v12 = "JpegQTables tag has incorrect count";
        goto LABEL_16;
      }
      *(_BYTE *)(v9 + 295) = v11;
      v17 = (uint64_t *)*((_QWORD *)a3 + 1);
      v18 = (_QWORD *)(v9 + 304);
      do
      {
        v19 = *v17++;
        *v18++ = v19;
        --v11;
      }
      while (v11);
      goto LABEL_26;
    case 520:
      v13 = *a3;
      if (!(_DWORD)v13)
        goto LABEL_26;
      if (v13 >= 4)
      {
        v12 = "JpegDcTables tag has incorrect count";
        goto LABEL_16;
      }
      *(_BYTE *)(v9 + 296) = v13;
      v20 = (uint64_t *)*((_QWORD *)a3 + 1);
      v21 = (_QWORD *)(v9 + 328);
      do
      {
        v22 = *v20++;
        *v21++ = v22;
        --v13;
      }
      while (v13);
      goto LABEL_26;
    case 521:
      v14 = *a3;
      if (!(_DWORD)v14)
        goto LABEL_26;
      if (v14 < 4)
      {
        *(_BYTE *)(v9 + 297) = v14;
        v23 = (uint64_t *)*((_QWORD *)a3 + 1);
        v24 = (_QWORD *)(v9 + 352);
        do
        {
          v25 = *v23++;
          *v24++ = v25;
          --v14;
        }
        while (v14);
LABEL_26:
        result = (uint64_t)TIFFFieldWithTag((_QWORD *)a1, a2);
        if (result)
        {
          v26 = *(unsigned __int16 *)(result + 24);
          result = 1;
          *(_DWORD *)(a1 + ((v26 >> 3) & 0x1FFC) + 72) |= 1 << v26;
          *(_DWORD *)(a1 + 16) |= 8u;
        }
      }
      else
      {
        v12 = "JpegAcTables tag has incorrect count";
LABEL_16:
        TIFFErrorExtR(a1, "OJPEGVSetField", v12, a4, a5, a6, a7, a8, v27);
        return 0;
      }
      return result;
    case 530:
      *(_BYTE *)(v9 + 291) = 1;
      v15 = *a3;
      *(_BYTE *)(v9 + 292) = *a3;
      v16 = a3[2];
      *(_BYTE *)(v9 + 293) = v16;
      *(_WORD *)(a1 + 336) = v15;
      *(_WORD *)(a1 + 338) = v16;
      goto LABEL_26;
    default:
      return (*(uint64_t (**)(uint64_t))(v9 + 224))(a1);
  }
}

uint64_t OJPEGPrintDir(uint64_t result, FILE *__stream, uint64_t a3)
{
  uint64_t v3;
  uint64_t v6;
  int v7;
  uint64_t (*v8)(uint64_t, FILE *, uint64_t);
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;

  v3 = *(_QWORD *)(result + 1096);
  if (!v3)
    OJPEGPrintDir_cold_1();
  v6 = result;
  v7 = *(_DWORD *)(result + 80);
  if ((v7 & 4) != 0)
  {
    result = fprintf(__stream, "  JpegInterchangeFormat: %llu\n", *(_QWORD *)(v3 + 272));
    v7 = *(_DWORD *)(v6 + 80);
    if ((v7 & 8) == 0)
    {
LABEL_4:
      if ((v7 & 0x10) == 0)
        goto LABEL_5;
      goto LABEL_14;
    }
  }
  else if ((v7 & 8) == 0)
  {
    goto LABEL_4;
  }
  result = fprintf(__stream, "  JpegInterchangeFormatLength: %llu\n", *(_QWORD *)(v3 + 280));
  v7 = *(_DWORD *)(v6 + 80);
  if ((v7 & 0x10) == 0)
  {
LABEL_5:
    if ((v7 & 0x20) == 0)
      goto LABEL_6;
    goto LABEL_18;
  }
LABEL_14:
  fwrite("  JpegQTables:", 0xEuLL, 1uLL, __stream);
  if (*(_BYTE *)(v3 + 295))
  {
    v9 = 0;
    do
      fprintf(__stream, " %llu", *(_QWORD *)(v3 + 304 + 8 * v9++));
    while (v9 < *(unsigned __int8 *)(v3 + 295));
  }
  result = fputc(10, __stream);
  v7 = *(_DWORD *)(v6 + 80);
  if ((v7 & 0x20) == 0)
  {
LABEL_6:
    if ((v7 & 0x40) == 0)
      goto LABEL_7;
    goto LABEL_22;
  }
LABEL_18:
  fwrite("  JpegDcTables:", 0xFuLL, 1uLL, __stream);
  if (*(_BYTE *)(v3 + 296))
  {
    v10 = 0;
    do
      fprintf(__stream, " %llu", *(_QWORD *)(v3 + 328 + 8 * v10++));
    while (v10 < *(unsigned __int8 *)(v3 + 296));
  }
  result = fputc(10, __stream);
  v7 = *(_DWORD *)(v6 + 80);
  if ((v7 & 0x40) == 0)
  {
LABEL_7:
    if ((v7 & 0x80) == 0)
      goto LABEL_8;
    goto LABEL_26;
  }
LABEL_22:
  fwrite("  JpegAcTables:", 0xFuLL, 1uLL, __stream);
  if (*(_BYTE *)(v3 + 297))
  {
    v11 = 0;
    do
      fprintf(__stream, " %llu", *(_QWORD *)(v3 + 352 + 8 * v11++));
    while (v11 < *(unsigned __int8 *)(v3 + 297));
  }
  result = fputc(10, __stream);
  v7 = *(_DWORD *)(v6 + 80);
  if ((v7 & 0x80) == 0)
  {
LABEL_8:
    if ((v7 & 0x100) == 0)
      goto LABEL_10;
    goto LABEL_9;
  }
LABEL_26:
  result = fprintf(__stream, "  JpegProc: %hhu\n", *(unsigned __int8 *)(v3 + 288));
  if ((*(_DWORD *)(v6 + 80) & 0x100) != 0)
LABEL_9:
    result = fprintf(__stream, "  JpegRestartInterval: %hu\n", *(unsigned __int16 *)(v3 + 472));
LABEL_10:
  v8 = *(uint64_t (**)(uint64_t, FILE *, uint64_t))(v3 + 232);
  if (v8)
    return v8(v6, __stream, a3);
  return result;
}

uint64_t OJPEGSubsamplingCorrect(uint64_t result, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  BOOL v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  BOOL v21;
  char v22;

  v8 = *(_QWORD *)(result + 1096);
  if (*(_BYTE *)(v8 + 290))
    OJPEGSubsamplingCorrect_cold_1();
  v9 = result;
  if (*(_WORD *)(result + 130) != 3
    || ((v10 = *(unsigned __int16 *)(result + 122), v10 != 6) ? (v11 = v10 == 10) : (v11 = 1), !v11))
  {
    if (*(_BYTE *)(v8 + 291))
      result = TIFFWarningExtR(result, "OJPEGSubsamplingCorrect", "Subsampling tag not appropriate for this Photometric and/or SamplesPerPixel", a4, a5, a6, a7, a8, v22);
    *(_WORD *)(v8 + 292) = 257;
    *(_BYTE *)(v8 + 294) = 0;
    goto LABEL_14;
  }
  v12 = *(unsigned __int8 *)(v8 + 292);
  v13 = *(unsigned __int8 *)(v8 + 293);
  *(_WORD *)(v8 + 289) = 257;
  result = OJPEGReadHeaderInfoSec(result, a2, a3, a4, a5, a6, a7, a8);
  v19 = *(unsigned __int8 *)(v8 + 294);
  if (*(_BYTE *)(v8 + 294))
  {
    *(_WORD *)(v8 + 292) = 257;
    *(_BYTE *)(v8 + 289) = 0;
    if (v12 != 1)
      goto LABEL_23;
    LOBYTE(v12) = 1;
    LOBYTE(v20) = 1;
    goto LABEL_16;
  }
  v20 = *(unsigned __int8 *)(v8 + 292);
  *(_BYTE *)(v8 + 289) = 0;
  if (v20 == v12)
  {
LABEL_16:
    if (v19)
      v21 = 1;
    else
      v21 = *(unsigned __int8 *)(v8 + 293) == v13;
    if (v21)
      goto LABEL_23;
  }
  if (*(_BYTE *)(v8 + 291))
    result = TIFFWarningExtR(v9, "OJPEGSubsamplingCorrect", "Subsampling inside JPEG data [%hhu,%hhu] does not match subsampling tag values [%hhu,%hhu]; assuming subs"
               "ampling inside JPEG data is correct",
               v14,
               v15,
               v16,
               v17,
               v18,
               v20);
  else
    result = TIFFWarningExtR(v9, "OJPEGSubsamplingCorrect", "Subsampling tag is not set, yet subsampling inside JPEG data [%hhu,%hhu] does not match default values [2,2]; assuming subsampling inside JPEG data is correct",
               v14,
               v15,
               v16,
               v17,
               v18,
               v20);
LABEL_23:
  if (!*(_BYTE *)(v8 + 294)
    || (!*(_BYTE *)(v8 + 291)
      ? (result = TIFFWarningExtR(v9, "OJPEGSubsamplingCorrect", "Subsampling tag is not set, yet subsampling inside JPEG data does not match default values [2,2] (nor any other values allowed in TIFF); assuming subsampling inside JPEG data is correct and desubsampl"
                    "ing inside JPEG decompression",
                    v14,
                    v15,
                    v16,
                    v17,
                    v18,
                    v22))
      : (result = TIFFWarningExtR(v9, "OJPEGSubsamplingCorrect", "Subsampling inside JPEG data does not match subsampling tag values [%hhu,%hhu] (nor any other values allowed in TIFF); assuming subsampling inside JPEG data is correct and desubsampling inside JPEG decompression",
                    v14,
                    v15,
                    v16,
                    v17,
                    v18,
                    v12)),
        !*(_BYTE *)(v8 + 294)))
  {
    if (*(unsigned __int8 *)(v8 + 292) < *(unsigned __int8 *)(v8 + 293))
      result = TIFFWarningExtR(v9, "OJPEGSubsamplingCorrect", "Subsampling values [%hhu,%hhu] are not allowed in TIFF", v14, v15, v16, v17, v18, *(_BYTE *)(v8 + 292));
  }
LABEL_14:
  *(_BYTE *)(v8 + 290) = 1;
  return result;
}

uint64_t OJPEGReadHeaderInfoSec(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  BOOL v13;
  __int16 v14;
  uint64_t result;
  unsigned __int8 *v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  __int16 v23;
  unsigned __int16 v24;
  uint64_t v25;
  unsigned __int16 v26;
  char *v27;
  char *v28;
  _BYTE *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  uint64_t v34;
  unsigned __int8 v35;
  int v36;
  int v37;
  _QWORD *v38;
  char *v39;
  unsigned __int8 *v40;
  uint64_t v41;
  uint64_t v42;
  char **v43;
  uint64_t v44;
  uint64_t v45;
  const char *v46;
  uint64_t v47;
  unsigned int v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  char *v55;
  uint64_t v56;
  unint64_t v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  char *v61;
  uint64_t v62;
  char *v63;
  uint64_t v64;
  unsigned int v65;
  unint64_t v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint16x8_t v76;
  uint16x8_t v77;
  uint64_t v78;
  __int32 v79;
  char *v80;
  uint64_t v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  unint64_t v85;
  char v86;
  unsigned __int16 v87;
  unsigned __int8 v88;
  unsigned __int16 v89;
  unsigned __int8 v90;
  uint8x16_t v91;
  uint64_t v92;

  v92 = *MEMORY[0x1E0C80C00];
  v9 = *(_QWORD *)(a1 + 1096);
  v87 = 0;
  v10 = *(_QWORD *)(v9 + 240);
  if (!v10)
  {
    v10 = (*(uint64_t (**)(_QWORD))(a1 + 1240))(*(_QWORD *)(a1 + 1200));
    *(_QWORD *)(v9 + 240) = v10;
  }
  v11 = *(_QWORD *)(v9 + 272);
  if (v11)
  {
    if (v10 <= v11)
    {
      *(_QWORD *)(v9 + 272) = 0;
      *(_QWORD *)(v9 + 280) = 0;
    }
    else
    {
      v12 = *(_QWORD *)(v9 + 280);
      v13 = __CFADD__(v12, v11);
      if (!v12 || v13 || v12 + v11 > v10)
        *(_QWORD *)(v9 + 280) = v10 - v11;
    }
  }
  v14 = 0;
  *(_QWORD *)(v9 + 1608) = 0;
  *(_DWORD *)(v9 + 1616) = *(_DWORD *)(a1 + 228);
  *(_QWORD *)(v9 + 1640) = 0;
  *(_WORD *)(v9 + 1648) = 0;
  while (2)
  {
    if (!v14)
    {
      result = OJPEGReadBufferFill(v9);
      if (!(_DWORD)result)
        return result;
      v14 = *(_WORD *)(v9 + 1648);
      if (!v14)
        OJPEGReadHeaderInfoSec_cold_1();
    }
    v16 = *(unsigned __int8 **)(v9 + 1656);
    v88 = *v16;
    if (v88 == 255)
    {
      *(_QWORD *)(v9 + 1656) = v16 + 1;
      *(_WORD *)(v9 + 1648) = v14 - 1;
LABEL_19:
      result = OJPEGReadByte(v9, &v88);
      if (!(_DWORD)result)
        return result;
      v17 = v88;
      switch(v88)
      {
        case 0xC0u:
        case 0xC1u:
        case 0xC3u:
          v18 = *(_QWORD *)(a1 + 1096);
          if (*(_BYTE *)(v18 + 475))
          {
            v46 = "OJPEGReadHeaderInfoSecStreamSof";
LABEL_147:
            v61 = "Corrupt JPEG data";
            goto LABEL_194;
          }
          if (!*(_BYTE *)(v18 + 289))
            *(_BYTE *)(v18 + 476) = v88;
          v91.i16[0] = 0;
          if (!OJPEGReadWord(v18, &v91))
            return 0;
          if (v91.u16[0] <= 0xAu)
            goto LABEL_143;
          v19 = (unsigned __int16)(v91.i16[0] - 8) / 3u;
          v20 = *(unsigned __int8 *)(v18 + 289);
          if (v91.i16[0] - 8 != 3 * ((unsigned __int16)((unsigned __int16)(v91.i16[0] - 8) / 0x18000u) >> 1))
            goto LABEL_144;
          if (!*(_BYTE *)(v18 + 289) && (_DWORD)v19 != *(unsigned __int8 *)(v18 + 268))
          {
            v46 = "OJPEGReadHeaderInfoSecStreamSof";
            v61 = "JPEG compressed data indicates unexpected number of samples";
            goto LABEL_194;
          }
          v90 = 0;
          if (!OJPEGReadByte(v18, &v90))
            return 0;
          if (v90 != 8)
          {
            if (!*(_BYTE *)(v18 + 289))
            {
              v46 = "OJPEGReadHeaderInfoSecStreamSof";
              v61 = "JPEG compressed data indicates unexpected number of bits per sample";
              goto LABEL_194;
            }
            return 0;
          }
          if (*(_BYTE *)(v18 + 289))
          {
            OJPEGReadSkip(v18, 4u);
          }
          else
          {
            v89 = 0;
            if (!OJPEGReadWord(v18, &v89))
              return 0;
            if (*(_DWORD *)(v18 + 252) > v89 && *(_DWORD *)(v18 + 264) > v89)
            {
              v46 = "OJPEGReadHeaderInfoSecStreamSof";
              v61 = "JPEG compressed data indicates unexpected height";
              goto LABEL_194;
            }
            *(_DWORD *)(v18 + 484) = v89;
            if (!OJPEGReadWord(v18, &v89))
              return 0;
            v33 = *(_DWORD *)(v18 + 256);
            if (*(_DWORD *)(v18 + 248) > v89 && v33 > v89)
            {
              v46 = "OJPEGReadHeaderInfoSecStreamSof";
              v61 = "JPEG compressed data indicates unexpected width";
              goto LABEL_194;
            }
            if (v33 < v89)
            {
              v46 = "OJPEGReadHeaderInfoSecStreamSof";
              v61 = "JPEG compressed data image width exceeds expected image width";
              goto LABEL_194;
            }
            *(_DWORD *)(v18 + 480) = v89;
          }
          if (!OJPEGReadByte(v18, &v90))
            return 0;
          if ((_DWORD)v19 != v90)
          {
LABEL_143:
            v20 = *(unsigned __int8 *)(v18 + 289);
LABEL_144:
            if (!v20)
            {
              v46 = "OJPEGReadHeaderInfoSecStreamSof";
              v61 = "Corrupt SOF marker in JPEG data";
              goto LABEL_194;
            }
            return 0;
          }
          if (!OJPEGReadByte(v18, &v90))
            return 0;
          v34 = 0;
          while (2)
          {
            if (!*(_BYTE *)(v18 + 289))
              *(_BYTE *)(v18 + v34 + 488) = v90;
            if (!OJPEGReadByte(v18, &v90))
              return 0;
            if (*(_BYTE *)(v18 + 289))
            {
              v35 = v90;
              if (v34)
              {
                if (v90 == 17)
                  goto LABEL_83;
              }
              else
              {
                *(_BYTE *)(v18 + 292) = v90 >> 4;
                *(_BYTE *)(v18 + 293) = v35 & 0xF;
              }
              *(_BYTE *)(v18 + 294) = 1;
            }
            else
            {
              v36 = v90;
              *(_BYTE *)(v18 + v34 + 491) = v90;
              if (!*(_BYTE *)(v18 + 294))
              {
                if (v34)
                {
                  if (v36 != 17)
                    goto LABEL_150;
                }
                else if ((*(unsigned __int8 *)(v18 + 293) | (16 * *(unsigned __int8 *)(v18 + 292))) != v36)
                {
LABEL_150:
                  v46 = "OJPEGReadHeaderInfoSecStreamSof";
                  v61 = "JPEG compressed data indicates unexpected subsampling values";
                  goto LABEL_194;
                }
              }
            }
LABEL_83:
            if (!OJPEGReadByte(v18, &v90))
              return 0;
            if (*(_BYTE *)(v18 + 289))
            {
              if (++v34 == v19)
                goto LABEL_101;
LABEL_88:
              if (!OJPEGReadByte(v18, &v90))
                return 0;
              continue;
            }
            break;
          }
          *(_BYTE *)(v18 + v34++ + 494) = v90;
          if (v34 != v19)
            goto LABEL_88;
          *(_BYTE *)(v18 + 475) = 1;
LABEL_101:
          if (*(_BYTE *)(v9 + 289))
            return 1;
LABEL_102:
          if (v17 == 218)
            break;
LABEL_25:
          v14 = *(_WORD *)(v9 + 1648);
          continue;
        case 0xC4u:
          v21 = *(_QWORD *)(a1 + 1096);
          v91.i16[0] = 0;
          if (!OJPEGReadWord(v21, &v91))
            return 0;
          v23 = v91.i16[0];
          v24 = v91.i16[0] - 2;
          if (v91.u16[0] <= 2u)
          {
            if (!*(_BYTE *)(v21 + 289))
            {
              v46 = "OJPEGReadHeaderInfoSecStreamDht";
              v61 = "Corrupt DHT marker in JPEG data";
              goto LABEL_194;
            }
            return 0;
          }
          if (*(_BYTE *)(v21 + 289))
          {
            OJPEGReadSkip(v21, (unsigned __int16)(v91.i16[0] - 2));
            goto LABEL_25;
          }
          v37 = v91.u16[0] + 6;
          v38 = _TIFFmallocExt((_QWORD *)a1, v91.u16[0] + 6, v22, a4, a5, a6, a7, a8);
          if (!v38)
          {
            v46 = "OJPEGReadHeaderInfoSecStreamDht";
LABEL_152:
            v61 = "Out of memory";
            goto LABEL_194;
          }
          v39 = (char *)v38;
          *(_DWORD *)v38 = v37;
          *((_WORD *)v38 + 2) = -15105;
          *((_BYTE *)v38 + 6) = HIBYTE(v23);
          *((_BYTE *)v38 + 7) = v23;
          v40 = (unsigned __int8 *)(v38 + 1);
          if (!OJPEGReadBlock(v21, v24, (char *)v38 + 8))
            goto LABEL_198;
          v41 = *v40;
          if ((v41 & 0xF0) == 0x10)
          {
            v44 = v41 & 0xF;
            if (v44 < 4)
            {
              v45 = v21 + 8 * v44;
              a2 = *(char **)(v45 + 440);
              if (a2)
                _TIFFfreeExt(a1, a2);
              v43 = (char **)(v45 + 440);
              goto LABEL_108;
            }
          }
          else if ((v41 & 0xF0) == 0 && v41 < 4)
          {
            v42 = v21 + 8 * v41;
            a2 = *(char **)(v42 + 408);
            if (a2)
              _TIFFfreeExt(a1, a2);
            v43 = (char **)(v42 + 408);
LABEL_108:
            *v43 = v39;
            goto LABEL_25;
          }
          TIFFErrorExtR(a1, "OJPEGReadHeaderInfoSecStreamDht", "Corrupt DHT marker in JPEG data", a4, a5, a6, a7, a8, v86);
LABEL_198:
          v62 = a1;
          v63 = v39;
          goto LABEL_199;
        case 0xD8u:
          goto LABEL_25;
        case 0xDAu:
          if (*(_BYTE *)(v9 + 289))
            return 1;
          if (*(_BYTE *)(v9 + 269))
            OJPEGReadHeaderInfoSec_cold_2();
          result = OJPEGReadHeaderInfoSecStreamSos(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
          if ((_DWORD)result)
            goto LABEL_113;
          return result;
        case 0xDBu:
          v25 = *(_QWORD *)(a1 + 1096);
          v91.i16[0] = 0;
          if (!OJPEGReadWord(v25, &v91))
            return 0;
          v26 = v91.i16[0] - 2;
          if (v91.u16[0] <= 2u)
          {
            if (*(_BYTE *)(v25 + 289))
              return 0;
LABEL_161:
            v46 = "OJPEGReadHeaderInfoSecStreamDqt";
            v61 = "Corrupt DQT marker in JPEG data";
            goto LABEL_194;
          }
          if (*(_BYTE *)(v25 + 289))
          {
            OJPEGReadSkip(v25, (unsigned __int16)(v91.i16[0] - 2));
            goto LABEL_102;
          }
          while (1)
          {
            if (v26 <= 0x40u)
              goto LABEL_161;
            v27 = (char *)_TIFFmallocExt((_QWORD *)a1, 73, a3, a4, a5, a6, a7, a8);
            if (!v27)
              break;
            v28 = v27;
            *(_DWORD *)v27 = 73;
            *((_DWORD *)v27 + 1) = 1124129791;
            v29 = v27 + 8;
            if (!OJPEGReadBlock(v25, 65, v27 + 8))
              goto LABEL_154;
            v30 = *v29 & 0xF;
            if (v30 >= 4)
            {
              TIFFErrorExtR(a1, "OJPEGReadHeaderInfoSecStreamDqt", "Corrupt DQT marker in JPEG data", a4, a5, a6, a7, a8, v86);
LABEL_154:
              v62 = a1;
              v63 = v28;
LABEL_199:
              _TIFFfreeExt(v62, v63);
              return 0;
            }
            v31 = v25 + 8 * v30;
            a2 = *(char **)(v31 + 376);
            if (a2)
              _TIFFfreeExt(a1, a2);
            *(_QWORD *)(v31 + 376) = v28;
            v26 -= 65;
            if (!v26)
              goto LABEL_102;
          }
          v46 = "OJPEGReadHeaderInfoSecStreamDqt";
          goto LABEL_152;
        case 0xDDu:
          v32 = *(_QWORD *)(a1 + 1096);
          v91.i16[0] = 0;
          if (!OJPEGReadWord(v32, &v91))
            return 0;
          if (v91.u16[0] != 4)
          {
            v46 = "OJPEGReadHeaderInfoSecStreamDri";
            v61 = "Corrupt DRI marker in JPEG data";
            goto LABEL_194;
          }
          if (!OJPEGReadWord(v32, &v91))
            return 0;
          *(_WORD *)(v32 + 472) = v91.i16[0];
          goto LABEL_25;
        case 0xE0u:
        case 0xE1u:
        case 0xE2u:
        case 0xE3u:
        case 0xE4u:
        case 0xE5u:
        case 0xE6u:
        case 0xE7u:
        case 0xE8u:
        case 0xE9u:
        case 0xEAu:
        case 0xEBu:
        case 0xECu:
        case 0xEDu:
        case 0xEEu:
        case 0xEFu:
        case 0xFEu:
          result = OJPEGReadWord(v9, &v87);
          if (!(_DWORD)result)
            return result;
          if (v87 > 1u)
          {
            if (v87 != 2)
              OJPEGReadSkip(v9, (unsigned __int16)(v87 - 2));
            goto LABEL_25;
          }
          if (*(_BYTE *)(v9 + 289))
            return 0;
          v46 = "OJPEGReadHeaderInfoSec";
          goto LABEL_147;
        case 0xFFu:
          goto LABEL_19;
        default:
          TIFFErrorExtR(a1, "OJPEGReadHeaderInfoSec", "Unknown marker type %hhu in JPEG data", a4, a5, a6, a7, a8, v88);
          return 0;
      }
    }
    break;
  }
LABEL_113:
  if (*(_BYTE *)(v9 + 289) || *(_BYTE *)(v9 + 475))
    return 1;
  v47 = *(_QWORD *)(a1 + 1096);
  if (!*(_QWORD *)(v47 + 304))
  {
    v46 = "OJPEGReadHeaderInfoSecTablesQTable";
LABEL_193:
    v61 = "Missing JPEG tables";
    goto LABEL_194;
  }
  *(_BYTE *)(v47 + 1632) = 0;
  v48 = *(unsigned __int8 *)(v47 + 268);
  if (*(_BYTE *)(v47 + 268))
  {
    v49 = 0;
    v50 = -1;
    while (1)
    {
      v51 = v47 + 8 * v49;
      v52 = *(_QWORD *)(v51 + 304);
      if (!v52)
        break;
      if (v49)
      {
        v53 = v49 - 1;
        if (v52 == *(_QWORD *)(v47 + 8 * (v49 - 1) + 304))
          goto LABEL_134;
        if (v49 >= 2)
        {
          v54 = 0;
          do
          {
            if (v52 == *(_QWORD *)(v47 + 304 + 8 * v54))
            {
              v46 = "OJPEGReadHeaderInfoSecTablesQTable";
              v61 = "Corrupt JpegQTables tag value";
              goto LABEL_194;
            }
            ++v54;
          }
          while (v50 != v54);
        }
      }
      v55 = (char *)_TIFFmallocExt((_QWORD *)a1, 73, a3, a4, a5, a6, a7, a8);
      if (!v55)
      {
        v46 = "OJPEGReadHeaderInfoSecTablesQTable";
        goto LABEL_152;
      }
      v39 = v55;
      *(_DWORD *)v55 = 73;
      *((_DWORD *)v55 + 1) = 1124129791;
      v55[8] = v49;
      (*(void (**)(_QWORD, _QWORD, _QWORD))(a1 + 1224))(*(_QWORD *)(a1 + 1200), *(_QWORD *)(v51 + 304), 0);
      if ((*(unsigned int (**)(_QWORD, char *, uint64_t))(a1 + 1208))(*(_QWORD *)(a1 + 1200), v39 + 9, 64) != 64)
        goto LABEL_198;
      v56 = v47 + 8 * v49;
      a2 = *(char **)(v56 + 376);
      if (a2)
        _TIFFfreeExt(a1, a2);
      *(_QWORD *)(v56 + 376) = v39;
      *(_BYTE *)(v47 + v49 + 494) = v49;
      v48 = *(unsigned __int8 *)(v47 + 268);
LABEL_135:
      ++v49;
      ++v50;
      if (v49 >= v48)
        goto LABEL_136;
    }
    v53 = v49 - 1;
LABEL_134:
    *(_BYTE *)(v47 + 494 + v49) = *(_BYTE *)(v47 + 494 + v53);
    goto LABEL_135;
  }
LABEL_136:
  *(_BYTE *)(v9 + 476) = -64;
  v57 = *(unsigned __int8 *)(v9 + 268);
  if (*(_BYTE *)(v9 + 268))
  {
    v58 = 0;
    do
    {
      *(_BYTE *)(v9 + 488 + v58) = v58;
      ++v58;
    }
    while (v58 < v57);
    *(_BYTE *)(v9 + 491) = *(_BYTE *)(v9 + 293) | (16 * *(_BYTE *)(v9 + 292));
    if (v57 >= 2)
    {
      v59 = 492;
      do
      {
        *(_BYTE *)(v9 + v59) = 17;
        v60 = v59 - 490;
        ++v59;
      }
      while (v60 < v57);
    }
  }
  else
  {
    *(_BYTE *)(v9 + 491) = *(_BYTE *)(v9 + 293) | (16 * *(_BYTE *)(v9 + 292));
  }
  *(_DWORD *)(v9 + 480) = *(_DWORD *)(v9 + 256);
  *(_DWORD *)(v9 + 484) = *(_DWORD *)(v9 + 264);
  *(_BYTE *)(v9 + 475) = 1;
  v64 = *(_QWORD *)(a1 + 1096);
  if (!*(_QWORD *)(v64 + 328))
  {
    v46 = "OJPEGReadHeaderInfoSecTablesDcTable";
    goto LABEL_193;
  }
  *(_BYTE *)(v64 + 1632) = 0;
  v65 = *(unsigned __int8 *)(v64 + 268);
  if (*(_BYTE *)(v64 + 268))
  {
    v66 = 0;
    v91 = 0uLL;
    v67 = -1;
    while (1)
    {
      a2 = *(char **)(v64 + 8 * v66 + 328);
      if (!a2)
        break;
      if (v66)
      {
        v68 = v66 - 1;
        if (a2 == *(char **)(v64 + 8 * (v66 - 1) + 328))
          goto LABEL_185;
        if (v66 >= 2)
        {
          v69 = 0;
          while (a2 != *(char **)(v64 + 328 + 8 * v69))
          {
            if (v67 == ++v69)
              goto LABEL_176;
          }
          v46 = "OJPEGReadHeaderInfoSecTablesDcTable";
          v61 = "Corrupt JpegDcTables tag value";
LABEL_194:
          TIFFErrorExtR(a1, v46, v61, a4, a5, a6, a7, a8, v86);
          return 0;
        }
      }
LABEL_176:
      (*(void (**)(_QWORD))(a1 + 1224))(*(_QWORD *)(a1 + 1200));
      if ((*(unsigned int (**)(_QWORD, uint8x16_t *, uint64_t))(a1 + 1208))(*(_QWORD *)(a1 + 1200), &v91, 16) != 16)return 0;
      v76 = vmovl_high_u8(v91);
      v77 = vmovl_u8(*(uint8x8_t *)v91.i8);
      v77.i32[0] = vaddvq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v77.i8, *(uint16x4_t *)v76.i8), (int32x4_t)vaddl_high_u16(v77, v76)));
      v78 = v77.u32[0];
      v79 = v77.i32[0] + 25;
      v80 = (char *)_TIFFmallocExt((_QWORD *)a1, (v77.i32[0] + 25), v70, v71, v72, v73, v74, v75);
      if (!v80)
      {
        v46 = "OJPEGReadHeaderInfoSecTablesDcTable";
        goto LABEL_152;
      }
      v39 = v80;
      v81 = 0;
      *(_DWORD *)v80 = v79;
      *((_WORD *)v80 + 2) = -15105;
      v80[6] = (unsigned __int16)(v78 + 19) >> 8;
      v80[7] = v78 + 19;
      v80[8] = v66;
      do
      {
        v80[v81 + 9] = v91.i8[v81];
        ++v81;
      }
      while (v81 != 16);
      if ((_DWORD)v78 != (*(unsigned int (**)(_QWORD, char *, uint64_t))(a1 + 1208))(*(_QWORD *)(a1 + 1200), v80 + 25, v78))goto LABEL_198;
      v82 = v64 + 8 * v66;
      a2 = *(char **)(v82 + 408);
      if (a2)
        _TIFFfreeExt(a1, a2);
      *(_QWORD *)(v82 + 408) = v39;
      *(_BYTE *)(v64 + v66 + 500) = 16 * v66;
      v65 = *(unsigned __int8 *)(v64 + 268);
LABEL_186:
      ++v66;
      ++v67;
      if (v66 >= v65)
        goto LABEL_187;
    }
    v68 = v66 - 1;
LABEL_185:
    *(_BYTE *)(v64 + 500 + v66) = *(_BYTE *)(v64 + 500 + v68);
    goto LABEL_186;
  }
LABEL_187:
  result = OJPEGReadHeaderInfoSecTablesAcTable(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (!(_DWORD)result)
    return result;
  v83 = *(unsigned __int8 *)(v9 + 268);
  if (v83 < 2)
    return 1;
  v84 = 498;
  result = 1;
  do
  {
    *(_BYTE *)(v9 + v84) = v84 + 15;
    v85 = v84 - 496;
    ++v84;
  }
  while (v85 < v83);
  return result;
}

uint64_t OJPEGReadByte(uint64_t a1, _BYTE *a2)
{
  uint64_t result;

  if (!*(_WORD *)(a1 + 1648))
  {
    result = OJPEGReadBufferFill(a1);
    if (!(_DWORD)result)
      return result;
    if (!*(_WORD *)(a1 + 1648))
      OJPEGReadByte_cold_1();
  }
  *a2 = *(_BYTE *)(*(_QWORD *)(a1 + 1656))++;
  --*(_WORD *)(a1 + 1648);
  return 1;
}

uint64_t OJPEGReadWord(uint64_t a1, _WORD *a2)
{
  uint64_t result;
  unsigned __int8 v5;

  v5 = 0;
  result = OJPEGReadByte(a1, &v5);
  if ((_DWORD)result)
  {
    *a2 = v5 << 8;
    result = OJPEGReadByte(a1, &v5);
    if ((_DWORD)result)
    {
      *a2 |= v5;
      return 1;
    }
  }
  return result;
}

uint64_t OJPEGReadSkip(uint64_t result, unsigned int a2)
{
  unsigned int v2;
  uint64_t v3;
  unsigned __int16 v4;
  unint64_t v5;

  v2 = *(unsigned __int16 *)(result + 1648);
  if (v2 >= a2)
    v3 = a2;
  else
    v3 = *(unsigned __int16 *)(result + 1648);
  *(_QWORD *)(result + 1656) += v3;
  *(_WORD *)(result + 1648) = v2 - v3;
  if (v2 < a2)
  {
    v4 = a2 - v3;
    v5 = *(_QWORD *)(result + 1640);
    if (v5 < v4)
      v4 = *(_QWORD *)(result + 1640);
    *(_QWORD *)(result + 1624) += v4;
    *(_QWORD *)(result + 1640) = v5 - v4;
    *(_BYTE *)(result + 1632) = 0;
  }
  return result;
}

uint64_t OJPEGReadHeaderInfoSecStreamSos(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned __int8 *v8;
  uint64_t result;
  uint64_t v11;
  char v12;
  unsigned __int8 v13;
  unsigned __int16 v14;

  v8 = *(unsigned __int8 **)(a1 + 1096);
  if (v8[289])
    OJPEGReadHeaderInfoSecStreamSos_cold_1();
  if (!v8[475])
    goto LABEL_13;
  v14 = 0;
  result = OJPEGReadWord((uint64_t)v8, &v14);
  if (!(_DWORD)result)
    return result;
  if (2 * v8[270] + 6 != v14)
    goto LABEL_13;
  v13 = 0;
  result = OJPEGReadByte((uint64_t)v8, &v13);
  if (!(_DWORD)result)
    return result;
  if (v13 == v8[270])
  {
    if (v13)
    {
      v11 = 0;
      while (1)
      {
        result = OJPEGReadByte((uint64_t)v8, &v13);
        if (!(_DWORD)result)
          break;
        v8[v11 + 497 + v8[269]] = v13;
        result = OJPEGReadByte((uint64_t)v8, &v13);
        if (!(_DWORD)result)
          break;
        v8[v11++ + 500 + v8[269]] = v13;
        if (v11 >= v8[270])
          goto LABEL_12;
      }
    }
    else
    {
LABEL_12:
      OJPEGReadSkip((uint64_t)v8, 3u);
      return 1;
    }
  }
  else
  {
LABEL_13:
    TIFFErrorExtR(a1, "OJPEGReadHeaderInfoSecStreamSos", "Corrupt SOS marker in JPEG data", a4, a5, a6, a7, a8, v12);
    return 0;
  }
  return result;
}

uint64_t OJPEGReadHeaderInfoSecTablesAcTable(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  unsigned int v10;
  unint64_t v11;
  uint64_t v12;
  int64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint16x8_t v21;
  uint16x8_t v22;
  uint64_t v23;
  __int32 v24;
  char *v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  char *v31;
  uint8x16_t v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v9 = *(_QWORD *)(a1 + 1096);
  if (*(_QWORD *)(v9 + 352))
  {
    *(_BYTE *)(v9 + 1632) = 0;
    v10 = *(unsigned __int8 *)(v9 + 268);
    if (*(_BYTE *)(v9 + 268))
    {
      v11 = 0;
      v32 = 0uLL;
      while (1)
      {
        v12 = *(_QWORD *)(v9 + 8 * v11 + 352);
        if (!v12)
          break;
        if (v11)
        {
          v13 = v11 - 1;
          if (v12 == *(_QWORD *)(v9 + 8 * (v11 - 1) + 352))
            goto LABEL_20;
          if (v11 >= 2)
          {
            v14 = 0;
            while (v12 != *(_QWORD *)(v9 + 8 * v14 + 352))
            {
              if (v13 <= ++v14)
                goto LABEL_11;
            }
            v31 = "Corrupt JpegAcTables tag value";
            goto LABEL_25;
          }
        }
LABEL_11:
        (*(void (**)(_QWORD))(a1 + 1224))(*(_QWORD *)(a1 + 1200));
        if ((*(unsigned int (**)(_QWORD, uint8x16_t *, uint64_t))(a1 + 1208))(*(_QWORD *)(a1 + 1200), &v32, 16) != 16)return 0;
        v21 = vmovl_high_u8(v32);
        v22 = vmovl_u8(*(uint8x8_t *)v32.i8);
        v22.i32[0] = vaddvq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v22.i8, *(uint16x4_t *)v21.i8), (int32x4_t)vaddl_high_u16(v22, v21)));
        v23 = v22.u32[0];
        v24 = v22.i32[0] + 25;
        v25 = (char *)_TIFFmallocExt((_QWORD *)a1, (v22.i32[0] + 25), v15, v16, v17, v18, v19, v20);
        if (!v25)
        {
          v31 = "Out of memory";
          goto LABEL_25;
        }
        v26 = v25;
        v27 = 0;
        *(_DWORD *)v25 = v24;
        *((_WORD *)v25 + 2) = -15105;
        v25[6] = (unsigned __int16)(v23 + 19) >> 8;
        v25[7] = v23 + 19;
        v25[8] = v11 | 0x10;
        do
        {
          v25[v27 + 9] = v32.i8[v27];
          ++v27;
        }
        while (v27 != 16);
        if ((_DWORD)v23 != (*(unsigned int (**)(_QWORD, char *, uint64_t))(a1 + 1208))(*(_QWORD *)(a1 + 1200), v25 + 25, v23))
        {
          _TIFFfreeExt(a1, v26);
          return 0;
        }
        v28 = v9 + 8 * v11;
        v29 = *(char **)(v28 + 440);
        if (v29)
          _TIFFfreeExt(a1, v29);
        *(_QWORD *)(v28 + 440) = v26;
        *(_BYTE *)(v9 + v11 + 500) |= v11;
        v10 = *(unsigned __int8 *)(v9 + 268);
LABEL_21:
        if (++v11 >= v10)
          return 1;
      }
      v13 = v11 - 1;
LABEL_20:
      *(_BYTE *)(v9 + 500 + v11) |= *(_BYTE *)(v9 + 500 + v13) & 0xF;
      goto LABEL_21;
    }
    return 1;
  }
  else
  {
    v31 = "Missing JPEG tables";
LABEL_25:
    TIFFErrorExtR(a1, "OJPEGReadHeaderInfoSecTablesAcTable", v31, a4, a5, a6, a7, a8, v32.i8[0]);
    return 0;
  }
}

uint64_t OJPEGReadBufferFill(uint64_t a1)
{
  unint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t result;
  unint64_t v12;
  BOOL v13;
  unint64_t v14;

  v2 = *(_QWORD *)(a1 + 1640);
  if (!v2)
  {
    do
    {
      *(_BYTE *)(a1 + 1632) = 0;
      v3 = *(_DWORD *)(a1 + 1608);
      if (v3 == 2)
      {
        v5 = *(unsigned int *)(a1 + 1612);
        if ((_DWORD)v5 == *(_DWORD *)(a1 + 1616))
        {
          v4 = 0;
          *(_DWORD *)(a1 + 1608) = 3;
        }
        else
        {
          v6 = TIFFGetStrileOffsetWithErr(*(_QWORD *)a1, v5);
          *(_QWORD *)(a1 + 1624) = v6;
          if (v6)
          {
            v7 = TIFFGetStrileByteCountWithErr(*(_QWORD *)a1, *(unsigned int *)(a1 + 1612));
            v8 = *(_QWORD *)(a1 + 1624);
            v9 = *(_QWORD *)(a1 + 240);
            if (v9 <= v8)
            {
              *(_QWORD *)(a1 + 1624) = 0;
            }
            else if (!v7 || (*(_QWORD *)(a1 + 1640) = v7, __CFADD__(v7, v8)) || v8 + v7 > v9)
            {
              *(_QWORD *)(a1 + 1640) = v9 - v8;
            }
          }
          ++*(_DWORD *)(a1 + 1612);
          v2 = *(_QWORD *)(a1 + 1640);
          v4 = v2;
        }
      }
      else if (v3 == 1)
      {
        v4 = 0;
        *(_DWORD *)(a1 + 1608) = 2;
      }
      else
      {
        if (v3)
          return 0;
        v4 = *(_QWORD *)(a1 + 272);
        if (v4)
        {
          *(_QWORD *)(a1 + 1624) = v4;
          v2 = *(_QWORD *)(a1 + 280);
          *(_QWORD *)(a1 + 1640) = v2;
          v4 = v2;
        }
        *(_DWORD *)(a1 + 1608) = 1;
      }
    }
    while (!v4);
  }
  if (!*(_BYTE *)(a1 + 1632))
  {
    (*(void (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)a1 + 1224))(*(_QWORD *)(*(_QWORD *)a1 + 1200), *(_QWORD *)(a1 + 1624), 0);
    *(_BYTE *)(a1 + 1632) = 1;
    v2 = *(_QWORD *)(a1 + 1640);
  }
  if (v2 >= 0x800)
    v10 = 2048;
  else
    v10 = (unsigned __int16)v2;
  result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)a1 + 1208))(*(_QWORD *)(*(_QWORD *)a1 + 1200), a1 + 1664, v10);
  if (result)
  {
    if (result <= 0)
      OJPEGReadBufferFill_cold_1();
    if ((unint64_t)result >= 0x801)
      OJPEGReadBufferFill_cold_2();
    v12 = *(_QWORD *)(a1 + 1640);
    v13 = v12 >= result;
    v14 = v12 - result;
    if (!v13)
      OJPEGReadBufferFill_cold_3();
    *(_WORD *)(a1 + 1648) = result;
    *(_QWORD *)(a1 + 1656) = a1 + 1664;
    *(_QWORD *)(a1 + 1640) = v14;
    *(_QWORD *)(a1 + 1624) += result;
    return 1;
  }
  return result;
}

uint64_t OJPEGReadBlock(uint64_t a1, int a2, char *__dst)
{
  unsigned __int16 v4;
  unsigned __int16 v6;
  uint64_t result;
  size_t v8;

  if (!a2)
    OJPEGReadBlock_cold_1();
  v4 = a2;
  v6 = *(_WORD *)(a1 + 1648);
  do
  {
    if (!v6)
    {
      result = OJPEGReadBufferFill(a1);
      if (!(_DWORD)result)
        return result;
      v6 = *(_WORD *)(a1 + 1648);
      if (!v6)
        OJPEGReadBlock_cold_2();
    }
    if (v4 >= v6)
      v8 = v6;
    else
      v8 = v4;
    _TIFFmemcpy(__dst, *(const void **)(a1 + 1656), v8);
    *(_QWORD *)(a1 + 1656) += v8;
    v6 = *(_WORD *)(a1 + 1648) - v8;
    *(_WORD *)(a1 + 1648) = v6;
    v4 -= v8;
    __dst += v8;
  }
  while (v4);
  return 1;
}

uint64_t OJPEGLibjpegSessionAbort(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;

  v1 = *(_QWORD *)(a1 + 1096);
  if (!*(_BYTE *)(v1 + 608))
    OJPEGLibjpegSessionAbort_cold_1();
  result = _cg_jpeg_destroy(v1 + 792);
  *(_BYTE *)(v1 + 608) = 0;
  return result;
}

uint64_t OJPEGLibjpegJpegErrorMgrOutputMessage(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _OWORD v8[12];
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v9 = 0;
  memset(v8, 0, sizeof(v8));
  (*(void (**)(uint64_t *, _OWORD *))(*a1 + 24))(a1, v8);
  return TIFFWarningExtR(a1[3], "LibJpeg", "%s", v2, v3, v4, v5, v6, (char)v8);
}

void OJPEGLibjpegJpegErrorMgrErrorExit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _OWORD v7[12];
  uint64_t v8;

  v8 = 0;
  memset(v7, 0, sizeof(v7));
  (*(void (**)(uint64_t *, _OWORD *))(*a1 + 24))(a1, v7);
  TIFFErrorExtR(a1[3], "LibJpeg", "%s", v2, v3, v4, v5, v6, (char)v7);
  siglongjmp((int *)(*(_QWORD *)(a1[3] + 1096) + 16), 1);
}

uint64_t jpeg_create_decompress_encap(uint64_t a1, char *a2)
{
  uint64_t v3;

  v3 = 0;
  if (!sigsetjmp((int *)(a1 + 16), 0))
  {
    _cg_jpeg_CreateDecompress(a2, 90, 664);
    return 1;
  }
  return v3;
}

uint64_t OJPEGLibjpegJpegSourceMgrFillInputBuffer(uint64_t a1)
{
  _WORD *v1;
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  _DWORD *v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  char *v12;
  _BYTE *v13;
  char v14;
  uint64_t v15;
  int v16;
  int v17;
  char v18;
  uint64_t v19;
  int v20;
  char *v21;
  _BYTE *v22;
  uint64_t v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  int v33;
  uint64_t v34;
  char v36;

  v1 = 0;
  v2 = 0;
  v3 = *(_QWORD *)(a1 + 24);
  v4 = *(_QWORD *)(v3 + 1096);
  while (2)
  {
    v5 = *(_DWORD *)(v4 + 3712);
    if (v5 >= 0x13)
      OJPEGLibjpegJpegSourceMgrFillInputBuffer_cold_1();
    switch(v5)
    {
      case 0u:
        v15 = *(_QWORD *)(v3 + 1096);
        v1 = (_WORD *)(v15 + 3716);
        *(_WORD *)(v15 + 3716) = -9985;
        v16 = *(_DWORD *)(v15 + 3712) + 1;
        goto LABEL_44;
      case 1u:
        v6 = *(_QWORD *)(v3 + 1096);
        v7 = *(_DWORD **)(v6 + 376);
        if (!v7)
          goto LABEL_29;
        goto LABEL_28;
      case 2u:
        v6 = *(_QWORD *)(v3 + 1096);
        v7 = *(_DWORD **)(v6 + 384);
        if (!v7)
          goto LABEL_29;
        goto LABEL_28;
      case 3u:
        v6 = *(_QWORD *)(v3 + 1096);
        v7 = *(_DWORD **)(v6 + 392);
        if (!v7)
          goto LABEL_29;
        goto LABEL_28;
      case 4u:
        v6 = *(_QWORD *)(v3 + 1096);
        v7 = *(_DWORD **)(v6 + 400);
        if (!v7)
          goto LABEL_29;
        goto LABEL_28;
      case 5u:
        v6 = *(_QWORD *)(v3 + 1096);
        v7 = *(_DWORD **)(v6 + 408);
        if (!v7)
          goto LABEL_29;
        goto LABEL_28;
      case 6u:
        v6 = *(_QWORD *)(v3 + 1096);
        v7 = *(_DWORD **)(v6 + 416);
        if (!v7)
          goto LABEL_29;
        goto LABEL_28;
      case 7u:
        v6 = *(_QWORD *)(v3 + 1096);
        v7 = *(_DWORD **)(v6 + 424);
        if (!v7)
          goto LABEL_29;
        goto LABEL_28;
      case 8u:
        v6 = *(_QWORD *)(v3 + 1096);
        v7 = *(_DWORD **)(v6 + 432);
        if (!v7)
          goto LABEL_29;
        goto LABEL_28;
      case 9u:
        v6 = *(_QWORD *)(v3 + 1096);
        v7 = *(_DWORD **)(v6 + 440);
        if (!v7)
          goto LABEL_29;
        goto LABEL_28;
      case 0xAu:
        v6 = *(_QWORD *)(v3 + 1096);
        v7 = *(_DWORD **)(v6 + 448);
        if (v7)
          goto LABEL_28;
        goto LABEL_29;
      case 0xBu:
        v6 = *(_QWORD *)(v3 + 1096);
        v7 = *(_DWORD **)(v6 + 456);
        if (!v7)
          goto LABEL_29;
        goto LABEL_28;
      case 0xCu:
        v6 = *(_QWORD *)(v3 + 1096);
        v7 = *(_DWORD **)(v6 + 464);
        if (!v7)
          goto LABEL_29;
LABEL_28:
        v2 = *v7 - 4;
        v1 = v7 + 1;
        LODWORD(v7) = v2;
        goto LABEL_29;
      case 0xDu:
        v6 = *(_QWORD *)(v3 + 1096);
        LODWORD(v7) = *(unsigned __int16 *)(v6 + 472);
        if (*(_WORD *)(v6 + 472))
        {
          v1 = (_WORD *)(v6 + 3716);
          *(_DWORD *)(v6 + 3716) = 67165695;
          *(_BYTE *)(v6 + 3720) = BYTE1(v7);
          *(_BYTE *)(v6 + 3721) = (_BYTE)v7;
          v2 = 6;
          LODWORD(v7) = 6;
        }
LABEL_29:
        ++*(_DWORD *)(v6 + 3712);
        goto LABEL_30;
      case 0xEu:
        v8 = *(_QWORD *)(v3 + 1096);
        v9 = *(unsigned __int8 *)(v8 + 270);
        if (v9 >= 0x53)
          OJPEGLibjpegJpegSourceMgrFillInputBuffer_cold_2();
        v1 = (_WORD *)(v8 + 3716);
        *(_BYTE *)(v8 + 3716) = -1;
        *(_BYTE *)(v8 + 3717) = *(_BYTE *)(v8 + 476);
        *(_BYTE *)(v8 + 3718) = 0;
        v10 = 3 * v9;
        *(_BYTE *)(v8 + 3719) = 3 * v9 + 8;
        *(_BYTE *)(v8 + 3720) = 8;
        *(_WORD *)(v8 + 3721) = bswap32(*(unsigned __int16 *)(v8 + 484)) >> 16;
        v11 = *(_DWORD *)(v8 + 480);
        *(_BYTE *)(v8 + 3723) = BYTE1(v11);
        *(_BYTE *)(v8 + 3724) = v11;
        *(_BYTE *)(v8 + 3725) = v9;
        if ((_DWORD)v9)
        {
          v12 = (char *)(*(unsigned __int8 *)(v8 + 269) + v8 + 494);
          v13 = (_BYTE *)(v8 + 3728);
          do
          {
            *(v13 - 2) = *(v12 - 6);
            *(v13 - 1) = *(v12 - 3);
            v14 = *v12++;
            *v13 = v14;
            v13 += 3;
            --v9;
          }
          while (v9);
        }
        v2 = v10 + 10;
        goto LABEL_62;
      case 0xFu:
        v8 = *(_QWORD *)(v3 + 1096);
        v19 = *(unsigned __int8 *)(v8 + 270);
        if (v19 >= 0x7D)
          OJPEGLibjpegJpegSourceMgrFillInputBuffer_cold_3();
        v1 = (_WORD *)(v8 + 3716);
        *(_WORD *)(v8 + 3716) = -9473;
        *(_BYTE *)(v8 + 3718) = 0;
        v20 = 2 * v19;
        *(_BYTE *)(v8 + 3719) = 2 * v19 + 6;
        *(_BYTE *)(v8 + 3720) = v19;
        if ((_DWORD)v19)
        {
          v21 = (char *)(*(unsigned __int8 *)(v8 + 269) + v8 + 500);
          v22 = (_BYTE *)(v8 + 3722);
          v23 = v19;
          do
          {
            *(v22 - 1) = *(v21 - 3);
            v24 = *v21++;
            *v22 = v24;
            v22 += 2;
            --v23;
          }
          while (v23);
          v25 = 2 * v19;
        }
        else
        {
          v25 = 0;
        }
        v34 = v8 + v25;
        *(_WORD *)(v34 + 3721) = 16128;
        *(_BYTE *)(v34 + 3723) = 0;
        v2 = v20 + 8;
LABEL_62:
        ++*(_DWORD *)(v8 + 3712);
        goto LABEL_63;
      case 0x10u:
        v26 = *(_QWORD *)(v3 + 1096);
        v2 = *(unsigned __int16 *)(v26 + 1648);
        if (!*(_WORD *)(v26 + 1648))
        {
          if (!OJPEGReadBufferFill(*(_QWORD *)(v3 + 1096)))
          {
            TIFFErrorExtR(v3, "LibJpeg", "Premature end of JPEG data", v27, v28, v29, v30, v31, v36);
            siglongjmp((int *)(*(_QWORD *)(v3 + 1096) + 16), 1);
          }
          v2 = *(unsigned __int16 *)(v26 + 1648);
          if (!*(_WORD *)(v26 + 1648))
            OJPEGLibjpegJpegSourceMgrFillInputBuffer_cold_4();
        }
        v1 = *(_WORD **)(v26 + 1656);
        *(_WORD *)(v26 + 1648) = 0;
        if (*(_QWORD *)(v26 + 1640))
          goto LABEL_63;
        v32 = *(_DWORD *)(v26 + 1608);
        if (v32 == 3)
          goto LABEL_65;
        if (v32 == 2)
        {
          if (*(_DWORD *)(v26 + 1612) >= *(_DWORD *)(v26 + 1616))
LABEL_65:
            v33 = 18;
          else
            v33 = 17;
          *(_DWORD *)(v26 + 3712) = v33;
        }
LABEL_63:
        *(_QWORD *)(v4 + 1464) = v2;
        *(_QWORD *)(v4 + 1456) = v1;
        return 1;
      case 0x11u:
        v15 = *(_QWORD *)(v3 + 1096);
        v1 = (_WORD *)(v15 + 3716);
        *(_BYTE *)(v15 + 3716) = -1;
        v17 = *(unsigned __int8 *)(v15 + 474);
        *(_BYTE *)(v15 + 3717) = v17 - 48;
        if (v17 == 7)
          v18 = 0;
        else
          v18 = v17 + 1;
        *(_BYTE *)(v15 + 474) = v18;
        v16 = 16;
LABEL_44:
        *(_DWORD *)(v15 + 3712) = v16;
        goto LABEL_46;
      case 0x12u:
        v1 = (_WORD *)(*(_QWORD *)(v3 + 1096) + 3716);
        *v1 = -9729;
LABEL_46:
        v2 = 2;
        goto LABEL_63;
      default:
        LODWORD(v7) = 0;
LABEL_30:
        if ((_DWORD)v7)
          goto LABEL_63;
        continue;
    }
  }
}

void OJPEGLibjpegJpegSourceMgrSkipInputData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  char v9;

  v8 = *(_QWORD *)(a1 + 24);
  TIFFErrorExtR(v8, "LibJpeg", "Unexpected error", a4, a5, a6, a7, a8, v9);
  siglongjmp((int *)(*(_QWORD *)(v8 + 1096) + 16), 1);
}

void OJPEGLibjpegJpegSourceMgrResyncToRestart(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  char v9;

  v8 = *(_QWORD *)(a1 + 24);
  TIFFErrorExtR(v8, "LibJpeg", "Unexpected error", a4, a5, a6, a7, a8, v9);
  siglongjmp((int *)(*(_QWORD *)(v8 + 1096) + 16), 1);
}

uint64_t jpeg_read_header_encap(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = 0;
  if (!sigsetjmp((int *)(a1 + 16), 0))
  {
    v3 = 1;
    _cg_jpeg_read_header(a2, 1);
  }
  return v3;
}

uint64_t jpeg_start_decompress_encap(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = 0;
  if (!sigsetjmp((int *)(a1 + 16), 0))
  {
    _cg_jpeg_start_decompress(a2);
    return 1;
  }
  return v3;
}

uint64_t jpeg_read_raw_data_encap(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t v7;

  v7 = 0;
  if (!sigsetjmp((int *)(a1 + 16), 0))
  {
    _cg_jpeg_read_raw_data(a2, a3, a4);
    return 1;
  }
  return v7;
}

uint64_t jpeg_read_scanlines_encap(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;

  v5 = 0;
  if (!sigsetjmp((int *)(a1 + 16), 0))
  {
    v5 = 1;
    _cg_jpeg_read_scanlines(a2, a3, 1);
  }
  return v5;
}

uint64_t IIOImageWriteSession::getPosition(IIOImageWriteSession *this)
{
  return *((_QWORD *)this + 8);
}

size_t IIOImageWriteSession::getBytes(IIOImageWriteSession *this, void *__ptr, size_t a3)
{
  uint64_t v5;
  size_t v6;
  size_t v7;
  size_t v8;
  size_t v9;
  FILE *v10;
  __CFData *v11;
  UInt8 *MutableBytePtr;

  v6 = *((_QWORD *)this + 7);
  v5 = *((_QWORD *)this + 8);
  v7 = v5 + a3;
  v8 = v6 - v5;
  if (v7 <= v6)
    v9 = a3;
  else
    v9 = v8;
  v10 = (FILE *)*((_QWORD *)this + 4);
  if (v10)
  {
    v9 = fread(__ptr, 1uLL, v9, v10);
  }
  else
  {
    v11 = (__CFData *)*((_QWORD *)this + 3);
    if (v11)
    {
      MutableBytePtr = CFDataGetMutableBytePtr(v11);
      memcpy(__ptr, &MutableBytePtr[*((_QWORD *)this + 8)], v9);
    }
    else if (*((_QWORD *)this + 2))
    {
      LogError("getBytes", 306, "*** ERROR: does not work for CGDataConsumers\n");
      return 0;
    }
  }
  *((_QWORD *)this + 8) += v9;
  return v9;
}

uint64_t _CGImageWriteSessionCopyDebugDesc(const void *a1)
{
  return 0;
}

uint64_t CGImageWriteSessionCreateWithConsumer(const void *a1)
{
  IIOImageWriteSession *v2;

  if (!a1)
    return 0;
  v2 = (IIOImageWriteSession *)operator new();
  IIOImageWriteSession::IIOImageWriteSession(v2, a1);
  if (*((_DWORD *)v2 + 19))
  {
    (*(void (**)(IIOImageWriteSession *))(*(_QWORD *)v2 + 8))(v2);
    return 0;
  }
  return CGImageWriteSessionCreateWith_wSession(v2);
}

void sub_187FB5434(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C408329B462);
  _Unwind_Resume(a1);
}

uint64_t _cg_TIFFWriteScanline(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9;
  int v12;
  unsigned int v13;
  int v14;
  char *v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t result;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  char v22;

  v9 = a3;
  v12 = *(_DWORD *)(a1 + 16);
  if ((v12 & 0x40) == 0)
  {
    if (!TIFFWriteCheck(a1, 0, "TIFFWriteScanline", a4, a5, a6, a7, a8))
      return 0xFFFFFFFFLL;
    v12 = *(_DWORD *)(a1 + 16);
  }
  if ((v12 & 0x10) == 0 || !*(_QWORD *)(a1 + 1120))
  {
    if (!TIFFWriteBufferSetup(a1, 0, -1, a4, a5, a6, a7, a8))
      return 0xFFFFFFFFLL;
    v12 = *(_DWORD *)(a1 + 16);
  }
  *(_DWORD *)(a1 + 16) = v12 | 0x100000;
  v13 = *(_DWORD *)(a1 + 92);
  v14 = *(unsigned __int16 *)(a1 + 170);
  if (v13 <= v9)
  {
    if (v14 == 2)
    {
      v15 = "Can not change \"ImageLength\" when using separate planes";
LABEL_39:
      TIFFErrorExtR(a1, "TIFFWriteScanline", v15, a4, a5, a6, a7, a8, v22);
      return 0xFFFFFFFFLL;
    }
    *(_DWORD *)(a1 + 92) = v9 + 1;
    goto LABEL_15;
  }
  if (v14 != 2)
  {
LABEL_15:
    v16 = v9 / *(_DWORD *)(a1 + 132);
    goto LABEL_16;
  }
  if (*(unsigned __int16 *)(a1 + 130) <= a4)
  {
    TIFFErrorExtR(a1, "TIFFWriteScanline", "%lu: Sample out of range, max %lu", a4, a5, a6, a7, a8, a4);
    return 0xFFFFFFFFLL;
  }
  v16 = v9 / *(_DWORD *)(a1 + 132) + *(_DWORD *)(a1 + 224) * a4;
LABEL_16:
  if (v16 >= *(_DWORD *)(a1 + 228) && !TIFFGrowStrips(a1, "TIFFWriteScanline", a3, a4, a5, a6, a7, a8))
    return 0xFFFFFFFFLL;
  if (v16 == *(_DWORD *)(a1 + 884))
  {
LABEL_19:
    v17 = *(_DWORD *)(a1 + 876);
    if (v17 != v9)
    {
      if (v17 > v9)
      {
        v17 = *(_DWORD *)(a1 + 132) * (v16 % *(_DWORD *)(a1 + 224));
        *(_DWORD *)(a1 + 876) = v17;
        *(_QWORD *)(a1 + 1152) = *(_QWORD *)(a1 + 1120);
      }
      if (!(*(unsigned int (**)(uint64_t, _QWORD))(a1 + 1064))(a1, v9 - v17))
        return 0xFFFFFFFFLL;
      *(_DWORD *)(a1 + 876) = v9;
    }
    (*(void (**)(uint64_t, uint64_t, _QWORD))(a1 + 1248))(a1, a2, *(_QWORD *)(a1 + 1104));
    result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(a1 + 1016))(a1, a2, *(_QWORD *)(a1 + 1104), a4);
    *(_DWORD *)(a1 + 876) = v9 + 1;
    return result;
  }
  if (TIFFFlushData(a1, a2, a3, a4, a5, a6, a7, a8))
  {
    *(_DWORD *)(a1 + 884) = v16;
    v19 = *(_DWORD *)(a1 + 224);
    if (v13 <= v9 && v16 >= v19)
    {
      v19 = 0;
      v20 = *(_DWORD *)(a1 + 92);
      v21 = *(_DWORD *)(a1 + 132);
      if (v20 < -v21)
        v19 = (v20 + v21 - 1) / v21;
      *(_DWORD *)(a1 + 224) = v19;
    }
    if (!v19)
    {
      v15 = "Zero strips per image";
      goto LABEL_39;
    }
    *(_DWORD *)(a1 + 876) = *(_DWORD *)(a1 + 132) * (v16 % v19);
    if ((*(_BYTE *)(a1 + 16) & 0x20) == 0)
    {
      if (!(*(unsigned int (**)(uint64_t))(a1 + 976))(a1))
        return 0xFFFFFFFFLL;
      *(_DWORD *)(a1 + 16) |= 0x20u;
    }
    *(_QWORD *)(a1 + 1160) = 0;
    *(_QWORD *)(a1 + 1152) = *(_QWORD *)(a1 + 1120);
    *(_QWORD *)(a1 + 888) = 0;
    if ((*(unsigned int (**)(uint64_t, uint64_t))(a1 + 992))(a1, a4))
    {
      *(_DWORD *)(a1 + 16) |= 0x1000u;
      goto LABEL_19;
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t TIFFWriteCheck(uint64_t a1, int a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t result;
  int v14;
  const char *v15;
  char v16;

  if (!*(_DWORD *)(a1 + 12))
  {
    v12 = "File not open for writing";
    goto LABEL_9;
  }
  if (((*(_DWORD *)(a1 + 16) >> 10) & 1) != a2)
  {
    if (a2)
      v12 = "Can not write tiles to a striped image";
    else
      v12 = "Can not write scanlines to a tiled image";
    goto LABEL_9;
  }
  _TIFFFillStriles(a1);
  if ((*(_BYTE *)(a1 + 72) & 2) == 0)
  {
    v12 = "Must set \"ImageWidth\" before writing data";
LABEL_9:
    TIFFErrorExtR(a1, a3, v12, a4, a5, a6, a7, a8, v16);
    return 0;
  }
  if (!*(_QWORD *)(a1 + 232) && !TIFFSetupStrips(a1, v10, v11, a4, a5, a6, a7, a8))
  {
    *(_DWORD *)(a1 + 228) = 0;
    if ((*(_DWORD *)(a1 + 16) & 0x400) != 0)
      v15 = "tile";
    else
      v15 = "strip";
    TIFFErrorExtR(a1, a3, "No space for %s arrays", a4, a5, a6, a7, a8, (char)v15);
    return 0;
  }
  if ((*(_BYTE *)(a1 + 17) & 4) != 0)
  {
    result = _cg_TIFFTileSize(a1, v10, v11, a4, a5, a6, a7, a8);
    *(_QWORD *)(a1 + 936) = result;
    if (!result)
      return result;
  }
  else
  {
    *(_QWORD *)(a1 + 936) = -1;
  }
  result = _cg_TIFFScanlineSize(a1, v10, v11, a4, a5, a6, a7, a8);
  *(_QWORD *)(a1 + 1104) = result;
  if (result)
  {
    v14 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 16) = v14 | 0x40;
    if (!*(_WORD *)(a1 + 256)
      || *(_QWORD *)(a1 + 264)
      || *(_WORD *)(a1 + 258)
      || *(_QWORD *)(a1 + 272)
      || !*(_WORD *)(a1 + 288)
      || *(_QWORD *)(a1 + 296)
      || *(_WORD *)(a1 + 290))
    {
      return 1;
    }
    result = 1;
    if (!*(_QWORD *)(a1 + 304) && (v14 & 8) == 0)
    {
      TIFFForceStrileArrayWriting(a1);
      return 1;
    }
  }
  return result;
}

uint64_t TIFFWriteBufferSetup(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  char *v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t result;
  char v23;

  v8 = a3;
  v11 = *(char **)(a1 + 1120);
  if (v11)
  {
    if ((*(_BYTE *)(a1 + 17) & 2) != 0)
    {
      _TIFFfreeExt(a1, v11);
      *(_DWORD *)(a1 + 16) &= ~0x200u;
    }
    *(_QWORD *)(a1 + 1120) = 0;
  }
  if (v8 == -1)
  {
    if ((*(_BYTE *)(a1 + 17) & 4) != 0)
      v13 = *(_QWORD *)(a1 + 936);
    else
      v13 = _cg_TIFFStripSize(a1, (uint64_t)v11, a3, a4, a5, a6, a7, a8);
    v14 = v13 / 10;
    if (v13 >= ((v13 / 10) ^ 0x7FFFFFFFFFFFFFFFLL))
      v14 = 0;
    v15 = v14 + v13;
    if (v15 <= 0x2000)
      v8 = 0x2000;
    else
      v8 = v15;
  }
  else if (a2)
  {
    v12 = *(_DWORD *)(a1 + 16) & 0xFFFFFDFF;
LABEL_18:
    *(_QWORD *)(a1 + 1120) = a2;
    *(_QWORD *)(a1 + 1128) = v8;
    *(_QWORD *)(a1 + 1160) = 0;
    *(_QWORD *)(a1 + 1152) = a2;
    result = 1;
    *(_DWORD *)(a1 + 16) = v12 | 0x10;
    return result;
  }
  v16 = _TIFFmallocExt((_QWORD *)a1, v8, a3, a4, a5, a6, a7, a8);
  if (v16)
  {
    a2 = v16;
    v12 = *(_DWORD *)(a1 + 16) | 0x200;
    goto LABEL_18;
  }
  TIFFErrorExtR(a1, "TIFFWriteBufferSetup", "No space for output buffer", v17, v18, v19, v20, v21, v23);
  return 0;
}

uint64_t TIFFGrowStrips(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  BOOL v23;
  char v25;

  if (*(_WORD *)(a1 + 170) != 1)
    TIFFGrowStrips_cold_1();
  v10 = (char *)_TIFFreallocExt((_QWORD *)a1, *(char **)(a1 + 232), 8 * (*(_DWORD *)(a1 + 228) + 1), a4, a5, a6, a7, a8);
  v16 = (char *)_TIFFreallocExt((_QWORD *)a1, *(char **)(a1 + 240), 8 * (*(_DWORD *)(a1 + 228) + 1), v11, v12, v13, v14, v15);
  v22 = v16;
  if (v10)
    v23 = v16 == 0;
  else
    v23 = 1;
  if (v23)
  {
    if (v10)
      _TIFFfreeExt(a1, v10);
    if (v22)
      _TIFFfreeExt(a1, v22);
    *(_DWORD *)(a1 + 228) = 0;
    TIFFErrorExtR(a1, a2, "No space to expand strip arrays", v17, v18, v19, v20, v21, v25);
    return 0;
  }
  else
  {
    *(_QWORD *)(a1 + 232) = v10;
    *(_QWORD *)(a1 + 240) = v16;
    _TIFFmemset(&v10[8 * *(unsigned int *)(a1 + 228)], 0, 8uLL);
    _TIFFmemset((void *)(*(_QWORD *)(a1 + 240) + 8 * *(unsigned int *)(a1 + 228)), 0, 8uLL);
    ++*(_DWORD *)(a1 + 228);
    *(_DWORD *)(a1 + 16) |= 8u;
    return 1;
  }
}

uint64_t _TIFFReserveLargeEnoughWriteBuffer(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t result;

  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 240) + 8 * a2);
  if (!v8)
    return 1;
  if (*(_QWORD *)(a1 + 1128) > v8 + 5)
    return 1;
  result = TIFFWriteBufferSetup(a1, 0, (v8 + 1028) & 0xFFFFFFFFFFFFFC00, a4, a5, a6, a7, a8);
  if ((_DWORD)result)
    return 1;
  return result;
}

uint64_t TIFFAppendToStrip(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  char *v46;
  int v47;
  uint64_t v48;

  v11 = *(_QWORD *)(a1 + 888);
  v12 = a2;
  if (v11)
  {
    v13 = *(_QWORD *)(a1 + 232);
    if (*(_QWORD *)(v13 + 8 * a2))
    {
      v14 = -1;
      goto LABEL_15;
    }
    v15 = 0;
    v16 = 1;
  }
  else
  {
    *(_QWORD *)(a1 + 896) = 0;
    v15 = *(_QWORD *)(*(_QWORD *)(a1 + 232) + 8 * a2);
    v16 = v15 == 0;
  }
  if (!*(_DWORD *)(a1 + 228))
    TIFFAppendToStrip_cold_1();
  v17 = *(_QWORD *)(*(_QWORD *)(a1 + 240) + 8 * v12);
  if (v17 < a4)
    v16 = 1;
  if (!v17 || v16)
  {
    v19 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(a1 + 1224))(*(_QWORD *)(a1 + 1200), 0, 2);
    v13 = *(_QWORD *)(a1 + 232);
    v18 = *(_QWORD *)(a1 + 240);
    *(_QWORD *)(v13 + 8 * v12) = v19;
    *(_DWORD *)(a1 + 16) |= 0x200000u;
  }
  else
  {
    if (!_TIFFSeekOK(a1, v15))
    {
      v47 = *(_DWORD *)(a1 + 876);
      v22 = "Seek error at scanline %lu";
      goto LABEL_45;
    }
    v13 = *(_QWORD *)(a1 + 232);
    v18 = *(_QWORD *)(a1 + 240);
    *(_QWORD *)(a1 + 896) = *(_QWORD *)(v18 + 8 * v12) + *(_QWORD *)(v13 + 8 * v12);
    v19 = *(_QWORD *)(v13 + 8 * v12);
  }
  *(_QWORD *)(a1 + 888) = v19;
  v14 = *(_QWORD *)(v18 + 8 * v12);
  *(_QWORD *)(v18 + 8 * v12) = 0;
  v11 = *(_QWORD *)(a1 + 888);
LABEL_15:
  if ((*(_BYTE *)(a1 + 18) & 8) != 0)
    v20 = v11 + a4;
  else
    v20 = (v11 + a4);
  if (v20 < v11 || v20 < a4)
  {
LABEL_22:
    v22 = "Maximum TIFF file size exceeded";
LABEL_45:
    TIFFErrorExtR(a1, "TIFFAppendToStrip", v22, a4, a5, a6, a7, a8, v47);
    return 0;
  }
  v23 = *(_QWORD *)(a1 + 896);
  if (v23)
  {
    if (v20 > v23)
    {
      v24 = *(_QWORD *)(*(_QWORD *)(a1 + 240) + 8 * v12);
      if (v24)
      {
        if (v24 >= 0x100000)
          v25 = 0x100000;
        else
          v25 = *(_QWORD *)(*(_QWORD *)(a1 + 240) + 8 * v12);
        v48 = *(_QWORD *)(v13 + 8 * v12);
        v26 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(a1 + 1224))(*(_QWORD *)(a1 + 1200), 0, 2);
        v28 = v26;
        if ((*(_BYTE *)(a1 + 18) & 8) != 0 || !((v24 + a4 + v26) >> 32))
        {
          v29 = (char *)_TIFFmallocExt((_QWORD *)a1, v25, v27, a4, a5, a6, a7, a8);
          if (v29)
          {
            v30 = v29;
            v31 = 0;
            *(_DWORD *)(a1 + 16) |= 0x200000u;
            v32 = *(_QWORD *)(a1 + 240);
            *(_QWORD *)(*(_QWORD *)(a1 + 232) + 8 * v12) = v28;
            *(_QWORD *)(v32 + 8 * v12) = 0;
            while (1)
            {
              if (!_TIFFSeekOK(a1, v48 + v31))
              {
LABEL_48:
                v46 = "Seek error";
                goto LABEL_51;
              }
              if ((*(uint64_t (**)(_QWORD, char *, uint64_t))(a1 + 1208))(*(_QWORD *)(a1 + 1200), v30, v25) != v25)
              {
                v46 = "Cannot read";
                goto LABEL_51;
              }
              if (!_TIFFSeekOK(a1, v28 + v31))
                goto LABEL_48;
              if ((*(uint64_t (**)(_QWORD, char *, uint64_t))(a1 + 1216))(*(_QWORD *)(a1 + 1200), v30, v25) != v25)
                break;
              *(_QWORD *)(*(_QWORD *)(a1 + 240) + 8 * v12) += v25;
              v31 += v25;
              if (v24 == v31)
              {
                _TIFFfreeExt(a1, v30);
                v20 = v28 + a4 + v31;
                goto LABEL_39;
              }
            }
            v46 = "Cannot write";
LABEL_51:
            TIFFErrorExtR(a1, "TIFFAppendToStrip", v46, v33, v34, v35, v36, v37, v47);
            _TIFFfreeExt(a1, v30);
            return 0;
          }
          v22 = "No space for output buffer";
          goto LABEL_45;
        }
        goto LABEL_22;
      }
    }
  }
LABEL_39:
  if ((*(uint64_t (**)(_QWORD, uint64_t, unint64_t))(a1 + 1216))(*(_QWORD *)(a1 + 1200), a3, a4) != a4)
  {
    TIFFErrorExtR(a1, "TIFFAppendToStrip", "Write error at scanline %lu", v38, v39, v40, v41, v42, *(_DWORD *)(a1 + 876));
    return 0;
  }
  *(_QWORD *)(a1 + 888) = v20;
  v43 = *(_QWORD *)(a1 + 240);
  v44 = *(_QWORD *)(v43 + 8 * v12) + a4;
  *(_QWORD *)(v43 + 8 * v12) = v44;
  if (v44 != v14)
    *(_DWORD *)(a1 + 16) |= 0x200000u;
  return 1;
}

uint64_t _cg_TIFFWriteTile(uint64_t a1, unsigned __int8 *a2, unsigned int a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  unsigned int v9;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v8 = a6;
  v9 = a5;
  if (!TIFFCheckTile(a1, a3, a4, a5, a6, a6, a7, a8))
    return -1;
  v14 = _cg_TIFFComputeTile(a1, a3, a4, v9, v8);
  return _cg_TIFFWriteEncodedTile(a1, v14, a2, -1, v15, v16, v17, v18);
}

uint64_t _cg_TIFFWriteEncodedTile(uint64_t a1, unsigned int a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  BOOL v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  char *v23;
  int v25;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int64_t v36;
  char v37;

  if ((*(_BYTE *)(a1 + 16) & 0x40) == 0
    && !TIFFWriteCheck(a1, 1, "TIFFWriteEncodedTile", a4, a5, a6, a7, a8))
  {
    return -1;
  }
  if (*(_DWORD *)(a1 + 228) <= a2)
  {
    v37 = a2;
    v23 = "Tile %lu out of range, max %lu";
    goto LABEL_16;
  }
  v12 = *(_DWORD *)(a1 + 16);
  if ((v12 & 0x10) == 0 || !*(_QWORD *)(a1 + 1120))
  {
    v13 = -1;
    if (!TIFFWriteBufferSetup(a1, 0, -1, a4, a5, a6, a7, a8))
      return v13;
    v12 = *(_DWORD *)(a1 + 16);
  }
  *(_DWORD *)(a1 + 16) = v12 | 0x100000;
  *(_DWORD *)(a1 + 932) = a2;
  *(_QWORD *)(a1 + 888) = 0;
  if (!_TIFFReserveLargeEnoughWriteBuffer(a1, a2, (uint64_t)a3, a4, a5, a6, a7, a8))
    return -1;
  *(_QWORD *)(a1 + 1160) = 0;
  *(_QWORD *)(a1 + 1152) = *(_QWORD *)(a1 + 1120);
  v14 = *(_DWORD *)(a1 + 92);
  v15 = *(_DWORD *)(a1 + 104);
  if (v14 >= -v15)
    goto LABEL_14;
  v16 = v14 - 1;
  v17 = __CFADD__(v16, v15);
  v18 = v16 + v15;
  if (v17
    || (*(_DWORD *)(a1 + 876) = a2 % (v18 / v15) * v15,
        v19 = *(_DWORD *)(a1 + 88),
        v20 = *(_DWORD *)(a1 + 100),
        v19 >= -v20)
    || (v21 = v19 - 1, v17 = __CFADD__(v21, v20), v22 = v21 + v20, v17))
  {
LABEL_14:
    v23 = "Zero tiles";
LABEL_16:
    TIFFErrorExtR(a1, "TIFFWriteEncodedTile", v23, a4, a5, a6, a7, a8, v37);
    return -1;
  }
  *(_DWORD *)(a1 + 928) = a2 % (v22 / v20) * v20;
  v25 = *(_DWORD *)(a1 + 16);
  if ((v25 & 0x20) == 0)
  {
    if (!(*(unsigned int (**)(uint64_t))(a1 + 976))(a1))
      return -1;
    v25 = *(_DWORD *)(a1 + 16) | 0x20;
  }
  *(_DWORD *)(a1 + 16) = v25 & 0xFFFFEFFF;
  if (*(_QWORD *)(a1 + 936) < a4 || a4 < 1)
    v13 = *(_QWORD *)(a1 + 936);
  else
    v13 = a4;
  if (*(_WORD *)(a1 + 120) != 1)
  {
    v31 = (unsigned __int16)(a2 / *(_DWORD *)(a1 + 224));
    if ((*(unsigned int (**)(uint64_t, uint64_t))(a1 + 992))(a1, v31))
    {
      (*(void (**)(uint64_t, unsigned __int8 *, uint64_t))(a1 + 1248))(a1, a3, v13);
      if ((*(unsigned int (**)(uint64_t, unsigned __int8 *, uint64_t, uint64_t))(a1 + 1048))(a1, a3, v13, v31))
      {
        if ((*(unsigned int (**)(uint64_t))(a1 + 1000))(a1))
        {
          if ((*(_DWORD *)(a1 + 16) & (*(unsigned __int16 *)(a1 + 126) | 0x100)) == 0)
            TIFFReverseBits(*(unsigned __int8 **)(a1 + 1120), *(_QWORD *)(a1 + 1160));
          v36 = *(_QWORD *)(a1 + 1160);
          if (v36 < 1 || TIFFAppendToStrip(a1, a2, *(_QWORD *)(a1 + 1120), v36, v32, v33, v34, v35))
          {
            *(_QWORD *)(a1 + 1160) = 0;
            *(_QWORD *)(a1 + 1152) = *(_QWORD *)(a1 + 1120);
            return v13;
          }
        }
      }
    }
    return -1;
  }
  (*(void (**)(uint64_t, unsigned __int8 *, uint64_t))(a1 + 1248))(a1, a3, v13);
  if ((*(_DWORD *)(a1 + 16) & (*(unsigned __int16 *)(a1 + 126) | 0x100)) == 0)
    TIFFReverseBits(a3, v13);
  if (v13 >= 1 && !TIFFAppendToStrip(a1, a2, (uint64_t)a3, v13, v27, v28, v29, v30))
    return -1;
  return v13;
}

uint64_t TIFFSetupStrips(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t result;
  char v18;

  v9 = *(_DWORD *)(a1 + 72);
  if ((*(_BYTE *)(a1 + 17) & 4) != 0)
  {
    if ((v9 & 4) == 0 || *(_DWORD *)(a1 + 92))
    {
      v10 = _cg_TIFFNumberOfTiles(a1, a2, a3, a4, a5, a6, a7, a8);
      goto LABEL_9;
    }
  }
  else if ((v9 & 0x20000) == 0 || *(_DWORD *)(a1 + 92))
  {
    v10 = _cg_TIFFNumberOfStrips(a1, a2, a3, a4, a5, a6, a7, a8);
    goto LABEL_9;
  }
  v10 = *(unsigned __int16 *)(a1 + 130);
LABEL_9:
  *(_DWORD *)(a1 + 224) = v10;
  *(_DWORD *)(a1 + 228) = v10;
  if ((*(_BYTE *)(a1 + 18) & 8) != 0)
    v11 = 0x10000000;
  else
    v11 = 0x20000000;
  if (v10 >= v11)
  {
    TIFFErrorExtR(a1, "TIFFSetupStrips", "Too large Strip/Tile Offsets/ByteCounts arrays", a4, a5, a6, a7, a8, v18);
    return 0;
  }
  else
  {
    if (*(_WORD *)(a1 + 170) == 2)
      *(_DWORD *)(a1 + 224) = v10 / *(unsigned __int16 *)(a1 + 130);
    *(_QWORD *)(a1 + 232) = _TIFFCheckMalloc((const char **)a1, v10, 8, (uint64_t)"for \"StripOffsets\" array", a5, a6, a7, a8);
    v16 = _TIFFCheckMalloc((const char **)a1, *(unsigned int *)(a1 + 228), 8, (uint64_t)"for \"StripByteCounts\" array", v12, v13, v14, v15);
    result = 0;
    *(_QWORD *)(a1 + 240) = v16;
    if (*(_QWORD *)(a1 + 232))
    {
      if (v16)
      {
        _TIFFmemset(*(void **)(a1 + 232), 0, 8 * *(unsigned int *)(a1 + 228));
        _TIFFmemset(*(void **)(a1 + 240), 0, 8 * *(unsigned int *)(a1 + 228));
        *(_DWORD *)(a1 + 72) |= 0x3000000u;
        return 1;
      }
    }
  }
  return result;
}

uint64_t TIFFFlushData1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  int v10;
  uint64_t result;
  BOOL v12;
  uint64_t v13;

  v8 = *(_QWORD *)(a1 + 1160);
  if (v8 < 1)
    return 1;
  v10 = *(_DWORD *)(a1 + 16);
  if ((v10 & 0x100000) == 0)
    return 1;
  if (((unsigned __int16)v10 & (*(_WORD *)(a1 + 126) | 0x100)) == 0)
  {
    TIFFReverseBits(*(unsigned __int8 **)(a1 + 1120), v8);
    v10 = *(_DWORD *)(a1 + 16);
    v8 = *(_QWORD *)(a1 + 1160);
  }
  v12 = (v10 & 0x400) == 0;
  v13 = 932;
  if (v12)
    v13 = 884;
  result = TIFFAppendToStrip(a1, *(_DWORD *)(a1 + v13), *(_QWORD *)(a1 + 1120), v8, a5, a6, a7, a8);
  *(_QWORD *)(a1 + 1160) = 0;
  *(_QWORD *)(a1 + 1152) = *(_QWORD *)(a1 + 1120);
  return result;
}

uint64_t IIO_Reader_PSD::createReadPlugin(IIO_Reader *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;

  v4 = operator new();
  v5 = IIO_Reader::osType(a1);
  PSDReadPlugin::PSDReadPlugin(v4, a2, v5);
  return v4;
}

void sub_187FB6370(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C408AB442B6);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_PSD::createReadPlugin(IIO_Reader *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8;
  int v9;

  v8 = operator new();
  v9 = IIO_Reader::osType(a1);
  PSDReadPlugin::PSDReadPlugin(v8, a2, a3, a4, v9);
  return v8;
}

void sub_187FB640C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C408AB442B6);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_PSD::initThumbnail(IIO_Reader *a1, uint64_t a2, int a3, int a4)
{
  int v7;
  uint64_t inited;
  _OWORD v10[30];

  memset(v10, 0, sizeof(v10));
  v7 = IIO_Reader::osType(a1);
  PSDReadPlugin::PSDReadPlugin((uint64_t)v10, a2, a3, 0, v7);
  IIOReadPlugin::setDecodeMode((uint64_t)v10, 2);
  IIOReadPlugin::setDestMaxPixelSize((uint64_t)v10, a4);
  inited = PSDReadPlugin::initThumbnail((PSDReadPlugin *)v10);
  PSDReadPlugin::~PSDReadPlugin((PSDReadPlugin *)v10);
  return inited;
}

void sub_187FB64F0(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187FB64D0);
}

void sub_187FB6500(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  PSDReadPlugin::~PSDReadPlugin((PSDReadPlugin *)&a9);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_PSD::deserializeGlobalInfo(IIO_Reader_PSD *this, unsigned __int8 *a2)
{
  return 0;
}

uint64_t IIO_Reader_PSD::hasCustomThumbnailProc(IIO_Reader_PSD *this)
{
  return 1;
}

uint64_t CreateMD5FromIIMBlock(void *a1, CC_LONG a2, unsigned __int8 *a3)
{
  CC_MD5_CTX v7;

  memset(&v7, 0, sizeof(v7));
  CC_MD5_Init(&v7);
  CC_MD5_Update(&v7, a1, a2);
  return CC_MD5_Final(a3, &v7);
}

__CFString *CreateMD5StringFromIIMBlock(void *a1, CC_LONG a2)
{
  __CFString *Mutable;
  uint64_t i;
  unsigned __int8 v5[8];
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)v5 = 0;
  v6 = 0;
  CreateMD5FromIIMBlock(a1, a2, v5);
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 16);
  if (Mutable)
  {
    for (i = 0; i != 16; ++i)
      CFStringAppendFormat(Mutable, 0, CFSTR("%02X"), v5[i]);
  }
  return Mutable;
}

uint64_t SizeOfIPTCData(IIODictionary *a1)
{
  const __CFDictionary *v1;
  uint64_t context;

  context = 0;
  if (a1
    && (v1 = (const __CFDictionary *)*((_QWORD *)a1 + 1)) != 0
    && (CFDictionaryApplyFunction(v1, (CFDictionaryApplierFunction)ApplierSizeOfIPTC, &context), context))
  {
    return context + 15;
  }
  else
  {
    return 0;
  }
}

void ApplierSizeOfIPTC(const __CFString *a1, const __CFString *cf, _QWORD *a3)
{
  CFTypeID v6;
  char *i;
  CFTypeID v9;
  char *j;
  CFTypeID v12;
  CFStringRef v13;
  const char *v14;
  const char *v15;
  _QWORD v16[3];
  _QWORD v17[3];
  CFRange v18;

  if (a1 && cf && a3)
  {
    v6 = CFGetTypeID(cf);
    if (v6 == CFStringGetTypeID())
    {
      for (i = &byte_1E1BC4158; CFStringCompare(a1, **((CFStringRef **)i - 2), 0); i += 24)
      {
        if (!*i)
          return;
      }
      SizeOfIPTCEntry(cf, a3);
    }
    else
    {
      v9 = CFGetTypeID(cf);
      if (v9 == CFArrayGetTypeID())
      {
        for (j = &byte_1E1BC4150; CFStringCompare(a1, **((CFStringRef **)j - 1), 0); j += 24)
        {
          if (!j[8])
            return;
        }
        if (*j)
        {
          v18.length = CFArrayGetCount((CFArrayRef)cf);
          v18.location = 0;
          CFArrayApplyFunction((CFArrayRef)cf, v18, (CFArrayApplierFunction)SizeOfIPTCEntry, a3);
        }
      }
      else
      {
        v12 = CFGetTypeID(cf);
        v13 = CFCopyTypeIDDescription(v12);
        memset(v17, 0, sizeof(v17));
        IIOString::IIOString((IIOString *)v17, a1);
        memset(v16, 0, sizeof(v16));
        IIOString::IIOString((IIOString *)v16, v13);
        v14 = (const char *)IIOString::utf8String((IIOString *)v17);
        v15 = (const char *)IIOString::utf8String((IIOString *)v16);
        _cg_jpeg_mem_term("ApplierSizeOfIPTC", 188, "*** ApplierSizeOfIPTC - skipping '%s' -- '%s'\n", v14, v15);
        CFRelease(v13);
        IIOString::~IIOString((IIOString *)v16);
        IIOString::~IIOString((IIOString *)v17);
      }
    }
  }
}

void sub_187FB6838(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void WriteIPTCData(CFDictionaryRef *a1, unsigned __int8 *a2)
{
  _QWORD v2[2];

  if (a1)
  {
    if (a2)
    {
      *(_QWORD *)a2 = 0x47251B03005A011CLL;
      *((_DWORD *)a2 + 2) = 540;
      *((_WORD *)a2 + 6) = 2;
      a2[14] = 2;
      v2[0] = 0;
      v2[1] = a2 + 15;
      CFDictionaryApplyFunction(a1[1], (CFDictionaryApplierFunction)ApplierWriteIPTC, v2);
    }
  }
}

__n128 ApplierWriteIPTC(const __CFString *a1, const __CFString *cf, char *a3)
{
  CFTypeID v6;
  char *j;
  __n128 result;
  char *i;
  CFRange v13;

  if (!a1 || !cf)
    return result;
  v6 = CFGetTypeID(cf);
  if (CFStringGetTypeID() != v6)
  {
    if (CFArrayGetTypeID() == v6)
    {
      for (i = &byte_1E1BC4150; CFStringCompare(a1, **((CFStringRef **)i - 1), 0); i += 24)
      {
        if (!i[8])
          return result;
      }
    }
    else
    {
      if (CFDictionaryGetTypeID() != v6)
      {
        if (v6 != CFNumberGetTypeID())
          return _cg_jpeg_mem_term("ApplierWriteIPTC", 289, "*** ApplierWriteIPTC - does not handle non-strings / non-arrays\n");
        return result;
      }
      for (i = &byte_1E1BC4150; CFStringCompare(a1, **((CFStringRef **)i - 1), 0); i += 24)
      {
        if (!i[8])
          return result;
      }
    }
    if (*i)
    {
      *a3 = *(i - 16);
      v13.length = CFArrayGetCount((CFArrayRef)cf);
      v13.location = 0;
      CFArrayApplyFunction((CFArrayRef)cf, v13, (CFArrayApplierFunction)WriteIPTCEntry, a3);
    }
    return result;
  }
  for (j = &iptcInfo; CFStringCompare(a1, **((CFStringRef **)j + 1), 0); j += 24)
  {
    if (!j[24])
      return result;
  }
  *a3 = *j;
  WriteIPTCEntry(cf, (_BYTE **)a3);
  return result;
}

void ReadIPTCProps(IIODictionary *a1, _BYTE *a2, unint64_t a3)
{
  unint64_t v3;
  _BYTE *v4;
  size_t v5;
  const __CFAllocator *v6;
  unint64_t v7;
  char *v8;
  int v9;
  int v10;
  unint64_t v11;
  size_t v12;
  int v13;
  BOOL v14;
  CFStringEncoding v15;
  int v16;
  unsigned int v17;
  char *v18;
  int v19;
  int v20;
  BOOL v21;
  const char *v22;
  int v23;
  char *v24;
  size_t v25;
  CFIndex v26;
  CFStringRef v27;
  CFStringRef v28;
  const __CFString **v29;
  const __CFDictionary *ObjectForKeyGroup;
  int v31;
  __CFString *MD5StringFromIIMBlock;
  __CFString *v33;
  CFStringEncoding encoding;
  CFMutableArrayRef v38[3];
  _BYTE v39[24];

  v3 = a3;
  v4 = a2;
  if (a3 >= 6)
  {
    encoding = 0;
    v5 = 0;
    v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v7 = 5;
    do
    {
      if (v4[v5] != 28)
        break;
      v8 = &v4[v5];
      v9 = v4[v5 + 1];
      if ((v9 - 1) > 1)
        break;
      v10 = v8[2];
      v11 = __rev16(*(unsigned __int16 *)(v8 + 3));
      v12 = v11 + v7 <= v3 ? v11 : v3 - v7;
      if (v9 == 1 && v10 == 90 && v12 == 3)
      {
        if (v4[v7] != 27)
          goto LABEL_42;
        v13 = v4[v5 + 6];
        if (v13 == 47)
        {
          v14 = v4[v5 + 7] == 65;
          v15 = encoding;
          v16 = 513;
        }
        else
        {
          if (v13 != 37)
            goto LABEL_42;
          v14 = v4[v5 + 7] == 71;
          v15 = encoding;
          v16 = 134217984;
        }
        if (v14)
          v15 = v16;
        encoding = v15;
      }
      else
      {
        if (v9 == 1)
          goto LABEL_42;
        if (v10 != 25
          || v12 != 6
          || v5 + 12 > 6
          || (v17 = v4[v7], v17 < 0x35)
          || ((v18 = &v4[v5], v19 = *(_DWORD *)(v18 + 6), v20 = *((unsigned __int16 *)v18 + 5), v19 == 1635013408)
            ? (v21 = v20 == 114)
            : (v21 = 0),
              !v21))
        {
          v22 = &v4[v7];
          v23 = 3;
          v24 = &byte_1E1BC4158;
          while (1)
          {
            if (v23 == v10)
            {
              v25 = strnlen(v22, v12);
              if (v12 >= v25)
                v26 = v25;
              else
                v26 = v12;
              v27 = CFStringCreateWithBytes(v6, (const UInt8 *)v22, v26, encoding, 1u);
              if (!v27)
              {
LABEL_37:
                v4 = a2;
                v3 = a3;
                goto LABEL_42;
              }
              v28 = v27;
              v29 = (const __CFString **)*((_QWORD *)v24 - 2);
              if (*(v24 - 8))
              {
                ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup(a1, *v29, CFSTR("{IPTC}"));
                if (!ObjectForKeyGroup)
                {
                  ObjectForKeyGroup = CFArrayCreateMutable(v6, 0, MEMORY[0x1E0C9B378]);
                  IIODictionary::setObjectForKeyGroup(a1, ObjectForKeyGroup, *v29, CFSTR("{IPTC}"));
                  CFRelease(ObjectForKeyGroup);
                }
                memset(v38, 0, sizeof(v38));
                IIOArray::IIOArray((IIOArray *)v38, ObjectForKeyGroup);
                IIOArray::addObject(v38, v28);
                IIOArray::~IIOArray((IIOArray *)v38);
              }
              else
              {
                IIODictionary::setObjectForKeyGroup(a1, v27, *v29, CFSTR("{IPTC}"));
              }
              CFRelease(v28);
            }
            v31 = *v24;
            v24 += 24;
            v23 = v31;
            if (!v31)
              goto LABEL_37;
          }
        }
        IIONumber::IIONumber((IIONumber *)v39, v17 - 48);
        IIODictionary::setObjectForKeyGroup(a1, (uint64_t)v39, CFSTR("StarRating"), CFSTR("{IPTC}"));
        IIONumber::~IIONumber((IIONumber *)v39);
      }
LABEL_42:
      v5 = v12 + v7;
      v7 += v12 + 5;
    }
    while (v7 < v3);
  }
  MD5StringFromIIMBlock = CreateMD5StringFromIIMBlock(v4, v3);
  if (MD5StringFromIIMBlock)
  {
    v33 = MD5StringFromIIMBlock;
    IIODictionary::setObjectForKeyGroup(a1, MD5StringFromIIMBlock, CFSTR("iptcComputedMD5"), CFSTR("{IPTC}"));
    CFRelease(v33);
  }
}

void sub_187FB6D3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

CGImageMetadata *CreateMetadataFromIPTCDatabuffer(_BYTE *a1, unint64_t a2)
{
  CGImageMetadata *v4;
  CGImageMetadata *v5;
  _QWORD v7[3];

  memset(v7, 0, sizeof(v7));
  IIODictionary::IIODictionary((IIODictionary *)v7);
  ReadIPTCProps((IIODictionary *)v7, a1, a2);
  v4 = (CGImageMetadata *)CGImageMetadataCreateFromLegacyProps((IIODictionary *)v7);
  v5 = v4;
  if (v4)
    CGImageMetadataSetValueWithPath(v4, 0, CFSTR("iio:hasIIM"), (CFTypeRef)*MEMORY[0x1E0C9AE50]);
  IIODictionary::~IIODictionary((IIODictionary *)v7);
  return v5;
}

void sub_187FB6DE4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void CGImagePluginReadRawIPTCProps(__CFDictionary *a1, _BYTE *a2, unint64_t a3)
{
  _QWORD v6[3];

  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0xC000) == 0)
    ImageIODebugOptions(3, "S", "CGImagePluginReadRawIPTCProps", 0, 0, -1, 0);
  memset(v6, 0, sizeof(v6));
  IIODictionary::IIODictionary((IIODictionary *)v6, a1);
  ReadIPTCProps((IIODictionary *)v6, a2, a3);
  IIODictionary::~IIODictionary((IIODictionary *)v6);
}

void sub_187FB6E9C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

__CFArray *CreateIIMHashArrayForIIMBlock(void *a1, CC_LONG a2)
{
  const __CFAllocator *v4;
  __CFArray *Mutable;
  uint64_t i;
  CFNumberRef v7;
  CFNumberRef v8;
  CC_MD5_CTX v10;
  unsigned __int8 md[8];
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (Mutable)
  {
    memset(&v10, 0, sizeof(v10));
    *(_QWORD *)md = 0;
    v12 = 0;
    CC_MD5_Init(&v10);
    CC_MD5_Update(&v10, a1, a2);
    CC_MD5_Final(md, &v10);
    for (i = 0; i != 16; ++i)
    {
      v7 = CFNumberCreate(v4, kCFNumberCharType, &md[i]);
      if (v7)
      {
        v8 = v7;
        CFArrayAppendValue(Mutable, v7);
        CFRelease(v8);
      }
    }
  }
  return Mutable;
}

char *CreateIPTCDataFromProperties(char a1, IIODictionary *a2, unint64_t *a3)
{
  uint64_t v6;
  unsigned __int8 *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 *v10;
  __CFArray *IIMHashArrayForIIMBlock;
  const __CFArray *v12;
  CFIndex v13;
  char *v14;
  uint64_t v15;
  const __CFNumber *ValueAtIndex;
  char *v18;
  char valuePtr;

  if (a2)
  {
    v6 = SizeOfIPTCData(a2);
    if (v6)
      goto LABEL_7;
  }
  else
  {
    v6 = 0;
  }
  if ((a1 & 1) != 0)
    return 0;
LABEL_7:
  v8 = v6 & 1;
  v9 = v6 + v8;
  v10 = (unsigned __int8 *)malloc_type_calloc(v6 + v8 + 54, 1uLL, 0xE8B19911uLL);
  v7 = v10;
  if (v10)
  {
    *((_DWORD *)v10 + 4) = 67390793;
    *(_OWORD *)v10 = *(_OWORD *)"Photoshop 3.0";
    *((_WORD *)v10 + 12) = bswap32(v6) >> 16;
    WriteIPTCData((CFDictionaryRef *)a2, v10 + 26);
    IIMHashArrayForIIMBlock = CreateIIMHashArrayForIIMBlock(v7 + 26, v6);
    if (!IIMHashArrayForIIMBlock)
    {
      v18 = (char *)&v7[v6 + v8];
      *(_QWORD *)(v18 + 46) = 0;
      *(_QWORD *)(v18 + 38) = 0;
      if (!a3)
        return (char *)v7;
      goto LABEL_15;
    }
    v12 = IIMHashArrayForIIMBlock;
    v13 = 0;
    v14 = (char *)&v7[v9 + 26];
    *(_QWORD *)v14 = 0x25044D494238;
    *((_DWORD *)v14 + 2) = 0x10000000;
    v15 = (uint64_t)&v7[v6 + 38 + v8];
    do
    {
      valuePtr = 0;
      ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v12, v13);
      if (CFNumberGetValue(ValueAtIndex, kCFNumberCharType, &valuePtr))
        *(_BYTE *)(v15 + v13) = valuePtr;
      ++v13;
    }
    while (v13 != 16);
    CFRelease(v12);
  }
  if (a3)
LABEL_15:
    *a3 = v9 + 54;
  return (char *)v7;
}

uint64_t SizeOfIPTCEntry(const __CFString *a1, _QWORD *a2)
{
  CFTypeID v4;
  uint64_t result;
  CFIndex usedBufLen;
  CFRange v7;

  v4 = CFGetTypeID(a1);
  result = CFStringGetTypeID();
  if (v4 == result)
  {
    v7.length = CFStringGetLength(a1);
    usedBufLen = 0;
    v7.location = 0;
    result = CFStringGetBytes(a1, v7, 0x8000100u, 0x3Fu, 0, 0, 0, &usedBufLen);
    if (usedBufLen)
      *a2 += usedBufLen + 5;
  }
  return result;
}

uint64_t WriteIPTCEntry(const __CFString *a1, _BYTE **a2)
{
  CFTypeID v4;
  uint64_t result;
  CFIndex Length;
  CFIndex usedBufLen;
  CFRange v8;
  CFRange v9;

  v4 = CFGetTypeID(a1);
  result = CFStringGetTypeID();
  if (v4 == result)
  {
    Length = CFStringGetLength(a1);
    usedBufLen = 0;
    v8.location = 0;
    v8.length = Length;
    result = CFStringGetBytes(a1, v8, 0x8000100u, 0x3Fu, 0, 0, 0, &usedBufLen);
    if (usedBufLen)
    {
      *a2[1] = 28;
      a2[1][1] = 2;
      a2[1][2] = *(_BYTE *)a2;
      a2[1][3] = BYTE1(usedBufLen);
      a2[1][4] = usedBufLen;
      v9.location = 0;
      v9.length = Length;
      result = CFStringGetBytes(a1, v9, 0x8000100u, 0x3Fu, 0, a2[1] + 5, 0xFFFFLL, 0);
      a2[1] += usedBufLen + 5;
    }
  }
  return result;
}

uint64_t RGBE_ReadHeader(FILE *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  int v19;
  FILE *v20;
  const char *v21;
  int v22;
  int v24;
  char v25[16];
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    *(_DWORD *)a4 = 0;
    *(_BYTE *)(a4 + 4) = 0;
    __asm { FMOV            V0.2S, #1.0 }
    *(_QWORD *)(a4 + 20) = _D0;
  }
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  *(_OWORD *)v25 = 0u;
  v26 = 0u;
  v24 = 0;
  if (!fgets(v25, 128, a1))
    goto LABEL_51;
  if (!a4 || v25[0] != 35 || v25[1] != 63)
    goto LABEL_15;
  v12 = 0;
  *(_DWORD *)a4 |= 1u;
  v13 = MEMORY[0x1E0C80978];
  do
  {
    v14 = v25[v12 + 2];
    if (!v25[v12 + 2])
      break;
    if ((v14 & 0x80000000) != 0)
    {
      if (__maskrune(v25[v12 + 2], 0x4000uLL))
        break;
    }
    else if ((*(_DWORD *)(v13 + 4 * v14 + 60) & 0x4000) != 0)
    {
      break;
    }
    *(_BYTE *)(a4 + 4 + v12++) = v14;
  }
  while (v12 != 15);
  *(_BYTE *)(a4 + v12 + 4) = 0;
  if (!fgets(v25, 128, a1))
    goto LABEL_51;
  while (1)
  {
LABEL_15:
    if (v25[0] == 10 || v25[0] == 0)
    {
      v20 = (FILE *)*MEMORY[0x1E0C80C10];
      v21 = "no FORMAT specifier found";
LABEL_39:
      fprintf(v20, "RGBE bad file format: %s\n", v21);
      return 0xFFFFFFFFLL;
    }
    if (*(_QWORD *)v25 == 0x333D54414D524F46
      && *(_QWORD *)&v25[8] == 0x6C725F7469622D32
      && (_QWORD)v26 == 0xA656267725F65)
    {
      v22 = 8;
      goto LABEL_42;
    }
    if (*(_QWORD *)v25 == 0x663D54414D524F46 && *(_QWORD *)&v25[6] == 0xA74616F6C663DLL)
      break;
    if (a4)
    {
      if (sscanf(v25, "GAMMA=%g", &v24) == 1)
      {
        *(_DWORD *)(a4 + 20) = v24;
        v19 = 2;
LABEL_35:
        *(_DWORD *)a4 |= v19;
        goto LABEL_36;
      }
      if (sscanf(v25, "EXPOSURE=%g", &v24) == 1)
      {
        *(_DWORD *)(a4 + 24) = v24;
        v19 = 4;
        goto LABEL_35;
      }
    }
LABEL_36:
    if (!fgets(v25, 128, a1))
      goto LABEL_51;
  }
  v22 = 16;
LABEL_42:
  *(_DWORD *)a4 |= v22;
  while (fgets(v25, 128, a1))
  {
    if (v25[0] == 10)
    {
      if (!fgets(v25, 128, a1))
        break;
      if (sscanf(v25, "-Y %d +X %d", a3, a2) <= 1
        && sscanf(v25, "+X %d +Y %d", a2, a3) <= 1
        && sscanf(v25, "+Y %d +X %d", a3, a2) <= 1)
      {
        v20 = (FILE *)*MEMORY[0x1E0C80C10];
        v21 = "missing image size specifier";
        goto LABEL_39;
      }
      return 0;
    }
  }
LABEL_51:
  perror("RGBE read error");
  return 0xFFFFFFFFLL;
}

uint64_t RGBE_ReadPixels(FILE *__stream, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  int v7;
  int __ptr;
  uint64_t v10;
  uint64_t v11;

  if (a3 < 1)
    return 0;
  v10 = v3;
  v11 = v4;
  __ptr = 0;
  v7 = a3 + 1;
  while (fread(&__ptr, 4uLL, 1uLL, __stream))
  {
    rgbe2float((float *)a2, (float *)(a2 + 4), (float *)(a2 + 8), &__ptr);
    *(_DWORD *)(a2 + 12) = 1065353216;
    --v7;
    a2 += 16;
    if (v7 <= 1)
      return 0;
  }
  perror("RGBE read error");
  return 0xFFFFFFFFLL;
}

void rgbe2float(float *a1, float *a2, float *a3, _BYTE *a4)
{
  float v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;

  if (a4[3])
  {
    v8 = ldexp(1.0, a4[3] - 136);
    LOBYTE(v9) = *a4;
    *(float *)&v10 = v8 * (float)v9;
    *a1 = *(float *)&v10;
    LOBYTE(v10) = a4[1];
    *(float *)&v11 = v8 * (float)v10;
    *a2 = *(float *)&v11;
    LOBYTE(v11) = a4[2];
    *a3 = v8 * (float)v11;
  }
  else
  {
    *a3 = 0.0;
    *a2 = 0.0;
    *a1 = 0.0;
  }
}

uint64_t RGBE_ReadPixels_RLE(FILE *__stream, uint64_t a2, unsigned int a3, int a4)
{
  int v4;
  int v8;
  char *v10;
  size_t v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  char *v15;
  char *v16;
  unsigned int v17;
  uint64_t v18;
  int v19;
  size_t v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;
  size_t v24;
  uint64_t v25;
  __int16 v26;
  int __ptr;

  v4 = a4;
  if (a3 - 0x8000 < 0xFFFF8008)
  {
    v8 = a4 * a3;
    return RGBE_ReadPixels(__stream, a2, v8);
  }
  if (a4 < 1)
  {
    v10 = 0;
LABEL_39:
    free(v10);
    return 0;
  }
  v10 = 0;
  __ptr = 0;
  v26 = 0;
  v11 = 4 * a3;
  v12 = 2 * a3;
  v25 = 3 * a3;
  while (1)
  {
    if (!fread(&__ptr, 4uLL, 1uLL, __stream))
    {
LABEL_40:
      free(v10);
      perror("RGBE read error");
      return 0xFFFFFFFFLL;
    }
    v13 = __ptr == 2 && BYTE1(__ptr) == 2;
    if (!v13 || SBYTE2(__ptr) < 0)
      break;
    if ((HIBYTE(__ptr) | (BYTE2(__ptr) << 8)) != a3)
    {
LABEL_36:
      free(v10);
      fprintf((FILE *)*MEMORY[0x1E0C80C10], "RGBE bad file format: %s\n");
      return 0xFFFFFFFFLL;
    }
    if (!v10)
    {
      v10 = (char *)malloc_type_malloc(v11, 0x5C5D87ABuLL);
      if (!v10)
      {
        fprintf((FILE *)*MEMORY[0x1E0C80C10], "RGBE error: %s\n");
        return 0xFFFFFFFFLL;
      }
    }
    v23 = v12;
    v24 = v11;
    v14 = 0;
    v15 = v10;
    do
    {
      v16 = &v10[++v14 * a3];
      while (v15 < v16)
      {
        if (!fread(&v26, 2uLL, 1uLL, __stream))
          goto LABEL_40;
        v17 = v26;
        v18 = v16 - v15;
        if (v26 < 0x81u)
        {
          if (!(_BYTE)v26 || v18 < v26)
            goto LABEL_36;
          *v15++ = HIBYTE(v26);
          if (v17 >= 2)
          {
            v20 = v17 - 1;
            if (!fread(v15, v20, 1uLL, __stream))
              goto LABEL_40;
            v15 += v20;
          }
        }
        else
        {
          if (v18 < v26 - 128)
            goto LABEL_36;
          v19 = v26 - 127;
          do
          {
            *v15++ = HIBYTE(v26);
            --v19;
          }
          while (v19 > 1);
        }
      }
    }
    while (v14 != 4);
    v21 = 0;
    v12 = v23;
    do
    {
      LOBYTE(__ptr) = v10[v21];
      BYTE1(__ptr) = v10[a3 + v21];
      BYTE2(__ptr) = v10[(v23 + v21)];
      HIBYTE(__ptr) = v10[v25 + v21];
      rgbe2float((float *)a2, (float *)(a2 + 4), (float *)(a2 + 8), &__ptr);
      *(_DWORD *)(a2 + 12) = 1065353216;
      a2 += 16;
      ++v21;
    }
    while (a3 != v21);
    v22 = __OFSUB__(v4--, 1);
    v11 = v24;
    if ((v4 < 0) ^ v22 | (v4 == 0))
      goto LABEL_39;
  }
  rgbe2float((float *)a2, (float *)(a2 + 4), (float *)(a2 + 8), &__ptr);
  *(_DWORD *)(a2 + 12) = 1065353216;
  a2 += 16;
  free(v10);
  v8 = v4 * a3 - 1;
  return RGBE_ReadPixels(__stream, a2, v8);
}

size_t ImageIOSIMD_GetVectorLevelName(unint64_t a1, char *__str, size_t __size)
{
  size_t v7;
  uint64_t v8;
  unsigned int v9;
  size_t v10;
  unsigned int v11;
  size_t v12;
  size_t v13;
  size_t v15;

  if (!__size)
    return -1;
  if (!a1)
    return snprintf(__str, __size, "<scalar only>");
  if (a1 > 0x20)
    return snprintf(__str, __size, "<invalid value>");
  v8 = 0;
  v7 = 0;
  while (1)
  {
    if (1 << v8 > a1)
    {
LABEL_22:
      v13 = __size - 1;
      if (v7 < __size - 1)
        v13 = v7;
      __str[v13] = 0;
      return v7;
    }
    if (((1 << v8) & a1) != 0)
      break;
    ++v8;
LABEL_21:
    if (v8 == 6)
      goto LABEL_22;
  }
  if (!v7)
  {
LABEL_16:
    v11 = snprintf(&__str[v7], __size - v7, "%s", ImageIOSIMD_GetVectorLevelName::kVectorLevelNames[++v8]);
    if ((v11 & 0x80000000) != 0)
      goto LABEL_22;
    v12 = v11;
    if (v11 >= __size - v7)
      v12 = __size - v7;
    v7 += v12;
    goto LABEL_21;
  }
  v9 = snprintf(&__str[v7], __size - v7, " | ");
  if ((v9 & 0x80000000) == 0)
  {
    v10 = v9;
    if (v9 >= __size - v7)
      v10 = __size - v7;
    v7 += v10;
    goto LABEL_16;
  }
  v15 = __size - 1;
  if (v7 < __size - 1)
    v15 = v7;
  __str[v15] = 0;
  return (int)v7;
}

uint64_t ImageIOSIMD_GetVectorLevel()
{
  if (ImageIOSIMD_GetVectorLevel::vectorPredicate != -1)
    dispatch_once(&ImageIOSIMD_GetVectorLevel::vectorPredicate, &__block_literal_global_8);
  return vectorLevel;
}

uint64_t ImageIOSIMD_GetHardwareVectorLevel()
{
  if (ImageIOSIMD_GetHardwareVectorLevel::hardwarePredicate != -1)
    dispatch_once(&ImageIOSIMD_GetHardwareVectorLevel::hardwarePredicate, &__block_literal_global_12);
  return ImageIOSIMD_GetHardwareVectorLevel::hardwareLevel;
}

void ImageIOSIMD_SetVectorLevel(uint64_t a1)
{
  if (ImageIOSIMD_GetVectorLevel::vectorPredicate != -1)
    dispatch_once(&ImageIOSIMD_GetVectorLevel::vectorPredicate, &__block_literal_global_8);
  if (vectorLevel != a1)
  {
    if (ImageIOSIMD_GetHardwareVectorLevel::hardwarePredicate != -1)
      dispatch_once(&ImageIOSIMD_GetHardwareVectorLevel::hardwarePredicate, &__block_literal_global_12);
    vectorLevel = ImageIOSIMD_GetHardwareVectorLevel::hardwareLevel & a1;
  }
}

uint64_t WebPReadPlugin::WebPReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t result;

  result = IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *(_QWORD *)result = &off_1E1BAFE28;
  *(_WORD *)(result + 436) = 0;
  return result;
}

uint64_t WebPReadPlugin::WebPReadPlugin(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result;

  result = IIOReadPlugin::IIOReadPlugin(a1, a2, a3);
  *(_QWORD *)result = &off_1E1BAFE28;
  *(_WORD *)(result + 436) = 0;
  return result;
}

void WebPReadPlugin::~WebPReadPlugin(WebPReadPlugin *this)
{
  IIOReadPlugin::~IIOReadPlugin(this);
  JUMPOUT(0x18D761C30);
}

uint64_t WebPReadPlugin::loadDataFromXPCObject(WebPReadPlugin *this, void *a2)
{
  uint64_t result;
  _WORD *data;
  _WORD *v6;
  size_t length;

  result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!(_DWORD)result)
  {
    length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_webp", &length);
    if (length == 2)
    {
      v6 = data;
      result = 0;
      *((_WORD *)this + 218) = *v6;
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t WebPReadPlugin::saveDataToXPCObject(WebPReadPlugin *this, void *a2)
{
  uint64_t v4;

  v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!(_DWORD)v4)
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_webp", (char *)this + 436, 2uLL);
  return v4;
}

uint64_t WebPReadPlugin::handleChunks(uint64_t a1, uint64_t a2)
{
  int v4;
  int v5;
  char *v6;
  char *v7;
  uint64_t v8;
  const char *v9;
  uint64_t Chunk;
  CGMutableImageMetadataRef MetadataFromDatabuffer;
  uint64_t v12;
  const char *v13;
  CGMutableImageMetadataRef v14;
  void *TagWithPath;
  CGImageMetadata *MetadataFromXMPBuffer;
  uint64_t v17;
  const char *v18;
  CGImageMetadata *v19;
  int v20;
  int v21;
  IIODictionary *v22;
  IIODictionary *v23;
  IIODictionary *v24;
  IIODictionary *v25;
  IIODictionary *v26;
  IIODictionary *v27;
  IIODictionary *v28;
  IIODictionary *v29;
  _BYTE v31[24];
  _BYTE v32[24];
  _BYTE v33[24];
  _BYTE v34[24];
  _BYTE v35[24];
  _BYTE v36[24];
  _BYTE v37[24];
  _BYTE v38[24];
  int v39[4];
  int v40[4];
  __int128 v41;
  int v42[4];
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  uint64_t v47;

  v47 = 0;
  v45 = 0u;
  v46 = 0u;
  v44 = 0u;
  v4 = IIOSkipMetadata(*(IIODictionary **)(a1 + 48));
  v5 = IIOSkipXMP_and_IPTC(*(IIODictionary **)(a1 + 48));
  v6 = WebPDemuxInternal(a2, 0, 0, 263);
  if (!v6)
    return 0;
  v7 = v6;
  if (WebPDemuxGetChunk((uint64_t)v6, "ICCP", 1, (uint64_t)&v44))
  {
    _cg_jpeg_mem_term("handleChunks", 98, "ICCP: %p [%ld]\n", *((const void **)&v44 + 1), (_QWORD)v45);
    *(_QWORD *)(a1 + 160) = CGColorSpaceCreateWithCopyOfData(*((UInt8 **)&v44 + 1), v45);
    _cg_jpeg_mem_term(&v44, v8, v9);
  }
  Chunk = WebPDemuxGetChunk((uint64_t)v7, "EXIF", 1, (uint64_t)&v44);
  if ((_DWORD)Chunk)
  {
    _cg_jpeg_mem_term("handleChunks", 107, "EXIF: %p [%ld]\n", *((const void **)&v44 + 1), (_QWORD)v45);
    MetadataFromDatabuffer = CreateMetadataFromDatabuffer(*((const char **)&v44 + 1), v45, 0);
    if (MetadataFromDatabuffer)
    {
      v14 = MetadataFromDatabuffer;
      if (v4)
      {
        TagWithPath = CGImageMetadataGetTagWithPath(MetadataFromDatabuffer, 0, CFSTR("tiff:Orientation"));
        if (TagWithPath)
          CGImageMetadataAddTag(*(_QWORD *)(a1 + 64), TagWithPath);
      }
      else
      {
        CGImageMetadataMerge(*(_QWORD *)(a1 + 64), (uint64_t)MetadataFromDatabuffer, *(IIODictionary **)(a1 + 48));
      }
      CFRelease(v14);
    }
    _cg_jpeg_mem_term(&v44, v12, v13);
  }
  if (((v4 | v5) & 1) == 0)
  {
    Chunk = WebPDemuxGetChunk((uint64_t)v7, "XMP ", 1, (uint64_t)&v44);
    if ((_DWORD)Chunk)
    {
      MetadataFromXMPBuffer = CreateMetadataFromXMPBuffer(*((const char **)&v44 + 1), v45);
      if (MetadataFromXMPBuffer)
      {
        v19 = MetadataFromXMPBuffer;
        CGImageMetadataMerge(*(_QWORD *)(a1 + 64), (uint64_t)MetadataFromXMPBuffer, *(IIODictionary **)(a1 + 48));
        CFRelease(v19);
      }
      _cg_jpeg_mem_term(&v44, v17, v18);
    }
  }
  if (*(_BYTE *)(a1 + 436))
  {
    *(_OWORD *)v42 = 0u;
    v43 = 0u;
    *(_OWORD *)v40 = 0u;
    v41 = 0u;
    *(_OWORD *)v39 = 0u;
    WebPDemuxGetFrame((uint64_t)v7, *(_DWORD *)(a1 + 208) + 1, (uint64_t)v39);
    v20 = v40[2];
    if (v40[2] >= 11)
      v21 = v40[2];
    else
      v21 = 100;
    v22 = *(IIODictionary **)(a1 + 56);
    IIONumber::IIONumber((IIONumber *)v38, (double)v21 / 1000.0);
    IIODictionary::setObjectForKeyGroup(v22, (uint64_t)v38, CFSTR("DelayTime"), CFSTR("{WebP}"));
    IIONumber::~IIONumber((IIONumber *)v38);
    v23 = *(IIODictionary **)(a1 + 56);
    IIONumber::IIONumber((IIONumber *)v37, (double)v20 / 1000.0);
    IIODictionary::setObjectForKeyGroup(v23, (uint64_t)v37, CFSTR("UnclampedDelayTime"), CFSTR("{WebP}"));
    IIONumber::~IIONumber((IIONumber *)v37);
    if (*(_BYTE *)(a1 + 437))
    {
      v24 = *(IIODictionary **)(a1 + 56);
      IIONumber::IIONumber((IIONumber *)v36, v39[2]);
      IIODictionary::setObjectForKeyGroup(v24, (uint64_t)v36, CFSTR("xOffset"), CFSTR("{WebP}"));
      IIONumber::~IIONumber((IIONumber *)v36);
      v25 = *(IIODictionary **)(a1 + 56);
      IIONumber::IIONumber((IIONumber *)v35, v39[3]);
      IIODictionary::setObjectForKeyGroup(v25, (uint64_t)v35, CFSTR("yOffset"), CFSTR("{WebP}"));
      IIONumber::~IIONumber((IIONumber *)v35);
      v26 = *(IIODictionary **)(a1 + 56);
      IIONumber::IIONumber((IIONumber *)v34, v40[0]);
      IIODictionary::setObjectForKeyGroup(v26, (uint64_t)v34, CFSTR("width"), CFSTR("{WebP}"));
      IIONumber::~IIONumber((IIONumber *)v34);
      v27 = *(IIODictionary **)(a1 + 56);
      IIONumber::IIONumber((IIONumber *)v33, v40[1]);
      IIODictionary::setObjectForKeyGroup(v27, (uint64_t)v33, CFSTR("height"), CFSTR("{WebP}"));
      IIONumber::~IIONumber((IIONumber *)v33);
      v28 = *(IIODictionary **)(a1 + 56);
      IIONumber::IIONumber((IIONumber *)v32, v40[3]);
      IIODictionary::setObjectForKeyGroup(v28, (uint64_t)v32, CFSTR("disposeOp"), CFSTR("{WebP}"));
      IIONumber::~IIONumber((IIONumber *)v32);
      v29 = *(IIODictionary **)(a1 + 56);
      IIONumber::IIONumber((IIONumber *)v31, v42[3]);
      IIODictionary::setObjectForKeyGroup(v29, (uint64_t)v31, CFSTR("blendOp"), CFSTR("{WebP}"));
      IIONumber::~IIONumber((IIONumber *)v31);
    }
  }
  WebPDemuxDelete(v7);
  return Chunk;
}

void sub_187FB8284(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t WebPReadPlugin::initialize(IIOImageReadSession **this, IIODictionary *a2)
{
  IIODictionary *v3;
  IIOImageRead *v4;
  const UInt8 *BytePtr;
  uint64_t v6;
  const __CFData *v7;
  unint64_t Size;
  int v9;
  int v10;
  int v11;
  int v12;
  char v13;
  char v14;
  IIOImageRead **v15;
  _OWORD v17[2];
  uint64_t v18;
  const UInt8 *v19;
  unint64_t v20;
  void *v21;

  v20 = 0;
  v21 = 0;
  v19 = 0;
  v18 = 0;
  memset(v17, 0, sizeof(v17));
  if (!IIOImageReadSession::isFinal(this[3]))
    goto LABEL_18;
  v3 = this[6];
  if (v3)
    LOBYTE(v3) = IIODictionary::getBoolForKey(v3, CFSTR("IIO_SKIP_WEBP_COMPOSING"));
  *((_BYTE *)this + 437) = (_BYTE)v3;
  v4 = IIOImageReadSession::retainBytePointer(this[3], (const __CFData **)&v21, 0);
  if (v4)
  {
    BytePtr = (const UInt8 *)v4;
    v6 = 0;
  }
  else
  {
    v7 = IIOImageReadSession::copyData((IIOImageRead **)this[3]);
    if (!v7)
    {
LABEL_18:
      v6 = 4294967246;
LABEL_29:
      kdebug_trace();
      return v6;
    }
    v6 = (uint64_t)v7;
    BytePtr = CFDataGetBytePtr(v7);
  }
  v19 = BytePtr;
  Size = (unint64_t)IIOImageReadSession::getSize(this[3]);
  v20 = Size;
  if (WebPGetFeaturesInternal((uint64_t)BytePtr, Size, (uint64_t)v17, 521))
    goto LABEL_16;
  v9 = v17[0];
  v10 = DWORD1(v17[0]);
  if (SLODWORD(v17[0]) >= 0x4000 || SDWORD1(v17[0]) >= 0x4000)
  {
    _cg_jpeg_mem_term("initialize", 210, "*** ERROR: 'WebP' bad dimension: %d x %d\n");
    goto LABEL_16;
  }
  v11 = DWORD2(v17[0]);
  if (DWORD2(v17[0]))
    v12 = 4;
  else
    v12 = 3;
  if (80000 * Size < DWORD1(v17[0]) * LODWORD(v17[0]) * v12)
  {
    _cg_jpeg_mem_term("initialize", 216, "*** ERROR: fileSize: %ld   canvas: %d x %d --> malformed image? (factor: %g)\n");
LABEL_16:
    if (v6)
    {
      CFRelease((CFTypeRef)v6);
      goto LABEL_18;
    }
    v14 = 0;
    v6 = 4294967246;
    goto LABEL_25;
  }
  *((_BYTE *)this + 436) = HIDWORD(v17[0]) != 0;
  if (v11)
    v13 = 3;
  else
    v13 = 5;
  *((_BYTE *)this + 246) = v13;
  *((_DWORD *)this + 57) = v9;
  *((_DWORD *)this + 58) = v10;
  *((_WORD *)this + 122) = 4;
  *((_DWORD *)this + 59) = 4 * v9;
  *((_DWORD *)this + 60) = 2097160;
  *((_DWORD *)this + 81) = 1380401696;
  this[20] = 0;
  *((_WORD *)this + 172) = 0;
  *((_BYTE *)this + 346) = 0;
  WebPReadPlugin::handleChunks((uint64_t)this, (uint64_t)&v19);
  v14 = 1;
  *((_WORD *)this + 188) = 1;
  if (v6)
  {
    CFRelease((CFTypeRef)v6);
    return 0;
  }
LABEL_25:
  if (BytePtr)
  {
    v15 = (IIOImageRead **)this[3];
    if (v15)
      IIOImageReadSession::releaseBytePointer(v15, v21);
  }
  if ((v14 & 1) == 0)
    goto LABEL_29;
  return v6;
}

uint64_t WebPReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v2;

  v2 = *(__int16 *)(a1 + 376);
  if (v2 == 12)
    return IIOReadPlugin::setupImageProviderCallbackV2(a1, a2, (uint64_t)IIO_Reader::CopyImageBlockSetProc, (uint64_t)IIO_Reader::CopyIOSurfaceProc);
  if (v2 == 1)
    return IIOReadPlugin::setupCallback(a1, a2);
  return 4294967246;
}

uint64_t WebPReadPlugin::decodeAnimatedWebP(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v6;
  int v7;
  int v8;
  char *v9;
  uint64_t v10;
  const char *v11;
  void **v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  size_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  _BYTE *v23;
  _BYTE *v24;
  int v25;
  uint64_t v27;
  BOOL v29;
  int v30;
  uint64_t v31;
  _OWORD v32[2];
  int v33;
  _OWORD v34[2];
  int v35;

  if (*(_BYTE *)(a1 + 246))
    v6 = 1;
  else
    v6 = *(_BYTE *)(a1 + 404) == 1;
  v29 = v6;
  v7 = *(_DWORD *)(a1 + 300);
  v35 = 0;
  memset(v34, 0, sizeof(v34));
  WebPAnimDecoderOptionsInitInternal(v34, 263);
  if (*(_BYTE *)(a1 + 404) == 1)
    v8 = 8;
  else
    v8 = 1;
  LODWORD(v34[0]) = v8;
  v9 = WebPAnimDecoderNewInternal(a2, (int *)v34, 263);
  v12 = (void **)v9;
  if (v9)
  {
    v33 = 0;
    memset(v32, 0, sizeof(v32));
    if (WebPAnimDecoderGetInfo((uint64_t)v9, (uint64_t)v32))
    {
      if (*(_QWORD *)&v32[0] != *(_QWORD *)(a1 + 292))
      {
        v27 = 4294967246;
        goto LABEL_29;
      }
      v13 = 0;
      while (WebPAnimDecoderHasMoreFrames((_BOOL8)v12))
      {
        v31 = 0;
        v30 = 0;
        if (!WebPAnimDecoderGetNext((uint64_t)v12, &v31, &v30))
          break;
        v14 = *(unsigned int *)(a1 + 208);
        if (v13 == v14)
        {
          v15 = DWORD1(v32[0]);
          if (v29)
          {
            if (DWORD1(v32[0]))
            {
              v16 = 0;
              v17 = 0;
              v18 = v31;
              v19 = (4 * LODWORD(v32[0]));
              do
              {
                memcpy((void *)(a3 + v17), (const void *)(v18 + v16), v19);
                v17 += v7;
                v16 += v19;
                --v15;
              }
              while (v15);
            }
          }
          else if (DWORD1(v32[0]))
          {
            v20 = 0;
            v21 = v31;
            v22 = v32[0];
            do
            {
              if (v22)
              {
                v23 = (_BYTE *)(a3 + (v7 * v20));
                v24 = (_BYTE *)(v21 + (4 * v20 * v22));
                v25 = v22;
                do
                {
                  *v23 = *v24;
                  v23[1] = v24[1];
                  v23[2] = v24[2];
                  v23 += 3;
                  v24 += 4;
                  --v25;
                }
                while (v25);
              }
              ++v20;
            }
            while (v20 != v15);
          }
          v14 = *(unsigned int *)(a1 + 208);
        }
        if (v13++ >= v14)
        {
          v27 = 0;
          goto LABEL_29;
        }
      }
    }
  }
  v27 = 4294967243;
LABEL_29:
  WebPAnimDecoderDelete(v12, v10, v11);
  return v27;
}

uint64_t WebPReadPlugin::decodeWebP(uint64_t a1, uint64_t *a2, void *a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  vImagePixelCount v9;
  size_t v10;
  vImage_Buffer v12;

  if (*(_BYTE *)(a1 + 246))
  {
    v6 = *a2;
    v7 = a2[1];
    v8 = *(_DWORD *)(a1 + 300);
    if (*(_BYTE *)(a1 + 405))
      WebPDecodeRGBAInto(v6, v7, (uint64_t)a3, a4, v8);
    else
      WebPDecodeBGRAInto(v6, v7, (uint64_t)a3, a4, v8);
    if (*(_BYTE *)(a1 + 406) == 1)
    {
      v9 = *(unsigned int *)(a1 + 296);
      v12.data = a3;
      v12.height = v9;
      v10 = *(unsigned int *)(a1 + 300);
      v12.width = *(unsigned int *)(a1 + 292);
      v12.rowBytes = v10;
      vImagePremultiplyData_RGBA8888(&v12, &v12, 0x10u);
    }
  }
  else
  {
    WebPDecodeRGBInto(*a2, a2[1], (uint64_t)a3, a4, *(_DWORD *)(a1 + 300));
  }
  return 0;
}

uint64_t WebPReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4)
{
  int v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  IIOImageRead **v20;
  _BOOL4 v21;
  void *BaseAddress;
  size_t Height;
  uint64_t BlockArray;
  size_t v25;
  double v26;
  double v27;
  unint64_t v28;
  unsigned int v29;
  uint64_t v30;
  const char **v31;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  double v36;
  double v37;
  size_t v38;
  CGRect v39;
  CGRect v40;

  v38 = 0;
  *((_DWORD *)this + 52) = *((_QWORD *)a2 + 9);
  if ((gIIODebugFlags & 0x20000) == 0)
    goto LABEL_26;
  v8 = *((_DWORD *)this + 51);
  v9 = v8 >> 24;
  v10 = MEMORY[0x1E0C80978];
  if (v8 < 0)
  {
    v11 = __maskrune(v9, 0x40000uLL);
    v8 = *((_DWORD *)this + 51);
  }
  else
  {
    v11 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v9 + 60) & 0x40000;
  }
  if (v11)
    v12 = (v8 >> 24);
  else
    v12 = 46;
  v13 = v8 << 8 >> 24;
  if (v8 << 8 < 0)
  {
    v14 = __maskrune(v13, 0x40000uLL);
    v8 = *((_DWORD *)this + 51);
  }
  else
  {
    v14 = *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
  }
  if (v14)
    v15 = (v8 << 8 >> 24);
  else
    v15 = 46;
  v16 = (__int16)v8 >> 8;
  if (v8 << 16 < 0)
  {
    v17 = __maskrune(v16, 0x40000uLL);
    v8 = *((_DWORD *)this + 51);
  }
  else
  {
    v17 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
  }
  if (v17)
    v18 = ((__int16)v8 >> 8);
  else
    v18 = 46;
  if ((v8 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v10 + 4 * (char)v8 + 60) & 0x40000) != 0)
      goto LABEL_22;
LABEL_24:
    v19 = 46;
    goto LABEL_25;
  }
  if (!__maskrune((char)v8, 0x40000uLL))
    goto LABEL_24;
LABEL_22:
  v19 = *((char *)this + 204);
LABEL_25:
  ImageIOLog("  '%c%c%c%c' [%s] %s\n", v12, v15, v18, v19, iioTypeStr[a3], "virtual OSStatus WebPReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  v20 = (IIOImageRead **)*((_QWORD *)this + 3);
  if (v20)
    v21 = IIOImageReadSession::mapData(v20);
  else
    v21 = 0;
  if (a3 == 3)
  {
    BlockArray = IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
    LODWORD(v28) = *((_DWORD *)this + 73);
    v27 = (double)v28;
    v29 = *((_DWORD *)this + 74);
    v26 = (double)v29;
    v25 = *((unsigned int *)this + 75) * (unint64_t)v29;
    BaseAddress = (void *)_ImageIO_Malloc(v25, *((_QWORD *)this + 48), &v38, (uint64_t)kImageMalloc_WEBP_Data[0], *((_DWORD *)this + 108), 0, 0);
  }
  else
  {
    if (a3 != 1)
    {
      BlockArray = 0;
      BaseAddress = 0;
      goto LABEL_39;
    }
    if (!a4 || !*a4)
    {
      BlockArray = 0;
      if (!v21)
        return BlockArray;
      goto LABEL_46;
    }
    IOSurfaceLock(*a4, 0, 0);
    BaseAddress = IOSurfaceGetBaseAddress(*a4);
    Height = IOSurfaceGetHeight(*a4);
    BlockArray = 0;
    v25 = IOSurfaceGetBytesPerRow(*a4) * Height;
    v38 = v25;
    v26 = 0.0;
    v27 = 0.0;
  }
  if (!BaseAddress)
    goto LABEL_39;
  bzero(BaseAddress, v25);
  v30 = (*(uint64_t (**)(IIOReadPlugin *, void *, size_t))(*(_QWORD *)this + 112))(this, BaseAddress, v25);
  if ((_DWORD)v30)
  {
    BlockArray = v30;
    *((_DWORD *)this + 26) = 0;
    goto LABEL_39;
  }
  if (a3 == 3)
  {
    v33 = 0;
    v39.origin.x = 0.0;
    v39.origin.y = 0.0;
    v39.size.width = v27;
    v39.size.height = v26;
    **((_QWORD **)this + 12) = IIOReadPlugin::createImageBlock(this, BaseAddress, v25, v39, *((unsigned int *)this + 75), *((unsigned __int8 *)this + 343));
    if (CGRectEqualToRect(*(CGRect *)((char *)this + 120), *MEMORY[0x1E0C9D628]))
    {
      v34 = 0;
    }
    else
    {
      v40.origin.x = 0.0;
      v40.origin.y = 0.0;
      v40.size.width = v27;
      v40.size.height = v26;
      *(CGRect *)(&v34 - 1) = CGRectUnion(*(CGRect *)((char *)this + 120), v40);
      v33 = v35;
      v27 = v36;
      v26 = v37;
    }
    BlockArray = 0;
    BaseAddress = 0;
    *((_QWORD *)this + 15) = v33;
    *((_QWORD *)this + 16) = v34;
    *((double *)this + 17) = v27;
    *((double *)this + 18) = v26;
LABEL_39:
    if (!a4)
      goto LABEL_42;
    goto LABEL_40;
  }
  IOSurfaceUnlock(*a4, 0, 0);
  BlockArray = 0;
LABEL_40:
  if (*a4)
    IOSurfaceUnlock(*a4, 0, 0);
LABEL_42:
  if (a3 == 3 && BaseAddress)
    _ImageIO_Free((unint64_t)BaseAddress, v38);
  if (v21)
  {
LABEL_46:
    v31 = (const char **)*((_QWORD *)this + 3);
    if (v31)
      IIOImageReadSession::unmapData(v31);
  }
  return BlockArray;
}

uint64_t WebPReadPlugin::decodeImageData(IIOImageReadSession **this, unsigned __int8 *a2, uint64_t a3)
{
  IIOImageRead *v6;
  const UInt8 *BytePtr;
  const __CFData *v8;
  const __CFData *v9;
  uint64_t v10;
  IIOImageRead **v11;
  void *v13;
  uint64_t v14[2];

  v13 = 0;
  v6 = IIOImageReadSession::retainBytePointer(this[3], (const __CFData **)&v13, 0);
  if (v6)
  {
    BytePtr = (const UInt8 *)v6;
    v8 = 0;
  }
  else
  {
    v9 = IIOImageReadSession::copyData((IIOImageRead **)this[3]);
    if (!v9)
      return 0;
    v8 = v9;
    BytePtr = CFDataGetBytePtr(v9);
  }
  v14[0] = (uint64_t)BytePtr;
  v14[1] = (uint64_t)IIOImageReadSession::getSize(this[3]);
  if (*((_BYTE *)this + 436))
  {
    v10 = WebPReadPlugin::decodeAnimatedWebP((uint64_t)this, (uint64_t)v14, (uint64_t)a2);
    if ((_DWORD)v10)
      _cg_jpeg_mem_term("decodeImageData", 489, "*** ERROR: decodeAnimatedWebP failed\n");
  }
  else
  {
    WebPReadPlugin::decodeWebP((uint64_t)this, v14, a2, a3);
    v10 = 0;
  }
  if (v8)
  {
    CFRelease(v8);
  }
  else if (BytePtr)
  {
    v11 = (IIOImageRead **)this[3];
    if (v11)
      IIOImageReadSession::releaseBytePointer(v11, v13);
  }
  return v10;
}

void BCWritePlugin::BCWritePlugin(BCWritePlugin *this, IIOImageWriteSession *a2, IIOImageDestination *a3, char a4)
{
  uint64_t v5;

  IIOWritePlugin::IIOWritePlugin(this, a2, a3, 4u);
  *(_QWORD *)v5 = &off_1E1BAC680;
  *(_QWORD *)(v5 + 48) = 0;
  *(_BYTE *)(v5 + 56) = 0;
  *(_BYTE *)(v5 + 57) = a4;
  *(_QWORD *)(v5 + 64) = 0;
}

void BCWritePlugin::BCWritePlugin(IIOWritePlugin *a1, IIOImageWriteSession *a2, IIOImageDestination *a3, uint64_t a4)
{
  uint64_t v5;

  IIOWritePlugin::IIOWritePlugin(a1, a2, a3, 4u);
  *(_QWORD *)v5 = &off_1E1BAC680;
  *(_QWORD *)(v5 + 48) = 0;
  *(_WORD *)(v5 + 56) = 0;
  *(_QWORD *)(v5 + 64) = a4;
}

void BCWritePlugin::~BCWritePlugin(BCWritePlugin *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

const __CFDictionary *BCWritePlugin::handleProperties(BCWritePlugin *this, IIODictionary *a2)
{
  float FloatForKey;
  float v5;
  float v6;
  const __CFDictionary *result;

  *((_QWORD *)this + 5) = 0;
  if (IIODictionary::containsKey(a2, CFSTR("kCGImagePropertyBCFormat")))
    *((_DWORD *)this + 12) = IIODictionary::getUint32ForKey(a2, CFSTR("kCGImagePropertyBCFormat"));
  if (IIODictionary::containsKey(a2, CFSTR("kCGImageDestinationLossyCompressionQuality")))
  {
    FloatForKey = IIODictionary::getFloatForKey(a2, CFSTR("kCGImageDestinationLossyCompressionQuality"));
    v5 = 0.0;
    if (FloatForKey >= 0.0)
    {
      v5 = FloatForKey;
      if (FloatForKey > 1.0)
        v5 = 1.0;
    }
    v6 = (1.0 - v5) * 0.0032;
    *((float *)this + 13) = v6;
  }
  else
  {
    *((_DWORD *)this + 13) = 978433815;
  }
  result = IIODictionary::containsKey(a2, CFSTR("kCGImagePropertyBCWeightChannelsEqually"));
  if ((_DWORD)result)
  {
    result = IIODictionary::getUint32ForKey(a2, CFSTR("kCGImagePropertyBCWeightChannelsEqually"));
    if ((_DWORD)result)
      *((_QWORD *)this + 5) |= 0x40uLL;
  }
  return result;
}

uint64_t BCWritePlugin::writeOneImage(BCWritePlugin *this, CGImage *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

uint64_t BCWritePlugin::writeOne(IIOImageWriteSession **this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  unsigned int AlphaInfo;
  __int16 BitmapInfo;
  uint64_t v8;
  uint64_t Property;
  int v10;
  const __CFNumber *v11;
  at_alpha_t v12;
  CGColorSpace *SourceGeomColorSpace;
  CGColorSpaceModel Model;
  int Error;
  int v16;
  at_texel_format_t v17;
  uint64_t v18;
  int v19;
  at_block_format_t v20;
  int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  int v25;
  NSObject *v26;
  NSObject *v27;
  BOOL is_compression_monolithic;
  uint64_t v29;
  size_t v30;
  uint64_t v31;
  uint64_t v32;
  char v33;
  uint64_t v34;
  void *v35;
  unint64_t block_counts;
  unsigned int v37;
  unint64_t v38;
  size_t block_size;
  size_t v40;
  char *v41;
  char *v42;
  BOOL v43;
  uint64_t v44;
  unsigned int v46;
  at_flags_t v47;
  IIOImageWriteSession *v48;
  unsigned int v49;
  uint64_t v50;
  uint64_t v51;
  size_t v52;
  IIOImageWriteSession **v53;
  int __ptr;
  at_block_buffer_t dest;
  at_texel_region_t src;
  at_size_t v57;

  BCWritePlugin::handleProperties((BCWritePlugin *)this, a3);
  AlphaInfo = IIOImagePixelDataProvider::getAlphaInfo(a2);
  BitmapInfo = IIOImagePixelDataProvider::getBitmapInfo(a2);
  IIOImageSource::imageReadRef(a2);
  CGImageGetImageProvider();
  v8 = *MEMORY[0x1E0C9AE50];
  Property = CGImageProviderGetProperty();
  if (v8 == Property && (v11 = (const __CFNumber *)CGImageProviderGetProperty()) != 0)
  {
    IIONumber::IIONumber((IIONumber *)&src, v11);
    v10 = IIONumber::uint32Num((IIONumber *)&src);
    IIONumber::~IIONumber((IIONumber *)&src);
  }
  else
  {
    v10 = 4;
  }
  if (AlphaInfo >= 7)
  {
    _cg_jpeg_mem_term("writeOne", 202, "### alpha not handled: %X\n", AlphaInfo);
    v12 = at_alpha_opaque;
  }
  else
  {
    v12 = dword_188210AEC[AlphaInfo];
  }
  SourceGeomColorSpace = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(a2);
  Model = CGColorSpaceGetModel(SourceGeomColorSpace);
  Error = _cg_GifLastError((uint64_t)a2);
  v49 = v10;
  if (Model == kCGColorSpaceModelRGB)
  {
    v18 = 10;
    if ((BitmapInfo & 0x100) == 0)
      v18 = 7;
    if (Error == 16)
      v17 = v18;
    else
      v17 = at_texel_format_rgba8_unorm;
    goto LABEL_20;
  }
  if (Model)
  {
    v17 = at_texel_format_invalid;
LABEL_20:
    v16 = 1;
    goto LABEL_24;
  }
  if (Error == 16)
  {
    v16 = 0;
    if (AlphaInfo)
      v17 = at_texel_format_la16_unorm;
    else
      v17 = at_texel_format_l16_unorm;
  }
  else
  {
    v16 = 0;
    if (AlphaInfo)
      v17 = at_texel_format_la8_unorm;
    else
      v17 = at_texel_format_l8_unorm;
  }
LABEL_24:
  v19 = *((_DWORD *)this + 12);
  v50 = Property;
  v51 = v8;
  if (v19 <= 35918)
  {
    v20 = at_block_format_bc1;
    if (v19 > 33778)
    {
      if ((v19 - 35916) < 2)
        goto LABEL_51;
      if (v19 == 33779)
      {
LABEL_42:
        v20 = at_block_format_bc3;
        goto LABEL_51;
      }
      v21 = 35918;
    }
    else
    {
      if ((v19 - 33776) < 2)
        goto LABEL_51;
      if (!v19)
      {
        if (v17 - 1 <= 3)
        {
          v20 = qword_188210B08[v17 - 1];
          goto LABEL_51;
        }
        goto LABEL_48;
      }
      v21 = 33778;
    }
    if (v19 == v21)
    {
      v20 = at_block_format_bc2;
      goto LABEL_51;
    }
LABEL_50:
    v20 = at_block_format_invalid;
    goto LABEL_51;
  }
  if (v19 > 36491)
  {
    if ((v19 - 36492) >= 2)
    {
      if (v19 == 36494)
      {
        v20 = at_block_format_bc6;
        goto LABEL_51;
      }
      if (v19 == 36495)
      {
        v20 = at_block_format_bc6u;
        goto LABEL_51;
      }
      goto LABEL_50;
    }
LABEL_48:
    v20 = at_block_format_bc7;
    goto LABEL_51;
  }
  switch(v19)
  {
    case 36283:
      v20 = at_block_format_bc4;
      break;
    case 36284:
      v20 = at_block_format_bc4s;
      break;
    case 36285:
      v20 = at_block_format_bc5;
      break;
    case 36286:
      v20 = at_block_format_bc5s;
      break;
    default:
      if (v19 == 35919)
        goto LABEL_42;
      goto LABEL_50;
  }
LABEL_51:
  v22 = IIOImageSource::count(a2);
  v23 = IIO_Reader::testHeaderSize(a2);
  if (*((_BYTE *)this + 57))
  {
    if (v16)
    {
      if (IIO_CGColorSpaceNameMatchesName(SourceGeomColorSpace, (const __CFString *)*MEMORY[0x1E0C9D908]))
      {
        v24 = 3;
      }
      else if (IIO_CGColorSpaceNameMatchesName(SourceGeomColorSpace, (const __CFString *)*MEMORY[0x1E0C9D8F8]))
      {
        v24 = 2;
      }
      else
      {
        v24 = 1;
      }
    }
    else
    {
      v24 = 0;
    }
    v25 = *((_DWORD *)this + 12);
    if (!v25)
    {
      if (v20 - 33 > 9)
        v25 = 0;
      else
        v25 = dword_188210B28[v20 - 33];
      *((_DWORD *)this + 12) = v25;
    }
    KTXWritePlugin::writeKTXHeader(this[2], v22, v23, 0, v24, AlphaInfo, 0, 1, 0, v25, 0, 1);
  }
  v26 = at_encoder_create(v17, v12, v20, v12, 0);
  v27 = v26;
  if (!v26)
  {
    v35 = 0;
    v42 = 0;
    goto LABEL_77;
  }
  v53 = this;
  is_compression_monolithic = at_encoder_is_compression_monolithic(v26, at_flags_default);
  v29 = IIOImagePlus::sourceImageProvider(a2);
  v30 = v29;
  *(_QWORD *)&src.validSize.z = 0;
  v31 = v23;
  if (v51 == v50 && !is_compression_monolithic)
  {
    v32 = v49;
    do
    {
      v31 = v32;
      v33 = v32 * v22;
      v32 *= 2;
    }
    while ((v33 & 0xF) != 0);
  }
  v34 = v31 * v29;
  v35 = malloc_type_malloc(v31 * v29, 0x12B15185uLL);
  src.texels = 0;
  *(_QWORD *)&src.validSize.x = __PAIR64__(v23, v22);
  src.validSize.z = 1;
  src.rowBytes = v30;
  src.sliceBytes = 0;
  *(_QWORD *)&v57.x = __PAIR64__(v23, v22);
  v57.z = 1;
  block_counts = (unint64_t)at_encoder_get_block_counts(v27, v57);
  v37 = block_counts;
  v38 = HIDWORD(block_counts);
  block_size = at_encoder_get_block_size(v27);
  v40 = v38 * v37 * block_size;
  dest.rowBytes = v37 * block_size;
  dest.sliceBytes = v40;
  v41 = (char *)malloc_type_calloc(v40, 1uLL, 0xADA0ED5AuLL);
  v42 = v41;
  if (v40)
    v43 = v41 == 0;
  else
    v43 = 1;
  if (v43)
  {
    LogError("writeOne", 359, "*** could not allocate dest buffer [%d bytes]\n", v40);
    goto LABEL_77;
  }
  v52 = v40;
  dest.blocks = v41;
  if (!v23)
  {
LABEL_91:
    v48 = v53[8];
    if (v48)
    {
      if ((*(uint64_t (**)(void))(*((_QWORD *)v48 + 1) + 24))() != v52
        || (*(unsigned int (**)(void))(*((_QWORD *)v53[8] + 1) + 64))())
      {
        goto LABEL_100;
      }
    }
    else if (*((_BYTE *)v53 + 57))
    {
      __ptr = v52;
      if (IIOImageWriteSession::putBytes(v53[2], &__ptr, 4uLL) != 4)
        goto LABEL_100;
      IIOImageWriteSession::putBytes(v53[2], v42, v52);
    }
LABEL_77:
    v44 = 0;
    if (!v27)
      goto LABEL_79;
    goto LABEL_78;
  }
  v46 = 0;
  v47 = (at_flags_t)v53[5];
  while (1)
  {
    if (v31 + (unint64_t)v46 > v23)
    {
      v31 = v23 - v46;
      v34 = v30 * v31;
    }
    src.validSize.y = v31;
    src.texels = v35;
    if (IIOImagePixelDataProvider::getBytes((uint64_t (**)(IIOImagePixelDataProvider *, void *))a2, v35) != v34)
    {
      LogError("writeOne", 384, "failed to read %ld bytes\n");
      goto LABEL_100;
    }
    dest.blocks = &v42[dest.rowBytes * (v46 >> 2)];
    if (at_encoder_compress_texels(v27, &src, &dest, *((float *)v53 + 13), v47) < 0.0)
      break;
    v46 += v31;
    if (v46 >= v23)
      goto LABEL_91;
  }
  LogError("writeOne", 394, "*** ERROR: at_encoder_compress_texels: %g (%ld)\n");
LABEL_100:
  v44 = 4294967246;
  if (v27)
LABEL_78:
    CFRelease(v27);
LABEL_79:
  if (v42)
    free(v42);
  if (v35)
    free(v35);
  return v44;
}

void sub_187FB94C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_list va;

  va_start(va, a12);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t BCWritePlugin::GetVkFormat(uint64_t this, IIODictionary *a2)
{
  IIODictionary *v2;
  int Uint32ForKey;
  int v4;

  if (this)
  {
    v2 = (IIODictionary *)this;
    this = (uint64_t)IIODictionary::containsKey((IIODictionary *)this, CFSTR("kCGImagePropertyBCFormat"));
    if ((_DWORD)this)
    {
      Uint32ForKey = IIODictionary::getUint32ForKey(v2, CFSTR("kCGImagePropertyBCFormat"));
      if (Uint32ForKey > 36282)
      {
        switch(Uint32ForKey)
        {
          case 36283:
            this = 139;
            break;
          case 36284:
            this = 140;
            break;
          case 36285:
            this = 141;
            break;
          case 36286:
            this = 142;
            break;
          default:
            switch(Uint32ForKey)
            {
              case 36492:
                this = 145;
                break;
              case 36493:
                this = 146;
                break;
              case 36494:
                this = 144;
                break;
              case 36495:
                this = 143;
                break;
              default:
LABEL_12:
                this = 0;
                break;
            }
            break;
        }
      }
      else
      {
        v4 = Uint32ForKey - 33776;
        this = 131;
        switch(v4)
        {
          case 0:
            return this;
          case 1:
            this = 133;
            break;
          case 2:
            this = 135;
            break;
          case 3:
            this = 137;
            break;
          default:
            goto LABEL_12;
        }
      }
    }
  }
  return this;
}

void IIO_Writer_BC::~IIO_Writer_BC(IIO_Writer_BC *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

uint64_t IIO_Writer_BC::write(IIO_Writer_BC *this, IIOImageWriteSession *a2, IIOImageDestination *a3)
{
  uint64_t v3;
  uint64_t v4;
  const char *v5;
  _OWORD v7[3];
  __int128 v8;
  uint64_t v9;

  v9 = 0;
  v8 = 0u;
  memset(v7, 0, sizeof(v7));
  IIOWritePlugin::IIOWritePlugin((IIOWritePlugin *)v7, a2, a3, 4u);
  v9 = 0;
  *(_QWORD *)&v7[0] = &off_1E1BAC680;
  *(_QWORD *)&v8 = 0;
  WORD4(v8) = 0;
  v3 = IIOWritePlugin::writeAll((IIOImageDestination **)v7);
  _cg_jpeg_mem_term(v7, v4, v5);
  return v3;
}

void sub_187FB96DC(void *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _cg_jpeg_mem_term(&a9, a2, a3);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187FB96C8);
}

uint64_t TIFFPredictorInit(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int8x16_t v16;
  uint64_t v17;
  uint64_t v18;
  char v20;

  v8 = *(_QWORD *)(a1 + 1096);
  if (!v8)
    TIFFPredictorInit_cold_1();
  v10 = 1;
  if (_TIFFMergeFields(a1, predictFields, 1, a4, a5, a6, a7, a8))
  {
    v16 = *(int8x16_t *)(a1 + 1280);
    *(_QWORD *)(a1 + 1288) = PredictorVGetField;
    *(int8x16_t *)(v8 + 88) = vextq_s8(v16, v16, 8uLL);
    *(_QWORD *)(a1 + 1280) = PredictorVSetField;
    v17 = *(_QWORD *)(a1 + 1296);
    *(_QWORD *)(a1 + 1296) = PredictorPrintDir;
    v18 = *(_QWORD *)(a1 + 960);
    *(_QWORD *)(v8 + 104) = v17;
    *(_QWORD *)(v8 + 112) = v18;
    *(_QWORD *)(a1 + 960) = PredictorSetupDecode;
    *(_QWORD *)(v8 + 120) = *(_QWORD *)(a1 + 976);
    *(_QWORD *)(a1 + 976) = PredictorSetupEncode;
    *(_DWORD *)v8 = 1;
    *(_QWORD *)(v8 + 48) = 0;
    *(_QWORD *)(v8 + 80) = 0;
  }
  else
  {
    TIFFErrorExtR(a1, "TIFFPredictorInit", "Merging Predictor codec-specific tags failed", v11, v12, v13, v14, v15, v20);
    return 0;
  }
  return v10;
}

uint64_t PredictorVGetField(uint64_t a1, int a2, _WORD **a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 1096);
  if (!v3 || !*(_QWORD *)(v3 + 96))
    return 0;
  if (a2 != 317)
    return (*(uint64_t (**)(void))(v3 + 88))();
  **a3 = *(_DWORD *)v3;
  return 1;
}

uint64_t PredictorVSetField(uint64_t a1, int a2, unsigned __int16 *a3)
{
  uint64_t v3;
  uint64_t (*v4)(void);

  v3 = *(_QWORD *)(a1 + 1096);
  if (!v3)
    return 0;
  v4 = *(uint64_t (**)(void))(v3 + 96);
  if (!v4)
    return 0;
  if (a2 != 317)
    return v4();
  *(_DWORD *)v3 = *a3;
  *(_DWORD *)(a1 + 80) |= 4u;
  *(_DWORD *)(a1 + 16) |= 8u;
  return 1;
}

uint64_t PredictorPrintDir(uint64_t result, FILE *__stream, uint64_t a3)
{
  uint64_t v5;
  _DWORD *v6;
  int v7;
  const char *v8;
  size_t v9;
  uint64_t (*v10)(uint64_t, FILE *, uint64_t);

  v5 = result;
  v6 = *(_DWORD **)(result + 1096);
  if ((*(_BYTE *)(result + 80) & 4) == 0)
    goto LABEL_10;
  fwrite("  Predictor: ", 0xDuLL, 1uLL, __stream);
  v7 = *v6;
  if (*v6 == 3)
  {
    v8 = "floating point predictor ";
    v9 = 25;
    goto LABEL_8;
  }
  if (v7 == 2)
  {
    v8 = "horizontal differencing ";
    v9 = 24;
    goto LABEL_8;
  }
  if (v7 == 1)
  {
    v8 = "none ";
    v9 = 5;
LABEL_8:
    fwrite(v8, v9, 1uLL, __stream);
  }
  result = fprintf(__stream, "%d (0x%x)\n", *v6, *v6);
LABEL_10:
  v10 = (uint64_t (*)(uint64_t, FILE *, uint64_t))*((_QWORD *)v6 + 13);
  if (v10)
    return v10(v5, __stream, a3);
  return result;
}

uint64_t PredictorSetupDecode(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unint64_t v12;
  uint64_t (*v13)(uint64_t, uint64_t, uint64_t);
  uint64_t v14;
  uint64_t (*v15)(uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  void *v16;
  uint64_t (*v17)(uint64_t, uint64_t, uint64_t);
  uint64_t v18;

  v2 = *(_QWORD *)(a1 + 1096);
  result = (*(uint64_t (**)(void))(v2 + 112))();
  if ((_DWORD)result)
  {
    result = PredictorSetup(a1, v4, v5, v6, v7, v8, v9, v10);
    if ((_DWORD)result)
    {
      if (*(_DWORD *)v2 == 3)
      {
        *(_QWORD *)(v2 + 80) = fpAcc;
        v17 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 1008);
        if (v17 != PredictorDecodeRow)
        {
          *(_QWORD *)(a1 + 1008) = PredictorDecodeRow;
          v18 = *(_QWORD *)(a1 + 1024);
          *(_QWORD *)(v2 + 56) = v17;
          *(_QWORD *)(v2 + 64) = v18;
          *(_QWORD *)(a1 + 1024) = PredictorDecodeTile;
          *(_QWORD *)(v2 + 72) = *(_QWORD *)(a1 + 1040);
          *(_QWORD *)(a1 + 1040) = PredictorDecodeTile;
        }
        if ((*(_BYTE *)(a1 + 16) & 0x80) == 0)
          return 1;
      }
      else
      {
        if (*(_DWORD *)v2 != 2)
          return 1;
        HIDWORD(v12) = *(unsigned __int16 *)(a1 + 116);
        LODWORD(v12) = HIDWORD(v12) - 8;
        v11 = v12 >> 3;
        if (v11 <= 7 && ((0x8Bu >> v11) & 1) != 0)
          *(_QWORD *)(v2 + 80) = off_1E1BC4640[v11];
        v13 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 1008);
        if (v13 != PredictorDecodeRow)
        {
          *(_QWORD *)(a1 + 1008) = PredictorDecodeRow;
          v14 = *(_QWORD *)(a1 + 1024);
          *(_QWORD *)(v2 + 56) = v13;
          *(_QWORD *)(v2 + 64) = v14;
          *(_QWORD *)(a1 + 1024) = PredictorDecodeTile;
          *(_QWORD *)(v2 + 72) = *(_QWORD *)(a1 + 1040);
          *(_QWORD *)(a1 + 1040) = PredictorDecodeTile;
        }
        if ((*(_BYTE *)(a1 + 16) & 0x80) == 0)
          return 1;
        v15 = *(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v2 + 80);
        if ((char *)v15 == (char *)horAcc16)
        {
          v16 = swabHorAcc16;
        }
        else if ((char *)v15 == (char *)horAcc32)
        {
          v16 = swabHorAcc32;
        }
        else
        {
          if (v15 != horAcc64)
            return 1;
          v16 = swabHorAcc64;
        }
        *(_QWORD *)(v2 + 80) = v16;
      }
      *(_QWORD *)(a1 + 1248) = _TIFFNoPostDecode;
      return 1;
    }
  }
  return result;
}

uint64_t PredictorSetupEncode(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unint64_t v12;
  uint64_t (*v13)(uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v14;
  uint64_t (*v15)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  void *v16;
  uint64_t (*v17)(uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v18;

  v2 = *(_QWORD *)(a1 + 1096);
  result = (*(uint64_t (**)(void))(v2 + 120))();
  if ((_DWORD)result)
  {
    result = PredictorSetup(a1, v4, v5, v6, v7, v8, v9, v10);
    if ((_DWORD)result)
    {
      if (*(_DWORD *)v2 == 3)
      {
        *(_QWORD *)(v2 + 48) = fpDiff;
        v17 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 1016);
        if (v17 != PredictorEncodeRow)
        {
          *(_QWORD *)(a1 + 1016) = PredictorEncodeRow;
          v18 = *(_QWORD *)(a1 + 1032);
          *(_QWORD *)(v2 + 24) = v17;
          *(_QWORD *)(v2 + 32) = v18;
          *(_QWORD *)(a1 + 1032) = PredictorEncodeTile;
          *(_QWORD *)(v2 + 40) = *(_QWORD *)(a1 + 1048);
          *(_QWORD *)(a1 + 1048) = PredictorEncodeTile;
        }
        return 1;
      }
      if (*(_DWORD *)v2 == 2)
      {
        HIDWORD(v12) = *(unsigned __int16 *)(a1 + 116);
        LODWORD(v12) = HIDWORD(v12) - 8;
        v11 = v12 >> 3;
        if (v11 <= 7 && ((0x8Bu >> v11) & 1) != 0)
          *(_QWORD *)(v2 + 48) = off_1E1BC4680[v11];
        v13 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 1016);
        if (v13 != PredictorEncodeRow)
        {
          *(_QWORD *)(a1 + 1016) = PredictorEncodeRow;
          v14 = *(_QWORD *)(a1 + 1032);
          *(_QWORD *)(v2 + 24) = v13;
          *(_QWORD *)(v2 + 32) = v14;
          *(_QWORD *)(a1 + 1032) = PredictorEncodeTile;
          *(_QWORD *)(v2 + 40) = *(_QWORD *)(a1 + 1048);
          *(_QWORD *)(a1 + 1048) = PredictorEncodeTile;
        }
        if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
        {
          v15 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v2 + 48);
          if (v15 == horDiff16)
          {
            v16 = swabHorDiff16;
            goto LABEL_19;
          }
          if (v15 == horDiff32)
          {
            v16 = swabHorDiff32;
            goto LABEL_19;
          }
          if (v15 == horDiff64)
          {
            v16 = swabHorDiff64;
LABEL_19:
            *(_QWORD *)(v2 + 48) = v16;
            *(_QWORD *)(a1 + 1248) = _TIFFNoPostDecode;
          }
        }
      }
      return 1;
    }
  }
  return result;
}

uint64_t TIFFPredictorCleanup(_QWORD *a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  v1 = (_QWORD *)a1[137];
  if (!v1)
    TIFFPredictorCleanup_cold_1();
  v2 = v1[12];
  a1[161] = v1[11];
  a1[160] = v2;
  v3 = v1[14];
  a1[162] = v1[13];
  a1[120] = v3;
  a1[122] = v1[15];
  return 1;
}

BOOL PredictorSetup(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v8;
  uint64_t v9;
  unint64_t v10;
  int v11;
  unint64_t v13;
  int v14;
  uint64_t v16;
  uint64_t v17;

  v8 = *(unsigned int **)(a1 + 1096);
  v9 = *v8;
  if ((_DWORD)v9 == 1)
    return v9;
  if ((_DWORD)v9 == 3)
  {
    if (*(_WORD *)(a1 + 118) == 3)
    {
      HIDWORD(v13) = *(unsigned __int16 *)(a1 + 116);
      LODWORD(v13) = (HIDWORD(v13) << 16) - 0x100000;
      v14 = (1 << (v13 >> 19)) & 0x47;
      if ((unsigned __int16)(v13 >> 19) <= 6u && v14 != 0)
        goto LABEL_15;
      TIFFErrorExtR(a1, "PredictorSetup", "Floating point \"Predictor\" not supported with %hu-bit samples", a4, a5, a6, a7, a8, *(_WORD *)(a1 + 116));
    }
    else
    {
      TIFFErrorExtR(a1, "PredictorSetup", "Floating point \"Predictor\" not supported with %hu data format", a4, a5, a6, a7, a8, *(_WORD *)(a1 + 118));
    }
    return 0;
  }
  if ((_DWORD)v9 != 2)
  {
    TIFFErrorExtR(a1, "PredictorSetup", "\"Predictor\" value %d not supported", a4, a5, a6, a7, a8, *v8);
    return 0;
  }
  HIDWORD(v10) = *(unsigned __int16 *)(a1 + 116);
  LODWORD(v10) = (HIDWORD(v10) << 16) - 0x80000;
  v11 = (1 << (v10 >> 19)) & 0x8B;
  if ((unsigned __int16)(v10 >> 19) > 7u || v11 == 0)
  {
    TIFFErrorExtR(a1, "PredictorSetup", "Horizontal differencing \"Predictor\" not supported with %hu-bit samples", a4, a5, a6, a7, a8, *(_WORD *)(a1 + 116));
    return 0;
  }
LABEL_15:
  if (*(_WORD *)(a1 + 170) == 1)
    v16 = *(unsigned __int16 *)(a1 + 130);
  else
    v16 = 1;
  *((_QWORD *)v8 + 1) = v16;
  if ((*(_BYTE *)(a1 + 17) & 4) != 0)
    v17 = _cg_TIFFTileRowSize(a1, a2, a3, a4, a5, a6, a7, a8);
  else
    v17 = _cg_TIFFScanlineSize(a1, a2, a3, a4, a5, a6, a7, a8);
  *((_QWORD *)v8 + 2) = v17;
  return v17 != 0;
}

uint64_t horAcc8(uint64_t a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8x8_t a9, uint8x8_t a10)
{
  uint64_t v10;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  unsigned __int8 *v17;
  uint64_t v18;
  unint64_t v19;
  unsigned __int8 *v20;
  unsigned __int8 v21;
  BOOL v22;
  int32x4_t v23;
  uint64_t v24;
  int16x8_t v25;

  v10 = *(_QWORD *)(*(_QWORD *)(a1 + 1096) + 8);
  if (a3 % v10)
  {
    TIFFErrorExtR(a1, "horAcc8", "%s", a4, a5, a6, a7, a8, (char)"(cc%stride)!=0");
    return 0;
  }
  v12 = a3 - v10;
  if (a3 <= v10)
    return 1;
  if (v10 != 4)
  {
    if (v10 == 3)
    {
      if (a3 >= 4)
      {
        v13 = 0;
        v14 = a2[2];
        v15 = a2[1];
        v16 = *a2;
        do
        {
          v17 = &a2[v13];
          v16 += a2[v13 + 3];
          v17[3] = v16;
          v15 += a2[v13 + 4];
          v17[4] = v15;
          v14 += a2[v13 + 5];
          v17[5] = v14;
          v18 = v13 + 6;
          v13 += 3;
        }
        while (v18 < a3);
      }
    }
    else
    {
      do
      {
        if (v10)
        {
          if (v10 != 1)
          {
            if (v10 != 2)
            {
              if (v10 >= 5)
              {
                v19 = v10 - 3;
                do
                {
                  a2[v10] += *a2;
                  ++a2;
                  --v19;
                }
                while (v19 > 1);
              }
              a2[v10] += *a2;
              v21 = a2[1];
              v20 = a2 + 1;
              v20[v10] += v21;
              a2 = v20 + 1;
            }
            a2[v10] += *a2;
            ++a2;
          }
          a2[v10] += *a2;
          ++a2;
        }
        v22 = v12 <= v10;
        v12 -= v10;
      }
      while (!v22);
    }
    return 1;
  }
  if (a3 < 5)
    return 1;
  a9.i32[0] = *(_DWORD *)a2;
  v23 = (int32x4_t)vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(a9));
  v24 = 4;
  result = 1;
  do
  {
    a10.i32[0] = *(_DWORD *)&a2[v24];
    v25 = (int16x8_t)vmovl_u8(a10);
    v23 = (int32x4_t)vaddw_u16((uint32x4_t)v23, *(uint16x4_t *)v25.i8);
    *(int16x4_t *)v25.i8 = vmovn_s32(v23);
    a10 = (uint8x8_t)vmovn_s16(v25);
    *(_DWORD *)&a2[v24] = a10.i32[0];
    v24 += 4;
  }
  while (v24 < a3);
  return result;
}

uint64_t horAcc16(uint64_t a1, _WORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  unint64_t v14;

  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 1096) + 8);
  if (a3 >= 0)
    v9 = a3;
  else
    v9 = a3 + 1;
  if (a3 % (2 * v8))
  {
    TIFFErrorExtR(a1, "horAcc16", "%s", a4, a5, a6, a7, a8, (char)"cc%(2*stride))!=0");
    return 0;
  }
  else
  {
    v11 = v9 >> 1;
    v12 = v11 <= v8;
    v13 = v11 - v8;
    if (!v12)
    {
      while (2)
      {
        switch(v8)
        {
          case 0:
            goto LABEL_15;
          case 1:
            goto LABEL_14;
          case 2:
            goto LABEL_13;
          case 3:
            goto LABEL_12;
          case 4:
            goto LABEL_11;
          default:
            if (v8 >= 5)
            {
              v14 = v8 - 3;
              do
              {
                a2[v8] += *a2;
                ++a2;
                --v14;
              }
              while (v14 > 1);
            }
LABEL_11:
            a2[v8] += *a2;
            ++a2;
LABEL_12:
            a2[v8] += *a2;
            ++a2;
LABEL_13:
            a2[v8] += *a2;
            ++a2;
LABEL_14:
            a2[v8] += *a2;
            ++a2;
LABEL_15:
            v12 = v13 <= v8;
            v13 -= v8;
            if (!v12)
              continue;
            return 1;
        }
      }
    }
    return 1;
  }
}

uint64_t horAcc32(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  unint64_t v14;

  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 1096) + 8);
  v9 = a3 + 3;
  if (a3 >= 0)
    v9 = a3;
  if (a3 % (4 * v8))
  {
    TIFFErrorExtR(a1, "horAcc32", "%s", a4, a5, a6, a7, a8, (char)"cc%(4*stride))!=0");
    return 0;
  }
  else
  {
    v11 = v9 >> 2;
    v12 = v11 <= v8;
    v13 = v11 - v8;
    if (!v12)
    {
      while (2)
      {
        switch(v8)
        {
          case 0:
            goto LABEL_14;
          case 1:
            goto LABEL_13;
          case 2:
            goto LABEL_12;
          case 3:
            goto LABEL_11;
          case 4:
            goto LABEL_10;
          default:
            if (v8 >= 5)
            {
              v14 = v8 - 3;
              do
              {
                a2[v8] += *a2;
                ++a2;
                --v14;
              }
              while (v14 > 1);
            }
LABEL_10:
            a2[v8] += *a2;
            ++a2;
LABEL_11:
            a2[v8] += *a2;
            ++a2;
LABEL_12:
            a2[v8] += *a2;
            ++a2;
LABEL_13:
            a2[v8] += *a2;
            ++a2;
LABEL_14:
            v12 = v13 <= v8;
            v13 -= v8;
            if (!v12)
              continue;
            return 1;
        }
      }
    }
    return 1;
  }
}

uint64_t horAcc64(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  unint64_t v14;

  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 1096) + 8);
  v9 = a3 + 7;
  if (a3 >= 0)
    v9 = a3;
  if (a3 % (8 * v8))
  {
    TIFFErrorExtR(a1, "horAcc64", "%s", a4, a5, a6, a7, a8, (char)"cc%(8*stride))!=0");
    return 0;
  }
  else
  {
    v11 = v9 >> 3;
    v12 = v11 <= v8;
    v13 = v11 - v8;
    if (!v12)
    {
      while (2)
      {
        switch(v8)
        {
          case 0:
            goto LABEL_14;
          case 1:
            goto LABEL_13;
          case 2:
            goto LABEL_12;
          case 3:
            goto LABEL_11;
          case 4:
            goto LABEL_10;
          default:
            if (v8 >= 5)
            {
              v14 = v8 - 3;
              do
              {
                a2[v8] += *a2;
                ++a2;
                --v14;
              }
              while (v14 > 1);
            }
LABEL_10:
            a2[v8] += *a2;
            ++a2;
LABEL_11:
            a2[v8] += *a2;
            ++a2;
LABEL_12:
            a2[v8] += *a2;
            ++a2;
LABEL_13:
            a2[v8] += *a2;
            ++a2;
LABEL_14:
            v12 = v13 <= v8;
            v13 -= v8;
            if (!v12)
              continue;
            return 1;
        }
      }
    }
    return 1;
  }
}

uint64_t PredictorDecodeRow(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t (*v4)(void);
  uint64_t result;

  v3 = *(_QWORD *)(a1 + 1096);
  if (!v3)
    PredictorDecodeRow_cold_1();
  v4 = *(uint64_t (**)(void))(v3 + 56);
  if (!v4)
    PredictorDecodeRow_cold_2();
  if (!*(_QWORD *)(v3 + 80))
    PredictorDecodeRow_cold_3();
  result = v4();
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v3 + 80))(a1, a2, a3);
  return result;
}

uint64_t PredictorDecodeTile(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v3;
  uint64_t (*v4)(void);
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v3 = *(_QWORD **)(a1 + 1096);
  if (!v3)
    PredictorDecodeTile_cold_1();
  v4 = (uint64_t (*)(void))v3[9];
  if (!v4)
    PredictorDecodeTile_cold_2();
  result = v4();
  if ((_DWORD)result)
  {
    v14 = v3[2];
    if (v14 <= 0)
      PredictorDecodeTile_cold_3();
    if (a3 % v14)
    {
      TIFFErrorExtR(a1, "PredictorDecodeTile", "%s", v9, v10, v11, v12, v13, (char)"occ0%rowsize != 0");
      return 0;
    }
    else
    {
      if (!v3[10])
        PredictorDecodeTile_cold_4();
      if (a3 < 1)
      {
        return 1;
      }
      else
      {
        while (1)
        {
          result = ((uint64_t (*)(uint64_t, uint64_t, uint64_t))v3[10])(a1, a2, v14);
          if (!(_DWORD)result)
            break;
          a3 -= v14;
          a2 += v14;
          if (a3 <= 0)
            return 1;
        }
      }
    }
  }
  return result;
}

uint64_t swabHorAcc16(uint64_t a1, _WORD *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (a3 >= 0)
    v6 = a3;
  else
    v6 = a3 + 1;
  TIFFSwabArrayOfShort((uint64_t)a2, v6 >> 1);
  return horAcc16(a1, a2, a3, v7, v8, v9, v10, v11);
}

uint64_t swabHorAcc32(uint64_t a1, __int32 *a2, uint64_t a3, uint8x8_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  TIFFSwabArrayOfLong(a2, a3 / 4, a4);
  return horAcc32(a1, a2, a3, v7, v8, v9, v10, v11);
}

uint64_t swabHorAcc64(uint64_t a1, int8x8_t *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  TIFFSwabArrayOfLong8(a2, a3 / 8);
  return horAcc64(a1, a2, a3, v6, v7, v8, v9, v10);
}

uint64_t fpAcc(uint64_t a1, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t result;
  char *v15;
  uint64_t v16;
  _BYTE *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _BYTE *v23;
  unsigned int v24;

  v8 = *(unsigned __int16 *)(a1 + 116);
  if (v8 < 8)
    return 0;
  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 1096) + 8);
  v12 = v8 >> 3;
  if (a3 % (uint64_t)(v11 * (v8 >> 3)))
  {
    TIFFErrorExtR(a1, "fpAcc", "%s", a4, a5, a6, a7, a8, (char)"cc%(bps*stride))!=0");
    return 0;
  }
  result = (uint64_t)_TIFFmallocExt((_QWORD *)a1, a3, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    v15 = (char *)result;
    v16 = a3 / v12;
    if (v11 < a3)
    {
      v17 = a2;
      v18 = a3;
      while (2)
      {
        switch(v11)
        {
          case 0:
            goto LABEL_17;
          case 1:
            goto LABEL_16;
          case 2:
            goto LABEL_15;
          case 3:
            goto LABEL_14;
          case 4:
            goto LABEL_13;
          default:
            if (v11 >= 5)
            {
              v19 = v11 - 3;
              do
              {
                v17[v11] += *v17;
                ++v17;
                --v19;
              }
              while (v19 > 1);
            }
LABEL_13:
            v17[v11] += *v17;
            ++v17;
LABEL_14:
            v17[v11] += *v17;
            ++v17;
LABEL_15:
            v17[v11] += *v17;
            ++v17;
LABEL_16:
            v17[v11] += *v17;
            ++v17;
LABEL_17:
            v18 -= v11;
            if (v18 <= v11)
              break;
            continue;
        }
        break;
      }
    }
    _TIFFmemcpy((void *)result, a2, a3);
    if (v16 >= 1)
    {
      v20 = 0;
      if (v12 <= 1)
        v21 = 1;
      else
        v21 = v12;
      do
      {
        v22 = v21;
        v23 = a2;
        v24 = v12 - 1;
        do
        {
          *v23++ = v15[v20 + v16 * v24--];
          --v22;
        }
        while (v22);
        ++v20;
        a2 += v12;
      }
      while (v20 != v16);
    }
    _TIFFfreeExt(a1, v15);
    return 1;
  }
  return result;
}

uint64_t horDiff8(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8x8_t a9, uint8x8_t a10)
{
  uint64_t v10;
  uint64_t v12;
  char v13;
  char v14;
  uint64_t v15;
  char *v16;
  char v17;
  char v18;
  char v19;
  char v20;
  __int32 *v21;
  __int32 v22;
  int16x8_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  char *v27;
  char v28;
  BOOL v29;

  v10 = *(_QWORD *)(*(_QWORD *)(a1 + 1096) + 8);
  if (a3 % v10)
  {
    TIFFErrorExtR(a1, "horDiff8", "%s", a4, a5, a6, a7, a8, (char)"(cc%stride)!=0");
    return 0;
  }
  else
  {
    v12 = a3 - v10;
    if (a3 > v10)
    {
      if (v10 == 4)
      {
        v22 = *(_DWORD *)a2;
        v21 = (__int32 *)(a2 + 4);
        a9.i32[0] = v22;
        v23 = (int16x8_t)vmovl_u8(a9);
        v24 = v12 + 4;
        do
        {
          a10.i32[0] = *v21;
          a10 = (uint8x8_t)vmovl_u8(a10).u64[0];
          *(int16x4_t *)v23.i8 = vsub_s16((int16x4_t)a10, *(int16x4_t *)v23.i8);
          *v21++ = vmovn_s16(v23).u32[0];
          v24 -= 4;
          *(uint8x8_t *)v23.i8 = a10;
        }
        while (v24 > 4);
      }
      else if (v10 == 3)
      {
        v13 = *a2;
        v14 = a2[1];
        v15 = v12 + 3;
        v16 = a2 + 5;
        v17 = a2[2];
        do
        {
          v18 = *(v16 - 2);
          *(v16 - 2) = v18 - v13;
          v19 = *(v16 - 1);
          *(v16 - 1) = v19 - v14;
          v20 = *v16;
          v15 -= 3;
          *v16 -= v17;
          v16 += 3;
          v13 = v18;
          v14 = v19;
          v17 = v20;
        }
        while (v15 > 3);
      }
      else
      {
        v25 = &a2[v12 - 1];
        do
        {
          if (v10)
          {
            if (v10 != 1)
            {
              if (v10 != 2)
              {
                if (v10 >= 5)
                {
                  v26 = 0;
                  do
                  {
                    v25[v10 + v26] -= v25[v26];
                    --v26;
                  }
                  while ((unint64_t)(v10 + v26 - 3) > 1);
                  v25 += v26;
                }
                v25[v10] -= *v25;
                v28 = *(v25 - 1);
                v27 = v25 - 1;
                v27[v10] -= v28;
                v25 = v27 - 1;
              }
              v25[v10] -= *v25;
              --v25;
            }
            v25[v10] -= *v25;
            --v25;
          }
          v29 = v12 <= v10;
          v12 -= v10;
        }
        while (!v29);
      }
    }
    return 1;
  }
}

uint64_t horDiff16(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  _WORD *v14;
  unint64_t v15;

  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 1096) + 8);
  if (a3 >= 0)
    v9 = a3;
  else
    v9 = a3 + 1;
  if (a3 % (2 * v8))
  {
    TIFFErrorExtR(a1, "horDiff8", "%s", a4, a5, a6, a7, a8, (char)"(cc%(2*stride))!=0");
    return 0;
  }
  else
  {
    v11 = v9 >> 1;
    v12 = v11 <= v8;
    v13 = v11 - v8;
    if (!v12)
    {
      v14 = (_WORD *)(a2 + 2 * v13 - 2);
      while (2)
      {
        switch(v8)
        {
          case 0:
            goto LABEL_16;
          case 1:
            goto LABEL_15;
          case 2:
            goto LABEL_14;
          case 3:
            goto LABEL_13;
          case 4:
            goto LABEL_12;
          default:
            if (v8 >= 5)
            {
              v15 = v8 - 3;
              do
              {
                v14[v8] -= *v14;
                --v14;
                --v15;
              }
              while (v15 > 1);
            }
LABEL_12:
            v14[v8] -= *v14;
            --v14;
LABEL_13:
            v14[v8] -= *v14;
            --v14;
LABEL_14:
            v14[v8] -= *v14;
            --v14;
LABEL_15:
            v14[v8] -= *v14;
            --v14;
LABEL_16:
            v12 = v13 <= v8;
            v13 -= v8;
            if (!v12)
              continue;
            return 1;
        }
      }
    }
    return 1;
  }
}

uint64_t horDiff32(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  _DWORD *v14;
  unint64_t v15;

  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 1096) + 8);
  v9 = a3 + 3;
  if (a3 >= 0)
    v9 = a3;
  if (a3 % (4 * v8))
  {
    TIFFErrorExtR(a1, "horDiff32", "%s", a4, a5, a6, a7, a8, (char)"(cc%(4*stride))!=0");
    return 0;
  }
  else
  {
    v11 = v9 >> 2;
    v12 = v11 <= v8;
    v13 = v11 - v8;
    if (!v12)
    {
      v14 = (_DWORD *)(a2 + 4 * v13 - 4);
      while (2)
      {
        switch(v8)
        {
          case 0:
            goto LABEL_15;
          case 1:
            goto LABEL_14;
          case 2:
            goto LABEL_13;
          case 3:
            goto LABEL_12;
          case 4:
            goto LABEL_11;
          default:
            if (v8 >= 5)
            {
              v15 = v8 - 3;
              do
              {
                v14[v8] -= *v14;
                --v14;
                --v15;
              }
              while (v15 > 1);
            }
LABEL_11:
            v14[v8] -= *v14;
            --v14;
LABEL_12:
            v14[v8] -= *v14;
            --v14;
LABEL_13:
            v14[v8] -= *v14;
            --v14;
LABEL_14:
            v14[v8] -= *v14;
            --v14;
LABEL_15:
            v12 = v13 <= v8;
            v13 -= v8;
            if (!v12)
              continue;
            return 1;
        }
      }
    }
    return 1;
  }
}

uint64_t horDiff64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  _QWORD *v14;
  unint64_t v15;

  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 1096) + 8);
  v9 = a3 + 7;
  if (a3 >= 0)
    v9 = a3;
  if (a3 % (8 * v8))
  {
    TIFFErrorExtR(a1, "horDiff64", "%s", a4, a5, a6, a7, a8, (char)"(cc%(8*stride))!=0");
    return 0;
  }
  else
  {
    v11 = v9 >> 3;
    v12 = v11 <= v8;
    v13 = v11 - v8;
    if (!v12)
    {
      v14 = (_QWORD *)(a2 + 8 * v13 - 8);
      while (2)
      {
        switch(v8)
        {
          case 0:
            goto LABEL_15;
          case 1:
            goto LABEL_14;
          case 2:
            goto LABEL_13;
          case 3:
            goto LABEL_12;
          case 4:
            goto LABEL_11;
          default:
            if (v8 >= 5)
            {
              v15 = v8 - 3;
              do
              {
                v14[v8] -= *v14;
                --v14;
                --v15;
              }
              while (v15 > 1);
            }
LABEL_11:
            v14[v8] -= *v14;
            --v14;
LABEL_12:
            v14[v8] -= *v14;
            --v14;
LABEL_13:
            v14[v8] -= *v14;
            --v14;
LABEL_14:
            v14[v8] -= *v14;
            --v14;
LABEL_15:
            v12 = v13 <= v8;
            v13 -= v8;
            if (!v12)
              continue;
            return 1;
        }
      }
    }
    return 1;
  }
}

uint64_t PredictorEncodeRow(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t (*v5)(void);
  uint64_t result;

  v4 = *(_QWORD *)(a1 + 1096);
  if (!v4)
    PredictorEncodeRow_cold_1();
  v5 = *(uint64_t (**)(void))(v4 + 48);
  if (!v5)
    PredictorEncodeRow_cold_2();
  if (!*(_QWORD *)(v4 + 24))
    PredictorEncodeRow_cold_3();
  result = v5();
  if ((_DWORD)result)
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v4 + 24))(a1, a2, a3, a4);
  return result;
}

uint64_t PredictorEncodeTile(_QWORD *a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v8;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v27;
  uint64_t v28;
  uint64_t v29;

  v8 = (_QWORD *)a1[137];
  if (!v8)
    PredictorEncodeTile_cold_1();
  if (!v8[6])
    PredictorEncodeTile_cold_2();
  if (!v8[5])
    PredictorEncodeTile_cold_3();
  v13 = (char *)_TIFFmallocExt(a1, a3, a3, a4, a5, a6, a7, a8);
  if (!v13)
  {
    TIFFErrorExtR((uint64_t)a1, "PredictorEncodeTile", "Out of memory allocating %lld byte temp buffer.", v14, v15, v16, v17, v18, a3);
    return 0;
  }
  v19 = v13;
  memcpy(v13, a2, a3);
  v25 = v8[2];
  if (v25 <= 0)
    PredictorEncodeTile_cold_4();
  if (a3 % v25)
  {
    TIFFErrorExtR((uint64_t)a1, "PredictorEncodeTile", "%s", v20, v21, v22, v23, v24, (char)"(cc0%rowsize)!=0");
    _TIFFfreeExt((uint64_t)a1, v19);
    return 0;
  }
  if (a3 >= 1)
  {
    v27 = v19;
    v28 = a3;
    do
    {
      ((void (*)(_QWORD *, char *, uint64_t))v8[6])(a1, v27, v25);
      v28 -= v25;
      v27 += v25;
    }
    while (v28 > 0);
  }
  v29 = ((uint64_t (*)(_QWORD *, char *, uint64_t, uint64_t))v8[5])(a1, v19, a3, a4);
  _TIFFfreeExt((uint64_t)a1, v19);
  return v29;
}

uint64_t swabHorDiff16(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v11;

  result = horDiff16(a1, a2, a3, a4, a5, a6, a7, a8);
  if ((_DWORD)result)
  {
    if (a3 >= 0)
      v11 = a3;
    else
      v11 = a3 + 1;
    TIFFSwabArrayOfShort(a2, v11 >> 1);
    return 1;
  }
  return result;
}

uint64_t swabHorDiff32(uint64_t a1, __int32 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint8x8_t v11;

  result = horDiff32(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if ((_DWORD)result)
  {
    TIFFSwabArrayOfLong(a2, a3 / 4, v11);
    return 1;
  }
  return result;
}

uint64_t swabHorDiff64(uint64_t a1, int8x8_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;

  result = horDiff64(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if ((_DWORD)result)
  {
    TIFFSwabArrayOfLong8(a2, a3 / 8);
    return 1;
  }
  return result;
}

uint64_t fpDiff(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t result;
  int64_t v13;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;
  unsigned int v22;
  char v23;
  char *v24;
  uint64_t v25;

  v9 = *(_QWORD *)(*(_QWORD *)(a1 + 1096) + 8);
  v10 = *(unsigned __int16 *)(a1 + 116);
  v11 = v10 >> 3;
  if (a3 % (uint64_t)(v9 * (v10 >> 3)))
  {
    TIFFErrorExtR(a1, "fpDiff", "%s", a4, a5, a6, a7, a8, (char)"(cc%(bps*stride))!=0");
    return 0;
  }
  else
  {
    v13 = a3;
    result = (uint64_t)_TIFFmallocExt((_QWORD *)a1, a3, a3, a4, a5, a6, a7, a8);
    if (result)
    {
      v15 = (char *)result;
      v16 = v13 / v11;
      _TIFFmemcpy((void *)result, a2, v13);
      if (v13 / v11 >= 1)
      {
        v17 = 0;
        if (v11 <= 1)
          v18 = 1;
        else
          v18 = v11;
        v19 = v15;
        do
        {
          if (v10 >= 8)
          {
            v20 = v18;
            v21 = v19;
            v22 = v11 - 1;
            do
            {
              v23 = *v21++;
              a2[v17 + v16 * v22--] = v23;
              --v20;
            }
            while (v20);
          }
          ++v17;
          v19 += v11;
        }
        while (v17 != v16);
      }
      _TIFFfreeExt(a1, v15);
      if (v9 < v13)
      {
        v24 = &a2[v13 + ~v9];
        while (2)
        {
          switch(v9)
          {
            case 0:
              goto LABEL_24;
            case 1:
              goto LABEL_23;
            case 2:
              goto LABEL_22;
            case 3:
              goto LABEL_21;
            case 4:
              goto LABEL_20;
            default:
              if (v9 >= 5)
              {
                v25 = 0;
                do
                {
                  v24[v9 + v25] -= v24[v25];
                  --v25;
                }
                while ((unint64_t)(v9 + v25 - 3) > 1);
                v24 += v25;
              }
LABEL_20:
              v24[v9] -= *v24;
              --v24;
LABEL_21:
              v24[v9] -= *v24;
              --v24;
LABEL_22:
              v24[v9] -= *v24;
              --v24;
LABEL_23:
              v24[v9] -= *v24;
              --v24;
LABEL_24:
              v13 -= v9;
              if (v13 <= v9)
                return 1;
              continue;
          }
        }
      }
      return 1;
    }
  }
  return result;
}

uint64_t IIO_Reader_RAD::createReadPlugin(IIO_Reader *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;

  v4 = operator new();
  v5 = IIO_Reader::osType(a1);
  RADReadPlugin::RADReadPlugin(v4, a2, v5);
  return v4;
}

void sub_187FBB108(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40221BAC5BLL);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_RAD::createReadPlugin(IIO_Reader *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8;
  int v9;

  v8 = operator new();
  v9 = IIO_Reader::osType(a1);
  RADReadPlugin::RADReadPlugin(v8, a2, a3, a4, v9);
  return v8;
}

void sub_187FBB1A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40221BAC5BLL);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_RAD::compareOptions(IIO_Reader_RAD *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  _BOOL4 BoolForKey;
  uint64_t v5;
  _QWORD v7[3];
  _QWORD v8[3];

  memset(v8, 0, sizeof(v8));
  IIODictionary::IIODictionary((IIODictionary *)v8, a2);
  memset(v7, 0, sizeof(v7));
  IIODictionary::IIODictionary((IIODictionary *)v7, a3);
  BoolForKey = IIODictionary::getBoolForKey((IIODictionary *)v8, CFSTR("kCGImageSourceShouldAllowFloat"));
  v5 = BoolForKey ^ IIODictionary::getBoolForKey((IIODictionary *)v7, CFSTR("kCGImageSourceShouldAllowFloat")) ^ 1u;
  IIODictionary::~IIODictionary((IIODictionary *)v7);
  IIODictionary::~IIODictionary((IIODictionary *)v8);
  return v5;
}

void sub_187FBB254(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

BOOL _cg_TIFFWriteDirectory(uint64_t a1)
{
  return TIFFWriteDirectorySec(a1, 1, 1u, 0);
}

BOOL TIFFWriteDirectorySec(uint64_t a1, int a2, unsigned int a3, _QWORD *a4)
{
  char *v8;
  uint64_t v9;
  uint64_t v10;
  int8x8_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint8x8_t v14;
  int v15;
  uint64_t v16;
  int v17;
  char *v18;
  _DWORD *v19;
  unsigned __int16 *v20;
  unint64_t v21;
  int v22;
  uint8x8_t v23;
  uint8x8_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unsigned __int16 *v36;
  uint64_t v37;
  int v38;
  _DWORD *v39;
  __int16 v40;
  unint64_t v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  char *v48;
  int v49;
  unint64_t v50;
  int v51;
  unint64_t v52;
  __int16 v53;
  uint64_t v54;
  int v55;
  BOOL v56;
  _DWORD *v57;
  int v58;
  unint64_t v59;
  char *v60;
  char *v61;
  int v62;
  unint64_t v63;
  int v64;
  uint64_t v65;
  __int32 *v66;
  uint8x8_t v67;
  char *v68;
  uint64_t v69;
  unsigned int v70;
  uint64_t *v71;
  __int32 *v72;
  uint64_t v73;
  int v74;
  int v75;
  uint64_t v76;
  uint64_t v77;
  unsigned int v78;
  unsigned int *v79;
  unint64_t v80;
  int v81;
  size_t v82;
  uint8x8_t v83;
  uint64_t v84;
  uint64_t v85;
  unsigned int *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  int Size;
  uint64_t v91;
  double *v92;
  unint64_t v93;
  __int32 *v94;
  uint64_t v95;
  uint8x8_t v96;
  __int32 *v97;
  int v98;
  __int32 *v99;
  double v100;
  uint64_t v101;
  uint64_t v102;
  unsigned __int16 *v103;
  uint64_t v104;
  uint64_t v105;
  int v106;
  float *v107;
  unint64_t v108;
  __int32 *v109;
  uint8x8_t v110;
  int v111;
  __int32 *v112;
  double v113;
  int v114;
  int8x8_t *v115;
  __int32 *v116;
  uint8x8_t v117;
  uint64_t v118;
  int8x8_t v119;
  int v120;
  int8x8_t *v121;
  __int32 *v122;
  uint8x8_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  char *v127;
  int8x8_t *v128;
  __int32 *v129;
  uint8x8_t v130;
  __int32 *v131;
  uint64_t v132;
  int8x8_t v133;
  int v134;
  int v135;
  __int32 *v136;
  uint8x8_t v137;
  __int32 *v138;
  int v139;
  __int32 *v140;
  float v141;
  int v142;
  uint64_t v143;
  unsigned __int16 *v144;
  uint64_t v145;
  unsigned __int16 *v146;
  int v147;
  unint64_t v148;
  unint64_t v149;
  unint64_t v150;
  uint64_t v151;
  int v152;
  int v153;
  char *v154;
  _QWORD *v155;
  unint64_t v156;
  uint64_t v157;
  __n128 v158;
  int v159;
  unsigned int v160;
  uint64_t v161;
  uint64_t v162;
  _DWORD *v163;
  int v164;
  __n128 v165;
  uint64_t v166;
  const char *v167;
  __int16 v168;
  uint64_t v169;
  uint64_t v170;
  __n128 v171;
  uint64_t v172;
  __n128 v173;
  uint64_t v174;
  __int16 v175;
  int v176;
  uint64_t v177;
  uint64_t v178;
  unint64_t v179;
  unint64_t v180;
  uint64_t v182;
  char *v183;
  uint64_t v184;
  char *v185;
  uint64_t v186;
  char *v187;
  int8x8_t *v189;
  uint8x8_t v190;
  char *v191;
  int v192;
  unsigned int v193;
  unsigned int v194;
  unsigned __int16 *v195;
  char *v196;
  int v197;
  uint8x8_t v198;
  char *v199;
  char v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  const char *v206;
  char *v207;
  const char *v209;
  unsigned int v210;
  unsigned int v211;
  char *v212;
  _WORD *v213;
  int v214;
  int8x8_t *v215;
  int v216;
  unsigned __int16 *v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  int v224;
  char v225;
  unsigned int v226;
  _DWORD *v227;
  unsigned int v228;
  _QWORD *v229;
  int v230;
  unsigned int v231;
  uint64_t v232;
  int8x8_t v233;
  unint64_t __src;

  if (!*(_DWORD *)(a1 + 12))
    return 1;
  _TIFFFillStriles(a1);
  if (!a3)
    goto LABEL_13;
  v15 = *(_DWORD *)(a1 + 16);
  if ((v15 & 0x1000) != 0)
  {
    *(_DWORD *)(a1 + 16) = v15 & 0xFFFFEFFF;
    if (!(*(unsigned int (**)(uint64_t))(a1 + 1000))(a1))
    {
      v183 = "Error post-encoding before directory write";
LABEL_420:
      TIFFErrorExtR(a1, "TIFFWriteDirectorySec", v183, v9, v10, (uint64_t)v11, v12, v13, v225);
      return 0;
    }
  }
  (*(void (**)(uint64_t))(a1 + 1056))(a1);
  v17 = *(_DWORD *)(a1 + 16);
  if (*(uint64_t *)(a1 + 1160) < 1 || (v17 & 0x40) == 0)
    goto LABEL_9;
  if (!TIFFFlushData1(a1, v16, (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13))
  {
    v183 = "Error flushing data before directory write";
    goto LABEL_420;
  }
  v17 = *(_DWORD *)(a1 + 16);
LABEL_9:
  if ((v17 & 0x200) != 0)
  {
    v18 = *(char **)(a1 + 1120);
    if (v18)
    {
      _TIFFfreeExt(a1, v18);
      *(_QWORD *)(a1 + 1160) = 0;
      v14 = 0;
      *(_OWORD *)(a1 + 1120) = 0u;
      *(_OWORD *)(a1 + 1136) = 0u;
      v17 = *(_DWORD *)(a1 + 16);
    }
  }
  *(_DWORD *)(a1 + 16) = v17 & 0xFFFFFFAF;
LABEL_13:
  v226 = a3;
  v19 = (_DWORD *)(a1 + 72);
  if ((*(_BYTE *)(a1 + 72) & 0x80) != 0 && *(unsigned __int16 *)(a1 + 120) == 32946)
    TIFFWarningExtR(a1, "TIFFWriteDirectorySec", "Creating TIFF with legacy Deflate codec identifier, COMPRESSION_ADOBE_DEFLATE is more widely supported", v9, v10, (uint64_t)v11, v12, v13, v225);
  v20 = 0;
  LODWORD(v21) = 0;
  v229 = a4;
  v230 = a2;
  while (1)
  {
    v228 = v21;
    v231 = 0;
    if (v20)
    {
      if (!a2)
        goto LABEL_211;
    }
    else
    {
      *(_QWORD *)(a1 + 432) = 0;
      if (!a2)
        goto LABEL_211;
    }
    v22 = *v19;
    if ((*v19 & 2) != 0)
    {
      if (!TIFFWriteDirectoryTagShortLong(a1, &v231, v20, 256, *(_DWORD *)(a1 + 88), v14)
        || !TIFFWriteDirectoryTagShortLong(a1, &v231, v20, 257, *(_DWORD *)(a1 + 92), v23))
      {
        goto LABEL_428;
      }
      v22 = *v19;
    }
    if ((v22 & 4) != 0)
    {
      if (!TIFFWriteDirectoryTagShortLong(a1, &v231, v20, 322, *(_DWORD *)(a1 + 100), v14)
        || !TIFFWriteDirectoryTagShortLong(a1, &v231, v20, 323, *(_DWORD *)(a1 + 104), v24))
      {
        goto LABEL_428;
      }
      v22 = *v19;
    }
    if ((v22 & 8) != 0)
    {
      if (!TIFFWriteDirectoryTagRational(a1, &v231, v20, 282, v10, (uint64_t)v11, v12, v13, *(float *)(a1 + 160))|| !TIFFWriteDirectoryTagRational(a1, &v231, v20, 283, v25, v26, v27, v28, *(float *)(a1 + 164)))
      {
        goto LABEL_428;
      }
      v22 = *v19;
    }
    if ((v22 & 0x10) != 0)
    {
      if (!TIFFWriteDirectoryTagRational(a1, &v231, v20, 286, v10, (uint64_t)v11, v12, v13, *(float *)(a1 + 172))|| !TIFFWriteDirectoryTagRational(a1, &v231, v20, 287, v29, v30, v31, v32, *(float *)(a1 + 176)))
      {
        goto LABEL_428;
      }
      v22 = *v19;
    }
    if ((v22 & 0x20) != 0)
    {
      if (!TIFFWriteDirectoryTagCheckedLong(a1, &v231, v20, 254, *(_DWORD *)(a1 + 112), v14))
        goto LABEL_428;
      v22 = *v19;
    }
    if ((v22 & 0x40) != 0)
    {
      if (!TIFFWriteDirectoryTagShortPerSample(a1, &v231, v20, 258, *(_WORD *)(a1 + 116), (uint64_t)v11, v12, v13))goto LABEL_428;
      v22 = *v19;
    }
    if ((v22 & 0x80) != 0)
    {
      if (!TIFFWriteDirectoryTagCheckedShort(a1, &v231, v20, 259, *(_WORD *)(a1 + 120)))
        goto LABEL_428;
      v22 = *v19;
    }
    if ((v22 & 0x100) != 0)
    {
      if (!TIFFWriteDirectoryTagCheckedShort(a1, &v231, v20, 262, *(_WORD *)(a1 + 122)))
        goto LABEL_428;
      v22 = *v19;
    }
    if ((v22 & 0x200) != 0)
    {
      if (!TIFFWriteDirectoryTagCheckedShort(a1, &v231, v20, 263, *(_WORD *)(a1 + 124)))
        goto LABEL_428;
      v22 = *v19;
    }
    if ((v22 & 0x400) != 0)
    {
      if (!TIFFWriteDirectoryTagCheckedShort(a1, &v231, v20, 266, *(_WORD *)(a1 + 126)))
        goto LABEL_428;
      v22 = *v19;
    }
    if ((v22 & 0x8000) != 0)
    {
      if (!TIFFWriteDirectoryTagCheckedShort(a1, &v231, v20, 274, *(_WORD *)(a1 + 128)))
        goto LABEL_428;
      v22 = *v19;
    }
    if ((v22 & 0x10000) != 0)
    {
      if (!TIFFWriteDirectoryTagCheckedShort(a1, &v231, v20, 277, *(_WORD *)(a1 + 130)))
        goto LABEL_428;
      v22 = *v19;
    }
    if ((v22 & 0x20000) != 0)
    {
      if (!TIFFWriteDirectoryTagShortLong(a1, &v231, v20, 278, *(_DWORD *)(a1 + 132), v14))
        goto LABEL_428;
      v22 = *v19;
    }
    if ((v22 & 0x40000) != 0)
    {
      if (!TIFFWriteDirectoryTagShortPerSample(a1, &v231, v20, 280, *(_WORD *)(a1 + 136), (uint64_t)v11, v12, v13))goto LABEL_428;
      v22 = *v19;
    }
    if ((v22 & 0x80000) != 0)
    {
      if (!TIFFWriteDirectoryTagShortPerSample(a1, &v231, v20, 281, *(_WORD *)(a1 + 138), (uint64_t)v11, v12, v13))goto LABEL_428;
      v22 = *v19;
    }
    if ((v22 & 0x100000) != 0)
    {
      if (!TIFFWriteDirectoryTagCheckedShort(a1, &v231, v20, 284, *(_WORD *)(a1 + 170)))
        goto LABEL_428;
      v22 = *v19;
    }
    if ((v22 & 0x400000) != 0)
    {
      if (!TIFFWriteDirectoryTagCheckedShort(a1, &v231, v20, 296, *(_WORD *)(a1 + 168)))
        goto LABEL_428;
      v22 = *v19;
    }
    if ((v22 & 0x800000) != 0)
    {
      if (!TIFFWriteDirectoryTagCheckedShortArray(a1, &v231, v20, 297, 2, a1 + 180))
        goto LABEL_428;
      v22 = *v19;
    }
    if ((v22 & 0x1000000) != 0)
    {
      v33 = (*(_BYTE *)(a1 + 17) & 4) != 0 ? 325 : 279;
      if (!TIFFWriteDirectoryTagLongLong8Array(a1, &v231, v20, v33, *(unsigned int *)(a1 + 228), *(int8x8_t **)(a1 + 240), v12, v13))
      {
LABEL_428:
        if (v20)
          goto LABEL_429;
        return 0;
      }
    }
    if ((*((_BYTE *)v19 + 3) & 2) != 0)
    {
      if ((*(_BYTE *)(a1 + 17) & 4) != 0)
      {
        v34 = *(unsigned int *)(a1 + 228);
        v11 = *(int8x8_t **)(a1 + 232);
        v35 = a1;
        v36 = v20;
        v37 = 324;
      }
      else
      {
        v11 = *(int8x8_t **)(a1 + 232);
        if (!v11)
          goto LABEL_90;
        v34 = *(unsigned int *)(a1 + 228);
        v35 = a1;
        v36 = v20;
        v37 = 273;
      }
      if (!TIFFWriteDirectoryTagLongLong8Array(v35, &v231, v36, v37, v34, v11, v12, v13))
        goto LABEL_428;
    }
LABEL_90:
    v38 = *v19;
    if ((*v19 & 0x4000000) == 0)
      goto LABEL_95;
    v39 = v19;
    v40 = *(_WORD *)(a1 + 116);
    v41 = 2 * (3 << v40);
    if (v20)
    {
      v42 = (char *)_TIFFmallocExt((_QWORD *)a1, v41, (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13);
      if (!v42)
      {
        v209 = "TIFFWriteDirectoryTagColormap";
        goto LABEL_474;
      }
      v48 = v42;
      _TIFFmemcpy(v42, *(const void **)(a1 + 184), 2 * (1 << v40));
      _TIFFmemcpy(&v48[2 * (1 << v40)], *(const void **)(a1 + 192), 2 * (1 << v40));
      _TIFFmemcpy(&v48[2 * (2 << v40)], *(const void **)(a1 + 200), 2 * (1 << v40));
      v49 = TIFFWriteDirectoryTagCheckedShortArray(a1, &v231, v20, 320, (3 << v40), (uint64_t)v48);
      _TIFFfreeExt(a1, v48);
      if (!v49)
        goto LABEL_429;
      v19 = v39;
      v38 = *v39;
LABEL_95:
      if (v38 < 0)
        goto LABEL_96;
      goto LABEL_104;
    }
    v50 = 4;
    if ((*(_BYTE *)(a1 + 18) & 8) != 0)
      v50 = 8;
    if (v41 > v50)
      *(_QWORD *)(a1 + 432) += v41;
    ++v231;
    v19 = v39;
    if (v38 < 0)
    {
LABEL_96:
      if (*(_WORD *)(a1 + 212))
      {
        v233.i16[0] = 0;
        __src = 0;
        _cg_TIFFGetFieldDefaulted(a1, 338, (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13, (uint64_t)&v233);
        if (!TIFFWriteDirectoryTagCheckedShortArray(a1, &v231, v20, 338, v233.u16[0], __src))
          goto LABEL_428;
      }
    }
LABEL_104:
    v51 = *(_DWORD *)(a1 + 76);
    if ((v51 & 1) != 0)
    {
      if (!TIFFWriteDirectoryTagShortPerSample(a1, &v231, v20, 339, *(_WORD *)(a1 + 118), (uint64_t)v11, v12, v13))goto LABEL_428;
      v51 = *(_DWORD *)(a1 + 76);
    }
    if ((v51 & 2) != 0)
    {
      if (!TIFFWriteDirectoryTagSampleformatArray(a1, &v231, v20, 340, *(unsigned __int16 *)(a1 + 130), *(_QWORD *)(a1 + 144), v12, v13))goto LABEL_428;
      v51 = *(_DWORD *)(a1 + 76);
    }
    if ((v51 & 4) != 0)
    {
      if (!TIFFWriteDirectoryTagSampleformatArray(a1, &v231, v20, 341, *(unsigned __int16 *)(a1 + 130), *(_QWORD *)(a1 + 152), v12, v13))goto LABEL_428;
      v51 = *(_DWORD *)(a1 + 76);
    }
    if ((v51 & 8) != 0)
    {
      if (!TIFFWriteDirectoryTagCheckedLong(a1, &v231, v20, 32997, *(_DWORD *)(a1 + 96), v14))
        goto LABEL_428;
      v51 = *(_DWORD *)(a1 + 76);
    }
    if ((v51 & 0x10) != 0)
    {
      if (!TIFFWriteDirectoryTagCheckedLong(a1, &v231, v20, 32998, *(_DWORD *)(a1 + 108), v14))
        goto LABEL_428;
      v51 = *(_DWORD *)(a1 + 76);
    }
    if ((v51 & 0x20) != 0)
    {
      if (!TIFFWriteDirectoryTagCheckedShortArray(a1, &v231, v20, 321, 2, a1 + 208))
        goto LABEL_428;
      v51 = *(_DWORD *)(a1 + 76);
    }
    if ((v51 & 0x80) != 0)
    {
      if (!TIFFWriteDirectoryTagCheckedShortArray(a1, &v231, v20, 530, 2, a1 + 336))
        goto LABEL_428;
      v51 = *(_DWORD *)(a1 + 76);
    }
    if ((v51 & 0x100) != 0)
    {
      if (!TIFFWriteDirectoryTagCheckedShort(a1, &v231, v20, 531, *(_WORD *)(a1 + 340)))
        goto LABEL_428;
      v51 = *(_DWORD *)(a1 + 76);
    }
    if ((v51 & 0x200) != 0)
    {
      if (!TIFFWriteDirectoryTagRationalArray(a1, &v231, v20, 532, 6, *(_QWORD *)(a1 + 368), v12, v13))goto LABEL_428;
      v51 = *(_DWORD *)(a1 + 76);
    }
    if ((v51 & 0x1000) != 0)
    {
      v52 = 0;
      v53 = *(_WORD *)(a1 + 116);
      v54 = 1 << v53;
      v55 = *(unsigned __int16 *)(a1 + 130) - *(unsigned __int16 *)(a1 + 212);
      do
      {
        if (!*(_QWORD *)(a1 + 8 * v52 + 344))
        {
          TIFFWarningExtR(a1, "TIFFWriteDirectoryTagTransferfunction", "Too few TransferFunctions provided. Tag not written to file", v9, v10, (uint64_t)v11, v12, v13, v225);
          goto LABEL_156;
        }
        if (v55 < 2)
          break;
        v56 = v52++ > 1;
      }
      while (!v56);
      v57 = v19;
      if (v55 < 2)
      {
        v58 = 1;
      }
      else if (_TIFFmemcmp(*(const void **)(a1 + 344), *(const void **)(a1 + 360), 2 * v54))
      {
        v58 = 3;
      }
      else if (_TIFFmemcmp(*(const void **)(a1 + 344), *(const void **)(a1 + 352), 2 * v54))
      {
        v58 = 3;
      }
      else
      {
        v58 = 1;
      }
      v59 = 2 * (v58 << v53);
      if (v20)
      {
        v60 = (char *)_TIFFmallocExt((_QWORD *)a1, v59, (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13);
        if (!v60)
        {
          v209 = "TIFFWriteDirectoryTagTransferfunction";
LABEL_474:
          TIFFErrorExtR(a1, v209, "Out of memory", v43, v44, v45, v46, v47, v225);
          goto LABEL_429;
        }
        v61 = v60;
        _TIFFmemcpy(v60, *(const void **)(a1 + 344), 2 * (1 << v53));
        if (v58 != 1)
        {
          _TIFFmemcpy(&v61[2 * (1 << v53)], *(const void **)(a1 + 352), 2 * (1 << v53));
          _TIFFmemcpy(&v61[2 * (2 << v53)], *(const void **)(a1 + 360), 2 * (1 << v53));
        }
        v62 = TIFFWriteDirectoryTagCheckedShortArray(a1, &v231, v20, 301, (v58 << v53), (uint64_t)v61);
        _TIFFfreeExt(a1, v61);
        v19 = v57;
        if (!v62)
          goto LABEL_429;
      }
      else
      {
        v63 = 4;
        if ((*(_BYTE *)(a1 + 18) & 8) != 0)
          v63 = 8;
        if (v59 > v63)
          *(_QWORD *)(a1 + 432) += v59;
        ++v231;
        v19 = v57;
      }
    }
LABEL_156:
    v64 = *(_DWORD *)(a1 + 76);
    if ((v64 & 0x4000) != 0)
    {
      if (!TIFFWriteDirectoryTagAscii(a1, &v231, v20, 333, *(unsigned int *)(a1 + 376), *(_QWORD *)(a1 + 384)))goto LABEL_428;
      v64 = *(_DWORD *)(a1 + 76);
    }
    if ((v64 & 0x40000) != 0)
    {
      if (!TIFFWriteDirectoryTagCheckedShort(a1, &v231, v20, 334, *(_WORD *)(a1 + 392)))
        goto LABEL_428;
      v64 = *(_DWORD *)(a1 + 76);
    }
    if ((v64 & 0x20000) != 0)
    {
      v10 = *(unsigned __int16 *)(a1 + 320);
      if (*(_WORD *)(a1 + 320))
      {
        v65 = *(_QWORD *)(a1 + 904);
        if ((*(_BYTE *)(a1 + 18) & 8) != 0)
        {
          v74 = TIFFWriteDirectoryTagCheckedIfd8Array(a1, &v231, v20, 330, v10, *(int8x8_t **)(a1 + 328));
        }
        else
        {
          v66 = (__int32 *)_TIFFmallocExt((_QWORD *)a1, 4 * *(unsigned __int16 *)(a1 + 320), (uint64_t)v8, v9, *(unsigned __int16 *)(a1 + 320), (uint64_t)v11, v12, v13);
          if (!v66)
          {
            v206 = "TIFFWriteDirectoryTagSubifd";
            goto LABEL_476;
          }
          v68 = (char *)v66;
          v69 = *(unsigned __int16 *)(a1 + 320);
          if (*(_WORD *)(a1 + 320))
          {
            v70 = 0;
            v71 = *(uint64_t **)(a1 + 328);
            v72 = v66;
            do
            {
              if (!v71)
                TIFFWriteDirectorySec_cold_14();
              v73 = *v71;
              if (HIDWORD(*v71))
              {
                TIFFErrorExtR(a1, "TIFFWriteDirectoryTagSubifd", "Illegal value for SubIFD tag", v9, v69, (uint64_t)v11, v12, v13, v225);
                goto LABEL_426;
              }
              ++v71;
              *v72++ = v73;
              ++v70;
            }
            while (v70 < v69);
          }
          v74 = TIFFWriteDirectoryTagCheckedIfdArray(a1, &v231, v20, 330, v69, v66, v67);
          _TIFFfreeExt(a1, v68);
        }
        if (v20)
        {
          if (!v74)
            goto LABEL_429;
          *(_DWORD *)(a1 + 16) |= 0x2000u;
          v75 = *(unsigned __int16 *)(a1 + 320);
          *(_WORD *)(a1 + 912) = v75;
          if (v75 == 1)
            v76 = 0;
          else
            v76 = v65;
          *(_QWORD *)(a1 + 920) = v76;
        }
        else if (!v74)
        {
          return 0;
        }
      }
    }
    if ((*(_BYTE *)(a1 + 78) & 0x20) != 0)
      TIFFWarning("TIFFWriteRichIPTCTag", "Unimplemented.", (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13, v225);
    if (*(_QWORD *)(a1 + 1264))
    {
      v77 = 0;
      v78 = 1;
      do
      {
        v79 = *(unsigned int **)(*(_QWORD *)(a1 + 1256) + 8 * v77);
        v80 = *((unsigned __int16 *)v79 + 12);
        if (v80 >= 0x42 && ((*(_DWORD *)((char *)v19 + ((v80 >> 3) & 0x1FFC)) >> v80) & 1) != 0)
        {
          v81 = v79[5];
          if (v81 > 5)
          {
            if (v81 == 6)
            {
              LODWORD(__src) = 0;
              if (v79[2] != 4)
                TIFFWriteDirectorySec_cold_10();
              if (*((_WORD *)v79 + 2) != 1)
                TIFFWriteDirectorySec_cold_9();
              if (*((_BYTE *)v79 + 27))
                TIFFWriteDirectorySec_cold_8();
              _cg_TIFFGetField(a1, *v79, (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13, (uint64_t)&__src);
              if (!TIFFWriteDirectoryTagCheckedLong(a1, &v231, v20, *(unsigned __int16 *)v79, __src, v83))
                goto LABEL_428;
            }
            else
            {
              if (v81 != 40)
              {
LABEL_449:
                v200 = TIFFFieldTag(v79);
                TIFFErrorExtR(a1, "TIFFWriteDirectorySec", "Cannot write tag %u (%s)", v201, v202, v203, v204, v205, v200);
                goto LABEL_478;
              }
              v233.i32[0] = 0;
              __src = 0;
              if (v79[2] != 7)
                TIFFWriteDirectorySec_cold_13();
              if (*((__int16 *)v79 + 2) != -3)
                TIFFWriteDirectorySec_cold_12();
              if (*((_BYTE *)v79 + 27) != 1)
                TIFFWriteDirectorySec_cold_11();
              _cg_TIFFGetField(a1, *v79, (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13, (uint64_t)&v233);
              if (!TIFFWriteDirectoryTagUndefinedArray(a1, &v231, v20, *(unsigned __int16 *)v79, v233.u32[0], __src))goto LABEL_428;
            }
          }
          else if (v81 == 1)
          {
            __src = 0;
            if (v79[2] != 2)
              TIFFWriteDirectorySec_cold_4();
            if (*((__int16 *)v79 + 2) != -1)
              TIFFWriteDirectorySec_cold_3();
            if (*((_BYTE *)v79 + 27))
              TIFFWriteDirectorySec_cold_2();
            _cg_TIFFGetField(a1, *v79, (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13, (uint64_t)&__src);
            v82 = strlen((const char *)__src);
            if (!TIFFWriteDirectoryTagAscii(a1, &v231, v20, *(unsigned __int16 *)v79, v82, __src))
              goto LABEL_428;
          }
          else
          {
            if (v81 != 4)
              goto LABEL_449;
            LOWORD(__src) = 0;
            if (v79[2] != 3)
              TIFFWriteDirectorySec_cold_7();
            if (*((_WORD *)v79 + 2) != 1)
              TIFFWriteDirectorySec_cold_6();
            if (*((_BYTE *)v79 + 27))
              TIFFWriteDirectorySec_cold_5();
            _cg_TIFFGetField(a1, *v79, (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13, (uint64_t)&__src);
            if (!TIFFWriteDirectoryTagCheckedShort(a1, &v231, v20, *(unsigned __int16 *)v79, __src))
              goto LABEL_428;
          }
        }
        v77 = v78;
        v56 = *(_QWORD *)(a1 + 1264) > (unint64_t)v78++;
      }
      while (v56);
    }
LABEL_211:
    if (*(_DWORD *)(a1 + 408))
    {
      v84 = 0;
      v227 = v19;
      while (1)
      {
        v85 = *(_QWORD *)(a1 + 416);
        v86 = (unsigned int *)(v85 + 24 * v84);
        v87 = *(_QWORD *)v86;
        v88 = **(unsigned __int16 **)v86;
        v89 = v86[2];
        switch(*(_DWORD *)(*(_QWORD *)v86 + 8))
        {
          case 1:
            if (!TIFFWriteDirectoryTagByteArray(a1, &v231, v20, **(unsigned __int16 **)v86, v86[2], *(_QWORD *)(v85 + 24 * v84 + 16)))goto LABEL_428;
            goto LABEL_321;
          case 2:
            if (!TIFFWriteDirectoryTagAscii(a1, &v231, v20, **(unsigned __int16 **)v86, v86[2], *(_QWORD *)(v85 + 24 * v84 + 16)))goto LABEL_428;
            goto LABEL_321;
          case 3:
            if (!TIFFWriteDirectoryTagCheckedShortArray(a1, &v231, v20, **(unsigned __int16 **)v86, v86[2], *(_QWORD *)(v85 + 24 * v84 + 16)))goto LABEL_428;
            goto LABEL_321;
          case 4:
            if (!TIFFWriteDirectoryTagCheckedLongArray(a1, &v231, v20, **(unsigned __int16 **)v86, v86[2], *(__int32 **)(v85 + 24 * v84 + 16), v14))goto LABEL_428;
            goto LABEL_321;
          case 5:
            Size = TIFFFieldSetGetSize(v87);
            v91 = *(_QWORD *)(a1 + 416) + 24 * v84;
            v92 = *(double **)(v91 + 16);
            if (Size != 8)
            {
              v134 = Size;
              if (!TIFFWriteDirectoryTagRationalArray(a1, &v231, v20, v88, v89, *(_QWORD *)(v91 + 16), v12, v13))goto LABEL_428;
              if (v134 != 4)
                TIFFErrorExtR(a1, "TIFFLib: _TIFFWriteDirectorySec()", "Rational2Double: .set_field_type is not 4 but %d", v9, v10, (uint64_t)v11, v12, v13, v134);
              goto LABEL_321;
            }
            v93 = 4 * (2 * v89);
            if (!v20)
            {
              v148 = 4;
              if ((*(_BYTE *)(a1 + 18) & 8) != 0)
                v148 = 8;
              if (v93 > v148)
                *(_QWORD *)(a1 + 432) += v93;
              ++v231;
              goto LABEL_321;
            }
            v94 = (__int32 *)_TIFFmallocExt((_QWORD *)a1, v93, (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13);
            if (!v94)
            {
              v209 = "TIFFWriteDirectoryTagCheckedRationalDoubleArray";
              goto LABEL_474;
            }
            v97 = v94;
            if ((_DWORD)v89)
            {
              v98 = v89;
              v99 = v94;
              do
              {
                v100 = *v92++;
                DoubleToRational(v99, v99 + 1, v100, v95, v43, v44, v45, v46, v47, v225);
                v99 += 2;
                --v98;
              }
              while (v98);
            }
            if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
              TIFFSwabArrayOfLong(v97, (2 * v89), v96);
            v101 = (8 * v89);
            v102 = a1;
            v103 = v20;
            v104 = v88;
            v105 = 5;
            goto LABEL_248;
          case 6:
            if (!TIFFWriteDirectoryTagSbyteArray(a1, &v231, v20, **(unsigned __int16 **)v86, v86[2], *(_QWORD *)(v85 + 24 * v84 + 16)))goto LABEL_428;
            goto LABEL_321;
          case 7:
            if (!TIFFWriteDirectoryTagUndefinedArray(a1, &v231, v20, **(unsigned __int16 **)v86, v86[2], *(_QWORD *)(v85 + 24 * v84 + 16)))goto LABEL_428;
            goto LABEL_321;
          case 8:
            if (!TIFFWriteDirectoryTagSshortArray(a1, &v231, v20, **(unsigned __int16 **)v86, v86[2], *(_QWORD *)(v85 + 24 * v84 + 16)))goto LABEL_428;
            goto LABEL_321;
          case 9:
            if (!TIFFWriteDirectoryTagCheckedSlongArray(a1, &v231, v20, **(unsigned __int16 **)v86, v86[2], *(__int32 **)(v85 + 24 * v84 + 16), v14))goto LABEL_428;
            goto LABEL_321;
          case 0xA:
            v106 = TIFFFieldSetGetSize(v87);
            v107 = *(float **)(*(_QWORD *)(a1 + 416) + 24 * v84 + 16);
            v108 = 4 * (2 * v89);
            if (v106 != 8)
            {
              v135 = v106;
              if (v20)
              {
                v136 = (__int32 *)_TIFFmallocExt((_QWORD *)a1, v108, (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13);
                if (!v136)
                {
                  v209 = "TIFFWriteDirectoryTagCheckedSrationalArray";
                  goto LABEL_474;
                }
                v138 = v136;
                if ((_DWORD)v89)
                {
                  v139 = v89;
                  v140 = v136;
                  do
                  {
                    v141 = *v107++;
                    DoubleToSrational(v140, v140 + 1, v141);
                    v140 += 2;
                    --v139;
                  }
                  while (v139);
                }
                if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
                  TIFFSwabArrayOfLong(v138, (2 * v89), v137);
                v142 = TIFFWriteDirectoryTagData(a1, &v231, v20, v88, 10, v89, (8 * v89), (uint64_t)v138);
                _TIFFfreeExt(a1, (char *)v138);
                v19 = v227;
                if (!v142)
                  goto LABEL_428;
              }
              else
              {
                v150 = 4;
                if ((*(_BYTE *)(a1 + 18) & 8) != 0)
                  v150 = 8;
                if (v108 > v150)
                  *(_QWORD *)(a1 + 432) += v108;
                ++v231;
                v19 = v227;
              }
              if (v135 != 4)
                TIFFErrorExtR(a1, "TIFFLib: _TIFFWriteDirectorySec()", "Rational2Double: .set_field_type is not 4 but %d", v9, v10, (uint64_t)v11, v12, v13, v135);
              goto LABEL_321;
            }
            if (!v20)
            {
              v149 = 4;
              if ((*(_BYTE *)(a1 + 18) & 8) != 0)
                v149 = 8;
              if (v108 > v149)
                *(_QWORD *)(a1 + 432) += v108;
              ++v231;
              v19 = v227;
              goto LABEL_321;
            }
            v109 = (__int32 *)_TIFFmallocExt((_QWORD *)a1, v108, (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13);
            if (!v109)
            {
              v209 = "TIFFWriteDirectoryTagCheckedSrationalDoubleArray";
              goto LABEL_474;
            }
            v97 = v109;
            if ((_DWORD)v89)
            {
              v111 = v89;
              v112 = v109;
              do
              {
                v113 = *(double *)v107;
                v107 += 2;
                DoubleToSrational(v112, v112 + 1, v113);
                v112 += 2;
                --v111;
              }
              while (v111);
            }
            if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
              TIFFSwabArrayOfLong(v97, (2 * v89), v110);
            v101 = (8 * v89);
            v102 = a1;
            v103 = v20;
            v104 = v88;
            v105 = 10;
LABEL_248:
            v114 = TIFFWriteDirectoryTagData(v102, &v231, v103, v104, v105, v89, v101, (uint64_t)v97);
            _TIFFfreeExt(a1, (char *)v97);
            v19 = v227;
            goto LABEL_294;
          case 0xB:
            if (!TIFFWriteDirectoryTagFloatArray(a1, &v231, v20, **(unsigned __int16 **)v86, v86[2], *(__int32 **)(v85 + 24 * v84 + 16), v14))goto LABEL_428;
            goto LABEL_321;
          case 0xC:
            if (!TIFFWriteDirectoryTagDoubleArray(a1, &v231, v20, **(unsigned __int16 **)v86, v86[2], *(int8x8_t **)(v85 + 24 * v84 + 16)))goto LABEL_428;
            goto LABEL_321;
          case 0xD:
            if (!TIFFWriteDirectoryTagCheckedIfdArray(a1, &v231, v20, **(unsigned __int16 **)v86, v86[2], *(__int32 **)(v85 + 24 * v84 + 16), v14))goto LABEL_428;
            goto LABEL_321;
          case 0x10:
            v115 = *(int8x8_t **)(v85 + 24 * v84 + 16);
            if (!v20)
            {
              v143 = a1;
              v144 = 0;
LABEL_299:
              v147 = TIFFWriteDirectoryTagCheckedLong8Array(v143, &v231, v144, **(unsigned __int16 **)v86, v86[2], v115, v12, v13);
              goto LABEL_302;
            }
            if ((*(_BYTE *)(a1 + 18) & 8) != 0)
            {
              v143 = a1;
              v144 = v20;
              goto LABEL_299;
            }
            v116 = (__int32 *)_TIFFmallocExt((_QWORD *)a1, 4 * v89, (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13);
            if (!v116)
            {
              v209 = "TIFFWriteDirectoryTagLong8Array";
              goto LABEL_474;
            }
            v68 = (char *)v116;
            if ((_DWORD)v89)
            {
              v118 = 0;
              while (1)
              {
                v119 = v115[v118];
                if (HIDWORD(*(_QWORD *)&v119))
                  break;
                v116[v118++] = v119.i32[0];
                if ((_DWORD)v89 == (_DWORD)v118)
                  goto LABEL_262;
              }
              TIFFErrorExtR(a1, "TIFFWriteDirectoryTagLong8Array", "Attempt to write unsigned long value %llu larger than 0xFFFFFFFF for tag %d in Classic TIFF file. TIFF file writing aborted", v43, v44, v45, v46, v47, *(_QWORD *)&v115[v118]);
              goto LABEL_426;
            }
LABEL_262:
            v120 = TIFFWriteDirectoryTagCheckedLongArray(a1, &v231, v20, v88, v89, v116, v117);
LABEL_272:
            v114 = v120;
            v126 = a1;
            v127 = v68;
            goto LABEL_280;
          case 0x11:
            v121 = *(int8x8_t **)(v85 + 24 * v84 + 16);
            if (!v20)
            {
              v145 = a1;
              v146 = 0;
              goto LABEL_301;
            }
            if ((*(_BYTE *)(a1 + 18) & 8) != 0)
            {
              v145 = a1;
              v146 = v20;
LABEL_301:
              v147 = TIFFWriteDirectoryTagCheckedSlong8Array(v145, &v231, v146, **(unsigned __int16 **)v86, v86[2], v121, v12, v13);
LABEL_302:
              if (!v147)
                goto LABEL_428;
              goto LABEL_321;
            }
            v122 = (__int32 *)_TIFFmallocExt((_QWORD *)a1, 4 * v89, (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13);
            if (!v122)
            {
              v209 = "TIFFWriteDirectoryTagSlong8Array";
              goto LABEL_474;
            }
            v68 = (char *)v122;
            if ((_DWORD)v89)
            {
              v124 = 0;
              while (1)
              {
                v125 = (uint64_t)v121[v124];
                if (v125 >= 0x80000000)
                {
                  TIFFErrorExtR(a1, "TIFFWriteDirectoryTagSlong8Array", "Attempt to write signed long value %lli larger than 0x7FFFFFFF (2147483647) for tag %d in Classic TIFF file. TIFF writing to file aborted", v43, v44, v45, v46, v47, *(_QWORD *)&v121[v124]);
                  goto LABEL_426;
                }
                if (v125 <= (uint64_t)0xFFFFFFFF7FFFFFFFLL)
                  break;
                v122[v124++] = v125;
                if ((_DWORD)v89 == (_DWORD)v124)
                  goto LABEL_271;
              }
              TIFFErrorExtR(a1, "TIFFWriteDirectoryTagSlong8Array", "Attempt to write signed long value %lli smaller than 0x80000000 (-2147483648) for tag %d in Classic TIFF file. TIFF writing to file aborted", v43, v44, v45, v46, v47, *(_QWORD *)&v121[v124]);
LABEL_426:
              v184 = a1;
              v185 = v68;
LABEL_427:
              _TIFFfreeExt(v184, v185);
              goto LABEL_428;
            }
LABEL_271:
            v120 = TIFFWriteDirectoryTagCheckedSlongArray(a1, &v231, v20, v88, v89, v122, v123);
            goto LABEL_272;
          case 0x12:
            v128 = *(int8x8_t **)(v85 + 24 * v84 + 16);
            if ((*(_BYTE *)(a1 + 18) & 8) != 0)
            {
              v114 = TIFFWriteDirectoryTagCheckedIfd8Array(a1, &v231, v20, **(unsigned __int16 **)v86, v86[2], v128);
            }
            else
            {
              v129 = (__int32 *)_TIFFmallocExt((_QWORD *)a1, 4 * v89, (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13);
              if (!v129)
              {
                v206 = "TIFFWriteDirectoryTagIfdIfd8Array";
                goto LABEL_476;
              }
              v131 = v129;
              if ((_DWORD)v89)
              {
                v132 = 0;
                while (1)
                {
                  v133 = v128[v132];
                  if (HIDWORD(*(_QWORD *)&v133))
                    break;
                  v129[v132++] = v133.i32[0];
                  if ((_DWORD)v89 == (_DWORD)v132)
                    goto LABEL_279;
                }
                TIFFErrorExtR(a1, "TIFFWriteDirectoryTagIfdIfd8Array", "Attempt to write value larger than 0xFFFFFFFF in Classic TIFF file.", v9, v10, (uint64_t)v11, v12, v13, v225);
                v184 = a1;
                v185 = (char *)v131;
                goto LABEL_427;
              }
LABEL_279:
              v114 = TIFFWriteDirectoryTagCheckedIfdArray(a1, &v231, v20, v88, v89, v129, v130);
              v126 = a1;
              v127 = (char *)v131;
LABEL_280:
              _TIFFfreeExt(v126, v127);
            }
LABEL_294:
            if (!v114)
              goto LABEL_428;
LABEL_321:
            if (++v84 >= (unint64_t)*(unsigned int *)(a1 + 408))
              goto LABEL_322;
            break;
          default:
            TIFFWriteDirectorySec_cold_1();
        }
      }
    }
LABEL_322:
    if (v20)
      break;
    v151 = v231;
    if ((*(_DWORD *)(a1 + 16) & 0x80000) != 0)
      v152 = 20;
    else
      v152 = 12;
    if ((*(_DWORD *)(a1 + 16) & 0x80000) != 0)
      v153 = 16;
    else
      v153 = 6;
    *(_QWORD *)(a1 + 432) += v153 + v231 * v152;
    v154 = (char *)_TIFFmallocExt((_QWORD *)a1, 32 * v151, (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13);
    a2 = v230;
    if (!v154)
    {
      v183 = "Out of memory";
      goto LABEL_420;
    }
    v20 = (unsigned __int16 *)v154;
    if (!v230)
    {
      v156 = *(_QWORD *)(a1 + 440);
      v155 = v229;
      if (!v156 || *(_QWORD *)(a1 + 432) > v156)
      {
        *(_QWORD *)(a1 + 24) = ((*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(a1 + 1224))(*(_QWORD *)(a1 + 1200), 0, 2)+ 1) & 0xFFFFFFFFFFFFFFFELL;
        if (!v229)
          goto LABEL_400;
        goto LABEL_399;
      }
      goto LABEL_398;
    }
    v155 = v229;
    if (*(_QWORD *)(a1 + 24))
    {
      if (*(_QWORD *)(a1 + 432) > *(_QWORD *)(a1 + 440))
      {
        _TIFFfreeExt(a1, v154);
        return TIFFRewriteDirectorySec(a1, v226, v229) != 0;
      }
LABEL_398:
      if (!v155)
        goto LABEL_400;
      goto LABEL_399;
    }
    v157 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(a1 + 1224))(*(_QWORD *)(a1 + 1200), 0, 2);
    *(_QWORD *)(a1 + 24) = (v157 + 1) & 0xFFFFFFFFFFFFFFFELL;
    v159 = *(_DWORD *)(a1 + 16);
    if ((v159 & 0x2000) != 0)
    {
      if ((v159 & 0x80000) != 0)
      {
        __src = (v157 + 1) & 0xFFFFFFFFFFFFFFFELL;
        if ((v159 & 0x80) != 0)
          v158.n128_u64[0] = (unint64_t)TIFFSwabLong8((int8x8_t *)&__src);
        (*(void (**)(_QWORD, _QWORD, _QWORD, __n128))(a1 + 1224))(*(_QWORD *)(a1 + 1200), *(_QWORD *)(a1 + 920), 0, v158);
        if ((*(uint64_t (**)(_QWORD, unint64_t *, uint64_t))(a1 + 1216))(*(_QWORD *)(a1 + 1200), &__src, 8) != 8)goto LABEL_387;
        v175 = *(_WORD *)(a1 + 912) - 1;
        *(_WORD *)(a1 + 912) = v175;
        if (!v175)
          goto LABEL_395;
        v169 = *(_QWORD *)(a1 + 920) + 8;
LABEL_386:
        *(_QWORD *)(a1 + 920) = v169;
LABEL_396:
        v176 = 1;
      }
      else
      {
        LODWORD(__src) = (v157 + 1) & 0xFFFFFFFE;
        if ((v159 & 0x80) != 0)
          v158.n128_u64[0] = (unint64_t)TIFFSwabLong((__int32 *)&__src, (uint8x8_t)v158.n128_u64[0]);
        (*(void (**)(_QWORD, _QWORD, _QWORD, __n128))(a1 + 1224))(*(_QWORD *)(a1 + 1200), *(_QWORD *)(a1 + 920), 0, v158);
        if ((*(uint64_t (**)(_QWORD, unint64_t *, uint64_t))(a1 + 1216))(*(_QWORD *)(a1 + 1200), &__src, 4) == 4)
        {
          v168 = *(_WORD *)(a1 + 912) - 1;
          *(_WORD *)(a1 + 912) = v168;
          if (v168)
          {
            v169 = *(_QWORD *)(a1 + 920) + 4;
            goto LABEL_386;
          }
LABEL_395:
          *(_DWORD *)(a1 + 16) &= ~0x2000u;
          goto LABEL_396;
        }
LABEL_387:
        v166 = a1;
        v167 = "TIFFLinkDirectory";
        v8 = "Error writing SubIFD directory link";
LABEL_394:
        TIFFErrorExtR(v166, v167, v8, v9, v10, (uint64_t)v11, v12, v13, v225);
        v176 = 0;
      }
LABEL_397:
      if (!v176)
        goto LABEL_428;
      goto LABEL_398;
    }
    if ((v159 & 0x80000) != 0)
    {
      __src = (v157 + 1) & 0xFFFFFFFFFFFFFFFELL;
      if ((v159 & 0x80) != 0)
        v158.n128_u64[0] = (unint64_t)TIFFSwabLong8((int8x8_t *)&__src);
      if (*(_QWORD *)(a1 + 864))
      {
        if (*(_QWORD *)(a1 + 40))
          v170 = *(_QWORD *)(a1 + 40);
        else
          v170 = *(_QWORD *)(a1 + 864);
        while (1)
        {
          v233 = 0;
          v232 = 0;
          if (!_TIFFSeekOK(a1, v170)
            || (*(uint64_t (**)(_QWORD, int8x8_t *, uint64_t))(a1 + 1208))(*(_QWORD *)(a1 + 1200), &v233, 8) != 8)
          {
            v8 = "Error fetching directory count";
            goto LABEL_389;
          }
          if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
            v171.n128_u64[0] = (unint64_t)TIFFSwabLong8(&v233);
          if (*(_QWORD *)&v233 >> 16)
          {
            v8 = "Sanity check on tag count failed, likely corrupt TIFF";
            goto LABEL_389;
          }
          v172 = v170 + 20 * *(_QWORD *)&v233 + 8;
          (*(void (**)(_QWORD, uint64_t, _QWORD, __n128))(a1 + 1224))(*(_QWORD *)(a1 + 1200), v172, 0, v171);
          if ((*(uint64_t (**)(_QWORD, uint64_t *, uint64_t))(a1 + 1208))(*(_QWORD *)(a1 + 1200), &v232, 8) != 8)
            break;
          if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
            v173.n128_u64[0] = (unint64_t)TIFFSwabLong8((int8x8_t *)&v232);
          v170 = v232;
          if (!v232)
          {
            (*(void (**)(_QWORD, uint64_t, _QWORD, __n128))(a1 + 1224))(*(_QWORD *)(a1 + 1200), v172, 0, v173);
            v174 = (*(uint64_t (**)(_QWORD, unint64_t *, uint64_t))(a1 + 1216))(*(_QWORD *)(a1 + 1200), &__src, 8);
            v8 = "Error writing directory link";
            if (v174 != 8)
              goto LABEL_389;
            *(_QWORD *)(a1 + 40) = *(_QWORD *)(a1 + 24);
            if (!v229)
              goto LABEL_400;
LABEL_399:
            *v155 = *(_QWORD *)(a1 + 24);
            goto LABEL_400;
          }
        }
        v8 = "Error fetching directory link";
LABEL_389:
        TIFFErrorExtR(a1, "TIFFLinkDirectory", v8, v9, v10, (uint64_t)v11, v12, v13, v225);
        v176 = 0;
        goto LABEL_397;
      }
      v178 = *(_QWORD *)(a1 + 24);
      *(_QWORD *)(a1 + 864) = v178;
      *(_QWORD *)(a1 + 40) = v178;
      (*(void (**)(_QWORD, uint64_t, _QWORD, __n128))(a1 + 1224))(*(_QWORD *)(a1 + 1200), 8, 0, v158);
      if ((*(uint64_t (**)(_QWORD, unint64_t *, uint64_t))(a1 + 1216))(*(_QWORD *)(a1 + 1200), &__src, 8) == 8)goto LABEL_396;
LABEL_393:
      v167 = *(const char **)a1;
      v166 = a1;
      v8 = "Error writing TIFF header";
      goto LABEL_394;
    }
    LODWORD(__src) = (v157 + 1) & 0xFFFFFFFE;
    if ((v159 & 0x80) != 0)
      v158.n128_u64[0] = (unint64_t)TIFFSwabLong((__int32 *)&__src, (uint8x8_t)v158.n128_u64[0]);
    v160 = *(_DWORD *)(a1 + 860);
    if (!v160)
    {
      v177 = *(_QWORD *)(a1 + 24);
      *(_DWORD *)(a1 + 860) = v177;
      *(_QWORD *)(a1 + 40) = v177;
      (*(void (**)(_QWORD, uint64_t, _QWORD, __n128))(a1 + 1224))(*(_QWORD *)(a1 + 1200), 4, 0, v158);
      if ((*(uint64_t (**)(_QWORD, unint64_t *, uint64_t))(a1 + 1216))(*(_QWORD *)(a1 + 1200), &__src, 4) == 4)goto LABEL_396;
      goto LABEL_393;
    }
    v161 = *(_QWORD *)(a1 + 40);
    if (v161)
      v162 = v161;
    else
      v162 = v160;
    LOWORD(v232) = 0;
    v233.i32[0] = 0;
    if (!_TIFFSeekOK(a1, v162))
    {
LABEL_355:
      v8 = "Error fetching directory count";
LABEL_356:
      v166 = a1;
      v167 = "TIFFLinkDirectory";
      goto LABEL_394;
    }
    while (1)
    {
      if ((*(uint64_t (**)(_QWORD, uint64_t *, uint64_t))(a1 + 1208))(*(_QWORD *)(a1 + 1200), &v232, 2) != 2)
        goto LABEL_355;
      v163 = v19;
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
        TIFFSwabShort(&v232);
      v164 = v162 + 2;
      (*(void (**)(_QWORD, _QWORD, _QWORD))(a1 + 1224))(*(_QWORD *)(a1 + 1200), (_DWORD)v162 + 2 + 12 * (unsigned __int16)v232, 0);
      if ((*(uint64_t (**)(_QWORD, int8x8_t *, uint64_t))(a1 + 1208))(*(_QWORD *)(a1 + 1200), &v233, 4) != 4)
      {
        v8 = "Error fetching directory link";
        v19 = v163;
        goto LABEL_356;
      }
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
        v165.n128_u64[0] = (unint64_t)TIFFSwabLong((__int32 *)&v233, (uint8x8_t)v165.n128_u64[0]);
      v162 = v233.u32[0];
      if (!v233.i32[0])
        break;
      LOWORD(v232) = 0;
      v233.i32[0] = 0;
      v19 = v163;
      if (!_TIFFSeekOK(a1, v162))
        goto LABEL_355;
    }
    (*(void (**)(_QWORD, _QWORD, _QWORD, __n128))(a1 + 1224))(*(_QWORD *)(a1 + 1200), v164 + 12 * (unsigned __int16)v232, 0, v165);
    v182 = (*(uint64_t (**)(_QWORD, unint64_t *, uint64_t))(a1 + 1216))(*(_QWORD *)(a1 + 1200), &__src, 4);
    v8 = "Error writing directory link";
    v19 = v163;
    if (v182 != 4)
      goto LABEL_356;
    *(_QWORD *)(a1 + 40) = *(_QWORD *)(a1 + 24);
    if (v229)
      goto LABEL_399;
LABEL_400:
    v179 = *(_QWORD *)(a1 + 24);
    if ((*(_BYTE *)(a1 + 18) & 8) != 0)
    {
      v21 = 20 * v231 + 16;
      v180 = v179 + v21;
    }
    else
    {
      v21 = 12 * v231 + 6;
      v180 = (v179 + v21);
    }
    *(_QWORD *)(a1 + 904) = v180;
    if (v180 < v179 || v180 < v21)
    {
      v206 = "TIFFWriteDirectorySec";
      v207 = "Maximum TIFF file size exceeded";
      goto LABEL_477;
    }
    if ((v180 & 1) != 0)
      *(_QWORD *)(a1 + 904) = v180 + 1;
    if (v230)
      ++*(_DWORD *)(a1 + 880);
  }
  if (!v230 || (*(_BYTE *)(a1 + 78) & 2) == 0 || *(_QWORD *)(a1 + 920))
    goto LABEL_435;
  if (!v231)
  {
LABEL_484:
    v206 = "TIFFWriteDirectorySec";
    v207 = "Cannot find SubIFD tag";
    goto LABEL_477;
  }
  v216 = 0;
  v217 = v20;
  while (*v217 != 330)
  {
    ++v216;
    v217 += 16;
    if (v231 == v216)
      goto LABEL_484;
  }
  v223 = 20;
  if ((*(_DWORD *)(a1 + 16) & 0x80000) != 0)
    v224 = 20;
  else
    v224 = 12;
  if ((*(_DWORD *)(a1 + 16) & 0x80000) == 0)
    v223 = 10;
  *(_QWORD *)(a1 + 920) = v223 + *(_QWORD *)(a1 + 24) + (v216 * v224);
LABEL_435:
  v189 = (int8x8_t *)_TIFFmallocExt((_QWORD *)a1, v228, (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13);
  if (!v189)
  {
    v206 = "TIFFWriteDirectorySec";
LABEL_476:
    v207 = "Out of memory";
LABEL_477:
    TIFFErrorExtR(a1, v206, v207, v9, v10, (uint64_t)v11, v12, v13, v225);
LABEL_478:
    if (!v20)
      return 0;
LABEL_429:
    v186 = a1;
    v187 = (char *)v20;
    goto LABEL_430;
  }
  v191 = (char *)v189;
  v192 = *(_DWORD *)(a1 + 16);
  if ((v192 & 0x80000) != 0)
  {
    v210 = v231;
    *v189 = (int8x8_t)v231;
    if ((v192 & 0x80) != 0)
      TIFFSwabLong8(v189);
    if (v210)
    {
      v211 = 0;
      v212 = v191 + 10;
      v213 = v20 + 1;
      do
      {
        *((_WORD *)v212 - 1) = *(v213 - 1);
        if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
        {
          TIFFSwabShort(v212 - 2);
          v214 = *(_DWORD *)(a1 + 16);
          *(_WORD *)v212 = *v213;
          if ((v214 & 0x80) != 0)
            TIFFSwabShort(v212);
        }
        else
        {
          *(_WORD *)v212 = *v213;
        }
        _TIFFmemcpy(v212 + 2, v213 + 3, 8uLL);
        if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
          TIFFSwabLong8((int8x8_t *)(v212 + 2));
        _TIFFmemcpy(v212 + 10, v213 + 7, 8uLL);
        ++v211;
        v212 += 20;
        v213 += 16;
      }
      while (v211 < v231);
      v215 = (int8x8_t *)(v212 - 2);
    }
    else
    {
      v215 = (int8x8_t *)(v191 + 8);
    }
    _TIFFmemcpy(v215, (const void *)(a1 + 32), 8uLL);
    if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      TIFFSwabLong8(v215);
  }
  else
  {
    LODWORD(__src) = 0;
    v193 = v231;
    v189->i16[0] = v231;
    if ((v192 & 0x80) != 0)
      TIFFSwabShort(v189);
    if (v193)
    {
      v194 = 0;
      v195 = v20 + 1;
      v196 = v191 + 6;
      do
      {
        *((_WORD *)v196 - 2) = *(v195 - 1);
        if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
        {
          TIFFSwabShort(v196 - 4);
          v197 = *(_DWORD *)(a1 + 16);
          *((_WORD *)v196 - 1) = *v195;
          if ((v197 & 0x80) != 0)
            TIFFSwabShort(v196 - 2);
        }
        else
        {
          *((_WORD *)v196 - 1) = *v195;
        }
        LODWORD(__src) = *(_QWORD *)(v195 + 3);
        _TIFFmemcpy(v196, &__src, 4uLL);
        if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
          TIFFSwabLong((__int32 *)v196, v198);
        _TIFFmemcpy(v196 + 4, v195 + 7, 4uLL);
        ++v194;
        v195 += 16;
        v196 += 12;
      }
      while (v194 < v231);
      v199 = v196 - 4;
    }
    else
    {
      v199 = v191 + 2;
    }
    LODWORD(__src) = *(_QWORD *)(a1 + 32);
    if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      TIFFSwabLong((__int32 *)&__src, v190);
    _TIFFmemcpy(v199, &__src, 4uLL);
  }
  _TIFFfreeExt(a1, (char *)v20);
  if (_TIFFSeekOK(a1, *(_QWORD *)(a1 + 24))
    && (*(uint64_t (**)(_QWORD, char *, _QWORD))(a1 + 1216))(*(_QWORD *)(a1 + 1200), v191, v228) == v228)
  {
    _TIFFfreeExt(a1, v191);
    if (v226)
    {
      _cg_TIFFFreeDirectory(a1);
      *(_DWORD *)(a1 + 16) &= 0xFFDFFFF7;
      (*(void (**)(uint64_t))(a1 + 1072))(a1);
      TIFFCreateDirectory(a1);
    }
    else
    {
      *(_QWORD *)(a1 + 440) = *(_QWORD *)(a1 + 432);
    }
    return 1;
  }
  TIFFErrorExtR(a1, "TIFFWriteDirectorySec", "IO error writing directory", v218, v219, v220, v221, v222, v225);
  v186 = a1;
  v187 = v191;
LABEL_430:
  _TIFFfreeExt(v186, v187);
  return 0;
}

BOOL TIFFRewriteDirectory(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return TIFFRewriteDirectorySec(a1, 1u, 0, a4, a5, a6, a7, a8);
}

BOOL TIFFRewriteDirectorySec(uint64_t a1, unsigned int a2, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9;
  uint64_t v12;
  uint64_t v14;
  const char *v15;
  char *v16;
  uint64_t v17;
  const char *v18;
  __n128 v19;
  uint64_t v20;
  __n128 v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  __n128 v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  char v35;
  uint64_t v36;
  uint64_t v37;
  int8x8_t v38;

  v9 = *(_QWORD *)(a1 + 24);
  if (!v9)
    return TIFFWriteDirectorySec(a1, 1, 1u, 0);
  if ((*(_BYTE *)(a1 + 18) & 8) != 0)
  {
    v14 = *(_QWORD *)(a1 + 864);
    if (v14 == v9)
    {
      *(_QWORD *)(a1 + 864) = 0;
      *(_QWORD *)(a1 + 24) = 0;
      (*(void (**)(_QWORD, uint64_t, _QWORD))(a1 + 1224))(*(_QWORD *)(a1 + 1200), 8, 0);
      if ((*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(a1 + 1216))(*(_QWORD *)(a1 + 1200), a1 + 864, 8) == 8)
      {
LABEL_43:
        _TIFFRemoveEntryFromDirectoryListByOffset(a1, v9);
        return TIFFWriteDirectorySec(a1, 1, a2, a3);
      }
      goto LABEL_9;
    }
    v18 = "Error fetching directory count";
    while (1)
    {
      v37 = 0;
      v38 = 0;
      if (!_TIFFSeekOK(a1, v14)
        || (*(uint64_t (**)(_QWORD, int8x8_t *, uint64_t))(a1 + 1208))(*(_QWORD *)(a1 + 1200), &v38, 8) != 8)
      {
        break;
      }
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
        v19.n128_u64[0] = (unint64_t)TIFFSwabLong8(&v38);
      if (*(_QWORD *)&v38 >> 16)
      {
        v18 = "Sanity check on tag count failed, likely corrupt TIFF";
        break;
      }
      v20 = v14 + 20 * *(_QWORD *)&v38 + 8;
      (*(void (**)(_QWORD, uint64_t, _QWORD, __n128))(a1 + 1224))(*(_QWORD *)(a1 + 1200), v20, 0, v19);
      if ((*(uint64_t (**)(_QWORD, uint64_t *, uint64_t))(a1 + 1208))(*(_QWORD *)(a1 + 1200), &v37, 8) != 8)
      {
LABEL_44:
        v18 = "Error fetching directory link";
        break;
      }
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
        v21.n128_u64[0] = (unint64_t)TIFFSwabLong8((int8x8_t *)&v37);
      if (v37 == *(_QWORD *)(a1 + 24))
      {
        v36 = 0;
        (*(void (**)(_QWORD, uint64_t, _QWORD, __n128))(a1 + 1224))(*(_QWORD *)(a1 + 1200), v20, 0, v21);
        if ((*(uint64_t (**)(_QWORD, uint64_t *, uint64_t))(a1 + 1216))(*(_QWORD *)(a1 + 1200), &v36, 8) == 8)
        {
          *(_QWORD *)(a1 + 24) = 0;
          *(_QWORD *)(a1 + 40) = 0;
          v27 = 5;
        }
        else
        {
          TIFFErrorExtR(a1, "TIFFRewriteDirectory", "Error writing directory link", v22, v23, v24, v25, v26, v35);
          v27 = 1;
        }
        if (v27 == 5)
          goto LABEL_43;
        return 0;
      }
      v14 = v37;
    }
  }
  else
  {
    v12 = *(unsigned int *)(a1 + 860);
    if (v9 == v12)
    {
      *(_DWORD *)(a1 + 860) = 0;
      *(_QWORD *)(a1 + 24) = 0;
      (*(void (**)(_QWORD, uint64_t, _QWORD))(a1 + 1224))(*(_QWORD *)(a1 + 1200), 4, 0);
      if ((*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(a1 + 1216))(*(_QWORD *)(a1 + 1200), a1 + 860, 4) == 4)
        goto LABEL_43;
LABEL_9:
      v15 = *(const char **)a1;
      v16 = "Error updating TIFF header";
LABEL_12:
      v17 = a1;
      goto LABEL_47;
    }
    if (HIDWORD(v9))
    {
      v15 = "TIFFRewriteDirectory";
      v16 = "tif->tif_diroff exceeds 32 bit range allowed for Classic TIFF";
      goto LABEL_12;
    }
    v18 = "Error fetching directory count";
    while (1)
    {
      LOWORD(v36) = 0;
      v38.i32[0] = 0;
      if (!_TIFFSeekOK(a1, v12)
        || (*(uint64_t (**)(_QWORD, uint64_t *, uint64_t))(a1 + 1208))(*(_QWORD *)(a1 + 1200), &v36, 2) != 2)
      {
        break;
      }
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
        TIFFSwabShort(&v36);
      (*(void (**)(_QWORD, _QWORD, _QWORD))(a1 + 1224))(*(_QWORD *)(a1 + 1200), (_DWORD)v12 + 2 + 12 * (unsigned __int16)v36, 0);
      if ((*(uint64_t (**)(_QWORD, int8x8_t *, uint64_t))(a1 + 1208))(*(_QWORD *)(a1 + 1200), &v38, 4) != 4)
        goto LABEL_44;
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
        v28.n128_u64[0] = (unint64_t)TIFFSwabLong((__int32 *)&v38, (uint8x8_t)v28.n128_u64[0]);
      if (*(_QWORD *)(a1 + 24) == v38.u32[0])
      {
        LODWORD(v37) = 0;
        (*(void (**)(_QWORD, _QWORD, _QWORD, __n128))(a1 + 1224))(*(_QWORD *)(a1 + 1200), (_DWORD)v12 + 2 + 12 * (unsigned __int16)v36, 0, v28);
        if ((*(uint64_t (**)(_QWORD, uint64_t *, uint64_t))(a1 + 1216))(*(_QWORD *)(a1 + 1200), &v37, 4) == 4)
        {
          *(_QWORD *)(a1 + 24) = 0;
          *(_QWORD *)(a1 + 40) = 0;
          v34 = 3;
        }
        else
        {
          TIFFErrorExtR(a1, "TIFFRewriteDirectory", "Error writing directory link", v29, v30, v31, v32, v33, v35);
          v34 = 1;
        }
        if (v34 != 3)
          return 0;
        goto LABEL_43;
      }
      LODWORD(v12) = v38.i32[0];
    }
  }
  v15 = "TIFFRewriteDirectory";
  v17 = a1;
  v16 = (char *)v18;
LABEL_47:
  TIFFErrorExtR(v17, v15, v16, a4, a5, a6, a7, a8, v35);
  return 0;
}

uint64_t _TIFFRewriteField(uint64_t a1, int a2, unsigned int a3, int64_t a4, const void *a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int8x8_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  char *v28;
  int v29;
  int8x8_t v30;
  int8x8_t v31;
  int v32;
  __int16 v33;
  unsigned int v34;
  int v35;
  unsigned int v36;
  BOOL v37;
  int v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t result;
  int8x8_t *v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  unint64_t v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint8x8_t v68;
  uint64_t v69;
  unint64_t v70;
  int v71;
  uint64_t v72;
  int v73;
  int8x8_t v74;
  int64_t *v75;
  _WORD *v76;
  uint64_t (*v77)(uint64_t, int8x8_t *, int64_t);
  uint64_t v78;
  int v79;
  uint64_t v80;
  int64_t v81;
  uint64_t (*v82)(uint64_t, int8x8_t *, int64_t);
  uint64_t v83;
  int v84;
  uint64_t v85;
  uint8x8_t v86;
  int v87;
  int8x8_t v88;
  int v89;
  int v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  int8x8_t v97;
  int8x8_t v98;
  int64_t v99;
  unsigned __int16 v100;
  unsigned __int16 v101;
  __int16 v102;
  int8x8_t v103[4];

  v103[3] = *(int8x8_t *)MEMORY[0x1E0C80C00];
  v101 = 0;
  v100 = 0;
  v98 = 0;
  v99 = 0;
  TIFFFindField((_QWORD *)a1, a2, 0);
  if ((*(_BYTE *)(a1 + 17) & 8) != 0)
  {
    v28 = "Memory mapped files not currently supported for this operation.";
    goto LABEL_167;
  }
  v15 = *(_QWORD *)(a1 + 24);
  if (!v15)
  {
    v28 = "Attempt to reset field on directory not already on disk.";
    goto LABEL_167;
  }
  if (!_TIFFSeekOK(a1, v15))
    goto LABEL_166;
  v102 = 0;
  memset(v103, 0, 20);
  v16 = *(_QWORD *)(a1 + 24);
  if ((*(_BYTE *)(a1 + 18) & 8) != 0)
  {
    v97 = 0;
    if ((*(uint64_t (**)(_QWORD, int8x8_t *, uint64_t))(a1 + 1208))(*(_QWORD *)(a1 + 1200), &v97, 8) == 8)
    {
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
        v24 = TIFFSwabLong8(&v97);
      v102 = v97.i16[0];
      v25 = v16 + 8;
      v26 = 20;
      if (v97.i16[0])
      {
LABEL_9:
        while ((*(uint64_t (**)(_QWORD, int8x8_t *, uint64_t))(a1 + 1208))(*(_QWORD *)(a1 + 1200), v103, v26) == v26)
        {
          v27 = v103[0].u16[0];
          v101 = v103[0].i16[0];
          if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
          {
            TIFFSwabShort(&v101);
            v27 = v101;
          }
          if (v27 != a2)
          {
            v25 += v26;
            if (v102)
              continue;
          }
          goto LABEL_22;
        }
        TIFFErrorExtR(a1, "TIFFResetField", "%s: Can not read TIFF directory entry.", v19, v20, v21, v22, v23, *(_QWORD *)a1);
        return 0;
      }
      goto LABEL_21;
    }
LABEL_28:
    TIFFErrorExtR(a1, "TIFFResetField", "%s: Can not read TIFF directory count", v19, v20, v21, v22, v23, *(_QWORD *)a1);
    return 0;
  }
  if ((*(uint64_t (**)(_QWORD, __int16 *, uint64_t))(a1 + 1208))(*(_QWORD *)(a1 + 1200), &v102, 2) != 2)
    goto LABEL_28;
  if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
    TIFFSwabShort(&v102);
  v25 = v16 + 2;
  v26 = 12;
  if (v102)
    goto LABEL_9;
LABEL_21:
  v27 = v101;
LABEL_22:
  if (v27 == a2)
  {
    v100 = v103[0].u16[1];
    v29 = *(_DWORD *)(a1 + 16);
    if ((v29 & 0x80) != 0)
    {
      TIFFSwabShort(&v100);
      v29 = *(_DWORD *)(a1 + 16);
    }
    if ((v29 & 0x80000) != 0)
    {
      v99 = *(int64_t *)((char *)v103 + 4);
      if ((v29 & 0x80) != 0)
      {
        TIFFSwabLong8((int8x8_t *)&v99);
        v35 = *(_DWORD *)(a1 + 16);
        v30 = *(int8x8_t *)((char *)&v103[1] + 4);
        v98 = *(int8x8_t *)((char *)&v103[1] + 4);
        if ((v35 & 0x80) != 0)
        {
          TIFFSwabLong8(&v98);
          v30 = v98;
        }
LABEL_37:
        if (*(_QWORD *)&v30 || v99 || v100)
        {
LABEL_46:
          if (TIFFDataWidth(a3) != 8 || (*(_BYTE *)(a1 + 18) & 8) != 0)
          {
            if (a3 == 18)
            {
              v36 = v100;
              v37 = v100 == 13;
              v38 = 18;
            }
            else
            {
              if (a3 != 17)
              {
                v34 = a3;
                if (a3 == 16 && v100 <= 0x10u && ((1 << v100) & 0x10018) != 0)
                  v34 = v100;
                goto LABEL_67;
              }
              v36 = v100;
              v37 = v100 == 9;
              v38 = 17;
            }
            if (v37)
              v34 = v36;
            else
              v34 = v38;
          }
          else if (a3 == 18)
          {
            v34 = 13;
          }
          else if (a3 == 17)
          {
            v34 = 9;
          }
          else
          {
            v34 = a3;
            if (a3 == 16)
            {
              if (v100 == 3)
                v34 = 3;
              else
                v34 = 4;
            }
          }
LABEL_67:
          v39 = TIFFDataWidth(v34);
          result = (uint64_t)_TIFFCheckMalloc((const char **)a1, a4, v39, (uint64_t)"for field buffer.", v40, v41, v42, v43);
          if (!result)
            return result;
          v45 = (int8x8_t *)result;
          if (v34 == a3)
          {
            v46 = TIFFDataWidth(a3);
            memcpy(v45, a5, v46 * a4);
            goto LABEL_70;
          }
          if (a3 == 17 && v34 == 9)
          {
            if (a4 < 1)
              goto LABEL_70;
            v47 = 0;
            while (1)
            {
              v48 = *((_QWORD *)a5 + v47);
              *(_DWORD *)(result + 4 * v47) = v48;
              if (v48 != (int)v48)
                goto LABEL_94;
              if (a4 == ++v47)
                goto LABEL_70;
            }
          }
          if (a3 == 16 && v34 == 4 || a3 == 18 && v34 == 13)
          {
            if (a4 < 1)
              goto LABEL_70;
            v58 = 0;
            while (1)
            {
              v59 = *((_QWORD *)a5 + v58);
              *(_DWORD *)(result + 4 * v58) = v59;
              if (HIDWORD(v59))
                break;
              if (a4 == ++v58)
                goto LABEL_70;
            }
LABEL_94:
            _TIFFfreeExt(a1, (char *)result);
            v28 = "Value exceeds 32bit range of output type.";
            goto LABEL_167;
          }
          if (a3 == 16 && v34 == 3)
          {
            if (a4 >= 1)
            {
              v69 = 0;
              while (1)
              {
                v70 = *((_QWORD *)a5 + v69);
                *(_WORD *)(result + 2 * v69) = v70;
                if (v70 >= 0x10000)
                  break;
                if (a4 == ++v69)
                  goto LABEL_70;
              }
              _TIFFfreeExt(a1, (char *)result);
              v28 = "Value exceeds 16bit range of output type.";
              goto LABEL_167;
            }
LABEL_70:
            if ((int)TIFFDataWidth(v34) >= 2 && (*(_BYTE *)(a1 + 16) & 0x80) != 0)
            {
              if (TIFFDataWidth(v34) == 2)
              {
                TIFFSwabArrayOfShort((uint64_t)v45, a4);
              }
              else if (TIFFDataWidth(v34) == 4)
              {
                TIFFSwabArrayOfLong((__int32 *)v45, a4, v68);
              }
              else if (TIFFDataWidth(v34) == 8)
              {
                TIFFSwabArrayOfLong8(v45, a4);
              }
            }
            v71 = *(_DWORD *)(a1 + 16);
            v72 = (int)TIFFDataWidth(v34) * a4;
            if ((v71 & 0x80000) != 0)
            {
              if (v72 <= 8)
              {
                v73 = 0;
                v74 = (int8x8_t)(v25 + 12);
                goto LABEL_117;
              }
            }
            else if (v72 <= 4)
            {
              v73 = 0;
              v74 = (int8x8_t)(v25 + 8);
LABEL_117:
              v98 = v74;
              goto LABEL_119;
            }
            v73 = 1;
LABEL_119:
            if (a2 > 323)
            {
              if (a2 == 325)
              {
LABEL_128:
                if (!*(_QWORD *)(a1 + 296) && !*(_WORD *)(a1 + 290) && !*(_QWORD *)(a1 + 304))
                {
                  v75 = (int64_t *)(a1 + 296);
                  v76 = (_WORD *)(a1 + 290);
LABEL_138:
                  *v76 = v34;
                  *v75 = a4;
                }
LABEL_139:
                if (v99 == a4 && v100 == (unsigned __int16)v34)
                {
                  if (_TIFFSeekOK(a1, *(_QWORD *)&v98))
                  {
                    v77 = *(uint64_t (**)(uint64_t, int8x8_t *, int64_t))(a1 + 1216);
                    v78 = *(_QWORD *)(a1 + 1200);
                    v79 = TIFFDataWidth(v34);
                    v80 = v77(v78, v45, v79 * a4);
                    v81 = (int)TIFFDataWidth(v34) * a4;
                    _TIFFfreeExt(a1, (char *)v45);
                    if (v80 == v81)
                      return 1;
                    goto LABEL_147;
                  }
                  _TIFFfreeExt(a1, (char *)v45);
                }
                else
                {
                  if (v73)
                  {
                    v98 = (int8x8_t)(*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(a1 + 1224))(*(_QWORD *)(a1 + 1200), 0, 2);
                    v82 = *(uint64_t (**)(uint64_t, int8x8_t *, int64_t))(a1 + 1216);
                    v83 = *(_QWORD *)(a1 + 1200);
                    v84 = TIFFDataWidth(v34);
                    v85 = v82(v83, v45, v84 * a4);
                    if (v85 != (int)TIFFDataWidth(v34) * a4)
                    {
                      _TIFFfreeExt(a1, (char *)v45);
LABEL_147:
                      v28 = "Error writing directory link";
                      goto LABEL_167;
                    }
                  }
                  else if ((int)TIFFDataWidth(v34) * a4 == 4)
                  {
                    v97.i32[0] = 0;
                    TIFFDataWidth(v34);
                    __memcpy_chk();
                    v98 = (int8x8_t)v97.u32[0];
                  }
                  else
                  {
                    TIFFDataWidth(v34);
                    __memcpy_chk();
                  }
                  _TIFFfreeExt(a1, (char *)v45);
                  v100 = v34;
                  v99 = a4;
                  v103[0].i16[1] = v34;
                  v87 = *(_DWORD *)(a1 + 16);
                  if ((v87 & 0x80) != 0)
                  {
                    TIFFSwabShort((_BYTE *)v103 + 2);
                    v87 = *(_DWORD *)(a1 + 16);
                  }
                  if ((v87 & 0x80000) != 0)
                  {
                    *(int8x8_t *)((char *)v103 + 4) = (int8x8_t)v99;
                    if ((v87 & 0x80) != 0)
                    {
                      TIFFSwabLong8((int8x8_t *)((char *)v103 + 4));
                      v90 = *(_DWORD *)(a1 + 16);
                      *(int8x8_t *)((char *)&v103[1] + 4) = v98;
                      if ((v90 & 0x80) != 0)
                        TIFFSwabLong8((int8x8_t *)((char *)&v103[1] + 4));
                    }
                    else
                    {
                      *(int8x8_t *)((char *)&v103[1] + 4) = v98;
                    }
                  }
                  else
                  {
                    v103[0].i32[1] = v99;
                    if ((v87 & 0x80) != 0)
                    {
                      v88 = TIFFSwabLong((__int32 *)v103 + 1, v86);
                      v89 = *(_DWORD *)(a1 + 16);
                      v103[1].i32[0] = v98.i32[0];
                      if ((v89 & 0x80) != 0)
                        TIFFSwabLong((__int32 *)&v103[1], (uint8x8_t)v88);
                    }
                    else
                    {
                      v103[1].i32[0] = v98.i32[0];
                    }
                  }
                  if (_TIFFSeekOK(a1, v25))
                  {
                    if ((*(uint64_t (**)(_QWORD, int8x8_t *, uint64_t))(a1 + 1216))(*(_QWORD *)(a1 + 1200), v103, v26) == v26)return 1;
                    TIFFErrorExtR(a1, "TIFFResetField", "%s: Can not write TIFF directory entry.", v91, v92, v93, v94, v95, *(_QWORD *)a1);
                    return 0;
                  }
                }
LABEL_166:
                v96 = *(_QWORD *)a1;
                v28 = "%s: Seek error accessing TIFF directory";
                goto LABEL_167;
              }
              if (a2 != 324)
                goto LABEL_139;
            }
            else if (a2 != 273)
            {
              goto LABEL_127;
            }
            if (!*(_QWORD *)(a1 + 264) && !*(_WORD *)(a1 + 258) && !*(_QWORD *)(a1 + 272))
            {
              v75 = (int64_t *)(a1 + 264);
              v76 = (_WORD *)(a1 + 258);
              goto LABEL_138;
            }
LABEL_127:
            if (a2 != 279)
              goto LABEL_139;
            goto LABEL_128;
          }
          v28 = "Unhandled type conversion.";
LABEL_167:
          TIFFErrorExtR(a1, "TIFFResetField", v28, v10, v11, v12, v13, v14, v96);
          return 0;
        }
        if (a2 == 324 || a2 == 273)
        {
          if ((*(_DWORD *)(a1 + 16) & 0x80000) != 0)
            v33 = 16;
          else
            v33 = 4;
          goto LABEL_45;
        }
        if (a2 == 279 && a4 > 1)
        {
          v49 = _cg_TIFFStripSize64(a1, v17, v18, v19, v20, v21, v22, v23);
          if (!_WriteAsType(a1, v49, 0xFFFFFFFFuLL))
          {
            v57 = _cg_TIFFStripSize64(a1, v50, v51, v52, v53, v54, v55, v56);
            goto LABEL_134;
          }
        }
        else
        {
          v33 = 16;
          if (a2 != 325 || a4 <= 1)
            goto LABEL_45;
          v60 = _cg_TIFFTileSize64(a1, v17, v18, v19, v20, v21, v22, v23);
          if (!_WriteAsType(a1, v60, 0xFFFFFFFFuLL))
          {
            v57 = _cg_TIFFTileSize64(a1, v61, v62, v63, v64, v65, v66, v67);
LABEL_134:
            if (_WriteAsType(a1, v57, 0xFFFFuLL))
              v33 = 4;
            else
              v33 = 3;
            goto LABEL_45;
          }
        }
        v33 = 16;
LABEL_45:
        v100 = v33;
        goto LABEL_46;
      }
      v30 = *(int8x8_t *)((char *)&v103[1] + 4);
    }
    else
    {
      v97.i32[0] = v103[0].i32[1];
      if ((v29 & 0x80) != 0)
      {
        v31 = TIFFSwabLong((__int32 *)&v97, (uint8x8_t)v24);
        v32 = *(_DWORD *)(a1 + 16);
        v99 = v97.u32[0];
        v30.i32[0] = v103[1].i32[0];
        v97.i32[0] = v103[1].i32[0];
        if ((v32 & 0x80) != 0)
        {
          TIFFSwabLong((__int32 *)&v97, (uint8x8_t)v31);
          v30.i32[0] = v97.i32[0];
        }
      }
      else
      {
        v99 = v103[0].u32[1];
        v30.i32[0] = v103[1].i32[0];
      }
      v30 = (int8x8_t)v30.u32[0];
    }
    v98 = v30;
    goto LABEL_37;
  }
  TIFFErrorExtR(a1, "TIFFResetField", "%s: Could not find tag %hu.", v19, v20, v21, v22, v23, *(_QWORD *)a1);
  return 0;
}

uint64_t TIFFWriteDirectoryTagShortLong(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, unsigned __int32 a5, uint8x8_t a6)
{
  if (HIWORD(a5))
    return TIFFWriteDirectoryTagCheckedLong(a1, a2, a3, a4, a5, a6);
  else
    return TIFFWriteDirectoryTagCheckedShort(a1, a2, a3, a4, a5);
}

uint64_t TIFFWriteDirectoryTagRational(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9)
{
  uint8x8_t v14;
  int8x8_t v15;
  __int32 v16;
  __int32 v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a9 >= 0.0)
  {
    if (a3)
    {
      DoubleToRational(&v16, &v17, a9, (uint64_t)a3, a4, a5, a6, a7, a8, 0);
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      {
        v15 = TIFFSwabLong(&v16, v14);
        TIFFSwabLong(&v17, (uint8x8_t)v15);
      }
      return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 5, 1, 8, (uint64_t)&v16);
    }
    else
    {
      *(_QWORD *)(a1 + 432) += ~*(_WORD *)(a1 + 18) & 8;
      ++*a2;
      return 1;
    }
  }
  else
  {
    TIFFErrorExtR(a1, "TIFFWriteDirectoryTagCheckedRational", "Negative value is illegal", a4, a5, a6, a7, a8, v16);
    return 0;
  }
}

uint64_t TIFFWriteDirectoryTagShortPerSample(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, __int16 a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  unsigned int v20;
  char *v21;
  uint64_t v22;
  uint64_t v24;
  char v25;

  if (!a3)
    return TIFFWriteDirectoryTagCheckedShortArray(a1, a2, 0, a4, *(unsigned __int16 *)(a1 + 130), 0);
  v13 = (char *)_TIFFmallocExt((_QWORD *)a1, 2 * *(unsigned __int16 *)(a1 + 130), (uint64_t)a3, a4, *(unsigned __int16 *)(a1 + 130), a6, a7, a8);
  if (v13)
  {
    v19 = v13;
    if (*(_WORD *)(a1 + 130))
    {
      v20 = 0;
      v21 = v13;
      do
      {
        *(_WORD *)v21 = a5;
        v21 += 2;
        ++v20;
        v22 = *(unsigned __int16 *)(a1 + 130);
      }
      while (v20 < v22);
    }
    else
    {
      v22 = 0;
    }
    v24 = TIFFWriteDirectoryTagCheckedShortArray(a1, a2, a3, a4, v22, (uint64_t)v13);
    _TIFFfreeExt(a1, v19);
    return v24;
  }
  else
  {
    TIFFErrorExtR(a1, "TIFFWriteDirectoryTagShortPerSample", "Out of memory", v14, v15, v16, v17, v18, v25);
    return 0;
  }
}

uint64_t TIFFWriteDirectoryTagLongLong8Array(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, int8x8_t *__src, uint64_t a7, uint64_t a8)
{
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  __int32 *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint8x8_t v24;
  __int32 *v25;
  uint64_t v26;
  int8x8_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  char *v31;
  char *v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  char *v36;
  char v37;

  if (*(_BYTE *)(a1 + 424))
  {
    if (a3)
      return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 0, 0, 0, 0);
    ++*a2;
    return 1;
  }
  if ((*(_BYTE *)(a1 + 18) & 8) != 0)
  {
    if ((_DWORD)a4 == 279 && a5 >= 2)
    {
      v15 = _cg_TIFFStripSize64(a1, (uint64_t)a2, (uint64_t)a3, a4, a5, (uint64_t)__src, a7, a8);
    }
    else
    {
      if ((_DWORD)a4 != 325 || a5 < 2)
        return TIFFWriteDirectoryTagCheckedLong8Array(a1, a2, a3, a4, a5, __src, a7, a8);
      v15 = _cg_TIFFTileSize64(a1, (uint64_t)a2, (uint64_t)a3, a4, a5, (uint64_t)__src, a7, a8);
    }
    if (_WriteAsType(a1, v15, 0xFFFFFFFFuLL))
      return TIFFWriteDirectoryTagCheckedLong8Array(a1, a2, a3, a4, a5, __src, a7, a8);
  }
  v16 = a5;
  if ((_DWORD)a4 == 279 && a5 >= 2)
  {
    v17 = _cg_TIFFStripSize64(a1, (uint64_t)a2, (uint64_t)a3, a4, a5, (uint64_t)__src, a7, a8);
  }
  else
  {
    if ((_DWORD)a4 != 325 || a5 < 2)
      goto LABEL_21;
    v17 = _cg_TIFFTileSize64(a1, (uint64_t)a2, (uint64_t)a3, a4, a5, (uint64_t)__src, a7, a8);
  }
  if (!_WriteAsType(a1, v17, 0xFFFFuLL))
  {
    v31 = (char *)_TIFFmallocExt((_QWORD *)a1, 2 * a5, (uint64_t)a3, a4, a5, (uint64_t)__src, a7, a8);
    if (v31)
    {
      v32 = v31;
      v33 = 0;
      while (1)
      {
        v34 = (unint64_t)__src[v33];
        if (v34 >= 0x10000)
          break;
        *(_WORD *)&v31[2 * v33++] = v34;
        if ((_DWORD)v16 == (_DWORD)v33)
        {
          v28 = TIFFWriteDirectoryTagCheckedShortArray(a1, a2, a3, a4, v16, (uint64_t)v31);
          v29 = a1;
          v30 = v32;
          goto LABEL_32;
        }
      }
      TIFFErrorExtR(a1, "TIFFWriteDirectoryTagLongLong8Array", "Attempt to write value larger than 0xFFFF in SHORT array.", v19, v20, v21, v22, v23, v37);
      v35 = a1;
      v36 = v32;
      goto LABEL_36;
    }
LABEL_33:
    TIFFErrorExtR(a1, "TIFFWriteDirectoryTagLongLong8Array", "Out of memory", v19, v20, v21, v22, v23, v37);
    return 0;
  }
LABEL_21:
  v18 = (__int32 *)_TIFFmallocExt((_QWORD *)a1, 4 * a5, (uint64_t)a3, a4, a5, (uint64_t)__src, a7, a8);
  if (!v18)
    goto LABEL_33;
  v25 = v18;
  if ((_DWORD)a5)
  {
    v26 = 0;
    while (1)
    {
      v27 = __src[v26];
      if (HIDWORD(*(_QWORD *)&v27))
        break;
      v18[v26++] = v27.i32[0];
      if ((_DWORD)a5 == (_DWORD)v26)
        goto LABEL_26;
    }
    TIFFErrorExtR(a1, "TIFFWriteDirectoryTagLongLong8Array", "Attempt to write value larger than 0xFFFFFFFF in LONG array.", v19, v20, v21, v22, v23, v37);
    v35 = a1;
    v36 = (char *)v25;
LABEL_36:
    _TIFFfreeExt(v35, v36);
    return 0;
  }
LABEL_26:
  v28 = TIFFWriteDirectoryTagCheckedLongArray(a1, a2, a3, a4, a5, v18, v24);
  v29 = a1;
  v30 = (char *)v25;
LABEL_32:
  _TIFFfreeExt(v29, v30);
  return v28;
}

uint64_t TIFFWriteDirectoryTagSampleformatArray(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int8x8_t *v8;
  __int32 *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint8x8_t v20;
  __int32 *v21;
  uint64_t v22;
  int v23;
  __int32 *v24;
  int8x8_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  __int32 *v29;
  double v30;
  int v31;
  unsigned int v32;
  __int32 *v33;
  double v34;
  int v35;
  __int32 *v36;
  double v37;
  int v38;
  __int32 *v39;
  double v40;
  int v41;
  unsigned int *v42;
  double v43;
  unsigned int v44;
  __int32 *v45;
  double v46;
  int v47;
  char v49;

  v8 = (int8x8_t *)a6;
  v14 = (__int32 *)_TIFFmallocExt((_QWORD *)a1, 8 * a5, (uint64_t)a3, a4, a5, a6, a7, a8);
  if (v14)
  {
    v21 = v14;
    v22 = a5;
    v23 = *(unsigned __int16 *)(a1 + 118);
    switch(v23)
    {
      case 1:
        v28 = *(unsigned __int16 *)(a1 + 116);
        if (v28 > 8)
        {
          if (v28 >= 0x11)
          {
            if ((_DWORD)a5)
            {
              v20 = (uint8x8_t)0x41EFFFFFFFE00000;
              v42 = (unsigned int *)v14;
              do
              {
                v43 = *(double *)v8;
                if (*(double *)v8 >= 0.0)
                {
                  v44 = v43;
                  if (v43 > 4294967300.0)
                    v44 = -1;
                }
                else
                {
                  v44 = 0;
                }
                *v42++ = v44;
                ++v8;
                --v22;
              }
              while (v22);
            }
            v26 = TIFFWriteDirectoryTagCheckedLongArray(a1, a2, a3, a4, a5, v14, v20);
          }
          else
          {
            if ((_DWORD)a5)
            {
              v36 = v14;
              do
              {
                v37 = *(double *)v8;
                if (*(double *)v8 >= 0.0)
                {
                  v38 = (int)v37;
                  if (v37 > 65535.0)
                    LOWORD(v38) = -1;
                }
                else
                {
                  LOWORD(v38) = 0;
                }
                *(_WORD *)v36 = v38;
                v36 = (__int32 *)((char *)v36 + 2);
                ++v8;
                --v22;
              }
              while (v22);
            }
            v26 = TIFFWriteDirectoryTagCheckedShortArray(a1, a2, a3, a4, a5, (uint64_t)v14);
          }
        }
        else
        {
          if ((_DWORD)a5)
          {
            v29 = v14;
            do
            {
              v30 = *(double *)v8;
              if (*(double *)v8 >= 0.0)
              {
                v31 = (int)v30;
                if (v30 > 255.0)
                  LOBYTE(v31) = -1;
              }
              else
              {
                LOBYTE(v31) = 0;
              }
              *(_BYTE *)v29 = v31;
              v29 = (__int32 *)((char *)v29 + 1);
              ++v8;
              --v22;
            }
            while (v22);
          }
          v26 = TIFFWriteDirectoryTagByteArray(a1, a2, a3, a4, a5, (uint64_t)v14);
        }
        break;
      case 2:
        v32 = *(unsigned __int16 *)(a1 + 116);
        if (v32 > 8)
        {
          if (v32 >= 0x11)
          {
            if ((_DWORD)a5)
            {
              v20 = (uint8x8_t)0x41DFFFFFFFC00000;
              v45 = v14;
              do
              {
                v46 = *(double *)v8;
                if (*(double *)v8 <= 2147483650.0)
                {
                  v47 = (int)v46;
                  if (v46 < -2147483650.0)
                    v47 = 0x80000000;
                }
                else
                {
                  v47 = 0x7FFFFFFF;
                }
                *v45++ = v47;
                ++v8;
                --v22;
              }
              while (v22);
            }
            v26 = TIFFWriteDirectoryTagCheckedSlongArray(a1, a2, a3, a4, a5, v14, v20);
          }
          else
          {
            if ((_DWORD)a5)
            {
              v39 = v14;
              do
              {
                v40 = *(double *)v8;
                if (*(double *)v8 <= 32767.0)
                {
                  v41 = (int)v40;
                  if (v40 < -32768.0)
                    LOWORD(v41) = 0x8000;
                }
                else
                {
                  LOWORD(v41) = 0x7FFF;
                }
                *(_WORD *)v39 = v41;
                v39 = (__int32 *)((char *)v39 + 2);
                ++v8;
                --v22;
              }
              while (v22);
            }
            v26 = TIFFWriteDirectoryTagSshortArray(a1, a2, a3, a4, a5, (uint64_t)v14);
          }
        }
        else
        {
          if ((_DWORD)a5)
          {
            v33 = v14;
            do
            {
              v34 = *(double *)v8;
              if (*(double *)v8 <= 127.0)
              {
                v35 = (int)v34;
                if (v34 < -128.0)
                  LOBYTE(v35) = 0x80;
              }
              else
              {
                LOBYTE(v35) = 127;
              }
              *(_BYTE *)v33 = v35;
              v33 = (__int32 *)((char *)v33 + 1);
              ++v8;
              --v22;
            }
            while (v22);
          }
          v26 = TIFFWriteDirectoryTagSbyteArray(a1, a2, a3, a4, a5, (uint64_t)v14);
        }
        break;
      case 3:
        if (*(unsigned __int16 *)(a1 + 116) > 0x20u)
        {
          v26 = TIFFWriteDirectoryTagDoubleArray(a1, a2, a3, a4, a5, v8);
        }
        else
        {
          if ((_DWORD)a5)
          {
            v24 = v14;
            do
            {
              v25 = *v8++;
              *(float *)v20.i32 = _TIFFClampDoubleToFloat(*(double *)&v25);
              *v24++ = v20.i32[0];
              --v22;
            }
            while (v22);
          }
          v26 = TIFFWriteDirectoryTagFloatArray(a1, a2, a3, a4, a5, v21, v20);
        }
        break;
      default:
        v27 = 0;
LABEL_66:
        _TIFFfreeExt(a1, (char *)v21);
        return v27;
    }
    v27 = v26;
    goto LABEL_66;
  }
  TIFFErrorExtR(a1, "TIFFWriteDirectoryTagSampleformatArray", "Out of memory", v15, v16, v17, v18, v19, v49);
  return 0;
}

uint64_t TIFFWriteDirectoryTagRationalArray(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  unint64_t v11;
  float *v12;
  __int32 *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint8x8_t v23;
  __int32 *v24;
  int v25;
  __int32 *v26;
  float v27;
  uint64_t v28;
  unint64_t v30;
  char v31;

  v10 = (2 * a5);
  v11 = 4 * v10;
  if (a3)
  {
    v12 = (float *)a6;
    v16 = (__int32 *)_TIFFmallocExt((_QWORD *)a1, v11, (uint64_t)a3, a4, a5, a6, a7, a8);
    if (v16)
    {
      v24 = v16;
      if ((_DWORD)a5)
      {
        v25 = a5;
        v26 = v16;
        do
        {
          v27 = *v12++;
          DoubleToRational(v26, v26 + 1, v27, v17, v18, v19, v20, v21, v22, v31);
          v26 += 2;
          --v25;
        }
        while (v25);
      }
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
        TIFFSwabArrayOfLong(v24, v10, v23);
      v28 = TIFFWriteDirectoryTagData(a1, a2, a3, a4, 5, a5, (8 * a5), (uint64_t)v24);
      _TIFFfreeExt(a1, (char *)v24);
      return v28;
    }
    else
    {
      TIFFErrorExtR(a1, "TIFFWriteDirectoryTagCheckedRationalArray", "Out of memory", v18, v19, v20, v21, v22, v31);
      return 0;
    }
  }
  else
  {
    v30 = 8;
    if ((*(_BYTE *)(a1 + 18) & 8) == 0)
      v30 = 4;
    if (v11 > v30)
      *(_QWORD *)(a1 + 432) += v11;
    ++*a2;
    return 1;
  }
}

uint64_t TIFFWriteDirectoryTagAscii(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t __src)
{
  unint64_t v7;

  if (a3)
    return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 2, a5, a5, __src);
  v7 = 8;
  if ((*(_BYTE *)(a1 + 18) & 8) == 0)
    v7 = 4;
  if (v7 < a5)
    *(_QWORD *)(a1 + 432) += (a5 & 1) + a5;
  ++*a2;
  return 1;
}

uint64_t TIFFWriteDirectoryTagUndefinedArray(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t __src)
{
  unint64_t v7;

  if (a3)
    return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 7, a5, a5, __src);
  v7 = 8;
  if ((*(_BYTE *)(a1 + 18) & 8) == 0)
    v7 = 4;
  if (v7 < a5)
    *(_QWORD *)(a1 + 432) += (a5 & 1) + a5;
  ++*a2;
  return 1;
}

uint64_t TIFFWriteDirectoryTagByteArray(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t __src)
{
  unint64_t v7;

  if (a3)
    return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 1, a5, a5, __src);
  v7 = 8;
  if ((*(_BYTE *)(a1 + 18) & 8) == 0)
    v7 = 4;
  if (v7 < a5)
    *(_QWORD *)(a1 + 432) += (a5 & 1) + a5;
  ++*a2;
  return 1;
}

uint64_t TIFFWriteDirectoryTagSbyteArray(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t __src)
{
  unint64_t v7;

  if (a3)
    return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 6, a5, a5, __src);
  v7 = 8;
  if ((*(_BYTE *)(a1 + 18) & 8) == 0)
    v7 = 4;
  if (v7 < a5)
    *(_QWORD *)(a1 + 432) += (a5 & 1) + a5;
  ++*a2;
  return 1;
}

uint64_t TIFFWriteDirectoryTagSshortArray(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t __src)
{
  unint64_t v13;
  unint64_t v14;

  if ((a5 & 0x80000000) != 0)
    TIFFWriteDirectoryTagSshortArray_cold_1();
  if (a3)
  {
    if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      TIFFSwabArrayOfShort(__src, a5);
    return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 8, a5, (2 * a5), __src);
  }
  else
  {
    v13 = 2 * a5;
    v14 = 8;
    if ((*(_BYTE *)(a1 + 18) & 8) == 0)
      v14 = 4;
    if (v13 > v14)
      *(_QWORD *)(a1 + 432) += v13;
    ++*a2;
    return 1;
  }
}

uint64_t TIFFWriteDirectoryTagFloatArray(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, __int32 *__src, uint8x8_t a7)
{
  unint64_t v14;
  unint64_t v15;

  if (a5 >> 30)
    TIFFWriteDirectoryTagFloatArray_cold_1();
  if (a3)
  {
    if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      TIFFSwabArrayOfLong(__src, a5, a7);
    return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 11, a5, (4 * a5), (uint64_t)__src);
  }
  else
  {
    v14 = 4 * a5;
    v15 = 8;
    if ((*(_BYTE *)(a1 + 18) & 8) == 0)
      v15 = 4;
    if (v14 > v15)
      *(_QWORD *)(a1 + 432) += v14;
    ++*a2;
    return 1;
  }
}

uint64_t TIFFWriteDirectoryTagDoubleArray(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, int8x8_t *__src)
{
  unint64_t v13;
  unint64_t v14;

  if (a5 >> 29)
    TIFFWriteDirectoryTagDoubleArray_cold_1();
  if (a3)
  {
    if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      TIFFSwabArrayOfLong8(__src, a5);
    return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 12, a5, (8 * a5), (uint64_t)__src);
  }
  else
  {
    v13 = 8 * a5;
    v14 = 8;
    if ((*(_BYTE *)(a1 + 18) & 8) == 0)
      v14 = 4;
    if (v13 > v14)
      *(_QWORD *)(a1 + 432) += v13;
    ++*a2;
    return 1;
  }
}

uint64_t TIFFWriteDirectoryTagCheckedShort(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, __int16 a5)
{
  __int16 __src;

  if (a3)
  {
    __src = a5;
    if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      TIFFSwabShort(&__src);
    return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 3, 1, 2, (uint64_t)&__src);
  }
  else
  {
    ++*a2;
    return 1;
  }
}

uint64_t TIFFWriteDirectoryTagCheckedLong(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, __int32 a5, uint8x8_t a6)
{
  __int32 __src;

  if (a3)
  {
    __src = a5;
    if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      TIFFSwabLong(&__src, a6);
    return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 4, 1, 4, (uint64_t)&__src);
  }
  else
  {
    ++*a2;
    return 1;
  }
}

uint64_t TIFFWriteDirectoryTagData(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t __n, uint64_t __src)
{
  unsigned int v9;
  uint64_t v12;
  uint64_t v13;
  unsigned __int16 *v14;
  unsigned int v15;
  BOOL v16;
  unsigned __int16 *v17;
  unsigned __int16 *v18;
  __int128 v19;
  __int128 v20;
  int8x8_t *v21;
  int8x8_t *v22;
  int v23;
  unsigned int v24;
  unint64_t v25;
  unint64_t v26;
  char *v28;
  size_t v29;
  int8x8_t *v30;
  __int32 *v31;
  uint8x8_t v33;
  int v34;
  char v35;
  __int32 v36;

  v9 = __n;
  v12 = *a2;
  if ((_DWORD)v12)
  {
    v13 = 0;
    v14 = a3;
    while (1)
    {
      v15 = *v14;
      v14 += 16;
      v16 = v15 > a4;
      if (v15 == (_DWORD)a4)
        TIFFWriteDirectoryTagData_cold_1();
      if (v16)
        break;
      if (v12 == ++v13)
      {
        LODWORD(v13) = *a2;
        goto LABEL_11;
      }
    }
    if (v12 > v13)
    {
      v17 = &a3[16 * v12];
      v18 = &a3[16 * (v12 - 1)];
      do
      {
        v19 = *(_OWORD *)v18;
        v20 = *((_OWORD *)v18 + 1);
        v18 -= 16;
        *(_OWORD *)v17 = v19;
        *((_OWORD *)v17 + 1) = v20;
        v17 -= 16;
        LODWORD(v12) = v12 - 1;
      }
      while (v12 > v13);
    }
  }
  else
  {
    LODWORD(v13) = 0;
  }
LABEL_11:
  v21 = (int8x8_t *)&a3[16 * v13];
  v21->i16[0] = a4;
  v21->i16[1] = a5;
  v21[1] = (int8x8_t)a6;
  v21[2] = 0;
  v22 = v21 + 2;
  v23 = *(_DWORD *)(a1 + 16);
  if ((v23 & 0x80000) != 0)
    v24 = 8;
  else
    v24 = 4;
  if (v24 >= __n)
  {
    if (!(_DWORD)__n || !__src)
      goto LABEL_27;
    v29 = __n;
    v30 = v22;
    v31 = (__int32 *)__src;
LABEL_26:
    _TIFFmemcpy(v30, v31, v29);
LABEL_27:
    ++*a2;
    return 1;
  }
  v25 = *(_QWORD *)(a1 + 904);
  if ((v23 & 0x80000) != 0)
    v26 = v25 + __n;
  else
    v26 = (v25 + __n);
  if (v26 >= v25 && v26 >= __n)
  {
    if (!_TIFFSeekOK(a1, *(_QWORD *)(a1 + 904)))
      goto LABEL_35;
    if ((v9 & 0x80000000) != 0)
    {
      v28 = "libtiff does not allow writing more than 2147483647 bytes in a tag";
      goto LABEL_37;
    }
    if ((*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(a1 + 1216))(*(_QWORD *)(a1 + 1200), __src, v9) != v9)
    {
LABEL_35:
      v28 = "IO error writing tag data";
      goto LABEL_37;
    }
    *(_QWORD *)(a1 + 904) = (v26 & 1) + v26;
    v34 = *(_DWORD *)(a1 + 16);
    if ((v34 & 0x80000) != 0)
    {
      *v22 = (int8x8_t)v25;
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
        TIFFSwabLong8(v22);
      goto LABEL_27;
    }
    v36 = v25;
    if ((v34 & 0x80) != 0)
      TIFFSwabLong(&v36, v33);
    v31 = &v36;
    v30 = v22;
    v29 = 4;
    goto LABEL_26;
  }
  v28 = "Maximum TIFF file size exceeded";
LABEL_37:
  TIFFErrorExtR(a1, "TIFFWriteDirectoryTagData", v28, a4, a5, a6, __n, __src, v35);
  return 0;
}

_DWORD *DoubleToRational(_DWORD *result, int *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10)
{
  _DWORD *v11;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  double v22;
  double v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;

  v11 = result;
  if (a3 < 0.0)
  {
    *a2 = 0;
    *result = 0;
    return (_DWORD *)TIFFErrorExt(0, "TIFFLib: DoubleToRational()", " Negative Value for Unsigned Rational given.", a5, a6, a7, a8, a9, a10);
  }
  if (a3 > 4294967300.0)
  {
    *result = -1;
    *a2 = 0;
    return result;
  }
  if ((double)a3 == a3)
  {
    *result = a3;
    v13 = 1;
LABEL_9:
    *a2 = v13;
    return result;
  }
  if (a3 < 2.32830644e-10)
  {
    *result = 0;
    v13 = -1;
    goto LABEL_9;
  }
  v26 = 0;
  v27 = 0;
  v24 = 0;
  v25 = 0;
  ToRationalEuclideanGCD(0, 0, &v27, &v26, a3);
  result = (_DWORD *)ToRationalEuclideanGCD(0, 1, &v25, &v24, a3);
  v19 = v26;
  v20 = v27;
  v21 = v24;
  if (HIDWORD(v27) || HIDWORD(v26) || HIDWORD(v25) || HIDWORD(v24))
  {
    TIFFErrorExt(0, "TIFFLib: DoubleToRational()", " Num or Denom exceeds ULONG: val=%14.6f, num=%12llu, denom=%12llu | num2=%12llu, denom2=%12llu", v14, v15, v16, v17, v18, SLOBYTE(a3));
    __assert_rtn("DoubleToRational", "tif_dirwrite.c", 2811, "0");
  }
  v22 = vabdd_f64(a3, (double)v27 / (double)v26);
  v23 = vabdd_f64(a3, (double)v25 / (double)v24);
  if (v22 >= v23)
    v20 = v25;
  *v11 = v20;
  if (v22 >= v23)
    v19 = v21;
  *a2 = v19;
  return result;
}

unint64_t ToRationalEuclideanGCD(int a1, int a2, unint64_t *a3, unint64_t *a4, double a5)
{
  unint64_t v5;
  double v6;
  unint64_t v7;
  double v8;
  unint64_t v10;
  double v11;
  unsigned int v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t result;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;

  v5 = 0x3FFFFFFFFFFFFFFFLL;
  if (a2)
    v5 = 0x3FFFFFFFLL;
  v6 = (double)v5;
  v7 = 0x7FFFFFFFLL;
  if (!a1)
    v7 = 0xFFFFFFFFLL;
  v8 = floor(a5);
  if (v6 <= a5 || v8 == a5)
  {
    v10 = 1;
  }
  else
  {
    v10 = 1;
    do
    {
      v10 *= 2;
      a5 = a5 + a5;
      v11 = floor(a5);
    }
    while (a5 < v6 && a5 != v11 && v10 < v5);
  }
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = (unint64_t)a5;
  v18 = 1;
  v19 = 1;
  while (1)
  {
    result = v10;
    v21 = v17 / v10;
    v22 = v18 + v21 * v15;
    if (v22 >= v7)
      break;
    v23 = v16 + v21 * v19;
    if (v14 <= 0x3E)
    {
      v10 = v17 - v21 * result;
      ++v14;
      v17 = result;
      v18 = v15;
      v15 = v22;
      v16 = v19;
      v19 = v23;
      if (v10)
        continue;
    }
    goto LABEL_27;
  }
  v24 = (v7 - v18) / v15;
  if (v21 <= 2 * v24)
  {
    v22 = v18 + v24 * v15;
    v23 = v16 + v24 * v19;
  }
  else
  {
    v23 = v19;
    v22 = v15;
  }
LABEL_27:
  while (v23 > v7 || v22 > v7)
  {
    v23 >>= 1;
    v22 >>= 1;
  }
  *a3 = v23;
  *a4 = v22;
  return result;
}

uint64_t TIFFWriteDirectoryTagCheckedShortArray(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t __src)
{
  unint64_t v13;
  unint64_t v14;

  if ((a5 & 0x80000000) != 0)
    TIFFWriteDirectoryTagCheckedShortArray_cold_1();
  if (a3)
  {
    if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      TIFFSwabArrayOfShort(__src, a5);
    return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 3, a5, (2 * a5), __src);
  }
  else
  {
    v13 = 2 * a5;
    v14 = 8;
    if ((*(_BYTE *)(a1 + 18) & 8) == 0)
      v14 = 4;
    if (v13 > v14)
      *(_QWORD *)(a1 + 432) += v13;
    ++*a2;
    return 1;
  }
}

uint64_t TIFFWriteDirectoryTagCheckedLong8Array(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, int8x8_t *__src, uint64_t a7, uint64_t a8)
{
  int v9;
  char v16;

  if (a5 >> 29)
    TIFFWriteDirectoryTagCheckedLong8Array_cold_1();
  v9 = *(_DWORD *)(a1 + 16);
  if ((v9 & 0x80000) != 0)
  {
    if (a3)
    {
      if ((v9 & 0x80) != 0)
        TIFFSwabArrayOfLong8(__src, a5);
      return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 16, a5, (8 * a5), (uint64_t)__src);
    }
    else
    {
      if (a5 >= 2)
        *(_QWORD *)(a1 + 432) += 8 * a5;
      ++*a2;
      return 1;
    }
  }
  else
  {
    TIFFErrorExtR(a1, "TIFFWriteDirectoryTagCheckedLong8Array", "LONG8 not allowed for ClassicTIFF", a4, a5, (uint64_t)__src, a7, a8, v16);
    return 0;
  }
}

uint64_t TIFFWriteDirectoryTagCheckedLongArray(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, __int32 *__src, uint8x8_t a7)
{
  unint64_t v14;
  unint64_t v15;

  if (a5 >> 30)
    TIFFWriteDirectoryTagCheckedLongArray_cold_1();
  if (a3)
  {
    if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      TIFFSwabArrayOfLong(__src, a5, a7);
    return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 4, a5, (4 * a5), (uint64_t)__src);
  }
  else
  {
    v14 = 4 * a5;
    v15 = 8;
    if ((*(_BYTE *)(a1 + 18) & 8) == 0)
      v15 = 4;
    if (v14 > v15)
      *(_QWORD *)(a1 + 432) += v14;
    ++*a2;
    return 1;
  }
}

uint64_t TIFFWriteDirectoryTagCheckedIfdArray(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, __int32 *__src, uint8x8_t a7)
{
  unint64_t v14;
  unint64_t v15;

  if (a5 >> 30)
    TIFFWriteDirectoryTagCheckedIfdArray_cold_1();
  if (a3)
  {
    if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      TIFFSwabArrayOfLong(__src, a5, a7);
    return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 13, a5, (4 * a5), (uint64_t)__src);
  }
  else
  {
    v14 = 4 * a5;
    v15 = 8;
    if ((*(_BYTE *)(a1 + 18) & 8) == 0)
      v15 = 4;
    if (v14 > v15)
      *(_QWORD *)(a1 + 432) += v14;
    ++*a2;
    return 1;
  }
}

uint64_t TIFFWriteDirectoryTagCheckedIfd8Array(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, int8x8_t *__src)
{
  int v7;

  if (a5 >> 29)
    TIFFWriteDirectoryTagCheckedIfd8Array_cold_1();
  v7 = *(_DWORD *)(a1 + 16);
  if ((v7 & 0x80000) == 0)
    TIFFWriteDirectoryTagCheckedIfd8Array_cold_2();
  if (a3)
  {
    if ((v7 & 0x80) != 0)
      TIFFSwabArrayOfLong8(__src, a5);
    return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 18, a5, (8 * a5), (uint64_t)__src);
  }
  else
  {
    if (a5 >= 2)
      *(_QWORD *)(a1 + 432) += 8 * a5;
    ++*a2;
    return 1;
  }
}

uint64_t TIFFWriteDirectoryTagCheckedSlongArray(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, __int32 *__src, uint8x8_t a7)
{
  unint64_t v14;
  unint64_t v15;

  if (a5 >> 30)
    TIFFWriteDirectoryTagCheckedSlongArray_cold_1();
  if (a3)
  {
    if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      TIFFSwabArrayOfLong(__src, a5, a7);
    return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 9, a5, (4 * a5), (uint64_t)__src);
  }
  else
  {
    v14 = 4 * a5;
    v15 = 8;
    if ((*(_BYTE *)(a1 + 18) & 8) == 0)
      v15 = 4;
    if (v14 > v15)
      *(_QWORD *)(a1 + 432) += v14;
    ++*a2;
    return 1;
  }
}

uint64_t TIFFWriteDirectoryTagCheckedSlong8Array(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, int8x8_t *__src, uint64_t a7, uint64_t a8)
{
  int v9;
  char v16;

  if (a5 >> 29)
    TIFFWriteDirectoryTagCheckedSlong8Array_cold_1();
  v9 = *(_DWORD *)(a1 + 16);
  if ((v9 & 0x80000) != 0)
  {
    if (a3)
    {
      if ((v9 & 0x80) != 0)
        TIFFSwabArrayOfLong8(__src, a5);
      return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 17, a5, (8 * a5), (uint64_t)__src);
    }
    else
    {
      if (a5 >= 2)
        *(_QWORD *)(a1 + 432) += 8 * a5;
      ++*a2;
      return 1;
    }
  }
  else
  {
    TIFFErrorExtR(a1, "TIFFWriteDirectoryTagCheckedSlong8Array", "SLONG8 not allowed for ClassicTIFF", a4, a5, (uint64_t)__src, a7, a8, v16);
    return 0;
  }
}

_DWORD *DoubleToSrational(_DWORD *result, int *a2, double a3)
{
  _DWORD *v4;
  double v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  double v15;
  double v16;
  double v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;

  v4 = result;
  if (a3 >= 0.0)
    v5 = a3;
  else
    v5 = -a3;
  if (a3 >= 0.0)
    v6 = 1;
  else
    v6 = -1;
  if (v5 <= 2147483650.0)
  {
    if (v5 == (double)(int)v5)
    {
      *result = (int)(v5 * (double)v6);
      v7 = 1;
    }
    else if (v5 >= 4.65661288e-10)
    {
      v21 = 0;
      v19 = 0;
      v20 = 0;
      v18 = 0;
      ToRationalEuclideanGCD(1, 0, &v21, &v20, v5);
      result = (_DWORD *)ToRationalEuclideanGCD(1, 1, &v19, &v18, v5);
      v13 = v21;
      v7 = v20;
      v14 = v18;
      if (v21 >> 31 || v20 >> 31 || v19 >> 31 || v18 >> 31)
      {
        v17 = v5 * (double)v6;
        TIFFErrorExt(0, "TIFFLib: DoubleToSrational()", " Num or Denom exceeds LONG: val=%14.6f, num=%12llu, denom=%12llu | num2=%12llu, denom2=%12llu", v8, v9, v10, v11, v12, SLOBYTE(v17));
        __assert_rtn("DoubleToSrational", "tif_dirwrite.c", 2887, "0");
      }
      v15 = vabdd_f64(v5, (double)v21 / (double)v20);
      v16 = vabdd_f64(v5, (double)v19 / (double)v18);
      if (v15 >= v16)
        v13 = v19;
      *v4 = v6 * v13;
      if (v15 >= v16)
        v7 = v14;
    }
    else
    {
      *result = 0;
      v7 = 0x7FFFFFFF;
    }
  }
  else
  {
    v7 = 0;
    *result = 0x7FFFFFFF;
  }
  *a2 = v7;
  return result;
}

uint64_t _WriteAsType(uint64_t a1, unint64_t a2, unint64_t a3)
{
  int v3;
  uint64_t result;

  v3 = *(unsigned __int16 *)(a1 + 120);
  result = 1;
  if (v3 > 34886)
  {
    if ((v3 - 50000) < 3 || v3 == 34887 || v3 == 34925)
      return a2 >= a3 / 0xA;
  }
  else
  {
    if (v3 > 6)
    {
      if ((v3 - 7) >= 2 && v3 != 32946)
        return result;
      return a2 >= a3 / 0xA;
    }
    if (v3 == 1)
      return a2 > a3;
    if (v3 == 5)
      return a2 >= a3 / 0xA;
  }
  return result;
}

double ATXReadPlugin::ATXReadPlugin(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  double result;

  v3 = CommonASTCReadPlugin::CommonASTCReadPlugin(a1, a2, a3);
  *(_QWORD *)v3 = &off_1E1BAC560;
  result = 0.0;
  *(_OWORD *)(v3 + 488) = 0u;
  *(_OWORD *)(v3 + 504) = 0u;
  *(_OWORD *)(v3 + 520) = 0u;
  *(_OWORD *)(v3 + 536) = 0u;
  *(_OWORD *)(v3 + 552) = 0u;
  *(_OWORD *)(v3 + 568) = 0u;
  *(_OWORD *)(v3 + 584) = 0u;
  *(_OWORD *)(v3 + 600) = 0u;
  *(_OWORD *)(v3 + 616) = 0u;
  *(_QWORD *)(v3 + 632) = 0;
  return result;
}

uint64_t ATXReadPlugin::loadDataFromXPCObject(ATXReadPlugin *this, void *a2)
{
  uint64_t DataFromXPCObject;
  _OWORD *data;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  size_t length;

  DataFromXPCObject = CommonASTCReadPlugin::loadDataFromXPCObject(this, a2);
  if (!(_DWORD)DataFromXPCObject)
  {
    length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_atx", &length);
    if (length == 152)
    {
      DataFromXPCObject = 0;
      v6 = data[1];
      *(_OWORD *)((char *)this + 488) = *data;
      *(_OWORD *)((char *)this + 504) = v6;
      v7 = data[2];
      v8 = data[3];
      v9 = data[5];
      *(_OWORD *)((char *)this + 552) = data[4];
      *(_OWORD *)((char *)this + 568) = v9;
      *(_OWORD *)((char *)this + 520) = v7;
      *(_OWORD *)((char *)this + 536) = v8;
      v10 = data[6];
      v11 = data[7];
      v12 = data[8];
      *((_QWORD *)this + 79) = *((_QWORD *)data + 18);
      *(_OWORD *)((char *)this + 600) = v11;
      *(_OWORD *)((char *)this + 616) = v12;
      *(_OWORD *)((char *)this + 584) = v10;
    }
    else
    {
      DataFromXPCObject = 4294967246;
    }
    (*(void (**)(_QWORD, void *))(**((_QWORD **)this + 59) + 16))(*((_QWORD *)this + 59), a2);
  }
  return DataFromXPCObject;
}

uint64_t ATXReadPlugin::saveDataToXPCObject(ATXReadPlugin *this, void *a2)
{
  uint64_t v4;

  v4 = CommonASTCReadPlugin::saveDataToXPCObject(this, a2);
  if (!(_DWORD)v4)
  {
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_atx", (char *)this + 488, 0x98uLL);
    (*(void (**)(_QWORD, void *))(**((_QWORD **)this + 59) + 24))(*((_QWORD *)this + 59), a2);
  }
  return v4;
}

__n128 __Block_byref_object_copy__0(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;
  __int128 v4;

  *(_QWORD *)(a1 + 40) = &off_1E1BAB4D8;
  result = *(__n128 *)(a2 + 48);
  v3 = *(_OWORD *)(a2 + 64);
  v4 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 93) = *(_OWORD *)(a2 + 93);
  *(_OWORD *)(a1 + 64) = v3;
  *(_OWORD *)(a1 + 80) = v4;
  *(__n128 *)(a1 + 48) = result;
  return result;
}

void __Block_byref_object_dispose__0(uint64_t a1)
{
  IIOScanner::~IIOScanner((IIOScanner *)(a1 + 40));
}

vImage_Error ATXReadPlugin::decodeImageData(ATXReadPlugin *this, unsigned __int8 *a2)
{
  if (*((_QWORD *)this + 73) || *((_QWORD *)this + 76))
    return ATXReadPlugin::decodeImageData420f(this, a2);
  if (*((_QWORD *)this + 72))
    return ATXReadPlugin::decodeImageDataASTC(this, a2);
  return 4294967292;
}

vImage_Error ATXReadPlugin::decodeImageData420f(ATXReadPlugin *this, unsigned __int8 *a2)
{
  vImagePixelCount v4;
  vImagePixelCount v5;
  size_t v6;
  size_t v7;
  size_t v8;
  unint64_t v9;
  unint64_t v10;
  int v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  size_t BytesAtOffset;
  unsigned __int8 *v15;
  size_t v16;
  uint64_t v17;
  int8x16_t v18;
  uint64_t v19;
  int *v20;
  vImage_Error v21;
  vImage_Buffer dest;
  vImage_Buffer srcCbCr;
  vImage_Buffer srcYp;
  int v26;
  int v27;

  v4 = *((unsigned int *)this + 73);
  v5 = *((unsigned int *)this + 74);
  v6 = *((unsigned int *)this + 75);
  v27 = 197121;
  v26 = 66051;
  v7 = *((unsigned int *)this + 150);
  v8 = *((unsigned int *)this + 149);
  v9 = v7 * (unint64_t)v8;
  if ((v9 & 0xFFFFFFFF00000000) != 0)
  {
    _cg_jpeg_mem_term("decodeImageData420f", 600, "*** ERROR: lumaPlaneSize overflow [%ld * %ld]\n");
    return 4294967292;
  }
  v10 = *((unsigned int *)this + 156) * (unint64_t)*((unsigned int *)this + 155);
  if ((v10 & 0xFFFFFFFF00000000) != 0)
  {
    _cg_jpeg_mem_term("decodeImageData420f", 603, "*** ERROR: chromaPlaneSize overflow [%ld * %ld]\n");
    return 4294967292;
  }
  v11 = *((unsigned __int8 *)this + 405);
  v12 = (unsigned __int8 *)malloc_type_calloc(v7, v8, 0x67AE71A9uLL);
  if (*((_BYTE *)this + 632))
  {
    v13 = (unsigned __int8 *)malloc_type_malloc(*((unsigned int *)this + 151), 0x22EEF814uLL);
    BytesAtOffset = IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v13, *((_QWORD *)this + 73) + 8, *((unsigned int *)this + 151));
    if (BytesAtOffset == *((_DWORD *)this + 151))
    {
      IIOReadPlugin::decodeLZFSEIntoBuffer(this, v13, BytesAtOffset, v12, v9);
      goto LABEL_8;
    }
    _cg_jpeg_mem_term("decodeImageData420f", 614, "*** luma-lzfseBuffer-getBytesAtOffset failed: expected: %ld   got: %ld\n");
LABEL_30:
    v15 = 0;
    goto LABEL_32;
  }
  if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v12, *((_QWORD *)this + 73), v9) != v9)
  {
    _cg_jpeg_mem_term("decodeImageData420f", 620, "*** luma-getBytesAtOffset failed: expected: %ld   got: %ld\n");
    goto LABEL_30;
  }
  v13 = 0;
LABEL_8:
  v15 = (unsigned __int8 *)malloc_type_calloc(*((unsigned int *)this + 156), *((unsigned int *)this + 155), 0x39919F84uLL);
  if (*((_BYTE *)this + 632))
  {
    v13 = (unsigned __int8 *)reallocf(v13, *((unsigned int *)this + 157));
    v16 = IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v13, *((_QWORD *)this + 76) + 8, *((unsigned int *)this + 157));
    if (v16 == *((_DWORD *)this + 157))
    {
      IIOReadPlugin::decodeLZFSEIntoBuffer(this, v13, v16, v15, v10);
      goto LABEL_12;
    }
    _cg_jpeg_mem_term("decodeImageData420f", 632, "*** chroma-lzfseBuffer-getBytesAtOffset failed: expected: %ld   got: %ld\n");
  }
  else
  {
    if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v15, *((_QWORD *)this + 76), v10) == v10)
    {
LABEL_12:
      if (v13)
        free(v13);
      v17 = *((_QWORD *)this + 74);
      v18.i64[0] = v17;
      v18.i64[1] = HIDWORD(v17);
      *(int8x16_t *)&srcYp.height = vextq_s8(v18, v18, 8uLL);
      srcYp.rowBytes = *((unsigned int *)this + 150);
      dest.rowBytes = v6;
      srcCbCr.data = v15;
      v19 = *((_QWORD *)this + 77);
      v18.i64[0] = v19;
      v18.i64[1] = HIDWORD(v19);
      *(int8x16_t *)&srcCbCr.height = vextq_s8(v18, v18, 8uLL);
      srcCbCr.rowBytes = *((unsigned int *)this + 156);
      srcYp.data = v12;
      dest.height = v5;
      dest.width = v4;
      dest.data = a2;
      if (ATXReadPlugin::decodeImageData420f(unsigned char *,unsigned long)::YpCbCrToARGBCreate != -1)
        dispatch_once(&ATXReadPlugin::decodeImageData420f(unsigned char *,unsigned long)::YpCbCrToARGBCreate, &__block_literal_global_9);
      if (v11)
        v20 = &v27;
      else
        v20 = &v26;
      v21 = vImageConvert_420Yp8_CbCr8ToARGB8888(&srcYp, &srcCbCr, &dest, &ATXReadPlugin::decodeImageData420f(unsigned char *,unsigned long)::conversion, (const uint8_t *)v20, 0xFFu, 0);
      if (!v12)
        goto LABEL_21;
      goto LABEL_20;
    }
    _cg_jpeg_mem_term("decodeImageData420f", 638, "*** chroma-getBytesAtOffset failed: expected: %ld   got: %ld\n");
  }
LABEL_32:
  v21 = 4294967292;
  if (v12)
LABEL_20:
    free(v12);
LABEL_21:
  if (v15)
    free(v15);
  return v21;
}

uint64_t ATXReadPlugin::decodeImageDataASTC(ATXReadPlugin *this, unsigned __int8 *a2)
{
  void *v4;
  vImagePixelCount v5;
  vImagePixelCount v6;
  size_t v7;
  IIOImageReadSession *v8;
  vImage_Buffer v10;

  v4 = (void *)*((_QWORD *)this + 59);
  if (v4)
  v5 = *((unsigned int *)this + 65);
  v6 = *((unsigned int *)this + 66);
  v7 = *((unsigned int *)this + 75);
  v10.data = a2;
  v10.height = v6;
  v10.width = v5;
  v10.rowBytes = v7;
  v8 = (IIOImageReadSession *)*((_QWORD *)this + 3);
  if (v8)
    return ASTCTextureImp::decodeASTCtoRGBX((ASTCTextureImp *)v4, v8, &v10, *((unsigned __int8 *)this + 310), *((_BYTE *)this + 405) == 0);
  else
    return 4294967292;
}

__n128 ___ZN13ATXReadPlugin19decodeImageData420fEPhm_block_invoke()
{
  vImage_Error v0;
  __n128 result;
  vImage_Error v2;
  const char *v3;
  vImage_YpCbCrToARGBMatrix matrix;
  vImage_YpCbCrPixelRange pixelRange;

  pixelRange = *(vImage_YpCbCrPixelRange *)ymmword_188210EA0;
  *(_OWORD *)&matrix.Yp = xmmword_188210EC0;
  matrix.Cb_B = 1.772;
  v0 = vImageConvert_YpCbCrToARGB_GenerateConversion(&matrix, &pixelRange, &ATXReadPlugin::decodeImageData420f(unsigned char *,unsigned long)::conversion, kvImage422YpCbYpCr8, kvImageARGB8888, 0);
  if (v0)
  {
    v2 = v0;
    v3 = IIO_vImageErrorString(v0);
    return _cg_jpeg_mem_term("decodeImageData420f_block_invoke", 675, "*** ERROR: vImageConvert_YpCbCrToARGB_GenerateConversion returned %ld (%s)\n", v2, v3);
  }
  return result;
}

vImage_Error ATXReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4)
{
  int v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  IIOImageRead **v20;
  _BOOL4 v21;
  void *BaseAddress;
  size_t Height;
  vImage_Error BlockArray;
  size_t v25;
  double v26;
  double v27;
  unint64_t v28;
  unsigned int v29;
  vImagePixelCount v30;
  size_t v31;
  const char **v32;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  double v37;
  double v38;
  vImage_Buffer dest;
  size_t v40;
  CGRect v41;
  CGRect v42;

  v40 = 0;
  if ((gIIODebugFlags & 0x20000) == 0)
    goto LABEL_26;
  v8 = *((_DWORD *)this + 51);
  v9 = v8 >> 24;
  v10 = MEMORY[0x1E0C80978];
  if (v8 < 0)
  {
    v11 = __maskrune(v9, 0x40000uLL);
    v8 = *((_DWORD *)this + 51);
  }
  else
  {
    v11 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v9 + 60) & 0x40000;
  }
  if (v11)
    v12 = (v8 >> 24);
  else
    v12 = 46;
  v13 = v8 << 8 >> 24;
  if (v8 << 8 < 0)
  {
    v14 = __maskrune(v13, 0x40000uLL);
    v8 = *((_DWORD *)this + 51);
  }
  else
  {
    v14 = *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
  }
  if (v14)
    v15 = (v8 << 8 >> 24);
  else
    v15 = 46;
  v16 = (__int16)v8 >> 8;
  if (v8 << 16 < 0)
  {
    v17 = __maskrune(v16, 0x40000uLL);
    v8 = *((_DWORD *)this + 51);
  }
  else
  {
    v17 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
  }
  if (v17)
    v18 = ((__int16)v8 >> 8);
  else
    v18 = 46;
  if ((v8 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v10 + 4 * (char)v8 + 60) & 0x40000) != 0)
      goto LABEL_22;
LABEL_24:
    v19 = 46;
    goto LABEL_25;
  }
  if (!__maskrune((char)v8, 0x40000uLL))
    goto LABEL_24;
LABEL_22:
  v19 = *((char *)this + 204);
LABEL_25:
  ImageIOLog("  '%c%c%c%c' [%s] %s\n", v12, v15, v18, v19, iioTypeStr[a3], "virtual OSStatus ATXReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  v20 = (IIOImageRead **)*((_QWORD *)this + 3);
  if (v20)
    v21 = IIOImageReadSession::mapData(v20);
  else
    v21 = 0;
  if (a3 == 3)
  {
    BlockArray = IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
    LODWORD(v28) = *((_DWORD *)this + 73);
    v27 = (double)v28;
    v29 = *((_DWORD *)this + 74);
    v26 = (double)v29;
    v25 = *((unsigned int *)this + 75) * (unint64_t)v29;
    BaseAddress = (void *)_ImageIO_Malloc(v25, *((_QWORD *)this + 48), &v40, (uint64_t)kImageMalloc_ATX_Data[0], *((_DWORD *)this + 108), 0, 0);
  }
  else
  {
    if (a3 != 1 || !a4 || !*a4)
      goto LABEL_51;
    IOSurfaceLock(*a4, 0, 0);
    BaseAddress = IOSurfaceGetBaseAddress(*a4);
    Height = IOSurfaceGetHeight(*a4);
    BlockArray = 0;
    v25 = IOSurfaceGetBytesPerRow(*a4) * Height;
    v40 = v25;
    v26 = 0.0;
    v27 = 0.0;
  }
  if (!BaseAddress)
    goto LABEL_52;
  memset(BaseAddress, 255, v25);
  if (*((_QWORD *)this + 73) || *((_QWORD *)this + 76))
  {
    BlockArray = ATXReadPlugin::decodeImageData420f(this, (unsigned __int8 *)BaseAddress);
    goto LABEL_39;
  }
  if (!*((_QWORD *)this + 72))
  {
LABEL_39:
    if ((_DWORD)BlockArray)
      goto LABEL_40;
    goto LABEL_49;
  }
  BlockArray = ATXReadPlugin::decodeImageDataASTC(this, (unsigned __int8 *)BaseAddress);
  if ((_DWORD)BlockArray)
  {
LABEL_40:
    *((_DWORD *)this + 26) = 0;
    if (a3 == 3)
    {
      _ImageIO_Free((unint64_t)BaseAddress, v40);
      if (!v21)
        return BlockArray;
      goto LABEL_53;
    }
LABEL_52:
    if (!v21)
      return BlockArray;
    goto LABEL_53;
  }
  if (*((_WORD *)this + 153) == 32 && *((_WORD *)this + 152) == 8 && *((_BYTE *)this + 406) == 1)
  {
    v30 = *((unsigned int *)this + 74);
    dest.data = BaseAddress;
    dest.height = v30;
    v31 = *((unsigned int *)this + 75);
    dest.width = *((unsigned int *)this + 73);
    dest.rowBytes = v31;
    vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
  }
LABEL_49:
  if (a3 != 3)
  {
    IOSurfaceUnlock(*a4, 0, 0);
LABEL_51:
    BlockArray = 0;
    goto LABEL_52;
  }
  v34 = 0;
  v41.origin.x = 0.0;
  v41.origin.y = 0.0;
  v41.size.width = v27;
  v41.size.height = v26;
  **((_QWORD **)this + 12) = IIOReadPlugin::createImageBlock(this, BaseAddress, v25, v41, *((unsigned int *)this + 75), *((unsigned __int8 *)this + 343));
  if (CGRectEqualToRect(*(CGRect *)((char *)this + 120), *MEMORY[0x1E0C9D628]))
  {
    v35 = 0;
  }
  else
  {
    v42.origin.x = 0.0;
    v42.origin.y = 0.0;
    v42.size.width = v27;
    v42.size.height = v26;
    *(CGRect *)(&v35 - 1) = CGRectUnion(*(CGRect *)((char *)this + 120), v42);
    v34 = v36;
    v27 = v37;
    v26 = v38;
  }
  BlockArray = 0;
  *((_QWORD *)this + 15) = v34;
  *((_QWORD *)this + 16) = v35;
  *((double *)this + 17) = v27;
  *((double *)this + 18) = v26;
  if (v21)
  {
LABEL_53:
    v32 = (const char **)*((_QWORD *)this + 3);
    if (v32)
      IIOImageReadSession::unmapData(v32);
  }
  return BlockArray;
}

void setByteArray(_QWORD *a1, char **a2, const void *a3, int64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;

  v13 = *a2;
  if (v13)
  {
    _TIFFfreeExt((uint64_t)a1, v13);
    *a2 = 0;
  }
  if (a3)
  {
    v20 = _TIFFMultiplySSize(0, a4, a5, 0, a5, a6, a7, a8);
    if (v20)
    {
      v21 = (char *)_TIFFmallocExt(a1, v20, v14, v15, v16, v17, v18, v19);
      *a2 = v21;
      if (!v21)
        return;
      goto LABEL_6;
    }
    v21 = *a2;
    if (*a2)
LABEL_6:
      _TIFFmemcpy(v21, a3, v20);
  }
}

void _TIFFsetByteArrayExt(_QWORD *a1, char **a2, const void *a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  setByteArray(a1, a2, a3, a4, 1, a6, a7, a8);
}

void _TIFFsetShortArrayExt(_QWORD *a1, char **a2, const void *a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  setByteArray(a1, a2, a3, a4, 2, a6, a7, a8);
}

uint64_t TIFFCreateDirectory(uint64_t a1)
{
  _cg_TIFFFreeDirectory(a1);
  TIFFDefaultDirectory(a1);
  *(_QWORD *)(a1 + 888) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 876) = -1;
  *(_DWORD *)(a1 + 884) = -1;
  return 0;
}

uint64_t TIFFAdvanceDirectory(uint64_t a1, uint64_t *a2, _QWORD *a3, unsigned int *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint8x8_t v20;
  uint64_t v21;
  uint64_t result;
  unint64_t v23;
  unint64_t v24;
  __n128 v25;
  unint64_t v26;
  char *v27;
  unint64_t v28;
  uint8x8_t v29;
  uint64_t v30;
  unint64_t v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  const char *v38;
  int8x8_t v39;
  unsigned __int16 __dst;

  if (!_TIFFCheckDirNumberAndOffset(a1, *a4, *a2))
  {
    TIFFErrorExtR(a1, "TIFFAdvanceDirectory", "Starting directory %u at offset 0x%llx (%llu) might cause an IFD loop", v8, v9, v10, v11, v12, *a4);
    result = 0;
    *a2 = 0;
    *a4 = 0;
    return result;
  }
  v13 = *(_DWORD *)(a1 + 16);
  if ((v13 & 0x800) == 0)
  {
    if ((v13 & 0x80000) == 0)
    {
      __dst = 0;
      v39.i32[0] = 0;
      if (_TIFFSeekOK(a1, *a2)
        && (*(uint64_t (**)(_QWORD, unsigned __int16 *, uint64_t))(a1 + 1208))(*(_QWORD *)(a1 + 1200), &__dst, 2) == 2)
      {
        if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
          TIFFSwabShort(&__dst);
        v14 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(a1 + 1224))(*(_QWORD *)(a1 + 1200), 12 * __dst, 1);
        if (a3)
          *a3 = v14;
        if ((*(uint64_t (**)(_QWORD, int8x8_t *, uint64_t))(a1 + 1208))(*(_QWORD *)(a1 + 1200), &v39, 4) == 4)
        {
          if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
            TIFFSwabLong((__int32 *)&v39, v20);
          v21 = v39.u32[0];
          *a2 = v39.u32[0];
          goto LABEL_59;
        }
        goto LABEL_49;
      }
      goto LABEL_30;
    }
    v39 = 0;
    if (!_TIFFSeekOK(a1, *a2)
      || (*(uint64_t (**)(_QWORD, int8x8_t *, uint64_t))(a1 + 1208))(*(_QWORD *)(a1 + 1200), &v39, 8) != 8)
    {
      goto LABEL_30;
    }
    if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      v25.n128_u64[0] = (unint64_t)TIFFSwabLong8(&v39);
    if (*(_QWORD *)&v39 >= 0x10000uLL)
    {
LABEL_30:
      v38 = "/Library/Caches/com.apple.xbs/Sources/ImageIO/FileFormats/libTIFF/tif_dir.c";
      v27 = "%s:%d: %s: Error fetching directory count";
LABEL_31:
      TIFFErrorExtR(a1, "TIFFAdvanceDirectory", v27, v8, v9, v10, v11, v12, (char)v38);
      return 0;
    }
    v30 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, __n128))(a1 + 1224))(*(_QWORD *)(a1 + 1200), 20 * *(_QWORD *)&v39, 1, v25);
    if (a3)
      *a3 = v30;
    if ((*(uint64_t (**)(_QWORD, uint64_t *, uint64_t))(a1 + 1208))(*(_QWORD *)(a1 + 1200), a2, 8) != 8)
    {
LABEL_49:
      TIFFErrorExtR(a1, "TIFFAdvanceDirectory", "%s: Error fetching directory link", v15, v16, v17, v18, v19, *(_QWORD *)a1);
      return 0;
    }
    goto LABEL_56;
  }
  v23 = *a2;
  if ((v13 & 0x80000) == 0)
  {
    __dst = 0;
    v39.i32[0] = 0;
    if (v23 > 0x7FFFFFFFFFFFFFFDLL || (v24 = v23 + 2, (int64_t)(v23 + 2) > *(_QWORD *)(a1 + 1176)))
    {
      TIFFErrorExtR(a1, "TIFFAdvanceDirectory", "%s:%d: %s: Error fetching directory count", v8, v9, v10, v11, v12, (char)"/Library/Caches/com.apple.xbs/Sources/ImageIO/FileFormats/libTIFF/tif_dir.c");
      *a2 = 0;
      return 0;
    }
    _TIFFmemcpy(&__dst, (const void *)(*(_QWORD *)(a1 + 1168) + v23), 2uLL);
    if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
      TIFFSwabShort(&__dst);
    v28 = v24 + 12 * __dst;
    if (v28 <= 0x7FFFFFFFFFFFFFFBLL && (int64_t)(v28 + 4) <= *(_QWORD *)(a1 + 1176))
    {
      if (a3)
        *a3 = v28;
      _TIFFmemcpy(&v39, (const void *)(*(_QWORD *)(a1 + 1168) + v28), 4uLL);
      if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
        TIFFSwabLong((__int32 *)&v39, v29);
      *a2 = v39.u32[0];
      goto LABEL_58;
    }
LABEL_52:
    v27 = "Error fetching directory link";
    goto LABEL_31;
  }
  v39 = 0;
  if (v23 > 0x7FFFFFFFFFFFFFF7)
    goto LABEL_30;
  v26 = v23 + 8;
  if ((int64_t)(v23 + 8) > *(_QWORD *)(a1 + 1176))
    goto LABEL_30;
  _TIFFmemcpy(&v39, (const void *)(*(_QWORD *)(a1 + 1168) + v23), 8uLL);
  if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
    TIFFSwabLong8(&v39);
  if (*(_QWORD *)&v39 >= 0x10000uLL)
  {
    v27 = "Sanity check on directory count failed";
    goto LABEL_31;
  }
  if (v26 > 0x7FFFFFFFFFFFFFF7 - 20 * *(_QWORD *)&v39)
    goto LABEL_52;
  v31 = 20 * *(_QWORD *)&v39 + v26;
  if ((int64_t)(v31 + 8) > *(_QWORD *)(a1 + 1176))
    goto LABEL_52;
  if (a3)
    *a3 = v31;
  _TIFFmemcpy(a2, (const void *)(*(_QWORD *)(a1 + 1168) + v31), 8uLL);
LABEL_56:
  if ((*(_BYTE *)(a1 + 16) & 0x80) != 0)
    TIFFSwabLong8((int8x8_t *)a2);
LABEL_58:
  v21 = *a2;
LABEL_59:
  if (v21)
  {
    v32 = *a4 + 1;
    *a4 = v32;
    if (!_TIFFCheckDirNumberAndOffset(a1, v32, v21))
    {
      TIFFWarningExtR(a1, "TIFFAdvanceDirectory", "the next directory %u at offset 0x%llx (%llu) might be an IFD loop. Treating directory %d as last directory", v33, v34, v35, v36, v37, *a4);
      *a2 = 0;
      --*a4;
    }
  }
  return 1;
}

uint64_t _cg_TIFFSetDirectory(uint64_t a1, unsigned int a2)
{
  unsigned int v4;
  uint64_t v5;
  int v6;
  BOOL v7;
  unsigned int v8;
  uint64_t result;
  BOOL v10;
  unsigned int v11;
  uint64_t v12;

  v12 = 0;
  v11 = 0;
  if (!*(_DWORD *)(a1 + 64) || (_TIFFCleanupIFDOffsetAndNumberMaps(a1), !*(_DWORD *)(a1 + 64)))
  {
    if (_TIFFGetOffsetFromDirNumber(a1, a2, &v12))
    {
      *(_QWORD *)(a1 + 32) = v12;
      *(_DWORD *)(a1 + 64) = 0;
LABEL_26:
      *(_DWORD *)(a1 + 880) = a2 - 1;
      return _cg_TIFFReadDirectory(a1);
    }
  }
  v4 = *(_DWORD *)(a1 + 880);
  if (a2 >= v4 && (v5 = *(_QWORD *)(a1 + 24)) != 0 && !*(_DWORD *)(a1 + 64))
  {
    v12 = *(_QWORD *)(a1 + 24);
    v11 = v4;
    v6 = 1;
    a2 -= v4;
  }
  else
  {
    v6 = 0;
    if ((*(_BYTE *)(a1 + 18) & 8) != 0)
      v5 = *(_QWORD *)(a1 + 864);
    else
      v5 = *(unsigned int *)(a1 + 860);
    v12 = v5;
  }
  *(_DWORD *)(a1 + 64) = 0;
  v7 = a2 != 0;
  if (a2 && v5)
  {
    v8 = a2 - 1;
    while (1)
    {
      result = TIFFAdvanceDirectory(a1, &v12, 0, &v11);
      if (!(_DWORD)result)
        break;
      v5 = v12;
      v10 = v8-- != 0;
      v7 = v10;
      if (!v10 || !v12)
        goto LABEL_22;
    }
  }
  else
  {
LABEL_22:
    result = 0;
    if (!v7 && v5)
    {
      *(_QWORD *)(a1 + 32) = v5;
      if (v6)
        a2 += *(_DWORD *)(a1 + 880);
      goto LABEL_26;
    }
  }
  return result;
}

char *setDoubleArrayOneValue(_QWORD *a1, char **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9)
{
  uint64_t v9;
  char *v13;
  char *result;

  v9 = a3;
  v13 = *a2;
  if (v13)
    _TIFFfreeExt((uint64_t)a1, v13);
  result = (char *)_TIFFmallocExt(a1, 8 * v9, a3, a4, a5, a6, a7, a8);
  *a2 = result;
  if (result && v9)
  {
    do
      *(double *)&result[8 * v9-- - 8] = a9;
    while (v9);
  }
  return result;
}

uint64_t setExtraSamples(uint64_t a1, unsigned __int16 *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  const void *v9;
  uint64_t v13;
  _WORD *v14;
  unsigned int v15;
  int v16;
  char v18;

  v8 = *a2;
  *a3 = v8;
  if (v8 > *(unsigned __int16 *)(a1 + 130))
    return 0;
  v9 = (const void *)*((_QWORD *)a2 + 1);
  if ((_DWORD)v8 && v9 == 0)
    return 0;
  if ((_DWORD)v8)
  {
    v13 = v8;
    v14 = (_WORD *)*((_QWORD *)a2 + 1);
    do
    {
      v15 = (unsigned __int16)*v14;
      if (v15 >= 3)
      {
        if (v15 != 999)
          return 0;
        *v14 = 2;
      }
      ++v14;
      --v13;
    }
    while (v13);
  }
  if (*(_QWORD *)(a1 + 344))
  {
    v16 = *(unsigned __int16 *)(a1 + 130);
    if ((v16 - v8) >= 2 && v16 - *(unsigned __int16 *)(a1 + 212) <= 1)
    {
      TIFFWarningExtR(a1, "setExtraSamples", "ExtraSamples tag value is changing, but TransferFunction was read with a different value. Canceling it", a4, a5, a6, a7, a8, v18);
      *(_DWORD *)(a1 + 76) &= ~0x1000u;
      _TIFFfreeExt(a1, *(char **)(a1 + 344));
      *(_QWORD *)(a1 + 344) = 0;
      LODWORD(v8) = *(unsigned __int16 *)a3;
    }
  }
  *(_WORD *)(a1 + 212) = v8;
  setByteArray((_QWORD *)a1, (char **)(a1 + 216), v9, v8, 2, a6, a7, a8);
  return 1;
}

uint64_t countInkNamesString(_QWORD *a1, unsigned int a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned __int16 v8;
  unint64_t v9;
  unint64_t v10;

  v8 = 0;
  if (a2)
  {
    v9 = a3 + a2;
    while (a3 < v9)
    {
      v10 = v9 - a3++;
      while (*(_BYTE *)(a3 - 1))
      {
        ++a3;
        if (!--v10)
          goto LABEL_10;
      }
      ++v8;
      if (a3 >= v9)
        return v8;
    }
  }
LABEL_10:
  TIFFErrorExtR((uint64_t)a1, "TIFFSetField", "%s: Invalid InkNames value; no null at given buffer end location %u, after %hu ink",
    a4,
    a5,
    a6,
    a7,
    a8,
    *a1);
  return 0;
}

uint64_t IIO_Reader_ICNS::createReadPlugin(IIO_Reader *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;

  v4 = operator new();
  v5 = IIO_Reader::osType(a1);
  ICNSReadPlugin::ICNSReadPlugin(v4, a2, v5);
  return v4;
}

void sub_187FC0D44(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C407866354DLL);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_ICNS::createReadPlugin(IIO_Reader *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8;
  int v9;

  v8 = operator new();
  v9 = IIO_Reader::osType(a1);
  ICNSReadPlugin::ICNSReadPlugin(v8, a2, a3, a4, v9);
  return v8;
}

void sub_187FC0DE0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C407866354DLL);
  _Unwind_Resume(a1);
}

IIOImageRead *IIO_Reader_ICNS::createGlobalInfoData(IIO_Reader_ICNS *this, IIOImageReadSession *a2)
{
  IIOImageRead *result;

  result = IIOImageReadSession::globalInfoForType(a2, 1229147731);
  if (result)
    return (IIOImageRead *)GlobalICNSInfo::createDataRepresentation(result);
  return result;
}

uint64_t IIO_Reader_ICNS::updateGlobalInfo(IIO_Reader_ICNS *this, IIOImageRead **a2, unsigned __int8 *a3, unint64_t a4)
{
  GlobalICNSInfo *v7;

  v7 = (GlobalICNSInfo *)operator new();
  GlobalICNSInfo::GlobalICNSInfo(v7, a3, a4);
  IIOImageReadSession::setGlobalInfo(a2, 1229147731, v7, (void (*)(void *))globalICNSInfoReleaseProc);
  return 0;
}

void sub_187FC0EA4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x20C40A759441BLL);
  _Unwind_Resume(a1);
}

GlobalICNSInfo *globalICNSInfoReleaseProc(GlobalICNSInfo *result)
{
  if (result)
  {
    GlobalICNSInfo::~GlobalICNSInfo(result);
    JUMPOUT(0x18D761C30);
  }
  return result;
}

uint64_t IIO_Reader_ICNS::updateSourceProperties(IIO_Reader_ICNS *this, IIOImageReadSession *a2, IIODictionary *a3, IIODictionary *a4, IIODictionary *a5, CGImageSourceStatus *a6)
{
  IIO_Reader_ICNS *v8;
  GlobalICNSInfo *v9;
  unsigned int i;
  int v11;
  int v12;
  int Count;
  _BYTE v15[16];
  void *v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  _QWORD v20[2];
  void *v21;
  __int128 v22;
  void *v23[2];
  __int128 v24;
  uint64_t v25;
  CFMutableArrayRef v26;
  void *value;
  uint64_t v28;
  uint64_t v29;
  const void *v30;
  uint64_t v31;
  char v32[4];
  char v33;

  v33 = 0;
  *(_DWORD *)v32 = 0;
  v8 = IIOImageReadSession::globalInfoForType(a2, 1229147731);
  v9 = v8;
  if (!v8)
  {
    v9 = (GlobalICNSInfo *)operator new();
    GlobalICNSInfo::GlobalICNSInfo(v9);
    v8 = (IIO_Reader_ICNS *)IIOImageReadSession::setGlobalInfo((IIOImageRead **)a2, 1229147731, v9, (void (*)(void *))globalICNSInfoReleaseProc);
  }
  IIO_Reader_ICNS::extractImageInfo(v8, (void **)v9, a2);
  v29 = 0;
  v30 = 0;
  v31 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v29);
  v26 = 0;
  value = 0;
  v28 = 0;
  IIOArray::IIOArray((IIOArray *)&v26);
  IIODictionary::setObjectForKey((IIODictionary *)&v29, value, CFSTR("Images"));
  for (i = 0; i < GlobalICNSInfo::icnsImageCount(v9); ++i)
  {
    v25 = 0;
    *(_OWORD *)v23 = 0u;
    v24 = 0u;
    v22 = 0u;
    GlobalICNSInfo::getICNSImageInfoAtIndex(v9, i, (uint64_t)&v22);
    *(_DWORD *)v32 = bswap32(v24);
    v20[0] = 0;
    v20[1] = 0;
    v21 = 0;
    IIOString::IIOString((IIOString *)v20, v32);
    v17 = 0;
    v18 = 0;
    v19 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v17);
    IIODictionary::setObjectForKey((IIODictionary *)&v17, v21, CFSTR("IconType"));
    IIONumber::IIONumber((IIONumber *)v15, LOWORD(v23[1]));
    IIODictionary::setObjectForKey((IIODictionary *)&v17, v16, CFSTR("PixelWidth"));
    IIONumber::~IIONumber((IIONumber *)v15);
    IIONumber::IIONumber((IIONumber *)v15, WORD1(v23[1]));
    IIODictionary::setObjectForKey((IIODictionary *)&v17, v16, CFSTR("PixelHeight"));
    IIONumber::~IIONumber((IIONumber *)v15);
    if (BYTE1(v25) == 2)
      v11 = 144;
    else
      v11 = 72;
    IIONumber::IIONumber((IIONumber *)v15, v11);
    IIODictionary::setObjectForKey((IIODictionary *)&v17, v16, CFSTR("DPIWidth"));
    IIONumber::~IIONumber((IIONumber *)v15);
    if (BYTE1(v25) == 2)
      v12 = 144;
    else
      v12 = 72;
    IIONumber::IIONumber((IIONumber *)v15, v12);
    IIODictionary::setObjectForKey((IIODictionary *)&v17, v16, CFSTR("DPIHeight"));
    IIONumber::~IIONumber((IIONumber *)v15);
    IIOArray::addObject(&v26, v18);
    IIODictionary::~IIODictionary((IIODictionary *)&v17);
    IIOString::~IIOString((IIOString *)v20);
  }
  Count = IIOArray::getCount((IIOArray *)&v26);
  IIONumber::IIONumber((IIONumber *)&v22, Count);
  IIODictionary::setObjectForKey((IIODictionary *)&v29, v23[0], CFSTR("ImageCount"));
  IIONumber::~IIONumber((IIONumber *)&v22);
  IIODictionary::setObjectForKey(a3, v30, CFSTR("{FileContents}"));
  IIOArray::~IIOArray((IIOArray *)&v26);
  IIODictionary::~IIODictionary((IIODictionary *)&v29);
  return 0;
}

void sub_187FC1198(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x20C40A759441BLL);
  _Unwind_Resume(a1);
}

__n128 IIO_Reader_ICNS::extractImageInfo(IIO_Reader_ICNS *this, void **a2, IIOImageReadSession *a3)
{
  __n128 result;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  IIO_ReaderHandler *ReaderHandler;
  IIO_Reader *v13;
  IIO_ReaderHandler *v14;
  IIO_ReaderHandler *v15;
  IIO_Reader *v16;
  __int16 *ICNSInfoTable;
  signed int v18;
  __int16 *v19;
  int v20;
  unsigned int v21;
  int v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  int v28;
  uint64_t v29;
  unsigned int v30;
  int v31;
  uint64_t v32;
  unsigned int v33;
  int v34;
  uint64_t v35;
  IIOImageRead *v36;
  unsigned int v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;
  signed int v42;
  unsigned int v43;
  _QWORD v44[3];

  v44[2] = *MEMORY[0x1E0C80C00];
  if (!GlobalICNSInfo::icnsImageCount((GlobalICNSInfo *)a2)
    && IIOImageReadSession::isFinal(a3))
  {
    v43 = 0;
    v42 = 0;
    v38 = 0u;
    v39 = 0u;
    v40 = 0u;
    v41 = 0;
    v44[0] = 0;
    v44[1] = 0;
    IIOImageReadSession::rewind((uint64_t)a3);
    v37 = 0;
    IIOImageReadSession::getBytes(a3, &v37, 4uLL);
    v6 = v37;
    v37 = bswap32(v37);
    if (v6 != 1936614249)
    {
      result = _cg_jpeg_mem_term("extractImageInfo", 194, "*** bad 'icns' - does not start with 'icns'\n");
      if (!a2)
        return result;
      goto LABEL_51;
    }
    IIOImageReadSession::skipBytes(a3, 4);
    v7 = MEMORY[0x1E0C80978];
    do
    {
      if (IIOImageReadSession::getBytes(a3, &v42, 4uLL) != 4)
        break;
      v42 = bswap32(v42);
      if (IIOImageReadSession::getBytes(a3, &v43, 4uLL) != 4)
        break;
      v8 = bswap32(v43);
      v43 = v8;
      if (v8 < 9)
        break;
      v43 = v8 - 8;
      v9 = IIO_Reader::minimumFileSize(a3);
      if (v43 >= 0x10)
      {
        if (IIOImageReadSession::getBytes(a3, v44, 0x10uLL) != 16)
          break;
        ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler((IIO_ReaderHandler *)0x10);
        v13 = IIO_ReaderHandler::readerForType(ReaderHandler, 1347307296);
        v14 = (IIO_ReaderHandler *)(*(uint64_t (**)(IIO_Reader *, _QWORD *, uint64_t, _QWORD, _QWORD))(*(_QWORD *)v13 + 16))(v13, v44, 16, 0, 0);
        if ((v14 & 1) != 0)
        {
          v11 = 2;
        }
        else
        {
          v15 = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(v14);
          v16 = IIO_ReaderHandler::readerForType(v15, 1246769696);
          v11 = (*(unsigned int (**)(IIO_Reader *, _QWORD *, uint64_t, _QWORD, _QWORD))(*(_QWORD *)v16 + 16))(v16, v44, 16, 0, 0)? 4: 1;
        }
        v10 = 16;
      }
      else
      {
        v10 = 0;
        v11 = 1;
      }
      ICNSInfoTable = (__int16 *)GetICNSInfoTable();
      v18 = v42;
      if (*ICNSInfoTable == -1)
      {
LABEL_21:
        if (v42 != 1414480672 && v42 != 1768842863)
        {
          v21 = v42 >> 24;
          if (v42 < 0)
          {
            v22 = __maskrune(v21, 0x40000uLL);
            v18 = v42;
            v21 = v42 >> 24;
          }
          else
          {
            v22 = *(_DWORD *)(v7 + 4 * v21 + 60) & 0x40000;
          }
          if (v22)
            v26 = v21;
          else
            v26 = 46;
          v27 = v18 << 8 >> 24;
          if (v18 << 8 < 0)
          {
            v28 = __maskrune(v27, 0x40000uLL);
            v18 = v42;
            v27 = v42 << 8 >> 24;
          }
          else
          {
            v28 = *(_DWORD *)(v7 + 4 * v27 + 60) & 0x40000;
          }
          if (v28)
            v29 = v27;
          else
            v29 = 46;
          v30 = (__int16)v18 >> 8;
          if (v18 << 16 < 0)
          {
            v31 = __maskrune(v30, 0x40000uLL);
            v18 = v42;
            v30 = (__int16)v42 >> 8;
          }
          else
          {
            v31 = *(_DWORD *)(v7 + 4 * v30 + 60) & 0x40000;
          }
          if (v31)
            v32 = v30;
          else
            v32 = 46;
          v33 = (char)v18;
          if ((v18 << 24) <= 0x7F000000)
          {
            v34 = *(_DWORD *)(v7 + 4 * (char)v18 + 60) & 0x40000;
          }
          else
          {
            v34 = __maskrune((char)v18, 0x40000uLL);
            v33 = (char)v42;
          }
          if (v34)
            v35 = v33;
          else
            v35 = 46;
          _cg_jpeg_mem_term("extractImageInfo", 277, "did not handle '%c%c%c%c' -- not found in ICNSInfoTable\n", v26, v29, v32, v35);
        }
      }
      else
      {
        v19 = ICNSInfoTable + 16;
        while (v42 != *(_DWORD *)v19)
        {
          v20 = v19[12];
          v19 += 28;
          if (v20 == -1)
            goto LABEL_21;
        }
        v24 = *((_OWORD *)v19 - 1);
        v23 = *(_OWORD *)v19;
        v25 = *((_QWORD *)v19 + 2);
        v38 = *((_OWORD *)v19 - 2);
        *((_QWORD *)&v39 + 1) = *((_QWORD *)&v24 + 1);
        v41 = v25;
        v40 = v23;
        *((_QWORD *)&v38 + 1) = v9;
        *(_QWORD *)&v39 = v43;
        BYTE2(v41) = v11;
        GlobalICNSInfo::addICNSInfo(a2, (__int16 *)&v38);
      }
      v36 = IIOImageReadSession::skipBytes(a3, v43 - v10);
    }
    while (v36 == (IIOImageRead *)(v43 - v10));
    if (a2)
LABEL_51:
      GlobalICNSInfo::sortInfo(a2);
  }
  return result;
}

uint64_t IIO_Reader_ICNS::getImageCount(IIO_Reader_ICNS *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  IIO_Reader_ICNS *v7;
  GlobalICNSInfo *v8;
  unsigned int v9;

  v7 = IIOImageReadSession::globalInfoForType(a2, 1229147731);
  v8 = v7;
  if (!v7)
  {
    v8 = (GlobalICNSInfo *)operator new();
    GlobalICNSInfo::GlobalICNSInfo(v8);
    v7 = (IIO_Reader_ICNS *)IIOImageReadSession::setGlobalInfo((IIOImageRead **)a2, 1229147731, v8, (void (*)(void *))globalICNSInfoReleaseProc);
  }
  IIO_Reader_ICNS::extractImageInfo(v7, (void **)v8, a2);
  v9 = GlobalICNSInfo::icnsImageCount(v8);
  if (a5)
    *a5 = v9;
  return 0;
}

void sub_187FC16B4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x20C40A759441BLL);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_ICNS::hasCustomImageCountProc(IIO_Reader_ICNS *this)
{
  return 1;
}

uint64_t IIO_Reader_ICNS::hasCustomSourcePropertiesProc(IIO_Reader_ICNS *this)
{
  return 1;
}

uint64_t GetSizeForTiffType(uint64_t result)
{
  result = result;
  switch((int)result)
  {
    case 0:
      return result;
    case 1:
    case 2:
    case 6:
    case 7:
      return 1;
    case 3:
    case 8:
      return 2;
    case 4:
    case 9:
    case 11:
    case 13:
      return 4;
    case 5:
    case 10:
    case 12:
    case 16:
    case 17:
    case 18:
      return 8;
    case 14:
    case 15:
      goto LABEL_7;
    default:
      if ((_DWORD)result == 32775)
        return 8;
LABEL_7:
      _cg_jpeg_mem_term("GetSizeForTiffType", 145, "*** ERROR: tag with unknown type [%d]\n", result);
      return 0;
  }
}

void ReadExifVers(uint64_t a1, uint64_t a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, uint64_t a7)
{
  CFStringRef v12;
  CFStringRef v13;
  CGImageMetadataTagRef v14;
  char cStr[4];
  char v16;

  v16 = 0;
  if (*(_DWORD *)(a7 + 4) == 4)
  {
    *(_DWORD *)cStr = *(_DWORD *)(a7 + 8);
    v12 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], cStr, 0x600u);
    if (v12)
    {
      v13 = v12;
      v14 = CGImageMetadataTagCreate(a3, a4, a5, kCGImageMetadataTypeString, v12);
      CFRelease(v13);
      if (v14)
      {
        CGImageMetadataAddTagWithKey(a1, a6, v14);
        CFRelease(v14);
      }
    }
  }
}

void ReadGPSVers(uint64_t a1, uint64_t a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, unsigned __int8 *a7)
{
  CFStringRef v12;
  CFStringRef v13;
  CGImageMetadataTagRef v14;

  v12 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%d.%d.%d.%d"), a7[8], a7[9], a7[10], a7[11]);
  if (v12)
  {
    v13 = v12;
    v14 = CGImageMetadataTagCreate(a3, a4, a5, kCGImageMetadataTypeString, v12);
    CFRelease(v13);
    if (v14)
    {
      CGImageMetadataAddTagWithKey(a1, a6, v14);
      CFRelease(v14);
    }
  }
}

void ReadGPSCoords(uint64_t a1, IIOImageReadSession *this, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v15;
  uint64_t v16;
  double v17;
  uint64_t i;
  double v19;
  double v20;
  double v21;
  uint64_t v22;
  double v23;
  BOOL v24;
  double v25;
  CFStringRef v26;
  CFStringRef v27;
  CGImageMetadataTagRef v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v15 = *(unsigned int *)(a7 + 8);
  if (a9)
  {
    v16 = bswap32(v15);
    *(_DWORD *)(a7 + 8) = v16;
    if (IIOImageReadSession::getBytesAtOffset(this, &v29, v16 + a8, 0x18uLL) != 24)
      return;
    for (i = 0; i != 24; i += 4)
      *(_DWORD *)((char *)&v29 + i) = bswap32(*(_DWORD *)((char *)&v29 + i));
  }
  else if (IIOImageReadSession::getBytesAtOffset(this, &v29, v15 + a8, 0x18uLL) != 24)
  {
    return;
  }
  if (*(_WORD *)a7 == 7)
  {
    v19 = 0.0;
    v20 = 0.0;
    if (HIDWORD(v29))
    {
      LODWORD(v20) = v29;
      v17 = (double)HIDWORD(v29);
      v20 = (double)*(unint64_t *)&v20 / (double)HIDWORD(v29);
    }
    if (HIDWORD(v30))
    {
      LODWORD(v19) = v30;
      v17 = (double)HIDWORD(v30);
      v19 = (double)*(unint64_t *)&v19 / (double)HIDWORD(v30);
    }
    if (HIDWORD(v31))
    {
      LODWORD(v17) = v31;
      v21 = (double)*(unint64_t *)&v17 / (double)HIDWORD(v31);
      if (v21 > 3600.0)
      {
        v20 = v20 + (double)(uint64_t)(v21 / 3600.0);
        v21 = v21 - (double)(3600 * (uint64_t)(v21 / 3600.0));
      }
      if (v21 > 60.0)
      {
        v22 = (uint64_t)(v21 / 60.0);
        v19 = v19 + (double)v22;
        v21 = v21 - (double)(60 * v22);
        if (v19 > 60.0)
        {
          v20 = v20 + (double)(uint64_t)(v19 / 60.0);
          v19 = v19 - (double)(60 * (uint64_t)(v19 / 60.0));
        }
      }
    }
    else
    {
      v21 = 0.0;
    }
    if (v20 > 23.0)
      v20 = v20 + -23.0;
    v26 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%.2ld:%.2ld:%05.2f"), (uint64_t)v20, (uint64_t)v19, *(_QWORD *)&v21);
  }
  else
  {
    v23 = 0.0;
    if ((_DWORD)v29)
      v24 = HIDWORD(v29) == 0;
    else
      v24 = 1;
    v25 = 0.0;
    if (!v24)
      v25 = (double)v29 / (double)HIDWORD(v29);
    if ((_DWORD)v30 && HIDWORD(v30))
      v23 = (double)v30 / (double)HIDWORD(v30);
    if ((_DWORD)v31 && HIDWORD(v31))
      v23 = v23 + (double)v31 / ((double)HIDWORD(v31) * 60.0);
    if (v25 > 180.0)
      v25 = 180.0;
    v26 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%ld,%g"), (uint64_t)v25, v23 + (v25 - (double)(uint64_t)v25) * 60.0);
  }
  v27 = v26;
  if (v26)
  {
    v28 = CGImageMetadataTagCreate(a3, a4, a5, kCGImageMetadataTypeString, v26);
    CFRelease(v27);
    if (v28)
    {
      CGImageMetadataAddTagWithKey(a1, a6, v28);
      CFRelease(v28);
    }
  }
}

void ReadUserComment(uint64_t a1, IIOImageReadSession *this, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, uint64_t a7, uint64_t a8, char a9)
{
  IIOImageRead *Size;
  size_t v18;
  _BYTE *v19;
  unsigned int v20;
  CFTypeRef *v21;
  CGImageMetadataTagRef v22;
  CGImageMetadataTagRef v23;

  if (*(_DWORD *)(a7 + 4) <= 8u)
  {
    _cg_jpeg_mem_term("ReadUserComment", 1195, "*** ERROR: tag-count: %d too small\n");
    return;
  }
  Size = IIOImageReadSession::getSize(this);
  v18 = *(unsigned int *)(a7 + 4);
  if ((unint64_t)Size <= v18)
  {
    _cg_jpeg_mem_term("ReadUserComment", 1203, "*** ERROR: tag-count too big: %d    image-size: %ld\n");
    return;
  }
  v19 = malloc_type_malloc(v18, 0x8368BCDBuLL);
  v20 = *(_DWORD *)(a7 + 8);
  if (a9)
  {
    v20 = bswap32(v20);
    *(_DWORD *)(a7 + 8) = v20;
  }
  IIOImageReadSession::getBytesAtOffset(this, v19, a8 + v20, *(unsigned int *)(a7 + 4));
  if (*(_QWORD *)v19 == *(_QWORD *)ReadUserComment(CGImageMetadata *,IIOImageReadSession *,__CFString const*,__CFString const*,__CFString const*,CGImageMetadataTagKey *,tag_entry *,unsigned long,BOOL)::asciiCode)
  {
    v21 = (CFTypeRef *)operator new();
    IIOString::IIOString(v21, 0, (*(_DWORD *)(a7 + 4) - 8), v19 + 8);
    goto LABEL_13;
  }
  if (*(_QWORD *)v19 == *(_QWORD *)ReadUserComment(CGImageMetadata *,IIOImageReadSession *,__CFString const*,__CFString const*,__CFString const*,CGImageMetadataTagKey *,tag_entry *,unsigned long,BOOL)::jisCode)
  {
    v21 = (CFTypeRef *)operator new();
    IIOString::IIOString(v21, 1, (*(_DWORD *)(a7 + 4) - 8), v19 + 8);
    goto LABEL_13;
  }
  if (*(_QWORD *)v19 == *(_QWORD *)ReadUserComment(CGImageMetadata *,IIOImageReadSession *,__CFString const*,__CFString const*,__CFString const*,CGImageMetadataTagKey *,tag_entry *,unsigned long,BOOL)::uniCode)
  {
    v21 = (CFTypeRef *)operator new();
    IIOString::IIOString(v21, 2, (*(_DWORD *)(a7 + 4) - 8), v19 + 8);
LABEL_13:
    v22 = CGImageMetadataTagCreate(a3, a4, a5, kCGImageMetadataTypeString, v21[2]);
    if (v22)
    {
      v23 = v22;
      CGImageMetadataAddTagWithKey(a1, a6, v22);
      CFRelease(v23);
    }
    (*((void (**)(CFTypeRef *))*v21 + 1))(v21);
  }
  free(v19);
}

void sub_187FC1E84(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0xF1C40AFE2EBACLL);
  _Unwind_Resume(a1);
}

void ReadComponentsConfiguration(uint64_t a1, uint64_t a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, uint64_t a7)
{
  uint64_t v12;
  uint64_t i;
  CGImageMetadataTagRef v14;
  _BYTE v15[16];
  void *v16;
  CFMutableArrayRef v17;
  CFTypeRef value;
  uint64_t v19;

  v12 = a7 + 8;
  v17 = 0;
  value = 0;
  v19 = 0;
  IIOArray::IIOArray((IIOArray *)&v17);
  for (i = 0; i != 4; ++i)
  {
    IIOString::IIOString((IIOString *)v15, 0, CFSTR("%d"), *(unsigned __int8 *)(v12 + i));
    IIOArray::addObject(&v17, v16);
    IIOString::~IIOString((IIOString *)v15);
  }
  v14 = CGImageMetadataTagCreate(a3, a4, a5, kCGImageMetadataTypeArrayOrdered, value);
  if (v14)
  {
    CGImageMetadataAddTagWithKey(a1, a6, v14);
    CFRelease(v14);
  }
  IIOArray::~IIOArray((IIOArray *)&v17);
}

void sub_187FC1F94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  IIOArray::~IIOArray((IIOArray *)va);
  _Unwind_Resume(a1);
}

__n128 ReadDeviceSettings(uint64_t a1, IIOImageReadSession *this, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, uint64_t a7, uint64_t a8, char a9)
{
  unint64_t v9;
  unsigned __int8 *v18;
  __n128 result;
  unsigned __int8 *v20;
  unsigned int v21;
  unint64_t BytesAtOffset;
  int Val16;
  int v24;
  const char *i;
  unsigned int Count;
  CGImageMetadataTagRef v27;
  _BYTE v28[16];
  void *v29;
  CFMutableArrayRef v30;
  CFTypeRef value;
  uint64_t v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;

  v9 = *(unsigned int *)(a7 + 4);
  if (v9 <= 4)
  {
    return _cg_jpeg_mem_term("ReadDeviceSettings", 1289, "*** tagsize (%d) too small\n");
  }
  else if ((unint64_t)IIOImageReadSession::getSize(this) <= v9)
  {
    IIOImageReadSession::getSize(this);
    return _cg_jpeg_mem_term("ReadDeviceSettings", 1290, "*** tagsize (%d) larger than filesize (%d)\n");
  }
  else
  {
    v18 = (unsigned __int8 *)malloc_type_malloc(*(unsigned int *)(a7 + 4), 0x65DDCCCAuLL);
    if (v18)
    {
      v20 = v18;
      v21 = *(_DWORD *)(a7 + 8);
      if (a9)
      {
        v21 = bswap32(v21);
        *(_DWORD *)(a7 + 8) = v21;
      }
      BytesAtOffset = IIOImageReadSession::getBytesAtOffset(this, v18, a8 + v21, *(unsigned int *)(a7 + 4));
      if (BytesAtOffset == *(_DWORD *)(a7 + 4))
      {
        v37 = 0;
        v35 = 0u;
        v36 = 0u;
        v33 = 0u;
        v34 = 0u;
        IIOScanner::IIOScanner((IIOScanner *)&v33, v20, BytesAtOffset, a9 ^ 1);
        Val16 = IIOScanner::getVal16((IIOScanner *)&v33);
        v24 = IIOScanner::getVal16((IIOScanner *)&v33);
        if ((v24 * Val16) < *(_DWORD *)(a7 + 4))
        {
          v30 = 0;
          value = 0;
          v32 = 0;
          IIOArray::IIOArray((IIOArray *)&v30);
          for (i = (const char *)IIOScanner::getString((IIOScanner *)&v33);
                i && *i >= 8;
                i = (const char *)IIOScanner::getString((IIOScanner *)&v33))
          {
            IIOString::IIOString((IIOString *)v28, i);
            IIOArray::addObject(&v30, v29);
            IIOString::~IIOString((IIOString *)v28);
            if (*((_QWORD *)&v34 + 1) < (unint64_t)*(unsigned int *)(a7 + 4)
              && !*(_BYTE *)(*((_QWORD *)&v33 + 1) + *((_QWORD *)&v34 + 1)))
            {
              IIOScanner::getVal8((IIOScanner *)&v33);
            }
          }
          if (IIOArray::getCount((IIOArray *)&v30) != v24 * Val16)
          {
            Count = IIOArray::getCount((IIOArray *)&v30);
            _cg_jpeg_mem_term("ReadDeviceSettings", 1323, "*** tag 0xA40B --> cols=%d  rows=%d   #of strings: %d\n", Val16, v24, Count);
          }
          v27 = CGImageMetadataTagCreate(a3, a4, a5, kCGImageMetadataTypeArrayOrdered, value);
          if (v27)
          {
            CGImageMetadataAddTagWithKey(a1, a6, v27);
            CFRelease(v27);
          }
          IIOArray::~IIOArray((IIOArray *)&v30);
        }
        IIOScanner::~IIOScanner((IIOScanner *)&v33);
      }
      free(v20);
    }
  }
  return result;
}

void sub_187FC2220(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v9;
  va_list va;
  uint64_t v11;
  uint64_t v12;
  va_list va1;

  va_start(va1, a8);
  va_start(va, a8);
  v9 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  IIOArray::~IIOArray((IIOArray *)va);
  IIOScanner::~IIOScanner((IIOScanner *)va1);
  _Unwind_Resume(a1);
}

void ReadSceneType(uint64_t a1, IIOImageReadSession *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, uint64_t a7, uint64_t a8, char a9)
{
  if (*(_DWORD *)(a7 + 4) == 1 && *(_WORD *)(a7 + 2) == 7)
    ReadMetadataByte(a1, a2, a3, a4, a5, a6, 0, a7, a8, a9);
}

void ReadMetadataByte(uint64_t a1, IIOImageReadSession *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, int a7, uint64_t a8, uint64_t a9, char a10)
{
  size_t v15;
  unsigned int *v17;
  unint64_t v18;
  unsigned int *v19;
  unsigned int v20;
  unint64_t BytesAtOffset;
  BOOL v22;
  const __CFAllocator **v23;
  CFMutableArrayRef Mutable;
  __CFArray *v25;
  CGImageMetadataType v26;
  unint64_t v27;
  const __CFAllocator *v28;
  CFStringRef v29;
  unint64_t v30;
  CGImageMetadataTagRef v31;
  uint64_t v32;
  const void *v33;
  const __CFString *name;

  v15 = *(unsigned int *)(a8 + 4);
  if (v15 <= 4)
  {
    v17 = 0;
    v19 = (unsigned int *)(a8 + 8);
    LODWORD(v18) = *(_DWORD *)(a8 + 4);
    goto LABEL_8;
  }
  v17 = (unsigned int *)malloc_type_calloc(v15, 1uLL, 0x6E2833ECuLL);
  v18 = *(unsigned int *)(a8 + 4);
  v19 = (unsigned int *)(a8 + 8);
  if (v18 < 5)
    goto LABEL_8;
  v20 = *v19;
  if (a10)
  {
    v20 = bswap32(v20);
    *v19 = v20;
  }
  BytesAtOffset = IIOImageReadSession::getBytesAtOffset(a2, v17, a9 + v20, v18);
  v19 = v17;
  v18 = *(unsigned int *)(a8 + 4);
  if (BytesAtOffset == v18)
  {
LABEL_8:
    v22 = v18 <= 1 && a7 == 0;
    v23 = (const __CFAllocator **)MEMORY[0x1E0C9AE00];
    if (v22)
    {
      if (!(_DWORD)v18)
        goto LABEL_29;
      v33 = a6;
      name = a5;
      v32 = a1;
      v25 = 0;
      v26 = kCGImageMetadataTypeString;
    }
    else
    {
      Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
      v25 = Mutable;
      if (!*(_DWORD *)(a8 + 4))
      {
        if (!Mutable)
          goto LABEL_29;
        v33 = a6;
        name = a5;
        v32 = a1;
        v26 = kCGImageMetadataTypeArrayOrdered;
        goto LABEL_26;
      }
      v33 = a6;
      name = a5;
      v32 = a1;
      v26 = kCGImageMetadataTypeArrayOrdered;
    }
    v27 = 0;
    v28 = *v23;
    do
    {
      v29 = CFStringCreateWithFormat(v28, 0, CFSTR("%d"), *((unsigned __int8 *)v19 + v27));
      if ((a7 & 1) != 0 || (v30 = *(unsigned int *)(a8 + 4), v30 >= 2))
      {
        CFArrayAppendValue(v25, v29);
        CFRelease(v29);
        v29 = 0;
        v30 = *(unsigned int *)(a8 + 4);
      }
      ++v27;
    }
    while (v27 < v30);
    if (!v25)
    {
      if (!v29)
        goto LABEL_29;
      v31 = CGImageMetadataTagCreate(a3, a4, name, v26, v29);
      goto LABEL_27;
    }
LABEL_26:
    v31 = CGImageMetadataTagCreate(a3, a4, name, v26, v25);
    v29 = (CFStringRef)v25;
LABEL_27:
    CFRelease(v29);
    if (v31)
    {
      CGImageMetadataAddTagWithKey(v32, v33, v31);
      CFRelease(v31);
    }
  }
LABEL_29:
  if (v17)
    free(v17);
}

void ReadArtist(_QWORD *a1, IIOImageReadSession *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, uint64_t a7, uint64_t a8, unsigned __int8 a9)
{
  const char *ASCIIString;
  char *v15;
  const __CFAllocator *v16;
  const __CFString *v17;
  const __CFString *v18;
  const __CFArray *ArrayBySeparatingStrings;
  CGImageMetadataTag *TagWithPath;
  uint64_t v21;
  const __CFArray *Value;
  const __CFArray *v23;
  CFTypeID v24;
  __CFArray *Mutable;
  CFIndex v26;
  const void *v27;
  CFIndex v28;
  const void *ValueAtIndex;
  CGImageMetadataTagRef v30;
  CGImageMetadataTagRef v31;

  if (!*(_DWORD *)(a7 + 4))
    return;
  if (*(_WORD *)(a7 + 2) != 2)
    return;
  ASCIIString = (const char *)ReadAndCreateASCIIString(a2, (unsigned __int16 *)a7, a8, a9);
  if (!ASCIIString)
    return;
  v15 = (char *)ASCIIString;
  v16 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v17 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], ASCIIString, 0x8000100u);
  if (!v17)
  {
    free(v15);
    return;
  }
  v18 = v17;
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v16, v17, CFSTR("; "));
  if (!ArrayBySeparatingStrings)
    goto LABEL_20;
  TagWithPath = (CGImageMetadataTag *)CGImageMetadataGetTagWithPath(a1, 0, CFSTR("dc:creator"));
  if (!TagWithPath
    || (v21 = (uint64_t)TagWithPath, CGImageMetadataTagGetType(TagWithPath) != kCGImageMetadataTypeArrayOrdered))
  {
    Mutable = CFArrayCreateMutable(v16, 1, MEMORY[0x1E0C9B378]);
    if (CFArrayGetCount(ArrayBySeparatingStrings) >= 1)
    {
      v28 = 0;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(ArrayBySeparatingStrings, v28);
        CFArraySetValueAtIndex(Mutable, v28++, ValueAtIndex);
      }
      while (v28 < CFArrayGetCount(ArrayBySeparatingStrings));
    }
    v30 = CGImageMetadataTagCreate(a3, a4, a5, kCGImageMetadataTypeArrayOrdered, Mutable);
    if (v30)
    {
      v31 = v30;
      CGImageMetadataAddTagWithKey((uint64_t)a1, a6, v30);
      CFRelease(v31);
    }
    goto LABEL_21;
  }
  Value = (const __CFArray *)CGImageMetadataTagGetValue(v21);
  if (Value && (v23 = Value, v24 = CFGetTypeID(Value), v24 == CFArrayGetTypeID()))
  {
    Mutable = CFArrayCreateMutableCopy(v16, 0, v23);
    if (CFArrayGetCount(ArrayBySeparatingStrings) >= 1)
    {
      v26 = 0;
      do
      {
        v27 = CFArrayGetValueAtIndex(ArrayBySeparatingStrings, v26);
        CFArrayAppendValue(Mutable, v27);
        ++v26;
      }
      while (v26 < CFArrayGetCount(ArrayBySeparatingStrings));
    }
    CGImageMetadataTagSetValue(v21, (const __CFString *)Mutable);
  }
  else
  {
LABEL_20:
    Mutable = 0;
  }
LABEL_21:
  free(v15);
  CFRelease(v18);
  if (ArrayBySeparatingStrings)
    CFRelease(ArrayBySeparatingStrings);
  if (Mutable)
    CFRelease(Mutable);
}

void *ReadAndCreateASCIIString(IIOImageReadSession *a1, unsigned __int16 *a2, uint64_t a3, int a4)
{
  IIOImageRead *Size;
  unint64_t v9;
  void *v10;
  _BYTE *v11;
  unint64_t v12;
  unsigned int *v13;
  unsigned int v14;
  unint64_t BytesAtOffset;
  uint64_t v16;

  Size = IIOImageReadSession::getSize(a1);
  v9 = *((unsigned int *)a2 + 1);
  if ((unint64_t)Size < v9)
  {
    _cg_jpeg_mem_term("ReadAndCreateASCIIString", 970, "p->count: %ld > rrefSize: %ld\n", *((unsigned int *)a2 + 1), Size);
    return 0;
  }
  v11 = malloc_type_malloc(v9 + 1, 0xB35469C1uLL);
  v10 = v11;
  if (v11)
  {
    v11[*((unsigned int *)a2 + 1)] = 0;
    v12 = *((unsigned int *)a2 + 1);
    v13 = (unsigned int *)(a2 + 4);
    if (v12 <= 4)
    {
      memmove(v11, v13, *((unsigned int *)a2 + 1));
      return v10;
    }
    v14 = *v13;
    if (a4)
    {
      v14 = bswap32(v14);
      *v13 = v14;
    }
    BytesAtOffset = IIOImageReadSession::getBytesAtOffset(a1, v11, a3 + v14, v12);
    v16 = *((unsigned int *)a2 + 1);
    if (BytesAtOffset != v16)
    {
      LogWarning("ReadAndCreateASCIIString", 994, "Unable to read ASCII TIFF Tag #%d with reported length (%u)\n", *a2, v16);
      free(v10);
      return 0;
    }
  }
  return v10;
}

void ReadCopyright(CGImageMetadata *a1, IIOImageReadSession *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned __int8 a9)
{
  const char *ASCIIString;
  char *v11;
  CFStringRef v12;
  CFStringRef v13;

  if (*(_DWORD *)(a7 + 4))
  {
    if (*(_WORD *)(a7 + 2) == 2)
    {
      ASCIIString = (const char *)ReadAndCreateASCIIString(a2, (unsigned __int16 *)a7, a8, a9);
      if (ASCIIString)
      {
        v11 = (char *)ASCIIString;
        v12 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], ASCIIString, 0x8000100u);
        if (v12)
        {
          v13 = v12;
          CGImageMetadataSetValueWithPath(a1, 0, CFSTR("dc:rights[x-default]"), v12);
          CFRelease(v13);
        }
        free(v11);
      }
    }
  }
}

void ReadImageDescription(CGImageMetadata *a1, IIOImageReadSession *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned __int8 a9)
{
  const char *ASCIIString;
  char *v11;
  CFStringRef v12;
  CFStringRef v13;

  if (*(_DWORD *)(a7 + 4))
  {
    if (*(_WORD *)(a7 + 2) == 2)
    {
      ASCIIString = (const char *)ReadAndCreateASCIIString(a2, (unsigned __int16 *)a7, a8, a9);
      if (ASCIIString)
      {
        v11 = (char *)ASCIIString;
        v12 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], ASCIIString, 0x8000100u);
        if (v12)
        {
          v13 = v12;
          CGImageMetadataSetValueWithPath(a1, 0, CFSTR("dc:description[x-default]"), v12);
          CFRelease(v13);
        }
        free(v11);
      }
    }
  }
}

__n128 ReadDateTime(uint64_t a1, IIOImageReadSession *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, uint64_t a7, uint64_t a8, unsigned __int8 a9)
{
  int v9;
  const char *ASCIIString;
  __n128 result;
  char *v20;
  const __CFString *v21;
  const __CFString *v22;
  const __CFString *XMPDateTimeFromEXIFDateTime;
  const __CFString *v24;
  CGImageMetadataTagRef v25;
  CGImageMetadataTagRef v26;

  v9 = *(_DWORD *)(a7 + 4);
  if ((v9 - 21) <= 0xFFFFFFFD)
    return _cg_jpeg_mem_term("ReadDateTime", 1515, "Bad dataTime length: %d (expected 20)\n", *(_DWORD *)(a7 + 4));
  if (*(_WORD *)(a7 + 2) != 2)
    return _cg_jpeg_mem_term("ReadDateTime", 1516, "Bad dataTime format (tiff_ASCII)\n");
  if (v9 == 19)
    _cg_jpeg_mem_term("ReadDateTime", 1519, "Bad dataTime length: 19 (expected 20) missing null termination?\n");
  ASCIIString = (const char *)ReadAndCreateASCIIString(a2, (unsigned __int16 *)a7, a8, a9);
  if (ASCIIString)
  {
    v20 = (char *)ASCIIString;
    v21 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], ASCIIString, 0x8000100u);
    if (v21)
    {
      v22 = v21;
      XMPDateTimeFromEXIFDateTime = CreateXMPDateTimeFromEXIFDateTime(v21);
      if (XMPDateTimeFromEXIFDateTime)
      {
        v24 = XMPDateTimeFromEXIFDateTime;
        v25 = CGImageMetadataTagCreate(a3, a4, a5, kCGImageMetadataTypeString, XMPDateTimeFromEXIFDateTime);
        if (v25)
        {
          v26 = v25;
          CGImageMetadataAddTagWithKey(a1, a6, v25);
          CFRelease(v26);
        }
        CFRelease(v24);
      }
      CFRelease(v22);
    }
    free(v20);
  }
  return result;
}

__n128 ReadOffsetTime(uint64_t a1, IIOImageReadSession *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, uint64_t a7, uint64_t a8, unsigned __int8 a9)
{
  const char *ASCIIString;
  __n128 result;
  char *v16;
  CFStringRef v17;
  CFStringRef v18;
  CGImageMetadataTagRef v19;
  CGImageMetadataTagRef v20;

  if (*(_DWORD *)(a7 + 4) != 7)
    return _cg_jpeg_mem_term("ReadOffsetTime", 1564, "Bad dataOffsetTime length: %d (expected 7)\n", *(_DWORD *)(a7 + 4));
  if (*(_WORD *)(a7 + 2) != 2)
    return _cg_jpeg_mem_term("ReadOffsetTime", 1565, "Bad dataOffsetTime format (tiff_ASCII)\n");
  ASCIIString = (const char *)ReadAndCreateASCIIString(a2, (unsigned __int16 *)a7, a8, a9);
  if (ASCIIString)
  {
    v16 = (char *)ASCIIString;
    v17 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], ASCIIString, 0x8000100u);
    if (v17)
    {
      v18 = v17;
      v19 = CGImageMetadataTagCreate(a3, a4, a5, kCGImageMetadataTypeString, v17);
      if (v19)
      {
        v20 = v19;
        CGImageMetadataAddTagWithKey(a1, a6, v19);
        CFRelease(v20);
      }
      CFRelease(v18);
    }
    free(v16);
  }
  return result;
}

void ReadFlash(_QWORD *a1, IIOImageReadSession *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, uint64_t a7, uint64_t a8, char a9)
{
  void *TagWithPath;
  uint64_t v11;
  const __CFString *Value;
  SInt32 IntValue;
  __CFDictionary *XMPFlashStructFromInt;
  const __CFString *v15;

  if (*(_DWORD *)(a7 + 4) == 1 && *(_WORD *)(a7 + 2) == 3)
  {
    ReadMetadataShort((uint64_t)a1, a2, a3, a4, a5, a6, 0, a7, a8, a9);
    TagWithPath = CGImageMetadataGetTagWithPath(a1, 0, CFSTR("exif:Flash"));
    if (TagWithPath)
    {
      v11 = (uint64_t)TagWithPath;
      Value = (const __CFString *)CGImageMetadataTagGetValue((uint64_t)TagWithPath);
      IntValue = CFStringGetIntValue(Value);
      XMPFlashStructFromInt = CreateXMPFlashStructFromInt(IntValue);
      if (XMPFlashStructFromInt)
      {
        v15 = (const __CFString *)XMPFlashStructFromInt;
        CGImageMetadataTagSetValueType(v11, 6);
        CGImageMetadataTagSetValue(v11, v15);
        CFRelease(v15);
      }
    }
  }
}

void ReadFileSource(uint64_t a1, IIOImageReadSession *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, uint64_t a7, uint64_t a8, char a9)
{
  if (*(_DWORD *)(a7 + 4) == 1 && *(_WORD *)(a7 + 2) == 7)
    ReadMetadataByte(a1, a2, a3, a4, a5, a6, 0, a7, a8, a9);
}

void ReadPhotoshopImageResourceTag(uint64_t a1, IIOImageReadSession *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  size_t v10;
  _BYTE *v14;
  uint64_t v15;
  unint64_t v16;
  unsigned int v17;

  v10 = *(unsigned int *)(a7 + 4);
  if ((v10 - 20001) > 0xFFFFB1E8)
  {
    v14 = malloc_type_calloc(v10, 1uLL, 0xAB6CB84AuLL);
    v16 = *(unsigned int *)(a7 + 4);
    LODWORD(v15) = *(_DWORD *)(a7 + 8);
    v17 = bswap32(v15);
    if (a9)
      v15 = v17;
    else
      v15 = v15;
    if (IIOImageReadSession::getBytesAtOffset(a2, v14, v15 + a8, *(unsigned int *)(a7 + 4)) == v16)
      ReadPhotoshopImageResource(a1, (uint64_t)v14, v16);
    if (v14)
      free(v14);
  }
  else
  {
    LogError("ReadPhotoshopImageResourceTag", 1657, "*** ERROR: Skipping Photoshop Image Resources block, size is %d\n", *(_DWORD *)(a7 + 4));
  }
}

__n128 ReadCompositeTimes(uint64_t a1, IIOImageReadSession *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, uint64_t a7, uint64_t a8, char a9)
{
  unsigned int *v12;
  const __CFAllocator *v13;
  __CFArray *Mutable;
  uint64_t i;
  uint64_t j;
  CFStringRef v17;
  unsigned int v18;
  CFStringRef v19;
  unsigned int v20;
  CFStringRef v21;
  unint64_t v22;
  int v23;
  uint64_t v24;
  unsigned int *v25;
  unint64_t v26;
  unsigned int *v27;
  CFStringRef v28;
  CGImageMetadataTagRef v29;
  __n128 result;
  uint64_t v31;
  const void *v32;
  const __CFString *v33;
  const __CFString *v34;
  const __CFString *name;
  int v36;

  if (a9)
    *(_DWORD *)(a7 + 8) = bswap32(*(_DWORD *)(a7 + 8));
  if (*(_WORD *)(a7 + 2) == 7)
  {
    if (*(_DWORD *)(a7 + 4) <= 0x39u)
      return _cg_jpeg_mem_term("ReadCompositeTimes", 1716, "*** ERROR: count < fixedSize + sizeof(uint16_t) [%d < %d]", *(_DWORD *)(a7 + 4), 58);
    v33 = a3;
    v34 = a4;
    name = a5;
    v31 = a1;
    v32 = a6;
    v12 = (unsigned int *)malloc_type_calloc(0x38uLL, 1uLL, 0xF0A6139AuLL);
    v36 = 0;
    v13 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
    IIOImageReadSession::getBytesAtOffset(a2, v12, *(unsigned int *)(a7 + 8) + a8, 0x38uLL);
    if (a9)
    {
      for (i = 0; i != 14; ++i)
        v12[i] = bswap32(v12[i]);
    }
    for (j = 0; j != 14; j += 2)
    {
      v17 = CFStringCreateWithFormat(v13, 0, CFSTR("%u/%u"), v12[j], v12[j + 1]);
      CFArrayAppendValue(Mutable, v17);
      CFRelease(v17);
    }
    IIOImageReadSession::getBytesAtOffset(a2, (_BYTE *)&v36 + 2, a8 + *(unsigned int *)(a7 + 8) + 56, 2uLL);
    v18 = HIWORD(v36);
    if ((a9 & 1) != 0)
    {
      v18 = __rev16(HIWORD(v36));
      HIWORD(v36) = v18;
    }
    v19 = CFStringCreateWithFormat(v13, 0, CFSTR("%d"), v18);
    CFArrayAppendValue(Mutable, v19);
    CFRelease(v19);
    if (HIWORD(v36))
    {
      IIOImageReadSession::getBytesAtOffset(a2, &v36, a8 + *(unsigned int *)(a7 + 8) + 58, 2uLL);
      v20 = (unsigned __int16)v36;
      if (a9)
      {
        v20 = __rev16((unsigned __int16)v36);
        LOWORD(v36) = v20;
      }
      v21 = CFStringCreateWithFormat(v13, 0, CFSTR("%d"), v20);
      CFArrayAppendValue(Mutable, v21);
      CFRelease(v21);
      if ((*(_DWORD *)(a7 + 4) - 56) - 4 != 8 * (unsigned __int16)v36)
        goto LABEL_27;
      v22 = 8 * (unsigned __int16)v36;
      if ((unsigned __int16)v36 >= 8u)
        v12 = (unsigned int *)reallocf(v12, 8 * (unsigned __int16)v36);
    }
    else
    {
      if (*(_DWORD *)(a7 + 4) != 60)
        goto LABEL_27;
      v22 = 0;
    }
    IIOImageReadSession::getBytesAtOffset(a2, v12, a8 + *(unsigned int *)(a7 + 8) + 60, v22);
    v23 = (unsigned __int16)v36;
    if (!a9)
      goto LABEL_24;
    if ((_WORD)v36)
    {
      v24 = 2 * (unsigned __int16)v36;
      v25 = v12;
      do
      {
        *v25 = bswap32(*v25);
        ++v25;
        --v24;
      }
      while (v24);
LABEL_24:
      if (v23)
      {
        v26 = 0;
        v27 = v12 + 1;
        do
        {
          v28 = CFStringCreateWithFormat(v13, 0, CFSTR("%u/%u"), *(v27 - 1), *v27, v31, v32, v33, v34, name);
          CFArrayAppendValue(Mutable, v28);
          CFRelease(v28);
          ++v26;
          v27 += 2;
        }
        while (v26 < (unsigned __int16)v36);
      }
    }
LABEL_27:
    if (Mutable)
    {
      v29 = CGImageMetadataTagCreate(v33, v34, name, kCGImageMetadataTypeArrayOrdered, Mutable);
      CFRelease(Mutable);
      if (v29)
      {
        CGImageMetadataAddTagWithKey(v31, v32, v29);
        CFRelease(v29);
      }
    }
    free(v12);
  }
  return result;
}

uint64_t SRationalApprox(double a1, int *a2, unsigned int *a3)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;

  v6 = 0;
  v7 = 0;
  result = RationalApprox(a1, 0x7FFFFFFFLL, &v7, &v6);
  *a2 = v7;
  *a3 = v6;
  return result;
}

char *CreateExifBufferFromPropertiesTIFF(IIODictionary *a1, uint64_t a2, uint64_t a3, int a4, unint64_t *a5)
{
  const __CFDictionary *ObjectForKey;
  const __CFDictionary *v11;
  IIODictionary *v12;
  const __CFDictionary *v13;
  uint64_t v14;
  uint64_t v15;
  __int16 *v16;
  const __CFString **v17;
  const __CFString *v18;
  unint64_t valid;
  _QWORD *v20;
  _QWORD *v21;
  int v22;
  char *v23;
  unsigned __int8 *v24;
  uint64_t *v25;
  unsigned __int16 *v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  const __CFArray *v30;
  CFTypeID v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  char *v36;
  unint64_t *v37;
  uint64_t v38;
  char *v39;
  int v40;
  _BYTE v41[24];
  _BYTE v42[24];
  _BYTE v43[16];
  _QWORD v44[308];

  v44[306] = *MEMORY[0x1E0C80C00];
  bzero(v43, 0x9A0uLL);
  if (!a1 || (ObjectForKey = IIODictionary::getObjectForKey(a1, CFSTR("{Exif}"))) == 0)
  {
    v14 = 0;
    v38 = 0;
    v34 = 0;
    if (!a5)
      return v34;
    goto LABEL_36;
  }
  v11 = ObjectForKey;
  v12 = (IIODictionary *)operator new();
  IIODictionary::IIODictionary(v12, v11, 1);
  v37 = a5;
  IIONumber::IIONumber((IIONumber *)v42, a2);
  IIODictionary::setObjectForKey((uint64_t)v12, (uint64_t)v42, CFSTR("PixelXDimension"));
  IIONumber::~IIONumber((IIONumber *)v42);
  IIONumber::IIONumber((IIONumber *)v41, a3);
  IIODictionary::setObjectForKey((uint64_t)v12, (uint64_t)v41, CFSTR("PixelYDimension"));
  IIONumber::~IIONumber((IIONumber *)v41);
  if ((IIODictionary::containsKey(a1, CFSTR("{MakerApple}")) & 1) != 0)
  {
    v13 = IIODictionary::getObjectForKey(a1, CFSTR("{MakerApple}"));
    IIODictionary::setObjectForKey(v12, v13, CFSTR("MakerNote"));
  }
  v14 = 0;
  v15 = 0;
  v16 = (__int16 *)&tagdefsExif;
  do
  {
    v17 = (const __CFString **)*((_QWORD *)v16 + 5);
    if (v17)
      v18 = (const __CFString *)IIODictionary::getObjectForKey(v12, *v17);
    else
      v18 = 0;
    valid = validValueForKey((unsigned __int16 *)v16, v18);
    if (valid)
    {
      v20 = &v43[32 * v15];
      *v20 = v16;
      v20[1] = v18;
      v20[2] = valid;
      v20[3] = 0;
      v21 = v20 + 3;
      if (valid >= 5)
      {
        *v21 = v14;
        v14 += valid;
      }
      ++v15;
    }
    v22 = v16[28];
    v16 += 28;
  }
  while (v22 != -1);
  if (v15)
  {
    v38 = 12 * v15 + 6;
    v23 = (char *)malloc_type_calloc(1uLL, v38 + v14, 0x27939BF1uLL);
    v36 = v23;
    if (v23)
    {
      v39 = &v23[v38];
      v40 = v38 + a4;
      v23[1] = v15;
      v24 = (unsigned __int8 *)(v23 + 10);
      v25 = v44;
      while (1)
      {
        v26 = (unsigned __int16 *)*(v25 - 2);
        v27 = *v26;
        v28 = v26[1] == 32771 ? 4 : v26[1];
        *((_WORD *)v24 - 4) = __rev16(v27);
        *((_WORD *)v24 - 3) = __rev16(v28);
        if (v28 > 0xA)
          break;
        if (((1 << v28) & 0x86) != 0)
        {
          v29 = bswap32(*(_DWORD *)v25);
        }
        else
        {
          if (((1 << v28) & 0x420) == 0)
            break;
          v29 = bswap32((unint64_t)*v25 >> 3);
        }
LABEL_29:
        *((_DWORD *)v24 - 1) = v29;
        v32 = *v25;
        if ((unint64_t)*v25 < 5)
        {
          *(_DWORD *)v24 = 0;
          WriteValueForTagID((const __CFString *)*(v25 - 1), v32, v27, v28, 0, v24);
        }
        else
        {
          v33 = v25[1];
          *(_DWORD *)v24 = bswap32(v40 + v33);
          WriteValueForTagID((const __CFString *)*(v25 - 1), v32, v27, v28, 0, (unsigned __int8 *)&v39[v33]);
        }
        v24 += 12;
        v25 += 4;
        if (!--v15)
        {
          v34 = v36;
          goto LABEL_35;
        }
      }
      if (v26[2] || (v30 = (const __CFArray *)*(v25 - 1), v31 = CFGetTypeID(v30), v31 != CFArrayGetTypeID()))
        v29 = 0x1000000;
      else
        v29 = bswap32(CFArrayGetCount(v30));
      goto LABEL_29;
    }
    v34 = 0;
  }
  else
  {
    v34 = 0;
    v38 = 0;
  }
LABEL_35:
  (*(void (**)(IIODictionary *))(*(_QWORD *)v12 + 8))(v12);
  a5 = v37;
  if (v37)
LABEL_36:
    *a5 = v38 + v14;
  return v34;
}

void sub_187FC364C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

_WORD *CreateGPSBufferFromPropertiesTIFF(IIODictionary *a1, unint64_t a2, unint64_t a3, int a4, unint64_t *a5, unint64_t *a6)
{
  return _CreateGPSBufferFromPropertiesTIFF(a1, a4, 0, a5, (BOOL)a5, a6);
}

_WORD *_CreateGPSBufferFromPropertiesTIFF(IIODictionary *a1, int a2, int a3, _QWORD *a4, BOOL a5, unint64_t *a6)
{
  const __CFDictionary *ObjectForKey;
  __CFDictionary *v11;
  IIODictionary *v12;
  uint64_t v13;
  _WORD *v14;
  __int16 *v15;
  const __CFString **v16;
  const __CFString *v17;
  unint64_t valid;
  _QWORD *v19;
  _QWORD *v20;
  int v21;
  uint64_t v22;
  _WORD *v23;
  unsigned int v24;
  unsigned int *v25;
  int v26;
  int v27;
  char *v28;
  unint64_t *v29;
  unsigned __int16 *v30;
  unsigned int v31;
  unsigned int v32;
  __int16 v33;
  __int16 v34;
  unint64_t v35;
  unint64_t v36;
  unsigned int v37;
  unint64_t v38;
  unsigned int v39;
  unsigned int v40;
  const __CFString *v41;
  unsigned __int8 *v42;
  int v43;
  int v44;
  int v45;
  _WORD *v47;
  uint64_t v48;
  _QWORD *v49;
  int v50;
  _BYTE v51[16];
  _QWORD v52[132];

  v52[130] = *MEMORY[0x1E0C80C00];
  bzero(v51, 0x420uLL);
  if (!a1 || (ObjectForKey = IIODictionary::getObjectForKey(a1, CFSTR("{GPS}"))) == 0)
  {
    v14 = 0;
    v13 = 0;
    v22 = 0;
    if (!a4)
      return v14;
    goto LABEL_47;
  }
  v11 = ObjectForKey;
  v12 = (IIODictionary *)operator new();
  IIODictionary::IIODictionary(v12, v11);
  v13 = 0;
  v14 = 0;
  v15 = (__int16 *)&tagdefsGPS;
  do
  {
    v16 = (const __CFString **)*((_QWORD *)v15 + 5);
    if (v16)
      v17 = (const __CFString *)IIODictionary::getObjectForKey(v12, *v16);
    else
      v17 = 0;
    valid = validValueForKey((unsigned __int16 *)v15, v17);
    if (valid)
    {
      v19 = &v51[32 * (_QWORD)v14];
      *v19 = v15;
      v19[1] = v17;
      v19[2] = valid;
      v19[3] = 0;
      v20 = v19 + 3;
      if (valid >= 5)
      {
        *v20 = v13;
        v13 += valid;
      }
      v14 = (_WORD *)((char *)v14 + 1);
    }
    v21 = v15[28];
    v15 += 28;
  }
  while (v21 != -1);
  if (v14)
  {
    v22 = 12 * (_QWORD)v14 + 6;
    v23 = malloc_type_calloc(1uLL, v22 + v13, 0xFC8617CuLL);
    if (v23)
    {
      v48 = 12 * (_QWORD)v14 + 6;
      v49 = a4;
      v24 = bswap32(v14) >> 16;
      if (a3)
        LOWORD(v24) = (_WORD)v14;
      *v23 = v24;
      v25 = (unsigned int *)(v23 + 5);
      if (a3)
        v26 = 1;
      else
        v26 = 0x1000000;
      v50 = v26;
      v27 = v22 + a2;
      v47 = v23;
      v28 = (char *)v23 + v22;
      v29 = v52;
      while (1)
      {
        v30 = (unsigned __int16 *)*(v29 - 2);
        v31 = *v30;
        v32 = v30[1];
        if (v32 >= 0xB)
        {
          if (v32 == 32771)
          {
            v32 = 4;
          }
          else if (v32 == 32775)
          {
            v32 = 5;
          }
          else
          {
            _cg_jpeg_mem_term("_CreateGPSBufferFromPropertiesTIFF", 4620, "*** tagType '%d' [0x%04X] not handled\n", v32, v32);
          }
        }
        v33 = __rev16(v31);
        v34 = __rev16(v32);
        if (a3)
        {
          v33 = v31;
          v34 = v32;
        }
        *((_WORD *)v25 - 4) = v33;
        *((_WORD *)v25 - 3) = v34;
        if (v32 > 0xA)
          break;
        if (((1 << v32) & 0x86) != 0)
        {
          v35 = *v29;
          LODWORD(v36) = bswap32(*v29);
          if (a3)
            LODWORD(v36) = *v29;
        }
        else
        {
          if (((1 << v32) & 0x420) == 0)
            break;
          v35 = *v29;
          v36 = *v29 >> 3;
          v37 = bswap32(v36);
          if (!a3)
            LODWORD(v36) = v37;
        }
        *(v25 - 1) = v36;
LABEL_37:
        if (v35 < 5)
        {
          *v25 = 0;
          v41 = (const __CFString *)*(v29 - 1);
          v43 = v31;
          v44 = v32;
          v45 = a3;
          v42 = (unsigned __int8 *)v25;
        }
        else
        {
          v38 = v29[1];
          v39 = v27 + v38;
          v40 = bswap32(v27 + v38);
          if (!a3)
            v39 = v40;
          *v25 = v39;
          v41 = (const __CFString *)*(v29 - 1);
          v42 = (unsigned __int8 *)&v28[v38];
          v43 = v31;
          v44 = v32;
          v45 = a3;
        }
        WriteValueForTagID(v41, v35, v43, v44, v45, v42);
        v29 += 4;
        v25 += 3;
        v14 = (_WORD *)((char *)v14 - 1);
        if (!v14)
        {
          v22 = v48;
          a4 = v49;
          v14 = v47;
          goto LABEL_46;
        }
      }
      *(v25 - 1) = v50;
      v35 = *v29;
      goto LABEL_37;
    }
    v14 = 0;
  }
  else
  {
    v22 = 0;
  }
LABEL_46:
  (*(void (**)(IIODictionary *))(*(_QWORD *)v12 + 8))(v12);
  if (a4)
LABEL_47:
    *a4 = v22 + v13;
  return v14;
}

void sub_187FC39D4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

_WORD *CreateGPSBufferFromPropertiesTIFFNew(IIODictionary *a1, unint64_t a2, unint64_t a3, int a4, int a5, unint64_t *a6)
{
  return _CreateGPSBufferFromPropertiesTIFF(a1, a4, a5, a6, a5, a6);
}

void call_RAWCamera_readMakerNoteProps(uint64_t a1, IIODictionary *a2, uint64_t a3, uint64_t a4, char a5)
{
  void (*v6)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD);
  uint64_t v7;
  uint64_t v8;
  _BYTE v9[31];
  unsigned __int8 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  IIODictionary *v14;
  uint64_t v15;

  v15 = a1;
  v14 = a2;
  v13 = a3;
  v12 = 0;
  v11 = a4;
  v10 = a5 & 1;
  IIONumber::IIONumber((IIONumber *)v9, a4);
  IIODictionary::setObjectForKeyGroup(a2, (uint64_t)v9, CFSTR("MakerNoteSize"), CFSTR("{MakerNoteInfo}"));
  IIONumber::~IIONumber((IIONumber *)v9);
  if (gReadMakerNoteProps)
  {
    v6 = (void (*)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))gReadMakerNoteProps;
    v7 = v15;
    v8 = IIOImageSource::cf(v14);
    v6(v7, v8, v13, v12, v10);
  }
  IIODictionary::removeObjectForKey(v14, CFSTR("{MakerNoteInfo}"));
}

void ReadMetadataSRtnl(uint64_t a1, IIOImageReadSession *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, int a7, uint64_t a8, char a9)
{
  unsigned int *v16;
  unsigned int v17;
  unint64_t BytesAtOffset;
  unsigned int v19;
  unint64_t v20;
  BOOL v21;
  const __CFAllocator **v22;
  CFMutableArrayRef Mutable;
  __CFArray *v24;
  const void *v25;
  int v26;
  unint64_t v27;
  const __CFAllocator *v28;
  unsigned int *v29;
  CFStringRef v30;
  unint64_t v31;
  const __CFString *v32;
  CGImageMetadataType v33;
  CGImageMetadataTagRef v34;
  CGImageMetadataType type;
  const __CFString *v36;
  uint64_t v37;
  const __CFString *prefix;

  v16 = (unsigned int *)malloc_type_calloc(*(unsigned int *)(a8 + 4), 8uLL, 0xFF299D4DuLL);
  v17 = *(_DWORD *)(a8 + 8);
  if (a9)
  {
    v17 = bswap32(v17);
    *(_DWORD *)(a8 + 8) = v17;
  }
  BytesAtOffset = IIOImageReadSession::getBytesAtOffset(a2, v16, v17, (8 * *(_DWORD *)(a8 + 4)));
  v19 = *(_DWORD *)(a8 + 4);
  if (BytesAtOffset == 8 * v19)
  {
    if ((v19 & 0x7FFFFFFF) != 0 && a9)
    {
      v20 = 0;
      do
      {
        v16[v20] = bswap32(v16[v20]);
        ++v20;
        v19 = *(_DWORD *)(a8 + 4);
      }
      while (v20 < 2 * v19);
    }
    v21 = v19 <= 1 && a7 == 0;
    v22 = (const __CFAllocator **)MEMORY[0x1E0C9AE00];
    if (v21)
    {
      if (!v19)
        goto LABEL_30;
      v37 = a1;
      prefix = a4;
      v36 = a5;
      v25 = a6;
      v24 = 0;
      v26 = 1;
    }
    else
    {
      Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
      v24 = Mutable;
      if (!*(_DWORD *)(a8 + 4))
      {
        if (!Mutable)
          goto LABEL_30;
        v33 = kCGImageMetadataTypeArrayOrdered;
        v32 = a3;
        goto LABEL_27;
      }
      v37 = a1;
      prefix = a4;
      v36 = a5;
      v25 = a6;
      v26 = 3;
    }
    type = v26;
    v27 = 0;
    v28 = *v22;
    v29 = v16 + 1;
    do
    {
      v30 = CFStringCreateWithFormat(v28, 0, CFSTR("%d/%d"), *(v29 - 1), *v29);
      if ((a7 & 1) != 0 || (v31 = *(unsigned int *)(a8 + 4), v31 >= 2))
      {
        CFArrayAppendValue(v24, v30);
        CFRelease(v30);
        v30 = 0;
        v31 = *(unsigned int *)(a8 + 4);
      }
      v29 += 2;
      ++v27;
    }
    while (v27 < v31);
    a6 = v25;
    a4 = prefix;
    if (!v24)
    {
      a1 = v37;
      if (!v30)
        goto LABEL_30;
      v34 = CGImageMetadataTagCreate(a3, prefix, v36, type, v30);
      goto LABEL_28;
    }
    a5 = v36;
    a1 = v37;
    v32 = a3;
    v33 = type;
LABEL_27:
    v34 = CGImageMetadataTagCreate(v32, a4, a5, v33, v24);
    v30 = (CFStringRef)v24;
LABEL_28:
    CFRelease(v30);
    if (v34)
    {
      CGImageMetadataAddTagWithKey(a1, a6, v34);
      CFRelease(v34);
    }
  }
LABEL_30:
  free(v16);
}

uint64_t ___ZL16validValueForKeyPK6tagdefPKv_block_invoke(uint64_t a1, const __CFString *cf)
{
  CFTypeID v4;
  uint64_t result;

  v4 = CFGetTypeID(cf);
  result = CFStringGetTypeID();
  if (v4 == result)
  {
    result = CFStringGetLength(cf);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += result + 2;
  }
  return result;
}

void ___ZL18WriteValueForTagIDPKvmttbPh_block_invoke(_QWORD *a1, CFTypeRef cf, uint64_t a3, _BYTE *a4)
{
  CFTypeID v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  _QWORD v16[3];

  v7 = CFGetTypeID(cf);
  if (v7 == CFStringGetTypeID())
  {
    memset(v16, 0, sizeof(v16));
    IIOString::IIOString((IIOString *)v16, cf);
    v8 = *(_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
    v9 = IIOString::length((IIOString *)v16) + v8;
    v10 = a1[5];
    if (v10 <= v9)
    {
      *a4 = 1;
    }
    else
    {
      v11 = *(_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
      v12 = IIOString::length((IIOString *)v16);
      v13 = a1[6];
      v14 = *(unsigned int *)(*(_QWORD *)(a1[4] + 8) + 24);
      v15 = (const char *)IIOString::utf8String((IIOString *)v16);
      *(_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24) += snprintf((char *)(v13 + v14), v10 - (v12 + v11), "%s", v15);
      *(_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24) += 2;
    }
    IIOString::~IIOString((IIOString *)v16);
  }
}

void sub_187FC4018(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_PVR::createReadPlugin(IIO_Reader *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;

  v4 = operator new();
  v5 = IIO_Reader::osType(a1);
  PVRReadPlugin::PVRReadPlugin(v4, a2, v5);
  return v4;
}

void sub_187FC4094(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40C8507604);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_PVR::createReadPlugin(IIO_Reader *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8;
  int v9;

  v8 = operator new();
  v9 = IIO_Reader::osType(a1);
  PVRReadPlugin::PVRReadPlugin(v8, a2, a3, a4, v9);
  return v8;
}

void sub_187FC4130(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40C8507604);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_PVR::updateSourceProperties(IIO_Reader_PVR *this, IIOImageReadSession *a2, IIODictionary *a3, IIODictionary *a4, IIODictionary *a5, CGImageSourceStatus *a6)
{
  return 4294967246;
}

uint64_t IIO_Reader_PVR::getImageCount(IIO_Reader_PVR *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  unsigned int Size;
  int v11;
  uint64_t v12;
  int v13;
  IIO_ReaderHandler *BytesAtOffset;
  int v15;
  unint64_t v16;
  __CFString **v17;
  IIO_ReaderHandler *ReaderHandler;
  int v19;
  IIO_Reader *v20;
  unsigned int v21;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  int v26;
  uint64_t v27;

  Size = IIOImageReadSession::getSize(a2);
  v27 = 0;
  IIOImageReadSession::getBytesAtOffset(a2, &v27, 0x2CuLL, 4uLL);
  v11 = v27;
  LODWORD(v27) = bswap32(v27);
  if (v11 == 559044176)
  {
    v26 = 0;
    v24 = 0u;
    v25 = 0u;
    v23 = 0u;
    IIOImageReadSession::getBytesAtOffset(a2, &v23, 0, 0x34uLL);
    if (DWORD2(v23) <= Size && DWORD1(v23) <= Size)
    {
      v12 = 0;
      v13 = HIDWORD(v23);
      if (HIDWORD(v23) <= 1)
        v13 = 1;
      goto LABEL_12;
    }
    _cg_jpeg_mem_term("getImageCount", 169, "*** invalid PVR file: size: %d x %d  (fileSize: %d)\n");
    goto LABEL_18;
  }
  BytesAtOffset = (IIO_ReaderHandler *)IIOImageReadSession::getBytesAtOffset(a2, &v27, 0, 4uLL);
  v15 = v27;
  LODWORD(v27) = bswap32(v27);
  if (v15 == 55727696)
  {
    v26 = 0;
    v24 = 0u;
    v25 = 0u;
    v23 = 0u;
    IIOImageReadSession::getBytesAtOffset(a2, &v23, 0, 0x34uLL);
    if (HIDWORD(v24) > Size || DWORD2(v24) > Size)
    {
      _cg_jpeg_mem_term("getImageCount", 190, "*** invalid PVR file: size: %d x %d  (fileSize: %d)\n");
    }
    else if (DWORD1(v25) >= 0x11)
    {
      _cg_jpeg_mem_term("getImageCount", 194, "*** bad numberOfSurfaces count [%d]\n");
    }
    else
    {
      v16 = DWORD2(v25);
      if ((unint64_t)IIOImageReadSession::getSize(a2) >= v16)
      {
        v12 = 0;
        v13 = HIDWORD(v25);
LABEL_12:
        HIDWORD(v27) = v13;
        goto LABEL_21;
      }
      IIOImageReadSession::getSize(a2);
      _cg_jpeg_mem_term("getImageCount", 195, "*** bad numberOfFaces count [%d]  size: %d\n");
    }
    goto LABEL_18;
  }
  v17 = (__CFString **)*((_QWORD *)this + 1);
  if (v17 == kCGImageTypeIdentifierKTX)
  {
    ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(BytesAtOffset);
    v19 = 1263818784;
  }
  else
  {
    if (v17 != kCGImageTypeIdentifierKTX2)
    {
LABEL_18:
      v12 = 4294967246;
      goto LABEL_21;
    }
    ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(BytesAtOffset);
    v19 = 1263818802;
  }
  v20 = IIO_ReaderHandler::readerForType(ReaderHandler, v19);
  v12 = (*(uint64_t (**)(IIO_Reader *, IIOImageReadSession *, IIODictionary *, CGImageSourceStatus *, char *))(*(_QWORD *)v20 + 32))(v20, a2, a3, a4, (char *)&v27 + 4);
LABEL_21:
  v21 = HIDWORD(v27);
  if (HIDWORD(v27) > Size)
  {
    _cg_jpeg_mem_term("getImageCount", 218, "*** invalid PVR file: MipMapCount = %d  (fileSize: %d)\n", HIDWORD(v27), Size);
    v21 = 0;
  }
  if (a5)
    *a5 = v21;
  return v12;
}

uint64_t IIO_Reader_PVR::hasCustomImageCountProc(IIO_Reader_PVR *this)
{
  return 1;
}

uint64_t IIO_Reader_PVR::hasCustomSourcePropertiesProc(IIO_Reader_PVR *this)
{
  return 1;
}

uint64_t _TIFFDefaultStripSize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  unint64_t v9;

  if ((int)a2 <= 0)
  {
    v8 = _cg_TIFFScanlineSize64(a1, a2, a3, a4, a5, a6, a7, a8);
    if (v8 <= 1)
      v9 = 1;
    else
      v9 = v8;
    if (v9 <= 0x2000)
      return 0x2000u / (unsigned __int16)v9;
    else
      return 1;
  }
  return a2;
}

void ICOWritePlugin::ICOWritePlugin(ICOWritePlugin *this, IIOImageWriteSession *a2, IIOImageDestination *a3)
{
  _QWORD *v3;

  IIOWritePlugin::IIOWritePlugin(this, a2, a3, 0xCu);
  *v3 = &off_1E1BAE398;
}

void ICOWritePlugin::~ICOWritePlugin(ICOWritePlugin *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

uint64_t ICOWritePlugin::writeOneImage(ICOWritePlugin *this, CGImage *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

uint64_t ICOWritePlugin::writeAll(IIOImageDestination **this)
{
  unsigned int ImageCount;
  uint64_t v3;
  unint64_t v4;
  size_t v5;
  IIOImageSource *PixelDataProviderAtIndex;
  uint64_t Ref;
  IIOImageSource **v8;
  uint64_t v9;
  _DWORD *v10;
  void *v11;
  uint64_t v12;
  _DWORD *v13;
  char *v14;
  char v15;
  int v16;
  __CFData **v17;
  _DWORD *v18;
  size_t v19;
  IIOImageWriteSession *v20;
  IIOImageWriteSession *v21;
  IIOImageDestination *v22;
  IIOImagePixelDataProvider *v23;
  IIODictionary *SourceGeomColorSpace;
  IIODictionary *v25;
  IIOImageDestination *v26;
  CGImage *v27;
  IIODictionary *v28;
  IIODictionary *v29;
  int Length;
  uint64_t i;
  char *v32;
  UInt8 *MutableBytePtr;
  size_t v34;
  int v35;
  _DWORD *v36;
  int v37;
  int v38;
  UInt8 *v39;
  uint64_t v40;
  size_t v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t j;
  const void *v45;
  void *v46;
  void *v48;
  const __CFAllocator *allocator;
  int __ptr;
  __int16 v51;
  __int128 __base;
  __int128 v53;
  _OWORD v54[28];
  uint64_t v55;
  CFRange v56;

  v55 = *MEMORY[0x1E0C80C00];
  memset(v54, 0, sizeof(v54));
  __base = 0u;
  v53 = 0u;
  v51 = 0;
  __ptr = 0;
  ImageCount = IIOWritePlugin::getImageCount(this);
  if (ImageCount >= 0xC)
    v3 = 12;
  else
    v3 = ImageCount;
  if (!(_DWORD)v3)
    goto LABEL_43;
  v4 = 0;
  v5 = 0;
  do
  {
    PixelDataProviderAtIndex = (IIOImageSource *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, v4);
    Ref = IIOImageSource::imageReadRef(PixelDataProviderAtIndex);
    v8 = (IIOImageSource **)&__base + 5 * v5;
    *v8 = PixelDataProviderAtIndex;
    v8[1] = (IIOImageSource *)Ref;
    v8[2] = (IIOImageSource *)IIOWritePlugin::getPropertiesAtIndex(this, v4);
    v9 = IIOImageSource::count(PixelDataProviderAtIndex);
    if (v9 == IIO_Reader::testHeaderSize(PixelDataProviderAtIndex))
    {
      if ((unint64_t)(v9 - 16) <= 0x38 && ((1 << (v9 - 16)) & 0x101000100010101) != 0
        || v9 == 256
        || v9 == 128)
      {
        *((_DWORD *)&v53 + 10 * v5++ + 2) = v9;
      }
      else
      {
        LogError("writeAll", 97, "*** unsupported ICO image size (%d x %d) - expected: 16, 32, 48, 128, or 256\n");
      }
    }
    else
    {
      LogError("writeAll", 101, "*** cannot create non-square ICO image (%d x %d)\n");
    }
    ++v4;
  }
  while (v3 != v4);
  if (!v5
    || (qsort_b(&__base, v5, 0x28uLL, &__block_literal_global_11),
        __ptr = 0x10000,
        v51 = v5,
        IIOImageWriteSession::putBytes(this[2], &__ptr, 6uLL) != 6))
  {
LABEL_43:
    v11 = 0;
    goto LABEL_44;
  }
  v10 = malloc_type_calloc(0x10uLL, v5, 0xB31454C3uLL);
  v48 = v10;
  v11 = v10;
  if (!v10)
  {
LABEL_44:
    v43 = 4294967246;
    goto LABEL_45;
  }
  v12 = 0;
  v13 = v10 + 1;
  v14 = (char *)&v53 + 8;
  do
  {
    v15 = *v14;
    v14 += 40;
    *((_BYTE *)v13 - 4) = v15;
    *((_BYTE *)v13 - 3) = v15;
    *((_WORD *)v13 - 1) = 0;
    v13[1] = 0;
    v13[2] = 0;
    *v13 = 2097153;
    v13 += 4;
    ++v12;
  }
  while (v5 != v12);
  v16 = (16 * v5) | 6;
  allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v17 = (__CFData **)v54;
  v18 = v10 + 3;
  v19 = v5;
  do
  {
    *v17 = CFDataCreateMutable(allocator, 0);
    v20 = (IIOImageWriteSession *)operator new();
    IIOImageWriteSession::IIOImageWriteSession(v20, *v17);
    v21 = this[3];
    if (*((_DWORD *)v17 - 2) == 256)
    {
      v22 = *(v17 - 4);
      v23 = *(v17 - 2);
      SourceGeomColorSpace = (IIODictionary *)IIOImagePlus::getSourceGeomColorSpace(this[3]);
      if (PNGWritePlugin::WriteImageWithSession(v20, v21, v22, v23, SourceGeomColorSpace, v25))
      {
        LogError("writeAll", 170, "could not create ico for size %d x %d\n", *((_DWORD *)v17 - 2), *((_DWORD *)v17 - 2));
        goto LABEL_30;
      }
      *v18 = v16;
      Length = CFDataGetLength(*v17);
    }
    else
    {
      v26 = *(v17 - 3);
      v27 = *(v17 - 2);
      v28 = (IIODictionary *)IIOImagePlus::getSourceGeomColorSpace(this[3]);
      if (BMPWritePlugin::WriteImageWithSession(v20, v21, v26, v27, v28, v29))
      {
        LogError("writeAll", 191, "could not create ico for size %d x %d\n", *((_DWORD *)v17 - 2), *((_DWORD *)v17 - 2));
        goto LABEL_30;
      }
      *v18 = v16;
      v56.location = 0;
      v56.length = 14;
      CFDataReplaceBytes(*v17, v56, 0, 0);
      CFDataIncreaseLength(*v17, (*((_DWORD *)v17 - 2) * *((_DWORD *)v17 - 2)) >> 2);
      Length = CFDataGetLength(*v17);
    }
    *(v18 - 1) = Length;
    v16 += Length;
LABEL_30:
    (*(void (**)(IIOImageWriteSession *))(*(_QWORD *)v20 + 8))(v20);
    v17 += 5;
    v18 += 4;
    --v19;
  }
  while (v19);
  IIOImageWriteSession::putBytes(this[2], v48, 16 * v5);
  for (i = 0; i != v5; ++i)
  {
    v32 = (char *)&__base + 40 * i;
    MutableBytePtr = CFDataGetMutableBytePtr(*((CFMutableDataRef *)v32 + 4));
    v34 = CFDataGetLength(*((CFDataRef *)v32 + 4));
    v37 = *((_DWORD *)v32 + 6);
    v36 = v32 + 24;
    v35 = v37;
    if (v37 != 256
      && ((*((_DWORD *)MutableBytePtr + 2) = 2 * v35, v38 = *((unsigned __int16 *)MutableBytePtr + 7), v38 == 24)
       || v38 == 32))
    {
      IIOImageWriteSession::putBytes(this[2], MutableBytePtr, *(unsigned int *)MutableBytePtr);
      v39 = &MutableBytePtr[*(unsigned int *)MutableBytePtr];
      v40 = *v36;
      v41 = v40 * (*((unsigned __int16 *)MutableBytePtr + 7) >> 3);
      if ((int)v40 >= 1)
      {
        v42 = v40 + 1;
        do
          IIOImageWriteSession::putBytes(this[2], &v39[v41 * (unint64_t)(v42-- - 2)], v41);
        while (v42 > 1);
        LODWORD(v40) = *v36;
      }
      IIOImageWriteSession::putBytes(this[2], &v39[v41 * (unint64_t)v40], (v40 * v40) >> 2);
    }
    else
    {
      IIOImageWriteSession::putBytes(this[2], MutableBytePtr, v34);
    }
  }
  v43 = 0;
  v11 = v48;
LABEL_45:
  for (j = 32; j != 512; j += 40)
  {
    v45 = *(const void **)((char *)&__base + j);
    if (v45)
    {
      v46 = v11;
      CFRelease(v45);
      v11 = v46;
    }
  }
  if (v11)
    free(v11);
  return v43;
}

void sub_187FC49C8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C408329B462);
  _Unwind_Resume(a1);
}

uint64_t ___ZN14ICOWritePlugin8writeAllEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3;
  unsigned int v4;
  BOOL v5;
  unsigned int v6;

  v3 = *(_DWORD *)(a2 + 24);
  v4 = *(_DWORD *)(a3 + 24);
  v5 = v3 >= v4;
  if (v3 <= v4)
    v6 = 0;
  else
    v6 = -1;
  if (v5)
    return v6;
  else
    return 1;
}

uint64_t ICOWritePlugin::writeOne(ICOWritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967292;
}

void IIO_Writer_HEIF::~IIO_Writer_HEIF(IIO_Writer_HEIF *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

HEIFWritePlugin *IIO_Writer_HEIF::createWritePlugin(IIO_Writer_HEIF *this, IIOImageWriteSession *a2, IIOImageDestination *a3)
{
  const __CFString *v5;
  unsigned int v6;
  HEIFWritePlugin *v7;

  v5 = (const __CFString *)IIOImageDestination::utType(a3);
  if (CFStringCompare(v5, CFSTR("public.jpeg"), 0))
  {
    if (CFStringCompare(v5, CFSTR("public.avci"), 0))
    {
      v6 = 1752589105;
      if (CFStringCompare(v5, CFSTR("public.heic"), 0) && CFStringCompare(v5, CFSTR("public.heics"), 0))
      {
        if (CFStringCompare(v5, CFSTR("public.heif"), 0))
          v6 = 0;
        else
          v6 = 1785750887;
      }
    }
    else
    {
      v6 = 1635148593;
    }
  }
  else
  {
    v6 = 1785750887;
  }
  v7 = (HEIFWritePlugin *)operator new();
  HEIFWritePlugin::HEIFWritePlugin(v7, a2, a3, v6);
  return v7;
}

void sub_187FC4B5C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C4048267937);
  _Unwind_Resume(a1);
}

uint64_t IIO_Writer_HEIF::write(IIO_Writer_HEIF *this, void *a2, void *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = (*(uint64_t (**)(IIO_Writer_HEIF *, void *, void *))(*(_QWORD *)this + 8))(this, a2, a3);
  v4 = v3;
  if (!v3)
    return 4294967246;
  v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 16))(v3);
  (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  return v5;
}

void sub_187FC4BEC(void *a1)
{
  uint64_t v1;

  __cxa_begin_catch(a1);
  __cxa_end_catch();
  if (!v1)
    JUMPOUT(0x187FC4BD8);
  JUMPOUT(0x187FC4BC0);
}

uint64_t IIO_Writer_HEIF::canWriteDepth(IIO_Writer_HEIF *this)
{
  return 1;
}

uint64_t IIOReadPlugin::IIOReadPlugin(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6;
  IIOImageReadSession *v7;
  uint64_t v8;
  __int128 *v9;
  __int128 v10;
  __int128 v11;
  IIODictionary *v12;
  const __CFString *ObjectForKey;
  unsigned int v14;
  _DWORD *exception;

  *(_QWORD *)a1 = &off_1E1BACDE8;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_QWORD *)(a1 + 424) = 0;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  if ((IIO_XPCServer() & 1) == 0)
    abort();
  *(_BYTE *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  if (!a2)
    goto LABEL_12;
  if (!*(_QWORD *)(a2 + 24))
    goto LABEL_12;
  *(_BYTE *)(a1 + 40) = 1;
  v6 = operator new();
  IIOImageRead::IIOImageRead(v6, *(_QWORD *)(a2 + 24), 8, 0, 0, *(unsigned __int8 *)(a2 + 50));
  *(_QWORD *)(a1 + 32) = v6;
  v7 = (IIOImageReadSession *)operator new();
  IIOImageReadSession::IIOImageReadSession(v7, *(IIOImageRead **)(a1 + 32));
  *(_QWORD *)(a1 + 24) = v7;
  *(_QWORD *)(a1 + 184) = CFDataGetLength(*(CFDataRef *)(a2 + 24));
  if (!*(_QWORD *)(a1 + 32))
  {
LABEL_12:
    exception = __cxa_allocate_exception(4uLL);
    *exception = -1;
    __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
  }
  *(_OWORD *)(a1 + 48) = *(_OWORD *)a2;
  v8 = *(_QWORD *)(a2 + 16);
  v9 = (__int128 *)MEMORY[0x1E0C9D628];
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  v10 = *v9;
  v11 = v9[1];
  LOBYTE(v9) = *(_BYTE *)(a2 + 50);
  *(_OWORD *)(a1 + 120) = v10;
  *(_BYTE *)(a1 + 341) = (_BYTE)v9;
  *(_DWORD *)(a1 + 432) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 136) = v11;
  *(_QWORD *)(a1 + 64) = v8;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 152) = 0;
  *(_BYTE *)(a1 + 176) = IIOPluginShouldDebugWriteImageBlocks();
  *(_BYTE *)(a1 + 177) = IIOPluginShouldDebugWriteImageBlocks();
  *(_WORD *)(a1 + 376) = -1;
  *(_QWORD *)(a1 + 192) = *(_QWORD *)(a2 + 40);
  *(_BYTE *)(a1 + 355) = -1;
  *(_DWORD *)(a1 + 320) = -1;
  *(_WORD *)(a1 + 328) = 0;
  *(_QWORD *)(a1 + 332) = 0x2D2D2D2D00000000;
  *(_BYTE *)(a1 + 216) = *(_BYTE *)(a2 + 48);
  *(_QWORD *)(a1 + 208) = *(_QWORD *)(a2 + 32);
  *(_BYTE *)(a1 + 342) = 1;
  *(_WORD *)(a1 + 353) = 0;
  v12 = *(IIODictionary **)(a1 + 48);
  if (v12 && IIODictionary::containsKey(v12, CFSTR("kCGImageSourceDecodeRequest")))
  {
    ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey(*(IIODictionary **)(a1 + 48), CFSTR("kCGImageSourceDecodeRequest"));
    *(_BYTE *)(a1 + 353) = CFStringCompare(ObjectForKey, CFSTR("kCGImageSourceDecodeToSDR"), 0) == kCFCompareEqualTo;
    *(_BYTE *)(a1 + 354) = CFStringCompare(ObjectForKey, CFSTR("kCGImageSourceDecodeToHDR"), 0) == kCFCompareEqualTo;
  }
  if ((gIIODebugFlags & 0x20000000) != 0)
    v14 = (gIIODebugFlags >> 30) & 1;
  else
    LOBYTE(v14) = *(_BYTE *)(a2 + 49);
  *(_BYTE *)(a1 + 343) = v14;
  *(_BYTE *)(a1 + 344) = 1;
  *(_QWORD *)(a1 + 384) = 0;
  *(_QWORD *)(a1 + 392) = 0;
  *(_QWORD *)(a1 + 404) = -1;
  *(_DWORD *)(a1 + 400) = 538976288;
  *(_WORD *)(a1 + 413) = 256;
  *(_DWORD *)(a1 + 204) = a3;
  return a1;
}

void sub_187FC4EB0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C40DD5C407ELL);
  _Unwind_Resume(a1);
}

uint64_t IIOReadPlugin::freeBlockArray(IIOReadPlugin *this)
{
  void *v2;

  v2 = (void *)*((_QWORD *)this + 12);
  if (v2)
    free(v2);
  *((_QWORD *)this + 12) = 0;
  *((_DWORD *)this + 26) = 0;
  return 0;
}

uint64_t IIOReadPlugin::initialize(IIOReadPlugin *this, IIODictionary *a2)
{
  int v2;
  unsigned int v3;
  uint64_t v4;
  int v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v2 = *((_DWORD *)this + 51);
  v3 = v2 >> 24;
  v4 = MEMORY[0x1E0C80978];
  if (v2 < 0)
    v5 = __maskrune(v2 >> 24, 0x40000uLL);
  else
    v5 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v3 + 60) & 0x40000;
  v6 = v2 << 8 >> 24;
  if (v2 << 8 < 0)
    v7 = __maskrune(v2 << 8 >> 24, 0x40000uLL);
  else
    v7 = *(_DWORD *)(v4 + 4 * v6 + 60) & 0x40000;
  v8 = (__int16)v2 >> 8;
  if (v2 << 16 < 0)
    v9 = __maskrune((__int16)v2 >> 8, 0x40000uLL);
  else
    v9 = *(_DWORD *)(v4 + 4 * v8 + 60) & 0x40000;
  if ((v2 << 24) <= 0x7F000000)
    v10 = *(_DWORD *)(v4 + 4 * (char)v2 + 60) & 0x40000;
  else
    v10 = __maskrune((char)v2, 0x40000uLL);
  if (v9)
    v11 = v8;
  else
    v11 = 46;
  if (v7)
    v12 = v6;
  else
    v12 = 46;
  if (v5)
    v13 = v3;
  else
    v13 = 46;
  if (v10)
    v14 = (char)v2;
  else
    v14 = 46;
  _cg_jpeg_mem_term("initialize", 470, "*** [%c%c%c%c] plugin did not implement 'initialize' ***\n", v13, v12, v11, v14);
  return 4294967240;
}

uint64_t IIOReadPlugin::copyAuxiliaryDataInfo(IIOReadPlugin *this, unsigned int a2, const __CFString *a3, IIODictionary *a4)
{
  return 0;
}

void IIOReadPlugin::updateTempColorSpace(IIOReadPlugin *this)
{
  const __CFDictionary *ObjectForKey;
  CGColorSpaceRef v3;
  const void *v4;
  _QWORD v5[3];

  memset(v5, 0, sizeof(v5));
  IIODictionary::IIODictionary((IIODictionary *)v5, *((__CFDictionary **)this + 19));
  if (IIODictionary::containsKey((IIODictionary *)v5, CFSTR("TEMP_COLORSPACE")))
  {
    ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v5, CFSTR("TEMP_COLORSPACE"));
    v3 = CGColorSpaceCreateWithPropertyList(ObjectForKey);
    if (v3)
    {
      CGColorSpaceRelease(*((CGColorSpaceRef *)this + 20));
      *((_QWORD *)this + 20) = v3;
      if (CGColorSpaceContainsFlexGTCInfo())
      {
        *(_WORD *)((char *)this + 351) = 1;
        v4 = (const void *)*((_QWORD *)this + 21);
        if (v4)
          CFRelease(v4);
        *((_QWORD *)this + 21) = CGColorSpaceCopyFlexGTCInfo();
      }
    }
  }
  IIODictionary::~IIODictionary((IIODictionary *)v5);
}

void sub_187FC5140(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOReadPlugin::getColorSpace(IIOReadPlugin *this)
{
  return *((_QWORD *)this + 20);
}

uint64_t IIOReadPlugin::getColorSpaceModel(IIOReadPlugin *this)
{
  return *((unsigned int *)this + 80);
}

uint64_t ___ZN13IIOReadPlugin17readOnlyRequestedEv_block_invoke()
{
  return _cg_jpeg_mem_term("readOnlyRequested_block_invoke", 643, "*** dDebugBlockSet was set - ignoring 'kCGImageBlockMarkAsReadOnlyRequest'\n");
}

uint64_t IIOReadPlugin::createPixelConverter(IIOReadPlugin *this)
{
  uint64_t v1;
  _QWORD v3[2];

  v3[0] = (*(uint64_t (**)(IIOReadPlugin *))(*(_QWORD *)this + 48))(this);
  v3[1] = v1;
  return ImageIOPixelConverter::CreatePixelConverter((uint64_t)v3);
}

uint64_t IIOReadPlugin::createFlexGTCInfo(IIOReadPlugin *this, IIODictionary *a2, const __CFDictionary **a3)
{
  return 4294967292;
}

uint64_t IIOReadPlugin::updateColorSpace(uint64_t a1, CFDictionaryRef *a2)
{
  float FloatForKeyGroup;
  uint64_t CopyWithFlexGTCInfo;
  float v6;
  _DWORD v8[4];
  void *v9;
  void *value[3];

  if (*(_BYTE *)(a1 + 352))
  {
    if ((gIIODebugFlags & 0x300000) != 0)
      ImageIOLog("  _colorSpaceIsFlexGTCProxy - now creating a FlexGTC colorspace...\n");
    memset(value, 0, sizeof(value));
    IIODictionary::IIODictionary((IIODictionary *)value);
    IIODictionary::setObjectForKey((IIODictionary *)value, *(const void **)(a1 + 160), CFSTR("kCGFlexRangeAlternateColorSpace"));
    if (IIODictionary::containsKeyGroup(*(IIODictionary **)(a1 + 48), CFSTR("kCGTargetHeadroom"), CFSTR("kCGImageSourceDecodeRequestOptions")))
    {
      FloatForKeyGroup = IIODictionary::getFloatForKeyGroup(*(IIODictionary **)(a1 + 48), CFSTR("kCGTargetHeadroom"), CFSTR("kCGImageSourceDecodeRequestOptions"));
      IIONumber::IIONumber((IIONumber *)v8, FloatForKeyGroup);
      IIODictionary::setObjectForKey((IIODictionary *)value, v9, CFSTR("kCGTargetHeadroom"));
      IIONumber::~IIONumber((IIONumber *)v8);
    }
    if (*(_QWORD *)(a1 + 168)
      || !(*(unsigned int (**)(uint64_t, void **, uint64_t))(*(_QWORD *)a1 + 168))(a1, value, a1 + 168))
    {
      CopyWithFlexGTCInfo = IIO_ColorSpaceCreateCopyWithFlexGTCInfo();
      CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 160));
      *(_QWORD *)(a1 + 160) = CopyWithFlexGTCInfo;
      v8[0] = 0;
      CGColorSpaceGetHeadroomInfo();
      *(float *)(a1 + 332) = v6;
      if ((gIIODebugFlags & 0x300000) != 0)
        ImageIOLog("  updateColorSpace: - FlexGTC colorspace - headroom: %g\n", v6);
    }
    IIODictionary::~IIODictionary((IIODictionary *)value);
  }
  if (!*(_QWORD *)(a1 + 160))
  {
    value[0] = 0;
    if (a2)
    {
      CFDictionaryGetValueIfPresent(*a2, CFSTR("TEMP_COLORSPACE"), (const void **)value);
      if (value[0])
        *(_QWORD *)(a1 + 160) = CGColorSpaceCreateWithPropertyList(value[0]);
    }
  }
  return 0;
}

void sub_187FC5368(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  _Unwind_Resume(a1);
}

const char *IIOReadPlugin::debugGeometry(uint64_t a1, __int128 *a2, IIODictionary *this)
{
  unsigned int Uint32ForKey;
  int v7;
  unsigned int v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  char *v23;
  int v24;
  int v25;
  int v26;
  unsigned int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  char *v33;
  int v34;
  int v35;
  int v36;
  int v37;
  unsigned int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  char *v44;
  __int128 v46;
  int v47;

  if (a2)
  {
    if (this
      && IIODictionary::containsKey(this, CFSTR("kImageIOInfoHeader_createImageProviderWithBitmapInfo")))
    {
      Uint32ForKey = IIODictionary::getUint32ForKey(this, CFSTR("kImageIOInfoHeader_createImageProviderWithBitmapInfo"));
    }
    else
    {
      Uint32ForKey = *((_DWORD *)a2 + 15) | *((_DWORD *)a2 + 14);
    }
  }
  else
  {
    Uint32ForKey = 0;
  }
  ImageIOLog("                             x     y     w     h       rb   bpp   bpc    #c     a        bmi   bitmapInfo\n");
  ImageIOLog("           -----------   ----- ----- ----- -----   ------   ---   ---   ---   ---   --------   ---------------------\n");
  if (a2)
  {
    v7 = *((_DWORD *)a2 + 10);
    v8 = v7 >> 24;
    v9 = MEMORY[0x1E0C80978];
    if (v7 < 0)
    {
      v10 = __maskrune(v8, 0x40000uLL);
      v7 = *((_DWORD *)a2 + 10);
    }
    else
    {
      v10 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v8 + 60) & 0x40000;
    }
    if (v10)
      v11 = (v7 >> 24);
    else
      v11 = 46;
    v12 = v7 << 8 >> 24;
    if (v7 << 8 < 0)
    {
      v13 = __maskrune(v12, 0x40000uLL);
      v7 = *((_DWORD *)a2 + 10);
    }
    else
    {
      v13 = *(_DWORD *)(v9 + 4 * v12 + 60) & 0x40000;
    }
    if (v13)
      v14 = (v7 << 8 >> 24);
    else
      v14 = 46;
    v15 = (__int16)v7 >> 8;
    if (v7 << 16 < 0)
    {
      v16 = __maskrune(v15, 0x40000uLL);
      v7 = *((_DWORD *)a2 + 10);
    }
    else
    {
      v16 = *(_DWORD *)(v9 + 4 * v15 + 60) & 0x40000;
    }
    if (v16)
      v17 = ((__int16)v7 >> 8);
    else
      v17 = 46;
    if ((v7 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v9 + 4 * (char)v7 + 60) & 0x40000) != 0)
        goto LABEL_28;
    }
    else if (__maskrune((char)v7, 0x40000uLL))
    {
LABEL_28:
      v18 = *((char *)a2 + 40);
LABEL_31:
      v46 = *a2;
      v20 = *((_QWORD *)a2 + 3);
      v19 = *((_QWORD *)a2 + 4);
      v21 = *((_QWORD *)a2 + 2);
      v22 = *((_DWORD *)a2 + 14);
      v23 = IIO_BitmapInfoStringSmall(Uint32ForKey);
      ImageIOLog("           iPlus '%c%c%c%c'              %5d %5d   %6d   %3d   %3d         %3d   %08X   %s\n", v11, v14, v17, v18, (_DWORD)v46, DWORD2(v46), v19, v20, v21, v22, Uint32ForKey, v23);
      goto LABEL_32;
    }
    v18 = 46;
    goto LABEL_31;
  }
LABEL_32:
  v47 = *(unsigned __int16 *)(a1 + 242);
  v24 = *(unsigned __int16 *)(a1 + 240);
  v25 = *(unsigned __int16 *)(a1 + 244);
  v26 = *(unsigned __int8 *)(a1 + 246);
  v27 = (*(unsigned __int8 *)(a1 + 248) << 16) | (*(unsigned __int8 *)(a1 + 247) << 12) | ((*(_BYTE *)(a1 + 249) != 0) << 8) | v26;
  v28 = *(_DWORD *)(a1 + 220);
  v29 = *(_DWORD *)(a1 + 224);
  v30 = *(_DWORD *)(a1 + 228);
  v31 = *(_DWORD *)(a1 + 232);
  v32 = *(_DWORD *)(a1 + 236);
  v33 = IIO_BitmapInfoStringSmall(v27);
  ImageIOLog("             _inputGeo   %5d %5d %5d %5d   %6d   %3d   %3d   %3d   %3d   %08X   %s\n", v28, v29, v30, v31, v32, v47, v24, v25, v26, v27, v33);
  v34 = *(unsigned __int16 *)(a1 + 274);
  v35 = *(unsigned __int16 *)(a1 + 272);
  v36 = *(unsigned __int16 *)(a1 + 276);
  v37 = *(unsigned __int8 *)(a1 + 278);
  v38 = (*(unsigned __int8 *)(a1 + 280) << 16) | (*(unsigned __int8 *)(a1 + 279) << 12) | ((*(_BYTE *)(a1 + 281) != 0) << 8) | v37;
  v39 = *(_DWORD *)(a1 + 252);
  v40 = *(_DWORD *)(a1 + 256);
  v41 = *(_DWORD *)(a1 + 260);
  v42 = *(_DWORD *)(a1 + 264);
  v43 = *(_DWORD *)(a1 + 268);
  v44 = IIO_BitmapInfoStringSmall(v38);
  return ImageIOLog("           _decodedGeo   %5d %5d %5d %5d   %6d   %3d   %3d   %3d   %3d   %08X   %s\n", v39, v40, v41, v42, v43, v34, v35, v36, v37, v38, v44);
}

uint64_t IIOReadPlugin::canCreateChromaSubsampledIOSurface(IIOReadPlugin *this)
{
  return 0;
}

uint64_t IIOReadPlugin::getPixelFormat(IIOReadPlugin *this)
{
  int v2;
  int v3;
  unsigned int v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  int v20;
  uint64_t v21;
  unsigned int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;

  v2 = (*(uint64_t (**)(IIOReadPlugin *))(*(_QWORD *)this + 32))(this);
  v3 = *((_DWORD *)this + 81);
  if (v3 == 1196573017)
  {
    v5 = 1278226488;
    v6 = *((unsigned __int16 *)this + 152);
    if (v6 == 8)
      goto LABEL_37;
    if (v6 == 32)
    {
      v5 = 1278226534;
      goto LABEL_37;
    }
    if (v6 != 16)
    {
      _cg_jpeg_mem_term("getPixelFormat", 1413, " GRAY - bitdepth %d not handled\n");
      goto LABEL_36;
    }
    if (*((_BYTE *)this + 345))
      v5 = 1278226536;
    else
      v5 = 1278226742;
  }
  else
  {
    if (v3 != 1380401696)
    {
      if (v3 < 0)
      {
        __maskrune(v3 >> 24, 0x40000uLL);
        v3 = *((_DWORD *)this + 81);
      }
      if (v3 << 8 < 0)
      {
        __maskrune(v3 << 8 >> 24, 0x40000uLL);
        v3 = *((_DWORD *)this + 81);
      }
      if (v3 << 16 < 0)
      {
        __maskrune((__int16)v3 >> 8, 0x40000uLL);
        v3 = *((_DWORD *)this + 81);
      }
      if ((v3 << 24) > 0x7F000000)
        __maskrune((char)v3, 0x40000uLL);
      _cg_jpeg_mem_term("getPixelFormat", 1418, " colormodel '%c%c%c%c' not handled\n");
      goto LABEL_36;
    }
    v4 = *((unsigned __int16 *)this + 152);
    if (v4 > 0xF)
    {
      v5 = 1380410945;
      if (v4 != 16)
      {
        if (v4 == 32)
          goto LABEL_37;
LABEL_18:
        _cg_jpeg_mem_term("getPixelFormat", 1393, " RGB - bitdepth %d not handled\n");
LABEL_36:
        v5 = 0;
        goto LABEL_37;
      }
      if (*((_BYTE *)this + 345))
        v5 = 1380411457;
      else
        v5 = 1815491698;
    }
    else
    {
      if (v4 != 8)
      {
        if (v4 == 10)
        {
          if ((v2 & 1) != 0)
          {
            v5 = 2019963440;
            goto LABEL_37;
          }
          _cg_jpeg_mem_term("getPixelFormat", 1380, " RGB - bitdepth %d not handled\n");
          goto LABEL_36;
        }
        goto LABEL_18;
      }
      if (v2)
        v5 = 875704422;
      else
        v5 = 1111970369;
    }
  }
LABEL_37:
  v7 = *((_DWORD *)this + 84);
  if ((_DWORD)v5 != v7)
  {
    v8 = MEMORY[0x1E0C80978];
    v9 = MEMORY[0x1E0C80978] + 60;
    if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 60 + 4 * BYTE3(v5)) & 0x40000) != 0)
      v10 = BYTE3(v5);
    else
      v10 = 46;
    v11 = WORD1(v5) & 0x77;
    if ((*(_DWORD *)(v9 + 4 * v11) & 0x40000) != 0)
      v12 = v11;
    else
      v12 = 46;
    v13 = (v5 >> 8) & 0x7F;
    if ((*(_DWORD *)(v9 + 4 * v13) & 0x40000) != 0)
      v14 = v13;
    else
      v14 = 46;
    if ((*(_DWORD *)(v9 + 4 * (v5 & 0x7F)) & 0x40000) != 0)
      v15 = v5 & 0x7F;
    else
      v15 = 46;
    v16 = v7 >> 24;
    if (v7 < 0)
    {
      v17 = __maskrune(v16, 0x40000uLL);
      v7 = *((_DWORD *)this + 84);
    }
    else
    {
      v17 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v16 + 60) & 0x40000;
    }
    if (v17)
      v18 = (v7 >> 24);
    else
      v18 = 46;
    v19 = v7 << 8 >> 24;
    if (v7 << 8 < 0)
    {
      v20 = __maskrune(v19, 0x40000uLL);
      v7 = *((_DWORD *)this + 84);
    }
    else
    {
      v20 = *(_DWORD *)(v8 + 4 * v19 + 60) & 0x40000;
    }
    if (v20)
      v21 = (v7 << 8 >> 24);
    else
      v21 = 46;
    v22 = (__int16)v7 >> 8;
    if (v7 << 16 < 0)
    {
      v23 = __maskrune(v22, 0x40000uLL);
      v7 = *((_DWORD *)this + 84);
    }
    else
    {
      v23 = *(_DWORD *)(v8 + 4 * v22 + 60) & 0x40000;
    }
    if (v23)
      v24 = ((__int16)v7 >> 8);
    else
      v24 = 46;
    if ((v7 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v8 + 4 * (char)v7 + 60) & 0x40000) != 0)
        goto LABEL_70;
    }
    else if (__maskrune((char)v7, 0x40000uLL))
    {
LABEL_70:
      v25 = *((char *)this + 336);
LABEL_73:
      _cg_jpeg_mem_term("getPixelFormat", 1421, " pixelFormat: '%c%c%c%c'   _rpd.pixelFormat: '%c%c%c%c'\n", v10, v12, v14, v15, v18, v21, v24, v25);
      return v5;
    }
    v25 = 46;
    goto LABEL_73;
  }
  return v5;
}

void IIOReadPlugin::printRequests(IIOReadPlugin *this, const __CFDictionary *a2)
{
  const char *v3;
  int v4;
  unsigned int v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  std::string *v17;
  std::string v18;

  if (*((_BYTE *)this + 414))
    v3 = "true";
  else
    v3 = "false";
  ImageIOLog("    reqAreValid: %s\n", v3);
  v4 = *((_DWORD *)this + 100);
  v5 = v4 >> 24;
  v6 = MEMORY[0x1E0C80978];
  if (v4 < 0)
  {
    v7 = __maskrune(v5, 0x40000uLL);
    v4 = *((_DWORD *)this + 100);
  }
  else
  {
    v7 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v5 + 60) & 0x40000;
  }
  if (v7)
    v8 = (v4 >> 24);
  else
    v8 = 46;
  v9 = v4 << 8 >> 24;
  if (v4 << 8 < 0)
  {
    v10 = __maskrune(v9, 0x40000uLL);
    v4 = *((_DWORD *)this + 100);
  }
  else
  {
    v10 = *(_DWORD *)(v6 + 4 * v9 + 60) & 0x40000;
  }
  if (v10)
    v11 = (v4 << 8 >> 24);
  else
    v11 = 46;
  v12 = (__int16)v4 >> 8;
  if (v4 << 16 < 0)
  {
    v13 = __maskrune(v12, 0x40000uLL);
    v4 = *((_DWORD *)this + 100);
  }
  else
  {
    v13 = *(_DWORD *)(v6 + 4 * v12 + 60) & 0x40000;
  }
  if (v13)
    v14 = ((__int16)v4 >> 8);
  else
    v14 = 46;
  if ((v4 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v6 + 4 * (char)v4 + 60) & 0x40000) != 0)
      goto LABEL_24;
  }
  else if (__maskrune((char)v4, 0x40000uLL))
  {
LABEL_24:
    v15 = *((char *)this + 400);
    goto LABEL_27;
  }
  v15 = 46;
LABEL_27:
  ImageIOLog("    format:      %c%c%c%c\n", v8, v11, v14, v15);
  if (*((_BYTE *)this + 412))
    v16 = "true";
  else
    v16 = "false";
  ImageIOLog("    wantsFloat:  %s\n", v16);
  ImageIOLog("    requests:    BGRx8       RGBX8888    premult     readOnly    single      addrAlign   addrAlign   cache\n");
  memset(&v18, 0, sizeof(v18));
  std::string::basic_string[abi:ne180100]<0>(&v18, "                 ");
  std::string::append(&v18, off_1E1BC4A80[*((char *)this + 404) + 1]);
  std::string::append(&v18, off_1E1BC4A80[*((char *)this + 405) + 1]);
  std::string::append(&v18, off_1E1BC4A80[*((char *)this + 406) + 1]);
  std::string::append(&v18, off_1E1BC4A80[*((char *)this + 407) + 1]);
  std::string::append(&v18, off_1E1BC4A80[*((char *)this + 408) + 1]);
  std::string::append(&v18, off_1E1BC4A80[*((char *)this + 409) + 1]);
  std::string::append(&v18, off_1E1BC4A80[*((char *)this + 410) + 1]);
  std::string::append(&v18, off_1E1BC4A80[*((char *)this + 411) + 1]);
  if ((v18.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v17 = &v18;
  else
    v17 = (std::string *)v18.__r_.__value_.__r.__words[0];
  ImageIOLog("%s\n", (const char *)v17);
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v18.__r_.__value_.__l.__data_);
}

void sub_187FC5CE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t IIOReadPlugin::setIPlus(IIOReadPlugin *this, IIOImagePlus *a2, IIOImageReadSession *a3)
{
  uint64_t result;

  *((_QWORD *)this + 2) = a2;
  *((_QWORD *)this + 3) = a3;
  result = IIO_Reader::testHeaderSize(a3);
  *((_QWORD *)this + 4) = result;
  return result;
}

uint64_t IIOReadPlugin::validateReadPluginData(IIOReadPlugin *this)
{
  uint64_t v2;

  if (!IIOGeometry::isValid((IIOReadPlugin *)((char *)this + 220)))
    return 4294967246;
  v2 = 4294967246;
  if (IIOGeometry::isValid((IIOReadPlugin *)((char *)this + 252)))
  {
    if (IIOGeometry::isValid((IIOReadPlugin *)((char *)this + 284)))
      return 0;
    else
      return 4294967246;
  }
  return v2;
}

uint64_t IIOReadPlugin::loadDataFromXPCObject(IIOReadPlugin *this, xpc_object_t xdict)
{
  _OWORD *data;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t PluginData;
  size_t length;

  length = 0;
  data = xpc_dictionary_get_data(xdict, "iio_xpc_plugin_data", &length);
  if (length != 248)
    return 4294967246;
  v4 = *data;
  v5 = data[1];
  v6 = data[2];
  *(_OWORD *)((char *)this + 232) = data[3];
  *(_OWORD *)((char *)this + 216) = v6;
  *(_OWORD *)((char *)this + 200) = v5;
  *(_OWORD *)((char *)this + 184) = v4;
  v7 = data[4];
  v8 = data[5];
  v9 = data[7];
  *(_OWORD *)((char *)this + 280) = data[6];
  *(_OWORD *)((char *)this + 296) = v9;
  *(_OWORD *)((char *)this + 264) = v8;
  *(_OWORD *)((char *)this + 248) = v7;
  v10 = data[8];
  v11 = data[9];
  v12 = data[11];
  *(_OWORD *)((char *)this + 344) = data[10];
  *(_OWORD *)((char *)this + 360) = v12;
  *(_OWORD *)((char *)this + 312) = v10;
  *(_OWORD *)((char *)this + 328) = v11;
  v13 = data[12];
  v14 = data[13];
  v15 = data[14];
  *((_QWORD *)this + 53) = *((_QWORD *)data + 30);
  *(_OWORD *)((char *)this + 392) = v14;
  *(_OWORD *)((char *)this + 408) = v15;
  *(_OWORD *)((char *)this + 376) = v13;
  PluginData = IIOReadPlugin::validateReadPluginData(this);
  if (IIO_XPCServer())
    *((_DWORD *)this + 108) = xpc_dictionary_copy_mach_send();
  return PluginData;
}

uint64_t IIOReadPlugin::saveDataToXPCObject(IIOReadPlugin *this, void *a2)
{
  iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data", (char *)this + 184, 0xF8uLL);
  if ((IIO_XPCServer() & 1) == 0)
  {
    if (IIOReadPlugin::saveDataToXPCObject(void *)::onceToken != -1)
      dispatch_once(&IIOReadPlugin::saveDataToXPCObject(void *)::onceToken, &__block_literal_global_85);
    xpc_dictionary_set_mach_send();
  }
  return 0;
}

uint64_t IIOReadPlugin::addImageBlocksToXPCObject(IIOReadPlugin *this, void *a2)
{
  const void *v3;
  xpc_object_t empty;
  unint64_t v5;
  _QWORD *v6;
  uint64_t BytesPerRow;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  void *Data;
  size_t v17;
  xpc_object_t v18;
  xpc_object_t v19;
  void *v20;
  xpc_object_t v21;
  uint64_t v22;
  void *v23;

  v3 = (const void *)*((_QWORD *)this + 12);
  if (*((_DWORD *)this + 26) && v3)
  {
    empty = xpc_array_create_empty();
    if (*((_DWORD *)this + 26))
    {
      v5 = 0;
      do
      {
        v6 = (_QWORD *)*((_QWORD *)this + 12);
        if (v6[v5])
        {
          BytesPerRow = CGImageBlockGetBytesPerRow();
          CGImageBlockGetRect();
          v9 = v8;
          v11 = v10;
          v13 = v12;
          v15 = v14;
          Data = (void *)CGImageBlockGetData();
          v17 = (unint64_t)(v15 * (double)BytesPerRow);
          v18 = xpc_dictionary_create_empty();
          v19 = xpc_shmem_create(Data, v17);
          if (v19)
          {
            v20 = v19;
            xpc_dictionary_set_value(v18, "iio_xpc_cb_decode_image_buffer", v19);
            xpc_dictionary_set_uint64(v18, "iio_xpc_cb_decode_image_buffer_size", v17);
            xpc_release(v20);
          }
          iio_xpc_dictionary_addCGRect(v18, "iio_xpc_cb_block_cgrect", v9, v11, v13, v15);
          xpc_dictionary_set_uint64(v18, "iio_xpc_cb_block_rowbytes", BytesPerRow);
          CGImageBlockRelease();
          xpc_array_append_value(empty, v18);
          xpc_release(v18);
        }
        else
        {
          LogError("addImageBlocksToXPCObject", 1839, "*** ERROR: _blockArray: %p    _blockArray[%d]: %p\n", v6, v5, 0);
        }
        ++v5;
      }
      while (v5 < *((unsigned int *)this + 26));
    }
    v21 = iio_xpc_add_callback_dict(a2);
    xpc_dictionary_set_value(v21, "iio_xpc_cb_blockset", empty);
    xpc_release(empty);
    v22 = 0;
  }
  else
  {
    LogError("addImageBlocksToXPCObject", 1828, "*** ERROR: _blockCount is 0   (_blockArray: %p)\n", v3);
    v22 = 4294967243;
  }
  v23 = (void *)*((_QWORD *)this + 12);
  if (v23)
    free(v23);
  *((_QWORD *)this + 12) = 0;
  *((_DWORD *)this + 26) = 0;
  return v22;
}

uint64_t IIOReadPlugin::allocateBlockArray(IIOReadPlugin *this, size_t size)
{
  unsigned int v2;
  void *v4;
  int v5;
  void *v7;
  uint64_t result;

  v2 = size;
  v4 = (void *)*((_QWORD *)this + 12);
  if (v4)
    free(v4);
  *((_QWORD *)this + 12) = 0;
  v5 = *((_DWORD *)this + 26);
  if (v5 != v2 || v5 == 0)
    return 4294967246;
  v7 = malloc_type_calloc(8uLL, v2, 0x5CEA8685uLL);
  result = 0;
  *((_QWORD *)this + 12) = v7;
  return result;
}

xpc_object_t IIOReadPlugin::createImageBlockSetFromXPCObject(uint64_t a1, void *a2, const void *a3, uint64_t a4)
{
  xpc_object_t result;
  xpc_object_t value;
  size_t count;
  size_t v10;
  double v11;
  double v12;
  double v13;
  double v14;
  xpc_object_t v15;
  double v16;
  double v17;
  double v18;
  double v19;
  CGFloat v20;
  CGFloat v21;
  double v22;
  double v23;
  uint64_t uint64;
  xpc_object_t v25;
  uint64_t v26;
  uint64_t v27;
  size_t v28;
  unint64_t v29;
  uint64_t v30;
  const void *v31;
  void *region;
  CGRect v33;
  CGRect v34;
  CGRect v35;

  result = iio_xpc_get_callback_dict(a2);
  if (!result)
    return result;
  value = xpc_dictionary_get_value(result, "iio_xpc_cb_blockset");
  count = xpc_array_get_count(value);
  *(_DWORD *)(a1 + 104) = count;
  if (!(_DWORD)count)
  {
    ImageIOLog("*** ERROR: _blockCount == 0 -- decode failed?\n");
    return 0;
  }
  if (IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, count))
    return 0;
  v30 = a4;
  v31 = a3;
  if (*(_DWORD *)(a1 + 104))
  {
    v10 = 0;
    v11 = 0.0;
    v12 = 0.0;
    v13 = 0.0;
    v14 = 0.0;
    while (1)
    {
      v15 = xpc_array_get_value(value, v10);
      v16 = iio_xpc_dictionary_get_CGRect(v15, "iio_xpc_cb_block_cgrect");
      v20 = v16;
      v21 = v17;
      v22 = v18;
      v23 = v19;
      if (v10)
      {
        v33.origin.x = v11;
        v33.origin.y = v12;
        v33.size.width = v13;
        v33.size.height = v14;
        v35.origin.x = v20;
        v35.origin.y = v21;
        v35.size.width = v22;
        v35.size.height = v23;
        *(CGRect *)&v16 = CGRectUnion(v33, v35);
      }
      v14 = v19;
      v11 = v16;
      v12 = v17;
      v13 = v18;
      uint64 = xpc_dictionary_get_uint64(v15, "iio_xpc_cb_block_rowbytes");
      v25 = xpc_dictionary_get_value(v15, "iio_xpc_cb_decode_image_buffer");
      v26 = xpc_dictionary_get_uint64(v15, "iio_xpc_cb_decode_image_buffer_size");
      if (v22 * v23 > (double)v26 || v23 * (double)uint64 > (double)v26)
        break;
      if (v25)
      {
        v27 = v26;
        if (v26)
        {
          region = 0;
          v28 = xpc_shmem_map(v25, &region);
          if (region)
          {
            if (v28 >= v27)
            {
              _ImageIO_AccreditMemory((uint64_t)region, v28);
              v34.origin.x = v20;
              v34.origin.y = v21;
              v34.size.width = v22;
              v34.size.height = v23;
              *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8 * v10) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, region, v28, v34, uint64, 1);
            }
          }
        }
      }
      ++v10;
      v29 = *(unsigned int *)(a1 + 104);
      if (v10 >= v29)
        return (xpc_object_t)IIOReadPlugin::imageBlockSetCreate(a1, v30, v29, v13, v14, v11, v12, v13, v14, *(_QWORD *)(a1 + 96), v31);
    }
    return 0;
  }
  v29 = 0;
  v14 = 0.0;
  v13 = 0.0;
  v12 = 0.0;
  v11 = 0.0;
  return (xpc_object_t)IIOReadPlugin::imageBlockSetCreate(a1, v30, v29, v13, v14, v11, v12, v13, v14, *(_QWORD *)(a1 + 96), v31);
}

uint64_t IIOReadPlugin::debugBlockSetAlpha(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t result;
  int v6;
  uint64_t v7;
  char v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  uint64_t Data;
  unsigned int v18;
  double v19;
  unsigned int v20;
  double v21;
  double v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int *v25;
  unsigned __int8 v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  char v32;
  char v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  int v51;
  unsigned int v52;
  unsigned int v53;
  int v54;
  uint64_t v55;
  int v56;

  result = CGImageProviderGetAlphaInfo();
  v56 = result;
  if (*(_DWORD *)(a1 + 320) != 1)
    return result;
  if ((result - 1) >= 2)
  {
    if (*(_BYTE *)(a1 + 404) != 1 || a3 == 0)
      return result;
  }
  else if (!a3)
  {
    return result;
  }
  v6 = 0;
  v7 = 0;
  v8 = 1;
  do
  {
    CGImageBlockGetRect();
    v10 = v9;
    v12 = v11;
    v14 = v13;
    v16 = v15;
    Data = CGImageBlockGetData();
    result = CGImageBlockGetBytesPerRow();
    v18 = v12;
    v19 = v12 + v16;
    v51 = v6;
    if (v19 > (double)v18)
    {
      v54 = result;
      v55 = Data;
      v20 = v10;
      v21 = v10 + v14;
      v52 = v20;
      v53 = v18;
      v22 = (double)v20;
      v23 = v18;
      do
      {
        if (v21 > v22)
        {
          v24 = v52;
          v25 = (unsigned int *)(Data + (v23 - v53) * v54);
          do
          {
            v27 = *v25++;
            v26 = v27;
            v28 = v27 >> 8;
            v29 = HIWORD(v27);
            v30 = HIBYTE(v27);
            v31 = v27;
            v32 = BYTE1(v27);
            v33 = BYTE2(v27);
            if (v56 == 2)
              v34 = v31;
            else
              v34 = v30;
            if (v56 == 2)
            {
              LOBYTE(v29) = v32;
              LOBYTE(v28) = v33;
              v26 = v30;
            }
            v35 = v29;
            v36 = v28;
            v37 = v26;
            if (v29 > v34 || v28 > v34 || v26 > v34)
            {
              if ((v8 & 1) != 0)
                puts("*** BAD premultiplied alpha data R, G, and B values should be smaller than Alpha");
              v40 = 60;
              if (v37 <= v34)
                v41 = 32;
              else
                v41 = 60;
              v49 = v41;
              if (v37 <= v34)
                v42 = 32;
              else
                v42 = 62;
              v48 = v42;
              if (v36 <= v34)
                v43 = 32;
              else
                v43 = 60;
              v47 = v43;
              if (v36 <= v34)
                v44 = 32;
              else
                v44 = 62;
              if (v35 <= v34)
                v40 = 32;
              v46 = v44;
              if (v35 <= v34)
                v45 = 32;
              else
                v45 = 62;
              result = printf("[%3d:%3d]  %c%02X%c  %c%02X%c   %c%02X%c   %02X\n", v24, v23, v45, v35, v40, v46, v36, v47, v48, v37, v49, v34);
              if (v7 > 98)
                return puts("*** BAD premultiplied alpha (stopped logging after 100 bad pixels)");
              v8 = 0;
              ++v7;
            }
            ++v24;
          }
          while (v21 > (double)v24);
        }
        ++v23;
        Data = v55;
      }
      while (v19 > (double)v23);
    }
    v6 = v51 + 1;
  }
  while ((v51 + 1) < a3);
  return result;
}

uint64_t IIOReadPlugin::copyImageBlockSet(uint64_t a1)
{
  int v1;
  unsigned int v2;
  uint64_t v3;
  int v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v1 = *(_DWORD *)(a1 + 204);
  v2 = v1 >> 24;
  v3 = MEMORY[0x1E0C80978];
  if (v1 < 0)
    v4 = __maskrune(v1 >> 24, 0x40000uLL);
  else
    v4 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v2 + 60) & 0x40000;
  v5 = v1 << 8 >> 24;
  if (v1 << 8 < 0)
    v6 = __maskrune(v1 << 8 >> 24, 0x40000uLL);
  else
    v6 = *(_DWORD *)(v3 + 4 * v5 + 60) & 0x40000;
  v7 = (__int16)v1 >> 8;
  if (v1 << 16 < 0)
    v8 = __maskrune((__int16)v1 >> 8, 0x40000uLL);
  else
    v8 = *(_DWORD *)(v3 + 4 * v7 + 60) & 0x40000;
  if ((v1 << 24) <= 0x7F000000)
    v9 = *(_DWORD *)(v3 + 4 * (char)v1 + 60) & 0x40000;
  else
    v9 = __maskrune((char)v1, 0x40000uLL);
  if (v8)
    v10 = v7;
  else
    v10 = 46;
  if (v6)
    v11 = v5;
  else
    v11 = 46;
  if (v4)
    v12 = v2;
  else
    v12 = 46;
  if (v9)
    v13 = (char)v1;
  else
    v13 = 46;
  _cg_jpeg_mem_term("copyImageBlockSet", 2035, "*** [%c%c%c%c] plugin did not implement 'copyImageBlockSet' ***\n", v12, v11, v10, v13);
  return 0;
}

uint64_t IIOReadPlugin::decodeImageImp(uint64_t a1)
{
  int v1;
  unsigned int v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  unsigned int v6;
  int v7;
  uint64_t v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;

  if ((gIIODebugFlags & 0x30000) != 0)
  {
    v1 = *(_DWORD *)(a1 + 204);
    v2 = v1 >> 24;
    v3 = MEMORY[0x1E0C80978];
    if (v1 < 0)
      v4 = __maskrune(v1 >> 24, 0x40000uLL);
    else
      v4 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v2 + 60) & 0x40000;
    if (v4)
      v5 = v2;
    else
      v5 = 46;
    v6 = v1 << 8 >> 24;
    if (v1 << 8 < 0)
      v7 = __maskrune(v1 << 8 >> 24, 0x40000uLL);
    else
      v7 = *(_DWORD *)(v3 + 4 * v6 + 60) & 0x40000;
    if (v7)
      v8 = v6;
    else
      v8 = 46;
    v9 = (__int16)v1 >> 8;
    if (v1 << 16 < 0)
      v10 = __maskrune((__int16)v1 >> 8, 0x40000uLL);
    else
      v10 = *(_DWORD *)(v3 + 4 * v9 + 60) & 0x40000;
    if (v10)
      v11 = v9;
    else
      v11 = 46;
    if ((v1 << 24) <= 0x7F000000)
      v12 = *(_DWORD *)(v3 + 4 * (char)v1 + 60) & 0x40000;
    else
      v12 = __maskrune((char)v1, 0x40000uLL);
    if (v12)
      v13 = (char)v1;
    else
      v13 = 46;
    ImageIOLog("*** [%c%c%c%c] plugin does not implement 'decodeImageImp' ***\n", v5, v8, v11, v13);
  }
  return 4294967240;
}

uint64_t IIOReadPlugin::decodeImageIntoIOSurface(IIOReadPlugin *this, IIODecodeParameter *a2, __IOSurface *a3)
{
  IOSurfaceRef v4;

  v4 = a3;
  if (a3)
    return IIOReadPlugin::callDecodeImage((uint64_t)this, (uint64_t)a2, 1, &v4, 0, 0);
  else
    return 4294967292;
}

uint64_t IIOReadPlugin::createIOSurface(IIOReadPlugin *this)
{
  return 0;
}

uint64_t IIOReadPlugin::createCVPixelBuffer(IIOReadPlugin *this)
{
  return 0;
}

uint64_t IIOReadPlugin::copyImageBlockSetImp(uint64_t a1)
{
  int v1;
  unsigned int v2;
  uint64_t v3;
  int v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v1 = *(_DWORD *)(a1 + 204);
  v2 = v1 >> 24;
  v3 = MEMORY[0x1E0C80978];
  if (v1 < 0)
    v4 = __maskrune(v1 >> 24, 0x40000uLL);
  else
    v4 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v2 + 60) & 0x40000;
  v5 = v1 << 8 >> 24;
  if (v1 << 8 < 0)
    v6 = __maskrune(v1 << 8 >> 24, 0x40000uLL);
  else
    v6 = *(_DWORD *)(v3 + 4 * v5 + 60) & 0x40000;
  v7 = (__int16)v1 >> 8;
  if (v1 << 16 < 0)
    v8 = __maskrune((__int16)v1 >> 8, 0x40000uLL);
  else
    v8 = *(_DWORD *)(v3 + 4 * v7 + 60) & 0x40000;
  if ((v1 << 24) <= 0x7F000000)
    v9 = *(_DWORD *)(v3 + 4 * (char)v1 + 60) & 0x40000;
  else
    v9 = __maskrune((char)v1, 0x40000uLL);
  if (v8)
    v10 = v7;
  else
    v10 = 46;
  if (v6)
    v11 = v5;
  else
    v11 = 46;
  if (v4)
    v12 = v2;
  else
    v12 = 46;
  if (v9)
    v13 = (char)v1;
  else
    v13 = 46;
  _cg_jpeg_mem_term("copyImageBlockSetImp", 2374, "*** [%c%c%c%c] plugin did not implement 'copyImageBlockSetImp' ***\n", v12, v11, v10, v13);
  return 0;
}

uint64_t IIOReadPlugin::decodeImageData(IIOReadPlugin *this, unsigned __int8 *a2)
{
  int v2;
  unsigned int v3;
  uint64_t v4;
  int v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v2 = *((_DWORD *)this + 51);
  v3 = v2 >> 24;
  v4 = MEMORY[0x1E0C80978];
  if (v2 < 0)
    v5 = __maskrune(v2 >> 24, 0x40000uLL);
  else
    v5 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v3 + 60) & 0x40000;
  v6 = v2 << 8 >> 24;
  if (v2 << 8 < 0)
    v7 = __maskrune(v2 << 8 >> 24, 0x40000uLL);
  else
    v7 = *(_DWORD *)(v4 + 4 * v6 + 60) & 0x40000;
  v8 = (__int16)v2 >> 8;
  if (v2 << 16 < 0)
    v9 = __maskrune((__int16)v2 >> 8, 0x40000uLL);
  else
    v9 = *(_DWORD *)(v4 + 4 * v8 + 60) & 0x40000;
  if ((v2 << 24) <= 0x7F000000)
    v10 = *(_DWORD *)(v4 + 4 * (char)v2 + 60) & 0x40000;
  else
    v10 = __maskrune((char)v2, 0x40000uLL);
  if (v9)
    v11 = v8;
  else
    v11 = 46;
  if (v7)
    v12 = v6;
  else
    v12 = 46;
  if (v5)
    v13 = v3;
  else
    v13 = 46;
  if (v10)
    v14 = (char)v2;
  else
    v14 = 46;
  _cg_jpeg_mem_term("decodeImageData", 2406, "*** [%c%c%c%c] plugin did not implement 'decodeImageData' ***\n", v13, v12, v11, v14);
  return 4294967240;
}

void IIOReadPlugin::debugWriteImageBlocks(IIOReadPlugin *this, const void *a2, size_t a3, uint64_t a4, double a5, double a6, size_t a7, uint64_t a8, int a9)
{
  uint64_t v18;
  const char *v19;
  int v20;
  unsigned int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  unsigned int v25;
  int v26;
  size_t v27;
  uint64_t v28;
  unsigned int v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  __darwin_ct_rune_t v35;
  uint64_t v36;
  int v37;
  size_t v38;
  uint64_t v39;
  FILE *v40;
  FILE *v41;
  int v42;
  int *v43;
  char *v44;
  size_t __nitems;
  uint64_t v46;
  uint64_t v47;
  char *v48;

  if (a2)
  {
    v18 = ImageIOTempDirPath();
    if (v18)
    {
      v19 = (const char *)v18;
      __nitems = a3;
      v20 = *((_DWORD *)this + 51);
      v21 = v20 >> 24;
      v22 = MEMORY[0x1E0C80978];
      if (v20 < 0)
        v23 = __maskrune(v20 >> 24, 0x40000uLL);
      else
        v23 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v21 + 60) & 0x40000;
      if (v23)
        v24 = v21;
      else
        v24 = 46;
      v47 = v24;
      v25 = v20 << 8 >> 24;
      v46 = a4;
      if (v20 << 8 < 0)
        v26 = __maskrune(v20 << 8 >> 24, 0x40000uLL);
      else
        v26 = *(_DWORD *)(v22 + 4 * v25 + 60) & 0x40000;
      v27 = a7;
      if (v26)
        v28 = v25;
      else
        v28 = 46;
      v29 = (__int16)v20 >> 8;
      v30 = v22;
      if (v20 << 16 < 0)
      {
        v32 = v28;
        v31 = __maskrune((__int16)v20 >> 8, 0x40000uLL);
        v28 = v32;
      }
      else
      {
        v31 = *(_DWORD *)(v22 + 4 * v29 + 60) & 0x40000;
      }
      if (v31)
        v33 = v29;
      else
        v33 = 46;
      v34 = (char)v20;
      if ((v20 << 24) <= 0x7F000000)
      {
        v37 = *(_DWORD *)(v30 + 4 * (char)v20 + 60) & 0x40000;
      }
      else
      {
        v35 = (char)v20;
        v36 = v28;
        v37 = __maskrune(v35, 0x40000uLL);
        v28 = v36;
      }
      v38 = v27;
      v48 = 0;
      if (v37)
        v39 = v34;
      else
        v39 = 46;
      asprintf(&v48, "%s/ImageBlock#%ld '%c%c%c%c' <%p>,w=%g,h=%g,rb=%ld,cs=%ld,bpc=%ld,bmi=%08X,i=%ld.br2", v19, v46, v47, v28, v33, v39, this, a5, a6, v27, *((int *)this + 80), a8, a9, *((unsigned int *)this + 52));
      v40 = fopen(v48, "w");
      if (v40)
      {
        v41 = v40;
        ImageIOLog("==================================================================================\n");
        ImageIOLog("=== Writing image block to '%s'\n", v48);
        ImageIOLog("==================================================================================\n");
        fwrite(a2, v38, __nitems, v41);
        fclose(v41);
      }
      else
      {
        LogError("debugWriteImageBlocks", 2545, "ERROR: can't write image block to '%s'\n", v48);
        v42 = *__error();
        v43 = __error();
        v44 = strerror(*v43);
        LogError("debugWriteImageBlocks", 2546, "       error = %d (%s)\n", v42, v44);
      }
      if (v48)
        free(v48);
    }
  }
}

uint64_t IIOReadPlugin::copyIOSurface(uint64_t a1)
{
  int v1;
  unsigned int v2;
  uint64_t v3;
  int v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v1 = *(_DWORD *)(a1 + 204);
  v2 = v1 >> 24;
  v3 = MEMORY[0x1E0C80978];
  if (v1 < 0)
    v4 = __maskrune(v1 >> 24, 0x40000uLL);
  else
    v4 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v2 + 60) & 0x40000;
  v5 = v1 << 8 >> 24;
  if (v1 << 8 < 0)
    v6 = __maskrune(v1 << 8 >> 24, 0x40000uLL);
  else
    v6 = *(_DWORD *)(v3 + 4 * v5 + 60) & 0x40000;
  v7 = (__int16)v1 >> 8;
  if (v1 << 16 < 0)
    v8 = __maskrune((__int16)v1 >> 8, 0x40000uLL);
  else
    v8 = *(_DWORD *)(v3 + 4 * v7 + 60) & 0x40000;
  if ((v1 << 24) <= 0x7F000000)
    v9 = *(_DWORD *)(v3 + 4 * (char)v1 + 60) & 0x40000;
  else
    v9 = __maskrune((char)v1, 0x40000uLL);
  if (v8)
    v10 = v7;
  else
    v10 = 46;
  if (v6)
    v11 = v5;
  else
    v11 = 46;
  if (v4)
    v12 = v2;
  else
    v12 = 46;
  if (v9)
    v13 = (char)v1;
  else
    v13 = 46;
  _cg_jpeg_mem_term("copyIOSurface", 2678, "*** [%c%c%c%c] plugin did not implement 'copyIOSurface' ***\n", v12, v11, v10, v13);
  return 0;
}

uint64_t IIOReadPlugin::copyIOSurfaceImp(uint64_t a1)
{
  int v1;
  unsigned int v2;
  uint64_t v3;
  int v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v1 = *(_DWORD *)(a1 + 204);
  v2 = v1 >> 24;
  v3 = MEMORY[0x1E0C80978];
  if (v1 < 0)
    v4 = __maskrune(v1 >> 24, 0x40000uLL);
  else
    v4 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v2 + 60) & 0x40000;
  v5 = v1 << 8 >> 24;
  if (v1 << 8 < 0)
    v6 = __maskrune(v1 << 8 >> 24, 0x40000uLL);
  else
    v6 = *(_DWORD *)(v3 + 4 * v5 + 60) & 0x40000;
  v7 = (__int16)v1 >> 8;
  if (v1 << 16 < 0)
    v8 = __maskrune((__int16)v1 >> 8, 0x40000uLL);
  else
    v8 = *(_DWORD *)(v3 + 4 * v7 + 60) & 0x40000;
  if ((v1 << 24) <= 0x7F000000)
    v9 = *(_DWORD *)(v3 + 4 * (char)v1 + 60) & 0x40000;
  else
    v9 = __maskrune((char)v1, 0x40000uLL);
  if (v8)
    v10 = v7;
  else
    v10 = 46;
  if (v6)
    v11 = v5;
  else
    v11 = 46;
  if (v4)
    v12 = v2;
  else
    v12 = 46;
  if (v9)
    v13 = (char)v1;
  else
    v13 = 46;
  _cg_jpeg_mem_term("copyIOSurfaceImp", 2689, "*** [%c%c%c%c] plugin did not implement 'copyIOSurfaceImp' ***\n", v12, v11, v10, v13);
  return 4294967240;
}

uint64_t IIOReadPlugin::copyIOSurface420f(uint64_t a1)
{
  int v1;
  unsigned int v2;
  uint64_t v3;
  int v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v1 = *(_DWORD *)(a1 + 204);
  v2 = v1 >> 24;
  v3 = MEMORY[0x1E0C80978];
  if (v1 < 0)
    v4 = __maskrune(v1 >> 24, 0x40000uLL);
  else
    v4 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v2 + 60) & 0x40000;
  v5 = v1 << 8 >> 24;
  if (v1 << 8 < 0)
    v6 = __maskrune(v1 << 8 >> 24, 0x40000uLL);
  else
    v6 = *(_DWORD *)(v3 + 4 * v5 + 60) & 0x40000;
  v7 = (__int16)v1 >> 8;
  if (v1 << 16 < 0)
    v8 = __maskrune((__int16)v1 >> 8, 0x40000uLL);
  else
    v8 = *(_DWORD *)(v3 + 4 * v7 + 60) & 0x40000;
  if ((v1 << 24) <= 0x7F000000)
    v9 = *(_DWORD *)(v3 + 4 * (char)v1 + 60) & 0x40000;
  else
    v9 = __maskrune((char)v1, 0x40000uLL);
  if (v8)
    v10 = v7;
  else
    v10 = 46;
  if (v6)
    v11 = v5;
  else
    v11 = 46;
  if (v4)
    v12 = v2;
  else
    v12 = 46;
  if (v9)
    v13 = (char)v1;
  else
    v13 = 46;
  _cg_jpeg_mem_term("copyIOSurface420f", 2700, "*** [%c%c%c%c] plugin did not implement 'copyIOSurfaceCallback420f' ***\n", v12, v11, v10, v13);
  return 0;
}

uint64_t IIOReadPlugin::copyIOSurfaceSet(uint64_t a1)
{
  int v1;
  unsigned int v2;
  uint64_t v3;
  int v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v1 = *(_DWORD *)(a1 + 204);
  v2 = v1 >> 24;
  v3 = MEMORY[0x1E0C80978];
  if (v1 < 0)
    v4 = __maskrune(v1 >> 24, 0x40000uLL);
  else
    v4 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v2 + 60) & 0x40000;
  v5 = v1 << 8 >> 24;
  if (v1 << 8 < 0)
    v6 = __maskrune(v1 << 8 >> 24, 0x40000uLL);
  else
    v6 = *(_DWORD *)(v3 + 4 * v5 + 60) & 0x40000;
  v7 = (__int16)v1 >> 8;
  if (v1 << 16 < 0)
    v8 = __maskrune((__int16)v1 >> 8, 0x40000uLL);
  else
    v8 = *(_DWORD *)(v3 + 4 * v7 + 60) & 0x40000;
  if ((v1 << 24) <= 0x7F000000)
    v9 = *(_DWORD *)(v3 + 4 * (char)v1 + 60) & 0x40000;
  else
    v9 = __maskrune((char)v1, 0x40000uLL);
  if (v8)
    v10 = v7;
  else
    v10 = 46;
  if (v6)
    v11 = v5;
  else
    v11 = 46;
  if (v4)
    v12 = v2;
  else
    v12 = 46;
  if (v9)
    v13 = (char)v1;
  else
    v13 = 46;
  _cg_jpeg_mem_term("copyIOSurfaceSet", 2710, "*** [%c%c%c%c] plugin did not implement 'copyIOSurfaceSet' ***\n", v12, v11, v10, v13);
  return 0;
}

void IIOReadPlugin::debugWriteIOSurface(IIOReadPlugin *this, __IOSurface *a2)
{
  char v3;
  char *v4;

  v3 = IIO_XPCServer();
  if (a2)
  {
    if ((v3 & 1) == 0)
    {
      v4 = 0;
      asprintf(&v4, "*/IOSurface-%d.br2", 0);
      ImageIOLog("==================================================================================\n");
      ImageIOLog("=== Writing IOSurfaceRef to '%s'\n", v4);
      ImageIOLog("==================================================================================\n");
      free(v4);
    }
  }
}

uint64_t IIOReadPlugin::copyImageTextureData(uint64_t a1)
{
  int v1;
  unsigned int v2;
  uint64_t v3;
  int v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v1 = *(_DWORD *)(a1 + 204);
  v2 = v1 >> 24;
  v3 = MEMORY[0x1E0C80978];
  if (v1 < 0)
    v4 = __maskrune(v1 >> 24, 0x40000uLL);
  else
    v4 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v2 + 60) & 0x40000;
  v5 = v1 << 8 >> 24;
  if (v1 << 8 < 0)
    v6 = __maskrune(v1 << 8 >> 24, 0x40000uLL);
  else
    v6 = *(_DWORD *)(v3 + 4 * v5 + 60) & 0x40000;
  v7 = (__int16)v1 >> 8;
  if (v1 << 16 < 0)
    v8 = __maskrune((__int16)v1 >> 8, 0x40000uLL);
  else
    v8 = *(_DWORD *)(v3 + 4 * v7 + 60) & 0x40000;
  if ((v1 << 24) <= 0x7F000000)
    v9 = *(_DWORD *)(v3 + 4 * (char)v1 + 60) & 0x40000;
  else
    v9 = __maskrune((char)v1, 0x40000uLL);
  if (v8)
    v10 = v7;
  else
    v10 = 46;
  if (v6)
    v11 = v5;
  else
    v11 = 46;
  if (v4)
    v12 = v2;
  else
    v12 = 46;
  if (v9)
    v13 = (char)v1;
  else
    v13 = 46;
  _cg_jpeg_mem_term("copyImageTextureData", 2742, "*** [%c%c%c%c] plugin did not implement 'copyImageTextureData' ***\n", v12, v11, v10, v13);
  return 0;
}

uint64_t IIOReadPlugin::decodeLZFSEIntoBuffer(IIOReadPlugin *this, unsigned __int8 *a2, size_t a3, unsigned __int8 *a4, unint64_t a5)
{
  uint64_t v9;
  unint64_t v10;
  compression_status v11;
  compression_stream v13;

  if (!a3)
    return 0;
  memset(&v13, 0, sizeof(v13));
  if (compression_stream_init(&v13, COMPRESSION_STREAM_DECODE, COMPRESSION_LZFSE))
    return 0;
  v10 = 0;
  v13.src_ptr = a2;
  v13.src_size = a3;
  while (a5 > v10)
  {
    v13.dst_ptr = &a4[v10];
    v13.dst_size = a5 - v10;
    v11 = compression_stream_process(&v13, 0);
    if (v11 == COMPRESSION_STATUS_ERROR)
      break;
    v10 = v13.dst_ptr - a4;
    if (v11 == COMPRESSION_STATUS_END)
    {
      v9 = 1;
      goto LABEL_10;
    }
  }
  v9 = 0;
LABEL_10:
  compression_stream_destroy(&v13);
  return v9;
}

uint64_t IIOReadPlugin::textureDataLockData(IIOReadPlugin *this, unint64_t a2, unint64_t a3, unint64_t *a4, unint64_t *a5, unint64_t *a6)
{
  *a4 = 0;
  *a5 = 0;
  *a6 = 0;
  return 0;
}

uint64_t IIOReadPlugin::updateImageIOCacheKey(uint64_t result, uint64_t a2, int a3, double a4, double a5, double a6, double a7)
{
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;

  *(_QWORD *)a2 = *(_QWORD *)(result + 32);
  *(_DWORD *)(a2 + 8) = a4;
  *(_DWORD *)(a2 + 12) = a5;
  *(_DWORD *)(a2 + 16) = a6;
  *(_DWORD *)(a2 + 20) = a7;
  v7 = *(_QWORD *)(a2 + 28) & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)(result + 208);
  *(_QWORD *)(a2 + 28) = v7;
  v8 = (*(_DWORD *)(result + 392) << 16) | v7 & 0xFFFFFFFF0000FFFFLL;
  *(_QWORD *)(a2 + 28) = v8;
  v9 = v8 & 0xFF00FFFFFFFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(result + 304) << 48);
  *(_QWORD *)(a2 + 28) = v9;
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(result + 400);
  v10 = v9 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(result + 316) << 32);
  *(_QWORD *)(a2 + 28) = v10;
  *(_DWORD *)(a2 + 36) = a3;
  v11 = v10 & 0xFDFFFFFFFFFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(result + 354) << 57);
  *(_QWORD *)(a2 + 28) = v11;
  *(_QWORD *)(a2 + 28) = v11 & 0xFEFFFFFFFFFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(result + 353) << 56);
  return result;
}

uint64_t IIOReadPlugin::getCachedTile(IIOReadPlugin *this, double a2)
{
  double v3;
  double v4;
  double v5;
  double v6;
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[10];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  int v15;

  LODWORD(a2) = *((_DWORD *)this + 71);
  v3 = (double)*(unint64_t *)&a2;
  LODWORD(a2) = *((_DWORD *)this + 72);
  v4 = (double)*(unint64_t *)&a2;
  LODWORD(a2) = *((_DWORD *)this + 73);
  v5 = (double)*(unint64_t *)&a2;
  LODWORD(a2) = *((_DWORD *)this + 74);
  v6 = (double)*(unint64_t *)&a2;
  v12 = 0;
  v13 = &v12;
  v14 = 0x2000000000;
  v15 = 0;
  if ((gIIODebugFlags & 0x300) == 0x100 || (gIIODebugFlags & 0x400000000000) != 0)
    ImageIOLog("::: getCachedTile  request: rect=(%5g, %5g, %5g, %5g)\n", v3, v4, v5, v6);
  v8 = *((_QWORD *)this + 4);
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 0x40000000;
  v11[2] = ___ZN13IIOReadPlugin13getCachedTileEv_block_invoke;
  v11[3] = &unk_1E1BC4AC0;
  *(double *)&v11[6] = v3;
  *(double *)&v11[7] = v4;
  *(double *)&v11[8] = v5;
  *(double *)&v11[9] = v6;
  v11[4] = &v12;
  v11[5] = this;
  IIOImageRead::enumerateCacheKeysWithBlock(v8, (uint64_t)v11);
  v9 = (*((_DWORD *)this + 26) - *((_DWORD *)v13 + 6));
  _Block_object_dispose(&v12, 8);
  return v9;
}

void sub_187FC775C(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

void ___ZN13IIOReadPlugin13getCachedTileEv_block_invoke(uint64_t a1, _DWORD *a2, double a3, double a4)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v8;
  double v9;
  double v10;
  double v11;
  double v12;
  unint64_t v14;
  unint64_t v15;
  double y;
  double v17;
  double v18;
  double height;
  unsigned int v21;
  int v22;
  double x;
  double width;
  const void *ImageBlock;
  memory_object_offset_t v26;
  void *v27;
  vImagePixelCount v28;
  vImagePixelCount v29;
  size_t v30;
  size_t v31;
  uint8_t permuteMap[4];
  vImage_Buffer dest;
  vImage_Buffer src;
  size_t v35;
  void *v36;
  CGRect v37;
  CGRect v38;
  CGRect v39;
  CGRect v40;

  v8 = *(_QWORD *)(a1 + 40);
  LODWORD(a3) = a2[2];
  LODWORD(a4) = a2[3];
  v9 = (double)*(unint64_t *)&a3;
  v10 = (double)*(unint64_t *)&a4;
  LODWORD(a3) = a2[4];
  LODWORD(a4) = a2[5];
  v11 = (double)*(unint64_t *)&a3;
  v12 = (double)*(unint64_t *)&a4;
  if ((gIIODebugFlags & 0x300) == 0x100 || (gIIODebugFlags & 0x400000000000) != 0)
    ImageIOLog(":::                checking rect=(%5g, %5g, %5g, %5g)\n", v9, v10, (double)*(unint64_t *)&a3, (double)*(unint64_t *)&a4);
  v39.origin.x = v9;
  v39.origin.y = v10;
  v39.size.width = v11;
  v39.size.height = v12;
  if (CGRectEqualToRect(*(CGRect *)(a1 + 48), v39))
  {
    v36 = 0;
    LODWORD(v4) = *(_DWORD *)(v8 + 284);
    LODWORD(v14) = *(_DWORD *)(v8 + 288);
    y = (double)v14;
    LODWORD(v5) = *(_DWORD *)(v8 + 292);
    LODWORD(v14) = *(_DWORD *)(v8 + 296);
    v17 = (double)v14;
    LODWORD(v15) = *(_DWORD *)(v8 + 232);
    v18 = (double)v15;
    if (y + v17 <= v18)
      height = v17;
    else
      height = v18 - y;
    if ((gIIODebugFlags & 0x300) == 0x100 || (gIIODebugFlags & 0x400000000000) != 0)
      ImageIOLog(":::          found matching rect=(%5g, %5g, %5g, %5g)\n", v9, v10, v11, v12);
    v21 = a2[9];
    v22 = *(_DWORD *)(v8 + 300);
    if (v21 != v22)
    {
      _cg_jpeg_mem_term("getCachedTile_block_invoke", 2946, "*** cannot use cached tile: cached-rb: %d   blockGeo-rb:%d\n", a2[9], v22);
      return;
    }
    x = (double)v4;
    width = (double)v5;
    if (*(_DWORD *)(v8 + 400) == a2[6])
    {
      if (!IIOImageRead::getCachedImageBlockData(*(_QWORD *)(v8 + 32), a2, &v36))
        return;
      v37.origin.x = (double)v4;
      v37.origin.y = y;
      v37.size.width = (double)v5;
      v37.size.height = height;
      ImageBlock = IIOReadPlugin::createImageBlock((IIOReadPlugin *)v8, v36, 0, v37, *(unsigned int *)(v8 + 300), 1);
    }
    else
    {
      if (*(_WORD *)(v8 + 242) != 32)
        return;
      if (*(_WORD *)(v8 + 240) != 8)
        return;
      if (*(_DWORD *)(v8 + 320) != 1)
        return;
      v35 = 0;
      v26 = _ImageIO_Malloc(*(unsigned int *)(v8 + 296) * (unint64_t)v21, *(_QWORD *)(v8 + 384), &v35, (uint64_t)"ImageIOGetCachedBlocks", *(_DWORD *)(v8 + 432), 0, 0);
      if (!v26)
        return;
      v27 = (void *)v26;
      if (!IIOImageRead::getCachedImageBlockData(*(_QWORD *)(v8 + 32), a2, &v36))
        return;
      v28 = *(unsigned int *)(v8 + 296);
      src.data = v36;
      src.height = v28;
      v29 = *(unsigned int *)(v8 + 292);
      v30 = a2[9];
      dest.data = v27;
      dest.height = v28;
      v31 = *(unsigned int *)(v8 + 300);
      dest.width = v29;
      dest.rowBytes = v31;
      src.width = v29;
      src.rowBytes = v30;
      *(_DWORD *)permuteMap = 50331906;
      if (v30 < 4 * (int)v29)
        return;
      vImagePermuteChannels_ARGB8888(&src, &dest, permuteMap, 0x10u);
      if (*(unsigned __int8 *)(v8 + 246) - 3 <= 1)
      {
        if (*(_BYTE *)(v8 + 404))
        {
          if (*(_BYTE *)(v8 + 404) == 1)
            vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
        }
        else
        {
          vImageUnpremultiplyData_RGBA8888(&dest, &dest, 0x10u);
        }
      }
      CGImageReadSessionReleaseCachedImageBlockData(v36);
      ImageBlock = IIO_ImageBlockCreate((unint64_t)v27, *(unsigned int *)(v8 + 300), 0, (double)v4, y, (double)v5, height);
    }
    *(_QWORD *)(*(_QWORD *)(v8 + 96) + 8 * *(unsigned int *)(v8 + 112)) = ImageBlock;
    if (!CGRectEqualToRect(*(CGRect *)(v8 + 120), *MEMORY[0x1E0C9D628]))
    {
      v40.origin.x = (double)v4;
      v40.origin.y = y;
      v40.size.width = (double)v5;
      v40.size.height = height;
      v38 = CGRectUnion(*(CGRect *)(v8 + 120), v40);
      x = v38.origin.x;
      y = v38.origin.y;
      width = v38.size.width;
      height = v38.size.height;
    }
    *(double *)(v8 + 120) = x;
    *(double *)(v8 + 128) = y;
    *(double *)(v8 + 136) = width;
    *(double *)(v8 + 144) = height;
    if ((gIIODebugFlags & 0x300) == 0x100 || (gIIODebugFlags & 0x400000000000) != 0)
      ImageIOLog("::: cache  hit:      rect=(%5d, %5d, %5d, %5d)   rb=%d   imageData=%p\n", *(_DWORD *)(v8 + 284), *(_DWORD *)(v8 + 288), *(_DWORD *)(v8 + 292), *(_DWORD *)(v8 + 296), *(_DWORD *)(v8 + 300), v36);
    ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
}

IIODictionary *IIOReadPlugin::CreateRecodeProperties(IIOReadPlugin *this, IIOImageSource *a2, IIODictionary *a3, const __CFDictionary **a4, IIODictionary *a5, CGImageMetadata **a6)
{
  IIODictionary *v8;
  unsigned __int8 v9;
  const __CFDictionary *ObjectForKey;

  *(_QWORD *)a5 = CGImageMetadataCreateMutable();
  v8 = (IIODictionary *)operator new();
  IIODictionary::IIODictionary(v8, a4[1], 1);
  v9 = IIODictionary::containsKey(v8, CFSTR("Orientation"));
  if (a2 && (v9 & 1) == 0 && IIODictionary::containsKey(a2, CFSTR("Orientation")))
  {
    ObjectForKey = IIODictionary::getObjectForKey(a2, CFSTR("Orientation"));
    IIODictionary::setObjectForKey(v8, ObjectForKey, CFSTR("Orientation"));
  }
  return v8;
}

void sub_187FC7BB4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

void IIOReadPlugin::CleanupRecodeProperties(IIOReadPlugin *this, IIODictionary *a2)
{
  const __CFDictionary *ObjectForKey;
  const __CFDictionary *v4;
  int Uint32ForKey;
  int Uint32ForKeyGroup;
  BOOL v7;
  BOOL v8;
  const __CFDictionary *v9;
  const __CFDictionary *v10;
  const __CFDictionary *v11;
  _BYTE v12[16];
  void *v13;
  uint64_t v14;
  void *value;
  void *v16;

  if (this)
  {
    if ((IIODictionary::containsKey(this, CFSTR("{Exif}")) & 1) == 0)
    {
      v14 = 0;
      value = 0;
      v16 = 0;
      IIODictionary::IIODictionary((IIODictionary *)&v14);
      IIODictionary::setObjectForKey(this, value, CFSTR("{Exif}"));
      if (IIODictionary::containsKey(this, CFSTR("PixelWidth")))
      {
        ObjectForKey = IIODictionary::getObjectForKey(this, CFSTR("PixelWidth"));
        IIODictionary::setObjectForKey((IIODictionary *)&v14, ObjectForKey, CFSTR("PixelXDimension"));
      }
      if (IIODictionary::containsKey(this, CFSTR("PixelHeight")))
      {
        v4 = IIODictionary::getObjectForKey(this, CFSTR("PixelHeight"));
        IIODictionary::setObjectForKey((IIODictionary *)&v14, v4, CFSTR("PixelYDimension"));
      }
      IIODictionary::~IIODictionary((IIODictionary *)&v14);
    }
    if ((IIODictionary::containsKey(this, CFSTR("{TIFF}")) & 1) != 0)
    {
      Uint32ForKey = IIODictionary::getUint32ForKey(this, CFSTR("Orientation"));
      Uint32ForKeyGroup = IIODictionary::getUint32ForKeyGroup(this, CFSTR("Orientation"), CFSTR("{TIFF}"));
      _cg_jpeg_mem_term("CleanupRecodeProperties", 3548, "IIOReadPlugin::CleanupRecodeProperties:  top: %d  tiff: %d\n", Uint32ForKey, Uint32ForKeyGroup);
      if (Uint32ForKey)
        v7 = Uint32ForKeyGroup == 0;
      else
        v7 = 0;
      if (v7)
      {
        IIONumber::IIONumber((IIONumber *)&v14, Uint32ForKey);
        IIODictionary::setObjectForKeyGroup(this, v16, CFSTR("Orientation"), CFSTR("{TIFF}"));
        goto LABEL_28;
      }
      if (Uint32ForKey)
        v8 = 1;
      else
        v8 = Uint32ForKeyGroup == 0;
      if (!v8)
      {
        IIONumber::IIONumber((IIONumber *)&v14, Uint32ForKeyGroup);
        IIODictionary::setObjectForKey(this, v16, CFSTR("Orientation"));
LABEL_28:
        IIONumber::~IIONumber((IIONumber *)&v14);
      }
    }
    else
    {
      v14 = 0;
      value = 0;
      v16 = 0;
      IIODictionary::IIODictionary((IIODictionary *)&v14);
      IIODictionary::setObjectForKey(this, value, CFSTR("{TIFF}"));
      if (IIODictionary::containsKey(this, CFSTR("DPIWidth")))
      {
        v9 = IIODictionary::getObjectForKey(this, CFSTR("DPIWidth"));
        IIODictionary::setObjectForKey((IIODictionary *)&v14, v9, CFSTR("XResolution"));
      }
      if (IIODictionary::containsKey(this, CFSTR("DPIHeight")))
      {
        v10 = IIODictionary::getObjectForKey(this, CFSTR("DPIHeight"));
        IIODictionary::setObjectForKey((IIODictionary *)&v14, v10, CFSTR("YResolution"));
      }
      if (IIODictionary::getCount((IIODictionary *)&v14))
      {
        IIONumber::IIONumber((IIONumber *)v12, 2);
        IIODictionary::setObjectForKey((IIODictionary *)&v14, v13, CFSTR("ResolutionUnit"));
        IIONumber::~IIONumber((IIONumber *)v12);
      }
      if (IIODictionary::containsKey(this, CFSTR("Orientation")))
      {
        v11 = IIODictionary::getObjectForKey(this, CFSTR("Orientation"));
        IIODictionary::setObjectForKey((IIODictionary *)&v14, v11, CFSTR("Orientation"));
      }
      IIODictionary::~IIODictionary((IIODictionary *)&v14);
    }
  }
}

void sub_187FC7EB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

FILE *IIOImageReadSession::createFILE(IIOImageReadSession *this)
{
  FILE *v2;
  FILE *v3;
  const void *v4;

  v2 = funopen(this, (int (__cdecl *)(void *, char *, int))imagereader_readfn, 0, (fpos_t (__cdecl *)(void *, fpos_t, int))imagereader_seekfn, (int (__cdecl *)(void *))imagereader_closefn);
  v3 = v2;
  if (v2)
  {
    if ((gIIODebugFlags & 0x200000000000) != 0)
      ImageIOLog(">>> CGImageReadSessionCreateFILE: [%p] funopen FILE* %p\n", this, v2);
    v4 = (const void *)*((_QWORD *)this + 1);
    if (v4)
      CFRetain(v4);
  }
  return v3;
}

unint64_t imagereader_readfn(IIOImageReadSession *a1, char *a2, int a3)
{
  return IIOImageReadSession::getBytes(a1, a2, a3);
}

uint64_t imagereader_closefn(_QWORD *a1)
{
  const void *v1;

  if (a1)
  {
    v1 = (const void *)a1[1];
    if (v1)
      CFRelease(v1);
  }
  return 0;
}

uint64_t IIOImageReadSession::setOffset(uint64_t this, uint64_t a2)
{
  *(_QWORD *)(this + 40) = a2;
  return this;
}

size_t *IIOImageReadSession::addDataToXPCDictionary(IIOImageReadSession *this, void *a2, void **a3)
{
  size_t *result;

  result = (size_t *)*((_QWORD *)this + 4);
  if (result)
    return (size_t *)IIOImageRead::addDataToXPCDict(result, a2, a3);
  return result;
}

const __CFData *IIOImageReadSession::copyData(IIOImageRead **this)
{
  return IIOImageRead::copyData(this[4]);
}

char *IIOImageReadSession::copySourceInfo(IIOImageRead **this)
{
  return IIOImageRead::copySourceInfo(this[4]);
}

uint64_t IIOImageReadSession::shouldExposeMultiFrameContents(IIOImageRead **this)
{
  return IIOImageRead::shouldExposeMultiFrameContents(this[4]);
}

uint64_t IIOImageReadSession::useImageSequence(IIOImageRead **this)
{
  return IIOImageRead::useImageSequence(this[4]);
}

uint64_t CGImageReadSessionGetTypeID()
{
  if (CGImageReadSessionGetTypeID::once != -1)
    dispatch_once(&CGImageReadSessionGetTypeID::once, &__block_literal_global_13);
  return CGImageReadSessionGetTypeID::id;
}

CFStringRef _CGImageReadSessionCopyDebugDesc(_QWORD *cf)
{
  uint64_t v2;
  const __CFAllocator *v3;

  if (cf)
    v2 = cf[3];
  else
    v2 = 0;
  v3 = CFGetAllocator(cf);
  return CFStringCreateWithFormat(v3, 0, CFSTR("<CGImageReadSessionRef %p>{offset=%lld}%s"), cf, *(_QWORD *)(v2 + 40), "");
}

CFIndex CGImageReadSessionGetSize(uint64_t a1)
{
  uint64_t v1;
  IIOImageRead *v2;

  if (a1 && (v1 = *(_QWORD *)(a1 + 24)) != 0 && (v2 = *(IIOImageRead **)(v1 + 32)) != 0)
    return IIOImageRead::getSize(v2);
  else
    return 0;
}

BOOL CGImageReadSessionIsFinal(uint64_t a1)
{
  uint64_t v1;
  IIOImageRead *v2;

  return a1
      && (v1 = *(_QWORD *)(a1 + 24)) != 0
      && (v2 = *(IIOImageRead **)(v1 + 32)) != 0
      && IIOImageRead::isFinal(v2);
}

const UInt8 *CGImageReadSessionGetBytePointer(uint64_t a1, const __CFData **a2)
{
  uint64_t v2;
  IIOImageRead *v3;

  if (a1 && a2 && (v2 = *(_QWORD *)(a1 + 24)) != 0 && (v3 = *(IIOImageRead **)(v2 + 32)) != 0)
    return IIOImageRead::retainBytePointer(v3, a2, 0);
  else
    return 0;
}

void CGImageReadSessionReleaseBytePointer(uint64_t a1, const void *a2)
{
  uint64_t v2;
  IIOImageRead *v3;

  if (a1)
  {
    v2 = *(_QWORD *)(a1 + 24);
    if (v2)
    {
      v3 = *(IIOImageRead **)(v2 + 32);
      if (v3)
        IIOImageRead::releaseBytePointer(v3, a2);
    }
  }
}

unint64_t CGImageReadSessionGetBytesAtOffset(uint64_t a1, _BYTE *a2, unint64_t a3, unint64_t a4)
{
  uint64_t v4;
  IIOImageRead *v5;

  if (a1 && (v4 = *(_QWORD *)(a1 + 24)) != 0 && (v5 = *(IIOImageRead **)(v4 + 32)) != 0)
    return IIOImageRead::getBytesAtOffset(v5, a2, a3, a4);
  else
    return 0;
}

char *CGImageReadSessionCopySourceInfo(uint64_t a1)
{
  uint64_t v1;
  IIOImageRead *v2;

  if (a1 && (v1 = *(_QWORD *)(a1 + 24)) != 0 && (v2 = *(IIOImageRead **)(v1 + 32)) != 0)
    return IIOImageRead::copySourceInfo(v2);
  else
    return 0;
}

FILE *CGImageReadSessionCreateFILE(_QWORD *a1)
{
  const void *v2;
  FILE *v3;
  FILE *v4;

  if (!a1)
    return 0;
  v2 = (const void *)a1[3];
  v3 = funopen(v2, (int (__cdecl *)(void *, char *, int))imagereader_readfn, 0, (fpos_t (__cdecl *)(void *, fpos_t, int))imagereader_seekfn, (int (__cdecl *)(void *))imagereader_closefn);
  v4 = v3;
  if (v3)
  {
    if ((gIIODebugFlags & 0x200000000000) != 0)
      ImageIOLog(">>> CGImageReadSessionCreateFILE: [%p] funopen FILE* %p\n", v2, v3);
    CFRetain(a1);
  }
  return v4;
}

uint64_t jinit_arith_decoder(uint64_t a1)
{
  uint64_t result;
  int v3;
  __int128 v4;

  result = (**(uint64_t (***)(void))(a1 + 8))();
  *(_QWORD *)(a1 + 624) = result;
  *(_QWORD *)result = start_pass_0;
  *(_QWORD *)(result + 16) = finish_pass;
  *(_OWORD *)(result + 304) = 0u;
  *(_OWORD *)(result + 320) = 0u;
  *(_OWORD *)(result + 272) = 0u;
  *(_OWORD *)(result + 288) = 0u;
  *(_OWORD *)(result + 240) = 0u;
  *(_OWORD *)(result + 256) = 0u;
  *(_OWORD *)(result + 208) = 0u;
  *(_OWORD *)(result + 224) = 0u;
  *(_OWORD *)(result + 176) = 0u;
  *(_OWORD *)(result + 192) = 0u;
  *(_OWORD *)(result + 144) = 0u;
  *(_OWORD *)(result + 160) = 0u;
  *(_OWORD *)(result + 112) = 0u;
  *(_OWORD *)(result + 128) = 0u;
  *(_OWORD *)(result + 80) = 0u;
  *(_OWORD *)(result + 96) = 0u;
  *(_BYTE *)(result + 336) = 113;
  if (*(_DWORD *)(a1 + 316))
  {
    result = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, (uint64_t)*(int *)(a1 + 56) << 8);
    *(_QWORD *)(a1 + 192) = result;
    if (*(int *)(a1 + 56) >= 1)
    {
      v3 = 0;
      *(_QWORD *)&v4 = -1;
      *((_QWORD *)&v4 + 1) = -1;
      do
      {
        *(_OWORD *)(result + 224) = v4;
        *(_OWORD *)(result + 240) = v4;
        *(_OWORD *)(result + 192) = v4;
        *(_OWORD *)(result + 208) = v4;
        *(_OWORD *)(result + 160) = v4;
        *(_OWORD *)(result + 176) = v4;
        *(_OWORD *)(result + 128) = v4;
        *(_OWORD *)(result + 144) = v4;
        *(_OWORD *)(result + 96) = v4;
        *(_OWORD *)(result + 112) = v4;
        *(_OWORD *)(result + 64) = v4;
        *(_OWORD *)(result + 80) = v4;
        *(_OWORD *)(result + 32) = v4;
        *(_OWORD *)(result + 48) = v4;
        *(_OWORD *)result = v4;
        *(_OWORD *)(result + 16) = v4;
        result += 256;
        ++v3;
      }
      while (v3 < *(_DWORD *)(a1 + 56));
    }
  }
  return result;
}

uint64_t start_pass_0(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _DWORD *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v18;
  void *v19;
  uint64_t i;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  int v33;

  v1 = result;
  v2 = *(_QWORD *)(result + 624);
  v3 = *(_DWORD *)(result + 540);
  if (*(_DWORD *)(result + 316))
  {
    v4 = *(_DWORD *)(result + 544);
    if (v3)
    {
      if (v4 < v3 || v4 > *(_DWORD *)(result + 568) || *(_DWORD *)(result + 448) != 1)
        goto LABEL_18;
    }
    else if (v4)
    {
      goto LABEL_18;
    }
    v7 = *(_DWORD *)(result + 548);
    if (v7)
    {
      v8 = v7 - 1;
      if (v8 != *(_DWORD *)(result + 552))
        goto LABEL_18;
    }
    else
    {
      v8 = *(_DWORD *)(result + 552);
    }
    if (v8 < 14)
    {
LABEL_19:
      LODWORD(v6) = *(_DWORD *)(v1 + 448);
      if ((int)v6 >= 1)
      {
        v10 = 0;
        do
        {
          v11 = *(int *)(*(_QWORD *)(v1 + 8 * v10 + 456) + 4);
          v12 = (_DWORD *)(*(_QWORD *)(v1 + 192) + (v11 << 8));
          v13 = *(_DWORD *)(v1 + 540);
          if (v13 && (*v12 & 0x80000000) != 0)
          {
            v14 = *(_QWORD *)v1;
            *(_DWORD *)(v14 + 40) = 118;
            *(_DWORD *)(v14 + 48) = v11;
            *(_DWORD *)(*(_QWORD *)v1 + 52) = 0;
            result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v1 + 8))(v1, 0xFFFFFFFFLL);
            v13 = *(_DWORD *)(v1 + 540);
          }
          if (v13 <= *(_DWORD *)(v1 + 544))
          {
            v15 = v13;
            do
            {
              if (*(_DWORD *)(v1 + 548) != (v12[v15] & ~((int)v12[v15] >> 31)))
              {
                v16 = *(_QWORD *)v1;
                *(_DWORD *)(v16 + 40) = 118;
                *(_DWORD *)(v16 + 48) = v11;
                *(_DWORD *)(*(_QWORD *)v1 + 52) = v15;
                result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v1 + 8))(v1, 0xFFFFFFFFLL);
              }
              v12[v15] = *(_DWORD *)(v1 + 552);
            }
            while (v15++ < *(int *)(v1 + 544));
          }
          ++v10;
          v6 = *(int *)(v1 + 448);
        }
        while (v10 < v6);
      }
      v18 = *(_DWORD *)(v1 + 540);
      if (*(_DWORD *)(v1 + 548))
      {
        if (v18)
          v19 = decode_mcu_AC_refine_0;
        else
          v19 = decode_mcu_DC_refine_0;
      }
      else if (v18)
      {
        v19 = decode_mcu_AC_first_0;
      }
      else
      {
        v19 = decode_mcu_DC_first_0;
      }
      *(_QWORD *)(v2 + 8) = v19;
      goto LABEL_38;
    }
LABEL_18:
    v9 = *(_QWORD *)result;
    *(_DWORD *)(v9 + 40) = 17;
    *(_DWORD *)(v9 + 48) = v3;
    *(_DWORD *)(*(_QWORD *)result + 52) = *(_DWORD *)(result + 544);
    *(_DWORD *)(*(_QWORD *)result + 56) = *(_DWORD *)(result + 548);
    *(_DWORD *)(*(_QWORD *)result + 60) = *(_DWORD *)(result + 552);
    result = (**(uint64_t (***)(uint64_t))result)(result);
    goto LABEL_19;
  }
  if (v3
    || *(_DWORD *)(result + 548)
    || *(_DWORD *)(result + 552)
    || (v33 = *(_DWORD *)(result + 544), v33 <= 63) && v33 != *(_DWORD *)(result + 568))
  {
    v5 = *(_QWORD *)result;
    *(_DWORD *)(v5 + 40) = 125;
    result = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 8))(result, 0xFFFFFFFFLL);
  }
  *(_QWORD *)(v2 + 8) = decode_mcu_0;
  LODWORD(v6) = *(_DWORD *)(v1 + 448);
LABEL_38:
  if ((int)v6 >= 1)
  {
    for (i = 0; i < *(int *)(v1 + 448); ++i)
    {
      v21 = *(_QWORD *)(v1 + 8 * i + 456);
      if (!*(_DWORD *)(v1 + 316))
        goto LABEL_43;
      if (*(_DWORD *)(v1 + 540))
        goto LABEL_51;
      if (!*(_DWORD *)(v1 + 548))
      {
LABEL_43:
        v22 = *(_DWORD *)(v21 + 20);
        if (v22 >= 0x10)
        {
          v23 = *(_QWORD *)v1;
          *(_DWORD *)(v23 + 40) = 50;
          *(_DWORD *)(v23 + 48) = v22;
          (**(void (***)(uint64_t))v1)(v1);
        }
        v24 = v2 + 8 * (int)v22;
        v26 = *(_QWORD *)(v24 + 80);
        v25 = (uint64_t *)(v24 + 80);
        result = v26;
        if (!v26)
        {
          result = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(v1 + 8))(v1, 1, 64);
          *v25 = result;
        }
        *(_OWORD *)(result + 32) = 0u;
        *(_OWORD *)(result + 48) = 0u;
        *(_OWORD *)result = 0u;
        *(_OWORD *)(result + 16) = 0u;
        v27 = v2 + 4 * i;
        *(_DWORD *)(v27 + 44) = 0;
        *(_DWORD *)(v27 + 60) = 0;
        if (*(_DWORD *)(v1 + 316))
        {
          if (*(_DWORD *)(v1 + 540))
            goto LABEL_51;
        }
        else if (*(_DWORD *)(v1 + 568))
        {
LABEL_51:
          v28 = *(_DWORD *)(v21 + 24);
          if (v28 >= 0x10)
          {
            v29 = *(_QWORD *)v1;
            *(_DWORD *)(v29 + 40) = 50;
            *(_DWORD *)(v29 + 48) = v28;
            (**(void (***)(uint64_t))v1)(v1);
          }
          v30 = v2 + 8 * (int)v28;
          v32 = *(_QWORD *)(v30 + 208);
          v31 = (uint64_t *)(v30 + 208);
          result = v32;
          if (!v32)
          {
            result = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(v1 + 8))(v1, 1, 256);
            *v31 = result;
          }
          *(_OWORD *)(result + 224) = 0u;
          *(_OWORD *)(result + 240) = 0u;
          *(_OWORD *)(result + 192) = 0u;
          *(_OWORD *)(result + 208) = 0u;
          *(_OWORD *)(result + 160) = 0u;
          *(_OWORD *)(result + 176) = 0u;
          *(_OWORD *)(result + 128) = 0u;
          *(_OWORD *)(result + 144) = 0u;
          *(_OWORD *)(result + 96) = 0u;
          *(_OWORD *)(result + 112) = 0u;
          *(_OWORD *)(result + 64) = 0u;
          *(_OWORD *)(result + 80) = 0u;
          *(_OWORD *)(result + 32) = 0u;
          *(_OWORD *)(result + 48) = 0u;
          *(_OWORD *)result = 0u;
          *(_OWORD *)(result + 16) = 0u;
        }
      }
    }
  }
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_DWORD *)(v2 + 40) = -16;
  *(_DWORD *)(v2 + 76) = *(_DWORD *)(v1 + 372);
  return result;
}

uint64_t decode_mcu_DC_first_0(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  _WORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  int *v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  _BYTE *v18;
  int v19;
  int v20;
  int v21;
  int v22;
  _BYTE *v23;
  int v24;
  BOOL v25;
  int v26;
  uint64_t v27;
  uint64_t v28;

  v3 = *(_QWORD *)(a1 + 624);
  if (*(_DWORD *)(a1 + 372))
  {
    v4 = *(_DWORD *)(v3 + 76);
    if (!v4)
    {
      process_restart_0((uint64_t *)a1);
      v4 = *(_DWORD *)(v3 + 76);
    }
    *(_DWORD *)(v3 + 76) = v4 - 1;
  }
  if (*(_DWORD *)(v3 + 40) == -1 || *(int *)(a1 + 496) < 1)
    return 1;
  v5 = 0;
  while (1)
  {
    v6 = *(_WORD **)(a2 + 8 * v5);
    v7 = *(int *)(a1 + 4 * v5 + 500);
    v8 = *(int *)(*(_QWORD *)(a1 + 8 * v7 + 456) + 20);
    v9 = v3 + 8 * v8;
    v12 = *(_QWORD *)(v9 + 80);
    v11 = (_QWORD *)(v9 + 80);
    v10 = v12;
    v13 = v3 + 4 * v7;
    v15 = *(int *)(v13 + 60);
    v14 = (int *)(v13 + 60);
    v16 = v10 + v15;
    if (arith_decode(a1, (_BYTE *)(v10 + v15)))
      break;
    *v14 = 0;
    v20 = *(_DWORD *)(v3 + 4 * v7 + 44);
LABEL_30:
    *v6 = v20 << *(_DWORD *)(a1 + 552);
    if (++v5 >= *(int *)(a1 + 496))
      return 1;
  }
  v17 = arith_decode(a1, (_BYTE *)(v16 + 1));
  v18 = (_BYTE *)(v16 + v17 + 2);
  if (!arith_decode(a1, v18))
  {
    v19 = 0;
    goto LABEL_16;
  }
  v18 = (_BYTE *)(*v11 + 20);
  v19 = 1;
  if (!arith_decode(a1, v18))
  {
LABEL_16:
    if (v19 >= (int)((unint64_t)(1 << *(_BYTE *)(a1 + v8 + 324)) >> 1))
    {
      v21 = 4 * v17 + 4;
      if (v19 > (int)((unint64_t)(1 << *(_BYTE *)(a1 + v8 + 340)) >> 1))
        v21 = 4 * v17 + 12;
    }
    else
    {
      v21 = 0;
    }
    *v14 = v21;
    if (v19 >= 2)
    {
      v23 = v18 + 14;
      v22 = v19;
      do
      {
        if (arith_decode(a1, v23))
          v24 = v19 >> 1;
        else
          v24 = 0;
        v22 |= v24;
        v25 = v19 > 3;
        v19 >>= 1;
      }
      while (v25);
    }
    else
    {
      v22 = v19;
    }
    v26 = ~v22;
    if (!v17)
      v26 = v22 + 1;
    v27 = v3 + 4 * v7;
    v20 = *(_DWORD *)(v27 + 44) + v26;
    *(_DWORD *)(v27 + 44) = v20;
    goto LABEL_30;
  }
  while (1)
  {
    v19 *= 2;
    if (v19 == 0x8000)
      break;
    if (!arith_decode(a1, ++v18))
      goto LABEL_16;
  }
  v28 = *(_QWORD *)a1;
  *(_DWORD *)(v28 + 40) = 117;
  (*(void (**)(uint64_t, uint64_t))(v28 + 8))(a1, 0xFFFFFFFFLL);
  *(_DWORD *)(v3 + 40) = -1;
  return 1;
}

uint64_t decode_mcu_AC_first_0(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t *v9;
  uint64_t v10;
  _BYTE *v11;
  int *v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  _BYTE *v17;
  int v18;
  int v19;
  int v20;
  int v21;
  BOOL v22;
  int v23;
  uint64_t v24;
  unsigned __int8 *v26;
  uint64_t v27;
  uint64_t v28;

  v4 = *(_QWORD *)(a1 + 624);
  if (*(_DWORD *)(a1 + 372))
  {
    v5 = *(_DWORD *)(v4 + 76);
    if (!v5)
    {
      process_restart_0((uint64_t *)a1);
      v5 = *(_DWORD *)(v4 + 76);
    }
    *(_DWORD *)(v4 + 76) = v5 - 1;
  }
  if (*(_DWORD *)(v4 + 40) != -1)
  {
    v6 = *(_QWORD *)(a1 + 560);
    v7 = *(int *)(*(_QWORD *)(a1 + 456) + 24);
    v8 = *(_DWORD *)(a1 + 540) - 1;
    v9 = (uint64_t *)(v4 + 8 * v7 + 208);
    v28 = *a2;
    v26 = (unsigned __int8 *)(a1 + v7 + 356);
    v27 = v6;
    do
    {
      v10 = *v9;
      if (arith_decode(a1, (_BYTE *)(*v9 + 3 * v8)))
        break;
      v11 = (_BYTE *)(v10 + 3 * v8 + 2);
      v12 = (int *)(v6 + 4 * (v8 + 1));
      while (1)
      {
        v13 = v8 + 1;
        if (arith_decode(a1, v11 - 1))
          break;
        v11 += 3;
        ++v12;
        ++v8;
        if (v13 >= *(_DWORD *)(a1 + 544))
          goto LABEL_32;
      }
      v14 = arith_decode(a1, (_BYTE *)(v4 + 336));
      if (arith_decode(a1, v11))
      {
        if (arith_decode(a1, v11))
        {
          v15 = *v9;
          v16 = 217;
          if (v8 < *v26)
            v16 = 189;
          v17 = (_BYTE *)(v15 + v16 + 14);
          v18 = 2;
          if (arith_decode(a1, (_BYTE *)(v15 + v16)))
          {
            while (1)
            {
              v18 *= 2;
              if (v18 == 0x8000)
                break;
              v19 = arith_decode(a1, v17 - 13);
              ++v17;
              if (!v19)
              {
                if (!v18)
                  goto LABEL_28;
                goto LABEL_20;
              }
            }
LABEL_32:
            v24 = *(_QWORD *)a1;
            *(_DWORD *)(v24 + 40) = 117;
            (*(void (**)(uint64_t, uint64_t))(v24 + 8))(a1, 0xFFFFFFFFLL);
            *(_DWORD *)(v4 + 40) = -1;
            return 1;
          }
LABEL_20:
          v20 = v18;
          do
          {
            if (arith_decode(a1, v17))
              v21 = v20 >> 1;
            else
              v21 = 0;
            v18 |= v21;
            v22 = v20 > 3;
            v20 >>= 1;
          }
          while (v22);
        }
        else
        {
          v18 = 1;
        }
      }
      else
      {
        v18 = 0;
      }
LABEL_28:
      v23 = ~v18;
      if (!v14)
        v23 = v18 + 1;
      v6 = v27;
      *(_WORD *)(v28 + 2 * *v12) = v23 << *(_DWORD *)(a1 + 552);
      v8 = v13;
    }
    while (v13 < *(_DWORD *)(a1 + 544));
  }
  return 1;
}

uint64_t decode_mcu_DC_refine_0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  _BYTE *v7;
  int v8;

  v4 = *(_QWORD *)(a1 + 624);
  if (*(_DWORD *)(a1 + 372))
  {
    v5 = *(_DWORD *)(v4 + 76);
    if (!v5)
    {
      process_restart_0((uint64_t *)a1);
      v5 = *(_DWORD *)(v4 + 76);
    }
    *(_DWORD *)(v4 + 76) = v5 - 1;
  }
  if (*(int *)(a1 + 496) >= 1)
  {
    v6 = 0;
    v7 = (_BYTE *)(v4 + 336);
    v8 = 1 << *(_DWORD *)(a1 + 552);
    do
    {
      if (arith_decode(a1, v7))
        **(_WORD **)(a2 + 8 * v6) |= v8;
      ++v6;
    }
    while (v6 < *(int *)(a1 + 496));
  }
  return 1;
}

uint64_t decode_mcu_AC_refine_0(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  _BYTE *i;
  uint64_t v17;
  __int16 *v18;
  int v19;
  __int16 v20;
  int v21;
  uint64_t v22;
  int v24;

  v4 = *(_QWORD *)(a1 + 624);
  if (*(_DWORD *)(a1 + 372))
  {
    v5 = *(_DWORD *)(v4 + 76);
    if (!v5)
    {
      process_restart_0((uint64_t *)a1);
      v5 = *(_DWORD *)(v4 + 76);
    }
    *(_DWORD *)(v4 + 76) = v5 - 1;
  }
  if (*(_DWORD *)(v4 + 40) != -1)
  {
    v6 = *(_QWORD *)(a1 + 560);
    v7 = *a2;
    v24 = 1 << *(_DWORD *)(a1 + 552);
    v8 = *(int *)(a1 + 544);
    do
    {
      if (*(_WORD *)(v7 + 2 * *(int *)(v6 + 4 * v8)))
        break;
      --v8;
    }
    while ((_DWORD)v8);
    v9 = *(_DWORD *)(a1 + 540) - 1;
    v10 = (uint64_t *)(v4 + 8 * *(int *)(*(_QWORD *)(a1 + 456) + 24) + 208);
    v11 = v6 + 4;
    do
    {
      v12 = *v10;
      v13 = 3 * v9;
      if (v9 >= (int)v8 && arith_decode(a1, (_BYTE *)(v12 + v13)))
        break;
      v14 = v13;
      v15 = v9++;
      for (i = (_BYTE *)(v12 + v14 + 2); ; i += 3)
      {
        v17 = *(int *)(v11 + 4 * v15);
        if (*(_WORD *)(v7 + 2 * v17))
          break;
        if (arith_decode(a1, i - 1))
        {
          v18 = (__int16 *)(v7 + 2 * v17);
          v21 = arith_decode(a1, (_BYTE *)(v4 + 336));
          v20 = v24;
          if (v21)
            v20 = -(__int16)v24;
          goto LABEL_23;
        }
        ++v15;
        ++v9;
        if (v15 >= *(int *)(a1 + 544))
        {
          v22 = *(_QWORD *)a1;
          *(_DWORD *)(v22 + 40) = 117;
          (*(void (**)(uint64_t, uint64_t))(v22 + 8))(a1, 0xFFFFFFFFLL);
          *(_DWORD *)(v4 + 40) = -1;
          return 1;
        }
      }
      if (!arith_decode(a1, i))
        continue;
      v18 = (__int16 *)(v7 + 2 * v17);
      v19 = *v18;
      v20 = v19 < 0 ? v19 - v24 : v19 + v24;
LABEL_23:
      *v18 = v20;
    }
    while (*(_DWORD *)(a1 + 544) > v9);
  }
  return 1;
}

uint64_t decode_mcu_0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  int *v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  _BYTE *v19;
  int v20;
  int v21;
  int v22;
  int v23;
  _BYTE *v24;
  int v25;
  BOOL v26;
  int v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  _BYTE *v33;
  int *v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  _BYTE *v38;
  int v39;
  int v40;
  int v41;
  int v42;
  __int16 v43;
  uint64_t v44;
  unsigned __int8 *v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  _WORD *v50;

  v4 = *(_QWORD *)(a1 + 624);
  if (*(_DWORD *)(a1 + 372))
  {
    v5 = *(_DWORD *)(v4 + 76);
    if (!v5)
    {
      process_restart_0((uint64_t *)a1);
      v5 = *(_DWORD *)(v4 + 76);
    }
    *(_DWORD *)(v4 + 76) = v5 - 1;
  }
  if (*(_DWORD *)(v4 + 40) == -1 || *(int *)(a1 + 496) < 1)
    return 1;
  v6 = 0;
  v49 = *(_QWORD *)(a1 + 560);
  v48 = a2;
  while (1)
  {
    v50 = *(_WORD **)(a2 + 8 * v6);
    v7 = *(int *)(a1 + 4 * v6 + 500);
    v8 = *(_QWORD *)(a1 + 8 * v7 + 456);
    v9 = *(int *)(v8 + 20);
    v10 = v4 + 8 * v9;
    v13 = *(_QWORD *)(v10 + 80);
    v12 = (_QWORD *)(v10 + 80);
    v11 = v13;
    v14 = v4 + 4 * v7;
    v16 = *(int *)(v14 + 60);
    v15 = (int *)(v14 + 60);
    v17 = v11 + v16;
    if (arith_decode(a1, (_BYTE *)(v11 + v16)))
      break;
    *v15 = 0;
    v21 = *(_DWORD *)(v4 + 4 * v7 + 44);
LABEL_30:
    *v50 = v21;
    if (*(_DWORD *)(a1 + 568))
    {
      v29 = 0;
      v30 = *(int *)(v8 + 24);
      v31 = (uint64_t *)(v4 + 8 * v30 + 208);
      v46 = (unsigned __int8 *)(a1 + v30 + 356);
      do
      {
        v32 = *v31;
        if (arith_decode(a1, (_BYTE *)(*v31 + 3 * v29)))
          break;
        v33 = (_BYTE *)(v32 + 3 * v29 + 2);
        v34 = (int *)(v49 + 4 * (v29 + 1));
        while (1)
        {
          v35 = v29 + 1;
          if (arith_decode(a1, v33 - 1))
            break;
          v33 += 3;
          ++v34;
          ++v29;
          if (v35 >= *(_DWORD *)(a1 + 568))
            goto LABEL_58;
        }
        v47 = arith_decode(a1, (_BYTE *)(v4 + 336));
        if (arith_decode(a1, v33))
        {
          if (arith_decode(a1, v33))
          {
            v36 = *v31;
            v37 = 217;
            if (v29 < *v46)
              v37 = 189;
            v38 = (_BYTE *)(v36 + v37 + 14);
            v39 = 2;
            if (arith_decode(a1, (_BYTE *)(v36 + v37)))
            {
              while (1)
              {
                v39 *= 2;
                if (v39 == 0x8000)
                  goto LABEL_58;
                v40 = arith_decode(a1, v38 - 13);
                ++v38;
                if (!v40)
                {
                  if (!v39)
                    goto LABEL_53;
                  break;
                }
              }
            }
            v41 = v39;
            do
            {
              if (arith_decode(a1, v38))
                v42 = v41 >> 1;
              else
                LOWORD(v42) = 0;
              LOWORD(v39) = v42 | v39;
              v26 = v41 > 3;
              v41 >>= 1;
            }
            while (v26);
          }
          else
          {
            LOWORD(v39) = 1;
          }
        }
        else
        {
          LOWORD(v39) = 0;
        }
LABEL_53:
        v43 = ~(_WORD)v39;
        if (!v47)
          v43 = v39 + 1;
        v50[*v34] = v43;
        v29 = v35;
      }
      while (v35 < *(_DWORD *)(a1 + 568));
    }
    ++v6;
    a2 = v48;
    if (v6 >= *(int *)(a1 + 496))
      return 1;
  }
  v18 = arith_decode(a1, (_BYTE *)(v17 + 1));
  v19 = (_BYTE *)(v17 + v18 + 2);
  if (!arith_decode(a1, v19))
  {
    v20 = 0;
    goto LABEL_16;
  }
  v19 = (_BYTE *)(*v12 + 20);
  v20 = 1;
  if (!arith_decode(a1, v19))
  {
LABEL_16:
    if (v20 >= (int)((unint64_t)(1 << *(_BYTE *)(a1 + v9 + 324)) >> 1))
    {
      v22 = 4 * v18 + 4;
      if (v20 > (int)((unint64_t)(1 << *(_BYTE *)(a1 + v9 + 340)) >> 1))
        v22 = 4 * v18 + 12;
    }
    else
    {
      v22 = 0;
    }
    *v15 = v22;
    if (v20 >= 2)
    {
      v24 = v19 + 14;
      v23 = v20;
      do
      {
        if (arith_decode(a1, v24))
          v25 = v20 >> 1;
        else
          v25 = 0;
        v23 |= v25;
        v26 = v20 > 3;
        v20 >>= 1;
      }
      while (v26);
    }
    else
    {
      v23 = v20;
    }
    v27 = ~v23;
    if (!v18)
      v27 = v23 + 1;
    v28 = v4 + 4 * v7;
    v21 = *(_DWORD *)(v28 + 44) + v27;
    *(_DWORD *)(v28 + 44) = v21;
    goto LABEL_30;
  }
  while (1)
  {
    v20 *= 2;
    if (v20 == 0x8000)
      break;
    if (!arith_decode(a1, ++v19))
      goto LABEL_16;
  }
LABEL_58:
  v44 = *(_QWORD *)a1;
  *(_DWORD *)(v44 + 40) = 117;
  (*(void (**)(uint64_t, uint64_t))(v44 + 8))(a1, 0xFFFFFFFFLL);
  *(_DWORD *)(v4 + 40) = -1;
  return 1;
}

uint64_t process_restart_0(uint64_t *a1)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  uint64_t i;
  uint64_t v6;
  _OWORD *v7;
  uint64_t v8;
  _OWORD *v9;

  v2 = a1[78];
  result = (*(uint64_t (**)(void))(a1[77] + 16))();
  if (!(_DWORD)result)
  {
    v4 = *a1;
    *(_DWORD *)(v4 + 40) = 25;
    result = (*(uint64_t (**)(uint64_t *))v4)(a1);
  }
  if (*((int *)a1 + 112) >= 1)
  {
    for (i = 0; i < *((int *)a1 + 112); ++i)
    {
      v6 = a1[i + 57];
      if (!*((_DWORD *)a1 + 79))
        goto LABEL_8;
      if (*((_DWORD *)a1 + 135))
        goto LABEL_10;
      if (!*((_DWORD *)a1 + 137))
      {
LABEL_8:
        v7 = *(_OWORD **)(v2 + 8 * *(int *)(v6 + 20) + 80);
        v7[2] = 0uLL;
        v7[3] = 0uLL;
        *v7 = 0uLL;
        v7[1] = 0uLL;
        v8 = v2 + 4 * i;
        *(_DWORD *)(v8 + 44) = 0;
        *(_DWORD *)(v8 + 60) = 0;
        if (!*((_DWORD *)a1 + 79))
        {
          if (!*((_DWORD *)a1 + 142))
            continue;
LABEL_10:
          v9 = *(_OWORD **)(v2 + 8 * *(int *)(v6 + 24) + 208);
          v9[14] = 0uLL;
          v9[15] = 0uLL;
          v9[12] = 0uLL;
          v9[13] = 0uLL;
          v9[10] = 0uLL;
          v9[11] = 0uLL;
          v9[8] = 0uLL;
          v9[9] = 0uLL;
          v9[6] = 0uLL;
          v9[7] = 0uLL;
          v9[4] = 0uLL;
          v9[5] = 0uLL;
          v9[2] = 0uLL;
          v9[3] = 0uLL;
          *v9 = 0uLL;
          v9[1] = 0uLL;
          continue;
        }
        if (*((_DWORD *)a1 + 135))
          goto LABEL_10;
      }
    }
  }
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_DWORD *)(v2 + 40) = -16;
  *(_DWORD *)(v2 + 76) = *((_DWORD *)a1 + 93);
  return result;
}

uint64_t arith_decode(uint64_t a1, _BYTE *a2)
{
  uint64_t v3;
  uint64_t v4;
  int v6;
  int v7;
  unsigned int byte;
  int v9;
  int v10;
  BOOL v11;
  BOOL v12;
  int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  BOOL v20;
  uint64_t v21;
  char v22;

  v3 = *(_QWORD *)(a1 + 624);
  v4 = *(_QWORD *)(v3 + 32);
  if (v4 >= 0x8000)
  {
    v6 = *(_DWORD *)(v3 + 40);
  }
  else
  {
    v6 = *(_DWORD *)(v3 + 40);
    do
    {
      v7 = v6--;
      *(_DWORD *)(v3 + 40) = v6;
      if (v7 <= 0)
      {
        if (*(_DWORD *)(a1 + 572))
        {
          byte = 0;
        }
        else
        {
          byte = get_byte((uint64_t *)a1);
          if (byte == 255)
          {
            do
              v9 = get_byte((uint64_t *)a1);
            while (v9 == 255);
            if ((_BYTE)v9)
            {
              v10 = v9;
              byte = 0;
              *(_DWORD *)(a1 + 572) = v10;
            }
            else
            {
              byte = 255;
            }
          }
          v6 = *(_DWORD *)(v3 + 40);
        }
        *(_QWORD *)(v3 + 24) = byte | (*(_QWORD *)(v3 + 24) << 8);
        *(_DWORD *)(v3 + 40) = v6 + 8;
        v13 = v6 + 9;
        v11 = v6 == -9;
        v12 = v6 <= -9;
        v6 += 8;
        if (v12)
        {
          *(_DWORD *)(v3 + 40) = v13;
          v6 = v13;
          if (v11)
          {
            v6 = 0;
            *(_QWORD *)(v3 + 32) = 0x8000;
          }
        }
      }
      v4 = 2 * *(_QWORD *)(v3 + 32);
      *(_QWORD *)(v3 + 32) = v4;
    }
    while (v4 < 0x8000);
  }
  v14 = *a2;
  v15 = jpeg_aritab[v14 & 0x7F];
  v16 = v15 >> 16;
  v17 = v4 - (v15 >> 16);
  *(_QWORD *)(v3 + 32) = v17;
  v18 = v17 << v6;
  v19 = *(_QWORD *)(v3 + 24);
  v20 = __OFSUB__(v19, v18);
  v21 = v19 - v18;
  if (v21 < 0 == v20)
  {
    *(_QWORD *)(v3 + 24) = v21;
    *(_QWORD *)(v3 + 32) = v16;
    v22 = v14 & 0x80;
    if (v17 >= v16)
      goto LABEL_26;
LABEL_24:
    *a2 = v22 ^ BYTE1(v15);
    return v14 >> 7;
  }
  if (v17 < 0x8000)
  {
    v22 = v14 & 0x80;
    if (v17 < v16)
    {
LABEL_26:
      *a2 = v22 ^ v15;
      v14 ^= 0x80u;
      return v14 >> 7;
    }
    goto LABEL_24;
  }
  return v14 >> 7;
}

uint64_t get_byte(uint64_t *a1)
{
  unsigned __int8 **v1;
  uint64_t v3;
  unsigned __int8 *v4;
  uint64_t v5;

  v1 = (unsigned __int8 **)a1[5];
  if (!v1[1] && !((unsigned int (*)(void))v1[3])())
  {
    v3 = *a1;
    *(_DWORD *)(v3 + 40) = 25;
    (*(void (**)(uint64_t *))v3)(a1);
  }
  v4 = *v1;
  v5 = (uint64_t)(v1[1] - 1);
  ++*v1;
  v1[1] = (unsigned __int8 *)v5;
  return *v4;
}

void IIO_WriterHandler::~IIO_WriterHandler(IIO_WriterHandler *this)
{
  void *v2;

  *(_QWORD *)this = &off_1E1BB10F0;
  v2 = (void *)*((_QWORD *)this + 1);
  if (v2)
  {
    *((_QWORD *)this + 2) = v2;
    operator delete(v2);
  }
}

{
  void *v2;

  *(_QWORD *)this = &off_1E1BB10F0;
  v2 = (void *)*((_QWORD *)this + 1);
  if (v2)
  {
    *((_QWORD *)this + 2) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x18D761C30);
}

CFMutableArrayRef IIO_WriterHandler::copyImageFormats(IIO_WriterHandler *this, const __CFString *a2)
{
  CFMutableArrayRef Mutable;
  IIO_Writer **i;
  const __CFString *v6;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  for (i = (IIO_Writer **)*((_QWORD *)this + 1); i != *((IIO_Writer ***)this + 2); ++i)
  {
    v6 = (const __CFString *)IIO_Writer::utType(*i);
    if (CFStringCompare(v6, a2, 0) == kCFCompareEqualTo)
    {
      (*(void (**)(IIO_Writer *, CFMutableArrayRef))(*(_QWORD *)*i + 32))(*i, Mutable);
      return Mutable;
    }
  }
  return Mutable;
}

IIO_Reader *IIO_WriterHandler::findWriterForType(IIO_WriterHandler *this, const __CFString *a2, const __CFString *a3, IIODictionary *a4, IIODictionary *a5)
{
  return IIO_WriterHandler::findWriterForTypeAndAlternateType(this, a2, a3, (uint64_t)a3, a5);
}

IIO_Reader *IIO_WriterHandler::findWriterForTypeAndAlternateType(IIO_WriterHandler *this, const __CFString *a2, const __CFString *a3, uint64_t a4, IIODictionary *a5)
{
  IIO_Reader *WriterForType;
  IIO_Reader *v8;
  const char *v9;
  int v10;
  const char *v11;
  _BYTE v13[24];

  WriterForType = IIO_WriterHandler::getWriterForType(this, a2, a3);
  if (!WriterForType)
  {
    IIOString::IIOString((IIOString *)v13, a2);
    v11 = (const char *)IIOString::utf8String((IIOString *)v13);
    LogError("findWriterForTypeAndAlternateType", 132, "*** ERROR: unsupported output file format '%s'\n", v11);
    IIOString::~IIOString((IIOString *)v13);
    kdebug_trace();
    return 0;
  }
  v8 = WriterForType;
  if (a4 && IIO_Reader::testHeaderSize(WriterForType) != -1 && IIO_Reader::testHeaderSize(v8) < a4)
  {
    IIOString::IIOString((IIOString *)v13, a2);
    v9 = (const char *)IIOString::utf8String((IIOString *)v13);
    v10 = IIO_Reader::testHeaderSize(v8);
    LogError("findWriterForTypeAndAlternateType", 141, "*** ERROR: capacity parameter (%d) is too large for this file format '%s' (max is %d)\n", a4, v9, v10);
    IIOString::~IIOString((IIOString *)v13);
    return 0;
  }
  return v8;
}

void sub_187FC9618(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void png_set_cHRM_fixed(void (**a1)(void), uint64_t a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  int v12[8];

  if (a1 && a2)
  {
    v12[0] = a5;
    v12[1] = a6;
    v12[2] = a7;
    v12[3] = a8;
    v12[4] = a9;
    v12[5] = a10;
    v12[6] = a3;
    v12[7] = a4;
    if (png_colorspace_set_chromaticities(a1, a2 + 52, v12, 2))
      *(_WORD *)(a2 + 126) |= 0x10u;
    png_colorspace_sync_info((uint64_t)a1, a2);
  }
}

void _cg_png_set_cHRM(void (**a1)(void), uint64_t a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;

  v19 = png_fixed(a1, (uint64_t)"cHRM White X", a3);
  v20 = png_fixed(a1, (uint64_t)"cHRM White Y", a4);
  v21 = png_fixed(a1, (uint64_t)"cHRM Red X", a5);
  v22 = png_fixed(a1, (uint64_t)"cHRM Red Y", a6);
  v23 = png_fixed(a1, (uint64_t)"cHRM Green X", a7);
  v24 = png_fixed(a1, (uint64_t)"cHRM Green Y", a8);
  v25 = png_fixed(a1, (uint64_t)"cHRM Blue X", a9);
  v26 = png_fixed(a1, (uint64_t)"cHRM Blue Y", a10);
  png_set_cHRM_fixed(a1, a2, v19, v20, v21, v22, v23, v24, v25, v26);
}

void png_set_gAMA_fixed(uint64_t a1, uint64_t a2, int a3)
{
  if (a1)
  {
    if (a2)
    {
      png_colorspace_set_gamma(a1, a2 + 52, a3);
      png_colorspace_sync_info(a1, a2);
    }
  }
}

void _cg_png_set_gAMA(void (**a1)(void), uint64_t a2, double a3)
{
  int v5;

  v5 = png_fixed(a1, (uint64_t)"png_set_gAMA", a3);
  png_set_gAMA_fixed((uint64_t)a1, a2, v5);
}

_QWORD *png_set_hIST(_QWORD *result, uint64_t a2, const void *a3)
{
  _QWORD *v4;
  char *v5;

  if (result && a2)
  {
    v4 = result;
    if (*(unsigned __int16 *)(a2 + 32) - 257 <= 0xFFFFFEFF)
    {
      v5 = "Invalid palette size, hIST allocation skipped";
      return (_QWORD *)png_warning((uint64_t)v4, v5);
    }
    png_free_data((uint64_t)result, a2, 8u, 0);
    result = png_malloc_warn(v4, 0x200uLL);
    *(_QWORD *)(a2 + 256) = result;
    if (!result)
    {
      v5 = "Insufficient memory for hIST chunk data";
      return (_QWORD *)png_warning((uint64_t)v4, v5);
    }
    if (*(_WORD *)(a2 + 32))
      result = memcpy(result, a3, 2 * *(unsigned __int16 *)(a2 + 32));
    *(_DWORD *)(a2 + 300) |= 8u;
    *(_DWORD *)(a2 + 8) |= 0x40u;
  }
  return result;
}

uint64_t png_set_oFFs(uint64_t result, uint64_t a2, int a3, int a4, char a5)
{
  if (result)
  {
    if (a2)
    {
      *(_DWORD *)(a2 + 212) = a3;
      *(_DWORD *)(a2 + 216) = a4;
      *(_BYTE *)(a2 + 220) = a5;
      *(_DWORD *)(a2 + 8) |= 0x100u;
    }
  }
  return result;
}

void png_set_pCAL_sized(_QWORD *a1, uint64_t a2, char *__s, int a4, int a5, unsigned int a6, unsigned int a7, const char *a8, const char **a9)
{
  const char **v17;
  size_t v18;
  char *v19;
  uint64_t v20;
  size_t v21;
  _QWORD *v22;
  size_t v23;
  _QWORD *v24;
  _QWORD *v25;
  unint64_t v26;
  uint64_t v27;
  size_t v28;
  _QWORD *v29;
  _QWORD *v30;
  char *v31;
  int v32;
  size_t v33;

  if (!a1)
    return;
  if (!a2)
    return;
  if (!__s)
    return;
  if (!a8)
    return;
  v17 = a9;
  if ((int)a7 >= 1 && !a9)
    return;
  v18 = strlen(__s);
  if (a6 >= 4)
  {
    v19 = "Invalid pCAL equation type";
LABEL_27:
    png_chunk_report((uint64_t)a1, v19, 1);
    return;
  }
  if (a7 > 0xFF)
  {
    v19 = "Invalid pCAL parameter count";
    goto LABEL_27;
  }
  v33 = v18;
  v32 = a5;
  if (a7)
  {
    v20 = a7;
    while (*v17)
    {
      v21 = strlen(*v17);
      if (!png_check_fp_string((uint64_t)*v17, v21))
        break;
      ++v17;
      if (!--v20)
        goto LABEL_17;
    }
    v19 = "Invalid format for pCAL parameter";
    goto LABEL_27;
  }
LABEL_17:
  v22 = png_malloc_warn(a1, v33 + 1);
  *(_QWORD *)(a2 + 264) = v22;
  if (!v22)
  {
    v19 = "Insufficient memory for pCAL purpose";
    goto LABEL_27;
  }
  memcpy(v22, __s, v33 + 1);
  *(_DWORD *)(a2 + 300) |= 0x80u;
  *(_DWORD *)(a2 + 272) = a4;
  *(_DWORD *)(a2 + 276) = v32;
  *(_BYTE *)(a2 + 296) = a6;
  v23 = strlen(a8) + 1;
  v24 = png_malloc_warn(a1, v23);
  *(_QWORD *)(a2 + 280) = v24;
  if (v24)
  {
    memcpy(v24, a8, v23);
    v25 = png_malloc_warn(a1, 8 * a7);
    *(_QWORD *)(a2 + 288) = v25;
    *(_BYTE *)(a2 + 297) = a7;
    if (v25)
    {
      bzero(v25, 8 * a7);
      if ((int)a7 < 1)
      {
LABEL_24:
        *(_DWORD *)(a2 + 8) |= 0x400u;
        return;
      }
      v26 = 0;
      v27 = 8 * a7;
      while (1)
      {
        v28 = strlen(a9[v26 / 8]) + 1;
        v29 = png_malloc_warn(a1, v28);
        if (!v29)
          break;
        v30 = v29;
        memcpy(v29, a9[v26 / 8], v28);
        *(_QWORD *)(*(_QWORD *)(a2 + 288) + v26) = v30;
        v26 += 8;
        if (v27 == v26)
          goto LABEL_24;
      }
      v31 = "Insufficient memory for pCAL parameter";
    }
    else
    {
      v31 = "Insufficient memory for pCAL params";
    }
  }
  else
  {
    v31 = "Insufficient memory for pCAL units";
  }
  png_warning((uint64_t)a1, v31);
}

void (**png_set_sCAL_sized(void (**result)(void), uint64_t a2, int a3, char *__s, const char *a5))(void)
{
  char v6;
  void (**v7)(void);
  size_t v10;
  size_t v11;
  size_t v12;
  size_t v13;
  _QWORD *v14;
  _QWORD *v15;
  const char *v16;

  if (result && a2)
  {
    v6 = a3;
    v7 = result;
    if ((a3 - 3) <= 0xFFFFFFFD)
    {
      v16 = "Invalid sCAL unit";
    }
    else if (__s
           && (v10 = strlen(__s)) != 0
           && *__s != 45
           && (v11 = v10, png_check_fp_string((uint64_t)__s, v10)))
    {
      if (a5)
      {
        v12 = strlen(a5);
        if (v12)
        {
          if (*a5 != 45)
          {
            v13 = v12;
            if (png_check_fp_string((uint64_t)a5, v12))
            {
              *(_BYTE *)(a2 + 332) = v6;
              v14 = png_malloc_warn(v7, v11 + 1);
              *(_QWORD *)(a2 + 336) = v14;
              if (v14)
              {
                memcpy(v14, __s, v11 + 1);
                v15 = png_malloc_warn(v7, v13 + 1);
                *(_QWORD *)(a2 + 344) = v15;
                if (v15)
                {
                  result = (void (**)(void))memcpy(v15, a5, v13 + 1);
                  *(_DWORD *)(a2 + 300) |= 0x100u;
                  *(_DWORD *)(a2 + 8) |= 0x4000u;
                  return result;
                }
                png_free((uint64_t)v7, *(void **)(a2 + 336));
                *(_QWORD *)(a2 + 336) = 0;
              }
              return (void (**)(void))png_warning((uint64_t)v7, "Memory allocation failed while processing sCAL");
            }
          }
        }
      }
      v16 = "Invalid sCAL height";
    }
    else
    {
      v16 = "Invalid sCAL width";
    }
    _cg_png_error(v7, v16);
  }
  return result;
}

uint64_t _cg_png_set_text(void (**a1)(void), uint64_t a2, uint64_t a3, signed int a4)
{
  uint64_t result;

  result = png_set_text_2(a1, a2, a3, a4);
  if ((_DWORD)result)
    _cg_png_error(a1, "Insufficient memory to store text");
  return result;
}

void png_set_sPLT(void (**a1)(void), uint64_t a2, uint64_t a3, signed int a4)
{
  int v6;
  uint64_t v7;
  signed int v8;
  char *v9;
  char *v10;
  char *v11;
  const char *v12;
  size_t v13;
  void *v14;
  void *v15;
  uint64_t v16;

  if (!a3)
    return;
  if (!a1)
    return;
  if (!a2)
    return;
  v6 = a4;
  if (a4 < 1)
    return;
  v7 = a3;
  v8 = *(_DWORD *)(a2 + 328);
  v9 = png_realloc_array(a1, *(const void **)(a2 + 320), v8, a4, 0x28uLL);
  if (!v9)
  {
    png_chunk_report((uint64_t)a1, "too many sPLT chunks", 1);
    return;
  }
  v10 = v9;
  png_free((uint64_t)a1, *(void **)(a2 + 320));
  *(_QWORD *)(a2 + 320) = v10;
  *(_DWORD *)(a2 + 328) = v8 + v6;
  *(_DWORD *)(a2 + 300) |= 0x20u;
  v11 = &v10[40 * v8];
  while (1)
  {
    v12 = *(const char **)v7;
    if (!*(_QWORD *)v7 || !*(_QWORD *)(v7 + 24))
    {
      png_app_error((uint64_t)a1, "png_set_sPLT: invalid sPLT");
      goto LABEL_13;
    }
    v11[16] = *(_BYTE *)(v7 + 16);
    v13 = strlen(v12) + 1;
    v14 = png_malloc_base((uint64_t)a1, v13);
    *(_QWORD *)v11 = v14;
    *((_QWORD *)v11 + 1) = v13;
    if (!v14)
      goto LABEL_17;
    memcpy(v14, *(const void **)v7, v13);
    v15 = png_malloc_array(a1, *(_DWORD *)(v7 + 32), 0xAuLL);
    *((_QWORD *)v11 + 3) = v15;
    v16 = *(unsigned int *)(v7 + 32);
    *((_DWORD *)v11 + 8) = v16;
    if (!v15)
      break;
    memcpy(v15, *(const void **)(v7 + 24), 10 * v16);
    *(_DWORD *)(a2 + 8) |= 0x2000u;
    ++v8;
    v11 += 40;
    v7 += 40;
LABEL_13:
    if (!--v6)
      goto LABEL_19;
  }
  png_free((uint64_t)a1, *(void **)v11);
  *(_QWORD *)v11 = 0;
  *((_QWORD *)v11 + 1) = 0;
LABEL_17:
  if (v6 >= 1)
    png_chunk_report((uint64_t)a1, "sPLT out of memory", 1);
LABEL_19:
  *(_DWORD *)(a2 + 328) = v8;
}

uint64_t _cg_png_set_acTL(uint64_t a1, _DWORD *a2, int a3, int a4)
{
  char *v5;

  if (a1 && a2)
  {
    if (a3)
    {
      if (a3 < 0)
      {
        v5 = "Ignoring attempt to set acTL with num_frames > 2^31-1";
      }
      else
      {
        if ((a4 & 0x80000000) == 0)
        {
          a2[90] = a3;
          a2[91] = a4;
          a2[2] |= 0x20000u;
          return 1;
        }
        v5 = "Ignoring attempt to set acTL with num_plays > 2^31-1";
      }
    }
    else
    {
      v5 = "Ignoring attempt to set acTL with num_frames zero";
    }
  }
  else
  {
    v5 = "Call to png_set_acTL() with NULL png_ptr or info_ptr ignored";
  }
  png_warning(a1, v5);
  return 0;
}

uint64_t png_set_next_frame_fcTL(uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6, __int16 a7, __int16 a8, unsigned __int8 a9, unsigned __int8 a10)
{
  char v18;

  if (a1 && a2)
  {
    v18 = a10;
    png_ensure_fcTL_is_valid(a1, a3, a4, a5, a6, 0, 0, a9, a10);
    if (a10 == 1)
    {
      if ((*(_BYTE *)(a1 + 391) & 4) != 0 || _cg_png_get_valid(a1, a2, 0x10u))
      {
        v18 = 1;
      }
      else
      {
        png_warning(a1, "PNG_BLEND_OP_OVER is meaningless and wasteful for opaque images, ignored");
        v18 = 0;
      }
    }
    *(_DWORD *)(a2 + 368) = a3;
    *(_DWORD *)(a2 + 372) = a4;
    *(_DWORD *)(a2 + 376) = a5;
    *(_DWORD *)(a2 + 380) = a6;
    *(_WORD *)(a2 + 384) = a7;
    *(_WORD *)(a2 + 386) = a8;
    *(_BYTE *)(a2 + 388) = a9;
    *(_BYTE *)(a2 + 389) = v18;
    *(_DWORD *)(a2 + 8) |= 0x40000u;
    return 1;
  }
  else
  {
    png_warning(a1, "Call to png_set_fcTL() with NULL png_ptr or info_ptr ignored");
    return 0;
  }
}

uint64_t png_ensure_fcTL_is_valid(uint64_t result, int a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7, unsigned int a8, unsigned __int8 a9)
{
  if (a2 <= 0)
    _cg_png_error((void (**)(void))result, "invalid width in fcTL (> 2^31-1)");
  if (a3 <= 0)
    _cg_png_error((void (**)(void))result, "invalid height in fcTL (> 2^31-1)");
  if (a4 < 0)
    _cg_png_error((void (**)(void))result, "invalid x_offset in fcTL (> 2^31-1)");
  if (a5 < 0)
    _cg_png_error((void (**)(void))result, "invalid y_offset in fcTL (> 2^31-1)");
  if ((a4 + a2) > *(_DWORD *)(result + 776) || (a5 + a3) > *(_DWORD *)(result + 780))
    _cg_png_error((void (**)(void))result, "dimensions of a frame are greater thanthe ones in IHDR");
  if (a8 >= 3)
    _cg_png_error((void (**)(void))result, "invalid dispose_op in fcTL");
  if (a9 >= 2u)
    _cg_png_error((void (**)(void))result, "invalid blend_op in fcTL");
  return result;
}

uint64_t _cg_png_set_num_frames_read(uint64_t result, uint64_t a2, int a3)
{
  if (result)
    *(_DWORD *)(result + 784) = a3;
  return result;
}

uint64_t _cg_png_set_next_seq_num(uint64_t result, uint64_t a2, int a3)
{
  if (result)
    *(_DWORD *)(result + 772) = a3;
  return result;
}

void _cg_png_set_unknown_chunks(void (**a1)(void), uint64_t a2, uint64_t a3, signed int a4)
{
  signed int v8;
  char *v9;
  char *v10;
  char *v11;
  int v12;
  uint64_t i;
  void *v14;
  size_t v15;

  if (a3 && a1 && a2 && a4 >= 1)
  {
    v8 = *(_DWORD *)(a2 + 312);
    v9 = png_realloc_array(a1, *(const void **)(a2 + 304), v8, a4, 0x20uLL);
    if (!v9)
    {
      png_chunk_report((uint64_t)a1, "too many unknown chunks", 1);
      return;
    }
    v10 = v9;
    v11 = &v9[32 * v8];
    v12 = a4 + 1;
    for (i = a3 + 16; ; i += 32)
    {
      *(_DWORD *)v11 = *(_DWORD *)(i - 16);
      v11[4] = 0;
      v11[24] = check_location((uint64_t)a1, *(_BYTE *)(i + 8));
      if (*(_QWORD *)i)
      {
        v14 = png_malloc_base((uint64_t)a1, *(_QWORD *)i);
        v15 = *(_QWORD *)i;
        *((_QWORD *)v11 + 1) = v14;
        *((_QWORD *)v11 + 2) = v15;
        if (!v14)
        {
          png_chunk_report((uint64_t)a1, "unknown chunk: out of memory", 1);
          goto LABEL_13;
        }
        memcpy(v14, *(const void **)(i - 8), *(_QWORD *)i);
      }
      else
      {
        *((_QWORD *)v11 + 1) = 0;
        *((_QWORD *)v11 + 2) = 0;
      }
      v11 += 32;
      ++v8;
LABEL_13:
      if (--v12 <= 1)
      {
        png_free((uint64_t)a1, *(void **)(a2 + 304));
        *(_QWORD *)(a2 + 304) = v10;
        *(_DWORD *)(a2 + 312) = v8;
        *(_DWORD *)(a2 + 300) |= 0x200u;
        return;
      }
    }
  }
}

void IIO_Writer_GIF::~IIO_Writer_GIF(IIO_Writer_GIF *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

uint64_t IIO_Writer_GIF::write(IIO_Writer_GIF *this, IIOImageWriteSession *a2, IIOImageDestination *a3)
{
  uint64_t v3;
  _OWORD v5[8];
  uint64_t v6;

  v6 = 0;
  memset(v5, 0, sizeof(v5));
  GIFWritePlugin::GIFWritePlugin((GIFWritePlugin *)v5, a2, a3);
  v3 = GIFWritePlugin::writeAll((GIFWritePlugin *)v5);
  GIFWritePlugin::~GIFWritePlugin((GIFWritePlugin *)v5);
  return v3;
}

void sub_187FCA34C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  GIFWritePlugin::~GIFWritePlugin((GIFWritePlugin *)&a9);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187FCA338);
}

void PDFWritePlugin::PDFWritePlugin(PDFWritePlugin *this, IIOImageWriteSession *a2, IIOImageDestination *a3)
{
  _QWORD *v3;

  IIOWritePlugin::IIOWritePlugin(this, a2, a3, 0x13u);
  *v3 = &off_1E1BAFBA0;
  v3[6] = 0;
  v3[7] = 0;
  v3[5] = 0;
}

void PDFWritePlugin::~PDFWritePlugin(PDFWritePlugin *this, uint64_t a2, const char *a3)
{
  const void *v4;
  const void *v5;
  const void *v6;

  *(_QWORD *)this = &off_1E1BAFBA0;
  v4 = (const void *)*((_QWORD *)this + 6);
  if (v4)
    CFRelease(v4);
  v5 = (const void *)*((_QWORD *)this + 7);
  if (v5)
    CFRelease(v5);
  v6 = (const void *)*((_QWORD *)this + 5);
  if (v6)
    CFRelease(v6);
  _cg_jpeg_mem_term(this, a2, a3);
}

{
  PDFWritePlugin::~PDFWritePlugin(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

uint64_t PDFWritePlugin::writeOneImage(CGContextRef *this, CGImageRef image, IIODictionary *a3, IIODictionary *a4)
{
  double Width;
  size_t Height;
  double v10;
  float FloatForKey;
  double v12;
  float v13;
  float v15;
  _BYTE v17[24];
  _QWORD v18[3];
  CGRect mediaBox;

  mediaBox.origin.x = 0.0;
  mediaBox.origin.y = 0.0;
  if (this[6])
  {
    Width = (double)CGImageGetWidth(image);
    mediaBox.size.width = Width;
    Height = CGImageGetHeight(image);
    v10 = (double)Height;
    mediaBox.size.height = (double)Height;
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("    mediaBox.size: %g x %g\n", Width, (double)Height);
    if (IIODictionary::containsKey(a3, CFSTR("DPIHeight")))
    {
      if (IIODictionary::containsKey(a3, CFSTR("DPIWidth")))
      {
        FloatForKey = IIODictionary::getFloatForKey(a3, CFSTR("DPIWidth"));
        v12 = v10 / IIODictionary::getFloatForKey(a3, CFSTR("DPIHeight")) * 72.0;
        mediaBox.size.width = Width / FloatForKey * 72.0;
        mediaBox.size.height = v12;
        if ((gIIODebugFlags & 0x30000) != 0)
          ImageIOLog("    mediaBox.size: %g x %g\n", Width / FloatForKey * 72.0, v12);
      }
    }
    CGContextBeginPage(this[6], &mediaBox);
    memset(v18, 0, sizeof(v18));
    IIODictionary::IIODictionary((IIODictionary *)v18);
    if (IIODictionary::containsKey(a4, CFSTR("kCGImageDestinationLossyCompressionQuality")))
    {
      v13 = IIODictionary::getFloatForKey(a4, CFSTR("kCGImageDestinationLossyCompressionQuality"));
      if (v13 > 1.0 || v13 < 0.0)
        v15 = 0.8;
      else
        v15 = v13;
    }
    else
    {
      v15 = 0.8;
    }
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("    qualityVal: %g\n", v15);
    IIONumber::IIONumber((IIONumber *)v17, v15);
    IIODictionary::setObjectForKey((uint64_t)v18, (uint64_t)v17, CFSTR("kCGImageDestinationLossyCompressionQuality"));
    IIONumber::~IIONumber((IIONumber *)v17);
    if ((CGContextDrawImageWithOptions() & 1) == 0)
    {
      if ((gIIODebugFlags & 0x30000) != 0)
        ImageIOLog("    CGContextDrawImageWithOptions failed -- falling back to CGContextDrawImage\n");
      CGContextDrawImage(this[6], mediaBox, image);
    }
    IIODictionary::~IIODictionary((IIODictionary *)v18);
    CGContextEndPage(this[6]);
  }
  else
  {
    _cg_jpeg_mem_term("writeOneImage", 52, "*** _context is NULL\n", a4);
  }
  return 0;
}

void sub_187FCA67C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  _Unwind_Resume(a1);
}

uint64_t PDFWritePlugin::writeOne(PDFWritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

CGContextRef PDFWritePlugin::setup(PDFWritePlugin *this)
{
  CGDataConsumer *v2;
  CGContextRef result;
  __int128 v4;

  v4 = xmmword_1E1BC4B88;
  *((_QWORD *)this + 7) = 0;
  v2 = CGDataConsumerCreate(*((void **)this + 2), (const CGDataConsumerCallbacks *)&v4);
  *((_QWORD *)this + 5) = v2;
  result = CGPDFContextCreate(v2, 0, *((CFDictionaryRef *)this + 7));
  *((_QWORD *)this + 6) = result;
  return result;
}

void PDFWritePlugin::done(CGContextRef *this)
{
  CGPDFContextClose(this[6]);
}

__CFString *CopyProfileFromParams(IIODictionary *a1)
{
  const __CFDictionary *ObjectForKey;
  __CFString *v2;
  CFTypeID v3;
  CFTypeID v5;
  off_t st_size;
  __CFData *Mutable;
  int v8;
  int v9;
  UInt8 *MutableBytePtr;
  __CFData *v11;
  stat v12;
  char buffer[1024];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  ObjectForKey = IIODictionary::getObjectForKey(a1, CFSTR("kCGImageCopyFileSetProfile"));
  v2 = (__CFString *)ObjectForKey;
  if (ObjectForKey)
  {
    v3 = CFGetTypeID(ObjectForKey);
    if (v3 == CFDataGetTypeID())
      return (__CFString *)CFRetain(v2);
    v5 = CFGetTypeID(v2);
    if (v5 == CFStringGetTypeID())
    {
      bzero(buffer, 0x400uLL);
      if (CFStringGetCString(v2, buffer, 1024, 0x8000100u))
      {
        memset(&v12, 0, sizeof(v12));
        if (!stat(buffer, &v12))
        {
          st_size = v12.st_size;
          if (v12.st_size)
          {
            Mutable = CFDataCreateMutable(0, v12.st_size);
            v2 = (__CFString *)Mutable;
            if (Mutable)
            {
              CFDataSetLength(Mutable, st_size);
              v8 = open(buffer, 0, 438);
              v9 = v8;
              if ((gIIODebugFlags & 0x200000000000) != 0)
                ImageIOLog(">>> %s: opening file [%d] '%s'\n", "CopyProfileFromParams", v8, buffer);
              if (v9)
              {
                MutableBytePtr = CFDataGetMutableBytePtr((CFMutableDataRef)v2);
                read(v9, MutableBytePtr, st_size);
                if ((gIIODebugFlags & 0x200000000000) != 0)
                  ImageIOLog("<<< %s: closing file [%d] '%s'\n", "CopyProfileFromParams", v9, buffer);
                close(v9);
              }
            }
            return v2;
          }
        }
      }
    }
    else if (v2 == (__CFString *)*MEMORY[0x1E0C9B0D0])
    {
      v11 = CFDataCreateMutable(0, 0);
      v2 = (__CFString *)v11;
      if (v11)
        CFDataSetLength(v11, 0);
      return v2;
    }
    return 0;
  }
  return v2;
}

const __CFDictionary *CopyOrientationFromParams(IIODictionary *a1, _WORD *a2)
{
  const __CFDictionary *result;
  unsigned int Uint32ForKey;
  __int16 v6;

  result = IIODictionary::containsKey(a1, CFSTR("kCGImageCopyFileSetOrientation"));
  if ((_DWORD)result)
  {
    Uint32ForKey = IIODictionary::getUint32ForKey(a1, CFSTR("kCGImageCopyFileSetOrientation"));
    if (a2)
    {
      if (Uint32ForKey - 9 >= 0xFFFFFFF8)
        v6 = Uint32ForKey;
      else
        v6 = 0;
      *a2 = v6;
      return (const __CFDictionary *)1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL CopyDateTimeFromParams(IIODictionary *a1, char *a2)
{
  const __CFDictionary *ObjectForKey;
  const char *v5;
  uint64_t i;
  int v7;
  _BOOL8 result;
  _BYTE v9[24];

  if (!IIODictionary::containsKey(a1, CFSTR("kCGImageCopyFileSetDateTime")))
    return 1;
  ObjectForKey = IIODictionary::getObjectForKey(a1, CFSTR("kCGImageCopyFileSetDateTime"));
  IIOString::IIOString((IIOString *)v9, ObjectForKey);
  v5 = (const char *)IIOString::utf8String((IIOString *)v9);
  strncpy(a2, v5, 0x14uLL);
  IIOString::~IIOString((IIOString *)v9);
  if (strlen(a2) == 19)
  {
    for (i = 0; i != 20; ++i)
    {
      v7 = a2[i];
      if (v7 < a10000000000000[i] || v7 > a29991939295959[i])
        *a2 = 0;
    }
    return *a2 != 0;
  }
  else
  {
    result = 0;
    *a2 = 0;
  }
  return result;
}

void sub_187FCAA7C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

IIODictionary *copyIPTCDictFromParams(IIODictionary *a1)
{
  const __CFDictionary *ObjectForKey;
  const __CFDictionary *v3;
  IIODictionary *v4;
  const __CFArray *v5;
  IIODictionary *v6;
  const __CFDictionary *v7;
  __CFArray *MutableCopy;
  const __CFDictionary *v9;
  unsigned int Uint32ForKey;
  char v11;
  char v12;
  _BYTE v14[16];
  void *value;
  char v16[2];
  CFRange v17;

  if (!a1)
    return 0;
  ObjectForKey = IIODictionary::getObjectForKey(a1, CFSTR("kCGImageCopyFileSetIPTC"));
  v3 = IIODictionary::getObjectForKey(a1, CFSTR("kCGImageCopyFileSetKeywords"));
  if (!((unint64_t)ObjectForKey | (unint64_t)v3))
    return 0;
  v5 = v3;
  v6 = (IIODictionary *)operator new();
  v4 = v6;
  if (ObjectForKey)
    IIODictionary::IIODictionary(v6, ObjectForKey, 1);
  else
    IIODictionary::IIODictionary(v6);
  v7 = IIODictionary::getObjectForKey(v4, CFSTR("Keywords"));
  if (v7)
  {
    MutableCopy = CFArrayCreateMutableCopy(0, 0, v7);
  }
  else
  {
    MutableCopy = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    v9 = IIODictionary::getObjectForKey(v4, CFSTR("Keywords"));
    if (v9)
      CFArrayAppendValue(MutableCopy, v9);
  }
  IIODictionary::setObjectForKey(v4, MutableCopy, CFSTR("Keywords"));
  if (v5)
  {
    v17.length = CFArrayGetCount(v5);
    v17.location = 0;
    CFArrayAppendArray(MutableCopy, v5, v17);
  }
  CFRelease(MutableCopy);
  if (IIODictionary::containsKey(a1, CFSTR("kCGImageCopyFileSetStarRating")))
  {
    Uint32ForKey = IIODictionary::getUint32ForKey(a1, CFSTR("kCGImageCopyFileSetStarRating"));
    if (Uint32ForKey >= 5)
      v11 = 5;
    else
      v11 = Uint32ForKey;
    v12 = v11 | 0x30;
    if (!Uint32ForKey)
      v12 = 49;
    v16[1] = 0;
    v16[0] = v12;
    IIOString::IIOString((IIOString *)v14, v16);
    IIODictionary::setObjectForKey(v4, value, CFSTR("StarRating"));
    IIOString::~IIOString((IIOString *)v14);
  }
  return v4;
}

void sub_187FCAC50(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

__CFData *copyIPTCFromParams(IIODictionary *a1)
{
  IIODictionary *v1;
  CFDictionaryRef *v2;
  CFIndex v3;
  CFIndex v4;
  __CFData *Mutable;
  __CFData *v6;
  unsigned __int8 *MutableBytePtr;

  if (!a1)
    return 0;
  v1 = copyIPTCDictFromParams(a1);
  if (!v1)
    return 0;
  v2 = (CFDictionaryRef *)v1;
  v3 = SizeOfIPTCData(v1);
  if (v3)
  {
    v4 = v3;
    Mutable = CFDataCreateMutable(0, v3);
    v6 = Mutable;
    if (Mutable)
    {
      CFDataSetLength(Mutable, v4);
      MutableBytePtr = CFDataGetMutableBytePtr(v6);
      if (MutableBytePtr)
        WriteIPTCData(v2, MutableBytePtr);
    }
  }
  else
  {
    v6 = 0;
  }
  (*((void (**)(CFDictionaryRef *))*v2 + 1))(v2);
  return v6;
}

void CopyJPEGXMPFromXMPParams(IIODictionary *a1, CFDataRef *a2, CFDataRef *a3, CFDataRef *a4)
{
  const __CFDictionary *ObjectForKey;
  __CFArray *v8;
  CFTypeID v9;
  CGImageMetadata *v10;
  CGImageMetadata *v11;

  if (a2)
  {
    if (a3)
    {
      if (a4)
      {
        *a2 = 0;
        *a3 = 0;
        *a4 = 0;
        if (a1)
        {
          ObjectForKey = IIODictionary::getObjectForKey(a1, CFSTR("kCGImageCopyFileSetXMP"));
          if (ObjectForKey)
          {
            v8 = ObjectForKey;
            v9 = CFGetTypeID(ObjectForKey);
            if (v9 == CFArrayGetTypeID())
            {
              v10 = CGImageMetadataCreateFromMetadataProperties(v8);
              if (v10)
              {
                v11 = v10;
                CGImageMetadataCreateSerializedDataAndExtendedData((CFDictionaryRef *)v10, a2, a3, a4);
                CFRelease(v11);
              }
            }
            else
            {
              LogError("CopyJPEGXMPFromXMPParams", 721, "*** ERROR: value for kCGImageCopyFileSetXMP must be a CFArray");
            }
          }
        }
      }
    }
  }
}

CFDataRef CopyXMPFromIPTCParams(IIODictionary *a1)
{
  IIODictionary *v1;
  const void **v2;
  IIODictionary *v3;
  const CGImageMetadata *v4;
  CFDataRef XMPData;

  if (!a1)
    return 0;
  v1 = copyIPTCDictFromParams(a1);
  if (!v1)
    return 0;
  v2 = (const void **)v1;
  v3 = (IIODictionary *)operator new();
  IIODictionary::IIODictionary(v3);
  IIODictionary::setObjectForKey(v3, v2[1], CFSTR("{IPTC}"));
  v4 = (const CGImageMetadata *)CGImageMetadataCreateFromLegacyProps(v3);
  XMPData = CGImageMetadataCreateXMPData(v4, 0);
  (*(void (**)(IIODictionary *))(*(_QWORD *)v3 + 8))(v3);
  (*((void (**)(const void **))*v2 + 1))(v2);
  if (v4)
    CFRelease(v4);
  return XMPData;
}

void sub_187FCAEB0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

BOOL CGImageCopyFileWithParametersOLD(__CFString *a1, const __CFString *a2, IIODictionary *a3)
{
  CFTypeID v6;
  CFTypeID v7;
  CFIndex MaximumSizeOfFileSystemRepresentation;
  std::__fs::filesystem::path *v9;
  CFIndex v10;
  char *v11;
  char *v12;
  size_t v13;
  const __CFURL *v14;
  const void *v15;
  uint64_t v16;
  IIOImageRead *Source;
  unint64_t Size;
  size_t v19;
  _QWORD *v20;
  const void *v21;
  IIOImageReadSession *v22;
  FILE *FILE;
  FILE *v24;
  FILE *v25;
  FILE *v26;
  char *v27;
  _BOOL8 v28;
  __CFData *v29;
  __CFString *v30;
  const __CFData *v31;
  BOOL v32;
  char v33;
  BOOL v34;
  _BOOL4 v35;
  _BOOL4 v36;
  char v37;
  _BOOL4 v38;
  _BOOL4 v39;
  int v40;
  UInt8 *v41;
  UInt8 *v42;
  const __CFAllocator *v43;
  CFDataRef v44;
  const __CFData *v45;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v47;
  const __CFDictionary *v48;
  const __CFData *EXIFJPEGData;
  const __CFData *v50;
  FILE *v51;
  FILE *v52;
  size_t Length;
  BOOL v54;
  CFIndex v55;
  std::__fs::filesystem::path *v56;
  std::error_code *v57;
  int v58;
  int *v59;
  char *v60;
  int *v61;
  char *v63;
  __CFDictionary *ObjectForKey;
  __CFDictionary *BytePtr;
  int v66;
  __CFData *cf;
  const void *v68;
  __CFString *v69;
  const __CFData *v70;
  int __ptr;
  BOOL v72;
  unsigned __int16 v73;
  BOOL v74;
  BOOL v75[2];
  _QWORD v76[2];
  int v77;
  uint64_t v78;

  v78 = *MEMORY[0x1E0C80C00];
  *(_WORD *)v75 = 0;
  v74 = 0;
  v73 = 0;
  v72 = 0;
  v76[0] = 0;
  v76[1] = 0;
  v77 = 0;
  if (!a1)
    return 0;
  v6 = CFGetTypeID(a1);
  if (v6 != CFStringGetTypeID() && v6 != CFDataGetTypeID() && v6 != CGDataProviderGetTypeID())
    return 0;
  if (a2)
  {
    v7 = CFGetTypeID(a2);
    if (v7 == CFStringGetTypeID())
    {
      MaximumSizeOfFileSystemRepresentation = CFStringGetMaximumSizeOfFileSystemRepresentation(a2);
      v9 = (std::__fs::filesystem::path *)malloc_type_malloc(MaximumSizeOfFileSystemRepresentation, 0x1AF28F41uLL);
      CFStringGetFileSystemRepresentation(a2, (char *)v9, MaximumSizeOfFileSystemRepresentation);
      goto LABEL_13;
    }
    return 0;
  }
  if (v6 != CFStringGetTypeID())
    return 0;
  v10 = CFStringGetMaximumSizeOfFileSystemRepresentation(a1);
  v9 = (std::__fs::filesystem::path *)malloc_type_malloc(v10 + 6, 0xDDB13DC9uLL);
  CFStringGetFileSystemRepresentation(a1, (char *)v9, v10);
  v11 = strrchr((char *)v9, 47);
  if (v11)
    v12 = v11 + 1;
  else
    v12 = (char *)v9;
  v13 = strlen(v12);
  memmove(v12 + 1, v12, v13 + 1);
  *v12 = 46;
  strcat((char *)v9, "-XXXX");
  mktemp((char *)v9);
LABEL_13:
  if (v6 == CFStringGetTypeID())
  {
    v14 = CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, kCFURLPOSIXPathStyle, 0);
    v15 = (const void *)CGImageReadCreateWithURL(0, v14, (unsigned __int8 *)1, 0, 0);
    CFRelease(v14);
    if (!v15)
      goto LABEL_131;
LABEL_21:
    Source = (IIOImageRead *)CGImageSourceGetSource((uint64_t)v15);
    Size = IIOImageRead::getSize(Source);
    if (Size < 0xC || (v19 = Size, (v20 = CGImageReadSessionCreate(v15)) == 0))
    {
      CFRelease(v15);
      goto LABEL_131;
    }
    v21 = v20;
    v22 = (IIOImageReadSession *)CGImageSourceGetSource((uint64_t)v20);
    FILE = IIOImageReadSession::createFILE(v22);
    if (!FILE)
    {
      v28 = 0;
LABEL_44:
      CFRelease(v15);
      CFRelease(v21);
      if (!v9)
        return v28;
      goto LABEL_45;
    }
    v24 = FILE;
    v68 = v21;
    v25 = fopen((const char *)v9, "wb");
    if (!v25)
    {
      fclose(v24);
      v28 = 0;
LABEL_43:
      v21 = v68;
      goto LABEL_44;
    }
    v26 = v25;
    flockfile(v24);
    flockfile(v26);
    v69 = CopyProfileFromParams(a3);
    ObjectForKey = IIODictionary::getObjectForKey(a3, CFSTR("kCGImageCopyFileSetIPTC"));
    cf = copyIPTCFromParams(a3);
    v70 = CopyXMPFromIPTCParams(a3);
    CopyOrientationFromParams(a3, &v73);
    v27 = (char *)v76;
    if (CopyDateTimeFromParams(a3, (char *)v76))
    {
      v66 = LOBYTE(v76[0]);
      if (!LOBYTE(v76[0]))
        v27 = 0;
      __ptr = 0;
      if (fread(&__ptr, 1uLL, 4uLL, v24) == 4)
      {
        if (__ptr != 255 || BYTE1(__ptr) != 216 || BYTE2(__ptr) != 255)
        {
          v32 = __ptr == 77 && BYTE1(__ptr) == 77;
          v33 = v32;
          if (v32 && !BYTE2(__ptr) && HIBYTE(__ptr) == 42)
            goto LABEL_90;
          v34 = __ptr == 73 && BYTE1(__ptr) == 73;
          v35 = v34;
          if (v34 && BYTE2(__ptr) == 42 && !HIBYTE(__ptr))
            goto LABEL_90;
          v36 = BYTE2(__ptr) == 82 && v35;
          if (v36 && HIBYTE(__ptr) == 79)
            goto LABEL_90;
          if (BYTE2(__ptr) != 79)
            v33 = 0;
          v37 = HIBYTE(__ptr) == 82 ? v33 : 0;
          v38 = HIBYTE(__ptr) == 83 && v36;
          if ((v37 & 1) != 0
            || v38
            || ((v28 = 0, BYTE2(__ptr) == 85) ? (v39 = v35) : (v39 = 0), v39 && !HIBYTE(__ptr)))
          {
LABEL_90:
            v63 = v27;
            v29 = cf;
            if (!CopyTiffFile(v19, v24, v26, (unsigned __int8 *)&__ptr, (const __CFData *)v69, &v75[1], cf, ObjectForKey, v75, v70, &v74, v73, &v72, v63))
            {
              v40 = v66;
              if ((!cf || v75[1]) && (!v70 || v75[0]) && (!v66 || v72) && v73 && !v74)
              {
                fclose(v26);
                v41 = (UInt8 *)malloc_type_malloc(v19, 0x3BA9C566uLL);
                if (v41)
                {
                  v42 = v41;
                  fseek(v24, 0, 0);
                  if (fread(v42, 1uLL, v19, v24) == v19)
                  {
                    v43 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
                    v44 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v42, v19);
                    if (v44)
                    {
                      v45 = v44;
                      Mutable = CFDictionaryCreateMutable(v43, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                      if (Mutable)
                      {
                        v47 = Mutable;
                        v48 = IIODictionary::getObjectForKey(a3, CFSTR("kCGImageCopyFileSetOrientation"));
                        CFDictionaryAddValue(v47, CFSTR("Orientation"), v48);
                        EXIFJPEGData = (const __CFData *)CGImageCreateEXIFJPEGData(0, v45, 0, v47);
                        if (EXIFJPEGData)
                        {
                          v50 = EXIFJPEGData;
                          v51 = fopen((const char *)v9, "wb");
                          if (v51)
                          {
                            v52 = v51;
                            BytePtr = (__CFDictionary *)CFDataGetBytePtr(v50);
                            Length = CFDataGetLength(v50);
                            fwrite(BytePtr, Length, 1uLL, v52);
                            fclose(v52);
                            v74 = 1;
                            v29 = cf;
                          }
                          CFRelease(v50);
                        }
                        CFRelease(v47);
                      }
                      CFRelease(v45);
                    }
                  }
                  free(v42);
                }
                v26 = 0;
                v40 = v66;
              }
              v31 = v70;
              if (v29 && !v75[1] || v70 && !v75[0] || v73 && !v74)
              {
                v28 = 0;
              }
              else
              {
                if (v40)
                  v54 = !v72;
                else
                  v54 = 0;
                v28 = !v54;
              }
              v30 = v69;
              if (!v69)
                goto LABEL_37;
              goto LABEL_36;
            }
            v28 = 0;
LABEL_35:
            v30 = v69;
            v31 = v70;
            if (!v69)
            {
LABEL_37:
              if (v31)
                CFRelease(v31);
              if (v29)
                CFRelease(v29);
              fclose(v24);
              if (v26)
                fclose(v26);
              goto LABEL_43;
            }
LABEL_36:
            CFRelease(v30);
            goto LABEL_37;
          }
LABEL_34:
          v29 = cf;
          goto LABEL_35;
        }
        LogError("CGImageCopyFileWithParametersOLD", 1571, " ERROR: CGImageCopyFileWithParametersOLD - skipping 'JPEG' case\n");
      }
    }
    v28 = 0;
    goto LABEL_34;
  }
  if (v6 == CFDataGetTypeID())
  {
    v16 = CGImageReadCreateWithData(0, (IIOImageRead *)a1, (__CFData *)1);
  }
  else
  {
    if (v6 != CGDataProviderGetTypeID())
      goto LABEL_131;
    v16 = CGImageReadCreateWithProvider(0, (IIOImageRead *)a1, (CGDataProvider *)1);
  }
  v15 = (const void *)v16;
  if (v16)
    goto LABEL_21;
LABEL_131:
  v28 = 0;
  if (!v9)
    return v28;
LABEL_45:
  if (v28)
  {
    if (a2)
    {
      v28 = 1;
    }
    else
    {
      v55 = CFStringGetMaximumSizeOfFileSystemRepresentation(a1);
      v56 = (std::__fs::filesystem::path *)malloc_type_malloc(v55, 0xA2160716uLL);
      CFStringGetFileSystemRepresentation(a1, (char *)v56, v55);
      rename(v9, v56, v57);
      v28 = v58 == 0;
      if (v58)
      {
        v59 = __error();
        v60 = strerror(*v59);
        v61 = __error();
        LogError("CGImageCopyFileWithParametersOLD", 1701, "*** ImageIO: rename (\"%s\" to \"%s\") failed: '%s' (%d)\n", (const char *)v9, (const char *)v56, v60, *v61);
        unlink((const char *)v9);
      }
      free(v56);
    }
  }
  else
  {
    unlink((const char *)v9);
    v28 = 0;
  }
  free(v9);
  return v28;
}

uint64_t CopyTiffFile(uint64_t a1, __sFILE *a2, __sFILE *a3, unsigned __int8 *a4, const __CFData *a5, BOOL *a6, const __CFData *a7, const __CFDictionary *a8, BOOL *a9, const __CFData *a10, BOOL *a11, unsigned __int16 a12, BOOL *a13, char *a14)
{
  const __CFData *v14;
  const __CFDictionary *v15;
  const __CFData *v16;
  BOOL *v17;
  BOOL *v18;
  const __CFData *v19;
  const __CFData *v20;
  unsigned __int8 *v21;
  const void *v22;
  FILE *v23;
  FILE *v24;
  FILE *v25;
  FILE *v26;
  unint64_t v27;
  int v28;
  signed int v29;
  signed int v30;
  const UInt8 *v31;
  const UInt8 *v32;
  uint64_t v33;
  unsigned int v34;
  unint64_t v35;
  unsigned int v36;
  unsigned int v37;
  size_t v38;
  char *v39;
  char *v40;
  unsigned int *v41;
  int v42;
  int v43;
  int v44;
  int v45;
  __int16 *v46;
  unsigned int v47;
  uint64_t v48;
  unsigned int v49;
  unsigned int v50;
  __int16 v51;
  BOOL v52;
  unsigned int v53;
  unsigned int v54;
  unsigned int v55;
  unsigned int v56;
  unsigned int v57;
  unsigned int v58;
  __int16 v59;
  unsigned int v60;
  BOOL v61;
  unsigned int v65;
  unsigned __int16 v66;
  size_t v67;
  unsigned __int16 *v68;
  unsigned int v69;
  unsigned int v70;
  unsigned __int16 *v71;
  unsigned int v72;
  unsigned int v73;
  unsigned int v74;
  unsigned int v75;
  unsigned int v76;
  unsigned int v77;
  __int16 v78;
  unsigned int v79;
  _BOOL4 v80;
  _BOOL4 v81;
  _BOOL4 v82;
  BOOL v83;
  _BOOL4 v84;
  char *v86;
  char *v87;
  int v88;
  _BOOL4 v89;
  int v90;
  char *v91;
  char *v92;
  char *v93;
  char *v94;
  char *v95;
  unsigned int v96;
  __int16 v97;
  uint64_t v98;
  __int16 *v99;
  __int16 v100;
  FILE *v101;
  __int16 *v102;
  __int16 v103;
  __int16 *v104;
  __int16 v105;
  const __CFDictionary *v106;
  char v107;
  __int16 *v108;
  __int16 v109;
  size_t v110;
  unsigned int v111;
  char *v112;
  char *v113;
  _BOOL4 v114;
  unsigned int v115;
  unsigned int v116;
  BOOL v117;
  __int16 v118;
  int v119;
  unsigned __int16 v120;
  BOOL *v121;
  BOOL v122;
  char v123;
  BOOL v124;
  __int16 v125;
  unsigned int v126;
  unsigned int v127;
  unint64_t v128;
  BOOL *v129;
  BOOL v130;
  __int16 v131;
  int v132;
  unsigned int v133;
  BOOL v134;
  __int16 v135;
  unsigned int v136;
  unint64_t v137;
  unsigned int v138;
  unsigned int v139;
  BOOL v140;
  __int16 v141;
  unsigned int v142;
  unsigned int v143;
  const char *UTF8String;
  int v146;
  unsigned int v147;
  _BOOL4 v148;
  unsigned int v149;
  const char *v151;
  int v152;
  _BOOL4 v153;
  unsigned int v154;
  int v155;
  _BOOL4 v156;
  unsigned int v157;
  unint64_t v158;
  unsigned int v159;
  BOOL v160;
  unsigned int v161;
  unsigned int v162;
  unsigned int v163;
  int v164;
  int v165;
  uint64_t v166;
  size_t v167;
  unsigned int v168;
  __int16 v169;
  unsigned int v170;
  unsigned int v171;
  void *v172;
  unsigned int v173;
  __int16 v174;
  unsigned int v175;
  unsigned int v176;
  const UInt8 *v177;
  unsigned int v178;
  size_t v179;
  size_t v180;
  size_t v181;
  size_t v182;
  size_t v183;
  unsigned int v184;
  uint64_t v185;
  unsigned int v186;
  unsigned int v187;
  unsigned int v188;
  unsigned int v189;
  unsigned int v190;
  int v191;
  unsigned int v192;
  unsigned int v193;
  unsigned int v194;
  int v195;
  unsigned int v196;
  unsigned int v197;
  signed int v198;
  unsigned __int16 *v199;
  unsigned int v200;
  uint64_t v201;
  size_t __size;
  unsigned int v203;
  unsigned int v204;
  BOOL *v205;
  FILE *v206;
  char *v207;
  const UInt8 *v208;
  signed int v209;
  char *v210;
  unsigned __int16 v211;
  BOOL v212;
  signed int v213;
  unsigned int v214;
  const UInt8 *v215;
  const __CFDictionary *v216;
  char *v217;
  const UInt8 *BytePtr;
  int Length;
  unint64_t v220;
  void *value;
  BOOL v222;
  __int128 v223;
  __int128 v224;
  uint64_t v225;
  uint64_t __ptr;
  int v227;
  uint64_t v228;

  MEMORY[0x1E0C80A78](a1, a2);
  v216 = v15;
  v16 = v14;
  v18 = v17;
  v20 = v19;
  v22 = v21;
  v24 = v23;
  v26 = v25;
  v220 = v27;
  v228 = *MEMORY[0x1E0C80C00];
  v28 = *v21;
  v222 = v28 == 77;
  if (v14)
  {
    Length = CFDataGetLength(v14);
    if (a10)
      goto LABEL_3;
LABEL_6:
    v29 = 0;
    if (v20)
      goto LABEL_4;
    goto LABEL_7;
  }
  Length = 0;
  if (!a10)
    goto LABEL_6;
LABEL_3:
  v29 = CFDataGetLength(a10);
  if (v20)
  {
LABEL_4:
    v30 = CFDataGetLength(v20);
    goto LABEL_8;
  }
LABEL_7:
  v30 = 0;
LABEL_8:
  if (Length)
  {
    BytePtr = CFDataGetBytePtr(v16);
    if (v29)
      goto LABEL_10;
LABEL_13:
    v31 = 0;
    if (v30)
      goto LABEL_11;
LABEL_14:
    v32 = 0;
    goto LABEL_15;
  }
  BytePtr = 0;
  if (!v29)
    goto LABEL_13;
LABEL_10:
  v31 = CFDataGetBytePtr(a10);
  if (!v30)
    goto LABEL_14;
LABEL_11:
  v32 = CFDataGetBytePtr(v20);
LABEL_15:
  v225 = 0;
  v223 = 0u;
  v224 = 0u;
  if (fwrite(v22, 1uLL, 4uLL, v24) != 4)
    return 4294967276;
  LODWORD(__ptr) = 0;
  if (fread(&__ptr, 1uLL, 4uLL, v26) != 4)
    goto LABEL_93;
  v215 = v31;
  v33 = 0;
  v34 = bswap32(__ptr);
  if (v28 == 77)
    v35 = v34;
  else
    v35 = __ptr;
  if (v35 < 8 || v35 >= v220)
    return v33;
  v214 = v35;
  if (fseek(v26, v35, 0))
    return 4294967257;
  LOWORD(__ptr) = 0;
  if (fread(&__ptr, 1uLL, 2uLL, v26) != 2)
  {
LABEL_93:
    if ((v26->_flags & 0x20) != 0)
      return 4294967257;
    else
      return 4294967277;
  }
  v36 = bswap32((unsigned __int16)__ptr) >> 16;
  if (v222)
    v37 = v36;
  else
    v37 = (unsigned __int16)__ptr;
  if ((unsigned __int16)(v37 - 512) < 0xFE03u)
    return 0;
  v209 = v29;
  v38 = 12 * (unsigned __int16)v37;
  v39 = (char *)malloc_type_malloc(v38, 0xDE515FAuLL);
  if (!v39)
    return 0;
  v40 = v39;
  if (fread(v39, 1uLL, v38, v26) == v38)
  {
    v213 = v30;
    LODWORD(__ptr) = 0;
    if (fread(&__ptr, 1uLL, 4uLL, v26) == 4)
    {
      v195 = v38;
      v206 = v24;
      v208 = v32;
      v205 = v18;
      v41 = (unsigned int *)v40;
      v42 = 0;
      v43 = 0;
      v44 = 0;
      v45 = 0;
      v46 = 0;
      v47 = 0;
      LODWORD(v48) = 0;
      v210 = (char *)v41;
      v49 = __ptr;
      v50 = bswap32(__ptr);
      if (v222)
        v49 = v50;
      v196 = v49;
      v51 = v37;
      do
      {
        v52 = v20 != 0;
        --v51;
        v53 = *(unsigned __int16 *)v41;
        v54 = bswap32(v53) >> 16;
        if (v222)
          LOWORD(v53) = v54;
        v55 = *((unsigned __int16 *)v41 + 1);
        v56 = bswap32(v55) >> 16;
        if (v222)
          LOWORD(v55) = v56;
        v57 = v41[1];
        v58 = v41[2];
        v59 = bswap32(v57);
        if (v222)
          LOWORD(v57) = v59;
        v60 = bswap32(v58);
        if (v222)
          v58 = v60;
        v45 |= (unsigned __int16)v53 == 274;
        v44 |= (unsigned __int16)v53 == 33723;
        v43 |= (unsigned __int16)v53 == 34675;
        v42 |= (unsigned __int16)v53 == 700;
        if ((unsigned __int16)v53 != 34675)
          v52 = 0;
        if (v30 == 0 && v52)
          v46 = (__int16 *)v41;
        if ((_WORD)v57)
          v61 = (unsigned __int16)v55 == 4;
        else
          v61 = 0;
        if (v61 && (unsigned __int16)v53 == 34665)
          v48 = v58;
        else
          v48 = v48;
        if ((unsigned __int16)v57 == 20 && (unsigned __int16)v55 == 2 && (unsigned __int16)v53 == 306)
          v47 = v58;
        v41 += 3;
      }
      while (v51);
      if ((_DWORD)v48)
      {
        if (fseek(v26, v48, 0))
        {
          v207 = 0;
          v86 = 0;
          v217 = 0;
          v33 = 4294967257;
        }
        else
        {
          LOWORD(__ptr) = 0;
          if (fread(&__ptr, 1uLL, 2uLL, v26) == 2)
          {
            v65 = bswap32((unsigned __int16)__ptr) >> 16;
            if (v222)
              v66 = v65;
            else
              v66 = __ptr;
            if ((unsigned __int16)(v66 - 512) >= 0xFE03u)
            {
              v67 = 12 * v66;
              v68 = (unsigned __int16 *)malloc_type_malloc(v67, 0x86AACC8EuLL);
              if (v68)
              {
                v199 = v68;
                if (fread(v68, 1uLL, v67, v26) != v67)
                {
                  v207 = 0;
                  v86 = 0;
                  v217 = 0;
                  if ((v26->_flags & 0x20) != 0)
                    v33 = 4294967257;
                  else
                    v33 = 4294967277;
                  v40 = v210;
                  v172 = v199;
LABEL_359:
                  free(v172);
LABEL_360:
                  v87 = v207;
                  if (!v40)
                    goto LABEL_101;
                  goto LABEL_100;
                }
                v69 = 0;
                v70 = 0;
                v71 = v199;
                do
                {
                  --v66;
                  v72 = *v71;
                  v73 = bswap32(v72) >> 16;
                  if (v222)
                    LOWORD(v72) = v73;
                  v74 = v71[1];
                  v75 = bswap32(v74) >> 16;
                  if (v222)
                    LOWORD(v74) = v75;
                  v76 = *((_DWORD *)v71 + 1);
                  v77 = *((_DWORD *)v71 + 2);
                  v78 = bswap32(v76);
                  if (v222)
                    LOWORD(v76) = v78;
                  v79 = bswap32(v77);
                  if (v222)
                    v77 = v79;
                  v80 = (unsigned __int16)v72 == 36867;
                  v81 = (unsigned __int16)v76 == 20;
                  v82 = (unsigned __int16)v72 == 36868;
                  v83 = (unsigned __int16)v74 == 2;
                  v84 = (unsigned __int16)v74 == 2 && v80;
                  if (!v83)
                    v82 = 0;
                  if (v84 && v81)
                    v70 = v77;
                  if (v82 && v81)
                    v69 = v77;
                  v71 += 6;
                }
                while (v66);
                v30 = v213;
LABEL_108:
                v186 = v69;
                v187 = v70;
                v88 = v47 | v70 | v69;
                v212 = v88 != 0;
                if (v88)
                  v89 = 0;
                else
                  v89 = a14 != 0;
                v90 = ((a12 != 0) & (v45 ^ 1))
                    - (v46 != 0)
                    + ((BytePtr != 0) & (v44 ^ 1))
                    + ((v208 != 0) & (v43 ^ 1))
                    + ((v215 != 0) & (v42 ^ 1))
                    + v89;
                v203 = v37 + v90;
                __size = 12 * (unsigned __int16)(v37 + v90);
                v191 = v90;
                if (v90 < 1)
                {
                  v193 = v214;
                  v91 = v210;
                }
                else
                {
                  v91 = (char *)reallocf(v210, __size);
                  v193 = v220;
                  v220 += (__size + 6);
                }
                v92 = &v91[12 * (unsigned __int16)v37];
                v93 = v92 + 12;
                v94 = v92 + 24;
                if (v46)
                {
                  *v46 = -1;
                }
                else
                {
                  v95 = v92 + 36;
                  v46 = (__int16 *)&v91[12 * (unsigned __int16)v37];
                  v92 += 12;
                  v93 = v94;
                  v94 = v95;
                }
                *(_QWORD *)&v223 = v46;
                *((_QWORD *)&v223 + 1) = v92;
                *(_QWORD *)&v224 = v93;
                *((_QWORD *)&v224 + 1) = v94;
                if ((a12 == 0) | v45 & 1)
                {
                  v96 = 0;
                }
                else
                {
                  if (v222)
                    v97 = 4609;
                  else
                    v97 = 274;
                  *v46 = v97;
                  v96 = 1;
                }
                if (!((BytePtr == 0) | v44 & 1))
                {
                  v98 = v96++;
                  v99 = *(__int16 **)((unint64_t)&v223 | (8 * v98));
                  if (v222)
                    v100 = -17533;
                  else
                    v100 = -31813;
                  *v99 = v100;
                }
                v101 = v206;
                if (!((v215 == 0) | v42 & 1))
                {
                  v102 = (__int16 *)*((_QWORD *)&v223 + v96++);
                  if (v222)
                    v103 = -17406;
                  else
                    v103 = 700;
                  *v102 = v103;
                }
                v40 = v91;
                if (!((v208 == 0) | v43 & 1))
                {
                  v104 = (__int16 *)*((_QWORD *)&v223 + v96++);
                  if (v222)
                    v105 = 29575;
                  else
                    v105 = -30861;
                  *v104 = v105;
                }
                v106 = v216;
                v107 = v212;
                if (!a14)
                  v107 = 1;
                if ((v107 & 1) == 0)
                {
                  v108 = (__int16 *)*((_QWORD *)&v223 + v96);
                  if (v222)
                    v109 = 12801;
                  else
                    v109 = 306;
                  *v108 = v109;
                }
                if ((unsigned __int16)v37 <= (unsigned __int16)v203)
                  v110 = (unsigned __int16)v203;
                else
                  v110 = (unsigned __int16)v37;
                qsort_r(v91, v110, 0xCuLL, &v222, (int (__cdecl *)(void *, const void *, const void *))sortifd);
                v111 = v203;
                if ((_WORD)v203)
                {
                  v194 = 0;
                  v198 = 0;
                  v189 = 0;
                  v207 = 0;
                  v112 = 0;
                  v217 = 0;
                  v185 = 0;
                  v188 = 0;
                  v192 = 0;
                  v197 = 0;
                  v204 = 0;
                  v184 = bswap32(v30);
                  v190 = bswap32(v209);
                  v201 = (Length + 3) >> 2;
                  v200 = bswap32(v201);
                  v211 = __rev16(a12);
                  v113 = v40 + 8;
                  while (1)
                  {
                    v114 = v222;
                    v115 = *((unsigned __int16 *)v113 - 4);
                    v116 = bswap32(v115) >> 16;
                    if (v222)
                      LOWORD(v115) = v116;
                    if (a12 && (unsigned __int16)v115 == 274)
                    {
                      v117 = !v222;
                      if (v222)
                        v118 = 768;
                      else
                        v118 = 3;
                      *((_WORD *)v113 - 3) = v118;
                      if (v114)
                        v119 = 0x1000000;
                      else
                        v119 = 1;
                      *((_DWORD *)v113 - 1) = v119;
                      v120 = a12;
                      if (!v117)
                        v120 = v211;
                      *(_WORD *)v113 = v120;
                      v121 = a11;
                      if (!a11)
                        goto LABEL_196;
LABEL_195:
                      *v121 = 1;
                      goto LABEL_196;
                    }
                    if (a14)
                      v122 = (unsigned __int16)v115 == 306;
                    else
                      v122 = 0;
                    v123 = v212;
                    if (!v122)
                      v123 = 1;
                    if ((v123 & 1) != 0)
                    {
                      if (!BytePtr || (unsigned __int16)v115 != 33723)
                      {
                        if (v215 && (unsigned __int16)v115 == 700)
                        {
                          v134 = !v222;
                          if (v222)
                            v135 = 256;
                          else
                            v135 = 1;
                          *((_WORD *)v113 - 3) = v135;
                          v136 = v190;
                          if (v134)
                            v136 = v209;
                          *((_DWORD *)v113 - 1) = v136;
                          v137 = v220;
                          v138 = bswap32(v220);
                          if (v134)
                            v138 = v220;
                          *(_DWORD *)v113 = v138;
                          if (a9)
                            *a9 = 1;
                          v197 = v220;
                          v139 = v209;
                          goto LABEL_221;
                        }
                        if (v208 && (unsigned __int16)v115 == 34675)
                        {
                          v140 = !v222;
                          if (v222)
                            v141 = 1792;
                          else
                            v141 = 7;
                          *((_WORD *)v113 - 3) = v141;
                          if (v140)
                            v142 = v30;
                          else
                            v142 = v184;
                          v137 = v220;
                          v143 = bswap32(v220);
                          if (v140)
                            v143 = v220;
                          *((_DWORD *)v113 - 1) = v142;
                          *(_DWORD *)v113 = v143;
                          v139 = v30;
                          v192 = v220;
LABEL_221:
                          v220 = v137 + v139;
                          value = 0;
                        }
                        else
                        {
                          value = 0;
                          if (v106 && (unsigned __int16)v115 == 270)
                          {
                            if (!CFDictionaryGetValueIfPresent(v106, CFSTR("Caption/Abstract"), (const void **)&value))
                              goto LABEL_196;
                            if (v217)
                              free(v217);
                            IIOString::IIOString((IIOString *)&__ptr, value);
                            UTF8String = (const char *)IIOString::createUTF8String((IIOString *)&__ptr);
                            IIOString::~IIOString((IIOString *)&__ptr);
                            if (!UTF8String)
                            {
                              v217 = 0;
                              goto LABEL_196;
                            }
                            v155 = strlen(UTF8String);
                            v147 = v155 + 1;
                            v156 = v222;
                            v157 = bswap32(v155 + 1);
                            if (!v222)
                              v157 = v155 + 1;
                            *((_DWORD *)v113 - 1) = v157;
                            v217 = (char *)UTF8String;
                            v189 = v155 + 1;
                            if (v147 > 4)
                            {
                              v158 = v220;
                              v159 = bswap32(v220);
                              v160 = !v156;
                              LODWORD(v185) = v220;
                              goto LABEL_261;
                            }
                            goto LABEL_236;
                          }
                        }
                        if ((unsigned __int16)v115 != 315 || v106 == 0)
                        {
                          if ((unsigned __int16)v115 != 33432
                            || !v106
                            || !CFDictionaryGetValueIfPresent(v106, CFSTR("CopyrightNotice"), (const void **)&value))
                          {
                            goto LABEL_196;
                          }
                          if (v207)
                            free(v207);
                          IIOString::IIOString((IIOString *)&__ptr, value);
                          UTF8String = (const char *)IIOString::createUTF8String((IIOString *)&__ptr);
                          IIOString::~IIOString((IIOString *)&__ptr);
                          if (!UTF8String)
                          {
                            v207 = 0;
                            goto LABEL_196;
                          }
                          v146 = strlen(UTF8String);
                          v147 = v146 + 1;
                          v148 = v222;
                          v149 = bswap32(v146 + 1);
                          if (!v222)
                            v149 = v146 + 1;
                          *((_DWORD *)v113 - 1) = v149;
                          v207 = (char *)UTF8String;
                          v198 = v146 + 1;
                          if (v147 > 4)
                          {
                            v158 = v220;
                            v159 = bswap32(v220);
                            v160 = !v148;
                            HIDWORD(v185) = v220;
                            goto LABEL_261;
                          }
LABEL_236:
                          strlcpy(v113, UTF8String, 4uLL);
                          goto LABEL_196;
                        }
                        if (CFDictionaryGetValueIfPresent(v106, CFSTR("Byline"), (const void **)&value))
                        {
                          if (v112)
                            free(v112);
                          IIOString::IIOString((IIOString *)&__ptr, value);
                          v151 = (const char *)IIOString::createUTF8String((IIOString *)&__ptr);
                          IIOString::~IIOString((IIOString *)&__ptr);
                          if (v151)
                          {
                            v152 = strlen(v151);
                            v147 = v152 + 1;
                            v153 = v222;
                            v154 = bswap32(v152 + 1);
                            if (!v222)
                              v154 = v152 + 1;
                            *((_DWORD *)v113 - 1) = v154;
                            v194 = v152 + 1;
                            if (v147 > 4)
                            {
                              v112 = (char *)v151;
                              v158 = v220;
                              v159 = bswap32(v220);
                              v160 = !v153;
                              v188 = v220;
LABEL_261:
                              if (v160)
                                v161 = v158;
                              else
                                v161 = v159;
                              *(_DWORD *)v113 = v161;
                              v220 = v158 + v147;
                              goto LABEL_196;
                            }
                            v112 = (char *)v151;
                            strlcpy(v113, v151, 4uLL);
                          }
                          else
                          {
                            v112 = 0;
                          }
                        }
                        goto LABEL_196;
                      }
                      v124 = !v222;
                      if (v222)
                        v125 = 1024;
                      else
                        v125 = 4;
                      *((_WORD *)v113 - 3) = v125;
                      if (v114)
                        v126 = v200;
                      else
                        v126 = (Length + 3) >> 2;
                      v127 = bswap32(v220);
                      if (v124)
                        v127 = v220;
                      *((_DWORD *)v113 - 1) = v126;
                      *(_DWORD *)v113 = v127;
                      v204 = v220;
                      v128 = v220 + v201;
                      v129 = v205;
                    }
                    else
                    {
                      v130 = !v222;
                      if (v222)
                        v131 = 512;
                      else
                        v131 = 2;
                      *((_WORD *)v113 - 3) = v131;
                      if (v114)
                        v132 = 335544320;
                      else
                        v132 = 20;
                      v133 = bswap32(v220);
                      if (v130)
                        v133 = v220;
                      *((_DWORD *)v113 - 1) = v132;
                      *(_DWORD *)v113 = v133;
                      v47 = v220;
                      v128 = v220 + 20;
                      v129 = a13;
                    }
                    v121 = v129;
                    v220 = v128;
                    if (v129)
                      goto LABEL_195;
LABEL_196:
                    --v111;
                    v113 += 12;
                    if (!(_WORD)v111)
                      goto LABEL_266;
                  }
                }
                v204 = 0;
                v197 = 0;
                v192 = 0;
                v185 = 0;
                v188 = 0;
                v217 = 0;
                v112 = 0;
                v207 = 0;
                v189 = 0;
                v198 = 0;
                v194 = 0;
LABEL_266:
                if (fseek(v26, 8, 0))
                  goto LABEL_365;
                v162 = bswap32(v193);
                if (v222)
                  v163 = v162;
                else
                  v163 = v193;
                LODWORD(__ptr) = v163;
                if (fwrite(&__ptr, 1uLL, 4uLL, v101) != 4)
                  goto LABEL_356;
                v164 = v214 - 8;
                if (v214 != 8)
                {
                  bzero(&__ptr, 0x4000uLL);
                  while (1)
                  {
                    v165 = v164 >= 2048 ? 2048 : v164;
                    v166 = v165;
                    if (fread(&__ptr, 1uLL, v165, v26) != v165)
                      break;
                    v167 = fwrite(&__ptr, 1uLL, v165, v101);
                    v30 = v213;
                    if (v167 != v166)
                      goto LABEL_356;
                    v164 -= v166;
                    if (!v164)
                      goto LABEL_279;
                  }
                  if ((v26->_flags & 0x20) != 0)
                    v33 = 4294967257;
                  else
                    v33 = 4294967277;
                  goto LABEL_357;
                }
LABEL_279:
                if (v191 <= 0)
                {
                  if (fseek(v26, (v195 + 6), 1))
                    goto LABEL_365;
                  v173 = bswap32(v203) >> 16;
                  if (v222)
                    v174 = v173;
                  else
                    v174 = v203;
                  LOWORD(__ptr) = v174;
                  if (fwrite(&__ptr, 1uLL, 2uLL, v101) != 2 || fwrite(v40, 1uLL, __size, v101) != __size)
                    goto LABEL_356;
                  v175 = bswap32(v196);
                  v176 = v222 ? v175 : v196;
                  LODWORD(__ptr) = v176;
                  if (fwrite(&__ptr, 1uLL, 4uLL, v101) != 4)
                    goto LABEL_356;
                  if (v191 < 0)
                  {
                    v227 = 0;
                    __ptr = 0;
                    if (fwrite(&__ptr, 1uLL, 0xCuLL, v101) != 12)
                      goto LABEL_356;
                  }
                  v33 = copyRemainder(v26, v101);
                  v86 = v112;
                  if ((_DWORD)v33)
                    goto LABEL_358;
                }
                else
                {
                  v33 = copyRemainder(v26, v101);
                  v86 = v112;
                  if ((_DWORD)v33)
                    goto LABEL_358;
                  v168 = bswap32(v203) >> 16;
                  if (v222)
                    v169 = v168;
                  else
                    v169 = v203;
                  LOWORD(__ptr) = v169;
                  if (fwrite(&__ptr, 1uLL, 2uLL, v101) != 2 || fwrite(v40, 1uLL, __size, v101) != __size)
                    goto LABEL_356;
                  v170 = bswap32(v196);
                  if (v222)
                    v171 = v170;
                  else
                    v171 = v196;
                  LODWORD(__ptr) = v171;
                  v86 = v112;
                  if (fwrite(&__ptr, 1uLL, 4uLL, v101) != 4)
                    goto LABEL_366;
                }
                v177 = v215;
                if (BytePtr)
                {
                  if (fseek(v101, v204, 0))
                    goto LABEL_365;
                  if (fwrite(BytePtr, 1uLL, Length, v101) != Length)
                    goto LABEL_356;
                  BYTE2(__ptr) = 0;
                  LOWORD(__ptr) = 0;
                  if ((-Length & 3) != 0 && fwrite(&__ptr, 1uLL, -Length & 3, v101) != (-Length & 3))
                    goto LABEL_356;
                  if (v205)
                    *v205 = 1;
                  v177 = v215;
                  v86 = v112;
                }
                if (!v177)
                {
LABEL_324:
                  if (v208)
                  {
                    if (fseek(v101, v192, 0))
                      goto LABEL_365;
                    v86 = v112;
                    if (fwrite(v208, 1uLL, v30, v101) != v30)
                      goto LABEL_366;
                  }
                  v178 = v198;
                  if (a14 && (v47 || v187 || v186))
                  {
                    if (v47)
                    {
                      if (fseek(v101, v47, 0))
                        goto LABEL_365;
                      v179 = fwrite(a14, 1uLL, 0x14uLL, v101);
                      v86 = v112;
                      v178 = v198;
                      if (v179 != 20)
                        goto LABEL_366;
                    }
                    if (v187)
                    {
                      if (fseek(v101, v187, 0))
                        goto LABEL_365;
                      v180 = fwrite(a14, 1uLL, 0x14uLL, v101);
                      v86 = v112;
                      v178 = v198;
                      if (v180 != 20)
                        goto LABEL_366;
                    }
                    if (v186)
                    {
                      if (fseek(v101, v186, 0))
                        goto LABEL_365;
                      v181 = fwrite(a14, 1uLL, 0x14uLL, v101);
                      v86 = v112;
                      v178 = v198;
                      if (v181 != 20)
                        goto LABEL_366;
                    }
                    if (a13)
                      *a13 = 1;
                  }
                  if (!v217 || v189 < 5)
                  {
LABEL_346:
                    if (!v86 || v194 < 5)
                      goto LABEL_350;
                    if (fseek(v101, v188, 0))
                    {
                      v33 = 4294967257;
                      goto LABEL_358;
                    }
                    v183 = fwrite(v86, 1uLL, (int)v194, v101);
                    v86 = v112;
                    v178 = v198;
                    if (v183 == v194)
                    {
LABEL_350:
                      v33 = 0;
                      if (v207 && v178 >= 5)
                      {
                        if (!fseek(v101, HIDWORD(v185), 0))
                        {
                          if (fwrite(v207, 1uLL, v198, v101) == v198)
                            v33 = 0;
                          else
                            v33 = 4294967276;
                          goto LABEL_357;
                        }
                        goto LABEL_365;
                      }
LABEL_358:
                      v172 = v199;
                      if (!v199)
                        goto LABEL_360;
                      goto LABEL_359;
                    }
LABEL_366:
                    v33 = 4294967276;
                    goto LABEL_358;
                  }
                  if (!fseek(v101, v185, 0))
                  {
                    v182 = fwrite(v217, 1uLL, (int)v189, v101);
                    v86 = v112;
                    v178 = v198;
                    if (v182 != v189)
                      goto LABEL_366;
                    goto LABEL_346;
                  }
LABEL_365:
                  v33 = 4294967257;
                  goto LABEL_357;
                }
                if (fseek(v101, v197, 0))
                  goto LABEL_365;
                if (fwrite(v177, 1uLL, v209, v101) == v209)
                {
                  v86 = v112;
                  if (a9)
                    *a9 = 1;
                  goto LABEL_324;
                }
LABEL_356:
                v33 = 4294967276;
LABEL_357:
                v86 = v112;
                goto LABEL_358;
              }
            }
            v207 = 0;
            v86 = 0;
            v217 = 0;
            v33 = 0;
          }
          else
          {
            v207 = 0;
            v86 = 0;
            v217 = 0;
            if ((v26->_flags & 0x20) != 0)
              v33 = 4294967257;
            else
              v33 = 4294967277;
          }
        }
        v40 = v210;
        goto LABEL_360;
      }
      v199 = 0;
      v70 = 0;
      v69 = 0;
      goto LABEL_108;
    }
  }
  v217 = 0;
  v86 = 0;
  v87 = 0;
  if ((v26->_flags & 0x20) != 0)
    v33 = 4294967257;
  else
    v33 = 4294967277;
LABEL_100:
  free(v40);
LABEL_101:
  if (v217)
    free(v217);
  if (v86)
    free(v86);
  if (v87)
    free(v87);
  return v33;
}

void sub_187FCC9B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53)
{
  IIOString::~IIOString((IIOString *)&a53);
  _Unwind_Resume(a1);
}

uint64_t sortifd(_BYTE *a1, unsigned __int16 *a2, unsigned __int16 *a3)
{
  unsigned int v3;
  unsigned __int16 v4;
  unsigned int v5;
  unsigned int v6;

  v3 = bswap32(*a2) >> 16;
  if (*a1)
    v4 = v3;
  else
    v4 = *a2;
  v5 = *a3;
  v6 = bswap32(v5) >> 16;
  if (*a1)
    LOWORD(v5) = v6;
  return v4 - (unsigned __int16)v5;
}

uint64_t copyRemainder(__sFILE *a1, __sFILE *a2)
{
  FILE *v2;
  FILE *v3;
  FILE *v4;
  FILE *v5;
  unsigned int v6;
  unsigned int v7;
  size_t v8;
  _BYTE __ptr[4096];
  uint64_t v11;

  MEMORY[0x1E0C80A78](a1, a2);
  v3 = v2;
  v5 = v4;
  v11 = *MEMORY[0x1E0C80C00];
  bzero(__ptr, 0x1000uLL);
  while (1)
  {
    v6 = fread(__ptr, 1uLL, 0x1000uLL, v5);
    v7 = v6;
    v8 = v6;
    if (v6 <= 0xFFFuLL)
      break;
    if (fwrite(__ptr, 1uLL, v6, v3) != v6)
      return 4294967276;
  }
  if (!feof(v5))
    return 4294967277;
  if (fwrite(__ptr, 1uLL, v8, v3) == v7)
    return 0;
  return 4294967276;
}

uint64_t IIO_BytesPerPixelForPixelFormatPlane0(int a1)
{
  uint64_t result;
  int v3;
  int v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  unsigned int v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;

  if (a1 > 1380411456)
  {
    if (a1 > 1932996148)
    {
      if (a1 > 2019963439)
      {
        if (a1 <= 2019963955)
        {
          if (a1 == 2019963440)
            return 2;
          v5 = 2019963442;
        }
        else
        {
          if (a1 == 2019963956 || a1 == 2037741158)
            return 2;
          v5 = 2037741171;
        }
      }
      else
      {
        if (a1 <= 2016686639)
        {
          if (a1 == 1932996149)
            return 2;
          v3 = 1999843442;
          goto LABEL_50;
        }
        if (a1 == 2016686640 || a1 == 2016686642)
          return 2;
        v5 = 2016687156;
      }
    }
    else
    {
      result = 8;
      if (a1 <= 1751410031)
      {
        if (a1 > 1650943795)
        {
          if (a1 != 1650943796)
          {
            if (a1 != 1717855600)
            {
              v3 = 1717856627;
              goto LABEL_50;
            }
            return 4;
          }
          return 2;
        }
        if (a1 == 1380411457)
          return result;
        v3 = 1647534392;
LABEL_50:
        if (a1 == v3)
          return 4;
        goto LABEL_62;
      }
      if (a1 <= 1815162993)
      {
        if (a1 == 1751410032)
          return 2;
        v5 = 1751411059;
      }
      else
      {
        if (a1 == 1815162994)
          return 4;
        if (a1 == 1815491698)
          return result;
        v5 = 1919379252;
      }
    }
    goto LABEL_60;
  }
  if (a1 > 875704949)
  {
    if (a1 <= 1278226735)
    {
      if (a1 <= 875836533)
      {
        if (a1 == 875704950)
          return 1;
        v4 = 875836518;
      }
      else
      {
        if (a1 == 875836534)
          return 1;
        if (a1 == 1111970369)
          return 4;
        v4 = 1278226488;
      }
      goto LABEL_44;
    }
    if (a1 > 1278555700)
    {
      if (a1 == 1278555701 || a1 == 1279340600)
        return 2;
      v3 = 1380401729;
      goto LABEL_50;
    }
    if (a1 == 1278226736)
      return 2;
    v5 = 1278226742;
LABEL_60:
    if (a1 == v5)
      return 2;
    goto LABEL_62;
  }
  if (a1 <= 843264103)
  {
    if (a1 <= 825306676)
    {
      if (a1 == 16)
        return 2;
      if (a1 == 32)
        return 4;
LABEL_62:
      v6 = a1 >> 24;
      v7 = MEMORY[0x1E0C80978];
      if (a1 < 0)
        v8 = __maskrune(a1 >> 24, 0x40000uLL);
      else
        v8 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v6 + 60) & 0x40000;
      if (v8)
        v9 = v6;
      else
        v9 = 46;
      v10 = a1 << 8 >> 24;
      if (a1 << 8 < 0)
        v11 = __maskrune(a1 << 8 >> 24, 0x40000uLL);
      else
        v11 = *(_DWORD *)(v7 + 4 * v10 + 60) & 0x40000;
      if (v11)
        v12 = v10;
      else
        v12 = 46;
      v13 = (__int16)a1 >> 8;
      if (a1 << 16 < 0)
        v14 = __maskrune((__int16)a1 >> 8, 0x40000uLL);
      else
        v14 = *(_DWORD *)(v7 + 4 * v13 + 60) & 0x40000;
      if (v14)
        v15 = v13;
      else
        v15 = 46;
      if ((a1 << 24) <= 0x7F000000)
        v16 = *(_DWORD *)(v7 + 4 * (char)a1 + 60) & 0x40000;
      else
        v16 = __maskrune((char)a1, 0x40000uLL);
      if (v16)
        v17 = (char)a1;
      else
        v17 = 46;
      LogError("IIO_BytesPerPixelForPixelFormatPlane0", 140, "*** IIO_BytesPerPixelForPixelFormatPlane0 - '%c%c%c%c' not handled\n", v9, v12, v15, v17);
      return 1;
    }
    if (a1 == 825306677)
      return 2;
    v5 = 825437747;
    goto LABEL_60;
  }
  if (a1 <= 875704421)
  {
    if (a1 == 843264104)
      return 4;
    v3 = 843264310;
    goto LABEL_50;
  }
  if (a1 == 875704422 || a1 == 875704438)
    return 1;
  v4 = 875704934;
LABEL_44:
  if (a1 != v4)
    goto LABEL_62;
  return 1;
}

uint64_t IIO_FillGeometry420(int a1, unsigned int a2, uint64_t a3, double a4, double a5, double a6, double a7)
{
  double v10;
  unint64_t v12;
  unint64_t v13;
  double v14;
  unsigned int v15;
  double v16;
  unsigned int v17;
  int v18;
  int v19;
  int v20;
  uint64_t result;
  double v22;
  unsigned int v23;
  int v24;

  v10 = a4;
  v12 = (unint64_t)a6;
  v13 = (unint64_t)a7;
  v14 = (double)((unint64_t)a7 + (unint64_t)a5 + ~(((unint64_t)a5 - 1) % (unint64_t)a7));
  *(double *)a3 = (double)((unint64_t)a6
                         + (unint64_t)a4
                         + ~(((unint64_t)a4 - 1) % (unint64_t)a6));
  *(double *)(a3 + 8) = v14;
  v15 = IIO_BytesPerPixelForPixelFormatPlane0(a1);
  v16 = (double)v15;
  v17 = (*(double *)a3 * (double)v15);
  if (v17 % a2)
    v18 = a2 - v17 % a2;
  else
    v18 = 0;
  v19 = v18 + v17;
  *(_DWORD *)(a3 + 16) = v15;
  *(_DWORD *)(a3 + 20) = v19;
  if (v10 <= 0.0 || a5 <= 0.0)
  {
    _cg_jpeg_mem_term("IIO_FillGeometry420", 226, "*** ERROR: bad dimension (%d x %d) for creating a '420f' surface\n");
    return 4294967246;
  }
  if (v19 < 0)
  {
    _cg_jpeg_mem_term("IIO_FillGeometry420", 227, "*** ERROR: IOSurface does not support rowBytes larger than INT32_MAX");
    return 4294967246;
  }
  if (a1 <= 875836517)
  {
    if (a1 <= 875704933)
    {
      if (a1 != 875704422)
      {
        v20 = 875704438;
        goto LABEL_21;
      }
      goto LABEL_22;
    }
    if (a1 == 875704934 || a1 == 875704950)
    {
      v10 = (double)(unint64_t)((v10 + 1.0) * 0.5);
      goto LABEL_18;
    }
LABEL_27:
    _cg_jpeg_mem_term("IIO_FillGeometry420", 246, "*** unhandled pixel format\n");
    return 4294967246;
  }
  if (a1 > 2016686639)
  {
    if (a1 != 2019963440)
    {
      v20 = 2016686640;
LABEL_21:
      if (a1 == v20)
        goto LABEL_22;
      goto LABEL_27;
    }
LABEL_22:
    v10 = (double)(unint64_t)((v10 + 1.0) * 0.5);
    *(double *)(a3 + 24) = v10;
    *(double *)(a3 + 32) = (double)(unint64_t)((a5 + 1.0) * 0.5);
    v14 = (double)((unint64_t)((a5 + 1.0) * 0.5) + v13 + ~(((unint64_t)((a5 + 1.0) * 0.5) - 1) % v13));
    goto LABEL_23;
  }
  if (a1 != 875836518 && a1 != 875836534)
    goto LABEL_27;
LABEL_18:
  *(double *)(a3 + 24) = v10;
  *(double *)(a3 + 32) = a5;
LABEL_23:
  result = 0;
  v22 = (double)((unint64_t)(v10 + v10) + v12 + ~(((unint64_t)(v10 + v10) - 1) % v12));
  *(double *)(a3 + 40) = v22;
  *(double *)(a3 + 48) = v14;
  v23 = (v16 * v22);
  if (v23 % a2)
    v24 = a2 - v23 % a2;
  else
    v24 = 0;
  *(_DWORD *)(a3 + 56) = v24 + v23;
  return result;
}

uint64_t CIF10MIN(void)
{
  return 384;
}

uint64_t CIF10MAX(void)
{
  return 895;
}

uint64_t IIOAlignRowBytes(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2 - 1;
  if (!a2)
    v2 = 15;
  return (v2 + a1) & ~v2;
}

IIODictionary *IIO_CreateIOSurfaceProperties(int a1, int a2, int a3)
{
  IIODictionary *v6;
  const void *v7;
  const void *v8;
  unsigned int v9;
  const void *v10;
  int v11;
  const void *v12;
  IIONumber *v13;
  _BYTE v15[24];
  _BYTE v16[24];
  _BYTE v17[24];
  _BYTE v18[24];
  _BYTE v19[24];
  _BYTE v20[24];
  _BYTE v21[24];
  _BYTE v22[24];
  CFMutableArrayRef v23;
  void *value;
  uint64_t v25;
  _BYTE v26[24];
  _BYTE v27[24];
  _BYTE v28[24];
  _BYTE v29[24];
  _BYTE v30[24];
  _BYTE v31[24];
  _BYTE v32[24];
  _BYTE v33[24];
  _BYTE v34[24];
  _BYTE v35[24];
  CFMutableArrayRef v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  void *v40;
  uint64_t v41;
  _BYTE v42[24];
  _BYTE v43[24];
  _BYTE v44[24];
  _BYTE v45[24];
  _BYTE v46[24];
  _BYTE v47[24];
  _BYTE v48[24];
  _BYTE v49[24];

  v6 = (IIODictionary *)operator new();
  IIODictionary::IIODictionary(v6);
  IIONumber::IIONumber((IIONumber *)v49, a3);
  IIODictionary::setObjectForKey((uint64_t)v6, (uint64_t)v49, (const void *)*MEMORY[0x1E0CBC070]);
  IIONumber::~IIONumber((IIONumber *)v49);
  IIONumber::IIONumber((IIONumber *)v48, 2);
  IIODictionary::setObjectForKey((uint64_t)v6, (uint64_t)v48, (const void *)*MEMORY[0x1E0CBC020]);
  IIONumber::~IIONumber((IIONumber *)v48);
  if (a3 <= 1380401728)
  {
    if (a3 <= 1111970368)
    {
      if (a3 == 875704422 || a3 == 875704438)
      {
        v39 = 0;
        v40 = 0;
        v41 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v39);
        v36 = 0;
        v37 = 0;
        v38 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v36);
        IIONumber::IIONumber((IIONumber *)v35, a1);
        v7 = (const void *)*MEMORY[0x1E0CBC178];
        IIODictionary::setObjectForKey((uint64_t)&v39, (uint64_t)v35, (const void *)*MEMORY[0x1E0CBC178]);
        IIONumber::~IIONumber((IIONumber *)v35);
        IIONumber::IIONumber((IIONumber *)v34, a2);
        v8 = (const void *)*MEMORY[0x1E0CBC140];
        IIODictionary::setObjectForKey((uint64_t)&v39, (uint64_t)v34, (const void *)*MEMORY[0x1E0CBC140]);
        IIONumber::~IIONumber((IIONumber *)v34);
        IIONumber::IIONumber((IIONumber *)v33, 1);
        IIODictionary::setObjectForKey((uint64_t)&v39, (uint64_t)v33, (const void *)*MEMORY[0x1E0CBBF00]);
        v9 = (((a1 + 7) & 0xFFFFFFF8) + 15) & 0xFFFFFFF0;
        IIONumber::~IIONumber((IIONumber *)v33);
        IIONumber::IIONumber((IIONumber *)v32, v9);
        v10 = (const void *)*MEMORY[0x1E0CBC098];
        IIODictionary::setObjectForKey((uint64_t)&v39, (uint64_t)v32, (const void *)*MEMORY[0x1E0CBC098]);
        IIONumber::~IIONumber((IIONumber *)v32);
        v11 = v9 * ((a2 + 7) & 0xFFFFFFF8);
        IIONumber::IIONumber((IIONumber *)v31, v11);
        v12 = (const void *)*MEMORY[0x1E0CBC168];
        IIODictionary::setObjectForKey((uint64_t)&v39, (uint64_t)v31, (const void *)*MEMORY[0x1E0CBC168]);
        IIONumber::~IIONumber((IIONumber *)v31);
        IIONumber::IIONumber((IIONumber *)v30, (a1 + 1) >> 1);
        IIODictionary::setObjectForKey((uint64_t)&v36, (uint64_t)v30, v7);
        IIONumber::~IIONumber((IIONumber *)v30);
        IIONumber::IIONumber((IIONumber *)v29, (a2 + 1) >> 1);
        IIODictionary::setObjectForKey((uint64_t)&v36, (uint64_t)v29, v8);
        IIONumber::~IIONumber((IIONumber *)v29);
        IIONumber::IIONumber((IIONumber *)v28, 2);
        IIODictionary::setObjectForKey((uint64_t)&v36, (uint64_t)v28, (const void *)*MEMORY[0x1E0CBC090]);
        IIONumber::~IIONumber((IIONumber *)v28);
        IIONumber::IIONumber((IIONumber *)v27, v9);
        IIODictionary::setObjectForKey((uint64_t)&v36, (uint64_t)v27, v10);
        IIONumber::~IIONumber((IIONumber *)v27);
        IIONumber::IIONumber((IIONumber *)v26, v11 >> 1);
        IIODictionary::setObjectForKey((uint64_t)&v36, (uint64_t)v26, v12);
        IIONumber::~IIONumber((IIONumber *)v26);
        v23 = 0;
        value = 0;
        v25 = 0;
        IIOArray::IIOArray((IIOArray *)&v23);
        IIOArray::addObject(&v23, v40);
        IIOArray::addObject(&v23, v37);
        IIODictionary::setObjectForKey(v6, value, (const __CFString *)*MEMORY[0x1E0CBC158]);
        IIONumber::IIONumber((IIONumber *)v22, a1);
        IIODictionary::setObjectForKey((uint64_t)v6, (uint64_t)v22, (const void *)*MEMORY[0x1E0CBC1E0]);
        IIONumber::~IIONumber((IIONumber *)v22);
        IIONumber::IIONumber((IIONumber *)v21, a2);
        IIODictionary::setObjectForKey((uint64_t)v6, (uint64_t)v21, (const void *)*MEMORY[0x1E0CBC008]);
        IIONumber::~IIONumber((IIONumber *)v21);
        IIOArray::~IIOArray((IIOArray *)&v23);
        IIODictionary::~IIODictionary((IIODictionary *)&v36);
LABEL_18:
        IIODictionary::~IIODictionary((IIODictionary *)&v39);
        return v6;
      }
      return v6;
    }
    if (a3 != 1111970369)
    {
      if (a3 != 1278226488)
        return v6;
      IIONumber::IIONumber((IIONumber *)v44, a1);
      IIODictionary::setObjectForKey((uint64_t)v6, (uint64_t)v44, (const void *)*MEMORY[0x1E0CBC1E0]);
      IIONumber::~IIONumber((IIONumber *)v44);
      IIONumber::IIONumber((IIONumber *)v43, a2);
      IIODictionary::setObjectForKey((uint64_t)v6, (uint64_t)v43, (const void *)*MEMORY[0x1E0CBC008]);
      IIONumber::~IIONumber((IIONumber *)v43);
      IIONumber::IIONumber((IIONumber *)v42, 1);
      IIODictionary::setObjectForKey((uint64_t)v6, (uint64_t)v42, (const void *)*MEMORY[0x1E0CBBF00]);
      v13 = (IIONumber *)v42;
LABEL_14:
      IIONumber::~IIONumber(v13);
      return v6;
    }
LABEL_13:
    IIONumber::IIONumber((IIONumber *)v47, a1);
    IIODictionary::setObjectForKey((uint64_t)v6, (uint64_t)v47, (const void *)*MEMORY[0x1E0CBC1E0]);
    IIONumber::~IIONumber((IIONumber *)v47);
    IIONumber::IIONumber((IIONumber *)v46, a2);
    IIODictionary::setObjectForKey((uint64_t)v6, (uint64_t)v46, (const void *)*MEMORY[0x1E0CBC008]);
    IIONumber::~IIONumber((IIONumber *)v46);
    IIONumber::IIONumber((IIONumber *)v45, 4);
    IIODictionary::setObjectForKey((uint64_t)v6, (uint64_t)v45, (const void *)*MEMORY[0x1E0CBBF00]);
    v13 = (IIONumber *)v45;
    goto LABEL_14;
  }
  if (a3 <= 2037741157)
  {
    if (a3 != 1380401729 && a3 != 1999843442)
      return v6;
    goto LABEL_13;
  }
  if (a3 == 2037741158 || a3 == 2037741171)
  {
    IIONumber::IIONumber((IIONumber *)v20, a1);
    IIODictionary::setObjectForKey((uint64_t)v6, (uint64_t)v20, (const void *)*MEMORY[0x1E0CBC1E0]);
    IIONumber::~IIONumber((IIONumber *)v20);
    IIONumber::IIONumber((IIONumber *)v19, a2);
    IIODictionary::setObjectForKey((uint64_t)v6, (uint64_t)v19, (const void *)*MEMORY[0x1E0CBC008]);
    IIONumber::~IIONumber((IIONumber *)v19);
    v39 = 0;
    v40 = 0;
    v41 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v39);
    IIONumber::IIONumber((IIONumber *)v18, a1);
    IIODictionary::setObjectForKey((uint64_t)&v39, (uint64_t)v18, (const void *)*MEMORY[0x1E0CBC178]);
    IIONumber::~IIONumber((IIONumber *)v18);
    IIONumber::IIONumber((IIONumber *)v17, a2);
    IIODictionary::setObjectForKey((uint64_t)&v39, (uint64_t)v17, (const void *)*MEMORY[0x1E0CBC140]);
    IIONumber::~IIONumber((IIONumber *)v17);
    IIONumber::IIONumber((IIONumber *)v16, 0);
    IIODictionary::setObjectForKey((uint64_t)&v39, (uint64_t)v16, (const void *)*MEMORY[0x1E0CBC160]);
    IIONumber::~IIONumber((IIONumber *)v16);
    IIONumber::IIONumber((IIONumber *)v15, (2 * a1 + 15) & 0xFFFFFFF0);
    IIODictionary::setObjectForKey((uint64_t)&v39, (uint64_t)v15, (const void *)*MEMORY[0x1E0CBC098]);
    IIONumber::~IIONumber((IIONumber *)v15);
    v36 = 0;
    v37 = 0;
    v38 = 0;
    IIOArray::IIOArray((IIOArray *)&v36);
    IIOArray::addObject(&v36, v40);
    IIODictionary::setObjectForKey(v6, v37, (const __CFString *)*MEMORY[0x1E0CBC158]);
    IIOArray::~IIOArray((IIOArray *)&v36);
    goto LABEL_18;
  }
  return v6;
}

void sub_187FCD8C8(_Unwind_Exception *a1)
{
  IIONumber::~IIONumber((IIONumber *)&STACK[0x200]);
  _Unwind_Resume(a1);
}

__IOSurface *IIO_CreateSurfaceWithFormat(int a1, int a2, int a3, CGColorSpace *a4)
{
  int v8;
  __IOSurface *v9;
  __IOSurface *v10;
  unsigned int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  _BYTE v24[24];
  _BYTE v25[24];
  _BYTE v26[24];
  _BYTE v27[24];
  _BYTE v28[24];
  uint64_t v29;
  CFDictionaryRef v30;
  uint64_t v31;

  if (a1 > 1380401728)
  {
    if (a1 > 1380411456)
    {
      if (a1 == 1815491698 || a1 == 1380411457)
      {
        v8 = 8;
        goto LABEL_18;
      }
    }
    else
    {
      if (a1 == 1380401729)
      {
LABEL_16:
        v8 = 4;
        goto LABEL_18;
      }
      if (a1 == 1380410945)
      {
        v8 = 16;
        goto LABEL_18;
      }
    }
    goto LABEL_23;
  }
  if (a1 <= 1278226487)
  {
    if (a1 != 843264056)
    {
      if (a1 != 1111970369)
        goto LABEL_23;
      goto LABEL_16;
    }
LABEL_12:
    v8 = 2;
    goto LABEL_18;
  }
  if (a1 != 1278226488)
  {
    if (a1 == 1278226742)
      goto LABEL_12;
LABEL_23:
    v12 = a1 >> 24;
    v13 = MEMORY[0x1E0C80978];
    if (a1 < 0)
      v14 = __maskrune(a1 >> 24, 0x40000uLL);
    else
      v14 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v12 + 60) & 0x40000;
    if (v14)
      v15 = v12;
    else
      v15 = 46;
    v16 = a1 << 8 >> 24;
    if (a1 << 8 < 0)
      v17 = __maskrune(a1 << 8 >> 24, 0x40000uLL);
    else
      v17 = *(_DWORD *)(v13 + 4 * v16 + 60) & 0x40000;
    if (v17)
      v18 = v16;
    else
      v18 = 46;
    v19 = (__int16)a1 >> 8;
    if (a1 << 16 < 0)
      v20 = __maskrune((__int16)a1 >> 8, 0x40000uLL);
    else
      v20 = *(_DWORD *)(v13 + 4 * v19 + 60) & 0x40000;
    if (v20)
      v21 = v19;
    else
      v21 = 46;
    if ((a1 << 24) <= 0x7F000000)
      v22 = *(_DWORD *)(v13 + 4 * (char)a1 + 60) & 0x40000;
    else
      v22 = __maskrune((char)a1, 0x40000uLL);
    if (v22)
      v23 = (char)a1;
    else
      v23 = 46;
    LogError("IIO_CreateSurfaceWithFormat", 628, "*** ERROR: Unexpected pixelFormat '%c%c%c%c'\n", v15, v18, v21, v23);
    return 0;
  }
  v8 = 1;
LABEL_18:
  v29 = 0;
  v30 = 0;
  v31 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v29);
  IIONumber::IIONumber((IIONumber *)v28, a2);
  IIODictionary::setObjectForKey((uint64_t)&v29, (uint64_t)v28, (const void *)*MEMORY[0x1E0CBC1E0]);
  IIONumber::~IIONumber((IIONumber *)v28);
  IIONumber::IIONumber((IIONumber *)v27, a3);
  IIODictionary::setObjectForKey((uint64_t)&v29, (uint64_t)v27, (const void *)*MEMORY[0x1E0CBC008]);
  IIONumber::~IIONumber((IIONumber *)v27);
  IIONumber::IIONumber((IIONumber *)v26, a1);
  IIODictionary::setObjectForKey((uint64_t)&v29, (uint64_t)v26, (const void *)*MEMORY[0x1E0CBC070]);
  IIONumber::~IIONumber((IIONumber *)v26);
  IIONumber::IIONumber((IIONumber *)v25, v8);
  IIODictionary::setObjectForKey((uint64_t)&v29, (uint64_t)v25, (const void *)*MEMORY[0x1E0CBBF00]);
  IIONumber::~IIONumber((IIONumber *)v25);
  IIODictionary::setObjectForKey((IIODictionary *)&v29, (const void *)*MEMORY[0x1E0C9AE40], (const __CFString *)*MEMORY[0x1E0CBC068]);
  IIONumber::IIONumber((IIONumber *)v24, (v8 * a2 + 15) & 0xFFFFFFF0);
  IIODictionary::setObjectForKey((uint64_t)&v29, (uint64_t)v24, (const void *)*MEMORY[0x1E0CBBF08]);
  IIONumber::~IIONumber((IIONumber *)v24);
  v9 = IOSurfaceCreate(v30);
  v10 = v9;
  if (a4 && v9)
    IIO_IOSurfaceAddColorSpace(v9, a4);
  IIODictionary::~IIODictionary((IIODictionary *)&v29);
  return v10;
}

void sub_187FCDDDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v5;
  va_list va;

  va_start(va, a5);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)(v5 - 72));
  _Unwind_Resume(a1);
}

void IIO_IOSurfaceAddColorSpace(__IOSurface *a1, CGColorSpaceRef space)
{
  CFDataRef v4;
  CFDataRef v5;
  CFPropertyListRef v6;
  const void *v7;

  if (space)
  {
    v4 = CGColorSpaceCopyICCData(space);
    if (v4)
    {
      v5 = v4;
      IOSurfaceSetValue(a1, (CFStringRef)*MEMORY[0x1E0CBC010], v4);
      CFRelease(v5);
    }
    v6 = CGColorSpaceCopyPropertyList(space);
    if (v6)
    {
      v7 = v6;
      IOSurfaceSetValue(a1, (CFStringRef)*MEMORY[0x1E0CBBF90], v6);
      CFRelease(v7);
    }
    IOSurfaceSetBulkAttachments2();
    IOSurfaceSetValue(a1, (CFStringRef)*MEMORY[0x1E0CBC1E8], (CFTypeRef)*MEMORY[0x1E0CBC1F8]);
  }
}

__IOSurface *IIO_CreateBiPlanarIOSurfaceWithFormat(int a1, CGSize a2, CGSize a3, unsigned int a4, unsigned __int8 *a5, unsigned int a6, uint64_t a7, unsigned int a8, uint64_t a9, uint64_t a10, BOOL a11, task_t a12, int *a13)
{
  double height;
  double width;
  double v19;
  double v20;
  const void *v22;
  const void *v23;
  int v24;
  const void *v25;
  const void *v26;
  uint64_t v27;
  const void *v28;
  double v29;
  uint64_t v30;
  const void *v31;
  uint64_t v32;
  unsigned int v33;
  double v34;
  unsigned int v35;
  size_t v36;
  unsigned __int8 *v37;
  uint64_t v38;
  __IOSurface *v39;
  int v40;
  _BYTE v44[16];
  CFTypeRef value;
  _BYTE v46[24];
  _BYTE v47[24];
  _BYTE v48[24];
  _BYTE v49[24];
  _BYTE v50[24];
  _BYTE v51[24];
  _BYTE v52[24];
  _BYTE v53[24];
  _BYTE v54[24];
  _BYTE v55[24];
  _BYTE v56[24];
  _BYTE v57[24];
  _BYTE v58[24];
  _BYTE v59[24];
  _BYTE v60[24];
  __int128 v61;
  __int128 v62;
  __int128 v63;
  unsigned int v64[4];
  size_t v65;
  CFMutableArrayRef v66;
  const void *v67;
  uint64_t v68;
  uint64_t v69;
  const void *v70;
  uint64_t v71;
  uint64_t v72;
  const void *v73;
  uint64_t v74;
  uint64_t v75;
  CFDictionaryRef v76;
  uint64_t v77;

  height = a3.height;
  width = a3.width;
  v19 = a2.height;
  v20 = a2.width;
  v75 = 0;
  v76 = 0;
  v77 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v75);
  v72 = 0;
  v73 = 0;
  v74 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v72);
  v69 = 0;
  v70 = 0;
  v71 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v69);
  v66 = 0;
  v67 = 0;
  v68 = 0;
  IIOArray::IIOArray((IIOArray *)&v66);
  v65 = 0;
  v63 = 0u;
  *(_OWORD *)v64 = 0u;
  v61 = 0u;
  v62 = 0u;
  if (IIO_FillGeometry420(a1, a4, (uint64_t)&v61, v20, v19, width, height))
    goto LABEL_33;
  IIONumber::IIONumber((IIONumber *)v60, v20);
  IIODictionary::setObjectForKey((uint64_t)&v75, (uint64_t)v60, (const void *)*MEMORY[0x1E0CBC1E0]);
  IIONumber::~IIONumber((IIONumber *)v60);
  IIONumber::IIONumber((IIONumber *)v59, v19);
  IIODictionary::setObjectForKey((uint64_t)&v75, (uint64_t)v59, (const void *)*MEMORY[0x1E0CBC008]);
  IIONumber::~IIONumber((IIONumber *)v59);
  IIONumber::IIONumber((IIONumber *)v58, a1);
  IIODictionary::setObjectForKey((uint64_t)&v75, (uint64_t)v58, (const void *)*MEMORY[0x1E0CBC070]);
  IIONumber::~IIONumber((IIONumber *)v58);
  IIONumber::IIONumber((IIONumber *)v57, v20);
  v22 = (const void *)*MEMORY[0x1E0CBC178];
  IIODictionary::setObjectForKey((uint64_t)&v72, (uint64_t)v57, (const void *)*MEMORY[0x1E0CBC178]);
  IIONumber::~IIONumber((IIONumber *)v57);
  IIONumber::IIONumber((IIONumber *)v56, v19);
  v23 = (const void *)*MEMORY[0x1E0CBC140];
  IIODictionary::setObjectForKey((uint64_t)&v72, (uint64_t)v56, (const void *)*MEMORY[0x1E0CBC140]);
  IIONumber::~IIONumber((IIONumber *)v56);
  v24 = v62;
  IIONumber::IIONumber((IIONumber *)v55, v62);
  v25 = (const void *)*MEMORY[0x1E0CBC090];
  IIODictionary::setObjectForKey((uint64_t)&v72, (uint64_t)v55, (const void *)*MEMORY[0x1E0CBC090]);
  IIONumber::~IIONumber((IIONumber *)v55);
  IIONumber::IIONumber((IIONumber *)v54, a7);
  v26 = (const void *)*MEMORY[0x1E0CBC160];
  IIODictionary::setObjectForKey((uint64_t)&v72, (uint64_t)v54, (const void *)*MEMORY[0x1E0CBC160]);
  IIONumber::~IIONumber((IIONumber *)v54);
  v27 = DWORD1(v62);
  IIONumber::IIONumber((IIONumber *)v53, SDWORD1(v62));
  v28 = (const void *)*MEMORY[0x1E0CBC098];
  IIODictionary::setObjectForKey((uint64_t)&v72, (uint64_t)v53, (const void *)*MEMORY[0x1E0CBC098]);
  IIONumber::~IIONumber((IIONumber *)v53);
  v29 = (double)a8;
  if (!a8)
    v29 = *((double *)&v61 + 1) * (double)v27;
  v30 = v29;
  if ((v30 & 0x80000000) != 0)
  {
    _cg_jpeg_mem_term("IIO_CreateBiPlanarIOSurfaceWithFormat", 702, "*** IOSurface does not support luma planeSize larger than INT32_MAX");
LABEL_33:
    v39 = 0;
LABEL_21:
    if (v39)
      v40 = 0;
    else
      v40 = -50;
    goto LABEL_27;
  }
  IIONumber::IIONumber((IIONumber *)v52, v29);
  v31 = (const void *)*MEMORY[0x1E0CBC168];
  IIODictionary::setObjectForKey((uint64_t)&v72, (uint64_t)v52, (const void *)*MEMORY[0x1E0CBC168]);
  IIONumber::~IIONumber((IIONumber *)v52);
  IIOArray::addObject(&v66, v73);
  IIONumber::IIONumber((IIONumber *)v51, *((double *)&v62 + 1));
  IIODictionary::setObjectForKey((uint64_t)&v69, (uint64_t)v51, v22);
  IIONumber::~IIONumber((IIONumber *)v51);
  IIONumber::IIONumber((IIONumber *)v50, *(double *)&v63);
  IIODictionary::setObjectForKey((uint64_t)&v69, (uint64_t)v50, v23);
  IIONumber::~IIONumber((IIONumber *)v50);
  IIONumber::IIONumber((IIONumber *)v49, 2 * v24);
  IIODictionary::setObjectForKey((uint64_t)&v69, (uint64_t)v49, v25);
  IIONumber::~IIONumber((IIONumber *)v49);
  if (a9)
    v32 = a9;
  else
    v32 = v30;
  IIONumber::IIONumber((IIONumber *)v48, v32);
  IIODictionary::setObjectForKey((uint64_t)&v69, (uint64_t)v48, v26);
  IIONumber::~IIONumber((IIONumber *)v48);
  v33 = v64[2];
  IIONumber::IIONumber((IIONumber *)v47, v64[2]);
  IIODictionary::setObjectForKey((uint64_t)&v69, (uint64_t)v47, v28);
  IIONumber::~IIONumber((IIONumber *)v47);
  v34 = *(double *)v64 * (double)v33;
  v35 = v34;
  if ((v34 & 0x80000000) != 0)
  {
    _cg_jpeg_mem_term("IIO_CreateBiPlanarIOSurfaceWithFormat", 717, "IOSurface does not support chroma planeSize larger than INT32_MAX");
    goto LABEL_33;
  }
  IIONumber::IIONumber((IIONumber *)v46, v34);
  IIODictionary::setObjectForKey((uint64_t)&v69, (uint64_t)v46, v31);
  IIONumber::~IIONumber((IIONumber *)v46);
  v36 = v35 + v30;
  if ((v36 & 0x80000000) != 0)
  {
    _cg_jpeg_mem_term("IIO_CreateBiPlanarIOSurfaceWithFormat", 720, "IOSurface does not support allocSize larger than INT32_MAX");
    goto LABEL_33;
  }
  IIOArray::addObject(&v66, v70);
  IIODictionary::setObjectForKey((IIODictionary *)&v75, v67, (const __CFString *)*MEMORY[0x1E0CBC158]);
  if (a5)
  {
    v37 = 0;
    v38 = a6;
  }
  else
  {
    if (!a11)
    {
      v37 = 0;
      goto LABEL_18;
    }
    v37 = (unsigned __int8 *)_ImageIO_Malloc(v36, 4, &v65, (uint64_t)kImageMalloc_IOSurface_Data, a12, 0, 0);
    v38 = v65;
    a5 = v37;
  }
  if (a5 && v38)
  {
    IIONumber::IIONumber((IIONumber *)v44, v27);
    IIODictionary::setObjectForKey((IIODictionary *)&v75, value, (const __CFString *)*MEMORY[0x1E0CBBF08]);
    IIONumber::~IIONumber((IIONumber *)v44);
    IIONumber::IIONumber((IIONumber *)v44, v38);
    IIODictionary::setObjectForKey((IIODictionary *)&v75, value, (const __CFString *)*MEMORY[0x1E0CBBEE0]);
    IIONumber::~IIONumber((IIONumber *)v44);
    IIONumber::IIONumber((IIONumber *)v44, (uint64_t)a5);
    IIODictionary::setObjectForKey((IIODictionary *)&v75, value, (const __CFString *)*MEMORY[0x1E0CBBF68]);
    IIONumber::~IIONumber((IIONumber *)v44);
  }
LABEL_18:
  v39 = IOSurfaceCreate(v76);
  if (v39)
  {
    if (v37)
    {
      IIONumber::IIONumber((IIONumber *)v44, v65);
      IOSurfaceSetValue(v39, CFSTR("iosurface_plane_datasize"), value);
      IIONumber::~IIONumber((IIONumber *)v44);
      IOSurfaceSetValue(v39, CFSTR("com.apple.ImageIO.ImageIO_Malloced"), (CFTypeRef)*MEMORY[0x1E0C9AE50]);
    }
    goto LABEL_21;
  }
  LogError("IIO_CreateBiPlanarIOSurfaceWithFormat", 763, "*** ERROR: IOSurfaceCreate failed (kIOSurfaceClientAddress)\n");
  if (v37)
    _ImageIO_Free((unint64_t)v37, v65);
  v39 = 0;
  v40 = -50;
LABEL_27:
  if (a13)
    *a13 = v40;
  IIOArray::~IIOArray((IIOArray *)&v66);
  IIODictionary::~IIODictionary((IIODictionary *)&v69);
  IIODictionary::~IIODictionary((IIODictionary *)&v72);
  IIODictionary::~IIODictionary((IIODictionary *)&v75);
  return v39;
}

void sub_187FCE508(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  va_list va;

  va_start(va, a3);
  IIONumber::~IIONumber((IIONumber *)va);
  IIOArray::~IIOArray((IIOArray *)(v3 - 216));
  IIODictionary::~IIODictionary((IIODictionary *)(v3 - 192));
  IIODictionary::~IIODictionary((IIODictionary *)(v3 - 168));
  IIODictionary::~IIODictionary((IIODictionary *)(v3 - 144));
  _Unwind_Resume(a1);
}

__IOSurface *IIO_CreateIOSurfaceWithFormatAndBuffer(unint64_t a1, unint64_t a2, unint64_t a3, int a4, unsigned __int8 *a5, uint64_t a6, _BOOL4 a7, uint64_t a8)
{
  task_t v8;
  _BOOL4 v9;
  unint64_t v12;
  int v15;
  unsigned int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  unint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  unsigned __int8 *v27;
  int v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  int v34;
  unsigned int v35;
  __IOSurface *BiPlanarIOSurfaceWithFormat;
  memory_object_offset_t v37;
  unsigned __int8 *v38;
  int v39;
  int v40;
  __IOSurface *v41;
  uint64_t v42;
  uint64_t v43;
  unsigned int v44;
  int v45;
  unsigned int v46;
  int v47;
  uint64_t v48;
  unsigned int v49;
  uint64_t v50;
  int v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unsigned int v56;
  int v57;
  uint64_t v58;
  unsigned int v59;
  int v60;
  uint64_t v61;
  int v62;
  uint64_t v63;
  uint64_t v65;
  task_t v66;
  unsigned int v67;
  uint64_t v69;
  _BYTE v71[16];
  void *value;
  int v73[2];
  CFDictionaryRef v74;
  uint64_t v75;
  size_t v76[2];
  CGSize v77;
  CGSize v78;

  v8 = a8;
  v9 = a7;
  v12 = a3;
  v76[0] = 0;
  v15 = a3 + 15;
  if (((a3 + 15) & 0xFFFFFFF0) != a3)
  {
    v16 = a4 >> 24;
    v17 = MEMORY[0x1E0C80978];
    if (a4 < 0)
    {
      v19 = MEMORY[0x1E0C80978];
      v18 = __maskrune(a4 >> 24, 0x40000uLL);
      v17 = v19;
    }
    else
    {
      v18 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v16 + 60) & 0x40000;
    }
    v66 = v8;
    if (v18)
      v20 = v16;
    else
      v20 = 46;
    v21 = a4 << 8 >> 24;
    v22 = a1;
    if (a4 << 8 < 0)
    {
      v24 = v17;
      v23 = __maskrune(a4 << 8 >> 24, 0x40000uLL);
      v17 = v24;
    }
    else
    {
      v23 = *(_DWORD *)(v17 + 4 * v21 + 60) & 0x40000;
    }
    if (v23)
      v25 = v21;
    else
      v25 = 46;
    v26 = (__int16)a4 >> 8;
    v27 = a5;
    if (a4 << 16 < 0)
    {
      v29 = v17;
      v28 = __maskrune((__int16)a4 >> 8, 0x40000uLL);
      v17 = v29;
    }
    else
    {
      v28 = *(_DWORD *)(v17 + 4 * v26 + 60) & 0x40000;
    }
    v30 = v15 & 0xFFFFFFF0;
    if (v28)
      v31 = v26;
    else
      v31 = 46;
    if ((a4 << 24) <= 0x7F000000)
      v32 = *(_DWORD *)(v17 + 4 * (char)a4 + 60) & 0x40000;
    else
      v32 = __maskrune((char)a4, 0x40000uLL);
    if (v32)
      v33 = (char)a4;
    else
      v33 = 46;
    _cg_jpeg_mem_term("IIO_CreateIOSurfaceWithFormatAndBuffer", 798, "*** IIO_CreateIOSurfaceWithFormatAndBuffer: '%c%c%c%c':  rowBytes: %d   alignedRowBytes: %d\n", v20, v25, v31, v33, v12, v30);
    a5 = v27;
    a1 = v22;
    v9 = a7;
    v8 = v66;
  }
  if (a4 <= 1380410944)
  {
    if (a4 > 1278226487)
    {
      if (a4 == 1278226488)
      {
        v35 = 1;
        goto LABEL_45;
      }
      v34 = 1380401729;
    }
    else
    {
      if (a4 == 875704422)
        goto LABEL_42;
      v34 = 1111970369;
    }
LABEL_40:
    if (a4 == v34)
    {
      v35 = 4;
      goto LABEL_45;
    }
    goto LABEL_65;
  }
  if (a4 <= 1815162993)
  {
    if (a4 == 1380410945)
    {
      v35 = 16;
      goto LABEL_45;
    }
    if (a4 != 1380411457)
    {
LABEL_65:
      v46 = a4 >> 24;
      if (a4 < 0)
        v47 = __maskrune(a4 >> 24, 0x40000uLL);
      else
        v47 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v46 + 60) & 0x40000;
      if (v47)
        v55 = v46;
      else
        v55 = 46;
      v56 = a4 << 8 >> 24;
      if (a4 << 8 < 0)
        v57 = __maskrune(a4 << 8 >> 24, 0x40000uLL);
      else
        v57 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v56 + 60) & 0x40000;
      if (v57)
        v58 = v56;
      else
        v58 = 46;
      v59 = (__int16)a4 >> 8;
      if (a4 << 16 < 0)
        v60 = __maskrune((__int16)a4 >> 8, 0x40000uLL);
      else
        v60 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v59 + 60) & 0x40000;
      if (v60)
        v61 = v59;
      else
        v61 = 46;
      if ((a4 << 24) <= 0x7F000000)
        v62 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)a4 + 60) & 0x40000;
      else
        v62 = __maskrune((char)a4, 0x40000uLL);
      if (v62)
        v63 = (char)a4;
      else
        v63 = 46;
      _cg_jpeg_mem_term("IIO_CreateIOSurfaceWithFormatAndBuffer", 827, "*** pixelFormat: '%c%c%c%c' not handled\n", v55, v58, v61, v63);
      BiPlanarIOSurfaceWithFormat = 0;
LABEL_109:
      v38 = a5;
      if (a5)
        return BiPlanarIOSurfaceWithFormat;
LABEL_110:
      if (v38 && !BiPlanarIOSurfaceWithFormat)
        _ImageIO_Free((unint64_t)v38, v76[0]);
      return BiPlanarIOSurfaceWithFormat;
    }
    goto LABEL_37;
  }
  if (a4 == 2019963440)
  {
LABEL_42:
    v73[0] = 0;
    v77.width = (double)a1;
    v77.height = (double)a2;
    v78.width = 16.0;
    v78.height = 16.0;
    BiPlanarIOSurfaceWithFormat = IIO_CreateBiPlanarIOSurfaceWithFormat(a4, v77, v78, 0x10u, 0, 0, 0, 0, 0, a8, v9, v8, v73);
    goto LABEL_109;
  }
  if (a4 != 1815491698)
  {
    v34 = 1815162994;
    goto LABEL_40;
  }
LABEL_37:
  v35 = 8;
LABEL_45:
  if (a5 || !v9)
  {
    v76[0] = a6;
    v38 = a5;
  }
  else
  {
    if (!v12)
      v12 = (v35 * a1 + 15) & 0xFFFFFFFFFFFFFFF0;
    if (!is_mul_ok(a2, v12))
      return 0;
    a6 = a2 * v12;
    v37 = _ImageIO_Malloc(a2 * v12, 0, v76, (uint64_t)kImageMalloc_IOSurface_Data, v8, 0, 0);
    if (!v37)
      return 0;
    v38 = (unsigned __int8 *)v37;
  }
  *(_QWORD *)v73 = 0;
  v74 = 0;
  v75 = 0;
  IIODictionary::IIODictionary((IIODictionary *)v73);
  IIONumber::IIONumber((IIONumber *)v71, a1);
  IIODictionary::setObjectForKey((IIODictionary *)v73, value, (const __CFString *)*MEMORY[0x1E0CBC1E0]);
  IIONumber::~IIONumber((IIONumber *)v71);
  IIONumber::IIONumber((IIONumber *)v71, a2);
  IIODictionary::setObjectForKey((IIODictionary *)v73, value, (const __CFString *)*MEMORY[0x1E0CBC008]);
  IIONumber::~IIONumber((IIONumber *)v71);
  IIONumber::IIONumber((IIONumber *)v71, a4);
  IIODictionary::setObjectForKey((IIODictionary *)v73, value, (const __CFString *)*MEMORY[0x1E0CBC070]);
  IIONumber::~IIONumber((IIONumber *)v71);
  IIONumber::IIONumber((IIONumber *)v71, v35);
  IIODictionary::setObjectForKey((IIODictionary *)v73, value, (const __CFString *)*MEMORY[0x1E0CBBF00]);
  IIONumber::~IIONumber((IIONumber *)v71);
  IIONumber::IIONumber((IIONumber *)v71, 2);
  IIODictionary::setObjectForKey((IIODictionary *)v73, value, (const __CFString *)*MEMORY[0x1E0CBC020]);
  IIONumber::~IIONumber((IIONumber *)v71);
  v39 = a5 != 0 || v9;
  v67 = v35;
  if (v39 == 1)
  {
    v76[0] = a6;
    IIONumber::IIONumber((IIONumber *)v71, v12);
    IIODictionary::setObjectForKey((IIODictionary *)v73, value, (const __CFString *)*MEMORY[0x1E0CBBF08]);
    IIONumber::~IIONumber((IIONumber *)v71);
    IIONumber::IIONumber((IIONumber *)v71, a6);
    IIODictionary::setObjectForKey((IIODictionary *)v73, value, (const __CFString *)*MEMORY[0x1E0CBBEE0]);
    IIONumber::~IIONumber((IIONumber *)v71);
    IIONumber::IIONumber((IIONumber *)v71, (uint64_t)v38);
    IIODictionary::setObjectForKey((IIODictionary *)v73, value, (const __CFString *)*MEMORY[0x1E0CBBF68]);
    IIONumber::~IIONumber((IIONumber *)v71);
    IIONumber::IIONumber((IIONumber *)v71, 0);
    IIODictionary::setObjectForKey((IIODictionary *)v73, value, (const __CFString *)*MEMORY[0x1E0CBC160]);
    v40 = a2;
    IIONumber::~IIONumber((IIONumber *)v71);
  }
  else
  {
    v40 = a2;
    a6 = 0;
    LODWORD(v12) = 0;
  }
  v41 = IOSurfaceCreate(v74);
  BiPlanarIOSurfaceWithFormat = v41;
  if (v41)
  {
    if (v39)
      IOSurfaceSetValue(v41, CFSTR("com.apple.ImageIO.ImageIO_Malloced"), (CFTypeRef)*MEMORY[0x1E0C9AE50]);
  }
  else
  {
    LODWORD(v42) = HIBYTE(a4);
    v43 = MEMORY[0x1E0C80978];
    if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * HIBYTE(a4) + 60) & 0x40000) != 0)
      v42 = v42;
    else
      v42 = 46;
    v69 = v42;
    v44 = a4 << 8 >> 24;
    if (a4 << 8 < 0)
      v45 = __maskrune(a4 << 8 >> 24, 0x40000uLL);
    else
      v45 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v44 + 60) & 0x40000;
    if (v45)
      v48 = v44;
    else
      v48 = 46;
    v65 = v48;
    v49 = (__int16)a4 >> 8;
    if (a4 << 16 < 0)
    {
      v51 = __maskrune((__int16)a4 >> 8, 0x40000uLL);
      v50 = v43;
    }
    else
    {
      v50 = v43;
      v51 = *(_DWORD *)(v43 + 4 * v49 + 60) & 0x40000;
    }
    if ((a4 << 24) <= 0x7F000000)
      v52 = *(_DWORD *)(v50 + 4 * (char)a4 + 60) & 0x40000;
    else
      v52 = __maskrune((char)a4, 0x40000uLL);
    if (v51)
      v53 = v49;
    else
      v53 = 46;
    if (v52)
      v54 = (char)a4;
    else
      v54 = 46;
    LogError("IIO_CreateIOSurfaceWithFormatAndBuffer", 887, "*** ERROR: IOSurfaceCreate '%c%c%c%c' failed - clientAddress: %p allocSize: 0x%08lx  size: %d x %d  rb: %d [0x%08x]  bpp: %d\n", v69, v65, v53, v54, v38, a6, a1, v40, v12, v12, v67);
  }
  IIODictionary::~IIODictionary((IIODictionary *)v73);
  if (!a5)
    goto LABEL_110;
  return BiPlanarIOSurfaceWithFormat;
}

void sub_187FCEDE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  uint64_t v17;
  va_list va;

  va_start(va, a17);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)(v17 - 120));
  _Unwind_Resume(a1);
}

__IOSurface *IIO_CreateIOSurfaceWithFormat(unint64_t a1, unint64_t a2, unint64_t a3, int a4, _BOOL4 a5, uint64_t a6)
{
  return IIO_CreateIOSurfaceWithFormatAndBuffer(a1, a2, a3, a4, 0, 0, a5, a6);
}

IOSurfaceRef IIO_CreateOutputSurfaceWithFormat(int a1, int a2, int a3, int a4)
{
  CFDictionaryRef *IOSurfaceProperties;
  IOSurfaceRef v6;
  _BYTE v8[24];

  IOSurfaceProperties = (CFDictionaryRef *)IIO_CreateIOSurfaceProperties(a1, a2, a4);
  IIONumber::IIONumber((IIONumber *)v8, (a3 + 15) & 0xFFFFFFF0);
  IIODictionary::setObjectForKey((uint64_t)IOSurfaceProperties, (uint64_t)v8, (const void *)*MEMORY[0x1E0CBBF08]);
  IIONumber::~IIONumber((IIONumber *)v8);
  v6 = IOSurfaceCreate(IOSurfaceProperties[1]);
  (*((void (**)(CFDictionaryRef *))*IOSurfaceProperties + 1))(IOSurfaceProperties);
  return v6;
}

void sub_187FCEEDC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

__IOSurface *IIO_CreateIOSurfaceWithPixelBufferAttributes(const __CFDictionary *a1)
{
  int Uint32ForKey;
  int v2;
  int v3;
  CFDictionaryRef *IOSurfaceProperties;
  const void *v5;
  unsigned int v6;
  __IOSurface *v7;
  CGColorSpace *ObjectForKey;
  CGColorSpace *v9;
  CFPropertyListRef v10;
  CFStringRef Name;
  const char *v12;
  const __CFDictionary *v13;
  _BYTE v15[24];
  _BYTE v16[24];
  _QWORD v17[3];

  memset(v17, 0, sizeof(v17));
  IIODictionary::IIODictionary((IIODictionary *)v17, a1);
  Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v17, *(const __CFString **)gIIO_kCVPixelBufferWidthKey);
  v2 = IIODictionary::getUint32ForKey((IIODictionary *)v17, *(const __CFString **)gIIO_kCVPixelBufferHeightKey);
  v3 = IIODictionary::getUint32ForKey((IIODictionary *)v17, *(const __CFString **)gIIO_kCVPixelBufferPixelFormatTypeKey);
  IOSurfaceProperties = (CFDictionaryRef *)IIO_CreateIOSurfaceProperties(Uint32ForKey, v2, v3);
  v5 = (const void *)*MEMORY[0x1E0CBBF08];
  v6 = IIODictionary::getUint32ForKey((IIODictionary *)v17, (const __CFString *)*MEMORY[0x1E0CBBF08]);
  if (v6)
  {
    IIONumber::IIONumber((IIONumber *)v16, (v6 + 15) & 0xFFFFFFF0);
    IIODictionary::setObjectForKey((uint64_t)IOSurfaceProperties, (uint64_t)v16, v5);
    IIONumber::~IIONumber((IIONumber *)v16);
  }
  v7 = IOSurfaceCreate(IOSurfaceProperties[1]);
  ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v17, *(const __CFString **)gIIO_kCVImageBufferCGColorSpaceKey);
  v9 = ObjectForKey;
  if (ObjectForKey)
  {
    v10 = CGColorSpaceCopyPropertyList(ObjectForKey);
    if (v10)
    {
      IOSurfaceSetValue(v7, (CFStringRef)*MEMORY[0x1E0CBBF90], v10);
      CFRelease(v10);
    }
    else
    {
      Name = CGColorSpaceGetName(v9);
      IIOString::IIOString((IIOString *)v15, Name);
      v12 = (const char *)IIOString::utf8String((IIOString *)v15);
      _cg_jpeg_mem_term("IIO_CreateIOSurfaceWithPixelBufferAttributes", 972, "Could not serialized color space '%s'\n", v12);
      IIOString::~IIOString((IIOString *)v15);
    }
  }
  v13 = IIODictionary::getObjectForKey((IIODictionary *)v17, *(const __CFString **)gIIO_kCVImageBufferYCbCrMatrixKey);
  if (v13)
    IOSurfaceSetValue(v7, (CFStringRef)*MEMORY[0x1E0CBC1E8], v13);
  (*((void (**)(CFDictionaryRef *))*IOSurfaceProperties + 1))(IOSurfaceProperties);
  IIODictionary::~IIODictionary((IIODictionary *)v17);
  return v7;
}

void sub_187FCF0C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  IIOString::~IIOString((IIOString *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  _Unwind_Resume(a1);
}

__IOSurface *IIO_CreateIOSurfaceFromImage(CGImageRef image, int a2, uint64_t a3)
{
  CGColorSpaceRef v5;
  CGColorSpace *v6;
  CGColorSpace *v7;
  CGImageAlphaInfo AlphaInfo;
  int v9;
  CGBitmapInfo v10;
  IIOImagePixelDataProvider *v11;
  int v12;
  int v13;
  int v14;
  __IOSurface *OutputSurfaceWithFormat;
  __IOSurface *v16;
  __IOSurface *IOSurfaceWithFormatAndBuffer;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  __IOSurface *v21;
  size_t v23;
  size_t v24;
  size_t v25;
  CGDataProvider *v26;
  size_t v27;
  size_t v28;
  char *BaseAddress;
  const __CFData *v30;
  const __CFData *v31;
  const UInt8 *BytePtr;
  size_t Length;
  UInt8 *v34;
  unsigned int v35;
  uint64_t v36;
  int v37;
  size_t Width;
  size_t Height;
  size_t BytesPerRow;
  CGDataProvider *DataProvider;
  size_t v42;
  size_t v43;
  const __CFData *v44;
  uint64_t v45;
  unsigned int v46;
  int v47;
  uint64_t v48;
  unsigned int v49;
  int v50;
  uint64_t v51;
  int v52;
  uint64_t v53;
  size_t v54;
  size_t v55;
  CGColorSpace *ColorSpace;
  size_t v58;
  size_t v59;
  vImage_CGImageFormat v60;

  if (!image)
    return 0;
  if (a2 > 1380410944)
  {
    if (a2 == 1380410945)
    {
      Width = CGImageGetWidth(image);
      Height = CGImageGetHeight(image);
      BytesPerRow = CGImageGetBytesPerRow(image);
      IOSurfaceWithFormatAndBuffer = IIO_CreateIOSurfaceWithFormatAndBuffer(Width, Height, BytesPerRow, 1380410945, 0, 0, 0, a3);
      if (!IOSurfaceWithFormatAndBuffer)
      {
        _cg_jpeg_mem_term("IIO_create_RGfA_IOSurfaceFromImage", 1140, "*** ERROR: failed to create IOSurface from image data provider(%p)\n");
        return IOSurfaceWithFormatAndBuffer;
      }
      DataProvider = CGImageGetDataProvider(image);
      v42 = IOSurfaceGetHeight(IOSurfaceWithFormatAndBuffer);
      v43 = IOSurfaceGetBytesPerRow(IOSurfaceWithFormatAndBuffer);
      if (!IOSurfaceLock(IOSurfaceWithFormatAndBuffer, 0, 0))
      {
        BaseAddress = (char *)IOSurfaceGetBaseAddress(IOSurfaceWithFormatAndBuffer);
        if (CGDataProviderGetSizeOfData() == -1)
        {
          v59 = v42;
          Length = BytesPerRow * Height;
          v34 = (UInt8 *)malloc_type_malloc(BytesPerRow * Height, 0x7830C37AuLL);
          CGDataProviderRewind();
          CGDataProviderGetBytes();
          v31 = 0;
          BytePtr = v34;
        }
        else
        {
          v44 = CGDataProviderCopyData(DataProvider);
          if (!v44)
            goto LABEL_85;
          v31 = v44;
          v59 = v42;
          BytePtr = CFDataGetBytePtr(v44);
          Length = CFDataGetLength(v31);
          v34 = 0;
        }
        if (!BytePtr || !Length)
          goto LABEL_81;
        if (v43 * v59 != BytesPerRow * Height)
        {
          if (BytesPerRow >= v43)
            v55 = v43;
          else
            v55 = BytesPerRow;
          for (; Height; --Height)
          {
            memcpy(BaseAddress, BytePtr, v55);
            BytePtr += BytesPerRow;
            BaseAddress += v43;
          }
          goto LABEL_81;
        }
        goto LABEL_75;
      }
    }
    else
    {
      if (a2 != 1380411457)
        goto LABEL_23;
      v23 = CGImageGetWidth(image);
      v24 = CGImageGetHeight(image);
      v25 = CGImageGetBytesPerRow(image);
      IOSurfaceWithFormatAndBuffer = IIO_CreateIOSurfaceWithFormatAndBuffer(v23, v24, v25, 1380411457, 0, 0, 0, a3);
      if (!IOSurfaceWithFormatAndBuffer)
      {
        _cg_jpeg_mem_term("IIO_create_RGhA_IOSurfaceFromImage", 1055, "*** ERROR: failed to create IOSurface from image data provider(%p)\n");
        return IOSurfaceWithFormatAndBuffer;
      }
      v26 = CGImageGetDataProvider(image);
      v27 = IOSurfaceGetHeight(IOSurfaceWithFormatAndBuffer);
      v28 = IOSurfaceGetBytesPerRow(IOSurfaceWithFormatAndBuffer);
      if (!IOSurfaceLock(IOSurfaceWithFormatAndBuffer, 0, 0))
      {
        BaseAddress = (char *)IOSurfaceGetBaseAddress(IOSurfaceWithFormatAndBuffer);
        if (CGDataProviderGetSizeOfData() == -1)
        {
          v58 = v27;
          Length = v25 * v24;
          v34 = (UInt8 *)malloc_type_malloc(v25 * v24, 0xAE52A0EBuLL);
          CGDataProviderRewind();
          CGDataProviderGetBytes();
          v31 = 0;
          BytePtr = v34;
LABEL_62:
          if (!BytePtr || !Length)
            goto LABEL_81;
          if (v28 * v58 != v25 * v24)
          {
            if (v25 >= v28)
              v54 = v28;
            else
              v54 = v25;
            for (; v24; --v24)
            {
              memcpy(BaseAddress, BytePtr, v54);
              BytePtr += v25;
              BaseAddress += v28;
            }
            goto LABEL_81;
          }
LABEL_75:
          memcpy(BaseAddress, BytePtr, Length);
LABEL_81:
          if (v34)
            free(v34);
          if (v31)
            CFRelease(v31);
          goto LABEL_85;
        }
        v30 = CGDataProviderCopyData(v26);
        if (v30)
        {
          v31 = v30;
          v58 = v27;
          BytePtr = CFDataGetBytePtr(v30);
          Length = CFDataGetLength(v31);
          v34 = 0;
          goto LABEL_62;
        }
LABEL_85:
        IOSurfaceUnlock(IOSurfaceWithFormatAndBuffer, 0, 0);
      }
    }
    ColorSpace = CGImageGetColorSpace(image);
    IIO_IOSurfaceAddColorSpace(IOSurfaceWithFormatAndBuffer, ColorSpace);
    return IOSurfaceWithFormatAndBuffer;
  }
  if (a2 != 1111970369 && a2 != 1380401729)
  {
LABEL_23:
    v35 = a2 >> 24;
    v36 = MEMORY[0x1E0C80978];
    if (a2 < 0)
      v37 = __maskrune(a2 >> 24, 0x40000uLL);
    else
      v37 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v35 + 60) & 0x40000;
    if (v37)
      v45 = v35;
    else
      v45 = 46;
    v46 = a2 << 8 >> 24;
    if (a2 << 8 < 0)
      v47 = __maskrune(a2 << 8 >> 24, 0x40000uLL);
    else
      v47 = *(_DWORD *)(v36 + 4 * v46 + 60) & 0x40000;
    if (v47)
      v48 = v46;
    else
      v48 = 46;
    v49 = (__int16)a2 >> 8;
    if (a2 << 16 < 0)
      v50 = __maskrune((__int16)a2 >> 8, 0x40000uLL);
    else
      v50 = *(_DWORD *)(v36 + 4 * v49 + 60) & 0x40000;
    if (v50)
      v51 = v49;
    else
      v51 = 46;
    if ((a2 << 24) <= 0x7F000000)
      v52 = *(_DWORD *)(v36 + 4 * (char)a2 + 60) & 0x40000;
    else
      v52 = __maskrune((char)a2, 0x40000uLL);
    if (v52)
      v53 = (char)a2;
    else
      v53 = 46;
    _cg_jpeg_mem_term("IIO_CreateIOSurfaceFromImage", 1236, "*** ERROR: unhandled pixelFormat: '%c%c%c%c'\n", v45, v48, v51, v53);
    return 0;
  }
  v5 = CGImageGetColorSpace(image);
  v6 = (CGColorSpace *)CFRetain(v5);
  v7 = v6;
  if (v6 && CGColorSpaceGetModel(v6) != kCGColorSpaceModelRGB)
  {
    CGColorSpaceRelease(v7);
    v7 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
  }
  AlphaInfo = CGImageGetAlphaInfo(image);
  v9 = _AlphaPosition(AlphaInfo);
  *(_QWORD *)&v60.renderingIntent = 0;
  *(_QWORD *)&v60.bitsPerComponent = 0x2000000008;
  v60.colorSpace = v7;
  if (v9)
    v10 = 8195;
  else
    v10 = 8197;
  v60.bitmapInfo = v10;
  *(_OWORD *)&v60.version = 0uLL;
  v11 = (IIOImagePixelDataProvider *)operator new();
  IIOImagePixelDataProvider::IIOImagePixelDataProvider(v11, image, &v60, 0);
  CGColorSpaceRelease(v7);
  v12 = IIOImageSource::count(v11);
  v13 = IIO_Reader::testHeaderSize(v11);
  v14 = IIOImagePlus::sourceImageProvider(v11);
  OutputSurfaceWithFormat = IIO_CreateOutputSurfaceWithFormat(v12, v13, v14, a2);
  if (OutputSurfaceWithFormat)
  {
    v16 = OutputSurfaceWithFormat;
    IOSurfaceWithFormatAndBuffer = 0;
    if (!IOSurfaceLock(OutputSurfaceWithFormat, 0, 0))
    {
      v18 = IIOImagePlus::sourceImageProvider(v11);
      v19 = IIO_Reader::testHeaderSize(v11) * v18;
      v20 = IOSurfaceGetBaseAddress(v16);
      if (IIOImagePixelDataProvider::getBytes((uint64_t (**)(IIOImagePixelDataProvider *, void *))v11, v20) == v19)
      {
        v21 = (__IOSurface *)CFRetain(v16);
        IOSurfaceWithFormatAndBuffer = v21;
        if (v9)
          IIO_IOSurfaceSetAlpha(v21, kCGImageAlphaLast);
      }
      else
      {
        IOSurfaceWithFormatAndBuffer = 0;
      }
      IOSurfaceUnlock(v16, 0, 0);
    }
    IIO_IOSurfaceRelease(v16);
  }
  else
  {
    IOSurfaceWithFormatAndBuffer = 0;
  }
  (*(void (**)(IIOImagePixelDataProvider *))(*(_QWORD *)v11 + 8))(v11);
  return IOSurfaceWithFormatAndBuffer;
}

void sub_187FCF7A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10F1C400B9EDD37);
  _Unwind_Resume(a1);
}

__IOSurface *IIO_CreateIOSurfaceFromBlockSet(uint64_t a1, const __CFDictionary *a2)
{
  uint64_t Property;
  BOOL v4;
  int v5;
  int ComponentType;
  int PixelSize;
  unsigned int v8;
  int v9;
  _BOOL4 BoolForKey;
  double v11;
  double v12;
  double v13;
  double v14;
  unsigned int BytesPerRow;
  __IOSurface *v16;
  void *Data;
  void *BaseAddress;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  uint64_t v25;
  uint8_t permuteMap[4];
  vImage_Buffer dest;
  vImage_Buffer src;
  _QWORD v30[3];
  uint64_t v31;
  CFDictionaryRef v32;
  uint64_t v33;

  v31 = 0;
  v32 = 0;
  v33 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v31);
  memset(v30, 0, sizeof(v30));
  IIODictionary::IIODictionary((IIODictionary *)v30, a2);
  if (CGImageBlockSetGetCount() != 1)
  {
    LogError("IIO_CreateIOSurfaceFromBlockSet", 1265, "   _createIOSurfaceFromBlockSet != 1");
    goto LABEL_38;
  }
  Property = CGImageBlockSetGetProperty();
  if (Property)
    v4 = Property == *MEMORY[0x1E0C9AE50];
  else
    v4 = 1;
  v5 = v4;
  ComponentType = CGImageBlockSetGetComponentType();
  PixelSize = CGImageBlockSetGetPixelSize();
  v8 = 1380411457;
  v9 = PixelSize;
  if (ComponentType == 5)
  {
    BoolForKey = 0;
  }
  else
  {
    if (ComponentType != 2)
    {
      if (ComponentType == 1)
      {
        if (PixelSize == 4)
        {
          BoolForKey = 0;
          v8 = 1111970369;
          goto LABEL_18;
        }
        _cg_jpeg_mem_term("IIO_CreateIOSurfaceFromBlockSet", 1286, "*** ERROR can't handle RGB-888 input (pixelSize=%d) (componentType=%d)\n");
      }
      else
      {
        _cg_jpeg_mem_term("IIO_CreateIOSurfaceFromBlockSet", 1315, "*** ERROR can't handle non-RGBA input (pixelSize=%d) (componentType=%d)\n");
      }
LABEL_38:
      v16 = 0;
      goto LABEL_39;
    }
    BoolForKey = IIODictionary::getBoolForKey((IIODictionary *)v30, CFSTR("kCGImageSourceShouldAllowFloat"));
    if (BoolForKey)
      v8 = 1380411457;
    else
      v8 = 1815491698;
  }
LABEL_18:
  CGImageBlockSetGetImageBlock();
  CGImageBlockGetRect();
  v12 = v11;
  v14 = v13;
  IIONumber::IIONumber((IIONumber *)&src, v8);
  IIODictionary::setObjectForKey((IIODictionary *)&v31, (const void *)src.width, (const __CFString *)*MEMORY[0x1E0CBC070]);
  IIONumber::~IIONumber((IIONumber *)&src);
  IIONumber::IIONumber((IIONumber *)&src, v12);
  IIODictionary::setObjectForKey((IIODictionary *)&v31, (const void *)src.width, (const __CFString *)*MEMORY[0x1E0CBC1E0]);
  IIONumber::~IIONumber((IIONumber *)&src);
  IIONumber::IIONumber((IIONumber *)&src, v14);
  IIODictionary::setObjectForKey((IIODictionary *)&v31, (const void *)src.width, (const __CFString *)*MEMORY[0x1E0CBC008]);
  IIONumber::~IIONumber((IIONumber *)&src);
  BytesPerRow = CGImageBlockGetBytesPerRow();
  IIONumber::IIONumber((IIONumber *)&src, BytesPerRow);
  IIODictionary::setObjectForKey((IIODictionary *)&v31, (const void *)src.width, (const __CFString *)*MEMORY[0x1E0CBBF08]);
  IIONumber::~IIONumber((IIONumber *)&src);
  IIONumber::IIONumber((IIONumber *)&src, v9);
  IIODictionary::setObjectForKey((IIODictionary *)&v31, (const void *)src.width, (const __CFString *)*MEMORY[0x1E0CBBF00]);
  IIONumber::~IIONumber((IIONumber *)&src);
  v16 = IOSurfaceCreate(v32);
  if (!v16)
  {
    LODWORD(v19) = HIBYTE(v8);
    v20 = MEMORY[0x1E0C80978] + 60;
    if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 60 + 4 * HIBYTE(v8)) & 0x40000) != 0)
      v19 = v19;
    else
      v19 = 46;
    LODWORD(v21) = HIWORD(v8) & 0x77;
    v4 = (*(_DWORD *)(v20 + 4 * v21) & 0x40000) == 0;
    LODWORD(v22) = (v8 >> 8) & 0x7E;
    v23 = *(_DWORD *)(v20 + 4 * v22);
    v24 = *(_DWORD *)(v20 + 4 * (v8 & 0x73));
    if (v4)
      v21 = 46;
    else
      v21 = v21;
    if ((v23 & 0x40000) != 0)
      v22 = v22;
    else
      v22 = 46;
    if ((v24 & 0x40000) != 0)
      v25 = v8 & 0x73;
    else
      v25 = 46;
    LogError("IIO_CreateIOSurfaceFromBlockSet", 1392, "*** IOSurfaceCreate failed for '%c%c%c%c' (%d x %d   rb:%d)\n", v19, v21, v22, v25, v12, v14, BytesPerRow);
    goto LABEL_38;
  }
  Data = (void *)CGImageBlockGetData();
  if (!IOSurfaceLock(v16, 0, 0))
  {
    BaseAddress = IOSurfaceGetBaseAddress(v16);
    if (BaseAddress)
    {
      if (BoolForKey)
      {
        src.data = Data;
        src.height = v14;
        src.width = 4 * v12;
        src.rowBytes = BytesPerRow;
        dest.data = BaseAddress;
        dest.height = src.height;
        dest.width = src.width;
        dest.rowBytes = BytesPerRow;
        vImageConvert_16Uto16F(&src, &dest, 0);
      }
      else if (v9 == 4 && !v5)
      {
        *(_DWORD *)permuteMap = 50331906;
        src.data = Data;
        src.height = v14;
        src.width = v12;
        src.rowBytes = BytesPerRow;
        dest.data = BaseAddress;
        dest.height = src.height;
        dest.width = src.width;
        dest.rowBytes = BytesPerRow;
        vImagePermuteChannels_ARGB8888(&src, &dest, permuteMap, 0x10u);
      }
      else
      {
        memcpy(BaseAddress, Data, BytesPerRow * v14);
      }
    }
    IOSurfaceUnlock(v16, 0, 0);
  }
LABEL_39:
  IIODictionary::~IIODictionary((IIODictionary *)v30);
  IIODictionary::~IIODictionary((IIODictionary *)&v31);
  return v16;
}

void sub_187FCFBC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  uint64_t v17;
  va_list va;

  va_start(va, a17);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  IIODictionary::~IIODictionary((IIODictionary *)(v17 - 120));
  _Unwind_Resume(a1);
}

uint64_t IIO_IOSurfaceLogAlphaInfo(__IOSurface *a1, const char *a2)
{
  signed int PixelFormat;
  const __CFDictionary *v5;
  const __CFDictionary *v6;
  const std::string::value_type *v7;
  const __CFString *ObjectForKey;
  const std::string::value_type *v9;
  unsigned int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  unsigned int v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  std::string *v22;
  _QWORD v24[3];
  std::string v25;

  if (a1)
  {
    if ((gIIODebugFlags & 0x40000000000) != 0)
    {
      PixelFormat = IOSurfaceGetPixelFormat(a1);
      v5 = IOSurfaceCopyAllValues(a1);
      if (v5)
      {
        v6 = v5;
        memset(&v25, 0, sizeof(v25));
        memset(v24, 0, sizeof(v24));
        IIODictionary::IIODictionary((IIODictionary *)v24, v5);
        if (!IOSurfaceGetBulkAttachments())
          std::string::append(&v25, "bulk: alphaUnknown  ");
        IIO_LoadHEIFSymbols();
        if (IIODictionary::containsKey((IIODictionary *)v24, *(const __CFString **)gIIO_kCVImageBufferAlphaChannelIsOpaque))
        {
          if (IIODictionary::getBoolForKey((IIODictionary *)v24, *(const __CFString **)gIIO_kCVImageBufferAlphaChannelIsOpaque))
          {
            v7 = "alphaOpaque  ";
          }
          else
          {
            v7 = "alphaNotOpaque  ";
          }
          std::string::append(&v25, v7);
        }
        if (IIODictionary::containsKey((IIODictionary *)v24, *(const __CFString **)gIIO_kCVImageBufferAlphaChannelModeKey))
        {
          ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey((IIODictionary *)v24, *(const __CFString **)gIIO_kCVImageBufferAlphaChannelModeKey);
          if (CFStringCompare(ObjectForKey, *(CFStringRef *)gIIO_kCVImageBufferAlphaChannelMode_PremultipliedAlpha, 0))
          {
            if (CFStringCompare(ObjectForKey, *(CFStringRef *)gIIO_kCVImageBufferAlphaChannelMode_StraightAlpha, 0))
              v9 = "unknown  ";
            else
              v9 = "alphaStraight  ";
          }
          else
          {
            v9 = "alphaPremul  ";
          }
          std::string::append(&v25, v9);
        }
        if ((gIIODebugFlags & 0x40000000000) != 0)
        {
          v10 = PixelFormat >> 24;
          v11 = MEMORY[0x1E0C80978];
          if (PixelFormat < 0)
            v12 = __maskrune(PixelFormat >> 24, 0x40000uLL);
          else
            v12 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v10 + 60) & 0x40000;
          if (v12)
            v13 = v10;
          else
            v13 = 46;
          v14 = PixelFormat << 8 >> 24;
          if (PixelFormat << 8 < 0)
            v15 = __maskrune(PixelFormat << 8 >> 24, 0x40000uLL);
          else
            v15 = *(_DWORD *)(v11 + 4 * v14 + 60) & 0x40000;
          if (v15)
            v16 = v14;
          else
            v16 = 46;
          v17 = (__int16)PixelFormat >> 8;
          if (PixelFormat << 16 < 0)
            v18 = __maskrune((__int16)PixelFormat >> 8, 0x40000uLL);
          else
            v18 = *(_DWORD *)(v11 + 4 * v17 + 60) & 0x40000;
          if ((PixelFormat << 24) <= 0x7F000000)
            v19 = *(_DWORD *)(v11 + 4 * (char)PixelFormat + 60) & 0x40000;
          else
            v19 = __maskrune((char)PixelFormat, 0x40000uLL);
          if (v18)
            v20 = v17;
          else
            v20 = 46;
          if (v19)
            v21 = (char)PixelFormat;
          else
            v21 = 46;
          v22 = &v25;
          if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v22 = (std::string *)v25.__r_.__value_.__r.__words[0];
          ImageIOLog("  %s <IOSurface:  %p> '%c%c%c%c' - %s\n", a2, a1, v13, v16, v20, v21, (const char *)v22);
        }
        CFRelease(v6);
        IIODictionary::~IIODictionary((IIODictionary *)v24);
        if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v25.__r_.__value_.__l.__data_);
      }
    }
  }
  return 0;
}

void sub_187FCFF38(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 - 89) < 0)
    operator delete(*(void **)(v1 - 112));
  _Unwind_Resume(exception_object);
}

uint64_t IIO_IOSurfaceGetAlpha(__IOSurface *a1)
{
  signed int PixelFormat;
  int v3;
  uint64_t v4;
  unsigned int v5;
  int v6;
  const __CFDictionary *v7;
  const __CFDictionary *v8;
  const __CFString *ObjectForKey;
  int v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  const char *v21;
  _QWORD v23[3];

  IIO_LoadJPEGSymbols();
  if (!a1)
  {
    v5 = 0;
    v4 = 0;
    v3 = 0;
    if ((gIIODebugFlags & 0x40000000000) == 0)
      return v4;
    goto LABEL_50;
  }
  PixelFormat = IOSurfaceGetPixelFormat(a1);
  v3 = PixelFormat;
  v4 = 0;
  if (PixelFormat > 1815162993)
  {
    if (PixelFormat <= 2016687155)
    {
      if (PixelFormat <= 1999843441)
      {
        if (PixelFormat != 1815162994)
        {
          v6 = 1983066168;
          goto LABEL_33;
        }
      }
      else if (PixelFormat != 1999843442)
      {
        if (PixelFormat == 2016686640)
          goto LABEL_48;
        v6 = 2016686642;
        goto LABEL_33;
      }
LABEL_39:
      v4 = 5;
      goto LABEL_48;
    }
    if (PixelFormat > 2019963955)
    {
      if (PixelFormat == 2019963956 || PixelFormat == 2037741158)
        goto LABEL_48;
      v6 = 2037741171;
    }
    else
    {
      if (PixelFormat == 2016687156 || PixelFormat == 2019963440)
        goto LABEL_48;
      v6 = 2019963442;
    }
LABEL_33:
    if (PixelFormat == v6)
      goto LABEL_48;
LABEL_34:
    v7 = IOSurfaceCopyAllValues(a1);
    if (!v7)
    {
      v4 = 0;
      goto LABEL_48;
    }
    v8 = v7;
    memset(v23, 0, sizeof(v23));
    IIODictionary::IIODictionary((IIODictionary *)v23, v7);
    v4 = 0;
    if (IOSurfaceGetBulkAttachments())
      goto LABEL_47;
    if (IIODictionary::containsKey((IIODictionary *)v23, *(const __CFString **)gIIO_kCVImageBufferAlphaChannelIsOpaque)&& IIODictionary::getBoolForKey((IIODictionary *)v23, *(const __CFString **)gIIO_kCVImageBufferAlphaChannelIsOpaque))
    {
      IIODictionary::~IIODictionary((IIODictionary *)v23);
      goto LABEL_39;
    }
    if (IIODictionary::containsKey((IIODictionary *)v23, *(const __CFString **)gIIO_kCVImageBufferAlphaChannelModeKey))
    {
      ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey((IIODictionary *)v23, *(const __CFString **)gIIO_kCVImageBufferAlphaChannelModeKey);
      if (CFStringCompare(ObjectForKey, *(CFStringRef *)gIIO_kCVImageBufferAlphaChannelMode_PremultipliedAlpha, 0) == kCFCompareEqualTo)
      {
        LogError("IIO_IOSurfaceGetAlpha", 1912, "*** ERROR: IOSurface kCVImageBufferAlphaChannelMode_PremultipliedAlpha, but keys.premultipliedAlpha = %d\n", 0);
        v4 = 1;
        goto LABEL_47;
      }
      if (CFStringCompare(ObjectForKey, *(CFStringRef *)gIIO_kCVImageBufferAlphaChannelMode_StraightAlpha, 0) == kCFCompareEqualTo)
      {
        LogError("IIO_IOSurfaceGetAlpha", 1918, "*** ERROR: IOSurface kCVImageBufferAlphaChannelMode_StraightAlpha, but keys.premultipliedAlpha = %d\n", 0);
        v4 = 3;
        goto LABEL_47;
      }
    }
    v4 = 0;
LABEL_47:
    CFRelease(v8);
    IIODictionary::~IIODictionary((IIODictionary *)v23);
    goto LABEL_48;
  }
  if (PixelFormat <= 1278226487)
  {
    if (PixelFormat <= 846624120)
    {
      if (PixelFormat == 24)
        goto LABEL_48;
      v6 = 846624102;
    }
    else
    {
      if (PixelFormat == 846624121 || PixelFormat == 875704422)
        goto LABEL_48;
      v6 = 875704438;
    }
    goto LABEL_33;
  }
  if (PixelFormat > 1278226735)
  {
    if (PixelFormat == 1278226736 || PixelFormat == 1278226742)
      goto LABEL_48;
    v6 = 1714630712;
    goto LABEL_33;
  }
  if ((PixelFormat - 1278226488) > 0x30
    || ((1 << (PixelFormat - 56)) & 0x1400000000001) == 0)
  {
    goto LABEL_34;
  }
LABEL_48:
  if ((gIIODebugFlags & 0x40000000000) == 0)
    return v4;
  v5 = v3 >> 24;
  if (v3 < 0)
  {
    v10 = __maskrune(v3 >> 24, 0x40000uLL);
    goto LABEL_52;
  }
LABEL_50:
  v10 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v5 + 60) & 0x40000;
LABEL_52:
  if (v10)
    v11 = v5;
  else
    v11 = 46;
  v12 = v3 << 8 >> 24;
  v13 = MEMORY[0x1E0C80978];
  if (v3 << 8 < 0)
    v14 = __maskrune(v3 << 8 >> 24, 0x40000uLL);
  else
    v14 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v12 + 60) & 0x40000;
  if (v14)
    v15 = v12;
  else
    v15 = 46;
  v16 = (__int16)v3 >> 8;
  if (v3 << 16 < 0)
    v17 = __maskrune((__int16)v3 >> 8, 0x40000uLL);
  else
    v17 = *(_DWORD *)(v13 + 4 * v16 + 60) & 0x40000;
  if (v17)
    v18 = v16;
  else
    v18 = 46;
  if ((v3 << 24) <= 0x7F000000)
    v19 = *(_DWORD *)(v13 + 4 * (char)v3 + 60) & 0x40000;
  else
    v19 = __maskrune((char)v3, 0x40000uLL);
  if (v19)
    v20 = (char)v3;
  else
    v20 = 46;
  v21 = IIO_AlphaInfoString(v4);
  ImageIOLog("  IIO_IOSurfaceGetAlpha <IOSurface:  %p> '%c%c%c%c' -  alpha:%s\n", a1, v11, v15, v18, v20, v21);
  return v4;
}

void sub_187FD0440(_Unwind_Exception *a1)
{
  uint64_t v1;

  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 104));
  _Unwind_Resume(a1);
}

uint64_t IIO_IOSurfaceSetAlpha(__IOSurface *a1, CGImageAlphaInfo a2)
{
  uint64_t *v4;
  CFTypeRef *v5;
  uint64_t *v6;
  const char *v7;
  std::string *p_p;
  std::string __p;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  int v19;

  v19 = 0;
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  v12 = 0u;
  v11 = 116;
  if (IOSurfaceGetBulkAttachments())
  {
    v19 = 0;
    v17 = 0u;
    v18 = 0u;
    v15 = 0u;
    v16 = 0u;
    v13 = 0u;
    v14 = 0u;
    v12 = 0u;
  }
  if (a2 - 1 <= 1)
  {
    BYTE4(v18) = 2;
    v4 = &gIIO_kCVImageBufferAlphaChannelMode_PremultipliedAlpha;
LABEL_7:
    v5 = (CFTypeRef *)*v4;
    v6 = &gIIO_kCVImageBufferAlphaChannelModeKey;
LABEL_8:
    IOSurfaceSetValue(a1, *(CFStringRef *)*v6, *v5);
    goto LABEL_9;
  }
  if (a2 - 3 <= 1)
  {
    BYTE4(v18) = 1;
    v4 = &gIIO_kCVImageBufferAlphaChannelMode_StraightAlpha;
    goto LABEL_7;
  }
  BYTE4(v18) = 0;
  if (a2)
  {
    v6 = &gIIO_kCVImageBufferAlphaChannelIsOpaque;
    v5 = (CFTypeRef *)MEMORY[0x1E0C9AE50];
    goto LABEL_8;
  }
LABEL_9:
  IOSurfaceSetBulkAttachments2();
  memset(&__p, 0, sizeof(__p));
  std::string::basic_string[abi:ne180100]<0>(&__p, "IIO_IOSurfaceSetAlpha ");
  v7 = IIO_AlphaInfoString(a2);
  std::string::append(&__p, v7);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  IIO_IOSurfaceLogAlphaInfo(a1, (const char *)p_p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return 0;
}

void sub_187FD05C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

vImage_Error IIO_IOSurfacePremultiply(__IOSurface *a1)
{
  int Alpha;
  OSType PixelFormat;
  int v4;
  vImage_Error v5;
  vImagePixelCount Width;
  vImagePixelCount Height;
  size_t BytesPerRow;
  vImage_Error v10;
  vImage_Buffer v11;

  Alpha = IIO_IOSurfaceGetAlpha(a1);
  PixelFormat = IOSurfaceGetPixelFormat(a1);
  if (Alpha != 3)
    return -50;
  v4 = PixelFormat;
  if (IOSurfaceLock(a1, 0, 0))
    return -50;
  Width = IOSurfaceGetWidth(a1);
  Height = IOSurfaceGetHeight(a1);
  BytesPerRow = IOSurfaceGetBytesPerRow(a1);
  v11.data = IOSurfaceGetBaseAddress(a1);
  v11.height = Height;
  v11.width = Width;
  v11.rowBytes = BytesPerRow;
  if (v4 <= 1380411456)
  {
    if (v4 == 1111970369 || v4 == 1380401729)
    {
      v10 = vImagePremultiplyData_RGBA8888(&v11, &v11, 0x10u);
      goto LABEL_13;
    }
LABEL_15:
    IOSurfaceUnlock(a1, 0, 0);
    return -50;
  }
  if (v4 == 1380411457)
  {
    v10 = vImagePremultiplyData_RGBA16F(&v11, &v11, 0x10u);
  }
  else
  {
    if (v4 != 1815491698)
      goto LABEL_15;
    v10 = vImagePremultiplyData_RGBA16U(&v11, &v11, 0x10u);
  }
LABEL_13:
  v5 = v10;
  IOSurfaceUnlock(a1, 0, 0);
  if (!v5)
    IIO_IOSurfaceSetAlpha(a1, kCGImageAlphaPremultipliedLast);
  return v5;
}

vImage_Error IIOSurfaceCopyAlphaValuesFromSource(__IOSurface *a1, __IOSurface *a2)
{
  int Alpha;
  vImage_Error v5;
  signed int PixelFormat;
  signed int v7;
  int v8;
  unsigned __int16 v9;
  int v10;
  vImagePixelCount Width;
  vImagePixelCount v12;
  size_t Height;
  size_t BytesPerRow;
  size_t v15;
  unsigned int v16;
  unsigned int v17;
  void *v18;
  void *v19;
  int v20;
  char *v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  _BOOL4 v26;
  _BOOL4 v28;
  size_t v29;
  vImage_Error v30;
  vImagePixelCount v31;
  _WORD *v32;
  __int16 *v33;
  __int16 v34;
  unsigned int v35;
  int v36;
  uint64_t v37;
  unsigned int v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  unsigned int v42;
  int v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  unsigned int v47;
  int v48;
  uint64_t v49;
  unsigned int v50;
  int v51;
  uint64_t v52;
  unsigned int v53;
  int v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  _BOOL4 v59;
  size_t __n;
  size_t __na;
  _BOOL4 v62;
  void *__src;
  void *v64;
  char *BaseAddress;
  size_t v66;
  vImage_Buffer newSrc;
  vImage_Buffer dest;
  vImage_Buffer origSrc;
  vImage_Buffer src;

  Alpha = IIO_IOSurfaceGetAlpha(a1);
  IIO_IOSurfaceGetAlpha(a2);
  v5 = 0;
  if (!Alpha || Alpha == 5)
    return v5;
  PixelFormat = IOSurfaceGetPixelFormat(a1);
  v7 = IOSurfaceGetPixelFormat(a2);
  v8 = v7;
  if (PixelFormat <= 1380411456)
  {
    if (PixelFormat != 1111970369)
    {
      v9 = 16961;
      goto LABEL_8;
    }
LABEL_9:
    if (v7 > 1380411456)
    {
      if (v7 == 1380411457)
        goto LABEL_15;
      v10 = 1815491698;
    }
    else
    {
      if (v7 == 1111970369)
        goto LABEL_15;
      v10 = 1380401729;
    }
    if (v7 == v10)
    {
LABEL_15:
      Width = IOSurfaceGetWidth(a1);
      v12 = IOSurfaceGetWidth(a2);
      Height = IOSurfaceGetHeight(a1);
      IOSurfaceGetHeight(a2);
      BytesPerRow = IOSurfaceGetBytesPerRow(a1);
      v15 = IOSurfaceGetBytesPerRow(a2);
      v16 = IIO_BitsPerComponentForPixelFormat(PixelFormat);
      v17 = IIO_BitsPerComponentForPixelFormat(v8);
      v18 = malloc_type_malloc(BytesPerRow, 0xC37F84DBuLL);
      v64 = malloc_type_malloc(v15, 0xDA5718E2uLL);
      if (IOSurfaceLock(a1, 1u, 0))
      {
        v5 = 0;
LABEL_111:
        free(v18);
        free(v64);
        return v5;
      }
      v66 = Height;
      v5 = 0;
      if (!IOSurfaceLock(a2, 0, 0))
      {
        v19 = v18;
        v20 = v16;
        __n = (unint64_t)v17 >> 3;
        BaseAddress = (char *)IOSurfaceGetBaseAddress(a1);
        v21 = (char *)IOSurfaceGetBaseAddress(a2);
        v22 = (unint64_t)v16 >> 3;
        *(_OWORD *)&src.data = xmmword_18820C490;
        src.width = Width;
        src.rowBytes = BytesPerRow;
        *(_OWORD *)&origSrc.data = xmmword_18820C490;
        origSrc.width = v12;
        origSrc.rowBytes = v15;
        __src = v19;
        dest.data = v19;
        dest.height = 1;
        dest.width = Width;
        dest.rowBytes = v22 * Width;
        newSrc.data = v64;
        newSrc.height = 1;
        newSrc.width = v12;
        newSrc.rowBytes = __n * v12;
        if (v66)
        {
          v23 = v21;
          v24 = 0;
          v5 = 0;
          v26 = v22 == 1 && __n == 2;
          v62 = v26;
          v28 = v22 == 2 && __n == 1;
          v59 = v28;
          if (BytesPerRow >= v15)
            v29 = v15;
          else
            v29 = BytesPerRow;
          __na = v29;
          while (1)
          {
            src.data = &BaseAddress[v24 * BytesPerRow];
            origSrc.data = &v23[v24 * v15];
            if (v20 == 16)
            {
              vImageExtractChannel_ARGB16U(&src, &dest, 3, 0x10u);
            }
            else if (v20 == 8)
            {
              vImageExtractChannel_ARGB8888(&src, &dest, 3, 0x10u);
            }
            else
            {
              _cg_jpeg_mem_term("IIOSurfaceCopyAlphaValuesFromSource", 1712, "*** ERROR: bpcSrc '%d' not handled\n", v20);
            }
            if (v20 == v17)
            {
              memcpy(v64, __src, __na);
            }
            else
            {
              if (v62)
              {
                v30 = vImageConvert_Planar8To16U(&dest, &newSrc, 0x10u);
              }
              else
              {
                if (!v59)
                {
                  _cg_jpeg_mem_term("IIOSurfaceCopyAlphaValuesFromSource", 1730, "*** ERROR: combination of bpcSrc '%d' and bpcDst '%d' not handled\n", v20, v17);
                  goto LABEL_48;
                }
                v30 = vImageConvert_16UToPlanar8(&dest, &newSrc, 0x10u);
              }
              v5 = v30;
            }
LABEL_48:
            if (v17 == 16)
            {
              v31 = Width;
              if (Width)
              {
                v32 = (char *)origSrc.data + 6;
                v33 = (__int16 *)v64;
                do
                {
                  v34 = *v33++;
                  *v32 = v34;
                  v32 += 4;
                  --v31;
                }
                while (v31);
              }
            }
            else if (v17 == 8)
            {
              v5 = vImageOverwriteChannels_ARGB8888(&newSrc, &origSrc, &origSrc, 1u, 0x10u);
            }
            else
            {
              _cg_jpeg_mem_term("IIOSurfaceCopyAlphaValuesFromSource", 1749, "*** ERROR: bpcDst '%d' not handled\n", v17);
            }
            if (++v24 == v66)
              goto LABEL_109;
          }
        }
        v5 = 0;
LABEL_109:
        IOSurfaceUnlock(a2, 0, 0);
        v18 = __src;
      }
      IOSurfaceUnlock(a1, 1u, 0);
      goto LABEL_111;
    }
    v35 = HIBYTE(PixelFormat);
    goto LABEL_61;
  }
  if (PixelFormat == 1815491698)
    goto LABEL_9;
  v9 = 26689;
LABEL_8:
  if (PixelFormat == (v9 | 0x52470000))
    goto LABEL_9;
  v35 = PixelFormat >> 24;
  if ((PixelFormat & 0x80000000) == 0)
  {
LABEL_61:
    v36 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v35 + 60) & 0x40000;
    goto LABEL_62;
  }
  v36 = __maskrune(PixelFormat >> 24, 0x40000uLL);
LABEL_62:
  if (v36)
    v37 = v35;
  else
    v37 = 46;
  v38 = PixelFormat << 8 >> 24;
  v39 = MEMORY[0x1E0C80978];
  if (PixelFormat << 8 < 0)
    v40 = __maskrune(PixelFormat << 8 >> 24, 0x40000uLL);
  else
    v40 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v38 + 60) & 0x40000;
  if (v40)
    v41 = v38;
  else
    v41 = 46;
  v42 = (__int16)PixelFormat >> 8;
  if (PixelFormat << 16 < 0)
    v43 = __maskrune((__int16)PixelFormat >> 8, 0x40000uLL);
  else
    v43 = *(_DWORD *)(v39 + 4 * v42 + 60) & 0x40000;
  if (v43)
    v44 = v42;
  else
    v44 = 46;
  if ((PixelFormat << 24) <= 0x7F000000)
    v45 = *(_DWORD *)(v39 + 4 * (char)PixelFormat + 60) & 0x40000;
  else
    v45 = __maskrune((char)PixelFormat, 0x40000uLL);
  if (v45)
    v46 = (char)PixelFormat;
  else
    v46 = 46;
  v47 = v8 >> 24;
  if (v8 < 0)
    v48 = __maskrune(v8 >> 24, 0x40000uLL);
  else
    v48 = *(_DWORD *)(v39 + 4 * v47 + 60) & 0x40000;
  if (v48)
    v49 = v47;
  else
    v49 = 46;
  v50 = v8 << 8 >> 24;
  if (v8 << 8 < 0)
    v51 = __maskrune(v8 << 8 >> 24, 0x40000uLL);
  else
    v51 = *(_DWORD *)(v39 + 4 * v50 + 60) & 0x40000;
  if (v51)
    v52 = v50;
  else
    v52 = 46;
  v53 = (__int16)v8 >> 8;
  if (v8 << 16 < 0)
    v54 = __maskrune((__int16)v8 >> 8, 0x40000uLL);
  else
    v54 = *(_DWORD *)(v39 + 4 * v53 + 60) & 0x40000;
  if (v54)
    v55 = v53;
  else
    v55 = 46;
  if ((v8 << 24) <= 0x7F000000)
    v56 = *(_DWORD *)(v39 + 4 * (char)v8 + 60) & 0x40000;
  else
    v56 = __maskrune((char)v8, 0x40000uLL);
  if (v56)
    v57 = (char)v8;
  else
    v57 = 46;
  LogError("IIOSurfaceCopyAlphaValuesFromSource", 1764, "*** ERROR: 'IIOSurfaceCopyAlphaValuesFromSource' - cannot copy values from '%c%c%c%c' surface to '%c%c%c%c' surface\n", v37, v41, v44, v46, v49, v52, v55, v57);
  return 4294967246;
}

uint64_t IIO_BitsPerComponentForPixelFormat(int a1)
{
  uint64_t result;
  int v3;
  unsigned int v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;

  result = 16;
  if (a1 > 1647534391)
  {
    if (a1 > 1815491697)
    {
      if (a1 == 1815491698)
        return result;
      v3 = 1999843442;
    }
    else
    {
      if (a1 == 1647534392)
        return 10;
      v3 = 1815162994;
    }
    if (a1 != v3)
      goto LABEL_17;
    return 10;
  }
  if (a1 > 1380401728)
  {
    if (a1 != 1380401729)
    {
      if (a1 == 1380411457)
        return result;
      goto LABEL_17;
    }
    return 8;
  }
  if (a1 == 32 || a1 == 1111970369)
    return 8;
LABEL_17:
  v4 = a1 >> 24;
  v5 = MEMORY[0x1E0C80978];
  if (a1 < 0)
    v6 = __maskrune(a1 >> 24, 0x40000uLL);
  else
    v6 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v4 + 60) & 0x40000;
  if (v6)
    v7 = v4;
  else
    v7 = 46;
  v8 = a1 << 8 >> 24;
  if (a1 << 8 < 0)
    v9 = __maskrune(a1 << 8 >> 24, 0x40000uLL);
  else
    v9 = *(_DWORD *)(v5 + 4 * v8 + 60) & 0x40000;
  if (v9)
    v10 = v8;
  else
    v10 = 46;
  v11 = (__int16)a1 >> 8;
  if (a1 << 16 < 0)
    v12 = __maskrune((__int16)a1 >> 8, 0x40000uLL);
  else
    v12 = *(_DWORD *)(v5 + 4 * v11 + 60) & 0x40000;
  if (v12)
    v13 = v11;
  else
    v13 = 46;
  if ((a1 << 24) <= 0x7F000000)
    v14 = *(_DWORD *)(v5 + 4 * (char)a1 + 60) & 0x40000;
  else
    v14 = __maskrune((char)a1, 0x40000uLL);
  if (v14)
    v15 = (char)a1;
  else
    v15 = 46;
  LogError("IIO_BitsPerComponentForPixelFormat", 71, "*** IIO_BitsPerComponentForPixelFormat - '%c%c%c%c' not handled\n", v7, v10, v13, v15);
  return 0;
}

uint64_t IIO_IOSurfaceCopyColorSpace(__IOSurface *a1)
{
  signed int PixelFormat;
  CFTypeRef v3;
  CGColorSpaceRef v4;
  CFTypeRef v5;
  uint64_t ColorSpaceFromAttachments;
  CFTypeRef v7;
  int v8;
  int v9;
  int v10;
  int v11;
  const char *v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  size_t Width;
  size_t Height;
  const char *v26;
  CFStringRef *v27;
  CGColorSpaceRef v28;
  const void *StringForIntegerCodePoint;
  const void *v30;
  const void *v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  CFDataRef v35;
  CFDataRef v36;
  uint64_t *v37;
  const char *v38;
  unsigned int v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  unsigned int v43;
  int v44;
  uint64_t v45;
  unsigned int v46;
  int v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  size_t v51;
  size_t v52;
  const char *v53;
  CFStringRef *v54;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  int v67;
  _QWORD v68[3];
  UInt8 bytes;
  char v70;
  char v71;
  char v72;
  char v73;
  char v74;
  char v75;
  char v76;
  char v77;
  char v78;
  char v79;
  char v80;
  char v81;
  char v82;
  char v83;
  char v84;
  const void *v85;
  uint64_t v86;

  v86 = *MEMORY[0x1E0C80C00];
  PixelFormat = IOSurfaceGetPixelFormat(a1);
  v3 = IOSurfaceCopyValue(a1, (CFStringRef)*MEMORY[0x1E0CBBF90]);
  IIO_LoadJPEGSymbols();
  if (v3)
  {
    v4 = CGColorSpaceCreateWithPropertyList(v3);
  }
  else
  {
    v5 = IOSurfaceCopyValue(a1, (CFStringRef)*MEMORY[0x1E0CBC010]);
    if (!v5)
      goto LABEL_6;
    v3 = v5;
    v4 = (CGColorSpaceRef)MEMORY[0x18D760CAC]();
  }
  ColorSpaceFromAttachments = (uint64_t)v4;
  CFRelease(v3);
  if (!ColorSpaceFromAttachments)
  {
LABEL_6:
    v7 = IOSurfaceCopyValue(a1, (CFStringRef)*MEMORY[0x1E0CBC048]);
    memset(v68, 0, sizeof(v68));
    IIOString::IIOString((IIOString *)v68, v7);
    if (v7)
      CFRelease(v7);
    v8 = 1;
    if (PixelFormat > 1279340599)
    {
      if ((PixelFormat - 1279340600) <= 0x30
        && ((1 << (PixelFormat - 56)) & 0x1400000000001) != 0
        || PixelFormat == 1279340854)
      {
        goto LABEL_19;
      }
      v9 = 1279342648;
    }
    else
    {
      if ((PixelFormat - 1278226488) <= 0x30
        && ((1 << (PixelFormat - 56)) & 0x1400000000001) != 0
        || PixelFormat == 1278226736)
      {
        goto LABEL_19;
      }
      v9 = 1278226742;
    }
    if (PixelFormat != v9)
      v8 = 0;
LABEL_19:
    v10 = 1;
    if (PixelFormat <= 1380410944)
    {
      if (PixelFormat > 1279340645)
      {
        if (PixelFormat == 1279340646)
          goto LABEL_32;
        v11 = 1279340648;
      }
      else
      {
        if (PixelFormat == 1278226534)
          goto LABEL_32;
        v11 = 1278226536;
      }
    }
    else if (PixelFormat <= 1751527983)
    {
      if (PixelFormat == 1380410945)
        goto LABEL_32;
      v11 = 1380411457;
    }
    else
    {
      if (PixelFormat == 1751527984 || PixelFormat == 1751527986)
        goto LABEL_32;
      v11 = 1751528500;
    }
    if (PixelFormat != v11)
    {
      v10 = 0;
      if (v8)
        goto LABEL_33;
      goto LABEL_65;
    }
LABEL_32:
    if (v8)
    {
LABEL_33:
      if ((gIIODebugFlags & 0x8000300000) != 0)
      {
        v12 = (const char *)IIOString::utf8String((IIOString *)v68);
        v13 = PixelFormat >> 24;
        if (PixelFormat < 0)
          v14 = __maskrune(PixelFormat >> 24, 0x40000uLL);
        else
          v14 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v13 + 60) & 0x40000;
        if (v14)
          v15 = v13;
        else
          v15 = 46;
        v16 = PixelFormat << 8 >> 24;
        if (PixelFormat << 8 < 0)
          v17 = __maskrune(PixelFormat << 8 >> 24, 0x40000uLL);
        else
          v17 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v16 + 60) & 0x40000;
        if (v17)
          v18 = v16;
        else
          v18 = 46;
        v19 = (__int16)PixelFormat >> 8;
        if (PixelFormat << 16 < 0)
          v20 = __maskrune((__int16)PixelFormat >> 8, 0x40000uLL);
        else
          v20 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v19 + 60) & 0x40000;
        if (v20)
          v21 = v19;
        else
          v21 = 46;
        if ((PixelFormat << 24) <= 0x7F000000)
          v22 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)PixelFormat + 60) & 0x40000;
        else
          v22 = __maskrune((char)PixelFormat, 0x40000uLL);
        if (v22)
          v23 = (char)PixelFormat;
        else
          v23 = 46;
        Width = IOSurfaceGetWidth(a1);
        Height = IOSurfaceGetHeight(a1);
        v26 = "GenericGrayGamma2_2";
        if (v10)
          v26 = "ExtendedLinearGray";
        ImageIOLog("*** NOTE: IOSurface '%s' [%c%c%c%c] %ldx%ld has no kIOSurfaceColorSpace/kIOSurfaceICCProfile - using %s\n", v12, v15, v18, v21, v23, Width, Height, v26);
      }
      v27 = (CFStringRef *)MEMORY[0x1E0C9D948];
      if (!v10)
        v27 = (CFStringRef *)MEMORY[0x1E0C9D978];
      v28 = CGColorSpaceCreateWithName(*v27);
LABEL_133:
      ColorSpaceFromAttachments = (uint64_t)v28;
      goto LABEL_134;
    }
LABEL_65:
    v67 = 0;
    v65 = 0u;
    v66 = 0u;
    v63 = 0u;
    v64 = 0u;
    v61 = 0u;
    v62 = 0u;
    v60 = 0u;
    v59 = 116;
    if (IOSurfaceGetBulkAttachments())
    {
LABEL_102:
      if ((gIIODebugFlags & 0x8000300000) != 0)
      {
        v38 = (const char *)IIOString::utf8String((IIOString *)v68);
        v39 = PixelFormat >> 24;
        v40 = MEMORY[0x1E0C80978];
        if (PixelFormat < 0)
          v41 = __maskrune(PixelFormat >> 24, 0x40000uLL);
        else
          v41 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v39 + 60) & 0x40000;
        if (v41)
          v42 = v39;
        else
          v42 = 46;
        v43 = PixelFormat << 8 >> 24;
        if (PixelFormat << 8 < 0)
          v44 = __maskrune(PixelFormat << 8 >> 24, 0x40000uLL);
        else
          v44 = *(_DWORD *)(v40 + 4 * v43 + 60) & 0x40000;
        if (v44)
          v45 = v43;
        else
          v45 = 46;
        v46 = (__int16)PixelFormat >> 8;
        if (PixelFormat << 16 < 0)
          v47 = __maskrune((__int16)PixelFormat >> 8, 0x40000uLL);
        else
          v47 = *(_DWORD *)(v40 + 4 * v46 + 60) & 0x40000;
        if (v47)
          v48 = v46;
        else
          v48 = 46;
        if ((PixelFormat << 24) <= 0x7F000000)
          v49 = *(_DWORD *)(v40 + 4 * (char)PixelFormat + 60) & 0x40000;
        else
          v49 = __maskrune((char)PixelFormat, 0x40000uLL);
        if (v49)
          v50 = (char)PixelFormat;
        else
          v50 = 46;
        v51 = IOSurfaceGetWidth(a1);
        v52 = IOSurfaceGetHeight(a1);
        v53 = "SRGB";
        if (v10)
          v53 = "ExtendedLinearSRGB";
        ImageIOLog("*** NOTE: IOSurface '%s' [%c%c%c%c] %ldx%ld has no kIOSurfaceColorSpace/kIOSurfaceICCProfile - using %s\n", v38, v42, v45, v48, v50, v51, v52, v53);
      }
      v54 = (CFStringRef *)MEMORY[0x1E0C9D958];
      if (!v10)
        v54 = (CFStringRef *)MEMORY[0x1E0C9DA10];
      v28 = CGColorSpaceCreateWithName(*v54);
      goto LABEL_133;
    }
    v56 = 0;
    v57 = 0;
    v58 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v56);
    if (DWORD1(v63))
    {
      IIONumber::IIONumber((IIONumber *)&bytes, (double)(int)v63 / (double)SDWORD1(v63));
      IIODictionary::setObjectForKey((IIODictionary *)&v56, v85, *(const __CFString **)gIIO_kCVImageBufferGammaLevelKey);
      IIONumber::~IIONumber((IIONumber *)&bytes);
    }
    StringForIntegerCodePoint = (const void *)gFunc_CVYCbCrMatrixGetStringForIntegerCodePoint(BYTE10(v63));
    if (StringForIntegerCodePoint)
      IIODictionary::setObjectForKey((IIODictionary *)&v56, StringForIntegerCodePoint, *(const __CFString **)gIIO_kCVImageBufferYCbCrMatrixKey);
    v30 = (const void *)gFunc_CVColorPrimariesGetStringForIntegerCodePoint(BYTE11(v63));
    if (v30)
      IIODictionary::setObjectForKey((IIODictionary *)&v56, v30, *(const __CFString **)gIIO_kCVImageBufferColorPrimariesKey);
    v31 = (const void *)gFunc_CVTransferFunctionGetStringForIntegerCodePoint(BYTE12(v63));
    if (v31)
    {
      IIODictionary::setObjectForKey((IIODictionary *)&v56, v31, *(const __CFString **)gIIO_kCVImageBufferTransferFunctionKey);
    }
    else if (BYTE12(v63) == 2 && DWORD1(v63))
    {
      IIODictionary::setObjectForKey((IIODictionary *)&v56, *(const void **)gIIO_kCVImageBufferTransferFunction_UseGamma, *(const __CFString **)gIIO_kCVImageBufferTransferFunctionKey);
    }
    v32 = BYTE13(v63) - 1;
    if (v32 <= 6)
      IIODictionary::setObjectForKey((IIODictionary *)&v56, *(const void **)*off_1E1BC4BE8[(char)v32], *(const __CFString **)gIIO_kCVImageBufferChromaLocationTopFieldKey);
    v33 = BYTE14(v63) - 1;
    if (v33 <= 6)
      IIODictionary::setObjectForKey((IIODictionary *)&v56, *(const void **)*off_1E1BC4BE8[(char)v33], *(const __CFString **)gIIO_kCVImageBufferChromaLocationBottomFieldKey);
    v34 = HIBYTE(v63) - 1;
    if (v34 <= 2)
      IIODictionary::setObjectForKey((IIODictionary *)&v56, *(const void **)*off_1E1BC4C20[(char)v34], *(const __CFString **)gIIO_kCVImageBufferChromaSubsamplingKey);
    if ((_WORD)v64
      && WORD1(v64)
      && WORD2(v64)
      && WORD3(v64)
      && WORD4(v64)
      && WORD5(v64)
      && WORD6(v64)
      && HIWORD(v64)
      && (_DWORD)v65)
    {
      bytes = BYTE1(v64);
      v70 = v64;
      v71 = BYTE3(v64);
      v72 = BYTE2(v64);
      v73 = BYTE5(v64);
      v74 = BYTE4(v64);
      v75 = BYTE7(v64);
      v76 = BYTE6(v64);
      v77 = BYTE9(v64);
      v78 = BYTE8(v64);
      v79 = BYTE11(v64);
      v80 = BYTE10(v64);
      v81 = BYTE13(v64);
      v82 = BYTE12(v64);
      v83 = HIBYTE(v64);
      v84 = BYTE14(v64);
      LOBYTE(v85) = BYTE3(v65);
      BYTE1(v85) = BYTE2(v65);
      BYTE2(v85) = BYTE1(v65);
      BYTE3(v85) = v65;
      HIDWORD(v85) = bswap32(DWORD1(v65));
      v35 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], &bytes, 24);
      IIODictionary::setObjectForKey((IIODictionary *)&v56, v35, *(const __CFString **)gIIO_kCVImageBufferMasteringDisplayColorVolumeKey);
      CFRelease(v35);
    }
    if (WORD4(v65) && WORD5(v65))
    {
      bytes = BYTE9(v65);
      v70 = BYTE8(v65);
      v71 = BYTE11(v65);
      v72 = BYTE10(v65);
      v36 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], &bytes, 4);
      IIODictionary::setObjectForKey((IIODictionary *)&v56, v36, *(const __CFString **)gIIO_kCVImageBufferContentLightLevelInfoKey);
      CFRelease(v36);
    }
    if (BYTE4(v66) == 1)
    {
      v37 = &gIIO_kCVImageBufferAlphaChannelMode_StraightAlpha;
    }
    else
    {
      if (BYTE4(v66) != 2)
        goto LABEL_101;
      v37 = &gIIO_kCVImageBufferAlphaChannelMode_PremultipliedAlpha;
    }
    IIODictionary::setObjectForKey((IIODictionary *)&v56, *(const void **)gIIO_kCVImageBufferAlphaChannelModeKey, *(const __CFString **)*v37);
LABEL_101:
    ColorSpaceFromAttachments = gFunc_CVImageBufferCreateColorSpaceFromAttachments(v57);
    IIODictionary::~IIODictionary((IIODictionary *)&v56);
    if (ColorSpaceFromAttachments)
    {
LABEL_134:
      IIOString::~IIOString((IIOString *)v68);
      return ColorSpaceFromAttachments;
    }
    goto LABEL_102;
  }
  return ColorSpaceFromAttachments;
}

void sub_187FD18D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  va_list va;

  va_start(va, a9);
  IIONumber::~IIONumber((IIONumber *)(v9 - 112));
  IIODictionary::~IIODictionary((IIODictionary *)va);
  IIOString::~IIOString((IIOString *)(v9 - 136));
  _Unwind_Resume(a1);
}

uint64_t IIO_CreateIOSurfaceContext(__IOSurface *a1, CGColorSpace *a2)
{
  signed int PixelFormat;
  signed int v4;
  unsigned int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  unsigned int v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;

  PixelFormat = IOSurfaceGetPixelFormat(a1);
  if (PixelFormat == 1111970369 || (v4 = PixelFormat, PixelFormat == 1815491698) || PixelFormat == 1380411457)
  {
    IOSurfaceGetWidth(a1);
    IOSurfaceGetHeight(a1);
    return CGIOSurfaceContextCreate();
  }
  else
  {
    v6 = PixelFormat >> 24;
    v7 = MEMORY[0x1E0C80978];
    if (PixelFormat < 0)
      v8 = __maskrune(PixelFormat >> 24, 0x40000uLL);
    else
      v8 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v6 + 60) & 0x40000;
    if (v8)
      v9 = v6;
    else
      v9 = 46;
    v10 = v4 << 8 >> 24;
    if (v4 << 8 < 0)
      v11 = __maskrune(v4 << 8 >> 24, 0x40000uLL);
    else
      v11 = *(_DWORD *)(v7 + 4 * v10 + 60) & 0x40000;
    if (v11)
      v12 = v10;
    else
      v12 = 46;
    v13 = (__int16)v4 >> 8;
    if (v4 << 16 < 0)
      v14 = __maskrune((__int16)v4 >> 8, 0x40000uLL);
    else
      v14 = *(_DWORD *)(v7 + 4 * v13 + 60) & 0x40000;
    if (v14)
      v15 = v13;
    else
      v15 = 46;
    if ((v4 << 24) <= 0x7F000000)
      v16 = *(_DWORD *)(v7 + 4 * (char)v4 + 60) & 0x40000;
    else
      v16 = __maskrune((char)v4, 0x40000uLL);
    if (v16)
      v17 = (char)v4;
    else
      v17 = 46;
    _cg_jpeg_mem_term("IIO_CreateIOSurfaceContext", 2030, "*** Unsupported pixel format %c%c%c%c\n", v9, v12, v15, v17);
    return 0;
  }
}

uint64_t _cg_png_write_flush(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    v1 = result;
    if (*(_DWORD *)(result + 308) < *(_DWORD *)(result + 288))
    {
      png_compress_IDAT(result, 0, 0, 2);
      *(_DWORD *)(v1 + 444) = 0;
      return png_flush(v1);
    }
  }
  return result;
}

void (**_cg_png_write_frame_head(uint64_t a1, unsigned __int8 *a2, uint64_t a3, unsigned int a4, unsigned int a5, int a6, int a7, uint64_t a8, unsigned __int16 a9, Bytef a10, unsigned __int8 a11))(void)
{
  void (**result)(void);

  if ((a2[10] & 2) == 0)
    _cg_png_error((void (**)(void))a1, "png_write_frame_head(): acTL not set");
  png_write_reset(a1);
  result = (void (**)(void))png_write_reinit(a1, a2, a4, a5);
  if (*(_DWORD *)(a1 + 812) || (*(_BYTE *)(a1 + 768) & 1) == 0)
    return png_write_fcTL(a1, a4, a5, a6, a7, a8, a9, a10, a11);
  return result;
}

uint64_t _cg_png_write_frame_tail(uint64_t result)
{
  ++*(_DWORD *)(result + 812);
  return result;
}

const char *TIFFWarning(const char *result, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  const char *v10;

  v10 = result;
  if (_TIFFwarningHandler)
    result = (const char *)_TIFFwarningHandler(result, a2, &a9);
  if (_TIFFwarningHandlerExt)
    return (const char *)_TIFFwarningHandlerExt(0, v10, a2, &a9);
  return result;
}

uint64_t TIFFWarningExtR(uint64_t result, const char *a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;

  v11 = result;
  if (!result
    || !*(_QWORD *)(result + 1344)
    || (result = (*(uint64_t (**)(uint64_t, _QWORD, const char *, const char *, char *))(result + 1344))(result, *(_QWORD *)(result + 1352), a2, a3, &a9), !(_DWORD)result))
  {
    if (_TIFFwarningHandler)
      result = _TIFFwarningHandler(a2, a3, &a9);
    if (_TIFFwarningHandlerExt)
    {
      if (v11)
        v12 = *(_QWORD *)(v11 + 1200);
      else
        v12 = 0;
      return ((uint64_t (*)(uint64_t, const char *, const char *, char *))_TIFFwarningHandlerExt)(v12, a2, a3, &a9);
    }
  }
  return result;
}

void CGImagePluginReadRawXMPProps(const __CFDictionary *a1, const char *a2, uint64_t a3)
{
  _BOOL4 v6;

  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0xC000) == 0)
    ImageIODebugOptions(3, "S", "CGImagePluginReadRawXMPProps", 0, 0, -1, 0);
  v6 = 0;
  if (a1 && (const __CFDictionary *)*MEMORY[0x1E0C9B0D0] != a1)
    v6 = CFDictionaryGetValue(a1, CFSTR("XMP_FROM_SIDECAR")) != 0;
  CGImagePluginReadRawXMPPropsInternal(a1, a2, a3, 0, 0, v6);
}

void CGImagePluginReadRawXMPPropsInternal(__CFDictionary *a1, const char *a2, uint64_t a3, const char *a4, uint64_t a5, int a6)
{
  CGImageMetadata *MetadataFromXMPSidecarData;
  CGImageMetadata *v8;
  int v9;

  if (a6)
  {
    MetadataFromXMPSidecarData = CreateMetadataFromXMPSidecarData(a2, a3);
    v8 = MetadataFromXMPSidecarData;
    v9 = 16;
  }
  else
  {
    MetadataFromXMPSidecarData = CreateMetadataFromExtendedXMPData(a2, a3, a4, a5);
    v8 = MetadataFromXMPSidecarData;
    v9 = 8;
  }
  metadataSetSource((uint64_t)MetadataFromXMPSidecarData, v9);
  if (v8)
  {
    CFDictionaryAddValue(a1, CFSTR("{XMP}"), v8);
    CFDictionaryAddValue(a1, CFSTR("needsPostProcessing"), (const void *)*MEMORY[0x1E0C9AE50]);
    CFRelease(v8);
  }
  else
  {
    CFDictionaryAddValue(a1, CFSTR("needsPostProcessing"), (const void *)*MEMORY[0x1E0C9AE50]);
  }
}

void CGImagePluginReadRawXMPSidecarProps(__CFDictionary *a1, const char *a2, uint64_t a3)
{
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0xC000) == 0)
    ImageIODebugOptions(3, "S", "CGImagePluginReadRawXMPSidecarProps", 0, 0, -1, 0);
  CGImagePluginReadRawXMPPropsInternal(a1, a2, a3, 0, 0, 1);
}

void HEIFGroup::~HEIFGroup(HEIFGroup *this)
{
  void *v2;

  *(_QWORD *)this = &off_1E1BB2F40;
  v2 = (void *)*((_QWORD *)this + 6);
  if (v2)
  {
    *((_QWORD *)this + 7) = v2;
    operator delete(v2);
  }
}

{
  void *v2;

  *(_QWORD *)this = &off_1E1BB2F40;
  v2 = (void *)*((_QWORD *)this + 6);
  if (v2)
  {
    *((_QWORD *)this + 7) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x18D761C30);
}

uint64_t HEIFGroup::setLeftImage(HEIFGroup *this, int a2)
{
  uint64_t result;
  const char *v4;

  if (*((_DWORD *)this + 4) != 1937007986)
  {
    v4 = "*** ERROR cannot add left image to non 'ster' group";
LABEL_7:
    puts(v4);
    return 4294967246;
  }
  if (*((_DWORD *)this + 5) != -1)
  {
    v4 = "*** ERROR left image was already set";
    goto LABEL_7;
  }
  result = 0;
  *((_DWORD *)this + 5) = a2;
  return result;
}

uint64_t HEIFGroup::setRightImage(HEIFGroup *this, int a2)
{
  uint64_t result;
  const char *v4;

  if (*((_DWORD *)this + 4) != 1937007986)
  {
    v4 = "*** ERROR cannot add right image to non 'ster' group";
LABEL_7:
    puts(v4);
    return 4294967246;
  }
  if (*((_DWORD *)this + 6) != -1)
  {
    v4 = "*** ERROR right image was already set";
    goto LABEL_7;
  }
  result = 0;
  *((_DWORD *)this + 6) = a2;
  return result;
}

uint64_t HEIFGroup::setMonoImage(HEIFGroup *this, int a2)
{
  uint64_t result;
  const char *v4;

  if (*((_DWORD *)this + 4) != 1937007986)
  {
    v4 = "*** ERROR cannot add mono image to non 'ster' group";
LABEL_7:
    puts(v4);
    return 4294967246;
  }
  if (*((_DWORD *)this + 7) != -1)
  {
    v4 = "*** ERROR mono image was already set";
    goto LABEL_7;
  }
  result = 0;
  *((_DWORD *)this + 7) = a2;
  return result;
}

uint64_t HEIFGroup::setOtherImage(HEIFGroup *this, int a2)
{
  char *v4;
  unint64_t v5;
  char *v6;
  _DWORD *v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  int v16;
  uint64_t result;

  if (*((_DWORD *)this + 4) == 1634497650)
  {
    v4 = (char *)this + 64;
    v5 = *((_QWORD *)this + 8);
    v6 = (char *)*((_QWORD *)this + 7);
    if ((unint64_t)v6 >= v5)
    {
      v8 = (char *)*((_QWORD *)this + 6);
      v9 = (v6 - v8) >> 2;
      if ((unint64_t)(v9 + 1) >> 62)
        std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
      v10 = v5 - (_QWORD)v8;
      v11 = (uint64_t)(v5 - (_QWORD)v8) >> 1;
      if (v11 <= v9 + 1)
        v11 = v9 + 1;
      if (v10 >= 0x7FFFFFFFFFFFFFFCLL)
        v12 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v12 = v11;
      if (v12)
      {
        v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)v4, v12);
        v8 = (char *)*((_QWORD *)this + 6);
        v6 = (char *)*((_QWORD *)this + 7);
      }
      else
      {
        v13 = 0;
      }
      v14 = &v13[4 * v9];
      v15 = &v13[4 * v12];
      *(_DWORD *)v14 = a2;
      v7 = v14 + 4;
      while (v6 != v8)
      {
        v16 = *((_DWORD *)v6 - 1);
        v6 -= 4;
        *((_DWORD *)v14 - 1) = v16;
        v14 -= 4;
      }
      *((_QWORD *)this + 6) = v14;
      *((_QWORD *)this + 7) = v7;
      *((_QWORD *)this + 8) = v15;
      if (v8)
        operator delete(v8);
    }
    else
    {
      *(_DWORD *)v6 = a2;
      v7 = v6 + 4;
    }
    result = 0;
    *((_QWORD *)this + 7) = v7;
  }
  else
  {
    puts("*** ERROR cannot add other-image to non 'altr' group");
    return 4294967246;
  }
  return result;
}

void HEIFWritePlugin::HEIFWritePlugin(HEIFWritePlugin *this, IIOImageWriteSession *a2, IIOImageDestination *a3, int a4)
{
  _QWORD *v7;
  const __CFString *v8;
  CFComparisonResult v9;
  const char *v10;

  IIOWritePlugin::IIOWritePlugin(this, a2, a3, 0xAu);
  *v7 = &off_1E1BB01C0;
  v7[12] = 0;
  v7[13] = 0;
  v7[14] = 0;
  IIO_LoadHEIFSymbols();
  *((_DWORD *)this + 10) = a4;
  *((_QWORD *)this + 6) = IIOImageDestination::getDepthArray(a3);
  *((_QWORD *)this + 7) = 0;
  v8 = (const __CFString *)IIOImageDestination::utType(a3);
  v9 = CFStringCompare(v8, CFSTR("public.heics"), 0);
  *((_BYTE *)this + 125) = v9 == kCFCompareEqualTo;
  if ((gIIODebugFlags & 0x30000) != 0)
  {
    v10 = "NO";
    if (v9 == kCFCompareEqualTo)
      v10 = "YES";
    ImageIOLog("seq  _creatingHEIFSequence: %s\n", v10);
  }
  *((_BYTE *)this + 124) = 0;
  *((_DWORD *)this + 16) = -1;
  *((_DWORD *)this + 30) = 0;
}

void sub_187FD2318(_Unwind_Exception *a1, uint64_t a2, const char *a3)
{
  uint64_t v3;
  void **v4;
  void *v6;

  v6 = *v4;
  if (*v4)
  {
    *(_QWORD *)(v3 + 104) = v6;
    operator delete(v6);
  }
  _cg_jpeg_mem_term(v3, a2, a3);
  _Unwind_Resume(a1);
}

void HEIFWritePlugin::~HEIFWritePlugin(HEIFWritePlugin *this, uint64_t a2, const char *a3)
{
  _QWORD *v4;
  _QWORD *v5;

  *(_QWORD *)this = &off_1E1BB01C0;
  v4 = (_QWORD *)*((_QWORD *)this + 12);
  v5 = (_QWORD *)*((_QWORD *)this + 13);
  if (v4 != v5)
  {
    do
    {
      if (*v4)
        (*(void (**)(_QWORD))(*(_QWORD *)*v4 + 8))(*v4);
      ++v4;
    }
    while (v4 != v5);
    v4 = (_QWORD *)*((_QWORD *)this + 12);
  }
  *((_QWORD *)this + 13) = v4;
  if (*((_QWORD *)this + 7))
  {
    gFunc_CMPhotoCompressionSessionReleaseHardwareResources();
    CFRelease(*((CFTypeRef *)this + 7));
    *((_QWORD *)this + 7) = 0;
    v4 = (_QWORD *)*((_QWORD *)this + 12);
  }
  if (v4)
  {
    *((_QWORD *)this + 13) = v4;
    operator delete(v4);
  }
  _cg_jpeg_mem_term(this, a2, a3);
}

{
  HEIFWritePlugin::~HEIFWritePlugin(this, a2, a3);
  JUMPOUT(0x18D761C30);
}

CFDataRef HEIFWritePlugin::createExifData(HEIFWritePlugin *this, IIODictionary *a2)
{
  char *ExifBufferFromPropertiesJPEG;
  char *v3;
  CFDataRef v4;
  CFIndex length;

  length = 0;
  ExifBufferFromPropertiesJPEG = CreateExifBufferFromPropertiesJPEG(a2, 0, 0, 0, 0, CFSTR("public.jpeg"), (unint64_t *)&length);
  if (ExifBufferFromPropertiesJPEG)
  {
    v3 = ExifBufferFromPropertiesJPEG;
    v4 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)ExifBufferFromPropertiesJPEG, length);
    free(v3);
  }
  else
  {
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("*** HEIFWritePlugin::createExifData - no Exif data???\n");
    return 0;
  }
  return v4;
}

CFDataRef HEIFWritePlugin::createXMPData(HEIFWritePlugin *this, IIODictionary *a2)
{
  const __CFDictionary *ObjectForKey;
  const CGImageMetadata *v5;
  CFTypeRef v7;
  CFTypeRef cf;
  CFDataRef v9;

  cf = 0;
  v9 = 0;
  v7 = 0;
  ObjectForKey = IIODictionary::getObjectForKey(a2, CFSTR("{MetaData}"));
  if (ObjectForKey)
  {
    v5 = ObjectForKey;
    CFRetain(ObjectForKey);
    goto LABEL_4;
  }
  v5 = (const CGImageMetadata *)CGImageMetadataCreateFromLegacyProps(a2);
  if (v5)
  {
LABEL_4:
    if ((CGImageMetadataCreateExtendedXMPWithEXIFFiltered(v5, &v9, (CFDataRef *)&cf, (CFDataRef *)&v7, 1) & 1) == 0&& *((_BYTE *)this + 37))
    {
      _cg_jpeg_mem_term("createXMPData", 410, "*** HEIFWritePlugin::createXMPData - CGImageMetadataCreateExtendedXMPWithEXIFFiltered failed\n");
    }
    CFRelease(v5);
    goto LABEL_8;
  }
  if (*((_BYTE *)this + 37))
    _cg_jpeg_mem_term("createXMPData", 410, "*** HEIFWritePlugin::createXMPData - CGImageMetadataCreateExtendedXMPWithEXIFFiltered failed\n");
LABEL_8:
  if (cf)
    CFRelease(cf);
  if (v7)
    CFRelease(v7);
  return v9;
}

uint64_t HEIFWritePlugin::writeOneImage(HEIFWritePlugin *this, CGImage *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

void HEIFWritePlugin::updateHEIFProperties(HEIFWritePlugin *this, IIODictionary *a2, IIODictionary *a3)
{
  const __CFDictionary *ObjectForKeyGroup;
  const __CFDictionary *ObjectForKey;
  const __CFDictionary *v7;
  int Uint32ForKey;
  const __CFDictionary *v9;
  const __CFDictionary *v10;
  const __CFDictionary *v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  void *value;
  void *v17;
  _QWORD v18[3];

  ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup(a3, CFSTR("CameraExtrinsics"), CFSTR("{HEIF}"));
  memset(v18, 0, sizeof(v18));
  IIODictionary::IIODictionary((IIODictionary *)v18, ObjectForKeyGroup);
  if (IIODictionary::containsKey((IIODictionary *)v18, CFSTR("Position")))
  {
    v15 = 0;
    value = 0;
    v17 = 0;
    ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v18, CFSTR("Position"));
    IIOArray::IIOArray((IIOArray *)&v15, ObjectForKey);
    if (IIOArray::getCount((IIOArray *)&v15) == 3)
      IIODictionary::setObjectForKey(a2, value, CFSTR("ExtrinsicsPosition"));
    else
      _cg_jpeg_mem_term("updateHEIFProperties", 455, "*** ERROR: CameraExtrinsics/Position should be a CFArray with 3 entries of type 'double'\n");
    IIOArray::~IIOArray((IIOArray *)&v15);
  }
  if (IIODictionary::containsKey((IIODictionary *)v18, CFSTR("Rotation")))
  {
    v15 = 0;
    value = 0;
    v17 = 0;
    v7 = IIODictionary::getObjectForKey((IIODictionary *)v18, CFSTR("Rotation"));
    IIOArray::IIOArray((IIOArray *)&v15, v7);
    if (IIOArray::getCount((IIOArray *)&v15) == 9)
      IIODictionary::setObjectForKey(a2, value, CFSTR("ExtrinsicsRotation"));
    else
      _cg_jpeg_mem_term("updateHEIFProperties", 464, "*** ERROR: CameraExtrinsics/Rotation should be a CFArray with 9 entries of type 'double'\n");
    IIOArray::~IIOArray((IIOArray *)&v15);
  }
  if (IIODictionary::containsKey((IIODictionary *)v18, CFSTR("CoordinateSystemID")))
  {
    Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v18, CFSTR("CoordinateSystemID"));
    IIONumber::IIONumber((IIONumber *)&v15, Uint32ForKey);
    IIODictionary::setObjectForKey(a2, v17, CFSTR("CoordinateSystemID"));
    IIONumber::~IIONumber((IIONumber *)&v15);
  }
  v9 = IIODictionary::getObjectForKeyGroup(a3, CFSTR("CameraModel"), CFSTR("{HEIF}"));
  v15 = 0;
  value = 0;
  v17 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v15, v9);
  if (IIODictionary::containsKey((IIODictionary *)&v15, CFSTR("Intrinsics")))
  {
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v10 = IIODictionary::getObjectForKey((IIODictionary *)&v15, CFSTR("Intrinsics"));
    IIOArray::IIOArray((IIOArray *)&v12, v10);
    if (IIOArray::getCount((IIOArray *)&v12) == 9)
      IIODictionary::setObjectForKey(a2, v13, CFSTR("IntrinsicsMatrix"));
    else
      _cg_jpeg_mem_term("updateHEIFProperties", 483, "*** ERROR: CameraModel/Intrinsics should be a CFArray with 9 entries of type 'double'\n");
    IIOArray::~IIOArray((IIOArray *)&v12);
  }
  if (IIODictionary::containsKey((IIODictionary *)&v15, CFSTR("ModelType")))
  {
    v11 = IIODictionary::getObjectForKey((IIODictionary *)&v15, CFSTR("ModelType"));
    IIODictionary::setObjectForKey(a2, v11, CFSTR("ModelType"));
  }
  IIODictionary::~IIODictionary((IIODictionary *)&v15);
  IIODictionary::~IIODictionary((IIODictionary *)v18);
}

void sub_187FD2864(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v6;
  va_list va;
  uint64_t v8;
  uint64_t v9;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  _Unwind_Resume(a1);
}

__n128 HEIFWritePlugin::updateHardwareEncodeOptions(HEIFWritePlugin *this, IIODictionary *a2, IIODictionary *a3)
{
  int v6;
  __n128 result;
  uint64_t *v8;

  v6 = IIO_HardwareEncoderDefaultValue();
  if (IIODictionary::containsKey(a3, CFSTR("kCGImageDestinationEnableRestrictedEncoding"))
    && IIODictionary::getBoolForKey(a3, CFSTR("kCGImageDestinationEnableRestrictedEncoding")))
  {
    goto LABEL_12;
  }
  switch(v6)
  {
    case -1:
      if (!IIODictionary::containsKey(a3, CFSTR("kCGImageDestinationUseHardwareAcceleration")))
        break;
      if (IIODictionary::getBoolForKey(a3, CFSTR("kCGImageDestinationUseHardwareAcceleration")))
        goto LABEL_9;
LABEL_10:
      _cg_jpeg_mem_term("updateHardwareEncodeOptions", 556, "    setting kCMPhotoCompressionOption_PreferSoftwareCodec to true\n");
      v8 = &gIIO_kCMPhotoCompressionOption_PreferSoftwareCodec;
      goto LABEL_11;
    case 0:
      goto LABEL_10;
    case 1:
LABEL_9:
      _cg_jpeg_mem_term("updateHardwareEncodeOptions", 552, "    setting kCMPhotoCompressionOption_ForceHighSpeed to true\n");
      v8 = &gIIO_kCMPhotoCompressionOption_ForceHighSpeed;
LABEL_11:
      IIODictionary::setObjectForKey(a2, (const void *)*MEMORY[0x1E0C9AE50], *(const __CFString **)*v8);
      break;
  }
LABEL_12:
  if (*((_BYTE *)this + 37))
    return _cg_jpeg_mem_term("updateHardwareEncodeOptions", 562, "    done setting HW options\n");
  return result;
}

uint64_t HEIFWritePlugin::writeImageAtIndex(HEIFWritePlugin *this, IIOImagePixelDataProvider *a2, CGImage *a3, const __CFDictionary **a4, IIODictionary *a5, int a6, uint64_t *a7)
{
  CGBitmapInfo BitmapInfo;
  CGImage *Ref;
  size_t BitsPerComponent;
  int v13;
  unsigned int Uint32ForKey;
  size_t v15;
  _BOOL4 BoolForKey;
  const char *v17;
  __n128 v18;
  float v19;
  int v21;
  int v22;
  uint64_t v23;
  unint64_t v24;
  size_t appleflags;
  uint64_t v26;
  unsigned int v27;
  __IOSurface *v28;
  int Alpha;
  char v30;
  const char *v31;
  const char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  signed int PixelFormat;
  signed int v37;
  unsigned int v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  unsigned int v42;
  int v43;
  uint64_t v44;
  unsigned int v45;
  unsigned int v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  const char *v51;
  uint64_t v52;
  uint64_t v53;
  unsigned int v54;
  int v55;
  const __CFString *Name;
  IIOImagePixelDataProvider *v57;
  IIODictionary *v58;
  CGColorSpace *v59;
  uint64_t *v60;
  int v61;
  unsigned int Uint32ForKeyGroup;
  unsigned int v63;
  BOOL v64;
  unsigned int v65;
  BOOL v66;
  unsigned int v67;
  CFDictionaryRef DictionaryRepresentation;
  uint64_t v69;
  unsigned int v70;
  int v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  const __CFDictionary *ObjectForKey;
  const __CFDictionary *v76;
  CFTypeID v77;
  int v78;
  HEIFWritePlugin *v79;
  __n128 updated;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  __n128 v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  int v90;
  _BOOL8 v91;
  int v92;
  int v93;
  int v94;
  const char *v95;
  CFDataRef ExifData;
  int v97;
  int v98;
  const char *v99;
  CFDataRef XMPData;
  int v101;
  int v102;
  const char *v103;
  const __CFString *v104;
  double DoubleForKeyGroup;
  const char *v107;
  const char *v108;
  int v109;
  unsigned int v110;
  int v111;
  uint64_t v112;
  unsigned int v113;
  int v114;
  uint64_t v115;
  unsigned int v116;
  int v117;
  uint64_t v118;
  int v119;
  uint64_t v120;
  int v121;
  uint64_t v122;
  int v123;
  CGColorSpaceModel Model;
  vImagePixelCount Width;
  uint64_t BytesPerRow;
  uint64_t v127;
  vImagePixelCount Height;
  int v131;
  void *v132;
  void *v133;
  CGColorSpace *space;
  __int128 v136;
  vImagePixelCount v137;
  __int128 v138;
  uint64_t v139;
  _BYTE v140[24];
  _BYTE v141[24];
  __int128 v142;
  uint64_t v143;
  _BYTE v144[24];
  _BYTE v145[24];
  __int128 v146;
  uint64_t v147;
  _BYTE v148[24];
  _BYTE v149[24];
  _BYTE v150[24];
  _BYTE v151[24];
  _BYTE v152[16];
  void *value;
  _BYTE v154[24];
  _BYTE v155[24];
  _BYTE v156[24];
  vImage_Buffer dest;
  uint8_t permuteMap[16];
  const void *v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  _QWORD v164[2];
  CGSize v165;

  v163 = 0;
  v164[0] = 0;
  v161 = 0;
  v162 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v161);
  v160 = 0;
  if (a2)
  {
    BytesPerRow = IIOImagePlus::sourceImageProvider(a2);
    Width = IIOImageSource::count(a2);
    Height = IIO_Reader::testHeaderSize(a2);
    BitmapInfo = IIOImagePixelDataProvider::getBitmapInfo(a2);
    Ref = (CGImage *)IIOImageSource::imageReadRef(a2);
    space = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(a2);
  }
  else
  {
    if (!a3)
    {
      v23 = 4294967246;
      goto LABEL_254;
    }
    BytesPerRow = CGImageGetBytesPerRow(a3);
    Width = CGImageGetWidth(a3);
    Height = CGImageGetHeight(a3);
    BitmapInfo = CGImageGetBitmapInfo(a3);
    space = CGImageGetColorSpace(a3);
    Ref = a3;
  }
  BitsPerComponent = CGImageGetBitsPerComponent(Ref);
  if (BitsPerComponent > 0xF)
    v13 = (BitmapInfo >> 8) & 1;
  else
    v13 = 0;
  Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)a4, CFSTR("Depth"));
  if (Uint32ForKey)
    v15 = Uint32ForKey;
  else
    v15 = BitsPerComponent;
  if (BitsPerComponent < v15)
  {
    _cg_jpeg_mem_term("writeImageAtIndex", 646, "*** imageProperties-bitDepth: %d    bpc: %d  -- using: %d bit/component\n", v15, BitsPerComponent, BitsPerComponent);
    LODWORD(v15) = BitsPerComponent;
  }
  Model = CGColorSpaceGetModel(space);
  if (IIODictionary::getBoolForKey((IIODictionary *)a4, CFSTR("PrimaryImage")) && !*((_BYTE *)this + 124))
  {
    v123 = 1;
    *((_BYTE *)this + 124) = 1;
  }
  else
  {
    v123 = 0;
  }
  if (IIODictionary::containsKey((IIODictionary *)a4, CFSTR("kCGImageSourceEnableRestrictedDecoding")))
  {
    BoolForKey = IIODictionary::getBoolForKey((IIODictionary *)a4, CFSTR("kCGImageSourceEnableRestrictedDecoding"));
    if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild())
    {
      v17 = "";
      if (BoolForKey)
        v17 = "";
      ImageIOLog(" %s EnableRestrictedDecoding  | %s:%d\n", v17, "writeImageAtIndex", 670);
    }
  }
  else
  {
    if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild())
      ImageIOLog("  EnableRestrictedDecoding  | %s:%d\n", "writeImageAtIndex", 673);
    LOBYTE(BoolForKey) = 0;
  }
  v19 = -1.0;
  if (IIODictionary::containsKey((IIODictionary *)a4, CFSTR("kCGImageDestinationLossyCompressionQuality")))
  {
    v18.n128_f32[0] = IIODictionary::getFloatForKey((IIODictionary *)a4, CFSTR("kCGImageDestinationLossyCompressionQuality"));
    if (v18.n128_f32[0] > 1.0 || v18.n128_f32[0] < 0.0)
      v19 = -1.0;
    else
      v19 = v18.n128_f32[0];
  }
  v131 = BitmapInfo & 0x1F;
  if (BoolForKey || !IIO_CGImageWrapsIOSurface((uint64_t)Ref, 1))
  {
    v23 = 4294967246;
  }
  else
  {
    CGImageGetImageProvider();
    if (*MEMORY[0x1E0C9AE50] == CGImageProviderGetProperty())
    {
      LogError("writeImageAtIndex", 694, "*** ERROR: HEIF saving failed - input image cannot be decoded ('kCMPhotoError_XPCError'\n");
      v23 = 4294967246;
      if (!v164[0])
        goto LABEL_254;
      goto LABEL_251;
    }
    if (Model == kCGColorSpaceModelRGB)
    {
      if ((v131 - 1) < 4 || v131 == 7 || v19 == 1.0)
      {
        if (v13)
          v21 = 1380411457;
        else
          v21 = 1815491698;
        if (BitsPerComponent <= 8)
          v22 = 1111970369;
        else
          v22 = v21;
      }
      else if (BitsPerComponent < 9 || *((_DWORD *)this + 10) == 1785750887)
      {
        v22 = 875704422;
      }
      else
      {
        v22 = 2019963440;
        BitsPerComponent = 10;
      }
    }
    else
    {
      v22 = 0;
    }
    memset(&dest, 0, 24);
    IIODictionary::IIODictionary((IIODictionary *)&dest);
    IIONumber::IIONumber((IIONumber *)permuteMap, v22);
    IIODictionary::setObjectForKey((IIODictionary *)&dest, v159, CFSTR("kCGImageSurfaceFormatRequest"));
    IIONumber::~IIONumber((IIONumber *)permuteMap);
    v28 = (__IOSurface *)CGImageProviderCopyIOSurface();
    IIO_IOSurfaceLogAlphaInfo(v28, "writeImageAtIndex surface:");
    Alpha = IIO_IOSurfaceGetAlpha(v28);
    v30 = Alpha;
    if (v131 != Alpha)
    {
      v31 = IIO_AlphaInfoString(v131);
      v32 = IIO_AlphaInfoString(v30);
      _cg_jpeg_mem_term("writeImageAtIndex", 738, "*** NOTE: image-alpha: %s   surface-alpha: %s\n", v31, v32);
    }
    if (v28)
    {
      v33 = gFunc_CVPixelBufferCreateWithIOSurface(*MEMORY[0x1E0C9AE00], v28, 0, v164);
      v34 = v33;
      if ((_DWORD)v33)
      {
        _cg_jpeg_mem_term("writeImageAtIndex", 746, "*** CVPixelBufferCreateWithIOSurface - err=%d\n", v33);
      }
      else
      {
        v122 = v33;
        PixelFormat = IOSurfaceGetPixelFormat(v28);
        v37 = PixelFormat;
        v38 = PixelFormat >> 24;
        v39 = MEMORY[0x1E0C80978];
        if (PixelFormat < 0)
          v40 = __maskrune(PixelFormat >> 24, 0x40000uLL);
        else
          v40 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v38 + 60) & 0x40000;
        if (v40)
          v41 = v38;
        else
          v41 = 46;
        v133 = (void *)v41;
        v42 = v37 << 8 >> 24;
        if (v37 << 8 < 0)
          v43 = __maskrune(v37 << 8 >> 24, 0x40000uLL);
        else
          v43 = *(_DWORD *)(v39 + 4 * v42 + 60) & 0x40000;
        if (v43)
          v44 = v42;
        else
          v44 = 46;
        v127 = v44;
        v45 = (__int16)v37 >> 8;
        if (v37 << 16 < 0)
          v121 = __maskrune(v45, 0x40000uLL);
        else
          v121 = *(_DWORD *)(v39 + 4 * v45 + 60) & 0x40000;
        v46 = (char)v37;
        if ((v37 << 24) <= 0x7F000000)
        {
          v47 = *(_DWORD *)(v39 + 4 * (char)v37 + 60) & 0x40000;
        }
        else
        {
          v47 = __maskrune((char)v37, 0x40000uLL);
          v46 = (char)v37;
        }
        if (v121)
          v48 = ((__int16)v37 >> 8);
        else
          v48 = 46;
        if (v47)
          v49 = v46;
        else
          v49 = 46;
        _cg_jpeg_mem_term("writeImageAtIndex", 752, "*** CVPixelBufferCreateWithIOSurface: '%c%c%c%c'\n", v133, v127, v48, v49);
        BytesPerRow = gFunc_CVPixelBufferGetBytesPerRow(v164[0]);
        v34 = v122;
      }
      CFRelease(v28);
    }
    else
    {
      v34 = 4294967246;
    }
    IIODictionary::~IIODictionary((IIODictionary *)&dest);
    v23 = v34;
  }
  if (v164[0])
  {
    v132 = 0;
    if (!(_DWORD)v23)
      goto LABEL_135;
LABEL_248:
    if (a7)
      *a7 = v160;
    goto LABEL_250;
  }
  v24 = Height * (unint64_t)BytesPerRow;
  if ((v24 & 0xFFFFFFFF00000000) != 0)
  {
LABEL_262:
    v132 = 0;
    goto LABEL_250;
  }
  v132 = malloc_type_malloc(v24, 0x53BCE341uLL);
  if (!v132)
  {
    v18 = _cg_jpeg_mem_term("writeImageAtIndex", 773, "*** could not allocate outputBuffer [%d x %d]\n", Height, Width);
    goto LABEL_262;
  }
  if (a2)
  {
    IIOImagePixelDataProvider::getBytes((uint64_t (**)(IIOImagePixelDataProvider *, void *))a2, v132);
    appleflags = _cg_png_get_appleflags((uint64_t)a2);
  }
  else
  {
    appleflags = CGImageGetBitsPerPixel(a3);
    if (CGImageGetData() != Height)
    {
      v18 = _cg_jpeg_mem_term("writeImageAtIndex", 784, "*** could not get image data [%d x %d]  rb: %d\n", Height, Width, BytesPerRow);
      goto LABEL_250;
    }
  }
  if (*((_DWORD *)this + 10) == 1785750887)
  {
    if (Model == kCGColorSpaceModelMonochrome)
    {
      v26 = 843264056;
      goto LABEL_129;
    }
    if (Model != kCGColorSpaceModelRGB)
    {
      LogError("writeImageAtIndex", 800, "*** ERROR: unsupported colorSpaceModel [JFIF] (%d)\n");
      goto LABEL_83;
    }
    v26 = 1111970369;
    if (appleflags != 32)
      goto LABEL_129;
    if (_AlphaPosition(v131) == 1)
      goto LABEL_60;
    v35 = 1111970369;
LABEL_128:
    v26 = v35;
    if ((_DWORD)v35)
      goto LABEL_129;
LABEL_83:
    LogError("writeImageAtIndex", 875, "*** ERROR: pixelFormat was not set for:  bpc:%d   bpp:%d\n", BitsPerComponent, appleflags);
    v26 = 0;
    goto LABEL_129;
  }
  if (Model == kCGColorSpaceModelRGB)
  {
    v26 = 1111970369;
    if ((v131 - 1) < 4 || v131 == 7)
    {
      v35 = 1111970369;
      if (BitsPerComponent != 8)
      {
        if (appleflags == 64)
        {
          if ((BitmapInfo & 0x100) != 0)
            v26 = 1380411457;
          else
            v26 = 1815491698;
          goto LABEL_129;
        }
        v35 = 0;
      }
    }
    else if (BitsPerComponent == 8)
    {
      v35 = 24;
    }
    else
    {
      v35 = 1815491698;
    }
    if (appleflags == 32 && _AlphaPosition(v131) == 1)
    {
LABEL_60:
      dest.data = v132;
      dest.height = Height;
      dest.width = Width;
      dest.rowBytes = BytesPerRow;
      *(_DWORD *)permuteMap = 50331906;
      vImagePermuteChannels_ARGB8888(&dest, &dest, permuteMap, 0);
      goto LABEL_129;
    }
    goto LABEL_128;
  }
  if (Model)
  {
    LogError("writeImageAtIndex", 844, "*** ERROR: unsupported colorSpaceModel (%d)\n");
    goto LABEL_83;
  }
  if ((BitmapInfo & 0x1F) != 0)
    v27 = 843264056;
  else
    v27 = 1278226488;
  if (BitsPerComponent == 8)
    v26 = v27;
  else
    v26 = v27 + 254;
LABEL_129:
  v50 = gFunc_CVPixelBufferCreateWithBytes(*MEMORY[0x1E0C9AE00], Width, Height, v26, v132, BytesPerRow, CVPixelBufferReleaseImageBlock, v132, v162, v164);
  v23 = v50;
  if ((_DWORD)v50)
  {
    v51 = IIOCMErrorString(v50);
    v52 = MEMORY[0x1E0C80978];
    if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * BYTE3(v26) + 60) & 0x40000) != 0)
      v53 = BYTE3(v26);
    else
      v53 = 46;
    v54 = (int)((_DWORD)v26 << 8) >> 24;
    if ((((_DWORD)v26 << 8) & 0x80000000) != 0)
      v55 = __maskrune((int)((_DWORD)v26 << 8) >> 24, 0x40000uLL);
    else
      v55 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v54 + 60) & 0x40000;
    if (v55)
      v69 = v54;
    else
      v69 = 46;
    v70 = (__int16)v26 >> 8;
    if ((((_DWORD)v26 << 16) & 0x80000000) != 0)
      v71 = __maskrune((__int16)v26 >> 8, 0x40000uLL);
    else
      v71 = *(_DWORD *)(v52 + 4 * v70 + 60) & 0x40000;
    if ((_DWORD)v26 << 24 <= 0x7F000000u)
      v72 = *(_DWORD *)(v52 + 4 * (char)v26 + 60) & 0x40000;
    else
      v72 = __maskrune((char)v26, 0x40000uLL);
    if (v71)
      v73 = v70;
    else
      v73 = 46;
    if (v72)
      v74 = (char)v26;
    else
      v74 = 46;
    v18 = _cg_jpeg_mem_term("writeImageAtIndex", 883, "*** ERROR: CVPixelBufferCreateWithBytes err = %s [%d]  '%c%c%c%c'\n", v51, v23, v53, v69, v73, v74);
    goto LABEL_248;
  }
LABEL_135:
  Name = CGColorSpaceGetName(space);
  if (Name && CFStringCompare(Name, CFSTR("kCGColorSpaceDeviceRGB"), 0) == kCFCompareEqualTo)
  {
    v59 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
    gFunc_CVBufferSetAttachment(v164[0], *(_QWORD *)gIIO_kCVImageBufferCGColorSpaceKey, v59, 1);
    CGColorSpaceRelease(v59);
  }
  else
  {
    gFunc_CVBufferSetAttachment(v164[0], *(_QWORD *)gIIO_kCVImageBufferCGColorSpaceKey, space, 1);
  }
  if (!a6)
    HEIFWritePlugin::prepareHEIFWriting(this, v57, v58);
  if (v131 == 3)
  {
    v60 = &gIIO_kCVImageBufferAlphaChannelMode_StraightAlpha;
  }
  else
  {
    if (v131 != 1)
      goto LABEL_146;
    v60 = &gIIO_kCVImageBufferAlphaChannelMode_PremultipliedAlpha;
  }
  gFunc_CVBufferSetAttachment(v164[0], *(_QWORD *)gIIO_kCVImageBufferAlphaChannelModeKey, *(_QWORD *)*v60, 1);
LABEL_146:
  memset(&dest, 0, 24);
  IIODictionary::IIODictionary((IIODictionary *)&dest);
  if ((_DWORD)v15 == 8)
    v61 = 8;
  else
    v61 = 10;
  IIONumber::IIONumber((IIONumber *)permuteMap, v61);
  IIODictionary::setObjectForKey((IIODictionary *)&dest, v159, *(const __CFString **)gIIO_kCMPhotoCompressionOption_BitDepth);
  IIONumber::~IIONumber((IIONumber *)permuteMap);
  IIONumber::IIONumber((IIONumber *)v156, *((_DWORD *)this + 10));
  IIODictionary::setObjectForKey((uint64_t)&dest, (uint64_t)v156, *(const void **)gIIO_kCMPhotoCompressionOption_CodecType);
  IIONumber::~IIONumber((IIONumber *)v156);
  if (*((_DWORD *)this + 10) == 1752589105
    && IIODictionary::containsKeyGroup((IIODictionary *)a4, CFSTR("TileWidth"), CFSTR("{TIFF}"))
    && IIODictionary::containsKeyGroup((IIODictionary *)a4, CFSTR("TileLength"), CFSTR("{TIFF}")))
  {
    Uint32ForKeyGroup = IIODictionary::getUint32ForKeyGroup((IIODictionary *)a4, CFSTR("TileWidth"), CFSTR("{TIFF}"));
    v63 = IIODictionary::getUint32ForKeyGroup((IIODictionary *)a4, CFSTR("TileLength"), CFSTR("{TIFF}"));
    v64 = (Uint32ForKeyGroup & 0x7F) != 0 || Uint32ForKeyGroup == 0;
    v65 = (Uint32ForKeyGroup + 127) & 0xFFFFFF80;
    if (!v64)
      v65 = Uint32ForKeyGroup;
    v66 = (v63 & 0x3F) != 0 || v63 == 0;
    v67 = (v63 + 63) & 0xFFFFFFC0;
    if (!v66)
      v67 = v63;
    if (v65)
    {
      if (v67)
      {
        v165.width = (double)v65;
        v165.height = (double)v67;
        DictionaryRepresentation = CGSizeCreateDictionaryRepresentation(v165);
        if (DictionaryRepresentation)
        {
          IIODictionary::setObjectForKey((IIODictionary *)&dest, DictionaryRepresentation, *(const __CFString **)gIIO_kCMPhotoCompressionOption_Tiling);
          CFRelease(DictionaryRepresentation);
        }
      }
    }
  }
  if (v19 != -1.0)
  {
    if (*((_DWORD *)this + 10) == 1785750887)
    {
      IIONumber::IIONumber((IIONumber *)v155, 3);
      IIODictionary::setObjectForKey((uint64_t)&dest, (uint64_t)v155, *(const void **)gIIO_kCMPhotoCompressionOption_QualityControllerType);
      IIONumber::~IIONumber((IIONumber *)v155);
      memset(permuteMap, 0, sizeof(permuteMap));
      v159 = 0;
      IIODictionary::IIODictionary((IIODictionary *)permuteMap);
      IIONumber::IIONumber((IIONumber *)v154, v19);
      IIODictionary::setObjectForKey((uint64_t)permuteMap, (uint64_t)v154, *(const void **)gIIO_kCMPhotoQualityControllerParameter_QualityValue);
      IIONumber::~IIONumber((IIONumber *)v154);
      IIODictionary::setObjectForKey((IIODictionary *)&dest, *(const void **)&permuteMap[8], *(const __CFString **)gIIO_kCMPhotoCompressionOption_QualityControllerParameters);
      if (v19 == 1.0)
      {
        IIONumber::IIONumber((IIONumber *)v152, 3);
        IIODictionary::setObjectForKey((IIODictionary *)&dest, value, *(const __CFString **)gIIO_kCMPhotoCompressionOption_Subsampling);
        IIONumber::~IIONumber((IIONumber *)v152);
      }
    }
    else
    {
      if (v19 >= 1.0)
      {
        IIONumber::IIONumber((IIONumber *)permuteMap, 3);
        IIODictionary::setObjectForKey((IIODictionary *)&dest, v159, *(const __CFString **)gIIO_kCMPhotoCompressionOption_Subsampling);
        IIONumber::~IIONumber((IIONumber *)permuteMap);
        IIONumber::IIONumber((IIONumber *)v149, 6);
        IIODictionary::setObjectForKey((uint64_t)&dest, (uint64_t)v149, *(const void **)gIIO_kCMPhotoCompressionOption_QualityControllerType);
        IIONumber::~IIONumber((IIONumber *)v149);
        goto LABEL_191;
      }
      IIONumber::IIONumber((IIONumber *)v151, 3);
      IIODictionary::setObjectForKey((uint64_t)&dest, (uint64_t)v151, *(const void **)gIIO_kCMPhotoCompressionOption_QualityControllerType);
      IIONumber::~IIONumber((IIONumber *)v151);
      memset(permuteMap, 0, sizeof(permuteMap));
      v159 = 0;
      IIODictionary::IIODictionary((IIODictionary *)permuteMap);
      IIONumber::IIONumber((IIONumber *)v150, v19);
      IIODictionary::setObjectForKey((uint64_t)permuteMap, (uint64_t)v150, *(const void **)gIIO_kCMPhotoQualityControllerParameter_QualityValue);
      IIONumber::~IIONumber((IIONumber *)v150);
      IIODictionary::setObjectForKey((IIODictionary *)&dest, *(const void **)&permuteMap[8], *(const __CFString **)gIIO_kCMPhotoCompressionOption_QualityControllerParameters);
    }
    IIODictionary::~IIODictionary((IIODictionary *)permuteMap);
  }
LABEL_191:
  ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)a4, CFSTR("kCGImageDestinationEnableRGBToYUVDithering"));
  v76 = ObjectForKey;
  if (ObjectForKey)
  {
    v77 = CFGetTypeID(ObjectForKey);
    if (v77 == CFBooleanGetTypeID())
      IIODictionary::setObjectForKey((IIODictionary *)&dest, v76, *(const __CFString **)gIIO_kCMPhotoCompressionOption_RGBToYUVDithering);
  }
  if (v123)
    IIODictionary::setObjectForKey((IIODictionary *)&dest, (const void *)*MEMORY[0x1E0C9AE50], *(const __CFString **)gIIO_kCMPhotoCompressionOption_PrimaryImage);
  if (*((_DWORD *)this + 10) == 1752589105)
  {
    if (a4 && IIODictionary::containsKey((IIODictionary *)a4, CFSTR("Orientation")))
      v78 = IIODictionary::getUint32ForKey((IIODictionary *)a4, CFSTR("Orientation"));
    else
      v78 = 1;
    IIONumber::IIONumber((IIONumber *)v148, v78);
    IIODictionary::setObjectForKey((uint64_t)&dest, (uint64_t)v148, *(const void **)gIIO_kCMPhotoCompressionOption_ImageOrientation);
    IIONumber::~IIONumber((IIONumber *)v148);
  }
  v79 = IIODictionary::containsKey((IIODictionary *)a4, CFSTR("{HEIF}"));
  if ((_DWORD)v79)
    HEIFWritePlugin::updateHEIFProperties(v79, (IIODictionary *)&dest, (IIODictionary *)a4);
  updated = HEIFWritePlugin::updateHardwareEncodeOptions(this, (IIODictionary *)&dest, (IIODictionary *)a4);
  v81 = *((_QWORD *)this + 7);
  if (*((_BYTE *)this + 125))
  {
    v82 = *((int *)this + 16);
    v146 = *(_OWORD *)((char *)this + 68);
    v147 = *(_QWORD *)((char *)this + 84);
    v83 = gFunc_CMPhotoCompressionSessionAddImageToSequence(v81, v82, &v146, dest.height, v164[0], &v160);
    v23 = v83;
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("seq CMPhotoCompressionSessionAddImageToSequence: [session:%p]  seq:%d  img:%d  err=%d\n", *((const void **)this + 7), *((_DWORD *)this + 16), v160, v83);
  }
  else
  {
    v84 = gFunc_CMPhotoCompressionSessionAddImage(v81, dest.height, v164[0], &v160, updated);
    v23 = v84;
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("    CMPhotoCompressionSessionAddImage: [session:%p]  err=%d\n", *((const void **)this + 7), v84);
  }
  if ((_DWORD)v23 == -15474)
  {
    IIONumber::IIONumber((IIONumber *)permuteMap, 5);
    IIODictionary::setObjectForKey((IIODictionary *)&dest, v159, *(const __CFString **)gIIO_kCMPhotoCompressionOption_Subsampling);
    IIONumber::~IIONumber((IIONumber *)permuteMap);
    IIODictionary::removeObjectForKey((IIODictionary *)&dest, *(const __CFString **)gIIO_kCMPhotoCompressionOption_QualityControllerType);
    IIONumber::IIONumber((IIONumber *)v145, 3);
    IIODictionary::setObjectForKey((uint64_t)&dest, (uint64_t)v145, *(const void **)gIIO_kCMPhotoCompressionOption_QualityControllerType);
    IIONumber::~IIONumber((IIONumber *)v145);
    memset(permuteMap, 0, sizeof(permuteMap));
    v159 = 0;
    IIODictionary::IIODictionary((IIODictionary *)permuteMap);
    IIONumber::IIONumber((IIONumber *)v144, v19);
    IIODictionary::setObjectForKey((uint64_t)permuteMap, (uint64_t)v144, *(const void **)gIIO_kCMPhotoQualityControllerParameter_QualityValue);
    IIONumber::~IIONumber((IIONumber *)v144);
    IIODictionary::setObjectForKey((IIODictionary *)&dest, *(const void **)&permuteMap[8], *(const __CFString **)gIIO_kCMPhotoCompressionOption_QualityControllerParameters);
    v86 = *((_QWORD *)this + 7);
    if (*((_BYTE *)this + 125))
    {
      v87 = *((int *)this + 16);
      v142 = *(_OWORD *)((char *)this + 68);
      v143 = *(_QWORD *)((char *)this + 84);
      v88 = gFunc_CMPhotoCompressionSessionAddImageToSequence(v86, v87, &v142, dest.height, v164[0], &v160);
      v23 = v88;
      if ((gIIODebugFlags & 0x30000) != 0)
        ImageIOLog("seq CMPhotoCompressionSessionAddImageToSequence: [session:%p]  seq:%d  img:%d  err=%d\n", *((const void **)this + 7), *((_DWORD *)this + 16), v160, v88);
    }
    else
    {
      v89 = gFunc_CMPhotoCompressionSessionAddImage(v86, dest.height, v164[0], &v160, v85);
      v23 = v89;
      if ((gIIODebugFlags & 0x30000) != 0)
        ImageIOLog("    CMPhotoCompressionSessionAddImage: [session:%p]  err=%d\n", *((const void **)this + 7), v89);
    }
    IIODictionary::~IIODictionary((IIODictionary *)permuteMap);
  }
  if ((_DWORD)v23)
  {
    if (*((_BYTE *)this + 125))
      v107 = "CMPhotoCompressionSessionAddImageToSequence";
    else
      v107 = "CMPhotoCompressionSessionAddImage";
    v108 = IIOCMErrorString(v23);
    v109 = *((_DWORD *)this + 10);
    v110 = v109 >> 24;
    if (v109 < 0)
    {
      v111 = __maskrune(v110, 0x40000uLL);
      v109 = *((_DWORD *)this + 10);
    }
    else
    {
      v111 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v110 + 60) & 0x40000;
    }
    if (v111)
      v112 = (v109 >> 24);
    else
      v112 = 46;
    v113 = v109 << 8 >> 24;
    if (v109 << 8 < 0)
    {
      v114 = __maskrune(v113, 0x40000uLL);
      v109 = *((_DWORD *)this + 10);
    }
    else
    {
      v114 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v113 + 60) & 0x40000;
    }
    if (v114)
      v115 = (v109 << 8 >> 24);
    else
      v115 = 46;
    v116 = (__int16)v109 >> 8;
    if (v109 << 16 < 0)
    {
      v117 = __maskrune(v116, 0x40000uLL);
      v109 = *((_DWORD *)this + 10);
    }
    else
    {
      v117 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v116 + 60) & 0x40000;
    }
    if (v117)
      v118 = ((__int16)v109 >> 8);
    else
      v118 = 46;
    if ((v109 << 24) <= 0x7F000000)
      v119 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v109 + 60) & 0x40000;
    else
      v119 = __maskrune((char)v109, 0x40000uLL);
    if (v119)
      v120 = *((char *)this + 40);
    else
      v120 = 46;
    LogError("writeImageAtIndex", 1085, "*** %s: err = %s [%d]    (codec: '%c%c%c%c')\n", v107, v108, v23, v112, v115, v118, v120);
    IIODictionary::~IIODictionary((IIODictionary *)&dest);
  }
  else
  {
    if ((BitmapInfo & 0x1D | 2) == 3)
    {
      memset(permuteMap, 0, sizeof(permuteMap));
      v159 = 0;
      IIODictionary::IIODictionary((IIODictionary *)permuteMap);
      v90 = gFunc_CMPhotoCompressionSessionAddAuxiliaryImage(*((_QWORD *)this + 7), v160, 3, 0, *(_QWORD *)&permuteMap[8], v164[0], 0);
      if ((gIIODebugFlags & 0x30000) != 0)
        ImageIOLog("    CMPhotoCompressionSessionAddAuxiliaryImage: [session:%p]  err=%d\n", *((const void **)this + 7), v90);
      IIODictionary::~IIODictionary((IIODictionary *)permuteMap);
    }
    IIODictionary::~IIODictionary((IIODictionary *)&dest);
    v91 = IIODictionary::getBoolForKey((IIODictionary *)a4, CFSTR("kCGImageDestinationEmbedThumbnail"));
    if (v91)
    {
      *(_QWORD *)permuteMap = 320;
      v92 = gFunc_CMPhotoDetermineMIAFCompliantThumbnailMaxPixelSize(permuteMap, (float)Width, (float)Height);
      if ((gIIODebugFlags & 0x30000) != 0)
        ImageIOLog("    CMPhotoDetermineMIAFCompliantThumbnailMaxPixelSize: [session:%p] size:%u err:%d\n", *((const void **)this + 7), *(_DWORD *)permuteMap, v92);
      memset(&dest, 0, 24);
      IIODictionary::IIODictionary((IIODictionary *)&dest);
      IIONumber::IIONumber((IIONumber *)v141, *(int *)permuteMap);
      IIODictionary::setObjectForKey((uint64_t)&dest, (uint64_t)v141, *(const void **)gIIO_kCMPhotoCompressionOption_MaxPixelSize);
      IIONumber::~IIONumber((IIONumber *)v141);
      IIONumber::IIONumber((IIONumber *)v140, *((_DWORD *)this + 10));
      IIODictionary::setObjectForKey((uint64_t)&dest, (uint64_t)v140, *(const void **)gIIO_kCMPhotoCompressionOption_CodecType);
      IIONumber::~IIONumber((IIONumber *)v140);
      IIODictionary::setObjectForKey((IIODictionary *)&dest, (const void *)*MEMORY[0x1E0C9AE50], *(const __CFString **)gIIO_kCMPhotoCompressionOption_ForceHighSpeed);
      v93 = gFunc_CMPhotoCompressionSessionAddThumbnail(*((_QWORD *)this + 7), v160, dest.height, v164[0]);
      v94 = v93;
      if ((gIIODebugFlags & 0x30000) != 0)
        ImageIOLog("    CMPhotoCompressionSessionAddThumbnail: [session:%p]  img:%d  err=%d\n", *((const void **)this + 7), v160, v93);
      if (v94)
      {
        v95 = IIOCMErrorString(v94);
        _cg_jpeg_mem_term("writeImageAtIndex", 1120, "*** CMPhotoCompressionSessionAddThumbnail  err = %s [%d]\n", v95, v94);
      }
      IIODictionary::~IIODictionary((IIODictionary *)&dest);
    }
    if (a4)
    {
      ExifData = HEIFWritePlugin::createExifData((HEIFWritePlugin *)v91, (IIODictionary *)a4);
      if (ExifData)
      {
        v97 = gFunc_CMPhotoCompressionSessionAddExif (*((_QWORD *)this + 7), v160, 0, ExifData);
        v98 = v97;
        if ((gIIODebugFlags & 0x30000) != 0)
          ImageIOLog("    CMPhotoCompressionSessionAddExif: [session:%p]  img:%d  err=%d\n", *((const void **)this + 7), v160, v97);
        if (v98)
        {
          v99 = IIOCMErrorString(v98);
          _cg_jpeg_mem_term("writeImageAtIndex", 1139, "*** CMPhotoCompressionSessionAddExif  err = %s [%d]\n", v99, v98);
          IIO_CFShow(a4[1], 2, "imageProperties");
        }
        CFRelease(ExifData);
      }
      XMPData = HEIFWritePlugin::createXMPData(this, (IIODictionary *)a4);
      if (XMPData)
      {
        v101 = gFunc_CMPhotoCompressionSessionAddXMP(*((_QWORD *)this + 7), v160, 0, XMPData);
        v102 = v101;
        if ((gIIODebugFlags & 0x30000) != 0)
          ImageIOLog("    CMPhotoCompressionSessionAddXMP: [session:%p]  img:%d  err=%d\n", *((const void **)this + 7), v160, v101);
        if (v102)
        {
          v103 = IIOCMErrorString(v102);
          _cg_jpeg_mem_term("writeImageAtIndex", 1161, "*** CMPhotoCompressionSessionAddXMP  err = %s [%d]\n", v103, v102);
          IIO_CFShow(a4[1], 2, "imageProperties");
        }
        CFRelease(XMPData);
      }
    }
    v23 = HEIFWritePlugin::writeAuxImages(this, a6, v160);
    if (!(_DWORD)v23)
    {
      HEIFWritePlugin::writeAlternateImage(this, a6, v160);
      v104 = CFSTR("UnclampedDelayTime");
      if ((IIODictionary::containsKeyGroup((IIODictionary *)a4, CFSTR("UnclampedDelayTime"), CFSTR("{HEICS}")) & 1) != 0|| (v104 = CFSTR("DelayTime"), IIODictionary::containsKeyGroup((IIODictionary *)a4, CFSTR("DelayTime"), CFSTR("{HEICS}"))))
      {
        DoubleForKeyGroup = IIODictionary::getDoubleForKeyGroup((IIODictionary *)a4, v104, CFSTR("{HEICS}"));
      }
      else
      {
        DoubleForKeyGroup = 0.1;
      }
      memset(&dest, 0, 24);
      gFunc_CMTimeMake(&dest, (uint64_t)(DoubleForKeyGroup * 1000.0), 1000);
      v138 = *(_OWORD *)((char *)this + 68);
      v139 = *(_QWORD *)((char *)this + 84);
      v136 = *(_OWORD *)&dest.data;
      v137 = dest.width;
      gFunc_CMTimeAdd(permuteMap, &v138, &v136);
      v23 = 0;
      v18 = *(__n128 *)permuteMap;
      *(_OWORD *)((char *)this + 68) = *(_OWORD *)permuteMap;
      *(_QWORD *)((char *)this + 84) = v159;
      goto LABEL_248;
    }
    v18 = _cg_jpeg_mem_term("writeImageAtIndex", 1172, "*** ERROR: failed to write aux images...");
  }
LABEL_250:
  if (v164[0])
  {
LABEL_251:
    gFunc_CVPixelBufferRelease(v18);
    goto LABEL_254;
  }
  if (v132)
    free(v132);
LABEL_254:
  IIODictionary::~IIODictionary((IIODictionary *)&v161);
  return v23;
}

void sub_187FD4318(_Unwind_Exception *a1)
{
  uint64_t v1;

  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 136));
  _Unwind_Resume(a1);
}

void CVPixelBufferReleaseImageBlock(void *a1, const void *a2)
{
  if (a1)
    free(a1);
}

uint64_t HEIFWritePlugin::prepareHEIFWriting(HEIFWritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3)
{
  const void **v4;
  uint64_t v5;
  uint64_t v6;
  IIONumber *v7;
  uint64_t v8;
  uint64_t started;
  const char *v11;
  const char *v12;
  const char *v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  _BYTE v17[24];
  _BYTE v18[24];
  _BYTE v19[24];
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  v23 = 0;
  v24 = 0;
  v25 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v23);
  if (IIOWritePlugin::getImageCount((IIOImageDestination **)this) >= 2)
    IIODictionary::setObjectForKey((IIODictionary *)&v23, (const void *)*MEMORY[0x1E0C9AE50], *(const __CFString **)gIIO_kCMPhotoCompressionSessionOption_UseCodecSessionPool);
  v4 = (const void **)((char *)this + 56);
  v5 = gFunc_CMPhotoCompressionSessionCreate(*MEMORY[0x1E0C9AE00], v24, (char *)this + 56);
  v6 = v5;
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("    CMPhotoCompressionSessionCreate: [session:%p]  err=%d\n", *v4, v5);
  if ((_DWORD)v6 || !*v4)
  {
    v11 = IIOCMErrorString(v6);
    _cg_jpeg_mem_term("prepareHEIFWriting", 1512, "*** CMPhotoCompressionSessionCreate: err = %s [%d]\n", v11, v6);
  }
  else
  {
    v20 = 0;
    v21 = 0;
    v22 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v20);
    IIONumber::IIONumber((IIONumber *)v19, 1);
    IIODictionary::setObjectForKey((uint64_t)&v20, (uint64_t)v19, *(const void **)gIIO_kCMPhotoCompressionContainerOption_BackingType);
    IIONumber::~IIONumber((IIONumber *)v19);
    if (*((_DWORD *)this + 10) == 1785750887)
    {
      IIONumber::IIONumber((IIONumber *)v18, 1);
      v7 = (IIONumber *)v18;
      IIODictionary::setObjectForKey((uint64_t)&v20, (uint64_t)v18, *(const void **)gIIO_kCMPhotoCompressionContainerOption_Format);
    }
    else
    {
      IIONumber::IIONumber((IIONumber *)v17, 0);
      v7 = (IIONumber *)v17;
      IIODictionary::setObjectForKey((uint64_t)&v20, (uint64_t)v17, *(const void **)gIIO_kCMPhotoCompressionContainerOption_Format);
    }
    IIONumber::~IIONumber(v7);
    v8 = gFunc_CMPhotoCompressionSessionOpenEmptyContainer(*v4, v21);
    v6 = v8;
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("    CMPhotoCompressionSessionOpenEmptyContainer: [session:%p]  err=%d\n", *v4, v8);
    if ((_DWORD)v6)
    {
      v12 = IIOCMErrorString(v6);
      _cg_jpeg_mem_term("prepareHEIFWriting", 1538, "*** CMPhotoCompressionSessionOpenEmptyContainer: err = %s [%d]\n", v12, v6);
    }
    else if (*((_BYTE *)this + 125))
    {
      v16 = 0;
      started = gFunc_CMPhotoCompressionSessionStartImageSequence(*v4, 0, &v16);
      v6 = started;
      if ((gIIODebugFlags & 0x30000) != 0)
        ImageIOLog("seq CMPhotoCompressionSessionStartImageSequence: [session:%p]  seq:%d  err=%d\n", *v4, v16, started);
      if ((_DWORD)v6)
      {
        v13 = IIOCMErrorString(v6);
        _cg_jpeg_mem_term("prepareHEIFWriting", 1545, "*** CMPhotoCompressionSessionStartImageSequence: err = %s [%d]\n", v13, v6);
      }
      else
      {
        *((_DWORD *)this + 16) = v16;
        gFunc_CMTimeMake(&v14, 0, 1000);
        *(_OWORD *)((char *)this + 68) = v14;
        *(_QWORD *)((char *)this + 84) = v15;
      }
    }
    else
    {
      v6 = 0;
    }
    IIODictionary::~IIODictionary((IIODictionary *)&v20);
  }
  IIODictionary::~IIODictionary((IIODictionary *)&v23);
  return v6;
}

void sub_187FD47BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v8;
  va_list va;

  va_start(va, a8);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)(v8 - 80));
  IIODictionary::~IIODictionary((IIODictionary *)(v8 - 56));
  _Unwind_Resume(a1);
}

uint64_t HEIFWritePlugin::writeAuxImages(HEIFWritePlugin *this, int a2, uint64_t a3)
{
  const __CFArray *v4;
  IIOArray *v7;
  unsigned int Count;
  CFIndex v9;
  uint64_t v10;
  uint64_t v11;
  const __CFDictionary *ObjectAtIndex;
  IIODictionary *v13;
  const __CFDictionary *Uint32ForKey;
  const __CFString *ObjectForKey;
  _BOOL4 BoolForKey;
  const __CFString *v17;
  CFComparisonResult v18;
  const __CFString *v19;
  CFComparisonResult v20;
  CFComparisonResult v21;
  CFComparisonResult v22;
  CFComparisonResult v23;
  CFComparisonResult v24;
  CFComparisonResult v25;
  CFComparisonResult v26;
  CFComparisonResult v27;
  const __CFDictionary *v28;
  const __CFDictionary *ObjectForKeyGroup;
  uint64_t v30;
  const char *v31;
  int v32;
  HEIFWritePlugin *v33;
  IIODictionary *v34;
  const __CFDictionary *PixelBufferFromAuxiliaryDataInfo;
  const __CFDictionary *v36;
  uint64_t v37;
  const char *v38;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  _QWORD v50[3];
  _QWORD v51[4];

  v4 = (const __CFArray *)*((_QWORD *)this + 6);
  if (!v4)
    return 0;
  memset(v51, 0, 24);
  v7 = IIOArray::IIOArray((IIOArray *)v51, v4);
  Count = IIOArray::getCount(v7);
  if (!Count)
  {
    v10 = 0;
    goto LABEL_47;
  }
  v9 = 0;
  v10 = 0;
  v11 = Count;
  while (1)
  {
    ObjectAtIndex = IIOArray::getObjectAtIndex((IIOArray *)v51, v9);
    memset(v50, 0, sizeof(v50));
    v13 = IIODictionary::IIODictionary((IIODictionary *)v50, ObjectAtIndex);
    Uint32ForKey = IIODictionary::getUint32ForKey(v13, "AuxiliaryImageType");
    ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey((IIODictionary *)v50, "AuxiliaryImageURN");
    BoolForKey = IIODictionary::getBoolForKey((IIODictionary *)v50, "customMetadata");
    v47 = 0;
    v48 = 0;
    v49 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v47);
    v46 = 0;
    if (IIODictionary::getUint32ForKey((IIODictionary *)v50, CFSTR("ImageIndex")) != a2
      || ObjectForKey
      && CFStringCompare(CFSTR("kCGImageAuxiliaryDataTypeISOGainMap"), ObjectForKey, 0) == kCFCompareEqualTo)
    {
      goto LABEL_36;
    }
    v17 = CFSTR("kCGImageAuxiliaryDataTypeDisparity");
    if ((_DWORD)Uint32ForKey == 1)
      goto LABEL_22;
    if ((_DWORD)Uint32ForKey == 5)
    {
      v17 = CFSTR("kCGImageAuxiliaryDataTypePortraitEffectsMatte");
LABEL_22:
      v28 = IIODictionary::getObjectForKey((IIODictionary *)v50, v17);
      goto LABEL_23;
    }
    v17 = CFSTR("kCGImageAuxiliaryDataTypeDepth");
    if ((_DWORD)Uint32ForKey == 2)
      goto LABEL_22;
    if (ObjectForKey)
    {
      v18 = CFStringCompare(*(CFStringRef *)gIIO_kCMPhotoAuxiliaryImageTypeURN_Alpha, ObjectForKey, 0);
      v19 = CFSTR("kCGImageAuxiliaryDataTypeAlpha");
      if (v18 == kCFCompareEqualTo)
        goto LABEL_39;
      v20 = CFStringCompare(*(CFStringRef *)gIIO_kCMPhotoAuxiliaryImageTypeURN_Depth, ObjectForKey, 0);
      v19 = CFSTR("kCGImageAuxiliaryDataTypeDepth");
      if (v20 == kCFCompareEqualTo)
        goto LABEL_39;
      v21 = CFStringCompare(*(CFStringRef *)gIIO_kCMPhotoAuxiliaryImageTypeURN_PortraitEffectsMatte, ObjectForKey, 0);
      v19 = CFSTR("kCGImageAuxiliaryDataTypePortraitEffectsMatte");
      if (v21 == kCFCompareEqualTo)
        goto LABEL_39;
      v22 = CFStringCompare(*(CFStringRef *)gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticSkinMatte, ObjectForKey, 0);
      v19 = CFSTR("kCGImageAuxiliaryDataTypeSemanticSegmentationSkinMatte");
      if (v22 == kCFCompareEqualTo)
        goto LABEL_39;
      v23 = CFStringCompare(*(CFStringRef *)gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticHairMatte, ObjectForKey, 0);
      v19 = CFSTR("kCGImageAuxiliaryDataTypeSemanticSegmentationHairMatte");
      if (v23 == kCFCompareEqualTo)
        goto LABEL_39;
      v24 = CFStringCompare(*(CFStringRef *)gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticTeethMatte, ObjectForKey, 0);
      v19 = CFSTR("kCGImageAuxiliaryDataTypeSemanticSegmentationTeethMatte");
      if (v24 == kCFCompareEqualTo)
        goto LABEL_39;
      v25 = CFStringCompare(*(CFStringRef *)gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticGlassesMatte, ObjectForKey, 0);
      v19 = CFSTR("kCGImageAuxiliaryDataTypeSemanticSegmentationGlassesMatte");
      if (v25
        && (v26 = CFStringCompare(*(CFStringRef *)gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticSkyMatte, ObjectForKey, 0), v19 = CFSTR("kCGImageAuxiliaryDataTypeSemanticSegmentationSkyMatte"), v26)&& (v27 = CFStringCompare(*(CFStringRef *)gIIO_kCMPhotoAuxiliaryImageTypeURN_HDRGainMap, ObjectForKey, 0), v19 = CFSTR("kCGImageAuxiliaryDataTypeHDRGainMap"), v27))
      {
        v28 = 0;
      }
      else
      {
LABEL_39:
        v28 = IIODictionary::getObjectForKey((IIODictionary *)v50, v19);
      }
      if (BoolForKey)
        v28 = IIODictionary::getObjectForKey((IIODictionary *)v50, ObjectForKey);
      IIODictionary::setObjectForKey((IIODictionary *)&v47, ObjectForKey, *(const __CFString **)gIIO_kCMPhotoCompressionOption_AuxiliaryImageCustomTypeURN);
    }
    else
    {
      v28 = 0;
    }
LABEL_23:
    if (!BoolForKey)
      break;
    v43 = 0;
    v44 = 0;
    v45 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v43);
    v40 = 0;
    v41 = 0;
    v42 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v40);
    ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup((IIODictionary *)v50, CFSTR("kCGImageAuxiliaryDataInfoData"), ObjectForKey);
    IIODictionary::setObjectForKey((IIODictionary *)&v43, ObjectForKeyGroup, *(const __CFString **)gIIO_kCMPhotoCustomMetadata_Data);
    IIODictionary::setObjectForKey((IIODictionary *)&v43, ObjectForKey, *(const __CFString **)gIIO_kCMPhotoCustomMetadata_URI);
    v30 = gFunc_CMPhotoCompressionSessionAddCustomMetadata(*((_QWORD *)this + 7), a3, v41, v44);
    v10 = v30;
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("    CMPhotoCompressionSessionAddCustomMetadata: [session:%p]  img:%d  err=%d\n", *((const void **)this + 7), a3, v30);
    if ((_DWORD)v10)
    {
      v31 = IIOCMErrorString(v10);
      _cg_jpeg_mem_term("writeAuxImages", 1318, "*** CMPhotoCompressionSessionAddCustomMetadata  err = %s [%d]\n", v31, v10);
      v32 = 5;
    }
    else
    {
      v32 = 0;
    }
    IIODictionary::~IIODictionary((IIODictionary *)&v40);
    IIODictionary::~IIODictionary((IIODictionary *)&v43);
    if ((_DWORD)v10)
    {
      IIODictionary::~IIODictionary((IIODictionary *)&v47);
      IIODictionary::~IIODictionary((IIODictionary *)v50);
      if ((v32 | 4) != 4)
        goto LABEL_47;
      goto LABEL_37;
    }
LABEL_36:
    IIODictionary::~IIODictionary((IIODictionary *)&v47);
    IIODictionary::~IIODictionary((IIODictionary *)v50);
LABEL_37:
    if (v11 == ++v9)
      goto LABEL_47;
  }
  v43 = 0;
  v44 = 0;
  v45 = 0;
  v33 = IIODictionary::IIODictionary((IIODictionary *)&v43, v28);
  PixelBufferFromAuxiliaryDataInfo = HEIFWritePlugin::createPixelBufferFromAuxiliaryDataInfo(v33, (IIODictionary *)&v43, v34);
  v36 = IIODictionary::getObjectForKey((IIODictionary *)&v43, CFSTR("kCGImageAuxiliaryDataInfoMetadata"));
  v37 = gFunc_CMPhotoCompressionSessionAddAuxiliaryImage(*((_QWORD *)this + 7), a3, Uint32ForKey, v36, v48, PixelBufferFromAuxiliaryDataInfo, &v46);
  v10 = v37;
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("    CMPhotoCompressionSessionAddAuxiliaryImage: [session:%p]  img:%d  err=%d\n", *((const void **)this + 7), a3, v37);
  if (!(_DWORD)v10)
  {
    IIODictionary::~IIODictionary((IIODictionary *)&v43);
    goto LABEL_36;
  }
  v38 = IIOCMErrorString(v10);
  _cg_jpeg_mem_term("writeAuxImages", 1333, "*** Error: CMPhotoCompressionSessionAddAuxiliaryImage  err = %s [%d]\n", v38, v10);
  IIODictionary::~IIODictionary((IIODictionary *)&v43);
  IIODictionary::~IIODictionary((IIODictionary *)&v47);
  IIODictionary::~IIODictionary((IIODictionary *)v50);
LABEL_47:
  IIOArray::~IIOArray((IIOArray *)v51);
  return v10;
}

void sub_187FD4E08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  uint64_t v29;

  IIODictionary::~IIODictionary((IIODictionary *)&a29);
  IIODictionary::~IIODictionary((IIODictionary *)(v29 - 160));
  IIODictionary::~IIODictionary((IIODictionary *)(v29 - 136));
  IIOArray::~IIOArray((IIOArray *)(v29 - 112));
  _Unwind_Resume(a1);
}

uint64_t HEIFWritePlugin::writeAlternateImage(HEIFWritePlugin *this, int a2, uint64_t a3)
{
  const __CFArray *v4;
  IIOArray *v5;
  unsigned int Count;
  CFIndex v7;
  uint64_t v8;
  const __CFDictionary *ObjectAtIndex;
  IIODictionary *v10;
  const __CFString *ObjectForKey;
  const __CFDictionary *v12;
  IIODictionary *v13;
  IIODictionary *v14;
  HEIFWritePlugin *v15;
  IIODictionary *v16;
  const __CFDictionary *PixelBufferFromAuxiliaryDataInfo;
  int v18;
  CGColorSpaceRef v19;
  CGColorSpace *v20;
  const __CFDictionary *v21;
  uint64_t v22;
  int v23;
  int v24;
  const char *v25;
  int v26;
  const __CFString *name;
  void *value;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  _BYTE v36[24];
  uint64_t v37;
  void *v38;
  uint64_t v39;
  _BYTE v40[24];
  _BYTE v41[24];
  CFTypeRef cf;
  uint64_t v43;
  uint64_t v44;
  _QWORD v45[3];
  _QWORD v46[3];
  _QWORD v47[3];
  _QWORD v48[4];

  v4 = (const __CFArray *)*((_QWORD *)this + 6);
  if (v4)
  {
    memset(v48, 0, 24);
    v5 = IIOArray::IIOArray((IIOArray *)v48, v4);
    Count = IIOArray::getCount(v5);
    if (Count)
    {
      v7 = 0;
      value = (void *)*MEMORY[0x1E0C9AE40];
      name = (const __CFString *)*MEMORY[0x1E0C9D9C8];
      v8 = Count;
      do
      {
        ObjectAtIndex = IIOArray::getObjectAtIndex((IIOArray *)v48, v7);
        memset(v47, 0, sizeof(v47));
        v10 = IIODictionary::IIODictionary((IIODictionary *)v47, ObjectAtIndex);
        ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey(v10, "AuxiliaryImageURN");
        memset(v46, 0, sizeof(v46));
        IIODictionary::IIODictionary((IIODictionary *)v46);
        if (IIODictionary::getUint32ForKey((IIODictionary *)v47, CFSTR("ImageIndex")) == a2
          && ObjectForKey
          && CFStringCompare(CFSTR("kCGImageAuxiliaryDataTypeISOGainMap"), ObjectForKey, 0) == kCFCompareEqualTo)
        {
          v12 = IIODictionary::getObjectForKey((IIODictionary *)v47, CFSTR("kCGImageAuxiliaryDataTypeISOGainMap"));
          memset(v45, 0, sizeof(v45));
          v13 = IIODictionary::IIODictionary((IIODictionary *)v45, v12);
          v14 = IIODictionary::getObjectForKey(v13, CFSTR("kCGImageAuxiliaryDataInfoMetadata"));
          v15 = IIODictionary::getObjectForKey((IIODictionary *)v45, CFSTR("kCGImageAuxiliaryDataInfoColorSpace"));
          PixelBufferFromAuxiliaryDataInfo = HEIFWritePlugin::createPixelBufferFromAuxiliaryDataInfo(v15, (IIODictionary *)v45, v16);
          if (v14)
          {
            cf = 0;
            if (CGImageCreateFlexRangeDictionary((uint64_t)v14, &cf))
            {
              v14 = 0;
            }
            else
            {
              v14 = (IIODictionary *)operator new();
              IIODictionary::IIODictionary(v14, (const __CFDictionary *)cf);
              CFRelease(cf);
            }
          }
          v18 = *((_DWORD *)this + 10);
          cf = 0;
          v43 = 0;
          v44 = 0;
          IIODictionary::IIODictionary((IIODictionary *)&cf);
          IIODictionary::setObjectForKey((IIODictionary *)&cf, value, *(const __CFString **)gIIO_kCMPhotoCompressionOption_ApplyTransform);
          IIONumber::IIONumber((IIONumber *)v41, v18);
          IIODictionary::setObjectForKey((uint64_t)&cf, (uint64_t)v41, *(const void **)gIIO_kCMPhotoCompressionOption_CodecType);
          IIONumber::~IIONumber((IIONumber *)v41);
          IIONumber::IIONumber((IIONumber *)v40, 3);
          IIODictionary::setObjectForKey((uint64_t)&cf, (uint64_t)v40, *(const void **)gIIO_kCMPhotoCompressionOption_QualityControllerType);
          IIONumber::~IIONumber((IIONumber *)v40);
          v37 = 0;
          v38 = 0;
          v39 = 0;
          IIODictionary::IIODictionary((IIODictionary *)&v37);
          IIONumber::IIONumber((IIONumber *)v36, 0.9);
          IIODictionary::setObjectForKey((uint64_t)&v37, (uint64_t)v36, *(const void **)gIIO_kCMPhotoQualityControllerParameter_QualityValue);
          IIONumber::~IIONumber((IIONumber *)v36);
          IIODictionary::setObjectForKey((IIODictionary *)&cf, v38, *(const __CFString **)gIIO_kCMPhotoCompressionOption_QualityControllerParameters);
          v33 = 0;
          v34 = 0;
          v35 = 0;
          IIODictionary::IIODictionary((IIODictionary *)&v33);
          if (v15)
            v19 = CGColorSpaceRetain(v15);
          else
            v19 = CGColorSpaceCreateWithName(name);
          v20 = v19;
          IIODictionary::setObjectForKey((IIODictionary *)&v33, v19, *(const __CFString **)gIIO_kCMPhotoCompressionOption_ColorSpace);
          v21 = IIODictionary::getObjectForKey((IIODictionary *)v45, CFSTR("kCGImageAuxiliaryDataInfoMeteorPlusMetadata"));
          v32 = 0;
          if (v14)
            v22 = *((_QWORD *)v14 + 1);
          else
            v22 = 0;
          v23 = gFunc_CMPhotoCompressionSessionAddTmapImageOneShot(*((_QWORD *)this + 7), a3, v43, v34, PixelBufferFromAuxiliaryDataInfo, v22, v21 != 0, v21, &v32);
          v24 = v23;
          if (v23)
          {
            v25 = IIOCMErrorString(v23);
            _cg_jpeg_mem_term("writeAlternateImage", 1425, "*** Error: CMPhotoCompressionSessionAddTmapImageOneShot  err = %s [%d]\n", v25, v24);
            v26 = 5;
          }
          else
          {
            if (v14)
              (*(void (**)(IIODictionary *))(*(_QWORD *)v14 + 8))(v14);
            if (PixelBufferFromAuxiliaryDataInfo)
              CFRelease(PixelBufferFromAuxiliaryDataInfo);
            v26 = 0;
          }
          CGColorSpaceRelease(v20);
          IIODictionary::~IIODictionary((IIODictionary *)&v33);
          IIODictionary::~IIODictionary((IIODictionary *)&v37);
          IIODictionary::~IIODictionary((IIODictionary *)&cf);
          IIODictionary::~IIODictionary((IIODictionary *)v45);
          IIODictionary::~IIODictionary((IIODictionary *)v46);
          IIODictionary::~IIODictionary((IIODictionary *)v47);
          if ((v26 | 4) != 4)
            break;
        }
        else
        {
          IIODictionary::~IIODictionary((IIODictionary *)v46);
          IIODictionary::~IIODictionary((IIODictionary *)v47);
        }
        ++v7;
      }
      while (v8 != v7);
    }
    IIOArray::~IIOArray((IIOArray *)v48);
  }
  return 0;
}

void sub_187FD52CC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  MEMORY[0x18D761C30](v1, 0x10A1C4047070A01);
  IIODictionary::~IIODictionary((IIODictionary *)(v2 - 200));
  IIODictionary::~IIODictionary((IIODictionary *)(v2 - 176));
  IIODictionary::~IIODictionary((IIODictionary *)(v2 - 152));
  IIOArray::~IIOArray((IIOArray *)(v2 - 128));
  _Unwind_Resume(a1);
}

const __CFDictionary *HEIFWritePlugin::createPixelBufferFromAuxiliaryDataInfo(HEIFWritePlugin *this, IIODictionary *a2, IIODictionary *a3)
{
  const __CFDictionary *ObjectForKey;
  const __CFDictionary *v5;
  const __CFDictionary *v6;
  const __CFDictionary *v7;
  const __CFDictionary *v8;
  int v9;
  BOOL v11;
  unsigned int Uint32ForKey;
  unsigned int v13;
  unsigned int v14;
  const __CFDictionary *v15;
  const UInt8 *BytePtr;
  int v17;
  int v18;
  const char *v19;
  _QWORD v20[3];
  const __CFDictionary *v21;

  ObjectForKey = IIODictionary::getObjectForKey(a2, CFSTR("kCGImageAuxiliaryDataInfoData"));
  v5 = IIODictionary::getObjectForKey(a2, CFSTR("kCGImageAuxiliaryDataInfoDataDescription"));
  v6 = IIODictionary::getObjectForKey(a2, CFSTR("kCGImageAuxiliaryDataInfoImage"));
  v7 = IIODictionary::getObjectForKey(a2, CFSTR("kCGImageAuxiliaryDataInfoPixelBuffer"));
  v8 = IIODictionary::getObjectForKey(a2, CFSTR("kCGImageAuxiliaryDataInfoIOSurface"));
  v21 = 0;
  if (v7)
  {
    v21 = v7;
    CFRetain(v7);
  }
  else if (v8)
  {
    v9 = gFunc_CVPixelBufferCreateWithIOSurface(0, v8, 0, &v21);
    if (v9)
    {
      IIOCMErrorString(v9);
      LogError("createPixelBufferFromAuxiliaryDataInfo", 1464, "*** Error: CVPixelBufferCreateWithIOSurface  err = %s [%d]\n");
    }
  }
  else if (v6)
  {
    LogError("createPixelBufferFromAuxiliaryDataInfo", 1470, "*** Not supported yet");
  }
  else
  {
    if (ObjectForKey)
      v11 = v5 == 0;
    else
      v11 = 1;
    if (!v11)
    {
      memset(v20, 0, sizeof(v20));
      IIODictionary::IIODictionary((IIODictionary *)v20, v5);
      Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v20, CFSTR("Width"));
      v13 = IIODictionary::getUint32ForKey((IIODictionary *)v20, CFSTR("Height"));
      v14 = IIODictionary::getUint32ForKey((IIODictionary *)v20, CFSTR("BytesPerRow"));
      v15 = IIODictionary::getUint32ForKey((IIODictionary *)v20, CFSTR("PixelFormat"));
      BytePtr = CFDataGetBytePtr(ObjectForKey);
      v17 = gFunc_CVPixelBufferCreateWithBytes(*MEMORY[0x1E0C9AE00], Uint32ForKey, v13, v15, BytePtr, v14, 0, 0, 0, &v21);
      v18 = v17;
      if (v17)
      {
        v19 = IIOCMErrorString(v17);
        LogError("createPixelBufferFromAuxiliaryDataInfo", 1486, "*** Error: CVPixelBufferCreateWithBytes  err = %s [%d]\n", v19, v18);
      }
      IIODictionary::~IIODictionary((IIODictionary *)v20);
    }
  }
  return v21;
}

void sub_187FD560C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t HEIFWritePlugin::completeHEIFWriting(HEIFWritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3)
{
  uint64_t *i;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int *j;
  int v11;
  __n128 v12;
  int v13;
  const char *v14;
  const UInt8 *BytePtr;
  size_t Length;
  uint64_t v17;
  __n128 v18;
  uint64_t v19;
  const char *v20;
  _QWORD v22[2];
  uint64_t (*v23)(uint64_t, unsigned int);
  void *v24;
  HEIFWritePlugin *v25;
  uint64_t v26;
  _DWORD v27[4];
  void *value;
  _BYTE v29[24];
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  CFTypeRef v34[2];

  v34[0] = 0;
  if (*((_BYTE *)this + 125))
  {
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("seq CMPhotoCompressionSessionEndImageSequence:   [session:%p]  seq:%d\n", *((const void **)this + 7), *((_DWORD *)this + 16));
    gFunc_CMPhotoCompressionSessionEndImageSequence(*((_QWORD *)this + 7), *((int *)this + 16), 0);
  }
  v5 = (uint64_t *)*((_QWORD *)this + 12);
  for (i = (uint64_t *)*((_QWORD *)this + 13); v5 != i; ++v5)
  {
    v33 = -1;
    v6 = *(unsigned int *)(*v5 + 16);
    v30 = 0;
    v31 = 0;
    v32 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v30);
    gFunc_CMPhotoCompressionSessionAddGroup(*((_QWORD *)this + 7), 0, v6, &v33);
    if ((_DWORD)v6 == 1937007986)
    {
      gFunc_CMPhotoCompressionSessionAddImageHandleToGroup(*((_QWORD *)this + 7), 0, *(int *)(*v5 + 20), v33);
      gFunc_CMPhotoCompressionSessionAddImageHandleToGroup(*((_QWORD *)this + 7), 0, *(int *)(*v5 + 24), v33);
      v7 = *v5;
      v8 = *(unsigned int *)(*v5 + 28);
      if ((v8 & 0x80000000) == 0)
      {
        gFunc_CMPhotoCompressionSessionAddImageHandleToGroup(*((_QWORD *)this + 7), 0, v8, v33);
        IIONumber::IIONumber((IIONumber *)v29, *(_DWORD *)(*v5 + 32));
        IIODictionary::setObjectForKey((uint64_t)&v30, (uint64_t)v29, *(const void **)gIIO_kCMPhotoCompressionContainerDescription_GroupProperty_MonoImageLocation);
        IIONumber::~IIONumber((IIONumber *)v29);
        v7 = *v5;
      }
      IIONumber::IIONumber((IIONumber *)v27, *(_DWORD *)(v7 + 40));
      IIODictionary::setObjectForKey((IIODictionary *)&v30, value, *(const __CFString **)gIIO_kCMPhotoCompressionContainerDescription_GroupProperty_DisparityAdjustment);
      IIONumber::~IIONumber((IIONumber *)v27);
    }
    else
    {
      v9 = *v5;
      v22[0] = MEMORY[0x1E0C809B0];
      v22[1] = 0x40000000;
      v23 = ___ZN15HEIFWritePlugin19completeHEIFWritingEP25IIOImagePixelDataProviderP13IIODictionary_block_invoke;
      v24 = &__block_descriptor_tmp_18;
      v25 = this;
      v26 = v33;
      for (j = *(unsigned int **)(v9 + 48); j != *(unsigned int **)(v9 + 56); ++j)
        v23((uint64_t)v22, *j);
    }
    if (gFunc_CMPhotoCompressionSessionAddGroupProperties)
      ((void (*)(_QWORD, _QWORD, uint64_t, uint64_t))gFunc_CMPhotoCompressionSessionAddGroupProperties)(*((_QWORD *)this + 7), 0, v33, v31);
    IIODictionary::~IIODictionary((IIODictionary *)&v30);
  }
  v30 = 0;
  v27[0] = 0;
  v11 = gFunc_CMPhotoCompressionSessionCloseContainerAndCopyBacking(*((_QWORD *)this + 7), v27, &v30, v34);
  v13 = v11;
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("    CMPhotoCompressionSessionCloseContainerAndCopyBacking: [session:%p]  err=%d\n", *((const void **)this + 7), v11);
  if (v13)
  {
    v14 = IIOCMErrorString(v13);
    v12 = _cg_jpeg_mem_term("completeHEIFWriting", 1618, "*** CMPhotoCompressionSessionCloseContainerAndCopyBacking  err = %s [%d]\n", v14, v13);
  }
  else if (v27[0] == 1)
  {
    BytePtr = CFDataGetBytePtr((CFDataRef)v34[0]);
    Length = CFDataGetLength((CFDataRef)v34[0]);
    IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), BytePtr, Length);
  }
  v17 = gFunc_CMPhotoCompressionSessionInvalidate(*((_QWORD *)this + 7), v12);
  v19 = v17;
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("    CMPhotoCompressionSessionInvalidate: [session:%p]  err=%d\n", *((const void **)this + 7), v17);
  if ((_DWORD)v19)
  {
    v20 = IIOCMErrorString(v19);
    v18 = _cg_jpeg_mem_term("completeHEIFWriting", 1642, "*** CMPhotoCompressionSessionInvalidate  err = %s [%d]\n", v20, v19);
  }
  if (v34[0])
    CFRelease(v34[0]);
  if (*((_QWORD *)this + 7))
  {
    gFunc_CMPhotoCompressionSessionReleaseHardwareResources(v18);
    CFRelease(*((CFTypeRef *)this + 7));
    *((_QWORD *)this + 7) = 0;
  }
  return v19;
}

void sub_187FD59E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  uint64_t v13;
  va_list va;
  uint64_t v15;
  uint64_t v16;
  va_list va1;

  va_start(va1, a12);
  va_start(va, a12);
  v13 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  _Unwind_Resume(a1);
}

uint64_t ___ZN15HEIFWritePlugin19completeHEIFWritingEP25IIOImagePixelDataProviderP13IIODictionary_block_invoke(uint64_t a1, unsigned int a2)
{
  return gFunc_CMPhotoCompressionSessionAddImageHandleToGroup(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 56), 0, a2, *(_QWORD *)(a1 + 40));
}

uint64_t HEIFWritePlugin::writeAll(IIOImageDestination **this)
{
  unsigned int ImageCount;
  unint64_t v3;
  uint64_t v4;
  uint64_t PixelDataProviderAtIndex;
  IIODictionary *PropertiesAtIndex;
  IIODictionary *ContainerProperties;
  IIODictionary *v8;
  unsigned int Uint32ForKey;
  uint64_t SourceImageAtIndex;
  uint64_t result;
  IIOImagePixelDataProvider *v12;
  IIODictionary *v13;
  int Uint32ForKeyGroup;
  const __CFString *ObjectForKeyGroup;
  const __CFString *v16;
  int v17;
  uint64_t v18;
  _DWORD *v19;
  unsigned int v20;
  unsigned int v21;
  const __CFString *v22;
  const __CFString *v23;
  int v24;
  int v25[2];

  ImageCount = IIOWritePlugin::getImageCount(this);
  if (ImageCount)
  {
    v3 = 0;
    v4 = ImageCount;
    while (1)
    {
      PixelDataProviderAtIndex = IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, v3);
      PropertiesAtIndex = (IIODictionary *)IIOWritePlugin::getPropertiesAtIndex(this, v3);
      ContainerProperties = (IIODictionary *)IIOWritePlugin::getContainerProperties(this);
      v8 = ContainerProperties;
      if (ContainerProperties)
      {
        Uint32ForKey = IIODictionary::getUint32ForKey(ContainerProperties, CFSTR("capacity"));
        if (!PixelDataProviderAtIndex)
          goto LABEL_7;
      }
      else
      {
        Uint32ForKey = 1;
        if (!PixelDataProviderAtIndex)
        {
LABEL_7:
          SourceImageAtIndex = IIOWritePlugin::getSourceImageAtIndex(this, v3);
          goto LABEL_8;
        }
      }
      SourceImageAtIndex = 0;
LABEL_8:
      *(_QWORD *)v25 = 0;
      result = (*((uint64_t (**)(IIOImageDestination **, uint64_t, uint64_t, IIODictionary *, IIODictionary *, unint64_t, int *))*this
                + 5))(this, PixelDataProviderAtIndex, SourceImageAtIndex, PropertiesAtIndex, v8, v3, v25);
      if ((_DWORD)result)
        return result;
      if (IIODictionary::containsKey(PropertiesAtIndex, CFSTR("{Groups}")))
      {
        Uint32ForKeyGroup = IIODictionary::getUint32ForKeyGroup(PropertiesAtIndex, CFSTR("GroupIndex"), CFSTR("{Groups}"));
        ObjectForKeyGroup = (const __CFString *)IIODictionary::getObjectForKeyGroup(PropertiesAtIndex, CFSTR("GroupType"), CFSTR("{Groups}"));
        if (ObjectForKeyGroup)
        {
          v16 = ObjectForKeyGroup;
          if (CFStringCompare(ObjectForKeyGroup, CFSTR("StereoPair"), 0))
          {
            CFStringCompare(v16, CFSTR("Alternate"), 0);
          }
          else
          {
            if ((IIODictionary::getBoolForKeyGroup(PropertiesAtIndex, CFSTR("GroupImageIsLeftImage"), CFSTR("{Groups}")) & 1) != 0)
            {
              v17 = 0;
            }
            else if ((IIODictionary::getBoolForKeyGroup(PropertiesAtIndex, CFSTR("GroupImageIsRightImage"), CFSTR("{Groups}")) & 1) != 0)
            {
              v17 = 1;
            }
            else if (IIODictionary::getBoolForKeyGroup(PropertiesAtIndex, CFSTR("GroupImageIsMonoscopicImage"), CFSTR("{Groups}")))
            {
              v17 = 2;
            }
            else
            {
              v17 = v3;
            }
            v18 = HEIFWritePlugin::addGroupItem((uint64_t)this, Uint32ForKeyGroup, 1937007986, v25[0], v17);
            if (v18)
            {
              v19 = (_DWORD *)v18;
              v20 = IIODictionary::getUint32ForKeyGroup(PropertiesAtIndex, CFSTR("GroupImageBaseline"), CFSTR("{Groups}"));
              v21 = IIODictionary::getUint32ForKeyGroup(PropertiesAtIndex, CFSTR("GroupImageDisparityAdjustment"), CFSTR("{Groups}"));
              if (v20)
                v19[9] = v20;
              if (v21)
                v19[10] = v21;
              v22 = (const __CFString *)IIODictionary::getObjectForKeyGroup(PropertiesAtIndex, CFSTR("GroupImageIndexMonoscopicImageLocation"), CFSTR("{Groups}"));
              if (v22)
              {
                v23 = v22;
                if (CFStringCompare(v22, CFSTR("Left"), 0))
                {
                  if (CFStringCompare(v23, CFSTR("Right"), 0))
                  {
                    if (CFStringCompare(v23, CFSTR("Center"), 0))
                      v24 = 0;
                    else
                      v24 = 3;
                  }
                  else
                  {
                    v24 = 2;
                  }
                }
                else
                {
                  v24 = 1;
                }
                v19[8] = v24;
              }
            }
          }
        }
      }
      if (v3 == Uint32ForKey - 1)
        HEIFWritePlugin::completeHEIFWriting((HEIFWritePlugin *)this, v12, v13);
      if (v4 == ++v3)
        return 0;
    }
  }
  return 4294967246;
}

uint64_t HEIFWritePlugin::addGroupItem(uint64_t a1, int a2, int a3, int a4, int a5)
{
  uint64_t *v10;
  char **v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  uint64_t *v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  char *v25;
  uint64_t v26;
  int v27;

  v10 = *(uint64_t **)(a1 + 96);
  v11 = (char **)(a1 + 96);
  while (v10 != *(uint64_t **)(a1 + 104))
  {
    v12 = *v10;
    if (*(_DWORD *)(*v10 + 8) == a2)
      goto LABEL_22;
    ++v10;
  }
  v12 = operator new();
  v13 = *(_QWORD *)(a1 + 112);
  v14 = *(_DWORD *)(a1 + 120);
  *(_QWORD *)v12 = &off_1E1BB2F40;
  *(_QWORD *)(v12 + 56) = 0;
  *(_QWORD *)(v12 + 64) = 0;
  *(_QWORD *)(v12 + 48) = 0;
  *(_DWORD *)(v12 + 12) = v14;
  *(_DWORD *)(v12 + 16) = a3;
  *(_DWORD *)(v12 + 8) = a2;
  *(_QWORD *)(v12 + 20) = -1;
  *(_DWORD *)(v12 + 28) = -1;
  *(_DWORD *)(v12 + 36) = 0;
  *(_DWORD *)(v12 + 40) = 0;
  *(_DWORD *)(a1 + 120) = v14 + 1;
  v15 = *(uint64_t **)(a1 + 104);
  if ((unint64_t)v15 >= v13)
  {
    v17 = ((char *)v15 - *v11) >> 3;
    if ((unint64_t)(v17 + 1) >> 61)
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    v18 = v13 - (_QWORD)*v11;
    v19 = v18 >> 2;
    if (v18 >> 2 <= (unint64_t)(v17 + 1))
      v19 = v17 + 1;
    if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8)
      v20 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v20 = v19;
    if (v20)
      v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>(a1 + 112, v20);
    else
      v21 = 0;
    v22 = (uint64_t *)&v21[8 * v17];
    v23 = &v21[8 * v20];
    *v22 = v12;
    v16 = v22 + 1;
    v25 = *(char **)(a1 + 96);
    v24 = *(char **)(a1 + 104);
    if (v24 != v25)
    {
      do
      {
        v26 = *((_QWORD *)v24 - 1);
        v24 -= 8;
        *--v22 = v26;
      }
      while (v24 != v25);
      v24 = *v11;
    }
    *(_QWORD *)(a1 + 96) = v22;
    *(_QWORD *)(a1 + 104) = v16;
    *(_QWORD *)(a1 + 112) = v23;
    if (v24)
      operator delete(v24);
  }
  else
  {
    *v15 = v12;
    v16 = v15 + 1;
  }
  *(_QWORD *)(a1 + 104) = v16;
LABEL_22:
  if (a3 == 1634497650)
  {
    v27 = HEIFGroup::setOtherImage((HEIFGroup *)v12, a4);
  }
  else
  {
    if (a3 != 1937007986)
      return v12;
    if (a5 == 2)
    {
      v27 = HEIFGroup::setMonoImage((HEIFGroup *)v12, a4);
    }
    else if (a5 == 1)
    {
      v27 = HEIFGroup::setRightImage((HEIFGroup *)v12, a4);
    }
    else
    {
      if (a5)
        return v12;
      v27 = HEIFGroup::setLeftImage((HEIFGroup *)v12, a4);
    }
  }
  if (v27)
    *(_DWORD *)(v12 + 12) = -1;
  return v12;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(4 * a2);
}

uint64_t TIFFInitPackBits(_QWORD *a1)
{
  a1[126] = PackBitsDecode;
  a1[128] = PackBitsDecode;
  a1[130] = PackBitsDecode;
  a1[124] = PackBitsPreEncode;
  a1[125] = PackBitsPostEncode;
  a1[127] = PackBitsEncode;
  a1[129] = PackBitsEncodeChunk;
  a1[131] = PackBitsEncodeChunk;
  return 1;
}

uint64_t PackBitsDecode(uint64_t a1, char *__b, int64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned __int8 *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  size_t v17;
  unsigned __int8 *v18;
  int v19;
  int64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v27;
  char v28;

  v11 = *(unsigned __int8 **)(a1 + 1152);
  v12 = *(_QWORD *)(a1 + 1160);
LABEL_2:
  v13 = 0;
  v14 = v12;
  while (1)
  {
    v15 = v13;
    if (v14 < 1 || a3 < 1)
      break;
    v16 = (char)v11[v13];
    if ((v16 & 0x8000000000000000) == 0)
    {
      v20 = v11[v13];
      if (v16 >= a3)
      {
        TIFFWarningExtR(a1, "PackBitsDecode", "Discarding %lld bytes to avoid buffer overrun", a4, a5, a6, a7, a8, v16 - a3 + 1);
        v20 = a3 - 1;
      }
      v17 = v20 + 1;
      if (v14 > v20 + 1)
      {
        _TIFFmemcpy(__b, &v11[v15 + 1], v20 + 1);
        v11 += v20 + v15 + 2;
        v12 = v12 - v20 - v15 - 2;
        goto LABEL_15;
      }
      v27 = ~v15 + v12;
LABEL_21:
      TIFFWarningExtR(a1, "PackBitsDecode", "Terminating PackBitsDecode due to lack of data.", a4, a5, a6, a7, a8, v28);
      *(_QWORD *)(a1 + 1152) = &v11[v15 + 1];
      *(_QWORD *)(a1 + 1160) = v27;
LABEL_17:
      bzero(__b, a3);
      TIFFErrorExtR(a1, "PackBitsDecode", "Not enough data for scanline %u", v21, v22, v23, v24, v25, *(_DWORD *)(a1 + 876));
      return 0;
    }
    ++v13;
    --v14;
    if ((_DWORD)v16 != -128)
    {
      v17 = 1 - v16;
      if (1 - v16 > (unint64_t)a3)
      {
        TIFFWarningExtR(a1, "PackBitsDecode", "Discarding %lld bytes to avoid buffer overrun", a4, a5, a6, a7, a8, 1 - v16 - a3);
        v17 = a3;
      }
      if (v12 != v13)
      {
        v18 = &v11[v13];
        v19 = *v18;
        v11 = v18 + 1;
        v12 += ~v13;
        memset(__b, v19, v17);
LABEL_15:
        __b += v17;
        a3 -= v17;
        goto LABEL_2;
      }
      v27 = 0;
      goto LABEL_21;
    }
  }
  *(_QWORD *)(a1 + 1152) = &v11[v13];
  *(_QWORD *)(a1 + 1160) = v14;
  if (a3 >= 1)
    goto LABEL_17;
  return 1;
}

uint64_t PackBitsPreEncode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  result = (uint64_t)_TIFFmallocExt((_QWORD *)a1, 8, a3, a4, a5, a6, a7, a8);
  *(_QWORD *)(a1 + 1096) = result;
  if (result)
  {
    if ((*(_BYTE *)(a1 + 17) & 4) != 0)
      v17 = _cg_TIFFTileRowSize(a1, v10, v11, v12, v13, v14, v15, v16);
    else
      v17 = _cg_TIFFScanlineSize(a1, v10, v11, v12, v13, v14, v15, v16);
    **(_QWORD **)(a1 + 1096) = v17;
    return 1;
  }
  return result;
}

uint64_t PackBitsPostEncode(uint64_t a1)
{
  char *v1;

  v1 = *(char **)(a1 + 1096);
  if (v1)
    _TIFFfreeExt(a1, v1);
  return 1;
}

uint64_t PackBitsEncode(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char *v9;
  uint64_t v10;
  unsigned __int8 *v11;
  int v12;
  char *v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t result;
  uint64_t v20;
  unint64_t v21;
  char v22;
  unsigned int v23;
  unsigned int v24;
  char *v25;
  uint64_t v26;
  int v27;
  uint64_t v28;

  v9 = (char *)a1[144];
  if (a3 < 1)
  {
    v28 = a1[144];
    goto LABEL_44;
  }
  v10 = a3;
  v11 = (unsigned __int8 *)a2;
  v12 = 0;
  v13 = 0;
  v14 = a1[140] + a1[141];
  do
  {
    v15 = *v11;
    if ((unint64_t)v10 < 2)
    {
      v10 = 0;
      v17 = 1;
      ++v11;
    }
    else
    {
      v16 = v10 - 1;
      v17 = 1;
      while (v15 == v11[v17])
      {
        ++v17;
        if (!--v16)
        {
          v17 = v10;
          v11 += v10;
          v10 = 0;
          goto LABEL_10;
        }
      }
      v11 += v17;
      v10 = v16;
    }
    while (1)
    {
      while (1)
      {
LABEL_10:
        if ((unint64_t)(v9 + 2) >= v14)
        {
          v18 = a1[145];
          if ((v12 & 0xFFFFFFFD) == 1)
          {
            a1[145] = &v13[v18 - a1[144]];
            result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
            if (!(_DWORD)result)
              return result;
            v20 = v9 - v13;
            v9 = (char *)a1[144];
            if (v20 < 1)
            {
              v13 = (char *)a1[144];
            }
            else
            {
              v21 = v20 + 1;
              do
              {
                v22 = *v13++;
                *v9++ = v22;
                --v21;
              }
              while (v21 > 1);
              v13 = (char *)a1[144];
            }
          }
          else
          {
            a1[145] = &v9[v18 - a1[144]];
            result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
            if (!(_DWORD)result)
              return result;
            v9 = (char *)a1[144];
          }
        }
        if (v12 != 3)
          break;
        v12 = 2;
        if (v17 == 1 && *(v9 - 2) == 255)
        {
          v23 = *v13;
          if (v23 <= 0x7D)
          {
            v24 = v23 + 2;
            *v13 = v24;
            v12 = v24 != 127;
            *(v9 - 2) = *(v9 - 1);
          }
        }
      }
      if (v12 == 2)
      {
        if (v17 < 2)
        {
LABEL_37:
          *v9 = 0;
          v25 = v9 + 1;
          v12 = 1;
          v26 = 2;
          v13 = v9;
          goto LABEL_41;
        }
        if ((unint64_t)v17 < 0x81)
        {
LABEL_38:
          *v9 = 1 - v17;
          v25 = v9 + 1;
          v26 = 2;
          v12 = 2;
          goto LABEL_41;
        }
        goto LABEL_32;
      }
      if (v12 != 1)
      {
        if (v17 < 2)
          goto LABEL_37;
        if ((unint64_t)v17 <= 0x80)
          goto LABEL_38;
LABEL_32:
        v12 = 2;
        goto LABEL_36;
      }
      if (v17 < 2)
      {
        v27 = (*v13)++ + 1;
        v12 = v27 != 127;
        v26 = 1;
        v25 = v9;
        goto LABEL_41;
      }
      if ((unint64_t)v17 <= 0x80)
        break;
      v12 = 3;
LABEL_36:
      *v9 = -127;
      v9[1] = v15;
      v9 += 2;
      v17 -= 128;
    }
    *v9 = 1 - v17;
    v25 = v9 + 1;
    v12 = 3;
    v26 = 2;
LABEL_41:
    v9 += v26;
    *v25 = v15;
  }
  while (v10 > 0);
  v28 = a1[144];
LABEL_44:
  a1[145] += &v9[-v28];
  a1[144] = v9;
  return 1;
}

uint64_t PackBitsEncodeChunk(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;

  if (a3 >= 1)
  {
    v8 = a3;
    v11 = **(_QWORD **)(a1 + 1096);
    do
    {
      if (v8 >= v11)
        v12 = v11;
      else
        v12 = v8;
      PackBitsEncode((_QWORD *)a1, a2, v12, 0, a5, a6, a7, a8);
      a2 += v12;
      v13 = v8 <= v12;
      v8 -= v12;
    }
    while (!v13);
  }
  return 1;
}

uint64_t LibJPEGReadPlugin::LibJPEGReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, char a6, int a7, uint64_t a8, int a9)
{
  _QWORD *v10;

  JPEGReadPlugin::JPEGReadPlugin(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  *v10 = &off_1E1BB1110;
  bzero(v10 + 63, 0x23C8uLL);
  return a1;
}

uint64_t LibJPEGReadPlugin::LibJPEGReadPlugin(uint64_t a1, uint64_t a2, int a3)
{
  _QWORD *v4;

  JPEGReadPlugin::JPEGReadPlugin(a1, a2, a3);
  *v4 = &off_1E1BB1110;
  bzero(v4 + 63, 0x23C8uLL);
  return a1;
}

void LibJPEGReadPlugin::~LibJPEGReadPlugin(LibJPEGReadPlugin *this)
{
  *(_QWORD *)this = &off_1E1BB1110;
  _cg_jpeg_destroy_decompress((char *)this + 504);
  if (*((_QWORD *)this + 153))
    *((_QWORD *)this + 153) = 0;
  JPEGReadPlugin::~JPEGReadPlugin(this);
}

{
  LibJPEGReadPlugin::~LibJPEGReadPlugin(this);
  JUMPOUT(0x18D761C30);
}

uint64_t LibJPEGReadPlugin::loadDataFromXPCObject(LibJPEGReadPlugin *this, void *a2)
{
  uint64_t result;
  const void *data;
  uint64_t v6;
  size_t length;

  result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!(_DWORD)result)
  {
    length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_libjpeg", &length);
    if (length == 9160)
    {
      memcpy((char *)this + 504, data, 0x23C8uLL);
      v6 = _cg_jpeg_std_error((uint64_t)this + 9272);
      result = 0;
      *((_QWORD *)this + 68) = (char *)this + 1168;
      *((_QWORD *)this + 1159) = errorExit;
      *((_QWORD *)this + 1161) = outputMessage;
      *((_QWORD *)this + 149) = fill_input_buffer;
      *((_QWORD *)this + 148) = init_source;
      *((_QWORD *)this + 146) = (char *)this + 1264;
      *((_QWORD *)this + 151) = _cg_jpeg_resync_to_restart;
      *((_QWORD *)this + 150) = skip_input_data;
      *((_QWORD *)this + 152) = term_source;
      *((_QWORD *)this + 153) = *((_QWORD *)this + 3);
      *((_QWORD *)this + 155) = *((_QWORD *)this + 24);
      *((_QWORD *)this + 63) = v6;
      *((_QWORD *)this + 64) = 0;
      *((_QWORD *)this + 147) = 0;
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

void errorExit(uint64_t *a1)
{
  uint64_t v1;

  v1 = *a1;
  (*(void (**)(uint64_t *))(*a1 + 16))(a1);
  siglongjmp((int *)(v1 + 176), 1);
}

const char *outputMessage(const char *result)
{
  const char *v1;
  uint64_t v2;
  _OWORD v3[12];
  uint64_t v4;
  uint64_t v5;

  v1 = result;
  v5 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)result;
  if (*(_DWORD *)(*(_QWORD *)result + 40) == 120)
  {
    if ((outputMessage(jpeg_common_struct *)::didWarn_JWRN_HIT_MARKER & 1) != 0)
      return result;
    outputMessage(jpeg_common_struct *)::didWarn_JWRN_HIT_MARKER = 1;
  }
  v4 = 0;
  memset(v3, 0, sizeof(v3));
  (*(void (**)(const char *, _OWORD *))(v2 + 24))(result, v3);
  result = LogError(0, 0, "libJPEG", " %s\n", v3);
  if (*(_DWORD *)(*(_QWORD *)v1 + 40) == 116)
    *(_BYTE *)(*(_QWORD *)v1 + 44) = 1;
  return result;
}

uint64_t fill_input_buffer(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  __n128 v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  _BYTE *v12;
  size_t Bytes;
  int v14;
  BOOL v15;
  size_t v16;
  _BYTE __dst[8002];
  uint64_t v18;

  v3.n128_f64[0] = MEMORY[0x1E0C80A78](a1, a2);
  v4 = v2;
  v18 = *MEMORY[0x1E0C80C00];
  v5 = v2[5];
  if (!v5 || !*(_QWORD *)(v5 + 56))
  {
    v6 = *v2;
    *(_DWORD *)(v6 + 40) = 43;
    (*(void (**)(uint64_t *, __n128))v6)(v2, v3);
    if (!*(_QWORD *)(v5 + 56))
    {
      v7 = *v4;
      *(_DWORD *)(v7 + 40) = 43;
      (*(void (**)(uint64_t *))v7)(v4);
    }
  }
  v8 = *(_QWORD *)(v5 + 88);
  if (!v8)
  {
LABEL_11:
    bzero(__dst, 0x1F42uLL);
    v11 = *(_QWORD *)(v5 + 8);
    if (v11)
      memcpy(__dst, *(const void **)v5, *(_QWORD *)(v5 + 8));
    v12 = (_BYTE *)(v5 + 96);
    Bytes = IIOImageReadSession::getBytes(*(IIOImageReadSession **)(v5 + 56), (_BYTE *)(v5 + 96), 0xFA0uLL);
    v14 = *(unsigned __int8 *)(v5 + 96);
    if (!*(_BYTE *)(v5 + 96) || (v14 != 238 ? (v15 = v14 == 2) : (v15 = 1), v15))
    {
      if (*(unsigned __int8 *)(v5 + 97) == 216
        && *(unsigned __int8 *)(v5 + 98) == 255
        && *(unsigned __int8 *)(v5 + 99) == 219
        && IIOImageReadSession::seek(*(IIOImageReadSession **)(v5 + 56), 0, 1) == *(_QWORD *)(v5 + 72) + Bytes)
      {
        *v12 = -1;
      }
    }
    if (Bytes > 0xF9F)
    {
      if (Bytes == 4000)
      {
        result = 1;
        v16 = 4000;
        goto LABEL_32;
      }
      if ((Bytes & 0x8000000000000000) != 0)
        return 0;
    }
    else if (*(_BYTE *)(v5 + 64)
           || (IIOImageReadSession::isFinal(*(IIOImageReadSession **)(v5 + 56)) & 1) != 0)
    {
      *(_WORD *)(v5 + Bytes + 96) = -9729;
      v16 = Bytes + 2;
      result = 1;
LABEL_32:
      *(_QWORD *)v5 = v12;
      *(_QWORD *)(v5 + 8) = v16;
      return result;
    }
    memcpy(&__dst[v11], (const void *)(v5 + 96), Bytes);
    v16 = Bytes + v11;
    memcpy((void *)(v5 + 96), __dst, v16);
    result = 0;
    goto LABEL_32;
  }
  while (1)
  {
    v9 = v8 >= 0xFA0 ? 4000 : v8;
    result = (uint64_t)IIOImageReadSession::skipBytes(*(IIOImageReadSession **)(v5 + 56), v9);
    if (!result)
      return result;
    v8 = *(_QWORD *)(v5 + 88) - result;
    *(_QWORD *)(v5 + 88) = v8;
    if (!v8)
      goto LABEL_11;
  }
}

const char *init_source(uint64_t a1)
{
  _QWORD *v1;
  IIOImageReadSession *v2;
  const char *result;

  v1 = *(_QWORD **)(a1 + 40);
  if (!v1)
    return LogError("init_source", 259, "*** ImageIO - libJPEG nil-'source'cinfo->src'\n");
  v2 = (IIOImageReadSession *)v1[7];
  if (!v2)
    return LogError("init_source", 259, "*** ImageIO - libJPEG nil-'source'cinfo->src'\n");
  result = (const char *)IIOImageReadSession::seek(v2, v1[9], 0);
  v1[11] = 0;
  *v1 = v1 + 12;
  v1[1] = 0;
  return result;
}

uint64_t skip_input_data(uint64_t result, unint64_t a2)
{
  _QWORD *v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;

  v2 = *(_QWORD **)(result + 40);
  v3 = v2[1];
  v4 = v3 - a2;
  if (v3 <= a2)
  {
    v4 = 0;
    v5 = a2 - v3;
  }
  else
  {
    v5 = 0;
    *v2 += a2;
  }
  v2[1] = v4;
  v2[11] += v5;
  return result;
}

uint64_t LibJPEGReadPlugin::saveDataToXPCObject(LibJPEGReadPlugin *this, void *a2)
{
  uint64_t v4;

  v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!(_DWORD)v4)
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_libjpeg", (char *)this + 504, 0x23C8uLL);
  return v4;
}

CGMutableImageMetadataRef LibJPEGReadPlugin::readAPP13(uint64_t a1, uint64_t a2)
{
  uint64_t **v2;
  uint64_t v4;
  uint64_t *v6;
  CGMutableImageMetadataRef Mutable;
  void *TagWithPath;
  uint64_t v11;
  const CGPath *Value;
  IIOImagePlus *v13;
  const CGPath *v14;

  v2 = *(uint64_t ***)(a2 + 408);
  if (!v2)
    return 0;
  while (1)
  {
    v4 = *((unsigned int *)v2 + 4);
    if (*((unsigned __int8 *)v2 + 8) == 237 && v4 >= 0xF)
    {
      v6 = v2[3];
      if (*v6 == 0x6F68736F746F6850 && *((_WORD *)v6 + 4) == 8304)
        break;
    }
    v2 = (uint64_t **)*v2;
    if (!v2)
      return 0;
  }
  Mutable = CGImageMetadataCreateMutable();
  ReadPhotoshopImageResource((uint64_t)Mutable, (uint64_t)v6 + 14, v4 - 14);
  if (Mutable)
  {
    TagWithPath = CGImageMetadataGetTagWithPath(Mutable, 0, CFSTR("iio:PSIRClippingPath"));
    if (TagWithPath)
    {
      v11 = (uint64_t)TagWithPath;
      Value = (const CGPath *)CGImageMetadataTagGetValue((uint64_t)TagWithPath);
      if (Value)
      {
        v13 = *(IIOImagePlus **)(a1 + 16);
        v14 = CGPathRetain(Value);
        IIOImagePlus::setClipPath(v13, v14);
      }
      CGImageMetadataRemoveTag((uint64_t)Mutable, v11);
    }
  }
  return Mutable;
}

const __CFDictionary *LibJPEGReadPlugin::readExifData(int a1, uint64_t a2, IIODictionary *a3)
{
  uint64_t *v4;
  const __CFDictionary *MetadataFromDatabuffer;
  _BYTE *v7;
  char v8;
  const __CFDictionary *TopLevelTag;
  uint64_t v10;
  const __CFString *Value;
  SInt32 IntValue;
  IIOImageReadSession *v13;
  uint64_t v14;
  const __CFString *v15;
  const __CFString *v16;
  const __CFDictionary *v17;
  const __CFDictionary *v18;
  const __CFDictionary *v19;
  const __CFDictionary *v20;
  unsigned __int16 v22;

  v4 = *(uint64_t **)(a2 + 408);
  if (v4)
  {
    MetadataFromDatabuffer = 0;
    do
    {
      if (*((unsigned __int8 *)v4 + 8) == 225 && *((_DWORD *)v4 + 4) >= 0xBu)
      {
        v7 = (_BYTE *)v4[3];
        if (*v7 == 69 && v7[1] == 120 && v7[2] == 105 && v7[3] == 102 && !v7[4] && !v7[5])
        {
          v8 = IIOMetadataFlagsFromImageSourceOptions(a3);
          MetadataFromDatabuffer = CreateMetadataFromDatabuffer((const char *)(v4[3] + 6), (*((_DWORD *)v4 + 4) - 6), v8);
        }
      }
      v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  else
  {
    MetadataFromDatabuffer = 0;
  }
  if (*(_DWORD *)(a2 + 376))
  {
    TopLevelTag = CGImageMetadataGetTopLevelTag(MetadataFromDatabuffer, (uint64_t)CFSTR("http://ns.apple.com/ImageIO/1.0/"), (uint64_t)CFSTR("JPEGInterchangeFormat"));
    if (TopLevelTag)
    {
      v10 = (uint64_t)TopLevelTag;
      Value = (const __CFString *)CGImageMetadataTagGetValue((uint64_t)TopLevelTag);
      IntValue = CFStringGetIntValue(Value);
      v13 = *(IIOImageReadSession **)(*(_QWORD *)(a2 + 40) + 56);
      v22 = 0;
      IIOImageReadSession::getBytesAtOffset(v13, &v22, IntValue, 2uLL);
      if (v22 != 55551 && v22 != 65496)
      {
        v14 = (IntValue + 18);
        IIOImageReadSession::getBytesAtOffset(v13, &v22, (int)v14, 2uLL);
        if (v22 == 65496 || v22 == 55551)
        {
          v15 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%d"), v14);
          if (v15)
          {
            v16 = v15;
            CGImageMetadataTagSetValue(v10, v15);
            CFRelease(v16);
          }
        }
        else
        {
          v17 = CGImageMetadataGetTopLevelTag(MetadataFromDatabuffer, (uint64_t)CFSTR("http://ns.apple.com/ImageIO/1.0/"), (uint64_t)CFSTR("JPEGInterchangeFormat"));
          CGImageMetadataRemoveTag((uint64_t)MetadataFromDatabuffer, (uint64_t)v17);
          v18 = CGImageMetadataGetTopLevelTag(MetadataFromDatabuffer, (uint64_t)CFSTR("http://ns.apple.com/ImageIO/1.0/"), (uint64_t)CFSTR("JPEGInterchangeFormatLength"));
          CGImageMetadataRemoveTag((uint64_t)MetadataFromDatabuffer, (uint64_t)v18);
          v19 = CGImageMetadataGetTopLevelTag(MetadataFromDatabuffer, (uint64_t)CFSTR("http://ns.apple.com/ImageIO/1.0/"), (uint64_t)CFSTR("JPEGInterchangeFormatWidth"));
          CGImageMetadataRemoveTag((uint64_t)MetadataFromDatabuffer, (uint64_t)v19);
          v20 = CGImageMetadataGetTopLevelTag(MetadataFromDatabuffer, (uint64_t)CFSTR("http://ns.apple.com/ImageIO/1.0/"), (uint64_t)CFSTR("JPEGInterchangeFormatHeight"));
          CGImageMetadataRemoveTag((uint64_t)MetadataFromDatabuffer, (uint64_t)v20);
        }
      }
    }
  }
  return MetadataFromDatabuffer;
}

uint64_t LibJPEGReadPlugin::startDecompressing(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t result;
  int v6;
  int v7;
  unsigned int v8;

  v4 = a1 + 504;
  _cg_jpeg_CreateDecompress((char *)(a1 + 504), 90, 664);
  *(_QWORD *)(a1 + 544) = a1 + 1168;
  result = _cg_jpeg_read_header(v4, 1);
  v6 = *(unsigned __int16 *)(a1 + 316);
  if (*(_WORD *)(a1 + 316))
  {
    *(_DWORD *)(a1 + 600) = 1;
    v7 = 8;
    *(_DWORD *)(a1 + 576) = 8;
    v8 = v6 - 2;
    if (v8 <= 6)
      v7 = dword_188211350[(__int16)v8];
    *(_DWORD *)(a1 + 572) = v7;
  }
  *(_DWORD *)(a1 + 568) = a2;
  if (*(int *)(a1 + 540) >= 202)
    return _cg_jpeg_start_decompress(v4);
  return result;
}

CGImageMetadata *LibJPEGReadPlugin::readXMPData(uint64_t a1, uint64_t a2, CFDataRef theData)
{
  const char *BytePtr;
  CFIndex Length;
  CGImageMetadata *result;
  uint64_t *v7;
  char v8;
  uint64_t v9;
  size_t v10;
  char *v11;
  unsigned int v12;
  const char *v13;
  unsigned int v14;
  uint64_t v15;
  size_t v18;
  const char *v19;
  int v20;
  unsigned int v21;
  char *v22;
  size_t v23;
  unsigned int v24;
  unint64_t v25;
  unsigned int v26;
  CGImageMetadata *MetadataFromExtendedXMPData;
  uint64_t v28;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;

  if (theData)
  {
    BytePtr = (const char *)CFDataGetBytePtr(theData);
    Length = CFDataGetLength(theData);
    return CreateMetadataFromXMPSidecarData(BytePtr, Length);
  }
  v7 = *(uint64_t **)(a2 + 408);
  v32 = 0u;
  v33 = 0u;
  if (!v7)
    return 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  do
  {
    if (*((unsigned __int8 *)v7 + 8) == 225)
    {
      v14 = *((_DWORD *)v7 + 4);
      if (v14 >= 0x1E)
      {
        v15 = v7[3];
        if (*(_QWORD *)v15 == 0x6E2F2F3A70747468
          && *(_QWORD *)(v15 + 8) == 0x2E65626F64612E73
          && *(_QWORD *)(v15 + 16) == 0x2F7061782F6D6F63)
        {
          v20 = *(unsigned __int8 *)(v15 + 29);
          v19 = (const char *)(v15 + 29);
          v21 = v14 - 29;
          if (v20 == 60)
          {
            v13 = v19;
            v12 = v21;
          }
        }
        else
        {
          v18 = v14 - 75;
          if (v14 >= 0x4B && !strcmp((const char *)v7[3], "http://ns.adobe.com/xmp/extension/"))
          {
            v28 = v9;
            v22 = v11;
            v30 = *(_OWORD *)(v15 + 35);
            v31 = *(_OWORD *)(v15 + 51);
            v23 = bswap32(*(_DWORD *)(v15 + 67));
            v24 = *(_DWORD *)(v15 + 71);
            if ((v8 & 1) != 0)
            {
              v25 = v10;
              goto LABEL_24;
            }
            v32 = *(_OWORD *)(v15 + 35);
            v33 = *(_OWORD *)(v15 + 51);
            if ((unint64_t)IIOImageReadSession::getSize(*(IIOImageReadSession **)(a1 + 24)) <= v23)
            {
              _cg_jpeg_mem_term("readXMPData", 1316, "*** ERROR bad extendedLength: %d\n", v23);
              v8 = 0;
            }
            else
            {
              v25 = v23;
              v10 = v23;
              v22 = (char *)malloc_type_calloc(1uLL, v23, 0x9658313AuLL);
              if (!v22)
              {
                v11 = 0;
                v8 = 0;
                goto LABEL_43;
              }
LABEL_24:
              if ((unint64_t)IIOImageReadSession::getSize(*(IIOImageReadSession **)(a1 + 24)) <= v25)
              {
                _cg_jpeg_mem_term("readXMPData", 1322, "*** ERROR bad extendedLength: %d\n");
              }
              else
              {
                v26 = bswap32(v24);
                if (v26 < v10)
                {
                  v11 = v22;
                  if (!__CFADD__((_DWORD)v18, v26))
                  {
                    v8 = 1;
                    v9 = v28;
                    if ((unint64_t)v32 ^ (unint64_t)v30 | *((_QWORD *)&v32 + 1) ^ *((_QWORD *)&v30 + 1) | (unint64_t)v33 ^ (unint64_t)v31 | *((_QWORD *)&v33 + 1) ^ *((_QWORD *)&v31 + 1))
                    {
                      v23 = v10;
                    }
                    else if ((_DWORD)v23 == (_DWORD)v10 && v18 + v26 <= v10)
                    {
                      memcpy(&v11[v26], (const void *)(v7[3] + 75), v18);
                      v9 = v28 + v18;
                    }
                    else
                    {
                      v23 = v10;
                    }
                    goto LABEL_33;
                  }
                  v8 = 1;
                  v23 = v10;
LABEL_43:
                  v9 = v28;
LABEL_33:
                  v10 = v23;
                  goto LABEL_34;
                }
                _cg_jpeg_mem_term("readXMPData", 1323, "*** ERROR bad chunkOffset: %d\n");
              }
              v8 = 1;
              v23 = v10;
            }
            v11 = v22;
            goto LABEL_43;
          }
        }
      }
    }
LABEL_34:
    v7 = (uint64_t *)*v7;
  }
  while (v7);
  if (v11 && (_DWORD)v10 && v9 == v10 && v13 && v12)
  {
    MetadataFromExtendedXMPData = CreateMetadataFromExtendedXMPData(v13, v12, v11, v9);
    goto LABEL_56;
  }
  if (!v13 || !v12)
  {
    MetadataFromExtendedXMPData = 0;
    result = 0;
    if (!v11)
      return result;
    goto LABEL_56;
  }
  result = CreateMetadataFromXMPBuffer(v13, v12);
  MetadataFromExtendedXMPData = result;
  if (v11)
  {
LABEL_56:
    free(v11);
    return MetadataFromExtendedXMPData;
  }
  return result;
}

void LibJPEGReadPlugin::readQualityPropertiesFromJPEG(uint64_t a1, uint64_t a2, IIODictionary *a3)
{
  const __CFAllocator *v5;
  CFMutableArrayRef Mutable;
  __CFArray *v7;
  CFIndex v8;
  const void *v9;
  uint64_t v10;
  CFIndex v11;
  uint64_t v12;
  uint64_t i;
  CFDataRef v14;
  _BYTE v15[24];
  UInt8 v16[24];
  UInt8 bytes[16];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 4, MEMORY[0x1E0C9B378]);
    if (Mutable)
    {
      v7 = Mutable;
      v8 = 0;
      v9 = (const void *)*MEMORY[0x1E0C9B0D0];
      do
        CFArraySetValueAtIndex(v7, v8++, v9);
      while (v8 != 4);
      v23 = 0u;
      v24 = 0u;
      v21 = 0u;
      v22 = 0u;
      v19 = 0u;
      v20 = 0u;
      *(_OWORD *)bytes = 0u;
      v18 = 0u;
      if (*(int *)(a2 + 56) >= 1)
      {
        v10 = 0;
        do
        {
          v11 = *(unsigned int *)(*(_QWORD *)(a2 + 304) + 96 * v10 + 16);
          if (v11 <= 3)
          {
            v12 = *(_QWORD *)(a2 + 8 * v11 + 200);
            if (v12)
            {
              if (CFArrayGetValueAtIndex(v7, *(unsigned int *)(*(_QWORD *)(a2 + 304) + 96 * v10 + 16)) == v9)
              {
                for (i = 0; i != 128; i += 2)
                  *(_WORD *)&bytes[i] = *(_WORD *)(v12 + i);
                v14 = CFDataCreate(v5, bytes, 128);
                if (v14)
                {
                  CFArraySetValueAtIndex(v7, v11, v14);
                  CFRelease(v14);
                }
              }
            }
          }
          ++v10;
        }
        while (v10 < *(int *)(a2 + 56));
      }
      IIODictionary::setObjectForKeyGroup(a3, v7, CFSTR("Quantization"), CFSTR("{JPEG}"));
      CFRelease(v7);
    }
    if (*(_DWORD *)(a2 + 56) == 3)
    {
      IIONumber::IIONumber((IIONumber *)v16, *(_DWORD *)(*(_QWORD *)(a2 + 304) + 8));
      IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v16, CFSTR("ChromaSubsamplingX"), CFSTR("{JPEG}"));
      IIONumber::~IIONumber((IIONumber *)v16);
      IIONumber::IIONumber((IIONumber *)v15, *(_DWORD *)(*(_QWORD *)(a2 + 304) + 12));
      IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v15, CFSTR("ChromaSubsamplingY"), CFSTR("{JPEG}"));
      IIONumber::~IIONumber((IIONumber *)v15);
    }
  }
}

void sub_187FD75CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  IIONumber::~IIONumber((IIONumber *)&a9);
  _Unwind_Resume(a1);
}

uint64_t LibJPEGReadPlugin::validateJPEG(IIOImageReadSession **this)
{
  unsigned int Val16;
  _OWORD v3[4];
  uint64_t v4;

  v4 = 0;
  memset(v3, 0, sizeof(v3));
  IIOScanner::IIOScanner((IIOScanner *)v3, this[3]);
  GlobalHEIFInfo::setShouldExposeMultiFrameContents((uint64_t)v3, 0);
  IIOScanner::seek((IIOScanner *)v3, 2uLL);
  while (IIOScanner::getVal16((IIOScanner *)v3) != 65498)
  {
    Val16 = IIOScanner::getVal16((IIOScanner *)v3);
    IIOScanner::skip((uint64_t)v3, Val16 - 2);
  }
  IIOScanner::~IIOScanner((IIOScanner *)v3);
  return 0;
}

void sub_187FD7688(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187FD766CLL);
}

void sub_187FD769C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  IIOScanner::~IIOScanner((IIOScanner *)&a9);
  _Unwind_Resume(a1);
}

uint64_t LibJPEGReadPlugin::initialize(LibJPEGReadPlugin *this, IIODictionary *a2)
{
  uint64_t v3;
  IIODictionary *v4;
  _BOOL4 v5;
  _BOOL4 v6;
  const __CFDictionary *ObjectForKey;
  const __CFDictionary *v8;
  unint64_t Uint32ForKey;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  IIOImageReadSession *v14;
  unint64_t v15;
  unint64_t v16;
  IIOImageRead *Size;
  IIOImageRead *v18;
  int v19;
  IIOImageRead *v20;
  uint64_t result;
  BOOL v22;
  IIOImageReadSession *v23;
  IIOImageRead *v24;
  int v25;
  char v26;
  int header;
  int v28;
  CGMutableImageMetadataRef v29;
  unint64_t Bytes;
  int v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  int v36;
  BOOL v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  int v41;
  unint64_t v42;
  uint64_t v43;
  unsigned int v44;
  IIOImageRead *v45;
  unint64_t v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  _BOOL8 BoolForKey;
  int v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  int v60;
  IIOImageReadSession *v61;
  unint64_t v62;
  IIOImageReadSession *v63;
  unint64_t v64;
  int v65;
  unint64_t v66;
  unint64_t v67;
  IIOImageReadSession *v68;
  unint64_t v69;
  int v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  unint64_t v74;
  int v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  int v79;
  int v80;
  BOOL v81;
  int v82;
  int v83;
  unint64_t v84;
  int v85;
  unint64_t v86;
  unint64_t v87;
  char *v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  IIOImageReadSession *v93;
  unint64_t v94;
  int v95;
  unint64_t v96;
  char *v97;
  unint64_t v98;
  int v99;
  unint64_t v100;
  unsigned int v101;
  unsigned int v102;
  __int16 v103;
  const __CFDictionary *ExifData;
  CGMutableImageMetadataRef v105;
  CGMutableImageMetadataRef APP13;
  CGImageMetadata *XMPData;
  unsigned int v108;
  unsigned int v109;
  int v110;
  int v111;
  int v112;
  CGMutableImageMetadataRef v113;
  uint64_t Metadata;
  CGMutableImageMetadataRef v115;
  const __CFDictionary *v116;
  uint64_t v117;
  CGMutableImageMetadataRef v118;
  CGImageMetadata *v119;
  CGMutableImageMetadataRef v120;
  CGImageMetadata *v121;
  char v122;
  int v123;
  int v124;
  uint64_t **v125;
  unint64_t v126;
  unint64_t v127;
  unsigned int *v128;
  unint64_t v129;
  unint64_t v130;
  uint64_t v131;
  uint64_t *v132;
  uint64_t v133;
  uint64_t v134;
  BOOL v135;
  unsigned int *v136;
  uint64_t v137;
  size_t v138;
  unsigned int *v139;
  unsigned int *v140;
  unsigned int v141;
  unint64_t v142;
  uint64_t v143;
  CGColorSpaceRef v144;
  int v145;
  CGColorSpaceRef ColorSpaceFromMetadata;
  const __CFDictionary *TopLevelTag;
  const __CFString *Value;
  SInt32 IntValue;
  CFStringRef *v150;
  CFStringRef *v151;
  IIOImagePlus *v152;
  CGColorSpaceRef v153;
  unsigned int *v154;
  double v155;
  uint64_t v156;
  size_t v157;
  size_t v158;
  char *v159;
  char *v160;
  uint64_t v161;
  size_t v162;
  size_t v163;
  char *v164;
  char *v165;
  size_t v166;
  size_t v167;
  CGImage *v168;
  CGImageRef v169;
  unsigned int v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  unsigned int v174;
  IIOImageReadSession **v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  _QWORD *v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  _QWORD *v183;
  uint64_t v184;
  CGDataProvider *v185;
  CGDataProviderRef v186;
  CGDataProvider *v187;
  CGDataProviderRef v188;
  CGDataProvider *v189;
  CGImage *v190;
  CGDataProviderRef v191;
  CGImageRef v192;
  CGImage *v193;
  CGImage *CGImageRefFromYCbCrData;
  CGDataProvider *v195;
  CGImageRef v196;
  CGImageRef v197;
  CGImageRef v198;
  CGDataProvider *v199;
  unsigned int *v200;
  CGDataProvider *provider;
  CGImage *v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  CGImageRef v206;
  unsigned int v207;
  unsigned int v208;
  unsigned int v209;
  unsigned int v210;
  unsigned int v211;
  unsigned int v212;
  CGDataProvider *cf;
  size_t v214;
  CGImage *v215;
  size_t bytesPerRow;
  char *v217;
  char *data;
  size_t v219;
  size_t v220;
  size_t v221;
  size_t v222;
  size_t width;
  size_t v224;
  CGColorSpace *space;
  int v226;
  unint64_t v227;
  const __CFDictionary *v228;
  int v229;
  char v230;
  int v231;
  IIODictionary *v232;
  uint64_t v233;
  const __CFData *theData;
  uint64_t v235;
  uint64_t v236;
  unsigned int v237;
  unsigned int v238;
  _BOOL4 v239;
  _BOOL4 v240;
  _QWORD v241[3];
  IIOImageReadSession *v242[2];
  _OWORD v243[7];
  _BYTE v244[128];
  _BYTE v245[792];
  uint64_t v246;

  v246 = *MEMORY[0x1E0C80C00];
  v3 = *((_QWORD *)this + 8);
  v232 = (IIODictionary *)*((_QWORD *)this + 7);
  v4 = (IIODictionary *)*((_QWORD *)this + 6);
  if (IIODictionary::getBoolForKey(v4, CFSTR("kCGImageSourceUseCoreImage")))
  {
    if (GetCIProc(void)::onceToken != -1)
      dispatch_once(&GetCIProc(void)::onceToken, &__block_literal_global_15);
    v5 = g_ciGetCGImageRefFromYCbCrData != 0;
  }
  else
  {
    v5 = 0;
  }
  v6 = v5;
  v231 = IIOSkipMetadata(v4);
  v230 = IIOSkipXMP_and_IPTC(v4);
  if (IIODictionary::containsKey(v4, CFSTR("kCGImageSourceXMPSidecar")))
    ObjectForKey = IIODictionary::getObjectForKey(v4, CFSTR("kCGImageSourceXMPSidecar"));
  else
    ObjectForKey = 0;
  v8 = ObjectForKey;
  v229 = *((_DWORD *)this + 113);
  if (IIODictionary::containsKey(v4, CFSTR("kCGImageSourceSubsampleFactor")))
    Uint32ForKey = IIODictionary::getUint32ForKey(v4, CFSTR("kCGImageSourceSubsampleFactor"));
  else
    Uint32ForKey = 0;
  v10 = IIODictionary::containsKey(v4, CFSTR("kCGImageSourceColorTransform"));
  if (v10)
    v11 = IIODictionary::getUint32ForKey(v4, CFSTR("kCGImageSourceColorTransform"));
  else
    v11 = -1;
  v12 = v11;
  v13 = *((unsigned __int8 *)this + 216);
  if (v13 == 1)
    goto LABEL_26;
  v233 = v3;
  v235 = v11;
  v237 = v10;
  v239 = v6;
  v14 = (IIOImageReadSession *)*((_QWORD *)this + 3);
  v15 = *((_QWORD *)this + 24);
  v16 = *((_QWORD *)this + 58);
  Size = IIOImageReadSession::getSize(v14);
  bzero(&v242[1], 0x410uLL);
  v242[0] = v14;
  if (!v15 && IIOImageReadSession::isFinal(v14))
  {
    LOWORD(v241[0]) = 0;
    v18 = IIOImageReadSession::getSize(v14);
    IIOImageReadSession::getBytesAtOffset(v14, v241, (unint64_t)v18 - 2, 2uLL);
    v19 = LOWORD(v241[0]);
    LOWORD(v241[0]) = __rev16(LOWORD(v241[0]));
    if (v19 != 55807)
    {
      v20 = IIOImageReadSession::getSize(v14);
      IIOImageReadSession::getBytesAtOffset(v14, v241, (unint64_t)v20 - 3, 2uLL);
      if (LOWORD(v241[0]) != 55807)
        return 4294967246;
    }
LABEL_20:
    v6 = v239;
    v10 = v237;
    v12 = v235;
    v3 = v233;
    goto LABEL_26;
  }
  if (!v16 || Size == (IIOImageRead *)-1)
  {
    if (IIOImageReadSession::seek(v14, v15, 0) != v15)
      return 4294967246;
    Bytes = IIOImageReadSession::getBytes(v14, (_BYTE *)v243 + 8, 0x400uLL);
    if (!Bytes)
      return 4294967246;
    v31 = BYTE8(v243[0]);
    v32 = 1;
    v33 = Bytes - 1;
    v242[1] = (IIOImageReadSession *)1;
    *(_QWORD *)&v243[0] = Bytes - 1;
    if (Bytes == 1)
    {
      v34 = IIOImageReadSession::getBytes(v242[0], (_BYTE *)v243 + 8, 0x400uLL);
      if (!v34)
        return 4294967246;
      v33 = v34;
      v32 = 0;
    }
    v35 = v33;
    v36 = *(unsigned __int8 *)(((unint64_t)v242 | v32) + 0x18);
    v242[1] = (IIOImageReadSession *)(v32 + 1);
    *(_QWORD *)&v243[0] = v33 - 1;
    v37 = (v31 + 1) <= 1u || v31 == 2;
    if (!v37 || v36 != 216)
      return 4294967246;
    v38 = v33 - 1;
    v39 = v32 + 1;
    if (v35 == 1)
    {
      v40 = IIOImageReadSession::getBytes(v242[0], (_BYTE *)v243 + 8, 0x400uLL);
      v242[1] = 0;
      *(_QWORD *)&v243[0] = v40;
      if (!v40)
        return 4294967246;
      v39 = 0;
      v38 = v40;
    }
    v41 = *(unsigned __int8 *)(((unint64_t)v242 | v39) + 0x18);
    v242[1] = (IIOImageReadSession *)(v39 + 1);
    *(_QWORD *)&v243[0] = v38 - 1;
    if (v38 == 1)
    {
      v58 = IIOImageReadSession::getBytes(v242[0], (_BYTE *)v243 + 8, 0x400uLL);
      v242[1] = 0;
      *(_QWORD *)&v243[0] = v58;
      if (!v58)
        return 4294967246;
      v43 = 0;
      v42 = v58;
    }
    else
    {
      v42 = v38 - 1;
      v43 = v39 + 1;
    }
    v59 = v42;
    v60 = *(unsigned __int8 *)(((unint64_t)v242 | v43) + 0x18);
    v61 = (IIOImageReadSession *)(v43 + 1);
    v62 = v59 - 1;
    v242[1] = v61;
    *(_QWORD *)&v243[0] = v62;
    if (v41 == 255 && v60)
    {
      v63 = v61;
      v64 = v62;
      v65 = v60;
      while (1)
      {
        if ((v65 - 208) < 9 || v65 == 218)
        {
          do
          {
            v66 = v64;
            v67 = v64;
            v68 = v63;
            if (!v66)
            {
              v69 = IIOImageReadSession::getBytes(v242[0], (_BYTE *)v243 + 8, 0x400uLL);
              v242[1] = 0;
              *(_QWORD *)&v243[0] = v69;
              if (!v69)
                return 4294967246;
              v68 = 0;
              v67 = v69;
            }
            v70 = *((unsigned __int8 *)v68 + (_QWORD)v243 + 8);
            v242[1] = (IIOImageReadSession *)((char *)v68 + 1);
            *(_QWORD *)&v243[0] = v67 - 1;
            if (v67 == 1)
            {
              v73 = IIOImageReadSession::getBytes(v242[0], (_BYTE *)v243 + 8, 0x400uLL);
              v242[1] = 0;
              *(_QWORD *)&v243[0] = v73;
              if (!v73)
                return 4294967246;
              v72 = 0;
              v71 = v73;
            }
            else
            {
              v71 = v67 - 1;
              v72 = (uint64_t)v68 + 1;
            }
            v74 = v71;
            v75 = *((unsigned __int8 *)v243 + v72 + 8);
            v63 = (IIOImageReadSession *)(v72 + 1);
            v76 = v74 - 1;
            v242[1] = (IIOImageReadSession *)(v72 + 1);
            *(_QWORD *)&v243[0] = v74 - 1;
            if (v75 == 255)
            {
              v77 = v74 - 1;
              if (v74 == 1)
              {
                v78 = IIOImageReadSession::getBytes(v242[0], (_BYTE *)v243 + 8, 0x400uLL);
                v242[1] = 0;
                *(_QWORD *)&v243[0] = v78;
                if (!v78)
                  return 4294967246;
                v77 = v78;
                v63 = 0;
              }
              v79 = *((unsigned __int8 *)v63 + (_QWORD)v243 + 8);
              v63 = (IIOImageReadSession *)((char *)v63 + 1);
              v242[1] = v63;
              *(_QWORD *)&v243[0] = v77 - 1;
              v76 = v77 - 1;
              v75 = v79;
              v80 = 255;
            }
            else
            {
              v80 = v70;
            }
            v81 = v80 != 255 || v75 == 0;
            v64 = v76;
          }
          while (v81);
          v82 = 0;
          v65 = v75;
        }
        else
        {
          if (v65 == 217)
            goto LABEL_20;
          if (!v64)
          {
            v84 = IIOImageReadSession::getBytes(v242[0], (_BYTE *)v243 + 8, 0x400uLL);
            v242[1] = 0;
            *(_QWORD *)&v243[0] = v84;
            if (!v84)
              return 4294967246;
            v64 = v84;
            v63 = 0;
          }
          v85 = *((unsigned __int8 *)v63 + (_QWORD)v243 + 8);
          v86 = v64 - 1;
          v242[1] = (IIOImageReadSession *)((char *)v63 + 1);
          *(_QWORD *)&v243[0] = v86;
          if (v86)
          {
            v87 = v86;
            v88 = (char *)v63 + 1;
          }
          else
          {
            v89 = IIOImageReadSession::getBytes(v242[0], (_BYTE *)v243 + 8, 0x400uLL);
            v242[1] = 0;
            *(_QWORD *)&v243[0] = v89;
            if (!v89)
              return 4294967246;
            v88 = 0;
            v87 = v89;
          }
          v90 = v87 - 1;
          v91 = (int)((bswap32(v85 | (v88[(_QWORD)v243 + 8] << 8)) >> 16) - 2);
          if (v90 >= v91)
          {
            v92 = v90 - v91;
            v242[1] = (IIOImageReadSession *)&v88[v91 + 1];
            *(_QWORD *)&v243[0] = v92;
          }
          else
          {
            v242[1] = 0;
            *(_QWORD *)&v243[0] = 0;
            if (IIOImageReadSession::skipBytes(v242[0], (int)v91 - (int)v90) != (IIOImageRead *)((int)v91 - (int)v90))
              return 4294967246;
            v92 = *(_QWORD *)&v243[0];
          }
          if (v92)
          {
            v93 = v242[1];
          }
          else
          {
            v94 = IIOImageReadSession::getBytes(v242[0], (_BYTE *)v243 + 8, 0x400uLL);
            v242[1] = 0;
            *(_QWORD *)&v243[0] = v94;
            if (!v94)
              return 4294967246;
            v93 = 0;
            v92 = v94;
          }
          v95 = *((unsigned __int8 *)v93 + (_QWORD)v243 + 8);
          v242[1] = (IIOImageReadSession *)((char *)v93 + 1);
          *(_QWORD *)&v243[0] = v92 - 1;
          if (v92 == 1)
          {
            v98 = IIOImageReadSession::getBytes(v242[0], (_BYTE *)v243 + 8, 0x400uLL);
            v242[1] = 0;
            *(_QWORD *)&v243[0] = v98;
            if (!v98)
              return 4294967246;
            v97 = 0;
            v96 = v98;
          }
          else
          {
            v96 = v92 - 1;
            v97 = (char *)v93 + 1;
          }
          v99 = v97[(_QWORD)v243 + 8];
          v63 = (IIOImageReadSession *)(v97 + 1);
          v100 = v96 - 1;
          v242[1] = (IIOImageReadSession *)(v97 + 1);
          *(_QWORD *)&v243[0] = v100;
          if (v95 == 255)
          {
            v65 = v99;
            v82 = 0;
          }
          else
          {
            v82 = -1;
          }
          v76 = v100;
        }
        v83 = v82;
        v64 = v76;
        if (v83)
          return 4294967246;
      }
    }
    return 4294967246;
  }
  result = 4294967246;
  v10 = v237;
  if ((unint64_t)Size > v15)
  {
    v22 = (unint64_t)Size - v15 >= v16;
    v6 = v239;
    v12 = v235;
    v3 = v233;
    if (v22)
    {
LABEL_26:
      if (IIOImageReadSession::seek(*((IIOImageReadSession **)this + 3), *((_QWORD *)this + 24), 0) != *((_QWORD *)this + 24))
        return 4294967246;
      if ((gIIODebugFlags & 0x80000000) == 0 && Uint32ForKey <= 1)
        *((_BYTE *)this + 348) = 1;
      if (sigsetjmp((int *)this + 2362, 0))
      {
        _cg_jpeg_mem_term("initialize", 1548, "sigsetjmp");
        _cg_jpeg_destroy_decompress((char *)this + 504);
        if (*((_QWORD *)this + 153))
          *((_QWORD *)this + 153) = 0;
        return 4294967246;
      }
      theData = v8;
      v236 = v12;
      v240 = v6;
      _cg_jpeg_CreateDecompress((char *)this + 504, 90, 664);
      *((_QWORD *)this + 63) = _cg_jpeg_std_error((uint64_t)this + 9272);
      *((_QWORD *)this + 1159) = errorExit;
      *((_QWORD *)this + 1161) = outputMessage;
      *((_QWORD *)this + 148) = init_source;
      *((_QWORD *)this + 149) = fill_input_buffer;
      *((_QWORD *)this + 150) = skip_input_data;
      *((_QWORD *)this + 151) = _cg_jpeg_resync_to_restart;
      *((_QWORD *)this + 152) = term_source;
      *((_QWORD *)this + 146) = (char *)this + 1264;
      *((_QWORD *)this + 147) = 0;
      v23 = (IIOImageReadSession *)*((_QWORD *)this + 3);
      *((_BYTE *)this + 1232) = v13 != 1;
      *((_QWORD *)this + 155) = *((_QWORD *)this + 24);
      v24 = (IIOImageRead *)*((_QWORD *)this + 58);
      *((_QWORD *)this + 153) = v23;
      if (!v24)
        v24 = IIOImageReadSession::getSize(v23);
      *((_QWORD *)this + 156) = v24;
      *((_QWORD *)this + 68) = (char *)this + 1168;
      if (v229 == 1297108768 || v229 == 1346981191 || !*((_QWORD *)this + 24))
      {
        _cg_jpeg_save_markers((_QWORD *)this + 63, 226, 0xFFFFu);
        _cg_jpeg_save_markers((_QWORD *)this + 63, 225, 0xFFFFu);
        _cg_jpeg_save_markers((_QWORD *)this + 63, 225, 0xFFFFu);
        _cg_jpeg_save_markers((_QWORD *)this + 63, 237, 0xFFFFu);
        _cg_jpeg_save_markers((_QWORD *)this + 63, 254, 0xFFFFu);
      }
      v25 = v231;
      v26 = v230;
      header = _cg_jpeg_read_header((uint64_t)this + 504, 1);
      if (header == 1)
      {
        v44 = v10;
        v45 = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
        v46 = IIO_Reader::minimumFileSize(*((IIO_Reader **)this + 3));
        result = LibJPEGReadPlugin::validateJPEG((IIOImageReadSession **)this);
        if ((_DWORD)result)
          return result;
        IIOImageReadSession::seek(*((IIOImageReadSession **)this + 3), v46, 0);
        if (v46 > (unint64_t)v45)
        {
          v47 = Uint32ForKey;
LABEL_258:
          result = *((_QWORD *)this + 2);
          if (result)
          {
            IIOImagePlus::setJpegProvider(result, v47);
            return 0;
          }
          return result;
        }
        v228 = (const __CFDictionary *)v3;
        if (*(_BYTE *)(*((_QWORD *)this + 63) + 44))
          v49 = 0;
        else
          v49 = Uint32ForKey;
        BoolForKey = IIODictionary::getBoolForKey(v4, CFSTR("kCGImageSourceAddJPEGQualityInformation"));
        if (BoolForKey)
          LibJPEGReadPlugin::readQualityPropertiesFromJPEG(BoolForKey, (uint64_t)this + 504, v232);
        v50 = 1;
        v48 = 0;
        v10 = v44;
        v25 = v231;
        v26 = v230;
      }
      else
      {
        if (!header)
        {
          if (!*((_QWORD *)this + 24))
          {
            readJFIFData((uint64_t)this + 504, v232);
            if ((v231 & 1) != 0)
            {
              v29 = copyRenderingInfo((uint64_t)this + 504);
              CGImageMetadataMerge(v3, (uint64_t)v29, 0);
              if (!v29)
                return 4294967246;
            }
            else
            {
              ExifData = LibJPEGReadPlugin::readExifData(v28, (uint64_t)this + 504, v4);
              CGImageMetadataMerge(v3, (uint64_t)ExifData, v4);
              if ((v230 & 1) != 0)
              {
                v105 = 0;
                v29 = 0;
              }
              else
              {
                APP13 = LibJPEGReadPlugin::readAPP13((uint64_t)this, (uint64_t)this + 504);
                XMPData = LibJPEGReadPlugin::readXMPData((uint64_t)this, (uint64_t)this + 504, theData);
                CGImageMetadataMerge(v3, (uint64_t)APP13, v4);
                CGImageMetadataMerge(v3, (uint64_t)XMPData, v4);
                v105 = APP13;
                v29 = XMPData;
              }
              if (ExifData)
                CFRelease(ExifData);
              if (v105)
                CFRelease(v105);
              if (!v29)
                return 4294967246;
            }
            CFRelease(v29);
          }
          return 4294967246;
        }
        v228 = (const __CFDictionary *)v3;
        v48 = 4294967246;
        v49 = Uint32ForKey;
        v50 = 0;
      }
      v52 = *((_DWORD *)this + 141) - 1;
      if (v52 >= 5)
      {
        LogError("initialize", 1704, "Unsupported jpeg colorspace %d\n", *((_DWORD *)this + 141));
        goto LABEL_76;
      }
      v53 = dword_18821133C[v52];
      *((_DWORD *)this + 2414) = v53;
      *((_DWORD *)this + 142) = v53;
      v54 = *((unsigned int *)this + 138);
      v55 = *((unsigned int *)this + 139);
      *((_QWORD *)this + 60) = v54;
      *((_QWORD *)this + 61) = v55;
      v56 = *((unsigned __int16 *)this + 280);
      if (v49 >= 2)
      {
        if ((unint64_t)v49 < 8)
        {
          if ((unint64_t)v49 < 4)
            v57 = 2;
          else
            v57 = 4;
        }
        else
        {
          v57 = 8;
        }
        *((_WORD *)this + 158) = v57;
        v49 = v57;
        goto LABEL_162;
      }
      if (*((unsigned __int8 *)this + 216) >= 2u)
      {
        v101 = *((_DWORD *)this + 53);
        if (v101)
        {
          if (v54 <= v55)
            v102 = v55;
          else
            v102 = v54;
          if (v101 >= v102)
            v101 = v102;
          *((_DWORD *)this + 53) = v101;
          if (v101 <= (v54 + 7) >> 3 || v101 <= (v55 + 7) >> 3)
          {
            v103 = 8;
          }
          else if (v101 <= (v54 + 3) >> 2 || v101 <= (v55 + 3) >> 2)
          {
            v103 = 4;
          }
          else
          {
            if (v101 > (v54 + 1) >> 1 && v101 > (v55 + 1) >> 1)
              goto LABEL_162;
            v103 = 2;
          }
        }
        else
        {
          v103 = 1;
        }
        *((_WORD *)this + 158) = v103;
      }
LABEL_162:
      v227 = v49;
      v108 = *((unsigned __int16 *)this + 158);
      v109 = v108 - 2;
      if (v108 >= 2)
      {
        *((_DWORD *)this + 150) = 1;
        v110 = 8;
        *((_DWORD *)this + 144) = 8;
        if (v109 <= 6)
          v110 = dword_188211350[(__int16)v109];
        *((_DWORD *)this + 143) = v110;
        LODWORD(v54) = (v108 - 1 + v54) / v108;
        LODWORD(v55) = (v108 - 1 + v55) / v108;
      }
      if ((double)(v54 * v55) / (double)*((unint64_t *)this + 23) < 1000.0)
      {
        *((_DWORD *)this + 57) = v54;
        *((_DWORD *)this + 58) = v55;
        *((_WORD *)this + 120) = 8;
        *((_WORD *)this + 121) = 8 * v56;
        *((_WORD *)this + 122) = v56;
        v111 = v54 * v56;
        *((_DWORD *)this + 59) = v111;
        *((_BYTE *)this + 246) = 0;
        *((_BYTE *)this + 344) = 0;
        *((_BYTE *)this + 346) = 0;
        *((_DWORD *)this + 67) = v111;
        *((_QWORD *)this + 45) = 1;
        readJFIFData((uint64_t)this + 504, v232);
        v226 = v25;
        if ((v25 & 1) != 0)
        {
          if (!*((_QWORD *)this + 2))
            goto LABEL_180;
          v113 = copyRenderingInfo((uint64_t)this + 504);
          Metadata = IIOImagePlus::getMetadata(*((IIOImagePlus **)this + 2));
          CGImageMetadataMerge(Metadata, (uint64_t)v113, 0);
          v115 = v113;
          if (!v113)
            goto LABEL_180;
        }
        else
        {
          v238 = v10;
          v116 = LibJPEGReadPlugin::readExifData(v112, (uint64_t)this + 504, v4);
          v117 = *((_QWORD *)this + 8);
          CGImageMetadataMerge(v117, (uint64_t)v116, v4);
          if ((v26 & 1) != 0)
          {
            v118 = 0;
            v119 = 0;
          }
          else
          {
            v120 = LibJPEGReadPlugin::readAPP13((uint64_t)this, (uint64_t)this + 504);
            v121 = LibJPEGReadPlugin::readXMPData((uint64_t)this, (uint64_t)this + 504, theData);
            CGImageMetadataMerge(v117, (uint64_t)v120, v4);
            CGImageMetadataMerge(v117, (uint64_t)v121, v4);
            v118 = v120;
            v119 = v121;
          }
          v10 = v238;
          if (v116)
            CFRelease(v116);
          if (v118)
            CFRelease(v118);
          v115 = v119;
          if (!v119)
          {
LABEL_180:
            if (!*((_DWORD *)this + 223) || *((_DWORD *)this + 140) != 4 || *((_BYTE *)this + 896) == 1)
              goto LABEL_193;
            if (*((_BYTE *)this + 896))
            {
              if (v10 && (v236 != 1 || *((_DWORD *)this + 141) == 5))
                goto LABEL_193;
            }
            else
            {
              if (v236 == 1)
                v122 = 0;
              else
                v122 = v10;
              if ((v122 & 1) != 0)
              {
LABEL_193:
                if (*((_DWORD *)this + 205))
                  IIODictionary::setObjectForKeyGroup(v232, (const void *)*MEMORY[0x1E0C9AE50], CFSTR("IsProgressive"), CFSTR("{JFIF}"));
                v123 = *((_DWORD *)this + 2414);
                switch(v123)
                {
                  case 1:
                    v124 = 1196573017;
                    break;
                  case 2:
                    v124 = 1380401696;
                    break;
                  case 4:
                    v124 = 1129142603;
                    break;
                  default:
                    goto LABEL_202;
                }
                *((_DWORD *)this + 81) = v124;
LABEL_202:
                v125 = (uint64_t **)*((_QWORD *)this + 114);
                if (!v125)
                  goto LABEL_230;
                v126 = 0;
                v127 = 0;
                v128 = 0;
                do
                {
                  v129 = v127;
                  v130 = v126;
                  if (*((unsigned __int8 *)v125 + 8) == 226
                    && (v131 = *((unsigned int *)v125 + 4), v131 >= 0xF)
                    && ((v132 = v125[3],
                         v133 = *v132,
                         v134 = *(uint64_t *)((char *)v132 + 3),
                         v133 == 0x464F52505F434349)
                      ? (v135 = v134 == 0x454C49464F52505FLL)
                      : (v135 = 0),
                        v135))
                  {
                    v137 = v131 - 14;
                    v138 = v131 - 14;
                    if (v128)
                    {
                      if (v129 > 13 - v131)
                        goto LABEL_229;
                      v139 = (unsigned int *)reallocf(v128, v137 + v129);
                    }
                    else
                    {
                      v139 = (unsigned int *)malloc_type_malloc(v131 - 14, 0x55127D9DuLL);
                    }
                    v140 = v139;
                    if (!v139)
                      goto LABEL_230;
                    memcpy((char *)v139 + v130, (char *)v125[3] + 14, v138);
                    v130 += v137;
                    v129 = v130;
                    v136 = v140;
                  }
                  else
                  {
                    v136 = v128;
                  }
                  v125 = (uint64_t **)*v125;
                  v126 = v130;
                  v127 = v129;
                  v128 = v136;
                }
                while (v125);
                if (!v136)
                  goto LABEL_230;
                if (v129 >= 0x80)
                {
                  v141 = v136[9];
                  v142 = bswap32(*v136);
                  if (v129 < v142)
                    LogError("readICCData", 865, "Embedded profile header length is greater than data length.\n");
                  if (v141 == 1886610273)
                  {
                    if (v130 >= v142)
                    {
                      v143 = CGColorSpaceCreateWithCopyOfData((UInt8 *)v136, v130);
                      free(v136);
                      v144 = (CGColorSpaceRef)v143;
                      if (v143)
                        goto LABEL_248;
LABEL_230:
                      v145 = *((_DWORD *)this + 81);
                      if (v145 == 1380401696)
                      {
                        LOBYTE(v242[0]) = 0;
                        ColorSpaceFromMetadata = createColorSpaceFromMetadata(v228, v226, v242);
                        if (LOBYTE(v242[0]))
                          *((_WORD *)this + 164) = 1;
                        v144 = ColorSpaceFromMetadata;
                        if (ColorSpaceFromMetadata)
                          goto LABEL_248;
                        v145 = *((_DWORD *)this + 81);
                      }
                      switch(v145)
                      {
                        case 1129142603:
                          v151 = (CFStringRef *)MEMORY[0x1E0C9D968];
                          goto LABEL_247;
                        case 1196573017:
                          v151 = (CFStringRef *)MEMORY[0x1E0C9D978];
                          goto LABEL_247;
                        case 1380401696:
                          TopLevelTag = CGImageMetadataGetTopLevelTag(v228, (uint64_t)CFSTR("http://ns.adobe.com/exif/1.0/"), (uint64_t)CFSTR("ColorSpace"));
                          if (!TopLevelTag
                            || (Value = (const __CFString *)CGImageMetadataTagGetValue((uint64_t)TopLevelTag)) == 0)
                          {
                            v151 = (CFStringRef *)MEMORY[0x1E0C9DA10];
                            goto LABEL_247;
                          }
                          IntValue = CFStringGetIntValue(Value);
                          v150 = (CFStringRef *)MEMORY[0x1E0C9DA10];
                          v151 = (CFStringRef *)MEMORY[0x1E0C9DA10];
                          if (IntValue != 1)
                          {
LABEL_247:
                            v144 = CGColorSpaceCreateWithName(*v151);
                            break;
                          }
                          v144 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
                          if (!v144)
                          {
                            v151 = v150;
                            goto LABEL_247;
                          }
                          break;
                        default:
                          v144 = 0;
                          break;
                      }
LABEL_248:
                      if (!v240
                        || *((_QWORD *)this + 24)
                        || !*((_BYTE *)this + 341)
                        || *((_BYTE *)this + 216) != 1
                        || v227
                        || *((_DWORD *)this + 141) != 3
                        || *((int *)this + 230) > 2
                        || *((int *)this + 231) > 2)
                      {
                        if (*((_BYTE *)this + 341) || *((_BYTE *)this + 216) != 1)
                        {
                          *((_QWORD *)this + 20) = v144;
                          _cg_jpeg_destroy_decompress((char *)this + 504);
                          *((_BYTE *)this + 9661) = 0;
                          *((_WORD *)this + 188) = 1;
                        }
                        else
                        {
                          *((_QWORD *)this + 20) = v144;
                          *((_BYTE *)this + 9661) = 1;
                          *((_BYTE *)this + 448) = 2;
                          *((_WORD *)this + 188) = 1;
                        }
                        v152 = (IIOImagePlus *)*((_QWORD *)this + 2);
                        if (v152 && IIOImagePlus::sourceImageProvider(v152))
                          CGImageProviderSetProperty();
                        v47 = v227;
                        goto LABEL_258;
                      }
                      v153 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D978]);
                      memset(v245, 0, 128);
                      memset(v244, 0, sizeof(v244));
                      memset(v243, 0, sizeof(v243));
                      *(_OWORD *)v242 = 0u;
                      v241[0] = v242;
                      v241[1] = v244;
                      v241[2] = v245;
                      v154 = (unsigned int *)*((_QWORD *)this + 101);
                      v155 = 0.0;
                      if (*((_DWORD *)this + 230) == 2)
                      {
                        if (*((_DWORD *)this + 231) == 1)
                          v155 = 0.5;
                        else
                          v155 = 0.0;
                      }
                      space = v153;
                      *((_DWORD *)this + 149) = 1;
                      v156 = v154[11];
                      v157 = v154[12];
                      v158 = ImageIOAlignRowBytes(v156, 0x10uLL);
                      v159 = (char *)malloc_type_calloc(v158, v157 + 15, 0x281BD07EuLL);
                      v160 = v159;
                      if (v159)
                      {
                        v224 = v157;
                        data = v159;
                        v161 = v154[35];
                        v162 = v154[36];
                        v163 = ImageIOAlignRowBytes(v161, 0x10uLL);
                        v222 = v162;
                        v164 = (char *)malloc_type_calloc(v163, v162 + 15, 0xE739715AuLL);
                        v165 = v164;
                        if (!v164)
                        {
                          v185 = 0;
                          v195 = 0;
                          v187 = 0;
                          v196 = 0;
                          v169 = 0;
                          v197 = 0;
                          v193 = 0;
                          v190 = 0;
                          v160 = data;
                          goto LABEL_302;
                        }
                        v221 = v161;
                        width = v156;
                        v217 = v164;
                        v166 = v154[60];
                        v219 = v154[59];
                        v200 = v154;
                        v167 = ImageIOAlignRowBytes(v219, 0x10uLL);
                        v220 = v166;
                        v168 = (CGImage *)malloc_type_calloc(v167, v166 + 15, 0x2864B59CuLL);
                        v169 = v168;
                        if (!v168)
                        {
                          v185 = 0;
                          v195 = 0;
                          v187 = 0;
                          v196 = 0;
                          v197 = 0;
                          v193 = 0;
                          v190 = 0;
                          v160 = data;
                          v165 = v217;
                          goto LABEL_302;
                        }
                        v214 = v158;
                        v215 = v168;
                        bytesPerRow = v163;
                        v170 = 8 * *((_DWORD *)this + 231);
                        v212 = 8 * v200[3];
                        v210 = 8 * v200[27];
                        v211 = v200[3];
                        v209 = v200[27];
                        v207 = v200[51];
                        v208 = 8 * v207;
                        _cg_jpeg_start_decompress((uint64_t)this + 504);
                        if (v212 <= 1)
                          v171 = 1;
                        else
                          v171 = v212;
                        if (v210 <= 1)
                          v172 = 1;
                        else
                          v172 = v210;
                        if (v208 <= 1)
                          v173 = 1;
                        else
                          v173 = v208;
                        v205 = v171;
                        v204 = v172;
                        v203 = v173;
                        do
                        {
                          v174 = *((_DWORD *)this + 168);
                          if (v174 >= *((_DWORD *)this + 161))
                            break;
                          if (v211)
                          {
                            v175 = v242;
                            v176 = v205;
                            v177 = 0;
                            do
                            {
                              *v175++ = (IIOImageReadSession *)&v160[v158 * (v177 + (int)(v174 * v212 / v170))];
                              ++v177;
                              --v176;
                            }
                            while (v176);
                          }
                          if (v209)
                          {
                            v178 = v204;
                            v179 = v244;
                            v180 = 0;
                            do
                            {
                              *v179++ = &v165[v163 * (v180 + (int)(v174 * v210 / v170))];
                              ++v180;
                              --v178;
                            }
                            while (v178);
                          }
                          if (v207)
                          {
                            v181 = (int)(v174 * v208 / v170);
                            v182 = v203;
                            v183 = v245;
                            v184 = 0;
                            do
                            {
                              *v183++ = (char *)v169 + v167 * (v184 + v181);
                              ++v184;
                              --v182;
                            }
                            while (v182);
                          }
                        }
                        while (_cg_jpeg_read_raw_data((uint64_t)this + 504, (uint64_t)v241, v170) >= v170);
                        _cg_jpeg_destroy_decompress((char *)this + 504);
                        v185 = 0;
                        v160 = data;
                        v186 = CGDataProviderCreateWithData(0, data, v158 * v224, (CGDataProviderReleaseDataCallback)releaseData);
                        if (v186)
                        {
                          cf = v186;
                          v187 = 0;
                          v165 = v217;
                          v188 = CGDataProviderCreateWithData(0, v217, v163 * v222, (CGDataProviderReleaseDataCallback)releaseData);
                          if (v188)
                          {
                            v189 = v188;
                            v165 = 0;
                            v190 = v215;
                            v191 = CGDataProviderCreateWithData(0, v215, v167 * v220, (CGDataProviderReleaseDataCallback)releaseData);
                            if (v191)
                            {
                              provider = v191;
                              v206 = CGImageCreate(width, v224, 8uLL, 8uLL, v214, space, 0, cf, 0, 1, kCGRenderingIntentDefault);
                              v169 = CGImageCreate(v221, v222, 8uLL, 8uLL, bytesPerRow, space, 0, v189, 0, 1, kCGRenderingIntentDefault);
                              v192 = CGImageCreate(v219, v220, 8uLL, 8uLL, v167, space, 0, provider, 0, 1, kCGRenderingIntentDefault);
                              if (v206 && v169)
                              {
                                if (v192)
                                {
                                  CGImageSetProperty();
                                  CGImageSetProperty();
                                  CGImageSetProperty();
                                  CGImageSetProperty();
                                  CGImageSetProperty();
                                  CGImageSetProperty();
                                  v193 = 0;
                                  CGImageRefFromYCbCrData = (CGImage *)g_ciGetCGImageRefFromYCbCrData(v206, v169, v192, v144, 0, v155, 0.0);
                                  if (CGImageRefFromYCbCrData)
                                  {
                                    v193 = CGImageRefFromYCbCrData;
                                    IIOImagePlus::setImage(*((CGImageRef **)this + 2), CGImageRefFromYCbCrData);
                                    v185 = cf;
                                    v195 = v189;
                                    v187 = provider;
                                    v196 = v206;
                                    v197 = v192;
                                    v165 = 0;
                                    v190 = 0;
                                    v160 = 0;
                                  }
                                  else
                                  {
                                    v185 = cf;
                                    v195 = v189;
                                    v187 = provider;
                                    v196 = v206;
                                    v197 = v192;
                                    v160 = 0;
                                    v165 = 0;
                                    v190 = 0;
                                  }
                                  goto LABEL_302;
                                }
                                v185 = cf;
                                v195 = v189;
                              }
                              else
                              {
                                v185 = cf;
                                v195 = v189;
                              }
                              v187 = provider;
                              v196 = v206;
                              v197 = v192;
                              v193 = 0;
                              v160 = 0;
                              v165 = 0;
                              v190 = 0;
                            }
                            else
                            {
                              v185 = cf;
                              v195 = v189;
                              v196 = 0;
                              v169 = 0;
                              v197 = 0;
                              v193 = 0;
                              v160 = 0;
                              v187 = 0;
                            }
LABEL_302:
                            v202 = v190;
                            v198 = v197;
                            v199 = v195;
                            if (space)
                              CGColorSpaceRelease(space);
                            if (v193)
                              CFRelease(v193);
                            if (v196)
                              CFRelease(v196);
                            if (v185)
                              CFRelease(v185);
                            if (v160)
                              free(v160);
                            if (v169)
                              CFRelease(v169);
                            if (v199)
                              CFRelease(v199);
                            if (v165)
                              free(v165);
                            if (v198)
                              CFRelease(v198);
                            if (v187)
                              CFRelease(v187);
                            if (v202)
                              free(v202);
                            v47 = 0;
                            goto LABEL_258;
                          }
                          v195 = 0;
                          v185 = cf;
                          v196 = 0;
                          v169 = 0;
                          v197 = 0;
                          v193 = 0;
                          v160 = 0;
                        }
                        else
                        {
                          v195 = 0;
                          v187 = 0;
                          v196 = 0;
                          v169 = 0;
                          v197 = 0;
                          v193 = 0;
                          v165 = v217;
                        }
                        v190 = v215;
                        goto LABEL_302;
                      }
                      v185 = 0;
                      v195 = 0;
                      v187 = 0;
                      v196 = 0;
                      v169 = 0;
                      v197 = 0;
                      v193 = 0;
                      v165 = 0;
                      v190 = 0;
                      goto LABEL_302;
                    }
                  }
                  else
                  {
                    LogError("readICCData", 867, "Embedded profile signature is not valid.\n");
                  }
                }
                v128 = v136;
LABEL_229:
                free(v128);
                goto LABEL_230;
              }
            }
            *((_BYTE *)this + 346) = 1;
            goto LABEL_193;
          }
        }
        CFRelease(v115);
        goto LABEL_180;
      }
      _cg_jpeg_mem_term("initialize", 1761, "malformed JPEG?\n");
LABEL_76:
      v47 = v49;
      result = v48;
      if (!v50)
        return result;
      goto LABEL_258;
    }
  }
  return result;
}

void readJFIFData(uint64_t a1, IIODictionary *a2)
{
  IIONumber *v4;
  IIONumber *v5;
  unint64_t v6;
  int v7;
  float v8;
  float v9;
  unint64_t v10;
  _BYTE v11[24];
  _BYTE v12[24];
  _BYTE v13[24];
  _BYTE v14[24];
  _BYTE v15[24];
  _BYTE v16[16];
  const void *v17;
  CFMutableArrayRef v18;
  const void *v19;
  uint64_t v20;

  if (a1 && a2 && *(_DWORD *)(a1 + 376))
  {
    v18 = 0;
    v19 = 0;
    v20 = 0;
    IIOArray::IIOArray((IIOArray *)&v18);
    IIONumber::IIONumber((IIONumber *)v16, *(unsigned __int8 *)(a1 + 380));
    IIOArray::addObject(&v18, v17);
    IIONumber::~IIONumber((IIONumber *)v16);
    IIONumber::IIONumber(v4, *(unsigned __int8 *)(a1 + 381) >> 4);
    IIOArray::addObject(&v18, v17);
    IIONumber::~IIONumber((IIONumber *)v16);
    IIONumber::IIONumber(v5, *(_BYTE *)(a1 + 381) & 0xF);
    IIOArray::addObject(&v18, v17);
    IIONumber::~IIONumber((IIONumber *)v16);
    IIODictionary::setObjectForKeyGroup(a2, v19, CFSTR("JFIFVersion"), CFSTR("{JFIF}"));
    IIOArray::~IIOArray((IIOArray *)&v18);
    IIONumber::IIONumber((IIONumber *)v15, *(unsigned __int16 *)(a1 + 384));
    IIODictionary::setObjectForKeyGroup(a2, (uint64_t)v15, CFSTR("XDensity"), CFSTR("{JFIF}"));
    IIONumber::~IIONumber((IIONumber *)v15);
    IIONumber::IIONumber((IIONumber *)v14, *(unsigned __int16 *)(a1 + 386));
    IIODictionary::setObjectForKeyGroup(a2, (uint64_t)v14, CFSTR("YDensity"), CFSTR("{JFIF}"));
    IIONumber::~IIONumber((IIONumber *)v14);
    IIONumber::IIONumber((IIONumber *)v13, *(unsigned __int8 *)(a1 + 382));
    IIODictionary::setObjectForKeyGroup(a2, (uint64_t)v13, CFSTR("DensityUnit"), CFSTR("{JFIF}"));
    IIONumber::~IIONumber((IIONumber *)v13);
    v7 = *(unsigned __int8 *)(a1 + 382);
    if (v7 == 2)
    {
      LOWORD(v6) = *(_WORD *)(a1 + 384);
      *(double *)&v10 = (double)v6 * 2.54;
      v8 = *(double *)&v10;
      LOWORD(v10) = *(_WORD *)(a1 + 386);
      v9 = (double)v10 * 2.54;
    }
    else
    {
      v8 = 0.0;
      v9 = 0.0;
      if (v7 == 1)
      {
        LOWORD(v6) = *(_WORD *)(a1 + 384);
        v8 = (float)v6;
        LOWORD(v6) = *(_WORD *)(a1 + 386);
        v9 = (float)v6;
      }
    }
    if (ValidDPI(v8) && ValidDPI(v9))
    {
      IIONumber::IIONumber((IIONumber *)v12, v8);
      IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v12, CFSTR("DPIWidth"));
      IIONumber::~IIONumber((IIONumber *)v12);
      IIONumber::IIONumber((IIONumber *)v11, v9);
      IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v11, CFSTR("DPIHeight"));
      IIONumber::~IIONumber((IIONumber *)v11);
    }
  }
}

void sub_187FD923C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

CGMutableImageMetadataRef copyRenderingInfo(uint64_t a1)
{
  uint64_t *v1;
  CGMutableImageMetadataRef result;
  unsigned int v3;
  uint64_t v4;

  v1 = *(uint64_t **)(a1 + 408);
  if (!v1)
    return 0;
  result = 0;
  do
  {
    if (*((unsigned __int8 *)v1 + 8) == 225)
    {
      v3 = *((_DWORD *)v1 + 4);
      if (v3 >= 0xB)
      {
        v4 = v1[3];
        if (*(_BYTE *)v4 == 69
          && *(_BYTE *)(v4 + 1) == 120
          && *(_BYTE *)(v4 + 2) == 105
          && *(_BYTE *)(v4 + 3) == 102
          && !*(_BYTE *)(v4 + 4)
          && !*(_BYTE *)(v4 + 5))
        {
          result = CreateMetadataFromDatabuffer((const char *)(v4 + 6), v3 - 6, 3);
        }
      }
    }
    v1 = (uint64_t *)*v1;
  }
  while (v1);
  return result;
}

void releaseData(void *a1, void *a2)
{
  free(a2);
}

uint64_t LibJPEGReadPlugin::copyImageBlockSetJPEGTiles(uint64_t a1, const void *a2, const void *a3, const __CFDictionary *a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  double v16;
  double v17;
  double v19;
  double v20;
  double v21;
  double v22;
  unsigned int PixelSize;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  unsigned int v35;
  double v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int v39;
  unsigned int v40;
  double v41;
  uint32x2_t v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  IIOImageRead **v46;
  int v47;
  unsigned int v48;
  unint64_t v49;
  int v50;
  int scanlines;
  BOOL v52;
  unsigned int v53;
  char v54;
  uint64_t v55;
  unsigned int v56;
  unsigned int v57;
  double v58;
  int v59;
  double v60;
  double y;
  unsigned int v62;
  unsigned int v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  double x;
  double v70;
  double width;
  unsigned int v72;
  uint64_t v73;
  unsigned int v74;
  uint64_t v75;
  unsigned int v76;
  CGFloat height;
  uint64_t v78;
  char v79;
  uint64_t v80;
  unsigned int v81;
  double v82;
  unsigned int v83;
  double v84;
  uint64_t v85;
  int v86;
  double v87;
  double v88;
  double v89;
  int v90;
  const char **v91;
  double v93;
  double v94;
  unsigned int v95;
  unsigned int v96;
  uint64_t v97;
  uint64_t v98;
  int v99;
  unsigned int v100;
  unsigned int v101;
  unsigned int v102;
  double v103;
  uint64_t v104;
  char *valuePtr;
  void *value;
  unint64_t v108;
  void *v109;
  void *v110;
  CGRect v111;
  CGRect v112;
  CGRect v113;
  CGRect v114;
  CGRect v115;

  v16 = a6;
  v17 = a5;
  v110 = 0;
  v109 = 0;
  v108 = 0;
  value = 0;
  if (a3)
  {
    CGImageProviderGetSize();
    v20 = v19;
    v22 = v21;
    PixelSize = CGImageProviderGetPixelSize();
    v24 = v22;
  }
  else
  {
    LODWORD(a5) = *(_DWORD *)(a1 + 292);
    v20 = (double)*(unint64_t *)&a5;
    LODWORD(a6) = *(_DWORD *)(a1 + 296);
    v24 = (double)*(unint64_t *)&a6;
    if (*(_WORD *)(a1 + 308) == 3)
    {
      if (*(_BYTE *)(a1 + 310))
        PixelSize = 4;
      else
        PixelSize = 3;
    }
    else
    {
      PixelSize = *(unsigned __int16 *)(a1 + 308);
    }
  }
  v103 = v24;
  if (a4)
    CFDictionaryGetValueIfPresent(a4, (const void *)*MEMORY[0x1E0C9DAC8], (const void **)&value);
  v94 = a8;
  v25 = a8;
  v26 = a7;
  v27 = v16;
  v28 = v17;
  if (value)
  {
    valuePtr = 0;
    v29 = a7;
    v30 = a10;
    v31 = a9;
    v32 = v25;
    v93 = v16;
    v33 = v26;
    v34 = v27;
    CFNumberGetValue((CFNumberRef)value, kCFNumberLongType, &valuePtr);
    v28 = v17;
    v27 = v34;
    v26 = v33;
    v16 = v93;
    v25 = v32;
    a9 = v31;
    a10 = v30;
    a7 = v29;
    if (valuePtr <= 0x40)
      v35 = 64;
    else
      v35 = valuePtr;
  }
  else
  {
    v35 = 256;
  }
  v36 = (double)(v35 - 1);
  v37 = ((v17 + a7 + v36) / (double)v35);
  v38 = (v16 / (double)v35);
  v39 = ((v16 + v94 + v36) / (double)v35);
  *(_DWORD *)(a1 + 292) = v35;
  *(_DWORD *)(a1 + 296) = v35;
  *(_DWORD *)(a1 + 300) = v35 * PixelSize;
  v40 = (v37 - (v17 / (double)v35)) * (v39 - v38);
  *(_DWORD *)(a1 + 104) = v40;
  *(_WORD *)(a1 + 316) = 1;
  IIOReadPlugin::debugCopyBlockSet((const char *)a1, a3, v28, v27, v26, v25, a9, a10);
  v41 = (double)PixelSize;
  *(_DWORD *)(a1 + 236) = ((unint64_t)(a7 * (double)PixelSize) + 15) & 0xFFFFFFF0;
  v42 = vmin_u32((uint32x2_t)vdup_n_s32(v35), *(uint32x2_t *)(a1 + 228));
  *(uint32x2_t *)(a1 + 292) = v42;
  *(_DWORD *)(a1 + 300) = v42.i32[0] * PixelSize;
  *(_DWORD *)(a1 + 104) = v40;
  if (sigsetjmp((int *)(a1 + 9448), 0))
  {
    _cg_jpeg_mem_term("copyImageBlockSetJPEGTiles", 2302, "sigsetjmp");
    v43 = 0;
    v44 = 0;
    goto LABEL_74;
  }
  v100 = v39;
  v101 = v37;
  v102 = (v17 / (double)v35);
  v45 = a1 + 504;
  IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, *(unsigned int *)(a1 + 104));
  v46 = *(IIOImageRead ***)(a1 + 24);
  if (v46)
    LODWORD(v46) = IIOImageReadSession::mapData(v46);
  v47 = (int)v46;
  _cg_jpeg_destroy_decompress(a1 + 504);
  LibJPEGReadPlugin::startDecompressing(a1, *(_DWORD *)(a1 + 9656));
  *(_QWORD *)(a1 + 9648) = -1;
  if (*(_DWORD *)(a1 + 540) != 205)
  {
    v43 = 0;
    *(_DWORD *)(a1 + 104) = 0;
    v44 = v47;
    goto LABEL_74;
  }
  v48 = (v16 / (double)v35);
  v49 = ImageIOAlignRowBytes(*(_DWORD *)(a1 + 640) * PixelSize, 0x10uLL);
  v109 = malloc_type_malloc(v49 * *(unsigned int *)(a1 + 296), 0xC0C0BF88uLL);
  v104 = (uint64_t)a3;
  v99 = v47;
  if (!v38)
    goto LABEL_27;
  v50 = v35 * v38;
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("    skipping rows %4d through %4d\n", 0, v35 * v38);
  valuePtr = (char *)v109;
  if (v50)
  {
    do
    {
      scanlines = _cg_jpeg_read_scanlines(a1 + 504, (uint64_t)&valuePtr, 1);
      --v50;
    }
    while (v50);
    v52 = scanlines == 1;
    v48 = (v16 / (double)v35);
  }
  else
  {
LABEL_27:
    v52 = 0;
  }
  if (v100 <= v38)
  {
LABEL_70:
    v43 = 0;
    if (v104 && *(_DWORD *)(a1 + 104))
      v43 = IIOReadPlugin::imageBlockSetCreate(a1, v104, *(unsigned int *)(a1 + 104), v20, v103, *(double *)(a1 + 120), *(double *)(a1 + 128), *(double *)(a1 + 136), *(double *)(a1 + 144), *(_QWORD *)(a1 + 96), a2);
    v44 = v99;
    goto LABEL_74;
  }
  v98 = v35;
  v97 = PixelSize;
  v53 = v48;
  v54 = v52;
  v55 = 0;
  while (1)
  {
    v95 = v35;
    v96 = v53;
    v56 = *(_DWORD *)(a1 + 296);
    v57 = v56 * v96;
    v58 = (double)(v56 * v96);
    v59 = *(_DWORD *)(a1 + 292);
    if ((double)v56 + v58 <= v103)
      v60 = (double)v56;
    else
      v60 = v103 - (double)v57;
    y = v60 + v58;
    v62 = (v60 + v58);
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("                   reading rows: %d ... %d\n", v57, v62 - 1);
    if (v57 < v62)
    {
      v63 = v57;
      v64 = 0;
      while (1)
      {
        valuePtr = (char *)v109 + v64;
        if (_cg_jpeg_read_scanlines(v45, (uint64_t)&valuePtr, 1) != 1)
          goto LABEL_55;
        ++v63;
        v64 += v49;
        if (v63 >= v62)
          goto LABEL_41;
      }
    }
    if ((v54 & 1) != 0)
      break;
LABEL_55:
    if (v96 + 1 < *(_DWORD *)(a1 + 116))
      *(_DWORD *)(a1 + 104) = v96 + 1 - *(_DWORD *)(a1 + 112);
    v80 = v95 - v57;
    if ((_DWORD)v80)
    {
      v81 = v95 - v57;
      LODWORD(y) = v59;
      v82 = (double)*(unint64_t *)&y;
      v83 = (v41 * (double)*(unint64_t *)&y);
      *(_DWORD *)(a1 + 300) = v83;
      if ((gIIODebugFlags & 0x30000) != 0)
      {
        ImageIOLog("                     valid rows: %ld\n", v80);
        v83 = *(_DWORD *)(a1 + 300);
      }
      v84 = (double)v80;
      v113.origin.x = 0.0;
      v113.origin.y = v58;
      v113.size.width = v82;
      v113.size.height = (double)v80;
      *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8 * v55) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, v110, v108, v113, v83, 0);
      if (CGRectEqualToRect(*(CGRect *)(a1 + 120), *MEMORY[0x1E0C9D628]))
      {
        v85 = 0;
      }
      else
      {
        v115.origin.x = 0.0;
        v115.origin.y = v58;
        v115.size.width = v82;
        v115.size.height = (double)v80;
        *(CGRect *)&v85 = CGRectUnion(*(CGRect *)(a1 + 120), v115);
        v58 = v87;
        v82 = v88;
        v84 = v89;
      }
      v79 = 0;
      ++v55;
      *(_QWORD *)(a1 + 120) = v85;
      *(double *)(a1 + 128) = v58;
      *(double *)(a1 + 136) = v82;
      *(double *)(a1 + 144) = v84;
    }
    else
    {
      v86 = *(_DWORD *)(a1 + 104);
      if (v86)
        *(_DWORD *)(a1 + 104) = v86 - 1;
      _ImageIO_Free((unint64_t)v110, v108);
      v110 = 0;
      v79 = 0;
      v81 = 0;
    }
LABEL_69:
    v35 = v81;
    v54 = v79;
    v53 = v96 + 1;
    if (v96 + 1 == v100)
      goto LABEL_70;
  }
LABEL_41:
  if (v101 <= v102)
  {
    v79 = 1;
LABEL_63:
    v81 = v95;
    goto LABEL_69;
  }
  v65 = v102;
  v66 = v55;
  while (1)
  {
    v67 = v65;
    v68 = v65 * v98;
    x = (double)(unint64_t)(v65 * v98);
    LODWORD(y) = *(_DWORD *)(a1 + 292);
    v70 = (double)*(unint64_t *)&y;
    width = x + v70 <= v20 ? v70 : v20 - x;
    v72 = (width * v41);
    v110 = (void *)_ImageIO_Malloc(*(unsigned int *)(a1 + 296) * (unint64_t)v72, *(_QWORD *)(a1 + 384), &v108, (uint64_t)kImageMalloc_LIBJPEG_Data[0], *(_DWORD *)(a1 + 432), 0, 0);
    if (!v110)
      break;
    v73 = v45;
    if (v60 > 0.0)
    {
      v74 = 0;
      v75 = v68 * v97;
      v76 = 0;
      do
      {
        memcpy((char *)v110 + v74, (char *)v109 + v49 * v76++ + v75, (width * v41));
        v74 += v72;
      }
      while (v60 > (double)v76);
    }
    *(_DWORD *)(a1 + 300) = v72;
    v111.origin.x = x;
    v111.origin.y = v58;
    v111.size.width = width;
    v111.size.height = v60;
    *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8 * v66) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, v110, v108, v111, (width * v41), 0);
    if (CGRectEqualToRect(*(CGRect *)(a1 + 120), *MEMORY[0x1E0C9D628]))
    {
      y = v58;
      height = v60;
    }
    else
    {
      v114.size.height = v60;
      v114.origin.y = v58;
      v114.origin.x = x;
      v114.size.width = width;
      v112 = CGRectUnion(*(CGRect *)(a1 + 120), v114);
      x = v112.origin.x;
      width = v112.size.width;
      y = v112.origin.y;
      height = v112.size.height;
    }
    v45 = v73;
    v78 = v66 + 1;
    *(double *)(a1 + 120) = x;
    *(double *)(a1 + 128) = y;
    *(double *)(a1 + 136) = width;
    *(CGFloat *)(a1 + 144) = height;
    v65 = v67 + 1;
    ++v66;
    if (v67 + 1 == v101)
    {
      v79 = 1;
      v55 = v78;
      goto LABEL_63;
    }
  }
  v44 = v99;
  v43 = 0;
LABEL_74:
  v90 = v44;
  if (v109)
    free(v109);
  if (v90)
  {
    v91 = *(const char ***)(a1 + 24);
    if (v91)
      IIOImageReadSession::unmapData(v91);
  }
  return v43;
}

uint64_t LibJPEGReadPlugin::copyImageBlockSetProgressive(uint64_t a1, const void *a2, const void *a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  unint64_t v9;
  double v11;
  double v14;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  unsigned int PixelSize;
  unsigned int v25;
  double v26;
  double v27;
  unsigned int v28;
  __int16 v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  int v37;
  int v38;
  __int16 v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unsigned int v44;
  unsigned int v45;
  unsigned int v46;
  unsigned int v47;
  unsigned int v48;
  unsigned int v49;
  unint64_t v50;
  unsigned int v51;
  unsigned int v52;
  char *v53;
  int v54;
  unsigned int v55;
  BOOL v56;
  unsigned int v57;
  int v58;
  BOOL v59;
  uint64_t v60;
  uint64_t v61;
  double v62;
  double v63;
  uint64_t v64;
  _BYTE *v66;
  int v67;
  unint64_t i;
  double v69;
  const void *v72;
  char *v73;
  unint64_t v74;
  void *v75;
  CGRect v76;
  CGRect v77;

  v11 = a8;
  v14 = a9;
  v75 = 0;
  v74 = 0;
  if (a3)
  {
    v17 = a8;
    v18 = a7;
    v19 = a5;
    v20 = a4;
    CGImageProviderGetSize();
    v22 = v21;
    v69 = v23;
    PixelSize = CGImageProviderGetPixelSize();
    a4 = v20;
    a5 = v19;
    a7 = v18;
    a8 = v17;
    v14 = a9;
    v25 = PixelSize;
    v26 = v69;
  }
  else
  {
    LODWORD(v9) = *(_DWORD *)(a1 + 292);
    v22 = (double)v9;
    LODWORD(v9) = *(_DWORD *)(a1 + 296);
    v26 = (double)v9;
    if (*(_WORD *)(a1 + 308) == 3)
    {
      if (*(_BYTE *)(a1 + 310))
        v25 = 4;
      else
        v25 = 3;
    }
    else
    {
      v25 = *(unsigned __int16 *)(a1 + 308);
    }
  }
  v27 = v22;
  IIOReadPlugin::debugCopyBlockSet((const char *)a1, a3, a4, a5, a6, a7, a8, v14);
  v28 = *(unsigned __int16 *)(a1 + 316);
  v29 = *(_WORD *)(a1 + 316);
  v30 = *(_QWORD *)(a1 + 228);
  v72 = a2;
  if (!*(_BYTE *)(a1 + 348))
    goto LABEL_28;
  if (v28 <= 1)
    v31 = 1;
  else
    v31 = *(unsigned __int16 *)(a1 + 316);
  v32 = v31 * (unint64_t)v22;
  v33 = v31 * (unint64_t)v26;
  if (v11 > (double)(v32 >> 3) || a9 > (double)(v33 >> 3))
  {
    if (v11 <= (double)(v32 >> 2) && a9 <= (double)(v33 >> 2))
    {
      if (v28 == 4)
      {
        v37 = 8;
        goto LABEL_29;
      }
      v39 = 4;
      v40 = 4;
      v41 = 3;
      goto LABEL_36;
    }
    if (v11 <= (double)(v32 >> 1) && a9 <= (double)(v33 >> 1) && v28 != 2)
    {
      v39 = 2;
      v40 = 2;
      v41 = 1;
      goto LABEL_36;
    }
LABEL_28:
    v37 = *(unsigned __int16 *)(a1 + 316);
LABEL_29:
    v38 = 0;
    goto LABEL_37;
  }
  if (v28 == 8)
  {
    v37 = 8;
    goto LABEL_29;
  }
  v40 = 8;
  v41 = 7;
  v39 = 8;
LABEL_36:
  *(_WORD *)(a1 + 316) = v39;
  v42 = (uint64_t)(v32 + v41) / v40;
  v27 = (double)v42;
  v43 = (uint64_t)(v33 + v41) / v40;
  v26 = (double)v43;
  v38 = 1;
  *(_DWORD *)(a1 + 228) = v42;
  *(_DWORD *)(a1 + 232) = v43;
  v37 = 8;
LABEL_37:
  v44 = *(_DWORD *)(a1 + 572);
  if (v44)
    v45 = *(_DWORD *)(a1 + 576) / v44;
  else
    v45 = 1;
  if (v45 <= 1)
    v46 = 1;
  else
    v46 = v45;
  v47 = *(_DWORD *)(a1 + 552);
  if (v46 <= v47)
    v48 = v47 / v46;
  else
    v48 = 1;
  v49 = *(_DWORD *)(a1 + 560);
  v50 = v49 * (unint64_t)v48;
  if ((v50 & 0xFFFFFFFF00000000) == 0)
  {
    if (v37 || (v51 = *(_DWORD *)(a1 + 300), v50 <= v51))
    {
      v52 = ((unint64_t)(a6 * (double)v25) + 15) & 0xFFFFFFF0;
      *(_DWORD *)(a1 + 300) = v52;
      v75 = (void *)_ImageIO_Malloc(*(unsigned int *)(a1 + 296) * (unint64_t)v52, *(_QWORD *)(a1 + 384), &v74, (uint64_t)kImageMalloc_LIBJPEG_Data[0], *(_DWORD *)(a1 + 432), 0, 0);
      v53 = (char *)v75;
      if (sigsetjmp((int *)(a1 + 9448), 0))
      {
        _cg_jpeg_mem_term("copyImageBlockSetProgressive", 2617, "sigsetjmp\n");
        if (v75 && *(_DWORD *)(a1 + 9312) == 20 && *(_DWORD *)(a1 + 540) == 205)
          v75 = 0;
      }
      else
      {
        _cg_jpeg_destroy_decompress(a1 + 504);
        v54 = *(_DWORD *)(a1 + 9656);
        _cg_jpeg_CreateDecompress((char *)(a1 + 504), 90, 664);
        *(_QWORD *)(a1 + 544) = a1 + 1168;
        _cg_jpeg_read_header(a1 + 504, 1);
        v55 = *(unsigned __int16 *)(a1 + 316);
        v56 = v55 >= 2;
        v57 = v55 - 2;
        if (v56)
        {
          *(_DWORD *)(a1 + 600) = 1;
          v58 = 8;
          *(_DWORD *)(a1 + 576) = 8;
          if (v57 <= 6)
            v58 = dword_188211350[(__int16)v57];
          *(_DWORD *)(a1 + 572) = v58;
        }
        *(_DWORD *)(a1 + 568) = v54;
        *(_DWORD *)(a1 + 592) = 1;
        if (*(int *)(a1 + 540) >= 202)
          _cg_jpeg_start_decompress(a1 + 504);
        if (!*(_BYTE *)(a1 + 9660))
        {
          v66 = (_BYTE *)(a1 + 9660);
          while (_cg_jpeg_consume_input((uint64_t *)(a1 + 504)))
          {
            v67 = *(_DWORD *)(a1 + 540);
            if (v67 == 202)
            {
              if (!_cg_jpeg_start_decompress(a1 + 504))
                break;
              v67 = *(_DWORD *)(a1 + 540);
            }
            if (v67 == 208)
            {
              if (!_cg_jpeg_finish_output(a1 + 504))
                break;
              v67 = *(_DWORD *)(a1 + 540);
            }
            if (v67 == 207)
            {
              if (!_cg_jpeg_start_output(a1 + 504, *(_DWORD *)(a1 + 676)))
                break;
              v67 = *(_DWORD *)(a1 + 540);
            }
            if (v67 == 205)
            {
              for (i = *(unsigned int *)(a1 + 672); i < *(unsigned int *)(a1 + 644); i = *(unsigned int *)(a1 + 672))
              {
                v73 = &v53[i * (((unint64_t)(a6 * (double)v25) + 15) & 0xFFFFFFF0)];
                if (!_cg_jpeg_read_scanlines(a1 + 504, (uint64_t)&v73, 1))
                  goto LABEL_63;
              }
              _cg_jpeg_finish_output(a1 + 504);
            }
            if (_cg_jpeg_input_complete(a1 + 504))
            {
              if (*(_DWORD *)(a1 + 676) == *(_DWORD *)(a1 + 684))
              {
                *v66 = 1;
                _cg_jpeg_destroy_decompress(a1 + 504);
                if (*(_QWORD *)(a1 + 1224))
                  *(_QWORD *)(a1 + 1224) = 0;
              }
            }
            if (*v66)
              break;
          }
        }
      }
    }
    else
    {
      _cg_jpeg_mem_term("copyImageBlockSetProgressive", 2593, "*** ERROR: unexpected JPEG dimension: %d x %d (%d components) - blockSize: %d x %d (rb: %d)\n", v47, *(_DWORD *)(a1 + 556), v49, *(_DWORD *)(a1 + 292), *(_DWORD *)(a1 + 296), v51);
    }
  }
LABEL_63:
  if (!v75)
    goto LABEL_69;
  *(_DWORD *)(a1 + 104) = 1;
  IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, 1uLL);
  v59 = CGRectEqualToRect(*(CGRect *)(a1 + 120), *MEMORY[0x1E0C9D628]);
  v60 = 0;
  v61 = 0;
  v62 = v27;
  v63 = v26;
  if (!v59)
  {
    v77.origin.x = 0.0;
    v77.origin.y = 0.0;
    v77.size.width = v27;
    v77.size.height = v26;
    *(CGRect *)&v60 = CGRectUnion(*(CGRect *)(a1 + 120), v77);
  }
  *(_QWORD *)(a1 + 120) = v60;
  *(_QWORD *)(a1 + 128) = v61;
  *(double *)(a1 + 136) = v62;
  *(double *)(a1 + 144) = v63;
  v76.origin.x = 0.0;
  v76.origin.y = 0.0;
  v76.size.width = v27;
  v76.size.height = v26;
  **(_QWORD **)(a1 + 96) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, v75, v74, v76, *(unsigned int *)(a1 + 300), 0);
  if (!a3)
  {
LABEL_69:
    v64 = 0;
    if (!v38)
      goto LABEL_71;
    goto LABEL_70;
  }
  v64 = IIOReadPlugin::imageBlockSetCreate(a1, (uint64_t)a3, *(unsigned int *)(a1 + 104), v27, v26, *(double *)(a1 + 120), *(double *)(a1 + 128), *(double *)(a1 + 136), *(double *)(a1 + 144), *(_QWORD *)(a1 + 96), v72);
  if (v38)
  {
LABEL_70:
    *(_WORD *)(a1 + 316) = v29;
    *(_QWORD *)(a1 + 228) = v30;
  }
LABEL_71:
  if (a3)
    IIOReadPlugin::freeBlockArray((IIOReadPlugin *)a1);
  return v64;
}

uint64_t LibJPEGReadPlugin::copyImageBlockSetStandard(uint64_t a1, const void *a2, const void *a3, const __CFDictionary *a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  double v16;
  double v17;
  uint64_t v20;
  double v21;
  double v22;
  double v23;
  double v24;
  unsigned int PixelSize;
  uint64_t v26;
  __int16 v27;
  _BOOL4 v28;
  int v29;
  unsigned int v30;
  int v31;
  __int128 v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t v40;
  uint64_t v41;
  double v42;
  uint64_t v43;
  uint64_t v44;
  double v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  int v60;
  _BOOL4 v61;
  unsigned int v62;
  unsigned int v63;
  unsigned int v64;
  uint64_t v65;
  unsigned int v66;
  unint64_t v67;
  double v68;
  double v69;
  double v70;
  IIOImageRead **v71;
  _BOOL4 v72;
  _BOOL4 v73;
  _BOOL4 v74;
  unint64_t v75;
  int v76;
  int v77;
  int i;
  int scanlines;
  BOOL v80;
  char v81;
  unsigned int v82;
  uint64_t v83;
  uint64_t v84;
  char v85;
  uint64_t v86;
  int v87;
  uint64_t v88;
  uint64_t v89;
  unsigned int v90;
  unsigned int v91;
  double v92;
  double v93;
  double v94;
  unint64_t v95;
  unint64_t v96;
  unint64_t v97;
  int v98;
  const void *v99;
  int v100;
  unint64_t v101;
  size_t v102;
  char v103;
  char *v104;
  double v105;
  unsigned int v106;
  double v107;
  unint64_t v108;
  unint64_t v109;
  uint64_t v110;
  uint64_t v111;
  int v112;
  char v113;
  uint64_t v114;
  unint64_t v115;
  uint64_t v116;
  uint64_t v117;
  double v118;
  double v119;
  int v120;
  unsigned int v121;
  int v122;
  uint64_t v123;
  double v124;
  uint64_t v125;
  double v126;
  double v127;
  double v128;
  uint64_t v129;
  int v130;
  _BOOL4 v131;
  __int128 v132;
  const char **v133;
  int v135;
  double v136;
  double v137;
  uint64_t v138;
  uint64_t v139;
  unsigned int v140;
  _BOOL4 v141;
  int v142;
  int v143;
  int v144;
  __int16 v145;
  uint64_t v146;
  void *value;
  __int128 v148;
  __int128 v149;
  size_t v150;
  void *v151;
  char *v152;
  CGRect v153;
  CGRect v154;
  CGRect v155;
  CGRect v156;

  v16 = a6;
  v17 = a5;
  v152 = 0;
  v151 = 0;
  v150 = 0;
  v20 = a1 + 504;
  HIDWORD(a5) = 0;
  v148 = 0u;
  v149 = 0u;
  if (a3)
  {
    CGImageProviderGetSize();
    v22 = v21;
    v24 = v23;
    PixelSize = CGImageProviderGetPixelSize();
  }
  else
  {
    LODWORD(a5) = *(_DWORD *)(a1 + 292);
    v22 = (double)*(unint64_t *)&a5;
    LODWORD(a6) = *(_DWORD *)(a1 + 296);
    v24 = (double)*(unint64_t *)&a6;
    if (*(_WORD *)(a1 + 308) == 3)
    {
      if (*(_BYTE *)(a1 + 310))
        PixelSize = 4;
      else
        PixelSize = 3;
    }
    else
    {
      PixelSize = *(unsigned __int16 *)(a1 + 308);
    }
  }
  v26 = 0;
  v27 = 0;
  if (a7 == 0.0)
  {
    v28 = 0;
    v29 = 0;
    goto LABEL_165;
  }
  v28 = 0;
  v29 = 0;
  if (a8 == 0.0)
    goto LABEL_165;
  v136 = a9;
  if (a4)
  {
    value = 0;
    CFDictionaryGetValueIfPresent(a4, (const void *)*MEMORY[0x1E0C9DAC8], (const void **)&value);
    if (value)
    {
      v26 = LibJPEGReadPlugin::copyImageBlockSetJPEGTiles(a1, a2, a3, a4, v17, v16, a7, a8, a9, a10);
      if (v26)
      {
        v29 = 0;
        v27 = 0;
        v28 = 0;
        goto LABEL_165;
      }
    }
  }
  v137 = a10;
  v30 = *(unsigned __int16 *)(a1 + 316);
  if (*(_BYTE *)(a1 + 348))
  {
    v31 = *(unsigned __int16 *)(a1 + 308);
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("RB  multi-res: original subsampleFactor: %d\n", *(unsigned __int16 *)(a1 + 316));
    v32 = *(_OWORD *)(a1 + 300);
    v148 = *(_OWORD *)(a1 + 284);
    v149 = v32;
    if (v30 <= 1)
      v33 = 1;
    else
      v33 = v30;
    v34 = v33;
    v35 = v33 * (unint64_t)v22;
    v36 = v34 * (unint64_t)v24;
    if (a9 > (double)(v35 >> 3) || a10 > (double)(v36 >> 3))
    {
      if (a9 > (double)(v35 >> 2) || a10 > (double)(v36 >> 2))
      {
        if (a9 <= (double)(v35 >> 1) && a10 <= (double)(v36 >> 1) && v30 != 2)
        {
          if ((uint64_t)(v35 + 1) >= 0)
            v40 = v35 + 1;
          else
            v40 = v35 + 2;
          v41 = v40 >> 1;
          v42 = (double)v41;
          if ((uint64_t)(v36 + 1) >= 0)
            v43 = v36 + 1;
          else
            v43 = v36 + 2;
          v44 = v43 >> 1;
          v45 = (double)v44;
          *(_WORD *)(a1 + 316) = 2;
          *(_DWORD *)(a1 + 292) = v41;
          *(_DWORD *)(a1 + 296) = v44;
          *(_DWORD *)(a1 + 300) = (((_DWORD)v41 << (2 * (v31 != 1))) + 15) & 0xFFFFFFF0;
          if ((gIIODebugFlags & 0x30000) != 0)
            ImageIOLog("RB  multi-res: new subsampleFactor 2:  rb=%d\n");
          goto LABEL_58;
        }
      }
      else if (v30 != 4)
      {
        v53 = v35 + 3;
        v54 = v35 + 6;
        if (v53 >= 0)
          v54 = v53;
        v55 = v36 + 3;
        v56 = v36 + 6;
        if (v55 >= 0)
          v56 = v55;
        v57 = v54 >> 2;
        v42 = (double)v57;
        v58 = v56 >> 2;
        v45 = (double)v58;
        *(_WORD *)(a1 + 316) = 4;
        *(_DWORD *)(a1 + 292) = v57;
        *(_DWORD *)(a1 + 296) = v58;
        *(_DWORD *)(a1 + 300) = (((_DWORD)v57 << (2 * (v31 != 1))) + 15) & 0xFFFFFFF0;
        if ((gIIODebugFlags & 0x30000) != 0)
          ImageIOLog("RB  multi-res: new subsampleFactor 4:  rb=%d\n");
        goto LABEL_58;
      }
    }
    else if (v30 != 8)
    {
      v46 = v35 + 7;
      v47 = v35 + 14;
      if (v46 >= 0)
        v47 = v46;
      v48 = v36 + 7;
      v49 = v36 + 14;
      if (v48 >= 0)
        v49 = v48;
      v50 = v47 >> 3;
      v42 = (double)v50;
      v51 = v49 >> 3;
      v45 = (double)v51;
      *(_WORD *)(a1 + 316) = 8;
      *(_DWORD *)(a1 + 292) = v50;
      *(_DWORD *)(a1 + 296) = v51;
      *(_DWORD *)(a1 + 300) = (((_DWORD)v50 << (2 * (v31 != 1))) + 15) & 0xFFFFFFF0;
      if ((gIIODebugFlags & 0x30000) != 0)
        ImageIOLog("RB  multi-res: new subsampleFactor 8:  rb=%d\n");
LABEL_58:
      v52 = 1;
      goto LABEL_59;
    }
  }
  v52 = 0;
  v45 = v24;
  v42 = v22;
LABEL_59:
  v59 = v52;
  v27 = v30;
  IIOReadPlugin::debugCopyBlockSet((const char *)a1, a3, v17, v16, a7, a8, v136, v137);
  CGImageProviderGetPixelSize();
  if ((ImageIOShouldAllowFullsizeDecode() & 1) == 0 && *(_BYTE *)(a1 + 408) == 1)
  {
    _cg_jpeg_mem_term("copyImageBlockSetStandard", 2902, "Rejecting singleton request - image is too large");
    goto LABEL_180;
  }
  *(_DWORD *)(a1 + 300) = ((unint64_t)(v42 * (double)PixelSize) + 15) & 0xFFFFFFF0;
  v60 = *(_DWORD *)(a1 + 112);
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("                      blockSize: {%d, %d}\n", *(_DWORD *)(a1 + 292), *(_DWORD *)(a1 + 296));
  if (sigsetjmp((int *)(a1 + 9448), 0))
  {
    _cg_jpeg_mem_term("copyImageBlockSetStandard", 2927, "sigsetjmp");
    goto LABEL_65;
  }
  v62 = *(_DWORD *)(a1 + 572);
  if (v62)
    v63 = *(_DWORD *)(a1 + 576) / v62;
  else
    v63 = 1;
  if (v63 <= 1)
    v64 = 1;
  else
    v64 = v63;
  v65 = *(unsigned int *)(a1 + 552);
  if (v64 <= v65)
    v66 = v65 / v64;
  else
    v66 = 1;
  v67 = *(unsigned int *)(a1 + 560) * (unint64_t)v66;
  if ((v67 & 0xFFFFFFFF00000000) != 0)
  {
LABEL_180:
    v26 = 0;
    v28 = 0;
    goto LABEL_164;
  }
  if (v67 > *(_DWORD *)(a1 + 300) && *(unsigned __int16 *)(a1 + 316) <= 1u)
  {
    _cg_jpeg_mem_term("copyImageBlockSetStandard", 2942, "*** ERROR: unexpected JPEG dimension: %d x %d (%d components) - blockSize: %d x %d (rb: %d)\n", v65);
LABEL_65:
    v61 = 0;
LABEL_66:
    if (!v152)
    {
      v26 = 0;
      v28 = v61;
      goto LABEL_164;
    }
    _ImageIO_Free((unint64_t)v152, v150);
    v28 = v61;
    v29 = v59;
    v26 = 0;
    goto LABEL_165;
  }
  IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, *(unsigned int *)(a1 + 104));
  if (!IIOReadPlugin::getCachedBlocks((IIOReadPlugin *)a1, v68, v69, v70))
  {
    v73 = 0;
    goto LABEL_160;
  }
  v71 = *(IIOImageRead ***)(a1 + 24);
  if (v71)
    v72 = IIOImageReadSession::mapData(v71);
  else
    v72 = 0;
  v74 = v72;
  _cg_jpeg_destroy_decompress(v20);
  LibJPEGReadPlugin::startDecompressing(a1, *(_DWORD *)(a1 + 9656));
  *(_QWORD *)(a1 + 9648) = -1;
  if (*(_DWORD *)(a1 + 540) != 205)
  {
    v26 = 0;
    *(_DWORD *)(a1 + 104) = 0;
    v28 = v74;
    goto LABEL_164;
  }
  v151 = malloc_type_malloc(*(unsigned int *)(a1 + 236), 0xD9BBBB4uLL);
  v76 = *(_DWORD *)(a1 + 112);
  v142 = v60;
  if (v76)
  {
    v77 = *(_DWORD *)(a1 + 296) * v76;
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("    skipping rows %4d through %4d\n", 0, v77);
    if (v77)
    {
      v143 = v59;
      for (i = 0; i != v77; ++i)
      {
        scanlines = _cg_jpeg_read_scanlines(v20, (uint64_t)&v151, 1);
        v80 = scanlines == 1;
        if (scanlines != 1)
          _cg_jpeg_mem_term("copyImageBlockSetStandard", 2991, "*** jpeg_read_scanlines at row %d\n", i);
      }
      v81 = v80;
      v59 = v143;
      v60 = v142;
    }
    else
    {
      v81 = 0;
    }
  }
  else
  {
    v81 = 0;
  }
  v146 = v20;
  if ((gIIODebugFlags & 0x30000) != 0)
  {
    ImageIOLog("                     startBlock: %d\n", *(_DWORD *)(a1 + 112));
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("                       endBlock: %d\n", *(_DWORD *)(a1 + 116));
  }
  v82 = *(_DWORD *)(a1 + 112);
  if (v82 >= *(_DWORD *)(a1 + 116))
  {
LABEL_143:
    v73 = v74;
    v20 = v146;
    goto LABEL_160;
  }
  v83 = 0;
  v84 = *(unsigned int *)(a1 + 112);
  v144 = v59;
  v145 = v27;
  v141 = v74;
  while (1)
  {
    v85 = v81;
    v86 = v84;
    v140 = v82;
    v87 = v84;
    v88 = (v84 - v60);
    v89 = v88;
    if (*(_QWORD *)(*(_QWORD *)(a1 + 96) + 8 * v88))
      _cg_jpeg_mem_term("copyImageBlockSetStandard", 3015, "*** _blockArray[%d] was cached - and already allocated\n", v88);
    v138 = v89;
    v90 = *(_DWORD *)(a1 + 296);
    v91 = v90 * v87;
    v92 = (double)(v90 * v87);
    LODWORD(v75) = *(_DWORD *)(a1 + 556);
    v93 = (double)v75;
    if ((double)v90 + v92 <= v93)
      v94 = (double)v90;
    else
      v94 = v93 - (double)v91;
    v95 = *(int *)(a1 + 648);
    if (!is_mul_ok(*(unsigned int *)(a1 + 640), v95)
      || (v96 = *(unsigned int *)(a1 + 640) * v95, v97 = *(unsigned int *)(a1 + 644), !is_mul_ok(v97, v96)))
    {
      v26 = 0;
      v28 = v141;
      v29 = v144;
      v27 = v145;
      v20 = v146;
      goto LABEL_165;
    }
    v98 = *(_DWORD *)(a1 + 296);
    v99 = a2;
    v100 = *(_DWORD *)(a1 + 292);
    v101 = *(unsigned int *)(a1 + 300) * (unint64_t)v90;
    v102 = v97 * v96;
    if (v97 * v96 <= v101)
      v102 = *(unsigned int *)(a1 + 300) * (unint64_t)v90;
    else
      _cg_jpeg_mem_term("copyImageBlockSetStandard", 3037, "*** ERROR: libJPEGBufferSize > imageDataBufferSize   (%lld > %lld)\n", v102, v101);
    v152 = (char *)_ImageIO_Malloc(v102, *(_QWORD *)(a1 + 384), &v150, (uint64_t)kImageMalloc_LIBJPEG_Data[0], *(_DWORD *)(a1 + 432), 0, 0);
    if (!v152)
    {
      v61 = v141;
      v20 = v146;
      v59 = v144;
      v27 = v145;
      goto LABEL_66;
    }
    v135 = v87;
    v103 = v85;
    v139 = v86;
    v104 = v152;
    v105 = v94 + v92;
    v106 = (v94 + v92);
    if (*(unsigned __int16 *)(a1 + 316) >= 2u)
    {
      if (*(_DWORD *)(a1 + 644) >= (v94 + v92))
        v106 = (v94 + v92);
      else
        v106 = *(_DWORD *)(a1 + 644);
    }
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("                   reading rows: %d ... %d\n", v91, v106 - 1);
    LODWORD(v105) = v100;
    v107 = (double)*(unint64_t *)&v105;
    if (v91 >= v106)
    {
      v114 = v83;
      a2 = v99;
      v74 = v141;
      v60 = v142;
      if ((v103 & 1) == 0)
        goto LABEL_145;
LABEL_134:
      v115 = *(unsigned int *)(a1 + 300);
      v116 = v114;
      goto LABEL_137;
    }
    v108 = (unint64_t)&v104[v102];
    v109 = *(unsigned int *)(a1 + 300);
    value = v152;
    if ((unint64_t)v152 < v108)
      break;
    v113 = v103;
LABEL_136:
    a2 = v99;
    v74 = v141;
    v60 = v142;
    v116 = v83;
    v115 = v109;
    if ((v113 & 1) == 0)
      goto LABEL_145;
LABEL_137:
    v83 = v116;
    v153.origin.x = 0.0;
    v153.origin.y = (double)v91;
    v153.size.width = v107;
    v153.size.height = v94;
    *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8 * v138) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, v152, v150, v153, v115, *(unsigned __int8 *)(a1 + 343));
    v59 = v144;
    v27 = v145;
    if (CGRectEqualToRect(*(CGRect *)(a1 + 120), *MEMORY[0x1E0C9D628]))
    {
      v117 = 0;
    }
    else
    {
      v155.origin.x = 0.0;
      v155.origin.y = v92;
      v155.size.width = v107;
      v155.size.height = v94;
      *(CGRect *)(&v75 - 2) = CGRectUnion(*(CGRect *)(a1 + 120), v155);
      v92 = v118;
      v107 = *(double *)&v75;
      v94 = v119;
    }
    *(_QWORD *)(a1 + 120) = v117;
    *(double *)(a1 + 128) = v92;
    *(double *)(a1 + 136) = v107;
    *(double *)(a1 + 144) = v94;
    v84 = v139 + 1;
    v82 = v140 + 1;
    v81 = 1;
    if (v139 + 1 >= (unint64_t)*(unsigned int *)(a1 + 116))
      goto LABEL_143;
  }
  v110 = 1;
  while (_cg_jpeg_read_scanlines(v146, (uint64_t)&value, 1) == 1)
  {
    if (*(_BYTE *)(a1 + 341))
    {
      v111 = *(_QWORD *)(a1 + 16);
      if (v111)
        IIOImagePlus::setStatus(v111, (CGImageSourceStatus)-6);
      *(_BYTE *)(a1 + 343) = 0;
    }
    if (v98 * v140 + v110 >= v106)
    {
      v114 = v106 - 1;
      a2 = v99;
      v74 = v141;
      v60 = v142;
      goto LABEL_134;
    }
    v109 = *(unsigned int *)(a1 + 300);
    value = &v152[v110 * v109];
    v112 = ++v110;
    if ((unint64_t)value >= v108)
    {
      v83 = v112 + v98 * v140 - 2;
      v113 = 1;
      goto LABEL_136;
    }
  }
  LODWORD(v83) = v110 + v98 * v140 - 1;
  a2 = v99;
  v74 = v141;
LABEL_145:
  v120 = v83;
  v73 = v74;
  if (v83 <= v91)
    v121 = 0;
  else
    v121 = v91;
  if ((v135 + 1) < *(_DWORD *)(a1 + 116))
    *(_DWORD *)(a1 + 104) = v135 + 1 - *(_DWORD *)(a1 + 112);
  v20 = v146;
  v59 = v144;
  v27 = v145;
  if (v120 == v121)
  {
    v122 = *(_DWORD *)(a1 + 104);
    if (v122)
      *(_DWORD *)(a1 + 104) = v122 - 1;
    _ImageIO_Free((unint64_t)v152, v150);
    v152 = 0;
  }
  else
  {
    v123 = v120 - v121;
    v124 = (double)v123;
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("                     valid rows: %ld\n", v123);
    v154.origin.x = 0.0;
    v154.origin.y = v92;
    v154.size.width = v107;
    v154.size.height = v124;
    *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8 * v138) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, v152, v150, v154, *(unsigned int *)(a1 + 300), 0);
    if (CGRectEqualToRect(*(CGRect *)(a1 + 120), *MEMORY[0x1E0C9D628]))
    {
      v125 = 0;
    }
    else
    {
      v156.origin.x = 0.0;
      v156.origin.y = v92;
      v156.size.width = v107;
      v156.size.height = v124;
      *(CGRect *)&v125 = CGRectUnion(*(CGRect *)(a1 + 120), v156);
      v92 = v126;
      v107 = v127;
      v124 = v128;
    }
    *(_QWORD *)(a1 + 120) = v125;
    *(double *)(a1 + 128) = v92;
    *(double *)(a1 + 136) = v107;
    *(double *)(a1 + 144) = v124;
  }
LABEL_160:
  v26 = 0;
  if (a3 && *(_DWORD *)(a1 + 104))
    v26 = IIOReadPlugin::imageBlockSetCreate(a1, (uint64_t)a3, *(unsigned int *)(a1 + 104), v42, v45, *(double *)(a1 + 120), *(double *)(a1 + 128), *(double *)(a1 + 136), *(double *)(a1 + 144), *(_QWORD *)(a1 + 96), a2);
  v28 = v73;
LABEL_164:
  v29 = v59;
LABEL_165:
  v129 = v26;
  v130 = v29;
  v131 = v28;
  _cg_jpeg_destroy_decompress(v20);
  if (v151)
    free(v151);
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("<<< copyImageBlockSetJPEG\n\n");
  if (a3)
    IIOReadPlugin::freeBlockArray((IIOReadPlugin *)a1);
  if (v130)
  {
    v132 = v149;
    *(_OWORD *)(a1 + 284) = v148;
    *(_OWORD *)(a1 + 300) = v132;
    *(_WORD *)(a1 + 316) = v27;
  }
  if (v131)
  {
    v133 = *(const char ***)(a1 + 24);
    if (v133)
      IIOImageReadSession::unmapData(v133);
  }
  return v129;
}

uint64_t LibJPEGReadPlugin::copyImageBlockSetImp(uint64_t a1, const void *a2, const void *a3, uint64_t a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  *(_BYTE *)(a1 + 343) = 0;
  if (a4)
    return 0;
  if (*(_BYTE *)(a1 + 448) == 2)
    return LibJPEGReadPlugin::copyImageBlockSetProgressive(a1, a2, a3, a5, a6, a7, a8, a9, a10);
  return LibJPEGReadPlugin::copyImageBlockSetStandard(a1, a2, a3, 0, a5, a6, a7, a8, a9, a10);
}

void sub_187FDAFDC(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187FDAFB0);
}

uint64_t LibJPEGReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  int v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  unsigned int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t result;

  if ((gIIODebugFlags & 0x20000) != 0)
  {
    v10 = *((_DWORD *)this + 51);
    v11 = v10 >> 24;
    v12 = MEMORY[0x1E0C80978];
    if (v10 < 0)
    {
      v13 = __maskrune(v11, 0x40000uLL);
      v10 = *((_DWORD *)this + 51);
    }
    else
    {
      v13 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v11 + 60) & 0x40000;
    }
    if (v13)
      v14 = (v10 >> 24);
    else
      v14 = 46;
    v15 = v10 << 8 >> 24;
    if (v10 << 8 < 0)
    {
      v16 = __maskrune(v15, 0x40000uLL);
      v10 = *((_DWORD *)this + 51);
    }
    else
    {
      v16 = *(_DWORD *)(v12 + 4 * v15 + 60) & 0x40000;
    }
    if (v16)
      v17 = (v10 << 8 >> 24);
    else
      v17 = 46;
    v18 = (__int16)v10 >> 8;
    if (v10 << 16 < 0)
    {
      v19 = __maskrune(v18, 0x40000uLL);
      v10 = *((_DWORD *)this + 51);
    }
    else
    {
      v19 = *(_DWORD *)(v12 + 4 * v18 + 60) & 0x40000;
    }
    if (v19)
      v20 = ((__int16)v10 >> 8);
    else
      v20 = 46;
    if ((v10 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v12 + 4 * (char)v10 + 60) & 0x40000) != 0)
        goto LABEL_22;
    }
    else if (__maskrune((char)v10, 0x40000uLL))
    {
LABEL_22:
      v21 = *((char *)this + 204);
LABEL_25:
      ImageIOLog("  '%c%c%c%c' [%s] %s\n", v14, v17, v20, v21, iioTypeStr[a3], "virtual OSStatus LibJPEGReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      goto LABEL_26;
    }
    v21 = 46;
    goto LABEL_25;
  }
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  if (a3 != 3)
    return 4294967246;
  v22 = *((_QWORD *)a2 + 1);
  v23 = *((_QWORD *)a2 + 2);
  v24 = *((double *)a2 + 3);
  v25 = *((double *)a2 + 4);
  v26 = *((double *)a2 + 5);
  v27 = *((double *)a2 + 6);
  v28 = *((double *)a2 + 7);
  v29 = *((double *)a2 + 8);
  v30 = IIOImageSource::reader(a2);
  v31 = (*(uint64_t (**)(IIOReadPlugin *, uint64_t, uint64_t, uint64_t, double, double, double, double, double, double))(*(_QWORD *)this + 200))(this, v22, v23, v30, v24, v25, v26, v27, v28, v29);
  if (!a6)
    return 4294967246;
  v32 = v31;
  result = 0;
  *a6 = v32;
  return result;
}

unint64_t *unpack_etc2_block(unint64_t *result, uint64_t a2)
{
  unint64_t v2;
  unsigned int v3;
  uint32x2_t v4;
  int8x8_t v5;
  int8x8_t v6;
  int v7;
  int v8;
  int v9;
  unint64_t v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t i;
  uint64_t v16;
  uint64_t v17;

  v2 = *result;
  HIDWORD(v17) = HIDWORD(*result);
  v3 = v2 >> 25;
  *(_DWORD *)a2 = 0;
  *(_BYTE *)(a2 + 11) = (v2 & 0x2000000) != 0;
  *(_BYTE *)(a2 + 10) = BYTE3(v2) & 1;
  *(_BYTE *)(a2 + 8) = v2 >> 29;
  *(_BYTE *)(a2 + 9) = (v2 >> 26) & 7;
  if (((v2 >> 25) & 1) == 0)
  {
    v4 = (uint32x2_t)vdup_n_s32(v2);
    v5.i32[0] = v2 >> 20;
    v5.i32[1] = WORD1(v2);
    v6 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v4, (uint32x2_t)0x800000004), (int8x8_t)0xF0000000F00), vand_s8((int8x8_t)vshl_u32(v4, (uint32x2_t)0xFFFFFFFCFFFFFFF8), (int8x8_t)0xF0000000F0)), vand_s8(v5, (int8x8_t)0xF0000000FLL));
    *(_WORD *)(a2 + 6) = v6.i16[2];
    *(_WORD *)(a2 + 4) = v6.i16[0];
LABEL_3:
    v7 = 1;
    goto LABEL_21;
  }
  *(_WORD *)(a2 + 4) = ((_WORD)v2 << 7) & 0x7C00 | ((unsigned __int16)v2 >> 6) & 0xFFE0 | (v2 >> 19) & 0x1F;
  *(_WORD *)(a2 + 6) = ((_WORD)v2 << 6) & 0x1C0 | (v2 >> 5) & 0x38 | BYTE2(v2) & 7;
  if ((v2 & 4) != 0)
    v8 = -8;
  else
    v8 = 0;
  if ((v2 & 0x40000) != 0)
    v9 = -8;
  else
    v9 = 0;
  if ((v2 >> 3) + (v2 & 7) + v8 <= 0x1F)
  {
    if (((v2 >> 8) & 4) != 0)
      v11 = -8;
    else
      v11 = 0;
    if (((unsigned __int16)v2 >> 11) + ((v2 >> 8) & 7) + v11 <= 0x1F)
    {
      if (((v2 >> 19) & 0x1F) + (WORD1(v2) & 7) + v9 > 0x1F)
      {
        *(_DWORD *)a2 = 3;
        *(_BYTE *)(a2 + 4) = (v2 >> 1) & 0x3F;
        *(_BYTE *)(a2 + 5) = ((_BYTE)v2 << 6) & 0x40 | (v2 >> 9) & 0x3F;
        *(_BYTE *)(a2 + 6) = BYTE2(v2) & 0x18 | ((v2 & 0x80000000) != 0) | (v2 >> 3) & 0x20 | (v2 >> 15) & 6;
        *(_BYTE *)(a2 + 7) = v3 & 0x3E | BYTE3(v2) & 1;
        *(_BYTE *)(a2 + 8) = (v2 >> 33) & 0x7F;
        *(_BYTE *)(a2 + 9) = (v2 >> 27) & 0x20 | (v2 >> 43) & 0x1F;
        *(_BYTE *)(a2 + 10) = (v2 >> 37) & 0x38 | (v2 >> 53) & 7;
        *(_BYTE *)(a2 + 11) = (v2 >> 46) & 0x7C | (v2 >> 62);
        *(_BYTE *)(a2 + 12) = HIBYTE(v2) & 0x3F;
        return result;
      }
      goto LABEL_3;
    }
    *(_DWORD *)a2 = 2;
    v12 = (32 * v2) & 0xF00 | (16 * ((v2 >> 12) & 1 | (2 * (v2 & 7)))) | (v2 >> 8) & 8 | (v2 >> 7) & 6 | (v2 >> 23) & 1;
    *(_WORD *)(a2 + 4) = (32 * v2) & 0xF00 | (16 * ((v2 >> 12) & 1 | (2 * (v2 & 7)))) | (v2 >> 8) & 8 | (v2 >> 7) & 6 | (v2 >> 23) & 1;
    v13 = (v2 >> 11) & 0xF00 | (16 * ((v2 >> 15) & 0xE | (v2 >> 31))) | (v2 >> 27) & 0xF;
    *(_WORD *)(a2 + 6) = (v2 >> 11) & 0xF00 | (16
                                                           * ((v2 >> 15) & 0xE | (v2 >> 31))) | (v2 >> 27) & 0xF;
    v14 = BYTE3(v2) & 4 | (v2 >> 23) & 2;
    *(_BYTE *)(a2 + 8) = v14;
    if (v12 >= v13)
    {
      v7 = 0;
      *(_BYTE *)(a2 + 8) = v14 | 1;
    }
    else
    {
      v7 = 0;
    }
  }
  else
  {
    v7 = 0;
    *(_DWORD *)a2 = 1;
    HIDWORD(v10) = v2 & 3 | (4 * ((v2 >> 3) & 3));
    LODWORD(v10) = (_DWORD)v2 << 16;
    *(_WORD *)(a2 + 4) = v10 >> 24;
    *(_WORD *)(a2 + 6) = (v2 >> 12) & 0xFF0 | (v2 >> 28);
    *(_BYTE *)(a2 + 8) = v3 & 6 | BYTE3(v2) & 1;
  }
LABEL_21:
  for (i = 0; i != 16; ++i)
  {
    v16 = (((unsigned __int8 *)&v17 - (i >> 3))[7] >> (i & 7)) & 1 | (2
                                                                                  * ((((unsigned __int8 *)&v17
                                                                                     - (i >> 3))[5] >> (i & 7)) & 1u));
    if (v7)
      LOBYTE(v16) = etc_selector_unscramble[v16];
    *(_BYTE *)(a2 + 14 + i) = v16;
  }
  return result;
}

void decode_etc2(uint64_t a1, __n128 *a2, int32x4_t a3, int32x4_t a4, double a5, __n128 a6)
{
  __n128 *v6;
  unint64_t v8;
  unsigned int v9;
  int32x2_t v10;
  int32x4_t v11;
  unint64_t v12;
  int v13;
  unsigned int v14;
  int v15;
  int8x8_t v16;
  int32x2_t v17;
  int v18;
  unsigned int v19;
  int32x4_t v20;
  int32x4_t v21;
  int32x4_t v22;
  int8x16_t v23;
  int32x4_t v24;
  uint64_t v25;
  int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  uint64_t v45;
  int8x16_t v46;
  float32x4_t v47;
  uint64_t v48;
  __n128 *v49;
  uint32x4_t v50;
  int32x4_t v51;
  uint64_t v52;
  const float *v53;
  int8x16_t v54;
  uint16x4_t v55;
  int32x4_t v56;
  int32x4_t v57;
  int32x4_t v58;
  int32x4_t v59;
  int8x16_t v60;
  int8x16_t v61;
  uint64_t v62;
  float32x4_t v63;
  uint64_t v64;
  int8x16_t *v65;
  uint32x4_t v66;
  int32x4_t v67;
  uint64_t v68;
  int v69;
  int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  int32x4_t v75;
  int32x4_t v76;
  int32x4_t v77;
  unsigned int v78;
  unsigned int v79;
  float32x4_t v80;
  unsigned int v86;
  float32x4_t v87;
  float32x4_t v88;
  float32x4_t v89;
  float *v90;
  uint64_t v91;
  uint64_t v92;
  int8x16_t v93;
  float32x4_t v94;
  uint64_t v95;
  uint64_t v96;
  int v97;
  unsigned int v98;
  uint32x4_t v99;
  int32x4_t v100;
  unsigned __int128 v101;
  unsigned __int128 v102;
  uint64_t v103;

  v103 = *MEMORY[0x1E0C80C00];
  v6 = a2;
  switch(*(_DWORD *)a1)
  {
    case 0:
      v101 = 0u;
      v102 = 0u;
      if (*(_BYTE *)(a1 + 11))
      {
        v8 = *(unsigned __int8 *)(a1 + 8);
        if (v8 >= 8)
          decode_etc2();
        v9 = *(unsigned __int16 *)(a1 + 4);
        v10 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v9), (uint32x2_t)0xFFFFFFF6FFFFFFFBLL), (int8x8_t)0x1F0000001FLL);
        v11.i64[0] = 0xFF000000FFLL;
        v11.i64[1] = 0xFF000000FFLL;
        v101 = *(_OWORD *)&vorrq_s8(vorrq_s8((int8x16_t)vshlq_n_s32(vminq_s32(vmaxq_s32(vaddq_s32(vdupq_n_s32((8 * v10.i32[0]) | ((unsigned __int32)v10.i32[0] >> 2)), etc_intensity_modifiers[v8]), (int32x4_t)0), v11), 0x10uLL), (int8x16_t)vshlq_n_s32(vminq_s32(vmaxq_s32(vaddq_s32(vdupq_n_s32((v9 >> 2) & 7 | (8 * (v9 & 0x1F))), etc_intensity_modifiers[v8]), (int32x4_t)0), v11), 0x18uLL)),
                             (int8x16_t)vshlq_n_s32(vminq_s32(vmaxq_s32(vaddq_s32(vdupq_n_s32((8 * v10.i32[1]) | ((unsigned __int32)v10.i32[1] >> 2)), etc_intensity_modifiers[v8]), (int32x4_t)0), v11), 8uLL)) | __PAIR128__(0xFF000000FFLL, 0xFF000000FFLL);
        v12 = *(unsigned __int8 *)(a1 + 9);
        if (v12 >= 8)
          decode_etc2();
        v13 = v9 & 0x1F;
        v14 = *(unsigned __int16 *)(a1 + 6);
        if ((v14 & 4) != 0)
          v15 = -8;
        else
          v15 = 0;
        v16 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v14), (uint32x2_t)0xFFFFFFFAFFFFFFFDLL), (int8x8_t)0x700000007);
        v17 = vadd_s32((int32x2_t)vorr_s8((int8x8_t)(*(_QWORD *)&vcgt_u32((uint32x2_t)v16, (uint32x2_t)0x300000003) & 0xFFFFFFF8FFFFFFF8), v16), v10);
        v18 = (v15 & 0xFFFFFFF8 | v14 & 7) + v13;
        if ((v17.i32[0] | v18 | v17.i32[1]) >= 0x20)
        {
          v17 = vmin_s32(vmax_s32(v17, 0), (int32x2_t)0x1F0000001FLL);
          v18 &= ~(v18 >> 31);
          if (v18 >= 31)
            v18 = 31;
        }
        v19 = (8 * v17.i32[0]) | (v17.i32[0] >> 2);
        v23 = (int8x16_t)etc_intensity_modifiers[v12];
        v20 = vaddq_s32((int32x4_t)v23, vdupq_n_s32((8 * v17.i32[1]) | ((unsigned __int32)v17.i32[1] >> 2)));
        v21 = vaddq_s32((int32x4_t)v23, vdupq_n_s32(v19));
        v22 = vaddq_s32((int32x4_t)v23, vdupq_n_s32((8 * v18) | (v18 >> 2)));
        v23.i32[3] = 0;
        v24.i64[0] = 0xFF000000FFLL;
        v24.i64[1] = 0xFF000000FFLL;
        v102 = *(_OWORD *)&vorrq_s8(vorrq_s8((int8x16_t)vshlq_n_s32(vminq_s32(vmaxq_s32(v21, (int32x4_t)0), v24), 0x10uLL), (int8x16_t)vshlq_n_s32(vminq_s32(vmaxq_s32(v22, (int32x4_t)0), v24), 0x18uLL)), (int8x16_t)vshlq_n_s32(vminq_s32(vmaxq_s32(v20, (int32x4_t)0), v24), 8uLL)) | __PAIR128__(0xFF000000FFLL, 0xFF000000FFLL);
      }
      else
      {
        get_abs_subblock_palette(*(unsigned __int16 *)(a1 + 4), *(unsigned __int8 *)(a1 + 8), (__n128 *)&v101);
        get_abs_subblock_palette(*(unsigned __int16 *)(a1 + 6), *(unsigned __int8 *)(a1 + 9), (__n128 *)&v102);
      }
      v91 = 0;
      v92 = 14;
      v93.i64[0] = 0xFF000000FFLL;
      v93.i64[1] = 0xFF000000FFLL;
      v94 = (float32x4_t)vdupq_n_s32(0x3B808081u);
      do
      {
        v95 = 0;
        v96 = v92;
        do
        {
          if (*(_DWORD *)a1)
            decode_etc2();
          if (*(_BYTE *)(a1 + 10))
            v97 = v91;
          else
            v97 = v95;
          v98 = *((_DWORD *)&v101 + 4 * ((v97 & 0xFFFFFFFE) != 0) + *(unsigned __int8 *)(a1 + v96));
          *(uint32x2_t *)v23.i8 = vshl_u32((uint32x2_t)vdup_n_s32(v98), (uint32x2_t)0xFFFFFFF0FFFFFFF8);
          v23.i32[2] = v98;
          v99 = vshrq_n_u32((uint32x4_t)v23, 0x18uLL);
          v23.i32[3] = v98;
          v100 = (int32x4_t)vandq_s8(v23, v93);
          v100.i32[2] = v99.i32[2];
          v23 = (int8x16_t)vmulq_f32(vcvtq_f32_s32(v100), v94);
          v6[v95++] = (__n128)v23;
          v96 += 4;
        }
        while (v95 != 4);
        ++v91;
        ++v92;
        v6 += 4;
      }
      while (v91 != 4);
      break;
    case 1:
      v25 = 0;
      v26 = etc_th_distances[*(unsigned __int8 *)(a1 + 8)];
      v27 = *(unsigned __int16 *)(a1 + 4);
      v28 = (v27 >> 4 << 16) & 0xFF0FFFFF | (v27 >> 4 << 20) | (((v27 >> 8) & 0xF) << 8) & 0xFFFF0FFF | (((v27 >> 8) & 0xF) << 12) | ((v27 & 0xF) << 24) | (v27 << 28);
      v29 = *(unsigned __int16 *)(a1 + 6);
      v30 = (v29 >> 8) & 0xF | (16 * ((v29 >> 8) & 0xF));
      v31 = (v29 >> 4) | (16 * (v29 >> 4));
      v32 = v29 & 0xF | (16 * (v29 & 0xF));
      v33 = (v30 + v26) & ~((v30 + v26) >> 31);
      if (v33 >= 255)
        v33 = 255;
      v34 = (v31 + v26) & ~((v31 + v26) >> 31);
      if (v34 >= 255)
        v34 = 255;
      v35 = (v34 << 16) | (v33 << 8);
      v36 = (v32 + v26) & ~((v32 + v26) >> 31);
      if (v36 >= 255)
        v36 = 255;
      LODWORD(v101) = v28 | 0xFF;
      DWORD1(v101) = v35 | (v36 << 24) | 0xFF;
      v37 = (v30 << 8) | (v31 << 16) | (v32 << 24) | 0xFF;
      v38 = v30 - v26;
      v39 = v31 - v26;
      v40 = v32 - v26;
      v41 = v38 & ~(v38 >> 31);
      if (v41 >= 255)
        v41 = 255;
      v42 = v39 & ~(v39 >> 31);
      if (v42 >= 255)
        v42 = 255;
      v43 = (v42 << 16) | (v41 << 8);
      v44 = v40 & ~(v40 >> 31);
      if (v44 >= 255)
        v44 = 255;
      DWORD2(v101) = v37;
      HIDWORD(v101) = v43 | (v44 << 24) | 0xFF;
      v45 = a1 + 14;
      v46.i64[0] = 0xFF000000FFLL;
      v46.i64[1] = 0xFF000000FFLL;
      v47 = (float32x4_t)vdupq_n_s32(0x3B808081u);
      do
      {
        v48 = 0;
        v49 = v6;
        do
        {
          a6.n128_u64[0] = (unint64_t)vshl_u32((uint32x2_t)vdup_n_s32(*((_DWORD *)&v101 + *(unsigned __int8 *)(v45 + v48))), (uint32x2_t)0xFFFFFFF0FFFFFFF8);
          a6.n128_u32[2] = *((_DWORD *)&v101 + *(unsigned __int8 *)(v45 + v48));
          v50 = vshrq_n_u32((uint32x4_t)a6, 0x18uLL);
          a6.n128_u32[3] = a6.n128_u32[2];
          v51 = (int32x4_t)vandq_s8((int8x16_t)a6, v46);
          v51.i32[2] = v50.i32[2];
          a6 = (__n128)vmulq_f32(vcvtq_f32_s32(v51), v47);
          *v49++ = a6;
          v48 += 4;
        }
        while (v48 != 16);
        ++v25;
        ++v45;
        v6 += 4;
      }
      while (v25 != 4);
      break;
    case 2:
      v52 = 0;
      v53 = (const float *)&etc_th_distances[*(unsigned __int8 *)(a1 + 8)];
      a3.i32[0] = *(unsigned __int16 *)(a1 + 4);
      a4.i32[0] = a3.i32[0];
      a4.i32[1] = *(unsigned __int16 *)(a1 + 6);
      a3.i32[1] = a4.i32[1];
      v54.i64[0] = 0xF0000000FLL;
      v54.i64[1] = 0xF0000000FLL;
      v55 = (uint16x4_t)vmovn_s32((int32x4_t)vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vzip1q_s32(a3, a3), (uint32x4_t)xmmword_1882113A0), v54));
      v60 = (int8x16_t)vmull_u16(v55, (uint16x4_t)0x11001100110011);
      *(int32x2_t *)a4.i8 = vmul_s32((int32x2_t)vand_s8(*(int8x8_t *)a4.i8, (int8x8_t)0xF0000000FLL), (int32x2_t)0x1100000011);
      v56 = vzip1q_s32(a4, a4);
      v57 = vrev64q_s32((int32x4_t)v60);
      v58 = (int32x4_t)vld1q_dup_f32(v53);
      v59 = vtrn2q_s32(vrev64q_s32((int32x4_t)vmlal_u16((uint32x4_t)v58, v55, (uint16x4_t)0x11001100110011)), vsubq_s32((int32x4_t)v60, v58));
      v60.i32[3] = 0;
      v61.i64[0] = 0xFF000000FFLL;
      v61.i64[1] = 0xFF000000FFLL;
      v101 = *(_OWORD *)&vorrq_s8(vorrq_s8((int8x16_t)vshlq_u32((uint32x4_t)vminq_s32(vmaxq_s32(v59, (int32x4_t)0), (int32x4_t)v61), (uint32x4_t)xmmword_1882113C0), (int8x16_t)vshlq_n_s32(vminq_s32(vmaxq_s32(vtrn2q_s32(vrev64q_s32(vaddq_s32(v56, v58)), vsubq_s32(v56, v58)), (int32x4_t)0), (int32x4_t)v61), 0x18uLL)), (int8x16_t)vshlq_u32((uint32x4_t)vminq_s32(vmaxq_s32(vtrn2q_s32(vrev64q_s32(vaddq_s32(v57, v58)), vsubq_s32(v57, v58)), (int32x4_t)0), (int32x4_t)v61),
                                        (uint32x4_t)xmmword_1882113B0)) | __PAIR128__(0xFF000000FFLL, 0xFF000000FFLL);
      v62 = a1 + 14;
      v63 = (float32x4_t)vdupq_n_s32(0x3B808081u);
      do
      {
        v64 = 0;
        v65 = (int8x16_t *)v6;
        do
        {
          *(uint32x2_t *)v60.i8 = vshl_u32((uint32x2_t)vdup_n_s32(*((_DWORD *)&v101 + *(unsigned __int8 *)(v62 + v64))), (uint32x2_t)0xFFFFFFF0FFFFFFF8);
          v60.i32[2] = *((_DWORD *)&v101 + *(unsigned __int8 *)(v62 + v64));
          v66 = vshrq_n_u32((uint32x4_t)v60, 0x18uLL);
          v60.i32[3] = v60.i32[2];
          v67 = (int32x4_t)vandq_s8(v60, v61);
          v67.i32[2] = v66.i32[2];
          v60 = (int8x16_t)vmulq_f32(vcvtq_f32_s32(v67), v63);
          *v65++ = v60;
          v64 += 4;
        }
        while (v64 != 16);
        ++v52;
        ++v62;
        v6 += 4;
      }
      while (v52 != 4);
      break;
    case 3:
      v68 = 0;
      v69 = (4 * *(unsigned __int8 *)(a1 + 4)) | (*(unsigned __int8 *)(a1 + 4) >> 4);
      v70 = (2 * *(unsigned __int8 *)(a1 + 5)) | (*(unsigned __int8 *)(a1 + 5) >> 6);
      v71 = (4 * *(unsigned __int8 *)(a1 + 6)) | (*(unsigned __int8 *)(a1 + 6) >> 4);
      v72 = ((4 * *(unsigned __int8 *)(a1 + 10)) | (*(unsigned __int8 *)(a1 + 10) >> 4)) - v69;
      v73 = ((2 * *(unsigned __int8 *)(a1 + 11)) | (*(unsigned __int8 *)(a1 + 11) >> 6)) - v70;
      v74 = ((4 * *(unsigned __int8 *)(a1 + 12)) | (*(unsigned __int8 *)(a1 + 12) >> 4)) - v71;
      v75 = vmulq_s32(vdupq_n_s32(((4 * *(unsigned __int8 *)(a1 + 7)) | (*(unsigned __int8 *)(a1 + 7) >> 4)) - v69), (int32x4_t)xmmword_18820BF90);
      v76 = vmulq_s32(vdupq_n_s32(((2 * *(unsigned __int8 *)(a1 + 8)) | (*(unsigned __int8 *)(a1 + 8) >> 6)) - v70), (int32x4_t)xmmword_18820BF90);
      v77 = vmulq_s32(vdupq_n_s32(((4 * *(unsigned __int8 *)(a1 + 9)) | (*(unsigned __int8 *)(a1 + 9) >> 4)) - v71), (int32x4_t)xmmword_18820BF90);
      v78 = (4 * v71) | 2;
      v79 = (4 * v70) | 2;
      v80 = (float32x4_t)vdupq_n_s32(0x437F0000u);
      __asm { FMOV            V19.4S, #1.0 }
      v86 = (4 * v69) | 2;
      do
      {
        v87 = vminnmq_f32(vmaxnmq_f32(vdivq_f32(vcvtq_f32_s32(vshrq_n_s32(vaddq_s32(vdupq_n_s32(v86), v75), 2uLL)), v80), (float32x4_t)0), _Q19);
        v88 = vminnmq_f32(vmaxnmq_f32(vdivq_f32(vcvtq_f32_s32(vshrq_n_s32(vaddq_s32(vdupq_n_s32(v79), v76), 2uLL)), v80), (float32x4_t)0), _Q19);
        v89 = vminnmq_f32(vmaxnmq_f32(vdivq_f32(vcvtq_f32_s32(vshrq_n_s32(vaddq_s32(vdupq_n_s32(v78), v77), 2uLL)), v80), (float32x4_t)0), _Q19);
        v90 = (float *)&a2[v68];
        vst4q_f32(v90, *(float32x4x4_t *)(&_Q19 - 3));
        v68 += 4;
        v78 += v74;
        v79 += v73;
        v86 += v72;
      }
      while (v68 != 16);
      break;
    default:
      decode_etc2();
  }
}

uint64_t nv::decompress_eac(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t result;
  unsigned int v6;
  uint64_t v7;
  int v8;
  int v9;
  char *v10;
  int v11;
  int v12;
  uint64_t v13;
  _QWORD v14[3];

  v14[2] = *MEMORY[0x1E0C80C00];
  if (a3 >= 4)
    nv::decompress_eac();
  v13 = 0;
  v14[0] = 0;
  *(_DWORD *)((char *)v14 + 7) = 0;
  result = unpack_eac_block(a1, &v13);
  v6 = 0;
  v7 = 0;
  v8 = (8 * v13) | 4;
  if (BYTE1(v13))
    v9 = 8 * BYTE1(v13);
  else
    v9 = 1;
  v10 = (char *)&eac_intensity_modifiers + 32 * BYTE2(v13);
  do
  {
    v11 = v8 + v9 * *(_DWORD *)&v10[4 * *((unsigned __int8 *)&v14[-1] + (v7 & 0xC) + (v6 >> 2) + 3)];
    v12 = v11 & ~(v11 >> 31);
    if (v12 >= 2047)
      v12 = 2047;
    *(float *)(a2 + 4 * a3 + 4 * v7) = (float)((32 * v12) | (v12 >> 6)) / 65535.0;
    v7 += 4;
    ++v6;
  }
  while (v7 != 64);
  return result;
}

uint64_t unpack_eac_block(uint64_t result, _BYTE *a2)
{
  unint64_t v2;
  _BYTE *v3;
  uint64_t i;

  *a2 = *(_QWORD *)result;
  a2[2] = *(_BYTE *)(result + 1) & 0xF;
  a2[1] = (unsigned __int16)*(_DWORD *)result >> 12;
  v2 = __ROR8__(*(_QWORD *)result, 56) & 0xFF000000FFLL | ((unint64_t)BYTE2(*(_QWORD *)result) << 40) | (*(_QWORD *)result >> 8) & 0xFF000000 | (*(_QWORD *)result >> 24) & 0xFF0000 | (*(_QWORD *)result >> 40) & 0xFF00;
  v3 = a2 + 3;
  for (i = 45; i != -3; i -= 3)
    *v3++ = (v2 >> i) & 7;
  return result;
}

float nv::decompress_etc_eac(uint64_t a1, __n128 *a2)
{
  int32x4_t v4;
  int32x4_t v5;
  double v6;
  __n128 v7;
  unsigned int v8;
  uint64_t v9;
  int v10;
  int v11;
  char *v12;
  int v13;
  int v14;
  float result;
  uint64_t v16;
  _QWORD v17[2];
  _OWORD v18[2];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  memset(v18, 0, sizeof(v18));
  unpack_etc2_block((unint64_t *)(a1 + 8), (uint64_t)v18);
  decode_etc2((uint64_t)v18, a2, v4, v5, v6, v7);
  v16 = 0;
  v17[0] = 0;
  *(_DWORD *)((char *)v17 + 7) = 0;
  unpack_eac_block(a1, &v16);
  v8 = 0;
  v9 = 0;
  v10 = v16;
  v11 = BYTE1(v16);
  v12 = (char *)&eac_intensity_modifiers + 32 * BYTE2(v16);
  do
  {
    v13 = v10 + *(_DWORD *)&v12[4 * *((unsigned __int8 *)&v17[-1] + ((v9 * 4) & 0xC) + (v8 >> 2) + 3)] * v11;
    v14 = v13 & ~(v13 >> 31);
    if (v14 >= 255)
      v14 = 255;
    result = (float)v14 / 255.0;
    a2[v9++].n128_f32[3] = result;
    ++v8;
  }
  while (v9 != 16);
  return result;
}

uint64_t nv::DecompressETC_EAC(int a1, unsigned int a2, unsigned int a3, unint64_t *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  unsigned int v9;
  int32x2_t v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  int v16;
  int8x8_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int32x4_t v21;
  int32x4_t v22;
  double v23;
  __n128 v24;
  uint64_t v25;
  unint64_t *v26;
  unsigned int v27;
  uint64_t v28;
  int8x8_t *v29;
  unsigned int v30;
  float v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  uint64_t v37;
  int v38;
  unsigned int v39;
  uint64_t v40;
  unsigned int v41;
  unsigned int v42;
  int v43;
  uint64_t v44;
  __n128 v45;
  _OWORD v46[2];
  uint64_t v47;

  v6 = 0;
  v47 = *MEMORY[0x1E0C80C00];
  switch(a1)
  {
    case 14:
      goto LABEL_9;
    case 15:
      LODWORD(v6) = 0;
      v39 = (a2 + 3) >> 2;
      v9 = (a3 + 3) >> 2;
      goto LABEL_7;
    case 16:
      LODWORD(v6) = 1;
LABEL_9:
      v39 = (a2 + 3) >> 2;
      v9 = (a3 + 3) >> 2;
      v10 = (int32x2_t)v6;
      goto LABEL_10;
    case 17:
    case 18:
    case 19:
      v39 = (a2 + 3) >> 2;
      v9 = (a3 + 3) >> 2;
      LODWORD(v6) = 1;
      if (a1 == 17)
        goto LABEL_7;
      v10 = (int32x2_t)0x100000001;
      if (a1 == 18)
      {
LABEL_10:
        v11 = 8;
      }
      else if (a1 == 19)
      {
LABEL_7:
        v10 = vdup_n_s32(v6);
        v11 = 16;
        LODWORD(v6) = 1;
      }
      else
      {
        v11 = 0;
      }
      v44 = v11;
      if (v11 > a5)
        return 0;
      if (!v9)
        return 1;
      v12 = 0;
      v13 = 0;
      v42 = a1 & 0xFFFFFFFD;
      v14 = a2;
      v15 = a3;
      v38 = 16 * a2;
      v16 = 4 * a2;
      v37 = v9;
      v17 = (int8x8_t)vcltz_s32(vshl_n_s32(v10, 0x1FuLL));
      v43 = a1;
      break;
    default:
      return v6;
  }
  while (1)
  {
    v41 = v12;
    v40 = v13;
    if (v39)
      break;
LABEL_41:
    v13 = v40 + 1;
    v12 = v41 + v38;
    if (v40 + 1 == v37)
      return 1;
  }
  v18 = 0;
  v19 = 0;
  v20 = 4 * v13;
  while (1)
  {
    memset(&v45, 0, 256);
    if (a1 == 16 || a1 == 13)
    {
LABEL_19:
      memset(v46, 0, sizeof(v46));
      unpack_etc2_block(a4, (uint64_t)v46);
      decode_etc2((uint64_t)v46, &v45, v21, v22, v23, v24);
      goto LABEL_20;
    }
    if (v42 == 17)
    {
      nv::decompress_etc_eac((uint64_t)a4, &v45);
      goto LABEL_20;
    }
    if (a1 == 18)
      goto LABEL_19;
    if (a1 == 15)
    {
      nv::decompress_eac((uint64_t)a4, (uint64_t)&v45, 0);
      v34 = (uint64_t)a4 + (v44 >> 1);
      v35 = 1;
      goto LABEL_40;
    }
    if (a1 != 14)
      return 0;
    v34 = (uint64_t)a4;
    v35 = 0;
LABEL_40:
    nv::decompress_eac(v34, (uint64_t)&v45, v35);
LABEL_20:
    v25 = 0;
    v26 = &v45.n128_u64[1];
    v27 = v12;
    a1 = v43;
    do
    {
      v28 = 0;
      v29 = (int8x8_t *)v26;
      v30 = v27;
      do
      {
        if (v18 + v28 < v14 && v25 + v20 < v15)
        {
          v32 = *(float *)&v29[-1].i32[1];
          v33 = a6 + 4 * v30;
          if (!(_DWORD)v6)
            v32 = 0.0;
          *(_DWORD *)v33 = v29[-1].i32[0];
          *(float *)(v33 + 4) = v32;
          *(int8x8_t *)(v33 + 8) = vbsl_s8(v17, *v29, (int8x8_t)0x3F80000000000000);
        }
        ++v28;
        v30 += 4;
        v29 += 2;
      }
      while (v28 != 4);
      ++v25;
      v27 += v16;
      v26 += 8;
    }
    while (v25 != 4);
    a4 = (unint64_t *)((char *)a4 + v44);
    ++v19;
    v12 += 16;
    v18 += 4;
    if (v19 == v39)
      goto LABEL_41;
  }
}

__n128 get_abs_subblock_palette(unsigned int a1, unsigned int a2, __n128 *a3)
{
  int32x4_t v3;
  int32x4_t v4;
  __n128 result;

  if (a2 >= 8)
    get_abs_subblock_palette();
  v3 = etc_intensity_modifiers[a2];
  v4.i64[0] = 0xFF000000FFLL;
  v4.i64[1] = 0xFF000000FFLL;
  result = (__n128)(*(_OWORD *)&vorrq_s8(vorrq_s8((int8x16_t)vshlq_n_s32(vminq_s32(vmaxq_s32(vaddq_s32(v3, vdupq_n_s32((a1 >> 4) | (16* (a1 >> 4)))), (int32x4_t)0), v4), 0x10uLL), (int8x16_t)vshlq_n_s32(vminq_s32(vmaxq_s32(vaddq_s32(v3, vdupq_n_s32((a1 >> 8) & 0xF | (16 * ((a1 >> 8) & 0xF)))), (int32x4_t)0), v4),
                                                 8uLL)),
                                  (int8x16_t)vshlq_n_s32(vminq_s32(vmaxq_s32(vaddq_s32(v3, vdupq_n_s32(a1 & 0xF | (16 * (a1 & 0xF)))), (int32x4_t)0), v4), 0x18uLL)) | __PAIR128__(0xFF000000FFLL, 0xFF000000FFLL));
  *a3 = result;
  return result;
}

BOOL isPowerOf2(uint64_t a1)
{
  return a1 && (a1 & (a1 - 1)) == 0;
}

double PVRReadPlugin::PVRReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t v5;
  double result;

  v5 = IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *(_QWORD *)v5 = &off_1E1BAD9F8;
  result = 0.0;
  *(_OWORD *)(v5 + 440) = 0u;
  *(_OWORD *)(v5 + 456) = 0u;
  *(_OWORD *)(v5 + 472) = 0u;
  *(_OWORD *)(v5 + 488) = 0u;
  *(_OWORD *)(v5 + 504) = 0u;
  *(_OWORD *)(v5 + 520) = 0u;
  *(_OWORD *)(v5 + 536) = 0u;
  *(_OWORD *)(v5 + 552) = 0u;
  *(_QWORD *)(v5 + 568) = 0;
  return result;
}

double PVRReadPlugin::PVRReadPlugin(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  double result;

  v3 = IIOReadPlugin::IIOReadPlugin(a1, a2, a3);
  *(_QWORD *)v3 = &off_1E1BAD9F8;
  result = 0.0;
  *(_OWORD *)(v3 + 440) = 0u;
  *(_OWORD *)(v3 + 456) = 0u;
  *(_OWORD *)(v3 + 472) = 0u;
  *(_OWORD *)(v3 + 488) = 0u;
  *(_OWORD *)(v3 + 504) = 0u;
  *(_OWORD *)(v3 + 520) = 0u;
  *(_OWORD *)(v3 + 536) = 0u;
  *(_OWORD *)(v3 + 552) = 0u;
  *(_QWORD *)(v3 + 568) = 0;
  return result;
}

void PVRReadPlugin::~PVRReadPlugin(PVRReadPlugin *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_1E1BAD9F8;
  v2 = *((_QWORD *)this + 70);
  if (v2)
    (**(void (***)(void))(v2 + 8))();
  IIOReadPlugin::~IIOReadPlugin(this);
}

{
  PVRReadPlugin::~PVRReadPlugin(this);
  JUMPOUT(0x18D761C30);
}

uint64_t PVRReadPlugin::loadDataFromXPCObject(PVRReadPlugin *this, void *a2)
{
  uint64_t result;
  _OWORD *data;
  _OWORD *v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  size_t length;

  result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!(_DWORD)result)
  {
    length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_pvr", &length);
    if (length == 136)
    {
      v6 = data;
      result = 0;
      v7 = v6[5];
      v8 = v6[6];
      v9 = *((_QWORD *)v6 + 16);
      *(_OWORD *)((char *)this + 552) = v6[7];
      *(_OWORD *)((char *)this + 440) = *v6;
      v10 = v6[1];
      v11 = v6[2];
      v12 = v6[4];
      *(_OWORD *)((char *)this + 488) = v6[3];
      *(_OWORD *)((char *)this + 504) = v12;
      *(_OWORD *)((char *)this + 456) = v10;
      *(_OWORD *)((char *)this + 472) = v11;
      *((_QWORD *)this + 71) = v9;
      *(_OWORD *)((char *)this + 520) = v7;
      *(_OWORD *)((char *)this + 536) = v8;
      *((_QWORD *)this + 70) = 0;
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t PVRReadPlugin::saveDataToXPCObject(PVRReadPlugin *this, void *a2)
{
  uint64_t v4;

  v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!(_DWORD)v4)
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_pvr", (char *)this + 440, 0x88uLL);
  return v4;
}

void PVRReadPlugin::addImageTypeIdentifier(PVRReadPlugin *this, CGImage *a2, const __CFString *a3, int a4)
{
  _BYTE v6[16];

  if (*((_BYTE *)this + 496))
  {
    CGImageSetProperty();
    IIOString::IIOString((IIOString *)v6, 0x4B545820u);
  }
  else
  {
    CGImageSetProperty();
    IIOString::IIOString((IIOString *)v6, *((_DWORD *)this + 51));
  }
  CGImageSetProperty();
  IIOString::~IIOString((IIOString *)v6);
  IIONumber::IIONumber((IIONumber *)v6, a4);
  CGImageSetProperty();
  IIONumber::~IIONumber((IIONumber *)v6);
}

void sub_187FDC610(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t PVRReadPlugin::validateV2Header(uint64_t a1, _DWORD *a2)
{
  int v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  int v8;
  int v9;

  v4 = a2[4];
  if (*a2 == 52 || *a2 == 44)
  {
    if (a2[6])
    {
      v5 = a2[5];
      if ((unint64_t)IIOImageReadSession::getSize(*(IIOImageReadSession **)(a1 + 24)) > v5)
      {
        v6 = a2[12];
        if ((unint64_t)IIOImageReadSession::getSize(*(IIOImageReadSession **)(a1 + 24)) > v6)
        {
          if ((v4 & 0xFE) != 0x18 && (a2[6] & 7) != 0)
          {
            _cg_jpeg_mem_term("validateV2Header", 163, "*** invalid bits/pixel: %d");
          }
          else
          {
            if ((v4 - 22) < 0x1Du && ((0x10000023u >> (v4 - 22)) & 1) != 0)
              return 1;
            v8 = a2[7];
            v7 = a2[8];
            if ((v7 & v8) != 0)
            {
              _cg_jpeg_mem_term("validateV2Header", 166, "*** red/green masks overlap: r:0x%08X g:0x%08X");
            }
            else
            {
              v9 = a2[9];
              if ((v9 & v8) != 0)
              {
                _cg_jpeg_mem_term("validateV2Header", 167, "*** red/blue masks overlap: r:0x%08X b:0x%08X");
              }
              else
              {
                if ((v9 & v7) == 0)
                  return 1;
                _cg_jpeg_mem_term("validateV2Header", 168, "*** green/blue masks overlap: g:0x%08X b:0x%08X");
              }
            }
          }
        }
      }
    }
  }
  return 0;
}

uint64_t PVRReadPlugin::validateV3Header(uint64_t a1, _DWORD *a2)
{
  unint64_t v4;
  unint64_t v5;

  if (a2[9] >= 0x11u)
  {
    _cg_jpeg_mem_term("validateV3Header", 181, "*** bad numberOfSurfaces count [%d]\n");
  }
  else
  {
    v4 = a2[10];
    if ((unint64_t)IIOImageReadSession::getSize(*(IIOImageReadSession **)(a1 + 24)) < v4)
    {
      IIOImageReadSession::getSize(*(IIOImageReadSession **)(a1 + 24));
      _cg_jpeg_mem_term("validateV3Header", 182, "*** bad numberOfFaces count [%d]  size: %d\n");
    }
    else if (a2[4] >= 2u)
    {
      _cg_jpeg_mem_term("validateV3Header", 183, "*** bad colorSpace [%d]\n");
    }
    else if (a2[8] >= 0x11u)
    {
      _cg_jpeg_mem_term("validateV3Header", 184, "*** bad depth [%d]\n");
    }
    else
    {
      v5 = a2[12];
      if ((unint64_t)IIOImageReadSession::getSize(*(IIOImageReadSession **)(a1 + 24)) >= v5)
        return 1;
      IIOImageReadSession::getSize(*(IIOImageReadSession **)(a1 + 24));
      _cg_jpeg_mem_term("validateV3Header", 185, "*** bad metadataSize [%d]  size: %d\n");
    }
  }
  return 0;
}

uint64_t PVRReadPlugin::calculateOffsetToRequestedImage(PVRReadPlugin *this, uint64_t a2)
{
  unsigned int v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  int v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int v17;

  v4 = *((_DWORD *)this + 117);
  v5 = *((_DWORD *)this + 116);
  v6 = *((unsigned __int16 *)this + 275);
  v7 = *((_DWORD *)this + 52);
  if (v7)
  {
    v8 = 0;
    v9 = *((_DWORD *)this + 121);
    v17 = *((_DWORD *)this + 116);
    do
    {
      v10 = (v4 * v6) >> 3;
      if (v9)
      {
        v11 = 0;
        v12 = v4;
        do
        {
          v13 = v10 * v5;
          printf("#%d  mm:%d    size: %dx%d    imgSize: %d\n", v8, v11, v12, v5, v10 * v5);
          a2 += v13;
          v12 >>= 1;
          v5 >>= 1;
          v6 = *((unsigned __int16 *)this + 275);
          ++v11;
          v10 = (v12 * v6) >> 3;
        }
        while (v9 != v11);
        v7 = *((_DWORD *)this + 52);
        v5 = v17;
      }
      ++v8;
    }
    while (v8 < v7);
  }
  else
  {
    v10 = (v4 * v6) >> 3;
  }
  if (*((_WORD *)this + 159))
  {
    v14 = 0;
    do
    {
      v15 = v10 * v5;
      printf("   mm:%d    size: %dx%d    imgSize: %d\n", v14, v4, v5, v10 * v5);
      a2 += v15;
      v4 >>= 1;
      v5 >>= 1;
      v10 = (v4 * *((unsigned __int16 *)this + 275)) >> 3;
      ++v14;
    }
    while (v14 < *((unsigned __int16 *)this + 159));
  }
  return a2;
}

uint64_t PVRReadPlugin::initialize(PVRReadPlugin *this, IIODictionary *a2)
{
  unsigned int v3;
  IIODictionary *v4;
  int v5;
  unsigned int Uint32ForKey;
  double v7;
  unsigned __int32 v8;
  unsigned __int32 v9;
  __int16 v10;
  unsigned __int32 v11;
  unsigned __int32 v12;
  __int16 v13;
  unsigned __int8 v14;
  __int16 v15;
  unsigned int v16;
  int v17;
  __int128 v18;
  unsigned int v19;
  unsigned int v20;
  unsigned __int32 v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned __int32 v26;
  unsigned int v27;
  __int16 v28;
  int v29;
  int v30;
  __int32 v31;
  __int8 v32;
  IIOImageRead *Size;
  int v34;
  unsigned int v35;
  unsigned int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  __int16 v41;
  unsigned __int16 v42;
  int v43;
  unint64_t v44;
  unint64_t v45;
  unsigned int v46;
  int v47;
  unint64_t v48;
  unsigned int v49;
  int v50;
  int8x8_t v51;
  int8x8_t v52;
  unsigned int v53;
  unsigned int v54;
  int v55;
  int v56;
  BOOL v57;
  int v58;
  uint64_t result;
  int v60;
  unsigned int v61;
  unsigned int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  uint64_t v67;
  unsigned int v68;
  int8x16_t v69;
  _OWORD v70[2];
  __int128 v71;
  __int128 v72;
  __int128 v73;
  uint64_t v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  uint64_t v80;

  v80 = *MEMORY[0x1E0C80C00];
  v68 = 0;
  if (!*((_BYTE *)this + 341))
    goto LABEL_157;
  IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), &v68, 0x2CuLL, 4uLL);
  v68 = bswap32(v68);
  *((_WORD *)this + 159) = 0;
  v3 = IIODictionary::containsKey(*((IIODictionary **)this + 6), CFSTR("kCGImageSourceMipmapLevel"));
  v4 = (IIODictionary *)*((_QWORD *)this + 6);
  if (v3)
  {
    LOWORD(v5) = (unsigned __int16)IIODictionary::getUint32ForKey(v4, CFSTR("kCGImageSourceMipmapLevel"));
  }
  else
  {
    if (!IIODictionary::containsKey(v4, CFSTR("kCGImageSourceSubsampleFactor")))
      goto LABEL_10;
    Uint32ForKey = IIODictionary::getUint32ForKey(*((IIODictionary **)this + 6), CFSTR("kCGImageSourceSubsampleFactor"));
    if (Uint32ForKey)
      v7 = log2((double)Uint32ForKey);
    else
      v7 = 0.0;
    v5 = (int)v7;
  }
  *((_WORD *)this + 159) = v5;
LABEL_10:
  if (v68 != 1347834401)
  {
    IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), &v68, 0, 4uLL);
    v16 = v68;
    v68 = bswap32(v68);
    if (v16 != 55727696)
    {
      v29 = *((_DWORD *)this + 51);
      if (v29 == 1261588566)
      {
        *((_DWORD *)this + 123) = -1;
        v78 = 0u;
        v79 = 0u;
        v76 = 0u;
        v77 = 0u;
        v75 = 0u;
        Size = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
        if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), &v75, *((_QWORD *)this + 24), 0x50uLL) != 80)
        {
          _cg_jpeg_mem_term("initialize", 640, "*** ERROR: PVR failed to read KTX2 header (%d bytes) expected: %d\n");
          goto LABEL_157;
        }
        if (!IsKTX2Header(&v75))
          goto LABEL_157;
        if ((unint64_t)Size <= v77)
        {
          _cg_jpeg_mem_term("initialize", 645, "*** ERROR: Invalid numberOfArrayElements (%d).");
          goto LABEL_157;
        }
        if ((unint64_t)Size <= v78)
        {
          _cg_jpeg_mem_term("initialize", 646, "*** ERROR: Invalid dfdOffset (%d).");
          goto LABEL_157;
        }
        if ((unint64_t)Size <= DWORD1(v78))
        {
          _cg_jpeg_mem_term("initialize", 647, "*** ERROR: Invalid dfdLength (%d).");
          goto LABEL_157;
        }
        if ((unint64_t)Size <= DWORD2(v78))
        {
          _cg_jpeg_mem_term("initialize", 648, "*** ERROR: Invalid kvdOffset (%d).");
          goto LABEL_157;
        }
        if ((unint64_t)Size <= HIDWORD(v78))
        {
          _cg_jpeg_mem_term("initialize", 649, "*** ERROR: Invalid kvdLength (%d).");
          goto LABEL_157;
        }
        if ((unint64_t)v79 >= (unint64_t)Size)
        {
          _cg_jpeg_mem_term("initialize", 650, "*** ERROR: Invalid scgdOffset (%d).");
          goto LABEL_157;
        }
        if (*((_QWORD *)&v79 + 1) >= (unint64_t)Size)
        {
          _cg_jpeg_mem_term("initialize", 651, "*** ERROR: Invalid scgdLength (%d).");
          goto LABEL_157;
        }
        v74 = 0;
        v72 = 0u;
        v73 = 0u;
        v71 = 0u;
        v69 = 0u;
        memset(v70, 0, sizeof(v70));
        v67 = 0;
        if (CreateKtxStream((uint64_t)&v69, *((IIOImageReadSession **)this + 3)))
          goto LABEL_157;
        if (ktxTexture2_CreateFromStream(&v69, 0, &v67))
        {
          _cg_jpeg_mem_term("initialize", 660, "*** ERROR: ktxTexture2_CreateFromStream failed [%d]\n");
          goto LABEL_157;
        }
        *((_QWORD *)this + 70) = v67;
        v34 = HIDWORD(v75);
        v35 = DWORD2(v77);
        *((_DWORD *)this + 142) = HIDWORD(v75);
        *((_BYTE *)this + 497) = 1;
        if (v35 >= 0x14)
        {
          _cg_jpeg_mem_term("initialize", 667, "unexpected numberOfMipmapLevels == %d\n");
          goto LABEL_157;
        }
        if (DWORD1(v77) >= 0x14)
        {
          _cg_jpeg_mem_term("initialize", 668, "unexpected numberOfMipmapLevels == %d\n");
          goto LABEL_157;
        }
        if (HIDWORD(v76))
        {
          _cg_jpeg_mem_term("initialize", 669, "unexpected pixelDepth == %d\n");
          goto LABEL_157;
        }
        if (!DWORD2(v76))
        {
          _cg_jpeg_mem_term("initialize", 670, "unexpected pixelHeight == %d\n");
          goto LABEL_157;
        }
        v30 = DWORD1(v76);
        if (!DWORD1(v76))
        {
          _cg_jpeg_mem_term("initialize", 671, "unexpected pixelWidth == %d\n");
          goto LABEL_157;
        }
        v36 = v34 - 1000054000;
        if (v36 >= 8)
          v37 = 0;
        else
          v37 = dword_1882116F0[v36];
        *((_DWORD *)this + 131) = v37;
        *((_BYTE *)this + 344) = 0;
        *((_DWORD *)this + 57) = v30;
        *((_DWORD *)this + 58) = v30;
      }
      else
      {
        if (v29 != 1263556178)
          goto LABEL_77;
        v71 = 0u;
        v69 = 0u;
        memset(v70, 0, sizeof(v70));
        *((_DWORD *)this + 123) = -1;
        if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), &v69, *((_QWORD *)this + 24), 0x40uLL) != 64)
        {
          _cg_jpeg_mem_term("initialize", 596, "*** ERROR: PVR failed to read KTX header (%d bytes) expected: %d\n");
          goto LABEL_157;
        }
        *((_BYTE *)this + 496) = 1;
        SwapKTXHeader(&v69);
        if (DWORD2(v71) >= 0x14)
        {
          _cg_jpeg_mem_term("initialize", 601, "unexpected numberOfMipmapLevels == %d\n");
          goto LABEL_157;
        }
        if (DWORD1(v71) >= 0x14)
        {
          _cg_jpeg_mem_term("initialize", 602, "unexpected numberOfMipmapLevels == %d\n");
          goto LABEL_157;
        }
        if (HIDWORD(v70[1]))
        {
          _cg_jpeg_mem_term("initialize", 603, "unexpected pixelDepth == %d\n");
          goto LABEL_157;
        }
        if (!DWORD2(v70[1]))
        {
          _cg_jpeg_mem_term("initialize", 604, "unexpected pixelHeight == %d\n");
          goto LABEL_157;
        }
        v30 = DWORD1(v70[1]);
        if (!DWORD1(v70[1]))
        {
          _cg_jpeg_mem_term("initialize", 605, "unexpected pixelWidth == %d\n");
          goto LABEL_157;
        }
        v31 = v69.i32[3];
        *((_DWORD *)this + 131) = HIDWORD(v70[0]);
        *((_BYTE *)this + 344) = v31 == 67305985;
        *((_DWORD *)this + 57) = v30;
        *((_DWORD *)this + 58) = v30;
        *((_QWORD *)this + 24) = HIDWORD(v71) + 64;
      }
      *((_BYTE *)this + 498) = 1;
      *((_WORD *)this + 122) = 4;
      *((_DWORD *)this + 59) = 4 * v30;
      *((_DWORD *)this + 60) = 2097160;
      *((_QWORD *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
      *((_DWORD *)this + 81) = 1380401696;
      *((_WORD *)this + 123) = 3;
      goto LABEL_77;
    }
    LODWORD(v71) = 0;
    memset(v70, 0, sizeof(v70));
    v69 = 0u;
    if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), &v69, 0, 0x34uLL) != 52)
    {
      _cg_jpeg_mem_term("initialize", 398, "*** ERROR: PVR failed to read v3 header (%d bytes) expected: %d\n");
      goto LABEL_157;
    }
    if ((PVRReadPlugin::validateV3Header((uint64_t)this, &v69) & 1) == 0)
    {
      _cg_jpeg_mem_term("initialize", 401, "*** invalid PVR3 header\n");
      goto LABEL_157;
    }
    v17 = DWORD2(v70[1]);
    *((_DWORD *)this + 122) = v71;
    *((_BYTE *)this + 496) = 0;
    v18 = v70[1];
    *(_OWORD *)((char *)this + 456) = v70[0];
    *(_OWORD *)((char *)this + 472) = v18;
    *(int8x16_t *)((char *)this + 440) = v69;
    *((_DWORD *)this + 123) = 3;
    *((_DWORD *)this + 120) = v17;
    v19 = *((unsigned __int16 *)this + 159);
    v20 = *((_DWORD *)this + 121);
    if (v20 <= v19)
    {
      *((_WORD *)this + 159) = v20 - 1;
      v19 = (unsigned __int16)(v20 - 1);
    }
    *(int32x2_t *)((char *)this + 228) = vrev64_s32((int32x2_t)vshl_u32(*(uint32x2_t *)((char *)v70 + 8), (uint32x2_t)vneg_s32(vdup_n_s32(v19))));
    *((_BYTE *)this + 548) = -1;
    *((_BYTE *)this + 520) = -1;
    *((_DWORD *)this + 60) = 2097160;
    *((_WORD *)this + 122) = 4;
    *((_DWORD *)this + 81) = 1380401696;
    v21 = v69.u32[3];
    if (!v69.i32[3])
    {
      v32 = v69.i8[8];
      *((_BYTE *)this + 520) = v69.i8[8];
      *((_BYTE *)this + 498) = (v32 & 0xFEu) < 6;
      *((_BYTE *)this + 246) = 3;
LABEL_146:
      *((_DWORD *)this + 59) = 4 * *((_DWORD *)this + 57);
      *((_QWORD *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
LABEL_147:
      v66 = *((unsigned __int16 *)this + 121);
      if (v66 == 16)
      {
        *((_BYTE *)this + 247) = 1;
      }
      else if (v66 == 32)
      {
        *((_BYTE *)this + 247) = 0;
      }
      goto LABEL_77;
    }
    *((_BYTE *)this + 498) = 0;
    v22 = v69.u32[2];
    v23 = v21;
    v24 = BYTE1(v21);
    v25 = BYTE2(v21);
    v26 = HIBYTE(v21);
    v27 = HIBYTE(v21) + v21 + BYTE1(v21) + BYTE2(v21);
    *((_WORD *)this + 275) = v27;
    if (v27 >= 9)
    {
      if (v27 >= 0x11)
      {
        if (v27 >= 0x21)
        {
          if (v27 >= 0x41)
          {
            if (v27 >= 0x81)
            {
              _cg_jpeg_mem_term("initialize", 453, "*** ERROR: bad _bitsPerPixel: %d for RGBA channels (%d,%d,%d,%d)\n");
              goto LABEL_157;
            }
            v28 = 128;
          }
          else
          {
            v28 = 64;
          }
        }
        else
        {
          v28 = 32;
        }
      }
      else
      {
        v28 = 16;
      }
    }
    else
    {
      v28 = 8;
    }
    v60 = bswap32(v22);
    *((_WORD *)this + 275) = v28;
    *((_DWORD *)this + 138) = -1;
    if (v60 <= 1912602623)
    {
      if (v60 > 1650946559)
      {
        if (v60 == 1650946560)
        {
          *((_BYTE *)this + 548) = 1;
          *((_BYTE *)this + 554) = v23;
          *((_BYTE *)this + 553) = v24;
          *((_BYTE *)this + 552) = v25;
          if (v25 == v24)
          {
            v61 = v23;
            v62 = v25;
            if (v23 == v24)
              goto LABEL_132;
          }
          _cg_jpeg_mem_term("initialize", 516, "*** ERROR unsupported 'bgr'-bitDepth: %d-%d-%d\n");
          goto LABEL_157;
        }
        if (v60 == 1650946657 || v60 == 1650946680)
        {
          *((_BYTE *)this + 548) = 3;
          *((_BYTE *)this + 554) = v23;
          *((_BYTE *)this + 553) = v24;
          *((_BYTE *)this + 552) = v25;
          *((_BYTE *)this + 555) = v26;
          *((_BYTE *)this + 246) = 3;
          if (v25 == v24)
          {
            v61 = v23;
            v62 = v23;
            if (v24 == v23)
              goto LABEL_132;
          }
          _cg_jpeg_mem_term("initialize", 538, "*** ERROR unsupported 'bgra/bgrx'-bitDepth: %d-%d-%d\n");
          goto LABEL_157;
        }
        goto LABEL_131;
      }
      if (v60 != 1633838962)
      {
        v63 = 1634887522;
LABEL_114:
        if (v60 == v63)
        {
          *((_BYTE *)this + 548) = 2;
          *((_BYTE *)this + 555) = v23;
          *((_BYTE *)this + 552) = v24;
          *((_BYTE *)this + 553) = v25;
          *((_BYTE *)this + 554) = v26;
          *((_BYTE *)this + 246) = 4;
          if (v24 == v25)
          {
            v61 = v24;
            v62 = v24;
            if (v25 == v26)
              goto LABEL_132;
          }
          _cg_jpeg_mem_term("initialize", 495, "*** ERROR unsupported 'argb/xrgb'-bitDepth: %d-%d-%d\n");
          goto LABEL_157;
        }
LABEL_131:
        _cg_jpeg_mem_term("initialize", 542, "*** ERROR unsupported 'v3Header.pixelFormatLo' 0x%08X\n", v22);
        v62 = *((unsigned __int8 *)this + 552);
        v61 = *((unsigned __int8 *)this + 553);
LABEL_132:
        if (v62 - 9 < 0xF6)
        {
          if (v61 <= 8)
          {
            _cg_jpeg_mem_term("initialize", 549, "*** _greenBits don't match _redBits  [0x%02X vs 0x%02X]\n");
            goto LABEL_157;
          }
          if (*((unsigned __int8 *)this + 554) <= 8u)
          {
            _cg_jpeg_mem_term("initialize", 551, "*** _blueBits don't match _redBits [0x%02X vs 0x%02X]\n");
            goto LABEL_157;
          }
        }
        if (v61 - 9 <= 0xF5 && *((unsigned __int8 *)this + 554) <= 8u)
        {
          _cg_jpeg_mem_term("initialize", 556, "*** _blueBits don't match _greenBits [0x%02X vs 0x%02X]\n");
          goto LABEL_157;
        }
        v23 = v62;
LABEL_138:
        if (v23 != 255 && v23 - 8 >= 0x19)
        {
          _cg_jpeg_mem_term("initialize", 560, "*** _redBits out of range  [0x%02X]\n");
          goto LABEL_157;
        }
        if (v61 != 255 && v61 - 8 >= 0x19)
        {
          _cg_jpeg_mem_term("initialize", 562, "*** _greenBits out of range  [0x%02X]\n");
          goto LABEL_157;
        }
        v64 = *((unsigned __int8 *)this + 554);
        if (v64 != 255 && (v64 - 8) >= 0x19)
        {
          _cg_jpeg_mem_term("initialize", 564, "*** _blueBits out of range  [0x%02X]\n");
          goto LABEL_157;
        }
        v65 = *((_DWORD *)this + 81);
        if (v65 == 1196573017)
        {
          *((_DWORD *)this + 59) = *((_DWORD *)this + 57);
          *((_QWORD *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D978]);
          *(_DWORD *)((char *)this + 242) = 65544;
          goto LABEL_77;
        }
        if (v65 != 1380401696)
          goto LABEL_147;
        goto LABEL_146;
      }
    }
    else
    {
      if (v60 <= 1919378039)
      {
        if (v60 == 1912602624)
        {
          *((_BYTE *)this + 548) = 6;
          *(_DWORD *)((char *)this + 242) = 65544;
          *((_DWORD *)this + 81) = 1196573017;
          *((_BYTE *)this + 552) = v23;
          *(_WORD *)((char *)this + 553) = -1;
          v61 = 255;
          *((_BYTE *)this + 555) = -1;
          goto LABEL_138;
        }
        if (v60 == 1919377920)
        {
          *((_BYTE *)this + 548) = 0;
          *((_BYTE *)this + 552) = v23;
          *((_BYTE *)this + 553) = v24;
          *((_BYTE *)this + 554) = v25;
          if (v23 != v24 || v24 != v25)
          {
            _cg_jpeg_mem_term("initialize", 481, "*** ERROR unsupported 'rgb'-bitDepth: %d-%d-%d\n");
            goto LABEL_157;
          }
          *((_BYTE *)this + 557) = 3;
          *((_WORD *)this + 122) = 4;
          *((_BYTE *)this + 246) = 5;
          v61 = v24;
          v62 = v23;
          goto LABEL_132;
        }
        if (v60 != 1919378017)
          goto LABEL_131;
        goto LABEL_118;
      }
      if (v60 == 1919378040)
      {
LABEL_118:
        *((_BYTE *)this + 548) = 2;
        *((_BYTE *)this + 552) = v23;
        *((_BYTE *)this + 553) = v24;
        *((_BYTE *)this + 554) = v25;
        *((_BYTE *)this + 555) = v26;
        *((_BYTE *)this + 246) = 3;
        if (v23 == v24)
        {
          v61 = v23;
          v62 = v23;
          if (v24 == v25)
            goto LABEL_132;
        }
        _cg_jpeg_mem_term("initialize", 507, "*** ERROR unsupported 'rgba/rgbx'-bitDepth: %d-%d-%d\n");
LABEL_157:
        kdebug_trace();
        return 4294967246;
      }
      if (v60 != 2019714930)
      {
        v63 = 2020763490;
        goto LABEL_114;
      }
    }
    *((_BYTE *)this + 548) = 5;
    *((_BYTE *)this + 555) = v23;
    *((_BYTE *)this + 554) = v24;
    *((_BYTE *)this + 553) = v25;
    *((_BYTE *)this + 552) = v26;
    *((_BYTE *)this + 246) = 4;
    if (v26 == v25)
    {
      v61 = v24;
      v62 = v24;
      if (v25 == v24)
        goto LABEL_132;
    }
    _cg_jpeg_mem_term("initialize", 527, "*** ERROR unsupported 'abgr/xbgr'-bitDepth: %d-%d-%d\n");
    goto LABEL_157;
  }
  LODWORD(v71) = 0;
  memset(v70, 0, sizeof(v70));
  v69 = 0u;
  if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), &v69, 0, 0x34uLL) != 52)
  {
    _cg_jpeg_mem_term("initialize", 302, "*** ERROR: PVR failed to read v2 header (%d bytes) expected: %d\n");
    goto LABEL_157;
  }
  if ((PVRReadPlugin::validateV2Header((uint64_t)this, &v69) & 1) == 0)
  {
    _cg_jpeg_mem_term("initialize", 305, "*** invalid PVR2 header\n");
    goto LABEL_157;
  }
  *((_DWORD *)this + 110) = 1;
  *((_DWORD *)this + 115) = 0;
  *(_QWORD *)((char *)this + 452) = 0;
  *(_QWORD *)((char *)this + 444) = 0;
  v9 = v69.u32[1];
  v8 = v69.u32[2];
  *((_QWORD *)this + 58) = *(uint64_t *)((char *)v69.i64 + 4);
  *((_DWORD *)this + 119) = v71;
  v10 = WORD4(v70[0]);
  v11 = v69.u32[3];
  *((_DWORD *)this + 118) = DWORD2(v70[0]);
  *((_DWORD *)this + 120) = 0;
  if (v11 <= 1)
    v11 = 1;
  *((_DWORD *)this + 121) = v11;
  *(_OWORD *)((char *)this + 500) = *(_OWORD *)((char *)v70 + 12);
  *((_QWORD *)this + 61) = 0x200000000;
  *((_BYTE *)this + 496) = 0;
  v12 = *((unsigned __int16 *)this + 159);
  if (v11 <= v12)
  {
    v13 = v11 - 1;
    *((_WORD *)this + 159) = v13;
    LOBYTE(v12) = v13;
  }
  *((_DWORD *)this + 57) = v8 >> v12;
  *((_DWORD *)this + 58) = v9 >> v12;
  *((_WORD *)this + 275) = v10;
  v14 = v70[0];
  *((_BYTE *)this + 520) = v70[0];
  *((_BYTE *)this + 498) = (v14 < 0x1Au) & (0x3003000u >> v14);
  if (v14 <= 0x29u)
  {
    switch(v14)
    {
      case 0x16u:
        goto LABEL_21;
      case 0x17u:
        *((_BYTE *)this + 246) = 3;
        *((_WORD *)this + 120) = 8;
        v15 = 2;
        goto LABEL_66;
      case 0x1Bu:
LABEL_21:
        *((_BYTE *)this + 246) = 0;
        *((_WORD *)this + 120) = 8;
        v15 = 1;
LABEL_66:
        *((_WORD *)this + 122) = v15;
        *((_QWORD *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D978]);
        v38 = 1196573017;
LABEL_69:
        *((_DWORD *)this + 81) = v38;
        goto LABEL_70;
    }
    goto LABEL_67;
  }
  if (v14 - 42 < 2)
  {
    *((_BYTE *)this + 246) = 3;
    *((_WORD *)this + 120) = 16;
    *((_WORD *)this + 122) = 4;
LABEL_68:
    *((_QWORD *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
    v38 = 1380401696;
    goto LABEL_69;
  }
  if (v14 != 50)
  {
LABEL_67:
    *((_WORD *)this + 120) = 8;
    *((_DWORD *)this + 61) = 196612;
    goto LABEL_68;
  }
  *((_BYTE *)this + 246) = 3;
  *((_WORD *)this + 120) = 16;
  *((_WORD *)this + 122) = 4;
  *((_QWORD *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D960]);
  *((_DWORD *)this + 81) = 1380401696;
  *((_BYTE *)this + 247) = 1;
  *((_BYTE *)this + 249) = 1;
LABEL_70:
  v39 = *((unsigned __int16 *)this + 121);
  if (v39 == 16)
  {
    v40 = 1;
    *((_BYTE *)this + 247) = 1;
  }
  else if (v39 == 32)
  {
    v40 = 0;
    *((_BYTE *)this + 247) = 0;
  }
  else
  {
    v40 = *((unsigned __int8 *)this + 247);
  }
  v41 = *((_WORD *)this + 120);
  v42 = *((_WORD *)this + 122) * v41;
  *((_WORD *)this + 121) = v42;
  v43 = v42;
  v45 = *((unsigned int *)this + 57);
  v44 = *((unsigned int *)this + 58);
  v46 = (v45 * v43) >> 3;
  *((_DWORD *)this + 59) = v46;
  *((_DWORD *)this + 65) = v45;
  *((_DWORD *)this + 66) = v44;
  *((_DWORD *)this + 67) = v46;
  *((_WORD *)this + 136) = v41;
  v47 = (v40 << 12) | (*((unsigned __int8 *)this + 248) << 16);
  LOBYTE(v46) = *((_BYTE *)this + 249) != 0;
  *((_BYTE *)this + 278) = *((_BYTE *)this + 246) & 0x1F;
  *((_BYTE *)this + 279) = v40 & 7;
  *((_BYTE *)this + 280) = BYTE2(v47) & 0xF;
  *((_BYTE *)this + 281) = v46;
  *((_BYTE *)this + 350) = 1;
  v48 = *((_QWORD *)this + 23);
  if (v48 <= v45)
  {
    _cg_jpeg_mem_term("initialize", 383, "*** unexpected image size: %d x %d\n");
    goto LABEL_157;
  }
  if (v48 <= v44)
  {
    _cg_jpeg_mem_term("initialize", 384, "*** unexpected image size: %d x %d\n");
    goto LABEL_157;
  }
LABEL_77:
  v49 = *((_DWORD *)this + 57);
  v50 = *((_DWORD *)this + 58);
  if (v49 == v50)
  {
    v51 = (int8x8_t)vdup_n_s32(v49);
  }
  else
  {
    _cg_jpeg_mem_term("initialize", 696, "*** NOTE: non-square PVR - %d x %d\n", *((_DWORD *)this + 57), v50);
    v51 = *(int8x8_t *)((char *)this + 228);
  }
  v52 = vbic_s8((int8x8_t)vceqz_s32((int32x2_t)vand_s8(v51, (int8x8_t)vadd_s32((int32x2_t)v51, (int32x2_t)-1))), (int8x8_t)vceqz_s32((int32x2_t)v51));
  v53 = v51.i32[0];
  v54 = v51.u32[1];
  if ((v52.i32[0] & v52.i32[1] & 1) == 0)
  {
    _cg_jpeg_mem_term("initialize", 702, "*** NOTE: non-power-of-2 PVR - %d x %d\n", v51.i32[0], v51.i32[1]);
    v53 = *((_DWORD *)this + 57);
    v54 = *((_DWORD *)this + 58);
  }
  if (v53 < 8 || v54 <= 7)
  {
    LogError("initialize", 706, "*** ERROR: can't handle PVR - %d x %d (too small)\n");
    goto LABEL_157;
  }
  if (v53 > 0x1000 || v54 > 0x1000)
  {
    LogError("initialize", 710, "*** ERROR: can't handle PVR - %d x %d (too small)\n");
    goto LABEL_157;
  }
  if (*((_WORD *)this + 120) == 8 && *((_WORD *)this + 121) == 32)
  {
    *((_WORD *)this + 138) = 4;
    *((_DWORD *)this + 68) = 2097160;
  }
  *((_BYTE *)this + 344) = 0;
  *((_BYTE *)this + 346) = 0;
  v55 = *((unsigned __int8 *)this + 247);
  v56 = (v55 << 12) | (*((unsigned __int8 *)this + 248) << 16);
  v57 = *((_BYTE *)this + 249) != 0;
  *((_BYTE *)this + 278) = *((_BYTE *)this + 246) & 0x1F;
  *((_BYTE *)this + 279) = v55 & 7;
  *((_BYTE *)this + 280) = BYTE2(v56) & 0xF;
  *((_BYTE *)this + 281) = v57;
  *((_BYTE *)this + 350) = 1;
  *((_WORD *)this + 188) = 1;
  v58 = IIO_Reader::minimumFileSize(*((IIO_Reader **)this + 3));
  result = 0;
  *((_DWORD *)this + 50) = v58;
  return result;
}

uint64_t PVRReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v2;

  v2 = *(__int16 *)(a1 + 376);
  if (v2 == 12)
    return IIOReadPlugin::setupImageProviderCallbackV2(a1, a2, (uint64_t)IIO_Reader::CopyImageBlockSetProc, (uint64_t)IIO_Reader::CopyIOSurfaceProc);
  if (v2 == 1)
    return IIOReadPlugin::setupCallback(a1, a2);
  return 4294967246;
}

uint64_t PVRReadPlugin::decodeImageDataPVR(PVRReadPlugin *this, unsigned __int8 *a2)
{
  unsigned int v4;
  unsigned int v5;
  unint64_t v6;
  int v7;
  unint64_t v8;
  unsigned int v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t BytesAtOffset;
  BOOL v15;
  int v16;
  void *data;
  BOOL v18;
  uint64_t height_low;
  size_t rowBytes;
  uint64_t v21;
  uint8_t permuteMap[4];
  vImage_Buffer dest;

  v5 = *((_DWORD *)this + 57);
  v4 = *((_DWORD *)this + 58);
  if (!*((_WORD *)this + 275))
  {
    v6 = *((unsigned __int8 *)this + 520);
    if (v6 <= 3)
      *((_WORD *)this + 275) = 0x4000400020002uLL >> (16 * v6);
  }
  v7 = *((unsigned __int8 *)this + 405);
  v8 = PVRReadPlugin::calculateOffsetToRequestedImage(this, 52);
  v9 = (v5 * *((unsigned __int16 *)this + 275)) >> 3;
  v10 = (unsigned __int8 *)malloc_type_calloc(v4 * (unint64_t)v9, 1uLL, 0xC6DE5CCCuLL);
  if (!v10)
    return 4294967246;
  v11 = v10;
  if (*((_DWORD *)this + 51) != 1261588566)
  {
    v13 = v9 * v4;
    BytesAtOffset = IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v10, v8, v13);
    if (BytesAtOffset)
      v15 = BytesAtOffset == v13;
    else
      v15 = 0;
    if (!v15)
      goto LABEL_25;
    goto LABEL_14;
  }
  LODWORD(dest.data) = *((_DWORD *)this + 52);
  *(void **)((char *)&dest.data + 4) = v10;
  *(_OWORD *)((char *)&dest.height + 4) = v4 * (unint64_t)v9;
  v12 = *((_QWORD *)this + 70);
  if (!v12)
  {
    LogFault("decodeImageDataPVR", 906, "*** _pvr._ktxTexture is NULL\n");
    goto LABEL_25;
  }
  if (!(*(unsigned int (**)(void))(*(_QWORD *)(v12 + 8) + 40))())
  {
    v13 = v9 * v4;
LABEL_14:
    memset(&dest, 0, sizeof(dest));
    v16 = decodePVRTC(&dest, v11, v13, *((unsigned __int16 *)this + 275), *((_DWORD *)this + 52), v5, v4);
    data = dest.data;
    if (v16)
      v18 = dest.data == 0;
    else
      v18 = 1;
    if (!v18)
    {
      height_low = LODWORD(dest.height);
      if (*((_WORD *)this + 153) == 32 && !v7)
      {
        *(_DWORD *)permuteMap = 50331906;
        vImagePermuteChannels_ARGB8888(&dest, &dest, permuteMap, 0x10u);
        data = dest.data;
      }
      rowBytes = *((unsigned int *)this + 75);
      if (dest.rowBytes < rowBytes)
        rowBytes = dest.rowBytes;
      memcpy(a2, data, rowBytes * height_low);
      free(data);
      v21 = 0;
      goto LABEL_26;
    }
  }
LABEL_25:
  v21 = 4294967246;
LABEL_26:
  free(v11);
  return v21;
}

uint64_t PVRReadPlugin::decodeImageDataV2(PVRReadPlugin *this, unsigned __int8 *a2)
{
  uint64_t v4;
  uint64_t v5;
  char v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  unint64_t v11;
  unsigned int v12;
  _BYTE *v13;
  _BYTE *v14;
  unint64_t Bytes;
  uint64_t v16;
  _QWORD v18[4];
  _QWORD v19[4];

  v4 = *((unsigned int *)this + 57);
  v5 = *((unsigned int *)this + 58);
  if (*((_BYTE *)this + 405))
    v6 = 2;
  else
    v6 = 3;
  v7 = *((unsigned __int8 *)this + 520);
  switch(*((_BYTE *)this + 520))
  {
    case 0:
      v8 = operator new();
      IIOPixelConverterRGB::IIOPixelConverterRGB(v8, 4, 4, 4u, 4, 4, 4, v6, 8u, 0, (uint64_t)"0x00-ARGB 4444");
      goto LABEL_19;
    case 1:
      v8 = operator new();
      IIOPixelConverterRGB::IIOPixelConverterRGB(v8, 4, 4, 5u, 5, 5, 1, v6, 8u, 0, (uint64_t)"0x01-ARGB 1555");
      goto LABEL_19;
    case 2:
      v8 = operator new();
      IIOPixelConverterRGB::IIOPixelConverterRGB(v8, 0, 3, 5u, 6, 5, 255, v6, 8u, 0, (uint64_t)"0x02-RGB 565");
      goto LABEL_19;
    case 3:
      v8 = operator new();
      IIOPixelConverterRGB::IIOPixelConverterRGB(v8, 0, 3, 5u, 5, 5, 255, v6, 8u, 0, (uint64_t)"0x03-RGB 555");
      goto LABEL_19;
    case 4:
      v8 = operator new();
      IIOPixelConverterRGB::IIOPixelConverterRGB(v8, 0, 3, 8u, 8, 8, 255, v6, 8u, 0, (uint64_t)"0x04-RGB 888");
      goto LABEL_19;
    case 5:
      v8 = operator new();
      v10 = 4;
      IIOPixelConverterRGB::IIOPixelConverterRGB(v8, 3, 4, 8u, 8, 8, 8, v6, 8u, 0, (uint64_t)"0x05-ARGB 8888");
      goto LABEL_20;
    case 6:
    case 7:
    case 8:
    case 9:
    case 0xA:
    case 0xB:
    case 0xC:
    case 0xD:
    case 0xE:
    case 0xF:
    case 0x18:
    case 0x19:
    case 0x1C:
    case 0x1D:
    case 0x1E:
    case 0x1F:
    case 0x20:
    case 0x21:
    case 0x22:
    case 0x23:
    case 0x24:
    case 0x25:
    case 0x26:
    case 0x27:
    case 0x28:
    case 0x29:
      goto LABEL_8;
    case 0x10:
      v8 = operator new();
      IIOPixelConverterRGB::IIOPixelConverterRGB(v8, 4, 4, 4u, 4, 4, 4, v6, 8u, 0, (uint64_t)"0x10-ARGB 4444");
      goto LABEL_19;
    case 0x11:
      v8 = operator new();
      IIOPixelConverterRGB::IIOPixelConverterRGB(v8, 4, 4, 5u, 5, 5, 1, v6, 8u, 0, (uint64_t)"0x11-ARGB 1555");
      goto LABEL_19;
    case 0x12:
      v8 = operator new();
      v10 = 4;
      IIOPixelConverterRGB::IIOPixelConverterRGB(v8, 2, 4, 8u, 8, 8, 8, v6, 8u, 0, (uint64_t)"0x12-ARGB 8888");
      goto LABEL_20;
    case 0x13:
      v8 = operator new();
      IIOPixelConverterRGB::IIOPixelConverterRGB(v8, 0, 3, 5u, 6, 5, 255, v6, 8u, 0, (uint64_t)"0x13-RGB 565");
      goto LABEL_19;
    case 0x14:
      v8 = operator new();
      IIOPixelConverterRGB::IIOPixelConverterRGB(v8, 0, 3, 5u, 5, 5, 255, v6, 8u, 0, (uint64_t)"0x14-RGB 555");
LABEL_19:
      v10 = 2;
      goto LABEL_20;
    case 0x15:
      v8 = operator new();
      v10 = 3;
      IIOPixelConverterRGB::IIOPixelConverterRGB(v8, 0, 3, 8u, 8, 8, 255, v6, 8u, 0, (uint64_t)"0x15-RGB 888");
      goto LABEL_20;
    case 0x16:
      v8 = operator new();
      v10 = 1;
      IIOPixelConverterGray::IIOPixelConverterGray(v8, 6, 1, 8u, 255, 6, 8u, 0, (uint64_t)"0x16-I8");
      goto LABEL_20;
    case 0x17:
      v8 = operator new();
      v10 = 1;
      IIOPixelConverterGray::IIOPixelConverterGray(v8, 8, 1, 8u, 8, 8, 8u, 0, (uint64_t)"0x16-I8");
      goto LABEL_20;
    case 0x1A:
      v8 = operator new();
      v10 = 4;
      IIOPixelConverterRGB::IIOPixelConverterRGB(v8, 3, 4, 8u, 8, 8, 8, v6, 8u, 0, (uint64_t)"0x1A-BGRA 8888");
      goto LABEL_20;
    case 0x1B:
      v8 = operator new();
      v10 = 1;
      IIOPixelConverterGray::IIOPixelConverterGray(v8, 6, 1, 8u, 255, 6, 8u, 0, (uint64_t)"0x1B-I8");
      goto LABEL_20;
    case 0x2A:
      v8 = operator new();
      v10 = 4;
      IIOPixelConverterRGB::IIOPixelConverterRGB(v8, 5, 4, 0xAu, 10, 10, 2, v6, 0x10u, 0, (uint64_t)"0x2A-ABGR 2101010");
      goto LABEL_20;
    case 0x2B:
      v8 = operator new();
      IIOPixelConverterRGB::IIOPixelConverterRGB(v8, 4, 4, 0xAu, 10, 10, 2, v6, 0x10u, 0, (uint64_t)"0x2B-ARGB 2101010");
      goto LABEL_36;
    default:
      if (v7 == 50)
      {
        v8 = operator new();
        IIOPixelConverterRGB::IIOPixelConverterRGB(v8, 22, 4, 0x10u, 16, 16, 16, 22, 0x10u, 0, (uint64_t)"0x32-ABGR 16161616F");
LABEL_36:
        v10 = 8;
LABEL_20:
        v11 = PVRReadPlugin::calculateOffsetToRequestedImage(this, 52);
        v12 = v10 * v4;
        v13 = malloc_type_malloc(v5 * (unint64_t)(v10 * v4), 0x240FF335uLL);
        if (v13)
        {
          v14 = v13;
          IIOImageReadSession::seek(*((IIOImageReadSession **)this + 3), v11, 0);
          Bytes = IIOImageReadSession::getBytes(*((IIOImageReadSession **)this + 3), v14, v5 * (unint64_t)v12);
          if (Bytes == v5 * (unint64_t)v12)
          {
            v19[0] = v14;
            v19[1] = v5;
            v19[2] = v4;
            v19[3] = (v10 * v4);
            v18[0] = a2;
            v18[1] = v5;
            v16 = *((unsigned int *)this + 75);
            v18[2] = v4;
            v18[3] = v16;
            v9 = (*(uint64_t (**)(uint64_t, _QWORD *, _QWORD *))(*(_QWORD *)v8 + 16))(v8, v19, v18);
            if ((_DWORD)v9)
              _cg_jpeg_mem_term("decodeImageDataV2", 1131, "*** ERROR: ImageIOPixelConverter->convert failed [%ld]\n", (int)v9);
          }
          else
          {
            _cg_jpeg_mem_term("decodeImageDataV2", 1143, "*** ERROR: PVR - requested %ld bytes, got %ld bytes\n", v5 * (unint64_t)v12, Bytes);
            v9 = 4294967246;
          }
          free(v14);
        }
        else
        {
          v9 = 4294967294;
        }
        (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
      }
      else
      {
LABEL_8:
        _cg_jpeg_mem_term("decodeImageDataV2", 1104, "*** ERROR: PVRV2 PixelFormat '%02X' not handled", v7);
        return 4294967294;
      }
      return v9;
  }
}

void sub_187FDE5A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10F1C401865CEE3);
  _Unwind_Resume(a1);
}

uint64_t PVRReadPlugin::decodeImageDataV3(PVRReadPlugin *this, unsigned __int8 *a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  char v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  _BYTE *v15;
  _BYTE *v16;
  unint64_t Bytes;
  uint64_t v18;
  uint64_t v19;
  _QWORD v21[4];
  _QWORD v22[4];

  if (*((unsigned __int8 *)this + 548) == 255)
  {
    if (*((unsigned __int8 *)this + 520) <= 5u)
      _cg_jpeg_mem_term("decodeImageDataV3", 1181, "*** PVRTC -- should be handled by: copyImageBlockSetPVR\n");
    return 4294967293;
  }
  else
  {
    v4 = *((unsigned int *)this + 73);
    v5 = *((unsigned int *)this + 74);
    v6 = *((unsigned __int8 *)this + 405);
    if (*((_BYTE *)this + 557))
      v7 = *((_BYTE *)this + 557);
    else
      v7 = 3;
    v8 = operator new();
    v9 = v8;
    if (v6)
      v10 = 2;
    else
      v10 = 3;
    IIOPixelConverterRGB::IIOPixelConverterRGB(v8, *((_BYTE *)this + 548), v7, *((unsigned __int8 *)this + 552), *((unsigned __int8 *)this + 553), *((unsigned __int8 *)this + 554), *((unsigned __int8 *)this + 555), v10, 8u, 0, (uint64_t)"v3");
    if (*((_WORD *)this + 275)
      && ((v11 = (*((unsigned __int16 *)this + 275) * (unint64_t)v4) >> 3,
           v12 = *((unsigned int *)this + 59),
           v11 <= v12)
        ? (v13 = v12)
        : (v13 = v11),
          v14 = PVRReadPlugin::calculateOffsetToRequestedImage(this, *((unsigned int *)this + 122) + 52),
          (v15 = malloc_type_calloc(v5 * (unint64_t)v13, 1uLL, 0xC8862C11uLL)) != 0))
    {
      v16 = v15;
      IIOImageReadSession::seek(*((IIOImageReadSession **)this + 3), v14, 0);
      Bytes = IIOImageReadSession::getBytes(*((IIOImageReadSession **)this + 3), v16, v5 * (unint64_t)v13);
      if (Bytes == v5 * (unint64_t)v13)
      {
        v22[0] = v16;
        v22[1] = v5;
        v22[2] = v4;
        v22[3] = v13;
        v21[0] = a2;
        v21[1] = v5;
        v18 = *((unsigned int *)this + 75);
        v21[2] = v4;
        v21[3] = v18;
        (*(void (**)(uint64_t, _QWORD *, _QWORD *))(*(_QWORD *)v9 + 16))(v9, v22, v21);
        v19 = 0;
      }
      else
      {
        _cg_jpeg_mem_term("decodeImageDataV3", 1318, "*** ERROR: PVR - requested %ld bytes, got %ld bytes\n", v5 * (unint64_t)v13, Bytes);
        v19 = 4294967293;
      }
      free(v16);
    }
    else
    {
      v19 = 4294967293;
    }
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  }
  return v19;
}

void sub_187FDE808(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10F1C401865CEE3);
  _Unwind_Resume(a1);
}

uint64_t PVRReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4)
{
  unint64_t v4;
  int v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  unsigned int v18;
  int v19;
  uint64_t v20;
  int v21;
  IIOImageRead **v22;
  _BOOL4 v23;
  char v24;
  unsigned int v25;
  double v26;
  void *BaseAddress;
  size_t Height;
  uint64_t BlockArray;
  size_t v30;
  unsigned int v31;
  memory_object_offset_t v32;
  double v33;
  int v34;
  uint64_t v35;
  vImagePixelCount v36;
  size_t v37;
  const char **v38;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  double v43;
  double v44;
  vImage_Buffer dest;
  size_t v46;
  CGRect v47;
  CGRect v48;

  v46 = 0;
  v9 = *((_DWORD *)this + 73);
  if ((gIIODebugFlags & 0x20000) == 0)
    goto LABEL_26;
  v10 = *((_DWORD *)this + 51);
  v11 = v10 >> 24;
  v12 = MEMORY[0x1E0C80978];
  if (v10 < 0)
  {
    v13 = __maskrune(v11, 0x40000uLL);
    v10 = *((_DWORD *)this + 51);
  }
  else
  {
    v13 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v11 + 60) & 0x40000;
  }
  if (v13)
    v14 = (v10 >> 24);
  else
    v14 = 46;
  v15 = v10 << 8 >> 24;
  if (v10 << 8 < 0)
  {
    v16 = __maskrune(v15, 0x40000uLL);
    v10 = *((_DWORD *)this + 51);
  }
  else
  {
    v16 = *(_DWORD *)(v12 + 4 * v15 + 60) & 0x40000;
  }
  if (v16)
    v17 = (v10 << 8 >> 24);
  else
    v17 = 46;
  v18 = (__int16)v10 >> 8;
  if (v10 << 16 < 0)
  {
    v19 = __maskrune(v18, 0x40000uLL);
    v10 = *((_DWORD *)this + 51);
  }
  else
  {
    v19 = *(_DWORD *)(v12 + 4 * v18 + 60) & 0x40000;
  }
  if (v19)
    v20 = ((__int16)v10 >> 8);
  else
    v20 = 46;
  if ((v10 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v12 + 4 * (char)v10 + 60) & 0x40000) != 0)
      goto LABEL_22;
LABEL_24:
    LOBYTE(v21) = 46;
    goto LABEL_25;
  }
  if (!__maskrune((char)v10, 0x40000uLL))
    goto LABEL_24;
LABEL_22:
  v21 = *((_DWORD *)this + 51);
LABEL_25:
  ImageIOLog("  '%c%c%c%c' [%s] %s\n", v14, v17, v20, (char)v21, iioTypeStr[a3], "virtual OSStatus PVRReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  v22 = (IIOImageRead **)*((_QWORD *)this + 3);
  if (v22)
  {
    v23 = IIOImageReadSession::mapData(v22);
    v22 = (IIOImageRead **)*((_QWORD *)this + 3);
  }
  else
  {
    v23 = 0;
  }
  IIOImageReadSession::rewind((uint64_t)v22);
  if (*((_BYTE *)this + 498))
  {
    v24 = 1;
LABEL_37:
    *((_BYTE *)this + 556) = v24;
    goto LABEL_38;
  }
  if (*((_DWORD *)this + 123) != 2)
  {
    v24 = 3;
    goto LABEL_37;
  }
  *((_BYTE *)this + 556) = 2;
  if (*((_DWORD *)this + 75) <= (*((_DWORD *)this + 118) * v9) >> 3)
    v25 = (*((_DWORD *)this + 118) * v9) >> 3;
  else
    v25 = *((_DWORD *)this + 75);
  *((_DWORD *)this + 75) = v25;
LABEL_38:
  if (a3 == 3)
  {
    BlockArray = IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
    LODWORD(v4) = *((_DWORD *)this + 73);
    v31 = *((_DWORD *)this + 74);
    v30 = *((unsigned int *)this + 75) * (unint64_t)v31;
    v32 = _ImageIO_Malloc(v30, *((_QWORD *)this + 48), &v46, (uint64_t)kImageMalloc_PVR_Data[0], *((_DWORD *)this + 108), 0, 0);
    if (!v32)
      goto LABEL_67;
    BaseAddress = (void *)v32;
    v33 = (double)v4;
    v26 = (double)v31;
  }
  else
  {
    v26 = 0.0;
    if (a3 == 1)
    {
      if (!a4 || !*a4)
      {
LABEL_66:
        BlockArray = 0;
        goto LABEL_67;
      }
      IOSurfaceLock(*a4, 0, 0);
      BaseAddress = IOSurfaceGetBaseAddress(*a4);
      Height = IOSurfaceGetHeight(*a4);
      BlockArray = 0;
      v30 = IOSurfaceGetBytesPerRow(*a4) * Height;
      v46 = v30;
    }
    else
    {
      v30 = 0;
      BaseAddress = 0;
      BlockArray = 0;
    }
    v33 = 0.0;
  }
  bzero(BaseAddress, v30);
  v34 = *((unsigned __int8 *)this + 556);
  switch(v34)
  {
    case 3:
      v35 = PVRReadPlugin::decodeImageDataV3(this, (unsigned __int8 *)BaseAddress);
      break;
    case 2:
      v35 = PVRReadPlugin::decodeImageDataV2(this, (unsigned __int8 *)BaseAddress);
      break;
    case 1:
      v35 = PVRReadPlugin::decodeImageDataPVR(this, (unsigned __int8 *)BaseAddress);
      break;
    default:
      goto LABEL_54;
  }
  BlockArray = v35;
LABEL_54:
  if ((_DWORD)BlockArray)
  {
    *((_DWORD *)this + 26) = 0;
    if (a3 == 3 && BaseAddress)
    {
      _ImageIO_Free((unint64_t)BaseAddress, v46);
      if (!v23)
        return BlockArray;
      goto LABEL_68;
    }
LABEL_67:
    if (!v23)
      return BlockArray;
    goto LABEL_68;
  }
  if (*((_WORD *)this + 153) == 32 && *((_WORD *)this + 152) == 8 && *((_BYTE *)this + 406) == 1)
  {
    v36 = *((unsigned int *)this + 74);
    dest.data = BaseAddress;
    dest.height = v36;
    v37 = *((unsigned int *)this + 75);
    dest.width = *((unsigned int *)this + 73);
    dest.rowBytes = v37;
    vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
  }
  if (a3 != 3)
  {
    if (a3 == 1)
      IOSurfaceUnlock(*a4, 0, 0);
    goto LABEL_66;
  }
  v40 = 0;
  v47.origin.x = 0.0;
  v47.origin.y = 0.0;
  v47.size.width = v33;
  v47.size.height = v26;
  **((_QWORD **)this + 12) = IIOReadPlugin::createImageBlock(this, BaseAddress, v30, v47, *((unsigned int *)this + 75), *((unsigned __int8 *)this + 343));
  if (CGRectEqualToRect(*(CGRect *)((char *)this + 120), *MEMORY[0x1E0C9D628]))
  {
    v41 = 0;
  }
  else
  {
    v48.origin.x = 0.0;
    v48.origin.y = 0.0;
    v48.size.width = v33;
    v48.size.height = v26;
    *(CGRect *)(&v41 - 1) = CGRectUnion(*(CGRect *)((char *)this + 120), v48);
    v40 = v42;
    v33 = v43;
    v26 = v44;
  }
  BlockArray = 0;
  *((_QWORD *)this + 15) = v40;
  *((_QWORD *)this + 16) = v41;
  *((double *)this + 17) = v33;
  *((double *)this + 18) = v26;
  if (v23)
  {
LABEL_68:
    v38 = (const char **)*((_QWORD *)this + 3);
    if (v38)
      IIOImageReadSession::unmapData(v38);
  }
  return BlockArray;
}

uint64_t ASTCTextureImp::loadDataFromXPCObject(ASTCTextureImp *this, xpc_object_t xdict)
{
  _OWORD *data;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  size_t length;

  length = 0;
  data = xpc_dictionary_get_data(xdict, "iio_xpc_plugin_data_astc_imp", &length);
  if (length == 232)
  {
    v4 = *data;
    v5 = data[2];
    *((_OWORD *)this + 2) = data[1];
    *((_OWORD *)this + 3) = v5;
    *((_OWORD *)this + 1) = v4;
    v6 = data[3];
    v7 = data[4];
    v8 = data[6];
    *((_OWORD *)this + 6) = data[5];
    *((_OWORD *)this + 7) = v8;
    *((_OWORD *)this + 4) = v6;
    *((_OWORD *)this + 5) = v7;
    v9 = data[7];
    v10 = data[8];
    v11 = data[10];
    *((_OWORD *)this + 10) = data[9];
    *((_OWORD *)this + 11) = v11;
    *((_OWORD *)this + 8) = v9;
    *((_OWORD *)this + 9) = v10;
    v12 = data[11];
    v13 = data[12];
    v14 = data[13];
    *((_QWORD *)this + 30) = *((_QWORD *)data + 28);
    *((_OWORD *)this + 13) = v13;
    *((_OWORD *)this + 14) = v14;
    *((_OWORD *)this + 12) = v12;
    pthread_mutex_init((pthread_mutex_t *)((char *)this + 168), 0);
    *((_QWORD *)this + 7) = 0;
    *((_DWORD *)this + 58) = 0;
    *((_QWORD *)this + 30) = 0;
    *((_QWORD *)this + 9) = 0;
    *((_QWORD *)this + 10) = 0;
    *((_QWORD *)this + 16) = 0;
    *((_QWORD *)this + 17) = 0;
    *((_QWORD *)this + 15) = 0;
  }
  return 0;
}

uint64_t ASTCTextureImp::saveDataToXPCObject(ASTCTextureImp *this, void *a2)
{
  iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_astc_imp", (char *)this + 16, 0xE8uLL);
  return 0;
}

uint64_t ASTCTextureImp::set_needs_hdr(uint64_t this, char a2)
{
  *(_BYTE *)(this + 42) = a2;
  return this;
}

uint64_t ASTCTextureImp::createDecodedDataFromLZFSECompressedData(ASTCTextureImp *this, IIOImageReadSession *a2, unsigned __int8 *a3, size_t a4, unsigned __int8 **a5, uint8_t **a6)
{
  size_t v8;
  void *v10;
  uint8_t *v11;
  compression_status v12;
  uint64_t result;
  compression_stream v14;

  *a5 = 0;
  *a6 = 0;
  if (a4)
  {
    v8 = a4;
    memset(&v14, 0, sizeof(v14));
    if (compression_stream_init(&v14, COMPRESSION_STREAM_DECODE, COMPRESSION_LZFSE) == COMPRESSION_STATUS_OK)
    {
      v14.src_ptr = a3;
      v14.src_size = v8;
      v10 = malloc_type_malloc(v8, 0x75FE6B69uLL);
      v11 = 0;
      while (1)
      {
        if ((unint64_t)v11 >= v8)
        {
          v8 += v8 >> 1;
          v10 = reallocf(v10, v8);
        }
        v14.dst_ptr = &v11[(_QWORD)v10];
        v14.dst_size = v8 - (_QWORD)v11;
        v12 = compression_stream_process(&v14, 0);
        if (v12 == COMPRESSION_STATUS_ERROR)
          break;
        v11 = (uint8_t *)(v14.dst_ptr - (uint8_t *)v10);
        if (v12 == COMPRESSION_STATUS_END)
        {
          compression_stream_destroy(&v14);
          result = 0;
          *a5 = (unsigned __int8 *)v10;
          *a6 = v11;
          return result;
        }
      }
      free(v10);
      compression_stream_destroy(&v14);
    }
  }
  return 4294967243;
}

uint64_t ASTCTextureImp::BlockFormatForASTCBlockSize(ASTCTextureImp *this, char a2)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;

  v2 = (a2 | (16 * (_BYTE)this));
  if (v2 > 0x87)
  {
    if ((a2 | (16 * (_BYTE)this)) > 0xC9u)
    {
      v11 = 14;
      if (v2 != 204)
        v11 = 0;
      if (v2 == 202)
        return 13;
      else
        return v11;
    }
    else
    {
      result = 0;
      switch(v2)
      {
        case 0xA5u:
          result = 9;
          break;
        case 0xA6u:
          result = 10;
          break;
        case 0xA7u:
        case 0xA9u:
          return result;
        case 0xA8u:
          result = 11;
          break;
        case 0xAAu:
          result = 12;
          break;
        default:
          if (v2 == 136)
            result = 8;
          else
            result = 0;
          break;
      }
    }
  }
  else
  {
    v3 = 6;
    v4 = 7;
    if (v2 != 134)
      v4 = 0;
    if (v2 != 133)
      v3 = v4;
    v5 = 4;
    v6 = 5;
    if (v2 != 102)
      v6 = 0;
    if (v2 != 101)
      v5 = v6;
    if ((a2 | (16 * (_BYTE)this)) <= 0x84u)
      v3 = v5;
    v7 = 1;
    v8 = 2;
    v9 = 3;
    if (v2 != 85)
      v9 = 0;
    if (v2 != 84)
      v8 = v9;
    if (v2 != 68)
      v7 = v8;
    if ((a2 | (16 * (_BYTE)this)) <= 0x64u)
      return v7;
    else
      return v3;
  }
  return result;
}

uint64_t ASTCTextureImp::HDRBlockFormat(ASTCTextureImp *this, at_block_format_t a2)
{
  if ((unint64_t)this - 1 >= 0xE)
    return 0;
  else
    return (uint64_t)this + 16;
}

uint64_t ASTCTextureImp::MetalFormatForVulkanFormat(ASTCTextureImp *this)
{
  int v1;
  uint64_t result;

  v1 = (_DWORD)this - 157;
  result = 204;
  switch(v1)
  {
    case 0:
      return result;
    case 1:
      result = 186;
      break;
    case 2:
      result = 205;
      break;
    case 3:
      result = 187;
      break;
    case 4:
      result = 206;
      break;
    case 5:
      result = 188;
      break;
    case 6:
      result = 207;
      break;
    case 7:
      result = 189;
      break;
    case 8:
      result = 208;
      break;
    case 9:
      result = 190;
      break;
    case 10:
      result = 210;
      break;
    case 11:
      result = 192;
      break;
    case 12:
      result = 211;
      break;
    case 13:
      result = 193;
      break;
    case 14:
      result = 212;
      break;
    case 15:
      result = 194;
      break;
    case 16:
      result = 213;
      break;
    case 17:
      result = 195;
      break;
    case 18:
      result = 214;
      break;
    case 19:
      result = 196;
      break;
    case 20:
      result = 215;
      break;
    case 21:
      result = 197;
      break;
    case 22:
      result = 216;
      break;
    case 23:
      result = 198;
      break;
    case 24:
      result = 217;
      break;
    case 25:
      result = 199;
      break;
    case 26:
      result = 218;
      break;
    case 27:
      result = 200;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

char *ASTCTextureImp::createTwiddledDataFromLinear(char *this, IIOImageReadSession *a2, uint64_t a3)
{
  char *v3;
  unsigned int Size;
  int v7;
  unsigned int v8;
  IIOImageRead *v9;
  const void *v10;
  uint64_t v11;

  v3 = this;
  if (*((_DWORD *)this + 58))
  {
    *((_QWORD *)this + 10) = 0;
    return this;
  }
  ASTCTextureImp::createTwiddler((ASTCTwiddler *)this, 1uLL);
  this = (char *)*((_QWORD *)v3 + 30);
  if (this)
  {
    if (ASTCTwiddler::finalized((ASTCTwiddler *)this))
    {
      if (a3)
      {
LABEL_8:
        *((_QWORD *)v3 + 10) = ASTCTwiddler::twiddledData(*((ASTCTwiddler **)v3 + 30));
        this = (char *)ASTCTwiddler::twiddledDataSize(*((ASTCTwiddler **)v3 + 30));
        *((_QWORD *)v3 + 18) = this;
        *((_QWORD *)v3 + 19) = 0;
        *((_QWORD *)v3 + 20) = this;
        *((_DWORD *)v3 + 58) = 0;
        return this;
      }
LABEL_7:
      ASTCTwiddler::finalizeTwiddling(*((ASTCTwiddler **)v3 + 30));
      goto LABEL_8;
    }
    if (!*((_QWORD *)v3 + 15))
    {
      v9 = IIOImageReadSession::retainBytePointer(a2, (const __CFData **)v3 + 16, 1);
      *((_QWORD *)v3 + 15) = v9;
      if (!v9)
        goto LABEL_19;
      if (IIOImageSource::cf(a2))
      {
        v10 = (const void *)IIOImageSource::cf(a2);
        *((_QWORD *)v3 + 17) = v10;
        CFRetain(v10);
      }
      if (!*((_QWORD *)v3 + 15))
      {
LABEL_19:
        this = (char *)_cg_jpeg_mem_term("createTwiddledDataFromLinear", 832, "*** Can't access image data\n");
        goto LABEL_26;
      }
    }
    if (!*((_QWORD *)v3 + 14))
    {
      this = (char *)LogError("createTwiddledDataFromLinear", 801, "*** ERROR: _imp._textureBaseOffset is zero - that's wrong (should be the offset to the ASTC data).\n");
      goto LABEL_26;
    }
    Size = IIOImageReadSession::getSize(a2);
    v7 = *((_DWORD *)v3 + 7);
    if (v7 == 8)
    {
      if (*((_DWORD *)v3 + 8) == 8)
      {
        v8 = (*((_DWORD *)v3 + 26) * *((_DWORD *)v3 + 25)) >> 2;
        goto LABEL_24;
      }
    }
    else if (v7 == 4 && *((_DWORD *)v3 + 8) == 4)
    {
      v8 = *((_DWORD *)v3 + 26) * *((_DWORD *)v3 + 25);
LABEL_24:
      v11 = *((_QWORD *)v3 + 14);
      if (v11 + (unint64_t)v8 <= Size)
      {
        ASTCTwiddler::copyFromLinearData(*((ASTCTwiddler **)v3 + 30), *((const void **)v3 + 15), v11, Size, (16 * *((_DWORD *)v3 + 5)), *((_DWORD *)v3 + 4));
        if (a3)
          goto LABEL_8;
        goto LABEL_7;
      }
      this = (char *)LogError("createTwiddledDataFromLinear", 823, "*** Can't access image data [%ld/%ld] (%dx%d)\n");
LABEL_26:
      *((_QWORD *)v3 + 10) = 0;
      *((_DWORD *)v3 + 58) = -50;
      return this;
    }
    v8 = 0;
    goto LABEL_24;
  }
  return this;
}

CFTypeRef ASTCTextureImp::createLinearDataFromLinear(CFTypeRef this, IIOImageReadSession *a2)
{
  uint64_t v2;
  uint64_t v3;
  const void *v5;

  v2 = (uint64_t)this;
  v3 = *((_QWORD *)this + 15);
  if (v3
    || (*((_QWORD *)this + 15) = IIOImageReadSession::retainBytePointer(a2, (const __CFData **)this + 16, 1),
        v5 = (const void *)IIOImageSource::cf(a2),
        *(_QWORD *)(v2 + 136) = v5,
        this = CFRetain(v5),
        (v3 = *(_QWORD *)(v2 + 120)) != 0))
  {
    *(_QWORD *)(v2 + 56) = v3 + *(_QWORD *)(v2 + 112);
    *(_BYTE *)(v2 + 43) = 1;
  }
  else
  {
    this = (CFTypeRef)_cg_jpeg_mem_term("createLinearDataFromLinear", 979, "*** Can't access image data\n");
    *(_QWORD *)(v2 + 56) = 0;
  }
  return this;
}

uint64_t ASTCTextureImp::decodeRGBXFromLinear(ASTCTextureImp *this, IIOImageReadSession *a2, vImage_Buffer *a3, at_alpha_t a4, at_block_format_t a5, at_texel_format_t a6)
{
  IIOImageRead *v12;
  IIOImageRead *Size;
  uint64_t v14;
  unint64_t v15;
  _BYTE *v16;
  unint64_t BytesAtOffset;
  void *v18;
  NSObject *v19;
  NSObject *v20;
  vImagePixelCount height;
  size_t rowBytes;
  unint64_t block_counts;
  unint64_t v24;
  unsigned int v25;
  at_error_t v26;
  uint64_t v27;
  at_texel_region_t dest;
  at_block_buffer_t src;
  void *v31;
  at_size_t v32;

  v31 = 0;
  v12 = IIOImageReadSession::retainBytePointer(a2, (const __CFData **)&v31, 0);
  Size = IIOImageReadSession::getSize(a2);
  v14 = *((_QWORD *)this + 14);
  v15 = (unint64_t)Size - v14;
  if ((uint64_t)Size - v14 <= 0)
  {
    IIOImageReadSession::getSize(a2);
    _cg_jpeg_mem_term("decodeRGBXFromLinear", 1159, "*** ERROR: truncated file? (fileSize: %lld  textureOffset: %lld\n)\n");
    goto LABEL_25;
  }
  if (v15 < (unint64_t)(float)((float)(*((float *)this + 9)
                                             * (float)(*((_DWORD *)this + 26) * *((_DWORD *)this + 25)))
                                     * 0.125))
  {
    _cg_jpeg_mem_term("decodeRGBXFromLinear", 1162, "*** bad input data (input size: %ld  bytesNeeded: %d  (%d x %d) bpp: %g)\n");
    goto LABEL_25;
  }
  if (v12)
  {
    v16 = (char *)v12 + v14;
    if ((v16 & 0xF) == 0)
    {
      v18 = 0;
      goto LABEL_10;
    }
    IIOImageReadSession::releaseBytePointer((IIOImageRead **)a2, v31);
    v31 = 0;
  }
  v16 = malloc_type_malloc(v15, 0xA55E2EA2uLL);
  BytesAtOffset = IIOImageReadSession::getBytesAtOffset(a2, v16, *((_QWORD *)this + 14), v15);
  if (v15 == BytesAtOffset)
  {
    v18 = v16;
    if (!v16)
    {
      _cg_jpeg_mem_term("decodeRGBXFromLinear", 1186, "*** tempLinearBuffer is nil\n");
LABEL_25:
      v27 = 4294967246;
      goto LABEL_19;
    }
LABEL_10:
    v19 = at_encoder_create(a6, a4, a5, a4, 0);
    if (!v19)
    {
      v27 = 4294967246;
      if (!v18)
        goto LABEL_19;
      goto LABEL_18;
    }
    v20 = v19;
    height = a3->height;
    dest.texels = a3->data;
    rowBytes = a3->rowBytes;
    dest.validSize.x = a3->width;
    dest.validSize.y = height;
    *((_DWORD *)&dest.validSize + 3) = 0;
    dest.rowBytes = rowBytes;
    dest.validSize.z = 1;
    dest.sliceBytes = 0;
    *(_QWORD *)&v32.x = *(_QWORD *)&dest.validSize.x;
    v32.z = 1;
    block_counts = (unint64_t)at_encoder_get_block_counts(v19, v32);
    v24 = HIDWORD(block_counts);
    src.blocks = v16;
    v25 = block_counts;
    src.rowBytes = at_encoder_get_block_size(v20) * block_counts;
    src.sliceBytes = v24 * (unint64_t)v25 * at_encoder_get_block_size(v20);
    if (v15 >= src.sliceBytes)
    {
      v26 = at_encoder_decompress_texels(v20, &src, &dest, at_flags_default);
      if (v26 == at_error_success)
      {
        v27 = 0;
LABEL_15:

        if (!v18)
          goto LABEL_19;
LABEL_18:
        free(v18);
        goto LABEL_19;
      }
      LogError("decodeRGBXFromLinear", 1226, "at_encoder_decompress_texels returned: %ld\n", v26);
    }
    v27 = 4294967246;
    goto LABEL_15;
  }
  _cg_jpeg_mem_term("decodeRGBXFromLinear", 1183, "got: %ld expected: %ld\n", BytesAtOffset, v15);
  v27 = 4294967246;
  v18 = v16;
  if (v16)
    goto LABEL_18;
LABEL_19:
  if (v31)
    IIOImageReadSession::releaseBytePointer((IIOImageRead **)a2, v31);
  return v27;
}

uint64_t ASTCTextureImp::decodeRGBXFromMemory(ASTCTextureImp *this, void *a2, size_t a3, vImage_Buffer *a4, uint64_t texelAlphaType, at_block_format_t blockType, at_texel_format_t texelType)
{
  NSObject *v10;
  NSObject *v11;
  vImagePixelCount height;
  size_t rowBytes;
  unint64_t block_counts;
  unsigned int v15;
  unint64_t v16;
  uint64_t v17;
  at_error_t v18;
  at_texel_region_t dest;
  at_block_buffer_t src;
  at_size_t v22;

  if (!a2)
  {
    _cg_jpeg_mem_term("decodeRGBXFromMemory", 1257, "*** srcBuffer is nil\n", a4, texelAlphaType, blockType, texelType);
    return 4294967246;
  }
  v10 = at_encoder_create(texelType, (at_alpha_t)texelAlphaType, blockType, (at_alpha_t)texelAlphaType, 0);
  if (!v10)
    return 4294967246;
  v11 = v10;
  height = a4->height;
  dest.texels = a4->data;
  rowBytes = a4->rowBytes;
  dest.validSize.x = a4->width;
  dest.validSize.y = height;
  *((_DWORD *)&dest.validSize + 3) = 0;
  dest.rowBytes = rowBytes;
  dest.validSize.z = 1;
  dest.sliceBytes = 0;
  *(_QWORD *)&v22.x = *(_QWORD *)&dest.validSize.x;
  v22.z = 1;
  block_counts = (unint64_t)at_encoder_get_block_counts(v10, v22);
  v15 = block_counts;
  v16 = HIDWORD(block_counts);
  src.blocks = a2;
  src.rowBytes = at_encoder_get_block_size(v11) * block_counts;
  src.sliceBytes = v16 * (unint64_t)v15 * at_encoder_get_block_size(v11);
  if (src.sliceBytes > a3)
  {

    return 4294967246;
  }
  v18 = at_encoder_decompress_texels(v11, &src, &dest, at_flags_default);
  if (v18)
  {
    LogError("decodeRGBXFromMemory", 1292, "at_encoder_decompress_texels returned: %ld\n", v18);
    v17 = 4294967246;
  }
  else
  {
    v17 = 0;
  }

  return v17;
}

uint64_t ASTCTextureImp::decodeRGBXFromLinearLZFSE(ASTCTextureImp *this, IIOImageReadSession *a2, vImage_Buffer *a3, at_alpha_t a4, at_block_format_t a5, at_texel_format_t a6)
{
  IIOImageRead *v12;
  IIOImageReadSession *v13;
  IIOImageRead *Size;
  unsigned __int8 *v15;
  uint64_t v16;
  unsigned __int8 *v17;
  uint64_t v18;
  unint64_t BytesAtOffset;
  size_t *v20;
  uint64_t v21;
  void *v23;
  uint64_t DecodedDataFromLZFSECompressedData;
  NSObject *v25;
  NSObject *v26;
  vImagePixelCount height;
  size_t rowBytes;
  unsigned int v29;
  unint64_t block_counts;
  unint64_t v31;
  unsigned int v32;
  float v33;
  float v34;
  at_block_features_t v35;
  size_t v36;
  at_error_t v37;
  at_block_format_t blockType;
  size_t outSize;
  at_texel_region_t dest;
  at_block_buffer_t src;
  void *v42;
  at_size_t v43;
  at_size_t v44;

  v42 = 0;
  v12 = IIOImageReadSession::retainBytePointer(a2, (const __CFData **)&v42, 0);
  Size = IIOImageReadSession::getSize(a2);
  if (v12)
  {
    v15 = 0;
    v16 = *((_QWORD *)this + 6);
    v17 = (unsigned __int8 *)v12 + v16;
    v18 = *((unsigned int *)this + 11);
  }
  else
  {
    v15 = (unsigned __int8 *)malloc_type_malloc(*((unsigned int *)this + 11), 0xC0A2AC22uLL);
    BytesAtOffset = IIOImageReadSession::getBytesAtOffset(a2, v15, *((_QWORD *)this + 6), *((unsigned int *)this + 11));
    v18 = *((unsigned int *)this + 11);
    if (BytesAtOffset != v18)
    {
      _cg_jpeg_mem_term("decodeRGBXFromLinearLZFSE", 1332, "got: %ld expected: %ld\n", BytesAtOffset, v18);
LABEL_7:
      v21 = 4294967246;
      if (!v15)
        goto LABEL_9;
      goto LABEL_8;
    }
    v16 = *((_QWORD *)this + 6);
    v17 = v15;
  }
  *((_QWORD *)this + 8) = 0;
  v20 = (size_t *)((char *)this + 64);
  if (v16 + v18 > (unint64_t)Size)
  {
    LogError("decodeRGBXFromLinearLZFSE", 1340, "*** bad file ***  (fileSize: %ld   compressedDataOffset: %ld   compressedSize: %ld\n", Size, v16, v18);
    goto LABEL_7;
  }
  blockType = a5;
  v23 = (void *)*((_QWORD *)this + 7);
  if (v23)
    free(v23);
  *((_QWORD *)this + 7) = 0;
  DecodedDataFromLZFSECompressedData = ASTCTextureImp::createDecodedDataFromLZFSECompressedData((ASTCTextureImp *)v23, v13, v17, *((unsigned int *)this + 11), (unsigned __int8 **)this + 7, (uint8_t **)this + 8);
  if ((_DWORD)DecodedDataFromLZFSECompressedData)
  {
    v21 = DecodedDataFromLZFSECompressedData;
    if (!v15)
      goto LABEL_9;
LABEL_8:
    free(v15);
    goto LABEL_9;
  }
  v25 = at_encoder_create(a6, a4, a5, a4, 0);
  if (v25)
  {
    v26 = v25;
    height = a3->height;
    dest.texels = a3->data;
    rowBytes = a3->rowBytes;
    dest.validSize.x = a3->width;
    dest.validSize.y = height;
    *((_DWORD *)&dest.validSize + 3) = 0;
    dest.rowBytes = rowBytes;
    dest.validSize.z = 1;
    dest.sliceBytes = 0;
    v29 = height;
    *(_QWORD *)&v43.x = *(_QWORD *)&dest.validSize.x;
    v43.z = 1;
    block_counts = (unint64_t)at_encoder_get_block_counts(v25, v43);
    v31 = HIDWORD(block_counts);
    src.blocks = (void *)*((_QWORD *)this + 7);
    v32 = block_counts;
    src.rowBytes = at_encoder_get_block_size(v26) * block_counts;
    src.sliceBytes = v31 * (unint64_t)v32 * at_encoder_get_block_size(v26);
    v33 = (float)*((unint64_t *)this + 8);
    v34 = (float)(a3->height * a3->width);
    if ((float)((float)(ASTCBitsPerPixel(*((unsigned __int8 *)this + 28), *((unsigned __int8 *)this + 32)) * v34)
               * 0.125) > v33)
    {
      _cg_jpeg_mem_term("decodeRGBXFromLinearLZFSE", 1373, "*** bad linearDataSize: %d for image: %dx%d\n", *v20, a3->width, a3->height);
    }
    else
    {
      outSize = 0;
      *(_QWORD *)&v44.x = *(_QWORD *)&dest.validSize.x;
      v44.z = 1;
      v35.bits = at_block_get_features(blockType, &src, v44, Size, &outSize, at_flags_default).bits;
      if (outSize > *v20)
      {
        v36 = *v20 / src.rowBytes * ((v35.bits >> 22) & 0xFFF);
        if (v36 >= 0xFFFFFFFF)
          LODWORD(v36) = -1;
        if (v36 >= v29)
          LODWORD(v36) = v29;
        dest.validSize.y = v36;
      }
      v37 = at_encoder_decompress_texels(v26, &src, &dest, at_flags_default);
      if (v37)
        LogError("decodeRGBXFromLinearLZFSE", 1389, "at_encoder_decompress_texels returned: %ld\n", v37);

    }
  }
  v21 = 0;
  if (v15)
    goto LABEL_8;
LABEL_9:
  if (v42)
    IIOImageReadSession::releaseBytePointer((IIOImageRead **)a2, v42);
  return v21;
}

at_error_t ASTCTextureImp::decodeRGBXFromTwiddled(ASTCTextureImp *this, IIOImageReadSession *a2, vImage_Buffer *a3, at_alpha_t a4, at_block_format_t a5, at_texel_format_t a6)
{
  IIOImageRead *v12;
  void *v13;
  _BYTE *v14;
  int v15;
  uint64_t v16;
  unint64_t v17;
  ASTCTwiddler *v18;
  unsigned int v19;
  void *v20;
  void *v21;
  NSObject *v22;
  NSObject *v23;
  vImagePixelCount height;
  size_t rowBytes;
  unint64_t block_counts;
  unint64_t v27;
  unsigned int v28;
  at_error_t v29;
  IIOImageRead *Size;
  IIOImageRead *v31;
  unint64_t v32;
  unint64_t BytesAtOffset;
  at_texel_region_t dest;
  at_block_buffer_t src;
  void *v37;
  at_size_t v38;

  v37 = 0;
  v12 = IIOImageReadSession::retainBytePointer(a2, (const __CFData **)&v37, 0);
  if (v12)
  {
    v13 = 0;
    v14 = (char *)v12 + *((_QWORD *)this + 14);
    goto LABEL_3;
  }
  Size = IIOImageReadSession::getSize(a2);
  v31 = (IIOImageRead *)*((_QWORD *)this + 14);
  v32 = Size - v31;
  if (Size == v31)
  {
LABEL_16:
    v29 = at_error_success;
    goto LABEL_22;
  }
  v14 = malloc_type_malloc(Size - v31, 0x3AF8B7C8uLL);
  BytesAtOffset = IIOImageReadSession::getBytesAtOffset(a2, v14, *((_QWORD *)this + 14), v32);
  if (v32 == BytesAtOffset)
  {
    v13 = v14;
    if (v14)
    {
LABEL_3:
      v15 = *((_DWORD *)this + 8) | (16 * *((_DWORD *)this + 7));
      v16 = 212;
      if (v15 != 136)
        v16 = 0;
      if (v15 == 68)
        v17 = 204;
      else
        v17 = v16;
      v18 = (ASTCTwiddler *)operator new();
      ASTCTwiddler::ASTCTwiddler(v18, v17, *((unsigned int *)this + 25), *((unsigned int *)this + 26), 1uLL, 0);
      v19 = ASTCTwiddler::twiddledDataSize(v18);
      v20 = malloc_type_malloc(v19, 0xD0627F19uLL);
      if (v20)
      {
        v21 = v20;
        ASTCTwiddler::copyFromTextureData(v18, v14, v20, 0, 16 * ((LODWORD(a3->width) + *((_DWORD *)this + 7) - 1) / *((_DWORD *)this + 7)), 0);
        v22 = at_encoder_create(a6, a4, a5, a4, 0);
        if (v22)
        {
          v23 = v22;
          height = a3->height;
          dest.texels = a3->data;
          rowBytes = a3->rowBytes;
          dest.validSize.x = a3->width;
          dest.validSize.y = height;
          *((_DWORD *)&dest.validSize + 3) = 0;
          dest.rowBytes = rowBytes;
          dest.validSize.z = 1;
          dest.sliceBytes = 0;
          *(_QWORD *)&v38.x = *(_QWORD *)&dest.validSize.x;
          v38.z = 1;
          block_counts = (unint64_t)at_encoder_get_block_counts(v22, v38);
          v27 = HIDWORD(block_counts);
          src.blocks = v21;
          v28 = block_counts;
          src.rowBytes = at_encoder_get_block_size(v23) * block_counts;
          src.sliceBytes = v27 * (unint64_t)v28 * at_encoder_get_block_size(v23);
          v29 = at_encoder_decompress_texels(v23, &src, &dest, at_flags_default);
          if (v29)
            LogError("decodeRGBXFromTwiddled", 1504, "at_encoder_decompress_texels returned: %ld\n", v29);

        }
        else
        {
          v29 = at_error_success;
        }
        free(v21);
      }
      else
      {
        v29 = at_error_success;
      }
      (*(void (**)(ASTCTwiddler *))(*(_QWORD *)v18 + 8))(v18);
      if (v13)
        goto LABEL_21;
      goto LABEL_22;
    }
    goto LABEL_16;
  }
  _cg_jpeg_mem_term("decodeRGBXFromTwiddled", 1446, "got: %ld expected: %ld\n", BytesAtOffset, v32);
  v29 = at_error_success;
  v13 = v14;
  if (v14)
LABEL_21:
    free(v13);
LABEL_22:
  if (v37)
    IIOImageReadSession::releaseBytePointer((IIOImageRead **)a2, v37);
  return v29;
}

void sub_187FDFD54(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0xA1C40BD48D6D6);
  _Unwind_Resume(a1);
}

uint64_t ASTCTextureImp::decodeASTCtoRGBX(ASTCTextureImp *this, IIOImageReadSession *a2, vImage_Buffer *a3, int a4, int a5)
{
  at_alpha_t v10;
  pthread_mutex_t *v11;
  ASTCTextureImp *v12;
  at_block_format_t v13;
  at_block_format_t v14;
  at_texel_format_t v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  vImagePixelCount height;
  char *data;
  size_t rowBytes;
  vImagePixelCount width;
  uint64_t v24;

  if (ASTCTextureImp::decodeASTCtoRGBX(IIOImageReadSession *,vImage_Buffer *,CGImageAlphaInfo,BOOL)::once != -1)
    dispatch_once(&ASTCTextureImp::decodeASTCtoRGBX(IIOImageReadSession *,vImage_Buffer *,CGImageAlphaInfo,BOOL)::once, &__block_literal_global_90);
  if (a4 > 2)
    v10 = at_alpha_not_premultiplied;
  else
    v10 = dword_188211940[a4];
  v11 = (pthread_mutex_t *)((char *)this + 168);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 168));
  v12 = (ASTCTextureImp *)ASTCTextureImp::BlockFormatForASTCBlockSize((ASTCTextureImp *)*((unsigned __int8 *)this + 28), *((_BYTE *)this + 32));
  v14 = (at_block_format_t)v12;
  if (a5)
    v15 = at_texel_format_bgra8_unorm;
  else
    v15 = at_texel_format_rgba8_unorm;
  if (*((_BYTE *)this + 42))
  {
    v14 = ASTCTextureImp::HDRBlockFormat(v12, v13);
    v15 = at_texel_format_rgba16_float;
  }
  if (!*((_BYTE *)this + 41))
  {
    if (*((_BYTE *)this + 40))
    {
      v17 = ASTCTextureImp::decodeRGBXFromLinearLZFSE(this, a2, a3, v10, v14, v15);
      if (v17)
      {
        v16 = v17;
        _cg_jpeg_mem_term("decodeASTCtoRGBX", 1601, "*** ERROR: decodeRGBXFromLinearLZFSE failed [%d]\n");
        goto LABEL_23;
      }
    }
    else
    {
      v19 = ASTCTextureImp::decodeRGBXFromLinear(this, a2, a3, v10, v14, v15);
      if (v19)
      {
        v16 = v19;
        _cg_jpeg_mem_term("decodeASTCtoRGBX", 1594, "*** ERROR: decodeRGBXFromLinear failed [%d]\n", v19);
        goto LABEL_23;
      }
    }
    goto LABEL_32;
  }
  if (!*((_BYTE *)this + 40))
  {
    if (!ASTCTextureImp::decodeASTCtoRGBX(IIOImageReadSession *,vImage_Buffer *,CGImageAlphaInfo,BOOL)::gUntwiddle)
      goto LABEL_14;
    v18 = ASTCTextureImp::decodeRGBXFromTwiddled(this, a2, a3, v10, v14, v15);
    if (v18)
    {
      v16 = v18;
      _cg_jpeg_mem_term("decodeASTCtoRGBX", 1613, "*** ERROR: decodeRGBXFromTwiddled failed [%d]\n");
      goto LABEL_23;
    }
LABEL_32:
    v24 = 0;
    goto LABEL_31;
  }
  LogError("decodeASTCtoRGBX", 1618, "*** pre-twiddled LZFSE compressed ASTC is not supported\n");
LABEL_14:
  v16 = -50;
LABEL_23:
  height = a3->height;
  if (height)
  {
    data = (char *)a3->data;
    width = a3->width;
    rowBytes = a3->rowBytes;
    do
    {
      if (width)
        memset_pattern16(data, &unk_188211950, 4 * width);
      data += rowBytes;
      --height;
    }
    while (height);
  }
  if (ASTCTextureImp::decodeASTCtoRGBX(IIOImageReadSession *,vImage_Buffer *,CGImageAlphaInfo,BOOL)::gUntwiddle)
    v24 = v16;
  else
    v24 = 0;
LABEL_31:
  pthread_mutex_unlock(v11);
  return v24;
}

__n128 ___ZN14ASTCTextureImp16decodeASTCtoRGBXEP19IIOImageReadSessionP13vImage_Buffer16CGImageAlphaInfob_block_invoke()
{
  __n128 result;

  ASTCTextureImp::decodeASTCtoRGBX(IIOImageReadSession *,vImage_Buffer *,CGImageAlphaInfo,BOOL)::gUntwiddle = IOPreferencesGetBoolean("ImageIO_untwiddle_for_CG", 1, 0);
  if ((ASTCTextureImp::decodeASTCtoRGBX(IIOImageReadSession *,vImage_Buffer *,CGImageAlphaInfo,BOOL)::gUntwiddle & 1) == 0)
    return _cg_jpeg_mem_term("decodeASTCtoRGBX_block_invoke", 1563, "*** ATX pre-twiddled data will show up as blue rects\n");
  return result;
}

uint64_t ASTCTextureImp::decodeASTCtoRGBX(ASTCTextureImp *this, void *a2, size_t a3, vImage_Buffer *a4, unsigned int a5, int a6)
{
  uint64_t v11;
  pthread_mutex_t *v12;
  ASTCTextureImp *v13;
  at_block_format_t v14;
  at_texel_format_t v15;
  uint64_t v16;
  vImagePixelCount height;
  char *data;
  size_t rowBytes;
  vImagePixelCount width;

  if (a5 > 2)
    v11 = 0;
  else
    v11 = dword_188211940[a5];
  v12 = (pthread_mutex_t *)((char *)this + 168);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 168));
  v13 = (ASTCTextureImp *)ASTCTextureImp::BlockFormatForASTCBlockSize((ASTCTextureImp *)*((unsigned __int8 *)this + 28), *((_BYTE *)this + 32));
  if (a6)
    v15 = at_texel_format_bgra8_unorm;
  else
    v15 = at_texel_format_rgba8_unorm;
  if (*((_BYTE *)this + 42))
  {
    v13 = (ASTCTextureImp *)ASTCTextureImp::HDRBlockFormat(v13, v14);
    v15 = at_texel_format_rgba16_float;
  }
  v16 = ASTCTextureImp::decodeRGBXFromMemory(v13, a2, a3, a4, v11, (at_block_format_t)v13, v15);
  if ((_DWORD)v16)
  {
    height = a4->height;
    if (height)
    {
      data = (char *)a4->data;
      width = a4->width;
      rowBytes = a4->rowBytes;
      do
      {
        if (width)
          memset_pattern16(data, &unk_188211950, 4 * width);
        data += rowBytes;
        --height;
      }
      while (height);
    }
  }
  pthread_mutex_unlock(v12);
  return v16;
}

void TXMPMeta<std::string>::operator=(uint64_t a1, uint64_t a2)
{
  _DWORD *v2;
  uint64_t v3;

  v2 = *(_DWORD **)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 8) = v3;
  WXMPMeta_IncrementRefCount_1(v3);
  WXMPMeta_DecrementRefCount_1(v2);
}

_QWORD *TXMPMeta<std::string>::TXMPMeta(_QWORD *a1, uint64_t a2)
{
  *a1 = &off_1E1BB2B60;
  a1[1] = a2;
  WXMPMeta_IncrementRefCount_1(a2);
  return a1;
}

_QWORD *TXMPMeta<std::string>::TXMPMeta(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *exception;
  uint64_t v8;
  _OWORD v9[2];
  uint64_t v10;

  *a1 = &off_1E1BB2B60;
  v10 = 0;
  memset(v9, 0, sizeof(v9));
  WXMPMeta_CTor_1(v9);
  if (*(_QWORD *)&v9[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v8 = *(_QWORD *)&v9[0];
    *(_DWORD *)exception = v10;
    exception[1] = v8;
    *((_BYTE *)exception + 16) = 0;
  }
  a1[1] = *((_QWORD *)&v9[0] + 1);
  TXMPMeta<std::string>::ParseFromBuffer((uint64_t)a1, a2, a3, 0);
  return a1;
}

void sub_187FE01E4(void *a1)
{
  uint64_t v1;

  __cxa_begin_catch(a1);
  WXMPMeta_DecrementRefCount_1(*(_DWORD **)(v1 + 8));
  *(_QWORD *)(v1 + 8) = 0;
  __cxa_rethrow();
}

void sub_187FE01FC(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void TXMPMeta<std::string>::~TXMPMeta(uint64_t a1)
{
  TXMPMeta<std::string>::~TXMPMeta(a1);
  JUMPOUT(0x18D761C30);
}

BOOL TXMPMeta<std::string>::RegisterNamespace(XMPMeta *a1, char *a2, uint64_t a3)
{
  _QWORD *exception;
  uint64_t v5;
  _OWORD v6[2];
  uint64_t v7;

  v7 = 0;
  memset(v6, 0, sizeof(v6));
  WXMPMeta_RegisterNamespace_1(a1, a2, a3, (uint64_t (*)(uint64_t, _QWORD, _QWORD))TXMPMeta<std::string>::SetClientString, (unsigned int *)v6);
  if (*(_QWORD *)&v6[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v5 = *(_QWORD *)&v6[0];
    *(_DWORD *)exception = v7;
    exception[1] = v5;
    *((_BYTE *)exception + 16) = 0;
  }
  return (_DWORD)v7 != 0;
}

BOOL TXMPMeta<std::string>::GetProperty(uint64_t a1, _BYTE *a2, _BYTE *a3, uint64_t a4, uint64_t *a5)
{
  _QWORD *exception;
  uint64_t v7;
  _OWORD v8[2];
  uint64_t v9;

  v9 = 0;
  memset(v8, 0, sizeof(v8));
  WXMPMeta_GetProperty_1(*(_QWORD *)(a1 + 8), a2, a3, a4, a5, (void (*)(uint64_t, uint64_t, _QWORD))TXMPMeta<std::string>::SetClientString, (uint64_t)v8);
  if (*(_QWORD *)&v8[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v7 = *(_QWORD *)&v8[0];
    *(_DWORD *)exception = v9;
    exception[1] = v7;
    *((_BYTE *)exception + 16) = 0;
  }
  return (_DWORD)v9 != 0;
}

BOOL TXMPMeta<std::string>::GetArrayItem(uint64_t a1, _BYTE *a2, _BYTE *a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  _QWORD *exception;
  uint64_t v8;
  _OWORD v9[2];
  uint64_t v10;

  v10 = 0;
  memset(v9, 0, sizeof(v9));
  WXMPMeta_GetArrayItem_1(*(_QWORD *)(a1 + 8), a2, a3, a4, a5, a6, (void (*)(uint64_t, uint64_t, _QWORD))TXMPMeta<std::string>::SetClientString, (uint64_t)v9);
  if (*(_QWORD *)&v9[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v8 = *(_QWORD *)&v9[0];
    *(_DWORD *)exception = v10;
    exception[1] = v8;
    *((_BYTE *)exception + 16) = 0;
  }
  return (_DWORD)v10 != 0;
}

void TXMPMeta<std::string>::SetProperty(uint64_t a1, _BYTE *a2, _BYTE *a3, uint64_t a4, uint64_t a5)
{
  _QWORD *exception;
  uint64_t v6;
  _OWORD v7[2];
  uint64_t v8;

  v8 = 0;
  memset(v7, 0, sizeof(v7));
  WXMPMeta_SetProperty_1(*(_QWORD *)(a1 + 8), a2, a3, a4, a5, v7);
  if (*(_QWORD *)&v7[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v6 = *(_QWORD *)&v7[0];
    *(_DWORD *)exception = v8;
    exception[1] = v6;
    *((_BYTE *)exception + 16) = 0;
  }
}

void TXMPMeta<std::string>::AppendArrayItem(uint64_t a1, _BYTE *a2, _BYTE *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  _QWORD *exception;
  uint64_t v7;
  _OWORD v8[2];
  uint64_t v9;

  v9 = 0;
  memset(v8, 0, sizeof(v8));
  WXMPMeta_AppendArrayItem_1(*(_QWORD *)(a1 + 8), a2, a3, a4, a5, a6, v8);
  if (*(_QWORD *)&v8[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v7 = *(_QWORD *)&v8[0];
    *(_DWORD *)exception = v9;
    exception[1] = v7;
    *((_BYTE *)exception + 16) = 0;
  }
}

void TXMPMeta<std::string>::SetStructField(uint64_t a1, char *a2, char *a3, char *a4, char *a5, const char *a6, uint64_t a7)
{
  _QWORD *exception;
  uint64_t v8;
  _OWORD v9[2];
  uint64_t v10;

  v10 = 0;
  memset(v9, 0, sizeof(v9));
  WXMPMeta_SetStructField_1(*(_QWORD *)(a1 + 8), a2, a3, a4, a5, a6, a7, v9);
  if (*(_QWORD *)&v9[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v8 = *(_QWORD *)&v9[0];
    *(_DWORD *)exception = v10;
    exception[1] = v8;
    *((_BYTE *)exception + 16) = 0;
  }
}

void TXMPMeta<std::string>::SetQualifier(uint64_t a1, _BYTE *a2, _BYTE *a3, _BYTE *a4, _BYTE *a5, uint64_t a6, uint64_t a7)
{
  _QWORD *exception;
  uint64_t v8;
  _OWORD v9[2];
  uint64_t v10;

  v10 = 0;
  memset(v9, 0, sizeof(v9));
  WXMPMeta_SetQualifier_1(*(_QWORD *)(a1 + 8), a2, a3, a4, a5, a6, a7, v9);
  if (*(_QWORD *)&v9[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v8 = *(_QWORD *)&v9[0];
    *(_DWORD *)exception = v10;
    exception[1] = v8;
    *((_BYTE *)exception + 16) = 0;
  }
}

void TXMPMeta<std::string>::DeleteProperty(uint64_t a1, _BYTE *a2, _BYTE *a3)
{
  _QWORD *exception;
  uint64_t v4;
  _OWORD v5[2];
  uint64_t v6;

  v6 = 0;
  memset(v5, 0, sizeof(v5));
  WXMPMeta_DeleteProperty_1(*(_QWORD *)(a1 + 8), a2, a3, v5);
  if (*(_QWORD *)&v5[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v4 = *(_QWORD *)&v5[0];
    *(_DWORD *)exception = v6;
    exception[1] = v4;
    *((_BYTE *)exception + 16) = 0;
  }
}

BOOL TXMPMeta<std::string>::DoesPropertyExist(uint64_t a1, _BYTE *a2, _BYTE *a3)
{
  _QWORD *exception;
  uint64_t v5;
  _OWORD v6[2];
  uint64_t v7;

  v7 = 0;
  memset(v6, 0, sizeof(v6));
  WXMPMeta_DoesPropertyExist_1(*(_QWORD *)(a1 + 8), a2, a3, (uint64_t)v6);
  if (*(_QWORD *)&v6[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v5 = *(_QWORD *)&v6[0];
    *(_DWORD *)exception = v7;
    exception[1] = v5;
    *((_BYTE *)exception + 16) = 0;
  }
  return (_DWORD)v7 != 0;
}

BOOL TXMPMeta<std::string>::GetProperty_Bool(uint64_t a1, const char *a2, const char *a3, _BYTE *a4, unsigned int *a5)
{
  int v6;
  _QWORD *exception;
  uint64_t v9;
  _OWORD v10[2];
  uint64_t v11;
  BOOL v12;

  v12 = 0;
  v11 = 0;
  memset(v10, 0, sizeof(v10));
  WXMPMeta_GetProperty_Bool_1(*(_QWORD *)(a1 + 8), a2, a3, &v12, a5, (uint64_t)v10);
  if (*(_QWORD *)&v10[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v9 = *(_QWORD *)&v10[0];
    *(_DWORD *)exception = v11;
    exception[1] = v9;
    *((_BYTE *)exception + 16) = 0;
  }
  v6 = v11;
  if (a4 && (_DWORD)v11)
    *a4 = v12;
  return v6 != 0;
}

BOOL TXMPMeta<std::string>::GetProperty_Int(uint64_t a1, const char *a2, const char *a3, int *a4, unsigned int *a5)
{
  _QWORD *exception;
  uint64_t v7;
  _OWORD v8[2];
  uint64_t v9;

  v9 = 0;
  memset(v8, 0, sizeof(v8));
  WXMPMeta_GetProperty_Int_1(*(_QWORD *)(a1 + 8), a2, a3, a4, a5, (uint64_t)v8);
  if (*(_QWORD *)&v8[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v7 = *(_QWORD *)&v8[0];
    *(_DWORD *)exception = v9;
    exception[1] = v7;
    *((_BYTE *)exception + 16) = 0;
  }
  return (_DWORD)v9 != 0;
}

BOOL TXMPMeta<std::string>::GetProperty_Date(uint64_t a1, _BYTE *a2, _BYTE *a3, __int128 *a4, int *a5)
{
  _QWORD *exception;
  uint64_t v7;
  _OWORD v8[2];
  uint64_t v9;

  v9 = 0;
  memset(v8, 0, sizeof(v8));
  WXMPMeta_GetProperty_Date_1(*(_QWORD *)(a1 + 8), a2, a3, a4, a5, (uint64_t)v8);
  if (*(_QWORD *)&v8[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v7 = *(_QWORD *)&v8[0];
    *(_DWORD *)exception = v9;
    exception[1] = v7;
    *((_BYTE *)exception + 16) = 0;
  }
  return (_DWORD)v9 != 0;
}

void TXMPMeta<std::string>::SetProperty_Bool(uint64_t a1, const char *a2, const char *a3, int a4, uint64_t a5)
{
  _QWORD v5[4];
  uint64_t v6;

  v6 = 0;
  memset(v5, 0, sizeof(v5));
  WXMPMeta_SetProperty_Bool_1(*(_QWORD *)(a1 + 8), a2, a3, a4, a5, v5);
}

void sub_187FE07A0()
{
  _QWORD *exception;
  uint64_t v1;
  int v2;

  if (v1)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = v2;
    exception[1] = v1;
    *((_BYTE *)exception + 16) = 0;
  }
}

void TXMPMeta<std::string>::SetProperty_Int(uint64_t a1, const char *a2, const char *a3, uint64_t a4, uint64_t a5)
{
  _QWORD *exception;
  uint64_t v6;
  _OWORD v7[2];
  uint64_t v8;

  v8 = 0;
  memset(v7, 0, sizeof(v7));
  WXMPMeta_SetProperty_Int_1(*(_QWORD *)(a1 + 8), a2, a3, a4, a5, v7);
  if (*(_QWORD *)&v7[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v6 = *(_QWORD *)&v7[0];
    *(_DWORD *)exception = v8;
    exception[1] = v6;
    *((_BYTE *)exception + 16) = 0;
  }
}

void TXMPMeta<std::string>::SetProperty_Int64(uint64_t a1, const char *a2, const char *a3, uint64_t a4, uint64_t a5)
{
  _QWORD *exception;
  uint64_t v6;
  _OWORD v7[2];
  uint64_t v8;

  v8 = 0;
  memset(v7, 0, sizeof(v7));
  WXMPMeta_SetProperty_Int64_1(*(_QWORD *)(a1 + 8), a2, a3, a4, a5, v7);
  if (*(_QWORD *)&v7[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v6 = *(_QWORD *)&v7[0];
    *(_DWORD *)exception = v8;
    exception[1] = v6;
    *((_BYTE *)exception + 16) = 0;
  }
}

void TXMPMeta<std::string>::SetProperty_Float(uint64_t a1, const char *a2, const char *a3, uint64_t a4, double a5)
{
  _QWORD *exception;
  uint64_t v6;
  _OWORD v7[2];
  uint64_t v8;

  v8 = 0;
  memset(v7, 0, sizeof(v7));
  WXMPMeta_SetProperty_Float_1(*(_QWORD *)(a1 + 8), a2, a3, a4, v7, a5);
  if (*(_QWORD *)&v7[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v6 = *(_QWORD *)&v7[0];
    *(_DWORD *)exception = v8;
    exception[1] = v6;
    *((_BYTE *)exception + 16) = 0;
  }
}

void TXMPMeta<std::string>::SetProperty_Date(uint64_t a1, _BYTE *a2, _BYTE *a3, __int128 *a4, uint64_t a5)
{
  _QWORD *exception;
  uint64_t v6;
  _OWORD v7[2];
  uint64_t v8;

  v8 = 0;
  memset(v7, 0, sizeof(v7));
  WXMPMeta_SetProperty_Date_1(*(_QWORD *)(a1 + 8), a2, a3, a4, a5, v7);
  if (*(_QWORD *)&v7[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v6 = *(_QWORD *)&v7[0];
    *(_DWORD *)exception = v8;
    exception[1] = v6;
    *((_BYTE *)exception + 16) = 0;
  }
}

BOOL TXMPMeta<std::string>::GetLocalizedText(uint64_t a1, _BYTE *a2, _BYTE *a3, const char *a4, _BYTE *a5, uint64_t a6, uint64_t a7, uint64_t *a8)
{
  _QWORD *exception;
  uint64_t v10;
  _OWORD v11[2];
  uint64_t v12;

  v12 = 0;
  memset(v11, 0, sizeof(v11));
  WXMPMeta_GetLocalizedText_1(*(_QWORD *)(a1 + 8), a2, a3, a4, a5, a6, a7, a8, (void (*)(uint64_t, uint64_t, _QWORD))TXMPMeta<std::string>::SetClientString, (uint64_t)v11);
  if (*(_QWORD *)&v11[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v10 = *(_QWORD *)&v11[0];
    *(_DWORD *)exception = v12;
    exception[1] = v10;
    *((_BYTE *)exception + 16) = 0;
  }
  return (_DWORD)v12 != 0;
}

void TXMPMeta<std::string>::SetLocalizedText(uint64_t a1, _BYTE *a2, _BYTE *a3, const char *a4, _BYTE *a5, const char *a6, uint64_t a7)
{
  _QWORD *exception;
  uint64_t v8;
  _OWORD v9[2];
  uint64_t v10;

  v10 = 0;
  memset(v9, 0, sizeof(v9));
  WXMPMeta_SetLocalizedText_1(*(_QWORD *)(a1 + 8), a2, a3, a4, a5, a6, a7, v9);
  if (*(_QWORD *)&v9[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v8 = *(_QWORD *)&v9[0];
    *(_DWORD *)exception = v10;
    exception[1] = v8;
    *((_BYTE *)exception + 16) = 0;
  }
}

void TXMPMeta<std::string>::SerializeToBuffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5, const char *a6, uint64_t a7)
{
  _QWORD *exception;
  uint64_t v8;
  _OWORD v9[2];
  uint64_t v10;

  v10 = 0;
  memset(v9, 0, sizeof(v9));
  WXMPMeta_SerializeToBuffer_1(*(_QWORD *)(a1 + 8), a2, a3, a4, a5, a6, a7, (void (*)(uint64_t, void *, uint64_t))TXMPMeta<std::string>::SetClientString, v9);
  if (*(_QWORD *)&v9[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v8 = *(_QWORD *)&v9[0];
    *(_DWORD *)exception = v10;
    exception[1] = v8;
    *((_BYTE *)exception + 16) = 0;
  }
}

void TXMPMeta<std::string>::SerializeToBuffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  TXMPMeta<std::string>::SerializeToBuffer(a1, a2, a3, a4, "", "", 0);
}

void TXMPMeta<std::string>::Clone(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v4;
  _QWORD *exception;
  uint64_t v6;
  _OWORD v7[2];
  uint64_t v8;

  v8 = 0;
  memset(v7, 0, sizeof(v7));
  WXMPMeta_Clone_1(*(_QWORD *)(a1 + 8), a2, v7);
  if (*(_QWORD *)&v7[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v6 = *(_QWORD *)&v7[0];
    *(_DWORD *)exception = v8;
    exception[1] = v6;
    *((_BYTE *)exception + 16) = 0;
  }
  v4 = *((_QWORD *)&v7[0] + 1);
  *a3 = &off_1E1BB2B60;
  a3[1] = v4;
  WXMPMeta_IncrementRefCount_1(v4);
}

uint64_t TXMPMeta<std::string>::CountArrayItems(uint64_t a1, _BYTE *a2, _BYTE *a3)
{
  _QWORD *exception;
  uint64_t v5;
  _OWORD v6[2];
  uint64_t v7;

  v7 = 0;
  memset(v6, 0, sizeof(v6));
  WXMPMeta_CountArrayItems_1(*(_QWORD *)(a1 + 8), a2, a3, (uint64_t)v6);
  if (*(_QWORD *)&v6[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v5 = *(_QWORD *)&v6[0];
    *(_DWORD *)exception = v7;
    exception[1] = v5;
    *((_BYTE *)exception + 16) = 0;
  }
  return v7;
}

uint64_t WrapErrorNotify(uint64_t (*a1)(void *, uint64_t, uint64_t, const char *), void *a2, uint64_t a3, uint64_t a4, const char *a5)
{
  return a1(a2, a3, a4, a5);
}

void sub_187FE0BE8(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187FE0BE0);
}

void TXMPIterator<std::string>::~TXMPIterator(uint64_t a1)
{
  TXMPIterator<std::string>::~TXMPIterator(a1);
  JUMPOUT(0x18D761C30);
}

void TXMPUtils<std::string>::ComposeArrayItemPath(char *a1, char *a2, int a3, uint64_t a4)
{
  _QWORD *exception;
  uint64_t v5;
  _OWORD v6[2];
  uint64_t v7;

  v7 = 0;
  memset(v6, 0, sizeof(v6));
  WXMPUtils_ComposeArrayItemPath_1(a1, a2, a3, a4, (void (*)(uint64_t, std::string *, uint64_t))TXMPUtils<std::string>::SetClientString, v6);
  if (*(_QWORD *)&v6[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v5 = *(_QWORD *)&v6[0];
    *(_DWORD *)exception = v7;
    exception[1] = v5;
    *((_BYTE *)exception + 16) = 0;
  }
}

void TXMPUtils<std::string>::SetClientString()
{
  JUMPOUT(0x18D761A20);
}

void TXMPUtils<std::string>::ComposeStructFieldPath(char *a1, char *a2, char *a3, _BYTE *a4, uint64_t a5)
{
  _QWORD *exception;
  uint64_t v6;
  _OWORD v7[2];
  uint64_t v8;

  v8 = 0;
  memset(v7, 0, sizeof(v7));
  WXMPUtils_ComposeStructFieldPath_1(a1, a2, a3, a4, a5, (void (*)(uint64_t, std::string *, uint64_t))TXMPUtils<std::string>::SetClientString, v7);
  if (*(_QWORD *)&v7[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v6 = *(_QWORD *)&v7[0];
    *(_DWORD *)exception = v8;
    exception[1] = v6;
    *((_BYTE *)exception + 16) = 0;
  }
}

void TXMPUtils<std::string>::ConvertFromFloat(const char *a1, uint64_t a2, double a3)
{
  _QWORD *exception;
  uint64_t v4;
  _OWORD v5[2];
  uint64_t v6;

  v6 = 0;
  memset(v5, 0, sizeof(v5));
  WXMPUtils_ConvertFromFloat_1(a1, a2, (void (*)(uint64_t, std::string *, uint64_t))TXMPUtils<std::string>::SetClientString, v5, a3);
  if (*(_QWORD *)&v5[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v4 = *(_QWORD *)&v5[0];
    *(_DWORD *)exception = v6;
    exception[1] = v4;
    *((_BYTE *)exception + 16) = 0;
  }
}

BOOL TXMPUtils<std::string>::ConvertToBool(XMPUtils *a1)
{
  _QWORD *exception;
  uint64_t v3;
  _OWORD v4[2];
  uint64_t v5;

  v5 = 0;
  memset(v4, 0, sizeof(v4));
  WXMPUtils_ConvertToBool_1(a1, (uint64_t)v4);
  if (*(_QWORD *)&v4[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v3 = *(_QWORD *)&v4[0];
    *(_DWORD *)exception = v5;
    exception[1] = v3;
    *((_BYTE *)exception + 16) = 0;
  }
  return (_DWORD)v5 != 0;
}

BOOL TXMPUtils<std::string>::ConvertToBool(char *a1)
{
  if (a1[23] < 0)
    a1 = *(char **)a1;
  return TXMPUtils<std::string>::ConvertToBool((XMPUtils *)a1);
}

uint64_t TXMPUtils<std::string>::ConvertToDate(char *a1, uint64_t a2)
{
  uint64_t result;
  _QWORD *exception;
  uint64_t v4;
  _OWORD v5[2];
  uint64_t v6;

  v6 = 0;
  memset(v5, 0, sizeof(v5));
  result = WXMPUtils_ConvertToDate_1(a1, a2, v5);
  if (*(_QWORD *)&v5[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v4 = *(_QWORD *)&v5[0];
    *(_DWORD *)exception = v6;
    exception[1] = v4;
    *((_BYTE *)exception + 16) = 0;
  }
  return result;
}

uint64_t TXMPUtils<std::string>::ConvertToUTCTime(uint64_t a1)
{
  uint64_t result;
  _QWORD *exception;
  uint64_t v3;
  _OWORD v4[2];
  uint64_t v5;

  v5 = 0;
  memset(v4, 0, sizeof(v4));
  result = WXMPUtils_ConvertToUTCTime_1(a1, v4);
  if (*(_QWORD *)&v4[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v3 = *(_QWORD *)&v4[0];
    *(_DWORD *)exception = v5;
    exception[1] = v3;
    *((_BYTE *)exception + 16) = 0;
  }
  return result;
}

void TXMPUtils<std::string>::PackageForJPEG(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *exception;
  uint64_t v5;
  _OWORD v6[2];
  uint64_t v7;

  v7 = 0;
  memset(v6, 0, sizeof(v6));
  WXMPUtils_PackageForJPEG_1(*(const std::string **)(a1 + 8), a2, a3, a4, (void (*)(uint64_t, void *, uint64_t))TXMPUtils<std::string>::SetClientString, v6);
  if (*(_QWORD *)&v6[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v5 = *(_QWORD *)&v6[0];
    *(_DWORD *)exception = v7;
    exception[1] = v5;
    *((_BYTE *)exception + 16) = 0;
  }
}

void TXMPUtils<std::string>::MergeFromJPEG(uint64_t a1, uint64_t a2)
{
  _QWORD *exception;
  uint64_t v3;
  _OWORD v4[2];
  uint64_t v5;

  v5 = 0;
  memset(v4, 0, sizeof(v4));
  WXMPUtils_MergeFromJPEG_1(*(_QWORD *)(a1 + 8), *(_QWORD *)(a2 + 8), v4);
  if (*(_QWORD *)&v4[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v3 = *(_QWORD *)&v4[0];
    *(_DWORD *)exception = v5;
    exception[1] = v3;
    *((_BYTE *)exception + 16) = 0;
  }
}

void TXMPUtils<std::string>::CatenateArrayItems(uint64_t a1, char *a2, _BYTE *a3, char *a4, const char *a5, unsigned int a6, uint64_t a7)
{
  _QWORD *exception;
  uint64_t v8;
  _OWORD v9[2];
  uint64_t v10;

  v10 = 0;
  memset(v9, 0, sizeof(v9));
  WXMPUtils_CatenateArrayItems_1(*(char ***)(a1 + 8), a2, a3, a4, a5, a6, a7, (void (*)(uint64_t, std::string *, uint64_t))TXMPUtils<std::string>::SetClientString, v9);
  if (*(_QWORD *)&v9[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v8 = *(_QWORD *)&v9[0];
    *(_DWORD *)exception = v10;
    exception[1] = v8;
    *((_BYTE *)exception + 16) = 0;
  }
}

void TXMPUtils<std::string>::SeparateArrayItems(uint64_t a1, XMPMeta *a2, char *a3, const char *a4, char *a5)
{
  _QWORD *exception;
  uint64_t v6;
  _OWORD v7[2];
  uint64_t v8;

  if (!a1)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 4;
    exception[1] = "Null output SXMPMeta pointer";
    goto LABEL_6;
  }
  v8 = 0;
  memset(v7, 0, sizeof(v7));
  WXMPUtils_SeparateArrayItems_1(*(char ***)(a1 + 8), a2, a3, a4, a5, v7);
  if (*(_QWORD *)&v7[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v6 = *(_QWORD *)&v7[0];
    *(_DWORD *)exception = v8;
    exception[1] = v6;
LABEL_6:
    *((_BYTE *)exception + 16) = 0;
  }
}

{
  if (a5[23] < 0)
    a5 = *(char **)a5;
  TXMPUtils<std::string>::SeparateArrayItems(a1, a2, a3, a4, a5);
}

void TXMPUtils<std::string>::RemoveProperties(uint64_t a1, XMPMeta *a2, char *a3, const char *a4)
{
  _QWORD *exception;
  uint64_t v5;
  _OWORD v6[2];
  uint64_t v7;

  if (!a1)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 4;
    exception[1] = "Null output SXMPMeta pointer";
    goto LABEL_6;
  }
  v7 = 0;
  memset(v6, 0, sizeof(v6));
  WXMPUtils_RemoveProperties_1(*(char ***)(a1 + 8), a2, a3, a4, v6);
  if (*(_QWORD *)&v6[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v5 = *(_QWORD *)&v6[0];
    *(_DWORD *)exception = v7;
    exception[1] = v5;
LABEL_6:
    *((_BYTE *)exception + 16) = 0;
  }
}

void TXMPUtils<std::string>::DuplicateSubtree(uint64_t a1, uint64_t a2, XMPMeta *a3, char *a4, char *a5, char *a6, const char *a7)
{
  _QWORD *exception;
  uint64_t v8;
  _OWORD v9[2];
  uint64_t v10;

  if (!a2)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 4;
    exception[1] = "Null output SXMPMeta pointer";
    goto LABEL_6;
  }
  v10 = 0;
  memset(v9, 0, sizeof(v9));
  WXMPUtils_DuplicateSubtree_1(*(char ***)(a1 + 8), *(char ***)(a2 + 8), a3, a4, a5, a6, a7, v9);
  if (*(_QWORD *)&v9[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v8 = *(_QWORD *)&v9[0];
    *(_DWORD *)exception = v10;
    exception[1] = v8;
LABEL_6:
    *((_BYTE *)exception + 16) = 0;
  }
}

BOOL TXMPFiles<std::string>::Initialize(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  _QWORD *exception;
  uint64_t v6;
  _OWORD v7[2];
  uint64_t v8;

  v8 = 0;
  memset(v7, 0, sizeof(v7));
  WXMPFiles_Initialize_1(0, (uint64_t)v7, a3, a4);
  if (*(_QWORD *)&v7[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v6 = *(_QWORD *)&v7[0];
    *(_DWORD *)exception = v8;
    exception[1] = v6;
    *((_BYTE *)exception + 16) = 0;
  }
  return (_DWORD)v8 != 0;
}

uint64_t TXMPFiles<std::string>::~TXMPFiles(uint64_t a1)
{
  *(_QWORD *)a1 = &off_1E1BB2FD0;
  WXMPFiles_DecrementRefCount_1(*(_DWORD **)(a1 + 8));
  *(_QWORD *)(a1 + 8) = 0;
  return a1;
}

void TXMPFiles<std::string>::~TXMPFiles(uint64_t a1)
{
  TXMPFiles<std::string>::~TXMPFiles(a1);
  JUMPOUT(0x18D761C30);
}

BOOL TXMPFiles<std::string>::OpenFile(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  _QWORD *exception;
  uint64_t v6;
  _OWORD v7[2];
  uint64_t v8;

  v8 = 0;
  memset(v7, 0, sizeof(v7));
  WXMPFiles_OpenFile_2(*(_QWORD *)(a1 + 8), a2, a3, a4, (uint64_t)v7);
  if (*(_QWORD *)&v7[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v6 = *(_QWORD *)&v7[0];
    *(_DWORD *)exception = v8;
    exception[1] = v6;
    *((_BYTE *)exception + 16) = 0;
  }
  return (_DWORD)v8 != 0;
}

void TXMPFiles<std::string>::CloseFile(uint64_t a1, char a2)
{
  _QWORD *exception;
  uint64_t v3;
  _OWORD v4[2];
  uint64_t v5;

  v5 = 0;
  memset(v4, 0, sizeof(v4));
  WXMPFiles_CloseFile_1(*(_QWORD *)(a1 + 8), a2, v4);
  if (*(_QWORD *)&v4[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v3 = *(_QWORD *)&v4[0];
    *(_DWORD *)exception = v5;
    exception[1] = v3;
    *((_BYTE *)exception + 16) = 0;
  }
}

void TXMPFiles<std::string>::PutXMP(uint64_t a1, uint64_t a2)
{
  _QWORD *exception;
  uint64_t v3;
  _OWORD v4[2];
  uint64_t v5;

  v5 = 0;
  memset(v4, 0, sizeof(v4));
  WXMPFiles_PutXMP_1(*(_QWORD *)(a1 + 8), *(_QWORD *)(a2 + 8), 0, 0, v4);
  if (*(_QWORD *)&v4[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v3 = *(_QWORD *)&v4[0];
    *(_DWORD *)exception = v5;
    exception[1] = v3;
    *((_BYTE *)exception + 16) = 0;
  }
}

void TXMPFiles<std::string>::PutXMP(uint64_t a1, const char *a2, uint64_t a3)
{
  _QWORD *exception;
  uint64_t v4;
  _OWORD v5[2];
  uint64_t v6;

  v6 = 0;
  memset(v5, 0, sizeof(v5));
  WXMPFiles_PutXMP_1(*(_QWORD *)(a1 + 8), 0, a2, a3, v5);
  if (*(_QWORD *)&v5[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v4 = *(_QWORD *)&v5[0];
    *(_DWORD *)exception = v6;
    exception[1] = v4;
    *((_BYTE *)exception + 16) = 0;
  }
}

BOOL TXMPFiles<std::string>::CanPutXMP(uint64_t a1, uint64_t a2)
{
  _QWORD *exception;
  uint64_t v4;
  _OWORD v5[2];
  uint64_t v6;

  v6 = 0;
  memset(v5, 0, sizeof(v5));
  WXMPFiles_CanPutXMP_1(*(_QWORD *)(a1 + 8), *(_QWORD *)(a2 + 8), 0, 0, (uint64_t)v5);
  if (*(_QWORD *)&v5[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v4 = *(_QWORD *)&v5[0];
    *(_DWORD *)exception = v6;
    exception[1] = v4;
    *((_BYTE *)exception + 16) = 0;
  }
  return (_DWORD)v6 != 0;
}

BOOL TXMPFiles<std::string>::CanPutXMP(uint64_t a1, const char *a2, uint64_t a3)
{
  _QWORD *exception;
  uint64_t v5;
  _OWORD v6[2];
  uint64_t v7;

  v7 = 0;
  memset(v6, 0, sizeof(v6));
  WXMPFiles_CanPutXMP_1(*(_QWORD *)(a1 + 8), 0, a2, a3, (uint64_t)v6);
  if (*(_QWORD *)&v6[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v5 = *(_QWORD *)&v6[0];
    *(_DWORD *)exception = v7;
    exception[1] = v5;
    *((_BYTE *)exception + 16) = 0;
  }
  return (_DWORD)v7 != 0;
}

uint64_t IIO_InitializeXMPToolkit()
{
  _BOOL8 v0;
  _BOOL4 v1;
  uint64_t v2;
  uint64_t v3;
  const char *v4;
  _BOOL4 v5;

  pthread_mutex_lock(&xmpLock);
  v0 = TXMPMeta<std::string>::Initialize();
  v1 = v0;
  v5 = TXMPFiles<std::string>::Initialize(v0, v2, v3, v4);
  pthread_mutex_unlock(&xmpLock);
  return v1 & v5;
}

uint64_t IIO_TerminateXMPToolkit()
{
  XMPFiles *v0;
  XMPMeta *v1;

  v0 = (XMPFiles *)pthread_mutex_lock(&xmpLock);
  WXMPFiles_Terminate_1(v0);
  WXMPMeta_Terminate_1(v1);
  return pthread_mutex_unlock(&xmpLock);
}

CGImageMetadata *CreateMetadataFromXMPSidecarData(const char *a1, uint64_t a2)
{
  return CreateMetadataFromXMPBufferInternal(a1, a2, 0, 0, 16);
}

CGImageMetadata *CreateMetadataFromExtendedXMPData(const char *a1, uint64_t a2, const char *a3, uint64_t a4)
{
  CGImageMetadata *MetadataFromXMPBufferInternal;

  kdebug_trace();
  MetadataFromXMPBufferInternal = CreateMetadataFromXMPBufferInternal(a1, a2, a3, a4, 8);
  kdebug_trace();
  return MetadataFromXMPBufferInternal;
}

_QWORD *CreateSXMPMetaFromMetadata(CFDictionaryRef *a1)
{
  CFTypeID v2;
  _QWORD *v3;
  const void **v4;
  const void **v5;
  uint64_t i;
  const void **v7;
  CGImageMetadataTag *v8;
  CFTypeID v9;
  uint64_t Source;
  uint64_t v11;
  const __CFString *v12;
  CFTypeID v13;
  char *UTF8String;
  const __CFString *v15;
  CFTypeID v16;
  char *v17;
  __CFString *v18;
  CFTypeID v19;
  char *v20;
  void **v21;
  CFStringRef SimpleStringFromCFValue;
  int DefaultMetadataValueTypeForProperty;
  const void *v24;
  CFTypeID v25;
  const __CFArray *v26;
  int v27;
  uint64_t v28;
  CFTypeID v29;
  CFTypeID v30;
  void **v31;
  void **v32;
  void *v33;
  CFIndex v34;
  CFIndex j;
  const void *ValueAtIndex;
  uint64_t v37;
  const void **v38;
  CFTypeID v39;
  void *v40;
  _BYTE *v41;
  _BYTE *v42;
  void *v44;
  const void **v45;
  uint64_t v46;
  CFIndex Count;
  _BYTE v48[24];
  void *__p[2];
  uint64_t v50;

  if (!a1)
    return 0;
  v2 = CFGetTypeID(a1);
  if (v2 != CGImageMetadataGetTypeID())
    return 0;
  v3 = (_QWORD *)operator new();
  TXMPMeta<std::string>::TXMPMeta(v3);
  Count = CFDictionaryGetCount(a1[3]);
  v4 = (const void **)malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
  if (v4)
  {
    v5 = (const void **)malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
    if (v5)
    {
      CFDictionaryGetKeysAndValues(a1[3], v4, v5);
      if (Count)
      {
        v45 = v4;
        v46 = (uint64_t)v3;
        for (i = 0; i != Count; ++i)
        {
          __p[0] = 0;
          __p[1] = 0;
          v50 = 0;
          v7 = v5;
          v8 = (CGImageMetadataTag *)v5[i];
          if (v8)
          {
            v9 = CFGetTypeID(v5[i]);
            if (v9 == CGImageMetadataTagGetTypeID())
            {
              Source = CGImageSourceGetSource((uint64_t)v8);
              v11 = Source;
              v12 = *(const __CFString **)(Source + 16);
              if (v12)
              {
                v13 = CFGetTypeID(*(CFTypeRef *)(Source + 16));
                if (v13 == CFStringGetTypeID())
                {
                  if (CFStringCompare(v12, CFSTR("http://ns.apple.com/ImageIO/1.0/"), 0))
                  {
                    IIOString::IIOString((IIOString *)v48, v12);
                    UTF8String = (char *)IIOString::createUTF8String((IIOString *)v48);
                    IIOString::~IIOString((IIOString *)v48);
                    if (UTF8String)
                    {
                      v15 = *(const __CFString **)(v11 + 32);
                      if (v15)
                      {
                        v16 = CFGetTypeID(*(CFTypeRef *)(v11 + 32));
                        if (v16 == CFStringGetTypeID() && !CFStringHasPrefix(v15, CFSTR("IIM2-")))
                        {
                          IIOString::IIOString((IIOString *)v48, v15);
                          v17 = (char *)IIOString::createUTF8String((IIOString *)v48);
                          IIOString::~IIOString((IIOString *)v48);
                          if (v17)
                          {
                            v18 = *(__CFString **)(v11 + 24);
                            if ((v18 || (v18 = CGImageMetadataDefaultPrefixForNamespace(v12)) != 0)
                              && (v19 = CFGetTypeID(v18), v19 == CFStringGetTypeID()))
                            {
                              IIOString::IIOString((IIOString *)v48, v18);
                              v20 = (char *)IIOString::createUTF8String((IIOString *)v48);
                              IIOString::~IIOString((IIOString *)v48);
                              if (v20)
                              {
                                if (!TXMPMeta<std::string>::GetNamespacePrefix((XMPMeta *)UTF8String, (uint64_t)__p)
                                  && !TXMPMeta<std::string>::RegisterNamespace((XMPMeta *)UTF8String, v20, (uint64_t)__p))
                                {
                                  v21 = __p;
                                  if (v50 < 0)
                                    v21 = (void **)__p[0];
                                  LogMetadata("CreateSXMPMetaFromMetadata", 1257, "A collision occurred while registering the suggested prefix '%s' for namespace '%s', new prefix is '%s'.\n", v20, UTF8String, (const char *)v21);
                                }
                                free(v20);
                                SimpleStringFromCFValue = *(CFStringRef *)(v11 + 48);
                                if (SimpleStringFromCFValue)
                                {
                                  DefaultMetadataValueTypeForProperty = getDefaultMetadataValueTypeForProperty(v8);
                                  v24 = *(const void **)(v11 + 56);
                                  if (v24)
                                  {
                                    v25 = CFGetTypeID(v24);
                                    if (v25 == CFArrayGetTypeID())
                                      v26 = (const __CFArray *)v24;
                                    else
                                      v26 = 0;
                                  }
                                  else
                                  {
                                    v26 = 0;
                                  }
                                  v27 = DefaultMetadataValueTypeForProperty - 1;
                                  v28 = 512;
                                  switch(v27)
                                  {
                                    case 0:
                                      v29 = CFGetTypeID(SimpleStringFromCFValue);
                                      if (v29 == CFBooleanGetTypeID()
                                        || (v30 = CFGetTypeID(SimpleStringFromCFValue), v30 == CFNumberGetTypeID()))
                                      {
                                        SimpleStringFromCFValue = CGImageMetadataCreateSimpleStringFromCFValue(SimpleStringFromCFValue, 2);
                                        if (!SimpleStringFromCFValue)
                                        {
                                          v44 = 0;
                                          goto LABEL_60;
                                        }
                                      }
                                      else
                                      {
                                        CFRetain(SimpleStringFromCFValue);
                                      }
                                      IIOString::IIOString((IIOString *)v48, SimpleStringFromCFValue);
                                      v33 = IIOString::createUTF8String((IIOString *)v48);
                                      IIOString::~IIOString((IIOString *)v48);
                                      v44 = v33;
                                      if (v33)
                                        TXMPMeta<std::string>::SetProperty(v46, UTF8String, v17, (uint64_t)v33, 0);
                                      CFRelease(SimpleStringFromCFValue);
LABEL_60:
                                      if (v26)
                                      {
                                        v34 = CFArrayGetCount(v26);
                                        if (v34 >= 1)
                                        {
                                          for (j = 0; j != v34; ++j)
                                          {
                                            ValueAtIndex = CFArrayGetValueAtIndex(v26, j);
                                            v37 = CGImageSourceGetSource((uint64_t)ValueAtIndex);
                                            if (ValueAtIndex
                                              && (v38 = (const void **)v37,
                                                  v39 = CFGetTypeID(ValueAtIndex),
                                                  v39 == CGImageMetadataTagGetTypeID()))
                                            {
                                              IIOString::IIOString((IIOString *)v48, v38[6]);
                                              v40 = IIOString::createUTF8String((IIOString *)v48);
                                              IIOString::~IIOString((IIOString *)v48);
                                              if (v40)
                                              {
                                                IIOString::IIOString((IIOString *)v48, v38[2]);
                                                v41 = IIOString::createUTF8String((IIOString *)v48);
                                                IIOString::~IIOString((IIOString *)v48);
                                                IIOString::IIOString((IIOString *)v48, v38[4]);
                                                v42 = IIOString::createUTF8String((IIOString *)v48);
                                                IIOString::~IIOString((IIOString *)v48);
                                                TXMPMeta<std::string>::SetQualifier(v46, UTF8String, v17, v41, v42, (uint64_t)v40, 0);
                                                if (v41)
                                                  free(v41);
                                                if (v42)
                                                  free(v42);
                                                free(v40);
                                              }
                                            }
                                            else
                                            {
                                              LogMetadata("CreateSXMPMetaFromMetadata", 1328, "Qualifier at index %d for tag %s/%s is not a CGImageMetadataTagRef, skipping.\n", j, UTF8String, v17);
                                            }
                                          }
                                        }
                                      }
                                      if (v44)
                                        free(v44);
                                      break;
                                    case 1:
                                      goto LABEL_42;
                                    case 2:
                                      v28 = 1536;
                                      goto LABEL_42;
                                    case 3:
                                      v28 = 2560;
                                      goto LABEL_42;
                                    case 4:
                                      v28 = 4608;
LABEL_42:
                                      TXMPMeta<std::string>::SetProperty(v46, UTF8String, v17, 0, v28);
                                      if (v50 >= 0)
                                        v31 = __p;
                                      else
                                        v31 = (void **)__p[0];
                                      serializeArrayPropertyValue(v46, UTF8String, (const char *)v31, v17, SimpleStringFromCFValue, v28);
                                      break;
                                    case 5:
                                      TXMPMeta<std::string>::SetProperty(v46, UTF8String, v17, 0, 256);
                                      if (v50 >= 0)
                                        v32 = __p;
                                      else
                                        v32 = (void **)__p[0];
                                      serializeStructPropertyValue(v46, UTF8String, (const char *)v32, v17, SimpleStringFromCFValue);
                                      break;
                                    default:
                                      break;
                                  }
                                }
                              }
                              else
                              {
                                LogError("CreateSXMPMetaFromMetadata", 1265, "Could not allocate prefix string.\n");
                              }
                            }
                            else
                            {
                              LogMetadata("CreateSXMPMetaFromMetadata", 1270, "Namespace '%s' does not have a valid prefix, skipping property '%s'.\n", UTF8String, v17);
                            }
                            free(v17);
                          }
                        }
                      }
                      free(UTF8String);
                    }
                  }
                }
              }
            }
          }
          if (SHIBYTE(v50) < 0)
            operator delete(__p[0]);
          v5 = v7;
        }
        v4 = v45;
        v3 = (_QWORD *)v46;
      }
    }
    free(v4);
    if (v5)
      free(v5);
  }
  return v3;
}

void sub_187FE1D6C()
{
  __cxa_end_catch();
  JUMPOUT(0x187FE1C5CLL);
}

void sub_187FE1D78()
{
  __cxa_end_catch();
  JUMPOUT(0x187FE1C5CLL);
}

uint64_t getDefaultMetadataValueTypeForProperty(CGImageMetadataTag *a1)
{
  uint64_t Source;
  uint64_t v2;
  const void *v3;
  CFTypeID v4;
  CFTypeID v5;
  CFTypeID v6;
  CFTypeID v8;
  CFTypeID v9;

  Source = CGImageSourceGetSource((uint64_t)a1);
  v2 = *(unsigned int *)(Source + 40);
  if ((v2 + 1) <= 1)
  {
    v3 = *(const void **)(Source + 48);
    v4 = CFGetTypeID(v3);
    if (v4 == CFBooleanGetTypeID())
      return 1;
    v5 = CFGetTypeID(v3);
    if (v5 == CFNumberGetTypeID())
      return 1;
    v6 = CFGetTypeID(v3);
    if (v6 == CFStringGetTypeID())
    {
      return 1;
    }
    else
    {
      v8 = CFGetTypeID(v3);
      if (v8 == CFArrayGetTypeID())
      {
        return 3;
      }
      else
      {
        v9 = CFGetTypeID(v3);
        if (v9 == CFDictionaryGetTypeID())
          return 6;
        else
          return v2;
      }
    }
  }
  return v2;
}

void serializeArrayPropertyValue(uint64_t a1, char *a2, const char *a3, char *a4, const void *a5, unsigned int a6)
{
  CFTypeID v6;
  CFIndex v7;
  CGImageMetadataTag *ValueAtIndex;
  CGImageMetadataTag *v9;
  CFTypeID v10;
  uint64_t Source;
  IIOString *v12;
  char *UTF8String;
  IIOString *v14;
  IIOString *v15;
  char *v16;
  const void *v17;
  int DefaultMetadataValueTypeForProperty;
  const void *v19;
  CFTypeID v20;
  int v21;
  uint64_t v22;
  CFTypeID v23;
  CFTypeID v24;
  IIOString *v25;
  void *v26;
  CFIndex v27;
  CFIndex v28;
  const void *v29;
  uint64_t v30;
  const void **v31;
  CFTypeID v32;
  IIOString *v33;
  void *v34;
  _BYTE *v35;
  _BYTE *v36;
  void **v37;
  CFTypeID v38;
  CFTypeID v39;
  CFStringRef v40;
  IIOString *v41;
  const char *v42;
  void **v43;
  char *v44;
  CFStringRef v47;
  CFIndex Count;
  _BYTE v53[24];
  void **v54;
  uint64_t v55;
  uint64_t v56;

  if (a2)
  {
    if (a4)
    {
      if (a5)
      {
        v6 = CFGetTypeID(a5);
        if (v6 == CFArrayGetTypeID())
        {
          Count = CFArrayGetCount((CFArrayRef)a5);
          if (Count >= 1)
          {
            v7 = 0;
            while (1)
            {
              ValueAtIndex = (CGImageMetadataTag *)CFArrayGetValueAtIndex((CFArrayRef)a5, v7);
              v9 = ValueAtIndex;
              if (ValueAtIndex)
                break;
LABEL_53:
              if (++v7 == Count)
                return;
            }
            v10 = CFGetTypeID(ValueAtIndex);
            if (v10 == CGImageMetadataTagGetTypeID())
            {
              Source = CGImageSourceGetSource((uint64_t)v9);
              v12 = IIOString::IIOString((IIOString *)&v54, *(const void **)(Source + 16));
              UTF8String = (char *)IIOString::createUTF8String(v12);
              IIOString::~IIOString((IIOString *)&v54);
              v15 = IIOString::IIOString(v14, *(const void **)(Source + 24));
              v16 = (char *)IIOString::createUTF8String(v15);
              IIOString::~IIOString((IIOString *)&v54);
              v17 = *(const void **)(Source + 48);
              if (v17)
              {
                DefaultMetadataValueTypeForProperty = getDefaultMetadataValueTypeForProperty(v9);
                v19 = *(const void **)(Source + 56);
                if (v19)
                {
                  v20 = CFGetTypeID(v19);
                  if (v20 != CFArrayGetTypeID())
                    v19 = 0;
                }
                v21 = DefaultMetadataValueTypeForProperty - 1;
                v47 = 0;
                v22 = 512;
                switch(v21)
                {
                  case 0:
                    goto LABEL_19;
                  case 1:
                    goto LABEL_44;
                  case 2:
                    v22 = 1536;
                    goto LABEL_44;
                  case 3:
                    v22 = 2560;
                    goto LABEL_44;
                  case 4:
                    v22 = 4608;
LABEL_44:
                    v54 = 0;
                    v55 = 0;
                    v56 = 0;
                    TXMPMeta<std::string>::AppendArrayItem(a1, a2, a4, a6, 0, v22);
                    TXMPUtils<std::string>::ComposeArrayItemPath(UTF8String, a4, v7 + 1, (uint64_t)&v54);
                    if (v56 >= 0)
                      v43 = (void **)&v54;
                    else
                      v43 = v54;
                    serializeArrayPropertyValue(a1, a2, v16, v43, v17, v22);
                    break;
                  case 5:
                    v54 = 0;
                    v55 = 0;
                    v56 = 0;
                    TXMPMeta<std::string>::AppendArrayItem(a1, a2, a4, a6, 0, 256);
                    TXMPUtils<std::string>::ComposeArrayItemPath(UTF8String, a4, v7 + 1, (uint64_t)&v54);
                    if (v56 >= 0)
                      v44 = (char *)&v54;
                    else
                      v44 = (char *)v54;
                    serializeStructPropertyValue(a1, a2, v16, v44, v17);
                    break;
                  default:
                    goto LABEL_49;
                }
                if (SHIBYTE(v56) < 0)
                {
                  operator delete(v54);
                  if (!UTF8String)
                  {
LABEL_51:
                    if (v16)
                      free(v16);
                    goto LABEL_53;
                  }
LABEL_50:
                  free(UTF8String);
                  goto LABEL_51;
                }
              }
            }
            else
            {
              v23 = CFGetTypeID(v9);
              if (v23 == CFStringGetTypeID())
              {
                v16 = strdup(a3);
                UTF8String = strdup(a2);
                v19 = 0;
                v47 = 0;
                v17 = v9;
              }
              else
              {
                v24 = CFGetTypeID(v9);
                if (v24 != CFNumberGetTypeID())
                {
                  v38 = CFGetTypeID(v9);
                  if (v38 != CFDictionaryGetTypeID())
                  {
                    v39 = CFGetTypeID(v9);
                    v40 = CFCopyTypeIDDescription(v39);
                    v54 = 0;
                    v55 = 0;
                    v56 = 0;
                    v41 = IIOString::IIOString((IIOString *)&v54, v40);
                    v42 = (const char *)IIOString::utf8String(v41);
                    LogError("serializeArrayPropertyValue", 1670, "Array element has unsupported type '%s', skipping.\n", v42);
                    CFRelease(v40);
                    IIOString::~IIOString((IIOString *)&v54);
                  }
                  goto LABEL_53;
                }
                v16 = strdup(a3);
                UTF8String = strdup(a2);
                v19 = 0;
                v47 = CFStringCreateWithFormat(0, 0, CFSTR("%@"), v9);
                v17 = v47;
              }
LABEL_19:
              v25 = IIOString::IIOString((IIOString *)&v54, v17);
              v26 = IIOString::createUTF8String(v25);
              IIOString::~IIOString((IIOString *)&v54);
              if (v26)
              {
                TXMPMeta<std::string>::AppendArrayItem(a1, a2, a4, a6, (uint64_t)v26, 0);
                if (v19 && (v27 = CFArrayGetCount((CFArrayRef)v19), v27 >= 1))
                {
                  v28 = 0;
                  while (1)
                  {
                    v29 = CFArrayGetValueAtIndex((CFArrayRef)v19, v28);
                    v30 = CGImageSourceGetSource((uint64_t)v29);
                    if (!v29)
                      break;
                    v31 = (const void **)v30;
                    v32 = CFGetTypeID(v29);
                    if (v32 != CGImageMetadataTagGetTypeID())
                      break;
                    v33 = IIOString::IIOString((IIOString *)&v54, v31[6]);
                    v34 = IIOString::createUTF8String(v33);
                    IIOString::~IIOString((IIOString *)&v54);
                    if (v34)
                    {
                      v54 = 0;
                      v55 = 0;
                      v56 = 0;
                      TXMPUtils<std::string>::ComposeArrayItemPath(a2, a4, v7 + 1, (uint64_t)&v54);
                      IIOString::IIOString((IIOString *)v53, v31[2]);
                      v35 = IIOString::createUTF8String((IIOString *)v53);
                      IIOString::~IIOString((IIOString *)v53);
                      IIOString::IIOString((IIOString *)v53, v31[4]);
                      v36 = IIOString::createUTF8String((IIOString *)v53);
                      IIOString::~IIOString((IIOString *)v53);
                      if (v56 >= 0)
                        v37 = (void **)&v54;
                      else
                        v37 = v54;
                      TXMPMeta<std::string>::SetQualifier(a1, a2, v37, v35, v36, (uint64_t)v34, 0);
                      if (v35)
                        free(v35);
                      if (v36)
                        free(v36);
                      free(v34);
                      if (SHIBYTE(v56) < 0)
                        operator delete(v54);
                    }
                    if (v27 == ++v28)
                      goto LABEL_36;
                  }
                  LogMetadata("serializeArrayPropertyValue", 1701, "Qualifier at index %d for tag %s/%s is not a CGImageMetadataTagRef, skipping.\n", v28, a2, a4);
                }
                else
                {
LABEL_36:
                  free(v26);
                }
              }
              if (v47)
                CFRelease(v47);
            }
LABEL_49:
            if (!UTF8String)
              goto LABEL_51;
            goto LABEL_50;
          }
        }
      }
    }
  }
}

void sub_187FE2484(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void serializeStructPropertyValue(uint64_t a1, const char *a2, const char *a3, char *a4, const void *a5)
{
  CFTypeID v8;
  const __CFAllocator *v9;
  const void **v10;
  uint64_t v11;
  const void *v12;
  CFTypeID v13;
  CFTypeID TypeID;
  CGImageMetadataTag *v15;
  _QWORD *Source;
  const void *v17;
  int DefaultMetadataValueTypeForProperty;
  CFStringRef v19;
  CFStringRef v20;
  const void *v21;
  CFTypeID v22;
  const __CFArray *v23;
  CFTypeID v24;
  IIOString *v25;
  XMPMeta *UTF8String;
  IIOString *v27;
  IIOString *v28;
  char *v29;
  IIOString *v30;
  char *v31;
  IIOString *v32;
  uint64_t v33;
  IIOString *v34;
  const char *v35;
  CFIndex v36;
  CFIndex i;
  const void *ValueAtIndex;
  uint64_t v39;
  const void **v40;
  CFTypeID v41;
  IIOString *v42;
  void *v43;
  _BYTE *v44;
  _BYTE *v45;
  void **v46;
  void **v47;
  void **v48;
  char *v49;
  CFStringRef v50;
  CFStringRef cf;
  const void **v52;
  char *v54;
  CFIndex Count;
  void **values;
  _BYTE v58[24];
  void *v59;
  uint64_t v60;
  uint64_t v61;

  if (a2)
  {
    if (a4)
    {
      if (a5)
      {
        v8 = CFGetTypeID(a5);
        if (v8 == CFDictionaryGetTypeID())
        {
          v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          v54 = (char *)a2;
          cf = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, 0x8000100u);
          v50 = CFStringCreateWithCString(v9, a3, 0x8000100u);
          Count = CFDictionaryGetCount((CFDictionaryRef)a5);
          v10 = (const void **)malloc_type_malloc(8 * Count, 0x6004044C4A2DFuLL);
          values = (void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
          CFDictionaryGetKeysAndValues((CFDictionaryRef)a5, v10, (const void **)values);
          v52 = v10;
          if (Count >= 1)
          {
            v11 = 0;
            while (1)
            {
              v12 = values[v11];
              if (!v12)
                break;
              v13 = CFGetTypeID(v12);
              TypeID = CGImageMetadataTagGetTypeID();
              v15 = (CGImageMetadataTag *)values[v11];
              if (v13 != TypeID)
                goto LABEL_15;
              Source = (_QWORD *)CGImageSourceGetSource((uint64_t)values[v11]);
              v17 = (const void *)Source[6];
              if (v17)
              {
                DefaultMetadataValueTypeForProperty = getDefaultMetadataValueTypeForProperty(v15);
                v19 = (CFStringRef)Source[2];
                v20 = (CFStringRef)Source[3];
                v21 = (const void *)Source[7];
                if (v21)
                {
                  v22 = CFGetTypeID(v21);
                  if (v22 == CFArrayGetTypeID())
                    v23 = (const __CFArray *)v21;
                  else
                    v23 = 0;
                }
                else
                {
                  v23 = 0;
                }
LABEL_17:
                v25 = IIOString::IIOString((IIOString *)&v59, v19);
                UTF8String = (XMPMeta *)IIOString::createUTF8String(v25);
                IIOString::~IIOString((IIOString *)&v59);
                v28 = IIOString::IIOString(v27, v20);
                v29 = (char *)IIOString::createUTF8String(v28);
                IIOString::~IIOString((IIOString *)&v59);
                if (v19)
                {
                  v59 = 0;
                  v60 = 0;
                  v61 = 0;
                  if (UTF8String)
                  {
                    if (v29)
                    {
                      TXMPMeta<std::string>::RegisterNamespace(UTF8String, v29, (uint64_t)&v59);
                      if (SHIBYTE(v61) < 0)
                        operator delete(v59);
                    }
                  }
                }
                v30 = IIOString::IIOString((IIOString *)&v59, v52[v11]);
                v31 = (char *)IIOString::createUTF8String(v30);
                IIOString::~IIOString((IIOString *)&v59);
                if (!v31)
                  goto LABEL_62;
                if ((DefaultMetadataValueTypeForProperty - 2) < 4)
                {
                  v59 = 0;
                  v60 = 0;
                  v61 = 0;
                  if ((DefaultMetadataValueTypeForProperty - 3) > 2)
                    v33 = 512;
                  else
                    v33 = dword_188211A5C[DefaultMetadataValueTypeForProperty - 3];
                  TXMPMeta<std::string>::SetStructField(a1, v54, a4, (char *)UTF8String, v31, 0, v33);
                  TXMPUtils<std::string>::ComposeStructFieldPath(v54, a4, (char *)UTF8String, v31, (uint64_t)&v59);
                  if (v61 >= 0)
                    v47 = &v59;
                  else
                    v47 = (void **)v59;
                  serializeArrayPropertyValue(a1, v54, v29, v47, v17, v33);
                  goto LABEL_56;
                }
                if (DefaultMetadataValueTypeForProperty == 6)
                {
                  v59 = 0;
                  v60 = 0;
                  v61 = 0;
                  TXMPMeta<std::string>::SetStructField(a1, v54, a4, (char *)UTF8String, v31, 0, 256);
                  TXMPUtils<std::string>::ComposeStructFieldPath(v54, a4, (char *)UTF8String, v31, (uint64_t)&v59);
                  if (v61 >= 0)
                    v48 = &v59;
                  else
                    v48 = (void **)v59;
                  serializeStructPropertyValue(a1, v54, v29, v48, v17);
LABEL_56:
                  if (SHIBYTE(v61) < 0)
                  {
                    operator delete(v59);
                    if (!UTF8String)
                      goto LABEL_59;
                    goto LABEL_58;
                  }
                }
                else if (DefaultMetadataValueTypeForProperty == 1)
                {
                  v34 = IIOString::IIOString(v32, v17);
                  v35 = (const char *)IIOString::createUTF8String(v34);
                  IIOString::~IIOString((IIOString *)&v59);
                  if (v35)
                    TXMPMeta<std::string>::SetStructField(a1, v54, a4, (char *)UTF8String, v31, v35, 0);
                  v49 = (char *)v35;
                  if (v23)
                  {
                    v36 = CFArrayGetCount(v23);
                    if (v36 >= 1)
                    {
                      for (i = 0; i != v36; ++i)
                      {
                        ValueAtIndex = CFArrayGetValueAtIndex(v23, i);
                        v39 = CGImageSourceGetSource((uint64_t)ValueAtIndex);
                        if (ValueAtIndex
                          && (v40 = (const void **)v39,
                              v41 = CFGetTypeID(ValueAtIndex),
                              v41 == CGImageMetadataTagGetTypeID()))
                        {
                          v42 = IIOString::IIOString((IIOString *)&v59, v40[6]);
                          v43 = IIOString::createUTF8String(v42);
                          IIOString::~IIOString((IIOString *)&v59);
                          if (v43)
                          {
                            v59 = 0;
                            v60 = 0;
                            v61 = 0;
                            TXMPUtils<std::string>::ComposeStructFieldPath(v54, a4, (char *)UTF8String, v31, (uint64_t)&v59);
                            IIOString::IIOString((IIOString *)v58, v40[2]);
                            v44 = IIOString::createUTF8String((IIOString *)v58);
                            IIOString::~IIOString((IIOString *)v58);
                            IIOString::IIOString((IIOString *)v58, v40[4]);
                            v45 = IIOString::createUTF8String((IIOString *)v58);
                            IIOString::~IIOString((IIOString *)v58);
                            if (v61 >= 0)
                              v46 = &v59;
                            else
                              v46 = (void **)v59;
                            TXMPMeta<std::string>::SetQualifier(a1, v54, v46, v44, v45, (uint64_t)v43, 0);
                            if (v44)
                              free(v44);
                            if (v45)
                              free(v45);
                            free(v43);
                            if (SHIBYTE(v61) < 0)
                              operator delete(v59);
                          }
                        }
                        else
                        {
                          LogMetadata("serializeStructPropertyValue", 1929, "Qualifier at index %d for tag %s/%s is not a CGImageMetadataTagRef, skipping.\n", i, v54, a4);
                        }
                      }
                    }
                  }
                  if (v49)
                  {
                    free(v49);
                    if (!UTF8String)
                      goto LABEL_59;
LABEL_58:
                    free(UTF8String);
LABEL_59:
                    if (v29)
                      free(v29);
                    free(v31);
                    goto LABEL_62;
                  }
                }
                if (UTF8String)
                  goto LABEL_58;
                goto LABEL_59;
              }
LABEL_62:
              if (++v11 == Count)
                goto LABEL_71;
            }
            v15 = 0;
LABEL_15:
            v24 = CFGetTypeID(v15);
            if (v24 == CFStringGetTypeID())
            {
              v23 = 0;
              v17 = values[v11];
              DefaultMetadataValueTypeForProperty = 1;
              v20 = v50;
              v19 = cf;
              goto LABEL_17;
            }
            LogError("serializeStructPropertyValue", 1880, "Struct field has unsupported type, skipping.\n");
            goto LABEL_62;
          }
LABEL_71:
          if (cf)
            CFRelease(cf);
          if (v50)
            CFRelease(v50);
          if (values)
            free(values);
          if (v52)
            free(v52);
        }
      }
    }
  }
}

#error "187FE2B8C: call analysis failed (funcsize=22)"

void sub_187FE2BB4(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t SerializeMetadataForJPEGXMP(CFDictionaryRef *a1, char **a2, _QWORD *a3, char **a4, _QWORD *a5, char **a6, _QWORD *a7)
{
  _QWORD *SXMPMetaFromMetadata;
  _QWORD *v15;
  uint64_t v16;
  char *v17;
  const char *v18;
  char *v19;
  uint64_t v20;
  char *v21;
  const char *v22;
  char *v23;
  uint64_t v24;
  char *v25;
  const char *p_p;
  char *v27;
  void *__p;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;

  if (a3)
    *a3 = 0;
  if (a5)
  {
    *a5 = 0;
    if (a3)
    {
      if (a1 && a7)
      {
        v35 = 0;
        v36 = 0;
        v37 = 0;
        v32 = 0;
        v33 = 0;
        v34 = 0;
        __p = 0;
        v30 = 0;
        v31 = 0;
        IIO_InitializeXMPToolkit();
        SXMPMetaFromMetadata = CreateSXMPMetaFromMetadata(a1);
        v15 = SXMPMetaFromMetadata;
        if (SXMPMetaFromMetadata)
        {
          TXMPUtils<std::string>::PackageForJPEG((uint64_t)SXMPMetaFromMetadata, (uint64_t)&v35, (uint64_t)&v32, (uint64_t)&__p);
          (*(void (**)(_QWORD *))(*v15 + 8))(v15);
          if (v37 >= 0)
            v16 = HIBYTE(v37);
          else
            v16 = v36;
          v17 = (char *)malloc_type_malloc(v16 + 1, 0x100004077774924uLL);
          if (v37 >= 0)
            v18 = (const char *)&v35;
          else
            v18 = (const char *)v35;
          v19 = strncpy(v17, v18, v16 + 1);
          v19[v16] = 0;
          *a3 = v16 + 1;
          *a2 = v19;
          if (v34 >= 0)
            v20 = HIBYTE(v34);
          else
            v20 = v33;
          v21 = (char *)malloc_type_malloc(v20 + 1, 0x100004077774924uLL);
          if (v34 >= 0)
            v22 = (const char *)&v32;
          else
            v22 = (const char *)v32;
          v23 = strncpy(v21, v22, v20 + 1);
          v23[v20] = 0;
          *a5 = v20 + 1;
          *a4 = v23;
          if (v31 >= 0)
            v24 = HIBYTE(v31);
          else
            v24 = v30;
          v25 = (char *)malloc_type_malloc(v24 + 1, 0x100004077774924uLL);
          if (v31 >= 0)
            p_p = (const char *)&__p;
          else
            p_p = (const char *)__p;
          v27 = strncpy(v25, p_p, v24 + 1);
          v27[v24] = 0;
          *a7 = v24 + 1;
          *a6 = v27;
        }
        IIO_TerminateXMPToolkit();
        if (SHIBYTE(v31) < 0)
          operator delete(__p);
        if (SHIBYTE(v34) < 0)
          operator delete(v32);
        if (SHIBYTE(v37) < 0)
          operator delete(v35);
      }
    }
  }
  return 0;
}

BOOL IIO_XMPMeta_ErrorCallback(_QWORD *a1, int a2, int a3, const char *a4)
{
  if (!a2)
    ++*a1;
  return a2 == 0;
}

void std::vector<std::string>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 24)
  {
    if (*(char *)(i - 1) < 0)
      operator delete(*(void **)(i - 24));
  }
  a1[1] = v2;
}

uint64_t std::vector<std::string>::__push_back_slow_path<std::string const&>(uint64_t *a1, __int128 *a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  std::string *v10;
  std::__split_buffer<std::string>::pointer end;
  __int128 v12;
  uint64_t v13;
  std::__split_buffer<std::string> __v;

  v3 = *a1;
  v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL)
    std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x555555555555555)
    v9 = 0xAAAAAAAAAAAAAAALL;
  else
    v9 = v5;
  __v.__end_cap_.__value_ = (std::allocator<std::string> *)(a1 + 2);
  if (v9)
    v10 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(v7, v9);
  else
    v10 = 0;
  end = v10 + v4;
  __v.__first_ = v10;
  __v.__begin_ = end;
  __v.__end_ = end;
  __v.__end_cap_.__value_ = &v10[v9];
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(end, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
    end = __v.__end_;
  }
  else
  {
    v12 = *a2;
    end->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&end->__r_.__value_.__l.__data_ = v12;
  }
  __v.__end_ = end + 1;
  std::vector<std::string>::__swap_out_circular_buffer((std::vector<std::string> *)a1, &__v);
  v13 = a1[1];
  std::__split_buffer<std::string>::~__split_buffer(&__v);
  return v13;
}

void sub_187FE3014(_Unwind_Exception *a1, std::__split_buffer<std::string> *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  std::__split_buffer<std::string>::~__split_buffer((std::__split_buffer<std::string> *)&a10);
  _Unwind_Resume(a1);
}

void std::vector<std::string>::__swap_out_circular_buffer(std::vector<std::string> *this, std::__split_buffer<std::string> *__v)
{
  std::string *v4;
  std::string *begin;
  std::string *end;
  std::string *value;

  std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::string>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>>((uint64_t)&this->__end_cap_, (uint64_t)this->__end_, (uint64_t)this->__end_, (uint64_t)this->__begin_, (uint64_t)this->__begin_, (uint64_t)__v->__begin_, (uint64_t)__v->__begin_);
  __v->__begin_ = v4;
  begin = this->__begin_;
  this->__begin_ = v4;
  __v->__begin_ = begin;
  end = this->__end_;
  this->__end_ = __v->__end_;
  __v->__end_ = end;
  value = this->__end_cap_.__value_;
  this->__end_cap_.__value_ = __v->__end_cap_.__value_;
  __v->__end_cap_.__value_ = value;
  __v->__first_ = __v->__begin_;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(24 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::string>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  __int128 v10;
  _QWORD v12[3];
  uint64_t v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  v13 = 0;
  if (a3 != a5)
  {
    v9 = a7;
    do
    {
      v10 = *(_OWORD *)(a3 - 24);
      *(_QWORD *)(v9 - 8) = *(_QWORD *)(a3 - 8);
      *(_OWORD *)(v9 - 24) = v10;
      v9 -= 24;
      *(_QWORD *)(a3 - 16) = 0;
      *(_QWORD *)(a3 - 8) = 0;
      *(_QWORD *)(a3 - 24) = 0;
      v7 -= 24;
      a3 -= 24;
    }
    while (a3 != a5);
    *((_QWORD *)&v15 + 1) = v9;
  }
  LOBYTE(v13) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return a6;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 23) < 0)
      operator delete(*(void **)v1);
    v1 += 24;
  }
}

void std::__split_buffer<std::string>::~__split_buffer(std::__split_buffer<std::string> *this)
{
  std::__split_buffer<std::string>::__destruct_at_end[abi:ne180100]((uint64_t)this, (void **)&this->__begin_->__r_.__value_.__l.__data_);
  if (this->__first_)
    operator delete(this->__first_);
}

void std::__split_buffer<std::string>::__destruct_at_end[abi:ne180100](uint64_t a1, void **a2)
{
  void **v2;
  void **v5;

  v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      v5 = v2 - 3;
      *(_QWORD *)(a1 + 16) = v2 - 3;
      if (*((char *)v2 - 1) < 0)
      {
        operator delete(*v5);
        v5 = *(void ***)(a1 + 16);
      }
      v2 = v5;
    }
    while (v5 != a2);
  }
}

_QWORD *ICOReadPlugin::ICOReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  _QWORD *result;

  result = (_QWORD *)IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *result = &off_1E1BACC88;
  return result;
}

_QWORD *ICOReadPlugin::ICOReadPlugin(uint64_t a1, uint64_t a2, int a3)
{
  _QWORD *result;

  result = (_QWORD *)IIOReadPlugin::IIOReadPlugin(a1, a2, a3);
  *result = &off_1E1BACC88;
  return result;
}

void ICOReadPlugin::~ICOReadPlugin(ICOReadPlugin *this)
{
  IIOReadPlugin::~IIOReadPlugin(this);
  JUMPOUT(0x18D761C30);
}

uint64_t ICOReadPlugin::loadDataFromXPCObject(ICOReadPlugin *this, void *a2)
{
  uint64_t result;
  _QWORD *data;
  _QWORD *v6;
  size_t length;

  result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!(_DWORD)result)
  {
    length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_ico", &length);
    if (length == 8)
    {
      v6 = data;
      result = 0;
      *((_QWORD *)this + 55) = *v6;
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t ICOReadPlugin::saveDataToXPCObject(ICOReadPlugin *this, void *a2)
{
  uint64_t v4;

  v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!(_DWORD)v4)
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_ico", (char *)this + 440, 8uLL);
  return v4;
}

uint64_t ICOReadPlugin::initialize(IIOImageReadSession **this, IIODictionary *a2)
{
  size_t v4;
  unsigned __int16 *v5;
  uint64_t v6;
  unsigned int v7;
  __int16 *v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  int v13;
  unint64_t v15;
  BOOL v16;
  unint64_t v17;
  unint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  unsigned __int16 *v24;
  unsigned int *v25;
  size_t BytesAtOffset;
  uint8x8_t v27;
  uint64_t v28;
  unsigned int v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  unsigned __int16 *v33;
  int v34;
  uint64_t v35;
  const char *v36;
  uint64_t v37;
  unsigned __int8 *v38;
  uint64_t v39;
  uint64_t v40;
  unsigned __int8 *v41;
  unsigned __int8 *v42;
  unsigned __int8 v43;
  unsigned __int8 v44;
  CGColorSpace *v45;
  char v46;
  int v47;
  IIOImageReadSession *v48;
  IIOImageReadSession *v49;
  uint64_t v50;
  char v51;
  char v52;
  IIODictionary *v54;
  unsigned __int16 *__base;
  __int128 v56;
  void *value[2];
  uint64_t v58;
  _BYTE v59[24];
  _BYTE v60[24];
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  uint64_t v65;
  int v66;
  __int16 v67;
  __int32 __dst[5];

  __dst[0] = 0;
  v67 = 0;
  v66 = 0;
  v65 = 0;
  v63 = 0u;
  v64 = 0u;
  v61 = 0u;
  v62 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v61, this[3]);
  if (!*((_BYTE *)this + 341)
    || (v54 = a2, IIOScanner::getBytes((IIOScanner *)&v61, &v66, 6uLL), v4 = v67, !(_BYTE)v67)
    || *((_DWORD *)this + 52) >= v67)
  {
    v28 = 4294967246;
    goto LABEL_93;
  }
  v5 = (unsigned __int16 *)malloc_type_calloc(v67, 0x10uLL, 0x1000040451B5BE8uLL);
  if (IIOScanner::getBytes((IIOScanner *)&v61, v5, 16 * v4) != 16 * v4)
  {
    v52 = 0;
    v28 = 4294967246;
    goto LABEL_90;
  }
  v6 = 0;
  v7 = (16 * v4) | 6;
  __base = v5;
  v8 = (__int16 *)(v5 + 3);
  do
  {
    if (BYTE2(v66) == 2)
    {
      v9 = (uint64_t)this[7];
      IIONumber::IIONumber((IIONumber *)v60, (unsigned __int16)*(v8 - 1));
      IIODictionary::setObjectForKey(v9, (uint64_t)v60, CFSTR("hotspotX"));
      IIONumber::~IIONumber((IIONumber *)v60);
      v10 = (uint64_t)this[7];
      IIONumber::IIONumber((IIONumber *)v59, (unsigned __int16)*v8);
      IIODictionary::setObjectForKey(v10, (uint64_t)v59, CFSTR("hotspotY"));
      IIONumber::~IIONumber((IIONumber *)v59);
      *(_DWORD *)(v8 - 1) = 65537;
      v11 = 1;
    }
    else
    {
      v11 = (unsigned __int16)*v8;
    }
    v12 = *((unsigned __int8 *)v8 - 6);
    v13 = *((unsigned __int8 *)v8 - 5);
    if (v12 | v13)
    {
      v16 = (v12 - 12) > 0xFFFFFFF4 || (v13 - 12) > 0xFFFFFFF4;
      if (v16
        || v11 > 0x20
        || ((1 << v11) & 0x101000113) == 0
        || (v17 = *(unsigned int *)(v8 + 1), v17 < 0x28)
        || (v18 = *(unsigned int *)(v8 + 3), v18 < v7)
        || (unint64_t)v62 < v18)
      {
        _cg_jpeg_mem_term("initialize", 188, "*** ERROR: ICO#%2d - bad dimension (%3dx%3d) | bitDepth (%6d) | offset (%10ld) - skipping\n", v6, v12, v13, v11, *(unsigned int *)(v8 + 3));
        goto LABEL_40;
      }
      if (!v11 && *((_BYTE *)v8 - 6) && *((_BYTE *)v8 - 5))
      {
        v19 = 4 * v13;
        v20 = 4 * v13 * ((v12 + 31) >> 5);
        v21 = v20 + 40;
        if (v20 + 40 + v20 >= v17)
        {
          *v8 = 1;
          goto LABEL_41;
        }
        if ((unint64_t)(v19 * ((2 * v12 + 31) >> 5)) + v21 - 120 >= v17)
        {
          v22 = 2;
LABEL_47:
          *v8 = v22;
          goto LABEL_41;
        }
        if (v21 + (unint64_t)(v19 * ((4 * v12 + 31) >> 5) + 64) >= v17)
        {
          v22 = 4;
          goto LABEL_47;
        }
        if (v21 + (unint64_t)(v19 * ((8 * v12 + 31) >> 5) + 1024) >= v17)
        {
          v22 = 8;
          goto LABEL_47;
        }
        if (v21 + (unint64_t)(v19 * ((24 * v12 + 31) >> 5)) < v17)
        {
          if (v21 + (unint64_t)(4 * v12 * v13) < v17)
          {
            _cg_jpeg_mem_term("initialize", 218, "*** ERROR: skipping bad ICO#%d - [2]\n", v6);
            goto LABEL_40;
          }
          v22 = 32;
          goto LABEL_47;
        }
        *v8 = 24;
      }
    }
    else
    {
      if (v11 > 0x20 || ((1 << v11) & 0x101000113) == 0)
      {
        v15 = *(unsigned int *)(v8 + 3);
LABEL_39:
        _cg_jpeg_mem_term("initialize", 172, "*** ERROR: ICO#%2d - bad dimension (%3dx%3d) | bitDepth (%6d) | offset (%10ld) - skipping\n", v6, 0, 0, v11, v15);
LABEL_40:
        *(_QWORD *)(v8 - 3) = 0;
        *(_QWORD *)(v8 + 1) = 0;
        goto LABEL_41;
      }
      v15 = *(unsigned int *)(v8 + 3);
      if (*(_DWORD *)(v8 + 1) < 0x28u || v15 < v7 || (unint64_t)v62 < v15)
        goto LABEL_39;
    }
LABEL_41:
    ++v6;
    v8 += 8;
  }
  while (v4 != v6);
  qsort_b(v5, v4, 0x10uLL, &__block_literal_global_18);
  v23 = *((unsigned int *)this + 52);
  v24 = &v5[8 * v23];
  v25 = (unsigned int *)(v24 + 6);
  BytesAtOffset = IIOScanner::getBytesAtOffset((IIOScanner *)&v61, __dst, *((unsigned int *)v24 + 3), 4uLL);
  v27.i32[0] = __dst[0];
  if (vmovn_s16((int16x8_t)vmovl_u8(v27)).u32[0] == 1196314761 && BytesAtOffset == 4)
  {
    IIONumber::IIONumber((IIONumber *)&v56, 1347307296);
    IIODictionary::setObjectForKey(v54, value[0], CFSTR("NEW_PLUGIN_ostype"));
    IIONumber::~IIONumber((IIONumber *)&v56);
    IIONumber::IIONumber((IIONumber *)&v56, *v25);
    IIODictionary::setObjectForKey(v54, value[0], CFSTR("NEW_PLUGIN_dataOffset"));
    IIONumber::~IIONumber((IIONumber *)&v56);
    IIONumber::IIONumber((IIONumber *)&v56, *(unsigned __int8 *)v24);
    IIODictionary::setObjectForKey(v54, value[0], CFSTR("NEW_PLUGIN_expectedWidth"));
    IIONumber::~IIONumber((IIONumber *)&v56);
    IIONumber::IIONumber((IIONumber *)&v56, HIBYTE(v5[8 * v23]));
    IIODictionary::setObjectForKey(v54, value[0], CFSTR("NEW_PLUGIN_expectedHeight"));
    IIONumber::~IIONumber((IIONumber *)&v56);
    v28 = 4294967247;
    goto LABEL_53;
  }
  v29 = *(_DWORD *)&v5[8 * v23 + 4];
  v28 = 4294967246;
  if (v29 < 0x29)
    goto LABEL_53;
  v30 = *v25;
  if (!(_DWORD)v30)
    goto LABEL_53;
  v58 = 0;
  v56 = 0u;
  *(_OWORD *)value = 0u;
  if (IIOScanner::getBytesAtOffset((IIOScanner *)&v61, &v56, v30, 0x28uLL) != 40)
  {
LABEL_100:
    v28 = 4294967246;
LABEL_53:
    free(v5);
    goto LABEL_93;
  }
  v31 = DWORD2(v56) >> 1;
  v32 = HIWORD(v56);
  v33 = v5;
  if (DWORD1(v56) <= *(unsigned __int8 *)v24)
    v34 = *(unsigned __int8 *)v24;
  else
    v34 = DWORD1(v56);
  if (v31 <= HIBYTE(__base[8 * v23]))
    v35 = HIBYTE(v33[8 * v23]);
  else
    v35 = v31;
  if (v34 && (v34 - 12) >= 0xF5)
  {
    _cg_jpeg_mem_term("initialize", 286, "*** ERROR: unsupported width: %d\n");
LABEL_99:
    v5 = __base;
    goto LABEL_100;
  }
  if ((_DWORD)v35 && (v35 - 12) > 0xF4)
  {
    v36 = "*** ERROR: unsupported height: %d\n";
    v37 = 287;
    v32 = v35;
LABEL_98:
    _cg_jpeg_mem_term("initialize", v37, v36, v32);
    goto LABEL_99;
  }
  v36 = "*** ERROR: unsupported bpp: %d\n";
  v37 = 288;
  if (HIWORD(v56) > 0x20u || ((1 << SBYTE14(v56)) & 0x101000112) == 0)
    goto LABEL_98;
  v38 = 0;
  LODWORD(v39) = 0;
  *((_DWORD *)this + 57) = v34;
  *((_DWORD *)this + 58) = v35;
  if ((int)v32 <= 7)
  {
    if ((_DWORD)v32 != 1 && (_DWORD)v32 != 4)
      goto LABEL_87;
    goto LABEL_77;
  }
  switch((_DWORD)v32)
  {
    case 0x20:
      LODWORD(v39) = 0;
      v38 = 0;
      this[34] = (IIOImageReadSession *)0x3000400200008;
      *((_DWORD *)this + 59) = 4 * v34;
      *((_DWORD *)this + 60) = 2097160;
      *((_WORD *)this + 122) = 4;
      *((_BYTE *)this + 246) = 3;
      *((_BYTE *)this + 350) = 1;
      this[20] = 0;
      break;
    case 0x18:
      LODWORD(v39) = 0;
      v38 = 0;
      *((_DWORD *)this + 59) = (3 * v34 + 7) & 0xFFFFFFF8;
      *((_DWORD *)this + 60) = 1572872;
      *((_WORD *)this + 122) = 3;
      this[34] = (IIOImageReadSession *)0x5000400200008;
      *((_DWORD *)this + 67) = (4 * v34 + 15) & 0x7FFFFFF0;
      *((_BYTE *)this + 350) = 1;
      this[20] = 0;
      *((_BYTE *)this + 246) = 0;
      break;
    case 8:
LABEL_77:
      v39 = 4 << v32;
      if (v29 > (4 << v32) + 40)
      {
        v38 = (unsigned __int8 *)malloc_type_calloc(4 << v32, 1uLL, 0xBC705827uLL);
        if (IIOScanner::getBytesAtOffset((IIOScanner *)&v61, v38, (v30 + 40), 4 << v32) == v39)
        {
          v40 = 0;
          v41 = v38 + 1;
          v42 = v38 + 2;
          do
          {
            v43 = v41[v40];
            v44 = v38[v40];
            *(v42 - 2) = v41[v40 + 1];
            *(v42 - 1) = v43;
            *v42 = v44;
            v42 += 3;
            v40 += 4;
          }
          while (4 * (1 << v32) != v40);
          v45 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
          this[20] = CGColorSpaceCreateIndexed(v45, (1 << v32) - 1, v38);
          CGColorSpaceRelease(v45);
          *((_WORD *)this + 121) = v32;
          *((_WORD *)this + 120) = v32;
          *((_WORD *)this + 122) = 1;
          *((_DWORD *)this + 59) = ((v34 * v32 + 31) >> 3) & 0x1FFFFFFC;
          if ((_DWORD)v32 == 1)
            v46 = 1;
          else
            v46 = 2;
          *((_DWORD *)this + 67) = v34 << v46;
          *((_DWORD *)this + 68) = 1048584;
          *((_WORD *)this + 138) = 2;
          *((_BYTE *)this + 278) = 3;
          break;
        }
        v5 = __base;
        goto LABEL_104;
      }
      v28 = 4294967246;
      v5 = __base;
      goto LABEL_53;
  }
LABEL_87:
  *((_DWORD *)this + 81) = 1380401696;
  *((_BYTE *)this + 344) = 0;
  *((_BYTE *)this + 346) = 0;
  v47 = v56 + v39;
  v48 = (IIOImageReadSession *)(v56 + v39 + v30);
  this[24] = v48;
  this[55] = (IIOImageReadSession *)(v29 - v47);
  v49 = this[23];
  if (v49 > v48)
  {
    v50 = 0;
    v28 = 0;
    v51 = 1;
    this[45] = (IIOImageReadSession *)1;
    *((_WORD *)this + 188) = 1;
    v52 = 1;
    v5 = __base;
    if (v38)
      goto LABEL_89;
    goto LABEL_90;
  }
  _cg_jpeg_mem_term("initialize", 376, "bad offset %d > fileSize %d\n", (_DWORD)v48, (_DWORD)v49);
  v5 = __base;
LABEL_104:
  v51 = 0;
  v52 = 0;
  v50 = 4294967246;
  v28 = 4294967246;
  if (v38)
  {
LABEL_89:
    free(v38);
    v52 = v51;
    v28 = v50;
  }
LABEL_90:
  if (v5)
    free(v5);
  if ((v52 & 1) == 0)
LABEL_93:
    kdebug_trace();
  IIOScanner::~IIOScanner((IIOScanner *)&v61);
  return v28;
}

void sub_187FE3C58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  IIOScanner::~IIOScanner((IIOScanner *)&a29);
  _Unwind_Resume(a1);
}

uint64_t ___ZN13ICOReadPlugin10initializeEP13IIODictionary_block_invoke(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  BOOL v8;
  unsigned int v9;

  v3 = *a2;
  if (!*a2)
    v3 = 256;
  if (*a3)
    v4 = *a3;
  else
    v4 = 256;
  v5 = *((unsigned __int16 *)a2 + 3);
  v6 = *((unsigned __int16 *)a3 + 3);
  if (v5 < v6)
    return 1;
  if (v5 > v6)
    return 0xFFFFFFFFLL;
  v8 = v3 >= v4;
  if (v3 <= v4)
    v9 = 0;
  else
    v9 = -1;
  if (v8)
    return v9;
  else
    return 1;
}

uint64_t ICOReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v2;

  v2 = *(__int16 *)(a1 + 376);
  if (v2 == 12)
    return IIOReadPlugin::setupImageProviderCallbackV2(a1, a2, (uint64_t)IIO_Reader::CopyImageBlockSetProc, (uint64_t)IIO_Reader::CopyIOSurfaceProc);
  if (v2 == 1)
    return IIOReadPlugin::setupCallback(a1, a2);
  return 4294967246;
}

uint64_t ICOReadPlugin::decodeImageData(ICOReadPlugin *this, IIOBitStream *a2, void *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  size_t v7;
  size_t v8;
  IIOBitStream *v11;
  IIOBitStream *v12;
  const char *v13;
  unsigned int v14;
  uint64_t IIOBitStream;
  const char *v16;
  uint64_t v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned __int8 *v25;
  IIOBitStream *v26;
  uint64_t v27;
  uint64_t v28;
  unsigned __int8 *v29;
  unsigned __int8 *v30;
  uint64_t v31;
  uint64_t v32;
  unsigned __int8 v33;
  char v34;
  uint64_t v35;
  uint64_t v36;
  unsigned __int8 *v37;
  unsigned __int8 *v38;
  uint64_t v39;
  uint64_t v40;
  IIOBitStream *v42;
  IIOBitStream *v43;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;

  v4 = *((unsigned int *)this + 57);
  v3 = *((unsigned int *)this + 58);
  v5 = *((unsigned int *)this + 59);
  v6 = ((unint64_t)(v4 + 31) >> 3) & 0x3FFFFFFC;
  if (*((_WORD *)this + 121) == 32)
    v6 = 0;
  v46 = v6;
  v7 = (v6 + v5) * v3;
  v8 = *((_QWORD *)this + 55);
  if (v8 < v7)
  {
    _cg_jpeg_mem_term("decodeImageData", 451, "*** _ico._length: %d   length: %d\n", v8, v7);
    return 4294967246;
  }
  v45 = *((unsigned int *)this + 75);
  v11 = (IIOBitStream *)malloc_type_calloc(v7, 1uLL, 0xA43BFE77uLL);
  if (!v11)
    return 4294967246;
  v12 = v11;
  v47 = 0;
  if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v11, *((_QWORD *)this + 24), v7) <= v7)
  {
    v14 = *((unsigned __int16 *)this + 121);
    if (v14 <= 7)
    {
      IIOBitStream = IIOBitStream::CreateIIOBitStream(v12, (void *)(v5 * (unint64_t)v3), "r", v13);
      v17 = IIOBitStream::CreateIIOBitStream((IIOBitStream *)((char *)v12 + v5 * (unint64_t)v3), (void *)(v46 * (unint64_t)v3), "r", v16);
      v19 = IIOBitStream::CreateIIOBitStream(a2, a3, "w", v18);
      if ((_DWORD)v3)
      {
        v42 = v12;
        v20 = 0;
        while (1)
        {
          (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)IIOBitStream + 32))(IIOBitStream, v20 * v5);
          (*(void (**)(uint64_t, unint64_t))(*(_QWORD *)v17 + 32))(v17, v20 * v46);
          (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v19 + 32))(v19, (~v20 + v3) * v45);
          v21 = v4;
          if ((_DWORD)v4)
            break;
LABEL_18:
          if (++v20 == v3)
          {
            v24 = 0;
            goto LABEL_30;
          }
        }
        while (1)
        {
          v22 = (*(uint64_t (**)(uint64_t, _QWORD, char *))(*(_QWORD *)IIOBitStream + 24))(IIOBitStream, *((unsigned __int16 *)this + 120), (char *)&v47 + 4);
          if ((_DWORD)v22)
            break;
          v22 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *))(*(_QWORD *)v17 + 24))(v17, 1, &v47);
          if ((_DWORD)v22)
            break;
          v22 = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v19 + 16))(v19, *((unsigned __int16 *)this + 152), HIDWORD(v47));
          if ((_DWORD)v22)
            break;
          v23 = (_DWORD)v47 ? 0 : 0xFFFFFFFFLL;
          v22 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v19 + 16))(v19, 8, v23);
          if ((_DWORD)v22)
            break;
          if (!--v21)
            goto LABEL_18;
        }
        v24 = v22;
LABEL_30:
        v12 = v42;
      }
      else
      {
        v24 = 0;
        if (!IIOBitStream)
        {
LABEL_32:
          if (!v17)
            goto LABEL_34;
          goto LABEL_33;
        }
      }
      (*(void (**)(uint64_t))(*(_QWORD *)IIOBitStream + 8))(IIOBitStream);
      goto LABEL_32;
    }
    if (v14 == 8)
    {
      v17 = IIOBitStream::CreateIIOBitStream((IIOBitStream *)((char *)v12 + v5 * (unint64_t)v3), (void *)(v46 * (unint64_t)v3), "r", v13);
      if ((_DWORD)v3)
      {
        v27 = v5;
        v28 = 0;
        while (1)
        {
          (*(void (**)(uint64_t, unint64_t))(*(_QWORD *)v17 + 32))(v17, v28 * v46);
          if ((_DWORD)v4)
            break;
LABEL_45:
          if (++v28 == v3)
          {
            v24 = 0;
            goto LABEL_62;
          }
        }
        v29 = (unsigned __int8 *)a2 + (~v28 + v3) * v45;
        v30 = (unsigned __int8 *)v12 + v28 * v27;
        v31 = v4;
        while (1)
        {
          v32 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *))(*(_QWORD *)v17 + 24))(v17, 1, &v47);
          if ((_DWORD)v32)
            break;
          v33 = *v30++;
          *v29 = v33;
          if ((_DWORD)v47)
            v34 = 0;
          else
            v34 = -1;
          v29[1] = v34;
          v29 += 2;
          if (!--v31)
            goto LABEL_45;
        }
        v24 = v32;
LABEL_62:
        v19 = 0;
        goto LABEL_33;
      }
    }
    else
    {
      if (v14 != 24)
      {
        if (v14 == 32)
        {
          if ((_DWORD)v3)
          {
            v25 = (unsigned __int8 *)a2 + (v3 - 1) * v45;
            v26 = v12;
            do
            {
              memcpy(v25, v26, 4 * v4);
              v26 = (IIOBitStream *)((char *)v26 + v5);
              v25 -= v45;
              --v3;
            }
            while (v3);
          }
        }
        else
        {
          _cg_jpeg_mem_term("decodeImageData", 559, "*** _rpd._inputGeo.bitsPerPixel [%d] not handled\n", *((unsigned __int16 *)this + 121));
        }
        v24 = 0;
        goto LABEL_57;
      }
      v17 = IIOBitStream::CreateIIOBitStream((IIOBitStream *)((char *)v12 + v5 * (unint64_t)v3), (void *)(v46 * (unint64_t)v3), "r", v13);
      if ((_DWORD)v3)
      {
        v35 = v5;
        v43 = v12;
        v36 = 0;
        while (1)
        {
          (*(void (**)(uint64_t, unint64_t))(*(_QWORD *)v17 + 32))(v17, v36 * v46);
          if ((_DWORD)v4)
            break;
LABEL_53:
          if (++v36 == v3)
          {
            v24 = 0;
            goto LABEL_64;
          }
        }
        v37 = (unsigned __int8 *)a2 + (~v36 + v3) * v45;
        v38 = (unsigned __int8 *)v43 + v36 * v35;
        v39 = v4;
        while (1)
        {
          v40 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *))(*(_QWORD *)v17 + 24))(v17, 1, &v47);
          if ((_DWORD)v40)
            break;
          *v37 = *v38;
          v37[1] = v38[1];
          v37[2] = v38[2];
          v37[3] = -1;
          v38 += 3;
          v37 += 4;
          if (!--v39)
            goto LABEL_53;
        }
        v24 = v40;
LABEL_64:
        v19 = 0;
        v12 = v43;
        goto LABEL_33;
      }
    }
    v19 = 0;
    v24 = 0;
    if (!v17)
    {
LABEL_34:
      if (v19)
        (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
      goto LABEL_57;
    }
LABEL_33:
    (*(void (**)(uint64_t))(*(_QWORD *)v17 + 8))(v17);
    goto LABEL_34;
  }
  v24 = 4294967246;
LABEL_57:
  free(v12);
  return v24;
}

uint64_t ICOReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4)
{
  int v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  IIOImageRead **v20;
  _BOOL4 v21;
  void *BaseAddress;
  size_t Height;
  uint64_t BlockArray;
  size_t v25;
  double v26;
  double v27;
  unint64_t v28;
  unsigned int v29;
  vImagePixelCount v30;
  size_t v31;
  const char **v32;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  double v37;
  double v38;
  uint8_t permuteMap[4];
  vImage_Buffer dest;
  size_t v41;
  CGRect v42;
  CGRect v43;

  v41 = 0;
  if ((gIIODebugFlags & 0x20000) == 0)
    goto LABEL_26;
  v8 = *((_DWORD *)this + 51);
  v9 = v8 >> 24;
  v10 = MEMORY[0x1E0C80978];
  if (v8 < 0)
  {
    v11 = __maskrune(v9, 0x40000uLL);
    v8 = *((_DWORD *)this + 51);
  }
  else
  {
    v11 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v9 + 60) & 0x40000;
  }
  if (v11)
    v12 = (v8 >> 24);
  else
    v12 = 46;
  v13 = v8 << 8 >> 24;
  if (v8 << 8 < 0)
  {
    v14 = __maskrune(v13, 0x40000uLL);
    v8 = *((_DWORD *)this + 51);
  }
  else
  {
    v14 = *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
  }
  if (v14)
    v15 = (v8 << 8 >> 24);
  else
    v15 = 46;
  v16 = (__int16)v8 >> 8;
  if (v8 << 16 < 0)
  {
    v17 = __maskrune(v16, 0x40000uLL);
    v8 = *((_DWORD *)this + 51);
  }
  else
  {
    v17 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
  }
  if (v17)
    v18 = ((__int16)v8 >> 8);
  else
    v18 = 46;
  if ((v8 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v10 + 4 * (char)v8 + 60) & 0x40000) != 0)
      goto LABEL_22;
LABEL_24:
    v19 = 46;
    goto LABEL_25;
  }
  if (!__maskrune((char)v8, 0x40000uLL))
    goto LABEL_24;
LABEL_22:
  v19 = *((char *)this + 204);
LABEL_25:
  ImageIOLog("  '%c%c%c%c' [%s] %s\n", v12, v15, v18, v19, iioTypeStr[a3], "virtual OSStatus ICOReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  v20 = (IIOImageRead **)*((_QWORD *)this + 3);
  if (v20)
    v21 = IIOImageReadSession::mapData(v20);
  else
    v21 = 0;
  if (a3 == 3)
  {
    BlockArray = IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
    LODWORD(v28) = *((_DWORD *)this + 73);
    v27 = (double)v28;
    v29 = *((_DWORD *)this + 74);
    v26 = (double)v29;
    v25 = *((unsigned int *)this + 75) * (unint64_t)v29;
    BaseAddress = (void *)_ImageIO_Malloc(v25, *((_QWORD *)this + 48), &v41, (uint64_t)kImageMalloc_ICO_Data[0], *((_DWORD *)this + 108), 0, 0);
  }
  else
  {
    if (a3 != 1 || !a4 || !*a4)
      goto LABEL_48;
    IOSurfaceLock(*a4, 0, 0);
    BaseAddress = IOSurfaceGetBaseAddress(*a4);
    Height = IOSurfaceGetHeight(*a4);
    BlockArray = 0;
    v25 = IOSurfaceGetBytesPerRow(*a4) * Height;
    v41 = v25;
    v26 = 0.0;
    v27 = 0.0;
  }
  if (!BaseAddress)
    goto LABEL_49;
  memset(BaseAddress, 255, v25);
  BlockArray = (*(uint64_t (**)(IIOReadPlugin *, void *, size_t))(*(_QWORD *)this + 112))(this, BaseAddress, v25);
  if (*((_WORD *)this + 153) == 32 && *((_WORD *)this + 152) == 8)
  {
    v30 = *((unsigned int *)this + 74);
    dest.data = BaseAddress;
    dest.height = v30;
    v31 = *((unsigned int *)this + 75);
    dest.width = *((unsigned int *)this + 73);
    dest.rowBytes = v31;
    if (*((_BYTE *)this + 405))
    {
      *(_DWORD *)permuteMap = 50331906;
      vImagePermuteChannels_ARGB8888(&dest, &dest, permuteMap, 0x10u);
    }
    if (*((_BYTE *)this + 406) == 1)
      vImagePremultiplyData_RGBA8888(&dest, &dest, 0);
  }
  if ((_DWORD)BlockArray)
  {
    *((_DWORD *)this + 26) = 0;
    if (a3 == 3)
    {
      _ImageIO_Free((unint64_t)BaseAddress, v41);
      if (!v21)
        return BlockArray;
      goto LABEL_50;
    }
LABEL_49:
    if (!v21)
      return BlockArray;
    goto LABEL_50;
  }
  if (a3 != 3)
  {
    IOSurfaceUnlock(*a4, 0, 0);
LABEL_48:
    BlockArray = 0;
    goto LABEL_49;
  }
  v34 = 0;
  v42.origin.x = 0.0;
  v42.origin.y = 0.0;
  v42.size.width = v27;
  v42.size.height = v26;
  **((_QWORD **)this + 12) = IIOReadPlugin::createImageBlock(this, BaseAddress, v25, v42, *((unsigned int *)this + 75), *((unsigned __int8 *)this + 343));
  if (CGRectEqualToRect(*(CGRect *)((char *)this + 120), *MEMORY[0x1E0C9D628]))
  {
    v35 = 0;
  }
  else
  {
    v43.origin.x = 0.0;
    v43.origin.y = 0.0;
    v43.size.width = v27;
    v43.size.height = v26;
    *(CGRect *)(&v35 - 1) = CGRectUnion(*(CGRect *)((char *)this + 120), v43);
    v34 = v36;
    v27 = v37;
    v26 = v38;
  }
  BlockArray = 0;
  *((_QWORD *)this + 15) = v34;
  *((_QWORD *)this + 16) = v35;
  *((double *)this + 17) = v27;
  *((double *)this + 18) = v26;
  if (v21)
  {
LABEL_50:
    v32 = (const char **)*((_QWORD *)this + 3);
    if (v32)
      IIOImageReadSession::unmapData(v32);
  }
  return BlockArray;
}

void IIOInitDebugFlags()
{
  if (IIOInitDebugFlags::onceToken != -1)
    dispatch_once(&IIOInitDebugFlags::onceToken, &__block_literal_global_19);
}

const char *IIODebug_ShowBacktrace(int a1)
{
  const char *result;
  int v4;
  int v5;
  const void **v6;
  Dl_info v7;
  void *v8[129];

  v8[128] = *(void **)MEMORY[0x1E0C80C00];
  bzero(v8, 0x400uLL);
  memset(&v7, 0, sizeof(v7));
  result = (const char *)backtrace(v8, 128);
  if ((int)result < a1 || a1 < 1)
    v4 = 1;
  else
    v4 = a1;
  if (v4 < (int)result)
  {
    v5 = (int)result;
    v6 = (const void **)&v8[v4];
    do
    {
      if (dladdr(*v6, &v7))
        result = ImageIOLog("%1.*s<%s+%ld>\n");
      else
        result = ImageIOLog("%1.*s%08lx\n");
      ++v4;
      ++v6;
    }
    while (v5 != v4);
  }
  return result;
}

const char *LogSurfaceFormat(__IOSurface *a1, const char *a2, const char *a3, int a4)
{
  signed int PixelFormat;
  unsigned int v7;
  uint64_t v8;
  int v9;
  unsigned int v10;
  int v11;
  unsigned int v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  size_t Width;
  size_t Height;

  PixelFormat = IOSurfaceGetPixelFormat(a1);
  Width = IOSurfaceGetWidth(a1);
  Height = IOSurfaceGetHeight(a1);
  v7 = PixelFormat >> 24;
  v8 = MEMORY[0x1E0C80978];
  if (PixelFormat < 0)
    v9 = __maskrune(PixelFormat >> 24, 0x40000uLL);
  else
    v9 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v7 + 60) & 0x40000;
  v10 = PixelFormat << 8 >> 24;
  if (PixelFormat << 8 < 0)
    v11 = __maskrune(PixelFormat << 8 >> 24, 0x40000uLL);
  else
    v11 = *(_DWORD *)(v8 + 4 * v10 + 60) & 0x40000;
  v12 = (__int16)PixelFormat >> 8;
  if (PixelFormat << 16 < 0)
    v13 = __maskrune((__int16)PixelFormat >> 8, 0x40000uLL);
  else
    v13 = *(_DWORD *)(v8 + 4 * v12 + 60) & 0x40000;
  if ((PixelFormat << 24) <= 0x7F000000)
    v14 = *(_DWORD *)(v8 + 4 * (char)PixelFormat + 60) & 0x40000;
  else
    v14 = __maskrune((char)PixelFormat, 0x40000uLL);
  if (v13)
    v15 = v12;
  else
    v15 = 46;
  if (v11)
    v16 = v10;
  else
    v16 = 46;
  if (v9)
    v17 = v7;
  else
    v17 = 46;
  if (v14)
    v18 = (char)PixelFormat;
  else
    v18 = 46;
  return ImageIOLog("  %s:%d - %s %ldx%ld - '%c%c%c%c'\n", a3, a4, a2, Width, Height, v17, v16, v15, v18);
}

const char *LogPixelFormat(int a1, const char *a2, int a3)
{
  unsigned int v5;
  uint64_t v6;
  int v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v5 = a1 >> 24;
  v6 = MEMORY[0x1E0C80978];
  if (a1 < 0)
    v7 = __maskrune(a1 >> 24, 0x40000uLL);
  else
    v7 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v5 + 60) & 0x40000;
  v8 = a1 << 8 >> 24;
  if (a1 << 8 < 0)
    v9 = __maskrune(a1 << 8 >> 24, 0x40000uLL);
  else
    v9 = *(_DWORD *)(v6 + 4 * v8 + 60) & 0x40000;
  v10 = (__int16)a1 >> 8;
  if (a1 << 16 < 0)
    v11 = __maskrune((__int16)a1 >> 8, 0x40000uLL);
  else
    v11 = *(_DWORD *)(v6 + 4 * v10 + 60) & 0x40000;
  if ((a1 << 24) <= 0x7F000000)
    v12 = *(_DWORD *)(v6 + 4 * (char)a1 + 60) & 0x40000;
  else
    v12 = __maskrune((char)a1, 0x40000uLL);
  if (v11)
    v13 = v10;
  else
    v13 = 46;
  if (v9)
    v14 = v8;
  else
    v14 = 46;
  if (v7)
    v15 = v5;
  else
    v15 = 46;
  if (v12)
    v16 = (char)a1;
  else
    v16 = 46;
  return ImageIOLog("  %s:%d - '%c%c%c%c'\n", a2, a3, v15, v14, v13, v16);
}

void ImageIODebugOptionsDictionary(const __CFDictionary *a1)
{
  if (a1)
  {
    if (CFDictionaryGetCount(a1) < 1)
    {
      ImageIOLog("    options: ()\n");
    }
    else
    {
      ImageIOLog("    options:\n");
      CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)OptionsApplyFunction, 0);
    }
  }
}

void OptionsApplyFunction(const void *a1, const void *a2, uint64_t a3)
{
  uint64_t v5;
  CFTypeID v6;
  const char *v7;
  const char *v8;
  const char *v9;
  CFTypeID v10;
  const char *v11;
  const char *v12;
  float v13;
  CFTypeID v14;
  int Value;
  const char *v16;
  const char *v17;
  const char *v18;
  CFTypeID v19;
  const char *v20;
  const char *v21;
  const char *v22;
  const char *v23;
  unint64_t v24;
  CFTypeID v25;
  const char *v26;
  const char *v27;
  CFTypeID v28;
  CFTypeID TypeID;
  const char *v30;
  const char *v31;
  const char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD v36[3];
  CFRange v37;

  memset(v36, 0, sizeof(v36));
  IIOString::IIOString((IIOString *)v36, a1);
  if (a3 >= 4)
    v5 = 4;
  else
    v5 = a3;
  if (a2)
  {
    v6 = CFGetTypeID(a2);
    if (v6 == CFStringGetTypeID())
    {
      v33 = 0;
      v34 = 0;
      v35 = 0;
      IIOString::IIOString((IIOString *)&v33, a2);
      v7 = (const char *)*((_QWORD *)&gIndents + v5);
      v8 = (const char *)IIOString::utf8String((IIOString *)v36);
      v9 = (const char *)IIOString::utf8String((IIOString *)&v33);
      ImageIOLog("      %s%s: %s\n", v7, v8, v9);
      IIOString::~IIOString((IIOString *)&v33);
    }
    else
    {
      v10 = CFGetTypeID(a2);
      if (v10 == CFNumberGetTypeID())
      {
        v33 = 0;
        v34 = 0;
        v35 = 0;
        if (CFNumberIsFloatType((CFNumberRef)a2))
        {
          IIONumber::IIONumber((IIONumber *)&v33, (const __CFNumber *)a2);
          v11 = (const char *)*((_QWORD *)&gIndents + v5);
          v12 = (const char *)IIOString::utf8String((IIOString *)v36);
          v13 = IIONumber::floatNum((IIONumber *)&v33);
          ImageIOLog("      %s%s: %g\n", v11, v12, v13);
        }
        else
        {
          IIONumber::IIONumber((IIONumber *)&v33, (const __CFNumber *)a2);
          v22 = (const char *)*((_QWORD *)&gIndents + v5);
          v23 = (const char *)IIOString::utf8String((IIOString *)v36);
          v24 = IIONumber::uint64Num((IIONumber *)&v33);
          ImageIOLog("      %s%s: %ld\n", v22, v23, v24);
        }
        IIONumber::~IIONumber((IIONumber *)&v33);
      }
      else
      {
        v14 = CFGetTypeID(a2);
        if (v14 == CFBooleanGetTypeID())
        {
          Value = CFBooleanGetValue((CFBooleanRef)a2);
          v16 = (const char *)*((_QWORD *)&gIndents + v5);
          v17 = (const char *)IIOString::utf8String((IIOString *)v36);
          v18 = "true";
          if (!Value)
            v18 = "false";
          ImageIOLog("      %s%s: %s\n", v16, v17, v18);
        }
        else
        {
          v19 = CFGetTypeID(a2);
          if (v19 == CFArrayGetTypeID())
          {
            v20 = (const char *)*((_QWORD *)&gIndents + v5);
            v21 = (const char *)IIOString::utf8String((IIOString *)v36);
            ImageIOLog("      %s%s\n", v20, v21);
            v37.length = CFArrayGetCount((CFArrayRef)a2);
            v37.location = 0;
            CFArrayApplyFunction((CFArrayRef)a2, v37, (CFArrayApplierFunction)OptionsArrayApplyFunction, (void *)(v5 + 1));
          }
          else
          {
            v25 = CFGetTypeID(a2);
            if (v25 == CFDictionaryGetTypeID())
            {
              v26 = (const char *)*((_QWORD *)&gIndents + v5);
              v27 = (const char *)IIOString::utf8String((IIOString *)v36);
              ImageIOLog("      %s%s\n", v26, v27);
              CFDictionaryApplyFunction((CFDictionaryRef)a2, (CFDictionaryApplierFunction)OptionsApplyFunction, (void *)(v5 + 2));
            }
            else
            {
              v28 = CFGetTypeID(a2);
              TypeID = CFNullGetTypeID();
              v30 = (const char *)*((_QWORD *)&gIndents + v5);
              if (v28 == TypeID)
              {
                v31 = (const char *)IIOString::utf8String((IIOString *)v36);
                ImageIOLog("      %s%s: kCFNull\n", v30, v31);
              }
              else
              {
                v32 = (const char *)IIOString::utf8String((IIOString *)v36);
                ImageIOLog("      %s%s: ", v30, v32);
                CFShow(a2);
              }
            }
          }
        }
      }
    }
  }
  IIOString::~IIOString((IIOString *)v36);
}

void sub_187FE5B64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void ImageIODebugOptions(int a1, const char *a2, const char *a3, CFTypeRef cf, const char *a5, uint64_t a6, const __CFDictionary *a7)
{
  CFStringRef v13;
  CFStringRef v14;
  const char *v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  if (!cf)
  {
    if (a5)
    {
LABEL_7:
      if (a6 < 0)
        ImageIOLog("%s   %s - '%s'\n");
      else
        ImageIOLog("%s   %s[%ld] - '%s'\n");
LABEL_17:
      v14 = 0;
      goto LABEL_20;
    }
LABEL_12:
    if (a6 < 0)
      ImageIOLog("%s   %s\n");
    else
      ImageIOLog("%s   %s[%ld]\n");
    goto LABEL_17;
  }
  v13 = CFCopyDescription(cf);
  v14 = v13;
  if (!a5)
  {
    if (v13)
    {
      v17 = 0;
      v18 = 0;
      v19 = 0;
      IIOString::IIOString((IIOString *)&v17, v13);
      v16 = (const char *)IIOString::utf8String((IIOString *)&v17);
      if (a6 < 0)
        ImageIOLog("%s   %s  %s\n", a2, a3, v16);
      else
        ImageIOLog("%s   %s[%ld]  %s\n", a2, a3, a6, v16);
      goto LABEL_19;
    }
    goto LABEL_12;
  }
  if (!v13)
    goto LABEL_7;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  IIOString::IIOString((IIOString *)&v17, v13);
  v15 = (const char *)IIOString::utf8String((IIOString *)&v17);
  if (a6 < 0)
    ImageIOLog("%s   %s - '%s' - '%s'\n", a2, a3, v15, a5);
  else
    ImageIOLog("%s   %s[%ld] - '%s' - '%s'\n", a2, a3, a6, v15, a5);
LABEL_19:
  IIOString::~IIOString((IIOString *)&v17);
LABEL_20:
  if (a1 >= 2)
    ImageIODebugOptionsDictionary(a7);
  if (v14)
    CFRelease(v14);
}

void sub_187FE5D4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

const char *IIODebugOrientation(const char *result, int a2, IIODictionary *this)
{
  unsigned int Uint32ForKey;
  unsigned int Uint32ForKeyGroup;

  if ((gIIODebugFlags & 0x2000000000000) != 0)
  {
    if (this)
    {
      if (IIODictionary::containsKey(this, CFSTR("Orientation")))
      {
        Uint32ForKey = IIODictionary::getUint32ForKey(this, CFSTR("Orientation"));
        if ((IIODictionary::containsKeyGroup(this, CFSTR("Orientation"), CFSTR("{TIFF}")) & 1) == 0)
        {
          if (Uint32ForKey)
            return ImageIOLog("%s %s:%d - Orientation top: %d\n");
          return ImageIOLog("%s %s:%d - Orientation not found in dictionary\n");
        }
        Uint32ForKeyGroup = IIODictionary::getUint32ForKeyGroup(this, CFSTR("Orientation"), CFSTR("{TIFF}"));
        if (Uint32ForKey)
        {
          if (Uint32ForKeyGroup)
            return ImageIOLog("%s %s:%d - Orientation top+tiff: %d / %d\n");
          return ImageIOLog("%s %s:%d - Orientation top: %d\n");
        }
        goto LABEL_10;
      }
      if (IIODictionary::containsKeyGroup(this, CFSTR("Orientation"), CFSTR("{TIFF}")))
      {
        Uint32ForKeyGroup = IIODictionary::getUint32ForKeyGroup(this, CFSTR("Orientation"), CFSTR("{TIFF}"));
LABEL_10:
        if (Uint32ForKeyGroup)
          return ImageIOLog("%s %s:%d - Orientation tiff: %d\n");
      }
    }
    return ImageIOLog("%s %s:%d - Orientation not found in dictionary\n");
  }
  return result;
}

void OptionsArrayApplyFunction(const void *a1, uint64_t a2)
{
  uint64_t v3;
  CFTypeID v4;
  const char *v5;
  const char *v6;
  CFTypeID v7;
  const char *v8;
  float v9;
  CFTypeID v10;
  int Value;
  const char *v12;
  CFTypeID v13;
  const char *v14;
  unint64_t v15;
  CFTypeID v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  CFRange v20;

  if (a2 >= 4)
    v3 = 4;
  else
    v3 = a2;
  v4 = CFGetTypeID(a1);
  if (v4 == CFStringGetTypeID())
  {
    v17 = 0;
    v18 = 0;
    v19 = 0;
    IIOString::IIOString((IIOString *)&v17, a1);
    v5 = (const char *)*((_QWORD *)&gIndents + v3);
    v6 = (const char *)IIOString::utf8String((IIOString *)&v17);
    ImageIOLog("      %s %s\n", v5, v6);
    IIOString::~IIOString((IIOString *)&v17);
  }
  else
  {
    v7 = CFGetTypeID(a1);
    if (v7 == CFNumberGetTypeID())
    {
      v17 = 0;
      v18 = 0;
      v19 = 0;
      if (CFNumberIsFloatType((CFNumberRef)a1))
      {
        IIONumber::IIONumber((IIONumber *)&v17, (const __CFNumber *)a1);
        v8 = (const char *)*((_QWORD *)&gIndents + v3);
        v9 = IIONumber::floatNum((IIONumber *)&v17);
        ImageIOLog("      %s %g\n", v8, v9);
      }
      else
      {
        IIONumber::IIONumber((IIONumber *)&v17, (const __CFNumber *)a1);
        v14 = (const char *)*((_QWORD *)&gIndents + v3);
        v15 = IIONumber::uint64Num((IIONumber *)&v17);
        ImageIOLog("      %s %ld\n", v14, v15);
      }
      IIONumber::~IIONumber((IIONumber *)&v17);
    }
    else
    {
      v10 = CFGetTypeID(a1);
      if (v10 == CFBooleanGetTypeID())
      {
        Value = CFBooleanGetValue((CFBooleanRef)a1);
        v12 = "true";
        if (!Value)
          v12 = "false";
        ImageIOLog("      %s %s\n", *((const char **)&gIndents + v3), v12);
      }
      else
      {
        v13 = CFGetTypeID(a1);
        if (v13 == CFArrayGetTypeID())
        {
          ImageIOLog("      %s\n", *((const char **)&gIndents + v3));
          v20.length = CFArrayGetCount((CFArrayRef)a1);
          v20.location = 0;
          CFArrayApplyFunction((CFArrayRef)a1, v20, (CFArrayApplierFunction)OptionsArrayApplyFunction, (void *)(v3 + 1));
        }
        else
        {
          v16 = CFGetTypeID(a1);
          if (v16 == CFDictionaryGetTypeID())
            CFDictionaryApplyFunction((CFDictionaryRef)a1, (CFDictionaryApplierFunction)OptionsApplyFunction, (void *)(v3 + 1));
          else
            CFShow(a1);
        }
      }
    }
  }
}

void sub_187FE610C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

void flush_fn(uint64_t a1)
{
  const void *io_ptr;

  io_ptr = (const void *)_cg_png_get_io_ptr(a1);
  CFRelease(io_ptr);
}

void handle_write_error(uint64_t a1, const char *a2)
{
  _DWORD *exception;

  if (a2)
  {
    if (*a2)
      LogError("handle_write_error", 113, "%s\n", a2);
  }
  exception = __cxa_allocate_exception(4uLL);
  *exception = -1;
  __cxa_throw(exception, MEMORY[0x1E0DE4EF0], 0);
}

void PNGWritePlugin::reduceFrame(PNGWritePlugin *this, unsigned __int8 *a2, unsigned __int8 *a3, unsigned __int8 *a4, int a5, unsigned int *a6, unsigned int *a7, unsigned int *a8, unsigned int *a9)
{
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int *v36;
  unsigned int *v37;
  unsigned int v38;
  unsigned int v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  unsigned int v47;
  unsigned int v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  unsigned int v53;
  unsigned int v54;
  int v55;

  v13 = *a8;
  v14 = v13 - 1;
  v15 = *a9;
  v16 = *a9 - 1;
  if (v13 >= 2)
    v17 = 2;
  else
    v17 = v13;
  if (v15 >= 2)
    v18 = 2;
  else
    v18 = *a9;
  if (a5 == 4)
  {
    v36 = a7;
    v37 = a6;
    v54 = v13;
    v55 = v18;
    v53 = v17;
    v38 = *a9;
    bzero(a4, *((_QWORD *)this + 8));
    v15 = v38;
    v17 = v53;
    v13 = v54;
    v18 = v55;
    a6 = v37;
    a7 = v36;
    v39 = *a9;
    if (!*a9)
    {
LABEL_57:
      *a6 = v13 >> 1;
      *a7 = v15 >> 1;
      *a8 = v17;
      goto LABEL_58;
    }
    v19 = 0;
    v40 = 0;
    v21 = 0;
    v22 = 0;
    v41 = *a8;
    do
    {
      if (v41)
      {
        v42 = 0;
        do
        {
          v44 = *(_DWORD *)a2;
          a2 += 4;
          v43 = v44;
          v46 = *(_DWORD *)a3;
          a3 += 4;
          v45 = v46;
          v47 = v46 | v43;
          if (v42 >= v14)
            v48 = v14;
          else
            v48 = v42;
          if (v42 <= v22)
            v49 = v22;
          else
            v49 = v42;
          if (v40 >= v16)
            v50 = v16;
          else
            v50 = v40;
          if (v40 <= v21)
            v51 = v21;
          else
            v51 = v40;
          if (v43 != v45 && HIBYTE(v47) != 0)
          {
            v14 = v48;
            v16 = v50;
            v22 = v49;
            v21 = v51;
            ++v19;
          }
          *(_DWORD *)a4 = v43;
          a4 += 4;
          ++v42;
          v41 = *a8;
        }
        while (v42 < *a8);
        v39 = *a9;
      }
      ++v40;
    }
    while (v40 < v39);
  }
  else
  {
    if (a5 != 3 || !v15)
      goto LABEL_57;
    v19 = 0;
    v20 = 0;
    v21 = 0;
    v22 = 0;
    v23 = *a9;
    v24 = v13;
    do
    {
      if (v24)
      {
        v25 = 0;
        do
        {
          v26 = (a2[2] << 16) | (a2[1] << 8);
          v27 = *a2;
          a2 += 3;
          v28 = v26 | v27;
          v29 = (a3[2] << 16) | (a3[1] << 8);
          v30 = *a3;
          a3 += 3;
          v31 = v29 | v30;
          if (v25 >= v14)
            v32 = v14;
          else
            v32 = v25;
          if (v25 <= v22)
            v33 = v22;
          else
            v33 = v25;
          if (v20 >= v16)
            v34 = v16;
          else
            v34 = v20;
          if (v20 <= v21)
            v35 = v21;
          else
            v35 = v20;
          if (v28 != v31)
          {
            v14 = v32;
            v16 = v34;
            v22 = v33;
            v21 = v35;
            ++v19;
          }
          *(_WORD *)a4 = v31;
          a4[2] = BYTE2(v31);
          a4 += 3;
          ++v25;
          v24 = *a8;
        }
        while (v25 < *a8);
        v23 = *a9;
      }
      ++v20;
    }
    while (v20 < v23);
  }
  if (!v19)
    goto LABEL_57;
  *a6 = v14;
  *a7 = v16;
  *a8 = v22 - v14 + 1;
  v18 = v21 - v16 + 1;
LABEL_58:
  *a9 = v18;
}

uint64_t PNGWritePlugin::writeAPNGFrame(PNGWritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3)
{
  uint64_t Ref;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t Property;
  BOOL v11;
  uint8_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const __CFString *v16;
  double DoubleForKeyGroup;
  unsigned int v18;
  uint64_t Bytes;
  CGColorSpace *ColorSpace;
  CGColorSpace *BaseColorSpace;
  size_t NumberOfComponents;
  unsigned int ColorTableCount;
  uint64_t j;
  unsigned __int8 *v25;
  unsigned int v26;
  unsigned __int8 *v27;
  int v28;
  uint8_t *v29;
  size_t v30;
  size_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t v36;
  unsigned __int8 *v37;
  uint64_t v38;
  uint64_t v39;
  unsigned __int8 *v40;
  unsigned __int8 *v41;
  uint64_t v42;
  unsigned __int8 *v43;
  unsigned int v44;
  unint64_t v45;
  char *v46;
  uint64_t v47;
  unsigned __int8 *v48;
  uint64_t v49;
  char v50;
  char *v51;
  uint64_t v52;
  uint64_t v54;
  unint64_t v55;
  unint64_t i;
  CGImage *image;
  int v58;
  char v59;
  unsigned int v60;
  size_t size;
  unint64_t v62;
  _OWORD v63[5];
  unsigned int v64;
  unsigned int v65;
  unsigned int v66[2];
  unsigned __int8 *v67;
  char *v68;

  v68 = 0;
  v67 = 0;
  Ref = IIOImageSource::imageReadRef(a2);
  CGImageGetImageProvider();
  v7 = IIOImageSource::count(a2);
  v8 = IIO_Reader::testHeaderSize(a2);
  v9 = IIOImagePlus::sourceImageProvider(a2);
  Property = CGImageProviderGetProperty();
  if (Property)
    v11 = Property == *MEMORY[0x1E0C9AE50];
  else
    v11 = 0;
  image = (CGImage *)Ref;
  if (!v11)
    goto LABEL_5;
  LODWORD(v12) = *((_BYTE *)this + 124) == 0;
  v13 = v9;
  if (*((_BYTE *)this + 124))
  {
LABEL_9:
    *((_BYTE *)this + 123) = 0;
    goto LABEL_10;
  }
  if (v9 == v7)
  {
    v13 = 3 * v7;
    goto LABEL_9;
  }
LABEL_5:
  LODWORD(v12) = 0;
  v13 = v9;
LABEL_10:
  v14 = v8;
  v15 = v9 * v8;
  if (IIOImagePixelDataProvider::hasAlpha(a2)
    || *((_BYTE *)this + 121)
    || (IIOImagePixelDataProvider::srcFormat(a2, (uint64_t)v63), DWORD1(v63[0]) != 24))
  {
    v58 = 0;
    v62 = v9 * v8;
  }
  else
  {
    _cg_png_set_appleflags((uint64_t)a2, 32);
    v9 = 4 * v7;
    v62 = v8 * (unint64_t)v9;
    v58 = 1;
  }
  size = v13 * v8;
  if (*((_BYTE *)this + 37))
  {
    ImageIOLog("            bufferSize:  %d\n", v62);
    ImageIOLog("           dstRowbytes:  %d\n", v13);
    ImageIOLog("              rowbytes:  %d\n", v9);
    ImageIOLog("    expandIndexedToRGB:  %d\n", (_DWORD)v12);
    ImageIOLog("        expandRGB2RGBA:  %d\n", v58);
    ImageIOLog("      _optimizeForSize:  %d\n", *((unsigned __int8 *)this + 123));
  }
  v59 = (char)v12;
  v60 = v8;
  if (*((_DWORD *)this + 18) >= 2u && !*((_QWORD *)this + 7))
  {
    *((_QWORD *)this + 8) = size;
    *((_QWORD *)this + 7) = malloc_type_malloc(size, 0x3D51C1E4uLL);
  }
  v68 = (char *)malloc_type_malloc(v62, 0xC35AAFBFuLL);
  v67 = (unsigned __int8 *)malloc_type_malloc(size, 0x64351943uLL);
  v16 = CFSTR("UnclampedDelayTime");
  if ((IIODictionary::containsKeyGroup(a3, CFSTR("UnclampedDelayTime"), CFSTR("{PNG}")) & 1) != 0
    || (v16 = CFSTR("DelayTime"), IIODictionary::containsKeyGroup(a3, CFSTR("DelayTime"), CFSTR("{PNG}"))))
  {
    DoubleForKeyGroup = IIODictionary::getDoubleForKeyGroup(a3, v16, CFSTR("{PNG}"));
  }
  else
  {
    DoubleForKeyGroup = 0.1;
  }
  *(_QWORD *)v66 = 0;
  v18 = v60;
  v64 = v60;
  v65 = v7;
  Bytes = IIOImagePixelDataProvider::getBytes((uint64_t (**)(IIOImagePixelDataProvider *, void *))a2, v68);
  if (Bytes != v15)
  {
    _cg_jpeg_mem_term("writeAPNGFrame", 1319, "    iPixelDataProvider->getBytes - expected: %d  got: %d\n", v15, Bytes);
    v52 = 0;
    goto LABEL_60;
  }
  if (v58)
  {
    memset(v63, 0, sizeof(v63));
    IIOPixelConverterRGB::IIOPixelConverterRGB((uint64_t)v63, 0, 3, 8u, 8, 8, 0, 2, 8u, 0, 0);
    malloc_type_malloc(4 * v7, 0xC98582C2uLL);
    v54 = 3 * v7;
    v55 = 4 * (v7 & 0x3FFFFFFF) * (unint64_t)(v60 - 1);
    for (i = v54 * (unint64_t)(v60 - 1); ; i -= v54)
    {
      IIOPixelConverterRGB::convertRow((IIOPixelConverterRGB *)v63, (unsigned __int8 *)&v68[i], (unsigned __int8 *)&v68[v55], v7);
      v55 -= 4 * v7;
    }
  }
  if ((_DWORD)v12)
  {
    ColorSpace = CGImageGetColorSpace(image);
    BaseColorSpace = CGColorSpaceGetBaseColorSpace(ColorSpace);
    NumberOfComponents = CGColorSpaceGetNumberOfComponents(BaseColorSpace);
    ColorTableCount = CGColorSpaceGetColorTableCount(ColorSpace);
    v12 = (uint8_t *)malloc_type_calloc(NumberOfComponents, ColorTableCount, 0x188E4B86uLL);
    CGColorSpaceGetColorTable(ColorSpace, v12);
    if (v14)
    {
      for (j = 0; j != v14; ++j)
      {
        if (v7)
        {
          v25 = &v67[j * v13];
          v26 = v7;
          v27 = (unsigned __int8 *)&v68[j * v9];
          do
          {
            v28 = *v27++;
            v29 = &v12[3 * v28];
            *v25 = *v29;
            v25[1] = v29[1];
            v25[2] = v29[2];
            v25 += 3;
            --v26;
          }
          while (v26);
        }
      }
    }
    free(v12);
    v18 = v60;
    LOBYTE(v12) = v59;
  }
  if (*((_DWORD *)this + 19) && *((_BYTE *)this + 123) && !*((_BYTE *)this + 124))
  {
    PNGWritePlugin::reduceFrame(this, (unsigned __int8 *)v68, *((unsigned __int8 **)this + 7), v67, 4, &v66[1], v66, &v65, &v64);
    if (*((_BYTE *)this + 37))
    {
      ImageIOLog("            orig-frame:  {%6d, %6d, %6d, %6d}\n", 0, 0, v7, v18);
      ImageIOLog("         reduced-frame:  {%6d, %6d, %6d, %6d}\n", v66[1], v66[0], v65, v64);
    }
    if ((v12 & 1) != 0)
      goto LABEL_46;
    goto LABEL_42;
  }
  if ((v12 & 1) == 0)
  {
    if (v62 >= size)
      v30 = v13 * v14;
    else
      v30 = v62;
    memcpy(v67, v68, v30);
LABEL_42:
    if (v62 >= *((_QWORD *)this + 8))
      v31 = *((_QWORD *)this + 8);
    else
      v31 = v62;
    memcpy(*((void **)this + 7), v68, v31);
  }
LABEL_46:
  v32 = v64;
  v33 = v66[0];
  v34 = v66[1];
  _cg_png_write_frame_head(*((_QWORD *)this + 5), *((unsigned __int8 **)this + 6), 0, v65, v64, v66[1], v66[0], (int)(DoubleForKeyGroup * 1000.0), 0x3E8u, 0, 0);
  if ((_DWORD)v32)
  {
    v35 = 0;
    v36 = 4 * v34 + v13 * v33;
    v37 = &v67[v36];
    v38 = v7;
    v39 = 4 * v7;
    v40 = &v67[2 * v7 - 1 + v36];
    v41 = &v67[v36 - 1 + v7];
    do
    {
      if (*((_BYTE *)this + 122))
      {
        if (*((_BYTE *)this + 84) == 4)
        {
          if (v38)
          {
            v42 = 0;
            v43 = v41;
            do
            {
              v44 = *v43--;
              v45 = 3 * ((unint64_t)v44 >> 4);
              v46 = (char *)&v37[v39 + v42];
              *(v46 - 4) = *(_BYTE *)(*((_QWORD *)this + 14) + v45);
              *(v46 - 3) = *(_BYTE *)(v45 + *((_QWORD *)this + 14) + 1);
              *(v46 - 2) = *(_BYTE *)(v45 + *((_QWORD *)this + 14) + 2);
              *(v46 - 1) = v44 & 0xF | (16 * v44);
              v42 -= 4;
            }
            while (v39 + v42);
          }
        }
        else if (v38)
        {
          v47 = 0;
          v48 = v40;
          do
          {
            v49 = *(v48 - 1);
            v50 = *v48;
            v48 -= 2;
            v49 *= 3;
            v51 = (char *)&v37[v39 + v47];
            *(v51 - 4) = *(_BYTE *)(*((_QWORD *)this + 14) + v49);
            *(v51 - 3) = *(_BYTE *)(v49 + *((_QWORD *)this + 14) + 1);
            *(v51 - 2) = *(_BYTE *)(v49 + *((_QWORD *)this + 14) + 2);
            *(v51 - 1) = v50;
            v47 -= 4;
          }
          while (v39 + v47);
        }
      }
      _cg_png_write_row_sized(*((_QWORD *)this + 5), v37);
      ++v35;
      v37 += v13;
      v40 += v13;
      v41 += v13;
    }
    while (v35 != v32);
  }
  _cg_png_write_frame_tail(*((_QWORD *)this + 5));
  v52 = 1;
LABEL_60:
  if (v67)
    free(v67);
  if (v68)
    free(v68);
  return v52;
}

void sub_187FE6AC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  IIOPixelConverterRGB::~IIOPixelConverterRGB((IIOPixelConverterRGB *)va);
  _Unwind_Resume(a1);
}

uint64_t PNGWritePlugin::writeOneImage(PNGWritePlugin *this, CGImage *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

uint64_t imagePNG_write_error_break(uint64_t a1)
{
  uint64_t result;

  LogError("imagePNG_write_error_break", 90, "*** ERROR: imagePNG_write_error_break\n");
  *gCrashMessage = 0;
  result = snprintf(gCrashMessage, 0x200uLL, "*** ERROR: PNG-writeAll  %dx%d  bpc: %d  cs: %d", *(_DWORD *)(a1 + 280), *(_DWORD *)(a1 + 284), *(unsigned __int8 *)(a1 + 392), *(unsigned __int8 *)(a1 + 391));
  qword_1ECDD8318 = gCrashMessage;
  return result;
}

uint64_t PNGWritePlugin::WriteImageWithSession(PNGWritePlugin *this, IIOImageWriteSession *a2, IIOImageDestination *a3, IIOImagePixelDataProvider *a4, IIODictionary *a5, IIODictionary *a6)
{
  uint64_t v8;
  IIOImagePixelDataProvider *v9;
  IIODictionary *v10;
  uint64_t v11;
  const char *v12;
  _OWORD v14[2];
  __int128 v15;
  __int128 v16;
  _OWORD v17[2];
  __int128 v18;
  __int128 v19;

  v18 = 0u;
  v19 = 0u;
  memset(v17, 0, sizeof(v17));
  v15 = 0u;
  v16 = 0u;
  memset(v14, 0, sizeof(v14));
  IIOWritePlugin::IIOWritePlugin((IIOWritePlugin *)v14, this, a2, 0x15u);
  DWORD2(v17[0]) = 1;
  *(_QWORD *)&v17[0] = 0;
  *(_QWORD *)((char *)v17 + 12) = 0;
  BYTE4(v17[1]) = 0;
  *(_DWORD *)((char *)&v19 + 9) = 1;
  *((_QWORD *)&v15 + 1) = 0;
  v16 = 0uLL;
  *(_QWORD *)&v14[0] = &off_1E1BAFBE8;
  *((_QWORD *)&v18 + 1) = 0;
  *(_QWORD *)&v19 = 0;
  PNGWritePlugin::writePrologue((PNGWritePlugin *)v14, a3, a4);
  v8 = PNGWritePlugin::writePNG((PNGWritePlugin *)v14, a3, a4);
  PNGWritePlugin::writeEpilogue((PNGWritePlugin *)v14, v9, v10);
  PNGWritePlugin::~PNGWritePlugin((PNGWritePlugin *)v14, v11, v12);
  return v8;
}

void sub_187FE6C60(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187FE6C48);
}

uint64_t PNGWritePlugin::writeOne(PNGWritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967292;
}

uint64_t _TIFFNoRowEncode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  TIFFNoEncode(a1, (uint64_t)"scanline", a3, a4, a5, a6, a7, a8);
  return 0xFFFFFFFFLL;
}

uint64_t TIFFNoEncode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t *v9;
  uint64_t v10;
  const char *v11;
  __int16 *i;
  int v13;

  v8 = *(unsigned __int16 *)(a1 + 120);
  v9 = &registeredCODECS;
  while (1)
  {
    v9 = (uint64_t *)*v9;
    if (!v9)
      break;
    v10 = v9[1];
    if (*(unsigned __int16 *)(v10 + 8) == v8)
    {
      v11 = *(const char **)v10;
      return TIFFErrorExtR(a1, *(const char **)a1, "%s %s encoding is not implemented", a4, a5, a6, a7, a8, (char)v11);
    }
  }
  v11 = "None";
  if ("None")
  {
    if (v8 == 1)
      return TIFFErrorExtR(a1, *(const char **)a1, "%s %s encoding is not implemented", a4, a5, a6, a7, a8, (char)v11);
    for (i = &word_1E1B81998; ; i += 12)
    {
      v11 = (const char *)*((_QWORD *)i - 1);
      if (!v11)
        break;
      v13 = (unsigned __int16)*i;
      if (v13 == v8)
        return TIFFErrorExtR(a1, *(const char **)a1, "%s %s encoding is not implemented", a4, a5, a6, a7, a8, (char)v11);
    }
  }
  return TIFFErrorExtR(a1, *(const char **)a1, "Compression scheme %hu %s encoding is not implemented", a4, a5, a6, a7, a8, *(_WORD *)(a1 + 120));
}

uint64_t _TIFFNoStripEncode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  TIFFNoEncode(a1, (uint64_t)"strip", a3, a4, a5, a6, a7, a8);
  return 0xFFFFFFFFLL;
}

uint64_t _TIFFNoTileEncode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  TIFFNoEncode(a1, (uint64_t)"tile", a3, a4, a5, a6, a7, a8);
  return 0xFFFFFFFFLL;
}

uint64_t _TIFFNoRowDecode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  TIFFNoDecode(a1, (uint64_t)"scanline", a3, a4, a5, a6, a7, a8);
  return 0;
}

uint64_t TIFFNoDecode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t *v9;
  uint64_t v10;
  const char *v11;
  __int16 *i;
  int v13;

  v8 = *(unsigned __int16 *)(a1 + 120);
  v9 = &registeredCODECS;
  while (1)
  {
    v9 = (uint64_t *)*v9;
    if (!v9)
      break;
    v10 = v9[1];
    if (*(unsigned __int16 *)(v10 + 8) == v8)
    {
      v11 = *(const char **)v10;
      return TIFFErrorExtR(a1, *(const char **)a1, "%s %s decoding is not implemented", a4, a5, a6, a7, a8, (char)v11);
    }
  }
  v11 = "None";
  if ("None")
  {
    if (v8 == 1)
      return TIFFErrorExtR(a1, *(const char **)a1, "%s %s decoding is not implemented", a4, a5, a6, a7, a8, (char)v11);
    for (i = &word_1E1B81998; ; i += 12)
    {
      v11 = (const char *)*((_QWORD *)i - 1);
      if (!v11)
        break;
      v13 = (unsigned __int16)*i;
      if (v13 == v8)
        return TIFFErrorExtR(a1, *(const char **)a1, "%s %s decoding is not implemented", a4, a5, a6, a7, a8, (char)v11);
    }
  }
  return TIFFErrorExtR(a1, *(const char **)a1, "Compression scheme %hu %s decoding is not implemented", a4, a5, a6, a7, a8, *(_WORD *)(a1 + 120));
}

uint64_t _TIFFNoStripDecode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  TIFFNoDecode(a1, (uint64_t)"strip", a3, a4, a5, a6, a7, a8);
  return 0;
}

uint64_t _TIFFNoTileDecode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  TIFFNoDecode(a1, (uint64_t)"tile", a3, a4, a5, a6, a7, a8);
  return 0;
}

uint64_t _TIFFNoSeek(const char **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  TIFFErrorExtR((uint64_t)a1, *a1, "Compression algorithm does not support random access", a4, a5, a6, a7, a8, vars0);
  return 0;
}

uint64_t _TIFFNoFixupTags()
{
  return 1;
}

const char *_cg_TIFFFindCODEC(int a1)
{
  uint64_t *v1;
  const char *i;

  v1 = &registeredCODECS;
  while (1)
  {
    v1 = (uint64_t *)*v1;
    if (!v1)
      break;
    i = (const char *)v1[1];
    if (*((unsigned __int16 *)i + 4) == a1)
      return i;
  }
  i = "None";
  if ("None")
  {
    for (i = (const char *)&_TIFFBuiltinCODECS; *((unsigned __int16 *)i + 4) != a1; i += 24)
    {
      if (!*((_QWORD *)i + 3))
        return 0;
    }
  }
  return i;
}

uint64_t IIOSavePermissionsToXPCObject(void *a1)
{
  xpc_object_t v1;

  if (gPermissionsChanged == 1)
  {
    v1 = iio_xpc_add_permission_dict(a1);
    if (v1)
      xpc_dictionary_set_uint64(v1, "iio_xpc_permission_data", gPermissions);
  }
  return 0;
}

uint64_t IIOSaveAllowedTypesToXPCObject(void *a1)
{
  xpc_object_t v1;

  if (gAllowedTypesChanged == 1)
  {
    v1 = iio_xpc_add_permission_dict(a1);
    if (v1)
      iio_xpc_dictionary_add_CFDictionary(v1, "iio_xpc_permission_allowed_types_array");
  }
  return 0;
}

uint64_t IIOXPCUpdatePermissions(void *a1)
{
  xpc_object_t permission_dict;
  int uint64;
  int v3;
  uint64_t v4;
  char v6;
  uint64_t v7;

  permission_dict = iio_xpc_get_permission_dict(a1);
  if (!permission_dict)
    return 0;
  uint64 = xpc_dictionary_get_uint64(permission_dict, "iio_xpc_permission_data");
  v3 = uint64;
  if ((uint64 & 1) == 0)
    return 0;
  v6 = gPermissions ^ uint64;
  if (((gPermissions ^ uint64) & 2) != 0)
  {
    v4 = IIODisableRAWDecoding();
    IIOXPCLog(" RAWDecoding disabled\n");
    v6 = gPermissions ^ v3;
    if (((gPermissions ^ v3) & 4) == 0)
      goto LABEL_10;
    goto LABEL_9;
  }
  v4 = 0;
  if (((gPermissions ^ uint64) & 4) != 0)
  {
LABEL_9:
    v4 = IIODisableMetadataParsing();
    IIOXPCLog(" MetadataParsing disabled\n");
    v6 = gPermissions ^ v3;
  }
LABEL_10:
  if ((v6 & 8) == 0)
  {
    if ((v6 & 0x10) == 0)
      goto LABEL_12;
LABEL_15:
    v4 = IIOEnableRestrictedDecoding();
    IIOXPCLog(" RestrictedDecoding enabled\n");
    if (((gPermissions ^ v3) & 0x20) == 0)
      return v4;
    goto LABEL_16;
  }
  v4 = IIODisableHardwareDecoding();
  IIOXPCLog(" HardwareDecoding disabled\n");
  v6 = gPermissions ^ v3;
  if (((gPermissions ^ v3) & 0x10) != 0)
    goto LABEL_15;
LABEL_12:
  if ((v6 & 0x20) == 0)
    return v4;
LABEL_16:
  v7 = IIODisableCaching();
  IIOXPCLog(" caching disabled\n");
  return v7;
}

uint64_t IIODisableRAWDecoding()
{
  uint64_t v0;
  _QWORD block[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  int v6;

  kdebug_trace();
  v3 = 0;
  v4 = &v3;
  v5 = 0x2000000000;
  v6 = -50;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __IIODisableRAWDecoding_block_invoke;
  block[3] = &unk_1E1BC4C88;
  block[4] = &v3;
  if (IIODisableRAWDecoding::onceToken != -1)
    dispatch_once(&IIODisableRAWDecoding::onceToken, block);
  v0 = *((unsigned int *)v4 + 6);
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t IIODisableMetadataParsing()
{
  uint64_t v0;
  _QWORD block[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  int v6;

  kdebug_trace();
  v3 = 0;
  v4 = &v3;
  v5 = 0x2000000000;
  v6 = -50;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __IIODisableMetadataParsing_block_invoke;
  block[3] = &unk_1E1BC4CB0;
  block[4] = &v3;
  if (IIODisableMetadataParsing::onceToken != -1)
    dispatch_once(&IIODisableMetadataParsing::onceToken, block);
  v0 = *((unsigned int *)v4 + 6);
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t IIODisableCaching()
{
  uint64_t v0;
  _QWORD block[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  int v6;

  kdebug_trace();
  v3 = 0;
  v4 = &v3;
  v5 = 0x2000000000;
  v6 = -50;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __IIODisableCaching_block_invoke;
  block[3] = &unk_1E1BC4D28;
  block[4] = &v3;
  if (IIODisableCaching::onceToken != -1)
    dispatch_once(&IIODisableCaching::onceToken, block);
  v0 = *((unsigned int *)v4 + 6);
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t IIOXPCUpdateAllowableTypes(void *a1)
{
  xpc_object_t permission_dict;
  const void *v2;
  const void *v3;
  uint64_t v4;

  if ((gAllowedTypesChanged & 1) != 0)
    return 0;
  permission_dict = iio_xpc_get_permission_dict(a1);
  if (!permission_dict)
    return 0;
  if (!xpc_dictionary_get_array(permission_dict, "iio_xpc_permission_allowed_types_array"))
    return 0;
  v2 = (const void *)_CFXPCCreateCFObjectFromXPCObject();
  if (!v2)
    return 0;
  v3 = v2;
  v4 = IIODecodingSetAllowableTypes(v2);
  IIOXPCLog(" AllowableTypes updated\n");
  CFRelease(v3);
  return v4;
}

BOOL onlyspaces(unsigned __int8 *a1)
{
  int v1;
  int v2;

  do
  {
    v2 = *a1++;
    v1 = v2;
  }
  while (v2 == 32);
  return v1 == 0;
}

uint64_t stringType(unsigned __int8 *a1, int a2)
{
  char v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  char v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  unsigned int v11;

  v2 = 0;
  if (!a2)
    return v2 & 1;
  while (1)
  {
    v3 = a2--;
    while (((char)*a1 & 0x80000000) == 0)
    {
      ++a1;
      --a2;
      if (!--v3)
        return v2 & 1;
    }
    v4 = *a1;
    if ((v4 + 2) < 0xC2u)
      break;
    v5 = 0;
    do
    {
      v6 = v5;
      v7 = v5++ + 2;
      --a2;
    }
    while (((v4 << v7) & 0x80) != 0);
    if (v3 < (int)v5 + 1)
      break;
    v8 = 0;
    v9 = v4 & ~(-1 << (6 - v5));
    v10 = v6 + 1;
    do
    {
      v11 = a1[++v8] & 0x3F | (v9 << 6);
      v9 = v11;
    }
    while (v10 != v8);
    if (HIWORD(v11) > 0x10u || v11 < stringType::vmin[v5 + 1])
      break;
    a1 += v5 + 1;
    v2 = 1;
    if (!a2)
      return v2 & 1;
  }
  return 2;
}

uint64_t IIO_Reader_HEIF::createReadPlugin(IIO_Reader *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;

  v4 = operator new();
  v5 = IIO_Reader::osType(a1);
  HEIFReadPlugin::HEIFReadPlugin(v4, a2, v5);
  return v4;
}

void sub_187FE7600(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40DBAD00F1);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_HEIF::createReadPlugin(CFStringRef **a1, uint64_t a2, int a3, uint64_t a4)
{
  CFComparisonResult v8;
  uint64_t v9;
  int v10;

  v8 = CFStringCompare(*a1[1], CFSTR("public.jpeg"), 0);
  v9 = operator new();
  v10 = IIO_Reader::osType((IIO_Reader *)a1);
  HEIFReadPlugin::HEIFReadPlugin(v9, a2, a3, a4, 0, v8 == kCFCompareEqualTo, v10);
  return v9;
}

void sub_187FE76C8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40DBAD00F1);
  _Unwind_Resume(a1);
}

IIOImageRead *IIO_Reader_HEIF::createGlobalInfoData(IIO_Reader_HEIF *this, IIOImageReadSession *a2)
{
  IIOImageRead *result;

  result = IIOImageReadSession::globalInfoForType(a2, 1212500294);
  if (result)
    return (IIOImageRead *)GlobalHEIFInfo::createDataRepresentation(result);
  return result;
}

uint64_t IIO_Reader_HEIF::updateGlobalInfo(IIO_Reader_HEIF *this, IIOImageRead **a2, unsigned __int8 *a3, unint64_t a4)
{
  GlobalHEIFInfo *v7;

  v7 = (GlobalHEIFInfo *)operator new();
  GlobalHEIFInfo::GlobalHEIFInfo(v7, a3, a4);
  IIOImageReadSession::setGlobalInfo(a2, 1212500294, v7, (void (*)(void *))globalHEIFInfoReleaseProc);
  return 0;
}

void sub_187FE778C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40D222D63DLL);
  _Unwind_Resume(a1);
}

BOOL IIO_Reader_HEIF::addBasicProperties(IIO_Reader_HEIF *this, unsigned __int8 *a2, unsigned int a3, __CFDictionary *a4, unsigned int *a5, const __CFData **a6)
{
  int v11;
  int v12;
  const char *v13;
  _BOOL8 v14;
  CFDataRef v15;
  CFDataRef v16;
  int v17;
  int v18;
  const char *v19;
  int v20;
  int v21;
  const char *v22;
  const __CFDictionary *ObjectForKey;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *ObjectForKeyGroup;
  const __CFDictionary *v26;
  const __CFDictionary *v27;
  const __CFDictionary *v28;
  const __CFDictionary *v29;
  const __CFDictionary *v30;
  int Uint32ForKey;
  unsigned int v33;
  _QWORD v34[2];
  void *value;
  _QWORD v36[3];
  _QWORD v37[3];
  _QWORD v38[3];
  const __CFDictionary *v39;
  int v40;
  CFTypeRef v41;
  CFTypeRef v42;

  v42 = 0;
  IIO_LoadHEIFSymbols();
  v11 = IIOCreateCMPhotoDecompressionSession((uint64_t)&v42);
  if (v11)
  {
    v12 = v11;
    v13 = IIOCMErrorString(v11);
    _cg_jpeg_mem_term("addBasicProperties", 361, "*** CMPhotoDecompressionSessionCreate  err = %s [%d]\n", v13, v12);
    return 0;
  }
  else
  {
    v41 = 0;
    v40 = 0;
    v15 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, a3, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
    if (v15)
    {
      v16 = v15;
      v17 = gFunc_CMPhotoDecompressionSessionCreateContainer(v42, 0, v15, &v40, &v41);
      if (v17)
      {
        v18 = v17;
        v19 = IIOCMErrorString(v17);
        _cg_jpeg_mem_term("addBasicProperties", 376, "*** CMPhotoDecompressionSessionCreateContainer  err = %s [%d]\n", v19, v18);
        v14 = 0;
      }
      else
      {
        v39 = 0;
        v20 = gFunc_CMPhotoDecompressionContainerCreateDictionaryDescription(v41, &v39);
        v14 = v20 == 0;
        if (v20)
        {
          v21 = v20;
          v22 = IIOCMErrorString(v20);
          _cg_jpeg_mem_term("addBasicProperties", 386, "*** CMPhotoDecompressionContainerCreateDictionaryDescription  err = %s [%d]\n", v22, v21);
        }
        else
        {
          memset(v38, 0, sizeof(v38));
          IIODictionary::IIODictionary((IIODictionary *)v38, a4);
          IIODictionary::IIODictionary((IIODictionary *)v37, v39);
          ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v37, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_MainImages);
          IIODictionary::~IIODictionary((IIODictionary *)v37);
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(ObjectForKey, 0);
          memset(v37, 0, sizeof(v37));
          IIODictionary::IIODictionary((IIODictionary *)v37, ValueAtIndex);
          ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup((IIODictionary *)v37, CFSTR("Width"), *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_Dimensions);
          IIODictionary::setObjectForKey((IIODictionary *)v38, ObjectForKeyGroup, CFSTR("PixelXDimension"));
          v26 = IIODictionary::getObjectForKeyGroup((IIODictionary *)v37, CFSTR("Height"), *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_Dimensions);
          IIODictionary::setObjectForKey((IIODictionary *)v38, v26, CFSTR("PixelYDimension"));
          v27 = IIODictionary::getObjectForKey((IIODictionary *)v37, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_ThumbnailImages);
          v28 = (const __CFDictionary *)CFArrayGetValueAtIndex(v27, 0);
          memset(v36, 0, sizeof(v36));
          IIODictionary::IIODictionary((IIODictionary *)v36, v28);
          v29 = IIODictionary::getObjectForKeyGroup((IIODictionary *)v36, CFSTR("Width"), *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_Dimensions);
          IIODictionary::setObjectForKey((IIODictionary *)v38, v29, CFSTR("ThumbnailWidth"));
          v30 = IIODictionary::getObjectForKeyGroup((IIODictionary *)v36, CFSTR("Height"), *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_Dimensions);
          IIODictionary::setObjectForKey((IIODictionary *)v38, v30, CFSTR("ThumbnailHeight"));
          Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v36, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_DataLength);
          LODWORD(ObjectForKey) = IIODictionary::getUint32ForKey((IIODictionary *)v36, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_DataOffset);
          IIONumber::IIONumber((IIONumber *)v34, Uint32ForKey);
          IIODictionary::setObjectForKey((IIODictionary *)v38, value, CFSTR("ThumbnailSize"));
          IIONumber::~IIONumber((IIONumber *)v34);
          IIONumber::IIONumber((IIONumber *)v34, (int)ObjectForKey);
          IIODictionary::setObjectForKey((IIODictionary *)v38, value, CFSTR("ThumbnailOffset"));
          IIONumber::~IIONumber((IIONumber *)v34);
          if (a6)
          {
            v33 = 0;
            v34[0] = 0;
            if (!gFunc_CMPhotoDecompressionContainerCopyExifForIndexWithOptions(v41, 0, 0, 0, &v33, v34))
            {
              if (v34[0])
              {
                *a6 = (const __CFData *)v34[0];
                *a5 = v33;
              }
            }
          }
          CFRelease(v39);
          IIODictionary::~IIODictionary((IIODictionary *)v36);
          IIODictionary::~IIODictionary((IIODictionary *)v37);
          IIODictionary::~IIODictionary((IIODictionary *)v38);
        }
        CFRelease(v41);
      }
      CFRelease(v16);
    }
    else
    {
      v14 = 0;
    }
    CFRelease(v42);
  }
  return v14;
}

void sub_187FE7BA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v9;
  va_list va;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  va_list va1;
  uint64_t v15;
  uint64_t v16;
  va_list va2;

  va_start(va2, a8);
  va_start(va1, a8);
  va_start(va, a8);
  v9 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v13 = va_arg(va2, _QWORD);
  v15 = va_arg(va2, _QWORD);
  v16 = va_arg(va2, _QWORD);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  IIODictionary::~IIODictionary((IIODictionary *)va2);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_HEIF::extractImageInfo(IIO_Reader_HEIF *this, GlobalHEIFInfo *a2, IIOImageReadSession *a3, IIODictionary *a4)
{
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  const UInt8 *v9;
  CFIndex Uint32ForKey;
  CFDataRef v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  const char *v15;
  CFIndex Count;
  CFIndex v17;
  CFIndex i;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v20;
  HEIFGroupItem *v21;
  unsigned int v22;
  int v23;
  int v24;
  int SequenceCount;
  int v26;
  const char *v27;
  int v28;
  int v29;
  const char *v30;
  uint64_t v31;
  const char *v32;
  CFIndex v33;
  CFIndex j;
  const void *v35;
  int v36;
  int v37;
  const char *v39;
  HEIFMainImage *v40;
  CFIndex v41;
  CFIndex k;
  const void *v43;
  int v44;
  int v45;
  const char *v47;
  int ImageGeometryForIndexWithOptions;
  int v49;
  const char *v51;
  HEIFMainImage *v52;
  unsigned int v53;
  void *value[3];
  CFTypeRef cf;
  void *v57;
  CFArrayRef v58;
  CFArrayRef theArray;
  CFDictionaryRef v60[3];
  CFDictionaryRef theDict;
  int v62;
  CFTypeRef v63;
  CFTypeRef v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  uint64_t v69;
  CFTypeRef v70[2];

  v70[0] = 0;
  v69 = 0;
  v67 = 0u;
  v68 = 0u;
  v65 = 0u;
  v66 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v65, a3);
  if (GlobalHEIFInfo::getNumberOfMainImages(a2))
  {
    v6 = 0;
  }
  else
  {
    v7 = IIOCreateCMPhotoDecompressionSession((uint64_t)v70);
    v6 = v7;
    if ((_DWORD)v7)
    {
      v8 = IIOCMErrorString(v7);
      _cg_jpeg_mem_term("extractImageInfo", 462, "*** CMPhotoDecompressionSessionCreate  err = %s [%d]\n", v8, v6);
    }
    else
    {
      v63 = 0;
      v64 = 0;
      v62 = 0;
      v9 = (const UInt8 *)*((_QWORD *)&v65 + 1);
      Uint32ForKey = v66;
      if (a4 && IIODictionary::containsKey(a4, CFSTR("JPEGOffset")))
      {
        Uint32ForKey = IIODictionary::getUint32ForKey(a4, CFSTR("JPEGLength"));
        v9 += IIODictionary::getUint32ForKey(a4, CFSTR("JPEGOffset"));
      }
      v6 = 0;
      v11 = 0;
      if (Uint32ForKey && v9)
      {
        v11 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v9, Uint32ForKey, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
        if (v11)
        {
          v12 = gFunc_CMPhotoDecompressionSessionCreateContainer(v70[0], 0, v11, &v62, &v64);
          v6 = v12;
          if ((_DWORD)v12)
          {
            v13 = IIOCMErrorString(v12);
            _cg_jpeg_mem_term("extractImageInfo", 496, "*** CMPhotoDecompressionSessionCreateContainer  err = %s [%d]\n", v13, v6);
          }
          else
          {
            theDict = 0;
            v14 = gFunc_CMPhotoDecompressionContainerCreateDictionaryDescription(v64, &theDict);
            v6 = v14;
            if ((_DWORD)v14)
            {
              v15 = IIOCMErrorString(v14);
              _cg_jpeg_mem_term("extractImageInfo", 509, "*** CMPhotoDecompressionContainerCreateDictionaryDescription  err = %s [%d]\n", v15, v6);
            }
            else
            {
              memset(v60, 0, sizeof(v60));
              IIODictionary::IIODictionary((IIODictionary *)v60, theDict);
              if (IIODictionary::containsKey((IIODictionary *)v60, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_GroupsList))
              {
                value[0] = 0;
                CFDictionaryGetValueIfPresent(theDict, *(const void **)gIIO_kCMPhotoDecompressionContainerDescription_GroupsList, (const void **)value);
                theArray = 0;
                if (gFunc_CMPhotoDecompressionContainerCopyGroupsDescriptionArray)
                {
                  v6 = gFunc_CMPhotoDecompressionContainerCopyGroupsDescriptionArray(v64, &theArray);
                }
                else
                {
                  _cg_jpeg_mem_term("extractImageInfo", 530, "*** ERROR: Symbol 'CMPhotoDecompressionContainerCopyGroupsDescriptionArray' not loaded\n");
                  v6 = 0;
                }
                Count = CFArrayGetCount((CFArrayRef)value[0]);
                if (theArray)
                  v17 = CFArrayGetCount(theArray);
                else
                  v17 = 0;
                if (Count >= 1)
                {
                  for (i = 0; i != Count; ++i)
                  {
                    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)value[0], i);
                    if (ValueAtIndex)
                    {
                      if (i >= v17)
                        v20 = 0;
                      else
                        v20 = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, i);
                      v21 = (HEIFGroupItem *)operator new();
                      HEIFGroupItem::HEIFGroupItem(v21, ValueAtIndex, v20, i);
                      GlobalHEIFInfo::addHEIFGroupItem(a2, v21);
                    }
                  }
                }
                if (theArray)
                  CFRelease(theArray);
              }
              else
              {
                v6 = 0;
              }
              if (IIODictionary::containsKey((IIODictionary *)v60, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_ImageSequenceCount))v22 = IIODictionary::getUint32ForKey((IIODictionary *)v60, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_ImageSequenceCount);
              else
                v22 = 0;
              v23 = IIOImageRead::trustedURL(a2);
              if (v22)
                v24 = v23;
              else
                v24 = 0;
              if (v24 == 1)
              {
                value[0] = 0;
                GlobalHEIFInfo::setHasHEIFSequence((uint64_t)a2, 1);
                SequenceCount = gFunc_CMPhotoDecompressionContainerGetSequenceCount(v64, value);
                v26 = SequenceCount;
                if (SequenceCount)
                {
                  v27 = IIOCMErrorString(SequenceCount);
                  _cg_jpeg_mem_term("extractImageInfo", 569, "*** CMPhotoDecompressionContainerGetSequenceCount  err = %s [%d]\n", v27, v26);
                }
                v28 = gFunc_CMPhotoDecompressionContainerCreateSequenceContainer(v64, 0, (char *)value[0] - 1, &v63);
                v29 = v28;
                if (v28)
                {
                  v30 = IIOCMErrorString(v28);
                  _cg_jpeg_mem_term("extractImageInfo", 575, "*** CMPhotoDecompressionContainerCreateSequenceContainer  err = %s [%d]\n", v30, v29);
                }
                theArray = 0;
                v31 = gFunc_CMPhotoDecompressionContainerCreateDictionaryDescription(v63, &theArray);
                v6 = v31;
                if ((_DWORD)v31)
                {
                  v32 = IIOCMErrorString(v31);
                  _cg_jpeg_mem_term("extractImageInfo", 586, "*** CMPhotoDecompressionContainerCreateDictionaryDescription  err = %s [%d]\n", v32, v6);
                }
                if (theArray)
                {
                  v58 = 0;
                  CFDictionaryGetValueIfPresent(theArray, *(const void **)gIIO_kCMPhotoDecompressionContainerDescription_MainImages, (const void **)&v58);
                  v33 = CFArrayGetCount(v58);
                  v57 = 0;
                  CFDictionaryGetValueIfPresent(theArray, *(const void **)gIIO_kCMPhotoDecompressionContainerDescription_SequenceTracksDescription, (const void **)&v57);
                  if (v33 >= 1)
                  {
                    for (j = 0; j != v33; ++j)
                    {
                      v35 = CFArrayGetValueAtIndex(v58, j);
                      if (v35)
                      {
                        cf = 0;
                        v36 = gFunc_CMPhotoDecompressionContainerCopyHEIFItemPropertiesForIndexWithOptions(v63, j, 0, &cf);
                        v37 = v36;
                        if ((v36 + 16994) >= 2 && v36 != 0)
                        {
                          v39 = IIOCMErrorString(v36);
                          _cg_jpeg_mem_term("extractImageInfo", 608, "*** CMPhotoDecompressionContainerCopyHEIFItemPropertiesForIndexWithOptions  err = %s [%d]\n", v39, v37);
                        }
                        v40 = (HEIFMainImage *)operator new();
                        HEIFMainImage::HEIFMainImage(v40, v63, j, v35, cf, v57, (LODWORD(value[0]) - 1));
                        GlobalHEIFInfo::addHEIFMainImage(a2, v40);
                        if (cf)
                          CFRelease(cf);
                        v6 = 0;
                      }
                    }
                  }
                  CFRelease(theArray);
                }
                if (v63)
                {
                  CFRelease(v63);
                  v63 = 0;
                }
              }
              else
              {
                value[0] = 0;
                CFDictionaryGetValueIfPresent(theDict, *(const void **)gIIO_kCMPhotoDecompressionContainerDescription_MainImages, (const void **)value);
                if (value[0])
                {
                  v41 = CFArrayGetCount((CFArrayRef)value[0]);
                  if (v41 >= 1)
                  {
                    for (k = 0; k != v41; ++k)
                    {
                      v43 = CFArrayGetValueAtIndex((CFArrayRef)value[0], k);
                      if (v43)
                      {
                        LODWORD(v58) = 0;
                        theArray = 0;
                        v44 = gFunc_CMPhotoDecompressionContainerCopyHEIFItemPropertiesForIndexWithOptions(v64, k, 0, &theArray);
                        v45 = v44;
                        if ((v44 + 16994) >= 2 && v44 != 0)
                        {
                          v47 = IIOCMErrorString(v44);
                          _cg_jpeg_mem_term("extractImageInfo", 651, "*** CMPhotoDecompressionContainerCopyHEIFItemPropertiesForIndexWithOptions  err = %s [%d]\n", v47, v45);
                        }
                        ImageGeometryForIndexWithOptions = gFunc_CMPhotoDecompressionContainerGetImageGeometryForIndexWithOptions(v64, k, 0, 0, 0, &v58);
                        v49 = ImageGeometryForIndexWithOptions;
                        if (ImageGeometryForIndexWithOptions != -16993 && ImageGeometryForIndexWithOptions != 0)
                        {
                          v51 = IIOCMErrorString(ImageGeometryForIndexWithOptions);
                          _cg_jpeg_mem_term("extractImageInfo", 657, "*** CMPhotoDecompressionContainerGetImageGeometryForIndexWithOptions  err = %s [%d]\n", v51, v49);
                        }
                        v52 = (HEIFMainImage *)operator new();
                        HEIFMainImage::HEIFMainImage(v52, v64, k, v43, theArray, 0, 0xFFFFFFFFLL);
                        *((_DWORD *)v52 + 38) = (_DWORD)v58;
                        GlobalHEIFInfo::addHEIFMainImage(a2, v52);
                        if (theArray)
                          CFRelease(theArray);
                        v6 = 0;
                      }
                    }
                  }
                }
              }
              theArray = 0;
              CFDictionaryGetValueIfPresent(theDict, *(const void **)gIIO_kCMPhotoDecompressionContainerDescription_PrimaryImageIndex, (const void **)&theArray);
              if (theArray)
              {
                memset(value, 0, sizeof(value));
                IIONumber::IIONumber((IIONumber *)value, theArray);
                v53 = IIONumber::uint32Num((IIONumber *)value);
                GlobalHEIFInfo::setPrimaryImageIndex((uint64_t)a2, v53);
                IIONumber::~IIONumber((IIONumber *)value);
              }
              IIODictionary::~IIODictionary((IIODictionary *)v60);
            }
            if (theDict)
              CFRelease(theDict);
            CFRelease(v64);
          }
        }
        else
        {
          v6 = 0;
        }
      }
      gFunc_CMPhotoDecompressionSessionFlushCachedBuffers(v70[0], 0, 0);
      CFRelease(v70[0]);
      if (v11)
        CFRelease(v11);
    }
  }
  IIOScanner::~IIOScanner((IIOScanner *)&v65);
  return v6;
}

void sub_187FE8428(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  uint64_t v11;
  va_list va;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a10);
  va_start(va, a10);
  v11 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  IIOScanner::~IIOScanner((IIOScanner *)va1);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_HEIF::initThumbnail(CFStringRef **a1, uint64_t a2, unsigned int a3, unint64_t a4)
{
  uint64_t Session;
  IIOImageReadSession *Source;
  GlobalHEIFInfo *v10;
  char shouldExposeMultiFrameContents;
  char v12;
  uint64_t v13;
  HEIFMainImage *HEIFMainImageAtIndex;
  HEIFMainImage *v15;
  int v16;
  int v17;
  unsigned int v18;
  unsigned int v19;
  HEIFThumbnailImage *HEIFThumbnailImageAtIndex;
  IIO_Reader *v21;
  unsigned int v22;
  unsigned int GroupType;
  unsigned int IsAnonymous;
  unsigned int v25;
  CFComparisonResult v26;
  IIOReadPlugin *v27;
  int v28;
  int v29;
  int v30;

  IIO_LoadHEIFSymbols();
  Session = CGImagePluginGetSession(a2);
  Source = (IIOImageReadSession *)CGImageSourceGetSource(Session);
  v10 = IIOImageReadSession::globalInfoForType(Source, 1212500294);
  if (!v10)
  {
    v10 = (GlobalHEIFInfo *)operator new();
    GlobalHEIFInfo::GlobalHEIFInfo(v10);
    IIOImageReadSession::setGlobalInfo((IIOImageRead **)Source, 1212500294, v10, (void (*)(void *))globalHEIFInfoReleaseProc);
    shouldExposeMultiFrameContents = IIOImageReadSession::shouldExposeMultiFrameContents((IIOImageRead **)Source);
    GlobalHEIFInfo::setShouldExposeMultiFrameContents((uint64_t)v10, shouldExposeMultiFrameContents);
    v12 = IIOImageReadSession::useImageSequence((IIOImageRead **)Source);
    GlobalHEIFInfo::setUseHEIFSequence((uint64_t)v10, v12);
  }
  v13 = ((uint64_t (*)(CFStringRef **, GlobalHEIFInfo *, IIOImageReadSession *, _QWORD))(*a1)[34])(a1, v10, Source, 0);
  if ((_DWORD)v13)
  {
    v15 = (HEIFMainImage *)v13;
    LogError("initThumbnail", 1161, "*** ERROR: extractImageInfo failed: %d\n", v13);
  }
  else
  {
    HEIFMainImageAtIndex = (HEIFMainImage *)GlobalHEIFInfo::getHEIFMainImageAtIndex(v10, a3);
    v15 = HEIFMainImageAtIndex;
    if (HEIFMainImageAtIndex)
    {
      if (HEIFMainImage::width(HEIFMainImageAtIndex) < a4
        && HEIFMainImage::height(v15) < a4)
      {
        v16 = HEIFMainImage::width(v15);
        v17 = HEIFMainImage::height(v15);
        LogError("initThumbnail", 1168, "*** ERROR: kCGImageSourceThumbnailMaxPixelSize: %d is larger than image-dimension: %dx%d\n", a4, v16, v17);
        v18 = HEIFMainImage::width(v15);
        if (v18 <= HEIFMainImage::height(v15))
          v19 = HEIFMainImage::height(v15);
        else
          v19 = HEIFMainImage::width(v15);
        a4 = v19;
      }
      HEIFThumbnailImageAtIndex = (HEIFThumbnailImage *)HEIFMainImage::getHEIFThumbnailImageAtIndex(v15, 0);
      if (HEIFThumbnailImageAtIndex)
      {
        v21 = HEIFThumbnailImageAtIndex;
        v15 = (HEIFMainImage *)HEIFThumbnailImage::dataLength(HEIFThumbnailImageAtIndex);
        v22 = IIO_Reader::osType(v21);
        GroupType = HEIFGroupItem::getGroupType(v21);
        if (GroupType <= TIFFFieldIsAnonymous((uint64_t)v21))
          IsAnonymous = TIFFFieldIsAnonymous((uint64_t)v21);
        else
          IsAnonymous = HEIFGroupItem::getGroupType(v21);
        v25 = IsAnonymous;
        if ((_DWORD)v15)
        {
          v26 = CFStringCompare(*a1[1], CFSTR("public.jpeg"), 0);
          v27 = (IIOReadPlugin *)operator new();
          v28 = IIO_Reader::osType((IIO_Reader *)a1);
          HEIFReadPlugin::HEIFReadPlugin((uint64_t)v27, a2, a3, v22, v15, v26 == kCFCompareEqualTo, v28);
          IIOReadPlugin::setDecodeMode((uint64_t)v27, 2);
          v29 = v25;
          if (a4 < v25)
            v29 = a4;
          if (v25)
            v30 = v29;
          else
            v30 = a4;
          IIOReadPlugin::setDestMaxPixelSize((uint64_t)v27, v30);
          return IIOReadPlugin::callInitialize(v27);
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return (uint64_t)v15;
}

void sub_187FE87D0(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187FE8788);
}

float IIO_Reader_HEIF::updateImageHeadroom(int a1, CGImageRef image, IIOImageReadSession *a3, CGColorSpace *a4)
{
  IIOImageRead *v8;
  HEIFMainImage *HEIFMainImageAtIndex;
  HEIFMainImage *v10;
  float ISO5Headroom;
  float v12;
  CGColorSpace *ColorSpace;
  const void *v14;
  const __CFString *v15;
  const char *v16;
  int NumberOfAuxImages;
  unsigned int v19;
  int v20;
  HEIFAuxImage *HEIFAuxImageAtIndex;
  float v22;
  _BYTE v24[24];

  CGImageGetColorSpace(image);
  if (CGColorSpaceContainsFlexGTCInfo())
  {
    CGColorSpaceGetHeadroomInfo();
    return IIO_Reader::updateImageHeadroom(a1, (int)image, (int)a3, a4);
  }
  if (!a3)
    return IIO_Reader::updateImageHeadroom(a1, (int)image, (int)a3, a4);
  v8 = IIOImageReadSession::globalInfoForType(a3, 1212500294);
  if (!v8)
    return IIO_Reader::updateImageHeadroom(a1, (int)image, (int)a3, a4);
  HEIFMainImageAtIndex = (HEIFMainImage *)GlobalHEIFInfo::getHEIFMainImageAtIndex(v8, 0);
  if (!HEIFMainImageAtIndex)
    return IIO_Reader::updateImageHeadroom(a1, (int)image, (int)a3, a4);
  v10 = HEIFMainImageAtIndex;
  if (HEIFMainImage::hasISO5Headroom(HEIFMainImageAtIndex))
  {
    ISO5Headroom = HEIFMainImage::getISO5Headroom(v10);
  }
  else
  {
    NumberOfAuxImages = HEIFMainImage::getNumberOfAuxImages(v10);
    if (!NumberOfAuxImages)
      return IIO_Reader::updateImageHeadroom(a1, (int)image, (int)a3, a4);
    v19 = 0;
    v20 = NumberOfAuxImages - 1;
    while (1)
    {
      HEIFAuxImageAtIndex = (HEIFAuxImage *)HEIFMainImage::getHEIFAuxImageAtIndex(v10, v19);
      ISO5Headroom = HEIFAuxImage::meteorHeadroomFromMakerNote(HEIFAuxImageAtIndex);
      if (ISO5Headroom > 0.0)
        break;
      v22 = HEIFAuxImage::meteorHeadroomFromProperties(HEIFAuxImageAtIndex);
      if (v22 > 0.0 || v20 == v19++)
      {
        v12 = v22;
        if (v22 > 0.0)
          goto LABEL_9;
        return IIO_Reader::updateImageHeadroom(a1, (int)image, (int)a3, a4);
      }
    }
  }
  v12 = ISO5Headroom;
LABEL_9:
  if (image)
  {
    if ((gIIODebugFlags & 0x300000) != 0)
      ImageIOLog("  %s - updating CGImage<%p>  headroom: %g\n", "updateImageHeadroom", image, v12);
    if ((CGImageSetHeadroom() & 1) == 0)
    {
      ColorSpace = CGImageGetColorSpace(image);
      v14 = CGColorSpaceCopyName(ColorSpace);
      if (v14 || (v14 = (const void *)CGColorSpaceCopyICCProfileDescription()) != 0)
      {
        IIOString::IIOString((IIOString *)v24, v14);
        v15 = IIOString::utf8String((IIOString *)v24);
        IIOString::~IIOString((IIOString *)v24);
        v16 = "????";
        if (v15)
          v16 = (const char *)v15;
        LogError("updateImageHeadroom", 1309, "*** ERROR: CGImageSetHeadroom: %f failed for image with %s color space\n", v12, v16);
        CFRelease(v14);
      }
      else
      {
        LogError("updateImageHeadroom", 1313, "*** ERROR: CGImageSetHeadroom: %f failed for image with unnamed color space\n", v12);
      }
    }
  }
  return v12;
}

void sub_187FE8A7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

BOOL IIO_Reader_HEIF::canScaleThumbnailToFinalSize(IIO_Reader_HEIF *this)
{
  return IIO_Reader::osType(this) != 1212500307;
}

void IIO_Reader_HEIF::CreateGlobalHEIFInfoIfNeeded(IIO_Reader_HEIF *this, IIOImageReadSession *a2, int a3)
{
  int v4;
  IIO_ReaderHandler *ReaderHandler;
  IIO_Reader *v7;
  IIO_Reader *v8;
  int v9;
  _BYTE v10[16];
  void *value;
  _QWORD v12[3];
  int v13;

  v4 = (int)a2;
  ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(this);
  v7 = IIO_ReaderHandler::readerForUTType(ReaderHandler, CFSTR("public.heic"));
  if (v7)
  {
    v8 = v7;
    v13 = 0;
    memset(v12, 0, sizeof(v12));
    IIODictionary::IIODictionary((IIODictionary *)v12);
    IIONumber::IIONumber((IIONumber *)v10, v4);
    IIODictionary::setObjectForKey((IIODictionary *)v12, value, CFSTR("JPEGOffset"));
    IIONumber::~IIONumber((IIONumber *)v10);
    IIONumber::IIONumber((IIONumber *)v10, a3);
    IIODictionary::setObjectForKey((IIODictionary *)v12, value, CFSTR("JPEGLength"));
    IIONumber::~IIONumber((IIONumber *)v10);
    v9 = (*(uint64_t (**)(IIO_Reader *, IIO_Reader_HEIF *, _QWORD *, _QWORD, int *))(*(_QWORD *)v8 + 32))(v8, this, v12, 0, &v13);
    if (v9)
      _cg_jpeg_mem_term("CreateGlobalHEIFInfoIfNeeded", 1349, "*** ERROR: CreateGlobalHEIFInfoIfNeeded: err: %d\n", v9);
    IIODictionary::~IIODictionary((IIODictionary *)v12);
  }
}

void sub_187FE8BBC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  uint64_t v6;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_HEIF::hasCustomThumbnailProc(IIO_Reader_HEIF *this)
{
  return 1;
}

uint64_t IIO_Reader_HEIF::canCreateCustomThumbnailSizes(IIO_Reader_HEIF *this)
{
  return 1;
}

uint64_t IIO_Reader_HEIF::canApplyTransform(IIO_Reader_HEIF *this)
{
  return 1;
}

uint64_t IIO_Reader_PDF::createReadPlugin(IIO_Reader *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;

  v4 = operator new();
  v5 = IIO_Reader::osType(a1);
  PDFReadPlugin::PDFReadPlugin(v4, a2, v5);
  return v4;
}

void sub_187FE8C68(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40F62C0459);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_PDF::createReadPlugin(IIO_Reader *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8;
  int v9;

  v8 = operator new();
  v9 = IIO_Reader::osType(a1);
  PDFReadPlugin::PDFReadPlugin(v8, a2, a3, a4, v9);
  return v8;
}

void sub_187FE8D04(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D761C30](v1, 0x10E1C40F62C0459);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_PDF::updateSourceProperties(IIO_Reader_PDF *this, IIOImageReadSession *a2, IIODictionary *a3, IIODictionary *a4, IIODictionary *a5, CGImageSourceStatus *a6)
{
  CGPDFDocument *v8;
  CGPDFDocument *v9;
  _BOOL4 IsEncrypted;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;
  char AccessPermissions;
  const void *v16;
  const void *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  const void *v21;
  const void *v22;
  const void *v23;
  const __CFDictionary *v24;
  const __CFLocale *v25;
  const __CFAllocator *v26;
  __CFDateFormatter *v27;
  const __CFString *v28;
  const __CFDate *ObjectForKey;
  CFStringRef StringWithDate;
  const __CFString *v31;
  const __CFDate *v32;
  CFStringRef v33;
  const __CFString *v34;
  const __CFDictionary *v35;
  const __CFString *v36;
  const __CFDictionary *v37;
  const __CFString *v38;
  const __CFDictionary *v39;
  const __CFString *v40;
  const __CFDictionary *v41;
  const __CFString *v42;
  const __CFDictionary *v43;
  const __CFString *v44;
  const __CFDictionary *v45;
  uint64_t v46;
  _QWORD v48[3];
  BOOL v49;
  _OWORD v50[4];
  uint64_t v51;

  *a6 = kCGImageStatusIncomplete;
  if (!IIOImageReadSession::isFinal(a2))
    return 4294967246;
  v51 = 0;
  memset(v50, 0, sizeof(v50));
  IIOScanner::IIOScanner((IIOScanner *)v50, a2);
  v49 = 0;
  v8 = CreateSessionPDFRef((off_t *)v50, &v49);
  v9 = v8;
  if (v8)
  {
    IsEncrypted = CGPDFDocumentIsEncrypted(v8);
    v11 = (const void *)*MEMORY[0x1E0C9AE50];
    v12 = (const void *)*MEMORY[0x1E0C9AE40];
    if (IsEncrypted)
      v13 = (const void *)*MEMORY[0x1E0C9AE50];
    else
      v13 = (const void *)*MEMORY[0x1E0C9AE40];
    IIODictionary::setObjectForKeyGroup(a3, v13, CFSTR("IsEncrypted"), CFSTR("{PDF}"));
    if (CGPDFDocumentIsUnlocked(v9))
      v14 = v11;
    else
      v14 = v12;
    IIODictionary::setObjectForKeyGroup(a3, v14, CFSTR("IsUnlocked"), CFSTR("{PDF}"));
    AccessPermissions = CGPDFDocumentGetAccessPermissions(v9);
    if ((AccessPermissions & 1) != 0)
      v16 = v11;
    else
      v16 = v12;
    IIODictionary::setObjectForKeyGroup(a3, v16, CFSTR("AllowsLowQualityPrinting"), CFSTR("{PDF}"));
    if ((AccessPermissions & 2) != 0)
      v17 = v11;
    else
      v17 = v12;
    IIODictionary::setObjectForKeyGroup(a3, v17, CFSTR("AllowsHighQualityPrinting"), CFSTR("{PDF}"));
    if ((AccessPermissions & 4) != 0)
      v18 = v11;
    else
      v18 = v12;
    IIODictionary::setObjectForKeyGroup(a3, v18, CFSTR("AllowsDocumentChanges"), CFSTR("{PDF}"));
    if ((AccessPermissions & 8) != 0)
      v19 = v11;
    else
      v19 = v12;
    IIODictionary::setObjectForKeyGroup(a3, v19, CFSTR("AllowsDocumentAssembly"), CFSTR("{PDF}"));
    if ((AccessPermissions & 0x10) != 0)
      v20 = v11;
    else
      v20 = v12;
    IIODictionary::setObjectForKeyGroup(a3, v20, CFSTR("AllowsContentCopying"), CFSTR("{PDF}"));
    if ((AccessPermissions & 0x20) != 0)
      v21 = v11;
    else
      v21 = v12;
    IIODictionary::setObjectForKeyGroup(a3, v21, CFSTR("AllowsContentAccessibility"), CFSTR("{PDF}"));
    if ((AccessPermissions & 0x40) != 0)
      v22 = v11;
    else
      v22 = v12;
    IIODictionary::setObjectForKeyGroup(a3, v22, CFSTR("AllowsCommenting"), CFSTR("{PDF}"));
    if (AccessPermissions < 0)
      v23 = v11;
    else
      v23 = v12;
    IIODictionary::setObjectForKeyGroup(a3, v23, CFSTR("AllowsFormFieldEntry"), CFSTR("{PDF}"));
    v24 = (const __CFDictionary *)CGPDFDocumentCopyInfoDictionary();
    if (v24)
    {
      v25 = CFLocaleCopyCurrent();
      v26 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v27 = CFDateFormatterCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v25, kCFDateFormatterNoStyle, kCFDateFormatterNoStyle);
      CFDateFormatterSetFormat(v27, CFSTR("yyyy:MM:dd HH:mm:ss"));
      memset(v48, 0, sizeof(v48));
      IIODictionary::IIODictionary((IIODictionary *)v48, v24);
      v28 = (const __CFString *)*MEMORY[0x1E0C9DBC0];
      if (IIODictionary::containsKey((IIODictionary *)v48, (const __CFString *)*MEMORY[0x1E0C9DBC0]))
      {
        ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v48, v28);
        StringWithDate = CFDateFormatterCreateStringWithDate(v26, v27, ObjectForKey);
        IIODictionary::setObjectForKeyGroup(a3, StringWithDate, CFSTR("ModificationDate"), CFSTR("{PDF}"));
        CFRelease(StringWithDate);
      }
      v31 = (const __CFString *)*MEMORY[0x1E0C9DBA8];
      if (IIODictionary::containsKey((IIODictionary *)v48, (const __CFString *)*MEMORY[0x1E0C9DBA8]))
      {
        v32 = IIODictionary::getObjectForKey((IIODictionary *)v48, v31);
        v33 = CFDateFormatterCreateStringWithDate(v26, v27, v32);
        IIODictionary::setObjectForKeyGroup(a3, v33, CFSTR("CreationDate"), CFSTR("{PDF}"));
        CFRelease(v33);
      }
      CFRelease(v25);
      CFRelease(v27);
      v34 = (const __CFString *)*MEMORY[0x1E0C9DBC8];
      if (IIODictionary::containsKey((IIODictionary *)v48, (const __CFString *)*MEMORY[0x1E0C9DBC8]))
      {
        v35 = IIODictionary::getObjectForKey((IIODictionary *)v48, v34);
        IIODictionary::setObjectForKeyGroup(a3, v35, CFSTR("Producer"), CFSTR("{PDF}"));
      }
      v36 = (const __CFString *)*MEMORY[0x1E0C9DBB0];
      if (IIODictionary::containsKey((IIODictionary *)v48, (const __CFString *)*MEMORY[0x1E0C9DBB0]))
      {
        v37 = IIODictionary::getObjectForKey((IIODictionary *)v48, v36);
        IIODictionary::setObjectForKeyGroup(a3, v37, CFSTR("Creator"), CFSTR("{PDF}"));
      }
      v38 = (const __CFString *)*MEMORY[0x1E0C9DBB8];
      if (IIODictionary::containsKey((IIODictionary *)v48, (const __CFString *)*MEMORY[0x1E0C9DBB8]))
      {
        v39 = IIODictionary::getObjectForKey((IIODictionary *)v48, v38);
        IIODictionary::setObjectForKeyGroup(a3, v39, CFSTR("Keywords"), CFSTR("{PDF}"));
      }
      v40 = (const __CFString *)*MEMORY[0x1E0C9DBD0];
      if (IIODictionary::containsKey((IIODictionary *)v48, (const __CFString *)*MEMORY[0x1E0C9DBD0]))
      {
        v41 = IIODictionary::getObjectForKey((IIODictionary *)v48, v40);
        IIODictionary::setObjectForKeyGroup(a3, v41, CFSTR("Subject"), CFSTR("{PDF}"));
      }
      v42 = (const __CFString *)*MEMORY[0x1E0C9DBA0];
      if (IIODictionary::containsKey((IIODictionary *)v48, (const __CFString *)*MEMORY[0x1E0C9DBA0]))
      {
        v43 = IIODictionary::getObjectForKey((IIODictionary *)v48, v42);
        IIODictionary::setObjectForKeyGroup(a3, v43, CFSTR("Author"), CFSTR("{PDF}"));
      }
      v44 = (const __CFString *)*MEMORY[0x1E0C9DBD8];
      if (IIODictionary::containsKey((IIODictionary *)v48, (const __CFString *)*MEMORY[0x1E0C9DBD8]))
      {
        v45 = IIODictionary::getObjectForKey((IIODictionary *)v48, v44);
        IIODictionary::setObjectForKeyGroup(a3, v45, CFSTR("Title"), CFSTR("{PDF}"));
      }
      CFRelease(v24);
      IIODictionary::~IIODictionary((IIODictionary *)v48);
    }
    CGPDFDocumentRelease(v9);
    v46 = 0;
  }
  else
  {
    if (v49)
      IIODictionary::setObjectForKeyGroup(a3, (const void *)*MEMORY[0x1E0C9AE50], CFSTR("IsLocked"), CFSTR("{PDF}"));
    v46 = 4294967246;
  }
  IIOScanner::~IIOScanner((IIOScanner *)v50);
  return v46;
}

void sub_187FE9214(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  IIODictionary::~IIODictionary((IIODictionary *)&a9);
  IIOScanner::~IIOScanner((IIOScanner *)&a13);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_PDF::getImageCount(IIO_Reader_PDF *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  CGPDFDocument *SessionPDFRef;
  CGPDFDocument *v9;
  uint64_t v10;
  _OWORD v12[4];
  uint64_t v13;

  *a4 = kCGImageStatusIncomplete;
  if (!IIOImageReadSession::isFinal(a2))
    return 4294967246;
  v13 = 0;
  memset(v12, 0, sizeof(v12));
  IIOScanner::IIOScanner((IIOScanner *)v12, a2);
  SessionPDFRef = CreateSessionPDFRef((off_t *)v12, 0);
  v9 = SessionPDFRef;
  if (SessionPDFRef)
  {
    if (a5)
      *a5 = CGPDFDocumentGetNumberOfPages(SessionPDFRef);
    CGPDFDocumentRelease(v9);
    v10 = 0;
    *a4 = kCGImageStatusComplete;
  }
  else
  {
    v10 = 4294967246;
  }
  IIOScanner::~IIOScanner((IIOScanner *)v12);
  return v10;
}

void sub_187FE931C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  IIOScanner::~IIOScanner((IIOScanner *)&a9);
  _Unwind_Resume(a1);
}

BOOL IIO_Reader_PDF::compareOptions(IIO_Reader_PDF *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  float FloatForKey;
  unsigned int v5;
  float v6;
  _BOOL8 v7;
  _QWORD v9[3];
  _QWORD v10[3];

  memset(v10, 0, sizeof(v10));
  IIODictionary::IIODictionary((IIODictionary *)v10, a2);
  memset(v9, 0, sizeof(v9));
  IIODictionary::IIODictionary((IIODictionary *)v9, a3);
  FloatForKey = 0.0;
  if (IIODictionary::containsKey((IIODictionary *)v10, CFSTR("kCGImageSourceRasterizationDPI")))
    FloatForKey = IIODictionary::getFloatForKey((IIODictionary *)v10, CFSTR("kCGImageSourceRasterizationDPI"));
  v5 = IIODictionary::containsKey((IIODictionary *)v9, CFSTR("kCGImageSourceRasterizationDPI"));
  v6 = 0.0;
  if (v5)
    v6 = IIODictionary::getFloatForKey((IIODictionary *)v9, CFSTR("kCGImageSourceRasterizationDPI"));
  v7 = FloatForKey == v6;
  IIODictionary::~IIODictionary((IIODictionary *)v9);
  IIODictionary::~IIODictionary((IIODictionary *)v10);
  return v7;
}

void sub_187FE93EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_PDF::hasCustomImageCountProc(IIO_Reader_PDF *this)
{
  return 1;
}

uint64_t IIO_Reader_PDF::hasCustomCompareOptionsProc(IIO_Reader_PDF *this)
{
  return 1;
}

uint64_t IIO_Reader_PDF::hasCustomSourcePropertiesProc(IIO_Reader_PDF *this)
{
  return 1;
}

CFMutableDictionaryRef CGImageMetadataTagsDictCreate()
{
  return CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &kCGImageMetadataTagKeyCallbacks, MEMORY[0x1E0C9B3A0]);
}

__CFString *_CGImageMetadataCopyFormattingDescription(CFDictionaryRef *cf, const __CFDictionary *a2)
{
  __CFString *Mutable;
  CFTypeID v4;
  const __CFAllocator *v5;
  int64_t Count;
  const void **v7;
  const __CFString *v8;
  const __CFString *v9;
  const __CFString *MutableCopy;
  __CFString *v11;
  const void **v13;
  const void **v14;
  CFRange v15;

  Mutable = 0;
  if (cf && (CFDictionaryRef *)*MEMORY[0x1E0C9B0D0] != cf)
  {
    v4 = CFGetTypeID(cf);
    if (CGImageMetadataGetTypeID::once != -1)
      dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_20);
    if (v4 == CGImageMetadataGetTypeID::id && cf[3])
    {
      v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
      CFStringAppend(Mutable, CFSTR("(\n"));
      Count = CFDictionaryGetCount(cf[3]);
      v13 = (const void **)malloc_type_calloc(8uLL, Count, 0xF211B383uLL);
      v14 = (const void **)malloc_type_calloc(8uLL, Count, 0xA3A68BAAuLL);
      CFDictionaryGetKeysAndValues(cf[3], v13, v14);
      if (Count >= 1)
      {
        v7 = v14;
        do
        {
          v8 = CFStringCreateWithFormat(v5, 0, CFSTR("%@"), *v7);
          if (v8)
          {
            v9 = v8;
            MutableCopy = CFStringCreateMutableCopy(v5, 0, v8);
            if (MutableCopy)
            {
              v11 = (__CFString *)MutableCopy;
              v15.length = CFStringGetLength(MutableCopy);
              v15.location = 0;
              CFStringFindAndReplace(v11, CFSTR("\n"), CFSTR("\n        "), v15, 0);
              CFStringAppendFormat(Mutable, 0, CFSTR("    %@\n"), v11);
              CFRelease(v11);
            }
            CFRelease(v9);
          }
          ++v7;
          --Count;
        }
        while (Count);
      }
      CFStringAppend(Mutable, CFSTR(")\n"));
      if (v13)
        free(v13);
      if (v14)
        free(v14);
    }
    else
    {
      return 0;
    }
  }
  return Mutable;
}

CFStringRef _CGImageMetadataCopyDescription(CFDictionaryRef *cf)
{
  __CFString *v1;
  CFTypeID v3;
  int v4;
  const __CFAllocator *v5;
  __CFString *Mutable;
  CFIndex Count;
  int64_t v8;
  const char *v9;
  const void **v10;
  unint64_t v11;
  uint64_t v12;
  const void *Value;
  const __CFString *v14;
  const __CFString *v15;
  const __CFString *MutableCopy;
  __CFString *v17;
  const __CFString *v18;
  CFIndex Length;
  const __CFString *v21;
  __CFString *v22;
  const char *CStringPtr;
  const char *v24;
  const __CFString *v25;
  const __CFString *v26;
  const void **v27;
  uint64_t (*v28[3])(uint64_t, uint64_t);
  CFRange v29;
  CFRange v30;
  CFRange v31;
  CFRange v32;

  v1 = 0;
  if (cf && (CFDictionaryRef *)*MEMORY[0x1E0C9B0D0] != cf)
  {
    v3 = CFGetTypeID(cf);
    if (CGImageMetadataGetTypeID::once != -1)
      dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_20);
    if (v3 == CGImageMetadataGetTypeID::id)
    {
      v4 = IIO_OSAppleInternalBuild();
      v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      if (!v4)
        return CFStringCreateWithFormat(v5, 0, CFSTR("<CGImageMetadata %p> %@"), cf, cf);
      Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 9999);
      v1 = Mutable;
      if (!cf[3])
        goto LABEL_25;
      CFStringAppendFormat(Mutable, 0, CFSTR("<CGImageMetadata: %p> (\n"), cf);
      Count = CFDictionaryGetCount(cf[3]);
      v8 = Count;
      v9 = "s";
      if (Count == 1)
        v9 = "";
      CFStringAppendFormat(v1, 0, CFSTR("    %d tag%s\n"), Count, v9);
      v10 = (const void **)malloc_type_calloc(8uLL, v8, 0xA4FA6ADDuLL);
      CFDictionaryGetKeysAndValues(cf[3], v10, 0);
      v28[0] = (uint64_t (*)(uint64_t, uint64_t))compareCGImageMetadataTagKey;
      v11 = 126 - 2 * __clz(v8);
      if (v8)
        v12 = v11;
      else
        v12 = 0;
      std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(CGImageMetadataTagKey const*,CGImageMetadataTagKey const*),CGImageMetadataTagKey**,false>((uint64_t)v10, (uint64_t *)&v10[v8], v28, v12, 1);
      if (v8 < 1)
      {
        CFStringAppendFormat(v1, 0, CFSTR(")\n"));
        if (!v10)
          goto LABEL_25;
      }
      else
      {
        v27 = v10;
        do
        {
          Value = CFDictionaryGetValue(cf[3], *v10);
          v14 = CFStringCreateWithFormat(v5, 0, CFSTR("%@"), Value);
          if (v14)
          {
            v15 = v14;
            MutableCopy = CFStringCreateMutableCopy(v5, 0, v14);
            if (MutableCopy)
            {
              v17 = (__CFString *)MutableCopy;
              v29.length = CFStringGetLength(MutableCopy);
              v29.location = 0;
              CFStringFindAndReplace(v17, CFSTR("\n"), CFSTR("\n        "), v29, 0);
              IIOString::IIOString((IIOString *)v28, v17);
              v18 = IIOString::utf8String((IIOString *)v28);
              CFStringAppendFormat(v1, 0, CFSTR("    %s\n"), v18);
              IIOString::~IIOString((IIOString *)v28);
              CFRelease(v17);
            }
            CFRelease(v15);
          }
          ++v10;
          --v8;
        }
        while (v8);
        CFStringAppendFormat(v1, 0, CFSTR(")\n"));
        v10 = v27;
      }
      free(v10);
LABEL_25:
      Length = CFStringGetLength(v1);
      v21 = CFStringCreateMutableCopy(v5, Length, v1);
      if (v21)
      {
        v22 = (__CFString *)v21;
        v30.length = CFStringGetLength(v21);
        v30.location = 0;
        CFStringFindAndReplace(v22, CFSTR("\\n"), CFSTR("\n"), v30, 1uLL);
        v31.length = CFStringGetLength(v22);
        v31.location = 0;
        CFStringFindAndReplace(v22, CFSTR("\\\""), CFSTR("\""), v31, 1uLL);
        v32.length = CFStringGetLength(v22);
        v32.location = 0;
        CFStringFindAndReplace(v22, CFSTR("\\\\"), CFSTR("\\"), v32, 1uLL);
        CStringPtr = CFStringGetCStringPtr(v22, 0x8000100u);
        if (CStringPtr)
          v24 = CStringPtr;
        else
          v24 = "<<<BAD-STRING>>>";
        v25 = CFStringCreateWithCString(v5, v24, 0xBFFu);
        if (v25)
        {
          v26 = v25;
          CFStringReplaceAll(v1, v25);
          CFRelease(v26);
        }
        CFRelease(v22);
      }
      return v1;
    }
    return 0;
  }
  return v1;
}

void sub_187FE99FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t CGImageMetadataCreateImmutableCopy(uint64_t a1)
{
  const __CFAllocator *v2;
  uint64_t Instance;
  uint64_t v4;
  const __CFDictionary *MutableCopy;
  const __CFDictionary *v6;
  const __CFDictionary *v7;
  const __CFDictionary *v8;
  const __CFString *v9;
  const __CFString *v10;

  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (CGImageMetadataGetTypeID::once != -1)
    dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_20);
  Instance = _CFRuntimeCreateInstance();
  v4 = Instance;
  if (Instance)
  {
    *(_BYTE *)(Instance + 16) = 0;
    MutableCopy = CFDictionaryCreateMutableCopy(v2, 0, *(CFDictionaryRef *)(a1 + 24));
    *(_QWORD *)(v4 + 24) = MutableCopy;
    CFDictionaryApplyFunction(MutableCopy, (CFDictionaryApplierFunction)makeTagsImmutableDictionaryApplier, 0);
    v6 = *(const __CFDictionary **)(a1 + 40);
    if (v6)
      *(_QWORD *)(v4 + 40) = CFDictionaryCreateMutableCopy(v2, 0, v6);
    v7 = *(const __CFDictionary **)(a1 + 32);
    if (v7)
      *(_QWORD *)(v4 + 32) = CFDictionaryCreateMutableCopy(v2, 0, v7);
    v8 = *(const __CFDictionary **)(a1 + 48);
    if (v8)
      *(_QWORD *)(v4 + 48) = CFDictionaryCreateMutableCopy(v2, 0, v8);
    v9 = *(const __CFString **)(a1 + 56);
    if (v9)
      *(_QWORD *)(v4 + 56) = CFStringCreateCopy(v2, v9);
    v10 = *(const __CFString **)(a1 + 64);
    if (v10)
      *(_QWORD *)(v4 + 64) = CFStringCreateCopy(v2, v10);
    initRecursivePthread_mutex((pthread_mutex_t *)(v4 + 72));
    pthread_mutex_init((pthread_mutex_t *)(v4 + 136), 0);
    initRecursivePthread_mutex((pthread_mutex_t *)(v4 + 208));
  }
  return v4;
}

void makeTagsImmutableDictionaryApplier(const void *a1, CFTypeRef cf, void *a3)
{
  CFTypeID v4;
  uint64_t Source;
  const void *v6;
  CFTypeID v7;
  CFTypeID TypeID;
  const __CFArray *v9;
  CFTypeID v10;
  CFRange v11;

  if (cf)
  {
    v4 = CFGetTypeID(cf);
    if (v4 == CGImageMetadataTagGetTypeID())
    {
      Source = CGImageSourceGetSource((uint64_t)cf);
      *(_BYTE *)(Source + 64) = 0;
      v6 = *(const void **)(Source + 48);
      if (v6)
      {
        v7 = CFGetTypeID(v6);
        TypeID = CFArrayGetTypeID();
        v9 = *(const __CFArray **)(Source + 48);
        if (v7 == TypeID)
        {
          v11.length = CFArrayGetCount(*(CFArrayRef *)(Source + 48));
          v11.location = 0;
          CFArrayApplyFunction(v9, v11, (CFArrayApplierFunction)makeTagsImmutableArrayApplier, 0);
        }
        else if (v9)
        {
          v10 = CFGetTypeID(*(CFTypeRef *)(Source + 48));
          if (v10 == CFDictionaryGetTypeID())
            CFDictionaryApplyFunction(*(CFDictionaryRef *)(Source + 48), (CFDictionaryApplierFunction)makeTagsImmutableDictionaryApplier, 0);
        }
      }
    }
  }
}

CFArrayRef CGImageMetadataCopyTags(CGImageMetadataRef metadata)
{
  CFTypeID v2;
  CFIndex Count;
  const void **v4;
  const void **v5;
  const void **v6;
  CFArrayRef v7;
  const __CFArray *v8;

  IIOInitDebugFlags();
  if ((~(_DWORD)gIIODebugFlags & 0x3000) == 0)
    ImageIODebugOptions(3, "A", "CGImageMetadataCopyTags", 0, 0, -1, 0);
  if (!metadata)
    goto LABEL_10;
  v2 = CFGetTypeID(metadata);
  if (CGImageMetadataGetTypeID::once != -1)
    dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_20);
  if (v2 != CGImageMetadataGetTypeID::id)
  {
LABEL_10:
    LogMetadata("CGImageMetadataCopyTags", 552, "metadata is NULL or not a CGImageMetadataRef");
    return 0;
  }
  Count = CFDictionaryGetCount(*((CFDictionaryRef *)metadata + 3));
  v4 = (const void **)malloc_type_calloc(8uLL, Count, 0x911B64C4uLL);
  v5 = (const void **)malloc_type_calloc(8uLL, Count, 0x7E0FFA52uLL);
  v6 = v5;
  if (v4 && v5)
  {
    CFDictionaryGetKeysAndValues(*((CFDictionaryRef *)metadata + 3), v4, v5);
    v7 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v6, Count, MEMORY[0x1E0C9B378]);
  }
  else
  {
    v7 = 0;
    v8 = 0;
    if (!v4)
      goto LABEL_13;
  }
  free(v4);
  v8 = v7;
LABEL_13:
  if (v6)
    free(v6);
  return v8;
}

CGImageMetadataTagRef CGImageMetadataCopyTagWithPath(CGImageMetadataRef metadata, CGImageMetadataTagRef parent, CFStringRef path)
{
  const char *v6;
  CFTypeID v7;
  void *TagWithPath;
  CGImageMetadataTag *v9;
  _BYTE v11[24];

  IIOInitDebugFlags();
  if ((~(_DWORD)gIIODebugFlags & 0x3000) == 0)
  {
    IIOString::IIOString((IIOString *)v11, path);
    v6 = (const char *)IIOString::utf8String((IIOString *)v11);
    ImageIODebugOptions(3, "A", "CGImageMetadataCopyTagWithPath", 0, v6, -1, 0);
    IIOString::~IIOString((IIOString *)v11);
  }
  if (!metadata)
    goto LABEL_9;
  v7 = CFGetTypeID(metadata);
  if (CGImageMetadataGetTypeID::once != -1)
    dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_20);
  if (v7 == CGImageMetadataGetTypeID::id)
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)metadata + 72));
    TagWithPath = CGImageMetadataGetTagWithPath(metadata, parent, path);
    if (TagWithPath)
      v9 = CGImageMetadataTagCopy((uint64_t)TagWithPath);
    else
      v9 = 0;
    pthread_mutex_unlock((pthread_mutex_t *)((char *)metadata + 72));
  }
  else
  {
LABEL_9:
    LogMetadata("CGImageMetadataCopyTagWithPath", 578, "metadata is NULL or not a CGImageMetadataRef");
    return 0;
  }
  return v9;
}

void sub_187FE9EC8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

CFStringRef CGImageMetadataCopyStringValueWithPath(CGImageMetadataRef metadata, CGImageMetadataTagRef parent, CFStringRef path)
{
  CFTypeID v6;
  void *TagWithPath;
  const __CFString *DefaultString;
  const __CFString *Copy;

  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0)
    ImageIODebugOptions(3, "A", "CGImageMetadataCopyStringValueWithPath", 0, 0, -1, 0);
  if (!metadata)
    return 0;
  v6 = CFGetTypeID(metadata);
  if (CGImageMetadataGetTypeID::once != -1)
    dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_20);
  if (v6 != CGImageMetadataGetTypeID::id)
    return 0;
  pthread_mutex_lock((pthread_mutex_t *)((char *)metadata + 72));
  TagWithPath = CGImageMetadataGetTagWithPath(metadata, parent, path);
  if (TagWithPath && (DefaultString = (const __CFString *)CGImageMetadataGetDefaultString(TagWithPath)) != 0)
    Copy = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], DefaultString);
  else
    Copy = 0;
  pthread_mutex_unlock((pthread_mutex_t *)((char *)metadata + 72));
  return Copy;
}

void *CGImageMetadataGetStringValueWithPath(_QWORD *a1, void *a2, const __CFString *a3)
{
  void *result;

  result = CGImageMetadataGetTagWithPath(a1, a2, a3);
  if (result)
    return (void *)CGImageMetadataGetDefaultString(result);
  return result;
}

BOOL CGImageMetadataRemoveTagWithPath(CGMutableImageMetadataRef metadata, CGImageMetadataTagRef parent, CFStringRef path)
{
  IIOString *v6;
  const char *v7;
  CFTypeID v8;
  CFTypeID v9;
  IIOMetadata_Tag *Source;
  const __CFAllocator *v11;
  const __CFString *v12;
  const __CFString *PathWithChildPath;
  char *v14;
  uint64_t v15;
  int v16;
  char *v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  char *v22;
  void *TagWithPath;
  uint64_t v24;
  IIOMetadata_Tag *v25;
  const void *v26;
  CFTypeID v27;
  const __CFAllocator *v28;
  CFIndex Count;
  __CFArray *MutableCopy;
  const __CFString *v31;
  const __CFAllocator *v32;
  const __CFString *v33;
  uint64_t v34;
  int v35;
  int v36;
  char *NodePath;
  const __CFString *v38;
  uint64_t v39;
  CFTypeID v40;
  CFStringRef v41;
  CFStringRef v42;
  const void *v43;
  CFTypeID v44;
  const __CFAllocator *v45;
  __CFDictionary *v46;
  CFStringRef v47;
  CFStringRef v48;
  CFStringRef v49;
  uint64_t v50;
  CFIndex Length;
  CFIndex v52;
  char *v53;
  char v54;
  const __CFString *v56;
  pthread_mutex_t *v57;
  _QWORD v58[8];
  _QWORD v59[9];
  _QWORD v60[3];
  char v61;
  uint64_t v62;
  uint64_t *v63;
  uint64_t v64;
  char v65;

  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0)
  {
    v6 = IIOString::IIOString((IIOString *)&v62, path);
    v7 = (const char *)IIOString::utf8String(v6);
    ImageIODebugOptions(3, "A", "CGImageMetadataRemoveTagWithPath", 0, v7, -1, 0);
    IIOString::~IIOString((IIOString *)&v62);
  }
  v62 = 0;
  v63 = &v62;
  v64 = 0x2000000000;
  v65 = 0;
  if (metadata)
  {
    v8 = CFGetTypeID(metadata);
    if (CGImageMetadataGetTypeID::once == -1)
    {
      if (!path)
        goto LABEL_73;
    }
    else
    {
      dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_20);
      if (!path)
        goto LABEL_73;
    }
    if (v8 == CGImageMetadataGetTypeID::id)
    {
      v9 = CFGetTypeID(path);
      if (v9 == CFStringGetTypeID())
      {
        Source = (IIOMetadata_Tag *)CGImageSourceGetSource((uint64_t)parent);
        pthread_mutex_lock((pthread_mutex_t *)((char *)metadata + 208));
        if (*((_BYTE *)metadata + 200))
        {
          LogMetadata("CGImageMetadataRemoveTagWithPath", 1473, "Cannot mutate metadata while enumerating");
          pthread_mutex_unlock((pthread_mutex_t *)((char *)metadata + 208));
          goto LABEL_73;
        }
        pthread_mutex_unlock((pthread_mutex_t *)((char *)metadata + 208));
        v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        if (parent)
        {
          v12 = CFStringCreateWithFormat(v11, 0, CFSTR("%@:%@"), *((_QWORD *)Source + 3), *((_QWORD *)Source + 4));
          if (!v12)
            goto LABEL_73;
          PathWithChildPath = IIOMetadata_Tag::createPathWithChildPath(Source, path);
          v14 = parse_metadata_pathString(v12);
          if (v14)
          {
            v15 = *((_QWORD *)v14 + 5);
            if (v15)
            {
              v16 = 0;
              do
              {
                if ((*(_DWORD *)v15 & 0xFFFFFFFE) != 2)
                  break;
                ++v16;
                v15 = *(_QWORD *)(v15 + 40);
              }
              while (v15);
            }
            else
            {
              v16 = 0;
            }
            freeNodes(v14);
          }
          else
          {
            v16 = 0;
          }
          CFRelease(v12);
        }
        else
        {
          PathWithChildPath = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], path);
          v16 = 0;
        }
        v17 = parse_metadata_pathString(PathWithChildPath);
        v18 = v17;
        if (!v17 || !*((_QWORD *)v17 + 1) || !*((_QWORD *)v17 + 2))
          goto LABEL_69;
        v19 = 0;
        v20 = v17;
        do
        {
          v21 = v20;
          v22 = v19;
          v20 = (char *)*((_QWORD *)v20 + 5);
          v19 = v21;
        }
        while (v20);
        v57 = (pthread_mutex_t *)((char *)metadata + 72);
        pthread_mutex_lock((pthread_mutex_t *)((char *)metadata + 72));
        if (!parent && v21 == v18)
        {
          TagWithPath = CGImageMetadataGetTagWithPath(metadata, 0, PathWithChildPath);
          if (TagWithPath)
          {
            CGImageMetadataRemoveTag((uint64_t)metadata, (uint64_t)TagWithPath);
LABEL_31:
            *((_BYTE *)v63 + 24) = 1;
          }
          goto LABEL_65;
        }
        if (parent && v22 == v18)
        {
LABEL_34:
          v24 = CGImageSourceGetSource((uint64_t)parent);
          v25 = (IIOMetadata_Tag *)v24;
          switch(*(_DWORD *)v21)
          {
            case 2:
              if ((*(_DWORD *)(v24 + 40) - 2) <= 2)
              {
                v26 = *(const void **)(v24 + 48);
                if (v26)
                {
                  v27 = CFGetTypeID(*(CFTypeRef *)(v24 + 48));
                  if (v27 == CFArrayGetTypeID())
                  {
                    v28 = CFGetAllocator(v26);
                    Count = CFArrayGetCount((CFArrayRef)v26);
                    MutableCopy = CFArrayCreateMutableCopy(v28, Count, (CFArrayRef)v26);
                    v31 = (const __CFString *)MutableCopy;
                    if (MutableCopy)
                    {
                      CFArrayRemoveValueAtIndex(MutableCopy, *((int *)v21 + 6));
                      IIOArrayEnumerateUsingBlock((uint64_t)v31, (uint64_t)&__block_literal_global_25);
                      IIOMetadata_Tag::setValue(v25, v31);
                      CFRelease(v26);
                      goto LABEL_31;
                    }
                  }
                }
              }
              break;
            case 3:
              if (*(_DWORD *)(v24 + 40) == 5)
              {
                v39 = *(_QWORD *)(v24 + 48);
                if (v39)
                {
                  v40 = CFGetTypeID(*(CFTypeRef *)(v24 + 48));
                  if (v40 == CFArrayGetTypeID())
                  {
                    v41 = CFStringCreateWithCString(v11, *((const char **)v21 + 4), 0x8000100u);
                    v42 = v41;
                    if (v41)
                    {
                      v60[0] = 0;
                      v60[1] = v60;
                      v60[2] = 0x2000000000;
                      v61 = 0;
                      v59[0] = MEMORY[0x1E0C809B0];
                      v59[1] = 0x40000000;
                      v59[2] = __CGImageMetadataRemoveTagWithPath_block_invoke_2;
                      v59[3] = &unk_1E1BC4E10;
                      v59[6] = v41;
                      v59[7] = v39;
                      v59[8] = v25;
                      v59[4] = &v62;
                      v59[5] = v60;
                      IIOArrayEnumerateUsingBlock(v39, (uint64_t)v59);
                      CFRelease(v42);
                      _Block_object_dispose(v60, 8);
                    }
                  }
                }
              }
              break;
            case 4:
              if (*(_DWORD *)(v24 + 40) == 6)
              {
                v43 = *(const void **)(v24 + 48);
                if (v43)
                {
                  v44 = CFGetTypeID(*(CFTypeRef *)(v24 + 48));
                  if (v44 == CFDictionaryGetTypeID())
                  {
                    v45 = CFGetAllocator(v43);
                    v46 = CFDictionaryCreateMutableCopy(v45, 0, (CFDictionaryRef)v43);
                    if (v46)
                    {
                      v47 = CFStringCreateWithCString(v11, *((const char **)v21 + 2), 0x8000100u);
                      if (v47)
                      {
                        CFDictionaryRemoveValue(v46, v47);
                        IIOMetadata_Tag::setValue(v25, (const __CFString *)v46);
                        CFRelease(v43);
                        CFRelease(v47);
                        goto LABEL_31;
                      }
                      CFRelease(v46);
                    }
                  }
                }
              }
              break;
            case 5:
              v48 = CFStringCreateWithCString(v11, *((const char **)v21 + 1), 0x8000100u);
              v49 = CFStringCreateWithCString(v11, *((const char **)v21 + 2), 0x8000100u);
              v50 = *((_QWORD *)v25 + 7);
              if (v50)
              {
                v58[0] = MEMORY[0x1E0C809B0];
                v58[1] = 0x40000000;
                v58[2] = __CGImageMetadataRemoveTagWithPath_block_invoke_4;
                v58[3] = &unk_1E1BC4E38;
                v58[6] = v49;
                v58[7] = v50;
                v58[4] = &v62;
                v58[5] = v48;
                IIOArrayEnumerateUsingBlock(v50, (uint64_t)v58);
              }
              if (v48)
                CFRelease(v48);
              if (v49)
                CFRelease(v49);
              break;
            default:
              goto LABEL_65;
          }
          goto LABEL_65;
        }
        v56 = path;
        v32 = v11;
        v33 = PathWithChildPath;
        v34 = (uint64_t)v18;
        if (parent)
        {
          v35 = v16 + 1;
          v34 = (uint64_t)v18;
          do
          {
            v34 = *(_QWORD *)(v34 + 40);
            --v35;
          }
          while (v35);
        }
        v36 = *(_DWORD *)v34;
        *((_QWORD *)v22 + 5) = 0;
        NodePath = createNodePath(v34);
        *(_DWORD *)v34 = v36;
        *((_QWORD *)v22 + 5) = v21;
        PathWithChildPath = v33;
        v11 = v32;
        path = v56;
        if (!NodePath)
          goto LABEL_65;
        v38 = CFStringCreateWithCString(v11, NodePath, 0x8000100u);
        if (v38)
        {
          parent = (CGImageMetadataTagRef)CGImageMetadataGetTagWithPath(metadata, parent, v38);
          CFRelease(v38);
          free(NodePath);
          if (parent)
            goto LABEL_34;
        }
        else
        {
          free(NodePath);
        }
LABEL_65:
        if (!*((_BYTE *)v63 + 24))
        {
          Length = CFStringGetLength(path);
          v52 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
          v53 = (char *)malloc_type_calloc(1uLL, v52, 0x25857A6uLL);
          if (v53)
          {
            CFStringGetCString(path, v53, v52, 0x8000100u);
            LogMetadata("CGImageMetadataRemoveTagWithPath", 1721, "Could not find a tag at path '%s' to remove.\n", v53);
            free(v53);
          }
        }
        pthread_mutex_unlock(v57);
LABEL_69:
        if (PathWithChildPath)
          CFRelease(PathWithChildPath);
        if (v18)
          freeNodes(v18);
      }
    }
  }
LABEL_73:
  v54 = *((_BYTE *)v63 + 24);
  _Block_object_dispose(&v62, 8);
  return v54;
}

void sub_187FEA8F0(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

CGImageMetadataTagRef CGImageMetadataCopyTagMatchingImageProperty(CGImageMetadataRef metadata, CFStringRef dictionaryName, CFStringRef propertyName)
{
  CFTypeID v6;
  CFTypeID TypeID;
  CFTypeID v8;
  CGImageMetadataTag *v9;
  _QWORD v11[8];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;

  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0)
    ImageIODebugOptions(3, "A", "CGImageMetadataCopyTagMatchingImageProperty", 0, 0, -1, 0);
  v12 = 0;
  v13 = &v12;
  v14 = 0x2000000000;
  v15 = 0;
  if (dictionaryName)
  {
    v6 = CFGetTypeID(dictionaryName);
    TypeID = CFStringGetTypeID();
    if (propertyName)
    {
      if (v6 == TypeID)
      {
        v8 = CFGetTypeID(propertyName);
        if (v8 == CFStringGetTypeID())
        {
          v11[0] = MEMORY[0x1E0C809B0];
          v11[1] = 0x40000000;
          v11[2] = __CGImageMetadataCopyTagMatchingImageProperty_block_invoke;
          v11[3] = &unk_1E1BC4E60;
          v11[6] = propertyName;
          v11[7] = metadata;
          v11[4] = &v12;
          v11[5] = dictionaryName;
          XMPMappingIterateUsingBlock((uint64_t)v11);
        }
      }
    }
  }
  v9 = (CGImageMetadataTag *)v13[3];
  _Block_object_dispose(&v12, 8);
  return v9;
}

void sub_187FEAD48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL CGImageMetadataSetValueMatchingImageProperty(CGMutableImageMetadataRef metadata, CFStringRef dictionaryName, CFStringRef propertyName, CFTypeRef value)
{
  CFTypeID v8;
  CFTypeID TypeID;
  CFTypeID v10;
  char v11;
  _QWORD v13[9];
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  char v17;

  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0)
    ImageIODebugOptions(3, "A", "CGImageMetadataSetValueMatchingImageProperty", 0, 0, -1, 0);
  v14 = 0;
  v15 = &v14;
  v16 = 0x2000000000;
  v17 = 0;
  if (dictionaryName)
  {
    v8 = CFGetTypeID(dictionaryName);
    TypeID = CFStringGetTypeID();
    if (propertyName)
    {
      if (v8 == TypeID)
      {
        v10 = CFGetTypeID(propertyName);
        if (v10 == CFStringGetTypeID())
        {
          v13[0] = MEMORY[0x1E0C809B0];
          v13[1] = 0x40000000;
          v13[2] = __CGImageMetadataSetValueMatchingImageProperty_block_invoke;
          v13[3] = &unk_1E1BC4EB0;
          v13[4] = &v14;
          v13[5] = dictionaryName;
          v13[6] = propertyName;
          v13[7] = metadata;
          v13[8] = value;
          XMPMappingIterateUsingBlock((uint64_t)v13);
        }
      }
    }
  }
  v11 = *((_BYTE *)v15 + 24);
  _Block_object_dispose(&v14, 8);
  return v11;
}

void sub_187FEAF54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void CGImageMetadataEnumerateTagsUsingBlock(CGImageMetadataRef metadata, CFStringRef rootPath, CFDictionaryRef options, CGImageMetadataTagBlock block)
{
  CFTypeID v8;
  _QWORD v9[3];

  IIOInitDebugFlags();
  if ((~(_DWORD)gIIODebugFlags & 0x3000) == 0)
    ImageIODebugOptions(3, "A", "CGImageMetadataEnumerateTagsUsingBlock", 0, 0, -1, 0);
  if (!metadata)
    goto LABEL_9;
  v8 = CFGetTypeID(metadata);
  if (CGImageMetadataGetTypeID::once != -1)
    dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_20);
  if (v8 == CGImageMetadataGetTypeID::id)
  {
    if (block)
    {
      pthread_mutex_lock((pthread_mutex_t *)((char *)metadata + 72));
      pthread_mutex_lock((pthread_mutex_t *)((char *)metadata + 208));
      *((_BYTE *)metadata + 200) = 1;
      pthread_mutex_unlock((pthread_mutex_t *)((char *)metadata + 208));
      memset(v9, 0, sizeof(v9));
      IIODictionary::IIODictionary((IIODictionary *)v9, options);
      CGImageMetadataEnumerateTagsUsingBlockInternal((CFDictionaryRef *)metadata, rootPath, (IIODictionary *)v9, (unsigned int (**)(void *, CFStringRef, uint64_t))block);
      pthread_mutex_lock((pthread_mutex_t *)((char *)metadata + 208));
      *((_BYTE *)metadata + 200) = 0;
      pthread_mutex_unlock((pthread_mutex_t *)((char *)metadata + 208));
      pthread_mutex_unlock((pthread_mutex_t *)((char *)metadata + 72));
      IIODictionary::~IIODictionary((IIODictionary *)v9);
    }
    else
    {
      LogMetadata("CGImageMetadataEnumerateTagsUsingBlock", 2089, "block is NULL.");
    }
  }
  else
  {
LABEL_9:
    LogMetadata("CGImageMetadataEnumerateTagsUsingBlock", 2093, "'metadata' is not a CGImageMetadataRef.");
  }
}

void sub_187FEB1C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void CGImageMetadataEnumerateTagsUsingBlockInternal(CFDictionaryRef *a1, const __CFString *a2, IIODictionary *a3, unsigned int (**a4)(void *, CFStringRef, uint64_t))
{
  _BOOL4 BoolForKey;
  CGImageMetadataTag *TagWithPath;
  uint64_t v10;
  CGImageMetadataType Type;
  CGImageMetadataType v12;
  const __CFDictionary *Value;
  const void *v14;
  uint64_t v15;
  CFTypeID v16;
  _QWORD *v17;
  CFTypeID v18;
  int64_t Count;
  const void **v20;
  const void **v21;
  uint64_t v22;
  const __CFAllocator *v23;
  uint64_t v24;
  CFTypeID v25;
  uint64_t Source;
  CFStringRef v27;
  CFStringRef v28;
  const char *CStringPtr;
  const char *v30;
  const void **v31;
  const void *v32;
  unsigned int (**v33)(void *, CFStringRef, uint64_t);
  CFTypeID v34;
  const __CFDictionary *v35;
  CFTypeID v36;
  int64_t v37;
  const void **v38;
  const void **v39;
  uint64_t v40;
  const __CFAllocator *v41;
  const __CFString *v42;
  const __CFString *v43;
  void *v44;
  IIODictionary *v45;
  IIODictionary *v46;
  unsigned int (**v47)(void *, CFStringRef, uint64_t);
  const void **v48;
  _QWORD v49[7];
  _QWORD v50[8];
  BOOL v51;

  BoolForKey = IIODictionary::getBoolForKey(a3, CFSTR("kCGImageMetadataEnumerateRecursively"));
  if (!a2 || CFStringGetLength(a2) < 1)
  {
    if (!a1)
      return;
    v18 = CFGetTypeID(a1);
    if (CGImageMetadataGetTypeID::once != -1)
      dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_20);
    if (v18 != CGImageMetadataGetTypeID::id)
      return;
    v45 = a3;
    v47 = a4;
    Count = CFDictionaryGetCount(a1[3]);
    v20 = (const void **)malloc_type_calloc(8uLL, Count, 0x2C27D4D5uLL);
    v21 = (const void **)malloc_type_calloc(8uLL, Count, 0xAB6C3DECuLL);
    CFDictionaryGetKeysAndValues(a1[3], v20, v21);
    if (v21 && Count >= 1 && v20)
    {
      v22 = 0;
      v23 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      do
      {
        v24 = (uint64_t)v21[v22];
        if (v24 && (v25 = CFGetTypeID(v21[v22]), v25 == CGImageMetadataTagGetTypeID()))
        {
          Source = CGImageSourceGetSource(v24);
          v27 = CFStringCreateWithFormat(v23, 0, CFSTR("%@:%@"), *(_QWORD *)(Source + 24), *(_QWORD *)(Source + 32));
          if (v27)
          {
            v28 = v27;
            if (!v47[2](v47, v27, v24))
            {
              free(v20);
              free(v21);
              CFRelease(v28);
              return;
            }
            if (BoolForKey)
              CGImageMetadataEnumerateTagsUsingBlockInternal(a1, v28, v45, v47);
            CFRelease(v28);
          }
        }
        else
        {
          CStringPtr = CFStringGetCStringPtr(*(CFStringRef *)v20[v22], 0);
          v30 = CFStringGetCStringPtr(*((CFStringRef *)v20[v22] + 1), 0);
          LogMetadata("CGImageMetadataEnumerateTagsUsingBlockInternal", 2041, "Value for Key = %s%s is not a valid CGImageMetadataTagRef\n", CStringPtr, v30);
        }
        ++v22;
      }
      while (Count != v22);
    }
    if (v20)
      free(v20);
    if (!v21)
      return;
    v31 = v21;
LABEL_30:
    free(v31);
    return;
  }
  TagWithPath = (CGImageMetadataTag *)CGImageMetadataGetTagWithPath(a1, 0, a2);
  if (!TagWithPath)
    return;
  v10 = (uint64_t)TagWithPath;
  Type = CGImageMetadataTagGetType(TagWithPath);
  if (Type == kCGImageMetadataTypeDefault)
    return;
  v12 = Type;
  Value = (const __CFDictionary *)CGImageMetadataTagGetValue(v10);
  if ((v12 & 0xFFFFFFFE) == 2)
  {
    v14 = (const void *)CGImageMetadataTagGetValue(v10);
    if (v14)
    {
      v15 = (uint64_t)v14;
      v16 = CFGetTypeID(v14);
      if (v16 == CFArrayGetTypeID())
      {
        v50[0] = MEMORY[0x1E0C809B0];
        v50[1] = 0x40000000;
        v50[2] = ___ZL46CGImageMetadataEnumerateTagsUsingBlockInternalPK15CGImageMetadataPK10__CFStringP13IIODictionaryU13block_pointerFbS4_P18CGImageMetadataTagE_block_invoke;
        v50[3] = &unk_1E1BC4ED8;
        v50[4] = a4;
        v50[5] = a2;
        v51 = BoolForKey;
        v50[6] = a1;
        v50[7] = a3;
        v17 = v50;
LABEL_35:
        IIOArrayEnumerateUsingBlock(v15, (uint64_t)v17);
        return;
      }
    }
    return;
  }
  if (v12 != kCGImageMetadataTypeAlternateText)
  {
    if (v12 != kCGImageMetadataTypeStructure)
      return;
    v35 = Value;
    if (!Value)
      return;
    v36 = CFGetTypeID(Value);
    if (v36 != CFDictionaryGetTypeID())
      return;
    v37 = CFDictionaryGetCount(v35);
    v38 = (const void **)malloc_type_calloc(8uLL, v37, 0xDA39B998uLL);
    v39 = (const void **)malloc_type_calloc(8uLL, v37, 0xF7EB24FFuLL);
    CFDictionaryGetKeysAndValues(v35, v38, v39);
    v48 = v39;
    if (v38 && v39)
    {
      v46 = a3;
      if (v37 >= 1)
      {
        v40 = 0;
        v41 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        do
        {
          v42 = CFStringCreateWithFormat(v41, 0, CFSTR("%@.%@"), a2, v38[v40]);
          if (v42)
          {
            v43 = v42;
            v44 = CGImageMetadataGetTagWithPath(a1, 0, v42);
            if (!a4[2](a4, v43, (uint64_t)v44))
            {
              free(v38);
              free(v48);
              CFRelease(v43);
              return;
            }
            if (BoolForKey)
              CGImageMetadataEnumerateTagsUsingBlockInternal(a1, v43, v46, a4);
            CFRelease(v43);
          }
          ++v40;
        }
        while (v37 != v40);
      }
    }
    else if (!v38)
    {
      goto LABEL_53;
    }
    free(v38);
LABEL_53:
    v31 = v48;
    if (!v48)
      return;
    goto LABEL_30;
  }
  v32 = (const void *)CGImageMetadataTagGetValue(v10);
  if (v32)
  {
    v15 = (uint64_t)v32;
    v33 = a4;
    v34 = CFGetTypeID(v32);
    if (v34 == CFArrayGetTypeID())
    {
      v49[0] = MEMORY[0x1E0C809B0];
      v49[1] = 0x40000000;
      v49[2] = ___ZL46CGImageMetadataEnumerateTagsUsingBlockInternalPK15CGImageMetadataPK10__CFStringP13IIODictionaryU13block_pointerFbS4_P18CGImageMetadataTagE_block_invoke_2;
      v49[3] = &unk_1E1BC4F00;
      v49[5] = a1;
      v49[6] = a2;
      v49[4] = v33;
      v17 = v49;
      goto LABEL_35;
    }
  }
}

CGImageMetadataRef CGImageMetadataCreateFromXMPData(CFDataRef data)
{
  CFDataRef v1;
  CFTypeID v2;
  unint64_t Length;
  unint64_t v4;
  const char *BytePtr;
  uint64_t v6;
  CGImageMetadata *MetadataFromXMPBuffer;
  const __CFDictionary *v8;

  v1 = data;
  if (data)
    CFDataGetLength(data);
  kdebug_trace();
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0)
    ImageIODebugOptions(3, "A", "CGImageMetadataCreateFromXMPData", 0, 0, -1, 0);
  if (v1)
  {
    v2 = CFGetTypeID(v1);
    if (v2 == CFDataGetTypeID() && (Length = CFDataGetLength(v1), Length >= 0x29))
    {
      v4 = Length;
      BytePtr = (const char *)CFDataGetBytePtr(v1);
      v6 = 29;
      if (!strncmp(BytePtr, kMainXMPSignatureString[0], 0x1DuLL)
        || (v6 = 0, v1 = 0, !strncmp(BytePtr, kMainXMPPlainString[0], 0x21uLL)))
      {
        MetadataFromXMPBuffer = CreateMetadataFromXMPBuffer(&BytePtr[v6], v4 - v6);
        v1 = MetadataFromXMPBuffer;
        if (MetadataFromXMPBuffer)
        {
          v8 = (const __CFDictionary *)*((_QWORD *)MetadataFromXMPBuffer + 3);
          if (v8)
            CFDictionaryGetCount(v8);
        }
      }
    }
    else
    {
      v1 = 0;
    }
  }
  kdebug_trace();
  return v1;
}

CFStringRef CGImageMetadataTagKeyCopyDescription(_QWORD *a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%@%@"), *a1, a1[1]);
}

unint64_t compareCGImageMetadataTagKey(CFStringRef *a1, CFStringRef *a2)
{
  CFComparisonResult v4;

  v4 = CFStringCompare(*a1, *a2, 0x61uLL);
  if (v4 < 0)
    return 1;
  if (v4)
    return 0;
  return (unint64_t)CFStringCompare(a1[1], a2[1], 0x61uLL) >> 63;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(CGImageMetadataTagKey const*,CGImageMetadataTagKey const*),CGImageMetadataTagKey**,false>(uint64_t result, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t), uint64_t a4, char a5)
{
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t *v17;
  char v18;
  BOOL v19;
  uint64_t v20;

  v8 = (uint64_t *)result;
LABEL_2:
  v9 = v8;
LABEL_3:
  v10 = 1 - a4;
  while (2)
  {
    v8 = v9;
    v11 = v10;
    v12 = (char *)a2 - (char *)v9;
    v13 = a2 - v9;
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        result = (*a3)(*(a2 - 1), *v9);
        if ((_DWORD)result)
        {
          v20 = *v9;
          *v9 = *(a2 - 1);
          *(a2 - 1) = v20;
        }
        return result;
      case 3uLL:
        return std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(v9, v9 + 1, a2 - 1, (unsigned int (**)(_QWORD))a3);
      case 4uLL:
        return std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(v9, v9 + 1, v9 + 2, a2 - 1, (unsigned int (**)(_QWORD))a3);
      case 5uLL:
        return std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(v9, v9 + 1, v9 + 2, v9 + 3, a2 - 1, (unsigned int (**)(_QWORD))a3);
      default:
        if (v12 <= 191)
        {
          if ((a5 & 1) != 0)
            return std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>((uint64_t)v9, a2, a3);
          else
            return std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>((uint64_t)v9, a2, a3);
        }
        if (v11 != 1)
        {
          v14 = v13 >> 1;
          v15 = &v9[v13 >> 1];
          if ((unint64_t)v12 < 0x401)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(&v9[v13 >> 1], v9, a2 - 1, (unsigned int (**)(_QWORD))a3);
            if ((a5 & 1) != 0)
              goto LABEL_12;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(v9, &v9[v13 >> 1], a2 - 1, (unsigned int (**)(_QWORD))a3);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(v9 + 1, v15 - 1, a2 - 2, (unsigned int (**)(_QWORD))a3);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(v9 + 2, &v9[v14 + 1], a2 - 3, (unsigned int (**)(_QWORD))a3);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(v15 - 1, v15, &v9[v14 + 1], (unsigned int (**)(_QWORD))a3);
            v16 = *v9;
            *v9 = *v15;
            *v15 = v16;
            if ((a5 & 1) != 0)
              goto LABEL_12;
          }
          if (((*a3)(*(v9 - 1), *v9) & 1) == 0)
          {
            result = (uint64_t)std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,IIOTag **,BOOL (*&)(IIOTag *,IIOTag *)>(v9, a2, a3);
            v9 = (uint64_t *)result;
            goto LABEL_17;
          }
LABEL_12:
          v17 = std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,IIOTag **,BOOL (*&)(IIOTag *,IIOTag *)>(v9, a2, a3);
          if ((v18 & 1) == 0)
            goto LABEL_15;
          v19 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGImageMetadataTagKey const*,CGImageMetadataTagKey const*),CGImageMetadataTagKey**>(v9, v17, (unsigned int (**)(_QWORD))a3);
          v9 = v17 + 1;
          result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGImageMetadataTagKey const*,CGImageMetadataTagKey const*),CGImageMetadataTagKey**>(v17 + 1, a2, (unsigned int (**)(_QWORD))a3);
          if (!(_DWORD)result)
          {
            v10 = v11 + 1;
            if (v19)
              continue;
LABEL_15:
            result = std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(CGImageMetadataTagKey const*,CGImageMetadataTagKey const*),CGImageMetadataTagKey**,false>(v8, v17, a3, -v11, a5 & 1);
            v9 = v17 + 1;
LABEL_17:
            a5 = 0;
            a4 = -v11;
            goto LABEL_3;
          }
          a4 = -v11;
          a2 = v17;
          if (v19)
            return result;
          goto LABEL_2;
        }
        if (v9 != a2)
          return (uint64_t)std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **,IIOTag **>((char *)v9, (char *)a2, a2, a3);
        return result;
    }
  }
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGImageMetadataTagKey const*,CGImageMetadataTagKey const*),CGImageMetadataTagKey**>(_QWORD *a1, _QWORD *a2, unsigned int (**a3)(_QWORD))
{
  uint64_t v6;
  _BOOL8 result;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  _QWORD *v16;

  v6 = a2 - a1;
  result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (((unsigned int (*)(_QWORD, _QWORD))*a3)(*(a2 - 1), *a1))
      {
        v8 = *a1;
        *a1 = *(a2 - 1);
        *(a2 - 1) = v8;
      }
      return 1;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(a1, a1 + 1, a2 - 1, a3);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1;
    default:
      v9 = a1 + 2;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(a1, a1 + 1, a1 + 2, a3);
      v10 = a1 + 3;
      if (a1 + 3 == a2)
        return 1;
      v11 = 0;
      v12 = 0;
      break;
  }
  while (1)
  {
    if (((unsigned int (*)(_QWORD, _QWORD))*a3)(*v10, *v9))
    {
      v13 = *v10;
      v14 = v11;
      while (1)
      {
        v15 = (char *)a1 + v14;
        *(_QWORD *)((char *)a1 + v14 + 24) = *(_QWORD *)((char *)a1 + v14 + 16);
        if (v14 == -16)
          break;
        v14 -= 8;
        if ((((uint64_t (*)(uint64_t, _QWORD))*a3)(v13, *((_QWORD *)v15 + 1)) & 1) == 0)
        {
          v16 = (_QWORD *)((char *)a1 + v14 + 24);
          goto LABEL_12;
        }
      }
      v16 = a1;
LABEL_12:
      *v16 = v13;
      if (++v12 == 8)
        return v10 + 1 == a2;
    }
    v9 = v10;
    v11 += 8;
    if (++v10 == a2)
      return 1;
  }
}

uint64_t makeTagsImmutableArrayApplier(CFTypeRef cf, void *a2, void *a3)
{
  return makeTagsImmutableDictionaryApplier(cf, cf, a3);
}

void ___ZL46CGImageMetadataEnumerateTagsUsingBlockInternalPK15CGImageMetadataPK10__CFStringP13IIODictionaryU13block_pointerFbS4_P18CGImageMetadataTagE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  const __CFString *v6;
  const __CFString *v7;

  v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%@[%ld]"), *(_QWORD *)(a1 + 40), a3);
  if (v6)
  {
    v7 = v6;
    CGImageMetadataGetTagWithPath(*(_QWORD **)(a1 + 48), 0, v6);
    if (((*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))() & 1) != 0)
    {
      if (*(_BYTE *)(a1 + 64))
        CGImageMetadataEnumerateTagsUsingBlockInternal(*(_QWORD *)(a1 + 48), v7, *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 32));
      CFRelease(v7);
    }
    else
    {
      CFRelease(v7);
      *a4 = 1;
    }
  }
}

void ___ZL46CGImageMetadataEnumerateTagsUsingBlockInternalPK15CGImageMetadataPK10__CFStringP13IIODictionaryU13block_pointerFbS4_P18CGImageMetadataTagE_block_invoke_2(uint64_t a1, void *a2, uint64_t a3, _BYTE *a4)
{
  void *TagWithPath;
  uint64_t Source;
  CFStringRef v8;
  CFStringRef v9;
  char v10;

  TagWithPath = CGImageMetadataGetTagWithPath(*(_QWORD **)(a1 + 40), a2, CFSTR("?xml:lang"));
  Source = CGImageSourceGetSource((uint64_t)TagWithPath);
  if (TagWithPath)
  {
    v8 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%@[%@]"), *(_QWORD *)(a1 + 48), *(_QWORD *)(Source + 48));
    if (v8)
    {
      v9 = v8;
      v10 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
      CFRelease(v9);
      if ((v10 & 1) == 0)
        *a4 = 1;
    }
  }
}

uint64_t DumpModeEncode(_QWORD *a1, uint64_t __src, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  char *v9;
  uint64_t v11;
  uint64_t v12;
  int64_t v13;
  char *v14;
  char *v15;
  uint64_t v16;
  uint64_t result;
  BOOL v18;

  if (a3 < 1)
    return 1;
  v8 = a3;
  v9 = (char *)__src;
  while (1)
  {
    v11 = a1[145];
    v12 = a1[141];
    if (v11 + v8 <= v12)
      v13 = v8;
    else
      v13 = v12 - v11;
    if (v13 <= 0)
      DumpModeEncode_cold_1();
    v14 = (char *)a1[144];
    if (v14 == v9)
    {
      v15 = v9;
    }
    else
    {
      _TIFFmemcpy(v14, v9, v13);
      v15 = (char *)a1[144];
      v11 = a1[145];
      v12 = a1[141];
    }
    a1[144] = &v15[v13];
    v16 = v11 + v13;
    a1[145] = v16;
    if (v16 >= v12)
    {
      result = TIFFFlushData1((uint64_t)a1, __src, a3, a4, a5, a6, a7, a8);
      if (!(_DWORD)result)
        break;
    }
    v9 += v13;
    v18 = v8 <= v13;
    v8 -= v13;
    if (v18)
      return 1;
  }
  return result;
}

uint64_t DumpModeSeek(_QWORD *a1, unsigned int a2)
{
  uint64_t v2;

  v2 = a1[138] * a2;
  a1[144] += v2;
  a1[145] -= v2;
  return 1;
}

void releaseGlobalInfoJP2(void *a1)
{
  if (a1)
    free(a1);
}

uint64_t GlobalJP2Info::GlobalJP2Info(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  BOOL v4;
  size_t v6;
  void *v7;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  v3 = *(unsigned int *)(a2 + 4);
  *(_DWORD *)(a1 + 4) = v3;
  *(_QWORD *)(a1 + 8) = 0;
  if (*(_QWORD *)(a2 + 8))
    v4 = v3 >> 30 == 0;
  else
    v4 = 0;
  if (v4)
  {
    v6 = 4 * v3;
    v7 = malloc_type_malloc(4 * v3, 0x35BE2623uLL);
    *(_QWORD *)(a1 + 8) = v7;
    memcpy(v7, *(const void **)(a2 + 8), v6);
  }
  return a1;
}

void GlobalJP2Info::~GlobalJP2Info(void **this)
{
  free(this[1]);
}

double JP2ReadPlugin::JP2ReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t v5;
  double result;

  v5 = IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *(_QWORD *)v5 = &off_1E1BAD1B8;
  result = 0.0;
  *(_OWORD *)(v5 + 440) = 0u;
  *(_OWORD *)(v5 + 456) = 0u;
  *(_OWORD *)(v5 + 472) = 0u;
  *(_OWORD *)(v5 + 488) = 0u;
  *(_OWORD *)(v5 + 504) = 0u;
  *(_OWORD *)(v5 + 520) = 0u;
  *(_OWORD *)(v5 + 536) = 0u;
  *(_OWORD *)(v5 + 552) = 0u;
  *(_OWORD *)(v5 + 568) = 0u;
  *(_OWORD *)(v5 + 584) = 0u;
  *(_OWORD *)(v5 + 600) = 0u;
  *(_OWORD *)(v5 + 616) = 0u;
  *(_QWORD *)(v5 + 632) = 0;
  return result;
}

double JP2ReadPlugin::JP2ReadPlugin(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  double result;

  v3 = IIOReadPlugin::IIOReadPlugin(a1, a2, a3);
  *(_QWORD *)v3 = &off_1E1BAD1B8;
  result = 0.0;
  *(_OWORD *)(v3 + 440) = 0u;
  *(_OWORD *)(v3 + 456) = 0u;
  *(_OWORD *)(v3 + 472) = 0u;
  *(_OWORD *)(v3 + 488) = 0u;
  *(_OWORD *)(v3 + 504) = 0u;
  *(_OWORD *)(v3 + 520) = 0u;
  *(_OWORD *)(v3 + 536) = 0u;
  *(_OWORD *)(v3 + 552) = 0u;
  *(_OWORD *)(v3 + 568) = 0u;
  *(_OWORD *)(v3 + 584) = 0u;
  *(_OWORD *)(v3 + 600) = 0u;
  *(_OWORD *)(v3 + 616) = 0u;
  *(_QWORD *)(v3 + 632) = 0;
  return result;
}

void JP2ReadPlugin::~JP2ReadPlugin(JP2ReadPlugin *this)
{
  const void *v2;

  *(_QWORD *)this = &off_1E1BAD1B8;
  _cg_JP2TearDownDecompressor((_QWORD *)this + 55);
  v2 = (const void *)*((_QWORD *)this + 67);
  if (v2)
    CFRelease(v2);
  IIOReadPlugin::~IIOReadPlugin(this);
}

{
  JP2ReadPlugin::~JP2ReadPlugin(this);
  JUMPOUT(0x18D761C30);
}

uint64_t JP2ReadPlugin::loadDataFromXPCObject(JP2ReadPlugin *this, void *a2)
{
  uint64_t result;
  const void *data;
  size_t v6;
  const void *v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  CFDataRef v17;
  size_t length;

  result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!(_DWORD)result)
  {
    length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_jp2", &length);
    v6 = length;
    if (length < 0xC8)
    {
      return 4294967246;
    }
    else
    {
      v7 = data;
      result = 0;
      *(_OWORD *)((char *)this + 440) = *(_OWORD *)v7;
      v8 = *((_OWORD *)v7 + 1);
      v9 = *((_OWORD *)v7 + 2);
      v10 = *((_OWORD *)v7 + 4);
      *(_OWORD *)((char *)this + 488) = *((_OWORD *)v7 + 3);
      *(_OWORD *)((char *)this + 504) = v10;
      *(_OWORD *)((char *)this + 456) = v8;
      *(_OWORD *)((char *)this + 472) = v9;
      v11 = *((_OWORD *)v7 + 5);
      v12 = *((_OWORD *)v7 + 6);
      v13 = *((_OWORD *)v7 + 8);
      *(_OWORD *)((char *)this + 552) = *((_OWORD *)v7 + 7);
      *(_OWORD *)((char *)this + 568) = v13;
      *(_OWORD *)((char *)this + 520) = v11;
      *(_OWORD *)((char *)this + 536) = v12;
      v14 = *((_OWORD *)v7 + 9);
      v15 = *((_OWORD *)v7 + 10);
      v16 = *((_OWORD *)v7 + 11);
      *((_QWORD *)this + 79) = *((_QWORD *)v7 + 24);
      *(_OWORD *)((char *)this + 600) = v15;
      *(_OWORD *)((char *)this + 616) = v16;
      *(_OWORD *)((char *)this + 584) = v14;
      *((_QWORD *)this + 55) = *((_QWORD *)this + 3);
      *((_QWORD *)this + 58) = MyRead;
      *((_QWORD *)this + 59) = MySeek;
      *((_QWORD *)this + 57) = *((_QWORD *)this + 24);
      *((_QWORD *)this + 60) = 0;
      *((_DWORD *)this + 122) = 0;
      *((_QWORD *)this + 62) = 0;
      *((_QWORD *)this + 67) = 0;
      *((_QWORD *)this + 73) = 0;
      *((_QWORD *)this + 74) = 0;
      if (v6 != 200)
      {
        v17 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)v7 + 200, v6 - 200);
        result = 0;
        *((_QWORD *)this + 67) = v17;
      }
    }
  }
  return result;
}

unint64_t MySeek(IIOImageReadSession *a1, unint64_t a2)
{
  return IIOImageReadSession::seek(a1, a2, 0);
}

uint64_t JP2ReadPlugin::saveDataToXPCObject(JP2ReadPlugin *this, void *a2)
{
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  const __CFData *v10;
  CFIndex v11;
  __CFData *Mutable;
  const UInt8 *BytePtr;
  CFIndex Length;
  _OWORD v16[2];
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  CFDataRef theData[2];
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;

  v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!(_DWORD)v4)
  {
    v27 = *((_QWORD *)this + 79);
    v5 = *(_OWORD *)((char *)this + 616);
    v25 = *(_OWORD *)((char *)this + 600);
    v26 = v5;
    v6 = *(_OWORD *)((char *)this + 552);
    *(_OWORD *)theData = *(_OWORD *)((char *)this + 536);
    v22 = v6;
    v7 = *(_OWORD *)((char *)this + 584);
    v23 = *(_OWORD *)((char *)this + 568);
    v24 = v7;
    v8 = *(_OWORD *)((char *)this + 488);
    v17 = *(_OWORD *)((char *)this + 472);
    v18 = v8;
    v9 = *(_OWORD *)((char *)this + 520);
    v19 = *(_OWORD *)((char *)this + 504);
    v20 = v9;
    v10 = theData[0];
    theData[0] = 0;
    memset(v16, 0, sizeof(v16));
    v17 = 0u;
    v18 = 0u;
    v24 = 0uLL;
    if (v10)
      v11 = CFDataGetLength(v10) + 200;
    else
      v11 = 200;
    Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v11);
    CFDataAppendBytes(Mutable, (const UInt8 *)v16, 200);
    if (v10)
    {
      BytePtr = CFDataGetBytePtr(v10);
      Length = CFDataGetLength(v10);
      CFDataAppendBytes(Mutable, BytePtr, Length);
    }
    iio_xpc_dictionary_add_CFData(a2, "iio_xpc_plugin_data_jp2", Mutable);
    CFRelease(Mutable);
  }
  return v4;
}

BOOL JP2ReadPlugin::hasNoLength(JP2ReadPlugin *this, int a2)
{
  return (a2 - 65328) < 0x10 || (a2 - 65426) < 2 || a2 == 65359 || a2 == 65497;
}

CGColorSpaceRef JP2ReadPlugin::createColorSpaceForJP2(uint64_t a1, uint64_t a2, int a3)
{
  CGColorSpaceRef v5;
  int v6;
  int v7;
  CFStringRef *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  CGColorSpace *v13;
  CFStringRef *v14;
  unsigned int NumberOfComponents;
  unsigned __int8 *Palette;
  unsigned __int8 *v17;
  size_t v18;
  CGColorSpaceRef Indexed;
  uint64_t v21;

  v5 = 0;
  v6 = *(_DWORD *)(a2 + 80);
  if (v6 <= 99)
  {
    v7 = v6 - 12;
    v8 = (CFStringRef *)MEMORY[0x1E0C9D968];
    switch(v7)
    {
      case 0:
        goto LABEL_12;
      case 4:
      case 6:
        goto LABEL_3;
      case 5:
        goto LABEL_11;
      default:
        goto LABEL_13;
    }
    goto LABEL_13;
  }
  v9 = *(_QWORD *)(a2 + 96);
  switch(v6)
  {
    case 'd':
      v5 = (CGColorSpaceRef)MEMORY[0x18D760CAC](v9);
      if (v5)
        goto LABEL_16;
LABEL_11:
      v8 = (CFStringRef *)MEMORY[0x1E0C9D978];
      goto LABEL_12;
    case 'e':
      v5 = (CGColorSpaceRef)MEMORY[0x18D760CAC](v9);
      if (v5)
        goto LABEL_16;
      goto LABEL_3;
    case 'f':
      v10 = *(_QWORD *)(a2 + 88);
      v5 = (CGColorSpaceRef)MEMORY[0x18D760CAC](v9);
      if (v5)
        goto LABEL_16;
      if ((unint64_t)(v10 - 1) <= 3)
      {
        v8 = (CFStringRef *)qword_1E1BC4F20[v10 - 1];
        goto LABEL_12;
      }
LABEL_3:
      v8 = (CFStringRef *)MEMORY[0x1E0C9DA10];
LABEL_12:
      v5 = CGColorSpaceCreateWithName(*v8);
      break;
  }
LABEL_13:
  if (!v5 && a3)
    v5 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
LABEL_16:
  if (!*(_BYTE *)(a2 + 179))
    return v5;
  v11 = 1380401696;
  v21 = 0;
  v12 = *(_DWORD *)(a2 + 80);
  if (v12 > 99)
  {
    if (v12 == 100)
      goto LABEL_28;
    if (v12 != 102)
      goto LABEL_29;
    if (*(_QWORD *)(a2 + 88) == 1)
      v11 = 1196573017;
    else
      v11 = 1380401696;
    if (!v5)
    {
LABEL_35:
      if (v11 == 1129142603)
      {
        v14 = (CFStringRef *)MEMORY[0x1E0C9D968];
      }
      else if (v11 == 1196573017)
      {
        v14 = (CFStringRef *)MEMORY[0x1E0C9D978];
      }
      else
      {
        v14 = (CFStringRef *)MEMORY[0x1E0C9DA10];
      }
      v13 = CGColorSpaceCreateWithName(*v14);
      if (!v13)
        return v5;
      goto LABEL_41;
    }
  }
  else
  {
    if (v12 != 12)
    {
      if (v12 != 17)
      {
LABEL_29:
        if (!v5)
          goto LABEL_35;
        goto LABEL_30;
      }
LABEL_28:
      v11 = 1196573017;
      goto LABEL_29;
    }
    v11 = 1129142603;
    if (!v5)
      goto LABEL_35;
  }
LABEL_30:
  v13 = (CGColorSpace *)CFRetain(v5);
  if (!v13)
    goto LABEL_35;
LABEL_41:
  NumberOfComponents = CGColorSpaceGetNumberOfComponents(v13);
  Palette = _cg_JP2GetPalette(a2, NumberOfComponents, (int *)&v21 + 1, &v21);
  if (Palette)
  {
    v17 = Palette;
    v18 = (int)v21;
    if (CGColorSpaceGetNumberOfComponents(v13) <= v18)
    {
      Indexed = CGColorSpaceCreateIndexed(v13, SHIDWORD(v21) - 1, v17);
      if (v5)
        CGColorSpaceRelease(v5);
    }
    else
    {
      Indexed = v5;
    }
    free(v17);
    v5 = Indexed;
  }
  CFRelease(v13);
  return v5;
}

uint64_t JP2ReadPlugin::validateJ2K(JP2ReadPlugin *this, IIOScanner *a2, unint64_t a3, BOOL *a4)
{
  unint64_t v7;
  unint64_t v8;
  char v9;
  char v10;
  char v11;
  unint64_t v12;
  JP2ReadPlugin *Val16;
  int v14;
  uint64_t v15;
  JP2ReadPlugin *v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char v20;
  unint64_t v22;
  uint64_t v23;
  _QWORD __dst[2];

  __dst[1] = *MEMORY[0x1E0C80C00];
  v7 = *((_QWORD *)a2 + 3);
  if (a4)
    *a4 = 0;
  v8 = v7 + a3;
  if (v7 < v7 + a3)
  {
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v22 = a3 + 10;
    v23 = 0;
    while (1)
    {
      Val16 = (JP2ReadPlugin *)IIOScanner::getVal16(a2);
      v14 = (int)Val16;
      if (!(_DWORD)Val16)
        goto LABEL_45;
      if (JP2ReadPlugin::hasNoLength(Val16, (int)Val16))
      {
        if (v14 == 65427)
        {
          if (v12 + 1 < 0xF)
            goto LABEL_49;
          v15 = v12 - 14;
LABEL_33:
          v9 = 1;
          goto LABEL_40;
        }
        v15 = 0;
      }
      else
      {
        v16 = (JP2ReadPlugin *)IIOScanner::getVal16(a2);
        if (v16 < 2)
          goto LABEL_49;
        v15 = v16 - 2;
        switch(v14)
        {
          case 65424:
            __dst[0] = 0;
            IIOScanner::copyBytes(a2, __dst, 8uLL);
            IIOScanner::skip((uint64_t)a2, 8);
            if (BYTE6(__dst[0]) == 255)
              goto LABEL_49;
            v18 = *((_QWORD *)a2 + 3);
            if (*(_DWORD *)((char *)__dst + 2))
            {
              v12 = bswap32(*(unsigned int *)((char *)__dst + 2));
            }
            else
            {
              if (v18 + 10 > a3)
              {
LABEL_49:
                v20 = 0;
                return v20 & 1;
              }
              v12 = v22 - v18;
            }
            IIOScanner::seek(a2, v18 - 8);
            goto LABEL_40;
          case 65362:
            v19 = *((_QWORD *)a2 + 3);
            if (!JP2ReadPlugin::checkCodingStyleDefaultBox(v16, a2))
              goto LABEL_49;
            IIOScanner::seek(a2, v19);
LABEL_29:
            v10 = 1;
            goto LABEL_40;
          case 65361:
            v17 = *((_QWORD *)a2 + 3);
            if (!JP2ReadPlugin::checkImageTileSizeBox(v16, a2))
              goto LABEL_49;
            IIOScanner::seek(a2, v17);
LABEL_30:
            v11 = 1;
            goto LABEL_40;
        }
        if (v12)
        {
          if (v12 < 5)
            goto LABEL_49;
          v12 = v12 - v16 - 2;
        }
      }
      if (v14 > 65371)
      {
        switch(v14)
        {
          case 65372:
            LOBYTE(v23) = 1;
            break;
          case 65427:
            goto LABEL_33;
          case 65497:
            if (a4)
              *a4 = 1;
            goto LABEL_45;
        }
      }
      else
      {
        switch(v14)
        {
          case 65359:
            BYTE4(v23) = 1;
            break;
          case 65361:
            goto LABEL_30;
          case 65362:
            goto LABEL_29;
        }
      }
LABEL_40:
      if (v15)
        IIOScanner::skip((uint64_t)a2, v15);
      if (*((_QWORD *)a2 + 3) >= v8)
        goto LABEL_45;
    }
  }
  v23 = 0;
  v11 = 0;
  v10 = 0;
  v9 = 0;
LABEL_45:
  v20 = BYTE4(v23) & v11 & v10 & v23 & v9;
  return v20 & 1;
}

BOOL JP2ReadPlugin::checkImageTileSizeBox(JP2ReadPlugin *this, IIOScanner *a2)
{
  IIOScanner::getVal16(a2);
  IIOScanner::getVal32(a2);
  IIOScanner::getVal32(a2);
  IIOScanner::getVal32(a2);
  IIOScanner::getVal32(a2);
  IIOScanner::getVal32(a2);
  IIOScanner::getVal32(a2);
  IIOScanner::getVal32(a2);
  IIOScanner::getVal32(a2);
  IIOScanner::getVal16(a2);
  return (IIOScanner::getVal8(a2) & 0x7F) - 1 < 0x26;
}

uint64_t JP2ReadPlugin::checkCodingStyleDefaultBox(JP2ReadPlugin *this, IIOScanner *a2)
{
  unsigned int Val8;
  int Val16;
  unsigned int v5;
  unsigned int v6;
  double v7;

  IIOScanner::getVal8(a2);
  Val8 = IIOScanner::getVal8(a2);
  Val16 = IIOScanner::getVal16(a2);
  IIOScanner::getVal8(a2);
  v5 = IIOScanner::getVal8(a2);
  v6 = IIOScanner::getVal8(a2);
  IIOScanner::getVal8(a2);
  IIOScanner::getVal8(a2);
  if (Val8 >= 5)
    *(_QWORD *)&v7 = _cg_jpeg_mem_term("checkCodingStyleDefaultBox", 1183, "*** ERROR: unexpected 'Progression order for the SGcod, SPcoc, and Ppoc parameters' (%d)\n", Val8).n128_u64[0];
  if (Val16)
  {
    if (v5 >= 0x21)
    {
      _cg_jpeg_mem_term("checkCodingStyleDefaultBox", 1189, "*** ERROR: bad 'COD NumDecompositionLevels' (%d)\n", v7);
    }
    else if (v6 >= 0xFE)
    {
      _cg_jpeg_mem_term("checkCodingStyleDefaultBox", 1192, "*** ERROR: bad 'COD CodeBlockWidth' (%d)\n", v7);
    }
    else
    {
      if ((v6 + 2) < 0xBu)
        return 1;
      _cg_jpeg_mem_term("checkCodingStyleDefaultBox", 1193, "*** ERROR: bad 'COD CodeBlockWidth' (%d)\n", v7);
    }
  }
  else
  {
    _cg_jpeg_mem_term("checkCodingStyleDefaultBox", 1186, "*** ERROR: bad 'COD NumberOfLayers' (%d)\n", v7);
  }
  return 0;
}

BOOL JP2ReadPlugin::checkFileTypeBox(JP2ReadPlugin *this, IIOScanner *a2, int a3)
{
  int Val32;
  int v6;
  int v7;
  int v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int v21;
  int v22;
  unsigned int v24;
  int v25;

  if ((a3 & 3) != 0)
  {
    _cg_jpeg_mem_term("checkFileTypeBox", 923, "*** ERROR: bad JP2 FileBox size [%lld]\n");
  }
  else
  {
    Val32 = IIOScanner::getVal32(a2);
    if (Val32 == 1785737760 || (v6 = Val32, Val32 == 1785755680))
    {
      v7 = IIOScanner::getVal32(a2);
      if (v7)
      {
        v8 = v7;
        if (v7 != 1785737760)
        {
          v9 = v7 >> 24;
          if (v7 < 0)
            v10 = __maskrune(v7 >> 24, 0x40000uLL);
          else
            v10 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v9 + 60) & 0x40000;
          if (v10)
            v11 = v9;
          else
            v11 = 46;
          v12 = v8 << 8 >> 24;
          if (v8 << 8 < 0)
            v13 = __maskrune(v8 << 8 >> 24, 0x40000uLL);
          else
            v13 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v12 + 60) & 0x40000;
          if (v13)
            v14 = v12;
          else
            v14 = 46;
          v15 = (__int16)v8 >> 8;
          if (v8 << 16 < 0)
            v16 = __maskrune((__int16)v8 >> 8, 0x40000uLL);
          else
            v16 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v15 + 60) & 0x40000;
          if (v16)
            v17 = v15;
          else
            v17 = 46;
          if ((v8 << 24) <= 0x7F000000)
            v18 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v8 + 60) & 0x40000;
          else
            v18 = __maskrune((char)v8, 0x40000uLL);
          if (v18)
            v19 = (char)v8;
          else
            v19 = 46;
          LogWarning("checkFileTypeBox", 935, "*** NOTE: JPEG2000 - bad minorVersion? [0x%08X] '%c%c%c%c'\n", v8, v11, v14, v17, v19);
        }
      }
      v20 = a3 - 8;
      if ((a3 - 8) >= 4)
      {
        v21 = v20 >> 2;
        if (v20 >> 2 <= 1)
          v22 = 1;
        else
          v22 = v20 >> 2;
        if (IIOScanner::getVal32(a2) == 1785737760)
          return 1;
        v24 = 0;
        v25 = v22 - 1;
        while (v25 != v24)
        {
          ++v24;
          if (IIOScanner::getVal32(a2) == 1785737760)
            return v24 < v21;
        }
      }
      _cg_jpeg_mem_term("checkFileTypeBox", 952, "*** ERROR: CompatibleBrands does not contain 'jp2 '\n");
    }
    else
    {
      if (Val32 < 0)
        __maskrune(Val32 >> 24, 0x40000uLL);
      if (v6 << 8 < 0)
        __maskrune(v6 << 8 >> 24, 0x40000uLL);
      if (v6 << 16 < 0)
        __maskrune((__int16)v6 >> 8, 0x40000uLL);
      if ((v6 << 24) > 0x7F000000)
        __maskrune((char)v6, 0x40000uLL);
      _cg_jpeg_mem_term("checkFileTypeBox", 927, "*** ERROR: bad majorBrand '%c%c%c%c' [%08X]\n");
    }
  }
  return 0;
}

uint64_t JP2ReadPlugin::checkJP2HeaderBox(JP2ReadPlugin *this, IIOScanner *a2, uint64_t a3)
{
  uint64_t v5;
  int Val32;
  JP2ReadPlugin *v7;
  uint64_t result;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  char v12;
  unint64_t v13;
  JP2ReadPlugin *v14;
  unint64_t v15;
  int v16;

  v5 = *((_QWORD *)a2 + 3);
  Val32 = IIOScanner::getVal32(a2);
  v7 = (JP2ReadPlugin *)IIOScanner::getVal32(a2);
  if ((_DWORD)v7 == 1768449138)
  {
    if (Val32 == 22)
    {
      result = JP2ReadPlugin::checkImageHeaderBox(v7, a2);
      if (!(_DWORD)result)
        return result;
      v9 = *((_QWORD *)a2 + 3);
      v10 = IIOScanner::getVal32(a2);
      if (v10)
      {
        v11 = v10;
        v12 = 0;
        v13 = v5 + a3;
        do
        {
          v14 = (JP2ReadPlugin *)IIOScanner::getVal32(a2);
          if ((_DWORD)v14 == 1885564018)
          {
            IIOScanner::getVal16(a2);
            IIOScanner::getVal8(a2);
          }
          else if ((_DWORD)v14 == 1668246642)
          {
            if ((JP2ReadPlugin::checkColorSpecificationBox(v14, a2, v11) & 1) == 0)
              return 0;
            v12 = 1;
          }
          v15 = v9 + v11;
          if (v13 <= v15)
            break;
          IIOScanner::seek(a2, v15);
          v9 = *((_QWORD *)a2 + 3);
          v11 = IIOScanner::getVal32(a2);
        }
        while (v11);
        if ((v12 & 1) != 0)
          return 1;
      }
      _cg_jpeg_mem_term("checkJP2HeaderBox", 1019, "*** ERROR: JP2HeaderBox: ihdr has no ColorSpecificationBox\n");
    }
    else
    {
      _cg_jpeg_mem_term("checkJP2HeaderBox", 975, "*** ERROR: JP2HeaderBox: ihdr marker has wrong size (%d)\n");
    }
  }
  else
  {
    v16 = (int)v7;
    if ((v7 & 0x80000000) != 0)
      __maskrune((int)v7 >> 24, 0x40000uLL);
    if (v16 << 8 < 0)
      __maskrune(v16 << 8 >> 24, 0x40000uLL);
    if (v16 << 16 < 0)
      __maskrune((__int16)v16 >> 8, 0x40000uLL);
    if ((v16 << 24) > 0x7F000000)
      __maskrune((char)v16, 0x40000uLL);
    _cg_jpeg_mem_term("checkJP2HeaderBox", 974, "*** ERROR: JP2HeaderBox - expected 'ihdr' marker, got '%c%c%c%c' [%08X]\n");
  }
  return 0;
}

uint64_t JP2ReadPlugin::checkImageHeaderBox(JP2ReadPlugin *this, IIOScanner *a2)
{
  int Val32;
  int v4;
  int Val16;
  int Val8;
  int v7;
  unsigned int v8;

  Val32 = IIOScanner::getVal32(a2);
  v4 = IIOScanner::getVal32(a2);
  Val16 = IIOScanner::getVal16(a2);
  Val8 = IIOScanner::getVal8(a2);
  v7 = IIOScanner::getVal8(a2);
  IIOScanner::getVal8(a2);
  v8 = IIOScanner::getVal8(a2);
  if (Val32)
  {
    if (v4)
    {
      if ((Val16 - 16385) <= 0xFFFFBFFF)
      {
        _cg_jpeg_mem_term("checkImageHeaderBox", 1042, "*** ERROR: invalid JP2: numberOfComponents == %d\n");
      }
      else if ((Val8 - 39) > 0xFFFFFFD9 || Val16 == 255)
      {
        if (v7 == 7)
        {
          if (v8 < 2)
            return 1;
          _cg_jpeg_mem_term("checkImageHeaderBox", 1045, "*** ERROR: invalid JP2: interlectualProperty == %d\n");
        }
        else
        {
          _cg_jpeg_mem_term("checkImageHeaderBox", 1044, "*** ERROR: invalid JP2: compression == %d\n");
        }
      }
      else
      {
        _cg_jpeg_mem_term("checkImageHeaderBox", 1043, "*** ERROR: invalid JP2: numberOfComponents == %d\n");
      }
    }
    else
    {
      _cg_jpeg_mem_term("checkImageHeaderBox", 1041, "*** ERROR: invalid JP2: height == 0\n");
    }
  }
  else
  {
    _cg_jpeg_mem_term("checkImageHeaderBox", 1040, "*** ERROR: invalid JP2: width == 0\n");
  }
  return 0;
}

uint64_t JP2ReadPlugin::checkColorSpecificationBox(JP2ReadPlugin *this, IIOScanner *a2, uint64_t a3)
{
  int Val8;
  double v6;
  int Val32;
  double v8;

  Val8 = IIOScanner::getVal8(a2);
  if (a3 == 15 && (Val8 - 3) <= 0xFFFFFFFD)
  {
    _cg_jpeg_mem_term("checkColorSpecificationBox", 1060, "*** ERROR: invalid JP2: colorSpecMethod == %d\n", v6);
    return 0;
  }
  if (Val8 == 1)
  {
    IIOScanner::skip((uint64_t)a2, 2);
    Val32 = IIOScanner::getVal32(a2);
    if ((Val32 - 1) >= 0x18 || ((0xFFFD0Du >> (Val32 - 1)) & 1) == 0)
    {
      *(_QWORD *)&v8 = _cg_jpeg_mem_term("checkColorSpecificationBox", 1097, "*** ERROR: unsupported colorSpace (%d)\n", Val32).n128_u64[0];
      _cg_jpeg_mem_term("checkColorSpecificationBox", 1100, "*** ERROR: invalid JP2 colorSpace: %d\n", v8);
      return 0;
    }
  }
  return 1;
}

BOOL JP2ReadPlugin::checkContinousCodestreamBox(JP2ReadPlugin *this, IIOScanner *a2)
{
  int Val16;
  uint64_t v4;
  JP2ReadPlugin *v5;
  unsigned int v6;
  _BOOL8 result;

  if (IIOScanner::getVal16(a2) == 65359)
  {
    while (1)
    {
      Val16 = IIOScanner::getVal16(a2);
      v4 = *((_QWORD *)a2 + 3);
      v5 = (JP2ReadPlugin *)IIOScanner::getVal16(a2);
      v6 = v5;
      if (Val16 <= 65361)
      {
        if (Val16 == 65361)
        {
          result = JP2ReadPlugin::checkImageTileSizeBox(v5, a2);
          if (!result)
            return result;
        }
      }
      else if (Val16 == 65362)
      {
        if ((JP2ReadPlugin::checkCodingStyleDefaultBox(v5, a2) & 1) == 0)
          return 0;
      }
      else
      {
        result = 1;
        if (Val16 == 65427 || Val16 == 65497)
          return result;
      }
      IIOScanner::seek(a2, v4 + v6);
    }
  }
  _cg_jpeg_mem_term("checkContinousCodestreamBox", 1212, "*** ERROR: invalid JP2: CodestreamBox missing SOC\n");
  return 1;
}

uint64_t JP2ReadPlugin::validateJP2(JP2ReadPlugin *this, IIOScanner *a2)
{
  unint64_t v3;
  uint64_t v4;
  int Val32;
  uint64_t v6;
  JP2ReadPlugin *Val64;
  int v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v22;
  char v23;
  char v24;

  v3 = *((_QWORD *)a2 + 2);
  v4 = *((_QWORD *)a2 + 3);
  Val32 = IIOScanner::getVal32(a2);
  if (v4 + 3 >= v3)
    goto LABEL_53;
  LODWORD(v6) = Val32;
  v22 = 0;
  v24 = 0;
  v23 = 0;
  do
  {
    Val64 = (JP2ReadPlugin *)IIOScanner::getVal32(a2);
    v8 = (int)Val64;
    if ((_DWORD)v6 == 1)
    {
      Val64 = (JP2ReadPlugin *)IIOScanner::getVal64(a2);
      v6 = (uint64_t)Val64;
    }
    else
    {
      v6 = v6;
    }
    if (v8 > 1785737826)
    {
      if (v8 == 1785737827)
      {
        if (!JP2ReadPlugin::checkContinousCodestreamBox(Val64, a2))
          return 0;
        LOBYTE(v22) = 1;
      }
      else if (v8 == 1785737832)
      {
        if ((JP2ReadPlugin::checkJP2HeaderBox(this, a2, v6) & 1) == 0)
          return 0;
        BYTE4(v22) = 1;
      }
    }
    else if (v8 == 1718909296)
    {
      if (!JP2ReadPlugin::checkFileTypeBox(Val64, a2, v6))
        return 0;
      v24 = 1;
    }
    else if (v8 == 1783636000)
    {
      if (IIOScanner::getVal32(a2) != 218793738)
        return 0;
      v23 = 1;
    }
    if (v6 + v4 == v3)
      break;
    if (v6 + v4 > v3)
    {
      v9 = v8 >> 24;
      v10 = v8 < 0 ? __maskrune(v8 >> 24, 0x40000uLL) : *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v9 + 60) & 0x40000;
      v11 = v10 ? v9 : 46;
      v12 = v8 << 8 >> 24;
      v13 = v8 << 8 < 0
          ? __maskrune(v8 << 8 >> 24, 0x40000uLL)
          : *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v12 + 60) & 0x40000;
      v14 = v13 ? v12 : 46;
      v15 = (__int16)v8 >> 8;
      v16 = v8 << 16 < 0
          ? __maskrune((__int16)v8 >> 8, 0x40000uLL)
          : *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v15 + 60) & 0x40000;
      v17 = v16 ? v15 : 46;
      v18 = (v8 << 24) <= 0x7F000000
          ? *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v8 + 60) & 0x40000
          : __maskrune((char)v8, 0x40000uLL);
      v19 = v18 ? (char)v8 : 46;
      _cg_jpeg_mem_term("validateJP2", 1309, "*** ERROR: marker '%c%c%c%c' length (%d) at offset (%d [0x%04X]) larger than fileSize(%d)\n", v11, v14, v17, v19, v6, v4, v4, v3);
      if (v8 != 1785737827)
        break;
    }
    IIOScanner::seek(a2, v6 + v4);
    if (!v6)
      break;
    v4 = *((_QWORD *)a2 + 3);
    LODWORD(v6) = IIOScanner::getVal32(a2);
  }
  while (v4 + 3 < v3);
  if ((v23 & 1) != 0)
  {
    if ((v24 & 1) != 0)
    {
      if ((v22 & 0x100000000) != 0)
      {
        if ((v22 & 1) != 0)
          return 1;
        _cg_jpeg_mem_term("validateJP2", 1326, "*** ERROR: no ContinousCodestreamBox\n");
      }
      else
      {
        _cg_jpeg_mem_term("validateJP2", 1325, "*** ERROR: no JP2HeaderBox\n");
      }
    }
    else
    {
      _cg_jpeg_mem_term("validateJP2", 1324, "*** ERROR: no FileTypeBox\n");
    }
  }
  else
  {
LABEL_53:
    _cg_jpeg_mem_term("validateJP2", 1323, "*** ERROR: no SignatureBox\n");
  }
  return 0;
}

uint64_t JP2ReadPlugin::isValidJP2000(JP2ReadPlugin *this)
{
  IIOImageRead *Size;
  int Val16;
  uint64_t v4;
  uint64_t v5;
  int v6;
  _OWORD v8[4];
  uint64_t v9;
  BOOL v10;

  v10 = 0;
  Size = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
  v9 = 0;
  memset(v8, 0, sizeof(v8));
  IIOScanner::IIOScanner((IIOScanner *)v8, *((IIOImageReadSession **)this + 3));
  GlobalHEIFInfo::setShouldExposeMultiFrameContents((uint64_t)v8, 0);
  IIOScanner::seek((IIOScanner *)v8, *((_QWORD *)this + 24));
  Val16 = IIOScanner::getVal16((IIOScanner *)v8);
  IIOScanner::seek((IIOScanner *)v8, *((_QWORD *)this + 24));
  if (Val16 == 65359)
  {
    v4 = JP2ReadPlugin::validateJ2K(this, (IIOScanner *)v8, (unint64_t)Size, &v10);
    v5 = v4;
    if (v10)
      v6 = 0;
    else
      v6 = v4;
    if (v6 == 1)
    {
      if (IIOImageReadSession::isFinal(*((IIOImageReadSession **)this + 3)))
      {
        _cg_jpeg_mem_term("isValidJP2000", 1355, "*** ERROR: missing EOC maker for final JPEG2000\n");
        v5 = 0;
      }
      else
      {
        v5 = 1;
      }
    }
  }
  else
  {
    v5 = JP2ReadPlugin::validateJP2(this, (IIOScanner *)v8);
  }
  IIOScanner::~IIOScanner((IIOScanner *)v8);
  return v5;
}

void sub_187FED89C(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187FED85CLL);
}

void sub_187FED8A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  IIOScanner::~IIOScanner((IIOScanner *)&a9);
  _Unwind_Resume(a1);
}

uint64_t JP2ReadPlugin::initialize(JP2ReadPlugin *this, IIODictionary *a2)
{
  uint64_t v4;
  IIODictionary *v5;
  unsigned int Uint32ForKey;
  unsigned int v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  IIOImageReadSession *v11;
  _QWORD *v12;
  unsigned int v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  const __CFDictionary *BoolForKey;
  uint64_t v20;
  int v21;
  int v22;
  int v24;
  CGColorSpaceRef ColorSpaceForJP2;
  int v26;
  int v27;
  int v28;
  char v30;
  unsigned int v31;
  unint64_t v32;
  uint64_t v34;
  _BYTE v35[24];
  _BYTE v36[24];
  float v37;
  float v38;

  v37 = 72.0;
  v38 = 72.0;
  v5 = (IIODictionary *)*((_QWORD *)this + 6);
  v4 = *((_QWORD *)this + 7);
  Uint32ForKey = IIODictionary::getUint32ForKey(a2, CFSTR("NEW_PLUGIN_expectedWidth"));
  v7 = IIODictionary::getUint32ForKey(a2, CFSTR("NEW_PLUGIN_expectedHeight"));
  if ((JP2ReadPlugin::isValidJP2000(this) & 1) == 0)
  {
    LogError("initialize", 1397, "*** invalid JPEG2000 file ***\n");
LABEL_5:
    v10 = 4294967246;
LABEL_6:
    kdebug_trace();
    return v10;
  }
  v8 = *((_QWORD *)this + 24);
  if (v8)
  {
    IIOImageReadSession::seek(*((IIOImageReadSession **)this + 3), v8, 0);
    v9 = *((_QWORD *)this + 24);
  }
  else
  {
    v9 = 0;
  }
  *((_OWORD *)this + 28) = 0u;
  *((_OWORD *)this + 29) = 0u;
  *((_QWORD *)this + 78) = 0;
  *((_OWORD *)this + 37) = 0u;
  *((_OWORD *)this + 38) = 0u;
  *((_OWORD *)this + 35) = 0u;
  *((_OWORD *)this + 36) = 0u;
  *((_OWORD *)this + 33) = 0u;
  *((_OWORD *)this + 34) = 0u;
  *((_OWORD *)this + 31) = 0u;
  *((_OWORD *)this + 32) = 0u;
  *((_OWORD *)this + 30) = 0u;
  v11 = (IIOImageReadSession *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 55) = v11;
  *((_QWORD *)this + 58) = MyRead;
  *((_QWORD *)this + 59) = MySeek;
  *((_QWORD *)this + 57) = v9;
  if (!IIOImageReadSession::globalInfoForType(v11, 1246769696))
  {
    v12 = malloc_type_calloc(1uLL, 0x10uLL, 0x1010040449DF08BuLL);
    v12[1] = 0;
    IIOImageReadSession::setGlobalInfo(*((IIOImageRead ***)this + 3), 1246769696, v12, releaseGlobalInfoJP2);
  }
  *((_BYTE *)this + 617) = 0;
  if (IIODictionary::containsKey(v5, CFSTR("kCGImageSourceSubsampleFactor")))
  {
    v13 = IIODictionary::getUint32ForKey(v5, CFSTR("kCGImageSourceSubsampleFactor"));
    *((_QWORD *)this + 76) = v13;
    if (v13 >= 2)
    {
      if (Uint32ForKey)
        Uint32ForKey /= v13;
      if (v7)
        v7 /= v13;
    }
  }
  *((_QWORD *)this + 75) = *((unsigned int *)this + 53);
  v14 = _cg_JP2SetupDecompressor((uint64_t)this + 440, (uint64_t)this + 440);
  if ((_DWORD)v14)
  {
    v34 = v14;
    _cg_jpeg_mem_term("initialize", 1457, "*** ERROR: JP2SetupDecompressor failed [%d]\n", v14);
    v10 = v34;
    goto LABEL_6;
  }
  if (Uint32ForKey && *((_QWORD *)this + 63) != Uint32ForKey)
  {
    _cg_jpeg_mem_term("initialize", 1460, "*** BAD WIDTH - expected: %d   got: %d\n");
    return 0;
  }
  if (v7 && *((_QWORD *)this + 64) != v7)
  {
    _cg_jpeg_mem_term("initialize", 1462, "*** BAD HEIGHT - expected: %d   got: %d\n");
    return 0;
  }
  v15 = *((_QWORD *)this + 63);
  if (v15 >> 5 > 0xC34)
    return 0;
  v16 = *((_QWORD *)this + 64);
  if (v16 > 0x1869F)
    return 0;
  if (37600 * *((_QWORD *)this + 23) <= v16 * v15)
  {
    _cg_jpeg_mem_term("initialize", 1472, "_rpd._fileSize * %d > pixelCount (%ld * %d > %ld)\n");
    return 0;
  }
  *((_DWORD *)this + 57) = v15;
  *((_DWORD *)this + 58) = v16;
  v17 = *((_QWORD *)this + 69);
  *((_WORD *)this + 120) = v17;
  v18 = *((_QWORD *)this + 71);
  *((_WORD *)this + 121) = v18;
  *((_WORD *)this + 122) = v18 / v17;
  *((_DWORD *)this + 59) = *((_QWORD *)this + 72);
  BoolForKey = IIODictionary::containsKey(a2, CFSTR("kCGImageSourceSkipAlpha"));
  if ((_DWORD)BoolForKey)
  {
    BoolForKey = (const __CFDictionary *)IIODictionary::getBoolForKey(a2, CFSTR("kCGImageSourceSkipAlpha"));
    if ((_DWORD)BoolForKey)
    {
      v20 = *((int *)this + 137);
      if (v20 <= 4)
        *((_DWORD *)this + 137) = dword_188211C30[v20];
    }
  }
  v21 = *((_DWORD *)this + 130);
  if (*((_BYTE *)this + 619))
  {
    if (v21 == 17)
    {
      _cg_jpeg_mem_term("initialize", 1554, "*** ERROR: indexedColor cannot be used with gray scale data\n");
      goto LABEL_5;
    }
    if (v21 == 18)
    {
      _cg_jpeg_mem_term("initialize", 1555, "*** ERROR: indexedColor cannot be used with YCC data\n");
      goto LABEL_5;
    }
    if (*((_QWORD *)this + 69) >= 9uLL)
    {
      _cg_jpeg_mem_term("initialize", 1556, "*** ERROR: %d bpp is not allowed for indexedColor\n");
      goto LABEL_5;
    }
  }
  else if (v21 == 12)
  {
    if (*((_QWORD *)this + 70) > 3uLL)
    {
      if (*((_DWORD *)this + 137)
        && 5 * *((unsigned __int16 *)this + 120) > *((unsigned __int16 *)this + 121))
      {
        *((_DWORD *)this + 137) = 0;
      }
    }
    else
    {
      *((_DWORD *)this + 130) = 16;
    }
  }
  v22 = *((_DWORD *)this + 57);
  v24 = v22 == *((_DWORD *)this + 58) && (v22 == 256 || v22 == 512);
  ColorSpaceForJP2 = JP2ReadPlugin::createColorSpaceForJP2((uint64_t)BoolForKey, (uint64_t)this + 440, v24);
  *((_QWORD *)this + 20) = ColorSpaceForJP2;
  v26 = *((unsigned __int8 *)this + 619);
  if (*((_BYTE *)this + 619) && !ColorSpaceForJP2)
  {
    _cg_jpeg_mem_term("initialize", 1582, "*** ERROR: indexed-color JP2, but no colorMap ");
    v10 = 4294967243;
    goto LABEL_6;
  }
  v27 = *((_DWORD *)this + 130);
  if (v27 > 99)
  {
    if (v27 == 102)
    {
      if (*((_QWORD *)this + 66) != 1)
        goto LABEL_52;
    }
    else if (v27 != 100)
    {
      goto LABEL_52;
    }
    goto LABEL_57;
  }
  if (v27 == 12)
  {
    v28 = 1129142603;
    goto LABEL_59;
  }
  if (v27 == 17)
  {
LABEL_57:
    v28 = 1196573017;
LABEL_59:
    *((_DWORD *)this + 81) = v28;
    goto LABEL_60;
  }
LABEL_52:
  *((_DWORD *)this + 81) = 1380401696;
  if (!v26 && 3 * *((unsigned __int16 *)this + 120) > *((unsigned __int16 *)this + 121))
  {
    LogError("initialize", 1590, "*** bad JP2 image (RGB: bpp = %d, bpc = %d)\n");
    goto LABEL_5;
  }
LABEL_60:
  *((_BYTE *)this + 246) = *((_BYTE *)this + 548) & 0x1F;
  *((_BYTE *)this + 344) = 0;
  *((_BYTE *)this + 346) = 0;
  *((_QWORD *)this + 45) = 1;
  _cg_JP2GetDisplayResolution((uint64_t)this + 440, &v38, &v37);
  if (ValidDPI(v38) && ValidDPI(v37))
  {
    IIONumber::IIONumber((IIONumber *)v36, v38);
    IIODictionary::setObjectForKey(v4, (uint64_t)v36, CFSTR("DPIWidth"));
    IIONumber::~IIONumber((IIONumber *)v36);
    IIONumber::IIONumber((IIONumber *)v35, v37);
    IIODictionary::setObjectForKey(v4, (uint64_t)v35, CFSTR("DPIHeight"));
    IIONumber::~IIONumber((IIONumber *)v35);
  }
  if ((*((_DWORD *)this + 53) - 512) < 0xFFFFFE01 && *((_BYTE *)this + 341) == 0)
    v30 = 2;
  else
    v30 = 1;
  *((_BYTE *)this + 632) = v30;
  if (*((_DWORD *)this + 81) == 1380401696 && *((_WORD *)this + 120) == 8 && !*((_BYTE *)this + 619))
  {
    v31 = *((_DWORD *)this + 137) - 1;
    if (v31 > 5)
    {
      *((_BYTE *)this + 246) = 0;
      LOBYTE(v32) = 5;
    }
    else
    {
      v32 = 0x50503030101uLL >> (8 * v31);
      *((_WORD *)this + 123) = v32;
    }
    *((_WORD *)this + 138) = 4;
    *((_DWORD *)this + 68) = 2097160;
    *((_BYTE *)this + 278) = v32;
    *((_BYTE *)this + 279) = 0;
    *((_BYTE *)this + 350) = 1;
  }
  v10 = 0;
  *((_WORD *)this + 188) = 1;
  return v10;
}

void sub_187FEDED8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t JP2ReadPlugin::decodeJP2Block(JP2ReadPlugin *this, void *a2, CGRect a3)
{
  double height;
  double width;
  double y;
  double x;
  char *v7;
  uint64_t result;

  height = a3.size.height;
  width = a3.size.width;
  y = a3.origin.y;
  x = a3.origin.x;
  v7 = (char *)this + 440;
  *((_QWORD *)this + 74) = a2;
  *((_DWORD *)this + 122) = 0;
  if (*((_BYTE *)this + 618))
  {
    IIOImageReadSession::rewind(*((_QWORD *)this + 3));
    result = _cg_JP2ResetSource((uint64_t)v7);
    if ((_DWORD)result)
      return result;
    *((_BYTE *)this + 618) = 0;
  }
  return _cg_JP2DecompressBlock((uint64_t)v7, (int)x, (int)y, (int)width, (int)height);
}

void sub_187FEDF78(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x187FEDF64);
}

uint64_t JP2ReadPlugin::decodeJP2Prog(JP2ReadPlugin *this, void *a2, CGRect a3)
{
  double height;
  double width;
  double y;
  double x;

  height = a3.size.height;
  width = a3.size.width;
  y = a3.origin.y;
  x = a3.origin.x;
  if (IIOImageReadSession::globalInfoForType(*((IIOImageReadSession **)this + 3), 1246769696))
  {
    IIOImageReadSession::rewind(*((_QWORD *)this + 3));
    _cg_JP2ResetSource((uint64_t)this + 440);
    *((_QWORD *)this + 74) = a2;
    *((_DWORD *)this + 122) = 0;
    *((_BYTE *)this + 618) = 1;
    return 2
         * (_cg_JP2DecompressBlock((uint64_t)this + 440, (int)x, (int)y, (int)width, (int)height) != 0);
  }
  else
  {
    LogError("decodeJP2Prog", 1712, "globalInfo is NULL\n");
    return 2;
  }
}

void JP2ReadPlugin::fixPremultipliedData(JP2ReadPlugin *this, CGRect a2, unsigned __int8 *a3)
{
  uint64_t v3;
  uint64_t v5;
  double height;
  double width;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  int v15;
  unint64_t v16;
  unint64_t v17;
  unsigned int v18;
  _BYTE *v19;

  v3 = *((_QWORD *)this + 66);
  if ((v3 | 2) == 3)
  {
    v5 = *((_QWORD *)this + 70);
    if ((v5 & 0xE0000000) == 0)
    {
      height = a2.size.height;
      width = a2.size.width;
      v9 = *((unsigned __int16 *)this + 121);
      v10 = malloc_type_calloc((8 * v5), 1uLL, 0x245CB1D6uLL);
      if (v10)
      {
        v11 = *((_QWORD *)this + 70);
        if (v11)
        {
          v12 = *((_QWORD *)this + 69) >> 3;
          v13 = *((_QWORD *)this + 70);
          v14 = v10;
          do
          {
            *v14++ = a3;
            a3 += v12;
            --v13;
          }
          while (v13);
        }
        if (width * height > 0.0)
        {
          v15 = 0;
          v16 = v11;
          do
          {
            if (v16)
            {
              v17 = 0;
              v18 = *(unsigned __int8 *)v10[v3];
              do
              {
                v19 = (_BYTE *)v10[v17];
                if (v18 < *v19)
                {
                  *v19 = v18;
                  v19 = (_BYTE *)v10[v17];
                  v11 = *((_QWORD *)this + 70);
                }
                v10[v17++] = &v19[v9 >> 3];
                v16 = v11;
              }
              while (v11 > v17);
            }
            ++v15;
          }
          while (width * height > (double)v15);
        }
        free(v10);
      }
    }
  }
}

void JP2ReadPlugin::decodeBlocks(uint64_t a1, uint64_t a2, double **a3)
{
  IIOImageRead *v5;
  double *v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  int v13;
  int v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  unint64_t v21;
  double *v22;
  _QWORD v23[2];
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  CFTypeRef cf[2];
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;
  _OWORD v36[4];

  v5 = (IIOImageRead *)IIO_Reader::testHeaderSize(*(IIO_Reader **)(a1 + 24));
  v6 = *a3;
  memset(v36, 0, sizeof(v36));
  IIOImageReadSession::IIOImageReadSession((IIOImageReadSession *)v36, v5);
  v7 = *(_OWORD *)(a1 + 616);
  v33 = *(_OWORD *)(a1 + 600);
  v34 = v7;
  v35 = *(_QWORD *)(a1 + 632);
  v8 = *(_OWORD *)(a1 + 552);
  *(_OWORD *)cf = *(_OWORD *)(a1 + 536);
  v30 = v8;
  v9 = *(_OWORD *)(a1 + 584);
  v31 = *(_OWORD *)(a1 + 568);
  v32 = v9;
  v10 = *(_OWORD *)(a1 + 488);
  v25 = *(_OWORD *)(a1 + 472);
  v26 = v10;
  v11 = *(_OWORD *)(a1 + 520);
  v27 = *(_OWORD *)(a1 + 504);
  v28 = v11;
  v12 = *(_OWORD *)(a1 + 456);
  v23[1] = *(_QWORD *)(a1 + 448);
  v24 = v12;
  v23[0] = v36;
  if (IIO_XPCServer())
  {
    *((_QWORD *)&v24 + 1) = MyRead;
    *(_QWORD *)&v25 = MySeek;
    *((_QWORD *)&v25 + 1) = 0;
  }
  cf[0] = 0;
  v13 = _cg_JP2SetupDecompressor((uint64_t)v23, (uint64_t)v23);
  v14 = v13;
  if (v13)
  {
    ImageIOLog("_cg_JP2SetupDecompressor returned error: %d\n", v13);
  }
  else
  {
    v15 = (void *)*((_QWORD *)v6 + 5);
    v16 = *((_QWORD *)v6 + 1);
    v17 = *((_QWORD *)v6 + 2);
    v18 = *((_QWORD *)v6 + 3);
    v19 = *((_QWORD *)v6 + 4);
    if (*(_BYTE *)(a1 + 632) == 1)
      v20 = JP2ReadPlugin::decodeJP2Block((JP2ReadPlugin *)a1, v15, *(CGRect *)&v16);
    else
      v20 = JP2ReadPlugin::decodeJP2Prog((JP2ReadPlugin *)a1, v15, *(CGRect *)&v16);
    v14 = v20;
    _cg_JP2TearDownDecompressor(v23);
    if (cf[0])
      CFRelease(cf[0]);
  }
  v21 = (unint64_t)v6[4];
  if (v14)
    v21 = 0;
  v22 = *a3;
  *((_QWORD *)v22 + 8) = v21;
  *((_DWORD *)v22 + 18) = v14;
  IIOImageReadSession::~IIOImageReadSession((IIOImageReadSession *)v36);
}

void sub_187FEE2B8(_Unwind_Exception *a1)
{
  uint64_t v1;

  IIOImageReadSession::~IIOImageReadSession((IIOImageReadSession *)(v1 - 112));
  _Unwind_Resume(a1);
}

uint64_t JP2ReadPlugin::decodeImageImpProgressive(IIOReadPlugin *this, IIODecodeParameter *a2, int a3)
{
  int v6;
  unsigned int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  double v20;
  double v21;
  int v22;
  int v23;
  int v24;
  size_t v25;
  unsigned int BlockArray;
  IIOImageRead *v27;
  IIOImageRead *v28;
  void *v29;
  size_t v30;
  uint64_t v32;
  CGRect *v33;
  int v34;
  unsigned int v35;
  double x;
  unsigned int v37;
  double y;
  unint64_t v39;
  double v40;
  double width;
  double height;
  double v43;
  uint64_t v44;
  int CachedTile;
  int v46;
  memory_object_offset_t v47;
  uint64_t v48;
  double *v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  char *v54;
  double *v55;
  uint64_t v56;
  unint64_t v57;
  unint64_t v58;
  char *v59;
  char *v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  double *v65;
  double *v66;
  double *v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  char *v72;
  double *v73;
  double *v74;
  int v75;
  char v76;
  double *v77;
  double *v78;
  unint64_t v79;
  unsigned int v80;
  int v81;
  int v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  uint64_t v88;
  double *v89;
  char *v90;
  char *v91;
  size_t v92;
  _QWORD v93[6];
  CGRect v94;
  CGRect v95;

  v92 = 0;
  *((_WORD *)this + 158) = *((_QWORD *)this + 76);
  if ((gIIODebugFlags & 0x20000) != 0)
  {
    v6 = *((_DWORD *)this + 51);
    v7 = v6 >> 24;
    v8 = MEMORY[0x1E0C80978];
    if (v6 < 0)
    {
      v9 = __maskrune(v7, 0x40000uLL);
      v6 = *((_DWORD *)this + 51);
    }
    else
    {
      v9 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v7 + 60) & 0x40000;
    }
    if (v9)
      v10 = (v6 >> 24);
    else
      v10 = 46;
    v11 = v6 << 8 >> 24;
    if (v6 << 8 < 0)
    {
      v12 = __maskrune(v11, 0x40000uLL);
      v6 = *((_DWORD *)this + 51);
    }
    else
    {
      v12 = *(_DWORD *)(v8 + 4 * v11 + 60) & 0x40000;
    }
    if (v12)
      v13 = (v6 << 8 >> 24);
    else
      v13 = 46;
    v14 = (__int16)v6 >> 8;
    if (v6 << 16 < 0)
    {
      v15 = __maskrune(v14, 0x40000uLL);
      v6 = *((_DWORD *)this + 51);
    }
    else
    {
      v15 = *(_DWORD *)(v8 + 4 * v14 + 60) & 0x40000;
    }
    if (v15)
      v16 = ((__int16)v6 >> 8);
    else
      v16 = 46;
    if ((v6 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v8 + 4 * (char)v6 + 60) & 0x40000) != 0)
        goto LABEL_22;
    }
    else if (__maskrune((char)v6, 0x40000uLL))
    {
LABEL_22:
      v17 = *((_DWORD *)this + 51);
LABEL_25:
      ImageIOLog("  '%c%c%c%c' [%s] %s\n", v10, v13, v16, (char)v17, iioTypeStr[a3], "OSStatus JP2ReadPlugin::decodeImageImpProgressive(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      goto LABEL_26;
    }
    LOBYTE(v17) = 46;
    goto LABEL_25;
  }
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  v18 = *((_QWORD *)this + 63);
  v19 = *((_DWORD *)this + 128);
  *((_DWORD *)this + 73) = v18;
  *((_DWORD *)this + 74) = v19;
  v20 = *((double *)a2 + 3);
  v21 = *((double *)a2 + 4);
  v22 = (int)(v20 / (double)v18);
  v23 = (int)(v21 / (double)v19);
  v24 = (int)((v20 + *((double *)a2 + 5) + (double)v18 + -1.0) / (double)v18);
  v82 = (int)((v21 + *((double *)a2 + 6) + (double)v19 + -1.0) / (double)v19);
  v25 = ((v82 - v23) * (v24 - v22));
  *((_DWORD *)this + 26) = v25;
  BlockArray = IIOReadPlugin::allocateBlockArray(this, v25);
  v27 = IIOImageReadSession::globalInfoForType(*((IIOImageReadSession **)this + 3), 1246769696);
  if (!v27)
    return 4294967246;
  v28 = v27;
  v29 = (void *)*((_QWORD *)v27 + 1);
  v30 = *((unsigned int *)this + 26);
  v80 = BlockArray;
  if (v29)
  {
    if (v30 > *((_DWORD *)v28 + 1))
    {
      free(v29);
      *((_QWORD *)v28 + 1) = malloc_type_calloc(4uLL, *((unsigned int *)this + 26), 0xC53E0568uLL);
    }
  }
  else
  {
    *((_QWORD *)v28 + 1) = malloc_type_calloc(4uLL, v30, 0x6D27189CuLL);
    *((_DWORD *)v28 + 1) = *((_DWORD *)this + 26);
  }
  v89 = 0;
  v90 = 0;
  v91 = 0;
  if (v82 <= v23)
  {
LABEL_73:
    JP2ReadPlugin::decodeBlocks((uint64_t)this, v30, &v89);
    v73 = v89;
    v74 = (double *)v90;
    while (1)
    {
      if (v73 == v74)
      {
        if ((gIIODebugFlags & 0x30000) != 0)
          ImageIOLog("                    coveredRect: {%g, %g, %g, %g}\n\n", *((double *)this + 15), *((double *)this + 16), *((double *)this + 17), *((double *)this + 18));
        goto LABEL_85;
      }
      v75 = *((_DWORD *)v73 + 18);
      if ((v75 - 1) >= 2)
      {
        if (v75)
          goto LABEL_80;
        v76 = *((_BYTE *)this + 341);
      }
      else
      {
        v76 = 0;
      }
      *((_BYTE *)this + 343) = v76;
LABEL_80:
      if (*((_DWORD *)this + 137) == 1)
        JP2ReadPlugin::fixPremultipliedData(this, *(CGRect *)(v73 + 1), *((unsigned __int8 **)v73 + 5));
      *(_QWORD *)(*((_QWORD *)this + 12) + 8 * *(_QWORD *)v73) = IIOReadPlugin::createImageBlock(this, *((void **)v73 + 5), *((_QWORD *)v73 + 7), *(CGRect *)(v73 + 1), *((_QWORD *)v73 + 6), *((unsigned __int8 *)this + 343));
      v73[5] = 0.0;
      v73 += 11;
    }
  }
  v32 = 0;
  v33 = (CGRect *)MEMORY[0x1E0C9D628];
  v81 = v22;
  while (v24 <= v22)
  {
    v44 = v32;
LABEL_72:
    ++v23;
    v32 = v44;
    v22 = v81;
    if (v23 == v82)
      goto LABEL_73;
  }
  v34 = v22;
  while (1)
  {
    v35 = *((_DWORD *)this + 73);
    x = (double)(v35 * v34);
    v37 = *((_DWORD *)this + 74);
    y = (double)(v37 * v23);
    v39 = *((_QWORD *)this + 64);
    v40 = (double)*((unint64_t *)this + 63);
    if ((double)v35 + x <= v40)
      width = (double)v35;
    else
      width = v40 - x;
    if ((double)v37 + y <= (double)v39)
      height = (double)v37;
    else
      height = (double)v39 - y;
    v43 = width * (double)(*((unsigned __int16 *)this + 121) >> 3);
    *((_DWORD *)this + 75) = (unint64_t)v43;
    v44 = (v32 + 1);
    *((_DWORD *)this + 28) = v32;
    *((_DWORD *)this + 29) = v44;
    CachedTile = IIOReadPlugin::getCachedTile(this, v43);
    v46 = CachedTile;
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("     numberOfBlocksLeftToDecode: %d\n", CachedTile);
    if (!v46)
      goto LABEL_67;
    if ((gIIODebugFlags & 0x30000) != 0)
      ImageIOLog("JP2: Decoding blockArrayIndex: %d, blockIndex: %d  = (%d, %d)\n", v32, v34 + v23 * ((v18 + (unint64_t)v18 - 1) / v18), v34, v23);
    if (!is_mul_ok((unint64_t)height, *((unsigned int *)this + 75)))
      break;
    v47 = _ImageIO_Malloc((unint64_t)height * *((unsigned int *)this + 75), *((_QWORD *)this + 48), &v92, (uint64_t)kImageMalloc_JP2_Data[0], *((_DWORD *)this + 108), 0, 0);
    if (!v47)
      break;
    *((_BYTE *)this + 618) = 1;
    v48 = *((unsigned int *)this + 75);
    *(_QWORD *)&v83 = (int)v32;
    *((double *)&v83 + 1) = x;
    *(double *)&v84 = y;
    *((double *)&v84 + 1) = width;
    *(double *)&v85 = height;
    *((_QWORD *)&v85 + 1) = v47;
    *(_QWORD *)&v86 = v48;
    *((_QWORD *)&v86 + 1) = v92;
    v87 = 0uLL;
    v88 = 0;
    v49 = (double *)v90;
    if (v90 >= v91)
    {
      v55 = v89;
      v56 = 0x2E8BA2E8BA2E8BA3 * ((v90 - (char *)v89) >> 3);
      v57 = v56 + 1;
      if ((unint64_t)(v56 + 1) > 0x2E8BA2E8BA2E8BALL)
        std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
      if (0x5D1745D1745D1746 * ((v91 - (char *)v89) >> 3) > v57)
        v57 = 0x5D1745D1745D1746 * ((v91 - (char *)v89) >> 3);
      if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * ((v91 - (char *)v89) >> 3)) >= 0x1745D1745D1745DLL)
        v58 = 0x2E8BA2E8BA2E8BALL;
      else
        v58 = v57;
      v93[4] = &v91;
      if (v58)
      {
        v59 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIODecodeFrameParams>>((uint64_t)&v91, v58);
        v55 = v89;
        v49 = (double *)v90;
      }
      else
      {
        v59 = 0;
      }
      v60 = &v59[88 * v56];
      v61 = v84;
      *(_OWORD *)v60 = v83;
      *((_OWORD *)v60 + 1) = v61;
      v62 = v85;
      v63 = v86;
      v64 = v87;
      *((_QWORD *)v60 + 10) = v88;
      *((_OWORD *)v60 + 3) = v63;
      *((_OWORD *)v60 + 4) = v64;
      *((_OWORD *)v60 + 2) = v62;
      if (v49 == v55)
      {
        v67 = (double *)&v59[88 * v56];
      }
      else
      {
        v65 = v49;
        v66 = (double *)&v59[88 * v56];
        do
        {
          v67 = v66 - 11;
          v68 = *(_OWORD *)(v65 - 11);
          *(_OWORD *)(v66 - 9) = *(_OWORD *)(v65 - 9);
          *(_OWORD *)(v66 - 11) = v68;
          v69 = *(_OWORD *)(v65 - 7);
          v70 = *(_OWORD *)(v65 - 5);
          v71 = *(_OWORD *)(v65 - 3);
          *(v66 - 1) = *(v65 - 1);
          *(_OWORD *)(v66 - 3) = v71;
          *(_OWORD *)(v66 - 5) = v70;
          *(_OWORD *)(v66 - 7) = v69;
          v65 -= 11;
          v66 -= 11;
        }
        while (v65 != v55);
      }
      v54 = v60 + 88;
      v89 = v67;
      v90 = v60 + 88;
      v72 = v91;
      v91 = &v59[88 * v58];
      v93[2] = v49;
      v93[3] = v72;
      v93[0] = v55;
      v93[1] = v55;
      std::__split_buffer<IIODecodeFrameParams>::~__split_buffer((uint64_t)v93);
    }
    else
    {
      v50 = v84;
      *(_OWORD *)v90 = v83;
      *((_OWORD *)v49 + 1) = v50;
      v51 = v85;
      v52 = v86;
      v53 = v87;
      *((_QWORD *)v49 + 10) = v88;
      *((_OWORD *)v49 + 3) = v52;
      *((_OWORD *)v49 + 4) = v53;
      *((_OWORD *)v49 + 2) = v51;
      v54 = (char *)(v49 + 11);
    }
    v90 = v54;
    IIODecodeFrameParams::~IIODecodeFrameParams((IIODecodeFrameParams *)&v83);
LABEL_67:
    if (!CGRectEqualToRect(*(CGRect *)((char *)this + 120), *v33))
    {
      v95.origin.x = x;
      v95.origin.y = y;
      v95.size.width = width;
      v95.size.height = height;
      v94 = CGRectUnion(*(CGRect *)((char *)this + 120), v95);
      x = v94.origin.x;
      y = v94.origin.y;
      width = v94.size.width;
      height = v94.size.height;
    }
    *((double *)this + 15) = x;
    *((double *)this + 16) = y;
    *((double *)this + 17) = width;
    *((double *)this + 18) = height;
    ++v34;
    LODWORD(v32) = v32 + 1;
    if (v34 == v24)
      goto LABEL_72;
  }
LABEL_85:
  v77 = v89;
  v78 = (double *)v90;
  while (v77 != v78)
  {
    v79 = *((_QWORD *)v77 + 5);
    if (v79)
      _ImageIO_Free(v79, *((_QWORD *)v77 + 7));
    v77 += 11;
  }
  if ((gIIODebugFlags & 0x30000) != 0)
    ImageIOLog("<<< copyImageBlockSetJP2Prog\n");
  *(_QWORD *)&v83 = &v89;
  std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100]((void ***)&v83);
  return v80;
}

void sub_187FEEA18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void **a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  a18 = (void **)&a29;
  std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100](&a18);
  _Unwind_Resume(a1);
}

uint64_t JP2ReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4)
{
  int v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  uint64_t BlockArray;
  uint64_t v23;
  unsigned int v24;
  unsigned int v25;
  IIOImageRead **v26;
  _BOOL4 v27;
  void *BaseAddress;
  size_t Height;
  size_t v30;
  unsigned int v31;
  double v32;
  double v33;
  int v34;
  _QWORD *v35;
  size_t v36;
  unsigned int v37;
  int8x16_t v38;
  int v39;
  const uint8_t *v40;
  const char **v41;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  double v46;
  double v47;
  vImage_Buffer dest;
  size_t v49;
  CGRect v50;
  CGRect v51;
  CGRect v52;

  v49 = 0;
  if ((gIIODebugFlags & 0x20000) != 0)
  {
    v8 = *((_DWORD *)this + 51);
    v9 = v8 >> 24;
    v10 = MEMORY[0x1E0C80978];
    if (v8 < 0)
    {
      v11 = __maskrune(v9, 0x40000uLL);
      v8 = *((_DWORD *)this + 51);
    }
    else
    {
      v11 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v9 + 60) & 0x40000;
    }
    if (v11)
      v12 = (v8 >> 24);
    else
      v12 = 46;
    v13 = v8 << 8 >> 24;
    if (v8 << 8 < 0)
    {
      v14 = __maskrune(v13, 0x40000uLL);
      v8 = *((_DWORD *)this + 51);
    }
    else
    {
      v14 = *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
    }
    if (v14)
      v15 = (v8 << 8 >> 24);
    else
      v15 = 46;
    v16 = (__int16)v8 >> 8;
    if (v8 << 16 < 0)
    {
      v17 = __maskrune(v16, 0x40000uLL);
      v8 = *((_DWORD *)this + 51);
    }
    else
    {
      v17 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
    }
    if (v17)
      v18 = ((__int16)v8 >> 8);
    else
      v18 = 46;
    if ((v8 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v10 + 4 * (char)v8 + 60) & 0x40000) != 0)
        goto LABEL_22;
    }
    else if (__maskrune((char)v8, 0x40000uLL))
    {
LABEL_22:
      v19 = *((_DWORD *)this + 51);
LABEL_25:
      ImageIOLog("  '%c%c%c%c' [%s] %s\n", v12, v15, v18, (char)v19, iioTypeStr[a3], "virtual OSStatus JP2ReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      goto LABEL_26;
    }
    LOBYTE(v19) = 46;
    goto LABEL_25;
  }
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  v20 = *((unsigned __int16 *)this + 153);
  if (v20 == 8)
  {
    if (*((_WORD *)this + 152) == 8)
    {
      v21 = *((_DWORD *)this + 73);
      goto LABEL_32;
    }
  }
  else if (v20 == 24 && *((_WORD *)this + 152) == 8)
  {
    v21 = 3 * *((_DWORD *)this + 73);
LABEL_32:
    *((_DWORD *)this + 75) = v21;
  }
  if (!*((_BYTE *)this + 414) || *((_BYTE *)this + 410) == 1 && *((_DWORD *)this + 75) % *((_DWORD *)this + 98))
    return 4294967115;
  if (!*((_QWORD *)this + 62))
  {
    v23 = _cg_JP2SetupDecompressor((uint64_t)this + 440, (uint64_t)this + 440);
    if ((_DWORD)v23)
      return v23;
  }
  *((_WORD *)this + 158) = *((_QWORD *)this + 76);
  v24 = *((_DWORD *)this + 126);
  v25 = *((_DWORD *)this + 128);
  *((_DWORD *)this + 73) = v24;
  *((_DWORD *)this + 74) = v25;
  v26 = (IIOImageRead **)*((_QWORD *)this + 3);
  if (v26)
  {
    v27 = IIOImageReadSession::mapData(v26);
    v24 = *((_DWORD *)this + 73);
    v25 = *((_DWORD *)this + 74);
  }
  else
  {
    v27 = 0;
  }
  if (a3 == 3)
  {
    BlockArray = IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
    v31 = *((_DWORD *)this + 75);
    if (v31 <= *((_DWORD *)this + 59))
      v31 = *((_DWORD *)this + 59);
    v30 = *((unsigned int *)this + 74) * (unint64_t)v31;
    BaseAddress = (void *)_ImageIO_Malloc(v30, *((_QWORD *)this + 48), &v49, (uint64_t)kImageMalloc_JP2_Data[0], *((_DWORD *)this + 108), 0, 0);
  }
  else
  {
    if (a3 != 1 || !a4 || !*a4)
      goto LABEL_80;
    IOSurfaceLock(*a4, 0, 0);
    BaseAddress = IOSurfaceGetBaseAddress(*a4);
    Height = IOSurfaceGetHeight(*a4);
    BlockArray = 0;
    v30 = IOSurfaceGetBytesPerRow(*a4) * Height;
    v49 = v30;
  }
  if (!BaseAddress)
    goto LABEL_81;
  v32 = (double)v24;
  v33 = (double)v25;
  memset(BaseAddress, 255, v30);
  v34 = *((unsigned __int8 *)this + 632);
  if (v34 == 2)
  {
    BlockArray = JP2ReadPlugin::decodeImageImpProgressive(this, a2, a3);
LABEL_59:
    if (!(_DWORD)BlockArray)
    {
LABEL_78:
      if (a3 == 3)
      {
        v43 = 0;
        v51.origin.x = 0.0;
        v51.origin.y = 0.0;
        v51.size.width = (double)v24;
        v51.size.height = (double)v25;
        **((_QWORD **)this + 12) = IIOReadPlugin::createImageBlock(this, BaseAddress, v30, v51, *((unsigned int *)this + 75), *((unsigned __int8 *)this + 343));
        if (CGRectEqualToRect(*(CGRect *)((char *)this + 120), *MEMORY[0x1E0C9D628]))
        {
          v44 = 0;
        }
        else
        {
          v52.origin.x = 0.0;
          v52.origin.y = 0.0;
          v52.size.width = (double)v24;
          v52.size.height = (double)v25;
          *(CGRect *)(&v44 - 1) = CGRectUnion(*(CGRect *)((char *)this + 120), v52);
          v43 = v45;
          v32 = v46;
          v33 = v47;
        }
        BlockArray = 0;
        *((_QWORD *)this + 15) = v43;
        *((_QWORD *)this + 16) = v44;
        *((double *)this + 17) = v32;
        *((double *)this + 18) = v33;
LABEL_81:
        if (!v27)
          return BlockArray;
        goto LABEL_82;
      }
      IOSurfaceUnlock(*a4, 0, 0);
LABEL_80:
      BlockArray = 0;
      goto LABEL_81;
    }
    goto LABEL_60;
  }
  if (v34 != 1)
    goto LABEL_59;
  v50.origin.x = 0.0;
  v50.origin.y = 0.0;
  v50.size.width = (double)v24;
  v50.size.height = (double)v25;
  BlockArray = JP2ReadPlugin::decodeJP2Block(this, BaseAddress, v50);
  if (!(_DWORD)BlockArray)
  {
    v35 = (_QWORD *)((char *)this + 292);
    if (*((_WORD *)this + 153) == 32 && *((_WORD *)this + 121) == 24 && *((_DWORD *)this + 81) == 1380401696)
    {
      ImageIOPixelConverter::ExpandRGB888ToARGB8888((ImageIOPixelConverter *)BaseAddress, v30, *((_DWORD *)this + 73), *((_DWORD *)this + 74), *((_DWORD *)this + 75));
    }
    else
    {
      v36 = *((unsigned int *)this + 67);
      v37 = *((_DWORD *)this + 75);
      if ((_DWORD)v36 != v37)
        ImageIOPixelConverter::AdjustRowBytes((ImageIOPixelConverter *)BaseAddress, v30, *((_DWORD *)this + 73), *((_DWORD *)this + 74), v36, v37);
    }
    dest.data = BaseAddress;
    v38.i64[0] = *v35;
    v38.i64[1] = HIDWORD(*v35);
    *(int8x16_t *)&dest.height = vextq_s8(v38, v38, 8uLL);
    dest.rowBytes = *((unsigned int *)this + 75);
    if (*((_WORD *)this + 153) != 32)
      goto LABEL_76;
    v39 = *((unsigned __int16 *)this + 152);
    if (*((_WORD *)this + 121) == 24)
    {
      if (v39 != 8)
        goto LABEL_76;
      if (*((_DWORD *)this + 81) == 1380401696)
      {
        if (!*((_BYTE *)this + 405))
          goto LABEL_76;
        v40 = (const uint8_t *)&JP2ReadPlugin::decodeImageImp(IIODecodeParameter *,IIOImageType,__IOSurface **,__CVBuffer **,CGImageBlockSet **)::permuteMap;
        goto LABEL_75;
      }
    }
    else if (v39 != 8)
    {
      goto LABEL_76;
    }
    if (*((_DWORD *)this + 100) != 1111970392)
      goto LABEL_76;
    v40 = (const uint8_t *)&JP2ReadPlugin::decodeImageImp(IIODecodeParameter *,IIOImageType,__IOSurface **,__CVBuffer **,CGImageBlockSet **)::permuteMap;
LABEL_75:
    vImagePermuteChannels_ARGB8888(&dest, &dest, v40, 0x10u);
LABEL_76:
    if (*((_BYTE *)this + 406) == 1)
      vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
    goto LABEL_78;
  }
LABEL_60:
  *((_DWORD *)this + 26) = 0;
  if (a3 == 3)
  {
    _ImageIO_Free((unint64_t)BaseAddress, v49);
    goto LABEL_81;
  }
  if (!v27)
    return BlockArray;
LABEL_82:
  v41 = (const char **)*((_QWORD *)this + 3);
  if (v41)
    IIOImageReadSession::unmapData(v41);
  return BlockArray;
}

void _TIFFFax3fillruns(uint64_t a1, unsigned int *a2, unsigned int *a3, unsigned int a4)
{
  unsigned int *v5;
  unsigned int *v6;
  unsigned int v8;
  unsigned int v9;
  _BYTE *v11;
  unsigned int v12;
  unsigned int v13;
  char v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  _BYTE *v22;
  char v23;
  unsigned int v24;
  char v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unsigned int v30;

  v5 = a3;
  v6 = a2;
  if ((((_DWORD)a3 - (_DWORD)a2) & 4) != 0)
  {
    *a3 = 0;
    v5 = a3 + 1;
  }
  if (v5 > a2)
  {
    v8 = 0;
    while (1)
    {
      v9 = *v6;
      if (*v6 > a4 || *v6 + v8 > a4)
      {
        v9 = a4 - v8;
        *v6 = a4 - v8;
      }
      if (v9)
        break;
LABEL_31:
      v20 = v6[1];
      if (v20 > a4 || v20 + v8 > a4)
      {
        v20 = a4 - v8;
        v6[1] = a4 - v8;
      }
      if (!v20)
        goto LABEL_57;
      v22 = (_BYTE *)(a1 + (v8 >> 3));
      v23 = v8 & 7;
      if (v20 <= 8 - (v8 & 7))
      {
        v30 = _TIFFFax3fillruns__fillmasks[v20] >> v23;
      }
      else
      {
        if ((v8 & 7) != 0)
        {
          *v22++ |= 0xFFu >> v23;
          v20 -= 8 - (v8 & 7);
        }
        if (v20 >= 8)
        {
          v24 = v20 >> 3;
          if (v20 < 0x80)
            goto LABEL_50;
          if ((v22 & 7) != 0)
          {
            v25 = v22 ^ 7;
            v26 = (v22 ^ 7) & 7;
            v27 = v24 - 1;
            if (v26 >= v27)
              v26 = v27;
            v28 = v26 + 1;
            memset(v22, 255, v26 + 1);
            v22 += v28;
            if (v27 >= (v25 & 7u))
              v24 = v27 - (v25 & 7);
            else
              v24 = 0;
          }
          memset(v22, 255, 8 * ((v24 >> 3) - 1) + 8);
          v22 += 8 * (v24 >> 3);
          v24 &= 7u;
          if (v24)
          {
LABEL_50:
            v29 = v24;
            memset(v22, 255, v24);
          }
          else
          {
            v29 = 0;
          }
          v22 += v29;
          v20 &= 7u;
        }
        if (!v20)
          goto LABEL_56;
        v30 = 0xFF00u >> v20;
      }
      *v22 |= v30;
LABEL_56:
      v8 += v6[1];
LABEL_57:
      v6 += 2;
      if (v6 >= v5)
        goto LABEL_62;
    }
    v11 = (_BYTE *)(a1 + (v8 >> 3));
    v12 = 8 - (v8 & 7);
    if (v9 <= v12)
    {
      v19 = *v11 & ~(_TIFFFax3fillruns__fillmasks[v9] >> (v8 & 7));
    }
    else
    {
      if ((v8 & 7) != 0)
      {
        *v11++ &= -1 << v12;
        v9 -= v12;
      }
      if (v9 >= 8)
      {
        v13 = v9 >> 3;
        if (v9 < 0x80)
          goto LABEL_24;
        if ((v11 & 7) != 0)
        {
          v14 = v11 ^ 7;
          v15 = (v11 ^ 7) & 7;
          v16 = v13 - 1;
          if (v15 >= v16)
            v15 = v16;
          v17 = v15 + 1;
          bzero(v11, v15 + 1);
          v11 += v17;
          if (v16 >= (v14 & 7u))
            v13 = v16 - (v14 & 7);
          else
            v13 = 0;
        }
        bzero(v11, 8 * ((v13 >> 3) - 1) + 8);
        v11 += 8 * (v13 >> 3);
        v13 &= 7u;
        if (v13)
        {
LABEL_24:
          v18 = v13;
          bzero(v11, v13);
        }
        else
        {
          v18 = 0;
        }
        v11 += v18;
        v9 &= 7u;
      }
      if (!v9)
        goto LABEL_30;
      v19 = *v11 & (0xFFu >> v9);
    }
    *v11 = v19;
LABEL_30:
    v8 += *v6;
    goto LABEL_31;
  }
  v8 = 0;
LABEL_62:
  if (v8 != a4)
    _TIFFFax3fillruns_cold_1();
}

uint64_t TIFFInitCCITTFax3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v21;

  if (!InitCCITTFax3(a1, a2, a3, a4, a5, a6, a7, a8))
    return 1;
  if (_TIFFMergeFields(a1, fax3Fields, 1, v9, v10, v11, v12, v13))
    return _cg_TIFFSetField(a1, 0x10000, v14, v15, v16, v17, v18, v19, 1);
  TIFFErrorExtR(a1, "TIFFInitCCITTFax3", "Merging CCITT Fax 3 codec-specific tags failed", v15, v16, v17, v18, v19, v21);
  return 0;
}

uint64_t InitCCITTFax3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int8x16_t v24;
  uint64_t result;
  char *v26;
  char v27;

  if (!_TIFFMergeFields(a1, faxFields, 5, a4, a5, a6, a7, a8))
  {
    v26 = "Merging common CCITT Fax codec-specific tags failed";
LABEL_8:
    TIFFErrorExtR(a1, "InitCCITTFax3", v26, v10, v11, v12, v13, v14, v27);
    return 0;
  }
  v15 = _TIFFmallocExt((_QWORD *)a1, 160, v9, v10, v11, v12, v13, v14);
  *(_QWORD *)(a1 + 1096) = v15;
  if (!v15)
  {
    v26 = "No space for state block";
    goto LABEL_8;
  }
  _TIFFmemset(v15, 0, 0xA0uLL);
  v22 = *(_QWORD *)(a1 + 1096);
  v23 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)v22 = v23;
  v24 = *(int8x16_t *)(a1 + 1280);
  *(_QWORD *)(a1 + 1288) = Fax3VGetField;
  *(int8x16_t *)(v22 + 40) = vextq_s8(v24, v24, 8uLL);
  *(_QWORD *)(a1 + 1280) = Fax3VSetField;
  *(_QWORD *)(v22 + 56) = *(_QWORD *)(a1 + 1296);
  *(_QWORD *)(a1 + 1296) = Fax3PrintDir;
  *(_DWORD *)(v22 + 32) = 0;
  if (!v23)
    *(_DWORD *)(a1 + 16) |= 0x100u;
  *(_QWORD *)(v22 + 96) = 0;
  _cg_TIFFSetField(a1, 65540, v16, v17, v18, v19, v20, v21, (uint64_t)_TIFFFax3fillruns);
  *(_QWORD *)(*(_QWORD *)(a1 + 1096) + 136) = 0;
  *(_QWORD *)(a1 + 952) = Fax3FixupTags;
  *(_QWORD *)(a1 + 960) = Fax3SetupState;
  *(_QWORD *)(a1 + 968) = Fax3PreDecode;
  *(_QWORD *)(a1 + 1008) = Fax3Decode1D;
  *(_QWORD *)(a1 + 1024) = Fax3Decode1D;
  *(_QWORD *)(a1 + 1040) = Fax3Decode1D;
  *(_QWORD *)(a1 + 976) = Fax3SetupState;
  *(_QWORD *)(a1 + 992) = Fax3PreEncode;
  *(_QWORD *)(a1 + 1000) = Fax3PostEncode;
  *(_QWORD *)(a1 + 1016) = Fax3Encode;
  *(_QWORD *)(a1 + 1032) = Fax3Encode;
  *(_QWORD *)(a1 + 1048) = Fax3Encode;
  *(_QWORD *)(a1 + 1056) = Fax3Close;
  result = 1;
  *(_QWORD *)(a1 + 1072) = Fax3Cleanup;
  return result;
}

uint64_t TIFFInitCCITTFax4(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v21;

  if (InitCCITTFax3((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8))
  {
    if (_TIFFMergeFields((uint64_t)a1, fax4Fields, 1, v9, v10, v11, v12, v13))
    {
      a1[126] = Fax4Decode;
      a1[128] = Fax4Decode;
      a1[130] = Fax4Decode;
      a1[127] = Fax4Encode;
      a1[129] = Fax4Encode;
      a1[131] = Fax4Encode;
      a1[125] = Fax4PostEncode;
      return _cg_TIFFSetField((uint64_t)a1, 0x10000, v14, v15, v16, v17, v18, v19, 1);
    }
    TIFFErrorExtR((uint64_t)a1, "TIFFInitCCITTFax4", "Merging CCITT Fax 4 codec-specific tags failed", v15, v16, v17, v18, v19, v21);
  }
  return 0;
}

uint64_t Fax4Decode(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int *v22;
  unsigned __int8 *v23;
  int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int *v28;
  _DWORD *v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  int v33;
  unsigned int *v34;
  unsigned int v35;
  unsigned int v36;
  uint64_t v37;
  uint64_t v38;
  unsigned __int8 *v39;
  int v40;
  int v41;
  int v43;
  uint64_t v44;
  uint64_t v45;
  unsigned __int8 *v46;
  int v47;
  int v48;
  int v49;
  unsigned int *v50;
  unsigned int *v51;
  int v52;
  int v53;
  unsigned int *v54;
  unsigned int *v55;
  int v56;
  int v57;
  unsigned int *v58;
  unsigned int *v59;
  int v60;
  int v61;
  int v62;
  int v63;
  _DWORD *v64;
  uint64_t v65;
  uint64_t v66;
  unsigned __int8 *v67;
  int v68;
  int v69;
  int v70;
  int v71;
  uint64_t v72;
  uint64_t v73;
  unsigned __int8 *v74;
  int v75;
  int v76;
  int v78;
  char *v79;
  int v80;
  unsigned int *v82;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  unsigned int v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  uint64_t v92;
  _DWORD *v93;
  int v94;
  const char *v95;
  _BOOL4 v96;
  int *v97;
  int *v98;
  int v99;
  BOOL v100;
  uint64_t v101;
  unsigned __int8 *v102;
  uint64_t v103;
  uint64_t v104;
  _DWORD *v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  unsigned int v111;
  uint64_t v112;
  uint64_t v113;
  unint64_t v115;
  int v116;
  uint64_t v117;
  _DWORD *v118;
  int v119;
  uint64_t v120;
  uint64_t v121;
  _DWORD *v122;
  int v123;
  _BOOL4 v124;
  int *v125;
  int *v126;
  int v127;
  BOOL v128;
  uint64_t v129;
  int v130;
  char v131;
  _DWORD *v132;
  int v133;
  unsigned __int8 *v134;
  unsigned int v135;
  unsigned int v136;
  unsigned int v137;
  unsigned int v138;
  unint64_t v139;
  uint64_t v140;
  uint64_t v141;

  v8 = a1;
  v9 = a1[137];
  if (a3 % *(_QWORD *)(v9 + 8))
  {
    TIFFErrorExtR((uint64_t)a1, "Fax4Decode", "Fractional scanlines cannot be read", a4, a5, a6, a7, a8, v131);
    return 0xFFFFFFFFLL;
  }
  v10 = a3;
  v12 = *(_DWORD *)(v9 + 72);
  v11 = *(_DWORD *)(v9 + 76);
  v13 = *(_DWORD *)(v9 + 80);
  v14 = a1[144];
  v15 = a1[145];
  if (a3 < 1)
  {
    v23 = (unsigned __int8 *)a1[144];
    goto LABEL_201;
  }
  v16 = &TIFFFaxMainTable;
  v17 = v14 + v15;
  v18 = *(unsigned int *)(v9 + 16);
  v19 = *(_QWORD *)(v9 + 64);
  v20 = (((int)v18 + 7) >> 3);
  v22 = *(unsigned int **)(v9 + 112);
  v21 = *(_QWORD *)(v9 + 120);
  v23 = (unsigned __int8 *)a1[144];
  v139 = v17;
  v140 = v19;
LABEL_5:
  v141 = a2;
  if ((int)v18 < 1)
  {
    LODWORD(v26) = 0;
    v29 = (_DWORD *)v21;
    goto LABEL_149;
  }
  v133 = v13;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v28 = v22 + 1;
  v27 = *v22;
  v29 = (_DWORD *)v21;
LABEL_7:
  v30 = *(unsigned int *)(v9 + 104);
  if ((unint64_t)v29 >= v21 + 4 * v30)
    goto LABEL_208;
  if (v11 <= 6)
  {
    if ((unint64_t)v23 >= v17)
    {
      if (!v11)
      {
LABEL_202:
        v115 = v21;
        v116 = v10;
        v117 = v18;
        v136 = v20;
LABEL_203:
        v118 = v29;
        v119 = v133;
        goto LABEL_205;
      }
      v11 = 7;
    }
    else
    {
      v31 = *v23++;
      v12 |= *(unsigned __int8 *)(v19 + v31) << v11;
      v11 += 8;
    }
  }
  v32 = v12 & 0x7F;
  v33 = *((unsigned __int8 *)&TIFFFaxMainTable + 8 * v32 + 1);
  v11 -= v33;
  v12 >>= v33;
  switch(8 * v32)
  {
    case 0:
    case 0x400:
    case 0x424:
      *v29++ = v18 - v26;
      v136 = v20;
      v132 = v29;
      if (v11 > 3)
      {
        v86 = v18;
      }
      else if ((unint64_t)v23 >= v17)
      {
        if (!v11)
        {
          v115 = v21;
          v116 = v10;
          v117 = v18;
          goto LABEL_203;
        }
        v86 = v18;
        v11 = 4;
      }
      else
      {
        v86 = v18;
        v111 = *v23++;
        v12 |= *(unsigned __int8 *)(v19 + v111) << v11;
        v11 += 8;
      }
      if ((v12 & 0xF) != 0)
      {
        v112 = v21;
        Fax3Unexpected("Fax4Decode", (uint64_t)a1, *(_DWORD *)(v9 + 152), v26, v20, v21, (uint64_t)&TIFFFaxMainTable, a8);
        v21 = v112;
      }
      v11 -= 4;
      v12 >>= 4;
      v13 = 1;
      goto LABEL_192;
    case 8:
    case 0x11:
    case 0x18:
    case 0x21:
    case 0x28:
    case 0x31:
    case 0x38:
    case 0x48:
    case 0x51:
    case 0x58:
    case 0x61:
    case 0x68:
    case 0x71:
    case 0x78:
    case 0x88:
    case 0x91:
    case 0x98:
    case 0xA1:
    case 0xA8:
    case 0xB1:
    case 0xB8:
    case 0xC8:
    case 0xD1:
    case 0xD8:
    case 0xE1:
    case 0xE8:
    case 0xF1:
    case 0xF8:
    case 0x104:
    case 0x108:
    case 0x111:
    case 0x118:
    case 0x121:
    case 0x128:
    case 0x131:
    case 0x138:
    case 0x148:
    case 0x151:
    case 0x158:
    case 0x161:
    case 0x168:
    case 0x171:
    case 0x178:
    case 0x188:
    case 0x191:
    case 0x198:
    case 0x1A1:
    case 0x1A8:
    case 0x1B1:
    case 0x1B8:
    case 0x1C8:
    case 0x1D1:
    case 0x1D8:
    case 0x1E1:
    case 0x1E8:
    case 0x1F1:
    case 0x1F8:
    case 0x208:
    case 0x211:
    case 0x218:
    case 0x221:
    case 0x228:
    case 0x231:
    case 0x238:
    case 0x248:
    case 0x251:
    case 0x258:
    case 0x261:
    case 0x268:
    case 0x271:
    case 0x278:
    case 0x288:
    case 0x291:
    case 0x298:
    case 0x2A1:
    case 0x2A8:
    case 0x2B1:
    case 0x2B8:
    case 0x2C8:
    case 0x2D1:
    case 0x2D8:
    case 0x2E1:
    case 0x2E8:
    case 0x2F1:
    case 0x2F8:
    case 0x304:
    case 0x308:
    case 0x311:
    case 0x318:
    case 0x321:
    case 0x328:
    case 0x331:
    case 0x338:
    case 0x348:
    case 0x351:
    case 0x358:
    case 0x361:
    case 0x368:
    case 0x371:
    case 0x378:
    case 0x388:
    case 0x391:
    case 0x398:
    case 0x3A1:
    case 0x3A8:
    case 0x3B1:
    case 0x3B8:
    case 0x3C8:
    case 0x3D1:
    case 0x3D8:
    case 0x3E1:
    case 0x3E8:
    case 0x3F1:
    case 0x3F8:
    case 0x40CLL:
      if (v29 == (_DWORD *)v21 || (int)v27 > (int)v26)
        goto LABEL_57;
      v50 = &v22[v30];
      v51 = v28 + 1;
      do
      {
        if (v51 >= v50)
          goto LABEL_208;
        v27 = *(v51 - 1) + (_DWORD)v27 + *v51;
        v51 += 2;
      }
      while ((int)v27 <= (int)v26);
      v28 = v51 - 1;
LABEL_57:
      *v29 = v25 + v24 + v27;
      if (v28 >= &v22[*(unsigned int *)(v9 + 104)])
        goto LABEL_208;
      v25 = 0;
      ++v29;
      v53 = *v28++;
      v52 = v53;
      v26 = v27;
      goto LABEL_67;
    case 9:
    case 0x14:
    case 0x19:
    case 0x29:
    case 0x34:
    case 0x39:
    case 0x40:
    case 0x49:
    case 0x54:
    case 0x59:
    case 0x69:
    case 0x74:
    case 0x79:
    case 0x89:
    case 0x94:
    case 0x99:
    case 0xA9:
    case 0xB4:
    case 0xB9:
    case 0xC0:
    case 0xC9:
    case 0xD4:
    case 0xD9:
    case 0xE9:
    case 0xF4:
    case 0xF9:
    case 0x109:
    case 0x114:
    case 0x119:
    case 0x129:
    case 0x134:
    case 0x139:
    case 0x140:
    case 0x149:
    case 0x154:
    case 0x159:
    case 0x169:
    case 0x174:
    case 0x179:
    case 0x189:
    case 0x194:
    case 0x199:
    case 0x1A9:
    case 0x1B4:
    case 0x1B9:
    case 0x1C0:
    case 0x1C9:
    case 0x1D4:
    case 0x1D9:
    case 0x1E9:
    case 0x1F4:
    case 0x1F9:
    case 0x209:
    case 0x214:
    case 0x219:
    case 0x229:
    case 0x234:
    case 0x239:
    case 0x240:
    case 0x249:
    case 0x254:
    case 0x259:
    case 0x269:
    case 0x274:
    case 0x279:
    case 0x289:
    case 0x294:
    case 0x299:
    case 0x2A9:
    case 0x2B4:
    case 0x2B9:
    case 0x2C0:
    case 0x2C9:
    case 0x2D4:
    case 0x2D9:
    case 0x2E9:
    case 0x2F4:
    case 0x2F9:
    case 0x309:
    case 0x314:
    case 0x319:
    case 0x329:
    case 0x334:
    case 0x339:
    case 0x340:
    case 0x349:
    case 0x354:
    case 0x359:
    case 0x369:
    case 0x374:
    case 0x379:
    case 0x389:
    case 0x394:
    case 0x399:
    case 0x3A9:
    case 0x3B4:
    case 0x3B9:
    case 0x3C0:
    case 0x3C9:
    case 0x3D4:
    case 0x3D9:
    case 0x3E9:
    case 0x3F4:
    case 0x3F9:
      if (v29 == (_DWORD *)v21 || (int)v27 > (int)v26)
        goto LABEL_20;
      v34 = v28 + 1;
      do
      {
        if (v34 >= &v22[v30])
          goto LABEL_208;
        LODWORD(v27) = *(v34 - 1) + v27 + *v34;
        v34 += 2;
      }
      while ((int)v27 <= (int)v26);
      v28 = v34 - 1;
LABEL_20:
      if (v28 + 1 >= &v22[v30])
        goto LABEL_208;
      v35 = *v28;
      v36 = v28[1];
      v28 += 2;
      v26 = v35 + v27;
      v25 += v24 + v26;
      v27 = v26 + v36;
      goto LABEL_77;
    case 0x10:
    case 0x50:
    case 0x80:
    case 0x90:
    case 0xD0:
    case 0x100:
    case 0x110:
    case 0x150:
    case 0x190:
    case 0x1D0:
    case 0x210:
    case 0x250:
    case 0x280:
    case 0x290:
    case 0x2D0:
    case 0x310:
    case 0x350:
    case 0x390:
    case 0x3D0:
    case 0x411:
    case 0x41CLL:
    case 0x429:
      if (v29 == (_DWORD *)v21 || (int)v27 > (int)v26)
        goto LABEL_74;
      v58 = &v22[v30];
      v59 = v28 + 1;
      do
      {
        if (v59 >= v58)
          goto LABEL_208;
        LODWORD(v27) = *(v59 - 1) + v27 + *v59;
        v59 += 2;
      }
      while ((int)v27 <= (int)v26);
      v28 = v59 - 1;
LABEL_74:
      v60 = *((_DWORD *)&TIFFFaxMainTable + 2 * v32 + 1);
      if ((int)v27 >= v60 + (int)v26)
      {
        v61 = v27 + v24 - v60;
        *v29++ = v61 + v25;
        v26 = (v61 + v26);
        v62 = *--v28;
        v27 = (v27 - v62);
        goto LABEL_76;
      }
      v86 = v18;
      v132 = v29;
      v136 = v20;
      v110 = v21;
      Fax3Unexpected("Fax4Decode", (uint64_t)a1, *(_DWORD *)(v9 + 152), v26, v20, v21, (uint64_t)&TIFFFaxMainTable, a8);
LABEL_185:
      v21 = v110;
      v13 = v133;
LABEL_192:
      v20 = v136;
      goto LABEL_144;
    case 0x20:
    case 0x60:
    case 0x84:
    case 0xA0:
    case 0xE0:
    case 0x120:
    case 0x160:
    case 0x184:
    case 0x1A0:
    case 0x1E0:
    case 0x220:
    case 0x260:
    case 0x284:
    case 0x2A0:
    case 0x2E0:
    case 0x320:
    case 0x360:
    case 0x384:
    case 0x3A0:
    case 0x3E0:
      if ((((_DWORD)v29 - (_DWORD)v21) & 4) != 0)
      {
        while (1)
        {
          if (v11 > 12)
            goto LABEL_49;
          if ((unint64_t)v23 >= v17)
          {
            if (!v11)
              goto LABEL_202;
            v11 = 13;
          }
          else
          {
            v12 |= *(unsigned __int8 *)(v19 + *v23) << v11;
            if (v11 > 4)
            {
              v11 += 8;
            }
            else
            {
              if ((unint64_t)(v23 + 1) < v17)
              {
                v44 = v23[1];
                v23 += 2;
                v12 |= *(unsigned __int8 *)(v19 + v44) << (v11 + 8);
                v11 += 16;
                goto LABEL_49;
              }
              v11 = 13;
            }
            ++v23;
          }
LABEL_49:
          v45 = v12 & 0x1FFF;
          v46 = (unsigned __int8 *)&TIFFFaxBlackTable[2 * v45];
          v47 = v46[1];
          v11 -= v47;
          v12 >>= v47;
          v48 = *v46;
          if ((v48 - 10) >= 2)
          {
            if (v48 != 8)
            {
              v84 = v21;
              v85 = v10;
              v86 = v18;
              v87 = v20;
              v132 = v29;
LABEL_140:
              v89 = (uint64_t)a1;
              goto LABEL_143;
            }
            v71 = TIFFFaxBlackTable[2 * v45 + 1];
            *v29 = v71 + v25;
            v64 = v29 + 1;
            v26 = (v71 + v26);
            v25 = 0;
            while (2)
            {
              if (v11 <= 11)
              {
                if ((unint64_t)v23 >= v17)
                {
                  if (!v11)
                  {
LABEL_204:
                    v115 = v21;
                    v116 = v10;
                    v117 = v18;
                    v136 = v20;
                    v119 = v133;
                    v118 = v64;
                    goto LABEL_205;
                  }
                  v11 = 12;
                  goto LABEL_105;
                }
                v12 |= *(unsigned __int8 *)(v19 + *v23) << v11;
                if (v11 > 3)
                {
                  v11 += 8;
                }
                else
                {
                  if ((unint64_t)(v23 + 1) < v17)
                  {
                    v72 = v23[1];
                    v23 += 2;
                    v12 |= *(unsigned __int8 *)(v19 + v72) << (v11 + 8);
                    v11 += 16;
                    goto LABEL_105;
                  }
                  v11 = 12;
                }
                ++v23;
              }
LABEL_105:
              v73 = v12 & 0xFFF;
              v74 = (unsigned __int8 *)&TIFFFaxWhiteTable[2 * v73];
              v75 = v74[1];
              v11 -= v75;
              v12 >>= v75;
              v76 = *v74;
              if (v76 != 9 && v76 != 11)
              {
                if (v76 == 7)
                {
                  if ((unint64_t)v64 >= v21 + 4 * (unint64_t)*(unsigned int *)(v9 + 104))
                    goto LABEL_208;
                  v79 = (char *)&TIFFFaxWhiteTable[2 * v73];
LABEL_117:
                  v80 = *((_DWORD *)v79 + 1);
                  *v64 = v80 + v25;
                  v26 = (v80 + v26);
                  v29 += 2;
                  if (v29 != (_DWORD *)v21)
                  {
                    if ((int)v27 <= (int)v26 && (int)v27 < (int)v18)
                    {
                      v82 = v28 + 1;
                      while (v82 < &v22[*(unsigned int *)(v9 + 104)])
                      {
                        v27 = *(v82 - 1) + (_DWORD)v27 + *v82;
                        v82 += 2;
                        if ((int)v27 > (int)v26 || (int)v27 >= (int)v18)
                        {
                          v25 = 0;
                          v28 = v82 - 1;
                          goto LABEL_77;
                        }
                      }
                      v120 = a1[150];
                      goto LABEL_209;
                    }
LABEL_76:
                    v25 = 0;
                    goto LABEL_77;
                  }
                  v25 = 0;
                  v29 = (_DWORD *)v21;
LABEL_77:
                  v24 = -(int)v26;
                  if ((int)v26 >= (int)v18)
                  {
                    if (!v25)
                    {
                      v8 = a1;
                      v13 = v133;
                      goto LABEL_149;
                    }
                    v13 = v133;
                    if (v25 + (int)v26 >= (int)v18)
                      goto LABEL_198;
                    if (v11 > 0)
                      goto LABEL_195;
                    if ((unint64_t)v23 < v17)
                    {
                      v88 = *v23++;
                      v12 |= *(unsigned __int8 *)(v19 + v88) << v11;
                      v11 += 8;
                      goto LABEL_195;
                    }
                    if (v11)
                    {
                      v11 = 1;
LABEL_195:
                      if ((v12 & 1) == 0)
                      {
LABEL_196:
                        v113 = v21;
                        v86 = v18;
                        v132 = v29;
                        v137 = v20;
                        Fax3Unexpected("Fax4Decode", (uint64_t)a1, *(_DWORD *)(v9 + 152), v26, v20, v21, (uint64_t)&TIFFFaxMainTable, a8);
                        v13 = v133;
                        v20 = v137;
                        v21 = v113;
LABEL_144:
                        if (v25)
                        {
                          v29 = v132;
                          v17 = v139;
                          v19 = v140;
                          if ((unint64_t)v132 >= v21 + 4 * (unint64_t)*(unsigned int *)(v9 + 104))
                            goto LABEL_208;
                          v18 = v86;
                          goto LABEL_147;
                        }
                        v8 = a1;
                        v17 = v139;
                        v19 = v140;
                        v29 = v132;
                        v18 = v86;
LABEL_149:
                        if ((_DWORD)v26 == (_DWORD)v18)
                          goto LABEL_173;
                        v134 = v23;
                        v90 = v21;
                        v91 = v10;
                        v92 = v18;
                        v93 = v29;
                        v135 = v20;
                        v94 = v13;
                        v95 = "Line length mismatch";
                        if (v26 < v18)
                          v95 = "Premature EOL";
                        TIFFWarningExtR((uint64_t)v8, "Fax4Decode", "%s at line %u of %s %u (got %u, expected %u)", v18, v20, v21, (uint64_t)v16, a8, (char)v95);
                        v96 = (int)v26 > (int)v92;
                        if ((int)v26 <= (int)v92)
                        {
                          v13 = v94;
                          v20 = v135;
                          v17 = v139;
                          v19 = v140;
                          v29 = v93;
                        }
                        else
                        {
                          v29 = v93;
                          if ((unint64_t)v93 > v90)
                          {
                            v97 = v93 - 1;
                            v98 = v93 - 1;
                            v13 = v94;
                            v17 = v139;
                            v19 = v140;
                            v18 = v92;
                            v10 = v91;
                            v21 = v90;
                            do
                            {
                              v99 = *v98--;
                              LODWORD(v26) = v26 - v99;
                              v96 = (int)v26 > (int)v92;
                              v100 = (int)v26 > (int)v92 && (unint64_t)v97 > v90;
                              v97 = v98;
                            }
                            while (v100);
                            v29 = v98 + 1;
                            v20 = v135;
LABEL_163:
                            v23 = v134;
                            if ((int)v26 < (int)v18)
                            {
                              if ((((_DWORD)v29 - (_DWORD)v21) & 4) == 0)
                                goto LABEL_167;
                              if ((unint64_t)v29 < v21 + 4 * (unint64_t)*(unsigned int *)(v9 + 104))
                              {
                                *v29++ = 0;
LABEL_167:
                                if ((unint64_t)v29 < v21 + 4 * (unint64_t)*(unsigned int *)(v9 + 104))
                                {
                                  *v29++ = v18 - (v26 & ~((int)v26 >> 31));
                                  goto LABEL_173;
                                }
                              }
LABEL_238:
                              v120 = v8[150];
                              goto LABEL_209;
                            }
                            if (v96)
                            {
                              v101 = v141;
                              if ((unint64_t)v29 >= v21 + 4 * (unint64_t)*(unsigned int *)(v9 + 104))
                                goto LABEL_238;
                              *v29 = v18;
                              if ((unint64_t)(v29 + 1) >= v21
                                                                + 4 * (unint64_t)*(unsigned int *)(v9 + 104))
                                goto LABEL_238;
                              v29[1] = 0;
                              v29 += 2;
                              v20 = v135;
LABEL_174:
                              if (!v13)
                              {
                                if ((int)v20 <= (int)v10)
                                {
                                  v102 = v23;
                                  v103 = v10;
                                  v104 = v20;
                                  v105 = v29;
                                  v106 = v18;
                                  v107 = v21;
                                  v108 = v101;
                                  (*(void (**)(void))(v9 + 88))();
                                  if ((unint64_t)v105 >= v107
                                                               + 4 * (unint64_t)*(unsigned int *)(v9 + 104))
                                  {
                                    v120 = a1[150];
                                    goto LABEL_209;
                                  }
                                  v13 = 0;
                                  *v105 = 0;
                                  v21 = *(_QWORD *)(v9 + 112);
                                  v22 = *(unsigned int **)(v9 + 120);
                                  *(_QWORD *)(v9 + 112) = v22;
                                  *(_QWORD *)(v9 + 120) = v21;
                                  v109 = *(_QWORD *)(v9 + 8);
                                  a2 = v108 + v109;
                                  ++*(_DWORD *)(v9 + 152);
                                  v10 = v103 - v109;
                                  v17 = v139;
                                  v19 = v140;
                                  v20 = v104;
                                  v18 = v106;
                                  v23 = v102;
                                  v16 = &TIFFFaxMainTable;
                                  v8 = a1;
                                  if (v103 <= v109)
                                  {
                                    v13 = 0;
                                    v14 = a1[144];
                                    v15 = a1[145];
LABEL_201:
                                    *(_DWORD *)(v9 + 72) = v12;
                                    *(_DWORD *)(v9 + 76) = v11;
                                    *(_DWORD *)(v9 + 80) = v13;
                                    v8[145] = v14 - (_QWORD)v23 + v15;
                                    v8[144] = v23;
                                    return 1;
                                  }
                                  goto LABEL_5;
                                }
LABEL_252:
                                TIFFErrorExtR((uint64_t)v8, "Fax4Decode", "Buffer overrun detected : %lld bytes available, %d bits needed", v18, v20, v21, (uint64_t)v16, a8, v10);
                                return 0xFFFFFFFFLL;
                              }
                              if (v11 > 12)
                                goto LABEL_251;
                              goto LABEL_241;
                            }
LABEL_173:
                            v101 = v141;
                            goto LABEL_174;
                          }
                          v13 = v94;
                          v20 = v135;
                          v17 = v139;
                          v19 = v140;
                        }
                        v18 = v92;
                        v10 = v91;
                        v21 = v90;
                        goto LABEL_163;
                      }
                      --v11;
                      v12 >>= 1;
LABEL_198:
                      if ((unint64_t)v29 >= v21 + 4 * (unint64_t)*(unsigned int *)(v9 + 104))
                        goto LABEL_208;
LABEL_147:
                      *v29++ = v25;
                      v8 = a1;
                      goto LABEL_149;
                    }
                    v115 = v21;
                    v116 = v10;
                    v117 = v18;
                    v136 = v20;
                    v118 = v29;
                    v119 = v133;
LABEL_205:
                    TIFFWarningExtR((uint64_t)a1, "Fax4Decode", "Premature EOF at line %u of %s %u (x %u)", v18, v20, v21, (uint64_t)&TIFFFaxMainTable, a8, *(_DWORD *)(v9 + 152));
                    if (v25)
                    {
                      v20 = v136;
                      if ((unint64_t)v118 >= v115 + 4 * *(unsigned int *)(v9 + 104))
                        goto LABEL_208;
                      v13 = v119;
                      v18 = v117;
                      *v118 = v25;
                      v29 = v118 + 1;
                    }
                    else
                    {
                      v13 = v119;
                      v29 = v118;
                      v20 = v136;
                      v18 = v117;
                    }
                    v8 = a1;
                    if ((_DWORD)v26 == (_DWORD)v18)
                    {
                      v11 = 0;
                      v19 = v140;
                      v101 = v141;
                      v17 = v139;
                      LODWORD(v10) = v116;
                      v21 = v115;
                      goto LABEL_241;
                    }
                    v121 = v18;
                    v122 = v29;
                    v138 = v20;
                    v123 = v13;
                    Fax3BadLength("Fax4Decode", (uint64_t)a1, *(unsigned int *)(v9 + 152), v26, v18, v21, (uint64_t)v16, a8);
                    v124 = (int)v26 > (int)v121;
                    if ((int)v26 <= (int)v121)
                    {
                      v13 = v123;
                      v20 = v138;
                      v17 = v139;
                      v19 = v140;
                      v29 = v122;
                      v18 = v121;
                      LODWORD(v10) = v116;
                      v21 = v115;
                    }
                    else
                    {
                      v29 = v122;
                      v21 = v115;
                      if ((unint64_t)v122 <= v115)
                      {
                        v13 = v123;
                        v20 = v138;
                        v17 = v139;
                        v19 = v140;
                        v18 = v121;
                      }
                      else
                      {
                        v125 = v122 - 1;
                        v126 = v122 - 1;
                        v13 = v123;
                        v17 = v139;
                        v19 = v140;
                        v18 = v121;
                        do
                        {
                          v127 = *v126--;
                          LODWORD(v26) = v26 - v127;
                          v124 = (int)v26 > (int)v121;
                          v128 = (int)v26 > (int)v121 && (unint64_t)v125 > v115;
                          v125 = v126;
                        }
                        while (v128);
                        v29 = v126 + 1;
                        v20 = v138;
                      }
                      LODWORD(v10) = v116;
                    }
                    if ((int)v26 >= (int)v18)
                    {
                      if (!v124)
                      {
                        v11 = 0;
                        goto LABEL_240;
                      }
                      v101 = v141;
                      if ((unint64_t)v29 >= v21 + 4 * (unint64_t)*(unsigned int *)(v9 + 104))
                        goto LABEL_238;
                      *v29 = v18;
                      if ((unint64_t)(v29 + 1) >= v21 + 4 * (unint64_t)*(unsigned int *)(v9 + 104))
                        goto LABEL_238;
                      v11 = 0;
                      v29[1] = 0;
                      v29 += 2;
                      v20 = v138;
                    }
                    else
                    {
                      if ((((_DWORD)v29 - (_DWORD)v21) & 4) != 0)
                      {
                        if ((unint64_t)v29 >= v21 + 4 * (unint64_t)*(unsigned int *)(v9 + 104))
                          goto LABEL_238;
                        *v29++ = 0;
                      }
                      if ((unint64_t)v29 >= v21 + 4 * (unint64_t)*(unsigned int *)(v9 + 104))
                        goto LABEL_238;
                      v11 = 0;
                      *v29++ = v18 - (v26 & ~((int)v26 >> 31));
LABEL_240:
                      v101 = v141;
                    }
LABEL_241:
                    if ((unint64_t)v23 >= v17)
                    {
                      if (v11)
                        v11 = 13;
                      else
                        v11 = 0;
                    }
                    else
                    {
                      v12 |= *(unsigned __int8 *)(v19 + *v23) << v11;
                      if (v11 > 4)
                      {
                        v11 += 8;
                      }
                      else
                      {
                        if ((unint64_t)(v23 + 1) < v17)
                        {
                          v129 = v23[1];
                          v23 += 2;
                          v12 |= *(unsigned __int8 *)(v19 + v129) << (v11 + 8);
                          v11 += 16;
                          goto LABEL_251;
                        }
                        v11 = 13;
                      }
                      ++v23;
                    }
LABEL_251:
                    if ((int)v20 <= (int)v10)
                    {
                      v130 = v13;
                      (*(void (**)(uint64_t, uint64_t, _DWORD *))(v9 + 88))(v101, v21, v29);
                      *(_DWORD *)(v9 + 72) = v12 >> 13;
                      *(_DWORD *)(v9 + 76) = v11 - 13;
                      *(_DWORD *)(v9 + 80) = v130;
                      v8[145] += v8[144] - (_QWORD)v23;
                      v8[144] = v23;
                      if (*(_DWORD *)(v9 + 152))
                        return 1;
                      else
                        return 0xFFFFFFFFLL;
                    }
                    goto LABEL_252;
                  }
                  goto LABEL_7;
                }
                v84 = v21;
                v85 = v10;
                v86 = v18;
                v87 = v20;
                v132 = v29 + 1;
LABEL_142:
                v89 = (uint64_t)a1;
LABEL_143:
                TIFFErrorExtR(v89, "Fax4Decode", "Bad code word at line %u of %s %u (x %u)", v18, v20, v21, (uint64_t)&TIFFFaxMainTable, a8, *(_DWORD *)(v9 + 152));
                v13 = v133;
                v20 = v87;
                v10 = v85;
                v21 = v84;
                goto LABEL_144;
              }
              v78 = TIFFFaxWhiteTable[2 * v73 + 1];
              v26 = (v78 + v26);
              v25 += v78;
              continue;
            }
          }
          v49 = TIFFFaxBlackTable[2 * v45 + 1];
          v26 = (v49 + v26);
          v25 += v49;
        }
      }
      while (1)
      {
        if (v11 > 11)
          goto LABEL_33;
        if ((unint64_t)v23 >= v17)
        {
          if (!v11)
            goto LABEL_202;
          v11 = 12;
        }
        else
        {
          v12 |= *(unsigned __int8 *)(v19 + *v23) << v11;
          if (v11 > 3)
          {
            v11 += 8;
          }
          else
          {
            if ((unint64_t)(v23 + 1) < v17)
            {
              v37 = v23[1];
              v23 += 2;
              v12 |= *(unsigned __int8 *)(v19 + v37) << (v11 + 8);
              v11 += 16;
              goto LABEL_33;
            }
            v11 = 12;
          }
          ++v23;
        }
LABEL_33:
        v38 = v12 & 0xFFF;
        v39 = (unsigned __int8 *)&TIFFFaxWhiteTable[2 * v38];
        v40 = v39[1];
        v11 -= v40;
        v12 >>= v40;
        v41 = *v39;
        if (v41 != 9 && v41 != 11)
          break;
        v43 = TIFFFaxWhiteTable[2 * v38 + 1];
        v26 = (v43 + v26);
        v25 += v43;
      }
      if (v41 != 7)
      {
        v84 = v21;
        v85 = v10;
        v86 = v18;
        v87 = v20;
        v132 = v29;
        goto LABEL_142;
      }
      v63 = TIFFFaxWhiteTable[2 * v38 + 1];
      *v29 = v63 + v25;
      v64 = v29 + 1;
      v26 = (v63 + v26);
      v25 = 0;
      while (2)
      {
        if (v11 > 12)
          goto LABEL_91;
        if ((unint64_t)v23 >= v17)
        {
          if (!v11)
            goto LABEL_204;
          v11 = 13;
        }
        else
        {
          v12 |= *(unsigned __int8 *)(v19 + *v23) << v11;
          if (v11 > 4)
          {
            v11 += 8;
          }
          else
          {
            if ((unint64_t)(v23 + 1) < v17)
            {
              v65 = v23[1];
              v23 += 2;
              v12 |= *(unsigned __int8 *)(v19 + v65) << (v11 + 8);
              v11 += 16;
              goto LABEL_91;
            }
            v11 = 13;
          }
          ++v23;
        }
LABEL_91:
        v66 = v12 & 0x1FFF;
        v67 = (unsigned __int8 *)&TIFFFaxBlackTable[2 * v66];
        v68 = v67[1];
        v11 -= v68;
        v12 >>= v68;
        v69 = *v67;
        if ((v69 - 10) < 2)
        {
          v70 = TIFFFaxBlackTable[2 * v66 + 1];
          v26 = (v70 + v26);
          v25 += v70;
          continue;
        }
        break;
      }
      if (v69 != 8)
      {
        v84 = v21;
        v85 = v10;
        v86 = v18;
        v87 = v20;
        v132 = v29 + 1;
        goto LABEL_140;
      }
      if ((unint64_t)v64 < v21 + 4 * (unint64_t)*(unsigned int *)(v9 + 104))
      {
        v79 = (char *)&TIFFFaxBlackTable[2 * v66];
        goto LABEL_117;
      }
LABEL_208:
      v120 = a1[150];
LABEL_209:
      TIFFErrorExt(v120, "Fax4Decode", "Buffer overflow at line %u of %s %u", v18, v20, v21, (uint64_t)v16, a8, *(_DWORD *)(v9 + 152));
      return 0xFFFFFFFFLL;
    case 0x30:
    case 0x41:
    case 0x70:
    case 0xB0:
    case 0xC1:
    case 0xF0:
    case 0x130:
    case 0x141:
    case 0x170:
    case 0x180:
    case 0x1B0:
    case 0x1C1:
    case 0x1F0:
    case 0x230:
    case 0x241:
    case 0x270:
    case 0x2B0:
    case 0x2C1:
    case 0x2F0:
    case 0x300:
    case 0x330:
    case 0x341:
    case 0x370:
    case 0x380:
    case 0x3B0:
    case 0x3C1:
    case 0x3F0:
    case 0x409:
    case 0x419:
      if (v29 == (_DWORD *)v21 || (int)v27 > (int)v26)
        goto LABEL_65;
      v54 = &v22[v30];
      v55 = v28 + 1;
      do
      {
        if (v55 >= v54)
          goto LABEL_208;
        LODWORD(v27) = *(v55 - 1) + v27 + *v55;
        v55 += 2;
      }
      while ((int)v27 <= (int)v26);
      v28 = v55 - 1;
LABEL_65:
      v56 = *((_DWORD *)&TIFFFaxMainTable + 2 * v32 + 1);
      *v29 = v25 + v24 + v27 + v56;
      if (v28 >= &v22[*(unsigned int *)(v9 + 104)])
        goto LABEL_208;
      v25 = 0;
      v26 = (v56 + v27);
      ++v29;
      v57 = *v28++;
      v52 = v57;
LABEL_67:
      v27 = (v52 + v27);
      goto LABEL_77;
    case 0x81:
    case 0x181:
    case 0x200:
    case 0x281:
    case 0x381:
    case 0x421:
    case 0x431:
      v86 = v18;
      *v29 = v18 - v26;
      v132 = v29 + 1;
      v136 = v20;
      v110 = v21;
      Fax3Extension("Fax4Decode", (uint64_t)a1, *(_DWORD *)(v9 + 152), v26, v20, v21, (uint64_t)&TIFFFaxMainTable, a8);
      goto LABEL_185;
    default:
      goto LABEL_196;
  }
}

uint64_t Fax4Encode(_QWORD *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  uint64_t v13;
  BOOL v14;
  char v15;

  v9 = a1[137];
  if (a3 % *(_QWORD *)(v9 + 8))
  {
    TIFFErrorExtR((uint64_t)a1, "Fax4Encode", "Fractional scanlines cannot be written", a4, a5, a6, a7, a8, v15);
    return 0;
  }
  else
  {
    v11 = a3;
    if (a3 < 1)
    {
      return 1;
    }
    else
    {
      while (1)
      {
        result = Fax3Encode2DRow(a1, a2, *(char **)(v9 + 136), *(unsigned int *)(v9 + 16), a5, a6, a7, a8);
        if (!(_DWORD)result)
          break;
        _TIFFmemcpy(*(void **)(v9 + 136), a2, *(_QWORD *)(v9 + 8));
        v13 = *(_QWORD *)(v9 + 8);
        a2 += v13;
        v14 = v11 <= v13;
        v11 -= v13;
        if (v14)
          return 1;
      }
    }
  }
  return result;
}

uint64_t Fax4PostEncode(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char v23;
  _BYTE *v24;

  v9 = a1[137];
  v10 = 1;
  Fax3PutBits(a1, 1, 12, a4, a5, a6, a7, a8);
  Fax3PutBits(a1, 1, 12, v11, v12, v13, v14, v15);
  if (*(_DWORD *)(v9 + 76) != 8)
  {
    if (a1[145] < a1[141] || TIFFFlushData1((uint64_t)a1, v16, v17, v18, v19, v20, v21, v22))
    {
      v23 = *(_DWORD *)(v9 + 72);
      v24 = (_BYTE *)a1[144];
      a1[144] = v24 + 1;
      *v24 = v23;
      ++a1[145];
      *(_QWORD *)(v9 + 72) = 0x800000000;
    }
    else
    {
      return 0;
    }
  }
  return v10;
}

uint64_t TIFFInitCCITTRLE(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  result = InitCCITTFax3((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
  if ((_DWORD)result)
  {
    a1[126] = Fax3DecodeRLE;
    a1[128] = Fax3DecodeRLE;
    a1[130] = Fax3DecodeRLE;
    return _cg_TIFFSetField((uint64_t)a1, 0x10000, v10, v11, v12, v13, v14, v15, 7);
  }
  return result;
}

uint64_t Fax3DecodeRLE(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v10;
  int v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  _DWORD *v20;
  unsigned __int8 *v21;
  int v22;
  _DWORD *v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  int v29;
  int v30;
  _DWORD *v31;
  uint64_t v32;
  uint64_t v33;
  unsigned __int8 *v34;
  int v35;
  int v36;
  int v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  const char *v42;
  _BOOL4 v43;
  unint64_t v44;
  int *v45;
  int *v46;
  int v47;
  BOOL v48;
  char v49;
  char v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  const char *v56;
  _BOOL4 v57;
  int *v58;
  int *v59;
  int v60;
  BOOL v61;
  uint64_t v62;
  int v63;
  _DWORD *v64;
  char v65;
  int v66;
  uint64_t v67;
  int v68;
  _QWORD *v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  uint64_t v73;

  v8 = a1[137];
  if (a3 % *(_QWORD *)(v8 + 8))
  {
    TIFFErrorExtR((uint64_t)a1, "Fax3DecodeRLE", "Fractional scanlines cannot be read", a4, a5, a6, a7, a8, v65);
    return 0xFFFFFFFFLL;
  }
  v10 = a3;
  v12 = *(_DWORD *)(v8 + 72);
  v11 = *(_DWORD *)(v8 + 76);
  v13 = *(_DWORD *)(v8 + 80);
  v14 = a1[144];
  v15 = a1[145];
  if (a3 < 1)
  {
    v21 = (unsigned __int8 *)a1[144];
LABEL_85:
    *(_DWORD *)(v8 + 72) = v12;
    *(_DWORD *)(v8 + 76) = v11;
    *(_DWORD *)(v8 + 80) = v13;
    a1[145] = v14 - (_QWORD)v21 + v15;
    a1[144] = v21;
    return 1;
  }
  v66 = *(_DWORD *)(v8 + 80);
  v69 = a1;
  v17 = *(unsigned int *)(v8 + 16);
  v18 = *(_QWORD *)(v8 + 64);
  v19 = v14 + v15;
  v68 = *(_DWORD *)(v8 + 4);
  v20 = *(_DWORD **)(v8 + 120);
  v21 = (unsigned __int8 *)a1[144];
  v73 = a1[137];
  v72 = (unint64_t)v20;
  v67 = v18;
  while (2)
  {
    v70 = v10;
    v71 = a2;
    v22 = 0;
    v23 = v20;
    while (2)
    {
      v24 = 0;
      while (2)
      {
        if (v11 > 11)
          goto LABEL_18;
        if ((unint64_t)v21 >= v19)
        {
          if (v11)
          {
            v11 = 12;
            goto LABEL_18;
          }
LABEL_81:
          v52 = v8;
          TIFFWarningExtR((uint64_t)v69, "Fax3DecodeRLE", "Premature EOF at line %u of %s %u (x %u)", a4, a5, a6, a7, a8, *(_DWORD *)(v8 + 152));
          if (v24)
          {
            v53 = v52;
            if ((unint64_t)v23 >= v72 + 4 * *(unsigned int *)(v52 + 104))
              goto LABEL_112;
            *v23++ = v24;
          }
          else
          {
            v53 = v52;
          }
          if (v22 == (_DWORD)v17)
          {
            v54 = v71;
            v55 = v72;
LABEL_115:
            v64 = (_DWORD *)v53;
            (*(void (**)(uint64_t, unint64_t, _DWORD *, uint64_t))(v53 + 88))(v54, v55, v23, v17);
            v64[18] = v12;
            v64[19] = 0;
            v64[20] = v66;
            v69[145] += v69[144] - (_QWORD)v21;
            v69[144] = v21;
            return 0xFFFFFFFFLL;
          }
          v56 = "Line length mismatch";
          if (v22 < v17)
            v56 = "Premature EOL";
          TIFFWarningExtR((uint64_t)v69, "Fax3DecodeRLE", "%s at line %u of %s %u (got %u, expected %u)", a4, a5, a6, a7, a8, (char)v56);
          v57 = v22 > (int)v17;
          if (v22 <= (int)v17)
          {
            v53 = v73;
            v55 = v72;
          }
          else
          {
            v55 = v72;
            if ((unint64_t)v23 <= v72)
            {
              v53 = v73;
            }
            else
            {
              v58 = v23 - 1;
              v59 = v23 - 1;
              v53 = v73;
              do
              {
                v60 = *v59--;
                v22 -= v60;
                v57 = v22 > (int)v17;
                v61 = v22 > (int)v17 && (unint64_t)v58 > v72;
                v58 = v59;
              }
              while (v61);
              v23 = v59 + 1;
            }
          }
          if (v22 >= (int)v17)
          {
            if (!v57)
              goto LABEL_114;
            v54 = v71;
            if ((unint64_t)v23 < v55 + 4 * *(unsigned int *)(v53 + 104))
            {
              *v23 = v17;
              if ((unint64_t)(v23 + 1) < v55 + 4 * *(unsigned int *)(v53 + 104))
              {
                v23[1] = 0;
                v23 += 2;
                goto LABEL_115;
              }
            }
          }
          else
          {
            if ((((_DWORD)v23 - (_DWORD)v55) & 4) != 0)
            {
              if ((unint64_t)v23 >= v55 + 4 * *(unsigned int *)(v53 + 104))
                goto LABEL_112;
              *v23++ = 0;
            }
            if ((unint64_t)v23 < v55 + 4 * *(unsigned int *)(v53 + 104))
            {
              *v23++ = v17 - (v22 & ~(v22 >> 31));
LABEL_114:
              v54 = v71;
              goto LABEL_115;
            }
          }
LABEL_112:
          v62 = v69[150];
          v63 = *(_DWORD *)(v53 + 152);
          goto LABEL_113;
        }
        v12 |= *(unsigned __int8 *)(v18 + *v21) << v11;
        if (v11 > 3)
        {
          v11 += 8;
        }
        else
        {
          if ((unint64_t)(v21 + 1) < v19)
          {
            v25 = v21[1];
            v21 += 2;
            v12 |= *(unsigned __int8 *)(v18 + v25) << (v11 + 8);
            v11 += 16;
            goto LABEL_18;
          }
          v11 = 12;
        }
        ++v21;
LABEL_18:
        v26 = v12 & 0xFFF;
        v27 = BYTE1(TIFFFaxWhiteTable[2 * v26]);
        v11 -= v27;
        v12 >>= v27;
        switch(8 * v26)
        {
          case 0:
          case 0x24:
            goto LABEL_42;
          case 1:
          case 0x14:
          case 0x2CLL:
          case 0x30:
            v28 = TIFFFaxWhiteTable[2 * v26 + 1];
            v22 += v28;
            v24 += v28;
            continue;
          case 8:
          case 0x10:
          case 0x18:
          case 0x20:
          case 0x28:
            if (v23 >= &v20[*(unsigned int *)(v8 + 104)])
              goto LABEL_99;
            v29 = TIFFFaxWhiteTable[2 * v26 + 1];
            v30 = v29 + v24;
            v31 = v23;
            *v23++ = v29 + v24;
            v22 += v29;
            if (v22 >= (int)v17)
              goto LABEL_49;
            v24 = 0;
            break;
          default:
            v39 = (uint64_t)v69;
            goto LABEL_47;
        }
        break;
      }
      while (1)
      {
        if (v11 > 12)
          goto LABEL_33;
        if ((unint64_t)v21 >= v19)
        {
          if (!v11)
            goto LABEL_81;
          v11 = 13;
        }
        else
        {
          v12 |= *(unsigned __int8 *)(v18 + *v21) << v11;
          if (v11 > 4)
          {
            v11 += 8;
          }
          else
          {
            if ((unint64_t)(v21 + 1) < v19)
            {
              v32 = v21[1];
              v21 += 2;
              v12 |= *(unsigned __int8 *)(v18 + v32) << (v11 + 8);
              v11 += 16;
              goto LABEL_33;
            }
            v11 = 13;
          }
          ++v21;
        }
LABEL_33:
        v33 = v12 & 0x1FFF;
        v34 = (unsigned __int8 *)&TIFFFaxBlackTable[2 * v33];
        v35 = v34[1];
        v11 -= v35;
        v12 >>= v35;
        v36 = *v34;
        if ((v36 - 10) >= 2)
          break;
        v37 = TIFFFaxBlackTable[2 * v33 + 1];
        v22 += v37;
        v24 += v37;
      }
      if (v36 == 12)
      {
LABEL_42:
        v66 = 1;
        if (!v24)
        {
LABEL_48:
          v8 = v73;
          break;
        }
LABEL_43:
        v8 = v73;
        if (v23 < &v20[*(unsigned int *)(v73 + 104)])
        {
          *v23++ = v24;
          break;
        }
        goto LABEL_99;
      }
      if (v36 != 8)
      {
        v39 = (uint64_t)v69;
LABEL_47:
        TIFFErrorExtR(v39, "Fax3DecodeRLE", "Bad code word at line %u of %s %u (x %u)", a4, a5, a6, a7, a8, *(_DWORD *)(v8 + 152));
        v20 = (_DWORD *)v72;
        if (!v24)
          goto LABEL_48;
        goto LABEL_43;
      }
      if (v23 >= &v20[*(unsigned int *)(v8 + 104)])
        goto LABEL_99;
      v38 = TIFFFaxBlackTable[2 * v33 + 1];
      v23 = v31 + 2;
      v31[1] = v38 + v24;
      v22 += v38;
      if (v22 < (int)v17)
      {
        if (!((v38 + v24) | v30))
          v23 = v31;
        continue;
      }
      break;
    }
LABEL_49:
    if (v22 == (_DWORD)v17)
    {
      v41 = v70;
      v40 = v71;
      goto LABEL_74;
    }
    v42 = "Line length mismatch";
    if (v22 < v17)
      v42 = "Premature EOL";
    TIFFWarningExtR((uint64_t)v69, "Fax3DecodeRLE", "%s at line %u of %s %u (got %u, expected %u)", a4, a5, a6, a7, a8, (char)v42);
    v43 = v22 > (int)v17;
    if (v22 <= (int)v17)
    {
      v8 = v73;
      v44 = v72;
    }
    else
    {
      v44 = v72;
      if ((unint64_t)v23 > v72)
      {
        v45 = v23 - 1;
        v46 = v23 - 1;
        do
        {
          v47 = *v46--;
          v22 -= v47;
          v43 = v22 > (int)v17;
          v48 = v22 > (int)v17 && (unint64_t)v45 > v72;
          v45 = v46;
        }
        while (v48);
        v23 = v46 + 1;
      }
      v8 = v73;
    }
    v41 = v70;
    if (v22 < (int)v17)
    {
      if ((((_DWORD)v23 - (_DWORD)v44) & 4) == 0)
        goto LABEL_67;
      if ((unint64_t)v23 >= v44 + 4 * *(unsigned int *)(v8 + 104))
        goto LABEL_99;
      *v23++ = 0;
LABEL_67:
      if ((unint64_t)v23 >= v44 + 4 * *(unsigned int *)(v8 + 104))
        goto LABEL_99;
      *v23 = v17 - (v22 & ~(v22 >> 31));
LABEL_73:
      v40 = v71;
LABEL_74:
      (*(void (**)(uint64_t))(v8 + 88))(v40);
      if ((v68 & 4) != 0)
      {
        v50 = v11 & 7;
        v11 &= 0xFFFFFFF8;
        v12 >>= v50;
      }
      else if ((v68 & 8) != 0)
      {
        v49 = v11 & 0xF;
        v11 &= 0xFFFFFFF0;
        v12 >>= v49;
        v21 += (v11 == 0) & v21;
      }
      v8 = v73;
      v20 = (_DWORD *)v72;
      v18 = v67;
      v51 = *(_QWORD *)(v73 + 8);
      a2 = v40 + v51;
      ++*(_DWORD *)(v73 + 152);
      v48 = v41 <= v51;
      v10 = v41 - v51;
      if (v48)
      {
        a1 = v69;
        v14 = v69[144];
        v15 = v69[145];
        v13 = v66;
        goto LABEL_85;
      }
      continue;
    }
    break;
  }
  if (!v43)
    goto LABEL_73;
  if ((unint64_t)v23 < v44 + 4 * *(unsigned int *)(v8 + 104))
  {
    *v23 = v17;
    if ((unint64_t)(v23 + 1) < v44 + 4 * *(unsigned int *)(v8 + 104))
    {
      v23[1] = 0;
      goto LABEL_73;
    }
  }
LABEL_99:
  v62 = v69[150];
  v63 = *(_DWORD *)(v8 + 152);
LABEL_113:
  TIFFErrorExt(v62, "Fax3DecodeRLE", "Buffer overflow at line %u of %s %u", a4, a5, a6, a7, a8, v63);
  return 0xFFFFFFFFLL;
}

uint64_t TIFFInitCCITTRLEW(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  result = InitCCITTFax3((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
  if ((_DWORD)result)
  {
    a1[126] = Fax3DecodeRLE;
    a1[128] = Fax3DecodeRLE;
    a1[130] = Fax3DecodeRLE;
    return _cg_TIFFSetField((uint64_t)a1, 0x10000, v10, v11, v12, v13, v14, v15, 11);
  }
  return result;
}

uint64_t Fax3VGetField(uint64_t a1, int a2, _QWORD **a3)
{
  uint64_t v3;
  int v4;

  v3 = *(_QWORD *)(a1 + 1096);
  if (!v3)
    Fax3VGetField_cold_1();
  if (a2 > 327)
  {
    switch(a2)
    {
      case 328:
        v4 = *(_DWORD *)(v3 + 24);
        break;
      case 65540:
        **a3 = *(_QWORD *)(v3 + 88);
        return 1;
      case 65536:
        v4 = *(_DWORD *)(v3 + 4);
        break;
      default:
        return (*(uint64_t (**)(void))(v3 + 40))();
    }
LABEL_14:
    *(_DWORD *)*a3 = v4;
    return 1;
  }
  if ((a2 - 292) < 2)
  {
    v4 = *(_DWORD *)(v3 + 32);
    goto LABEL_14;
  }
  if (a2 == 326)
  {
    v4 = *(_DWORD *)(v3 + 28);
    goto LABEL_14;
  }
  if (a2 == 327)
  {
    *(_WORD *)*a3 = *(_WORD *)(v3 + 20);
    return 1;
  }
  return (*(uint64_t (**)(void))(v3 + 40))();
}

uint64_t Fax3VSetField(uint64_t a1, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t (*v4)(uint64_t);
  uint64_t result;
  unint64_t v7;

  v3 = *(_QWORD *)(a1 + 1096);
  if (!v3)
    Fax3VSetField_cold_1();
  v4 = *(uint64_t (**)(uint64_t))(v3 + 48);
  if (!v4)
    Fax3VSetField_cold_2();
  if (a2 <= 326)
  {
    switch(a2)
    {
      case 292:
        if (*(_WORD *)(a1 + 120) != 3)
          goto LABEL_18;
        break;
      case 293:
        if (*(_WORD *)(a1 + 120) != 4)
          goto LABEL_18;
        break;
      case 326:
        *(_DWORD *)(v3 + 28) = *a3;
        goto LABEL_18;
      default:
        return v4(a1);
    }
    *(_DWORD *)(v3 + 32) = *a3;
    goto LABEL_18;
  }
  if (a2 >= 0x10000)
  {
    if (a2 == 65540)
    {
      *(_QWORD *)(v3 + 88) = *(_QWORD *)a3;
    }
    else
    {
      if (a2 != 0x10000)
        return v4(a1);
      *(_DWORD *)(v3 + 4) = *a3;
    }
    return 1;
  }
  if (a2 != 327)
  {
    if (a2 == 328)
    {
      *(_DWORD *)(v3 + 24) = *a3;
      goto LABEL_18;
    }
    return v4(a1);
  }
  *(_WORD *)(v3 + 20) = *a3;
LABEL_18:
  result = (uint64_t)TIFFFieldWithTag((_QWORD *)a1, a2);
  if (result)
  {
    v7 = *(unsigned __int16 *)(result + 24);
    result = 1;
    *(_DWORD *)(a1 + ((v7 >> 3) & 0x1FFC) + 72) |= 1 << v7;
    *(_DWORD *)(a1 + 16) |= 8u;
  }
  return result;
}

uint64_t Fax3PrintDir(uint64_t result, FILE *__stream, uint64_t a3)
{
  uint64_t v3;
  uint64_t v6;
  int v7;
  uint64_t (*v8)(uint64_t, FILE *, uint64_t);
  const char *v9;
  int v10;
  int v11;
  const char *v12;
  size_t v13;

  v3 = *(_QWORD *)(result + 1096);
  if (!v3)
    Fax3PrintDir_cold_1();
  v6 = result;
  v7 = *(_DWORD *)(result + 80);
  if ((v7 & 0x200) == 0)
  {
    if ((v7 & 8) == 0)
      goto LABEL_4;
    goto LABEL_18;
  }
  if (*(_WORD *)(result + 120) == 4)
  {
    fwrite("  Group 4 Options:", 0x12uLL, 1uLL, __stream);
    if ((*(_BYTE *)(v3 + 32) & 2) == 0)
      goto LABEL_17;
    v9 = " ";
    goto LABEL_16;
  }
  fwrite("  Group 3 Options:", 0x12uLL, 1uLL, __stream);
  v10 = *(_DWORD *)(v3 + 32);
  v9 = " ";
  if ((v10 & 1) != 0)
  {
    fprintf(__stream, "%s2-d encoding", " ");
    v10 = *(_DWORD *)(v3 + 32);
    v9 = "+";
    if ((v10 & 4) == 0)
    {
LABEL_15:
      if ((v10 & 2) == 0)
        goto LABEL_17;
      goto LABEL_16;
    }
  }
  else if ((v10 & 4) == 0)
  {
    goto LABEL_15;
  }
  fprintf(__stream, "%sEOL padding", v9);
  v9 = "+";
  if ((*(_DWORD *)(v3 + 32) & 2) != 0)
LABEL_16:
    fprintf(__stream, "%suncompressed data", v9);
LABEL_17:
  result = fprintf(__stream, " (%u = 0x%x)\n", *(_DWORD *)(v3 + 32), *(_DWORD *)(v3 + 32));
  v7 = *(_DWORD *)(v6 + 80);
  if ((v7 & 8) == 0)
  {
LABEL_4:
    if ((v7 & 4) == 0)
      goto LABEL_5;
    goto LABEL_29;
  }
LABEL_18:
  fwrite("  Fax Data:", 0xBuLL, 1uLL, __stream);
  v11 = *(unsigned __int16 *)(v3 + 20);
  if (v11 == 2)
  {
    v12 = " uncorrected errors";
    v13 = 19;
  }
  else if (v11 == 1)
  {
    v12 = " receiver regenerated";
    v13 = 21;
  }
  else
  {
    if (*(_WORD *)(v3 + 20))
      goto LABEL_28;
    v12 = " clean";
    v13 = 6;
  }
  fwrite(v12, v13, 1uLL, __stream);
LABEL_28:
  result = fprintf(__stream, " (%hu = 0x%hx)\n", *(unsigned __int16 *)(v3 + 20), *(unsigned __int16 *)(v3 + 20));
  v7 = *(_DWORD *)(v6 + 80);
  if ((v7 & 4) == 0)
  {
LABEL_5:
    if ((v7 & 0x10) == 0)
      goto LABEL_7;
    goto LABEL_6;
  }
LABEL_29:
  result = fprintf(__stream, "  Bad Fax Lines: %u\n", *(_DWORD *)(v3 + 28));
  if ((*(_DWORD *)(v6 + 80) & 0x10) != 0)
LABEL_6:
    result = fprintf(__stream, "  Consecutive Bad Fax Lines: %u\n", *(_DWORD *)(v3 + 24));
LABEL_7:
  v8 = *(uint64_t (**)(uint64_t, FILE *, uint64_t))(v3 + 56);
  if (v8)
    return v8(v6, __stream, a3);
  return result;
}

uint64_t Fax3FixupTags()
{
  return 1;
}

uint64_t Fax3SetupState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  int64_t v10;
  unsigned int *v11;
  const char *v12;
  char *v13;
  uint64_t v14;
  _BOOL4 v15;
  int v16;
  int v17;
  uint64_t result;
  int v19;
  size_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  char v31;

  if (*(_WORD *)(a1 + 116) != 1)
  {
    v12 = "Fax3SetupState";
    v13 = "Bits/sample must be 1 for Group 3/4 encoding/decoding";
LABEL_34:
    TIFFErrorExtR(a1, v12, v13, a4, a5, a6, a7, a8, v31);
    return 0;
  }
  v9 = *(_QWORD *)(a1 + 1096);
  if ((*(_BYTE *)(a1 + 17) & 4) != 0)
  {
    v10 = _cg_TIFFTileRowSize(a1, a2, a3, a4, a5, a6, a7, a8);
    v11 = (unsigned int *)(a1 + 100);
  }
  else
  {
    v10 = _cg_TIFFScanlineSize(a1, a2, a3, a4, a5, a6, a7, a8);
    v11 = (unsigned int *)(a1 + 88);
  }
  v14 = *v11;
  if (v10 >= (uint64_t)((unint64_t)(v14 + 7) >> 3))
  {
    *(_QWORD *)(v9 + 8) = v10;
    *(_DWORD *)(v9 + 16) = v14;
    v15 = (*(_BYTE *)(v9 + 32) & 1) != 0 || *(unsigned __int16 *)(a1 + 120) == 4;
    *(_QWORD *)(v9 + 96) = 0;
    if ((v14 + 1) >= 0xFFFFFFE0)
      v16 = 0;
    else
      v16 = (v14 & 0xFFFFFFE0) + 32;
    v17 = 2 * v16;
    if (v16 < 0)
      v17 = 0;
    if (v15)
      v16 = v17;
    *(_DWORD *)(v9 + 104) = v16;
    if (!v16 || v16 < 0 || (v16 & 0x7FFFFFFE) == 0)
    {
      v12 = *(const char **)a1;
      v31 = v14;
      v13 = "Row pixels integer overflow (rowpixels %u)";
      goto LABEL_34;
    }
    result = (uint64_t)_TIFFCheckMalloc((const char **)a1, (2 * v16), 4, (uint64_t)"for Group 3/4 run arrays", a5, a6, a7, a8);
    *(_QWORD *)(v9 + 96) = result;
    if (!result)
      return result;
    v19 = *(_DWORD *)(v9 + 104);
    if (v19 < 0)
      v20 = 0;
    else
      v20 = 4 * (2 * v19);
    bzero((void *)result, v20);
    v27 = 0;
    v28 = *(_QWORD *)(v9 + 96);
    *(_QWORD *)(v9 + 120) = v28;
    if (v15)
      v27 = v28 + 4 * *(unsigned int *)(v9 + 104);
    *(_QWORD *)(v9 + 112) = v27;
    if (*(_WORD *)(a1 + 120) == 3 && (*(_BYTE *)(v9 + 32) & 1) != 0)
    {
      *(_QWORD *)(a1 + 1008) = Fax3Decode2D;
      *(_QWORD *)(a1 + 1024) = Fax3Decode2D;
      *(_QWORD *)(a1 + 1040) = Fax3Decode2D;
    }
    v29 = *(_QWORD *)(a1 + 1096);
    if (v15)
    {
      v30 = _TIFFmallocExt((_QWORD *)a1, v10, v21, v22, v23, v24, v25, v26);
      *(_QWORD *)(v29 + 136) = v30;
      if (!v30)
      {
        v12 = "Fax3SetupState";
        v13 = "No space for Group 3/4 reference line";
        goto LABEL_34;
      }
    }
    else
    {
      *(_QWORD *)(v29 + 136) = 0;
    }
    return 1;
  }
  TIFFErrorExtR(a1, "Fax3SetupState", "Inconsistent number of bytes per row : rowbytes=%lld rowpixels=%u", a4, a5, a6, a7, a8, v10);
  return 0;
}

uint64_t Fax3PreDecode(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v3;

  v1 = *(_QWORD *)(a1 + 1096);
  if (!v1)
    Fax3PreDecode_cold_1();
  *(_QWORD *)(v1 + 72) = 0;
  *(_DWORD *)(v1 + 80) = 0;
  *(_QWORD *)(v1 + 64) = TIFFGetBitRevTable(*(unsigned __int16 *)(a1 + 126) != 2);
  v2 = *(_QWORD *)(v1 + 96);
  *(_QWORD *)(v1 + 120) = v2;
  if (*(_QWORD *)(v1 + 112))
  {
    v3 = (_QWORD *)(v2 + 4 * *(unsigned int *)(v1 + 104));
    *(_QWORD *)(v1 + 112) = v3;
    *v3 = *(unsigned int *)(v1 + 16);
  }
  *(_DWORD *)(v1 + 152) = 0;
  return 1;
}

uint64_t Fax3Decode1D(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v10;
  int v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int *v20;
  unsigned __int8 *v21;
  uint64_t v22;
  unsigned int v23;
  char v24;
  int v25;
  int *v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int *v34;
  uint64_t v35;
  uint64_t v36;
  unsigned __int8 *v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int *v42;
  int v43;
  const char *v44;
  _BOOL4 v45;
  int *v46;
  int *v47;
  int *v48;
  int v49;
  BOOL v50;
  uint64_t v51;
  _QWORD *v52;
  int *v53;
  int v54;
  int *v55;
  const char *v56;
  _BOOL4 v57;
  int *v58;
  int *v59;
  int v60;
  BOOL v61;
  uint64_t v62;
  char v63;
  int v64;
  uint64_t v65;
  uint64_t v66;
  _QWORD *v67;
  uint64_t v68;
  int *v69;

  v8 = a1[137];
  if (a3 % *(_QWORD *)(v8 + 8))
  {
    TIFFErrorExtR((uint64_t)a1, "Fax3Decode1D", "Fractional scanlines cannot be read", a4, a5, a6, a7, a8, v63);
    return 0xFFFFFFFFLL;
  }
  v10 = a3;
  v12 = *(_DWORD *)(v8 + 72);
  v11 = *(_DWORD *)(v8 + 76);
  v13 = *(_DWORD *)(v8 + 80);
  v14 = a1[144];
  v15 = a1[145];
  if (a3 < 1)
  {
    v21 = (unsigned __int8 *)a1[144];
    goto LABEL_100;
  }
  v67 = a1;
  v17 = v14 + v15;
  v18 = *(unsigned int *)(v8 + 16);
  v19 = *(_QWORD *)(v8 + 64);
  v20 = *(int **)(v8 + 120);
  v21 = (unsigned __int8 *)a1[144];
  v68 = v18;
  v69 = v20;
  while (2)
  {
    if (v13)
      goto LABEL_22;
    while (1)
    {
      if (v11 > 10)
        goto LABEL_19;
      if ((unint64_t)v21 >= v17)
      {
        if (!v11)
        {
          v13 = 0;
LABEL_106:
          v52 = v67;
          if ((_DWORD)v18)
          {
            TIFFWarningExtR((uint64_t)v67, "Fax3Decode1D", "%s at line %u of %s %u (got %u, expected %u)", v18, a5, a6, a7, a8, (char)"Premature EOL");
            v18 = v68;
            v54 = *(_DWORD *)(v8 + 104);
            if ((int)v68 < 1)
            {
              v20 = v69;
              if (!v54)
                goto LABEL_139;
              *v69 = v68;
              if (*(_DWORD *)(v8 + 104) <= 1u)
                goto LABEL_139;
              v53 = v69 + 2;
              v69[1] = 0;
            }
            else
            {
              v20 = v69;
              if (!v54)
                goto LABEL_139;
              *v69 = v68;
              v53 = v69 + 1;
            }
          }
          else
          {
            v53 = v20;
          }
          goto LABEL_143;
        }
        v11 = 11;
      }
      else
      {
        v12 |= *(unsigned __int8 *)(v19 + *v21) << v11;
        if (v11 > 2)
        {
          v11 += 8;
        }
        else
        {
          if ((unint64_t)(v21 + 1) < v17)
          {
            v22 = v21[1];
            v21 += 2;
            v12 |= *(unsigned __int8 *)(v19 + v22) << (v11 + 8);
            v11 += 16;
            goto LABEL_19;
          }
          v11 = 11;
        }
        ++v21;
      }
LABEL_19:
      if ((v12 & 0x7FF) == 0)
        break;
      --v11;
      v12 >>= 1;
    }
    while (1)
    {
LABEL_22:
      if (v11 <= 7)
      {
        if ((unint64_t)v21 >= v17)
        {
          if (!v11)
            goto LABEL_106;
          v11 = 8;
        }
        else
        {
          v23 = *v21++;
          v12 |= *(unsigned __int8 *)(v19 + v23) << v11;
          v11 += 8;
        }
      }
      if ((_BYTE)v12)
        break;
      v11 -= 8;
      v12 >>= 8;
    }
    v65 = v10;
    if ((v12 & 1) == 0)
    {
      do
      {
        v24 = v12;
        --v11;
        v12 >>= 1;
      }
      while ((v24 & 2) == 0);
    }
    v66 = a2;
    v25 = 0;
    --v11;
    v12 >>= 1;
    v26 = v20;
    while (2)
    {
      v27 = 0;
      while (2)
      {
        if (v11 <= 11)
        {
          if ((unint64_t)v21 < v17)
          {
            v12 |= *(unsigned __int8 *)(v19 + *v21) << v11;
            if (v11 > 3)
            {
              v11 += 8;
            }
            else
            {
              if ((unint64_t)(v21 + 1) < v17)
              {
                v28 = v21[1];
                v21 += 2;
                v12 |= *(unsigned __int8 *)(v19 + v28) << (v11 + 8);
                v11 += 16;
                goto LABEL_42;
              }
              v11 = 12;
            }
            ++v21;
            goto LABEL_42;
          }
          if (v11)
          {
            v11 = 12;
            goto LABEL_42;
          }
          v34 = v26;
LABEL_102:
          v52 = v67;
          TIFFWarningExtR((uint64_t)v67, "Fax3Decode1D", "Premature EOF at line %u of %s %u (x %u)", v18, a5, a6, a7, a8, *(_DWORD *)(v8 + 152));
          if (v27)
          {
            if (v34 < &v69[*(unsigned int *)(v8 + 104)])
            {
              *v34 = v27;
              v53 = v34 + 1;
              goto LABEL_115;
            }
LABEL_139:
            v62 = v52[150];
            goto LABEL_140;
          }
          v53 = v34;
LABEL_115:
          a2 = v66;
          if (v25 == (_DWORD)v68)
          {
            v13 = 0;
            v10 = v65;
            v20 = v69;
            goto LABEL_143;
          }
          v55 = v53;
          v56 = "Premature EOL";
          if (v25 >= v68)
            v56 = "Line length mismatch";
          TIFFWarningExtR((uint64_t)v67, "Fax3Decode1D", "%s at line %u of %s %u (got %u, expected %u)", v68, a5, a6, a7, a8, (char)v56);
          v18 = v68;
          v57 = v25 > (int)v68;
          if (v25 <= (int)v68)
          {
            v20 = v69;
            v53 = v55;
          }
          else
          {
            v20 = v69;
            v53 = v55;
            if (v55 > v69)
            {
              v58 = v55 - 1;
              v59 = v55 - 1;
              do
              {
                v60 = *v59--;
                v25 -= v60;
                v57 = v25 > (int)v68;
                v61 = v25 > (int)v68 && v58 > v69;
                v58 = v59;
              }
              while (v61);
              v53 = v59 + 1;
            }
          }
          if (v25 >= (int)v68)
          {
            if (!v57)
            {
              v13 = 0;
              goto LABEL_142;
            }
            v10 = v65;
            if (v53 >= &v20[*(unsigned int *)(v8 + 104)])
              goto LABEL_139;
            *v53 = v68;
            if (v53 + 1 >= &v20[*(unsigned int *)(v8 + 104)])
              goto LABEL_139;
            v13 = 0;
            v53[1] = 0;
            v53 += 2;
          }
          else
          {
            if ((((_DWORD)v53 - (_DWORD)v20) & 4) != 0)
            {
              if (v53 >= &v20[*(unsigned int *)(v8 + 104)])
                goto LABEL_139;
              *v53++ = 0;
            }
            if (v53 >= &v20[*(unsigned int *)(v8 + 104)])
              goto LABEL_139;
            v13 = 0;
            *v53++ = v68 - (v25 & ~(v25 >> 31));
LABEL_142:
            v10 = v65;
          }
LABEL_143:
          (*(void (**)(uint64_t, int *, int *))(v8 + 88))(a2, v20, v53);
          *(_DWORD *)(v8 + 72) = v12;
          *(_DWORD *)(v8 + 76) = 0;
          *(_DWORD *)(v8 + 80) = v13;
          v52[145] += v52[144] - (_QWORD)v21;
          v52[144] = v21;
          if (v10 < *((unsigned int *)v52 + 22))
            return 1;
          else
            return 0xFFFFFFFFLL;
        }
LABEL_42:
        v29 = v12 & 0xFFF;
        v30 = *((unsigned __int8 *)&TIFFFaxWhiteTable + 8 * v29 + 1);
        v11 -= v30;
        v12 >>= v30;
        switch(8 * v29)
        {
          case 0:
          case 0x24:
            goto LABEL_68;
          case 1:
          case 0x14:
          case 0x2CLL:
          case 0x30:
            v31 = *((_DWORD *)&TIFFFaxWhiteTable + 2 * v29 + 1);
            v25 += v31;
            v27 += v31;
            continue;
          case 8:
          case 0x10:
          case 0x18:
          case 0x20:
          case 0x28:
            if (v26 >= &v20[*(unsigned int *)(v8 + 104)])
              goto LABEL_127;
            v32 = *((_DWORD *)&TIFFFaxWhiteTable + 2 * v29 + 1);
            v33 = v32 + v27;
            *v26 = v32 + v27;
            v34 = v26 + 1;
            v25 += v32;
            if (v25 >= (int)v18)
              goto LABEL_98;
            v27 = 0;
            break;
          default:
            v42 = v26;
            TIFFErrorExtR((uint64_t)v67, "Fax3Decode1D", "Bad code word at line %u of %s %u (x %u)", v18, a5, a6, a7, a8, *(_DWORD *)(v8 + 152));
            v26 = v42;
            v18 = v68;
            v20 = v69;
            v43 = 0;
            goto LABEL_69;
        }
        break;
      }
      while (2)
      {
        if (v11 > 12)
          goto LABEL_57;
        if ((unint64_t)v21 >= v17)
        {
          if (!v11)
            goto LABEL_102;
          v11 = 13;
        }
        else
        {
          v12 |= *(unsigned __int8 *)(v19 + *v21) << v11;
          if (v11 > 4)
          {
            v11 += 8;
          }
          else
          {
            if ((unint64_t)(v21 + 1) < v17)
            {
              v35 = v21[1];
              v21 += 2;
              v12 |= *(unsigned __int8 *)(v19 + v35) << (v11 + 8);
              v11 += 16;
              goto LABEL_57;
            }
            v11 = 13;
          }
          ++v21;
        }
LABEL_57:
        v36 = v12 & 0x1FFF;
        v37 = (unsigned __int8 *)&TIFFFaxBlackTable + 8 * v36;
        v38 = v37[1];
        v11 -= v38;
        v12 >>= v38;
        v39 = *v37;
        if ((v39 - 10) < 2)
        {
          v40 = *((_DWORD *)&TIFFFaxBlackTable + 2 * v36 + 1);
          v25 += v40;
          v27 += v40;
          continue;
        }
        break;
      }
      if (v39 == 12)
      {
        ++v26;
LABEL_68:
        v43 = 1;
LABEL_69:
        v64 = v43;
        if (v27)
        {
          if (v26 >= &v20[*(unsigned int *)(v8 + 104)])
            goto LABEL_127;
          *v26++ = v27;
        }
        v34 = v26;
        goto LABEL_73;
      }
      if (v39 != 8)
      {
        TIFFErrorExtR((uint64_t)v67, "Fax3Decode1D", "Bad code word at line %u of %s %u (x %u)", v18, a5, a6, a7, a8, *(_DWORD *)(v8 + 152));
        v18 = v68;
        v20 = v69;
        v43 = 0;
        v26 = v34;
        goto LABEL_69;
      }
      if (v34 >= &v20[*(unsigned int *)(v8 + 104)])
        goto LABEL_127;
      v41 = *((_DWORD *)&TIFFFaxBlackTable + 2 * v36 + 1);
      v34 = v26 + 2;
      v26[1] = v41 + v27;
      v25 += v41;
      if (v25 < (int)v18)
      {
        if ((v41 + v27) | v33)
          v26 += 2;
        continue;
      }
      break;
    }
LABEL_98:
    v64 = 0;
LABEL_73:
    if (v25 == (_DWORD)v18)
      goto LABEL_95;
    v44 = "Premature EOL";
    if (v25 >= v18)
      v44 = "Line length mismatch";
    TIFFWarningExtR((uint64_t)v67, "Fax3Decode1D", "%s at line %u of %s %u (got %u, expected %u)", v18, a5, a6, a7, a8, (char)v44);
    v45 = v25 > (int)v68;
    if (v25 <= (int)v68)
    {
      v46 = v69;
    }
    else
    {
      v46 = v69;
      if (v34 > v69)
      {
        v47 = v34 - 1;
        v48 = v34 - 1;
        do
        {
          v49 = *v48--;
          v25 -= v49;
          v45 = v25 > (int)v68;
          v50 = v25 > (int)v68 && v47 > v69;
          v47 = v48;
        }
        while (v50);
        v34 = v48 + 1;
      }
    }
    if (v25 >= (int)v68)
    {
      if (v45)
      {
        if (v34 >= &v46[*(unsigned int *)(v8 + 104)])
          goto LABEL_127;
        *v34 = v68;
        if (v34 + 1 >= &v46[*(unsigned int *)(v8 + 104)])
          goto LABEL_127;
        v34[1] = 0;
        v34 += 2;
      }
LABEL_95:
      (*(void (**)(uint64_t, int *, int *, uint64_t))(v8 + 88))(v66, v69, v34, v68);
      v18 = v68;
      v20 = v69;
      v51 = *(_QWORD *)(v8 + 8);
      a2 = v66 + v51;
      ++*(_DWORD *)(v8 + 152);
      v10 = v65 - v51;
      v13 = v64;
      if (v65 <= v51)
      {
        a1 = v67;
        v14 = v67[144];
        v15 = v67[145];
LABEL_100:
        *(_DWORD *)(v8 + 72) = v12;
        *(_DWORD *)(v8 + 76) = v11;
        *(_DWORD *)(v8 + 80) = v13;
        a1[145] = v14 - (_QWORD)v21 + v15;
        a1[144] = v21;
        return 1;
      }
      continue;
    }
    break;
  }
  if ((((_DWORD)v34 - (_DWORD)v46) & 4) == 0)
    goto LABEL_89;
  if (v34 < &v46[*(unsigned int *)(v8 + 104)])
  {
    *v34++ = 0;
LABEL_89:
    if (v34 < &v46[*(unsigned int *)(v8 + 104)])
    {
      *v34++ = v68 - (v25 & ~(v25 >> 31));
      goto LABEL_95;
    }
  }
LABEL_127:
  v62 = v67[150];
LABEL_140:
  TIFFErrorExt(v62, "Fax3Decode1D", "Buffer overflow at line %u of %s %u", v18, a5, a6, a7, a8, *(_DWORD *)(v8 + 152));
  return 0xFFFFFFFFLL;
}

uint64_t Fax3PreEncode(uint64_t a1)
{
  uint64_t v1;
  void *v3;
  int v4;
  int v5;
  float v6;

  v1 = *(_QWORD *)(a1 + 1096);
  if (!v1)
    Fax3PreEncode_cold_1();
  *(_QWORD *)(v1 + 72) = 0x800000000;
  *(_DWORD *)(v1 + 128) = 0;
  v3 = *(void **)(v1 + 136);
  if (v3)
    _TIFFmemset(v3, 0, *(_QWORD *)(v1 + 8));
  if ((*(_BYTE *)(v1 + 32) & 1) != 0)
  {
    v6 = *(float *)(a1 + 164);
    if (*(_WORD *)(a1 + 168) == 3)
      v6 = v6 * 2.54;
    if (v6 <= 150.0)
      v4 = 2;
    else
      v4 = 4;
    v5 = v4 - 1;
  }
  else
  {
    v4 = 0;
    v5 = 0;
  }
  *(_DWORD *)(v1 + 144) = v5;
  *(_DWORD *)(v1 + 148) = v4;
  *(_DWORD *)(v1 + 152) = 0;
  return 1;
}

uint64_t Fax3PostEncode(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t result;
  char v11;
  _BYTE *v12;

  v8 = a1[137];
  if (*(_DWORD *)(v8 + 76) == 8)
    return 1;
  if (a1[145] < a1[141] || (result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8), (_DWORD)result))
  {
    v11 = *(_DWORD *)(v8 + 72);
    v12 = (_BYTE *)a1[144];
    a1[144] = v12 + 1;
    *v12 = v11;
    ++a1[145];
    *(_QWORD *)(v8 + 72) = 0x800000000;
    return 1;
  }
  return result;
}

uint64_t Fax3Encode(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  _BYTE *v19;
  _BYTE *v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  _BYTE *v24;
  int v25;
  int v26;
  _BYTE *v27;
  int v28;
  uint64_t v29;
  BOOL v30;
  char v31;

  v9 = a1[137];
  if (a3 % *(_QWORD *)(v9 + 8))
  {
    TIFFErrorExtR((uint64_t)a1, "Fax3Encode", "Fractional scanlines cannot be written", a4, a5, a6, a7, a8, v31);
    return 0;
  }
  v11 = a3;
  if (a3 < 1)
    return 1;
  v12 = (char *)a2;
  while ((*(_BYTE *)(v9 + 4) & 2) != 0)
  {
LABEL_36:
    if ((*(_BYTE *)(v9 + 32) & 1) == 0)
    {
      result = Fax3Encode1DRow(a1, (uint64_t)v12, *(_DWORD *)(v9 + 16), a4, a5, a6, a7, a8);
      if (!(_DWORD)result)
        return result;
      goto LABEL_46;
    }
    if (*(_DWORD *)(v9 + 128))
    {
      result = Fax3Encode2DRow(a1, v12, *(char **)(v9 + 136), *(unsigned int *)(v9 + 16), a5, a6, a7, a8);
      if (!(_DWORD)result)
        return result;
      v28 = *(_DWORD *)(v9 + 144) - 1;
      *(_DWORD *)(v9 + 144) = v28;
      if (!v28)
        goto LABEL_45;
    }
    else
    {
      result = Fax3Encode1DRow(a1, (uint64_t)v12, *(_DWORD *)(v9 + 16), a4, a5, a6, a7, a8);
      if (!(_DWORD)result)
        return result;
      *(_DWORD *)(v9 + 128) = 1;
      if (!*(_DWORD *)(v9 + 144))
      {
LABEL_45:
        *(_DWORD *)(v9 + 128) = 0;
        *(_DWORD *)(v9 + 144) = *(_DWORD *)(v9 + 148) - 1;
        goto LABEL_46;
      }
    }
    _TIFFmemcpy(*(void **)(v9 + 136), v12, *(_QWORD *)(v9 + 8));
LABEL_46:
    v29 = *(_QWORD *)(v9 + 8);
    v12 += v29;
    result = 1;
    v30 = v11 <= v29;
    v11 -= v29;
    if (v30)
      return result;
  }
  v13 = a1[137];
  v15 = *(_DWORD *)(v13 + 72);
  v14 = *(_DWORD *)(v13 + 76);
  if ((*(_BYTE *)(v13 + 32) & 4) == 0 || v14 == 4)
    goto LABEL_23;
  v16 = v14 < 4 ? 4 : -4;
  v17 = v16 + v14;
  if (v16 + v14 <= v14)
  {
    if (v17 >= 9)
      Fax3Encode_cold_2();
  }
  else
  {
    v18 = a1[145];
    do
    {
      if (v18 >= a1[141])
      {
        result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
        if (!(_DWORD)result)
          return result;
      }
      v17 -= v14;
      v19 = (_BYTE *)a1[144];
      a1[144] = v19 + 1;
      *v19 = v15;
      v18 = a1[145] + 1;
      a1[145] = v18;
      v14 = 8;
      LOBYTE(v15) = 0;
    }
    while (v17 > 8);
    LOBYTE(v15) = 0;
  }
  v14 -= v17;
  if (v14)
  {
LABEL_23:
    if ((*(_BYTE *)(v13 + 32) & 1) != 0)
    {
      v22 = (*(_DWORD *)(v13 + 128) == 0) | 2;
      v21 = 13;
    }
    else
    {
      v21 = 12;
      v22 = 1;
    }
    if (v21 <= v14)
      Fax3Encode_cold_1();
    v23 = a1[145];
    do
    {
      if (v23 >= a1[141])
      {
        result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
        if (!(_DWORD)result)
          return result;
      }
      v21 -= v14;
      v24 = (_BYTE *)a1[144];
      a1[144] = v24 + 1;
      *v24 = (v22 >> v21) | v15;
      v23 = a1[145] + 1;
      a1[145] = v23;
      v14 = 8;
      LOBYTE(v15) = 0;
    }
    while (v21 > 8);
    v25 = 8 - v21;
    v26 = (_msbmask[v21] & v22) << (8 - v21);
    if (v21 == 8)
    {
      if (v23 >= a1[141])
      {
        result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
        if (!(_DWORD)result)
          return result;
      }
      v27 = (_BYTE *)a1[144];
      a1[144] = v27 + 1;
      *v27 = v26;
      ++a1[145];
      v25 = 8;
      v26 = 0;
    }
    *(_DWORD *)(v13 + 72) = v26;
    *(_DWORD *)(v13 + 76) = v25;
    goto LABEL_36;
  }
  if (a1[145] < a1[141] || (result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8), (_DWORD)result))
  {
    v20 = (_BYTE *)a1[144];
    a1[144] = v20 + 1;
    *v20 = v15;
    ++a1[145];
    v14 = 8;
    LOBYTE(v15) = 0;
    goto LABEL_23;
  }
  return result;
}

double Fax3Close(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  double result;
  char v16;
  _BYTE *v17;

  v8 = a1[137];
  if ((*(_BYTE *)(v8 + 4) & 1) == 0 && a1[144])
  {
    if ((*(_BYTE *)(v8 + 32) & 1) != 0)
    {
      v11 = (*(_DWORD *)(v8 + 128) == 0) | 2u;
      v10 = 13;
    }
    else
    {
      v10 = 12;
      v11 = 1;
    }
    v12 = 6;
    do
    {
      Fax3PutBits(a1, v11, v10, a4, a5, a6, a7, a8);
      --v12;
    }
    while (v12);
    if (a1[145] < a1[141] || TIFFFlushData1((uint64_t)a1, v13, v14, a4, a5, a6, a7, a8))
    {
      v16 = *(_DWORD *)(v8 + 72);
      v17 = (_BYTE *)a1[144];
      a1[144] = v17 + 1;
      *v17 = v16;
      ++a1[145];
      *(_QWORD *)&result = 0x800000000;
      *(_QWORD *)(v8 + 72) = 0x800000000;
    }
  }
  return result;
}

uint64_t Fax3Cleanup(uint64_t a1)
{
  _QWORD *v1;
  uint64_t v3;
  char *v4;
  char *v5;

  v1 = *(_QWORD **)(a1 + 1096);
  if (!v1)
    Fax3Cleanup_cold_1();
  v3 = v1[6];
  *(_QWORD *)(a1 + 1288) = v1[5];
  *(_QWORD *)(a1 + 1280) = v3;
  *(_QWORD *)(a1 + 1296) = v1[7];
  v4 = (char *)v1[12];
  if (v4)
    _TIFFfreeExt(a1, v4);
  v5 = (char *)v1[17];
  if (v5)
    _TIFFfreeExt(a1, v5);
  _TIFFfreeExt(a1, *(char **)(a1 + 1096));
  *(_QWORD *)(a1 + 1096) = 0;
  return _TIFFSetDefaultCompressionState(a1);
}

uint64_t Fax3Decode2D(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v11;
  int v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int *v21;
  unsigned __int8 *v22;
  uint64_t v23;
  unsigned int v24;
  char v25;
  unsigned int v26;
  int v27;
  unsigned int v28;
  int v29;
  int i;
  uint64_t v31;
  unsigned int *v32;
  uint64_t v33;
  unsigned int *v34;
  uint64_t v35;
  unsigned int v36;
  uint64_t v37;
  int v38;
  unsigned int *v39;
  unsigned int v40;
  unsigned int v41;
  uint64_t v42;
  uint64_t v43;
  unsigned __int8 *v44;
  int v45;
  int v46;
  int v48;
  uint64_t v49;
  uint64_t v50;
  unsigned __int8 *v51;
  int v52;
  int v53;
  int v54;
  unsigned int *v55;
  unsigned int *v56;
  int v57;
  int v58;
  unsigned int *v59;
  unsigned int *v60;
  int v61;
  int v62;
  unsigned int *v63;
  unsigned int *v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int *v69;
  uint64_t v70;
  uint64_t v71;
  unsigned __int8 *v72;
  int v73;
  int v74;
  int v75;
  int v76;
  uint64_t v77;
  uint64_t v78;
  unsigned __int8 *v79;
  int v80;
  int v81;
  int v83;
  char *v84;
  int v85;
  unsigned int *v87;
  int *v89;
  int v90;
  uint64_t v91;
  uint64_t v92;
  int v93;
  int v94;
  int v95;
  int v96;
  uint64_t v97;
  uint64_t v98;
  unsigned __int8 *v99;
  int v100;
  int v101;
  int v102;
  int v103;
  int v104;
  int *v105;
  uint64_t v106;
  uint64_t v107;
  int *v108;
  int v109;
  int *v110;
  int *v111;
  int *v112;
  int *v113;
  const char *v114;
  _BOOL4 v115;
  int *v116;
  int *v117;
  int v118;
  BOOL v119;
  int *v120;
  unsigned int v121;
  uint64_t v122;
  int v123;
  const char *v124;
  int *v125;
  int v126;
  BOOL v127;
  uint64_t v128;
  int *v129;
  int *v130;
  int8x16_t v131;
  uint64_t v132;
  int *v133;
  unsigned int v134;
  int *v135;
  int *v136;
  int v137;
  int *v138;
  int *v139;
  int *v140;
  int *v141;
  int *v142;
  int *v143;
  int *v144;
  _BOOL4 v145;
  int *v146;
  int *v147;
  int v148;
  BOOL v149;
  uint64_t v150;
  int *v151;
  int v152;
  BOOL v153;
  char v154;
  char v155;
  int v156;
  int *v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v161;

  v8 = a1;
  v9 = a1[137];
  if (a3 % *(_QWORD *)(v9 + 8))
  {
    TIFFErrorExtR((uint64_t)a1, "Fax3Decode2D", "Fractional scanlines cannot be read", a4, (uint64_t)a5, a6, a7, a8, v154);
    return 0xFFFFFFFFLL;
  }
  v11 = a3;
  v13 = *(_DWORD *)(v9 + 72);
  v12 = *(_DWORD *)(v9 + 76);
  v14 = *(_DWORD *)(v9 + 80);
  v15 = a1[144];
  v16 = a1[145];
  if (a3 < 1)
  {
    v22 = (unsigned __int8 *)a1[144];
    goto LABEL_285;
  }
  v18 = v15 + v16;
  v19 = *(unsigned int *)(v9 + 16);
  v20 = *(_QWORD *)(v9 + 64);
  v21 = *(int **)(v9 + 120);
  v22 = (unsigned __int8 *)a1[144];
  v161 = v19;
  while (2)
  {
    if (!v14)
    {
      while (1)
      {
        if (v12 > 10)
          goto LABEL_19;
        if ((unint64_t)v22 >= v18)
        {
          if (!v12)
          {
            v14 = 0;
LABEL_287:
            if ((_DWORD)v19)
            {
LABEL_288:
              v136 = v21;
              TIFFWarningExtR((uint64_t)v8, "Fax3Decode2D", "%s at line %u of %s %u (got %u, expected %u)", v19, (uint64_t)a5, a6, a7, a8, (char)"Premature EOL");
              v19 = v161;
              v137 = *(_DWORD *)(v9 + 104);
              if ((int)v161 < 1)
              {
                if (v137)
                {
                  v21 = v136;
                  *v136 = v161;
                  if (*(_DWORD *)(v9 + 104) > 1u)
                  {
                    v138 = v136 + 2;
                    v136[1] = 0;
                    goto LABEL_342;
                  }
                }
              }
              else if (v137)
              {
                v21 = v136;
                *v136 = v161;
                v138 = v136 + 1;
                goto LABEL_342;
              }
              goto LABEL_336;
            }
LABEL_341:
            v138 = v21;
            goto LABEL_342;
          }
          v12 = 11;
        }
        else
        {
          v13 |= *(unsigned __int8 *)(v20 + *v22) << v12;
          if (v12 > 2)
          {
            v12 += 8;
          }
          else
          {
            if ((unint64_t)(v22 + 1) < v18)
            {
              v23 = v22[1];
              v22 += 2;
              v13 |= *(unsigned __int8 *)(v20 + v23) << (v12 + 8);
              v12 += 16;
              goto LABEL_19;
            }
            v12 = 11;
          }
          ++v22;
        }
LABEL_19:
        if ((v13 & 0x7FF) == 0)
          goto LABEL_22;
        --v12;
        v13 >>= 1;
      }
    }
    while (1)
    {
LABEL_22:
      if (v12 <= 7)
      {
        if ((unint64_t)v22 >= v18)
        {
          if (!v12)
            goto LABEL_287;
          v12 = 8;
        }
        else
        {
          v24 = *v22++;
          v13 |= *(unsigned __int8 *)(v20 + v24) << v12;
          v12 += 8;
        }
      }
      if ((_BYTE)v13)
        break;
      v12 -= 8;
      v13 >>= 8;
    }
    if ((v13 & 1) == 0)
    {
      do
      {
        v25 = v13;
        --v12;
        v13 >>= 1;
      }
      while ((v25 & 2) == 0);
    }
    v26 = v13 >> 1;
    v27 = v12 - 1;
    if (v12 <= 1)
    {
      if ((unint64_t)v22 >= v18)
      {
        if (v12 == 1)
        {
          v14 = 0;
          v13 >>= 1;
          if ((_DWORD)v19)
            goto LABEL_288;
          goto LABEL_341;
        }
        v27 = 1;
      }
      else
      {
        v28 = *v22++;
        v26 |= *(unsigned __int8 *)(v20 + v28) << v27;
        v27 = v12 + 7;
      }
    }
    v12 = v27 - 1;
    v13 = v26 >> 1;
    v159 = a2;
    if ((v26 & 1) != 0)
    {
      v31 = 0;
      v89 = v21;
      v158 = v11;
LABEL_163:
      v90 = 0;
      while (2)
      {
        if (v12 > 11)
          goto LABEL_174;
        if ((unint64_t)v22 >= v18)
        {
          if (!v12)
          {
            v139 = v89;
            v140 = v21;
            goto LABEL_297;
          }
          v12 = 12;
          goto LABEL_174;
        }
        v13 |= *(unsigned __int8 *)(v20 + *v22) << v12;
        if (v12 > 3)
        {
          v12 += 8;
        }
        else
        {
          if ((unint64_t)(v22 + 1) < v18)
          {
            v91 = v22[1];
            v22 += 2;
            v13 |= *(unsigned __int8 *)(v20 + v91) << (v12 + 8);
            v12 += 16;
            goto LABEL_174;
          }
          v12 = 12;
        }
        ++v22;
LABEL_174:
        v92 = v13 & 0xFFF;
        v93 = *((unsigned __int8 *)&TIFFFaxWhiteTable + 8 * v92 + 1);
        v12 -= v93;
        v13 >>= v93;
        switch(8 * v92)
        {
          case 0:
          case 0x24:
            v109 = 1;
            goto LABEL_203;
          case 1:
          case 0x14:
          case 0x2CLL:
          case 0x30:
            v94 = *((_DWORD *)&TIFFFaxWhiteTable + 2 * v92 + 1);
            v31 = (v94 + v31);
            v90 += v94;
            continue;
          case 8:
          case 0x10:
          case 0x18:
          case 0x20:
          case 0x28:
            if (v89 >= &v21[*(unsigned int *)(v9 + 104)])
              goto LABEL_314;
            v95 = *((_DWORD *)&TIFFFaxWhiteTable + 2 * v92 + 1);
            v96 = v95 + v90;
            *v89 = v95 + v90;
            a5 = v89 + 1;
            v31 = (v95 + v31);
            if ((int)v31 >= (int)v19)
              goto LABEL_264;
            v90 = 0;
            break;
          default:
            v155 = *(_DWORD *)(v9 + 152);
            v105 = v21;
            v106 = v20;
            v107 = v9;
            v108 = v89;
            TIFFErrorExtR((uint64_t)a1, "Fax3Decode2D", "Bad code word at line %u of %s %u (x %u)", v19, (uint64_t)a5, a6, a7, a8, v155);
            v89 = v108;
            v9 = v107;
            v20 = v106;
            v21 = v105;
            v19 = v161;
            v109 = 0;
            goto LABEL_203;
        }
        break;
      }
      while (1)
      {
        if (v12 > 12)
          goto LABEL_189;
        if ((unint64_t)v22 >= v18)
        {
          if (!v12)
          {
            v140 = v21;
            v139 = v89 + 1;
LABEL_297:
            TIFFWarningExtR((uint64_t)a1, "Fax3Decode2D", "Premature EOF at line %u of %s %u (x %u)", v19, (uint64_t)a5, a6, a7, a8, *(_DWORD *)(v9 + 152));
            if (v90)
            {
              v19 = v161;
              if (v139 >= &v140[*(unsigned int *)(v9 + 104)])
                goto LABEL_314;
              v21 = v140;
              *v139 = v90;
              v138 = v139 + 1;
            }
            else
            {
              LODWORD(v19) = v161;
              v21 = v140;
              v138 = v139;
            }
            v8 = a1;
            if ((_DWORD)v31 == (_DWORD)v19)
              goto LABEL_338;
            v143 = v138;
            v144 = v21;
            Fax3BadLength("Fax3Decode2D", (uint64_t)a1, *(unsigned int *)(v9 + 152), v31, v161, a6, a7, a8);
            v19 = v161;
            v145 = (int)v31 > (int)v161;
            if ((int)v31 <= (int)v161)
              goto LABEL_325;
            v21 = v144;
            v138 = v143;
            if (v143 > v144)
            {
              v146 = v143 - 1;
              v147 = v143 - 1;
              do
              {
                v148 = *v147--;
                LODWORD(v31) = v31 - v148;
                v145 = (int)v31 > (int)v161;
                v149 = (int)v31 > (int)v161 && v146 > v144;
                v146 = v147;
              }
              while (v149);
LABEL_324:
              v138 = v147 + 1;
            }
LABEL_326:
            if ((int)v31 >= (int)v19)
            {
              if (!v145)
                goto LABEL_338;
              a2 = v159;
              if (v138 < &v21[*(unsigned int *)(v9 + 104)])
              {
                *v138 = v19;
                if (v138 + 1 < &v21[*(unsigned int *)(v9 + 104)])
                {
                  v14 = 0;
                  v138[1] = 0;
                  v138 += 2;
                  goto LABEL_342;
                }
              }
            }
            else
            {
              if ((((_DWORD)v138 - (_DWORD)v21) & 4) != 0)
              {
                if (v138 >= &v21[*(unsigned int *)(v9 + 104)])
                  goto LABEL_336;
                *v138++ = 0;
              }
              if (v138 < &v21[*(unsigned int *)(v9 + 104)])
              {
                v14 = 0;
                *v138++ = v19 - (v31 & ~((int)v31 >> 31));
                goto LABEL_339;
              }
            }
LABEL_336:
            v150 = v8[150];
            goto LABEL_337;
          }
          v12 = 13;
        }
        else
        {
          v13 |= *(unsigned __int8 *)(v20 + *v22) << v12;
          if (v12 > 4)
          {
            v12 += 8;
          }
          else
          {
            if ((unint64_t)(v22 + 1) < v18)
            {
              v97 = v22[1];
              v22 += 2;
              v13 |= *(unsigned __int8 *)(v20 + v97) << (v12 + 8);
              v12 += 16;
              goto LABEL_189;
            }
            v12 = 13;
          }
          ++v22;
        }
LABEL_189:
        v98 = v13 & 0x1FFF;
        v99 = (unsigned __int8 *)&TIFFFaxBlackTable + 8 * v98;
        v100 = v99[1];
        v12 -= v100;
        v13 >>= v100;
        v101 = *v99;
        if ((v101 - 10) >= 2)
        {
          if (v101 == 12)
          {
            v109 = 1;
            ++v89;
          }
          else
          {
            if (v101 == 8)
            {
              if (a5 >= &v21[*(unsigned int *)(v9 + 104)])
                goto LABEL_314;
              v103 = *((_DWORD *)&TIFFFaxBlackTable + 2 * v98 + 1);
              a5 = v89 + 2;
              v89[1] = v103 + v90;
              v31 = (v103 + v31);
              if ((int)v31 < (int)v19)
              {
                if ((v103 + v90) | v96)
                  v89 += 2;
                goto LABEL_163;
              }
LABEL_264:
              v109 = 0;
LABEL_207:
              v156 = v109;
              v8 = a1;
              if ((_DWORD)v31 == (_DWORD)v19)
                goto LABEL_259;
              v112 = a5;
              v113 = v21;
              v114 = "Premature EOL";
              if (v31 >= v19)
                v114 = "Line length mismatch";
              TIFFWarningExtR((uint64_t)a1, "Fax3Decode2D", "%s at line %u of %s %u (got %u, expected %u)", v19, (uint64_t)a5, a6, a7, a8, (char)v114);
              v19 = v161;
              v115 = (int)v31 > (int)v161;
              if ((int)v31 <= (int)v161)
                goto LABEL_248;
              v21 = v113;
              a5 = v112;
              if (v112 > v113)
              {
                v116 = v112 - 1;
                v117 = v112 - 1;
                do
                {
                  v118 = *v117--;
                  LODWORD(v31) = v31 - v118;
                  v115 = (int)v31 > (int)v161;
                  v119 = (int)v31 > (int)v161 && v116 > v113;
                  v116 = v117;
                }
                while (v119);
LABEL_247:
                a5 = v117 + 1;
              }
LABEL_249:
              if ((int)v31 >= (int)v19)
              {
                if (!v115)
                  goto LABEL_259;
                v128 = v159;
                if (a5 < &v21[*(unsigned int *)(v9 + 104)])
                {
                  *a5 = v19;
                  if (a5 + 1 < &v21[*(unsigned int *)(v9 + 104)])
                  {
                    a5[1] = 0;
                    a5 += 2;
                    goto LABEL_260;
                  }
                }
              }
              else if ((((_DWORD)a5 - (_DWORD)v21) & 4) != 0)
              {
                if (a5 < &v21[*(unsigned int *)(v9 + 104)])
                {
                  *a5++ = 0;
                  goto LABEL_253;
                }
              }
              else
              {
LABEL_253:
                if (a5 < &v21[*(unsigned int *)(v9 + 104)])
                {
                  *a5++ = v19 - (v31 & ~((int)v31 >> 31));
                  goto LABEL_259;
                }
              }
              goto LABEL_336;
            }
            v110 = v21;
            v111 = v89 + 1;
            Fax3Unexpected("Fax3Decode2D", (uint64_t)a1, *(_DWORD *)(v9 + 152), v31, (uint64_t)a5, a6, a7, a8);
            v21 = v110;
            v19 = v161;
            v109 = 0;
            v89 = v111;
          }
LABEL_203:
          if (v90)
          {
            if (v89 >= &v21[*(unsigned int *)(v9 + 104)])
              goto LABEL_314;
            *v89++ = v90;
          }
          a5 = v89;
          goto LABEL_207;
        }
        v102 = *((_DWORD *)&TIFFFaxBlackTable + 2 * v98 + 1);
        v31 = (v102 + v31);
        v90 += v102;
      }
    }
    if ((int)v19 < 1)
    {
      v104 = 0;
      LODWORD(v31) = 0;
      a5 = v21;
      goto LABEL_237;
    }
    v29 = 0;
    i = 0;
    v31 = 0;
    v32 = *(unsigned int **)(v9 + 112);
    v34 = v32 + 1;
    v33 = *v32;
    a5 = v21;
LABEL_38:
    v35 = *(unsigned int *)(v9 + 104);
    if (a5 >= &v21[v35])
      goto LABEL_314;
    if (v12 <= 6)
    {
      if ((unint64_t)v22 >= v18)
      {
        if (!v12)
          goto LABEL_295;
        v12 = 7;
      }
      else
      {
        v36 = *v22++;
        v13 |= *(unsigned __int8 *)(v20 + v36) << v12;
        v12 += 8;
      }
    }
    v37 = v13 & 0x7F;
    v38 = *((unsigned __int8 *)&TIFFFaxMainTable + 8 * v37 + 1);
    v12 -= v38;
    v13 >>= v38;
    switch(8 * v37)
    {
      case 0:
      case 0x400:
      case 0x424:
        *a5++ = v19 - v31;
        v157 = a5;
        if (v12 <= 3)
        {
          if ((unint64_t)v22 >= v18)
          {
            if (!v12)
              goto LABEL_295;
            v12 = 4;
          }
          else
          {
            v134 = *v22++;
            v13 |= *(unsigned __int8 *)(v20 + v134) << v12;
            v12 += 8;
          }
        }
        if ((v13 & 0xF) != 0)
        {
          v135 = v21;
          Fax3Unexpected("Fax3Decode2D", (uint64_t)a1, *(_DWORD *)(v9 + 152), v31, (uint64_t)a5, a6, a7, a8);
          v21 = v135;
        }
        v12 -= 4;
        v13 >>= 4;
        v123 = 1;
        goto LABEL_231;
      case 8:
      case 0x11:
      case 0x18:
      case 0x21:
      case 0x28:
      case 0x31:
      case 0x38:
      case 0x48:
      case 0x51:
      case 0x58:
      case 0x61:
      case 0x68:
      case 0x71:
      case 0x78:
      case 0x88:
      case 0x91:
      case 0x98:
      case 0xA1:
      case 0xA8:
      case 0xB1:
      case 0xB8:
      case 0xC8:
      case 0xD1:
      case 0xD8:
      case 0xE1:
      case 0xE8:
      case 0xF1:
      case 0xF8:
      case 0x104:
      case 0x108:
      case 0x111:
      case 0x118:
      case 0x121:
      case 0x128:
      case 0x131:
      case 0x138:
      case 0x148:
      case 0x151:
      case 0x158:
      case 0x161:
      case 0x168:
      case 0x171:
      case 0x178:
      case 0x188:
      case 0x191:
      case 0x198:
      case 0x1A1:
      case 0x1A8:
      case 0x1B1:
      case 0x1B8:
      case 0x1C8:
      case 0x1D1:
      case 0x1D8:
      case 0x1E1:
      case 0x1E8:
      case 0x1F1:
      case 0x1F8:
      case 0x208:
      case 0x211:
      case 0x218:
      case 0x221:
      case 0x228:
      case 0x231:
      case 0x238:
      case 0x248:
      case 0x251:
      case 0x258:
      case 0x261:
      case 0x268:
      case 0x271:
      case 0x278:
      case 0x288:
      case 0x291:
      case 0x298:
      case 0x2A1:
      case 0x2A8:
      case 0x2B1:
      case 0x2B8:
      case 0x2C8:
      case 0x2D1:
      case 0x2D8:
      case 0x2E1:
      case 0x2E8:
      case 0x2F1:
      case 0x2F8:
      case 0x304:
      case 0x308:
      case 0x311:
      case 0x318:
      case 0x321:
      case 0x328:
      case 0x331:
      case 0x338:
      case 0x348:
      case 0x351:
      case 0x358:
      case 0x361:
      case 0x368:
      case 0x371:
      case 0x378:
      case 0x388:
      case 0x391:
      case 0x398:
      case 0x3A1:
      case 0x3A8:
      case 0x3B1:
      case 0x3B8:
      case 0x3C8:
      case 0x3D1:
      case 0x3D8:
      case 0x3E1:
      case 0x3E8:
      case 0x3F1:
      case 0x3F8:
      case 0x40CLL:
        if (a5 == v21 || (int)v33 > (int)v31)
          goto LABEL_88;
        v55 = &v32[v35];
        v56 = v34 + 1;
        do
        {
          if (v56 >= v55)
            goto LABEL_314;
          v33 = *(v56 - 1) + (_DWORD)v33 + *v56;
          v56 += 2;
        }
        while ((int)v33 <= (int)v31);
        v34 = v56 - 1;
LABEL_88:
        *a5 = i + v29 + v33;
        if (v34 >= &v32[*(unsigned int *)(v9 + 104)])
          goto LABEL_314;
        i = 0;
        ++a5;
        v58 = *v34++;
        v57 = v58;
        v31 = v33;
        goto LABEL_98;
      case 9:
      case 0x14:
      case 0x19:
      case 0x29:
      case 0x34:
      case 0x39:
      case 0x40:
      case 0x49:
      case 0x54:
      case 0x59:
      case 0x69:
      case 0x74:
      case 0x79:
      case 0x89:
      case 0x94:
      case 0x99:
      case 0xA9:
      case 0xB4:
      case 0xB9:
      case 0xC0:
      case 0xC9:
      case 0xD4:
      case 0xD9:
      case 0xE9:
      case 0xF4:
      case 0xF9:
      case 0x109:
      case 0x114:
      case 0x119:
      case 0x129:
      case 0x134:
      case 0x139:
      case 0x140:
      case 0x149:
      case 0x154:
      case 0x159:
      case 0x169:
      case 0x174:
      case 0x179:
      case 0x189:
      case 0x194:
      case 0x199:
      case 0x1A9:
      case 0x1B4:
      case 0x1B9:
      case 0x1C0:
      case 0x1C9:
      case 0x1D4:
      case 0x1D9:
      case 0x1E9:
      case 0x1F4:
      case 0x1F9:
      case 0x209:
      case 0x214:
      case 0x219:
      case 0x229:
      case 0x234:
      case 0x239:
      case 0x240:
      case 0x249:
      case 0x254:
      case 0x259:
      case 0x269:
      case 0x274:
      case 0x279:
      case 0x289:
      case 0x294:
      case 0x299:
      case 0x2A9:
      case 0x2B4:
      case 0x2B9:
      case 0x2C0:
      case 0x2C9:
      case 0x2D4:
      case 0x2D9:
      case 0x2E9:
      case 0x2F4:
      case 0x2F9:
      case 0x309:
      case 0x314:
      case 0x319:
      case 0x329:
      case 0x334:
      case 0x339:
      case 0x340:
      case 0x349:
      case 0x354:
      case 0x359:
      case 0x369:
      case 0x374:
      case 0x379:
      case 0x389:
      case 0x394:
      case 0x399:
      case 0x3A9:
      case 0x3B4:
      case 0x3B9:
      case 0x3C0:
      case 0x3C9:
      case 0x3D4:
      case 0x3D9:
      case 0x3E9:
      case 0x3F4:
      case 0x3F9:
        if (a5 == v21 || (int)v33 > (int)v31)
          goto LABEL_51;
        v39 = v34 + 1;
        do
        {
          if (v39 >= &v32[v35])
            goto LABEL_314;
          LODWORD(v33) = *(v39 - 1) + v33 + *v39;
          v39 += 2;
        }
        while ((int)v33 <= (int)v31);
        v34 = v39 - 1;
LABEL_51:
        if (v34 + 1 >= &v32[v35])
          goto LABEL_314;
        v40 = *v34;
        v41 = v34[1];
        v34 += 2;
        v31 = v40 + v33;
        i += v29 + v31;
        v33 = v31 + v41;
        goto LABEL_108;
      case 0x10:
      case 0x50:
      case 0x80:
      case 0x90:
      case 0xD0:
      case 0x100:
      case 0x110:
      case 0x150:
      case 0x190:
      case 0x1D0:
      case 0x210:
      case 0x250:
      case 0x280:
      case 0x290:
      case 0x2D0:
      case 0x310:
      case 0x350:
      case 0x390:
      case 0x3D0:
      case 0x411:
      case 0x41CLL:
      case 0x429:
        if (a5 == v21 || (int)v33 > (int)v31)
          goto LABEL_105;
        v63 = &v32[v35];
        v64 = v34 + 1;
        do
        {
          if (v64 >= v63)
            goto LABEL_314;
          LODWORD(v33) = *(v64 - 1) + v33 + *v64;
          v64 += 2;
        }
        while ((int)v33 <= (int)v31);
        v34 = v64 - 1;
LABEL_105:
        v65 = *((_DWORD *)&TIFFFaxMainTable + 2 * v37 + 1);
        if ((int)v33 >= v65 + (int)v31)
        {
          v66 = v33 + v29 - v65;
          *a5++ = v66 + i;
          v31 = (v66 + v31);
          v67 = *--v34;
          v33 = (v33 - v67);
          goto LABEL_107;
        }
        v157 = a5;
        v133 = v21;
        Fax3Unexpected("Fax3Decode2D", (uint64_t)a1, *(_DWORD *)(v9 + 152), v31, (uint64_t)a5, a6, a7, a8);
LABEL_271:
        v21 = v133;
        v123 = 0;
        goto LABEL_231;
      case 0x20:
      case 0x60:
      case 0x84:
      case 0xA0:
      case 0xE0:
      case 0x120:
      case 0x160:
      case 0x184:
      case 0x1A0:
      case 0x1E0:
      case 0x220:
      case 0x260:
      case 0x284:
      case 0x2A0:
      case 0x2E0:
      case 0x320:
      case 0x360:
      case 0x384:
      case 0x3A0:
      case 0x3E0:
        if ((((_DWORD)a5 - (_DWORD)v21) & 4) != 0)
        {
          while (1)
          {
            if (v12 > 12)
              goto LABEL_80;
            if ((unint64_t)v22 >= v18)
            {
              if (!v12)
                goto LABEL_295;
              v12 = 13;
            }
            else
            {
              v13 |= *(unsigned __int8 *)(v20 + *v22) << v12;
              if (v12 > 4)
              {
                v12 += 8;
              }
              else
              {
                if ((unint64_t)(v22 + 1) < v18)
                {
                  v49 = v22[1];
                  v22 += 2;
                  v13 |= *(unsigned __int8 *)(v20 + v49) << (v12 + 8);
                  v12 += 16;
                  goto LABEL_80;
                }
                v12 = 13;
              }
              ++v22;
            }
LABEL_80:
            v50 = v13 & 0x1FFF;
            v51 = (unsigned __int8 *)&TIFFFaxBlackTable + 8 * v50;
            v52 = v51[1];
            v12 -= v52;
            v13 >>= v52;
            v53 = *v51;
            if ((v53 - 10) >= 2)
              break;
            v54 = *((_DWORD *)&TIFFFaxBlackTable + 2 * v50 + 1);
            v31 = (v54 + v31);
            i += v54;
          }
          if (v53 != 8)
          {
            v157 = a5;
            v120 = v21;
LABEL_226:
            v122 = (uint64_t)a1;
            goto LABEL_229;
          }
          v76 = *((_DWORD *)&TIFFFaxBlackTable + 2 * v50 + 1);
          *a5 = v76 + i;
          v69 = a5 + 1;
          v31 = (v76 + v31);
          i = 0;
          while (2)
          {
            if (v12 > 11)
              goto LABEL_136;
            if ((unint64_t)v22 >= v18)
            {
              if (!v12)
              {
LABEL_310:
                v142 = v21;
                v141 = v69;
                goto LABEL_311;
              }
              v12 = 12;
            }
            else
            {
              v13 |= *(unsigned __int8 *)(v20 + *v22) << v12;
              if (v12 > 3)
              {
                v12 += 8;
              }
              else
              {
                if ((unint64_t)(v22 + 1) < v18)
                {
                  v77 = v22[1];
                  v22 += 2;
                  v13 |= *(unsigned __int8 *)(v20 + v77) << (v12 + 8);
                  v12 += 16;
                  goto LABEL_136;
                }
                v12 = 12;
              }
              ++v22;
            }
LABEL_136:
            v78 = v13 & 0xFFF;
            v79 = (unsigned __int8 *)&TIFFFaxWhiteTable + 8 * v78;
            v80 = v79[1];
            v12 -= v80;
            v13 >>= v80;
            v81 = *v79;
            if (v81 == 9 || v81 == 11)
            {
              v83 = *((_DWORD *)&TIFFFaxWhiteTable + 2 * v78 + 1);
              v31 = (v83 + v31);
              i += v83;
              continue;
            }
            break;
          }
          if (v81 != 7)
          {
            v120 = v21;
            v157 = a5 + 1;
            goto LABEL_228;
          }
          if (v69 >= &v21[*(unsigned int *)(v9 + 104)])
            goto LABEL_314;
          v84 = (char *)&TIFFFaxWhiteTable + 8 * v78;
LABEL_148:
          v85 = *((_DWORD *)v84 + 1);
          *v69 = v85 + i;
          v31 = (v85 + v31);
          a5 += 2;
          if (a5 != v21)
          {
            if ((int)v33 <= (int)v31 && (int)v33 < (int)v19)
            {
              v87 = v34 + 1;
              while (v87 < &v32[*(unsigned int *)(v9 + 104)])
              {
                v33 = *(v87 - 1) + (_DWORD)v33 + *v87;
                v87 += 2;
                if ((int)v33 > (int)v31 || (int)v33 >= (int)v19)
                {
                  i = 0;
                  v34 = v87 - 1;
                  goto LABEL_108;
                }
              }
              v150 = a1[150];
              goto LABEL_337;
            }
LABEL_107:
            i = 0;
            goto LABEL_108;
          }
          i = 0;
          a5 = v21;
LABEL_108:
          v29 = -(int)v31;
          if ((int)v31 >= (int)v19)
          {
            if (!i)
            {
              v104 = 0;
              goto LABEL_235;
            }
            if (i + (int)v31 >= (int)v19)
              goto LABEL_282;
            if (v12 > 0)
              goto LABEL_279;
            if ((unint64_t)v22 < v18)
            {
              v121 = *v22++;
              v13 |= *(unsigned __int8 *)(v20 + v121) << v12;
              v12 += 8;
              goto LABEL_279;
            }
            if (v12)
            {
              v12 = 1;
LABEL_279:
              if ((v13 & 1) == 0)
              {
LABEL_280:
                v157 = a5;
                v120 = v21;
                Fax3Unexpected("Fax3Decode2D", (uint64_t)a1, *(_DWORD *)(v9 + 152), v31, (uint64_t)a5, a6, a7, a8);
                goto LABEL_230;
              }
              --v12;
              v13 >>= 1;
LABEL_282:
              if (a5 >= &v21[*(unsigned int *)(v9 + 104)])
                goto LABEL_314;
              v104 = 0;
LABEL_234:
              *a5++ = i;
LABEL_235:
              v8 = a1;
LABEL_237:
              v158 = v11;
              v156 = v104;
              if ((_DWORD)v31 != (_DWORD)v19)
              {
                v112 = a5;
                v113 = v21;
                v124 = "Premature EOL";
                if (v31 >= v19)
                  v124 = "Line length mismatch";
                TIFFWarningExtR((uint64_t)v8, "Fax3Decode2D", "%s at line %u of %s %u (got %u, expected %u)", v19, (uint64_t)a5, a6, a7, a8, (char)v124);
                v19 = v161;
                v115 = (int)v31 > (int)v161;
                if ((int)v31 > (int)v161)
                {
                  v21 = v113;
                  a5 = v112;
                  if (v112 > v113)
                  {
                    v125 = v112 - 1;
                    v117 = v112 - 1;
                    do
                    {
                      v126 = *v117--;
                      LODWORD(v31) = v31 - v126;
                      v115 = (int)v31 > (int)v161;
                      v127 = (int)v31 > (int)v161 && v125 > v113;
                      v125 = v117;
                    }
                    while (v127);
                    goto LABEL_247;
                  }
                  goto LABEL_249;
                }
LABEL_248:
                v21 = v113;
                a5 = v112;
                goto LABEL_249;
              }
LABEL_259:
              v128 = v159;
LABEL_260:
              v129 = v21;
              v130 = a5;
              (*(void (**)(uint64_t))(v9 + 88))(v128);
              if (v130 < &v129[*(unsigned int *)(v9 + 104)])
                *v130 = 0;
              v131 = *(int8x16_t *)(v9 + 112);
              *(int8x16_t *)(v9 + 112) = vextq_s8(v131, v131, 8uLL);
              v132 = *(_QWORD *)(v9 + 8);
              a2 = v128 + v132;
              ++*(_DWORD *)(v9 + 152);
              v21 = (int *)v131.i64[0];
              v11 = v158 - v132;
              v19 = v161;
              v14 = v156;
              if (v158 <= v132)
              {
                v15 = v8[144];
                v16 = v8[145];
LABEL_285:
                *(_DWORD *)(v9 + 72) = v13;
                *(_DWORD *)(v9 + 76) = v12;
                *(_DWORD *)(v9 + 80) = v14;
                v8[145] = v15 - (_QWORD)v22 + v16;
                v8[144] = v22;
                return 1;
              }
              continue;
            }
LABEL_295:
            v141 = a5;
            v142 = v21;
LABEL_311:
            TIFFWarningExtR((uint64_t)a1, "Fax3Decode2D", "Premature EOF at line %u of %s %u (x %u)", v19, (uint64_t)a5, a6, a7, a8, *(_DWORD *)(v9 + 152));
            if (i)
            {
              v19 = v161;
              if (v141 >= &v142[*(unsigned int *)(v9 + 104)])
                goto LABEL_314;
              v21 = v142;
              *v141 = i;
              v138 = v141 + 1;
            }
            else
            {
              v138 = v141;
              LODWORD(v19) = v161;
              v21 = v142;
            }
            v8 = a1;
            if ((_DWORD)v31 != (_DWORD)v19)
            {
              v143 = v138;
              v144 = v21;
              Fax3BadLength("Fax3Decode2D", (uint64_t)a1, *(unsigned int *)(v9 + 152), v31, v161, a6, a7, a8);
              v19 = v161;
              v145 = (int)v31 > (int)v161;
              if ((int)v31 > (int)v161)
              {
                v21 = v144;
                v138 = v143;
                if (v143 > v144)
                {
                  v151 = v143 - 1;
                  v147 = v143 - 1;
                  do
                  {
                    v152 = *v147--;
                    LODWORD(v31) = v31 - v152;
                    v145 = (int)v31 > (int)v161;
                    v153 = (int)v31 > (int)v161 && v151 > v144;
                    v151 = v147;
                  }
                  while (v153);
                  goto LABEL_324;
                }
                goto LABEL_326;
              }
LABEL_325:
              v21 = v144;
              v138 = v143;
              goto LABEL_326;
            }
LABEL_338:
            v14 = 0;
LABEL_339:
            a2 = v159;
LABEL_342:
            (*(void (**)(uint64_t, int *, int *))(v9 + 88))(a2, v21, v138);
            *(_DWORD *)(v9 + 72) = v13;
            *(_DWORD *)(v9 + 76) = 0;
            *(_DWORD *)(v9 + 80) = v14;
            v8[145] += v8[144] - (_QWORD)v22;
            v8[144] = v22;
            return 0xFFFFFFFFLL;
          }
          goto LABEL_38;
        }
        while (1)
        {
          if (v12 > 11)
            goto LABEL_64;
          if ((unint64_t)v22 >= v18)
          {
            if (!v12)
              goto LABEL_295;
            v12 = 12;
          }
          else
          {
            v13 |= *(unsigned __int8 *)(v20 + *v22) << v12;
            if (v12 > 3)
            {
              v12 += 8;
            }
            else
            {
              if ((unint64_t)(v22 + 1) < v18)
              {
                v42 = v22[1];
                v22 += 2;
                v13 |= *(unsigned __int8 *)(v20 + v42) << (v12 + 8);
                v12 += 16;
                goto LABEL_64;
              }
              v12 = 12;
            }
            ++v22;
          }
LABEL_64:
          v43 = v13 & 0xFFF;
          v44 = (unsigned __int8 *)&TIFFFaxWhiteTable + 8 * v43;
          v45 = v44[1];
          v12 -= v45;
          v13 >>= v45;
          v46 = *v44;
          if (v46 != 9 && v46 != 11)
            break;
          v48 = *((_DWORD *)&TIFFFaxWhiteTable + 2 * v43 + 1);
          v31 = (v48 + v31);
          i += v48;
        }
        if (v46 != 7)
        {
          v157 = a5;
          v120 = v21;
LABEL_228:
          v122 = (uint64_t)a1;
LABEL_229:
          TIFFErrorExtR(v122, "Fax3Decode2D", "Bad code word at line %u of %s %u (x %u)", v19, (uint64_t)a5, a6, a7, a8, *(_DWORD *)(v9 + 152));
LABEL_230:
          v123 = 0;
          v21 = v120;
LABEL_231:
          if (i)
          {
            a5 = v157;
            v19 = v161;
            if (v157 >= &v21[*(unsigned int *)(v9 + 104)])
              goto LABEL_314;
            v104 = v123;
            goto LABEL_234;
          }
          v8 = a1;
          v19 = v161;
          a5 = v157;
          v104 = v123;
          goto LABEL_237;
        }
        v68 = *((_DWORD *)&TIFFFaxWhiteTable + 2 * v43 + 1);
        *a5 = v68 + i;
        v69 = a5 + 1;
        v31 = (v68 + v31);
        for (i = 0; ; i += v75)
        {
          if (v12 > 12)
            goto LABEL_122;
          if ((unint64_t)v22 >= v18)
          {
            if (!v12)
              goto LABEL_310;
            v12 = 13;
          }
          else
          {
            v13 |= *(unsigned __int8 *)(v20 + *v22) << v12;
            if (v12 > 4)
            {
              v12 += 8;
            }
            else
            {
              if ((unint64_t)(v22 + 1) < v18)
              {
                v70 = v22[1];
                v22 += 2;
                v13 |= *(unsigned __int8 *)(v20 + v70) << (v12 + 8);
                v12 += 16;
                goto LABEL_122;
              }
              v12 = 13;
            }
            ++v22;
          }
LABEL_122:
          v71 = v13 & 0x1FFF;
          v72 = (unsigned __int8 *)&TIFFFaxBlackTable + 8 * v71;
          v73 = v72[1];
          v12 -= v73;
          v13 >>= v73;
          v74 = *v72;
          if ((v74 - 10) >= 2)
            break;
          v75 = *((_DWORD *)&TIFFFaxBlackTable + 2 * v71 + 1);
          v31 = (v75 + v31);
        }
        if (v74 != 8)
        {
          v120 = v21;
          v157 = a5 + 1;
          goto LABEL_226;
        }
        if (v69 < &v21[*(unsigned int *)(v9 + 104)])
        {
          v84 = (char *)&TIFFFaxBlackTable + 8 * v71;
          goto LABEL_148;
        }
LABEL_314:
        v150 = a1[150];
LABEL_337:
        TIFFErrorExt(v150, "Fax3Decode2D", "Buffer overflow at line %u of %s %u", v19, (uint64_t)a5, a6, a7, a8, *(_DWORD *)(v9 + 152));
        return 0xFFFFFFFFLL;
      case 0x30:
      case 0x41:
      case 0x70:
      case 0xB0:
      case 0xC1:
      case 0xF0:
      case 0x130:
      case 0x141:
      case 0x170:
      case 0x180:
      case 0x1B0:
      case 0x1C1:
      case 0x1F0:
      case 0x230:
      case 0x241:
      case 0x270:
      case 0x2B0:
      case 0x2C1:
      case 0x2F0:
      case 0x300:
      case 0x330:
      case 0x341:
      case 0x370:
      case 0x380:
      case 0x3B0:
      case 0x3C1:
      case 0x3F0:
      case 0x409:
      case 0x419:
        if (a5 == v21 || (int)v33 > (int)v31)
          goto LABEL_96;
        v59 = &v32[v35];
        v60 = v34 + 1;
        do
        {
          if (v60 >= v59)
            goto LABEL_314;
          LODWORD(v33) = *(v60 - 1) + v33 + *v60;
          v60 += 2;
        }
        while ((int)v33 <= (int)v31);
        v34 = v60 - 1;
LABEL_96:
        v61 = *((_DWORD *)&TIFFFaxMainTable + 2 * v37 + 1);
        *a5 = i + v29 + v33 + v61;
        if (v34 >= &v32[*(unsigned int *)(v9 + 104)])
          goto LABEL_314;
        i = 0;
        v31 = (v61 + v33);
        ++a5;
        v62 = *v34++;
        v57 = v62;
LABEL_98:
        v33 = (v57 + v33);
        goto LABEL_108;
      case 0x81:
      case 0x181:
      case 0x200:
      case 0x281:
      case 0x381:
      case 0x421:
      case 0x431:
        *a5 = v19 - v31;
        v157 = a5 + 1;
        v133 = v21;
        Fax3Extension("Fax3Decode2D", (uint64_t)a1, *(_DWORD *)(v9 + 152), v31, (uint64_t)(a5 + 1), a6, a7, a8);
        goto LABEL_271;
      default:
        goto LABEL_280;
    }
  }
}

uint64_t Fax3Unexpected(const char *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return TIFFErrorExtR(a2, a1, "Bad code word at line %u of %s %u (x %u)", a4, a5, a6, a7, a8, a3);
}

uint64_t Fax3BadLength(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v8;

  v8 = "Line length mismatch";
  if (a4 < a5)
    v8 = "Premature EOL";
  return TIFFWarningExtR(a2, a1, "%s at line %u of %s %u (got %u, expected %u)", a4, a5, a6, a7, a8, (char)v8);
}

uint64_t Fax3Extension(const char *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return TIFFErrorExtR(a2, a1, "Uncompressed data (not supported) at line %u of %s %u (x %u)", a4, a5, a6, a7, a8, a3);
}

uint64_t Fax3Encode1DRow(_QWORD *a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11;
  int v12;
  _BYTE *v13;
  int v14;
  unsigned int v15;
  uint64_t v16;
  _QWORD *v17;
  int v18;
  _BYTE *v19;
  int v21;
  BOOL v22;
  int v23;
  int v24;
  uint64_t result;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  unsigned __int8 *v30;
  int v31;
  unsigned int v32;
  uint64_t v33;
  unsigned __int8 *v34;
  int v35;
  unsigned __int8 *v36;
  uint64_t v37;
  int v39;
  uint64_t v40;
  int v41;
  int v42;
  int v43;
  char v44;
  _BYTE *v45;
  _BYTE *v46;
  int v47;
  _DWORD *v48;

  v11 = 0;
  v48 = (_DWORD *)a1[137];
  do
  {
    v12 = a3 - v11;
    if ((int)(a3 - v11) < 1)
    {
      v16 = 0;
      goto LABEL_39;
    }
    v13 = (_BYTE *)(a2 + (v11 >> 3));
    v14 = v11 & 7;
    if ((v11 & 7) != 0)
    {
      v15 = zeroruns[(*v13 << v14) & 0xFELL];
      if (8 - v14 < v15)
        v15 = 8 - v14;
      if (v15 >= v12)
        v16 = v12;
      else
        v16 = v15;
      if ((v16 + v14) < 8)
        goto LABEL_39;
      v12 -= v16;
      ++v13;
    }
    else
    {
      v16 = 0;
    }
    if (v12 < 128)
    {
      v17 = v13;
      goto LABEL_26;
    }
    if ((v13 & 7) != 0)
    {
      v17 = &v13[-(v13 & 7) + 8];
      v18 = -(int)v16;
      v19 = v13 + 1;
      do
      {
        if (*v13)
        {
          v24 = zeroruns[*v13];
          goto LABEL_38;
        }
        v12 -= 8;
        ++v13;
        v18 -= 8;
      }
      while ((unint64_t)(v19++ & 7));
      v16 = -v18;
      if (v12 + 8 > 71)
        goto LABEL_22;
LABEL_26:
      v21 = v12;
      if (v12 < 8)
      {
LABEL_32:
        if (v12 >= 1)
        {
          v23 = zeroruns[*(unsigned __int8 *)v17];
          if (v12 >= v23)
            v12 = v23;
          v16 = (v12 + v16);
        }
        goto LABEL_39;
      }
      goto LABEL_27;
    }
    v17 = v13;
LABEL_22:
    v21 = v12;
    while (!*v17)
    {
      v16 = (v16 + 64);
      v12 = v21 - 64;
      ++v17;
      v22 = v21 <= 127;
      v21 -= 64;
      if (v22)
        goto LABEL_26;
    }
LABEL_27:
    v18 = -(int)v16;
    while (!*(_BYTE *)v17)
    {
      v12 = v21 - 8;
      v17 = (_QWORD *)((char *)v17 + 1);
      v18 -= 8;
      v22 = v21 <= 15;
      v21 -= 8;
      if (v22)
      {
        v16 = -v18;
        goto LABEL_32;
      }
    }
    v24 = zeroruns[*(unsigned __int8 *)v17];
LABEL_38:
    v16 = (v24 - v18);
LABEL_39:
    result = putspan(a1, v16, (uint64_t)&TIFFFaxWhiteCodes, a4, a5, a6, a7, a8);
    if (!(_DWORD)result)
      return result;
    v28 = v16 + v11;
    v29 = a3 - v28;
    if (a3 <= v28)
      break;
    if (v29 < 1)
    {
      v33 = 0;
      goto LABEL_78;
    }
    v30 = (unsigned __int8 *)(a2 + (v28 >> 3));
    v31 = v28 & 7;
    if ((v28 & 7) != 0)
    {
      v32 = oneruns[(*v30 << v31) & 0xFELL];
      if (8 - v31 < v32)
        v32 = 8 - v31;
      if (v32 >= v29)
        v33 = v29;
      else
        v33 = v32;
      if ((v33 + v31) < 8)
        goto LABEL_78;
      v29 -= v33;
      ++v30;
    }
    else
    {
      v33 = 0;
    }
    if (v29 < 128)
    {
      v34 = v30;
      goto LABEL_65;
    }
    if ((v30 & 7) != 0)
    {
      v34 = &v30[-(v30 & 7) + 8];
      v35 = -(int)v33;
      v36 = v30 + 1;
      do
      {
        v37 = *v30;
        if (v37 != 255)
        {
          v42 = oneruns[v37];
          goto LABEL_77;
        }
        v29 -= 8;
        ++v30;
        v35 -= 8;
      }
      while ((unint64_t)(v36++ & 7));
      v33 = -v35;
      if (v29 + 8 > 71)
        goto LABEL_61;
LABEL_65:
      v39 = v29;
      if (v29 < 8)
      {
LABEL_71:
        if (v29 >= 1)
        {
          v41 = oneruns[*v34];
          if (v29 >= v41)
            v29 = v41;
          v33 = (v29 + v33);
        }
        goto LABEL_78;
      }
      goto LABEL_66;
    }
    v34 = v30;
LABEL_61:
    v39 = v29;
    while (*(_QWORD *)v34 == -1)
    {
      v33 = (v33 + 64);
      v29 = v39 - 64;
      v34 += 8;
      v22 = v39 <= 127;
      v39 -= 64;
      if (v22)
        goto LABEL_65;
    }
LABEL_66:
    v35 = -(int)v33;
    while (1)
    {
      v40 = *v34;
      if (v40 != 255)
        break;
      v29 = v39 - 8;
      ++v34;
      v35 -= 8;
      v22 = v39 <= 15;
      v39 -= 8;
      if (v22)
      {
        v33 = -v35;
        goto LABEL_71;
      }
    }
    v42 = oneruns[v40];
LABEL_77:
    v33 = (v42 - v35);
LABEL_78:
    result = putspan(a1, v33, (uint64_t)L"\n7", a4, a5, a6, a7, a8);
    if (!(_DWORD)result)
      return result;
    v11 = v33 + v28;
  }
  while (v11 < a3);
  v43 = v48[1];
  if ((v43 & 0xC) == 0)
    return 1;
  if (v48[19] == 8)
  {
LABEL_85:
    if ((v43 & 8) != 0)
    {
      v46 = (_BYTE *)a1[144];
      if ((v46 & 1) != 0)
      {
        if (a1[145] >= a1[141])
        {
          result = TIFFFlushData1((uint64_t)a1, v26, v27, a4, a5, a6, a7, a8);
          if (!(_DWORD)result)
            return result;
          v46 = (_BYTE *)a1[144];
        }
        v47 = v48[18];
        a1[144] = v46 + 1;
        *v46 = v47;
        ++a1[145];
        *((_QWORD *)v48 + 9) = 0x800000000;
      }
    }
    return 1;
  }
  if (a1[145] < a1[141] || (result = TIFFFlushData1((uint64_t)a1, v26, v27, a4, a5, a6, a7, a8), (_DWORD)result))
  {
    v44 = v48[18];
    v45 = (_BYTE *)a1[144];
    a1[144] = v45 + 1;
    *v45 = v44;
    ++a1[145];
    *((_QWORD *)v48 + 9) = 0x800000000;
    v43 = v48[1];
    goto LABEL_85;
  }
  return result;
}

uint64_t Fax3Encode2DRow(_QWORD *a1, char *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int v12;
  char *v13;
  char *v14;
  char *v15;
  BOOL v16;
  int v17;
  int v18;
  BOOL v19;
  int v20;
  int v21;
  unsigned int v22;
  char *v23;
  char *v24;
  char *v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  unsigned int v31;
  int v32;
  int v33;
  char *v34;
  unsigned int v35;
  char *v36;
  int v37;
  _BYTE *v38;
  uint64_t v39;
  char *v41;
  _BYTE *v42;
  int v44;
  uint64_t v45;
  int v46;
  int v47;
  int v48;
  uint64_t result;
  unsigned int v50;
  unsigned int v51;
  int v52;
  int v53;
  char *v54;
  unsigned int v55;
  char *v56;
  int v57;
  _BYTE *v58;
  uint64_t v59;
  char *v61;
  _BYTE *v62;
  int v64;
  int v65;
  int v66;
  uint64_t v67;
  int v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  _QWORD *v80;
  const __int16 *v81;
  int v82;
  int v83;
  uint64_t v84;
  char *v85;
  int v86;
  unsigned int v87;
  int v88;
  char *v89;
  int v90;
  _BYTE *v91;
  uint64_t v92;
  char *v94;
  _BYTE *v95;
  int v97;
  uint64_t v98;
  int v99;
  int v100;
  int v101;
  char *v102;
  unsigned int v103;
  char *v104;
  int v105;
  char *v106;
  int v107;
  _BYTE *v108;
  unsigned __int8 *v110;
  unsigned __int8 *v111;
  uint64_t v112;
  int v114;
  int v115;
  int v116;
  int v117;
  uint64_t v118;
  int v119;
  char *v120;
  int v121;
  unsigned int v122;
  char *v123;
  int v124;
  unsigned __int8 *v125;
  int v126;
  unsigned __int8 *v127;
  uint64_t v128;
  char *v130;
  _BYTE *v131;
  int v133;
  uint64_t v134;
  int v135;
  int v136;
  int v137;

  v8 = a4;
  v12 = 0;
  if ((int)a4 < 1 || *a2 < 0)
    goto LABEL_29;
  if (a4 < 0x80)
  {
    v12 = 0;
    v13 = a2;
    v18 = a4;
  }
  else
  {
    v12 = 0;
    if ((a2 & 7) == 0)
    {
      v13 = a2;
      v17 = a4;
LABEL_13:
      while (!*(_QWORD *)v13)
      {
        v12 += 64;
        v18 = v17 - 64;
        v13 += 8;
        v19 = v17 <= 127;
        v17 -= 64;
        if (v19)
          goto LABEL_16;
      }
      goto LABEL_17;
    }
    v13 = &a2[-(a2 & 7) + 8];
    v14 = a2 + 1;
    v15 = a2;
    do
    {
      if (*v15)
      {
        v21 = zeroruns[*v15];
        goto LABEL_28;
      }
      v12 += 8;
      ++v15;
      v16 = (v14++ & 7) == 0;
    }
    while (!v16);
    v17 = a4 - v12;
    v18 = a4 - v12;
    if ((int)(a4 - v12 + 8) > 71)
      goto LABEL_13;
  }
LABEL_16:
  v17 = v18;
  if (v18 >= 8)
  {
LABEL_17:
    v20 = -v12;
    while (!*v13)
    {
      v18 = v17 - 8;
      ++v13;
      v20 -= 8;
      v19 = v17 <= 15;
      v17 -= 8;
      if (v19)
      {
        v12 = -v20;
        goto LABEL_22;
      }
    }
    v12 = zeroruns[*v13] - v20;
    goto LABEL_29;
  }
LABEL_22:
  if (v18 >= 1)
  {
    v21 = zeroruns[*v13];
    if (v18 < v21)
      v21 = v18;
LABEL_28:
    v12 += v21;
  }
LABEL_29:
  v22 = 0;
  if ((int)a4 >= 1 && (*a3 & 0x80000000) == 0)
  {
    if (a4 < 0x80)
    {
      v22 = 0;
      v23 = a3;
      v27 = a4;
    }
    else
    {
      v22 = 0;
      if ((a3 & 7) == 0)
      {
        v23 = a3;
        v26 = a4;
LABEL_41:
        while (!*(_QWORD *)v23)
        {
          v22 += 64;
          v27 = v26 - 64;
          v23 += 8;
          v19 = v26 <= 127;
          v26 -= 64;
          if (v19)
            goto LABEL_44;
        }
LABEL_45:
        v28 = -v22;
        while (!*v23)
        {
          v27 = v26 - 8;
          ++v23;
          v28 -= 8;
          v19 = v26 <= 15;
          v26 -= 8;
          if (v19)
          {
            v22 = -v28;
            goto LABEL_50;
          }
        }
        v22 = zeroruns[*v23] - v28;
        goto LABEL_57;
      }
      v23 = &a3[-(a3 & 7) + 8];
      v24 = a3 + 1;
      v25 = a3;
      do
      {
        if (*v25)
        {
          v29 = zeroruns[*v25];
          goto LABEL_56;
        }
        v22 += 8;
        ++v25;
        v16 = (v24++ & 7) == 0;
      }
      while (!v16);
      v26 = a4 - v22;
      v27 = a4 - v22;
      if ((int)(a4 - v22 + 8) > 71)
        goto LABEL_41;
    }
LABEL_44:
    v26 = v27;
    if (v27 < 8)
    {
LABEL_50:
      if (v27 >= 1)
      {
        v29 = zeroruns[*v23];
        if (v27 < v29)
          v29 = v27;
LABEL_56:
        v22 += v29;
      }
      goto LABEL_57;
    }
    goto LABEL_45;
  }
LABEL_57:
  v30 = 0;
  while (1)
  {
    v31 = v8;
    v32 = v8 - v22;
    if (v8 <= v22)
      goto LABEL_130;
    v33 = v22 & 7;
    v34 = &a3[(int)v22 >> 3];
    if (((a3[(unint64_t)v22 >> 3] >> (v22 & 7 ^ 7)) & 1) != 0)
    {
      if (v32 < 1)
        goto LABEL_76;
      if ((v22 & 7) != 0)
      {
        v35 = oneruns[(*v34 << v33) & 0xFELL];
        if (8 - v33 < v35)
          v35 = 8 - v33;
        if (v35 >= v32)
          v35 = v8 - v22;
        if (v35 + v33 < 8)
          goto LABEL_129;
        v32 -= v35;
        ++v34;
      }
      else
      {
        v35 = 0;
      }
      if (v32 < 128)
      {
        v36 = v34;
        goto LABEL_100;
      }
      if ((v34 & 7) != 0)
      {
        v36 = &v34[-(v34 & 7) + 8];
        v37 = -v35;
        v38 = v34 + 1;
        do
        {
          v39 = *v34;
          if (v39 != 255)
          {
            v47 = oneruns[v39];
            goto LABEL_128;
          }
          v32 -= 8;
          ++v34;
          v37 -= 8;
        }
        while ((unint64_t)(v38++ & 7));
        v35 = -v37;
        if (v32 + 8 > 71)
          goto LABEL_96;
LABEL_100:
        v44 = v32;
        if (v32 >= 8)
          goto LABEL_101;
LABEL_106:
        if (v32 >= 1)
        {
          v46 = oneruns[*v36];
LABEL_123:
          if (v32 >= v46)
            v32 = v46;
          v35 += v32;
          goto LABEL_129;
        }
        goto LABEL_129;
      }
      v36 = v34;
LABEL_96:
      v44 = v32;
      while (*(_QWORD *)v36 == -1)
      {
        v35 += 64;
        v32 = v44 - 64;
        v36 += 8;
        v19 = v44 <= 127;
        v44 -= 64;
        if (v19)
          goto LABEL_100;
      }
LABEL_101:
      v37 = -v35;
      while (1)
      {
        v45 = *v36;
        if (v45 != 255)
          break;
        v32 = v44 - 8;
        ++v36;
        v37 -= 8;
        v19 = v44 <= 15;
        v44 -= 8;
        if (v19)
        {
          v35 = -v37;
          goto LABEL_106;
        }
      }
      v47 = oneruns[v45];
LABEL_128:
      v35 = v47 - v37;
      goto LABEL_129;
    }
    if (v32 < 1)
    {
LABEL_76:
      v35 = 0;
      goto LABEL_129;
    }
    if ((v22 & 7) != 0)
    {
      v35 = zeroruns[(*v34 << v33) & 0xFELL];
      if (8 - v33 < v35)
        v35 = 8 - v33;
      if (v35 >= v32)
        v35 = v8 - v22;
      if (v35 + v33 < 8)
        goto LABEL_129;
      v32 -= v35;
      ++v34;
    }
    else
    {
      v35 = 0;
    }
    if (v32 < 128)
    {
      v41 = v34;
    }
    else
    {
      if ((v34 & 7) == 0)
      {
        v41 = v34;
LABEL_111:
        v48 = v32;
        while (!*(_QWORD *)v41)
        {
          v35 += 64;
          v32 = v48 - 64;
          v41 += 8;
          v19 = v48 <= 127;
          v48 -= 64;
          if (v19)
            goto LABEL_115;
        }
LABEL_116:
        v37 = -v35;
        while (!*v41)
        {
          v32 = v48 - 8;
          ++v41;
          v37 -= 8;
          v19 = v48 <= 15;
          v48 -= 8;
          if (v19)
          {
            v35 = -v37;
            goto LABEL_121;
          }
        }
        v47 = zeroruns[*v41];
        goto LABEL_128;
      }
      v41 = &v34[-(v34 & 7) + 8];
      v37 = -v35;
      v42 = v34 + 1;
      do
      {
        if (*v34)
        {
          v47 = zeroruns[*v34];
          goto LABEL_128;
        }
        v32 -= 8;
        ++v34;
        v37 -= 8;
      }
      while ((unint64_t)(v42++ & 7));
      v35 = -v37;
      if (v32 + 8 > 71)
        goto LABEL_111;
    }
LABEL_115:
    v48 = v32;
    if (v32 >= 8)
      goto LABEL_116;
LABEL_121:
    if (v32 >= 1)
    {
      v46 = zeroruns[*v41];
      goto LABEL_123;
    }
LABEL_129:
    v31 = v35 + v22;
LABEL_130:
    if (v31 < v12)
    {
      result = Fax3PutBits(a1, 1, 4, a4, a5, a6, a7, a8);
      goto LABEL_220;
    }
    v50 = v22 - v12;
    if (v22 >= v12 && v50 < 4)
      goto LABEL_134;
    if (v22 < v12)
    {
      v51 = v12 - v22;
      if (v51 < 4)
      {
        v50 = -v51;
LABEL_134:
        result = Fax3PutBits(a1, vcodes[3 * v50 + 10], vcodes[3 * v50 + 9], a4, a5, a6, a7, a8);
        v30 = v12;
        if (!(_DWORD)result)
          return result;
        goto LABEL_221;
      }
    }
    v31 = v8;
    v52 = v8 - v12;
    if (v8 > v12)
    {
      v53 = v12 & 7;
      v54 = &a2[(int)v12 >> 3];
      if (((a2[(unint64_t)v12 >> 3] >> (v12 & 7 ^ 7)) & 1) != 0)
      {
        if (v52 >= 1)
        {
          if ((v12 & 7) != 0)
          {
            v55 = oneruns[(*v54 << v53) & 0xFELL];
            if (8 - v53 < v55)
              v55 = 8 - v53;
            if (v55 >= v52)
              v55 = v8 - v12;
            if (v55 + v53 >= 8)
            {
              v52 -= v55;
              ++v54;
              goto LABEL_159;
            }
LABEL_211:
            v31 = v55 + v12;
            goto LABEL_212;
          }
          v55 = 0;
LABEL_159:
          if (v52 < 128)
          {
            v56 = v54;
            goto LABEL_189;
          }
          if ((v54 & 7) == 0)
          {
            v56 = v54;
LABEL_185:
            v66 = v52;
            while (*(_QWORD *)v56 == -1)
            {
              v55 += 64;
              v52 = v66 - 64;
              v56 += 8;
              v19 = v66 <= 127;
              v66 -= 64;
              if (v19)
                goto LABEL_189;
            }
            goto LABEL_190;
          }
          v56 = &v54[-(v54 & 7) + 8];
          v57 = -v55;
          v58 = v54 + 1;
          do
          {
            v59 = *v54;
            if (v59 != 255)
            {
              v68 = oneruns[v59];
              goto LABEL_210;
            }
            v52 -= 8;
            ++v54;
            v57 -= 8;
          }
          while ((unint64_t)(v58++ & 7));
          v55 = -v57;
          if (v52 + 8 > 71)
            goto LABEL_185;
LABEL_189:
          v66 = v52;
          if (v52 >= 8)
          {
LABEL_190:
            v57 = -v55;
            while (1)
            {
              v67 = *v56;
              if (v67 != 255)
                break;
              v52 = v66 - 8;
              ++v56;
              v57 -= 8;
              v19 = v66 <= 15;
              v66 -= 8;
              if (v19)
              {
                v55 = -v57;
                goto LABEL_195;
              }
            }
            v68 = oneruns[v67];
LABEL_210:
            v55 = v68 - v57;
            goto LABEL_211;
          }
LABEL_195:
          if (v52 < 1)
            goto LABEL_211;
          v65 = oneruns[*v56];
LABEL_197:
          if (v52 >= v65)
            v52 = v65;
          v55 += v52;
          goto LABEL_211;
        }
      }
      else if (v52 >= 1)
      {
        if ((v12 & 7) != 0)
        {
          v55 = zeroruns[(*v54 << v53) & 0xFELL];
          if (8 - v53 < v55)
            v55 = 8 - v53;
          if (v55 >= v52)
            v55 = v8 - v12;
          if (v55 + v53 < 8)
            goto LABEL_211;
          v52 -= v55;
          ++v54;
        }
        else
        {
          v55 = 0;
        }
        if (v52 < 128)
        {
          v61 = v54;
LABEL_176:
          v64 = v52;
          if (v52 < 8)
          {
LABEL_182:
            if (v52 < 1)
              goto LABEL_211;
            v65 = zeroruns[*v61];
            goto LABEL_197;
          }
        }
        else
        {
          if ((v54 & 7) != 0)
          {
            v61 = &v54[-(v54 & 7) + 8];
            v57 = -v55;
            v62 = v54 + 1;
            do
            {
              if (*v54)
              {
                v68 = zeroruns[*v54];
                goto LABEL_210;
              }
              v52 -= 8;
              ++v54;
              v57 -= 8;
            }
            while ((unint64_t)(v62++ & 7));
            v55 = -v57;
            if (v52 + 8 <= 71)
              goto LABEL_176;
          }
          else
          {
            v61 = v54;
          }
          v64 = v52;
          while (!*(_QWORD *)v61)
          {
            v55 += 64;
            v52 = v64 - 64;
            v61 += 8;
            v19 = v64 <= 127;
            v64 -= 64;
            if (v19)
              goto LABEL_176;
          }
        }
        v57 = -v55;
        while (!*v61)
        {
          v52 = v64 - 8;
          ++v61;
          v57 -= 8;
          v19 = v64 <= 15;
          v64 -= 8;
          if (v19)
          {
            v55 = -v57;
            goto LABEL_182;
          }
        }
        v68 = zeroruns[*v61];
        goto LABEL_210;
      }
      v55 = 0;
      goto LABEL_211;
    }
LABEL_212:
    result = Fax3PutBits(a1, 1, 3, a4, a5, a6, a7, a8);
    if (!(_DWORD)result)
      return result;
    if (v30 + v12 && ((a2[(unint64_t)v30 >> 3] >> (~(_BYTE)v30 & 7)) & 1) != 0)
    {
      result = putspan(a1, v12 - v30, (uint64_t)L"\n7", v69, v70, v71, v72, v73);
      if (!(_DWORD)result)
        return result;
      v79 = v31 - v12;
      v80 = a1;
      v81 = (const __int16 *)&TIFFFaxWhiteCodes;
    }
    else
    {
      result = putspan(a1, v12 - v30, (uint64_t)&TIFFFaxWhiteCodes, v69, v70, v71, v72, v73);
      if (!(_DWORD)result)
        return result;
      v79 = v31 - v12;
      v80 = a1;
      v81 = L"\n7";
    }
    result = putspan(v80, v79, (uint64_t)v81, v74, v75, v76, v77, v78);
LABEL_220:
    v30 = v31;
    if (!(_DWORD)result)
      return result;
LABEL_221:
    v82 = v8 - v30;
    if (v8 <= v30)
      return 1;
    v83 = v30 & 7;
    v84 = (uint64_t)v30 >> 3;
    v85 = &a2[v30 >> 3];
    v86 = (1 << (v30 & 7 ^ 7)) & a2[(unint64_t)v30 >> 3];
    if (v86)
    {
      if (v82 < 1)
      {
        v87 = 0;
LABEL_240:
        v12 = v87 + v30;
LABEL_296:
        if (v82 < 1)
        {
          v103 = 0;
LABEL_313:
          v105 = v103 + v30;
          goto LABEL_369;
        }
        v102 = &a3[v84];
        if ((v30 & 7) != 0)
        {
          v103 = zeroruns[(*v102 << v83) & 0xFELL];
          if (8 - v83 < v103)
            v103 = 8 - v83;
          if (v103 >= v82)
            v103 = v8 - v30;
          if (v103 + v83 < 8)
            goto LABEL_313;
          v82 -= v103;
          ++v102;
        }
        else
        {
          v103 = 0;
        }
        if (v82 < 128)
        {
          v106 = v102;
        }
        else
        {
          if ((v102 & 7) == 0)
          {
            v106 = v102;
LABEL_335:
            v114 = v82;
            while (!*(_QWORD *)v106)
            {
              v103 += 64;
              v82 = v114 - 64;
              v106 += 8;
              v19 = v114 <= 127;
              v114 -= 64;
              if (v19)
                goto LABEL_339;
            }
LABEL_340:
            v107 = -v103;
            while (!*v106)
            {
              v82 = v114 - 8;
              ++v106;
              v107 -= 8;
              v19 = v114 <= 15;
              v114 -= 8;
              if (v19)
              {
                v103 = -v107;
                goto LABEL_345;
              }
            }
            v116 = zeroruns[*v106];
            goto LABEL_367;
          }
          v106 = &v102[-(v102 & 7) + 8];
          v107 = -v103;
          v108 = v102 + 1;
          do
          {
            if (*v102)
            {
              v116 = zeroruns[*v102];
              goto LABEL_367;
            }
            v82 -= 8;
            ++v102;
            v107 -= 8;
          }
          while ((unint64_t)(v108++ & 7));
          v103 = -v107;
          if (v82 + 8 > 71)
            goto LABEL_335;
        }
LABEL_339:
        v114 = v82;
        if (v82 >= 8)
          goto LABEL_340;
LABEL_345:
        if (v82 < 1)
          goto LABEL_368;
        v115 = zeroruns[*v106];
        goto LABEL_362;
      }
      if ((v30 & 7) != 0)
      {
        v87 = oneruns[(*v85 << v83) & 0xFELL];
        if (8 - v83 < v87)
          v87 = 8 - v83;
        if (v87 >= v82)
          v87 = v8 - v30;
        if (v87 + v83 < 8)
          goto LABEL_240;
        v88 = v82 - v87;
        ++v85;
      }
      else
      {
        v87 = 0;
        v88 = v8 - v30;
      }
      if (v88 < 128)
      {
        v89 = v85;
      }
      else
      {
        if ((v85 & 7) == 0)
        {
          v89 = v85;
LABEL_262:
          v97 = v88;
          while (*(_QWORD *)v89 == -1)
          {
            v87 += 64;
            v88 = v97 - 64;
            v89 += 8;
            v19 = v97 <= 127;
            v97 -= 64;
            if (v19)
              goto LABEL_266;
          }
LABEL_267:
          v90 = -v87;
          while (1)
          {
            v98 = *v89;
            if (v98 != 255)
              break;
            v88 = v97 - 8;
            ++v89;
            v90 -= 8;
            v19 = v97 <= 15;
            v97 -= 8;
            if (v19)
            {
              v87 = -v90;
              goto LABEL_272;
            }
          }
          v100 = oneruns[v98];
          goto LABEL_294;
        }
        v89 = &v85[-(v85 & 7) + 8];
        v90 = -v87;
        v91 = v85 + 1;
        do
        {
          v92 = *v85;
          if (v92 != 255)
          {
            v100 = oneruns[v92];
            goto LABEL_294;
          }
          v88 -= 8;
          ++v85;
          v90 -= 8;
        }
        while ((unint64_t)(v91++ & 7));
        v87 = -v90;
        if (v88 + 8 > 71)
          goto LABEL_262;
      }
LABEL_266:
      v97 = v88;
      if (v88 >= 8)
        goto LABEL_267;
LABEL_272:
      if (v88 < 1)
        goto LABEL_295;
      v99 = oneruns[*v89];
    }
    else
    {
      if (v82 < 1)
      {
        v87 = 0;
LABEL_250:
        v12 = v87 + v30;
        goto LABEL_304;
      }
      if ((v30 & 7) != 0)
      {
        v87 = zeroruns[(*v85 << v83) & 0xFELL];
        if (8 - v83 < v87)
          v87 = 8 - v83;
        if (v87 >= v82)
          v87 = v8 - v30;
        if (v87 + v83 < 8)
          goto LABEL_250;
        v88 = v82 - v87;
        ++v85;
      }
      else
      {
        v87 = 0;
        v88 = v8 - v30;
      }
      if (v88 < 128)
      {
        v94 = v85;
      }
      else
      {
        if ((v85 & 7) == 0)
        {
          v94 = v85;
LABEL_277:
          v101 = v88;
          while (!*(_QWORD *)v94)
          {
            v87 += 64;
            v88 = v101 - 64;
            v94 += 8;
            v19 = v101 <= 127;
            v101 -= 64;
            if (v19)
              goto LABEL_281;
          }
LABEL_282:
          v90 = -v87;
          while (!*v94)
          {
            v88 = v101 - 8;
            ++v94;
            v90 -= 8;
            v19 = v101 <= 15;
            v101 -= 8;
            if (v19)
            {
              v87 = -v90;
              goto LABEL_287;
            }
          }
          v100 = zeroruns[*v94];
LABEL_294:
          v87 = v100 - v90;
          goto LABEL_295;
        }
        v94 = &v85[-(v85 & 7) + 8];
        v90 = -v87;
        v95 = v85 + 1;
        do
        {
          if (*v85)
          {
            v100 = zeroruns[*v85];
            goto LABEL_294;
          }
          v88 -= 8;
          ++v85;
          v90 -= 8;
        }
        while ((unint64_t)(v95++ & 7));
        v87 = -v90;
        if (v88 + 8 > 71)
          goto LABEL_277;
      }
LABEL_281:
      v101 = v88;
      if (v88 >= 8)
        goto LABEL_282;
LABEL_287:
      if (v88 < 1)
        goto LABEL_295;
      v99 = zeroruns[*v94];
    }
    if (v88 < v99)
      v99 = v88;
    v87 += v99;
LABEL_295:
    v12 = v87 + v30;
    if (v86)
      goto LABEL_296;
LABEL_304:
    if (v82 < 1)
    {
      v103 = 0;
LABEL_323:
      v105 = v103 + v30;
LABEL_377:
      v119 = v8 - v105;
      if ((int)(v8 - v105) < 1)
      {
LABEL_385:
        v122 = 0;
        goto LABEL_438;
      }
      v123 = &a3[v105 >> 3];
      v124 = v105 & 7;
      if ((v105 & 7) == 0)
      {
        v122 = 0;
LABEL_396:
        if (v119 < 128)
        {
          v130 = v123;
        }
        else
        {
          if ((v123 & 7) == 0)
          {
            v130 = v123;
LABEL_420:
            v137 = v119;
            while (!*(_QWORD *)v130)
            {
              v122 += 64;
              v119 = v137 - 64;
              v130 += 8;
              v19 = v137 <= 127;
              v137 -= 64;
              if (v19)
                goto LABEL_424;
            }
LABEL_425:
            v126 = -v122;
            while (!*v130)
            {
              v119 = v137 - 8;
              ++v130;
              v126 -= 8;
              v19 = v137 <= 15;
              v137 -= 8;
              if (v19)
              {
                v122 = -v126;
                goto LABEL_430;
              }
            }
            v136 = zeroruns[*v130];
LABEL_437:
            v122 = v136 - v126;
            goto LABEL_438;
          }
          v130 = &v123[-(v123 & 7) + 8];
          v126 = -v122;
          v131 = v123 + 1;
          do
          {
            if (*v123)
            {
              v136 = zeroruns[*v123];
              goto LABEL_437;
            }
            v119 -= 8;
            ++v123;
            v126 -= 8;
          }
          while ((unint64_t)(v131++ & 7));
          v122 = -v126;
          if (v119 + 8 > 71)
            goto LABEL_420;
        }
LABEL_424:
        v137 = v119;
        if (v119 >= 8)
          goto LABEL_425;
LABEL_430:
        if (v119 < 1)
          goto LABEL_438;
        v135 = zeroruns[*v130];
LABEL_432:
        if (v119 >= v135)
          v119 = v135;
        v122 += v119;
        goto LABEL_438;
      }
      v122 = zeroruns[(*v123 << v124) & 0xFELL];
      if (8 - v124 < v122)
        v122 = 8 - v124;
      if (v122 >= v119)
        v122 = v8 - v105;
      if (v122 + v124 >= 8)
      {
        v119 -= v122;
        ++v123;
        goto LABEL_396;
      }
      goto LABEL_438;
    }
    v104 = &a3[v84];
    if ((v30 & 7) != 0)
    {
      v103 = oneruns[(*v104 << v83) & 0xFELL];
      if (8 - v83 < v103)
        v103 = 8 - v83;
      if (v103 >= v82)
        v103 = v8 - v30;
      if (v103 + v83 < 8)
        goto LABEL_323;
      v82 -= v103;
      ++v104;
    }
    else
    {
      v103 = 0;
    }
    if (v82 < 128)
    {
      v110 = (unsigned __int8 *)v104;
    }
    else
    {
      if ((v104 & 7) == 0)
      {
        v110 = (unsigned __int8 *)v104;
LABEL_350:
        v117 = v82;
        while (*(_QWORD *)v110 == -1)
        {
          v103 += 64;
          v82 = v117 - 64;
          v110 += 8;
          v19 = v117 <= 127;
          v117 -= 64;
          if (v19)
            goto LABEL_354;
        }
LABEL_355:
        v107 = -v103;
        while (1)
        {
          v118 = *v110;
          if (v118 != 255)
            break;
          v82 = v117 - 8;
          ++v110;
          v107 -= 8;
          v19 = v117 <= 15;
          v117 -= 8;
          if (v19)
          {
            v103 = -v107;
            goto LABEL_360;
          }
        }
        v116 = oneruns[v118];
LABEL_367:
        v103 = v116 - v107;
        goto LABEL_368;
      }
      v110 = (unsigned __int8 *)&v104[-(v104 & 7) + 8];
      v107 = -v103;
      v111 = (unsigned __int8 *)(v104 + 1);
      do
      {
        v112 = *v104;
        if (v112 != 255)
        {
          v116 = oneruns[v112];
          goto LABEL_367;
        }
        v82 -= 8;
        ++v104;
        v107 -= 8;
      }
      while ((unint64_t)(v111++ & 7));
      v103 = -v107;
      if (v82 + 8 > 71)
        goto LABEL_350;
    }
LABEL_354:
    v117 = v82;
    if (v82 >= 8)
      goto LABEL_355;
LABEL_360:
    if (v82 < 1)
      goto LABEL_368;
    v115 = oneruns[*v110];
LABEL_362:
    if (v82 >= v115)
      v82 = v115;
    v103 += v82;
LABEL_368:
    v105 = v103 + v30;
    if (!v86)
      goto LABEL_377;
LABEL_369:
    v119 = v8 - v105;
    if ((int)(v8 - v105) < 1)
      goto LABEL_385;
    v120 = &a3[v105 >> 3];
    v121 = v105 & 7;
    if ((v105 & 7) == 0)
    {
      v122 = 0;
      goto LABEL_387;
    }
    v122 = oneruns[(*v120 << v121) & 0xFELL];
    if (8 - v121 < v122)
      v122 = 8 - v121;
    if (v122 >= v119)
      v122 = v8 - v105;
    if (v122 + v121 >= 8)
    {
      v119 -= v122;
      ++v120;
LABEL_387:
      if (v119 < 128)
      {
        v125 = (unsigned __int8 *)v120;
      }
      else
      {
        if ((v120 & 7) == 0)
        {
          v125 = (unsigned __int8 *)v120;
LABEL_405:
          v133 = v119;
          while (*(_QWORD *)v125 == -1)
          {
            v122 += 64;
            v119 = v133 - 64;
            v125 += 8;
            v19 = v133 <= 127;
            v133 -= 64;
            if (v19)
              goto LABEL_409;
          }
LABEL_410:
          v126 = -v122;
          while (1)
          {
            v134 = *v125;
            if (v134 != 255)
              break;
            v119 = v133 - 8;
            ++v125;
            v126 -= 8;
            v19 = v133 <= 15;
            v133 -= 8;
            if (v19)
            {
              v122 = -v126;
              goto LABEL_415;
            }
          }
          v136 = oneruns[v134];
          goto LABEL_437;
        }
        v125 = (unsigned __int8 *)&v120[-(v120 & 7) + 8];
        v126 = -v122;
        v127 = (unsigned __int8 *)(v120 + 1);
        do
        {
          v128 = *v120;
          if (v128 != 255)
          {
            v136 = oneruns[v128];
            goto LABEL_437;
          }
          v119 -= 8;
          ++v120;
          v126 -= 8;
        }
        while ((unint64_t)(v127++ & 7));
        v122 = -v126;
        if (v119 + 8 > 71)
          goto LABEL_405;
      }
LABEL_409:
      v133 = v119;
      if (v119 >= 8)
        goto LABEL_410;
LABEL_415:
      if (v119 < 1)
        goto LABEL_438;
      v135 = oneruns[*v125];
      goto LABEL_432;
    }
LABEL_438:
    v22 = v122 + v105;
  }
}

