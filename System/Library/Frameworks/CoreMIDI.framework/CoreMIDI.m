void *CADeprecated::XMachServer::RemoveMachClient(CADeprecated::XMachServer *this, CADeprecated::XMachServer::Client *a2)
{
  mach_port_name_t v4;
  ipc_space_t *v5;
  kern_return_t v6;
  uint64_t v7;
  void *result;
  int v9;
  CADeprecated::XMachServer::Client **v10;
  CADeprecated::XMachServer::Client **v11;
  int64_t v12;
  mach_port_t previous;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  uint64_t v19;
  __int16 v20;
  kern_return_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v4 = *((_DWORD *)a2 + 3);
  previous = 0;
  v5 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
  v6 = mach_port_request_notification(*MEMORY[0x1E0C83DA0], v4, 72, 1u, 0, 0x15u, &previous);
  if (v6)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      v7 = (*(uint64_t (**)(char *))(*((_QWORD *)this + 10) + 24))((char *)this + 80);
      *(_DWORD *)buf = 136315906;
      v15 = "XMachServer.cpp";
      v16 = 1024;
      v17 = 128;
      v18 = 2080;
      v19 = v7;
      v20 = 1024;
      v21 = v6;
      _os_log_impl(&dword_1D4E88000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "%25s:%-5d %s: XMachServer couldn't cancel port-death notification (0x%x)", buf, 0x22u);
    }
  }
  else
  {
    mach_port_deallocate(*v5, previous);
  }
  result = (void *)(*(uint64_t (**)(char *))(*((_QWORD *)this + 14) + 16))((char *)this + 112);
  v9 = (int)result;
  v11 = (CADeprecated::XMachServer::Client **)*((_QWORD *)this + 25);
  v10 = (CADeprecated::XMachServer::Client **)*((_QWORD *)this + 26);
  while (v11 != v10)
  {
    if (*v11 == a2)
    {
      v12 = (char *)v10 - (char *)(v11 + 1);
      if (v10 != v11 + 1)
        result = memmove(v11, v11 + 1, (char *)v10 - (char *)(v11 + 1));
      *((_QWORD *)this + 26) = (char *)v11 + v12;
      break;
    }
    ++v11;
  }
  if (v9)
    return (void *)(*(uint64_t (**)(char *))(*((_QWORD *)this + 14) + 24))((char *)this + 112);
  return result;
}

void sub_1D4E898B0(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

void CADeprecated::CAMutex::Unlock(CADeprecated::CAMutex *this)
{
  _opaque_pthread_t *v2;
  _opaque_pthread_t *v3;
  int v4;
  int v5;
  _DWORD *exception;
  uint8_t v7[16];
  uint8_t buf[16];

  v2 = pthread_self();
  v3 = (_opaque_pthread_t *)atomic_load((unint64_t *)this + 2);
  if (pthread_equal(v2, v3))
  {
    atomic_store(0, (unint64_t *)this + 2);
    v4 = pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 24));
    if (v4)
    {
      v5 = v4;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1D4E88000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, " CAMutex::Unlock: Could not unlock the mutex", buf, 2u);
      }
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &off_1E98B9410;
      exception[2] = v5;
    }
  }
  else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v7 = 0;
    _os_log_impl(&dword_1D4E88000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, " CAMutex::Unlock: A thread is attempting to unlock a Mutex it doesn't own", v7, 2u);
  }
}

BOOL CADeprecated::CAMutex::Lock(CADeprecated::CAMutex *this)
{
  _opaque_pthread_t *v2;
  _opaque_pthread_t *v3;
  int v4;
  int v5;
  int v7;
  _DWORD *exception;
  uint8_t v9[16];

  v2 = pthread_self();
  v3 = (_opaque_pthread_t *)atomic_load((unint64_t *)this + 2);
  v4 = pthread_equal(v2, v3);
  if (!v4)
  {
    v5 = pthread_mutex_lock((pthread_mutex_t *)((char *)this + 24));
    if (v5)
    {
      v7 = v5;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v9 = 0;
        _os_log_error_impl(&dword_1D4E88000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, " CAMutex::Lock: Could not lock the mutex", v9, 2u);
      }
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &off_1E98B9410;
      exception[2] = v7;
    }
    atomic_store((unint64_t)v2, (unint64_t *)this + 2);
  }
  return v4 == 0;
}

uint64_t BaseOpaqueObject::ResolveOpaqueRef(uint64_t a1, int a2)
{
  uint64_t result;
  uint64_t *v4;
  char v5;
  BOOL v6;
  uint64_t *v7;

  result = OpaqueObjectMgr::sInstance;
  if (OpaqueObjectMgr::sInstance)
  {
    v4 = caulk::concurrent::guarded_lookup_hash_table<unsigned int,BaseOpaqueObject *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()>>::lookup<(caulk::concurrent::guarded_lookup_hash_table_options)0,void>(OpaqueObjectMgr::sInstance, a2);
    if (v5)
      v6 = v4 == 0;
    else
      v6 = 1;
    if (v6)
    {
      return 0;
    }
    else
    {
      v7 = v4;
      if ((*(unsigned int (**)(uint64_t *, uint64_t))(*v4 + 24))(v4, a1))
        return (uint64_t)v7;
      else
        return 0;
    }
  }
  return result;
}

uint64_t *caulk::concurrent::guarded_lookup_hash_table<unsigned int,BaseOpaqueObject *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned int)>>::lookup<(caulk::concurrent::guarded_lookup_hash_table_options)0,void>(uint64_t a1, int a2)
{
  unsigned int *v2;
  unsigned int v3;
  uint64_t *result;
  uint64_t v5;
  unsigned int v6;

  v2 = (unsigned int *)(a1 + 48);
  do
    v3 = __ldaxr(v2);
  while (__stlxr(v3 + 1, v2));
  result = (uint64_t *)atomic_load((unint64_t *)(a1 + 40));
  if (result)
  {
    caulk::concurrent::guarded_lookup_hash_table<unsigned int,BaseOpaqueObject *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()>>::table_impl::findSlotForKey(result, a2);
    if (v5)
      result = *(uint64_t **)(v5 + 8);
    else
      result = 0;
  }
  do
    v6 = __ldaxr(v2);
  while (__stlxr(v6 - 1, v2));
  return result;
}

uint64_t caulk::concurrent::guarded_lookup_hash_table<unsigned int,BaseOpaqueObject *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned int)>>::table_impl::findSlotForKey(uint64_t *a1, int a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  int v15;
  int v17;

  v3 = *((_DWORD *)a1 + 2);
  v4 = *a1;
  v17 = a2;
  v5 = *(_QWORD *)(v4 + 24);
  if (!v5)
    goto LABEL_24;
  v7 = (*(unsigned int (**)(uint64_t, int *))(*(_QWORD *)v5 + 48))(v5, &v17) % *((_DWORD *)a1 + 2);
  if ((int)v7 >= 3)
    v8 = 0;
  else
    v8 = v3;
  v9 = (v7 + v8 - 3);
  v10 = 0xFFFFFFFFLL;
  v11 = 1;
  v12 = v7;
  while (1)
  {
    v13 = v9;
    v14 = atomic_load((unint64_t *)&a1[v12 + 2]);
    if (v14 != -1)
      break;
    if ((int)v10 >= 0)
      v10 = v10;
    else
      v10 = v12;
LABEL_13:
    if ((int)v9 >= 3)
      v15 = 0;
    else
      v15 = v3;
    v9 = (v9 + v15 - 3);
    v12 = v13;
    if ((_DWORD)v13 == (_DWORD)v7)
    {
      if ((v10 & 0x80000000) == 0)
      {
        v11 = 0;
        v12 = v10;
        return v11 | (v12 << 32);
      }
      __break(1u);
LABEL_24:
      std::__throw_bad_function_call[abi:ne180100]();
    }
  }
  if (v14)
  {
    if (*(_DWORD *)(v14 + 4) == a2)
      return v11 | (v12 << 32);
    goto LABEL_13;
  }
  v11 = 0;
  if ((int)v10 >= 0)
    v12 = v10;
  else
    v12 = v12;
  return v11 | (v12 << 32);
}

uint64_t std::__function::__func<OpaqueObjectMgr::OpaqueObjectMgr(void)::$_0,std::allocator<OpaqueObjectMgr::OpaqueObjectMgr(void)::$_0>,unsigned int ()(unsigned int)>::operator()(uint64_t a1, unsigned int *a2)
{
  return *a2;
}

unsigned int *std::__shared_ptr_emplace<CADeprecated::XMachReceivePort>::__on_zero_shared(uint64_t a1)
{
  unsigned int *v1;

  v1 = (unsigned int *)(a1 + 24);
  atomic_load(v1);
  return CADeprecated::XMachReceivePort::SetMachPort(v1, 0);
}

void CADeprecated::XBasicMIGServer::~XBasicMIGServer(CADeprecated::XBasicMIGServer *this)
{
  const void *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;

  *(_QWORD *)this = &off_1E98B9C78;
  v2 = (const void *)*((_QWORD *)this + 8);
  if (v2)
    CFRelease(v2);
  v3 = *((_QWORD *)this + 7);
  *((_QWORD *)this + 7) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = (std::__shared_weak_count *)*((_QWORD *)this + 6);
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

{
  CADeprecated::XBasicMIGServer::~XBasicMIGServer(this);
  JUMPOUT(0x1D826BA98);
}

void CADeprecated::XMachServer::AddMachClient(CADeprecated::XMachServer *this, CADeprecated::XMachServer::Client *a2)
{
  CADeprecated::XMachPortDeathListener *v4;
  mach_port_name_t v5;
  ipc_space_t *v6;
  ipc_space_t v7;
  __CFMachPort *PortDeathCFPort;
  mach_port_t Port;
  kern_return_t v10;
  uint64_t v11;
  mach_port_name_t v12;
  uint64_t v13;
  int v14;
  unint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  char *v24;
  uint64_t v25;
  mach_port_t previous;
  uint8_t buf[4];
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  uint64_t v32;
  __int16 v33;
  mach_port_t v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v4 = (CADeprecated::XMachServer *)((char *)this + 80);
  v5 = *((_DWORD *)a2 + 3);
  if (CADeprecated::XMachPortDeathListener::GetPortDeathCFPort((CADeprecated::XMachServer *)((char *)this + 80)))
  {
    previous = 0;
    v6 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
    v7 = *MEMORY[0x1E0C83DA0];
    PortDeathCFPort = CADeprecated::XMachPortDeathListener::GetPortDeathCFPort(v4);
    Port = CFMachPortGetPort(PortDeathCFPort);
    v10 = mach_port_request_notification(v7, v5, 72, 1u, Port, 0x15u, &previous);
    if (v10 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      v11 = (*(uint64_t (**)(CADeprecated::XMachPortDeathListener *))(*(_QWORD *)v4 + 24))(v4);
      *(_DWORD *)buf = 136315906;
      v28 = "XMachServer.cpp";
      v29 = 1024;
      v30 = 103;
      v31 = 2080;
      v32 = v11;
      v33 = 1024;
      v34 = v10;
      _os_log_impl(&dword_1D4E88000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "%25s:%-5d %s: XMachServer couldn't request port-death notification (0x%x)", buf, 0x22u);
    }
    v12 = previous;
    if (previous)
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_INFO))
      {
        v13 = (*(uint64_t (**)(CADeprecated::XMachPortDeathListener *))(*(_QWORD *)v4 + 24))(v4);
        *(_DWORD *)buf = 136315906;
        v28 = "XMachServer.cpp";
        v29 = 1024;
        v30 = 116;
        v31 = 2080;
        v32 = v13;
        v33 = 1024;
        v34 = previous;
        _os_log_impl(&dword_1D4E88000, MEMORY[0x1E0C81028], OS_LOG_TYPE_INFO, "%25s:%-5d %s is deallocating notification port (0x%x) because a new notification port has been registered.", buf, 0x22u);
        v12 = previous;
      }
      mach_port_deallocate(*v6, v12);
    }
  }
  v14 = (*(uint64_t (**)(char *))(*((_QWORD *)this + 14) + 16))((char *)this + 112);
  v16 = (_QWORD *)*((_QWORD *)this + 26);
  v15 = *((_QWORD *)this + 27);
  if ((unint64_t)v16 >= v15)
  {
    v18 = (_QWORD *)*((_QWORD *)this + 25);
    v19 = v16 - v18;
    v20 = v19 + 1;
    if ((unint64_t)(v19 + 1) >> 61)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v21 = v15 - (_QWORD)v18;
    if (v21 >> 2 > v20)
      v20 = v21 >> 2;
    if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF8)
      v22 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v22 = v20;
    if (v22)
    {
      if (v22 >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v23 = (char *)operator new(8 * v22);
    }
    else
    {
      v23 = 0;
    }
    v24 = &v23[8 * v19];
    *(_QWORD *)v24 = a2;
    v17 = v24 + 8;
    if (v16 != v18)
    {
      do
      {
        v25 = *--v16;
        *((_QWORD *)v24 - 1) = v25;
        v24 -= 8;
      }
      while (v16 != v18);
      v16 = (_QWORD *)*((_QWORD *)this + 25);
    }
    *((_QWORD *)this + 25) = v24;
    *((_QWORD *)this + 26) = v17;
    *((_QWORD *)this + 27) = &v23[8 * v22];
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v16 = a2;
    v17 = v16 + 1;
  }
  *((_QWORD *)this + 26) = v17;
  if (v14)
    (*(void (**)(char *))(*((_QWORD *)this + 14) + 24))((char *)this + 112);
}

void sub_1D4E89FDC(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

const char *CAMemoryStream::Write(CAMemoryStream *this, void *a2, const char *a3)
{
  const char *v3;
  uint64_t v6;
  uint64_t v7;
  char *v8;

  v3 = a3;
  if ((int)a3 >= 1)
  {
    v6 = *((_QWORD *)this + 2);
    v7 = v6 + a3;
    if ((unint64_t)(v7 + 1) <= *((_QWORD *)this + 3))
    {
      v8 = (char *)*((_QWORD *)this + 1);
    }
    else
    {
      v8 = (char *)malloc_type_realloc(*((void **)this + 1), (v7 & 0xFFFFFFFFFFFFFF80) + 128, 0xB69AE6F0uLL);
      if (!v8)
      {
        fwrite("realloc failed", 0xEuLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
        return (const char *)0xFFFFFFFFLL;
      }
      *((_QWORD *)this + 1) = v8;
      *((_QWORD *)this + 3) = (v7 & 0xFFFFFFFFFFFFFF80) + 128;
      v6 = *((_QWORD *)this + 2);
    }
    memcpy(&v8[v6], a2, v3);
    *((_QWORD *)this + 2) = v7;
  }
  return v3;
}

void __clang_call_terminate(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

uint64_t MIDICISniffer::clearStateForGroup(uint64_t *a1, unsigned int a2, int a3, char a4)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v9;
  char v10;
  char v11;

  result = a1[8];
  v7 = *a1;
  if (result && a3 != 3 && *(_DWORD *)(v7 + 20 * a2 + 4) == 3)
  {
    v11 = a2;
    v10 = a4;
    result = (*(uint64_t (**)(uint64_t, char *, char *))(*(_QWORD *)result + 48))(result, &v11, &v10);
    v7 = *a1;
  }
  v9 = v7 + 20 * a2;
  *(_DWORD *)(v9 + 15) = 0;
  *(_QWORD *)(v9 + 8) = 0;
  *(_DWORD *)(v9 + 4) = a3;
  return result;
}

void std::__throw_bad_function_call[abi:ne180100]()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
}

void std::bad_function_call::~bad_function_call(std::bad_function_call *this)
{
  std::exception::~exception(this);
  JUMPOUT(0x1D826BA98);
}

void CAException::~CAException(std::exception *this)
{
  std::exception::~exception(this);
  JUMPOUT(0x1D826BA98);
}

const char *CAException::what(CAException *this)
{
  return "CAException";
}

void CAXException::~CAXException(std::exception *this)
{
  std::exception::~exception(this);
  JUMPOUT(0x1D826BA98);
}

uint64_t CAXException::what(CAXException *this)
{
  return (uint64_t)this + 8;
}

uint64_t CADeprecated::XMachServer::GetDebugName(CADeprecated::XMachServer *this)
{
  return *((_QWORD *)this + 1);
}

void *CADeprecated::XMachServer::PortDied(CADeprecated::XMachServer *this, int a2)
{
  _QWORD *v4;
  void *result;
  int v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  v4 = (_QWORD *)((char *)this + 112);
  result = (void *)(*(uint64_t (**)(char *))(*((_QWORD *)this + 14) + 16))((char *)this + 112);
  v6 = (int)result;
  v8 = (uint64_t *)v4[11];
  v7 = (uint64_t *)v4[12];
  while (1)
  {
    if (v8 == v7)
    {
      v9 = 0;
      if (!(_DWORD)result)
        goto LABEL_11;
      goto LABEL_10;
    }
    v9 = *v8;
    if (*(_DWORD *)(*v8 + 12) == a2)
      break;
    ++v8;
  }
  v10 = (char *)v7 - (char *)(v8 + 1);
  if (v7 != v8 + 1)
    result = memmove(v8, v8 + 1, (char *)v7 - (char *)(v8 + 1));
  *((_QWORD *)this + 26) = (char *)v8 + v10;
  if (v6)
LABEL_10:
    result = (void *)(*(uint64_t (**)(_QWORD *))(*v4 + 24))(v4);
LABEL_11:
  if (v9)
    return (void *)(*(uint64_t (**)(CADeprecated::XMachServer *, uint64_t))(*(_QWORD *)this + 32))(this, v9);
  return result;
}

void *`non-virtual thunk to'CADeprecated::XMachServer::PortDied(CADeprecated::XMachServer *this, int a2)
{
  return CADeprecated::XMachServer::PortDied((CADeprecated::XMachServer *)((char *)this - 80), a2);
}

uint64_t `non-virtual thunk to'CADeprecated::XMachServer::GetDebugName(CADeprecated::XMachServer *this)
{
  return *((_QWORD *)this - 9);
}

void std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  std::bad_array_new_length *exception;
  std::bad_array_new_length *v1;

  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  v1 = std::bad_array_new_length::bad_array_new_length(exception);
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
}

void sub_1D4E8A3B8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5020] + 16);
  return result;
}

CFMachPortRef CADeprecated::XMachPortDeathListener::GetPortDeathCFPort(CADeprecated::XMachPortDeathListener *this)
{
  CFMachPortRef result;
  CFMachPortContext v3;
  Boolean shouldFreeInfo;

  result = (CFMachPortRef)*((_QWORD *)this + 2);
  if (!result)
  {
    shouldFreeInfo = 0;
    v3.version = 0;
    v3.info = this;
    memset(&v3.retain, 0, 24);
    result = CFMachPortCreate(0, (CFMachPortCallBack)CADeprecated::XMachPortDeathListener::PortDeathListenerProc, &v3, &shouldFreeInfo);
    *((_QWORD *)this + 2) = result;
  }
  return result;
}

uint64_t CADeprecated::XMachPortDeathListener::PortDeathListenerProc(CADeprecated::XMachPortDeathListener *this, __CFMachPort *a2, void *a3, uint64_t a4, void *a5)
{
  uint64_t v6;
  uint64_t result;

  if (*((_DWORD *)a2 + 5) == 72)
  {
    v6 = *((unsigned int *)a2 + 8);
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], *((_DWORD *)a2 + 8));
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a4 + 16))(a4, v6);
  }
  return result;
}

void CADeprecated::XMachPortDeathListener::~XMachPortDeathListener(CADeprecated::XMachPortDeathListener *this)
{
  const void *v2;
  const void *v3;
  uint64_t v4;

  *(_QWORD *)this = off_1E98B9CB8;
  v2 = (const void *)*((_QWORD *)this + 2);
  if (v2)
    CFRelease(v2);
  v3 = (const void *)*((_QWORD *)this + 3);
  if (v3)
    CFRelease(v3);
  v4 = *((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
}

uint64_t CADeprecated::XMachPortServicer::SetRunLoopAndSource(CADeprecated::XMachPortServicer *this, __CFRunLoop *a2, const __CFString *a3, __CFRunLoopSource *a4)
{
  _QWORD *v8;
  _QWORD *v9;
  const __CFString **v10;
  const __CFString *v11;
  uint64_t result;

  v8 = (_QWORD *)operator new();
  v9 = v8;
  v10 = (const __CFString **)MEMORY[0x1E0C9B280];
  *v8 = &off_1E98B9C98;
  v8[1] = a2;
  v11 = *v10;
  if (a3)
    v11 = a3;
  v8[2] = v11;
  v8[3] = a4;
  CFRetain(a2);
  CFRetain((CFTypeRef)v9[2]);
  CFRetain((CFTypeRef)v9[3]);
  CFRunLoopAddSource((CFRunLoopRef)v9[1], (CFRunLoopSourceRef)v9[3], (CFRunLoopMode)v9[2]);
  result = *(_QWORD *)this;
  *(_QWORD *)this = v9;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void sub_1D4E8A5C4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D826BA98](v1, 0xE1C405CB88AE7);
  _Unwind_Resume(a1);
}

void CADeprecated::XMachPortServicer::RunLoopImpl::~RunLoopImpl(CADeprecated::XMachPortServicer::RunLoopImpl *this)
{
  CADeprecated::XMachPortServicer::RunLoopImpl::~RunLoopImpl(this);
  JUMPOUT(0x1D826BA98);
}

{
  *(_QWORD *)this = &off_1E98B9C98;
  CFRunLoopRemoveSource(*((CFRunLoopRef *)this + 1), *((CFRunLoopSourceRef *)this + 3), *((CFRunLoopMode *)this + 2));
  CFRelease(*((CFTypeRef *)this + 1));
  CFRelease(*((CFTypeRef *)this + 2));
  CFRelease(*((CFTypeRef *)this + 3));
}

unsigned int *CADeprecated::XMachReceivePort::SetMachPort(unsigned int *this, unsigned int a2)
{
  mach_port_name_t v2;
  ipc_space_t *v3;

  do
    v2 = __ldaxr(this);
  while (__stlxr(a2, this));
  if (v2)
  {
    v3 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
    mach_port_mod_refs(*MEMORY[0x1E0C83DA0], v2, 1u, -1);
    return (unsigned int *)mach_port_deallocate(*v3, v2);
  }
  return this;
}

void CADeprecated::XMachPortSendRight::~XMachPortSendRight(mach_port_name_t *this)
{
  if (*this)
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], *this);
}

uint64_t CADeprecated::XMachServer::CreateServerPort(CADeprecated::XMachServer *this, char *a2, int a3, int *a4)
{
  ipc_space_t *v6;
  kern_return_t v7;
  kern_return_t v8;
  uint64_t v9;
  kern_return_t v10;
  char *v11;
  kern_return_t inserted;
  mach_port_t special_port[2];
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  CADeprecated::XMachServer *v20;
  __int16 v21;
  kern_return_t v22;
  __int16 v23;
  char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)special_port = 0;
  v6 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
  v7 = task_get_special_port(*MEMORY[0x1E0C83DA0], 4, special_port);
  if (v7)
  {
    v8 = v7;
    v9 = 0;
    goto LABEL_12;
  }
  v10 = bootstrap_check_in(special_port[0], (const char *)this, &special_port[1]);
  if (!v10)
  {
    inserted = mach_port_insert_right(*v6, special_port[1], special_port[1], 0x14u);
    v9 = special_port[1];
    if (inserted | special_port[1])
    {
LABEL_10:
      v8 = inserted;
      goto LABEL_12;
    }
LABEL_9:
    inserted = mach_port_allocate(*v6, 1u, &special_port[1]);
    v9 = special_port[1];
    if (!inserted)
    {
      v8 = mach_port_insert_right(*v6, special_port[1], special_port[1], 0x14u);
      v9 = special_port[1];
      goto LABEL_12;
    }
    goto LABEL_10;
  }
  v8 = v10;
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    v11 = mach_error_string(v8);
    *(_DWORD *)buf = 136316162;
    v16 = "XMachServer.cpp";
    v17 = 1024;
    v18 = 227;
    v19 = 2080;
    v20 = this;
    v21 = 1024;
    v22 = v8;
    v23 = 2080;
    v24 = v11;
    _os_log_impl(&dword_1D4E88000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d bootstrap_check_in(%s) failed: 0x%x; %s",
      buf,
      0x2Cu);
  }
  v9 = special_port[1];
  if (!special_port[1])
    goto LABEL_9;
LABEL_12:
  *(_DWORD *)a2 = v8;
  return v9;
}

void CAX4CCString::CAX4CCString(CAX4CCString *this, unsigned int a2)
{
  unsigned int v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;

  v4 = bswap32(a2);
  *(_DWORD *)((char *)this + 1) = v4;
  v5 = MEMORY[0x1E0C80978];
  if ((v4 & 0x80) != 0)
  {
    if (!__maskrune((char)v4, 0x40000uLL))
      goto LABEL_17;
  }
  else if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * (char)v4 + 60) & 0x40000) == 0)
  {
    goto LABEL_17;
  }
  v6 = *((char *)this + 2);
  if ((v6 & 0x80000000) != 0)
  {
    if (!__maskrune(v6, 0x40000uLL))
      goto LABEL_17;
  }
  else if ((*(_DWORD *)(v5 + 4 * v6 + 60) & 0x40000) == 0)
  {
    goto LABEL_17;
  }
  v7 = *((char *)this + 3);
  if ((v7 & 0x80000000) != 0)
  {
    if (!__maskrune(v7, 0x40000uLL))
      goto LABEL_17;
LABEL_13:
    v8 = *((char *)this + 4);
    if ((v8 & 0x80000000) != 0)
    {
      if (!__maskrune(v8, 0x40000uLL))
        goto LABEL_17;
    }
    else if ((*(_DWORD *)(v5 + 4 * v8 + 60) & 0x40000) == 0)
    {
      goto LABEL_17;
    }
    *(_WORD *)((char *)this + 5) = 39;
    *(_BYTE *)this = 39;
    return;
  }
  if ((*(_DWORD *)(v5 + 4 * v7 + 60) & 0x40000) != 0)
    goto LABEL_13;
LABEL_17:
  if (a2 + 199999 > 0x61A7E)
    snprintf((char *)this, 0x10uLL, "0x%x");
  else
    snprintf((char *)this, 0x10uLL, "%d");
}

void std::__shared_ptr_emplace<CADeprecated::XMachReceivePort>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E98BA008;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<CADeprecated::XMachReceivePort>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E98BA008;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D826BA98);
}

void sub_1D4E8AEAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21,void *a22,void *a23,void *a24)
{
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;

  _Unwind_Resume(a1);
}

void sub_1D4E8B3A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11)
{
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

void sub_1D4E8B5C0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1D4E8B98C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16)
{
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;

  _Unwind_Resume(a1);
}

void sub_1D4E8BC14(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1D4E8BDC4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1D4E8BE2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1D4E8BEF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  void *v15;
  void *v16;
  void *v17;

  v17 = v16;

  if (a15 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_1D4E8BFEC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void CIProfileBytesToName(uint64_t a1, _BYTE *a2, unint64_t a3)
{
  std::string *v5;
  __int128 v6;
  std::string *v7;
  __int128 v8;
  std::string *v9;
  std::string::size_type size;
  std::string *v11;
  __int128 v12;
  int v13;
  int v14;
  std::string *v15;
  __int128 v16;
  std::string *v17;
  __int128 v18;
  const std::string::value_type *v19;
  std::string::size_type v20;
  std::string *v21;
  __int128 v22;
  std::string *v23;
  std::string::size_type v24;
  std::string *v25;
  __int128 v26;
  std::string *v27;
  __int128 v28;
  std::string *v29;
  std::string::size_type v30;
  std::string *v31;
  __int128 v32;
  std::string *v33;
  __int128 v34;
  std::string *v35;
  std::string::size_type v36;
  std::string *v37;
  __int128 v38;
  std::string *v39;
  __int128 v40;
  std::string *v41;
  std::string::size_type v42;
  std::string *v43;
  std::string::size_type v44;
  int v45;
  void *v46;
  void *v47;
  const std::string::value_type *v48;
  std::string::size_type v49;
  std::string *v50;
  __int128 v51;
  std::string *v52;
  __int128 v53;
  std::string *v54;
  std::string::size_type v55;
  int v56;
  std::string *v57;
  __int128 v58;
  std::string *v59;
  __int128 v60;
  std::string *v61;
  std::string::size_type v62;
  std::string *v63;
  __int128 v64;
  std::string *v65;
  __int128 v66;
  const std::string::value_type *v67;
  std::string::size_type v68;
  std::string *v69;
  std::string::size_type v70;
  int v71;
  std::string *v72;
  std::string::size_type v73;
  int v74;
  std::string *v75;
  std::string::size_type v76;
  std::string *v77;
  __int128 v78;
  const std::string::value_type *v79;
  std::string::size_type v80;
  std::string *v81;
  std::string::size_type v82;
  int v83;
  std::string v84;
  std::string v85;
  std::string v86;
  std::string v87;
  std::string v88;
  std::string v89;
  std::string v90;
  std::string v91;
  std::string v92;
  std::string v93;
  std::string v94;
  std::string v95;
  std::string v96;
  __int128 v97;
  int64_t v98;

  if (a3 <= 4)
  {
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    return;
  }
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  CIProfileBytesToName(std::span<unsigned char const,18446744073709551615ul>)::{lambda(int)#1}::operator()(&v94);
  v5 = std::string::insert(&v94, 0, " Version: ", 0xAuLL);
  v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
  v95.__r_.__value_.__r.__words[2] = v5->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v95.__r_.__value_.__l.__data_ = v6;
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  v7 = std::string::append(&v95, " Level: ", 8uLL);
  v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
  v96.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v96.__r_.__value_.__l.__data_ = v8;
  v7->__r_.__value_.__l.__size_ = 0;
  v7->__r_.__value_.__r.__words[2] = 0;
  v7->__r_.__value_.__r.__words[0] = 0;
  CIProfileBytesToName(std::span<unsigned char const,18446744073709551615ul>)::{lambda(int)#1}::operator()(&v93);
  if ((v93.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v9 = &v93;
  else
    v9 = (std::string *)v93.__r_.__value_.__r.__words[0];
  if ((v93.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v93.__r_.__value_.__r.__words[2]);
  else
    size = v93.__r_.__value_.__l.__size_;
  v11 = std::string::append(&v96, (const std::string::value_type *)v9, size);
  v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  v98 = v11->__r_.__value_.__r.__words[2];
  v97 = v12;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v93.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v93.__r_.__value_.__l.__data_);
  if (SHIBYTE(v96.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v96.__r_.__value_.__l.__data_);
  if (SHIBYTE(v95.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v95.__r_.__value_.__l.__data_);
  if (SHIBYTE(v94.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v94.__r_.__value_.__l.__data_);
  if (*a2 != 126)
  {
    CIProfileBytesToName(std::span<unsigned char const,18446744073709551615ul>)::{lambda(int)#1}::operator()(&v96);
    CIProfileBytesToName(std::span<unsigned char const,18446744073709551615ul>)::{lambda(int)#1}::operator()(&v95);
    CIProfileBytesToName(std::span<unsigned char const,18446744073709551615ul>)::{lambda(int)#1}::operator()(&v94);
    CIProfileBytesToName(std::span<unsigned char const,18446744073709551615ul>)::{lambda(int)#1}::operator()(&v93);
    CIProfileBytesToName(std::span<unsigned char const,18446744073709551615ul>)::{lambda(int)#1}::operator()(&v92);
    std::operator+<char>();
    v21 = std::string::append(&v84, " ", 1uLL);
    v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
    v85.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v85.__r_.__value_.__l.__data_ = v22;
    v21->__r_.__value_.__l.__size_ = 0;
    v21->__r_.__value_.__r.__words[2] = 0;
    v21->__r_.__value_.__r.__words[0] = 0;
    if ((v95.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v23 = &v95;
    else
      v23 = (std::string *)v95.__r_.__value_.__r.__words[0];
    if ((v95.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v24 = HIBYTE(v95.__r_.__value_.__r.__words[2]);
    else
      v24 = v95.__r_.__value_.__l.__size_;
    v25 = std::string::append(&v85, (const std::string::value_type *)v23, v24);
    v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
    v86.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v86.__r_.__value_.__l.__data_ = v26;
    v25->__r_.__value_.__l.__size_ = 0;
    v25->__r_.__value_.__r.__words[2] = 0;
    v25->__r_.__value_.__r.__words[0] = 0;
    v27 = std::string::append(&v86, " ", 1uLL);
    v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
    v87.__r_.__value_.__r.__words[2] = v27->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v87.__r_.__value_.__l.__data_ = v28;
    v27->__r_.__value_.__l.__size_ = 0;
    v27->__r_.__value_.__r.__words[2] = 0;
    v27->__r_.__value_.__r.__words[0] = 0;
    if ((v94.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v29 = &v94;
    else
      v29 = (std::string *)v94.__r_.__value_.__r.__words[0];
    if ((v94.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v30 = HIBYTE(v94.__r_.__value_.__r.__words[2]);
    else
      v30 = v94.__r_.__value_.__l.__size_;
    v31 = std::string::append(&v87, (const std::string::value_type *)v29, v30);
    v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
    v88.__r_.__value_.__r.__words[2] = v31->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v88.__r_.__value_.__l.__data_ = v32;
    v31->__r_.__value_.__l.__size_ = 0;
    v31->__r_.__value_.__r.__words[2] = 0;
    v31->__r_.__value_.__r.__words[0] = 0;
    v33 = std::string::append(&v88, ") Profile ", 0xAuLL);
    v34 = *(_OWORD *)&v33->__r_.__value_.__l.__data_;
    v89.__r_.__value_.__r.__words[2] = v33->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v89.__r_.__value_.__l.__data_ = v34;
    v33->__r_.__value_.__l.__size_ = 0;
    v33->__r_.__value_.__r.__words[2] = 0;
    v33->__r_.__value_.__r.__words[0] = 0;
    if ((v93.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v35 = &v93;
    else
      v35 = (std::string *)v93.__r_.__value_.__r.__words[0];
    if ((v93.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v36 = HIBYTE(v93.__r_.__value_.__r.__words[2]);
    else
      v36 = v93.__r_.__value_.__l.__size_;
    v37 = std::string::append(&v89, (const std::string::value_type *)v35, v36);
    v38 = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
    v90.__r_.__value_.__r.__words[2] = v37->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v90.__r_.__value_.__l.__data_ = v38;
    v37->__r_.__value_.__l.__size_ = 0;
    v37->__r_.__value_.__r.__words[2] = 0;
    v37->__r_.__value_.__r.__words[0] = 0;
    v39 = std::string::append(&v90, " ", 1uLL);
    v40 = *(_OWORD *)&v39->__r_.__value_.__l.__data_;
    v91.__r_.__value_.__r.__words[2] = v39->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v91.__r_.__value_.__l.__data_ = v40;
    v39->__r_.__value_.__l.__size_ = 0;
    v39->__r_.__value_.__r.__words[2] = 0;
    v39->__r_.__value_.__r.__words[0] = 0;
    if ((v92.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v41 = &v92;
    else
      v41 = (std::string *)v92.__r_.__value_.__r.__words[0];
    if ((v92.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v42 = HIBYTE(v92.__r_.__value_.__r.__words[2]);
    else
      v42 = v92.__r_.__value_.__l.__size_;
    v43 = std::string::append(&v91, (const std::string::value_type *)v41, v42);
    v44 = v43->__r_.__value_.__l.__size_;
    *(_QWORD *)a1 = v43->__r_.__value_.__r.__words[0];
    *(_QWORD *)(a1 + 8) = v44;
    *(_QWORD *)(a1 + 15) = *(std::string::size_type *)((char *)&v43->__r_.__value_.__r.__words[1] + 7);
    LOBYTE(v44) = *((_BYTE *)&v43->__r_.__value_.__s + 23);
    v43->__r_.__value_.__l.__size_ = 0;
    v43->__r_.__value_.__r.__words[2] = 0;
    v43->__r_.__value_.__r.__words[0] = 0;
    v45 = SHIBYTE(v91.__r_.__value_.__r.__words[2]);
    *(_BYTE *)(a1 + 23) = v44;
    if (v45 < 0)
      operator delete(v91.__r_.__value_.__l.__data_);
    if (SHIBYTE(v90.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v90.__r_.__value_.__l.__data_);
    if (SHIBYTE(v89.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v89.__r_.__value_.__l.__data_);
    if (SHIBYTE(v88.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v88.__r_.__value_.__l.__data_);
    if (SHIBYTE(v87.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v87.__r_.__value_.__l.__data_);
    if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v86.__r_.__value_.__l.__data_);
    if (SHIBYTE(v85.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v85.__r_.__value_.__l.__data_);
    if (SHIBYTE(v84.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v84.__r_.__value_.__l.__data_);
    if (SHIBYTE(v92.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v92.__r_.__value_.__l.__data_);
    if (SHIBYTE(v93.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v93.__r_.__value_.__l.__data_);
    if (SHIBYTE(v94.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v94.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v95.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_76;
    v46 = (void *)v95.__r_.__value_.__r.__words[0];
    goto LABEL_75;
  }
  v13 = a2[1];
  v14 = a2[2];
  if (v13 != 33)
  {
    if (v13 == 64)
    {
      CIProfileBytesToName(std::span<unsigned char const,18446744073709551615ul>)::{lambda(int)#1}::operator()(&v94);
      v50 = std::string::insert(&v94, 0, "Standard Drawbar Organ Profile ", 0x1FuLL);
      v51 = *(_OWORD *)&v50->__r_.__value_.__l.__data_;
      v95.__r_.__value_.__r.__words[2] = v50->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v95.__r_.__value_.__l.__data_ = v51;
      v50->__r_.__value_.__l.__size_ = 0;
      v50->__r_.__value_.__r.__words[2] = 0;
      v50->__r_.__value_.__r.__words[0] = 0;
      v52 = std::string::append(&v95, ",", 1uLL);
      v53 = *(_OWORD *)&v52->__r_.__value_.__l.__data_;
      v96.__r_.__value_.__r.__words[2] = v52->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v96.__r_.__value_.__l.__data_ = v53;
      v52->__r_.__value_.__l.__size_ = 0;
      v52->__r_.__value_.__r.__words[2] = 0;
      v52->__r_.__value_.__r.__words[0] = 0;
      if (v98 >= 0)
        v19 = (const std::string::value_type *)&v97;
      else
        v19 = (const std::string::value_type *)v97;
      if (v98 >= 0)
        v20 = HIBYTE(v98);
      else
        v20 = *((_QWORD *)&v97 + 1);
    }
    else
    {
      if (v13 != 97)
      {
        CIProfileBytesToName(std::span<unsigned char const,18446744073709551615ul>)::{lambda(int)#1}::operator()(&v92);
        v57 = std::string::insert(&v92, 0, "Standard Profile Bank ", 0x16uLL);
        v58 = *(_OWORD *)&v57->__r_.__value_.__l.__data_;
        v93.__r_.__value_.__r.__words[2] = v57->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v93.__r_.__value_.__l.__data_ = v58;
        v57->__r_.__value_.__l.__size_ = 0;
        v57->__r_.__value_.__r.__words[2] = 0;
        v57->__r_.__value_.__r.__words[0] = 0;
        v59 = std::string::append(&v93, " Number ", 8uLL);
        v60 = *(_OWORD *)&v59->__r_.__value_.__l.__data_;
        v94.__r_.__value_.__r.__words[2] = v59->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v94.__r_.__value_.__l.__data_ = v60;
        v59->__r_.__value_.__l.__size_ = 0;
        v59->__r_.__value_.__r.__words[2] = 0;
        v59->__r_.__value_.__r.__words[0] = 0;
        CIProfileBytesToName(std::span<unsigned char const,18446744073709551615ul>)::{lambda(int)#1}::operator()(&v91);
        if ((v91.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v61 = &v91;
        else
          v61 = (std::string *)v91.__r_.__value_.__r.__words[0];
        if ((v91.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v62 = HIBYTE(v91.__r_.__value_.__r.__words[2]);
        else
          v62 = v91.__r_.__value_.__l.__size_;
        v63 = std::string::append(&v94, (const std::string::value_type *)v61, v62);
        v64 = *(_OWORD *)&v63->__r_.__value_.__l.__data_;
        v95.__r_.__value_.__r.__words[2] = v63->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v95.__r_.__value_.__l.__data_ = v64;
        v63->__r_.__value_.__l.__size_ = 0;
        v63->__r_.__value_.__r.__words[2] = 0;
        v63->__r_.__value_.__r.__words[0] = 0;
        v65 = std::string::append(&v95, ",", 1uLL);
        v66 = *(_OWORD *)&v65->__r_.__value_.__l.__data_;
        v96.__r_.__value_.__r.__words[2] = v65->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v96.__r_.__value_.__l.__data_ = v66;
        v65->__r_.__value_.__l.__size_ = 0;
        v65->__r_.__value_.__r.__words[2] = 0;
        v65->__r_.__value_.__r.__words[0] = 0;
        if (v98 >= 0)
          v67 = (const std::string::value_type *)&v97;
        else
          v67 = (const std::string::value_type *)v97;
        if (v98 >= 0)
          v68 = HIBYTE(v98);
        else
          v68 = *((_QWORD *)&v97 + 1);
        v69 = std::string::append(&v96, v67, v68);
        v70 = v69->__r_.__value_.__l.__size_;
        *(_QWORD *)a1 = v69->__r_.__value_.__r.__words[0];
        *(_QWORD *)(a1 + 8) = v70;
        *(_QWORD *)(a1 + 15) = *(std::string::size_type *)((char *)&v69->__r_.__value_.__r.__words[1] + 7);
        LOBYTE(v70) = *((_BYTE *)&v69->__r_.__value_.__s + 23);
        v69->__r_.__value_.__l.__size_ = 0;
        v69->__r_.__value_.__r.__words[2] = 0;
        v69->__r_.__value_.__r.__words[0] = 0;
        v71 = SHIBYTE(v96.__r_.__value_.__r.__words[2]);
        *(_BYTE *)(a1 + 23) = v70;
        if (v71 < 0)
          operator delete(v96.__r_.__value_.__l.__data_);
        if (SHIBYTE(v95.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v95.__r_.__value_.__l.__data_);
        if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v91.__r_.__value_.__l.__data_);
        if (SHIBYTE(v94.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v94.__r_.__value_.__l.__data_);
        if (SHIBYTE(v93.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v93.__r_.__value_.__l.__data_);
        if ((SHIBYTE(v92.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_125;
        v47 = (void *)v92.__r_.__value_.__r.__words[0];
LABEL_124:
        operator delete(v47);
        goto LABEL_125;
      }
      CIProfileBytesToName(std::span<unsigned char const,18446744073709551615ul>)::{lambda(int)#1}::operator()(&v94);
      v15 = std::string::insert(&v94, 0, "Standard Rotary Effect ", 0x17uLL);
      v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
      v95.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v95.__r_.__value_.__l.__data_ = v16;
      v15->__r_.__value_.__l.__size_ = 0;
      v15->__r_.__value_.__r.__words[2] = 0;
      v15->__r_.__value_.__r.__words[0] = 0;
      v17 = std::string::append(&v95, ",", 1uLL);
      v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
      v96.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v96.__r_.__value_.__l.__data_ = v18;
      v17->__r_.__value_.__l.__size_ = 0;
      v17->__r_.__value_.__r.__words[2] = 0;
      v17->__r_.__value_.__r.__words[0] = 0;
      if (v98 >= 0)
        v19 = (const std::string::value_type *)&v97;
      else
        v19 = (const std::string::value_type *)v97;
      if (v98 >= 0)
        v20 = HIBYTE(v98);
      else
        v20 = *((_QWORD *)&v97 + 1);
    }
    v54 = std::string::append(&v96, v19, v20);
    v55 = v54->__r_.__value_.__l.__size_;
    *(_QWORD *)a1 = v54->__r_.__value_.__r.__words[0];
    *(_QWORD *)(a1 + 8) = v55;
    *(_QWORD *)(a1 + 15) = *(std::string::size_type *)((char *)&v54->__r_.__value_.__r.__words[1] + 7);
    LOBYTE(v55) = *((_BYTE *)&v54->__r_.__value_.__s + 23);
    v54->__r_.__value_.__l.__size_ = 0;
    v54->__r_.__value_.__r.__words[2] = 0;
    v54->__r_.__value_.__r.__words[0] = 0;
    v56 = SHIBYTE(v96.__r_.__value_.__r.__words[2]);
    *(_BYTE *)(a1 + 23) = v55;
    if (v56 < 0)
      operator delete(v96.__r_.__value_.__l.__data_);
    if (SHIBYTE(v95.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v95.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v94.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_125;
    v47 = (void *)v94.__r_.__value_.__r.__words[0];
    goto LABEL_124;
  }
  if (v14)
  {
    std::string::basic_string[abi:ne180100]<0>(&v96, "General MIDI 1 / General MIDI 2");
    switch(v14)
    {
      case 1:
        std::operator+<char>();
        std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&v95, &v94, " Profile,");
        if (v98 >= 0)
          v48 = (const std::string::value_type *)&v97;
        else
          v48 = (const std::string::value_type *)v97;
        if (v98 >= 0)
          v49 = HIBYTE(v98);
        else
          v49 = *((_QWORD *)&v97 + 1);
        break;
      case 2:
        std::operator+<char>();
        std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&v95, &v94, " Single Channel Profile,");
        if (v98 >= 0)
          v48 = (const std::string::value_type *)&v97;
        else
          v48 = (const std::string::value_type *)v97;
        if (v98 >= 0)
          v49 = HIBYTE(v98);
        else
          v49 = *((_QWORD *)&v97 + 1);
        break;
      case 3:
        std::operator+<char>();
        std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&v95, &v94, " Drum Map Profile,");
        if (v98 >= 0)
          v48 = (const std::string::value_type *)&v97;
        else
          v48 = (const std::string::value_type *)v97;
        if (v98 >= 0)
          v49 = HIBYTE(v98);
        else
          v49 = *((_QWORD *)&v97 + 1);
        break;
      default:
        std::operator+<char>();
        std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&v93, &v92, " Profile ");
        CIProfileBytesToName(std::span<unsigned char const,18446744073709551615ul>)::{lambda(int)#1}::operator()(&v91);
        if ((v91.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v75 = &v91;
        else
          v75 = (std::string *)v91.__r_.__value_.__r.__words[0];
        if ((v91.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v76 = HIBYTE(v91.__r_.__value_.__r.__words[2]);
        else
          v76 = v91.__r_.__value_.__l.__size_;
        v77 = std::string::append(&v93, (const std::string::value_type *)v75, v76);
        v78 = *(_OWORD *)&v77->__r_.__value_.__l.__data_;
        v94.__r_.__value_.__r.__words[2] = v77->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v94.__r_.__value_.__l.__data_ = v78;
        v77->__r_.__value_.__l.__size_ = 0;
        v77->__r_.__value_.__r.__words[2] = 0;
        v77->__r_.__value_.__r.__words[0] = 0;
        std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&v95, &v94, ",");
        if (v98 >= 0)
          v79 = (const std::string::value_type *)&v97;
        else
          v79 = (const std::string::value_type *)v97;
        if (v98 >= 0)
          v80 = HIBYTE(v98);
        else
          v80 = *((_QWORD *)&v97 + 1);
        v81 = std::string::append(&v95, v79, v80);
        v82 = v81->__r_.__value_.__l.__size_;
        *(_QWORD *)a1 = v81->__r_.__value_.__r.__words[0];
        *(_QWORD *)(a1 + 8) = v82;
        *(_QWORD *)(a1 + 15) = *(std::string::size_type *)((char *)&v81->__r_.__value_.__r.__words[1] + 7);
        LOBYTE(v82) = *((_BYTE *)&v81->__r_.__value_.__s + 23);
        v81->__r_.__value_.__l.__size_ = 0;
        v81->__r_.__value_.__r.__words[2] = 0;
        v81->__r_.__value_.__r.__words[0] = 0;
        v83 = SHIBYTE(v95.__r_.__value_.__r.__words[2]);
        *(_BYTE *)(a1 + 23) = v82;
        if (v83 < 0)
          operator delete(v95.__r_.__value_.__l.__data_);
        if (SHIBYTE(v94.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v94.__r_.__value_.__l.__data_);
        if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v91.__r_.__value_.__l.__data_);
        if (SHIBYTE(v93.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v93.__r_.__value_.__l.__data_);
        if ((SHIBYTE(v92.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_76;
        v46 = (void *)v92.__r_.__value_.__r.__words[0];
        goto LABEL_75;
    }
    v72 = std::string::append(&v95, v48, v49);
    v73 = v72->__r_.__value_.__l.__size_;
    *(_QWORD *)a1 = v72->__r_.__value_.__r.__words[0];
    *(_QWORD *)(a1 + 8) = v73;
    *(_QWORD *)(a1 + 15) = *(std::string::size_type *)((char *)&v72->__r_.__value_.__r.__words[1] + 7);
    LOBYTE(v73) = *((_BYTE *)&v72->__r_.__value_.__s + 23);
    v72->__r_.__value_.__l.__size_ = 0;
    v72->__r_.__value_.__r.__words[2] = 0;
    v72->__r_.__value_.__r.__words[0] = 0;
    v74 = SHIBYTE(v95.__r_.__value_.__r.__words[2]);
    *(_BYTE *)(a1 + 23) = v73;
    if (v74 < 0)
      operator delete(v95.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v94.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_76;
    v46 = (void *)v94.__r_.__value_.__r.__words[0];
LABEL_75:
    operator delete(v46);
LABEL_76:
    if ((SHIBYTE(v96.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_125;
    v47 = (void *)v96.__r_.__value_.__r.__words[0];
    goto LABEL_124;
  }
  std::operator+<char>();
  *(std::string *)a1 = v96;
LABEL_125:
  if (SHIBYTE(v98) < 0)
    operator delete((void *)v97);
}

void sub_1D4E8CA10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,uint64_t a50,void *a51,uint64_t a52,int a53,__int16 a54,char a55,char a56,uint64_t a57,void *__p,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  uint64_t v63;

  if (*(char *)(v63 - 121) < 0)
    operator delete(*(void **)(v63 - 144));
  if (*(char *)(v63 - 153) < 0)
    operator delete(*(void **)(v63 - 176));
  if (a63 < 0)
    operator delete(__p);
  if (*(char *)(v63 - 185) < 0)
    operator delete(*(void **)(v63 - 208));
  if (*(char *)(v63 - 209) < 0)
    operator delete(*(void **)(v63 - 232));
  if (*(char *)(v63 - 89) < 0)
    operator delete(*(void **)(v63 - 112));
  if (*(char *)(v63 - 57) < 0)
    operator delete(*(void **)(v63 - 80));
  _Unwind_Resume(exception_object);
}

void sub_1D4E8CD70()
{
  JUMPOUT(0x1D4E8CD68);
}

uint64_t CIProfileBytesToName(std::span<unsigned char const,18446744073709551615ul>)::{lambda(int)#1}::operator()(_BYTE *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  std::ios_base *v7;
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  unint64_t v11;
  const void *v12;
  uint64_t v13;
  uint64_t v14;
  _BYTE *v15;
  uint64_t v17;
  uint64_t v18;
  _QWORD v19[4];
  unint64_t v20;
  void *__p[2];
  __int128 v22;
  int v23;
  uint64_t v24[19];

  v2 = MEMORY[0x1E0DE4FE0];
  v3 = MEMORY[0x1E0DE4FE0] + 64;
  v4 = (uint64_t *)MEMORY[0x1E0DE4F60];
  v5 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 8);
  v6 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 16);
  v24[0] = MEMORY[0x1E0DE4FE0] + 64;
  v17 = v5;
  *(uint64_t *)((char *)&v17 + *(_QWORD *)(v5 - 24)) = v6;
  v7 = (std::ios_base *)((char *)&v17 + *(_QWORD *)(v17 - 24));
  std::ios_base::init(v7, &v18);
  v7[1].__vftable = 0;
  v7[1].__fmtflags_ = -1;
  v17 = v2 + 24;
  v24[0] = v3;
  std::streambuf::basic_streambuf();
  v8 = MEMORY[0x1E0DE4FB8];
  v18 = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)__p = 0u;
  v22 = 0u;
  v23 = 16;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v17, (uint64_t)"0x", 2);
  v9 = v17;
  *(_DWORD *)((char *)&v17 + *(_QWORD *)(v17 - 24) + 8) = *(_DWORD *)((_BYTE *)&v17 + *(_QWORD *)(v17 - 24) + 8) & 0xFFFFFFB5 | 8;
  *(_QWORD *)((char *)v19 + *(_QWORD *)(v9 - 24)) = 2;
  std::operator<<[abi:ne180100]<std::char_traits<char>>(&v17, 48);
  std::ostream::operator<<();
  if ((v23 & 0x10) != 0)
  {
    v11 = *((_QWORD *)&v22 + 1);
    if (*((_QWORD *)&v22 + 1) < v20)
    {
      *((_QWORD *)&v22 + 1) = v20;
      v11 = v20;
    }
    v12 = (const void *)v19[3];
  }
  else
  {
    if ((v23 & 8) == 0)
    {
      v10 = 0;
      a1[23] = 0;
      goto LABEL_16;
    }
    v12 = (const void *)v19[0];
    v11 = v19[2];
  }
  v10 = v11 - (_QWORD)v12;
  if (v11 - (unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (v10 >= 0x17)
  {
    v13 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v10 | 7) != 0x17)
      v13 = v10 | 7;
    v14 = v13 + 1;
    v15 = operator new(v13 + 1);
    *((_QWORD *)a1 + 1) = v10;
    *((_QWORD *)a1 + 2) = v14 | 0x8000000000000000;
    *(_QWORD *)a1 = v15;
    a1 = v15;
    goto LABEL_15;
  }
  a1[23] = v10;
  if (v10)
LABEL_15:
    memmove(a1, v12, v10);
LABEL_16:
  a1[v10] = 0;
  v17 = *v4;
  *(uint64_t *)((char *)&v17 + *(_QWORD *)(v17 - 24)) = v4[3];
  v18 = v8 + 16;
  if (SBYTE7(v22) < 0)
    operator delete(__p[0]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1D826BA14](v24);
}

void sub_1D4E8CFA8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::ostream::~ostream();
  MEMORY[0x1D826BA14](v1);
  _Unwind_Resume(a1);
}

_QWORD *std::string::basic_string[abi:ne180100]<0>(_QWORD *a1, char *__s)
{
  size_t v4;
  size_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v5 = v4;
  if (v4 >= 0x17)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((_BYTE *)a1 + 23) = v4;
    v6 = a1;
    if (!v4)
      goto LABEL_9;
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((_BYTE *)v6 + v5) = 0;
  return a1;
}

__n128 std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(std::string *a1, std::string *a2, char *__s)
{
  size_t v6;
  __n128 *v7;
  __n128 result;

  v6 = strlen(__s);
  v7 = (__n128 *)std::string::append(a2, __s, v6);
  result = *v7;
  *a1 = *(std::string *)v7->n128_u8;
  v7->n128_u64[0] = 0;
  v7->n128_u64[1] = 0;
  v7[1].n128_u64[0] = 0;
  return result;
}

void std::string::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("basic_string");
}

uint64_t std::string::basic_string[abi:ne180100](uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  void *v6;

  if (a2 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (a2 > 0x16)
  {
    v4 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a2 | 7) != 0x17)
      v4 = a2 | 7;
    v5 = v4 + 1;
    v6 = operator new(v4 + 1);
    *(_QWORD *)(a1 + 8) = a2;
    *(_QWORD *)(a1 + 16) = v5 | 0x8000000000000000;
    *(_QWORD *)a1 = v6;
  }
  else
  {
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    *(_BYTE *)(a1 + 23) = a2;
  }
  return a1;
}

std::logic_error *std::out_of_range::out_of_range[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
  return result;
}

_QWORD *std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  char *v6;
  uint64_t v7;
  int v8;
  int v9;
  const std::locale::facet *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  int64_t v16;
  std::locale *v17;
  uint64_t v18;
  _BYTE v20[16];
  std::locale __b;
  char v22;

  MEMORY[0x1D826B8AC](v20, a1);
  if (v20[0])
  {
    v6 = (char *)a1 + *(_QWORD *)(*a1 - 24);
    v7 = *((_QWORD *)v6 + 5);
    v8 = *((_DWORD *)v6 + 2);
    v9 = *((_DWORD *)v6 + 36);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)));
      v10 = std::locale::use_facet(&__b, MEMORY[0x1E0DE4A90]);
      v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&__b);
      *((_DWORD *)v6 + 36) = v9;
    }
    v11 = a2 + a3;
    if ((v8 & 0xB0) == 0x20)
      v12 = a2 + a3;
    else
      v12 = a2;
    if (!v7)
      goto LABEL_23;
    v13 = *((_QWORD *)v6 + 3);
    v14 = v13 <= a3;
    v15 = v13 - a3;
    v16 = v14 ? 0 : v15;
    if (v12 - a2 >= 1
      && (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7 + 96))(v7, a2, v12 - a2) != v12 - a2)
    {
      goto LABEL_23;
    }
    if (v16 >= 1)
    {
      std::string::basic_string[abi:ne180100](&__b, v16, (char)v9);
      v17 = v22 >= 0 ? &__b : (std::locale *)__b.__locale_;
      v18 = (*(uint64_t (**)(uint64_t, std::locale *, int64_t))(*(_QWORD *)v7 + 96))(v7, v17, v16);
      if (v22 < 0)
        operator delete(__b.__locale_);
      if (v18 != v16)
        goto LABEL_23;
    }
    if (v11 - v12 < 1
      || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7 + 96))(v7, v12, v11 - v12) == v11 - v12)
    {
      *((_QWORD *)v6 + 3) = 0;
    }
    else
    {
LABEL_23:
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | 5);
    }
  }
  MEMORY[0x1D826B8B8](v20);
  return a1;
}

void sub_1D4E8D368(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  _QWORD *v17;

  if (a17 < 0)
    operator delete(__p);
  MEMORY[0x1D826B8B8](&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v17 + *(_QWORD *)(*v17 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x1D4E8D344);
}

void sub_1D4E8D3C8(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

_QWORD *std::operator<<[abi:ne180100]<std::char_traits<char>>(_QWORD *a1, char a2)
{
  char *v4;
  const std::locale::facet *v5;
  int v6;
  std::locale v8;

  v4 = (char *)a1 + *(_QWORD *)(*a1 - 24);
  if (*((_DWORD *)v4 + 36) == -1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)));
    v5 = std::locale::use_facet(&v8, MEMORY[0x1E0DE4A90]);
    v6 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v5->__vftable[2].~facet_0)(v5, 32);
    std::locale::~locale(&v8);
    *((_DWORD *)v4 + 36) = v6;
  }
  *((_DWORD *)v4 + 36) = a2;
  return a1;
}

void sub_1D4E8D46C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  std::locale::~locale(&a10);
  _Unwind_Resume(a1);
}

uint64_t std::ostringstream::~ostringstream(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = MEMORY[0x1E0DE4F60];
  v3 = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)a1 = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)(a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 24);
  *(_QWORD *)(a1 + 8) = MEMORY[0x1E0DE4FB8] + 16;
  if (*(char *)(a1 + 95) < 0)
    operator delete(*(void **)(a1 + 72));
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1D826BA14](a1 + 112);
  return a1;
}

_QWORD *std::string::basic_string[abi:ne180100](_QWORD *__b, size_t __len, int __c)
{
  void *v6;
  size_t v7;
  size_t v8;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (__len >= 0x17)
  {
    v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v7 = __len | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *__b = v6;
  }
  else
  {
    *((_BYTE *)__b + 23) = __len;
    v6 = __b;
    if (!__len)
      goto LABEL_9;
  }
  memset(v6, __c, __len);
LABEL_9:
  *((_BYTE *)v6 + __len) = 0;
  return __b;
}

void MIDIMachServer::~MIDIMachServer(MIDIMachServer *this)
{
  CADeprecated::XMachPortDeathListener *v2;
  void *v3;

  *(_QWORD *)this = off_1E98B9BC8;
  *((_QWORD *)this + 10) = &unk_1E98B9C10;
  v2 = (MIDIMachServer *)((char *)this + 80);
  v3 = (void *)*((_QWORD *)this + 25);
  if (v3)
  {
    *((_QWORD *)this + 26) = v3;
    operator delete(v3);
  }
  *((_QWORD *)this + 14) = &off_1E98B9D98;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 136));
  CADeprecated::XMachPortDeathListener::~XMachPortDeathListener(v2);
  CADeprecated::XBasicMIGServer::~XBasicMIGServer(this);
}

{
  CADeprecated::XMachPortDeathListener *v2;
  void *v3;

  *(_QWORD *)this = off_1E98B9BC8;
  *((_QWORD *)this + 10) = &unk_1E98B9C10;
  v2 = (MIDIMachServer *)((char *)this + 80);
  v3 = (void *)*((_QWORD *)this + 25);
  if (v3)
  {
    *((_QWORD *)this + 26) = v3;
    operator delete(v3);
  }
  *((_QWORD *)this + 14) = &off_1E98B9D98;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 136));
  CADeprecated::XMachPortDeathListener::~XMachPortDeathListener(v2);
  CADeprecated::XBasicMIGServer::~XBasicMIGServer(this);
  JUMPOUT(0x1D826BA98);
}

void MIDIMachServer::ClientDied(MIDIMachServer *this, CADeprecated::XMachServer::Client *a2)
{
  ClientProcess *v3;
  MIDIServer *v4;

  getMIDIServer(this);
  if (a2)
    v4 = (CADeprecated::XMachServer::Client *)((char *)a2 + 16);
  else
    v4 = 0;
  MIDIServer::ClientDied(v4, v3);
}

void `non-virtual thunk to'MIDIMachServer::~MIDIMachServer(MIDIMachServer *this)
{
  CADeprecated::XBasicMIGServer *v2;
  void *v3;

  *((_QWORD *)this - 10) = off_1E98B9BC8;
  v2 = (MIDIMachServer *)((char *)this - 80);
  *(_QWORD *)this = &unk_1E98B9C10;
  v3 = (void *)*((_QWORD *)this + 15);
  if (v3)
  {
    *((_QWORD *)this + 16) = v3;
    operator delete(v3);
  }
  *((_QWORD *)this + 4) = &off_1E98B9D98;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 56));
  CADeprecated::XMachPortDeathListener::~XMachPortDeathListener(this);
  CADeprecated::XBasicMIGServer::~XBasicMIGServer(v2);
}

{
  CADeprecated::XBasicMIGServer *v2;
  void *v3;

  *((_QWORD *)this - 10) = off_1E98B9BC8;
  v2 = (MIDIMachServer *)((char *)this - 80);
  *(_QWORD *)this = &unk_1E98B9C10;
  v3 = (void *)*((_QWORD *)this + 15);
  if (v3)
  {
    *((_QWORD *)this + 16) = v3;
    operator delete(v3);
  }
  *((_QWORD *)this + 4) = &off_1E98B9D98;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 56));
  CADeprecated::XMachPortDeathListener::~XMachPortDeathListener(this);
  CADeprecated::XBasicMIGServer::~XBasicMIGServer(v2);
  JUMPOUT(0x1D826BA98);
}

uint64_t getMIDIServer(MIDIServer *a1)
{
  uint64_t *v1;
  uint64_t result;

  v1 = MIDIServer::defaultInstance(a1);
  result = (*(uint64_t (**)(uint64_t *))(*v1 + 16))(v1);
  if (!result)
    std::terminate();
  return result;
}

void MIDIServer_RegisterProcess(MIDIServer *a1, int a2, mach_port_name_t a3, int a4)
{
  uint64_t MIDIServer;
  __int128 v9;
  pid_t v10;
  ClientProcess **i;
  uint64_t v12;
  NSObject *v13;
  int v14;
  pid_t pidp[2];
  _BYTE atoken[34];
  __int16 v17;
  pid_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  MIDIServer = getMIDIServer(a1);
  v9 = *((_OWORD *)a1 + 1);
  *(_OWORD *)atoken = *(_OWORD *)a1;
  *(_OWORD *)&atoken[16] = v9;
  *(_QWORD *)pidp = 0;
  audit_token_to_au32((audit_token_t *)atoken, 0, (uid_t *)&pidp[1], 0, 0, 0, pidp, 0, 0);
  v10 = pidp[0];
  for (i = *(ClientProcess ***)(MIDIServer + 232); i != *(ClientProcess ***)(MIDIServer + 240); ++i)
  {
    if (*((_DWORD *)*i + 2) == pidp[0])
    {
      ClientTable::ProcessQuit((ClientTable *)(MIDIServer + 192), *i);
      break;
    }
  }
  v12 = operator new();
  BaseOpaqueObject::BaseOpaqueObject((BaseOpaqueObject *)v12);
  *(_DWORD *)(v12 + 12) = a2;
  *(_QWORD *)(v12 + 16) = &unk_1E98B80D0;
  *(_DWORD *)(v12 + 24) = v10;
  *(_BYTE *)(v12 + 29) = 0;
  *(_BYTE *)(v12 + 32) = 0;
  *(_BYTE *)(v12 + 36) = 0;
  *(_BYTE *)(v12 + 40) = 0;
  *(_BYTE *)(v12 + 192) = 0;
  *(_BYTE *)(v12 + 200) = 0;
  *(_BYTE *)(v12 + 304) = 0;
  *(_QWORD *)(v12 + 312) = v12 + 312;
  *(_QWORD *)(v12 + 320) = v12 + 312;
  *(_QWORD *)(v12 + 328) = 0;
  *(_BYTE *)(v12 + 336) = 0;
  *(_QWORD *)v12 = &off_1E98B8088;
  ClientProcess::setupIO((mach_port_name_t *)(v12 + 16), a3, a4 != 0);
  gServerClientProcessLog();
  v13 = gServerClientProcessLog(void)::cliprc;
  if (os_log_type_enabled((os_log_t)gServerClientProcessLog(void)::cliprc, OS_LOG_TYPE_DEBUG))
  {
    v14 = *(_DWORD *)(v12 + 8);
    *(_DWORD *)atoken = 136316162;
    *(_QWORD *)&atoken[4] = "ClientProcess.cpp";
    *(_WORD *)&atoken[12] = 1024;
    *(_DWORD *)&atoken[14] = 230;
    *(_WORD *)&atoken[18] = 2048;
    *(_QWORD *)&atoken[20] = v12;
    *(_WORD *)&atoken[28] = 1024;
    *(_DWORD *)&atoken[30] = v14;
    v17 = 1024;
    v18 = v10;
    _os_log_impl(&dword_1D4E88000, v13, OS_LOG_TYPE_DEBUG, "%25s:%-5d ClientProcess object %p (opaque ref 0x%x) for pid %d", atoken, 0x28u);
  }
  (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(MIDIServer + 928) + 16))(*(_QWORD *)(MIDIServer + 928), v12);
  ClientTable::AddProcess((ClientTable *)(MIDIServer + 192), (ClientProcess *)(v12 + 16));
  BackgroundAppManager::Update((BackgroundAppManager *)(MIDIServer + 912));
}

void sub_1D4E8D9EC(_Unwind_Exception *a1)
{
  BaseOpaqueObject *v1;
  ClientProcess *v2;
  mach_port_name_t *v3;

  ClientProcess::~ClientProcess(v2);
  *(_QWORD *)v1 = &off_1E98B9B98;
  CADeprecated::XMachPortSendRight::~XMachPortSendRight(v3);
  BaseOpaqueObject::~BaseOpaqueObject(v1);
  MEMORY[0x1D826BA98](v1, 0x10B3C40A895F4ADLL);
  _Unwind_Resume(a1);
}

void ClientTable::AddProcess(ClientTable *this, ClientProcess *a2)
{
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  uint64_t v14;

  v5 = (_QWORD *)*((_QWORD *)this + 6);
  v4 = *((_QWORD *)this + 7);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)this + 5);
    v8 = v5 - v7;
    v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v10 = v4 - (_QWORD)v7;
    if (v10 >> 2 > v9)
      v9 = v10 >> 2;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v9;
    if (v11)
    {
      if (v11 >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v12 = (char *)operator new(8 * v11);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    *(_QWORD *)v13 = a2;
    v6 = v13 + 8;
    if (v5 != v7)
    {
      do
      {
        v14 = *--v5;
        *((_QWORD *)v13 - 1) = v14;
        v13 -= 8;
      }
      while (v5 != v7);
      v5 = (_QWORD *)*((_QWORD *)this + 5);
    }
    *((_QWORD *)this + 5) = v13;
    *((_QWORD *)this + 6) = v6;
    *((_QWORD *)this + 7) = &v12[8 * v11];
    if (v5)
      operator delete(v5);
  }
  else
  {
    *v5 = a2;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 6) = v6;
  ClientTable::CheckActiveProcesses(this);
}

void IPCBufferReader::~IPCBufferReader(IPCBufferReader *this)
{
  const void *v2;

  v2 = (const void *)*((_QWORD *)this + 2);
  if (v2)
    CFRelease(v2);
  if (*(_QWORD *)this)
  {
    if ((*((_BYTE *)this + 12) & 1) != 0)
      MEMORY[0x1D826C41C](*MEMORY[0x1E0C83DA0]);
  }
}

uint64_t IPCBufferWriter::write(IPCBufferWriter *this, CFStringRef theString, void **a3, unsigned int *a4)
{
  CFIndex Length;
  uint64_t Buffer;
  CFIndex usedBufLen;
  CFRange v12;
  CFRange v13;

  if (!theString)
    return 4294967246;
  Length = CFStringGetLength(theString);
  usedBufLen = 0;
  v12.location = 0;
  v12.length = Length;
  CFStringGetBytes(theString, v12, 0x100u, 0, 1u, 0, 0, &usedBufLen);
  Buffer = IPCBufferWriter::AllocateBuffer((vm_address_t *)this, usedBufLen);
  if ((_DWORD)Buffer)
  {
    if (!a3)
      goto LABEL_5;
    goto LABEL_4;
  }
  v13.location = 0;
  v13.length = Length;
  CFStringGetBytes(theString, v13, 0x100u, 0, 1u, *((UInt8 **)this + 1), *((unsigned int *)this + 4), &usedBufLen);
  if (a3)
LABEL_4:
    *a3 = (void *)*((_QWORD *)this + 1);
LABEL_5:
  if (a4)
    *a4 = *((_DWORD *)this + 4);
  return Buffer;
}

void IPCBufferWriter::~IPCBufferWriter(void **this)
{
  if (this[1])
  {
    if ((*(_DWORD *)this & 1) != 0)
    {
      if ((*(_DWORD *)this & 2) != 0)
        MEMORY[0x1D826C41C](*MEMORY[0x1E0C83DA0]);
    }
    else
    {
      free(this[1]);
    }
  }
}

uint64_t IPCBufferWriter::AllocateBuffer(vm_address_t *this, vm_size_t size)
{
  int v2;
  void *v4;
  uint64_t result;

  v2 = size;
  if ((*(_BYTE *)this & 1) != 0)
  {
    result = vm_allocate(*MEMORY[0x1E0C83DA0], this + 1, size, 1);
  }
  else
  {
    v4 = malloc_type_malloc(size, 0x55F4B235uLL);
    result = 0;
    this[1] = (vm_address_t)v4;
  }
  *((_DWORD *)this + 4) = v2;
  return result;
}

uint64_t MIDIServer_ObjectSetStringProperty(MIDIServer *a1, const UInt8 *a2, CFIndex numBytes, UInt8 *a4, unsigned int a5)
{
  uint64_t v8;
  UInt8 *bytes;
  CFIndex numBytesa;
  CFStringRef v12;
  const UInt8 *v13;
  int v14;
  int v15;
  const __CFString *v16;

  v13 = a2;
  v14 = numBytes;
  v15 = 0;
  bytes = a4;
  numBytesa = a5;
  v16 = CFStringCreateWithBytes(0, a2, numBytes, 0x100u, 1u);
  v12 = CFStringCreateWithBytes(0, bytes, numBytesa, 0x100u, 1u);
  v8 = _MIDIObjectSetStringProperty(a1, v16, (uint64_t)v12);
  if (!(_DWORD)v8)
    MEMORY[0x1D826C41C](*MEMORY[0x1E0C83DA0], a4, a5);
  IPCBufferReader::~IPCBufferReader((IPCBufferReader *)&bytes);
  IPCBufferReader::~IPCBufferReader((IPCBufferReader *)&v13);
  return v8;
}

void sub_1D4E8DDF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  IPCBufferReader::~IPCBufferReader((IPCBufferReader *)&a9);
  IPCBufferReader::~IPCBufferReader((IPCBufferReader *)&a12);
  _Unwind_Resume(a1);
}

uint64_t IPCBufferWriter::write(IPCBufferWriter *this, CFDataRef theData, void **a3, unsigned int *a4)
{
  vm_size_t Length;
  unsigned int v9;
  uint64_t Buffer;
  CFRange v12;

  if (!theData)
    return 4294967246;
  Length = CFDataGetLength(theData);
  v9 = Length;
  Buffer = IPCBufferWriter::AllocateBuffer((vm_address_t *)this, Length);
  if ((_DWORD)Buffer)
  {
    if (!a3)
      goto LABEL_5;
    goto LABEL_4;
  }
  v12.length = v9;
  v12.location = 0;
  CFDataGetBytes(theData, v12, *((UInt8 **)this + 1));
  if (a3)
LABEL_4:
    *a3 = (void *)*((_QWORD *)this + 1);
LABEL_5:
  if (a4)
    *a4 = *((_DWORD *)this + 4);
  return Buffer;
}

uint64_t MIDIServer_ObjectSetDataProperty(MIDIServer *a1, const UInt8 *a2, CFIndex numBytes, const UInt8 *a4, unsigned int a5)
{
  uint64_t v8;
  const UInt8 *v10;
  unsigned int v11;
  int v12;
  CFDataRef v13;
  const UInt8 *v14;
  int v15;
  int v16;
  const __CFString *v17;

  v14 = a2;
  v15 = numBytes;
  v16 = 0;
  v17 = CFStringCreateWithBytes(0, a2, numBytes, 0x100u, 1u);
  v10 = a4;
  v11 = a5;
  v12 = 0;
  v13 = CFDataCreate(0, a4, a5);
  v8 = _MIDIObjectSetDataProperty(a1, v17, (uint64_t)v13);
  if (!(_DWORD)v8)
    MEMORY[0x1D826C41C](*MEMORY[0x1E0C83DA0], a4, a5);
  IPCBufferReader::~IPCBufferReader((IPCBufferReader *)&v10);
  IPCBufferReader::~IPCBufferReader((IPCBufferReader *)&v14);
  return v8;
}

void sub_1D4E8DF78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  IPCBufferReader::~IPCBufferReader((IPCBufferReader *)&a9);
  IPCBufferReader::~IPCBufferReader((IPCBufferReader *)&a12);
  _Unwind_Resume(a1);
}

uint64_t IPCBufferWriter::write(IPCBufferWriter *this, const void *a2, void **a3, unsigned int *a4)
{
  const __CFData *Data;
  uint64_t v8;

  if (!a2)
    return 4294967246;
  Data = CFPropertyListCreateData(0, a2, kCFPropertyListXMLFormat_v1_0, 0, 0);
  v8 = IPCBufferWriter::write(this, Data, a3, a4);
  CFRelease(Data);
  return v8;
}

uint64_t MIDIServer_ObjectSetDictionaryProperty(MIDIServer *a1, const UInt8 *a2, CFIndex numBytes, const UInt8 *a4, unsigned int a5)
{
  const __CFString *v8;
  const UInt8 *v9;
  uint64_t v10;
  const UInt8 *v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  const UInt8 *v16;
  int v17;
  int v18;
  const __CFString *v19;

  v16 = a2;
  v17 = numBytes;
  v18 = 0;
  v8 = CFStringCreateWithBytes(0, a2, numBytes, 0x100u, 1u);
  v19 = v8;
  v12 = a4;
  v13 = a5;
  v14 = 0;
  v15 = 0;
  v9 = IPCBufferReader::ReadCFPropertyList(&v12, 0);
  v10 = _MIDIObjectSetDictionaryProperty(a1, v8, (uint64_t)v9);
  if (!(_DWORD)v10)
    MEMORY[0x1D826C41C](*MEMORY[0x1E0C83DA0], a4, a5);
  IPCBufferReader::~IPCBufferReader((IPCBufferReader *)&v12);
  IPCBufferReader::~IPCBufferReader((IPCBufferReader *)&v16);
  return v10;
}

void sub_1D4E8E0CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  IPCBufferReader::~IPCBufferReader((IPCBufferReader *)&a9);
  IPCBufferReader::~IPCBufferReader((IPCBufferReader *)&a12);
  _Unwind_Resume(a1);
}

const UInt8 *IPCBufferReader::ReadCFPropertyList(const UInt8 **this, char a2)
{
  const __CFData *v4;
  const UInt8 *v5;
  CFErrorRef error;

  v4 = CFDataCreate(0, *this, *((unsigned int *)this + 2));
  error = 0;
  v5 = (const UInt8 *)CFPropertyListCreateWithData(0, v4, 0, 0, &error);
  if (error)
    CFRelease(error);
  CFRelease(v4);
  if ((a2 & 1) == 0)
    this[2] = v5;
  return v5;
}

void ErrorFormatter::ErrorFormatter(ErrorFormatter *this, unsigned int a2)
{
  char v3[16];
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    CAX4CCString::CAX4CCString((CAX4CCString *)v3, a2);
    snprintf((char *)this, 0x20uLL, " *** error %s", v3);
  }
  else
  {
    *(_BYTE *)this = 0;
  }
}

uint64_t MIDIServer_ExternalDeviceCreate(UInt8 *bytes, CFIndex numBytes, UInt8 *a3, unsigned int a4, UInt8 *a5, unsigned int a6, MIDIDeviceRef *a7)
{
  uint64_t v8;
  UInt8 *v10;
  CFIndex v11;
  CFStringRef v12;
  UInt8 *bytesa;
  CFIndex numBytesa;
  CFStringRef v15;
  UInt8 *v16;
  int v17;
  int v18;
  CFStringRef v19;

  v16 = bytes;
  v17 = numBytes;
  v18 = 0;
  bytesa = a3;
  numBytesa = a4;
  v10 = a5;
  v11 = a6;
  v19 = CFStringCreateWithBytes(0, bytes, numBytes, 0x100u, 1u);
  v15 = CFStringCreateWithBytes(0, bytesa, numBytesa, 0x100u, 1u);
  v12 = CFStringCreateWithBytes(0, v10, v11, 0x100u, 1u);
  v8 = MIDIDeviceCreate(0, v19, v15, v12, a7);
  IPCBufferReader::~IPCBufferReader((IPCBufferReader *)&v10);
  IPCBufferReader::~IPCBufferReader((IPCBufferReader *)&bytesa);
  IPCBufferReader::~IPCBufferReader((IPCBufferReader *)&v16);
  return v8;
}

void sub_1D4E8E2DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  va_list va1;
  uint64_t v9;
  uint64_t v10;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v7 = va_arg(va2, _QWORD);
  v9 = va_arg(va2, _QWORD);
  v10 = va_arg(va2, _QWORD);
  IPCBufferReader::~IPCBufferReader((IPCBufferReader *)va);
  IPCBufferReader::~IPCBufferReader((IPCBufferReader *)va1);
  IPCBufferReader::~IPCBufferReader((IPCBufferReader *)va2);
  _Unwind_Resume(a1);
}

uint64_t MIDIServer_ThruConnectionCreate(_OWORD *a1, const UInt8 *a2, CFIndex numBytes, const UInt8 *a4, unsigned int a5, _DWORD *a6)
{
  CFStringRef v10;
  __int128 v11;
  uint64_t v12;
  const UInt8 *v14;
  unsigned int v15;
  int v16;
  const __CFData *v17;
  const UInt8 *v18;
  int v19;
  int v20;
  CFStringRef v21;
  audit_token_t atoken;
  pid_t pidp[2];

  v18 = a2;
  v19 = numBytes;
  v20 = 0;
  v21 = 0;
  if (a2)
  {
    v10 = CFStringCreateWithBytes(0, a2, numBytes, 0x100u, 1u);
    v21 = v10;
  }
  else
  {
    v10 = 0;
  }
  v14 = a4;
  v15 = a5;
  v16 = 0;
  v17 = CFDataCreate(0, a4, a5);
  *(_QWORD *)pidp = 0;
  v11 = a1[1];
  *(_OWORD *)atoken.val = *a1;
  *(_OWORD *)&atoken.val[4] = v11;
  audit_token_to_au32(&atoken, 0, (uid_t *)&pidp[1], 0, 0, 0, pidp, 0, 0);
  v12 = _MIDIThruConnectionCreate((MIDIServer *)pidp[0], v10, v17, a6);
  if (!(_DWORD)v12)
    MEMORY[0x1D826C41C](*MEMORY[0x1E0C83DA0], a4, a5);
  IPCBufferReader::~IPCBufferReader((IPCBufferReader *)&v14);
  IPCBufferReader::~IPCBufferReader((IPCBufferReader *)&v18);
  return v12;
}

void sub_1D4E8E420(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  IPCBufferReader::~IPCBufferReader((IPCBufferReader *)va);
  _Unwind_Resume(a1);
}

uint64_t MIDIServer_UMPCIObjectCreate(_OWORD *a1, int a2, const UInt8 *a3, int a4, int *a5)
{
  const UInt8 *v8;
  __int128 v9;
  uint64_t v10;
  const UInt8 *v12;
  int v13;
  int v14;
  uint64_t v15;
  audit_token_t atoken;
  pid_t pidp[2];

  v12 = a3;
  v13 = a4;
  v14 = 0;
  v15 = 0;
  v8 = IPCBufferReader::ReadCFPropertyList(&v12, 0);
  *(_QWORD *)pidp = 0;
  v9 = a1[1];
  *(_OWORD *)atoken.val = *a1;
  *(_OWORD *)&atoken.val[4] = v9;
  audit_token_to_au32(&atoken, 0, (uid_t *)&pidp[1], 0, 0, 0, pidp, 0, 0);
  v10 = _UMPCIObjectCreate((MIDIServer *)pidp[0], a2, v8, a5);
  IPCBufferReader::~IPCBufferReader((IPCBufferReader *)&v12);
  return v10;
}

void sub_1D4E8E4F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IPCBufferReader::~IPCBufferReader((IPCBufferReader *)va);
  _Unwind_Resume(a1);
}

unint64_t ___ZN28MIDIDriverKitPluginRegistrarC2ER13MIDIDriverMgr_block_invoke(unint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t *i;
  uint64_t v6;
  MIDIDriverPlugin_DriverKit *v7;

  if (*(_DWORD *)a2 == 4)
  {
    v2 = **(_QWORD **)(result + 32);
    v3 = *(uint64_t **)(v2 + 16);
    for (i = *(uint64_t **)(v2 + 24); v3 != i; ++v3)
    {
      v6 = *v3;
      if (*v3 && *(_DWORD *)(v6 + 64) == 4)
      {
        v7 = (MIDIDriverPlugin_DriverKit *)*(unsigned int *)(a2 + 8);
        result = MIDIDriverPlugin_DriverKit::getRemoteRef(*(MIDIDriverPlugin_DriverKit **)(v6 + 88), *(MIDIDriverPlugin_DriverKit **)(v6 + 96), *(_DWORD *)(a2 + 8));
        if (HIDWORD(result))
          result = MIDIDriverPlugin_DriverKit::syncPropertyRemote(v6, *(CFStringRef *)(a2 + 16), v7, result);
      }
    }
  }
  return result;
}

void midiDriverKitLog(void)
{
  unsigned __int8 v0;

  if ((v0 & 1) == 0)
  {
    {
      caulk::log_category::log_category((caulk::log_category *)&midiDriverKitLog(void)::category, "com.apple.coremidi", "MIDIDriverKit");
    }
  }
}

CFDictionaryRef applesauce::CF::details::make_CFDictionaryRef(uint64_t a1)
{
  unint64_t v2;
  uint64_t v3;
  void **v4;
  uint64_t v5;
  void *v6;
  void **v7;
  void **v8;
  void **v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  void **v15;
  void *v16;
  void *v17;
  void **v18;
  void **v19;
  void **v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  void **v26;
  void *v27;
  void **v28;
  void **v29;
  CFDictionaryRef v30;
  void *exception;
  void **values;
  void **v34;
  unint64_t v35;
  void **keys;
  void **v37;
  unint64_t v38;

  v2 = *(_QWORD *)(a1 + 8);
  keys = 0;
  v37 = 0;
  v38 = 0;
  std::vector<void const*>::reserve((void **)&keys, v2);
  values = 0;
  v34 = 0;
  v35 = 0;
  std::vector<void const*>::reserve((void **)&values, v2);
  v3 = *(_QWORD *)(a1 + 8);
  if (v3)
  {
    v4 = *(void ***)a1;
    v5 = *(_QWORD *)a1 + 16 * v3;
    do
    {
      v6 = *v4;
      v7 = v37;
      if ((unint64_t)v37 >= v38)
      {
        v9 = keys;
        v10 = v37 - keys;
        v11 = v10 + 1;
        if ((unint64_t)(v10 + 1) >> 61)
          std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
        v12 = v38 - (_QWORD)keys;
        if ((uint64_t)(v38 - (_QWORD)keys) >> 2 > v11)
          v11 = v12 >> 2;
        if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
          v13 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v13 = v11;
        if (v13)
          v13 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v13);
        else
          v14 = 0;
        v15 = (void **)(v13 + 8 * v10);
        *v15 = v6;
        v8 = v15 + 1;
        if (v7 != v9)
        {
          do
          {
            v16 = *--v7;
            *--v15 = v16;
          }
          while (v7 != v9);
          v7 = keys;
        }
        keys = v15;
        v38 = v13 + 8 * v14;
        if (v7)
          operator delete(v7);
      }
      else
      {
        *v37 = v6;
        v8 = v7 + 1;
      }
      v37 = v8;
      v17 = v4[1];
      v18 = v34;
      if ((unint64_t)v34 >= v35)
      {
        v20 = values;
        v21 = v34 - values;
        v22 = v21 + 1;
        if ((unint64_t)(v21 + 1) >> 61)
          std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
        v23 = v35 - (_QWORD)values;
        if ((uint64_t)(v35 - (_QWORD)values) >> 2 > v22)
          v22 = v23 >> 2;
        if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8)
          v24 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v24 = v22;
        if (v24)
          v24 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v24);
        else
          v25 = 0;
        v26 = (void **)(v24 + 8 * v21);
        *v26 = v17;
        v19 = v26 + 1;
        if (v18 != v20)
        {
          do
          {
            v27 = *--v18;
            *--v26 = v27;
          }
          while (v18 != v20);
          v18 = values;
        }
        values = v26;
        v35 = v24 + 8 * v25;
        if (v18)
          operator delete(v18);
      }
      else
      {
        *v34 = v17;
        v19 = v18 + 1;
      }
      v34 = v19;
      v4 += 2;
    }
    while (v4 != (void **)v5);
  }
  v28 = keys;
  v29 = values;
  v30 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, v2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!v30)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  if (v29)
    operator delete(v29);
  if (v28)
    operator delete(v28);
  return v30;
}

void sub_1D4E8E860(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12)
{
  void *v12;

  __cxa_free_exception(v12);
  if (__p)
    operator delete(__p);
  if (a12)
    operator delete(a12);
  _Unwind_Resume(a1);
}

uint64_t applesauce::iokit::io_service_factory::io_service_factory(uint64_t a1, const __CFDictionary **a2, const char *a3, uint64_t a4)
{
  void *v8;
  id v9;
  const __CFDictionary *v10;
  uint64_t v11;
  IONotificationPortRef v12;
  id v13;
  uint64_t v14;
  io_object_t *v15;
  NSObject *v16;
  IONotificationPort *v17;
  uint64_t v18;
  io_object_t v19;
  io_object_t v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  void *exception;
  const std::error_category *v26;
  void (*v27)(void *);
  struct type_info *v28;
  void *v29;
  const std::error_category *v30;
  const std::error_category *v31;
  mach_port_t mainPort;
  _QWORD v33[3];
  _QWORD *v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v8 = (void *)MEMORY[0x1E0C80D38];
  v9 = MEMORY[0x1E0C80D38];
  v10 = *a2;
  *a2 = 0;
  std::__function::__value_func<void ()(applesauce::iokit::io_object_holder)>::__value_func[abi:ne180100]((uint64_t)v33, a4);
  mainPort = 0;
  v11 = MEMORY[0x1D826B624](*MEMORY[0x1E0C81720], &mainPort);
  if ((_DWORD)v11)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    v26 = std::system_category();
    MEMORY[0x1D826B8A0](exception, v11, v26, "IOMainPort failed");
    v27 = (void (*)(void *))MEMORY[0x1E0DE4580];
    goto LABEL_23;
  }
  v12 = IONotificationPortCreate(mainPort);
  *(_QWORD *)a1 = v12;
  if (!v12)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "IONotificationPortCreate failed");
    v27 = (void (*)(void *))MEMORY[0x1E0DE4338];
LABEL_23:
    __cxa_throw(exception, v28, v27);
  }
  v13 = v8;
  *(_QWORD *)(a1 + 8) = v8;
  v14 = (uint64_t)v34;
  if (!v34)
  {
LABEL_6:
    *(_QWORD *)(a1 + 40) = v14;
    goto LABEL_8;
  }
  if (v34 != v33)
  {
    v14 = (*(uint64_t (**)(void))(*v34 + 16))();
    goto LABEL_6;
  }
  *(_QWORD *)(a1 + 40) = a1 + 16;
  (*(void (**)(_QWORD *, uint64_t))(v33[0] + 24))(v33, a1 + 16);
LABEL_8:
  *(_DWORD *)(a1 + 48) = 0;
  v15 = (io_object_t *)(a1 + 48);
  v17 = *(IONotificationPort **)a1;
  v16 = *(NSObject **)(a1 + 8);
  caulk::mach::os_object<NSObject  {objcproto15OS_os_eventlink}* {__strong}>::get(v16);
  objc_claimAutoreleasedReturnValue();
  IONotificationPortSetDispatchQueue(v17, v16);

  mainPort = 0;
  v18 = IOServiceAddMatchingNotification(*(IONotificationPortRef *)a1, a3, v10, (IOServiceMatchingCallback)applesauce::iokit::io_service_factory::matching_callback_, (void *)a1, &mainPort);
  if ((_DWORD)v18)
  {
    v29 = __cxa_allocate_exception(0x20uLL);
    v30 = std::system_category();
    MEMORY[0x1D826B8A0](v29, v18, v30, "Error on IOServiceAddMatchingNotification");
    goto LABEL_26;
  }
  v19 = mainPort;
  v20 = *v15;
  *v15 = mainPort;
  if (v20)
  {
    IOObjectRelease(v20);
    v19 = *v15;
  }
  if (v19)
  {
    v21 = IOObjectRetain(v19);
    if ((_DWORD)v21)
    {
      v29 = __cxa_allocate_exception(0x20uLL);
      v31 = std::system_category();
      MEMORY[0x1D826B8A0](v29, v21, v31, "Error on Retain");
LABEL_26:
    }
  }
  applesauce::iokit::io_service_factory::matching_callback(a1, v19);
  if (v19)
    IOObjectRelease(v19);
  v22 = v34;
  if (v34 == v33)
  {
    v23 = 4;
    v22 = v33;
    goto LABEL_19;
  }
  if (v34)
  {
    v23 = 5;
LABEL_19:
    (*(void (**)(void))(*v22 + 8 * v23))();
  }

  return a1;
}

void sub_1D4E8EB88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, __int16 a11, char a12, char a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, __int16 *a20)
{
  uint64_t v20;
  id *v21;
  _QWORD *v22;
  io_object_t *v23;
  void *v24;
  _QWORD *v26;
  uint64_t v27;
  __int16 *v28;
  uint64_t v29;

  __cxa_free_exception(v24);
  applesauce::iokit::io_object_holder::~io_object_holder(v23);
  v26 = *(_QWORD **)(v20 + 40);
  if (v26 == v22)
  {
    v27 = 4;
  }
  else
  {
    if (!v26)
      goto LABEL_6;
    v27 = 5;
    v22 = *(_QWORD **)(v20 + 40);
  }
  (*(void (**)(_QWORD *))(*v22 + 8 * v27))(v22);
LABEL_6:
  applesauce::dispatch::v1::queue::~queue(v21);
  applesauce::iokit::details::io_notificationport_holder::~io_notificationport_holder((IONotificationPortRef *)v20);
  v28 = a20;
  if (a20 == &a15)
  {
    v29 = 4;
    v28 = &a15;
  }
  else
  {
    if (!a20)
      goto LABEL_11;
    v29 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v28 + 8 * v29))();
LABEL_11:
  applesauce::CF::DictionaryRef::~DictionaryRef(&a10);

  _Unwind_Resume(a1);
}

void applesauce::CF::DictionaryRef::~DictionaryRef(const void **this)
{
  const void *v1;

  v1 = *this;
  if (v1)
    CFRelease(v1);
}

void std::default_delete<applesauce::iokit::io_service_factory>::operator()[abi:ne180100](uint64_t a1)
{
  io_object_t v2;
  _QWORD *v3;
  uint64_t v4;
  void *v5;

  v2 = *(_DWORD *)(a1 + 48);
  if (v2)
    IOObjectRelease(v2);
  v3 = *(_QWORD **)(a1 + 40);
  if (v3 == (_QWORD *)(a1 + 16))
  {
    v4 = 4;
    v3 = (_QWORD *)(a1 + 16);
  }
  else
  {
    if (!v3)
    {
LABEL_8:
      v5 = *(void **)(a1 + 8);
      *(_QWORD *)(a1 + 8) = 0;

      IONotificationPortDestroy(*(IONotificationPortRef *)a1);
      JUMPOUT(0x1D826BA98);
    }
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
  goto LABEL_8;
}

void applesauce::CF::TypeRefPair::~TypeRefPair(applesauce::CF::TypeRefPair *this)
{
  const void *v2;

  v2 = (const void *)*((_QWORD *)this + 1);
  if (v2)
    CFRelease(v2);
  if (*(_QWORD *)this)
    CFRelease(*(CFTypeRef *)this);
}

void std::__function::__func<MIDIDriverKitPluginRegistrar::MIDIDriverKitPluginRegistrar(MIDIDriverMgr &)::$_1,std::allocator<MIDIDriverKitPluginRegistrar::MIDIDriverKitPluginRegistrar(MIDIDriverMgr &)::$_1>,void ()(applesauce::iokit::io_object_holder)>::~__func()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *std::__function::__func<MIDIDriverKitPluginRegistrar::MIDIDriverKitPluginRegistrar(MIDIDriverMgr &)::$_1,std::allocator<MIDIDriverKitPluginRegistrar::MIDIDriverKitPluginRegistrar(MIDIDriverMgr &)::$_1>,void ()(applesauce::iokit::io_object_holder)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E98B72F0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<MIDIDriverKitPluginRegistrar::MIDIDriverKitPluginRegistrar(MIDIDriverMgr &)::$_1,std::allocator<MIDIDriverKitPluginRegistrar::MIDIDriverKitPluginRegistrar(MIDIDriverMgr &)::$_1>,void ()(applesauce::iokit::io_object_holder)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E98B72F0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<MIDIDriverKitPluginRegistrar::MIDIDriverKitPluginRegistrar(MIDIDriverMgr &)::$_1,std::allocator<MIDIDriverKitPluginRegistrar::MIDIDriverKitPluginRegistrar(MIDIDriverMgr &)::$_1>,void ()(applesauce::iokit::io_object_holder)>::operator()(MIDIServer *a1, io_object_t *a2)
{
  io_object_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  MIDIServer *v6;
  io_object_t v7;
  void *v8;
  const std::error_category *v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  io_object_t v13;
  uint64_t v14;
  BOOL v15;
  uint64_t *v16;
  int v17;
  uint64_t v18;
  MIDIDeviceRef *v19;
  MIDIDeviceRef *v20;
  MIDIDeviceRef *v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  const std::error_category *v29;
  void *exception;
  const std::error_category *v31;

  v2 = *a2;
  *a2 = 0;
  v3 = (uint64_t *)*((_QWORD *)a1 + 1);
  if (v2)
  {
    v4 = IOObjectRetain(v2);
    if ((_DWORD)v4)
    {
      exception = __cxa_allocate_exception(0x20uLL);
      v31 = std::system_category();
      MEMORY[0x1D826B8A0](exception, v4, v31, "Error on Retain");
    }
    v5 = *v3;
    a1 = (MIDIServer *)IOObjectRetain(v2);
    v6 = a1;
    v7 = v2;
    if ((_DWORD)a1)
    {
      v8 = __cxa_allocate_exception(0x20uLL);
      v9 = std::system_category();
      MEMORY[0x1D826B8A0](v8, v6, v9, "Error on Retain");
    }
  }
  else
  {
    v7 = 0;
    v5 = *v3;
  }
  v10 = *(uint64_t **)(v5 + 16);
  v11 = *(uint64_t **)(v5 + 24);
  if (v10 != v11)
  {
    do
    {
      v12 = *v10;
      if (*v10 && *(_DWORD *)(v12 + 64) == 4)
      {
        v13 = *(_DWORD *)(v12 + 72);
        if (v13)
        {
          v14 = IOObjectRetain(*(_DWORD *)(v12 + 72));
          if ((_DWORD)v14)
          {
            v28 = __cxa_allocate_exception(0x20uLL);
            v29 = std::system_category();
            MEMORY[0x1D826B8A0](v28, v14, v29, "Error on Retain");
          }
          v15 = (v13 | v7) == 0;
          if (v2)
            v15 = IOObjectIsEqualTo(v13, v7) != 0;
          a1 = (MIDIServer *)IOObjectRelease(v13);
          if (v15)
            goto LABEL_18;
        }
        else if (!v7)
        {
          goto LABEL_18;
        }
      }
      ++v10;
    }
    while (v10 != v11);
    v10 = v11;
  }
LABEL_18:
  if (v2)
    a1 = (MIDIServer *)IOObjectRelease(v7);
  if (v10 != *(uint64_t **)(*v3 + 24))
  {
    v16 = MIDIServer::defaultInstance(a1) + 2;
    v17 = (*(uint64_t (**)(uint64_t *))(*v16 + 16))(v16);
    v18 = *v10;
    if (*v10 && *(_DWORD *)(v18 + 64) == 4)
    {
      v19 = *(MIDIDeviceRef **)(v18 + 88);
      v20 = *(MIDIDeviceRef **)(v18 + 96);
      if (v19 != v20)
      {
        do
        {
          MIDIDriverPlugin_DriverKit::DeviceIO::stop((MIDIDriverPlugin_DriverKit::DeviceIO *)(v19 + 8));
          caulk::mach::os_eventlink::dissociate((caulk::mach::os_eventlink *)(v19 + 60));
          MIDISetupRemoveDevice(*v19);
          MIDIDeviceDispose(*v19);
          v19 += 74;
        }
        while (v19 != v20);
        v21 = *(MIDIDeviceRef **)(v18 + 88);
        v19 = *(MIDIDeviceRef **)(v18 + 96);
        if (v19 != v21)
        {
          do
          {
            v19 -= 74;
            std::__destroy_at[abi:ne180100]<MIDIDriverPlugin_DriverKit::Device,0>((uint64_t)v19);
          }
          while (v19 != v21);
          v19 = v21;
        }
      }
      *(_QWORD *)(v18 + 96) = v19;
      v22 = *v3;
      v23 = v10 + 1;
      v24 = *(uint64_t **)(v22 + 24);
      if (v10 + 1 != v24)
      {
        do
        {
          v10 = v23;
          v25 = *(v23 - 1);
          *(v23 - 1) = *v23;
          *v23 = 0;
          if (v25)
            (*(void (**)(uint64_t))(*(_QWORD *)v25 + 8))(v25);
          ++v23;
        }
        while (v10 + 1 != v24);
        v23 = *(uint64_t **)(v22 + 24);
      }
      while (v23 != v10)
      {
        v27 = *--v23;
        v26 = v27;
        *v23 = 0;
        if (v27)
          (*(void (**)(uint64_t))(*(_QWORD *)v26 + 8))(v26);
      }
      *(_QWORD *)(v22 + 24) = v10;
    }
    if (v17)
      (*(void (**)(uint64_t *))(*v16 + 24))(v16);
  }
  if (v2)
  {
    IOObjectRelease(v2);
    IOObjectRelease(v2);
  }
}

void sub_1D4E8F118(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, char a11)
{
  io_object_t v11;
  void *v12;

  __cxa_free_exception(v12);
  IOObjectRelease(v11);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  if (!v11)
    JUMPOUT(0x1D4E8F070);
  JUMPOUT(0x1D4E8F068);
}

void sub_1D4E8F1C0(_Unwind_Exception *exception_object)
{
  io_object_t v1;

  if (v1)
    IOObjectRelease(v1);
  _Unwind_Resume(exception_object);
}

io_object_t *MIDIDriverKitPluginRegistrar::handleServiceTerminated(applesauce::iokit::io_object_holder)::$_0::~$_0(io_object_t *a1)
{
  io_object_t v2;

  v2 = *a1;
  if (v2)
    IOObjectRelease(v2);
  return a1;
}

void std::__destroy_at[abi:ne180100]<MIDIDriverPlugin_DriverKit::Device,0>(uint64_t a1)
{
  void *v2;
  void *v3;
  void **v4;

  caulk::thread::~thread((caulk::thread *)(a1 + 280));
  if (*(char *)(a1 + 271) < 0)
    operator delete(*(void **)(a1 + 248));
  caulk::mach::details::release_os_object(*(caulk::mach::details **)(a1 + 240), v2);
  if (*(char *)(a1 + 239) < 0)
    operator delete(*(void **)(a1 + 216));
  caulk::mach::details::release_os_object(*(caulk::mach::details **)(a1 + 208), v3);
  v4 = (void **)(a1 + 8);
  std::vector<MIDIDriverPlugin_DriverKit::Entity>::__destroy_vector::operator()[abi:ne180100](&v4);
}

uint64_t MIDIDriverPlugin_DriverKit::DeviceIO::stop(MIDIDriverPlugin_DriverKit::DeviceIO *this)
{
  void *v2;
  _QWORD v4[2];

  *((_BYTE *)this + 240) = 0;
  v2 = (void *)*((_QWORD *)this + 22);
  caulk::mach::os_object<NSObject  {objcproto15OS_os_eventlink}* {__strong}>::get(v2);
  objc_claimAutoreleasedReturnValue();
  os_eventlink_cancel();

  caulk::thread::join((MIDIDriverPlugin_DriverKit::DeviceIO *)((char *)this + 248));
  v4[0] = 0;
  v4[1] = 0;
  caulk::thread::operator=();
  caulk::thread::~thread((caulk::thread *)v4);
  return caulk::mach::os_eventlink::dissociate((MIDIDriverPlugin_DriverKit::DeviceIO *)((char *)this + 208));
}

void sub_1D4E8F2E4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void std::vector<MIDIDriverPlugin_DriverKit::Entity>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  _QWORD *v2;
  _QWORD *v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 7;
        std::__destroy_at[abi:ne180100]<MIDIDriverPlugin_DriverKit::Entity,0>(v4);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__destroy_at[abi:ne180100]<MIDIDriverPlugin_DriverKit::Entity,0>(_QWORD *a1)
{
  void *v2;
  void *v3;

  v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = v2;
    operator delete(v2);
  }
  v3 = (void *)a1[1];
  if (v3)
  {
    a1[2] = v3;
    operator delete(v3);
  }
}

uint64_t std::__function::__value_func<void ()(applesauce::iokit::io_object_holder)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a2 + 24) + 24))(*(_QWORD *)(a2 + 24), a1);
    }
    else
    {
      *(_QWORD *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 16))(v3);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t applesauce::iokit::io_service_factory::matching_callback_(uint64_t this, io_object_t object)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *exception;
  const std::error_category *v7;

  if (this && object)
  {
    v3 = this;
    v4 = IOObjectRetain(object);
    if ((_DWORD)v4)
    {
      v5 = v4;
      exception = __cxa_allocate_exception(0x20uLL);
      v7 = std::system_category();
      MEMORY[0x1D826B8A0](exception, v5, v7, "Error on Retain");
    }
    applesauce::iokit::io_service_factory::matching_callback(v3, object);
    return IOObjectRelease(object);
  }
  return this;
}

void sub_1D4E8F4A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, char a11)
{
  void *v11;

  __cxa_free_exception(v11);
  _Unwind_Resume(a1);
}

uint64_t applesauce::iokit::io_service_factory::matching_callback(uint64_t a1, io_object_t object)
{
  uint64_t v4;
  uint64_t v5;
  io_iterator_t v6;
  void *v7;
  const std::error_category *v8;
  uint64_t result;
  io_object_t v10;
  uint64_t v11;
  uint64_t v12;
  io_object_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  const std::error_category *v17;
  void *v18;
  const std::error_category *v19;
  void *v20;
  const std::error_category *v21;
  uint64_t v22;
  void *exception;
  const std::error_category *v24;
  io_object_t objecta;
  io_object_t v26;
  uint64_t v27;
  io_object_t v28;
  io_object_t v29;
  io_object_t v30;

  v28 = object;
  if (object)
  {
    v4 = IOObjectRetain(object);
    if ((_DWORD)v4)
    {
      v22 = v4;
      exception = __cxa_allocate_exception(0x20uLL);
      v24 = std::system_category();
      MEMORY[0x1D826B8A0](exception, v22, v24, "Error on Retain");
    }
    v29 = object;
    v5 = IOObjectRetain(object);
    v6 = object;
    if ((_DWORD)v5)
    {
      v7 = __cxa_allocate_exception(0x20uLL);
      v8 = std::system_category();
      MEMORY[0x1D826B8A0](v7, v5, v8, "Error on Retain");
    }
  }
  else
  {
    v6 = 0;
    v29 = 0;
  }
  result = IOIteratorNext(v6);
  v10 = result;
  v30 = result;
  if (object)
    result = IOObjectRelease(object);
  v27 = 0;
  if (v10)
  {
    do
    {
      if (v6)
      {
        v11 = IOObjectRetain(v6);
        if ((_DWORD)v11)
        {
          v20 = __cxa_allocate_exception(0x20uLL);
          v21 = std::system_category();
          MEMORY[0x1D826B8A0](v20, v11, v21, "Error on Retain");
        }
      }
      objecta = v10;
      v12 = IOObjectRetain(v10);
      if ((_DWORD)v12)
      {
        v16 = __cxa_allocate_exception(0x20uLL);
        v17 = std::system_category();
        MEMORY[0x1D826B8A0](v16, v12, v17, "Error on Retain");
      }
      v13 = IOIteratorNext(v6);
      v30 = v13;
      IOObjectRelease(v10);
      v26 = v10;
      if (v10)
      {
        v14 = IOObjectRetain(v10);
        if ((_DWORD)v14)
        {
          v18 = __cxa_allocate_exception(0x20uLL);
          v19 = std::system_category();
          MEMORY[0x1D826B8A0](v18, v14, v19, "Error on Retain");
        }
      }
      v15 = *(_QWORD *)(a1 + 40);
      if (!v15)
        std::__throw_bad_function_call[abi:ne180100]();
      (*(void (**)(uint64_t, io_object_t *))(*(_QWORD *)v15 + 48))(v15, &v26);
      if (v26)
        IOObjectRelease(v26);
      if (objecta)
        IOObjectRelease(objecta);
      result = v6;
      if (v6)
        result = IOObjectRelease(v6);
      v10 = v13;
    }
    while (v13);
  }
  if (v6)
    return IOObjectRelease(v6);
  return result;
}

void sub_1D4E8F760(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, char a11, int a12, char a13, __int16 a14, char a15, char a16, int a17, int a18, io_object_t a19, char a20,char a21)
{
  void *v21;

  __cxa_free_exception(v21);
  applesauce::iokit::io_object_holder::~io_object_holder(&a19);
  _Unwind_Resume(a1);
}

void applesauce::iokit::io_object_holder::~io_object_holder(io_object_t *this)
{
  io_object_t v1;

  v1 = *this;
  if (v1)
    IOObjectRelease(v1);
}

void applesauce::dispatch::v1::queue::~queue(id *this)
{
  id v2;

  v2 = *this;
  *this = 0;

}

void applesauce::iokit::details::io_notificationport_holder::~io_notificationport_holder(IONotificationPortRef *this)
{
  IONotificationPortDestroy(*this);
}

void applesauce::iokit::details::io_services_iterator::~io_services_iterator(applesauce::iokit::details::io_services_iterator *this)
{
  io_object_t v2;

  v2 = *((_DWORD *)this + 1);
  if (v2)
    IOObjectRelease(v2);
  if (*(_DWORD *)this)
    IOObjectRelease(*(_DWORD *)this);
}

void std::__function::__func<MIDIDriverKitPluginRegistrar::MIDIDriverKitPluginRegistrar(MIDIDriverMgr &)::$_0,std::allocator<MIDIDriverKitPluginRegistrar::MIDIDriverKitPluginRegistrar(MIDIDriverMgr &)::$_0>,void ()(applesauce::iokit::io_object_holder)>::~__func()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *std::__function::__func<MIDIDriverKitPluginRegistrar::MIDIDriverKitPluginRegistrar(MIDIDriverMgr &)::$_0,std::allocator<MIDIDriverKitPluginRegistrar::MIDIDriverKitPluginRegistrar(MIDIDriverMgr &)::$_0>,void ()(applesauce::iokit::io_object_holder)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E98B72A8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<MIDIDriverKitPluginRegistrar::MIDIDriverKitPluginRegistrar(MIDIDriverMgr &)::$_0,std::allocator<MIDIDriverKitPluginRegistrar::MIDIDriverKitPluginRegistrar(MIDIDriverMgr &)::$_0>,void ()(applesauce::iokit::io_object_holder)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E98B72A8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<MIDIDriverKitPluginRegistrar::MIDIDriverKitPluginRegistrar(MIDIDriverMgr &)::$_0,std::allocator<MIDIDriverKitPluginRegistrar::MIDIDriverKitPluginRegistrar(MIDIDriverMgr &)::$_0>,void ()(applesauce::iokit::io_object_holder)>::operator()(MIDIServer *a1, io_object_t *a2)
{
  io_object_t v2;
  int64x2_t **v3;
  MIDIServer *v4;
  uint64_t *v5;
  int v6;
  int64x2_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  const std::error_category *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  mach_port_t v17;
  uint64_t v18;
  mach_port_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  _QWORD *v25;
  uint64_t v26;
  char *v27;
  CFTypeRef v28;
  const void *v29;
  const __CFString *v30;
  uint64_t v31;
  uint64_t v32;
  io_object_t v33;
  io_object_t v34;
  mach_port_t v35;
  uint64_t v36;
  CFStringRef **p_reference;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _QWORD *v41;
  uint64_t v42;
  CFStringRef *v43;
  uint64_t v44;
  MIDIDriverPlugin *v45;
  unint64_t v46;
  uint64_t *v47;
  _QWORD *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t *v55;
  unint64_t v56;
  _QWORD *v57;
  _QWORD *v58;
  uint64_t v59;
  int64x2_t v60;
  uint64_t v61;
  uint64_t v62;
  void *exception;
  const std::error_category *v64;
  void *v65;
  const std::error_category *v66;
  void *v67;
  const std::error_category *v68;
  void *v69;
  io_service_t object;
  io_object_t v71;
  mach_port_t connection;
  uint64_t v73;
  CFTypeRef cf;
  _BYTE v75[24];
  _BYTE *v76;
  CFStringRef *reference;
  _BYTE reference_8[24];
  __int128 v79;
  __int128 v80;
  CFStringRef errorString;
  _DWORD *v82;
  CFStringRef *p_errorString;
  uint64_t v84;

  v84 = *MEMORY[0x1E0C80C00];
  v2 = *a2;
  *a2 = 0;
  v3 = (int64x2_t **)*((_QWORD *)a1 + 1);
  if (v2)
  {
    a1 = (MIDIServer *)IOObjectRetain(v2);
    v4 = a1;
    if ((_DWORD)a1)
    {
      exception = __cxa_allocate_exception(0x20uLL);
      v64 = std::system_category();
      MEMORY[0x1D826B8A0](exception, v4, v64, "Error on Retain");
    }
  }
  v5 = MIDIServer::defaultInstance(a1) + 2;
  v6 = (*(uint64_t (**)(uint64_t *))(*v5 + 16))(v5);
  v7 = *v3;
  if (v2)
  {
    v8 = IOObjectRetain(v2);
    if ((_DWORD)v8)
    {
      v65 = __cxa_allocate_exception(0x20uLL);
      v66 = std::system_category();
      MEMORY[0x1D826B8A0](v65, v8, v66, "Error on Retain");
    }
    object = v2;
    v9 = IOObjectRetain(v2);
    if ((_DWORD)v9)
    {
      v67 = __cxa_allocate_exception(0x20uLL);
      v68 = std::system_category();
      MEMORY[0x1D826B8A0](v67, v9, v68, "Error on Retain");
    }
    v76 = 0;
    v71 = v2;
    v10 = IOObjectRetain(v2);
    if ((_DWORD)v10)
    {
      v11 = __cxa_allocate_exception(0x20uLL);
      v12 = std::system_category();
      MEMORY[0x1D826B8A0](v11, v10, v12, "Error on Retain");
    }
  }
  else
  {
    object = 0;
    v71 = 0;
    v76 = 0;
  }
  connection = 0;
  v13 = operator new();
  *(_QWORD *)(v13 + 80) = 0;
  *(_OWORD *)(v13 + 48) = 0u;
  *(_OWORD *)(v13 + 64) = 0u;
  *(_OWORD *)(v13 + 16) = 0u;
  *(_OWORD *)(v13 + 32) = 0u;
  *(_OWORD *)v13 = 0u;
  MIDIDriverKitClient::State::State((MIDIDriverKitClient::State *)v13);
  v73 = v13;
  v14 = IOServiceOpen(object, *MEMORY[0x1E0C83DA0], 0x434D7564u, &connection);
  v15 = throw_on_error(v14, "Failed to establish connection to IOKit service");
  LODWORD(errorString) = MEMORY[0x1D826BA68](v15);
  v82 = &v71;
  v16 = IOConnectCallMethod(connection, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  throw_on_error(v16, "Failed to open driver");
  std::__function::__value_func<void ()(unsigned int,std::span<unsigned int const,18446744073709551615ul>)>::operator=[abi:ne180100]((_QWORD *)(v73 + 24), (uint64_t)v75);
  v17 = objc_msgSend(*(id *)(v73 + 16), "machPort");
  reference = 0;
  v79 = 0u;
  v80 = 0u;
  *(_QWORD *)reference_8 = MIDIDriverKitClient::propertiesChangedCallback;
  *(_OWORD *)&reference_8[8] = (unint64_t)v73;
  v18 = IOConnectCallAsyncMethod(connection, 0xCu, v17, (uint64_t *)&reference, 8u, 0, 0, 0, 0, 0, 0, 0, 0);
  throw_on_error(v18, "Failed to set properties changed async callback");
  v19 = objc_msgSend(*(id *)(v73 + 16), "machPort");
  reference = 0;
  v79 = 0u;
  v80 = 0u;
  *(_QWORD *)reference_8 = MIDIDriverKitClient::requestConfigChangeCallback;
  *(_OWORD *)&reference_8[8] = (unint64_t)v73;
  v20 = IOConnectCallAsyncMethod(connection, 0xDu, v19, (uint64_t *)&reference, 8u, 0, 0, 0, 0, 0, 0, 0, 0);
  throw_on_error(v20, "Failed to set request config change async callback");
  applesauce::raii::v1::detail::ScopeGuard<MIDIDriverKitClient::MIDIDriverKitClient(applesauce::iokit::io_object_holder,std::function<void ()(unsigned int,std::span<unsigned int const,18446744073709551615ul>)>)::{lambda(void)#1},applesauce::raii::v1::detail::StackFailPolicy>::~ScopeGuard((uint64_t)&errorString);
  v25 = v76;
  if (v76 == v75)
  {
    v26 = 4;
    v25 = v75;
  }
  else
  {
    if (!v76)
      goto LABEL_15;
    v26 = 5;
  }
  (*(void (**)(void))(*v25 + 8 * v26))();
LABEL_15:
  if (object)
    IOObjectRelease(object);
  MIDIDriverKitClient::getProperty<unsigned char>((uint64_t)&reference, (uint64_t)&v71, 1u, 1684955501, v21, v22, v23, v24);
  if (reference_8[16])
  {
    errorString = 0;
    v27 = (char *)reference;
    v28 = IOCFUnserializeBinary((const char *)reference, *(_QWORD *)reference_8 - (_QWORD)reference, (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &errorString);
    if (errorString)
    {
      v69 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x1D826B7EC](v69, "Failed to deserialize object");
    }
    v29 = v28;
    if (v28)
      CFRetain(v28);
    applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cf, v29);
    v30 = (const __CFString *)cf;
    if (cf)
      CFRelease(cf);
    if (v27)
      operator delete(v27);
  }
  else
  {
    v30 = (const __CFString *)reference;
  }
  v31 = operator new();
  MIDIObject::MIDIObject((MIDIObject *)v31, 0, v30);
  *(_QWORD *)(v31 + 48) = 0;
  *(_BYTE *)(v31 + 56) = 1;
  *(_DWORD *)(v31 + 64) = 4;
  *(_QWORD *)v31 = &off_1E98B6D30;
  *(_DWORD *)(v31 + 72) = 0;
  *(_DWORD *)(v31 + 76) = 0;
  v32 = operator new();
  *(_QWORD *)(v32 + 80) = 0;
  *(_OWORD *)(v32 + 48) = 0u;
  *(_OWORD *)(v32 + 64) = 0u;
  *(_OWORD *)(v32 + 16) = 0u;
  *(_OWORD *)(v32 + 32) = 0u;
  *(_OWORD *)v32 = 0u;
  MIDIDriverKitClient::State::State((MIDIDriverKitClient::State *)v32);
  *(_QWORD *)(v31 + 80) = v32;
  v33 = v71;
  v71 = 0;
  v34 = *(_DWORD *)(v31 + 72);
  *(_DWORD *)(v31 + 72) = v33;
  if (v34)
  {
    IOObjectRelease(v34);
    v32 = *(_QWORD *)(v31 + 80);
  }
  v35 = *(_DWORD *)(v31 + 76);
  *(_DWORD *)(v31 + 76) = connection;
  connection = v35;
  v36 = v73;
  v73 = 0;
  *(_QWORD *)(v31 + 80) = v36;
  if (v32)
    std::default_delete<MIDIDriverKitClient::State>::operator()[abi:ne180100](v32);
  *(_QWORD *)(v31 + 88) = 0;
  *(_QWORD *)(v31 + 96) = 0;
  *(_BYTE *)(v31 + 112) = 0;
  *(_QWORD *)(v31 + 104) = 0;
  reference = (CFStringRef *)&off_1E98B7260;
  *(_QWORD *)reference_8 = v31;
  *(_QWORD *)&reference_8[16] = &reference;
  std::__function::__value_func<void ()(unsigned int,std::span<unsigned int const,18446744073709551615ul>)>::operator=[abi:ne180100]((_QWORD *)(v36 + 24), (uint64_t)&reference);
  p_reference = *(CFStringRef ***)&reference_8[16];
  if (*(CFStringRef ***)&reference_8[16] == &reference)
  {
    v38 = 4;
    p_reference = &reference;
  }
  else
  {
    if (!*(_QWORD *)&reference_8[16])
      goto LABEL_35;
    v38 = 5;
  }
  ((void (*)(void))(*p_reference)[v38])();
LABEL_35:
  errorString = (CFStringRef)&off_1E98B7218;
  v82 = (_DWORD *)v31;
  p_errorString = &errorString;
  v39 = *(_QWORD *)(v31 + 80);
  v40 = v39 + 56;
  v41 = *(_QWORD **)(v39 + 80);
  *(_QWORD *)(v39 + 80) = 0;
  if (v41 == (_QWORD *)(v39 + 56))
  {
    v42 = 4;
    v41 = (_QWORD *)(v39 + 56);
  }
  else
  {
    if (!v41)
      goto LABEL_42;
    v42 = 5;
  }
  (*(void (**)(void))(*v41 + 8 * v42))();
  if (!p_errorString)
  {
    *(_QWORD *)(v39 + 80) = 0;
    goto LABEL_48;
  }
  if (p_errorString != &errorString)
  {
    *(_QWORD *)(v39 + 80) = p_errorString;
    goto LABEL_48;
  }
LABEL_42:
  *(_QWORD *)(v39 + 80) = v40;
  ((void (*)(CFStringRef *, uint64_t))errorString->length)(&errorString, v40);
  v43 = p_errorString;
  if (p_errorString == &errorString)
  {
    v44 = 4;
    v43 = &errorString;
  }
  else
  {
    if (!p_errorString)
      goto LABEL_48;
    v44 = 5;
  }
  (*((void (**)(void))&(*v43)->isa + v44))();
LABEL_48:
  MIDIDriverKitClient::~MIDIDriverKitClient((MIDIDriverKitClient *)&v71);
  v46 = v7[2].u64[0];
  v47 = (uint64_t *)v7[1].i64[1];
  if ((unint64_t)v47 >= v46)
  {
    v49 = v7[1].i64[0];
    v50 = ((uint64_t)v47 - v49) >> 3;
    if ((unint64_t)(v50 + 1) >> 61)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v51 = v46 - v49;
    v52 = v51 >> 2;
    if (v51 >> 2 <= (unint64_t)(v50 + 1))
      v52 = v50 + 1;
    if ((unint64_t)v51 >= 0x7FFFFFFFFFFFFFF8)
      v53 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v53 = v52;
    *(_QWORD *)&v79 = v7 + 2;
    if (v53)
      v53 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v53);
    else
      v54 = 0;
    v55 = (uint64_t *)(v53 + 8 * v50);
    v56 = v53 + 8 * v54;
    *(_QWORD *)&reference_8[16] = v56;
    *v55 = v31;
    v48 = v55 + 1;
    *(_QWORD *)&reference_8[8] = v55 + 1;
    v58 = (_QWORD *)v7[1].i64[0];
    v57 = (_QWORD *)v7[1].i64[1];
    if (v57 == v58)
    {
      v60 = vdupq_n_s64((unint64_t)v57);
    }
    else
    {
      do
      {
        v59 = *--v57;
        *v57 = 0;
        *--v55 = v59;
      }
      while (v57 != v58);
      v60 = v7[1];
      v56 = *(_QWORD *)&reference_8[16];
      v48 = *(_QWORD **)&reference_8[8];
    }
    v7[1].i64[0] = (uint64_t)v55;
    v7[1].i64[1] = (uint64_t)v48;
    *(int64x2_t *)reference_8 = v60;
    v61 = v7[2].i64[0];
    v7[2].i64[0] = v56;
    *(_QWORD *)&reference_8[16] = v61;
    reference = (CFStringRef *)v60.i64[0];
    std::__split_buffer<std::unique_ptr<MIDIDriverPlugin>>::~__split_buffer((uint64_t)&reference);
  }
  else
  {
    *v47 = v31;
    v48 = v47 + 1;
  }
  v7[1].i64[1] = (uint64_t)v48;
  if (v2)
    IOObjectRelease(v2);
  if ((*v3)->i8[0])
  {
    v62 = (*v3)[1].i64[1];
    LODWORD(errorString) = MIDIDriverMgr::GetDriverDeviceList(*(MIDIDriverMgr **)(v62 - 8), v45);
    reference = &errorString;
    (*(void (**)(_QWORD))(**(_QWORD **)(v62 - 8) + 88))(*(_QWORD *)(v62 - 8));
    MIDIDeviceListDispose((MIDIDeviceListRef)errorString);
  }
  if (v6)
    (*(void (**)(uint64_t *))(*v5 + 24))(v5);
  if (v2)
  {
    IOObjectRelease(v2);
    IOObjectRelease(v2);
  }
}

void sub_1D4E90158(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, io_object_t a15, io_object_t a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,char *a24,char a25)
{
  uint64_t v25;
  int v26;
  void *v27;
  uint64_t v28;
  char *v31;
  uint64_t v32;
  void *v33;
  NSObject *v34;
  NSObject *v35;
  NSObject *v36;
  uint64_t v37;

  if (!a2)
    _Unwind_Resume(exception_object);
  __cxa_free_exception(v27);
  v31 = a24;
  if (a24 == &a21)
  {
    v32 = 4;
    v31 = &a21;
  }
  else
  {
    if (!a24)
      goto LABEL_9;
    v32 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v31 + 8 * v32))();
LABEL_9:
  applesauce::iokit::io_object_holder::~io_object_holder(&a16);
  applesauce::iokit::io_object_holder::~io_object_holder(&a15);
  if (v26)
    (*(void (**)(uint64_t))(*(_QWORD *)v25 + 24))(v25);
  v33 = __cxa_begin_catch(exception_object);
  midiDriverKitLog();
  v34 = objc_retainAutorelease((id)midiDriverKitLog(void)::category);
  v35 = v34;
  if (a2 == 2)
  {
    v36 = v34;
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
    {
      v37 = (*(uint64_t (**)(void *))(*(_QWORD *)v33 + 16))(v33);
      *(_DWORD *)(v28 - 128) = 136315650;
      *(_QWORD *)(v28 - 124) = "MIDIDriverPlugin_DriverKit.mm";
      *(_WORD *)(v28 - 116) = 1024;
      *(_DWORD *)(v28 - 114) = 1620;
      *(_WORD *)(v28 - 110) = 2080;
      *(_QWORD *)(v28 - 108) = v37;
      _os_log_impl(&dword_1D4E88000, v36, OS_LOG_TYPE_ERROR, "%25s:%-5d %s", (uint8_t *)(v28 - 128), 0x1Cu);
    }

  }
  else if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)(v28 - 128) = 136315394;
    *(_QWORD *)(v28 - 124) = "MIDIDriverPlugin_DriverKit.mm";
    *(_WORD *)(v28 - 116) = 1024;
    *(_DWORD *)(v28 - 114) = 1623;
    _os_log_impl(&dword_1D4E88000, v35, OS_LOG_TYPE_ERROR, "%25s:%-5d An unknown error occurred!", (uint8_t *)(v28 - 128), 0x12u);
  }
  __cxa_end_catch();
  JUMPOUT(0x1D4E90000);
}

void sub_1D4E90560(uint64_t a1, int a2)
{
  io_object_t v2;

  if (a2)
  {
    if (v2)
      IOObjectRelease(v2);
    JUMPOUT(0x1D4E90294);
  }
  JUMPOUT(0x1D4E9035CLL);
}

void sub_1D4E9057C()
{
  JUMPOUT(0x1D4E9035CLL);
}

void MIDIDriverKitClient::getProperty<unsigned char>(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  unsigned int v8;
  uint64_t PropertySize;
  size_t v13;
  char v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int PropertyData;
  char v19;
  void *v20;
  void *__p[2];
  uint64_t v22;

  v8 = a4;
  PropertySize = MIDIDriverKitClient::getPropertySize(*(_DWORD *)(a2 + 4), a3, a4, a4, a5, a6, a7, a8);
  v13 = PropertySize;
  if (v14)
  {
    std::vector<unsigned char>::vector(__p, PropertySize);
    PropertyData = MIDIDriverKitClient::getPropertyData(*(_DWORD *)(a2 + 4), a3, v8, __p[0], v13, v15, v16, v17);
    if (v19)
    {
      *(_OWORD *)a1 = *(_OWORD *)__p;
      *(_QWORD *)(a1 + 16) = v22;
      *(_BYTE *)(a1 + 24) = 1;
    }
    else
    {
      *(_DWORD *)a1 = PropertyData;
      v20 = __p[0];
      *(_BYTE *)(a1 + 24) = 0;
      if (v20)
      {
        __p[1] = v20;
        operator delete(v20);
      }
    }
  }
  else
  {
    *(_DWORD *)a1 = PropertySize;
    *(_BYTE *)(a1 + 24) = 0;
  }
}

void sub_1D4E9064C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

applesauce::CF::StringRef *applesauce::CF::StringRef::StringRef(applesauce::CF::StringRef *this, CFTypeRef cf)
{
  CFTypeID v3;
  void *exception;

  *(_QWORD *)this = cf;
  if (cf)
  {
    v3 = CFGetTypeID(cf);
    if (v3 != CFStringGetTypeID())
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x1D826B7EC](exception, "Could not construct");
    }
  }
  return this;
}

void sub_1D4E906E4(_Unwind_Exception *a1)
{
  CFTypeRef *v1;
  void *v2;

  __cxa_free_exception(v2);
  if (*v1)
    CFRelease(*v1);
  _Unwind_Resume(a1);
}

void MIDIDriverKitClient::~MIDIDriverKitClient(MIDIDriverKitClient *this)
{
  id *v2;
  id v3;
  NSObject *v4;
  uint64_t v5;
  void *v6;
  NSObject *v7;
  uint64_t v8;
  char v9;
  uint64_t block;
  uint64_t v11;
  uint64_t (*v12)();
  void *v13;
  char *v14;

  IOConnectRelease(*((_DWORD *)this + 1));
  v2 = (id *)*((_QWORD *)this + 1);
  if (v2)
  {
    v3 = *v2;
    caulk::mach::os_object<NSObject  {objcproto15OS_os_eventlink}* {__strong}>::get(*v2);
    v4 = objc_claimAutoreleasedReturnValue();
    v5 = MEMORY[0x1E0C809B0];
    block = MEMORY[0x1E0C809B0];
    v11 = 3221225472;
    v12 = ___ZN10applesauce8dispatch2v19sync_implIZN19MIDIDriverKitClientD1EvEUlvE_EEvPU28objcproto17OS_dispatch_queue8NSObjectOT_NSt3__117integral_constantIbLb1EEE_block_invoke;
    v13 = &__block_descriptor_40_e5_v8__0l;
    v14 = &v9;
    dispatch_sync(v4, &block);

    v6 = *(void **)(*((_QWORD *)this + 1) + 8);
    caulk::mach::os_object<NSObject  {objcproto15OS_os_eventlink}* {__strong}>::get(v6);
    v7 = objc_claimAutoreleasedReturnValue();
    block = v5;
    v11 = 3221225472;
    v12 = ___ZN10applesauce8dispatch2v19sync_implIZN19MIDIDriverKitClientD1EvEUlvE0_EEvPU28objcproto17OS_dispatch_queue8NSObjectOT_NSt3__117integral_constantIbLb1EEE_block_invoke;
    v13 = &__block_descriptor_40_e5_v8__0l;
    v14 = &v9;
    dispatch_sync(v7, &block);

    v8 = *((_QWORD *)this + 1);
    *((_QWORD *)this + 1) = 0;
    if (v8)
      std::default_delete<MIDIDriverKitClient::State>::operator()[abi:ne180100](v8);
  }
  else
  {
    *((_QWORD *)this + 1) = 0;
  }
  if (*(_DWORD *)this)
    IOObjectRelease(*(_DWORD *)this);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(unint64_t a1)
{
  if (a1 >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(8 * a1);
}

uint64_t std::__split_buffer<std::unique_ptr<MIDIDriverPlugin>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;
    v4 = *(_QWORD *)(i - 8);
    *(_QWORD *)(i - 8) = 0;
    if (v4)
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

MIDIDeviceListRef **applesauce::raii::v1::detail::ScopeGuard<MIDIDriverKitPluginRegistrar::handleServiceMatch(applesauce::iokit::io_object_holder)::$_0,applesauce::raii::v1::detail::StackExitPolicy>::~ScopeGuard(MIDIDeviceListRef **a1)
{
  MIDIDeviceListDispose(**a1);
  return a1;
}

void std::default_delete<MIDIDriverKitClient::State>::operator()[abi:ne180100](uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  void *v7;
  id v8;

  v2 = (_QWORD *)(a1 + 56);
  v3 = *(_QWORD **)(a1 + 80);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  v5 = *(_QWORD **)(a1 + 48);
  if (v5 == (_QWORD *)(a1 + 24))
  {
    v6 = 4;
    v5 = (_QWORD *)(a1 + 24);
  }
  else
  {
    if (!v5)
    {
LABEL_11:

      v7 = *(void **)(a1 + 8);
      *(_QWORD *)(a1 + 8) = 0;

      v8 = *(id *)a1;
      *(_QWORD *)a1 = 0;

      JUMPOUT(0x1D826BA98);
    }
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
  goto LABEL_11;
}

_QWORD *std::__function::__value_func<void ()(unsigned int,std::span<unsigned int const,18446744073709551615ul>)>::operator=[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;

  v4 = (_QWORD *)a1[3];
  a1[3] = 0;
  if (v4 == a1)
  {
    v5 = 4;
    v4 = a1;
  }
  else
  {
    if (!v4)
      goto LABEL_6;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_6:
  v6 = *(_QWORD *)(a2 + 24);
  if (v6)
  {
    if (v6 == a2)
    {
      a1[3] = a1;
      (*(void (**)(_QWORD, _QWORD *))(**(_QWORD **)(a2 + 24) + 24))(*(_QWORD *)(a2 + 24), a1);
    }
    else
    {
      a1[3] = v6;
      *(_QWORD *)(a2 + 24) = 0;
    }
  }
  else
  {
    a1[3] = 0;
  }
  return a1;
}

void _ZNSt3__110__function6__funcIZN26MIDIDriverPlugin_DriverKitC1EO19MIDIDriverKitClientPK10__CFStringS7_EUlT_E_NS_9allocatorIS9_EEFvNS3_16ConfigChangeInfoEEED0Ev()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *_ZNKSt3__110__function6__funcIZN26MIDIDriverPlugin_DriverKitC1EO19MIDIDriverKitClientPK10__CFStringS7_EUlT_E_NS_9allocatorIS9_EEFvNS3_16ConfigChangeInfoEEE7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E98B7218;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN26MIDIDriverPlugin_DriverKitC1EO19MIDIDriverKitClientPK10__CFStringS7_EUlT_E_NS_9allocatorIS9_EEFvNS3_16ConfigChangeInfoEEE7__cloneEPNS0_6__baseISD_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E98B7218;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN26MIDIDriverPlugin_DriverKitC1EO19MIDIDriverKitClientPK10__CFStringS7_EUlT_E_NS_9allocatorIS9_EEFvNS3_16ConfigChangeInfoEEEclEOSC_(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t result;
  MIDIDriverPlugin *v12;
  void *exception;
  __int128 v14;
  MIDIDeviceListRef devList;
  _BYTE v16[24];
  uint64_t input[2];
  uint64_t v18;

  v14 = *(_OWORD *)a2;
  v8 = *(_QWORD *)(a2 + 16);
  v9 = *(_QWORD *)(a1 + 8);
  v10 = *(unsigned __int8 *)(v9 + 112);
  if (*(_BYTE *)(v9 + 112))
    MIDIDriverPlugin_DriverKit::StopMIDI(*(MIDIDriverPlugin_DriverKit **)(a1 + 8), a2, a3, a4, a5, a6, a7, a8);
  *(_OWORD *)input = v14;
  v18 = v8;
  result = MIDIDriverKitClient::call((uint64_t)v16, *(_DWORD *)(v9 + 76), 0xEu, input, 3u, 0, 0, a8, 0, 0, 0, 0);
  if (!v16[16])
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Failed to perform config change");
  }
  if (v10)
  {
    devList = MIDIDriverMgr::GetDriverDeviceList((MIDIDriverMgr *)v9, v12);
    MIDIDriverPlugin_DriverKit::StartMIDI((mach_port_t *)v9, devList);
    return MIDIDeviceListDispose(devList);
  }
  return result;
}

void sub_1D4E90B7C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, __int128 a11, __int128 a12, int a13, MIDIDeviceListRef devList, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,char a23)
{
  __break(1u);
}

void sub_1D4E90C34(void *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4E90BF4);
}

void sub_1D4E90C58()
{
  __cxa_end_catch();
  JUMPOUT(0x1D4E90BA0);
}

uint64_t MIDIDriverPlugin_DriverKit::StopMIDI(MIDIDriverPlugin_DriverKit *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  uint64_t v9;
  unsigned int *v10;
  unsigned int *v11;
  unsigned int *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int *v23;
  uint64_t v24;
  char v26[24];

  v9 = *((_QWORD *)this + 11);
  v10 = (unsigned int *)*((_QWORD *)this + 12);
  if ((unsigned int *)v9 != v10)
  {
    v11 = (unsigned int *)(v9 + 136);
    v12 = (unsigned int *)MEMORY[0x1E0C83DA0];
    do
    {
      MIDIDriverPlugin_DriverKit::DeviceIO::stop((MIDIDriverPlugin_DriverKit::DeviceIO *)(v11 - 26));
      caulk::mach::os_eventlink::dissociate((caulk::mach::os_eventlink *)(v11 + 26));
      MIDIDriverPlugin_DriverKit::withIOThread(*((_DWORD *)this + 19), *(v11 - 26), 0x11u, v13, v14, v15, v16, v17);
      v18 = MEMORY[0x1D826B60C](*((unsigned int *)this + 19), *(v11 - 24), *v12, *((_QWORD *)v11 - 11));
      throw_on_error(v18, "could not unmap shared memory");
      v19 = MEMORY[0x1D826B60C](*((unsigned int *)this + 19), *(v11 - 18), *v12, *((_QWORD *)v11 - 8));
      throw_on_error(v19, "could not unmap shared memory");
      v20 = MEMORY[0x1D826B60C](*((unsigned int *)this + 19), *(v11 - 12), *v12, *((_QWORD *)v11 - 5));
      throw_on_error(v20, "could not unmap shared memory");
      v21 = MEMORY[0x1D826B60C](*((unsigned int *)this + 19), *v11, *v12, *((_QWORD *)v11 + 1));
      throw_on_error(v21, "could not unmap shared memory");
      v22 = MEMORY[0x1D826B60C](*((unsigned int *)this + 19), v11[6], *v12, *((_QWORD *)v11 + 4));
      throw_on_error(v22, "could not unmap shared memory");
      v23 = v11 + 40;
      v11 += 74;
    }
    while (v23 != v10);
    v24 = *((_QWORD *)this + 11);
    v9 = *((_QWORD *)this + 12);
    if (v9 != v24)
    {
      do
      {
        v9 -= 296;
        std::__destroy_at[abi:ne180100]<MIDIDriverPlugin_DriverKit::Device,0>(v9);
      }
      while (v9 != v24);
      v9 = v24;
    }
  }
  *((_QWORD *)this + 12) = v9;
  MIDIDriverKitClient::call((uint64_t)v26, *((_DWORD *)this + 19), 3u, 0, 0, 0, 0, a8, 0, 0, 0, 0);
  *((_BYTE *)this + 112) = 0;
  return 0;
}

uint64_t MIDIDriverPlugin_DriverKit::StartMIDI(mach_port_t *this, MIDIDeviceListRef a2)
{
  MIDIDriverPlugin_DriverKit *v3;
  DeviceList *v4;
  const __CFData *v5;
  UInt8 *BytePtr;
  size_t Length;
  int v8;
  ItemCount NumberOfDevices;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  ItemCount v14;
  MIDIDeviceRef v15;
  ItemCount i;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  unsigned int *v22;
  unsigned int *v23;
  const __CFDictionary *v24;
  const __CFString *v25;
  const __CFString *v26;
  const __CFString *v27;
  const __CFString *v28;
  const __CFString *v29;
  const __CFString *v30;
  MIDIDriverPlugin_DriverKit *v31;
  const __CFNumber *v32;
  __int16 v33;
  int v34;
  int v35;
  unsigned int v36;
  unint64_t v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  char *v45;
  uint64_t v46;
  char *v47;
  uint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  void *v52;
  void *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  unsigned int *v63;
  unsigned int *v64;
  unsigned int v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  void *v70;
  unsigned int *v71;
  unsigned int *v72;
  uint64_t v73;
  unsigned int *v74;
  unsigned int v75;
  std::string::size_type v76;
  MIDIDriverPlugin_DriverKit *Source;
  uint64_t v78;
  int v79;
  char *v80;
  _QWORD *v81;
  char *v82;
  uint64_t v83;
  unint64_t v84;
  uint64_t v85;
  unint64_t v86;
  char *v87;
  std::string::size_type *v88;
  std::string::size_type v89;
  unsigned int v90;
  unsigned int *v91;
  unsigned int v92;
  uint64_t v93;
  MIDIDriverPlugin_DriverKit *Destination;
  uint64_t v95;
  char *v96;
  uint64_t v97;
  uint64_t v98;
  unint64_t v99;
  uint64_t v100;
  unint64_t v101;
  char *v102;
  char *v103;
  char *v104;
  char *v105;
  char *v106;
  uint64_t v107;
  unint64_t v108;
  unint64_t v109;
  char *v110;
  char *v111;
  char *v112;
  char *v113;
  char *v114;
  char *v115;
  uint64_t v116;
  char *v117;
  char *v118;
  char *v119;
  void *v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  int v125;
  int v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  int v133;
  uint64_t Buffer;
  void *v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  int v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  int v148;
  uint64_t v149;
  void *v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  int v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  _QWORD *v160;
  __int128 *v161;
  uintptr_t v162;
  uintptr_t v163;
  __int128 *v164;
  uintptr_t v165;
  uintptr_t v166;
  id v167;
  BOOL v168;
  void *v169;
  __int128 v170;
  __int128 v171;
  __int128 v172;
  __int128 v173;
  __int128 v174;
  __int128 v175;
  __int128 v176;
  __int128 v177;
  uint64_t v178;
  void *v179;
  void **v180;
  __int128 v181;
  uint64_t v182;
  void **v183;
  __int128 v184;
  void *v185;
  void *v186;
  uint64_t v187;
  void *exception;
  void *v190;
  int v191;
  std::string *v192;
  void *v193;
  void *v194;
  __CFArray *cf;
  void *v196;
  unsigned int *v197;
  char **v198;
  unsigned int *v199;
  uint64_t v200;
  char **v201;
  char **v202;
  unsigned int *v203;
  MIDIDeviceRef device;
  unsigned int v205[2];
  unsigned int *v206;
  unsigned int *v207;
  void *v208;
  int v209;
  void *ref1;
  uint64_t v212;
  char v213[24];
  __CFArray *v214;
  MIDIEntityRef newEntity;
  _BYTE v216[184];
  __int128 v217;
  __int128 v218;
  __int128 v219;
  __int128 v220;
  void *__p[4];
  _QWORD v222[2];
  __int128 v223;
  uint64_t v224;
  char v225;
  uint64_t inputStruct;
  std::string v227;
  const __CFDictionary *v228;
  char v229;
  std::string input;
  uint64_t v231;

  v3 = (MIDIDriverPlugin_DriverKit *)this;
  v231 = *MEMORY[0x1E0C80C00];
  *((_BYTE *)this + 112) = 1;
  v4 = (DeviceList *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<DeviceList>::sRTTI, a2);
  if (!v4)
    return 4294967246;
  v214 = DeviceList::ToPList(v4);
  cf = v214;
  v5 = IOCFSerialize(v214, 0);
  BytePtr = (UInt8 *)CFDataGetBytePtr(v5);
  Length = CFDataGetLength(v5);
  MIDIDriverKitClient::call((uint64_t)v213, *((_DWORD *)v3 + 19), 2u, 0, 0, BytePtr, Length, v8, 0, 0, 0, 0);
  NumberOfDevices = MIDIDeviceListGetNumberOfDevices(a2);
  v14 = NumberOfDevices;
  if (NumberOfDevices)
  {
    v15 = MIDIDeviceListGetDevice(a2, NumberOfDevices - 1);
    for (i = v14 - 2; ; --i)
    {
      MIDISetupRemoveDevice(v15);
      MIDIDeviceDispose(v15);
      if (i == -1)
        break;
      v15 = MIDIDeviceListGetDevice(a2, i);
    }
  }
  v17 = (uint64_t)v3 + 72;
  MIDIDriverKitClient::getProperty<unsigned int>((uint64_t)v216, (uint64_t)v3 + 72, 1u, 1684370979, v10, v11, v12, v13);
  if (v216[24])
  {
    v194 = *(void **)v216;
    v197 = *(unsigned int **)&v216[8];
    if (*(_QWORD *)v216 != *(_QWORD *)&v216[8])
    {
      v22 = *(unsigned int **)v216;
      v212 = (uint64_t)v3 + 72;
      do
      {
        *(_QWORD *)v205 = *v22;
        MIDIDriverPlugin_DriverKit::getCFProperty<applesauce::CF::DictionaryRef>((uint64_t)&v228, (uint64_t)v3, *v22, 1886548068, v18, v19, v20, v21);
        if (!v229)
          goto LABEL_169;
        v23 = (unsigned int *)operator new();
        v199 = v22;
        v24 = v228;
        if (!v228)
        {
          exception = __cxa_allocate_exception(0x10uLL);
          MEMORY[0x1D826B7EC](exception, "Could not construct");
        }
        v25 = (const __CFString *)applesauce::CF::details::at_key<__CFString const* const&>(v228, kMIDIPropertyName);
        if (v25)
          v26 = v25;
        else
          v26 = CFSTR("no name");
        v27 = (const __CFString *)applesauce::CF::details::at_key<__CFString const* const&>(v24, kMIDIPropertyManufacturer);
        if (v27)
          v28 = v27;
        else
          v28 = CFSTR("no manufacturer");
        v29 = (const __CFString *)applesauce::CF::details::at_key<__CFString const* const&>(v24, kMIDIPropertyModel);
        if (v29)
          v30 = v29;
        else
          v30 = CFSTR("no model");
        MIDIDevice::MIDIDevice((MIDIDevice *)v23, v3, v26, v28, v30);
        v31 = (MIDIDriverPlugin_DriverKit *)v23[2];
        v32 = (const __CFNumber *)applesauce::CF::details::at_key<__CFString const* const&>(v24, kMIDIPropertyOffline);
        if (v32)
        {
          v33 = applesauce::CF::convert_as<BOOL,0>(v32);
          v34 = v33;
          v35 = HIBYTE(v33);
        }
        else
        {
          v35 = 0;
          v34 = 0;
        }
        v36 = v34 | (v35 << 8);
        if (v36 <= 0x100)
          LOBYTE(v36) = 0;
        MIDIObjectSetIntegerProperty((MIDIObjectRef)v31, kMIDIPropertyOffline, v36 != 0);
        MIDIDriverPlugin_DriverKit::syncAllPropertiesLocal(v3, (int)v31, v205[0]);
        *(_DWORD *)v216 = (_DWORD)v31;
        *(_DWORD *)&v216[4] = v205[0];
        memset(&v216[8], 0, 28);
        memset(&v216[40], 0, 144);
        v217 = 0u;
        v218 = 0u;
        v219 = 0u;
        v220 = 0u;
        memset(__p, 0, 25);
        v222[0] = 0;
        v222[1] = 0;
        v37 = *((_QWORD *)v3 + 12);
        v38 = *((_QWORD *)v3 + 13);
        if (v37 >= v38)
        {
          v40 = *((_QWORD *)v3 + 11);
          v41 = 0x14C1BACF914C1BADLL * ((uint64_t)(v37 - v40) >> 3);
          v42 = v41 + 1;
          if ((unint64_t)(v41 + 1) > 0xDD67C8A60DD67CLL)
            std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
          v43 = 0x14C1BACF914C1BADLL * ((uint64_t)(v38 - v40) >> 3);
          if (2 * v43 > v42)
            v42 = 2 * v43;
          if (v43 >= 0x6EB3E45306EB3ELL)
            v44 = 0xDD67C8A60DD67CLL;
          else
            v44 = v42;
          if (v44)
          {
            if (v44 > 0xDD67C8A60DD67CLL)
              std::__throw_bad_array_new_length[abi:ne180100]();
            v45 = (char *)operator new(296 * v44);
          }
          else
          {
            v45 = 0;
          }
          v46 = (uint64_t)&v45[296 * v41];
          v47 = &v45[296 * v44];
          v48 = std::construct_at[abi:ne180100]<MIDIDriverPlugin_DriverKit::Device,MIDIDriverPlugin_DriverKit::Device,MIDIDriverPlugin_DriverKit::Device*>(v46, (uint64_t)v216);
          v39 = v48 + 296;
          v50 = (char *)*((_QWORD *)v3 + 11);
          v49 = (char *)*((_QWORD *)v3 + 12);
          if (v49 == v50)
          {
            *((_QWORD *)v3 + 11) = v48;
            *((_QWORD *)v3 + 12) = v39;
            *((_QWORD *)v3 + 13) = v47;
            if (!v49)
              goto LABEL_44;
          }
          else
          {
            do
            {
              v49 -= 296;
              v48 = std::construct_at[abi:ne180100]<MIDIDriverPlugin_DriverKit::Device,MIDIDriverPlugin_DriverKit::Device,MIDIDriverPlugin_DriverKit::Device*>(v48 - 296, (uint64_t)v49);
            }
            while (v49 != v50);
            v51 = (char *)*((_QWORD *)v3 + 11);
            v49 = (char *)*((_QWORD *)v3 + 12);
            *((_QWORD *)v3 + 11) = v48;
            *((_QWORD *)v3 + 12) = v39;
            *((_QWORD *)v3 + 13) = v47;
            if (v49 != v51)
            {
              do
              {
                v49 -= 296;
                std::__destroy_at[abi:ne180100]<MIDIDriverPlugin_DriverKit::Device,0>((uint64_t)v49);
              }
              while (v49 != v51);
              v49 = v51;
            }
            if (!v49)
              goto LABEL_44;
          }
          operator delete(v49);
        }
        else
        {
          v39 = std::construct_at[abi:ne180100]<MIDIDriverPlugin_DriverKit::Device,MIDIDriverPlugin_DriverKit::Device,MIDIDriverPlugin_DriverKit::Device*>(v37, (uint64_t)v216)+ 296;
          *((_QWORD *)v3 + 12) = v39;
        }
LABEL_44:
        *((_QWORD *)v3 + 12) = v39;
        caulk::thread::~thread((caulk::thread *)v222);
        if (SHIBYTE(__p[2]) < 0)
          operator delete(__p[0]);
        caulk::mach::details::release_os_object(*((caulk::mach::details **)&v220 + 1), v52);
        if (SBYTE7(v220) < 0)
          operator delete((void *)v219);
        caulk::mach::details::release_os_object(*((caulk::mach::details **)&v218 + 1), v53);
        *(_QWORD *)&v223 = &v216[8];
        std::vector<MIDIDriverPlugin_DriverKit::Entity>::__destroy_vector::operator()[abi:ne180100]((void ***)&v223);
        v54 = *((_QWORD *)v3 + 12);
        MIDIDriverKitClient::getProperty<unsigned int>((uint64_t)v216, v17, v205[0], 1701737507, v55, v56, v57, v58);
        ref1 = (void *)(v54 - 296);
        v200 = v54;
        if (v216[24])
        {
          v63 = *(unsigned int **)&v216[8];
          v196 = *(void **)v216;
          if (*(_QWORD *)v216 != *(_QWORD *)&v216[8])
          {
            v201 = (char **)(v54 - 280);
            v198 = (char **)(v54 - 288);
            v202 = (char **)(v54 - 272);
            v203 = *(unsigned int **)&v216[8];
            v64 = *(unsigned int **)v216;
            device = v31;
            while (2)
            {
              v207 = v64;
              v65 = *v64;
              MIDIDriverKitClient::getProperty<unsigned int>((uint64_t)v216, v17, *v64, 1936876323, v59, v60, v61, v62);
              v209 = v216[24];
              v70 = (void *)*(unsigned int *)v216;
              v72 = *(unsigned int **)v216;
              v71 = *(unsigned int **)&v216[8];
              if (v216[24])
                v70 = *(void **)v216;
              v208 = v70;
              if (v216[24])
                v73 = *(_QWORD *)&v216[8];
              else
                v73 = 1;
              MIDIDriverKitClient::getProperty<unsigned int>((uint64_t)v216, v17, v65, 1685287971, v66, v67, v68, v69);
              if (!v216[24])
                goto LABEL_132;
              v206 = *(unsigned int **)v216;
              if (v209)
              {
                v74 = *(unsigned int **)&v216[8];
                MIDIDriverPlugin_DriverKit::getCFProperty<applesauce::CF::StringRef>((uint64_t)&v227, (uint64_t)v3, v65, 1835950445, v59, v60, v61, v62);
                if (v227.__r_.__value_.__s.__data_[16])
                {
                  newEntity = 0;
                  MIDIDeviceNewEntity(device, (CFStringRef)v227.__r_.__value_.__l.__data_, kMIDIProtocol_2_0, 1u, v71 - v72, v74 - v206, &newEntity);
                  MIDIDriverPlugin_DriverKit::syncAllPropertiesLocal(v3, newEntity, v65);
                  MIDIDriverPlugin_DriverKit::syncAllPropertiesRemote(v3, (MIDIDriverPlugin_DriverKit *)newEntity, v65);
                  *(_DWORD *)v216 = newEntity;
                  *(_DWORD *)&v216[4] = v65;
                  memset(&v216[8], 0, 48);
                  if (v72 != v71)
                  {
                    v75 = 0;
                    do
                    {
                      v76 = *v72;
                      Source = (MIDIDriverPlugin_DriverKit *)MIDIEntityGetSource(newEntity, v75);
                      v78 = Source;
                      inputStruct = Source;
                      input.__r_.__value_.__r.__words[0] = v76;
                      input.__r_.__value_.__l.__size_ = 1919120504;
                      MIDIDriverKitClient::call((uint64_t)&v223, *((_DWORD *)v3 + 19), 8u, (uint64_t *)&input, 2u, &inputStruct, 8uLL, v79, 0, 0, 0, 0);
                      MIDIDriverPlugin_DriverKit::syncAllPropertiesLocal(v3, (int)Source, v76);
                      MIDIDriverPlugin_DriverKit::syncAllPropertiesRemote(v3, Source, v76);
                      v80 = *(char **)&v216[16];
                      if (*(_QWORD *)&v216[16] >= *(_QWORD *)&v216[24])
                      {
                        v82 = *(char **)&v216[8];
                        v83 = (uint64_t)(*(_QWORD *)&v216[16] - *(_QWORD *)&v216[8]) >> 3;
                        v84 = v83 + 1;
                        if ((unint64_t)(v83 + 1) >> 61)
                          std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
                        v85 = *(_QWORD *)&v216[24] - *(_QWORD *)&v216[8];
                        if ((uint64_t)(*(_QWORD *)&v216[24] - *(_QWORD *)&v216[8]) >> 2 > v84)
                          v84 = v85 >> 2;
                        if ((unint64_t)v85 >= 0x7FFFFFFFFFFFFFF8)
                          v86 = 0x1FFFFFFFFFFFFFFFLL;
                        else
                          v86 = v84;
                        if (v86)
                        {
                          if (v86 >> 61)
                            std::__throw_bad_array_new_length[abi:ne180100]();
                          v87 = (char *)operator new(8 * v86);
                        }
                        else
                        {
                          v87 = 0;
                        }
                        v88 = (std::string::size_type *)&v87[8 * v83];
                        *v88 = v78 | (v76 << 32);
                        v81 = v88 + 1;
                        if (v80 == v82)
                        {
                          v3 = (MIDIDriverPlugin_DriverKit *)this;
                        }
                        else
                        {
                          v3 = (MIDIDriverPlugin_DriverKit *)this;
                          do
                          {
                            v89 = *((_QWORD *)v80 - 1);
                            v80 -= 8;
                            *--v88 = v89;
                          }
                          while (v80 != v82);
                          v80 = *(char **)&v216[8];
                        }
                        *(_QWORD *)&v216[8] = v88;
                        *(_QWORD *)&v216[16] = v81;
                        *(_QWORD *)&v216[24] = &v87[8 * v86];
                        if (v80)
                          operator delete(v80);
                      }
                      else
                      {
                        **(_QWORD **)&v216[16] = Source | (v76 << 32);
                        v81 = v80 + 8;
                      }
                      ++v75;
                      *(_QWORD *)&v216[16] = v81;
                      ++v72;
                    }
                    while (v72 != (unsigned int *)v73);
                  }
                  if (v206 != v74)
                  {
                    v90 = 0;
                    v91 = v206;
                    do
                    {
                      v92 = *v91;
                      MIDIDriverKitClient::getProperty<unsigned char>((uint64_t)&v223, v212, *v91, 1919120504, v59, v60, v61, v62);
                      if (v225)
                      {
                        v93 = *(_QWORD *)v223;
                        operator delete((void *)v223);
                      }
                      else
                      {
                        v93 = v223;
                      }
                      Destination = (MIDIDriverPlugin_DriverKit *)MIDIEntityGetDestination(newEntity, v90);
                      MIDIDriverPlugin_DriverKit::syncAllPropertiesLocal(v3, (int)Destination, v92);
                      MIDIDriverPlugin_DriverKit::syncAllPropertiesRemote(v3, Destination, v92);
                      v95 = *(_QWORD *)&v216[40];
                      if (*(_QWORD *)&v216[40] >= *(_QWORD *)&v216[48])
                      {
                        v97 = *(_QWORD *)&v216[32];
                        v98 = (uint64_t)(*(_QWORD *)&v216[40] - *(_QWORD *)&v216[32]) >> 4;
                        v99 = v98 + 1;
                        if ((unint64_t)(v98 + 1) >> 60)
                          std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
                        v100 = *(_QWORD *)&v216[48] - *(_QWORD *)&v216[32];
                        if ((uint64_t)(*(_QWORD *)&v216[48] - *(_QWORD *)&v216[32]) >> 3 > v99)
                          v99 = v100 >> 3;
                        if ((unint64_t)v100 >= 0x7FFFFFFFFFFFFFF0)
                          v101 = 0xFFFFFFFFFFFFFFFLL;
                        else
                          v101 = v99;
                        if (v101)
                        {
                          if (v101 >> 60)
                            std::__throw_bad_array_new_length[abi:ne180100]();
                          v102 = (char *)operator new(16 * v101);
                        }
                        else
                        {
                          v102 = 0;
                        }
                        v103 = &v102[16 * v98];
                        *(_DWORD *)v103 = (_DWORD)Destination;
                        *((_DWORD *)v103 + 1) = v92;
                        *((_QWORD *)v103 + 1) = v93;
                        v104 = v103;
                        if (v95 == v97)
                        {
                          v3 = (MIDIDriverPlugin_DriverKit *)this;
                        }
                        else
                        {
                          v3 = (MIDIDriverPlugin_DriverKit *)this;
                          do
                          {
                            *((_OWORD *)v104 - 1) = *(_OWORD *)(v95 - 16);
                            v104 -= 16;
                            v95 -= 16;
                          }
                          while (v95 != v97);
                          v95 = *(_QWORD *)&v216[32];
                        }
                        v105 = &v102[16 * v101];
                        v96 = v103 + 16;
                        *(_QWORD *)&v216[32] = v104;
                        *(_QWORD *)&v216[40] = v103 + 16;
                        *(_QWORD *)&v216[48] = v105;
                        if (v95)
                          operator delete((void *)v95);
                      }
                      else
                      {
                        **(_DWORD **)&v216[40] = (_DWORD)Destination;
                        *(_DWORD *)(v95 + 4) = v92;
                        v96 = (char *)(v95 + 16);
                        *(_QWORD *)(v95 + 8) = v93;
                      }
                      *(_QWORD *)&v216[40] = v96;
                      MIDIEndpointSetRefCons((MIDIEndpointRef)Destination, ref1, v96 - 16);
                      ++v90;
                      ++v91;
                    }
                    while (v91 != v74);
                  }
                  v106 = *v201;
                  if (*v201 < *v202)
                  {
                    *(_QWORD *)v106 = *(_QWORD *)v216;
                    *((_QWORD *)v106 + 1) = 0;
                    *((_QWORD *)v106 + 3) = 0;
                    *((_QWORD *)v106 + 4) = 0;
                    *((_QWORD *)v106 + 2) = 0;
                    *(_OWORD *)(v106 + 8) = *(_OWORD *)&v216[8];
                    *((_QWORD *)v106 + 3) = *(_QWORD *)&v216[24];
                    memset(&v216[8], 0, 24);
                    *((_QWORD *)v106 + 5) = 0;
                    *((_QWORD *)v106 + 6) = 0;
                    *((_OWORD *)v106 + 2) = *(_OWORD *)&v216[32];
                    *((_QWORD *)v106 + 6) = *(_QWORD *)&v216[48];
                    memset(&v216[32], 0, 24);
                    *v201 = v106 + 56;
                    goto LABEL_125;
                  }
                  v107 = 0x6DB6DB6DB6DB6DB7 * ((v106 - *v198) >> 3);
                  v108 = v107 + 1;
                  if ((unint64_t)(v107 + 1) > 0x492492492492492)
                    std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
                  if (0xDB6DB6DB6DB6DB6ELL * ((*v202 - *v198) >> 3) > v108)
                    v108 = 0xDB6DB6DB6DB6DB6ELL * ((*v202 - *v198) >> 3);
                  if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((*v202 - *v198) >> 3)) >= 0x249249249249249)
                    v109 = 0x492492492492492;
                  else
                    v109 = v108;
                  if (v109 > 0x492492492492492)
                    std::__throw_bad_array_new_length[abi:ne180100]();
                  v110 = (char *)operator new(56 * v109);
                  v111 = &v110[56 * v107];
                  v112 = &v110[56 * v109];
                  *(_QWORD *)v111 = *(_QWORD *)v216;
                  *(_OWORD *)(v111 + 8) = *(_OWORD *)&v216[8];
                  *((_QWORD *)v111 + 3) = *(_QWORD *)&v216[24];
                  memset(&v216[8], 0, 24);
                  *((_OWORD *)v111 + 2) = *(_OWORD *)&v216[32];
                  *((_QWORD *)v111 + 6) = *(_QWORD *)&v216[48];
                  memset(&v216[32], 0, 24);
                  v113 = v111 + 56;
                  v114 = *v201;
                  v115 = *v198;
                  if (*v201 == *v198)
                  {
                    *v198 = v111;
                    *v201 = v113;
                    *v202 = v112;
                    if (v114)
                      goto LABEL_122;
                  }
                  else
                  {
                    v116 = 0;
                    do
                    {
                      v117 = &v111[v116];
                      v118 = &v114[v116];
                      *((_QWORD *)v117 - 7) = *(_QWORD *)&v114[v116 - 56];
                      *((_QWORD *)v117 - 6) = 0;
                      *((_QWORD *)v117 - 5) = 0;
                      *((_QWORD *)v117 - 4) = 0;
                      *((_OWORD *)v117 - 3) = *(_OWORD *)&v114[v116 - 48];
                      *((_QWORD *)v117 - 4) = *(_QWORD *)&v114[v116 - 32];
                      *((_QWORD *)v118 - 6) = 0;
                      *((_QWORD *)v118 - 5) = 0;
                      *((_QWORD *)v118 - 4) = 0;
                      *((_QWORD *)v117 - 3) = 0;
                      *((_QWORD *)v117 - 2) = 0;
                      *((_QWORD *)v117 - 1) = 0;
                      *(_OWORD *)(v117 - 24) = *(_OWORD *)&v114[v116 - 24];
                      *((_QWORD *)v117 - 1) = *(_QWORD *)&v114[v116 - 8];
                      *((_QWORD *)v118 - 3) = 0;
                      *((_QWORD *)v118 - 2) = 0;
                      *((_QWORD *)v118 - 1) = 0;
                      v116 -= 56;
                    }
                    while (&v114[v116] != v115);
                    v119 = *v198;
                    v114 = *v201;
                    *v198 = &v111[v116];
                    *v201 = v113;
                    *v202 = v112;
                    if (v114 != v119)
                    {
                      do
                      {
                        v114 -= 56;
                        std::__destroy_at[abi:ne180100]<MIDIDriverPlugin_DriverKit::Entity,0>(v114);
                      }
                      while (v114 != v119);
                      v114 = v119;
                    }
                    if (v114)
LABEL_122:
                      operator delete(v114);
                  }
                  v120 = *(void **)&v216[32];
                  *v201 = v113;
                  if (v120)
                  {
                    *(_QWORD *)&v216[40] = v120;
                    operator delete(v120);
                  }
LABEL_125:
                  if (*(_QWORD *)&v216[8])
                  {
                    *(_QWORD *)&v216[16] = *(_QWORD *)&v216[8];
                    operator delete(*(void **)&v216[8]);
                  }
                  if (v227.__r_.__value_.__s.__data_[16])
                    caulk::__expected_detail::destroy<applesauce::CF::StringRef,(void *)0>(v227.__r_.__value_.__l.__data_);
                }
                v17 = v212;
                v31 = (MIDIDriverPlugin_DriverKit *)device;
                v63 = v203;
              }
              if (v206)
                operator delete(v206);
LABEL_132:
              if (v209 && v208)
                operator delete(v208);
              v64 = v207 + 1;
              if (v207 + 1 == v63)
                break;
              continue;
            }
          }
          if (v196)
            operator delete(v196);
        }
        MIDISetupAddDevice((MIDIDeviceRef)v31);
        MIDIDriverPlugin_DriverKit::syncAllPropertiesRemote(v3, v31, v205[0]);
        MIDIDriverPlugin_DriverKit::withIOThread(*((_DWORD *)v3 + 19), v205[0], 0x10u, v121, v122, v123, v124, v125);
        *(_DWORD *)v216 = v205[0];
        inputStruct = 0;
        input.__r_.__value_.__r.__words[0] = *(_QWORD *)v205;
        MIDIDriverKitClient::call((uint64_t)&v223, *((_DWORD *)v3 + 19), 9u, (uint64_t *)&input, 1u, 0, 0, v126, (uint64_t *)&inputStruct, 1, 0, 0);
        if (!(_BYTE)v224)
        {
          v190 = __cxa_allocate_exception(0x18uLL);
          v191 = v223;
          std::to_string(&v227, 9u);
          v192 = std::string::insert(&v227, 0, "could not get shared id with method: ", 0x25uLL);
          input = *v192;
          v192->__r_.__value_.__l.__size_ = 0;
          v192->__r_.__value_.__r.__words[2] = 0;
          v192->__r_.__value_.__r.__words[0] = 0;
          MIDIDriverKitException::MIDIDriverKitException((uint64_t)v190, v191, (const void **)&input.__r_.__value_.__l.__data_);
        }
        v127 = inputStruct;
        v128 = MIDIDriverKitClient::mapMemory((MIDIDriverKitClient *)this[19], inputStruct);
        *(_QWORD *)&v216[8] = v127;
        *(_QWORD *)&v216[16] = v128;
        *(_QWORD *)&v216[24] = v129;
        Buffer = MIDIDriverPlugin_DriverKit::getBufferID<int>(this[19], v205[0], 0xBu, 1u, v130, v131, v132, v133);
        v135 = (void *)MIDIDriverKitClient::mapMemory((MIDIDriverKitClient *)this[19], Buffer);
        *(_QWORD *)&v216[32] = Buffer;
        *(_QWORD *)&v216[40] = v135;
        *(_QWORD *)&v216[48] = v136;
        v141 = MIDIDriverPlugin_DriverKit::getBufferID<int>(this[19], v205[0], 0xAu, 1u, v137, v138, v139, v140);
        v142 = MIDIDriverKitClient::mapMemory((MIDIDriverKitClient *)this[19], v141);
        v144 = v143;
        *(_QWORD *)&v216[56] = v141;
        *(_QWORD *)&v216[64] = v142;
        *(_QWORD *)&v216[72] = v143;
        memset(&v216[80], 0, 24);
        v149 = MIDIDriverPlugin_DriverKit::getBufferID<int>(this[19], v205[0], 0xBu, 0, v145, v146, v147, v148);
        v150 = (void *)MIDIDriverKitClient::mapMemory((MIDIDriverKitClient *)this[19], v149);
        *(_QWORD *)&v216[104] = v149;
        *(_QWORD *)&v216[112] = v150;
        *(_QWORD *)&v216[120] = v151;
        v156 = MIDIDriverPlugin_DriverKit::getBufferID<int>(this[19], v205[0], 0xAu, 0, v152, v153, v154, v155);
        v157 = MIDIDriverKitClient::mapMemory((MIDIDriverKitClient *)this[19], v156);
        v159 = v158;
        *(_QWORD *)&v216[128] = v156;
        *(_QWORD *)&v216[136] = v157;
        *(_QWORD *)&v216[144] = v158;
        memset(&v216[152], 0, 24);
        v160 = MIDIDriverKit::SharedRingBuffer<unsigned char>::SharedRingBuffer(&v223, v142, v144, v135);
        *(_OWORD *)&v216[80] = v223;
        *(_QWORD *)&v216[96] = v224;
        MIDIDriverKit::SharedRingBuffer<unsigned char>::SharedRingBuffer(v160, v157, v159, v150);
        *(_OWORD *)&v216[152] = v223;
        *(_QWORD *)&v216[168] = v224;
        caulk::make_string((caulk *)"eventlink-input-%u", (uint64_t)&v223, *(_QWORD *)v205);
        caulk::make_string((caulk *)"eventlink-output-%u", (uint64_t)&input, *(_QWORD *)v205);
        caulk::mach::os_eventlink::make();
        v217 = v223;
        *(_QWORD *)&v218 = v224;
        v224 = 0;
        v223 = 0uLL;
        caulk::mach::os_eventlink::make();
        v219 = *(_OWORD *)&input.__r_.__value_.__l.__data_;
        *(_QWORD *)&v220 = *((_QWORD *)&input.__r_.__value_.__l + 2);
        memset(&input, 0, sizeof(input));
        BYTE8(v220) = 0;
        __p[0] = 0;
        __p[1] = 0;
        if (SHIBYTE(v224) < 0)
          operator delete((void *)v223);
        if ((SBYTE7(v218) & 0x80u) == 0)
          v161 = &v217;
        else
          v161 = (__int128 *)v217;
        if ((SBYTE7(v218) & 0x80u) == 0)
          v162 = BYTE7(v218);
        else
          v162 = *((_QWORD *)&v217 + 1);
        v163 = caulk::mach::os_eventlink::copy_mach_port((caulk::mach::os_eventlink *)&v216[176]);
        v3 = (MIDIDriverPlugin_DriverKit *)this;
        v17 = v212;
        MIDIDriverKitClient::registerEventlink(v212, (uintptr_t)v161, v162, v163);
        if (!*(_QWORD *)&v216[176])
        {
          v193 = __cxa_allocate_exception(0x10uLL);
          MEMORY[0x1D826B7EC](v193, "input eventlink not valid");
          goto LABEL_190;
        }
        if ((SBYTE7(v220) & 0x80u) == 0)
          v164 = &v219;
        else
          v164 = (__int128 *)v219;
        if ((SBYTE7(v220) & 0x80u) == 0)
          v165 = BYTE7(v220);
        else
          v165 = *((_QWORD *)&v219 + 1);
        v166 = caulk::mach::os_eventlink::copy_mach_port((caulk::mach::os_eventlink *)((char *)&v218 + 8));
        MIDIDriverKitClient::registerEventlink(v212, (uintptr_t)v164, v165, v166);
        if (!*((_QWORD *)&v218 + 1))
        {
          v193 = __cxa_allocate_exception(0x10uLL);
          MEMORY[0x1D826B7EC](v193, "output eventlink not valid");
LABEL_190:
        }
        v167 = *((id *)&v218 + 1);
        v168 = os_eventlink_associate() == 0;

        if (!v168)
        {
          v193 = __cxa_allocate_exception(0x10uLL);
          MEMORY[0x1D826B7EC](v193, "couldn't associate output eventlink");
          goto LABEL_190;
        }
        v170 = *(_OWORD *)v216;
        v171 = *(_OWORD *)&v216[16];
        *(_OWORD *)(v200 - 232) = *(_OWORD *)&v216[32];
        *(_OWORD *)(v200 - 248) = v171;
        *(_OWORD *)(v200 - 264) = v170;
        v172 = *(_OWORD *)&v216[48];
        v173 = *(_OWORD *)&v216[64];
        v174 = *(_OWORD *)&v216[80];
        *(_OWORD *)(v200 - 168) = *(_OWORD *)&v216[96];
        *(_OWORD *)(v200 - 184) = v174;
        *(_OWORD *)(v200 - 200) = v173;
        *(_OWORD *)(v200 - 216) = v172;
        v175 = *(_OWORD *)&v216[112];
        v176 = *(_OWORD *)&v216[128];
        v177 = *(_OWORD *)&v216[144];
        *(_OWORD *)(v200 - 104) = *(_OWORD *)&v216[160];
        *(_OWORD *)(v200 - 120) = v177;
        *(_OWORD *)(v200 - 136) = v176;
        *(_OWORD *)(v200 - 152) = v175;
        v178 = *(_QWORD *)(v200 - 88);
        *(_QWORD *)(v200 - 88) = 0;
        *(_QWORD *)(v200 - 88) = *(_QWORD *)&v216[176];
        *(_QWORD *)&v216[176] = v178;
        caulk::mach::details::release_os_object(0, v169);
        v180 = (void **)(v200 - 80);
        if (*(char *)(v200 - 57) < 0)
          operator delete(*v180);
        v181 = v217;
        *(_QWORD *)(v200 - 64) = v218;
        *(_OWORD *)v180 = v181;
        BYTE7(v218) = 0;
        LOBYTE(v217) = 0;
        v182 = *(_QWORD *)(v200 - 56);
        *(_QWORD *)(v200 - 56) = 0;
        *(_QWORD *)(v200 - 56) = *((_QWORD *)&v218 + 1);
        *((_QWORD *)&v218 + 1) = v182;
        caulk::mach::details::release_os_object(0, v179);
        v183 = (void **)(v200 - 48);
        if (*(char *)(v200 - 25) < 0)
          operator delete(*v183);
        v184 = v219;
        *(_QWORD *)(v200 - 32) = v220;
        *(_OWORD *)v183 = v184;
        BYTE7(v220) = 0;
        LOBYTE(v219) = 0;
        *(_BYTE *)(v200 - 24) = BYTE8(v220);
        caulk::thread::operator=();
        caulk::thread::~thread((caulk::thread *)__p);
        if (SBYTE7(v220) < 0)
          operator delete((void *)v219);
        caulk::mach::details::release_os_object(*((caulk::mach::details **)&v218 + 1), v185);
        if (SBYTE7(v218) < 0)
          operator delete((void *)v217);
        caulk::mach::details::release_os_object(*(caulk::mach::details **)&v216[176], v186);
        *(_BYTE *)(v200 - 24) = 1;
        v216[0] = 0;
        v216[24] = 0;
        *(_OWORD *)&v216[32] = xmmword_1D4F18A10;
        *(_DWORD *)&v216[48] = 1;
        v216[52] = 1;
        v216[56] = 0;
        v216[60] = 0;
        *(_QWORD *)&v223 = 0;
        BYTE8(v223) = 0;
        v187 = operator new();
        std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:ne180100]((std::string *)v187, (__int128 *)v216);
        *(_OWORD *)(v187 + 32) = *(_OWORD *)&v216[32];
        *(_OWORD *)(v187 + 45) = *(_OWORD *)&v216[45];
        *(_QWORD *)(v187 + 64) = this;
        *(_QWORD *)(v187 + 72) = ref1;
        caulk::thread::start((caulk::thread *)&v223, (caulk::thread::attributes *)v187, (void *(*)(void *))caulk::thread_proxy<std::tuple<caulk::thread::attributes,MIDIDriverPlugin_DriverKit::retrieveDevices::{lambda(void)#1},std::tuple<>>>, (void *)v187);
        caulk::thread::operator=();
        caulk::thread::~thread((caulk::thread *)&v223);
        v22 = v199;
        if (v229)
          caulk::__expected_detail::destroy<applesauce::CF::DictionaryRef,(void *)0>(v228);
LABEL_169:
        ++v22;
      }
      while (v22 != v197);
    }
    if (v194)
      operator delete(v194);
  }
  if (cf)
    CFRelease(cf);
  return 0;
}

void sub_1D4E92010(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,void *a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49,uint64_t a50,char a51)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t MIDIDriverKitClient::call(uint64_t a1, mach_port_t connection, uint32_t selector, uint64_t *input, uint32_t inputCnt, void *inputStruct, size_t inputStructCnt, int a8, uint64_t *a9, uint64_t a10, void *outputStruct, size_t a12)
{
  uint64_t result;
  char v14;
  size_t v15;
  size_t outputStructCnt;
  uint32_t outputCnt;

  outputCnt = a10;
  outputStructCnt = a12;
  result = IOConnectCallMethod(connection, selector, input, inputCnt, inputStruct, inputStructCnt, a9, &outputCnt, outputStruct, &outputStructCnt);
  if ((_DWORD)result)
  {
    v14 = 0;
    *(_DWORD *)a1 = result;
  }
  else
  {
    v15 = outputStructCnt;
    *(_QWORD *)a1 = outputStruct;
    *(_QWORD *)(a1 + 8) = v15;
    v14 = 1;
  }
  *(_BYTE *)(a1 + 16) = v14;
  return result;
}

const void **applesauce::CF::ObjectRef<void const*>::~ObjectRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

void MIDIDriverKitClient::getProperty<unsigned int>(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  unsigned int v8;
  uint64_t PropertySize;
  uint64_t v13;
  uint64_t v14;
  int v15;
  size_t v16;
  char v17;
  char *v18;
  __int128 v19;
  char *v20;
  uint64_t v21;
  void *v22;
  int PropertyData;
  char v24;
  __int128 v25;

  v8 = a4;
  PropertySize = MIDIDriverKitClient::getPropertySize(*(_DWORD *)(a2 + 4), a3, a4, a4, a5, a6, a7, a8);
  v16 = PropertySize;
  if (v17)
  {
    if (PropertySize >= 4)
    {
      v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(PropertySize >> 2);
      v18 = &v20[4 * v21];
      bzero(v20, v16 & 0xFFFFFFFFFFFFFFFCLL);
      *(_QWORD *)&v19 = v20;
      *((_QWORD *)&v19 + 1) = &v20[v16 & 0xFFFFFFFFFFFFFFFCLL];
    }
    else
    {
      v18 = 0;
      v19 = 0uLL;
    }
    v25 = v19;
    v22 = (void *)v19;
    PropertyData = MIDIDriverKitClient::getPropertyData(*(_DWORD *)(a2 + 4), a3, v8, (void *)v19, v16, v13, v14, v15);
    if (v24)
    {
      *(_OWORD *)a1 = v25;
      *(_QWORD *)(a1 + 16) = v18;
      *(_BYTE *)(a1 + 24) = 1;
    }
    else
    {
      *(_DWORD *)a1 = PropertyData;
      *(_BYTE *)(a1 + 24) = 0;
      if (v22)
        operator delete(v22);
    }
  }
  else
  {
    *(_DWORD *)a1 = PropertySize;
    *(_BYTE *)(a1 + 24) = 0;
  }
}

void sub_1D4E926EC(_Unwind_Exception *exception_object)
{
  void *v1;

  if (v1)
    operator delete(v1);
  _Unwind_Resume(exception_object);
}

void MIDIDriverPlugin_DriverKit::getCFProperty<applesauce::CF::DictionaryRef>(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  char *v9;
  CFTypeRef v10;
  uint64_t v11;
  CFStringRef errorString;
  const char *v13[3];
  char v14;

  MIDIDriverKitClient::getProperty<unsigned char>((uint64_t)v13, a2 + 72, a3, a4, a5, a6, a7, a8);
  if (!v14)
  {
    *(_QWORD *)a1 = LODWORD(v13[0]);
    *(_QWORD *)(a1 + 8) = 1;
    *(_BYTE *)(a1 + 16) = 0;
    return;
  }
  errorString = 0;
  v9 = (char *)v13[0];
  v10 = IOCFUnserializeBinary(v13[0], v13[1] - v13[0], (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &errorString);
  if (!errorString)
  {
    applesauce::CF::DictionaryRef::DictionaryRef((applesauce::CF::DictionaryRef *)&v11, v10);
    *(_QWORD *)a1 = v11;
    *(_BYTE *)(a1 + 16) = 1;
    if (!v9)
      return;
    goto LABEL_7;
  }
  *(_QWORD *)a1 = errorString;
  *(_DWORD *)(a1 + 8) = 2;
  *(_BYTE *)(a1 + 16) = 0;
  if (v9)
LABEL_7:
    operator delete(v9);
}

void sub_1D4E927C0(_Unwind_Exception *exception_object)
{
  void *v1;

  if (v1)
    operator delete(v1);
  _Unwind_Resume(exception_object);
}

const void *applesauce::CF::details::at_key<__CFString const* const&>(const __CFDictionary *a1, const void *a2)
{
  if (a2)
    return CFDictionaryGetValue(a1, a2);
  else
    return 0;
}

void MIDIDriverPlugin_DriverKit::syncAllPropertiesLocal(MIDIDriverPlugin_DriverKit *this, int a2, unsigned int a3)
{
  uint64_t *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  MIDIObject *v12;
  const __CFDictionary *v13;
  uint64_t v14;
  const __CFNumber *v15;
  unint64_t v16;
  int v17;
  MIDISetup **v18;
  SetupManager *v19;
  SetupManager *v20;
  void *v21;
  void *exception;
  CFTypeRef cf1;
  CFTypeRef v24;
  CFTypeRef cf;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  _BYTE *v29;
  void *__p;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  void *v34;
  _BYTE *v35;
  void *v36;
  void *v37;
  const __CFDictionary *v38;
  char v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v6 = MIDIServer::defaultInstance(this) + 2;
  v7 = (*(uint64_t (**)(uint64_t *))(*v6 + 16))(v6);
  MIDIDriverPlugin_DriverKit::getCFProperty<applesauce::CF::DictionaryRef>((uint64_t)&v38, (uint64_t)this, a3, 1886548068, v8, v9, v10, v11);
  if (!v39)
    goto LABEL_38;
  v12 = (MIDIObject *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIObject>::sRTTI, a2);
  if (!v12)
    goto LABEL_37;
  v13 = v38;
  applesauce::CF::DictionaryRef_iterator<applesauce::CF::TypeRef,applesauce::CF::TypeRef>::DictionaryRef_iterator((uint64_t)&v32, v38);
  applesauce::CF::DictionaryRef_iterator<applesauce::CF::TypeRef,applesauce::CF::TypeRef>::DictionaryRef_iterator((uint64_t)&v26, v13);
  v27 = (v29 - (_BYTE *)v28) >> 3;
  while (1)
  {
    if (v32 && v33 != (v35 - (_BYTE *)v34) >> 3)
    {
      v14 = v26;
      goto LABEL_10;
    }
    v14 = v26;
    if (!v26 || v27 == (v29 - (_BYTE *)v28) >> 3)
      break;
LABEL_10:
    if (v32 == v14 && v33 == v27)
      break;
    applesauce::CF::DictionaryRef_iterator<applesauce::CF::TypeRef,applesauce::CF::TypeRef>::dereference(&v24, &v32);
    applesauce::CF::TypeRef::operator applesauce::CF::StringRef((applesauce::CF::StringRef *)&cf1, &v24);
    v15 = (const __CFNumber *)cf;
    if (cf)
      CFRetain(cf);
    if (CFEqual(cf1, kMIDIPropertyUniqueID))
    {
      if (!v15)
      {
        exception = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x1D826B7EC](exception, "Could not construct");
      }
      v16 = applesauce::CF::convert_as<int,0>(v15);
      if (!HIDWORD(v16))
      {
        v21 = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x1D826B7EC](v21, "Could not convert");
      }
      v17 = v16;
      v18 = (MIDISetup **)SetupManager::instance((SetupManager *)v16);
      if (MIDISetup::FindObjectByUniqueID(*v18, v17, v12))
        goto LABEL_21;
    }
    v19 = (SetupManager *)(*(uint64_t (**)(MIDIObject *, CFTypeRef, const __CFNumber *))(*(_QWORD *)v12 + 40))(v12, cf1, v15);
    if ((_DWORD)v19)
    {
      v20 = (SetupManager *)SetupManager::instance(v19);
      SetupManager::PropertyDirty(v20, v12, (const __CFString *)cf1);
    }
    if (v15)
LABEL_21:
      CFRelease(v15);
    if (cf1)
      CFRelease(cf1);
    if (v15)
      CFRelease(v15);
    if (v24)
      CFRelease(v24);
    ++v33;
  }
  if (__p)
  {
    v31 = __p;
    operator delete(__p);
  }
  if (v28)
  {
    v29 = v28;
    operator delete(v28);
  }
  if (v36)
  {
    v37 = v36;
    operator delete(v36);
  }
  if (v34)
  {
    v35 = v34;
    operator delete(v34);
  }
LABEL_37:
  caulk::__expected_detail::destroy<applesauce::CF::DictionaryRef,(void *)0>(v38);
LABEL_38:
  if (v7)
    (*(void (**)(uint64_t *))(*v6 + 24))(v6);
}

void sub_1D4E92AEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

void MIDIDriverPlugin_DriverKit::Device::~Device(MIDIDriverPlugin_DriverKit::Device *this)
{
  void *v2;
  void *v3;
  void **v4;

  caulk::thread::~thread((MIDIDriverPlugin_DriverKit::Device *)((char *)this + 280));
  if (*((char *)this + 271) < 0)
    operator delete(*((void **)this + 31));
  caulk::mach::details::release_os_object(*((caulk::mach::details **)this + 30), v2);
  if (*((char *)this + 239) < 0)
    operator delete(*((void **)this + 27));
  caulk::mach::details::release_os_object(*((caulk::mach::details **)this + 26), v3);
  v4 = (void **)((char *)this + 8);
  std::vector<MIDIDriverPlugin_DriverKit::Entity>::__destroy_vector::operator()[abi:ne180100](&v4);
}

void MIDIDriverPlugin_DriverKit::getCFProperty<applesauce::CF::StringRef>(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  char *v9;
  CFTypeRef v10;
  uint64_t v11;
  CFStringRef errorString;
  const char *v13[3];
  char v14;

  MIDIDriverKitClient::getProperty<unsigned char>((uint64_t)v13, a2 + 72, a3, a4, a5, a6, a7, a8);
  if (!v14)
  {
    *(_QWORD *)a1 = LODWORD(v13[0]);
    *(_QWORD *)(a1 + 8) = 1;
    *(_BYTE *)(a1 + 16) = 0;
    return;
  }
  errorString = 0;
  v9 = (char *)v13[0];
  v10 = IOCFUnserializeBinary(v13[0], v13[1] - v13[0], (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &errorString);
  if (!errorString)
  {
    applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v11, v10);
    *(_QWORD *)a1 = v11;
    *(_BYTE *)(a1 + 16) = 1;
    if (!v9)
      return;
    goto LABEL_7;
  }
  *(_QWORD *)a1 = errorString;
  *(_DWORD *)(a1 + 8) = 2;
  *(_BYTE *)(a1 + 16) = 0;
  if (v9)
LABEL_7:
    operator delete(v9);
}

void sub_1D4E92CD8(_Unwind_Exception *exception_object)
{
  void *v1;

  if (v1)
    operator delete(v1);
  _Unwind_Resume(exception_object);
}

void MIDIDriverPlugin_DriverKit::syncAllPropertiesRemote(MIDIDriverPlugin_DriverKit *this, MIDIDriverPlugin_DriverKit *a2, unsigned int a3)
{
  uint64_t *v6;
  int v7;
  uint64_t v8;
  CFMutableDictionaryRef v9;
  CFMutableDictionaryRef v10;
  uint64_t v11;
  CFTypeRef cf;
  CFTypeRef v13;
  CFTypeRef v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _BYTE *v18;
  void *__p;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  _BYTE *v24;
  void *v25;
  void *v26;
  const __CFDictionary *v27;

  v6 = MIDIServer::defaultInstance(this) + 2;
  v7 = (*(uint64_t (**)(uint64_t *))(*v6 + 16))(v6);
  v8 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIObject>::sRTTI, (int)a2);
  if (!v8)
    goto LABEL_29;
  v9 = MIDIObject::ToDictionary(*(CFDictionaryRef *)(v8 + 24));
  v10 = v9;
  if (!v9)
    goto LABEL_29;
  CFRetain(v9);
  applesauce::CF::DictionaryRef::DictionaryRef((applesauce::CF::DictionaryRef *)&v27, v10);
  applesauce::CF::DictionaryRef_iterator<applesauce::CF::TypeRef,applesauce::CF::TypeRef>::DictionaryRef_iterator((uint64_t)&v21, v27);
  applesauce::CF::DictionaryRef_iterator<applesauce::CF::TypeRef,applesauce::CF::TypeRef>::DictionaryRef_iterator((uint64_t)&v15, v27);
  v16 = (v18 - (_BYTE *)v17) >> 3;
  while (1)
  {
    if (v21 && v22 != (v24 - (_BYTE *)v23) >> 3)
    {
      v11 = v15;
      goto LABEL_10;
    }
    v11 = v15;
    if (!v15 || v16 == (v18 - (_BYTE *)v17) >> 3)
      break;
LABEL_10:
    if (v21 == v11 && v22 == v16)
      break;
    applesauce::CF::DictionaryRef_iterator<applesauce::CF::TypeRef,applesauce::CF::TypeRef>::dereference(&v13, &v21);
    applesauce::CF::TypeRef::operator applesauce::CF::StringRef((applesauce::CF::StringRef *)&cf, &v13);
    MIDIDriverPlugin_DriverKit::syncPropertyRemote((uint64_t)this, (CFStringRef)cf, a2, a3);
    if (cf)
      CFRelease(cf);
    if (v14)
      CFRelease(v14);
    if (v13)
      CFRelease(v13);
    ++v22;
  }
  if (__p)
  {
    v20 = __p;
    operator delete(__p);
  }
  if (v17)
  {
    v18 = v17;
    operator delete(v17);
  }
  if (v25)
  {
    v26 = v25;
    operator delete(v25);
  }
  if (v23)
  {
    v24 = v23;
    operator delete(v23);
  }
  if (v27)
    CFRelease(v27);
LABEL_29:
  if (v7)
    (*(void (**)(uint64_t *))(*v6 + 24))(v6);
}

void sub_1D4E92EC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
  uint64_t v20;
  int v21;

  if (v21)
    (*(void (**)(uint64_t))(*(_QWORD *)v20 + 24))(v20);
  _Unwind_Resume(exception_object);
}

void MIDIDriverPlugin_DriverKit::Entity::~Entity(MIDIDriverPlugin_DriverKit::Entity *this)
{
  void *v2;
  void *v3;

  v2 = (void *)*((_QWORD *)this + 4);
  if (v2)
  {
    *((_QWORD *)this + 5) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 1);
  if (v3)
  {
    *((_QWORD *)this + 2) = v3;
    operator delete(v3);
  }
}

void caulk::__expected_detail::destroy<applesauce::CF::StringRef,(void *)0>(const void *a1)
{
  if (a1)
    CFRelease(a1);
}

void caulk::__expected_detail::destroy<applesauce::CF::DictionaryRef,(void *)0>(const void *a1)
{
  if (a1)
    CFRelease(a1);
}

std::string *std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:ne180100](std::string *this, __int128 *a2)
{
  __int128 v3;

  this->__r_.__value_.__s.__data_[0] = 0;
  this[1].__r_.__value_.__s.__data_[0] = 0;
  if (*((_BYTE *)a2 + 24))
  {
    if (*((char *)a2 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
    }
    else
    {
      v3 = *a2;
      this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
      *(_OWORD *)&this->__r_.__value_.__l.__data_ = v3;
    }
    this[1].__r_.__value_.__s.__data_[0] = 1;
  }
  return this;
}

void sub_1D4E93024(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(_BYTE *)(v1 + 24))
  {
    if (*(char *)(v1 + 23) < 0)
      operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t caulk::thread_proxy<std::tuple<caulk::thread::attributes,MIDIDriverPlugin_DriverKit::retrieveDevices(unsigned int)::{lambda(void)#1},std::tuple<>>>(caulk::thread::attributes *a1)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  NSObject *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  unint64_t v23;
  size_t v24;
  char *v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  int v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  char *v36;
  unint64_t v37;
  unint64_t v38;
  size_t v39;
  unint64_t v40;
  size_t v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t *v47;
  unint64_t v48;
  uint64_t *v49;
  int v50;
  MIDISource *v51;
  uint64_t v52;
  NSObject *v53;
  const char *v54;
  uint64_t v56;
  _DWORD __dst[3];
  _DWORD v58[5];
  _BYTE buf[18];
  __int16 v60;
  int v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  caulk::thread::attributes::apply_to_this_thread(a1);
  v2 = *((_QWORD *)a1 + 8);
  v3 = caulk::mach::os_eventlink::associate((caulk::mach::os_eventlink *)(*((_QWORD *)a1 + 9) + 208));
  if (v3)
  {
    v9 = v3;
    midiDriverKitLog();
    v10 = objc_retainAutorelease((id)midiDriverKitLog(void)::category);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "MIDIDriverPlugin_DriverKit.mm";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1232;
      v60 = 1024;
      v61 = v9;
      _os_log_impl(&dword_1D4E88000, v10, OS_LOG_TYPE_ERROR, "%25s:%-5d Failed to dissociate input eventlink (status: %i)", buf, 0x18u);
    }
  }
  v56 = *((_QWORD *)a1 + 9);
  MIDIDriverPlugin_DriverKit::withIOThread(*(_DWORD *)(v2 + 76), *(_DWORD *)(v56 + 4), 0x12u, v4, v5, v6, v7, v8);
  v11 = (_QWORD *)*((_QWORD *)a1 + 9);
  std::vector<unsigned char>::vector(buf, ((unint64_t)(v11[15] - 16) >> 4) + 20);
  v12 = *((_QWORD *)a1 + 9);
  if (*(_BYTE *)(v12 + 272))
  {
LABEL_5:
    v13 = caulk::mach::os_eventlink::timed_wait_signal_or_error((caulk::mach::os_eventlink *)(v12 + 208), 1.0);
    if ((v13 & 0xFF00000000) != 0)
    {
      while (1)
      {
        v14 = v11[16];
        if (!v14 || (v15 = atomic_load((unint64_t *)(v14 + 64))) == 0)
        {
          v12 = *((_QWORD *)a1 + 9);
          if (*(_BYTE *)(v12 + 272))
            goto LABEL_5;
          goto LABEL_62;
        }
        v17 = *(_QWORD *)buf;
        v16 = *(_QWORD *)&buf[8];
        **(_QWORD **)buf = 2;
        *(_DWORD *)(v17 + 16) = 0;
        v18 = v11[16];
        v19 = atomic_load((unint64_t *)(v18 + 64));
        if (v19 >= 0x10)
          v19 = 16;
        v20 = atomic_load((unint64_t *)(v18 + 8));
        v21 = v11[15];
        if (v21 < v20)
          v20 = v11[15];
        v22 = v21 - v20 >= v19 ? v19 : v21 - v20;
        v23 = v19 - v22;
        v24 = v21 >= v23 ? v23 : v11[15];
        if (v24 + v22 < 0x10)
          break;
        v25 = (char *)v11[14];
        if (v22)
          v13 = (uint64_t)memcpy(__dst, &v25[v20], v22);
        if (v24)
          v13 = (uint64_t)memcpy((char *)__dst + v22, v25, v24);
        v26 = v11[16];
        if (!v26)
          break;
        v27 = 4 * v58[0] + 16;
        v28 = atomic_load((unint64_t *)(v26 + 64));
        if (v28 < v27)
          break;
        v29 = (unint64_t)(v16 - v17 - 20) >> 2;
        if (v29 < v58[0])
          break;
        v30 = __dst[0];
        v32 = v11[15];
        v31 = v11[16];
        v33 = atomic_load((unint64_t *)(v31 + 64));
        if (v33 >= v27)
          v34 = 4 * v58[0] + 16;
        else
          v34 = v33;
        v35 = atomic_load((unint64_t *)(v31 + 8));
        v36 = (char *)v11[14];
        if (v32 < v35)
          v35 = v11[15];
        v37 = v32 - v35;
        if (v32 - v35 >= v34)
          v37 = v34;
        v38 = v34 - v37;
        v39 = v32 >= v38 ? v38 : v11[15];
        if (v37 > 0xF)
        {
          v40 = v37 - 16;
          if (v37 != 16)
            v13 = (uint64_t)memmove((void *)(v17 + 20), &v36[v35 + 16], v37 - 16);
        }
        else
        {
          v40 = 0;
          v41 = 16 - v37;
          if (v39 < 16 - v37)
            v41 = v39;
          v36 += v41;
          v39 -= v41;
        }
        if (v39)
          v13 = (uint64_t)memmove((void *)(v17 + 20 + v40), v36, v39);
        v42 = (((uint64_t)((unint64_t)v58[0] << 63) >> 63) & (8 - 4 * (v58[0] & 1))) + v27;
        v43 = atomic_load((unint64_t *)(v11[16] + 64));
        if (v43 >= v42)
        {
          v45 = v11[15];
          v44 = v11[16];
          v46 = atomic_load((unint64_t *)(v44 + 8));
          atomic_store((v46 + v42) % v45, (unint64_t *)(v44 + 8));
          v47 = (unint64_t *)(v44 + 64);
          do
            v48 = __ldaxr(v47);
          while (__stlxr(v48 - v42, v47));
        }
        if (v29 >= v58[0])
          v29 = v58[0];
        if (!v29)
          break;
        v49 = MIDIServer::defaultInstance((MIDIServer *)v13) + 13;
        v50 = (*(uint64_t (**)(uint64_t *))(*v49 + 16))(v49);
        v13 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIEndpoint>::sRTTI, v30);
        if (v13)
        {
          v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v13 + 80))(v13);
          v51 = (MIDISource *)v13;
          if (v13)
          {
            v52 = mach_absolute_time();
            if (*(_DWORD *)(v17 + 4))
              __assert_rtn("set_protocol", "EventList.h", 944, "empty()");
            *(_DWORD *)v17 = *((_DWORD *)v51 + 11);
            *(_DWORD *)(v17 + 4) = 1;
            *(_QWORD *)(v17 + 8) = v52;
            *(_DWORD *)(v17 + 16) = v29;
            v13 = MIDISource::ReceivedPacketList(v51, (MIDIEventPacket *)v17);
          }
        }
        if (v50)
          v13 = (*(uint64_t (**)(uint64_t *))(*v49 + 24))(v49);
      }
      midiDriverKitLog();
      v53 = objc_retainAutorelease((id)midiDriverKitLog(void)::category);
      if (!os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
        goto LABEL_62;
      __dst[0] = 136315394;
      *(_QWORD *)&__dst[1] = "MIDIDriverPlugin_DriverKit.mm";
      LOWORD(v58[0]) = 1024;
      *(_DWORD *)((char *)v58 + 2) = 1264;
      v54 = "%25s:%-5d read data is broken";
      goto LABEL_61;
    }
    midiDriverKitLog();
    v53 = objc_retainAutorelease((id)midiDriverKitLog(void)::category);
    if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
    {
      __dst[0] = 136315394;
      *(_QWORD *)&__dst[1] = "MIDIDriverPlugin_DriverKit.mm";
      LOWORD(v58[0]) = 1024;
      *(_DWORD *)((char *)v58 + 2) = 1253;
      v54 = "%25s:%-5d Input eventlink failed on wait or got cancelled";
LABEL_61:
      _os_log_impl(&dword_1D4E88000, v53, OS_LOG_TYPE_ERROR, v54, (uint8_t *)__dst, 0x12u);
    }
  }
LABEL_62:
  if (*(_QWORD *)buf)
  {
    *(_QWORD *)&buf[8] = *(_QWORD *)buf;
    operator delete(*(void **)buf);
  }
  applesauce::raii::v1::detail::ScopeGuard<MIDIDriverPlugin_DriverKit::retrieveDevices::{lambda(void)#1}::operator() const(void)::{lambda(void)#1},applesauce::raii::v1::detail::StackExitPolicy>::~ScopeGuard((uint64_t)&v56);
  if (a1)
    std::default_delete<std::tuple<caulk::thread::attributes,MIDIDriverPlugin_DriverKit::retrieveDevices::{lambda(void)#1},std::tuple<>>>::operator()[abi:ne180100]((uint64_t)a1);
  return 0;
}

void sub_1D4E935C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  uint64_t v16;
  uint64_t v17;
  char v18;

  if ((v18 & 1) != 0)
    (*(void (**)(uint64_t))(*(_QWORD *)v17 + 24))(v17);
  if (__p)
  {
    a16 = (uint64_t)__p;
    operator delete(__p);
  }
  applesauce::raii::v1::detail::ScopeGuard<MIDIDriverPlugin_DriverKit::retrieveDevices::{lambda(void)#1}::operator() const(void)::{lambda(void)#1},applesauce::raii::v1::detail::StackExitPolicy>::~ScopeGuard((uint64_t)&a10);
  if (v16)
    std::default_delete<std::tuple<caulk::thread::attributes,MIDIDriverPlugin_DriverKit::retrieveDevices::{lambda(void)#1},std::tuple<>>>::operator()[abi:ne180100](v16);
  _Unwind_Resume(a1);
}

uint64_t std::default_delete<std::tuple<caulk::thread::attributes,MIDIDriverPlugin_DriverKit::retrieveDevices(unsigned int)::{lambda(void)#1},std::tuple<>>>::operator()[abi:ne180100](uint64_t result)
{
  if (result)
  {
    if (*(_BYTE *)(result + 24))
    {
      if (*(char *)(result + 23) < 0)
        operator delete(*(void **)result);
    }
    JUMPOUT(0x1D826BA98);
  }
  return result;
}

uint64_t MIDIDriverPlugin_DriverKit::withIOThread(mach_port_t connection, unsigned int a2, uint32_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  uint64_t result;
  void *exception;
  int v11;
  std::string v12;
  int v13[4];
  char v14;
  std::string v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v15.__r_.__value_.__r.__words[0] = a2;
  result = MIDIDriverKitClient::call((uint64_t)v13, connection, a3, (uint64_t *)&v15, 1u, 0, 0, a8, 0, 0, 0, 0);
  if (!v14)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v11 = v13[0];
    std::to_string(&v15, a3);
    std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&v12, "couldn't call io thread method ", &v15);
    MIDIDriverKitException::MIDIDriverKitException((uint64_t)exception, v11, (const void **)&v12.__r_.__value_.__l.__data_);
  }
  return result;
}

void sub_1D4E93790(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  void *v18;
  int v19;
  uint64_t v20;

  if (a18 < 0)
    operator delete(__p);
  if (*(char *)(v20 - 41) < 0)
  {
    operator delete(*(void **)(v20 - 64));
    if ((v19 & 1) == 0)
LABEL_8:
      _Unwind_Resume(a1);
  }
  else if (!v19)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v18);
  goto LABEL_8;
}

_QWORD *std::vector<unsigned char>::vector(_QWORD *a1, size_t a2)
{
  char *v4;
  char *v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<unsigned char>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_1D4E9384C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t applesauce::raii::v1::detail::ScopeGuard<MIDIDriverPlugin_DriverKit::retrieveDevices(unsigned int)::{lambda(void)#1}::operator() const(void)::{lambda(void)#1},applesauce::raii::v1::detail::StackExitPolicy>::~ScopeGuard(uint64_t a1)
{
  int v2;
  int v3;
  NSObject *v4;
  int v6;
  const char *v7;
  __int16 v8;
  int v9;
  __int16 v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v2 = caulk::mach::os_eventlink::dissociate((caulk::mach::os_eventlink *)(*(_QWORD *)a1 + 208));
  if (v2)
  {
    v3 = v2;
    midiDriverKitLog();
    v4 = objc_retainAutorelease((id)midiDriverKitLog(void)::category);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v6 = 136315650;
      v7 = "MIDIDriverPlugin_DriverKit.mm";
      v8 = 1024;
      v9 = 1238;
      v10 = 1024;
      v11 = v3;
      _os_log_impl(&dword_1D4E88000, v4, OS_LOG_TYPE_ERROR, "%25s:%-5d Failed to dissociate input eventlink (status: %i)", (uint8_t *)&v6, 0x18u);
    }
  }
  return a1;
}

char *std::vector<unsigned char>::__vallocate[abi:ne180100](_QWORD *a1, size_t __sz)
{
  char *result;

  if ((__sz & 0x8000000000000000) != 0)
    std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
  result = (char *)operator new(__sz);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

__n128 std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(std::string *a1, char *__s, std::string *a3)
{
  size_t v6;
  __n128 *v7;
  __n128 result;

  v6 = strlen(__s);
  v7 = (__n128 *)std::string::insert(a3, 0, __s, v6);
  result = *v7;
  *a1 = *(std::string *)v7->n128_u8;
  v7->n128_u64[0] = 0;
  v7->n128_u64[1] = 0;
  v7[1].n128_u64[0] = 0;
  return result;
}

uint64_t MIDIDriverKitException::MIDIDriverKitException(uint64_t a1, int a2, const void **a3)
{
  size_t v6;
  std::string *v7;
  const void *v8;
  std::string *p_p;
  std::string::size_type size;
  std::string *v11;
  __int128 v12;
  char *v13;
  size_t v14;
  std::string *v15;
  __int128 v16;
  std::string __p;
  std::string v19;
  std::string v20;
  std::string v21;

  if (*((char *)a3 + 23) >= 0)
    v6 = *((unsigned __int8 *)a3 + 23);
  else
    v6 = (size_t)a3[1];
  v7 = &v19;
  std::string::basic_string[abi:ne180100]((uint64_t)&v19, v6 + 7);
  if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v7 = (std::string *)v19.__r_.__value_.__r.__words[0];
  if (v6)
  {
    if (*((char *)a3 + 23) >= 0)
      v8 = a3;
    else
      v8 = *a3;
    memmove(v7, v8, v6);
  }
  strcpy((char *)v7 + v6, ": code ");
  std::to_string(&__p, a2);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    size = __p.__r_.__value_.__l.__size_;
  v11 = std::string::append(&v19, (const std::string::value_type *)p_p, size);
  v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  v20.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v20.__r_.__value_.__l.__data_ = v12;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  v13 = mach_error_string(a2);
  v14 = strlen(v13);
  v15 = std::string::append(&v20, v13, v14);
  v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v21.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v21.__r_.__value_.__l.__data_ = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  std::runtime_error::runtime_error((std::runtime_error *)a1, &v21);
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v21.__r_.__value_.__l.__data_);
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v20.__r_.__value_.__l.__data_);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v19.__r_.__value_.__l.__data_);
  *(_QWORD *)a1 = &off_1E98B6C60;
  *(_DWORD *)(a1 + 16) = a2;
  return a1;
}

void sub_1D4E93B78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a33 < 0)
    operator delete(__p);
  if (a26 < 0)
    operator delete(a21);
  if (a14 < 0)
    operator delete(a9);
  if (a20 < 0)
    operator delete(a15);
  _Unwind_Resume(exception_object);
}

void MIDIDriverKitException::~MIDIDriverKitException(std::runtime_error *this)
{
  std::runtime_error::~runtime_error(this);
  JUMPOUT(0x1D826BA98);
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  std::string *v5;
  std::string::size_type v6;
  std::string::size_type v7;
  std::string *v8;

  v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8)
      std::string::__throw_length_error[abi:ne180100]();
    v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17)
      v6 = __sz | 7;
    v7 = v6 + 1;
    v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    v5 = v8;
  }
  else
  {
    *((_BYTE *)&this->__r_.__value_.__s + 23) = __sz;
  }
  memmove(v5, __s, __sz + 1);
}

void caulk::make_string(caulk *this@<X0>, uint64_t a2@<X8>, ...)
{
  int v5;
  int v6;
  char *v7;
  size_t v8;
  int v9;
  va_list va;

  va_start(va, a2);
  v5 = vsnprintf(0, 0, (const char *)this, va);
  if (v5 <= 0)
  {
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
  }
  else
  {
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    std::string::resize((std::string *)a2, (v5 + 1), 0);
    v6 = *(char *)(a2 + 23);
    if (v6 >= 0)
      v7 = (char *)a2;
    else
      v7 = *(char **)a2;
    if (v6 >= 0)
      v8 = *(unsigned __int8 *)(a2 + 23);
    else
      v8 = *(_QWORD *)(a2 + 8);
    v9 = vsnprintf(v7, v8, (const char *)this, va);
    std::string::resize((std::string *)a2, v9, 0);
  }
}

uint64_t MIDIDriverKitClient::registerEventlink(uint64_t a1, uintptr_t p1, uintptr_t p2, uintptr_t p3)
{
  uint64_t result;
  void *exception;
  int v6;
  void *v7;
  const void *v8[3];

  if (!(_DWORD)p3)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Invalid eventlink mach port");
  }
  result = IOConnectTrap3(*(_DWORD *)(a1 + 4), 0, p1, p2, p3);
  if ((_DWORD)result)
  {
    v6 = result;
    v7 = __cxa_allocate_exception(0x18uLL);
    std::string::basic_string[abi:ne180100]<0>(v8, "Failed to register event link");
    MIDIDriverKitException::MIDIDriverKitException((uint64_t)v7, v6, v8);
  }
  return result;
}

void sub_1D4E93E04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  void *v15;
  int v16;

  if (a15 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0)
LABEL_6:
      _Unwind_Resume(a1);
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

void MIDIDriverPlugin_DriverKit::DeviceIO::~DeviceIO(MIDIDriverPlugin_DriverKit::DeviceIO *this)
{
  void *v2;
  void *v3;

  caulk::thread::~thread((MIDIDriverPlugin_DriverKit::DeviceIO *)((char *)this + 248));
  if (*((char *)this + 239) < 0)
    operator delete(*((void **)this + 27));
  caulk::mach::details::release_os_object(*((caulk::mach::details **)this + 26), v2);
  if (*((char *)this + 207) < 0)
    operator delete(*((void **)this + 23));
  caulk::mach::details::release_os_object(*((caulk::mach::details **)this + 22), v3);
}

uint64_t MIDIDriverKitClient::mapMemory(MIDIDriverKitClient *this, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;

  v4 = 0;
  v5 = 0;
  v2 = MEMORY[0x1D826B5E8](this, a2, *MEMORY[0x1E0C83DA0], &v5, &v4, 1);
  throw_on_error(v2, "could not map shared memory");
  return v5;
}

uint64_t MIDIDriverPlugin_DriverKit::getBufferID<int>(mach_port_t connection, unsigned int a2, uint32_t a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  void *exception;
  int v11;
  std::string v12;
  int v13[4];
  char v14;
  uint64_t v15;
  std::string v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v15 = 0;
  v16.__r_.__value_.__r.__words[0] = a2;
  v16.__r_.__value_.__l.__size_ = a4;
  MIDIDriverKitClient::call((uint64_t)v13, connection, a3, (uint64_t *)&v16, 2u, 0, 0, a8, &v15, 1, 0, 0);
  if (!v14)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    v11 = v13[0];
    std::to_string(&v16, a3);
    std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&v12, "could not get shared id with method: ", &v16);
    MIDIDriverKitException::MIDIDriverKitException((uint64_t)exception, v11, (const void **)&v12.__r_.__value_.__l.__data_);
  }
  return v15;
}

void sub_1D4E93FE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  void *v19;
  int v20;
  uint64_t v21;

  if (a19 < 0)
    operator delete(__p);
  if (*(char *)(v21 - 41) < 0)
  {
    operator delete(*(void **)(v21 - 64));
    if ((v20 & 1) == 0)
LABEL_8:
      _Unwind_Resume(a1);
  }
  else if (!v20)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v19);
  goto LABEL_8;
}

_QWORD *MIDIDriverKit::SharedRingBuffer<unsigned char>::SharedRingBuffer(_QWORD *a1, uint64_t a2, uint64_t a3, void *a4)
{
  void *v5;
  void *v7;
  size_t __space;

  *a1 = a2;
  a1[1] = a3;
  v7 = a4;
  __space = 192;
  v5 = std::align(0x40uLL, 0x80uLL, &v7, &__space);
  a1[2] = v5;
  if (!v5)
    __assert_rtn("SharedRingBuffer", "SharedRingBuffer.h", 365, "mState != nullptr");
  return a1;
}

uint64_t throw_on_error(uint64_t result, char *a2)
{
  int v2;
  void *exception;
  const void *v5[3];

  if ((_DWORD)result)
  {
    v2 = result;
    exception = __cxa_allocate_exception(0x18uLL);
    std::string::basic_string[abi:ne180100]<0>(v5, a2);
    MIDIDriverKitException::MIDIDriverKitException((uint64_t)exception, v2, v5);
  }
  return result;
}

void sub_1D4E94140(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  void *v15;
  int v16;

  if (a15 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0)
LABEL_6:
      _Unwind_Resume(a1);
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

void caulk::bad_expected_access<int>::~bad_expected_access(std::exception *a1)
{
  std::exception::~exception(a1);
  JUMPOUT(0x1D826BA98);
}

applesauce::CF::DictionaryRef *applesauce::CF::DictionaryRef::DictionaryRef(applesauce::CF::DictionaryRef *this, CFTypeRef cf)
{
  CFTypeID v3;
  void *exception;

  *(_QWORD *)this = cf;
  if (cf)
  {
    v3 = CFGetTypeID(cf);
    if (v3 != CFDictionaryGetTypeID())
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x1D826B7EC](exception, "Could not construct");
    }
  }
  return this;
}

void sub_1D4E94220(_Unwind_Exception *a1)
{
  CFTypeRef *v1;
  void *v2;

  __cxa_free_exception(v2);
  if (*v1)
    CFRelease(*v1);
  _Unwind_Resume(a1);
}

uint64_t applesauce::CF::DictionaryRef_iterator<applesauce::CF::TypeRef,applesauce::CF::TypeRef>::DictionaryRef_iterator(uint64_t a1, CFDictionaryRef theDict)
{
  char **v3;
  CFIndex Count;

  *(_QWORD *)a1 = theDict;
  *(_OWORD *)(a1 + 40) = 0u;
  v3 = (char **)(a1 + 40);
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_QWORD *)(a1 + 56) = 0;
  if (theDict)
  {
    Count = CFDictionaryGetCount(theDict);
    std::vector<void const*>::resize((char **)(a1 + 16), Count);
    std::vector<void const*>::resize(v3, Count);
    CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)a1, *(const void ***)(a1 + 16), *(const void ***)(a1 + 40));
  }
  return a1;
}

_QWORD *applesauce::CF::DictionaryRef_iterator<applesauce::CF::TypeRef,applesauce::CF::TypeRef>::dereference(_QWORD *result, _QWORD *a2)
{
  unint64_t v2;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  std::logic_error *exception;

  v2 = a2[1];
  if ((v2 & 0x8000000000000000) != 0 || (v4 = a2[2], v2 >= (a2[3] - v4) >> 3))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "DictionaryRef_iterator iterator out of range.");
  }
  v5 = result;
  v6 = *(_QWORD *)(v4 + 8 * v2);
  if (v6)
  {
    result = CFRetain(*(CFTypeRef *)(v4 + 8 * v2));
    v2 = a2[1];
  }
  v7 = a2[5];
  v8 = *(_QWORD *)(v7 + 8 * v2);
  if (v8)
    result = CFRetain(*(CFTypeRef *)(v7 + 8 * v2));
  *v5 = v6;
  v5[1] = v8;
  return result;
}

void sub_1D4E94374(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

applesauce::CF::StringRef *applesauce::CF::TypeRef::operator applesauce::CF::StringRef(applesauce::CF::StringRef *a1, CFTypeRef *a2)
{
  CFTypeID v4;
  CFTypeRef v5;
  applesauce::CF *exception;

  if (*a2)
  {
    v4 = CFGetTypeID(*a2);
    if (v4 != CFStringGetTypeID())
    {
      exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
      applesauce::CF::construct_error(exception);
    }
    v5 = *a2;
    if (v5)
      CFRetain(v5);
  }
  else
  {
    v5 = 0;
  }
  return applesauce::CF::StringRef::StringRef(a1, v5);
}

void sub_1D4E943FC()
{
  void *v0;

}

void sub_1D4E94414(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t MIDIDriverPlugin_DriverKit::syncPropertyRemote(uint64_t this, CFStringRef theString1, MIDIDriverPlugin_DriverKit *a3, unsigned int a4)
{
  uint64_t v7;
  unsigned __int8 v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  CFTypeRef v20;
  int v21;
  const __CFDictionary *v22;
  const __CFDictionary *v23;
  _BOOL4 v24;
  BOOL v25;
  char v26;
  CFTypeID MIDIPropertyType;
  MIDIServer *TypeID;
  uint64_t *v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  CFTypeRef v35;
  const __CFData *v36;
  UInt8 *v37;
  size_t v38;
  int v39;
  int v40;
  int v41;
  char v42;
  BOOL v43;
  MIDIServer *v44;
  int v45;
  const __CFNumber **v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  CFTypeRef v51;
  CFComparisonResult v52;
  void *v53;
  CFDictionaryRef CFDictionaryRef;
  int v55;
  int v56;
  MIDIServer *v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  char v64;
  MIDIServer *v65;
  uint64_t *v66;
  int v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  int v71;
  char v72;
  CFTypeRef v73;
  const __CFData *v74;
  UInt8 *v75;
  size_t v76;
  int v77;
  int v78;
  int v79;
  BOOL v80;
  const __CFData *v81;
  UInt8 *BytePtr;
  size_t Length;
  int v84;
  int v85;
  int v86;
  char v87;
  BOOL v88;
  char *data;
  int v90;
  int v91;
  void *exception;
  CFTypeRef v93;
  CFTypeRef v94;
  CFTypeRef cf;
  CFTypeRef cf2;
  int v97;
  CFStringRef v98;
  int v99;
  CFStringRef v100;
  int v101;
  CFStringRef v102;
  int v103;
  CFStringRef v104;
  int v105;
  CFStringRef v106;
  int v107;
  CFStringRef v108;
  int v109;
  CFStringRef v110;
  int v111;
  CFStringRef v112;
  int v113;
  CFStringRef v114;
  int v115;
  CFStringRef v116;
  int v117;
  CFStringRef v118;
  int v119;
  CFStringRef v120;
  int v121;
  CFStringRef v122;
  int v123;
  CFStringRef v124;
  int v125;
  CFStringRef v126;
  int v127;
  CFStringRef v128;
  int v129;
  CFStringRef v130;
  int v131;
  CFStringRef v132;
  int v133;
  CFStringRef v134;
  int v135;
  CFStringRef v136;
  int v137;
  CFStringRef v138;
  int v139;
  CFStringRef v140;
  int v141;
  CFStringRef v142;
  int v143;
  CFStringRef v144;
  int v145;
  CFStringRef v146;
  int v147;
  CFStringRef v148;
  int v149;
  CFStringRef v150;
  int v151;
  CFStringRef v152;
  int v153;
  CFStringRef v154;
  int v155;
  CFStringRef v156;
  int v157;
  CFStringRef v158;
  int v159;
  CFStringRef v160;
  int v161;
  CFStringRef v162;
  int v163;
  CFStringRef v164;
  int v165;
  CFStringRef v166;
  int v167;
  CFStringRef v168;
  int v169;
  CFStringRef v170;
  int v171;
  CFStringRef v172;
  int v173;
  CFStringRef v174;
  int v175;
  CFStringRef v176;
  int v177;
  CFStringRef v178;
  int v179;
  CFStringRef v180;
  int v181;
  CFStringRef v182;
  int v183;
  CFStringRef v184;
  int v185;
  CFStringRef v186;
  int v187;
  CFStringRef v188;
  int v189;
  uint64_t v190;
  int v191;
  CFDictionaryRef outDict;
  char v193;
  char v194;
  __CFString str;
  uint64_t v196;

  v7 = this;
  v196 = *MEMORY[0x1E0C80C00];
  if ((v8 & 1) == 0)
  {
    if ((_DWORD)this)
    {
      cf2 = kMIDIPropertyName;
      v97 = 1835950445;
      v98 = kMIDIPropertyManufacturer;
      v99 = 1835884907;
      v100 = kMIDIPropertyModel;
      v101 = 1835888484;
      v102 = kMIDIPropertyUniqueID;
      v103 = 1836411236;
      v104 = kMIDIPropertyDeviceID;
      v105 = 1835297124;
      v106 = kMIDIPropertyReceiveChannels;
      v107 = 1920492392;
      v108 = kMIDIPropertyTransmitChannels;
      v109 = 1836344168;
      v110 = kMIDIPropertyMaxSysExSpeed;
      v111 = 1835889520;
      v112 = kMIDIPropertyAdvanceScheduleTimeMuSec;
      v113 = 1835103092;
      v114 = kMIDIPropertyIsEmbeddedEntity;
      v115 = 1701667429;
      v116 = kMIDIPropertyIsBroadcast;
      v117 = 1651663713;
      v118 = kMIDIPropertySingleRealtimeEntity;
      v119 = 1936880741;
      v120 = kMIDIPropertyConnectionUniqueID;
      v121 = 1668639076;
      v122 = kMIDIPropertyOffline;
      v123 = 1836017254;
      v124 = kMIDIPropertyPrivate;
      v125 = 1836085878;
      v126 = kMIDIPropertyDriverOwner;
      v127 = 1685221239;
      v128 = kMIDIPropertyNameConfigurationDictionary;
      v129 = 1852072820;
      v130 = kMIDIPropertyImage;
      v131 = 1835625831;
      v132 = kMIDIPropertyDriverVersion;
      v133 = 1685480818;
      v134 = kMIDIPropertySupportsGeneralMIDI;
      v135 = 1936158052;
      v136 = kMIDIPropertySupportsMMC;
      v137 = 1936551267;
      v138 = kMIDIPropertyCanRoute;
      v139 = 1667329650;
      v140 = kMIDIPropertyReceivesClock;
      v141 = 1919118443;
      v142 = kMIDIPropertyReceivesMTC;
      v143 = 1919775843;
      v144 = kMIDIPropertyReceivesNotes;
      v145 = 1919841395;
      v146 = kMIDIPropertyReceivesProgramChanges;
      v147 = 1919971939;
      v148 = kMIDIPropertyReceivesBankSelectMSB;
      v149 = 1919054701;
      v150 = kMIDIPropertyReceivesBankSelectLSB;
      v151 = 1919054700;
      v152 = kMIDIPropertyTransmitsClock;
      v153 = 1952672875;
      v154 = kMIDIPropertyTransmitsMTC;
      v155 = 1953330275;
      v156 = kMIDIPropertyTransmitsNotes;
      v157 = 1953395827;
      v158 = kMIDIPropertyTransmitsProgramChanges;
      v159 = 1953526371;
      v160 = kMIDIPropertyTransmitsBankSelectMSB;
      v161 = 1952609133;
      v162 = kMIDIPropertyTransmitsBankSelectLSB;
      v163 = 1952609132;
      v164 = kMIDIPropertyPanDisruptsStereo;
      v165 = 1836082291;
      v166 = kMIDIPropertyIsSampler;
      v167 = 1935764848;
      v168 = kMIDIPropertyIsDrumMachine;
      v169 = 1685220717;
      v170 = kMIDIPropertyIsMixer;
      v171 = 1835886968;
      v172 = kMIDIPropertyIsEffectUnit;
      v173 = 1701209720;
      v174 = kMIDIPropertyMaxReceiveChannels;
      v175 = 1836610147;
      v176 = kMIDIPropertyMaxTransmitChannels;
      v177 = 1836610659;
      v178 = kMIDIPropertyDriverDeviceEditorApp;
      v179 = 1684301153;
      v180 = kMIDIPropertySupportsShowControl;
      v181 = 1936941938;
      v182 = kMIDIPropertyDisplayName;
      v183 = 1684955501;
      v184 = kMIDIPropertyProtocolID;
      v185 = 1886547828;
      v186 = kMIDIPropertyUMPActiveGroupBitmap;
      v187 = 1969317730;
      v188 = kMIDIPropertyUMPCanTransmitGroupless;
      v189 = 1969452135;
      v190 = kMIDIPropertyAssociatedEndpoint;
      v191 = 1634037876;
      std::map<__CFString const*,unsigned int>::map[abi:ne180100]((uint64_t *)&cf2, 48);
    }
  }
  v9 = getMIDIPropertySelector(__CFString const*)::midiPropertyMap;
  if ((uint64_t *)getMIDIPropertySelector(__CFString const*)::midiPropertyMap == &qword_1EFEFCBC0)
    goto LABEL_12;
  while (1)
  {
    this = CFStringCompare(theString1, *(CFStringRef *)(v9 + 32), 0);
    if (!this)
      break;
    v10 = *(uint64_t **)(v9 + 8);
    if (v10)
    {
      do
      {
        v11 = v10;
        v10 = (uint64_t *)*v10;
      }
      while (v10);
    }
    else
    {
      do
      {
        v11 = *(uint64_t **)(v9 + 16);
        v43 = *v11 == v9;
        v9 = (uint64_t)v11;
      }
      while (!v43);
    }
    v9 = (uint64_t)v11;
    if (v11 == &qword_1EFEFCBC0)
      goto LABEL_12;
  }
  v12 = *(unsigned int *)(v9 + 40);
  if ((_DWORD)v12 == 2003332927)
  {
LABEL_12:
    v13 = MIDIServer::defaultInstance((MIDIServer *)this) + 2;
    v14 = (*(uint64_t (**)(uint64_t *))(*v13 + 16))(v13);
    v15 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIObject>::sRTTI, (int)a3);
    if (!v15
      || (cf = 0,
          (*(unsigned int (**)(uint64_t, CFStringRef, CFTypeRef *, uint64_t))(*(_QWORD *)v15 + 32))(v15, theString1, &cf, 1)))
    {
LABEL_68:
      LOBYTE(v7) = 0;
LABEL_69:
      if (v14)
        (*(void (**)(uint64_t *))(*v13 + 24))(v13);
      return v7 & 1;
    }
    MIDIDriverPlugin_DriverKit::getCFProperty<applesauce::CF::DictionaryRef>((uint64_t)&cf2, v7, a4, 1886548068, v16, v17, v18, v19);
    v20 = cf;
    v94 = cf;
    v21 = v98;
    if ((_BYTE)v98)
    {
      if (!cf2)
      {
        exception = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x1D826B7EC](exception, "Could not construct");
      }
      v22 = (const __CFDictionary *)applesauce::CF::details::at_key<__CFString const* const&>((const __CFDictionary *)cf2, theString1);
      if (!v22)
      {
        LOBYTE(outDict) = 0;
        v193 = 0;
        goto LABEL_47;
      }
      v23 = v22;
      CFRetain(v22);
      outDict = v23;
      v193 = 1;
      v24 = v20 == 0;
      v25 = v23 == 0;
      if (v20)
      {
        if (CFEqual(v20, v23))
        {
          std::__optional_destruct_base<applesauce::CF::TypeRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&outDict);
          v26 = 1;
LABEL_64:
          CFRelease(v20);
LABEL_65:
          if (v21)
            caulk::__expected_detail::destroy<applesauce::CF::DictionaryRef,(void *)0>(cf2);
          if ((v26 & 1) == 0)
            goto LABEL_69;
          goto LABEL_68;
        }
        goto LABEL_47;
      }
    }
    else
    {
      outDict = 0;
      v25 = 1;
      v193 = 1;
      v24 = cf == 0;
    }
    if (v24 && v25)
    {
      v26 = 1;
      goto LABEL_63;
    }
LABEL_47:
    if (theString1)
      CFRetain(theString1);
    applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v93, theString1);
    v53 = (void *)v93;
    if (v93)
      CFRetain(v93);
    str.isa = v53;
    if (v20)
      CFRetain(v20);
    str.info = (uint64_t)v20;
    str.data = (char *)&str;
    str.length = 1;
    CFDictionaryRef = applesauce::CF::details::make_CFDictionaryRef((uint64_t)&str.data);
    if (str.info)
      CFRelease((CFTypeRef)str.info);
    if (str.isa)
      CFRelease(str.isa);
    CFRetain(CFDictionaryRef);
    str.data = (char *)CFDictionaryRef;
    LODWORD(v7) = MIDIDriverPlugin_DriverKit::setCFProperty<applesauce::CF::DictionaryRef>(v7, a4, 0x6373746Du, CFDictionaryRef);
    v56 = v55;
    if (CFDictionaryRef)
      CFRelease(CFDictionaryRef);
    if (v56 != 1)
      std::__throw_bad_variant_access[abi:ne180100]();
    LOBYTE(v7) = (_DWORD)v7 == 0;
    CFRelease(CFDictionaryRef);
    if (v93)
      CFRelease(v93);
    v26 = 0;
LABEL_63:
    std::__optional_destruct_base<applesauce::CF::TypeRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&outDict);
    if (!v20)
      goto LABEL_65;
    goto LABEL_64;
  }
  MIDIPropertyType = getMIDIPropertyType(*(_DWORD *)(v9 + 40));
  TypeID = (MIDIServer *)CFStringGetTypeID();
  if ((MIDIServer *)MIDIPropertyType != TypeID)
  {
    v44 = (MIDIServer *)CFNumberGetTypeID();
    if ((MIDIServer *)MIDIPropertyType == v44)
    {
      v29 = MIDIServer::defaultInstance(v44) + 2;
      v45 = (*(uint64_t (**)(uint64_t *))(*v29 + 16))(v29);
      str.isa = 0;
      if (MIDIDriverPlugin_DriverKit::getIntegerProperty(a3, theString1, &str, v46) || !str.isa)
        goto LABEL_133;
      applesauce::CF::NumberRef::NumberRef((applesauce::CF::NumberRef *)&cf, str.isa);
      MIDIDriverPlugin_DriverKit::getCFProperty<applesauce::CF::NumberRef>((uint64_t)&outDict, v7, a4, v12, v47, v48, v49, v50);
      if (v194)
      {
        caulk::expected<applesauce::CF::DictionaryRef,std::variant<int,int,__CFString const*>>::value((uint64_t)&outDict);
        v51 = cf;
        if (cf)
        {
          if (!outDict)
            goto LABEL_119;
          v52 = CFNumberCompare((CFNumberRef)cf, outDict, 0);
        }
        else if (outDict)
        {
          v52 = kCFCompareLessThan;
        }
        else
        {
          v52 = kCFCompareEqualTo;
        }
        if (v52 == kCFCompareEqualTo)
        {
          v87 = 1;
          goto LABEL_128;
        }
      }
      v51 = cf;
      if (!cf)
      {
LABEL_120:
        v94 = v51;
        v81 = IOCFSerialize(v51, 0);
        BytePtr = (UInt8 *)CFDataGetBytePtr(v81);
        Length = CFDataGetLength(v81);
        str.data = (char *)a4;
        str.length = v12;
        MIDIDriverKitClient::call((uint64_t)&cf2, *(_DWORD *)(v7 + 76), 8u, (uint64_t *)&str.data, 2u, BytePtr, Length, v84, 0, 0, 0, 0);
        v85 = v98;
        v86 = (int)cf2;
        if (v94)
          CFRelease(v94);
        v87 = 0;
        if (v85)
          v88 = 1;
        else
          v88 = v86 == 0;
        LOBYTE(v7) = v88;
LABEL_128:
        if (v194)
          caulk::__expected_detail::destroy<applesauce::CF::NumberRef,(void *)0>(outDict);
        if (cf)
          CFRelease(cf);
        if ((v87 & 1) == 0)
        {
LABEL_134:
          if (!v45)
            return v7 & 1;
LABEL_135:
          (*(void (**)(uint64_t *))(*v29 + 24))(v29);
          return v7 & 1;
        }
LABEL_133:
        LOBYTE(v7) = 0;
        goto LABEL_134;
      }
LABEL_119:
      CFRetain(v51);
      goto LABEL_120;
    }
    v58 = (MIDIServer *)CFDataGetTypeID();
    if ((MIDIServer *)MIDIPropertyType == v58)
    {
      v29 = MIDIServer::defaultInstance(v58) + 2;
      v59 = (*(uint64_t (**)(uint64_t *))(*v29 + 16))(v29);
      str.isa = 0;
      if (MIDIObjectGetDataProperty((MIDIObjectRef)a3, theString1, (CFDataRef *)&str) || !str.isa)
        goto LABEL_111;
      applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)&cf, str.isa);
      MIDIDriverPlugin_DriverKit::getCFProperty<applesauce::CF::DataRef>((uint64_t)&outDict, v7, a4, v12, v60, v61, v62, v63);
      if (v194
        && (caulk::expected<applesauce::CF::DictionaryRef,std::variant<int,int,__CFString const*>>::value((uint64_t)&outDict),
            applesauce::CF::operator==((CFDataRef *)&cf, &outDict)))
      {
        v64 = 1;
      }
      else
      {
        v73 = cf;
        if (cf)
          CFRetain(cf);
        v94 = v73;
        v74 = IOCFSerialize(v73, 0);
        v75 = (UInt8 *)CFDataGetBytePtr(v74);
        v76 = CFDataGetLength(v74);
        str.data = (char *)a4;
        str.length = v12;
        MIDIDriverKitClient::call((uint64_t)&cf2, *(_DWORD *)(v7 + 76), 8u, (uint64_t *)&str.data, 2u, v75, v76, v77, 0, 0, 0, 0);
        v78 = v98;
        v79 = (int)cf2;
        if (v73)
          CFRelease(v73);
        v64 = 0;
        v80 = v78 || v79 == 0;
        LOBYTE(v7) = v80;
      }
      if (v194)
        caulk::__expected_detail::destroy<applesauce::CF::DataRef,(void *)0>(outDict);
      if (cf)
        CFRelease(cf);
      if ((v64 & 1) != 0)
LABEL_111:
        LOBYTE(v7) = 0;
      if (v59)
        goto LABEL_135;
      return v7 & 1;
    }
    v65 = (MIDIServer *)CFDictionaryGetTypeID();
    if ((MIDIServer *)MIDIPropertyType != v65)
    {
      LOBYTE(v7) = 0;
      return v7 & 1;
    }
    v66 = MIDIServer::defaultInstance(v65) + 2;
    v67 = (*(uint64_t (**)(uint64_t *))(*v66 + 16))(v66);
    outDict = 0;
    if (MIDIObjectGetDictionaryProperty((MIDIObjectRef)a3, theString1, &outDict) || !outDict)
    {
LABEL_149:
      LOBYTE(v7) = 0;
LABEL_150:
      if (v67)
        (*(void (**)(uint64_t *))(*v66 + 24))(v66);
      return v7 & 1;
    }
    applesauce::CF::DictionaryRef::DictionaryRef((applesauce::CF::DictionaryRef *)&str.data, outDict);
    MIDIDriverPlugin_DriverKit::getCFProperty<applesauce::CF::DictionaryRef>((uint64_t)&cf2, v7, a4, v12, v68, v69, v70, v71);
    if ((_BYTE)v98)
    {
      caulk::expected<applesauce::CF::DictionaryRef,std::variant<int,int,__CFString const*>>::value((uint64_t)&cf2);
      if (str.data && cf2)
      {
        if (CFEqual(str.data, cf2))
        {
LABEL_85:
          v72 = 1;
          goto LABEL_144;
        }
      }
      else if (!((unint64_t)str.data | (unint64_t)cf2))
      {
        goto LABEL_85;
      }
    }
    data = str.data;
    if (str.data)
      CFRetain(str.data);
    str.isa = data;
    LODWORD(v7) = MIDIDriverPlugin_DriverKit::setCFProperty<applesauce::CF::DictionaryRef>(v7, a4, v12, data);
    v91 = v90;
    if (data)
      CFRelease(data);
    if (v91 != 1)
      std::__throw_bad_variant_access[abi:ne180100]();
    v72 = 0;
    LOBYTE(v7) = (_DWORD)v7 == 0;
LABEL_144:
    if ((_BYTE)v98)
      caulk::__expected_detail::destroy<applesauce::CF::DictionaryRef,(void *)0>(cf2);
    if (str.data)
      CFRelease(str.data);
    if ((v72 & 1) == 0)
      goto LABEL_150;
    goto LABEL_149;
  }
  v29 = MIDIServer::defaultInstance(TypeID) + 2;
  v30 = (*(uint64_t (**)(uint64_t *))(*v29 + 16))(v29);
  str.isa = 0;
  if (MIDIObjectGetStringProperty((MIDIObjectRef)a3, theString1, (CFStringRef *)&str) || !str.isa)
    goto LABEL_93;
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cf, str.isa);
  MIDIDriverPlugin_DriverKit::getCFProperty<applesauce::CF::StringRef>((uint64_t)&outDict, v7, a4, v12, v31, v32, v33, v34);
  if (v194
    && (caulk::expected<applesauce::CF::DictionaryRef,std::variant<int,int,__CFString const*>>::value((uint64_t)&outDict),
        applesauce::CF::compare<applesauce::CF::StringRef,0,applesauce::CF::StringRef,0>((const __CFString *)cf, (const __CFString **)&outDict) == kCFCompareEqualTo))
  {
    v42 = 1;
  }
  else
  {
    v35 = cf;
    if (cf)
      CFRetain(cf);
    v94 = v35;
    v36 = IOCFSerialize(v35, 0);
    v37 = (UInt8 *)CFDataGetBytePtr(v36);
    v38 = CFDataGetLength(v36);
    str.data = (char *)a4;
    str.length = v12;
    MIDIDriverKitClient::call((uint64_t)&cf2, *(_DWORD *)(v7 + 76), 8u, (uint64_t *)&str.data, 2u, v37, v38, v39, 0, 0, 0, 0);
    v40 = v98;
    v41 = (int)cf2;
    if (v35)
      CFRelease(v35);
    v42 = 0;
    v43 = v40 || v41 == 0;
    LOBYTE(v7) = v43;
  }
  if (v194)
    caulk::__expected_detail::destroy<applesauce::CF::StringRef,(void *)0>(outDict);
  if (cf)
    CFRelease(cf);
  if ((v42 & 1) != 0)
LABEL_93:
    LOBYTE(v7) = 0;
  if (v30)
    goto LABEL_135;
  return v7 & 1;
}

void sub_1D4E9516C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void applesauce::CF::StringRef::~StringRef(const void **this)
{
  const void *v1;

  v1 = *this;
  if (v1)
    CFRelease(v1);
}

uint64_t std::pair<applesauce::CF::TypeRef,applesauce::CF::TypeRef>::~pair(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 8);
  if (v2)
    CFRelease(v2);
  if (*(_QWORD *)a1)
    CFRelease(*(CFTypeRef *)a1);
  return a1;
}

_QWORD *applesauce::CF::DictionaryRef_iterator<applesauce::CF::TypeRef,applesauce::CF::TypeRef>::~DictionaryRef_iterator(_QWORD *a1)
{
  void *v2;
  void *v3;

  v2 = (void *)a1[5];
  if (v2)
  {
    a1[6] = v2;
    operator delete(v2);
  }
  v3 = (void *)a1[2];
  if (v3)
  {
    a1[3] = v3;
    operator delete(v3);
  }
  return a1;
}

uint64_t *std::map<__CFString const*,unsigned int>::map[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t *v8;
  BOOL v9;
  unint64_t v10;
  uint64_t *v11;
  uint64_t *v12;
  _OWORD *v13;
  unint64_t v14;

  qword_1EFEFCBC8 = 0;
  qword_1EFEFCBC0 = 0;
  getMIDIPropertySelector(__CFString const*)::midiPropertyMap = (uint64_t)&qword_1EFEFCBC0;
  if (a2)
  {
    v2 = result;
    v3 = 0;
    v4 = &result[2 * a2];
    v5 = &qword_1EFEFCBC0;
    while (1)
    {
      if (v5 == &qword_1EFEFCBC0)
      {
        v7 = &qword_1EFEFCBC0;
      }
      else
      {
        v6 = (uint64_t *)v3;
        if (v3)
        {
          do
          {
            v7 = v6;
            v6 = (uint64_t *)v6[1];
          }
          while (v6);
        }
        else
        {
          v8 = &qword_1EFEFCBC0;
          do
          {
            v7 = (uint64_t *)v8[2];
            v9 = *v7 == (_QWORD)v8;
            v8 = v7;
          }
          while (v9);
        }
        v10 = *v2;
        if (v7[4] >= (unint64_t)*v2)
        {
          if (v3)
          {
            v12 = &qword_1EFEFCBC0;
            while (1)
            {
              while (1)
              {
                v11 = (uint64_t *)v3;
                v14 = *(_QWORD *)(v3 + 32);
                if (v10 >= v14)
                  break;
                v3 = *v11;
                v12 = v11;
                if (!*v11)
                  goto LABEL_18;
              }
              if (v14 >= v10)
                break;
              v12 = v11 + 1;
              v3 = v11[1];
              if (!v3)
                goto LABEL_18;
            }
          }
          else
          {
            v11 = &qword_1EFEFCBC0;
            v12 = &qword_1EFEFCBC0;
          }
          goto LABEL_17;
        }
      }
      if (v3)
        v11 = v7;
      else
        v11 = &qword_1EFEFCBC0;
      if (v3)
        v12 = v7 + 1;
      else
        v12 = &qword_1EFEFCBC0;
LABEL_17:
      if (!*v12)
      {
LABEL_18:
        v13 = operator new(0x30uLL);
        v13[2] = *(_OWORD *)v2;
        *(_QWORD *)v13 = 0;
        *((_QWORD *)v13 + 1) = 0;
        *((_QWORD *)v13 + 2) = v11;
        *v12 = (uint64_t)v13;
        if (*(_QWORD *)getMIDIPropertySelector(__CFString const*)::midiPropertyMap)
        {
          getMIDIPropertySelector(__CFString const*)::midiPropertyMap = *(_QWORD *)getMIDIPropertySelector(__CFString const*)::midiPropertyMap;
          v13 = (_OWORD *)*v12;
        }
        result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)qword_1EFEFCBC0, (uint64_t *)v13);
        ++qword_1EFEFCBC8;
      }
      v2 += 2;
      if (v2 == v4)
        return result;
      v5 = (uint64_t *)getMIDIPropertySelector(__CFString const*)::midiPropertyMap;
      v3 = qword_1EFEFCBC0;
    }
  }
  return result;
}

void sub_1D4E95654(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<__CFString const*,unsigned int>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,unsigned int>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,unsigned int>>>::destroy((_QWORD *)qword_1EFEFCBC0);
  _Unwind_Resume(a1);
}

uint64_t MIDIDriverPlugin_DriverKit::setCFProperty<applesauce::CF::DictionaryRef>(uint64_t a1, unsigned int a2, unsigned int a3, CFTypeRef object)
{
  const __CFData *v7;
  UInt8 *BytePtr;
  size_t Length;
  int v10;
  _DWORD v12[4];
  char v13;
  uint64_t input[3];

  input[2] = *MEMORY[0x1E0C80C00];
  v7 = IOCFSerialize(object, 0);
  BytePtr = (UInt8 *)CFDataGetBytePtr(v7);
  Length = CFDataGetLength(v7);
  input[0] = a2;
  input[1] = a3;
  MIDIDriverKitClient::call((uint64_t)v12, *(_DWORD *)(a1 + 76), 8u, input, 2u, BytePtr, Length, v10, 0, 0, 0, 0);
  if (v13)
    return 0;
  else
    return v12[0];
}

void std::__throw_bad_variant_access[abi:ne180100]()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
  *exception = MEMORY[0x1E0DE5040] + 16;
}

uint64_t std::__optional_destruct_base<applesauce::CF::TypeRef,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  const void *v2;

  if (*(_BYTE *)(a1 + 8))
  {
    v2 = *(const void **)a1;
    if (*(_QWORD *)a1)
      CFRelease(v2);
  }
  return a1;
}

void applesauce::CF::TypeRef::~TypeRef(const void **this)
{
  const void *v1;

  v1 = *this;
  if (v1)
    CFRelease(v1);
}

CFTypeID getMIDIPropertyType(int a1)
{
  int v2;
  int v3;
  int v4;

  if (a1 <= 1836610146)
  {
    if (a1 > 1835103091)
    {
      if (a1 > 1835889519)
      {
        if (a1 > 1836082290)
        {
          if (a1 > 1836344167)
          {
            if (a1 == 1836344168)
              return CFNumberGetTypeID();
            v2 = 1836411236;
          }
          else
          {
            if (a1 == 1836082291)
              return CFNumberGetTypeID();
            v2 = 1836085878;
          }
LABEL_72:
          if (a1 != v2)
            return CFNullGetTypeID();
          return CFNumberGetTypeID();
        }
        if (a1 == 1835889520)
          return CFNumberGetTypeID();
        if (a1 != 1835950445)
        {
          v2 = 1836017254;
          goto LABEL_72;
        }
        return CFStringGetTypeID();
      }
      if (a1 > 1835884906)
      {
        if (a1 == 1835884907)
          return CFStringGetTypeID();
        if (a1 == 1835886968)
          return CFNumberGetTypeID();
        v3 = 1835888484;
      }
      else
      {
        if (a1 == 1835103092 || a1 == 1835297124)
          return CFNumberGetTypeID();
        v3 = 1835625831;
      }
LABEL_59:
      if (a1 != v3)
        return CFNullGetTypeID();
      return CFStringGetTypeID();
    }
    if (a1 > 1685220716)
    {
      if (a1 > 1701209719)
      {
        if (a1 == 1701209720 || a1 == 1701667429)
          return CFNumberGetTypeID();
        v4 = 1718644326;
LABEL_67:
        if (a1 != v4)
          return CFNullGetTypeID();
        return CFDataGetTypeID();
      }
      if (a1 == 1685220717)
        return CFNumberGetTypeID();
      if (a1 != 1685221239)
      {
        v2 = 1685480818;
        goto LABEL_72;
      }
    }
    else
    {
      if (a1 <= 1668639075)
      {
        if (a1 == 1634037876 || a1 == 1651663713)
          return CFNumberGetTypeID();
        v2 = 1667329650;
        goto LABEL_72;
      }
      if (a1 == 1668639076)
        return CFDataGetTypeID();
      if (a1 != 1684301153)
      {
        v3 = 1684955501;
        goto LABEL_59;
      }
    }
    return CFStringGetTypeID();
  }
  if (a1 > 1936158051)
  {
    if (a1 <= 1953330274)
    {
      if (a1 > 1936941937)
      {
        if ((a1 - 1952609132) < 2 || a1 == 1936941938)
          return CFNumberGetTypeID();
        v2 = 1952672875;
      }
      else
      {
        if (a1 == 1936158052 || a1 == 1936551267)
          return CFNumberGetTypeID();
        v2 = 1936880741;
      }
      goto LABEL_72;
    }
    if (a1 <= 1969317729)
    {
      if (a1 == 1953330275 || a1 == 1953395827)
        return CFNumberGetTypeID();
      v2 = 1953526371;
      goto LABEL_72;
    }
    if (a1 == 1969317730 || a1 == 1969452135)
      return CFNumberGetTypeID();
    v4 = 1970302566;
    goto LABEL_67;
  }
  if (a1 > 1919118442)
  {
    if (a1 > 1919971938)
    {
      if (a1 == 1919971939 || a1 == 1920492392)
        return CFNumberGetTypeID();
      v2 = 1935764848;
    }
    else
    {
      if (a1 == 1919118443 || a1 == 1919775843)
        return CFNumberGetTypeID();
      v2 = 1919841395;
    }
    goto LABEL_72;
  }
  if (a1 > 1852072819)
  {
    if ((a1 - 1919054700) < 2)
      return CFNumberGetTypeID();
    if (a1 == 1852072820)
      return CFDictionaryGetTypeID();
    v2 = 1886547828;
    goto LABEL_72;
  }
  if (a1 != 1836610147 && a1 != 1836610659)
  {
    if (a1 != 1852008039)
      return CFNullGetTypeID();
    return CFDictionaryGetTypeID();
  }
  return CFNumberGetTypeID();
}

uint64_t MIDIDriverPlugin_DriverKit::getIntegerProperty(MIDIDriverPlugin_DriverKit *this, const __CFString *a2, const __CFString *a3, const __CFNumber **a4)
{
  uint64_t IntegerProperty;
  CFNumberRef v6;
  void *exception;
  SInt32 outValue;
  SInt32 valuePtr;

  outValue = 0;
  IntegerProperty = MIDIObjectGetIntegerProperty((MIDIObjectRef)this, a2, &outValue);
  if (!(_DWORD)IntegerProperty)
  {
    valuePtr = outValue;
    v6 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    if (!v6)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x1D826B7EC](exception, "Could not construct");
    }
    a3->isa = v6;
  }
  return IntegerProperty;
}

void sub_1D4E95C64(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t caulk::expected<applesauce::CF::DictionaryRef,std::variant<int,int,__CFString const*>>::value(uint64_t result)
{
  __int128 *v1;
  char *exception;
  __int128 v3;

  if (!*(_BYTE *)(result + 16))
  {
    v1 = (__int128 *)result;
    exception = (char *)__cxa_allocate_exception(0x18uLL);
    v3 = *v1;
    *(_QWORD *)exception = &off_1E98B6E00;
    *(_OWORD *)(exception + 8) = v3;
  }
  return result;
}

void caulk::bad_expected_access<std::variant<int,int,__CFString const*>>::~bad_expected_access(std::exception *a1)
{
  std::exception::~exception(a1);
  JUMPOUT(0x1D826BA98);
}

applesauce::CF::DataRef *applesauce::CF::DataRef::DataRef(applesauce::CF::DataRef *this, CFTypeRef cf)
{
  CFTypeID v3;
  void *exception;

  *(_QWORD *)this = cf;
  if (cf)
  {
    v3 = CFGetTypeID(cf);
    if (v3 != CFDataGetTypeID())
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x1D826B7EC](exception, "Could not construct");
    }
  }
  return this;
}

void sub_1D4E95D74(_Unwind_Exception *a1)
{
  CFTypeRef *v1;
  void *v2;

  __cxa_free_exception(v2);
  if (*v1)
    CFRelease(*v1);
  _Unwind_Resume(a1);
}

void MIDIDriverPlugin_DriverKit::getCFProperty<applesauce::CF::DataRef>(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  char *v9;
  CFTypeRef v10;
  uint64_t v11;
  CFStringRef errorString;
  const char *v13[3];
  char v14;

  MIDIDriverKitClient::getProperty<unsigned char>((uint64_t)v13, a2 + 72, a3, a4, a5, a6, a7, a8);
  if (!v14)
  {
    *(_QWORD *)a1 = LODWORD(v13[0]);
    *(_QWORD *)(a1 + 8) = 1;
    *(_BYTE *)(a1 + 16) = 0;
    return;
  }
  errorString = 0;
  v9 = (char *)v13[0];
  v10 = IOCFUnserializeBinary(v13[0], v13[1] - v13[0], (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &errorString);
  if (!errorString)
  {
    applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)&v11, v10);
    *(_QWORD *)a1 = v11;
    *(_BYTE *)(a1 + 16) = 1;
    if (!v9)
      return;
    goto LABEL_7;
  }
  *(_QWORD *)a1 = errorString;
  *(_DWORD *)(a1 + 8) = 2;
  *(_BYTE *)(a1 + 16) = 0;
  if (v9)
LABEL_7:
    operator delete(v9);
}

void sub_1D4E95E60(_Unwind_Exception *exception_object)
{
  void *v1;

  if (v1)
    operator delete(v1);
  _Unwind_Resume(exception_object);
}

BOOL applesauce::CF::operator==(CFDataRef *a1, CFDataRef *a2)
{
  const __CFData *v3;
  _BOOL8 result;
  BOOL v5;
  const UInt8 *BytePtr;
  const UInt8 *v8;
  size_t Length;
  const __CFData *v10;

  v3 = *a1;
  result = ((unint64_t)*a1 | (unint64_t)*a2) == 0;
  if (v3)
    v5 = *a2 == 0;
  else
    v5 = 1;
  if (!v5)
  {
    BytePtr = CFDataGetBytePtr(v3);
    if (*a2)
      v8 = CFDataGetBytePtr(*a2);
    else
      v8 = 0;
    if (*a1)
      Length = CFDataGetLength(*a1);
    else
      Length = 0;
    v10 = *a2;
    if (*a2)
      v10 = (const __CFData *)CFDataGetLength(v10);
    return (const __CFData *)Length == v10 && memcmp(BytePtr, v8, Length) == 0;
  }
  return result;
}

void applesauce::CF::DataRef::~DataRef(const void **this)
{
  const void *v1;

  v1 = *this;
  if (v1)
    CFRelease(v1);
}

void caulk::__expected_detail::destroy<applesauce::CF::DataRef,(void *)0>(const void *a1)
{
  if (a1)
    CFRelease(a1);
}

applesauce::CF::NumberRef *applesauce::CF::NumberRef::NumberRef(applesauce::CF::NumberRef *this, CFTypeRef cf)
{
  CFTypeID v3;
  void *exception;

  *(_QWORD *)this = cf;
  if (cf)
  {
    v3 = CFGetTypeID(cf);
    if (v3 != CFNumberGetTypeID())
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x1D826B7EC](exception, "Could not construct");
    }
  }
  return this;
}

void sub_1D4E9600C(_Unwind_Exception *a1)
{
  CFTypeRef *v1;
  void *v2;

  __cxa_free_exception(v2);
  if (*v1)
    CFRelease(*v1);
  _Unwind_Resume(a1);
}

void MIDIDriverPlugin_DriverKit::getCFProperty<applesauce::CF::NumberRef>(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  char *v9;
  CFTypeRef v10;
  uint64_t v11;
  CFStringRef errorString;
  const char *v13[3];
  char v14;

  MIDIDriverKitClient::getProperty<unsigned char>((uint64_t)v13, a2 + 72, a3, a4, a5, a6, a7, a8);
  if (!v14)
  {
    *(_QWORD *)a1 = LODWORD(v13[0]);
    *(_QWORD *)(a1 + 8) = 1;
    *(_BYTE *)(a1 + 16) = 0;
    return;
  }
  errorString = 0;
  v9 = (char *)v13[0];
  v10 = IOCFUnserializeBinary(v13[0], v13[1] - v13[0], (CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &errorString);
  if (!errorString)
  {
    applesauce::CF::NumberRef::NumberRef((applesauce::CF::NumberRef *)&v11, v10);
    *(_QWORD *)a1 = v11;
    *(_BYTE *)(a1 + 16) = 1;
    if (!v9)
      return;
    goto LABEL_7;
  }
  *(_QWORD *)a1 = errorString;
  *(_DWORD *)(a1 + 8) = 2;
  *(_BYTE *)(a1 + 16) = 0;
  if (v9)
LABEL_7:
    operator delete(v9);
}

void sub_1D4E960F8(_Unwind_Exception *exception_object)
{
  void *v1;

  if (v1)
    operator delete(v1);
  _Unwind_Resume(exception_object);
}

void applesauce::CF::NumberRef::~NumberRef(const void **this)
{
  const void *v1;

  v1 = *this;
  if (v1)
    CFRelease(v1);
}

void caulk::__expected_detail::destroy<applesauce::CF::NumberRef,(void *)0>(const void *a1)
{
  if (a1)
    CFRelease(a1);
}

CFComparisonResult applesauce::CF::compare<applesauce::CF::StringRef,0,applesauce::CF::StringRef,0>(const __CFString *cf, const __CFString **a2)
{
  const __CFString *v4;
  CFComparisonResult v5;

  if (cf)
  {
    CFRetain(cf);
    v4 = *a2;
    if (!v4)
    {
      v5 = kCFCompareGreaterThan;
LABEL_9:
      CFRelease(cf);
      return v5;
    }
  }
  else
  {
    v4 = *a2;
    if (!*a2)
      return 0;
  }
  CFRetain(v4);
  if (cf)
    v5 = CFStringCompare(cf, v4, 0);
  else
    v5 = kCFCompareLessThan;
  CFRelease(v4);
  if (cf)
    goto LABEL_9;
  return v5;
}

void std::__tree<std::__value_type<__CFString const*,unsigned int>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,unsigned int>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,unsigned int>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<__CFString const*,unsigned int>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,unsigned int>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,unsigned int>>>::destroy(*a1);
    std::__tree<std::__value_type<__CFString const*,unsigned int>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,unsigned int>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,unsigned int>>>::destroy(a1[1]);
    operator delete(a1);
  }
}

uint64_t *std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  _BYTE *v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *((_BYTE *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      v2 = (uint64_t *)a2[2];
      if (*((_BYTE *)v2 + 24))
        return result;
      v3 = (uint64_t *)v2[2];
      v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), v5 = (_BYTE *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            v9 = (uint64_t **)a2[2];
          }
          else
          {
            v9 = (uint64_t **)v2[1];
            v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = v9;
            *v9 = v2;
            v2[2] = (uint64_t)v9;
            v3 = v9[2];
            v2 = (uint64_t *)*v3;
          }
          *((_BYTE *)v9 + 24) = 1;
          *((_BYTE *)v3 + 24) = 0;
          v13 = v2[1];
          *v3 = v13;
          if (v13)
            *(_QWORD *)(v13 + 16) = v3;
          v2[2] = v3[2];
          *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          v11 = a2[1];
          *v2 = v11;
          if (v11)
          {
            *(_QWORD *)(v11 + 16) = v2;
            v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((_BYTE *)a2 + 24) = 1;
        *((_BYTE *)v3 + 24) = 0;
        v2 = (uint64_t *)v3[1];
        v12 = *v2;
        v3[1] = *v2;
        if (v12)
          *(_QWORD *)(v12 + 16) = v3;
        v2[2] = v3[2];
        *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
        *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((_BYTE *)v2 + 24) = 1;
      a2 = v3;
      *((_BYTE *)v3 + 24) = v3 == result;
      *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

void applesauce::CF::construct_error(applesauce::CF *this)
{
  JUMPOUT(0x1D826B7ECLL);
}

void std::vector<void const*>::resize(char **a1, unint64_t a2)
{
  char *v3;
  char *v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  char *v12;
  uint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;
  char *v19;

  v3 = *a1;
  v4 = a1[1];
  v5 = (v4 - *a1) >> 3;
  if (a2 <= v5)
  {
    if (a2 >= v5)
      return;
    v19 = &v3[8 * a2];
    goto LABEL_17;
  }
  v6 = a2 - v5;
  v7 = a1[2];
  if (a2 - v5 <= (v7 - v4) >> 3)
  {
    bzero(a1[1], 8 * v6);
    v19 = &v4[8 * v6];
LABEL_17:
    a1[1] = v19;
    return;
  }
  if (a2 >> 61)
    std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
  v8 = v7 - v3;
  v9 = v8 >> 2;
  if (v8 >> 2 <= a2)
    v9 = a2;
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8)
    v10 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v10 = v9;
  v11 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v10);
  v12 = &v11[8 * v5];
  v14 = &v11[8 * v13];
  bzero(v12, 8 * v6);
  v15 = &v12[8 * v6];
  v17 = *a1;
  v16 = a1[1];
  if (v16 != *a1)
  {
    do
    {
      v18 = *((_QWORD *)v16 - 1);
      v16 -= 8;
      *((_QWORD *)v12 - 1) = v18;
      v12 -= 8;
    }
    while (v16 != v17);
    v16 = *a1;
  }
  *a1 = v12;
  a1[1] = v15;
  a1[2] = v14;
  if (v16)
    operator delete(v16);
}

uint64_t std::construct_at[abi:ne180100]<MIDIDriverPlugin_DriverKit::Device,MIDIDriverPlugin_DriverKit::Device,MIDIDriverPlugin_DriverKit::Device*>(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  void *v13;
  __int128 v14;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  v4 = *(_OWORD *)(a2 + 32);
  v5 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 64) = v5;
  *(_OWORD *)(a1 + 32) = v4;
  v6 = *(_OWORD *)(a2 + 80);
  v7 = *(_OWORD *)(a2 + 96);
  v8 = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(a1 + 128) = v8;
  *(_OWORD *)(a1 + 80) = v6;
  *(_OWORD *)(a1 + 96) = v7;
  v9 = *(_OWORD *)(a2 + 144);
  v10 = *(_OWORD *)(a2 + 160);
  v11 = *(_OWORD *)(a2 + 192);
  *(_OWORD *)(a1 + 176) = *(_OWORD *)(a2 + 176);
  *(_OWORD *)(a1 + 192) = v11;
  *(_OWORD *)(a1 + 144) = v9;
  *(_OWORD *)(a1 + 160) = v10;
  *(_QWORD *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 208) = *(_QWORD *)(a2 + 208);
  *(_QWORD *)(a2 + 208) = 0;
  caulk::mach::details::release_os_object(0, (void *)a2);
  v12 = *(_OWORD *)(a2 + 216);
  *(_QWORD *)(a1 + 232) = *(_QWORD *)(a2 + 232);
  *(_OWORD *)(a1 + 216) = v12;
  *(_QWORD *)(a2 + 216) = 0;
  *(_QWORD *)(a2 + 224) = 0;
  *(_QWORD *)(a2 + 232) = 0;
  *(_QWORD *)(a1 + 240) = 0;
  *(_QWORD *)(a1 + 240) = *(_QWORD *)(a2 + 240);
  *(_QWORD *)(a2 + 240) = 0;
  caulk::mach::details::release_os_object(0, v13);
  v14 = *(_OWORD *)(a2 + 248);
  *(_QWORD *)(a1 + 264) = *(_QWORD *)(a2 + 264);
  *(_OWORD *)(a1 + 248) = v14;
  *(_QWORD *)(a2 + 248) = 0;
  *(_QWORD *)(a2 + 256) = 0;
  *(_QWORD *)(a2 + 264) = 0;
  *(_BYTE *)(a1 + 272) = *(_BYTE *)(a2 + 272);
  caulk::thread::thread();
  return a1;
}

uint64_t applesauce::CF::convert_as<int,0>(const __CFNumber *a1)
{
  CFTypeID TypeID;
  int Value;
  CFTypeID v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  unsigned __int8 v12;
  int v13;
  uint64_t v14;
  double valuePtr;

  TypeID = CFNumberGetTypeID();
  if (TypeID == CFGetTypeID(a1))
  {
    switch(CFNumberGetType(a1))
    {
      case kCFNumberSInt8Type:
        LOBYTE(valuePtr) = 0;
        Value = CFNumberGetValue(a1, kCFNumberSInt8Type, &valuePtr);
        goto LABEL_14;
      case kCFNumberSInt16Type:
        LOWORD(valuePtr) = 0;
        v9 = CFNumberGetValue(a1, kCFNumberSInt16Type, &valuePtr);
        goto LABEL_21;
      case kCFNumberSInt32Type:
        LODWORD(valuePtr) = 0;
        v10 = CFNumberGetValue(a1, kCFNumberSInt32Type, &valuePtr);
        goto LABEL_32;
      case kCFNumberSInt64Type:
        valuePtr = 0.0;
        v10 = CFNumberGetValue(a1, kCFNumberSInt64Type, &valuePtr);
        goto LABEL_32;
      case kCFNumberFloat32Type:
        LODWORD(valuePtr) = 0;
        v10 = CFNumberGetValue(a1, kCFNumberFloat32Type, &valuePtr);
        goto LABEL_28;
      case kCFNumberFloat64Type:
        valuePtr = 0.0;
        v10 = CFNumberGetValue(a1, kCFNumberFloat64Type, &valuePtr);
        goto LABEL_34;
      case kCFNumberCharType:
        LOBYTE(valuePtr) = 0;
        Value = CFNumberGetValue(a1, kCFNumberCharType, &valuePtr);
LABEL_14:
        v11 = Value != 0;
        if (Value)
          v12 = LOBYTE(valuePtr);
        else
          v12 = 0;
        v13 = -256;
        if ((v11 & (SLOBYTE(valuePtr) < 0)) == 0)
          v13 = 0;
        v8 = v11 << 32;
        LODWORD(v5) = v13 & 0xFFFFFF00 | v12;
        v7 = v5 & 0xFFFFFF00;
        break;
      case kCFNumberShortType:
        LOWORD(valuePtr) = 0;
        v9 = CFNumberGetValue(a1, kCFNumberShortType, &valuePtr);
LABEL_21:
        if (v9)
          v5 = SLOWORD(valuePtr) & 0xFFFFFFFFLL | 0x100000000;
        else
          v5 = 0;
        goto LABEL_37;
      case kCFNumberIntType:
        LODWORD(valuePtr) = 0;
        v10 = CFNumberGetValue(a1, kCFNumberIntType, &valuePtr);
        goto LABEL_32;
      case kCFNumberLongType:
        valuePtr = 0.0;
        v10 = CFNumberGetValue(a1, kCFNumberLongType, &valuePtr);
        goto LABEL_32;
      case kCFNumberLongLongType:
        valuePtr = 0.0;
        v10 = CFNumberGetValue(a1, kCFNumberLongLongType, &valuePtr);
        goto LABEL_32;
      case kCFNumberFloatType:
        LODWORD(valuePtr) = 0;
        v10 = CFNumberGetValue(a1, kCFNumberFloatType, &valuePtr);
LABEL_28:
        v14 = (int)*(float *)&valuePtr;
        goto LABEL_35;
      case kCFNumberDoubleType:
        valuePtr = 0.0;
        v10 = CFNumberGetValue(a1, kCFNumberDoubleType, &valuePtr);
        goto LABEL_34;
      case kCFNumberCFIndexType:
        valuePtr = 0.0;
        v10 = CFNumberGetValue(a1, kCFNumberCFIndexType, &valuePtr);
        goto LABEL_32;
      case kCFNumberNSIntegerType:
        valuePtr = 0.0;
        v10 = CFNumberGetValue(a1, kCFNumberNSIntegerType, &valuePtr);
LABEL_32:
        v14 = LODWORD(valuePtr);
        goto LABEL_35;
      case kCFNumberCGFloatType:
        valuePtr = 0.0;
        v10 = CFNumberGetValue(a1, kCFNumberCGFloatType, &valuePtr);
LABEL_34:
        v14 = (int)valuePtr;
LABEL_35:
        v5 = v14 | 0x100000000;
        if (!v10)
          v5 = 0;
LABEL_37:
        v7 = v5 & 0xFFFFFF00;
        v8 = v5 & 0x100000000;
        break;
      default:
        v7 = 0;
        v8 = 0;
        LOBYTE(v5) = 0;
        break;
    }
    v6 = v8 | v7 & 0xFFFFFF00;
    v5 = v5;
  }
  else
  {
    v4 = CFBooleanGetTypeID();
    if (v4 == CFGetTypeID(a1))
    {
      v5 = CFBooleanGetValue(a1);
      v6 = 0x100000000;
    }
    else
    {
      v5 = 0;
      v6 = 0;
    }
  }
  return v6 | v5;
}

void applesauce::CF::convert_error(applesauce::CF *this)
{
  JUMPOUT(0x1D826B7ECLL);
}

uint64_t applesauce::CF::convert_as<BOOL,0>(const __CFNumber *a1)
{
  CFTypeID TypeID;
  _BOOL4 v3;
  CFTypeID v4;
  int Value;
  BOOL v6;
  int v7;
  BOOL v8;
  BOOL v9;
  int v10;
  double valuePtr;

  TypeID = CFBooleanGetTypeID();
  if (TypeID != CFGetTypeID(a1))
  {
    v4 = CFNumberGetTypeID();
    if (v4 == CFGetTypeID(a1))
    {
      switch(CFNumberGetType(a1))
      {
        case kCFNumberSInt8Type:
          LOBYTE(valuePtr) = 0;
          Value = CFNumberGetValue(a1, kCFNumberSInt8Type, &valuePtr);
          goto LABEL_13;
        case kCFNumberSInt16Type:
          LOWORD(valuePtr) = 0;
          Value = CFNumberGetValue(a1, kCFNumberSInt16Type, &valuePtr);
          goto LABEL_15;
        case kCFNumberSInt32Type:
          LODWORD(valuePtr) = 0;
          Value = CFNumberGetValue(a1, kCFNumberSInt32Type, &valuePtr);
          goto LABEL_17;
        case kCFNumberSInt64Type:
          valuePtr = 0.0;
          Value = CFNumberGetValue(a1, kCFNumberSInt64Type, &valuePtr);
          goto LABEL_28;
        case kCFNumberFloat32Type:
          LODWORD(valuePtr) = 0;
          Value = CFNumberGetValue(a1, kCFNumberFloat32Type, &valuePtr);
          goto LABEL_24;
        case kCFNumberFloat64Type:
          valuePtr = 0.0;
          Value = CFNumberGetValue(a1, kCFNumberFloat64Type, &valuePtr);
          goto LABEL_32;
        case kCFNumberCharType:
          LOBYTE(valuePtr) = 0;
          Value = CFNumberGetValue(a1, kCFNumberCharType, &valuePtr);
LABEL_13:
          v6 = Value == 0;
          v7 = LOBYTE(valuePtr);
          goto LABEL_18;
        case kCFNumberShortType:
          LOWORD(valuePtr) = 0;
          Value = CFNumberGetValue(a1, kCFNumberShortType, &valuePtr);
LABEL_15:
          v6 = Value == 0;
          v7 = LOWORD(valuePtr);
          goto LABEL_18;
        case kCFNumberIntType:
          LODWORD(valuePtr) = 0;
          Value = CFNumberGetValue(a1, kCFNumberIntType, &valuePtr);
LABEL_17:
          v6 = Value == 0;
          v7 = LODWORD(valuePtr);
LABEL_18:
          v8 = v6 || v7 == 0;
          break;
        case kCFNumberLongType:
          valuePtr = 0.0;
          Value = CFNumberGetValue(a1, kCFNumberLongType, &valuePtr);
          goto LABEL_28;
        case kCFNumberLongLongType:
          valuePtr = 0.0;
          Value = CFNumberGetValue(a1, kCFNumberLongLongType, &valuePtr);
          goto LABEL_28;
        case kCFNumberFloatType:
          LODWORD(valuePtr) = 0;
          Value = CFNumberGetValue(a1, kCFNumberFloatType, &valuePtr);
LABEL_24:
          v9 = *(float *)&valuePtr == 0.0;
          goto LABEL_33;
        case kCFNumberDoubleType:
          valuePtr = 0.0;
          Value = CFNumberGetValue(a1, kCFNumberDoubleType, &valuePtr);
          goto LABEL_32;
        case kCFNumberCFIndexType:
          valuePtr = 0.0;
          Value = CFNumberGetValue(a1, kCFNumberCFIndexType, &valuePtr);
          goto LABEL_28;
        case kCFNumberNSIntegerType:
          valuePtr = 0.0;
          Value = CFNumberGetValue(a1, kCFNumberNSIntegerType, &valuePtr);
LABEL_28:
          if (Value)
            v8 = *(_QWORD *)&valuePtr == 0;
          else
            v8 = 1;
          break;
        case kCFNumberCGFloatType:
          valuePtr = 0.0;
          Value = CFNumberGetValue(a1, kCFNumberCGFloatType, &valuePtr);
LABEL_32:
          v9 = valuePtr == 0.0;
LABEL_33:
          v8 = v9 || Value == 0;
          break;
        default:
          goto LABEL_6;
      }
      v3 = !v8;
      if (Value)
        goto LABEL_40;
    }
    else
    {
LABEL_6:
      v3 = 0;
    }
    v10 = 0;
    return v3 | (v10 << 8);
  }
  v3 = CFBooleanGetValue(a1) != 0;
LABEL_40:
  v10 = 1;
  return v3 | (v10 << 8);
}

uint64_t MIDIDriverKitClient::getPropertySize(mach_port_t connection, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  uint64_t v8;
  uint64_t v9;
  _DWORD v11[4];
  char v12;
  uint64_t input[2];
  uint64_t v14[2];

  v14[1] = *MEMORY[0x1E0C80C00];
  input[0] = a2;
  input[1] = a3;
  v14[0] = 0;
  MIDIDriverKitClient::call((uint64_t)v11, connection, 6u, input, 2u, 0, 0, a8, v14, 1, 0, 0);
  v8 = v14[0] & 0xFFFFFFFF00000000;
  if (v12)
    v9 = LODWORD(v14[0]);
  else
    v9 = v11[0];
  if (!v12)
    v8 = 0;
  return v8 | v9;
}

unint64_t MIDIDriverKitClient::getPropertyData(mach_port_t connection, unsigned int a2, unsigned int a3, void *a4, size_t a5, uint64_t a6, uint64_t a7, int a8)
{
  unint64_t v8;
  uint64_t v9;
  unsigned int v11;
  uint64_t v12;
  char v13;
  uint64_t input[2];
  uint64_t v15[2];

  v15[1] = *MEMORY[0x1E0C80C00];
  input[0] = a2;
  input[1] = a3;
  v15[0] = 0;
  MIDIDriverKitClient::call((uint64_t)&v11, connection, 7u, input, 2u, 0, 0, a8, v15, 1, a4, a5);
  v8 = v12 & 0xFFFFFFFF00000000;
  if (v13)
    v9 = v12;
  else
    v9 = v11;
  if (!v13)
    v8 = 0;
  return v8 | v9;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(unint64_t a1)
{
  if (a1 >> 62)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(4 * a1);
}

void std::__function::__func<MIDIDriverPlugin_DriverKit::MIDIDriverPlugin_DriverKit(MIDIDriverKitClient &&,__CFString const*,__CFString const)::{lambda(unsigned int,std::span<unsigned int const,18446744073709551615ul>)#1},std::allocator<std::span<unsigned int const,18446744073709551615ul>>,void ()(unsigned int,unsigned int const)>::~__func()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *std::__function::__func<MIDIDriverPlugin_DriverKit::MIDIDriverPlugin_DriverKit(MIDIDriverKitClient &&,__CFString const*,__CFString const)::{lambda(unsigned int,std::span<unsigned int const,18446744073709551615ul>)#1},std::allocator<std::span<unsigned int const,18446744073709551615ul>>,void ()(unsigned int,unsigned int const)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E98B7260;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<MIDIDriverPlugin_DriverKit::MIDIDriverPlugin_DriverKit(MIDIDriverKitClient &&,__CFString const*,__CFString const)::{lambda(unsigned int,std::span<unsigned int const,18446744073709551615ul>)#1},std::allocator<std::span<unsigned int const,18446744073709551615ul>>,void ()(unsigned int,unsigned int const)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E98B7260;
  a2[1] = v2;
  return result;
}

void std::__function::__func<MIDIDriverPlugin_DriverKit::MIDIDriverPlugin_DriverKit(MIDIDriverKitClient &&,__CFString const*,__CFString const)::{lambda(unsigned int,std::span<unsigned int const,18446744073709551615ul>)#1},std::allocator<std::span<unsigned int const,18446744073709551615ul>>,void ()(unsigned int,unsigned int const)>::operator()(uint64_t a1, unsigned int *a2, unsigned int **a3)
{
  unsigned int *v3;
  unsigned int *v4;
  uint64_t v5;
  uint64_t v6;
  MIDIDriverPlugin_DriverKit *v7;
  uint64_t v8;
  unsigned int *v9;
  unsigned int *i;
  unsigned int *j;
  MIDIDriverPlugin_DriverKit *v12;
  int v13;
  char *v14;
  const __CFString *v15;
  CFTypeID MIDIPropertyType;
  MIDIServer *TypeID;
  uint64_t *v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  MIDIServer *v24;
  int v25;
  const __CFNumber **v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  MIDIServer *v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  MIDIServer *v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  char *v43;
  uint64_t v44;
  char *data;
  unint64_t v46;
  void *exception;
  CFTypeRef v48;
  CFNumberRef number;
  __CFString cf;
  char v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  v3 = a3[1];
  if (!v3)
    return;
  v4 = *a3;
  v5 = (uint64_t)&(*a3)[(_QWORD)v3];
  v6 = *a2;
  v7 = *(MIDIDriverPlugin_DriverKit **)(a1 + 8);
  while (1)
  {
    v8 = *v4;
    NSLog(CFSTR("changed object %u property %u"), v6, v8);
    v9 = (unsigned int *)*((_QWORD *)v7 + 11);
LABEL_4:
    if (v9 == *((unsigned int **)v7 + 12))
      return;
    if (v9[1] == (_DWORD)v6)
      goto LABEL_20;
    for (i = (unsigned int *)*((_QWORD *)v9 + 1); ; i += 14)
    {
      if (i == *((unsigned int **)v9 + 2))
      {
        v9 += 74;
        goto LABEL_4;
      }
      if (i[1] == (_DWORD)v6)
        break;
      for (j = (unsigned int *)*((_QWORD *)i + 1); j != *((unsigned int **)i + 2); j += 2)
      {
        if (j[1] == (_DWORD)v6)
        {
LABEL_19:
          v9 = j;
          goto LABEL_20;
        }
      }
      for (j = (unsigned int *)*((_QWORD *)i + 4); j != *((unsigned int **)i + 5); j += 4)
      {
        if (j[1] == (_DWORD)v6)
          goto LABEL_19;
      }
    }
    v9 = i;
LABEL_20:
    v12 = (MIDIDriverPlugin_DriverKit *)*v9;
    if ((int)v8 <= 1836610146)
    {
      if ((int)v8 <= 1835103091)
      {
        if ((int)v8 > 1685220716)
        {
          if ((int)v8 > 1701209719)
          {
            if ((_DWORD)v8 == 1701209720 || (_DWORD)v8 == 1701667429)
              goto LABEL_91;
            v13 = 1718644326;
          }
          else
          {
            if ((_DWORD)v8 == 1685220717 || (_DWORD)v8 == 1685221239)
              goto LABEL_91;
            v13 = 1685480818;
          }
        }
        else if ((int)v8 > 1668639075)
        {
          if ((_DWORD)v8 == 1668639076 || (_DWORD)v8 == 1684301153)
            goto LABEL_91;
          v13 = 1684955501;
        }
        else
        {
          if ((_DWORD)v8 == 1634037876 || (_DWORD)v8 == 1651663713)
            goto LABEL_91;
          v13 = 1667329650;
        }
      }
      else if ((int)v8 <= 1835889519)
      {
        if ((int)v8 > 1835884906)
        {
          if ((_DWORD)v8 == 1835884907 || (_DWORD)v8 == 1835886968)
            goto LABEL_91;
          v13 = 1835888484;
        }
        else
        {
          if ((_DWORD)v8 == 1835103092 || (_DWORD)v8 == 1835297124)
            goto LABEL_91;
          v13 = 1835625831;
        }
      }
      else if ((int)v8 <= 1836082290)
      {
        if ((_DWORD)v8 == 1835889520 || (_DWORD)v8 == 1835950445)
          goto LABEL_91;
        v13 = 1836017254;
      }
      else if ((int)v8 > 1836344167)
      {
        if ((_DWORD)v8 == 1836344168)
          goto LABEL_91;
        v13 = 1836411236;
      }
      else
      {
        if ((_DWORD)v8 == 1836082291)
          goto LABEL_91;
        v13 = 1836085878;
      }
      goto LABEL_86;
    }
    if ((int)v8 > 1936158051)
    {
      if ((int)v8 > 1953330274)
      {
        if ((int)v8 > 1969317729)
        {
          if ((_DWORD)v8 == 1969317730 || (_DWORD)v8 == 1970302566)
            goto LABEL_91;
          v13 = 1969452135;
        }
        else
        {
          if ((_DWORD)v8 == 1953330275 || (_DWORD)v8 == 1953395827)
            goto LABEL_91;
          v13 = 1953526371;
        }
      }
      else if ((int)v8 > 1936941937)
      {
        if ((v8 - 1952609132) < 2 || (_DWORD)v8 == 1936941938)
          goto LABEL_91;
        v13 = 1952672875;
      }
      else
      {
        if ((_DWORD)v8 == 1936158052 || (_DWORD)v8 == 1936551267)
          goto LABEL_91;
        v13 = 1936880741;
      }
      goto LABEL_86;
    }
    if ((int)v8 > 1919118442)
    {
      if ((int)v8 > 1919971938)
      {
        if ((_DWORD)v8 == 1919971939 || (_DWORD)v8 == 1920492392)
          goto LABEL_91;
        v13 = 1935764848;
      }
      else
      {
        if ((_DWORD)v8 == 1919118443 || (_DWORD)v8 == 1919775843)
          goto LABEL_91;
        v13 = 1919841395;
      }
      goto LABEL_86;
    }
    if ((int)v8 <= 1852072819)
      break;
    if ((v8 - 1919054700) < 2 || (_DWORD)v8 == 1852072820)
      goto LABEL_91;
    v13 = 1886547828;
LABEL_86:
    if ((_DWORD)v8 == v13)
      goto LABEL_91;
    if ((_DWORD)v8 == 1668510829)
      MIDIDriverPlugin_DriverKit::syncAllPropertiesLocal(v7, (int)v12, v6);
    if (++v4 == (unsigned int *)v5)
      return;
  }
  if ((_DWORD)v8 != 1836610147 && (_DWORD)v8 != 1836610659)
  {
    v13 = 1852008039;
    goto LABEL_86;
  }
LABEL_91:
  if ((int)v8 <= 1836610146)
  {
    if ((int)v8 <= 1835103091)
    {
      if ((int)v8 > 1685220716)
      {
        if ((int)v8 > 1701209719)
        {
          switch((_DWORD)v8)
          {
            case 0x65666678:
              v14 = "is effect unit";
              break;
            case 0x656D6265:
              v14 = "embedded";
              break;
            case 0x66706E66:
              v14 = "factoryPatchFile";
              break;
            default:
              return;
          }
        }
        else
        {
          switch((_DWORD)v8)
          {
            case 0x64726D6D:
              v14 = "is drum machine";
              break;
            case 0x64726F77:
              v14 = "driver";
              break;
            case 0x64766572:
              v14 = "driverVersion";
              break;
            default:
              return;
          }
        }
      }
      else if ((int)v8 > 1668639075)
      {
        switch((_DWORD)v8)
        {
          case 0x63756964:
            v14 = "connUniqueID";
            break;
          case 0x64646561:
            v14 = "editorApp";
            break;
          case 0x646E616D:
            v14 = "displayName";
            break;
          default:
            return;
        }
      }
      else
      {
        switch((_DWORD)v8)
        {
          case 0x61657074:
            v14 = "associated endpoint";
            break;
          case 0x62726361:
            v14 = "broadcast";
            break;
          case 0x63616E72:
            v14 = "can route";
            break;
          default:
            return;
        }
      }
    }
    else if ((int)v8 <= 1835889519)
    {
      if ((int)v8 > 1835884906)
      {
        switch((_DWORD)v8)
        {
          case 0x6D6D616B:
            v14 = "manufacturer";
            break;
          case 0x6D6D6978:
            v14 = "is mixer";
            break;
          case 0x6D6D6F64:
            v14 = "model";
            break;
          default:
            return;
        }
      }
      else
      {
        switch((_DWORD)v8)
        {
          case 0x6D617374:
            v14 = "scheduleAheadMuSec";
            break;
          case 0x6D646964:
            v14 = "deviceID";
            break;
          case 0x6D696D67:
            v14 = "image";
            break;
          default:
            return;
        }
      }
    }
    else if ((int)v8 <= 1836082290)
    {
      switch((_DWORD)v8)
      {
        case 0x6D6D7370:
          v14 = "maxSysExSpeed";
          break;
        case 0x6D6E616D:
          v14 = "name";
          break;
        case 0x6D6F6666:
          v14 = "offline";
          break;
        default:
          return;
      }
    }
    else if ((int)v8 > 1836344167)
    {
      if ((_DWORD)v8 == 1836344168)
      {
        v14 = "transmitChannels";
      }
      else
      {
        if ((_DWORD)v8 != 1836411236)
          return;
        v14 = "uniqueID";
      }
    }
    else if ((_DWORD)v8 == 1836082291)
    {
      v14 = "pan disrupts stereo";
    }
    else
    {
      if ((_DWORD)v8 != 1836085878)
        return;
      v14 = "private";
    }
    goto LABEL_211;
  }
  if ((int)v8 > 1936158051)
  {
    if ((int)v8 <= 1952672874)
    {
      if ((int)v8 > 1936941937)
      {
        switch((_DWORD)v8)
        {
          case 0x73736372:
            v14 = "supports MSC";
            break;
          case 0x7462736C:
            v14 = "transmits bank select LSB";
            break;
          case 0x7462736D:
            v14 = "transmits bank select MSB";
            break;
          default:
            return;
        }
      }
      else
      {
        switch((_DWORD)v8)
        {
          case 0x73676D64:
            v14 = "supports General MIDI";
            break;
          case 0x736D6D63:
            v14 = "supports MMC";
            break;
          case 0x73727465:
            v14 = "single realtime entity";
            break;
          default:
            return;
        }
      }
    }
    else if ((int)v8 <= 1953526370)
    {
      switch((_DWORD)v8)
      {
        case 0x74636C6B:
          v14 = "transmits clock";
          break;
        case 0x746D7463:
          v14 = "transmits MTC";
          break;
        case 0x746E7473:
          v14 = "transmits notes";
          break;
        default:
          return;
      }
    }
    else if ((int)v8 > 1969452134)
    {
      if ((_DWORD)v8 == 1969452135)
      {
        v14 = "ump endpoint";
      }
      else
      {
        if ((_DWORD)v8 != 1970302566)
          return;
        v14 = "userPatchFile";
      }
    }
    else if ((_DWORD)v8 == 1953526371)
    {
      v14 = "transmits program changes";
    }
    else
    {
      if ((_DWORD)v8 != 1969317730)
        return;
      v14 = "active group bitmap";
    }
LABEL_211:
    applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v48, v14);
    v15 = (const __CFString *)v48;
    MIDIPropertyType = getMIDIPropertyType(v8);
    TypeID = (MIDIServer *)CFStringGetTypeID();
    if ((MIDIServer *)MIDIPropertyType == TypeID)
    {
      v18 = MIDIServer::defaultInstance(TypeID) + 2;
      v19 = (*(uint64_t (**)(uint64_t *))(*v18 + 16))(v18);
      cf.info = 0;
      if (!MIDIObjectGetStringProperty((MIDIObjectRef)v12, v15, (CFStringRef *)&cf.info) && cf.info)
      {
        applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cf, (CFTypeRef)cf.info);
        MIDIDriverPlugin_DriverKit::getCFProperty<applesauce::CF::StringRef>((uint64_t)&cf.data, (uint64_t)v7, v6, v8, v20, v21, v22, v23);
        if (v51)
        {
          caulk::expected<applesauce::CF::DictionaryRef,std::variant<int,int,__CFString const*>>::value((uint64_t)&cf.data);
          if (applesauce::CF::compare<applesauce::CF::StringRef,0,applesauce::CF::StringRef,0>((const __CFString *)cf.isa, (const __CFString **)&cf.data))
          {
            MIDIObjectSetStringProperty((MIDIObjectRef)v12, v15, (CFStringRef)cf.data);
          }
          if (v51)
            caulk::__expected_detail::destroy<applesauce::CF::StringRef,(void *)0>(cf.data);
        }
        if (cf.isa)
          CFRelease(cf.isa);
      }
      if (!v19)
        goto LABEL_275;
      goto LABEL_274;
    }
    v24 = (MIDIServer *)CFNumberGetTypeID();
    if ((MIDIServer *)MIDIPropertyType == v24)
    {
      v18 = MIDIServer::defaultInstance(v24) + 2;
      v25 = (*(uint64_t (**)(uint64_t *))(*v18 + 16))(v18);
      cf.isa = 0;
      if (MIDIDriverPlugin_DriverKit::getIntegerProperty(v12, v15, &cf, v26) || !cf.isa)
        goto LABEL_265;
      applesauce::CF::NumberRef::NumberRef((applesauce::CF::NumberRef *)&number, cf.isa);
      MIDIDriverPlugin_DriverKit::getCFProperty<applesauce::CF::NumberRef>((uint64_t)&cf.data, (uint64_t)v7, v6, v8, v27, v28, v29, v30);
      if (!v51)
      {
LABEL_263:
        if (number)
          CFRelease(number);
LABEL_265:
        if (!v25)
          goto LABEL_275;
        goto LABEL_274;
      }
      caulk::expected<applesauce::CF::DictionaryRef,std::variant<int,int,__CFString const*>>::value((uint64_t)&cf.data);
      if (number)
      {
        if (!cf.data)
          goto LABEL_278;
        if (CFNumberCompare(number, (CFNumberRef)cf.data, 0) == kCFCompareEqualTo)
          goto LABEL_261;
      }
      else
      {
        if (cf.data)
          v44 = -1;
        else
          v44 = 0;
        if (!v44)
        {
LABEL_261:
          if (v51)
            caulk::__expected_detail::destroy<applesauce::CF::NumberRef,(void *)0>(cf.data);
          goto LABEL_263;
        }
      }
      data = cf.data;
      if (cf.data)
      {
        CFRetain(cf.data);
        applesauce::CF::NumberRef::NumberRef((applesauce::CF::NumberRef *)&cf.info, data);
        if (cf.info)
        {
          v46 = applesauce::CF::convert_as<int,0>((const __CFNumber *)cf.info);
          if (HIDWORD(v46))
            MIDIObjectSetIntegerProperty((MIDIObjectRef)v12, v15, v46);
          if (cf.info)
            CFRelease((CFTypeRef)cf.info);
          goto LABEL_261;
        }
LABEL_279:
        exception = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x1D826B7EC](exception, "Could not construct");
      }
LABEL_278:
      cf.info = 0;
      goto LABEL_279;
    }
    v31 = (MIDIServer *)CFDataGetTypeID();
    if ((MIDIServer *)MIDIPropertyType == v31)
    {
      v18 = MIDIServer::defaultInstance(v31) + 2;
      v32 = (*(uint64_t (**)(uint64_t *))(*v18 + 16))(v18);
      cf.info = 0;
      if (!MIDIObjectGetDataProperty((MIDIObjectRef)v12, v15, (CFDataRef *)&cf.info) && cf.info)
      {
        applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)&cf, (CFTypeRef)cf.info);
        MIDIDriverPlugin_DriverKit::getCFProperty<applesauce::CF::DataRef>((uint64_t)&cf.data, (uint64_t)v7, v6, v8, v33, v34, v35, v36);
        if (v51)
        {
          caulk::expected<applesauce::CF::DictionaryRef,std::variant<int,int,__CFString const*>>::value((uint64_t)&cf.data);
          if (!applesauce::CF::operator==((CFDataRef *)&cf, (CFDataRef *)&cf.data))
            MIDIObjectSetDataProperty((MIDIObjectRef)v12, v15, (CFDataRef)cf.data);
          if (v51)
            caulk::__expected_detail::destroy<applesauce::CF::DataRef,(void *)0>(cf.data);
        }
        if (cf.isa)
          CFRelease(cf.isa);
      }
      if (!v32)
        goto LABEL_275;
LABEL_274:
      (*(void (**)(uint64_t *))(*v18 + 24))(v18);
LABEL_275:
      if (v48)
        CFRelease(v48);
      return;
    }
    v37 = (MIDIServer *)CFDictionaryGetTypeID();
    if ((MIDIServer *)MIDIPropertyType != v37)
      goto LABEL_275;
    v18 = MIDIServer::defaultInstance(v37) + 2;
    v38 = (*(uint64_t (**)(uint64_t *))(*v18 + 16))(v18);
    cf.info = 0;
    if (MIDIObjectGetDictionaryProperty((MIDIObjectRef)v12, v15, (CFDictionaryRef *)&cf.info) || !cf.info)
    {
LABEL_273:
      if (!v38)
        goto LABEL_275;
      goto LABEL_274;
    }
    applesauce::CF::DictionaryRef::DictionaryRef((applesauce::CF::DictionaryRef *)&cf, (CFTypeRef)cf.info);
    MIDIDriverPlugin_DriverKit::getCFProperty<applesauce::CF::DictionaryRef>((uint64_t)&cf.data, (uint64_t)v7, v6, v8, v39, v40, v41, v42);
    if (!v51)
    {
LABEL_271:
      if (cf.isa)
        CFRelease(cf.isa);
      goto LABEL_273;
    }
    caulk::expected<applesauce::CF::DictionaryRef,std::variant<int,int,__CFString const*>>::value((uint64_t)&cf.data);
    v43 = cf.data;
    if (cf.isa && cf.data)
    {
      if (CFEqual(cf.isa, cf.data))
        goto LABEL_269;
      v43 = cf.data;
    }
    else if (!((uint64_t)cf.isa | (uint64_t)cf.data))
    {
      goto LABEL_269;
    }
    MIDIObjectSetDictionaryProperty((MIDIObjectRef)v12, v15, (CFDictionaryRef)v43);
LABEL_269:
    if (v51)
      caulk::__expected_detail::destroy<applesauce::CF::DictionaryRef,(void *)0>(cf.data);
    goto LABEL_271;
  }
  if ((int)v8 <= 1919054700)
  {
    if ((int)v8 > 1852072819)
    {
      switch((_DWORD)v8)
      {
        case 0x6E646374:
          v14 = "nameConfigurationDictionary";
          break;
        case 0x70726F74:
          v14 = "protocol";
          break;
        case 0x7262736C:
          v14 = "receives bank select LSB";
          break;
        default:
          return;
      }
    }
    else
    {
      switch((_DWORD)v8)
      {
        case 0x6D787263:
          v14 = "max receive channels";
          break;
        case 0x6D787463:
          v14 = "max transmit channels";
          break;
        case 0x6E636667:
          v14 = "nameConfiguration";
          break;
        default:
          return;
      }
    }
    goto LABEL_211;
  }
  if ((int)v8 <= 1919841394)
  {
    switch((_DWORD)v8)
    {
      case 0x7262736D:
        v14 = "receives bank select MSB";
        break;
      case 0x72636C6B:
        v14 = "receives clock";
        break;
      case 0x726D7463:
        v14 = "receivesMTC";
        break;
      default:
        return;
    }
    goto LABEL_211;
  }
  if ((int)v8 > 1920492391)
  {
    if ((_DWORD)v8 == 1920492392)
    {
      v14 = "receiveChannels";
    }
    else
    {
      if ((_DWORD)v8 != 1935764848)
        return;
      v14 = "is sampler";
    }
    goto LABEL_211;
  }
  if ((_DWORD)v8 == 1919841395)
  {
    v14 = "receives notes";
    goto LABEL_211;
  }
  if ((_DWORD)v8 == 1919971939)
  {
    v14 = "receives program changes";
    goto LABEL_211;
  }
}

void sub_1D4E97CB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, CFTypeRef a11, CFTypeRef a12, CFTypeRef cf, CFTypeRef a14, const void *a15, uint64_t a16, char a17)
{
  uint64_t v17;
  int v18;

  if (a17)
    caulk::__expected_detail::destroy<applesauce::CF::DictionaryRef,(void *)0>(a15);
  if (cf)
    CFRelease(cf);
  if (v18)
    (*(void (**)(uint64_t))(*(_QWORD *)v17 + 24))(v17);
  if (a11)
    CFRelease(a11);
  _Unwind_Resume(exception_object);
}

applesauce::CF::StringRef *applesauce::CF::StringRef::StringRef(applesauce::CF::StringRef *this, char *a2)
{
  void **v3;
  CFIndex v4;
  CFStringRef v5;
  void *exception;
  void *__p[2];
  unsigned __int8 v9;

  std::string::basic_string[abi:ne180100]<0>(__p, a2);
  if ((v9 & 0x80u) == 0)
    v3 = __p;
  else
    v3 = (void **)__p[0];
  if ((v9 & 0x80u) == 0)
    v4 = v9;
  else
    v4 = (CFIndex)__p[1];
  v5 = CFStringCreateWithBytes(0, (const UInt8 *)v3, v4, 0x8000100u, 0);
  *(_QWORD *)this = v5;
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  if ((char)v9 < 0)
    operator delete(__p[0]);
  return this;
}

void sub_1D4E97F58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  CFTypeRef *v15;

  if (*v15)
    CFRelease(*v15);
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

MIDIDriverKitClient::State *MIDIDriverKitClient::State::State(MIDIDriverKitClient::State *this)
{
  void *v2;
  objc_class *v3;
  id v4;
  id v5;
  _QWORD v7[5];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;

  *(_QWORD *)this = dispatch_queue_create("config change queue", 0);
  *((_QWORD *)this + 1) = dispatch_queue_create("notification queue", 0);
  v8 = 0;
  v9 = &v8;
  v10 = 0x2050000000;
  v2 = (void *)getIOKNotificationPortClass(void)::softClass;
  v11 = getIOKNotificationPortClass(void)::softClass;
  if (!getIOKNotificationPortClass(void)::softClass)
  {
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 3221225472;
    v7[2] = ___ZL27getIOKNotificationPortClassv_block_invoke;
    v7[3] = &unk_1E98BA100;
    v7[4] = &v8;
    ___ZL27getIOKNotificationPortClassv_block_invoke((uint64_t)v7);
    v2 = (void *)v9[3];
  }
  v3 = objc_retainAutorelease(v2);
  _Block_object_dispose(&v8, 8);
  v4 = [v3 alloc];
  v5 = *((id *)this + 1);
  *((_QWORD *)this + 2) = objc_msgSend(v4, "initOnDispatchQueue:", v5);

  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 10) = 0;
  return this;
}

void sub_1D4E980A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  id *v7;
  id *v8;
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  applesauce::dispatch::v1::queue::~queue(v8);
  applesauce::dispatch::v1::queue::~queue(v7);
  _Unwind_Resume(a1);
}

Class ___ZL27getIOKNotificationPortClassv_block_invoke(uint64_t a1)
{
  Class result;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  if (!IOKittenLibraryCore(char **)::frameworkLibrary)
    IOKittenLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
  if (!IOKittenLibraryCore(char **)::frameworkLibrary)
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "void *IOKittenLibrary()");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, CFSTR("MIDIDriverPlugin_DriverKit.mm"), 39, CFSTR("%s"), 0);

    goto LABEL_8;
  }
  result = objc_getClass("IOKNotificationPort");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Class getIOKNotificationPortClass()_block_invoke");
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, CFSTR("MIDIDriverPlugin_DriverKit.mm"), 40, CFSTR("Unable to find class %s"), "IOKNotificationPort");

LABEL_8:
    __break(1u);
  }
  getIOKNotificationPortClass(void)::softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

void sub_1D4E98288(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  void *v11;

  _Unwind_Resume(a1);
}

void MIDIDriverPlugin_DriverKit::~MIDIDriverPlugin_DriverKit(MIDIDriverPlugin_DriverKit *this)
{
  MIDIDriverPlugin_DriverKit::~MIDIDriverPlugin_DriverKit(this);
  JUMPOUT(0x1D826BA98);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  v2 = *((_QWORD *)this + 11);
  if (v2)
  {
    v3 = *((_QWORD *)this + 12);
    v4 = (void *)*((_QWORD *)this + 11);
    if (v3 != v2)
    {
      do
      {
        v3 -= 296;
        std::__destroy_at[abi:ne180100]<MIDIDriverPlugin_DriverKit::Device,0>(v3);
      }
      while (v3 != v2);
      v4 = (void *)*((_QWORD *)this + 11);
    }
    *((_QWORD *)this + 12) = v2;
    operator delete(v4);
  }
  MIDIDriverKitClient::~MIDIDriverKitClient((MIDIDriverPlugin_DriverKit *)((char *)this + 72));
  MIDIDriverPlugin::~MIDIDriverPlugin(this);
}

uint64_t MIDIDriverPlugin_DriverKit::PrintObject(MIDIDriverPlugin_DriverKit *this, __sFILE *a2)
{
  fprintf(a2, "<%s 0x%x [%p]>", "MIDIDriverPlugin_DriverKit", *((_DWORD *)this + 2), this);
  fprintf(a2, " parent=0x%X", *((_QWORD *)this + 2));
  return fputc(10, a2);
}

BOOL TOpaqueObject<MIDIObject,unsigned int,BaseOpaqueObject>::isa(uint64_t a1, void *a2)
{
  return a2 == &TOpaqueRTTI<MIDIObject>::sRTTI || a2 == &BaseOpaqueObject::sBaseRTTI;
}

CFMutableDictionaryRef MIDIObject::ToPList(CFDictionaryRef *this)
{
  return MIDIObject::ToDictionary(this[3]);
}

uint64_t MIDIObject::ObjectType(MIDIObject *this)
{
  return 0xFFFFFFFFLL;
}

uint64_t MIDIDriverPlugin_DriverKit::FindDevices(MIDIDriverPlugin_DriverKit *this)
{
  return 4294956452;
}

uint64_t MIDIDriverPlugin_DriverKit::SendPacket(MIDIDriverPlugin_DriverKit *this, const MIDIPacketList *a2, void *a3, void *a4)
{
  return 4294956452;
}

uint64_t MIDIDriverPlugin_DriverKit::EnableSource(MIDIDriverPlugin_DriverKit *this, int a2, int a3)
{
  unint64_t RemoteRef;
  int v7;
  int v9;
  NSObject *v10;
  _DWORD v11[4];
  char v12;
  _BYTE buf[18];
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  RemoteRef = MIDIDriverPlugin_DriverKit::getRemoteRef(*((MIDIDriverPlugin_DriverKit **)this + 11), *((MIDIDriverPlugin_DriverKit **)this + 12), a2);
  if (!HIDWORD(RemoteRef))
    return 4294956462;
  v9 = RemoteRef;
  *(_QWORD *)buf = RemoteRef;
  *(_QWORD *)&buf[8] = a3 != 0;
  MIDIDriverKitClient::call((uint64_t)v11, *((_DWORD *)this + 19), 4u, (uint64_t *)buf, 2u, 0, 0, v7, 0, 0, 0, 0);
  if (v12)
    return 0;
  midiDriverKitLog();
  v10 = objc_retainAutorelease((id)midiDriverKitLog(void)::category);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = "MIDIDriverPlugin_DriverKit.mm";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 717;
    v14 = 1024;
    v15 = a2;
    v16 = 1024;
    v17 = v9;
    _os_log_impl(&dword_1D4E88000, v10, OS_LOG_TYPE_ERROR, "%25s:%-5d Could not enable source (local ref: %d, remote ref: %d)", buf, 0x1Eu);
  }
  return v11[0];
}

uint64_t MIDIDriverPlugin_DriverKit::SendEventList(MIDIDriverPlugin_DriverKit *this, const MIDIEventList *a2, _QWORD *a3, _DWORD *a4)
{
  UInt32 numPackets;
  unsigned int v5;
  MIDIEventPacket *packet;
  std::string::size_type v7;
  uint64_t wordCount;
  unint64_t v9;
  unint64_t v10;
  unint64_t *v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  _BYTE *v18;
  std::string::value_type *v19;
  std::string *v20;
  uint64_t v21;
  std::string::value_type v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  BOOL v29;
  unint64_t v30;
  unint64_t v31;
  _BYTE *v32;
  _BYTE *v33;
  unint64_t v34;
  UInt32 *words;
  char v36;
  char *v37;
  unint64_t v38;
  char v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  _BYTE *v44;
  std::string::value_type *v45;
  std::string *v46;
  unint64_t v47;
  std::string::value_type v48;
  char *v49;
  unint64_t v50;
  char v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  uint64_t v56;
  int v58;
  std::runtime_error *exception;
  std::string *v60;
  __int128 v61;
  std::string v62;
  std::string v63;
  uint64_t v64;

  v64 = *MEMORY[0x1E0C80C00];
  numPackets = a2->numPackets;
  if (numPackets)
  {
    v5 = a4[1];
    packet = a2->packet;
    v7 = *((_QWORD *)a4 + 1);
    do
    {
      wordCount = packet->wordCount;
      v62.__r_.__value_.__r.__words[0] = v7;
      v62.__r_.__value_.__l.__size_ = __PAIR64__(wordCount, v5);
      v9 = 4 * wordCount;
      v10 = (wordCount << 63 >> 63) & (8 - ((4 * wordCount) & 4));
      v12 = a3[24];
      v11 = (unint64_t *)a3[25];
      v13 = v10 + 4 * wordCount + 16;
      v14 = v11 + 8;
      v15 = atomic_load(v11 + 8);
      if (v12 - v15 >= v13)
      {
        v16 = v12 - *v11;
        if (v16 >= 0x10)
          v17 = 16;
        else
          v17 = v12 - *v11;
        v18 = (_BYTE *)a3[23];
        if (v17)
        {
          v19 = &v18[*v11];
          v20 = &v62;
          v21 = v17;
          do
          {
            v22 = v20->__r_.__value_.__s.__data_[0];
            v20 = (std::string *)((char *)v20 + 1);
            *v19++ = v22;
            --v21;
          }
          while (v21);
          v18 = (_BYTE *)a3[23];
        }
        if (v16 <= 0xF)
        {
          do
            *v18++ = v62.__r_.__value_.__s.__data_[v17++];
          while (v17 != 16);
        }
        v23 = *v11 + 16;
        v24 = a3[24];
        if (v23 < v24)
          v25 = 0;
        else
          v25 = a3[24];
        v26 = v23 - v25;
        if (v26 < v24)
          v27 = 0;
        else
          v27 = a3[24];
        v28 = v26 - v27;
        *v11 = v23;
        v29 = v23 >= v24 || v26 >= v24;
        if (v29)
          *v11 = v28;
        v30 = v24 - v28;
        if (v9 >= v24 - v28)
          v31 = v24 - v28;
        else
          v31 = v9;
        v32 = (_BYTE *)a3[23];
        if (v31)
        {
          v33 = &v32[v28];
          v34 = v31;
          words = packet->words;
          do
          {
            v36 = *(_BYTE *)words;
            words = (UInt32 *)((char *)words + 1);
            *v33++ = v36;
            --v34;
          }
          while (v34);
          v32 = (_BYTE *)a3[23];
        }
        if (v9 > v30)
        {
          v37 = (char *)packet->words + v31;
          v38 = v31 - v9;
          do
          {
            v39 = *v37++;
            *v32++ = v39;
            ++v38;
          }
          while (v38);
        }
        v40 = *v11 + v9;
        *v11 = v40;
        v41 = a3[24];
        if (v40 >= v41)
        {
          *v11 = v40 - v41;
          v40 -= v41;
        }
        v42 = v41 - v40;
        if (v10 >= v41 - v40)
          v43 = v41 - v40;
        else
          v43 = v10;
        v44 = (_BYTE *)a3[23];
        if (v43)
        {
          v45 = &v44[v40];
          v46 = &v63;
          v47 = v43;
          do
          {
            v48 = v46->__r_.__value_.__s.__data_[0];
            v46 = (std::string *)((char *)v46 + 1);
            *v45++ = v48;
            --v47;
          }
          while (v47);
          v44 = (_BYTE *)a3[23];
        }
        if (v10 > v42)
        {
          v49 = (char *)&v63 + v43;
          v50 = v10 - v43;
          do
          {
            v51 = *v49++;
            *v44++ = v51;
            --v50;
          }
          while (v50);
        }
        v52 = *v11 + v10;
        *v11 = v52;
        v53 = a3[24];
        v29 = v52 >= v53;
        v54 = v52 - v53;
        if (v29)
          *v11 = v54;
        __dmb(0xBu);
        do
          v55 = __ldaxr(v14);
        while (__stlxr(v55 + v13, v14));
      }
      packet = (MIDIEventPacket *)((char *)packet + 4 * packet->wordCount + 12);
      --numPackets;
    }
    while (numPackets);
  }
  v56 = caulk::mach::os_eventlink::signal_or_error((caulk::mach::os_eventlink *)(a3 + 30));
  if ((v56 & 0xFF00000000) == 0)
  {
    v58 = v56;
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::to_string(&v63, v58);
    v60 = std::string::insert(&v63, 0, "couldn't signal and wait error: ", 0x20uLL);
    v61 = *(_OWORD *)&v60->__r_.__value_.__l.__data_;
    v62.__r_.__value_.__r.__words[2] = v60->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v62.__r_.__value_.__l.__data_ = v61;
    v60->__r_.__value_.__l.__size_ = 0;
    v60->__r_.__value_.__r.__words[2] = 0;
    v60->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v62);
  }
  return 0;
}

void sub_1D4E987E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  void *v21;
  int v22;

  if (a14 < 0)
    operator delete(__p);
  if (a21 < 0)
  {
    operator delete(a16);
    if ((v22 & 1) == 0)
LABEL_8:
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

uint64_t MIDIDriverPlugin_DriverKit::getRemoteRef(MIDIDriverPlugin_DriverKit *this, MIDIDriverPlugin_DriverKit *a2, int a3)
{
  uint64_t i;
  _DWORD *j;
  uint64_t v5;
  uint64_t v6;
  unsigned int *v7;

  if (this == a2)
  {
    v5 = 0;
    v6 = 0;
  }
  else
  {
    while (2)
    {
      if (*(_DWORD *)this == a3)
      {
        v7 = (unsigned int *)((char *)this + 4);
LABEL_18:
        v6 = *v7;
        v5 = 0x100000000;
      }
      else
      {
        for (i = *((_QWORD *)this + 1); i != *((_QWORD *)this + 2); i += 56)
        {
          if (*(_DWORD *)i == a3)
          {
            v7 = (unsigned int *)(i + 4);
            goto LABEL_18;
          }
          for (j = *(_DWORD **)(i + 8); j != *(_DWORD **)(i + 16); j += 2)
          {
            if (*j == a3)
            {
LABEL_17:
              v7 = j + 1;
              goto LABEL_18;
            }
          }
          for (j = *(_DWORD **)(i + 32); j != *(_DWORD **)(i + 40); j += 4)
          {
            if (*j == a3)
              goto LABEL_17;
          }
        }
        v5 = 0;
        v6 = 0;
        this = (MIDIDriverPlugin_DriverKit *)((char *)this + 296);
        if (this != a2)
          continue;
      }
      break;
    }
  }
  return v6 | v5;
}

uint64_t applesauce::raii::v1::detail::ScopeGuard<MIDIDriverKitClient::MIDIDriverKitClient(applesauce::iokit::io_object_holder,std::function<void ()(unsigned int,std::span<unsigned int const,18446744073709551615ul>)>)::{lambda(void)#1},applesauce::raii::v1::detail::StackFailPolicy>::~ScopeGuard(uint64_t a1)
{
  io_connect_t v2;

  if ((int)MEMORY[0x1D826BA68]() > *(_DWORD *)a1)
  {
    v2 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4);
    if (v2)
      IOConnectRelease(v2);
  }
  return a1;
}

uint64_t MIDIDriverKitClient::requestConfigChangeCallback(MIDIDriverKitClient *this, void *a2, __int128 *a3, void *a4)
{
  uint64_t result;
  uint64_t v5;
  void *exception;
  __int128 v7;
  uint64_t v8;

  if (a4 <= 2)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Incorrect size for request config change!");
  }
  result = *((_QWORD *)this + 10);
  if (result)
  {
    v5 = *((_QWORD *)a3 + 2);
    v7 = *a3;
    v8 = v5;
    return (*(uint64_t (**)(uint64_t, __int128 *))(*(_QWORD *)result + 48))(result, &v7);
  }
  return result;
}

void sub_1D4E98A28(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void MIDIDriverKitClient::propertiesChangedCallback(MIDIDriverKitClient *this, void *a2, uint64_t *a3, void *a4)
{
  uint64_t *v5;
  uint64_t v6;
  unsigned int v7;
  char *v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  void *exception;
  int v14;
  _QWORD v15[2];

  if (((_DWORD)a4 - 1) <= 1)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "properties changed, bad size!");
  }
  v5 = a3 + 1;
  v6 = *a3;
  v7 = (_DWORD)a4 - 2;
  v8 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(((_DWORD)a4 - 2));
  v9 = 8 * v7;
  v10 = v8;
  do
  {
    v11 = *v5++;
    *(_DWORD *)v10 = v11;
    v10 += 4;
    v9 -= 8;
  }
  while (v9);
  v12 = *((_QWORD *)this + 6);
  if (v12)
  {
    v15[0] = v8;
    v15[1] = (v10 - v8) >> 2;
    v14 = v6;
    (*(void (**)(uint64_t, int *, _QWORD *))(*(_QWORD *)v12 + 48))(v12, &v14, v15);
  }
  if (v8)
    operator delete(v8);
}

void sub_1D4E98B14(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRef::TypeRef(applesauce::CF::TypeRef *this, char *a2)
{
  void **v3;
  CFIndex v4;
  CFStringRef v5;
  void *exception;
  void *__p[2];
  unsigned __int8 v9;

  std::string::basic_string[abi:ne180100]<0>(__p, a2);
  if ((v9 & 0x80u) == 0)
    v3 = __p;
  else
    v3 = (void **)__p[0];
  if ((v9 & 0x80u) == 0)
    v4 = v9;
  else
    v4 = (CFIndex)__p[1];
  v5 = CFStringCreateWithBytes(0, (const UInt8 *)v3, v4, 0x8000100u, 0);
  *(_QWORD *)this = v5;
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  if ((char)v9 < 0)
    operator delete(__p[0]);
  return this;
}

void sub_1D4E98BF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  CFTypeRef *v15;

  if (*v15)
    CFRelease(*v15);
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::vector<void const*>::reserve(void **a1, unint64_t a2)
{
  int64_t v3;
  char *v4;
  char *v5;
  uint64_t v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  uint64_t v11;

  if (a2 > ((_BYTE *)a1[2] - (_BYTE *)*a1) >> 3)
  {
    if (a2 >> 61)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v3 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v4 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(a2);
    v5 = &v4[v3 & 0xFFFFFFFFFFFFFFF8];
    v7 = &v4[8 * v6];
    v9 = (char *)*a1;
    v8 = (char *)a1[1];
    v10 = v5;
    if (v8 != *a1)
    {
      do
      {
        v11 = *((_QWORD *)v8 - 1);
        v8 -= 8;
        *((_QWORD *)v10 - 1) = v11;
        v10 -= 8;
      }
      while (v8 != v9);
      v8 = (char *)*a1;
    }
    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8)
      operator delete(v8);
  }
}

caulk::log_category *caulk::log_category::log_category(caulk::log_category *this, const char *subsystem, const char *category)
{
  os_log_t v4;
  void *v5;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  v4 = os_log_create(subsystem, category);
  v5 = *(void **)this;
  *(_QWORD *)this = v4;

  return this;
}

void sub_1D4E98EC4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1D4E99024(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1D4E9922C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

void sub_1D4E99418(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1D4E994AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1D4E99534(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__optional_destruct_base<std::pair<MIDICIDevice * {__strong},MIDIUMPCIProfile * {__strong}>,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1D4E995D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  va_list va;

  va_start(va, a2);
  std::__optional_destruct_base<std::pair<MIDICIDevice * {__strong},MIDIUMPCIProfile * {__strong}>,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)va);

  _Unwind_Resume(a1);
}

void sub_1D4E9970C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1D4E997A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1D4E99858(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1D4E998C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

uint64_t std::__optional_destruct_base<std::pair<MIDICIDevice * {__strong},MIDIUMPCIProfile * {__strong}>,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  if (*(_BYTE *)(a1 + 16))
  {

  }
  return a1;
}

void swix::connection::~connection(swix::connection *this)
{
  *(_QWORD *)this = &off_1E98B8568;
  std::shared_ptr<swix::connection::state>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &off_1E98B8568;
  std::shared_ptr<swix::connection::state>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x1D826BA98);
}

void swix::connection::configure_rebuilt_connection()
{
  std::terminate();
}

uint64_t std::shared_ptr<swix::connection::state>::~shared_ptr[abi:ne180100](uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return a1;
}

void swix::ipc_endpoint::~ipc_endpoint(swix::ipc_endpoint *this)
{
  char *v2;
  char *v3;
  uint64_t v4;

  *(_QWORD *)this = &off_1E98B8590;
  v2 = (char *)this + 24;
  v3 = (char *)*((_QWORD *)this + 6);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  *(_QWORD *)this = &off_1E98B8568;
  std::shared_ptr<swix::connection::state>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  char *v2;
  char *v3;
  uint64_t v4;

  *(_QWORD *)this = &off_1E98B8590;
  v2 = (char *)this + 24;
  v3 = (char *)*((_QWORD *)this + 6);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
    {
LABEL_6:
      *(_QWORD *)this = &off_1E98B8568;
      std::shared_ptr<swix::connection::state>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
      JUMPOUT(0x1D826BA98);
    }
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  goto LABEL_6;
}

void swix::ipc_endpoint::configure_rebuilt_connection(swix::ipc_endpoint *this, xpc_connection_t *a2)
{
  _xpc_connection_s *v3;
  _QWORD aBlock[5];

  v3 = *a2;
  aBlock[0] = MEMORY[0x1E0C809B0];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZN4swix12ipc_endpoint28configure_rebuilt_connectionERKN10applesauce3xpc10connectionE_block_invoke;
  aBlock[3] = &__block_descriptor_tmp_10_141;
  aBlock[4] = this;
  swix::connection::state::set_handler(*((_QWORD *)this + 1), v3, aBlock);
  xpc_connection_activate(*a2);
}

void ___ZN4swix12ipc_endpoint28configure_rebuilt_connectionERKN10applesauce3xpc10connectionE_block_invoke(uint64_t a1, xpc_object_t object)
{
  uint64_t v2;
  xpc_object_t objecta;

  v2 = *(_QWORD *)(a1 + 32);
  objecta = object;
  if (object)
    xpc_retain(object);
  else
    objecta = xpc_null_create();
  swix::ipc_endpoint::handle_event_or_error(v2, &objecta);
  xpc_release(objecta);
}

void swix::connection::state::set_handler(uint64_t a1, _xpc_connection_s *a2, void *aBlock)
{
  void *v5;
  const void *v6;
  void *v7;
  const void *v8;
  _QWORD v9[6];

  if (*(_QWORD *)(a1 + 168))
  {
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 0x40000000;
    v9[2] = ___ZN4swix10connection5state11set_handlerEP17_xpc_connection_sU13block_pointerFvPvE_block_invoke;
    v9[3] = &unk_1E98BA190;
    v9[4] = aBlock;
    v9[5] = a1;
    v5 = _Block_copy(v9);
    v6 = *(const void **)(a1 + 144);
    *(_QWORD *)(a1 + 144) = v5;
    if (v6)
      _Block_release(v6);
  }
  else
  {
    if (aBlock)
      v7 = _Block_copy(aBlock);
    else
      v7 = 0;
    v8 = *(const void **)(a1 + 144);
    *(_QWORD *)(a1 + 144) = v7;
    if (v8)
      _Block_release(v8);
  }
  xpc_connection_set_event_handler(a2, *(xpc_handler_t *)(a1 + 144));
}

void ___ZN4swix10connection5state11set_handlerEP17_xpc_connection_sU13block_pointerFvPvE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  NSObject *v9;
  dispatch_time_t v10;
  unint64_t *p_shared_owners;
  unint64_t v12;

  v3 = *(uint64_t **)(*(_QWORD *)(a1 + 40) + 168);
  v5 = *v3;
  v4 = (std::__shared_weak_count *)v3[1];
  if (!v4 || (v7 = std::__shared_weak_count::lock(v4)) == 0)
    std::__throw_bad_weak_ptr[abi:ne180100]();
  v8 = v7;
  v9 = *(NSObject **)(v5 + 64);
  v10 = dispatch_time(0, *(_QWORD *)(v5 + 16));
  dispatch_source_set_timer(v9, v10, 0xFFFFFFFFFFFFFFFFLL, *(uint64_t *)(v5 + 16) >> 6);
  (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), a2);
  dispatch_source_set_timer(*(dispatch_source_t *)(v5 + 64), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
  p_shared_owners = (unint64_t *)&v8->__shared_owners_;
  do
    v12 = __ldaxr(p_shared_owners);
  while (__stlxr(v12 - 1, p_shared_owners));
  if (!v12)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
}

void sub_1D4E99E78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  swix::detail::watchdog_timer::transaction::~transaction((swix::detail::watchdog_timer::transaction *)&a9);
  _Unwind_Resume(a1);
}

void swix::detail::watchdog_timer::transaction::~transaction(swix::detail::watchdog_timer::transaction *this)
{
  dispatch_source_set_timer(*(dispatch_source_t *)(*(_QWORD *)this + 64), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0);
  std::shared_ptr<swix::connection::state>::~shared_ptr[abi:ne180100]((uint64_t)this);
}

void std::__throw_bad_weak_ptr[abi:ne180100]()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
  *exception = MEMORY[0x1E0DE4F80] + 16;
}

void swix::ipc_endpoint::handle_event_or_error(uint64_t a1, _QWORD *a2)
{
  xpc_object_t v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  int v8;
  void **v9;
  uint64_t v10;
  xpc_object_t v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  char *v17;
  void **v18;
  xpc_object_t v19;
  void **v20;
  char *v21;
  _BYTE *v22;
  void **v23;
  _BYTE buf[22];
  char v25;
  _BYTE object[12];
  __int16 v27;
  _BYTE *v28;
  void *__p[2];
  char v30;
  void **v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v4 = (xpc_object_t)*a2;
  v5 = MEMORY[0x1E0C812F8];
  if (*a2 && MEMORY[0x1D826C5A8](*a2) == v5)
    xpc_retain(v4);
  else
    v4 = xpc_null_create();
  if (MEMORY[0x1D826C5A8](v4) != v5)
  {
    v6 = *(_QWORD *)(a1 + 8);
    v7 = *(NSObject **)(v6 + 80);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      v20 = __p;
      swix::connection::description((swix::connection *)__p, v6);
      if (v30 < 0)
        v20 = (void **)__p[0];
      v21 = (char *)MEMORY[0x1D826C4DC](*a2);
      std::string::basic_string[abi:ne180100]<0>(buf, v21);
      free(v21);
      if (v25 >= 0)
        v22 = buf;
      else
        v22 = *(_BYTE **)buf;
      *(_DWORD *)object = 136315394;
      *(_QWORD *)&object[4] = v20;
      v27 = 2080;
      v28 = v22;
      _os_log_error_impl(&dword_1D4E88000, v7, OS_LOG_TYPE_ERROR, "connection %s : error %s", object, 0x16u);
      if (v25 < 0)
        operator delete(*(void **)buf);
      if (v30 < 0)
        operator delete(__p[0]);
      v6 = *(_QWORD *)(a1 + 8);
    }
    v8 = *(unsigned __int8 *)(v6 + 89);
    std::__function::__value_func<void ()(applesauce::iokit::io_object_holder)>::__value_func[abi:ne180100]((uint64_t)__p, a1 + 24);
    if (!v31)
      goto LABEL_15;
    (*((void (**)(void **, uint64_t, _QWORD *))*v31 + 6))(v31, a1, a2);
    v9 = v31;
    if (v31 == __p)
    {
      v10 = 4;
      v9 = __p;
    }
    else
    {
      if (!v31)
        goto LABEL_15;
      v10 = 5;
    }
    (*((void (**)(void))*v9 + v10))();
LABEL_15:
    if (v8)
    {
      v12 = *(_QWORD *)(a1 + 8);
      v13 = *(NSObject **)(v12 + 80);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        swix::connection::description((swix::connection *)__p, v12);
        if (v30 >= 0)
          v23 = __p;
        else
          v23 = (void **)__p[0];
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = v23;
        _os_log_error_impl(&dword_1D4E88000, v13, OS_LOG_TYPE_ERROR, "auto-cancelling %s", buf, 0xCu);
        if (v30 < 0)
          operator delete(__p[0]);
        v12 = *(_QWORD *)(a1 + 8);
      }
      swix::connection::state::cancel_connection(v12, 0);
    }
    goto LABEL_34;
  }
  if (v4)
  {
    xpc_retain(v4);
    v11 = v4;
  }
  else
  {
    v11 = xpc_null_create();
  }
  v14 = *(_QWORD *)(a1 + 8);
  if (*(_BYTE *)(v14 + 88))
  {
    v15 = *(NSObject **)(v14 + 80);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      swix::connection::xpc_connection((swix::connection *)object, a1);
      v16 = *(_QWORD *)object;
      v17 = (char *)MEMORY[0x1D826C4DC](v11);
      std::string::basic_string[abi:ne180100]<0>(__p, v17);
      free(v17);
      if (v30 >= 0)
        v18 = __p;
      else
        v18 = (void **)__p[0];
      *(_DWORD *)buf = 134218242;
      *(_QWORD *)&buf[4] = v16;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = v18;
      _os_log_impl(&dword_1D4E88000, v15, OS_LOG_TYPE_DEFAULT, "%p received event %s", buf, 0x16u);
      if (v30 < 0)
        operator delete(__p[0]);
      xpc_release(*(xpc_object_t *)object);
    }
  }
  if (v11 && MEMORY[0x1D826C5A8](v11) == v5)
  {
    xpc_retain(v11);
    v19 = v11;
  }
  else
  {
    v19 = xpc_null_create();
  }
  swix::decode_message::decode_message((uint64_t)__p, v19, *(_QWORD *)(*(_QWORD *)(a1 + 8) + 80));
  xpc_release(v19);
  (*(void (**)(_BYTE *__return_ptr, _QWORD, void **))(**(_QWORD **)(a1 + 56) + 16))(buf, *(_QWORD *)(a1 + 56), __p);
  if (MEMORY[0x1D826C5A8](*(_QWORD *)&buf[8]) == v5)
    swix::connection::send((swix::connection *)a1, (const swix::encode_message *)buf);
  xpc_release(*(xpc_object_t *)&buf[8]);
  xpc_release(__p[1]);
  xpc_release(v11);
LABEL_34:
  xpc_release(v4);
}

void sub_1D4E9A2E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, uint64_t a10, uint64_t a11, xpc_object_t a12, uint64_t a13, uint64_t a14, xpc_object_t object, uint64_t a16, uint64_t a17, void *__p, xpc_object_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

void sub_1D4E9A408(uint64_t a1, int a2)
{
  if (a2)
    JUMPOUT(0x1D4E9A414);
  JUMPOUT(0x1D4E9A3F8);
}

void swix::connection::description(swix::connection *this, uint64_t a2)
{
  void *v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  void *v7;

  swix::connection::state::xpc_connection((swix::connection::state *)&v7, a2);
  v3 = v7;
  v4 = MEMORY[0x1D826C5A8](v7);
  v5 = MEMORY[0x1E0C812E0];
  if (v4 == MEMORY[0x1E0C812E0])
  {
    v6 = (char *)MEMORY[0x1D826C4DC](v3);
    std::string::basic_string[abi:ne180100]<0>(this, v6);
    free(v6);
  }
  xpc_release(v3);
  if (v4 != v5)
    std::string::basic_string[abi:ne180100]<0>(this, "(destroyed connection)");
}

void sub_1D4E9A590(_Unwind_Exception *a1)
{
  void *v1;

  xpc_release(v1);
  _Unwind_Resume(a1);
}

void swix::connection::state::cancel_connection(uint64_t a1, int a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;
  void *v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  xpc_object_t v11;
  xpc_object_t v12;
  void *v13;
  void **v14;
  _BYTE *v15;
  void *block[2];
  void (*v17)(uint64_t);
  void *v18;
  uint64_t v19;
  xpc_object_t object;
  void *v21;
  _BYTE buf[12];
  char v23;
  uint8_t v24[4];
  _BYTE *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v4 = (os_unfair_lock_s *)(a1 + 152);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 152));
  v5 = *(_QWORD *)(a1 + 160);
  *(_QWORD *)(a1 + 160) = 0;
  os_unfair_lock_unlock(v4);
  if (v5)
  {
    swix::detail::connection_impl::get((swix::detail::connection_impl *)&v21, *(void **)(v5 + 16));
    v6 = v21;
    if (MEMORY[0x1D826C5A8](v21) == MEMORY[0x1E0C812E0])
    {
      v7 = *(NSObject **)v5;
      if (os_log_type_enabled(*(os_log_t *)v5, OS_LOG_TYPE_DEBUG))
      {
        applesauce::xpc::connection::to_debug_string((applesauce::xpc::connection *)block, *(_QWORD *)(v5 + 16));
        v14 = SHIBYTE(v17) >= 0 ? block : (void **)block[0];
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = v14;
        _os_log_debug_impl(&dword_1D4E88000, v7, OS_LOG_TYPE_DEBUG, "canceling connection %s", buf, 0xCu);
        if (SHIBYTE(v17) < 0)
          operator delete(block[0]);
      }
      block[0] = (void *)MEMORY[0x1E0C809B0];
      block[1] = (void *)1174405120;
      v17 = ___ZN4swix6detail15connection_impl6cancelENS_19CancellationContextE_block_invoke;
      v18 = &__block_descriptor_tmp_14;
      v19 = v5;
      object = v6;
      if (v6)
        xpc_retain(v6);
      else
        object = xpc_null_create();
      v8 = *(NSObject **)(v5 + 8);
      if (a2)
      {
        if (v8)
          dispatch_retain(*(dispatch_object_t *)(v5 + 8));
        dispatch_assert_queue_not_V2(v8);
        if (v8)
          dispatch_release(v8);
        v9 = *(NSObject **)(v5 + 8);
        if (v9)
        {
          dispatch_retain(*(dispatch_object_t *)(v5 + 8));
          dispatch_barrier_async_and_wait(v9, block);
          dispatch_release(v9);
        }
        else
        {
          dispatch_barrier_async_and_wait(0, block);
        }
      }
      else
      {
        if (v8)
          dispatch_retain(*(dispatch_object_t *)(v5 + 8));
        dispatch_assert_queue_V2(v8);
        if (v8)
          dispatch_release(v8);
        ___ZN4swix6detail15connection_impl6cancelENS_19CancellationContextE_block_invoke((uint64_t)block);
      }
      v10 = *(NSObject **)v5;
      if (os_log_type_enabled(*(os_log_t *)v5, OS_LOG_TYPE_DEBUG))
      {
        applesauce::xpc::connection::to_debug_string((applesauce::xpc::connection *)buf, *(_QWORD *)(v5 + 16));
        if (v23 >= 0)
          v15 = buf;
        else
          v15 = *(_BYTE **)buf;
        *(_DWORD *)v24 = 136315138;
        v25 = v15;
        _os_log_debug_impl(&dword_1D4E88000, v10, OS_LOG_TYPE_DEBUG, "proceeding after canceling %s", v24, 0xCu);
        if (v23 < 0)
          operator delete(*(void **)buf);
      }
      v11 = xpc_null_create();
      v12 = xpc_null_create();
      v13 = *(void **)(v5 + 16);
      *(_QWORD *)(v5 + 16) = v11;
      xpc_release(v13);
      xpc_release(v12);
      xpc_release(object);
      object = 0;
    }
    xpc_release(v6);
  }
}

void sub_1D4E9A85C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, xpc_object_t object)
{
  void *v16;

  xpc_release(v16);
  xpc_release(object);
  _Unwind_Resume(a1);
}

xpc_object_t swix::detail::connection_impl::get(swix::detail::connection_impl *this, void *a2)
{
  xpc_object_t result;

  *(_QWORD *)this = a2;
  if (a2)
    return xpc_retain(a2);
  result = xpc_null_create();
  *(_QWORD *)this = result;
  return result;
}

void applesauce::xpc::connection::to_debug_string(applesauce::xpc::connection *this, uint64_t a2)
{
  char *v3;

  v3 = (char *)MEMORY[0x1D826C4DC](a2);
  std::string::basic_string[abi:ne180100]<0>(this, v3);
  free(v3);
}

void ___ZN4swix6detail15connection_impl6cancelENS_19CancellationContextE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  void **v4;
  void *__p[2];
  char v6;
  uint8_t buf[4];
  void **v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  xpc_connection_set_event_handler(*(xpc_connection_t *)(a1 + 40), &__block_literal_global_13);
  xpc_connection_cancel(*(xpc_connection_t *)(a1 + 40));
  v3 = *(NSObject **)v2;
  if (os_log_type_enabled(*(os_log_t *)v2, OS_LOG_TYPE_DEBUG))
  {
    applesauce::xpc::connection::to_debug_string((applesauce::xpc::connection *)__p, *(_QWORD *)(v2 + 16));
    if (v6 >= 0)
      v4 = __p;
    else
      v4 = (void **)__p[0];
    *(_DWORD *)buf = 136315138;
    v8 = v4;
    _os_log_debug_impl(&dword_1D4E88000, v3, OS_LOG_TYPE_DEBUG, "canceled connection %s", buf, 0xCu);
    if (v6 < 0)
      operator delete(__p[0]);
  }
}

xpc_object_t __copy_helper_block_e8_40c35_ZTSKN10applesauce3xpc10connectionE(uint64_t a1, uint64_t a2)
{
  void *v3;
  xpc_object_t result;

  v3 = *(void **)(a2 + 40);
  *(_QWORD *)(a1 + 40) = v3;
  if (v3)
    return xpc_retain(v3);
  result = xpc_null_create();
  *(_QWORD *)(a1 + 40) = result;
  return result;
}

void __destroy_helper_block_e8_40c35_ZTSKN10applesauce3xpc10connectionE(uint64_t a1)
{
  xpc_release(*(xpc_object_t *)(a1 + 40));
  *(_QWORD *)(a1 + 40) = 0;
}

void swix::connection::state::xpc_connection(swix::connection::state *this, uint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;

  v4 = (os_unfair_lock_s *)(a2 + 152);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 152));
  v5 = *(_QWORD *)(a2 + 160);
  if (v5)
    swix::detail::connection_impl::get(this, *(void **)(v5 + 16));
  else
    *(_QWORD *)this = xpc_null_create();
  os_unfair_lock_unlock(v4);
}

void swix::connection::xpc_connection(swix::connection *this, uint64_t a2)
{
  xpc_object_t v4;
  uint64_t v5;
  int v6;
  NSObject *v7;
  _BOOL4 v8;
  uint64_t v9;
  xpc_object_t v10;
  const applesauce::xpc::connection *v11;
  _QWORD *v12;
  uint64_t v13;
  std::runtime_error *exception;
  uint64_t v15;
  void (*v16)(uint64_t **, swix::connection *);
  uint64_t *v17;
  xpc_object_t v18;
  std::string buf;
  void *__p;
  char v21;
  xpc_object_t v22;
  dispatch_object_t object;
  _BYTE v24[24];
  _BYTE *v25;
  char v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  swix::connection::state::xpc_connection((swix::connection::state *)&v18, *(_QWORD *)(a2 + 8));
  v4 = v18;
  if (MEMORY[0x1D826C5A8](v18) != MEMORY[0x1E0C812E0])
  {
    v5 = *(_QWORD *)(a2 + 8);
    v6 = *(unsigned __int8 *)(v5 + 89);
    v7 = *(NSObject **)(v5 + 80);
    v8 = os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
    if (!v6)
    {
      if (v8)
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_log_error_impl(&dword_1D4E88000, v7, OS_LOG_TYPE_ERROR, "null connection", (uint8_t *)&buf, 2u);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x18uLL);
      std::string::basic_string[abi:ne180100]<0>(&buf, "null connection");
      std::runtime_error::runtime_error(exception, &buf);
      exception->__vftable = (std::runtime_error_vtbl *)&off_1E98B8610;
      LODWORD(exception[1].__vftable) = -2;
    }
    if (v8)
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_error_impl(&dword_1D4E88000, v7, OS_LOG_TYPE_ERROR, "rebuilding null connection", (uint8_t *)&buf, 2u);
      v5 = *(_QWORD *)(a2 + 8);
    }
    v15 = a2;
    v16 = (void (*)(uint64_t **, swix::connection *))caulk::function_ref<void ()(applesauce::xpc::connection const&)>::functor_invoker<swix::connection::xpc_connection(void)::$_0>;
    v17 = &v15;
    os_unfair_lock_lock((os_unfair_lock_t)(v5 + 152));
    v9 = *(_QWORD *)(v5 + 160);
    if (v9)
    {
      swix::detail::connection_impl::get(this, *(void **)(v9 + 16));
LABEL_20:
      os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 152));
      v10 = v18;
      goto LABEL_21;
    }
    swix::connection_config::connection_config(&buf, (const swix::connection_config *)(v5 + 16));
    swix::make_connection(this, (uint64_t)&buf);
    *(_QWORD *)(v5 + 160) = swix::detail::connection_impl::create((swix::detail::connection_impl *)&buf, (xpc_object_t *)this, v11);
    v16(&v17, this);
    if (v26)
    {
      v12 = v25;
      if (v25 == v24)
      {
        v13 = 4;
        v12 = v24;
        goto LABEL_13;
      }
      if (v25)
      {
        v13 = 5;
LABEL_13:
        (*(void (**)(void))(*v12 + 8 * v13))();
      }
    }
    if (object)
      dispatch_release(object);
    xpc_release(v22);
    v22 = 0;
    if (v21 < 0)
      operator delete(__p);
    if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
      operator delete(buf.__r_.__value_.__l.__data_);
    goto LABEL_20;
  }
  *(_QWORD *)this = v4;
  v10 = xpc_null_create();
  v18 = v10;
LABEL_21:
  xpc_release(v10);
}

void sub_1D4E9AD84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, xpc_object_t object, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

void swix::connection::send(swix::connection *this, const swix::encode_message *a2)
{
  uint64_t v4;
  NSObject *v5;
  _BOOL4 v6;
  xpc_object_t v7;
  xpc_connection_t v8;
  char *v9;
  void **v10;
  void *__p[2];
  char v12;
  xpc_object_t message;
  xpc_connection_t connection;
  uint8_t buf[4];
  xpc_connection_t v16;
  __int16 v17;
  void **v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  swix::connection::xpc_connection((swix::connection *)&connection, (uint64_t)this);
  swix::encode_message::xpc_message((swix::encode_message *)&message, (uint64_t)a2);
  v4 = *((_QWORD *)this + 1);
  if (*(_BYTE *)(v4 + 88))
  {
    v5 = *(NSObject **)(v4 + 80);
    v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
    v7 = message;
    if (v6)
    {
      v8 = connection;
      v9 = (char *)MEMORY[0x1D826C4DC](message);
      std::string::basic_string[abi:ne180100]<0>(__p, v9);
      free(v9);
      if (v12 >= 0)
        v10 = __p;
      else
        v10 = (void **)__p[0];
      *(_DWORD *)buf = 134218242;
      v16 = v8;
      v17 = 2080;
      v18 = v10;
      _os_log_impl(&dword_1D4E88000, v5, OS_LOG_TYPE_DEFAULT, "%p send msg %s", buf, 0x16u);
      if (v12 < 0)
        operator delete(__p[0]);
    }
  }
  else
  {
    v7 = message;
  }
  xpc_connection_send_message(connection, v7);
  xpc_release(v7);
  xpc_release(connection);
}

void sub_1D4E9AF6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, xpc_object_t object)
{
  void *v14;

  xpc_release(v14);
  xpc_release(object);
  _Unwind_Resume(a1);
}

uint64_t caulk::function_ref<void ()(applesauce::xpc::connection const&)>::functor_invoker<swix::connection::xpc_connection(void)::$_0>(_QWORD **a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)**a1 + 16))(**a1);
}

void swix::exception::~exception(std::runtime_error *this)
{
  std::runtime_error::~runtime_error(this);
  JUMPOUT(0x1D826BA98);
}

std::string *swix::connection_config::connection_config(std::string *this, const swix::connection_config *a2)
{
  __int128 v4;
  __int128 v5;
  void *v6;
  NSObject *v7;
  std::string::size_type v8;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v4 = *(_OWORD *)a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  if (*((char *)a2 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(this + 1, *((const std::string::value_type **)a2 + 3), *((_QWORD *)a2 + 4));
  }
  else
  {
    v5 = *(_OWORD *)((char *)a2 + 24);
    this[1].__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 5);
    *(_OWORD *)&this[1].__r_.__value_.__l.__data_ = v5;
  }
  v6 = (void *)*((_QWORD *)a2 + 6);
  this[2].__r_.__value_.__r.__words[0] = (std::string::size_type)v6;
  if (v6)
    xpc_retain(v6);
  else
    this[2].__r_.__value_.__r.__words[0] = (std::string::size_type)xpc_null_create();
  v7 = *((_QWORD *)a2 + 7);
  this[2].__r_.__value_.__l.__size_ = (std::string::size_type)v7;
  if (v7)
    dispatch_retain(v7);
  v8 = *((_QWORD *)a2 + 8);
  LOWORD(this[3].__r_.__value_.__l.__data_) = *((_WORD *)a2 + 36);
  this[2].__r_.__value_.__r.__words[2] = v8;
  std::__optional_copy_base<swix::timeout_config,false>::__optional_copy_base[abi:ne180100](&this[3].__r_.__value_.__s.__data_[8], (uint64_t)a2 + 80);
  return this;
}

void sub_1D4E9B0C4(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void swix::make_connection(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  const char *v11;
  xpc_connection_t mach_service;
  xpc_object_t v13;
  const char *v14;
  xpc_connection_t v15;
  xpc_object_t v16;
  xpc_object_t v17;
  void *v18;

  v4 = MEMORY[0x1D826C5A8](*(_QWORD *)(a2 + 48));
  v5 = MEMORY[0x1E0C812E0];
  v6 = v4 == MEMORY[0x1E0C812E0];
  v7 = *(char *)(a2 + 23);
  v8 = *(_QWORD *)(a2 + 8);
  if (v7 >= 0)
    v8 = *(unsigned __int8 *)(a2 + 23);
  v9 = *(unsigned __int8 *)(a2 + 47);
  v10 = (char)v9;
  if ((v9 & 0x80u) != 0)
    v9 = *(_QWORD *)(a2 + 32);
  if (v8)
    ++v6;
  if (v9)
    ++v6;
  if (v6 != 1)
    std::terminate();
  if (v8)
  {
    if (v7 >= 0)
      v11 = (const char *)a2;
    else
      v11 = *(const char **)a2;
    mach_service = xpc_connection_create_mach_service(v11, 0, 0);
    if (mach_service)
    {
      v13 = mach_service;
      *a1 = mach_service;
      goto LABEL_23;
    }
    v13 = xpc_null_create();
    *a1 = v13;
    if (v13)
    {
LABEL_23:
      if (MEMORY[0x1D826C5A8](v13) != v5)
        goto LABEL_29;
LABEL_30:
      xpc_retain(v13);
      goto LABEL_31;
    }
  }
  else
  {
    if (!v9)
    {
      v16 = xpc_null_create();
      *a1 = *(_QWORD *)(a2 + 48);
      *(_QWORD *)(a2 + 48) = xpc_null_create();
      v17 = xpc_null_create();
      v18 = *(void **)(a2 + 48);
      *(_QWORD *)(a2 + 48) = v16;
      xpc_release(v18);
      xpc_release(v17);
      return;
    }
    if (v10 >= 0)
      v14 = (const char *)(a2 + 24);
    else
      v14 = *(const char **)(a2 + 24);
    v15 = xpc_connection_create(v14, 0);
    v13 = v15;
    if (v15)
    {
      *a1 = v15;
    }
    else
    {
      v13 = xpc_null_create();
      *a1 = v13;
      if (!v13)
        goto LABEL_29;
    }
    if (MEMORY[0x1D826C5A8](v13) == v5)
      goto LABEL_30;
  }
LABEL_29:
  *a1 = xpc_null_create();
LABEL_31:
  xpc_release(v13);
}

uint64_t swix::detail::connection_impl::create(swix::detail::connection_impl *this, xpc_object_t *a2, const applesauce::xpc::connection *a3)
{
  uint64_t v5;
  int8x16_t v6;
  xpc_object_t v7;
  xpc_connection_t *v8;
  xpc_object_t v9;
  _BOOL4 v10;
  NSObject *v11;
  void **v12;
  void *__p[2];
  char v15;
  uint8_t buf[4];
  uint64_t v17;
  __int16 v18;
  void **v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v5 = operator new();
  v6 = *(int8x16_t *)((char *)this + 56);
  *(int8x16_t *)v5 = vextq_s8(v6, v6, 8uLL);
  if (v6.i64[0])
    dispatch_retain((dispatch_object_t)v6.i64[0]);
  v7 = *a2;
  *(_QWORD *)(v5 + 16) = *a2;
  v8 = (xpc_connection_t *)(v5 + 16);
  if (v7)
    xpc_retain(v7);
  else
    *v8 = (xpc_connection_t)xpc_null_create();
  v9 = xpc_null_create();
  v10 = xpc_equal(*a2, v9);
  xpc_release(v9);
  if (v10 || xpc_connection_get_context(*v8))
    std::terminate();
  xpc_connection_set_target_queue(*(xpc_connection_t *)(v5 + 16), *(dispatch_queue_t *)(v5 + 8));
  v11 = *(NSObject **)v5;
  if (os_log_type_enabled(*(os_log_t *)v5, OS_LOG_TYPE_DEFAULT))
  {
    applesauce::xpc::connection::to_debug_string((applesauce::xpc::connection *)__p, (uint64_t)*v8);
    if (v15 >= 0)
      v12 = __p;
    else
      v12 = (void **)__p[0];
    *(_DWORD *)buf = 134218242;
    v17 = v5;
    v18 = 2080;
    v19 = v12;
    _os_log_impl(&dword_1D4E88000, v11, OS_LOG_TYPE_DEFAULT, "created connimpl %p: %s", buf, 0x16u);
    if (v15 < 0)
      operator delete(__p[0]);
  }
  xpc_connection_set_context(*(xpc_connection_t *)(v5 + 16), (void *)v5);
  xpc_connection_set_finalizer_f(*v8, (xpc_finalizer_t)swix::detail::connection_impl::connection_impl(swix::connection_config const&,applesauce::xpc::connection const&)::{lambda(void *)#1}::__invoke);
  return v5;
}

void sub_1D4E9B460(_Unwind_Exception *a1)
{
  uint64_t v1;
  xpc_object_t *v2;
  NSObject *v4;

  applesauce::xpc::connection::~connection(v2);
  v4 = *(NSObject **)(v1 + 8);
  if (v4)
    dispatch_release(v4);
  MEMORY[0x1D826BA98](v1, 0xE0C40F9C386F3);
  _Unwind_Resume(a1);
}

void applesauce::xpc::connection::~connection(xpc_object_t *this)
{
  xpc_release(*this);
  *this = 0;
}

void swix::connection_config::~connection_config(swix::connection_config *this)
{
  swix::connection_config *v2;
  uint64_t v3;
  NSObject *v4;

  if (*((_BYTE *)this + 120))
  {
    v2 = (swix::connection_config *)*((_QWORD *)this + 14);
    if (v2 == (swix::connection_config *)((char *)this + 88))
    {
      v3 = 4;
      v2 = (swix::connection_config *)((char *)this + 88);
    }
    else
    {
      if (!v2)
        goto LABEL_7;
      v3 = 5;
    }
    (*(void (**)(void))(*(_QWORD *)v2 + 8 * v3))();
  }
LABEL_7:
  v4 = *((_QWORD *)this + 7);
  if (v4)
    dispatch_release(v4);
  xpc_release(*((xpc_object_t *)this + 6));
  *((_QWORD *)this + 6) = 0;
  if (*((char *)this + 47) < 0)
    operator delete(*((void **)this + 3));
  if (*((char *)this + 23) < 0)
    operator delete(*(void **)this);
}

{
  swix::connection_config *v2;
  uint64_t v3;
  void *v4;
  void *v5;

  if (*((_BYTE *)this + 120))
  {
    v2 = (swix::connection_config *)*((_QWORD *)this + 14);
    if (v2 == (swix::connection_config *)((char *)this + 88))
    {
      v3 = 4;
      v2 = (swix::connection_config *)((char *)this + 88);
    }
    else
    {
      if (!v2)
        goto LABEL_7;
      v3 = 5;
    }
    (*(void (**)(void))(*(_QWORD *)v2 + 8 * v3))();
  }
LABEL_7:

  v4 = (void *)*((_QWORD *)this + 7);
  *((_QWORD *)this + 7) = 0;

  v5 = (void *)*((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0;

  if (*((char *)this + 47) < 0)
    operator delete(*((void **)this + 3));
  if (*((char *)this + 23) < 0)
    operator delete(*(void **)this);
}

os_log_t *swix::detail::connection_impl::connection_impl(swix::connection_config const&,applesauce::xpc::connection const&)::{lambda(void *)#1}::__invoke(os_log_t *result)
{
  os_log_t *v1;
  NSObject *v2;
  NSObject *v3;
  int v4;
  os_log_t *v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v1 = result;
    v2 = *result;
    if (os_log_type_enabled(*result, OS_LOG_TYPE_DEFAULT))
    {
      v4 = 134217984;
      v5 = v1;
      _os_log_impl(&dword_1D4E88000, v2, OS_LOG_TYPE_DEFAULT, "destructor connimpl %p", (uint8_t *)&v4, 0xCu);
    }
    xpc_release(v1[2]);
    v1[2] = 0;
    v3 = v1[1];
    if (v3)
      dispatch_release(v3);
    JUMPOUT(0x1D826BA98);
  }
  return result;
}

void sub_1D4E9B680(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

_BYTE *std::__optional_copy_base<swix::timeout_config,false>::__optional_copy_base[abi:ne180100](_BYTE *a1, uint64_t a2)
{
  *a1 = 0;
  a1[40] = 0;
  if (*(_BYTE *)(a2 + 40))
  {
    *(_QWORD *)a1 = *(_QWORD *)a2;
    std::__function::__value_func<void ()(applesauce::iokit::io_object_holder)>::__value_func[abi:ne180100]((uint64_t)(a1 + 8), a2 + 8);
    a1[40] = 1;
  }
  return a1;
}

void sub_1D4E9B6D8(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;

  v3 = v2;
  if (*(_BYTE *)(v3 + 40))
  {
    v5 = *(_QWORD **)(v3 + 32);
    if (v5 == v1)
    {
      v6 = 4;
    }
    else
    {
      if (!v5)
        goto LABEL_7;
      v6 = 5;
      v1 = v5;
    }
    (*(void (**)(_QWORD *))(*v1 + 8 * v6))(v1);
  }
LABEL_7:
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;

  v3 = (_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(_QWORD *)(a1 + 24) = v4;
  }
  else
  {
    v3 = (_QWORD *)(a1 + 24);
  }
  *v3 = 0;
  return a1;
}

uint64_t ___ZN4swix6detail14watchdog_timerC2ENS_14timeout_configE_block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 48);
  if (!v1)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 48))(v1);
}

void std::__shared_ptr_emplace<swix::detail::watchdog_timer>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E98B8890;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<swix::detail::watchdog_timer>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E98B8890;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D826BA98);
}

void std::__shared_ptr_emplace<swix::detail::watchdog_timer>::__on_zero_shared(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;
  _QWORD *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;

  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 88));
  dispatch_sync(*(dispatch_queue_t *)(a1 + 80), &__block_literal_global);
  v2 = *(NSObject **)(a1 + 88);
  if (v2)
    dispatch_release(v2);
  v3 = *(NSObject **)(a1 + 80);
  if (v3)
    dispatch_release(v3);
  v4 = *(_QWORD **)(a1 + 72);
  if (v4 == (_QWORD *)(a1 + 48))
  {
    v5 = 4;
    v4 = (_QWORD *)(a1 + 48);
  }
  else
  {
    if (!v4)
      goto LABEL_10;
    v5 = 5;
  }
  (*(void (**)(void))(*v4 + 8 * v5))();
LABEL_10:
  v6 = *(std::__shared_weak_count **)(a1 + 32);
  if (v6)
    std::__shared_weak_count::__release_weak(v6);
}

swix::connection *swix::connection::connection(swix::connection *this, const swix::connection_config *a2)
{
  NSObject *v3;
  NSObject *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  const applesauce::xpc::connection *v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  uint64_t v11;
  _QWORD *v12;
  NSObject **v13;
  NSObject *global_queue;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  NSObject *shared_weak_owners;
  uint64_t v19;
  std::__shared_weak_count *shared_owners;
  unint64_t v21;
  unint64_t *p_shared_weak_owners;
  unint64_t v23;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t v27;
  __int128 v28;
  std::__shared_weak_count *v29;
  unint64_t v30;
  unint64_t *v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t *v34;
  unint64_t v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  _QWORD *v40;
  uint64_t v41;
  __int128 v43;
  __int128 v44;
  xpc_object_t v45;
  _QWORD handler[5];
  std::string v47;
  void *__p;
  char v49;
  xpc_object_t v50;
  dispatch_object_t object;
  uint64_t v52;
  _BYTE v53[24];
  _BYTE *v54;
  char v55;
  uint64_t v56;
  _BYTE v57[24];
  _BYTE *v58;
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)this = &off_1E98B8568;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  swix::connection_config::connection_config(&v47, a2);
  if (!object)
  {
    v3 = dispatch_queue_create("", 0);
    v4 = object;
    object = v3;
    if (v4)
      dispatch_release(v4);
  }
  swix::make_connection(&v45, (uint64_t)&v47);
  v5 = (std::__shared_weak_count *)operator new(0xD0uLL);
  *(_OWORD *)&v5->__shared_owners_ = 0u;
  p_shared_owners = (unint64_t *)&v5->__shared_owners_;
  v5->__vftable = (std::__shared_weak_count_vtbl *)&off_1E98B8858;
  v5[1].std::__shared_count = 0u;
  swix::connection_config::connection_config((std::string *)&v5[1].__shared_weak_owners_, (const swix::connection_config *)&v47);
  v5[7].__vftable = 0;
  v8 = swix::detail::connection_impl::create((swix::detail::connection_impl *)&v5[1].__shared_weak_owners_, &v45, v7);
  LODWORD(v5[7].__shared_owners_) = 0;
  v5[7].__shared_weak_owners_ = v8;
  if (!v55)
  {
    v5[8].__vftable = 0;
    v5[8].__shared_owners_ = 0;
    goto LABEL_34;
  }
  v9 = (std::__shared_weak_count *)operator new(0x60uLL);
  v9->__shared_owners_ = 0;
  v10 = (unint64_t *)&v9->__shared_owners_;
  v9->__shared_weak_owners_ = 0;
  v9->__vftable = (std::__shared_weak_count_vtbl *)&off_1E98B8890;
  v11 = (uint64_t)v54;
  v56 = v52;
  v12 = v57;
  if (!v54)
    goto LABEL_8;
  if (v54 != v53)
  {
    v11 = (*(uint64_t (**)(_BYTE *))(*(_QWORD *)v54 + 16))(v54);
LABEL_8:
    v58 = (_BYTE *)v11;
    goto LABEL_11;
  }
  v58 = v57;
  (*(void (**)(_BYTE *, _BYTE *))(*(_QWORD *)v54 + 24))(v54, v57);
LABEL_11:
  v9[1].__vftable = 0;
  v9[1].__shared_owners_ = 0;
  v9[1].__shared_weak_owners_ = v56;
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)&v9[2], (uint64_t)v57);
  v9[3].__shared_owners_ = 0;
  v9[3].__shared_weak_owners_ = 0;
  v13 = (NSObject **)&v9[3].__shared_owners_;
  if (!v9[3].__vftable)
    std::terminate();
  global_queue = dispatch_get_global_queue(25, 0);
  v15 = dispatch_queue_create_with_target_V2("", 0, global_queue);
  v16 = *v13;
  *v13 = v15;
  if (v16)
  {
    dispatch_release(v16);
    v15 = *v13;
  }
  v17 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, v15);
  shared_weak_owners = v9[3].__shared_weak_owners_;
  v9[3].__shared_weak_owners_ = (uint64_t)v17;
  if (shared_weak_owners)
  {
    dispatch_release(shared_weak_owners);
    v17 = v9[3].__shared_weak_owners_;
  }
  handler[0] = MEMORY[0x1E0C809B0];
  handler[1] = 0x40000000;
  handler[2] = ___ZN4swix6detail14watchdog_timerC2ENS_14timeout_configE_block_invoke;
  handler[3] = &__block_descriptor_tmp_157;
  handler[4] = v9 + 1;
  dispatch_source_set_event_handler(v17, handler);
  dispatch_resume((dispatch_object_t)v9[3].__shared_weak_owners_);
  if (v58 == v57)
  {
    v19 = 4;
  }
  else
  {
    if (!v58)
      goto LABEL_21;
    v19 = 5;
    v12 = v58;
  }
  (*(void (**)(_QWORD *))(*v12 + 8 * v19))(v12);
LABEL_21:
  v5[8].__vftable = (std::__shared_weak_count_vtbl *)&v9[1];
  v5[8].__shared_owners_ = (uint64_t)v9;
  shared_owners = (std::__shared_weak_count *)v9[1].__shared_owners_;
  if (shared_owners)
  {
    if (shared_owners->__shared_owners_ != -1)
      goto LABEL_34;
    do
      v21 = __ldxr(v10);
    while (__stxr(v21 + 1, v10));
    p_shared_weak_owners = (unint64_t *)&v9->__shared_weak_owners_;
    do
      v23 = __ldxr(p_shared_weak_owners);
    while (__stxr(v23 + 1, p_shared_weak_owners));
    v9[1].__vftable = (std::__shared_weak_count_vtbl *)&v9[1];
    v9[1].__shared_owners_ = (uint64_t)v9;
    std::__shared_weak_count::__release_weak(shared_owners);
  }
  else
  {
    do
      v24 = __ldxr(v10);
    while (__stxr(v24 + 1, v10));
    v25 = (unint64_t *)&v9->__shared_weak_owners_;
    do
      v26 = __ldxr(v25);
    while (__stxr(v26 + 1, v25));
    v9[1].__vftable = (std::__shared_weak_count_vtbl *)&v9[1];
    v9[1].__shared_owners_ = (uint64_t)v9;
  }
  do
    v27 = __ldaxr(v10);
  while (__stlxr(v27 - 1, v10));
  if (!v27)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
LABEL_34:
  *(_QWORD *)&v28 = v5 + 1;
  *((_QWORD *)&v28 + 1) = v5;
  v29 = (std::__shared_weak_count *)v5[1].__shared_owners_;
  if (v29)
  {
    if (v29->__shared_owners_ != -1)
      goto LABEL_47;
    do
      v30 = __ldxr(p_shared_owners);
    while (__stxr(v30 + 1, p_shared_owners));
    v43 = v28;
    v31 = (unint64_t *)&v5->__shared_weak_owners_;
    do
      v32 = __ldxr(v31);
    while (__stxr(v32 + 1, v31));
    v5[1].__vftable = (std::__shared_weak_count_vtbl *)&v5[1];
    v5[1].__shared_owners_ = (uint64_t)v5;
    std::__shared_weak_count::__release_weak(v29);
    v28 = v43;
  }
  else
  {
    do
      v33 = __ldxr(p_shared_owners);
    while (__stxr(v33 + 1, p_shared_owners));
    v34 = (unint64_t *)&v5->__shared_weak_owners_;
    do
      v35 = __ldxr(v34);
    while (__stxr(v35 + 1, v34));
    v5[1].__vftable = (std::__shared_weak_count_vtbl *)&v5[1];
    v5[1].__shared_owners_ = (uint64_t)v5;
  }
  do
    v36 = __ldaxr(p_shared_owners);
  while (__stlxr(v36 - 1, p_shared_owners));
  if (!v36)
  {
    v44 = v28;
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
    v28 = v44;
  }
LABEL_47:
  v37 = (std::__shared_weak_count *)*((_QWORD *)this + 2);
  *(_OWORD *)((char *)this + 8) = v28;
  if (v37)
  {
    v38 = (unint64_t *)&v37->__shared_owners_;
    do
      v39 = __ldaxr(v38);
    while (__stlxr(v39 - 1, v38));
    if (!v39)
    {
      ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
      std::__shared_weak_count::__release_weak(v37);
    }
  }
  xpc_release(v45);
  if (v55)
  {
    v40 = v54;
    if (v54 == v53)
    {
      v41 = 4;
      v40 = v53;
    }
    else
    {
      if (!v54)
        goto LABEL_58;
      v41 = 5;
    }
    (*(void (**)(void))(*v40 + 8 * v41))();
  }
LABEL_58:
  if (object)
    dispatch_release(object);
  xpc_release(v50);
  v50 = 0;
  if (v49 < 0)
    operator delete(__p);
  if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v47.__r_.__value_.__l.__data_);
  return this;
}

void sub_1D4E9BD50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  std::__shared_weak_count *v17;
  std::__shared_weak_count *v18;
  uint64_t v19;
  swix::connection_config *v20;
  void *v22;
  std::__shared_weak_count_vtbl *v23;
  std::__shared_weak_count *shared_owners;
  void *v25;

  std::__shared_weak_count::~__shared_weak_count(v18);
  operator delete(v22);
  v23 = v17[7].__vftable;
  if (v23)
    _Block_release(v23);
  swix::connection_config::~connection_config(v20);
  shared_owners = (std::__shared_weak_count *)v17[1].__shared_owners_;
  if (shared_owners)
    std::__shared_weak_count::__release_weak(shared_owners);
  std::__shared_weak_count::~__shared_weak_count(v17);
  operator delete(v25);
  xpc_release(object);
  swix::connection_config::~connection_config((swix::connection_config *)&a17);
  std::shared_ptr<swix::connection::state>::~shared_ptr[abi:ne180100](v19);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<swix::connection::state>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E98B8858;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<swix::connection::state>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E98B8858;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D826BA98);
}

void std::__shared_ptr_emplace<swix::connection::state>::__on_zero_shared(uint64_t a1)
{
  const void *v2;
  _QWORD *v3;
  uint64_t v4;
  NSObject *v5;
  std::__shared_weak_count *v6;

  swix::connection::state::cancel_connection(a1 + 24, 1);
  std::shared_ptr<swix::connection::state>::~shared_ptr[abi:ne180100](a1 + 192);
  v2 = *(const void **)(a1 + 168);
  if (v2)
    _Block_release(v2);
  if (*(_BYTE *)(a1 + 160))
  {
    v3 = *(_QWORD **)(a1 + 152);
    if (v3 == (_QWORD *)(a1 + 128))
    {
      v4 = 4;
      v3 = (_QWORD *)(a1 + 128);
    }
    else
    {
      if (!v3)
        goto LABEL_9;
      v4 = 5;
    }
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
LABEL_9:
  v5 = *(NSObject **)(a1 + 96);
  if (v5)
    dispatch_release(v5);
  xpc_release(*(xpc_object_t *)(a1 + 88));
  *(_QWORD *)(a1 + 88) = 0;
  if (*(char *)(a1 + 87) < 0)
    operator delete(*(void **)(a1 + 64));
  if (*(char *)(a1 + 63) < 0)
    operator delete(*(void **)(a1 + 40));
  v6 = *(std::__shared_weak_count **)(a1 + 32);
  if (v6)
    std::__shared_weak_count::__release_weak(v6);
}

void swix::connection::send_and_await_reply(swix::connection *this, const swix::encode_message *a2, int *a3)
{
  uint64_t v6;
  NSObject *v7;
  _BOOL4 v8;
  xpc_object_t v9;
  xpc_connection_t v10;
  char *v11;
  std::string *v12;
  xpc_object_t v13;
  uint64_t v14;
  NSObject *v15;
  xpc_connection_t v16;
  char *v17;
  std::string *v18;
  xpc_object_t v19;
  int v20;
  NSObject *v21;
  std::string *v22;
  std::string::size_type size;
  std::string *v24;
  __int128 v25;
  std::string *v26;
  __int128 v27;
  std::string *v28;
  std::string::size_type v29;
  std::string *v30;
  __int128 v31;
  std::string *v32;
  __int128 v33;
  xpc_object_t message;
  xpc_connection_t connection;
  std::string v36;
  std::string v37;
  std::string v38;
  std::string v39;
  std::string v40;
  std::string v41;
  std::string buf;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  swix::connection::xpc_connection((swix::connection *)&connection, (uint64_t)a2);
  swix::encode_message::xpc_message((swix::encode_message *)&message, (uint64_t)a3);
  v6 = *((_QWORD *)a2 + 1);
  if (*(_BYTE *)(v6 + 88))
  {
    v7 = *(NSObject **)(v6 + 80);
    v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    v9 = message;
    if (v8)
    {
      v10 = connection;
      v11 = (char *)MEMORY[0x1D826C4DC](message);
      std::string::basic_string[abi:ne180100]<0>(&v41, v11);
      free(v11);
      v12 = (v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &v41
          : (std::string *)v41.__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 134218242;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v10;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v12;
      _os_log_impl(&dword_1D4E88000, v7, OS_LOG_TYPE_DEFAULT, "%p send msg %s", (uint8_t *)&buf, 0x16u);
      if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v41.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    v9 = message;
  }
  v13 = xpc_connection_send_message_with_reply_sync(connection, v9);
  if (!v13)
    v13 = xpc_null_create();
  v14 = *((_QWORD *)a2 + 1);
  if (*(_BYTE *)(v14 + 88))
  {
    v15 = *(NSObject **)(v14 + 80);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v16 = connection;
      v17 = (char *)MEMORY[0x1D826C4DC](v13);
      std::string::basic_string[abi:ne180100]<0>(&v41, v17);
      free(v17);
      v18 = (v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &v41
          : (std::string *)v41.__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 134218242;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v16;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v18;
      _os_log_impl(&dword_1D4E88000, v15, OS_LOG_TYPE_DEFAULT, "%p msg reply %s", (uint8_t *)&buf, 0x16u);
      if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v41.__r_.__value_.__l.__data_);
    }
  }
  swix::connection::check_valid_reply((uint64_t)a2, (uint64_t)v13);
  if (v13 && MEMORY[0x1D826C5A8](v13) == MEMORY[0x1E0C812F8])
  {
    xpc_retain(v13);
    v19 = v13;
  }
  else
  {
    v19 = xpc_null_create();
  }
  swix::decode_message::decode_message((uint64_t)this, v19, *(_QWORD *)(*((_QWORD *)a2 + 1) + 80));
  xpc_release(v19);
  v20 = *a3;
  if (*(_DWORD *)this + *a3)
  {
    v21 = *((_QWORD *)this + 3);
    std::string::basic_string[abi:ne180100]<0>(&v38, "unexpected message ID (");
    std::to_string(&v37, -v20);
    if ((v37.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v22 = &v37;
    else
      v22 = (std::string *)v37.__r_.__value_.__r.__words[0];
    if ((v37.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(v37.__r_.__value_.__r.__words[2]);
    else
      size = v37.__r_.__value_.__l.__size_;
    v24 = std::string::append(&v38, (const std::string::value_type *)v22, size);
    v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
    v39.__r_.__value_.__r.__words[2] = v24->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v39.__r_.__value_.__l.__data_ = v25;
    v24->__r_.__value_.__l.__size_ = 0;
    v24->__r_.__value_.__r.__words[2] = 0;
    v24->__r_.__value_.__r.__words[0] = 0;
    v26 = std::string::append(&v39, "/", 1uLL);
    v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
    v40.__r_.__value_.__r.__words[2] = v26->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v40.__r_.__value_.__l.__data_ = v27;
    v26->__r_.__value_.__l.__size_ = 0;
    v26->__r_.__value_.__r.__words[2] = 0;
    v26->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v36, *(_DWORD *)this);
    if ((v36.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v28 = &v36;
    else
      v28 = (std::string *)v36.__r_.__value_.__r.__words[0];
    if ((v36.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v29 = HIBYTE(v36.__r_.__value_.__r.__words[2]);
    else
      v29 = v36.__r_.__value_.__l.__size_;
    v30 = std::string::append(&v40, (const std::string::value_type *)v28, v29);
    v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
    buf.__r_.__value_.__r.__words[2] = v30->__r_.__value_.__r.__words[2];
    *(_OWORD *)&buf.__r_.__value_.__l.__data_ = v31;
    v30->__r_.__value_.__l.__size_ = 0;
    v30->__r_.__value_.__r.__words[2] = 0;
    v30->__r_.__value_.__r.__words[0] = 0;
    v32 = std::string::append(&buf, ")", 1uLL);
    v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
    v41.__r_.__value_.__r.__words[2] = v32->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v41.__r_.__value_.__l.__data_ = v33;
    v32->__r_.__value_.__l.__size_ = 0;
    v32->__r_.__value_.__r.__words[2] = 0;
    v32->__r_.__value_.__r.__words[0] = 0;
    swix::decode_message::throw_error(v21, -301, &v41);
  }
  xpc_release(v13);
  xpc_release(message);
  xpc_release(connection);
}

void sub_1D4E9C2A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, xpc_object_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  xpc_object_t *v42;
  void *v43;
  uint64_t v44;

  if (*(char *)(v44 - 121) < 0)
    operator delete(*(void **)(v44 - 144));
  if (*(char *)(v44 - 89) < 0)
    operator delete(*(void **)(v44 - 112));
  if (a17 < 0)
    operator delete(__p);
  if (a42 < 0)
    operator delete(a37);
  if (a35 < 0)
    operator delete(a30);
  if (a23 < 0)
    operator delete(a18);
  if (a29 < 0)
    operator delete(a24);
  swix::decode_message::~decode_message(v42);
  xpc_release(v43);
  xpc_release(object);
  xpc_release(a11);
  _Unwind_Resume(a1);
}

void swix::connection::check_valid_reply(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  const char *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (a2 == MEMORY[0x1E0C81258])
  {
    v3 = *(NSObject **)(*(_QWORD *)(a1 + 8) + 80);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v5 = 134217984;
      v6 = a1;
      v4 = "%p reply: XPC_ERROR_CONNECTION_INTERRUPTED";
      goto LABEL_8;
    }
  }
  else if (a2 == MEMORY[0x1E0C81260])
  {
    v3 = *(NSObject **)(*(_QWORD *)(a1 + 8) + 80);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v5 = 134217984;
      v6 = a1;
      v4 = "%p reply: XPC_ERROR_CONNECTION_INVALID";
LABEL_8:
      _os_log_error_impl(&dword_1D4E88000, v3, OS_LOG_TYPE_ERROR, v4, (uint8_t *)&v5, 0xCu);
    }
  }
}

void swix::decode_message::~decode_message(xpc_object_t *this)
{
  xpc_release(this[1]);
  this[1] = 0;
}

void swix::decode_message::throw_error(NSObject *a1, int a2, std::string *a3)
{
  std::string *v6;
  std::runtime_error *exception;
  int v8;
  std::string *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (os_log_type_enabled(a1, OS_LOG_TYPE_ERROR))
  {
    if ((a3->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v6 = a3;
    else
      v6 = (std::string *)a3->__r_.__value_.__r.__words[0];
    v8 = 136315138;
    v9 = v6;
    _os_log_error_impl(&dword_1D4E88000, a1, OS_LOG_TYPE_ERROR, "throwing swix::exception: %s", (uint8_t *)&v8, 0xCu);
  }
  exception = (std::runtime_error *)__cxa_allocate_exception(0x18uLL);
  swix::exception::exception(exception, a2, a3);
}

void sub_1D4E9C5C8(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

std::runtime_error *swix::exception::exception(std::runtime_error *a1, int a2, std::string *a3)
{
  std::runtime_error *result;

  result = std::runtime_error::runtime_error(a1, a3);
  result->__vftable = (std::runtime_error_vtbl *)&off_1E98B8610;
  LODWORD(result[1].__vftable) = a2;
  return result;
}

uint64_t ___ZN4swix10connection21send_with_async_replyERKNS_14encode_messageEU13block_pointerFvPvE_block_invoke(uint64_t a1, xpc_object_t object)
{
  uint64_t v4;
  xpc_object_t v5;

  v4 = *(_QWORD *)(a1 + 40);
  if (object)
  {
    xpc_retain(object);
    v5 = object;
  }
  else
  {
    v5 = xpc_null_create();
  }
  swix::connection::check_valid_reply(v4, (uint64_t)v5);
  xpc_release(v5);
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void ___ZN4swix8listenerC2ERKNS_17connection_configE_block_invoke(uint64_t a1, xpc_object_t object)
{
  xpc_object_t v2;
  _QWORD *v3;
  xpc_object_t v4;
  NSObject *v5;
  xpc_object_t v6;
  char *v7;
  void **v8;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  void *__p[2];
  char v13;
  xpc_object_t objecta;
  uint8_t buf[4];
  xpc_object_t v16;
  __int16 v17;
  void **v18;
  uint64_t v19;

  v2 = object;
  v19 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD **)(a1 + 32);
  if (object)
  {
    xpc_retain(object);
    v4 = v2;
  }
  else
  {
    v4 = xpc_null_create();
  }
  v5 = *(NSObject **)(v3[1] + 80);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    swix::connection::xpc_connection((swix::connection *)&objecta, (uint64_t)v3);
    v6 = objecta;
    v7 = (char *)MEMORY[0x1D826C4DC](v4);
    std::string::basic_string[abi:ne180100]<0>(__p, v7);
    free(v7);
    if (v13 >= 0)
      v8 = __p;
    else
      v8 = (void **)__p[0];
    *(_DWORD *)buf = 134218242;
    v16 = v6;
    v17 = 2080;
    v18 = v8;
    _os_log_impl(&dword_1D4E88000, v5, OS_LOG_TYPE_DEFAULT, "%p connection event %s", buf, 0x16u);
    if (v13 < 0)
      operator delete(__p[0]);
    xpc_release(objecta);
  }
  v9 = MEMORY[0x1E0C812E0];
  if (v2)
  {
    xpc_retain(v2);
    __p[0] = v2;
  }
  else
  {
    v2 = xpc_null_create();
    __p[0] = v2;
    if (!v2)
    {
LABEL_15:
      __p[0] = xpc_null_create();
      goto LABEL_17;
    }
  }
  if (MEMORY[0x1D826C5A8](v2) != v9)
    goto LABEL_15;
  xpc_retain(v2);
LABEL_17:
  xpc_release(v2);
  if (MEMORY[0x1D826C5A8](__p[0]) == v9)
  {
    if (((*(uint64_t (**)(_QWORD *, void **))(*v3 + 24))(v3, __p) & 1) != 0)
    {
      xpc_connection_activate((xpc_connection_t)__p[0]);
    }
    else
    {
      v11 = *(NSObject **)(v3[1] + 80);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_1D4E88000, v11, OS_LOG_TYPE_ERROR, "rejecting connection", buf, 2u);
      }
      xpc_connection_cancel((xpc_connection_t)__p[0]);
    }
  }
  else
  {
    v10 = *(NSObject **)(v3[1] + 80);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D4E88000, v10, OS_LOG_TYPE_ERROR, "object not a connection?", buf, 2u);
    }
  }
  xpc_release(__p[0]);
  xpc_release(v4);
}

void sub_1D4E9C988(_Unwind_Exception *exception_object, int a2)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

void ___ZN4swix12ipc_endpointC2ERKNS_17connection_configERNS_13ipc_interfaceE_block_invoke(uint64_t a1, xpc_object_t object)
{
  uint64_t v2;
  xpc_object_t objecta;

  v2 = *(_QWORD *)(a1 + 32);
  objecta = object;
  if (object)
    xpc_retain(object);
  else
    objecta = xpc_null_create();
  swix::ipc_endpoint::handle_event_or_error(v2, &objecta);
  xpc_release(objecta);
}

_QWORD *swix::ipc_interface::ipc_interface(_QWORD *a1, const swix::connection_config *a2)
{
  uint64_t *v4;
  uint64_t v5;
  _QWORD v7[5];
  xpc_object_t object;

  *a1 = off_1E98B85B8;
  a1[1] = 0;
  if (*((_BYTE *)a2 + 128))
  {
    v4 = (uint64_t *)operator new();
    swix::connection::connection((swix::connection *)v4, a2);
    *v4 = (uint64_t)&off_1E98B8590;
    v4[6] = 0;
    v4[7] = (uint64_t)a1;
    swix::connection::xpc_connection((swix::connection *)&object, (uint64_t)v4);
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 0x40000000;
    v7[2] = ___ZN4swix12ipc_endpointC2ERKNS_17connection_configERNS_13ipc_interfaceE_block_invoke;
    v7[3] = &__block_descriptor_tmp_9;
    v7[4] = v4;
    swix::connection::state::set_handler(v4[1], (_xpc_connection_s *)object, v7);
    xpc_release(object);
    v5 = a1[1];
    a1[1] = v4;
    if (v5)
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  }
  return a1;
}

void sub_1D4E9CAF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, xpc_object_t object)
{
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;

  xpc_release(object);
  v17 = (_QWORD *)v15[6];
  if (v17 == v15 + 3)
  {
    v18 = 4;
    v17 = v15 + 3;
  }
  else
  {
    if (!v17)
      goto LABEL_6;
    v18 = 5;
  }
  (*(void (**)(void))(*v17 + 8 * v18))();
LABEL_6:
  *v15 = &off_1E98B8568;
  std::shared_ptr<swix::connection::state>::~shared_ptr[abi:ne180100]((uint64_t)(v15 + 1));
  MEMORY[0x1D826BA98](v15, 0x10A1C404C29359ELL);
  v19 = *(_QWORD *)(v14 + 8);
  *(_QWORD *)(v14 + 8) = 0;
  if (v19)
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
  _Unwind_Resume(a1);
}

void AsyncMessenger::addCallback(uint64_t a1, unsigned __int8 a2, _QWORD *a3)
{
  std::mutex *v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD v13[3];
  _QWORD *v14;
  _QWORD v15[4];

  v15[3] = *MEMORY[0x1E0C80C00];
  v6 = (std::mutex *)(a1 + 24);
  std::mutex::lock((std::mutex *)(a1 + 24));
  v7 = a3[3];
  if (!v7)
    goto LABEL_4;
  if ((_QWORD *)v7 != a3)
  {
    v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 16))(v7);
LABEL_4:
    v14 = (_QWORD *)v7;
    goto LABEL_6;
  }
  v14 = v13;
  (*(void (**)(_QWORD *, _QWORD *))(*a3 + 24))(a3, v13);
LABEL_6:
  v8 = (_QWORD *)(a1 + 32 * a2 + 176);
  if (v8 != v13)
  {
    v9 = v14;
    v10 = (_QWORD *)v8[3];
    if (v14 == v13)
    {
      if (v10 == v8)
      {
        (*(void (**)(_QWORD *, _QWORD *))(v13[0] + 24))(v13, v15);
        (*(void (**)(_QWORD *))(*v14 + 32))(v14);
        v14 = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)v8[3] + 24))(v8[3], v13);
        (*(void (**)(_QWORD))(*(_QWORD *)v8[3] + 32))(v8[3]);
        v8[3] = 0;
        v14 = v13;
        (*(void (**)(_QWORD *, _QWORD *))(v15[0] + 24))(v15, v8);
        (*(void (**)(_QWORD *))(v15[0] + 32))(v15);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(v13[0] + 24))(v13, v8);
        (*(void (**)(_QWORD *))(*v14 + 32))(v14);
        v14 = (_QWORD *)v8[3];
      }
      v8[3] = v8;
    }
    else if (v10 == v8)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*v8 + 24))(v8, v13);
      (*(void (**)(_QWORD))(*(_QWORD *)v8[3] + 32))(v8[3]);
      v8[3] = v14;
      v14 = v13;
    }
    else
    {
      v14 = (_QWORD *)v8[3];
      v8[3] = v9;
    }
  }
  v11 = v14;
  if (v14 == v13)
  {
    v12 = 4;
    v11 = v13;
    goto LABEL_19;
  }
  if (v14)
  {
    v12 = 5;
LABEL_19:
    (*(void (**)(void))(*v11 + 8 * v12))();
  }
  std::mutex::unlock(v6);
}

void sub_1D4E9CD9C(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void std::vector<std::unique_ptr<UMPStream::EndpointPair>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  _QWORD *v2;
  _QWORD *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v7 = *--v4;
        v6 = v7;
        *v4 = 0;
        if (v7)
          std::default_delete<UMPStream::EndpointPair>::operator()[abi:ne180100](v6);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::default_delete<UMPStream::EndpointPair>::operator()[abi:ne180100](uint64_t a1)
{
  void **v2;

  v2 = (void **)(a1 + 152);
  std::vector<std::unique_ptr<UMPStream::FunctionBlock>>::__destroy_vector::operator()[abi:ne180100](&v2);
  if (*(char *)(a1 + 143) < 0)
    operator delete(*(void **)(a1 + 120));
  if (*(char *)(a1 + 95) < 0)
    operator delete(*(void **)(a1 + 72));
  *(_QWORD *)a1 = off_1E98B9320;
  XCFObject<__CFDictionary const*>::~XCFObject(a1 + 24);
  BaseOpaqueObject::~BaseOpaqueObject((BaseOpaqueObject *)a1);
  JUMPOUT(0x1D826BA98);
}

void std::vector<std::unique_ptr<UMPStream::FunctionBlock>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  _QWORD *v2;
  _QWORD *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v7 = *--v4;
        v6 = v7;
        *v4 = 0;
        if (v7)
          std::default_delete<UMPStream::FunctionBlock>::operator()[abi:ne180100](v6);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::default_delete<UMPStream::FunctionBlock>::operator()[abi:ne180100](uint64_t a1)
{
  if (*(char *)(a1 + 95) < 0)
    operator delete(*(void **)(a1 + 72));
  *(_QWORD *)a1 = off_1E98B9320;
  XCFObject<__CFDictionary const*>::~XCFObject(a1 + 24);
  BaseOpaqueObject::~BaseOpaqueObject((BaseOpaqueObject *)a1);
  JUMPOUT(0x1D826BA98);
}

void std::__function::__func<UMPStream::EndpointManager::EndpointManager(UMPCIServerContext &)::$_1,std::allocator<UMPStream::EndpointManager::EndpointManager(UMPCIServerContext &)::$_1>,std::optional<unsigned char> ()(unsigned int,unsigned int,unsigned char)>::~__func()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *std::__function::__func<UMPStream::EndpointManager::EndpointManager(UMPCIServerContext &)::$_1,std::allocator<UMPStream::EndpointManager::EndpointManager(UMPCIServerContext &)::$_1>,std::optional<unsigned char> ()(unsigned int,unsigned int,unsigned char)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E98B74A0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<UMPStream::EndpointManager::EndpointManager(UMPCIServerContext &)::$_1,std::allocator<UMPStream::EndpointManager::EndpointManager(UMPCIServerContext &)::$_1>,std::optional<unsigned char> ()(unsigned int,unsigned int,unsigned char)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E98B74A0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<UMPStream::EndpointManager::EndpointManager(UMPCIServerContext &)::$_1,std::allocator<UMPStream::EndpointManager::EndpointManager(UMPCIServerContext &)::$_1>,std::optional<unsigned char> ()(unsigned int,unsigned int,unsigned char)>::operator()(uint64_t a1, int *a2, int *a3, unsigned __int8 *a4)
{
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t Pair;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  int v12;
  int v13;

  v4 = *a2;
  v5 = *a3;
  v6 = *a4;
  v7 = *(_QWORD *)(a1 + 8);
  std::mutex::lock((std::mutex *)(v7 + 32));
  Pair = UMPCIManager<UMPStream::EndpointPair>::getPair(v7, v4, v5);
  if (Pair)
  {
    v9 = *(uint64_t **)(Pair + 152);
    v10 = *(uint64_t **)(Pair + 160);
    while (v9 != v10)
    {
      if (*(unsigned __int8 *)(*v9 + 96) == v6)
      {
        if (v9 == v10)
          break;
        v11 = *v9;
        std::mutex::unlock((std::mutex *)(v7 + 32));
        if (v11)
        {
          v12 = *(unsigned __int8 *)(v11 + 104);
          v13 = 1;
          return v12 | (v13 << 8);
        }
        goto LABEL_10;
      }
      ++v9;
    }
  }
  std::mutex::unlock((std::mutex *)(v7 + 32));
LABEL_10:
  v12 = 0;
  v13 = 0;
  return v12 | (v13 << 8);
}

uint64_t UMPCIManager<UMPStream::EndpointPair>::getPair(uint64_t a1, int a2, int a3)
{
  uint64_t *v3;
  uint64_t *v4;
  uint64_t v5;

  if (a3 | a2)
  {
    v3 = *(uint64_t **)(a1 + 8);
    v4 = *(uint64_t **)(a1 + 16);
    while (v3 != v4)
    {
      v5 = *v3;
      if (!a3 && *(_DWORD *)(v5 + 100) == a2
        || !a2 && *(_DWORD *)(v5 + 104) == a3
        || *(_DWORD *)(v5 + 100) == a2 && *(_DWORD *)(v5 + 104) == a3)
      {
        if (v3 == v4)
          return 0;
        return *v3;
      }
      ++v3;
    }
  }
  return 0;
}

void std::__function::__func<UMPStream::EndpointManager::EndpointManager(UMPCIServerContext &)::$_0,std::allocator<UMPStream::EndpointManager::EndpointManager(UMPCIServerContext &)::$_0>,void ()(unsigned int,MIDIEventList const*)>::~__func()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *std::__function::__func<UMPStream::EndpointManager::EndpointManager(UMPCIServerContext &)::$_0,std::allocator<UMPStream::EndpointManager::EndpointManager(UMPCIServerContext &)::$_0>,void ()(unsigned int,MIDIEventList const*)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E98B7458;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<UMPStream::EndpointManager::EndpointManager(UMPCIServerContext &)::$_0,std::allocator<UMPStream::EndpointManager::EndpointManager(UMPCIServerContext &)::$_0>,void ()(unsigned int,MIDIEventList const*)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E98B7458;
  a2[1] = v2;
  return result;
}

void std::__function::__func<UMPStream::EndpointManager::EndpointManager(UMPCIServerContext &)::$_0,std::allocator<UMPStream::EndpointManager::EndpointManager(UMPCIServerContext &)::$_0>,void ()(unsigned int,MIDIEventList const*)>::operator()(uint64_t a1, int *a2, uint64_t *a3)
{
  int v3;
  uint64_t v4;
  BOOL v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  MIDIProtocolID v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  UMPStream::EndpointManager *v18;
  uint64_t Pair;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  NSObject *v23;
  os_log_type_t v24;
  const char *v25;
  uint64_t v26;
  uint32_t v27;
  uint64_t v28;
  int v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  int v33;
  char v34;
  int v35;
  int v36;
  unsigned int v37;
  uint64_t v38;
  uint64_t v39;
  unsigned int v40;
  int v41;
  unsigned int v42;
  uint64_t *v43;
  uint64_t *v44;
  uint64_t *v45;
  uint64_t *v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t *v51;
  uint64_t *v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  unint64_t v57;
  unsigned int v58;
  int v59;
  std::string *v60;
  unint64_t v61;
  uint64_t *v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v67;
  std::string *v68;
  NSObject *v69;
  std::string *p_buf;
  std::string::size_type size;
  uint64_t *v72;
  unint64_t v73;
  uint64_t v74;
  uint64_t v75;
  int v76;
  unsigned int v77;
  std::mutex *v78;
  UMPStream::EndpointManager *v79;
  unsigned int v80;
  MIDIProtocolID v81;
  uint64_t v82;
  int v83;
  std::string buf;
  MIDIProtocolID *v85;
  uint64_t *v86;
  UMPStream::EndpointManager *v87;
  unsigned int *v88;
  UMPStream::EndpointManager *v89;
  unsigned int *v90;
  __int128 __s;
  uint64_t v92;

  v92 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  v4 = *a3;
  v78 = (std::mutex *)(*(_QWORD *)(a1 + 8) + 32);
  v79 = *(UMPStream::EndpointManager **)(a1 + 8);
  std::mutex::lock(v78);
  if (v3)
    v5 = v4 == 0;
  else
    v5 = 1;
  if (!v5)
  {
    v6 = *(_DWORD *)(v4 + 4);
    if (v6)
    {
      v7 = *(_QWORD *)(v4 + 8);
      v8 = (unsigned int *)(v4 + 20);
      v9 = v4 + 20 + 4 * *(unsigned int *)(v4 + 16);
    }
    else
    {
      v7 = 0;
      v8 = 0;
      v9 = 0;
    }
    while (1)
    {
      if (v8 == (unsigned int *)v9)
      {
        if (v6 < 2)
          break;
        --v6;
        v7 = *(_QWORD *)v8;
        v10 = v8[2];
        v8 += 3;
        v9 = (uint64_t)&v8[v10];
      }
      if (v8 == (unsigned int *)v9)
        break;
      v83 = v3;
      v82 = v7;
      v11 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIEndpoint>::sRTTI, v3);
      v12 = v11;
      if (!v11)
      {
        gMIDIUMPEndpointLog();
        v28 = gMIDIUMPEndpointLog(void)::logCat;
        if (!os_log_type_enabled((os_log_t)gMIDIUMPEndpointLog(void)::logCat, OS_LOG_TYPE_INFO))
          goto LABEL_31;
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"EndpointManager.cpp";
        WORD2(buf.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = 284;
        v23 = v28;
        v24 = OS_LOG_TYPE_INFO;
        v25 = "%25s:%-5d NOTICE: Failed to dereference source";
LABEL_29:
        v27 = 18;
        goto LABEL_30;
      }
      v13 = *(_DWORD *)(v11 + 44);
      v81 = v13;
      v14 = *(_QWORD **)(v11 + 64);
      if (!v14 || v14[10] == v14[9] || (v16 = v14 + 13, v15 = v14[13], v16[1] == v15))
      {
        v80 = 0;
LABEL_25:
        gMIDIUMPEndpointLog();
        v26 = gMIDIUMPEndpointLog(void)::logCat;
        if (!os_log_type_enabled((os_log_t)gMIDIUMPEndpointLog(void)::logCat, OS_LOG_TYPE_ERROR))
          goto LABEL_31;
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"EndpointManager.cpp";
        WORD2(buf.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = 291;
        WORD1(buf.__r_.__value_.__r.__words[2]) = 1024;
        HIDWORD(buf.__r_.__value_.__r.__words[2]) = v3;
        v23 = v26;
        v24 = OS_LOG_TYPE_ERROR;
        v25 = "%25s:%-5d Unable to find paired destination for source %u";
        v27 = 24;
LABEL_30:
        _os_log_impl(&dword_1D4E88000, v23, v24, v25, (uint8_t *)&buf, v27);
        goto LABEL_31;
      }
      v17 = *(unsigned int *)(*(_QWORD *)v15 + 8);
      v80 = v17;
      if (!(_DWORD)v17)
        goto LABEL_25;
      v18 = v79;
      Pair = UMPCIManager<UMPStream::EndpointPair>::getPair((uint64_t)v79, v3, 0);
      if (Pair)
      {
        v20 = Pair;
        *(_QWORD *)(Pair + 56) = v7;
        v21 = *v8;
        if (*v8 >> 28 == 15)
        {
          switch(HIWORD(v21) & 0x3FF)
          {
            case 0:
              gMIDIUMPEndpointLog();
              v22 = gMIDIUMPEndpointLog(void)::logCat;
              if (os_log_type_enabled((os_log_t)gMIDIUMPEndpointLog(void)::logCat, OS_LOG_TYPE_INFO))
              {
                LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
                *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"EndpointManager.cpp";
                WORD2(buf.__r_.__value_.__r.__words[1]) = 1024;
                *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = 333;
                v23 = v22;
                v24 = OS_LOG_TYPE_INFO;
                v25 = "%25s:%-5d NOTICE: Unexpected discovery message request..";
                goto LABEL_29;
              }
              break;
            case 2:
              v35 = HIBYTE(v8[2]) & 0x7F | ((HIWORD(v8[2]) & 0x7F) << 7);
              v36 = (v8[2] >> 8) & 0x7F | ((v8[2] & 0x7F) << 7);
              v37 = v8[3];
              v77 = v77 & 0xFF000000 | v8[1] & 0xFF00 | (v8[1] << 16) & 0xFFFFFF | BYTE2(v8[1]);
              *(_DWORD *)(Pair + 108) = v77;
              *(_WORD *)(Pair + 112) = v35;
              *(_WORD *)(Pair + 114) = v36;
              *(_DWORD *)(Pair + 116) = (v37 << 8) & 0x7F0000 | ((v37 & 0x7F) << 24) | (v37 >> 8) & 0x7F00 | HIBYTE(v37) & 0x7F;
              break;
            case 3:
              v30 = *(unsigned __int8 *)(Pair + 95);
              if ((v30 & 0x80u) != 0)
                v30 = *(_QWORD *)(Pair + 80);
              if (v30 < 0x62 || (v21 & 0x8000000) == 0)
              {
                v31 = v8[2];
                v32 = bswap64(v8[3]);
                *(_QWORD *)&__s = (v31 << 24) & 0xFF000000000000 | ((unint64_t)BYTE2(v31) << 56) | ((unint64_t)v8[1] << 40) | ((unint64_t)BYTE1(v8[1]) << 32) | ((unint64_t)BYTE2(v8[1]) << 24) | ((unint64_t)v8[1] >> 8) & 0xFF0000 | ((unint64_t)v21 << 8) | BYTE1(v21);
                WORD6(__s) = HIWORD(v32);
                DWORD2(__s) = (v32 >> 16) & 0xFFFF0000 | (bswap32(v31) >> 16);
                if (HIBYTE(v32))
                {
                  *((_BYTE *)&buf.__r_.__value_.__s + 23) = 14;
                  buf.__r_.__value_.__r.__words[0] = __s;
                  *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 6) = *(_QWORD *)((char *)&__s + 6);
                  buf.__r_.__value_.__s.__data_[14] = 0;
                }
                else
                {
                  std::string::basic_string[abi:ne180100]<0>(&buf, (char *)&__s);
                }
                v68 = (std::string *)(v20 + 72);
                if (((*v8 >> 26) & 3) >= 2)
                {
                  if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                    p_buf = &buf;
                  else
                    p_buf = (std::string *)buf.__r_.__value_.__r.__words[0];
                  if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                    size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
                  else
                    size = buf.__r_.__value_.__l.__size_;
                  goto LABEL_118;
                }
                goto LABEL_133;
              }
              break;
            case 4:
              v47 = *(unsigned __int8 *)(Pair + 143);
              if ((v47 & 0x80u) != 0)
                v47 = *(_QWORD *)(Pair + 128);
              if (v47 < 0x62 || (v21 & 0x8000000) == 0)
              {
                v48 = v8[2];
                v49 = bswap64(v8[3]);
                *(_QWORD *)&__s = (v48 << 24) & 0xFF000000000000 | ((unint64_t)BYTE2(v48) << 56) | ((unint64_t)v8[1] << 40) | ((unint64_t)BYTE1(v8[1]) << 32) | ((unint64_t)BYTE2(v8[1]) << 24) | ((unint64_t)v8[1] >> 8) & 0xFF0000 | ((unint64_t)v21 << 8) | BYTE1(v21);
                WORD6(__s) = HIWORD(v49);
                DWORD2(__s) = (v49 >> 16) & 0xFFFF0000 | (bswap32(v48) >> 16);
                if (HIBYTE(v49))
                {
                  *((_BYTE *)&buf.__r_.__value_.__s + 23) = 14;
                  buf.__r_.__value_.__r.__words[0] = __s;
                  *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 6) = *(_QWORD *)((char *)&__s + 6);
                  buf.__r_.__value_.__s.__data_[14] = 0;
                }
                else
                {
                  std::string::basic_string[abi:ne180100]<0>(&buf, (char *)&__s);
                }
                v68 = (std::string *)(v20 + 120);
                if (((*v8 >> 26) & 3) >= 2)
                {
                  if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                    p_buf = &buf;
                  else
                    p_buf = (std::string *)buf.__r_.__value_.__r.__words[0];
                  if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                    size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
                  else
                    size = buf.__r_.__value_.__l.__size_;
                  goto LABEL_118;
                }
                goto LABEL_133;
              }
              break;
            case 5:
              gMIDIUMPEndpointLog();
              v50 = gMIDIUMPEndpointLog(void)::logCat;
              if (os_log_type_enabled((os_log_t)gMIDIUMPEndpointLog(void)::logCat, OS_LOG_TYPE_INFO))
              {
                LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
                *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"EndpointManager.cpp";
                WORD2(buf.__r_.__value_.__r.__words[1]) = 1024;
                *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = 353;
                v23 = v50;
                v24 = OS_LOG_TYPE_INFO;
                v25 = "%25s:%-5d NOTICE: Unexpectedly received stream configuration request message...";
                goto LABEL_29;
              }
              break;
            case 6:
              v33 = *(_DWORD *)(Pair + 64);
              if ((v21 & 3) != 0 || BYTE1(v21) != v13)
              {
                if (v33 == 2)
                {
                  *(_DWORD *)(Pair + 64) = 3;
                  gMIDIUMPEndpointLog();
                  v53 = gMIDIUMPEndpointLog(void)::logCat;
                  if (os_log_type_enabled((os_log_t)gMIDIUMPEndpointLog(void)::logCat, OS_LOG_TYPE_INFO))
                  {
                    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
                    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"EndpointManager.cpp";
                    WORD2(buf.__r_.__value_.__r.__words[1]) = 1024;
                    *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = 379;
                    v23 = v53;
                    v24 = OS_LOG_TYPE_INFO;
                    v25 = "%25s:%-5d NOTICE: Device configuration mismatch, we have already sent a request. Will not try again..";
                    goto LABEL_29;
                  }
                }
                else
                {
                  gMIDIUMPEndpointLog();
                  v69 = gMIDIUMPEndpointLog(void)::logCat;
                  if (os_log_type_enabled((os_log_t)gMIDIUMPEndpointLog(void)::logCat, OS_LOG_TYPE_INFO))
                  {
                    LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
                    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"EndpointManager.cpp";
                    WORD2(buf.__r_.__value_.__r.__words[1]) = 1024;
                    *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = 370;
                    _os_log_impl(&dword_1D4E88000, v69, OS_LOG_TYPE_INFO, "%25s:%-5d NOTICE: Received stream configuration notification, but it does not match the current configuration.", (uint8_t *)&buf, 0x12u);
                  }
                  UMPStream::EndpointManager::sendStreamConfigurationRequestMessage(v79, v80, v81);
                  *(_DWORD *)(v20 + 64) = 2;
                }
              }
              else if (v33 != 4
                     && *(unsigned __int8 *)(Pair + 176) == (uint64_t)(*(_QWORD *)(Pair + 160) - *(_QWORD *)(Pair + 152)) >> 3)
              {
                *(_DWORD *)(Pair + 64) = 4;
                if (*(_BYTE *)(v12 + 88))
                  v34 = 1;
                else
                  v34 = *(_BYTE *)(v12 + 90) ? 3 : 2 * (*(_QWORD *)(v12 + 56) != 0);
                *(_BYTE *)(Pair + 177) = v34;
                *(_BYTE *)(Pair + 147) = 1;
                v75 = *(_QWORD *)v79;
                v76 = *(_DWORD *)(v20 + 8);
                buf.__r_.__value_.__r.__words[0] = 0;
                UMPCIServerContext::sendNotificationForObject(v75, 0, v76, (const void **)&buf.__r_.__value_.__l.__data_);
                if (buf.__r_.__value_.__r.__words[0])
                  CFRelease(buf.__r_.__value_.__l.__data_);
              }
              break;
            case 0x10:
              gMIDIUMPEndpointLog();
              v38 = gMIDIUMPEndpointLog(void)::logCat;
              if (os_log_type_enabled((os_log_t)gMIDIUMPEndpointLog(void)::logCat, OS_LOG_TYPE_INFO))
              {
                LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
                *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)"EndpointManager.cpp";
                WORD2(buf.__r_.__value_.__r.__words[1]) = 1024;
                *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = 386;
                v23 = v38;
                v24 = OS_LOG_TYPE_INFO;
                v25 = "%25s:%-5d NOTICE: Unexpectedly received function block discovery message...";
                goto LABEL_29;
              }
              break;
            case 0x11:
              v39 = operator new();
              MIDIObject::MIDIObject((MIDIObject *)v39);
              *(_BYTE *)(v39 + 44) = 0;
              *(_BYTE *)(v39 + 48) = 0;
              *(_QWORD *)v39 = off_1E98B7080;
              *(_BYTE *)(v39 + 64) = (*v8 & 0x8000) != 0;
              *(_QWORD *)(v39 + 80) = 0;
              *(_QWORD *)(v39 + 88) = 0;
              *(_QWORD *)(v39 + 72) = 0;
              v40 = *v8;
              v41 = (*v8 >> 8) & 0x7F;
              *(_BYTE *)(v39 + 96) = BYTE1(*v8) & 0x7F;
              *(_DWORD *)(v39 + 100) = v40 & 3;
              v42 = v8[1];
              *(_BYTE *)(v39 + 104) = HIBYTE(v42);
              *(_BYTE *)(v39 + 105) = BYTE2(v42);
              *(_BYTE *)(v39 + 106) = v42;
              *(int8x8_t *)(v39 + 108) = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v40), (uint32x2_t)0xFFFFFFFCFFFFFFFELL), (int8x8_t)0x300000003);
              *(_QWORD *)(v39 + 56) = v7;
              *(_DWORD *)(v39 + 116) = *(_DWORD *)(v20 + 8);
              v43 = *(uint64_t **)(v20 + 152);
              v44 = *(uint64_t **)(v20 + 160);
              v45 = v43;
              v46 = v43;
              if (v43 == v44)
                goto LABEL_87;
              while (*(unsigned __int8 *)(*v45 + 96) != v41)
              {
                if (++v45 == v44)
                {
                  v46 = *(uint64_t **)(v20 + 160);
                  goto LABEL_87;
                }
              }
              v46 = *(uint64_t **)(v20 + 160);
              if (v45 == v44)
              {
LABEL_87:
                v61 = *(_QWORD *)(v20 + 168);
                if ((unint64_t)v46 >= v61)
                {
                  v63 = v46 - v43;
                  v64 = v63 + 1;
                  if ((unint64_t)(v63 + 1) >> 61)
                    std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
                  v65 = v61 - (_QWORD)v43;
                  if (v65 >> 2 > v64)
                    v64 = v65 >> 2;
                  if ((unint64_t)v65 >= 0x7FFFFFFFFFFFFFF8)
                    v66 = 0x1FFFFFFFFFFFFFFFLL;
                  else
                    v66 = v64;
                  v86 = (uint64_t *)(v20 + 168);
                  if (v66)
                    v66 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v66);
                  else
                    v67 = 0;
                  v72 = (uint64_t *)(v66 + 8 * v63);
                  buf.__r_.__value_.__r.__words[0] = v66;
                  buf.__r_.__value_.__l.__size_ = (std::string::size_type)v72;
                  v85 = (MIDIProtocolID *)(v66 + 8 * v67);
                  *v72 = v39;
                  buf.__r_.__value_.__r.__words[2] = (std::string::size_type)(v72 + 1);
                  std::vector<std::unique_ptr<UMPStream::FunctionBlock>>::__swap_out_circular_buffer((_QWORD *)(v20 + 152), &buf);
                  v62 = *(uint64_t **)(v20 + 160);
                  std::__split_buffer<std::unique_ptr<UMPStream::FunctionBlock>>::~__split_buffer((uint64_t)&buf);
                  v43 = *(uint64_t **)(v20 + 152);
                }
                else
                {
                  *v46 = v39;
                  v62 = v46 + 1;
                  *(_QWORD *)(v20 + 160) = v62;
                }
                v73 = 126 - 2 * __clz(v62 - v43);
                *(_QWORD *)(v20 + 160) = v62;
                if (v62 == v43)
                  v74 = 0;
                else
                  v74 = v73;
                std::__introsort<std::_RangeAlgPolicy,UMPStream::EndpointPair::addFunctionBlock(std::unique_ptr<UMPStream::FunctionBlock>)::$_1 &,std::unique_ptr<UMPStream::FunctionBlock>*,false>(v43, v62, v74, 1);
              }
              else
              {
                v60 = (std::string *)*v45;
                UMPStream::FunctionBlock::serialize((UMPStream::FunctionBlock *)v39, (CFDictionaryRef *)&buf);
                UMPStream::FunctionBlock::deserialize(v60, (const __CFDictionary **)&buf, (uint64_t)&__s);
                std::__tree<std::string>::destroy(*((char **)&__s + 1));
                if (buf.__r_.__value_.__r.__words[0])
                  CFRelease(buf.__r_.__value_.__l.__data_);
                std::default_delete<UMPStream::FunctionBlock>::operator()[abi:ne180100](v39);
              }
              if (*(unsigned __int8 *)(v20 + 176) == (uint64_t)(*(_QWORD *)(v20 + 160) - *(_QWORD *)(v20 + 152)) >> 3)
                UMPStream::EndpointManager::sendStreamConfigurationRequestMessage(v79, v17, v13);
              break;
            case 0x12:
              v51 = *(uint64_t **)(Pair + 152);
              v52 = *(uint64_t **)(Pair + 160);
              while (v51 != v52)
              {
                if (*(unsigned __int8 *)(*v51 + 96) == BYTE1(v21))
                {
                  if (v51 != v52)
                  {
                    v54 = *v51;
                    if (*v51)
                    {
                      v55 = *(unsigned __int8 *)(v54 + 95);
                      if ((v55 & 0x80u) != 0)
                        v55 = *(_QWORD *)(v54 + 80);
                      if (v55 < 0x62 || (v21 & 0x8000000) == 0)
                      {
                        v57 = v8[1];
                        v58 = v8[3];
                        v59 = v8[2] | (HIBYTE(v58) << 8);
                        *(_QWORD *)&__s = ((unint64_t)v8[2] << 48) & 0xFF00000000000000 | ((unint64_t)BYTE2(v8[2]) << 48) | ((unint64_t)HIBYTE(v8[2]) << 40) | ((unint64_t)v8[1] << 32) | ((unint64_t)BYTE1(v57) << 24) | v57 & 0xFF0000 | (v57 >> 16) & 0xFF00 | *v8;
                        BYTE12(__s) = v58;
                        DWORD2(__s) = v58 & 0xFF0000 | v59 & 0xFFFFFF | (BYTE1(v58) << 24);
                        if ((_BYTE)v58)
                        {
                          *((_BYTE *)&buf.__r_.__value_.__s + 23) = 13;
                          buf.__r_.__value_.__r.__words[0] = __s;
                          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 5) = *(_QWORD *)((char *)&__s + 5);
                          buf.__r_.__value_.__s.__data_[13] = 0;
                        }
                        else
                        {
                          std::string::basic_string[abi:ne180100]<0>(&buf, (char *)&__s);
                        }
                        v68 = (std::string *)(v54 + 72);
                        if (((*v8 >> 26) & 3) >= 2)
                        {
                          if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                            p_buf = &buf;
                          else
                            p_buf = (std::string *)buf.__r_.__value_.__r.__words[0];
                          if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                            size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
                          else
                            size = buf.__r_.__value_.__l.__size_;
LABEL_118:
                          std::string::append(v68, (const std::string::value_type *)p_buf, size);
                        }
                        else
                        {
LABEL_133:
                          std::string::operator=(v68, &buf);
                        }
                        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
                          operator delete(buf.__r_.__value_.__l.__data_);
                      }
                    }
                  }
                  goto LABEL_31;
                }
                ++v51;
              }
              break;
            default:
              break;
          }
        }
      }
      else
      {
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v79;
        buf.__r_.__value_.__l.__size_ = (std::string::size_type)&v83;
        buf.__r_.__value_.__r.__words[2] = (std::string::size_type)&v80;
        v85 = &v81;
        v86 = &v82;
        v87 = v79;
        v88 = &v80;
        v89 = v79;
        v90 = &v80;
        if (*v8 >> 28 != 15)
          goto LABEL_36;
        v29 = HIWORD(*v8) & 0x3FF;
        if (v29 != 1)
        {
          v18 = v79;
          if (!v29)
          {
            UMPStream::EndpointManager::sendEndpointInfoNotificationMessage(v79, v17);
            goto LABEL_31;
          }
LABEL_36:
          UMPStream::EndpointManager::sendEndpointDiscoveryMessage(v18, v17);
          goto LABEL_31;
        }
        UMPStream::EndpointManager::processBackground(unsigned int,MIDI::MIDIEvent const&)::$_0::operator()((uint64_t)&buf, (uint64_t)v8);
      }
LABEL_31:
      v8 += MIDI::UniversalPacket::word_sizes[(unint64_t)*v8 >> 28];
    }
  }
  std::mutex::unlock(v78);
}

void sub_1D4E9DD24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::mutex *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0)
    operator delete(__p);
  std::mutex::unlock(a11);
  _Unwind_Resume(a1);
}

void gMIDIUMPEndpointLog(void)
{
  unsigned __int8 v0;

  if ((v0 & 1) == 0)
  {
    {
      gMIDIUMPEndpointLog(void)::logCat = (uint64_t)os_log_create("com.apple.coremidi", "server-endpoint-manager");
    }
  }
}

void UMPStream::EndpointManager::sendEndpointDiscoveryMessage(UMPStream::EndpointManager *this, uint64_t a2)
{
  NSObject *v4;
  __int128 v5;
  uint8_t buf[4];
  const char *v7;
  __int16 v8;
  int v9;
  _BYTE v10[36];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v5 = xmmword_1D4F18A20;
  MIDI::SingleUMPEventList::SingleUMPEventList((uint64_t)v10, &v5);
  if ((*(unsigned int (**)(_QWORD, uint64_t, _BYTE *))(*(_QWORD *)this + 344))(*(unsigned int *)(*(_QWORD *)this + 340), a2, v10))
  {
    gMIDIUMPEndpointLog();
    v4 = gMIDIUMPEndpointLog(void)::logCat;
    if (os_log_type_enabled((os_log_t)gMIDIUMPEndpointLog(void)::logCat, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136315394;
      v7 = "EndpointManager.cpp";
      v8 = 1024;
      v9 = 217;
      _os_log_impl(&dword_1D4E88000, v4, OS_LOG_TYPE_INFO, "%25s:%-5d NOTICE: Failed to send endpoint discovery message", buf, 0x12u);
    }
  }
}

void UMPStream::EndpointManager::sendEndpointInfoNotificationMessage(UMPStream::EndpointManager *this, uint64_t a2)
{
  NSObject *v4;
  __int128 v5;
  uint8_t buf[4];
  const char *v7;
  __int16 v8;
  int v9;
  _BYTE v10[36];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v5 = xmmword_1D4F18A30;
  MIDI::SingleUMPEventList::SingleUMPEventList((uint64_t)v10, &v5);
  if ((*(unsigned int (**)(_QWORD, uint64_t, _BYTE *))(*(_QWORD *)this + 344))(*(unsigned int *)(*(_QWORD *)this + 340), a2, v10))
  {
    gMIDIUMPEndpointLog();
    v4 = gMIDIUMPEndpointLog(void)::logCat;
    if (os_log_type_enabled((os_log_t)gMIDIUMPEndpointLog(void)::logCat, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136315394;
      v7 = "EndpointManager.cpp";
      v8 = 1024;
      v9 = 229;
      _os_log_impl(&dword_1D4E88000, v4, OS_LOG_TYPE_INFO, "%25s:%-5d NOTICE: Failed to send endpoint discovery message", buf, 0x12u);
    }
  }
}

void UMPStream::EndpointManager::processBackground(unsigned int,MIDI::MIDIEvent const&)::$_0::operator()(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  unsigned int v12;
  uint64_t v13;
  NSObject *v14;
  uint8_t buf[4];
  _BYTE v16[14];
  uint64_t v17[6];

  v17[5] = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD **)a1;
  v5 = **(_DWORD **)(a1 + 8);
  v6 = **(_DWORD **)(a1 + 16);
  v7 = **(_DWORD **)(a1 + 24);
  v8 = operator new();
  MIDIObject::MIDIObject((MIDIObject *)v8);
  *(_BYTE *)(v8 + 44) = 0;
  *(_BYTE *)(v8 + 48) = 0;
  *(_QWORD *)(v8 + 56) = 0;
  *(_QWORD *)v8 = off_1E98B7008;
  *(_DWORD *)(v8 + 64) = 0;
  *(_QWORD *)(v8 + 80) = 0;
  *(_QWORD *)(v8 + 88) = 0;
  *(_QWORD *)(v8 + 72) = 0;
  *(_DWORD *)(v8 + 96) = v7;
  *(_DWORD *)(v8 + 100) = v5;
  *(_DWORD *)(v8 + 104) = v6;
  *(_DWORD *)(v8 + 112) = 0;
  *(_QWORD *)(v8 + 128) = 0;
  *(_QWORD *)(v8 + 136) = 0;
  *(_QWORD *)(v8 + 120) = 0;
  v9 = *(_DWORD *)(a2 + 4);
  *(_BYTE *)(v8 + 144) = v9 < 0;
  *(_BYTE *)(v8 + 145) = (v9 & 2) != 0;
  *(_BYTE *)(v8 + 146) = v9 & 1;
  *(_WORD *)(v8 + 147) = 0;
  *(_QWORD *)(v8 + 160) = 0;
  *(_QWORD *)(v8 + 168) = 0;
  *(_QWORD *)(v8 + 152) = 0;
  *(_WORD *)(v8 + 176) = HIBYTE(v9) & 0x7F;
  v17[0] = v8;
  v10 = UMPCIManager<UMPStream::EndpointPair>::addPair(v4, v17);
  if (v17[0])
    std::default_delete<UMPStream::EndpointPair>::operator()[abi:ne180100](v17[0]);
  if (v10)
  {
    *(_QWORD *)(v10 + 56) = **(_QWORD **)(a1 + 32);
    *(_DWORD *)(v10 + 64) = 1;
  }
  if ((*(_BYTE *)(a2 + 7) & 0x7F) != 0)
  {
    v11 = 0;
    v12 = 0;
    do
    {
      v13 = **(unsigned int **)(a1 + 16);
      *(_DWORD *)buf = v11 | 0xF0100003;
      *(_DWORD *)v16 = 0;
      *(_QWORD *)&v16[4] = 0;
      MIDI::SingleUMPEventList::SingleUMPEventList((uint64_t)v17, buf);
      if ((*(unsigned int (**)(_QWORD, uint64_t, uint64_t *))(*v4 + 344))(*(unsigned int *)(*v4 + 340), v13, v17))
      {
        gMIDIUMPEndpointLog();
        v14 = gMIDIUMPEndpointLog(void)::logCat;
        if (os_log_type_enabled((os_log_t)gMIDIUMPEndpointLog(void)::logCat, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)v16 = "EndpointManager.cpp";
          *(_WORD *)&v16[8] = 1024;
          *(_DWORD *)&v16[10] = 252;
          _os_log_impl(&dword_1D4E88000, v14, OS_LOG_TYPE_INFO, "%25s:%-5d NOTICE: Failed to send function block discovery message", buf, 0x12u);
        }
      }
      ++v12;
      v11 += 256;
    }
    while (v12 < (*(_BYTE *)(a2 + 7) & 0x7Fu));
  }
}

void sub_1D4E9E234(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if (a15)
    std::default_delete<UMPStream::EndpointPair>::operator()[abi:ne180100](a15);
  _Unwind_Resume(exception_object);
}

void UMPStream::EndpointManager::sendStreamConfigurationRequestMessage(UMPStream::EndpointManager *this, uint64_t a2, MIDIProtocolID a3)
{
  NSObject *v5;
  unsigned int v6;
  _BYTE v7[14];
  _BYTE v8[36];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v6 = (a3 << 8) | 0xF0050000;
  *(_DWORD *)v7 = 0;
  *(_QWORD *)&v7[4] = 0;
  MIDI::SingleUMPEventList::SingleUMPEventList((uint64_t)v8, &v6);
  if ((*(unsigned int (**)(_QWORD, uint64_t, _BYTE *))(*(_QWORD *)this + 344))(*(unsigned int *)(*(_QWORD *)this + 340), a2, v8))
  {
    gMIDIUMPEndpointLog();
    v5 = gMIDIUMPEndpointLog(void)::logCat;
    if (os_log_type_enabled((os_log_t)gMIDIUMPEndpointLog(void)::logCat, OS_LOG_TYPE_INFO))
    {
      v6 = 136315394;
      *(_QWORD *)v7 = "EndpointManager.cpp";
      *(_WORD *)&v7[8] = 1024;
      *(_DWORD *)&v7[10] = 241;
      _os_log_impl(&dword_1D4E88000, v5, OS_LOG_TYPE_INFO, "%25s:%-5d NOTICE: Failed to send stream configuration request", (uint8_t *)&v6, 0x12u);
    }
  }
}

uint64_t MIDI::SingleUMPEventList::SingleUMPEventList(uint64_t a1, _DWORD *a2)
{
  int v3;
  unint64_t v4;
  uint64_t v5;
  BOOL v6;
  _DWORD *v7;
  char *v8;
  int v9;
  int v10;
  __int128 v12;

  if (*a2 >> 28 == 2)
    v3 = 1;
  else
    v3 = 2;
  *(_DWORD *)a1 = v3;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  v4 = *(_QWORD *)a2;
  v5 = MIDI::UniversalPacket::word_sizes[*(_QWORD *)a2 >> 28];
  v12 = *(_OWORD *)a2;
  if ((_DWORD)v5)
    v6 = a1 + 4 * (unint64_t)v5 + 20 > a1 + 36;
  else
    v6 = 1;
  if (!v6)
  {
    *(_DWORD *)(a1 + 4) = 1;
    *(_QWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 16) = 0;
    v7 = (_DWORD *)(a1 + 20);
    v8 = (char *)&v12;
    switch((int)v5)
    {
      case 1:
        goto LABEL_12;
      case 2:
        goto LABEL_11;
      case 3:
        goto LABEL_10;
      case 4:
        *(_DWORD *)(a1 + 20) = v4;
        v4 >>= 32;
        v8 = (char *)&v12 + 4;
        v7 = (_DWORD *)(a1 + 24);
LABEL_10:
        *v7++ = v4;
        v9 = *((_DWORD *)v8 + 1);
        v8 += 4;
        LODWORD(v4) = v9;
LABEL_11:
        *v7++ = v4;
        LODWORD(v4) = *((_DWORD *)v8 + 1);
LABEL_12:
        *v7 = v4;
        v10 = *(_DWORD *)(a1 + 16);
        break;
      default:
        memcpy(v7, &v12, 4 * v5);
        v10 = 0;
        break;
    }
    *(_DWORD *)(a1 + 16) = v10 + v5;
  }
  return a1;
}

void UMPCIServerContext::sendNotificationForObject(uint64_t a1, int a2, int a3, const void **a4)
{
  uint64_t v8;
  const void *v9;
  const void *v10;
  uint8_t buf[16];

  v8 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<UMPCIObject>::sRTTI, a3);
  if (v8)
  {
    (*(void (**)(uint8_t *__return_ptr))(*(_QWORD *)v8 + 88))(buf);
    v9 = *a4;
    *a4 = *(const void **)buf;
    *(_QWORD *)buf = v9;
    if (v9)
      CFRelease(v9);
    goto LABEL_5;
  }
  if (a2 == 2)
  {
LABEL_5:
    v10 = *a4;
    if (v10)
      CFRetain(v10);
    std::function<void ()(UMPCIObjectEvent,unsigned int,applesauce::CF::DictionaryRef)>::operator()(*(_QWORD *)(a1 + 296), a2, a3);
    if (v10)
      CFRelease(v10);
    return;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_1D4E88000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, " Only destroyed objects should have a null dictionary.", buf, 2u);
  }
  __break(1u);
}

void sub_1D4E9E564(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  applesauce::CF::DictionaryRef::~DictionaryRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::function<void ()(UMPCIObjectEvent,unsigned int,applesauce::CF::DictionaryRef)>::operator()(uint64_t a1, int a2, int a3)
{
  int v4;
  int v5;

  v5 = a2;
  v4 = a3;
  if (!a1)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, int *, int *))(*(_QWORD *)a1 + 48))(a1, &v5, &v4);
}

uint64_t UMPCIManager<UMPStream::EndpointPair>::addPair(_QWORD *a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t Pair;
  unint64_t v6;
  uint64_t *v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  uint64_t *v15;
  char *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;

  v4 = *a2;
  Pair = UMPCIManager<UMPStream::EndpointPair>::getPair((uint64_t)a1, *(_DWORD *)(*a2 + 100), *(_DWORD *)(*a2 + 104));
  if (!Pair)
  {
    Pair = v4;
    *a2 = 0;
    v7 = (uint64_t *)a1[2];
    v6 = a1[3];
    if ((unint64_t)v7 >= v6)
    {
      v9 = (_QWORD *)a1[1];
      v10 = v7 - v9;
      v11 = v10 + 1;
      if ((unint64_t)(v10 + 1) >> 61)
        std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
      v12 = v6 - (_QWORD)v9;
      if (v12 >> 2 > v11)
        v11 = v12 >> 2;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
        v13 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v13 = v11;
      if (v13)
      {
        if (v13 >> 61)
          std::__throw_bad_array_new_length[abi:ne180100]();
        v14 = (char *)operator new(8 * v13);
      }
      else
      {
        v14 = 0;
      }
      v15 = (uint64_t *)&v14[8 * v10];
      v16 = &v14[8 * v13];
      *v15 = Pair;
      v8 = v15 + 1;
      if (v7 == v9)
      {
        a1[1] = v15;
        a1[2] = v8;
        a1[3] = v16;
        if (!v7)
          goto LABEL_23;
      }
      else
      {
        do
        {
          v17 = *--v7;
          *v7 = 0;
          *--v15 = v17;
        }
        while (v7 != v9);
        v18 = (uint64_t *)a1[1];
        v7 = (uint64_t *)a1[2];
        a1[1] = v15;
        a1[2] = v8;
        a1[3] = v16;
        if (v7 != v18)
        {
          do
          {
            v20 = *--v7;
            v19 = v20;
            *v7 = 0;
            if (v20)
              std::default_delete<UMPStream::EndpointPair>::operator()[abi:ne180100](v19);
          }
          while (v7 != v18);
          v7 = v18;
        }
        if (!v7)
          goto LABEL_23;
      }
      operator delete(v7);
    }
    else
    {
      *v7 = v4;
      v8 = v7 + 1;
    }
LABEL_23:
    a1[2] = v8;
  }
  return Pair;
}

void sub_1D4E9E6FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::default_delete<UMPStream::EndpointPair>::operator()[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void std::vector<std::unique_ptr<UMPStream::EndpointPair>>::erase(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t *v3;
  uint64_t *v4;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (a2 != a3)
  {
    v3 = a3;
    v4 = a2;
    v6 = *(uint64_t **)(a1 + 8);
    if (a3 != v6)
    {
      v7 = a3 - a2;
      do
      {
        v8 = v4[v7];
        v4[v7] = 0;
        v9 = *v4;
        *v4 = v8;
        if (v9)
          std::default_delete<UMPStream::EndpointPair>::operator()[abi:ne180100](v9);
        ++v4;
      }
      while (&v4[v7] != v6);
      v3 = *(uint64_t **)(a1 + 8);
    }
    while (v3 != v4)
    {
      v11 = *--v3;
      v10 = v11;
      *v3 = 0;
      if (v11)
        std::default_delete<UMPStream::EndpointPair>::operator()[abi:ne180100](v10);
    }
    *(_QWORD *)(a1 + 8) = v4;
  }
}

uint64_t UMPCIManager<UMPStream::EndpointPair>::removePairs(unsigned int,unsigned int)::{lambda(UMPStream::EndpointPair const&)#1}::operator()<std::unique_ptr<UMPStream::EndpointPair>>(int *a1, _DWORD *a2)
{
  int v2;
  int v3;
  uint64_t v4;
  int v5;
  unint64_t v6;
  _DWORD *v7;
  _DWORD *v8;
  _DWORD *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  BOOL v14;
  unint64_t v15;
  uint64_t v16;
  _DWORD *v17;
  unint64_t v18;
  int v19;

  v2 = a1[1];
  if (v2)
  {
    v3 = *a1;
  }
  else
  {
    v3 = *a1;
    if (a2[25] == *a1)
      goto LABEL_8;
  }
  if ((v3 || a2[26] != v2) && (a2[25] != v3 || a2[26] != v2))
    return 0;
LABEL_8:
  v4 = *((_QWORD *)a1 + 1);
  v5 = a2[2];
  v7 = *(_DWORD **)(v4 + 8);
  v6 = *(_QWORD *)(v4 + 16);
  if ((unint64_t)v7 >= v6)
  {
    v10 = *(_DWORD **)v4;
    v11 = ((uint64_t)v7 - *(_QWORD *)v4) >> 2;
    v12 = v11 + 1;
    if ((unint64_t)(v11 + 1) >> 62)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v13 = v6 - (_QWORD)v10;
    if (v13 >> 1 > v12)
      v12 = v13 >> 1;
    v14 = (unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL;
    v15 = 0x3FFFFFFFFFFFFFFFLL;
    if (!v14)
      v15 = v12;
    if (v15)
    {
      v15 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(v15);
      v10 = *(_DWORD **)v4;
      v7 = *(_DWORD **)(v4 + 8);
    }
    else
    {
      v16 = 0;
    }
    v17 = (_DWORD *)(v15 + 4 * v11);
    v18 = v15 + 4 * v16;
    *v17 = v5;
    v8 = v17 + 1;
    while (v7 != v10)
    {
      v19 = *--v7;
      *--v17 = v19;
    }
    *(_QWORD *)v4 = v17;
    *(_QWORD *)(v4 + 8) = v8;
    *(_QWORD *)(v4 + 16) = v18;
    if (v10)
      operator delete(v10);
  }
  else
  {
    *v7 = v5;
    v8 = v7 + 1;
  }
  *(_QWORD *)(v4 + 8) = v8;
  return 1;
}

void UMPCIObject::updateDescription(uint64_t a1, _QWORD *a2, const __CFDictionary **a3)
{
  const __CFNumber *v6;
  const __CFNumber *v7;
  char v8;
  const __CFNumber *v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  applesauce::CF *exception;
  applesauce::CF *v15;
  applesauce::CF *v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;

  if (!*a3)
  {
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  v6 = applesauce::CF::DictionaryRef_proxy::at_as<UMPCIObjectType,char const* const&>(*a3, "type");
  if (!((unint64_t)v6 >> 32) || (*(unsigned int (**)(_QWORD *))(*a2 + 96))(a2) != (_DWORD)v6)
    goto LABEL_11;
  if (!*a3)
  {
    v15 = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(v15);
  }
  v7 = applesauce::CF::details::find_at_key_or_optional<unsigned long long,char const* const&>(*a3);
  if (v8 && (unint64_t)v7 > a2[7])
  {
    if (!*a3)
    {
      v16 = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
      applesauce::CF::construct_error(v16);
    }
    v9 = applesauce::CF::details::find_at_key_or_optional<unsigned long long,char const* const&>(*a3);
    if (!v10)
      std::__throw_bad_optional_access[abi:ne180100]();
    a2[7] = v9;
    (*(void (**)(uint64_t **__return_ptr, _QWORD *, const __CFDictionary **))(*a2 + 80))(&v17, a2, a3);
    v11 = v18;
    *(_QWORD *)a1 = v17;
    *(_QWORD *)(a1 + 8) = v11;
    v12 = a1 + 8;
    v13 = v19;
    *(_QWORD *)(a1 + 16) = v19;
    if (v13)
    {
      *(_QWORD *)(v11 + 16) = v12;
      v17 = &v18;
      v18 = 0;
      v19 = 0;
      v11 = 0;
    }
    else
    {
      *(_QWORD *)a1 = v12;
    }
    *(_BYTE *)(a1 + 24) = 1;
    std::__tree<std::string>::destroy((char *)v11);
  }
  else
  {
LABEL_11:
    *(_BYTE *)a1 = 0;
    *(_BYTE *)(a1 + 24) = 0;
  }
}

void sub_1D4E9EA30(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::__tree<std::string>::destroy(char *a1)
{
  if (a1)
  {
    std::__tree<std::string>::destroy(*(_QWORD *)a1);
    std::__tree<std::string>::destroy(*((_QWORD *)a1 + 1));
    if (a1[55] < 0)
      operator delete(*((void **)a1 + 4));
    operator delete(a1);
  }
}

const __CFNumber *applesauce::CF::DictionaryRef_proxy::at_as<UMPCIObjectType,char const* const&>(const __CFDictionary *a1, char *a2)
{
  const __CFNumber *result;
  const __CFNumber *v3;
  CFTypeID TypeID;
  unsigned int valuePtr;

  result = (const __CFNumber *)applesauce::CF::details::at_key<char const* const&>(a1, a2);
  if (result)
  {
    v3 = result;
    TypeID = CFNumberGetTypeID();
    if (TypeID == CFGetTypeID(v3))
    {
      valuePtr = 0;
      if (CFNumberGetValue(v3, kCFNumberIntType, &valuePtr))
        return (const __CFNumber *)(valuePtr | 0x100000000);
      else
        return 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

const __CFNumber *applesauce::CF::details::find_at_key_or_optional<unsigned long long,char const* const&>(const __CFDictionary *a1)
{
  const __CFNumber *result;

  result = (const __CFNumber *)applesauce::CF::details::at_key<char const* const&>(a1, "timestamp");
  if (result)
    return applesauce::CF::convert_as<unsigned long long,0>(result);
  return result;
}

void std::__throw_bad_optional_access[abi:ne180100]()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
  *exception = MEMORY[0x1E0DE5048] + 16;
}

const void *applesauce::CF::details::at_key<char const* const&>(const __CFDictionary *a1, char *a2)
{
  const void *Value;
  void *key;

  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&key, a2);
  if (a1)
    Value = CFDictionaryGetValue(a1, key);
  if (key)
    CFRelease(key);
  if (!a1)
    return 0;
  return Value;
}

void sub_1D4E9EBC8(void *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  applesauce::CF::StringRef::~StringRef((const void **)va);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4E9EBACLL);
}

const __CFNumber *applesauce::CF::convert_as<unsigned long long,0>(const __CFNumber *result)
{
  const __CFNumber *v1;
  CFTypeID TypeID;
  int Value;
  CFTypeID v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  char v12;
  BOOL v13;
  unsigned __int8 v14;
  uint64_t v15;
  unint64_t v16;
  BOOL v17;
  double valuePtr;

  if (result)
  {
    v1 = result;
    TypeID = CFNumberGetTypeID();
    if (TypeID == CFGetTypeID(v1))
    {
      switch(CFNumberGetType(v1))
      {
        case kCFNumberSInt8Type:
          LOBYTE(valuePtr) = 0;
          Value = CFNumberGetValue(v1, kCFNumberSInt8Type, &valuePtr);
          goto LABEL_16;
        case kCFNumberSInt16Type:
          LOWORD(valuePtr) = 0;
          v7 = CFNumberGetValue(v1, kCFNumberSInt16Type, &valuePtr);
          goto LABEL_24;
        case kCFNumberSInt32Type:
          LODWORD(valuePtr) = 0;
          v8 = CFNumberGetValue(v1, kCFNumberSInt32Type, &valuePtr);
          goto LABEL_26;
        case kCFNumberSInt64Type:
          valuePtr = 0.0;
          v9 = CFNumberGetValue(v1, kCFNumberSInt64Type, &valuePtr);
          goto LABEL_37;
        case kCFNumberFloat32Type:
          LODWORD(valuePtr) = 0;
          v10 = CFNumberGetValue(v1, kCFNumberFloat32Type, &valuePtr);
          goto LABEL_33;
        case kCFNumberFloat64Type:
          valuePtr = 0.0;
          v11 = CFNumberGetValue(v1, kCFNumberFloat64Type, &valuePtr);
          goto LABEL_39;
        case kCFNumberCharType:
          LOBYTE(valuePtr) = 0;
          Value = CFNumberGetValue(v1, kCFNumberCharType, &valuePtr);
LABEL_16:
          if (Value)
            v12 = LOBYTE(valuePtr);
          else
            v12 = 0;
          if (Value != 0 && SLOBYTE(valuePtr) < 0)
            v5 = -256;
          else
            v5 = 0;
          LOBYTE(v6) = v12;
          return (const __CFNumber *)(v6 | v5);
        case kCFNumberShortType:
          LOWORD(valuePtr) = 0;
          v7 = CFNumberGetValue(v1, kCFNumberShortType, &valuePtr);
LABEL_24:
          v13 = v7 == 0;
          v14 = LOBYTE(valuePtr);
          v15 = SLOWORD(valuePtr);
          goto LABEL_27;
        case kCFNumberIntType:
          LODWORD(valuePtr) = 0;
          v8 = CFNumberGetValue(v1, kCFNumberIntType, &valuePtr);
LABEL_26:
          v13 = v8 == 0;
          v14 = LOBYTE(valuePtr);
          v15 = SLODWORD(valuePtr);
LABEL_27:
          v16 = v15 & 0xFFFFFFFFFFFFFF00 | v14;
          if (v13)
            v6 = 0;
          else
            v6 = v16;
          goto LABEL_43;
        case kCFNumberLongType:
          valuePtr = 0.0;
          v9 = CFNumberGetValue(v1, kCFNumberLongType, &valuePtr);
          goto LABEL_37;
        case kCFNumberLongLongType:
          valuePtr = 0.0;
          v9 = CFNumberGetValue(v1, kCFNumberLongLongType, &valuePtr);
          goto LABEL_37;
        case kCFNumberFloatType:
          LODWORD(valuePtr) = 0;
          v10 = CFNumberGetValue(v1, kCFNumberFloatType, &valuePtr);
LABEL_33:
          v17 = v10 == 0;
          v6 = (unint64_t)*(float *)&valuePtr;
          goto LABEL_40;
        case kCFNumberDoubleType:
          valuePtr = 0.0;
          v11 = CFNumberGetValue(v1, kCFNumberDoubleType, &valuePtr);
          goto LABEL_39;
        case kCFNumberCFIndexType:
          valuePtr = 0.0;
          v9 = CFNumberGetValue(v1, kCFNumberCFIndexType, &valuePtr);
          goto LABEL_37;
        case kCFNumberNSIntegerType:
          valuePtr = 0.0;
          v9 = CFNumberGetValue(v1, kCFNumberNSIntegerType, &valuePtr);
LABEL_37:
          v17 = v9 == 0;
          v6 = *(_QWORD *)&valuePtr;
          goto LABEL_40;
        case kCFNumberCGFloatType:
          valuePtr = 0.0;
          v11 = CFNumberGetValue(v1, kCFNumberCGFloatType, &valuePtr);
LABEL_39:
          v17 = v11 == 0;
          v6 = (unint64_t)valuePtr;
LABEL_40:
          if (v17)
            v6 = 0;
LABEL_43:
          v5 = v6 & 0xFFFFFFFFFFFFFF00;
          break;
        default:
          v5 = 0;
          LOBYTE(v6) = 0;
          break;
      }
      return (const __CFNumber *)(v6 | v5);
    }
    else
    {
      v4 = CFBooleanGetTypeID();
      if (v4 == CFGetTypeID(v1))
        return (const __CFNumber *)CFBooleanGetValue(v1);
      else
        return 0;
    }
  }
  return result;
}

uint64_t std::__split_buffer<applesauce::CF::DictionaryRef>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  const void *v4;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    v4 = *(const void **)(i - 8);
    *(_QWORD *)(a1 + 16) = i - 8;
    std::__destroy_at[abi:ne180100]<applesauce::CF::DictionaryRef,0>(v4);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

CFArrayRef applesauce::CF::details::make_CFArrayRef<applesauce::CF::DictionaryRef>(uint64_t **a1)
{
  uint64_t *v2;
  uint64_t *v3;
  _QWORD *v4;
  uint64_t v5;
  CFArrayRef CFArray;
  void *__p;
  void *v9;

  std::vector<void const*>::vector(&__p, a1[1] - *a1);
  v2 = *a1;
  v3 = a1[1];
  if (*a1 != v3)
  {
    v4 = __p;
    do
    {
      v5 = *v2++;
      *v4++ = v5;
    }
    while (v2 != v3);
  }
  CFArray = applesauce::CF::details::make_CFArrayRef<void const*>((const void **)__p, (uint64_t)v9);
  if (__p)
  {
    v9 = __p;
    operator delete(__p);
  }
  return CFArray;
}

void sub_1D4E9EF88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::vector<applesauce::CF::DictionaryRef>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  const void *v6;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = (const void *)*((_QWORD *)v4 - 1);
        v4 -= 8;
        std::__destroy_at[abi:ne180100]<applesauce::CF::DictionaryRef,0>(v6);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void applesauce::CF::ArrayRef::~ArrayRef(const void **this)
{
  const void *v1;

  v1 = *this;
  if (v1)
    CFRelease(v1);
}

void std::__destroy_at[abi:ne180100]<applesauce::CF::DictionaryRef,0>(const void *a1)
{
  if (a1)
    CFRelease(a1);
}

_QWORD *std::vector<void const*>::vector(_QWORD *a1, unint64_t a2)
{
  char *v4;
  uint64_t v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    if (a2 >> 61)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v4 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(a2);
    *a1 = v4;
    a1[2] = &v4[8 * v5];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_1D4E9F0CC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

CFArrayRef applesauce::CF::details::make_CFArrayRef<void const*>(const void **values, uint64_t a2)
{
  CFArrayRef result;
  applesauce::CF *exception;

  result = CFArrayCreate(0, values, (a2 - (uint64_t)values) >> 3, MEMORY[0x1E0C9B378]);
  if (!result)
  {
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  return result;
}

void sub_1D4E9F134()
{
  void *v0;

}

void sub_1D4E9F14C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t AsyncMessenger::push(uint64_t a1, char a2, int a3, uint64_t a4, char *__src)
{
  unint64_t v8;
  int v9;
  char *v10;
  uint64_t v11;
  BOOL v12;
  int *v13;
  int v14;
  int v15;
  int v16;
  size_t v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  int v23;
  int __srca;
  int v26;
  uint64_t v27;
  int v28;
  _DWORD v29[4];
  int v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v8 = *(unsigned int *)__src;
  if (v8 >> 28 == 2)
    v9 = 1;
  else
    v9 = 2;
  __srca = v9;
  v26 = 0;
  v10 = (char *)&v27;
  v11 = MIDI::UniversalPacket::word_sizes[v8 >> 28];
  v28 = 0;
  if ((_DWORD)v11)
    v12 = &v29[v11] > (_DWORD *)&v31;
  else
    v12 = 1;
  if (!v12)
  {
    v26 = 1;
    v27 = a4;
    v13 = v29;
    switch((int)v11)
    {
      case 1:
        goto LABEL_12;
      case 2:
        goto LABEL_11;
      case 3:
        goto LABEL_10;
      case 4:
        v29[0] = v8;
        v14 = *((_DWORD *)__src + 1);
        __src += 4;
        LODWORD(v8) = v14;
        v13 = &v30;
LABEL_10:
        *v13++ = v8;
        v15 = *((_DWORD *)__src + 1);
        __src += 4;
        LODWORD(v8) = v15;
LABEL_11:
        *v13++ = v8;
        LODWORD(v8) = *((_DWORD *)__src + 1);
LABEL_12:
        *v13 = v8;
        v16 = v28;
        break;
      default:
        memcpy(v29, __src, 4 * v11);
        v16 = 0;
        break;
    }
    v28 = v16 + v11;
    v10 = (char *)&v29[(v16 + v11)];
  }
  v17 = v10 - (char *)&__srca;
  v18 = (*(uint64_t (**)(_QWORD, size_t, uint64_t))(**(_QWORD **)(a1 + 168) + 16))(*(_QWORD *)(a1 + 168), v17 + 13, 8);
  *(_BYTE *)(v18 + 8) = a2;
  *(_DWORD *)(v18 + 9) = a3;
  memcpy((void *)(v18 + 13), &__srca, v17);
  v19 = (unint64_t *)(a1 + 96);
  v20 = *(_QWORD *)(a1 + 96);
  atomic_store(v20, (unint64_t *)v18);
  v21 = __ldaxr((unint64_t *)(a1 + 96));
  if (v21 != v20)
  {
    __clrex();
LABEL_19:
    while (1)
    {
      atomic_store(v21, (unint64_t *)v18);
      v22 = __ldaxr(v19);
      if (v22 != v21)
        break;
      if (__stlxr(v18, v19))
        goto LABEL_23;
      v23 = 1;
LABEL_24:
      v21 = v22;
      if (v23)
        return caulk::mach::semaphore::signal_all_or_error((caulk::mach::semaphore *)(a1 + 12));
    }
    __clrex();
LABEL_23:
    v23 = 0;
    goto LABEL_24;
  }
  if (__stlxr(v18, v19))
    goto LABEL_19;
  return caulk::mach::semaphore::signal_all_or_error((caulk::mach::semaphore *)(a1 + 12));
}

void sub_1D4E9F338(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

void MIDIObject::MIDIObject(MIDIObject *this)
{
  _QWORD *v2;

  BaseOpaqueObject::BaseOpaqueObject(this);
  *v2 = off_1E98B9320;
  v2[2] = 0;
  *((_QWORD *)this + 3) = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  *((_WORD *)this + 16) = 257;
}

void sub_1D4E9F3A4(_Unwind_Exception *a1)
{
  BaseOpaqueObject *v1;

  BaseOpaqueObject::~BaseOpaqueObject(v1);
  _Unwind_Resume(a1);
}

void MIDIDriverPlugin_CFPlugin::~MIDIDriverPlugin_CFPlugin(MIDIDriverPlugin_CFPlugin *this)
{
  MIDIDriverPlugin_CFPlugin::~MIDIDriverPlugin_CFPlugin(this);
  JUMPOUT(0x1D826BA98);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;

  v2 = *((_QWORD *)this + 9);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  if (*((_QWORD *)this + 10))
  {
    v3 = (std::__shared_weak_count *)*((_QWORD *)this + 11);
    *((_QWORD *)this + 10) = 0;
    *((_QWORD *)this + 11) = 0;
    if (v3)
    {
      p_shared_owners = (unint64_t *)&v3->__shared_owners_;
      do
        v5 = __ldaxr(p_shared_owners);
      while (__stlxr(v5 - 1, p_shared_owners));
      if (!v5)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
  }
  std::shared_ptr<swix::connection::state>::~shared_ptr[abi:ne180100]((uint64_t)this + 80);
  *(_QWORD *)this = off_1E98B9918;
  XCFObject<__CFString const*>::~XCFObject((uint64_t)this + 48);
  *(_QWORD *)this = off_1E98B9320;
  XCFObject<__CFDictionary const*>::~XCFObject((uint64_t)this + 24);
  BaseOpaqueObject::~BaseOpaqueObject(this);
}

uint64_t MIDIDriverPlugin_CFPlugin::PrintObject(MIDIDriverPlugin_CFPlugin *this, __sFILE *a2)
{
  fprintf(a2, "<%s 0x%x [%p]>", "MIDIDriverPlugin_CFPlugin", *((_DWORD *)this + 2), this);
  fprintf(a2, " parent=0x%X", *((_QWORD *)this + 2));
  return fputc(10, a2);
}

uint64_t MIDIDriverPlugin_CFPlugin::FindDevices(MIDIDriverPlugin_CFPlugin *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 9) + 32))(*((_QWORD *)this + 9));
}

uint64_t MIDIDriverPlugin_CFPlugin::StartMIDI(MIDIDriverPlugin_CFPlugin *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 9) + 40))(*((_QWORD *)this + 9));
}

uint64_t MIDIDriverPlugin_CFPlugin::StopMIDI(MIDIDriverPlugin_CFPlugin *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 9) + 48))(*((_QWORD *)this + 9));
}

uint64_t MIDIDriverPlugin_CFPlugin::SendPacket(MIDIDriverPlugin_CFPlugin *this, const MIDIPacketList *a2, void *a3, void *a4)
{
  return (*(uint64_t (**)(_QWORD, const MIDIPacketList *, void *, void *))(**((_QWORD **)this + 9) + 64))(*((_QWORD *)this + 9), a2, a3, a4);
}

uint64_t MIDIDriverPlugin_CFPlugin::EnableSource(MIDIDriverPlugin_CFPlugin *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 9) + 72))(*((_QWORD *)this + 9));
}

uint64_t MIDIDriverPlugin_CFPlugin::Flush(uint64_t this, uint64_t a2, void *a3, void *a4)
{
  if (*(int *)(this + 64) >= 2)
    return (*(uint64_t (**)(_QWORD, uint64_t, void *, void *))(**(_QWORD **)(this + 72) + 80))(*(_QWORD *)(this + 72), a2, a3, a4);
  return this;
}

uint64_t MIDIDriverPlugin_CFPlugin::Monitor(uint64_t this, uint64_t a2, const MIDIPacketList *a3)
{
  if (*(int *)(this + 64) >= 2)
    return (*(uint64_t (**)(_QWORD, uint64_t, const MIDIPacketList *))(**(_QWORD **)(this + 72) + 88))(*(_QWORD *)(this + 72), a2, a3);
  return this;
}

uint64_t MIDIDriverPlugin_CFPlugin::MonitorEvents(uint64_t this, uint64_t a2, MIDIEventList *a3)
{
  uint64_t v3;

  if (*(int *)(this + 64) > 2)
    return (*(uint64_t (**)(_QWORD, uint64_t, MIDIEventList *))(**(_QWORD **)(this + 72) + 104))(*(_QWORD *)(this + 72), a2, a3);
  v3 = *(_QWORD *)(this + 80);
  if (v3)
  {
    *(_DWORD *)(this + 96) = a2;
    return MIDI::MIDIPacketList_Deliverer::operator()(v3, a3);
  }
  return this;
}

uint64_t MIDIDriverPlugin_CFPlugin::SendEventList(MIDIDriverPlugin_CFPlugin *this, const MIDIEventList *a2, void *a3, void *a4)
{
  if (*((int *)this + 16) >= 3)
    return (*(uint64_t (**)(_QWORD, const MIDIEventList *, void *, void *))(**((_QWORD **)this + 9) + 96))(*((_QWORD *)this + 9), a2, a3, a4);
  else
    return 4294956452;
}

uint64_t MIDI::MIDIPacketList_Deliverer::operator()(uint64_t a1, _DWORD *a2)
{
  unsigned int v4;
  _DWORD *v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  size_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  size_t v15;
  unint64_t v16;
  uint64_t v17;
  _BYTE *v18;
  uint64_t *v19;
  uint64_t v20;
  _BYTE *v21;
  uint64_t *v22;
  char v23;
  char v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  int v32;
  int v33;
  uint64_t v34;
  unint64_t v35;
  unsigned __int8 *v36;
  unsigned int v37;
  unsigned int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  unsigned int v43;
  uint64_t v44;
  int v45;
  unsigned int v46;
  int v47;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  int v52;
  _DWORD *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  _DWORD *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  int *v64;
  int v65;
  int v66;
  uint64_t __src[3];

  __src[1] = *MEMORY[0x1E0C80C00];
  v62 = *(_QWORD *)(a1 + 8);
  (*(void (**)(uint64_t *, uint64_t))(v62 + 8))(&v63, a1 + 16);
  v65 = 0;
  v64 = &v66;
  v53 = a2;
  if (*a2 == 2)
  {
    if (!a2[1])
      return MIDI::PacketizerBase<MIDI::LegacyPacketList>::~PacketizerBase((uint64_t)&v62);
    v25 = 0;
    v26 = (uint64_t)(a2 + 2);
    v49 = a1 + 64;
LABEL_77:
    v52 = v25;
    v27 = *(unsigned int *)(v26 + 8);
    v58 = (_DWORD *)(v26 + 12);
    v59 = v27;
    v51 = v26;
    v60 = *(_QWORD *)v26;
    v61 = 0;
    while (1)
    {
      v56 = 0;
      v57 = 0;
      v55 = 0;
      if (!MIDI::EventList::PacketReader::read((uint64_t *)&v58, &v57, &v55))
      {
        v26 = v51 + 4 * *(unsigned int *)(v51 + 8) + 12;
        v25 = v52 + 1;
        if ((v52 + 1) >= v53[1])
          return MIDI::PacketizerBase<MIDI::LegacyPacketList>::~PacketizerBase((uint64_t)&v62);
        goto LABEL_77;
      }
      __src[0] = v57;
      v28 = v55;
      if (((1 << (v55 >> 28)) & 0xA02B) != 0)
        break;
      if (v55 >> 28 == 4)
      {
        v30 = BYTE3(v55) & 0xF | 0x20;
        v31 = HIDWORD(v55);
        switch(BYTE2(v55) >> 4)
        {
          case 2:
          case 3:
            v34 = v49 + 48 * (BYTE3(v55) & 0xF);
            v35 = ((unint64_t)v55 >> 16) & 0xF;
            v36 = (unsigned __int8 *)(v34 + 3 * v35);
            v37 = (v55 >> 8) & 0x7F;
            v38 = v55 & 0x7F;
            if ((v55 & 0x100000) != 0)
              v39 = 2;
            else
              v39 = 1;
            if (v39 == *v36 && v37 == v36[1])
            {
              v40 = v35 | 0xB0;
              if (v38 == *(unsigned __int8 *)(v34 + 3 * v35 + 2))
              {
                v41 = (v30 << 24) | (v40 << 16);
                goto LABEL_100;
              }
            }
            else
            {
              v40 = v35 | 0xB0;
            }
            v50 = ((unint64_t)v55 >> 16) & 0xF;
            if ((v55 & 0x100000) != 0)
              v42 = 25344;
            else
              v42 = 25856;
            v41 = (v30 << 24) | (v40 << 16);
            v43 = (v55 >> 8) & 0x7F;
            MIDI::LegacyPacketList::write_UP<MIDI::MIDIPacketList_Deliverer::operator()(MIDI::EventList const*)::{lambda(unsigned long long,MIDI::UniversalPacket const&)#2}::operator() const(unsigned long long,MIDI::UniversalPacket const&)::{lambda(MIDI::UniversalPacket const&)#1}::operator() const(MIDI::UniversalPacket const&)::{lambda(std::span<unsigned char const,18446744073709551615ul>)#1}>(v41 | v42 | v37, 0, (uint64_t)&v62, __src);
            MIDI::LegacyPacketList::write_UP<MIDI::MIDIPacketList_Deliverer::operator()(MIDI::EventList const*)::{lambda(unsigned long long,MIDI::UniversalPacket const&)#2}::operator() const(unsigned long long,MIDI::UniversalPacket const&)::{lambda(MIDI::UniversalPacket const&)#1}::operator() const(MIDI::UniversalPacket const&)::{lambda(std::span<unsigned char const,18446744073709551615ul>)#1}>(v41 | (v42 - 256) | v38, 0, (uint64_t)&v62, __src);
            *v36 = v39;
            v44 = v34 + 3 * v50;
            *(_BYTE *)(v44 + 1) = v43;
            *(_BYTE *)(v44 + 2) = v38;
LABEL_100:
            MIDI::LegacyPacketList::write_UP<MIDI::MIDIPacketList_Deliverer::operator()(MIDI::EventList const*)::{lambda(unsigned long long,MIDI::UniversalPacket const&)#2}::operator() const(unsigned long long,MIDI::UniversalPacket const&)::{lambda(MIDI::UniversalPacket const&)#1}::operator() const(MIDI::UniversalPacket const&)::{lambda(std::span<unsigned char const,18446744073709551615ul>)#1}>(v41 | (v31 >> 25) | 0x600, 0, (uint64_t)&v62, __src);
            v45 = (v31 >> 18) & 0x7F;
            if (!v45)
              continue;
            v29 = 0;
            v28 = v45 | v41 | 0x2600u;
            break;
          case 8:
          case 9:
          case 10:
          case 11:
            v29 = 0;
            v32 = BYTE2(v55) >> 4 == 9;
            if (HIDWORD(v55) >> 25)
              v32 = HIDWORD(v55) >> 25;
            v33 = (BYTE2(v55) << 16) | (v30 << 24) | v55 & 0x7F00;
            goto LABEL_87;
          case 12:
            if ((v55 & 1) != 0)
            {
              v47 = BYTE2(v55) << 16;
              MIDI::LegacyPacketList::write_UP<MIDI::MIDIPacketList_Deliverer::operator()(MIDI::EventList const*)::{lambda(unsigned long long,MIDI::UniversalPacket const&)#2}::operator() const(unsigned long long,MIDI::UniversalPacket const&)::{lambda(MIDI::UniversalPacket const&)#1}::operator() const(MIDI::UniversalPacket const&)::{lambda(std::span<unsigned char const,18446744073709551615ul>)#1}>((v47 - 0x100000) & 0xFFFFFF80 | (v30 << 24) | (HIDWORD(v55) >> 8) & 0x7F, 0, (uint64_t)&v62, __src);
              MIDI::LegacyPacketList::write_UP<MIDI::MIDIPacketList_Deliverer::operator()(MIDI::EventList const*)::{lambda(unsigned long long,MIDI::UniversalPacket const&)#2}::operator() const(unsigned long long,MIDI::UniversalPacket const&)::{lambda(MIDI::UniversalPacket const&)#1}::operator() const(MIDI::UniversalPacket const&)::{lambda(std::span<unsigned char const,18446744073709551615ul>)#1}>((v47 - 0x100000) | (v30 << 24) | v31 & 0x7F | 0x2000, 0, (uint64_t)&v62, __src);
              v46 = v30 << 24;
            }
            else
            {
              v46 = v30 << 24;
              v47 = BYTE2(v55) << 16;
            }
            v29 = 0;
            v33 = v46 | v47;
            v32 = HIWORD(v31) & 0x7F00;
LABEL_87:
            v28 = v32 | v33;
            break;
          case 13:
            v29 = 0;
            v28 = (BYTE2(v55) << 16) | (v30 << 24) | (HIDWORD(v55) >> 25 << 8);
            break;
          case 14:
            v29 = 0;
            v28 = (HIDWORD(v55) >> 10) & 0x7F00 | (BYTE2(v55) << 16) | (v30 << 24) | (HIDWORD(v55) >> 25);
            break;
          default:
            continue;
        }
LABEL_81:
        MIDI::LegacyPacketList::write_UP<MIDI::MIDIPacketList_Deliverer::operator()(MIDI::EventList const*)::{lambda(unsigned long long,MIDI::UniversalPacket const&)#2}::operator() const(unsigned long long,MIDI::UniversalPacket const&)::{lambda(MIDI::UniversalPacket const&)#1}::operator() const(MIDI::UniversalPacket const&)::{lambda(std::span<unsigned char const,18446744073709551615ul>)#1}>(v28, v29, (uint64_t)&v62, __src);
      }
    }
    v29 = HIDWORD(v55);
    goto LABEL_81;
  }
  if (*a2 != 1)
    std::terminate();
  if (a2[1])
  {
    v4 = 0;
    v5 = a2 + 2;
    do
    {
      v6 = v5[2];
      v58 = v5 + 3;
      v59 = v6;
      v60 = *(_QWORD *)v5;
      v61 = 0;
      while (1)
      {
        v54 = 0;
        v55 = 0;
        v56 = 0;
        if (!MIDI::EventList::PacketReader::read((uint64_t *)&v58, &v54, &v55))
          break;
        v7 = v54;
        v8 = v55;
        v9 = v55 >> 28;
        if (v55 >> 28 == 3)
        {
          v13 = ((unint64_t)v55 >> 16) & 0xF;
          if (v13 <= 6 && BYTE2(v55) <= 0x3Fu)
          {
            v57 = _byteswap_uint64(__PAIR64__(v55, HIDWORD(v55)));
            if ((v55 & 0x200000) != 0)
            {
              v10 = 0;
              if (!(_DWORD)v13)
                goto LABEL_45;
LABEL_44:
              memcpy((char *)__src + v10, (char *)&v57 + 2, ((unint64_t)v55 >> 16) & 0xF);
              v10 += (v13 - 1) + 1;
              goto LABEL_45;
            }
            LOBYTE(__src[0]) = -16;
            v10 = 1;
            if ((_DWORD)v13)
              goto LABEL_44;
LABEL_45:
            if ((((v8 >> 20) + 3) & 2) != 0)
              *((_BYTE *)__src + v10++) = -9;
            v11 = (unint64_t)v64;
            if (v65)
            {
              v20 = *((unsigned __int16 *)v64 + 4);
              if (*(_QWORD *)v64 == v7 && *((unsigned __int8 *)v64 + v20 + 9) != 247 && LOBYTE(__src[0]) != 240)
              {
                if ((char *)v64 + v10 + v20 + 10 > (char *)__src)
                  goto LABEL_63;
                goto LABEL_60;
              }
              v11 = ((unint64_t)v64 + v20 + 13) & 0xFFFFFFFFFFFFFFFCLL;
            }
            if (v11 + v10 + 10 > (unint64_t)__src)
              goto LABEL_63;
            v20 = 0;
            ++v65;
            *(_QWORD *)v11 = v7;
            *(_WORD *)(v11 + 8) = 0;
LABEL_60:
            v21 = (_BYTE *)(v11 + v20 + 10);
            v22 = __src;
            switch(v10)
            {
              case 0uLL:
                break;
              case 1uLL:
                goto LABEL_69;
              case 2uLL:
                goto LABEL_68;
              case 3uLL:
                goto LABEL_67;
              case 4uLL:
LABEL_66:
                *v21++ = __src[0];
                v22 = (uint64_t *)((char *)__src + 1);
LABEL_67:
                v23 = *(_BYTE *)v22;
                v22 = (uint64_t *)((char *)v22 + 1);
                *v21++ = v23;
LABEL_68:
                v24 = *(_BYTE *)v22;
                v22 = (uint64_t *)((char *)v22 + 1);
                *v21++ = v24;
LABEL_69:
                *v21 = *(_BYTE *)v22;
                break;
              default:
LABEL_70:
                memmove(v21, __src, v10);
                break;
            }
            *(_WORD *)(v11 + 8) += v10;
LABEL_72:
            v64 = (int *)v11;
          }
        }
        else if (v9 == 2)
        {
          v14 = v55 & 0xE00000;
          LOBYTE(__src[0]) = BYTE2(v55);
          BYTE1(__src[0]) = BYTE1(v55) & 0x7F;
          if ((v55 & 0xE00000) == 0xC00000)
            v15 = 2;
          else
            v15 = 3;
          if (v14 != 12582912)
            BYTE2(__src[0]) = v55 & 0x7F;
          v16 = (unint64_t)v64;
          if (v65)
          {
            v17 = *((unsigned __int16 *)v64 + 4);
            if (*(_QWORD *)v64 == v54 && BYTE2(v55) != 240 && *((unsigned __int8 *)v64 + v17 + 9) != 247)
            {
              if ((char *)v64 + v15 + v17 + 10 > (char *)__src)
                goto LABEL_39;
              goto LABEL_41;
            }
            v16 = ((unint64_t)v64 + v17 + 13) & 0xFFFFFFFFFFFFFFFCLL;
          }
          if (v16 + v15 + 10 > (unint64_t)__src)
          {
LABEL_39:
            v16 = MIDI::PacketizerBase<MIDI::LegacyPacketList>::begin_new_packet((uint64_t)&v62, v54, (char *)__src, v15);
            goto LABEL_55;
          }
          v17 = 0;
          ++v65;
          *(_QWORD *)v16 = v54;
          *(_WORD *)(v16 + 8) = 0;
LABEL_41:
          v18 = (_BYTE *)(v16 + v17 + 10);
          if (v14 == 12582912)
          {
            v19 = __src;
          }
          else
          {
            *v18++ = __src[0];
            v19 = (uint64_t *)((char *)__src + 1);
          }
          *v18 = *(_BYTE *)v19;
          v18[1] = *((_BYTE *)v19 + 1);
          *(_WORD *)(v16 + 8) += v15;
LABEL_55:
          v64 = (int *)v16;
        }
        else if (v9 == 1 && BYTE2(v55) >= 0xF0u && ((0x22B1uLL >> (BYTE2(v55) + 16)) & 1) == 0)
        {
          v10 = MIDI::system_message_size::sizes[BYTE2(v55) - 240];
          LOBYTE(__src[0]) = BYTE2(v55);
          if (((0xDD40uLL >> (BYTE2(v55) + 16)) & 1) == 0)
          {
            BYTE1(__src[0]) = BYTE1(v55) & 0x7F;
            if (BYTE2(v55) == 242)
              BYTE2(__src[0]) = v55 & 0x7F;
          }
          v11 = (unint64_t)v64;
          if (v65)
          {
            v12 = *((unsigned __int16 *)v64 + 4);
            if (*(_QWORD *)v64 == v54 && BYTE2(v55) != 240 && *((unsigned __int8 *)v64 + v12 + 9) != 247)
            {
              if ((char *)v64 + v12 + v10 + 10 <= (char *)__src)
                goto LABEL_65;
LABEL_63:
              v11 = MIDI::PacketizerBase<MIDI::LegacyPacketList>::begin_new_packet((uint64_t)&v62, v7, (char *)__src, v10);
              goto LABEL_72;
            }
            v11 = ((unint64_t)v64 + v12 + 13) & 0xFFFFFFFFFFFFFFFCLL;
          }
          if (v11 + v10 + 10 <= (unint64_t)__src)
          {
            v12 = 0;
            ++v65;
            *(_QWORD *)v11 = v54;
            *(_WORD *)(v11 + 8) = 0;
LABEL_65:
            v21 = (_BYTE *)(v11 + v12 + 10);
            v22 = __src;
            switch((int)v10)
            {
              case 1:
                goto LABEL_69;
              case 2:
                goto LABEL_68;
              case 3:
                goto LABEL_67;
              case 4:
                goto LABEL_66;
              default:
                goto LABEL_70;
            }
          }
          goto LABEL_63;
        }
      }
      v5 += v5[2] + 3;
      ++v4;
    }
    while (v4 < v53[1]);
  }
  return MIDI::PacketizerBase<MIDI::LegacyPacketList>::~PacketizerBase((uint64_t)&v62);
}

void sub_1D4E9FD30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  _Unwind_Resume(exception_object);
}

uint64_t MIDI::PacketizerBase<MIDI::LegacyPacketList>::~PacketizerBase(uint64_t a1)
{
  uint64_t v3;

  if (*(_DWORD *)(a1 + 64))
  {
    v3 = a1 + 64;
    (**(void (***)(uint64_t, uint64_t *))a1)(a1 + 8, &v3);
  }
  *(_DWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 56) = a1 + 68;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1 + 8);
  return a1;
}

uint64_t MIDI::EventList::PacketReader::read(uint64_t *a1, _QWORD *a2, _DWORD *a3)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unsigned int *v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t result;
  unsigned int v10;
  unsigned int v11;

  v3 = a1[1];
  v4 = a1[3];
  if (v4 >= v3)
    return 0;
  v5 = *a1;
  v6 = (unsigned int *)(*a1 + 4 * v4);
  v7 = *v6;
  v8 = v4 + MIDI::UniversalPacket::word_sizes[v7 >> 28];
  if (v8 > v3)
    return 0;
  *a2 = a1[2];
  switch((uint64_t)(v5 + 4 * v8 - (_QWORD)v6) >> 2)
  {
    case 0:
      goto LABEL_9;
    case 1:
      goto LABEL_8;
    case 2:
      goto LABEL_7;
    case 3:
      goto LABEL_6;
    case 4:
      *a3++ = v7;
      v10 = v6[1];
      ++v6;
      LODWORD(v7) = v10;
LABEL_6:
      *a3++ = v7;
      v11 = v6[1];
      ++v6;
      LODWORD(v7) = v11;
LABEL_7:
      *a3++ = v7;
      LODWORD(v7) = v6[1];
LABEL_8:
      *a3 = v7;
LABEL_9:
      a1[3] = v8;
      result = 1;
      break;
    default:
      std::terminate();
      return result;
  }
  return result;
}

uint64_t MIDI::LegacyPacketList::write_UP<MIDI::MIDIPacketList_Deliverer::operator()(MIDI::EventList const*)::{lambda(unsigned long long,MIDI::UniversalPacket const&)#2}::operator() const(unsigned long long,MIDI::UniversalPacket const&)::{lambda(MIDI::UniversalPacket const&)#1}::operator() const(MIDI::UniversalPacket const&)::{lambda(std::span<unsigned char const,18446744073709551615ul>)#1}>(uint64_t result, unsigned int a2, uint64_t a3, uint64_t *a4)
{
  int v6;
  unsigned int v7;
  size_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  size_t v14;
  unsigned int v15;
  int v16;
  size_t v17;
  uint64_t v18;
  unint64_t v19;
  int v20;
  uint64_t v21;
  unsigned __int8 *v22;
  unsigned __int8 *v23;
  uint64_t v24;
  unint64_t v25;
  int v26;
  uint64_t v27;
  unsigned __int8 *p_src;
  char v29;
  char v30;
  _DWORD v31[2];
  unsigned __int8 __src;
  char v33;
  char v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v6 = BYTE2(result);
  v7 = result >> 28;
  if (result >> 28 == 3)
  {
    v14 = WORD1(result) & 0xF;
    if (v14 > 6 || BYTE2(result) > 0x3Fu)
      return result;
    v15 = (result >> 20) + 3;
    v31[0] = bswap32(result);
    v31[1] = bswap32(a2);
    if ((result & 0x200000) != 0)
    {
      v8 = 0;
      if (!(_DWORD)v14)
        goto LABEL_39;
    }
    else
    {
      __src = -16;
      v8 = 1;
      if (!(_DWORD)v14)
      {
LABEL_39:
        if ((v15 & 2) != 0)
          *(&__src + v8++) = -9;
        v24 = *a4;
        v10 = *(_QWORD *)(a3 + 56);
        v25 = a3 + 1088;
        v26 = *(_DWORD *)(a3 + 64);
        if (v26)
        {
          v27 = *(unsigned __int16 *)(v10 + 8);
          if (*(_QWORD *)v10 == v24 && *(unsigned __int8 *)(v27 + v10 + 9) != 247 && __src != 240)
          {
            if (v10 + v8 + v27 + 10 <= v25)
              goto LABEL_54;
            goto LABEL_52;
          }
          v10 = (v10 + v27 + 13) & 0xFFFFFFFFFFFFFFFCLL;
        }
        if (v10 + v8 + 10 <= v25)
        {
          LODWORD(v27) = 0;
          *(_DWORD *)(a3 + 64) = v26 + 1;
          *(_QWORD *)v10 = v24;
          *(_WORD *)(v10 + 8) = 0;
LABEL_54:
          result = v10 + v27 + 10;
          p_src = &__src;
          switch(v8)
          {
            case 0uLL:
              break;
            case 1uLL:
              goto LABEL_64;
            case 2uLL:
              goto LABEL_63;
            case 3uLL:
              goto LABEL_62;
            case 4uLL:
LABEL_61:
              p_src = (unsigned __int8 *)&v33;
              *(_BYTE *)result++ = __src;
LABEL_62:
              v29 = *p_src++;
              *(_BYTE *)result++ = v29;
LABEL_63:
              v30 = *p_src++;
              *(_BYTE *)result++ = v30;
LABEL_64:
              *(_BYTE *)result = *p_src;
              break;
            default:
LABEL_65:
              result = (uint64_t)memmove((void *)result, &__src, v8);
              break;
          }
          *(_WORD *)(v10 + 8) += v8;
          goto LABEL_67;
        }
LABEL_52:
        result = MIDI::PacketizerBase<MIDI::LegacyPacketList>::begin_new_packet(a3, v24, (char *)&__src, v8);
LABEL_58:
        v10 = result;
LABEL_67:
        *(_QWORD *)(a3 + 56) = v10;
        return result;
      }
    }
    memcpy(&__src + v8, (char *)v31 + 2, v14);
    v8 += (v14 - 1) + 1;
    goto LABEL_39;
  }
  if (v7 == 2)
  {
    v16 = result & 0xE00000;
    __src = BYTE2(result);
    v33 = BYTE1(result) & 0x7F;
    if ((result & 0xE00000) == 0xC00000)
      v17 = 2;
    else
      v17 = 3;
    if (v16 != 12582912)
      v34 = result & 0x7F;
    v18 = *a4;
    result = *(_QWORD *)(a3 + 56);
    v19 = a3 + 1088;
    v20 = *(_DWORD *)(a3 + 64);
    if (v20)
    {
      v21 = *(unsigned __int16 *)(result + 8);
      if (*(_QWORD *)result == v18 && v6 != 240 && *(unsigned __int8 *)(v21 + result + 9) != 247)
      {
        if (result + v17 + v21 + 10 <= v19)
          goto LABEL_35;
        goto LABEL_33;
      }
      result = (result + v21 + 13) & 0xFFFFFFFFFFFFFFFCLL;
    }
    if (result + v17 + 10 <= v19)
    {
      LODWORD(v21) = 0;
      *(_DWORD *)(a3 + 64) = v20 + 1;
      *(_QWORD *)result = v18;
      *(_WORD *)(result + 8) = 0;
LABEL_35:
      v22 = (unsigned __int8 *)(result + v21 + 10);
      if (v16 == 12582912)
      {
        v23 = &__src;
      }
      else
      {
        v23 = (unsigned __int8 *)&v33;
        *v22 = __src;
        v22 = (unsigned __int8 *)(result + v21 + 11);
      }
      *v22 = *v23;
      v22[1] = v23[1];
      *(_WORD *)(result + 8) += v17;
      goto LABEL_49;
    }
LABEL_33:
    result = MIDI::PacketizerBase<MIDI::LegacyPacketList>::begin_new_packet(a3, v18, (char *)&__src, v17);
LABEL_49:
    *(_QWORD *)(a3 + 56) = result;
    return result;
  }
  if (v7 == 1 && BYTE2(result) >= 0xF0u && ((0x22B1uLL >> (BYTE2(result) + 16)) & 1) == 0)
  {
    v8 = MIDI::system_message_size::sizes[BYTE2(result) - 240];
    __src = BYTE2(result);
    if (((0xDD40uLL >> (BYTE2(result) + 16)) & 1) == 0)
    {
      v33 = BYTE1(result) & 0x7F;
      if (BYTE2(result) == 242)
        v34 = result & 0x7F;
    }
    v9 = *a4;
    v10 = *(_QWORD *)(a3 + 56);
    v11 = a3 + 1088;
    v12 = *(_DWORD *)(a3 + 64);
    if (v12)
    {
      v13 = *(unsigned __int16 *)(v10 + 8);
      if (*(_QWORD *)v10 == v9 && BYTE2(result) != 240 && *(unsigned __int8 *)(v13 + v10 + 9) != 247)
      {
        if (v10 + v13 + v8 + 10 <= v11)
          goto LABEL_60;
LABEL_57:
        result = MIDI::PacketizerBase<MIDI::LegacyPacketList>::begin_new_packet(a3, v9, (char *)&__src, v8);
        goto LABEL_58;
      }
      v10 = (v10 + v13 + 13) & 0xFFFFFFFFFFFFFFFCLL;
    }
    if (v10 + v8 + 10 <= v11)
    {
      LODWORD(v13) = 0;
      *(_DWORD *)(a3 + 64) = v12 + 1;
      *(_QWORD *)v10 = v9;
      *(_WORD *)(v10 + 8) = 0;
LABEL_60:
      result = v10 + v13 + 10;
      p_src = &__src;
      switch((int)v8)
      {
        case 1:
          goto LABEL_64;
        case 2:
          goto LABEL_63;
        case 3:
          goto LABEL_62;
        case 4:
          goto LABEL_61;
        default:
          goto LABEL_65;
      }
    }
    goto LABEL_57;
  }
  return result;
}

uint64_t MIDI::PacketizerBase<MIDI::LegacyPacketList>::begin_new_packet(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  uint64_t v8;
  char *v9;
  char *v10;
  __int16 v11;
  char v12;
  char v13;
  char v14;
  char *v16;

  if (*(_DWORD *)(a1 + 64)
    && (v16 = (char *)(a1 + 64),
        (**(void (***)(uint64_t, char **))a1)(a1 + 8, &v16),
        *(_DWORD *)(a1 + 64) = 0,
        v8 = a1 + 68,
        a1 + 68 + a4 + 10 <= a1 + 1088))
  {
    *(_DWORD *)(a1 + 64) = 1;
    *(_QWORD *)(a1 + 68) = a2;
    *(_WORD *)(a1 + 76) = 0;
    v10 = (char *)(a1 + 78);
    v11 = 0;
    switch(a4)
    {
      case 0uLL:
        break;
      case 1uLL:
        goto LABEL_8;
      case 2uLL:
        goto LABEL_7;
      case 3uLL:
        goto LABEL_6;
      case 4uLL:
        v12 = *a3++;
        v10 = (char *)(a1 + 79);
        *(_BYTE *)(a1 + 78) = v12;
LABEL_6:
        v13 = *a3++;
        *v10++ = v13;
LABEL_7:
        v14 = *a3++;
        *v10++ = v14;
LABEL_8:
        *v10 = *a3;
        v11 = *(_WORD *)(a1 + 76);
        break;
      default:
        if (a4)
          memmove(v10, a3, a4);
        v11 = 0;
        break;
    }
    *(_WORD *)(a1 + 76) = v11 + a4;
  }
  else
  {
    v9 = (char *)malloc_type_malloc(a4 + 14, 0x5D605258uLL);
    *(_DWORD *)v9 = 1;
    *(_QWORD *)(v9 + 4) = a2;
    *((_WORD *)v9 + 6) = a4;
    memcpy(v9 + 14, a3, a4);
    v16 = v9;
    (**(void (***)(uint64_t, char **))a1)(a1 + 8, &v16);
    free(v9);
    v8 = a1 + 68;
    *(_QWORD *)(a1 + 56) = a1 + 68;
    *(_DWORD *)(a1 + 64) = 0;
  }
  return v8;
}

void sub_1D4EA0410(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

uint64_t XCFObject<__CFString const*>::~XCFObject(uint64_t a1)
{
  const void *v2;

  if (*(_BYTE *)(a1 + 8))
  {
    v2 = *(const void **)a1;
    if (*(_QWORD *)a1)
      CFRelease(v2);
  }
  return a1;
}

void MIDIDriverPlugin::~MIDIDriverPlugin(MIDIDriverPlugin *this)
{
  *(_QWORD *)this = off_1E98B9918;
  XCFObject<__CFString const*>::~XCFObject((uint64_t)this + 48);
  *(_QWORD *)this = off_1E98B9320;
  XCFObject<__CFDictionary const*>::~XCFObject((uint64_t)this + 24);
  BaseOpaqueObject::~BaseOpaqueObject(this);
}

void CFPlugin::~CFPlugin(CFPlugin *this)
{
  const void *v2;

  v2 = (const void *)*((_QWORD *)this + 2);
  if (v2)
    CFRelease(v2);
  if (*(_QWORD *)this)
    CFRelease(*(CFTypeRef *)this);
}

uint64_t applesauce::raii::v1::detail::ScopeGuard<CFPlugin::open(__CFURL const*,__CFUUID const*)::$_0,applesauce::raii::v1::detail::StackExitPolicy>::~ScopeGuard(uint64_t a1)
{
  const void *v2;
  const void *v3;

  v2 = **(const void ***)a1;
  if (v2)
    CFRelease(v2);
  v3 = **(const void ***)(a1 + 8);
  if (v3)
    CFRelease(v3);
  return a1;
}

DIR *findPluginsInDirectory(const char *a1, char **a2)
{
  DIR *result;
  DIR *v5;
  unint64_t v6;
  NSObject *v7;
  size_t v8;
  CFURLRef v9;
  char *d_name;
  size_t v11;
  const char *v12;
  const __CFURL *v13;
  const __CFUUID *v14;
  __CFBundle *v15;
  const __CFArray *FactoriesForPlugInTypeInPlugIn;
  unint64_t v17;
  const void *ValueAtIndex;
  __CFBundle *v19;
  char *v20;
  char *v21;
  const void *v22;
  NSObject *v23;
  unint64_t v24;
  unint64_t v25;
  char *v26;
  NSObject *v27;
  char *v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  char *v33;
  char *v34;
  char *v35;
  __int128 v36;
  uint64_t v37;
  __int128 v38;
  char *v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  NSObject *v44;
  _BYTE v45[24];
  char v46;
  dirent *v47;
  _QWORD v48[2];
  CFArrayRef theArray;
  __CFBundle *v50;
  _BYTE v51[28];
  __int16 v52;
  char *v53;
  dirent buf;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  result = opendir(a1);
  if (result)
  {
    v5 = result;
    gDriverPlugin();
    v6 = 0x1EFEFC000uLL;
    v7 = gDriverPlugin(void)::drvtbl;
    if (os_log_type_enabled((os_log_t)gDriverPlugin(void)::drvtbl, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(buf.d_ino) = 136315650;
      *(__uint64_t *)((char *)&buf.d_ino + 4) = (__uint64_t)"MIDIDriverPlugin_CFPlugin.cpp";
      WORD2(buf.d_seekoff) = 1024;
      *(_DWORD *)((char *)&buf.d_seekoff + 6) = 351;
      buf.d_namlen = 2080;
      *(_QWORD *)&buf.d_type = a1;
      _os_log_impl(&dword_1D4E88000, v7, OS_LOG_TYPE_DEBUG, "%25s:%-5d Scanning directory %s for plugins", (uint8_t *)&buf, 0x1Cu);
    }
    v8 = strlen(a1);
    v9 = CFURLCreateFromFileSystemRepresentation(0, (const UInt8 *)a1, v8, 1u);
    if (v9)
    {
      while (1)
      {
        while (1)
        {
          do
          {
            v47 = 0;
            if (readdir_r(v5, &buf, &v47) || !v47)
            {
              CFRelease(v9);
              return (DIR *)closedir(v5);
            }
            d_name = v47->d_name;
            v11 = strlen(v47->d_name);
            v12 = (char *)&v47->d_seekoff + v11 + 6;
          }
          while (v12 < v47->d_name || strcmp(v12, ".plugin"));
          v13 = (const __CFURL *)MEMORY[0x1D826B594](0, d_name, v11, 0, v9);
          if (v13)
            break;
          gDriverPlugin();
          v27 = *(NSObject **)(v6 + 3104);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)v51 = 136315906;
            *(_QWORD *)&v51[4] = "MIDIDriverPlugin_CFPlugin.cpp";
            *(_WORD *)&v51[12] = 1024;
            *(_DWORD *)&v51[14] = 373;
            *(_WORD *)&v51[18] = 2080;
            *(_QWORD *)&v51[20] = a1;
            v52 = 2080;
            v53 = v47->d_name;
            _os_log_impl(&dword_1D4E88000, v27, OS_LOG_TYPE_INFO, "%25s:%-5d CFURLCreateWithFileSystemPathRelativeToBase failed for '%s/%s'", v51, 0x26u);
          }
        }
        v14 = CFUUIDGetConstantUUIDWithBytes(0, 0xECu, 0xDEu, 0x95u, 0x74u, 0xFu, 0xE4u, 0x11u, 0xD4u, 0xBBu, 0x1Au, 0, 0x50u, 0xE4u, 0xCEu, 0xA5u, 0x26u);
        theArray = 0;
        v50 = 0;
        v48[0] = &theArray;
        v48[1] = &v50;
        v15 = CFPlugInCreate(0, v13);
        v50 = v15;
        if (!v15)
          goto LABEL_14;
        FactoriesForPlugInTypeInPlugIn = CFPlugInFindFactoriesForPlugInTypeInPlugIn(v14, v15);
        theArray = FactoriesForPlugInTypeInPlugIn;
        if (FactoriesForPlugInTypeInPlugIn && CFArrayGetCount(FactoriesForPlugInTypeInPlugIn))
        {
          v17 = v6;
          ValueAtIndex = CFArrayGetValueAtIndex(theArray, 0);
          v19 = v50;
          *(_QWORD *)v51 = v13;
          CFRetain(v13);
          *(_QWORD *)&v51[8] = v19;
          CFRetain(v19);
          *(_QWORD *)&v51[16] = ValueAtIndex;
          CFRetain(ValueAtIndex);
          *(_QWORD *)v45 = v13;
          *(_QWORD *)&v45[8] = v19;
          memset(v51, 0, 24);
          *(_QWORD *)&v45[16] = ValueAtIndex;
          v46 = 1;
          CFPlugin::~CFPlugin((CFPlugin *)v51);
          v6 = v17;
        }
        else
        {
LABEL_14:
          v45[0] = 0;
          v46 = 0;
        }
        applesauce::raii::v1::detail::ScopeGuard<CFPlugin::open(__CFURL const*,__CFUUID const*)::$_0,applesauce::raii::v1::detail::StackExitPolicy>::~ScopeGuard((uint64_t)v48);
        if (v46)
          break;
LABEL_53:
        CFRelease(v13);
      }
      v20 = *a2;
      v21 = a2[1];
      if (*a2 != v21)
      {
        v22 = *(const void **)&v45[16];
        while (!CFEqual(v22, *((CFTypeRef *)v20 + 2)))
        {
          v20 += 24;
          if (v20 == v21)
            goto LABEL_20;
        }
        goto LABEL_51;
      }
LABEL_20:
      gDriverPlugin();
      v23 = *(NSObject **)(v6 + 3104);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)v51 = 136315906;
        *(_QWORD *)&v51[4] = "MIDIDriverPlugin_CFPlugin.cpp";
        *(_WORD *)&v51[12] = 1024;
        *(_DWORD *)&v51[14] = 386;
        *(_WORD *)&v51[18] = 2112;
        *(_QWORD *)&v51[20] = v13;
        v52 = 2112;
        v53 = *(char **)&v45[16];
        _os_log_impl(&dword_1D4E88000, v23, OS_LOG_TYPE_DEBUG, "%25s:%-5d Identified MIDI plugin: %@ (%@)", v51, 0x26u);
      }
      v25 = (unint64_t)a2[1];
      v24 = (unint64_t)a2[2];
      if (v25 < v24)
      {
        *(_QWORD *)v25 = 0;
        *(_QWORD *)(v25 + 8) = 0;
        *(_QWORD *)(v25 + 16) = 0;
        if ((_BYTE *)v25 != v45)
        {
          *(_OWORD *)v25 = *(_OWORD *)v45;
          *(_OWORD *)v45 = 0uLL;
          *(_QWORD *)(v25 + 16) = *(_QWORD *)&v45[16];
          *(_QWORD *)&v45[16] = 0;
        }
        v26 = (char *)(v25 + 24);
        goto LABEL_50;
      }
      v28 = *a2;
      v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v25 - (_QWORD)*a2) >> 3);
      v30 = v29 + 1;
      if (v29 + 1 > 0xAAAAAAAAAAAAAAALL)
        std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
      v31 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - (_QWORD)v28) >> 3);
      if (2 * v31 > v30)
        v30 = 2 * v31;
      if (v31 >= 0x555555555555555)
        v32 = 0xAAAAAAAAAAAAAAALL;
      else
        v32 = v30;
      if (v32)
      {
        if (v32 > 0xAAAAAAAAAAAAAAALL)
          std::__throw_bad_array_new_length[abi:ne180100]();
        v33 = (char *)operator new(24 * v32);
      }
      else
      {
        v33 = 0;
      }
      v34 = &v33[24 * v29];
      *(_QWORD *)v34 = 0;
      *((_QWORD *)v34 + 1) = 0;
      *((_QWORD *)v34 + 2) = 0;
      if (v34 != v45)
      {
        v35 = &v33[24 * v29];
        v36 = *(_OWORD *)v45;
        *(_QWORD *)v45 = 0;
        v37 = *(_QWORD *)&v45[16];
        v38 = *(_OWORD *)(v35 + 8);
        *(_OWORD *)v34 = v36;
        *((_QWORD *)v35 + 2) = v37;
        *(_OWORD *)&v45[8] = v38;
      }
      v39 = &v33[24 * v32];
      v26 = v34 + 24;
      if ((char *)v25 == v28)
      {
        *a2 = v34;
        a2[1] = v26;
        a2[2] = v39;
        if (!v25)
          goto LABEL_50;
      }
      else
      {
        v40 = v34;
        do
        {
          *((_QWORD *)v40 - 3) = 0;
          v40 -= 24;
          *((_QWORD *)v34 - 2) = 0;
          *((_QWORD *)v34 - 1) = 0;
          if (v34 != (char *)v25)
          {
            *((_QWORD *)v34 - 3) = *(_QWORD *)(v25 - 24);
            *(_QWORD *)(v25 - 24) = 0;
            v41 = *((_QWORD *)v34 - 2);
            *((_QWORD *)v34 - 2) = *(_QWORD *)(v25 - 16);
            *(_QWORD *)(v25 - 16) = v41;
            v42 = *((_QWORD *)v34 - 1);
            *((_QWORD *)v34 - 1) = *(_QWORD *)(v25 - 8);
            *(_QWORD *)(v25 - 8) = v42;
          }
          v25 -= 24;
          v34 = v40;
        }
        while ((char *)v25 != v28);
        v43 = *a2;
        v25 = (unint64_t)a2[1];
        *a2 = v40;
        a2[1] = v26;
        a2[2] = v39;
        if ((char *)v25 != v43)
        {
          do
          {
            v25 -= 24;
            CFPlugin::~CFPlugin((CFPlugin *)v25);
          }
          while ((char *)v25 != v43);
          v25 = (unint64_t)v43;
        }
        if (!v25)
          goto LABEL_50;
      }
      operator delete((void *)v25);
LABEL_50:
      v6 = 0x1EFEFC000;
      a2[1] = v26;
LABEL_51:
      if (v46)
        CFPlugin::~CFPlugin((CFPlugin *)v45);
      goto LABEL_53;
    }
    gDriverPlugin();
    v44 = gDriverPlugin(void)::drvtbl;
    if (os_log_type_enabled((os_log_t)gDriverPlugin(void)::drvtbl, OS_LOG_TYPE_INFO))
    {
      LODWORD(buf.d_ino) = 136315650;
      *(__uint64_t *)((char *)&buf.d_ino + 4) = (__uint64_t)"MIDIDriverPlugin_CFPlugin.cpp";
      WORD2(buf.d_seekoff) = 1024;
      *(_DWORD *)((char *)&buf.d_seekoff + 6) = 354;
      buf.d_namlen = 2080;
      *(_QWORD *)&buf.d_type = a1;
      _os_log_impl(&dword_1D4E88000, v44, OS_LOG_TYPE_INFO, "%25s:%-5d CFURLCreateWithFileSystemPath failed for '%s'", (uint8_t *)&buf, 0x1Cu);
    }
    return (DIR *)closedir(v5);
  }
  return result;
}

void sub_1D4EA0C00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, char a19)
{
  if (a16)
    CFPlugin::~CFPlugin((CFPlugin *)&a13);
  _Unwind_Resume(exception_object);
}

void std::vector<CFPlugin>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        CFPlugin::~CFPlugin((CFPlugin *)(v4 - 24));
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void gDriverPlugin(void)
{
  unsigned __int8 v0;

  if ((v0 & 1) == 0)
  {
    {
      gDriverPlugin(void)::drvtbl = (uint64_t)os_log_create("com.apple.coremidi", "drvplug");
    }
  }
}

void driverMap(void)
{
  unsigned __int8 v0;

  if ((v0 & 1) == 0)
  {
    {
      qword_1EFEFCC40 = 0;
      qword_1EFEFCC38 = 0;
      driverMap(void)::sDriverMap = (uint64_t)&qword_1EFEFCC38;
    }
  }
}

MIDIDriverPlugin_CFPlugin *std::unique_ptr<MIDIDriverPlugin_CFPlugin>::reset[abi:ne180100](MIDIDriverPlugin_CFPlugin **a1)
{
  MIDIDriverPlugin_CFPlugin *result;

  result = *a1;
  *a1 = 0;
  if (result)
  {
    MIDIDriverPlugin_CFPlugin::~MIDIDriverPlugin_CFPlugin(result);
    JUMPOUT(0x1D826BA98);
  }
  return result;
}

void std::vector<std::unique_ptr<MIDIDriverPlugin>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  _QWORD *v2;
  _QWORD *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v7 = *--v4;
        v6 = v7;
        *v4 = 0;
        if (v7)
          (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t caulk::inplace_function_detail::vtable<void,MIDI::LegacyPacketList const*>::vtable<MIDIDriverPlugin_CFPlugin::MIDIDriverPlugin_CFPlugin(__CFString const*,__CFString const*,MIDIDriverInterface **,int)::{lambda(MIDIPacketList const*)#1}>(caulk::inplace_function_detail::wrapper<MIDIDriverPlugin_CFPlugin::MIDIDriverPlugin_CFPlugin(__CFString const*,__CFString const*,MIDIDriverInterface **,int)::{lambda(MIDIPacketList const*)#1}>)::{lambda(void *,MIDI::LegacyPacketList const*&&)#1}::__invoke(uint64_t *a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t result;

  v2 = *a1;
  result = *(_QWORD *)(*a1 + 72);
  if (result)
    return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)result + 88))(result, *(unsigned int *)(v2 + 96), *a2);
  return result;
}

_QWORD *caulk::inplace_function_detail::vtable<void,MIDI::LegacyPacketList const*>::vtable<MIDIDriverPlugin_CFPlugin::MIDIDriverPlugin_CFPlugin(__CFString const*,__CFString const*,MIDIDriverInterface **,int)::{lambda(MIDIPacketList const*)#1}>(caulk::inplace_function_detail::wrapper<MIDIDriverPlugin_CFPlugin::MIDIDriverPlugin_CFPlugin(__CFString const*,__CFString const*,MIDIDriverInterface **,int)::{lambda(MIDIPacketList const*)#1}>)::{lambda(void *,void *)#1}::__invoke(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

_QWORD *caulk::inplace_function_detail::vtable<void,MIDI::LegacyPacketList const*>::vtable<MIDIDriverPlugin_CFPlugin::MIDIDriverPlugin_CFPlugin(__CFString const*,__CFString const*,MIDIDriverInterface **,int)::{lambda(MIDIPacketList const*)#1}>(caulk::inplace_function_detail::wrapper<MIDIDriverPlugin_CFPlugin::MIDIDriverPlugin_CFPlugin(__CFString const*,__CFString const*,MIDIDriverInterface **,int)::{lambda(MIDIPacketList const*)#1}>)::{lambda(void *,void *)#2}::__invoke(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

void MIDI::MIDIPacketList_Deliverer::~MIDIPacketList_Deliverer(MIDI::MIDIPacketList_Deliverer *this)
{
  *(_QWORD *)this = &off_1E98B9EC8;
  (*(void (**)(char *))(*((_QWORD *)this + 1) + 24))((char *)this + 16);
}

{
  *(_QWORD *)this = &off_1E98B9EC8;
  (*(void (**)(char *))(*((_QWORD *)this + 1) + 24))((char *)this + 16);
  JUMPOUT(0x1D826BA98);
}

uint64_t MIDI::MIDIPacketList_Deliverer::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return (**(uint64_t (***)(uint64_t, uint64_t *))(a1 + 8))(a1 + 16, &v3);
}

void std::__shared_ptr_emplace<MIDI::MIDIPacketList_Deliverer>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E98BA040;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<MIDI::MIDIPacketList_Deliverer>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E98BA040;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D826BA98);
}

uint64_t std::__shared_ptr_emplace<MIDI::MIDIPacketList_Deliverer>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t driverRefToPlugin(MIDIDriverInterface **a1)
{
  uint64_t v2;
  uint64_t *v3;
  unint64_t v4;
  BOOL v5;
  uint64_t *v6;

  driverMap();
  v2 = qword_1EFEFCC38;
  if (!qword_1EFEFCC38)
    return 0;
  v3 = &qword_1EFEFCC38;
  do
  {
    v4 = *(_QWORD *)(v2 + 32);
    v5 = v4 >= (unint64_t)a1;
    if (v4 >= (unint64_t)a1)
      v6 = (uint64_t *)v2;
    else
      v6 = (uint64_t *)(v2 + 8);
    if (v5)
      v3 = (uint64_t *)v2;
    v2 = *v6;
  }
  while (*v6);
  if (v3 != &qword_1EFEFCC38 && v3[4] <= (unint64_t)a1)
    return v3[5];
  else
    return 0;
}

MIDIPacket *__cdecl MIDIPacketListInit(MIDIPacketList *pktlist)
{
  pktlist->numPackets = 0;
  return pktlist->packet;
}

MIDIPacket *__cdecl MIDIPacketListAdd(MIDIPacketList *pktlist, ByteCount listSize, MIDIPacket *curPacket, MIDITimeStamp time, ByteCount nData, const Byte *data)
{
  __int16 v6;
  MIDIPacket *v7;
  MIDIPacket *v8;
  uint64_t length;
  Byte *v10;
  Byte v11;
  Byte v12;
  Byte v13;

  v6 = nData;
  v7 = curPacket;
  v8 = (MIDIPacket *)((char *)pktlist + listSize);
  if (pktlist->numPackets)
  {
    length = curPacket->length;
    if (curPacket->timeStamp == time && *((unsigned __int8 *)&curPacket->length + length + 1) != 247 && *data != 240)
    {
      if (&curPacket->data[length + nData] > (Byte *)v8)
        return 0;
      goto LABEL_9;
    }
    v7 = (MIDIPacket *)((unint64_t)&curPacket->data[length + 3] & 0xFFFFFFFFFFFFFFFCLL);
  }
  if (&v7->data[nData] > (Byte *)v8)
    return 0;
  LODWORD(length) = 0;
  ++pktlist->numPackets;
  v7->timeStamp = time;
  v7->length = 0;
LABEL_9:
  v10 = &v7->data[length];
  switch(nData)
  {
    case 0uLL:
      break;
    case 1uLL:
      goto LABEL_13;
    case 2uLL:
      goto LABEL_12;
    case 3uLL:
      goto LABEL_11;
    case 4uLL:
      v11 = *data++;
      *v10 = v11;
      v10 = &v7->data[length + 1];
LABEL_11:
      v12 = *data++;
      *v10++ = v12;
LABEL_12:
      v13 = *data++;
      *v10++ = v13;
LABEL_13:
      *v10 = *data;
      break;
    default:
      memmove(v10, data, nData);
      break;
  }
  v7->length += v6;
  return v7;
}

MIDIEventPacket *__cdecl MIDIEventListInit(MIDIEventList *evtlist, MIDIProtocolID protocol)
{
  evtlist->protocol = protocol;
  evtlist->numPackets = 0;
  return evtlist->packet;
}

MIDIEventPacket *__cdecl MIDIEventListAdd(MIDIEventList *evtlist, ByteCount listSize, MIDIEventPacket *curPacket, MIDITimeStamp time, ByteCount wordCount, const UInt32 *words)
{
  MIDIEventPacket *v6;
  int v7;
  MIDIEventPacket *v8;
  UInt32 v9;
  UInt32 numPackets;
  UInt32 v11;
  BOOL v12;
  UInt32 v13;
  UInt32 v14;
  int v15;
  BOOL v16;
  char v17;
  int v18;
  int v19;
  BOOL v20;
  uint64_t v21;
  UInt32 *v22;
  UInt32 v23;
  UInt32 v24;
  UInt32 v25;

  v6 = curPacket;
  if (!wordCount)
    return v6;
  v7 = wordCount;
  v8 = (MIDIEventPacket *)((char *)evtlist + listSize);
  v9 = *words & 0xF0000000;
  numPackets = evtlist->numPackets;
  if (curPacket && numPackets)
  {
    v11 = curPacket->wordCount;
    v12 = v11 >= 2;
    v13 = v11 - 2;
    if (v12 && curPacket->words[0] >> 28 == 3)
    {
      v14 = curPacket->words[v13];
      if (v14 >> 28 == 3)
        v15 = (v14 >> 20) & 0xF;
      else
        v15 = 255;
      if (v15)
        v16 = v15 == 3;
      else
        v16 = 1;
      v17 = v16;
      v18 = 1;
LABEL_20:
      v19 = v9 != 805306368;
      if (curPacket->timeStamp == time)
      {
        v20 = v19 == v18 || (*words & 0xF0E00000) == 805306368;
        if (!v20 && (v17 & 1) == 0)
        {
LABEL_26:
          v21 = curPacket->wordCount;
          if (&curPacket->words[v21 + wordCount] <= (UInt32 *)v8)
            goto LABEL_33;
          return 0;
        }
      }
      goto LABEL_29;
    }
LABEL_19:
    v18 = 0;
    v17 = 0;
    goto LABEL_20;
  }
  if (!numPackets)
    goto LABEL_30;
  if (curPacket)
    goto LABEL_19;
  if (v9 != 805306368)
    goto LABEL_26;
LABEL_29:
  v6 = (MIDIEventPacket *)&curPacket->words[curPacket->wordCount];
LABEL_30:
  if (&v6->words[wordCount] > (UInt32 *)v8)
    return 0;
  LODWORD(v21) = 0;
  evtlist->numPackets = numPackets + 1;
  v6->timeStamp = time;
  v6->wordCount = 0;
LABEL_33:
  v22 = &v6->words[v21];
  switch(wordCount)
  {
    case 1uLL:
      goto LABEL_37;
    case 2uLL:
      goto LABEL_36;
    case 3uLL:
      goto LABEL_35;
    case 4uLL:
      v23 = *words++;
      *v22 = v23;
      v22 = &v6->words[v21 + 1];
LABEL_35:
      v24 = *words++;
      *v22++ = v24;
LABEL_36:
      v25 = *words++;
      *v22++ = v25;
LABEL_37:
      *v22 = *words;
      break;
    default:
      memmove(v22, words, 4 * wordCount);
      break;
  }
  v6->wordCount += v7;
  return v6;
}

void MIDIEventListForEachEvent(const MIDIEventList *evtlist, MIDIEventVisitor visitor, void *visitorContext)
{
  UInt32 numPackets;
  MIDIEventPacket *packet;
  uint64_t wordCount;
  MIDITimeStamp timeStamp;
  UInt32 *words;
  uint64_t v10;
  unint64_t v11;
  unsigned int v12;
  __int16 v13;
  __int16 v14;
  int v15;
  BOOL v16;
  int v17;
  __int16 v18;
  unsigned int v19;
  int v20;
  unsigned int v21;
  unsigned __int8 v22;
  unsigned int v23;
  BOOL v24;
  unsigned __int8 v25;
  int v26;
  int v27;
  BOOL v28;
  unsigned __int8 v29;
  __int16 v30;
  int v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  int v36;
  unsigned int v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  unsigned int v42;
  unsigned int v43;
  unsigned int v44;
  unsigned int v45;
  uint64_t v46;
  uint64_t v47;
  unsigned int v48;
  int v49;
  uint64_t v50;
  int v51;
  unsigned int v52;
  int v53;
  uint64_t v54;
  MIDIEventPacket *v55;
  UInt32 v56;
  __int128 __dst;
  int v58;
  uint64_t v59;
  _BYTE v60[20];
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  numPackets = evtlist->numPackets;
  if (numPackets)
  {
    packet = evtlist->packet;
    while (1)
    {
      wordCount = packet->wordCount;
      if ((_DWORD)wordCount)
        break;
      v54 = 0;
LABEL_79:
      packet = (MIDIEventPacket *)((char *)packet + 4 * v54 + 12);
      if (!--numPackets)
        return;
    }
    v55 = packet;
    v56 = numPackets;
    timeStamp = packet->timeStamp;
    words = packet->words;
    v10 = (uint64_t)&packet->words[wordCount];
    while (1)
    {
      v11 = *words;
      switch(v11 >> 28)
      {
        case 0u:
          v12 = (v11 >> 20) & 0xF;
          v13 = *words;
          if (v12 == 1)
            v14 = *words;
          else
            v14 = 0;
          if (v12 == 1)
          {
            LODWORD(v11) = 1;
            v15 = 0;
          }
          else
          {
            v15 = 255;
          }
          v16 = v12 == 2;
          if (v12 == 2)
            v17 = 0;
          else
            v17 = v15;
          LODWORD(v59) = v17;
          BYTE4(v59) = -1;
          *(_WORD *)((char *)&v59 + 5) = 0;
          HIBYTE(v59) = 0;
          if (v16)
            LODWORD(v11) = 2;
          *(_DWORD *)v60 = v11;
          if (v16)
            v18 = v13;
          else
            v18 = v14;
          *(_WORD *)&v60[4] = v18;
          *(_QWORD *)&v60[6] = 0;
          *(_QWORD *)&v60[12] = 0;
          ((void (*)(void *, MIDITimeStamp, uint64_t *))visitor)(visitorContext, timeStamp, &v59);
          goto LABEL_76;
        case 1u:
          v19 = BYTE3(v11) & 0xF;
          v20 = BYTE2(v11);
          v21 = (v11 >> 8) & 0x7F;
          v22 = ((_BYTE)v11 << 7) | v21;
          v23 = (v11 >> 1) & 0x3F;
          v24 = BYTE2(v11) == 241;
          if (BYTE2(v11) == 241)
          {
            LODWORD(v11) = 241;
            v25 = v21;
          }
          else
          {
            v25 = 0;
          }
          if (v24)
            v26 = 1;
          else
            v26 = 255;
          if (v20 == 242)
          {
            LODWORD(v11) = 242;
            v27 = 1;
          }
          else
          {
            v22 = v25;
            LOWORD(v23) = 0;
            v27 = v26;
          }
          v28 = v20 == 243;
          if (v20 == 243)
          {
            LODWORD(v11) = 243;
            v29 = v21;
          }
          else
          {
            v29 = v22;
          }
          if (v28)
            v30 = 0;
          else
            v30 = v23;
          if (v28)
            v31 = 1;
          else
            v31 = v27;
          LODWORD(v59) = v31;
          BYTE4(v59) = v19;
          *(_WORD *)((char *)&v59 + 5) = 0;
          HIBYTE(v59) = 0;
          *(_DWORD *)v60 = v11;
          *(_WORD *)&v60[4] = v29 | (unsigned __int16)(v30 << 8);
          *(_QWORD *)&v60[6] = 0;
          *(_QWORD *)&v60[12] = 0;
          ((void (*)(void *, MIDITimeStamp, uint64_t *))visitor)(visitorContext, timeStamp, &v59);
          goto LABEL_76;
        case 2u:
          v32 = BYTE3(v11) & 0xF;
          v33 = WORD1(v11) & 0xF;
          switch((v11 >> 20) & 0xF)
          {
            case 8u:
            case 9u:
              v34 = (v11 >> 8) & 0x7F;
              LOWORD(v35) = v11 & 0x7F;
              v36 = 2;
              LODWORD(v11) = (v11 >> 20) & 0xF;
              break;
            case 0xAu:
              v34 = (v11 >> 8) & 0x7F;
              LOWORD(v35) = v11 & 0x7F;
              v36 = 2;
              LODWORD(v11) = 10;
              break;
            case 0xBu:
              v34 = (v11 >> 8) & 0x7F;
              LOWORD(v35) = v11 & 0x7F;
              v36 = 2;
              LODWORD(v11) = 11;
              break;
            case 0xCu:
              LOWORD(v35) = 0;
              v34 = (v11 >> 8) & 0x7F;
              v36 = 2;
              LODWORD(v11) = 12;
              break;
            case 0xDu:
              LOWORD(v35) = 0;
              v34 = (v11 >> 8) & 0x7F;
              v36 = 2;
              LODWORD(v11) = 13;
              break;
            case 0xEu:
              v34 = ((_DWORD)v11 << 7) | (v11 >> 8) & 0x7F;
              v35 = (v11 >> 1) & 0x3F;
              v36 = 2;
              LODWORD(v11) = 14;
              break;
            default:
              LOBYTE(v34) = 0;
              LOWORD(v35) = 0;
              v36 = 255;
              break;
          }
          LODWORD(v59) = v36;
          BYTE4(v59) = v32;
          *(_WORD *)((char *)&v59 + 5) = 0;
          HIBYTE(v59) = 0;
          *(_DWORD *)v60 = v11;
          v60[4] = v33;
          *(_WORD *)&v60[5] = 0;
          v60[7] = 0;
          *(_WORD *)&v60[8] = v34 | (unsigned __int16)((_WORD)v35 << 8);
          *(_QWORD *)&v60[10] = 0;
          *(_WORD *)&v60[18] = 0;
          ((void (*)(void *, MIDITimeStamp, uint64_t *))visitor)(visitorContext, timeStamp, &v59);
          goto LABEL_76;
        case 3u:
          v37 = words[1];
          LODWORD(v59) = 3;
          BYTE4(v59) = BYTE3(v11) & 0xF;
          *(_WORD *)((char *)&v59 + 5) = 0;
          HIBYTE(v59) = 0;
          *(_DWORD *)v60 = (v11 >> 20) & 0xF;
          v60[4] = BYTE2(v11) & 0xF;
          v60[5] = BYTE1(v11) & 0x7F;
          v60[6] = v11 & 0x7F;
          v60[7] = HIBYTE(v37) & 0x7F;
          v60[8] = BYTE2(v37) & 0x7F;
          v60[9] = BYTE1(v37) & 0x7F;
          *(_WORD *)&v60[10] = v37 & 0x7F;
          ((void (*)(void *, MIDITimeStamp, uint64_t *))visitor)(visitorContext, timeStamp, &v59);
          goto LABEL_76;
        case 4u:
          v38 = BYTE3(v11) & 0xF;
          LODWORD(v39) = (v11 >> 20) & 0xF;
          v40 = (v11 >> 16) & 0xF;
          switch((int)v39)
          {
            case 0:
            case 1:
              v41 = 0;
              v42 = 0;
              v43 = (v11 >> 8) & 0x7F;
              goto LABEL_63;
            case 2:
            case 3:
            case 4:
            case 5:
              v41 = 0;
              v42 = 0;
              v43 = (v11 >> 8) & 0x7F;
              LOBYTE(v11) = v11 & 0x7F;
LABEL_63:
              v51 = words[1];
              v52 = v51 & 0xFFFF0000;
              goto LABEL_65;
            case 6:
              v41 = 0;
              v42 = 0;
              v43 = (v11 >> 8) & 0x7F;
              v51 = words[1];
              v52 = v51 & 0xFFFF0000;
              v53 = 4;
              LODWORD(v39) = 6;
              goto LABEL_70;
            case 8:
            case 9:
              v41 = 0;
              v52 = 0;
              v43 = (v11 >> 8) & 0x7F;
              v51 = words[1];
              v42 = v51 & 0xFFFF0000;
LABEL_65:
              v53 = 4;
              break;
            case 10:
              v41 = 0;
              v42 = 0;
              v43 = (v11 >> 8) & 0x7F;
              v51 = words[1];
              v52 = v51 & 0xFFFF0000;
              v53 = 4;
              LODWORD(v39) = 10;
              goto LABEL_70;
            case 11:
              v41 = 0;
              v42 = 0;
              v43 = (v11 >> 8) & 0x7F;
              v51 = words[1];
              v52 = v51 & 0xFFFF0000;
              v53 = 4;
              LODWORD(v39) = 11;
LABEL_70:
              LOBYTE(v11) = 0;
              break;
            case 12:
              v41 = 0;
              v42 = 0;
              v52 = 0;
              v43 = *words;
              LODWORD(v11) = HIBYTE(words[1]) & 0x7F;
              v51 = words[1] & 0x7F | (((words[1] >> 8) & 0x7F) << 7);
              v53 = 4;
              LODWORD(v39) = 12;
              break;
            case 13:
              v41 = 0;
              LOWORD(v51) = 0;
              v52 = 0;
              v43 = words[1];
              LODWORD(v11) = v43 >> 8;
              v42 = v43 & 0xFFFF0000;
              v53 = 4;
              LODWORD(v39) = 13;
              break;
            case 14:
              v41 = 0;
              LOWORD(v51) = 0;
              v52 = 0;
              v43 = words[1];
              LODWORD(v11) = v43 >> 8;
              v42 = v43 & 0xFFFF0000;
              v53 = 4;
              LODWORD(v39) = 14;
              break;
            case 15:
              v41 = 0;
              v42 = 0;
              LOWORD(v51) = 0;
              v52 = 0;
              v43 = (v11 >> 8) & 0x7F;
              v53 = 4;
              LODWORD(v39) = 15;
              break;
            default:
              LOBYTE(v43) = 0;
              LOBYTE(v11) = 0;
              v42 = 0;
              LOWORD(v51) = 0;
              v52 = 0;
              v39 = *(_QWORD *)words;
              v40 = BYTE4(*(_QWORD *)words);
              v41 = *(_QWORD *)words & 0xFFFFFF0000000000;
              v53 = 255;
              break;
          }
          LODWORD(v59) = v53;
          BYTE4(v59) = v38;
          *(_WORD *)((char *)&v59 + 5) = 0;
          HIBYTE(v59) = 0;
          *(_QWORD *)v60 = v41 | (v40 << 32) | v39;
          *(_DWORD *)&v60[8] = v42 | (v11 << 8) | v43;
          *(_DWORD *)&v60[12] = v52 | (unsigned __int16)v51;
          *(_DWORD *)&v60[16] = 0;
          ((void (*)(void *, MIDITimeStamp, uint64_t *))visitor)(visitorContext, timeStamp, &v59);
          goto LABEL_76;
        case 5u:
          v44 = (v11 >> 20) & 0xF;
          *(_QWORD *)((char *)&__dst + 5) = 0;
          *(_QWORD *)&__dst = 0;
          if (v44 >= 4)
          {
            if (v44 - 8 >= 2)
            {
              v44 = *words;
              LOBYTE(v45) = *((_BYTE *)words + 4);
              LOBYTE(v48) = *((_BYTE *)words + 5);
              v50 = *(_QWORD *)((char *)words + 6);
              WORD4(__dst) = *((_WORD *)words + 7);
              *(_QWORD *)&__dst = v50;
              v49 = 255;
              goto LABEL_53;
            }
            v45 = WORD1(v11) & 0xF;
            LOBYTE(v48) = *((_BYTE *)words + 2);
            v46 = *(_QWORD *)((char *)words + 3);
            v47 = *((_QWORD *)words + 1);
          }
          else
          {
            v45 = WORD1(v11) & 0xF;
            v46 = *(_QWORD *)((char *)words + 3);
            v47 = *((_QWORD *)words + 1);
            v48 = v11 >> 8;
          }
          *(_QWORD *)((char *)&__dst + 5) = v47;
          *(_QWORD *)&__dst = v46;
          v49 = 5;
LABEL_53:
          LODWORD(v59) = v49;
          BYTE4(v59) = BYTE3(v11) & 0xF;
          *(_WORD *)((char *)&v59 + 5) = 0;
          HIBYTE(v59) = 0;
          *(_DWORD *)v60 = v44;
          v60[4] = v45;
          v60[5] = v48;
          *(_QWORD *)&v60[6] = __dst;
          *(_QWORD *)&v60[11] = *(_QWORD *)((char *)&__dst + 5);
          v60[19] = 0;
          ((void (*)(void *, MIDITimeStamp, uint64_t *))visitor)(visitorContext, timeStamp, &v59);
LABEL_76:
          words += MIDI::UniversalPacket::word_sizes[(unint64_t)*words >> 28];
          if (words == (UInt32 *)v10)
          {
            packet = v55;
            numPackets = v56;
            v54 = v55->wordCount;
            goto LABEL_79;
          }
          break;
        default:
          __dst = 0uLL;
          v58 = 0;
          if (MIDI::UniversalPacket::word_sizes[(unint64_t)*words >> 28])
            memmove(&__dst, words, 4 * MIDI::UniversalPacket::word_sizes[(unint64_t)*words >> 28]);
          v59 = 0xFF000000FFLL;
          *(_OWORD *)v60 = __dst;
          *(_DWORD *)&v60[16] = v58;
          ((void (*)(void *, MIDITimeStamp, uint64_t *))visitor)(visitorContext, timeStamp, &v59);
          goto LABEL_76;
      }
    }
  }
}

void std::vector<unsigned char>::reserve(unint64_t *a1, size_t __sz)
{
  unint64_t v2;
  char *v5;
  _BYTE *v6;
  char *v7;
  _BYTE *v8;
  char *v9;
  char v10;

  v2 = *a1;
  if (a1[2] - *a1 < __sz)
  {
    if ((__sz & 0x8000000000000000) != 0)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v5 = (char *)a1[1];
    v6 = operator new(__sz);
    v7 = &v5[(_QWORD)v6 - v2];
    v8 = v7;
    if (v5 != (char *)v2)
    {
      v9 = &v5[~v2];
      do
      {
        v10 = *--v5;
        (v9--)[(_QWORD)v6] = v10;
      }
      while (v5 != (char *)v2);
      v8 = v6;
    }
    *a1 = (unint64_t)v8;
    a1[1] = (unint64_t)v7;
    a1[2] = (unint64_t)&v6[__sz];
    if (v2)
      operator delete((void *)v2);
  }
}

void std::vector<unsigned char>::__insert_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(uint64_t a1, char *__dst, char *__src, char *a4, int64_t a5)
{
  uint64_t v9;
  _BYTE *v10;
  char *v11;
  uint64_t v12;
  char *v13;
  unint64_t v14;
  size_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  int64_t v19;
  _BYTE *v20;
  char *v21;
  char *v22;
  _BYTE *v23;
  char *v24;
  char v25;
  char *v26;
  char *v27;
  char *v28;
  char *v29;
  char *v30;

  if (a5 < 1)
    return;
  v10 = *(_BYTE **)(a1 + 8);
  v9 = *(_QWORD *)(a1 + 16);
  if (v9 - (uint64_t)v10 < a5)
  {
    v11 = *(char **)a1;
    v12 = (uint64_t)&v10[a5 - *(_QWORD *)a1];
    if (v12 < 0)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v13 = (char *)(__dst - v11);
    v14 = v9 - (_QWORD)v11;
    if (2 * v14 > v12)
      v12 = 2 * v14;
    if (v14 >= 0x3FFFFFFFFFFFFFFFLL)
      v15 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v15 = v12;
    if (v15)
      v16 = (char *)operator new(v15);
    else
      v16 = 0;
    v26 = &v13[(_QWORD)v16];
    memcpy(&v13[(_QWORD)v16], __src, a5);
    if (v11 == __dst)
    {
      v27 = &v13[(_QWORD)v16];
    }
    else
    {
      do
      {
        v13[(_QWORD)v16 - 1] = v13[(_QWORD)(v11 - 1)];
        --v13;
      }
      while (v13);
      v10 = *(_BYTE **)(a1 + 8);
      v27 = v16;
    }
    v28 = &v26[a5];
    v29 = &v16[v15];
    if (v10 != __dst)
      memmove(v28, __dst, v10 - __dst);
    v30 = *(char **)a1;
    *(_QWORD *)a1 = v27;
    *(_QWORD *)(a1 + 8) = &v28[v10 - __dst];
    *(_QWORD *)(a1 + 16) = v29;
    if (v30)
      operator delete(v30);
    return;
  }
  v17 = v10 - __dst;
  if (v10 - __dst >= a5)
  {
    v18 = &__src[a5];
    v20 = *(_BYTE **)(a1 + 8);
LABEL_17:
    v21 = &__dst[a5];
    v22 = &v20[-a5];
    v23 = v20;
    if (&v20[-a5] < v10)
    {
      v24 = (char *)(&v10[a5] - v20);
      v23 = v20;
      do
      {
        v25 = *v22++;
        *v23++ = v25;
        --v24;
      }
      while (v24);
    }
    *(_QWORD *)(a1 + 8) = v23;
    if (v20 != v21)
      memmove(&__dst[a5], __dst, v20 - v21);
    if (v18 != __src)
      memmove(__dst, __src, v18 - __src);
    return;
  }
  v18 = &__src[v17];
  v19 = a4 - &__src[v17];
  if (a4 != &__src[v17])
    memmove(*(void **)(a1 + 8), &__src[v17], a4 - &__src[v17]);
  v20 = &v10[v19];
  *(_QWORD *)(a1 + 8) = &v10[v19];
  if (v17 >= 1)
    goto LABEL_17;
}

swix::encode_message *swix::encode_message::encode_message(swix::encode_message *this, int a2)
{
  xpc_object_t v4;
  void *v5;
  xpc_object_t v6;

  v4 = xpc_dictionary_create(0, 0, 0);
  if (!v4)
  {
    v4 = xpc_null_create();
    if (!v4)
    {
      v5 = 0;
      goto LABEL_7;
    }
  }
  if (MEMORY[0x1D826C5A8](v4) != MEMORY[0x1E0C812F8])
  {
    v5 = v4;
LABEL_7:
    v4 = xpc_null_create();
    goto LABEL_8;
  }
  xpc_retain(v4);
  v5 = v4;
LABEL_8:
  xpc_release(v5);
  *(_DWORD *)this = a2;
  *((_DWORD *)this + 1) = 0;
  *((_QWORD *)this + 1) = v4;
  v6 = xpc_null_create();
  *((_QWORD *)this + 2) = 0;
  xpc_release(v6);
  xpc_dictionary_set_int64(*((xpc_object_t *)this + 1), "#", *(int *)this);
  return this;
}

void sub_1D4EA1CAC(_Unwind_Exception *a1)
{
  uint64_t v1;

  xpc_release(*(xpc_object_t *)(v1 + 8));
  *(_QWORD *)(v1 + 8) = 0;
  _Unwind_Resume(a1);
}

swix::encode_message *swix::encode_message::encode_message(swix::encode_message *this, xpc_object_t *a2)
{
  xpc_object_t reply;
  xpc_object_t v5;
  xpc_object_t v6;

  reply = xpc_dictionary_create_reply(a2[1]);
  if ((reply || (reply = xpc_null_create()) != 0) && MEMORY[0x1D826C5A8](reply) == MEMORY[0x1E0C812F8])
  {
    xpc_retain(reply);
    v5 = reply;
  }
  else
  {
    v5 = xpc_null_create();
  }
  *(_QWORD *)this = -*(_DWORD *)a2;
  *((_QWORD *)this + 1) = v5;
  v6 = xpc_null_create();
  *((_QWORD *)this + 2) = 0;
  xpc_release(v6);
  xpc_release(reply);
  xpc_dictionary_set_int64(*((xpc_object_t *)this + 1), "#", *(int *)this);
  return this;
}

void sub_1D4EA1D8C(_Unwind_Exception *a1)
{
  uint64_t v1;

  xpc_release(*(xpc_object_t *)(v1 + 8));
  *(_QWORD *)(v1 + 8) = 0;
  _Unwind_Resume(a1);
}

xpc_object_t swix::encode_message::xpc_message(swix::encode_message *this, uint64_t a2)
{
  void *v4;
  xpc_object_t result;

  if (*(_DWORD *)(a2 + 4))
    xpc_dictionary_set_uint64(*(xpc_object_t *)(a2 + 8), ".optionals", *(_QWORD *)(a2 + 16));
  v4 = *(void **)(a2 + 8);
  *(_QWORD *)this = v4;
  if (v4)
    return xpc_retain(v4);
  result = xpc_null_create();
  *(_QWORD *)this = result;
  return result;
}

int64_t swix::coder<int>::decode(void *a1, const char *a2)
{
  int64_t result;
  _QWORD *exception;

  result = xpc_dictionary_get_int64(a1, a2);
  if (result != (int)result)
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = &off_1E98B9E40;
  }
  return result;
}

void gsl::narrowing_error::~narrowing_error(std::exception *this)
{
  std::exception::~exception(this);
  JUMPOUT(0x1D826BA98);
}

uint64_t swix::decode_message::decode_message(uint64_t a1, xpc_object_t object, uint64_t a3)
{
  xpc_object_t v5;
  xpc_object_t v6;
  int v7;
  NSObject *v9;
  NSObject *v10;
  std::string v11;

  if (object)
  {
    v5 = object;
    xpc_retain(object);
  }
  else
  {
    v5 = xpc_null_create();
  }
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = v5;
  v6 = xpc_null_create();
  *(_QWORD *)(a1 + 16) = 0;
  xpc_release(v6);
  *(_QWORD *)(a1 + 24) = a3;
  if (MEMORY[0x1D826C5A8](*(_QWORD *)(a1 + 8)) != MEMORY[0x1E0C812F8])
  {
    v9 = *(NSObject **)(a1 + 24);
    std::string::basic_string[abi:ne180100]<0>(&v11, "!(is_valid())");
    swix::decode_message::throw_error(v9, -304, &v11);
  }
  v7 = swix::coder<int>::decode(*(void **)(a1 + 8), "#");
  *(_DWORD *)a1 = v7;
  if (!v7)
  {
    v10 = *(NSObject **)(a1 + 24);
    std::string::basic_string[abi:ne180100]<0>(&v11, "!(mMessageID != 0)");
    swix::decode_message::throw_error(v10, -303, &v11);
  }
  return a1;
}

void sub_1D4EA1F60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  if (a15 < 0)
    operator delete(__p);
  xpc_release(*(xpc_object_t *)(v15 + 8));
  *(_QWORD *)(v15 + 8) = 0;
  _Unwind_Resume(a1);
}

void CADeprecated::CAMutex::~CAMutex(CADeprecated::CAMutex *this)
{
  *(_QWORD *)this = &off_1E98B9D98;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 24));
}

{
  *(_QWORD *)this = &off_1E98B9D98;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 24));
  JUMPOUT(0x1D826BA98);
}

uint64_t CADeprecated::CAMutex::Try(CADeprecated::CAMutex *this, BOOL *a2)
{
  _opaque_pthread_t *v4;
  _opaque_pthread_t *v5;
  BOOL v6;
  int v7;
  uint64_t result;
  int v9;
  _DWORD *exception;
  _BYTE v11[5];
  uint8_t buf[4];
  int v13;
  __int16 v14;
  _BYTE *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  *a2 = 0;
  v4 = pthread_self();
  v5 = (_opaque_pthread_t *)atomic_load((unint64_t *)this + 2);
  if (pthread_equal(v4, v5))
  {
    v6 = 0;
  }
  else
  {
    v7 = pthread_mutex_trylock((pthread_mutex_t *)((char *)this + 24));
    if (v7 == 16)
    {
      v6 = 0;
      result = 0;
      goto LABEL_7;
    }
    if (v7)
    {
      v11[0] = HIBYTE(v7);
      v11[1] = BYTE2(v7);
      v11[2] = BYTE1(v7);
      v9 = v7;
      v11[3] = v7;
      v11[4] = 0;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109378;
        v13 = v9;
        v14 = 2080;
        v15 = v11;
        _os_log_error_impl(&dword_1D4E88000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, " CAMutex::Try: call to pthread_mutex_trylock failed, Error: %d (%s)", buf, 0x12u);
      }
      exception = __cxa_allocate_exception(0x10uLL);
      *(_QWORD *)exception = &off_1E98B9410;
      exception[2] = v9;
    }
    atomic_store((unint64_t)v4, (unint64_t *)this + 2);
    v6 = 1;
  }
  result = 1;
LABEL_7:
  *a2 = v6;
  return result;
}

BOOL CADeprecated::CAMutex::IsFree(CADeprecated::CAMutex *this)
{
  unint64_t v1;

  v1 = atomic_load((unint64_t *)this + 2);
  return v1 == 0;
}

BOOL CADeprecated::CAMutex::IsOwnedByCurrentThread(CADeprecated::CAMutex *this)
{
  _opaque_pthread_t *v2;
  _opaque_pthread_t *v3;

  v2 = pthread_self();
  v3 = (_opaque_pthread_t *)atomic_load((unint64_t *)this + 2);
  return pthread_equal(v2, v3) != 0;
}

CADeprecated::CAMutex *CADeprecated::CAMutex::CAMutex(CADeprecated::CAMutex *this, const char *a2)
{
  int v3;
  int v5;
  _DWORD *exception;
  uint8_t v7[16];

  *(_QWORD *)this = &off_1E98B9D98;
  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 2) = 0;
  v3 = pthread_mutex_init((pthread_mutex_t *)((char *)this + 24), 0);
  if (v3)
  {
    v5 = v3;
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v7 = 0;
      _os_log_error_impl(&dword_1D4E88000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, " CAMutex::CAMutex: Could not init the mutex", v7, 2u);
    }
    exception = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)exception = &off_1E98B9410;
    exception[2] = v5;
  }
  return this;
}

void _InitMIDIProperties(void)
{
  if ((_InitMIDIProperties(void)::inited & 1) == 0)
  {
    _InitMIDIProperties(void)::inited = 1;
    kMIDIPropertyName = CFSTR("name");
    kMIDIPropertyManufacturer = CFSTR("manufacturer");
    kMIDIPropertyModel = CFSTR("model");
    kMIDIPropertyUniqueID = CFSTR("uniqueID");
    kMIDIPropertyDeviceID = CFSTR("deviceID");
    kMIDIPropertyReceiveChannels = CFSTR("receiveChannels");
    kMIDIPropertyMaxSysExSpeed = CFSTR("maxSysExSpeed");
    kMIDIPropertyAdvanceScheduleTimeMuSec = CFSTR("scheduleAheadMuSec");
    kMIDIPropertyDriverOwner = CFSTR("driver");
    kMIDIPropertyIsEmbeddedEntity = CFSTR("embedded");
    kMIDIPropertyConnectionUniqueID = CFSTR("connUniqueID");
    kMIDIPropertyOffline = CFSTR("offline");
    kMIDIPropertyPrivate = CFSTR("private");
    kMIDIPropertyIsBroadcast = CFSTR("broadcast");
    kMIDIPropertyNameConfiguration = CFSTR("nameConfiguration");
    kMIDIPropertyNameConfigurationDictionary = CFSTR("nameConfigurationDictionary");
    kMIDIPropertyImage = CFSTR("image");
    kMIDIPropertyTransmitChannels = CFSTR("transmitChannels");
    kMIDIPropertyDriverVersion = CFSTR("driverVersion");
    kMIDIPropertySupportsGeneralMIDI = CFSTR("supports General MIDI");
    kMIDIPropertySupportsMMC = CFSTR("supports MMC");
    kMIDIPropertyCanRoute = CFSTR("can route");
    kMIDIPropertyReceivesClock = CFSTR("receives clock");
    kMIDIPropertyReceivesMTC = CFSTR("receives MTC");
    kMIDIPropertyReceivesNotes = CFSTR("receives notes");
    kMIDIPropertyReceivesProgramChanges = CFSTR("receives program changes");
    kMIDIPropertyReceivesBankSelectMSB = CFSTR("receives bank select MSB");
    kMIDIPropertyReceivesBankSelectLSB = CFSTR("receives bank select LSB");
    kMIDIPropertyTransmitsClock = CFSTR("transmits clock");
    kMIDIPropertyTransmitsMTC = CFSTR("transmits MTC");
    kMIDIPropertyTransmitsNotes = CFSTR("transmits notes");
    kMIDIPropertyTransmitsProgramChanges = CFSTR("transmits program changes");
    kMIDIPropertyTransmitsBankSelectMSB = CFSTR("transmits bank select MSB");
    kMIDIPropertyTransmitsBankSelectLSB = CFSTR("transmits bank select LSB");
    kMIDIPropertyPanDisruptsStereo = CFSTR("pan disrupts stereo");
    kMIDIPropertyIsSampler = CFSTR("is sampler");
    kMIDIPropertyIsDrumMachine = CFSTR("is drum machine");
    kMIDIPropertyIsMixer = CFSTR("is mixer");
    kMIDIPropertyIsEffectUnit = CFSTR("is effect unit");
    kMIDIPropertyMaxReceiveChannels = CFSTR("max receive channels");
    kMIDIPropertyMaxTransmitChannels = CFSTR("max transmit channels");
    kMIDIPropertySingleRealtimeEntity = CFSTR("single realtime entity");
    kMIDIPropertyDriverDeviceEditorApp = CFSTR("editorApp");
    kMIDIPropertySupportsShowControl = CFSTR("supports MSC");
    kMIDIPropertyDisplayName = CFSTR("displayName");
    kMIDIPropertyProtocolID = CFSTR("protocol");
    kMIDIPropertyUMPActiveGroupBitmap = CFSTR("active group bitmap");
    kMIDIPropertyUMPCanTransmitGroupless = CFSTR("ump endpoint");
    kMIDIPropertyAssociatedEndpoint = (uint64_t)CFSTR("associated endpoint");
  }
}

void sub_1D4EA26F4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1D4EA27E8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1D4EA2ADC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1D4EA2B80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1D4EA2C88(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

uint64_t std::__function::__value_func<void ()(midi::sysex7 const&)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;

  v3 = (_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(_QWORD *)(a1 + 24) = v4;
  }
  else
  {
    v3 = (_QWORD *)(a1 + 24);
  }
  *v3 = 0;
  return a1;
}

void _ZNSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E14_NS_9allocatorISG_EEFvS8_EED0Ev()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *_ZNKSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E14_NS_9allocatorISG_EEFvS8_EE7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E98B7650;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E14_NS_9allocatorISG_EEFvS8_EE7__cloneEPNS0_6__baseISJ_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E98B7650;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E14_NS_9allocatorISG_EEFvS8_EEclES8_(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  char v5;

  v2 = *(_QWORD *)(a1 + 8);
  v5 = 15;
  v3 = *(_QWORD *)(v2 + 24);
  if (!v3)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)v3 + 48))(v3, &v5, a2);
}

void _ZNSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E13_NS_9allocatorISG_EEFvS8_EED0Ev()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *_ZNKSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E13_NS_9allocatorISG_EEFvS8_EE7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E98B7608;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E13_NS_9allocatorISG_EEFvS8_EE7__cloneEPNS0_6__baseISJ_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E98B7608;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E13_NS_9allocatorISG_EEFvS8_EEclES8_(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  char v5;

  v2 = *(_QWORD *)(a1 + 8);
  v5 = 14;
  v3 = *(_QWORD *)(v2 + 24);
  if (!v3)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)v3 + 48))(v3, &v5, a2);
}

void _ZNSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E12_NS_9allocatorISG_EEFvS8_EED0Ev()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *_ZNKSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E12_NS_9allocatorISG_EEFvS8_EE7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E98B75C0;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E12_NS_9allocatorISG_EEFvS8_EE7__cloneEPNS0_6__baseISJ_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E98B75C0;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E12_NS_9allocatorISG_EEFvS8_EEclES8_(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  char v5;

  v2 = *(_QWORD *)(a1 + 8);
  v5 = 13;
  v3 = *(_QWORD *)(v2 + 24);
  if (!v3)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)v3 + 48))(v3, &v5, a2);
}

void _ZNSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E11_NS_9allocatorISG_EEFvS8_EED0Ev()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *_ZNKSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E11_NS_9allocatorISG_EEFvS8_EE7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E98B7578;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E11_NS_9allocatorISG_EEFvS8_EE7__cloneEPNS0_6__baseISJ_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E98B7578;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E11_NS_9allocatorISG_EEFvS8_EEclES8_(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  char v5;

  v2 = *(_QWORD *)(a1 + 8);
  v5 = 12;
  v3 = *(_QWORD *)(v2 + 24);
  if (!v3)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)v3 + 48))(v3, &v5, a2);
}

void _ZNSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E10_NS_9allocatorISG_EEFvS8_EED0Ev()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *_ZNKSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E10_NS_9allocatorISG_EEFvS8_EE7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E98B7530;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E10_NS_9allocatorISG_EEFvS8_EE7__cloneEPNS0_6__baseISJ_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E98B7530;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E10_NS_9allocatorISG_EEFvS8_EEclES8_(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  char v5;

  v2 = *(_QWORD *)(a1 + 8);
  v5 = 11;
  v3 = *(_QWORD *)(v2 + 24);
  if (!v3)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)v3 + 48))(v3, &v5, a2);
}

void _ZNSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E9_NS_9allocatorISG_EEFvS8_EED0Ev()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *_ZNKSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E9_NS_9allocatorISG_EEFvS8_EE7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E98B78D8;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E9_NS_9allocatorISG_EEFvS8_EE7__cloneEPNS0_6__baseISJ_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E98B78D8;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E9_NS_9allocatorISG_EEFvS8_EEclES8_(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  char v5;

  v2 = *(_QWORD *)(a1 + 8);
  v5 = 10;
  v3 = *(_QWORD *)(v2 + 24);
  if (!v3)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)v3 + 48))(v3, &v5, a2);
}

void _ZNSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E8_NS_9allocatorISG_EEFvS8_EED0Ev()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *_ZNKSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E8_NS_9allocatorISG_EEFvS8_EE7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E98B7890;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E8_NS_9allocatorISG_EEFvS8_EE7__cloneEPNS0_6__baseISJ_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E98B7890;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E8_NS_9allocatorISG_EEFvS8_EEclES8_(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  char v5;

  v2 = *(_QWORD *)(a1 + 8);
  v5 = 9;
  v3 = *(_QWORD *)(v2 + 24);
  if (!v3)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)v3 + 48))(v3, &v5, a2);
}

void _ZNSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E7_NS_9allocatorISG_EEFvS8_EED0Ev()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *_ZNKSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E7_NS_9allocatorISG_EEFvS8_EE7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E98B7848;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E7_NS_9allocatorISG_EEFvS8_EE7__cloneEPNS0_6__baseISJ_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E98B7848;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E7_NS_9allocatorISG_EEFvS8_EEclES8_(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  char v5;

  v2 = *(_QWORD *)(a1 + 8);
  v5 = 8;
  v3 = *(_QWORD *)(v2 + 24);
  if (!v3)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)v3 + 48))(v3, &v5, a2);
}

void _ZNSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E6_NS_9allocatorISG_EEFvS8_EED0Ev()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *_ZNKSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E6_NS_9allocatorISG_EEFvS8_EE7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E98B7800;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E6_NS_9allocatorISG_EEFvS8_EE7__cloneEPNS0_6__baseISJ_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E98B7800;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E6_NS_9allocatorISG_EEFvS8_EEclES8_(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  char v5;

  v2 = *(_QWORD *)(a1 + 8);
  v5 = 7;
  v3 = *(_QWORD *)(v2 + 24);
  if (!v3)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)v3 + 48))(v3, &v5, a2);
}

void _ZNSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E5_NS_9allocatorISG_EEFvS8_EED0Ev()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *_ZNKSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E5_NS_9allocatorISG_EEFvS8_EE7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E98B77B8;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E5_NS_9allocatorISG_EEFvS8_EE7__cloneEPNS0_6__baseISJ_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E98B77B8;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E5_NS_9allocatorISG_EEFvS8_EEclES8_(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  char v5;

  v2 = *(_QWORD *)(a1 + 8);
  v5 = 6;
  v3 = *(_QWORD *)(v2 + 24);
  if (!v3)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)v3 + 48))(v3, &v5, a2);
}

void _ZNSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E4_NS_9allocatorISG_EEFvS8_EED0Ev()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *_ZNKSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E4_NS_9allocatorISG_EEFvS8_EE7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E98B7770;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E4_NS_9allocatorISG_EEFvS8_EE7__cloneEPNS0_6__baseISJ_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E98B7770;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E4_NS_9allocatorISG_EEFvS8_EEclES8_(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  char v5;

  v2 = *(_QWORD *)(a1 + 8);
  v5 = 5;
  v3 = *(_QWORD *)(v2 + 24);
  if (!v3)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)v3 + 48))(v3, &v5, a2);
}

void _ZNSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E3_NS_9allocatorISG_EEFvS8_EED0Ev()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *_ZNKSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E3_NS_9allocatorISG_EEFvS8_EE7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E98B7728;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E3_NS_9allocatorISG_EEFvS8_EE7__cloneEPNS0_6__baseISJ_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E98B7728;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E3_NS_9allocatorISG_EEFvS8_EEclES8_(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  char v5;

  v2 = *(_QWORD *)(a1 + 8);
  v5 = 4;
  v3 = *(_QWORD *)(v2 + 24);
  if (!v3)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)v3 + 48))(v3, &v5, a2);
}

void _ZNSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E2_NS_9allocatorISG_EEFvS8_EED0Ev()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *_ZNKSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E2_NS_9allocatorISG_EEFvS8_EE7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E98B76E0;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E2_NS_9allocatorISG_EEFvS8_EE7__cloneEPNS0_6__baseISJ_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E98B76E0;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E2_NS_9allocatorISG_EEFvS8_EEclES8_(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  char v5;

  v2 = *(_QWORD *)(a1 + 8);
  v5 = 3;
  v3 = *(_QWORD *)(v2 + 24);
  if (!v3)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)v3 + 48))(v3, &v5, a2);
}

void _ZNSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E1_NS_9allocatorISG_EEFvS8_EED0Ev()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *_ZNKSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E1_NS_9allocatorISG_EEFvS8_EE7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E98B7698;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E1_NS_9allocatorISG_EEFvS8_EE7__cloneEPNS0_6__baseISJ_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E98B7698;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E1_NS_9allocatorISG_EEFvS8_EEclES8_(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  char v5;

  v2 = *(_QWORD *)(a1 + 8);
  v5 = 2;
  v3 = *(_QWORD *)(v2 + 24);
  if (!v3)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)v3 + 48))(v3, &v5, a2);
}

void _ZNSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E0_NS_9allocatorISG_EEFvS8_EED0Ev()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *_ZNKSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E0_NS_9allocatorISG_EEFvS8_EE7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E98B74E8;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E0_NS_9allocatorISG_EEFvS8_EE7__cloneEPNS0_6__baseISJ_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E98B74E8;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E0_NS_9allocatorISG_EEFvS8_EEclES8_(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  char v5;

  v2 = *(_QWORD *)(a1 + 8);
  v5 = 1;
  v3 = *(_QWORD *)(v2 + 24);
  if (!v3)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)v3 + 48))(v3, &v5, a2);
}

void _ZNSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E_NS_9allocatorISG_EEFvS8_EED0Ev()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *_ZNKSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E_NS_9allocatorISG_EEFvS8_EE7__cloneEv(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E98B7920;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E_NS_9allocatorISG_EEFvS8_EE7__cloneEPNS0_6__baseISJ_EE(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E98B7920;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZZN6MIDICI14SysexCollectorC1ENS_8functionIFvhRKN4midi6sysex7EEEEENK3__0clIJLm0ELm1ELm2ELm3ELm4ELm5ELm6ELm7ELm8ELm9ELm10ELm11ELm12ELm13ELm14ELm15EEEEDaNS_16integer_sequenceImJXspT_EEEEEUlS8_E_NS_9allocatorISG_EEFvS8_EEclES8_(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  char v5;

  v2 = *(_QWORD *)(a1 + 8);
  v5 = 0;
  v3 = *(_QWORD *)(v2 + 24);
  if (!v3)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(*(_QWORD *)v3 + 48))(v3, &v5, a2);
}

const void *retainC(const __CFAllocator *a1, const void *a2)
{
  return a2;
}

CFStringRef copyDescriptionC(const void *a1)
{
  return CFStringCreateWithFormat(0, 0, CFSTR("<%p>"), a1);
}

void sub_1D4EA3984(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1D4EA39C0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1D4EA3CB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12)
{
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

void sub_1D4EA4148(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21,void *a22)
{
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;

  _Unwind_Resume(a1);
}

void sub_1D4EA4468(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void gSysexSender(void)
{
  unsigned __int8 v0;

  if ((v0 & 1) == 0)
  {
    {
      gSysexSender(void)::ssxsnd = (uint64_t)os_log_create("com.apple.coremidi", "ssxsnd");
    }
  }
}

OSStatus MIDISendSysex(MIDISysexSendRequest *request)
{
  OSStatus result;
  NSObject *v3;
  CADeprecated::Task *v4;
  const char *v5;
  unsigned int v6;
  unsigned int v7;
  BOOL v8;
  BOOL v9;
  const char *v10;
  NSObject *v11;
  int v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  _BYTE v20[40];
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  result = -50;
  if (!request || (gAborting & 1) != 0)
    return result;
  request->reserved[0] = 0;
  gSysexSender();
  v3 = gSysexSender(void)::ssxsnd;
  if (os_log_type_enabled((os_log_t)gSysexSender(void)::ssxsnd, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)v20 = 136315650;
    *(_QWORD *)&v20[4] = "SysexSender.cpp";
    *(_WORD *)&v20[12] = 1024;
    *(_DWORD *)&v20[14] = 268;
    *(_WORD *)&v20[18] = 2048;
    *(_QWORD *)&v20[20] = request;
    _os_log_impl(&dword_1D4E88000, v3, OS_LOG_TYPE_DEBUG, "%25s:%-5d [?] SendSysex(req: %p)", v20, 0x1Cu);
  }
  std::mutex::lock(&gCreateDisposeLock);
  v4 = (CADeprecated::Task *)SysexSender<MIDISysexSendRequest,false>::sInstance;
  if (!SysexSender<MIDISysexSendRequest,false>::sInstance)
  {
    v4 = (CADeprecated::Task *)operator new();
    CADeprecated::Task::Task(v4, v5, v6, v7, v8, v9, v10);
    *(_QWORD *)v4 = &off_1E98B7EA8;
    *((_QWORD *)v4 + 38) = (char *)v4 + 304;
    *((_QWORD *)v4 + 39) = (char *)v4 + 304;
    *((_QWORD *)v4 + 40) = 0;
    *((_QWORD *)v4 + 41) = 0xC3500000000;
    CADeprecated::CAPThread::Start((uint64_t)v4);
    SysexSender<MIDISysexSendRequest,false>::sInstance = (uint64_t)v4;
  }
  std::mutex::unlock(&gCreateDisposeLock);
  std::mutex::lock(&gCreateDisposeLock);
  if (gClientState)
    goto LABEL_8;
  std::mutex::lock(&stru_1EFEFC9E0);
  *(_QWORD *)v20 = MEMORY[0x1E0C809B0];
  *(_QWORD *)&v20[8] = 0x40000000;
  *(_QWORD *)&v20[16] = __MIDIClientCreate_block_invoke;
  *(_QWORD *)&v20[24] = &__block_descriptor_tmp_2629;
  *(_QWORD *)&v20[32] = 0;
  v21 = 0;
  if (!MIDIClientCreateWithBlockInternal(&stru_1E98BB0B0, &gClientState, v20, 0))
  {
    gSysexSender();
    v19 = gSysexSender(void)::ssxsnd;
    if (os_log_type_enabled((os_log_t)gSysexSender(void)::ssxsnd, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)v20 = 136315906;
      *(_QWORD *)&v20[4] = "SysexSender.cpp";
      *(_WORD *)&v20[12] = 1024;
      *(_DWORD *)&v20[14] = 70;
      *(_WORD *)&v20[18] = 2048;
      *(_QWORD *)&v20[20] = v4;
      *(_WORD *)&v20[28] = 1024;
      *(_DWORD *)&v20[30] = gClientState;
      _os_log_impl(&dword_1D4E88000, v19, OS_LOG_TYPE_DEBUG, "%25s:%-5d [?] SysExSender(%p)::PrepareOutputPort() - created client %d", v20, 0x22u);
    }
    std::mutex::unlock(&stru_1EFEFC9E0);
LABEL_8:
    if (!dword_1EFEFC9DC)
    {
      MIDIOutputPortCreate(gClientState, &stru_1E98BB0B0, (MIDIPortRef *)&dword_1EFEFC9DC);
      gSysexSender();
      v11 = gSysexSender(void)::ssxsnd;
      if (os_log_type_enabled((os_log_t)gSysexSender(void)::ssxsnd, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)v20 = 136315906;
        *(_QWORD *)&v20[4] = "SysexSender.cpp";
        *(_WORD *)&v20[12] = 1024;
        *(_DWORD *)&v20[14] = 74;
        *(_WORD *)&v20[18] = 2048;
        *(_QWORD *)&v20[20] = v4;
        *(_WORD *)&v20[28] = 1024;
        *(_DWORD *)&v20[30] = dword_1EFEFC9DC;
        _os_log_impl(&dword_1D4E88000, v11, OS_LOG_TYPE_DEBUG, "%25s:%-5d [?] SysExSender(%p)::PrepareOutputPort() - created output port %d", v20, 0x22u);
      }
    }
    goto LABEL_13;
  }
  std::mutex::unlock(&stru_1EFEFC9E0);
LABEL_13:
  v12 = (*(uint64_t (**)(_QWORD *))(*((_QWORD *)v4 + 18) + 16))((_QWORD *)v4 + 18);
  v13 = *((_QWORD *)v4 + 40);
  v14 = operator new(0x18uLL);
  v14[1] = (char *)v4 + 304;
  v14[2] = request;
  v15 = *((_QWORD *)v4 + 38);
  *v14 = v15;
  *(_QWORD *)(v15 + 8) = v14;
  *((_QWORD *)v4 + 38) = v14;
  *((_QWORD *)v4 + 40) = v13 + 1;
  gSysexSender();
  v16 = gSysexSender(void)::ssxsnd;
  if (os_log_type_enabled((os_log_t)gSysexSender(void)::ssxsnd, OS_LOG_TYPE_DEBUG))
  {
    v17 = *((_QWORD *)v4 + 40);
    *(_DWORD *)v20 = 136316162;
    *(_QWORD *)&v20[4] = "SysexSender.cpp";
    *(_WORD *)&v20[12] = 1024;
    *(_DWORD *)&v20[14] = 117;
    *(_WORD *)&v20[18] = 2048;
    *(_QWORD *)&v20[20] = v4;
    *(_WORD *)&v20[28] = 2048;
    *(_QWORD *)&v20[30] = request;
    *(_WORD *)&v20[38] = 1024;
    LODWORD(v21) = v17;
    _os_log_impl(&dword_1D4E88000, v16, OS_LOG_TYPE_DEBUG, "%25s:%-5d [?] SysExSender(%p)::AddRequest(%p) - mQueue now contains %d items", v20, 0x2Cu);
  }
  if (v12)
    (*(void (**)(_QWORD *))(*((_QWORD *)v4 + 18) + 24))((_QWORD *)v4 + 18);
  if (!v13)
  {
    v18 = mach_absolute_time();
    CADeprecated::Task::WakeUpAt(v4, v18);
  }
  std::mutex::unlock(&gCreateDisposeLock);
  return 0;
}

void sub_1D4EA49C4(_Unwind_Exception *a1)
{
  std::mutex::unlock(&stru_1EFEFC9E0);
  std::mutex::unlock(&gCreateDisposeLock);
  _Unwind_Resume(a1);
}

_QWORD *std::__list_imp<MIDISysexSendRequest *>::clear(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;

  if (result[2])
  {
    v1 = result;
    result = (_QWORD *)result[1];
    v2 = *v1;
    v3 = *result;
    *(_QWORD *)(v3 + 8) = *(_QWORD *)(*v1 + 8);
    **(_QWORD **)(v2 + 8) = v3;
    v1[2] = 0;
    if (result != v1)
    {
      do
      {
        v4 = (_QWORD *)result[1];
        operator delete(result);
        result = v4;
      }
      while (v4 != v1);
    }
  }
  return result;
}

void SysexSender<MIDISysexSendRequest,false>::~SysexSender(_QWORD *a1)
{
  SysexSender<MIDISysexSendRequest,false>::~SysexSender(a1);
  JUMPOUT(0x1D826BA98);
}

void SysexSender<MIDISysexSendRequest,false>::RunTask(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  _BOOL4 v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  NSObject *v10;
  const char *v11;
  int v12;
  const char *v13;
  size_t v14;
  NSObject *v15;
  MIDIEndpointRef v16;
  int v17;
  MIDIObjectRef v18;
  signed int numPackets;
  uint64_t v20;
  unint64_t Length;
  const UInt8 *BytePtr;
  unsigned int *v23;
  unsigned int v24;
  MIDIUniqueID v25;
  OSStatus IntegerProperty;
  int v27;
  uint64_t v28;
  MIDIObjectType outObjectType[2];
  uint8_t v30[4];
  const char *v31;
  __int16 v32;
  int v33;
  __int16 v34;
  uint64_t v35;
  __int16 v36;
  uint64_t v37;
  __int16 v38;
  int v39;
  __int16 v40;
  MIDIEndpointRef v41;
  __int16 v42;
  int v43;
  MIDIPacketList buf;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 320);
  gSysexSender();
  v5 = gSysexSender(void)::ssxsnd;
  v6 = os_log_type_enabled((os_log_t)gSysexSender(void)::ssxsnd, OS_LOG_TYPE_DEBUG);
  if (v4)
  {
    if (v6)
    {
      v7 = *(_QWORD *)(a1 + 320);
      buf.numPackets = 136316162;
      buf.packet[0].timeStamp = (MIDITimeStamp)"SysexSender.cpp";
      buf.packet[0].length = 1024;
      *(_DWORD *)buf.packet[0].data = 143;
      *(_WORD *)&buf.packet[0].data[4] = 2048;
      *(_QWORD *)&buf.packet[0].data[6] = a1;
      *(_WORD *)&buf.packet[0].data[14] = 2048;
      *(_QWORD *)&buf.packet[0].data[16] = a2;
      *(_WORD *)&buf.packet[0].data[24] = 1024;
      *(_DWORD *)&buf.packet[0].data[26] = v7;
      _os_log_impl(&dword_1D4E88000, v5, OS_LOG_TYPE_DEBUG, "%25s:%-5d [?] SysExSender(%p)::RunTask(%llu) - mQueue starting with %d items", (uint8_t *)&buf, 0x2Cu);
    }
    v28 = a2;
    while (1)
    {
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 312) + 16);
      if (!*(_BYTE *)(v8 + 20))
      {
        v9 = *(_DWORD *)(v8 + 16);
        if (v9)
          break;
      }
      gSysexSender();
      v10 = gSysexSender(void)::ssxsnd;
      if (os_log_type_enabled((os_log_t)gSysexSender(void)::ssxsnd, OS_LOG_TYPE_DEBUG))
      {
        v11 = "true";
        if (!*(_BYTE *)(v8 + 20))
          v11 = "false";
        v12 = *(_DWORD *)(v8 + 16);
        buf.numPackets = 136316162;
        buf.packet[0].timeStamp = (MIDITimeStamp)"SysexSender.cpp";
        buf.packet[0].length = 1024;
        *(_DWORD *)buf.packet[0].data = 153;
        *(_WORD *)&buf.packet[0].data[4] = 2048;
        *(_QWORD *)&buf.packet[0].data[6] = v8;
        *(_WORD *)&buf.packet[0].data[14] = 2080;
        *(_QWORD *)&buf.packet[0].data[16] = v11;
        *(_WORD *)&buf.packet[0].data[24] = 1024;
        *(_DWORD *)&buf.packet[0].data[26] = v12;
        _os_log_impl(&dword_1D4E88000, v10, OS_LOG_TYPE_DEBUG, "%25s:%-5d     req %p: complete = %s, toSend = %d", (uint8_t *)&buf, 0x2Cu);
      }
      SysexSender<MIDISysexSendRequest,false>::currentRequestComplete((_QWORD *)a1, v8);
      if (!*(_QWORD *)(a1 + 320))
      {
        gSysexSender();
        v5 = gSysexSender(void)::ssxsnd;
        if (!os_log_type_enabled((os_log_t)gSysexSender(void)::ssxsnd, OS_LOG_TYPE_DEBUG))
          return;
        buf.numPackets = 136315906;
        buf.packet[0].timeStamp = (MIDITimeStamp)"SysexSender.cpp";
        buf.packet[0].length = 1024;
        *(_DWORD *)buf.packet[0].data = 157;
        *(_WORD *)&buf.packet[0].data[4] = 2048;
        *(_QWORD *)&buf.packet[0].data[6] = a1;
        *(_WORD *)&buf.packet[0].data[14] = 2048;
        *(_QWORD *)&buf.packet[0].data[16] = a2;
        v13 = "%25s:%-5d [?] SysExSender(%p)::RunTask(%llu) - queue is now empty; done";
LABEL_16:
        _os_log_impl(&dword_1D4E88000, v5, OS_LOG_TYPE_DEBUG, v13, (uint8_t *)&buf, 0x26u);
        return;
      }
    }
    buf.numPackets = 1;
    memset(buf.packet, 0, sizeof(buf.packet));
    if (v9 >= 0x100)
      v14 = 256;
    else
      v14 = v9;
    buf.packet[0].length = v14;
    memcpy(buf.packet[0].data, *(const void **)(v8 + 8), v14);
    std::mutex::lock(&stru_1EFEFC9E0);
    MIDISend(dword_1EFEFC9DC, *(_DWORD *)v8, &buf);
    *(_QWORD *)(v8 + 8) += v14;
    *(_DWORD *)(v8 + 16) -= v14;
    gSysexSender();
    v15 = gSysexSender(void)::ssxsnd;
    if (os_log_type_enabled((os_log_t)gSysexSender(void)::ssxsnd, OS_LOG_TYPE_DEBUG))
    {
      v16 = *(_DWORD *)v8;
      v17 = *(_DWORD *)(v8 + 16);
      *(_DWORD *)v30 = 136316674;
      v31 = "SysexSender.cpp";
      v32 = 1024;
      v33 = 176;
      v34 = 2048;
      v35 = a1;
      v36 = 2048;
      v37 = v28;
      v38 = 1024;
      v39 = v14;
      v40 = 1024;
      v41 = v16;
      v42 = 1024;
      v43 = v17;
      _os_log_impl(&dword_1D4E88000, v15, OS_LOG_TYPE_DEBUG, "%25s:%-5d [?] SysExSender(%p)::RunTask(%llu) - sent %d bytes to destination %d (%d remain)", v30, 0x38u);
    }
    std::mutex::unlock(&stru_1EFEFC9E0);
    v18 = *(_DWORD *)v8;
    if (*(_DWORD *)v8 == *(_DWORD *)(a1 + 328))
    {
      numPackets = *(_DWORD *)(a1 + 332);
      if (numPackets)
      {
LABEL_25:
        v20 = mach_absolute_time();
        CADeprecated::Task::WakeUpAt((CADeprecated::Task *)a1, v20 + 3 * (1000000000 * (unint64_t)v14 / numPackets) / 0x7D);
        return;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 328) = v18;
      buf.numPackets = 0;
      if (MIDIObjectGetIntegerProperty(v18, kMIDIPropertyMaxSysExSpeed, (SInt32 *)&buf))
        numPackets = 3125;
      else
        numPackets = buf.numPackets;
      *(_QWORD *)&buf.numPackets = 0;
      if (!MIDIObjectGetDataProperty(*(_DWORD *)v8, kMIDIPropertyConnectionUniqueID, (CFDataRef *)&buf))
      {
        Length = CFDataGetLength(*(CFDataRef *)&buf.numPackets);
        BytePtr = CFDataGetBytePtr(*(CFDataRef *)&buf.numPackets);
        if ((int)(Length >> 2) >= 1)
        {
          v23 = (unsigned int *)BytePtr;
          v24 = (Length >> 2) + 1;
          do
          {
            v25 = bswap32(*v23);
            *(_QWORD *)outObjectType = 0;
            if (!MIDIObjectFindByUniqueID(v25, (MIDIObjectRef *)&outObjectType[1], outObjectType))
            {
              *(_DWORD *)v30 = 0;
              IntegerProperty = MIDIObjectGetIntegerProperty(outObjectType[1], kMIDIPropertyMaxSysExSpeed, (SInt32 *)v30);
              v27 = *(_DWORD *)v30;
              if (IntegerProperty)
                v27 = 3125;
              if (v27 < numPackets)
                numPackets = v27;
            }
            ++v23;
            --v24;
          }
          while (v24 > 1);
        }
        CFRelease(*(CFTypeRef *)&buf.numPackets);
      }
      *(_DWORD *)(a1 + 332) = numPackets;
      if (numPackets)
        goto LABEL_25;
    }
    numPackets = 3125;
    *(_DWORD *)(a1 + 332) = 3125;
    goto LABEL_25;
  }
  if (v6)
  {
    buf.numPackets = 136315906;
    buf.packet[0].timeStamp = (MIDITimeStamp)"SysexSender.cpp";
    buf.packet[0].length = 1024;
    *(_DWORD *)buf.packet[0].data = 140;
    *(_WORD *)&buf.packet[0].data[4] = 2048;
    *(_QWORD *)&buf.packet[0].data[6] = a1;
    *(_WORD *)&buf.packet[0].data[14] = 2048;
    *(_QWORD *)&buf.packet[0].data[16] = a2;
    v13 = "%25s:%-5d [?] SysExSender(%p)::RunTask(%llu) - nothing to do; returning";
    goto LABEL_16;
  }
}

void sub_1D4EA5058(_Unwind_Exception *a1)
{
  std::mutex::unlock(&stru_1EFEFC9E0);
  _Unwind_Resume(a1);
}

void SysexSender<MIDISysexSendRequest,false>::currentRequestComplete(_QWORD *a1, uint64_t a2)
{
  void (*v4)(uint64_t);
  int v5;
  uint64_t *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  int v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  _QWORD *v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  *(_BYTE *)(a2 + 20) = 1;
  if (!*(_BYTE *)(a2 + 21))
  {
    v4 = *(void (**)(uint64_t))(a2 + 24);
    if (v4)
      v4(a2);
  }
  v5 = (*(uint64_t (**)(_QWORD *))(a1[18] + 16))(a1 + 18);
  v6 = (uint64_t *)a1[39];
  v7 = *v6;
  *(_QWORD *)(v7 + 8) = v6[1];
  *(_QWORD *)v6[1] = v7;
  --a1[40];
  operator delete(v6);
  gSysexSender();
  v8 = gSysexSender(void)::ssxsnd;
  if (os_log_type_enabled((os_log_t)gSysexSender(void)::ssxsnd, OS_LOG_TYPE_DEBUG))
  {
    v9 = a1[40];
    v10 = 136316162;
    v11 = "SysexSender.cpp";
    v12 = 1024;
    v13 = 105;
    v14 = 2048;
    v15 = a1;
    v16 = 2048;
    v17 = a2;
    v18 = 1024;
    v19 = v9;
    _os_log_impl(&dword_1D4E88000, v8, OS_LOG_TYPE_DEBUG, "%25s:%-5d [?] SysExSender(%p)::currentRequestComplete(%p) - mQueue now contains %d items", (uint8_t *)&v10, 0x2Cu);
  }
  if (v5)
    (*(void (**)(_QWORD *))(a1[18] + 24))(a1 + 18);
}

void sub_1D4EA51D4(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

_QWORD *SysexSender<MIDISysexSendRequest,false>::~SysexSender(_QWORD *a1)
{
  NSObject *v2;
  int v4;
  const char *v5;
  __int16 v6;
  int v7;
  __int16 v8;
  _QWORD *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  *a1 = &off_1E98B7EA8;
  gSysexSender();
  v2 = gSysexSender(void)::ssxsnd;
  if (os_log_type_enabled((os_log_t)gSysexSender(void)::ssxsnd, OS_LOG_TYPE_DEBUG))
  {
    v4 = 136315650;
    v5 = "SysexSender.cpp";
    v6 = 1024;
    v7 = 42;
    v8 = 2048;
    v9 = a1;
    _os_log_impl(&dword_1D4E88000, v2, OS_LOG_TYPE_DEBUG, "%25s:%-5d [?] SysExSender(%p) dtor", (uint8_t *)&v4, 0x1Cu);
  }
  while (a1[40])
    SysexSender<MIDISysexSendRequest,false>::currentRequestComplete(a1, *(_QWORD *)(a1[39] + 16));
  std::__list_imp<MIDISysexSendRequest *>::clear(a1 + 38);
  *a1 = off_1E98B9CE8;
  CADeprecated::CAGuard::~CAGuard((CADeprecated::CAGuard *)(a1 + 18));
  return a1;
}

void sub_1D4EA52EC(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

OSStatus MIDISendUMPSysex(MIDISysexSendRequestUMP *umpRequest)
{
  OSStatus result;
  CADeprecated::Task *v3;
  const char *v4;
  unsigned int v5;
  unsigned int v6;
  BOOL v7;
  BOOL v8;
  const char *v9;
  NSObject *v10;
  int v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  _BYTE v19[40];
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  result = -50;
  if (!umpRequest || (gAborting & 1) != 0)
    return result;
  std::mutex::lock(&gCreateDisposeLockUMP);
  v3 = (CADeprecated::Task *)SysexSender<MIDISysexSendRequestUMP,false>::sInstance;
  if (!SysexSender<MIDISysexSendRequestUMP,false>::sInstance)
  {
    v3 = (CADeprecated::Task *)operator new();
    CADeprecated::Task::Task(v3, v4, v5, v6, v7, v8, v9);
    *(_QWORD *)v3 = &off_1E98B7EE8;
    *((_QWORD *)v3 + 38) = (char *)v3 + 304;
    *((_QWORD *)v3 + 39) = (char *)v3 + 304;
    *((_QWORD *)v3 + 40) = 0;
    *((_QWORD *)v3 + 41) = 0xC3500000000;
    CADeprecated::CAPThread::Start((uint64_t)v3);
    SysexSender<MIDISysexSendRequestUMP,false>::sInstance = (uint64_t)v3;
  }
  std::mutex::unlock(&gCreateDisposeLockUMP);
  std::mutex::lock(&gCreateDisposeLockUMP);
  if (gClientState)
    goto LABEL_6;
  std::mutex::lock(&stru_1EFEFC9E0);
  *(_QWORD *)v19 = MEMORY[0x1E0C809B0];
  *(_QWORD *)&v19[8] = 0x40000000;
  *(_QWORD *)&v19[16] = __MIDIClientCreate_block_invoke;
  *(_QWORD *)&v19[24] = &__block_descriptor_tmp_2629;
  *(_QWORD *)&v19[32] = 0;
  v20 = 0;
  if (!MIDIClientCreateWithBlockInternal(&stru_1E98BB0B0, &gClientState, v19, 0))
  {
    gSysexSender();
    v18 = gSysexSender(void)::ssxsnd;
    if (os_log_type_enabled((os_log_t)gSysexSender(void)::ssxsnd, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)v19 = 136315906;
      *(_QWORD *)&v19[4] = "SysexSender.cpp";
      *(_WORD *)&v19[12] = 1024;
      *(_DWORD *)&v19[14] = 70;
      *(_WORD *)&v19[18] = 2048;
      *(_QWORD *)&v19[20] = v3;
      *(_WORD *)&v19[28] = 1024;
      *(_DWORD *)&v19[30] = gClientState;
      _os_log_impl(&dword_1D4E88000, v18, OS_LOG_TYPE_DEBUG, "%25s:%-5d [?] SysExSender(%p)::PrepareOutputPort() - created client %d", v19, 0x22u);
    }
    std::mutex::unlock(&stru_1EFEFC9E0);
LABEL_6:
    if (!dword_1EFEFC9DC)
    {
      MIDIOutputPortCreate(gClientState, &stru_1E98BB0B0, (MIDIPortRef *)&dword_1EFEFC9DC);
      gSysexSender();
      v10 = gSysexSender(void)::ssxsnd;
      if (os_log_type_enabled((os_log_t)gSysexSender(void)::ssxsnd, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)v19 = 136315906;
        *(_QWORD *)&v19[4] = "SysexSender.cpp";
        *(_WORD *)&v19[12] = 1024;
        *(_DWORD *)&v19[14] = 74;
        *(_WORD *)&v19[18] = 2048;
        *(_QWORD *)&v19[20] = v3;
        *(_WORD *)&v19[28] = 1024;
        *(_DWORD *)&v19[30] = dword_1EFEFC9DC;
        _os_log_impl(&dword_1D4E88000, v10, OS_LOG_TYPE_DEBUG, "%25s:%-5d [?] SysExSender(%p)::PrepareOutputPort() - created output port %d", v19, 0x22u);
      }
    }
    goto LABEL_11;
  }
  std::mutex::unlock(&stru_1EFEFC9E0);
LABEL_11:
  v11 = (*(uint64_t (**)(_QWORD *))(*((_QWORD *)v3 + 18) + 16))((_QWORD *)v3 + 18);
  v12 = *((_QWORD *)v3 + 40);
  v13 = operator new(0x18uLL);
  v13[1] = (char *)v3 + 304;
  v13[2] = umpRequest;
  v14 = *((_QWORD *)v3 + 38);
  *v13 = v14;
  *(_QWORD *)(v14 + 8) = v13;
  *((_QWORD *)v3 + 38) = v13;
  *((_QWORD *)v3 + 40) = v12 + 1;
  gSysexSender();
  v15 = gSysexSender(void)::ssxsnd;
  if (os_log_type_enabled((os_log_t)gSysexSender(void)::ssxsnd, OS_LOG_TYPE_DEBUG))
  {
    v16 = *((_QWORD *)v3 + 40);
    *(_DWORD *)v19 = 136316162;
    *(_QWORD *)&v19[4] = "SysexSender.cpp";
    *(_WORD *)&v19[12] = 1024;
    *(_DWORD *)&v19[14] = 117;
    *(_WORD *)&v19[18] = 2048;
    *(_QWORD *)&v19[20] = v3;
    *(_WORD *)&v19[28] = 2048;
    *(_QWORD *)&v19[30] = umpRequest;
    *(_WORD *)&v19[38] = 1024;
    LODWORD(v20) = v16;
    _os_log_impl(&dword_1D4E88000, v15, OS_LOG_TYPE_DEBUG, "%25s:%-5d [?] SysExSender(%p)::AddRequest(%p) - mQueue now contains %d items", v19, 0x2Cu);
  }
  if (v11)
    (*(void (**)(_QWORD *))(*((_QWORD *)v3 + 18) + 24))((_QWORD *)v3 + 18);
  if (!v12)
  {
    v17 = mach_absolute_time();
    CADeprecated::Task::WakeUpAt(v3, v17);
  }
  std::mutex::unlock(&gCreateDisposeLockUMP);
  return 0;
}

void sub_1D4EA5694(_Unwind_Exception *a1)
{
  std::mutex::unlock(&stru_1EFEFC9E0);
  std::mutex::unlock(&gCreateDisposeLockUMP);
  _Unwind_Resume(a1);
}

void SysexSender<MIDISysexSendRequestUMP,false>::~SysexSender(_QWORD *a1)
{
  SysexSender<MIDISysexSendRequestUMP,false>::~SysexSender(a1);
  JUMPOUT(0x1D826BA98);
}

void SysexSender<MIDISysexSendRequestUMP,false>::RunTask(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  _BOOL4 v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  NSObject *v10;
  const char *v11;
  UInt32 v12;
  const char *v13;
  uint64_t v14;
  NSObject *v15;
  MIDIEndpointRef v16;
  int v17;
  MIDIObjectRef v18;
  MIDIProtocolID protocol;
  uint64_t v20;
  unint64_t Length;
  const UInt8 *BytePtr;
  unsigned int *v23;
  unsigned int v24;
  MIDIUniqueID v25;
  OSStatus IntegerProperty;
  int v27;
  uint64_t v28;
  MIDIObjectType outObjectType[2];
  uint8_t v30[4];
  const char *v31;
  __int16 v32;
  int v33;
  __int16 v34;
  uint64_t v35;
  __int16 v36;
  uint64_t v37;
  __int16 v38;
  int v39;
  __int16 v40;
  MIDIEndpointRef v41;
  __int16 v42;
  int v43;
  MIDIEventList buf;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 320);
  gSysexSender();
  v5 = gSysexSender(void)::ssxsnd;
  v6 = os_log_type_enabled((os_log_t)gSysexSender(void)::ssxsnd, OS_LOG_TYPE_DEBUG);
  if (v4)
  {
    if (v6)
    {
      v7 = *(_QWORD *)(a1 + 320);
      buf.protocol = 136316162;
      *(_QWORD *)&buf.numPackets = "SysexSender.cpp";
      WORD2(buf.packet[0].timeStamp) = 1024;
      *(_DWORD *)((char *)&buf.packet[0].timeStamp + 6) = 143;
      HIWORD(buf.packet[0].wordCount) = 2048;
      *(_QWORD *)buf.packet[0].words = a1;
      LOWORD(buf.packet[0].words[2]) = 2048;
      *(_QWORD *)((char *)&buf.packet[0].words[2] + 2) = a2;
      HIWORD(buf.packet[0].words[4]) = 1024;
      buf.packet[0].words[5] = v7;
      _os_log_impl(&dword_1D4E88000, v5, OS_LOG_TYPE_DEBUG, "%25s:%-5d [?] SysExSender(%p)::RunTask(%llu) - mQueue starting with %d items", (uint8_t *)&buf, 0x2Cu);
    }
    v28 = a2;
    while (1)
    {
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 312) + 16);
      if (!*(_BYTE *)(v8 + 20))
      {
        v9 = *(_DWORD *)(v8 + 16);
        if (v9)
          break;
      }
      gSysexSender();
      v10 = gSysexSender(void)::ssxsnd;
      if (os_log_type_enabled((os_log_t)gSysexSender(void)::ssxsnd, OS_LOG_TYPE_DEBUG))
      {
        v11 = "true";
        if (!*(_BYTE *)(v8 + 20))
          v11 = "false";
        v12 = *(_DWORD *)(v8 + 16);
        buf.protocol = 136316162;
        *(_QWORD *)&buf.numPackets = "SysexSender.cpp";
        WORD2(buf.packet[0].timeStamp) = 1024;
        *(_DWORD *)((char *)&buf.packet[0].timeStamp + 6) = 153;
        HIWORD(buf.packet[0].wordCount) = 2048;
        *(_QWORD *)buf.packet[0].words = v8;
        LOWORD(buf.packet[0].words[2]) = 2080;
        *(_QWORD *)((char *)&buf.packet[0].words[2] + 2) = v11;
        HIWORD(buf.packet[0].words[4]) = 1024;
        buf.packet[0].words[5] = v12;
        _os_log_impl(&dword_1D4E88000, v10, OS_LOG_TYPE_DEBUG, "%25s:%-5d     req %p: complete = %s, toSend = %d", (uint8_t *)&buf, 0x2Cu);
      }
      SysexSender<MIDISysexSendRequestUMP,false>::currentRequestComplete((_QWORD *)a1, v8);
      if (!*(_QWORD *)(a1 + 320))
      {
        gSysexSender();
        v5 = gSysexSender(void)::ssxsnd;
        if (!os_log_type_enabled((os_log_t)gSysexSender(void)::ssxsnd, OS_LOG_TYPE_DEBUG))
          return;
        buf.protocol = 136315906;
        *(_QWORD *)&buf.numPackets = "SysexSender.cpp";
        WORD2(buf.packet[0].timeStamp) = 1024;
        *(_DWORD *)((char *)&buf.packet[0].timeStamp + 6) = 157;
        HIWORD(buf.packet[0].wordCount) = 2048;
        *(_QWORD *)buf.packet[0].words = a1;
        LOWORD(buf.packet[0].words[2]) = 2048;
        *(_QWORD *)((char *)&buf.packet[0].words[2] + 2) = a2;
        v13 = "%25s:%-5d [?] SysExSender(%p)::RunTask(%llu) - queue is now empty; done";
LABEL_16:
        _os_log_impl(&dword_1D4E88000, v5, OS_LOG_TYPE_DEBUG, v13, (uint8_t *)&buf, 0x26u);
        return;
      }
    }
    memset(buf.packet[0].words, 0, sizeof(buf.packet[0].words));
    *(_QWORD *)&buf.protocol = 0x100000002;
    buf.packet[0].timeStamp = 0;
    if (v9 >= 0x40)
      v14 = 64;
    else
      v14 = v9;
    buf.packet[0].wordCount = v14;
    memmove(buf.packet[0].words, *(const void **)(v8 + 8), 4 * v14);
    std::mutex::lock(&stru_1EFEFC9E0);
    MIDISendEventList(dword_1EFEFC9DC, *(_DWORD *)v8, &buf);
    *(_QWORD *)(v8 + 8) += 4 * v14;
    *(_DWORD *)(v8 + 16) -= v14;
    gSysexSender();
    v15 = gSysexSender(void)::ssxsnd;
    if (os_log_type_enabled((os_log_t)gSysexSender(void)::ssxsnd, OS_LOG_TYPE_DEBUG))
    {
      v16 = *(_DWORD *)v8;
      v17 = *(_DWORD *)(v8 + 16);
      *(_DWORD *)v30 = 136316674;
      v31 = "SysexSender.cpp";
      v32 = 1024;
      v33 = 191;
      v34 = 2048;
      v35 = a1;
      v36 = 2048;
      v37 = v28;
      v38 = 1024;
      v39 = v14;
      v40 = 1024;
      v41 = v16;
      v42 = 1024;
      v43 = v17;
      _os_log_impl(&dword_1D4E88000, v15, OS_LOG_TYPE_DEBUG, "%25s:%-5d [?] SysExSender(%p)::RunTask(%llu) - sent %d words to destination %d (%d remain)", v30, 0x38u);
    }
    std::mutex::unlock(&stru_1EFEFC9E0);
    v18 = *(_DWORD *)v8;
    if (*(_DWORD *)v8 == *(_DWORD *)(a1 + 328))
    {
      protocol = *(_DWORD *)(a1 + 332);
      if (protocol)
      {
LABEL_25:
        v20 = mach_absolute_time();
        CADeprecated::Task::WakeUpAt((CADeprecated::Task *)a1, v20 + 3 * (1000000000 * (unint64_t)(4 * v14) / (int)protocol) / 0x7D);
        return;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 328) = v18;
      buf.protocol = 0;
      if (MIDIObjectGetIntegerProperty(v18, kMIDIPropertyMaxSysExSpeed, (SInt32 *)&buf))
        protocol = 3125;
      else
        protocol = buf.protocol;
      *(_QWORD *)&buf.protocol = 0;
      if (!MIDIObjectGetDataProperty(*(_DWORD *)v8, kMIDIPropertyConnectionUniqueID, (CFDataRef *)&buf))
      {
        Length = CFDataGetLength(*(CFDataRef *)&buf.protocol);
        BytePtr = CFDataGetBytePtr(*(CFDataRef *)&buf.protocol);
        if ((int)(Length >> 2) >= 1)
        {
          v23 = (unsigned int *)BytePtr;
          v24 = (Length >> 2) + 1;
          do
          {
            v25 = bswap32(*v23);
            *(_QWORD *)outObjectType = 0;
            if (!MIDIObjectFindByUniqueID(v25, (MIDIObjectRef *)&outObjectType[1], outObjectType))
            {
              *(_DWORD *)v30 = 0;
              IntegerProperty = MIDIObjectGetIntegerProperty(outObjectType[1], kMIDIPropertyMaxSysExSpeed, (SInt32 *)v30);
              v27 = *(_DWORD *)v30;
              if (IntegerProperty)
                v27 = 3125;
              if (v27 < protocol)
                protocol = v27;
            }
            ++v23;
            --v24;
          }
          while (v24 > 1);
        }
        CFRelease(*(CFTypeRef *)&buf.protocol);
      }
      *(_DWORD *)(a1 + 332) = protocol;
      if (protocol)
        goto LABEL_25;
    }
    protocol = 3125;
    *(_DWORD *)(a1 + 332) = 3125;
    goto LABEL_25;
  }
  if (v6)
  {
    buf.protocol = 136315906;
    *(_QWORD *)&buf.numPackets = "SysexSender.cpp";
    WORD2(buf.packet[0].timeStamp) = 1024;
    *(_DWORD *)((char *)&buf.packet[0].timeStamp + 6) = 140;
    HIWORD(buf.packet[0].wordCount) = 2048;
    *(_QWORD *)buf.packet[0].words = a1;
    LOWORD(buf.packet[0].words[2]) = 2048;
    *(_QWORD *)((char *)&buf.packet[0].words[2] + 2) = a2;
    v13 = "%25s:%-5d [?] SysExSender(%p)::RunTask(%llu) - nothing to do; returning";
    goto LABEL_16;
  }
}

void sub_1D4EA5CC4(_Unwind_Exception *a1)
{
  std::mutex::unlock(&stru_1EFEFC9E0);
  _Unwind_Resume(a1);
}

void SysexSender<MIDISysexSendRequestUMP,false>::currentRequestComplete(_QWORD *a1, uint64_t a2)
{
  void (*v4)(uint64_t);
  int v5;
  uint64_t *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  int v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  _QWORD *v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  *(_BYTE *)(a2 + 20) = 1;
  v4 = *(void (**)(uint64_t))(a2 + 24);
  if (v4)
    v4(a2);
  v5 = (*(uint64_t (**)(_QWORD *))(a1[18] + 16))(a1 + 18);
  v6 = (uint64_t *)a1[39];
  v7 = *v6;
  *(_QWORD *)(v7 + 8) = v6[1];
  *(_QWORD *)v6[1] = v7;
  --a1[40];
  operator delete(v6);
  gSysexSender();
  v8 = gSysexSender(void)::ssxsnd;
  if (os_log_type_enabled((os_log_t)gSysexSender(void)::ssxsnd, OS_LOG_TYPE_DEBUG))
  {
    v9 = a1[40];
    v10 = 136316162;
    v11 = "SysexSender.cpp";
    v12 = 1024;
    v13 = 105;
    v14 = 2048;
    v15 = a1;
    v16 = 2048;
    v17 = a2;
    v18 = 1024;
    v19 = v9;
    _os_log_impl(&dword_1D4E88000, v8, OS_LOG_TYPE_DEBUG, "%25s:%-5d [?] SysExSender(%p)::currentRequestComplete(%p) - mQueue now contains %d items", (uint8_t *)&v10, 0x2Cu);
  }
  if (v5)
    (*(void (**)(_QWORD *))(a1[18] + 24))(a1 + 18);
}

void sub_1D4EA5E38(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

_QWORD *SysexSender<MIDISysexSendRequestUMP,false>::~SysexSender(_QWORD *a1)
{
  NSObject *v2;
  int v4;
  const char *v5;
  __int16 v6;
  int v7;
  __int16 v8;
  _QWORD *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  *a1 = &off_1E98B7EE8;
  gSysexSender();
  v2 = gSysexSender(void)::ssxsnd;
  if (os_log_type_enabled((os_log_t)gSysexSender(void)::ssxsnd, OS_LOG_TYPE_DEBUG))
  {
    v4 = 136315650;
    v5 = "SysexSender.cpp";
    v6 = 1024;
    v7 = 42;
    v8 = 2048;
    v9 = a1;
    _os_log_impl(&dword_1D4E88000, v2, OS_LOG_TYPE_DEBUG, "%25s:%-5d [?] SysExSender(%p) dtor", (uint8_t *)&v4, 0x1Cu);
  }
  while (a1[40])
    SysexSender<MIDISysexSendRequestUMP,false>::currentRequestComplete(a1, *(_QWORD *)(a1[39] + 16));
  std::__list_imp<MIDISysexSendRequest *>::clear(a1 + 38);
  *a1 = off_1E98B9CE8;
  CADeprecated::CAGuard::~CAGuard((CADeprecated::CAGuard *)(a1 + 18));
  return a1;
}

void sub_1D4EA5F50(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

OSStatus MIDISendUMPSysex8(MIDISysexSendRequestUMP *umpRequest)
{
  OSStatus result;
  NSObject *v3;
  CADeprecated::Task *v4;
  const char *v5;
  unsigned int v6;
  unsigned int v7;
  BOOL v8;
  BOOL v9;
  const char *v10;
  NSObject *v11;
  int v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  _BYTE v20[40];
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  result = -50;
  if (!umpRequest || (gAborting & 1) != 0)
    return result;
  gSysexSender();
  v3 = gSysexSender(void)::ssxsnd;
  if (os_log_type_enabled((os_log_t)gSysexSender(void)::ssxsnd, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)v20 = 136315650;
    *(_QWORD *)&v20[4] = "SysexSender.cpp";
    *(_WORD *)&v20[12] = 1024;
    *(_DWORD *)&v20[14] = 304;
    *(_WORD *)&v20[18] = 2048;
    *(_QWORD *)&v20[20] = umpRequest;
    _os_log_impl(&dword_1D4E88000, v3, OS_LOG_TYPE_DEBUG, "%25s:%-5d [?] SendSysexUMP8(umpRequest: %p)", v20, 0x1Cu);
  }
  std::mutex::lock(&gCreateDisposeLockUMP8);
  v4 = (CADeprecated::Task *)SysexSender<MIDISysexSendRequestUMP,true>::sInstance;
  if (!SysexSender<MIDISysexSendRequestUMP,true>::sInstance)
  {
    v4 = (CADeprecated::Task *)operator new();
    CADeprecated::Task::Task(v4, v5, v6, v7, v8, v9, v10);
    *(_QWORD *)v4 = &off_1E98B7F28;
    *((_QWORD *)v4 + 38) = (char *)v4 + 304;
    *((_QWORD *)v4 + 39) = (char *)v4 + 304;
    *((_QWORD *)v4 + 40) = 0;
    *((_QWORD *)v4 + 41) = 0xC3500000000;
    CADeprecated::CAPThread::Start((uint64_t)v4);
    SysexSender<MIDISysexSendRequestUMP,true>::sInstance = (uint64_t)v4;
  }
  std::mutex::unlock(&gCreateDisposeLockUMP8);
  std::mutex::lock(&gCreateDisposeLockUMP8);
  if (gClientState)
    goto LABEL_8;
  std::mutex::lock(&stru_1EFEFC9E0);
  *(_QWORD *)v20 = MEMORY[0x1E0C809B0];
  *(_QWORD *)&v20[8] = 0x40000000;
  *(_QWORD *)&v20[16] = __MIDIClientCreate_block_invoke;
  *(_QWORD *)&v20[24] = &__block_descriptor_tmp_2629;
  *(_QWORD *)&v20[32] = 0;
  v21 = 0;
  if (!MIDIClientCreateWithBlockInternal(&stru_1E98BB0B0, &gClientState, v20, 0))
  {
    gSysexSender();
    v19 = gSysexSender(void)::ssxsnd;
    if (os_log_type_enabled((os_log_t)gSysexSender(void)::ssxsnd, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)v20 = 136315906;
      *(_QWORD *)&v20[4] = "SysexSender.cpp";
      *(_WORD *)&v20[12] = 1024;
      *(_DWORD *)&v20[14] = 70;
      *(_WORD *)&v20[18] = 2048;
      *(_QWORD *)&v20[20] = v4;
      *(_WORD *)&v20[28] = 1024;
      *(_DWORD *)&v20[30] = gClientState;
      _os_log_impl(&dword_1D4E88000, v19, OS_LOG_TYPE_DEBUG, "%25s:%-5d [?] SysExSender(%p)::PrepareOutputPort() - created client %d", v20, 0x22u);
    }
    std::mutex::unlock(&stru_1EFEFC9E0);
LABEL_8:
    if (!dword_1EFEFC9DC)
    {
      MIDIOutputPortCreate(gClientState, &stru_1E98BB0B0, (MIDIPortRef *)&dword_1EFEFC9DC);
      gSysexSender();
      v11 = gSysexSender(void)::ssxsnd;
      if (os_log_type_enabled((os_log_t)gSysexSender(void)::ssxsnd, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)v20 = 136315906;
        *(_QWORD *)&v20[4] = "SysexSender.cpp";
        *(_WORD *)&v20[12] = 1024;
        *(_DWORD *)&v20[14] = 74;
        *(_WORD *)&v20[18] = 2048;
        *(_QWORD *)&v20[20] = v4;
        *(_WORD *)&v20[28] = 1024;
        *(_DWORD *)&v20[30] = dword_1EFEFC9DC;
        _os_log_impl(&dword_1D4E88000, v11, OS_LOG_TYPE_DEBUG, "%25s:%-5d [?] SysExSender(%p)::PrepareOutputPort() - created output port %d", v20, 0x22u);
      }
    }
    goto LABEL_13;
  }
  std::mutex::unlock(&stru_1EFEFC9E0);
LABEL_13:
  v12 = (*(uint64_t (**)(_QWORD *))(*((_QWORD *)v4 + 18) + 16))((_QWORD *)v4 + 18);
  v13 = *((_QWORD *)v4 + 40);
  v14 = operator new(0x18uLL);
  v14[1] = (char *)v4 + 304;
  v14[2] = umpRequest;
  v15 = *((_QWORD *)v4 + 38);
  *v14 = v15;
  *(_QWORD *)(v15 + 8) = v14;
  *((_QWORD *)v4 + 38) = v14;
  *((_QWORD *)v4 + 40) = v13 + 1;
  gSysexSender();
  v16 = gSysexSender(void)::ssxsnd;
  if (os_log_type_enabled((os_log_t)gSysexSender(void)::ssxsnd, OS_LOG_TYPE_DEBUG))
  {
    v17 = *((_QWORD *)v4 + 40);
    *(_DWORD *)v20 = 136316162;
    *(_QWORD *)&v20[4] = "SysexSender.cpp";
    *(_WORD *)&v20[12] = 1024;
    *(_DWORD *)&v20[14] = 117;
    *(_WORD *)&v20[18] = 2048;
    *(_QWORD *)&v20[20] = v4;
    *(_WORD *)&v20[28] = 2048;
    *(_QWORD *)&v20[30] = umpRequest;
    *(_WORD *)&v20[38] = 1024;
    LODWORD(v21) = v17;
    _os_log_impl(&dword_1D4E88000, v16, OS_LOG_TYPE_DEBUG, "%25s:%-5d [?] SysExSender(%p)::AddRequest(%p) - mQueue now contains %d items", v20, 0x2Cu);
  }
  if (v12)
    (*(void (**)(_QWORD *))(*((_QWORD *)v4 + 18) + 24))((_QWORD *)v4 + 18);
  if (!v13)
  {
    v18 = mach_absolute_time();
    CADeprecated::Task::WakeUpAt(v4, v18);
  }
  std::mutex::unlock(&gCreateDisposeLockUMP8);
  return 0;
}

void sub_1D4EA6368(_Unwind_Exception *a1)
{
  std::mutex::unlock(&stru_1EFEFC9E0);
  std::mutex::unlock(&gCreateDisposeLockUMP8);
  _Unwind_Resume(a1);
}

void SysexSender<MIDISysexSendRequestUMP,true>::~SysexSender(_QWORD *a1)
{
  SysexSender<MIDISysexSendRequestUMP,true>::~SysexSender(a1);
  JUMPOUT(0x1D826BA98);
}

void SysexSender<MIDISysexSendRequestUMP,true>::RunTask(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  _BOOL4 v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  NSObject *v10;
  const char *v11;
  UInt32 v12;
  const char *v13;
  uint64_t v14;
  NSObject *v15;
  MIDIEndpointRef v16;
  int v17;
  MIDIObjectRef v18;
  MIDIProtocolID protocol;
  uint64_t v20;
  unint64_t Length;
  const UInt8 *BytePtr;
  unsigned int *v23;
  unsigned int v24;
  MIDIUniqueID v25;
  OSStatus IntegerProperty;
  int v27;
  uint64_t v28;
  MIDIObjectType outObjectType[2];
  uint8_t v30[4];
  const char *v31;
  __int16 v32;
  int v33;
  __int16 v34;
  uint64_t v35;
  __int16 v36;
  uint64_t v37;
  __int16 v38;
  int v39;
  __int16 v40;
  MIDIEndpointRef v41;
  __int16 v42;
  int v43;
  MIDIEventList buf;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 320);
  gSysexSender();
  v5 = gSysexSender(void)::ssxsnd;
  v6 = os_log_type_enabled((os_log_t)gSysexSender(void)::ssxsnd, OS_LOG_TYPE_DEBUG);
  if (v4)
  {
    if (v6)
    {
      v7 = *(_QWORD *)(a1 + 320);
      buf.protocol = 136316162;
      *(_QWORD *)&buf.numPackets = "SysexSender.cpp";
      WORD2(buf.packet[0].timeStamp) = 1024;
      *(_DWORD *)((char *)&buf.packet[0].timeStamp + 6) = 143;
      HIWORD(buf.packet[0].wordCount) = 2048;
      *(_QWORD *)buf.packet[0].words = a1;
      LOWORD(buf.packet[0].words[2]) = 2048;
      *(_QWORD *)((char *)&buf.packet[0].words[2] + 2) = a2;
      HIWORD(buf.packet[0].words[4]) = 1024;
      buf.packet[0].words[5] = v7;
      _os_log_impl(&dword_1D4E88000, v5, OS_LOG_TYPE_DEBUG, "%25s:%-5d [?] SysExSender(%p)::RunTask(%llu) - mQueue starting with %d items", (uint8_t *)&buf, 0x2Cu);
    }
    v28 = a2;
    while (1)
    {
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 312) + 16);
      if (!*(_BYTE *)(v8 + 20))
      {
        v9 = *(_DWORD *)(v8 + 16);
        if (v9)
          break;
      }
      gSysexSender();
      v10 = gSysexSender(void)::ssxsnd;
      if (os_log_type_enabled((os_log_t)gSysexSender(void)::ssxsnd, OS_LOG_TYPE_DEBUG))
      {
        v11 = "true";
        if (!*(_BYTE *)(v8 + 20))
          v11 = "false";
        v12 = *(_DWORD *)(v8 + 16);
        buf.protocol = 136316162;
        *(_QWORD *)&buf.numPackets = "SysexSender.cpp";
        WORD2(buf.packet[0].timeStamp) = 1024;
        *(_DWORD *)((char *)&buf.packet[0].timeStamp + 6) = 153;
        HIWORD(buf.packet[0].wordCount) = 2048;
        *(_QWORD *)buf.packet[0].words = v8;
        LOWORD(buf.packet[0].words[2]) = 2080;
        *(_QWORD *)((char *)&buf.packet[0].words[2] + 2) = v11;
        HIWORD(buf.packet[0].words[4]) = 1024;
        buf.packet[0].words[5] = v12;
        _os_log_impl(&dword_1D4E88000, v10, OS_LOG_TYPE_DEBUG, "%25s:%-5d     req %p: complete = %s, toSend = %d", (uint8_t *)&buf, 0x2Cu);
      }
      SysexSender<MIDISysexSendRequestUMP,true>::currentRequestComplete((_QWORD *)a1, v8);
      if (!*(_QWORD *)(a1 + 320))
      {
        gSysexSender();
        v5 = gSysexSender(void)::ssxsnd;
        if (!os_log_type_enabled((os_log_t)gSysexSender(void)::ssxsnd, OS_LOG_TYPE_DEBUG))
          return;
        buf.protocol = 136315906;
        *(_QWORD *)&buf.numPackets = "SysexSender.cpp";
        WORD2(buf.packet[0].timeStamp) = 1024;
        *(_DWORD *)((char *)&buf.packet[0].timeStamp + 6) = 157;
        HIWORD(buf.packet[0].wordCount) = 2048;
        *(_QWORD *)buf.packet[0].words = a1;
        LOWORD(buf.packet[0].words[2]) = 2048;
        *(_QWORD *)((char *)&buf.packet[0].words[2] + 2) = a2;
        v13 = "%25s:%-5d [?] SysExSender(%p)::RunTask(%llu) - queue is now empty; done";
LABEL_16:
        _os_log_impl(&dword_1D4E88000, v5, OS_LOG_TYPE_DEBUG, v13, (uint8_t *)&buf, 0x26u);
        return;
      }
    }
    memset(buf.packet[0].words, 0, sizeof(buf.packet[0].words));
    *(_QWORD *)&buf.protocol = 0x100000002;
    buf.packet[0].timeStamp = 0;
    if (v9 >= 0x40)
      v14 = 64;
    else
      v14 = v9;
    buf.packet[0].wordCount = v14;
    memmove(buf.packet[0].words, *(const void **)(v8 + 8), 4 * v14);
    std::mutex::lock(&stru_1EFEFC9E0);
    MIDISendEventList(dword_1EFEFC9DC, *(_DWORD *)v8, &buf);
    *(_QWORD *)(v8 + 8) += 4 * v14;
    *(_DWORD *)(v8 + 16) -= v14;
    gSysexSender();
    v15 = gSysexSender(void)::ssxsnd;
    if (os_log_type_enabled((os_log_t)gSysexSender(void)::ssxsnd, OS_LOG_TYPE_DEBUG))
    {
      v16 = *(_DWORD *)v8;
      v17 = *(_DWORD *)(v8 + 16);
      *(_DWORD *)v30 = 136316674;
      v31 = "SysexSender.cpp";
      v32 = 1024;
      v33 = 191;
      v34 = 2048;
      v35 = a1;
      v36 = 2048;
      v37 = v28;
      v38 = 1024;
      v39 = v14;
      v40 = 1024;
      v41 = v16;
      v42 = 1024;
      v43 = v17;
      _os_log_impl(&dword_1D4E88000, v15, OS_LOG_TYPE_DEBUG, "%25s:%-5d [?] SysExSender(%p)::RunTask(%llu) - sent %d words to destination %d (%d remain)", v30, 0x38u);
    }
    std::mutex::unlock(&stru_1EFEFC9E0);
    v18 = *(_DWORD *)v8;
    if (*(_DWORD *)v8 == *(_DWORD *)(a1 + 328))
    {
      protocol = *(_DWORD *)(a1 + 332);
      if (protocol)
      {
LABEL_25:
        v20 = mach_absolute_time();
        CADeprecated::Task::WakeUpAt((CADeprecated::Task *)a1, v20 + 3 * (1000000000 * (unint64_t)(4 * v14) / (int)protocol) / 0x7D);
        return;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 328) = v18;
      buf.protocol = 0;
      if (MIDIObjectGetIntegerProperty(v18, kMIDIPropertyMaxSysExSpeed, (SInt32 *)&buf))
        protocol = 3125;
      else
        protocol = buf.protocol;
      *(_QWORD *)&buf.protocol = 0;
      if (!MIDIObjectGetDataProperty(*(_DWORD *)v8, kMIDIPropertyConnectionUniqueID, (CFDataRef *)&buf))
      {
        Length = CFDataGetLength(*(CFDataRef *)&buf.protocol);
        BytePtr = CFDataGetBytePtr(*(CFDataRef *)&buf.protocol);
        if ((int)(Length >> 2) >= 1)
        {
          v23 = (unsigned int *)BytePtr;
          v24 = (Length >> 2) + 1;
          do
          {
            v25 = bswap32(*v23);
            *(_QWORD *)outObjectType = 0;
            if (!MIDIObjectFindByUniqueID(v25, (MIDIObjectRef *)&outObjectType[1], outObjectType))
            {
              *(_DWORD *)v30 = 0;
              IntegerProperty = MIDIObjectGetIntegerProperty(outObjectType[1], kMIDIPropertyMaxSysExSpeed, (SInt32 *)v30);
              v27 = *(_DWORD *)v30;
              if (IntegerProperty)
                v27 = 3125;
              if (v27 < protocol)
                protocol = v27;
            }
            ++v23;
            --v24;
          }
          while (v24 > 1);
        }
        CFRelease(*(CFTypeRef *)&buf.protocol);
      }
      *(_DWORD *)(a1 + 332) = protocol;
      if (protocol)
        goto LABEL_25;
    }
    protocol = 3125;
    *(_DWORD *)(a1 + 332) = 3125;
    goto LABEL_25;
  }
  if (v6)
  {
    buf.protocol = 136315906;
    *(_QWORD *)&buf.numPackets = "SysexSender.cpp";
    WORD2(buf.packet[0].timeStamp) = 1024;
    *(_DWORD *)((char *)&buf.packet[0].timeStamp + 6) = 140;
    HIWORD(buf.packet[0].wordCount) = 2048;
    *(_QWORD *)buf.packet[0].words = a1;
    LOWORD(buf.packet[0].words[2]) = 2048;
    *(_QWORD *)((char *)&buf.packet[0].words[2] + 2) = a2;
    v13 = "%25s:%-5d [?] SysExSender(%p)::RunTask(%llu) - nothing to do; returning";
    goto LABEL_16;
  }
}

void sub_1D4EA69A0(_Unwind_Exception *a1)
{
  std::mutex::unlock(&stru_1EFEFC9E0);
  _Unwind_Resume(a1);
}

void SysexSender<MIDISysexSendRequestUMP,true>::currentRequestComplete(_QWORD *a1, uint64_t a2)
{
  void (*v4)(uint64_t);
  int v5;
  uint64_t *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  int v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  _QWORD *v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  *(_BYTE *)(a2 + 20) = 1;
  v4 = *(void (**)(uint64_t))(a2 + 24);
  if (v4)
    v4(a2);
  v5 = (*(uint64_t (**)(_QWORD *))(a1[18] + 16))(a1 + 18);
  v6 = (uint64_t *)a1[39];
  v7 = *v6;
  *(_QWORD *)(v7 + 8) = v6[1];
  *(_QWORD *)v6[1] = v7;
  --a1[40];
  operator delete(v6);
  gSysexSender();
  v8 = gSysexSender(void)::ssxsnd;
  if (os_log_type_enabled((os_log_t)gSysexSender(void)::ssxsnd, OS_LOG_TYPE_DEBUG))
  {
    v9 = a1[40];
    v10 = 136316162;
    v11 = "SysexSender.cpp";
    v12 = 1024;
    v13 = 105;
    v14 = 2048;
    v15 = a1;
    v16 = 2048;
    v17 = a2;
    v18 = 1024;
    v19 = v9;
    _os_log_impl(&dword_1D4E88000, v8, OS_LOG_TYPE_DEBUG, "%25s:%-5d [?] SysExSender(%p)::currentRequestComplete(%p) - mQueue now contains %d items", (uint8_t *)&v10, 0x2Cu);
  }
  if (v5)
    (*(void (**)(_QWORD *))(a1[18] + 24))(a1 + 18);
}

void sub_1D4EA6B14(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

_QWORD *SysexSender<MIDISysexSendRequestUMP,true>::~SysexSender(_QWORD *a1)
{
  NSObject *v2;
  int v4;
  const char *v5;
  __int16 v6;
  int v7;
  __int16 v8;
  _QWORD *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  *a1 = &off_1E98B7F28;
  gSysexSender();
  v2 = gSysexSender(void)::ssxsnd;
  if (os_log_type_enabled((os_log_t)gSysexSender(void)::ssxsnd, OS_LOG_TYPE_DEBUG))
  {
    v4 = 136315650;
    v5 = "SysexSender.cpp";
    v6 = 1024;
    v7 = 42;
    v8 = 2048;
    v9 = a1;
    _os_log_impl(&dword_1D4E88000, v2, OS_LOG_TYPE_DEBUG, "%25s:%-5d [?] SysExSender(%p) dtor", (uint8_t *)&v4, 0x1Cu);
  }
  while (a1[40])
    SysexSender<MIDISysexSendRequestUMP,true>::currentRequestComplete(a1, *(_QWORD *)(a1[39] + 16));
  std::__list_imp<MIDISysexSendRequest *>::clear(a1 + 38);
  *a1 = off_1E98B9CE8;
  CADeprecated::CAGuard::~CAGuard((CADeprecated::CAGuard *)(a1 + 18));
  return a1;
}

void sub_1D4EA6C2C(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

OSStatus MIDIEventPacketSysexBytesForGroup(const MIDIEventPacket *pkt, UInt8 groupIndex, CFDataRef *outData)
{
  uint64_t wordCount;
  unint64_t v6;
  UInt32 *words;
  UInt32 *v8;
  UInt32 *v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const UInt8 *v14;
  unsigned int v15;
  int v16;
  UInt32 *v17;
  UInt32 v18;
  UInt8 *v19;
  unsigned int v20;
  int v21;
  BOOL v22;
  UInt32 v23;
  BOOL v24;
  uint64_t v25;
  char v26;
  uint64_t v27;
  char v28;
  UInt32 v29;
  UInt8 v30;
  CFDataRef v31;
  UInt8 *v32;
  void *exception;
  const __CFData *v35;
  UInt8 *bytes[3];

  wordCount = pkt->wordCount;
  if ((_DWORD)wordCount)
  {
    v6 = 0;
    words = pkt->words;
    v8 = &pkt->words[wordCount];
    v9 = pkt->words;
    while (1)
    {
      v10 = *v9;
      if (v10 >> 28 != 3)
        break;
      if ((BYTE3(v10) & 0xF) == groupIndex)
      {
        v11 = (v10 >> 20) & 0xF;
        if (v11 > 3)
          v12 = 0;
        else
          v12 = qword_1D4F19250[v11];
        v6 += v12 + ((v10 >> 16) & 0xF);
      }
      v9 += MIDI::UniversalPacket::word_sizes[v10 >> 28];
      if (v9 == v8)
      {
        if (!v6)
          return -50;
        std::vector<unsigned char>::vector(bytes, v6);
        v13 = pkt->wordCount;
        v14 = bytes[0];
        if ((_DWORD)v13)
        {
          v15 = 0;
          v16 = LODWORD(bytes[0]) + v6;
          v17 = &words[v13];
          do
          {
            if (v6 <= v15)
              std::terminate();
            v18 = *words;
            v19 = &bytes[0][v15];
            if (*words >> 28 == 3)
              v20 = (*words >> 20) & 0xF;
            else
              v20 = 255;
            v21 = HIWORD(v18) & 0xF;
            if (v20 < 2)
              ++v21;
            if (v20)
              v22 = v20 == 3;
            else
              v22 = 1;
            if (v22)
              ++v21;
            if (v21 <= v16 - (int)v19)
            {
              v23 = words[1];
              v24 = v20 == 3 || v20 == 0;
              LODWORD(v25) = v21;
              if (v24)
              {
                v25 = v21 - 1;
                v19[v25] = -9;
              }
              if (v20 <= 1)
              {
                *v19++ = -16;
                LODWORD(v25) = v25 - 1;
              }
              if ((int)v25 >= 1)
              {
                v26 = 0;
                v27 = 0;
                do
                {
                  if (v27 >= 2)
                    v28 = 40;
                  else
                    v28 = 8;
                  if (v27 >= 2)
                    v29 = v23;
                  else
                    v29 = v18;
                  v30 = v29 >> (v28 + v26);
                  if (v27 > 5)
                    v30 = 0;
                  v19[v27] = v30;
                  v26 -= 8;
                  ++v27;
                }
                while (v25 != v27);
              }
            }
            else
            {
              v21 = 0;
            }
            v15 += v21;
            words += MIDI::UniversalPacket::word_sizes[(unint64_t)*words >> 28];
          }
          while (words != v17);
          v14 = bytes[0];
        }
        v31 = CFDataCreate(0, v14, v6);
        if (!v31)
        {
          exception = __cxa_allocate_exception(0x10uLL);
          MEMORY[0x1D826B7EC](exception, "Could not construct");
        }
        applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)&v35, v31);
        v32 = bytes[0];
        *outData = v35;
        if (v32)
        {
          bytes[1] = v32;
          operator delete(v32);
        }
        return 0;
      }
    }
  }
  return -50;
}

void sub_1D4EA6E8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  void *v11;

  __cxa_free_exception(v11);
  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void MIDIRingBuffer::~MIDIRingBuffer(MIDIRingBuffer *this)
{
  MIDIRingBuffer::~MIDIRingBuffer(this);
  JUMPOUT(0x1D826BA98);
}

{
  char *v2;
  const char *v3;

  *(_QWORD *)this = &off_1E98B9730;
  if (*((_BYTE *)this + 40))
  {
    v2 = (char *)*((_QWORD *)this + 11);
    if (v2 != (char *)this + 44)
      munmap(v2, *((int *)this + 8) + 32);
    if ((*((_BYTE *)this + 36) & 1) != 0)
    {
      v3 = (char *)this + 8;
      if (*((char *)this + 31) < 0)
        v3 = *(const char **)v3;
      shm_unlink(v3);
    }
  }
  if ((*((_BYTE *)this + 36) & 2) != 0)
    free(*((void **)this + 11));
  if (*((char *)this + 31) < 0)
    operator delete(*((void **)this + 1));
}

std::string *__cdecl std::string::__assign_external(std::string *this, const std::string::value_type *__s)
{
  size_t v4;

  v4 = strlen(__s);
  return std::string::__assign_external(this, __s, v4);
}

std::string *__cdecl std::string::__assign_external(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  unint64_t v6;
  std::string *v7;
  std::string::size_type size;
  unint64_t v9;
  unint64_t v10;

  LODWORD(v6) = SHIBYTE(this->__r_.__value_.__r.__words[2]);
  if ((v6 & 0x80000000) != 0)
  {
    v10 = this->__r_.__value_.__r.__words[2];
    v9 = (v10 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v9 < __n)
    {
      size = this->__r_.__value_.__l.__size_;
      goto LABEL_6;
    }
    v6 = HIBYTE(v10);
    v7 = (std::string *)this->__r_.__value_.__r.__words[0];
  }
  else
  {
    v7 = this;
    if (__n > 0x16)
    {
      size = HIBYTE(this->__r_.__value_.__r.__words[2]);
      v9 = 22;
LABEL_6:
      std::string::__grow_by_and_replace(this, v9, __n - v9, size, 0, size, __n, __s);
      return this;
    }
  }
  if (__n)
  {
    memmove(v7, __s, __n);
    LOBYTE(v6) = *((_BYTE *)&this->__r_.__value_.__s + 23);
  }
  if ((v6 & 0x80) != 0)
    this->__r_.__value_.__l.__size_ = __n;
  else
    *((_BYTE *)&this->__r_.__value_.__s + 23) = __n & 0x7F;
  v7->__r_.__value_.__s.__data_[__n] = 0;
  return this;
}

uint64_t MIDIRingBuffer::Write(MIDIRingBuffer *this, char *a2, int a3)
{
  unsigned int *v3;
  signed int v4;
  signed int v5;
  BOOL v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v14;
  int v15;
  int v16;
  unsigned int v17;
  size_t v18;

  v3 = (unsigned int *)*((_QWORD *)this + 11);
  v4 = atomic_load(v3);
  v5 = atomic_load(v3 + 1);
  v7 = v4 - v5;
  v6 = v4 < v5;
  v8 = *((_DWORD *)this + 8);
  if (v6)
    v9 = *((_DWORD *)this + 8);
  else
    v9 = 0;
  v10 = (v7 + v9);
  if ((int)v10 + a3 >= v8)
    return 0xFFFFFFFFLL;
  v14 = v4;
  v15 = v8 - v4;
  if (v15 >= a3)
    v16 = a3;
  else
    v16 = v15;
  memcpy((char *)v3 + v14 + 32, a2, v16);
  if (v16 + (_DWORD)v14 == *((_DWORD *)this + 8))
    v17 = 0;
  else
    v17 = v16 + v14;
  v18 = (a3 - v16);
  if ((int)v18 >= 1)
  {
    memcpy(v3 + 8, &a2[v16], v18);
    v17 += v18;
  }
  atomic_store(v17, v3);
  return v10;
}

uint64_t MIDIRingBuffer::Peek(MIDIRingBuffer *this, char *__dst, int a3)
{
  unsigned int *v6;
  unsigned int v7;
  signed int v8;
  BOOL v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  const void *v15;
  size_t v16;

  v6 = (unsigned int *)*((_QWORD *)this + 11);
  v7 = atomic_load(v6);
  v8 = atomic_load(v6 + 1);
  v9 = __OFSUB__(v7, v8);
  v10 = v7 - v8;
  if (v10 < 0 != v9)
    v10 += *((_DWORD *)this + 8);
  if (v10 < a3)
    return 0xFFFFFFFFLL;
  v12 = v8;
  v13 = *((_DWORD *)this + 8) - v8;
  if (v13 >= a3)
    v14 = a3;
  else
    v14 = v13;
  v15 = v6 + 8;
  memcpy(__dst, (char *)v6 + v12 + 32, v14);
  if (v14 + (_DWORD)v12 == *((_DWORD *)this + 8))
    v11 = 0;
  else
    v11 = (v14 + v12);
  v16 = (a3 - v14);
  if ((int)v16 >= 1)
  {
    memcpy(&__dst[v14], v15, v16);
    v11 = (v11 + v16);
  }
  if ((v11 & 0x80000000) != 0 || (int)v11 >= *((_DWORD *)this + 8))
    std::terminate();
  return v11;
}

void MIDIThruConnectionParamsInitialize(MIDIThruConnectionParams *inConnectionParams)
{
  *(_OWORD *)&inConnectionParams->destinations[6].uniqueID = 0u;
  *(_OWORD *)&inConnectionParams->channelMap[4] = 0u;
  *(_OWORD *)inConnectionParams->reserved2 = 0u;
  *(_OWORD *)&inConnectionParams->noteNumber.transform = 0u;
  *(_OWORD *)&inConnectionParams->programChange.transform = 0u;
  *(_OWORD *)&inConnectionParams->destinations[2].uniqueID = 0u;
  *(_OWORD *)&inConnectionParams->destinations[4].uniqueID = 0u;
  *(_OWORD *)&inConnectionParams->sources[7].endpointRef = 0u;
  *(_OWORD *)&inConnectionParams->destinations[0].uniqueID = 0u;
  *(_OWORD *)&inConnectionParams->sources[3].endpointRef = 0u;
  *(_OWORD *)&inConnectionParams->sources[5].endpointRef = 0u;
  *(_OWORD *)&inConnectionParams->version = 0u;
  *(_OWORD *)&inConnectionParams->sources[1].endpointRef = 0u;
  *(_OWORD *)inConnectionParams->channelMap = xmmword_1D4F18A40;
  inConnectionParams->highNote = 127;
}

uint64_t MIDIConfigCheckVirginState(const __CFString *a1)
{
  uint64_t v2;
  CFStringRef str;
  MIDIObjectRef obj;
  stat v6;
  char v7[1024];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  obj = 0;
  str = 0;
  MIDISetupGetCurrent_Priv((MIDIProcess *)&obj);
  if (MIDIObjectGetStringProperty(obj, kMIDIPropertyName, &str) || CFStringGetLength(str) <= 0)
  {
    MIDIConfigGetFullPathToFile(a1, v7);
    if (lstat(v7, &v6))
      v2 = MIDIObjectSetStringProperty(obj, kMIDIPropertyName, a1);
    else
      v2 = 1685418094;
  }
  else
  {
    v2 = 0;
  }
  if (str)
    CFRelease(str);
  return v2;
}

BOOL MIDIConfigExists(const __CFString *a1)
{
  stat v2;
  char v3[1024];
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  MIDIConfigGetFullPathToFile(a1, v3);
  return lstat(v3, &v2) == 0;
}

uint64_t MIDIConfigNew(const __CFString *a1)
{
  MIDIProcess *v2;
  uint64_t v3;
  uint64_t *v4;
  ClientInterface *v5;
  _UNKNOWN **v6;
  uint64_t v7;
  stat v9;
  MIDIObjectRef obj[256];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  MIDIConfigGetFullPathToFile(a1, (char *)obj);
  v2 = (MIDIProcess *)lstat((const char *)obj, &v9);
  if (!(_DWORD)v2)
    return 1685418094;
  obj[0] = 0;
  if ((gInMIDIServer & 1) != 0)
  {
    v3 = _MIDISetupCreate((MIDIServer *)obj);
    if ((_DWORD)v3)
      return v3;
  }
  else
  {
    v4 = MIDIProcess::defaultInstance(v2);
    v5 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v4 + 56))(v4);
    v3 = (uint64_t)v5;
    if ((_DWORD)v5)
      return v3;
    v6 = ClientInterface::global(v5);
    v3 = (*((uint64_t (**)(_UNKNOWN **, MIDIObjectRef *))*v6 + 38))(v6, obj);
    ObjectTreeCache::Invalidate((ObjectTreeCache *)(v4 + 36));
    if ((_DWORD)v3)
      return v3;
  }
  v7 = MIDIObjectSetStringProperty(obj[0], kMIDIPropertyName, a1);
  if (!(_DWORD)v7)
    return (uint64_t)MIDISetupInstall_Priv((MIDIProcess *)obj[0]);
  return v7;
}

__CFArray *MIDIConfigGetList()
{
  __CFArray *Mutable;
  DIR *v1;
  DIR *v2;
  dirent *v3;
  const UInt8 *d_name;
  char *v5;
  char *v6;
  const __CFURL *v7;
  const __CFURL *v8;
  CFStringRef PathComponent;

  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  MIDIConfigDirectory();
  v1 = opendir(MIDIConfigDirectory(void)::configDir);
  if (v1)
  {
    v2 = v1;
    while (1)
    {
      v3 = readdir(v2);
      if (!v3)
        break;
      d_name = (const UInt8 *)v3->d_name;
      v5 = strrchr(v3->d_name, 46);
      if (v5)
      {
        v6 = v5;
        if (!strcmp(v5, ".mcfg"))
        {
          v7 = CFURLCreateFromFileSystemRepresentation(0, d_name, v6 - (char *)d_name, 0);
          if (v7)
          {
            v8 = v7;
            PathComponent = CFURLCopyLastPathComponent(v7);
            CFRelease(v8);
            CFArrayAppendValue(Mutable, PathComponent);
            CFRelease(PathComponent);
          }
        }
      }
    }
    closedir(v2);
  }
  else
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

uint64_t MIDIConfigInstall(const __CFString *a1)
{
  __CFData *FileIntoCFData;
  __CFData *v3;
  uint64_t v4;
  uint64_t *v5;
  ClientInterface *v6;
  _UNKNOWN **v7;
  ClientInterface *v8;
  MIDIObjectRef obj;
  char v11[1024];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  MIDIConfigGetFullPathToFile(a1, v11);
  FileIntoCFData = ReadFileIntoCFData(v11);
  if (FileIntoCFData)
  {
    v3 = FileIntoCFData;
    obj = 0;
    if ((gInMIDIServer & 1) != 0)
    {
      v4 = _MIDISetupFromData(FileIntoCFData, &obj);
      if ((_DWORD)v4)
      {
LABEL_11:
        CFRelease(v3);
        return v4;
      }
    }
    else
    {
      v5 = MIDIProcess::defaultInstance(FileIntoCFData);
      v6 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v5 + 56))(v5);
      v4 = (uint64_t)v6;
      if ((_DWORD)v6)
        goto LABEL_11;
      v7 = ClientInterface::global(v6);
      v4 = (*((uint64_t (**)(_UNKNOWN **, __CFData *, MIDIObjectRef *))*v7 + 41))(v7, v3, &obj);
      ObjectTreeCache::Invalidate((ObjectTreeCache *)(v5 + 36));
      if ((_DWORD)v4)
        goto LABEL_11;
    }
    v8 = MIDISetupInstall_Priv((MIDIProcess *)obj);
    if (!(_DWORD)v8)
      v8 = (ClientInterface *)MIDIObjectSetStringProperty(obj, kMIDIPropertyName, a1);
    v4 = (uint64_t)v8;
    goto LABEL_11;
  }
  return 560362084;
}

uint64_t MIDIConfigDuplicate(const __CFString *a1, const __CFString *a2)
{
  uint64_t v3;
  __CFData *FileIntoCFData;
  const __CFData *v5;
  char v7[1024];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v3 = 560362084;
  MIDIConfigGetFullPathToFile(a1, v7);
  FileIntoCFData = ReadFileIntoCFData(v7);
  if (FileIntoCFData)
  {
    v5 = FileIntoCFData;
    MIDIConfigGetFullPathToFile(a2, v7);
    if (WriteFileFromCFData(v7, v5))
      v3 = 0;
    else
      v3 = 560363378;
    CFRelease(v5);
  }
  return v3;
}

uint64_t MIDIConfigRename(const __CFString *a1, CFStringRef theString)
{
  char *v3;
  char *v4;
  const __CFString *v5;
  uint64_t Current_Priv;
  uint64_t v7;
  CFStringRef str;
  MIDIObjectRef obj;
  char buffer[512];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  obj = 0;
  str = 0;
  CFStringGetCString(theString, buffer, 512, 0x8000100u);
  while (1)
  {
    v3 = strchr(buffer, 47);
    if (!v3)
      break;
    *v3 = 32;
  }
  while (1)
  {
    v4 = strchr(buffer, 58);
    if (!v4)
      break;
    *v4 = 32;
  }
  v5 = CFStringCreateWithCString(0, buffer, 0x8000100u);
  Current_Priv = MIDISetupGetCurrent_Priv((MIDIProcess *)&obj);
  if (!(_DWORD)Current_Priv)
  {
    Current_Priv = MIDIObjectGetStringProperty(obj, kMIDIPropertyName, &str);
    if (!(_DWORD)Current_Priv)
    {
      if (!CFEqual(str, a1))
      {
        MIDIConfigFileRenameOrDelete(a1, v5);
        v7 = 0;
        goto LABEL_12;
      }
      Current_Priv = MIDIObjectSetStringProperty(obj, kMIDIPropertyName, v5);
    }
  }
  v7 = Current_Priv;
LABEL_12:
  CFRelease(v5);
  CFRelease(str);
  return v7;
}

uint64_t MIDIConfigDelete(const __CFString *a1)
{
  return MIDIConfigRename(a1, &stru_1E98BB0B0);
}

uint64_t MIDIConfigGetCurrent(_QWORD *a1)
{
  uint64_t result;
  CFStringRef v3;
  MIDIObjectRef obj;

  obj = 0;
  v3 = 0;
  result = MIDISetupGetCurrent_Priv((MIDIProcess *)&obj);
  if (!(_DWORD)result)
  {
    result = MIDIObjectGetStringProperty(obj, kMIDIPropertyName, &v3);
    if (!(_DWORD)result)
      *a1 = v3;
  }
  return result;
}

void MIDIConfigDirectory(void)
{
  char *v0;
  DIR *v1;
  DIR *v2;

  if ((MIDIConfigDirectory(void)::inited & 1) == 0)
  {
    MIDIConfigDirectory(void)::configDir[0] = 0;
    v0 = getenv("HOME");
    if (v0)
    {
      snprintf(MIDIConfigDirectory(void)::configDir, 0x400uLL, "%s%s", v0, "/Library/Audio");
      v1 = opendir(MIDIConfigDirectory(void)::configDir);
      if (v1)
        closedir(v1);
      else
        mkdir(MIDIConfigDirectory(void)::configDir, 0x1EDu);
      snprintf(MIDIConfigDirectory(void)::configDir, 0x400uLL, "%s/%s", MIDIConfigDirectory(void)::configDir, "MIDI Configurations");
      v2 = opendir(MIDIConfigDirectory(void)::configDir);
      if (v2)
        closedir(v2);
      else
        mkdir(MIDIConfigDirectory(void)::configDir, 0x1EDu);
      *(_WORD *)&MIDIConfigDirectory(void)::configDir[strlen(MIDIConfigDirectory(void)::configDir)] = 47;
      MIDIConfigDirectory(void)::inited = 1;
    }
  }
}

size_t MIDIConfigGetFullPathToFile(const __CFString *a1, char *a2)
{
  char *v3;
  char *v4;
  size_t result;
  char buffer[256];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  CFStringGetCString(a1, buffer, 256, 0x8000100u);
  MIDIConfigDirectory();
  v3 = strcpy(a2, MIDIConfigDirectory(void)::configDir);
  v4 = strcat(v3, buffer);
  result = strlen(v4);
  strcpy(&a2[result], ".mcfg");
  return result;
}

void MIDIConfigFileRenameOrDelete(const __CFString *a1, const __CFString *a2)
{
  std::error_code *v3;
  std::__fs::filesystem::path __to;
  std::__fs::filesystem::path __from;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  MIDIConfigGetFullPathToFile(a1, (char *)&__from);
  if (CFStringGetLength(a2) < 1)
  {
    unlink((const char *)&__from);
  }
  else
  {
    MIDIConfigGetFullPathToFile(a2, (char *)&__to);
    rename(&__from, &__to, v3);
  }
}

void midi::sysex::clear(midi::sysex *this)
{
  void *v2;
  _QWORD *v3;

  *(_DWORD *)this = 0;
  v3 = (_QWORD *)((char *)this + 8);
  v2 = (void *)*((_QWORD *)this + 1);
  *((_QWORD *)this + 2) = v2;
  if (*((_QWORD *)this + 3) - (_QWORD)v2 > 0x4000uLL)
  {
    *v3 = 0;
    v3[1] = 0;
    v3[2] = 0;
    if (v2)
      operator delete(v2);
  }
}

void midi::sysex7::add_device_identity(uint64_t a1)
{
  unint64_t *v2;
  unint64_t v3;
  char *v4;
  char *v5;
  unint64_t v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  size_t v10;
  char *v11;
  char *v12;
  char *v13;
  char v14;
  unint64_t v15;
  char *v16;
  unint64_t v17;
  char *v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  void *v22;
  char *v23;
  char *v24;
  char v25;
  unint64_t v26;
  char *v27;
  char *v28;
  char *v29;
  unint64_t v30;
  unint64_t v31;
  size_t v32;
  void *v33;
  char *v34;
  char *v35;
  char v36;
  __int16 __src;
  __int16 v38;
  int v39;
  uint64_t v40;

  v2 = (unint64_t *)(a1 + 8);
  v4 = *(char **)(a1 + 16);
  v3 = *(_QWORD *)(a1 + 24);
  if ((unint64_t)v4 >= v3)
  {
    v6 = *v2;
    v7 = &v4[-*v2];
    v8 = (unint64_t)(v7 + 1);
    if ((uint64_t)(v7 + 1) < 0)
      goto LABEL_56;
    v9 = v3 - v6;
    if (2 * v9 > v8)
      v8 = 2 * v9;
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL)
      v10 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v10 = v8;
    if (v10)
      v11 = (char *)operator new(v10);
    else
      v11 = 0;
    v12 = &v11[v10];
    v7[(_QWORD)v11] = 17;
    v5 = &v7[(_QWORD)v11 + 1];
    if (v4 == (char *)v6)
    {
      v11 = &v7[(_QWORD)v11];
    }
    else
    {
      v13 = &v4[~v6];
      do
      {
        v14 = *--v4;
        (v13--)[(_QWORD)v11] = v14;
      }
      while (v4 != (char *)v6);
      v4 = (char *)*v2;
    }
    *(_QWORD *)(a1 + 8) = v11;
    *(_QWORD *)(a1 + 16) = v5;
    *(_QWORD *)(a1 + 24) = v12;
    if (v4)
      operator delete(v4);
  }
  else
  {
    *v4 = 17;
    v5 = v4 + 1;
  }
  *(_QWORD *)(a1 + 16) = v5;
  v15 = *(_QWORD *)(a1 + 24);
  if ((unint64_t)v5 < v15)
  {
    *v5 = 0;
    v16 = v5 + 1;
    goto LABEL_37;
  }
  v17 = *v2;
  v18 = &v5[-*v2];
  v19 = (unint64_t)(v18 + 1);
  if ((uint64_t)(v18 + 1) < 0)
    goto LABEL_56;
  v20 = v15 - v17;
  if (2 * v20 > v19)
    v19 = 2 * v20;
  if (v20 >= 0x3FFFFFFFFFFFFFFFLL)
    v21 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v21 = v19;
  if (v21)
    v22 = operator new(v21);
  else
    v22 = 0;
  v23 = (char *)v22 + v21;
  v18[(_QWORD)v22] = 0;
  v16 = &v18[(_QWORD)v22 + 1];
  if (v5 == (char *)v17)
  {
    *(_QWORD *)(a1 + 8) = &v18[(_QWORD)v22];
    *(_QWORD *)(a1 + 16) = v16;
    *(_QWORD *)(a1 + 24) = v23;
LABEL_36:
    operator delete(v5);
    goto LABEL_37;
  }
  v24 = &v5[~v17];
  do
  {
    v25 = *--v5;
    (v24--)[(_QWORD)v22] = v25;
  }
  while (v5 != (char *)v17);
  v5 = *(char **)(a1 + 8);
  *(_QWORD *)(a1 + 8) = v22;
  *(_QWORD *)(a1 + 16) = v16;
  *(_QWORD *)(a1 + 24) = v23;
  if (v5)
    goto LABEL_36;
LABEL_37:
  *(_QWORD *)(a1 + 16) = v16;
  v26 = *(_QWORD *)(a1 + 24);
  if ((unint64_t)v16 < v26)
  {
    *v16 = 0;
    v27 = v16 + 1;
    goto LABEL_55;
  }
  v28 = (char *)*v2;
  v29 = &v16[-*v2];
  v30 = (unint64_t)(v29 + 1);
  if ((uint64_t)(v29 + 1) < 0)
LABEL_56:
    std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
  v31 = v26 - (_QWORD)v28;
  if (2 * v31 > v30)
    v30 = 2 * v31;
  if (v31 >= 0x3FFFFFFFFFFFFFFFLL)
    v32 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v32 = v30;
  if (v32)
    v33 = operator new(v32);
  else
    v33 = 0;
  v34 = (char *)v33 + v32;
  v29[(_QWORD)v33] = 0;
  v27 = &v29[(_QWORD)v33 + 1];
  if (v16 == v28)
  {
    *(_QWORD *)(a1 + 8) = &v29[(_QWORD)v33];
    *(_QWORD *)(a1 + 16) = v27;
    *(_QWORD *)(a1 + 24) = v34;
LABEL_54:
    operator delete(v16);
    goto LABEL_55;
  }
  v35 = &v16[~(unint64_t)v28];
  do
  {
    v36 = *--v16;
    (v35--)[(_QWORD)v33] = v36;
  }
  while (v16 != v28);
  v16 = *(char **)(a1 + 8);
  *(_QWORD *)(a1 + 8) = v33;
  *(_QWORD *)(a1 + 16) = v27;
  *(_QWORD *)(a1 + 24) = v34;
  if (v16)
    goto LABEL_54;
LABEL_55:
  *(_QWORD *)(a1 + 16) = v27;
  __src = 1;
  std::vector<unsigned char>::__insert_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((uint64_t)v2, v27, (char *)&__src, (char *)&v38, 2);
  v38 = 1;
  std::vector<unsigned char>::__insert_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((uint64_t)v2, *(char **)(a1 + 16), (char *)&v38, (char *)&v39, 2);
  v39 = 2;
  std::vector<unsigned char>::__insert_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((uint64_t)v2, *(char **)(a1 + 16), (char *)&v39, (char *)&v40, 4);
}

uint64_t MIDIProcess::asXPCImpl(MIDIProcess *this)
{
  return 0;
}

void MIDIProcessMIG::~MIDIProcessMIG(MIDIProcessMIG *this)
{
  MIDIProcess::~MIDIProcess(this);
  JUMPOUT(0x1D826BA98);
}

uint64_t MIDIProcessMIG::Initialize(mach_port_t *this)
{
  uint64_t v2;
  const char *v3;
  NSObject *v4;
  os_log_type_t v5;
  int v6;
  mach_port_t v7;
  int v8;
  mach_port_name_t reply_port;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  mach_port_t special_port;
  _BYTE msg[28];
  mach_port_t v17;
  __int128 v18;
  int v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  MIDIProcess::createInThread((MIDIProcess *)this);
  if ((gInMIDIServer & 1) == 0)
  {
    special_port = 0;
    task_get_special_port(*MEMORY[0x1E0C83DA0], 4, &special_port);
    if (bootstrap_look_up(special_port, "com.apple.midiserver", this + 113))
    {
      gMIDIClientLog();
      v2 = gMIDIClientLog(void)::clilib;
      if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)msg = 136315650;
        *(_QWORD *)&msg[4] = "MIDIProcessMIG.cpp";
        *(_WORD *)&msg[12] = 1024;
        *(_DWORD *)&msg[14] = 104;
        *(_WORD *)&msg[18] = 2080;
        *(_QWORD *)&msg[20] = "com.apple.midiserver";
        v3 = "%25s:%-5d Couldn't connect to %s; CoreMIDI will not be usable";
        v4 = v2;
        v5 = OS_LOG_TYPE_ERROR;
LABEL_25:
        _os_log_impl(&dword_1D4E88000, v4, v5, v3, msg, 0x1Cu);
        return 0;
      }
      return 0;
    }
  }
  v6 = *(_DWORD *)((**(uint64_t (***)(mach_port_t *))this)(this) + 452);
  v7 = this[112];
  v8 = **((_DWORD **)this + 2);
  v18 = 0u;
  memset(&msg[4], 0, 20);
  *(_DWORD *)&msg[24] = 2;
  v17 = v7;
  DWORD1(v18) = 1245184;
  DWORD2(v18) = v8;
  v19 = 1245184;
  v20 = *MEMORY[0x1E0C804E8];
  v21 = 0;
  v22 = 0;
  reply_port = mig_get_reply_port();
  *(_DWORD *)&msg[8] = v6;
  *(_DWORD *)&msg[12] = reply_port;
  *(_DWORD *)msg = -2147478253;
  *(_QWORD *)&msg[16] = 0x1F4000000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set((mach_msg_header_t *)msg);
    reply_port = *(_DWORD *)&msg[12];
  }
  v10 = mach_msg((mach_msg_header_t *)msg, 275, 0x44u, 0x2Cu, reply_port, 0x493E0u, 0);
  v11 = v10;
  if ((v10 - 268435458) <= 0xE && ((1 << (v10 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(*(mach_port_t *)&msg[12]);
  }
  else
  {
    if (!(_DWORD)v10)
    {
      if (*(_DWORD *)&msg[20] == 71)
      {
        v12 = 4294966988;
      }
      else if (*(_DWORD *)&msg[20] == 8100)
      {
        v12 = 4294966996;
        if ((*(_DWORD *)msg & 0x80000000) == 0 && *(_DWORD *)&msg[4] == 36 && !*(_DWORD *)&msg[8])
        {
          v12 = v18;
          if (!(_DWORD)v18)
            goto LABEL_23;
        }
      }
      else
      {
        v12 = 4294966995;
      }
LABEL_29:
      mach_msg_destroy((mach_msg_header_t *)msg);
      return v12;
    }
    mig_dealloc_reply_port(*(mach_port_t *)&msg[12]);
  }
  v12 = 268435460;
  if ((_DWORD)v11 == 268435460)
  {
    if ((*(_WORD *)msg & 0x1F00) == 0x1100)
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], *(mach_port_name_t *)&msg[12]);
    goto LABEL_29;
  }
  if (!(_DWORD)v11)
  {
LABEL_23:
    MIDIProcess::createOutPort((mach_port_name_t **)this);
    MIDIProcess::setupIOBuffers((MIDIProcess *)this);
    gMIDIClientLog();
    v13 = gMIDIClientLog(void)::clilib;
    if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)msg = 136315650;
      *(_QWORD *)&msg[4] = "MIDIProcessMIG.cpp";
      *(_WORD *)&msg[12] = 1024;
      *(_DWORD *)&msg[14] = 121;
      *(_WORD *)&msg[18] = 2048;
      *(_QWORD *)&msg[20] = this;
      v3 = "%25s:%-5d [-] MIDIProcess(%p)::Initialize()";
      v4 = v13;
      v5 = OS_LOG_TYPE_INFO;
      goto LABEL_25;
    }
    return 0;
  }
  return v11;
}

uint64_t MIDIProcessMIG::Uninitialize(MIDIProcessMIG *this)
{
  mach_port_name_t **v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t result;

  *((_BYTE *)this + 13) = 1;
  if (*((_DWORD *)this + 113))
    *((_DWORD *)this + 113) = 0;
  v2 = (mach_port_name_t **)((char *)this + 24);
  if (*((_QWORD *)this + 3))
    std::unique_ptr<XClientMachPort>::reset[abi:ne180100](v2, 0);
  *((_DWORD *)this + 112) = 0;
  CADeprecated::XThread::Stop(*((CADeprecated::XThread **)this + 4));
  v3 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = *((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  result = *((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void MIDIProcessMIG::SetCallbackRunLoop(MIDIProcessMIG *this, void *cf)
{
  __CFRunLoop *v4;
  const __CFString *v5;

  v4 = (__CFRunLoop *)*((_QWORD *)this + 55);
  v5 = (const __CFString *)*MEMORY[0x1E0C9B270];
  if (v4)
  {
    CFRunLoopRemoveSource(v4, *((CFRunLoopSourceRef *)this + 54), (CFRunLoopMode)*MEMORY[0x1E0C9B270]);
    CFRelease(*((CFTypeRef *)this + 55));
  }
  *((_QWORD *)this + 55) = cf;
  CFRetain(cf);
  CFRunLoopAddSource((CFRunLoopRef)cf, *((CFRunLoopSourceRef *)this + 54), v5);
}

uint64_t MIDIProcessMIG::InitOnce(MIDIProcessMIG *this)
{
  unint64_t v2;
  MIDIProcessMIG *v4;
  MIDIProcessMIG ***v5;
  MIDIProcessMIG **v6;

  v4 = this;
  v2 = atomic_load(&MIDIProcessMIG::InitOnce(void)::onceflag);
  if (v2 != -1)
  {
    v6 = &v4;
    v5 = &v6;
    std::__call_once(&MIDIProcessMIG::InitOnce(void)::onceflag, &v5, (void (__cdecl *)(void *))std::__call_once_proxy[abi:ne180100]<std::tuple<MIDIProcessMIG::InitOnce(void)::$_0 &&>>);
  }
  return *((unsigned int *)this + 2);
}

CFDataRef MIDIProcessMIG::GetObjectTree(MIDIProcessMIG *this, int *a2)
{
  int v3;
  mach_port_name_t reply_port;
  mach_msg_return_t v5;
  int v6;
  int v7;
  CFDataRef v8;
  CFIndex v9;
  const UInt8 *v10;
  _BYTE msg[64];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v3 = *(_DWORD *)((**(uint64_t (***)(MIDIProcessMIG *))this)(this) + 452);
  memset(&msg[20], 0, 44);
  *(_OWORD *)&msg[4] = 0u;
  *(_QWORD *)&msg[24] = *MEMORY[0x1E0C804E8];
  reply_port = mig_get_reply_port();
  *(_DWORD *)&msg[8] = v3;
  *(_DWORD *)&msg[12] = reply_port;
  *(_DWORD *)msg = 5395;
  *(_QWORD *)&msg[16] = 0x1F4900000000;
  if (MEMORY[0x1E0C85B60])
  {
    voucher_mach_msg_set((mach_msg_header_t *)msg);
    reply_port = *(_DWORD *)&msg[12];
  }
  v5 = mach_msg((mach_msg_header_t *)msg, 275, 0x24u, 0x40u, reply_port, 0x493E0u, 0);
  v6 = v5;
  if ((v5 - 268435458) <= 0xE && ((1 << (v5 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(*(mach_port_t *)&msg[12]);
  }
  else
  {
    if (!v5)
    {
      if (*(_DWORD *)&msg[20] == 71)
      {
        v7 = -308;
      }
      else if (*(_DWORD *)&msg[20] == 8109)
      {
        if ((*(_DWORD *)msg & 0x80000000) == 0)
        {
          if (*(_DWORD *)&msg[4] == 36)
          {
            v7 = -300;
            if (*(_DWORD *)&msg[32])
            {
              if (*(_DWORD *)&msg[8])
                v7 = -300;
              else
                v7 = *(_DWORD *)&msg[32];
            }
          }
          else
          {
            v7 = -300;
          }
          goto LABEL_29;
        }
        v7 = -300;
        if (*(_DWORD *)&msg[24] == 1 && *(_DWORD *)&msg[4] == 56 && !*(_DWORD *)&msg[8] && msg[39] == 1)
        {
          v9 = *(unsigned int *)&msg[40];
          if (*(_DWORD *)&msg[40] == *(_DWORD *)&msg[52])
          {
            v10 = *(const UInt8 **)&msg[28];
            *a2 = 0;
            *(_QWORD *)msg = v10;
            *(_DWORD *)&msg[8] = v9;
            *(_DWORD *)&msg[12] = 0;
            *(_QWORD *)&msg[16] = 0;
            v8 = CFDataCreate(0, v10, v9);
            IPCBufferReader::~IPCBufferReader((IPCBufferReader *)msg);
            return v8;
          }
        }
      }
      else
      {
        v7 = -301;
      }
LABEL_29:
      mach_msg_destroy((mach_msg_header_t *)msg);
      v8 = 0;
      *a2 = v7;
      return v8;
    }
    mig_dealloc_reply_port(*(mach_port_t *)&msg[12]);
  }
  v7 = 268435460;
  if (v6 == 268435460)
  {
    if ((*(_WORD *)msg & 0x1F00) == 0x1100)
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], *(mach_port_name_t *)&msg[12]);
    goto LABEL_29;
  }
  v8 = 0;
  *a2 = v6;
  return v8;
}

void sub_1D4EA853C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  IPCBufferReader::~IPCBufferReader((IPCBufferReader *)va);
  _Unwind_Resume(a1);
}

uint64_t std::__call_once_proxy[abi:ne180100]<std::tuple<MIDIProcessMIG::InitOnce(void)::$_0 &&>>(_QWORD ***a1)
{
  _DWORD *v1;
  uint64_t result;

  v1 = (_DWORD *)***a1;
  result = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v1 + 32))(v1);
  v1[2] = result;
  return result;
}

void MIDIProcess::MIDIProcess(MIDIProcess *this)
{
  *(_QWORD *)this = off_1E98B7E50;
  *((_DWORD *)this + 2) = 0;
  *((_WORD *)this + 6) = 0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_QWORD *)this + 6) = 0;
  CADeprecated::CAMutex::CAMutex((MIDIProcess *)((char *)this + 56), "LocalClientList");
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 9) = 0u;
  CADeprecated::CAMutex::CAMutex((MIDIProcess *)((char *)this + 192), "LocalMIDIReceiverList");
  *((_QWORD *)this + 35) = 0;
  CADeprecated::CAMutex::CAMutex((MIDIProcess *)((char *)this + 288), "mObjectCacheLock");
  *((_QWORD *)this + 47) = 0;
  *((_QWORD *)this + 48) = CFDictionaryCreateMutable(0, 0, &kCPtrKeyCallbacks, &kCPtrValueCallbacks);
  *((_QWORD *)this + 49) = CFDictionaryCreateMutable(0, 0, &kCPtrKeyCallbacks, &kCPtrValueCallbacks);
}

void sub_1D4EA8674(_Unwind_Exception *a1)
{
  uint64_t v1;
  mach_port_name_t **v2;
  LocalClientList *v3;
  const void **v4;
  LocalMIDIReceiverList *v5;
  CADeprecated::CAMutex *v6;
  const void **v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v7 = v4;
  TCFDictionaryBase::~TCFDictionaryBase(v7);
  CADeprecated::CAMutex::~CAMutex(v6);
  LocalMIDIReceiverList::~LocalMIDIReceiverList(v5);
  LocalClientList::~LocalClientList(v3);
  v9 = *(_QWORD *)(v1 + 48);
  *(_QWORD *)(v1 + 48) = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  v10 = *(_QWORD *)(v1 + 40);
  *(_QWORD *)(v1 + 40) = 0;
  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
  v11 = *(_QWORD *)(v1 + 32);
  *(_QWORD *)(v1 + 32) = 0;
  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
  std::unique_ptr<XClientMachPort>::reset[abi:ne180100]((mach_port_name_t **)(v1 + 24), 0);
  std::unique_ptr<XServerMachPort>::reset[abi:ne180100](v2, 0);
  _Unwind_Resume(a1);
}

void LocalMIDIReceiverList::~LocalMIDIReceiverList(LocalMIDIReceiverList *this)
{
  const void ***v2;
  const void ***v3;
  const void ***v4;

  v3 = *(const void ****)this;
  v2 = (const void ***)*((_QWORD *)this + 1);
  while (v3 != v2)
  {
    if (*v3)
    {
      LocalMIDIReceiver::~LocalMIDIReceiver(*v3);
      MEMORY[0x1D826BA98]();
      v2 = (const void ***)*((_QWORD *)this + 1);
    }
    ++v3;
  }
  *((_QWORD *)this + 3) = &off_1E98B9D98;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 48));
  v4 = *(const void ****)this;
  if (*(_QWORD *)this)
  {
    *((_QWORD *)this + 1) = v4;
    operator delete(v4);
  }
}

void LocalClientList::~LocalClientList(LocalClientList *this)
{
  void **v2;

  v2 = (void **)((char *)this + 88);
  std::vector<std::shared_ptr<LocalMIDIClient>>::__destroy_vector::operator()[abi:ne180100](&v2);
  *(_QWORD *)this = &off_1E98B9D98;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 24));
}

mach_port_name_t *std::unique_ptr<XClientMachPort>::reset[abi:ne180100](mach_port_name_t **a1, mach_port_name_t *a2)
{
  mach_port_name_t *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    XClientMachPort::~XClientMachPort(result);
    JUMPOUT(0x1D826BA98);
  }
  return result;
}

mach_port_name_t *std::unique_ptr<XServerMachPort>::reset[abi:ne180100](mach_port_name_t **a1, mach_port_name_t *a2)
{
  mach_port_name_t *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    XServerMachPort::~XServerMachPort(result);
    JUMPOUT(0x1D826BA98);
  }
  return result;
}

void XClientMachPort::~XClientMachPort(mach_port_name_t *this)
{
  if (*this)
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], *this);
}

void std::vector<std::shared_ptr<LocalMIDIClient>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        v4 = std::shared_ptr<swix::connection::state>::~shared_ptr[abi:ne180100](v4 - 16);
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void TCFDictionaryBase::~TCFDictionaryBase(const void **this)
{
  const void *v1;

  v1 = *this;
  if (v1)
    CFRelease(v1);
}

void MIDIProcessMIG::MIDIProcessMIG(MIDIProcessMIG *this)
{
  ipc_space_t *v1;
  CFRunLoopRef Current;

  MIDIProcess::MIDIProcess((MIDIProcess *)&MIDIProcess::defaultInstance(int)::migImpl);
  MIDIProcess::defaultInstance(int)::migImpl = (uint64_t)off_1E98B7FD8;
  qword_1EFEFDB78 = 0;
  *(_QWORD *)&dword_1EFEFDB80 = 0;
  qword_1EFEFDB70 = 0;
  _InitMIDIProperties();
  v1 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
  mach_port_allocate(*MEMORY[0x1E0C83DA0], 1u, (mach_port_name_t *)&dword_1EFEFDB80);
  mach_port_insert_right(*v1, dword_1EFEFDB80, dword_1EFEFDB80, 0x14u);
  qword_1EFEFDB70 = (uint64_t)MSHCreateMIGServerSource((uint64_t)&MIDIClientCallbackListener_MIDIClientCallbacks_subsystem, 0, dword_1EFEFDB80, (uint64_t)&MIDIProcess::defaultInstance(int)::migImpl);
  Current = CFRunLoopGetCurrent();
  (*(void (**)(uint64_t *, CFRunLoopRef))(MIDIProcess::defaultInstance(int)::migImpl + 48))(&MIDIProcess::defaultInstance(int)::migImpl, Current);
  MIDIProcess::createInPort((mach_port_name_t **)&MIDIProcess::defaultInstance(int)::migImpl);
}

void sub_1D4EA8A08(_Unwind_Exception *a1)
{
  MIDIProcess::~MIDIProcess((MIDIProcess *)MIDIProcess::defaultInstance(int)::migImpl);
  _Unwind_Resume(a1);
}

void sub_1D4EA8B60(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1D4EA8BEC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1D4EA8D68(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1D4EA8EC4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1D4EA8F88(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1D4EA9148(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  v6 = v4;

  _Unwind_Resume(a1);
}

void sub_1D4EA91FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1D4EA9514(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1D4EA9660(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1D4EA9798(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1D4EA98BC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1D4EA9E94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  void *v12;
  void *v13;
  void *v14;

  _Unwind_Resume(a1);
}

void sub_1D4EA9FE4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1D4EAA05C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  v3 = v2;

  _Unwind_Resume(a1);
}

void sub_1D4EAA1F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

void sub_1D4EAA4D4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void gSessionManager(void)
{
  unsigned __int8 v0;

  if ((v0 & 1) == 0)
  {
    {
      caulk::log_category::log_category((caulk::log_category *)&gSessionManager(void)::cisrvr, "com.apple.coremidi", "cisrvr");
    }
  }
}

void MIDICIMUIDList::~MIDICIMUIDList(MIDICIMUIDList *this)
{
  void *v2;
  void *v3;

  v2 = (void *)*((_QWORD *)this + 14);
  if (v2)
  {
    *((_QWORD *)this + 15) = v2;
    operator delete(v2);
  }
  *((_QWORD *)this + 3) = &off_1E98B9D98;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 48));
  v3 = *(void **)this;
  if (*(_QWORD *)this)
  {
    *((_QWORD *)this + 1) = v3;
    operator delete(v3);
  }
}

void MIDICISessionList::~MIDICISessionList(MIDICISessionList *this)
{
  *(_QWORD *)this = &off_1E98B99C0;
  OwnedPtrVector<MIDICIServerSession *>::~OwnedPtrVector((uint64_t)this + 120);
  *((_QWORD *)this + 4) = &off_1E98B9D98;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 56));
  OwnedPtrVector<MIDICIServerSession *>::~OwnedPtrVector((uint64_t)this);
}

{
  MIDICISessionList::~MIDICISessionList(this);
  JUMPOUT(0x1D826BA98);
}

uint64_t OwnedPtrVector<MIDICIServerSession *>::~OwnedPtrVector(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = &off_1E98B9810;
  OwnedPtrVector<MIDICIServerSession *>::erase((_QWORD *)a1, *(uint64_t **)(a1 + 8), *(uint64_t **)(a1 + 16));
  v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(_QWORD *)(a1 + 16) = v2;
    operator delete(v2);
  }
  return a1;
}

_QWORD *OwnedPtrVector<MIDICIServerSession *>::erase(_QWORD *result, uint64_t *__dst, uint64_t *__src)
{
  _QWORD *v5;
  uint64_t *v6;
  uint64_t *v7;
  int64_t v8;

  if (__dst != __src)
  {
    v5 = result;
    v6 = __dst;
    do
    {
      result = (_QWORD *)*v6;
      if (*v6)
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 8))(result);
      ++v6;
    }
    while (v6 != __src);
    v7 = (uint64_t *)v5[2];
    v8 = (char *)v7 - (char *)__src;
    if (v7 != __src)
      result = memmove(__dst, __src, (char *)v7 - (char *)__src);
    v5[2] = (char *)__dst + v8;
  }
  return result;
}

void OwnedPtrVector<MIDICIServerSession *>::~OwnedPtrVector(uint64_t a1)
{
  OwnedPtrVector<MIDICIServerSession *>::~OwnedPtrVector(a1);
  JUMPOUT(0x1D826BA98);
}

uint64_t SynchronizedListManager<MIDICIServerResponder>::AddShared(uint64_t a1, uint64_t *a2)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  int v7;
  int v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  _QWORD *v17;
  char *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  char *v24;
  __int128 v25;
  unint64_t *v26;
  unint64_t v27;
  char *v28;
  __int128 v29;
  int64x2_t v30;
  uint64_t v31;
  void *v32;
  uint64_t v34;
  std::__shared_weak_count *v35;

  v4 = (std::__shared_weak_count *)a2[1];
  v34 = *a2;
  v35 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 24))(a1, &v34);
  v8 = v7;
  v9 = v35;
  if (!v35)
    goto LABEL_8;
  v10 = (unint64_t *)&v35->__shared_owners_;
  do
    v11 = __ldaxr(v10);
  while (__stlxr(v11 - 1, v10));
  if (!v11)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    if ((v8 & 1) != 0)
      return v8 ^ 1u;
  }
  else
  {
LABEL_8:
    if ((v7 & 1) != 0)
      return v8 ^ 1u;
  }
  std::recursive_mutex::lock(*(std::recursive_mutex **)(a1 + 8));
  v13 = *(char **)(a1 + 32);
  v12 = *(_QWORD *)(a1 + 40);
  if ((unint64_t)v13 >= v12)
  {
    v18 = *(char **)(a1 + 24);
    v19 = (v13 - v18) >> 4;
    v20 = v19 + 1;
    if ((unint64_t)(v19 + 1) >> 60)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v21 = v12 - (_QWORD)v18;
    if (v21 >> 3 > v20)
      v20 = v21 >> 3;
    if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF0)
      v22 = 0xFFFFFFFFFFFFFFFLL;
    else
      v22 = v20;
    if (v22 >> 60)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v23 = (char *)operator new(16 * v22);
    v24 = &v23[16 * v19];
    v25 = *(_OWORD *)a2;
    *(_OWORD *)v24 = *(_OWORD *)a2;
    if (*((_QWORD *)&v25 + 1))
    {
      v26 = (unint64_t *)(*((_QWORD *)&v25 + 1) + 8);
      do
        v27 = __ldxr(v26);
      while (__stxr(v27 + 1, v26));
      v18 = *(char **)(a1 + 24);
      v13 = *(char **)(a1 + 32);
    }
    if (v13 == v18)
    {
      v30 = vdupq_n_s64((unint64_t)v13);
      v28 = &v23[16 * v19];
    }
    else
    {
      v28 = &v23[16 * v19];
      do
      {
        v29 = *((_OWORD *)v13 - 1);
        v13 -= 16;
        *((_OWORD *)v28 - 1) = v29;
        v28 -= 16;
        *(_QWORD *)v13 = 0;
        *((_QWORD *)v13 + 1) = 0;
      }
      while (v13 != v18);
      v30 = *(int64x2_t *)(a1 + 24);
    }
    v17 = v24 + 16;
    *(_QWORD *)(a1 + 24) = v28;
    *(_QWORD *)(a1 + 32) = v24 + 16;
    *(_QWORD *)(a1 + 40) = &v23[16 * v22];
    v31 = v30.i64[1];
    v32 = (void *)v30.i64[0];
    while ((void *)v31 != v32)
      v31 = std::shared_ptr<swix::connection::state>::~shared_ptr[abi:ne180100](v31 - 16);
    if (v32)
      operator delete(v32);
  }
  else
  {
    v14 = a2[1];
    *(_QWORD *)v13 = *a2;
    *((_QWORD *)v13 + 1) = v14;
    if (v14)
    {
      v15 = (unint64_t *)(v14 + 8);
      do
        v16 = __ldxr(v15);
      while (__stxr(v16 + 1, v15));
    }
    v17 = v13 + 16;
  }
  *(_QWORD *)(a1 + 32) = v17;
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(a1 + 8));
  return v8 ^ 1u;
}

void sub_1D4EAAB08(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::recursive_mutex::unlock(*(std::recursive_mutex **)(v1 + 8));
  _Unwind_Resume(a1);
}

BOOL SynchronizedListManager<MIDICIServerResponder>::RemoveShared(uint64_t a1, uint64_t *a2)
{
  __int128 *v4;
  __int128 *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  __int128 *i;
  unint64_t *v11;
  unint64_t v12;
  __int128 *v13;

  std::recursive_mutex::lock(*(std::recursive_mutex **)(a1 + 8));
  v4 = *(__int128 **)(a1 + 24);
  std::recursive_mutex::lock(*(std::recursive_mutex **)(a1 + 8));
  v5 = *(__int128 **)(a1 + 32);
  v7 = *a2;
  v6 = (std::__shared_weak_count *)a2[1];
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  if (v4 != v5)
  {
    while (*(_QWORD *)v4 != v7)
    {
      if (++v4 == v5)
      {
        v4 = v5;
        goto LABEL_14;
      }
    }
    if (v4 != v5)
    {
      for (i = v4 + 1; i != v5; ++i)
      {
        if (*(_QWORD *)i != v7)
          std::shared_ptr<MIDICIServerResponder>::operator=[abi:ne180100]((uint64_t)v4++, i);
      }
    }
  }
LABEL_14:
  if (v6)
  {
    v11 = (unint64_t *)&v6->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(a1 + 8));
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(a1 + 8));
  std::recursive_mutex::lock(*(std::recursive_mutex **)(a1 + 8));
  v13 = *(__int128 **)(a1 + 32);
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(a1 + 8));
  std::recursive_mutex::lock(*(std::recursive_mutex **)(a1 + 8));
  std::recursive_mutex::lock(*(std::recursive_mutex **)(a1 + 8));
  std::vector<std::shared_ptr<MIDICIServerResponder>>::erase(a1 + 24, (uint64_t)v4, *(_QWORD *)(a1 + 32));
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(a1 + 8));
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(a1 + 8));
  return v13 != v4;
}

void sub_1D4EAAC90(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::recursive_mutex::unlock(*(std::recursive_mutex **)(v1 + 8));
  _Unwind_Resume(a1);
}

BOOL SynchronizedListManager<MIDICIServerResponder>::Matches(uint64_t a1, uint64_t a2)
{
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  BOOL v10;
  unint64_t *v11;
  unint64_t v12;
  _BOOL8 v13;

  std::recursive_mutex::lock(*(std::recursive_mutex **)(a1 + 8));
  v4 = *(uint64_t **)(a1 + 24);
  std::recursive_mutex::lock(*(std::recursive_mutex **)(a1 + 8));
  v5 = *(uint64_t **)(a1 + 32);
  if (v4 != v5)
  {
    while (1)
    {
      v6 = *v4;
      v7 = (std::__shared_weak_count *)v4[1];
      if (v7)
      {
        p_shared_owners = (unint64_t *)&v7->__shared_owners_;
        do
          v9 = __ldxr(p_shared_owners);
        while (__stxr(v9 + 1, p_shared_owners));
      }
      if (*(_DWORD *)(v6 + 84) == *(_DWORD *)(a2 + 84))
      {
        v10 = *(_DWORD *)(v6 + 108) == *(_DWORD *)(a2 + 108);
        if (v7)
          goto LABEL_9;
      }
      else
      {
        v10 = 0;
        if (v7)
        {
LABEL_9:
          v11 = (unint64_t *)&v7->__shared_owners_;
          do
            v12 = __ldaxr(v11);
          while (__stlxr(v12 - 1, v11));
          if (!v12)
          {
            ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
            std::__shared_weak_count::__release_weak(v7);
          }
        }
      }
      if (v10)
        break;
      v4 += 2;
      if (v4 == v5)
      {
        v4 = v5;
        break;
      }
    }
  }
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(a1 + 8));
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(a1 + 8));
  std::recursive_mutex::lock(*(std::recursive_mutex **)(a1 + 8));
  v13 = v4 != *(uint64_t **)(a1 + 32);
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(a1 + 8));
  return v13;
}

void sub_1D4EAADB8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::recursive_mutex::unlock(*(std::recursive_mutex **)(v1 + 8));
  _Unwind_Resume(a1);
}

BOOL SynchronizedListManager<MIDICIServerResponder>::ContainsShared(uint64_t a1, uint64_t *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  _BOOL8 v12;

  std::recursive_mutex::lock(*(std::recursive_mutex **)(a1 + 8));
  v4 = *(_QWORD **)(a1 + 24);
  std::recursive_mutex::lock(*(std::recursive_mutex **)(a1 + 8));
  v5 = *(_QWORD **)(a1 + 32);
  v6 = *a2;
  v7 = (std::__shared_weak_count *)a2[1];
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  if (v4 != v5)
  {
    while (*v4 != v6)
    {
      v4 += 2;
      if (v4 == v5)
      {
        v4 = v5;
        break;
      }
    }
  }
  if (v7)
  {
    v10 = (unint64_t *)&v7->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(a1 + 8));
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(a1 + 8));
  std::recursive_mutex::lock(*(std::recursive_mutex **)(a1 + 8));
  v12 = v4 != *(_QWORD **)(a1 + 32);
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(a1 + 8));
  return v12;
}

void sub_1D4EAAEB0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::recursive_mutex::unlock(*(std::recursive_mutex **)(v1 + 8));
  _Unwind_Resume(a1);
}

void SynchronizedListManager<MIDICIServerResponder>::Clear(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  std::recursive_mutex::lock(*(std::recursive_mutex **)(a1 + 8));
  v3 = *(_QWORD *)(a1 + 24);
  for (i = *(_QWORD *)(a1 + 32); i != v3; i = std::shared_ptr<swix::connection::state>::~shared_ptr[abi:ne180100](i - 16))
    ;
  *(_QWORD *)(a1 + 32) = v3;
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(a1 + 8));
}

uint64_t SynchronizedListManager<MIDICIServerResponder>::Size(uint64_t a1)
{
  uint64_t v2;

  std::recursive_mutex::lock(*(std::recursive_mutex **)(a1 + 8));
  v2 = (uint64_t)(*(_QWORD *)(a1 + 32) - *(_QWORD *)(a1 + 24)) >> 4;
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(a1 + 8));
  return v2;
}

BOOL SynchronizedListManager<MIDICIServerResponder>::Empty(uint64_t a1)
{
  _BOOL8 v2;

  std::recursive_mutex::lock(*(std::recursive_mutex **)(a1 + 8));
  v2 = *(_QWORD *)(a1 + 24) == *(_QWORD *)(a1 + 32);
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(a1 + 8));
  return v2;
}

uint64_t std::vector<std::shared_ptr<MIDICIServerResponder>>::erase(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (a2 != a3)
  {
    v3 = a2;
    v4 = result;
    result = a3;
    v5 = *(_QWORD *)(v4 + 8);
    if (a3 != v5)
    {
      v6 = 16 * ((a3 - a2) >> 4);
      do
      {
        std::shared_ptr<MIDICIServerResponder>::operator=[abi:ne180100](v3, (__int128 *)(v3 + v6));
        v3 += 16;
      }
      while (v3 + v6 != v5);
      result = *(_QWORD *)(v4 + 8);
    }
    while (result != v3)
      result = std::shared_ptr<swix::connection::state>::~shared_ptr[abi:ne180100](result - 16);
    *(_QWORD *)(v4 + 8) = v3;
  }
  return result;
}

uint64_t std::shared_ptr<MIDICIServerResponder>::operator=[abi:ne180100](uint64_t a1, __int128 *a2)
{
  __int128 v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;

  v3 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v4 = *(std::__shared_weak_count **)(a1 + 8);
  *(_OWORD *)a1 = v3;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return a1;
}

uint64_t SynchronizedListManager<MIDICIPeer>::AddShared(uint64_t a1, uint64_t *a2)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  int v7;
  int v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  _QWORD *v17;
  char *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  char *v24;
  __int128 v25;
  unint64_t *v26;
  unint64_t v27;
  char *v28;
  __int128 v29;
  int64x2_t v30;
  uint64_t v31;
  void *v32;
  uint64_t v34;
  std::__shared_weak_count *v35;

  v4 = (std::__shared_weak_count *)a2[1];
  v34 = *a2;
  v35 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 24))(a1, &v34);
  v8 = v7;
  v9 = v35;
  if (!v35)
    goto LABEL_8;
  v10 = (unint64_t *)&v35->__shared_owners_;
  do
    v11 = __ldaxr(v10);
  while (__stlxr(v11 - 1, v10));
  if (!v11)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    if ((v8 & 1) != 0)
      return v8 ^ 1u;
  }
  else
  {
LABEL_8:
    if ((v7 & 1) != 0)
      return v8 ^ 1u;
  }
  std::recursive_mutex::lock(*(std::recursive_mutex **)(a1 + 8));
  v13 = *(char **)(a1 + 32);
  v12 = *(_QWORD *)(a1 + 40);
  if ((unint64_t)v13 >= v12)
  {
    v18 = *(char **)(a1 + 24);
    v19 = (v13 - v18) >> 4;
    v20 = v19 + 1;
    if ((unint64_t)(v19 + 1) >> 60)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v21 = v12 - (_QWORD)v18;
    if (v21 >> 3 > v20)
      v20 = v21 >> 3;
    if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF0)
      v22 = 0xFFFFFFFFFFFFFFFLL;
    else
      v22 = v20;
    if (v22 >> 60)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v23 = (char *)operator new(16 * v22);
    v24 = &v23[16 * v19];
    v25 = *(_OWORD *)a2;
    *(_OWORD *)v24 = *(_OWORD *)a2;
    if (*((_QWORD *)&v25 + 1))
    {
      v26 = (unint64_t *)(*((_QWORD *)&v25 + 1) + 8);
      do
        v27 = __ldxr(v26);
      while (__stxr(v27 + 1, v26));
      v18 = *(char **)(a1 + 24);
      v13 = *(char **)(a1 + 32);
    }
    if (v13 == v18)
    {
      v30 = vdupq_n_s64((unint64_t)v13);
      v28 = &v23[16 * v19];
    }
    else
    {
      v28 = &v23[16 * v19];
      do
      {
        v29 = *((_OWORD *)v13 - 1);
        v13 -= 16;
        *((_OWORD *)v28 - 1) = v29;
        v28 -= 16;
        *(_QWORD *)v13 = 0;
        *((_QWORD *)v13 + 1) = 0;
      }
      while (v13 != v18);
      v30 = *(int64x2_t *)(a1 + 24);
    }
    v17 = v24 + 16;
    *(_QWORD *)(a1 + 24) = v28;
    *(_QWORD *)(a1 + 32) = v24 + 16;
    *(_QWORD *)(a1 + 40) = &v23[16 * v22];
    v31 = v30.i64[1];
    v32 = (void *)v30.i64[0];
    while ((void *)v31 != v32)
      v31 = std::shared_ptr<swix::connection::state>::~shared_ptr[abi:ne180100](v31 - 16);
    if (v32)
      operator delete(v32);
  }
  else
  {
    v14 = a2[1];
    *(_QWORD *)v13 = *a2;
    *((_QWORD *)v13 + 1) = v14;
    if (v14)
    {
      v15 = (unint64_t *)(v14 + 8);
      do
        v16 = __ldxr(v15);
      while (__stxr(v16 + 1, v15));
    }
    v17 = v13 + 16;
  }
  *(_QWORD *)(a1 + 32) = v17;
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(a1 + 8));
  return v8 ^ 1u;
}

void sub_1D4EAB25C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::recursive_mutex::unlock(*(std::recursive_mutex **)(v1 + 8));
  _Unwind_Resume(a1);
}

BOOL SynchronizedListManager<MIDICIPeer>::RemoveShared(uint64_t a1, uint64_t *a2)
{
  __int128 *v4;
  __int128 *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  __int128 *i;
  unint64_t *v11;
  unint64_t v12;
  __int128 *v13;
  uint64_t v14;

  std::recursive_mutex::lock(*(std::recursive_mutex **)(a1 + 8));
  v4 = *(__int128 **)(a1 + 24);
  std::recursive_mutex::lock(*(std::recursive_mutex **)(a1 + 8));
  v5 = *(__int128 **)(a1 + 32);
  v7 = *a2;
  v6 = (std::__shared_weak_count *)a2[1];
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  if (v4 != v5)
  {
    while (*(_QWORD *)v4 != v7)
    {
      if (++v4 == v5)
      {
        v4 = v5;
        goto LABEL_14;
      }
    }
    if (v4 != v5)
    {
      for (i = v4 + 1; i != v5; ++i)
      {
        if (*(_QWORD *)i != v7)
          std::shared_ptr<MIDICIServerResponder>::operator=[abi:ne180100]((uint64_t)v4++, i);
      }
    }
  }
LABEL_14:
  if (v6)
  {
    v11 = (unint64_t *)&v6->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(a1 + 8));
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(a1 + 8));
  std::recursive_mutex::lock(*(std::recursive_mutex **)(a1 + 8));
  v13 = *(__int128 **)(a1 + 32);
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(a1 + 8));
  std::recursive_mutex::lock(*(std::recursive_mutex **)(a1 + 8));
  std::recursive_mutex::lock(*(std::recursive_mutex **)(a1 + 8));
  v14 = *(_QWORD *)(a1 + 32);
  if (v4 != (__int128 *)v14)
  {
    while ((__int128 *)v14 != v4)
    {
      v14 -= 16;
      std::shared_ptr<swix::connection::state>::~shared_ptr[abi:ne180100](v14);
    }
    *(_QWORD *)(a1 + 32) = v4;
  }
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(a1 + 8));
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(a1 + 8));
  return v13 != v4;
}

void sub_1D4EAB434(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::recursive_mutex::unlock(*(std::recursive_mutex **)(v1 + 8));
  _Unwind_Resume(a1);
}

BOOL SynchronizedListManager<MIDICIPeer>::Matches(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  _DWORD *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  BOOL v10;
  unint64_t *v11;
  unint64_t v12;
  _BOOL8 v13;

  std::recursive_mutex::lock(*(std::recursive_mutex **)(a1 + 8));
  v4 = *(_QWORD *)(a1 + 24);
  std::recursive_mutex::lock(*(std::recursive_mutex **)(a1 + 8));
  v5 = *(_QWORD *)(a1 + 32);
  if (v4 != v5)
  {
    while (1)
    {
      v6 = *(_DWORD **)v4;
      v7 = *(std::__shared_weak_count **)(v4 + 8);
      if (v7)
      {
        p_shared_owners = (unint64_t *)&v7->__shared_owners_;
        do
          v9 = __ldxr(p_shared_owners);
        while (__stxr(v9 + 1, p_shared_owners));
      }
      if (*v6 == *a2)
      {
        v10 = v6[6] == a2[6];
        if (v7)
          goto LABEL_9;
      }
      else
      {
        v10 = 0;
        if (v7)
        {
LABEL_9:
          v11 = (unint64_t *)&v7->__shared_owners_;
          do
            v12 = __ldaxr(v11);
          while (__stlxr(v12 - 1, v11));
          if (!v12)
          {
            ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
            std::__shared_weak_count::__release_weak(v7);
          }
        }
      }
      if (v10)
        break;
      v4 += 16;
      if (v4 == v5)
      {
        v4 = v5;
        break;
      }
    }
  }
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(a1 + 8));
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(a1 + 8));
  std::recursive_mutex::lock(*(std::recursive_mutex **)(a1 + 8));
  v13 = v4 != *(_QWORD *)(a1 + 32);
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(a1 + 8));
  return v13;
}

void sub_1D4EAB55C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::recursive_mutex::unlock(*(std::recursive_mutex **)(v1 + 8));
  _Unwind_Resume(a1);
}

BOOL SynchronizedListManager<MIDICIPeer>::ContainsShared(uint64_t a1, uint64_t *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  _BOOL8 v12;

  std::recursive_mutex::lock(*(std::recursive_mutex **)(a1 + 8));
  v4 = *(_QWORD **)(a1 + 24);
  std::recursive_mutex::lock(*(std::recursive_mutex **)(a1 + 8));
  v5 = *(_QWORD **)(a1 + 32);
  v6 = *a2;
  v7 = (std::__shared_weak_count *)a2[1];
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  if (v4 != v5)
  {
    while (*v4 != v6)
    {
      v4 += 2;
      if (v4 == v5)
      {
        v4 = v5;
        break;
      }
    }
  }
  if (v7)
  {
    v10 = (unint64_t *)&v7->__shared_owners_;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(a1 + 8));
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(a1 + 8));
  std::recursive_mutex::lock(*(std::recursive_mutex **)(a1 + 8));
  v12 = v4 != *(_QWORD **)(a1 + 32);
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(a1 + 8));
  return v12;
}

void sub_1D4EAB654(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::recursive_mutex::unlock(*(std::recursive_mutex **)(v1 + 8));
  _Unwind_Resume(a1);
}

void SynchronizedListManager<MIDICIPeer>::Clear(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  std::recursive_mutex::lock(*(std::recursive_mutex **)(a1 + 8));
  v3 = *(_QWORD *)(a1 + 24);
  for (i = *(_QWORD *)(a1 + 32); i != v3; i = std::shared_ptr<swix::connection::state>::~shared_ptr[abi:ne180100](i - 16))
    ;
  *(_QWORD *)(a1 + 32) = v3;
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(a1 + 8));
}

uint64_t SynchronizedListManager<MIDICIPeer>::Size(uint64_t a1)
{
  uint64_t v2;

  std::recursive_mutex::lock(*(std::recursive_mutex **)(a1 + 8));
  v2 = (uint64_t)(*(_QWORD *)(a1 + 32) - *(_QWORD *)(a1 + 24)) >> 4;
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(a1 + 8));
  return v2;
}

BOOL SynchronizedListManager<MIDICIPeer>::Empty(uint64_t a1)
{
  _BOOL8 v2;

  std::recursive_mutex::lock(*(std::recursive_mutex **)(a1 + 8));
  v2 = *(_QWORD *)(a1 + 24) == *(_QWORD *)(a1 + 32);
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(a1 + 8));
  return v2;
}

uint64_t MIDICIServerSession::Invalidate(MIDICIServerSession *this)
{
  NSObject *v2;
  uint64_t v3;
  unsigned int v4;
  int v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  NSObject *v11;
  uint32_t v12;
  int16x8_t v13;
  NSObject *v14;
  _OWORD *v15;
  void *v16;
  uint64_t v17;
  int *p_src;
  unsigned int v19;
  _BYTE *v20;
  int v21;
  unsigned int v22;
  int16x8_t v23;
  int v24;
  NSObject *v25;
  uint64_t v26;
  unsigned __int32 v28;
  const char *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  _BYTE v33[10];
  __int16 v34;
  int v35;
  __int16 v36;
  int v37;
  __int16 v38;
  const char *v39;
  __int16 v40;
  uint64_t v41;
  __int16 v42;
  uint64_t v43;
  __int16 v44;
  int v45;
  int __src;
  __int16 v47;
  uint64_t v48;
  char v49[2];
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  gSessionManager();
  v2 = objc_retainAutorelease((id)gSessionManager(void)::cisrvr);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    v28 = 136315650;
    v29 = "MIDICIServerSession.mm";
    v30 = 1024;
    v31 = 269;
    v32 = 2048;
    *(_QWORD *)v33 = this;
    _os_log_impl(&dword_1D4E88000, v2, OS_LOG_TYPE_INFO, "%25s:%-5d [*]MIDICIServerSession(%p)::Invalidate()", (uint8_t *)&v28, 0x1Cu);
  }
  v3 = *((_QWORD *)this + 15);
  v4 = *((_DWORD *)this + 19);
  v5 = *((_DWORD *)this + 20);
  v6 = v3 + 8;
  if (*(_QWORD *)(v3 + 16) != *(_QWORD *)(v3 + 8))
  {
    gCIMsgEmitter();
    v7 = gCIMsgEmitter(void)::ciemit;
    if (os_log_type_enabled((os_log_t)gCIMsgEmitter(void)::ciemit, OS_LOG_TYPE_DEBUG))
    {
      v8 = *(_QWORD *)(v3 + 16) - *(_QWORD *)(v3 + 8);
      v28 = 136315650;
      v29 = "MIDICIMessageEmitter.cpp";
      v30 = 1024;
      v31 = 49;
      v32 = 2048;
      *(_QWORD *)v33 = v8;
      _os_log_impl(&dword_1D4E88000, v7, OS_LOG_TYPE_DEBUG, "%25s:%-5d      Message already has %lu bytes. Checking continuation ...", (uint8_t *)&v28, 0x1Cu);
    }
    if (*(_DWORD *)(v3 + 176) != v4 || *(_DWORD *)(v3 + 180) != v5 || *(_BYTE *)(v3 + 184) != 126)
    {
      gCIMsgEmitter();
      v9 = gCIMsgEmitter(void)::ciemit;
      if (os_log_type_enabled((os_log_t)gCIMsgEmitter(void)::ciemit, OS_LOG_TYPE_ERROR))
      {
        v28 = 136315394;
        v29 = "MIDICIMessageEmitter.cpp";
        v30 = 1024;
        v31 = 52;
        v10 = "%25s:%-5d [!] MIDICIMessageEmitter::CreateCIMessage() can't continue message (kMIDINotPermitted)";
        v11 = v9;
        v12 = 18;
LABEL_34:
        _os_log_impl(&dword_1D4E88000, v11, OS_LOG_TYPE_ERROR, v10, (uint8_t *)&v28, v12);
      }
LABEL_35:
      *(_QWORD *)(v3 + 16) = *(_QWORD *)(v3 + 8);
      return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 15) + 24))(*((_QWORD *)this + 15));
    }
    v28 = 0;
    goto LABEL_23;
  }
  *(_DWORD *)(v3 + 176) = v4;
  *(_DWORD *)(v3 + 180) = 0xFFFFFFF;
  *(_WORD *)(v3 + 184) = 32638;
  __src = 226459376;
  v47 = 382;
  v48 = 0;
  if (!(v4 >> 28))
  {
    v13 = (int16x8_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v4), (uint32x4_t)xmmword_1D4F18A50);
    *(int16x4_t *)v13.i8 = vrev64_s16((int16x4_t)vand_s8((int8x8_t)vmovn_s32((int32x4_t)v13), (int8x8_t)0x7F007F007F007FLL));
    LODWORD(v48) = vmovn_s16(v13).u32[0];
  }
  HIDWORD(v48) = 2139062143;
  gCIMsgEmitter();
  v14 = gCIMsgEmitter(void)::ciemit;
  if (os_log_type_enabled((os_log_t)gCIMsgEmitter(void)::ciemit, OS_LOG_TYPE_DEBUG))
  {
    v15 = operator new(0x30uLL);
    v16 = v15;
    v17 = 0;
    *(_OWORD *)((char *)v15 + 27) = 0u;
    *v15 = 0u;
    v15[1] = 0u;
    p_src = &__src;
    do
    {
      v19 = *(unsigned __int8 *)p_src;
      p_src = (int *)((char *)p_src + 1);
      v20 = (char *)v15 + v17;
      *v20 = MIDIStringDump::hexBytes(std::span<unsigned char const,18446744073709551615ul>)::hex[(unint64_t)v19 >> 4];
      v20[1] = MIDIStringDump::hexBytes(std::span<unsigned char const,18446744073709551615ul>)::hex[v19 & 0xF];
      v20[2] = 32;
      v17 += 3;
    }
    while (v17 != 42);
    v28 = 136315650;
    v29 = "MIDICIMessageEmitter.cpp";
    v30 = 1024;
    v31 = 46;
    v32 = 2080;
    *(_QWORD *)v33 = v15;
    _os_log_impl(&dword_1D4E88000, v14, OS_LOG_TYPE_DEBUG, "%25s:%-5d      new message hdr: %s ...", (uint8_t *)&v28, 0x1Cu);
    operator delete(v16);
  }
  std::vector<unsigned char>::__insert_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(v6, *(char **)(v3 + 16), (char *)&__src, v49, 14);
  v21 = *(unsigned __int8 *)(v3 + 184);
  if ((v21 & 0xFE) != 0x70)
  {
    v28 = 0;
    if ((v21 - 112) < 2)
    {
      std::vector<unsigned char>::__insert_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(v6, *(char **)(v3 + 16), (char *)(v3 + 161), (char *)(v3 + 172), 11);
    }
    else
    {
      if (v21 == 126)
      {
LABEL_23:
        v22 = *(_DWORD *)(v3 + 176);
        if (!(v22 >> 28))
        {
          v23 = (int16x8_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v22), (uint32x4_t)xmmword_1D4F18A50);
          *(int16x4_t *)v23.i8 = vrev64_s16((int16x4_t)vand_s8((int8x8_t)vmovn_s32((int32x4_t)v23), (int8x8_t)0x7F007F007F007FLL));
          v28 = vmovn_s16(v23).u32[0];
        }
        std::vector<unsigned char>::__insert_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(v6, *(char **)(v3 + 16), (char *)&v28, (char *)&v29, 4);
        goto LABEL_26;
      }
      if (v21 == 127)
      {
LABEL_26:
        LOBYTE(__src) = -9;
        std::vector<unsigned char>::__insert_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(v6, *(char **)(v3 + 16), (char *)&__src, (char *)&__src + 1, 1);
        v24 = 0;
        goto LABEL_29;
      }
    }
  }
  v24 = -10844;
LABEL_29:
  gCIMsgEmitter();
  v25 = gCIMsgEmitter(void)::ciemit;
  if (os_log_type_enabled((os_log_t)gCIMsgEmitter(void)::ciemit, OS_LOG_TYPE_DEBUG))
  {
    v28 = 136317442;
    v29 = "MIDICIMessageEmitter.cpp";
    v30 = 1024;
    v31 = 80;
    v32 = 1024;
    *(_DWORD *)v33 = 127;
    *(_WORD *)&v33[4] = 1024;
    *(_DWORD *)&v33[6] = v4;
    v34 = 1024;
    v35 = v5;
    v36 = 1024;
    v37 = 126;
    v38 = 2080;
    v39 = "Invalidate MUID";
    v40 = 2048;
    v41 = 0;
    v42 = 2048;
    v43 = 0;
    v44 = 1024;
    v45 = v24;
    _os_log_impl(&dword_1D4E88000, v25, OS_LOG_TYPE_DEBUG, "%25s:%-5d [*] MIDICIMessageEmitter::CreateCIMessage(channel:0x%x, sourceMUID:0x%08x, destMUID:0x%08x, msgIndex:0x%x (%s), data:%p, length:%lu) = %d", (uint8_t *)&v28, 0x4Eu);
  }
  if (v24)
  {
    gCIMsgEmitter();
    v26 = gCIMsgEmitter(void)::ciemit;
    if (os_log_type_enabled((os_log_t)gCIMsgEmitter(void)::ciemit, OS_LOG_TYPE_ERROR))
    {
      v28 = 136315650;
      v29 = "MIDICIMessageEmitter.cpp";
      v30 = 1024;
      v31 = 83;
      v32 = 1024;
      *(_DWORD *)v33 = v24;
      v10 = "%25s:%-5d [!] MIDICIMessageEmitter::CreateCIMessage() failed with error %d (message will not be sent)";
      v11 = v26;
      v12 = 24;
      goto LABEL_34;
    }
    goto LABEL_35;
  }
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 15) + 24))(*((_QWORD *)this + 15));
}

uint64_t _ZNSt3__115allocate_sharedB8ne180100INS_15recursive_mutexENS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(uint64_t *a1)
{
  _QWORD *v2;
  uint64_t result;

  v2 = operator new(0x58uLL);
  v2[1] = 0;
  v2[2] = 0;
  *v2 = &off_1E98BA078;
  result = MEMORY[0x1D826B960](v2 + 3);
  *a1 = result;
  a1[1] = (uint64_t)v2;
  return result;
}

void sub_1D4EABCD0(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;
  void *v3;

  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void MIDICIMUIDList::MIDICIMUIDList(MIDICIMUIDList *this)
{
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  CADeprecated::CAMutex::CAMutex((MIDICIMUIDList *)((char *)this + 24), "MIDICIMUIDList");
  *((_QWORD *)this + 14) = 0;
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 16) = 0;
}

void sub_1D4EABD28(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

BOOL MIDICIMUIDList::Add(MIDICIMUIDList *this, int a2)
{
  _QWORD *v4;
  int v5;
  char *v6;
  char *v7;
  char *v8;
  unint64_t v9;
  _DWORD *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  BOOL v14;
  unint64_t v15;
  uint64_t v16;
  char *v17;
  _DWORD *v18;
  unint64_t v19;
  int v20;

  v4 = (_QWORD *)((char *)this + 24);
  v5 = (*(uint64_t (**)(char *))(*((_QWORD *)this + 3) + 16))((char *)this + 24);
  v6 = (char *)v4[11];
  v7 = (char *)v4[12];
  if (v6 == v7)
  {
LABEL_5:
    v8 = (char *)v4[12];
  }
  else
  {
    v8 = (char *)v4[11];
    while (*(_DWORD *)v8 != a2)
    {
      v8 += 4;
      if (v8 == v7)
        goto LABEL_5;
    }
  }
  if (v7 != v8)
  {
    if (!v5)
      return v7 == v8;
    goto LABEL_25;
  }
  v9 = *((_QWORD *)this + 16);
  if ((unint64_t)v7 >= v9)
  {
    v11 = (v7 - v6) >> 2;
    v12 = v11 + 1;
    if ((unint64_t)(v11 + 1) >> 62)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v13 = v9 - (_QWORD)v6;
    if (v13 >> 1 > v12)
      v12 = v13 >> 1;
    v14 = (unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL;
    v15 = 0x3FFFFFFFFFFFFFFFLL;
    if (!v14)
      v15 = v12;
    if (v15)
    {
      v15 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(v15);
      v6 = (char *)*((_QWORD *)this + 14);
      v17 = (char *)*((_QWORD *)this + 15);
    }
    else
    {
      v16 = 0;
      v17 = (char *)v4[12];
    }
    v18 = (_DWORD *)(v15 + 4 * v11);
    v19 = v15 + 4 * v16;
    *v18 = a2;
    v10 = v18 + 1;
    while (v17 != v6)
    {
      v20 = *((_DWORD *)v17 - 1);
      v17 -= 4;
      *--v18 = v20;
    }
    *((_QWORD *)this + 14) = v18;
    *((_QWORD *)this + 15) = v10;
    *((_QWORD *)this + 16) = v19;
    if (v6)
      operator delete(v6);
  }
  else
  {
    *(_DWORD *)v7 = a2;
    v10 = v7 + 4;
  }
  *((_QWORD *)this + 15) = v10;
  if (v5)
LABEL_25:
    (*(void (**)(_QWORD *))(*v4 + 24))(v4);
  return v7 == v8;
}

void sub_1D4EABE98(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  char v2;

  if ((v2 & 1) != 0)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_emplace<std::recursive_mutex>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E98BA078;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::recursive_mutex>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E98BA078;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D826BA98);
}

void std::__shared_ptr_emplace<std::recursive_mutex>::__on_zero_shared(uint64_t a1)
{
  std::recursive_mutex::~recursive_mutex((std::recursive_mutex *)(a1 + 24));
}

void MIDICISessionManager::MIDICISessionManager(MIDICISessionManager *this)
{
  NSObject *v2;
  int v3;
  NSObject *v4;
  OSStatus v5;
  NSObject *v6;
  uint32_t v7;
  NSObject *v8;
  int v9;
  int v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  MIDICISessionManager *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_1E98B99C0;
  *((_QWORD *)this + 1) = 0;
  CADeprecated::CAMutex::CAMutex((MIDICISessionManager *)((char *)this + 32), "MIDICISessionList");
  *((_QWORD *)this + 17) = 0;
  *((_QWORD *)this + 18) = 0;
  *((_QWORD *)this + 15) = &off_1E98B9810;
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 19) = off_1E98B9A90;
  _ZNSt3__115allocate_sharedB8ne180100INS_15recursive_mutexENS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_((uint64_t *)this + 20);
  *((_QWORD *)this + 22) = 0;
  *((_QWORD *)this + 23) = 0;
  *((_QWORD *)this + 24) = 0;
  MIDICIMUIDList::MIDICIMUIDList((MIDICISessionManager *)((char *)this + 200));
  MIDICIMUIDList::MIDICIMUIDList((MIDICISessionManager *)((char *)this + 336));
  MIDICIMUIDList::MIDICIMUIDList((MIDICISessionManager *)((char *)this + 472));
  *((_QWORD *)this + 76) = off_1E98B9A48;
  _ZNSt3__115allocate_sharedB8ne180100INS_15recursive_mutexENS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_((uint64_t *)this + 77);
  *((_QWORD *)this + 80) = 0;
  *((_QWORD *)this + 79) = 0;
  *((_QWORD *)this + 81) = 0;
  gSessionManager();
  v2 = objc_retainAutorelease((id)gSessionManager(void)::cisrvr);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    v10 = 136315650;
    v11 = "MIDICIServerSession.mm";
    v12 = 1024;
    v13 = 765;
    v14 = 2048;
    v15 = this;
    _os_log_impl(&dword_1D4E88000, v2, OS_LOG_TYPE_DEBUG, "%25s:%-5d MIDICISessionManager (%p) created", (uint8_t *)&v10, 0x1Cu);
  }
  v3 = MIDIClientCreateWithBlockInternal(CFSTR("MIDICISessionManager"), (int *)this + 164, &__block_literal_global_778, 0);
  if (v3)
  {
    gSessionManager();
    v4 = objc_retainAutorelease((id)gSessionManager(void)::cisrvr);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v10 = 136315650;
      v11 = "MIDICIServerSession.mm";
      v12 = 1024;
      v13 = 769;
      v14 = 1024;
      LODWORD(v15) = v3;
      _os_log_impl(&dword_1D4E88000, v4, OS_LOG_TYPE_ERROR, "%25s:%-5d Unable to create client for MIDICISessionManager (err = %d). MIDI-CI will not be possible.", (uint8_t *)&v10, 0x18u);
    }
  }
  v5 = MIDIOutputPortCreate(*((_DWORD *)this + 164), CFSTR("MIDICISessionManager Port"), (MIDIPortRef *)this + 165);
  if (v5)
  {
    gSessionManager();
    v6 = objc_retainAutorelease((id)gSessionManager(void)::cisrvr);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v10 = 136315650;
      v11 = "MIDICIServerSession.mm";
      v12 = 1024;
      v13 = 772;
      v14 = 1024;
      LODWORD(v15) = v5;
      _os_log_impl(&dword_1D4E88000, v6, OS_LOG_TYPE_ERROR, "%25s:%-5d Unable to create output port for MIDICISessionManager (err = %d).", (uint8_t *)&v10, 0x18u);
    }
  }
  do
    v7 = arc4random() & 0xFFFFFFF;
  while (!MIDICIMUIDList::Add((MIDICISessionManager *)((char *)this + 200), v7));
  *((_DWORD *)this + 166) = v7;
  gSessionManager();
  v8 = objc_retainAutorelease((id)gSessionManager(void)::cisrvr);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    v9 = *((_DWORD *)this + 166);
    v10 = 136315650;
    v11 = "MIDICIServerSession.mm";
    v12 = 1024;
    v13 = 775;
    v14 = 1024;
    LODWORD(v15) = v9;
    _os_log_impl(&dword_1D4E88000, v8, OS_LOG_TYPE_DEBUG, "%25s:%-5d NOTICE: MIDICISessionManager is using discovery MUID 0x%x", (uint8_t *)&v10, 0x18u);
  }
  *((_BYTE *)this + 668) = 0;
}

void sub_1D4EAC248(_Unwind_Exception *a1)
{
  MIDICISessionList *v1;
  uint64_t v2;
  MIDICIMUIDList *v3;
  MIDICIMUIDList *v4;
  MIDICIMUIDList *v5;
  void **v6;
  uint64_t v8;
  uint64_t v9;
  void *v10;

  MIDICIMUIDList::~MIDICIMUIDList(v5);
  MIDICIMUIDList::~MIDICIMUIDList(v4);
  MIDICIMUIDList::~MIDICIMUIDList(v3);
  *((_QWORD *)v1 + 19) = off_1E98B9A90;
  v8 = *((_QWORD *)v1 + 22);
  if (v8)
  {
    v9 = *((_QWORD *)v1 + 23);
    v10 = (void *)*((_QWORD *)v1 + 22);
    if (v9 != v8)
    {
      do
        v9 = std::shared_ptr<swix::connection::state>::~shared_ptr[abi:ne180100](v9 - 16);
      while (v9 != v8);
      v10 = *v6;
    }
    *((_QWORD *)v1 + 23) = v8;
    operator delete(v10);
  }
  std::shared_ptr<swix::connection::state>::~shared_ptr[abi:ne180100](v2);
  MIDICISessionList::~MIDICISessionList(v1);
  _Unwind_Resume(a1);
}

void CADeprecated::CAGuard::~CAGuard(CADeprecated::CAGuard *this)
{
  CADeprecated::CAGuard::~CAGuard(this);
  JUMPOUT(0x1D826BA98);
}

{
  *(_QWORD *)this = &off_1E98B9D28;
  pthread_cond_destroy((pthread_cond_t *)((char *)this + 88));
  *(_QWORD *)this = &off_1E98B9D98;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 24));
}

pthread_t CADeprecated::CAGuard::Wait(CADeprecated::CAGuard *this)
{
  _opaque_pthread_t *v2;
  _opaque_pthread_t *v3;
  int v4;
  pthread_t result;
  _DWORD *exception;
  int v7;
  uint8_t v8[16];
  uint8_t buf[16];

  v2 = pthread_self();
  v3 = (_opaque_pthread_t *)atomic_load((unint64_t *)this + 2);
  if (!pthread_equal(v2, v3))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D4E88000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, " CAGuard::Wait: A thread has to have locked a guard before it can wait", buf, 2u);
    }
    exception = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)exception = &off_1E98B9410;
    exception[2] = 1;
LABEL_10:
  }
  atomic_store(0, (unint64_t *)this + 2);
  v4 = pthread_cond_wait((pthread_cond_t *)((char *)this + 88), (pthread_mutex_t *)((char *)this + 24));
  if (v4)
  {
    v7 = v4;
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v8 = 0;
      _os_log_error_impl(&dword_1D4E88000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, " CAGuard::Wait: Could not wait for a signal", v8, 2u);
    }
    exception = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)exception = &off_1E98B9410;
    exception[2] = v7;
    goto LABEL_10;
  }
  result = pthread_self();
  atomic_store((unint64_t)result, (unint64_t *)this + 2);
  return result;
}

BOOL CADeprecated::CAGuard::WaitFor(CADeprecated::CAGuard *this, unint64_t a2)
{
  _opaque_pthread_t *v4;
  _opaque_pthread_t *v5;
  __darwin_time_t v6;
  unint64_t *v7;
  int v8;
  int v9;
  _DWORD *exception;
  uint8_t v12[16];
  timespec v13;

  v4 = pthread_self();
  v5 = (_opaque_pthread_t *)atomic_load((unint64_t *)this + 2);
  if (!pthread_equal(v4, v5))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      LOWORD(v13.tv_sec) = 0;
      _os_log_error_impl(&dword_1D4E88000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, " CAGuard::WaitFor: A thread has to have locked a guard be for it can wait", (uint8_t *)&v13, 2u);
    }
    exception = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)exception = &off_1E98B9410;
    exception[2] = 1;
LABEL_14:
  }
  if (a2 <= 0x3B9AC9FF)
  {
    v6 = 0;
  }
  else
  {
    v6 = a2 / 0x3B9ACA00;
    a2 %= 0x3B9ACA00uLL;
  }
  v13.tv_sec = v6;
  v13.tv_nsec = a2;
  v7 = (unint64_t *)((char *)this + 16);
  atomic_store(0, (unint64_t *)this + 2);
  v8 = pthread_cond_timedwait_relative_np((pthread_cond_t *)((char *)this + 88), (pthread_mutex_t *)((char *)this + 24), &v13);
  v9 = v8;
  if (v8 && v8 != 60)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v12 = 0;
      _os_log_error_impl(&dword_1D4E88000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, " CAGuard::WaitFor: Wait got an error", v12, 2u);
    }
    exception = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)exception = &off_1E98B9410;
    exception[2] = v9;
    goto LABEL_14;
  }
  atomic_store((unint64_t)pthread_self(), v7);
  return v9 == 60;
}

uint64_t CADeprecated::CAGuard::WaitUntil(CADeprecated::CAGuard *this, unint64_t a2)
{
  unint64_t v4;

  mach_absolute_time();
  v4 = __udivti3();
  if (a2 <= v4)
    return 1;
  else
    return (*(uint64_t (**)(CADeprecated::CAGuard *, unint64_t))(*(_QWORD *)this + 64))(this, a2 - v4);
}

uint64_t CADeprecated::CAGuard::Notify(CADeprecated::CAGuard *this)
{
  uint64_t result;
  _DWORD *exception;
  int v3;
  uint8_t buf[16];

  result = pthread_cond_signal((pthread_cond_t *)((char *)this + 88));
  if ((_DWORD)result)
  {
    v3 = result;
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D4E88000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, " CAGuard::Notify: failed", buf, 2u);
    }
    exception = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)exception = &off_1E98B9410;
    exception[2] = v3;
  }
  return result;
}

uint64_t CADeprecated::CAGuard::NotifyAll(CADeprecated::CAGuard *this)
{
  uint64_t result;
  _DWORD *exception;
  int v3;
  uint8_t buf[16];

  result = pthread_cond_broadcast((pthread_cond_t *)((char *)this + 88));
  if ((_DWORD)result)
  {
    v3 = result;
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_1D4E88000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, " CAGuard::NotifyAll: failed", buf, 2u);
    }
    exception = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)exception = &off_1E98B9410;
    exception[2] = v3;
  }
  return result;
}

CADeprecated::CAGuard *CADeprecated::CAGuard::CAGuard(CADeprecated::CAGuard *this, const char *a2)
{
  CADeprecated::CAMutex *v3;
  int v4;
  int v6;
  _DWORD *exception;
  uint8_t v8[16];

  v3 = CADeprecated::CAMutex::CAMutex(this, a2);
  *(_QWORD *)v3 = &off_1E98B9D28;
  v4 = pthread_cond_init((pthread_cond_t *)((char *)v3 + 88), 0);
  if (v4)
  {
    v6 = v4;
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v8 = 0;
      _os_log_error_impl(&dword_1D4E88000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, " CAGuard::CAGuard: Could not init the cond var", v8, 2u);
    }
    exception = __cxa_allocate_exception(0x10uLL);
    *(_QWORD *)exception = &off_1E98B9410;
    exception[2] = v6;
  }
  return this;
}

void sub_1D4EAC8A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)v1 = &off_1E98B9D98;
  pthread_mutex_destroy((pthread_mutex_t *)(v1 + 24));
  _Unwind_Resume(a1);
}

void sub_1D4EACA5C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1D4EACBAC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1D4EACCF0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1D4EACD6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1D4EACDC8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1D4EACE6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void sub_1D4EACFAC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1D4EAD040(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1D4EAD0B4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1D4EAD13C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void UMPStream::EndpointPair::~EndpointPair(void **this)
{
  void **v2;

  v2 = this + 19;
  std::vector<std::unique_ptr<UMPStream::FunctionBlock>>::__destroy_vector::operator()[abi:ne180100](&v2);
  if (*((char *)this + 143) < 0)
    operator delete(this[15]);
  if (*((char *)this + 95) < 0)
    operator delete(this[9]);
  *this = off_1E98B9320;
  XCFObject<__CFDictionary const*>::~XCFObject((uint64_t)(this + 3));
  BaseOpaqueObject::~BaseOpaqueObject((BaseOpaqueObject *)this);
}

{
  void **v2;

  v2 = this + 19;
  std::vector<std::unique_ptr<UMPStream::FunctionBlock>>::__destroy_vector::operator()[abi:ne180100](&v2);
  if (*((char *)this + 143) < 0)
    operator delete(this[15]);
  if (*((char *)this + 95) < 0)
    operator delete(this[9]);
  *this = off_1E98B9320;
  XCFObject<__CFDictionary const*>::~XCFObject((uint64_t)(this + 3));
  BaseOpaqueObject::~BaseOpaqueObject((BaseOpaqueObject *)this);
  JUMPOUT(0x1D826BA98);
}

uint64_t UMPCIObject::PrintObject(UMPCIObject *this, __sFILE *a2)
{
  return fputc(10, a2);
}

uint64_t TOpaqueObject<UMPCIObject,unsigned int,MIDIObject>::isa(uint64_t a1, void *a2)
{
  _BOOL4 v3;

  v3 = a2 == &TOpaqueRTTI<MIDIObject>::sRTTI || a2 == &BaseOpaqueObject::sBaseRTTI;
  return a2 == &TOpaqueRTTI<UMPCIObject>::sRTTI || v3;
}

void UMPStream::EndpointPair::deserialize(std::string *this@<X0>, const __CFDictionary **a2@<X1>, uint64_t a3@<X8>)
{
  const __CFNumber *v6;
  int v7;
  unint64_t v8;
  int v9;
  const __CFNumber *v10;
  int v11;
  unint64_t v12;
  int v13;
  const __CFNumber *v14;
  int v15;
  unint64_t v16;
  int v17;
  unsigned __int16 v18;
  std::string::value_type v19;
  unsigned __int16 v20;
  std::string::value_type v21;
  unsigned __int16 v22;
  std::string::value_type v23;
  unsigned __int16 v24;
  std::string::value_type v25;
  unsigned __int16 v26;
  std::string::value_type v27;
  const __CFArray *v28;
  CFIndex Count;
  CFIndex v30;
  const __CFArray *v31;
  CFIndex v32;
  unint64_t v33;
  const __CFNumber *v34;
  unsigned __int16 v35;
  std::string **size;
  std::string **v37;
  uint64_t v38;
  std::string::pointer data;
  uint64_t *v40;
  _QWORD *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t *v47;
  const __CFNumber *v48;
  unsigned __int8 v49;
  uint64_t v50;
  uint64_t v51;
  const __CFNumber *v52;
  CFTypeID TypeID;
  char v54;
  void *v55;
  void *exception;
  void *v57;
  void *v58;
  void *v59;
  void *v60;
  void *v61;
  void *v62;
  void *v63;
  void *v64;
  void *v65;
  void *v66;
  void *v67;
  void *v68;
  void *v69;
  std::string::size_type *p_size;
  _BYTE v71[8];
  char *v72;
  _BYTE v73[8];
  char *v74;
  CFTypeRef cf;
  CFTypeRef v76;
  _BYTE v77[8];
  char *v78;
  void *__p;
  char v80;
  char v81;
  std::string __str;
  unint64_t v83;
  std::string *v84;

  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)a3 = a3 + 8;
  std::string::basic_string[abi:ne180100]<0>(&__p, "name");
  if (!*a2)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  applesauce::CF::details::find_at_key_or_optional<std::string,std::string const&>((uint64_t)&__str, *a2, (const UInt8 *)&__p);
  if ((_BYTE)v83)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t **)a3, &__p, (uint64_t)&__p);
  }
  else
  {
    __str.__r_.__value_.__s.__data_[0] = 0;
    LOBYTE(v83) = 0;
  }
  if (v81 < 0)
    operator delete(__p);
  if ((_BYTE)v83)
  {
    std::string::operator=(this + 3, &__str);
    if ((_BYTE)v83)
    {
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__str.__r_.__value_.__l.__data_);
    }
  }
  std::string::basic_string[abi:ne180100]<0>(&__str, "protocol");
  if (!*a2)
  {
    v57 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v57, "Could not construct");
  }
  v6 = applesauce::CF::DictionaryRef_proxy::at_as<int,std::string const&>(*a2, (const UInt8 *)&__str);
  v7 = (int)v6;
  v8 = (unint64_t)v6 >> 32;
  if ((unint64_t)v6 >> 32)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t **)a3, (void **)&__str.__r_.__value_.__l.__data_, (uint64_t)&__str);
    v9 = v7;
  }
  else
  {
    v9 = 0;
  }
  if ((SHIBYTE(__str.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (!v8)
      goto LABEL_18;
    goto LABEL_17;
  }
  operator delete(__str.__r_.__value_.__l.__data_);
  if (v8)
LABEL_17:
    LODWORD(this[4].__r_.__value_.__l.__data_) = v9 | v7 & 0xFFFFFF00;
LABEL_18:
  std::string::basic_string[abi:ne180100]<0>(&__str, "source");
  if (!*a2)
  {
    v58 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v58, "Could not construct");
  }
  v10 = applesauce::CF::DictionaryRef_proxy::at_as<unsigned int,std::string const&>(*a2, (const UInt8 *)&__str);
  v11 = (int)v10;
  v12 = (unint64_t)v10 >> 32;
  if ((unint64_t)v10 >> 32)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t **)a3, (void **)&__str.__r_.__value_.__l.__data_, (uint64_t)&__str);
    v13 = v11;
  }
  else
  {
    v13 = 0;
  }
  if ((SHIBYTE(__str.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (!v12)
      goto LABEL_25;
    goto LABEL_24;
  }
  operator delete(__str.__r_.__value_.__l.__data_);
  if (v12)
LABEL_24:
    HIDWORD(this[4].__r_.__value_.__r.__words[0]) = v13 | v11 & 0xFFFFFF00;
LABEL_25:
  std::string::basic_string[abi:ne180100]<0>(&__str, "destination");
  if (!*a2)
  {
    v59 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v59, "Could not construct");
  }
  v14 = applesauce::CF::DictionaryRef_proxy::at_as<unsigned int,std::string const&>(*a2, (const UInt8 *)&__str);
  v15 = (int)v14;
  v16 = (unint64_t)v14 >> 32;
  if ((unint64_t)v14 >> 32)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t **)a3, (void **)&__str.__r_.__value_.__l.__data_, (uint64_t)&__str);
    v17 = v15;
  }
  else
  {
    v17 = 0;
  }
  if ((SHIBYTE(__str.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (!v16)
      goto LABEL_32;
    goto LABEL_31;
  }
  operator delete(__str.__r_.__value_.__l.__data_);
  if (v16)
LABEL_31:
    LODWORD(this[4].__r_.__value_.__r.__words[1]) = v17 | v15 & 0xFFFFFF00;
LABEL_32:
  std::string::basic_string[abi:ne180100]<0>(&__str, "device_info");
  if (!*a2)
  {
    v60 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v60, "Could not construct");
  }
  applesauce::CF::details::find_at_key_or_optional<applesauce::CF::DictionaryRef,std::string const&>(&__p, *a2, (const UInt8 *)&__str);
  if (v80)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t **)a3, (void **)&__str.__r_.__value_.__l.__data_, (uint64_t)&__str);
  }
  else
  {
    std::__optional_destruct_base<applesauce::CF::DictionaryRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&__p);
    LOBYTE(__p) = 0;
    v80 = 0;
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  if (v80)
  {
    MIDI2::DeviceInfo::deserialize((MIDI2::DeviceInfo *)v77, (const applesauce::CF::DictionaryRef *)((char *)&this[4].__r_.__value_.__r.__words[1] + 4), (const __CFDictionary **)&__p);
    std::__tree<std::string>::destroy(v78);
  }
  std::__optional_destruct_base<applesauce::CF::DictionaryRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&__p);
  std::string::basic_string[abi:ne180100]<0>(&__p, "product_instance");
  if (!*a2)
  {
    v61 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v61, "Could not construct");
  }
  applesauce::CF::details::find_at_key_or_optional<std::string,std::string const&>((uint64_t)&__str, *a2, (const UInt8 *)&__p);
  if ((_BYTE)v83)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t **)a3, &__p, (uint64_t)&__p);
  }
  else
  {
    __str.__r_.__value_.__s.__data_[0] = 0;
    LOBYTE(v83) = 0;
  }
  if (v81 < 0)
    operator delete(__p);
  if ((_BYTE)v83)
  {
    std::string::operator=(this + 5, &__str);
    if ((_BYTE)v83)
    {
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__str.__r_.__value_.__l.__data_);
    }
  }
  std::string::basic_string[abi:ne180100]<0>(&__str, "has_static_function_blocks");
  if (!*a2)
  {
    v62 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v62, "Could not construct");
  }
  v18 = applesauce::CF::details::find_at_key_or_optional<BOOL,std::string const&>(*a2, (const UInt8 *)&__str);
  if (v18 >= 0x100u)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t **)a3, (void **)&__str.__r_.__value_.__l.__data_, (uint64_t)&__str);
    v19 = v18;
  }
  else
  {
    v19 = 0;
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  if (v18 >= 0x100u)
    this[6].__r_.__value_.__s.__data_[0] = v19;
  std::string::basic_string[abi:ne180100]<0>(&__str, "jrts_receive_capability");
  if (!*a2)
  {
    v63 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v63, "Could not construct");
  }
  v20 = applesauce::CF::details::find_at_key_or_optional<BOOL,std::string const&>(*a2, (const UInt8 *)&__str);
  if (v20 >= 0x100u)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t **)a3, (void **)&__str.__r_.__value_.__l.__data_, (uint64_t)&__str);
    v21 = v20;
  }
  else
  {
    v21 = 0;
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  if (v20 >= 0x100u)
    this[6].__r_.__value_.__s.__data_[1] = v21;
  std::string::basic_string[abi:ne180100]<0>(&__str, "jrts_transmit_capability");
  if (!*a2)
  {
    v64 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v64, "Could not construct");
  }
  v22 = applesauce::CF::details::find_at_key_or_optional<BOOL,std::string const&>(*a2, (const UInt8 *)&__str);
  if (v22 >= 0x100u)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t **)a3, (void **)&__str.__r_.__value_.__l.__data_, (uint64_t)&__str);
    v23 = v22;
  }
  else
  {
    v23 = 0;
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  if (v22 >= 0x100u)
    this[6].__r_.__value_.__s.__data_[2] = v23;
  std::string::basic_string[abi:ne180100]<0>(&__str, "client_owned");
  if (!*a2)
  {
    v65 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v65, "Could not construct");
  }
  v24 = applesauce::CF::details::find_at_key_or_optional<BOOL,std::string const&>(*a2, (const UInt8 *)&__str);
  if (v24 >= 0x100u)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t **)a3, (void **)&__str.__r_.__value_.__l.__data_, (uint64_t)&__str);
    v25 = v24;
  }
  else
  {
    v25 = 0;
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  if (v24 >= 0x100u)
    this[6].__r_.__value_.__s.__data_[4] = v25;
  std::string::basic_string[abi:ne180100]<0>(&__str, "enabled");
  if (!*a2)
  {
    v66 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v66, "Could not construct");
  }
  v26 = applesauce::CF::details::find_at_key_or_optional<BOOL,std::string const&>(*a2, (const UInt8 *)&__str);
  if (v26 >= 0x100u)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t **)a3, (void **)&__str.__r_.__value_.__l.__data_, (uint64_t)&__str);
    v27 = v26;
  }
  else
  {
    v27 = 0;
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  if (v26 >= 0x100u)
    this[6].__r_.__value_.__s.__data_[3] = v27;
  std::string::basic_string[abi:ne180100]<0>(&__str, "function_blocks");
  if (!*a2)
  {
    v67 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v67, "Could not construct");
  }
  applesauce::CF::details::find_at_key_or_optional<applesauce::CF::ArrayRef,std::string const&>(&__p, *a2, (const UInt8 *)&__str);
  if (v80)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t **)a3, (void **)&__str.__r_.__value_.__l.__data_, (uint64_t)&__str);
  }
  else
  {
    std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&__p);
    LOBYTE(__p) = 0;
    v80 = 0;
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  if (v80)
  {
    v28 = (const __CFArray *)__p;
    if (__p)
    {
      Count = CFArrayGetCount((CFArrayRef)__p);
      v30 = Count;
      v31 = (const __CFArray *)__p;
      if (__p)
      {
        v32 = CFArrayGetCount((CFArrayRef)__p);
        if (!v30)
          goto LABEL_139;
      }
      else
      {
        v32 = 0;
        if (!Count)
          goto LABEL_139;
      }
      v33 = 0;
      p_size = &this[6].__r_.__value_.__l.__size_;
      do
      {
        if (v28 == v31 && v33 == v32)
          break;
        applesauce::CF::details::at_to<applesauce::CF::TypeRef>(&v76, v28, v33);
        applesauce::CF::TypeRef::operator applesauce::CF::DictionaryRef((applesauce::CF::DictionaryRef *)&cf, &v76);
        if (!cf)
        {
          v55 = __cxa_allocate_exception(0x10uLL);
          MEMORY[0x1D826B7EC](v55, "Could not construct");
        }
        v34 = (const __CFNumber *)applesauce::CF::details::at_key<char const* const&>((const __CFDictionary *)cf, "id");
        if (v34)
        {
          v35 = applesauce::CF::convert_as<unsigned char,0>(v34);
          if (v35 >= 0x100u)
          {
            size = (std::string **)this[6].__r_.__value_.__l.__size_;
            v37 = (std::string **)this[6].__r_.__value_.__r.__words[2];
            while (size != v37)
            {
              if ((*size)[4].__r_.__value_.__s.__data_[0] == v35)
              {
                if (size != v37 && *size)
                {
                  UMPStream::FunctionBlock::deserialize(*size, (const __CFDictionary **)&cf, (uint64_t)v73);
                  std::__tree<std::string>::destroy(v74);
                  goto LABEL_134;
                }
                break;
              }
              ++size;
            }
            v38 = operator new();
            *(_QWORD *)(v38 + 112) = 0;
            *(_OWORD *)(v38 + 80) = 0u;
            *(_OWORD *)(v38 + 96) = 0u;
            *(_OWORD *)(v38 + 48) = 0u;
            *(_OWORD *)(v38 + 64) = 0u;
            *(_OWORD *)(v38 + 16) = 0u;
            *(_OWORD *)(v38 + 32) = 0u;
            *(_OWORD *)v38 = 0u;
            MIDIObject::MIDIObject((MIDIObject *)v38);
            *(_BYTE *)(v38 + 44) = 0;
            *(_BYTE *)(v38 + 48) = 0;
            *(_QWORD *)(v38 + 56) = 0;
            *(_QWORD *)v38 = off_1E98B7080;
            *(_BYTE *)(v38 + 64) = 0;
            *(_QWORD *)(v38 + 112) = 0;
            *(_DWORD *)(v38 + 108) = 0;
            *(_QWORD *)(v38 + 80) = 0;
            *(_QWORD *)(v38 + 88) = 0;
            *(_QWORD *)(v38 + 72) = 0;
            *(_BYTE *)(v38 + 96) = 0;
            *(_DWORD *)(v38 + 100) = 0;
            *(_DWORD *)(v38 + 103) = 0;
            UMPStream::FunctionBlock::deserialize((std::string *)v38, (const __CFDictionary **)&cf, (uint64_t)v71);
            std::__tree<std::string>::destroy(v72);
            v40 = (uint64_t *)this[6].__r_.__value_.__r.__words[2];
            data = this[7].__r_.__value_.__l.__data_;
            if (v40 >= (uint64_t *)data)
            {
              v42 = (uint64_t)((uint64_t)v40 - *p_size) >> 3;
              if ((unint64_t)(v42 + 1) >> 61)
                std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
              v43 = (uint64_t)&data[-*p_size];
              v44 = v43 >> 2;
              if (v43 >> 2 <= (unint64_t)(v42 + 1))
                v44 = v42 + 1;
              if ((unint64_t)v43 >= 0x7FFFFFFFFFFFFFF8)
                v45 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v45 = v44;
              v84 = this + 7;
              if (v45)
                v45 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v45);
              else
                v46 = 0;
              v47 = (uint64_t *)(v45 + 8 * v42);
              __str.__r_.__value_.__r.__words[0] = v45;
              __str.__r_.__value_.__l.__size_ = (std::string::size_type)v47;
              v83 = v45 + 8 * v46;
              *v47 = v38;
              __str.__r_.__value_.__r.__words[2] = (std::string::size_type)(v47 + 1);
              std::vector<std::unique_ptr<UMPStream::FunctionBlock>>::__swap_out_circular_buffer(p_size, &__str);
              v41 = (_QWORD *)this[6].__r_.__value_.__r.__words[2];
              std::__split_buffer<std::unique_ptr<UMPStream::FunctionBlock>>::~__split_buffer((uint64_t)&__str);
            }
            else
            {
              *v40 = v38;
              v41 = v40 + 1;
            }
            this[6].__r_.__value_.__r.__words[2] = (std::string::size_type)v41;
          }
        }
LABEL_134:
        if (cf)
          CFRelease(cf);
        if (v76)
          CFRelease(v76);
        ++v33;
      }
      while (v33 != v30);
    }
  }
LABEL_139:
  std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&__p);
  std::string::basic_string[abi:ne180100]<0>(&__str, "timestamp");
  if (!*a2)
  {
    v68 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v68, "Could not construct");
  }
  v48 = applesauce::CF::details::find_at_key_or_optional<unsigned long long,std::string const&>(*a2, (const UInt8 *)&__str);
  v50 = v49;
  if (v49)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t **)a3, (void **)&__str.__r_.__value_.__l.__data_, (uint64_t)&__str);
    v51 = v48;
  }
  else
  {
    v51 = 0;
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  if (v50)
    this[2].__r_.__value_.__l.__size_ = v51 | (unint64_t)v48 & 0xFFFFFFFFFFFFFF00;
  std::string::basic_string[abi:ne180100]<0>(&__str, "endpoint_type");
  if (!*a2)
  {
    v69 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v69, "Could not construct");
  }
  v52 = (const __CFNumber *)applesauce::CF::details::at_key<std::string const&>(*a2, (const UInt8 *)&__str);
  if (v52)
  {
    TypeID = CFNumberGetTypeID();
    if (TypeID == CFGetTypeID(v52))
    {
      LOBYTE(__p) = 0;
      if (CFNumberGetValue(v52, kCFNumberCharType, &__p))
      {
        LOBYTE(v52) = (_BYTE)__p;
        std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t **)a3, (void **)&__str.__r_.__value_.__l.__data_, (uint64_t)&__str);
        v54 = 0;
        goto LABEL_154;
      }
    }
    LOBYTE(v52) = 0;
  }
  v54 = 1;
LABEL_154:
  if ((SHIBYTE(__str.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v54 & 1) != 0)
      return;
    goto LABEL_156;
  }
  operator delete(__str.__r_.__value_.__l.__data_);
  if ((v54 & 1) == 0)
LABEL_156:
    this[7].__r_.__value_.__s.__data_[9] = (char)v52;
}

void sub_1D4EAE64C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, char **a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  const void *v12;
  va_list va;
  const void *v14;
  va_list va1;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va2;

  va_start(va2, a11);
  va_start(va1, a11);
  va_start(va, a11);
  v12 = va_arg(va1, const void *);
  va_copy(va2, va1);
  v14 = va_arg(va2, const void *);
  v16 = va_arg(va2, _QWORD);
  v17 = va_arg(va2, _QWORD);
  v18 = va_arg(va2, _QWORD);
  applesauce::CF::DictionaryRef::~DictionaryRef((const void **)va);
  applesauce::CF::TypeRef::~TypeRef((const void **)va1);
  std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)va2);
  std::__tree<std::string>::destroy(*a4);
  _Unwind_Resume(a1);
}

void UMPStream::EndpointPair::serialize(UMPStream::EndpointPair *this@<X0>, CFDictionaryRef *a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  UMPStream::FunctionBlock **v11;
  UMPStream::FunctionBlock **i;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  unint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  CFDictionaryRef v24;
  __int128 v25;
  unint64_t v26;
  CFArrayRef v27;
  uint64_t v28;
  const void *v29;
  const void *v30;
  void *exception;
  CFArrayRef v32;
  CFTypeRef cf;
  int v34;
  int v35;
  _QWORD v36[2];
  __int128 v37;
  unint64_t v38;
  void **valuePtr;
  __int128 v40;
  unint64_t v41;
  unint64_t *v42;
  CFDictionaryRef v43;
  _BYTE v44[16];
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  _QWORD v51[2];
  _QWORD v52[2];
  _QWORD v53[2];
  _QWORD v54[2];
  _QWORD v55[2];
  uint64_t v56;
  uint64_t v57;
  uint64_t v59;
  _BYTE v60[16];
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  v35 = *((_DWORD *)this + 2);
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned int>((applesauce::CF::TypeRef *)v44, "object", &v35);
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,std::string const&>((applesauce::CF::TypeRef *)&v45, "name", (uint64_t)this + 72);
  v34 = *((_DWORD *)this + 24);
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,int>((applesauce::CF::TypeRef *)&v46, "protocol", &v34);
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned int const&>((applesauce::CF::TypeRef *)&v47, "source", (int *)this + 25);
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned int const&>((applesauce::CF::TypeRef *)&v48, "destination", (int *)this + 26);
  MIDI2::DeviceInfo::serialize((MIDI2::DeviceInfo *)&cf, (uint64_t)this + 108);
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,applesauce::CF::DictionaryRef>((applesauce::CF::TypeRef *)&v49, "device_info", &cf);
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,std::string const&>((applesauce::CF::TypeRef *)&v50, "product_instance", (uint64_t)this + 120);
  applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)v51, "has_static_function_blocks");
  v4 = *MEMORY[0x1E0C9AE50];
  v5 = *MEMORY[0x1E0C9AE40];
  if (*((_BYTE *)this + 144))
    v6 = *MEMORY[0x1E0C9AE50];
  else
    v6 = *MEMORY[0x1E0C9AE40];
  v51[1] = v6;
  applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)v52, "jrts_receive_capability");
  if (*((_BYTE *)this + 145))
    v7 = v4;
  else
    v7 = v5;
  v52[1] = v7;
  applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)v53, "jrts_transmit_capability");
  if (*((_BYTE *)this + 146))
    v8 = v4;
  else
    v8 = v5;
  v53[1] = v8;
  applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)v54, "client_owned");
  if (*((_BYTE *)this + 148))
    v9 = v4;
  else
    v9 = v5;
  v54[1] = v9;
  applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)v55, "enabled");
  if (*((_BYTE *)this + 147))
    v10 = v4;
  else
    v10 = v5;
  v55[1] = v10;
  v37 = 0uLL;
  v38 = 0;
  v11 = (UMPStream::FunctionBlock **)*((_QWORD *)this + 19);
  for (i = (UMPStream::FunctionBlock **)*((_QWORD *)this + 20); v11 != i; ++v11)
  {
    UMPStream::FunctionBlock::serialize(*v11, &v43);
    v13 = (_QWORD *)*((_QWORD *)&v37 + 1);
    if (*((_QWORD *)&v37 + 1) >= v38)
    {
      v14 = (_QWORD *)v37;
      v15 = (uint64_t)(*((_QWORD *)&v37 + 1) - v37) >> 3;
      v16 = v15 + 1;
      if ((unint64_t)(v15 + 1) >> 61)
        std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
      v17 = v38 - v37;
      if ((uint64_t)(v38 - v37) >> 2 > v16)
        v16 = v17 >> 2;
      if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8)
        v18 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v18 = v16;
      v42 = &v38;
      if (v18)
      {
        v18 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v18);
        v13 = (_QWORD *)*((_QWORD *)&v37 + 1);
        v14 = (_QWORD *)v37;
      }
      else
      {
        v19 = 0;
      }
      v20 = (_QWORD *)(v18 + 8 * v15);
      v21 = v18 + 8 * v19;
      v41 = v21;
      *v20 = v43;
      v22 = v20 + 1;
      v43 = 0;
      *((_QWORD *)&v40 + 1) = v20 + 1;
      if (v13 == v14)
      {
        v24 = 0;
      }
      else
      {
        do
        {
          v23 = *--v13;
          *--v20 = v23;
          *v13 = 0;
        }
        while (v13 != v14);
        v22 = (_QWORD *)*((_QWORD *)&v40 + 1);
        v21 = v41;
        v24 = v43;
      }
      v25 = v37;
      *(_QWORD *)&v37 = v20;
      *((_QWORD *)&v37 + 1) = v22;
      v40 = v25;
      v26 = v38;
      v38 = v21;
      v41 = v26;
      valuePtr = (void **)v25;
      std::__split_buffer<applesauce::CF::DictionaryRef>::~__split_buffer((uint64_t)&valuePtr);
      *((_QWORD *)&v37 + 1) = v22;
      if (v24)
        CFRelease(v24);
    }
    else
    {
      **((_QWORD **)&v37 + 1) = v43;
      *((_QWORD *)&v37 + 1) = v13 + 1;
    }
  }
  v27 = applesauce::CF::details::make_CFArrayRef<applesauce::CF::DictionaryRef>((uint64_t **)&v37);
  v32 = v27;
  valuePtr = (void **)&v37;
  std::vector<applesauce::CF::DictionaryRef>::__destroy_vector::operator()[abi:ne180100](&valuePtr);
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,applesauce::CF::ArrayRef>((applesauce::CF::TypeRef *)&v56, "function_blocks", (const void **)&v32);
  applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v57, "endpoint_type");
  LOBYTE(valuePtr) = *((_BYTE *)this + 177);
  if (!CFNumberCreate(0, kCFNumberCharType, &valuePtr))
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  LODWORD(valuePtr) = 2;
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,UMPCIObjectType>((applesauce::CF::TypeRef *)&v59, "type", (int *)&valuePtr);
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned long long const&>((applesauce::CF::TypeRef *)v60, "timestamp", (uint64_t *)this + 7);
  v36[0] = v44;
  v36[1] = 16;
  v28 = 0;
  *a2 = applesauce::CF::details::make_CFDictionaryRef((uint64_t)v36);
  do
  {
    v29 = *(const void **)&v60[v28 + 8];
    if (v29)
      CFRelease(v29);
    v30 = *(const void **)&v60[v28];
    if (v30)
      CFRelease(v30);
    v28 -= 16;
  }
  while (v28 != -256);
  if (v27)
    CFRelease(v27);
  if (cf)
    CFRelease(cf);
}

void sub_1D4EAECBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, const void *a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,CFTypeRef cf)
{
  const void **v52;

  if (cf)
    CFRelease(cf);
  applesauce::CF::TypeRef::~TypeRef(v52);
  applesauce::CF::ArrayRef::~ArrayRef(&a10);
  applesauce::CF::DictionaryRef::~DictionaryRef(&a11);
  while (v52 != (const void **)&a25)
  {
    v52 -= 2;
    applesauce::CF::TypeRefPair::~TypeRefPair((applesauce::CF::TypeRefPair *)v52);
  }
  _Unwind_Resume(a1);
}

uint64_t UMPStream::EndpointPair::getUMPCIType(UMPStream::EndpointPair *this)
{
  return 2;
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned int>(applesauce::CF::TypeRef *a1, char *a2, int *a3)
{
  CFNumberRef v5;
  void *exception;
  int valuePtr;

  applesauce::CF::TypeRef::TypeRef(a1, a2);
  valuePtr = *a3;
  v5 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  *((_QWORD *)a1 + 1) = v5;
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  return a1;
}

void sub_1D4EAEE6C(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  if (v3)
    CFRelease(v3);
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,std::string const&>(applesauce::CF::TypeRef *a1, char *a2, uint64_t a3)
{
  int v5;
  const UInt8 *v6;
  CFIndex v7;
  CFStringRef v8;
  void *exception;

  applesauce::CF::TypeRef::TypeRef(a1, a2);
  v5 = *(char *)(a3 + 23);
  if (v5 >= 0)
    v6 = (const UInt8 *)a3;
  else
    v6 = *(const UInt8 **)a3;
  if (v5 >= 0)
    v7 = *(unsigned __int8 *)(a3 + 23);
  else
    v7 = *(_QWORD *)(a3 + 8);
  v8 = CFStringCreateWithBytes(0, v6, v7, 0x8000100u, 0);
  *((_QWORD *)a1 + 1) = v8;
  if (!v8)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  return a1;
}

void sub_1D4EAEF40(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  if (v3)
    CFRelease(v3);
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,int>(applesauce::CF::TypeRef *a1, char *a2, int *a3)
{
  CFNumberRef v5;
  void *exception;
  int valuePtr;

  applesauce::CF::TypeRef::TypeRef(a1, a2);
  valuePtr = *a3;
  v5 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  *((_QWORD *)a1 + 1) = v5;
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  return a1;
}

void sub_1D4EAF008(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  if (v3)
    CFRelease(v3);
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned int const&>(applesauce::CF::TypeRef *a1, char *a2, int *a3)
{
  CFNumberRef v5;
  void *exception;
  int valuePtr;

  applesauce::CF::TypeRef::TypeRef(a1, a2);
  valuePtr = *a3;
  v5 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  *((_QWORD *)a1 + 1) = v5;
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  return a1;
}

void sub_1D4EAF0D0(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  if (v3)
    CFRelease(v3);
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

void MIDI2::DeviceInfo::serialize(MIDI2::DeviceInfo *this, uint64_t a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v9[2];
  void *__p[3];
  void *v11[3];
  _BYTE v12[16];
  uint64_t v13;
  uint64_t v14;
  _BYTE v15[16];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  memset(v11, 0, sizeof(v11));
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(v11, (unsigned __int8 *)a2, (unsigned __int8 *)(a2 + 3), 3uLL);
  memset(__p, 0, sizeof(__p));
  std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(__p, (unsigned __int8 *)(a2 + 8), (unsigned __int8 *)(a2 + 12), 4uLL);
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,std::vector<unsigned long long> const&>((applesauce::CF::TypeRef *)v12, "manufacturer_id", (uint64_t **)v11);
  v8 = *(unsigned __int16 *)(a2 + 4);
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned long long>((applesauce::CF::TypeRef *)&v13, "family", &v8);
  v7 = *(unsigned __int16 *)(a2 + 6);
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned long long>((applesauce::CF::TypeRef *)&v14, "model_number", &v7);
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,std::vector<unsigned long long> const&>((applesauce::CF::TypeRef *)v15, "revision_level", (uint64_t **)__p);
  v9[0] = v12;
  v9[1] = 4;
  v4 = 0;
  *(_QWORD *)this = applesauce::CF::details::make_CFDictionaryRef((uint64_t)v9);
  do
  {
    v5 = *(const void **)&v15[v4 + 8];
    if (v5)
      CFRelease(v5);
    v6 = *(const void **)&v15[v4];
    if (v6)
      CFRelease(v6);
    v4 -= 16;
  }
  while (v4 != -64);
  if (__p[0])
    operator delete(__p[0]);
  if (v11[0])
    operator delete(v11[0]);
}

void sub_1D4EAF26C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, char a20)
{
  uint64_t v20;
  uint64_t i;

  for (i = 48; i != -16; i -= 16)
    applesauce::CF::TypeRefPair::~TypeRefPair((applesauce::CF::TypeRefPair *)(v20 + i));
  if (__p)
    operator delete(__p);
  if (a17)
    operator delete(a17);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,applesauce::CF::DictionaryRef>(applesauce::CF::TypeRef *a1, char *a2, const void **a3)
{
  const void *v5;

  applesauce::CF::TypeRef::TypeRef(a1, a2);
  v5 = *a3;
  if (v5)
    CFRetain(v5);
  *((_QWORD *)a1 + 1) = v5;
  return a1;
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,applesauce::CF::ArrayRef>(applesauce::CF::TypeRef *a1, char *a2, const void **a3)
{
  const void *v5;

  applesauce::CF::TypeRef::TypeRef(a1, a2);
  v5 = *a3;
  if (v5)
    CFRetain(v5);
  *((_QWORD *)a1 + 1) = v5;
  return a1;
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,UMPCIObjectType>(applesauce::CF::TypeRef *a1, char *a2, int *a3)
{
  CFNumberRef v5;
  void *exception;
  int valuePtr;

  applesauce::CF::TypeRef::TypeRef(a1, a2);
  valuePtr = *a3;
  v5 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  *((_QWORD *)a1 + 1) = v5;
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  return a1;
}

void sub_1D4EAF408(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  if (v3)
    CFRelease(v3);
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned long long const&>(applesauce::CF::TypeRef *a1, char *a2, uint64_t *a3)
{
  CFNumberRef v5;
  void *exception;
  uint64_t valuePtr;

  applesauce::CF::TypeRef::TypeRef(a1, a2);
  valuePtr = *a3;
  v5 = CFNumberCreate(0, kCFNumberLongLongType, &valuePtr);
  *((_QWORD *)a1 + 1) = v5;
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  return a1;
}

void sub_1D4EAF4D0(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  if (v3)
    CFRelease(v3);
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(_QWORD *a1, unsigned __int8 *a2, unsigned __int8 *a3, unint64_t a4)
{
  _QWORD *result;
  uint64_t v8;
  unsigned int v9;

  result = std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(a4);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[v8];
  while (a2 != a3)
  {
    v9 = *a2++;
    *result++ = v9;
  }
  a1[1] = result;
  return result;
}

void sub_1D4EAF564(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,std::vector<unsigned long long> const&>(applesauce::CF::TypeRef *a1, char *a2, uint64_t **a3)
{
  unint64_t v5;
  uint64_t *v6;
  uint64_t *v7;
  CFNumberRef *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  int64x2_t v18;
  unint64_t v19;
  CFArrayRef v20;
  int64x2_t v22;
  unint64_t v23;
  int64x2_t *v24;
  int64x2_t v25;
  unint64_t v26;
  unint64_t *v27;

  applesauce::CF::TypeRef::TypeRef(a1, a2);
  v5 = a3[1] - *a3;
  v22 = 0uLL;
  v23 = 0;
  std::vector<applesauce::CF::NumberRef>::reserve(&v22, v5);
  v6 = *a3;
  v7 = a3[1];
  if (*a3 != v7)
  {
    v8 = (CFNumberRef *)v22.i64[1];
    do
    {
      v9 = *v6;
      if ((unint64_t)v8 >= v23)
      {
        v10 = ((uint64_t)v8 - v22.i64[0]) >> 3;
        if ((unint64_t)(v10 + 1) >> 61)
          std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
        v11 = (uint64_t)(v23 - v22.i64[0]) >> 2;
        if (v11 <= v10 + 1)
          v11 = v10 + 1;
        if (v23 - v22.i64[0] >= 0x7FFFFFFFFFFFFFF8)
          v12 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v12 = v11;
        v27 = &v23;
        if (v12)
          v12 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v12);
        else
          v13 = 0;
        v24 = (int64x2_t *)v12;
        v25.i64[0] = v12 + 8 * v10;
        v25.i64[1] = v25.i64[0];
        v26 = v12 + 8 * v13;
        std::construct_at[abi:ne180100]<applesauce::CF::NumberRef,unsigned long long,applesauce::CF::NumberRef*>((CFNumberRef *)v25.i64[0], v9);
        v14 = v25.i64[0];
        v8 = (CFNumberRef *)(v25.i64[1] + 8);
        v25.i64[1] += 8;
        v15 = (_QWORD *)v22.i64[1];
        v16 = (_QWORD *)v22.i64[0];
        if (v22.i64[1] == v22.i64[0])
        {
          v18 = vdupq_n_s64(v22.u64[1]);
        }
        else
        {
          do
          {
            v17 = *--v15;
            *(_QWORD *)(v14 - 8) = v17;
            v14 -= 8;
            *v15 = 0;
          }
          while (v15 != v16);
          v18 = v22;
          v8 = (CFNumberRef *)v25.i64[1];
        }
        v22.i64[0] = v14;
        v22.i64[1] = (uint64_t)v8;
        v25 = v18;
        v19 = v23;
        v23 = v26;
        v26 = v19;
        v24 = (int64x2_t *)v18.i64[0];
        std::__split_buffer<applesauce::CF::NumberRef>::~__split_buffer((uint64_t)&v24);
      }
      else
      {
        std::construct_at[abi:ne180100]<applesauce::CF::NumberRef,unsigned long long,applesauce::CF::NumberRef*>(v8++, *v6);
      }
      v22.i64[1] = (uint64_t)v8;
      ++v6;
    }
    while (v6 != v7);
  }
  v20 = applesauce::CF::details::make_CFArrayRef<applesauce::CF::NumberRef>((uint64_t **)&v22);
  v24 = &v22;
  std::vector<applesauce::CF::NumberRef>::__destroy_vector::operator()[abi:ne180100]((void ***)&v24);
  *((_QWORD *)a1 + 1) = v20;
  return a1;
}

void sub_1D4EAF720(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void **a13)
{
  const void **v13;

  a13 = (void **)&a9;
  std::vector<applesauce::CF::NumberRef>::__destroy_vector::operator()[abi:ne180100](&a13);
  applesauce::CF::TypeRef::~TypeRef(v13);
  _Unwind_Resume(a1);
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned long long>(applesauce::CF::TypeRef *a1, char *a2, uint64_t *a3)
{
  CFNumberRef v5;
  void *exception;
  uint64_t valuePtr;

  applesauce::CF::TypeRef::TypeRef(a1, a2);
  valuePtr = *a3;
  v5 = CFNumberCreate(0, kCFNumberLongLongType, &valuePtr);
  *((_QWORD *)a1 + 1) = v5;
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  return a1;
}

void sub_1D4EAF7F4(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  if (v3)
    CFRelease(v3);
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<applesauce::CF::NumberRef>::reserve(_QWORD *result, unint64_t a2)
{
  char **v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  int64x2_t v10;
  char *v11;
  uint64_t v12;
  int64x2_t v13;
  char *v14;
  _QWORD *v15;

  if (a2 > (uint64_t)(result[2] - *result) >> 3)
  {
    if (a2 >> 61)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v2 = (char **)result;
    v3 = result[1] - *result;
    v15 = result + 2;
    v4 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(a2);
    v7 = *v2;
    v6 = v2[1];
    if (v6 == *v2)
    {
      v10 = vdupq_n_s64((unint64_t)v6);
      v8 = &v4[v3 & 0xFFFFFFFFFFFFFFF8];
    }
    else
    {
      v8 = &v4[v3 & 0xFFFFFFFFFFFFFFF8];
      do
      {
        v9 = *((_QWORD *)v6 - 1);
        v6 -= 8;
        *((_QWORD *)v8 - 1) = v9;
        v8 -= 8;
        *(_QWORD *)v6 = 0;
      }
      while (v6 != v7);
      v10 = *(int64x2_t *)v2;
    }
    *v2 = v8;
    v2[1] = &v4[v3 & 0xFFFFFFFFFFFFFFF8];
    v13 = v10;
    v11 = v2[2];
    v2[2] = &v4[8 * v5];
    v14 = v11;
    v12 = v10.i64[0];
    return (_QWORD *)std::__split_buffer<applesauce::CF::NumberRef>::~__split_buffer((uint64_t)&v12);
  }
  return result;
}

CFArrayRef applesauce::CF::details::make_CFArrayRef<applesauce::CF::NumberRef>(uint64_t **a1)
{
  uint64_t *v2;
  uint64_t *v3;
  _QWORD *v4;
  uint64_t v5;
  CFArrayRef CFArray;
  void *__p;
  void *v9;

  std::vector<void const*>::vector(&__p, a1[1] - *a1);
  v2 = *a1;
  v3 = a1[1];
  if (*a1 != v3)
  {
    v4 = __p;
    do
    {
      v5 = *v2++;
      *v4++ = v5;
    }
    while (v2 != v3);
  }
  CFArray = applesauce::CF::details::make_CFArrayRef<void const*>((const void **)__p, (uint64_t)v9);
  if (__p)
  {
    v9 = __p;
    operator delete(__p);
  }
  return CFArray;
}

void sub_1D4EAF964(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

CFNumberRef *std::construct_at[abi:ne180100]<applesauce::CF::NumberRef,unsigned long long,applesauce::CF::NumberRef*>(CFNumberRef *a1, uint64_t a2)
{
  CFNumberRef v3;
  void *exception;
  uint64_t valuePtr;

  valuePtr = a2;
  v3 = CFNumberCreate(0, kCFNumberLongLongType, &valuePtr);
  *a1 = v3;
  if (!v3)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  return a1;
}

void sub_1D4EAFA00(_Unwind_Exception *exception_object)
{
  CFTypeRef *v1;

  if (*v1)
    CFRelease(*v1);
  _Unwind_Resume(exception_object);
}

void std::vector<applesauce::CF::NumberRef>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  const void *v6;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = (const void *)*((_QWORD *)v4 - 1);
        v4 -= 8;
        std::__destroy_at[abi:ne180100]<applesauce::CF::NumberRef,0>(v6);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__destroy_at[abi:ne180100]<applesauce::CF::NumberRef,0>(const void *a1)
{
  if (a1)
    CFRelease(a1);
}

uint64_t std::__split_buffer<applesauce::CF::NumberRef>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  const void *v4;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    v4 = *(const void **)(i - 8);
    *(_QWORD *)(a1 + 16) = i - 8;
    std::__destroy_at[abi:ne180100]<applesauce::CF::NumberRef,0>(v4);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

double applesauce::CF::details::find_at_key_or_optional<std::string,std::string const&>(uint64_t a1, const __CFDictionary *a2, const UInt8 *a3)
{
  const __CFString *v4;
  double result;
  const __CFString *v6;
  CFTypeID TypeID;
  char *CStringPtr;
  CFIndex Length;
  UInt8 *p_b;
  __int128 __b;
  uint64_t v12;
  CFIndex maxBufLen;
  CFRange v14;
  CFRange v15;

  v4 = (const __CFString *)applesauce::CF::details::at_key<std::string const&>(a2, a3);
  if (v4 && (v6 = v4, TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(v6)))
  {
    CStringPtr = (char *)CFStringGetCStringPtr(v6, 0x8000100u);
    if (CStringPtr)
    {
      std::string::basic_string[abi:ne180100]<0>(&__b, CStringPtr);
    }
    else
    {
      Length = CFStringGetLength(v6);
      maxBufLen = 0;
      v14.location = 0;
      v14.length = Length;
      CFStringGetBytes(v6, v14, 0x8000100u, 0, 0, 0, 0, &maxBufLen);
      std::string::basic_string[abi:ne180100](&__b, maxBufLen, 0);
      if (v12 >= 0)
        p_b = (UInt8 *)&__b;
      else
        p_b = (UInt8 *)__b;
      v15.location = 0;
      v15.length = Length;
      CFStringGetBytes(v6, v15, 0x8000100u, 0, 0, p_b, maxBufLen, &maxBufLen);
    }
    result = *(double *)&__b;
    *(_OWORD *)a1 = __b;
    *(_QWORD *)(a1 + 16) = v12;
    *(_BYTE *)(a1 + 24) = 1;
  }
  else
  {
    *(_BYTE *)a1 = 0;
    *(_BYTE *)(a1 + 24) = 0;
  }
  return result;
}

uint64_t std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>(uint64_t **a1, void **a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t **v6;
  _QWORD *v8;
  uint64_t result;
  uint64_t **v10;
  uint64_t *v11;
  std::string *v12;
  uint64_t *v13;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    do
    {
      while (1)
      {
        v6 = (uint64_t **)v5;
        v8 = v5 + 4;
        if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(a2, (void **)v5 + 4) & 0x80) == 0)
          break;
        v5 = *v6;
        v10 = v6;
        if (!*v6)
          goto LABEL_9;
      }
      result = std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v8, a2);
      if ((result & 0x80) == 0)
        return result;
      v10 = v6 + 1;
      v5 = v6[1];
    }
    while (v5);
  }
  else
  {
    v10 = a1 + 1;
  }
LABEL_9:
  v11 = (uint64_t *)operator new(0x38uLL);
  v12 = (std::string *)(v11 + 4);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v12, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v12->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    v11[6] = *(_QWORD *)(a3 + 16);
  }
  *v11 = 0;
  v11[1] = 0;
  v11[2] = (uint64_t)v6;
  *v10 = v11;
  v13 = (uint64_t *)**a1;
  if (v13)
  {
    *a1 = v13;
    v11 = *v10;
  }
  result = (uint64_t)std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v11);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

void sub_1D4EAFD30(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

const __CFNumber *applesauce::CF::DictionaryRef_proxy::at_as<int,std::string const&>(const __CFDictionary *a1, const UInt8 *a2)
{
  const __CFNumber *result;

  result = (const __CFNumber *)applesauce::CF::details::at_key<std::string const&>(a1, a2);
  if (result)
    return (const __CFNumber *)applesauce::CF::convert_as<int,0>(result);
  return result;
}

const __CFNumber *applesauce::CF::DictionaryRef_proxy::at_as<unsigned int,std::string const&>(const __CFDictionary *a1, const UInt8 *a2)
{
  const __CFNumber *result;

  result = (const __CFNumber *)applesauce::CF::details::at_key<std::string const&>(a1, a2);
  if (result)
    return (const __CFNumber *)applesauce::CF::convert_as<unsigned int,0>(result);
  return result;
}

void applesauce::CF::details::find_at_key_or_optional<applesauce::CF::DictionaryRef,std::string const&>(_BYTE *a1, const __CFDictionary *a2, const UInt8 *a3)
{
  const void *v4;
  const void *v5;
  CFTypeID v6;
  char v7;

  v4 = applesauce::CF::details::at_key<std::string const&>(a2, a3);
  if (!v4)
    goto LABEL_5;
  v5 = v4;
  CFRetain(v4);
  v6 = CFGetTypeID(v5);
  if (v6 != CFDictionaryGetTypeID())
  {
    CFRelease(v5);
LABEL_5:
    v7 = 0;
    *a1 = 0;
    goto LABEL_6;
  }
  *(_QWORD *)a1 = v5;
  v7 = 1;
LABEL_6:
  a1[8] = v7;
}

uint64_t std::__optional_destruct_base<applesauce::CF::DictionaryRef,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  const void *v2;

  if (*(_BYTE *)(a1 + 8))
  {
    v2 = *(const void **)a1;
    if (*(_QWORD *)a1)
      CFRelease(v2);
  }
  return a1;
}

void MIDI2::DeviceInfo::deserialize(MIDI2::DeviceInfo *this, const applesauce::CF::DictionaryRef *a2, const __CFDictionary **a3)
{
  int v6;
  uint64_t v7;
  _QWORD *v8;
  unsigned int v9;
  __int16 v10;
  unsigned int v11;
  __int16 v12;
  int v13;
  uint64_t v14;
  _QWORD *v15;
  void *exception;
  void *v17;
  void *v18;
  void *v19;
  void *__p[2];
  char v21;
  void *v22[2];
  char v23;
  unsigned __int8 v24;

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = (char *)this + 8;
  std::string::basic_string[abi:ne180100]<0>(__p, "manufacturer_id");
  if (!*a3)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  applesauce::CF::details::find_at_key_or_optional<std::vector<unsigned long long>,std::string const&>(v22, *a3, (const UInt8 *)__p);
  v6 = v24;
  if (v24)
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t **)this, __p, (uint64_t)__p);
  else
    LOBYTE(v22[0]) = 0;
  if (v21 < 0)
    operator delete(__p[0]);
  if (v6)
  {
    v7 = 0;
    v8 = v22[0];
    do
    {
      *((_BYTE *)a2 + v7) = v8[v7];
      ++v7;
    }
    while (v7 != 3);
    operator delete(v8);
  }
  std::string::basic_string[abi:ne180100]<0>(v22, "family");
  if (!*a3)
  {
    v17 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v17, "Could not construct");
  }
  v9 = applesauce::CF::DictionaryRef_proxy::at_as<unsigned short,std::string const&>(*a3, (const UInt8 *)v22);
  if (v9 >= 0x10000)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t **)this, v22, (uint64_t)v22);
    v10 = v9;
  }
  else
  {
    v10 = 0;
  }
  if (v23 < 0)
    operator delete(v22[0]);
  if (v9 >= 0x10000)
    *((_WORD *)a2 + 2) = v10 | v9 & 0xFF00;
  std::string::basic_string[abi:ne180100]<0>(v22, "model_number");
  if (!*a3)
  {
    v18 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v18, "Could not construct");
  }
  v11 = applesauce::CF::DictionaryRef_proxy::at_as<unsigned short,std::string const&>(*a3, (const UInt8 *)v22);
  if (v11 >= 0x10000)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t **)this, v22, (uint64_t)v22);
    v12 = v11;
  }
  else
  {
    v12 = 0;
  }
  if (v23 < 0)
    operator delete(v22[0]);
  if (v11 >= 0x10000)
    *((_WORD *)a2 + 3) = v12 | v11 & 0xFF00;
  std::string::basic_string[abi:ne180100]<0>(__p, "revision_level");
  if (!*a3)
  {
    v19 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v19, "Could not construct");
  }
  applesauce::CF::details::find_at_key_or_optional<std::vector<unsigned long long>,std::string const&>(v22, *a3, (const UInt8 *)__p);
  v13 = v24;
  if (v24)
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t **)this, __p, (uint64_t)__p);
  else
    LOBYTE(v22[0]) = 0;
  if (v21 < 0)
    operator delete(__p[0]);
  if (v13)
  {
    v14 = 0;
    v15 = v22[0];
    do
    {
      *((_BYTE *)a2 + v14 + 8) = v15[v14];
      ++v14;
    }
    while (v14 != 4);
    operator delete(v15);
  }
}

void sub_1D4EB0128(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  char **v21;

  if (a15 < 0)
    operator delete(__p);
  std::__tree<std::string>::destroy(*v21);
  _Unwind_Resume(a1);
}

uint64_t applesauce::CF::details::find_at_key_or_optional<BOOL,std::string const&>(const __CFDictionary *a1, const UInt8 *a2)
{
  const __CFNumber *v2;
  int v3;

  v2 = (const __CFNumber *)applesauce::CF::details::at_key<std::string const&>(a1, a2);
  if (v2)
  {
    LOWORD(v2) = applesauce::CF::convert_as<BOOL,0>(v2);
    v3 = BYTE1(v2);
  }
  else
  {
    v3 = 0;
  }
  return v2 | (v3 << 8);
}

void applesauce::CF::details::find_at_key_or_optional<applesauce::CF::ArrayRef,std::string const&>(_BYTE *a1, const __CFDictionary *a2, const UInt8 *a3)
{
  const void *v4;
  const void *v5;
  CFTypeID v6;
  char v7;

  v4 = applesauce::CF::details::at_key<std::string const&>(a2, a3);
  if (!v4)
    goto LABEL_5;
  v5 = v4;
  CFRetain(v4);
  v6 = CFGetTypeID(v5);
  if (v6 != CFArrayGetTypeID())
  {
    CFRelease(v5);
LABEL_5:
    v7 = 0;
    *a1 = 0;
    goto LABEL_6;
  }
  *(_QWORD *)a1 = v5;
  v7 = 1;
LABEL_6:
  a1[8] = v7;
}

uint64_t std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  const void *v2;

  if (*(_BYTE *)(a1 + 8))
  {
    v2 = *(const void **)a1;
    if (*(_QWORD *)a1)
      CFRelease(v2);
  }
  return a1;
}

CFTypeRef applesauce::CF::details::at_to<applesauce::CF::TypeRef>(_QWORD *a1, CFArrayRef theArray, unint64_t a3)
{
  const void *ValueAtIndex;
  const void *v7;
  CFTypeRef result;
  applesauce::CF *exception;

  if (CFArrayGetCount(theArray) <= a3
    || (ValueAtIndex = CFArrayGetValueAtIndex(theArray, a3), (v7 = ValueAtIndex) == 0))
  {
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::not_found(exception);
  }
  result = CFRetain(ValueAtIndex);
  *a1 = v7;
  return result;
}

void sub_1D4EB0314()
{
  void *v0;

}

void sub_1D4EB032C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

applesauce::CF::DictionaryRef *applesauce::CF::TypeRef::operator applesauce::CF::DictionaryRef(applesauce::CF::DictionaryRef *a1, CFTypeRef *a2)
{
  CFTypeID v4;
  CFTypeRef v5;
  applesauce::CF *exception;

  if (*a2)
  {
    v4 = CFGetTypeID(*a2);
    if (v4 != CFDictionaryGetTypeID())
    {
      exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
      applesauce::CF::construct_error(exception);
    }
    v5 = *a2;
    if (v5)
      CFRetain(v5);
  }
  else
  {
    v5 = 0;
  }
  return applesauce::CF::DictionaryRef::DictionaryRef(a1, v5);
}

void sub_1D4EB03C0()
{
  void *v0;

}

void sub_1D4EB03D8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<std::unique_ptr<UMPStream::FunctionBlock>>::__swap_out_circular_buffer(_QWORD *result, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;

  v3 = (_QWORD *)*result;
  v2 = (_QWORD *)result[1];
  v4 = a2[1];
  while (v2 != v3)
  {
    v5 = *--v2;
    *v2 = 0;
    *(_QWORD *)(v4 - 8) = v5;
    v4 -= 8;
  }
  a2[1] = v4;
  v6 = (_QWORD *)*result;
  *result = v4;
  a2[1] = v6;
  v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<std::unique_ptr<UMPStream::FunctionBlock>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;
    v4 = *(_QWORD *)(i - 8);
    *(_QWORD *)(i - 8) = 0;
    if (v4)
      std::default_delete<UMPStream::FunctionBlock>::operator()[abi:ne180100](v4);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

const __CFNumber *applesauce::CF::details::find_at_key_or_optional<unsigned long long,std::string const&>(const __CFDictionary *a1, const UInt8 *a2)
{
  const __CFNumber *result;

  result = (const __CFNumber *)applesauce::CF::details::at_key<std::string const&>(a1, a2);
  if (result)
    return applesauce::CF::convert_as<unsigned long long,0>(result);
  return result;
}

const void *applesauce::CF::details::at_key<std::string const&>(const __CFDictionary *a1, const UInt8 *a2)
{
  const void *Value;
  CFIndex v4;
  CFIndex v5;
  CFStringRef v6;
  void *exception;

  v4 = *((_QWORD *)a2 + 1);
  if (*((char *)a2 + 23) >= 0)
  {
    v5 = a2[23];
  }
  else
  {
    a2 = *(const UInt8 **)a2;
    v5 = v4;
  }
  v6 = CFStringCreateWithBytes(0, a2, v5, 0x8000100u, 0);
  if (!v6)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  if (a1)
    Value = CFDictionaryGetValue(a1, v6);
  CFRelease(v6);
  if (!a1)
    return 0;
  return Value;
}

void sub_1D4EB0590(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EB0540);
}

uint64_t applesauce::CF::convert_as<unsigned char,0>(const __CFNumber *a1)
{
  CFTypeID TypeID;
  int Value;
  CFTypeID v4;
  __int16 v5;
  int v6;
  uint64_t valuePtr;

  TypeID = CFNumberGetTypeID();
  if (TypeID == CFGetTypeID(a1))
  {
    switch(CFNumberGetType(a1))
    {
      case kCFNumberSInt8Type:
        LOBYTE(valuePtr) = 0;
        Value = CFNumberGetValue(a1, kCFNumberSInt8Type, &valuePtr);
        goto LABEL_21;
      case kCFNumberSInt16Type:
        LOWORD(valuePtr) = 0;
        Value = CFNumberGetValue(a1, kCFNumberSInt16Type, &valuePtr);
        goto LABEL_21;
      case kCFNumberSInt32Type:
        LODWORD(valuePtr) = 0;
        Value = CFNumberGetValue(a1, kCFNumberSInt32Type, &valuePtr);
        goto LABEL_21;
      case kCFNumberSInt64Type:
        valuePtr = 0;
        Value = CFNumberGetValue(a1, kCFNumberSInt64Type, &valuePtr);
        goto LABEL_21;
      case kCFNumberFloat32Type:
        v5 = applesauce::CF::details::handle_case<float,unsigned char>(a1, kCFNumberFloat32Type);
        goto LABEL_25;
      case kCFNumberFloat64Type:
        v5 = applesauce::CF::details::handle_case<double,unsigned char>(a1, kCFNumberFloat64Type);
        goto LABEL_25;
      case kCFNumberCharType:
        LOBYTE(valuePtr) = 0;
        Value = CFNumberGetValue(a1, kCFNumberCharType, &valuePtr);
        goto LABEL_21;
      case kCFNumberShortType:
        LOWORD(valuePtr) = 0;
        Value = CFNumberGetValue(a1, kCFNumberShortType, &valuePtr);
        goto LABEL_21;
      case kCFNumberIntType:
        LODWORD(valuePtr) = 0;
        Value = CFNumberGetValue(a1, kCFNumberIntType, &valuePtr);
        goto LABEL_21;
      case kCFNumberLongType:
        valuePtr = 0;
        Value = CFNumberGetValue(a1, kCFNumberLongType, &valuePtr);
        goto LABEL_21;
      case kCFNumberLongLongType:
        valuePtr = 0;
        Value = CFNumberGetValue(a1, kCFNumberLongLongType, &valuePtr);
        goto LABEL_21;
      case kCFNumberFloatType:
        v5 = applesauce::CF::details::handle_case<float,unsigned char>(a1, kCFNumberFloatType);
        goto LABEL_25;
      case kCFNumberDoubleType:
        v5 = applesauce::CF::details::handle_case<double,unsigned char>(a1, kCFNumberDoubleType);
        goto LABEL_25;
      case kCFNumberCFIndexType:
        valuePtr = 0;
        Value = CFNumberGetValue(a1, kCFNumberCFIndexType, &valuePtr);
        goto LABEL_21;
      case kCFNumberNSIntegerType:
        valuePtr = 0;
        Value = CFNumberGetValue(a1, kCFNumberNSIntegerType, &valuePtr);
LABEL_21:
        v6 = Value != 0;
        if (Value)
          LOBYTE(v5) = valuePtr;
        else
          LOBYTE(v5) = 0;
        break;
      case kCFNumberCGFloatType:
        v5 = applesauce::CF::details::handle_case<double,unsigned char>(a1, kCFNumberCGFloatType);
LABEL_25:
        v6 = HIBYTE(v5);
        break;
      default:
        goto LABEL_6;
    }
  }
  else
  {
    v4 = CFBooleanGetTypeID();
    if (v4 == CFGetTypeID(a1))
    {
      LOBYTE(v5) = CFBooleanGetValue(a1);
      v6 = 1;
    }
    else
    {
LABEL_6:
      v6 = 0;
      LOBYTE(v5) = 0;
    }
  }
  return v5 | (v6 << 8);
}

uint64_t applesauce::CF::details::handle_case<float,unsigned char>(const __CFNumber *a1, CFNumberType a2)
{
  int Value;
  int v3;
  float valuePtr;

  valuePtr = 0.0;
  Value = CFNumberGetValue(a1, a2, &valuePtr);
  v3 = (int)valuePtr;
  if (!Value)
    v3 = 0;
  return v3 | ((Value != 0) << 8);
}

uint64_t applesauce::CF::details::handle_case<double,unsigned char>(const __CFNumber *a1, CFNumberType a2)
{
  int Value;
  int v3;
  double valuePtr;

  valuePtr = 0.0;
  Value = CFNumberGetValue(a1, a2, &valuePtr);
  v3 = (int)valuePtr;
  if (!Value)
    v3 = 0;
  return v3 | ((Value != 0) << 8);
}

void applesauce::CF::not_found(applesauce::CF *this)
{
  JUMPOUT(0x1D826B7ECLL);
}

void applesauce::CF::details::find_at_key_or_optional<std::vector<unsigned long long>,std::string const&>(_BYTE *a1, const __CFDictionary *a2, const UInt8 *a3)
{
  const __CFArray *v4;

  v4 = (const __CFArray *)applesauce::CF::details::at_key<std::string const&>(a2, a3);
  if (v4)
  {
    applesauce::CF::convert_as<std::vector<unsigned long long>,0>((uint64_t)a1, v4);
  }
  else
  {
    *a1 = 0;
    a1[24] = 0;
  }
}

const __CFNumber *applesauce::CF::DictionaryRef_proxy::at_as<unsigned short,std::string const&>(const __CFDictionary *a1, const UInt8 *a2)
{
  const __CFNumber *result;
  const __CFNumber *v3;
  CFTypeID TypeID;
  int Value;
  CFTypeID v6;
  unsigned int v7;
  int v8;
  __int16 v9;
  int v10;
  int v11;
  int v12;
  int v13;
  double valuePtr;

  result = (const __CFNumber *)applesauce::CF::details::at_key<std::string const&>(a1, a2);
  if (result)
  {
    v3 = result;
    TypeID = CFNumberGetTypeID();
    if (TypeID == CFGetTypeID(v3))
    {
      switch(CFNumberGetType(v3))
      {
        case kCFNumberSInt8Type:
          LOBYTE(valuePtr) = 0;
          Value = CFNumberGetValue(v3, kCFNumberSInt8Type, &valuePtr);
          goto LABEL_16;
        case kCFNumberSInt16Type:
          LOWORD(valuePtr) = 0;
          v12 = CFNumberGetValue(v3, kCFNumberSInt16Type, &valuePtr);
          goto LABEL_28;
        case kCFNumberSInt32Type:
          LODWORD(valuePtr) = 0;
          v12 = CFNumberGetValue(v3, kCFNumberSInt32Type, &valuePtr);
          goto LABEL_28;
        case kCFNumberSInt64Type:
          valuePtr = 0.0;
          v12 = CFNumberGetValue(v3, kCFNumberSInt64Type, &valuePtr);
          goto LABEL_28;
        case kCFNumberFloat32Type:
          LODWORD(valuePtr) = 0;
          v12 = CFNumberGetValue(v3, kCFNumberFloat32Type, &valuePtr);
          goto LABEL_24;
        case kCFNumberFloat64Type:
          valuePtr = 0.0;
          v12 = CFNumberGetValue(v3, kCFNumberFloat64Type, &valuePtr);
          goto LABEL_30;
        case kCFNumberCharType:
          LOBYTE(valuePtr) = 0;
          Value = CFNumberGetValue(v3, kCFNumberCharType, &valuePtr);
LABEL_16:
          LOBYTE(v11) = LOBYTE(valuePtr);
          if (!Value)
            LOBYTE(v11) = 0;
          v10 = (Value != 0) << 16;
          v9 = (SLOBYTE(valuePtr) >> 7) << 8;
          return (const __CFNumber *)(v10 | v9 & 0xFF00 | v11);
        case kCFNumberShortType:
          LOWORD(valuePtr) = 0;
          v12 = CFNumberGetValue(v3, kCFNumberShortType, &valuePtr);
          goto LABEL_28;
        case kCFNumberIntType:
          LODWORD(valuePtr) = 0;
          v12 = CFNumberGetValue(v3, kCFNumberIntType, &valuePtr);
          goto LABEL_28;
        case kCFNumberLongType:
          valuePtr = 0.0;
          v12 = CFNumberGetValue(v3, kCFNumberLongType, &valuePtr);
          goto LABEL_28;
        case kCFNumberLongLongType:
          valuePtr = 0.0;
          v12 = CFNumberGetValue(v3, kCFNumberLongLongType, &valuePtr);
          goto LABEL_28;
        case kCFNumberFloatType:
          LODWORD(valuePtr) = 0;
          v12 = CFNumberGetValue(v3, kCFNumberFloatType, &valuePtr);
LABEL_24:
          v13 = (int)*(float *)&valuePtr;
          goto LABEL_31;
        case kCFNumberDoubleType:
          valuePtr = 0.0;
          v12 = CFNumberGetValue(v3, kCFNumberDoubleType, &valuePtr);
          goto LABEL_30;
        case kCFNumberCFIndexType:
          valuePtr = 0.0;
          v12 = CFNumberGetValue(v3, kCFNumberCFIndexType, &valuePtr);
          goto LABEL_28;
        case kCFNumberNSIntegerType:
          valuePtr = 0.0;
          v12 = CFNumberGetValue(v3, kCFNumberNSIntegerType, &valuePtr);
LABEL_28:
          v13 = LOWORD(valuePtr);
          goto LABEL_31;
        case kCFNumberCGFloatType:
          valuePtr = 0.0;
          v12 = CFNumberGetValue(v3, kCFNumberCGFloatType, &valuePtr);
LABEL_30:
          v13 = (int)valuePtr;
LABEL_31:
          v11 = v13 | 0x10000;
          if (!v12)
            v11 = 0;
          v9 = v11 & 0xFF00;
          v10 = v11 & 0x10000;
          break;
        default:
          v9 = 0;
          v10 = 0;
          LOBYTE(v11) = 0;
          break;
      }
      return (const __CFNumber *)(v10 | v9 & 0xFF00 | v11);
    }
    else
    {
      v6 = CFBooleanGetTypeID();
      if (v6 == CFGetTypeID(v3))
      {
        v7 = CFBooleanGetValue(v3);
        v8 = 0x10000;
      }
      else
      {
        v7 = 0;
        v8 = 0;
      }
      return (const __CFNumber *)(v8 | v7);
    }
  }
  return result;
}

void applesauce::CF::convert_as<std::vector<unsigned long long>,0>(uint64_t a1, const __CFArray *a2)
{
  CFTypeID TypeID;
  CFIndex Count;
  int v6;
  char *v7;
  uint64_t v8;
  char *v9;
  CFIndex v10;
  uint64_t v11;
  char *v12;
  const __CFNumber *ValueAtIndex;
  const __CFNumber *v14;
  char v15;
  const __CFNumber *v16;
  char *v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;

  TypeID = CFArrayGetTypeID();
  if (TypeID == CFGetTypeID(a2))
  {
    Count = CFArrayGetCount(a2);
    v6 = Count;
    if (Count << 32)
    {
      if (Count << 32 < 0)
LABEL_34:
        std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
      v7 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>((int)Count);
      v9 = &v7[8 * v8];
    }
    else
    {
      v7 = 0;
      v9 = 0;
    }
    if (v6 < 1)
    {
      v17 = v7;
LABEL_30:
      *(_QWORD *)a1 = v7;
      *(_QWORD *)(a1 + 8) = v17;
      *(_QWORD *)(a1 + 16) = v9;
      *(_BYTE *)(a1 + 24) = 1;
    }
    else
    {
      v10 = 0;
      v11 = v6;
      v12 = v7;
      while (1)
      {
        ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(a2, v10);
        v14 = applesauce::CF::convert_as<unsigned long long,0>(ValueAtIndex);
        if (!v15)
          break;
        v16 = v14;
        if (v12 >= v9)
        {
          v18 = (v12 - v7) >> 3;
          v19 = v18 + 1;
          if ((unint64_t)(v18 + 1) >> 61)
            goto LABEL_34;
          if ((v9 - v7) >> 2 > v19)
            v19 = (v9 - v7) >> 2;
          if ((unint64_t)(v9 - v7) >= 0x7FFFFFFFFFFFFFF8)
            v20 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v20 = v19;
          if (v20)
            v20 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v20);
          else
            v21 = 0;
          v22 = (char *)(v20 + 8 * v18);
          *(_QWORD *)v22 = v16;
          v17 = v22 + 8;
          while (v12 != v7)
          {
            v23 = *((_QWORD *)v12 - 1);
            v12 -= 8;
            *((_QWORD *)v22 - 1) = v23;
            v22 -= 8;
          }
          v9 = (char *)(v20 + 8 * v21);
          if (v7)
            operator delete(v7);
          v7 = v22;
        }
        else
        {
          *(_QWORD *)v12 = v14;
          v17 = v12 + 8;
        }
        ++v10;
        v12 = v17;
        if (v10 == v11)
          goto LABEL_30;
      }
      *(_BYTE *)a1 = 0;
      *(_BYTE *)(a1 + 24) = 0;
      if (v7)
        operator delete(v7);
    }
  }
  else
  {
    *(_BYTE *)a1 = 0;
    *(_BYTE *)(a1 + 24) = 0;
  }
}

uint64_t applesauce::CF::convert_as<unsigned int,0>(const __CFNumber *a1)
{
  CFTypeID TypeID;
  int Value;
  CFTypeID v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  unsigned __int8 v12;
  int v13;
  uint64_t v14;
  double valuePtr;

  TypeID = CFNumberGetTypeID();
  if (TypeID == CFGetTypeID(a1))
  {
    switch(CFNumberGetType(a1))
    {
      case kCFNumberSInt8Type:
        LOBYTE(valuePtr) = 0;
        Value = CFNumberGetValue(a1, kCFNumberSInt8Type, &valuePtr);
        goto LABEL_14;
      case kCFNumberSInt16Type:
        LOWORD(valuePtr) = 0;
        v9 = CFNumberGetValue(a1, kCFNumberSInt16Type, &valuePtr);
        goto LABEL_21;
      case kCFNumberSInt32Type:
        LODWORD(valuePtr) = 0;
        v10 = CFNumberGetValue(a1, kCFNumberSInt32Type, &valuePtr);
        goto LABEL_32;
      case kCFNumberSInt64Type:
        valuePtr = 0.0;
        v10 = CFNumberGetValue(a1, kCFNumberSInt64Type, &valuePtr);
        goto LABEL_32;
      case kCFNumberFloat32Type:
        LODWORD(valuePtr) = 0;
        v10 = CFNumberGetValue(a1, kCFNumberFloat32Type, &valuePtr);
        goto LABEL_28;
      case kCFNumberFloat64Type:
        valuePtr = 0.0;
        v10 = CFNumberGetValue(a1, kCFNumberFloat64Type, &valuePtr);
        goto LABEL_34;
      case kCFNumberCharType:
        LOBYTE(valuePtr) = 0;
        Value = CFNumberGetValue(a1, kCFNumberCharType, &valuePtr);
LABEL_14:
        v11 = Value != 0;
        if (Value)
          v12 = LOBYTE(valuePtr);
        else
          v12 = 0;
        v13 = -256;
        if ((v11 & (SLOBYTE(valuePtr) < 0)) == 0)
          v13 = 0;
        v8 = v11 << 32;
        LODWORD(v5) = v13 & 0xFFFFFF00 | v12;
        v7 = v5 & 0xFFFFFF00;
        break;
      case kCFNumberShortType:
        LOWORD(valuePtr) = 0;
        v9 = CFNumberGetValue(a1, kCFNumberShortType, &valuePtr);
LABEL_21:
        if (v9)
          v5 = SLOWORD(valuePtr) & 0xFFFFFFFFLL | 0x100000000;
        else
          v5 = 0;
        goto LABEL_37;
      case kCFNumberIntType:
        LODWORD(valuePtr) = 0;
        v10 = CFNumberGetValue(a1, kCFNumberIntType, &valuePtr);
        goto LABEL_32;
      case kCFNumberLongType:
        valuePtr = 0.0;
        v10 = CFNumberGetValue(a1, kCFNumberLongType, &valuePtr);
        goto LABEL_32;
      case kCFNumberLongLongType:
        valuePtr = 0.0;
        v10 = CFNumberGetValue(a1, kCFNumberLongLongType, &valuePtr);
        goto LABEL_32;
      case kCFNumberFloatType:
        LODWORD(valuePtr) = 0;
        v10 = CFNumberGetValue(a1, kCFNumberFloatType, &valuePtr);
LABEL_28:
        v14 = *(float *)&valuePtr;
        goto LABEL_35;
      case kCFNumberDoubleType:
        valuePtr = 0.0;
        v10 = CFNumberGetValue(a1, kCFNumberDoubleType, &valuePtr);
        goto LABEL_34;
      case kCFNumberCFIndexType:
        valuePtr = 0.0;
        v10 = CFNumberGetValue(a1, kCFNumberCFIndexType, &valuePtr);
        goto LABEL_32;
      case kCFNumberNSIntegerType:
        valuePtr = 0.0;
        v10 = CFNumberGetValue(a1, kCFNumberNSIntegerType, &valuePtr);
LABEL_32:
        v14 = LODWORD(valuePtr);
        goto LABEL_35;
      case kCFNumberCGFloatType:
        valuePtr = 0.0;
        v10 = CFNumberGetValue(a1, kCFNumberCGFloatType, &valuePtr);
LABEL_34:
        v14 = valuePtr;
LABEL_35:
        v5 = v14 | 0x100000000;
        if (!v10)
          v5 = 0;
LABEL_37:
        v7 = v5 & 0xFFFFFF00;
        v8 = v5 & 0x100000000;
        break;
      default:
        v7 = 0;
        v8 = 0;
        LOBYTE(v5) = 0;
        break;
    }
    v6 = v8 | v7 & 0xFFFFFF00;
    v5 = v5;
  }
  else
  {
    v4 = CFBooleanGetTypeID();
    if (v4 == CFGetTypeID(a1))
    {
      v5 = CFBooleanGetValue(a1);
      v6 = 0x100000000;
    }
    else
    {
      v5 = 0;
      v6 = 0;
    }
  }
  return v6 | v5;
}

uint64_t std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(_QWORD *a1, void **a2)
{
  size_t v2;
  size_t v3;
  int v4;
  void *v5;
  size_t v6;

  v2 = *((unsigned __int8 *)a1 + 23);
  v3 = a1[1];
  if ((v2 & 0x80u) != 0)
  {
    a1 = (_QWORD *)*a1;
    v2 = v3;
  }
  v4 = *((char *)a2 + 23);
  if (v4 >= 0)
    v5 = a2;
  else
    v5 = *a2;
  if (v4 >= 0)
    v6 = *((unsigned __int8 *)a2 + 23);
  else
    v6 = (size_t)a2[1];
  return std::operator<=>[abi:ne180100]<char,std::char_traits<char>>(a1, v2, v5, v6);
}

uint64_t std::operator<=>[abi:ne180100]<char,std::char_traits<char>>(const void *a1, size_t a2, void *__s2, size_t a4)
{
  size_t v7;
  int v8;

  if (a4 >= a2)
    v7 = a2;
  else
    v7 = a4;
  v8 = memcmp(a1, __s2, v7);
  if (v8)
  {
    if ((v8 & 0x80000000) == 0)
      return 1;
  }
  else
  {
    if (a2 == a4)
      return 0;
    if (a2 >= a4)
      return 1;
  }
  return 255;
}

void std::__introsort<std::_RangeAlgPolicy,UMPStream::EndpointPair::addFunctionBlock(std::unique_ptr<UMPStream::FunctionBlock>)::$_1 &,std::unique_ptr<UMPStream::FunctionBlock>*,false>(uint64_t *a1, uint64_t *a2, uint64_t a3, char a4)
{
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  BOOL v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t *v46;
  uint64_t *v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  unsigned int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t *v55;
  BOOL v57;
  uint64_t v58;
  uint64_t *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t i;
  uint64_t *v64;
  uint64_t *v65;
  uint64_t v66;
  int64_t v67;
  int64_t v68;
  int64_t v69;
  uint64_t v70;
  uint64_t *v71;
  uint64_t v72;
  uint64_t *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t *v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v98;
  uint64_t v99;
  unsigned int v100;
  uint64_t v101;
  uint64_t *v102;
  uint64_t v103;

LABEL_1:
  v8 = a2 - 1;
  v9 = a1;
  while (2)
  {
    a1 = v9;
    v10 = (char *)a2 - (char *)v9;
    v11 = a2 - v9;
    switch(v11)
    {
      case 0:
      case 1:
        return;
      case 2:
        v45 = *a1;
        if (*(unsigned __int8 *)(*v8 + 96) < *(unsigned __int8 *)(*a1 + 96))
        {
          *a1 = *v8;
          *v8 = v45;
        }
        return;
      case 3:
        std::__sort3[abi:ne180100]<std::_RangeAlgPolicy,UMPStream::EndpointPair::addFunctionBlock(std::unique_ptr<UMPStream::FunctionBlock>)::$_1 &,std::unique_ptr<UMPStream::FunctionBlock>*>(a1, a1 + 1, a2 - 1);
        return;
      case 4:
        std::__sort4[abi:ne180100]<std::_RangeAlgPolicy,UMPStream::EndpointPair::addFunctionBlock(std::unique_ptr<UMPStream::FunctionBlock>)::$_1 &,std::unique_ptr<UMPStream::FunctionBlock>*>(a1, a1 + 1, a1 + 2, a2 - 1);
        return;
      case 5:
        v46 = a1 + 1;
        v47 = a1 + 2;
        v48 = a1 + 3;
        std::__sort4[abi:ne180100]<std::_RangeAlgPolicy,UMPStream::EndpointPair::addFunctionBlock(std::unique_ptr<UMPStream::FunctionBlock>)::$_1 &,std::unique_ptr<UMPStream::FunctionBlock>*>(a1, a1 + 1, a1 + 2, a1 + 3);
        v49 = a1[3];
        if (*(unsigned __int8 *)(*v8 + 96) < *(unsigned __int8 *)(v49 + 96))
        {
          *v48 = *v8;
          *v8 = v49;
          v50 = *v48;
          v51 = *(unsigned __int8 *)(*v48 + 96);
          v52 = *v47;
          if (v51 < *(unsigned __int8 *)(*v47 + 96))
          {
            *v47 = v50;
            *v48 = v52;
            v53 = *v46;
            if (v51 < *(unsigned __int8 *)(*v46 + 96))
            {
              a1[1] = v50;
              a1[2] = v53;
              v54 = *a1;
              if (v51 < *(unsigned __int8 *)(*a1 + 96))
              {
                *a1 = v50;
                a1[1] = v54;
              }
            }
          }
        }
        return;
      default:
        if (v10 <= 191)
        {
          v55 = a1 + 1;
          v57 = a1 == a2 || v55 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v57)
            {
              v58 = 0;
              v59 = a1;
              do
              {
                v60 = *v59;
                v61 = v59[1];
                v59 = v55;
                if (*(unsigned __int8 *)(v61 + 96) < *(unsigned __int8 *)(v60 + 96))
                {
                  v62 = 0;
                  *v55 = 0;
                  for (i = v58; ; i -= 8)
                  {
                    v64 = (uint64_t *)((char *)a1 + i);
                    *v64 = 0;
                    v64[1] = v60;
                    if (v62)
                      std::default_delete<UMPStream::FunctionBlock>::operator()[abi:ne180100](v62);
                    if (!i)
                      break;
                    v65 = (uint64_t *)((char *)a1 + i);
                    v60 = *(uint64_t *)((char *)a1 + i - 8);
                    if (*(unsigned __int8 *)(v61 + 96) >= *(unsigned __int8 *)(v60 + 96))
                      goto LABEL_84;
                    v62 = *v64;
                  }
                  v65 = a1;
LABEL_84:
                  v66 = *v65;
                  *v65 = v61;
                  if (v66)
                    std::default_delete<UMPStream::FunctionBlock>::operator()[abi:ne180100](v66);
                }
                v55 = v59 + 1;
                v58 += 8;
              }
              while (v59 + 1 != a2);
            }
          }
          else if (!v57)
          {
            do
            {
              v98 = *a1;
              v99 = a1[1];
              a1 = v55;
              v100 = *(unsigned __int8 *)(v99 + 96);
              if (v100 < *(unsigned __int8 *)(v98 + 96))
              {
                v101 = 0;
                *a1 = 0;
                v102 = a1;
                do
                {
                  *(v102 - 1) = 0;
                  *v102 = v98;
                  if (v101)
                  {
                    std::default_delete<UMPStream::FunctionBlock>::operator()[abi:ne180100](v101);
                    v100 = *(unsigned __int8 *)(v99 + 96);
                  }
                  v103 = *--v102;
                  v101 = v103;
                  v98 = *(v102 - 1);
                }
                while (v100 < *(unsigned __int8 *)(v98 + 96));
                *v102 = v99;
                if (v101)
                  std::default_delete<UMPStream::FunctionBlock>::operator()[abi:ne180100](v101);
              }
              v55 = a1 + 1;
            }
            while (a1 + 1 != a2);
          }
          return;
        }
        if (!a3)
        {
          if (a1 == a2)
            return;
          v67 = (unint64_t)(v11 - 2) >> 1;
          v68 = v67;
          do
          {
            v69 = v68;
            if (v67 >= v68)
            {
              v70 = (2 * v68) | 1;
              v71 = &a1[v70];
              if (2 * v69 + 2 >= v11)
              {
                v72 = *v71;
              }
              else
              {
                v72 = *v71;
                if (*(unsigned __int8 *)(*v71 + 96) < *(unsigned __int8 *)(v71[1] + 96))
                {
                  v72 = v71[1];
                  ++v71;
                  v70 = 2 * v69 + 2;
                }
              }
              v73 = &a1[v69];
              v74 = *v73;
              if (*(unsigned __int8 *)(v72 + 96) >= *(unsigned __int8 *)(*v73 + 96))
              {
                *v73 = 0;
                v75 = *v71;
                do
                {
                  v76 = v71;
                  *v71 = 0;
                  v77 = *v73;
                  *v73 = v75;
                  if (v77)
                    std::default_delete<UMPStream::FunctionBlock>::operator()[abi:ne180100](v77);
                  if (v67 < v70)
                    break;
                  v71 = &a1[(2 * v70) | 1];
                  if (2 * v70 + 2 >= v11)
                  {
                    v75 = *v71;
                    v70 = (2 * v70) | 1;
                  }
                  else
                  {
                    v75 = *v71;
                    if (*(unsigned __int8 *)(*v71 + 96) >= *(unsigned __int8 *)(v71[1] + 96))
                    {
                      v70 = (2 * v70) | 1;
                    }
                    else
                    {
                      v75 = v71[1];
                      ++v71;
                      v70 = 2 * v70 + 2;
                    }
                  }
                  v73 = v76;
                }
                while (*(unsigned __int8 *)(v75 + 96) >= *(unsigned __int8 *)(v74 + 96));
                v78 = *v76;
                *v76 = v74;
                if (v78)
                  std::default_delete<UMPStream::FunctionBlock>::operator()[abi:ne180100](v78);
              }
            }
            v68 = v69 - 1;
          }
          while (v69);
          v79 = (unint64_t)v10 >> 3;
          while (2)
          {
            v80 = 0;
            v81 = *a1;
            *a1 = 0;
            v82 = a1;
            do
            {
              v83 = (uint64_t)&v82[v80 + 1];
              if (2 * v80 + 2 >= v79)
              {
                v84 = *(_QWORD *)v83;
                v80 = (2 * v80) | 1;
              }
              else
              {
                v84 = *(_QWORD *)v83;
                if (*(unsigned __int8 *)(*(_QWORD *)v83 + 96) >= *(unsigned __int8 *)(v82[v80 + 2] + 96))
                {
                  v80 = (2 * v80) | 1;
                }
                else
                {
                  v84 = v82[v80 + 2];
                  v83 = (uint64_t)&v82[v80 + 2];
                  v80 = 2 * v80 + 2;
                }
              }
              *(_QWORD *)v83 = 0;
              v85 = *v82;
              *v82 = v84;
              if (v85)
                std::default_delete<UMPStream::FunctionBlock>::operator()[abi:ne180100](v85);
              v82 = (uint64_t *)v83;
            }
            while (v80 <= (uint64_t)((unint64_t)(v79 - 2) >> 1));
            if ((uint64_t *)v83 == --a2)
            {
              v96 = *(_QWORD *)v83;
              *(_QWORD *)v83 = v81;
              if (!v96)
                goto LABEL_136;
            }
            else
            {
              v86 = *a2;
              *a2 = 0;
              v87 = *(_QWORD *)v83;
              *(_QWORD *)v83 = v86;
              if (v87)
                std::default_delete<UMPStream::FunctionBlock>::operator()[abi:ne180100](v87);
              v88 = *a2;
              *a2 = v81;
              if (v88)
                std::default_delete<UMPStream::FunctionBlock>::operator()[abi:ne180100](v88);
              v89 = v83 + 8 - (_QWORD)a1;
              if (v89 < 9)
                goto LABEL_136;
              v90 = (((unint64_t)v89 >> 3) - 2) >> 1;
              v91 = &a1[v90];
              v92 = *(_QWORD *)v83;
              if (*(unsigned __int8 *)(*v91 + 96) >= *(unsigned __int8 *)(*(_QWORD *)v83 + 96))
                goto LABEL_136;
              *(_QWORD *)v83 = 0;
              v93 = *v91;
              do
              {
                v94 = v91;
                *v91 = 0;
                v95 = *(_QWORD *)v83;
                *(_QWORD *)v83 = v93;
                if (v95)
                  std::default_delete<UMPStream::FunctionBlock>::operator()[abi:ne180100](v95);
                if (!v90)
                  break;
                v90 = (v90 - 1) >> 1;
                v91 = &a1[v90];
                v93 = *v91;
                v83 = (uint64_t)v94;
              }
              while (*(unsigned __int8 *)(*v91 + 96) < *(unsigned __int8 *)(v92 + 96));
              v96 = *v94;
              *v94 = v92;
              if (!v96)
              {
LABEL_136:
                if (v79-- <= 2)
                  return;
                continue;
              }
            }
            break;
          }
          std::default_delete<UMPStream::FunctionBlock>::operator()[abi:ne180100](v96);
          goto LABEL_136;
        }
        v12 = (unint64_t)v11 >> 1;
        v13 = &a1[(unint64_t)v11 >> 1];
        if ((unint64_t)v10 < 0x401)
        {
          std::__sort3[abi:ne180100]<std::_RangeAlgPolicy,UMPStream::EndpointPair::addFunctionBlock(std::unique_ptr<UMPStream::FunctionBlock>)::$_1 &,std::unique_ptr<UMPStream::FunctionBlock>*>(v13, a1, a2 - 1);
        }
        else
        {
          std::__sort3[abi:ne180100]<std::_RangeAlgPolicy,UMPStream::EndpointPair::addFunctionBlock(std::unique_ptr<UMPStream::FunctionBlock>)::$_1 &,std::unique_ptr<UMPStream::FunctionBlock>*>(a1, v13, a2 - 1);
          std::__sort3[abi:ne180100]<std::_RangeAlgPolicy,UMPStream::EndpointPair::addFunctionBlock(std::unique_ptr<UMPStream::FunctionBlock>)::$_1 &,std::unique_ptr<UMPStream::FunctionBlock>*>(a1 + 1, v13 - 1, a2 - 2);
          std::__sort3[abi:ne180100]<std::_RangeAlgPolicy,UMPStream::EndpointPair::addFunctionBlock(std::unique_ptr<UMPStream::FunctionBlock>)::$_1 &,std::unique_ptr<UMPStream::FunctionBlock>*>(a1 + 2, &a1[v12 + 1], a2 - 3);
          std::__sort3[abi:ne180100]<std::_RangeAlgPolicy,UMPStream::EndpointPair::addFunctionBlock(std::unique_ptr<UMPStream::FunctionBlock>)::$_1 &,std::unique_ptr<UMPStream::FunctionBlock>*>(v13 - 1, v13, &a1[v12 + 1]);
          v14 = *a1;
          *a1 = *v13;
          *v13 = v14;
        }
        --a3;
        v15 = *a1;
        if ((a4 & 1) == 0)
        {
          v16 = *(unsigned __int8 *)(v15 + 96);
          if (*(unsigned __int8 *)(*(a1 - 1) + 96) < v16)
            goto LABEL_11;
          *a1 = 0;
          if (v16 >= *(unsigned __int8 *)(*v8 + 96))
          {
            v34 = a1 + 1;
            do
            {
              v9 = v34;
              if (v34 >= a2)
                break;
              ++v34;
            }
            while (v16 >= *(unsigned __int8 *)(*v9 + 96));
          }
          else
          {
            v9 = a1;
            do
            {
              v33 = v9[1];
              ++v9;
            }
            while (v16 >= *(unsigned __int8 *)(v33 + 96));
          }
          v35 = a2;
          if (v9 < a2)
          {
            v35 = a2;
            do
              v36 = *--v35;
            while (v16 < *(unsigned __int8 *)(v36 + 96));
          }
          if (v9 < v35)
          {
            v37 = *v9;
            v38 = *v35;
            do
            {
              *v9 = v38;
              *v35 = v37;
              do
              {
                v39 = v9[1];
                ++v9;
                v37 = v39;
              }
              while (v16 >= *(unsigned __int8 *)(v39 + 96));
              do
              {
                v40 = *--v35;
                v38 = v40;
              }
              while (v16 < *(unsigned __int8 *)(v40 + 96));
            }
            while (v9 < v35);
          }
          v41 = v9 - 1;
          if (v9 - 1 != a1)
          {
            v42 = *v41;
            *v41 = 0;
            v43 = *a1;
            *a1 = v42;
            if (v43)
              std::default_delete<UMPStream::FunctionBlock>::operator()[abi:ne180100](v43);
          }
          a4 = 0;
          v44 = *v41;
          *v41 = v15;
          if (v44)
          {
            std::default_delete<UMPStream::FunctionBlock>::operator()[abi:ne180100](v44);
            a4 = 0;
          }
          continue;
        }
        v16 = *(unsigned __int8 *)(v15 + 96);
LABEL_11:
        *a1 = 0;
        v17 = a1;
        do
        {
          v18 = v17;
          v20 = v17[1];
          ++v17;
          v19 = v20;
        }
        while (*(unsigned __int8 *)(v20 + 96) < v16);
        v21 = a2;
        if (v18 == a1)
        {
          v21 = a2;
          do
          {
            if (v17 >= v21)
              break;
            v23 = *--v21;
          }
          while (*(unsigned __int8 *)(v23 + 96) >= v16);
        }
        else
        {
          do
            v22 = *--v21;
          while (*(unsigned __int8 *)(v22 + 96) >= v16);
        }
        if (v17 < v21)
        {
          v24 = *v21;
          v25 = v17;
          v26 = v21;
          do
          {
            *v25 = v24;
            *v26 = v19;
            do
            {
              v18 = v25;
              v27 = v25[1];
              ++v25;
              v19 = v27;
            }
            while (*(unsigned __int8 *)(v27 + 96) < v16);
            do
            {
              v28 = *--v26;
              v24 = v28;
            }
            while (*(unsigned __int8 *)(v28 + 96) >= v16);
          }
          while (v25 < v26);
        }
        if (v18 != a1)
        {
          v29 = *v18;
          *v18 = 0;
          v30 = *a1;
          *a1 = v29;
          if (v30)
            std::default_delete<UMPStream::FunctionBlock>::operator()[abi:ne180100](v30);
        }
        v31 = *v18;
        *v18 = v15;
        if (v31)
          std::default_delete<UMPStream::FunctionBlock>::operator()[abi:ne180100](v31);
        if (v17 < v21)
        {
LABEL_33:
          std::__introsort<std::_RangeAlgPolicy,UMPStream::EndpointPair::addFunctionBlock(std::unique_ptr<UMPStream::FunctionBlock>)::$_1 &,std::unique_ptr<UMPStream::FunctionBlock>*,false>(a1, v18, a3, a4 & 1);
          a4 = 0;
          v9 = v18 + 1;
          continue;
        }
        v32 = std::__insertion_sort_incomplete[abi:ne180100]<std::_RangeAlgPolicy,UMPStream::EndpointPair::addFunctionBlock(std::unique_ptr<UMPStream::FunctionBlock>)::$_1 &,std::unique_ptr<UMPStream::FunctionBlock>*>(a1, v18);
        v9 = v18 + 1;
        if (!std::__insertion_sort_incomplete[abi:ne180100]<std::_RangeAlgPolicy,UMPStream::EndpointPair::addFunctionBlock(std::unique_ptr<UMPStream::FunctionBlock>)::$_1 &,std::unique_ptr<UMPStream::FunctionBlock>*>(v18 + 1, a2))
        {
          if (v32)
            continue;
          goto LABEL_33;
        }
        a2 = v18;
        if (!v32)
          goto LABEL_1;
        return;
    }
  }
}

uint64_t *std::__sort3[abi:ne180100]<std::_RangeAlgPolicy,UMPStream::EndpointPair::addFunctionBlock(std::unique_ptr<UMPStream::FunctionBlock>)::$_1 &,std::unique_ptr<UMPStream::FunctionBlock>*>(uint64_t *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;

  v3 = *a2;
  v4 = *(unsigned __int8 *)(*a2 + 96);
  v5 = *result;
  v6 = *(unsigned __int8 *)(*result + 96);
  v7 = *a3;
  v8 = *(unsigned __int8 *)(*a3 + 96);
  if (v4 >= v6)
  {
    if (v8 < v4)
    {
      *a2 = v7;
      *a3 = v3;
      v9 = *result;
      if (*(unsigned __int8 *)(*a2 + 96) < *(unsigned __int8 *)(*result + 96))
      {
        *result = *a2;
        *a2 = v9;
      }
    }
  }
  else
  {
    if (v8 >= v4)
    {
      *result = v3;
      *a2 = v5;
      if (*(unsigned __int8 *)(*a3 + 96) >= v6)
        return result;
      *a2 = *a3;
    }
    else
    {
      *result = v7;
    }
    *a3 = v5;
  }
  return result;
}

uint64_t *std::__sort4[abi:ne180100]<std::_RangeAlgPolicy,UMPStream::EndpointPair::addFunctionBlock(std::unique_ptr<UMPStream::FunctionBlock>)::$_1 &,std::unique_ptr<UMPStream::FunctionBlock>*>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  result = std::__sort3[abi:ne180100]<std::_RangeAlgPolicy,UMPStream::EndpointPair::addFunctionBlock(std::unique_ptr<UMPStream::FunctionBlock>)::$_1 &,std::unique_ptr<UMPStream::FunctionBlock>*>(a1, a2, a3);
  v9 = *a3;
  if (*(unsigned __int8 *)(*a4 + 96) < *(unsigned __int8 *)(*a3 + 96))
  {
    *a3 = *a4;
    *a4 = v9;
    v10 = *a2;
    if (*(unsigned __int8 *)(*a3 + 96) < *(unsigned __int8 *)(*a2 + 96))
    {
      *a2 = *a3;
      *a3 = v10;
      v11 = *a1;
      if (*(unsigned __int8 *)(*a2 + 96) < *(unsigned __int8 *)(*a1 + 96))
      {
        *a1 = *a2;
        *a2 = v11;
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_RangeAlgPolicy,UMPStream::EndpointPair::addFunctionBlock(std::unique_ptr<UMPStream::FunctionBlock>)::$_1 &,std::unique_ptr<UMPStream::FunctionBlock>*>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;
  _BOOL8 result;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t i;
  char *v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  v4 = a2 - a1;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = *(a2 - 1);
      v7 = *a1;
      if (*(unsigned __int8 *)(v6 + 96) < *(unsigned __int8 *)(*a1 + 96))
      {
        *a1 = v6;
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_RangeAlgPolicy,UMPStream::EndpointPair::addFunctionBlock(std::unique_ptr<UMPStream::FunctionBlock>)::$_1 &,std::unique_ptr<UMPStream::FunctionBlock>*>(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_RangeAlgPolicy,UMPStream::EndpointPair::addFunctionBlock(std::unique_ptr<UMPStream::FunctionBlock>)::$_1 &,std::unique_ptr<UMPStream::FunctionBlock>*>(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      v19 = a1 + 1;
      v20 = a1 + 2;
      v21 = a1 + 3;
      std::__sort4[abi:ne180100]<std::_RangeAlgPolicy,UMPStream::EndpointPair::addFunctionBlock(std::unique_ptr<UMPStream::FunctionBlock>)::$_1 &,std::unique_ptr<UMPStream::FunctionBlock>*>(a1, a1 + 1, a1 + 2, a1 + 3);
      v22 = *(a2 - 1);
      v23 = a1[3];
      if (*(unsigned __int8 *)(v22 + 96) < *(unsigned __int8 *)(v23 + 96))
      {
        *v21 = v22;
        *(a2 - 1) = v23;
        v24 = *v21;
        v25 = *(unsigned __int8 *)(*v21 + 96);
        v26 = *v20;
        if (v25 < *(unsigned __int8 *)(*v20 + 96))
        {
          *v20 = v24;
          *v21 = v26;
          v27 = *v19;
          if (v25 < *(unsigned __int8 *)(*v19 + 96))
          {
            a1[1] = v24;
            a1[2] = v27;
            v28 = *a1;
            if (v25 < *(unsigned __int8 *)(*a1 + 96))
            {
              *a1 = v24;
              a1[1] = v28;
            }
          }
        }
      }
      return 1;
    default:
      v8 = a1 + 2;
      std::__sort3[abi:ne180100]<std::_RangeAlgPolicy,UMPStream::EndpointPair::addFunctionBlock(std::unique_ptr<UMPStream::FunctionBlock>)::$_1 &,std::unique_ptr<UMPStream::FunctionBlock>*>(a1, a1 + 1, a1 + 2);
      v9 = a1 + 3;
      if (a1 + 3 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *v9;
    v13 = *v8;
    if (*(unsigned __int8 *)(*v9 + 96) < *(unsigned __int8 *)(*v8 + 96))
    {
      v14 = 0;
      *v9 = 0;
      for (i = v10; ; i -= 8)
      {
        v16 = (char *)a1 + i;
        *((_QWORD *)v16 + 2) = 0;
        *((_QWORD *)v16 + 3) = v13;
        if (v14)
          std::default_delete<UMPStream::FunctionBlock>::operator()[abi:ne180100](v14);
        if (i == -16)
        {
          v17 = a1;
          goto LABEL_16;
        }
        v13 = *(uint64_t *)((char *)a1 + i + 8);
        if (*(unsigned __int8 *)(v12 + 96) >= *(unsigned __int8 *)(v13 + 96))
          break;
        v14 = *((_QWORD *)v16 + 2);
      }
      v17 = (uint64_t *)((char *)a1 + i + 16);
LABEL_16:
      v18 = *v17;
      *v17 = v12;
      if (v18)
        std::default_delete<UMPStream::FunctionBlock>::operator()[abi:ne180100](v18);
      if (++v11 == 8)
        return v9 + 1 == a2;
    }
    v8 = v9;
    v10 += 8;
    if (++v9 == a2)
      return 1;
  }
}

_QWORD *std::__list_imp<MergeQueueElem>::clear(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;

  if (result[2])
  {
    v1 = result;
    result = (_QWORD *)result[1];
    v2 = *v1;
    v3 = *result;
    *(_QWORD *)(v3 + 8) = *(_QWORD *)(*v1 + 8);
    **(_QWORD **)(v2 + 8) = v3;
    v1[2] = 0;
    while (result != v1)
    {
      v4 = (_QWORD *)result[1];
      std::__list_imp<MergeQueueElem>::__delete_node[abi:ne180100]<>(result);
      result = v4;
    }
  }
  return result;
}

void std::__list_imp<MergeQueueElem>::__delete_node[abi:ne180100]<>(_QWORD *__p)
{
  uint64_t v2;

  v2 = __p[2];
  __p[2] = 0;
  if (v2)
    ((void (*)(void))__p[3])();
  operator delete(__p);
}

void gSysExUtilitiesLog(void)
{
  unsigned __int8 v0;

  if ((v0 & 1) == 0)
  {
    {
      gSysExUtilitiesLog(void)::sysexu = (uint64_t)os_log_create("com.apple.coremidi", "sysexu");
    }
  }
}

MIDIEventPacket *MIDI::sendOrDeferEventsOnActiveSysExGroups(MIDIEventPacket *result, uint64_t a2, uint64_t a3, void (***a4)(_QWORD, _QWORD *), uint64_t (***a5)(_QWORD, _DWORD *, _QWORD *))
{
  uint64_t timeStamp_high;
  uint64_t p_wordCount;
  MIDIEventPacket *v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int v12;
  BOOL v13;
  BOOL v14;
  _DWORD *v15;
  unsigned int v16;
  _DWORD *v17;
  unsigned int v18;
  unint64_t v19;
  BOOL v20;
  unint64_t v21;
  BOOL v22;
  unsigned int v23;
  BOOL v24;
  int v25;
  MIDITimeStamp *v27;
  unsigned int v28;
  _DWORD *v29;
  unsigned int v30;
  unint64_t v31;
  BOOL v32;
  unint64_t v34;
  BOOL v35;
  unsigned int v36;
  size_t v37;
  uint64_t v38;
  char *v39;
  _QWORD *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t (***v44)(_QWORD, _QWORD, _QWORD);
  uint64_t (***v45)(_QWORD, int *, _QWORD *);
  uint64_t v46;
  MIDIEventPacket *v47;
  MIDIEventPacket *packet;
  void (***v49)(_QWORD, _QWORD);
  void (***v50)(_QWORD, _QWORD *);
  MIDIEventPacket *v51;
  uint64_t v52;
  MIDITimeStamp *v53;
  MIDIEventList v54;
  int timeStamp;
  _QWORD v56[3];

  v46 = a2;
  v56[1] = *MEMORY[0x1E0C80C00];
  timeStamp_high = HIDWORD(result->timeStamp);
  *(_QWORD *)&v54.protocol = LODWORD(result->timeStamp);
  if ((_DWORD)timeStamp_high)
  {
    v50 = a4;
    v51 = result;
    p_wordCount = (uint64_t)&result->wordCount;
    v44 = (uint64_t (***)(_QWORD, _QWORD, _QWORD))(a5 + 1);
    v45 = a5;
    packet = v54.packet;
    v49 = (void (***)(_QWORD, _QWORD))(a4 + 1);
    v7 = v54.packet;
    do
    {
      v43 = timeStamp_high;
      v8 = 0;
      v9 = p_wordCount + 12;
      v10 = (unsigned int *)(p_wordCount + 12);
      v52 = p_wordCount + 12;
      v53 = (MIDITimeStamp *)p_wordCount;
      while (1)
      {
        v11 = *v10;
        v12 = *v10 >> 28;
        if (v12)
          v13 = v12 == 15;
        else
          v13 = 1;
        if (v13)
          std::terminate();
        v14 = BYTE2(v11) - 248 > 7 || ((1 << (BYTE2(v11) + 8)) & 0xDD) == 0;
        v15 = (_DWORD *)(v9 + 4 * v8);
        if (!v14)
          goto LABEL_12;
        v28 = HIBYTE(v11) & 0xF;
        if (v12 == 15)
          v28 = 255;
        if (*(_BYTE *)(v46 + v28))
        {
          v16 = 0;
          v29 = &v15[*(_DWORD *)(p_wordCount + 8) - v8];
          LOBYTE(v30) = -1;
          do
          {
            v31 = *v15;
            if ((_BYTE)v30 == 0xFF)
            {
              if (BYTE2(v31) > 0xF7u && ((0xDDu >> (BYTE2(v31) + 8)) & 1) != 0)
              {
                LOBYTE(v30) = -1;
              }
              else
              {
                if (v31 >> 28)
                  v32 = v31 >> 28 == 15;
                else
                  v32 = 1;
                v30 = BYTE3(v31) & 0xF;
                if (v32)
                  LOBYTE(v30) = -1;
              }
            }
            if (BYTE2(v31) - 248 <= 7 && ((1 << (BYTE2(v31) + 8)) & 0xDD) != 0)
              break;
            v34 = v31 >> 28;
            v35 = !(*v15 >> 28) || (_DWORD)v34 == 15;
            if (v35 || (BYTE3(v31) & 0xF) != (char)v30)
            {
              v36 = BYTE2(v31) - 248;
              if (v36 > 7 || ((1 << v36) & 0xC1) == 0)
                break;
            }
            v16 += MIDI::UniversalPacket::word_sizes[v34];
            v15 += MIDI::UniversalPacket::word_sizes[v34];
          }
          while (v15 < v29);
          v47 = v7;
          MEMORY[0x1E0C80A78]();
          v39 = (char *)&v42 - v38;
          *(_QWORD *)v39 = *v40;
          *((_DWORD *)v39 + 2) = v16;
          if (v16)
            memcpy(v39 + 12, v10, v37);
          timeStamp = v51->timeStamp;
          v56[0] = v39;
          result = (MIDIEventPacket *)(**v45)(v44, &timeStamp, v56);
          v27 = v53;
          v7 = v47;
        }
        else
        {
LABEL_12:
          v16 = 0;
          v17 = &v15[*(_DWORD *)(p_wordCount + 8) - v8];
          LOBYTE(v18) = -1;
          do
          {
            v19 = *v15;
            if ((_BYTE)v18 == 0xFF)
            {
              if (BYTE2(v19) > 0xF7u && ((0xDDu >> (BYTE2(v19) + 8)) & 1) != 0)
              {
                LOBYTE(v18) = -1;
              }
              else
              {
                if (v19 >> 28)
                  v20 = v19 >> 28 == 15;
                else
                  v20 = 1;
                v18 = BYTE3(v19) & 0xF;
                if (v20)
                  LOBYTE(v18) = -1;
              }
            }
            v21 = v19 >> 28;
            if (*v15 >> 28)
              v22 = (_DWORD)v21 == 15;
            else
              v22 = 1;
            if (v22 || (BYTE3(v19) & 0xF) != (char)v18)
            {
              v23 = BYTE2(v19) - 248;
              v24 = v23 > 7;
              v25 = (1 << v23) & 0xDD;
              if (v24 || v25 == 0)
                break;
            }
            v16 += MIDI::UniversalPacket::word_sizes[v21];
            v15 += MIDI::UniversalPacket::word_sizes[v21];
          }
          while (v15 < v17);
          result = MIDIEventListAdd(&v54, 0x114uLL, v7, *(_QWORD *)p_wordCount, v16, v10);
          if (result)
          {
            v7 = result;
            v27 = v53;
          }
          else
          {
            v56[0] = &v54;
            (**v50)(v49, v56);
            *(_QWORD *)&v54.protocol = LODWORD(v51->timeStamp);
            v27 = v53;
            result = MIDIEventListAdd(&v54, 0x114uLL, packet, *v53, v16, v10);
            v7 = result;
          }
        }
        v8 += v16;
        v41 = *((unsigned int *)v27 + 2);
        p_wordCount = (uint64_t)v27;
        if (v8 >= v41)
          break;
        v9 = v52;
        v10 = (unsigned int *)(v52 + 4 * v8);
      }
      p_wordCount = (uint64_t)v27 + 4 * v41 + 12;
      timeStamp_high = (v43 - 1);
    }
    while ((_DWORD)v43 != 1);
    if (v54.numPackets)
    {
      v56[0] = &v54;
      return (MIDIEventPacket *)((uint64_t (*)(void (***)(_QWORD, _QWORD), _QWORD *, MIDIEventPacket *))**v50)(v49, v56, v7);
    }
  }
  return result;
}

void SetupManager::SetupManager(SetupManager *this)
{
  __CFRunLoop *Current;
  const __CFString *v3;
  __CFRunLoop *v4;
  CFRunLoopTimerContext context;

  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = (char *)this + 56;
  *((_QWORD *)this + 8) = (char *)this + 56;
  *((_QWORD *)this + 9) = 0;
  *((_DWORD *)this + 20) = 1;
  context.version = 0;
  context.info = this;
  memset(&context.retain, 0, 24);
  *((_QWORD *)this + 11) = CFRunLoopTimerCreate(0, 0.0, 1000000.0, 0, 0, (CFRunLoopTimerCallBack)SetupManager::NotificationTimerCallback, &context);
  Current = CFRunLoopGetCurrent();
  v3 = (const __CFString *)*MEMORY[0x1E0C9B280];
  CFRunLoopAddTimer(Current, *((CFRunLoopTimerRef *)this + 11), (CFRunLoopMode)*MEMORY[0x1E0C9B280]);
  *((_QWORD *)this + 12) = CFRunLoopTimerCreate(0, 0.0, 1000000.0, 0, 0, (CFRunLoopTimerCallBack)SetupManager::PrefSaverTimerCallback, &context);
  v4 = CFRunLoopGetCurrent();
  CFRunLoopAddTimer(v4, *((CFRunLoopTimerRef *)this + 12), v3);
}

void sub_1D4EB2160(_Unwind_Exception *a1)
{
  _QWORD *v1;
  NotificationQueue *v2;
  void *v4;
  void *v5;

  NotificationQueue::~NotificationQueue(v2);
  v4 = (void *)v1[4];
  if (v4)
  {
    v1[5] = v4;
    operator delete(v4);
  }
  v5 = (void *)v1[1];
  if (v5)
  {
    v1[2] = v5;
    operator delete(v5);
  }
  _Unwind_Resume(a1);
}

void NotificationQueue::~NotificationQueue(NotificationQueue *this)
{
  NotificationQueue *v2;
  uint64_t v3;
  uint64_t v4;
  NotificationQueue *v5;

  NotificationQueue::eraseall(this);
  if (*((_QWORD *)this + 2))
  {
    v3 = *(_QWORD *)this;
    v2 = (NotificationQueue *)*((_QWORD *)this + 1);
    v4 = *(_QWORD *)v2;
    *(_QWORD *)(v4 + 8) = *(_QWORD *)(*(_QWORD *)this + 8);
    **(_QWORD **)(v3 + 8) = v4;
    *((_QWORD *)this + 2) = 0;
    if (v2 != this)
    {
      do
      {
        v5 = (NotificationQueue *)*((_QWORD *)v2 + 1);
        operator delete(v2);
        v2 = v5;
      }
      while (v5 != this);
    }
  }
}

_QWORD *NotificationQueue::eraseall(_QWORD *this)
{
  uint64_t v1;
  _QWORD *v2;
  int v3;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;

  v1 = this[1];
  if ((_QWORD *)v1 != this)
  {
    v2 = this;
    do
    {
      v3 = *(_DWORD *)(v1 + 16);
      if ((v3 - 4096) < 3 || v3 == 4)
        CFRelease(*(CFTypeRef *)(v1 + 32));
      v1 = *(_QWORD *)(v1 + 8);
    }
    while ((_QWORD *)v1 != v2);
    this = (_QWORD *)v2[1];
    if (this != v2)
    {
      v5 = *v2;
      v6 = *this;
      *(_QWORD *)(v6 + 8) = *(_QWORD *)(*v2 + 8);
      **(_QWORD **)(v5 + 8) = v6;
      do
      {
        v7 = (_QWORD *)this[1];
        --v2[2];
        operator delete(this);
        this = v7;
      }
      while (v7 != v2);
    }
  }
  return this;
}

uint64_t SetupManager::instance(SetupManager *this)
{
  unsigned __int8 v1;
  SetupManager *v3;

  {
    v3 = (SetupManager *)operator new();
    SetupManager::SetupManager(v3);
    SetupManager::instance(void)::gSetupManager = (uint64_t)v3;
  }
  return SetupManager::instance(void)::gSetupManager;
}

void sub_1D4EB2304(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D826BA98](v1, 0x10A0C40369D21D1);
  _Unwind_Resume(a1);
}

void SetupManager::Install(SetupManager *this, MIDISetup *a2, char a3)
{
  SetupManager *v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  MIDISource **v13;
  MIDISource *v14;
  uint64_t *v15;
  uint64_t *v16;
  MIDIServer *v17;
  int v18;

  v5 = this;
  v6 = *(_QWORD *)this;
  if (*(_QWORD *)this)
  {
    v8 = *(uint64_t **)(v6 + 64);
    v7 = *(uint64_t **)(v6 + 72);
    while (v8 != v7)
    {
      v9 = *v8;
      v11 = *(uint64_t **)(*v8 + 80);
      v10 = *(uint64_t **)(*v8 + 88);
      if (v11 != v10)
      {
        do
        {
          v12 = *v11;
          v13 = *(MIDISource ***)(*v11 + 72);
          if (v13 != *(MIDISource ***)(*v11 + 80))
          {
            do
            {
              v14 = *v13++;
              this = (SetupManager *)MIDISource::CloseInputConnections(v14);
            }
            while (v13 != *(MIDISource ***)(v12 + 80));
            v10 = *(uint64_t **)(v9 + 88);
          }
          ++v11;
        }
        while (v11 != v10);
        v7 = *(uint64_t **)(v6 + 72);
      }
      ++v8;
    }
    v15 = MIDIServer::defaultInstance(this);
    MIDIDriverMgr::StopMIDI((MIDIDriverMgr *)v15[33]);
    MIDISetup::CheckWritePrefFile(*(MIDISetup **)v5);
    if (*(_QWORD *)v5)
      (*(void (**)(_QWORD))(**(_QWORD **)v5 + 8))(*(_QWORD *)v5);
  }
  else
  {
    v16 = MIDIServer::defaultInstance(this);
    MIDIDriverMgr::StopMIDI((MIDIDriverMgr *)v16[33]);
  }
  *(_QWORD *)v5 = a2;
  MIDISetup::CreationEffects(a2);
  MIDISetup::ScanForDriverDevices(a2);
  MIDIServer::startMIDI(v17, v18);
  if ((a3 & 1) == 0)
  {
    *((_BYTE *)v5 + 81) = 1;
    SetupManager::SchedulePrefSaver(v5);
  }
}

_QWORD *remove<std::vector<MIDISource *>,MIDISource *>(_QWORD *result, uint64_t a2)
{
  _QWORD *v2;
  char *v3;
  char *v4;
  int64_t v5;

  v2 = result;
  v4 = (char *)*result;
  v3 = (char *)result[1];
  if ((char *)*result != v3)
  {
    while (*(_QWORD *)v4 != a2)
    {
      v4 += 8;
      if (v4 == v3)
      {
        v4 = (char *)result[1];
        break;
      }
    }
  }
  if (v4 != v3)
  {
    v5 = v3 - (v4 + 8);
    if (v3 != v4 + 8)
      result = memmove(v4, v4 + 8, v3 - (v4 + 8));
    v2[1] = &v4[v5];
  }
  return result;
}

void SetupManager::PropertyDirty(SetupManager *this, MIDIObject *a2, const __CFString *a3)
{
  uint64_t v6;
  SetupManager *v7;
  MIDISetup *v8;
  MIDIServer *IntegerProperty;
  uint64_t *v10;
  MIDIObject **v11;
  MIDIObject **v12;
  MIDIObject *v13;
  MIDIServer *v14;
  uint64_t *v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t *v19;
  int v20;
  uint64_t v21;
  unint64_t IsPartOfUMPEndpoint;
  uint64_t *v23;
  const void *v24;
  std::mutex *v25;
  uint64_t *v26;
  uint64_t *v27;
  uint64_t *v28;
  uint64_t *v29;
  int v30;
  _QWORD *v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t *v34;
  const void *v35;
  std::mutex *v36;
  uint64_t *v37;
  uint64_t *v38;
  uint64_t *j;
  uint64_t v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t *v43;
  uint64_t v44;
  unsigned int v45;
  BOOL v46;
  uint64_t *v47;
  uint64_t *v48;
  uint64_t *v49;
  uint64_t *v50;
  BOOL v51;
  int *v52;
  int *v53;
  uint64_t v54;
  int v55;
  _QWORD *v56;
  uint64_t v57;
  _QWORD *v58;
  uint64_t v59;
  uint64_t *i;
  uint64_t v61;
  uint64_t v62;
  int *v63;
  int *v64;
  uint64_t v65;
  int v66;
  uint64_t v67;
  uint64_t *v68;
  unint64_t v69;
  _QWORD *v70;
  uint64_t v71;
  uint64_t *v72;
  unint64_t v73;
  _QWORD *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t *v86;
  char *v87;
  char *v88;
  uint64_t v89;
  uint64_t *v90;
  char *v91;
  char *v92;
  uint64_t v93;
  MIDIObject **k;
  MIDIObject *v95;
  int v96;
  uint64_t v97;
  int v98;
  int v99;
  const __CFString *v100;
  int v101;
  int *v102;
  int *v103;
  uint64_t v104;
  CFTypeRef cf;
  int **v106;

  v6 = *(_QWORD *)this;
  if (*(_QWORD *)this && !*(_BYTE *)(v6 + 218))
  {
    *(_BYTE *)(v6 + 217) = 1;
    v7 = (SetupManager *)SetupManager::instance(this);
    SetupManager::SchedulePrefSaver(v7);
  }
  v97 = 0x1800000004;
  v98 = *((_DWORD *)a2 + 2);
  v99 = (*(uint64_t (**)(MIDIObject *))(*(_QWORD *)a2 + 72))(a2);
  v100 = a3;
  CFRetain(a3);
  SetupManager::AddNotification((uint64_t)this, (uint64_t)&v97);
  if (CFEqual(a3, kMIDIPropertyOffline))
  {
    v8 = *(MIDISetup **)this;
    v101 = 0;
    IntegerProperty = (MIDIServer *)MIDIObject::GetIntegerProperty(a2, kMIDIPropertyOffline, &v101);
    if (!(_DWORD)IntegerProperty)
    {
      v10 = MIDIServer::defaultInstance(IntegerProperty);
      v12 = (MIDIObject **)*((_QWORD *)v8 + 11);
      v11 = (MIDIObject **)*((_QWORD *)v8 + 12);
      if (v12 != v11)
      {
        v96 = *(unsigned __int8 *)v10[33];
        do
        {
          v13 = *v12;
          if (*(MIDIObject **)(*((_QWORD *)*v12 + 8) + 48) == a2)
          {
            if (v101)
              MIDISetup::ObjectRemoved(v8, *v12);
            else
              MIDISetup::ObjectAdded(v8, v13);
            v15 = MIDIServer::defaultInstance(v14);
            v16 = (_QWORD *)*((_QWORD *)v13 + 8);
            if (!v16 || v16[10] == v16[9] || (v18 = v16 + 13, v17 = v16[13], v18[1] == v17))
            {
              IsPartOfUMPEndpoint = MIDIEndpoint::IsPartOfUMPEndpoint(v13);
            }
            else
            {
              v19 = v15;
              v20 = v101;
              v21 = *(unsigned int *)(*(_QWORD *)v17 + 8);
              IsPartOfUMPEndpoint = MIDIEndpoint::IsPartOfUMPEndpoint(v13);
              if ((_DWORD)IsPartOfUMPEndpoint && (_DWORD)v21)
              {
                v23 = v19 + 99;
                if (v20)
                {
                  v24 = (const void *)*((unsigned int *)v13 + 2);
                  v25 = (std::mutex *)(v19 + 103);
                  std::mutex::lock((std::mutex *)(v19 + 103));
                  v102 = 0;
                  v103 = 0;
                  v104 = 0;
                  cf = v24;
                  v26 = (uint64_t *)v19[100];
                  v27 = (uint64_t *)v19[101];
                  v106 = &v102;
                  if (v26 != v27)
                  {
                    while ((UMPCIManager<UMPStream::EndpointPair>::removePairs(unsigned int,unsigned int)::{lambda(UMPStream::EndpointPair const&)#1}::operator()<std::unique_ptr<UMPStream::EndpointPair>>((int *)&cf, (_DWORD *)*v26) & 1) == 0)
                    {
                      if (++v26 == v27)
                      {
                        v26 = v27;
                        goto LABEL_86;
                      }
                    }
                  }
                  if (v26 != v27)
                  {
                    for (i = v26 + 1; i != v27; ++i)
                    {
                      if ((UMPCIManager<UMPStream::EndpointPair>::removePairs(unsigned int,unsigned int)::{lambda(UMPStream::EndpointPair const&)#1}::operator()<std::unique_ptr<UMPStream::EndpointPair>>((int *)&cf, (_DWORD *)*i) & 1) == 0)
                      {
                        v61 = *i;
                        *i = 0;
                        v62 = *v26;
                        *v26 = v61;
                        if (v62)
                          std::default_delete<UMPStream::EndpointPair>::operator()[abi:ne180100](v62);
                        ++v26;
                      }
                    }
                  }
LABEL_86:
                  std::vector<std::unique_ptr<UMPStream::EndpointPair>>::erase((uint64_t)(v19 + 100), v26, (uint64_t *)v19[101]);
                  v63 = v102;
                  v64 = v103;
                  if (v102 != v103)
                  {
                    do
                    {
                      v65 = *v23;
                      v66 = *v63;
                      cf = 0;
                      UMPCIServerContext::sendNotificationForObject(v65, 2, v66, &cf);
                      if (cf)
                        CFRelease(cf);
                      ++v63;
                    }
                    while (v63 != v64);
                    v63 = v102;
                  }
                  if (v63)
                  {
                    v103 = v63;
                    operator delete(v63);
                  }
                  std::mutex::unlock(v25);
                }
                else if (v96)
                {
                  UMPStream::EndpointManager::sendEndpointDiscoveryMessage((UMPStream::EndpointManager *)(v19 + 99), v21);
                }
                else
                {
                  v71 = *((unsigned int *)v13 + 2);
                  v72 = (uint64_t *)v19[112];
                  v73 = v19[113];
                  if ((unint64_t)v72 >= v73)
                  {
                    v81 = v19[111];
                    v82 = ((uint64_t)v72 - v81) >> 3;
                    if ((unint64_t)(v82 + 1) >> 61)
LABEL_143:
                      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
                    v83 = v73 - v81;
                    v84 = v83 >> 2;
                    if (v83 >> 2 <= (unint64_t)(v82 + 1))
                      v84 = v82 + 1;
                    if ((unint64_t)v83 >= 0x7FFFFFFFFFFFFFF8)
                      IsPartOfUMPEndpoint = 0x1FFFFFFFFFFFFFFFLL;
                    else
                      IsPartOfUMPEndpoint = v84;
                    if (IsPartOfUMPEndpoint)
                      IsPartOfUMPEndpoint = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(IsPartOfUMPEndpoint);
                    else
                      v85 = 0;
                    v90 = (uint64_t *)(IsPartOfUMPEndpoint + 8 * v82);
                    *v90 = v71 | (v21 << 32);
                    v74 = v90 + 1;
                    v91 = (char *)v19[112];
                    v92 = (char *)v19[111];
                    if (v91 != v92)
                    {
                      do
                      {
                        v93 = *((_QWORD *)v91 - 1);
                        v91 -= 8;
                        *--v90 = v93;
                      }
                      while (v91 != v92);
                      v91 = (char *)v19[111];
                    }
                    v19[111] = (uint64_t)v90;
                    v19[112] = (uint64_t)v74;
                    v19[113] = IsPartOfUMPEndpoint + 8 * v85;
                    if (v91)
                      operator delete(v91);
                  }
                  else
                  {
                    *v72 = v71 | (v21 << 32);
                    v74 = v72 + 1;
                  }
                  v19[112] = (uint64_t)v74;
                }
              }
            }
            v28 = MIDIServer::defaultInstance((MIDIServer *)IsPartOfUMPEndpoint);
            if (!*((_BYTE *)v13 + 89))
            {
              if ((v29 = v28, v30 = v101, MIDIEndpoint::IsPartOfLegacyDevice(v13))
                && (v31 = (_QWORD *)*((_QWORD *)v13 + 8)) != 0
                && v31[10] != v31[9]
                && (v33 = v31 + 13, v32 = v31[13], v33[1] != v32)
                && *(_DWORD *)(*(_QWORD *)v32 + 8)
                || MIDIEndpoint::IsPartOfUMPDevice(v13)
                && (MIDIEndpoint::IsPartOfPhantomEntity(*((MIDIObject **)v13 + 8)) & 1) != 0
                || *((_QWORD *)v13 + 6))
              {
                v34 = v29 + 78;
                if (v30)
                {
                  v35 = (const void *)*((unsigned int *)v13 + 2);
                  v36 = (std::mutex *)(v29 + 82);
                  std::mutex::lock((std::mutex *)(v29 + 82));
                  v102 = 0;
                  v103 = 0;
                  v104 = 0;
                  cf = v35;
                  v37 = (uint64_t *)v29[79];
                  v38 = (uint64_t *)v29[80];
                  v106 = &v102;
                  if (v37 != v38)
                  {
                    while ((UMPCIManager<MIDICI::Device>::removePairs(unsigned int,unsigned int)::{lambda(MIDICI::Device const&)#1}::operator()<std::unique_ptr<MIDICI::Device>>((int *)&cf, (_DWORD *)*v37) & 1) == 0)
                    {
                      if (++v37 == v38)
                      {
                        v37 = v38;
                        goto LABEL_46;
                      }
                    }
                  }
                  if (v37 != v38)
                  {
                    for (j = v37 + 1; j != v38; ++j)
                    {
                      if ((UMPCIManager<MIDICI::Device>::removePairs(unsigned int,unsigned int)::{lambda(MIDICI::Device const&)#1}::operator()<std::unique_ptr<MIDICI::Device>>((int *)&cf, (_DWORD *)*j) & 1) == 0)
                      {
                        v40 = *j;
                        *j = 0;
                        v41 = *v37;
                        *v37 = v40;
                        if (v41)
                          std::default_delete<MIDICI::Device>::operator()[abi:ne180100](v41);
                        ++v37;
                      }
                    }
                  }
LABEL_46:
                  std::vector<std::unique_ptr<MIDICI::Device>>::erase((uint64_t)(v29 + 79), v37, (uint64_t *)v29[80]);
                  v42 = (uint64_t *)v29[92];
                  if (v42)
                  {
                    v43 = v29 + 92;
                    v44 = v29[92];
                    do
                    {
                      v45 = *(_DWORD *)(v44 + 32);
                      v46 = v45 >= v35;
                      if (v45 >= v35)
                        v47 = (uint64_t *)v44;
                      else
                        v47 = (uint64_t *)(v44 + 8);
                      if (v46)
                        v43 = (uint64_t *)v44;
                      v44 = *v47;
                    }
                    while (*v47);
                    if (v43 != v29 + 92 && v35 >= *((_DWORD *)v43 + 8))
                    {
                      v48 = (uint64_t *)v43[1];
                      v49 = v43;
                      if (v48)
                      {
                        do
                        {
                          v50 = v48;
                          v48 = (uint64_t *)*v48;
                        }
                        while (v48);
                      }
                      else
                      {
                        do
                        {
                          v50 = (uint64_t *)v49[2];
                          v51 = *v50 == (_QWORD)v49;
                          v49 = v50;
                        }
                        while (!v51);
                      }
                      if ((uint64_t *)v29[91] == v43)
                        v29[91] = (uint64_t)v50;
                      --v29[93];
                      std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v42, v43);
                      std::__destroy_at[abi:ne180100]<std::pair<unsigned int const,MIDICI::SourceState>,0>((uint64_t)(v43 + 4));
                      operator delete(v43);
                    }
                  }
                  v52 = v102;
                  v53 = v103;
                  if (v102 != v103)
                  {
                    do
                    {
                      v54 = *v34;
                      v55 = *v52;
                      cf = 0;
                      UMPCIServerContext::sendNotificationForObject(v54, 2, v55, &cf);
                      if (cf)
                        CFRelease(cf);
                      ++v52;
                    }
                    while (v52 != v53);
                    v52 = v102;
                  }
                  if (v52)
                  {
                    v103 = v52;
                    operator delete(v52);
                  }
                  std::mutex::unlock(v36);
                }
                else if (!MIDIEndpoint::IsPartOfUMPEndpoint(v13))
                {
                  v56 = (_QWORD *)*((_QWORD *)v13 + 8);
                  if (!v56 || v56[10] == v56[9] || (v58 = v56 + 13, v57 = v56[13], v58[1] == v57))
                    v59 = 0;
                  else
                    v59 = *(unsigned int *)(*(_QWORD *)v57 + 8);
                  if (v96)
                  {
                    MIDICI::DeviceManager::sendDiscoveryInquiryMessage((MIDICI::DeviceManager *)(v29 + 78), v59, 0);
                  }
                  else
                  {
                    v67 = *((unsigned int *)v13 + 2);
                    v68 = (uint64_t *)v29[95];
                    v69 = v29[96];
                    if ((unint64_t)v68 >= v69)
                    {
                      v75 = v29[94];
                      v76 = ((uint64_t)v68 - v75) >> 3;
                      if ((unint64_t)(v76 + 1) >> 61)
                        goto LABEL_143;
                      v77 = v69 - v75;
                      v78 = v77 >> 2;
                      if (v77 >> 2 <= (unint64_t)(v76 + 1))
                        v78 = v76 + 1;
                      if ((unint64_t)v77 >= 0x7FFFFFFFFFFFFFF8)
                        v79 = 0x1FFFFFFFFFFFFFFFLL;
                      else
                        v79 = v78;
                      if (v79)
                        v79 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v79);
                      else
                        v80 = 0;
                      v86 = (uint64_t *)(v79 + 8 * v76);
                      *v86 = v67 | (v59 << 32);
                      v70 = v86 + 1;
                      v87 = (char *)v29[95];
                      v88 = (char *)v29[94];
                      if (v87 != v88)
                      {
                        do
                        {
                          v89 = *((_QWORD *)v87 - 1);
                          v87 -= 8;
                          *--v86 = v89;
                        }
                        while (v87 != v88);
                        v87 = (char *)v29[94];
                      }
                      v29[94] = (uint64_t)v86;
                      v29[95] = (uint64_t)v70;
                      v29[96] = v79 + 8 * v80;
                      if (v87)
                        operator delete(v87);
                    }
                    else
                    {
                      *v68 = v67 | (v59 << 32);
                      v70 = v68 + 1;
                    }
                    v29[95] = (uint64_t)v70;
                  }
                }
              }
            }
            v11 = (MIDIObject **)*((_QWORD *)v8 + 12);
          }
          ++v12;
        }
        while (v12 != v11);
      }
      for (k = (MIDIObject **)*((_QWORD *)v8 + 14); k != *((MIDIObject ***)v8 + 15); ++k)
      {
        v95 = *k;
        if (*(MIDIObject **)(*((_QWORD *)*k + 8) + 48) == a2)
        {
          if (v101)
            MIDISetup::ObjectRemoved(v8, v95);
          else
            MIDISetup::ObjectAdded(v8, v95);
        }
      }
    }
  }
}

void sub_1D4EB2BD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, CFTypeRef cf)
{
  std::mutex *v17;

  if (__p)
    operator delete(__p);
  std::mutex::unlock(v17);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<unsigned short,unsigned short>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,unsigned short>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,unsigned short>>>::erase(uint64_t **a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t *v4;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t *v8;
  BOOL v9;
  uint64_t *v10;

  if (a2 != a3)
  {
    v4 = a2;
    do
    {
      v6 = (uint64_t *)v4[1];
      v7 = v4;
      if (v6)
      {
        do
        {
          v8 = v6;
          v6 = (uint64_t *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          v8 = (uint64_t *)v7[2];
          v9 = *v8 == (_QWORD)v7;
          v7 = v8;
        }
        while (!v9);
      }
      if (*a1 == v4)
        *a1 = v8;
      v10 = a1[1];
      a1[2] = (uint64_t *)((char *)a1[2] - 1);
      std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v10, v4);
      operator delete(v4);
      v4 = v8;
    }
    while (v8 != a3);
  }
  return a3;
}

uint64_t *std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t *v4;
  int v5;
  uint64_t **v6;
  uint64_t *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t *v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v2 = *a2;
  v3 = a2;
  if (*a2)
  {
    v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      v3 = a2;
      goto LABEL_7;
    }
    do
    {
      v3 = v4;
      v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  v2 = v3[1];
  if (v2)
  {
LABEL_7:
    v5 = 0;
    *(_QWORD *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  v5 = 1;
LABEL_8:
  v6 = (uint64_t **)v3[2];
  v7 = *v6;
  if (*v6 == v3)
  {
    *v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      v7 = 0;
      result = (uint64_t *)v2;
    }
    else
    {
      v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    v9 = a2[2];
    v3[2] = v9;
    *(_QWORD *)(v9 + 8 * (*(_QWORD *)a2[2] != (_QWORD)a2)) = v3;
    v11 = *a2;
    v10 = a2[1];
    *(_QWORD *)(v11 + 16) = v3;
    *v3 = v11;
    v3[1] = v10;
    if (v10)
      *(_QWORD *)(v10 + 16) = v3;
    *((_BYTE *)v3 + 24) = *((_BYTE *)a2 + 24);
    if (result == a2)
      result = v3;
  }
  if (!v8 || !result)
    return result;
  if (!v5)
  {
    *(_BYTE *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    v12 = v7[2];
    if (*(uint64_t **)v12 != v7)
      break;
    if (!*((_BYTE *)v7 + 24))
    {
      *((_BYTE *)v7 + 24) = 1;
      *(_BYTE *)(v12 + 24) = 0;
      v18 = v7[1];
      *(_QWORD *)v12 = v18;
      if (v18)
        *(_QWORD *)(v18 + 16) = v12;
      v7[2] = *(_QWORD *)(v12 + 16);
      *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v7;
      v7[1] = v12;
      *(_QWORD *)(v12 + 16) = v7;
      if (result == (uint64_t *)v12)
        result = v7;
      v7 = *(uint64_t **)v12;
    }
    v19 = (_QWORD *)*v7;
    if (*v7 && !*((_BYTE *)v19 + 24))
      goto LABEL_68;
    v20 = (uint64_t *)v7[1];
    if (v20 && !*((_BYTE *)v20 + 24))
    {
      if (v19 && !*((_BYTE *)v19 + 24))
      {
LABEL_68:
        v20 = v7;
      }
      else
      {
        *((_BYTE *)v20 + 24) = 1;
        *((_BYTE *)v7 + 24) = 0;
        v26 = *v20;
        v7[1] = *v20;
        if (v26)
          *(_QWORD *)(v26 + 16) = v7;
        v20[2] = v7[2];
        *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v20;
        *v20 = (uint64_t)v7;
        v7[2] = (uint64_t)v20;
        v19 = v7;
      }
      v23 = v20[2];
      *((_BYTE *)v20 + 24) = *(_BYTE *)(v23 + 24);
      *(_BYTE *)(v23 + 24) = 1;
      *((_BYTE *)v19 + 24) = 1;
      v24 = *(uint64_t **)v23;
      v27 = *(_QWORD *)(*(_QWORD *)v23 + 8);
      *(_QWORD *)v23 = v27;
      if (v27)
        *(_QWORD *)(v27 + 16) = v23;
      v24[2] = *(_QWORD *)(v23 + 16);
      *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
      v24[1] = v23;
      goto LABEL_72;
    }
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (*((_BYTE *)v17 + 24))
      v21 = v17 == result;
    else
      v21 = 1;
    if (v21)
      goto LABEL_53;
LABEL_49:
    v7 = *(uint64_t **)(v17[2] + 8 * (*(_QWORD *)v17[2] == (_QWORD)v17));
  }
  if (!*((_BYTE *)v7 + 24))
  {
    *((_BYTE *)v7 + 24) = 1;
    *(_BYTE *)(v12 + 24) = 0;
    v13 = *(uint64_t **)(v12 + 8);
    v14 = *v13;
    *(_QWORD *)(v12 + 8) = *v13;
    if (v14)
      *(_QWORD *)(v14 + 16) = v12;
    v13[2] = *(_QWORD *)(v12 + 16);
    *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v13;
    *v13 = v12;
    *(_QWORD *)(v12 + 16) = v13;
    if (result == (uint64_t *)*v7)
      result = v7;
    v7 = *(uint64_t **)(*v7 + 8);
  }
  v15 = (_QWORD *)*v7;
  if (!*v7 || *((_BYTE *)v15 + 24))
  {
    v16 = (uint64_t *)v7[1];
    if (v16 && !*((_BYTE *)v16 + 24))
      goto LABEL_59;
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      v17 = result;
LABEL_53:
      *((_BYTE *)v17 + 24) = 1;
      return result;
    }
    if (!*((_BYTE *)v17 + 24))
      goto LABEL_53;
    goto LABEL_49;
  }
  v16 = (uint64_t *)v7[1];
  if (v16 && !*((_BYTE *)v16 + 24))
  {
LABEL_59:
    v15 = v7;
  }
  else
  {
    *((_BYTE *)v15 + 24) = 1;
    *((_BYTE *)v7 + 24) = 0;
    v22 = v15[1];
    *v7 = v22;
    if (v22)
      *(_QWORD *)(v22 + 16) = v7;
    v15[2] = v7[2];
    *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v15;
    v15[1] = v7;
    v7[2] = (uint64_t)v15;
    v16 = v7;
  }
  v23 = v15[2];
  *((_BYTE *)v15 + 24) = *(_BYTE *)(v23 + 24);
  *(_BYTE *)(v23 + 24) = 1;
  *((_BYTE *)v16 + 24) = 1;
  v24 = *(uint64_t **)(v23 + 8);
  v25 = *v24;
  *(_QWORD *)(v23 + 8) = *v24;
  if (v25)
    *(_QWORD *)(v25 + 16) = v23;
  v24[2] = *(_QWORD *)(v23 + 16);
  *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
  *v24 = v23;
LABEL_72:
  *(_QWORD *)(v23 + 16) = v24;
  return result;
}

uint64_t _MIDIObjectGetIntegerProperty(MIDIServer *a1, const __CFString *a2, int *a3)
{
  int v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t IntegerProperty;
  uint64_t IntegerOrDataProperty;
  MIDIObject *v11;
  char v12;

  v5 = (int)a1;
  v6 = MIDIServer::defaultInstance(a1, (int)a2) + 16;
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 16))(v6);
  v8 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIObject>::sRTTI, v5);
  IntegerProperty = 0;
  IntegerOrDataProperty = 4294967246;
  if (!a3)
  {
    v12 = 0;
LABEL_7:
    if (!v7)
      goto LABEL_9;
    goto LABEL_8;
  }
  v11 = (MIDIObject *)v8;
  v12 = 0;
  if (!v8)
    goto LABEL_7;
  if (CFEqual(a2, kMIDIPropertyConnectionUniqueID))
  {
    IntegerOrDataProperty = MIDIObject::GetIntegerOrDataProperty(v11, a2, 0, a3);
    IntegerProperty = 0;
    v12 = 0;
    if (!v7)
      goto LABEL_9;
LABEL_8:
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
    goto LABEL_9;
  }
  v12 = 1;
  IntegerProperty = MIDIObject::GetIntegerProperty(v11, a2, a3);
  if (v7)
    goto LABEL_8;
LABEL_9:
  if ((v12 & 1) != 0)
    return IntegerProperty;
  return IntegerOrDataProperty;
}

void sub_1D4EB3174(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  int v11;

  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 3)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
  }
  else
  {
    if (a2 == 2)
    {
      __cxa_get_exception_ptr(a1);
      a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
      __cxa_begin_catch(a1);
      std::exception::~exception(&a10);
    }
    else
    {
      __cxa_begin_catch(a1);
    }
    __cxa_end_catch();
  }
  JUMPOUT(0x1D4EB3128);
}

uint64_t _MIDIObjectSetIntegerProperty(MIDIServer *a1, const __CFString *a2, int a3)
{
  int v5;
  uint64_t *v6;
  int v7;
  MIDIObject *v8;
  SetupManager *v9;
  MIDISetup **v10;
  char v11;
  uint64_t v12;
  SetupManager *v13;
  SetupManager *v14;

  v5 = (int)a1;
  v6 = MIDIServer::defaultInstance(a1) + 2;
  v7 = (*(uint64_t (**)(uint64_t *))(*v6 + 16))(v6);
  v8 = (MIDIObject *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIObject>::sRTTI, v5);
  if (!v8)
  {
    v11 = 0;
    v12 = 4294967246;
    if (!v7)
      goto LABEL_12;
    goto LABEL_11;
  }
  v9 = (SetupManager *)CFEqual(a2, kMIDIPropertyUniqueID);
  if ((_DWORD)v9)
  {
    v10 = (MIDISetup **)SetupManager::instance(v9);
    if (MIDISetup::FindObjectByUniqueID(*v10, a3, v8))
    {
      v11 = 0;
      v12 = 4294956453;
      if (!v7)
        goto LABEL_12;
LABEL_11:
      (*(void (**)(uint64_t *))(*v6 + 24))(v6);
      goto LABEL_12;
    }
  }
  v13 = (SetupManager *)MIDIObject::SetProperty(v8, a2, a3);
  if ((_DWORD)v13)
  {
    v14 = (SetupManager *)SetupManager::instance(v13);
    SetupManager::PropertyDirty(v14, v8, a2);
  }
  v12 = 4294956453;
  v11 = 1;
  if (v7)
    goto LABEL_11;
LABEL_12:
  if ((v11 & 1) != 0)
    return 0;
  return v12;
}

void sub_1D4EB3314(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  int v11;

  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 3)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
  }
  else
  {
    if (a2 == 2)
    {
      __cxa_get_exception_ptr(a1);
      a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
      __cxa_begin_catch(a1);
      std::exception::~exception(&a10);
    }
    else
    {
      __cxa_begin_catch(a1);
    }
    __cxa_end_catch();
  }
  JUMPOUT(0x1D4EB32F8);
}

uint64_t _MIDIObjectGetStringProperty(MIDIServer *a1, const __CFString *a2, const __CFString **StringProperty)
{
  int v5;
  uint64_t *v6;
  int v7;
  MIDIObject *v8;
  char v9;

  v5 = (int)a1;
  v6 = MIDIServer::defaultInstance(a1) + 2;
  v7 = (*(uint64_t (**)(uint64_t *))(*v6 + 16))(v6);
  if (!StringProperty)
  {
LABEL_6:
    v9 = 0;
    if (!v7)
      goto LABEL_8;
    goto LABEL_7;
  }
  v8 = (MIDIObject *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIObject>::sRTTI, v5);
  if (!v8)
  {
    StringProperty = 0;
    goto LABEL_6;
  }
  StringProperty = (const __CFString **)MIDIObject::GetStringProperty(v8, a2, StringProperty);
  v9 = 1;
  if (v7)
LABEL_7:
    (*(void (**)(uint64_t *))(*v6 + 24))(v6);
LABEL_8:
  if ((v9 & 1) == 0)
    return 4294967246;
  return (uint64_t)StringProperty;
}

void sub_1D4EB3470(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  int v11;

  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
    __cxa_begin_catch(a1);
    std::exception::~exception(&a10);
    __cxa_end_catch();
    JUMPOUT(0x1D4EB344CLL);
  }
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EB3450);
}

uint64_t _MIDIObjectSetStringProperty(MIDIServer *a1, const __CFString *a2, uint64_t a3)
{
  int v5;
  uint64_t *v6;
  int v7;
  MIDIObject *v8;
  SetupManager *v10;
  SetupManager *v11;

  v5 = (int)a1;
  v6 = MIDIServer::defaultInstance(a1) + 2;
  v7 = (*(uint64_t (**)(uint64_t *))(*v6 + 16))(v6);
  v8 = (MIDIObject *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIObject>::sRTTI, v5);
  if (v8 && !CFEqual(a2, kMIDIPropertyDisplayName))
  {
    v10 = (SetupManager *)(*(uint64_t (**)(MIDIObject *, const __CFString *, uint64_t))(*(_QWORD *)v8 + 40))(v8, a2, a3);
    if ((_DWORD)v10)
    {
      v11 = (SetupManager *)SetupManager::instance(v10);
      SetupManager::PropertyDirty(v11, v8, a2);
    }
    if (v7)
      (*(void (**)(uint64_t *))(*v6 + 24))(v6);
    return 0;
  }
  else
  {
    if (v7)
      (*(void (**)(uint64_t *))(*v6 + 24))(v6);
    return 4294967246;
  }
}

void sub_1D4EB35F4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
    __cxa_begin_catch(a1);
    std::exception::~exception(&a10);
    __cxa_end_catch();
    JUMPOUT(0x1D4EB3584);
  }
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EB35D0);
}

uint64_t _MIDIObjectGetDataProperty(MIDIServer *a1, const __CFString *a2, const __CFData **a3)
{
  int v5;
  uint64_t *v6;
  int v7;
  uint64_t v8;
  MIDIObject *v9;
  BOOL v10;
  char v11;
  uint64_t IntegerOrDataProperty;
  CFTypeID v14;
  CFTypeRef cf;

  v5 = (int)a1;
  v6 = MIDIServer::defaultInstance(a1) + 2;
  v7 = (*(uint64_t (**)(uint64_t *))(*v6 + 16))(v6);
  v8 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIObject>::sRTTI, v5);
  v9 = (MIDIObject *)v8;
  if (a3)
    v10 = v8 == 0;
  else
    v10 = 1;
  v11 = !v10;
  if (v10)
  {
    IntegerOrDataProperty = 0;
  }
  else if (CFEqual(a2, kMIDIPropertyConnectionUniqueID))
  {
    IntegerOrDataProperty = MIDIObject::GetIntegerOrDataProperty(v9, a2, a3, 0);
  }
  else
  {
    cf = 0;
    IntegerOrDataProperty = (*(uint64_t (**)(MIDIObject *, const __CFString *, CFTypeRef *, uint64_t))(*(_QWORD *)v9 + 32))(v9, a2, &cf, 1);
    if (!(_DWORD)IntegerOrDataProperty)
    {
      v14 = CFGetTypeID(cf);
      if (v14 == CFDataGetTypeID())
      {
        IntegerOrDataProperty = 0;
        *a3 = (const __CFData *)cf;
      }
      else
      {
        CFRelease(cf);
        IntegerOrDataProperty = 4294956460;
      }
    }
  }
  if (v7)
    (*(void (**)(uint64_t *))(*v6 + 24))(v6);
  if ((v11 & 1) == 0)
    return 4294967246;
  return IntegerOrDataProperty;
}

void sub_1D4EB37BC(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a9 = MEMORY[0x1E0DE5050] + 16;
    __cxa_begin_catch(a1);
    std::exception::~exception((std::exception *)&a9);
    __cxa_end_catch();
    JUMPOUT(0x1D4EB3738);
  }
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EB373CLL);
}

uint64_t _MIDIObjectSetDataProperty(MIDIServer *a1, const __CFString *a2, uint64_t a3)
{
  int v5;
  uint64_t *v6;
  int v7;
  uint64_t v8;
  MIDIObject *v9;
  SetupManager *v10;
  SetupManager *v11;

  v5 = (int)a1;
  v6 = MIDIServer::defaultInstance(a1) + 2;
  v7 = (*(uint64_t (**)(uint64_t *))(*v6 + 16))(v6);
  v8 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIObject>::sRTTI, v5);
  v9 = (MIDIObject *)v8;
  if (v8)
  {
    v10 = (SetupManager *)(*(uint64_t (**)(uint64_t, const __CFString *, uint64_t))(*(_QWORD *)v8 + 40))(v8, a2, a3);
    if ((_DWORD)v10)
    {
      v11 = (SetupManager *)SetupManager::instance(v10);
      SetupManager::PropertyDirty(v11, v9, a2);
    }
    if (v7)
      (*(void (**)(uint64_t *))(*v6 + 24))(v6);
    return 0;
  }
  else
  {
    if (v7)
      (*(void (**)(uint64_t *))(*v6 + 24))(v6);
    return 4294967246;
  }
}

void sub_1D4EB392C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
    __cxa_begin_catch(a1);
    std::exception::~exception(&a10);
    __cxa_end_catch();
    JUMPOUT(0x1D4EB3904);
  }
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EB3908);
}

uint64_t _MIDIObjectGetDictionaryProperty(MIDIServer *a1, const __CFString *a2, CFTypeRef *a3)
{
  int v5;
  uint64_t *v6;
  int v7;
  int v8;
  uint64_t v9;
  CFStringRef v10;
  uint64_t v11;
  CFTypeID v12;
  CFTypeRef cf;

  v5 = (int)a1;
  v6 = MIDIServer::defaultInstance(a1) + 2;
  v7 = (*(uint64_t (**)(uint64_t *))(*v6 + 16))(v6);
  v8 = v7;
  if (!a3)
  {
    v11 = 0;
    if (!v7)
      goto LABEL_16;
    goto LABEL_15;
  }
  v9 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIObject>::sRTTI, v5);
  if (!v9)
  {
    v11 = 0;
    LOBYTE(a3) = 0;
    if (!v8)
      goto LABEL_16;
LABEL_15:
    (*(void (**)(uint64_t *))(*v6 + 24))(v6);
    goto LABEL_16;
  }
  cf = 0;
  if (CFEqual(a2, kMIDIPropertyDisplayName))
    v10 = kMIDIPropertyName;
  else
    v10 = a2;
  v11 = (*(uint64_t (**)(uint64_t, CFStringRef, CFTypeRef *, uint64_t))(*(_QWORD *)v9 + 32))(v9, v10, &cf, 1);
  if (!(_DWORD)v11)
  {
    v12 = CFGetTypeID(cf);
    if (v12 == CFDictionaryGetTypeID())
    {
      v11 = 0;
      *a3 = cf;
    }
    else
    {
      CFRelease(cf);
      v11 = 4294956460;
    }
  }
  LOBYTE(a3) = 1;
  if (v8)
    goto LABEL_15;
LABEL_16:
  if ((a3 & 1) == 0)
    return 4294967246;
  return v11;
}

void sub_1D4EB3AF0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  uint64_t v9;
  int v10;

  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a9 = MEMORY[0x1E0DE5050] + 16;
    __cxa_begin_catch(a1);
    std::exception::~exception((std::exception *)&a9);
    __cxa_end_catch();
    JUMPOUT(0x1D4EB3ACCLL);
  }
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EB3AD0);
}

uint64_t _MIDIObjectSetDictionaryProperty(MIDIServer *a1, const __CFString *a2, uint64_t a3)
{
  int v5;
  uint64_t *v6;
  int v7;
  uint64_t v8;
  MIDIObject *v9;
  SetupManager *v10;
  SetupManager *v11;

  v5 = (int)a1;
  v6 = MIDIServer::defaultInstance(a1) + 2;
  v7 = (*(uint64_t (**)(uint64_t *))(*v6 + 16))(v6);
  v8 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIObject>::sRTTI, v5);
  v9 = (MIDIObject *)v8;
  if (v8)
  {
    v10 = (SetupManager *)(*(uint64_t (**)(uint64_t, const __CFString *, uint64_t))(*(_QWORD *)v8 + 40))(v8, a2, a3);
    if ((_DWORD)v10)
    {
      v11 = (SetupManager *)SetupManager::instance(v10);
      SetupManager::PropertyDirty(v11, v9, a2);
    }
    if (v7)
      (*(void (**)(uint64_t *))(*v6 + 24))(v6);
    return 0;
  }
  else
  {
    if (v7)
      (*(void (**)(uint64_t *))(*v6 + 24))(v6);
    return 4294967246;
  }
}

void sub_1D4EB3C60(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
    __cxa_begin_catch(a1);
    std::exception::~exception(&a10);
    __cxa_end_catch();
    JUMPOUT(0x1D4EB3C38);
  }
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EB3C3CLL);
}

uint64_t _MIDIObjectRemoveProperty(MIDIServer *a1, const __CFString *a2)
{
  int v3;
  uint64_t *v4;
  int v5;
  uint64_t v6;
  MIDIObject *v7;
  SetupManager *v8;
  SetupManager *v9;

  v3 = (int)a1;
  v4 = MIDIServer::defaultInstance(a1) + 2;
  v5 = (*(uint64_t (**)(uint64_t *))(*v4 + 16))(v4);
  v6 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIObject>::sRTTI, v3);
  v7 = (MIDIObject *)v6;
  if (v6)
  {
    v8 = (SetupManager *)(*(uint64_t (**)(uint64_t, const __CFString *))(*(_QWORD *)v6 + 48))(v6, a2);
    if ((_DWORD)v8)
    {
      v9 = (SetupManager *)SetupManager::instance(v8);
      SetupManager::PropertyDirty(v9, v7, a2);
    }
    if (v5)
      (*(void (**)(uint64_t *))(*v4 + 24))(v4);
    return 0;
  }
  else
  {
    if (v5)
      (*(void (**)(uint64_t *))(*v4 + 24))(v4);
    return 4294967246;
  }
}

void sub_1D4EB3DC0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
    __cxa_begin_catch(a1);
    std::exception::~exception(&a10);
    __cxa_end_catch();
    JUMPOUT(0x1D4EB3D9CLL);
  }
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EB3DA0);
}

ItemCount MIDIDeviceListGetNumberOfDevices(MIDIDeviceListRef devList)
{
  ItemCount result;

  if (gInMIDIServer != 1)
    return -50;
  result = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<DeviceList>::sRTTI, devList);
  if (result)
    return (uint64_t)(*(_QWORD *)(result + 24) - *(_QWORD *)(result + 16)) >> 3;
  return result;
}

MIDIDeviceRef MIDIDeviceListGetDevice(MIDIDeviceListRef devList, ItemCount index0)
{
  uint64_t v3;
  uint64_t v4;

  if (gInMIDIServer != 1)
    goto LABEL_5;
  v3 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<DeviceList>::sRTTI, devList);
  if (v3)
  {
    v4 = *(_QWORD *)(v3 + 16);
    if (index0 < (*(_QWORD *)(v3 + 24) - v4) >> 3)
    {
      LODWORD(v3) = *(_DWORD *)(*(_QWORD *)(v4 + 8 * index0) + 8);
      return v3;
    }
LABEL_5:
    LODWORD(v3) = 0;
  }
  return v3;
}

OSStatus MIDIDeviceListAddDevice(MIDIDeviceListRef devList, MIDIDeviceRef dev)
{
  uint64_t *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  unint64_t v19;
  char *v20;
  char *v21;
  uint64_t v22;

  if (gInMIDIServer != 1)
    return -50;
  v4 = MIDIServer::defaultInstance(*(MIDIServer **)&devList) + 2;
  v5 = (*(uint64_t (**)(uint64_t *))(*v4 + 16))(v4);
  v6 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<DeviceList>::sRTTI, devList);
  if (v6)
  {
    v7 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIDevice>::sRTTI, dev);
    v8 = v7;
    if (v7)
    {
      v10 = *(uint64_t **)(v6 + 24);
      v9 = *(_QWORD *)(v6 + 32);
      if ((unint64_t)v10 >= v9)
      {
        v12 = *(_QWORD *)(v6 + 16);
        v13 = ((uint64_t)v10 - v12) >> 3;
        if ((unint64_t)(v13 + 1) >> 61)
          std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
        v14 = v9 - v12;
        v15 = v14 >> 2;
        if (v14 >> 2 <= (unint64_t)(v13 + 1))
          v15 = v13 + 1;
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8)
          v16 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v16 = v15;
        if (v16)
          v16 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v16);
        else
          v17 = 0;
        v18 = (uint64_t *)(v16 + 8 * v13);
        v19 = v16 + 8 * v17;
        *v18 = v8;
        v11 = v18 + 1;
        v21 = *(char **)(v6 + 16);
        v20 = *(char **)(v6 + 24);
        if (v20 != v21)
        {
          do
          {
            v22 = *((_QWORD *)v20 - 1);
            v20 -= 8;
            *--v18 = v22;
          }
          while (v20 != v21);
          v20 = *(char **)(v6 + 16);
        }
        *(_QWORD *)(v6 + 16) = v18;
        *(_QWORD *)(v6 + 24) = v11;
        *(_QWORD *)(v6 + 32) = v19;
        if (v20)
          operator delete(v20);
      }
      else
      {
        *v10 = v7;
        v11 = v10 + 1;
      }
      *(_QWORD *)(v6 + 24) = v11;
      LOBYTE(v6) = 1;
      if (v5)
        goto LABEL_24;
      goto LABEL_25;
    }
    LOBYTE(v6) = 0;
  }
  if (v5)
LABEL_24:
    (*(void (**)(uint64_t *))(*v4 + 24))(v4);
LABEL_25:
  if ((v6 & 1) == 0)
    return -50;
  return 0;
}

OSStatus MIDIDeviceCreate(MIDIDriverRef owner, CFStringRef name, CFStringRef manufacturer, CFStringRef model, MIDIDeviceRef *outDevice)
{
  uint64_t *v10;
  int v11;
  int v12;
  MIDIDriverPlugin *v13;
  MIDIDeviceRef *v14;

  if (gInMIDIServer != 1)
    return -50;
  v10 = MIDIServer::defaultInstance((MIDIServer *)owner) + 2;
  v11 = (*(uint64_t (**)(uint64_t *))(*v10 + 16))(v10);
  v12 = v11;
  if (!outDevice)
  {
    if (v11)
      (*(void (**)(uint64_t *))(*v10 + 24))(v10);
    return -50;
  }
  v13 = (MIDIDriverPlugin *)driverRefToPlugin(owner);
  v14 = (MIDIDeviceRef *)operator new();
  MIDIDevice::MIDIDevice((MIDIDevice *)v14, v13, name, manufacturer, model);
  *outDevice = v14[2];
  if (v12)
    (*(void (**)(uint64_t *))(*v10 + 24))(v10);
  return 0;
}

void sub_1D4EB42C0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  int v11;
  uint64_t v12;

  MEMORY[0x1D826BA98](v12, 0x10E1C400F55952ELL);
  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
    __cxa_begin_catch(a1);
    std::exception::~exception(&a10);
    __cxa_end_catch();
    JUMPOUT(0x1D4EB4294);
  }
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EB4298);
}

OSStatus MIDIDeviceDispose(MIDIDeviceRef device)
{
  uint64_t *v2;
  int v3;
  uint64_t v4;

  if (gInMIDIServer != 1)
    return -50;
  v2 = MIDIServer::defaultInstance(*(MIDIServer **)&device) + 2;
  v3 = (*(uint64_t (**)(uint64_t *))(*v2 + 16))(v2);
  v4 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIDevice>::sRTTI, device);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  if (v3)
    (*(void (**)(uint64_t *))(*v2 + 24))(v2);
  return 0;
}

void sub_1D4EB4414(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  int v11;

  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
    __cxa_begin_catch(a1);
    std::exception::~exception(&a10);
  }
  else
  {
    __cxa_begin_catch(a1);
  }
  __cxa_end_catch();
  JUMPOUT(0x1D4EB43F0);
}

uint64_t _MIDIDeviceAddEntity(MIDIServer *a1, const __CFString *a2, MIDIProtocolID a3, int a4, int a5, int a6, _DWORD *a7)
{
  int v12;
  uint64_t *v13;
  int v14;
  uint64_t v15;
  MIDIObject *v16;
  uint64_t v17;
  char **v18;
  char **v19;
  MIDIDriverPlugin *v20;
  int v21;
  MIDISource *v22;
  const __CFString *v23;
  unint64_t v24;
  MIDISource **v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  MIDISource **v32;
  char *v33;
  char *v34;
  MIDISource *v35;
  int v36;
  MIDIDestination *v37;
  const __CFString *v38;
  unint64_t v39;
  MIDIDestination **v40;
  _QWORD *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  MIDIDestination **v47;
  char *v48;
  char *v49;
  MIDIDestination *v50;
  SetupManager *v51;
  MIDIConnection ***v52;
  MIDIDevice *v55;
  _DWORD *v56;
  uint64_t *v57;
  int v58;

  v12 = (int)a1;
  v13 = MIDIServer::defaultInstance(a1) + 2;
  v14 = (*(uint64_t (**)(uint64_t *))(*v13 + 16))(v13);
  v15 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIDevice>::sRTTI, v12);
  if (a7 && (v16 = (MIDIObject *)v15) != 0)
  {
    v57 = v13;
    v58 = v14;
    v17 = operator new();
    MIDIObject::MIDIObject((MIDIObject *)v17, v16, a2);
    v56 = a7;
    *(_QWORD *)v17 = &off_1E98B92C0;
    *(_QWORD *)(v17 + 48) = v16;
    *(_QWORD *)(v17 + 64) = &off_1E98B9790;
    v55 = v16;
    *(_DWORD *)(v17 + 56) = a3;
    *(_QWORD *)(v17 + 72) = 0;
    v18 = (char **)(v17 + 72);
    *(_QWORD *)(v17 + 80) = 0;
    *(_QWORD *)(v17 + 88) = 0;
    *(_QWORD *)(v17 + 96) = &off_1E98B97F0;
    *(_QWORD *)(v17 + 104) = 0;
    v19 = (char **)(v17 + 104);
    *(_QWORD *)(v17 + 112) = 0;
    *(_QWORD *)(v17 + 120) = 0;
    v20 = (MIDIDriverPlugin *)*((_QWORD *)v16 + 8);
    if (a5 >= 1)
    {
      std::vector<void const*>::reserve((void **)(v17 + 72), a5);
      v21 = 0;
      do
      {
        v22 = (MIDISource *)operator new();
        MIDISource::MIDISource(v22, v20, (MIDIEntity *)v17, a3, v23);
        v25 = *(MIDISource ***)(v17 + 80);
        v24 = *(_QWORD *)(v17 + 88);
        if ((unint64_t)v25 >= v24)
        {
          v27 = ((char *)v25 - *v18) >> 3;
          if ((unint64_t)(v27 + 1) >> 61)
            std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
          v28 = v24 - (_QWORD)*v18;
          v29 = v28 >> 2;
          if (v28 >> 2 <= (unint64_t)(v27 + 1))
            v29 = v27 + 1;
          if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFF8)
            v30 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v30 = v29;
          if (v30)
            v30 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v30);
          else
            v31 = 0;
          v32 = (MIDISource **)(v30 + 8 * v27);
          *v32 = v22;
          v26 = v32 + 1;
          v34 = *(char **)(v17 + 72);
          v33 = *(char **)(v17 + 80);
          if (v33 != v34)
          {
            do
            {
              v35 = (MIDISource *)*((_QWORD *)v33 - 1);
              v33 -= 8;
              *--v32 = v35;
            }
            while (v33 != v34);
            v33 = *v18;
          }
          *(_QWORD *)(v17 + 72) = v32;
          *(_QWORD *)(v17 + 80) = v26;
          *(_QWORD *)(v17 + 88) = v30 + 8 * v31;
          if (v33)
            operator delete(v33);
        }
        else
        {
          *v25 = v22;
          v26 = v25 + 1;
        }
        *(_QWORD *)(v17 + 80) = v26;
        ++v21;
      }
      while (v21 != a5);
    }
    if (a6 >= 1)
    {
      std::vector<void const*>::reserve((void **)(v17 + 104), a6);
      v36 = 0;
      do
      {
        v37 = (MIDIDestination *)operator new();
        MIDIDestination::MIDIDestination(v37, v20, (MIDIEntity *)v17, a3, v38);
        v40 = *(MIDIDestination ***)(v17 + 112);
        v39 = *(_QWORD *)(v17 + 120);
        if ((unint64_t)v40 >= v39)
        {
          v42 = ((char *)v40 - *v19) >> 3;
          if ((unint64_t)(v42 + 1) >> 61)
            std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
          v43 = v39 - (_QWORD)*v19;
          v44 = v43 >> 2;
          if (v43 >> 2 <= (unint64_t)(v42 + 1))
            v44 = v42 + 1;
          if ((unint64_t)v43 >= 0x7FFFFFFFFFFFFFF8)
            v45 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v45 = v44;
          if (v45)
            v45 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v45);
          else
            v46 = 0;
          v47 = (MIDIDestination **)(v45 + 8 * v42);
          *v47 = v37;
          v41 = v47 + 1;
          v49 = *(char **)(v17 + 104);
          v48 = *(char **)(v17 + 112);
          if (v48 != v49)
          {
            do
            {
              v50 = (MIDIDestination *)*((_QWORD *)v48 - 1);
              v48 -= 8;
              *--v47 = v50;
            }
            while (v48 != v49);
            v48 = *v19;
          }
          *(_QWORD *)(v17 + 104) = v47;
          *(_QWORD *)(v17 + 112) = v41;
          *(_QWORD *)(v17 + 120) = v45 + 8 * v46;
          if (v48)
            operator delete(v48);
        }
        else
        {
          *v40 = v37;
          v41 = v40 + 1;
        }
        *(_QWORD *)(v17 + 112) = v41;
        ++v36;
      }
      while (v36 != a6);
    }
    MIDIObject::SetProperty((MIDIObject *)v17, kMIDIPropertyIsEmbeddedEntity, a4 != 0);
    MIDIObject::SetProperty((MIDIObject *)v17, kMIDIPropertyMaxSysExSpeed, 3125);
    v51 = (SetupManager *)MIDIObject::SetProperty((MIDIObject *)v17, kMIDIPropertyProtocolID, a3);
    v52 = *(MIDIConnection ****)SetupManager::instance(v51);
    MIDIDevice::AddEntity(v55, (MIDIEntity *)v17);
    if (v52)
      MIDISetup::EntityAddEffects(v52, (MIDIEntity *)v17, 0);
    *v56 = *(_DWORD *)(v17 + 8);
    if (v58)
      (*(void (**)(uint64_t *))(*v57 + 24))(v57);
    return 0;
  }
  else
  {
    if (v14)
      (*(void (**)(uint64_t *))(*v13 + 24))(v13);
    return 4294967246;
  }
}

void sub_1D4EB4874(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, std::exception a16)
{
  uint64_t v16;

  MEMORY[0x1D826BA98](v16, 0x10E1C40CE33DE92);
  if (a15)
    (*(void (**)(uint64_t))(*(_QWORD *)a14 + 24))(a14);
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a16.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
    __cxa_begin_catch(a1);
    std::exception::~exception(&a16);
    __cxa_end_catch();
    JUMPOUT(0x1D4EB4808);
  }
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EB4838);
}

void MIDIDevice::AddEntity(MIDIDevice *this, MIDIEntity *a2)
{
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  unint64_t v14;
  char *v15;
  char *v16;
  uint64_t v17;

  v5 = (_QWORD *)*((_QWORD *)this + 11);
  v4 = *((_QWORD *)this + 12);
  if ((unint64_t)v5 >= v4)
  {
    v7 = *((_QWORD *)this + 10);
    v8 = ((uint64_t)v5 - v7) >> 3;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v9 = v4 - v7;
    v10 = v9 >> 2;
    if (v9 >> 2 <= (unint64_t)(v8 + 1))
      v10 = v8 + 1;
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    if (v11)
      v11 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v11);
    else
      v12 = 0;
    v13 = (_QWORD *)(v11 + 8 * v8);
    v14 = v11 + 8 * v12;
    *v13 = a2;
    v6 = v13 + 1;
    v16 = (char *)*((_QWORD *)this + 10);
    v15 = (char *)*((_QWORD *)this + 11);
    if (v15 != v16)
    {
      do
      {
        v17 = *((_QWORD *)v15 - 1);
        v15 -= 8;
        *--v13 = v17;
      }
      while (v15 != v16);
      v15 = (char *)*((_QWORD *)this + 10);
    }
    *((_QWORD *)this + 10) = v13;
    *((_QWORD *)this + 11) = v6;
    *((_QWORD *)this + 12) = v14;
    if (v15)
      operator delete(v15);
  }
  else
  {
    *v5 = a2;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 11) = v6;
}

uint64_t _MIDIDeviceGetNumberOfEntities(MIDIServer *a1)
{
  int v1;
  uint64_t *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;

  v1 = (int)a1;
  v2 = MIDIServer::defaultInstance(a1) + 2;
  v3 = (*(uint64_t (**)(uint64_t *))(*v2 + 16))(v2);
  v4 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIDevice>::sRTTI, v1);
  if (v4)
  {
    v5 = (uint64_t)(*(_QWORD *)(v4 + 88) - *(_QWORD *)(v4 + 80)) >> 3;
    if (!v3)
      return v5;
    goto LABEL_5;
  }
  v5 = 0;
  if (v3)
LABEL_5:
    (*(void (**)(uint64_t *))(*v2 + 24))(v2);
  return v5;
}

void sub_1D4EB4B20(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  int v11;

  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
    __cxa_begin_catch(a1);
    std::exception::~exception(&a10);
  }
  else
  {
    __cxa_begin_catch(a1);
  }
  __cxa_end_catch();
  JUMPOUT(0x1D4EB4B04);
}

uint64_t _MIDIDeviceGetEntity(MIDIServer *a1, unint64_t a2)
{
  int v3;
  uint64_t *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = (int)a1;
  v4 = MIDIServer::defaultInstance(a1) + 2;
  v5 = (*(uint64_t (**)(uint64_t *))(*v4 + 16))(v4);
  v6 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIDevice>::sRTTI, v3);
  if (v6)
  {
    v7 = *(_QWORD *)(v6 + 80);
    if (a2 < (*(_QWORD *)(v6 + 88) - v7) >> 3)
    {
      v8 = *(unsigned int *)(*(_QWORD *)(v7 + 8 * (int)a2) + 8);
      if (!v5)
        return v8;
      goto LABEL_6;
    }
  }
  v8 = 0;
  if (v5)
LABEL_6:
    (*(void (**)(uint64_t *))(*v4 + 24))(v4);
  return v8;
}

void sub_1D4EB4C44(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  int v11;

  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
    __cxa_begin_catch(a1);
    std::exception::~exception(&a10);
  }
  else
  {
    __cxa_begin_catch(a1);
  }
  __cxa_end_catch();
  JUMPOUT(0x1D4EB4C28);
}

uint64_t _MIDIEntityGetNumberOfSources(MIDIServer *a1)
{
  int v1;
  uint64_t *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;

  v1 = (int)a1;
  v2 = MIDIServer::defaultInstance(a1) + 2;
  v3 = (*(uint64_t (**)(uint64_t *))(*v2 + 16))(v2);
  v4 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIEntity>::sRTTI, v1);
  if (v4)
  {
    v5 = (uint64_t)(*(_QWORD *)(v4 + 80) - *(_QWORD *)(v4 + 72)) >> 3;
    if (!v3)
      return v5;
    goto LABEL_5;
  }
  v5 = 0;
  if (v3)
LABEL_5:
    (*(void (**)(uint64_t *))(*v2 + 24))(v2);
  return v5;
}

void sub_1D4EB4D50(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  int v11;

  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
    __cxa_begin_catch(a1);
    std::exception::~exception(&a10);
  }
  else
  {
    __cxa_begin_catch(a1);
  }
  __cxa_end_catch();
  JUMPOUT(0x1D4EB4D34);
}

uint64_t _MIDIEntityGetSource(MIDIServer *a1, unint64_t a2)
{
  int v3;
  uint64_t *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = (int)a1;
  v4 = MIDIServer::defaultInstance(a1) + 2;
  v5 = (*(uint64_t (**)(uint64_t *))(*v4 + 16))(v4);
  v6 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIEntity>::sRTTI, v3);
  if (v6)
  {
    v7 = *(_QWORD *)(v6 + 72);
    if (a2 < (*(_QWORD *)(v6 + 80) - v7) >> 3)
    {
      v8 = *(unsigned int *)(*(_QWORD *)(v7 + 8 * (int)a2) + 8);
      if (!v5)
        return v8;
      goto LABEL_6;
    }
  }
  v8 = 0;
  if (v5)
LABEL_6:
    (*(void (**)(uint64_t *))(*v4 + 24))(v4);
  return v8;
}

void sub_1D4EB4E74(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  int v11;

  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
    __cxa_begin_catch(a1);
    std::exception::~exception(&a10);
  }
  else
  {
    __cxa_begin_catch(a1);
  }
  __cxa_end_catch();
  JUMPOUT(0x1D4EB4E58);
}

uint64_t _MIDIEntityGetNumberOfDestinations(MIDIServer *a1)
{
  int v1;
  uint64_t *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;

  v1 = (int)a1;
  v2 = MIDIServer::defaultInstance(a1) + 2;
  v3 = (*(uint64_t (**)(uint64_t *))(*v2 + 16))(v2);
  v4 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIEntity>::sRTTI, v1);
  if (v4)
  {
    v5 = (uint64_t)(*(_QWORD *)(v4 + 112) - *(_QWORD *)(v4 + 104)) >> 3;
    if (!v3)
      return v5;
    goto LABEL_5;
  }
  v5 = 0;
  if (v3)
LABEL_5:
    (*(void (**)(uint64_t *))(*v2 + 24))(v2);
  return v5;
}

void sub_1D4EB4F80(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  int v11;

  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
    __cxa_begin_catch(a1);
    std::exception::~exception(&a10);
  }
  else
  {
    __cxa_begin_catch(a1);
  }
  __cxa_end_catch();
  JUMPOUT(0x1D4EB4F64);
}

uint64_t _MIDIEntityGetDestination(MIDIServer *a1, unint64_t a2)
{
  int v3;
  uint64_t *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = (int)a1;
  v4 = MIDIServer::defaultInstance(a1) + 2;
  v5 = (*(uint64_t (**)(uint64_t *))(*v4 + 16))(v4);
  v6 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIEntity>::sRTTI, v3);
  if (v6)
  {
    v7 = *(_QWORD *)(v6 + 104);
    if (a2 < (*(_QWORD *)(v6 + 112) - v7) >> 3)
    {
      v8 = *(unsigned int *)(*(_QWORD *)(v7 + 8 * (int)a2) + 8);
      if (!v5)
        return v8;
      goto LABEL_6;
    }
  }
  v8 = 0;
  if (v5)
LABEL_6:
    (*(void (**)(uint64_t *))(*v4 + 24))(v4);
  return v8;
}

void sub_1D4EB50A4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  int v11;

  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
    __cxa_begin_catch(a1);
    std::exception::~exception(&a10);
  }
  else
  {
    __cxa_begin_catch(a1);
  }
  __cxa_end_catch();
  JUMPOUT(0x1D4EB5088);
}

OSStatus MIDIEndpointSetRefCons(MIDIEndpointRef endpt, void *ref1, void *ref2)
{
  uint64_t *v6;
  int v7;
  uint64_t v8;

  if (gInMIDIServer != 1)
    return -50;
  v6 = MIDIServer::defaultInstance(*(MIDIServer **)&endpt) + 2;
  v7 = (*(uint64_t (**)(uint64_t *))(*v6 + 16))(v6);
  v8 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIEndpoint>::sRTTI, endpt);
  if (!v8)
  {
    if (v7)
      (*(void (**)(uint64_t *))(*v6 + 24))(v6);
    return -50;
  }
  *(_QWORD *)(v8 + 72) = ref1;
  *(_QWORD *)(v8 + 80) = ref2;
  if (v7)
    (*(void (**)(uint64_t *))(*v6 + 24))(v6);
  return 0;
}

void sub_1D4EB51E0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  int v11;

  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
    __cxa_begin_catch(a1);
    std::exception::~exception(&a10);
    __cxa_end_catch();
    JUMPOUT(0x1D4EB51B8);
  }
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EB51BCLL);
}

OSStatus MIDIEndpointGetRefCons(MIDIEndpointRef endpt, void **ref1, void **ref2)
{
  uint64_t *v6;
  int v7;
  uint64_t v8;

  if (gInMIDIServer != 1)
    return -50;
  v6 = MIDIServer::defaultInstance(*(MIDIServer **)&endpt) + 2;
  v7 = (*(uint64_t (**)(uint64_t *))(*v6 + 16))(v6);
  v8 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIEndpoint>::sRTTI, endpt);
  if (!v8)
  {
    if (v7)
      (*(void (**)(uint64_t *))(*v6 + 24))(v6);
    return -50;
  }
  *ref1 = *(void **)(v8 + 72);
  *ref2 = *(void **)(v8 + 80);
  if (v7)
    (*(void (**)(uint64_t *))(*v6 + 24))(v6);
  return 0;
}

void sub_1D4EB5340(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  int v11;

  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
    __cxa_begin_catch(a1);
    std::exception::~exception(&a10);
    __cxa_end_catch();
    JUMPOUT(0x1D4EB5318);
  }
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EB531CLL);
}

uint64_t _MIDIClientCreate(MIDIServer *a1, const __CFString *a2, uint64_t a3, const void *a4)
{
  int v7;
  uint64_t *v8;
  MIDIServer *v9;
  int v10;
  uint64_t *v11;
  uint64_t v12;
  char v13;
  uint64_t *v14;
  uint64_t i;
  uint64_t v16;
  uint64_t v17;
  MIDIServer *v18;
  uint64_t *v19;
  uint64_t *v20;
  unint64_t v21;
  uint64_t *v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;
  uint64_t *v30;
  char *v31;
  char *v32;
  char *v33;
  uint64_t v34;

  v7 = (int)a1;
  v8 = MIDIServer::defaultInstance(a1) + 2;
  v9 = (MIDIServer *)(*(uint64_t (**)(uint64_t *))(*v8 + 16))(v8);
  v10 = (int)v9;
  if (a3)
  {
    v11 = MIDIServer::defaultInstance(v9);
    v12 = gMIDIIOThread;
    if (gMIDIIOThread && *(_DWORD *)(gMIDIIOThread + 140))
    {
      v13 = 0;
      *(_DWORD *)a3 = 0;
      a3 = *(unsigned int *)(v12 + 140);
      if (!v10)
        goto LABEL_33;
LABEL_32:
      (*(void (**)(uint64_t *))(*v8 + 24))(v8);
      goto LABEL_33;
    }
    if (!v7)
    {
      v16 = 0;
LABEL_14:
      v17 = operator new();
      MIDIObject::MIDIObject((MIDIObject *)v17, 0, a2);
      *(_QWORD *)v17 = &off_1E98B9200;
      *(_QWORD *)(v17 + 48) = v16;
      *(_QWORD *)(v17 + 64) = &off_1E98B9830;
      *(_QWORD *)(v17 + 80) = 0;
      *(_QWORD *)(v17 + 88) = 0;
      *(_QWORD *)(v17 + 72) = 0;
      v18 = (MIDIServer *)_Block_copy(a4);
      *(_QWORD *)(v17 + 56) = v18;
      v19 = MIDIServer::defaultInstance(v18);
      v20 = v19;
      v22 = (uint64_t *)v19[26];
      v21 = v19[27];
      if ((unint64_t)v22 >= v21)
      {
        v24 = v19[25];
        v25 = ((uint64_t)v22 - v24) >> 3;
        if ((unint64_t)(v25 + 1) >> 61)
          std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
        v26 = v21 - v24;
        v27 = v26 >> 2;
        if (v26 >> 2 <= (unint64_t)(v25 + 1))
          v27 = v25 + 1;
        if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8)
          v28 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v28 = v27;
        if (v28)
        {
          if (v28 >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v29 = (char *)operator new(8 * v28);
        }
        else
        {
          v29 = 0;
        }
        v30 = (uint64_t *)&v29[8 * v25];
        v31 = &v29[8 * v28];
        *v30 = v17;
        v23 = v30 + 1;
        v33 = (char *)v20[25];
        v32 = (char *)v20[26];
        if (v32 != v33)
        {
          do
          {
            v34 = *((_QWORD *)v32 - 1);
            v32 -= 8;
            *--v30 = v34;
          }
          while (v32 != v33);
          v32 = (char *)v20[25];
        }
        v20[25] = (uint64_t)v30;
        v20[26] = (uint64_t)v23;
        v20[27] = (uint64_t)v31;
        if (v32)
          operator delete(v32);
      }
      else
      {
        *v22 = v17;
        v23 = v22 + 1;
      }
      v20[26] = (uint64_t)v23;
      *(_DWORD *)a3 = *(_DWORD *)(v17 + 8);
      v13 = 1;
      if (v10)
        goto LABEL_32;
      goto LABEL_33;
    }
    v14 = MIDIServer::defaultInstance((MIDIServer *)v11);
    for (i = v14[29]; i != v14[30]; i += 8)
    {
      v16 = *(_QWORD *)i;
      if (*(_DWORD *)(*(_QWORD *)i + 8) == v7)
        goto LABEL_14;
    }
  }
  v13 = 0;
  a3 = 4294967246;
  if (v10)
    goto LABEL_32;
LABEL_33:
  if ((v13 & 1) != 0)
    return 0;
  return a3;
}

void sub_1D4EB55F4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  int v11;
  BaseOpaqueObject *v12;
  _QWORD *v13;

  OwnedPtrVector<MIDIPort *>::~OwnedPtrVector(v13);
  *(_QWORD *)v12 = off_1E98B9320;
  XCFObject<__CFDictionary const*>::~XCFObject((uint64_t)v12 + 24);
  BaseOpaqueObject::~BaseOpaqueObject(v12);
  MEMORY[0x1D826BA98](v12, 0x10E1C4070F630E7);
  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 3)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
  }
  else
  {
    if (a2 == 2)
    {
      __cxa_get_exception_ptr(a1);
      a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
      __cxa_begin_catch(a1);
      std::exception::~exception(&a10);
    }
    else
    {
      __cxa_begin_catch(a1);
    }
    __cxa_end_catch();
  }
  JUMPOUT(0x1D4EB55C4);
}

uint64_t _MIDIClientDispose(MIDIServer *a1)
{
  int v1;
  uint64_t *v2;
  MIDIServer *v3;
  int v4;
  uint64_t *v5;
  int v6;
  MIDIServer *v7;
  MIDIServer *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;
  MIDIServer **v12;
  MIDIServer **v13;
  MIDIServer *v14;
  MIDIServer **v15;
  const void *v16;
  size_t v17;
  uint64_t v18;

  v1 = (int)a1;
  v2 = MIDIServer::defaultInstance(a1) + 13;
  v3 = (MIDIServer *)(*(uint64_t (**)(uint64_t *))(*v2 + 16))(v2);
  v4 = (int)v3;
  v5 = MIDIServer::defaultInstance(v3) + 2;
  v6 = (*(uint64_t (**)(uint64_t *))(*v5 + 16))(v5);
  v7 = (MIDIServer *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIClient>::sRTTI, v1);
  v8 = v7;
  if (!v7)
  {
    v18 = 4294967246;
    if (!v6)
      goto LABEL_18;
    goto LABEL_17;
  }
  v9 = MIDIServer::defaultInstance(v7);
  v10 = MIDIServer::defaultInstance((MIDIServer *)v9);
  v11 = v10;
  v12 = (MIDIServer **)v10[26];
  v13 = (MIDIServer **)v10[25];
  if (v13 != v12)
  {
    v13 = (MIDIServer **)v10[25];
    while (*v13 != v8)
    {
      if (++v13 == v12)
      {
        v13 = (MIDIServer **)v10[26];
        break;
      }
    }
  }
  if (v13 == v12)
  {
    v18 = 4294956466;
    if (!v6)
      goto LABEL_18;
    goto LABEL_17;
  }
  v14 = *v13;
  if (*v13)
  {
    v14 = (MIDIServer *)(*(uint64_t (**)(MIDIServer *))(*(_QWORD *)v14 + 8))(v14);
    v12 = (MIDIServer **)v11[26];
  }
  v15 = v13;
  v16 = v13 + 1;
  v17 = (char *)v12 - (char *)(v13 + 1);
  if (v17)
    v14 = (MIDIServer *)memmove(v15, v16, v17);
  v11[26] = (uint64_t)v15 + v17;
  ScheduleCheckServerShutdown(v14);
  v18 = 0;
  if (v6)
LABEL_17:
    (*(void (**)(uint64_t *))(*v5 + 24))(v5);
LABEL_18:
  if (v4)
    (*(void (**)(uint64_t *))(*v2 + 24))(v2);
  return v18;
}

void sub_1D4EB584C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  int v11;

  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 3)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
  }
  else
  {
    if (a2 == 2)
    {
      __cxa_get_exception_ptr(a1);
      a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
      __cxa_begin_catch(a1);
      std::exception::~exception(&a10);
    }
    else
    {
      __cxa_begin_catch(a1);
    }
    __cxa_end_catch();
  }
  JUMPOUT(0x1D4EB5810);
}

void sub_1D4EB58E8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  int v2;

  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

uint64_t _MIDICapabilityGetDiscoveryMUID(MIDIServer *a1)
{
  uint64_t *v1;
  MIDIServer *v2;
  int v3;
  uint64_t *v4;
  uint64_t v5;

  v1 = MIDIServer::defaultInstance(a1) + 2;
  v2 = (MIDIServer *)(*(uint64_t (**)(uint64_t *))(*v1 + 16))(v1);
  v3 = (int)v2;
  v4 = MIDIServer::defaultInstance(v2);
  v5 = *(unsigned int *)(MIDICISessionManager::Instance((MIDICISessionManager *)v4) + 664);
  if (v3)
    (*(void (**)(uint64_t *))(*v1 + 24))(v1);
  return v5;
}

void sub_1D4EB597C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  int v11;

  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
    __cxa_begin_catch(a1);
    std::exception::~exception(&a10);
  }
  else
  {
    __cxa_begin_catch(a1);
  }
  __cxa_end_catch();
  JUMPOUT(0x1D4EB5960);
}

BOOL _MIDICapabilityMUIDCollides(MIDIServer *a1)
{
  int v1;
  uint64_t *v2;
  MIDIServer *v3;
  int v4;
  uint64_t *v5;
  uint64_t v6;
  _BOOL8 v7;

  v1 = (int)a1;
  v2 = MIDIServer::defaultInstance(a1) + 2;
  v3 = (MIDIServer *)(*(uint64_t (**)(uint64_t *))(*v2 + 16))(v2);
  v4 = (int)v3;
  v5 = MIDIServer::defaultInstance(v3);
  v6 = MIDICISessionManager::Instance((MIDICISessionManager *)v5);
  v7 = !MIDICIMUIDList::Add((MIDICIMUIDList *)(v6 + 200), v1);
  if (v4)
    (*(void (**)(uint64_t *))(*v2 + 24))(v2);
  return v7;
}

void sub_1D4EB5A78(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
    __cxa_begin_catch(a1);
    std::exception::~exception(&a10);
  }
  else
  {
    __cxa_begin_catch(a1);
  }
  __cxa_end_catch();
  JUMPOUT(0x1D4EB5A5CLL);
}

uint64_t _UMPCIObjectCreate(MIDIServer *a1, int a2, const void *a3, int *a4)
{
  int v7;
  uint64_t *v8;
  MIDIServer *v9;
  int v10;
  BOOL v11;
  char v12;
  applesauce::CF::DictionaryRef *v13;
  uint64_t *v14;
  std::mutex *v15;
  uint64_t v16;
  uint64_t *v17;
  int v18;
  uint64_t v19;
  CFTypeRef v20;
  uint64_t v21;
  CFTypeRef v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  CFTypeRef v30;
  uint64_t v31;
  std::mutex *v33;
  CFTypeRef v34;
  CFTypeRef cf;
  CFTypeRef v36;
  uint64_t *v37;
  char *v38;

  v7 = (int)a1;
  v8 = MIDIServer::defaultInstance(a1) + 2;
  v9 = (MIDIServer *)(*(uint64_t (**)(uint64_t *))(*v8 + 16))(v8);
  v10 = (int)v9;
  if (a3)
    v11 = a4 == 0;
  else
    v11 = 1;
  v12 = !v11;
  if (v11)
  {
    v23 = 0;
    goto LABEL_31;
  }
  MIDIServer::defaultInstance(v9);
  CFRetain(a3);
  v13 = applesauce::CF::DictionaryRef::DictionaryRef((applesauce::CF::DictionaryRef *)&v34, a3);
  if ((a2 - 1) < 2)
  {
    v24 = MIDIServer::defaultInstance(v13);
    std::mutex::lock((std::mutex *)(v24 + 103));
    v33 = (std::mutex *)(v24 + 103);
    v25 = operator new();
    MIDIObject::MIDIObject((MIDIObject *)v25);
    *(_BYTE *)(v25 + 44) = 0;
    *(_BYTE *)(v25 + 48) = 0;
    *(_QWORD *)(v25 + 56) = 0;
    *(_QWORD *)v25 = off_1E98B7008;
    *(_DWORD *)(v25 + 64) = 0;
    *(_OWORD *)(v25 + 72) = 0u;
    *(_QWORD *)(v25 + 120) = 0;
    *(_DWORD *)(v25 + 112) = 0;
    *(_QWORD *)(v25 + 152) = 0;
    *(_OWORD *)(v25 + 88) = 0u;
    *(_DWORD *)(v25 + 104) = 0;
    *(_QWORD *)(v25 + 128) = 0;
    *(_QWORD *)(v25 + 136) = 0;
    *(_QWORD *)(v25 + 141) = 0;
    *(_QWORD *)(v25 + 160) = 0;
    *(_QWORD *)(v25 + 168) = 0;
    *(_WORD *)(v25 + 176) = 0;
    UMPStream::EndpointPair::deserialize((std::string *)v25, (const __CFDictionary **)&v34, (uint64_t)&v37);
    v26 = v24 + 99;
    std::__tree<std::string>::destroy(v38);
    *(_DWORD *)(v25 + 64) = 4;
    *(_BYTE *)(v25 + 177) = 1;
    v18 = *(_DWORD *)(v25 + 8);
    v37 = (uint64_t *)v25;
    v27 = UMPCIManager<UMPStream::EndpointPair>::addPair(v26, (uint64_t *)&v37);
    v28 = v37;
    v37 = 0;
    if (v28)
      std::default_delete<UMPStream::EndpointPair>::operator()[abi:ne180100]((uint64_t)v28);
    if (!v27)
    {
      v18 = 0;
      v15 = v33;
      goto LABEL_26;
    }
    v29 = *v26;
    v30 = v34;
    if (v34)
      CFRetain(v34);
    v36 = v30;
    UMPCIServerContext::sendNotificationForObject(v29, 0, v18, &v36);
    v22 = v36;
    v15 = v33;
    if (!v36)
      goto LABEL_26;
    goto LABEL_14;
  }
  if ((a2 - 3) < 2)
  {
    v14 = MIDIServer::defaultInstance(v13);
    v15 = (std::mutex *)(v14 + 82);
    std::mutex::lock((std::mutex *)(v14 + 82));
    v16 = operator new();
    *(_QWORD *)(v16 + 192) = 0;
    *(_OWORD *)(v16 + 160) = 0u;
    *(_OWORD *)(v16 + 176) = 0u;
    *(_OWORD *)(v16 + 128) = 0u;
    *(_OWORD *)(v16 + 144) = 0u;
    *(_OWORD *)(v16 + 96) = 0u;
    *(_OWORD *)(v16 + 112) = 0u;
    *(_OWORD *)(v16 + 64) = 0u;
    *(_OWORD *)(v16 + 80) = 0u;
    *(_OWORD *)(v16 + 32) = 0u;
    *(_OWORD *)(v16 + 48) = 0u;
    *(_OWORD *)v16 = 0u;
    *(_OWORD *)(v16 + 16) = 0u;
    MIDIObject::MIDIObject((MIDIObject *)v16);
    *(_BYTE *)(v16 + 44) = 0;
    *(_BYTE *)(v16 + 48) = 0;
    *(_QWORD *)(v16 + 56) = 0;
    *(_QWORD *)v16 = off_1E98B6E28;
    *(_DWORD *)(v16 + 64) = 0;
    *(_BYTE *)(v16 + 68) = 0;
    *(_QWORD *)(v16 + 72) = 0;
    *(_DWORD *)(v16 + 84) = 0;
    *(_QWORD *)(v16 + 176) = 0;
    *(_BYTE *)(v16 + 184) = 0;
    *(_QWORD *)(v16 + 192) = 0;
    *(_QWORD *)(v16 + 100) = 0;
    *(_QWORD *)(v16 + 92) = 0;
    *(_QWORD *)(v16 + 106) = 0;
    *(_OWORD *)(v16 + 120) = 0u;
    *(_OWORD *)(v16 + 136) = 0u;
    *(_OWORD *)(v16 + 152) = 0u;
    *(_DWORD *)(v16 + 168) = 0;
    MIDICI::Device::deserialize((MIDICI::Device *)v16, (const __CFDictionary **)&v34, &v37);
    v17 = v14 + 78;
    std::__tree<std::string>::destroy(v38);
    *(_BYTE *)(v16 + 68) = 2;
    v18 = *(_DWORD *)(v16 + 8);
    v36 = (CFTypeRef)v16;
    v19 = UMPCIManager<MIDICI::Device>::addPairWithoutCheck(v17, (uint64_t *)&v36);
    v20 = v36;
    v36 = 0;
    if (v20)
      std::default_delete<MIDICI::Device>::operator()[abi:ne180100]((uint64_t)v20);
    if (!v19)
    {
      v18 = 0;
      goto LABEL_26;
    }
    v21 = *v17;
    cf = 0;
    UMPCIServerContext::sendNotificationForObject(v21, 0, v18, &cf);
    v22 = cf;
    if (!cf)
    {
LABEL_26:
      std::mutex::unlock(v15);
      v23 = 0;
      goto LABEL_27;
    }
LABEL_14:
    CFRelease(v22);
    goto LABEL_26;
  }
  v18 = 0;
  v23 = 4294956452;
LABEL_27:
  v31 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<UMPCIObject>::sRTTI, v18);
  if (v31)
  {
    v23 = 0;
    *(_DWORD *)(v31 + 44) = v7;
    *(_BYTE *)(v31 + 48) = 1;
    *a4 = v18;
  }
  if (v34)
    CFRelease(v34);
LABEL_31:
  if (v10)
    (*(void (**)(uint64_t *))(*v8 + 24))(v8);
  if ((v12 & 1) == 0)
    return 4294967246;
  return v23;
}

void sub_1D4EB5E74(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::mutex *a10, std::exception a11, char a12, uint64_t a13, uint64_t a14)
{
  uint64_t v14;
  int v15;

  applesauce::CF::DictionaryRef::~DictionaryRef((const void **)&a13);
  std::mutex::unlock(a10);
  applesauce::CF::DictionaryRef::~DictionaryRef((const void **)&a11.__vftable);
  if (v15)
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 24))(v14);
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a11.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
    __cxa_begin_catch(a1);
    std::exception::~exception(&a11);
    __cxa_end_catch();
    JUMPOUT(0x1D4EB5E40);
  }
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EB5E44);
}

uint64_t _UMPCIObjectDispose(MIDIServer *a1)
{
  int v1;
  uint64_t *v2;
  int v3;
  MIDIServer *v4;
  MIDIServer *v5;
  MIDIServer *v6;
  uint64_t *v7;
  std::mutex *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t *v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  CFTypeRef v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  CFTypeRef cf;

  v1 = (int)a1;
  v2 = MIDIServer::defaultInstance(a1) + 2;
  v3 = (*(uint64_t (**)(uint64_t *))(*v2 + 16))(v2);
  v4 = (MIDIServer *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<UMPCIObject>::sRTTI, v1);
  v5 = v4;
  if (!v4)
  {
    v15 = 4294967246;
    if (!v3)
      return v15;
    goto LABEL_50;
  }
  MIDIServer::defaultInstance(v4);
  v6 = (MIDIServer *)(*(uint64_t (**)(MIDIServer *))(*(_QWORD *)v5 + 96))(v5);
  if (((_DWORD)v6 - 1) >= 2)
  {
    if (((_DWORD)v6 - 3) >= 2)
    {
      v15 = 4294956452;
      if (!v3)
        return v15;
      goto LABEL_50;
    }
    v7 = MIDIServer::defaultInstance(v6);
    v8 = (std::mutex *)(v7 + 82);
    std::mutex::lock((std::mutex *)(v7 + 82));
    v9 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<UMPCIObject>::sRTTI, v1);
    if (v9)
    {
      v10 = (uint64_t *)v7[79];
      v11 = (uint64_t *)v7[80];
      if (v10 != v11)
      {
        v12 = *(_DWORD *)(v9 + 72);
        v13 = *(_DWORD *)(v9 + 76);
        while (1)
        {
          v14 = *v10;
          if (!v13 && *(_DWORD *)(v14 + 72) == v12)
            break;
          if (!v12 && *(_DWORD *)(v14 + 76) == v13 || *(_DWORD *)(v14 + 72) == v12 && *(_DWORD *)(v14 + 76) == v13)
            break;
          if (++v10 == v11)
            goto LABEL_48;
        }
        if (v10 != v11)
        {
          v23 = v10 + 1;
          if (v10 + 1 != v11)
          {
            do
            {
              v10 = v23;
              v24 = *(v23 - 1);
              *(v23 - 1) = *v23;
              *v23 = 0;
              if (v24)
                std::default_delete<MIDICI::Device>::operator()[abi:ne180100](v24);
              v23 = v10 + 1;
            }
            while (v10 + 1 != v11);
            v11 = (uint64_t *)v7[80];
          }
          while (v11 != v10)
          {
            v26 = *--v11;
            v25 = v26;
            *v11 = 0;
            if (v26)
              std::default_delete<MIDICI::Device>::operator()[abi:ne180100](v25);
          }
          v7[80] = (uint64_t)v10;
          v27 = v7[78];
          cf = 0;
          UMPCIServerContext::sendNotificationForObject(v27, 2, v1, &cf);
          v28 = cf;
          if (!cf)
            goto LABEL_57;
          goto LABEL_56;
        }
      }
    }
LABEL_48:
    v15 = 4294956454;
    goto LABEL_49;
  }
  v16 = MIDIServer::defaultInstance(v6);
  v8 = (std::mutex *)(v16 + 103);
  std::mutex::lock((std::mutex *)(v16 + 103));
  v17 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<UMPCIObject>::sRTTI, v1);
  if (!v17)
    goto LABEL_48;
  if (!*(_BYTE *)(v17 + 148))
    goto LABEL_48;
  v18 = (uint64_t *)v16[100];
  v19 = (uint64_t *)v16[101];
  if (v18 == v19)
    goto LABEL_48;
  v20 = *(_DWORD *)(v17 + 100);
  v21 = *(_DWORD *)(v17 + 104);
  while (1)
  {
    v22 = *v18;
    if (!v21 && *(_DWORD *)(v22 + 100) == v20)
      break;
    if (!v20 && *(_DWORD *)(v22 + 104) == v21 || *(_DWORD *)(v22 + 100) == v20 && *(_DWORD *)(v22 + 104) == v21)
      break;
    if (++v18 == v19)
      goto LABEL_48;
  }
  if (v18 == v19)
    goto LABEL_48;
  v29 = v18 + 1;
  if (v18 + 1 != v19)
  {
    do
    {
      v18 = v29;
      v30 = *(v29 - 1);
      *(v29 - 1) = *v29;
      *v29 = 0;
      if (v30)
        std::default_delete<UMPStream::EndpointPair>::operator()[abi:ne180100](v30);
      v29 = v18 + 1;
    }
    while (v18 + 1 != v19);
    v19 = (uint64_t *)v16[101];
  }
  while (v19 != v18)
  {
    v33 = *--v19;
    v32 = v33;
    *v19 = 0;
    if (v33)
      std::default_delete<UMPStream::EndpointPair>::operator()[abi:ne180100](v32);
  }
  v16[101] = (uint64_t)v18;
  v34 = v16[99];
  cf = 0;
  UMPCIServerContext::sendNotificationForObject(v34, 2, v1, &cf);
  v28 = cf;
  if (!cf)
    goto LABEL_57;
LABEL_56:
  CFRelease(v28);
LABEL_57:
  v15 = 0;
LABEL_49:
  std::mutex::unlock(v8);
  if (v3)
LABEL_50:
    (*(void (**)(uint64_t *))(*v2 + 24))(v2);
  return v15;
}

void sub_1D4EB6364(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::exception a9, const void *a10)
{
  uint64_t v10;
  int v11;
  std::mutex *v12;

  applesauce::CF::DictionaryRef::~DictionaryRef(&a10);
  std::mutex::unlock(v12);
  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a9.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
    __cxa_begin_catch(a1);
    std::exception::~exception(&a9);
  }
  else
  {
    __cxa_begin_catch(a1);
  }
  __cxa_end_catch();
  JUMPOUT(0x1D4EB62F8);
}

uint64_t _UMPCIObjectSetDescription(MIDIServer *a1, const void *a2)
{
  int v3;
  uint64_t *v4;
  int v5;
  MIDIServer *v6;
  MIDIServer *v7;
  MIDIServer *v8;
  uint64_t *v9;
  std::mutex *v10;
  _QWORD *v11;
  CFTypeRef v12;
  int v13;
  uint64_t v14;
  CFTypeRef v15;
  uint64_t v16;
  uint64_t *v17;
  _QWORD *v18;
  CFTypeRef v19;
  uint64_t v20;
  CFTypeRef v21;
  _QWORD *v22;
  CFTypeRef v23;
  int v24;
  uint64_t v25;
  _QWORD *v26;
  CFTypeRef v27;
  uint64_t v28;
  CFTypeRef cf;
  CFTypeRef v31;
  CFTypeRef v32;
  CFTypeRef v33;
  char *v34;
  unsigned __int8 v35;

  v3 = (int)a1;
  v4 = MIDIServer::defaultInstance(a1) + 2;
  v5 = (*(uint64_t (**)(uint64_t *))(*v4 + 16))(v4);
  if (!BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<UMPCIObject>::sRTTI, v3)
    || (v6 = (MIDIServer *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<UMPCIObject>::sRTTI, v3),
        (v7 = v6) == 0))
  {
    v16 = 4294967246;
    goto LABEL_51;
  }
  MIDIServer::defaultInstance(v6);
  if (a2)
    CFRetain(a2);
  applesauce::CF::DictionaryRef::DictionaryRef((applesauce::CF::DictionaryRef *)&cf, a2);
  v8 = (MIDIServer *)(*(uint64_t (**)(MIDIServer *))(*(_QWORD *)v7 + 96))(v7);
  if (((_DWORD)v8 - 1) < 2)
  {
    v17 = MIDIServer::defaultInstance(v8);
    v10 = (std::mutex *)(v17 + 103);
    std::mutex::lock((std::mutex *)(v17 + 103));
    v18 = (_QWORD *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<UMPCIObject>::sRTTI, v3);
    if (v18)
    {
      v19 = cf;
      if (cf)
        CFRetain(cf);
      v32 = v19;
      UMPCIObject::updateDescription((uint64_t)&v33, v18, (const __CFDictionary **)&v32);
      if (v32)
        CFRelease(v32);
      if (!v35)
        goto LABEL_47;
      v20 = v17[99];
      v31 = 0;
      UMPCIServerContext::sendNotificationForObject(v20, 1, v3, &v31);
      v21 = v31;
      if (!v31)
        goto LABEL_45;
    }
    else
    {
      v26 = (_QWORD *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<UMPCIObject>::sRTTI, v3);
      if (!v26)
        goto LABEL_54;
      v27 = cf;
      if (cf)
        CFRetain(cf);
      v32 = v27;
      UMPCIObject::updateDescription((uint64_t)&v33, v26, (const __CFDictionary **)&v32);
      if (v32)
        CFRelease(v32);
      if (!v35)
        goto LABEL_47;
      v28 = v17[99];
      v31 = 0;
      UMPCIServerContext::sendNotificationForObject(v28, 1, v3, &v31);
      v21 = v31;
      if (!v31)
      {
LABEL_45:
        if (v35)
          std::__tree<std::string>::destroy(v34);
        goto LABEL_47;
      }
    }
    CFRelease(v21);
    goto LABEL_45;
  }
  if (((_DWORD)v8 - 3) >= 2)
  {
    v16 = 4294956452;
    goto LABEL_49;
  }
  v9 = MIDIServer::defaultInstance(v8);
  v10 = (std::mutex *)(v9 + 82);
  std::mutex::lock((std::mutex *)(v9 + 82));
  v11 = (_QWORD *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<UMPCIObject>::sRTTI, v3);
  if (v11)
  {
    v12 = cf;
    if (cf)
      CFRetain(cf);
    v32 = v12;
    UMPCIObject::updateDescription((uint64_t)&v33, v11, (const __CFDictionary **)&v32);
    v13 = v35;
    if (v35)
      std::__tree<std::string>::destroy(v34);
    if (v32)
      CFRelease(v32);
    if (!v13)
      goto LABEL_47;
    v14 = v9[78];
    v33 = 0;
    UMPCIServerContext::sendNotificationForObject(v14, 1, v3, &v33);
    v15 = v33;
    if (!v33)
      goto LABEL_47;
    goto LABEL_16;
  }
  v22 = (_QWORD *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<UMPCIObject>::sRTTI, v3);
  if (!v22)
  {
LABEL_54:
    v16 = 4294956454;
    goto LABEL_48;
  }
  v23 = cf;
  if (cf)
    CFRetain(cf);
  v32 = v23;
  UMPCIObject::updateDescription((uint64_t)&v33, v22, (const __CFDictionary **)&v32);
  v24 = v35;
  if (v35)
    std::__tree<std::string>::destroy(v34);
  if (v32)
    CFRelease(v32);
  if (!v24)
    goto LABEL_47;
  v25 = v9[78];
  v33 = 0;
  UMPCIServerContext::sendNotificationForObject(v25, 1, v3, &v33);
  v15 = v33;
  if (!v33)
    goto LABEL_47;
LABEL_16:
  CFRelease(v15);
LABEL_47:
  v16 = 0;
LABEL_48:
  std::mutex::unlock(v10);
LABEL_49:
  if (cf)
    CFRelease(cf);
LABEL_51:
  if (v5)
    (*(void (**)(uint64_t *))(*v4 + 24))(v4);
  return v16;
}

void sub_1D4EB6768(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10, const void *a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, char *a19, uint64_t a20,char a21)
{
  uint64_t v21;
  int v22;
  std::mutex *v23;

  applesauce::CF::DictionaryRef::~DictionaryRef(&a11);
  if (a21)
    std::__tree<std::string>::destroy(a19);
  std::mutex::unlock(v23);
  applesauce::CF::DictionaryRef::~DictionaryRef((const void **)&a10.__vftable);
  if (v22)
    (*(void (**)(uint64_t))(*(_QWORD *)v21 + 24))(v21);
  if (a2 == 3)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
  }
  else
  {
    if (a2 == 2)
    {
      __cxa_get_exception_ptr(a1);
      a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
      __cxa_begin_catch(a1);
      std::exception::~exception(&a10);
    }
    else
    {
      __cxa_begin_catch(a1);
    }
    __cxa_end_catch();
  }
  JUMPOUT(0x1D4EB6738);
}

uint64_t _UMPCIObjectSetEnableState(MIDIServer *a1, int a2)
{
  int v3;
  uint64_t *v4;
  int v5;
  MIDIServer *v6;
  uint64_t v7;
  MIDIServer *v8;
  uint64_t *v9;
  std::mutex *v10;
  uint64_t v11;
  uint64_t v12;
  CFTypeRef v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  CFTypeRef cf;

  v3 = (int)a1;
  v4 = MIDIServer::defaultInstance(a1) + 2;
  v5 = (*(uint64_t (**)(uint64_t *))(*v4 + 16))(v4);
  v6 = (MIDIServer *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<UMPCIObject>::sRTTI, v3);
  if (!v6
    || (MIDIServer::defaultInstance(v6),
        (v7 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<UMPCIObject>::sRTTI, v3)) == 0))
  {
    v14 = 4294967246;
    if (!v5)
      return v14;
    goto LABEL_23;
  }
  v8 = (MIDIServer *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 96))(v7);
  if (((_DWORD)v8 - 3) < 2)
  {
    v15 = MIDIServer::defaultInstance(v8);
    v10 = (std::mutex *)(v15 + 82);
    std::mutex::lock((std::mutex *)(v15 + 82));
    v16 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<UMPCIObject>::sRTTI, v3);
    if (v16)
    {
      *(_BYTE *)(v16 + 112) = a2 != 0;
      v17 = v15[78];
      cf = 0;
      UMPCIServerContext::sendNotificationForObject(v17, 1, v3, &cf);
      v13 = cf;
      if (cf)
        goto LABEL_20;
      goto LABEL_21;
    }
    v20 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<UMPCIObject>::sRTTI, v3);
    if (v20)
    {
      *(_BYTE *)(v20 + 116) = a2 != 0;
      v21 = v15[78];
      cf = 0;
      UMPCIServerContext::sendNotificationForObject(v21, 1, v3, &cf);
      v13 = cf;
      if (cf)
LABEL_20:
        CFRelease(v13);
LABEL_21:
      v14 = 0;
      goto LABEL_22;
    }
  }
  else
  {
    if (((_DWORD)v8 - 1) > 1)
    {
      v14 = 4294956452;
      if (!v5)
        return v14;
      goto LABEL_23;
    }
    v9 = MIDIServer::defaultInstance(v8);
    v10 = (std::mutex *)(v9 + 103);
    std::mutex::lock((std::mutex *)(v9 + 103));
    v11 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<UMPCIObject>::sRTTI, v3);
    if (v11)
    {
      *(_BYTE *)(v11 + 147) = a2 != 0;
      v12 = v9[99];
      cf = 0;
      UMPCIServerContext::sendNotificationForObject(v12, 1, v3, &cf);
      v13 = cf;
      if (cf)
        goto LABEL_20;
      goto LABEL_21;
    }
    v18 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<UMPCIObject>::sRTTI, v3);
    if (v18)
    {
      *(_BYTE *)(v18 + 64) = a2 != 0;
      v19 = v9[99];
      cf = 0;
      UMPCIServerContext::sendNotificationForObject(v19, 1, v3, &cf);
      v13 = cf;
      if (cf)
        goto LABEL_20;
      goto LABEL_21;
    }
  }
  v14 = 4294956454;
LABEL_22:
  std::mutex::unlock(v10);
  if (v5)
LABEL_23:
    (*(void (**)(uint64_t *))(*v4 + 24))(v4);
  return v14;
}

void sub_1D4EB6B10(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::exception a9, const void *a10)
{
  uint64_t v10;
  int v11;
  std::mutex *v12;

  applesauce::CF::DictionaryRef::~DictionaryRef(&a10);
  std::mutex::unlock(v12);
  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 3)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
  }
  else
  {
    if (a2 == 2)
    {
      __cxa_get_exception_ptr(a1);
      a9.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
      __cxa_begin_catch(a1);
      std::exception::~exception(&a9);
    }
    else
    {
      __cxa_begin_catch(a1);
    }
    __cxa_end_catch();
  }
  JUMPOUT(0x1D4EB6AE0);
}

uint64_t _UMPCIGlobalState(MIDIServer *a1)
{
  uint64_t *v2;
  MIDIServer *v3;
  int v4;
  void *Mutable;
  void *v6;
  uint64_t *v7;
  uint64_t *v8;
  std::mutex *v9;
  UMPStream::EndpointPair **v10;
  UMPStream::EndpointPair **i;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  CFDictionaryRef v23;
  __int128 v24;
  unint64_t v25;
  CFArrayRef v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t *v29;
  MIDICI::Device **v30;
  MIDICI::Device **j;
  _QWORD *v32;
  _QWORD *v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  unint64_t v40;
  _QWORD *v41;
  uint64_t v42;
  CFDictionaryRef v43;
  __int128 v44;
  unint64_t v45;
  CFArrayRef v46;
  CFNumberRef v47;
  void *exception;
  MIDIServer *v50;
  int v51;
  __int128 v52;
  unint64_t v53;
  CFDictionaryRef valuePtr;
  void **v55;
  __int128 v56;
  unint64_t v57;
  unint64_t *v58;
  uint64_t v59;

  v2 = MIDIServer::defaultInstance(a1) + 2;
  v3 = (MIDIServer *)(*(uint64_t (**)(uint64_t *))(*v2 + 16))(v2);
  v4 = (int)v3;
  if (!a1)
  {
    v27 = 4294967246;
    if (!(_DWORD)v3)
      return v27;
    goto LABEL_50;
  }
  v50 = a1;
  v51 = (int)v3;
  MIDIServer::defaultInstance(v3);
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9AEB8], MEMORY[0x1E0C9B3A0]);
  v6 = Mutable;
  if (Mutable)
    Mutable = (void *)CFRetain(Mutable);
  v7 = MIDIServer::defaultInstance((MIDIServer *)Mutable);
  if (v6)
  {
    v8 = v7;
    CFRetain(v6);
    v9 = (std::mutex *)(v8 + 103);
    std::mutex::lock((std::mutex *)(v8 + 103));
    v52 = 0uLL;
    v53 = 0;
    v10 = (UMPStream::EndpointPair **)v8[100];
    for (i = (UMPStream::EndpointPair **)v8[101]; v10 != i; ++v10)
    {
      UMPStream::EndpointPair::serialize(*v10, &valuePtr);
      v12 = (_QWORD *)*((_QWORD *)&v52 + 1);
      if (*((_QWORD *)&v52 + 1) >= v53)
      {
        v13 = (_QWORD *)v52;
        v14 = (uint64_t)(*((_QWORD *)&v52 + 1) - v52) >> 3;
        v15 = v14 + 1;
        if ((unint64_t)(v14 + 1) >> 61)
          std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
        v16 = v53 - v52;
        if ((uint64_t)(v53 - v52) >> 2 > v15)
          v15 = v16 >> 2;
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8)
          v17 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v17 = v15;
        v58 = &v53;
        if (v17)
        {
          v17 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v17);
          v12 = (_QWORD *)*((_QWORD *)&v52 + 1);
          v13 = (_QWORD *)v52;
        }
        else
        {
          v18 = 0;
        }
        v19 = (_QWORD *)(v17 + 8 * v14);
        v20 = v17 + 8 * v18;
        v57 = v20;
        *v19 = valuePtr;
        v21 = v19 + 1;
        valuePtr = 0;
        *((_QWORD *)&v56 + 1) = v19 + 1;
        if (v12 == v13)
        {
          v23 = 0;
        }
        else
        {
          do
          {
            v22 = *--v12;
            *--v19 = v22;
            *v12 = 0;
          }
          while (v12 != v13);
          v21 = (_QWORD *)*((_QWORD *)&v56 + 1);
          v20 = v57;
          v23 = valuePtr;
        }
        v24 = v52;
        *(_QWORD *)&v52 = v19;
        v56 = v24;
        v25 = v53;
        v53 = v20;
        v57 = v25;
        v55 = (void **)v24;
        std::__split_buffer<applesauce::CF::DictionaryRef>::~__split_buffer((uint64_t)&v55);
        *((_QWORD *)&v52 + 1) = v21;
        if (v23)
          CFRelease(v23);
      }
      else
      {
        **((_QWORD **)&v52 + 1) = valuePtr;
        *((_QWORD *)&v52 + 1) = v12 + 1;
      }
    }
    v26 = applesauce::CF::details::make_CFArrayRef<applesauce::CF::DictionaryRef>((uint64_t **)&v52);
    v55 = 0;
    v4 = v51;
    CFDictionaryAddValue((CFMutableDictionaryRef)v6, CFSTR("ump_endpoints"), v26);
    v55 = (void **)&v52;
    std::vector<applesauce::CF::DictionaryRef>::__destroy_vector::operator()[abi:ne180100](&v55);
    std::mutex::unlock(v9);
    CFRelease(v6);
  }
  v28 = MIDIServer::defaultInstance((MIDIServer *)v7);
  if (v6)
  {
    v29 = v28;
    CFRetain(v6);
    std::mutex::lock((std::mutex *)(v29 + 82));
    v52 = 0uLL;
    v53 = 0;
    v30 = (MIDICI::Device **)v29[79];
    for (j = (MIDICI::Device **)v29[80]; v30 != j; ++v30)
    {
      MIDICI::Device::serialize(*v30, &valuePtr);
      v32 = (_QWORD *)*((_QWORD *)&v52 + 1);
      if (*((_QWORD *)&v52 + 1) >= v53)
      {
        v33 = (_QWORD *)v52;
        v34 = (uint64_t)(*((_QWORD *)&v52 + 1) - v52) >> 3;
        v35 = v34 + 1;
        if ((unint64_t)(v34 + 1) >> 61)
          std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
        v36 = v53 - v52;
        if ((uint64_t)(v53 - v52) >> 2 > v35)
          v35 = v36 >> 2;
        if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF8)
          v37 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v37 = v35;
        v58 = &v53;
        if (v37)
        {
          v37 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v37);
          v32 = (_QWORD *)*((_QWORD *)&v52 + 1);
          v33 = (_QWORD *)v52;
        }
        else
        {
          v38 = 0;
        }
        v39 = (_QWORD *)(v37 + 8 * v34);
        v40 = v37 + 8 * v38;
        v57 = v40;
        *v39 = valuePtr;
        v41 = v39 + 1;
        valuePtr = 0;
        *((_QWORD *)&v56 + 1) = v39 + 1;
        if (v32 == v33)
        {
          v43 = 0;
        }
        else
        {
          do
          {
            v42 = *--v32;
            *--v39 = v42;
            *v32 = 0;
          }
          while (v32 != v33);
          v41 = (_QWORD *)*((_QWORD *)&v56 + 1);
          v40 = v57;
          v43 = valuePtr;
        }
        v44 = v52;
        *(_QWORD *)&v52 = v39;
        *((_QWORD *)&v52 + 1) = v41;
        v56 = v44;
        v45 = v53;
        v53 = v40;
        v57 = v45;
        v55 = (void **)v44;
        std::__split_buffer<applesauce::CF::DictionaryRef>::~__split_buffer((uint64_t)&v55);
        *((_QWORD *)&v52 + 1) = v41;
        if (v43)
          CFRelease(v43);
      }
      else
      {
        **((_QWORD **)&v52 + 1) = valuePtr;
        *((_QWORD *)&v52 + 1) = v32 + 1;
      }
    }
    v46 = applesauce::CF::details::make_CFArrayRef<applesauce::CF::DictionaryRef>((uint64_t **)&v52);
    v55 = 0;
    v4 = v51;
    CFDictionaryAddValue((CFMutableDictionaryRef)v6, CFSTR("midi_ci_devices"), v46);
    LODWORD(valuePtr) = *((_DWORD *)v29 + 180);
    v47 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    if (!v47)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x1D826B7EC](exception, "Could not construct");
    }
    v59 = 0;
    CFDictionaryAddValue((CFMutableDictionaryRef)v6, CFSTR("device_manager_muid"), v47);
    v55 = (void **)&v52;
    std::vector<applesauce::CF::DictionaryRef>::__destroy_vector::operator()[abi:ne180100](&v55);
    std::mutex::unlock((std::mutex *)(v29 + 82));
    CFRelease(v6);
  }
  v27 = 0;
  *(_QWORD *)v50 = v6;
  if (v4)
LABEL_50:
    (*(void (**)(uint64_t *))(*v2 + 24))(v2);
  return v27;
}

void sub_1D4EB7074(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, std::mutex *a9, uint64_t a10, int a11, int a12, const void *a13, __int16 a14, char a15, char a16, int a17, const void *a18, std::exception a19, uint64_t a20,uint64_t a21,CFTypeRef cf,const void *a23)
{
  uint64_t v23;
  uint64_t v24;

  applesauce::CF::ArrayRef::~ArrayRef(&a23);
  *(_QWORD *)(v24 - 88) = &a19;
  std::vector<applesauce::CF::DictionaryRef>::__destroy_vector::operator()[abi:ne180100]((void ***)(v24 - 88));
  std::mutex::unlock(a9);
  applesauce::CF::ObjectRef<__CFDictionary *>::~ObjectRef(&a13);
  applesauce::CF::ObjectRef<__CFDictionary *>::~ObjectRef(&a18);
  if (a12)
    (*(void (**)(uint64_t))(*(_QWORD *)v23 + 24))(v23);
  if (a2 == 3)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
  }
  else
  {
    if (a2 == 2)
    {
      __cxa_get_exception_ptr(a1);
      a19.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
      __cxa_begin_catch(a1);
      std::exception::~exception(&a19);
    }
    else
    {
      __cxa_begin_catch(a1);
    }
    __cxa_end_catch();
  }
  JUMPOUT(0x1D4EB700CLL);
}

const void **applesauce::CF::ObjectRef<__CFDictionary *>::~ObjectRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

uint64_t _UMPCIDiscover(MIDIServer *a1)
{
  uint64_t *v1;
  SetupManager *v2;
  int v3;
  MIDIServer *v4;
  uint64_t v5;
  uint64_t *v6;
  _BYTE *v7;
  _BYTE *v8;
  int64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  MIDICI::DeviceManager *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;

  v1 = MIDIServer::defaultInstance(a1) + 2;
  v2 = (SetupManager *)(*(uint64_t (**)(uint64_t *))(*v1 + 16))(v1);
  v3 = (int)v2;
  v4 = (MIDIServer *)SetupManager::instance(v2);
  v5 = *(_QWORD *)v4;
  if (*(_QWORD *)v4)
  {
    v6 = MIDIServer::defaultInstance(v4);
    v8 = *(_BYTE **)(v5 + 88);
    v7 = *(_BYTE **)(v5 + 96);
    v9 = v7 - v8;
    if (v7 != v8)
    {
      if (v9 < 0)
        std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
      v10 = v6;
      v11 = (uint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v9 >> 3);
      memmove((void *)v11, v8, v9);
      v12 = 8 * (v9 >> 3);
      if (v12)
      {
        v13 = 0;
        v14 = (MIDICI::DeviceManager *)(v10 + 78);
        do
        {
          v15 = *(_QWORD *)(v11 + v13);
          if (!*(_BYTE *)(v15 + 89))
          {
            if (MIDIEndpoint::IsPartOfLegacyDevice(*(MIDIEndpoint **)(v11 + v13))
              && (v16 = *(_QWORD **)(v15 + 64)) != 0
              && v16[10] != v16[9]
              && (v18 = v16 + 13, v17 = v16[13], v18[1] != v17)
              && *(_DWORD *)(*(_QWORD *)v17 + 8)
              || MIDIEndpoint::IsPartOfUMPDevice((MIDIEndpoint *)v15)
              && (MIDIEndpoint::IsPartOfPhantomEntity(*(MIDIObject **)(v15 + 64)) & 1) != 0
              || *(_QWORD *)(v15 + 48))
            {
              v19 = *(_QWORD **)(v15 + 64);
              if (!v19 || v19[10] == v19[9] || (v21 = v19 + 13, v20 = v19[13], v21[1] == v20))
                v22 = 0;
              else
                v22 = *(unsigned int *)(*(_QWORD *)v20 + 8);
              MIDICI::DeviceManager::sendDiscoveryInquiryMessage(v14, v22, 0);
            }
          }
          v13 += 8;
        }
        while (v12 != v13);
      }
      if (!v11)
      {
LABEL_25:
        if (!v3)
          return v11;
        goto LABEL_28;
      }
      operator delete((void *)v11);
    }
    v11 = 0;
    goto LABEL_25;
  }
  v11 = 4294956452;
  if (v3)
LABEL_28:
    (*(void (**)(uint64_t *))(*v1 + 24))(v1);
  return v11;
}

void sub_1D4EB7414(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  int v11;

  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 3)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
  }
  else
  {
    if (a2 == 2)
    {
      __cxa_get_exception_ptr(a1);
      a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
      __cxa_begin_catch(a1);
      std::exception::~exception(&a10);
    }
    else
    {
      __cxa_begin_catch(a1);
    }
    __cxa_end_catch();
  }
  JUMPOUT(0x1D4EB73E8);
}

uint64_t _MIDIInputPortCreate(MIDIServer *a1, const __CFString *a2, int a3, _DWORD *a4, const void *a5, const void *a6)
{
  int v11;
  uint64_t *v12;
  int v13;
  MIDIObject *v14;
  uint64_t v15;
  uint64_t v16;

  v11 = (int)a1;
  v12 = MIDIServer::defaultInstance(a1) + 2;
  v13 = (*(uint64_t (**)(uint64_t *))(*v12 + 16))(v12);
  v14 = (MIDIObject *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIClient>::sRTTI, v11);
  if (v14)
  {
    v15 = operator new();
    MIDIObject::MIDIObject((MIDIObject *)v15, v14, a2);
    *(_QWORD *)(v15 + 48) = v14;
    *(_QWORD *)v15 = &off_1E98B9570;
    *(_DWORD *)(v15 + 56) = a3;
    *(_QWORD *)(v15 + 80) = 0;
    *(_QWORD *)(v15 + 88) = 0;
    *(_QWORD *)(v15 + 96) = 0;
    *(_QWORD *)(v15 + 64) = _Block_copy(a5);
    *(_QWORD *)(v15 + 72) = _Block_copy(a6);
    *a4 = *(_DWORD *)(v15 + 8);
    MIDIClient::AddPort(v14, (MIDIPort *)v15);
    v16 = 0;
    if (!v13)
      return v16;
    goto LABEL_5;
  }
  v16 = 4294967246;
  if (v13)
LABEL_5:
    (*(void (**)(uint64_t *))(*v12 + 24))(v12);
  return v16;
}

void sub_1D4EB75F4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  int v11;
  uint64_t v12;

  MEMORY[0x1D826BA98](v12, 0x10E1C40D52198E0);
  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 3)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
  }
  else
  {
    if (a2 == 2)
    {
      __cxa_get_exception_ptr(a1);
      a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
      __cxa_begin_catch(a1);
      std::exception::~exception(&a10);
    }
    else
    {
      __cxa_begin_catch(a1);
    }
    __cxa_end_catch();
  }
  JUMPOUT(0x1D4EB75CCLL);
}

uint64_t _MIDIOutputPortCreate(MIDIServer *a1, const __CFString *a2, _DWORD *a3)
{
  int v5;
  uint64_t *v6;
  int v7;
  MIDIObject *v8;
  uint64_t v9;
  uint64_t v10;

  v5 = (int)a1;
  v6 = MIDIServer::defaultInstance(a1) + 2;
  v7 = (*(uint64_t (**)(uint64_t *))(*v6 + 16))(v6);
  v8 = (MIDIObject *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIClient>::sRTTI, v5);
  if (v8)
  {
    v9 = operator new();
    MIDIObject::MIDIObject((MIDIObject *)v9, v8, a2);
    *(_QWORD *)(v9 + 48) = v8;
    *(_QWORD *)v9 = &off_1E98B96C0;
    *a3 = *(_DWORD *)(v9 + 8);
    MIDIClient::AddPort(v8, (MIDIPort *)v9);
    v10 = 0;
    if (!v7)
      return v10;
    goto LABEL_5;
  }
  v10 = 4294967246;
  if (v7)
LABEL_5:
    (*(void (**)(uint64_t *))(*v6 + 24))(v6);
  return v10;
}

void sub_1D4EB77D0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  int v11;
  uint64_t v12;

  MEMORY[0x1D826BA98](v12, 0x10E1C403A02A5B8);
  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 3)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
  }
  else
  {
    if (a2 == 2)
    {
      __cxa_get_exception_ptr(a1);
      a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
      __cxa_begin_catch(a1);
      std::exception::~exception(&a10);
    }
    else
    {
      __cxa_begin_catch(a1);
    }
    __cxa_end_catch();
  }
  JUMPOUT(0x1D4EB77B0);
}

uint64_t _MIDIPortDispose(MIDIServer *a1)
{
  int v1;
  uint64_t *v2;
  MIDIServer *v3;
  int v4;
  uint64_t *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  char *v10;
  _QWORD *v11;
  int64_t v12;
  uint64_t v13;

  v1 = (int)a1;
  v2 = MIDIServer::defaultInstance(a1) + 13;
  v3 = (MIDIServer *)(*(uint64_t (**)(uint64_t *))(*v2 + 16))(v2);
  v4 = (int)v3;
  v5 = MIDIServer::defaultInstance(v3) + 2;
  v6 = (*(uint64_t (**)(uint64_t *))(*v5 + 16))(v5);
  v7 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIPort>::sRTTI, v1);
  if (!v7)
  {
    v13 = 4294967246;
    if (!v6)
      goto LABEL_18;
    goto LABEL_17;
  }
  v8 = *(_QWORD *)(v7 + 48);
  v9 = *(char **)(v8 + 80);
  v10 = *(char **)(v8 + 72);
  if (v10 != v9)
  {
    v10 = *(char **)(v8 + 72);
    while (*(_QWORD *)v10 != v7)
    {
      v10 += 8;
      if (v10 == v9)
      {
        v10 = *(char **)(v8 + 80);
        break;
      }
    }
  }
  if (v10 == v9)
  {
    v13 = 4294956465;
    if (!v6)
      goto LABEL_18;
    goto LABEL_17;
  }
  if (*(_QWORD *)v10)
  {
    (*(void (**)(_QWORD))(**(_QWORD **)v10 + 8))(*(_QWORD *)v10);
    v9 = *(char **)(v8 + 80);
  }
  v11 = v10;
  v12 = v9 - (v10 + 8);
  if (v9 != v10 + 8)
    memmove(v10, v10 + 8, v9 - (v10 + 8));
  v13 = 0;
  *(_QWORD *)(v8 + 80) = (char *)v11 + v12;
  if (v6)
LABEL_17:
    (*(void (**)(uint64_t *))(*v5 + 24))(v5);
LABEL_18:
  if (v4)
    (*(void (**)(uint64_t *))(*v2 + 24))(v2);
  return v13;
}

void sub_1D4EB79E4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  int v11;

  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 3)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
  }
  else
  {
    if (a2 == 2)
    {
      __cxa_get_exception_ptr(a1);
      a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
      __cxa_begin_catch(a1);
      std::exception::~exception(&a10);
    }
    else
    {
      __cxa_begin_catch(a1);
    }
    __cxa_end_catch();
  }
  JUMPOUT(0x1D4EB79A8);
}

void sub_1D4EB7A7C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  int v2;

  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

uint64_t _MIDIPortConnectSource(MIDIServer *a1, int a2, uint64_t a3)
{
  int v5;
  uint64_t *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  MIDIServer *v11;
  int64x2_t *v12;
  uint64_t *v13;
  int v14;
  int64x2_t **v15;
  int64x2_t **v16;
  int64x2_t **v17;
  unint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  char *v26;
  int64x2_t **v27;
  char *v28;
  char *v29;
  char *v30;
  int64x2_t *v31;
  uint64_t v32;
  char *v33;
  unint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t v38;
  int64x2_t v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD *v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  _QWORD *v46;
  unint64_t v47;
  uint64_t *v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  char *v55;
  uint64_t *v56;
  unint64_t v57;
  uint64_t v58;
  char *v59;
  uint64_t v60;
  uint64_t v61;
  int64x2_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  int64x2_t v66;
  uint64_t v67;
  int64x2_t *v68;
  uint64_t (**v69)();
  _QWORD v70[6];
  uint64_t (**v71)();
  int64x2_t v72;
  uint64_t v73;
  int64x2_t *v74;
  uint64_t v75;

  v5 = (int)a1;
  v75 = *MEMORY[0x1E0C80C00];
  v6 = MIDIServer::defaultInstance(a1) + 2;
  v7 = (*(uint64_t (**)(uint64_t *))(*v6 + 16))(v6);
  v8 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIPort>::sRTTI, v5);
  if (!v8)
    goto LABEL_12;
  v9 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIEndpoint>::sRTTI, a2);
  if (!v9)
    goto LABEL_12;
  v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 80))(v9);
  if (!v10)
  {
    v20 = 4294956464;
    goto LABEL_13;
  }
  v11 = (MIDIServer *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 80))(v8);
  v12 = (int64x2_t *)v11;
  if (!v11)
  {
LABEL_12:
    v20 = 4294967246;
    goto LABEL_13;
  }
  v13 = MIDIServer::defaultInstance(v11) + 13;
  v14 = (*(uint64_t (**)(uint64_t *))(*v13 + 16))(v13);
  v15 = *(int64x2_t ***)(v10 + 96);
  v16 = *(int64x2_t ***)(v10 + 104);
  v17 = v15;
  if (v15 != v16)
  {
    while (*v17 != v12)
    {
      if (++v17 == v16)
      {
        v17 = *(int64x2_t ***)(v10 + 104);
        break;
      }
    }
  }
  if (v17 == v16)
  {
    v18 = *(_QWORD *)(v10 + 112);
    if ((unint64_t)v16 >= v18)
    {
      v22 = v16 - v15;
      if ((unint64_t)(v22 + 1) >> 61)
        std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
      v23 = v18 - (_QWORD)v15;
      v24 = v23 >> 2;
      if (v23 >> 2 <= (unint64_t)(v22 + 1))
        v24 = v22 + 1;
      if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8)
        v25 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v25 = v24;
      if (v25)
      {
        if (v25 >> 61)
          std::__throw_bad_array_new_length[abi:ne180100]();
        v26 = (char *)operator new(8 * v25);
      }
      else
      {
        v26 = 0;
      }
      v27 = (int64x2_t **)&v26[8 * v22];
      v28 = &v26[8 * v25];
      *v27 = v12;
      v19 = v27 + 1;
      v30 = *(char **)(v10 + 96);
      v29 = *(char **)(v10 + 104);
      if (v29 != v30)
      {
        do
        {
          v31 = (int64x2_t *)*((_QWORD *)v29 - 1);
          v29 -= 8;
          *--v27 = v31;
        }
        while (v29 != v30);
        v29 = *(char **)(v10 + 96);
      }
      *(_QWORD *)(v10 + 96) = v27;
      *(_QWORD *)(v10 + 104) = v19;
      *(_QWORD *)(v10 + 112) = v28;
      if (v29)
        operator delete(v29);
    }
    else
    {
      *v16 = v12;
      v19 = v16 + 1;
    }
    *(_QWORD *)(v10 + 104) = v19;
    v32 = v12[5].i64[0];
    if (v32 == v12[5].i64[1] && (unint64_t)(v12[6].i64[0] - v32) <= 0xFF)
    {
      v74 = v12 + 6;
      v33 = (char *)operator new(0x100uLL);
      v35 = v12[5].i64[0];
      v34 = v12[5].u64[1];
      if (v34 == v35)
      {
        v39 = vdupq_n_s64(v34);
        v36 = v33;
      }
      else
      {
        v36 = v33;
        do
        {
          v37 = *(_QWORD *)(v34 - 16);
          v34 -= 16;
          *((_QWORD *)v36 - 2) = v37;
          v36 -= 16;
          v38 = *(_QWORD *)(v34 + 8);
          *(_QWORD *)(v34 + 8) = 0;
          *((_QWORD *)v36 + 1) = v38;
        }
        while (v34 != v35);
        v39 = v12[5];
      }
      v12[5].i64[0] = (uint64_t)v36;
      v12[5].i64[1] = (uint64_t)v33;
      v72 = v39;
      v40 = v12[6].i64[0];
      v12[6].i64[0] = (uint64_t)(v33 + 256);
      v73 = v40;
      v71 = (uint64_t (**)())v39.i64[0];
      std::__split_buffer<MIDIInputPort::ConnectedSource>::~__split_buffer((uint64_t)&v71);
    }
    v41 = v12[4].i64[0];
    if (v41)
    {
      v69 = caulk::inplace_function<void ()(MIDI::LegacyPacketList const*),48ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<MIDIInputPort::AddConnectedSource(MIDISource *,void *)::$_0>;
      v70[0] = v41;
      v70[1] = a3;
      v42 = (_QWORD *)operator new();
      v71 = caulk::inplace_function<void ()(MIDI::LegacyPacketList const*),48ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<MIDIInputPort::AddConnectedSource(MIDISource *,void *)::$_0>;
      caulk::inplace_function_detail::vtable<void,MIDI::LegacyPacketList const*>::vtable<MIDIInputPort::AddConnectedSource(MIDISource *,void *)::$_0>(caulk::inplace_function_detail::wrapper<MIDIInputPort::AddConnectedSource(MIDISource *,void *)::$_0>)::{lambda(void *,void *)#1}::__invoke((__n128 *)&v72, (__n128 *)v70);
      v43 = (uint64_t)v71;
      v71 = (uint64_t (**)())&caulk::inplace_function_detail::vtable<void,MIDI::LegacyPacketList const*>::empty;
      *v42 = &off_1E98B9EC8;
      v42[1] = v43;
      (*(void (**)(_QWORD *, int64x2_t *))(v43 + 16))(v42 + 2, &v72);
      bzero(v42 + 8, 0x300uLL);
      ((void (*)(int64x2_t *))v71[3])(&v72);
      ((void (*)(_QWORD *))v69[3])(v70);
    }
    else
    {
      v42 = 0;
    }
    v44 = v12[4].i64[1];
    if (v44)
    {
      v45 = v12[3].i32[2];
      v71 = caulk::inplace_function<void ()(MIDI::EventList const*),48ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<MIDIInputPort::AddConnectedSource(MIDISource *,void *)::$_1>;
      v72.i64[0] = v44;
      v72.i64[1] = a3;
      MIDI::EventListDeliverer::create(&v65, v45, (uint64_t *)&v71);
      v46 = (_QWORD *)v65;
      v65 = 0;
      if (v42)
      {
        (*(void (**)(_QWORD *))(*v42 + 8))(v42);
        v65 = 0;
      }
      ((void (*)(int64x2_t *))v71[3])(&v72);
      v42 = v46;
    }
    v47 = v12[6].u64[0];
    v48 = (uint64_t *)v12[5].i64[1];
    if ((unint64_t)v48 >= v47)
    {
      v50 = v12[5].i64[0];
      v51 = ((uint64_t)v48 - v50) >> 4;
      v52 = v51 + 1;
      if ((unint64_t)(v51 + 1) >> 60)
        std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
      v53 = v47 - v50;
      if (v53 >> 3 > v52)
        v52 = v53 >> 3;
      if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFF0)
        v54 = 0xFFFFFFFFFFFFFFFLL;
      else
        v54 = v52;
      v68 = v12 + 6;
      if (v54 >> 60)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v55 = (char *)operator new(16 * v54);
      v56 = (uint64_t *)&v55[16 * v51];
      *v56 = v10;
      v56[1] = (uint64_t)v42;
      v58 = v12[5].i64[0];
      v57 = v12[5].u64[1];
      if (v57 == v58)
      {
        v62 = vdupq_n_s64(v57);
        v59 = &v55[16 * v51];
      }
      else
      {
        v59 = &v55[16 * v51];
        do
        {
          v60 = *(_QWORD *)(v57 - 16);
          v57 -= 16;
          *((_QWORD *)v59 - 2) = v60;
          v59 -= 16;
          v61 = *(_QWORD *)(v57 + 8);
          *(_QWORD *)(v57 + 8) = 0;
          *((_QWORD *)v59 + 1) = v61;
        }
        while (v57 != v58);
        v62 = v12[5];
      }
      v49 = v56 + 2;
      v12[5].i64[0] = (uint64_t)v59;
      v12[5].i64[1] = (uint64_t)(v56 + 2);
      v66 = v62;
      v63 = v12[6].i64[0];
      v12[6].i64[0] = (uint64_t)&v55[16 * v54];
      v67 = v63;
      v65 = v62.i64[0];
      std::__split_buffer<MIDIInputPort::ConnectedSource>::~__split_buffer((uint64_t)&v65);
    }
    else
    {
      *v48 = v10;
      v48[1] = (uint64_t)v42;
      v49 = v48 + 2;
    }
    v12[5].i64[1] = (uint64_t)v49;
    if (*(_QWORD *)(v10 + 104) - *(_QWORD *)(v10 + 96) == 8)
    {
      v64 = *(_QWORD *)(v10 + 56);
      if (v64)
        (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v64 + 112))(v64, *(unsigned int *)(v10 + 8), 1);
    }
  }
  if (v14)
    (*(void (**)(uint64_t *))(*v13 + 24))(v13);
  v20 = 0;
LABEL_13:
  if (v7)
    (*(void (**)(uint64_t *))(*v6 + 24))(v6);
  return v20;
}

void sub_1D4EB7F9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

void sub_1D4EB8090(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  uint64_t v9;
  int v10;

  if (a2)
  {
    if (v10)
      (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
    if (a2 == 3)
    {
      __cxa_begin_catch(a1);
      __cxa_end_catch();
    }
    else
    {
      if (a2 == 2)
      {
        __cxa_get_exception_ptr(a1);
        a9 = MEMORY[0x1E0DE5050] + 16;
        __cxa_begin_catch(a1);
        std::exception::~exception((std::exception *)&a9);
      }
      else
      {
        __cxa_begin_catch(a1);
      }
      __cxa_end_catch();
    }
    JUMPOUT(0x1D4EB7BD0);
  }
  JUMPOUT(0x1D4EB8078);
}

void sub_1D4EB80B8(uint64_t a1, int a2)
{
  if (a2)
    JUMPOUT(0x1D4EB80C4);
  JUMPOUT(0x1D4EB8078);
}

void sub_1D4EB8130()
{
  JUMPOUT(0x1D4EB8078);
}

uint64_t _MIDIPortDisconnectSource(MIDIServer *a1, int a2)
{
  int v3;
  uint64_t *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  MIDIInputPort ***v8;
  MIDIInputPort *v9;
  uint64_t v10;

  v3 = (int)a1;
  v4 = MIDIServer::defaultInstance(a1) + 2;
  v5 = (*(uint64_t (**)(uint64_t *))(*v4 + 16))(v4);
  v6 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIPort>::sRTTI, v3);
  if (v6)
  {
    v7 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIEndpoint>::sRTTI, a2);
    if (v7)
    {
      v8 = (MIDIInputPort ***)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 80))(v7);
      if (!v8)
      {
        v10 = 4294956464;
        if (!v5)
          return v10;
        goto LABEL_8;
      }
      v9 = (MIDIInputPort *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 80))(v6);
      if (v9)
      {
        v10 = MIDISource::DisconnectPort(v8, v9);
        if (!v5)
          return v10;
        goto LABEL_8;
      }
    }
  }
  v10 = 4294967246;
  if (v5)
LABEL_8:
    (*(void (**)(uint64_t *))(*v4 + 24))(v4);
  return v10;
}

void sub_1D4EB8218(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  int v11;

  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 3)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
  }
  else
  {
    if (a2 == 2)
    {
      __cxa_get_exception_ptr(a1);
      a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
      __cxa_begin_catch(a1);
      std::exception::~exception(&a10);
    }
    else
    {
      __cxa_begin_catch(a1);
    }
    __cxa_end_catch();
  }
  JUMPOUT(0x1D4EB81F4);
}

uint64_t _MIDISetupCreate(MIDIServer *a1)
{
  uint64_t *v2;
  int v3;
  MIDIServer *v4;
  uint64_t *v5;
  MIDISetup *v6;
  MIDIServer *v7;
  int v8;

  v2 = MIDIServer::defaultInstance(a1) + 2;
  v3 = (*(uint64_t (**)(uint64_t *))(*v2 + 16))(v2);
  Scheduler::FlushAllOutput((Scheduler *)gScheduler);
  v5 = MIDIServer::defaultInstance(v4);
  MIDIDriverMgr::StopMIDI((MIDIDriverMgr *)v5[33]);
  v6 = (MIDISetup *)operator new();
  MIDISetup::MIDISetup(v6);
  MIDISetup::ScanForDriverDevices(v6);
  MIDIServer::startMIDI(v7, v8);
  *(_DWORD *)a1 = *((_DWORD *)v6 + 2);
  if (v3)
    (*(void (**)(uint64_t *))(*v2 + 24))(v2);
  return 0;
}

void sub_1D4EB8374(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;

  v13 = v12;
  MEMORY[0x1D826BA98](v13, 0x10E1C4053490D92);
  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 3)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
  }
  else
  {
    if (a2 == 2)
    {
      __cxa_get_exception_ptr(a1);
      a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
      __cxa_begin_catch(a1);
      std::exception::~exception(&a10);
    }
    else
    {
      __cxa_begin_catch(a1);
    }
    __cxa_end_catch();
  }
  JUMPOUT(0x1D4EB8358);
}

uint64_t _MIDISetupInstall(MIDIServer *a1)
{
  int v1;
  uint64_t *v2;
  int v3;
  SetupManager *v4;
  MIDISetup *v5;
  SetupManager *v6;

  v1 = (int)a1;
  v2 = MIDIServer::defaultInstance(a1) + 2;
  v3 = (*(uint64_t (**)(uint64_t *))(*v2 + 16))(v2);
  v4 = (SetupManager *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDISetup>::sRTTI, v1);
  v5 = v4;
  if (v4)
  {
    v6 = (SetupManager *)SetupManager::instance(v4);
    SetupManager::Install(v6, v5, 0);
  }
  if (v3)
    (*(void (**)(uint64_t *))(*v2 + 24))(v2);
  if (v5)
    return 0;
  else
    return 4294967246;
}

uint64_t _MIDISetupGetCurrent(MIDIServer *a1)
{
  uint64_t *v2;
  SetupManager *v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  char v7;

  v2 = MIDIServer::defaultInstance(a1) + 2;
  v3 = (SetupManager *)(*(uint64_t (**)(uint64_t *))(*v2 + 16))(v2);
  v4 = (int)v3;
  if (a1)
  {
    v5 = SetupManager::instance(v3);
    if (*(_QWORD *)v5)
    {
      *(_DWORD *)a1 = *(_DWORD *)(*(_QWORD *)v5 + 8);
      v6 = 4294956459;
      v7 = 1;
      if (!v4)
        goto LABEL_9;
    }
    else
    {
      v7 = 0;
      v6 = 4294956459;
      if (!v4)
        goto LABEL_9;
    }
LABEL_8:
    (*(void (**)(uint64_t *))(*v2 + 24))(v2);
    goto LABEL_9;
  }
  v7 = 0;
  v6 = 4294967246;
  if ((_DWORD)v3)
    goto LABEL_8;
LABEL_9:
  if ((v7 & 1) != 0)
    return 0;
  return v6;
}

void sub_1D4EB8610(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  int v11;

  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 3)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
  }
  else
  {
    if (a2 == 2)
    {
      __cxa_get_exception_ptr(a1);
      a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
      __cxa_begin_catch(a1);
      std::exception::~exception(&a10);
    }
    else
    {
      __cxa_begin_catch(a1);
    }
    __cxa_end_catch();
  }
  JUMPOUT(0x1D4EB85F4);
}

uint64_t _MIDISetupFromData(MIDIServer *a1, _DWORD *a2)
{
  uint64_t *v4;
  int v5;
  int v6;
  BOOL v7;
  char v8;
  MIDISetup *v9;
  uint64_t v10;
  int v11;

  v4 = MIDIServer::defaultInstance(a1) + 2;
  v5 = (*(uint64_t (**)(uint64_t *))(*v4 + 16))(v4);
  v6 = v5;
  if (a1)
    v7 = a2 == 0;
  else
    v7 = 1;
  v8 = !v7;
  if (!v7)
  {
    v9 = (MIDISetup *)operator new();
    MIDISetup::MIDISetup(v9);
    v10 = MIDISetup::FromData(v9, a1);
    if ((_DWORD)v10)
    {
      (*(void (**)(MIDISetup *))(*(_QWORD *)v9 + 8))(v9);
      v11 = 0;
    }
    else
    {
      v11 = *((_DWORD *)v9 + 2);
    }
    *a2 = v11;
    if (!v6)
      goto LABEL_15;
    goto LABEL_14;
  }
  v10 = 0;
  if (v5)
LABEL_14:
    (*(void (**)(uint64_t *))(*v4 + 24))(v4);
LABEL_15:
  if ((v8 & 1) == 0)
    return 4294967246;
  return v10;
}

void sub_1D4EB8790(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  int v11;
  uint64_t v12;

  MEMORY[0x1D826BA98](v12, 0x10E1C4053490D92);
  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
    __cxa_begin_catch(a1);
    std::exception::~exception(&a10);
    __cxa_end_catch();
    JUMPOUT(0x1D4EB876CLL);
  }
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EB8770);
}

uint64_t _MIDIGetNumberOfDevices(MIDIServer *a1)
{
  uint64_t *v1;
  SetupManager *v2;
  int v3;
  uint64_t v4;
  MIDIObject **v5;
  MIDIObject **v6;
  uint64_t v7;
  MIDIObject *v8;
  int v10;

  v1 = MIDIServer::defaultInstance(a1) + 2;
  v2 = (SetupManager *)(*(uint64_t (**)(uint64_t *))(*v1 + 16))(v1);
  v3 = (int)v2;
  v4 = *(_QWORD *)SetupManager::instance(v2);
  if (!v4 || (v5 = *(MIDIObject ***)(v4 + 64), v6 = *(MIDIObject ***)(v4 + 72), v5 == v6))
  {
    v7 = 0;
    if (!v3)
      return v7;
LABEL_10:
    (*(void (**)(uint64_t *))(*v1 + 24))(v1);
    return v7;
  }
  v7 = 0;
  do
  {
    v8 = *v5;
    v10 = 0;
    MIDIObject::GetIntegerProperty(v8, kMIDIPropertyPrivate, &v10);
    if (!v10)
      ++v7;
    ++v5;
  }
  while (v5 != v6);
  if (v3)
    goto LABEL_10;
  return v7;
}

void sub_1D4EB890C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  uint64_t v9;
  int v10;

  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a9 = MEMORY[0x1E0DE5050] + 16;
    __cxa_begin_catch(a1);
    std::exception::~exception((std::exception *)&a9);
  }
  else
  {
    __cxa_begin_catch(a1);
  }
  __cxa_end_catch();
  JUMPOUT(0x1D4EB88ECLL);
}

uint64_t _MIDIGetDevice(MIDIServer *a1)
{
  MIDIServer *v1;
  uint64_t *v2;
  SetupManager *v3;
  int v4;
  uint64_t v5;
  unsigned int **v6;
  unsigned int **v7;
  unsigned int *v8;
  uint64_t v9;
  int v11;

  v1 = a1;
  v2 = MIDIServer::defaultInstance(a1) + 2;
  v3 = (SetupManager *)(*(uint64_t (**)(uint64_t *))(*v2 + 16))(v2);
  v4 = (int)v3;
  v5 = SetupManager::instance(v3);
  v6 = *(unsigned int ***)(*(_QWORD *)v5 + 64);
  v7 = *(unsigned int ***)(*(_QWORD *)v5 + 72);
  if (v6 == v7)
    goto LABEL_6;
  while (1)
  {
    v8 = *v6;
    v11 = 0;
    MIDIObject::GetIntegerProperty((MIDIObject *)v8, kMIDIPropertyPrivate, &v11);
    if (!v11)
      break;
LABEL_5:
    if (++v6 == v7)
      goto LABEL_6;
  }
  if (v1)
  {
    v1 = (MIDIServer *)((char *)v1 - 1);
    goto LABEL_5;
  }
  if (!v8)
  {
LABEL_6:
    v9 = 0;
    if (v4)
      goto LABEL_7;
    return v9;
  }
  v9 = v8[2];
  if (!v4)
    return v9;
LABEL_7:
  (*(void (**)(uint64_t *))(*v2 + 24))(v2);
  return v9;
}

void sub_1D4EB8A64(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  uint64_t v9;
  int v10;

  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a9 = MEMORY[0x1E0DE5050] + 16;
    __cxa_begin_catch(a1);
    std::exception::~exception((std::exception *)&a9);
  }
  else
  {
    __cxa_begin_catch(a1);
  }
  __cxa_end_catch();
  JUMPOUT(0x1D4EB8A30);
}

uint64_t _MIDIGetNumberOfSources(MIDIServer *a1)
{
  uint64_t *v1;
  SetupManager *v2;
  int v3;
  SetupManager *IntegerProperty;
  uint64_t v5;
  MIDIObject **v6;
  MIDIObject **v7;
  uint64_t v8;
  MIDIObject *v9;
  uint64_t v10;
  uint64_t v11;
  MIDIObject **v12;
  MIDIObject **v13;
  uint64_t v14;
  MIDIObject *v15;
  int v17;

  v1 = MIDIServer::defaultInstance(a1) + 2;
  v2 = (SetupManager *)(*(uint64_t (**)(uint64_t *))(*v1 + 16))(v1);
  v3 = (int)v2;
  IntegerProperty = (SetupManager *)SetupManager::instance(v2);
  v5 = *(_QWORD *)IntegerProperty;
  if (!*(_QWORD *)IntegerProperty)
  {
    v10 = 0;
    if (!v3)
      return v10;
    goto LABEL_21;
  }
  v6 = *(MIDIObject ***)(v5 + 88);
  v7 = *(MIDIObject ***)(v5 + 96);
  if (v6 == v7)
  {
    v8 = 0;
  }
  else
  {
    v8 = 0;
    do
    {
      v9 = *v6;
      v17 = 0;
      IntegerProperty = (SetupManager *)MIDIObject::GetIntegerProperty(v9, kMIDIPropertyOffline, &v17);
      if (!v17)
      {
        v17 = 0;
        IntegerProperty = (SetupManager *)MIDIObject::GetIntegerProperty(v9, kMIDIPropertyPrivate, &v17);
        if (!v17)
          ++v8;
      }
      ++v6;
    }
    while (v6 != v7);
  }
  v11 = SetupManager::instance(IntegerProperty);
  v12 = *(MIDIObject ***)(v11 + 8);
  v13 = *(MIDIObject ***)(v11 + 16);
  if (v12 == v13)
  {
    v14 = 0;
  }
  else
  {
    v14 = 0;
    do
    {
      v15 = *v12;
      v17 = 0;
      MIDIObject::GetIntegerProperty(v15, kMIDIPropertyOffline, &v17);
      if (!v17)
      {
        v17 = 0;
        MIDIObject::GetIntegerProperty(v15, kMIDIPropertyPrivate, &v17);
        if (!v17)
          ++v14;
      }
      ++v12;
    }
    while (v12 != v13);
  }
  v10 = v14 + v8;
  if (v3)
LABEL_21:
    (*(void (**)(uint64_t *))(*v1 + 24))(v1);
  return v10;
}

void sub_1D4EB8C5C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  uint64_t v9;
  int v10;

  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a9 = MEMORY[0x1E0DE5050] + 16;
    __cxa_begin_catch(a1);
    std::exception::~exception((std::exception *)&a9);
  }
  else
  {
    __cxa_begin_catch(a1);
  }
  __cxa_end_catch();
  JUMPOUT(0x1D4EB8C34);
}

uint64_t _MIDIGetSource(MIDIServer *a1)
{
  uint64_t v1;
  uint64_t *v2;
  SetupManager *v3;
  int v4;
  SetupManager *IntegerProperty;
  unsigned int **v6;
  unsigned int **v7;
  unsigned int *v8;
  uint64_t v9;
  unsigned int **v10;
  unsigned int **v11;
  uint64_t v12;
  int v14;

  v1 = (uint64_t)a1;
  v2 = MIDIServer::defaultInstance(a1) + 2;
  v3 = (SetupManager *)(*(uint64_t (**)(uint64_t *))(*v2 + 16))(v2);
  v4 = (int)v3;
  IntegerProperty = (SetupManager *)SetupManager::instance(v3);
  v6 = *(unsigned int ***)(*(_QWORD *)IntegerProperty + 88);
  v7 = *(unsigned int ***)(*(_QWORD *)IntegerProperty + 96);
  while (1)
  {
    if (v6 == v7)
      goto LABEL_10;
    v8 = *v6;
    v14 = 0;
    IntegerProperty = (SetupManager *)MIDIObject::GetIntegerProperty((MIDIObject *)v8, kMIDIPropertyOffline, &v14);
    if (!v14)
    {
      v14 = 0;
      IntegerProperty = (SetupManager *)MIDIObject::GetIntegerProperty((MIDIObject *)v8, kMIDIPropertyPrivate, &v14);
      if (!v14)
        break;
    }
LABEL_7:
    ++v6;
  }
  if (v1)
  {
    --v1;
    goto LABEL_7;
  }
  if (v8)
  {
LABEL_18:
    v12 = v8[2];
    if (!v4)
      return v12;
    goto LABEL_21;
  }
  v1 = -1;
LABEL_10:
  v9 = SetupManager::instance(IntegerProperty);
  v10 = *(unsigned int ***)(v9 + 8);
  v11 = *(unsigned int ***)(v9 + 16);
  while (v10 != v11)
  {
    v8 = *v10;
    v14 = 0;
    MIDIObject::GetIntegerProperty((MIDIObject *)v8, kMIDIPropertyOffline, &v14);
    if (!v14)
    {
      v14 = 0;
      MIDIObject::GetIntegerProperty((MIDIObject *)v8, kMIDIPropertyPrivate, &v14);
      if (!v14)
      {
        if (!v1)
        {
          if (v8)
            goto LABEL_18;
          break;
        }
        --v1;
      }
    }
    ++v10;
  }
  v12 = 0;
  if (v4)
LABEL_21:
    (*(void (**)(uint64_t *))(*v2 + 24))(v2);
  return v12;
}

void sub_1D4EB8E44(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  uint64_t v9;
  int v10;

  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a9 = MEMORY[0x1E0DE5050] + 16;
    __cxa_begin_catch(a1);
    std::exception::~exception((std::exception *)&a9);
  }
  else
  {
    __cxa_begin_catch(a1);
  }
  __cxa_end_catch();
  JUMPOUT(0x1D4EB8E20);
}

uint64_t _MIDIGetNumberOfDestinations(MIDIServer *a1)
{
  uint64_t *v1;
  SetupManager *v2;
  int v3;
  SetupManager *IntegerProperty;
  uint64_t v5;
  MIDIObject **v6;
  MIDIObject **v7;
  uint64_t v8;
  MIDIObject *v9;
  uint64_t v10;
  uint64_t v11;
  MIDIObject **v12;
  MIDIObject **v13;
  uint64_t v14;
  MIDIObject *v15;
  int v17;

  v1 = MIDIServer::defaultInstance(a1) + 2;
  v2 = (SetupManager *)(*(uint64_t (**)(uint64_t *))(*v1 + 16))(v1);
  v3 = (int)v2;
  IntegerProperty = (SetupManager *)SetupManager::instance(v2);
  v5 = *(_QWORD *)IntegerProperty;
  if (!*(_QWORD *)IntegerProperty)
  {
    v10 = 0;
    if (!v3)
      return v10;
    goto LABEL_21;
  }
  v6 = *(MIDIObject ***)(v5 + 112);
  v7 = *(MIDIObject ***)(v5 + 120);
  if (v6 == v7)
  {
    v8 = 0;
  }
  else
  {
    v8 = 0;
    do
    {
      v9 = *v6;
      v17 = 0;
      IntegerProperty = (SetupManager *)MIDIObject::GetIntegerProperty(v9, kMIDIPropertyOffline, &v17);
      if (!v17)
      {
        v17 = 0;
        IntegerProperty = (SetupManager *)MIDIObject::GetIntegerProperty(v9, kMIDIPropertyPrivate, &v17);
        if (!v17)
          ++v8;
      }
      ++v6;
    }
    while (v6 != v7);
  }
  v11 = SetupManager::instance(IntegerProperty);
  v12 = *(MIDIObject ***)(v11 + 32);
  v13 = *(MIDIObject ***)(v11 + 40);
  if (v12 == v13)
  {
    v14 = 0;
  }
  else
  {
    v14 = 0;
    do
    {
      v15 = *v12;
      v17 = 0;
      MIDIObject::GetIntegerProperty(v15, kMIDIPropertyOffline, &v17);
      if (!v17)
      {
        v17 = 0;
        MIDIObject::GetIntegerProperty(v15, kMIDIPropertyPrivate, &v17);
        if (!v17)
          ++v14;
      }
      ++v12;
    }
    while (v12 != v13);
  }
  v10 = v14 + v8;
  if (v3)
LABEL_21:
    (*(void (**)(uint64_t *))(*v1 + 24))(v1);
  return v10;
}

void sub_1D4EB9044(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  uint64_t v9;
  int v10;

  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a9 = MEMORY[0x1E0DE5050] + 16;
    __cxa_begin_catch(a1);
    std::exception::~exception((std::exception *)&a9);
  }
  else
  {
    __cxa_begin_catch(a1);
  }
  __cxa_end_catch();
  JUMPOUT(0x1D4EB901CLL);
}

uint64_t _MIDIGetDestination(MIDIServer *a1)
{
  uint64_t v1;
  uint64_t *v2;
  SetupManager *v3;
  int v4;
  SetupManager *IntegerProperty;
  unsigned int **v6;
  unsigned int **v7;
  unsigned int *v8;
  uint64_t v9;
  unsigned int **v10;
  unsigned int **v11;
  uint64_t v12;
  int v14;

  v1 = (uint64_t)a1;
  v2 = MIDIServer::defaultInstance(a1) + 2;
  v3 = (SetupManager *)(*(uint64_t (**)(uint64_t *))(*v2 + 16))(v2);
  v4 = (int)v3;
  IntegerProperty = (SetupManager *)SetupManager::instance(v3);
  v6 = *(unsigned int ***)(*(_QWORD *)IntegerProperty + 112);
  v7 = *(unsigned int ***)(*(_QWORD *)IntegerProperty + 120);
  while (1)
  {
    if (v6 == v7)
      goto LABEL_10;
    v8 = *v6;
    v14 = 0;
    IntegerProperty = (SetupManager *)MIDIObject::GetIntegerProperty((MIDIObject *)v8, kMIDIPropertyOffline, &v14);
    if (!v14)
    {
      v14 = 0;
      IntegerProperty = (SetupManager *)MIDIObject::GetIntegerProperty((MIDIObject *)v8, kMIDIPropertyPrivate, &v14);
      if (!v14)
        break;
    }
LABEL_7:
    ++v6;
  }
  if (v1)
  {
    --v1;
    goto LABEL_7;
  }
  if (v8)
  {
LABEL_18:
    v12 = v8[2];
    if (!v4)
      return v12;
    goto LABEL_21;
  }
  v1 = -1;
LABEL_10:
  v9 = SetupManager::instance(IntegerProperty);
  v10 = *(unsigned int ***)(v9 + 32);
  v11 = *(unsigned int ***)(v9 + 40);
  while (v10 != v11)
  {
    v8 = *v10;
    v14 = 0;
    MIDIObject::GetIntegerProperty((MIDIObject *)v8, kMIDIPropertyOffline, &v14);
    if (!v14)
    {
      v14 = 0;
      MIDIObject::GetIntegerProperty((MIDIObject *)v8, kMIDIPropertyPrivate, &v14);
      if (!v14)
      {
        if (!v1)
        {
          if (v8)
            goto LABEL_18;
          break;
        }
        --v1;
      }
    }
    ++v10;
  }
  v12 = 0;
  if (v4)
LABEL_21:
    (*(void (**)(uint64_t *))(*v2 + 24))(v2);
  return v12;
}

void sub_1D4EB922C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  uint64_t v9;
  int v10;

  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a9 = MEMORY[0x1E0DE5050] + 16;
    __cxa_begin_catch(a1);
    std::exception::~exception((std::exception *)&a9);
  }
  else
  {
    __cxa_begin_catch(a1);
  }
  __cxa_end_catch();
  JUMPOUT(0x1D4EB9208);
}

uint64_t _MIDIGetNumberOfExternalDevices(MIDIServer *a1)
{
  uint64_t *v1;
  SetupManager *v2;
  int v3;
  uint64_t v4;
  MIDIObject **v5;
  MIDIObject **v6;
  uint64_t v7;
  MIDIObject *v8;
  int v10;

  v1 = MIDIServer::defaultInstance(a1) + 2;
  v2 = (SetupManager *)(*(uint64_t (**)(uint64_t *))(*v1 + 16))(v1);
  v3 = (int)v2;
  v4 = *(_QWORD *)SetupManager::instance(v2);
  if (!v4 || (v5 = *(MIDIObject ***)(v4 + 152), v6 = *(MIDIObject ***)(v4 + 160), v5 == v6))
  {
    v7 = 0;
    if (!v3)
      return v7;
LABEL_10:
    (*(void (**)(uint64_t *))(*v1 + 24))(v1);
    return v7;
  }
  v7 = 0;
  do
  {
    v8 = *v5;
    v10 = 0;
    MIDIObject::GetIntegerProperty(v8, kMIDIPropertyPrivate, &v10);
    if (!v10)
      ++v7;
    ++v5;
  }
  while (v5 != v6);
  if (v3)
    goto LABEL_10;
  return v7;
}

void sub_1D4EB9378(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  uint64_t v9;
  int v10;

  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a9 = MEMORY[0x1E0DE5050] + 16;
    __cxa_begin_catch(a1);
    std::exception::~exception((std::exception *)&a9);
  }
  else
  {
    __cxa_begin_catch(a1);
  }
  __cxa_end_catch();
  JUMPOUT(0x1D4EB9358);
}

uint64_t _MIDIGetExternalDevice(MIDIServer *a1)
{
  MIDIServer *v1;
  uint64_t *v2;
  SetupManager *v3;
  int v4;
  uint64_t v5;
  unsigned int **v6;
  unsigned int **v7;
  unsigned int *v8;
  uint64_t v9;
  int v11;

  v1 = a1;
  v2 = MIDIServer::defaultInstance(a1) + 2;
  v3 = (SetupManager *)(*(uint64_t (**)(uint64_t *))(*v2 + 16))(v2);
  v4 = (int)v3;
  v5 = SetupManager::instance(v3);
  v6 = *(unsigned int ***)(*(_QWORD *)v5 + 152);
  v7 = *(unsigned int ***)(*(_QWORD *)v5 + 160);
  if (v6 == v7)
    goto LABEL_6;
  while (1)
  {
    v8 = *v6;
    v11 = 0;
    MIDIObject::GetIntegerProperty((MIDIObject *)v8, kMIDIPropertyPrivate, &v11);
    if (!v11)
      break;
LABEL_5:
    if (++v6 == v7)
      goto LABEL_6;
  }
  if (v1)
  {
    v1 = (MIDIServer *)((char *)v1 - 1);
    goto LABEL_5;
  }
  if (!v8)
  {
LABEL_6:
    v9 = 0;
    if (v4)
      goto LABEL_7;
    return v9;
  }
  v9 = v8[2];
  if (!v4)
    return v9;
LABEL_7:
  (*(void (**)(uint64_t *))(*v2 + 24))(v2);
  return v9;
}

void sub_1D4EB94D0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  uint64_t v9;
  int v10;

  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a9 = MEMORY[0x1E0DE5050] + 16;
    __cxa_begin_catch(a1);
    std::exception::~exception((std::exception *)&a9);
  }
  else
  {
    __cxa_begin_catch(a1);
  }
  __cxa_end_catch();
  JUMPOUT(0x1D4EB949CLL);
}

uint64_t _MIDISend(MIDIServer *a1, int a2, const MIDI::EventList *a3)
{
  int v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;

  v5 = (int)a1;
  v6 = MIDIServer::defaultInstance(a1, a2) + 104;
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 16))(v6);
  v8 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIEndpoint>::sRTTI, a2);
  if (v8)
  {
    v9 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 88))(v8);
    if (!v9)
    {
      v12 = 4294956464;
      if (!v7)
        return v12;
      goto LABEL_10;
    }
    v10 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIPort>::sRTTI, v5);
    if (v10)
    {
      v11 = (void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 88))(v10);
      if (v11)
      {
        MIDIDestination::SendPacketList(v9, v11, a3);
        v12 = 0;
        if (!v7)
          return v12;
        goto LABEL_10;
      }
    }
  }
  v12 = 4294967246;
  if (v7)
LABEL_10:
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
  return v12;
}

void sub_1D4EB96B4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  int v2;

  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

uint64_t _MIDIReceived(MIDIServer *a1, MIDIEventPacket *a2)
{
  int v3;
  uint64_t *v4;
  int v5;
  uint64_t v6;
  MIDISource *v7;
  uint64_t v8;

  v3 = (int)a1;
  v4 = MIDIServer::defaultInstance(a1) + 13;
  v5 = (*(uint64_t (**)(uint64_t *))(*v4 + 16))(v4);
  v6 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIEndpoint>::sRTTI, v3);
  if (v6)
  {
    v7 = (MIDISource *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 80))(v6);
    if (v7)
    {
      v8 = MIDISource::ReceivedPacketList(v7, a2);
      if (!v5)
        return v8;
    }
    else
    {
      v8 = 4294956464;
      if (!v5)
        return v8;
    }
    goto LABEL_8;
  }
  v8 = 4294967246;
  if (v5)
LABEL_8:
    (*(void (**)(uint64_t *))(*v4 + 24))(v4);
  return v8;
}

void sub_1D4EB9800(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  int v2;

  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

uint64_t _MIDIFlushOutput(int a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  MIDIServer *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD v11[35];

  if (a1)
  {
    Scheduler::FlushEndpoint((Scheduler *)gScheduler, a1);
    v2 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIEndpoint>::sRTTI, a1);
    if (!v2)
      return 4294967246;
    v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 88))(v2);
    if (!v3)
      return 4294956464;
    v4 = *(_QWORD *)(v3 + 56);
    if (v4 && *(int *)(v3 + 868) >= 1)
    {
      (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v4 + 120))(*(_QWORD *)(v3 + 56), *(unsigned int *)(v3 + 8), *(_QWORD *)(v3 + 72), *(_QWORD *)(v3 + 80));
    }
    else if (*(_QWORD *)(v3 + 48))
    {
      v11[0] = 0x100000001;
      v11[1] = 0;
      v11[2] = 0x10FF000000000001;
      MIDIDestination::DeliverPacketsToDestination((MIDIDestination *)v3, (const MIDI::EventList *)v11);
    }
  }
  else
  {
    Scheduler::FlushAllOutput((Scheduler *)gScheduler);
    v6 = MIDIServer::defaultInstance(v5)[33];
    if (*(_BYTE *)v6)
    {
      v7 = *(_QWORD **)(v6 + 16);
      v8 = *(_QWORD **)(v6 + 24);
      while (v7 != v8)
      {
        (*(void (**)(_QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)*v7 + 120))(*v7, 0, 0, 0);
        ++v7;
      }
    }
  }
  return 0;
}

uint64_t _MIDIDestinationCreate(MIDIServer *a1, const __CFString *a2, MIDIProtocolID a3, _DWORD *a4, const void *a5, const void *a6)
{
  int v11;
  uint64_t *v12;
  int v13;
  unsigned int *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  SetupManager *v25;
  MIDISetup **v26;
  MIDISetup **v27;
  unint64_t v28;
  uint64_t *v29;
  MIDISetup *v30;
  MIDISetup *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  unint64_t v39;
  MIDISetup *v40;
  MIDISetup *v41;
  uint64_t v42;
  MIDISetup *v43;
  MIDIConnection **v44;
  int v46;
  const char *v47;
  __int16 v48;
  int v49;
  __int16 v50;
  uint64_t v51;
  __int16 v52;
  uint64_t v53;
  __int16 v54;
  const __CFString *v55;
  __int16 v56;
  MIDIProtocolID v57;
  __int16 v58;
  const void *v59;
  __int16 v60;
  const void *v61;
  uint64_t v62;

  v11 = (int)a1;
  v62 = *MEMORY[0x1E0C80C00];
  v12 = MIDIServer::defaultInstance(a1) + 2;
  v13 = (*(uint64_t (**)(uint64_t *))(*v12 + 16))(v12);
  v14 = (unsigned int *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIClient>::sRTTI, v11);
  if (v14)
  {
    v15 = operator new();
    MIDIEndpoint::MIDIEndpoint((MIDIEndpoint *)v15, (MIDIClient *)v14, 0, 0, a3, a2);
    v16 = 0;
    *(_QWORD *)v15 = &off_1E98B9870;
    do
    {
      v17 = v15 + v16;
      *(_DWORD *)(v17 + 96) = 0;
      *(_QWORD *)(v17 + 104) = 0;
      *(_QWORD *)(v17 + 112) = 0;
      v16 += 24;
    }
    while (v16 != 384);
    v18 = -384;
    v19 = 0uLL;
    do
    {
      *(_QWORD *)&v20 = v15 + v18 + 864;
      *((_QWORD *)&v20 + 1) = v15 + v18 + 888;
      v21 = v20;
      vst3q_f64((double *)v20, *(float64x2x3_t *)(&v19 - 2));
      v18 += 48;
    }
    while (v18);
    *(_DWORD *)(v15 + 864) = 3125;
    *(_DWORD *)(v15 + 892) = 0;
    *(_QWORD *)(v15 + 876) = 0;
    *(_QWORD *)(v15 + 884) = 0;
    *(_QWORD *)(v15 + 868) = 0;
    gMIDIDeviceTableLog();
    v22 = gMIDIDeviceTableLog(void)::dtable;
    if (os_log_type_enabled((os_log_t)gMIDIDeviceTableLog(void)::dtable, OS_LOG_TYPE_DEBUG))
    {
      v23 = *(unsigned int *)(v15 + 8);
      v24 = v14[2];
      v46 = 136316930;
      v47 = "DeviceTable.cpp";
      v48 = 1024;
      v49 = 993;
      v50 = 2048;
      v51 = v23;
      v52 = 2048;
      v53 = v24;
      v54 = 2112;
      v55 = a2;
      v56 = 1024;
      v57 = a3;
      v58 = 2048;
      v59 = a5;
      v60 = 2048;
      v61 = a6;
      _os_log_impl(&dword_1D4E88000, v22, OS_LOG_TYPE_DEBUG, "%25s:%-5d [*] MIDIDestination(ref 0x%lx)::MIDIDestination() - clientRef:0x%lx name:%@ protocol:%d readBlock:%p receiveBlock:%p", (uint8_t *)&v46, 0x4Au);
    }
    *(_QWORD *)(v15 + 880) = _Block_copy(a5);
    *(_QWORD *)(v15 + 888) = _Block_copy(a6);
    v25 = (SetupManager *)MIDIDestination::Init(v15);
    v26 = (MIDISetup **)SetupManager::instance(v25);
    v27 = v26;
    v29 = (uint64_t *)v26[5];
    v28 = (unint64_t)v26[6];
    if ((unint64_t)v29 >= v28)
    {
      v32 = v26[4];
      v33 = ((char *)v29 - (char *)v32) >> 3;
      if ((unint64_t)(v33 + 1) >> 61)
        std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
      v34 = v28 - (_QWORD)v32;
      v35 = v34 >> 2;
      if (v34 >> 2 <= (unint64_t)(v33 + 1))
        v35 = v33 + 1;
      if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF8)
        v36 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v36 = v35;
      if (v36)
        v36 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v36);
      else
        v37 = 0;
      v38 = (uint64_t *)(v36 + 8 * v33);
      v39 = v36 + 8 * v37;
      *v38 = v15;
      v30 = (MIDISetup *)(v38 + 1);
      v41 = v27[4];
      v40 = v27[5];
      if (v40 != v41)
      {
        do
        {
          v42 = *((_QWORD *)v40 - 1);
          v40 = (MIDISetup *)((char *)v40 - 8);
          *--v38 = v42;
        }
        while (v40 != v41);
        v40 = v27[4];
      }
      v27[4] = (MIDISetup *)v38;
      v27[5] = v30;
      v27[6] = (MIDISetup *)v39;
      if (v40)
        operator delete(v40);
    }
    else
    {
      *v29 = v15;
      v30 = (MIDISetup *)(v29 + 1);
    }
    v27[5] = v30;
    if (*v27)
    {
      MIDISetup::AssignUniqueID(*v27, (MIDIObject *)v15);
      v43 = *v27;
      v44 = (MIDIConnection **)*((_QWORD *)*v27 + 23);
      if (v44 != *((MIDIConnection ***)*v27 + 24))
      {
        do
          MIDIConnection::MaintainEndpoints(*v44++, v43);
        while (v44 != *((MIDIConnection ***)v43 + 24));
        v43 = *v27;
      }
      MIDISetup::ObjectAdded(v43, (MIDIObject *)v15);
    }
    *a4 = *(_DWORD *)(v15 + 8);
    if (v13)
      (*(void (**)(uint64_t *))(*v12 + 24))(v12);
    return 0;
  }
  else
  {
    if (v13)
      (*(void (**)(uint64_t *))(*v12 + 24))(v12);
    return 4294967246;
  }
}

void sub_1D4EB9D14(_Unwind_Exception *exception_object, int a2)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

void sub_1D4EB9D30(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::exception a9)
{
  uint64_t v9;
  int v10;
  uint64_t v11;

  if (a2)
  {
    MEMORY[0x1D826BA98](v11, 0x10E1C402D25DFBCLL);
    if (v10)
      (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
    if (a2 != 2)
    {
      __cxa_begin_catch(a1);
      __cxa_end_catch();
      JUMPOUT(0x1D4EB9CCCLL);
    }
    __cxa_get_exception_ptr(a1);
    a9.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
    __cxa_begin_catch(a1);
    std::exception::~exception(&a9);
    __cxa_end_catch();
    JUMPOUT(0x1D4EB9BCCLL);
  }
  JUMPOUT(0x1D4EB9D20);
}

void sub_1D4EB9E60()
{
  JUMPOUT(0x1D4EB9D20);
}

uint64_t _MIDISourceCreate(MIDIServer *a1, const __CFString *a2, MIDIProtocolID a3, _DWORD *a4)
{
  int v7;
  uint64_t *v8;
  int v9;
  unsigned int *v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  MIDISetup **v17;
  MIDISetup **v18;
  unint64_t v19;
  uint64_t *v20;
  MIDISetup *v21;
  MIDISetup *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  unint64_t v29;
  MIDISetup *v30;
  MIDISetup *v31;
  uint64_t v32;
  MIDISetup *v33;
  MIDIConnection **v34;
  int v36;
  const char *v37;
  __int16 v38;
  int v39;
  __int16 v40;
  uint64_t v41;
  __int16 v42;
  uint64_t v43;
  __int16 v44;
  MIDIProtocolID v45;
  __int16 v46;
  const __CFString *v47;
  uint64_t v48;

  v7 = (int)a1;
  v48 = *MEMORY[0x1E0C80C00];
  v8 = MIDIServer::defaultInstance(a1) + 2;
  v9 = (*(uint64_t (**)(uint64_t *))(*v8 + 16))(v8);
  v10 = (unsigned int *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIClient>::sRTTI, v7);
  if (v10)
  {
    v11 = operator new();
    MIDIEndpoint::MIDIEndpoint((MIDIEndpoint *)v11, (MIDIClient *)v10, 0, 0, a3, a2);
    *(_QWORD *)v11 = &off_1E98B9380;
    *(_OWORD *)(v11 + 96) = 0u;
    *(_WORD *)(v11 + 160) = 0;
    *(_QWORD *)(v11 + 168) = 0;
    *(_WORD *)(v11 + 176) = 0;
    *(_OWORD *)(v11 + 112) = 0u;
    *(_OWORD *)(v11 + 128) = 0u;
    *(_QWORD *)(v11 + 144) = 0;
    gMIDIDeviceTableLog();
    v12 = gMIDIDeviceTableLog(void)::dtable;
    if (os_log_type_enabled((os_log_t)gMIDIDeviceTableLog(void)::dtable, OS_LOG_TYPE_DEBUG))
    {
      v13 = *(unsigned int *)(v11 + 8);
      v14 = v10[2];
      v36 = 136316418;
      v37 = "DeviceTable.cpp";
      v38 = 1024;
      v39 = 712;
      v40 = 2048;
      v41 = v13;
      v42 = 2048;
      v43 = v14;
      v44 = 1024;
      v45 = a3;
      v46 = 2112;
      v47 = a2;
      _os_log_impl(&dword_1D4E88000, v12, OS_LOG_TYPE_DEBUG, "%25s:%-5d MIDISource(ref 0x%lx)::MIDISource() - clientRef:0x%lx protocol:%d name:%@", (uint8_t *)&v36, 0x36u);
    }
    MIDISource::CreateCISniffer((uint64_t **)v11);
    if (*(_BYTE *)(v11 + 88))
    {
      v15 = operator new();
      *(_BYTE *)v15 = 0;
      *(_QWORD *)(v15 + 64) = 0;
      *(_OWORD *)(v15 + 16) = 0u;
      *(_OWORD *)(v15 + 32) = 0u;
      *(_OWORD *)(v15 + 44) = 0u;
    }
    else
    {
      v15 = 0;
    }
    *(_QWORD *)(v11 + 152) = v15;
    v17 = (MIDISetup **)SetupManager::instance((SetupManager *)v15);
    v18 = v17;
    v20 = (uint64_t *)v17[2];
    v19 = (unint64_t)v17[3];
    if ((unint64_t)v20 >= v19)
    {
      v22 = v17[1];
      v23 = ((char *)v20 - (char *)v22) >> 3;
      if ((unint64_t)(v23 + 1) >> 61)
        std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
      v24 = v19 - (_QWORD)v22;
      v25 = v24 >> 2;
      if (v24 >> 2 <= (unint64_t)(v23 + 1))
        v25 = v23 + 1;
      if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8)
        v26 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v26 = v25;
      if (v26)
        v26 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v26);
      else
        v27 = 0;
      v28 = (uint64_t *)(v26 + 8 * v23);
      v29 = v26 + 8 * v27;
      *v28 = v11;
      v21 = (MIDISetup *)(v28 + 1);
      v31 = v18[1];
      v30 = v18[2];
      if (v30 != v31)
      {
        do
        {
          v32 = *((_QWORD *)v30 - 1);
          v30 = (MIDISetup *)((char *)v30 - 8);
          *--v28 = v32;
        }
        while (v30 != v31);
        v30 = v18[1];
      }
      v18[1] = (MIDISetup *)v28;
      v18[2] = v21;
      v18[3] = (MIDISetup *)v29;
      if (v30)
        operator delete(v30);
    }
    else
    {
      *v20 = v11;
      v21 = (MIDISetup *)(v20 + 1);
    }
    v18[2] = v21;
    if (*v18)
    {
      MIDISetup::AssignUniqueID(*v18, (MIDIObject *)v11);
      v33 = *v18;
      v34 = (MIDIConnection **)*((_QWORD *)*v18 + 23);
      if (v34 != *((MIDIConnection ***)*v18 + 24))
      {
        do
          MIDIConnection::MaintainEndpoints(*v34++, v33);
        while (v34 != *((MIDIConnection ***)v33 + 24));
        v33 = *v18;
      }
      MIDISetup::ObjectAdded(v33, (MIDIObject *)v11);
    }
    *a4 = *(_DWORD *)(v11 + 8);
    if (v9)
      (*(void (**)(uint64_t *))(*v8 + 24))(v8);
    return 0;
  }
  else
  {
    if (v9)
      (*(void (**)(uint64_t *))(*v8 + 24))(v8);
    return 4294967246;
  }
}

void sub_1D4EBA19C(_Unwind_Exception *exception_object, int a2)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

void sub_1D4EBA1B8(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::exception a9)
{
  uint64_t v9;
  int v10;
  uint64_t v11;

  if (a2)
  {
    MEMORY[0x1D826BA98](v11, 0x10E1C406897E7BCLL);
    if (v10)
      (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
    if (a2 != 2)
    {
      __cxa_begin_catch(a1);
      __cxa_end_catch();
      JUMPOUT(0x1D4EBA154);
    }
    __cxa_get_exception_ptr(a1);
    a9.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
    __cxa_begin_catch(a1);
    std::exception::~exception(&a9);
    __cxa_end_catch();
    JUMPOUT(0x1D4EBA030);
  }
  JUMPOUT(0x1D4EBA1A8);
}

void sub_1D4EBA2FC()
{
  JUMPOUT(0x1D4EBA1A8);
}

uint64_t _MIDIEndpointDispose(MIDIServer *a1)
{
  int v1;
  uint64_t *v2;
  int v3;
  SetupManager *v4;
  MIDIObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  MIDIServer *v10;
  uint64_t *v11;
  int v12;

  v1 = (int)a1;
  v2 = MIDIServer::defaultInstance(a1) + 2;
  v3 = (*(uint64_t (**)(uint64_t *))(*v2 + 16))(v2);
  v4 = (SetupManager *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIEndpoint>::sRTTI, v1);
  v5 = v4;
  if (v4)
  {
    v6 = SetupManager::instance(v4);
    v7 = (*(uint64_t (**)(MIDIObject *))(*(_QWORD *)v5 + 80))(v5);
    if (v7)
    {
      remove<std::vector<MIDISource *>,MIDISource *>((_QWORD *)(v6 + 8), v7);
    }
    else
    {
      v9 = (*(uint64_t (**)(MIDIObject *))(*(_QWORD *)v5 + 88))(v5);
      if (v9)
        remove<std::vector<MIDISource *>,MIDISource *>((_QWORD *)(v6 + 32), v9);
    }
    MIDISetup::ObjectRemoved(*(MIDISetup **)v6, v5);
    v11 = MIDIServer::defaultInstance(v10) + 13;
    v12 = (*(uint64_t (**)(uint64_t *))(*v11 + 16))(v11);
    (*(void (**)(MIDIObject *))(*(_QWORD *)v5 + 8))(v5);
    if (v12)
      (*(void (**)(uint64_t *))(*v11 + 24))(v11);
    if (v3)
      (*(void (**)(uint64_t *))(*v2 + 24))(v2);
    return 0;
  }
  else
  {
    if (v3)
      (*(void (**)(uint64_t *))(*v2 + 24))(v2);
    return 4294967246;
  }
}

void sub_1D4EBA44C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
    __cxa_begin_catch(a1);
    std::exception::~exception(&a10);
    __cxa_end_catch();
    JUMPOUT(0x1D4EBA398);
  }
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EBA424);
}

CFRunLoopRef MIDIGetDriverIORunLoop(void)
{
  MIDIServer *v0;
  uint64_t v1;

  if (gInMIDIServer == 1 && (v1 = *(_QWORD *)(MIDIServer::defaultInstance(v0)[33] + 8)) != 0)
    return *(CFRunLoopRef *)(v1 + 144);
  else
    return 0;
}

uint64_t _MIDISetupAddExternalDevice(MIDIServer *a1)
{
  int v1;
  uint64_t *v2;
  int v3;
  MIDIDevice *v4;
  MIDIDevice *v5;
  char v6;
  uint64_t v7;
  MIDISetup *v9;

  v1 = (int)a1;
  v2 = MIDIServer::defaultInstance(a1) + 2;
  v3 = (*(uint64_t (**)(uint64_t *))(*v2 + 16))(v2);
  v4 = (MIDIDevice *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIDevice>::sRTTI, v1);
  v5 = v4;
  if (v4 && !*((_QWORD *)v4 + 6))
  {
    v9 = *(MIDISetup **)SetupManager::instance(v4);
    if (v9)
    {
      MIDISetup::AddDevice(v9, v5);
      v7 = 4294956459;
      v6 = 1;
    }
    else
    {
      v6 = 0;
      v7 = 4294956459;
    }
  }
  else
  {
    v6 = 0;
    v7 = 4294967246;
  }
  if (v3)
    (*(void (**)(uint64_t *))(*v2 + 24))(v2);
  if ((v6 & 1) != 0)
    return 0;
  return v7;
}

void sub_1D4EBA5D8(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  int v11;

  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 3)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
  }
  else
  {
    if (a2 == 2)
    {
      __cxa_get_exception_ptr(a1);
      a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
      __cxa_begin_catch(a1);
      std::exception::~exception(&a10);
    }
    else
    {
      __cxa_begin_catch(a1);
    }
    __cxa_end_catch();
  }
  JUMPOUT(0x1D4EBA594);
}

uint64_t _MIDISetupRemoveExternalDevice(MIDIServer *a1)
{
  int v1;
  uint64_t *v2;
  int v3;
  MIDIDevice *v4;
  MIDIDevice *v5;
  char v6;
  uint64_t v7;
  MIDISetup *v9;

  v1 = (int)a1;
  v2 = MIDIServer::defaultInstance(a1) + 2;
  v3 = (*(uint64_t (**)(uint64_t *))(*v2 + 16))(v2);
  v4 = (MIDIDevice *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIDevice>::sRTTI, v1);
  v5 = v4;
  if (v4 && !*((_QWORD *)v4 + 6))
  {
    v9 = *(MIDISetup **)SetupManager::instance(v4);
    if (v9)
    {
      MIDISetup::RemoveDevice(v9, v5);
      v7 = 4294956459;
      v6 = 1;
    }
    else
    {
      v6 = 0;
      v7 = 4294956459;
    }
  }
  else
  {
    v6 = 0;
    v7 = 4294967246;
  }
  if (v3)
    (*(void (**)(uint64_t *))(*v2 + 24))(v2);
  if ((v6 & 1) != 0)
    return 0;
  return v7;
}

void sub_1D4EBA734(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  int v11;

  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 3)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
  }
  else
  {
    if (a2 == 2)
    {
      __cxa_get_exception_ptr(a1);
      a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
      __cxa_begin_catch(a1);
      std::exception::~exception(&a10);
    }
    else
    {
      __cxa_begin_catch(a1);
    }
    __cxa_end_catch();
  }
  JUMPOUT(0x1D4EBA6F0);
}

uint64_t _MIDISetupAddDevice(MIDIServer *a1)
{
  int v1;
  uint64_t *v2;
  int v3;
  MIDIDevice *v4;
  MIDIDevice *v5;
  MIDISetup *v6;
  uint64_t v7;
  char v8;

  v1 = (int)a1;
  v2 = MIDIServer::defaultInstance(a1) + 2;
  v3 = (*(uint64_t (**)(uint64_t *))(*v2 + 16))(v2);
  v4 = (MIDIDevice *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIDevice>::sRTTI, v1);
  v5 = v4;
  if (!v4 || !*((_QWORD *)v4 + 6))
  {
    v8 = 0;
    v7 = 4294967246;
    if (!v3)
      goto LABEL_8;
    goto LABEL_7;
  }
  v6 = *(MIDISetup **)SetupManager::instance(v4);
  if (v6)
  {
    MIDISetup::AddDevice(v6, v5);
    v7 = 4294956459;
    v8 = 1;
    if (!v3)
      goto LABEL_8;
LABEL_7:
    (*(void (**)(uint64_t *))(*v2 + 24))(v2);
    goto LABEL_8;
  }
  v8 = 0;
  v7 = 4294956459;
  if (v3)
    goto LABEL_7;
LABEL_8:
  if ((v8 & 1) != 0)
    return 0;
  return v7;
}

void sub_1D4EBA89C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  int v11;

  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 3)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
  }
  else
  {
    if (a2 == 2)
    {
      __cxa_get_exception_ptr(a1);
      a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
      __cxa_begin_catch(a1);
      std::exception::~exception(&a10);
    }
    else
    {
      __cxa_begin_catch(a1);
    }
    __cxa_end_catch();
  }
  JUMPOUT(0x1D4EBA870);
}

uint64_t _MIDISetupRemoveDevice(MIDIServer *a1)
{
  int v1;
  uint64_t *v2;
  int v3;
  MIDIDevice *v4;
  MIDIDevice *v5;
  MIDISetup *v6;
  uint64_t v7;
  char v8;

  v1 = (int)a1;
  v2 = MIDIServer::defaultInstance(a1) + 2;
  v3 = (*(uint64_t (**)(uint64_t *))(*v2 + 16))(v2);
  v4 = (MIDIDevice *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIDevice>::sRTTI, v1);
  v5 = v4;
  if (!v4 || !*((_QWORD *)v4 + 6))
  {
    v8 = 0;
    v7 = 4294967246;
    if (!v3)
      goto LABEL_8;
    goto LABEL_7;
  }
  v6 = *(MIDISetup **)SetupManager::instance(v4);
  if (v6)
  {
    MIDISetup::RemoveDevice(v6, v5);
    v7 = 4294956459;
    v8 = 1;
    if (!v3)
      goto LABEL_8;
LABEL_7:
    (*(void (**)(uint64_t *))(*v2 + 24))(v2);
    goto LABEL_8;
  }
  v8 = 0;
  v7 = 4294956459;
  if (v3)
    goto LABEL_7;
LABEL_8:
  if ((v8 & 1) != 0)
    return 0;
  return v7;
}

void sub_1D4EBAA00(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  int v11;

  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 3)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
  }
  else
  {
    if (a2 == 2)
    {
      __cxa_get_exception_ptr(a1);
      a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
      __cxa_begin_catch(a1);
      std::exception::~exception(&a10);
    }
    else
    {
      __cxa_begin_catch(a1);
    }
    __cxa_end_catch();
  }
  JUMPOUT(0x1D4EBA9D4);
}

uint64_t _MIDIDeviceRemoveEntity(MIDIServer *a1, int a2)
{
  int v3;
  uint64_t *v4;
  int v5;
  uint64_t v6;
  SetupManager *v7;
  MIDIEntity *v8;
  MIDISetup *v9;
  MIDIServer *v10;
  char *i;
  char v12;
  uint64_t v13;
  uint64_t *v14;
  int v15;
  char *v16;
  int64_t v17;

  v3 = (int)a1;
  v4 = MIDIServer::defaultInstance(a1) + 2;
  v5 = (*(uint64_t (**)(uint64_t *))(*v4 + 16))(v4);
  v6 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIDevice>::sRTTI, v3);
  if (!v6
    || (v7 = (SetupManager *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIEntity>::sRTTI, a2),
        (v8 = v7) == 0))
  {
    v12 = 0;
    v13 = 4294967246;
    if (!v5)
      goto LABEL_20;
    goto LABEL_19;
  }
  v9 = *(MIDISetup **)SetupManager::instance(v7);
  if (!v9)
  {
    v12 = 0;
    v13 = 4294956459;
    if (!v5)
      goto LABEL_20;
LABEL_19:
    (*(void (**)(uint64_t *))(*v4 + 24))(v4);
    goto LABEL_20;
  }
  MIDISetup::EntityRemoveEffects(v9, v8);
  for (i = *(char **)(v6 + 80); i != *(char **)(v6 + 88); i += 8)
  {
    if (*(MIDIEntity **)i == v8)
    {
      v14 = MIDIServer::defaultInstance(v10) + 13;
      v15 = (*(uint64_t (**)(uint64_t *))(*v14 + 16))(v14);
      if (*(_QWORD *)i)
        (*(void (**)(_QWORD))(**(_QWORD **)i + 8))(*(_QWORD *)i);
      v16 = *(char **)(v6 + 88);
      v17 = v16 - (i + 8);
      if (v16 != i + 8)
        memmove(i, i + 8, v16 - (i + 8));
      *(_QWORD *)(v6 + 88) = &i[v17];
      if (v15)
        (*(void (**)(uint64_t *))(*v14 + 24))(v14);
      break;
    }
  }
  v13 = 4294956459;
  v12 = 1;
  if (v5)
    goto LABEL_19;
LABEL_20:
  if ((v12 & 1) != 0)
    return 0;
  return v13;
}

void sub_1D4EBAC14(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  int v11;

  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 3)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
  }
  else
  {
    if (a2 == 2)
    {
      __cxa_get_exception_ptr(a1);
      a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
      __cxa_begin_catch(a1);
      std::exception::~exception(&a10);
    }
    else
    {
      __cxa_begin_catch(a1);
    }
    __cxa_end_catch();
  }
  JUMPOUT(0x1D4EBABECLL);
}

uint64_t _MIDIEntityAddOrRemoveEndpoints(MIDIServer *a1, unint64_t a2, unint64_t a3)
{
  int v5;
  uint64_t *v6;
  int v7;
  SetupManager *v8;
  SetupManager *v9;
  MIDISetup *v10;
  MIDIObject *v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  MIDIDriverPlugin *v15;
  MIDISource *v16;
  const __CFString *v17;
  unint64_t v18;
  MIDISource **v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  MIDISource **v27;
  char *v28;
  char *v29;
  MIDISource *v30;
  MIDISource **v31;
  MIDISource **v32;
  MIDISource **v33;
  unint64_t v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  MIDISource **v41;
  char *v42;
  char *v43;
  MIDISource *v44;
  _QWORD *v45;
  uint64_t v46;
  MIDIDriverPlugin *v47;
  MIDIDestination *v48;
  const __CFString *v49;
  unint64_t v50;
  MIDIDestination **v51;
  _QWORD *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  MIDIDestination **v59;
  char *v60;
  char *v61;
  MIDIDestination *v62;
  MIDIDestination **v63;
  MIDIDestination **v64;
  MIDIDestination **v65;
  unint64_t v66;
  _QWORD *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  uint64_t v72;
  MIDIDestination **v73;
  char *v74;
  char *v75;
  MIDIDestination *v76;
  MIDIObject *v77;
  char *v78;
  _BYTE *v79;
  int64_t v80;
  MIDIServer *v81;
  uint64_t *v82;
  int v83;
  MIDIObject *v84;
  char *v85;
  _BYTE *v86;
  int64_t v87;
  MIDIServer *v88;
  uint64_t *v89;
  int v90;
  MIDIConnection **j;
  uint64_t v92;
  char v93;
  int i;
  int v96;

  v5 = (int)a1;
  v6 = MIDIServer::defaultInstance(a1) + 2;
  v7 = (*(uint64_t (**)(uint64_t *))(*v6 + 16))(v6);
  v8 = (SetupManager *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIEntity>::sRTTI, v5);
  v9 = v8;
  if (!v8)
  {
    v93 = 0;
    v92 = 4294967246;
    if (!v7)
      goto LABEL_113;
    goto LABEL_112;
  }
  v10 = *(MIDISetup **)SetupManager::instance(v8);
  if (!v10)
  {
    v93 = 0;
    v92 = 4294956459;
    if (!v7)
      goto LABEL_113;
    goto LABEL_112;
  }
  v11 = (MIDIObject *)*((_QWORD *)v9 + 6);
  v12 = *((_QWORD *)v11 + 6);
  v96 = 0;
  if (MIDIObject::GetIntegerProperty(v11, kMIDIPropertyAdvanceScheduleTimeMuSec, &v96))
    v96 = 0;
  v14 = *((_QWORD *)v9 + 9);
  v13 = (_QWORD *)*((_QWORD *)v9 + 10);
  for (i = v7; a2 > ((uint64_t)v13 - v14) >> 3; v13 = (_QWORD *)*((_QWORD *)v9 + 10))
  {
    v15 = *(MIDIDriverPlugin **)(*((_QWORD *)v9 + 6) + 64);
    v16 = (MIDISource *)operator new();
    MIDISource::MIDISource(v16, v15, v9, *((MIDIProtocolID *)v9 + 14), v17);
    v19 = (MIDISource **)*((_QWORD *)v9 + 10);
    v18 = *((_QWORD *)v9 + 11);
    if ((unint64_t)v19 >= v18)
    {
      v21 = *((_QWORD *)v9 + 9);
      v22 = ((uint64_t)v19 - v21) >> 3;
      if ((unint64_t)(v22 + 1) >> 61)
        goto LABEL_116;
      v23 = v18 - v21;
      v24 = v23 >> 2;
      if (v23 >> 2 <= (unint64_t)(v22 + 1))
        v24 = v22 + 1;
      if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8)
        v25 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v25 = v24;
      if (v25)
        v25 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v25);
      else
        v26 = 0;
      v27 = (MIDISource **)(v25 + 8 * v22);
      *v27 = v16;
      v20 = v27 + 1;
      v29 = (char *)*((_QWORD *)v9 + 9);
      v28 = (char *)*((_QWORD *)v9 + 10);
      if (v28 != v29)
      {
        do
        {
          v30 = (MIDISource *)*((_QWORD *)v28 - 1);
          v28 -= 8;
          *--v27 = v30;
        }
        while (v28 != v29);
        v28 = (char *)*((_QWORD *)v9 + 9);
      }
      *((_QWORD *)v9 + 9) = v27;
      *((_QWORD *)v9 + 10) = v20;
      *((_QWORD *)v9 + 11) = v25 + 8 * v26;
      if (v28)
        operator delete(v28);
    }
    else
    {
      *v19 = v16;
      v20 = v19 + 1;
    }
    *((_QWORD *)v9 + 10) = v20;
    MIDISetup::AssignUniqueID(v10, v16);
    if (v12)
    {
      v31 = (MIDISource **)*((_QWORD *)v10 + 11);
      v32 = (MIDISource **)*((_QWORD *)v10 + 12);
      v33 = v31;
      if (v31 != v32)
      {
        while (*v33 != v16)
        {
          if (++v33 == v32)
          {
            v33 = (MIDISource **)*((_QWORD *)v10 + 12);
            break;
          }
        }
      }
      if (v33 == v32)
      {
        v34 = *((_QWORD *)v10 + 13);
        if ((unint64_t)v32 >= v34)
        {
          v36 = v32 - v31;
          if ((unint64_t)(v36 + 1) >> 61)
LABEL_116:
            std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
          v37 = v34 - (_QWORD)v31;
          v38 = v37 >> 2;
          if (v37 >> 2 <= (unint64_t)(v36 + 1))
            v38 = v36 + 1;
          if ((unint64_t)v37 >= 0x7FFFFFFFFFFFFFF8)
            v39 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v39 = v38;
          if (v39)
            v39 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v39);
          else
            v40 = 0;
          v41 = (MIDISource **)(v39 + 8 * v36);
          *v41 = v16;
          v35 = v41 + 1;
          v43 = (char *)*((_QWORD *)v10 + 11);
          v42 = (char *)*((_QWORD *)v10 + 12);
          if (v42 != v43)
          {
            do
            {
              v44 = (MIDISource *)*((_QWORD *)v42 - 1);
              v42 -= 8;
              *--v41 = v44;
            }
            while (v42 != v43);
            v42 = (char *)*((_QWORD *)v10 + 11);
          }
          *((_QWORD *)v10 + 11) = v41;
          *((_QWORD *)v10 + 12) = v35;
          *((_QWORD *)v10 + 13) = v39 + 8 * v40;
          if (v42)
            operator delete(v42);
        }
        else
        {
          *v32 = v16;
          v35 = v32 + 1;
        }
        *((_QWORD *)v10 + 12) = v35;
      }
    }
    MIDISetup::ObjectAdded(v10, v16);
    v14 = *((_QWORD *)v9 + 9);
  }
  v46 = *((_QWORD *)v9 + 13);
  v45 = (_QWORD *)*((_QWORD *)v9 + 14);
  if (a3 > ((uint64_t)v45 - v46) >> 3)
  {
    do
    {
      v47 = *(MIDIDriverPlugin **)(*((_QWORD *)v9 + 6) + 64);
      v48 = (MIDIDestination *)operator new();
      MIDIDestination::MIDIDestination(v48, v47, v9, *((MIDIProtocolID *)v9 + 14), v49);
      v51 = (MIDIDestination **)*((_QWORD *)v9 + 14);
      v50 = *((_QWORD *)v9 + 15);
      if ((unint64_t)v51 >= v50)
      {
        v53 = *((_QWORD *)v9 + 13);
        v54 = ((uint64_t)v51 - v53) >> 3;
        if ((unint64_t)(v54 + 1) >> 61)
          goto LABEL_117;
        v55 = v50 - v53;
        v56 = v55 >> 2;
        if (v55 >> 2 <= (unint64_t)(v54 + 1))
          v56 = v54 + 1;
        if ((unint64_t)v55 >= 0x7FFFFFFFFFFFFFF8)
          v57 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v57 = v56;
        if (v57)
          v57 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v57);
        else
          v58 = 0;
        v59 = (MIDIDestination **)(v57 + 8 * v54);
        *v59 = v48;
        v52 = v59 + 1;
        v61 = (char *)*((_QWORD *)v9 + 13);
        v60 = (char *)*((_QWORD *)v9 + 14);
        if (v60 != v61)
        {
          do
          {
            v62 = (MIDIDestination *)*((_QWORD *)v60 - 1);
            v60 -= 8;
            *--v59 = v62;
          }
          while (v60 != v61);
          v60 = (char *)*((_QWORD *)v9 + 13);
        }
        *((_QWORD *)v9 + 13) = v59;
        *((_QWORD *)v9 + 14) = v52;
        *((_QWORD *)v9 + 15) = v57 + 8 * v58;
        if (v60)
          operator delete(v60);
      }
      else
      {
        *v51 = v48;
        v52 = v51 + 1;
      }
      *((_QWORD *)v9 + 14) = v52;
      MIDISetup::AssignUniqueID(v10, v48);
      *((_DWORD *)v48 + 217) = v96;
      if (v12)
      {
        v63 = (MIDIDestination **)*((_QWORD *)v10 + 14);
        v64 = (MIDIDestination **)*((_QWORD *)v10 + 15);
        v65 = v63;
        if (v63 != v64)
        {
          while (*v65 != v48)
          {
            if (++v65 == v64)
            {
              v65 = (MIDIDestination **)*((_QWORD *)v10 + 15);
              break;
            }
          }
        }
        if (v65 == v64)
        {
          v66 = *((_QWORD *)v10 + 16);
          if ((unint64_t)v64 >= v66)
          {
            v68 = v64 - v63;
            if ((unint64_t)(v68 + 1) >> 61)
LABEL_117:
              std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
            v69 = v66 - (_QWORD)v63;
            v70 = v69 >> 2;
            if (v69 >> 2 <= (unint64_t)(v68 + 1))
              v70 = v68 + 1;
            if ((unint64_t)v69 >= 0x7FFFFFFFFFFFFFF8)
              v71 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v71 = v70;
            if (v71)
              v71 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v71);
            else
              v72 = 0;
            v73 = (MIDIDestination **)(v71 + 8 * v68);
            *v73 = v48;
            v67 = v73 + 1;
            v75 = (char *)*((_QWORD *)v10 + 14);
            v74 = (char *)*((_QWORD *)v10 + 15);
            if (v74 != v75)
            {
              do
              {
                v76 = (MIDIDestination *)*((_QWORD *)v74 - 1);
                v74 -= 8;
                *--v73 = v76;
              }
              while (v74 != v75);
              v74 = (char *)*((_QWORD *)v10 + 14);
            }
            *((_QWORD *)v10 + 14) = v73;
            *((_QWORD *)v10 + 15) = v67;
            *((_QWORD *)v10 + 16) = v71 + 8 * v72;
            if (v74)
              operator delete(v74);
          }
          else
          {
            *v64 = v48;
            v67 = v64 + 1;
          }
          *((_QWORD *)v10 + 15) = v67;
        }
      }
      MIDISetup::ObjectAdded(v10, v48);
      v46 = *((_QWORD *)v9 + 13);
      v45 = (_QWORD *)*((_QWORD *)v9 + 14);
    }
    while (a3 > ((uint64_t)v45 - v46) >> 3);
    v14 = *((_QWORD *)v9 + 9);
    v13 = (_QWORD *)*((_QWORD *)v9 + 10);
  }
  if (a2 < ((uint64_t)v13 - v14) >> 3)
  {
    do
    {
      v78 = (char *)(v13 - 1);
      v77 = (MIDIObject *)*(v13 - 1);
      *(v13 - 1) = 0;
      v79 = (_BYTE *)*((_QWORD *)v9 + 10);
      v80 = v79 - (_BYTE *)v13;
      if (v79 != (_BYTE *)v13)
        memmove(v13 - 1, v13, v79 - (_BYTE *)v13);
      *((_QWORD *)v9 + 10) = &v78[v80];
      remove<std::vector<MIDISource *>,MIDISource *>((_QWORD *)v10 + 11, (uint64_t)v77);
      MIDISetup::ObjectRemoved(v10, v77);
      v82 = MIDIServer::defaultInstance(v81) + 13;
      v83 = (*(uint64_t (**)(uint64_t *))(*v82 + 16))(v82);
      if (v77)
        (*(void (**)(MIDIObject *))(*(_QWORD *)v77 + 8))(v77);
      if (v83)
        (*(void (**)(uint64_t *))(*v82 + 24))(v82);
      v13 = (_QWORD *)*((_QWORD *)v9 + 10);
    }
    while (a2 < ((uint64_t)v13 - *((_QWORD *)v9 + 9)) >> 3);
    v46 = *((_QWORD *)v9 + 13);
    v45 = (_QWORD *)*((_QWORD *)v9 + 14);
  }
  if (a3 < ((uint64_t)v45 - v46) >> 3)
  {
    do
    {
      v85 = (char *)(v45 - 1);
      v84 = (MIDIObject *)*(v45 - 1);
      *(v45 - 1) = 0;
      v86 = (_BYTE *)*((_QWORD *)v9 + 14);
      v87 = v86 - (_BYTE *)v45;
      if (v86 != (_BYTE *)v45)
        memmove(v45 - 1, v45, v86 - (_BYTE *)v45);
      *((_QWORD *)v9 + 14) = &v85[v87];
      remove<std::vector<MIDISource *>,MIDISource *>((_QWORD *)v10 + 14, (uint64_t)v84);
      MIDISetup::ObjectRemoved(v10, v84);
      v89 = MIDIServer::defaultInstance(v88) + 13;
      v90 = (*(uint64_t (**)(uint64_t *))(*v89 + 16))(v89);
      if (v84)
        (*(void (**)(MIDIObject *))(*(_QWORD *)v84 + 8))(v84);
      if (v90)
        (*(void (**)(uint64_t *))(*v89 + 24))(v89);
      v45 = (_QWORD *)*((_QWORD *)v9 + 14);
    }
    while (a3 < ((uint64_t)v45 - *((_QWORD *)v9 + 13)) >> 3);
  }
  for (j = (MIDIConnection **)*((_QWORD *)v10 + 23); j != *((MIDIConnection ***)v10 + 24); ++j)
    MIDIConnection::MaintainEndpoints(*j, v10);
  v92 = 4294956459;
  v93 = 1;
  if (i)
LABEL_112:
    (*(void (**)(uint64_t *))(*v6 + 24))(v6);
LABEL_113:
  if ((v93 & 1) != 0)
    return 0;
  return v92;
}

void sub_1D4EBB320(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, std::exception a12)
{
  uint64_t v12;
  int v13;

  if (v13)
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 24))(v12);
  if (a2 == 3)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
  }
  else
  {
    if (a2 == 2)
    {
      __cxa_get_exception_ptr(a1);
      a12.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
      __cxa_begin_catch(a1);
      std::exception::~exception(&a12);
    }
    else
    {
      __cxa_begin_catch(a1);
    }
    __cxa_end_catch();
  }
  JUMPOUT(0x1D4EBB2E0);
}

MIDIDeviceListRef MIDIGetDriverDeviceList(MIDIDriverRef driver)
{
  uint64_t *v2;
  SetupManager *v3;
  int v4;
  MIDISetup *v5;
  MIDIDriverPlugin *v6;
  uint64_t DriverDevices;
  MIDIDeviceListRef v8;

  if (gInMIDIServer != 1)
    return 0;
  v2 = MIDIServer::defaultInstance((MIDIServer *)driver) + 2;
  v3 = (SetupManager *)(*(uint64_t (**)(uint64_t *))(*v2 + 16))(v2);
  v4 = (int)v3;
  v5 = *(MIDISetup **)SetupManager::instance(v3);
  v6 = (MIDIDriverPlugin *)driverRefToPlugin(driver);
  if (v5)
  {
    DriverDevices = MIDISetup::GetDriverDevices(v5, v6);
  }
  else
  {
    DriverDevices = operator new();
    BaseOpaqueObject::BaseOpaqueObject((BaseOpaqueObject *)DriverDevices);
    *(_QWORD *)(DriverDevices + 16) = 0;
    *(_QWORD *)(DriverDevices + 24) = 0;
    *(_QWORD *)(DriverDevices + 32) = 0;
    *(_QWORD *)DriverDevices = &off_1E98B91D0;
  }
  v8 = *(_DWORD *)(DriverDevices + 8);
  if (v4)
    (*(void (**)(uint64_t *))(*v2 + 24))(v2);
  return v8;
}

OSStatus MIDIDeviceListDispose(MIDIDeviceListRef devList)
{
  int v1;
  uint64_t v3;
  int v4;
  uint64_t v5;

  if (gInMIDIServer != 1)
    return -50;
  v3 = MIDIServer::defaultInstance(*(MIDIServer **)&devList, v1) + 16;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 16))(v3);
  v5 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<DeviceList>::sRTTI, devList);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  return 0;
}

uint64_t _MIDIObjectGetProperties(MIDIServer *a1, CFMutableDictionaryRef *a2, int a3)
{
  int v5;
  uint64_t *v6;
  int v7;
  CFDictionaryRef *v8;
  CFMutableDictionaryRef v9;

  v5 = (int)a1;
  v6 = MIDIServer::defaultInstance(a1) + 2;
  v7 = (*(uint64_t (**)(uint64_t *))(*v6 + 16))(v6);
  v8 = (CFDictionaryRef *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIObject>::sRTTI, v5);
  if (a2 && v8)
  {
    if (a3)
      v9 = (CFMutableDictionaryRef)(*((uint64_t (**)(CFDictionaryRef *))*v8 + 7))(v8);
    else
      v9 = MIDIObject::ToDictionary(v8[3]);
    *a2 = v9;
    if (v7)
      (*(void (**)(uint64_t *))(*v6 + 24))(v6);
    return 0;
  }
  else
  {
    if (v7)
      (*(void (**)(uint64_t *))(*v6 + 24))(v6);
    return 4294967246;
  }
}

void sub_1D4EBB794(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  int v11;

  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
    __cxa_begin_catch(a1);
    std::exception::~exception(&a10);
    __cxa_end_catch();
    JUMPOUT(0x1D4EBB74CLL);
  }
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EBB778);
}

uint64_t _MIDIRestart(MIDIServer *a1)
{
  uint64_t *v1;
  int v2;
  MIDIServer *v3;
  uint64_t *v4;
  SetupManager *v5;
  MIDISetup *v6;
  MIDIServer *v7;
  int v8;

  v1 = MIDIServer::defaultInstance(a1) + 2;
  v2 = (*(uint64_t (**)(uint64_t *))(*v1 + 16))(v1);
  Scheduler::FlushAllOutput((Scheduler *)gScheduler);
  v4 = MIDIServer::defaultInstance(v3);
  MIDIDriverMgr::StopMIDI((MIDIDriverMgr *)v4[33]);
  v6 = *(MIDISetup **)SetupManager::instance(v5);
  if (v6)
  {
    MIDISetup::ScanForDriverDevices(v6);
    MIDIServer::startMIDI(v7, v8);
    if (v2)
      (*(void (**)(uint64_t *))(*v1 + 24))(v1);
    return 0;
  }
  else
  {
    if (v2)
      (*(void (**)(uint64_t *))(*v1 + 24))(v1);
    return 4294956459;
  }
}

void sub_1D4EBB8E4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  if (a2 == 3)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
  }
  else
  {
    if (a2 == 2)
    {
      __cxa_get_exception_ptr(a1);
      a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
      __cxa_begin_catch(a1);
      std::exception::~exception(&a10);
    }
    else
    {
      __cxa_begin_catch(a1);
    }
    __cxa_end_catch();
  }
  JUMPOUT(0x1D4EBB8C4);
}

uint64_t _MIDIThruConnectionCreate(MIDIServer *a1, const void *a2, const __CFData *a3, _DWORD *a4)
{
  int v7;
  uint64_t *v8;
  uint64_t *v9;
  int v10;
  uint64_t *v11;
  uint64_t i;
  uint64_t v13;
  uint64_t v14;
  MIDISetup *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v19;
  uint64_t *v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  unint64_t v29;
  char *v30;
  char *v31;
  uint64_t v32;
  uint64_t v33[3];

  v7 = (int)a1;
  v8 = MIDIServer::defaultInstance(a1) + 2;
  v9 = (uint64_t *)(*(uint64_t (**)(uint64_t *))(*v8 + 16))(v8);
  v10 = (int)v9;
  if (!v7)
  {
    v13 = 0;
LABEL_9:
    v14 = 0;
    v16 = 4294967246;
    LOBYTE(v15) = 0;
    if (a3 && a4)
    {
      v15 = *(MIDISetup **)SetupManager::instance((SetupManager *)v9);
      if (v15)
      {
        v17 = operator new();
        BaseOpaqueObject::BaseOpaqueObject((BaseOpaqueObject *)v17);
        *(_QWORD *)v17 = &off_1E98B9618;
        *(_QWORD *)(v17 + 16) = a2;
        *(_BYTE *)(v17 + 24) = 1;
        CFRetain(a2);
        *(_QWORD *)(v17 + 48) = 0;
        *(_QWORD *)(v17 + 32) = v13;
        *(_QWORD *)(v17 + 40) = 0;
        *(_BYTE *)(v17 + 56) = 1;
        MIDI::StreamState::StreamState((MIDI::StreamState *)(v17 + 72), 0);
        MIDI::StreamState::StreamState((MIDI::StreamState *)(v17 + 7240), 0);
        *(_DWORD *)(v17 + 14408) = 0;
        *(_BYTE *)(v17 + 14412) = 0;
        v14 = MIDIConnection::SetParams((MIDIConnection *)v17, v15, a3);
        if ((_DWORD)v14)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v17 + 8))(v17);
        }
        else
        {
          v20 = (uint64_t *)*((_QWORD *)v15 + 24);
          v19 = *((_QWORD *)v15 + 25);
          if ((unint64_t)v20 >= v19)
          {
            v22 = *((_QWORD *)v15 + 23);
            v23 = ((uint64_t)v20 - v22) >> 3;
            if ((unint64_t)(v23 + 1) >> 61)
              std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
            v24 = v19 - v22;
            v25 = v24 >> 2;
            if (v24 >> 2 <= (unint64_t)(v23 + 1))
              v25 = v23 + 1;
            if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8)
              v26 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v26 = v25;
            if (v26)
              v26 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v26);
            else
              v27 = 0;
            v28 = (uint64_t *)(v26 + 8 * v23);
            v29 = v26 + 8 * v27;
            *v28 = v17;
            v21 = v28 + 1;
            v31 = (char *)*((_QWORD *)v15 + 23);
            v30 = (char *)*((_QWORD *)v15 + 24);
            if (v30 != v31)
            {
              do
              {
                v32 = *((_QWORD *)v30 - 1);
                v30 -= 8;
                *--v28 = v32;
              }
              while (v30 != v31);
              v30 = (char *)*((_QWORD *)v15 + 23);
            }
            *((_QWORD *)v15 + 23) = v28;
            *((_QWORD *)v15 + 24) = v21;
            *((_QWORD *)v15 + 25) = v29;
            if (v30)
              operator delete(v30);
          }
          else
          {
            *v20 = v17;
            v21 = v20 + 1;
          }
          *((_QWORD *)v15 + 24) = v21;
          if (a2)
          {
            v33[0] = 0x800000005;
            MIDISetup::GenerateNotification(v15, (uint64_t)v33);
          }
          *a4 = *(_DWORD *)(v17 + 8);
        }
        v16 = 4294967246;
        LOBYTE(v15) = 1;
        if (!v10)
          goto LABEL_17;
LABEL_16:
        (*(void (**)(uint64_t *))(*v8 + 24))(v8);
        goto LABEL_17;
      }
      v14 = 0;
      v16 = 4294956459;
    }
    if (!v10)
      goto LABEL_17;
    goto LABEL_16;
  }
  v11 = MIDIServer::defaultInstance((MIDIServer *)v9);
  v9 = MIDIServer::defaultInstance((MIDIServer *)v11);
  for (i = v9[29]; i != v9[30]; i += 8)
  {
    v13 = *(_QWORD *)i;
    if (*(_DWORD *)(*(_QWORD *)i + 8) == v7)
      goto LABEL_9;
  }
  v14 = 0;
  LOBYTE(v15) = 0;
  v16 = 4294967246;
  if (v10)
    goto LABEL_16;
LABEL_17:
  if ((v15 & 1) != 0)
    return v14;
  return v16;
}

void sub_1D4EBBC08(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, std::exception a12)
{
  uint64_t v12;
  BaseOpaqueObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v18;
  uint64_t v19;
  void *v20;

  v18 = (uint64_t *)((char *)v13 + 6928);
  v19 = -7168;
  while (1)
  {
    std::unique_ptr<std::map<unsigned short,unsigned short>>::reset[abi:ne180100](v18 + 38, 0);
    v20 = (void *)*v18;
    if (*v18)
    {
      v18[1] = (uint64_t)v20;
      operator delete(v20);
    }
    v18 -= 56;
    v19 += 448;
    if (!v19)
    {
      XCFObject<__CFData const*>::~XCFObject(v15);
      XCFObject<__CFString const*>::~XCFObject(v14);
      BaseOpaqueObject::~BaseOpaqueObject(v13);
      MEMORY[0x1D826BA98](v13, 0x10F1C4018F0CC6DLL);
      if (a11)
        (*(void (**)(uint64_t))(*(_QWORD *)v12 + 24))(v12);
      if (a2 == 3)
      {
        __cxa_begin_catch(a1);
        __cxa_end_catch();
      }
      else
      {
        if (a2 == 2)
        {
          __cxa_get_exception_ptr(a1);
          a12.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
          __cxa_begin_catch(a1);
          std::exception::~exception(&a12);
        }
        else
        {
          __cxa_begin_catch(a1);
        }
        __cxa_end_catch();
      }
      JUMPOUT(0x1D4EBBB04);
    }
  }
}

uint64_t _MIDIThruConnectionDispose(MIDIServer *a1)
{
  int v1;
  uint64_t *v2;
  int v3;
  SetupManager *v4;
  SetupManager *v5;
  uint64_t v6;
  char *v7;
  char *v8;
  int64_t v9;
  uint64_t v10;
  char v11;
  uint64_t v13[3];

  v1 = (int)a1;
  v2 = MIDIServer::defaultInstance(a1) + 2;
  v3 = (*(uint64_t (**)(uint64_t *))(*v2 + 16))(v2);
  v4 = (SetupManager *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIConnection>::sRTTI, v1);
  v5 = v4;
  if (!v4)
  {
    v6 = 0;
    v11 = 0;
    v10 = 4294967246;
    if (!v3)
      goto LABEL_23;
    goto LABEL_22;
  }
  v6 = *(_QWORD *)SetupManager::instance(v4);
  if (!v6)
  {
    v11 = 0;
    v10 = 4294956459;
    if (!v3)
      goto LABEL_23;
    goto LABEL_22;
  }
  v7 = *(char **)(v6 + 192);
  v8 = *(char **)(v6 + 184);
  if (v8 != v7)
  {
    v8 = *(char **)(v6 + 184);
    while (*(SetupManager **)v8 != v5)
    {
      v8 += 8;
      if (v8 == v7)
      {
        v8 = *(char **)(v6 + 192);
        break;
      }
    }
  }
  if (v8 == v7)
  {
    v10 = 4294956459;
    v11 = 1;
    v6 = 4294956463;
    if (!v3)
      goto LABEL_23;
    goto LABEL_22;
  }
  if (*(_QWORD *)v8)
  {
    (*(void (**)(_QWORD))(**(_QWORD **)v8 + 8))(*(_QWORD *)v8);
    v7 = *(char **)(v6 + 192);
  }
  v9 = v7 - (v8 + 8);
  if (v7 != v8 + 8)
    memmove(v8, v8 + 8, v7 - (v8 + 8));
  *(_QWORD *)(v6 + 192) = &v8[v9];
  if (*((_QWORD *)v5 + 2))
  {
    v13[0] = 0x800000005;
    MIDISetup::GenerateNotification((SetupManager *)v6, (uint64_t)v13);
  }
  v6 = 0;
  v10 = 4294956459;
  v11 = 1;
  if (v3)
LABEL_22:
    (*(void (**)(uint64_t *))(*v2 + 24))(v2);
LABEL_23:
  if ((v11 & 1) != 0)
    return v6;
  return v10;
}

void sub_1D4EBBEBC(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  uint64_t v9;
  int v10;

  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
  if (a2 == 3)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
  }
  else
  {
    if (a2 == 2)
    {
      __cxa_get_exception_ptr(a1);
      a9 = MEMORY[0x1E0DE5050] + 16;
      __cxa_begin_catch(a1);
      std::exception::~exception((std::exception *)&a9);
    }
    else
    {
      __cxa_begin_catch(a1);
    }
    __cxa_end_catch();
  }
  JUMPOUT(0x1D4EBBE98);
}

uint64_t _MIDIThruConnectionGetParams(MIDIServer *a1, _QWORD *a2)
{
  int v3;
  uint64_t *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;

  v3 = (int)a1;
  v4 = MIDIServer::defaultInstance(a1) + 2;
  v5 = (*(uint64_t (**)(uint64_t *))(*v4 + 16))(v4);
  if (!a2)
    goto LABEL_6;
  v6 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIConnection>::sRTTI, v3);
  if (v6)
  {
    v7 = *(_QWORD *)(v6 + 48);
    if (v7)
      CFRetain(*(CFTypeRef *)(v6 + 48));
    *a2 = v7;
    LOBYTE(a2) = 1;
LABEL_6:
    if (!v5)
      goto LABEL_8;
    goto LABEL_7;
  }
  LOBYTE(a2) = 0;
  if (v5)
LABEL_7:
    (*(void (**)(uint64_t *))(*v4 + 24))(v4);
LABEL_8:
  if ((a2 & 1) != 0)
    return 0;
  else
    return 4294967246;
}

uint64_t _MIDIThruConnectionSetParams(MIDIServer *a1, const __CFData *a2)
{
  int v3;
  uint64_t *v4;
  int v5;
  SetupManager *v6;
  MIDIConnection *v7;
  MIDISetup *v8;
  uint64_t v9;
  uint64_t v10;
  char v11;

  v3 = (int)a1;
  v4 = MIDIServer::defaultInstance(a1) + 2;
  v5 = (*(uint64_t (**)(uint64_t *))(*v4 + 16))(v4);
  v6 = (SetupManager *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIConnection>::sRTTI, v3);
  v7 = v6;
  if (v6)
  {
    v8 = *(MIDISetup **)SetupManager::instance(v6);
    if (v8)
    {
      v9 = MIDIConnection::SetParams(v7, v8, a2);
      v10 = 4294956459;
      v11 = 1;
      if (!v5)
        goto LABEL_9;
    }
    else
    {
      v9 = 0;
      v11 = 0;
      v10 = 4294956459;
      if (!v5)
        goto LABEL_9;
    }
LABEL_8:
    (*(void (**)(uint64_t *))(*v4 + 24))(v4);
    goto LABEL_9;
  }
  v9 = 0;
  v11 = 0;
  v10 = 4294967246;
  if (v5)
    goto LABEL_8;
LABEL_9:
  if ((v11 & 1) != 0)
    return v9;
  return v10;
}

void sub_1D4EBC178(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  int v11;

  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 3)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
  }
  else
  {
    if (a2 == 2)
    {
      __cxa_get_exception_ptr(a1);
      a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
      __cxa_begin_catch(a1);
      std::exception::~exception(&a10);
    }
    else
    {
      __cxa_begin_catch(a1);
    }
    __cxa_end_catch();
  }
  JUMPOUT(0x1D4EBC154);
}

uint64_t _MIDIThruConnectionFind(MIDIServer *a1, __CFData **a2)
{
  uint64_t *v4;
  SetupManager *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  __CFData *Mutable;
  uint64_t *i;
  uint64_t v11;
  const void *v12;
  UInt8 bytes[4];

  v4 = MIDIServer::defaultInstance(a1) + 2;
  v5 = (SetupManager *)(*(uint64_t (**)(uint64_t *))(*v4 + 16))(v4);
  v6 = (int)v5;
  LOBYTE(v7) = 0;
  v8 = 4294967246;
  if (!a1 || !a2)
    goto LABEL_11;
  v7 = *(_QWORD *)SetupManager::instance(v5);
  if (v7)
  {
    Mutable = CFDataCreateMutable(0, 0);
    for (i = *(uint64_t **)(v7 + 184); i != *(uint64_t **)(v7 + 192); ++i)
    {
      v11 = *i;
      v12 = *(const void **)(*i + 16);
      if (v12)
      {
        if (CFEqual(v12, a1))
        {
          *(_DWORD *)bytes = *(_DWORD *)(v11 + 8);
          CFDataAppendBytes(Mutable, bytes, 4);
        }
      }
    }
    *a2 = Mutable;
    v8 = 4294956459;
    LOBYTE(v7) = 1;
LABEL_11:
    if (!v6)
      goto LABEL_13;
    goto LABEL_12;
  }
  v8 = 4294956459;
  if (v6)
LABEL_12:
    (*(void (**)(uint64_t *))(*v4 + 24))(v4);
LABEL_13:
  if ((v7 & 1) != 0)
    return 0;
  return v8;
}

void sub_1D4EBC320(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  uint64_t v9;
  int v10;

  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
  if (a2 == 3)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
  }
  else
  {
    if (a2 == 2)
    {
      __cxa_get_exception_ptr(a1);
      a9 = MEMORY[0x1E0DE5050] + 16;
      __cxa_begin_catch(a1);
      std::exception::~exception((std::exception *)&a9);
    }
    else
    {
      __cxa_begin_catch(a1);
    }
    __cxa_end_catch();
  }
  JUMPOUT(0x1D4EBC2F0);
}

uint64_t _MIDIObjectFindByUniqueID(MIDIServer *a1, _DWORD *a2, _DWORD *a3)
{
  int v5;
  uint64_t *v6;
  SetupManager *v7;
  int v8;
  MIDISetup *v9;
  MIDIObject *ObjectByUniqueID;
  uint64_t v11;
  char v12;

  v5 = (int)a1;
  v6 = MIDIServer::defaultInstance(a1) + 2;
  v7 = (SetupManager *)(*(uint64_t (**)(uint64_t *))(*v6 + 16))(v6);
  v8 = (int)v7;
  v9 = *(MIDISetup **)SetupManager::instance(v7);
  if (!v9)
  {
    v12 = 0;
    v11 = 4294956459;
    if (!v8)
      goto LABEL_13;
    goto LABEL_12;
  }
  ObjectByUniqueID = MIDISetup::FindObjectByUniqueID(v9, v5, 0);
  if (!ObjectByUniqueID)
  {
    v12 = 0;
    v11 = 4294956454;
    if (!v8)
      goto LABEL_13;
    goto LABEL_12;
  }
  if (a2)
    *a2 = *((_DWORD *)ObjectByUniqueID + 2);
  if (a3)
    *a3 = (*(uint64_t (**)(MIDIObject *))(*(_QWORD *)ObjectByUniqueID + 72))(ObjectByUniqueID);
  v11 = 4294956454;
  v12 = 1;
  if (v8)
LABEL_12:
    (*(void (**)(uint64_t *))(*v6 + 24))(v6);
LABEL_13:
  if ((v12 & 1) != 0)
    return 0;
  return v11;
}

void sub_1D4EBC49C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  int v11;

  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 3)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
  }
  else
  {
    if (a2 == 2)
    {
      __cxa_get_exception_ptr(a1);
      a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
      __cxa_begin_catch(a1);
      std::exception::~exception(&a10);
    }
    else
    {
      __cxa_begin_catch(a1);
    }
    __cxa_end_catch();
  }
  JUMPOUT(0x1D4EBC47CLL);
}

__CFData *ReadFileIntoCFData(const char *a1)
{
  FILE *v1;
  FILE *v2;
  uint64_t v3;
  __CFData *Mutable;
  UInt8 *MutableBytePtr;

  v1 = fopen(a1, "rb");
  if (!v1)
    return 0;
  v2 = v1;
  fseek(v1, 0, 2);
  v3 = MEMORY[0x1D826BDBC](v2);
  rewind(v2);
  Mutable = CFDataCreateMutable(0, v3);
  CFDataSetLength(Mutable, v3);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  if (fread(MutableBytePtr, 1uLL, v3, v2) != v3)
  {
    CFRelease(Mutable);
    Mutable = 0;
  }
  fclose(v2);
  return Mutable;
}

BOOL WriteFileFromCFData(const char *a1, const __CFData *a2)
{
  FILE *v3;
  FILE *v4;
  size_t Length;
  const UInt8 *BytePtr;
  _BOOL8 v7;

  v3 = fopen(a1, "wb");
  if (!v3)
    return 0;
  v4 = v3;
  Length = CFDataGetLength(a2);
  BytePtr = CFDataGetBytePtr(a2);
  v7 = fwrite(BytePtr, 1uLL, Length, v4) == Length;
  fclose(v4);
  return v7;
}

void XServerMachPort::~XServerMachPort(mach_port_name_t *this)
{
  if (*this)
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], *this);
}

uint64_t XServerMachPort::ReceiveMessage(mach_port_name_t rcv_name, int *a2, void *a3, int *a4)
{
  uint64_t v7;
  int v8;
  uint64_t v9;
  mach_msg_header_t msg;
  int v12;
  int v13;
  _QWORD v14[9];

  v14[8] = *MEMORY[0x1E0C80C00];
  msg.msgh_bits = 0;
  msg.msgh_remote_port = 0;
  msg.msgh_local_port = rcv_name;
  msg.msgh_voucher_port = 0;
  msg.msgh_id = 0;
  v7 = mach_msg(&msg, 2, 0, 0x64u, rcv_name, 0, 0);
  v8 = v13;
  if (v13 < 0)
    return 268451844;
  v9 = v7;
  if (v13 >= *a4)
    v8 = *a4;
  *a4 = v8;
  memcpy(a3, v14, v8);
  *a2 = v12;
  return v9;
}

void MIDIServer::~MIDIServer(MIDIServer *this)
{
  MIDIServer::~MIDIServer(this);
  JUMPOUT(0x1D826BA98);
}

{
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  void *v6;
  MIDIServer *v7;
  uint64_t v8;
  MIDIServer *v9;
  uint64_t v10;
  MIDIServer *v11;
  uint64_t v12;
  void **v13;

  *(_QWORD *)this = &off_1E98B7E18;
  v2 = (void *)*((_QWORD *)this + 115);
  if (v2)
  {
    objc_msgSend(v2, "invalidate");
    v3 = (void *)*((_QWORD *)this + 115);
  }
  else
  {
    v3 = 0;
  }

  v4 = (void *)*((_QWORD *)this + 111);
  if (v4)
  {
    *((_QWORD *)this + 112) = v4;
    operator delete(v4);
  }
  std::mutex::~mutex((std::mutex *)((char *)this + 824));
  v13 = (void **)((char *)this + 800);
  std::vector<std::unique_ptr<UMPStream::EndpointPair>>::__destroy_vector::operator()[abi:ne180100](&v13);
  v5 = *((_QWORD *)this + 98);
  *((_QWORD *)this + 98) = 0;
  if (v5)
    MEMORY[0x1D826BA98](v5, 0x1000C40504FFAC1);
  v6 = (void *)*((_QWORD *)this + 94);
  if (v6)
  {
    *((_QWORD *)this + 95) = v6;
    operator delete(v6);
  }
  std::__tree<std::__value_type<unsigned int,MIDICI::SourceState>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,MIDICI::SourceState>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,MIDICI::SourceState>>>::destroy(*((_QWORD **)this + 92));
  std::mutex::~mutex((std::mutex *)((char *)this + 656));
  v13 = (void **)((char *)this + 632);
  std::vector<std::unique_ptr<MIDICI::Device>>::__destroy_vector::operator()[abi:ne180100](&v13);
  v7 = (MIDIServer *)*((_QWORD *)this + 75);
  if (v7 == (MIDIServer *)((char *)this + 576))
  {
    v8 = 4;
    v7 = (MIDIServer *)((char *)this + 576);
  }
  else
  {
    if (!v7)
      goto LABEL_15;
    v8 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v7 + 8 * v8))();
LABEL_15:
  v9 = (MIDIServer *)*((_QWORD *)this + 71);
  if (v9 == (MIDIServer *)((char *)this + 544))
  {
    v10 = 4;
    v9 = (MIDIServer *)((char *)this + 544);
  }
  else
  {
    if (!v9)
      goto LABEL_20;
    v10 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v9 + 8 * v10))();
LABEL_20:
  AsyncMessenger::~AsyncMessenger((MIDIServer *)((char *)this + 304));
  v11 = (MIDIServer *)*((_QWORD *)this + 37);
  if (v11 == (MIDIServer *)((char *)this + 272))
  {
    v12 = 4;
    v11 = (MIDIServer *)((char *)this + 272);
    goto LABEL_24;
  }
  if (v11)
  {
    v12 = 5;
LABEL_24:
    (*(void (**)(void))(*(_QWORD *)v11 + 8 * v12))();
  }
  std::unique_ptr<MIDIDriverMgr>::reset[abi:ne180100]((uint64_t *)this + 33, 0);
  OwnedPtrVector<ClientProcess *>::~OwnedPtrVector((_QWORD *)this + 28);
  OwnedPtrVector<MIDIClient *>::~OwnedPtrVector((_QWORD *)this + 24);
  *((_QWORD *)this + 13) = &off_1E98B9D98;
  pthread_mutex_destroy((pthread_mutex_t *)this + 2);
  *((_QWORD *)this + 2) = &off_1E98B9D98;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 40));
}

uint64_t MIDIServer::asMIGImpl(MIDIServer *this)
{
  return 0;
}

uint64_t MIDIServer::asXPCImpl(MIDIServer *this)
{
  return 0;
}

void MIDIServer::Init(MIDIServer *this, int a2)
{
  NSObject *v4;
  _BOOL8 v5;
  const char *v6;
  NSObject *v7;
  int v8;
  int v9;
  NSObject *v10;
  OSStatus v11;
  OSStatus v12;
  NSObject *v13;
  int v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  const char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  gMIDIServerLog();
  v4 = objc_retainAutorelease((id)gMIDIServerLog(void)::mdsrvr);
  v5 = os_log_type_enabled(v4, OS_LOG_TYPE_INFO);
  if (v5)
  {
    v6 = "false";
    v14 = 136315650;
    v15 = "MIDIServer.mm";
    if (a2)
      v6 = "true";
    v16 = 1024;
    v17 = 508;
    v18 = 2080;
    v19 = v6;
    _os_log_impl(&dword_1D4E88000, v4, OS_LOG_TYPE_INFO, "%25s:%-5d [+] MIDIServer::Init(runForever = %s)", (uint8_t *)&v14, 0x1Cu);
  }
  *((_BYTE *)this + 8) = a2;
  MIDICISessionManager::Instance((MIDICISessionManager *)v5);
  gMIDIServerLog();
  v7 = objc_retainAutorelease((id)gMIDIServerLog(void)::mdsrvr);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    v14 = 136315394;
    v15 = "MIDIServer.mm";
    v16 = 1024;
    v17 = 511;
    _os_log_impl(&dword_1D4E88000, v7, OS_LOG_TYPE_INFO, "%25s:%-5d [-] MIDIServer::Init()", (uint8_t *)&v14, 0x12u);
  }
  v8 = MIDIClientCreateWithBlockInternal(CFSTR("MIDI_UMPCI_CLIENT"), (int *)this + 152, &__block_literal_global_42, 0);
  if (v8)
  {
    v9 = v8;
    gUMPCIServerContext();
    v10 = objc_retainAutorelease((id)gUMPCIServerContext(void)::cisrvr);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      v14 = 136315650;
      v15 = "UMPCIServerContext.hpp";
      v16 = 1024;
      v17 = 81;
      v18 = 1024;
      LODWORD(v19) = v9;
      _os_log_impl(&dword_1D4E88000, v10, OS_LOG_TYPE_ERROR, "%25s:%-5d Unable to create client for UMPCIServerContext (err = %d). UMPCI will not be possible.", (uint8_t *)&v14, 0x18u);
    }
  }
  v11 = MIDIOutputPortCreate(*((_DWORD *)this + 152), CFSTR("MIDI_UMPCI_PORT"), (MIDIPortRef *)this + 153);
  if (v11)
  {
    v12 = v11;
    gUMPCIServerContext();
    v13 = objc_retainAutorelease((id)gUMPCIServerContext(void)::cisrvr);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v14 = 136315650;
      v15 = "UMPCIServerContext.hpp";
      v16 = 1024;
      v17 = 84;
      v18 = 1024;
      LODWORD(v19) = v12;
      _os_log_impl(&dword_1D4E88000, v13, OS_LOG_TYPE_ERROR, "%25s:%-5d Unable to create output port for UMPCIServerContext (err = %d).", (uint8_t *)&v14, 0x18u);
    }
  }
}

void gMIDIServerLog(void)
{
  unsigned __int8 v0;

  if ((v0 & 1) == 0)
  {
    {
      caulk::log_category::log_category((caulk::log_category *)&gMIDIServerLog(void)::mdsrvr, "com.apple.coremidi", "server");
    }
  }
}

uint64_t MIDICISessionManager::Instance(MIDICISessionManager *this)
{
  unsigned __int8 v1;
  MIDICISessionManager *v3;

  {
    v3 = (MIDICISessionManager *)operator new();
    MIDICISessionManager::MIDICISessionManager(v3);
    MIDICISessionManager::Instance(void)::m = (uint64_t)v3;
  }
  return MIDICISessionManager::Instance(void)::m;
}

void sub_1D4EBCAFC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D826BA98](v1, 0x10F0C40554E3538);
  _Unwind_Resume(a1);
}

void gUMPCIServerContext(void)
{
  unsigned __int8 v0;

  if ((v0 & 1) == 0)
  {
    {
      caulk::log_category::log_category((caulk::log_category *)&gUMPCIServerContext(void)::cisrvr, "com.apple.coremidi", "UMPCIServerContext");
    }
  }
}

void std::__tree<std::__value_type<unsigned int,MIDICI::SourceState>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,MIDICI::SourceState>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,MIDICI::SourceState>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned int,MIDICI::SourceState>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,MIDICI::SourceState>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,MIDICI::SourceState>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned int,MIDICI::SourceState>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,MIDICI::SourceState>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,MIDICI::SourceState>>>::destroy(a1[1]);
    std::__destroy_at[abi:ne180100]<std::pair<unsigned int const,MIDICI::SourceState>,0>((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void std::vector<std::unique_ptr<MIDICI::Device>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  _QWORD *v2;
  _QWORD *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v7 = *--v4;
        v6 = v7;
        *v4 = 0;
        if (v7)
          std::default_delete<MIDICI::Device>::operator()[abi:ne180100](v6);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void AsyncMessenger::~AsyncMessenger(AsyncMessenger *this)
{
  char *v2;
  unint64_t *v3;
  unint64_t *v4;
  unint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  char *v8;
  int i;
  uint64_t j;
  AsyncMessenger *v11;
  uint64_t v12;

  atomic_store(1u, (unsigned __int8 *)this + 8);
  v2 = (char *)this + 12;
  caulk::mach::semaphore::signal_all_or_error((AsyncMessenger *)((char *)this + 12));
  caulk::thread::join(*(caulk::thread **)this);
  v3 = (unint64_t *)((char *)this + 96);
  while (1)
  {
    v4 = (unint64_t *)*((_QWORD *)this + 20);
    if (v4)
      goto LABEL_8;
    do
      v5 = (unint64_t *)__ldaxr(v3);
    while (__stxr(0, v3));
    if (!v5)
      break;
    v4 = 0;
    do
    {
      v6 = (unint64_t)v4;
      v4 = v5;
      v5 = (unint64_t *)atomic_load(v5);
      atomic_store(v6, v4);
    }
    while (v5);
    *((_QWORD *)this + 20) = v4;
LABEL_8:
    v7 = atomic_load(v4);
    *((_QWORD *)this + 20) = v7;
    v8 = (char *)v4 + 21;
    for (i = *(_DWORD *)((char *)v4 + 17); i; --i)
      v8 += 4 * *((unsigned int *)v8 + 2) + 12;
    (*(void (**)(_QWORD))(**((_QWORD **)this + 21) + 24))(*((_QWORD *)this + 21));
  }
  for (j = 0; j != -64; j -= 32)
  {
    v11 = *(AsyncMessenger **)((char *)this + j + 232);
    if ((AsyncMessenger *)((char *)this + j + 208) == v11)
    {
      v11 = (AsyncMessenger *)((char *)this + j + 208);
      v12 = 4;
    }
    else
    {
      if (!v11)
        continue;
      v12 = 5;
    }
    (*(void (**)(void))(*(_QWORD *)v11 + 8 * v12))();
  }
  std::mutex::~mutex((std::mutex *)((char *)this + 24));
  MEMORY[0x1D826B744](v2);
  std::unique_ptr<caulk::thread>::reset[abi:ne180100]((caulk::thread **)this, 0);
}

uint64_t *std::unique_ptr<MIDIDriverMgr>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  void **v9;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    if (!*(_QWORD *)(v2 + 64))
    {
      MIDIDriverMgr::StopMIDI((MIDIDriverMgr *)v2);
      v3 = *(_QWORD **)(v2 + 16);
      v4 = *(_QWORD **)(v2 + 24);
      while (v4 != v3)
      {
        v6 = *--v4;
        v5 = v6;
        *v4 = 0;
        if (v6)
          (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
      }
      *(_QWORD *)(v2 + 24) = v3;
      v7 = *(_QWORD *)(v2 + 8);
      if (v7)
        (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
      std::unique_ptr<MIDIDriverKitPluginRegistrar>::reset[abi:ne180100]((uint64_t *)(v2 + 64), 0);
      v8 = *(void **)(v2 + 40);
      if (v8)
      {
        *(_QWORD *)(v2 + 48) = v8;
        operator delete(v8);
      }
      v9 = (void **)(v2 + 16);
      std::vector<std::unique_ptr<MIDIDriverPlugin>>::__destroy_vector::operator()[abi:ne180100](&v9);
      JUMPOUT(0x1D826BA98);
    }
    __assert_rtn("~MIDIDriverMgr", "DriverTable.cpp", 108, "mMDKPluginRegistrar == nullptr");
  }
  return result;
}

_QWORD *OwnedPtrVector<ClientProcess *>::~OwnedPtrVector(_QWORD *a1)
{
  char *v2;
  char *v3;
  char *v4;
  _BYTE *v5;
  uint64_t v6;
  char *v7;

  *a1 = &off_1E98B97B0;
  v2 = (char *)a1[1];
  v3 = (char *)a1[2];
  if (v2 != v3)
  {
    v4 = (char *)a1[1];
    do
    {
      if (*(_QWORD *)v4)
        (*(void (**)(_QWORD))(**(_QWORD **)v4 + 8))(*(_QWORD *)v4);
      v4 += 8;
    }
    while (v4 != v3);
    v5 = (_BYTE *)a1[2];
    v6 = v5 - v3;
    if (v5 != v3)
      memmove(v2, v3, v5 - v3);
    v7 = (char *)a1[1];
    a1[2] = &v2[v6];
    v2 = v7;
  }
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

_QWORD *OwnedPtrVector<MIDIClient *>::~OwnedPtrVector(_QWORD *a1)
{
  char *v2;
  char *v3;
  char *v4;
  _BYTE *v5;
  uint64_t v6;
  char *v7;

  *a1 = &off_1E98B9750;
  v2 = (char *)a1[1];
  v3 = (char *)a1[2];
  if (v2 != v3)
  {
    v4 = (char *)a1[1];
    do
    {
      if (*(_QWORD *)v4)
        (*(void (**)(_QWORD))(**(_QWORD **)v4 + 8))(*(_QWORD *)v4);
      v4 += 8;
    }
    while (v4 != v3);
    v5 = (_BYTE *)a1[2];
    v6 = v5 - v3;
    if (v5 != v3)
      memmove(v2, v3, v5 - v3);
    v7 = (char *)a1[1];
    a1[2] = &v2[v6];
    v2 = v7;
  }
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void OwnedPtrVector<MIDIClient *>::~OwnedPtrVector(_QWORD *a1)
{
  OwnedPtrVector<MIDIClient *>::~OwnedPtrVector(a1);
  JUMPOUT(0x1D826BA98);
}

void OwnedPtrVector<ClientProcess *>::~OwnedPtrVector(_QWORD *a1)
{
  OwnedPtrVector<ClientProcess *>::~OwnedPtrVector(a1);
  JUMPOUT(0x1D826BA98);
}

caulk::thread *std::unique_ptr<caulk::thread>::reset[abi:ne180100](caulk::thread **a1, caulk::thread *a2)
{
  caulk::thread *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    caulk::thread::~thread(result);
    JUMPOUT(0x1D826BA98);
  }
  return result;
}

void std::default_delete<MIDICI::Device>::operator()[abi:ne180100](uint64_t a1)
{
  const void *v2;
  void **v3;

  v2 = *(const void **)(a1 + 192);
  if (v2)
    CFRelease(v2);
  std::unique_ptr<PropertyExchange::RequestManager>::reset[abi:ne180100]((uint64_t *)(a1 + 176), 0);
  v3 = (void **)(a1 + 144);
  std::vector<std::unique_ptr<MIDICI::Profile>>::__destroy_vector::operator()[abi:ne180100](&v3);
  if (*(char *)(a1 + 143) < 0)
    operator delete(*(void **)(a1 + 120));
  *(_QWORD *)a1 = off_1E98B9320;
  XCFObject<__CFDictionary const*>::~XCFObject(a1 + 24);
  BaseOpaqueObject::~BaseOpaqueObject((BaseOpaqueObject *)a1);
  JUMPOUT(0x1D826BA98);
}

uint64_t *std::unique_ptr<PropertyExchange::RequestManager>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    std::__tree<std::__value_type<std::pair<unsigned int,unsigned char>,PropertyExchange::Request>,std::__map_value_compare<std::pair<unsigned int,unsigned char>,std::__value_type<std::pair<unsigned int,unsigned char>,PropertyExchange::Request>,std::less<std::pair<unsigned int,unsigned char>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,unsigned char>,PropertyExchange::Request>>>::destroy(*(_QWORD **)(v2 + 8));
    JUMPOUT(0x1D826BA98);
  }
  return result;
}

void std::vector<std::unique_ptr<MIDICI::Profile>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  _QWORD *v2;
  _QWORD *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v7 = *--v4;
        v6 = v7;
        *v4 = 0;
        if (v7)
          std::default_delete<MIDICI::Profile>::operator()[abi:ne180100](v6);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::default_delete<MIDICI::Profile>::operator()[abi:ne180100](uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 88);
  if (v2)
  {
    *(_QWORD *)(a1 + 96) = v2;
    operator delete(v2);
  }
  if (*(char *)(a1 + 87) < 0)
    operator delete(*(void **)(a1 + 64));
  *(_QWORD *)a1 = off_1E98B9320;
  XCFObject<__CFDictionary const*>::~XCFObject(a1 + 24);
  BaseOpaqueObject::~BaseOpaqueObject((BaseOpaqueObject *)a1);
  JUMPOUT(0x1D826BA98);
}

void std::__tree<std::__value_type<std::pair<unsigned int,unsigned char>,PropertyExchange::Request>,std::__map_value_compare<std::pair<unsigned int,unsigned char>,std::__value_type<std::pair<unsigned int,unsigned char>,PropertyExchange::Request>,std::less<std::pair<unsigned int,unsigned char>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,unsigned char>,PropertyExchange::Request>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::pair<unsigned int,unsigned char>,PropertyExchange::Request>,std::__map_value_compare<std::pair<unsigned int,unsigned char>,std::__value_type<std::pair<unsigned int,unsigned char>,PropertyExchange::Request>,std::less<std::pair<unsigned int,unsigned char>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,unsigned char>,PropertyExchange::Request>>>::destroy(*a1);
    std::__tree<std::__value_type<std::pair<unsigned int,unsigned char>,PropertyExchange::Request>,std::__map_value_compare<std::pair<unsigned int,unsigned char>,std::__value_type<std::pair<unsigned int,unsigned char>,PropertyExchange::Request>,std::less<std::pair<unsigned int,unsigned char>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,unsigned char>,PropertyExchange::Request>>>::destroy(a1[1]);
    std::__destroy_at[abi:ne180100]<std::pair<std::pair<unsigned int,unsigned char> const,PropertyExchange::Request>,0>(a1 + 4);
    operator delete(a1);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::pair<unsigned int,unsigned char> const,PropertyExchange::Request>,0>(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  void *v5;

  v2 = a1 + 5;
  v3 = (_QWORD *)a1[8];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  v5 = (void *)a1[2];
  if (v5)
  {
    a1[3] = v5;
    operator delete(v5);
  }
}

_QWORD *std::__destroy_at[abi:ne180100]<std::pair<unsigned int const,MIDICI::SourceState>,0>(uint64_t a1)
{
  _QWORD *result;

  std::__tree<std::__value_type<unsigned int,std::unique_ptr<MIDICI::CIRetrier>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::unique_ptr<MIDICI::CIRetrier>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::unique_ptr<MIDICI::CIRetrier>>>>::destroy(*(_QWORD **)(a1 + 24));
  result = *(_QWORD **)(a1 + 8);
  *(_QWORD *)(a1 + 8) = 0;
  if (result)
    std::default_delete<MIDICI::SysexCollector>::operator()[abi:ne180100](result);
  return result;
}

void std::__tree<std::__value_type<unsigned int,std::unique_ptr<MIDICI::CIRetrier>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::unique_ptr<MIDICI::CIRetrier>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::unique_ptr<MIDICI::CIRetrier>>>>::destroy(_QWORD *a1)
{
  uint64_t v2;

  if (a1)
  {
    std::__tree<std::__value_type<unsigned int,std::unique_ptr<MIDICI::CIRetrier>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::unique_ptr<MIDICI::CIRetrier>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::unique_ptr<MIDICI::CIRetrier>>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned int,std::unique_ptr<MIDICI::CIRetrier>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::unique_ptr<MIDICI::CIRetrier>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::unique_ptr<MIDICI::CIRetrier>>>>::destroy(a1[1]);
    v2 = a1[5];
    a1[5] = 0;
    if (v2)
      MEMORY[0x1D826BA98](v2, 0x1000C40504FFAC1);
    operator delete(a1);
  }
}

void std::default_delete<MIDICI::SysexCollector>::operator()[abi:ne180100](_QWORD *a1)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  void *v5;
  _QWORD *v6;
  uint64_t v7;

  v2 = 0;
  while (1)
  {
    v3 = (_QWORD *)a1[v2 + 163];
    if (&a1[v2 + 160] == v3)
      break;
    if (v3)
    {
      v4 = 5;
LABEL_6:
      (*(void (**)(void))(*v3 + 8 * v4))();
    }
    v5 = (void *)a1[v2 + 155];
    if (v5)
    {
      a1[v2 + 156] = v5;
      operator delete(v5);
    }
    v2 -= 10;
    if (v2 == -160)
    {
      v6 = (_QWORD *)a1[3];
      if (v6 == a1)
      {
        v7 = 4;
        v6 = a1;
LABEL_14:
        (*(void (**)(void))(*v6 + 8 * v7))();
      }
      else if (v6)
      {
        v7 = 5;
        goto LABEL_14;
      }
      JUMPOUT(0x1D826BA98);
    }
  }
  v3 = &a1[v2 + 160];
  v4 = 4;
  goto LABEL_6;
}

void FullInit(const char *a1, uint64_t a2)
{
  unsigned int v4;
  NSObject *v5;
  pid_t v6;
  const char *v7;
  const char *v8;
  NSObject *v9;
  _BOOL8 v10;
  uint64_t *v11;
  unsigned __int8 v12;
  _QWORD *v13;
  uint64_t v14;
  std::string *v15;
  std::string *v16;
  std::string::size_type v17;
  _BYTE *v18;
  std::string::size_type *v19;
  CFTypeRef *v20;
  CFTypeRef *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  char *v27;
  uint64_t v28;
  __int128 v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  int64x2_t v36;
  uint64_t v37;
  std::string *v38;
  uint64_t v39;
  uint64_t v40;
  SetupManager *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  NSObject *v45;
  uint64_t v46;
  uint64_t v47;
  unsigned int v48;
  BOOL v49;
  BOOL v50;
  const char *v51;
  uint64_t v52;
  uint64_t *v53;
  uint64_t *v54;
  int64x2_t *v55;
  char *v56;
  std::string *v57;
  __int128 v58;
  std::string *v59;
  __int128 v60;
  const char *v61;
  char *v62;
  char *v63;
  const __CFUUID *v64;
  const __CFUUID *v65;
  void *v66;
  NSObject *v67;
  CFURLRef v68;
  NSObject *v69;
  void (*v70)(void *, _QWORD, _QWORD, std::string *);
  const __CFUUID *v71;
  CFUUIDBytes v72;
  int v73;
  CFURLRef v74;
  void (*v75)(void *, _QWORD, _QWORD, std::string *);
  const __CFUUID *v76;
  CFUUIDBytes v77;
  void (*v78)(void *, _QWORD, _QWORD, std::string *);
  const __CFUUID *v79;
  CFUUIDBytes v80;
  __CFBundle *Bundle;
  const __CFDictionary *InfoDictionary;
  const __CFString *Value;
  CFStringRef PathComponent;
  uint64_t v85;
  std::string::size_type v86;
  _QWORD *v87;
  __int128 v88;
  std::__shared_weak_count *v89;
  unint64_t *p_shared_owners;
  unint64_t v91;
  unint64_t v92;
  uint64_t v93;
  uint64_t *v94;
  unint64_t v95;
  uint64_t *v96;
  uint64_t *v97;
  uint64_t *v98;
  uint64_t v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  unint64_t v103;
  uint64_t v104;
  uint64_t *v105;
  unint64_t v106;
  _QWORD *v107;
  _QWORD *v108;
  _QWORD *v109;
  uint64_t v110;
  int64x2_t v111;
  MIDIDriverPlugin_CFPlugin *v112;
  unint64_t v113;
  uint64_t *v114;
  uint64_t *v115;
  int64x2_t *v116;
  _QWORD *v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  unint64_t v123;
  uint64_t v124;
  _QWORD *v125;
  unint64_t v126;
  uint64_t v127;
  _QWORD *v128;
  _QWORD *v129;
  uint64_t v130;
  int64x2_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t *v134;
  uint64_t v135;
  int v136;
  NSObject *v137;
  CFDictionaryRef CFDictionaryRef;
  CFDictionaryRef v139;
  CFDictionaryRef v140;
  uint64_t i;
  const void *v142;
  const void *v143;
  uint64_t v144;
  _QWORD *v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  _QWORD *v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  const __CFString *v153;
  const __CFString *v154;
  const __CFString *v155;
  NSObject *v156;
  NSObject *v157;
  __CFData *FileIntoCFData;
  NSObject *v159;
  NSObject *v160;
  NSObject *v161;
  void *v162;
  void *v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t j;
  void *v167;
  void *v168;
  void *v169;
  void *v170;
  void *v171;
  NSObject *v172;
  uint64_t v173;
  NSObject *v174;
  _BOOL8 v175;
  SetupManager *v176;
  uint64_t v177;
  NSObject *v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  unsigned int v182;
  BOOL v183;
  BOOL v184;
  const char *v185;
  unsigned __int8 v186;
  uint64_t (**v187)();
  NSObject *v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  SetupManager *v192;
  NSObject *v193;
  pid_t v194;
  CASmartPreferences *v195;
  void *key;
  void *keya;
  CFPropertyListRef propertyList;
  void *__p;
  char v200;
  char v201;
  uint64_t v202;
  int v203;
  char v204;
  char v205;
  char v206;
  int64x2_t v207;
  unint64_t v208;
  _QWORD v209[2];
  _QWORD v210[3];
  SetupManager *v211;
  std::string v212;
  std::string *v213;
  CFTypeRef v214;
  CFTypeRef cf;
  uint64_t v216;
  CFTypeRef v217;
  CFTypeRef v218;
  _BYTE buf[40];
  uint64_t v220;
  _BYTE v221[32];
  _OWORD v222[2];
  uint64_t v223;

  v223 = *MEMORY[0x1E0C80C00];
  v4 = time(0);
  srand(v4);
  gInMIDIServer = 1;
  gMIDIServerLog();
  v5 = objc_retainAutorelease((id)gMIDIServerLog(void)::mdsrvr);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    v6 = getpid();
    v7 = ", forever";
    *(_DWORD *)buf = 136316162;
    *(_QWORD *)&buf[4] = "MIDIServer.mm";
    if (!(_DWORD)a2)
      v7 = "";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 286;
    v8 = "nullptr";
    if (a1)
      v8 = a1;
    *(_WORD *)&buf[18] = 2080;
    *(_QWORD *)&buf[20] = v8;
    *(_WORD *)&buf[28] = 2080;
    *(_QWORD *)&buf[30] = v7;
    *(_WORD *)&buf[38] = 1024;
    LODWORD(v220) = v6;
    _os_log_impl(&dword_1D4E88000, v5, OS_LOG_TYPE_INFO, "%25s:%-5d FullInit(%s%s) - MIDIServer [%d] starting", buf, 0x2Cu);
  }

  LOBYTE(__p) = 0;
  v201 = 0;
  v202 = 46;
  v203 = 2;
  v204 = 1;
  v205 = 0;
  v206 = 0;
  caulk::thread::attributes::apply_to_this_thread((caulk::thread::attributes *)&__p);
  _InitMIDIProperties();
  gMIDIServerLog();
  v9 = objc_retainAutorelease((id)gMIDIServerLog(void)::mdsrvr);
  v10 = os_log_type_enabled(v9, OS_LOG_TYPE_INFO);
  if (v10)
  {
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = "MIDIServer.mm";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 294;
    _os_log_impl(&dword_1D4E88000, v9, OS_LOG_TYPE_INFO, "%25s:%-5d Driver plugins initialized.", buf, 0x12u);
  }
  v11 = MIDIServer::defaultInstance((MIDIServer *)v10);
  (*(void (**)(uint64_t *, uint64_t))(*v11 + 32))(v11, a2);
  v210[0] = &off_1E98B70F8;
  v211 = (SetupManager *)v210;
  if ((v12 & 1) == 0)
  {
    if ((_DWORD)v195)
    {
      CASmartPreferences::CASmartPreferences(v195);
    }
  }
  *(_QWORD *)v221 = CASmartPreferences::InterpretBoolean;
  v13 = &v221[8];
  v14 = (uint64_t)v211;
  if (!v211)
    goto LABEL_13;
  if (v211 != (SetupManager *)v210)
  {
    v14 = (*(uint64_t (**)(void))(*(_QWORD *)v211 + 16))();
LABEL_13:
    *(_QWORD *)&v222[0] = v14;
    goto LABEL_15;
  }
  *(_QWORD *)&v222[0] = &v221[8];
  (*(void (**)(uint64_t, _QWORD *))(v210[0] + 24))((uint64_t)v210, &v221[8]);
LABEL_15:
  v213 = 0;
  v15 = (std::string *)operator new(0x30uLL);
  v16 = v15;
  v17 = *(_QWORD *)v221;
  v18 = *(_BYTE **)&v222[0];
  v15->__r_.__value_.__r.__words[0] = (std::string::size_type)&off_1E98B9F60;
  v15->__r_.__value_.__l.__size_ = v17;
  if (!v18)
  {
    v19 = &v15[1].__r_.__value_.__r.__words[2];
    goto LABEL_19;
  }
  if (v18 != &v221[8])
  {
    v19 = (std::string::size_type *)v222;
    v15[1].__r_.__value_.__r.__words[2] = (std::string::size_type)v18;
LABEL_19:
    *v19 = 0;
    goto LABEL_21;
  }
  v15[1].__r_.__value_.__r.__words[2] = (std::string::size_type)&v15->__r_.__value_.__r.__words[2];
  (*(void (**)(_BYTE *))(*(_QWORD *)&v221[8] + 24))(&v221[8]);
LABEL_21:
  v213 = v16;
  std::mutex::lock((std::mutex *)&CASmartPreferences::instance(void)::global);
  v21 = (CFTypeRef *)*((_QWORD *)&xmmword_1EFEFD900 + 1);
  v20 = (CFTypeRef *)xmmword_1EFEFD900;
  if ((_QWORD)xmmword_1EFEFD900 == *((_QWORD *)&xmmword_1EFEFD900 + 1))
  {
LABEL_25:
    CFRetain(CFSTR("MIDICIFiltering"));
    CFRetain(CFSTR("com.apple.coremidi"));
    v22 = *((_QWORD *)&xmmword_1EFEFD900 + 1);
    if (*((_QWORD *)&xmmword_1EFEFD900 + 1) < (unint64_t)qword_1EFEFD910)
    {
      std::construct_at[abi:ne180100]<CASmartPreferences::Pref,__CFString const*&,__CFString const*&,std::function<BOOL ()(void const*)> &,CASmartPreferences::Pref*>(*((_QWORD **)&xmmword_1EFEFD900 + 1), (uint64_t)CFSTR("MIDICIFiltering"), (uint64_t)CFSTR("com.apple.coremidi"), &v212);
      v23 = v22 + 48;
      *((_QWORD *)&xmmword_1EFEFD900 + 1) = v22 + 48;
LABEL_49:
      *((_QWORD *)&xmmword_1EFEFD900 + 1) = v23;
      CFSetAddValue((CFMutableSetRef)qword_1EFEFD8F8, CFSTR("com.apple.coremidi"));
      CASmartPreferences::Pref::Load((CFStringRef *)(*((_QWORD *)&xmmword_1EFEFD900 + 1) - 48));
      goto LABEL_50;
    }
    v24 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)&xmmword_1EFEFD900 + 1) - xmmword_1EFEFD900) >> 4);
    if (v24 + 1 > 0x555555555555555)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v25 = 0x5555555555555556 * ((qword_1EFEFD910 - (uint64_t)xmmword_1EFEFD900) >> 4);
    if (v25 <= v24 + 1)
      v25 = v24 + 1;
    if (0xAAAAAAAAAAAAAAABLL * ((qword_1EFEFD910 - (uint64_t)xmmword_1EFEFD900) >> 4) >= 0x2AAAAAAAAAAAAAALL)
      v26 = 0x555555555555555;
    else
      v26 = v25;
    *(_QWORD *)&buf[32] = &qword_1EFEFD910;
    if (v26)
    {
      if (v26 > 0x555555555555555)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v27 = (char *)operator new(48 * v26);
    }
    else
    {
      v27 = 0;
    }
    *(_QWORD *)buf = v27;
    *(_QWORD *)&buf[8] = &v27[48 * v24];
    *(_QWORD *)&buf[16] = *(_QWORD *)&buf[8];
    *(_QWORD *)&buf[24] = &v27[48 * v26];
    std::construct_at[abi:ne180100]<CASmartPreferences::Pref,__CFString const*&,__CFString const*&,std::function<BOOL ()(void const*)> &,CASmartPreferences::Pref*>(*(_QWORD **)&buf[8], (uint64_t)CFSTR("MIDICIFiltering"), (uint64_t)CFSTR("com.apple.coremidi"), &v212);
    v28 = *(_QWORD *)&buf[8];
    v23 = *(_QWORD *)&buf[16] + 48;
    *(_QWORD *)&buf[16] += 48;
    v29 = xmmword_1EFEFD900;
    if (*((_QWORD *)&xmmword_1EFEFD900 + 1) == (_QWORD)xmmword_1EFEFD900)
    {
      v36 = vdupq_n_s64(*((unint64_t *)&xmmword_1EFEFD900 + 1));
LABEL_48:
      *(_QWORD *)&xmmword_1EFEFD900 = v28;
      *((_QWORD *)&xmmword_1EFEFD900 + 1) = v23;
      *(int64x2_t *)&buf[8] = v36;
      v37 = qword_1EFEFD910;
      qword_1EFEFD910 = *(_QWORD *)&buf[24];
      *(_QWORD *)&buf[24] = v37;
      *(_QWORD *)buf = v36.i64[0];
      std::__split_buffer<CASmartPreferences::Pref>::~__split_buffer((uint64_t)buf);
      goto LABEL_49;
    }
    v30 = 0;
    v31 = *((_QWORD *)&xmmword_1EFEFD900 + 1);
    while (1)
    {
      v32 = v28 + v30;
      v33 = *((_QWORD *)&v29 + 1) + v30;
      *(_OWORD *)(v28 + v30 - 48) = *(_OWORD *)(*((_QWORD *)&v29 + 1) + v30 - 48);
      v34 = *(_QWORD *)(*((_QWORD *)&v29 + 1) + v30 - 8);
      if (v34)
      {
        if (v33 - 32 == v34)
        {
          *(_QWORD *)(v32 - 8) = v32 - 32;
          (*(void (**)(_QWORD))(**(_QWORD **)(v33 - 8) + 24))(*(_QWORD *)(v33 - 8));
          goto LABEL_45;
        }
        v35 = (_QWORD *)(v31 - 8);
        *(_QWORD *)(v32 - 8) = v34;
      }
      else
      {
        v35 = (_QWORD *)(v32 - 8);
      }
      *v35 = 0;
LABEL_45:
      v31 -= 48;
      v30 -= 48;
      if (*((_QWORD *)&v29 + 1) + v30 == (_QWORD)v29)
      {
        v28 += v30;
        v36 = (int64x2_t)xmmword_1EFEFD900;
        v23 = *(_QWORD *)&buf[16];
        goto LABEL_48;
      }
    }
  }
  while (!CFEqual(CFSTR("MIDICIFiltering"), *v20) || !CFEqual(CFSTR("com.apple.coremidi"), v20[1]))
  {
    v20 += 6;
    if (v20 == v21)
      goto LABEL_25;
  }
LABEL_50:
  std::mutex::unlock((std::mutex *)&CASmartPreferences::instance(void)::global);
  v38 = v213;
  if (v213 == &v212)
  {
    v39 = 4;
    v38 = &v212;
  }
  else
  {
    if (!v213)
      goto LABEL_55;
    v39 = 5;
  }
  (*(void (**)(void))(v38->__r_.__value_.__r.__words[0] + 8 * v39))();
LABEL_55:
  if (*(_BYTE **)&v222[0] == &v221[8])
  {
    v40 = 4;
  }
  else
  {
    if (!*(_QWORD *)&v222[0])
      goto LABEL_60;
    v40 = 5;
    v13 = *(_QWORD **)&v222[0];
  }
  (*(void (**)(_QWORD *))(*v13 + 8 * v40))(v13);
LABEL_60:
  v41 = v211;
  if (v211 == (SetupManager *)v210)
  {
    v42 = 4;
    v41 = (SetupManager *)v210;
  }
  else
  {
    if (!v211)
      goto LABEL_65;
    v42 = 5;
  }
  v41 = (SetupManager *)(*(uint64_t (**)(void))(*(_QWORD *)v41 + 8 * v42))();
LABEL_65:
  SetupManager::instance(v41);
  v43 = operator new();
  *(_QWORD *)(v43 + 8) = -1;
  *(_QWORD *)(v43 + 16) = "";
  *(_QWORD *)v43 = &off_1E98B9B38;
  CADeprecated::CAMutex::CAMutex((CADeprecated::CAMutex *)(v43 + 24), "Scheduler.mLock");
  *(_QWORD *)(v43 + 128) = 0;
  *(_QWORD *)(v43 + 136) = 0;
  *(_QWORD *)(v43 + 120) = v43 + 128;
  *(_BYTE *)(v43 + 144) = 0;
  v44 = gMIDITimerThread;
  if (!gMIDITimerThread)
  {
    CreateMIDITimerThread();
    v44 = gMIDITimerThread;
  }
  *(_QWORD *)(v43 + 112) = 6000;
  CADeprecated::TimerTaskMgr::AddTask(v44, v43);
  gScheduler = v43;
  gMIDIServerLog();
  v45 = objc_retainAutorelease((id)gMIDIServerLog(void)::mdsrvr);
  if (os_log_type_enabled(v45, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = "MIDIServer.mm";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 324;
    _os_log_impl(&dword_1D4E88000, v45, OS_LOG_TYPE_INFO, "%25s:%-5d Loading driver plugins ...", buf, 0x12u);
  }
  v46 = operator new();
  *(_BYTE *)v46 = 0;
  *(_OWORD *)(v46 + 8) = 0u;
  *(_OWORD *)(v46 + 24) = 0u;
  *(_OWORD *)(v46 + 40) = 0u;
  *(_OWORD *)(v46 + 56) = 0u;
  v47 = operator new();
  *(_QWORD *)v47 = off_1E98B9DE0;
  CADeprecated::CAPThread::CAPThread((CADeprecated::CAPThread *)v47, (void *(*)(void *))v47, (void *)0x1F, v48, v49, v50, v51);
  *(_QWORD *)(v47 + 128) = "DriverIOThread";
  *(_BYTE *)(v47 + 136) = 0;
  *(_QWORD *)v47 = &off_1E98B95E0;
  *(_QWORD *)(v47 + 144) = 0;
  *(_QWORD *)(v46 + 8) = v47;
  CADeprecated::CAPThread::SetTimeConstraints((CADeprecated::CAPThread *)v47, 0, 6000, 12000, 1);
  v52 = CADeprecated::CAPThread::Start(v47);
  while (!*(_QWORD *)(*(_QWORD *)(v46 + 8) + 144))
    v52 = usleep(0x2710u);
  *(_QWORD *)v221 = v46;
  v53 = MIDIServer::defaultInstance((MIDIServer *)v52);
  v54 = std::unique_ptr<MIDIDriverMgr>::reset[abi:ne180100](v53 + 33, v46);
  v55 = (int64x2_t *)MIDIServer::defaultInstance((MIDIServer *)v54)[33];
  v207 = 0uLL;
  v208 = 0;
  v214 = 0;
  cf = 0;
  v216 = 0;
  findPluginsInDirectory("/System/Library/Audio/MIDI Drivers", (char **)&v214);
  v56 = getenv("HOME");
  if (v56)
  {
    std::string::basic_string[abi:ne180100]<0>(&v212, v56);
    v57 = std::string::append(&v212, "/", 1uLL);
    v58 = *(_OWORD *)&v57->__r_.__value_.__l.__data_;
    *(_QWORD *)&v221[16] = *((_QWORD *)&v57->__r_.__value_.__l + 2);
    *(_OWORD *)v221 = v58;
    v57->__r_.__value_.__l.__size_ = 0;
    v57->__r_.__value_.__r.__words[2] = 0;
    v57->__r_.__value_.__r.__words[0] = 0;
    v59 = std::string::append((std::string *)v221, "/Library/Audio/MIDI Drivers", 0x1BuLL);
    v60 = *(_OWORD *)&v59->__r_.__value_.__l.__data_;
    *(_QWORD *)&buf[16] = *((_QWORD *)&v59->__r_.__value_.__l + 2);
    *(_OWORD *)buf = v60;
    v59->__r_.__value_.__l.__size_ = 0;
    v59->__r_.__value_.__r.__words[2] = 0;
    v59->__r_.__value_.__r.__words[0] = 0;
    if (buf[23] >= 0)
      v61 = buf;
    else
      v61 = *(const char **)buf;
    findPluginsInDirectory(v61, (char **)&v214);
    if ((buf[23] & 0x80000000) != 0)
      operator delete(*(void **)buf);
    if ((v221[23] & 0x80000000) != 0)
      operator delete(*(void **)v221);
    if (SHIBYTE(v212.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v212.__r_.__value_.__l.__data_);
  }
  v62 = (char *)v214;
  v63 = (char *)cf;
  if (v214 != cf)
  {
    key = (void *)*MEMORY[0x1E0C9AE78];
    do
    {
      v64 = (const __CFUUID *)*((_QWORD *)v62 + 2);
      v65 = CFUUIDGetConstantUUIDWithBytes(0, 0xECu, 0xDEu, 0x95u, 0x74u, 0xFu, 0xE4u, 0x11u, 0xD4u, 0xBBu, 0x1Au, 0, 0x50u, 0xE4u, 0xCEu, 0xA5u, 0x26u);
      v66 = CFPlugInInstanceCreate(0, v64, v65);
      gDriverPlugin();
      v67 = gDriverPlugin(void)::drvtbl;
      if (v66)
      {
        if (os_log_type_enabled((os_log_t)gDriverPlugin(void)::drvtbl, OS_LOG_TYPE_DEBUG))
        {
          v68 = *(CFURLRef *)v62;
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = "MIDIDriverPlugin_CFPlugin.cpp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 265;
          *(_WORD *)&buf[18] = 2112;
          *(_QWORD *)&buf[20] = v68;
          _os_log_impl(&dword_1D4E88000, v67, OS_LOG_TYPE_DEBUG, "%25s:%-5d Opening driver plugin %@", buf, 0x1Cu);
        }
        v212.__r_.__value_.__r.__words[0] = 0;
        gDriverPlugin();
        v69 = gDriverPlugin(void)::drvtbl;
        if (os_log_type_enabled((os_log_t)gDriverPlugin(void)::drvtbl, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = "MIDIDriverPlugin_CFPlugin.cpp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 270;
          _os_log_impl(&dword_1D4E88000, v69, OS_LOG_TYPE_DEBUG, "%25s:%-5d V3 driver support enabled.", buf, 0x12u);
        }
        v70 = *(void (**)(void *, _QWORD, _QWORD, std::string *))(*(_QWORD *)v66 + 8);
        v71 = CFUUIDGetConstantUUIDWithBytes(0, 0x2Fu, 0xD9u, 0x4Du, 0xFu, 0x8Cu, 0x2Au, 0x48u, 0x2Au, 0x8Au, 0xD8u, 0x7Du, 0x9Eu, 0xA3u, 0x81u, 0xC9u, 0xC1u);
        v72 = CFUUIDGetUUIDBytes(v71);
        v70(v66, *(_QWORD *)&v72.byte0, *(_QWORD *)&v72.byte8, &v212);
        if (v212.__r_.__value_.__r.__words[0])
        {
          v73 = 3;
          goto LABEL_97;
        }
        v75 = *(void (**)(void *, _QWORD, _QWORD, std::string *))(*(_QWORD *)v66 + 8);
        v76 = CFUUIDGetConstantUUIDWithBytes(0, 0x43u, 0xC9u, 0x8Cu, 0x3Cu, 0x30u, 0x6Cu, 0x11u, 0xD5u, 0xAFu, 0x73u, 0, 0x30u, 0x65u, 0xA8u, 0x30u, 0x1Eu);
        v77 = CFUUIDGetUUIDBytes(v76);
        v75(v66, *(_QWORD *)&v77.byte0, *(_QWORD *)&v77.byte8, &v212);
        if (v212.__r_.__value_.__r.__words[0])
        {
          v73 = 2;
          goto LABEL_97;
        }
        v78 = *(void (**)(void *, _QWORD, _QWORD, std::string *))(*(_QWORD *)v66 + 8);
        v79 = CFUUIDGetConstantUUIDWithBytes(0, 0x49u, 0xDFu, 0xCAu, 0x9Eu, 0xFu, 0xE5u, 0x11u, 0xD4u, 0x95u, 0xDu, 0, 0x50u, 0xE4u, 0xCEu, 0xA5u, 0x26u);
        v80 = CFUUIDGetUUIDBytes(v79);
        v78(v66, *(_QWORD *)&v80.byte0, *(_QWORD *)&v80.byte8, &v212);
        if (v212.__r_.__value_.__r.__words[0])
        {
          v73 = 1;
LABEL_97:
          Bundle = CFPlugInGetBundle(*((CFPlugInRef *)v62 + 1));
          if (Bundle
            && (InfoDictionary = CFBundleGetInfoDictionary(Bundle),
                (Value = (const __CFString *)CFDictionaryGetValue(InfoDictionary, key)) != 0))
          {
            PathComponent = CFURLCopyLastPathComponent(*(CFURLRef *)v62);
          }
          else
          {
            Value = CFURLCopyLastPathComponent(*(CFURLRef *)v62);
            PathComponent = 0;
          }
          (*(void (**)(void *))(*(_QWORD *)v66 + 24))(v66);
          v85 = operator new();
          v86 = v212.__r_.__value_.__r.__words[0];
          MIDIObject::MIDIObject((MIDIObject *)v85, 0, Value);
          *(_QWORD *)(v85 + 48) = PathComponent;
          *(_BYTE *)(v85 + 56) = 1;
          *(_DWORD *)(v85 + 64) = v73;
          *(_QWORD *)v85 = &off_1E98B6C88;
          *(_QWORD *)(v85 + 72) = v86;
          *(_QWORD *)(v85 + 80) = 0;
          *(_QWORD *)(v85 + 88) = 0;
          *(_DWORD *)(v85 + 96) = 0;
          MIDIObject::SetProperty((MIDIObject *)v85, kMIDIPropertyDriverVersion, v73);
          v87 = operator new(0x358uLL);
          v87[1] = 0;
          v87[2] = 0;
          *v87 = &off_1E98BA040;
          v87[3] = &off_1E98B9EC8;
          v87[4] = caulk::inplace_function<void ()(MIDI::LegacyPacketList const*),48ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<MIDIDriverPlugin_CFPlugin::MIDIDriverPlugin_CFPlugin(__CFString const*,__CFString const*,MIDIDriverInterface **,int)::{lambda(MIDIPacketList const*)#1}>;
          v87[5] = v85;
          bzero(v87 + 11, 0x300uLL);
          *(_QWORD *)&v88 = v87 + 3;
          *((_QWORD *)&v88 + 1) = v87;
          v89 = *(std::__shared_weak_count **)(v85 + 88);
          *(_OWORD *)(v85 + 80) = v88;
          if (v89)
          {
            p_shared_owners = (unint64_t *)&v89->__shared_owners_;
            do
              v91 = __ldaxr(p_shared_owners);
            while (__stlxr(v91 - 1, p_shared_owners));
            if (!v91)
            {
              ((void (*)(std::__shared_weak_count *))v89->__on_zero_shared)(v89);
              std::__shared_weak_count::__release_weak(v89);
            }
          }
          *(_QWORD *)v221 = v85;
          driverMap();
          v92 = *(_QWORD *)(v85 + 72);
          v93 = qword_1EFEFCC38;
          if (qword_1EFEFCC38)
          {
            while (1)
            {
              while (1)
              {
                v94 = (uint64_t *)v93;
                v95 = *(_QWORD *)(v93 + 32);
                if (v92 >= v95)
                  break;
                v93 = *v94;
                v96 = v94;
                if (!*v94)
                  goto LABEL_114;
              }
              if (v95 >= v92)
                break;
              v93 = v94[1];
              if (!v93)
              {
                v96 = v94 + 1;
                goto LABEL_114;
              }
            }
            v97 = v94;
          }
          else
          {
            v96 = &qword_1EFEFCC38;
            v94 = &qword_1EFEFCC38;
LABEL_114:
            v97 = (uint64_t *)operator new(0x30uLL);
            v97[4] = v92;
            v97[5] = 0;
            *v97 = 0;
            v97[1] = 0;
            v97[2] = (uint64_t)v94;
            *v96 = (uint64_t)v97;
            v98 = v97;
            if (*(_QWORD *)driverMap(void)::sDriverMap)
            {
              driverMap(void)::sDriverMap = *(_QWORD *)driverMap(void)::sDriverMap;
              v98 = (uint64_t *)*v96;
            }
            std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)qword_1EFEFCC38, v98);
            ++qword_1EFEFCC40;
          }
          v97[5] = v85;
          *(_QWORD *)v221 = 0;
          v99 = v207.i64[1];
          if (v207.i64[1] >= v208)
          {
            v100 = (v207.i64[1] - v207.i64[0]) >> 3;
            v101 = v100 + 1;
            if ((unint64_t)(v100 + 1) >> 61)
              std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
            v102 = v208 - v207.i64[0];
            if ((uint64_t)(v208 - v207.i64[0]) >> 2 > v101)
              v101 = v102 >> 2;
            if ((unint64_t)v102 >= 0x7FFFFFFFFFFFFFF8)
              v103 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v103 = v101;
            *(_QWORD *)&buf[32] = &v208;
            if (v103)
              v103 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v103);
            else
              v104 = 0;
            v105 = (uint64_t *)(v103 + 8 * v100);
            v106 = v103 + 8 * v104;
            *(_QWORD *)&buf[24] = v106;
            *v105 = v85;
            v107 = v105 + 1;
            *(_QWORD *)&buf[16] = v105 + 1;
            v108 = (_QWORD *)v207.i64[1];
            v109 = (_QWORD *)v207.i64[0];
            if (v207.i64[1] == v207.i64[0])
            {
              v112 = 0;
              v111 = vdupq_n_s64(v207.u64[1]);
            }
            else
            {
              do
              {
                v110 = *--v108;
                *v108 = 0;
                *--v105 = v110;
              }
              while (v108 != v109);
              v111 = v207;
              v107 = *(_QWORD **)&buf[16];
              v106 = *(_QWORD *)&buf[24];
              v112 = *(MIDIDriverPlugin_CFPlugin **)v221;
            }
            v207.i64[0] = (uint64_t)v105;
            v207.i64[1] = (uint64_t)v107;
            *(int64x2_t *)&buf[8] = v111;
            v113 = v208;
            v208 = v106;
            *(_QWORD *)&buf[24] = v113;
            *(_QWORD *)buf = v111.i64[0];
            std::__split_buffer<std::unique_ptr<MIDIDriverPlugin>>::~__split_buffer((uint64_t)buf);
            v207.i64[1] = (uint64_t)v107;
            if (v112)
            {
              MIDIDriverPlugin_CFPlugin::~MIDIDriverPlugin_CFPlugin(v112);
              MEMORY[0x1D826BA98]();
            }
          }
          else
          {
            *(_QWORD *)v207.i64[1] = v85;
            v207.i64[1] = v99 + 8;
          }
        }
      }
      else if (os_log_type_enabled((os_log_t)gDriverPlugin(void)::drvtbl, OS_LOG_TYPE_ERROR))
      {
        v74 = *(CFURLRef *)v62;
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "MIDIDriverPlugin_CFPlugin.cpp";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 261;
        *(_WORD *)&buf[18] = 2112;
        *(_QWORD *)&buf[20] = v74;
        _os_log_impl(&dword_1D4E88000, v67, OS_LOG_TYPE_ERROR, "%25s:%-5d Failed to create instance for %@", buf, 0x1Cu);
      }
      v62 += 24;
    }
    while (v62 != v63);
  }
  *(_QWORD *)buf = &v214;
  std::vector<CFPlugin>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
  v115 = (uint64_t *)v207.i64[1];
  v114 = (uint64_t *)v207.i64[0];
  if (v207.i64[0] != v207.i64[1])
  {
    v116 = v55 + 2;
    v117 = (_QWORD *)v55[1].i64[1];
    do
    {
      if ((unint64_t)v117 >= v116->i64[0])
      {
        v119 = v55[1].i64[0];
        v120 = ((uint64_t)v117 - v119) >> 3;
        if ((unint64_t)(v120 + 1) >> 61)
          std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
        v121 = v116->i64[0] - v119;
        v122 = v121 >> 2;
        if (v121 >> 2 <= (unint64_t)(v120 + 1))
          v122 = v120 + 1;
        if ((unint64_t)v121 >= 0x7FFFFFFFFFFFFFF8)
          v123 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v123 = v122;
        *(_QWORD *)&buf[32] = v55 + 2;
        if (v123)
          v123 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v123);
        else
          v124 = 0;
        v125 = (_QWORD *)(v123 + 8 * v120);
        v126 = v123 + 8 * v124;
        *(_QWORD *)&buf[24] = v126;
        v127 = *v114;
        *v114 = 0;
        *v125 = v127;
        v117 = v125 + 1;
        *(_QWORD *)&buf[16] = v125 + 1;
        v129 = (_QWORD *)v55[1].i64[0];
        v128 = (_QWORD *)v55[1].i64[1];
        if (v128 == v129)
        {
          v131 = vdupq_n_s64((unint64_t)v128);
        }
        else
        {
          do
          {
            v130 = *--v128;
            *v128 = 0;
            *--v125 = v130;
          }
          while (v128 != v129);
          v131 = v55[1];
          v117 = *(_QWORD **)&buf[16];
          v126 = *(_QWORD *)&buf[24];
        }
        v55[1].i64[0] = (uint64_t)v125;
        v55[1].i64[1] = (uint64_t)v117;
        *(int64x2_t *)&buf[8] = v131;
        v132 = v55[2].i64[0];
        v55[2].i64[0] = v126;
        *(_QWORD *)&buf[24] = v132;
        *(_QWORD *)buf = v131.i64[0];
        std::__split_buffer<std::unique_ptr<MIDIDriverPlugin>>::~__split_buffer((uint64_t)buf);
      }
      else
      {
        v118 = *v114;
        *v114 = 0;
        *v117++ = v118;
      }
      v55[1].i64[1] = (uint64_t)v117;
      ++v114;
    }
    while (v114 != v115);
  }
  *(_QWORD *)buf = &v207;
  std::vector<std::unique_ptr<MIDIDriverPlugin>>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
  if (_os_feature_enabled_impl())
  {
    v133 = operator new();
    *(_QWORD *)v133 = v55;
    *(_QWORD *)(v133 + 8) = 0;
    v134 = (uint64_t *)(v133 + 8);
    v135 = MEMORY[0x1E0C809B0];
    *(_QWORD *)(v133 + 16) = 0;
    *(_QWORD *)buf = v135;
    *(_QWORD *)&buf[8] = 3221225472;
    *(_QWORD *)&buf[16] = ___ZN28MIDIDriverKitPluginRegistrarC2ER13MIDIDriverMgr_block_invoke;
    *(_QWORD *)&buf[24] = &__block_descriptor_40_e30_v16__0r__MIDINotification_iI_8l;
    *(_QWORD *)&buf[32] = v133;
    v136 = MIDIClientCreateWithBlockInternal(CFSTR("MIDIDriverKitPluginRegistrar"), (int *)(v133 + 24), buf, 0);
    if (v136)
    {
      midiDriverKitLog();
      v137 = objc_retainAutorelease((id)midiDriverKitLog(void)::category);
      if (os_log_type_enabled(v137, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v221 = 136315650;
        *(_QWORD *)&v221[4] = "MIDIDriverPlugin_DriverKit.mm";
        *(_WORD *)&v221[12] = 1024;
        *(_DWORD *)&v221[14] = 1561;
        *(_WORD *)&v221[18] = 1024;
        *(_DWORD *)&v221[20] = v136;
        _os_log_impl(&dword_1D4E88000, v137, OS_LOG_TYPE_ERROR, "%25s:%-5d Unable to create client for MIDIDriverKitPluginRegistrar (err = %d).", v221, 0x18u);
      }
    }
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)v221, "IOClass");
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v221[8], "IOUserUserClient");
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v221[16], "IOUserClass");
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v221[24], "IOUserMIDIDriverUserClient");
    v209[0] = v221;
    v209[1] = 2;
    CFDictionaryRef = applesauce::CF::details::make_CFDictionaryRef((uint64_t)v209);
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v217, "IOUserMIDIDriverUserClientProperties");
    if (CFDictionaryRef)
      CFRetain(CFDictionaryRef);
    v218 = CFDictionaryRef;
    v207.i64[0] = (uint64_t)&v217;
    v207.i64[1] = 1;
    v139 = applesauce::CF::details::make_CFDictionaryRef((uint64_t)&v207);
    applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v214, "IOPropertyMatch");
    if (v139)
      CFRetain(v139);
    cf = v139;
    v212.__r_.__value_.__r.__words[0] = (std::string::size_type)&v214;
    v212.__r_.__value_.__l.__size_ = 1;
    v140 = applesauce::CF::details::make_CFDictionaryRef((uint64_t)&v212);
    if (cf)
      CFRelease(cf);
    if (v214)
      CFRelease(v214);
    if (v139)
      CFRelease(v139);
    if (v218)
      CFRelease(v218);
    if (v217)
      CFRelease(v217);
    if (CFDictionaryRef)
      CFRelease(CFDictionaryRef);
    for (i = 0; i != -32; i -= 16)
    {
      v142 = *(const void **)&v221[i + 24];
      if (v142)
        CFRelease(v142);
      v143 = *(const void **)&v221[i + 16];
      if (v143)
        CFRelease(v143);
    }
    v144 = operator new();
    CFRetain(v140);
    v212.__r_.__value_.__r.__words[0] = (std::string::size_type)v140;
    *(_QWORD *)v221 = &off_1E98B72A8;
    *(_QWORD *)&v221[8] = v133;
    *(_QWORD *)&v221[24] = v221;
    applesauce::iokit::io_service_factory::io_service_factory(v144, (const __CFDictionary **)&v212, "IOServiceFirstMatch", (uint64_t)v221);
    v145 = *(_QWORD **)&v221[24];
    if (*(_BYTE **)&v221[24] == v221)
    {
      v146 = 4;
      v145 = v221;
    }
    else
    {
      if (!*(_QWORD *)&v221[24])
        goto LABEL_186;
      v146 = 5;
    }
    (*(void (**)(void))(*v145 + 8 * v146))();
LABEL_186:
    if (v212.__r_.__value_.__r.__words[0])
      CFRelease(v212.__r_.__value_.__l.__data_);
    v147 = *v134;
    *v134 = v144;
    if (v147)
      std::default_delete<applesauce::iokit::io_service_factory>::operator()[abi:ne180100](v147);
    v148 = operator new();
    CFRetain(v140);
    v212.__r_.__value_.__r.__words[0] = (std::string::size_type)v140;
    *(_QWORD *)v221 = &off_1E98B72F0;
    *(_QWORD *)&v221[8] = v133;
    *(_QWORD *)&v221[24] = v221;
    applesauce::iokit::io_service_factory::io_service_factory(v148, (const __CFDictionary **)&v212, "IOServiceTerminate", (uint64_t)v221);
    v149 = *(_QWORD **)&v221[24];
    if (*(_BYTE **)&v221[24] == v221)
    {
      v150 = 4;
      v149 = v221;
    }
    else
    {
      if (!*(_QWORD *)&v221[24])
      {
LABEL_195:
        if (v212.__r_.__value_.__r.__words[0])
          CFRelease(v212.__r_.__value_.__l.__data_);
        v151 = *(_QWORD *)(v133 + 16);
        *(_QWORD *)(v133 + 16) = v148;
        if (v151)
          std::default_delete<applesauce::iokit::io_service_factory>::operator()[abi:ne180100](v151);
        CFRelease(v140);
        std::unique_ptr<MIDIDriverKitPluginRegistrar>::reset[abi:ne180100](v55[4].i64, v133);
        goto LABEL_200;
      }
      v150 = 5;
    }
    (*(void (**)(void))(*v149 + 8 * v150))();
    goto LABEL_195;
  }
LABEL_200:
  v152 = operator new();
  MIDISetup::MIDISetup((MIDISetup *)v152);
  *(_BYTE *)(v152 + 216) = 1;
  v153 = (const __CFString *)*MEMORY[0x1E0C9B260];
  v154 = (const __CFString *)*MEMORY[0x1E0C9B250];
  v155 = (const __CFString *)CFPreferencesCopyValue(CFSTR("CurrentSetupFilename"), CFSTR("com.apple.MIDI"), (CFStringRef)*MEMORY[0x1E0C9B260], (CFStringRef)*MEMORY[0x1E0C9B250]);
  if (v155)
  {
    buf[0] = 0;
    gMIDISetup();
    v156 = gMIDISetup(void)::midiso;
    if (os_log_type_enabled((os_log_t)gMIDISetup(void)::midiso, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)v221 = 136315650;
      *(_QWORD *)&v221[4] = "MIDISetup.cpp";
      *(_WORD *)&v221[12] = 1024;
      *(_DWORD *)&v221[14] = 789;
      *(_WORD *)&v221[18] = 2112;
      *(_QWORD *)&v221[20] = v155;
      _os_log_impl(&dword_1D4E88000, v156, OS_LOG_TYPE_DEBUG, "%25s:%-5d Searching for config %@", v221, 0x1Cu);
    }
    MIDIConfigGetFullPathToFile(v155, buf);
    gMIDISetup();
    v157 = gMIDISetup(void)::midiso;
    if (os_log_type_enabled((os_log_t)gMIDISetup(void)::midiso, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)v221 = 136315650;
      *(_QWORD *)&v221[4] = "MIDISetup.cpp";
      *(_WORD *)&v221[12] = 1024;
      *(_DWORD *)&v221[14] = 791;
      *(_WORD *)&v221[18] = 2080;
      *(_QWORD *)&v221[20] = buf;
      _os_log_impl(&dword_1D4E88000, v157, OS_LOG_TYPE_DEBUG, "%25s:%-5d Reading file %s", v221, 0x1Cu);
    }
    FileIntoCFData = ReadFileIntoCFData(buf);
    if (FileIntoCFData)
    {
      gMIDISetup();
      v159 = gMIDISetup(void)::midiso;
      if (os_log_type_enabled((os_log_t)gMIDISetup(void)::midiso, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)v221 = 136315650;
        *(_QWORD *)&v221[4] = "MIDISetup.cpp";
        *(_WORD *)&v221[12] = 1024;
        *(_DWORD *)&v221[14] = 794;
        *(_WORD *)&v221[18] = 2080;
        *(_QWORD *)&v221[20] = buf;
        _os_log_impl(&dword_1D4E88000, v159, OS_LOG_TYPE_DEBUG, "%25s:%-5d Read config from %s", v221, 0x1Cu);
      }
      MIDISetup::FromData((MIDISetup *)v152, FileIntoCFData);
      CFRelease(FileIntoCFData);
      *(_QWORD *)(v152 + 208) = CFStringCreateCopy(0, v155);
      CFRelease(v155);
      goto LABEL_229;
    }
    CFRelease(v155);
    gMIDISetup();
    v160 = gMIDISetup(void)::midiso;
    if (os_log_type_enabled((os_log_t)gMIDISetup(void)::midiso, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)v221 = 136315650;
      *(_QWORD *)&v221[4] = "MIDISetup.cpp";
      *(_WORD *)&v221[12] = 1024;
      *(_DWORD *)&v221[14] = 805;
      *(_WORD *)&v221[18] = 2080;
      *(_QWORD *)&v221[20] = buf;
      _os_log_impl(&dword_1D4E88000, v160, OS_LOG_TYPE_DEBUG, "%25s:%-5d failed to read config from %s", v221, 0x1Cu);
    }
    CFPreferencesSetValue(CFSTR("CurrentSetupFilename"), 0, CFSTR("com.apple.MIDI"), v153, v154);
    CFRelease(*(CFTypeRef *)(v152 + 208));
    *(_QWORD *)(v152 + 208) = &stru_1E98BB0B0;
  }
  propertyList = CFPreferencesCopyValue(CFSTR("MIDISetup"), CFSTR("com.apple.MIDI"), v153, v154);
  if (propertyList)
  {
    gMIDISetup();
    v161 = gMIDISetup(void)::midiso;
    if (os_log_type_enabled((os_log_t)gMIDISetup(void)::midiso, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "MIDISetup.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 818;
      _os_log_impl(&dword_1D4E88000, v161, OS_LOG_TYPE_DEBUG, "%25s:%-5d Loading MIDISetup from prefs", buf, 0x12u);
    }
    keya = (void *)CFPropertyListCreateDeepCopy(0, propertyList, 2uLL);
    objc_msgSend(keya, "objectForKeyedSubscript:", CFSTR("devices"));
    v162 = (void *)objc_claimAutoreleasedReturnValue();
    v163 = v162;
    if (v162)
    {
      memset(v222, 0, sizeof(v222));
      memset(v221, 0, sizeof(v221));
      v164 = objc_msgSend(v162, "countByEnumeratingWithState:objects:count:", v221, buf, 16);
      if (v164)
      {
        v165 = **(_QWORD **)&v221[16];
        do
        {
          for (j = 0; j != v164; ++j)
          {
            if (**(_QWORD **)&v221[16] != v165)
              objc_enumerationMutation(v163);
            objc_msgSend(*(id *)(*(_QWORD *)&v221[8] + 8 * j), "objectForKeyedSubscript:", CFSTR("apple.midirtp.addressbook"));
            v167 = (void *)objc_claimAutoreleasedReturnValue();
            v168 = v167;
            if (v167)
            {
              objc_msgSend(v167, "objectForKeyedSubscript:", CFSTR("entries"));
              v169 = (void *)objc_claimAutoreleasedReturnValue();
              v170 = v169;
              if (v169 && (unint64_t)objc_msgSend(v169, "count") >= 0xC9)
              {
                objc_msgSend(v170, "subarrayWithRange:", 0, 200);
                v171 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v168, "setObject:forKeyedSubscript:", v171, CFSTR("entries"));

              }
            }

          }
          v164 = objc_msgSend(v163, "countByEnumeratingWithState:objects:count:", v221, buf, 16);
        }
        while (v164);
      }
    }

    CFRelease(propertyList);
    (*(void (**)(uint64_t, void *))(*(_QWORD *)v152 + 64))(v152, keya);
    CFRelease(keya);
    MIDISetup::CreationEffects((MIDISetup *)v152);
  }
LABEL_229:
  *(_BYTE *)(v152 + 216) = 0;
  gMIDIServerLog();
  v172 = objc_retainAutorelease((id)gMIDIServerLog(void)::mdsrvr);
  if (os_log_type_enabled(v172, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = "MIDIServer.mm";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 335;
    _os_log_impl(&dword_1D4E88000, v172, OS_LOG_TYPE_INFO, "%25s:%-5d      MIDIServer is scanning for driver devices...", buf, 0x12u);
  }
  v173 = mach_absolute_time();
  MIDISetup::ScanForDriverDevices((MIDISetup *)v152);
  gMIDIServerLog();
  v174 = objc_retainAutorelease((id)gMIDIServerLog(void)::mdsrvr);
  v175 = os_log_type_enabled(v174, OS_LOG_TYPE_INFO);
  if (v175)
  {
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = "MIDIServer.mm";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 338;
    _os_log_impl(&dword_1D4E88000, v174, OS_LOG_TYPE_INFO, "%25s:%-5d           Installing setup...", buf, 0x12u);
  }
  v176 = (SetupManager *)SetupManager::instance((SetupManager *)v175);
  SetupManager::Install(v176, (MIDISetup *)v152, 1);
  v177 = mach_absolute_time();
  gMIDIServerLog();
  v178 = objc_retainAutorelease((id)gMIDIServerLog(void)::mdsrvr);
  if (os_log_type_enabled(v178, OS_LOG_TYPE_INFO))
  {
    v179 = __udivti3();
    if (v177 >= v173)
      v180 = v179;
    else
      v180 = -v179;
    *(_QWORD *)&buf[4] = "MIDIServer.mm";
    *(_DWORD *)buf = 136315650;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 341;
    *(_WORD *)&buf[18] = 2048;
    *(_QWORD *)&buf[20] = v180 / 1000;
    _os_log_impl(&dword_1D4E88000, v178, OS_LOG_TYPE_INFO, "%25s:%-5d      Took %llu microseconds to scan for driver devices.", buf, 0x1Cu);
  }
  v181 = operator new();
  *(_QWORD *)v181 = off_1E98B9DE0;
  CADeprecated::CAPThread::CAPThread((CADeprecated::CAPThread *)v181, (void *(*)(void *))v181, (void *)0x1F, v182, v183, v184, v185);
  *(_QWORD *)(v181 + 128) = "MIDIIOThread";
  *(_WORD *)(v181 + 136) = 0;
  *(_QWORD *)v181 = &off_1E98B94F8;
  *(_DWORD *)(v181 + 140) = 0;
  *(_DWORD *)(v181 + 144) = 0;
  if ((v186 & 1) == 0
  {
    createDefaultDoWithResolvedClientFunction(void)::version = CoreMIDIServerImplVersion();
  }
  if (createDefaultDoWithResolvedClientFunction(void)::version == 1)
    v187 = &off_1E98B86A8;
  else
    v187 = &off_1E98B86F0;
  *(_QWORD *)(v181 + 152) = v187;
  *(_QWORD *)(v181 + 176) = v181 + 152;
  gMIDIIOThread = v181;
  gMIDIServerLog();
  v188 = objc_retainAutorelease((id)gMIDIServerLog(void)::mdsrvr);
  if (os_log_type_enabled(v188, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = "MIDIServer.mm";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 345;
    _os_log_impl(&dword_1D4E88000, v188, OS_LOG_TYPE_INFO, "%25s:%-5d      Starting I/O thread...", buf, 0x12u);
  }
  (*(void (**)(uint64_t))(*(_QWORD *)gMIDIIOThread + 16))(gMIDIIOThread);
  while (!*(_BYTE *)(gMIDIIOThread + 137) && !*(_DWORD *)(gMIDIIOThread + 140))
    usleep(0x3E8u);
  v189 = mach_absolute_time();
  v190 = __udivti3();
  if (v189 >= v177)
    LODWORD(v191) = v190;
  else
    v191 = -v190;
  v192 = (SetupManager *)((int)v191 / -1000 + 500000);
  if ((int)v192 >= 1)
    v192 = (SetupManager *)usleep((useconds_t)v192);
  *(_BYTE *)(SetupManager::instance(v192) + 80) = 0;
  if (!gWatchdog)
  {
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    *(_QWORD *)&buf[8] = 0x40000000;
    *(_QWORD *)&buf[16] = __MIDIClientCreate_block_invoke;
    *(_QWORD *)&buf[24] = &__block_descriptor_tmp_2629;
    *(_QWORD *)&buf[32] = MIDIServer::WatchdogNotifyCallback;
    v220 = 0;
    MIDIClientCreateWithBlockInternal(CFSTR("Watchdog"), &gWatchdog, buf, 0);
  }
  gMIDIServerLog();
  v193 = objc_retainAutorelease((id)gMIDIServerLog(void)::mdsrvr);
  if (os_log_type_enabled(v193, OS_LOG_TYPE_INFO))
  {
    v194 = getpid();
    *(_DWORD *)buf = 136315650;
    *(_QWORD *)&buf[4] = "MIDIServer.mm";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 373;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v194;
    _os_log_impl(&dword_1D4E88000, v193, OS_LOG_TYPE_INFO, "%25s:%-5d FullInit() - MIDIServer [%d] started", buf, 0x18u);
  }

  if (v201)
  {
    if (v200 < 0)
      operator delete(__p);
  }
}

void sub_1D4EBF2E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,CFTypeRef cf,uint64_t a40,int a41,__int16 a42,char a43,char a44,uint64_t a45,CFTypeRef a46,CFTypeRef a47,uint64_t a48,CFTypeRef a49,CFTypeRef a50,void *a51,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  uint64_t v56;

  MEMORY[0x1D826BA98](v56, 0x10F1C40C0916F0ALL);
  if (a25)
  {
    if (a24 < 0)
      operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t *MIDIServer::defaultInstance(MIDIServer *this)
{
  unsigned __int8 v1;
  unsigned __int8 v2;
  unsigned __int8 v4;
  MIDIServerMIG *v5;
  uint64_t *v6;
  __guard *v7;
  MIDIServerXPCAssembly *v8;

  {
    MIDIServer::defaultInstance(int)::cachedVersion = CoreMIDIServerImplVersion();
  }
  if (MIDIServer::defaultInstance(int)::cachedVersion == 1)
  {
    if ((v2 & 1) != 0)
      return (uint64_t *)&MIDIServer::defaultInstance(int)::migServer;
    if (!(_DWORD)v5)
      return (uint64_t *)&MIDIServer::defaultInstance(int)::migServer;
    MIDIServerMIG::MIDIServerMIG(v5);
    v6 = (uint64_t *)&MIDIServer::defaultInstance(int)::migServer;
  }
  else
  {
    if ((v4 & 1) != 0)
      return MIDIServer::defaultInstance(int)::xpcServer;
    if (!(_DWORD)v8)
      return MIDIServer::defaultInstance(int)::xpcServer;
    MIDIServerXPCAssembly::MIDIServerXPCAssembly(v8);
    v6 = MIDIServer::defaultInstance(int)::xpcServer;
  }
  __cxa_guard_release(v7);
  return v6;
}

void sub_1D4EBF9B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void MIDIServer::WatchdogNotifyCallback(MIDIServer *this, const MIDINotification *a2, void *a3)
{
  MIDIObjectRef v4;
  MIDIServer *v5;
  MIDIServer *v6;
  MIDIServer *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  MIDIObjectRef v14;
  MIDIServer *v15;
  MIDIServer *v16;
  MIDIServer *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  CFStringRef str;

  if (*(_DWORD *)this == 3)
  {
    v14 = *((_DWORD *)this + 4);
    str = 0;
    if (MIDIObjectGetStringProperty(v14, kMIDIPropertyDriverOwner, &str))
      return;
    v15 = (MIDIServer *)CFEqual(str, CFSTR("com.apple.AppleMIDIBluetoothDriver"));
    if (!(_DWORD)v15)
      goto LABEL_31;
    v16 = (MIDIServer *)MIDIServer::USBDeviceCount(v15);
    if ((_DWORD)v16)
      goto LABEL_31;
    v17 = (MIDIServer *)MIDIServer::BluetoothDeviceCount(v16);
    if ((_DWORD)v17)
      goto LABEL_31;
    v8 = MIDIServer::defaultInstance(v17);
    v19 = v8[25];
    v18 = v8[26];
    if (v19 == v18)
      goto LABEL_30;
    v20 = v19 + 8;
    do
    {
      v12 = *(_QWORD *)(*(_QWORD *)(v20 - 8) + 48);
      if (v12)
        v21 = 1;
      else
        v21 = v20 == v18;
      v20 += 8;
    }
    while (!v21);
LABEL_29:
    if (v12)
    {
LABEL_31:
      CFRelease(str);
      return;
    }
LABEL_30:
    ScheduleCheckServerShutdown((MIDIServer *)v8);
    goto LABEL_31;
  }
  if (*(_DWORD *)this == 4)
  {
    v4 = *((_DWORD *)this + 2);
    str = 0;
    if (!MIDIObjectGetStringProperty(v4, kMIDIPropertyDriverOwner, &str))
    {
      if (!CFEqual(str, CFSTR("com.apple.AppleMIDIUSBDriver"))
        && !CFEqual(str, CFSTR("com.apple.YamahaUSBMIDIDriver"))
        && !CFEqual(str, CFSTR("com.apple.AppleMIDIBluetoothDriver")))
      {
        goto LABEL_31;
      }
      v5 = (MIDIServer *)CFEqual(*((CFTypeRef *)this + 2), kMIDIPropertyOffline);
      if (!(_DWORD)v5)
        goto LABEL_31;
      v6 = (MIDIServer *)MIDIServer::USBDeviceCount(v5);
      if ((_DWORD)v6)
        goto LABEL_31;
      v7 = (MIDIServer *)MIDIServer::BluetoothDeviceCount(v6);
      if ((_DWORD)v7)
        goto LABEL_31;
      v8 = MIDIServer::defaultInstance(v7);
      v10 = v8[25];
      v9 = v8[26];
      if (v10 == v9)
        goto LABEL_30;
      v11 = v10 + 8;
      do
      {
        v12 = *(_QWORD *)(*(_QWORD *)(v11 - 8) + 48);
        if (v12)
          v13 = 1;
        else
          v13 = v11 == v9;
        v11 += 8;
      }
      while (!v13);
      goto LABEL_29;
    }
  }
}

uint64_t MIDIServer::USBDeviceCount(MIDIServer *this)
{
  int v1;
  ItemCount v2;
  uint64_t v3;
  uint64_t v4;
  MIDIDeviceRef v5;
  CFTypeRef cf1;
  SInt32 outValue;

  if (!*(_BYTE *)MIDIServer::defaultInstance(this)[33])
    return 0;
  v1 = MIDIGetNumberOfDevices();
  outValue = 0;
  if (v1 < 1)
    return 0;
  v2 = 0;
  v3 = 0;
  v4 = v1;
  do
  {
    v5 = MIDIGetDevice(v2);
    cf1 = 0;
    if ((MIDIObjectGetIntegerProperty(v5, kMIDIPropertyOffline, &outValue) || !outValue)
      && !MIDIObjectGetStringProperty(v5, kMIDIPropertyDriverOwner, (CFStringRef *)&cf1))
    {
      if (CFEqual(cf1, CFSTR("com.apple.AppleMIDIUSBDriver")) || CFEqual(cf1, CFSTR("com.apple.YamahaUSBMIDIDriver")))
        v3 = (v3 + 1);
      CFRelease(cf1);
    }
    ++v2;
  }
  while (v4 != v2);
  return v3;
}

uint64_t MIDIServer::BluetoothDeviceCount(MIDIServer *this)
{
  int v1;
  ItemCount v2;
  uint64_t v3;
  uint64_t v4;
  MIDIDeviceRef v5;
  CFTypeRef cf1;
  SInt32 outValue;

  if (!*(_BYTE *)MIDIServer::defaultInstance(this)[33])
    return 0;
  v1 = MIDIGetNumberOfDevices();
  outValue = 0;
  if (v1 < 1)
    return 0;
  v2 = 0;
  v3 = 0;
  v4 = v1;
  do
  {
    v5 = MIDIGetDevice(v2);
    cf1 = 0;
    if ((MIDIObjectGetIntegerProperty(v5, kMIDIPropertyOffline, &outValue) || !outValue)
      && !MIDIObjectGetStringProperty(v5, kMIDIPropertyDriverOwner, (CFStringRef *)&cf1))
    {
      if (CFEqual(cf1, CFSTR("com.apple.AppleMIDIBluetoothDriver")))
      {
        if (MIDIDeviceGetNumberOfEntities(v5))
          v3 = (v3 + 1);
        else
          v3 = v3;
      }
      CFRelease(cf1);
    }
    ++v2;
  }
  while (v4 != v2);
  return v3;
}

void ScheduleCheckServerShutdown(MIDIServer *a1)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  _BOOL8 v8;
  int64_t v9;
  MIDIServer *v10;
  NSObject *v11;
  dispatch_time_t v12;
  int v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  unint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = MIDIServer::defaultInstance(a1);
  if (!*((_BYTE *)v1 + 10))
  {
    v2 = MIDIServer::defaultInstance((MIDIServer *)v1);
    v4 = v2[25];
    v3 = v2[26];
    if (v4 == v3)
      goto LABEL_11;
    v5 = v4 + 8;
    do
    {
      v6 = *(_QWORD *)(*(_QWORD *)(v5 - 8) + 48);
      if (v6)
        v7 = 1;
      else
        v7 = v5 == v3;
      v5 += 8;
    }
    while (!v7);
    if (!v6)
    {
LABEL_11:
      v8 = MIDIServer::ProblemDevicesAttached((MIDIServer *)v2);
      if (!v8)
      {
        v9 = 300000000000;
        v10 = (MIDIServer *)MIDIServer::USBDeviceCount((MIDIServer *)v8);
        if ((int)v10 <= 0 && (int)MIDIServer::BluetoothDeviceCount(v10) <= 0)
          v9 = 5000000000;
        gMIDIServerLog();
        v11 = objc_retainAutorelease((id)gMIDIServerLog(void)::mdsrvr);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
        {
          v13 = 136315650;
          v14 = "MIDIServer.mm";
          v15 = 1024;
          v16 = 688;
          v17 = 2048;
          v18 = (unint64_t)(((unint64_t)v9 * (unsigned __int128)0x89705F4137uLL) >> 64) >> 5;
          _os_log_impl(&dword_1D4E88000, v11, OS_LOG_TYPE_DEBUG, "%25s:%-5d ScheduleCheckServerShutdown() - shutting down in %llu seconds...", (uint8_t *)&v13, 0x1Cu);
        }
        v12 = dispatch_time(0, v9);
        dispatch_after(v12, MEMORY[0x1E0C80D38], &__block_literal_global_1223);
      }
    }
  }
}

BOOL MIDIServer::ProblemDevicesAttached(MIDIServer *this)
{
  int v1;
  ItemCount v2;
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  MIDIDeviceRef v6;
  int v7;
  CFTypeRef cf1;
  SInt32 outValue[2];

  if (*(_BYTE *)MIDIServer::defaultInstance(this)[33])
  {
    v1 = MIDIGetNumberOfDevices();
    *(_QWORD *)outValue = 0;
    if (v1 >= 1)
    {
      v2 = 0;
      v3 = v1;
      v4 = v1;
      v5 = 1;
      while (1)
      {
        v6 = MIDIGetDevice(v2);
        cf1 = 0;
        if ((MIDIObjectGetIntegerProperty(v6, kMIDIPropertyOffline, &outValue[1]) || !outValue[1])
          && !MIDIObjectGetStringProperty(v6, kMIDIPropertyDriverOwner, (CFStringRef *)&cf1))
        {
          if (CFEqual(cf1, CFSTR("com.apple.AppleMIDIUSBDriver"))
            || CFEqual(cf1, CFSTR("com.apple.YamahaUSBMIDIDriver")))
          {
            CFRelease(cf1);
            cf1 = 0;
            MIDIObjectGetIntegerProperty(v6, CFSTR("USBVendorProduct"), outValue);
            if (outValue[0] <= 281314321)
            {
              if (outValue[0] == 77140976)
                return v5;
              v7 = 239161696;
            }
            else
            {
              if (outValue[0] == 281314322 || outValue[0] == 367263784)
                return v5;
              v7 = 425918471;
            }
            if (outValue[0] == v7)
              return v5;
          }
          if (cf1)
            CFRelease(cf1);
        }
        v5 = (uint64_t)++v2 < v3;
        if (v4 == v2)
          return v5;
      }
    }
  }
  return 0;
}

void ___Z27ScheduleCheckServerShutdownv_block_invoke(MIDIServer *a1)
{
  uint64_t *v1;
  MIDIServer *v2;
  int v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  NSObject *v11;
  MIDIServer *v12;
  int v13;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  BOOL v20;
  int v21;
  SetupManager *v22;
  MIDISetup *v23;
  uint64_t *v24;
  NSObject *v25;
  pid_t v26;
  int v27;
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  pid_t v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v1 = MIDIServer::defaultInstance(a1) + 2;
  v2 = (MIDIServer *)(*(uint64_t (**)(uint64_t *))(*v1 + 16))(v1);
  v3 = (int)v2;
  v4 = MIDIServer::defaultInstance(v2);
  v5 = MIDIServer::defaultInstance((MIDIServer *)v4);
  v7 = v5[25];
  v6 = v5[26];
  if (v7 == v6)
    goto LABEL_9;
  v8 = v7 + 8;
  do
  {
    v9 = *(_QWORD *)(*(_QWORD *)(v8 - 8) + 48);
    if (v9)
      v10 = 1;
    else
      v10 = v8 == v6;
    v8 += 8;
  }
  while (!v10);
  if (!v9)
  {
LABEL_9:
    if (!MIDIServer::ProblemDevicesAttached((MIDIServer *)v5))
    {
      gMIDIServerLog();
      v11 = objc_retainAutorelease((id)gMIDIServerLog(void)::mdsrvr);
      v12 = (MIDIServer *)os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)v12)
      {
        v27 = 136315394;
        v28 = "MIDIServer.mm";
        v29 = 1024;
        v30 = 661;
        _os_log_impl(&dword_1D4E88000, v11, OS_LOG_TYPE_DEBUG, "%25s:%-5d MIDIServer shutting down now.", (uint8_t *)&v27, 0x12u);
      }
      if (!*((_BYTE *)v4 + 8))
      {
        v13 = -5;
        do
        {
          if (!*(_DWORD *)(gScheduler + 136))
            break;
          v12 = (MIDIServer *)sleep(1u);
        }
        while (!__CFADD__(v13++, 1));
        v15 = MIDIServer::defaultInstance(v12);
        v17 = v15[25];
        v16 = v15[26];
        if (v17 == v16)
          goto LABEL_28;
        v18 = v17 + 8;
        do
        {
          v19 = *(_QWORD *)(*(_QWORD *)(v18 - 8) + 48);
          if (v19)
            v20 = 1;
          else
            v20 = v18 == v16;
          v18 += 8;
        }
        while (!v20);
        if (!v19)
        {
LABEL_28:
          *((_BYTE *)v4 + 10) = 1;
          if (gMIDIIOThread)
            CADeprecated::XThread::Stop((CADeprecated::XThread *)gMIDIIOThread);
          v21 = (*(uint64_t (**)(uint64_t *))(v4[13] + 16))(v4 + 13);
          Scheduler::FlushAllOutput((Scheduler *)gScheduler);
          *(_BYTE *)(gScheduler + 144) = 1;
          if (v21)
            (*(void (**)(uint64_t *))(v4[13] + 24))(v4 + 13);
          MIDIDriverMgr::StopMIDI((MIDIDriverMgr *)v4[33]);
          v22 = (SetupManager *)gWatchdog;
          if (gWatchdog)
            v22 = (SetupManager *)MIDIClientDispose(gWatchdog);
          v23 = *(MIDISetup **)SetupManager::instance(v22);
          if (v23)
            MIDISetup::CheckWritePrefFile(v23);
          v24 = v4 + 33;
          std::unique_ptr<MIDIDriverKitPluginRegistrar>::reset[abi:ne180100]((uint64_t *)(*v24 + 64), 0);
          std::unique_ptr<MIDIDriverMgr>::reset[abi:ne180100](v24, 0);
          gMIDIServerLog();
          v25 = objc_retainAutorelease((id)gMIDIServerLog(void)::mdsrvr);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
          {
            v26 = getpid();
            v27 = 136315650;
            v28 = "MIDIServer.mm";
            v29 = 1024;
            v30 = 432;
            v31 = 1024;
            v32 = v26;
            _os_log_impl(&dword_1D4E88000, v25, OS_LOG_TYPE_INFO, "%25s:%-5d MIDIServer [%d] exiting", (uint8_t *)&v27, 0x18u);
          }

          exit(0);
        }
      }
    }
  }
  if (v3)
    (*(void (**)(uint64_t *))(*v1 + 24))(v1);
}

void sub_1D4EC031C(_Unwind_Exception *a1)
{
  uint64_t v1;
  int v2;
  void *v3;

  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

uint64_t CoreMIDIServerImplVersion()
{
  char *v0;
  int v1;

  v0 = getenv("CoreMIDI_ServerVersion");
  if (v0)
  {
    v1 = *v0;
    if (v1 == 49)
      return 1;
    if (v1 == 50)
      return 2;
  }
  if (_os_feature_enabled_impl())
    return 2;
  else
    return 1;
}

void std::__function::__func<std::function<void ()(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)> CreateDoWithResolvedClientFunction<ClientProcessXPC>(void)::{lambda(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)#1},std::allocator<std::function<void ()(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)> CreateDoWithResolvedClientFunction<ClientProcessXPC>(void)::{lambda(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)#1}>,void ()(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)>::~__func()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *std::__function::__func<std::function<void ()(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)> CreateDoWithResolvedClientFunction<ClientProcessXPC>(void)::{lambda(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)#1},std::allocator<std::function<void ()(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)> CreateDoWithResolvedClientFunction<ClientProcessXPC>(void)::{lambda(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)#1}>,void ()(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E98B86F0;
  return result;
}

void std::__function::__func<std::function<void ()(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)> CreateDoWithResolvedClientFunction<ClientProcessXPC>(void)::{lambda(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)#1},std::allocator<std::function<void ()(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)> CreateDoWithResolvedClientFunction<ClientProcessXPC>(void)::{lambda(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)#1}>,void ()(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E98B86F0;
}

void std::__function::__func<std::function<void ()(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)> CreateDoWithResolvedClientFunction<ClientProcessXPC>(void)::{lambda(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)#1},std::allocator<std::function<void ()(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)> CreateDoWithResolvedClientFunction<ClientProcessXPC>(void)::{lambda(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)#1}>,void ()(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)>::operator()(uint64_t a1, int *a2, __int128 *a3)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int *v6;
  unsigned int v7;
  __int128 v8;
  uint64_t v9;
  _BYTE v10[16];
  uint64_t v11;
  char v12;
  unsigned int *v13;
  char v14;
  uint64_t v15;
  int v16;

  v3 = *a2;
  v8 = *a3;
  v9 = *((_QWORD *)a3 + 2);
  v16 = v3;
  v10[0] = 0;
  v14 = 0;
  v15 = 0;
  if (OpaqueObjectMgr::sInstance)
  {
    std::optional<caulk::concurrent::guarded_lookup_hash_table<unsigned int,BaseOpaqueObject *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()>>::scoped_lookup>::emplace[abi:ne180100]<caulk::concurrent::guarded_lookup_hash_table<unsigned int,BaseOpaqueObject *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()>>&,unsigned int const&,void>((uint64_t)v10, OpaqueObjectMgr::sInstance, &v16);
    if (v12)
    {
      v4 = v11;
      if ((*(unsigned int (**)(uint64_t, void *))(*(_QWORD *)v11 + 24))(v11, &TOpaqueRTTI<ClientProcessXPC>::sRTTI))
      {
        v5 = v4;
      }
      else
      {
        v5 = 0;
      }
      v15 = v5;
      if (!v5)
        goto LABEL_10;
      goto LABEL_9;
    }
    v5 = v15;
    if (v15)
LABEL_9:
      ((void (*)(char *, uint64_t))v8)((char *)&v8 + 8, v5 + 16);
  }
LABEL_10:
  if (v14)
  {
    v6 = v13;
    if (v13)
    {
      do
        v7 = __ldaxr(v6);
      while (__stlxr(v7 - 1, v6));
    }
  }
}

void sub_1D4EC0518(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, unsigned int *a17, char a18)
{
  unsigned int v18;

  if (a18 && a17)
  {
    do
      v18 = __ldaxr(a17);
    while (__stlxr(v18 - 1, a17));
  }
  _Unwind_Resume(a1);
}

uint64_t std::optional<caulk::concurrent::guarded_lookup_hash_table<unsigned int,BaseOpaqueObject *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned int)>>::scoped_lookup>::emplace[abi:ne180100]<caulk::concurrent::guarded_lookup_hash_table<unsigned int,BaseOpaqueObject *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned int)>>&,unsigned int const&,void>(uint64_t a1, uint64_t a2, int *a3)
{
  unsigned int *v4;
  unsigned int v5;
  int v6;
  unsigned int *v7;
  unsigned int v8;
  uint64_t *v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int *v12;
  unsigned int v13;

  if (*(_BYTE *)(a1 + 40))
  {
    v4 = *(unsigned int **)(a1 + 32);
    if (v4)
    {
      do
        v5 = __ldaxr(v4);
      while (__stlxr(v5 - 1, v4));
    }
    *(_BYTE *)(a1 + 40) = 0;
  }
  v6 = *a3;
  *(_QWORD *)a1 = a2;
  *(_DWORD *)(a1 + 8) = v6;
  *(_BYTE *)(a1 + 16) = 0;
  *(_BYTE *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  v7 = (unsigned int *)(a2 + 48);
  do
    v8 = __ldaxr(v7);
  while (__stlxr(v8 + 1, v7));
  v9 = (uint64_t *)atomic_load((unint64_t *)(*(_QWORD *)a1 + 40));
  if (v9)
  {
    caulk::concurrent::guarded_lookup_hash_table<unsigned int,BaseOpaqueObject *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()>>::table_impl::findSlotForKey(v9, v6);
    *(_QWORD *)(a1 + 32) = v10;
    if (v10)
    {
      do
        v11 = __ldaxr(v10);
      while (__stlxr(v11 + 1, v10));
      *(_QWORD *)(a1 + 16) = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      *(_BYTE *)(a1 + 24) = 1;
    }
  }
  v12 = (unsigned int *)(*(_QWORD *)a1 + 48);
  do
    v13 = __ldaxr(v12);
  while (__stlxr(v13 - 1, v12));
  *(_BYTE *)(a1 + 40) = 1;
  return a1;
}

void std::__function::__func<std::function<void ()(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)> CreateDoWithResolvedClientFunction<ClientProcessMIG>(void)::{lambda(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)#1},std::allocator<std::function<void ()(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)> CreateDoWithResolvedClientFunction<ClientProcessMIG>(void)::{lambda(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)#1}>,void ()(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)>::~__func()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *std::__function::__func<std::function<void ()(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)> CreateDoWithResolvedClientFunction<ClientProcessMIG>(void)::{lambda(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)#1},std::allocator<std::function<void ()(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)> CreateDoWithResolvedClientFunction<ClientProcessMIG>(void)::{lambda(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)#1}>,void ()(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E98B86A8;
  return result;
}

void std::__function::__func<std::function<void ()(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)> CreateDoWithResolvedClientFunction<ClientProcessMIG>(void)::{lambda(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)#1},std::allocator<std::function<void ()(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)> CreateDoWithResolvedClientFunction<ClientProcessMIG>(void)::{lambda(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)#1}>,void ()(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E98B86A8;
}

void std::__function::__func<std::function<void ()(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)> CreateDoWithResolvedClientFunction<ClientProcessMIG>(void)::{lambda(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)#1},std::allocator<std::function<void ()(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)> CreateDoWithResolvedClientFunction<ClientProcessMIG>(void)::{lambda(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)#1}>,void ()(unsigned int,caulk::function_ref<void ()(ClientProcess &)>)>::operator()(uint64_t a1, int *a2, __int128 *a3)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int *v6;
  unsigned int v7;
  __int128 v8;
  uint64_t v9;
  _BYTE v10[16];
  uint64_t v11;
  char v12;
  unsigned int *v13;
  char v14;
  uint64_t v15;
  int v16;

  v3 = *a2;
  v8 = *a3;
  v9 = *((_QWORD *)a3 + 2);
  v16 = v3;
  v10[0] = 0;
  v14 = 0;
  v15 = 0;
  if (OpaqueObjectMgr::sInstance)
  {
    std::optional<caulk::concurrent::guarded_lookup_hash_table<unsigned int,BaseOpaqueObject *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()>>::scoped_lookup>::emplace[abi:ne180100]<caulk::concurrent::guarded_lookup_hash_table<unsigned int,BaseOpaqueObject *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()>>&,unsigned int const&,void>((uint64_t)v10, OpaqueObjectMgr::sInstance, &v16);
    if (v12)
    {
      v4 = v11;
      if ((*(unsigned int (**)(uint64_t, void *))(*(_QWORD *)v11 + 24))(v11, &TOpaqueRTTI<ClientProcessMIG>::sRTTI))
      {
        v5 = v4;
      }
      else
      {
        v5 = 0;
      }
      v15 = v5;
      if (!v5)
        goto LABEL_10;
      goto LABEL_9;
    }
    v5 = v15;
    if (v15)
LABEL_9:
      ((void (*)(char *, uint64_t))v8)((char *)&v8 + 8, v5 + 16);
  }
LABEL_10:
  if (v14)
  {
    v6 = v13;
    if (v13)
    {
      do
        v7 = __ldaxr(v6);
      while (__stlxr(v7 - 1, v6));
    }
  }
}

void sub_1D4EC075C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, unsigned int *a17, char a18)
{
  unsigned int v18;

  if (a18 && a17)
  {
    do
      v18 = __ldaxr(a17);
    while (__stlxr(v18 - 1, a17));
  }
  _Unwind_Resume(a1);
}

void MIDIIOThread::~MIDIIOThread(MIDIIOThread *this)
{
  char *v1;
  _QWORD *v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E98B94F8;
  v1 = (char *)this + 152;
  v2 = (_QWORD *)*((_QWORD *)this + 22);
  if (v2 == (_QWORD *)v1)
  {
    v3 = 4;
    v2 = v1;
  }
  else
  {
    if (!v2)
      return;
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
}

{
  char *v1;
  _QWORD *v2;
  uint64_t v3;

  *(_QWORD *)this = &off_1E98B94F8;
  v1 = (char *)this + 152;
  v2 = (_QWORD *)*((_QWORD *)this + 22);
  if (v2 == (_QWORD *)v1)
  {
    v3 = 4;
    v2 = v1;
  }
  else
  {
    if (!v2)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  JUMPOUT(0x1D826BA98);
}

uint64_t MIDIIOThread::Start(MIDIIOThread *this)
{
  CADeprecated::CAPThread::SetTimeConstraints(this, 0, 6000, 12000, 1);
  return CADeprecated::CAPThread::Start((uint64_t)this);
}

uint64_t MIDIIOThread::RequestStop(MIDIIOThread *this)
{
  int v1;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v1 = *((_DWORD *)this + 36);
  v3 = 0x2800000013;
  v4 = v1;
  v6 = 0;
  v5 = 0;
  v7 = 0x400000003;
  v8 = 0;
  return mach_msg((mach_msg_header_t *)&v3, 1, 0x28u, 0, 0, 0, 0);
}

void MIDIIOThread::Run(MIDIIOThread *this, uint64_t a2, int a3, int *a4)
{
  mach_port_name_t ServerPort;
  uint64_t v6;
  int v7;
  _QWORD v8[3];
  int v9;
  int v10;
  int v11;
  mach_port_name_t v12;
  int v13;

  ServerPort = CADeprecated::XMachServer::CreateServerPort((CADeprecated::XMachServer *)"com.apple.midiserver.io", (char *)this + 140, a3, a4);
  *((_DWORD *)this + 36) = ServerPort;
  if (!*((_DWORD *)this + 35))
  {
    v12 = ServerPort;
    *((_BYTE *)this + 137) = 1;
    while (1)
    {
      v11 = 0;
      v9 = 4;
      if (XServerMachPort::ReceiveMessage(ServerPort, &v11, &v10, &v9) || v11 == 3)
        break;
      v7 = v11;
      v8[0] = _ZN5caulk12function_refIFvR13ClientProcessEE15functor_invokerIZN12MIDIIOThread3RunEvEUlRT_E_EEvRKNS_7details15erased_callableIS3_EES2_;
      v8[1] = &v7;
      v13 = v10;
      v6 = *((_QWORD *)this + 22);
      if (!v6)
        std::__throw_bad_function_call[abi:ne180100]();
      (*(void (**)(uint64_t, int *, _QWORD *))(*(_QWORD *)v6 + 48))(v6, &v13, v8);
      ServerPort = v12;
    }
    XServerMachPort::~XServerMachPort(&v12);
  }
}

void sub_1D4EC0A04(_Unwind_Exception *a1)
{
  uint64_t v1;

  XServerMachPort::~XServerMachPort((mach_port_name_t *)(v1 - 40));
  _Unwind_Resume(a1);
}

uint64_t _ZN5caulk12function_refIFvR13ClientProcessEE15functor_invokerIZN12MIDIIOThread3RunEvEUlRT_E_EEvRKNS_7details15erased_callableIS3_EES2_(uint64_t result, uint64_t a2)
{
  int v3;
  int v4;
  int v5;
  NSObject *v6;
  UInt32 v7;
  mach_msg_header_t *v8;
  unsigned int *v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  MIDIEventPacket v14[3];
  _BYTE buf[12];
  uint64_t v16;
  __int128 v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v3 = **(_DWORD **)result;
  if (v3 == 2)
  {
    result = MIDIIORingBufferWriter::emptySecondaryQueue((os_unfair_lock_s *)(a2 + 24));
    if (!(_DWORD)result)
      return result;
    v7 = *(_DWORD *)(a2 + 16);
    v14[0].timeStamp = 0x2400000013;
    v14[0].wordCount = v7;
    *(_QWORD *)&v14[0].words[2] = 0;
    *(_QWORD *)v14[0].words = 0;
    *(_QWORD *)&v14[0].words[4] = 1;
    v8 = (mach_msg_header_t *)v14;
    return mach_msg(v8, 1, 0x24u, 0, 0, 0, 0);
  }
  if (v3 == 1)
  {
    v14[0].timeStamp = 1;
    if (!*(_BYTE *)(a2 + 288))
      std::__throw_bad_optional_access[abi:ne180100]();
    while (1)
    {
      result = MIDIIORingBufferReader::readPacketList((MIDIRingBuffer *)(a2 + 184), &v13, (uint64_t)v14);
      if (!(_DWORD)result)
        break;
      if (HIDWORD(v14[0].timeStamp))
      {
        if ((_DWORD)v13)
          v4 = _MIDISend((MIDIServer *)v13, SHIDWORD(v13), (const MIDI::EventList *)v14);
        else
          v4 = _MIDIReceived((MIDIServer *)HIDWORD(v13), v14);
        v5 = v4;
        if (v4)
        {
          gServerClientProcessLog();
          v6 = gServerClientProcessLog(void)::cliprc;
          if (os_log_type_enabled((os_log_t)gServerClientProcessLog(void)::cliprc, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136315906;
            *(_QWORD *)&buf[4] = "ClientProcess.cpp";
            v16 = 0x400000000A70400;
            LODWORD(v17) = v5;
            WORD2(v17) = 1024;
            *(_DWORD *)((char *)&v17 + 6) = v5;
            _os_log_impl(&dword_1D4E88000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d MIDISend/MIDIReceived returned %d/0x%x\n", buf, 0x1Eu);
          }
        }
      }
    }
    if (atomic_load((unsigned int *)(*(_QWORD *)(a2 + 272) + 16)))
    {
      v10 = (unsigned int *)(*(_QWORD *)(a2 + 272) + 24);
      do
        v11 = __ldaxr(v10);
      while (__stlxr(v11 | 1, v10));
      if (!v11)
      {
        v12 = *(_DWORD *)(a2 + 16);
        *(_QWORD *)buf = 0x2400000013;
        *(_DWORD *)&buf[8] = v12;
        *(_QWORD *)&v17 = 0;
        v16 = 0;
        *((_QWORD *)&v17 + 1) = 2;
        v8 = (mach_msg_header_t *)buf;
        return mach_msg(v8, 1, 0x24u, 0, 0, 0, 0);
      }
    }
  }
  return result;
}

uint64_t CADeprecated::XThread::RequestStop(uint64_t this)
{
  *(_BYTE *)(this + 136) = 1;
  return this;
}

_QWORD *std::__function::__func<void CASmartPreferences::AddHandler<BOOL>(__CFString const*,__CFString const*,BOOL (*)(void const*,BOOL &),std::function<void ()(BOOL)>)::{lambda(void const*)#1},std::allocator<void CASmartPreferences::AddHandler<BOOL>(__CFString const*,__CFString const*,BOOL (*)(void const*,BOOL &),std::function<void ()(BOOL)>)::{lambda(void const*)#1}>,BOOL ()(void const*)>::~__func(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  *a1 = &off_1E98B9F60;
  v2 = a1 + 2;
  v3 = (_QWORD *)a1[5];
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }
  return a1;
}

void std::__function::__func<void CASmartPreferences::AddHandler<BOOL>(__CFString const*,__CFString const*,BOOL (*)(void const*,BOOL &),std::function<void ()(BOOL)>)::{lambda(void const*)#1},std::allocator<void CASmartPreferences::AddHandler<BOOL>(__CFString const*,__CFString const*,BOOL (*)(void const*,BOOL &),std::function<void ()(BOOL)>)::{lambda(void const*)#1}>,BOOL ()(void const*)>::~__func(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;

  *a1 = &off_1E98B9F60;
  v1 = a1 + 2;
  v2 = (_QWORD *)a1[5];
  if (v2 == v1)
  {
    v3 = 4;
    v2 = v1;
  }
  else
  {
    if (!v2)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  JUMPOUT(0x1D826BA98);
}

_QWORD *std::__function::__func<void CASmartPreferences::AddHandler<BOOL>(__CFString const*,__CFString const*,BOOL (*)(void const*,BOOL &),std::function<void ()(BOOL)>)::{lambda(void const*)#1},std::allocator<void CASmartPreferences::AddHandler<BOOL>(__CFString const*,__CFString const*,BOOL (*)(void const*,BOOL &),std::function<void ()(BOOL)>)::{lambda(void const*)#1}>,BOOL ()(void const*)>::__clone(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;

  v2 = operator new(0x30uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *v2 = &off_1E98B9F60;
  v2[1] = v3;
  std::__function::__value_func<void ()(applesauce::iokit::io_object_holder)>::__value_func[abi:ne180100]((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

void sub_1D4EC0D6C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void CASmartPreferences::AddHandler<BOOL>(__CFString const*,__CFString const*,BOOL (*)(void const*,BOOL &),std::function<void ()(BOOL)>)::{lambda(void const*)#1},std::allocator<void CASmartPreferences::AddHandler<BOOL>(__CFString const*,__CFString const*,BOOL (*)(void const*,BOOL &),std::function<void ()(BOOL)>)::{lambda(void const*)#1}>,BOOL ()(void const*)>::__clone(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_1E98B9F60;
  a2[1] = v2;
  return std::__function::__value_func<void ()(applesauce::iokit::io_object_holder)>::__value_func[abi:ne180100]((uint64_t)(a2 + 2), a1 + 16);
}

_QWORD *std::__function::__func<void CASmartPreferences::AddHandler<BOOL>(__CFString const*,__CFString const*,BOOL (*)(void const*,BOOL &),std::function<void ()(BOOL)>)::{lambda(void const*)#1},std::allocator<void CASmartPreferences::AddHandler<BOOL>(__CFString const*,__CFString const*,BOOL (*)(void const*,BOOL &),std::function<void ()(BOOL)>)::{lambda(void const*)#1}>,BOOL ()(void const*)>::destroy(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;

  v1 = (_QWORD *)(a1 + 16);
  result = *(_QWORD **)(a1 + 40);
  if (result == v1)
  {
    v3 = 4;
    result = v1;
  }
  else
  {
    if (!result)
      return result;
    v3 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void std::__function::__func<void CASmartPreferences::AddHandler<BOOL>(__CFString const*,__CFString const*,BOOL (*)(void const*,BOOL &),std::function<void ()(BOOL)>)::{lambda(void const*)#1},std::allocator<void CASmartPreferences::AddHandler<BOOL>(__CFString const*,__CFString const*,BOOL (*)(void const*,BOOL &),std::function<void ()(BOOL)>)::{lambda(void const*)#1}>,BOOL ()(void const*)>::destroy_deallocate(char *__p)
{
  char *v2;
  char *v3;
  uint64_t v4;

  v2 = __p + 16;
  v3 = (char *)*((_QWORD *)__p + 5);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
    goto LABEL_5;
  }
  if (v3)
  {
    v4 = 5;
LABEL_5:
    (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
  }
  operator delete(__p);
}

BOOL std::__function::__func<void CASmartPreferences::AddHandler<BOOL>(__CFString const*,__CFString const*,BOOL (*)(void const*,BOOL &),std::function<void ()(BOOL)>)::{lambda(void const*)#1},std::allocator<void CASmartPreferences::AddHandler<BOOL>(__CFString const*,__CFString const*,BOOL (*)(void const*,BOOL &),std::function<void ()(BOOL)>)::{lambda(void const*)#1}>,BOOL ()(void const*)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  char v4;
  uint64_t v5;
  char v7;
  char v8;

  v3 = *a2;
  v7 = 0;
  v4 = (*(uint64_t (**)(uint64_t, char *))(a1 + 8))(v3, &v7);
  if (!v7)
    return 0;
  v8 = v4;
  v5 = *(_QWORD *)(a1 + 40);
  if (!v5)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, char *))(*(_QWORD *)v5 + 48))(v5, &v8);
  return v7 != 0;
}

void std::__function::__func<FullInit(char const*,BOOL)::$_0,std::allocator<FullInit(char const*,BOOL)::$_0>,void ()(BOOL)>::~__func()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *std::__function::__func<FullInit(char const*,BOOL)::$_0,std::allocator<FullInit(char const*,BOOL)::$_0>,void ()(BOOL)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E98B70F8;
  return result;
}

void std::__function::__func<FullInit(char const*,BOOL)::$_0,std::allocator<FullInit(char const*,BOOL)::$_0>,void ()(BOOL)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E98B70F8;
}

void std::__function::__func<FullInit(char const*,BOOL)::$_0,std::allocator<FullInit(char const*,BOOL)::$_0>,void ()(BOOL)>::operator()(MIDIServer *a1, unsigned __int8 *a2)
{
  int v2;
  NSObject *v3;
  _BOOL4 v4;
  NSObject *v5;
  const char *v6;
  int v7;
  const char *v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v2 = *a2;
  *((_BYTE *)MIDIServer::defaultInstance(a1) + 9) = v2;
  gMIDIServerLog();
  v3 = objc_retainAutorelease((id)gMIDIServerLog(void)::mdsrvr);
  v4 = os_log_type_enabled(v3, OS_LOG_TYPE_INFO);
  if (!v2)
  {
    if (!v4)
      return;
    v7 = 136315394;
    v8 = "MIDIServer.mm";
    v9 = 1024;
    v10 = 313;
    v6 = "%25s:%-5d NOTICE: Universal MIDI System Exclusive message filtering is temporarily disabled. Please enable the "
         "MIDI-CI beta for API message filtering.";
    goto LABEL_10;
  }
  if (v4)
  {
    v7 = 136315394;
    v8 = "MIDIServer.mm";
    v9 = 1024;
    v10 = 308;
    _os_log_impl(&dword_1D4E88000, v3, OS_LOG_TYPE_INFO, "%25s:%-5d ==========================================================================================================", (uint8_t *)&v7, 0x12u);
  }
  gMIDIServerLog();
  v5 = objc_retainAutorelease((id)gMIDIServerLog(void)::mdsrvr);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    v7 = 136315394;
    v8 = "MIDIServer.mm";
    v9 = 1024;
    v10 = 309;
    _os_log_impl(&dword_1D4E88000, v5, OS_LOG_TYPE_INFO, "%25s:%-5d NOTICE: MIDIServer is filtering Universal MIDI System Exclusive traffic.", (uint8_t *)&v7, 0x12u);
  }
  gMIDIServerLog();
  v3 = objc_retainAutorelease((id)gMIDIServerLog(void)::mdsrvr);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
  {
    v7 = 136315394;
    v8 = "MIDIServer.mm";
    v9 = 1024;
    v10 = 310;
    v6 = "%25s:%-5d ==========================================================================================================";
LABEL_10:
    _os_log_impl(&dword_1D4E88000, v3, OS_LOG_TYPE_INFO, v6, (uint8_t *)&v7, 0x12u);
  }
}

void MIDIServerXPCAssembly::MIDIServerXPCAssembly(MIDIServerXPCAssembly *this)
{
  _xpc_connection_s *v1;
  xpc_object_t v2;
  id v3;
  void *v4;
  uint64_t *v5;
  uint64_t v6;
  NSObject *v7;
  xpc_object_t *v8;
  _QWORD *v9;
  uint64_t v10;
  dispatch_queue_t v11;
  id v12;
  xpc_object_t object[2];
  char v14;
  void *v15[2];
  void *__p[2];
  __int128 v17;
  id v18;
  dispatch_queue_t v19;
  id v20;
  __int16 v21;
  uint64_t v22;
  _BYTE v23[24];
  _BYTE *v24;
  char v25;
  _BYTE buf[32];
  uint64_t *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)v15 = 0u;
  *(_OWORD *)__p = 0u;
  v17 = 0u;
  v1 = xpc_connection_create_mach_service("com.apple.midiserver", 0, 1uLL);
  v2 = v1;
  if (!v1)
    v2 = xpc_null_create();

  v3 = v2;
  v4 = v3;
  v18 = v3;
  if (!v3 || MEMORY[0x1D826C5A8](v3) != MEMORY[0x1E0C812E0])
  {
    v18 = xpc_null_create();

  }
  v19 = dispatch_queue_create("MIDIServer", 0);
  gMIDIServerLog();
  v20 = objc_retainAutorelease((id)gMIDIServerLog(void)::mdsrvr);
  v21 = 0;
  *(_QWORD *)buf = 9000000000;
  *(_QWORD *)&buf[8] = &off_1E98B8660;
  *(_QWORD *)&buf[16] = MIDIServerXPCAssembly::xpcConnectionConfig(void)::{lambda(void)#1}::__invoke;
  v27 = (uint64_t *)&buf[8];
  v22 = 9000000000;
  std::__function::__value_func<void ()(void)>::__value_func[abi:ne180100]((uint64_t)v23, (uint64_t)&buf[8]);
  v25 = 1;
  v5 = v27;
  if (v27 == (uint64_t *)&buf[8])
  {
    v6 = 4;
    v5 = (uint64_t *)&buf[8];
    goto LABEL_10;
  }
  if (v27)
  {
    v6 = 5;
LABEL_10:
    (*(void (**)(void))(*v5 + 8 * v6))();
  }

  MIDIServer::MIDIServer((MIDIServer *)MIDIServer::defaultInstance(int)::xpcServer);
  MIDIServer::defaultInstance(int)::xpcServer[0] = (uint64_t)&off_1E98B7FA0;
  swix::connection::connection((swix::connection *)&qword_1EFEFD858, (const swix::connection_config *)v15);
  qword_1EFEFD858 = (uint64_t)off_1E98B85E0;
  swix::connection::xpc_connection((swix::connection *)object, (uint64_t)&qword_1EFEFD858);
  *(_QWORD *)buf = MEMORY[0x1E0C809B0];
  *(_QWORD *)&buf[8] = 0x40000000;
  *(_QWORD *)&buf[16] = ___ZN4swix8listenerC2ERKNS_17connection_configE_block_invoke;
  *(_QWORD *)&buf[24] = &__block_descriptor_tmp_8_172;
  v27 = &qword_1EFEFD858;
  swix::connection::state::set_handler(qword_1EFEFD860, (_xpc_connection_s *)object[0], buf);
  xpc_release(object[0]);
  qword_1EFEFD858 = (uint64_t)&off_1E98B8538;
  qword_1EFEFD870 = (uint64_t)MIDIServer::defaultInstance(int)::xpcServer;
  gMIDIServerLog();
  v7 = gMIDIServerLog(void)::mdsrvr;
  if (os_log_type_enabled((os_log_t)gMIDIServerLog(void)::mdsrvr, OS_LOG_TYPE_DEFAULT))
  {
    swix::connection::description((swix::connection *)object, qword_1EFEFD860);
    v8 = v14 >= 0 ? object : (xpc_object_t *)object[0];
    *(_DWORD *)buf = 136315650;
    *(_QWORD *)&buf[4] = "MIDIServerXPC.cpp";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 38;
    *(_WORD *)&buf[18] = 2080;
    *(_QWORD *)&buf[20] = v8;
    _os_log_impl(&dword_1D4E88000, v7, OS_LOG_TYPE_DEFAULT, "%25s:%-5d server conn %s", buf, 0x1Cu);
    if (v14 < 0)
      operator delete(object[0]);
  }
  if (v25)
  {
    v9 = v24;
    if (v24 == v23)
    {
      v10 = 4;
      v9 = v23;
    }
    else
    {
      if (!v24)
        goto LABEL_23;
      v10 = 5;
    }
    (*(void (**)(void))(*v9 + 8 * v10))();
  }
LABEL_23:

  v11 = v19;
  v19 = 0;

  v12 = v18;
  v18 = 0;

  if (SHIBYTE(v17) < 0)
    operator delete(__p[1]);
  if (SHIBYTE(__p[0]) < 0)
    operator delete(v15[0]);
}

void sub_1D4EC1444(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void std::__function::__func<void (*)(void),std::allocator<void (*)(void)>,void ()(void)>::~__func()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *std::__function::__func<void (*)(void),std::allocator<void (*)(void)>,void ()(void)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E98B8660;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void (*)(void),std::allocator<void (*)(void)>,void ()(void)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E98B8660;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void (*)(void),std::allocator<void (*)(void)>,void ()(void)>::operator()(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 8))();
}

void MIDIServerRun(const char *a1, uint64_t a2)
{
  FullInit(a1, a2);
  CFRunLoopRun();
}

void MIDIServer::MIDIServer(MIDIServer *this)
{
  char *v2;
  caulk::alloc *v3;
  caulk::thread *v4;
  uint64_t v5;
  MUIDGenerator *v6;
  uint64_t v7;
  _DWORD *v8;
  uint64_t v9;
  std::string *v10;
  uint64_t v11;
  uint64_t v12;
  std::string *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  std::string *v17;
  uint64_t v18;
  uint64_t v19;
  std::string *v20;
  uint64_t v21;
  std::string v22;
  std::string *v23;
  _BYTE v24[29];
  _QWORD v25[3];
  _QWORD *v26;
  std::string __p;
  std::string *p_p;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)this = &off_1E98B7E18;
  *(_WORD *)((char *)this + 9) = 0;
  CADeprecated::CAMutex::CAMutex((MIDIServer *)((char *)this + 16), "mAPILock");
  CADeprecated::CAMutex::CAMutex((MIDIServer *)((char *)this + 104), "mIOLock");
  *((_QWORD *)this + 24) = &off_1E98B9750;
  *((_QWORD *)this + 25) = 0;
  *((_QWORD *)this + 26) = 0;
  *((_QWORD *)this + 27) = 0;
  *((_QWORD *)this + 28) = &off_1E98B97B0;
  *((_QWORD *)this + 30) = 0;
  *((_QWORD *)this + 31) = 0;
  *((_QWORD *)this + 29) = 0;
  *((_QWORD *)this + 33) = 0;
  v2 = (char *)this + 272;
  *((_QWORD *)this + 37) = 0;
  std::string::basic_string[abi:ne180100]<0>(&__p, "umpci_thread");
  *((_QWORD *)this + 38) = 0;
  *((_BYTE *)this + 312) = 0;
  v3 = (caulk::alloc *)MEMORY[0x1D826B738]((char *)this + 316);
  *((_QWORD *)this + 41) = 850045863;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((_OWORD *)this + 23) = 0u;
  *((_QWORD *)this + 48) = 0;
  *((_DWORD *)this + 98) = 1056964608;
  *((_QWORD *)this + 50) = 0;
  *((_QWORD *)this + 58) = 0;
  *((_QWORD *)this + 59) = caulk::alloc::get_realtime_safe_resource(v3);
  *((_QWORD *)this + 63) = 0;
  *((_QWORD *)this + 67) = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v22, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
  else
    v22 = __p;
  LOBYTE(v23) = 1;
  *(_QWORD *)v24 = 0x10000003CLL;
  *(_DWORD *)&v24[16] = 2;
  v24[20] = 1;
  v24[24] = 0;
  v24[28] = 0;
  v4 = (caulk::thread *)operator new();
  *(_QWORD *)v4 = 0;
  *((_BYTE *)v4 + 8) = 0;
  v5 = operator new();
  std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:ne180100]((std::string *)v5, (__int128 *)&v22);
  *(_OWORD *)(v5 + 32) = *(_OWORD *)v24;
  *(_OWORD *)(v5 + 45) = *(_OWORD *)&v24[13];
  *(_QWORD *)(v5 + 64) = (char *)this + 304;
  caulk::thread::start(v4, (caulk::thread::attributes *)v5, (void *(*)(void *))caulk::thread_proxy<std::tuple<caulk::thread::attributes,AsyncMessenger::AsyncMessenger(std::string const&,float)::{lambda(void)#1},std::tuple<>>>, (void *)v5);
  std::unique_ptr<caulk::thread>::reset[abi:ne180100]((caulk::thread **)this + 38, v4);
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v22.__r_.__value_.__l.__data_);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  *((_QWORD *)this + 71) = 0;
  *((_QWORD *)this + 75) = 0;
  *((_QWORD *)this + 77) = 0;
  *((_QWORD *)this + 76) = 0;
  v22.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_1E98B71D0;
  v22.__r_.__value_.__l.__size_ = (std::string::size_type)this + 272;
  v23 = &v22;
  std::__function::__value_func<void ()(UMPCIObjectEvent,unsigned int,applesauce::CF::DictionaryRef)>::swap[abi:ne180100](&v22, (_QWORD *)this + 68);
  v6 = (MUIDGenerator *)v23;
  if (v23 == &v22)
  {
    v7 = 4;
    v6 = (MUIDGenerator *)&v22;
  }
  else
  {
    if (!v23)
      goto LABEL_13;
    v7 = 5;
  }
  v6 = (MUIDGenerator *)(*(uint64_t (**)(void))(*(_QWORD *)v6 + 8 * v7))();
LABEL_13:
  *((_QWORD *)this + 77) = MIDISendEventList;
  *((_QWORD *)this + 78) = v2;
  *((_QWORD *)this + 79) = 0;
  *((_QWORD *)this + 81) = 0;
  *((_QWORD *)this + 80) = 0;
  *((_QWORD *)this + 82) = 850045863;
  *(_OWORD *)((char *)this + 664) = 0u;
  *(_OWORD *)((char *)this + 680) = 0u;
  *(_OWORD *)((char *)this + 696) = 0u;
  *((_QWORD *)this + 89) = 0;
  v8 = (_DWORD *)MUIDGenerator::instance(v6);
  *((_DWORD *)this + 180) = MUIDGenerator::operator()(v8);
  *((_QWORD *)this + 92) = 0;
  *((_QWORD *)this + 94) = 0;
  *((_QWORD *)this + 93) = 0;
  *((_QWORD *)this + 91) = (char *)this + 736;
  *((_BYTE *)this + 780) = 0;
  *((_QWORD *)this + 98) = 0;
  *((_QWORD *)this + 96) = 0;
  *((_QWORD *)this + 95) = 0;
  *((_BYTE *)this + 776) = 0;
  v9 = *((_QWORD *)this + 78) + 32;
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_1E98B7380;
  __p.__r_.__value_.__l.__size_ = (std::string::size_type)this + 624;
  p_p = &__p;
  AsyncMessenger::addCallback(v9, 1u, &__p);
  v10 = p_p;
  if (p_p == &__p)
  {
    v11 = 4;
    v10 = &__p;
  }
  else
  {
    if (!p_p)
      goto LABEL_18;
    v11 = 5;
  }
  (*(void (**)(void))(v10->__r_.__value_.__r.__words[0] + 8 * v11))();
LABEL_18:
  v12 = *((_QWORD *)this + 78);
  v25[0] = &off_1E98B73C8;
  v25[1] = (char *)this + 624;
  v26 = v25;
  v23 = &v22;
  std::__function::__func<MIDICI::DeviceManager::DeviceManager(UMPCIServerContext &)::$_1,std::allocator<MIDICI::DeviceManager::DeviceManager(UMPCIServerContext &)::$_1>,void ()(UMPCIObjectEvent,unsigned int,applesauce::CF::DictionaryRef)>::__clone((uint64_t)v25, &v22);
  std::__function::__value_func<void ()(UMPCIObjectEvent,unsigned int,applesauce::CF::DictionaryRef)>::swap[abi:ne180100](&v22, (_QWORD *)(v12 + 304));
  v13 = v23;
  if (v23 == &v22)
  {
    v14 = 4;
    v13 = &v22;
  }
  else
  {
    if (!v23)
      goto LABEL_23;
    v14 = 5;
  }
  (*(void (**)(void))(v13->__r_.__value_.__r.__words[0] + 8 * v14))();
LABEL_23:
  v15 = v26;
  if (v26 == v25)
  {
    v16 = 4;
    v15 = v25;
  }
  else
  {
    if (!v26)
      goto LABEL_28;
    v16 = 5;
  }
  (*(void (**)(void))(*v15 + 8 * v16))();
LABEL_28:
  *((_QWORD *)this + 99) = v2;
  *((_QWORD *)this + 100) = 0;
  *((_QWORD *)this + 102) = 0;
  *((_QWORD *)this + 101) = 0;
  *((_QWORD *)this + 103) = 850045863;
  *((_OWORD *)this + 52) = 0u;
  *((_OWORD *)this + 53) = 0u;
  *((_OWORD *)this + 54) = 0u;
  *((_OWORD *)this + 55) = 0u;
  *((_OWORD *)this + 56) = 0u;
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_1E98B7458;
  __p.__r_.__value_.__l.__size_ = (std::string::size_type)this + 792;
  p_p = &__p;
  AsyncMessenger::addCallback((uint64_t)this + 304, 0, &__p);
  v17 = p_p;
  if (p_p == &__p)
  {
    v18 = 4;
    v17 = &__p;
  }
  else
  {
    if (!p_p)
      goto LABEL_33;
    v18 = 5;
  }
  (*(void (**)(void))(v17->__r_.__value_.__r.__words[0] + 8 * v18))();
LABEL_33:
  v19 = *((_QWORD *)this + 99);
  v22.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_1E98B74A0;
  v22.__r_.__value_.__l.__size_ = (std::string::size_type)this + 792;
  v20 = &v22;
  v23 = &v22;
  if ((std::string *)v19 == &v22)
  {
    v21 = 4;
LABEL_42:
    (*(void (**)(void))(v20->__r_.__value_.__r.__words[0] + 8 * v21))();
    goto LABEL_43;
  }
  if (*(_QWORD *)(v19 + 24) == v19)
  {
    std::__function::__func<UMPStream::EndpointManager::EndpointManager(UMPCIServerContext &)::$_1,std::allocator<UMPStream::EndpointManager::EndpointManager(UMPCIServerContext &)::$_1>,std::optional<unsigned char> ()(unsigned int,unsigned int,unsigned char)>::__clone((uint64_t)&v22, v25);
    v23 = 0;
    (*(void (**)(uint64_t, std::string *))(*(_QWORD *)v19 + 24))(v19, &v22);
    (*(void (**)(_QWORD))(**(_QWORD **)(v19 + 24) + 32))(*(_QWORD *)(v19 + 24));
    *(_QWORD *)(v19 + 24) = 0;
    v23 = &v22;
    (*(void (**)(_QWORD *, uint64_t))(v25[0] + 24))(v25, v19);
    (*(void (**)(_QWORD *))(v25[0] + 32))(v25);
    *(_QWORD *)(v19 + 24) = v19;
    v20 = v23;
  }
  else
  {
    std::__function::__func<UMPStream::EndpointManager::EndpointManager(UMPCIServerContext &)::$_1,std::allocator<UMPStream::EndpointManager::EndpointManager(UMPCIServerContext &)::$_1>,std::optional<unsigned char> ()(unsigned int,unsigned int,unsigned char)>::__clone((uint64_t)&v22, (_QWORD *)v19);
    v20 = *(std::string **)(v19 + 24);
    v23 = v20;
    *(_QWORD *)(v19 + 24) = v19;
  }
  if (v20 == &v22)
  {
    v21 = 4;
    v20 = &v22;
    goto LABEL_42;
  }
  if (v20)
  {
    v21 = 5;
    goto LABEL_42;
  }
LABEL_43:
  *((_QWORD *)this + 114) = (char *)this + 192;
  *((_QWORD *)this + 115) = 0;
  BackgroundAppManager::Update((MIDIServer *)((char *)this + 912));
}

void sub_1D4EC1B80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _Unwind_Exception *exception_object, _QWORD *a10, CADeprecated::CAMutex *a11, CADeprecated::CAMutex *a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34)
{
  _QWORD *v34;
  uint64_t *v35;
  _QWORD *v36;
  uint64_t v37;
  caulk::thread **v38;
  uint64_t v39;
  uint64_t v40;
  _QWORD *v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;

  v40 = 0;
  while (1)
  {
    v41 = *(_QWORD **)(v37 + v40 + 536);
    if ((_QWORD *)(v37 + v40 + 512) == v41)
      break;
    if (v41)
    {
      v42 = 5;
LABEL_6:
      (*(void (**)(void))(*v41 + 8 * v42))();
    }
    v40 -= 32;
    if (v40 == -64)
    {
      std::mutex::~mutex((std::mutex *)(v37 + 328));
      MEMORY[0x1D826B744](v39);
      std::unique_ptr<caulk::thread>::reset[abi:ne180100](v38, 0);
      if (a33 < 0)
        operator delete(__p);
      v43 = *(_QWORD **)(v37 + 296);
      if (v43 == v36)
      {
        v44 = 4;
        goto LABEL_14;
      }
      if (v43)
      {
        v44 = 5;
        v36 = *(_QWORD **)(v37 + 296);
LABEL_14:
        (*(void (**)(_QWORD *))(*v36 + 8 * v44))(v36);
      }
      std::unique_ptr<MIDIDriverMgr>::reset[abi:ne180100](v35, 0);
      OwnedPtrVector<ClientProcess *>::~OwnedPtrVector(a10);
      OwnedPtrVector<MIDIClient *>::~OwnedPtrVector(v34);
      CADeprecated::CAMutex::~CAMutex(a11);
      CADeprecated::CAMutex::~CAMutex(a12);
      _Unwind_Resume(a1);
    }
  }
  v41 = (_QWORD *)(v37 + v40 + 512);
  v42 = 4;
  goto LABEL_6;
}

void sub_1D4EC1DFC()
{
  JUMPOUT(0x1D4EC1DECLL);
}

void UMPStream::EndpointManager::~EndpointManager(UMPStream::EndpointManager *this)
{
  void *v2;
  void **v3;

  v2 = (void *)*((_QWORD *)this + 12);
  if (v2)
  {
    *((_QWORD *)this + 13) = v2;
    operator delete(v2);
  }
  std::mutex::~mutex((std::mutex *)((char *)this + 32));
  v3 = (void **)((char *)this + 8);
  std::vector<std::unique_ptr<UMPStream::EndpointPair>>::__destroy_vector::operator()[abi:ne180100](&v3);
}

void MIDICI::DeviceManager::~DeviceManager(MIDICI::DeviceManager *this)
{
  uint64_t v2;
  void *v3;
  void **v4;

  v2 = *((_QWORD *)this + 20);
  *((_QWORD *)this + 20) = 0;
  if (v2)
    MEMORY[0x1D826BA98](v2, 0x1000C40504FFAC1);
  v3 = (void *)*((_QWORD *)this + 16);
  if (v3)
  {
    *((_QWORD *)this + 17) = v3;
    operator delete(v3);
  }
  std::__tree<std::__value_type<unsigned int,MIDICI::SourceState>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,MIDICI::SourceState>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,MIDICI::SourceState>>>::destroy(*((_QWORD **)this + 14));
  std::mutex::~mutex((std::mutex *)((char *)this + 32));
  v4 = (void **)((char *)this + 8);
  std::vector<std::unique_ptr<MIDICI::Device>>::__destroy_vector::operator()[abi:ne180100](&v4);
}

void UMPCIServerContext::~UMPCIServerContext(UMPCIServerContext *this)
{
  char *v2;
  char *v3;
  uint64_t v4;
  UMPCIServerContext *v5;
  uint64_t v6;
  UMPCIServerContext *v7;
  uint64_t v8;

  v2 = (char *)this + 304;
  v3 = (char *)*((_QWORD *)this + 41);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v3 + 8 * v4))();
LABEL_6:
  v5 = (UMPCIServerContext *)*((_QWORD *)this + 37);
  if (v5 == (UMPCIServerContext *)((char *)this + 272))
  {
    v6 = 4;
    v5 = (UMPCIServerContext *)((char *)this + 272);
  }
  else
  {
    if (!v5)
      goto LABEL_11;
    v6 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v5 + 8 * v6))();
LABEL_11:
  AsyncMessenger::~AsyncMessenger((UMPCIServerContext *)((char *)this + 32));
  v7 = (UMPCIServerContext *)*((_QWORD *)this + 3);
  if (v7 == this)
  {
    v8 = 4;
    v7 = this;
  }
  else
  {
    if (!v7)
      return;
    v8 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v7 + 8 * v8))();
}

_QWORD *std::__function::__value_func<void ()(UMPCIObjectEvent,unsigned int,applesauce::CF::DictionaryRef)>::swap[abi:ne180100](_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x1E0C80C00];
  if (a2 != result)
  {
    v3 = result;
    v4 = (_QWORD *)result[3];
    v5 = (_QWORD *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, v6);
        (*(void (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(_QWORD *, _QWORD *))(v6[0] + 24))(v6, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(*result + 24))(result, a2);
        result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a2 + 24))(a2, result);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_1D4EC20E8(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

void std::__function::__func<UMPCIServerContext::UMPCIServerContext(void)::{lambda(UMPCIObjectEvent,unsigned int,applesauce::CF::DictionaryRef)#1},std::allocator<UMPCIServerContext::UMPCIServerContext(void)::{lambda(UMPCIObjectEvent,unsigned int,applesauce::CF::DictionaryRef)#1}>,void ()(UMPCIObjectEvent,unsigned int,applesauce::CF::DictionaryRef)>::~__func()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *std::__function::__func<UMPCIServerContext::UMPCIServerContext(void)::{lambda(UMPCIObjectEvent,unsigned int,applesauce::CF::DictionaryRef)#1},std::allocator<UMPCIServerContext::UMPCIServerContext(void)::{lambda(UMPCIObjectEvent,unsigned int,applesauce::CF::DictionaryRef)#1}>,void ()(UMPCIObjectEvent,unsigned int,applesauce::CF::DictionaryRef)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E98B71D0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<UMPCIServerContext::UMPCIServerContext(void)::{lambda(UMPCIObjectEvent,unsigned int,applesauce::CF::DictionaryRef)#1},std::allocator<UMPCIServerContext::UMPCIServerContext(void)::{lambda(UMPCIObjectEvent,unsigned int,applesauce::CF::DictionaryRef)#1}>,void ()(UMPCIObjectEvent,unsigned int,applesauce::CF::DictionaryRef)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E98B71D0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<UMPCIServerContext::UMPCIServerContext(void)::{lambda(UMPCIObjectEvent,unsigned int,applesauce::CF::DictionaryRef)#1},std::allocator<UMPCIServerContext::UMPCIServerContext(void)::{lambda(UMPCIObjectEvent,unsigned int,applesauce::CF::DictionaryRef)#1}>,void ()(UMPCIObjectEvent,unsigned int,applesauce::CF::DictionaryRef)>::operator()(uint64_t a1, int *a2, int *a3, CFDictionaryRef *a4)
{
  int v4;
  int v5;
  CFDictionaryRef CFDictionaryRef;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t block;
  uint64_t v11;
  void (*v12)(uint64_t);
  void *v13;
  uint64_t v14;
  CFTypeRef v15;
  int v16;
  int v17;

  v4 = *a2;
  v5 = *a3;
  CFDictionaryRef = *a4;
  *a4 = 0;
  v7 = *(_QWORD *)(a1 + 8);
  if (!CFDictionaryRef)
  {
    block = 0;
    v11 = 0;
    CFDictionaryRef = applesauce::CF::details::make_CFDictionaryRef((uint64_t)&block);
  }
  dispatch_get_global_queue(0, 0);
  v8 = objc_claimAutoreleasedReturnValue();
  block = MEMORY[0x1E0C809B0];
  v11 = 3321888768;
  v12 = ___ZZN18UMPCIServerContextC1EvENKUl16UMPCIObjectEventjN10applesauce2CF13DictionaryRefEE_clES0_jS3__block_invoke;
  v13 = &__block_descriptor_56_ea8_40c36_ZTSN10applesauce2CF13DictionaryRefE_e5_v8__0l;
  v14 = v7;
  v16 = v5;
  if (CFDictionaryRef)
    CFRetain(CFDictionaryRef);
  v15 = CFDictionaryRef;
  v17 = v4;
  dispatch_async(v8, &block);

  v9 = *(_QWORD *)(v7 + 328);
  if (v9)
  {
    if (CFDictionaryRef)
    {
      CFRetain(CFDictionaryRef);
      v9 = *(_QWORD *)(v7 + 328);
    }
    std::function<void ()(UMPCIObjectEvent,unsigned int,applesauce::CF::DictionaryRef)>::operator()(v9, v4, v5);
    if (CFDictionaryRef)
      CFRelease(CFDictionaryRef);
  }
  if (v15)
    CFRelease(v15);
  if (CFDictionaryRef)
    CFRelease(CFDictionaryRef);
}

void sub_1D4EC2280(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFTypeRef cf, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, CFTypeRef a15)
{
  const void *v15;

  if (cf)
    CFRelease(cf);
  if (a15)
    CFRelease(a15);
  if (v15)
    CFRelease(v15);
  _Unwind_Resume(exception_object);
}

void ___ZZN18UMPCIServerContextC1EvENKUl16UMPCIObjectEventjN10applesauce2CF13DictionaryRefEE_clES0_jS3__block_invoke(uint64_t a1)
{
  unsigned int v2;
  uint64_t v3;
  const void *v4;
  int v5;
  uint64_t v6;
  _DWORD v7[2];
  uint64_t v8;
  SetupManager *v9;

  _MIDIObjectSetDictionaryProperty((MIDIServer *)*(unsigned int *)(a1 + 48), CFSTR("object description"), *(_QWORD *)(a1 + 40));
  v2 = *(_DWORD *)(a1 + 48);
  v3 = *(unsigned int *)(a1 + 52);
  v4 = *(const void **)(a1 + 40);
  if (v4)
    CFRetain(v4);
  if (v3 > 2)
    v5 = -1;
  else
    v5 = dword_1D4F1927C[v3];
  v7[0] = v5;
  v7[1] = 24;
  v8 = v2;
  v9 = (SetupManager *)CFRetain(v4);
  v6 = SetupManager::instance(v9);
  SetupManager::AddNotification(v6, (uint64_t)v7);
  if (v4)
    CFRelease(v4);
}

void sub_1D4EC2370(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  applesauce::CF::DictionaryRef::~DictionaryRef(&a9);
  _Unwind_Resume(a1);
}

_QWORD *__copy_helper_block_ea8_40c36_ZTSN10applesauce2CF13DictionaryRefE(_QWORD *result, uint64_t a2)
{
  _QWORD *v2;
  uint64_t v3;

  v2 = result;
  v3 = *(_QWORD *)(a2 + 40);
  if (v3)
    result = CFRetain(*(CFTypeRef *)(a2 + 40));
  v2[5] = v3;
  return result;
}

void __destroy_helper_block_ea8_40c36_ZTSN10applesauce2CF13DictionaryRefE(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 40);
  if (v1)
    CFRelease(v1);
}

uint64_t caulk::thread_proxy<std::tuple<caulk::thread::attributes,AsyncMessenger::AsyncMessenger(std::string const&,float)::{lambda(void)#1},std::tuple<>>>(caulk::thread::attributes *a1)
{
  uint64_t v2;
  unint64_t *v3;
  uint64_t v4;
  unsigned __int8 v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int i;
  char v14;
  char v15;
  uint64_t v16;
  unsigned __int8 v17;
  __int16 v19;

  caulk::thread::attributes::apply_to_this_thread(a1);
  v2 = *((_QWORD *)a1 + 8);
  v3 = (unint64_t *)(v2 + 96);
  v4 = v2 + 176;
  do
  {
    caulk::mach::semaphore::timed_wait_or_error((caulk::mach::semaphore *)(v2 + 12), *(float *)(v2 + 88));
    v5 = atomic_load((unsigned __int8 *)(v2 + 8));
    if ((v5 & 1) != 0)
      break;
    std::mutex::lock((std::mutex *)(v2 + 24));
    v19 = 0;
    while (1)
    {
      v6 = *(_QWORD *)(v2 + 160);
      if (v6)
        goto LABEL_10;
      do
        v7 = __ldaxr(v3);
      while (__stxr(0, v3));
      if (!v7)
        break;
      v6 = 0;
      do
      {
        v8 = v6;
        v6 = v7;
        v7 = atomic_load((unint64_t *)v7);
        atomic_store(v8, (unint64_t *)v6);
      }
      while (v7);
      *(_QWORD *)(v2 + 160) = v6;
LABEL_10:
      v9 = atomic_load((unint64_t *)v6);
      *(_QWORD *)(v2 + 160) = v9;
      v10 = *(unsigned __int8 *)(v6 + 8);
      v11 = *(_QWORD *)(v4 + 32 * v10 + 24);
      if (v11)
      {
        std::function<void ()(unsigned int,MIDIEventList const*)>::operator()(v11, *(_DWORD *)(v6 + 9), v6 + 13);
        *((_BYTE *)&v19 + v10) = 1;
      }
      v12 = v6 + 21;
      for (i = *(_DWORD *)(v6 + 17); i; --i)
        v12 += 4 * *(unsigned int *)(v12 + 8) + 12;
      (*(void (**)(_QWORD, unint64_t, unint64_t, uint64_t))(**(_QWORD **)(v2 + 168) + 24))(*(_QWORD *)(v2 + 168), v6, v12 - v6, 8);
    }
    v14 = 1;
    do
    {
      v15 = v14;
      v16 = *(_QWORD *)(v4 + 32 * v7 + 24);
      if (v16 && !*((_BYTE *)&v19 + v7))
        std::function<void ()(unsigned int,MIDIEventList const*)>::operator()(v16, 0, 0);
      v14 = 0;
      v7 = 1;
    }
    while ((v15 & 1) != 0);
    v17 = atomic_load((unsigned __int8 *)(v2 + 8));
    std::mutex::unlock((std::mutex *)(v2 + 24));
  }
  while ((v17 & 1) == 0);
  if (a1)
    std::default_delete<std::tuple<caulk::thread::attributes,AsyncMessenger::AsyncMessenger(std::string const&,float)::{lambda(void)#1},std::tuple<>>>::operator()[abi:ne180100]((uint64_t)a1);
  return 0;
}

void sub_1D4EC2560(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    std::default_delete<std::tuple<caulk::thread::attributes,AsyncMessenger::AsyncMessenger(std::string const&,float)::{lambda(void)#1},std::tuple<>>>::operator()[abi:ne180100](v1);
  _Unwind_Resume(exception_object);
}

uint64_t std::default_delete<std::tuple<caulk::thread::attributes,AsyncMessenger::AsyncMessenger(std::string const&,float)::{lambda(void)#1},std::tuple<>>>::operator()[abi:ne180100](uint64_t result)
{
  if (result)
  {
    if (*(_BYTE *)(result + 24))
    {
      if (*(char *)(result + 23) < 0)
        operator delete(*(void **)result);
    }
    JUMPOUT(0x1D826BA98);
  }
  return result;
}

uint64_t std::function<void ()(unsigned int,MIDIEventList const*)>::operator()(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v4;
  int v5;

  v5 = a2;
  v4 = a3;
  if (!a1)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, int *, uint64_t *))(*(_QWORD *)a1 + 48))(a1, &v5, &v4);
}

void MIDIServer::ClientDied(MIDIServer *this, ClientProcess *a2)
{
  MIDICISessionManager *v3;
  int v4;
  uint64_t v5;
  int v6;
  MIDICIServerSession **v7;
  MIDICIServerSession **v8;
  MIDICIServerSession **i;
  MIDICIServerSession *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  BOOL v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  uint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  BOOL v26;
  BOOL v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  MIDIServer *v31;
  uint64_t *v32;
  std::mutex *v33;
  uint64_t *v34;
  uint64_t *v35;
  uint64_t v36;
  int *v38;
  int *v39;
  int *v40;
  int v41;
  int *v42;
  uint64_t v43;
  uint64_t *j;
  uint64_t v45;
  uint64_t v46;
  uint64_t v48;
  int v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  uint64_t v53;
  int *v54;
  int *v55;
  int v56;
  int *v57;
  uint64_t v58;
  int v59;
  MIDIServer *v60;
  int v61;
  uint64_t *v62;
  std::mutex *v63;
  uint64_t *v64;
  uint64_t *v65;
  uint64_t v66;
  int *v68;
  int *v69;
  int *v70;
  int v71;
  int *v72;
  uint64_t v73;
  uint64_t *k;
  uint64_t v75;
  uint64_t v76;
  uint64_t v78;
  int v79;
  uint64_t v80;
  unint64_t v81;
  unint64_t v82;
  uint64_t v83;
  int *v84;
  int *v85;
  int v86;
  int *v87;
  uint64_t v88;
  int v89;
  SetupManager *v90;
  MIDIServer *v91;
  ClientProcess *v92;
  uint64_t v93;
  MIDIServer **v94;
  MIDIServer **v95;
  MIDIServer **v96;
  MIDIServer **v97;
  int64_t v98;
  uint64_t *v99;
  MIDIServer *v100;
  uint64_t *v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  BOOL v106;
  std::mutex *v107;
  std::mutex *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t *v111;
  int v112;
  MIDIServer *v113;
  int v114;
  uint64_t v115;
  std::__shared_weak_count *v116;
  uint64_t (**v117)();
  _DWORD v118[8];
  CFTypeRef cf;
  int v120[8];
  uint64_t v121;

  v121 = *MEMORY[0x1E0C80C00];
  v111 = MIDIServer::defaultInstance(this) + 2;
  v3 = (MIDICISessionManager *)(*(uint64_t (**)(void))(*v111 + 16))();
  v112 = (int)v3;
  v113 = this;
  v4 = *((_DWORD *)this + 2);
  v5 = MIDICISessionManager::Instance(v3);
  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v5 + 32) + 16))(v5 + 32);
  v8 = *(MIDICIServerSession ***)(v5 + 128);
  v7 = *(MIDICIServerSession ***)(v5 + 136);
  if (v8 != v7)
  {
    while (*((_DWORD *)*v8 + 18) != v4)
    {
      if (++v8 == v7)
      {
        v8 = *(MIDICIServerSession ***)(v5 + 136);
        goto LABEL_12;
      }
    }
    MIDICIServerSession::Invalidate(*v8);
    if (v8 != v7)
    {
      for (i = v8 + 1; i != v7; ++i)
      {
        v10 = *i;
        if (*((_DWORD *)*i + 18) == v4)
          MIDICIServerSession::Invalidate(v10);
        else
          *v8++ = v10;
      }
    }
  }
LABEL_12:
  OwnedPtrVector<MIDICIServerSession *>::erase((_QWORD *)(v5 + 120), (uint64_t *)v8, *(uint64_t **)(v5 + 136));
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)(v5 + 32) + 24))(v5 + 32);
  v117 = caulk::inplace_function<BOOL ()(std::shared_ptr<MIDICIServerResponder>),32ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<MIDICIResponderManager::ClientDied(int)::{lambda(std::shared_ptr<MIDICIServerResponder>)#1}>;
  v118[0] = v4;
  std::recursive_mutex::lock(*(std::recursive_mutex **)(v5 + 160));
  v11 = *(_QWORD *)(v5 + 176);
  std::recursive_mutex::lock(*(std::recursive_mutex **)(v5 + 160));
  v12 = *(_QWORD *)(v5 + 184);
  cf = caulk::inplace_function<BOOL ()(std::shared_ptr<MIDICIServerResponder>),32ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<MIDICIResponderManager::ClientDied(int)::{lambda(std::shared_ptr<MIDICIServerResponder>)#1}>;
  caulk::inplace_function_detail::vtable<BOOL,std::shared_ptr<MIDICIServerResponder>>::vtable<MIDICIResponderManager::ClientDied(int)::{lambda(std::shared_ptr<MIDICIServerResponder>)#1}>(caulk::inplace_function_detail::wrapper<MIDICIResponderManager::ClientDied(int)::{lambda(std::shared_ptr<MIDICIServerResponder>)#1}>)::{lambda(void *,void *)#1}::__invoke(v120, v118);
  if (v11 == v12)
  {
LABEL_43:
    v13 = v11;
    goto LABEL_44;
  }
  v13 = v12;
  while (1)
  {
    v14 = *(std::__shared_weak_count **)(v11 + 8);
    v115 = *(_QWORD *)v11;
    v116 = v14;
    if (v14)
    {
      p_shared_owners = (unint64_t *)&v14->__shared_owners_;
      do
        v16 = __ldxr(p_shared_owners);
      while (__stxr(v16 + 1, p_shared_owners));
    }
    v17 = (*(BOOL (**)(int *, uint64_t *))cf)(v120, &v115);
    v18 = v116;
    if (v116)
    {
      v19 = (unint64_t *)&v116->__shared_owners_;
      do
        v20 = __ldaxr(v19);
      while (__stlxr(v20 - 1, v19));
      if (!v20)
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
    }
    if (v17)
      break;
    v11 += 16;
    if (v11 == v12)
      goto LABEL_44;
  }
  if (v11 != v12)
  {
    v21 = v11 + 16;
    if (v11 + 16 != v12)
    {
      v13 = v11;
      while (1)
      {
        v23 = *(_QWORD *)(v11 + 16);
        v22 = *(std::__shared_weak_count **)(v11 + 24);
        v11 = v21;
        v115 = v23;
        v116 = v22;
        if (v22)
        {
          v24 = (unint64_t *)&v22->__shared_owners_;
          do
            v25 = __ldxr(v24);
          while (__stxr(v25 + 1, v24));
        }
        v26 = (*(BOOL (**)(int *, uint64_t *))cf)(v120, &v115);
        v27 = v26;
        v28 = v116;
        if (v116)
        {
          v29 = (unint64_t *)&v116->__shared_owners_;
          do
            v30 = __ldaxr(v29);
          while (__stlxr(v30 - 1, v29));
          if (!v30)
            break;
        }
        if (!v26)
          goto LABEL_38;
LABEL_39:
        v21 = v11 + 16;
        if (v11 + 16 == v12)
          goto LABEL_44;
      }
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
      if (v27)
        goto LABEL_39;
LABEL_38:
      std::shared_ptr<MIDICIServerResponder>::operator=[abi:ne180100](v13, (__int128 *)v11);
      v13 += 16;
      goto LABEL_39;
    }
    goto LABEL_43;
  }
LABEL_44:
  (*((void (**)(int *))cf + 3))(v120);
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(v5 + 160));
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(v5 + 160));
  std::recursive_mutex::lock(*(std::recursive_mutex **)(v5 + 160));
  std::recursive_mutex::lock(*(std::recursive_mutex **)(v5 + 160));
  std::vector<std::shared_ptr<MIDICIServerResponder>>::erase(v5 + 176, v13, *(_QWORD *)(v5 + 184));
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(v5 + 160));
  std::recursive_mutex::unlock(*(std::recursive_mutex **)(v5 + 160));
  v31 = (MIDIServer *)((uint64_t (*)(_DWORD *))v117[3])(v118);
  v32 = MIDIServer::defaultInstance(v31);
  v33 = (std::mutex *)(v32 + 103);
  std::mutex::lock((std::mutex *)(v32 + 103));
  v34 = (uint64_t *)v32[100];
  v35 = (uint64_t *)v32[101];
  v114 = v4;
  if (v34 == v35)
  {
    v107 = (std::mutex *)(v32 + 103);
    v109 = (uint64_t)(v32 + 100);
    v38 = 0;
    v39 = 0;
    v40 = 0;
  }
  else
  {
    while (1)
    {
      v36 = *(_QWORD *)(*v34 + 44);
      if ((v36 & 0xFF00000000) != 0 && v4 == (_DWORD)v36)
        break;
      if (++v34 == v35)
      {
        std::vector<std::unique_ptr<UMPStream::EndpointPair>>::erase((uint64_t)(v32 + 100), v35, (uint64_t *)v32[101]);
        goto LABEL_89;
      }
    }
    v107 = (std::mutex *)(v32 + 103);
    v109 = (uint64_t)(v32 + 100);
    v41 = *(_DWORD *)(*v34 + 8);
    v42 = (int *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(1uLL);
    v40 = &v42[v43];
    *v42 = v41;
    v39 = v42 + 1;
    v38 = v42;
  }
  if (v34 == v35)
  {
    v34 = v35;
  }
  else
  {
    for (j = v34 + 1; j != v35; ++j)
    {
      v45 = *j;
      v46 = *(_QWORD *)(*j + 44);
      if ((v46 & 0xFF00000000) != 0 && v114 == (_DWORD)v46)
      {
        v49 = *(_DWORD *)(v45 + 8);
        if (v39 >= v40)
        {
          v50 = v39 - v38;
          v51 = v50 + 1;
          if ((unint64_t)(v50 + 1) >> 62)
            std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
          if (((char *)v40 - (char *)v38) >> 1 > v51)
            v51 = ((char *)v40 - (char *)v38) >> 1;
          if ((unint64_t)((char *)v40 - (char *)v38) >= 0x7FFFFFFFFFFFFFFCLL)
            v52 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v52 = v51;
          if (v52)
            v52 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(v52);
          else
            v53 = 0;
          v54 = (int *)(v52 + 4 * v50);
          *v54 = v49;
          v55 = v54 + 1;
          while (v39 != v38)
          {
            v56 = *--v39;
            *--v54 = v56;
          }
          v40 = (int *)(v52 + 4 * v53);
          if (v38)
            operator delete(v38);
          v38 = v54;
          v39 = v55;
        }
        else
        {
          *v39++ = v49;
        }
      }
      else
      {
        *j = 0;
        v48 = *v34;
        *v34 = v45;
        if (v48)
          std::default_delete<UMPStream::EndpointPair>::operator()[abi:ne180100](v48);
        ++v34;
      }
    }
  }
  std::vector<std::unique_ptr<UMPStream::EndpointPair>>::erase(v109, v34, (uint64_t *)v32[101]);
  if (v38 != v39)
  {
    v57 = v38;
    do
    {
      v58 = v32[99];
      v59 = *v57;
      cf = 0;
      UMPCIServerContext::sendNotificationForObject(v58, 2, v59, &cf);
      if (cf)
        CFRelease(cf);
      ++v57;
    }
    while (v57 != v39);
  }
  v33 = v107;
  if (v38)
    operator delete(v38);
LABEL_89:
  std::mutex::unlock(v33);
  v61 = v114;
  v62 = MIDIServer::defaultInstance(v60);
  v63 = (std::mutex *)(v62 + 82);
  std::mutex::lock((std::mutex *)(v62 + 82));
  v64 = (uint64_t *)v62[79];
  v65 = (uint64_t *)v62[80];
  if (v64 == v65)
  {
    v108 = (std::mutex *)(v62 + 82);
    v110 = (uint64_t)(v62 + 79);
    v68 = 0;
    v69 = 0;
    v70 = 0;
  }
  else
  {
    while (1)
    {
      v66 = *(_QWORD *)(*v64 + 44);
      if ((v66 & 0xFF00000000) != 0 && v114 == (_DWORD)v66)
        break;
      if (++v64 == v65)
      {
        std::vector<std::unique_ptr<MIDICI::Device>>::erase((uint64_t)(v62 + 79), (uint64_t *)v62[80], (uint64_t *)v62[80]);
        goto LABEL_134;
      }
    }
    v108 = (std::mutex *)(v62 + 82);
    v110 = (uint64_t)(v62 + 79);
    v71 = *(_DWORD *)(*v64 + 8);
    v72 = (int *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(1uLL);
    v70 = &v72[v73];
    *v72 = v71;
    v69 = v72 + 1;
    v68 = v72;
  }
  if (v64 == v65)
  {
    v64 = v65;
  }
  else
  {
    for (k = v64 + 1; k != v65; ++k)
    {
      v75 = *k;
      v76 = *(_QWORD *)(*k + 44);
      if ((v76 & 0xFF00000000) != 0 && v61 == (_DWORD)v76)
      {
        v79 = *(_DWORD *)(v75 + 8);
        if (v69 >= v70)
        {
          v80 = v69 - v68;
          v81 = v80 + 1;
          if ((unint64_t)(v80 + 1) >> 62)
            std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
          if (((char *)v70 - (char *)v68) >> 1 > v81)
            v81 = ((char *)v70 - (char *)v68) >> 1;
          if ((unint64_t)((char *)v70 - (char *)v68) >= 0x7FFFFFFFFFFFFFFCLL)
            v82 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v82 = v81;
          if (v82)
            v82 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(v82);
          else
            v83 = 0;
          v84 = (int *)(v82 + 4 * v80);
          *v84 = v79;
          v85 = v84 + 1;
          while (v69 != v68)
          {
            v86 = *--v69;
            *--v84 = v86;
          }
          v70 = (int *)(v82 + 4 * v83);
          if (v68)
            operator delete(v68);
          v68 = v84;
          v69 = v85;
          v61 = v114;
        }
        else
        {
          *v69++ = v79;
        }
      }
      else
      {
        *k = 0;
        v78 = *v64;
        *v64 = v75;
        if (v78)
          std::default_delete<MIDICI::Device>::operator()[abi:ne180100](v78);
        ++v64;
      }
    }
  }
  std::vector<std::unique_ptr<MIDICI::Device>>::erase(v110, v64, (uint64_t *)v62[80]);
  if (v68 != v69)
  {
    v87 = v68;
    do
    {
      v88 = v62[78];
      v89 = *v87;
      cf = 0;
      UMPCIServerContext::sendNotificationForObject(v88, 2, v89, &cf);
      if (cf)
        CFRelease(cf);
      ++v87;
    }
    while (v87 != v69);
  }
  v63 = v108;
  if (v68)
    operator delete(v68);
LABEL_134:
  std::mutex::unlock(v63);
  v91 = (MIDIServer *)SetupManager::instance(v90);
  v92 = v113;
  v93 = *(_QWORD *)v91;
  if (*(_QWORD *)v91)
  {
    v95 = *(MIDIServer ***)(v93 + 184);
    v94 = *(MIDIServer ***)(v93 + 192);
    if (v95 != v94)
    {
      do
      {
        v96 = v95;
        while (1)
        {
          v91 = *v96;
          if (!*((_QWORD *)*v96 + 2) && *((ClientProcess **)v91 + 4) == v92)
            break;
          if (++v96 == v94)
            goto LABEL_144;
        }
        v91 = (MIDIServer *)(*(uint64_t (**)(MIDIServer *))(*(_QWORD *)v91 + 8))(v91);
        v97 = *(MIDIServer ***)(v93 + 192);
        v98 = (char *)v97 - (char *)(v96 + 1);
        if (v97 != v96 + 1)
          v91 = (MIDIServer *)memmove(v96, v96 + 1, (char *)v97 - (char *)(v96 + 1));
        v95 = *(MIDIServer ***)(v93 + 184);
        v94 = (MIDIServer **)((char *)v96 + v98);
        *(_QWORD *)(v93 + 192) = (char *)v96 + v98;
        v92 = v113;
      }
      while (v95 != (MIDIServer **)((char *)v96 + v98));
    }
  }
LABEL_144:
  v99 = MIDIServer::defaultInstance(v91);
  ClientTable::ProcessQuit((ClientTable *)(v99 + 24), v92);
  v101 = MIDIServer::defaultInstance(v100);
  v103 = v101[25];
  v102 = v101[26];
  if (v103 == v102)
    goto LABEL_152;
  v104 = v103 + 8;
  do
  {
    v105 = *(_QWORD *)(*(_QWORD *)(v104 - 8) + 48);
    if (v105)
      v106 = 1;
    else
      v106 = v104 == v102;
    v104 += 8;
  }
  while (!v106);
  if (!v105)
LABEL_152:
    ScheduleCheckServerShutdown((MIDIServer *)v101);
  if (v112)
    (*(void (**)(uint64_t *))(*v111 + 24))(v111);
}

void sub_1D4EC2E14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::mutex *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::exception a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

void sub_1D4EC2F10(uint64_t a1, int a2)
{
  if (a2)
    JUMPOUT(0x1D4EC2F1CLL);
  JUMPOUT(0x1D4EC2F00);
}

void sub_1D4EC2F64(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_list va;

  va_start(va, a17);
  if (a2)
  {
    applesauce::CF::DictionaryRef::~DictionaryRef((const void **)va);
    JUMPOUT(0x1D4EC2F78);
  }
  JUMPOUT(0x1D4EC2F00);
}

void sub_1D4EC2F84(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_list va;

  va_start(va, a17);
  if (a2)
  {
    applesauce::CF::DictionaryRef::~DictionaryRef((const void **)va);
    JUMPOUT(0x1D4EC2F98);
  }
  JUMPOUT(0x1D4EC2F00);
}

void sub_1D4EC3010(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, int a14)
{
  if (a14)
    (*(void (**)(uint64_t))(*(_QWORD *)a12 + 24))(a12);
  JUMPOUT(0x1D4EC2F00);
}

BOOL caulk::inplace_function_detail::vtable<BOOL,std::shared_ptr<MIDICIServerResponder>>::vtable<MIDICIResponderManager::ClientDied(int)::{lambda(std::shared_ptr<MIDICIServerResponder>)#1}>(caulk::inplace_function_detail::wrapper<MIDICIResponderManager::ClientDied(int)::{lambda(std::shared_ptr<MIDICIServerResponder>)#1}>)::{lambda(void *,std::shared_ptr<MIDICIServerResponder>&&)#1}::__invoke(int *a1, uint64_t *a2)
{
  uint64_t v2;
  std::__shared_weak_count *v3;
  int v4;
  int v5;
  unint64_t *p_shared_owners;
  unint64_t v7;

  v2 = *a2;
  v3 = (std::__shared_weak_count *)a2[1];
  *a2 = 0;
  a2[1] = 0;
  v4 = *(_DWORD *)(v2 + 80);
  v5 = *a1;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  return v4 == v5;
}

_DWORD *caulk::inplace_function_detail::vtable<BOOL,std::shared_ptr<MIDICIServerResponder>>::vtable<MIDICIResponderManager::ClientDied(int)::{lambda(std::shared_ptr<MIDICIServerResponder>)#1}>(caulk::inplace_function_detail::wrapper<MIDICIResponderManager::ClientDied(int)::{lambda(std::shared_ptr<MIDICIServerResponder>)#1}>)::{lambda(void *,void *)#1}::__invoke(_DWORD *result, _DWORD *a2)
{
  *result = *a2;
  return result;
}

_DWORD *caulk::inplace_function_detail::vtable<BOOL,std::shared_ptr<MIDICIServerResponder>>::vtable<MIDICIResponderManager::ClientDied(int)::{lambda(std::shared_ptr<MIDICIServerResponder>)#1}>(caulk::inplace_function_detail::wrapper<MIDICIResponderManager::ClientDied(int)::{lambda(std::shared_ptr<MIDICIServerResponder>)#1}>)::{lambda(void *,void *)#2}::__invoke(_DWORD *result, _DWORD *a2)
{
  *result = *a2;
  return result;
}

void MIDIServer::startMIDI(MIDIServer *this, int a2)
{
  unsigned __int8 *v2;
  NSObject *v3;
  SetupManager *v4;
  MIDIDriverPlugin *v5;
  int v6;
  MIDIDriverMgr **v7;
  MIDIDriverMgr **v8;
  uint64_t DriverDeviceList;
  MIDIDriverMgr *v10;
  int v11;
  int v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v2 = *(unsigned __int8 **)(MIDIServer::defaultInstance(this, a2) + 264);
  gDriverTable();
  v3 = gDriverTable(void)::drvtbl;
  v4 = (SetupManager *)os_log_type_enabled((os_log_t)gDriverTable(void)::drvtbl, OS_LOG_TYPE_DEBUG);
  if ((_DWORD)v4)
  {
    v6 = *v2;
    v12 = 136315650;
    v13 = "DriverTable.cpp";
    v14 = 1024;
    v15 = 144;
    v16 = 1024;
    v17 = v6;
    _os_log_impl(&dword_1D4E88000, v3, OS_LOG_TYPE_DEBUG, "%25s:%-5d StartMIDI: (already running: %d)", (uint8_t *)&v12, 0x18u);
  }
  if (!*v2)
  {
    v7 = (MIDIDriverMgr **)*((_QWORD *)v2 + 2);
    v8 = (MIDIDriverMgr **)*((_QWORD *)v2 + 3);
    while (v7 != v8)
    {
      DriverDeviceList = MIDIDriverMgr::GetDriverDeviceList(*v7, v5);
      v10 = *v7++;
      (*(void (**)(MIDIDriverMgr *, uint64_t))(*(_QWORD *)v10 + 88))(v10, DriverDeviceList);
      v4 = (SetupManager *)MIDIDeviceListDispose(DriverDeviceList);
    }
    *v2 = 1;
    if (*(_QWORD *)SetupManager::instance(v4))
      MIDISetup::SetMIDIRunning((MIDISetup *)*v2, v11);
  }
}

void CASmartPreferences::CASmartPreferences(CASmartPreferences *this)
{
  NSObject *global_queue;
  _QWORD handler[5];

  CASmartPreferences::instance(void)::global = 850045863;
  unk_1EFEFD8C0 = 0u;
  unk_1EFEFD8D0 = 0u;
  unk_1EFEFD8E0 = 0u;
  qword_1EFEFD8F0 = 0;
  qword_1EFEFD8F8 = (uint64_t)CFSetCreateMutable(0, 0, MEMORY[0x1E0C9B3B0]);
  global_queue = dispatch_get_global_queue(0, 0);
  xmmword_1EFEFD900 = 0u;
  *(_OWORD *)&qword_1EFEFD910 = 0u;
  qword_1EFEFD918 = (uint64_t)dispatch_source_create(MEMORY[0x1E0C80DC0], 1uLL, 0, global_queue);
  handler[0] = MEMORY[0x1E0C809B0];
  handler[1] = 0x40000000;
  handler[2] = ___ZN18CASmartPreferencesC2Ev_block_invoke;
  handler[3] = &__block_descriptor_tmp_1273;
  handler[4] = &CASmartPreferences::instance(void)::global;
  dispatch_source_set_event_handler((dispatch_source_t)qword_1EFEFD918, handler);
  dispatch_resume((dispatch_object_t)qword_1EFEFD918);
}

void sub_1D4EC32C0(_Unwind_Exception *a1)
{
  std::mutex::~mutex((std::mutex *)&CASmartPreferences::instance(void)::global);
  _Unwind_Resume(a1);
}

void ___ZN18CASmartPreferencesC2Ev_block_invoke(uint64_t a1)
{
  uint64_t v1;
  CFStringRef *v2;
  CFStringRef *v3;

  v1 = *(_QWORD *)(a1 + 32);
  std::mutex::lock((std::mutex *)v1);
  CFSetApplyFunction(*(CFSetRef *)(v1 + 64), (CFSetApplierFunction)SynchronizePrefDomain, 0);
  v2 = *(CFStringRef **)(v1 + 72);
  v3 = *(CFStringRef **)(v1 + 80);
  while (v2 != v3)
  {
    CASmartPreferences::Pref::Load(v2);
    v2 += 6;
  }
  std::mutex::unlock((std::mutex *)v1);
}

void sub_1D4EC3338(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t SynchronizePrefDomain(const __CFString *a1, void *a2)
{
  return CFPreferencesSynchronize(a1, (CFStringRef)*MEMORY[0x1E0C9B260], (CFStringRef)*MEMORY[0x1E0C9B250]);
}

CFPropertyListRef CASmartPreferences::Pref::Load(CFStringRef *this)
{
  CFPropertyListRef result;
  CFStringRef v3;
  CFPropertyListRef v4;

  result = CFPreferencesCopyAppValue(*this, this[1]);
  if (result)
  {
    v4 = result;
    v3 = this[5];
    if (!v3)
      std::__throw_bad_function_call[abi:ne180100]();
    return (CFPropertyListRef)(*((uint64_t (**)(CFStringRef, CFPropertyListRef *))v3->isa + 6))(v3, &v4);
  }
  return result;
}

BOOL CASmartPreferences::InterpretBoolean(CASmartPreferences *this, _BYTE *a2, BOOL *a3)
{
  const __CFBoolean *v4;
  CFTypeID v5;
  char v7;
  char *v8;
  int v9;
  BOOL v10;
  int valuePtr;
  char buffer[4];
  __int16 v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  valuePtr = 0;
  *a2 = 0;
  if (this)
  {
    v4 = this;
    v5 = CFGetTypeID(this);
    if (v5 == CFBooleanGetTypeID())
    {
      LODWORD(this) = CFBooleanGetValue(v4);
LABEL_6:
      *a2 = 1;
      return (_DWORD)this != 0;
    }
    if (v5 == CFNumberGetTypeID())
    {
      CFNumberGetValue(v4, kCFNumberIntType, &valuePtr);
      LODWORD(this) = valuePtr != 0;
      goto LABEL_6;
    }
    if (v5 != CFStringGetTypeID())
    {
      LODWORD(this) = 0;
      return (_DWORD)this != 0;
    }
    CFStringGetCString((CFStringRef)v4, buffer, 64, 0x600u);
    if (sscanf(buffer, "%d", &valuePtr) == 1)
    {
      *a2 = 1;
      LODWORD(this) = valuePtr != 0;
      return (_DWORD)this != 0;
    }
    v7 = buffer[0];
    if (buffer[0])
    {
      v8 = &buffer[1];
      do
      {
        *(v8 - 1) = __tolower(v7);
        v9 = *v8++;
        v7 = v9;
      }
      while (v9);
    }
    if (!(*(unsigned __int16 *)buffer ^ 0x6F6E | buffer[2])
      || (*(_DWORD *)buffer == 1936482662 ? (v10 = v13 == 101) : (v10 = 0), v10))
    {
      LODWORD(this) = 0;
      goto LABEL_6;
    }
    if (*(_DWORD *)buffer == 7562617 || !(*(_DWORD *)buffer ^ 0x65757274 | v13))
    {
      LODWORD(this) = 1;
      *a2 = 1;
    }
    else
    {
      LODWORD(this) = valuePtr;
    }
  }
  return (_DWORD)this != 0;
}

_QWORD *std::construct_at[abi:ne180100]<CASmartPreferences::Pref,__CFString const*&,__CFString const*&,std::function<BOOL ()(void const*)> &,CASmartPreferences::Pref*>(_QWORD *a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v7 = (_QWORD *)a4[3];
  if (!v7)
  {
    v13 = 0;
    *a1 = a2;
    a1[1] = a3;
LABEL_9:
    a1[5] = 0;
    return a1;
  }
  if (v7 == a4)
  {
    v13 = v12;
    (*(void (**)(_QWORD *, _QWORD *))(*a4 + 24))(a4, v12);
    v8 = v13;
  }
  else
  {
    v8 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*v7 + 16))(v7);
    v13 = v8;
  }
  *a1 = a2;
  a1[1] = a3;
  if (!v8)
    goto LABEL_9;
  if (v8 == v12)
  {
    a1[5] = a1 + 2;
    (*(void (**)(_QWORD *))(v12[0] + 24))(v12);
  }
  else
  {
    a1[5] = (*(uint64_t (**)(_QWORD *))(*v8 + 16))(v8);
  }
  v9 = v13;
  if (v13 == v12)
  {
    v10 = 4;
    v9 = v12;
    goto LABEL_15;
  }
  if (v13)
  {
    v10 = 5;
LABEL_15:
    (*(void (**)(void))(*v9 + 8 * v10))();
  }
  return a1;
}

void sub_1D4EC36B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  _Unwind_Resume(exception_object);
}

uint64_t std::__split_buffer<CASmartPreferences::Pref>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != v3)
  {
    *(_QWORD *)(a1 + 16) = v2 - 48;
    v4 = *(_QWORD **)(v2 - 8);
    if (v4 == (_QWORD *)(v2 - 32))
    {
      v4 = (_QWORD *)(v2 - 32);
      v5 = 4;
LABEL_7:
      (*(void (**)(void))(*v4 + 8 * v5))();
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      if (v4)
      {
        v5 = 5;
        goto LABEL_7;
      }
      v2 -= 48;
    }
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t CADeprecated::Task::RequestStop(CADeprecated::Task *this)
{
  *((_BYTE *)this + 136) = 1;
  return CADeprecated::CAGuard::Notify((CADeprecated::Task *)((char *)this + 144));
}

unint64_t CADeprecated::Task::Run(unint64_t this)
{
  uint64_t v1;
  CADeprecated::CAGuard *v2;
  int v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;

  if (!*(_BYTE *)(this + 136))
  {
    v1 = this;
    v2 = (CADeprecated::CAGuard *)(this + 144);
    do
    {
      v3 = (*(uint64_t (**)(CADeprecated::CAGuard *))(*(_QWORD *)(v1 + 144) + 16))(v2);
      if (!*(_BYTE *)(v1 + 280))
        goto LABEL_9;
      mach_absolute_time();
      v4 = __udivti3();
      if (*(_QWORD *)(v1 + 296) <= v4)
      {
        *(_BYTE *)(v1 + 280) = 0;
        (*(void (**)(uint64_t, unint64_t))(*(_QWORD *)v1 + 40))(v1, v4);
      }
      if (*(_BYTE *)(v1 + 280))
      {
        v5 = *(_QWORD *)(v1 + 296);
        mach_absolute_time();
        this = __udivti3();
        v6 = v5 - this;
        if (v5 > this)
          this = (*(uint64_t (**)(CADeprecated::CAGuard *, unint64_t))(*(_QWORD *)v2 + 64))(v2, v6);
      }
      else
      {
LABEL_9:
        this = (unint64_t)CADeprecated::CAGuard::Wait(v2);
      }
      if (v3)
        this = (*(uint64_t (**)(CADeprecated::CAGuard *, unint64_t))(*(_QWORD *)v2 + 24))(v2, v6);
    }
    while (!*(_BYTE *)(v1 + 136));
  }
  return this;
}

void sub_1D4EC3894(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  int v2;

  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

CADeprecated::Task *CADeprecated::Task::Task(CADeprecated::Task *this, const char *a2, unsigned int a3, unsigned int a4, BOOL a5, BOOL a6, const char *a7)
{
  CADeprecated::CAPThread *v8;

  *(_QWORD *)this = off_1E98B9DE0;
  v8 = CADeprecated::CAPThread::CAPThread(this, (void *(*)(void *))this, (void *)0x32, a4, a5, a6, a7);
  *((_QWORD *)v8 + 16) = "SysexSender";
  *((_BYTE *)v8 + 136) = 0;
  *(_QWORD *)v8 = off_1E98B9CE8;
  CADeprecated::CAGuard::CAGuard((CADeprecated::CAPThread *)((char *)v8 + 144), "Task");
  *((_BYTE *)this + 280) = 0;
  return this;
}

uint64_t CADeprecated::Task::WakeUpAt(CADeprecated::Task *this, unint64_t a2)
{
  char *v4;
  uint64_t result;
  int v6;

  v4 = (char *)this + 144;
  result = (*(uint64_t (**)(char *))(*((_QWORD *)this + 18) + 16))((char *)this + 144);
  v6 = result;
  if (v4[136] && *((_QWORD *)this + 36) <= a2)
  {
    if ((_DWORD)result)
      return (*(uint64_t (**)(char *))(*(_QWORD *)v4 + 24))(v4);
  }
  else
  {
    *((_BYTE *)this + 280) = 1;
    *((_QWORD *)this + 36) = a2;
    *((_QWORD *)this + 37) = __udivti3() - 20000;
    if (v6)
      (*(void (**)(char *))(*(_QWORD *)v4 + 24))(v4);
    return CADeprecated::CAGuard::Notify((CADeprecated::CAGuard *)v4);
  }
  return result;
}

uint64_t std::__tree<std::__value_type<std::pair<unsigned int,unsigned char>,PropertyExchange::Request>,std::__map_value_compare<std::pair<unsigned int,unsigned char>,std::__value_type<std::pair<unsigned int,unsigned char>,PropertyExchange::Request>,std::less<std::pair<unsigned int,unsigned char>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,unsigned char>,PropertyExchange::Request>>>::find<std::pair<unsigned int,unsigned char>>(uint64_t a1, unsigned int a2, unsigned __int8 a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  BOOL v8;
  char v9;
  unsigned int v10;
  BOOL v11;
  BOOL v12;
  uint64_t *v13;
  unsigned int v14;
  BOOL v15;
  char v16;
  unsigned int v17;
  char v18;

  v5 = *(_QWORD *)(a1 + 8);
  v3 = a1 + 8;
  v4 = v5;
  if (!v5)
    return v3;
  v6 = v3;
  do
  {
    v7 = *(_DWORD *)(v4 + 32);
    v8 = v7 == a2;
    if (v7 >= a2)
      v9 = 1;
    else
      v9 = -1;
    if (v8)
    {
      v10 = *(unsigned __int8 *)(v4 + 36);
      v11 = v10 == a3;
      v9 = v10 >= a3 ? 1 : -1;
      if (v11)
        v9 = 0;
    }
    v12 = (v9 & 0x80) == 0;
    if (v9 < 0)
      v13 = (uint64_t *)(v4 + 8);
    else
      v13 = (uint64_t *)v4;
    if (v12)
      v6 = v4;
    v4 = *v13;
  }
  while (*v13);
  if (v3 == v6)
    return v3;
  v14 = *(_DWORD *)(v6 + 32);
  v15 = v14 == a2;
  if (v14 <= a2)
    v16 = 1;
  else
    v16 = -1;
  if (v15)
  {
    v17 = *(unsigned __int8 *)(v6 + 36);
    v18 = -1;
    if (v17 <= a3)
      v18 = 1;
    if (v17 == a3)
      v16 = 0;
    else
      v16 = v18;
  }
  if (v16 < 0)
    return v3;
  return v6;
}

void std::__tree<std::__value_type<std::pair<unsigned int,unsigned char>,PropertyExchange::Request>,std::__map_value_compare<std::pair<unsigned int,unsigned char>,std::__value_type<std::pair<unsigned int,unsigned char>,PropertyExchange::Request>,std::less<std::pair<unsigned int,unsigned char>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,unsigned char>,PropertyExchange::Request>>>::__erase_unique<std::pair<unsigned int,unsigned char>>(_QWORD *a1, unsigned int a2, unsigned __int8 a3)
{
  uint64_t v4;
  uint64_t *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  BOOL v9;
  uint64_t *v10;

  v4 = std::__tree<std::__value_type<std::pair<unsigned int,unsigned char>,PropertyExchange::Request>,std::__map_value_compare<std::pair<unsigned int,unsigned char>,std::__value_type<std::pair<unsigned int,unsigned char>,PropertyExchange::Request>,std::less<std::pair<unsigned int,unsigned char>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,unsigned char>,PropertyExchange::Request>>>::find<std::pair<unsigned int,unsigned char>>((uint64_t)a1, a2, a3);
  if (a1 + 1 != (_QWORD *)v4)
  {
    v5 = (uint64_t *)v4;
    v6 = *(_QWORD **)(v4 + 8);
    if (v6)
    {
      do
      {
        v7 = v6;
        v6 = (_QWORD *)*v6;
      }
      while (v6);
    }
    else
    {
      v8 = (_QWORD *)v4;
      do
      {
        v7 = (_QWORD *)v8[2];
        v9 = *v7 == (_QWORD)v8;
        v8 = v7;
      }
      while (!v9);
    }
    if (*a1 == v4)
      *a1 = v7;
    v10 = (uint64_t *)a1[1];
    --a1[2];
    std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v10, v5);
    std::__destroy_at[abi:ne180100]<std::pair<std::pair<unsigned int,unsigned char> const,PropertyExchange::Request>,0>(v5 + 4);
    operator delete(v5);
  }
}

_QWORD *nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::parse<char const*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  lconv *v9;
  int v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  _QWORD *result;
  uint64_t v16;
  _BYTE v17[24];
  _BYTE *v18;
  _BYTE v19[24];
  _BYTE *v20;
  int v21;
  _QWORD v22[2];
  int v23;
  char v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  const char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  char v35;
  _QWORD v36[3];
  _QWORD *v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  *(_BYTE *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(a1);
  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(a1);
  std::__function::__value_func<void ()(applesauce::iokit::io_object_holder)>::__value_func[abi:ne180100]((uint64_t)v17, a4);
  std::__function::__value_func<BOOL ()(int,nlohmann::detail::parse_event_t,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> &)>::__value_func[abi:ne180100]((uint64_t)v36, (uint64_t)v17);
  v8 = (uint64_t)v37;
  if (!v37)
    goto LABEL_4;
  if (v37 != v36)
  {
    v8 = (*(uint64_t (**)(_QWORD *))(*v37 + 16))(v37);
LABEL_4:
    v20 = (_BYTE *)v8;
    goto LABEL_6;
  }
  v20 = v19;
  (*(void (**)(_QWORD *, _BYTE *))(v36[0] + 24))(v36, v19);
LABEL_6:
  v21 = 0;
  v22[0] = a2;
  v22[1] = a3;
  v23 = -1;
  v24 = 0;
  v25 = 0u;
  v26 = 0u;
  v27 = 0u;
  v28 = 0u;
  v29 = 0;
  v30 = "";
  v32 = 0;
  v33 = 0;
  v31 = 0;
  v9 = localeconv();
  if (!v9)
    __assert_rtn("get_decimal_point", "lexer.hpp", 136, "loc != nullptr");
  if (v9->decimal_point)
    v10 = *v9->decimal_point;
  else
    v10 = 46;
  v34 = v10;
  v35 = 0;
  v21 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::scan((uint64_t)v22);
  v11 = v37;
  if (v37 == v36)
  {
    v12 = 4;
    v11 = v36;
  }
  else
  {
    if (!v37)
      goto LABEL_15;
    v12 = 5;
  }
  (*(void (**)(void))(*v11 + 8 * v12))();
LABEL_15:
  nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::parse((uint64_t)v19, (unsigned __int8 *)a1);
  nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::~lexer((uint64_t)v22);
  v13 = v20;
  if (v20 == v19)
  {
    v14 = 4;
    v13 = v19;
  }
  else
  {
    if (!v20)
      goto LABEL_20;
    v14 = 5;
  }
  (*(void (**)(void))(*v13 + 8 * v14))();
LABEL_20:
  result = v18;
  if (v18 == v17)
  {
    v16 = 4;
    result = v17;
  }
  else
  {
    if (!v18)
      return result;
    v16 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v16))();
}

void sub_1D4EC3D28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object, char a11, uint64_t a12, uint64_t a13, char *a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  uint64_t **v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;

  v20 = *(_QWORD **)(v19 - 64);
  if (v20 == (_QWORD *)(v19 - 88))
  {
    v21 = 4;
    v20 = (_QWORD *)(v19 - 88);
  }
  else
  {
    if (!v20)
      goto LABEL_6;
    v21 = 5;
  }
  (*(void (**)(void))(*v20 + 8 * v21))();
LABEL_6:
  v22 = a14;
  if (a14 == &a11)
  {
    v23 = 4;
    v22 = &a11;
  }
  else
  {
    if (!a14)
      goto LABEL_11;
    v23 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v22 + 8 * v23))();
LABEL_11:
  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::~basic_json(v18);
  _Unwind_Resume(a1);
}

void sub_1D4EC3DF4(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

uint64_t **nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::~basic_json(uint64_t **a1)
{
  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)a1);
  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(a1 + 1, *(unsigned __int8 *)a1);
  return a1;
}

uint64_t nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(uint64_t result)
{
  const char *v1;
  int v2;

  switch(*(_BYTE *)result)
  {
    case 1:
      if (*(_QWORD *)(result + 8))
        return result;
      v1 = "m_type != value_t::object or m_value.object != nullptr";
      v2 = 1220;
      break;
    case 2:
      if (*(_QWORD *)(result + 8))
        return result;
      v1 = "m_type != value_t::array or m_value.array != nullptr";
      v2 = 1221;
      break;
    case 3:
      if (*(_QWORD *)(result + 8))
        return result;
      v1 = "m_type != value_t::string or m_value.string != nullptr";
      v2 = 1222;
      break;
    case 8:
      if (*(_QWORD *)(result + 8))
        return result;
      v1 = "m_type != value_t::binary or m_value.binary != nullptr";
      v2 = 1223;
      break;
    default:
      return result;
  }
  __assert_rtn("assert_invariant", "json.hpp", v2, v1);
}

void nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(uint64_t **a1, int a2)
{
  int v3;
  uint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  BOOL v9;
  unint64_t i;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned __int8 *v18;
  unsigned int v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t *v22;
  uint64_t *v23;
  uint64_t *v24;
  void *v25;
  void *v26;
  void **v27;
  uint64_t *v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;

  v29 = 0;
  v30 = 0;
  v31 = 0;
  v3 = a2 - 1;
  if (a2 == 1)
  {
    std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::reserve(&v29, (*a1)[2]);
    v4 = (uint64_t)(*a1 + 1);
    v5 = (_QWORD *)**a1;
    if (v5 != (_QWORD *)v4)
    {
      v6 = v30;
      do
      {
        if (v6 >= v31)
        {
          v6 = std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::__push_back_slow_path<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>(&v29, (uint64_t)(v5 + 7));
        }
        else
        {
          *(_BYTE *)v6 = *((_BYTE *)v5 + 56);
          *(_QWORD *)(v6 + 8) = v5[8];
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)(v5 + 7));
          *((_BYTE *)v5 + 56) = 0;
          v5[8] = 0;
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v6);
          v6 += 16;
        }
        v30 = v6;
        v7 = (_QWORD *)v5[1];
        if (v7)
        {
          do
          {
            v8 = v7;
            v7 = (_QWORD *)*v7;
          }
          while (v7);
        }
        else
        {
          do
          {
            v8 = (_QWORD *)v5[2];
            v9 = *v8 == (_QWORD)v5;
            v5 = v8;
          }
          while (!v9);
        }
        v5 = v8;
      }
      while (v8 != (_QWORD *)v4);
    }
  }
  else if (a2 == 2)
  {
    std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::reserve(&v29, ((*a1)[1] - **a1) >> 4);
    std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> *,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> *,std::back_insert_iterator<std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>>(**a1, (*a1)[1], &v29);
  }
  for (i = v30; v29 != v30; i = v30)
  {
    v13 = *(unsigned __int8 *)(i - 16);
    v12 = i - 16;
    v11 = v13;
    LOBYTE(v27) = v13;
    v14 = *(uint64_t **)(v12 + 8);
    v28 = v14;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v12);
    *(_BYTE *)v12 = 0;
    *(_QWORD *)(v12 + 8) = 0;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)&v27);
    std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::__base_destruct_at_end[abi:ne180100]((uint64_t)&v29, v30 - 16);
    if (v13 == 1)
    {
      v20 = *v14;
      if ((uint64_t *)*v14 == v14 + 1)
      {
        v11 = 1;
      }
      else
      {
        v21 = v30;
        do
        {
          if (v21 >= v31)
          {
            v21 = std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::__push_back_slow_path<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>(&v29, v20 + 56);
          }
          else
          {
            *(_BYTE *)v21 = *(_BYTE *)(v20 + 56);
            *(_QWORD *)(v21 + 8) = *(_QWORD *)(v20 + 64);
            nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v20 + 56);
            *(_BYTE *)(v20 + 56) = 0;
            *(_QWORD *)(v20 + 64) = 0;
            nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v21);
            v21 += 16;
          }
          v30 = v21;
          v22 = *(uint64_t **)(v20 + 8);
          if (v22)
          {
            do
            {
              v23 = v22;
              v22 = (uint64_t *)*v22;
            }
            while (v22);
          }
          else
          {
            do
            {
              v23 = *(uint64_t **)(v20 + 16);
              v9 = *v23 == v20;
              v20 = (uint64_t)v23;
            }
            while (!v9);
          }
          v20 = (uint64_t)v23;
        }
        while (v23 != v14 + 1);
        v14 = v28;
        v11 = v27;
      }
      std::__tree<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::__map_value_compare<std::string,std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::less<void>,true>,std::allocator<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>>::destroy((char *)v14[1]);
      *v14 = (uint64_t)(v14 + 1);
      v14[2] = 0;
      v14[1] = 0;
    }
    else if ((_DWORD)v11 == 2)
    {
      std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> *,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> *,std::back_insert_iterator<std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>>(*v14, v14[1], &v29);
      v16 = *v14;
      v15 = v14[1];
      if (v15 != *v14)
      {
        v17 = v15 - 16;
        v18 = (unsigned __int8 *)(v15 - 16);
        do
        {
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v17);
          v19 = *v18;
          v18 -= 16;
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(v17 + 8, v19);
          v9 = v17 == v16;
          v17 = (uint64_t)v18;
        }
        while (!v9);
      }
      v14[1] = v16;
      v11 = 2;
    }
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)&v27);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(&v28, v11);
  }
  switch(v3)
  {
    case 0:
      std::__tree<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::__map_value_compare<std::string,std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::less<void>,true>,std::allocator<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>>::destroy((char *)(*a1)[1]);
      goto LABEL_46;
    case 1:
      v27 = (void **)*a1;
      std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::__destroy_vector::operator()[abi:ne180100](&v27);
      goto LABEL_46;
    case 2:
      v24 = *a1;
      if ((*((char *)*a1 + 23) & 0x80000000) == 0)
        goto LABEL_47;
      v25 = (void *)*v24;
      break;
    case 7:
      v24 = *a1;
      v26 = (void *)**a1;
      if (!v26)
        goto LABEL_47;
      v24[1] = (uint64_t)v26;
      v25 = v26;
      break;
    default:
      goto LABEL_48;
  }
  operator delete(v25);
LABEL_46:
  v24 = *a1;
LABEL_47:
  operator delete(v24);
LABEL_48:
  v27 = (void **)&v29;
  std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::__destroy_vector::operator()[abi:ne180100](&v27);
}

uint64_t *std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::reserve(uint64_t *result, unint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD v5[5];

  if (a2 > (result[2] - *result) >> 4)
  {
    if (a2 >> 60)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v2 = result;
    v3 = result[1] - *result;
    v5[4] = result + 2;
    v5[0] = std::__allocate_at_least[abi:ne180100]<std::allocator<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>(a2);
    v5[1] = v5[0] + v3;
    v5[2] = v5[0] + v3;
    v5[3] = v5[0] + 16 * v4;
    std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::__swap_out_circular_buffer(v2, v5);
    return (uint64_t *)std::__split_buffer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::~__split_buffer((uint64_t)v5);
  }
  return result;
}

uint64_t std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> *,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> *,std::back_insert_iterator<std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>>(uint64_t result, uint64_t a2, uint64_t *a3)
{
  uint64_t v5;
  unint64_t v6;

  if (result != a2)
  {
    v5 = result;
    v6 = a3[1];
    do
    {
      if (v6 >= a3[2])
      {
        result = std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::__push_back_slow_path<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>(a3, v5);
        v6 = result;
      }
      else
      {
        *(_BYTE *)v6 = *(_BYTE *)v5;
        *(_QWORD *)(v6 + 8) = *(_QWORD *)(v5 + 8);
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v5);
        *(_BYTE *)v5 = 0;
        *(_QWORD *)(v5 + 8) = 0;
        result = nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v6);
        v6 += 16;
      }
      a3[1] = v6;
      v5 += 16;
    }
    while (v5 != a2);
  }
  return result;
}

uint64_t std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::__push_back_slow_path<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t *v6;
  uint64_t v7;
  unint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD v14[5];

  v2 = (a1[1] - *a1) >> 4;
  v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 60)
    std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
  v6 = a1 + 2;
  v7 = a1[2] - *a1;
  if (v7 >> 3 > v3)
    v3 = v7 >> 3;
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF0)
    v8 = 0xFFFFFFFFFFFFFFFLL;
  else
    v8 = v3;
  v14[4] = v6;
  v9 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>(v8);
  v10 = (uint64_t)&v9[16 * v2];
  v14[0] = v9;
  v14[1] = v10;
  v14[3] = &v9[16 * v11];
  *(_BYTE *)v10 = *(_BYTE *)a2;
  *(_QWORD *)(v10 + 8) = *(_QWORD *)(a2 + 8);
  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(a2);
  *(_BYTE *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v10);
  v14[2] = v10 + 16;
  std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::__swap_out_circular_buffer(a1, v14);
  v12 = a1[1];
  std::__split_buffer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::~__split_buffer((uint64_t)v14);
  return v12;
}

uint64_t std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::__base_destruct_at_end[abi:ne180100](uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned __int8 *v6;
  unsigned int v7;
  BOOL v8;

  v3 = result;
  v4 = *(_QWORD *)(result + 8);
  if (v4 != a2)
  {
    v5 = v4 - 16;
    v6 = (unsigned __int8 *)(v4 - 16);
    do
    {
      nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v5);
      v7 = *v6;
      v6 -= 16;
      result = nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(v5 + 8, v7);
      v8 = v5 == a2;
      v5 = (uint64_t)v6;
    }
    while (!v8);
  }
  *(_QWORD *)(v3 + 8) = a2;
  return result;
}

void std::__tree<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::__map_value_compare<std::string,std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::less<void>,true>,std::allocator<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>>::destroy(char *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::__map_value_compare<std::string,std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::less<void>,true>,std::allocator<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>>::destroy(*(_QWORD *)a1);
    std::__tree<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::__map_value_compare<std::string,std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::less<void>,true>,std::allocator<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>>::destroy(*((_QWORD *)a1 + 1));
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)(a1 + 56));
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(a1 + 64, a1[56]);
    if (a1[55] < 0)
      operator delete(*((void **)a1 + 4));
    operator delete(a1);
  }
}

void std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  uint64_t v6;
  char *v7;
  unsigned int v8;
  BOOL v9;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      v6 = (uint64_t)(v4 - 16);
      v7 = v4 - 16;
      do
      {
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v6);
        v8 = *v7;
        v7 -= 16;
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(v6 + 8, v8);
        v9 = v6 == (_QWORD)v2;
        v6 = (uint64_t)v7;
      }
      while (!v9);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>(unint64_t a1)
{
  if (a1 >> 60)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(16 * a1);
}

uint64_t *std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::__swap_out_circular_buffer(uint64_t *result, _QWORD *a2)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = result;
  v5 = *result;
  v4 = result[1];
  v6 = a2[1];
  if (v4 != *result)
  {
    v7 = 0;
    do
    {
      *(_BYTE *)(v6 + v7 - 16) = *(_BYTE *)(v4 + v7 - 16);
      *(_QWORD *)(v6 + v7 - 8) = *(_QWORD *)(v4 + v7 - 8);
      nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v4 + v7 - 16);
      *(_BYTE *)(v4 + v7 - 16) = 0;
      *(_QWORD *)(v4 + v7 - 8) = 0;
      result = (uint64_t *)nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v6 + v7 - 16);
      v7 -= 16;
    }
    while (v4 + v7 != v5);
    v6 += v7;
  }
  a2[1] = v6;
  v8 = *v3;
  *v3 = v6;
  a2[1] = v8;
  v9 = v3[1];
  v3[1] = a2[2];
  a2[2] = v9;
  v10 = v3[2];
  v3[2] = a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t i;

  v2 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v2; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 16;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(i - 16);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(i - 8, *(unsigned __int8 *)(i - 16));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void nlohmann::detail::type_error::create(nlohmann::detail::exception *a1, int a2, uint64_t a3)
{
  int v6;
  const std::string::value_type *v7;
  std::string::size_type v8;
  std::string *v9;
  __int128 v10;
  void **v11;
  void *__p[2];
  char v13;
  std::string v14;
  void *v15[2];
  int64_t v16;

  std::string::basic_string[abi:ne180100]<0>(__p, "type_error");
  nlohmann::detail::exception::name(&v14, (uint64_t)__p, a2);
  v6 = *(char *)(a3 + 23);
  if (v6 >= 0)
    v7 = (const std::string::value_type *)a3;
  else
    v7 = *(const std::string::value_type **)a3;
  if (v6 >= 0)
    v8 = *(unsigned __int8 *)(a3 + 23);
  else
    v8 = *(_QWORD *)(a3 + 8);
  v9 = std::string::append(&v14, v7, v8);
  v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
  v16 = v9->__r_.__value_.__r.__words[2];
  *(_OWORD *)v15 = v10;
  v9->__r_.__value_.__l.__size_ = 0;
  v9->__r_.__value_.__r.__words[2] = 0;
  v9->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v14.__r_.__value_.__l.__data_);
  if (v13 < 0)
    operator delete(__p[0]);
  if (v16 >= 0)
    v11 = v15;
  else
    v11 = (void **)v15[0];
  nlohmann::detail::exception::exception(a1, a2, (const char *)v11);
  *(_QWORD *)a1 = &off_1E98B6F18;
  if (SHIBYTE(v16) < 0)
    operator delete(v15[0]);
}

void sub_1D4EC47AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void nlohmann::detail::type_error::~type_error(std::runtime_error *this)
{
  this->__vftable = (std::runtime_error_vtbl *)&off_1E98B6FE0;
  std::runtime_error::~runtime_error(this + 1);
  std::exception::~exception(this);
}

{
  this->__vftable = (std::runtime_error_vtbl *)&off_1E98B6FE0;
  std::runtime_error::~runtime_error(this + 1);
  std::exception::~exception(this);
  JUMPOUT(0x1D826BA98);
}

void nlohmann::detail::exception::~exception(std::runtime_error *this)
{
  this->__vftable = (std::runtime_error_vtbl *)&off_1E98B6FE0;
  std::runtime_error::~runtime_error(this + 1);
  std::exception::~exception(this);
}

{
  this->__vftable = (std::runtime_error_vtbl *)&off_1E98B6FE0;
  std::runtime_error::~runtime_error(this + 1);
  std::exception::~exception(this);
  JUMPOUT(0x1D826BA98);
}

const char *nlohmann::detail::exception::what(const std::runtime_error *this)
{
  return std::runtime_error::what(this + 1);
}

void nlohmann::detail::exception::name(std::string *a1, uint64_t a2, int a3)
{
  std::string *v5;
  __int128 v6;
  std::string *p_p;
  std::string::size_type size;
  std::string *v9;
  __int128 v10;
  std::string *v11;
  std::string __p;
  std::string v13;
  std::string v14;
  std::string v15;

  std::operator+<char>();
  v5 = std::string::append(&v13, ".", 1uLL);
  v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
  v14.__r_.__value_.__r.__words[2] = v5->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v14.__r_.__value_.__l.__data_ = v6;
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&__p, a3);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    size = __p.__r_.__value_.__l.__size_;
  v9 = std::string::append(&v14, (const std::string::value_type *)p_p, size);
  v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
  v15.__r_.__value_.__r.__words[2] = v9->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v15.__r_.__value_.__l.__data_ = v10;
  v9->__r_.__value_.__l.__size_ = 0;
  v9->__r_.__value_.__r.__words[2] = 0;
  v9->__r_.__value_.__r.__words[0] = 0;
  v11 = std::string::append(&v15, "] ", 2uLL);
  *a1 = *v11;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v15.__r_.__value_.__l.__data_);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v14.__r_.__value_.__l.__data_);
  if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v13.__r_.__value_.__l.__data_);
}

void sub_1D4EC49C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (*(char *)(v26 - 41) < 0)
    operator delete(*(void **)(v26 - 64));
  if (a14 < 0)
    operator delete(__p);
  if (a26 < 0)
    operator delete(a21);
  if (a20 < 0)
    operator delete(a15);
  _Unwind_Resume(exception_object);
}

nlohmann::detail::exception *nlohmann::detail::exception::exception(nlohmann::detail::exception *this, int a2, const char *a3)
{
  *(_QWORD *)this = &off_1E98B6FE0;
  *((_DWORD *)this + 2) = a2;
  MEMORY[0x1D826B7EC]((char *)this + 16, a3);
  return this;
}

void sub_1D4EC4A60(_Unwind_Exception *a1)
{
  std::exception *v1;

  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__tree<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::__map_value_compare<std::string,std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::less<void>,true>,std::allocator<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>>::find<char const*>(uint64_t a1, char *__s)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  char v6;
  uint64_t *v7;

  v2 = a1 + 8;
  v3 = *(_QWORD *)(a1 + 8);
  if (!v3)
    return v2;
  v5 = a1 + 8;
  do
  {
    v6 = std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((const void **)(v3 + 32), __s);
    if (v6 >= 0)
      v7 = (uint64_t *)v3;
    else
      v7 = (uint64_t *)(v3 + 8);
    if (v6 >= 0)
      v5 = v3;
    v3 = *v7;
  }
  while (*v7);
  if (v5 == v2
    || (int)(std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((const void **)(v5 + 32), __s) << 24) >= 1)
  {
    return v2;
  }
  return v5;
}

uint64_t std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(const void **a1, char *__s)
{
  int v3;
  const void *v4;
  size_t v5;
  size_t v6;

  v3 = *((char *)a1 + 23);
  if (v3 >= 0)
    v4 = a1;
  else
    v4 = *a1;
  if (v3 >= 0)
    v5 = *((unsigned __int8 *)a1 + 23);
  else
    v5 = (size_t)a1[1];
  v6 = strlen(__s);
  return std::operator<=>[abi:ne180100]<char,std::char_traits<char>>(v4, v5, __s, v6);
}

void nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::parse(uint64_t a1, unsigned __int8 *a2)
{
  _QWORD *v4;
  uint64_t v5;
  char v6;
  int v7;
  int v8;
  std::string::size_type size;
  std::string::size_type v10;
  uint64_t v11;
  std::string::size_type v12;
  int v13;
  int v14;
  int v15;
  int v16;
  uint64_t **v17;
  int v18;
  uint64_t **v19;
  int v20;
  unsigned __int8 v21;
  int v22;
  int v23;
  std::string::size_type v24;
  std::string::size_type v25;
  std::string::size_type v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  uint64_t *v35;
  int v36;
  uint64_t **v37;
  int v38;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  char v42[8];
  uint64_t *v43;
  _BYTE v44[8];
  uint64_t v45;
  char v46[8];
  uint64_t v47;
  std::string v48;
  std::string v49;
  std::string v50;
  std::exception v51;
  std::runtime_error v52;
  std::string v53;
  std::string __p;
  _BYTE v55[24];
  _BYTE *v56;
  unsigned __int8 *v57;
  __int128 v58;
  __int128 v59;
  char v60;
  char v61;
  char v62;
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)(a1 + 24))
  {
    v6 = *(_BYTE *)(a1 + 176);
    v57 = a2;
    v58 = 0u;
    v59 = 0u;
    v60 = 0;
    v61 = v6;
    memset(&__p, 0, sizeof(__p));
    while (1)
    {
      switch(*(_DWORD *)(a1 + 32))
      {
        case 1:
          LOBYTE(v51.__vftable) = 1;
          nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<BOOL &>(&v57, (unsigned __int8 *)&v51);
          goto LABEL_19;
        case 2:
          LOBYTE(v51.__vftable) = 0;
          nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<BOOL &>(&v57, (unsigned __int8 *)&v51);
          goto LABEL_19;
        case 3:
          nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<decltype(nullptr)>(&v57);
          goto LABEL_19;
        case 4:
          nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<std::string&>((uint64_t *)&v57, a1 + 112);
          goto LABEL_19;
        case 5:
          v51.__vftable = *(std::exception_vtbl **)(a1 + 152);
          nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<unsigned long long &>(&v57, (uint64_t *)&v51);
          goto LABEL_19;
        case 6:
          v51.__vftable = *(std::exception_vtbl **)(a1 + 144);
          nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<long long &>(&v57, (uint64_t *)&v51);
          goto LABEL_19;
        case 7:
          if ((*(_QWORD *)(a1 + 160) & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
          {
            nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get_token_string(&v53, *(unsigned __int8 **)(a1 + 88), *(unsigned __int8 **)(a1 + 96));
            nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get_token_string(&v48, *(unsigned __int8 **)(a1 + 88), *(unsigned __int8 **)(a1 + 96));
            std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&v49, "number overflow parsing '", &v48);
            std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&v50, &v49, "'");
            nlohmann::detail::out_of_range::create((nlohmann::detail::exception *)&v51, (uint64_t)&v50);
            nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error((uint64_t)&v57, (const nlohmann::detail::type_error *)&v51);
            v51.__vftable = (std::exception_vtbl *)&off_1E98B6FE0;
            std::runtime_error::~runtime_error(&v52);
            std::exception::~exception(&v51);
            if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v50.__r_.__value_.__l.__data_);
            goto LABEL_114;
          }
          v51.__vftable = *(std::exception_vtbl **)(a1 + 160);
          nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<double &>(&v57, (uint64_t *)&v51);
          goto LABEL_19;
        case 8:
          nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::start_array((uint64_t *)&v57);
          v7 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::scan(a1 + 40);
          *(_DWORD *)(a1 + 32) = v7;
          if (v7 == 10)
            goto LABEL_14;
          LOBYTE(v51.__vftable) = 1;
          std::vector<BOOL>::push_back((uint64_t)&__p, &v51);
          continue;
        case 9:
          nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::start_object((uint64_t *)&v57);
          v8 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::scan(a1 + 40);
          *(_DWORD *)(a1 + 32) = v8;
          if (v8 == 11)
          {
LABEL_14:
            *((_QWORD *)&v58 + 1) -= 8;
LABEL_19:
            size = __p.__r_.__value_.__l.__size_;
            if (!__p.__r_.__value_.__l.__size_)
            {
LABEL_73:
              if (__p.__r_.__value_.__r.__words[0])
                operator delete(__p.__r_.__value_.__l.__data_);
              nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)a2);
              v33 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::scan(a1 + 40);
              *(_DWORD *)(a1 + 32) = v33;
              if (v33 != 15)
              {
                nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get_token_string(&__p, *(unsigned __int8 **)(a1 + 88), *(unsigned __int8 **)(a1 + 96));
                v53 = *(std::string *)(a1 + 64);
                std::string::basic_string[abi:ne180100]<0>(&v49, "value");
                nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::exception_message(&v50, a1, 0xFu, (uint64_t)&v49);
                nlohmann::detail::parse_error::create((nlohmann::detail::exception *)&v51, (uint64_t *)&v53, (uint64_t)&v50);
                nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error((uint64_t)&v57, (const nlohmann::detail::type_error *)&v51);
                v51.__vftable = (std::exception_vtbl *)&off_1E98B6FE0;
                std::runtime_error::~runtime_error(&v52);
                std::exception::~exception(&v51);
                if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(v50.__r_.__value_.__l.__data_);
                if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(v49.__r_.__value_.__l.__data_);
                if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(__p.__r_.__value_.__l.__data_);
              }
              if (v60)
              {
                v42[0] = 9;
                v43 = 0;
                nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v42);
                nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v42);
                v34 = *a2;
                *a2 = 9;
                v42[0] = v34;
                v35 = (uint64_t *)*((_QWORD *)a2 + 1);
                *((_QWORD *)a2 + 1) = 0;
                v43 = v35;
                nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)a2);
                nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v42);
                nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(&v43, v34);
              }
              if ((_QWORD)v58)
                operator delete((void *)v58);
              return;
            }
            v10 = __p.__r_.__value_.__r.__words[0];
            v11 = *((_QWORD *)&v58 + 1);
            while (1)
            {
              v12 = size - 1;
              if (((*(_QWORD *)(v10 + (((size - 1) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (size - 1)) & 1) != 0)
              {
                v13 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::scan(a1 + 40);
                *(_DWORD *)(a1 + 32) = v13;
                if (v13 == 13)
                {
                  *((_QWORD *)&v58 + 1) = v11;
                  __p.__r_.__value_.__l.__size_ = size;
                  v15 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::scan(a1 + 40);
                  goto LABEL_33;
                }
                if (v13 != 10)
                {
                  *((_QWORD *)&v58 + 1) = v11;
                  __p.__r_.__value_.__l.__size_ = size;
                  nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get_token_string(&v53, *(unsigned __int8 **)(a1 + 88), *(unsigned __int8 **)(a1 + 96));
                  v50 = *(std::string *)(a1 + 64);
                  std::string::basic_string[abi:ne180100]<0>(&v48, "array");
                  nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::exception_message(&v49, a1, 0xAu, (uint64_t)&v48);
                  nlohmann::detail::parse_error::create((nlohmann::detail::exception *)&v51, (uint64_t *)&v50, (uint64_t)&v49);
                  nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error((uint64_t)&v57, (const nlohmann::detail::type_error *)&v51);
                  goto LABEL_113;
                }
              }
              else
              {
                v14 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::scan(a1 + 40);
                *(_DWORD *)(a1 + 32) = v14;
                if (v14 == 13)
                {
                  *((_QWORD *)&v58 + 1) = v11;
                  __p.__r_.__value_.__l.__size_ = size;
                  v16 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::scan(a1 + 40);
                  *(_DWORD *)(a1 + 32) = v16;
                  if (v16 == 4)
                  {
                    v17 = *(uint64_t ***)(*(_QWORD *)(v11 - 8) + 8);
                    v51.__vftable = (std::exception_vtbl *)(a1 + 112);
                    *((_QWORD *)&v59 + 1) = std::__tree<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::__map_value_compare<std::string,std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::less<void>,true>,std::allocator<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v17, (void **)(a1 + 112), (__int128 **)&v51)+ 56;
                    v18 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::scan(a1 + 40);
                    *(_DWORD *)(a1 + 32) = v18;
                    if (v18 == 12)
                    {
                      v15 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::scan(a1 + 40);
                      goto LABEL_33;
                    }
LABEL_126:
                    nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get_token_string(&v53, *(unsigned __int8 **)(a1 + 88), *(unsigned __int8 **)(a1 + 96));
                    v50 = *(std::string *)(a1 + 64);
                    std::string::basic_string[abi:ne180100]<0>(&v48, "object separator");
                    nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::exception_message(&v49, a1, 0xCu, (uint64_t)&v48);
                    nlohmann::detail::parse_error::create((nlohmann::detail::exception *)&v51, (uint64_t *)&v50, (uint64_t)&v49);
                    nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error((uint64_t)&v57, (const nlohmann::detail::type_error *)&v51);
LABEL_113:
                    v51.__vftable = (std::exception_vtbl *)&off_1E98B6FE0;
                    std::runtime_error::~runtime_error(&v52);
                    std::exception::~exception(&v51);
LABEL_114:
                    if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(v49.__r_.__value_.__l.__data_);
                    if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(v48.__r_.__value_.__l.__data_);
                    if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(v53.__r_.__value_.__l.__data_);
                    goto LABEL_73;
                  }
LABEL_125:
                  nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get_token_string(&v53, *(unsigned __int8 **)(a1 + 88), *(unsigned __int8 **)(a1 + 96));
                  v50 = *(std::string *)(a1 + 64);
                  std::string::basic_string[abi:ne180100]<0>(&v48, "object key");
                  nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::exception_message(&v49, a1, 4u, (uint64_t)&v48);
                  nlohmann::detail::parse_error::create((nlohmann::detail::exception *)&v51, (uint64_t *)&v50, (uint64_t)&v49);
                  nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error((uint64_t)&v57, (const nlohmann::detail::type_error *)&v51);
                  goto LABEL_113;
                }
                if (v14 != 11)
                {
                  *((_QWORD *)&v58 + 1) = v11;
                  __p.__r_.__value_.__l.__size_ = size;
                  nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get_token_string(&v53, *(unsigned __int8 **)(a1 + 88), *(unsigned __int8 **)(a1 + 96));
                  v50 = *(std::string *)(a1 + 64);
                  std::string::basic_string[abi:ne180100]<0>(&v48, "object");
                  nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::exception_message(&v49, a1, 0xBu, (uint64_t)&v48);
                  nlohmann::detail::parse_error::create((nlohmann::detail::exception *)&v51, (uint64_t *)&v50, (uint64_t)&v49);
                  nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error((uint64_t)&v57, (const nlohmann::detail::type_error *)&v51);
                  goto LABEL_113;
                }
              }
              v11 -= 8;
              --size;
              if (!v12)
              {
                *((_QWORD *)&v58 + 1) = v11;
                goto LABEL_73;
              }
            }
          }
          if (v8 != 4)
            goto LABEL_125;
          v19 = *(uint64_t ***)(*(_QWORD *)(*((_QWORD *)&v58 + 1) - 8) + 8);
          v51.__vftable = (std::exception_vtbl *)(a1 + 112);
          *((_QWORD *)&v59 + 1) = std::__tree<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::__map_value_compare<std::string,std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::less<void>,true>,std::allocator<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v19, (void **)(a1 + 112), (__int128 **)&v51)+ 56;
          v20 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::scan(a1 + 40);
          *(_DWORD *)(a1 + 32) = v20;
          if (v20 != 12)
            goto LABEL_126;
          LOBYTE(v51.__vftable) = 0;
          std::vector<BOOL>::push_back((uint64_t)&__p, &v51);
          v15 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::scan(a1 + 40);
LABEL_33:
          *(_DWORD *)(a1 + 32) = v15;
          break;
        case 0xE:
          nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get_token_string(&v53, *(unsigned __int8 **)(a1 + 88), *(unsigned __int8 **)(a1 + 96));
          v50 = *(std::string *)(a1 + 64);
          std::string::basic_string[abi:ne180100]<0>(&v48, "value");
          nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::exception_message(&v49, a1, 0, (uint64_t)&v48);
          nlohmann::detail::parse_error::create((nlohmann::detail::exception *)&v51, (uint64_t *)&v50, (uint64_t)&v49);
          nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error((uint64_t)&v57, (const nlohmann::detail::type_error *)&v51);
          goto LABEL_113;
        default:
          nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get_token_string(&v53, *(unsigned __int8 **)(a1 + 88), *(unsigned __int8 **)(a1 + 96));
          v50 = *(std::string *)(a1 + 64);
          std::string::basic_string[abi:ne180100]<0>(&v48, "value");
          nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::exception_message(&v49, a1, 0x10u, (uint64_t)&v48);
          nlohmann::detail::parse_error::create((nlohmann::detail::exception *)&v51, (uint64_t *)&v50, (uint64_t)&v49);
          nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error((uint64_t)&v57, (const nlohmann::detail::type_error *)&v51);
          goto LABEL_113;
      }
    }
  }
  std::__function::__value_func<void ()(applesauce::iokit::io_object_holder)>::__value_func[abi:ne180100]((uint64_t)v55, a1);
  nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::json_sax_dom_callback_parser((uint64_t)&v57, (uint64_t)a2, (uint64_t)v55, *(_BYTE *)(a1 + 176));
  v4 = v56;
  if (v56 == v55)
  {
    v5 = 4;
    v4 = v55;
    goto LABEL_38;
  }
  if (v56)
  {
    v5 = 5;
LABEL_38:
    (*(void (**)(void))(*v4 + 8 * v5))();
  }
  memset(&__p, 0, sizeof(__p));
  while (2)
  {
    v21 = 0;
    switch(*(_DWORD *)(a1 + 32))
    {
      case 1:
        v21 = 1;
        goto LABEL_42;
      case 2:
LABEL_42:
        nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<BOOL &>(&v57, v21);
        goto LABEL_53;
      case 3:
        nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<decltype(nullptr)>(&v57);
        goto LABEL_53;
      case 4:
        nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<std::string&>(&v57, a1 + 112);
        goto LABEL_53;
      case 5:
        nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<unsigned long long &>(&v57, *(uint64_t **)(a1 + 152));
        goto LABEL_53;
      case 6:
        nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<long long &>(&v57, *(uint64_t **)(a1 + 144));
        goto LABEL_53;
      case 7:
        if ((*(_QWORD *)(a1 + 160) & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000)
        {
          nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<double &>(&v57, *(double *)(a1 + 160));
          goto LABEL_53;
        }
        nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get_token_string(&v53, *(unsigned __int8 **)(a1 + 88), *(unsigned __int8 **)(a1 + 96));
        nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get_token_string(&v48, *(unsigned __int8 **)(a1 + 88), *(unsigned __int8 **)(a1 + 96));
        std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&v49, "number overflow parsing '", &v48);
        std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&v50, &v49, "'");
        nlohmann::detail::out_of_range::create((nlohmann::detail::exception *)&v51, (uint64_t)&v50);
        nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error((uint64_t)&v57, (const nlohmann::detail::type_error *)&v51);
        v51.__vftable = (std::exception_vtbl *)&off_1E98B6FE0;
        std::runtime_error::~runtime_error(&v52);
        std::exception::~exception(&v51);
        if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v50.__r_.__value_.__l.__data_);
        goto LABEL_89;
      case 8:
        nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::start_array((uint64_t *)&v57);
        v22 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::scan(a1 + 40);
        *(_DWORD *)(a1 + 32) = v22;
        if (v22 == 10)
        {
          nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::end_array(&v57);
          goto LABEL_53;
        }
        LOBYTE(v51.__vftable) = 1;
        std::vector<BOOL>::push_back((uint64_t)&__p, &v51);
        continue;
      case 9:
        nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::start_object((uint64_t *)&v57);
        v23 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::scan(a1 + 40);
        *(_DWORD *)(a1 + 32) = v23;
        if (v23 != 11)
        {
          if (v23 != 4)
            goto LABEL_122;
          nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::key(&v57, (__int128 *)(a1 + 112));
          v32 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::scan(a1 + 40);
          *(_DWORD *)(a1 + 32) = v32;
          if (v32 != 12)
            goto LABEL_123;
          LOBYTE(v51.__vftable) = 0;
          std::vector<BOOL>::push_back((uint64_t)&__p, &v51);
          v29 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::scan(a1 + 40);
LABEL_68:
          *(_DWORD *)(a1 + 32) = v29;
          continue;
        }
        nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::end_object(&v57);
LABEL_53:
        v24 = __p.__r_.__value_.__l.__size_;
        if (!__p.__r_.__value_.__l.__size_)
          goto LABEL_95;
        v25 = __p.__r_.__value_.__r.__words[0];
        while (2)
        {
          v26 = v24 - 1;
          if (((*(_QWORD *)(v25 + (((v24 - 1) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v24 - 1)) & 1) != 0)
          {
            v27 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::scan(a1 + 40);
            *(_DWORD *)(a1 + 32) = v27;
            if (v27 == 13)
            {
              __p.__r_.__value_.__l.__size_ = v24;
              v29 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::scan(a1 + 40);
              goto LABEL_68;
            }
            if (v27 != 10)
            {
              __p.__r_.__value_.__l.__size_ = v24;
              nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get_token_string(&v53, *(unsigned __int8 **)(a1 + 88), *(unsigned __int8 **)(a1 + 96));
              v50 = *(std::string *)(a1 + 64);
              std::string::basic_string[abi:ne180100]<0>(&v48, "array");
              nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::exception_message(&v49, a1, 0xAu, (uint64_t)&v48);
              nlohmann::detail::parse_error::create((nlohmann::detail::exception *)&v51, (uint64_t *)&v50, (uint64_t)&v49);
              nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error((uint64_t)&v57, (const nlohmann::detail::type_error *)&v51);
              goto LABEL_88;
            }
            nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::end_array(&v57);
            goto LABEL_62;
          }
          v28 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::scan(a1 + 40);
          *(_DWORD *)(a1 + 32) = v28;
          if (v28 != 13)
          {
            if (v28 != 11)
            {
              __p.__r_.__value_.__l.__size_ = v24;
              nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get_token_string(&v53, *(unsigned __int8 **)(a1 + 88), *(unsigned __int8 **)(a1 + 96));
              v50 = *(std::string *)(a1 + 64);
              std::string::basic_string[abi:ne180100]<0>(&v48, "object");
              nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::exception_message(&v49, a1, 0xBu, (uint64_t)&v48);
              nlohmann::detail::parse_error::create((nlohmann::detail::exception *)&v51, (uint64_t *)&v50, (uint64_t)&v49);
              nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error((uint64_t)&v57, (const nlohmann::detail::type_error *)&v51);
              goto LABEL_88;
            }
            nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::end_object(&v57);
LABEL_62:
            --v24;
            if (!v26)
              goto LABEL_95;
            continue;
          }
          break;
        }
        __p.__r_.__value_.__l.__size_ = v24;
        v30 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::scan(a1 + 40);
        *(_DWORD *)(a1 + 32) = v30;
        if (v30 != 4)
        {
LABEL_122:
          nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get_token_string(&v53, *(unsigned __int8 **)(a1 + 88), *(unsigned __int8 **)(a1 + 96));
          v50 = *(std::string *)(a1 + 64);
          std::string::basic_string[abi:ne180100]<0>(&v48, "object key");
          nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::exception_message(&v49, a1, 4u, (uint64_t)&v48);
          nlohmann::detail::parse_error::create((nlohmann::detail::exception *)&v51, (uint64_t *)&v50, (uint64_t)&v49);
          nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error((uint64_t)&v57, (const nlohmann::detail::type_error *)&v51);
          goto LABEL_88;
        }
        nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::key(&v57, (__int128 *)(a1 + 112));
        v31 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::scan(a1 + 40);
        *(_DWORD *)(a1 + 32) = v31;
        if (v31 == 12)
        {
          v29 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::scan(a1 + 40);
          goto LABEL_68;
        }
LABEL_123:
        nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get_token_string(&v53, *(unsigned __int8 **)(a1 + 88), *(unsigned __int8 **)(a1 + 96));
        v50 = *(std::string *)(a1 + 64);
        std::string::basic_string[abi:ne180100]<0>(&v48, "object separator");
        nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::exception_message(&v49, a1, 0xCu, (uint64_t)&v48);
        nlohmann::detail::parse_error::create((nlohmann::detail::exception *)&v51, (uint64_t *)&v50, (uint64_t)&v49);
        nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error((uint64_t)&v57, (const nlohmann::detail::type_error *)&v51);
LABEL_88:
        v51.__vftable = (std::exception_vtbl *)&off_1E98B6FE0;
        std::runtime_error::~runtime_error(&v52);
        std::exception::~exception(&v51);
LABEL_89:
        if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v49.__r_.__value_.__l.__data_);
        if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v48.__r_.__value_.__l.__data_);
        if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v53.__r_.__value_.__l.__data_);
LABEL_95:
        if (__p.__r_.__value_.__r.__words[0])
          operator delete(__p.__r_.__value_.__l.__data_);
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)a2);
        v36 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::scan(a1 + 40);
        *(_DWORD *)(a1 + 32) = v36;
        if (v36 != 15)
        {
          nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get_token_string(&__p, *(unsigned __int8 **)(a1 + 88), *(unsigned __int8 **)(a1 + 96));
          v53 = *(std::string *)(a1 + 64);
          std::string::basic_string[abi:ne180100]<0>(&v49, "value");
          nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::exception_message(&v50, a1, 0xFu, (uint64_t)&v49);
          nlohmann::detail::parse_error::create((nlohmann::detail::exception *)&v51, (uint64_t *)&v53, (uint64_t)&v50);
          nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error((uint64_t)&v57, (const nlohmann::detail::type_error *)&v51);
          v51.__vftable = (std::exception_vtbl *)&off_1E98B6FE0;
          std::runtime_error::~runtime_error(&v52);
          std::exception::~exception(&v51);
          if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v50.__r_.__value_.__l.__data_);
          if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v49.__r_.__value_.__l.__data_);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
            operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (v62)
        {
          v46[0] = 9;
          v37 = (uint64_t **)&v47;
          v47 = 0;
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v46);
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v46);
          v38 = *a2;
          *a2 = 9;
          v46[0] = v38;
          v39 = *((_QWORD *)a2 + 1);
          *((_QWORD *)a2 + 1) = 0;
          v47 = v39;
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)a2);
          v40 = v46;
          goto LABEL_108;
        }
        if (*a2 == 9)
        {
          v44[0] = 0;
          v37 = (uint64_t **)&v45;
          v45 = 0;
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v44);
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v44);
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v44);
          v38 = *a2;
          *a2 = 0;
          v44[0] = v38;
          v41 = *((_QWORD *)a2 + 1);
          *((_QWORD *)a2 + 1) = 0;
          v45 = v41;
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)a2);
          v40 = v44;
LABEL_108:
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v40);
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(v37, v38);
        }
        nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::~json_sax_dom_callback_parser((uint64_t)&v57);
        return;
      case 0xE:
        nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get_token_string(&v53, *(unsigned __int8 **)(a1 + 88), *(unsigned __int8 **)(a1 + 96));
        v50 = *(std::string *)(a1 + 64);
        std::string::basic_string[abi:ne180100]<0>(&v48, "value");
        nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::exception_message(&v49, a1, 0, (uint64_t)&v48);
        nlohmann::detail::parse_error::create((nlohmann::detail::exception *)&v51, (uint64_t *)&v50, (uint64_t)&v49);
        nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error((uint64_t)&v57, (const nlohmann::detail::type_error *)&v51);
        goto LABEL_88;
      default:
        nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get_token_string(&v53, *(unsigned __int8 **)(a1 + 88), *(unsigned __int8 **)(a1 + 96));
        v50 = *(std::string *)(a1 + 64);
        std::string::basic_string[abi:ne180100]<0>(&v48, "value");
        nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::exception_message(&v49, a1, 0x10u, (uint64_t)&v48);
        nlohmann::detail::parse_error::create((nlohmann::detail::exception *)&v51, (uint64_t *)&v50, (uint64_t)&v49);
        nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error((uint64_t)&v57, (const nlohmann::detail::type_error *)&v51);
        goto LABEL_88;
    }
  }
}

void sub_1D4EC5C00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,std::exception a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,char a50,uint64_t a51,uint64_t a52,uint64_t a53,char a54,void *a55)
{
  std::runtime_error *v55;

  a33.__vftable = (std::exception_vtbl *)&off_1E98B6FE0;
  std::runtime_error::~runtime_error(v55 + 1);
  std::exception::~exception(&a33);
  if (a26 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a43 < 0)
    operator delete(a38);
  if (a44)
    operator delete(a44);
  if (a55)
    operator delete(a55);
  _Unwind_Resume(a1);
}

uint64_t nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::~lexer(uint64_t a1)
{
  void *v2;

  if (*(char *)(a1 + 95) < 0)
    operator delete(*(void **)(a1 + 72));
  v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(_QWORD *)(a1 + 56) = v2;
    operator delete(v2);
  }
  return a1;
}

_QWORD *nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::~parser(_QWORD *a1)
{
  _QWORD *v2;
  uint64_t v3;

  nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::~lexer((uint64_t)(a1 + 5));
  v2 = (_QWORD *)a1[3];
  if (v2 == a1)
  {
    v3 = 4;
    v2 = a1;
    goto LABEL_5;
  }
  if (v2)
  {
    v3 = 5;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }
  return a1;
}

uint64_t nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::json_sax_dom_callback_parser(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v6;
  char v8;

  *(_QWORD *)a1 = a2;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  v6 = a1 + 32;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_BYTE *)(a1 + 88) = 0;
  std::__function::__value_func<void ()(applesauce::iokit::io_object_holder)>::__value_func[abi:ne180100](a1 + 96, a3);
  *(_BYTE *)(a1 + 136) = 9;
  *(_BYTE *)(a1 + 128) = a4;
  *(_QWORD *)(a1 + 144) = 0;
  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(a1 + 136);
  v8 = 1;
  std::vector<BOOL>::push_back(v6, &v8);
  return a1;
}

void sub_1D4EC614C(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  _QWORD *v3;
  uint64_t **v4;
  void **v5;
  _QWORD *v6;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  void *v11;
  void *v12;

  v6 = v3;
  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::~basic_json(v4);
  v8 = (_QWORD *)v1[15];
  if (v8 == v6)
  {
    v9 = v6;
    v10 = 4;
  }
  else
  {
    if (!v8)
      goto LABEL_6;
    v10 = 5;
    v9 = (_QWORD *)v1[15];
  }
  (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_6:
  v11 = (void *)v1[7];
  if (v11)
    operator delete(v11);
  if (*v2)
    operator delete(*v2);
  v12 = *v5;
  if (*v5)
  {
    v1[2] = v12;
    operator delete(v12);
  }
  _Unwind_Resume(a1);
}

uint64_t nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::scan(uint64_t a1)
{
  const char *v2;
  int v3;
  uint64_t result;
  int v6;
  std::string *v7;
  int v8;
  std::string *v9;
  int v10;
  int v11;
  std::string *v12;
  int v13;
  int v14;
  unsigned int v15;
  char v16;
  int v17;
  unsigned int codepoint;
  unsigned int v19;
  char v20;
  unsigned int v21;
  int v22;
  int v23;
  const char **v24;
  const char *v25;
  uint64_t v26;
  const char **v27;
  const char *v28;
  unint64_t v29;
  uint64_t v30;
  const char **v31;
  const char *v32;
  uint64_t v33;
  uint64_t v34;
  __int128 v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)(a1 + 24))
  {
    if (nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get((unsigned __int8 **)a1) != 239)
    {
      nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::unget(a1);
      goto LABEL_7;
    }
    if (nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get((unsigned __int8 **)a1) != 187
      || nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get((unsigned __int8 **)a1) != 191)
    {
      v2 = "invalid BOM; must be 0xEF 0xBB 0xBF if given";
      goto LABEL_127;
    }
  }
  do
  {
LABEL_7:
    while (2)
    {
      nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get((unsigned __int8 **)a1);
      v3 = *(_DWORD *)(a1 + 16);
      if (v3 > 31)
      {
        if (v3 > 90)
        {
          if (v3 <= 109)
          {
            switch(v3)
            {
              case '[':
                return 8;
              case ']':
                return 10;
              case 'f':
                return nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::scan_literal(a1, "false", 5, 2);
              default:
                goto LABEL_124;
            }
          }
          else if (v3 > 122)
          {
            if (v3 == 123)
            {
              return 9;
            }
            else
            {
              if (v3 != 125)
                goto LABEL_124;
              return 11;
            }
          }
          else if (v3 == 110)
          {
            LODWORD(v35) = 1819047278;
            return nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::scan_literal(a1, (unsigned __int8 *)&v35, 4, 3);
          }
          else
          {
            if (v3 != 116)
              goto LABEL_124;
            LODWORD(v35) = 1702195828;
            return nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::scan_literal(a1, (unsigned __int8 *)&v35, 4, 1);
          }
        }
        switch(v3)
        {
          case ' ':
            continue;
          case '"':
            nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::reset(a1);
            if (*(_DWORD *)(a1 + 16) != 34)
              __assert_rtn("scan_string", "lexer.hpp", 250, "current == '\\\"'");
            while (2)
            {
              v14 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get((unsigned __int8 **)a1)
                  + 1;
              result = 4;
              v2 = "invalid string: missing closing quote";
              switch(v14)
              {
                case 0:
                  goto LABEL_127;
                case 1:
                  v2 = "invalid string: control character U+0000 (NUL) must be escaped to \\u0000";
                  goto LABEL_127;
                case 2:
                  v2 = "invalid string: control character U+0001 (SOH) must be escaped to \\u0001";
                  goto LABEL_127;
                case 3:
                  v2 = "invalid string: control character U+0002 (STX) must be escaped to \\u0002";
                  goto LABEL_127;
                case 4:
                  v2 = "invalid string: control character U+0003 (ETX) must be escaped to \\u0003";
                  goto LABEL_127;
                case 5:
                  v2 = "invalid string: control character U+0004 (EOT) must be escaped to \\u0004";
                  goto LABEL_127;
                case 6:
                  v2 = "invalid string: control character U+0005 (ENQ) must be escaped to \\u0005";
                  goto LABEL_127;
                case 7:
                  v2 = "invalid string: control character U+0006 (ACK) must be escaped to \\u0006";
                  goto LABEL_127;
                case 8:
                  v2 = "invalid string: control character U+0007 (BEL) must be escaped to \\u0007";
                  goto LABEL_127;
                case 9:
                  v2 = "invalid string: control character U+0008 (BS) must be escaped to \\u0008 or \\b";
                  goto LABEL_127;
                case 10:
                  v2 = "invalid string: control character U+0009 (HT) must be escaped to \\u0009 or \\t";
                  goto LABEL_127;
                case 11:
                  v2 = "invalid string: control character U+000A (LF) must be escaped to \\u000A or \\n";
                  goto LABEL_127;
                case 12:
                  v2 = "invalid string: control character U+000B (VT) must be escaped to \\u000B";
                  goto LABEL_127;
                case 13:
                  v2 = "invalid string: control character U+000C (FF) must be escaped to \\u000C or \\f";
                  goto LABEL_127;
                case 14:
                  v2 = "invalid string: control character U+000D (CR) must be escaped to \\u000D or \\r";
                  goto LABEL_127;
                case 15:
                  v2 = "invalid string: control character U+000E (SO) must be escaped to \\u000E";
                  goto LABEL_127;
                case 16:
                  v2 = "invalid string: control character U+000F (SI) must be escaped to \\u000F";
                  goto LABEL_127;
                case 17:
                  v2 = "invalid string: control character U+0010 (DLE) must be escaped to \\u0010";
                  goto LABEL_127;
                case 18:
                  v2 = "invalid string: control character U+0011 (DC1) must be escaped to \\u0011";
                  goto LABEL_127;
                case 19:
                  v2 = "invalid string: control character U+0012 (DC2) must be escaped to \\u0012";
                  goto LABEL_127;
                case 20:
                  v2 = "invalid string: control character U+0013 (DC3) must be escaped to \\u0013";
                  goto LABEL_127;
                case 21:
                  v2 = "invalid string: control character U+0014 (DC4) must be escaped to \\u0014";
                  goto LABEL_127;
                case 22:
                  v2 = "invalid string: control character U+0015 (NAK) must be escaped to \\u0015";
                  goto LABEL_127;
                case 23:
                  v2 = "invalid string: control character U+0016 (SYN) must be escaped to \\u0016";
                  goto LABEL_127;
                case 24:
                  v2 = "invalid string: control character U+0017 (ETB) must be escaped to \\u0017";
                  goto LABEL_127;
                case 25:
                  v2 = "invalid string: control character U+0018 (CAN) must be escaped to \\u0018";
                  goto LABEL_127;
                case 26:
                  v2 = "invalid string: control character U+0019 (EM) must be escaped to \\u0019";
                  goto LABEL_127;
                case 27:
                  v2 = "invalid string: control character U+001A (SUB) must be escaped to \\u001A";
                  goto LABEL_127;
                case 28:
                  v2 = "invalid string: control character U+001B (ESC) must be escaped to \\u001B";
                  goto LABEL_127;
                case 29:
                  v2 = "invalid string: control character U+001C (FS) must be escaped to \\u001C";
                  goto LABEL_127;
                case 30:
                  v2 = "invalid string: control character U+001D (GS) must be escaped to \\u001D";
                  goto LABEL_127;
                case 31:
                  v2 = "invalid string: control character U+001E (RS) must be escaped to \\u001E";
                  goto LABEL_127;
                case 32:
                  v2 = "invalid string: control character U+001F (US) must be escaped to \\u001F";
                  goto LABEL_127;
                case 33:
                case 34:
                case 36:
                case 37:
                case 38:
                case 39:
                case 40:
                case 41:
                case 42:
                case 43:
                case 44:
                case 45:
                case 46:
                case 47:
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                case 58:
                case 59:
                case 60:
                case 61:
                case 62:
                case 63:
                case 64:
                case 65:
                case 66:
                case 67:
                case 68:
                case 69:
                case 70:
                case 71:
                case 72:
                case 73:
                case 74:
                case 75:
                case 76:
                case 77:
                case 78:
                case 79:
                case 80:
                case 81:
                case 82:
                case 83:
                case 84:
                case 85:
                case 86:
                case 87:
                case 88:
                case 89:
                case 90:
                case 91:
                case 92:
                case 94:
                case 95:
                case 96:
                case 97:
                case 98:
                case 99:
                case 100:
                case 101:
                case 102:
                case 103:
                case 104:
                case 105:
                case 106:
                case 107:
                case 108:
                case 109:
                case 110:
                case 111:
                case 112:
                case 113:
                case 114:
                case 115:
                case 116:
                case 117:
                case 118:
                case 119:
                case 120:
                case 121:
                case 122:
                case 123:
                case 124:
                case 125:
                case 126:
                case 127:
                case 128:
                  v15 = *(_DWORD *)(a1 + 16);
                  goto LABEL_53;
                case 35:
                  return result;
                case 93:
                  v17 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get((unsigned __int8 **)a1);
                  v2 = "invalid string: forbidden character after backslash";
                  if (v17 > 97)
                  {
                    switch(v17)
                    {
                      case 'n':
                        LOBYTE(v15) = 10;
                        break;
                      case 'o':
                      case 'p':
                      case 'q':
                      case 's':
                        goto LABEL_127;
                      case 'r':
                        LOBYTE(v15) = 13;
                        break;
                      case 't':
                        LOBYTE(v15) = 9;
                        break;
                      case 'u':
                        codepoint = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get_codepoint(a1);
                        v15 = codepoint;
                        if (codepoint == -1)
                          goto LABEL_178;
                        if ((codepoint & 0xFFFFFC00) == 0xD800)
                        {
                          if (nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get((unsigned __int8 **)a1) != 92
                            || nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get((unsigned __int8 **)a1) != 117)
                          {
                            goto LABEL_179;
                          }
                          v19 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get_codepoint(a1);
                          v20 = v19;
                          if (v19 == -1)
                          {
LABEL_178:
                            v2 = "invalid string: '\\u' must be followed by 4 hex digits";
                            goto LABEL_127;
                          }
                          if (v19 >> 10 != 55)
                          {
LABEL_179:
                            v2 = "invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF";
                            goto LABEL_127;
                          }
                          v21 = v19 + (v15 << 10) - 56613888;
                          std::string::push_back((std::string *)(a1 + 72), (v21 >> 18) | 0xF0);
                          std::string::push_back((std::string *)(a1 + 72), (v21 >> 12) & 0x3F | 0x80);
                          std::string::push_back((std::string *)(a1 + 72), (v21 >> 6) & 0x3F | 0x80);
                          LOBYTE(v15) = v20 & 0x3F | 0x80;
                        }
                        else
                        {
                          if ((codepoint & 0xFFFFFC00) == 0xDC00)
                          {
                            v2 = "invalid string: surrogate U+DC00..U+DFFF must follow U+D800..U+DBFF";
                            goto LABEL_127;
                          }
                          if (codepoint > 0x7F)
                          {
                            if (codepoint > 0x7FF)
                            {
                              std::string::push_back((std::string *)(a1 + 72), (codepoint >> 12) | 0xE0);
                              std::string::push_back((std::string *)(a1 + 72), (v15 >> 6) & 0x3F | 0x80);
                            }
                            else
                            {
                              std::string::push_back((std::string *)(a1 + 72), (codepoint >> 6) | 0xC0);
                            }
                            LOBYTE(v15) = v15 & 0x3F | 0x80;
                          }
                        }
                        break;
                      default:
                        if (v17 == 98)
                        {
                          LOBYTE(v15) = 8;
                        }
                        else
                        {
                          if (v17 != 102)
                            goto LABEL_127;
                          LOBYTE(v15) = 12;
                        }
                        break;
                    }
                  }
                  else
                  {
                    switch(v17)
                    {
                      case '"':
                        LOBYTE(v15) = 34;
                        break;
                      case '/':
                        LOBYTE(v15) = 47;
                        break;
                      case '\\':
                        LOBYTE(v15) = 92;
                        break;
                      default:
                        goto LABEL_127;
                    }
                  }
LABEL_53:
                  std::string::push_back((std::string *)(a1 + 72), v15);
                  continue;
                case 195:
                case 196:
                case 197:
                case 198:
                case 199:
                case 200:
                case 201:
                case 202:
                case 203:
                case 204:
                case 205:
                case 206:
                case 207:
                case 208:
                case 209:
                case 210:
                case 211:
                case 212:
                case 213:
                case 214:
                case 215:
                case 216:
                case 217:
                case 218:
                case 219:
                case 220:
                case 221:
                case 222:
                case 223:
                case 224:
                  *(_QWORD *)&v35 = 0xBF00000080;
                  v16 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::next_byte_in_range((std::string *)a1, &v35, 2uLL);
                  goto LABEL_56;
                case 225:
                  v35 = xmmword_1D4F18A80;
                  v16 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::next_byte_in_range((std::string *)a1, &v35, 4uLL);
                  goto LABEL_56;
                case 226:
                case 227:
                case 228:
                case 229:
                case 230:
                case 231:
                case 232:
                case 233:
                case 234:
                case 235:
                case 236:
                case 237:
                case 239:
                case 240:
                  v35 = xmmword_1D4F18A70;
                  v16 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::next_byte_in_range((std::string *)a1, &v35, 4uLL);
                  goto LABEL_56;
                case 238:
                  v35 = xmmword_1D4F18A60;
                  v16 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::next_byte_in_range((std::string *)a1, &v35, 4uLL);
                  goto LABEL_56;
                case 241:
                  v36 = 0xBF00000080;
                  v35 = xmmword_1D4F19288;
                  v16 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::next_byte_in_range((std::string *)a1, &v35, 6uLL);
                  goto LABEL_56;
                case 242:
                case 243:
                case 244:
                  v36 = 0xBF00000080;
                  v35 = xmmword_1D4F192A0;
                  v16 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::next_byte_in_range((std::string *)a1, &v35, 6uLL);
                  goto LABEL_56;
                case 245:
                  v36 = 0xBF00000080;
                  v35 = xmmword_1D4F192B8;
                  v16 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::next_byte_in_range((std::string *)a1, &v35, 6uLL);
LABEL_56:
                  if ((v16 & 1) == 0)
                    return 14;
                  continue;
                default:
                  v2 = "invalid string: ill-formed UTF-8 byte";
                  goto LABEL_127;
              }
            }
          case ',':
            return 13;
          case '-':
          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::reset(a1);
            v6 = *(_DWORD *)(a1 + 16);
            if ((v6 - 49) < 9)
            {
              v7 = (std::string *)(a1 + 72);
              v8 = 5;
LABEL_18:
              std::string::push_back(v7, v6);
              v9 = (std::string *)(a1 + 72);
              while (1)
              {
                v10 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get((unsigned __int8 **)a1);
                if ((v10 - 48) >= 0xA)
                  break;
                std::string::push_back((std::string *)(a1 + 72), *(_BYTE *)(a1 + 16));
              }
              if (v10 != 46)
              {
                if (v10 == 69 || v10 == 101)
                  goto LABEL_24;
LABEL_110:
                nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::unget(a1);
                *(_QWORD *)&v35 = 0;
                *__error() = 0;
                if (v8 == 6)
                {
                  v31 = (const char **)(a1 + 72);
                  v32 = (const char *)(a1 + 72);
                  if (*(char *)(a1 + 95) < 0)
                    v32 = *v31;
                  v33 = strtoll(v32, (char **)&v35, 10);
                  if (*(char *)(a1 + 95) < 0)
                  {
                    v31 = *(const char ***)(a1 + 72);
                    v34 = *(_QWORD *)(a1 + 80);
                  }
                  else
                  {
                    v34 = *(unsigned __int8 *)(a1 + 95);
                  }
                  if ((const char **)v35 != (const char **)((char *)v31 + v34))
                    __assert_rtn("scan_number", "lexer.hpp", 1191, "endptr == token_buffer.data() + token_buffer.size()");
                  if (!*__error())
                  {
                    *(_QWORD *)(a1 + 104) = v33;
                    return 6;
                  }
                }
                else
                {
                  v27 = (const char **)(a1 + 72);
                  v28 = (const char *)(a1 + 72);
                  if (*(char *)(a1 + 95) < 0)
                    v28 = *v27;
                  v29 = strtoull(v28, (char **)&v35, 10);
                  if (*(char *)(a1 + 95) < 0)
                  {
                    v27 = *(const char ***)(a1 + 72);
                    v30 = *(_QWORD *)(a1 + 80);
                  }
                  else
                  {
                    v30 = *(unsigned __int8 *)(a1 + 95);
                  }
                  if ((const char **)v35 != (const char **)((char *)v27 + v30))
                    __assert_rtn("scan_number", "lexer.hpp", 1175, "endptr == token_buffer.data() + token_buffer.size()");
                  if (!*__error())
                  {
                    *(_QWORD *)(a1 + 112) = v29;
                    return 5;
                  }
                }
LABEL_103:
                v24 = (const char **)(a1 + 72);
                v25 = (const char *)(a1 + 72);
                if (*(char *)(a1 + 95) < 0)
                  v25 = *v24;
                *(double *)(a1 + 120) = strtod(v25, (char **)&v35);
                if (*(char *)(a1 + 95) < 0)
                {
                  v24 = *(const char ***)(a1 + 72);
                  v26 = *(_QWORD *)(a1 + 80);
                }
                else
                {
                  v26 = *(unsigned __int8 *)(a1 + 95);
                }
                if ((const char **)v35 != (const char **)((char *)v24 + v26))
                  __assert_rtn("scan_number", "lexer.hpp", 1208, "endptr == token_buffer.data() + token_buffer.size()");
                return 7;
              }
              goto LABEL_97;
            }
            if (v6 == 48)
            {
              std::string::push_back((std::string *)(a1 + 72), 48);
              v8 = 5;
            }
            else
            {
              if (v6 != 45)
                __assert_rtn("scan_number", "lexer.hpp", 928, "false");
              v7 = (std::string *)(a1 + 72);
              std::string::push_back((std::string *)(a1 + 72), 45);
              v13 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get((unsigned __int8 **)a1);
              if ((v13 - 49) < 9)
              {
                v6 = *(_DWORD *)(a1 + 16);
                v8 = 6;
                goto LABEL_18;
              }
              if (v13 != 48)
              {
                v2 = "invalid number; expected digit after '-'";
                goto LABEL_127;
              }
              std::string::push_back((std::string *)(a1 + 72), *(_BYTE *)(a1 + 16));
              v8 = 6;
            }
            v22 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get((unsigned __int8 **)a1);
            if (v22 == 101 || v22 == 69)
            {
              v9 = (std::string *)(a1 + 72);
              goto LABEL_24;
            }
            if (v22 != 46)
              goto LABEL_110;
            v9 = (std::string *)(a1 + 72);
LABEL_97:
            std::string::push_back(v9, *(_BYTE *)(a1 + 128));
            if (nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get((unsigned __int8 **)a1)
               - 48 > 9)
            {
              v2 = "invalid number; expected digit after '.'";
              goto LABEL_127;
            }
            v9 = (std::string *)(a1 + 72);
            do
            {
              std::string::push_back((std::string *)(a1 + 72), *(_BYTE *)(a1 + 16));
              v23 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get((unsigned __int8 **)a1);
            }
            while ((v23 - 48) < 0xA);
            if (v23 != 101 && v23 != 69)
            {
LABEL_102:
              nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::unget(a1);
              *(_QWORD *)&v35 = 0;
              *__error() = 0;
              goto LABEL_103;
            }
LABEL_24:
            std::string::push_back(v9, *(_BYTE *)(a1 + 16));
            v11 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get((unsigned __int8 **)a1);
            if ((v11 - 48) >= 0xA)
            {
              if (v11 != 45 && v11 != 43)
              {
                v2 = "invalid number; expected '+', '-', or digit after exponent";
                goto LABEL_127;
              }
              v12 = (std::string *)(a1 + 72);
              std::string::push_back((std::string *)(a1 + 72), *(_BYTE *)(a1 + 16));
              if (nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get((unsigned __int8 **)a1)
                 - 48 >= 0xA)
              {
                v2 = "invalid number; expected digit after exponent sign";
                goto LABEL_127;
              }
            }
            else
            {
              v12 = (std::string *)(a1 + 72);
            }
            std::string::push_back(v12, *(_BYTE *)(a1 + 16));
            while (nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get((unsigned __int8 **)a1)
                  - 48 <= 9)
              std::string::push_back((std::string *)(a1 + 72), *(_BYTE *)(a1 + 16));
            goto LABEL_102;
          case ':':
            return 12;
          default:
            goto LABEL_124;
        }
      }
      break;
    }
  }
  while ((v3 - 9) < 2 || v3 == 13);
  if ((v3 + 1) < 2)
    return 15;
LABEL_124:
  v2 = "invalid literal";
LABEL_127:
  *(_QWORD *)(a1 + 96) = v2;
  return 14;
}

void sub_1D4EC6CE0(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

void nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get_token_string(std::string *this, unsigned __int8 *a2, unsigned __int8 *a3)
{
  unsigned __int8 *v4;
  unsigned int v6;
  size_t v7;
  char __str[8];
  char v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)&this->__r_.__value_.__l.__data_ = 0uLL;
  this->__r_.__value_.__r.__words[2] = 0;
  if (a2 != a3)
  {
    v4 = a2;
    do
    {
      v6 = *v4;
      if (v6 > 0x1F)
      {
        std::string::push_back(this, v6);
      }
      else
      {
        v9 = 0;
        *(_QWORD *)__str = 0;
        snprintf(__str, 9uLL, "<U+%.4X>", v6);
        v7 = strlen(__str);
        std::string::append(this, __str, v7);
      }
      ++v4;
    }
    while (v4 != a3);
  }
}

void sub_1D4EC6DBC(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::exception_message(std::string *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v8;
  std::string *v9;
  __int128 v10;
  const std::string::value_type *v11;
  std::string::size_type v12;
  uint64_t v13;
  std::string *v14;
  __int128 v15;
  std::string *p_p;
  std::string::size_type size;
  std::string *v18;
  __int128 v19;
  std::string *v20;
  __int128 v21;
  const std::string::value_type *v22;
  std::string::size_type v23;
  void *v24;
  char *v25;
  std::string *v26;
  __int128 v27;
  const std::string::value_type *v28;
  std::string::size_type v29;
  char *v30;
  std::string *v31;
  __int128 v32;
  const std::string::value_type *v33;
  std::string::size_type v34;
  std::string __p;
  std::string v36;
  std::string v37;
  std::string v38;
  __int128 v39;
  int64_t v40;

  std::string::basic_string[abi:ne180100]<0>(a1, "syntax error ");
  v8 = *(unsigned __int8 *)(a4 + 23);
  if ((v8 & 0x80u) != 0)
    v8 = *(_QWORD *)(a4 + 8);
  if (v8)
  {
    std::operator+<char>();
    v9 = std::string::append(&v38, " ", 1uLL);
    v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    v40 = v9->__r_.__value_.__r.__words[2];
    v39 = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    if (v40 >= 0)
      v11 = (const std::string::value_type *)&v39;
    else
      v11 = (const std::string::value_type *)v39;
    if (v40 >= 0)
      v12 = HIBYTE(v40);
    else
      v12 = *((_QWORD *)&v39 + 1);
    std::string::append(a1, v11, v12);
    if (SHIBYTE(v40) < 0)
      operator delete((void *)v39);
    if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v38.__r_.__value_.__l.__data_);
  }
  std::string::append(a1, "- ", 2uLL);
  v13 = *(int *)(a2 + 32);
  if ((_DWORD)v13 == 14)
  {
    std::string::basic_string[abi:ne180100]<0>(&v36, *(char **)(a2 + 136));
    v14 = std::string::append(&v36, "; last read: '", 0xEuLL);
    v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    v37.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v37.__r_.__value_.__l.__data_ = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get_token_string(&__p, *(unsigned __int8 **)(a2 + 88), *(unsigned __int8 **)(a2 + 96));
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_p = &__p;
    else
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    else
      size = __p.__r_.__value_.__l.__size_;
    v18 = std::string::append(&v37, (const std::string::value_type *)p_p, size);
    v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v38.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v19;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    v20 = std::string::append(&v38, "'", 1uLL);
    v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
    v40 = v20->__r_.__value_.__r.__words[2];
    v39 = v21;
    v20->__r_.__value_.__l.__size_ = 0;
    v20->__r_.__value_.__r.__words[2] = 0;
    v20->__r_.__value_.__r.__words[0] = 0;
    if (v40 >= 0)
      v22 = (const std::string::value_type *)&v39;
    else
      v22 = (const std::string::value_type *)v39;
    if (v40 >= 0)
      v23 = HIBYTE(v40);
    else
      v23 = *((_QWORD *)&v39 + 1);
    std::string::append(a1, v22, v23);
    if (SHIBYTE(v40) < 0)
      operator delete((void *)v39);
    if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v38.__r_.__value_.__l.__data_);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v37.__r_.__value_.__l.__data_);
    if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0)
    {
      v24 = (void *)v36.__r_.__value_.__r.__words[0];
      goto LABEL_52;
    }
LABEL_49:
    if (!a3)
      return;
    goto LABEL_53;
  }
  if (v13 > 0x10)
    v25 = "unknown token";
  else
    v25 = off_1E98BA3B8[v13];
  std::string::basic_string[abi:ne180100]<0>(&v38, v25);
  v26 = std::string::insert(&v38, 0, "unexpected ", 0xBuLL);
  v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
  v40 = v26->__r_.__value_.__r.__words[2];
  v39 = v27;
  v26->__r_.__value_.__l.__size_ = 0;
  v26->__r_.__value_.__r.__words[2] = 0;
  v26->__r_.__value_.__r.__words[0] = 0;
  if (v40 >= 0)
    v28 = (const std::string::value_type *)&v39;
  else
    v28 = (const std::string::value_type *)v39;
  if (v40 >= 0)
    v29 = HIBYTE(v40);
  else
    v29 = *((_QWORD *)&v39 + 1);
  std::string::append(a1, v28, v29);
  if (SHIBYTE(v40) < 0)
    operator delete((void *)v39);
  if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    goto LABEL_49;
  v24 = (void *)v38.__r_.__value_.__r.__words[0];
LABEL_52:
  operator delete(v24);
  if (!a3)
    return;
LABEL_53:
  if (a3 > 0x10)
    v30 = "unknown token";
  else
    v30 = off_1E98BA3B8[a3];
  std::string::basic_string[abi:ne180100]<0>(&v38, v30);
  v31 = std::string::insert(&v38, 0, "; expected ", 0xBuLL);
  v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
  v40 = v31->__r_.__value_.__r.__words[2];
  v39 = v32;
  v31->__r_.__value_.__l.__size_ = 0;
  v31->__r_.__value_.__r.__words[2] = 0;
  v31->__r_.__value_.__r.__words[0] = 0;
  if (v40 >= 0)
    v33 = (const std::string::value_type *)&v39;
  else
    v33 = (const std::string::value_type *)v39;
  if (v40 >= 0)
    v34 = HIBYTE(v40);
  else
    v34 = *((_QWORD *)&v39 + 1);
  std::string::append(a1, v33, v34);
  if (SHIBYTE(v40) < 0)
    operator delete((void *)v39);
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v38.__r_.__value_.__l.__data_);
}

void sub_1D4EC7140(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  uint64_t v33;
  uint64_t v34;

  if (*(char *)(v34 - 41) < 0)
    operator delete(*(void **)(v34 - 64));
  if (a33 < 0)
    operator delete(__p);
  if (a14 < 0)
    operator delete(a9);
  if (a26 < 0)
    operator delete(a21);
  if (a20 < 0)
    operator delete(a15);
  if (*(char *)(v33 + 23) < 0)
    operator delete(*(void **)v33);
  _Unwind_Resume(exception_object);
}

void nlohmann::detail::parse_error::create(nlohmann::detail::exception *a1, uint64_t *a2, uint64_t a3)
{
  std::string *v6;
  __int128 v7;
  std::string *v8;
  __int128 v9;
  std::string *v10;
  __int128 v11;
  std::string *v12;
  std::string::size_type size;
  std::string *v14;
  __int128 v15;
  void **v16;
  std::string::size_type v17;
  std::string *v18;
  __int128 v19;
  std::string *v20;
  __int128 v21;
  int v22;
  const std::string::value_type *v23;
  std::string::size_type v24;
  std::string *v25;
  __int128 v26;
  uint64_t v27;
  void **v28;
  void *__p[2];
  int64_t v30;
  void *v31[2];
  char v32;
  std::string v33;
  std::string v34;
  std::string v35;
  std::string v36;
  void *v37[2];
  int64_t v38;
  std::string v39;
  std::string v40;
  std::string v41;
  std::string v42;

  std::string::basic_string[abi:ne180100]<0>(v31, "parse_error");
  nlohmann::detail::exception::name(&v33, (uint64_t)v31, 101);
  v6 = std::string::append(&v33, "parse error", 0xBuLL);
  v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v34.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v34.__r_.__value_.__l.__data_ = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v40, a2[2] + 1);
  v8 = std::string::insert(&v40, 0, " at line ", 9uLL);
  v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v41.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v41.__r_.__value_.__l.__data_ = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  v10 = std::string::append(&v41, ", column ", 9uLL);
  v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  v42.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v11;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v39, a2[1]);
  if ((v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v12 = &v39;
  else
    v12 = (std::string *)v39.__r_.__value_.__r.__words[0];
  if ((v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v39.__r_.__value_.__r.__words[2]);
  else
    size = v39.__r_.__value_.__l.__size_;
  v14 = std::string::append(&v42, (const std::string::value_type *)v12, size);
  v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v30 = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v39.__r_.__value_.__l.__data_);
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v42.__r_.__value_.__l.__data_);
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v41.__r_.__value_.__l.__data_);
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v40.__r_.__value_.__l.__data_);
  if (v30 >= 0)
    v16 = __p;
  else
    v16 = (void **)__p[0];
  if (v30 >= 0)
    v17 = HIBYTE(v30);
  else
    v17 = (std::string::size_type)__p[1];
  v18 = std::string::append(&v34, (const std::string::value_type *)v16, v17);
  v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
  v35.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v35.__r_.__value_.__l.__data_ = v19;
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  v20 = std::string::append(&v35, ": ", 2uLL);
  v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
  v36.__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v36.__r_.__value_.__l.__data_ = v21;
  v20->__r_.__value_.__l.__size_ = 0;
  v20->__r_.__value_.__r.__words[2] = 0;
  v20->__r_.__value_.__r.__words[0] = 0;
  v22 = *(char *)(a3 + 23);
  if (v22 >= 0)
    v23 = (const std::string::value_type *)a3;
  else
    v23 = *(const std::string::value_type **)a3;
  if (v22 >= 0)
    v24 = *(unsigned __int8 *)(a3 + 23);
  else
    v24 = *(_QWORD *)(a3 + 8);
  v25 = std::string::append(&v36, v23, v24);
  v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
  v38 = v25->__r_.__value_.__r.__words[2];
  *(_OWORD *)v37 = v26;
  v25->__r_.__value_.__l.__size_ = 0;
  v25->__r_.__value_.__r.__words[2] = 0;
  v25->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v36.__r_.__value_.__l.__data_);
  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v35.__r_.__value_.__l.__data_);
  if (SHIBYTE(v30) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v34.__r_.__value_.__l.__data_);
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v33.__r_.__value_.__l.__data_);
  if (v32 < 0)
    operator delete(v31[0]);
  v27 = *a2;
  if (v38 >= 0)
    v28 = v37;
  else
    v28 = (void **)v37[0];
  nlohmann::detail::exception::exception(a1, 101, (const char *)v28);
  *(_QWORD *)a1 = &off_1E98B6F68;
  *((_QWORD *)a1 + 4) = v27;
  if (SHIBYTE(v38) < 0)
    operator delete(v37[0]);
}

void sub_1D4EC74E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,uint64_t a48,void *__p,uint64_t a50,int a51,__int16 a52,char a53,char a54)
{
  if (a54 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1D4EC75DC()
{
  JUMPOUT(0x1D4EC75C4);
}

uint64_t nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error(uint64_t result, const nlohmann::detail::type_error *a2)
{
  void *exception;
  void *v3;
  void *v4;
  void *v5;
  nlohmann::detail::type_error *v6;
  nlohmann::detail::type_error *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;

  *(_BYTE *)(result + 88) = 1;
  if (*(_BYTE *)(result + 128))
  {
    switch(~(100 * (*((_DWORD *)a2 + 2) / 100 / 100)) + *((_DWORD *)a2 + 2) / 100)
    {
      case 0:
        exception = __cxa_allocate_exception(0x28uLL);
        v3 = (void *)nlohmann::detail::parse_error::parse_error((uint64_t)exception, (uint64_t)a2);
      case 1:
        v4 = __cxa_allocate_exception(0x20uLL);
        v5 = (void *)nlohmann::detail::invalid_iterator::invalid_iterator((uint64_t)v4, (uint64_t)a2);
      case 2:
        v6 = (nlohmann::detail::type_error *)__cxa_allocate_exception(0x20uLL);
        v7 = nlohmann::detail::type_error::type_error(v6, a2);
      case 3:
        v8 = __cxa_allocate_exception(0x20uLL);
        v9 = (void *)nlohmann::detail::out_of_range::out_of_range((uint64_t)v8, (uint64_t)a2);
      case 4:
        v10 = __cxa_allocate_exception(0x20uLL);
        v11 = (void *)nlohmann::detail::other_error::other_error((uint64_t)v10, (uint64_t)a2);
      default:
        __assert_rtn("parse_error", "json_sax.hpp", 537, "false");
    }
  }
  return result;
}

uint64_t nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::~json_sax_dom_callback_parser(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  void *v4;
  void *v5;
  void *v6;

  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(a1 + 136);
  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy((uint64_t **)(a1 + 144), *(unsigned __int8 *)(a1 + 136));
  v2 = *(_QWORD **)(a1 + 120);
  if (v2 == (_QWORD *)(a1 + 96))
  {
    v3 = 4;
    v2 = (_QWORD *)(a1 + 96);
  }
  else
  {
    if (!v2)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  v4 = *(void **)(a1 + 56);
  if (v4)
    operator delete(v4);
  v5 = *(void **)(a1 + 32);
  if (v5)
    operator delete(v5);
  v6 = *(void **)(a1 + 8);
  if (v6)
  {
    *(_QWORD *)(a1 + 16) = v6;
    operator delete(v6);
  }
  return a1;
}

uint64_t nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error(uint64_t result, const nlohmann::detail::type_error *a2)
{
  void *exception;
  void *v3;
  void *v4;
  void *v5;
  nlohmann::detail::type_error *v6;
  nlohmann::detail::type_error *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;

  *(_BYTE *)(result + 40) = 1;
  if (*(_BYTE *)(result + 41))
  {
    switch(~(100 * (*((_DWORD *)a2 + 2) / 100 / 100)) + *((_DWORD *)a2 + 2) / 100)
    {
      case 0:
        exception = __cxa_allocate_exception(0x28uLL);
        v3 = (void *)nlohmann::detail::parse_error::parse_error((uint64_t)exception, (uint64_t)a2);
      case 1:
        v4 = __cxa_allocate_exception(0x20uLL);
        v5 = (void *)nlohmann::detail::invalid_iterator::invalid_iterator((uint64_t)v4, (uint64_t)a2);
      case 2:
        v6 = (nlohmann::detail::type_error *)__cxa_allocate_exception(0x20uLL);
        v7 = nlohmann::detail::type_error::type_error(v6, a2);
      case 3:
        v8 = __cxa_allocate_exception(0x20uLL);
        v9 = (void *)nlohmann::detail::out_of_range::out_of_range((uint64_t)v8, (uint64_t)a2);
      case 4:
        v10 = __cxa_allocate_exception(0x20uLL);
        v11 = (void *)nlohmann::detail::other_error::other_error((uint64_t)v10, (uint64_t)a2);
      default:
        __assert_rtn("parse_error", "json_sax.hpp", 283, "false");
    }
  }
  return result;
}

uint64_t nlohmann::detail::parse_error::parse_error(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = &off_1E98B6FE0;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  MEMORY[0x1D826B804](a1 + 16, a2 + 16);
  *(_QWORD *)a1 = &off_1E98B6F68;
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  return a1;
}

void nlohmann::detail::parse_error::~parse_error(std::runtime_error *this)
{
  this->__vftable = (std::runtime_error_vtbl *)&off_1E98B6FE0;
  std::runtime_error::~runtime_error(this + 1);
  std::exception::~exception(this);
}

{
  this->__vftable = (std::runtime_error_vtbl *)&off_1E98B6FE0;
  std::runtime_error::~runtime_error(this + 1);
  std::exception::~exception(this);
  JUMPOUT(0x1D826BA98);
}

uint64_t nlohmann::detail::out_of_range::out_of_range(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = &off_1E98B6FE0;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  MEMORY[0x1D826B804](a1 + 16, a2 + 16);
  *(_QWORD *)a1 = &off_1E98B6F90;
  return a1;
}

void nlohmann::detail::out_of_range::~out_of_range(std::runtime_error *this)
{
  this->__vftable = (std::runtime_error_vtbl *)&off_1E98B6FE0;
  std::runtime_error::~runtime_error(this + 1);
  std::exception::~exception(this);
}

{
  this->__vftable = (std::runtime_error_vtbl *)&off_1E98B6FE0;
  std::runtime_error::~runtime_error(this + 1);
  std::exception::~exception(this);
  JUMPOUT(0x1D826BA98);
}

uint64_t nlohmann::detail::invalid_iterator::invalid_iterator(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = &off_1E98B6FE0;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  MEMORY[0x1D826B804](a1 + 16, a2 + 16);
  *(_QWORD *)a1 = &off_1E98B6FB8;
  return a1;
}

void nlohmann::detail::invalid_iterator::~invalid_iterator(std::runtime_error *this)
{
  this->__vftable = (std::runtime_error_vtbl *)&off_1E98B6FE0;
  std::runtime_error::~runtime_error(this + 1);
  std::exception::~exception(this);
}

{
  this->__vftable = (std::runtime_error_vtbl *)&off_1E98B6FE0;
  std::runtime_error::~runtime_error(this + 1);
  std::exception::~exception(this);
  JUMPOUT(0x1D826BA98);
}

nlohmann::detail::type_error *nlohmann::detail::type_error::type_error(nlohmann::detail::type_error *this, const nlohmann::detail::type_error *a2)
{
  *(_QWORD *)this = &off_1E98B6FE0;
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  MEMORY[0x1D826B804]((char *)this + 16, (char *)a2 + 16);
  *(_QWORD *)this = &off_1E98B6F18;
  return this;
}

uint64_t nlohmann::detail::other_error::other_error(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = &off_1E98B6FE0;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  MEMORY[0x1D826B804](a1 + 16, a2 + 16);
  *(_QWORD *)a1 = &off_1E98B6F40;
  return a1;
}

void nlohmann::detail::other_error::~other_error(std::runtime_error *this)
{
  this->__vftable = (std::runtime_error_vtbl *)&off_1E98B6FE0;
  std::runtime_error::~runtime_error(this + 1);
  std::exception::~exception(this);
}

{
  this->__vftable = (std::runtime_error_vtbl *)&off_1E98B6FE0;
  std::runtime_error::~runtime_error(this + 1);
  std::exception::~exception(this);
  JUMPOUT(0x1D826BA98);
}

void nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::start_object(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  unint64_t v14;
  char *v15;
  char *v16;
  uint64_t v17;
  char v18;

  v18 = 1;
  v2 = nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<nlohmann::detail::value_t>(a1, &v18);
  v3 = v2;
  v5 = (uint64_t *)a1[2];
  v4 = a1[3];
  if ((unint64_t)v5 >= v4)
  {
    v7 = a1[1];
    v8 = ((uint64_t)v5 - v7) >> 3;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v9 = v4 - v7;
    v10 = v9 >> 2;
    if (v9 >> 2 <= (unint64_t)(v8 + 1))
      v10 = v8 + 1;
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    if (v11)
      v11 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v11);
    else
      v12 = 0;
    v13 = (uint64_t *)(v11 + 8 * v8);
    v14 = v11 + 8 * v12;
    *v13 = v3;
    v6 = v13 + 1;
    v16 = (char *)a1[1];
    v15 = (char *)a1[2];
    if (v15 != v16)
    {
      do
      {
        v17 = *((_QWORD *)v15 - 1);
        v15 -= 8;
        *--v13 = v17;
      }
      while (v15 != v16);
      v15 = (char *)a1[1];
    }
    a1[1] = (uint64_t)v13;
    a1[2] = (uint64_t)v6;
    a1[3] = v14;
    if (v15)
      operator delete(v15);
  }
  else
  {
    *v5 = v2;
    v6 = v5 + 1;
  }
  a1[2] = (uint64_t)v6;
}

char *std::__tree<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::__map_value_compare<std::string,std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::less<void>,true>,std::allocator<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t **a1, void **a2, __int128 **a3)
{
  void **v5;
  char *v6;
  uint64_t **v7;
  std::string *v8;
  __int128 *v9;
  __int128 v10;
  _QWORD v12[2];
  char v13;
  uint64_t v14;

  v5 = (void **)std::__tree<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::__map_value_compare<std::string,std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::less<void>,true>,std::allocator<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>>::__find_equal<std::string>((uint64_t)a1, &v14, a2);
  v6 = (char *)*v5;
  if (!*v5)
  {
    v7 = (uint64_t **)v5;
    v6 = (char *)operator new(0x48uLL);
    v12[0] = v6;
    v12[1] = a1 + 1;
    v13 = 0;
    v8 = (std::string *)(v6 + 32);
    v9 = *a3;
    if (*((char *)*a3 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v8, *(const std::string::value_type **)v9, *((_QWORD *)v9 + 1));
    }
    else
    {
      v10 = *v9;
      *((_QWORD *)v6 + 6) = *((_QWORD *)v9 + 2);
      *(_OWORD *)&v8->__r_.__value_.__l.__data_ = v10;
    }
    v6[56] = 0;
    *((_QWORD *)v6 + 8) = 0;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)(v6 + 56));
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)(v6 + 56));
    v13 = 1;
    std::__tree<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::__map_value_compare<std::string,std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::less<void>,true>,std::allocator<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>>::__insert_node_at(a1, v14, v7, (uint64_t *)v6);
    v12[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,void *>>>>::reset[abi:ne180100]((uint64_t)v12);
  }
  return v6;
}

void sub_1D4EC7E40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::unique_ptr<std::__tree_node<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,void *>>>>::reset[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void std::vector<BOOL>::push_back(uint64_t a1, _BYTE *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t *v8;
  _QWORD *v9;
  __int128 v10;
  unint64_t v11;
  int v12;
  int v13;
  _QWORD *v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v5 = *(_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 16);
  if (v5 != v4 << 6)
    goto LABEL_29;
  if ((uint64_t)(v5 + 1) < 0)
    goto LABEL_8;
  if (v5 > 0x3FFFFFFFFFFFFFFELL)
  {
    v6 = 0x7FFFFFFFFFFFFFFFLL;
    if (v5 >= 0x7FFFFFFFFFFFFFFFLL)
      goto LABEL_29;
    goto LABEL_10;
  }
  v6 = v4 << 7;
  if (v6 <= (v5 & 0xFFFFFFFFFFFFFFC0) + 64)
    v6 = (v5 & 0xFFFFFFFFFFFFFFC0) + 64;
  if (v5 < v6)
  {
    if ((v6 & 0x8000000000000000) != 0)
LABEL_8:
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
LABEL_10:
    v7 = ((v6 - 1) >> 6) + 1;
    v8 = (uint64_t *)operator new(8 * v7);
    v9 = *(_QWORD **)a1;
    *(_QWORD *)&v10 = v5;
    *((_QWORD *)&v10 + 1) = v7;
    v11 = (v5 - 1) >> 6;
    if (v5 < 0x41)
      v11 = 0;
    v8[v11] = 0;
    if (v5 > 0x3F || (v5 & 0x3F) != 0)
    {
      v12 = 0;
      v13 = 0;
      v14 = &v9[v5 >> 6];
      v15 = v8;
      do
      {
        v16 = 1 << v12;
        if (((*v9 >> v13) & 1) != 0)
          v17 = *v15 | v16;
        else
          v17 = *v15 & ~v16;
        *v15 = v17;
        v9 += v13 == 63;
        if (v13 == 63)
          v13 = 0;
        else
          ++v13;
        v15 += v12 == 63;
        if (v12 == 63)
          v12 = 0;
        else
          ++v12;
      }
      while (v9 != v14 || v13 != (v5 & 0x3F));
      v9 = *(_QWORD **)a1;
    }
    *(_QWORD *)a1 = v8;
    *(_OWORD *)(a1 + 8) = v10;
    if (v9)
    {
      operator delete(v9);
      v5 = *(_QWORD *)(a1 + 8);
    }
  }
LABEL_29:
  *(_QWORD *)(a1 + 8) = v5 + 1;
  v18 = *(_QWORD **)a1;
  v19 = v5 >> 6;
  v20 = 1 << v5;
  if (*a2)
    v21 = v18[v19] | v20;
  else
    v21 = v18[v19] & ~v20;
  v18[v19] = v21;
}

void nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::start_array(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  unint64_t v14;
  char *v15;
  char *v16;
  uint64_t v17;
  char v18;

  v18 = 2;
  v2 = nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<nlohmann::detail::value_t>(a1, &v18);
  v3 = v2;
  v5 = (uint64_t *)a1[2];
  v4 = a1[3];
  if ((unint64_t)v5 >= v4)
  {
    v7 = a1[1];
    v8 = ((uint64_t)v5 - v7) >> 3;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v9 = v4 - v7;
    v10 = v9 >> 2;
    if (v9 >> 2 <= (unint64_t)(v8 + 1))
      v10 = v8 + 1;
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    if (v11)
      v11 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v11);
    else
      v12 = 0;
    v13 = (uint64_t *)(v11 + 8 * v8);
    v14 = v11 + 8 * v12;
    *v13 = v3;
    v6 = v13 + 1;
    v16 = (char *)a1[1];
    v15 = (char *)a1[2];
    if (v15 != v16)
    {
      do
      {
        v17 = *((_QWORD *)v15 - 1);
        v15 -= 8;
        *--v13 = v17;
      }
      while (v15 != v16);
      v15 = (char *)a1[1];
    }
    a1[1] = (uint64_t)v13;
    a1[2] = (uint64_t)v6;
    a1[3] = v14;
    if (v15)
      operator delete(v15);
  }
  else
  {
    *v5 = v2;
    v6 = v5 + 1;
  }
  a1[2] = (uint64_t)v6;
}

void nlohmann::detail::out_of_range::create(nlohmann::detail::exception *a1, uint64_t a2)
{
  int v4;
  const std::string::value_type *v5;
  std::string::size_type v6;
  std::string *v7;
  __int128 v8;
  void **v9;
  void *__p[2];
  char v11;
  std::string v12;
  void *v13[2];
  int64_t v14;

  std::string::basic_string[abi:ne180100]<0>(__p, "out_of_range");
  nlohmann::detail::exception::name(&v12, (uint64_t)__p, 406);
  v4 = *(char *)(a2 + 23);
  if (v4 >= 0)
    v5 = (const std::string::value_type *)a2;
  else
    v5 = *(const std::string::value_type **)a2;
  if (v4 >= 0)
    v6 = *(unsigned __int8 *)(a2 + 23);
  else
    v6 = *(_QWORD *)(a2 + 8);
  v7 = std::string::append(&v12, v5, v6);
  v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
  v14 = v7->__r_.__value_.__r.__words[2];
  *(_OWORD *)v13 = v8;
  v7->__r_.__value_.__l.__size_ = 0;
  v7->__r_.__value_.__r.__words[2] = 0;
  v7->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v12.__r_.__value_.__l.__data_);
  if (v11 < 0)
    operator delete(__p[0]);
  if (v14 >= 0)
    v9 = v13;
  else
    v9 = (void **)v13[0];
  nlohmann::detail::exception::exception(a1, 406, (const char *)v9);
  *(_QWORD *)a1 = &off_1E98B6F90;
  if (SHIBYTE(v14) < 0)
    operator delete(v13[0]);
}

void sub_1D4EC8194(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<double &>(unsigned __int8 **a1, uint64_t *a2)
{
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  int v6;
  uint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t **v12;
  uint64_t v13;
  unsigned __int8 *v14;
  int v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  unsigned __int8 *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char v29[8];
  uint64_t v30;
  char v31[8];
  uint64_t v32;
  _QWORD v33[5];

  v4 = a1[2];
  if (a1[1] == v4)
  {
    v12 = (uint64_t **)&v32;
    v13 = *a2;
    v31[0] = 7;
    v32 = v13;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v31);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v31);
    v14 = *a1;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v31);
    v15 = *v14;
    *v14 = 7;
    v31[0] = v15;
    v16 = *((_QWORD *)v14 + 1);
    *((_QWORD *)v14 + 1) = v13;
    v32 = v16;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v14);
    v17 = v31;
LABEL_9:
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v17);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(v12, v15);
    return;
  }
  v5 = (unsigned __int8 *)*((_QWORD *)v4 - 1);
  v6 = *v5;
  if (v6 != 2)
  {
    if (v6 != 1)
      __assert_rtn("handle_value", "json_sax.hpp", 312, "ref_stack.back()->is_array() or ref_stack.back()->is_object()");
    if (!a1[4])
      __assert_rtn("handle_value", "json_sax.hpp", 321, "object_element");
    v12 = (uint64_t **)&v30;
    v18 = *a2;
    v29[0] = 7;
    v30 = v18;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v29);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v29);
    v19 = a1[4];
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v29);
    v15 = *v19;
    *v19 = 7;
    v29[0] = v15;
    v20 = *((_QWORD *)v19 + 1);
    *((_QWORD *)v19 + 1) = v18;
    v30 = v20;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v19);
    v17 = v29;
    goto LABEL_9;
  }
  v7 = (uint64_t *)*((_QWORD *)v5 + 1);
  v8 = v7[1];
  v9 = v7[2];
  if (v8 >= v9)
  {
    v21 = (uint64_t)(v8 - *v7) >> 4;
    if ((unint64_t)(v21 + 1) >> 60)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v22 = v9 - *v7;
    v23 = v22 >> 3;
    if (v22 >> 3 <= (unint64_t)(v21 + 1))
      v23 = v21 + 1;
    if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF0)
      v24 = 0xFFFFFFFFFFFFFFFLL;
    else
      v24 = v23;
    v33[4] = v7 + 2;
    v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>(v24);
    v26 = (uint64_t)&v25[16 * v21];
    v33[0] = v25;
    v33[1] = v26;
    v33[3] = &v25[16 * v27];
    *(_QWORD *)(v26 + 8) = 0;
    v28 = *a2;
    *(_BYTE *)v26 = 7;
    *(_QWORD *)(v26 + 8) = v28;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v26);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v26);
    v33[2] = v26 + 16;
    std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::__swap_out_circular_buffer(v7, v33);
    v11 = v7[1];
    std::__split_buffer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::~__split_buffer((uint64_t)v33);
  }
  else
  {
    *(_QWORD *)(v8 + 8) = 0;
    v10 = *a2;
    *(_BYTE *)v8 = 7;
    *(_QWORD *)(v8 + 8) = v10;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v8);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v8);
    v11 = v8 + 16;
  }
  v7[1] = v11;
}

void nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<BOOL &>(unsigned __int8 **a1, unsigned __int8 *a2)
{
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  int v6;
  uint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t **v12;
  uint64_t v13;
  unsigned __int8 *v14;
  int v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  unsigned __int8 *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char v29[8];
  uint64_t v30;
  char v31[8];
  uint64_t v32;
  _QWORD v33[5];

  v4 = a1[2];
  if (a1[1] == v4)
  {
    v12 = (uint64_t **)&v32;
    v13 = *a2;
    v31[0] = 4;
    v32 = v13;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v31);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v31);
    v14 = *a1;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v31);
    v15 = *v14;
    *v14 = 4;
    v31[0] = v15;
    v16 = *((_QWORD *)v14 + 1);
    *((_QWORD *)v14 + 1) = v13;
    v32 = v16;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v14);
    v17 = v31;
LABEL_9:
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v17);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(v12, v15);
    return;
  }
  v5 = (unsigned __int8 *)*((_QWORD *)v4 - 1);
  v6 = *v5;
  if (v6 != 2)
  {
    if (v6 != 1)
      __assert_rtn("handle_value", "json_sax.hpp", 312, "ref_stack.back()->is_array() or ref_stack.back()->is_object()");
    if (!a1[4])
      __assert_rtn("handle_value", "json_sax.hpp", 321, "object_element");
    v12 = (uint64_t **)&v30;
    v18 = *a2;
    v29[0] = 4;
    v30 = v18;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v29);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v29);
    v19 = a1[4];
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v29);
    v15 = *v19;
    *v19 = 4;
    v29[0] = v15;
    v20 = *((_QWORD *)v19 + 1);
    *((_QWORD *)v19 + 1) = v18;
    v30 = v20;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v19);
    v17 = v29;
    goto LABEL_9;
  }
  v7 = (uint64_t *)*((_QWORD *)v5 + 1);
  v8 = v7[1];
  v9 = v7[2];
  if (v8 >= v9)
  {
    v21 = (uint64_t)(v8 - *v7) >> 4;
    if ((unint64_t)(v21 + 1) >> 60)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v22 = v9 - *v7;
    v23 = v22 >> 3;
    if (v22 >> 3 <= (unint64_t)(v21 + 1))
      v23 = v21 + 1;
    if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF0)
      v24 = 0xFFFFFFFFFFFFFFFLL;
    else
      v24 = v23;
    v33[4] = v7 + 2;
    v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>(v24);
    v26 = (uint64_t)&v25[16 * v21];
    v33[0] = v25;
    v33[1] = v26;
    v33[3] = &v25[16 * v27];
    *(_QWORD *)(v26 + 8) = 0;
    v28 = *a2;
    *(_BYTE *)v26 = 4;
    *(_QWORD *)(v26 + 8) = v28;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v26);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v26);
    v33[2] = v26 + 16;
    std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::__swap_out_circular_buffer(v7, v33);
    v11 = v7[1];
    std::__split_buffer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::~__split_buffer((uint64_t)v33);
  }
  else
  {
    *(_QWORD *)(v8 + 8) = 0;
    v10 = *a2;
    *(_BYTE *)v8 = 4;
    *(_QWORD *)(v8 + 8) = v10;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v8);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v8);
    v11 = v8 + 16;
  }
  v7[1] = v11;
}

void nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<decltype(nullptr)>(unsigned __int8 **a1)
{
  unsigned __int8 *v2;
  unsigned __int8 *v3;
  int v4;
  uint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t **v9;
  unsigned __int8 *v10;
  int v11;
  uint64_t v12;
  char *v13;
  unsigned __int8 *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  char v23[8];
  uint64_t v24;
  char v25[8];
  uint64_t v26;
  _QWORD v27[5];

  v2 = a1[2];
  if (a1[1] == v2)
  {
    v25[0] = 0;
    v9 = (uint64_t **)&v26;
    v26 = 0;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v25);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v25);
    v10 = *a1;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v25);
    v11 = *v10;
    *v10 = 0;
    v25[0] = v11;
    v12 = *((_QWORD *)v10 + 1);
    *((_QWORD *)v10 + 1) = 0;
    v26 = v12;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v10);
    v13 = v25;
LABEL_9:
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v13);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(v9, v11);
    return;
  }
  v3 = (unsigned __int8 *)*((_QWORD *)v2 - 1);
  v4 = *v3;
  if (v4 != 2)
  {
    if (v4 != 1)
      __assert_rtn("handle_value", "json_sax.hpp", 312, "ref_stack.back()->is_array() or ref_stack.back()->is_object()");
    if (!a1[4])
      __assert_rtn("handle_value", "json_sax.hpp", 321, "object_element");
    v23[0] = 0;
    v9 = (uint64_t **)&v24;
    v24 = 0;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v23);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v23);
    v14 = a1[4];
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v23);
    v11 = *v14;
    *v14 = 0;
    v23[0] = v11;
    v15 = *((_QWORD *)v14 + 1);
    *((_QWORD *)v14 + 1) = 0;
    v24 = v15;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v14);
    v13 = v23;
    goto LABEL_9;
  }
  v5 = (uint64_t *)*((_QWORD *)v3 + 1);
  v6 = v5[1];
  v7 = v5[2];
  if (v6 >= v7)
  {
    v16 = (uint64_t)(v6 - *v5) >> 4;
    if ((unint64_t)(v16 + 1) >> 60)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v17 = v7 - *v5;
    v18 = v17 >> 3;
    if (v17 >> 3 <= (unint64_t)(v16 + 1))
      v18 = v16 + 1;
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF0)
      v19 = 0xFFFFFFFFFFFFFFFLL;
    else
      v19 = v18;
    v27[4] = v5 + 2;
    v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>(v19);
    v21 = (uint64_t)&v20[16 * v16];
    v27[0] = v20;
    v27[1] = v21;
    v27[3] = &v20[16 * v22];
    *(_BYTE *)v21 = 0;
    *(_QWORD *)(v21 + 8) = 0;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v21);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v21);
    v27[2] = v21 + 16;
    std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::__swap_out_circular_buffer(v5, v27);
    v8 = v5[1];
    std::__split_buffer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::~__split_buffer((uint64_t)v27);
  }
  else
  {
    *(_BYTE *)v6 = 0;
    *(_QWORD *)(v6 + 8) = 0;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v6);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v6);
    v8 = v6 + 16;
  }
  v5[1] = v8;
}

void nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<long long &>(unsigned __int8 **a1, uint64_t *a2)
{
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  int v6;
  uint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t **v12;
  uint64_t v13;
  unsigned __int8 *v14;
  int v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  unsigned __int8 *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char v29[8];
  uint64_t v30;
  char v31[8];
  uint64_t v32;
  _QWORD v33[5];

  v4 = a1[2];
  if (a1[1] == v4)
  {
    v12 = (uint64_t **)&v32;
    v13 = *a2;
    v31[0] = 5;
    v32 = v13;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v31);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v31);
    v14 = *a1;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v31);
    v15 = *v14;
    *v14 = 5;
    v31[0] = v15;
    v16 = *((_QWORD *)v14 + 1);
    *((_QWORD *)v14 + 1) = v13;
    v32 = v16;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v14);
    v17 = v31;
LABEL_9:
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v17);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(v12, v15);
    return;
  }
  v5 = (unsigned __int8 *)*((_QWORD *)v4 - 1);
  v6 = *v5;
  if (v6 != 2)
  {
    if (v6 != 1)
      __assert_rtn("handle_value", "json_sax.hpp", 312, "ref_stack.back()->is_array() or ref_stack.back()->is_object()");
    if (!a1[4])
      __assert_rtn("handle_value", "json_sax.hpp", 321, "object_element");
    v12 = (uint64_t **)&v30;
    v18 = *a2;
    v29[0] = 5;
    v30 = v18;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v29);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v29);
    v19 = a1[4];
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v29);
    v15 = *v19;
    *v19 = 5;
    v29[0] = v15;
    v20 = *((_QWORD *)v19 + 1);
    *((_QWORD *)v19 + 1) = v18;
    v30 = v20;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v19);
    v17 = v29;
    goto LABEL_9;
  }
  v7 = (uint64_t *)*((_QWORD *)v5 + 1);
  v8 = v7[1];
  v9 = v7[2];
  if (v8 >= v9)
  {
    v21 = (uint64_t)(v8 - *v7) >> 4;
    if ((unint64_t)(v21 + 1) >> 60)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v22 = v9 - *v7;
    v23 = v22 >> 3;
    if (v22 >> 3 <= (unint64_t)(v21 + 1))
      v23 = v21 + 1;
    if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF0)
      v24 = 0xFFFFFFFFFFFFFFFLL;
    else
      v24 = v23;
    v33[4] = v7 + 2;
    v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>(v24);
    v26 = (uint64_t)&v25[16 * v21];
    v33[0] = v25;
    v33[1] = v26;
    v33[3] = &v25[16 * v27];
    *(_QWORD *)(v26 + 8) = 0;
    v28 = *a2;
    *(_BYTE *)v26 = 5;
    *(_QWORD *)(v26 + 8) = v28;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v26);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v26);
    v33[2] = v26 + 16;
    std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::__swap_out_circular_buffer(v7, v33);
    v11 = v7[1];
    std::__split_buffer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::~__split_buffer((uint64_t)v33);
  }
  else
  {
    *(_QWORD *)(v8 + 8) = 0;
    v10 = *a2;
    *(_BYTE *)v8 = 5;
    *(_QWORD *)(v8 + 8) = v10;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v8);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v8);
    v11 = v8 + 16;
  }
  v7[1] = v11;
}

void nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<std::string&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  unsigned __int8 *v5;
  int v6;
  uint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  uint64_t **v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  _BYTE v24[8];
  uint64_t v25;
  _BYTE v26[8];
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t *v32;

  v4 = a1[2];
  if (a1[1] == v4)
  {
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::basic_json<std::string&,std::string,0>((uint64_t)v26, a2);
    v11 = *a1;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v26);
    v12 = *(_BYTE *)v11;
    *(_BYTE *)v11 = v26[0];
    v26[0] = v12;
    v13 = (uint64_t **)&v27;
    v14 = *(_QWORD *)(v11 + 8);
    *(_QWORD *)(v11 + 8) = v27;
    v27 = v14;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v11);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v26);
    v15 = v26[0];
LABEL_9:
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(v13, v15);
    return;
  }
  v5 = *(unsigned __int8 **)(v4 - 8);
  v6 = *v5;
  if (v6 != 2)
  {
    if (v6 != 1)
      __assert_rtn("handle_value", "json_sax.hpp", 312, "ref_stack.back()->is_array() or ref_stack.back()->is_object()");
    if (!a1[4])
      __assert_rtn("handle_value", "json_sax.hpp", 321, "object_element");
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::basic_json<std::string&,std::string,0>((uint64_t)v24, a2);
    v16 = a1[4];
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v24);
    v17 = *(_BYTE *)v16;
    *(_BYTE *)v16 = v24[0];
    v24[0] = v17;
    v13 = (uint64_t **)&v25;
    v18 = *(_QWORD *)(v16 + 8);
    *(_QWORD *)(v16 + 8) = v25;
    v25 = v18;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v16);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v24);
    v15 = v24[0];
    goto LABEL_9;
  }
  v7 = (uint64_t *)*((_QWORD *)v5 + 1);
  v8 = v7[1];
  v9 = v7[2];
  if (v8 >= v9)
  {
    v19 = (uint64_t)(v8 - *v7) >> 4;
    if ((unint64_t)(v19 + 1) >> 60)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v20 = v9 - *v7;
    v21 = v20 >> 3;
    if (v20 >> 3 <= (unint64_t)(v19 + 1))
      v21 = v19 + 1;
    if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF0)
      v22 = 0xFFFFFFFFFFFFFFFLL;
    else
      v22 = v21;
    v32 = v7 + 2;
    if (v22)
      v22 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>(v22);
    else
      v23 = 0;
    v28 = v22;
    v29 = v22 + 16 * v19;
    v31 = v22 + 16 * v23;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::basic_json<std::string&,std::string,0>(v29, a2);
    v30 = v29 + 16;
    std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::__swap_out_circular_buffer(v7, &v28);
    v10 = v7[1];
    std::__split_buffer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::~__split_buffer((uint64_t)&v28);
  }
  else
  {
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::basic_json<std::string&,std::string,0>(v7[1], a2);
    v10 = v8 + 16;
    v7[1] = v8 + 16;
  }
  v7[1] = v10;
}

void sub_1D4EC8CF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  std::__split_buffer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<unsigned long long &>(unsigned __int8 **a1, uint64_t *a2)
{
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  int v6;
  uint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t **v12;
  uint64_t v13;
  unsigned __int8 *v14;
  int v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  unsigned __int8 *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char v29[8];
  uint64_t v30;
  char v31[8];
  uint64_t v32;
  _QWORD v33[5];

  v4 = a1[2];
  if (a1[1] == v4)
  {
    v12 = (uint64_t **)&v32;
    v13 = *a2;
    v31[0] = 6;
    v32 = v13;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v31);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v31);
    v14 = *a1;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v31);
    v15 = *v14;
    *v14 = 6;
    v31[0] = v15;
    v16 = *((_QWORD *)v14 + 1);
    *((_QWORD *)v14 + 1) = v13;
    v32 = v16;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v14);
    v17 = v31;
LABEL_9:
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v17);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(v12, v15);
    return;
  }
  v5 = (unsigned __int8 *)*((_QWORD *)v4 - 1);
  v6 = *v5;
  if (v6 != 2)
  {
    if (v6 != 1)
      __assert_rtn("handle_value", "json_sax.hpp", 312, "ref_stack.back()->is_array() or ref_stack.back()->is_object()");
    if (!a1[4])
      __assert_rtn("handle_value", "json_sax.hpp", 321, "object_element");
    v12 = (uint64_t **)&v30;
    v18 = *a2;
    v29[0] = 6;
    v30 = v18;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v29);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v29);
    v19 = a1[4];
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v29);
    v15 = *v19;
    *v19 = 6;
    v29[0] = v15;
    v20 = *((_QWORD *)v19 + 1);
    *((_QWORD *)v19 + 1) = v18;
    v30 = v20;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v19);
    v17 = v29;
    goto LABEL_9;
  }
  v7 = (uint64_t *)*((_QWORD *)v5 + 1);
  v8 = v7[1];
  v9 = v7[2];
  if (v8 >= v9)
  {
    v21 = (uint64_t)(v8 - *v7) >> 4;
    if ((unint64_t)(v21 + 1) >> 60)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v22 = v9 - *v7;
    v23 = v22 >> 3;
    if (v22 >> 3 <= (unint64_t)(v21 + 1))
      v23 = v21 + 1;
    if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF0)
      v24 = 0xFFFFFFFFFFFFFFFLL;
    else
      v24 = v23;
    v33[4] = v7 + 2;
    v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>(v24);
    v26 = (uint64_t)&v25[16 * v21];
    v33[0] = v25;
    v33[1] = v26;
    v33[3] = &v25[16 * v27];
    *(_QWORD *)(v26 + 8) = 0;
    v28 = *a2;
    *(_BYTE *)v26 = 6;
    *(_QWORD *)(v26 + 8) = v28;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v26);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v26);
    v33[2] = v26 + 16;
    std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::__swap_out_circular_buffer(v7, v33);
    v11 = v7[1];
    std::__split_buffer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::~__split_buffer((uint64_t)v33);
  }
  else
  {
    *(_QWORD *)(v8 + 8) = 0;
    v10 = *a2;
    *(_BYTE *)v8 = 6;
    *(_QWORD *)(v8 + 8) = v10;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v8);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v8);
    v11 = v8 + 16;
  }
  v7[1] = v11;
}

uint64_t nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::basic_json<std::string&,std::string,0>(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a1 + 8) = 0;
  *(_BYTE *)a1 = 3;
  *(_QWORD *)(a1 + 8) = nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::create<std::string,std::string const&>(a2);
  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(a1);
  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(a1);
  return a1;
}

std::string *nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::create<std::string,std::string const&>(uint64_t a1)
{
  std::string *v2;
  std::string *v3;

  v2 = (std::string *)operator new(0x18uLL);
  v3 = v2;
  if (*(char *)(a1 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v2, *(const std::string::value_type **)a1, *(_QWORD *)(a1 + 8));
  }
  else
  {
    *(_OWORD *)&v2->__r_.__value_.__l.__data_ = *(_OWORD *)a1;
    v2->__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 16);
  }
  return v3;
}

void sub_1D4EC8FF8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<nlohmann::detail::value_t>(uint64_t *a1, char *a2)
{
  uint64_t v4;
  unsigned __int8 *v5;
  int v6;
  uint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  int v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  unsigned __int8 v14;
  uint64_t *v15;
  int v17;
  uint64_t v18;
  unsigned __int8 v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  char v28[8];
  uint64_t *v29;
  char v30[8];
  uint64_t *v31;
  _QWORD v32[2];
  uint64_t v33;
  unint64_t v34;
  uint64_t *v35;

  v4 = a1[2];
  if (a1[1] == v4)
  {
    v12 = *a2;
    v30[0] = *a2;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::json_value(&v31, v12);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v30);
    v13 = *a1;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v30);
    v14 = *(_BYTE *)v13;
    *(_BYTE *)v13 = v30[0];
    v30[0] = v14;
    v15 = *(uint64_t **)(v13 + 8);
    *(_QWORD *)(v13 + 8) = v31;
    v31 = v15;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v13);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v30);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(&v31, v30[0]);
    return *a1;
  }
  else
  {
    v5 = *(unsigned __int8 **)(v4 - 8);
    v6 = *v5;
    if (v6 == 2)
    {
      v7 = (uint64_t *)*((_QWORD *)v5 + 1);
      v8 = v7[1];
      v9 = v7[2];
      if (v8 >= v9)
      {
        v21 = (uint64_t)(v8 - *v7) >> 4;
        if ((unint64_t)(v21 + 1) >> 60)
          std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
        v22 = v9 - *v7;
        v23 = v22 >> 3;
        if (v22 >> 3 <= (unint64_t)(v21 + 1))
          v23 = v21 + 1;
        if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF0)
          v24 = 0xFFFFFFFFFFFFFFFLL;
        else
          v24 = v23;
        v35 = v7 + 2;
        if (v24)
          v24 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>(v24);
        else
          v25 = 0;
        v26 = v24 + 16 * v21;
        v32[0] = v24;
        v32[1] = v26;
        v33 = v26;
        v34 = v24 + 16 * v25;
        v27 = *a2;
        *(_BYTE *)v26 = v27;
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::json_value((_QWORD *)(v26 + 8), v27);
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v26);
        v33 += 16;
        std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::__swap_out_circular_buffer(v7, v32);
        v11 = v7[1];
        std::__split_buffer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::~__split_buffer((uint64_t)v32);
      }
      else
      {
        v10 = *a2;
        *(_BYTE *)v8 = v10;
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::json_value((_QWORD *)(v8 + 8), v10);
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v8);
        v11 = v8 + 16;
        v7[1] = v8 + 16;
      }
      v7[1] = v11;
      return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1[2] - 8) + 8) + 8) - 16;
    }
    else
    {
      if (v6 != 1)
        __assert_rtn("handle_value", "json_sax.hpp", 312, "ref_stack.back()->is_array() or ref_stack.back()->is_object()");
      if (!a1[4])
        __assert_rtn("handle_value", "json_sax.hpp", 321, "object_element");
      v17 = *a2;
      v28[0] = *a2;
      nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::json_value(&v29, v17);
      nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v28);
      v18 = a1[4];
      nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v28);
      v19 = *(_BYTE *)v18;
      *(_BYTE *)v18 = v28[0];
      v28[0] = v19;
      v20 = *(uint64_t **)(v18 + 8);
      *(_QWORD *)(v18 + 8) = v29;
      v29 = v20;
      nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v18);
      nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v28);
      nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(&v29, v28[0]);
      return a1[4];
    }
  }
}

void sub_1D4EC9278(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  std::__split_buffer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

_QWORD *nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::json_value(_QWORD *a1, int a2)
{
  _QWORD *v3;
  _QWORD *v4;

  switch(a2)
  {
    case 1:
      v3 = operator new(0x18uLL);
      v3[2] = 0;
      v3[1] = 0;
      *v3 = v3 + 1;
      goto LABEL_8;
    case 2:
      v3 = operator new(0x18uLL);
      v3[1] = 0;
      v3[2] = 0;
      *v3 = 0;
      goto LABEL_8;
    case 3:
      v4 = operator new(0x18uLL);
      std::string::basic_string[abi:ne180100]<0>(v4, "");
      *a1 = v4;
      return a1;
    case 4:
      *(_BYTE *)a1 = 0;
      return a1;
    case 8:
      v3 = operator new(0x20uLL);
      v3[1] = 0;
      v3[2] = 0;
      *v3 = 0;
      *((_WORD *)v3 + 12) = 0;
LABEL_8:
      *a1 = v3;
      break;
    default:
      *a1 = 0;
      break;
  }
  return a1;
}

void sub_1D4EC9354(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__tree<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::__map_value_compare<std::string,std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::less<void>,true>,std::allocator<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>>::__find_equal<std::string>(uint64_t a1, _QWORD *a2, void **a3)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v7;
  _QWORD *v8;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        v7 = v4;
        v8 = v4 + 4;
        if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(a3, (void **)v4 + 4) & 0x80) == 0)
          break;
        v4 = (_QWORD *)*v7;
        v5 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v8, a3) & 0x80) == 0)
        break;
      v5 = v7 + 1;
      v4 = (_QWORD *)v7[1];
    }
    while (v4);
  }
  else
  {
    v7 = (_QWORD *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

uint64_t *std::__tree<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::__map_value_compare<std::string,std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::less<void>,true>,std::allocator<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  uint64_t *v5;
  uint64_t *result;

  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,0>((uint64_t)v1 + 32);
    operator delete(v1);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,0>(uint64_t a1)
{
  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(a1 + 24);
  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy((uint64_t **)(a1 + 32), *(unsigned __int8 *)(a1 + 24));
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

uint64_t nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get(unsigned __int8 **a1)
{
  int v2;
  unsigned __int8 *v3;
  unint64_t v4;
  unsigned __int8 *v5;
  uint64_t v6;
  unint64_t v7;
  unsigned __int8 *v8;
  uint64_t v9;
  unint64_t v10;
  size_t v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  unsigned __int8 v15;
  uint64_t result;
  uint64_t v17;

  *(int64x2_t *)(a1 + 3) = vaddq_s64(*(int64x2_t *)(a1 + 3), vdupq_n_s64(1uLL));
  if (*((_BYTE *)a1 + 20))
  {
    *((_BYTE *)a1 + 20) = 0;
    v2 = *((_DWORD *)a1 + 4);
  }
  else
  {
    v3 = *a1;
    if (*a1 == a1[1])
    {
      v2 = -1;
    }
    else
    {
      v2 = *v3;
      *a1 = v3 + 1;
    }
    *((_DWORD *)a1 + 4) = v2;
  }
  if (v2 == -1)
    return 0xFFFFFFFFLL;
  v5 = a1[7];
  v4 = (unint64_t)a1[8];
  if ((unint64_t)v5 >= v4)
  {
    v7 = (unint64_t)a1[6];
    v8 = &v5[-v7];
    v9 = (uint64_t)&v5[-v7 + 1];
    if (v9 < 0)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v10 = v4 - v7;
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x3FFFFFFFFFFFFFFFLL)
      v11 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v11 = v9;
    if (v11)
      v12 = (unsigned __int8 *)operator new(v11);
    else
      v12 = 0;
    v13 = &v12[v11];
    v8[(_QWORD)v12] = v2;
    v6 = (uint64_t)&v8[(_QWORD)v12 + 1];
    if (v5 == (unsigned __int8 *)v7)
    {
      v12 = &v8[(_QWORD)v12];
    }
    else
    {
      v14 = &v5[~v7];
      do
      {
        v15 = *--v5;
        (v14--)[(_QWORD)v12] = v15;
      }
      while (v5 != (unsigned __int8 *)v7);
      v5 = a1[6];
    }
    a1[6] = v12;
    a1[7] = (unsigned __int8 *)v6;
    a1[8] = v13;
    if (v5)
      operator delete(v5);
  }
  else
  {
    *v5 = v2;
    v6 = (uint64_t)(v5 + 1);
  }
  a1[7] = (unsigned __int8 *)v6;
  result = *((unsigned int *)a1 + 4);
  if ((_DWORD)result == 10)
  {
    v17 = (uint64_t)(a1[5] + 1);
    a1[4] = 0;
    a1[5] = (unsigned __int8 *)v17;
  }
  return result;
}

uint64_t nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::scan_literal(uint64_t a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4)
{
  unsigned __int8 *v6;
  uint64_t v7;
  unsigned __int8 v8;
  int v9;

  if (*a2 != *(unsigned __int8 *)(a1 + 16))
    __assert_rtn("scan_literal", "lexer.hpp", 1222, "char_traits<char_type>::to_char_type(current) == literal_text[0]");
  v6 = a2 + 1;
  v7 = a3 - 1;
  while (1)
  {
    v8 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get((unsigned __int8 **)a1);
    v9 = *v6++;
    if (v9 != v8)
      break;
    if (!--v7)
      return a4;
  }
  *(_QWORD *)(a1 + 96) = "invalid literal";
  return 14;
}

void nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::reset(uint64_t a1)
{
  _BYTE *v2;
  int v3;
  unint64_t v4;
  _BYTE *v5;
  unint64_t v6;
  uint64_t v7;
  size_t v8;
  _BYTE *v9;

  if (*(char *)(a1 + 95) < 0)
  {
    **(_BYTE **)(a1 + 72) = 0;
    *(_QWORD *)(a1 + 80) = 0;
  }
  else
  {
    *(_BYTE *)(a1 + 72) = 0;
    *(_BYTE *)(a1 + 95) = 0;
  }
  v2 = *(_BYTE **)(a1 + 48);
  *(_QWORD *)(a1 + 56) = v2;
  v3 = *(_DWORD *)(a1 + 16);
  v4 = *(_QWORD *)(a1 + 64);
  if ((unint64_t)v2 >= v4)
  {
    v6 = v4 - (_QWORD)v2;
    v7 = 2 * v6;
    if (2 * v6 <= 1)
      v7 = 1;
    if (v6 >= 0x3FFFFFFFFFFFFFFFLL)
      v8 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v8 = v7;
    v9 = operator new(v8);
    *v9 = v3;
    v5 = v9 + 1;
    *(_QWORD *)(a1 + 48) = v9;
    *(_QWORD *)(a1 + 56) = v9 + 1;
    *(_QWORD *)(a1 + 64) = &v9[v8];
    if (v2)
      operator delete(v2);
  }
  else
  {
    *v2 = v3;
    v5 = v2 + 1;
  }
  *(_QWORD *)(a1 + 56) = v5;
}

uint64_t nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::unget(uint64_t result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  v1 = (_QWORD *)(result + 32);
  v2 = *(_QWORD *)(result + 32);
  *(_BYTE *)(result + 20) = 1;
  --*(_QWORD *)(result + 24);
  if (v2 || (v1 = (_QWORD *)(result + 40), (v2 = *(_QWORD *)(result + 40)) != 0))
    *v1 = v2 - 1;
  if (*(_DWORD *)(result + 16) != -1)
  {
    v3 = *(_QWORD *)(result + 56);
    if (*(_QWORD *)(result + 48) == v3)
      __assert_rtn("unget", "lexer.hpp", 1314, "not token_string.empty()");
    *(_QWORD *)(result + 56) = v3 - 1;
  }
  return result;
}

uint64_t nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get_codepoint(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  __int128 v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 16) != 117)
    __assert_rtn("get_codepoint", "lexer.hpp", 162, "current == 'u'");
  v2 = 0;
  LODWORD(v3) = 0;
  v8 = xmmword_1D4F18A90;
  do
  {
    v4 = *(_DWORD *)((char *)&v8 + v2);
    nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get((unsigned __int8 **)a1);
    v5 = *(_DWORD *)(a1 + 16);
    v6 = v5 - 48;
    if ((v5 - 48) >= 0xA)
    {
      if ((v5 - 65) > 5)
      {
        if ((v5 - 97) > 5)
          return 0xFFFFFFFFLL;
        v6 = v5 - 87;
      }
      else
      {
        v6 = v5 - 55;
      }
    }
    v3 = ((v6 << v4) + v3);
    v2 += 4;
  }
  while (v2 != 16);
  if (v3 >= 0x10000)
    __assert_rtn("get_codepoint", "lexer.hpp", 188, "0x0000 <= codepoint and codepoint <= 0xFFFF");
  return v3;
}

uint64_t nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::next_byte_in_range(std::string *a1, _DWORD *a2, unint64_t a3)
{
  std::string *v6;
  _DWORD *v7;
  int v8;
  uint64_t result;

  if (a3 > 6 || ((1 << a3) & 0x54) == 0)
    __assert_rtn("next_byte_in_range", "lexer.hpp", 209, "ranges.size() == 2 or ranges.size() == 4 or ranges.size() == 6");
  v6 = a1 + 3;
  std::string::push_back(a1 + 3, a1->__r_.__value_.__s.__data_[16]);
  v7 = &a2[a3];
  while (1)
  {
    nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<char const*>>::get((unsigned __int8 **)a1);
    v8 = a1->__r_.__value_.__r.__words[2];
    if (*a2 > v8 || v8 > a2[1])
      break;
    std::string::push_back(v6, v8);
    a2 += 2;
    if (a2 == v7)
      return 1;
  }
  result = 0;
  a1[4].__r_.__value_.__r.__words[0] = (std::string::size_type)"invalid string: ill-formed UTF-8 byte";
  return result;
}

void nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::start_object(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  unint64_t v14;
  char *v15;
  char *v16;
  uint64_t v17;
  char v18;

  v18 = std::function<BOOL ()(int,nlohmann::detail::parse_event_t,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> &)>::operator()(a1[15], (unint64_t)(a1[2] - a1[1]) >> 3, 0);
  std::vector<BOOL>::push_back((uint64_t)(a1 + 4), &v18);
  v2 = nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<nlohmann::detail::value_t>(a1, 1u);
  v3 = v2;
  v5 = (uint64_t *)a1[2];
  v4 = a1[3];
  if ((unint64_t)v5 >= v4)
  {
    v7 = a1[1];
    v8 = ((uint64_t)v5 - v7) >> 3;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v9 = v4 - v7;
    v10 = v9 >> 2;
    if (v9 >> 2 <= (unint64_t)(v8 + 1))
      v10 = v8 + 1;
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    if (v11)
      v11 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v11);
    else
      v12 = 0;
    v13 = (uint64_t *)(v11 + 8 * v8);
    v14 = v11 + 8 * v12;
    *v13 = v3;
    v6 = v13 + 1;
    v16 = (char *)a1[1];
    v15 = (char *)a1[2];
    if (v15 != v16)
    {
      do
      {
        v17 = *((_QWORD *)v15 - 1);
        v15 -= 8;
        *--v13 = v17;
      }
      while (v15 != v16);
      v15 = (char *)a1[1];
    }
    a1[1] = (uint64_t)v13;
    a1[2] = (uint64_t)v6;
    a1[3] = v14;
    if (v15)
      operator delete(v15);
  }
  else
  {
    *v5 = v2;
    v6 = v5 + 1;
  }
  a1[2] = (uint64_t)v6;
}

void nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::end_object(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 *v10;
  int v11;
  unsigned __int8 *v12;
  _QWORD *v13;
  unint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  int v17;
  int v18;
  unsigned __int8 *v19;
  int v20;
  int v21;
  char *v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  unsigned __int8 *v26;
  std::string::value_type v27;
  std::string::size_type size;
  uint64_t v29;
  int v30;
  std::string::size_type v31;
  void *v32;
  _QWORD *v33;
  _QWORD *v34;
  _QWORD *v35;
  _QWORD *v36;
  BOOL v37;
  uint64_t *v38;
  nlohmann::detail::exception *exception;
  nlohmann::detail::exception *v40;
  nlohmann::detail::exception *v41;
  nlohmann::detail::exception *v42;
  nlohmann::detail::exception *v43;
  unsigned __int8 *v44;
  nlohmann::detail::exception *v45;
  unint64_t v46;
  char *v47;
  unsigned __int8 *v48[5];
  char v49[8];
  uint64_t *v50;
  std::string v51;
  std::string v52;

  v2 = a1[2];
  if (*(_QWORD *)(v2 - 8)
    && (std::function<BOOL ()(int,nlohmann::detail::parse_event_t,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> &)>::operator()(a1[15], ((unint64_t)(v2 - a1[1]) >> 3) - 1, 1) & 1) == 0)
  {
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::basic_json((uint64_t)v49, (uint64_t)(a1 + 17));
    v3 = *(_QWORD *)(a1[2] - 8);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v49);
    v4 = *(_BYTE *)v3;
    *(_BYTE *)v3 = v49[0];
    v49[0] = v4;
    v5 = *(uint64_t **)(v3 + 8);
    *(_QWORD *)(v3 + 8) = v50;
    v50 = v5;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v3);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v49);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(&v50, v49[0]);
  }
  v7 = a1[1];
  v6 = a1[2];
  if (v7 == v6)
    __assert_rtn("end_object", "json_sax.hpp", 450, "not ref_stack.empty()");
  v8 = a1[5];
  if (!v8)
    __assert_rtn("end_object", "json_sax.hpp", 451, "not keep_stack.empty()");
  v9 = v6 - 8;
  a1[2] = v6 - 8;
  a1[5] = v8 - 1;
  if (v7 == v6 - 8)
    return;
  v10 = *(unsigned __int8 **)(v6 - 16);
  if (!v10)
    return;
  v11 = *v10;
  if ((v11 - 1) > 1)
    return;
  if (*v10)
  {
    if (v11 == 2)
    {
      v13 = 0;
      v12 = (unsigned __int8 *)**((_QWORD **)v10 + 1);
      v14 = 0x8000000000000000;
    }
    else if (v11 == 1)
    {
      v12 = 0;
      v13 = (_QWORD *)**((_QWORD **)v10 + 1);
      v14 = 0x8000000000000000;
    }
    else
    {
      v14 = 0;
      v12 = 0;
      v13 = 0;
    }
  }
  else
  {
    v12 = 0;
    v13 = 0;
    v14 = 1;
  }
  while (1)
  {
    nlohmann::detail::iter_impl<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::iter_impl(v48, *(_QWORD *)(v9 - 8));
    nlohmann::detail::iter_impl<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::set_end(v48);
    if (v10 != v48[0])
    {
      exception = (nlohmann::detail::exception *)__cxa_allocate_exception(0x20uLL);
      std::string::basic_string[abi:ne180100]<0>(&v52, "cannot compare iterators of different containers");
      nlohmann::detail::invalid_iterator::create(exception, 212, (uint64_t)&v52);
    }
    v17 = *v10;
    if (v17 == 1)
    {
      if (v13 == (_QWORD *)v48[1])
        return;
    }
    else if (v17 == 2)
    {
      if (v12 == v48[2])
        return;
    }
    else if ((unsigned __int8 *)v14 == v48[4])
    {
      return;
    }
    v18 = *v10;
    if (v18 == 2)
    {
      v19 = v12;
      if (v12 == *(unsigned __int8 **)(*((_QWORD *)v10 + 1) + 8))
        __assert_rtn("operator->", "iter_impl.hpp", 291, "m_it.array_iterator != m_object->m_value.array->end()");
      goto LABEL_39;
    }
    if (v18 == 1)
    {
      if (v13 == (_QWORD *)(*((_QWORD *)v10 + 1) + 8))
        __assert_rtn("operator->", "iter_impl.hpp", 285, "m_it.object_iterator != m_object->m_value.object->end()");
      v19 = (unsigned __int8 *)(v13 + 7);
LABEL_39:
      v20 = *v19;
      goto LABEL_41;
    }
    v20 = *v10;
    if (v14)
    {
      v40 = (nlohmann::detail::exception *)__cxa_allocate_exception(0x20uLL);
      std::string::basic_string[abi:ne180100]<0>(v48, "cannot get value");
      nlohmann::detail::invalid_iterator::create(v40, 214, (uint64_t)v48);
    }
LABEL_41:
    if (v20 == 9)
      break;
    if (v18 == 2)
    {
      v12 += 16;
    }
    else if (v18 == 1)
    {
      v15 = (_QWORD *)v13[1];
      if (v15)
      {
        do
        {
          v13 = v15;
          v15 = (_QWORD *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          v16 = v13;
          v13 = (_QWORD *)v13[2];
        }
        while ((_QWORD *)*v13 != v16);
      }
    }
    else
    {
      ++v14;
    }
    v9 = a1[2];
  }
  if (v10 != *(unsigned __int8 **)(a1[2] - 8))
  {
    v41 = (nlohmann::detail::exception *)__cxa_allocate_exception(0x20uLL);
    std::string::basic_string[abi:ne180100]<0>(&v52, "iterator does not fit current value");
    nlohmann::detail::invalid_iterator::create(v41, 202, (uint64_t)&v52);
  }
  nlohmann::detail::iter_impl<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::iter_impl(v48, (uint64_t)v10);
  nlohmann::detail::iter_impl<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::set_end(v48);
  v21 = *v10;
  if ((v21 - 3) >= 6)
  {
    if (v21 == 1)
    {
      v33 = (_QWORD *)*((_QWORD *)v10 + 1);
      v34 = (_QWORD *)v13[1];
      if (v34)
      {
        do
        {
          v35 = v34;
          v34 = (_QWORD *)*v34;
        }
        while (v34);
      }
      else
      {
        v36 = v13;
        do
        {
          v35 = (_QWORD *)v36[2];
          v37 = *v35 == (_QWORD)v36;
          v36 = v35;
        }
        while (!v37);
      }
      if ((_QWORD *)*v33 == v13)
        *v33 = v35;
      v38 = (uint64_t *)v33[1];
      --v33[2];
      std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v38, v13);
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,0>((uint64_t)(v13 + 4));
      operator delete(v13);
    }
    else
    {
      if (v21 != 2)
      {
        v43 = (nlohmann::detail::exception *)__cxa_allocate_exception(0x20uLL);
        v44 = v10;
        v45 = v43;
        v46 = *v44;
        if (v46 > 9)
          v47 = "number";
        else
          v47 = off_1E98BA368[v46];
        std::string::basic_string[abi:ne180100]<0>(&v51, v47);
        std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&v52, "cannot use erase() with ", &v51);
        nlohmann::detail::type_error::create(v45, 307, (uint64_t)&v52);
      }
      v24 = *((_QWORD *)v10 + 1);
      v25 = (uint64_t)(v12 + 16);
      v26 = *(unsigned __int8 **)(v24 + 8);
      if (v12 + 16 != v26)
      {
        do
        {
          v52.__r_.__value_.__s.__data_[0] = *(_BYTE *)v25;
          v27 = v52.__r_.__value_.__s.__data_[0];
          v52.__r_.__value_.__l.__size_ = *(_QWORD *)(v25 + 8);
          size = v52.__r_.__value_.__l.__size_;
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v25);
          *(_BYTE *)v25 = 0;
          *(_QWORD *)(v25 + 8) = 0;
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)&v52);
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)&v52);
          v30 = *(unsigned __int8 *)(v25 - 16);
          v29 = v25 - 16;
          *(_BYTE *)v29 = v27;
          v52.__r_.__value_.__s.__data_[0] = v30;
          v31 = *(_QWORD *)(v29 + 8);
          *(_QWORD *)(v29 + 8) = size;
          v52.__r_.__value_.__l.__size_ = v31;
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v29);
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)&v52);
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy((uint64_t **)&v52.__r_.__value_.__l.__size_, v30);
          v25 = v29 + 32;
        }
        while ((unsigned __int8 *)v25 != v26);
        v12 = (unsigned __int8 *)(v25 - 16);
      }
      std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::__base_destruct_at_end[abi:ne180100](v24, (uint64_t)v12);
    }
  }
  else
  {
    if (v14)
    {
      v42 = (nlohmann::detail::exception *)__cxa_allocate_exception(0x20uLL);
      std::string::basic_string[abi:ne180100]<0>(&v52, "iterator out of range");
      nlohmann::detail::invalid_iterator::create(v42, 205, (uint64_t)&v52);
    }
    if (v21 == 8)
    {
      v22 = (char *)*((_QWORD *)v10 + 1);
      v32 = *(void **)v22;
      if (*(_QWORD *)v22)
      {
        *((_QWORD *)v22 + 1) = v32;
        v23 = v32;
LABEL_57:
        operator delete(v23);
        v22 = (char *)*((_QWORD *)v10 + 1);
      }
LABEL_58:
      operator delete(v22);
      *((_QWORD *)v10 + 1) = 0;
    }
    else if (v21 == 3)
    {
      v22 = (char *)*((_QWORD *)v10 + 1);
      if (v22[23] < 0)
      {
        v23 = *(void **)v22;
        goto LABEL_57;
      }
      goto LABEL_58;
    }
    *v10 = 0;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v10);
  }
}

void sub_1D4ECA164(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  void *v31;
  char v32;

  if (a31 < 0)
    operator delete(__p);
  if (a25 < 0)
    operator delete(a20);
  if ((v32 & 1) != 0)
    __cxa_free_exception(v31);
  _Unwind_Resume(exception_object);
}

void nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::key(_QWORD *a1, __int128 *a2)
{
  int v4;
  uint64_t **v5;
  char *v6;
  char v7;
  uint64_t *v8;
  unsigned __int8 v9[8];
  uint64_t *v10;
  char v11;
  _BYTE v12[8];
  uint64_t *v13;
  __int128 *v14;

  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::basic_json<std::string&,std::string,0>((uint64_t)v12, (uint64_t)a2);
  v4 = std::function<BOOL ()(int,nlohmann::detail::parse_event_t,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> &)>::operator()(a1[15], (a1[2] - a1[1]) >> 3, 4);
  v11 = v4;
  std::vector<BOOL>::push_back((uint64_t)(a1 + 7), &v11);
  if (v4 && *(_QWORD *)(a1[2] - 8))
  {
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::basic_json((uint64_t)v9, (uint64_t)(a1 + 17));
    v5 = *(uint64_t ***)(*(_QWORD *)(a1[2] - 8) + 8);
    v14 = a2;
    v6 = std::__tree<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::__map_value_compare<std::string,std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::less<void>,true>,std::allocator<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v5, (void **)a2, &v14);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v9);
    v7 = v6[56];
    v6 += 56;
    *v6 = v9[0];
    v9[0] = v7;
    v8 = (uint64_t *)*((_QWORD *)v6 + 1);
    *((_QWORD *)v6 + 1) = v10;
    v10 = v8;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v6);
    a1[10] = v6;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v9);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(&v10, v9[0]);
  }
  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v12);
  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(&v13, v12[0]);
}

void sub_1D4ECA308(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t *a9, uint64_t a10, uint64_t a11, uint64_t *a12)
{
  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::~basic_json(&a9);
  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::~basic_json(&a12);
  _Unwind_Resume(a1);
}

void nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::start_array(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  unint64_t v14;
  char *v15;
  char *v16;
  uint64_t v17;
  char v18;

  v18 = std::function<BOOL ()(int,nlohmann::detail::parse_event_t,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> &)>::operator()(a1[15], (unint64_t)(a1[2] - a1[1]) >> 3, 2);
  std::vector<BOOL>::push_back((uint64_t)(a1 + 4), &v18);
  v2 = nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<nlohmann::detail::value_t>(a1, 2u);
  v3 = v2;
  v5 = (uint64_t *)a1[2];
  v4 = a1[3];
  if ((unint64_t)v5 >= v4)
  {
    v7 = a1[1];
    v8 = ((uint64_t)v5 - v7) >> 3;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v9 = v4 - v7;
    v10 = v9 >> 2;
    if (v9 >> 2 <= (unint64_t)(v8 + 1))
      v10 = v8 + 1;
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    if (v11)
      v11 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v11);
    else
      v12 = 0;
    v13 = (uint64_t *)(v11 + 8 * v8);
    v14 = v11 + 8 * v12;
    *v13 = v3;
    v6 = v13 + 1;
    v16 = (char *)a1[1];
    v15 = (char *)a1[2];
    if (v15 != v16)
    {
      do
      {
        v17 = *((_QWORD *)v15 - 1);
        v15 -= 8;
        *--v13 = v17;
      }
      while (v15 != v16);
      v15 = (char *)a1[1];
    }
    a1[1] = (uint64_t)v13;
    a1[2] = (uint64_t)v6;
    a1[3] = v14;
    if (v15)
      operator delete(v15);
  }
  else
  {
    *v5 = v2;
    v6 = v5 + 1;
  }
  a1[2] = (uint64_t)v6;
}

void nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::end_array(_QWORD *a1)
{
  uint64_t v2;
  char v3;
  uint64_t v4;
  char v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE v11[8];
  uint64_t *v12;

  v2 = a1[2];
  if (*(_QWORD *)(v2 - 8)
    && (std::function<BOOL ()(int,nlohmann::detail::parse_event_t,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> &)>::operator()(a1[15], ((unint64_t)(v2 - a1[1]) >> 3) - 1, 3) & 1) == 0)
  {
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::basic_json((uint64_t)v11, (uint64_t)(a1 + 17));
    v4 = *(_QWORD *)(a1[2] - 8);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v11);
    v5 = *(_BYTE *)v4;
    *(_BYTE *)v4 = v11[0];
    v11[0] = v5;
    v6 = *(uint64_t **)(v4 + 8);
    *(_QWORD *)(v4 + 8) = v12;
    v12 = v6;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v4);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v11);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(&v12, v11[0]);
    v3 = 0;
  }
  else
  {
    v3 = 1;
  }
  v8 = a1[1];
  v7 = a1[2];
  if (v8 == v7)
    __assert_rtn("end_array", "json_sax.hpp", 502, "not ref_stack.empty()");
  v9 = a1[5];
  if (!v9)
    __assert_rtn("end_array", "json_sax.hpp", 503, "not keep_stack.empty()");
  a1[2] = v7 - 8;
  a1[5] = v9 - 1;
  if (v8 == v7 - 8)
    v3 = 1;
  if ((v3 & 1) == 0)
  {
    v10 = *(_QWORD *)(v7 - 16);
    if (*(_BYTE *)v10 == 2)
      std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::__base_destruct_at_end[abi:ne180100](*(_QWORD *)(v10 + 8), *(_QWORD *)(*(_QWORD *)(v10 + 8) + 8) - 16);
  }
}

void nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<double &>(unsigned __int8 **a1, double a2)
{
  unsigned __int8 *v2;
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  int v6;
  uint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  unsigned __int8 v10;
  uint64_t **v11;
  uint64_t *v12;
  unsigned __int8 *v13;
  int v14;
  uint64_t *v15;
  char *v16;
  unsigned __int8 *v17;
  unsigned __int8 *v18;
  unint64_t v19;
  unsigned __int8 v20;
  uint64_t *v21;
  unsigned __int8 *v22;
  uint64_t *v23;
  const char *v24;
  int v25;
  char v26[8];
  uint64_t *v27;
  char v28[8];
  uint64_t *v29;
  unsigned __int8 v30[8];
  uint64_t *v31;

  v2 = a1[5];
  if (!v2)
    __assert_rtn("handle_value", "json_sax.hpp", 568, "not keep_stack.empty()");
  if (((*(_QWORD *)&a1[4][((unint64_t)(v2 - 1) >> 3) & 0x1FFFFFFFFFFFFFF8] >> (v2 - 1)) & 1) != 0)
  {
    v30[0] = 7;
    v31 = *(uint64_t **)&a2;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v30);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v30);
    if ((std::function<BOOL ()(int,nlohmann::detail::parse_event_t,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> &)>::operator()((uint64_t)a1[15], (unint64_t)(a1[2] - a1[1]) >> 3, 5) & 1) != 0)
    {
      v4 = a1[2];
      if (a1[1] == v4)
      {
        v10 = v30[0];
        v28[0] = v30[0];
        v11 = &v29;
        v12 = v31;
        v29 = v31;
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v30);
        v30[0] = 0;
        v31 = 0;
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v28);
        v13 = *a1;
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v28);
        v14 = *v13;
        *v13 = v10;
        v28[0] = v14;
        v15 = (uint64_t *)*((_QWORD *)v13 + 1);
        *((_QWORD *)v13 + 1) = v12;
        v29 = v15;
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v13);
        v16 = v28;
LABEL_15:
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v16);
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(v11, v14);
        goto LABEL_18;
      }
      v5 = (unsigned __int8 *)*((_QWORD *)v4 - 1);
      if (v5)
      {
        v6 = *v5;
        if (v6 == 2)
        {
          v7 = (uint64_t *)*((_QWORD *)v5 + 1);
          v8 = v7[1];
          if (v8 >= v7[2])
          {
            v9 = std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::__push_back_slow_path<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>(v7, (uint64_t)v30);
          }
          else
          {
            *(_BYTE *)v8 = v30[0];
            *(_QWORD *)(v8 + 8) = v31;
            nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v30);
            v30[0] = 0;
            v31 = 0;
            nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v8);
            v9 = v8 + 16;
          }
          v7[1] = v9;
          goto LABEL_18;
        }
        if (v6 == 1)
        {
          v17 = a1[8];
          if (v17)
          {
            v18 = v17 - 1;
            v19 = *(_QWORD *)&a1[7][((unint64_t)v18 >> 3) & 0x1FFFFFFFFFFFFFF8];
            a1[8] = v18;
            if (((v19 >> (char)v18) & 1) != 0)
            {
              if (!a1[10])
                __assert_rtn("handle_value", "json_sax.hpp", 624, "object_element");
              v20 = v30[0];
              v26[0] = v30[0];
              v11 = &v27;
              v21 = v31;
              v27 = v31;
              nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v30);
              v30[0] = 0;
              v31 = 0;
              nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v26);
              v22 = a1[10];
              nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v26);
              v14 = *v22;
              *v22 = v20;
              v26[0] = v14;
              v23 = (uint64_t *)*((_QWORD *)v22 + 1);
              *((_QWORD *)v22 + 1) = v21;
              v27 = v23;
              nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v22);
              v16 = v26;
              goto LABEL_15;
            }
            goto LABEL_18;
          }
          v24 = "not key_keep_stack.empty()";
          v25 = 615;
        }
        else
        {
          v24 = "ref_stack.back()->is_array() or ref_stack.back()->is_object()";
          v25 = 603;
        }
        __assert_rtn("handle_value", "json_sax.hpp", v25, v24);
      }
    }
LABEL_18:
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v30);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(&v31, v30[0]);
  }
}

void sub_1D4ECA834(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::~basic_json((uint64_t **)va);
  _Unwind_Resume(a1);
}

void nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<BOOL &>(unsigned __int8 **a1, unsigned __int8 a2)
{
  unsigned __int8 *v2;
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  int v6;
  uint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  unsigned __int8 v10;
  uint64_t **v11;
  uint64_t *v12;
  unsigned __int8 *v13;
  int v14;
  uint64_t *v15;
  char *v16;
  unsigned __int8 *v17;
  unsigned __int8 *v18;
  unint64_t v19;
  unsigned __int8 v20;
  uint64_t *v21;
  unsigned __int8 *v22;
  uint64_t *v23;
  const char *v24;
  int v25;
  char v26[8];
  uint64_t *v27;
  char v28[8];
  uint64_t *v29;
  unsigned __int8 v30[8];
  unint64_t v31;

  v2 = a1[5];
  if (!v2)
    __assert_rtn("handle_value", "json_sax.hpp", 568, "not keep_stack.empty()");
  if (((*(_QWORD *)&a1[4][((unint64_t)(v2 - 1) >> 3) & 0x1FFFFFFFFFFFFFF8] >> (v2 - 1)) & 1) != 0)
  {
    v30[0] = 4;
    v31 = a2;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v30);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v30);
    if ((std::function<BOOL ()(int,nlohmann::detail::parse_event_t,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> &)>::operator()((uint64_t)a1[15], (unint64_t)(a1[2] - a1[1]) >> 3, 5) & 1) != 0)
    {
      v4 = a1[2];
      if (a1[1] == v4)
      {
        v10 = v30[0];
        v28[0] = v30[0];
        v11 = &v29;
        v12 = (uint64_t *)v31;
        v29 = (uint64_t *)v31;
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v30);
        v30[0] = 0;
        v31 = 0;
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v28);
        v13 = *a1;
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v28);
        v14 = *v13;
        *v13 = v10;
        v28[0] = v14;
        v15 = (uint64_t *)*((_QWORD *)v13 + 1);
        *((_QWORD *)v13 + 1) = v12;
        v29 = v15;
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v13);
        v16 = v28;
LABEL_15:
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v16);
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(v11, v14);
        goto LABEL_18;
      }
      v5 = (unsigned __int8 *)*((_QWORD *)v4 - 1);
      if (v5)
      {
        v6 = *v5;
        if (v6 == 2)
        {
          v7 = (uint64_t *)*((_QWORD *)v5 + 1);
          v8 = v7[1];
          if (v8 >= v7[2])
          {
            v9 = std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::__push_back_slow_path<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>(v7, (uint64_t)v30);
          }
          else
          {
            *(_BYTE *)v8 = v30[0];
            *(_QWORD *)(v8 + 8) = v31;
            nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v30);
            v30[0] = 0;
            v31 = 0;
            nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v8);
            v9 = v8 + 16;
          }
          v7[1] = v9;
          goto LABEL_18;
        }
        if (v6 == 1)
        {
          v17 = a1[8];
          if (v17)
          {
            v18 = v17 - 1;
            v19 = *(_QWORD *)&a1[7][((unint64_t)v18 >> 3) & 0x1FFFFFFFFFFFFFF8];
            a1[8] = v18;
            if (((v19 >> (char)v18) & 1) != 0)
            {
              if (!a1[10])
                __assert_rtn("handle_value", "json_sax.hpp", 624, "object_element");
              v20 = v30[0];
              v26[0] = v30[0];
              v11 = &v27;
              v21 = (uint64_t *)v31;
              v27 = (uint64_t *)v31;
              nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v30);
              v30[0] = 0;
              v31 = 0;
              nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v26);
              v22 = a1[10];
              nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v26);
              v14 = *v22;
              *v22 = v20;
              v26[0] = v14;
              v23 = (uint64_t *)*((_QWORD *)v22 + 1);
              *((_QWORD *)v22 + 1) = v21;
              v27 = v23;
              nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v22);
              v16 = v26;
              goto LABEL_15;
            }
            goto LABEL_18;
          }
          v24 = "not key_keep_stack.empty()";
          v25 = 615;
        }
        else
        {
          v24 = "ref_stack.back()->is_array() or ref_stack.back()->is_object()";
          v25 = 603;
        }
        __assert_rtn("handle_value", "json_sax.hpp", v25, v24);
      }
    }
LABEL_18:
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v30);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy((uint64_t **)&v31, v30[0]);
  }
}

void sub_1D4ECAAF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::~basic_json((uint64_t **)va);
  _Unwind_Resume(a1);
}

void nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<decltype(nullptr)>(unsigned __int8 **a1)
{
  unsigned __int8 *v1;
  unsigned __int8 *v3;
  unsigned __int8 *v4;
  int v5;
  uint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  unsigned __int8 v9;
  uint64_t **v10;
  uint64_t *v11;
  unsigned __int8 *v12;
  int v13;
  uint64_t *v14;
  char *v15;
  unsigned __int8 *v16;
  unsigned __int8 *v17;
  unint64_t v18;
  unsigned __int8 v19;
  uint64_t *v20;
  unsigned __int8 *v21;
  uint64_t *v22;
  const char *v23;
  int v24;
  char v25[8];
  uint64_t *v26;
  char v27[8];
  uint64_t *v28;
  char v29[8];
  uint64_t *v30;

  v1 = a1[5];
  if (!v1)
    __assert_rtn("handle_value", "json_sax.hpp", 568, "not keep_stack.empty()");
  if (((*(_QWORD *)&a1[4][((unint64_t)(v1 - 1) >> 3) & 0x1FFFFFFFFFFFFFF8] >> (v1 - 1)) & 1) != 0)
  {
    v29[0] = 0;
    v30 = 0;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v29);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v29);
    if ((std::function<BOOL ()(int,nlohmann::detail::parse_event_t,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> &)>::operator()((uint64_t)a1[15], (unint64_t)(a1[2] - a1[1]) >> 3, 5) & 1) != 0)
    {
      v3 = a1[2];
      if (a1[1] == v3)
      {
        v9 = v29[0];
        v27[0] = v29[0];
        v10 = &v28;
        v11 = v30;
        v28 = v30;
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v29);
        v29[0] = 0;
        v30 = 0;
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v27);
        v12 = *a1;
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v27);
        v13 = *v12;
        *v12 = v9;
        v27[0] = v13;
        v14 = (uint64_t *)*((_QWORD *)v12 + 1);
        *((_QWORD *)v12 + 1) = v11;
        v28 = v14;
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v12);
        v15 = v27;
LABEL_15:
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v15);
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(v10, v13);
        goto LABEL_18;
      }
      v4 = (unsigned __int8 *)*((_QWORD *)v3 - 1);
      if (v4)
      {
        v5 = *v4;
        if (v5 == 2)
        {
          v6 = (uint64_t *)*((_QWORD *)v4 + 1);
          v7 = v6[1];
          if (v7 >= v6[2])
          {
            v8 = std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::__push_back_slow_path<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>(v6, (uint64_t)v29);
          }
          else
          {
            *(_BYTE *)v7 = v29[0];
            *(_QWORD *)(v7 + 8) = v30;
            nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v29);
            v29[0] = 0;
            v30 = 0;
            nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v7);
            v8 = v7 + 16;
          }
          v6[1] = v8;
          goto LABEL_18;
        }
        if (v5 == 1)
        {
          v16 = a1[8];
          if (v16)
          {
            v17 = v16 - 1;
            v18 = *(_QWORD *)&a1[7][((unint64_t)v17 >> 3) & 0x1FFFFFFFFFFFFFF8];
            a1[8] = v17;
            if (((v18 >> (char)v17) & 1) != 0)
            {
              if (!a1[10])
                __assert_rtn("handle_value", "json_sax.hpp", 624, "object_element");
              v19 = v29[0];
              v25[0] = v29[0];
              v10 = &v26;
              v20 = v30;
              v26 = v30;
              nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v29);
              v29[0] = 0;
              v30 = 0;
              nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v25);
              v21 = a1[10];
              nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v25);
              v13 = *v21;
              *v21 = v19;
              v25[0] = v13;
              v22 = (uint64_t *)*((_QWORD *)v21 + 1);
              *((_QWORD *)v21 + 1) = v20;
              v26 = v22;
              nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v21);
              v15 = v25;
              goto LABEL_15;
            }
            goto LABEL_18;
          }
          v23 = "not key_keep_stack.empty()";
          v24 = 615;
        }
        else
        {
          v23 = "ref_stack.back()->is_array() or ref_stack.back()->is_object()";
          v24 = 603;
        }
        __assert_rtn("handle_value", "json_sax.hpp", v24, v23);
      }
    }
LABEL_18:
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v29);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(&v30, v29[0]);
  }
}

void sub_1D4ECADB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::~basic_json((uint64_t **)va);
  _Unwind_Resume(a1);
}

void nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<long long &>(unsigned __int8 **a1, uint64_t *a2)
{
  unsigned __int8 *v2;
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  int v6;
  uint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  unsigned __int8 v10;
  uint64_t **v11;
  uint64_t *v12;
  unsigned __int8 *v13;
  int v14;
  uint64_t *v15;
  char *v16;
  unsigned __int8 *v17;
  unsigned __int8 *v18;
  unint64_t v19;
  unsigned __int8 v20;
  uint64_t *v21;
  unsigned __int8 *v22;
  uint64_t *v23;
  const char *v24;
  int v25;
  char v26[8];
  uint64_t *v27;
  char v28[8];
  uint64_t *v29;
  unsigned __int8 v30[8];
  uint64_t *v31;

  v2 = a1[5];
  if (!v2)
    __assert_rtn("handle_value", "json_sax.hpp", 568, "not keep_stack.empty()");
  if (((*(_QWORD *)&a1[4][((unint64_t)(v2 - 1) >> 3) & 0x1FFFFFFFFFFFFFF8] >> (v2 - 1)) & 1) != 0)
  {
    v30[0] = 5;
    v31 = a2;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v30);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v30);
    if ((std::function<BOOL ()(int,nlohmann::detail::parse_event_t,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> &)>::operator()((uint64_t)a1[15], (unint64_t)(a1[2] - a1[1]) >> 3, 5) & 1) != 0)
    {
      v4 = a1[2];
      if (a1[1] == v4)
      {
        v10 = v30[0];
        v28[0] = v30[0];
        v11 = &v29;
        v12 = v31;
        v29 = v31;
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v30);
        v30[0] = 0;
        v31 = 0;
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v28);
        v13 = *a1;
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v28);
        v14 = *v13;
        *v13 = v10;
        v28[0] = v14;
        v15 = (uint64_t *)*((_QWORD *)v13 + 1);
        *((_QWORD *)v13 + 1) = v12;
        v29 = v15;
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v13);
        v16 = v28;
LABEL_15:
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v16);
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(v11, v14);
        goto LABEL_18;
      }
      v5 = (unsigned __int8 *)*((_QWORD *)v4 - 1);
      if (v5)
      {
        v6 = *v5;
        if (v6 == 2)
        {
          v7 = (uint64_t *)*((_QWORD *)v5 + 1);
          v8 = v7[1];
          if (v8 >= v7[2])
          {
            v9 = std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::__push_back_slow_path<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>(v7, (uint64_t)v30);
          }
          else
          {
            *(_BYTE *)v8 = v30[0];
            *(_QWORD *)(v8 + 8) = v31;
            nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v30);
            v30[0] = 0;
            v31 = 0;
            nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v8);
            v9 = v8 + 16;
          }
          v7[1] = v9;
          goto LABEL_18;
        }
        if (v6 == 1)
        {
          v17 = a1[8];
          if (v17)
          {
            v18 = v17 - 1;
            v19 = *(_QWORD *)&a1[7][((unint64_t)v18 >> 3) & 0x1FFFFFFFFFFFFFF8];
            a1[8] = v18;
            if (((v19 >> (char)v18) & 1) != 0)
            {
              if (!a1[10])
                __assert_rtn("handle_value", "json_sax.hpp", 624, "object_element");
              v20 = v30[0];
              v26[0] = v30[0];
              v11 = &v27;
              v21 = v31;
              v27 = v31;
              nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v30);
              v30[0] = 0;
              v31 = 0;
              nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v26);
              v22 = a1[10];
              nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v26);
              v14 = *v22;
              *v22 = v20;
              v26[0] = v14;
              v23 = (uint64_t *)*((_QWORD *)v22 + 1);
              *((_QWORD *)v22 + 1) = v21;
              v27 = v23;
              nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v22);
              v16 = v26;
              goto LABEL_15;
            }
            goto LABEL_18;
          }
          v24 = "not key_keep_stack.empty()";
          v25 = 615;
        }
        else
        {
          v24 = "ref_stack.back()->is_array() or ref_stack.back()->is_object()";
          v25 = 603;
        }
        __assert_rtn("handle_value", "json_sax.hpp", v25, v24);
      }
    }
LABEL_18:
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v30);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(&v31, v30[0]);
  }
}

void sub_1D4ECB074(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::~basic_json((uint64_t **)va);
  _Unwind_Resume(a1);
}

void nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<std::string&>(unsigned __int8 **a1, uint64_t a2)
{
  unsigned __int8 *v2;
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  int v6;
  uint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  unsigned __int8 v10;
  uint64_t **v11;
  uint64_t *v12;
  unsigned __int8 *v13;
  int v14;
  uint64_t *v15;
  char *v16;
  unsigned __int8 *v17;
  unsigned __int8 *v18;
  unint64_t v19;
  unsigned __int8 v20;
  uint64_t *v21;
  unsigned __int8 *v22;
  uint64_t *v23;
  const char *v24;
  int v25;
  char v26[8];
  uint64_t *v27;
  char v28[8];
  uint64_t *v29;
  char v30[8];
  uint64_t *v31;

  v2 = a1[5];
  if (!v2)
    __assert_rtn("handle_value", "json_sax.hpp", 568, "not keep_stack.empty()");
  if (((*(_QWORD *)&a1[4][((unint64_t)(v2 - 1) >> 3) & 0x1FFFFFFFFFFFFFF8] >> (v2 - 1)) & 1) != 0)
  {
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::basic_json<std::string&,std::string,0>((uint64_t)v30, a2);
    if ((std::function<BOOL ()(int,nlohmann::detail::parse_event_t,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> &)>::operator()((uint64_t)a1[15], (unint64_t)(a1[2] - a1[1]) >> 3, 5) & 1) != 0)
    {
      v4 = a1[2];
      if (a1[1] == v4)
      {
        v10 = v30[0];
        v28[0] = v30[0];
        v11 = &v29;
        v12 = v31;
        v29 = v31;
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v30);
        v30[0] = 0;
        v31 = 0;
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v28);
        v13 = *a1;
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v28);
        v14 = *v13;
        *v13 = v10;
        v28[0] = v14;
        v15 = (uint64_t *)*((_QWORD *)v13 + 1);
        *((_QWORD *)v13 + 1) = v12;
        v29 = v15;
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v13);
        v16 = v28;
LABEL_15:
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v16);
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(v11, v14);
        goto LABEL_18;
      }
      v5 = (unsigned __int8 *)*((_QWORD *)v4 - 1);
      if (v5)
      {
        v6 = *v5;
        if (v6 == 2)
        {
          v7 = (uint64_t *)*((_QWORD *)v5 + 1);
          v8 = v7[1];
          if (v8 >= v7[2])
          {
            v9 = std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::__push_back_slow_path<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>(v7, (uint64_t)v30);
          }
          else
          {
            *(_BYTE *)v8 = v30[0];
            *(_QWORD *)(v8 + 8) = v31;
            nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v30);
            v30[0] = 0;
            v31 = 0;
            nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v8);
            v9 = v8 + 16;
          }
          v7[1] = v9;
          goto LABEL_18;
        }
        if (v6 == 1)
        {
          v17 = a1[8];
          if (v17)
          {
            v18 = v17 - 1;
            v19 = *(_QWORD *)&a1[7][((unint64_t)v18 >> 3) & 0x1FFFFFFFFFFFFFF8];
            a1[8] = v18;
            if (((v19 >> (char)v18) & 1) != 0)
            {
              if (!a1[10])
                __assert_rtn("handle_value", "json_sax.hpp", 624, "object_element");
              v20 = v30[0];
              v26[0] = v30[0];
              v11 = &v27;
              v21 = v31;
              v27 = v31;
              nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v30);
              v30[0] = 0;
              v31 = 0;
              nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v26);
              v22 = a1[10];
              nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v26);
              v14 = *v22;
              *v22 = v20;
              v26[0] = v14;
              v23 = (uint64_t *)*((_QWORD *)v22 + 1);
              *((_QWORD *)v22 + 1) = v21;
              v27 = v23;
              nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v22);
              v16 = v26;
              goto LABEL_15;
            }
            goto LABEL_18;
          }
          v24 = "not key_keep_stack.empty()";
          v25 = 615;
        }
        else
        {
          v24 = "ref_stack.back()->is_array() or ref_stack.back()->is_object()";
          v25 = 603;
        }
        __assert_rtn("handle_value", "json_sax.hpp", v25, v24);
      }
    }
LABEL_18:
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v30);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(&v31, v30[0]);
  }
}

void sub_1D4ECB31C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::~basic_json((uint64_t **)va);
  _Unwind_Resume(a1);
}

void nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<unsigned long long &>(unsigned __int8 **a1, uint64_t *a2)
{
  unsigned __int8 *v2;
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  int v6;
  uint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  unsigned __int8 v10;
  uint64_t **v11;
  uint64_t *v12;
  unsigned __int8 *v13;
  int v14;
  uint64_t *v15;
  char *v16;
  unsigned __int8 *v17;
  unsigned __int8 *v18;
  unint64_t v19;
  unsigned __int8 v20;
  uint64_t *v21;
  unsigned __int8 *v22;
  uint64_t *v23;
  const char *v24;
  int v25;
  char v26[8];
  uint64_t *v27;
  char v28[8];
  uint64_t *v29;
  unsigned __int8 v30[8];
  uint64_t *v31;

  v2 = a1[5];
  if (!v2)
    __assert_rtn("handle_value", "json_sax.hpp", 568, "not keep_stack.empty()");
  if (((*(_QWORD *)&a1[4][((unint64_t)(v2 - 1) >> 3) & 0x1FFFFFFFFFFFFFF8] >> (v2 - 1)) & 1) != 0)
  {
    v30[0] = 6;
    v31 = a2;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v30);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v30);
    if ((std::function<BOOL ()(int,nlohmann::detail::parse_event_t,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> &)>::operator()((uint64_t)a1[15], (unint64_t)(a1[2] - a1[1]) >> 3, 5) & 1) != 0)
    {
      v4 = a1[2];
      if (a1[1] == v4)
      {
        v10 = v30[0];
        v28[0] = v30[0];
        v11 = &v29;
        v12 = v31;
        v29 = v31;
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v30);
        v30[0] = 0;
        v31 = 0;
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v28);
        v13 = *a1;
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v28);
        v14 = *v13;
        *v13 = v10;
        v28[0] = v14;
        v15 = (uint64_t *)*((_QWORD *)v13 + 1);
        *((_QWORD *)v13 + 1) = v12;
        v29 = v15;
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v13);
        v16 = v28;
LABEL_15:
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v16);
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(v11, v14);
        goto LABEL_18;
      }
      v5 = (unsigned __int8 *)*((_QWORD *)v4 - 1);
      if (v5)
      {
        v6 = *v5;
        if (v6 == 2)
        {
          v7 = (uint64_t *)*((_QWORD *)v5 + 1);
          v8 = v7[1];
          if (v8 >= v7[2])
          {
            v9 = std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::__push_back_slow_path<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>(v7, (uint64_t)v30);
          }
          else
          {
            *(_BYTE *)v8 = v30[0];
            *(_QWORD *)(v8 + 8) = v31;
            nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v30);
            v30[0] = 0;
            v31 = 0;
            nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v8);
            v9 = v8 + 16;
          }
          v7[1] = v9;
          goto LABEL_18;
        }
        if (v6 == 1)
        {
          v17 = a1[8];
          if (v17)
          {
            v18 = v17 - 1;
            v19 = *(_QWORD *)&a1[7][((unint64_t)v18 >> 3) & 0x1FFFFFFFFFFFFFF8];
            a1[8] = v18;
            if (((v19 >> (char)v18) & 1) != 0)
            {
              if (!a1[10])
                __assert_rtn("handle_value", "json_sax.hpp", 624, "object_element");
              v20 = v30[0];
              v26[0] = v30[0];
              v11 = &v27;
              v21 = v31;
              v27 = v31;
              nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v30);
              v30[0] = 0;
              v31 = 0;
              nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v26);
              v22 = a1[10];
              nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v26);
              v14 = *v22;
              *v22 = v20;
              v26[0] = v14;
              v23 = (uint64_t *)*((_QWORD *)v22 + 1);
              *((_QWORD *)v22 + 1) = v21;
              v27 = v23;
              nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v22);
              v16 = v26;
              goto LABEL_15;
            }
            goto LABEL_18;
          }
          v24 = "not key_keep_stack.empty()";
          v25 = 615;
        }
        else
        {
          v24 = "ref_stack.back()->is_array() or ref_stack.back()->is_object()";
          v25 = 603;
        }
        __assert_rtn("handle_value", "json_sax.hpp", v25, v24);
      }
    }
LABEL_18:
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v30);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(&v31, v30[0]);
  }
}

void sub_1D4ECB5DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::~basic_json((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t std::function<BOOL ()(int,nlohmann::detail::parse_event_t,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> &)>::operator()(uint64_t a1, int a2, char a3)
{
  char v4;
  int v5;

  v5 = a2;
  v4 = a3;
  if (!a1)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, int *, char *))(*(_QWORD *)a1 + 48))(a1, &v5, &v4);
}

uint64_t nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::basic_json(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  BOOL v14;
  uint64_t **v15;
  char *v16;
  uint64_t *v17;
  __int128 v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  char *v27;
  _QWORD *v29;
  char v30;
  char *v31;
  char **v32;
  char **v33;
  char v34;
  char *v35;
  char *v36;

  *(_BYTE *)a1 = *(_BYTE *)a2;
  *(_QWORD *)(a1 + 8) = 0;
  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(a2);
  switch(*(_BYTE *)a1)
  {
    case 1:
      v6 = *(_QWORD **)(a2 + 8);
      v4 = (uint64_t)operator new(0x18uLL);
      *(_QWORD *)(v4 + 8) = 0;
      *(_QWORD *)(v4 + 16) = 0;
      *(_QWORD *)v4 = v4 + 8;
      v9 = (_QWORD *)*v6;
      v7 = v6 + 1;
      v8 = v9;
      if (v9 == v7)
        goto LABEL_35;
      break;
    case 2:
      v21 = *(uint64_t **)(a2 + 8);
      v4 = (uint64_t)operator new(0x18uLL);
      *(_QWORD *)(v4 + 8) = 0;
      *(_QWORD *)(v4 + 16) = 0;
      *(_QWORD *)v4 = 0;
      v22 = *v21;
      v23 = v21[1];
      v29 = (_QWORD *)v4;
      v30 = 0;
      v24 = v23 - v22;
      if (v23 != v22)
      {
        if (v24 < 0)
          std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
        v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>(v24 >> 4);
        *(_QWORD *)v4 = v25;
        *(_QWORD *)(v4 + 8) = v25;
        *(_QWORD *)(v4 + 16) = &v25[16 * v26];
        v35 = v25;
        v36 = v25;
        v31 = (char *)(v4 + 16);
        v32 = &v35;
        v33 = &v36;
        v27 = v25;
        v34 = 0;
        do
        {
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::basic_json(v27, v22);
          v22 += 16;
          v27 = v36 + 16;
          v36 += 16;
        }
        while (v22 != v23);
        v34 = 1;
        std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&v31);
        *(_QWORD *)(v4 + 8) = v27;
      }
      goto LABEL_35;
    case 3:
      v4 = (uint64_t)nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::create<std::string,std::string const&>(*(_QWORD *)(a2 + 8));
      goto LABEL_35;
    case 4:
      v4 = *(unsigned __int8 *)(a2 + 8);
      goto LABEL_35;
    case 5:
    case 6:
    case 7:
      v4 = *(_QWORD *)(a2 + 8);
      goto LABEL_35;
    case 8:
      v5 = *(_QWORD *)(a2 + 8);
      v4 = (uint64_t)operator new(0x20uLL);
      *(_QWORD *)(v4 + 8) = 0;
      *(_QWORD *)(v4 + 16) = 0;
      *(_QWORD *)v4 = 0;
      std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>((_QWORD *)v4, *(const void **)v5, *(_QWORD *)(v5 + 8), *(_QWORD *)(v5 + 8) - *(_QWORD *)v5);
      *(_WORD *)(v4 + 24) = *(_WORD *)(v5 + 24);
LABEL_35:
      *(_QWORD *)(a1 + 8) = v4;
      goto LABEL_36;
    default:
LABEL_36:
      nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(a1);
      return a1;
  }
  while (1)
  {
    v10 = *(_QWORD *)(v4 + 8);
    v11 = (_QWORD *)(v4 + 8);
    if (*(_QWORD *)v4 == v4 + 8)
      goto LABEL_14;
    v12 = *(_QWORD **)(v4 + 8);
    v13 = (_QWORD *)(v4 + 8);
    if (v10)
    {
      do
      {
        v11 = v12;
        v12 = (_QWORD *)v12[1];
      }
      while (v12);
    }
    else
    {
      do
      {
        v11 = (_QWORD *)v13[2];
        v14 = *v11 == (_QWORD)v13;
        v13 = v11;
      }
      while (v14);
    }
    if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v11 + 4, (void **)v8 + 4) & 0x80) != 0)
    {
LABEL_14:
      if (!v10)
      {
        v29 = (_QWORD *)(v4 + 8);
        v15 = (uint64_t **)(v4 + 8);
LABEL_19:
        v16 = (char *)operator new(0x48uLL);
        v17 = (uint64_t *)v16;
        v31 = v16;
        v32 = (char **)(v4 + 8);
        LOBYTE(v33) = 0;
        if (*((char *)v8 + 55) < 0)
        {
          std::string::__init_copy_ctor_external((std::string *)(v16 + 32), (const std::string::value_type *)v8[4], v8[5]);
        }
        else
        {
          v18 = *((_OWORD *)v8 + 2);
          *((_QWORD *)v16 + 6) = v8[6];
          *((_OWORD *)v16 + 2) = v18;
        }
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::basic_json(v17 + 7, v8 + 7);
        LOBYTE(v33) = 1;
        std::__tree<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::__map_value_compare<std::string,std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::less<void>,true>,std::allocator<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>>::__insert_node_at((uint64_t **)v4, (uint64_t)v29, v15, v17);
        v31 = 0;
        std::unique_ptr<std::__tree_node<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,void *>>>>::reset[abi:ne180100]((uint64_t)&v31);
        goto LABEL_23;
      }
      v29 = v11;
      v15 = (uint64_t **)(v11 + 1);
    }
    else
    {
      v15 = (uint64_t **)std::__tree<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::__map_value_compare<std::string,std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::less<void>,true>,std::allocator<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>>::__find_equal<std::string>(v4, &v29, (void **)v8 + 4);
    }
    if (!*v15)
      goto LABEL_19;
LABEL_23:
    v19 = (_QWORD *)v8[1];
    if (v19)
    {
      do
      {
        v20 = v19;
        v19 = (_QWORD *)*v19;
      }
      while (v19);
    }
    else
    {
      do
      {
        v20 = (_QWORD *)v8[2];
        v14 = *v20 == (_QWORD)v8;
        v8 = v20;
      }
      while (!v14);
    }
    v8 = v20;
    if (v20 == v7)
      goto LABEL_35;
  }
}

void sub_1D4ECB924(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  void *v11;

  operator delete(v11);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(_QWORD *result, const void *a2, uint64_t a3, size_t __sz)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (__sz)
  {
    v6 = result;
    result = std::vector<unsigned char>::__vallocate[abi:ne180100](result, __sz);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1D4ECB9F0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned __int8 *v5;
  int v6;
  BOOL v7;

  if (!*(_BYTE *)(a1 + 24))
  {
    v2 = **(_QWORD **)(a1 + 16);
    v3 = **(_QWORD **)(a1 + 8);
    if (v2 != v3)
    {
      v4 = v2 - 16;
      v5 = (unsigned __int8 *)(v2 - 16);
      do
      {
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v4);
        v6 = *v5;
        v5 -= 16;
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy((uint64_t **)(v4 + 8), v6);
        v7 = v4 == v3;
        v4 = (uint64_t)v5;
      }
      while (!v7);
    }
  }
  return a1;
}

uint64_t nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<nlohmann::detail::value_t>(uint64_t *a1, unsigned __int8 a2)
{
  uint64_t v2;
  uint64_t v4;
  unsigned __int8 *v5;
  int v6;
  uint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 v11;
  uint64_t *v12;
  unsigned __int8 *v13;
  int v14;
  uint64_t *v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unsigned __int8 v19;
  uint64_t *v20;
  unsigned __int8 *v21;
  int v22;
  uint64_t *v23;
  const char *v25;
  int v26;
  char v27[8];
  uint64_t *v28;
  char v29[8];
  uint64_t *v30;
  char v31[8];
  uint64_t *v32;

  v2 = a1[5];
  if (!v2)
    __assert_rtn("handle_value", "json_sax.hpp", 568, "not keep_stack.empty()");
  if (((*(_QWORD *)(a1[4] + (((unint64_t)(v2 - 1) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v2 - 1)) & 1) != 0)
  {
    v31[0] = a2;
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::json_value(&v32, a2);
    nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v31);
    v4 = a1[2];
    if (a1[1] == v4)
    {
      v11 = v31[0];
      v29[0] = v31[0];
      v12 = v32;
      v30 = v32;
      nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v31);
      v31[0] = 0;
      v32 = 0;
      nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v29);
      v13 = (unsigned __int8 *)*a1;
      nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v29);
      v14 = *v13;
      *v13 = v11;
      v29[0] = v14;
      v15 = (uint64_t *)*((_QWORD *)v13 + 1);
      *((_QWORD *)v13 + 1) = v12;
      v30 = v15;
      nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v13);
      nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v29);
      nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(&v30, v14);
      v10 = *a1;
LABEL_18:
      nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v31);
      nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(&v32, v31[0]);
      return v10;
    }
    v5 = *(unsigned __int8 **)(v4 - 8);
    if (v5)
    {
      v6 = *v5;
      if (v6 == 2)
      {
        v7 = (uint64_t *)*((_QWORD *)v5 + 1);
        v8 = v7[1];
        if (v8 >= v7[2])
        {
          v9 = std::vector<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::__push_back_slow_path<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>(v7, (uint64_t)v31);
        }
        else
        {
          *(_BYTE *)v8 = v31[0];
          *(_QWORD *)(v8 + 8) = v32;
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v31);
          v31[0] = 0;
          v32 = 0;
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant(v8);
          v9 = v8 + 16;
        }
        v7[1] = v9;
        v10 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1[2] - 8) + 8) + 8) - 16;
        goto LABEL_18;
      }
      if (v6 == 1)
      {
        v16 = a1[8];
        if (v16)
        {
          v17 = v16 - 1;
          v18 = *(_QWORD *)(a1[7] + ((v17 >> 3) & 0x1FFFFFFFFFFFFFF8));
          a1[8] = v17;
          if (((v18 >> v17) & 1) != 0)
          {
            if (!a1[10])
              __assert_rtn("handle_value", "json_sax.hpp", 624, "object_element");
            v19 = v31[0];
            v27[0] = v31[0];
            v20 = v32;
            v28 = v32;
            nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v31);
            v31[0] = 0;
            v32 = 0;
            nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v27);
            v21 = (unsigned __int8 *)a1[10];
            nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v27);
            v22 = *v21;
            *v21 = v19;
            v27[0] = v22;
            v23 = (uint64_t *)*((_QWORD *)v21 + 1);
            *((_QWORD *)v21 + 1) = v20;
            v28 = v23;
            nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v21);
            nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v27);
            nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(&v28, v22);
            v10 = a1[10];
            goto LABEL_18;
          }
          goto LABEL_15;
        }
        v25 = "not key_keep_stack.empty()";
        v26 = 615;
      }
      else
      {
        v25 = "ref_stack.back()->is_array() or ref_stack.back()->is_object()";
        v26 = 603;
      }
      __assert_rtn("handle_value", "json_sax.hpp", v26, v25);
    }
LABEL_15:
    v10 = 0;
    goto LABEL_18;
  }
  return 0;
}

void sub_1D4ECBD44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::~basic_json((uint64_t **)va);
  _Unwind_Resume(a1);
}

_QWORD *nlohmann::detail::iter_impl<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::iter_impl(_QWORD *result, uint64_t a2)
{
  *result = a2;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  result[4] = 0x8000000000000000;
  if (!a2)
    __assert_rtn("iter_impl", "iter_impl.hpp", 88, "m_object != nullptr");
  return result;
}

unsigned __int8 **nlohmann::detail::iter_impl<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::set_end(unsigned __int8 **result)
{
  unsigned __int8 *v1;
  int v2;

  v1 = *result;
  if (!*result)
    __assert_rtn("set_end", "iter_impl.hpp", 211, "m_object != nullptr");
  v2 = *v1;
  if (v2 == 2)
  {
    result[2] = *(unsigned __int8 **)(*((_QWORD *)v1 + 1) + 8);
  }
  else if (v2 == 1)
  {
    result[1] = (unsigned __int8 *)(*((_QWORD *)v1 + 1) + 8);
  }
  else
  {
    result[4] = (unsigned __int8 *)1;
  }
  return result;
}

void nlohmann::detail::invalid_iterator::create(nlohmann::detail::exception *a1, int a2, uint64_t a3)
{
  int v6;
  const std::string::value_type *v7;
  std::string::size_type v8;
  std::string *v9;
  __int128 v10;
  void **v11;
  void *__p[2];
  char v13;
  std::string v14;
  void *v15[2];
  int64_t v16;

  std::string::basic_string[abi:ne180100]<0>(__p, "invalid_iterator");
  nlohmann::detail::exception::name(&v14, (uint64_t)__p, a2);
  v6 = *(char *)(a3 + 23);
  if (v6 >= 0)
    v7 = (const std::string::value_type *)a3;
  else
    v7 = *(const std::string::value_type **)a3;
  if (v6 >= 0)
    v8 = *(unsigned __int8 *)(a3 + 23);
  else
    v8 = *(_QWORD *)(a3 + 8);
  v9 = std::string::append(&v14, v7, v8);
  v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
  v16 = v9->__r_.__value_.__r.__words[2];
  *(_OWORD *)v15 = v10;
  v9->__r_.__value_.__l.__size_ = 0;
  v9->__r_.__value_.__r.__words[2] = 0;
  v9->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v14.__r_.__value_.__l.__data_);
  if (v13 < 0)
    operator delete(__p[0]);
  if (v16 >= 0)
    v11 = v15;
  else
    v11 = (void **)v15[0];
  nlohmann::detail::exception::exception(a1, a2, (const char *)v11);
  *(_QWORD *)a1 = &off_1E98B6FB8;
  if (SHIBYTE(v16) < 0)
    operator delete(v15[0]);
}

void sub_1D4ECBF0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__value_func<BOOL ()(int,nlohmann::detail::parse_event_t,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> &)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;

  v3 = (_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(_QWORD *)(a1 + 24) = v4;
  }
  else
  {
    v3 = (_QWORD *)(a1 + 24);
  }
  *v3 = 0;
  return a1;
}

uint64_t *std::unique_ptr<std::map<unsigned short,unsigned short>>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    std::__tree<std::__value_type<__CFString const*,unsigned int>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,unsigned int>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,unsigned int>>>::destroy(*(_QWORD **)(v2 + 8));
    JUMPOUT(0x1D826BA98);
  }
  return result;
}

uint64_t MIDI::ControlState::get_control_or_RPN(MIDI::ControlState *this, unsigned int a2)
{
  int v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  BOOL v10;
  uint64_t *v11;

  if (a2 > 0x7F)
  {
    v3 = *((_QWORD *)this + 18);
    if (v3)
    {
      v7 = *(_QWORD *)(v3 + 8);
      v5 = v3 + 8;
      v6 = v7;
      if (!v7)
        goto LABEL_17;
      v8 = v5;
      do
      {
        v9 = *(unsigned __int16 *)(v6 + 26);
        v10 = v9 >= a2;
        if (v9 >= a2)
          v11 = (uint64_t *)v6;
        else
          v11 = (uint64_t *)(v6 + 8);
        if (v10)
          v8 = v6;
        v6 = *v11;
      }
      while (*v11);
      if (v8 != v5 && *(unsigned __int16 *)(v8 + 26) <= a2)
        LOWORD(v3) = *(_WORD *)(v8 + 28);
      else
LABEL_17:
        LOWORD(v3) = 0;
    }
  }
  else
  {
    v2 = *((char *)this + a2 + 12);
    LODWORD(v3) = v2 & ~(v2 >> 31);
    if (a2 <= 0x1F && ((*((unsigned __int8 *)this + ((unint64_t)a2 >> 3)) >> (a2 & 7)) & 1) != 0)
    {
      v4 = *((char *)this + a2 + 44);
      LODWORD(v3) = v4 & ~(v4 >> 31) | (v3 << 7);
    }
    else
    {
      LOWORD(v3) = v3 << 7;
    }
  }
  return (unsigned __int16)v3;
}

uint64_t MIDI::ControlState::interpret_control(MIDI::ControlState *this, unint64_t a2, int a3, unsigned __int16 *a4, unsigned __int16 *a5)
{
  unsigned int v7;
  int v9;
  int v10;
  uint64_t result;
  unsigned int v12;
  unsigned int v13;
  int v14;
  int v15;
  unsigned int control_or_RPN;
  uint64_t **v17;
  unsigned __int16 *v18;
  uint64_t **v19;
  _QWORD *v20;
  unsigned int v21;
  _QWORD *v22;
  uint64_t *v23;
  uint64_t *v24;

  v7 = a2;
  if ((a2 - 96) > 5)
  {
    if ((_DWORD)a2 != 6)
    {
      if ((_DWORD)a2 != 38)
      {
        if (a2 > 0x1F)
        {
          if (a2 > 0x3F || ((*((unsigned __int8 *)this + ((a2 >> 3) & 3)) >> (a2 & 7)) & 1) == 0)
          {
            v13 = a3 << 7;
            v12 = a2;
            goto LABEL_35;
          }
          v7 = a2 & 0x1F;
          v13 = MIDI::ControlState::get_control_or_RPN(this, v7) & 0x3F80 | a3;
        }
        else
        {
          v13 = a3 << 7;
        }
        *((_BYTE *)this + v7 + 12) = v13 >> 7;
        LOWORD(v12) = v7;
        goto LABEL_38;
      }
      if ((*(_BYTE *)this & 0x40) == 0)
      {
        result = 0;
        v12 = 38;
LABEL_7:
        LOWORD(v13) = (_WORD)a3 << 7;
        *((_BYTE *)this + v12 + 12) = a3;
        goto LABEL_54;
      }
    }
  }
  else
  {
    v9 = 1 << (a2 - 96);
    if ((v9 & 3) == 0)
    {
      if ((v9 & 0xC) != 0)
        v10 = 2;
      else
        v10 = 1;
      *((_DWORD *)this + 2) = v10;
      result = 1;
      v12 = a2;
      goto LABEL_7;
    }
  }
  v14 = *((_DWORD *)this + 2);
  if (v14 == 1)
  {
    v12 = *((char *)this + 112) & ~(*((char *)this + 112) >> 31) | ((*((char *)this + 113) & ~(*((char *)this + 113) >> 31)) << 7) | 0x4000;
  }
  else if (v14 == 2)
  {
    v12 = *((char *)this + 110) & ~(*((char *)this + 110) >> 31) | ((*((char *)this + 111) & ~(*((char *)this + 111) >> 31)) << 7) | 0xFFFF8000;
  }
  else
  {
    v12 = a2;
  }
  switch((_DWORD)a2)
  {
    case '&':
      v13 = MIDI::ControlState::get_control_or_RPN(this, (unsigned __int16)v12) & 0x3F80 | a3;
      break;
      control_or_RPN = MIDI::ControlState::get_control_or_RPN(this, (unsigned __int16)v12);
      if (control_or_RPN >= 0x3FFF)
        v13 = control_or_RPN;
      else
        v13 = control_or_RPN + 1;
      break;
    case 'a':
      v15 = MIDI::ControlState::get_control_or_RPN(this, (unsigned __int16)v12);
      if (v15)
        v13 = v15 - 1;
      else
        v13 = 0;
      break;
    default:
      v13 = a3 << 7;
      break;
  }
LABEL_35:
  if (v12 < 0x80)
  {
    *((_BYTE *)this + (unsigned __int16)v12 + 12) = v13 >> 7;
    if (v12 > 0x1F)
      goto LABEL_48;
    v7 = (unsigned __int16)v12;
LABEL_38:
    if (((*((unsigned __int8 *)this + ((unint64_t)v7 >> 3)) >> (v7 & 7)) & 1) != 0)
    {
      result = 0;
      *((_BYTE *)this + v7 + 44) = v13 & 0x7F;
      goto LABEL_54;
    }
LABEL_48:
    result = 0;
    goto LABEL_54;
  }
  v17 = (uint64_t **)*((_QWORD *)this + 18);
  if (!v17)
    goto LABEL_48;
  v19 = v17 + 1;
  v18 = (unsigned __int16 *)v17[1];
  if (v18)
  {
    while (1)
    {
      while (1)
      {
        v20 = v18;
        v21 = v18[13];
        if (v21 <= (unsigned __int16)v12)
          break;
        v18 = (unsigned __int16 *)*v20;
        v19 = (uint64_t **)v20;
        if (!*v20)
          goto LABEL_50;
      }
      if (v21 >= (unsigned __int16)v12)
        break;
      v18 = (unsigned __int16 *)v20[1];
      if (!v18)
      {
        v19 = (uint64_t **)(v20 + 1);
        goto LABEL_50;
      }
    }
  }
  else
  {
    v20 = v17 + 1;
LABEL_50:
    v22 = v20;
    v20 = operator new(0x20uLL);
    *((_WORD *)v20 + 13) = v12;
    *((_WORD *)v20 + 14) = 0;
    *v20 = 0;
    v20[1] = 0;
    v20[2] = v22;
    *v19 = v20;
    v23 = (uint64_t *)**v17;
    v24 = v20;
    if (v23)
    {
      *v17 = v23;
      v24 = *v19;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v17[1], v24);
    v17[2] = (uint64_t *)((char *)v17[2] + 1);
  }
  result = 0;
  *((_WORD *)v20 + 14) = v13;
LABEL_54:
  *a4 = v12;
  *a5 = v13;
  return result;
}

uint64_t MIDI::Packetizer::add(MIDI::Packetizer *this, uint64_t a2, int a3)
{
  uint64_t result;
  char *v5;
  unsigned int v6;
  int v7;
  BOOL v8;
  unsigned int v9;
  BOOL v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  BOOL v14;
  char v15;
  int v16;
  int v17;
  uint64_t v18;
  int v19;

  v19 = a3;
  result = *((_QWORD *)this + 7);
  v5 = (char *)this + 1088;
  v6 = a3 & 0xF0000000;
  v7 = *((_DWORD *)this + 17);
  if (result)
    v8 = v7 == 0;
  else
    v8 = 1;
  if (!v8)
  {
    v9 = *(_DWORD *)(result + 8);
    v10 = v9 >= 2;
    v11 = v9 - 2;
    if (v10 && *(_DWORD *)(result + 12) >> 28 == 3)
    {
      v12 = *(_DWORD *)(result + 4 * v11 + 12);
      if (v12 >> 28 == 3)
        v13 = (v12 >> 20) & 0xF;
      else
        v13 = 255;
      if (v13)
        v14 = v13 == 3;
      else
        v14 = 1;
      v15 = v14;
      v16 = 1;
LABEL_24:
      v17 = v6 != 805306368;
      if ((a3 & 0xF0E00000) != 0x30000000 && v17 != v16 && *(_QWORD *)result == a2 && (v15 & 1) == 0)
      {
LABEL_28:
        v18 = *(unsigned int *)(result + 8);
        if (result + 4 * v18 + 16 <= (unint64_t)v5)
          goto LABEL_34;
        goto LABEL_32;
      }
      goto LABEL_30;
    }
LABEL_23:
    v16 = 0;
    v15 = 0;
    goto LABEL_24;
  }
  if (!v7)
    goto LABEL_31;
  if (result)
    goto LABEL_23;
  if (v6 != 805306368)
    goto LABEL_28;
LABEL_30:
  result += 4 * *(unsigned int *)(result + 8) + 12;
LABEL_31:
  if (result + 16 <= (unint64_t)v5)
  {
    LODWORD(v18) = 0;
    *((_DWORD *)this + 17) = v7 + 1;
    *(_QWORD *)result = a2;
    *(_DWORD *)(result + 8) = 0;
LABEL_34:
    *(_DWORD *)(result + 4 * v18 + 12) = a3;
    *(_DWORD *)(result + 8) = v18 + 1;
    goto LABEL_35;
  }
LABEL_32:
  result = MIDI::PacketizerBase<MIDI::EventList>::begin_new_packet((uint64_t)this, a2, &v19, 1);
LABEL_35:
  *((_QWORD *)this + 7) = result;
  return result;
}

uint64_t MIDI::PacketizerBase<MIDI::EventList>::begin_new_packet(uint64_t a1, uint64_t a2, int *a3, uint64_t a4)
{
  int *v8;
  uint64_t v9;
  int v10;
  char *v11;
  void *v12;
  int *v13;
  int v14;
  int v15;
  int v16;
  int v17;
  void *v19;

  v8 = (int *)(a1 + 64);
  if (!*(_DWORD *)(a1 + 68))
    goto LABEL_4;
  v19 = (void *)(a1 + 64);
  (**(void (***)(uint64_t, void **))a1)(a1 + 8, &v19);
  *(_DWORD *)(a1 + 68) = 0;
  v9 = a1 + 72;
  if (!a4)
    return v9;
  if (v9 + 4 * a4 + 12 <= (unint64_t)(a1 + 1088))
  {
    *(_DWORD *)(a1 + 68) = 1;
    *(_QWORD *)(a1 + 72) = a2;
    *(_DWORD *)(a1 + 80) = 0;
    v13 = (int *)(a1 + 84);
    v14 = 0;
    switch((4 * a4) >> 2)
    {
      case 0:
        break;
      case 1:
        goto LABEL_11;
      case 2:
        goto LABEL_10;
      case 3:
        goto LABEL_9;
      case 4:
        v15 = *a3++;
        v13 = (int *)(a1 + 88);
        *(_DWORD *)(a1 + 84) = v15;
LABEL_9:
        v16 = *a3++;
        *v13++ = v16;
LABEL_10:
        v17 = *a3++;
        *v13++ = v17;
LABEL_11:
        *v13 = *a3;
        v14 = *(_DWORD *)(a1 + 80);
        break;
      default:
        memmove(v13, a3, 4 * a4);
        v14 = 0;
        break;
    }
    *(_DWORD *)(a1 + 80) = v14 + a4;
  }
  else
  {
LABEL_4:
    v10 = *v8;
    v11 = (char *)malloc_type_malloc(4 * a4 + 20, 0x53A9EFB0uLL);
    v12 = v11;
    *(_DWORD *)v11 = v10;
    *((_DWORD *)v11 + 1) = 1;
    *((_QWORD *)v11 + 1) = a2;
    *((_DWORD *)v11 + 4) = a4;
    if (a4)
      memmove(v11 + 20, a3, 4 * a4);
    v19 = v12;
    (**(void (***)(uint64_t, void **))a1)(a1 + 8, &v19);
    MIDI::packet_list_deleter(v12);
    v9 = a1 + 72;
    *(_QWORD *)(a1 + 56) = a1 + 72;
    *(_DWORD *)(a1 + 68) = 0;
  }
  return v9;
}

void sub_1D4ECC658(_Unwind_Exception *a1)
{
  void *v1;

  MIDI::packet_list_deleter(v1);
  _Unwind_Resume(a1);
}

uint64_t *MIDI::ChannelState::clear(MIDI::ChannelState *this)
{
  _OWORD *v2;
  __int128 v3;
  uint64_t *result;

  if (*((_BYTE *)this + 1))
  {
    v2 = (_OWORD *)*((_QWORD *)this + 17);
    v2[6] = 0u;
    v2[7] = 0u;
    v2[4] = 0u;
    v2[5] = 0u;
    v2[2] = 0u;
    v2[3] = 0u;
    *v2 = 0u;
    v2[1] = 0u;
  }
  *(_OWORD *)((char *)this + 116) = 0u;
  *(_OWORD *)((char *)this + 100) = 0u;
  *(_OWORD *)((char *)this + 84) = 0u;
  *(_OWORD *)((char *)this + 68) = 0u;
  *(_OWORD *)((char *)this + 52) = 0u;
  *(_OWORD *)((char *)this + 36) = 0u;
  *(_OWORD *)((char *)this + 20) = 0u;
  *(_OWORD *)((char *)this + 4) = 0u;
  *(_QWORD *)&v3 = -1;
  *((_QWORD *)&v3 + 1) = -1;
  *((_OWORD *)this + 10) = v3;
  *((_OWORD *)this + 11) = v3;
  *((_OWORD *)this + 12) = v3;
  *((_OWORD *)this + 13) = v3;
  *((_OWORD *)this + 14) = v3;
  *((_OWORD *)this + 15) = v3;
  *((_OWORD *)this + 16) = v3;
  *((_OWORD *)this + 17) = v3;
  *((_DWORD *)this + 76) = 0;
  result = (uint64_t *)*((_QWORD *)this + 55);
  if (result)
  {
    result = std::__tree<std::__value_type<unsigned short,unsigned short>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,unsigned short>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,unsigned short>>>::erase((uint64_t **)result, (uint64_t *)*result, result + 1);
    *(_QWORD *)&v3 = -1;
    *((_QWORD *)&v3 + 1) = -1;
  }
  *(_OWORD *)((char *)this + 420) = v3;
  *(_OWORD *)((char *)this + 404) = v3;
  *(_OWORD *)((char *)this + 388) = v3;
  *(_OWORD *)((char *)this + 372) = v3;
  *(_OWORD *)((char *)this + 356) = v3;
  *(_OWORD *)((char *)this + 340) = v3;
  *(_OWORD *)((char *)this + 324) = v3;
  *(_OWORD *)((char *)this + 308) = v3;
  *((_WORD *)this + 1) = -1;
  *((_WORD *)this + 144) = -1;
  return result;
}

MIDI::StreamState *MIDI::StreamState::StreamState(MIDI::StreamState *this, char a2)
{
  char v2;
  uint64_t v4;
  char *v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  __int128 v11;
  char *v12;
  __int128 v13;
  _QWORD *v14;
  char *v15;
  char *v16;
  unint64_t v17;
  _BYTE *v18;
  char *v19;
  _QWORD *v20;
  char *v21;
  size_t v22;
  char *v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  size_t v29;
  char *v30;
  char *v31;
  char *v32;
  char *v33;
  char v34;
  size_t v36;
  char *v37;
  BOOL v39;
  int v40;
  uint64_t v41;

  v2 = a2;
  v4 = -7168;
  do
  {
    v5 = (char *)this + v4;
    *(_OWORD *)(v5 + 7304) = 0uLL;
    *((_QWORD *)v5 + 915) = 0;
    *((_DWORD *)v5 + 1866) = -1;
    *((_DWORD *)v5 + 1868) = 0;
    *((_QWORD *)v5 + 951) = 0;
    v4 += 448;
  }
  while (v4);
  v6 = 0;
  v39 = (a2 & 3) != 0;
  v40 = a2 & 3;
  do
  {
    v7 = (char *)this + 448 * v6;
    v7[300] = v6;
    *((_DWORD *)v7 + 76) = 0;
    v8 = *((_QWORD *)v7 + 55);
    if (v8)
    {
      std::__tree<std::__value_type<unsigned short,unsigned short>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,unsigned short>,std::less<unsigned short>,true>,std::allocator<std::__value_type<unsigned short,unsigned short>>>::erase((uint64_t **)v8, *(uint64_t **)v8, (uint64_t *)(v8 + 8));
      v9 = *((_QWORD *)v7 + 55);
      v10 = (char *)this + 448 * v6 + 296;
      *(_QWORD *)&v11 = -1;
      *((_QWORD *)&v11 + 1) = -1;
      *(_OWORD *)(v10 + 12) = v11;
      *(_OWORD *)(v10 + 28) = v11;
      *(_OWORD *)(v10 + 44) = v11;
      *(_OWORD *)(v10 + 60) = v11;
      *(_OWORD *)(v10 + 76) = v11;
      *(_OWORD *)(v10 + 92) = v11;
      *(_OWORD *)(v10 + 108) = v11;
      *(_OWORD *)(v10 + 124) = v11;
      if ((v9 != 0) == (v2 & 1))
        goto LABEL_10;
      if ((v2 & 1) == 0)
      {
        std::unique_ptr<std::map<unsigned short,unsigned short>>::reset[abi:ne180100]((uint64_t *)v7 + 55, 0);
        goto LABEL_10;
      }
    }
    else
    {
      v12 = (char *)this + 448 * v6 + 296;
      *(_QWORD *)&v13 = -1;
      *((_QWORD *)&v13 + 1) = -1;
      *(_OWORD *)(v12 + 124) = v13;
      *(_OWORD *)(v12 + 108) = v13;
      *(_OWORD *)(v12 + 92) = v13;
      *(_OWORD *)(v12 + 76) = v13;
      *(_OWORD *)(v12 + 60) = v13;
      *(_OWORD *)(v12 + 44) = v13;
      *(_OWORD *)(v12 + 28) = v13;
      *(_OWORD *)(v12 + 12) = v13;
      if ((v2 & 1) == 0)
        goto LABEL_10;
    }
    v14 = (_QWORD *)operator new();
    v14[2] = 0;
    v14[1] = 0;
    *v14 = v14 + 1;
    v41 = 0;
    std::unique_ptr<std::map<unsigned short,unsigned short>>::reset[abi:ne180100]((uint64_t *)v7 + 55, (uint64_t)v14);
    std::unique_ptr<std::map<unsigned short,unsigned short>>::reset[abi:ne180100](&v41, 0);
    v2 = a2;
LABEL_10:
    *((_BYTE *)this + 448 * v6 + 1) = v39;
    if (v40)
    {
      v15 = (char *)this + 448 * v6;
      v18 = (_BYTE *)*((_QWORD *)v15 + 17);
      v16 = v15 + 136;
      v17 = (unint64_t)v18;
      v20 = v16 + 8;
      v19 = (char *)*((_QWORD *)v16 + 1);
      v21 = (char *)(v19 - v18);
      if ((unint64_t)(v19 - v18) > 0x7F)
      {
        if (v21 != (char *)128)
          *v20 = v17 + 128;
      }
      else
      {
        v22 = 128 - (_QWORD)v21;
        v23 = (char *)this + 448 * v6;
        v26 = *((_QWORD *)v23 + 19);
        v25 = v23 + 152;
        v24 = v26;
        if (v26 - (uint64_t)v19 >= (unint64_t)(128 - (_QWORD)v21))
        {
          bzero(*((void **)v16 + 1), 128 - (_QWORD)v21);
          *v20 = &v19[v22];
        }
        else
        {
          v27 = v24 - v17;
          v28 = 2 * v27;
          if (2 * v27 <= 0x80)
            v28 = 128;
          if (v27 >= 0x3FFFFFFFFFFFFFFFLL)
            v29 = 0x7FFFFFFFFFFFFFFFLL;
          else
            v29 = v28;
          v36 = v29;
          v37 = v25;
          v30 = (char *)operator new(v29);
          v31 = &v21[(_QWORD)v30];
          bzero(v31, v22);
          if (v19 == (char *)v17)
          {
            v33 = v37;
          }
          else
          {
            v32 = &v19[~v17];
            v33 = v37;
            do
            {
              v34 = *--v19;
              (v32--)[(_QWORD)v30] = v34;
            }
            while (v19 != (char *)v17);
            v19 = *(char **)v16;
            v31 = v30;
          }
          *(_QWORD *)v16 = v31;
          *v20 = v30 + 128;
          *(_QWORD *)v33 = &v30[v36];
          v2 = a2;
          if (v19)
            operator delete(v19);
        }
      }
    }
    MIDI::ChannelState::clear((MIDI::ChannelState *)v7);
    ++v6;
  }
  while (v6 != 16);
  return this;
}

void sub_1D4ECC9F0(_Unwind_Exception *a1)
{
  uint64_t v1;
  MIDI::ChannelState *v3;
  uint64_t v4;
  uint64_t v5;

  v3 = (MIDI::ChannelState *)(v1 + 6720);
  v4 = -7168;
  do
  {
    MIDI::ChannelState::~ChannelState(v3);
    v3 = (MIDI::ChannelState *)(v5 - 448);
    v4 += 448;
  }
  while (v4);
  _Unwind_Resume(a1);
}

void MIDI::ChannelState::~ChannelState(MIDI::ChannelState *this)
{
  void *v2;

  std::unique_ptr<std::map<unsigned short,unsigned short>>::reset[abi:ne180100]((uint64_t *)this + 55, 0);
  v2 = (void *)*((_QWORD *)this + 17);
  if (v2)
  {
    *((_QWORD *)this + 18) = v2;
    operator delete(v2);
  }
}

uint64_t *MIDI::StreamState::clear(MIDI::StreamState *this)
{
  uint64_t v2;
  uint64_t *result;

  v2 = 16;
  do
  {
    result = MIDI::ChannelState::clear(this);
    this = (MIDI::StreamState *)((char *)this + 448);
    --v2;
  }
  while (v2);
  return result;
}

uint64_t MIDI::StreamState::update_with_v1_packets(uint64_t result, _DWORD *a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BYTE *v10;
  char v11;
  int v12;
  unsigned __int16 v13;
  unsigned __int16 v14;

  if (a3)
  {
    v4 = result;
    v5 = 4 * a3;
    do
    {
      v6 = *a2;
      if ((HIWORD(*a2) & 0xF0u) - 128 <= 0x6F)
      {
        v7 = (v6 >> 8) & 0x7F;
        switch((v6 >> 20) & 0xF)
        {
          case 8u:
            goto LABEL_9;
          case 9u:
            if (*a2)
            {
              if (*(_BYTE *)(v4 + 448 * ((v6 >> 16) & 0xF) + 1))
                *(_BYTE *)(*(_QWORD *)(v4 + 448 * (((unint64_t)*a2 >> 16) & 0xF) + 136)
                         + *a2) = BYTE1(*a2) & 0x7F;
              v8 = v4 + 448 * ((v6 >> 16) & 0xF) + v7;
              ++*(_BYTE *)(v8 + 4);
            }
            else
            {
LABEL_9:
              if (*(_BYTE *)(v4 + 448 * ((v6 >> 16) & 0xF) + 1))
                *(_BYTE *)(*(_QWORD *)(v4 + 448 * (((unint64_t)*a2 >> 16) & 0xF) + 136)
                         + *a2) = 0;
              v9 = v4 + 448 * ((v6 >> 16) & 0xF) + v7;
              v12 = *(unsigned __int8 *)(v9 + 4);
              v10 = (_BYTE *)(v9 + 4);
              v11 = v12;
              if (v12)
                *v10 = v11 - 1;
            }
            break;
          case 0xAu:
            *(_BYTE *)(v4 + 448 * ((v6 >> 16) & 0xF) + v7 + 160) = v6;
            break;
          case 0xBu:
            result = MIDI::ControlState::interpret_control((MIDI::ControlState *)(v4 + 448 * (((unint64_t)*a2 >> 16) & 0xF) + 296), v7, *a2, &v14, &v13);
            break;
          case 0xCu:
            *(_BYTE *)(v4 + 448 * ((v6 >> 16) & 0xF) + 3) = BYTE1(v6) & 0x7F;
            break;
          case 0xDu:
            *(_BYTE *)(v4 + 448 * ((v6 >> 16) & 0xF) + 2) = BYTE1(v6) & 0x7F;
            break;
          case 0xEu:
            *(_WORD *)(v4 + 448 * (((unint64_t)*a2 >> 16) & 0xF) + 288) = (*a2 >> 8) & 0x7F | (*a2 << 7);
            break;
          default:
            break;
        }
      }
      ++a2;
      v5 -= 4;
    }
    while (v5);
  }
  return result;
}

uint64_t *MIDI::StreamState::reset(MIDI::StreamState *this, MIDI::Packetizer *a2)
{
  uint64_t v4;
  char *v5;
  uint64_t v6;
  unsigned __int8 *v7;
  unsigned int v8;
  uint64_t v9;
  char *v10;
  int v11;
  uint64_t *result;
  char *v13;

  v4 = 0;
  v5 = (char *)this + 160;
  do
  {
    v13 = v5;
    v6 = 0;
    v7 = (unsigned __int8 *)this + 448 * v4;
    do
    {
      if (*((_BYTE *)this + 448 * v4 + v6 + 4))
      {
        v8 = *((unsigned __int8 *)this + 448 * v4 + v6 + 4) + 1;
        do
        {
          MIDI::Packetizer::add(a2, 0, ((_DWORD)v6 << 8) | (*v7 << 16) | 0x20080040);
          --v8;
        }
        while (v8 > 1);
      }
      ++v6;
    }
    while (v6 != 128);
    v9 = 0;
    v10 = v13;
    do
    {
      v11 = *v10++;
      if ((v11 & 0x80000000) == 0)
        MIDI::Packetizer::add(a2, 0, v9 | (*v7 << 16) | 0x200A0000);
      v9 += 256;
    }
    while (v9 != 0x8000);
    if (*((char *)this + 448 * v4 + 372) >= 1)
      MIDI::Packetizer::add(a2, 0, (*((unsigned __int8 *)this + 448 * v4 + 300) << 16) | 0x200B4000);
    if ((*((char *)this + 448 * v4 + 2) & 0x80000000) == 0)
      MIDI::Packetizer::add(a2, 0, (*v7 << 16) | 0x200D0000);
    if (*((__int16 *)this + 224 * v4 + 144) != -1)
      MIDI::Packetizer::add(a2, 0, (*v7 << 16) | 0x200E0040);
    result = MIDI::ChannelState::clear((MIDI::StreamState *)((char *)this + 448 * v4++));
    v5 = v13 + 448;
  }
  while (v4 != 16);
  return result;
}

uint64_t MIDI::StreamState::chase(uint64_t this, MIDI::Packetizer *a2)
{
  uint64_t v3;
  uint64_t v4;
  char *v5;
  uint64_t v6;
  unsigned __int8 *v7;
  unsigned int v8;
  unsigned __int8 *v9;
  int v10;
  uint64_t v11;
  int v12;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  int v21;
  unsigned int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  _DWORD *v26;
  _QWORD *v27;
  _QWORD *v28;
  BOOL v29;
  int v30;
  uint64_t i;
  int v32;
  uint64_t j;
  unsigned int v34;
  unsigned int v35;
  int v36;
  unsigned int v37;
  uint64_t v38;

  v3 = this;
  v4 = 0;
  v38 = *MEMORY[0x1E0C80C00];
  v5 = (char *)a2 + 1088;
  v6 = this;
  do
  {
    v7 = (unsigned __int8 *)(v3 + 448 * v4);
    if (((char)v7[2] & 0x80000000) == 0)
      this = MIDI::Packetizer::add(a2, 0, (v7[2] << 8) | (*v7 << 16) | 0x200D0000u);
    v8 = *(unsigned __int16 *)(v3 + 448 * v4 + 288);
    if (v8 != 0xFFFF)
      this = MIDI::Packetizer::add(a2, 0, ((v8 & 0x7F) << 8) | (*v7 << 16) | (v8 >> 7) | 0x200E0000);
    v9 = (unsigned __int8 *)(v3 + 448 * v4 + 300);
    v10 = 32512;
    v11 = 435;
    do
    {
      if ((*(char *)(v6 + v11) & 0x80000000) == 0)
        this = MIDI::Packetizer::add(a2, 0, (v10 + *(unsigned __int8 *)(v6 + v11)) | (*v9 << 16) | 0x200B0000u);
      --v11;
      v10 -= 256;
    }
    while ((unint64_t)(v11 - 307) > 0x78);
    v12 = 0;
    do
    {
      switch(v12)
      {
        case 6:
          continue;
        case 96:
          goto LABEL_16;
        case 38:
          if ((*(_BYTE *)(v3 + 448 * v4 + 296) & 0x40) == 0)
          {
            v12 = 38;
            continue;
          }
LABEL_16:
          v12 = 101;
          continue;
      }
      if ((*(char *)(v3 + 448 * v4 + v12 + 308) & 0x80000000) == 0)
        this = MIDI::Packetizer::add(a2, 0, *(unsigned __int8 *)(v3 + 448 * v4 + v12 + 308) | (v12 << 8) | (*v9 << 16) | 0x200B0000u);
    }
    while (v12++ < 119);
    v14 = *(_QWORD **)(v3 + 448 * v4 + 440);
    if (v14)
    {
      v17 = (_QWORD *)*v14;
      v16 = v14 + 1;
      v15 = v17;
      if (v17 != v16)
      {
        this = *((_QWORD *)a2 + 7);
        while (1)
        {
          v18 = *((unsigned __int16 *)v15 + 13);
          v19 = *((unsigned __int16 *)v15 + 14);
          v20 = (v18 & 0x4000) != 0 ? 25856 : 25344;
          v21 = (*v9 << 16) | 0xB0000;
          v22 = v20 & 0xFFFFFF80 | (v18 >> 7) & 0x7F | v21 | 0x20000000;
          v34 = v22;
          v35 = (v20 & 0xFFFFFF80 | v18 & 0x7F | v21) + 536870656;
          v36 = v21 | (v19 >> 7) | 0x20000600;
          v37 = v21 & 0xFFFFFF80 | v19 & 0x7F | 0x20002600;
          v23 = *((_DWORD *)a2 + 17);
          if (!this || !v23)
            break;
          v24 = *(unsigned int *)(this + 8);
          if (v24 < 2 || *(_DWORD *)(this + 12) >> 28 != 3)
            goto LABEL_33;
LABEL_35:
          this += 4 * v24 + 12;
LABEL_36:
          if (this + 28 <= (unint64_t)v5)
          {
            LODWORD(v25) = 0;
            *((_DWORD *)a2 + 17) = v23 + 1;
            *(_QWORD *)this = 0;
            *(_DWORD *)(this + 8) = 0;
LABEL_40:
            v26 = (_DWORD *)(this + 4 * v25);
            v26[3] = v22;
            v26[4] = v35;
            v26[5] = v36;
            v26[6] = v37;
            *(_DWORD *)(this + 8) = v25 + 4;
            goto LABEL_41;
          }
LABEL_39:
          this = MIDI::PacketizerBase<MIDI::EventList>::begin_new_packet((uint64_t)a2, 0, (int *)&v34, 4);
LABEL_41:
          *((_QWORD *)a2 + 7) = this;
          v27 = (_QWORD *)v15[1];
          if (v27)
          {
            do
            {
              v28 = v27;
              v27 = (_QWORD *)*v27;
            }
            while (v27);
          }
          else
          {
            do
            {
              v28 = (_QWORD *)v15[2];
              v29 = *v28 == (_QWORD)v15;
              v15 = v28;
            }
            while (!v29);
          }
          v15 = v28;
          if (v28 == v16)
            goto LABEL_47;
        }
        if (!v23)
          goto LABEL_36;
        if (!this)
          goto LABEL_38;
LABEL_33:
        if (!*(_QWORD *)this)
        {
LABEL_38:
          v25 = *(unsigned int *)(this + 8);
          if (this + 4 * v25 + 28 <= (unint64_t)v5)
            goto LABEL_40;
          goto LABEL_39;
        }
        v24 = *(unsigned int *)(this + 8);
        goto LABEL_35;
      }
    }
LABEL_47:
    if ((*(char *)(v3 + 448 * v4 + 3) & 0x80000000) == 0)
      this = MIDI::Packetizer::add(a2, 0, (*(unsigned __int8 *)(v3 + 448 * v4 + 3) << 8) | (*v7 << 16) | 0x200C0000u);
    if (*(_BYTE *)(v3 + 448 * v4 + 1))
    {
      v30 = 0;
      for (i = 0; i != 128; ++i)
      {
        if (*(char *)(*(_QWORD *)(v3 + 448 * v4 + 136) + i) >= 1)
          this = MIDI::Packetizer::add(a2, 0, (v30 + *(unsigned __int8 *)(*(_QWORD *)(v3 + 448 * v4 + 136) + i)) | (*v7 << 16) | 0x20090000u);
        v30 += 256;
      }
    }
    v32 = 0;
    for (j = 160; j != 288; ++j)
    {
      if ((*(char *)(v6 + j) & 0x80000000) == 0)
        this = MIDI::Packetizer::add(a2, 0, (v32 + *(unsigned __int8 *)(v6 + j)) | (*v7 << 16) | 0x200A0000u);
      v32 += 256;
    }
    ++v4;
    v6 += 448;
  }
  while (v4 != 16);
  return this;
}

uint64_t MIDIObject::GetProperty(MIDIObject *this, const __CFString *key, const void **a3, int a4)
{
  const __CFDictionary *v8;
  const void *Value;
  uint64_t v11;
  BOOL v12;

  v8 = (const __CFDictionary *)*((_QWORD *)this + 3);
  if (v8 && (Value = CFDictionaryGetValue(v8, key)) != 0)
  {
    *a3 = Value;
    CFRetain(Value);
    return 0;
  }
  else
  {
    v11 = *((_QWORD *)this + 2);
    if (v11)
      v12 = a4 == 0;
    else
      v12 = 1;
    if (v12)
    {
      *a3 = 0;
      return 4294956461;
    }
    else
    {
      return (*(uint64_t (**)(uint64_t, const __CFString *, const void **, uint64_t))(*(_QWORD *)v11 + 32))(v11, key, a3, 1);
    }
  }
}

uint64_t MIDIObject::SetProperty(const __CFDictionary **this, const __CFString *key, const void *a3)
{
  const __CFDictionary *v6;
  const void *Value;
  __CFDictionary *Mutable;
  const __CFDictionary *v10;

  if (!a3)
    return (*((uint64_t (**)(const __CFDictionary **, const __CFString *))*this + 6))(this, key);
  v6 = this[3];
  if (!v6)
    goto LABEL_8;
  Value = CFDictionaryGetValue(v6, key);
  if (Value && CFEqual(Value, a3))
    return 0;
  Mutable = this[3];
  if (!Mutable)
  {
LABEL_8:
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (*((_BYTE *)this + 32))
    {
      v10 = this[3];
      if (v10)
        CFRelease(v10);
    }
    this[3] = Mutable;
    *((_BYTE *)this + 33) = 1;
  }
  CFDictionarySetValue(Mutable, key, a3);
  return 1;
}

uint64_t MIDIObject::RemoveProperty(MIDIObject *this, const __CFString *a2)
{
  uint64_t result;

  result = *((_QWORD *)this + 3);
  if (result)
  {
    result = CFDictionaryContainsKey((CFDictionaryRef)result, a2);
    if ((_DWORD)result)
    {
      CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)this + 3), a2);
      return 1;
    }
  }
  return result;
}

void MIDIObject::MIDIObject(MIDIObject *this, MIDIObject *a2, const __CFString *a3)
{
  uint64_t v6;

  BaseOpaqueObject::BaseOpaqueObject(this);
  *(_QWORD *)v6 = off_1E98B9320;
  *(_QWORD *)(v6 + 16) = a2;
  *(_QWORD *)(v6 + 24) = 0;
  *(_WORD *)(v6 + 32) = 1;
  *(_WORD *)(v6 + 40) = 0;
  if (a3)
    MIDIObject::SetProperty((const __CFDictionary **)this, kMIDIPropertyName, a3);
}

void sub_1D4ECD3C8(_Unwind_Exception *a1)
{
  BaseOpaqueObject *v1;
  uint64_t v2;

  XCFObject<__CFDictionary const*>::~XCFObject(v2);
  BaseOpaqueObject::~BaseOpaqueObject(v1);
  _Unwind_Resume(a1);
}

uint64_t XCFObject<__CFDictionary const*>::~XCFObject(uint64_t a1)
{
  const void *v2;

  if (*(_BYTE *)(a1 + 8))
  {
    v2 = *(const void **)a1;
    if (*(_QWORD *)a1)
      CFRelease(v2);
  }
  return a1;
}

CFMutableDictionaryRef MIDIObject::ToDictionary(CFDictionaryRef theDict)
{
  if (theDict)
    return CFDictionaryCreateMutableCopy(0, 0, theDict);
  else
    return CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
}

void MIDIObject::FromDictionary(MIDIObject *this, CFDictionaryRef theDict)
{
  const void *v4;
  CFMutableDictionaryRef MutableCopy;
  const void *v6;

  if (*((_BYTE *)this + 32))
  {
    v4 = (const void *)*((_QWORD *)this + 3);
    if (v4)
      CFRelease(v4);
  }
  *((_QWORD *)this + 3) = 0;
  *((_BYTE *)this + 33) = 0;
  if (CFDictionaryGetCount(theDict) >= 1)
  {
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, theDict);
    if (*((_BYTE *)this + 32))
    {
      v6 = (const void *)*((_QWORD *)this + 3);
      if (v6)
        CFRelease(v6);
    }
    *((_QWORD *)this + 3) = MutableCopy;
    *((_BYTE *)this + 33) = 1;
  }
}

uint64_t MIDIObject::SetProperty(MIDIObject *this, const __CFString *a2, int a3)
{
  CFNumberRef v5;
  uint64_t v6;
  int valuePtr;

  valuePtr = a3;
  v5 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  v6 = (*(uint64_t (**)(MIDIObject *, const __CFString *, CFNumberRef))(*(_QWORD *)this + 40))(this, a2, v5);
  CFRelease(v5);
  return v6;
}

uint64_t MIDIObject::GetIntegerProperty(MIDIObject *this, const __CFString *a2, int *a3)
{
  uint64_t v4;
  CFTypeID v5;
  CFTypeID TypeID;
  CFTypeRef v7;
  CFTypeRef cf;

  cf = 0;
  *a3 = 0;
  v4 = (*(uint64_t (**)(MIDIObject *, const __CFString *, CFTypeRef *))(*(_QWORD *)this + 32))(this, a2, &cf);
  if (!(_DWORD)v4)
  {
    v5 = CFGetTypeID(cf);
    TypeID = CFNumberGetTypeID();
    v7 = cf;
    if (v5 == TypeID)
    {
      CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt32Type, a3);
      v4 = 0;
      v7 = cf;
    }
    else
    {
      v4 = 4294956460;
    }
    CFRelease(v7);
  }
  return v4;
}

uint64_t MIDIObject::GetStringProperty(MIDIObject *this, const __CFString *a2, const __CFString **a3)
{
  uint64_t v4;
  CFTypeID v5;
  CFTypeID TypeID;
  const __CFString *v7;
  CFTypeRef cf;

  cf = 0;
  v4 = (*(uint64_t (**)(MIDIObject *, const __CFString *, CFTypeRef *, uint64_t))(*(_QWORD *)this + 32))(this, a2, &cf, 1);
  if (!(_DWORD)v4)
  {
    v5 = CFGetTypeID(cf);
    TypeID = CFStringGetTypeID();
    v7 = (const __CFString *)cf;
    if (v5 == TypeID)
    {
      v4 = 0;
    }
    else
    {
      CFRelease(cf);
      v7 = 0;
      v4 = 4294956460;
    }
    *a3 = v7;
  }
  return v4;
}

uint64_t MIDIObject::GetIntegerOrDataProperty(MIDIObject *this, const __CFString *a2, const __CFData **a3, int *a4)
{
  uint64_t result;
  CFTypeID v7;
  CFTypeID TypeID;
  const __CFData *v9;
  CFTypeID v10;
  CFTypeID v11;
  CFTypeRef v12;
  unsigned int *BytePtr;
  unsigned int valuePtr;
  CFTypeRef cf;

  cf = 0;
  result = (*(uint64_t (**)(MIDIObject *, const __CFString *, CFTypeRef *, uint64_t))(*(_QWORD *)this + 32))(this, a2, &cf, 1);
  if (!(_DWORD)result)
  {
    v7 = CFGetTypeID(cf);
    TypeID = CFDataGetTypeID();
    v9 = (const __CFData *)cf;
    if (v7 != TypeID)
    {
      v10 = CFGetTypeID(cf);
      v11 = CFNumberGetTypeID();
      v12 = cf;
      if (v10 != v11)
      {
        CFRelease(cf);
        return 4294956460;
      }
      valuePtr = 0;
      CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt32Type, &valuePtr);
      CFRelease(v12);
      valuePtr = bswap32(valuePtr);
      if (a3)
        *a3 = CFDataCreate(0, (const UInt8 *)&valuePtr, 4);
      if (a4)
        *a4 = valuePtr;
      return 0;
    }
    if (a3)
    {
      *a3 = (const __CFData *)cf;
      if (!a4)
        return 0;
    }
    else
    {
      CFRelease(cf);
      if (!a4)
        return 0;
    }
    BytePtr = (unsigned int *)CFDataGetBytePtr(v9);
    result = 0;
    *a4 = bswap32(*BytePtr);
  }
  return result;
}

CFTypeRef DictGetAndDelete(__CFDictionary *a1, const __CFString *a2)
{
  CFTypeRef result;
  CFTypeRef v5;

  result = CFDictionaryGetValue(a1, a2);
  if (result)
  {
    v5 = CFRetain(result);
    CFDictionaryRemoveValue(a1, a2);
    return v5;
  }
  return result;
}

void midi::ci::message::make_with_payload_size(midi::ci::message *this, uint64_t a2, char a3, unsigned int a4, unsigned int a5, char a6)
{
  char *v11;
  char __src[12];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)this = 8257536;
  *((_QWORD *)this + 1) = 0;
  v11 = (char *)this + 8;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  std::vector<unsigned char>::reserve((unint64_t *)this + 1, a2 + 12);
  __src[0] = a6;
  __src[1] = 13;
  __src[2] = a3;
  __src[3] = 2;
  __src[4] = a4 & 0x7F;
  __src[5] = (a4 >> 7) & 0x7F;
  __src[6] = (a4 >> 14) & 0x7F;
  __src[7] = (a4 >> 21) & 0x7F;
  __src[8] = a5 & 0x7F;
  __src[9] = (a5 >> 7) & 0x7F;
  __src[10] = (a5 >> 14) & 0x7F;
  __src[11] = (a5 >> 21) & 0x7F;
  std::vector<unsigned char>::__insert_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((uint64_t)v11, *((char **)this + 2), __src, (char *)&v13, 12);
}

void sub_1D4ECD8B0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 16) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

BOOL midi::ci::profile_inquiry_reply_view::validate(uint64_t a1)
{
  _BYTE *v1;
  unint64_t v2;
  unint64_t v3;

  if (*(_DWORD *)a1 == 8257536
    && (v1 = *(_BYTE **)(a1 + 8), v2 = *(_QWORD *)(a1 + 16) - (_QWORD)v1, v2 >= 0x10)
    && v1[1] == 13
    && v1[2] == 33
    && (v3 = 5 * (v1[12] | ((unint64_t)v1[13] << 7)), v2 >= v3 + 16))
  {
    return v2 >= 5 * (v1[v3 + 14] | ((unint64_t)v1[v3 + 15] << 7)) + v3 + 16;
  }
  else
  {
    return 0;
  }
}

void midi::ci::profile_inquiry_reply_view::make_profiles(midi::ci::profile_inquiry_reply_view *this, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v7;
  _BYTE *v9;
  int v10;
  int v11;
  uint64_t v12;
  char *v13;
  midi::ci::profile_inquiry_reply_view *v14;
  char v15;
  char v16;
  char v17;
  char v18;
  char v19;
  unint64_t v20;
  _BYTE *v21;
  _BYTE *v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  _BYTE *v28;
  _BYTE *v29;
  int v30;
  char v31;
  midi::ci::profile_inquiry_reply_view *v32;
  int v33;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  v3 = *(_QWORD *)(*(_QWORD *)a2 + 8);
  v4 = *(_QWORD *)(*(_QWORD *)a2 + 16) - v3;
  v5 = a3 + 1;
  if (v4 <= a3 + 1)
    __assert_rtn("make_profiles", "capability_inquiry.cpp", 173, "sx.data.size() > pos + 1");
  v7 = *(unsigned __int8 *)(v3 + a3) | (*(unsigned __int8 *)(v3 + v5) << 7);
  if (v4 <= v7 + 4 * v7 + v5)
    __assert_rtn("make_profiles", "capability_inquiry.cpp", 176, "sx.data.size() > pos + 1 + num_profiles * sizeof(profile_id)");
  if ((_DWORD)v7)
  {
    v33 = *(unsigned __int8 *)(v3 + a3) | (*(unsigned __int8 *)(v3 + v5) << 7);
    v9 = std::__allocate_at_least[abi:ne180100]<std::allocator<midi::ci::profile_id>>(v7);
    v10 = v33;
    v11 = 0;
    *(_QWORD *)this = v9;
    *((_QWORD *)this + 1) = v9;
    v13 = (char *)(*(_QWORD *)(*(_QWORD *)a2 + 8) + a3 + 2);
    v14 = this;
    *((_QWORD *)this + 2) = &v9[5 * v12];
    do
    {
      v15 = *v13;
      v16 = v13[1];
      v17 = v13[2];
      v18 = v13[3];
      v19 = v13[4];
      v20 = *((_QWORD *)v14 + 2);
      if ((unint64_t)v9 >= v20)
      {
        v22 = *(_BYTE **)v14;
        v23 = 0xCCCCCCCCCCCCCCCDLL * (_QWORD)&v9[-*(_QWORD *)v14];
        v24 = v23 + 1;
        if (v23 + 1 >= 0x3333333333333334)
          std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
        v25 = 0xCCCCCCCCCCCCCCCDLL * (v20 - (_QWORD)v22);
        if (2 * v25 > v24)
          v24 = 2 * v25;
        if (v25 >= 0x1999999999999999)
          v26 = 0x3333333333333333;
        else
          v26 = v24;
        if (v26)
          v26 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<midi::ci::profile_id>>(v26);
        else
          v27 = 0;
        v28 = (_BYTE *)(v26 + 5 * v23);
        *v28 = v15;
        v28[1] = v16;
        v28[2] = v17;
        v28[3] = v18;
        v28[4] = v19;
        v29 = v28;
        if (v9 == v22)
        {
          v32 = this;
        }
        else
        {
          do
          {
            v30 = *(_DWORD *)(v9 - 5);
            v9 -= 5;
            v31 = v9[4];
            *(_DWORD *)(v29 - 5) = v30;
            v29 -= 5;
            v29[4] = v31;
          }
          while (v9 != v22);
          v32 = this;
          v9 = *(_BYTE **)this;
        }
        v21 = v28 + 5;
        *(_QWORD *)v32 = v29;
        *((_QWORD *)v32 + 1) = v28 + 5;
        *((_QWORD *)v32 + 2) = v26 + 5 * v27;
        if (v9)
        {
          operator delete(v9);
          v14 = this;
        }
        else
        {
          v14 = v32;
        }
        v10 = v33;
      }
      else
      {
        *v9 = v15;
        v9[1] = v16;
        v9[2] = v17;
        v9[3] = v18;
        v21 = v9 + 5;
        v9[4] = v19;
      }
      *((_QWORD *)v14 + 1) = v21;
      v13 += 5;
      ++v11;
      v9 = v21;
    }
    while (v11 != v10);
  }
}

void sub_1D4ECDBA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  void *v10;

  if (v10)
  {
    *(_QWORD *)(a10 + 8) = v10;
    operator delete(v10);
  }
  _Unwind_Resume(exception_object);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<midi::ci::profile_id>>(unint64_t a1)
{
  if (a1 >= 0x3333333333333334)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(5 * a1);
}

BOOL midi::ci::property_exchange::property_data_message_view::validate(uint64_t a1)
{
  _BYTE *v1;
  unint64_t v2;
  unsigned int v3;
  unsigned int v4;
  unsigned __int8 *v5;
  unsigned int v6;
  BOOL v7;
  BOOL v8;
  unsigned int v9;
  BOOL v10;

  if (*(_DWORD *)a1 != 8257536)
    return 0;
  v1 = *(_BYTE **)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16) - (_QWORD)v1;
  if (v2 < 0x15)
    return 0;
  if (v1[1] != 13)
    return 0;
  v3 = v1[2];
  if (v3 < 0x34 || v3 >= 0x3A && v3 != 63)
    return 0;
  v4 = v1[13] | (v1[14] << 7);
  if (v2 < v4 + 21)
    return 0;
  v5 = &v1[v4];
  v6 = v5[17] | (v5[18] << 7);
  if (v6 > (v5[15] | (v5[16] << 7)))
    return 0;
  if (v4)
  {
    v7 = v6 != 0;
    v8 = v6 == 1;
  }
  else
  {
    v7 = 0;
    v8 = 0;
  }
  if ((v8 || !v7) && ((v9 = v5[19] | (v5[20] << 7)) != 0 ? (v10 = v6 == 0) : (v10 = 0), !v10))
    return v4 + 21 + (unint64_t)v9 <= v2;
  else
    return 0;
}

void UMPStream::FunctionBlock::~FunctionBlock(void **this)
{
  if (*((char *)this + 95) < 0)
    operator delete(this[9]);
  *this = off_1E98B9320;
  XCFObject<__CFDictionary const*>::~XCFObject((uint64_t)(this + 3));
  BaseOpaqueObject::~BaseOpaqueObject((BaseOpaqueObject *)this);
}

{
  if (*((char *)this + 95) < 0)
    operator delete(this[9]);
  *this = off_1E98B9320;
  XCFObject<__CFDictionary const*>::~XCFObject((uint64_t)(this + 3));
  BaseOpaqueObject::~BaseOpaqueObject((BaseOpaqueObject *)this);
  JUMPOUT(0x1D826BA98);
}

void UMPStream::FunctionBlock::deserialize(std::string *this@<X0>, const __CFDictionary **a2@<X1>, uint64_t a3@<X8>)
{
  const __CFNumber *v6;
  unint64_t v7;
  std::string::value_type v8;
  const __CFNumber *v9;
  int v10;
  unint64_t v11;
  int v12;
  unsigned __int16 v13;
  std::string::value_type v14;
  unsigned __int16 v15;
  std::string::value_type v16;
  unsigned __int16 v17;
  std::string::value_type v18;
  const __CFNumber *v19;
  int v20;
  unint64_t v21;
  int v22;
  const __CFNumber *v23;
  int v24;
  unint64_t v25;
  int v26;
  unsigned __int16 v27;
  std::string::value_type v28;
  const __CFNumber *v29;
  int v30;
  unint64_t v31;
  int v32;
  const __CFNumber *v33;
  unsigned __int8 v34;
  uint64_t v35;
  uint64_t v36;
  void *exception;
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  void *v46;
  void *v47;
  void *__p[2];
  char v49;
  std::string __str;
  char v51;

  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)a3 = a3 + 8;
  std::string::basic_string[abi:ne180100]<0>(__p, "name");
  if (!*a2)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  applesauce::CF::details::find_at_key_or_optional<std::string,std::string const&>((uint64_t)&__str, *a2, (const UInt8 *)__p);
  if (v51)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t **)a3, __p, (uint64_t)__p);
  }
  else
  {
    __str.__r_.__value_.__s.__data_[0] = 0;
    v51 = 0;
  }
  if (v49 < 0)
    operator delete(__p[0]);
  if (v51)
  {
    std::string::operator=(this + 3, &__str);
    if (v51)
    {
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__str.__r_.__value_.__l.__data_);
    }
  }
  std::string::basic_string[abi:ne180100]<0>(&__str, "id");
  if (!*a2)
  {
    v38 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v38, "Could not construct");
  }
  v6 = applesauce::CF::DictionaryRef_proxy::at_as<unsigned int,std::string const&>(*a2, (const UInt8 *)&__str);
  v7 = (unint64_t)v6 >> 32;
  if ((unint64_t)v6 >> 32)
  {
    v8 = (char)v6;
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t **)a3, (void **)&__str.__r_.__value_.__l.__data_, (uint64_t)&__str);
  }
  else
  {
    v8 = 0;
  }
  if ((SHIBYTE(__str.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (!v7)
      goto LABEL_18;
    goto LABEL_17;
  }
  operator delete(__str.__r_.__value_.__l.__data_);
  if (v7)
LABEL_17:
    this[4].__r_.__value_.__s.__data_[0] = v8;
LABEL_18:
  std::string::basic_string[abi:ne180100]<0>(&__str, "direction");
  if (!*a2)
  {
    v39 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v39, "Could not construct");
  }
  v9 = applesauce::CF::DictionaryRef_proxy::at_as<int,std::string const&>(*a2, (const UInt8 *)&__str);
  v10 = (int)v9;
  v11 = (unint64_t)v9 >> 32;
  if ((unint64_t)v9 >> 32)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t **)a3, (void **)&__str.__r_.__value_.__l.__data_, (uint64_t)&__str);
    v12 = v10;
  }
  else
  {
    v12 = 0;
  }
  if ((SHIBYTE(__str.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (!v11)
      goto LABEL_25;
    goto LABEL_24;
  }
  operator delete(__str.__r_.__value_.__l.__data_);
  if (v11)
LABEL_24:
    HIDWORD(this[4].__r_.__value_.__r.__words[0]) = v12 | v10 & 0xFFFFFF00;
LABEL_25:
  std::string::basic_string[abi:ne180100]<0>(&__str, "first_group");
  if (!*a2)
  {
    v40 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v40, "Could not construct");
  }
  v13 = applesauce::CF::details::find_at_key_or_optional<unsigned char,std::string const&>(*a2, (const UInt8 *)&__str);
  if (v13 >= 0x100u)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t **)a3, (void **)&__str.__r_.__value_.__l.__data_, (uint64_t)&__str);
    v14 = v13;
  }
  else
  {
    v14 = 0;
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  if (v13 >= 0x100u)
    this[4].__r_.__value_.__s.__data_[8] = v14;
  std::string::basic_string[abi:ne180100]<0>(&__str, "groups_spanned");
  if (!*a2)
  {
    v41 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v41, "Could not construct");
  }
  v15 = applesauce::CF::details::find_at_key_or_optional<unsigned char,std::string const&>(*a2, (const UInt8 *)&__str);
  if (v15 >= 0x100u)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t **)a3, (void **)&__str.__r_.__value_.__l.__data_, (uint64_t)&__str);
    v16 = v15;
  }
  else
  {
    v16 = 0;
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  if (v15 >= 0x100u)
    this[4].__r_.__value_.__s.__data_[9] = v16;
  std::string::basic_string[abi:ne180100]<0>(&__str, "max_sysex8_stream");
  if (!*a2)
  {
    v42 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v42, "Could not construct");
  }
  v17 = applesauce::CF::details::find_at_key_or_optional<unsigned char,std::string const&>(*a2, (const UInt8 *)&__str);
  if (v17 >= 0x100u)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t **)a3, (void **)&__str.__r_.__value_.__l.__data_, (uint64_t)&__str);
    v18 = v17;
  }
  else
  {
    v18 = 0;
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  if (v17 >= 0x100u)
    this[4].__r_.__value_.__s.__data_[10] = v18;
  std::string::basic_string[abi:ne180100]<0>(&__str, "midi1_info");
  if (!*a2)
  {
    v43 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v43, "Could not construct");
  }
  v19 = applesauce::CF::DictionaryRef_proxy::at_as<int,std::string const&>(*a2, (const UInt8 *)&__str);
  v20 = (int)v19;
  v21 = (unint64_t)v19 >> 32;
  if ((unint64_t)v19 >> 32)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t **)a3, (void **)&__str.__r_.__value_.__l.__data_, (uint64_t)&__str);
    v22 = v20;
  }
  else
  {
    v22 = 0;
  }
  if ((SHIBYTE(__str.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (!v21)
      goto LABEL_56;
    goto LABEL_55;
  }
  operator delete(__str.__r_.__value_.__l.__data_);
  if (v21)
LABEL_55:
    HIDWORD(this[4].__r_.__value_.__r.__words[1]) = v22 | v20 & 0xFFFFFF00;
LABEL_56:
  std::string::basic_string[abi:ne180100]<0>(&__str, "ui_hint");
  if (!*a2)
  {
    v44 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v44, "Could not construct");
  }
  v23 = applesauce::CF::DictionaryRef_proxy::at_as<int,std::string const&>(*a2, (const UInt8 *)&__str);
  v24 = (int)v23;
  v25 = (unint64_t)v23 >> 32;
  if ((unint64_t)v23 >> 32)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t **)a3, (void **)&__str.__r_.__value_.__l.__data_, (uint64_t)&__str);
    v26 = v24;
  }
  else
  {
    v26 = 0;
  }
  if ((SHIBYTE(__str.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (!v25)
      goto LABEL_63;
    goto LABEL_62;
  }
  operator delete(__str.__r_.__value_.__l.__data_);
  if (v25)
LABEL_62:
    LODWORD(this[4].__r_.__value_.__r.__words[2]) = v26 | v24 & 0xFFFFFF00;
LABEL_63:
  std::string::basic_string[abi:ne180100]<0>(&__str, "enabled");
  if (!*a2)
  {
    v45 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v45, "Could not construct");
  }
  v27 = applesauce::CF::details::find_at_key_or_optional<BOOL,std::string const&>(*a2, (const UInt8 *)&__str);
  if (v27 >= 0x100u)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t **)a3, (void **)&__str.__r_.__value_.__l.__data_, (uint64_t)&__str);
    v28 = v27;
  }
  else
  {
    v28 = 0;
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  if (v27 >= 0x100u)
    this[2].__r_.__value_.__s.__data_[16] = v28;
  std::string::basic_string[abi:ne180100]<0>(&__str, "owner");
  if (!*a2)
  {
    v46 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v46, "Could not construct");
  }
  v29 = applesauce::CF::DictionaryRef_proxy::at_as<unsigned int,std::string const&>(*a2, (const UInt8 *)&__str);
  v30 = (int)v29;
  v31 = (unint64_t)v29 >> 32;
  if ((unint64_t)v29 >> 32)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t **)a3, (void **)&__str.__r_.__value_.__l.__data_, (uint64_t)&__str);
    v32 = v30;
  }
  else
  {
    v32 = 0;
  }
  if ((SHIBYTE(__str.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (!v31)
      goto LABEL_78;
    goto LABEL_77;
  }
  operator delete(__str.__r_.__value_.__l.__data_);
  if (v31)
LABEL_77:
    HIDWORD(this[4].__r_.__value_.__r.__words[2]) = v32 | v30 & 0xFFFFFF00;
LABEL_78:
  std::string::basic_string[abi:ne180100]<0>(&__str, "timestamp");
  if (!*a2)
  {
    v47 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v47, "Could not construct");
  }
  v33 = applesauce::CF::details::find_at_key_or_optional<unsigned long long,std::string const&>(*a2, (const UInt8 *)&__str);
  v35 = v34;
  if (v34)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t **)a3, (void **)&__str.__r_.__value_.__l.__data_, (uint64_t)&__str);
    v36 = v33;
  }
  else
  {
    v36 = 0;
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  if (v35)
    this[2].__r_.__value_.__l.__size_ = v36 | (unint64_t)v33 & 0xFFFFFFFFFFFFFF00;
}

void sub_1D4ECE4B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  void *v22;
  char **v23;

  __cxa_free_exception(v22);
  if (a21 < 0)
    operator delete(__p);
  std::__tree<std::string>::destroy(*v23);
  _Unwind_Resume(a1);
}

void UMPStream::FunctionBlock::serialize(UMPStream::FunctionBlock *this@<X0>, CFDictionaryRef *a2@<X8>)
{
  _QWORD *v4;
  uint64_t v5;
  const void *v6;
  const void *v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  _QWORD v13[2];
  _BYTE v14[16];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD v23[2];
  uint64_t v24;
  uint64_t v25;
  _BYTE v26[16];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v12 = *((_DWORD *)this + 2);
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned int>((applesauce::CF::TypeRef *)v14, "object", &v12);
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,std::string const&>((applesauce::CF::TypeRef *)&v15, "name", (uint64_t)this + 72);
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned char const&>((applesauce::CF::TypeRef *)&v16, "id", (char *)this + 96);
  v11 = *((_DWORD *)this + 25);
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,int>((applesauce::CF::TypeRef *)&v17, "direction", &v11);
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned char const&>((applesauce::CF::TypeRef *)&v18, "first_group", (char *)this + 104);
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned char const&>((applesauce::CF::TypeRef *)&v19, "groups_spanned", (char *)this + 105);
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned char const&>((applesauce::CF::TypeRef *)&v20, "max_sysex8_stream", (char *)this + 106);
  v10 = *((_DWORD *)this + 27);
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,int>((applesauce::CF::TypeRef *)&v21, "midi1_info", &v10);
  v9 = *((_DWORD *)this + 28);
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,int>((applesauce::CF::TypeRef *)&v22, "ui_hint", &v9);
  applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)v23, "enabled");
  if (*((_BYTE *)this + 64))
    v4 = (_QWORD *)MEMORY[0x1E0C9AE50];
  else
    v4 = (_QWORD *)MEMORY[0x1E0C9AE40];
  v23[1] = *v4;
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned int const&>((applesauce::CF::TypeRef *)&v24, "owner", (int *)this + 29);
  v8 = 1;
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,UMPCIObjectType>((applesauce::CF::TypeRef *)&v25, "type", &v8);
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned long long const&>((applesauce::CF::TypeRef *)v26, "timestamp", (uint64_t *)this + 7);
  v13[0] = v14;
  v13[1] = 13;
  v5 = 0;
  *a2 = applesauce::CF::details::make_CFDictionaryRef((uint64_t)v13);
  do
  {
    v6 = *(const void **)&v26[v5 + 8];
    if (v6)
      CFRelease(v6);
    v7 = *(const void **)&v26[v5];
    if (v7)
      CFRelease(v7);
    v5 -= 16;
  }
  while (v5 != -208);
}

void sub_1D4ECE7F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  uint64_t i;

  for (i = 192; i != -16; i -= 16)
    applesauce::CF::TypeRefPair::~TypeRefPair((applesauce::CF::TypeRefPair *)(&a14 + i));
  _Unwind_Resume(a1);
}

uint64_t UMPStream::FunctionBlock::getUMPCIType(UMPStream::FunctionBlock *this)
{
  return 1;
}

applesauce::CF::TypeRef *applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned char const&>(applesauce::CF::TypeRef *a1, char *a2, char *a3)
{
  CFNumberRef v5;
  void *exception;
  char valuePtr;

  applesauce::CF::TypeRef::TypeRef(a1, a2);
  valuePtr = *a3;
  v5 = CFNumberCreate(0, kCFNumberCharType, &valuePtr);
  *((_QWORD *)a1 + 1) = v5;
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  return a1;
}

void sub_1D4ECE910(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  if (v3)
    CFRelease(v3);
  applesauce::CF::TypeRef::~TypeRef((const void **)v1);
  _Unwind_Resume(a1);
}

uint64_t applesauce::CF::details::find_at_key_or_optional<unsigned char,std::string const&>(const __CFDictionary *a1, const UInt8 *a2)
{
  const __CFNumber *v2;
  int v3;

  v2 = (const __CFNumber *)applesauce::CF::details::at_key<std::string const&>(a1, a2);
  if (v2)
  {
    LOWORD(v2) = applesauce::CF::convert_as<unsigned char,0>(v2);
    v3 = BYTE1(v2);
  }
  else
  {
    v3 = 0;
  }
  return v2 | (v3 << 8);
}

void MIDIClient::~MIDIClient(const void **this)
{
  MIDIClient::~MIDIClient(this);
  JUMPOUT(0x1D826BA98);
}

{
  uint64_t v2;
  MIDIObject **v3;
  MIDIObject **v4;
  MIDIObject *v5;
  int64_t v6;
  MIDIServer *v7;
  uint64_t *v8;
  int v9;
  MIDIObject **v10;
  MIDIObject **v11;
  MIDIObject *v12;
  int64_t v13;
  MIDIServer *v14;
  uint64_t *v15;
  int v16;

  *this = &off_1E98B9200;
  v2 = SetupManager::instance((SetupManager *)this);
LABEL_2:
  v4 = *(MIDIObject ***)(v2 + 8);
  v3 = *(MIDIObject ***)(v2 + 16);
  while (v4 != v3)
  {
    v5 = *v4;
    if (*((const void ***)*v4 + 6) == this)
    {
      v6 = (char *)v3 - (char *)(v4 + 1);
      if (v3 != v4 + 1)
        memmove(v4, v4 + 1, (char *)v3 - (char *)(v4 + 1));
      *(_QWORD *)(v2 + 16) = (char *)v4 + v6;
      MIDISetup::ObjectRemoved(*(MIDISetup **)v2, v5);
      v8 = MIDIServer::defaultInstance(v7) + 13;
      v9 = (*(uint64_t (**)(uint64_t *))(*v8 + 16))(v8);
      (*(void (**)(MIDIObject *))(*(_QWORD *)v5 + 8))(v5);
      if (v9)
        (*(void (**)(uint64_t *))(*v8 + 24))(v8);
      goto LABEL_2;
    }
    ++v4;
  }
LABEL_10:
  v11 = *(MIDIObject ***)(v2 + 32);
  v10 = *(MIDIObject ***)(v2 + 40);
  while (v11 != v10)
  {
    v12 = *v11;
    if (*((const void ***)*v11 + 6) == this)
    {
      v13 = (char *)v10 - (char *)(v11 + 1);
      if (v10 != v11 + 1)
        memmove(v11, v11 + 1, (char *)v10 - (char *)(v11 + 1));
      *(_QWORD *)(v2 + 40) = (char *)v11 + v13;
      MIDISetup::ObjectRemoved(*(MIDISetup **)v2, v12);
      v15 = MIDIServer::defaultInstance(v14) + 13;
      v16 = (*(uint64_t (**)(uint64_t *))(*v15 + 16))(v15);
      (*(void (**)(MIDIObject *))(*(_QWORD *)v12 + 8))(v12);
      if (v16)
        (*(void (**)(uint64_t *))(*v15 + 24))(v15);
      goto LABEL_10;
    }
    ++v11;
  }
  _Block_release(this[7]);
  OwnedPtrVector<MIDIPort *>::~OwnedPtrVector(this + 8);
  *this = off_1E98B9320;
  XCFObject<__CFDictionary const*>::~XCFObject((uint64_t)(this + 3));
  BaseOpaqueObject::~BaseOpaqueObject((BaseOpaqueObject *)this);
}

uint64_t MIDIClient::PrintObject(MIDIClient *this, __sFILE *a2)
{
  fprintf(a2, "<%s 0x%x [%p]>", "MIDIClientRef", *((_DWORD *)this + 2), this);
  fprintf(a2, " parent=0x%X", *((_QWORD *)this + 2));
  return fputc(10, a2);
}

uint64_t TOpaqueObject<MIDIClient,unsigned int,MIDIObject>::isa(uint64_t a1, void *a2)
{
  _BOOL4 v3;

  v3 = a2 == &TOpaqueRTTI<MIDIObject>::sRTTI || a2 == &BaseOpaqueObject::sBaseRTTI;
  return a2 == &TOpaqueRTTI<MIDIClient>::sRTTI || v3;
}

_QWORD *OwnedPtrVector<MIDIPort *>::~OwnedPtrVector(_QWORD *a1)
{
  char *v2;
  char *v3;
  char *v4;
  _BYTE *v5;
  uint64_t v6;
  char *v7;

  *a1 = &off_1E98B9830;
  v2 = (char *)a1[1];
  v3 = (char *)a1[2];
  if (v2 != v3)
  {
    v4 = (char *)a1[1];
    do
    {
      if (*(_QWORD *)v4)
        (*(void (**)(_QWORD))(**(_QWORD **)v4 + 8))(*(_QWORD *)v4);
      v4 += 8;
    }
    while (v4 != v3);
    v5 = (_BYTE *)a1[2];
    v6 = v5 - v3;
    if (v5 != v3)
      memmove(v2, v3, v5 - v3);
    v7 = (char *)a1[1];
    a1[2] = &v2[v6];
    v2 = v7;
  }
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void OwnedPtrVector<MIDIPort *>::~OwnedPtrVector(_QWORD *a1)
{
  OwnedPtrVector<MIDIPort *>::~OwnedPtrVector(a1);
  JUMPOUT(0x1D826BA98);
}

uint64_t TOpaqueObject<MIDIPort,unsigned int,MIDIObject>::isa(uint64_t a1, void *a2)
{
  _BOOL4 v3;

  v3 = a2 == &TOpaqueRTTI<MIDIObject>::sRTTI || a2 == &BaseOpaqueObject::sBaseRTTI;
  return a2 == &TOpaqueRTTI<MIDIPort>::sRTTI || v3;
}

uint64_t MIDIPort::IsInputPort(MIDIPort *this)
{
  return 0;
}

uint64_t MIDIPort::IsOutputPort(MIDIPort *this)
{
  return 0;
}

void MIDIOutputPort::~MIDIOutputPort(MIDIOutputPort *this)
{
  MIDIOutputPort::~MIDIOutputPort(this);
  JUMPOUT(0x1D826BA98);
}

{
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  BOOL v9;
  uint64_t v10;
  _QWORD v11[5];

  *(_QWORD *)this = &off_1E98B96C0;
  v2 = gScheduler;
  v3 = gScheduler + 24;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(gScheduler + 24) + 16))(gScheduler + 24);
  v11[0] = &off_1E98B9460;
  memset(&v11[1], 0, 24);
  v11[4] = v2;
  v5 = *(_QWORD *)(v2 + 120);
  if (v5 != v2 + 128)
  {
    do
    {
      v6 = *(_QWORD **)(v5 + 8);
      v7 = (_QWORD *)v5;
      if (v6)
      {
        do
        {
          v8 = v6;
          v6 = (_QWORD *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          v8 = (_QWORD *)v7[2];
          v9 = *v8 == (_QWORD)v7;
          v7 = v8;
        }
        while (!v9);
      }
      if (*(MIDIOutputPort **)(v5 + 48) == this)
      {
        FlushManagerBase::InspectEvent(v11, *(_DWORD *)(v5 + 56), *(_QWORD *)(v5 + 64));
        v10 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIEndpoint>::sRTTI, *(_DWORD *)(v5 + 56));
        if (v10)
          --*(_DWORD *)(v10 + 92);
        std::__tree<std::__value_type<unsigned long long,ScheduledEvent>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,ScheduledEvent>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,ScheduledEvent>>>::erase((_QWORD *)(v2 + 120), v5);
      }
      v5 = (uint64_t)v8;
    }
    while (v8 != (_QWORD *)(v2 + 128));
  }
  FlushManager::~FlushManager((FlushManager *)v11);
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  *(_QWORD *)this = off_1E98B9320;
  XCFObject<__CFDictionary const*>::~XCFObject((uint64_t)this + 24);
  BaseOpaqueObject::~BaseOpaqueObject(this);
}

uint64_t MIDIOutputPort::PrintObject(MIDIOutputPort *this, __sFILE *a2)
{
  fprintf(a2, "<%s 0x%x [%p]>", "MIDIPortRef", *((_DWORD *)this + 2), this);
  fprintf(a2, " parent=0x%X", *((_QWORD *)this + 2));
  return fputc(10, a2);
}

void sub_1D4ECEEDC(void *a1)
{
  __clang_call_terminate(a1);
}

void MIDIInputPort::~MIDIInputPort(MIDIInputPort *this)
{
  MIDIInputPort::~MIDIInputPort(this);
  JUMPOUT(0x1D826BA98);
}

{
  void **v2;
  uint64_t v3;
  void **v4;

  *(_QWORD *)this = &off_1E98B9570;
  v2 = (void **)((char *)this + 80);
  while (1)
  {
    v3 = *((_QWORD *)this + 11);
    if (*((_QWORD *)this + 10) == v3)
      break;
    MIDISource::DisconnectPort(*(MIDIInputPort ****)(v3 - 16), this);
  }
  _Block_release(*((const void **)this + 8));
  _Block_release(*((const void **)this + 9));
  v4 = v2;
  std::vector<MIDIInputPort::ConnectedSource>::__destroy_vector::operator()[abi:ne180100](&v4);
  *(_QWORD *)this = off_1E98B9320;
  XCFObject<__CFDictionary const*>::~XCFObject((uint64_t)this + 24);
  BaseOpaqueObject::~BaseOpaqueObject(this);
}

uint64_t MIDIInputPort::PrintObject(MIDIInputPort *this, __sFILE *a2)
{
  fprintf(a2, "<%s 0x%x [%p]>", "MIDIPortRef", *((_DWORD *)this + 2), this);
  fprintf(a2, " parent=0x%X", *((_QWORD *)this + 2));
  return fputc(10, a2);
}

uint64_t MIDIInputPort::GetProperty(MIDIInputPort *this, const __CFString *cf1, const void **a3, int a4)
{
  if (!CFEqual(cf1, kMIDIPropertyProtocolID))
    return MIDIObject::GetProperty(this, cf1, a3, a4);
  *a3 = CFNumberCreate(0, kCFNumberSInt32Type, (char *)this + 56);
  return 0;
}

void std::vector<MIDIInputPort::ConnectedSource>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  uint64_t v6;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = *((_QWORD *)v4 - 1);
        *((_QWORD *)v4 - 1) = 0;
        if (v6)
          (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
        v4 -= 16;
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void ClientTable::ProcessQuit(ClientTable *this, ClientProcess *a2)
{
  ClientTable *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  int v14;
  char *v15;
  char *v16;
  char *v17;
  const void *v18;
  size_t v19;

  v3 = this;
  v5 = *((_QWORD *)this + 1);
  v4 = *((_QWORD *)this + 2);
  if (v4 != v5)
  {
    v6 = 0;
    v7 = 0;
    do
    {
      v8 = v5 + 8 * v6;
      if (*(ClientProcess **)(*(_QWORD *)v8 + 48) == a2)
      {
        v9 = MIDIServer::defaultInstance(this) + 13;
        v10 = (*(uint64_t (**)(uint64_t *))(*v9 + 16))(v9);
        this = *(ClientTable **)v8;
        if (*(_QWORD *)v8)
          this = (ClientTable *)(*(uint64_t (**)(ClientTable *))(*(_QWORD *)this + 8))(this);
        v11 = *((_QWORD *)v3 + 2);
        v12 = v11 - (v8 + 8);
        if (v11 != v8 + 8)
          this = (ClientTable *)memmove((void *)v8, (const void *)(v8 + 8), v11 - (v8 + 8));
        v4 = v8 + v12;
        *((_QWORD *)v3 + 2) = v8 + v12;
        if (v10)
        {
          this = (ClientTable *)(*(uint64_t (**)(uint64_t *))(*v9 + 24))(v9);
          v4 = *((_QWORD *)v3 + 2);
        }
      }
      else
      {
        ++v7;
      }
      v6 = v7;
      v5 = *((_QWORD *)v3 + 1);
    }
    while (v7 < (unint64_t)((v4 - v5) >> 3));
  }
  v13 = MIDIServer::defaultInstance(this) + 13;
  v14 = (*(uint64_t (**)(uint64_t *))(*v13 + 16))(v13);
  v15 = (char *)*((_QWORD *)v3 + 6);
  v16 = (char *)*((_QWORD *)v3 + 5);
  if (v16 != v15)
  {
    v16 = (char *)*((_QWORD *)v3 + 5);
    while (*(ClientProcess **)v16 != a2)
    {
      v16 += 8;
      if (v16 == v15)
      {
        v16 = (char *)*((_QWORD *)v3 + 6);
        break;
      }
    }
  }
  if (v16 != v15)
  {
    if (*(_QWORD *)v16)
    {
      (*(void (**)(_QWORD))(**(_QWORD **)v16 + 8))(*(_QWORD *)v16);
      v15 = (char *)*((_QWORD *)v3 + 6);
    }
    v17 = v16;
    v18 = v16 + 8;
    v19 = v15 - (v16 + 8);
    if (v19)
      memmove(v17, v18, v19);
    *((_QWORD *)v3 + 6) = &v17[v19];
  }
  if (v14)
    (*(void (**)(uint64_t *))(*v13 + 24))(v13);
  ClientTable::CheckActiveProcesses(v3);
}

void ClientTable::CheckActiveProcesses(ClientTable *this)
{
  _BOOL8 active;
  int v3;
  NSObject *v4;
  _BOOL8 v5;
  int v6;
  NSObject *v7;
  dispatch_time_t v8;
  _QWORD block[5];
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  active = ClientTable::AnyActiveProcesses(this);
  if (active)
  {
    if (!**(_BYTE **)(MIDIServer::defaultInstance((MIDIServer *)active, v3) + 264))
    {
      gClientTable();
      v4 = gClientTable(void)::clitbl;
      v5 = os_log_type_enabled((os_log_t)gClientTable(void)::clitbl, OS_LOG_TYPE_DEBUG);
      if (v5)
      {
        *(_DWORD *)buf = 136315394;
        v11 = "MIDIClient.cpp";
        v12 = 1024;
        v13 = 144;
        _os_log_impl(&dword_1D4E88000, v4, OS_LOG_TYPE_DEBUG, "%25s:%-5d ClientTable::CheckActiveProcesses: starting MIDI drivers", buf, 0x12u);
      }
      MIDIServer::startMIDI((MIDIServer *)v5, v6);
    }
  }
  else
  {
    *((_QWORD *)this + 8) = mach_absolute_time();
    gClientTable();
    v7 = gClientTable(void)::clitbl;
    if (os_log_type_enabled((os_log_t)gClientTable(void)::clitbl, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315394;
      v11 = "MIDIClient.cpp";
      v12 = 1024;
      v13 = 150;
      _os_log_impl(&dword_1D4E88000, v7, OS_LOG_TYPE_DEBUG, "%25s:%-5d ClientTable::CheckActiveProcesses: scheduling check for stopping MIDI drivers", buf, 0x12u);
    }
    v8 = dispatch_time(0, 60000000000);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ___ZN11ClientTable20CheckActiveProcessesEv_block_invoke;
    block[3] = &__block_descriptor_tmp_1568;
    block[4] = this;
    dispatch_after(v8, MEMORY[0x1E0C80D38], block);
  }
}

BOOL ClientTable::AnyActiveProcesses(ClientTable *this)
{
  uint64_t *i;
  uint64_t v3;
  NSObject *v4;
  _BOOL8 result;
  uint64_t v6;
  NSObject *v7;
  int v8;
  uint64_t v9;
  int v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  for (i = (uint64_t *)*((_QWORD *)this + 5); i != *((uint64_t **)this + 6); ++i)
  {
    v3 = *i;
    if (!*(_BYTE *)(*i + 13))
    {
      gClientTable();
      v7 = gClientTable(void)::clitbl;
      if (os_log_type_enabled((os_log_t)gClientTable(void)::clitbl, OS_LOG_TYPE_DEBUG))
      {
        v8 = *(_DWORD *)(v3 + 8);
        v9 = (*((_QWORD *)this + 6) - *((_QWORD *)this + 5)) >> 3;
        v10 = 136315906;
        v11 = "MIDIClient.cpp";
        v12 = 1024;
        v13 = 130;
        v14 = 1024;
        v15 = v8;
        v16 = 1024;
        v17 = v9;
        _os_log_impl(&dword_1D4E88000, v7, OS_LOG_TYPE_DEBUG, "%25s:%-5d ClientTable::AnyActiveProcesses() returning true due to pid %d for %d processes", (uint8_t *)&v10, 0x1Eu);
      }
      return 1;
    }
  }
  gClientTable();
  v4 = gClientTable(void)::clitbl;
  result = os_log_type_enabled((os_log_t)gClientTable(void)::clitbl, OS_LOG_TYPE_DEBUG);
  if (result)
  {
    v6 = (*((_QWORD *)this + 6) - *((_QWORD *)this + 5)) >> 3;
    v10 = 136315650;
    v11 = "MIDIClient.cpp";
    v12 = 1024;
    v13 = 134;
    v14 = 1024;
    v15 = v6;
    _os_log_impl(&dword_1D4E88000, v4, OS_LOG_TYPE_DEBUG, "%25s:%-5d ClientTable::AnyActiveProcesses() returning false for %d processes", (uint8_t *)&v10, 0x18u);
    return 0;
  }
  return result;
}

void gClientTable(void)
{
  unsigned __int8 v0;

  if ((v0 & 1) == 0)
  {
    {
      gClientTable(void)::clitbl = (uint64_t)os_log_create("com.apple.coremidi", "clitbl");
    }
  }
}

void ___ZN11ClientTable20CheckActiveProcessesEv_block_invoke(MIDIServer *a1, int a2)
{
  ClientTable *v2;
  uint64_t v3;
  int v4;
  double v5;
  uint64_t v6;
  const char *v7;
  NSObject *v8;
  uint32_t v9;
  BOOL active;
  NSObject *v11;
  MIDIServer *v12;
  int v13;
  uint64_t v14;
  int v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  double v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v2 = (ClientTable *)*((_QWORD *)a1 + 4);
  v3 = MIDIServer::defaultInstance(a1, a2) + 16;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 16))(v3);
  v5 = (double)(mach_absolute_time() - *((_QWORD *)v2 + 8)) * 0.0000000416666667;
  if (v5 < 59.0)
  {
    gClientTable();
    v6 = gClientTable(void)::clitbl;
    if (!os_log_type_enabled((os_log_t)gClientTable(void)::clitbl, OS_LOG_TYPE_DEBUG))
      goto LABEL_11;
    v15 = 136315650;
    v16 = "MIDIClient.cpp";
    v17 = 1024;
    v18 = 165;
    v19 = 2048;
    v20 = v5;
    v7 = "%25s:%-5d ClientTable::CheckActiveProcesses: waiting for a later message (only %.3f seconds elapsed)";
    v8 = v6;
    v9 = 28;
LABEL_7:
    _os_log_impl(&dword_1D4E88000, v8, OS_LOG_TYPE_DEBUG, v7, (uint8_t *)&v15, v9);
    goto LABEL_11;
  }
  active = ClientTable::AnyActiveProcesses(v2);
  gClientTable();
  v11 = gClientTable(void)::clitbl;
  if (active)
  {
    if (!os_log_type_enabled((os_log_t)gClientTable(void)::clitbl, OS_LOG_TYPE_DEBUG))
      goto LABEL_11;
    v15 = 136315394;
    v16 = "MIDIClient.cpp";
    v17 = 1024;
    v18 = 171;
    v7 = "%25s:%-5d ClientTable::CheckActiveProcesses: there are active processes, not stopping MIDI drivers";
    v8 = v11;
    v9 = 18;
    goto LABEL_7;
  }
  if (os_log_type_enabled((os_log_t)gClientTable(void)::clitbl, OS_LOG_TYPE_INFO))
  {
    v15 = 136315650;
    v16 = "MIDIClient.cpp";
    v17 = 1024;
    v18 = 167;
    v19 = 2048;
    v20 = v5;
    _os_log_impl(&dword_1D4E88000, v11, OS_LOG_TYPE_INFO, "%25s:%-5d [*] ClientTable::CheckActiveProcesses: no active processes for %.3f seconds, stopping MIDI drivers", (uint8_t *)&v15, 0x1Cu);
  }
  Scheduler::FlushAllOutput((Scheduler *)gScheduler);
  v14 = MIDIServer::defaultInstance(v12, v13);
  MIDIDriverMgr::StopMIDI(*(MIDIDriverMgr **)(v14 + 264));
LABEL_11:
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
}

void sub_1D4ECF874(_Unwind_Exception *exception_object, int a2)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

void MIDIClient::AddPort(MIDIClient *this, MIDIPort *a2)
{
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  uint64_t v14;

  v5 = (_QWORD *)*((_QWORD *)this + 10);
  v4 = *((_QWORD *)this + 11);
  if ((unint64_t)v5 >= v4)
  {
    v7 = (_QWORD *)*((_QWORD *)this + 9);
    v8 = v5 - v7;
    v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v10 = v4 - (_QWORD)v7;
    if (v10 >> 2 > v9)
      v9 = v10 >> 2;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v9;
    if (v11)
    {
      if (v11 >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v12 = (char *)operator new(8 * v11);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    *(_QWORD *)v13 = a2;
    v6 = v13 + 8;
    if (v5 != v7)
    {
      do
      {
        v14 = *--v5;
        *((_QWORD *)v13 - 1) = v14;
        v13 -= 8;
      }
      while (v5 != v7);
      v5 = (_QWORD *)*((_QWORD *)this + 9);
    }
    *((_QWORD *)this + 9) = v13;
    *((_QWORD *)this + 10) = v6;
    *((_QWORD *)this + 11) = &v12[8 * v11];
    if (v5)
      operator delete(v5);
  }
  else
  {
    *v5 = a2;
    v6 = v5 + 1;
  }
  *((_QWORD *)this + 10) = v6;
}

uint64_t MIDI::EventListDeliverer::create(_QWORD *a1, int a2, uint64_t *a3)
{
  _QWORD *v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  _QWORD v9[7];

  v9[6] = *MEMORY[0x1E0C80C00];
  if (a2 == 2)
  {
    v5 = (_QWORD *)operator new();
    v8 = *a3;
    (*(void (**)(_QWORD *, uint64_t *))(*a3 + 8))(v9, a3 + 1);
    *v5 = &off_1E98B9E68;
    v5[1] = v8;
    (*(void (**)(_QWORD *, _QWORD *))(v8 + 16))(v5 + 2, v9);
    bzero(v5 + 8, 0x821uLL);
    result = caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable(void)::{lambda(void *)#1}::__invoke(v9);
  }
  else
  {
    if (a2 != 1)
      std::terminate();
    v5 = (_QWORD *)operator new();
    v7 = *a3;
    (*(void (**)(_QWORD *, uint64_t *))(*a3 + 8))(v9, a3 + 1);
    *v5 = &off_1E98B9E98;
    v5[1] = v7;
    (*(void (**)(_QWORD *, _QWORD *))(v7 + 16))(v5 + 2, v9);
    bzero(v5 + 8, 0x300uLL);
    result = caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable(void)::{lambda(void *)#1}::__invoke(v9);
  }
  *a1 = v5;
  return result;
}

void sub_1D4ECFB14(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

uint64_t std::__split_buffer<MIDIInputPort::ConnectedSource>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 16;
    v4 = *(_QWORD *)(i - 8);
    *(_QWORD *)(i - 8) = 0;
    if (v4)
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void MIDI::MIDI_2_Deliverer::~MIDI_2_Deliverer(MIDI::MIDI_2_Deliverer *this)
{
  *(_QWORD *)this = &off_1E98B9E68;
  (*(void (**)(char *))(*((_QWORD *)this + 1) + 24))((char *)this + 16);
}

{
  *(_QWORD *)this = &off_1E98B9E68;
  (*(void (**)(char *))(*((_QWORD *)this + 1) + 24))((char *)this + 16);
  JUMPOUT(0x1D826BA98);
}

uint64_t MIDI::MIDI_2_Deliverer::operator()(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  _DWORD *v5;
  int *v6;
  _OWORD *v7;
  uint64_t v8;
  unint64_t v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  int v16;
  int v17;
  unsigned int v18;
  BOOL v19;
  int v20;
  unsigned int v21;
  int v22;
  BOOL v23;
  unsigned int v24;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  int v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  int v38;
  unsigned int v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int j;
  int v43;
  int v44;
  int v45;
  uint64_t v46;
  char v47;
  char v49;
  int v50;
  uint64_t v51;
  int v52;
  unsigned __int8 *v53;
  unsigned int v54;
  unsigned int v55;
  unsigned int i;
  uint64_t v57;
  char v58;
  unsigned int v59;
  unint64_t v61;
  unsigned int v62;
  BOOL v63;
  BOOL v64;
  int v65;
  int v66;
  unsigned int v67;
  int v68;
  unsigned int v69;
  unsigned int v70;
  BOOL v71;
  int v72;
  unsigned int v73;
  int v74;
  unsigned int v75;
  uint64_t v76;
  _DWORD *v77;
  unsigned int v78;
  __int128 v79;
  int v80[2];
  _DWORD *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  _QWORD v85[2];
  unsigned int __src;
  int v87;
  uint64_t v88;
  _DWORD *v89;
  _QWORD v90[8];
  _QWORD v91[129];

  v91[127] = *MEMORY[0x1E0C80C00];
  if (*a2 == 2)
  {
    v89 = a2;
    return (**(uint64_t (***)(uint64_t, _DWORD **))(a1 + 8))(a1 + 16, &v89);
  }
  if (*a2 != 1)
    std::terminate();
  v89 = *(_DWORD **)(a1 + 8);
  (*((void (**)(_QWORD *, uint64_t))v89 + 1))(v90, a1 + 16);
  v90[7] = 2;
  v90[6] = v91;
  if (!a2[1])
  {
    v4 = 0;
    goto LABEL_112;
  }
  v4 = 0;
  v78 = 0;
  v77 = a2;
  v5 = a2 + 2;
  v6 = (int *)(a1 + 64);
  v7 = (_OWORD *)(a1 + 80);
  do
  {
    v8 = v5[2];
    v81 = v5 + 3;
    v82 = v8;
    v83 = *(_QWORD *)v5;
    v84 = 0;
    while (1)
    {
      *(_QWORD *)v80 = 0;
      v79 = 0uLL;
      if (!MIDI::EventList::PacketReader::read((uint64_t *)&v81, v80, &v79))
        break;
      v4 = *(_QWORD *)v80;
      v9 = v79;
      if (v79 >> 28 == 2)
      {
        v85[0] = 0;
        v85[1] = 0;
        v10 = BYTE2(v79);
        v11 = *(unsigned __int8 *)(a1 + 96);
        v12 = BYTE2(v79) >> 4;
        if (!*(_BYTE *)(a1 + 96))
        {
          v31 = *v6;
          if ((*v6 & 0xFF0000) != 0)
          {
            if (((v31 ^ v79) & 0xF0000) != 0)
            {
              v11 = 1;
              *(_BYTE *)(a1 + 96) = 1;
            }
            else
            {
              if (v12 == 11)
              {
                v43 = BYTE1(v31);
                switch(v43)
                {
                  case 'b':
                    v44 = v79 & 0xFF00;
                    v45 = 25344;
                    goto LABEL_103;
                  case 'c':
                    v44 = v79 & 0xFF00;
                    v45 = 25088;
                    goto LABEL_103;
                  case 'd':
                    v44 = v79 & 0xFF00;
                    v45 = 25856;
                    goto LABEL_103;
                  case 'e':
                    v44 = v79 & 0xFF00;
                    v45 = 25600;
LABEL_103:
                    if (v44 != v45 && (v79 & 0xF0DF00) != 0xB00600)
                      break;
                    goto LABEL_107;
                  default:
                    if (v43 == 32)
                    {
                      if ((v79 & 0xFF00) != 0)
                        break;
LABEL_107:
                      v11 = 0;
                      *v7 = v79;
                      goto LABEL_9;
                    }
                    if (!v43 && (v79 & 0xFF00) == 0x2000)
                      goto LABEL_107;
                    break;
                }
LABEL_105:
                v11 = 1;
                goto LABEL_9;
              }
              v11 = (v31 & 0xDF00) != 0 || v12 != 12;
            }
          }
          else
          {
            v11 = 1;
            if (v12 == 11 && (v79 & 0xF00000) == 0xB00000)
            {
              if (BYTE1(v79) - 98 >= 4 && BYTE1(v79) != 32 && BYTE1(v79))
                goto LABEL_105;
              v11 = 0;
              *(_OWORD *)v6 = v79;
            }
          }
        }
LABEL_9:
        v13 = BYTE3(v9) & 0xF;
        v14 = BYTE3(v9) & 0xF | 0x40;
        v15 = *v6;
        v16 = BYTE2(*v6);
        if (BYTE2(*v6) && v11)
        {
          *(_BYTE *)(a1 + 96) = 1;
          v88 = 0;
          __src = v15 & 0xFF00 | (v16 << 16) & 0x80FFFFFF | ((BYTE3(v9) & 0xF | 0x40) << 24);
          v17 = v15 << 25;
          if (v15 >= 0x41u)
          {
            v18 = (v15 & 0x3F) << 19;
            if (v18)
            {
              do
              {
                v17 |= v18;
                v19 = v18 > 0x3F;
                v18 >>= 6;
              }
              while (v19);
            }
          }
          v87 = v17;
          MIDI::Packetizer::add((unsigned int *)&v89, v4, (int *)&__src);
          *v6 = 0;
          v88 = 0;
          v20 = *(_DWORD *)v7;
          if (BYTE2(*(_DWORD *)v7))
          {
            __src = *(_DWORD *)v7 & 0xFF00 | (BYTE2(*(_DWORD *)v7) << 16) | (v14 << 24);
            v21 = v20;
            v22 = v20 << 25;
            v23 = v21 >= 0x41;
            v24 = (v21 & 0x3F) << 19;
            if (v23 && v24 != 0)
            {
              do
              {
                v22 |= v24;
                v19 = v24 > 0x3F;
                v24 >>= 6;
              }
              while (v19);
            }
            v87 = v22;
            MIDI::Packetizer::add((unsigned int *)&v89, v4, (int *)&__src);
            *(_DWORD *)v7 = 0;
          }
          *(_QWORD *)(a1 + (v13 << 7) + 8 * ((v9 >> 16) & 0xF) + 97) = 0;
        }
        v26 = (v9 >> 8) & 0x7F;
        v27 = v9 & 0x7F;
        switch(v12)
        {
          case 8:
            goto LABEL_25;
          case 9:
            if ((v9 & 0x7F) == 0)
            {
              v10 = BYTE2(v9) - 16;
              v27 = 64;
            }
LABEL_25:
            LODWORD(v85[0]) = (v14 << 24) | (v10 << 16) | (v26 << 8);
            v28 = v27 << 9;
            if (v27 >= 0x41)
            {
              v29 = 8 * (v27 & 0x3F);
              if (v29)
              {
                do
                {
                  v28 |= v29;
                  v19 = v29 > 0x3F;
                  v29 >>= 6;
                }
                while (v19);
              }
            }
            v30 = v28 << 16;
            goto LABEL_98;
          case 10:
            LODWORD(v85[0]) = (BYTE2(v9) << 16) | (v14 << 24) | (v26 << 8);
            v30 = (_DWORD)v9 << 25;
            if (v27 >= 0x41)
            {
              v32 = (v9 & 0x3F) << 19;
              if (v32)
              {
                do
                {
                  v30 |= v32;
                  v19 = v32 > 0x3F;
                  v32 >>= 6;
                }
                while (v19);
              }
            }
            goto LABEL_98;
          case 11:
            v33 = a1 + (v13 << 7) + 97;
            v34 = (v9 >> 16) & 0xF;
            if (((v9 >> 8) & 0x7F) > 0x25)
            {
              switch(v26)
              {
                case 'b':
                  v46 = v33 + 8 * v34;
                  v47 = 2;
                  goto LABEL_91;
                case 'c':
                  v57 = v33 + 8 * v34;
                  v58 = 2;
                  goto LABEL_93;
                case 'd':
                  v46 = v33 + 8 * v34;
                  v47 = 1;
LABEL_91:
                  *(_BYTE *)(v46 + 1) = v47;
                  *(_BYTE *)(v46 + 5) = v27;
                  break;
                case 'e':
                  v57 = v33 + 8 * v34;
                  v58 = 1;
LABEL_93:
                  *(_BYTE *)(v57 + 1) = v58;
                  *(_BYTE *)(v57 + 4) = v27;
                  break;
                default:
                  if (v26 != 38)
                    goto LABEL_95;
                  v49 = v9 & 0x7F;
                  v50 = v9 & 0x7F;
                  goto LABEL_80;
              }
LABEL_94:
              if (!*(_BYTE *)(a1 + 96))
                continue;
              goto LABEL_95;
            }
            if (!v26)
            {
              *(_BYTE *)(v33 + 8 * v34 + 2) = v27;
LABEL_76:
              *(_BYTE *)(v33 + 8 * v34) = 1;
              goto LABEL_94;
            }
            if (v26 != 6)
            {
              if (v26 == 32)
              {
                *(_BYTE *)(v33 + 8 * v34 + 3) = v27;
                goto LABEL_76;
              }
LABEL_95:
              LODWORD(v85[0]) = (BYTE2(v9) << 16) | (v14 << 24) | (v26 << 8);
              v30 = (_DWORD)v9 << 25;
              if (v27 >= 0x41)
              {
                v59 = (v9 & 0x3F) << 19;
                if (v59)
                {
                  do
                  {
                    v30 |= v59;
                    v19 = v59 > 0x3F;
                    v59 >>= 6;
                  }
                  while (v19);
                }
              }
LABEL_98:
              HIDWORD(v85[0]) = v30;
              goto LABEL_99;
            }
            v49 = 0;
            v50 = 0;
            *(_BYTE *)(v33 + 8 * v34 + 6) = v27;
LABEL_80:
            v51 = v33 + 8 * v34;
            *(_BYTE *)(v51 + 7) = v49;
            if (*(_BYTE *)(a1 + 96) || !*(_BYTE *)(v51 + 1))
              goto LABEL_95;
            if (*(_BYTE *)(v51 + 1) == 1)
              v52 = 32;
            else
              v52 = 48;
            v53 = (unsigned __int8 *)(v33 + 8 * v34);
            LODWORD(v85[0]) = (v14 << 24) | ((v52 | v34) << 16) | (v53[4] << 8) | v53[5];
            v54 = v50 | (v53[6] << 7);
            v55 = v54 << 18;
            if (v54 > 0x2000)
            {
              for (i = 32 * (v54 & 0x1FFF); i; i >>= 13)
                v55 |= i;
            }
            HIDWORD(v85[0]) = v55;
LABEL_51:
            *(_OWORD *)v6 = 0u;
            *(_OWORD *)(a1 + 80) = 0u;
LABEL_99:
            MIDI::Packetizer::add((unsigned int *)&v89, v4, (int *)v85);
            break;
          case 12:
            v35 = a1 + (v13 << 7) + 97;
            v36 = *(unsigned __int8 *)(v35 + 8 * (WORD1(v9) & 0xF));
            if (*(_BYTE *)(v35 + 8 * (WORD1(v9) & 0xF)))
              v36 = *(unsigned __int8 *)(a1 + 96) ^ 1;
            v37 = v35 + 8 * (WORD1(v9) & 0xF);
            v38 = (v26 << 24) | (*(unsigned __int8 *)(v37 + 2) << 8) | *(unsigned __int8 *)(v37 + 3);
            LODWORD(v85[0]) = (v14 << 24) | (BYTE2(v9) << 16) | v36;
            HIDWORD(v85[0]) = v38;
            *(_QWORD *)v37 = 0;
            goto LABEL_51;
          case 13:
            LODWORD(v85[0]) = (v14 << 24) | (BYTE2(v9) << 16);
            v39 = v9 >> 8 << 25;
            if (v26 >= 0x41)
            {
              v40 = ((v9 >> 8) & 0x3F) << 19;
              if (v40)
              {
                do
                {
                  v39 |= v40;
                  v19 = v40 > 0x3F;
                  v40 >>= 6;
                }
                while (v19);
              }
            }
            HIDWORD(v85[0]) = v39;
            goto LABEL_99;
          case 14:
            LODWORD(v85[0]) = (v14 << 24) | (BYTE2(v9) << 16);
            v41 = v26 | (v27 << 7);
            v30 = v41 << 18;
            if (v41 > 0x2000)
            {
              for (j = 32 * (v41 & 0x1FFF); j; j >>= 13)
                v30 |= j;
            }
            goto LABEL_98;
          default:
            goto LABEL_99;
        }
      }
      else
      {
        MIDI::Packetizer::add((unsigned int *)&v89, *(uint64_t *)v80, (int *)&v79);
      }
    }
    v5 += v5[2] + 3;
    ++v78;
  }
  while (v78 < v77[1]);
LABEL_112:
  v61 = *(unsigned int *)(a1 + 64);
  v62 = v61 >> 28;
  if (v61 >> 28)
    v63 = v62 == 15;
  else
    v63 = 1;
  v64 = v63 || (v61 & 0xFF0000) == 0;
  if (!v64 && (BYTE1(v61) | 0x20) == 0x26)
  {
    LODWORD(v76) = BYTE3(v61) & 0xF;
    if (v62 == 15)
      v76 = 255;
    else
      v76 = v76;
    *(_QWORD *)(a1 + (v76 << 7) + 8 * ((v61 >> 16) & 0xF) + 97) = 0;
    *(_BYTE *)(a1 + 96) = 1;
  }
  if (BYTE2(v61))
  {
    v82 = 0;
    v65 = v61 & 0xF000000 | 0x40000000;
    if (v62 == 15)
      v65 = -16777216;
    if (v62)
      v66 = v65;
    else
      v66 = -16777216;
    LODWORD(v81) = v66 | v61 & 0xFF00 | (BYTE2(v61) << 16);
    v67 = v61;
    v68 = (_DWORD)v61 << 25;
    if (v67 >= 0x41)
    {
      v69 = (v67 & 0x3F) << 19;
      if (v69)
      {
        do
        {
          v68 |= v69;
          v19 = v69 > 0x3F;
          v69 >>= 6;
        }
        while (v19);
      }
    }
    HIDWORD(v81) = v68;
    MIDI::Packetizer::add((unsigned int *)&v89, v4, (int *)&v81);
    *(_DWORD *)(a1 + 64) = 0;
  }
  v70 = *(_DWORD *)(a1 + 80);
  if (BYTE2(v70))
  {
    v82 = 0;
    if (v70 >> 28)
      v71 = v70 >> 28 == 15;
    else
      v71 = 1;
    v72 = v70 & 0xF000000 | 0x40000000;
    if (v71)
      v72 = -16777216;
    LODWORD(v81) = v72 | v70 & 0xFF00 | (BYTE2(v70) << 16);
    v73 = v70;
    v74 = v70 << 25;
    if (v73 >= 0x41)
    {
      v75 = (v73 & 0x3F) << 19;
      if (v75)
      {
        do
        {
          v74 |= v75;
          v19 = v75 > 0x3F;
          v75 >>= 6;
        }
        while (v19);
      }
    }
    HIDWORD(v81) = v74;
    MIDI::Packetizer::add((unsigned int *)&v89, v4, (int *)&v81);
    *(_DWORD *)(a1 + 80) = 0;
  }
  return MIDI::PacketizerBase<MIDI::EventList>::~PacketizerBase((uint64_t)&v89);
}

void sub_1D4ED04A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  MIDI::PacketizerBase<MIDI::EventList>::~PacketizerBase((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t MIDI::MIDI_2_Deliverer::operator()(uint64_t a1, unsigned int *a2)
{
  unint64_t v4;
  int *v5;
  _OWORD *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  int v16;
  int v17;
  unsigned int v18;
  BOOL v19;
  int v20;
  unsigned int v21;
  int v22;
  BOOL v23;
  unsigned int v24;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  int v31;
  unsigned int v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int j;
  int v43;
  int v44;
  int v45;
  uint64_t v46;
  char v47;
  char v49;
  int v50;
  uint64_t v51;
  int v52;
  unsigned __int8 *v53;
  unsigned int v54;
  unsigned int v55;
  unsigned int i;
  uint64_t v57;
  char v58;
  unsigned int v59;
  unsigned int *v61;
  unsigned int v62;
  __int128 v63;
  int v64[2];
  uint64_t v65[4];
  _QWORD v66[2];
  unsigned int __src;
  int v68;
  uint64_t v69;
  uint64_t v70;
  _QWORD v71[8];
  _QWORD v72[129];

  v72[127] = *MEMORY[0x1E0C80C00];
  v70 = *(_QWORD *)(a1 + 8);
  (*(void (**)(_QWORD *, uint64_t))(v70 + 8))(v71, a1 + 16);
  v71[7] = 2;
  v71[6] = v72;
  v61 = a2;
  if (*a2)
  {
    v62 = 0;
    v4 = (unint64_t)(a2 + 1);
    v5 = (int *)(a1 + 64);
    v6 = (_OWORD *)(a1 + 80);
    do
    {
      v7 = *(unsigned __int16 *)(v4 + 8);
      v65[0] = v4 + 10;
      v65[1] = v7;
      v65[2] = *(_QWORD *)v4;
      v65[3] = 0;
      while (1)
      {
        *(_QWORD *)v64 = 0;
        v63 = 0uLL;
        if (!MIDI::LegacyPacketList::PacketReader::read(v65, v64, &v63))
          break;
        v8 = *(_QWORD *)v64;
        v9 = v63;
        if (v63 >> 28 == 2)
        {
          v66[0] = 0;
          v66[1] = 0;
          v10 = BYTE2(v63);
          v11 = *(unsigned __int8 *)(a1 + 96);
          v12 = BYTE2(v63) >> 4;
          if (!*(_BYTE *)(a1 + 96))
          {
            v31 = *v5;
            if ((*v5 & 0xFF0000) != 0)
            {
              if (((v31 ^ v63) & 0xF0000) != 0)
              {
                v11 = 1;
                *(_BYTE *)(a1 + 96) = 1;
              }
              else
              {
                if (v12 == 11)
                {
                  v43 = BYTE1(v31);
                  switch(v43)
                  {
                    case 'b':
                      v44 = v63 & 0xFF00;
                      v45 = 25344;
                      goto LABEL_101;
                    case 'c':
                      v44 = v63 & 0xFF00;
                      v45 = 25088;
                      goto LABEL_101;
                    case 'd':
                      v44 = v63 & 0xFF00;
                      v45 = 25856;
                      goto LABEL_101;
                    case 'e':
                      v44 = v63 & 0xFF00;
                      v45 = 25600;
LABEL_101:
                      if (v44 != v45 && (v63 & 0xF0DF00) != 0xB00600)
                        break;
                      goto LABEL_105;
                    default:
                      if (v43 == 32)
                      {
                        if ((v63 & 0xFF00) != 0)
                          break;
LABEL_105:
                        v11 = 0;
                        *v6 = v63;
                        goto LABEL_7;
                      }
                      if (!v43 && (v63 & 0xFF00) == 0x2000)
                        goto LABEL_105;
                      break;
                  }
LABEL_103:
                  v11 = 1;
                  goto LABEL_7;
                }
                v11 = (v31 & 0xDF00) != 0 || v12 != 12;
              }
            }
            else
            {
              v11 = 1;
              if (v12 == 11 && (v63 & 0xF00000) == 0xB00000)
              {
                if (BYTE1(v63) - 98 >= 4 && BYTE1(v63) != 32 && BYTE1(v63))
                  goto LABEL_103;
                v11 = 0;
                *(_OWORD *)v5 = v63;
              }
            }
          }
LABEL_7:
          v13 = BYTE3(v9) & 0xF;
          v14 = BYTE3(v9) & 0xF | 0x40;
          v15 = *v5;
          v16 = BYTE2(*v5);
          if (BYTE2(*v5) && v11)
          {
            *(_BYTE *)(a1 + 96) = 1;
            v69 = 0;
            __src = v15 & 0xFF00 | (v16 << 16) & 0x80FFFFFF | ((BYTE3(v9) & 0xF | 0x40) << 24);
            v17 = v15 << 25;
            if (v15 >= 0x41u)
            {
              v18 = (v15 & 0x3F) << 19;
              if (v18)
              {
                do
                {
                  v17 |= v18;
                  v19 = v18 > 0x3F;
                  v18 >>= 6;
                }
                while (v19);
              }
            }
            v68 = v17;
            MIDI::Packetizer::add((unsigned int *)&v70, v8, (int *)&__src);
            *v5 = 0;
            v69 = 0;
            v20 = *(_DWORD *)v6;
            if (BYTE2(*(_DWORD *)v6))
            {
              __src = *(_DWORD *)v6 & 0xFF00 | (BYTE2(*(_DWORD *)v6) << 16) | (v14 << 24);
              v21 = v20;
              v22 = v20 << 25;
              v23 = v21 >= 0x41;
              v24 = (v21 & 0x3F) << 19;
              if (v23 && v24 != 0)
              {
                do
                {
                  v22 |= v24;
                  v19 = v24 > 0x3F;
                  v24 >>= 6;
                }
                while (v19);
              }
              v68 = v22;
              MIDI::Packetizer::add((unsigned int *)&v70, v8, (int *)&__src);
              *(_DWORD *)v6 = 0;
            }
            *(_QWORD *)(a1 + (v13 << 7) + 8 * ((v9 >> 16) & 0xF) + 97) = 0;
          }
          v26 = (v9 >> 8) & 0x7F;
          v27 = v9 & 0x7F;
          switch(v12)
          {
            case 8:
              goto LABEL_23;
            case 9:
              if ((v9 & 0x7F) == 0)
              {
                v10 = BYTE2(v9) - 16;
                v27 = 64;
              }
LABEL_23:
              LODWORD(v66[0]) = (v14 << 24) | (v10 << 16) | (v26 << 8);
              v28 = v27 << 9;
              if (v27 >= 0x41)
              {
                v29 = 8 * (v27 & 0x3F);
                if (v29)
                {
                  do
                  {
                    v28 |= v29;
                    v19 = v29 > 0x3F;
                    v29 >>= 6;
                  }
                  while (v19);
                }
              }
              v30 = v28 << 16;
              goto LABEL_96;
            case 10:
              LODWORD(v66[0]) = (BYTE2(v9) << 16) | (v14 << 24) | (v26 << 8);
              v30 = (_DWORD)v9 << 25;
              if (v27 >= 0x41)
              {
                v32 = (v9 & 0x3F) << 19;
                if (v32)
                {
                  do
                  {
                    v30 |= v32;
                    v19 = v32 > 0x3F;
                    v32 >>= 6;
                  }
                  while (v19);
                }
              }
              goto LABEL_96;
            case 11:
              v37 = a1 + (v13 << 7) + 97;
              v38 = (v9 >> 16) & 0xF;
              if (((v9 >> 8) & 0x7F) > 0x25)
              {
                switch(v26)
                {
                  case 'b':
                    v46 = v37 + 8 * v38;
                    v47 = 2;
                    goto LABEL_89;
                  case 'c':
                    v57 = v37 + 8 * v38;
                    v58 = 2;
                    goto LABEL_91;
                  case 'd':
                    v46 = v37 + 8 * v38;
                    v47 = 1;
LABEL_89:
                    *(_BYTE *)(v46 + 1) = v47;
                    *(_BYTE *)(v46 + 5) = v27;
                    break;
                  case 'e':
                    v57 = v37 + 8 * v38;
                    v58 = 1;
LABEL_91:
                    *(_BYTE *)(v57 + 1) = v58;
                    *(_BYTE *)(v57 + 4) = v27;
                    break;
                  default:
                    if (v26 != 38)
                      goto LABEL_93;
                    v49 = v9 & 0x7F;
                    v50 = v9 & 0x7F;
                    goto LABEL_78;
                }
LABEL_92:
                if (!*(_BYTE *)(a1 + 96))
                  continue;
                goto LABEL_93;
              }
              if (!v26)
              {
                *(_BYTE *)(v37 + 8 * v38 + 2) = v27;
LABEL_74:
                *(_BYTE *)(v37 + 8 * v38) = 1;
                goto LABEL_92;
              }
              if (v26 != 6)
              {
                if (v26 == 32)
                {
                  *(_BYTE *)(v37 + 8 * v38 + 3) = v27;
                  goto LABEL_74;
                }
LABEL_93:
                LODWORD(v66[0]) = (BYTE2(v9) << 16) | (v14 << 24) | (v26 << 8);
                v30 = (_DWORD)v9 << 25;
                if (v27 >= 0x41)
                {
                  v59 = (v9 & 0x3F) << 19;
                  if (v59)
                  {
                    do
                    {
                      v30 |= v59;
                      v19 = v59 > 0x3F;
                      v59 >>= 6;
                    }
                    while (v19);
                  }
                }
LABEL_96:
                HIDWORD(v66[0]) = v30;
                goto LABEL_97;
              }
              v49 = 0;
              v50 = 0;
              *(_BYTE *)(v37 + 8 * v38 + 6) = v27;
LABEL_78:
              v51 = v37 + 8 * v38;
              *(_BYTE *)(v51 + 7) = v49;
              if (*(_BYTE *)(a1 + 96) || !*(_BYTE *)(v51 + 1))
                goto LABEL_93;
              if (*(_BYTE *)(v51 + 1) == 1)
                v52 = 32;
              else
                v52 = 48;
              v53 = (unsigned __int8 *)(v37 + 8 * v38);
              LODWORD(v66[0]) = (v14 << 24) | ((v52 | v38) << 16) | (v53[4] << 8) | v53[5];
              v54 = v50 | (v53[6] << 7);
              v55 = v54 << 18;
              if (v54 > 0x2000)
              {
                for (i = 32 * (v54 & 0x1FFF); i; i >>= 13)
                  v55 |= i;
              }
              HIDWORD(v66[0]) = v55;
LABEL_44:
              *(_OWORD *)v5 = 0u;
              *(_OWORD *)(a1 + 80) = 0u;
LABEL_97:
              MIDI::Packetizer::add((unsigned int *)&v70, v8, (int *)v66);
              break;
            case 12:
              v33 = a1 + (v13 << 7) + 97;
              v34 = *(unsigned __int8 *)(v33 + 8 * (WORD1(v9) & 0xF));
              if (*(_BYTE *)(v33 + 8 * (WORD1(v9) & 0xF)))
                v34 = *(unsigned __int8 *)(a1 + 96) ^ 1;
              v35 = v33 + 8 * (WORD1(v9) & 0xF);
              v36 = (v26 << 24) | (*(unsigned __int8 *)(v35 + 2) << 8) | *(unsigned __int8 *)(v35 + 3);
              LODWORD(v66[0]) = (v14 << 24) | (BYTE2(v9) << 16) | v34;
              HIDWORD(v66[0]) = v36;
              *(_QWORD *)v35 = 0;
              goto LABEL_44;
            case 13:
              LODWORD(v66[0]) = (v14 << 24) | (BYTE2(v9) << 16);
              v39 = v9 >> 8 << 25;
              if (v26 >= 0x41)
              {
                v40 = ((v9 >> 8) & 0x3F) << 19;
                if (v40)
                {
                  do
                  {
                    v39 |= v40;
                    v19 = v40 > 0x3F;
                    v40 >>= 6;
                  }
                  while (v19);
                }
              }
              HIDWORD(v66[0]) = v39;
              goto LABEL_97;
            case 14:
              LODWORD(v66[0]) = (v14 << 24) | (BYTE2(v9) << 16);
              v41 = v26 | (v27 << 7);
              v30 = v41 << 18;
              if (v41 > 0x2000)
              {
                for (j = 32 * (v41 & 0x1FFF); j; j >>= 13)
                  v30 |= j;
              }
              goto LABEL_96;
            default:
              goto LABEL_97;
          }
        }
        else
        {
          MIDI::Packetizer::add((unsigned int *)&v70, *(uint64_t *)v64, (int *)&v63);
        }
      }
      v4 = (v4 + *(unsigned __int16 *)(v4 + 8) + 13) & 0xFFFFFFFFFFFFFFFCLL;
      ++v62;
    }
    while (v62 < *v61);
  }
  return MIDI::PacketizerBase<MIDI::EventList>::~PacketizerBase((uint64_t)&v70);
}

void sub_1D4ED0B80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  _Unwind_Resume(exception_object);
}

uint64_t MIDI::PacketizerBase<MIDI::EventList>::~PacketizerBase(uint64_t a1)
{
  uint64_t v3;

  if (*(_DWORD *)(a1 + 68))
  {
    v3 = a1 + 64;
    (**(void (***)(uint64_t, uint64_t *))a1)(a1 + 8, &v3);
  }
  *(_DWORD *)(a1 + 68) = 0;
  *(_QWORD *)(a1 + 56) = a1 + 72;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1 + 8);
  return a1;
}

uint64_t MIDI::LegacyPacketList::PacketReader::read(uint64_t *a1, _QWORD *a2, _DWORD *a3)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  unint64_t v8;
  BOOL v9;
  _BOOL8 v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  unint64_t v15;
  int v16;
  int v18;
  unint64_t v19;
  int v20;
  int v21;
  int v22;
  int v23;
  unsigned int v24;
  unint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  _BYTE v29[2];
  unsigned int v30;

  v3 = a1[1];
  v4 = a1[3];
  if (v4 >= v3)
    return 0;
  v5 = *a1;
  v6 = *(unsigned __int8 *)(*a1 + v4);
  if (*(char *)(*a1 + v4) < -16)
  {
LABEL_3:
    v7 = 2;
    if ((v6 & 0xE0) != 0xC0)
      v7 = 3;
    v8 = v7 + v4;
    v9 = v7 + v4 > v3;
    v10 = v7 + v4 <= v3;
    if (!v9)
    {
      v11 = v4 + v5;
      v12 = *(_BYTE *)(v4 + v5 + 1) & 0x7F;
      if ((v6 & 0xE0) == 0xC0)
        v13 = 0;
      else
        v13 = *(_BYTE *)(v11 + 2) & 0x7F;
      *a3 = v13 | (v6 << 16) | (v12 << 8) | 0x20000000;
      *a2 = a1[2];
      v3 = v8;
    }
    goto LABEL_19;
  }
LABEL_8:
  if (v6 < 0xF1)
  {
    if (v6 == 240)
      v18 = 1;
    else
      v18 = 2;
    if (v6 == 240)
      a1[3] = ++v4;
    v19 = 0;
    v20 = 0;
    v21 = 0;
    while (1)
    {
      v22 = (v4 < v3) | v20;
      if (v4 < v3 && (v20 & 1) == 0)
      {
        v23 = *(char *)(v5 + v4);
        if ((v23 & 0x80000000) == 0)
        {
          if (v19 > 5)
          {
            v22 = 0;
            goto LABEL_42;
          }
          v22 = 0;
          a1[3] = ++v4;
          ++v21;
          goto LABEL_40;
        }
        if (v23 == -9)
          a1[3] = ++v4;
        if (v18 == 1)
          v18 = 0;
        else
          v18 = 3;
        v22 = 1;
      }
      if (v19 <= 5)
      {
        LOBYTE(v23) = 0;
LABEL_40:
        v29[v19] = v23;
      }
LABEL_42:
      ++v19;
      v20 = v22;
      if (v19 == 7)
      {
        v24 = bswap32(v30);
        *a3 = (v18 << 20) | (v21 << 16) | (v29[0] << 8) | v29[1] | 0x30000000;
        a3[1] = v24;
        *a2 = a1[2];
        return 1;
      }
    }
  }
  if (v6 == 247)
  {
    *(_QWORD *)a3 = 808452096;
    *a2 = a1[2];
    v25 = v4 + 1;
    goto LABEL_53;
  }
  v14 = v6 - 240;
  if (((0x22B1uLL >> (v6 + 16)) & 1) != 0)
  {
    v15 = v4;
    while (1)
    {
      v4 = v15 + 1;
      a1[3] = v15 + 1;
      if (v15 + 1 >= v3)
        return 0;
      v16 = *(char *)(v5 + 1 + v15++);
      if (v16 < 0)
      {
        v6 = v16;
        if ((char)v16 > -17)
          goto LABEL_8;
        goto LABEL_3;
      }
    }
  }
  v25 = v4 + MIDI::system_message_size::sizes[v14];
  if (v25 > v3)
  {
    v10 = 0;
LABEL_19:
    a1[3] = v3;
    return v10;
  }
  if ((unint64_t)(v14 - 1) > 2)
  {
    v27 = 0;
    goto LABEL_51;
  }
  v26 = v4 + v5;
  v27 = *(_BYTE *)(v4 + v5 + 1) & 0x7F;
  if ((v14 & 0xFFFFFFFD) == 1)
  {
LABEL_51:
    v28 = 0;
    goto LABEL_52;
  }
  v28 = *(_BYTE *)(v26 + 2) & 0x7F;
LABEL_52:
  *a3 = (v6 << 16) | (v27 << 8) | v28 | 0x10000000;
  *a2 = a1[2];
LABEL_53:
  a1[3] = v25;
  return 1;
}

unsigned int *MIDI::Packetizer::add(unsigned int *result, uint64_t a2, int *__src)
{
  unsigned int *v3;
  unint64_t v4;
  uint64_t v5;
  unsigned int *v6;
  unint64_t v7;
  int v8;
  unsigned int v9;
  BOOL v10;
  unsigned int v11;
  BOOL v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  BOOL v16;
  char v17;
  int v18;
  BOOL v19;
  uint64_t v20;
  int v21;
  int v22;
  int v23;

  v3 = result;
  v4 = *__src;
  v5 = MIDI::UniversalPacket::word_sizes[v4 >> 28];
  v6 = (unsigned int *)*((_QWORD *)result + 7);
  if (!MIDI::UniversalPacket::word_sizes[v4 >> 28])
  {
    if (v6)
      goto LABEL_47;
    goto LABEL_38;
  }
  v7 = (unint64_t)(result + 272);
  v8 = v4 & 0xF0000000;
  v9 = result[17];
  if (v6)
    v10 = v9 == 0;
  else
    v10 = 1;
  if (!v10)
  {
    v11 = v6[2];
    v12 = v11 >= 2;
    v13 = v11 - 2;
    if (v12 && v6[3] >> 28 == 3)
    {
      v14 = v6[v13 + 3];
      if (v14 >> 28 == 3)
        v15 = (v14 >> 20) & 0xF;
      else
        v15 = 255;
      if (v15)
        v16 = v15 == 3;
      else
        v16 = 1;
      v17 = v16;
      v18 = 1;
LABEL_27:
      if ((v4 & 0xF0E00000) != 0x30000000)
      {
        v19 = (v8 != 805306368) != v18 && *(_QWORD *)v6 == a2;
        if (v19 && (v17 & 1) == 0)
        {
LABEL_34:
          v20 = v6[2];
          if ((unint64_t)&v6[v20 + 3 + v5] <= v7)
            goto LABEL_40;
LABEL_38:
          result = (unsigned int *)MIDI::PacketizerBase<MIDI::EventList>::begin_new_packet((uint64_t)result, a2, __src, v5);
          v6 = result;
          goto LABEL_47;
        }
      }
      goto LABEL_36;
    }
LABEL_26:
    v18 = 0;
    v17 = 0;
    goto LABEL_27;
  }
  if (!v9)
    goto LABEL_37;
  if (v6)
    goto LABEL_26;
  if (v8 != 805306368)
    goto LABEL_34;
LABEL_36:
  v6 += v6[2] + 3;
LABEL_37:
  if ((unint64_t)&v6[v5 + 3] > v7)
    goto LABEL_38;
  LODWORD(v20) = 0;
  result[17] = v9 + 1;
  *(_QWORD *)v6 = a2;
  v6[2] = 0;
LABEL_40:
  result = &v6[v20 + 3];
  switch((int)v5)
  {
    case 1:
      goto LABEL_44;
    case 2:
      goto LABEL_43;
    case 3:
      goto LABEL_42;
    case 4:
      v21 = *__src++;
      *result = v21;
      result = &v6[v20 + 4];
LABEL_42:
      v22 = *__src++;
      *result++ = v22;
LABEL_43:
      v23 = *__src++;
      *result++ = v23;
LABEL_44:
      *result = *__src;
      break;
    default:
      result = (unsigned int *)memmove(result, __src, 4 * v5);
      break;
  }
  v6[2] += v5;
LABEL_47:
  *((_QWORD *)v3 + 7) = v6;
  return result;
}

void caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable(void)::{lambda(void *,MIDI::EventList const*&&)#1}::__invoke()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
}

void MIDI::MIDI_1UP_Deliverer::~MIDI_1UP_Deliverer(MIDI::MIDI_1UP_Deliverer *this)
{
  *(_QWORD *)this = &off_1E98B9E98;
  (*(void (**)(char *))(*((_QWORD *)this + 1) + 24))((char *)this + 16);
}

{
  *(_QWORD *)this = &off_1E98B9E98;
  (*(void (**)(char *))(*((_QWORD *)this + 1) + 24))((char *)this + 16);
  JUMPOUT(0x1D826BA98);
}

uint64_t MIDI::MIDI_1UP_Deliverer::operator()(uint64_t a1, _DWORD *a2)
{
  int v4;
  _DWORD *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  unint64_t v12;
  unsigned __int8 *v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  char v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  unsigned __int8 v26;
  int v27;
  _QWORD __src[2];
  int v29[2];
  uint64_t v30[4];
  uint64_t v31;
  int v32;
  int v33;
  _DWORD *v34;
  _QWORD v35[8];
  _QWORD v36[129];

  v36[127] = *MEMORY[0x1E0C80C00];
  if (*a2 == 2)
  {
    v34 = *(_DWORD **)(a1 + 8);
    (*((void (**)(_QWORD *, uint64_t))v34 + 1))(v35, a1 + 16);
    v35[7] = 1;
    v35[6] = v36;
    if (!a2[1])
      return MIDI::PacketizerBase<MIDI::EventList>::~PacketizerBase((uint64_t)&v34);
    v4 = 0;
    v5 = a2 + 2;
    v24 = a1 + 64;
    while (1)
    {
      v27 = v4;
      v6 = v5[2];
      v30[0] = (uint64_t)(v5 + 3);
      v30[1] = v6;
      v30[2] = *(_QWORD *)v5;
      v30[3] = 0;
      while (1)
      {
        __src[1] = 0;
        *(_QWORD *)v29 = 0;
        __src[0] = 0;
        if (!MIDI::EventList::PacketReader::read(v30, v29, __src))
          break;
        v7 = *(_QWORD *)v29;
        if (((1 << (LODWORD(__src[0]) >> 28)) & 0xA02B) != 0)
        {
          MIDI::Packetizer::add((unsigned int *)&v34, *(uint64_t *)v29, (int *)__src);
        }
        else if (LODWORD(__src[0]) >> 28 == 4)
        {
          v8 = HIBYTE(LODWORD(__src[0])) & 0xF | 0x20;
          v9 = HIDWORD(__src[0]);
          switch(BYTE2(__src[0]) >> 4)
          {
            case 2:
            case 3:
              v11 = v24 + 48 * (HIBYTE(LODWORD(__src[0])) & 0xF);
              v12 = ((unint64_t)LODWORD(__src[0]) >> 16) & 0xF;
              v13 = (unsigned __int8 *)(v11 + 3 * v12);
              v14 = (LODWORD(__src[0]) >> 8) & 0x7F;
              v15 = __src[0] & 0x7F;
              if ((__src[0] & 0x100000) != 0)
                v16 = 2;
              else
                v16 = 1;
              if (v16 != *v13 || v14 != v13[1])
              {
                v17 = v12 | 0xB0;
LABEL_23:
                v26 = v16;
                if ((__src[0] & 0x100000) != 0)
                  v19 = 25344;
                else
                  v19 = 25856;
                v33 = 0;
                v32 = 0;
                v18 = (v8 << 24) | (v17 << 16);
                v20 = BYTE1(__src[0]) & 0x7F;
                v31 = v18 | v19 | v14;
                MIDI::Packetizer::add((unsigned int *)&v34, *(uint64_t *)v29, (int *)&v31);
                v33 = 0;
                v32 = 0;
                v31 = v18 | (v19 - 256) | v15;
                MIDI::Packetizer::add((unsigned int *)&v34, v7, (int *)&v31);
                *v13 = v26;
                v21 = v11 + 3 * v12;
                *(_BYTE *)(v21 + 1) = v20;
                *(_BYTE *)(v21 + 2) = v15;
                goto LABEL_27;
              }
              v17 = v12 | 0xB0;
              if (v15 != *(unsigned __int8 *)(v11 + 3 * v12 + 2))
                goto LABEL_23;
              v18 = (v8 << 24) | (v17 << 16);
LABEL_27:
              v33 = 0;
              v32 = 0;
              v31 = v18 | (v9 >> 25) | 0x600;
              MIDI::Packetizer::add((unsigned int *)&v34, v7, (int *)&v31);
              if (((v9 >> 18) & 0x7F) != 0)
              {
                v33 = 0;
                v32 = 0;
                v31 = (v9 >> 18) & 0x7F | v18 | 0x2600;
                MIDI::Packetizer::add((unsigned int *)&v34, v7, (int *)&v31);
              }
              break;
            case 8:
            case 9:
            case 10:
            case 11:
              v10 = BYTE2(__src[0]) >> 4 == 9;
              if (HIDWORD(__src[0]) >> 25)
                v10 = HIDWORD(__src[0]) >> 25;
              v33 = 0;
              v32 = 0;
              v31 = v10 | (BYTE2(__src[0]) << 16) | (v8 << 24) | __src[0] & 0x7F00;
              MIDI::Packetizer::add((unsigned int *)&v34, *(uint64_t *)v29, (int *)&v31);
              continue;
            case 12:
              if ((__src[0] & 1) != 0)
              {
                v33 = 0;
                v32 = 0;
                v23 = BYTE2(__src[0]) << 16;
                v31 = (v23 - 0x100000) & 0xFFFFFF80 | (v8 << 24) | (HIDWORD(__src[0]) >> 8) & 0x7F;
                MIDI::Packetizer::add((unsigned int *)&v34, *(uint64_t *)v29, (int *)&v31);
                v33 = 0;
                v32 = 0;
                v31 = (v23 - 0x100000) | (v8 << 24) | v9 & 0x7F | 0x2000;
                MIDI::Packetizer::add((unsigned int *)&v34, v7, (int *)&v31);
                v22 = v8 << 24;
              }
              else
              {
                v22 = v8 << 24;
                v23 = BYTE2(__src[0]) << 16;
              }
              v33 = 0;
              v32 = 0;
              v31 = HIWORD(v9) & 0x7F00 | v22 | v23;
              MIDI::Packetizer::add((unsigned int *)&v34, v7, (int *)&v31);
              continue;
            case 13:
              v33 = 0;
              v32 = 0;
              v31 = (BYTE2(__src[0]) << 16) | (v8 << 24) | (HIDWORD(__src[0]) >> 25 << 8);
              MIDI::Packetizer::add((unsigned int *)&v34, *(uint64_t *)v29, (int *)&v31);
              continue;
            case 14:
              v33 = 0;
              v32 = 0;
              v31 = (HIDWORD(__src[0]) >> 10) & 0x7F00 | (BYTE2(__src[0]) << 16) | (v8 << 24) | (HIDWORD(__src[0]) >> 25);
              MIDI::Packetizer::add((unsigned int *)&v34, *(uint64_t *)v29, (int *)&v31);
              continue;
            default:
              continue;
          }
        }
      }
      v5 += v5[2] + 3;
      v4 = v27 + 1;
      if ((v27 + 1) >= a2[1])
        return MIDI::PacketizerBase<MIDI::EventList>::~PacketizerBase((uint64_t)&v34);
    }
  }
  if (*a2 != 1)
    std::terminate();
  v34 = a2;
  return (**(uint64_t (***)(uint64_t, _DWORD **))(a1 + 8))(a1 + 16, &v34);
}

void sub_1D4ED15CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  _Unwind_Resume(exception_object);
}

uint64_t MIDI::MIDI_1UP_Deliverer::operator()(uint64_t a1, unsigned int *a2)
{
  unsigned int *v4;
  uint64_t v5;
  _BYTE v6[48];
  uint64_t v7;
  _QWORD v8[8];
  _QWORD v9[128];

  v9[127] = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD *)(a1 + 8);
  (*(void (**)(_BYTE *, uint64_t))(v5 + 8))(v6, a1 + 16);
  v7 = v5;
  (*(void (**)(_QWORD *, _BYTE *))(v5 + 8))(v8, v6);
  v8[7] = 1;
  v8[6] = v9;
  v4 = (unsigned int *)&v7;
  MIDI::LegacyPacketList::traverse<MIDI::MIDIPacketList_to_MIDIEventList(MIDIPacketList const*,caulk::inplace_function<void ()(MIDI::EventList const*),48ul,8ul,caulk::inplace_function_detail::vtable>)::{lambda(MIDIPacket const*)#1}>(a2, &v4);
  MIDI::PacketizerBase<MIDI::EventList>::~PacketizerBase((uint64_t)&v7);
  return (*(uint64_t (**)(_BYTE *))(v5 + 24))(v6);
}

void sub_1D4ED16B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

unsigned int *MIDI::LegacyPacketList::traverse<MIDI::MIDIPacketList_to_MIDIEventList(MIDIPacketList const*,caulk::inplace_function<void ()(MIDI::EventList const*),48ul,8ul,caulk::inplace_function_detail::vtable>)::{lambda(MIDIPacket const*)#1}>(unsigned int *result, unsigned int **a2)
{
  unsigned int *v3;
  unsigned int v4;
  unint64_t v5;
  uint64_t v6;
  _QWORD __src[2];
  int v8[2];
  uint64_t v9[4];

  if (*result)
  {
    v3 = result;
    v4 = 0;
    v5 = (unint64_t)(result + 1);
    do
    {
      v6 = *(unsigned __int16 *)(v5 + 8);
      v9[0] = v5 + 10;
      v9[1] = v6;
      v9[2] = *(_QWORD *)v5;
      v9[3] = 0;
      while (1)
      {
        __src[1] = 0;
        *(_QWORD *)v8 = 0;
        __src[0] = 0;
        result = (unsigned int *)MIDI::LegacyPacketList::PacketReader::read(v9, v8, __src);
        if (!(_DWORD)result)
          break;
        MIDI::Packetizer::add(*a2, *(uint64_t *)v8, (int *)__src);
      }
      v5 = (v5 + *(unsigned __int16 *)(v5 + 8) + 13) & 0xFFFFFFFFFFFFFFFCLL;
      ++v4;
    }
    while (v4 < *v3);
  }
  return result;
}

uint64_t caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<MIDIInputPort::AddConnectedSource(MIDISource *,void *)::$_1>(caulk::inplace_function_detail::wrapper<MIDIInputPort::AddConnectedSource(MIDISource *,void *)::$_1>)::{lambda(void *,MIDI::EventList const*&&)#1}::__invoke(_QWORD *a1, _QWORD *a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*a1 + 16))(*a1, *a2, a1[1]);
}

__n128 caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<MIDIInputPort::AddConnectedSource(MIDISource *,void *)::$_1>(caulk::inplace_function_detail::wrapper<MIDIInputPort::AddConnectedSource(MIDISource *,void *)::$_1>)::{lambda(void *,void *)#1}::__invoke(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  *a1 = *a2;
  return result;
}

__n128 caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<MIDIInputPort::AddConnectedSource(MIDISource *,void *)::$_1>(caulk::inplace_function_detail::wrapper<MIDIInputPort::AddConnectedSource(MIDISource *,void *)::$_1>)::{lambda(void *,void *)#2}::__invoke(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  *a1 = *a2;
  return result;
}

void caulk::inplace_function_detail::vtable<void,MIDI::LegacyPacketList const*>::vtable(void)::{lambda(void *,MIDI::LegacyPacketList const*&&)#1}::__invoke()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
}

uint64_t caulk::inplace_function_detail::vtable<void,MIDI::LegacyPacketList const*>::vtable<MIDIInputPort::AddConnectedSource(MIDISource *,void *)::$_0>(caulk::inplace_function_detail::wrapper<MIDIInputPort::AddConnectedSource(MIDISource *,void *)::$_0>)::{lambda(void *,MIDI::LegacyPacketList const*&&)#1}::__invoke(_QWORD *a1, _QWORD *a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*a1 + 16))(*a1, *a2, a1[1]);
}

__n128 caulk::inplace_function_detail::vtable<void,MIDI::LegacyPacketList const*>::vtable<MIDIInputPort::AddConnectedSource(MIDISource *,void *)::$_0>(caulk::inplace_function_detail::wrapper<MIDIInputPort::AddConnectedSource(MIDISource *,void *)::$_0>)::{lambda(void *,void *)#1}::__invoke(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  *a1 = *a2;
  return result;
}

__n128 caulk::inplace_function_detail::vtable<void,MIDI::LegacyPacketList const*>::vtable<MIDIInputPort::AddConnectedSource(MIDISource *,void *)::$_0>(caulk::inplace_function_detail::wrapper<MIDIInputPort::AddConnectedSource(MIDISource *,void *)::$_0>)::{lambda(void *,void *)#2}::__invoke(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  *a1 = *a2;
  return result;
}

_QWORD *MIDIInputPort::RemoveConnectedSource(_QWORD *result, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;

  v2 = (_QWORD *)result[10];
  v3 = (_QWORD *)result[11];
  if (v2 != v3)
  {
    v5 = result;
    while (*v2 != a2)
    {
      v2 += 2;
      if (v2 == v3)
        return result;
    }
    if (v2 != v3)
    {
      v6 = v2 + 2;
      if (v2 + 2 != v3)
      {
        do
        {
          if (*v6 != a2)
          {
            *v2 = *v6;
            v7 = v6[1];
            v6[1] = 0;
            result = (_QWORD *)v2[1];
            v2[1] = v7;
            if (result)
              result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 8))(result);
            v2 += 2;
          }
          v6 += 2;
        }
        while (v6 != v3);
        v3 = (_QWORD *)v5[11];
      }
    }
    if (v2 != v3)
    {
      while (v3 != v2)
      {
        result = (_QWORD *)*(v3 - 1);
        *(v3 - 1) = 0;
        if (result)
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 8))(result);
        v3 -= 2;
      }
      v5[11] = v2;
    }
  }
  return result;
}

uint64_t MIDIInputPort::DeliverPacketsToInputPort(uint64_t this, const MIDI::EventList *a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD **i;

  v3 = *(_QWORD *)(this + 48);
  if (v3)
  {
    v4 = *(_QWORD *)(v3 + 48);
    if (v4)
      return ClientProcess::DeliverPacketsToClient(v4, *(_DWORD *)(this + 8), a3, a2);
  }
  for (i = *(_QWORD ***)(this + 80); i != *(_QWORD ***)(this + 88); i += 2)
  {
    if (*((_DWORD *)*i + 2) == a3)
      return (*(uint64_t (**)(_QWORD *, const MIDI::EventList *))(*i[1] + 16))(i[1], a2);
  }
  return this;
}

uint64_t *std::unique_ptr<MIDIDriverKitPluginRegistrar>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    MIDIClientDispose(*(_DWORD *)(v2 + 24));
    v3 = *(_QWORD *)(v2 + 16);
    *(_QWORD *)(v2 + 16) = 0;
    if (v3)
      std::default_delete<applesauce::iokit::io_service_factory>::operator()[abi:ne180100](v3);
    v4 = *(_QWORD *)(v2 + 8);
    *(_QWORD *)(v2 + 8) = 0;
    if (v4)
      std::default_delete<applesauce::iokit::io_service_factory>::operator()[abi:ne180100](v4);
    JUMPOUT(0x1D826BA98);
  }
  return result;
}

void DriverIOThread::~DriverIOThread(DriverIOThread *this)
{
  JUMPOUT(0x1D826BA98);
}

uint64_t DriverIOThread::Start(DriverIOThread *this)
{
  CADeprecated::CAPThread::SetTimeConstraints(this, 0, 6000, 12000, 1);
  return CADeprecated::CAPThread::Start((uint64_t)this);
}

void DriverIOThread::Run(DriverIOThread *this)
{
  const __CFString *v1;

  *((_QWORD *)this + 18) = CFRunLoopGetCurrent();
  v1 = (const __CFString *)*MEMORY[0x1E0C9B280];
  while (1)
  {
    while ((CFRunLoopRunInMode(v1, 1.0, 0) - 1) > 1)
      ;
    sleep(1u);
  }
}

void MIDIDriverMgr::StopMIDI(MIDIDriverMgr *this)
{
  NSObject *v2;
  SetupManager *v3;
  int v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  int v8;
  int v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  gDriverTable();
  v2 = gDriverTable(void)::drvtbl;
  v3 = (SetupManager *)os_log_type_enabled((os_log_t)gDriverTable(void)::drvtbl, OS_LOG_TYPE_DEBUG);
  if ((_DWORD)v3)
  {
    v4 = *(unsigned __int8 *)this;
    v9 = 136315650;
    v10 = "DriverTable.cpp";
    v11 = 1024;
    v12 = 164;
    v13 = 1024;
    v14 = v4;
    _os_log_impl(&dword_1D4E88000, v2, OS_LOG_TYPE_DEBUG, "%25s:%-5d StopMIDI: (already running: %d)\n", (uint8_t *)&v9, 0x18u);
  }
  if (*(_BYTE *)this)
  {
    v5 = (uint64_t *)*((_QWORD *)this + 2);
    v6 = (uint64_t *)*((_QWORD *)this + 3);
    while (v5 != v6)
    {
      v7 = *v5++;
      v3 = (SetupManager *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 96))(v7);
    }
    *(_BYTE *)this = 0;
    if (*(_QWORD *)SetupManager::instance(v3))
      MIDISetup::SetMIDIRunning((MIDISetup *)*(unsigned __int8 *)this, v8);
  }
}

void gDriverTable(void)
{
  unsigned __int8 v0;

  if ((v0 & 1) == 0)
  {
    {
      gDriverTable(void)::drvtbl = (uint64_t)os_log_create("com.apple.coremidi", "drvtbl");
    }
  }
}

uint64_t MIDIDriverMgr::GetDriverDeviceList(MIDIDriverMgr *this, MIDIDriverPlugin *a2)
{
  MIDISetup *v3;
  uint64_t DriverDevices;

  v3 = *(MIDISetup **)SetupManager::instance(this);
  if (v3)
  {
    DriverDevices = MIDISetup::GetDriverDevices(v3, this);
  }
  else
  {
    DriverDevices = operator new();
    BaseOpaqueObject::BaseOpaqueObject((BaseOpaqueObject *)DriverDevices);
    *(_QWORD *)(DriverDevices + 16) = 0;
    *(_QWORD *)(DriverDevices + 24) = 0;
    *(_QWORD *)(DriverDevices + 32) = 0;
    *(_QWORD *)DriverDevices = &off_1E98B91D0;
  }
  return *(unsigned int *)(DriverDevices + 8);
}

void sub_1D4ED1CAC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D826BA98](v1, 0x1081C40F159ABB6);
  _Unwind_Resume(a1);
}

uint64_t CADeprecated::XThread::RunHelper(CADeprecated::XThread *this, void *a2)
{
  (*(void (**)(CADeprecated::XThread *, void *))(*(_QWORD *)this + 32))(this, a2);
  return 0;
}

uint64_t CADeprecated::XThread::Stop(CADeprecated::XThread *this)
{
  int v2;
  uint64_t result;

  v2 = *((unsigned __int8 *)this + 123);
  *((_BYTE *)this + 123) = 0;
  for (result = (*(uint64_t (**)(CADeprecated::XThread *))(*(_QWORD *)this + 24))(this);
        atomic_load((unint64_t *)this + 1);
  if (v2)
    return (*(uint64_t (**)(CADeprecated::XThread *))(*(_QWORD *)this + 8))(this);
  return result;
}

void CreateMIDITimerThread()
{
  uint64_t v0;
  _opaque_pthread_t *v1;
  _opaque_pthread_t *v2;

  if (!gMIDITimerThread)
  {
    v0 = operator new();
    *(_QWORD *)v0 = &off_1E98B9E18;
    *(_QWORD *)(v0 + 8) = 0;
    v1 = pthread_self();
    *(_DWORD *)(v0 + 16) = CADeprecated::CAPThread::getScheduledPriority(v1, v2);
    *(_QWORD *)(v0 + 24) = CADeprecated::XThread::RunHelper;
    *(_QWORD *)(v0 + 32) = v0;
    *(_OWORD *)(v0 + 104) = xmmword_1D4F18AA0;
    *(_DWORD *)(v0 + 120) = 257;
    *(_OWORD *)(v0 + 40) = 0u;
    *(_OWORD *)(v0 + 56) = 0u;
    *(_OWORD *)(v0 + 72) = 0u;
    *(_OWORD *)(v0 + 88) = 0u;
    *(_QWORD *)(v0 + 128) = "";
    *(_QWORD *)v0 = &off_1E98B9C40;
    *(_BYTE *)(v0 + 136) = 0;
    CADeprecated::CAGuard::CAGuard((CADeprecated::CAGuard *)(v0 + 144), "TimerTaskMgr");
    *(_QWORD *)(v0 + 296) = 0;
    *(_QWORD *)(v0 + 304) = 0;
    *(_BYTE *)(v0 + 313) = 0;
    *(_QWORD *)(v0 + 280) = 4800;
    *(_QWORD *)(v0 + 288) = 0;
    gMIDITimerThread = v0;
    (*(void (**)(uint64_t))(*(_QWORD *)v0 + 16))(v0);
  }
}

void sub_1D4ED1E3C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D826BA98](v1, 0x10F1C401068BC31);
  _Unwind_Resume(a1);
}

_QWORD *MIDITimerTaskCreate(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;

  if (!gMIDITimerThread)
    CreateMIDITimerThread();
  v4 = (_QWORD *)operator new();
  *v4 = &off_1E98B99E0;
  v4[1] = -1;
  v4[2] = "";
  v4[3] = a1;
  v4[4] = a2;
  CADeprecated::TimerTaskMgr::AddTask(gMIDITimerThread, (uint64_t)v4);
  return v4;
}

void OpaqueMIDITimerTask::~OpaqueMIDITimerTask(OpaqueMIDITimerTask *this)
{
  JUMPOUT(0x1D826BA98);
}

uint64_t OpaqueMIDITimerTask::Perform(OpaqueMIDITimerTask *this)
{
  return (*((uint64_t (**)(_QWORD))this + 3))(*((_QWORD *)this + 4));
}

uint64_t MIDITimerTaskDispose(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  char *v5;
  char *v6;
  int64_t v7;

  v2 = gMIDITimerThread;
  v3 = gMIDITimerThread + 144;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(gMIDITimerThread + 144) + 16))(gMIDITimerThread + 144);
  v6 = *(char **)(v2 + 288);
  v5 = *(char **)(v2 + 296);
  if (v6 != v5)
  {
    while (*(_QWORD *)v6 != a1)
    {
      v6 += 8;
      if (v6 == v5)
      {
        v6 = *(char **)(v2 + 296);
        break;
      }
    }
  }
  if (v6 != v5)
  {
    v7 = v5 - (v6 + 8);
    if (v5 != v6 + 8)
      memmove(v6, v6 + 8, v5 - (v6 + 8));
    *(_QWORD *)(v2 + 296) = &v6[v7];
  }
  *(_BYTE *)(v2 + 312) = 1;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 8))(a1);
}

uint64_t MIDITimerTaskSetNextWakeTime(uint64_t a1, unint64_t a2)
{
  return CADeprecated::TimerTaskMgr::SetTaskNextWakeTime(gMIDITimerThread, a1, a2);
}

void gCIMsgEmitter(void)
{
  unsigned __int8 v0;

  if ((v0 & 1) == 0)
  {
    {
      gCIMsgEmitter(void)::ciemit = (uint64_t)os_log_create("com.apple.coremidi", "ciemit");
    }
  }
}

uint64_t MUIDGenerator::instance(MUIDGenerator *this)
{
  unsigned __int8 v1;
  MUIDGenerator *v3;

  {
    v3 = (MUIDGenerator *)operator new();
    MUIDGenerator::MUIDGenerator(v3);
    MUIDGenerator::instance(void)::m = (uint64_t)v3;
  }
  return MUIDGenerator::instance(void)::m;
}

void sub_1D4ED20B4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D826BA98](v1, 0x1000C4052888210);
  _Unwind_Resume(a1);
}

uint64_t MUIDGenerator::operator()(_DWORD *a1)
{
  unsigned int v1;
  unsigned int v2;
  BOOL v3;
  unsigned int i;
  int v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;

  v1 = 48271 * (*a1 % 0xADC8u);
  v2 = 3399 * (*a1 / 0xADC8u);
  v3 = v1 >= v2;
  for (i = v1 - v2; ; i = v8 - v7)
  {
    v5 = v3 ? 0 : 0x7FFFFFFF;
    v6 = i + v5;
    if (v6 <= 0xFFFFEFF)
      break;
    v7 = v6 / 0xADC8;
    v8 = 48271 * (v6 % 0xADC8);
    v7 *= 3399;
    v3 = v8 >= v7;
  }
  *a1 = v6;
  return v6;
}

void std::__function::__func<MIDICI::DeviceManager::DeviceManager(UMPCIServerContext &)::$_1,std::allocator<MIDICI::DeviceManager::DeviceManager(UMPCIServerContext &)::$_1>,void ()(UMPCIObjectEvent,unsigned int,applesauce::CF::DictionaryRef)>::~__func()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *std::__function::__func<MIDICI::DeviceManager::DeviceManager(UMPCIServerContext &)::$_1,std::allocator<MIDICI::DeviceManager::DeviceManager(UMPCIServerContext &)::$_1>,void ()(UMPCIObjectEvent,unsigned int,applesauce::CF::DictionaryRef)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E98B73C8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<MIDICI::DeviceManager::DeviceManager(UMPCIServerContext &)::$_1,std::allocator<MIDICI::DeviceManager::DeviceManager(UMPCIServerContext &)::$_1>,void ()(UMPCIObjectEvent,unsigned int,applesauce::CF::DictionaryRef)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E98B73C8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<MIDICI::DeviceManager::DeviceManager(UMPCIServerContext &)::$_1,std::allocator<MIDICI::DeviceManager::DeviceManager(UMPCIServerContext &)::$_1>,void ()(UMPCIObjectEvent,unsigned int,applesauce::CF::DictionaryRef)>::operator()(uint64_t a1, int *a2, int *a3, const void **a4)
{
  int v4;
  int v5;
  const void *v6;
  MIDICI::DeviceManager *v7;
  unsigned int *v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t v16;
  unsigned int v17;
  int v18;
  NSObject *v19;
  int v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  __int16 v26;
  unsigned int v27;
  __int16 v28;
  int v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v4 = *a2;
  v5 = *a3;
  v6 = *a4;
  *a4 = 0;
  if (!v4)
  {
    v7 = *(MIDICI::DeviceManager **)(a1 + 8);
    v8 = (unsigned int *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<UMPCIObject>::sRTTI, v5);
    v9 = v8;
    if (v8)
    {
      v10 = v8[40] - v8[38];
      v11 = (v10 >> 3);
      if ((v10 >> 3))
      {
        v12 = 0;
        v13 = v8[26];
        while (2)
        {
          v14 = (uint64_t *)*((_QWORD *)v9 + 19);
          v15 = (uint64_t *)*((_QWORD *)v9 + 20);
          while (v14 != v15)
          {
            if (*(unsigned __int8 *)(*v14 + 96) == v12)
            {
              if (v14 != v15)
              {
                v16 = *v14;
                if (v16)
                {
                  v17 = *(unsigned __int8 *)(v16 + 104);
                  v18 = MIDICI::DeviceManager::sendDiscoveryInquiryMessage(v7, v13, v17);
                  if (v18)
                  {
                    gMIDICIDeviceManagerLog();
                    v19 = gMIDICIDeviceManagerLog(void)::logCat;
                    if (os_log_type_enabled((os_log_t)gMIDICIDeviceManagerLog(void)::logCat, OS_LOG_TYPE_INFO))
                    {
                      v20 = 136316162;
                      v21 = "CIDeviceManager.cpp";
                      v22 = 1024;
                      v23 = 246;
                      v24 = 1024;
                      v25 = v13;
                      v26 = 1024;
                      v27 = v17;
                      v28 = 1024;
                      v29 = v18;
                      _os_log_impl(&dword_1D4E88000, v19, OS_LOG_TYPE_INFO, "%25s:%-5d ERROR: Failed to send MIDI-CI discovery inquiry to destination %ud, block %ud with error: %d", (uint8_t *)&v20, 0x24u);
                    }
                    goto LABEL_2;
                  }
                }
              }
              break;
            }
            ++v14;
          }
          if (++v12 < v11)
            continue;
          break;
        }
      }
    }
  }
LABEL_2:
  if (v6)
    CFRelease(v6);
}

void sub_1D4ED2364(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

uint64_t MIDICI::DeviceManager::sendDiscoveryInquiryMessage(MIDICI::DeviceManager *this, uint64_t a2, unsigned int a3)
{
  uint64_t v6;
  _BYTE v8[8];
  void *__p;
  void *__dst;
  int __src;
  uint64_t v12;

  midi::ci::message::make_with_payload_size((midi::ci::message *)v8, 18, 112, *((_DWORD *)this + 24), 0xFFFFFFFu, 127);
  midi::sysex7::add_device_identity((uint64_t)v8);
  LOBYTE(__src) = 28;
  std::vector<unsigned char>::__insert_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((uint64_t)&__p, (char *)__dst, (char *)&__src, (char *)&__src + 1, 1);
  __src = 0x10000;
  std::vector<unsigned char>::__insert_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((uint64_t)&__p, (char *)__dst, (char *)&__src, (char *)&v12, 4);
  LOBYTE(__src) = 0;
  std::vector<unsigned char>::__insert_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((uint64_t)&__p, (char *)__dst, (char *)&__src, (char *)&__src + 1, 1);
  v6 = MIDICI::DeviceManager::sendMessage((uint64_t)this, a2, a3, (uint64_t)v8);
  if (__p)
    operator delete(__p);
  return v6;
}

void sub_1D4ED248C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void gMIDICIDeviceManagerLog(void)
{
  unsigned __int8 v0;

  if ((v0 & 1) == 0)
  {
    {
      gMIDICIDeviceManagerLog(void)::logCat = (uint64_t)os_log_create("com.apple.coremidi", "server-ci-manager");
    }
  }
}

uint64_t MIDICI::DeviceManager::sendMessage(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  _DWORD *v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD v23[3];
  void *__p;
  _BYTE *v25;
  unint64_t v26;
  uint64_t v27;

  v8 = 3;
  if ((*(_DWORD *)a4 & 0xFF0000) != 0)
    v8 = 1;
  if (*(_DWORD *)a4)
    v9 = v8;
  else
    v9 = 0;
  std::vector<unsigned char>::vector(&__p, ((2* (((unint64_t)(v9 + *(_QWORD *)(a4 + 16) - *(_QWORD *)(a4 + 8)) * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64)) & 0xFFFFFFFFFFFFFFF8)+ 28);
  v10 = __p;
  v23[0] = __p;
  v23[1] = v25 - (_BYTE *)__p;
  *(_QWORD *)__p = 1;
  v23[2] = v10 + 2;
  v10[4] = 0;
  if (a3 >= 0x10)
    __assert_rtn("set_group", "universal_packet.h", 414, "c < 16");
  v11 = 3;
  if ((*(_DWORD *)a4 & 0xFF0000) != 0)
    v11 = 1;
  if (!*(_DWORD *)a4)
    v11 = 0;
  v12 = (unint64_t)(v11 + *(_QWORD *)(a4 + 16) - *(_QWORD *)(a4 + 8)) >= 7;
  v13 = 806354944;
  if (!v12)
    v13 = 805306368;
  v26 = v13 | ((unint64_t)a3 << 24);
  v27 = 0;
  midi::sysex7_packet::add_payload_byte((midi::sysex7_packet *)&v26);
  if ((unsigned __int16)*(_DWORD *)a4)
  {
    midi::sysex7_packet::add_payload_byte((midi::sysex7_packet *)&v26);
    midi::sysex7_packet::add_payload_byte((midi::sysex7_packet *)&v26);
  }
  v16 = a4 + 8;
  v14 = *(_QWORD *)(a4 + 8);
  v15 = *(_QWORD *)(v16 + 8);
  if (v14 == v15)
  {
    LODWORD(v19) = v26;
  }
  else
  {
    v17 = (unint64_t)a3 << 24;
    v18 = ~v14 + v15;
    do
    {
      midi::sysex7_packet::add_payload_byte((midi::sysex7_packet *)&v26);
      LODWORD(v19) = v26;
      if ((v26 & 0xF0000) == 0x60000)
      {
        MIDICI::DeviceManager::sendMessage(unsigned int,unsigned char,midi::sysex7 const&)::$_0::operator()(v23, (unsigned int *)&v26);
        if (v18 >= 7)
          v20 = 807403520;
        else
          v20 = 808452096;
        v19 = v20 | v17;
        v26 = v19;
        v27 = 0;
      }
      ++v14;
      --v18;
    }
    while (v14 != v15);
  }
  if ((v19 & 0xF0000) != 0)
    MIDICI::DeviceManager::sendMessage(unsigned int,unsigned char,midi::sysex7 const&)::$_0::operator()(v23, (unsigned int *)&v26);
  v21 = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)a1 + 344))(*(unsigned int *)(*(_QWORD *)a1 + 340), a2, v23[0]);
  if (__p)
  {
    v25 = __p;
    operator delete(__p);
  }
  return v21;
}

void sub_1D4ED2708(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void midi::sysex7_packet::add_payload_byte(midi::sysex7_packet *this)
{
  uint64_t v1;

  v1 = *((_WORD *)this + 1) & 0xF;
  if (v1 < 6)
    __asm { BR              X13 }
  __assert_rtn("add_payload_byte", "data_message.h", 134, "size < 6");
}

_QWORD *MIDICI::DeviceManager::sendMessage(unsigned int,unsigned char,midi::sysex7 const&)::$_0::operator()(_QWORD *result, unsigned int *a2)
{
  _QWORD *v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  int v8;
  BOOL v9;
  unsigned int v10;
  BOOL v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  BOOL v15;
  char v16;
  int v17;
  BOOL v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;

  v2 = result;
  v3 = *a2;
  v4 = *(_QWORD *)((char *)&unk_1D4F192E8 + ((v3 >> 25) & 0x78));
  v5 = result[2];
  v6 = *result + result[1];
  v7 = v3 & 0xF0000000;
  v8 = *(_DWORD *)(*result + 4);
  if (v5)
    v9 = v8 == 0;
  else
    v9 = 1;
  if (!v9)
  {
    v10 = *(_DWORD *)(v5 + 8);
    v11 = v10 >= 2;
    v12 = v10 - 2;
    if (v11 && *(_DWORD *)(v5 + 12) >> 28 == 3)
    {
      v13 = *(_DWORD *)(v5 + 4 * v12 + 12);
      if (v13 >> 28 == 3)
        v14 = (v13 >> 20) & 0xF;
      else
        v14 = 255;
      if (v14)
        v15 = v14 == 3;
      else
        v15 = 1;
      v16 = v15;
      v17 = 1;
LABEL_24:
      if ((v3 & 0xF0E00000) != 0x30000000)
      {
        v18 = (v7 != 805306368) != v17 && *(_QWORD *)v5 == 0;
        if (v18 && (v16 & 1) == 0)
        {
LABEL_31:
          v19 = *(unsigned int *)(v5 + 8);
          if (v5 + 4 * (v4 + v19) + 12 > v6)
            return result;
          goto LABEL_36;
        }
      }
      goto LABEL_33;
    }
LABEL_23:
    v17 = 0;
    v16 = 0;
    goto LABEL_24;
  }
  if (v8)
  {
    if (!v5)
    {
      if (v7 != 805306368)
        goto LABEL_31;
LABEL_33:
      v5 += 4 * *(unsigned int *)(v5 + 8) + 12;
      goto LABEL_34;
    }
    goto LABEL_23;
  }
LABEL_34:
  if (v5 + 4 * v4 + 12 > v6)
    return result;
  LODWORD(v19) = 0;
  *(_DWORD *)(*result + 4) = v8 + 1;
  *(_QWORD *)v5 = 0;
  *(_DWORD *)(v5 + 8) = 0;
LABEL_36:
  result = (_QWORD *)(v5 + 4 * v19 + 12);
  switch(v4)
  {
    case 0:
      break;
    case 1:
      goto LABEL_40;
    case 2:
      goto LABEL_39;
    case 3:
      goto LABEL_38;
    case 4:
      v20 = *a2++;
      *(_DWORD *)result = v20;
      result = (_QWORD *)(v5 + 4 * v19 + 16);
LABEL_38:
      v21 = *a2++;
      *(_DWORD *)result = v21;
      result = (_QWORD *)((char *)result + 4);
LABEL_39:
      v22 = *a2++;
      *(_DWORD *)result = v22;
      result = (_QWORD *)((char *)result + 4);
LABEL_40:
      *(_DWORD *)result = *a2;
      break;
    default:
      result = memmove(result, a2, 4 * v4);
      break;
  }
  *(_DWORD *)(v5 + 8) += v4;
  v2[2] = v5;
  return result;
}

void std::__function::__func<MIDICI::DeviceManager::DeviceManager(UMPCIServerContext &)::$_0,std::allocator<MIDICI::DeviceManager::DeviceManager(UMPCIServerContext &)::$_0>,void ()(unsigned int,MIDIEventList const*)>::~__func()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *std::__function::__func<MIDICI::DeviceManager::DeviceManager(UMPCIServerContext &)::$_0,std::allocator<MIDICI::DeviceManager::DeviceManager(UMPCIServerContext &)::$_0>,void ()(unsigned int,MIDIEventList const*)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E98B7380;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<MIDICI::DeviceManager::DeviceManager(UMPCIServerContext &)::$_0,std::allocator<MIDICI::DeviceManager::DeviceManager(UMPCIServerContext &)::$_0>,void ()(unsigned int,MIDIEventList const*)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E98B7380;
  a2[1] = v2;
  return result;
}

void std::__function::__func<MIDICI::DeviceManager::DeviceManager(UMPCIServerContext &)::$_0,std::allocator<MIDICI::DeviceManager::DeviceManager(UMPCIServerContext &)::$_0>,void ()(unsigned int,MIDIEventList const*)>::operator()(uint64_t a1, unsigned int *a2, uint64_t *a3)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  std::mutex *v6;
  BOOL v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t **v16;
  uint64_t v17;
  unsigned int v18;
  BOOL v19;
  uint64_t *v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  NSObject *v26;
  const char *v27;
  _QWORD *v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  _QWORD *v34;
  uint64_t v35;
  _QWORD *v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  _QWORD *v40;
  uint64_t v41;
  _QWORD *v42;
  uint64_t v43;
  _QWORD *v44;
  uint64_t v45;
  _QWORD *v46;
  uint64_t v47;
  _QWORD *v48;
  uint64_t v49;
  _QWORD *v50;
  uint64_t v51;
  _QWORD *v52;
  uint64_t v53;
  _QWORD *v54;
  uint64_t v55;
  uint8_t *v56;
  uint64_t v57;
  _QWORD *v58;
  uint64_t v59;
  char *v60;
  _QWORD *v61;
  uint64_t v62;
  unsigned int v63;
  unsigned int *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t v69;
  BOOL v70;
  unsigned int v71;
  unsigned int v72;
  unint64_t v73;
  unsigned int v74;
  std::mutex *v75;
  uint64_t v76;
  unsigned int v77;
  uint64_t v78;
  uint64_t v79;
  unint64_t v80;
  unint64_t v81;
  size_t v82;
  unint64_t v83;
  size_t v84;
  uint64_t v85;
  char v86;
  uint64_t v87;
  uint64_t v88;
  unsigned int v89;
  char *v90;
  int v91;
  int v92;
  int v93;
  char v94;
  unint64_t v95;
  _BYTE *v96;
  _BYTE *v97;
  unint64_t v98;
  _BYTE *v99;
  unint64_t v100;
  unint64_t v101;
  size_t v102;
  char *v103;
  char *v104;
  _BYTE *v105;
  _BYTE *v106;
  char v107;
  uint64_t v108;
  uint64_t v109;
  std::mutex *v110;
  unsigned int v111;
  uint64_t v112;
  unint64_t *v113;
  unsigned int v114;
  unsigned int v115;
  _BYTE v116[24];
  _BYTE *v117;
  _QWORD v118[3];
  _QWORD *v119;
  _QWORD v120[3];
  _QWORD *v121;
  _QWORD v122[3];
  _QWORD *v123;
  _QWORD v124[3];
  _QWORD *v125;
  _QWORD v126[3];
  _QWORD *v127;
  _QWORD v128[3];
  _QWORD *v129;
  _QWORD v130[3];
  _QWORD *v131;
  _QWORD v132[3];
  _QWORD *v133;
  _QWORD v134[3];
  _QWORD *v135;
  _QWORD v136[3];
  _QWORD *v137;
  _QWORD v138[3];
  _QWORD *v139;
  _QWORD v140[3];
  _QWORD *v141;
  _QWORD v142[3];
  _QWORD *v143;
  _QWORD v144[3];
  _QWORD *v145;
  _QWORD v146[3];
  _QWORD *v147;
  uint8_t buf[24];
  uint8_t *v149;
  uint64_t v150;

  v150 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  v4 = *a3;
  v5 = *(_QWORD *)(a1 + 8);
  v6 = (std::mutex *)(v5 + 32);
  std::mutex::lock((std::mutex *)(v5 + 32));
  if (v3)
    v7 = v4 == 0;
  else
    v7 = 1;
  if (!v7)
  {
    v115 = v3;
    v8 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIEndpoint>::sRTTI, v3);
    if (v8)
    {
      v9 = *(_QWORD **)(v8 + 64);
      if (v9)
      {
        if (v9[10] != v9[9])
        {
          v11 = v9 + 13;
          v10 = v9[13];
          if (v11[1] != v10)
          {
            v12 = *(_DWORD *)(*(_QWORD *)v10 + 8);
            if (v12)
            {
              v13 = *(_DWORD *)(v8 + 44);
              v14 = *(_QWORD *)(v4 + 8);
              v15 = *(_QWORD *)(v5 + 112);
              v16 = (uint64_t **)(v5 + 104);
              v110 = (std::mutex *)(v5 + 32);
              if (v15)
              {
                v17 = v5 + 112;
                do
                {
                  v18 = *(_DWORD *)(v15 + 32);
                  v19 = v18 >= v3;
                  if (v18 >= v3)
                    v20 = (uint64_t *)v15;
                  else
                    v20 = (uint64_t *)(v15 + 8);
                  if (v19)
                    v17 = v15;
                  v15 = *v20;
                }
                while (*v20);
                if (v17 != v5 + 112 && *(_DWORD *)(v17 + 32) <= v3)
                  goto LABEL_114;
              }
              v21 = operator new();
              v22 = operator new(0x28uLL);
              *v22 = &off_1E98B7338;
              v22[1] = v5;
              *((_DWORD *)v22 + 4) = v3;
              *((_DWORD *)v22 + 5) = v12;
              *((_DWORD *)v22 + 6) = v13;
              v22[4] = v14;
              v117 = v22;
              std::__function::__func<MIDICI::DeviceManager::processBackground(unsigned int,MIDIEventList const*)::$_0,std::allocator<MIDICI::DeviceManager::processBackground(unsigned int,MIDIEventList const*)::$_0>,void ()(unsigned char,midi::sysex7 const&)>::__clone((uint64_t)v22);
              *(_QWORD *)(v21 + 24) = v23;
              *(_QWORD *)buf = &off_1E98B7920;
              *(_QWORD *)&buf[8] = v21;
              v149 = buf;
              *(_DWORD *)(v21 + 32) = 0;
              *(_OWORD *)(v21 + 40) = 0u;
              *(_OWORD *)(v21 + 56) = 0u;
              *(_WORD *)(v21 + 72) = 16;
              std::__function::__value_func<void ()(midi::sysex7 const&)>::__value_func[abi:ne180100](v21 + 80, (uint64_t)buf);
              v146[0] = &off_1E98B74E8;
              v146[1] = v21;
              v147 = v146;
              *(_DWORD *)(v21 + 112) = 0;
              *(_OWORD *)(v21 + 120) = 0u;
              *(_OWORD *)(v21 + 136) = 0u;
              *(_WORD *)(v21 + 152) = 16;
              std::__function::__value_func<void ()(midi::sysex7 const&)>::__value_func[abi:ne180100](v21 + 160, (uint64_t)v146);
              v144[0] = &off_1E98B7698;
              v144[1] = v21;
              v145 = v144;
              *(_DWORD *)(v21 + 192) = 0;
              *(_OWORD *)(v21 + 200) = 0u;
              *(_OWORD *)(v21 + 216) = 0u;
              *(_WORD *)(v21 + 232) = 16;
              std::__function::__value_func<void ()(midi::sysex7 const&)>::__value_func[abi:ne180100](v21 + 240, (uint64_t)v144);
              v142[0] = &off_1E98B76E0;
              v142[1] = v21;
              v143 = v142;
              *(_DWORD *)(v21 + 272) = 0;
              *(_OWORD *)(v21 + 280) = 0u;
              *(_OWORD *)(v21 + 296) = 0u;
              *(_WORD *)(v21 + 312) = 16;
              std::__function::__value_func<void ()(midi::sysex7 const&)>::__value_func[abi:ne180100](v21 + 320, (uint64_t)v142);
              v140[0] = &off_1E98B7728;
              v140[1] = v21;
              v141 = v140;
              *(_DWORD *)(v21 + 352) = 0;
              *(_OWORD *)(v21 + 360) = 0u;
              *(_OWORD *)(v21 + 376) = 0u;
              *(_WORD *)(v21 + 392) = 16;
              std::__function::__value_func<void ()(midi::sysex7 const&)>::__value_func[abi:ne180100](v21 + 400, (uint64_t)v140);
              v138[0] = &off_1E98B7770;
              v138[1] = v21;
              v139 = v138;
              *(_DWORD *)(v21 + 432) = 0;
              *(_OWORD *)(v21 + 440) = 0u;
              *(_OWORD *)(v21 + 456) = 0u;
              *(_WORD *)(v21 + 472) = 16;
              std::__function::__value_func<void ()(midi::sysex7 const&)>::__value_func[abi:ne180100](v21 + 480, (uint64_t)v138);
              v136[0] = &off_1E98B77B8;
              v136[1] = v21;
              v137 = v136;
              *(_DWORD *)(v21 + 512) = 0;
              *(_OWORD *)(v21 + 520) = 0u;
              *(_OWORD *)(v21 + 536) = 0u;
              *(_WORD *)(v21 + 552) = 16;
              std::__function::__value_func<void ()(midi::sysex7 const&)>::__value_func[abi:ne180100](v21 + 560, (uint64_t)v136);
              v134[0] = &off_1E98B7800;
              v134[1] = v21;
              v135 = v134;
              *(_DWORD *)(v21 + 592) = 0;
              *(_OWORD *)(v21 + 600) = 0u;
              *(_OWORD *)(v21 + 616) = 0u;
              *(_WORD *)(v21 + 632) = 16;
              std::__function::__value_func<void ()(midi::sysex7 const&)>::__value_func[abi:ne180100](v21 + 640, (uint64_t)v134);
              v132[0] = &off_1E98B7848;
              v132[1] = v21;
              v133 = v132;
              *(_DWORD *)(v21 + 672) = 0;
              *(_OWORD *)(v21 + 680) = 0u;
              *(_OWORD *)(v21 + 696) = 0u;
              *(_WORD *)(v21 + 712) = 16;
              std::__function::__value_func<void ()(midi::sysex7 const&)>::__value_func[abi:ne180100](v21 + 720, (uint64_t)v132);
              v130[0] = &off_1E98B7890;
              v130[1] = v21;
              v131 = v130;
              *(_DWORD *)(v21 + 752) = 0;
              *(_OWORD *)(v21 + 760) = 0u;
              *(_OWORD *)(v21 + 776) = 0u;
              *(_WORD *)(v21 + 792) = 16;
              std::__function::__value_func<void ()(midi::sysex7 const&)>::__value_func[abi:ne180100](v21 + 800, (uint64_t)v130);
              v128[0] = &off_1E98B78D8;
              v128[1] = v21;
              v129 = v128;
              *(_DWORD *)(v21 + 832) = 0;
              *(_OWORD *)(v21 + 840) = 0u;
              *(_OWORD *)(v21 + 856) = 0u;
              *(_WORD *)(v21 + 872) = 16;
              std::__function::__value_func<void ()(midi::sysex7 const&)>::__value_func[abi:ne180100](v21 + 880, (uint64_t)v128);
              v126[0] = &off_1E98B7530;
              v126[1] = v21;
              v127 = v126;
              *(_DWORD *)(v21 + 912) = 0;
              *(_OWORD *)(v21 + 920) = 0u;
              *(_OWORD *)(v21 + 936) = 0u;
              *(_WORD *)(v21 + 952) = 16;
              std::__function::__value_func<void ()(midi::sysex7 const&)>::__value_func[abi:ne180100](v21 + 960, (uint64_t)v126);
              v124[0] = &off_1E98B7578;
              v124[1] = v21;
              v125 = v124;
              *(_DWORD *)(v21 + 992) = 0;
              *(_OWORD *)(v21 + 1000) = 0u;
              *(_OWORD *)(v21 + 1016) = 0u;
              *(_WORD *)(v21 + 1032) = 16;
              std::__function::__value_func<void ()(midi::sysex7 const&)>::__value_func[abi:ne180100](v21 + 1040, (uint64_t)v124);
              v122[0] = &off_1E98B75C0;
              v122[1] = v21;
              v123 = v122;
              *(_DWORD *)(v21 + 1072) = 0;
              *(_OWORD *)(v21 + 1080) = 0u;
              *(_OWORD *)(v21 + 1096) = 0u;
              *(_WORD *)(v21 + 1112) = 16;
              std::__function::__value_func<void ()(midi::sysex7 const&)>::__value_func[abi:ne180100](v21 + 1120, (uint64_t)v122);
              v120[0] = &off_1E98B7608;
              v120[1] = v21;
              v121 = v120;
              *(_DWORD *)(v21 + 1152) = 0;
              *(_OWORD *)(v21 + 1160) = 0u;
              *(_OWORD *)(v21 + 1176) = 0u;
              *(_WORD *)(v21 + 1192) = 16;
              std::__function::__value_func<void ()(midi::sysex7 const&)>::__value_func[abi:ne180100](v21 + 1200, (uint64_t)v120);
              v118[0] = &off_1E98B7650;
              v118[1] = v21;
              v119 = v118;
              *(_DWORD *)(v21 + 1232) = 0;
              *(_OWORD *)(v21 + 1240) = 0u;
              *(_OWORD *)(v21 + 1256) = 0u;
              *(_WORD *)(v21 + 1272) = 16;
              std::__function::__value_func<void ()(midi::sysex7 const&)>::__value_func[abi:ne180100](v21 + 1280, (uint64_t)v118);
              v24 = v119;
              if (v119 == v118)
              {
                v25 = 4;
                v24 = v118;
              }
              else
              {
                if (!v119)
                  goto LABEL_32;
                v25 = 5;
              }
              (*(void (**)(void))(*v24 + 8 * v25))();
LABEL_32:
              v28 = v121;
              if (v121 == v120)
              {
                v29 = 4;
                v28 = v120;
              }
              else
              {
                if (!v121)
                  goto LABEL_37;
                v29 = 5;
              }
              (*(void (**)(void))(*v28 + 8 * v29))();
LABEL_37:
              v30 = v123;
              if (v123 == v122)
              {
                v31 = 4;
                v30 = v122;
              }
              else
              {
                if (!v123)
                  goto LABEL_42;
                v31 = 5;
              }
              (*(void (**)(void))(*v30 + 8 * v31))();
LABEL_42:
              v32 = v125;
              if (v125 == v124)
              {
                v33 = 4;
                v32 = v124;
              }
              else
              {
                if (!v125)
                  goto LABEL_47;
                v33 = 5;
              }
              (*(void (**)(void))(*v32 + 8 * v33))();
LABEL_47:
              v34 = v127;
              if (v127 == v126)
              {
                v35 = 4;
                v34 = v126;
              }
              else
              {
                if (!v127)
                  goto LABEL_52;
                v35 = 5;
              }
              (*(void (**)(void))(*v34 + 8 * v35))();
LABEL_52:
              v36 = v129;
              if (v129 == v128)
              {
                v37 = 4;
                v36 = v128;
              }
              else
              {
                if (!v129)
                  goto LABEL_57;
                v37 = 5;
              }
              (*(void (**)(void))(*v36 + 8 * v37))();
LABEL_57:
              v38 = v131;
              if (v131 == v130)
              {
                v39 = 4;
                v38 = v130;
              }
              else
              {
                if (!v131)
                  goto LABEL_62;
                v39 = 5;
              }
              (*(void (**)(void))(*v38 + 8 * v39))();
LABEL_62:
              v40 = v133;
              if (v133 == v132)
              {
                v41 = 4;
                v40 = v132;
              }
              else
              {
                if (!v133)
                  goto LABEL_67;
                v41 = 5;
              }
              (*(void (**)(void))(*v40 + 8 * v41))();
LABEL_67:
              v42 = v135;
              if (v135 == v134)
              {
                v43 = 4;
                v42 = v134;
              }
              else
              {
                if (!v135)
                  goto LABEL_72;
                v43 = 5;
              }
              (*(void (**)(void))(*v42 + 8 * v43))();
LABEL_72:
              v44 = v137;
              if (v137 == v136)
              {
                v45 = 4;
                v44 = v136;
              }
              else
              {
                if (!v137)
                  goto LABEL_77;
                v45 = 5;
              }
              (*(void (**)(void))(*v44 + 8 * v45))();
LABEL_77:
              v46 = v139;
              if (v139 == v138)
              {
                v47 = 4;
                v46 = v138;
              }
              else
              {
                if (!v139)
                  goto LABEL_82;
                v47 = 5;
              }
              (*(void (**)(void))(*v46 + 8 * v47))();
LABEL_82:
              v48 = v141;
              if (v141 == v140)
              {
                v49 = 4;
                v48 = v140;
              }
              else
              {
                if (!v141)
                  goto LABEL_87;
                v49 = 5;
              }
              (*(void (**)(void))(*v48 + 8 * v49))();
LABEL_87:
              v50 = v143;
              if (v143 == v142)
              {
                v51 = 4;
                v50 = v142;
              }
              else
              {
                if (!v143)
                  goto LABEL_92;
                v51 = 5;
              }
              (*(void (**)(void))(*v50 + 8 * v51))();
LABEL_92:
              v52 = v145;
              if (v145 == v144)
              {
                v53 = 4;
                v52 = v144;
              }
              else
              {
                if (!v145)
                  goto LABEL_97;
                v53 = 5;
              }
              (*(void (**)(void))(*v52 + 8 * v53))();
LABEL_97:
              v54 = v147;
              if (v147 == v146)
              {
                v55 = 4;
                v54 = v146;
              }
              else
              {
                if (!v147)
                  goto LABEL_102;
                v55 = 5;
              }
              (*(void (**)(void))(*v54 + 8 * v55))();
LABEL_102:
              v56 = v149;
              if (v149 == buf)
              {
                v57 = 4;
                v56 = buf;
              }
              else
              {
                if (!v149)
                  goto LABEL_107;
                v57 = 5;
              }
              (*(void (**)(void))(*(_QWORD *)v56 + 8 * v57))();
LABEL_107:
              v58 = v117;
              if (v117 == v116)
              {
                v59 = 4;
                v58 = v116;
              }
              else
              {
                if (!v117)
                  goto LABEL_112;
                v59 = 5;
              }
              (*(void (**)(void))(*v58 + 8 * v59))();
LABEL_112:
              v3 = v115;
              v60 = std::__tree<std::__value_type<unsigned int,MIDICI::SourceState>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,MIDICI::SourceState>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,MIDICI::SourceState>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v16, v115, &v115);
              v61 = (_QWORD *)*((_QWORD *)v60 + 5);
              *((_QWORD *)v60 + 5) = v21;
              if (v61)
                std::default_delete<MIDICI::SysexCollector>::operator()[abi:ne180100](v61);
LABEL_114:
              v62 = *((_QWORD *)std::__tree<std::__value_type<unsigned int,MIDICI::SourceState>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,MIDICI::SourceState>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,MIDICI::SourceState>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v16, v3, &v115)+ 5);
              v63 = *(_DWORD *)(v4 + 4);
              if (v63)
              {
                v64 = (unsigned int *)(v4 + 20);
                v65 = v4 + 20 + 4 * *(unsigned int *)(v4 + 16);
              }
              else
              {
                v64 = 0;
                v65 = 0;
              }
              v66 = v62 + 32;
              v109 = v62 + 32;
              while (1)
              {
                if (v64 == (unsigned int *)v65)
                {
                  if (v63 < 2)
                    goto LABEL_29;
                  --v63;
                  v67 = v64[2];
                  v64 += 3;
                  v65 = (uint64_t)&v64[v67];
                }
                if (v64 == (unsigned int *)v65)
                  goto LABEL_29;
                *(_QWORD *)buf = 0;
                *(_QWORD *)&buf[8] = 0;
                v68 = *v64;
                v69 = v68 >> 28;
                if (MIDI::UniversalPacket::word_sizes[v68 >> 28])
                {
                  memmove(buf, v64, 4 * MIDI::UniversalPacket::word_sizes[v68 >> 28]);
                  LODWORD(v68) = *v64;
                  LODWORD(v69) = *v64 >> 28;
                }
                if ((_DWORD)v69)
                  v70 = (_DWORD)v69 == 15;
                else
                  v70 = 1;
                v71 = BYTE3(v68) & 0xF;
                if (v70)
                  v72 = 255;
                else
                  v72 = v71;
                v73 = *(unsigned int *)buf;
                if (*(_DWORD *)buf >> 28 != 3)
                  goto LABEL_190;
                v74 = buf[2] & 0xF0;
                if (v74 > 0x30 || (buf[2] & 0xFu) > 6)
                  goto LABEL_190;
                v75 = v6;
                v112 = v65;
                v76 = v66 + 80 * v72;
                v77 = v72;
                if ((buf[2] & 0xE0 | 0x10) == 0x10)
                {
                  if (*(_BYTE *)(v76 + 40) != 16)
                  {
                    midi::sysex::clear((midi::sysex *)(v66 + 80 * v72));
                    *(_BYTE *)(v76 + 40) = 16;
                    *(_BYTE *)(v66 + 80 * v77 + 41) = 0;
                  }
                }
                else if (*(_BYTE *)(v76 + 40) != 32)
                {
                  midi::sysex::clear((midi::sysex *)(v66 + 80 * v72));
                  *(_BYTE *)(v76 + 40) = 16;
                  *(_BYTE *)(v66 + 80 * v77 + 41) = 0;
                  v65 = v112;
                  v6 = v75;
                  goto LABEL_190;
                }
                v78 = (v73 >> 16) & 0xF;
                v79 = *(_QWORD *)(v76 + 8);
                v113 = (unint64_t *)(v76 + 8);
                v114 = v77;
                v80 = *(_QWORD *)(v76 + 16) - v79 + v78;
                v81 = *(_QWORD *)(v76 + 24) - v79;
                v6 = v75;
                if (v80 > v81)
                {
                  v82 = *(_QWORD *)(v66 + 80 * v114 + 32);
                  v83 = 2 * v81;
                  if (v83 <= 0x80)
                    v84 = 128;
                  else
                    v84 = v83;
                  if (v82)
                  {
                    if (v82 < v84)
                      v84 = *(_QWORD *)(v66 + 80 * v114 + 32);
                    std::vector<unsigned char>::reserve(v113, v84);
                    if ((unint64_t)(*(_QWORD *)(v76 + 16) + v78 - *(_QWORD *)(v76 + 8)) > *(_QWORD *)(v76 + 24)
                                                                                                - *(_QWORD *)(v76 + 8))
                    {
                      v85 = v66 + 80 * v114;
                      v86 = 16;
LABEL_188:
                      *(_BYTE *)(v85 + 40) = v86;
                      goto LABEL_189;
                    }
                  }
                  else
                  {
                    std::vector<unsigned char>::reserve(v113, v84);
                  }
                }
                if (!(_DWORD)v78)
                {
                  v89 = v114;
                  goto LABEL_182;
                }
                v111 = v63;
                v87 = v66;
                v88 = 0;
                v89 = v114;
                v90 = (char *)(v87 + 80 * v114 + 41);
                do
                {
                  if (v88 == 14)
                    __assert_rtn("get_byte", "universal_packet.h", 432, "b < 16");
                  v91 = *(_DWORD *)&buf[(v88 + 2) & 0xFFFFFFFFFFFFFFFCLL] >> (~(8 * (v88 + 2)) & 0x18);
                  v92 = *v90;
                  if (v92 == 2)
                  {
                    v93 = *(_DWORD *)v76 | (*(_DWORD *)&buf[(v88 + 2) & 0xFFFFFFFFFFFFFFFCLL] >> (~(8 * (v88 + 2)) & 0x18));
                    goto LABEL_158;
                  }
                  if (v92 == 1)
                  {
                    *(_DWORD *)v76 = (*(_DWORD *)&buf[(v88 + 2) & 0xFFFFFFFFFFFFFFFCLL] >> (~(8 * (v88 + 2)) & 0x18)) << 8;
                    v94 = 2;
LABEL_170:
                    *v90 = v94;
                    goto LABEL_179;
                  }
                  if (!*v90)
                  {
                    if ((*(_DWORD *)&buf[(v88 + 2) & 0xFFFFFFFFFFFFFFFCLL] >> (~(8 * (v88 + 2)) & 0x18)))
                    {
                      v93 = (*(_DWORD *)&buf[(v88 + 2) & 0xFFFFFFFFFFFFFFFCLL] >> (~(8 * (v88 + 2)) & 0x18)) << 16;
LABEL_158:
                      *(_DWORD *)v76 = v93;
                      *v90 = 3;
                      goto LABEL_179;
                    }
                    v94 = 1;
                    goto LABEL_170;
                  }
                  v96 = *(_BYTE **)(v76 + 16);
                  v95 = *(_QWORD *)(v76 + 24);
                  if ((unint64_t)v96 >= v95)
                  {
                    v98 = *v113;
                    v99 = &v96[-*v113];
                    v100 = (unint64_t)(v99 + 1);
                    if ((uint64_t)(v99 + 1) < 0)
                      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
                    v101 = v95 - v98;
                    if (2 * v101 > v100)
                      v100 = 2 * v101;
                    if (v101 >= 0x3FFFFFFFFFFFFFFFLL)
                      v102 = 0x7FFFFFFFFFFFFFFFLL;
                    else
                      v102 = v100;
                    if (v102)
                      v103 = (char *)operator new(v102);
                    else
                      v103 = 0;
                    v104 = &v99[(_QWORD)v103];
                    v105 = &v99[(_QWORD)v103];
                    *v105 = v91;
                    v97 = v105 + 1;
                    if (v96 != (_BYTE *)v98)
                    {
                      v106 = &v96[~v98];
                      do
                      {
                        v107 = *--v96;
                        (v106--)[(_QWORD)v103] = v107;
                      }
                      while (v96 != (_BYTE *)v98);
                      v96 = (_BYTE *)*v113;
                      v104 = v103;
                    }
                    *(_QWORD *)(v76 + 8) = v104;
                    *(_QWORD *)(v76 + 16) = v97;
                    *(_QWORD *)(v76 + 24) = &v103[v102];
                    if (v96)
                      operator delete(v96);
                  }
                  else
                  {
                    *v96 = v91;
                    v97 = v96 + 1;
                  }
                  *(_QWORD *)(v76 + 16) = v97;
                  v89 = v114;
LABEL_179:
                  ++v88;
                }
                while (v88 != v78);
                v74 = buf[2] & 0xF0;
                v66 = v109;
                v6 = v110;
                v63 = v111;
LABEL_182:
                if (v74 && v74 != 48)
                {
                  v85 = v66 + 80 * v89;
                  v86 = 32;
                  goto LABEL_188;
                }
                v108 = *(_QWORD *)(v66 + 80 * v89 + 72);
                if (v108)
                  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v108 + 48))(v108, v76);
                midi::sysex::clear((midi::sysex *)v76);
                *(_WORD *)(v66 + 80 * v114 + 40) = 16;
LABEL_189:
                v65 = v112;
LABEL_190:
                v64 += MIDI::UniversalPacket::word_sizes[(unint64_t)*v64 >> 28];
              }
            }
          }
        }
      }
      gMIDICIDeviceManagerLog();
      v26 = gMIDICIDeviceManagerLog(void)::logCat;
      if (os_log_type_enabled((os_log_t)gMIDICIDeviceManagerLog(void)::logCat, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = "CIDeviceManager.cpp";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 592;
        v27 = "%25s:%-5d ERROR: Failed to find UMP destination for source..";
LABEL_28:
        _os_log_impl(&dword_1D4E88000, v26, OS_LOG_TYPE_INFO, v27, buf, 0x12u);
      }
    }
    else
    {
      gMIDICIDeviceManagerLog();
      v26 = gMIDICIDeviceManagerLog(void)::logCat;
      if (os_log_type_enabled((os_log_t)gMIDICIDeviceManagerLog(void)::logCat, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = "CIDeviceManager.cpp";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 586;
        v27 = "%25s:%-5d ERROR: Failed to dereference source";
        goto LABEL_28;
      }
    }
  }
LABEL_29:
  std::mutex::unlock(v6);
}

void sub_1D4ED374C()
{
  _QWORD *v0;

  std::default_delete<MIDICI::SysexCollector>::operator()[abi:ne180100](v0);
}

void sub_1D4ED3758(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  _Unwind_Exception *v20;
  std::mutex *v21;

  std::mutex::unlock(v21);
  _Unwind_Resume(v20);
}

char *std::__tree<std::__value_type<unsigned int,MIDICI::SourceState>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,MIDICI::SourceState>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,MIDICI::SourceState>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t **a1, unsigned int a2, _DWORD *a3)
{
  char *v5;
  uint64_t **v6;
  char *v7;
  unsigned int v8;
  char *v9;
  uint64_t *v10;
  uint64_t *v11;

  v6 = a1 + 1;
  v5 = (char *)a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = v5;
        v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2)
          break;
        v5 = *(char **)v7;
        v6 = (uint64_t **)v7;
        if (!*(_QWORD *)v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = (char *)*((_QWORD *)v7 + 1);
      if (!v5)
      {
        v6 = (uint64_t **)(v7 + 8);
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = (char *)(a1 + 1);
LABEL_9:
    v9 = v7;
    v7 = (char *)operator new(0x48uLL);
    *((_DWORD *)v7 + 8) = *a3;
    *(_OWORD *)(v7 + 40) = 0u;
    *(_OWORD *)(v7 + 56) = 0u;
    *((_QWORD *)v7 + 6) = v7 + 56;
    *(_QWORD *)v7 = 0;
    *((_QWORD *)v7 + 1) = 0;
    *((_QWORD *)v7 + 2) = v9;
    *v6 = (uint64_t *)v7;
    v10 = (uint64_t *)**a1;
    v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void std::__function::__func<MIDICI::DeviceManager::processBackground(unsigned int,MIDIEventList const*)::$_0,std::allocator<MIDICI::DeviceManager::processBackground(unsigned int,MIDIEventList const*)::$_0>,void ()(unsigned char,midi::sysex7 const&)>::~__func()
{
  JUMPOUT(0x1D826BA98);
}

__n128 std::__function::__func<MIDICI::DeviceManager::processBackground(unsigned int,MIDIEventList const*)::$_0,std::allocator<MIDICI::DeviceManager::processBackground(unsigned int,MIDIEventList const*)::$_0>,void ()(unsigned char,midi::sysex7 const&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x28uLL);
  *(_QWORD *)v2 = &off_1E98B7338;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<MIDICI::DeviceManager::processBackground(unsigned int,MIDIEventList const*)::$_0,std::allocator<MIDICI::DeviceManager::processBackground(unsigned int,MIDIEventList const*)::$_0>,void ()(unsigned char,midi::sysex7 const&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E98B7338;
  result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<MIDICI::DeviceManager::processBackground(unsigned int,MIDIEventList const*)::$_0,std::allocator<MIDICI::DeviceManager::processBackground(unsigned int,MIDIEventList const*)::$_0>,void ()(unsigned char,midi::sysex7 const&)>::operator()(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t **v6;
  __n128 v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t (*v10)();
  unint64_t v11;
  int v12;
  unsigned int v13;
  unint64_t *v14;
  uint64_t *v15;
  char *v16;
  uint64_t (***v17)();
  uint64_t v18;
  char *v19;
  char *v20;
  int64_t v21;
  int64_t v22;
  unint64_t v23;
  size_t v24;
  char *v25;
  uint64_t **v26;
  uint64_t v27;
  int v28;
  MIDICI::DeviceManager *v29;
  MIDICI::DeviceManager *v30;
  uint64_t DeviceWithMUID;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  uint64_t *v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  BOOL v42;
  unsigned __int8 v43;
  unsigned __int16 v44;
  unsigned int v45;
  _BOOL4 v46;
  _BYTE *v47;
  unint64_t v48;
  char *v49;
  int v50;
  char *v51;
  char *v52;
  char *v53;
  char *v54;
  int64_t v55;
  void *v56;
  char *v57;
  char *v58;
  uint64_t **v59;
  int64_t v60;
  int64_t v61;
  unint64_t v62;
  size_t v63;
  char *v64;
  uint64_t i;
  char *v66;
  char *v67;
  char *v68;
  char *v69;
  int64_t v70;
  void *v71;
  char *v72;
  _BYTE *v73;
  unint64_t v74;
  uint64_t v75;
  char *v76;
  _QWORD *v77;
  uint64_t v78;
  unsigned int v79;
  int v80;
  unsigned int v81;
  unint64_t v82;
  uint64_t v83;
  BOOL v84;
  unint64_t v85;
  uint64_t v86;
  uint64_t v87;
  unsigned __int8 v88;
  int v89;
  unsigned int v90;
  NSObject *v91;
  const char *v92;
  uint64_t v93;
  uint64_t v94;
  _BYTE *v95;
  unint64_t v96;
  int v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  unsigned __int8 *v101;
  uint64_t v102;
  unsigned __int8 *v103;
  unsigned __int8 v104;
  unsigned __int8 v105;
  unsigned __int8 v106;
  int v107;
  uint64_t v108;
  unsigned int v109;
  int v110;
  unsigned int *v111;
  unsigned int v112;
  uint64_t v113;
  uint64_t **v114;
  unsigned int v115[2];
  __int16 v116;
  _BYTE __src[18];
  uint64_t (***v118)();
  uint64_t (**v119)();
  void *v120;
  char *v121;
  void *__p;
  void *v123;
  uint64_t v124;
  uint64_t v125;

  v125 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)a3 != 8257536)
    return;
  v4 = *(_QWORD *)(a3 + 8);
  if ((unint64_t)(*(_QWORD *)(a3 + 16) - v4) < 0xC || *(_BYTE *)(v4 + 1) != 13)
    return;
  *(_QWORD *)v115 = *a2;
  v6 = *(uint64_t ***)(a1 + 8);
  midi::universal_sysex::message_view::message_view(&v119, a3);
  if (*(_DWORD *)a3 != 8257536
    || (v8 = *(_BYTE **)(a3 + 8), v9 = *(_QWORD *)(a3 + 16), (unint64_t)(v9 - (_QWORD)v8) < 0xC)
    || v8[1] != 13)
  {
    __assert_rtn("capability_inquiry_view", "capability_inquiry.h", 2486, "validate(sx)");
  }
  v10 = v119[1];
  v11 = (char *)v119[2] - (char *)v10;
  if (v11 <= 7)
    __assert_rtn("make_uint28", "sysex.h", 249, "data_pos + 3 < data.size()");
  if (v11 <= 0xB)
    __assert_rtn("make_uint28", "sysex.h", 249, "data_pos + 3 < data.size()");
  v12 = *((unsigned __int8 *)v10 + 4) | (*((unsigned __int8 *)v10 + 5) << 7) | (*((unsigned __int8 *)v10 + 6) << 14) | (*((unsigned __int8 *)v10 + 7) << 21);
  v13 = *((unsigned __int8 *)v10 + 8) | (*((unsigned __int8 *)v10 + 9) << 7) | (*((unsigned __int8 *)v10 + 10) << 14) | (*((unsigned __int8 *)v10 + 11) << 21);
  if (v12 == v13)
    return;
  if (!*((_BYTE *)v10 + 3) || (*((_BYTE *)v10 + 3) & 0x70) != 0)
  {
    __src[0] = *((_BYTE *)v10 + 2);
    *(_WORD *)&__src[1] = 2;
    __src[7] = MEMORY[4];
    midi::ci::message::make_with_payload_size((midi::ci::message *)&v119, 40, 127, v13, *((unsigned __int8 *)v10 + 4) | (*((unsigned __int8 *)v10 + 5) << 7) | (*((unsigned __int8 *)v10 + 6) << 14) | (*((unsigned __int8 *)v10 + 7) << 21), *(_BYTE *)v10);
    v19 = v121;
    if ((_BYTE *)__p - v121 >= 8)
    {
      memmove(v121, __src, 8uLL);
      v121 = v19 + 8;
      v49 = v19 + 8;
    }
    else
    {
      v20 = (char *)v120;
      v21 = v121 - (_BYTE *)v120;
      v22 = v121 - (_BYTE *)v120 + 8;
      if (v22 < 0)
        std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
      v23 = (_BYTE *)__p - (_BYTE *)v120;
      if (2 * ((_BYTE *)__p - (_BYTE *)v120) > (unint64_t)v22)
        v22 = 2 * v23;
      if (v23 >= 0x3FFFFFFFFFFFFFFFLL)
        v24 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v24 = v22;
      if (v24)
      {
        v25 = (char *)operator new(v24);
        v26 = v6;
      }
      else
      {
        v26 = v6;
        v25 = 0;
      }
      v51 = &v25[v21];
      *(_QWORD *)&v25[v21] = *(_QWORD *)__src;
      v52 = &v25[v21 + 8];
      if (v20 == v19)
      {
        v53 = v19;
      }
      else
      {
        do
        {
          v25[v21 - 1] = v20[v21 - 1];
          --v21;
        }
        while (v21);
        v53 = v121;
        v51 = v25;
      }
      v54 = &v25[v24];
      v55 = v53 - v19;
      if (v53 != v19)
        memmove(v52, v19, v53 - v19);
      v49 = &v52[v55];
      v56 = v120;
      v120 = v51;
      v121 = &v52[v55];
      __p = v54;
      if (v56)
        operator delete(v56);
      v6 = v26;
    }
    v116 = 30;
    std::vector<unsigned char>::__insert_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((uint64_t)&v120, v49, (char *)&v116, __src, 2);
    v57 = (char *)v120;
    v58 = v121;
    if ((_BYTE *)__p - v121 >= 30)
    {
      for (i = 0; i != 30; ++i)
        v58[i] = aMidiCiVersionN[i];
      v121 = v58 + 30;
    }
    else
    {
      v59 = v6;
      v60 = v121 - (_BYTE *)v120;
      v61 = v121 - (_BYTE *)v120 + 30;
      if (v61 < 0)
        std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
      v62 = (_BYTE *)__p - (_BYTE *)v120;
      if (2 * ((_BYTE *)__p - (_BYTE *)v120) > (unint64_t)v61)
        v61 = 2 * v62;
      if (v62 >= 0x3FFFFFFFFFFFFFFFLL)
        v63 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v63 = v61;
      if (v63)
        v64 = (char *)operator new(v63);
      else
        v64 = 0;
      v66 = &v64[v60];
      qmemcpy(&v64[v60], "MIDI-CI version not supported!", 30);
      if (v57 == v58)
      {
        v67 = v58;
        v57 = &v64[v60];
      }
      else
      {
        do
        {
          v64[v60 - 1] = v57[v60 - 1];
          --v60;
        }
        while (v60);
        v67 = v121;
        v57 = v64;
      }
      v68 = v66 + 30;
      v69 = &v64[v63];
      v70 = v67 - v58;
      if (v67 != v58)
        memmove(v66 + 30, v58, v67 - v58);
      v71 = v120;
      v120 = v57;
      v121 = &v68[v70];
      __p = v69;
      if (v71)
        operator delete(v71);
      v6 = v59;
    }
    MIDICI::DeviceManager::sendMessage((uint64_t)v6, *(unsigned int *)(a1 + 20), v115[0], (uint64_t)&v119);
    if (!v57)
      return;
    v121 = v57;
    v72 = v57;
    goto LABEL_91;
  }
  if (v12 != *((_DWORD *)v6 + 24))
  {
    v113 = a1;
    v27 = a1 + 16;
    v28 = *(_DWORD *)(a1 + 16);
    v111 = (unsigned int *)v27;
    v30 = (MIDICI::DeviceManager *)v6[1];
    v29 = (MIDICI::DeviceManager *)v6[2];
    v110 = *(_DWORD *)(v27 + 4);
    DeviceWithMUID = MIDICI::DeviceManager::getDeviceWithMUID(v30, v29, v12, v28, v110);
    v32 = v13;
    v33 = DeviceWithMUID;
    v112 = v32;
    v114 = v6;
    if (v32 == 0xFFFFFFF)
    {
      v119 = (uint64_t (**)())v6;
      LODWORD(v120) = v28;
      LODWORD(v121) = 8257536;
      v123 = 0;
      v124 = 0;
      __p = 0;
      std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&__p, v8, v9, v9 - (_QWORD)v8);
      v34 = v113;
      v35 = v6[1];
      v36 = v6[2];
      if (v35 != v36)
      {
        v37 = (uint64_t)v119;
        v38 = (int)v120;
        do
        {
          v39 = *v35;
          v40 = *(_DWORD *)(*v35 + 72);
          if (v38 != v40)
          {
            v41 = *(unsigned int *)(v39 + 76);
            if (v40)
              v42 = (_DWORD)v41 == 0;
            else
              v42 = 1;
            if (v42)
            {
              v43 = 0;
            }
            else
            {
              v44 = std::function<std::optional<unsigned char> ()(unsigned int,unsigned int,unsigned char)>::operator()(*(_QWORD *)(*(_QWORD *)v37 + 24), v40, *(_DWORD *)(v39 + 76), *(_BYTE *)(v39 + 168));
              if (v44 <= 0x100u)
                v43 = 0;
              else
                v43 = v44;
              v41 = *(unsigned int *)(v39 + 76);
            }
            MIDICI::DeviceManager::sendMessage(v37, v41, v43, (uint64_t)&v121);
          }
          ++v35;
        }
        while (v35 != v36);
      }
      if (__p)
      {
        v123 = __p;
        operator delete(__p);
      }
      v45 = *(_DWORD *)a3;
      v6 = v114;
      if (v33)
        goto LABEL_47;
      v50 = 0xFFFFFFF;
      if (v45 != 8257536)
      {
LABEL_103:
        if (v50 == 0xFFFFFFF || v12 == 0xFFFFFFF)
          return;
        v76 = std::__tree<std::__value_type<unsigned int,MIDICI::SourceState>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,MIDICI::SourceState>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,MIDICI::SourceState>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v114 + 13, *v111, v111);
        v77 = operator new(0x20uLL);
        *v77 = &off_1E98BA4D8;
        v77[1] = v114;
        *((_DWORD *)v77 + 4) = v12;
        *(_QWORD *)((char *)v77 + 20) = *(_QWORD *)v111;
        *((_BYTE *)v77 + 28) = v115[0];
        v118 = (uint64_t (***)())v77;
        MIDICI::SourceState::shouldSendDiscoveryRequest((uint64_t)(v76 + 40), v12, __src);
        v17 = v118;
        if (v118 == (uint64_t (***)())__src)
        {
          v18 = 4;
          v17 = (uint64_t (***)())__src;
          goto LABEL_56;
        }
        goto LABEL_17;
      }
    }
    else
    {
      v50 = v32;
      if (DeviceWithMUID)
      {
        while (1)
        {
          if (v30 == v29)
            goto LABEL_113;
          if (*(_DWORD *)(*(_QWORD *)v30 + 64) == v32)
            break;
          v30 = (MIDICI::DeviceManager *)((char *)v30 + 8);
        }
        if (v30 == v29 || (v78 = *(_QWORD *)v30) == 0)
        {
LABEL_113:
          v45 = 8257536;
          v46 = 1;
          v34 = v113;
          goto LABEL_114;
        }
        LOBYTE(v79) = 0;
        if (v28)
        {
          v80 = v28;
          v34 = v113;
          if (v110)
          {
            v79 = (unsigned __int16)std::function<std::optional<unsigned char> ()(unsigned int,unsigned int,unsigned char)>::operator()((*v6)[3], v80, v110, *(_BYTE *)(v78 + 168));
            if (v79 <= 0x100)
              LOBYTE(v79) = 0;
          }
        }
        else
        {
          v34 = v113;
        }
        MIDICI::DeviceManager::sendMessage((uint64_t)v6, *(unsigned int *)(v78 + 76), v79, a3);
        v45 = *(_DWORD *)a3;
LABEL_47:
        v46 = v45 == 8257536;
        if (v45 == 8257536)
        {
LABEL_114:
          v47 = *(_BYTE **)(a3 + 8);
          v48 = *(_QWORD *)(a3 + 16) - (_QWORD)v47;
          v81 = v47[3];
          v82 = 28;
          if (v81 > 1)
            v82 = 30;
          if (v48 >= v82 && v47[1] == 13 && v47[2] == 113)
          {
            midi::universal_sysex::message_view::message_view(__src, a3);
            if (*(_DWORD *)a3 != 8257536
              || (v83 = *(_QWORD *)(a3 + 8), (unint64_t)(*(_QWORD *)(a3 + 16) - v83) < 0xC)
              || *(_BYTE *)(v83 + 1) != 13)
            {
              __assert_rtn("capability_inquiry_view", "capability_inquiry.h", 2486, "validate(sx)");
            }
            MIDICI::DeviceManager::handleDiscoveryReply((MIDICI::DeviceManager *)v6, v33, *(_DWORD *)(v34 + 16), *(unsigned int *)(v34 + 20), *(uint64_t *)__src);
            return;
          }
          v84 = v81 > 1;
          v85 = 28;
          if (v84)
            v85 = 29;
          if (v48 >= v85 && v47[1] == 13 && v47[2] == 112)
          {
            midi::universal_sysex::message_view::message_view(__src, a3);
            if (*(_DWORD *)a3 != 8257536
              || (v86 = *(_QWORD *)(a3 + 8), (unint64_t)(*(_QWORD *)(a3 + 16) - v86) < 0xC)
              || *(_BYTE *)(v86 + 1) != 13)
            {
              __assert_rtn("capability_inquiry_view", "capability_inquiry.h", 2486, "validate(sx)");
            }
            v87 = *(unsigned int *)(v34 + 20);
            v88 = 0;
            if (v33)
            {
              v89 = *(_DWORD *)(v34 + 16);
              if (v89)
              {
                if ((_DWORD)v87)
                {
                  v90 = (unsigned __int16)std::function<std::optional<unsigned char> ()(unsigned int,unsigned int,unsigned char)>::operator()((*v6)[3], v89, *(_DWORD *)(v34 + 20), *(_BYTE *)(v33 + 168));
                  if (v90 <= 0x100)
                    v88 = 0;
                  else
                    v88 = v90;
                  v87 = *(unsigned int *)(v34 + 20);
                }
              }
            }
            if (!MIDICI::DeviceManager::sendDiscoveryReply((MIDICI::DeviceManager *)v6, v87, v88, v115[0]))return;
            gMIDICIDeviceManagerLog();
            v91 = gMIDICIDeviceManagerLog(void)::logCat;
            if (!os_log_type_enabled((os_log_t)gMIDICIDeviceManagerLog(void)::logCat, OS_LOG_TYPE_INFO))
              return;
            *(_DWORD *)__src = 136315394;
            *(_QWORD *)&__src[4] = "CIDeviceManager.cpp";
            *(_WORD *)&__src[12] = 1024;
            *(_DWORD *)&__src[14] = 709;
            v92 = "%25s:%-5d ERROR: Failed to send discovery reply message..";
LABEL_151:
            _os_log_impl(&dword_1D4E88000, v91, OS_LOG_TYPE_INFO, v92, __src, 0x12u);
            return;
          }
        }
        else
        {
          if (v45 != 8323072)
            goto LABEL_166;
          v47 = *(_BYTE **)(a3 + 8);
          v48 = *(_QWORD *)(a3 + 16) - (_QWORD)v47;
        }
        if (v48 >= 2 && (v47[1] | (v45 >> 8)) == 0x7E06)
        {
          if ((v45 | 0x10000) != 0x7F0000)
            goto LABEL_166;
          if (v48 < 3)
          {
            if ((v45 | 0x10000) != 0x7F0000)
              goto LABEL_166;
LABEL_163:
            if ((v47[1] | (v45 >> 8)) == 0x7E0D
              && (v45 | 0x10000) == 0x7F0000
              && v48 >= 0x10
              && v47[2] == 126)
            {
              midi::universal_sysex::message_view::message_view(__src, a3);
              if (*(_DWORD *)a3 != 8257536
                || (v100 = *(_QWORD *)(a3 + 8), (unint64_t)(*(_QWORD *)(a3 + 16) - v100) < 0xC)
                || *(_BYTE *)(v100 + 1) != 13)
              {
                __assert_rtn("capability_inquiry_view", "capability_inquiry.h", 2486, "validate(sx)");
              }
              v101 = *(unsigned __int8 **)(*(_QWORD *)__src + 8);
              if (*(_QWORD *)(*(_QWORD *)__src + 16) - (_QWORD)v101 <= 0xBuLL)
                __assert_rtn("make_uint28", "sysex.h", 249, "data_pos + 3 < data.size()");
              MIDICI::DeviceManager::handleInvalidateMUID((MIDICI::DeviceManager *)v6, (MIDICI::Device *)v33, v101[8] | (v101[9] << 7) | (v101[10] << 14) | (v101[11] << 21));
              return;
            }
            goto LABEL_166;
          }
          if (v47[2] == 1)
          {
            if (!MIDICI::DeviceManager::sendIdentityReplyMessage((MIDICI::DeviceManager *)v6, *(unsigned int *)(v34 + 20), v115[0]))return;
            gMIDICIDeviceManagerLog();
            v91 = gMIDICIDeviceManagerLog(void)::logCat;
            if (!os_log_type_enabled((os_log_t)gMIDICIDeviceManagerLog(void)::logCat, OS_LOG_TYPE_INFO))
              return;
            *(_DWORD *)__src = 136315394;
            *(_QWORD *)&__src[4] = "CIDeviceManager.cpp";
            *(_WORD *)&__src[12] = 1024;
            *(_DWORD *)&__src[14] = 715;
            v92 = "%25s:%-5d ERROR: Failed to send identity reply message..";
            goto LABEL_151;
          }
        }
        if (v46)
        {
          if (v48 >= 0xF)
          {
            if (v48 >= (v47[13] | ((unint64_t)v47[14] << 7)) + 15
              && v47[1] == 13
              && v47[2] == 115)
            {
              midi::universal_sysex::message_view::message_view(__src, a3);
              if (*(_DWORD *)a3 != 8257536
                || (v93 = *(_QWORD *)(a3 + 8), (unint64_t)(*(_QWORD *)(a3 + 16) - v93) < 0xC)
                || *(_BYTE *)(v93 + 1) != 13)
              {
                __assert_rtn("capability_inquiry_view", "capability_inquiry.h", 2486, "validate(sx)");
              }
              MIDICI::DeviceManager::handleEndpointInformationReply((std::string *)v33, *(uint64_t *)__src);
              return;
            }
            goto LABEL_163;
          }
        }
        else if (v45 != 8323072)
        {
          goto LABEL_166;
        }
        if (v48 >= 2)
          goto LABEL_163;
LABEL_166:
        if (midi::ci::profile_inquiry_reply_view::validate(a3))
        {
          midi::universal_sysex::message_view::message_view(__src, a3);
          if (*(_DWORD *)a3 != 8257536
            || (v94 = *(_QWORD *)(a3 + 8), (unint64_t)(*(_QWORD *)(a3 + 16) - v94) < 0xC)
            || *(_BYTE *)(v94 + 1) != 13)
          {
            __assert_rtn("capability_inquiry_view", "capability_inquiry.h", 2486, "validate(sx)");
          }
          MIDICI::DeviceManager::handleProfileInquiryReply((_QWORD *)v33, *(uint64_t *)__src);
          return;
        }
        if (!v46)
          goto LABEL_185;
        v95 = *(_BYTE **)(a3 + 8);
        v96 = *(_QWORD *)(a3 + 16) - (_QWORD)v95;
        if (v96 < 0x11)
        {
          if (v96 < 0xD || v95[1] != 13)
          {
LABEL_185:
            if (midi::ci::property_exchange::property_data_message_view::validate(a3)
              && (*(_BYTE *)(*(_QWORD *)(a3 + 8) + 2) & 0xFE) == 0x34)
            {
              midi::universal_sysex::message_view::message_view(__src, a3);
              if (*(_DWORD *)a3 != 8257536
                || (v99 = *(_QWORD *)(a3 + 8), (unint64_t)(*(_QWORD *)(a3 + 16) - v99) < 0xC)
                || *(_BYTE *)(v99 + 1) != 13)
              {
                __assert_rtn("capability_inquiry_view", "capability_inquiry.h", 2486, "validate(sx)");
              }
              *(_QWORD *)&__src[8] = 1;
              if (*((_DWORD *)v6 + 24) == v112)
                MIDICI::Device::handleGetProperty(*(_QWORD **)(v33 + 176), (uint64_t *)__src);
            }
            return;
          }
          LOBYTE(v97) = v95[2];
        }
        else
        {
          if (v95[1] != 13)
            goto LABEL_185;
          v97 = v95[2];
          if ((v97 - 34) <= 5)
          {
            midi::universal_sysex::message_view::message_view(__src, a3);
            if (*(_DWORD *)a3 != 8257536
              || (v98 = *(_QWORD *)(a3 + 8), (unint64_t)(*(_QWORD *)(a3 + 16) - v98) < 0xC)
              || *(_BYTE *)(v98 + 1) != 13)
            {
              __assert_rtn("capability_inquiry_view", "capability_inquiry.h", 2486, "validate(sx)");
            }
            MIDICI::DeviceManager::handleProfileIDViewChange((uint64_t *)v6, v33, *(uint64_t *)__src, *(_QWORD *)(v34 + 32));
            return;
          }
        }
        if ((v97 & 0xFE) != 0x30 || v96 <= 0xE && v95[3] > 1u)
          goto LABEL_185;
        midi::universal_sysex::message_view::message_view(__src, a3);
        if (*(_DWORD *)a3 != 8257536
          || (v102 = *(_QWORD *)(a3 + 8), (unint64_t)(*(_QWORD *)(a3 + 16) - v102) < 0xC)
          || *(_BYTE *)(v102 + 1) != 13)
        {
          __assert_rtn("capability_inquiry_view", "capability_inquiry.h", 2486, "validate(sx)");
        }
        v103 = *(unsigned __int8 **)(*(_QWORD *)__src + 8);
        *(_BYTE *)(v33 + 169) = v103[12];
        if (v103[3] < 2u)
          v104 = 0;
        else
          v104 = v103[13];
        *(_BYTE *)(v33 + 170) = v104;
        if (v103[3] < 2u)
          v105 = 0;
        else
          v105 = v103[14];
        *(_BYTE *)(v33 + 171) = v105;
        MIDICI::Device::makeGetResourceListInquiryMessage((MIDICI::Device *)__src, v33, *((_DWORD *)v6 + 24));
        v106 = 0;
        v107 = *(_DWORD *)(v33 + 72);
        v108 = *(unsigned int *)(v33 + 76);
        if (v107 && (_DWORD)v108)
        {
          v109 = (unsigned __int16)std::function<std::optional<unsigned char> ()(unsigned int,unsigned int,unsigned char)>::operator()((*v6)[3], v107, *(_DWORD *)(v33 + 76), *(_BYTE *)(v33 + 168));
          if (v109 <= 0x100)
            v106 = 0;
          else
            v106 = v109;
          v108 = *(unsigned int *)(v33 + 76);
        }
        MIDICI::DeviceManager::sendMessage((uint64_t)v6, v108, v106, (uint64_t)__src);
        v72 = *(char **)&__src[8];
        if (!*(_QWORD *)&__src[8])
          return;
LABEL_91:
        operator delete(v72);
        return;
      }
    }
    v73 = *(_BYTE **)(a3 + 8);
    v74 = 28;
    if (v73[3] > 1u)
      v74 = 30;
    if (*(_QWORD *)(a3 + 16) - (_QWORD)v73 >= v74 && v73[1] == 13 && v73[2] == 113)
    {
      midi::universal_sysex::message_view::message_view(__src, a3);
      if (*(_DWORD *)a3 != 8257536
        || (v75 = *(_QWORD *)(a3 + 8), (unint64_t)(*(_QWORD *)(a3 + 16) - v75) < 0xC)
        || *(_BYTE *)(v75 + 1) != 13)
      {
        __assert_rtn("capability_inquiry_view", "capability_inquiry.h", 2486, "validate(sx)");
      }
      MIDICI::DeviceManager::handleDiscoveryReply((MIDICI::DeviceManager *)v114, 0, *(_DWORD *)(v113 + 16), *(unsigned int *)(v113 + 20), *(uint64_t *)__src);
      return;
    }
    goto LABEL_103;
  }
  v14 = (unint64_t *)v6[20];
  if (!v14)
  {
    v14 = (unint64_t *)operator new();
    *v14 = 0x4008000000000000;
    v14[1] = 0;
    v7.n128_u64[0] = 10;
    v14[2] = 10;
    v15 = v6[20];
    v6[20] = (uint64_t *)v14;
    if (v15)
    {
      MEMORY[0x1D826BA98](v15, 0x1000C40504FFAC1);
      v14 = (unint64_t *)v6[20];
    }
  }
  v16 = (char *)(*(unsigned int *)(a1 + 20) | (*(_QWORD *)v115 << 32));
  v119 = &off_1E98BA490;
  v120 = v6;
  v121 = v16;
  __p = &v119;
  MIDICI::CIRetrier::attempt(v14, (uint64_t)&v119, v7);
  v17 = (uint64_t (***)())__p;
  if (__p == &v119)
  {
    v18 = 4;
    v17 = &v119;
    goto LABEL_56;
  }
LABEL_17:
  if (v17)
  {
    v18 = 5;
LABEL_56:
    (*v17)[v18]();
  }
}

void sub_1D4ED4A10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, void *__p, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *midi::universal_sysex::message_view::message_view(_QWORD *result, uint64_t a2)
{
  *result = a2;
  if ((*(_DWORD *)a2 & 0xFFFEFFFF) != 0x7E0000)
    __assert_rtn("message_view", "universal_sysex.h", 103, "(sx.manufacturerID == manufacturer::universal_realtime) || (sx.manufacturerID == manufacturer::universal_non_realtime)");
  if (*(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8) <= 1uLL)
    __assert_rtn("message_view", "universal_sysex.h", 104, "sx.data.size() >= 2");
  return result;
}

unint64_t *MIDICI::CIRetrier::attempt(unint64_t *result, uint64_t a2, __n128 a3)
{
  unint64_t *v4;
  uint64_t v5;
  int v6;

  v4 = result;
  a3.n128_u64[0] = *result;
  if (*(double *)result <= 0.0
    || (result = (unint64_t *)std::chrono::steady_clock::now().__d_.__rep_,
        a3.n128_f64[0] = (double)((uint64_t)((uint64_t)result - v4[1]) / 1000000) * 0.001,
        a3.n128_f64[0] >= *(double *)v4))
  {
    if (*((_DWORD *)v4 + 5) < *((_DWORD *)v4 + 4))
    {
      v6 = *((_DWORD *)v4 + 5);
      v5 = *(_QWORD *)(a2 + 24);
      if (!v5)
        std::__throw_bad_function_call[abi:ne180100]();
      (*(void (**)(uint64_t, int *, __n128))(*(_QWORD *)v5 + 48))(v5, &v6, a3);
      ++*((_DWORD *)v4 + 5);
      result = (unint64_t *)std::chrono::steady_clock::now().__d_.__rep_;
      v4[1] = (unint64_t)result;
    }
  }
  return result;
}

uint64_t MIDICI::DeviceManager::getDeviceWithMUID(MIDICI::DeviceManager *this, MIDICI::DeviceManager *a2, int a3, int a4, int a5)
{
  uint64_t v5;

  while (1)
  {
    if (this == a2)
      return 0;
    v5 = *(_QWORD *)this;
    if (*(_DWORD *)(*(_QWORD *)this + 64) == a3 && *(_DWORD *)(v5 + 72) == a4 && *(_DWORD *)(v5 + 76) == a5)
      break;
    this = (MIDICI::DeviceManager *)((char *)this + 8);
  }
  if (this == a2)
    return 0;
  else
    return *(_QWORD *)this;
}

void MIDICI::DeviceManager::handleDiscoveryReply(MIDICI::DeviceManager *this, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  unsigned __int8 *v10;
  unsigned int v11;
  NSObject *v12;
  const char *v13;
  uint64_t v14;
  char v15;
  unsigned __int8 v16;
  unsigned int v17;
  uint64_t v18;
  unsigned __int8 *v19;
  unint64_t v20;
  unsigned __int8 v21;
  unsigned __int8 v22;
  __int16 v23;
  __int16 v24;
  int v25;
  int v26;
  int v27;
  unsigned int v28;
  __int16 v29;
  int v30;
  unint64_t v31;
  char v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char v37;
  uint64_t v38;
  int v39;
  unsigned int v40;
  char *v41;
  char *v42;
  unsigned int v43;
  BOOL v44;
  char **v45;
  uint64_t *v46;
  char *v47;
  uint64_t v48;
  unsigned int v49;
  BOOL v50;
  uint64_t *v51;
  char *v52;
  char *v53;
  char *v54;
  BOOL v55;
  uint64_t v56;
  unsigned int v57;
  char *v58;
  int v59;
  NSObject *v60;
  int v61;
  const char *v62;
  int v63;
  const char *v64;
  const char *v65;
  const char *v66;
  int v67;
  CFTypeRef cf;
  uint64_t v69;
  __int16 __src;
  char v71;
  _BYTE buf[24];
  char *v73;
  uint64_t v74;

  v6 = a4;
  v74 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (*(_DWORD *)(a2 + 72) != a3 || *(_DWORD *)(a2 + 76) != (_DWORD)a4)
      goto LABEL_99;
    v10 = *(unsigned __int8 **)(a5 + 8);
    if (*(_QWORD *)(a5 + 16) - (_QWORD)v10 <= 7uLL)
      __assert_rtn("make_uint28", "sysex.h", 249, "data_pos + 3 < data.size()");
    if (*(_DWORD *)(a2 + 64) != (v10[4] | (v10[5] << 7) | (v10[6] << 14) | (v10[7] << 21)))
    {
LABEL_99:
      LOBYTE(v11) = 0;
      if (a3)
      {
        if ((_DWORD)a4)
        {
          v11 = (unsigned __int16)std::function<std::optional<unsigned char> ()(unsigned int,unsigned int,unsigned char)>::operator()(*(_QWORD *)(*(_QWORD *)this + 24), a3, a4, *(_BYTE *)(a2 + 168));
          if (v11 <= 0x100)
            LOBYTE(v11) = 0;
        }
      }
      if (MIDICI::DeviceManager::sendInvalidateMUIDMessage(this, v6, v11, *(_DWORD *)(a2 + 64)))
      {
        gMIDICIDeviceManagerLog();
        v12 = gMIDICIDeviceManagerLog(void)::logCat;
        if (os_log_type_enabled((os_log_t)gMIDICIDeviceManagerLog(void)::logCat, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = "CIDeviceManager.cpp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 449;
          v13 = "%25s:%-5d ERROR: Failed to send invalidate MUID message..";
LABEL_88:
          _os_log_impl(&dword_1D4E88000, v12, OS_LOG_TYPE_INFO, v13, buf, 0x12u);
          return;
        }
      }
    }
    return;
  }
  v14 = *(_QWORD *)(a5 + 8);
  if (*(unsigned __int8 *)(v14 + 3) < 2u)
    v15 = 127;
  else
    v15 = *(_BYTE *)(v14 + 29);
  v16 = 0;
  if (a3 && (_DWORD)v6)
  {
    v17 = (unsigned __int16)std::function<std::optional<unsigned char> ()(unsigned int,unsigned int,unsigned char)>::operator()(*(_QWORD *)(*(_QWORD *)this + 24), a3, v6, v15);
    if (v17 <= 0x100)
      v16 = 0;
    else
      v16 = v17;
  }
  v18 = operator new();
  MIDIObject::MIDIObject((MIDIObject *)v18);
  *(_BYTE *)(v18 + 44) = 0;
  *(_BYTE *)(v18 + 48) = 0;
  *(_QWORD *)(v18 + 56) = 0;
  *(_QWORD *)v18 = off_1E98B6E28;
  v19 = *(unsigned __int8 **)(a5 + 8);
  v20 = *(_QWORD *)(a5 + 16) - (_QWORD)v19;
  if (v20 < 8)
    goto LABEL_90;
  *(_DWORD *)(v18 + 64) = v19[4] | (v19[5] << 7) | (v19[6] << 14) | (v19[7] << 21);
  *(_BYTE *)(v18 + 68) = 0;
  *(_DWORD *)(v18 + 72) = a3;
  *(_DWORD *)(v18 + 76) = v6;
  if (v20 < 0x17)
  {
    v62 = "data_pos + 10 < data.size()";
    v63 = 103;
    v64 = "sysex.cpp";
    v65 = "make_device_identity";
LABEL_92:
    __assert_rtn(v65, v64, v63, v62);
  }
  v21 = v19[13];
  v22 = v19[14];
  v23 = v19[18];
  v24 = v19[17];
  v25 = v19[19];
  v26 = v19[20];
  v27 = v19[21] << 14;
  v28 = v27 | (v19[22] << 21);
  v29 = v19[15] | (v19[16] << 7);
  *(_BYTE *)(v18 + 80) = v19[12] & 0x7F;
  *(_BYTE *)(v18 + 81) = v21 & 0x7F;
  *(_BYTE *)(v18 + 82) = v22 & 0x7F;
  *(_WORD *)(v18 + 84) = v29;
  *(_WORD *)(v18 + 86) = v24 | (v23 << 7);
  *(_BYTE *)(v18 + 88) = v25 & 0x7F;
  *(_BYTE *)(v18 + 89) = ((v25 | (v26 << 7)) >> 7) & 0x7F;
  *(_BYTE *)(v18 + 90) = ((v27 | (v26 << 7)) >> 14) & 0x7F;
  *(_BYTE *)(v18 + 91) = (v28 >> 21) & 0x7F;
  *(_BYTE *)(v18 + 92) = (v19[23] & 2) != 0;
  *(_BYTE *)(v18 + 93) = (v19[23] & 4) != 0;
  v30 = (v19[23] >> 3) & 1;
  *(_BYTE *)(v18 + 94) = (v19[23] & 8) != 0;
  *(_BYTE *)(v18 + 95) = (v19[23] & 0x10) != 0;
  if (v20 <= 0x1B)
  {
LABEL_90:
    v62 = "data_pos + 3 < data.size()";
    v63 = 249;
    v64 = "sysex.h";
    v65 = "make_uint28";
    goto LABEL_92;
  }
  v31 = v19[24] | ((unint64_t)v19[25] << 7) | ((unint64_t)v19[26] << 14) | ((unint64_t)v19[27] << 21);
  *(_OWORD *)(v18 + 120) = 0u;
  *(_QWORD *)(v18 + 96) = v31;
  *(_QWORD *)(v18 + 104) = 0;
  *(_WORD *)(v18 + 112) = 0;
  *(_OWORD *)(v18 + 136) = 0u;
  *(_OWORD *)(v18 + 152) = 0u;
  if (v19[3] < 2u)
    v32 = 127;
  else
    v32 = v19[29];
  *(_QWORD *)(v18 + 176) = 0;
  *(_BYTE *)(v18 + 168) = v32;
  *(_WORD *)(v18 + 169) = 0;
  *(_BYTE *)(v18 + 171) = 0;
  *(_BYTE *)(v18 + 184) = 0;
  *(_QWORD *)(v18 + 192) = 0;
  if (v30)
  {
    v33 = (_QWORD *)operator new();
    v33[2] = 0;
    v33[1] = 0;
    *v33 = v33 + 1;
    *(_QWORD *)buf = 0;
    std::unique_ptr<PropertyExchange::RequestManager>::reset[abi:ne180100]((uint64_t *)(v18 + 176), (uint64_t)v33);
    std::unique_ptr<PropertyExchange::RequestManager>::reset[abi:ne180100]((uint64_t *)buf, 0);
  }
  v69 = v18;
  v34 = UMPCIManager<MIDICI::Device>::addPairWithoutCheck(this, &v69);
  v35 = v69;
  v69 = 0;
  if (v35)
    std::default_delete<MIDICI::Device>::operator()[abi:ne180100](v35);
  v36 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIEndpoint>::sRTTI, a3);
  if (v36)
  {
    if (*(_BYTE *)(v36 + 88))
    {
      v37 = 2;
    }
    else if (*(_BYTE *)(v36 + 90))
    {
      v37 = 3;
    }
    else
    {
      v37 = *(_QWORD *)(v36 + 56) && MIDIEndpoint::IsPartOfLegacyDevice((MIDIEndpoint *)v36);
    }
    *(_BYTE *)(v34 + 68) = v37;
  }
  *(_BYTE *)(v34 + 112) = 1;
  v38 = *(_QWORD *)this;
  v39 = *(_DWORD *)(v34 + 8);
  cf = 0;
  UMPCIServerContext::sendNotificationForObject(v38, 0, v39, &cf);
  if (cf)
    CFRelease(cf);
  v40 = *(_DWORD *)(v34 + 64);
  v41 = (char *)*((_QWORD *)this + 14);
  if (v41)
  {
    v42 = (char *)this + 112;
    do
    {
      v43 = *((_DWORD *)v41 + 8);
      v44 = v43 >= a3;
      if (v43 >= a3)
        v45 = (char **)v41;
      else
        v45 = (char **)(v41 + 8);
      if (v44)
        v42 = v41;
      v41 = *v45;
    }
    while (*v45);
    if (v42 != (char *)this + 112 && *((_DWORD *)v42 + 8) <= a3)
    {
      v46 = (uint64_t *)*((_QWORD *)v42 + 7);
      if (v46)
      {
        v47 = v42 + 56;
        v48 = *((_QWORD *)v42 + 7);
        do
        {
          v49 = *(_DWORD *)(v48 + 32);
          v50 = v49 >= v40;
          if (v49 >= v40)
            v51 = (uint64_t *)v48;
          else
            v51 = (uint64_t *)(v48 + 8);
          if (v50)
            v47 = (char *)v48;
          v48 = *v51;
        }
        while (*v51);
        if (v47 != v42 + 56 && v40 >= *((_DWORD *)v47 + 8))
        {
          v52 = (char *)*((_QWORD *)v47 + 1);
          if (v52)
          {
            do
            {
              v53 = v52;
              v52 = *(char **)v52;
            }
            while (v52);
          }
          else
          {
            v54 = v47;
            do
            {
              v53 = (char *)*((_QWORD *)v54 + 2);
              v55 = *(_QWORD *)v53 == (_QWORD)v54;
              v54 = v53;
            }
            while (!v55);
          }
          if (*((char **)v42 + 6) == v47)
            *((_QWORD *)v42 + 6) = v53;
          --*((_QWORD *)v42 + 8);
          std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v46, (uint64_t *)v47);
          v56 = *((_QWORD *)v47 + 5);
          *((_QWORD *)v47 + 5) = 0;
          if (v56)
            MEMORY[0x1D826BA98](v56, 0x1000C40504FFAC1);
          operator delete(v47);
        }
      }
    }
  }
  if ((*(_BYTE *)(*(_QWORD *)(a5 + 8) + 23) & 4) != 0)
  {
    v57 = *((_DWORD *)this + 24);
    v58 = (char *)operator new(0xCuLL);
    *(_DWORD *)v58 = 35655039;
    v58[4] = v57 & 0x7F;
    v58[5] = (v57 >> 7) & 0x7F;
    v58[6] = (v57 >> 14) & 0x7F;
    v58[7] = (v57 >> 21) & 0x7F;
    v58[8] = v40 & 0x7F;
    v58[9] = (v40 >> 7) & 0x7F;
    v58[10] = (v40 >> 14) & 0x7F;
    v58[11] = (v40 >> 21) & 0x7F;
    *(_DWORD *)buf = 8257536;
    *(_QWORD *)&buf[8] = v58;
    *(_QWORD *)&buf[16] = v58 + 12;
    v73 = v58 + 12;
    if (v57 >> 28)
    {
      v66 = "source_muid <= uint28_max";
      v67 = 50;
    }
    else
    {
      v6 = v6;
      if (!(v40 >> 28))
      {
        v59 = MIDICI::DeviceManager::sendMessage((uint64_t)this, v6, v16, (uint64_t)buf);
        operator delete(v58);
        if (v59)
        {
          gMIDICIDeviceManagerLog();
          v60 = gMIDICIDeviceManagerLog(void)::logCat;
          if (os_log_type_enabled((os_log_t)gMIDICIDeviceManagerLog(void)::logCat, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)&buf[4] = "CIDeviceManager.cpp";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 434;
            _os_log_impl(&dword_1D4E88000, v60, OS_LOG_TYPE_INFO, "%25s:%-5d ERROR: Failed to send profile inquiry message..", buf, 0x12u);
          }
        }
        goto LABEL_82;
      }
      v66 = "destination_muid <= uint28_max";
      v67 = 51;
    }
    __assert_rtn("message", "capability_inquiry.cpp", v67, v66);
  }
LABEL_82:
  if ((*(_BYTE *)(*(_QWORD *)(a5 + 8) + 23) & 8) != 0)
  {
    midi::ci::message::make_with_payload_size((midi::ci::message *)buf, 3, 48, *((_DWORD *)this + 24), v40, 127);
    __src = 1;
    v71 = 0;
    std::vector<unsigned char>::__insert_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((uint64_t)&buf[8], *(char **)&buf[16], (char *)&__src, buf, 3);
    v61 = MIDICI::DeviceManager::sendMessage((uint64_t)this, v6, v16, (uint64_t)buf);
    if (*(_QWORD *)&buf[8])
      operator delete(*(void **)&buf[8]);
    if (v61)
    {
      gMIDICIDeviceManagerLog();
      v12 = gMIDICIDeviceManagerLog(void)::logCat;
      if (os_log_type_enabled((os_log_t)gMIDICIDeviceManagerLog(void)::logCat, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = "CIDeviceManager.cpp";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 438;
        v13 = "%25s:%-5d ERROR: Failed to send property exchange capabilities inquiry message..";
        goto LABEL_88;
      }
    }
  }
}

void sub_1D4ED543C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  void *v18;

  operator delete(v18);
  _Unwind_Resume(a1);
}

_QWORD *MIDICI::SourceState::shouldSendDiscoveryRequest(uint64_t a1, unsigned int a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t **v8;
  uint64_t v9;
  unsigned int v10;
  BOOL v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t **v14;
  uint64_t *v15;
  unint64_t *v16;
  __n128 v17;
  _QWORD *v18;
  _QWORD *result;
  uint64_t v20;
  unsigned int v21;
  _BYTE v22[24];
  _BYTE *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v21 = a2;
  v7 = *(_QWORD *)(a1 + 16);
  v5 = a1 + 16;
  v6 = v7;
  v8 = (uint64_t **)(v5 - 8);
  if (!v7)
    goto LABEL_12;
  v9 = v5;
  do
  {
    v10 = *(_DWORD *)(v6 + 32);
    v11 = v10 >= a2;
    if (v10 >= a2)
      v12 = (uint64_t *)v6;
    else
      v12 = (uint64_t *)(v6 + 8);
    if (v11)
      v9 = v6;
    v6 = *v12;
  }
  while (*v12);
  if (v9 == v5 || *(_DWORD *)(v9 + 32) > a2)
  {
LABEL_12:
    v13 = (uint64_t *)operator new();
    *v13 = 0;
    v13[1] = 0;
    v13[2] = 3;
    v14 = std::__tree<std::__value_type<unsigned int,std::unique_ptr<MIDICI::CIRetrier>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::unique_ptr<MIDICI::CIRetrier>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::unique_ptr<MIDICI::CIRetrier>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v8, a2, &v21);
    v15 = v14[5];
    v14[5] = v13;
    if (v15)
      MEMORY[0x1D826BA98](v15, 0x1000C40504FFAC1);
  }
  v16 = (unint64_t *)std::__tree<std::__value_type<unsigned int,std::unique_ptr<MIDICI::CIRetrier>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::unique_ptr<MIDICI::CIRetrier>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::unique_ptr<MIDICI::CIRetrier>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v8, a2, &v21)[5];
  v18 = (_QWORD *)a3[3];
  if (v18)
  {
    if (v18 == a3)
    {
      v23 = v22;
      v17.n128_f64[0] = (*(double (**)(_QWORD *, _BYTE *))(*a3 + 24))(a3, v22);
    }
    else
    {
      v23 = (_BYTE *)(*(uint64_t (**)(_QWORD *))(*v18 + 16))(v18);
    }
  }
  else
  {
    v23 = 0;
  }
  MIDICI::CIRetrier::attempt(v16, (uint64_t)v22, v17);
  result = v23;
  if (v23 == v22)
  {
    v20 = 4;
    result = v22;
  }
  else
  {
    if (!v23)
      return result;
    v20 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v20))();
}

void sub_1D4ED56C0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D826BA98](v1, 0x1000C40504FFAC1);
  _Unwind_Resume(a1);
}

uint64_t MIDICI::DeviceManager::sendDiscoveryReply(MIDICI::DeviceManager *this, uint64_t a2, unsigned int a3, unsigned int a4)
{
  uint64_t v7;
  _BYTE v9[8];
  void *__p;
  void *__dst;
  int __src;
  uint64_t v13;

  midi::ci::message::make_with_payload_size((midi::ci::message *)v9, 18, 113, *((_DWORD *)this + 24), a4, 127);
  midi::sysex7::add_device_identity((uint64_t)v9);
  LOBYTE(__src) = 0;
  std::vector<unsigned char>::__insert_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((uint64_t)&__p, (char *)__dst, (char *)&__src, (char *)&__src + 1, 1);
  __src = 0x10000;
  std::vector<unsigned char>::__insert_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((uint64_t)&__p, (char *)__dst, (char *)&__src, (char *)&v13, 4);
  LOBYTE(__src) = 0;
  std::vector<unsigned char>::__insert_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((uint64_t)&__p, (char *)__dst, (char *)&__src, (char *)&__src + 1, 1);
  LOBYTE(__src) = 127;
  std::vector<unsigned char>::__insert_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((uint64_t)&__p, (char *)__dst, (char *)&__src, (char *)&__src + 1, 1);
  v7 = MIDICI::DeviceManager::sendMessage((uint64_t)this, a2, a3, (uint64_t)v9);
  if (__p)
    operator delete(__p);
  return v7;
}

void sub_1D4ED5834(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t MIDICI::DeviceManager::sendIdentityReplyMessage(MIDICI::DeviceManager *this, uint64_t a2, unsigned int a3)
{
  char *v6;
  char *v7;
  char *v8;
  unint64_t v9;
  int64_t v10;
  int64_t v11;
  size_t v12;
  void *v13;
  char *v14;
  _BYTE *v15;
  char *v16;
  char v17;
  char *v18;
  unint64_t v19;
  uint64_t v20;
  int64_t v21;
  size_t v22;
  void *v23;
  char *v24;
  char v25;
  char *v26;
  char *v27;
  unint64_t v28;
  uint64_t v29;
  int64_t v30;
  size_t v31;
  void *v32;
  char *v33;
  _BYTE *v34;
  char *v35;
  char v36;
  char *v37;
  unint64_t v38;
  int64_t v39;
  int64_t v40;
  size_t v41;
  void *v42;
  char *v43;
  char *v44;
  char v45;
  void *v46;
  uint64_t v47;
  int v49;
  __int128 v50;
  char *v51;
  int v52;
  void *__p[2];
  char *v54;
  int __src;
  uint64_t v56;

  v52 = 8257536;
  __p[1] = 0;
  v54 = 0;
  __p[0] = 0;
  std::vector<unsigned char>::reserve((unint64_t *)__p, 0xCuLL);
  v6 = (char *)__p[1];
  v7 = v54;
  if (__p[1] >= v54)
  {
    v9 = (unint64_t)__p[0];
    v10 = (char *)__p[1] - (char *)__p[0];
    v11 = (char *)__p[1] - (char *)__p[0] + 1;
    if (v11 < 0)
      goto LABEL_76;
    if (2 * (v54 - (char *)__p[0]) > (unint64_t)v11)
      v11 = 2 * (v54 - (char *)__p[0]);
    if ((unint64_t)(v54 - (char *)__p[0]) >= 0x3FFFFFFFFFFFFFFFLL)
      v12 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
      v13 = operator new(v12);
    else
      v13 = 0;
    v14 = (char *)v13 + v10;
    v7 = (char *)v13 + v12;
    v15 = (char *)v13 + v10;
    *v15 = 127;
    v8 = v15 + 1;
    if (v6 == (char *)v9)
    {
      v13 = v14;
    }
    else
    {
      v16 = &v6[~v9];
      do
      {
        v17 = *--v6;
        (v16--)[(_QWORD)v13] = v17;
      }
      while (v6 != (char *)v9);
      v6 = (char *)__p[0];
    }
    __p[0] = v13;
    v54 = v7;
    if (v6)
      operator delete(v6);
  }
  else
  {
    *(_BYTE *)__p[1] = 127;
    v8 = v6 + 1;
  }
  __p[1] = v8;
  if (v8 < v7)
  {
    *v8 = 6;
    v18 = v8 + 1;
    goto LABEL_37;
  }
  v19 = (unint64_t)__p[0];
  v20 = v8 - (char *)__p[0];
  v21 = v8 - (char *)__p[0] + 1;
  if (v21 < 0)
    std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
  if (2 * (v7 - (char *)__p[0]) > (unint64_t)v21)
    v21 = 2 * (v7 - (char *)__p[0]);
  if ((unint64_t)(v7 - (char *)__p[0]) >= 0x3FFFFFFFFFFFFFFFLL)
    v22 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v22 = v21;
  if (v22)
    v23 = operator new(v22);
  else
    v23 = 0;
  v7 = (char *)v23 + v22;
  *((_BYTE *)v23 + v20) = 6;
  v18 = (char *)v23 + v20 + 1;
  if (v8 == (char *)v19)
  {
    __p[0] = (char *)v23 + v20;
    v54 = v7;
LABEL_36:
    operator delete(v8);
    goto LABEL_37;
  }
  v24 = &v8[~v19];
  do
  {
    v25 = *--v8;
    (v24--)[(_QWORD)v23] = v25;
  }
  while (v8 != (char *)v19);
  v8 = (char *)__p[0];
  __p[0] = v23;
  v54 = v7;
  if (v8)
    goto LABEL_36;
LABEL_37:
  __p[1] = v18;
  if (v18 < v7)
  {
    *v18 = 2;
    v26 = v54;
    v27 = v18 + 1;
    goto LABEL_55;
  }
  v28 = (unint64_t)__p[0];
  v29 = v18 - (char *)__p[0];
  v30 = v18 - (char *)__p[0] + 1;
  if (v30 < 0)
LABEL_76:
    std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
  if (2 * (v7 - (char *)__p[0]) > (unint64_t)v30)
    v30 = 2 * (v7 - (char *)__p[0]);
  if ((unint64_t)(v7 - (char *)__p[0]) >= 0x3FFFFFFFFFFFFFFFLL)
    v31 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v31 = v30;
  if (v31)
    v32 = operator new(v31);
  else
    v32 = 0;
  v33 = (char *)v32 + v29;
  v26 = (char *)v32 + v31;
  v34 = (char *)v32 + v29;
  *v34 = 2;
  v27 = v34 + 1;
  if (v18 == (char *)v28)
  {
    __p[0] = v33;
    v54 = (char *)v32 + v31;
LABEL_54:
    operator delete(v18);
    goto LABEL_55;
  }
  v35 = &v18[~v28];
  do
  {
    v36 = *--v18;
    (v35--)[(_QWORD)v32] = v36;
  }
  while (v18 != (char *)v28);
  v18 = (char *)__p[0];
  __p[0] = v32;
  v54 = (char *)v32 + v31;
  if (v18)
    goto LABEL_54;
LABEL_55:
  __p[1] = v27;
  if (v27 < v26)
  {
    *v27 = 17;
    v37 = v27 + 1;
    goto LABEL_73;
  }
  v38 = (unint64_t)__p[0];
  v39 = v27 - (char *)__p[0];
  v40 = v27 - (char *)__p[0] + 1;
  if (v40 < 0)
    std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
  if (2 * (v26 - (char *)__p[0]) > (unint64_t)v40)
    v40 = 2 * (v26 - (char *)__p[0]);
  if ((unint64_t)(v26 - (char *)__p[0]) >= 0x3FFFFFFFFFFFFFFFLL)
    v41 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v41 = v40;
  if (v41)
    v42 = operator new(v41);
  else
    v42 = 0;
  v43 = (char *)v42 + v41;
  *((_BYTE *)v42 + v39) = 17;
  v37 = (char *)v42 + v39 + 1;
  if (v27 == (char *)v38)
  {
    __p[0] = (char *)v42 + v39;
    v54 = v43;
LABEL_72:
    operator delete(v27);
    goto LABEL_73;
  }
  v44 = &v27[~v38];
  do
  {
    v45 = *--v27;
    (v44--)[(_QWORD)v42] = v45;
  }
  while (v27 != (char *)v38);
  v27 = (char *)__p[0];
  __p[0] = v42;
  v54 = v43;
  if (v27)
    goto LABEL_72;
LABEL_73:
  __p[1] = v37;
  LOWORD(__src) = 1;
  std::vector<unsigned char>::__insert_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((uint64_t)__p, v37, (char *)&__src, (char *)&__src + 2, 2);
  LOWORD(__src) = 1;
  std::vector<unsigned char>::__insert_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((uint64_t)__p, (char *)__p[1], (char *)&__src, (char *)&__src + 2, 2);
  __src = 2;
  std::vector<unsigned char>::__insert_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((uint64_t)__p, (char *)__p[1], (char *)&__src, (char *)&v56, 4);
  v49 = v52;
  v50 = *(_OWORD *)__p;
  v51 = v54;
  v46 = __p[0];
  v47 = MIDICI::DeviceManager::sendMessage((uint64_t)this, a2, a3, (uint64_t)&v49);
  if (v46)
    operator delete(v46);
  return v47;
}

void sub_1D4ED5C7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  void *v15;

  if (v15)
    operator delete(v15);
  _Unwind_Resume(exception_object);
}

void MIDICI::DeviceManager::handleEndpointInformationReply(std::string *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  std::string::size_type v4;
  std::string *p_dst;
  uint64_t v7;
  uint64_t v8;
  std::string __dst;

  v2 = *(_QWORD *)(a2 + 8);
  if (!*(_BYTE *)(v2 + 12))
  {
    v3 = *(_QWORD *)(a2 + 16);
    v4 = v3 - v2;
    if ((unint64_t)(v3 - v2) >= 0x7FFFFFFFFFFFFFF8)
      std::string::__throw_length_error[abi:ne180100]();
    if (v4 >= 0x17)
    {
      v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v4 | 7) != 0x17)
        v7 = v4 | 7;
      v8 = v7 + 1;
      p_dst = (std::string *)operator new(v7 + 1);
      __dst.__r_.__value_.__l.__size_ = v4;
      __dst.__r_.__value_.__r.__words[2] = v8 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v3 - v2;
      p_dst = &__dst;
      if (v3 == v2)
      {
LABEL_10:
        p_dst->__r_.__value_.__s.__data_[v4] = 0;
        std::string::operator=(a1 + 5, &__dst);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__dst.__r_.__value_.__l.__data_);
        return;
      }
    }
    memmove(p_dst, (const void *)(v2 + 15), v4);
    goto LABEL_10;
  }
}

void sub_1D4ED5D88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void MIDICI::DeviceManager::handleInvalidateMUID(MIDICI::DeviceManager *this, MIDICI::Device *a2, int a3)
{
  MIDICI::Device **v4;
  MIDICI::Device **v5;
  MIDICI::Device **v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (*((_DWORD *)this + 24) == a3)
  {
    MIDICI::DeviceManager::handleInvalidateManagerMUID((unsigned int *)this, 0, 0);
  }
  else if (a2)
  {
    v4 = (MIDICI::Device **)*((_QWORD *)this + 1);
    v5 = (MIDICI::Device **)*((_QWORD *)this + 2);
    if (v4 != v5)
    {
      while (*v4 != a2)
      {
        if (++v4 == v5)
          return;
      }
    }
    if (v4 != v5)
    {
      v6 = v4 + 1;
      if (v4 + 1 != v5)
      {
        do
        {
          v4 = v6;
          v7 = (uint64_t)*(v6 - 1);
          *(v6 - 1) = *v6;
          *v6 = 0;
          if (v7)
            std::default_delete<MIDICI::Device>::operator()[abi:ne180100](v7);
          v6 = v4 + 1;
        }
        while (v4 + 1 != v5);
        v5 = (MIDICI::Device **)*((_QWORD *)this + 2);
      }
      while (v5 != v4)
      {
        v9 = (uint64_t)*--v5;
        v8 = v9;
        *v5 = 0;
        if (v9)
          std::default_delete<MIDICI::Device>::operator()[abi:ne180100](v8);
      }
      *((_QWORD *)this + 2) = v4;
    }
  }
}

void MIDICI::DeviceManager::handleProfileInquiryReply(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  _BYTE *v9;
  _BYTE *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  _BYTE *v15;
  _BYTE *v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  _BYTE *v21;
  _BYTE *v22;
  uint64_t v23;
  _BYTE *v24;
  _BYTE *v25;
  uint64_t v26;
  uint8_t buf[4];
  const char *v28;
  __int16 v29;
  int v30;
  char v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v26 = a2;
  if (a1)
  {
    v4 = (_QWORD *)a1[18];
    v5 = (_QWORD *)a1[19];
    while (v5 != v4)
    {
      v7 = *--v5;
      v6 = v7;
      *v5 = 0;
      if (v7)
        std::default_delete<MIDICI::Profile>::operator()[abi:ne180100](v6);
    }
    a1[19] = v4;
    midi::ci::profile_inquiry_reply_view::make_profiles((midi::ci::profile_inquiry_reply_view *)&v24, (uint64_t)&v26, 12);
    v8 = v24;
    v9 = v25;
    if (v24 != v25)
    {
      v10 = v24;
      do
      {
        v11 = operator new();
        buf[0] = 0;
        v31 = 0;
        MIDICI::Profile::Profile(v11, v10, (__int128 *)buf, 1);
        v23 = v11;
        MIDICI::Device::addProfile(a1, &v23);
        v12 = v23;
        v23 = 0;
        if (v12)
          std::default_delete<MIDICI::Profile>::operator()[abi:ne180100](v12);
        v10 += 5;
      }
      while (v10 != v9);
    }
    v13 = *(_QWORD *)(a2 + 8);
    if ((unint64_t)(*(_QWORD *)(a2 + 16) - v13) <= 0xD)
      __assert_rtn("make_uint14", "sysex.h", 232, "data_pos + 1 < data.size()");
    midi::ci::profile_inquiry_reply_view::make_profiles((midi::ci::profile_inquiry_reply_view *)&v21, (uint64_t)&v26, 5 * (*(unsigned __int8 *)(v13 + 12) | ((unint64_t)*(unsigned __int8 *)(v13 + 13) << 7)) + 14);
    v14 = v21;
    v15 = v22;
    if (v21 != v22)
    {
      v16 = v21;
      do
      {
        v17 = operator new();
        buf[0] = 0;
        v31 = 0;
        MIDICI::Profile::Profile(v17, v16, (__int128 *)buf, 0);
        v20 = v17;
        MIDICI::Device::addProfile(a1, &v20);
        v18 = v20;
        v20 = 0;
        if (v18)
          std::default_delete<MIDICI::Profile>::operator()[abi:ne180100](v18);
        v16 += 5;
      }
      while (v16 != v15);
    }
    if (v14)
      operator delete(v14);
    if (v8)
      operator delete(v8);
  }
  else
  {
    gMIDICIDeviceManagerLog();
    v19 = gMIDICIDeviceManagerLog(void)::logCat;
    if (os_log_type_enabled((os_log_t)gMIDICIDeviceManagerLog(void)::logCat, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136315394;
      v28 = "CIDeviceManager.cpp";
      v29 = 1024;
      v30 = 543;
      _os_log_impl(&dword_1D4E88000, v19, OS_LOG_TYPE_INFO, "%25s:%-5d ERROR: Failed to handleProfileInquiryReply for null device", buf, 0x12u);
    }
  }
}

void sub_1D4ED60D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  _Unwind_Resume(exception_object);
}

void MIDICI::DeviceManager::handleProfileIDViewChange(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  _QWORD *v19;
  _QWORD *v20;
  int *v21;
  int v22;
  int v23;
  _QWORD *v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  CFTypeRef v33;
  CFTypeRef v34;
  CFTypeRef v35;
  CFTypeRef cf;
  uint64_t v37;
  int __s2;
  unsigned __int8 v39;
  uint8_t buf[4];
  const char *v41;
  __int16 v42;
  int v43;
  char v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v4 = *(_QWORD *)(a3 + 8);
    v5 = *(_QWORD *)(a3 + 16);
    v6 = *(unsigned __int8 *)(v4 + 12) | (*(_DWORD *)(v4 + 13) << 8);
    v39 = HIBYTE(*(_DWORD *)(v4 + 13));
    __s2 = v6;
    if ((unint64_t)(v5 - v4) >= 3)
    {
      v9 = *(unsigned __int8 *)(v4 + 2);
      if ((v9 - 36) < 2)
      {
        v16 = MIDICI::Device::profile(*(uint64_t **)(a2 + 144), *(uint64_t **)(a2 + 152), &__s2, 5uLL);
        if (v16)
        {
          *(_BYTE *)(v16 + 116) = v9 == 36;
          v17 = *a1;
          v18 = *(_DWORD *)(v16 + 8);
          v33 = 0;
          UMPCIServerContext::sendNotificationForObject(v17, 1, v18, &v33);
          if (v33)
            CFRelease(v33);
        }
      }
      else if (v9 == 39)
      {
        v19 = *(_QWORD **)(a2 + 144);
        v20 = *(_QWORD **)(a2 + 152);
        while (v19 != v20)
        {
          v21 = *(int **)(*v19 + 88);
          if (*(_QWORD *)(*v19 + 96) - (_QWORD)v21 == 5)
          {
            v22 = *v21;
            v23 = *((unsigned __int8 *)v21 + 4);
            if (v22 == __s2 && v23 == v39)
            {
              if (v19 != v20)
              {
                v25 = v19 + 1;
                v26 = *(_DWORD *)(*v19 + 8);
                if (v19 + 1 != v20)
                {
                  do
                  {
                    v19 = v25;
                    v27 = *(v25 - 1);
                    *(v25 - 1) = *v25;
                    *v25 = 0;
                    if (v27)
                      std::default_delete<MIDICI::Profile>::operator()[abi:ne180100](v27);
                    v25 = v19 + 1;
                  }
                  while (v19 + 1 != v20);
                  v20 = *(_QWORD **)(a2 + 152);
                }
                while (v20 != v19)
                {
                  v29 = *--v20;
                  v28 = v29;
                  *v20 = 0;
                  if (v29)
                    std::default_delete<MIDICI::Profile>::operator()[abi:ne180100](v28);
                }
                *(_QWORD *)(a2 + 152) = v19;
                v30 = *a1;
                v35 = 0;
                UMPCIServerContext::sendNotificationForObject(v30, 2, v26, &v35);
                if (v35)
                  CFRelease(v35);
                v31 = *a1;
                v32 = *(_DWORD *)(a2 + 8);
                v34 = 0;
                UMPCIServerContext::sendNotificationForObject(v31, 1, v32, &v34);
                if (v34)
                  CFRelease(v34);
              }
              return;
            }
          }
          ++v19;
        }
      }
      else if (v9 == 38)
      {
        v11 = operator new();
        buf[0] = 0;
        v44 = 0;
        MIDICI::Profile::Profile(v11, &__s2, (__int128 *)buf, 0);
        *(_DWORD *)(v11 + 120) = *(_DWORD *)(a2 + 8);
        *(_QWORD *)(v11 + 56) = a4;
        v37 = v11;
        MIDICI::Device::addProfile((_QWORD *)a2, &v37);
        v12 = v37;
        v37 = 0;
        if (v12)
          std::default_delete<MIDICI::Profile>::operator()[abi:ne180100](v12);
        v13 = *a1;
        v14 = *(_DWORD *)(a2 + 8);
        cf = 0;
        UMPCIServerContext::sendNotificationForObject(v13, 1, v14, &cf);
        if (cf)
          CFRelease(cf);
      }
    }
  }
  else
  {
    gMIDICIDeviceManagerLog();
    v15 = gMIDICIDeviceManagerLog(void)::logCat;
    if (os_log_type_enabled((os_log_t)gMIDICIDeviceManagerLog(void)::logCat, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136315394;
      v41 = "CIDeviceManager.cpp";
      v42 = 1024;
      v43 = 506;
      _os_log_impl(&dword_1D4E88000, v15, OS_LOG_TYPE_INFO, "%25s:%-5d ERROR: Failed to handleProfileIDViewChange for null device", buf, 0x12u);
    }
  }
}

void sub_1D4ED6454(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void MIDICI::DeviceManager::handleInvalidateManagerMUID(unsigned int *a1, uint64_t a2, __int16 a3)
{
  _DWORD *v6;
  unsigned int v7;
  NSObject *v8;
  NSObject *v9;
  unsigned int v10;
  uint64_t v11;
  NSObject *global_queue;
  _BYTE v13[24];
  void *v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v6 = (_DWORD *)MUIDGenerator::instance((MUIDGenerator *)a1);
  v7 = MUIDGenerator::operator()(v6);
  gMIDICIDeviceManagerLog();
  v8 = gMIDICIDeviceManagerLog(void)::logCat;
  if (os_log_type_enabled((os_log_t)gMIDICIDeviceManagerLog(void)::logCat, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)v13 = 136315650;
    *(_QWORD *)&v13[4] = "CIDeviceManager.cpp";
    *(_WORD *)&v13[12] = 1024;
    *(_DWORD *)&v13[14] = 470;
    *(_WORD *)&v13[18] = 1024;
    *(_DWORD *)&v13[20] = v7;
    _os_log_impl(&dword_1D4E88000, v8, OS_LOG_TYPE_INFO, "%25s:%-5d NOTICE: Received a message from myself, generating new MUID: %u", v13, 0x18u);
  }
  if ((a2 & 0xFF00000000) != 0
    && (a3 & 0xFF00) != 0
    && !MIDICI::DeviceManager::sendInvalidateMUIDMessage((MIDICI::DeviceManager *)a1, a2, a3, a1[24]))
  {
    gMIDICIDeviceManagerLog();
    v9 = gMIDICIDeviceManagerLog(void)::logCat;
    if (os_log_type_enabled((os_log_t)gMIDICIDeviceManagerLog(void)::logCat, OS_LOG_TYPE_INFO))
    {
      v10 = a1[24];
      *(_DWORD *)v13 = 136315650;
      *(_QWORD *)&v13[4] = "CIDeviceManager.cpp";
      *(_WORD *)&v13[12] = 1024;
      *(_DWORD *)&v13[14] = 474;
      *(_WORD *)&v13[18] = 1024;
      *(_DWORD *)&v13[20] = v10;
      _os_log_impl(&dword_1D4E88000, v9, OS_LOG_TYPE_INFO, "%25s:%-5d NOTICE: Asking the device to invalidate its MUID: %u", v13, 0x18u);
    }
  }
  a1[24] = v7;
  v11 = *(_QWORD *)a1;
  global_queue = dispatch_get_global_queue(0, 0);
  *(_QWORD *)v13 = MEMORY[0x1E0C809B0];
  *(_QWORD *)&v13[8] = 0x40000000;
  *(_QWORD *)&v13[16] = ___ZN18UMPCIServerContext27sendMUIDChangedNotificationEj_block_invoke;
  v14 = &__block_descriptor_tmp_1666;
  v15 = v11;
  v16 = v7;
  dispatch_async(global_queue, v13);
}

uint64_t MIDICI::DeviceManager::sendInvalidateMUIDMessage(MIDICI::DeviceManager *this, uint64_t a2, unsigned int a3, unsigned int a4)
{
  uint64_t v8;
  _BYTE v10[8];
  void *__p[3];
  char __src[4];
  uint64_t v13;

  midi::ci::message::make_with_payload_size((midi::ci::message *)v10, 4, 126, *((_DWORD *)this + 24), 0xFFFFFFFu, 127);
  if (a4 >> 28)
    __assert_rtn("add_uint28", "sysex.h", 238, "value <= uint28_max");
  __src[0] = a4 & 0x7F;
  __src[1] = (a4 >> 7) & 0x7F;
  __src[2] = (a4 >> 14) & 0x7F;
  __src[3] = a4 >> 21;
  std::vector<unsigned char>::__insert_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((uint64_t)__p, (char *)__p[1], __src, (char *)&v13, 4);
  v8 = MIDICI::DeviceManager::sendMessage((uint64_t)this, a2, a3, (uint64_t)v10);
  if (__p[0])
    operator delete(__p[0]);
  return v8;
}

void sub_1D4ED6798(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void ___ZN18UMPCIServerContext27sendMUIDChangedNotificationEj_block_invoke(SetupManager *a1)
{
  unsigned int v1;
  uint64_t v2;
  _QWORD v3[3];

  v1 = *((_DWORD *)a1 + 10);
  v3[2] = 0;
  v3[0] = 0x1800001003;
  v3[1] = v1;
  v2 = SetupManager::instance(a1);
  SetupManager::AddNotification(v2, (uint64_t)v3);
}

uint64_t **std::__tree<std::__value_type<unsigned int,std::unique_ptr<MIDICI::CIRetrier>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::unique_ptr<MIDICI::CIRetrier>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::unique_ptr<MIDICI::CIRetrier>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t **a1, unsigned int a2, _DWORD *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  unsigned int v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = (uint64_t *)v7;
    v7 = (uint64_t **)operator new(0x30uLL);
    *((_DWORD *)v7 + 8) = *a3;
    v7[5] = 0;
    *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *v6 = (uint64_t *)v7;
    v10 = (uint64_t *)**a1;
    v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void std::__function::__func<MIDICI::DeviceManager::processBackground(unsigned int,MIDIEventList const*)::$_0::operator() const(unsigned char,midi::sysex7 const&)::{lambda(int)#2},std::allocator<MIDICI::DeviceManager::processBackground(unsigned int,MIDIEventList const*)::$_0::operator() const(unsigned char,midi::sysex7 const&)::{lambda(int)#2}>,void ()(int)>::~__func()
{
  JUMPOUT(0x1D826BA98);
}

__n128 std::__function::__func<MIDICI::DeviceManager::processBackground(unsigned int,MIDIEventList const*)::$_0::operator() const(unsigned char,midi::sysex7 const&)::{lambda(int)#2},std::allocator<MIDICI::DeviceManager::processBackground(unsigned int,MIDIEventList const*)::$_0::operator() const(unsigned char,midi::sysex7 const&)::{lambda(int)#2}>,void ()(int)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_1E98BA4D8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<MIDICI::DeviceManager::processBackground(unsigned int,MIDIEventList const*)::$_0::operator() const(unsigned char,midi::sysex7 const&)::{lambda(int)#2},std::allocator<MIDICI::DeviceManager::processBackground(unsigned int,MIDIEventList const*)::$_0::operator() const(unsigned char,midi::sysex7 const&)::{lambda(int)#2}>,void ()(int)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E98BA4D8;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<MIDICI::DeviceManager::processBackground(unsigned int,MIDIEventList const*)::$_0::operator() const(unsigned char,midi::sysex7 const&)::{lambda(int)#2},std::allocator<MIDICI::DeviceManager::processBackground(unsigned int,MIDIEventList const*)::$_0::operator() const(unsigned char,midi::sysex7 const&)::{lambda(int)#2}>,void ()(int)>::operator()(uint64_t a1, int *a2)
{
  int v3;
  MIDICI::DeviceManager *v4;
  NSObject *v5;
  int v6;
  NSObject *v7;
  int v8;
  NSObject *v9;
  int v10;
  NSObject *v11;
  int v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  v4 = *(MIDICI::DeviceManager **)(a1 + 8);
  gMIDICIDeviceManagerLog();
  v5 = gMIDICIDeviceManagerLog(void)::logCat;
  if (os_log_type_enabled((os_log_t)gMIDICIDeviceManagerLog(void)::logCat, OS_LOG_TYPE_INFO))
  {
    v6 = *(_DWORD *)(a1 + 16);
    v12 = 136315906;
    v13 = "CIDeviceManager.cpp";
    v14 = 1024;
    v15 = 687;
    v16 = 1024;
    v17 = v6;
    v18 = 1024;
    v19 = v3;
    _os_log_impl(&dword_1D4E88000, v5, OS_LOG_TYPE_INFO, "%25s:%-5d NOTICE: Failed to find cached device with MUID: %d, sending discovery inquiry (attempt %d)..", (uint8_t *)&v12, 0x1Eu);
  }
  gMIDICIDeviceManagerLog();
  v7 = gMIDICIDeviceManagerLog(void)::logCat;
  if (os_log_type_enabled((os_log_t)gMIDICIDeviceManagerLog(void)::logCat, OS_LOG_TYPE_INFO))
  {
    v8 = *(_DWORD *)(a1 + 20);
    v12 = 136315650;
    v13 = "CIDeviceManager.cpp";
    v14 = 1024;
    v15 = 688;
    v16 = 1024;
    v17 = v8;
    _os_log_impl(&dword_1D4E88000, v7, OS_LOG_TYPE_INFO, "%25s:%-5d Source EndpointRef: %d", (uint8_t *)&v12, 0x18u);
  }
  gMIDICIDeviceManagerLog();
  v9 = gMIDICIDeviceManagerLog(void)::logCat;
  if (os_log_type_enabled((os_log_t)gMIDICIDeviceManagerLog(void)::logCat, OS_LOG_TYPE_INFO))
  {
    v10 = *(_DWORD *)(a1 + 24);
    v12 = 136315650;
    v13 = "CIDeviceManager.cpp";
    v14 = 1024;
    v15 = 689;
    v16 = 1024;
    v17 = v10;
    _os_log_impl(&dword_1D4E88000, v9, OS_LOG_TYPE_INFO, "%25s:%-5d Destination EndpointRef: %d", (uint8_t *)&v12, 0x18u);
  }
  if (MIDICI::DeviceManager::sendDiscoveryInquiryMessage(v4, *(unsigned int *)(a1 + 24), *(unsigned __int8 *)(a1 + 28)))
  {
    gMIDICIDeviceManagerLog();
    v11 = gMIDICIDeviceManagerLog(void)::logCat;
    if (os_log_type_enabled((os_log_t)gMIDICIDeviceManagerLog(void)::logCat, OS_LOG_TYPE_INFO))
    {
      v12 = 136315394;
      v13 = "CIDeviceManager.cpp";
      v14 = 1024;
      v15 = 694;
      _os_log_impl(&dword_1D4E88000, v11, OS_LOG_TYPE_INFO, "%25s:%-5d ERROR: Failed to send discovery inquiry message..", (uint8_t *)&v12, 0x12u);
    }
  }
}

uint64_t std::function<std::optional<unsigned char> ()(unsigned int,unsigned int,unsigned char)>::operator()(uint64_t a1, int a2, int a3, char a4)
{
  char v5;
  int v6;
  int v7;

  v7 = a2;
  v6 = a3;
  v5 = a4;
  if (!a1)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, int *, int *, char *))(*(_QWORD *)a1 + 48))(a1, &v7, &v6, &v5);
}

uint64_t UMPCIManager<MIDICI::Device>::addPairWithoutCheck(_QWORD *a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;

  v4 = *a2;
  v6 = (_QWORD *)a1[2];
  v5 = a1[3];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[1];
    v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v10 = v5 - v8;
    v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1))
      v11 = v9 + 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    if (v12)
    {
      if (v12 >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v13 = (char *)operator new(8 * v12);
    }
    else
    {
      v13 = 0;
    }
    v14 = &v13[8 * v9];
    v15 = &v13[8 * v12];
    *a2 = 0;
    *(_QWORD *)v14 = v4;
    v7 = v14 + 8;
    v16 = (_QWORD *)a1[1];
    v17 = (_QWORD *)a1[2];
    if (v17 == v16)
    {
      a1[1] = v14;
      a1[2] = v7;
      a1[3] = v15;
    }
    else
    {
      do
      {
        v18 = *--v17;
        *v17 = 0;
        *((_QWORD *)v14 - 1) = v18;
        v14 -= 8;
      }
      while (v17 != v16);
      v17 = (_QWORD *)a1[1];
      v19 = (_QWORD *)a1[2];
      a1[1] = v14;
      a1[2] = v7;
      a1[3] = v15;
      while (v19 != v17)
      {
        v21 = *--v19;
        v20 = v21;
        *v19 = 0;
        if (v21)
          std::default_delete<MIDICI::Device>::operator()[abi:ne180100](v20);
      }
    }
    if (v17)
      operator delete(v17);
  }
  else
  {
    *a2 = 0;
    *v6 = v4;
    v7 = v6 + 1;
  }
  a1[2] = v7;
  return v4;
}

void std::__function::__func<MIDICI::DeviceManager::processBackground(unsigned int,MIDIEventList const*)::$_0::operator() const(unsigned char,midi::sysex7 const&)::{lambda(int)#1},std::allocator<MIDICI::DeviceManager::processBackground(unsigned int,MIDIEventList const*)::$_0::operator() const(unsigned char,midi::sysex7 const&)::{lambda(int)#1}>,void ()(int)>::~__func()
{
  JUMPOUT(0x1D826BA98);
}

__n128 std::__function::__func<MIDICI::DeviceManager::processBackground(unsigned int,MIDIEventList const*)::$_0::operator() const(unsigned char,midi::sysex7 const&)::{lambda(int)#1},std::allocator<MIDICI::DeviceManager::processBackground(unsigned int,MIDIEventList const*)::$_0::operator() const(unsigned char,midi::sysex7 const&)::{lambda(int)#1}>,void ()(int)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E98BA490;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<MIDICI::DeviceManager::processBackground(unsigned int,MIDIEventList const*)::$_0::operator() const(unsigned char,midi::sysex7 const&)::{lambda(int)#1},std::allocator<MIDICI::DeviceManager::processBackground(unsigned int,MIDIEventList const*)::$_0::operator() const(unsigned char,midi::sysex7 const&)::{lambda(int)#1}>,void ()(int)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E98BA490;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<MIDICI::DeviceManager::processBackground(unsigned int,MIDIEventList const*)::$_0::operator() const(unsigned char,midi::sysex7 const&)::{lambda(int)#1},std::allocator<MIDICI::DeviceManager::processBackground(unsigned int,MIDIEventList const*)::$_0::operator() const(unsigned char,midi::sysex7 const&)::{lambda(int)#1}>,void ()(int)>::operator()(uint64_t a1, int *a2)
{
  int v3;
  unsigned int *v4;
  NSObject *v5;
  int v6;
  const char *v7;
  __int16 v8;
  int v9;
  __int16 v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  v4 = *(unsigned int **)(a1 + 8);
  gMIDICIDeviceManagerLog();
  v5 = gMIDICIDeviceManagerLog(void)::logCat;
  if (os_log_type_enabled((os_log_t)gMIDICIDeviceManagerLog(void)::logCat, OS_LOG_TYPE_ERROR))
  {
    v6 = 136315650;
    v7 = "CIDeviceManager.cpp";
    v8 = 1024;
    v9 = 637;
    v10 = 1024;
    v11 = v3;
    _os_log_impl(&dword_1D4E88000, v5, OS_LOG_TYPE_ERROR, "%25s:%-5d NOTICE: Suspected MUID collision, attempt %d to invalidate server MUID..", (uint8_t *)&v6, 0x18u);
  }
  MIDICI::DeviceManager::handleInvalidateManagerMUID(v4, *(unsigned int *)(a1 + 16) | 0x100000000, *(unsigned __int8 *)(a1 + 20) | 0x100);
}

void MUIDGenerator::MUIDGenerator(MUIDGenerator *this)
{
  uint32_t v2;
  unsigned int v3;
  std::random_device v4;
  std::string __token;

  std::string::basic_string[abi:ne180100]<0>(&__token, "/dev/urandom");
  std::random_device::random_device(&v4, &__token);
  if (SHIBYTE(__token.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__token.__r_.__value_.__l.__data_);
  v2 = arc4random();
  v3 = v2 + ((v2 / 0x7FFFFFFF) | ((v2 / 0x7FFFFFFF) << 31));
  if (v3 <= 1)
    v3 = 1;
  *(_DWORD *)this = v3;
  std::random_device::~random_device(&v4);
}

void sub_1D4ED6EC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, std::random_device a10, std::random_device __p, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  std::random_device::~random_device(&a10);
  _Unwind_Resume(a1);
}

void std::vector<std::unique_ptr<MIDICI::Device>>::erase(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t *v3;
  uint64_t *v4;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (a2 != a3)
  {
    v3 = a3;
    v4 = a2;
    v6 = *(uint64_t **)(a1 + 8);
    if (a3 != v6)
    {
      v7 = a3 - a2;
      do
      {
        v8 = v4[v7];
        v4[v7] = 0;
        v9 = *v4;
        *v4 = v8;
        if (v9)
          std::default_delete<MIDICI::Device>::operator()[abi:ne180100](v9);
        ++v4;
      }
      while (&v4[v7] != v6);
      v3 = *(uint64_t **)(a1 + 8);
    }
    while (v3 != v4)
    {
      v11 = *--v3;
      v10 = v11;
      *v3 = 0;
      if (v11)
        std::default_delete<MIDICI::Device>::operator()[abi:ne180100](v10);
    }
    *(_QWORD *)(a1 + 8) = v4;
  }
}

uint64_t UMPCIManager<MIDICI::Device>::removePairs(unsigned int,unsigned int)::{lambda(MIDICI::Device const&)#1}::operator()<std::unique_ptr<MIDICI::Device>>(int *a1, _DWORD *a2)
{
  int v2;
  int v3;
  uint64_t v4;
  int v5;
  unint64_t v6;
  _DWORD *v7;
  _DWORD *v8;
  _DWORD *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  BOOL v14;
  unint64_t v15;
  uint64_t v16;
  _DWORD *v17;
  unint64_t v18;
  int v19;

  v2 = a1[1];
  if (v2)
  {
    v3 = *a1;
  }
  else
  {
    v3 = *a1;
    if (a2[18] == *a1)
      goto LABEL_8;
  }
  if ((v3 || a2[19] != v2) && (a2[18] != v3 || a2[19] != v2))
    return 0;
LABEL_8:
  v4 = *((_QWORD *)a1 + 1);
  v5 = a2[2];
  v7 = *(_DWORD **)(v4 + 8);
  v6 = *(_QWORD *)(v4 + 16);
  if ((unint64_t)v7 >= v6)
  {
    v10 = *(_DWORD **)v4;
    v11 = ((uint64_t)v7 - *(_QWORD *)v4) >> 2;
    v12 = v11 + 1;
    if ((unint64_t)(v11 + 1) >> 62)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v13 = v6 - (_QWORD)v10;
    if (v13 >> 1 > v12)
      v12 = v13 >> 1;
    v14 = (unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL;
    v15 = 0x3FFFFFFFFFFFFFFFLL;
    if (!v14)
      v15 = v12;
    if (v15)
    {
      v15 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(v15);
      v10 = *(_DWORD **)v4;
      v7 = *(_DWORD **)(v4 + 8);
    }
    else
    {
      v16 = 0;
    }
    v17 = (_DWORD *)(v15 + 4 * v11);
    v18 = v15 + 4 * v16;
    *v17 = v5;
    v8 = v17 + 1;
    while (v7 != v10)
    {
      v19 = *--v7;
      *--v17 = v19;
    }
    *(_QWORD *)v4 = v17;
    *(_QWORD *)(v4 + 8) = v8;
    *(_QWORD *)(v4 + 16) = v18;
    if (v10)
      operator delete(v10);
  }
  else
  {
    *v7 = v5;
    v8 = v7 + 1;
  }
  *(_QWORD *)(v4 + 8) = v8;
  return 1;
}

uint64_t MIDIProcess::asMIGImpl(MIDIProcess *this)
{
  return 0;
}

void MIDIProcessXPC::~MIDIProcessXPC(MIDIProcessXPC *this)
{
  const void *v2;
  uint64_t v3;

  *(_QWORD *)this = off_1E98B8030;
  v2 = (const void *)*((_QWORD *)this + 55);
  if (v2)
    CFRelease(v2);
  v3 = *((_QWORD *)this + 54);
  *((_QWORD *)this + 54) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  MIDIProcess::~MIDIProcess(this);
}

{
  const void *v2;
  uint64_t v3;

  *(_QWORD *)this = off_1E98B8030;
  v2 = (const void *)*((_QWORD *)this + 55);
  if (v2)
    CFRelease(v2);
  v3 = *((_QWORD *)this + 54);
  *((_QWORD *)this + 54) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  MIDIProcess::~MIDIProcess(this);
  JUMPOUT(0x1D826BA98);
}

int64_t MIDIProcessXPC::Initialize(MIDIProcessXPC *this)
{
  swix::connection *v2;
  void *v3;
  uint64_t v4;
  const swix::encode_message *v5;
  int64_t v6;
  _BYTE v8[8];
  xpc_object_t object;
  int v10;
  xpc_object_t xdict;

  v2 = *(swix::connection **)(*((_QWORD *)this + 54) + 8);
  if (!v2)
    goto LABEL_9;
  swix::connection::activate(v2);
  MIDIProcess::createInPort((mach_port_name_t **)this);
  MIDIProcess::createInThread(this);
  v3 = (void *)xpc_mach_send_create();
  if (!v3)
    v3 = xpc_null_create();
  v4 = *((_QWORD *)this + 54);
  swix::encode_message::encode_message((swix::encode_message *)&v10, 220460581);
  xpc_dictionary_set_value(xdict, "ioPort", v3);
  xpc_dictionary_set_BOOL(xdict, "isIntel", 0);
  v5 = *(const swix::encode_message **)(v4 + 8);
  if (!v5)
LABEL_9:
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)v8, v5, &v10);
  v6 = swix::coder<int>::decode(object, ".error");
  xpc_release(object);
  xpc_release(xdict);
  if ((unint64_t)((_DWORD)v6 == 0) << 32 || !(_DWORD)v6)
  {
    MIDIProcess::createOutPort((mach_port_name_t **)this);
    MIDIProcess::setupIOBuffers(this);
    v6 = 0;
    *((_BYTE *)this + 448) = 1;
  }
  xpc_release(v3);
  return v6;
}

void sub_1D4ED7294(_Unwind_Exception *a1)
{
  void *v1;

  xpc_release(v1);
  _Unwind_Resume(a1);
}

void sub_1D4ED72B4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object)
{
  xpc_release(object);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4ED723CLL);
}

uint64_t MIDIProcessXPC::Uninitialize(MIDIProcessXPC *this)
{
  mach_port_name_t **v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;

  v3 = *((_QWORD *)this + 3);
  v2 = (mach_port_name_t **)((char *)this + 24);
  *((_BYTE *)v2 - 11) = 1;
  *((_BYTE *)v2 + 424) = 0;
  if (v3)
    std::unique_ptr<XClientMachPort>::reset[abi:ne180100](v2, 0);
  CADeprecated::XThread::Stop(*((CADeprecated::XThread **)this + 4));
  v4 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  std::unique_ptr<XServerMachPort>::reset[abi:ne180100]((mach_port_name_t **)this + 2, 0);
  v5 = *((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = 0;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  result = *((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void MIDIProcessXPC::SetCallbackRunLoop(MIDIProcessXPC *this, CFTypeRef cf)
{
  const void *v4;

  if (cf)
    CFRetain(cf);
  v4 = (const void *)*((_QWORD *)this + 55);
  *((_QWORD *)this + 55) = cf;
  if (v4)
    CFRelease(v4);
}

uint64_t MIDIProcessXPC::InitOnce(MIDIProcessXPC *this)
{
  uint64_t result;

  if (*((_BYTE *)this + 448))
    return *((unsigned int *)this + 2);
  result = (*(uint64_t (**)(MIDIProcessXPC *))(*(_QWORD *)this + 32))(this);
  *((_DWORD *)this + 2) = result;
  *((_BYTE *)this + 448) = 1;
  return result;
}

uint64_t MIDIProcessXPC::GetObjectTree(MIDIProcessXPC *this, int *a2)
{
  uint64_t v3;
  const swix::encode_message *v4;
  int v5;
  xpc_object_t v6;
  xpc_object_t v7;
  xpc_object_t v8;
  xpc_object_t v9;
  int v10;
  uint64_t v11;
  const UInt8 *bytes_ptr;
  size_t length;
  CFDataRef v14;
  void *exception;
  xpc_object_t v17;
  char v18;
  xpc_object_t v19;
  uint64_t v20;
  xpc_object_t object;
  int v22;
  xpc_object_t xdict;

  v3 = *((_QWORD *)this + 54);
  swix::encode_message::encode_message((swix::encode_message *)&v22, 220460624);
  xpc_dictionary_set_BOOL(xdict, "isBigEndian", 0);
  v4 = *(const swix::encode_message **)(v3 + 8);
  if (!v4)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)&v20, v4, &v22);
  v5 = swix::coder<int>::decode(object, ".error");
  if (v5)
  {
    LODWORD(v17) = v5;
    v18 = 0;
  }
  else
  {
    v6 = xpc_null_create();
    swix::xpcobj_coder<swix::data>::decode(&v19, object, "data");
    v7 = v19;
    v8 = xpc_null_create();
    v19 = v8;
    xpc_release(v6);
    xpc_release(v8);
    std::__tuple_leaf<0ul,swix::data,false>::__tuple_leaf[abi:ne180100](&v17, v7);
    v18 = 1;
    xpc_release(v7);
  }
  xpc_release(object);
  xpc_release(xdict);
  if (v18)
  {
    *a2 = 0;
  }
  else
  {
    v10 = (int)v17;
    *a2 = (int)v17;
    if (v10)
      return 0;
  }
  v9 = v17;
  if (v17)
    xpc_retain(v17);
  else
    v9 = xpc_null_create();
  bytes_ptr = (const UInt8 *)xpc_data_get_bytes_ptr(v9);
  length = xpc_data_get_length(v9);
  v14 = CFDataCreate(0, bytes_ptr, length);
  if (!v14)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)&v20, v14);
  v11 = v20;
  xpc_release(v9);
  if (v18)
    xpc_release(v17);
  return v11;
}

void sub_1D4ED75F8(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t a9, char a10, uint64_t a11, uint64_t a12, xpc_object_t object)
{
  void *v13;
  void *v14;

  v14 = v13;
  xpc_release(v14);
  xpc_release(object);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4ED7504);
}

void swix::connection::activate(swix::connection *this)
{
  xpc_connection_t connection;

  swix::connection::xpc_connection((swix::connection *)&connection, (uint64_t)this);
  xpc_connection_activate(connection);
  xpc_release(connection);
}

void sub_1D4ED76F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  _Unwind_Resume(a1);
}

uint64_t std::__optional_destruct_base<swix::connection_config,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  NSObject *v4;

  if (!*(_BYTE *)(a1 + 128))
    return a1;
  if (*(_BYTE *)(a1 + 120))
  {
    v2 = *(_QWORD **)(a1 + 112);
    if (v2 == (_QWORD *)(a1 + 88))
    {
      v3 = 4;
      v2 = (_QWORD *)(a1 + 88);
      goto LABEL_7;
    }
    if (v2)
    {
      v3 = 5;
LABEL_7:
      (*(void (**)(void))(*v2 + 8 * v3))();
    }
  }
  v4 = *(NSObject **)(a1 + 56);
  if (v4)
    dispatch_release(v4);
  xpc_release(*(xpc_object_t *)(a1 + 48));
  *(_QWORD *)(a1 + 48) = 0;
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  return a1;
}

_QWORD *std::function<void ()(swix::ipc_endpoint &,applesauce::xpc::object const&)>::operator=(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD v8[3];
  _QWORD *v9;
  _QWORD v10[4];

  v10[3] = *MEMORY[0x1E0C80C00];
  std::__function::__value_func<void ()(applesauce::iokit::io_object_holder)>::__value_func[abi:ne180100]((uint64_t)v8, a2);
  if (v8 != a1)
  {
    v3 = v9;
    v4 = (_QWORD *)a1[3];
    if (v9 == v8)
    {
      if (v4 == a1)
      {
        (*(void (**)(_QWORD *, _QWORD *))(v8[0] + 24))(v8, v10);
        (*(void (**)(_QWORD *))(*v9 + 32))(v9);
        v9 = 0;
        (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)a1[3] + 24))(a1[3], v8);
        (*(void (**)(_QWORD))(*(_QWORD *)a1[3] + 32))(a1[3]);
        a1[3] = 0;
        v9 = v8;
        (*(void (**)(_QWORD *, _QWORD *))(v10[0] + 24))(v10, a1);
        (*(void (**)(_QWORD *))(v10[0] + 32))(v10);
      }
      else
      {
        (*(void (**)(_QWORD *, _QWORD *))(v8[0] + 24))(v8, a1);
        (*(void (**)(_QWORD *))(*v9 + 32))(v9);
        v9 = (_QWORD *)a1[3];
      }
      a1[3] = a1;
    }
    else if (v4 == a1)
    {
      (*(void (**)(_QWORD *, _QWORD *))(*a1 + 24))(a1, v8);
      (*(void (**)(_QWORD))(*(_QWORD *)a1[3] + 32))(a1[3]);
      a1[3] = v9;
      v9 = v8;
    }
    else
    {
      v9 = (_QWORD *)a1[3];
      a1[3] = v3;
    }
  }
  v5 = v9;
  if (v9 == v8)
  {
    v6 = 4;
    v5 = v8;
    goto LABEL_14;
  }
  if (v9)
  {
    v6 = 5;
LABEL_14:
    (*(void (**)(void))(*v5 + 8 * v6))();
  }
  return a1;
}

void sub_1D4ED795C(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

void std::__function::__func<MIDIProcessXPC::MIDIProcessXPC(void)::$_0,std::allocator<MIDIProcessXPC::MIDIProcessXPC(void)::$_0>,void ()(swix::ipc_endpoint &,applesauce::xpc::object const&)>::~__func()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *std::__function::__func<MIDIProcessXPC::MIDIProcessXPC(void)::$_0,std::allocator<MIDIProcessXPC::MIDIProcessXPC(void)::$_0>,void ()(swix::ipc_endpoint &,applesauce::xpc::object const&)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E98B8780;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<MIDIProcessXPC::MIDIProcessXPC(void)::$_0,std::allocator<MIDIProcessXPC::MIDIProcessXPC(void)::$_0>,void ()(swix::ipc_endpoint &,applesauce::xpc::object const&)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E98B8780;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<MIDIProcessXPC::MIDIProcessXPC(void)::$_0,std::allocator<MIDIProcessXPC::MIDIProcessXPC(void)::$_0>,void ()(swix::ipc_endpoint &,applesauce::xpc::object const&)>::operator()(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 40))(*(_QWORD *)(a1 + 8));
}

void MIDIProcessXPC::MIDIProcessXPC(MIDIProcessXPC *this)
{
  NSObject *inactive;
  _QWORD *v2;
  NSObject *v3;
  uint64_t v4;
  std::string *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  CFRunLoopRef Current;
  void *v12[2];
  char v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  xpc_object_t v17;
  dispatch_object_t object;
  uint64_t v19;
  __int16 v20;
  char v21;
  _BYTE v22[24];
  _BYTE *v23;
  char v24;
  std::string __p[5];
  char v26;
  _BYTE buf[18];
  __int16 v28;
  _BYTE v29[12];
  char v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  MIDIProcess::MIDIProcess((MIDIProcess *)MIDIProcess::defaultInstance(int)::xpcImpl);
  MIDIProcess::defaultInstance(int)::xpcImpl[0] = (uint64_t)off_1E98B8030;
  inactive = dispatch_workloop_create_inactive("MIDIClient");
  dispatch_workloop_set_scheduler_priority();
  dispatch_activate(inactive);
  std::string::basic_string[abi:ne180100]<0>(v12, "com.apple.midiserver");
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = xpc_null_create();
  if (inactive)
    dispatch_retain(inactive);
  object = inactive;
  gMIDIClientLog();
  v19 = gMIDIClientLog(void)::clilib;
  v20 = 256;
  v21 = 0;
  v24 = 0;
  dispatch_release(inactive);
  v2 = (_QWORD *)operator new();
  swix::connection_config::connection_config(__p, (const swix::connection_config *)v12);
  v26 = 1;
  buf[0] = 0;
  v30 = 0;
  std::construct_at[abi:ne180100]<swix::connection_config,swix::connection_config,swix::connection_config*>((uint64_t)buf, (__int128 *)__p);
  v30 = 1;
  swix::ipc_interface::ipc_interface(v2, (const swix::connection_config *)buf);
  std::__optional_destruct_base<swix::connection_config,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)buf);
  *v2 = &off_1E98B8198;
  v2[2] = MIDIProcess::defaultInstance(int)::xpcImpl;
  qword_1EFEFDD40 = (uint64_t)v2;
  std::__optional_destruct_base<swix::connection_config,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)__p);
  gMIDIClientLog();
  v3 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEFAULT))
  {
    v4 = v2[1];
    if (!v4)
      goto LABEL_29;
    swix::connection::description((swix::connection *)__p, *(_QWORD *)(v4 + 8));
    if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v5 = __p;
    else
      v5 = (std::string *)__p[0].__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 136315650;
    *(_QWORD *)&buf[4] = "MIDIProcessXPC.cpp";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 38;
    v28 = 2080;
    *(_QWORD *)v29 = v5;
    _os_log_impl(&dword_1D4E88000, v3, OS_LOG_TYPE_DEFAULT, "%25s:%-5d client conn %s", buf, 0x1Cu);
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p[0].__r_.__value_.__l.__data_);
  }
  if (v24)
  {
    v6 = v23;
    if (v23 == v22)
    {
      v7 = 4;
      v6 = v22;
    }
    else
    {
      if (!v23)
        goto LABEL_16;
      v7 = 5;
    }
    (*(void (**)(void))(*v6 + 8 * v7))();
  }
LABEL_16:
  if (object)
    dispatch_release(object);
  xpc_release(v17);
  v17 = 0;
  if (SHIBYTE(v16) < 0)
    operator delete(v14);
  if (v13 < 0)
    operator delete(v12[0]);
  qword_1EFEFDD48 = 0;
  byte_1EFEFDD50 = 0;
  _InitMIDIProperties();
  v8 = *(_QWORD *)(qword_1EFEFDD40 + 8);
  if (!v8)
LABEL_29:
    std::terminate();
  *(_QWORD *)buf = &off_1E98B8780;
  *(_QWORD *)&buf[8] = MIDIProcess::defaultInstance(int)::xpcImpl;
  *(_QWORD *)&v29[4] = buf;
  std::function<void ()(swix::ipc_endpoint &,applesauce::xpc::object const&)>::operator=((_QWORD *)(v8 + 24), (uint64_t)buf);
  v9 = *(_QWORD **)&v29[4];
  if (*(_BYTE **)&v29[4] == buf)
  {
    v10 = 4;
    v9 = buf;
    goto LABEL_27;
  }
  if (*(_QWORD *)&v29[4])
  {
    v10 = 5;
LABEL_27:
    (*(void (**)(void))(*v9 + 8 * v10))();
  }
  Current = CFRunLoopGetCurrent();
  (*(void (**)(uint64_t *, CFRunLoopRef))(MIDIProcess::defaultInstance(int)::xpcImpl[0] + 48))(MIDIProcess::defaultInstance(int)::xpcImpl, Current);
}

void sub_1D4ED7CF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,xpc_object_t a22,dispatch_object_t object,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t *a30,char a31,int a32,__int16 a33,char a34,char a35)
{
  uint64_t v35;
  uint64_t *v37;
  uint64_t v38;

  qword_1EFEFDD40 = 0;
  (*(void (**)(uint64_t))(*(_QWORD *)v35 + 8))(v35);
  if (a31)
  {
    v37 = a30;
    if (a30 == &a27)
    {
      v38 = 4;
      v37 = &a27;
    }
    else
    {
      if (!a30)
        goto LABEL_7;
      v38 = 5;
    }
    (*(void (**)(void))(*v37 + 8 * v38))();
  }
LABEL_7:
  if (object)
    dispatch_release(object);
  xpc_release(a22);
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  MIDIProcess::~MIDIProcess((MIDIProcess *)MIDIProcess::defaultInstance(int)::xpcImpl);
  _Unwind_Resume(a1);
}

void ___ZN14MIDIProcessXPC14DispatchNotifyEPKvm_block_invoke(uint64_t a1)
{
  const __CFData *v2;
  char **v3;
  const UInt8 *BytePtr;
  const __CFData *v5;
  size_t Length;
  int v7;
  int v8;
  NSObject *v9;
  applesauce::CF *exception;
  applesauce::CF *v11;
  int v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v2 = *(const __CFData **)(a1 + 40);
  if (!v2)
  {
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  v3 = *(char ***)(a1 + 32);
  BytePtr = CFDataGetBytePtr(v2);
  v5 = *(const __CFData **)(a1 + 40);
  if (!v5)
  {
    v11 = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(v11);
  }
  Length = CFDataGetLength(v5);
  v7 = MIDIProcess::Notify(v3, (const UniChar *)BytePtr, Length);
  if (v7)
  {
    v8 = v7;
    gMIDIClientLog();
    v9 = gMIDIClientLog(void)::clilib;
    if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_ERROR))
    {
      v12 = 136315650;
      v13 = "MIDIProcessXPC.cpp";
      v14 = 1024;
      v15 = 113;
      v16 = 1024;
      v17 = v8;
      _os_log_impl(&dword_1D4E88000, v9, OS_LOG_TYPE_ERROR, "%25s:%-5d Error from Notify(), err = %d", (uint8_t *)&v12, 0x18u);
    }
  }
}

void sub_1D4ED7FA4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

_QWORD *__copy_helper_block_e8_40c29_ZTSN10applesauce2CF7DataRefE(_QWORD *result, uint64_t a2)
{
  _QWORD *v2;
  uint64_t v3;

  v2 = result;
  v3 = *(_QWORD *)(a2 + 40);
  if (v3)
    result = CFRetain(*(CFTypeRef *)(a2 + 40));
  v2[5] = v3;
  return result;
}

void __destroy_helper_block_e8_40c29_ZTSN10applesauce2CF7DataRefE(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 40);
  if (v1)
    CFRelease(v1);
}

void _ZNSt3__110__function6__funcIZN20MIDIServerXPC_Client6notifyERKN4swix4dataEE3__0NS_9allocatorIS7_EEFvNS3_6resultIJEEEEED0Ev()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *_ZNKSt3__110__function6__funcIZN20MIDIServerXPC_Client6notifyERKN4swix4dataEE3__0NS_9allocatorIS7_EEFvNS3_6resultIJEEEEE7__cloneEv()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E98B87C8;
  return result;
}

void _ZNKSt3__110__function6__funcIZN20MIDIServerXPC_Client6notifyERKN4swix4dataEE3__0NS_9allocatorIS7_EEFvNS3_6resultIJEEEEE7__cloneEPNS0_6__baseISC_EE(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E98B87C8;
}

void _ZNSt3__110__function6__funcIZN20MIDIServerXPC_Client6notifyERKN4swix4dataEE3__0NS_9allocatorIS7_EEFvNS3_6resultIJEEEEEclEOSB_(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  NSObject *v4;
  int v5;
  const char *v6;
  __int16 v7;
  int v8;
  __int16 v9;
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v2 = *a2;
  if ((*a2 & 0xFF00000000) == 0 && (_DWORD)v2 != 0)
  {
    gMIDIClientLog();
    v4 = gMIDIClientLog(void)::clilib;
    if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_ERROR))
    {
      v5 = 136315650;
      v6 = "MIDIProcessXPC.cpp";
      v7 = 1024;
      v8 = 164;
      v9 = 1024;
      v10 = v2;
      _os_log_impl(&dword_1D4E88000, v4, OS_LOG_TYPE_ERROR, "%25s:%-5d Received error from async acknowledgeNotification(), err = %d", (uint8_t *)&v5, 0x18u);
    }
  }
}

void MIDISetup::~MIDISetup(MIDISetup *this)
{
  MIDISetup::~MIDISetup(this);
  JUMPOUT(0x1D826BA98);
}

{
  BaseOpaqueObject *v2;
  BaseOpaqueObject *v3;
  char v4;
  char v5;
  BaseOpaqueObject *v6;
  uint64_t v7;
  MIDIDevice *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;

  *(_QWORD *)this = &off_1E98B9AD8;
  v2 = (MIDISetup *)((char *)this + 136);
  v3 = (MIDISetup *)((char *)this + 48);
  v4 = 1;
  do
  {
    v5 = v4;
    if ((v4 & 1) != 0)
      v6 = v2;
    else
      v6 = v3;
    while (1)
    {
      v7 = *((_QWORD *)v6 + 3);
      if (*((_QWORD *)v6 + 2) == v7)
        break;
      v8 = *(MIDIDevice **)(v7 - 8);
      *((_QWORD *)v6 + 3) = v7 - 8;
      MIDISetup::DeviceRemoveEffects(this, v8);
      if (v8)
        (*(void (**)(MIDIDevice *))(*(_QWORD *)v8 + 8))(v8);
    }
    v4 = 0;
  }
  while ((v5 & 1) != 0);
  OwnedPtrVector<MIDIConnection *>::~OwnedPtrVector((_QWORD *)this + 22);
  v9 = (void *)*((_QWORD *)this + 19);
  if (v9)
  {
    *((_QWORD *)this + 20) = v9;
    operator delete(v9);
  }
  BaseOpaqueObject::~BaseOpaqueObject(v2);
  v10 = (void *)*((_QWORD *)this + 14);
  if (v10)
  {
    *((_QWORD *)this + 15) = v10;
    operator delete(v10);
  }
  v11 = (void *)*((_QWORD *)this + 11);
  if (v11)
  {
    *((_QWORD *)this + 12) = v11;
    operator delete(v11);
  }
  v12 = (void *)*((_QWORD *)this + 8);
  if (v12)
  {
    *((_QWORD *)this + 9) = v12;
    operator delete(v12);
  }
  BaseOpaqueObject::~BaseOpaqueObject(v3);
  *(_QWORD *)this = off_1E98B9320;
  XCFObject<__CFDictionary const*>::~XCFObject((uint64_t)this + 24);
  BaseOpaqueObject::~BaseOpaqueObject(this);
}

uint64_t MIDISetup::PrintObject(MIDISetup *this, __sFILE *a2)
{
  fprintf(a2, "<%s 0x%x [%p]>", "MIDISetupRef", *((_DWORD *)this + 2), this);
  fprintf(a2, " parent=0x%X", *((_QWORD *)this + 2));
  return fputc(10, a2);
}

uint64_t TOpaqueObject<MIDISetup,unsigned int,MIDIObject>::isa(uint64_t a1, void *a2)
{
  _BOOL4 v3;

  v3 = a2 == &TOpaqueRTTI<MIDIObject>::sRTTI || a2 == &BaseOpaqueObject::sBaseRTTI;
  return a2 == &TOpaqueRTTI<MIDISetup>::sRTTI || v3;
}

uint64_t MIDISetup::GetProperty(MIDISetup *this, const __CFString *cf1, const void **a3)
{
  const void *v6;

  if (!CFEqual(cf1, kMIDIPropertyName))
    return MIDIObject::GetProperty(this, cf1, a3, 1);
  v6 = (const void *)*((_QWORD *)this + 26);
  *a3 = v6;
  CFRetain(v6);
  return 0;
}

uint64_t MIDISetup::SetProperty(MIDISetup *this, const __CFString *cf1, const __CFString *a3)
{
  CFTypeID v6;
  uint64_t v7;
  int v9;
  SetupManager *v10;
  SetupManager *v11;
  SetupManager *v12;

  if (!CFEqual(cf1, kMIDIPropertyName))
    return MIDIObject::SetProperty((const __CFDictionary **)this, cf1, a3);
  v6 = CFGetTypeID(a3);
  if (v6 != CFStringGetTypeID() || CFEqual(a3, *((CFTypeRef *)this + 26)))
    return 0;
  if (CFStringGetLength(*((CFStringRef *)this + 26)))
  {
    MIDIConfigFileRenameOrDelete(*((const __CFString **)this + 26), a3);
    if (v9)
      return 1;
  }
  CFRelease(*((CFTypeRef *)this + 26));
  *((_QWORD *)this + 26) = a3;
  v10 = (SetupManager *)CFRetain(a3);
  v11 = (SetupManager *)SetupManager::instance(v10);
  v7 = 1;
  *((_BYTE *)v11 + 81) = 1;
  *((_BYTE *)this + 217) = 1;
  v12 = (SetupManager *)SetupManager::instance(v11);
  SetupManager::SchedulePrefSaver(v12);
  MIDISetup::CheckWritePrefFile(this);
  return v7;
}

__CFDictionary *MIDISetup::ToPList(CFDictionaryRef *this)
{
  __CFDictionary *v2;
  __CFArray *v3;
  __CFArray *v4;
  uint64_t v5;
  __CFArray *Mutable;
  CFDictionaryRef v7;
  CFDictionaryRef v8;
  const CFDictionaryKeyCallBacks *v9;
  const CFDictionaryValueCallBacks *v10;
  uint64_t v11;
  CFMutableDictionaryRef v12;
  CFMutableDictionaryRef theDict;
  __int16 v15;

  v2 = MIDIObject::ToDictionary(this[3]);
  v3 = DeviceList::ToPList((DeviceList *)(this + 6));
  CFDictionarySetValue(v2, CFSTR("devices"), v3);
  CFRelease(v3);
  if (this[20] != this[19])
  {
    v4 = DeviceList::ToPList((DeviceList *)(this + 17));
    CFDictionarySetValue(v2, CFSTR("externalDevices"), v4);
    CFRelease(v4);
  }
  v5 = this[24] - this[23];
  if (v5)
  {
    Mutable = CFArrayCreateMutable(0, v5 >> 3, MEMORY[0x1E0C9B378]);
    v8 = this[23];
    v7 = this[24];
    if (v8 != v7)
    {
      v9 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
      v10 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
      do
      {
        v11 = *(_QWORD *)v8;
        if (*(_QWORD *)(*(_QWORD *)v8 + 16))
        {
          if (*(_QWORD *)(v11 + 48))
          {
            theDict = CFDictionaryCreateMutable(0, 0, v9, v10);
            v15 = 257;
            CFDictionarySetValue(theDict, CFSTR("owner"), *(const void **)(v11 + 16));
            CFDictionarySetValue(theDict, CFSTR("data"), *(const void **)(v11 + 48));
            v12 = theDict;
            if (theDict)
              CFRetain(theDict);
            XCFObject<__CFDictionary const*>::~XCFObject((uint64_t)&theDict);
          }
          else
          {
            v12 = 0;
          }
          CFArrayAppendValue(Mutable, v12);
          CFRelease(v12);
          v7 = this[24];
        }
        v8 = (CFDictionaryRef)((char *)v8 + 8);
      }
      while (v8 != v7);
    }
    CFDictionarySetValue(v2, CFSTR("thruConnections"), Mutable);
    CFRelease(Mutable);
  }
  return v2;
}

void sub_1D4ED851C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  XCFObject<__CFDictionary const*>::~XCFObject((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void MIDISetup::FromPList(MIDISetup *this, __CFDictionary *a2)
{
  __CFDictionary *v2;
  const __CFArray *v4;
  const __CFArray *v5;
  const __CFArray *v6;
  const __CFArray *v7;
  const __CFArray *v8;
  int Count;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  uint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  CFIndex i;
  __CFDictionary *ValueAtIndex;
  uint64_t v23;
  CFTypeRef v24;
  const __CFData *v25;
  const UInt8 *BytePtr;
  uint64_t j;
  const UInt8 *v28;
  unint64_t v29;
  uint64_t *v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  char *v39;
  char *v40;
  uint64_t v41;
  __CFDictionary *v42;

  if (a2)
  {
    v2 = a2;
    v4 = (const __CFArray *)DictGetAndDelete(a2, CFSTR("devices"));
    DeviceList::FromPList((MIDISetup *)((char *)this + 48), v4);
    CFRelease(v4);
    v5 = (const __CFArray *)DictGetAndDelete(v2, CFSTR("externalDevices"));
    if (v5)
    {
      v6 = v5;
      DeviceList::FromPList((MIDISetup *)((char *)this + 136), v5);
      CFRelease(v6);
    }
    v7 = (const __CFArray *)DictGetAndDelete(v2, CFSTR("thruConnections"));
    if (v7)
    {
      v8 = v7;
      Count = CFArrayGetCount(v7);
      v10 = *((_QWORD *)this + 23);
      v11 = (*((_QWORD *)this + 24) - v10) >> 3;
      v12 = v11 + Count;
      if (v12 > (*((_QWORD *)this + 25) - v10) >> 3)
      {
        if (v12 >> 61)
LABEL_40:
          std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
        v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v12);
        v14 = &v13[8 * v11];
        v16 = &v13[8 * v15];
        v18 = (char *)*((_QWORD *)this + 23);
        v17 = (char *)*((_QWORD *)this + 24);
        v19 = v14;
        if (v17 != v18)
        {
          do
          {
            v20 = *((_QWORD *)v17 - 1);
            v17 -= 8;
            *((_QWORD *)v19 - 1) = v20;
            v19 -= 8;
          }
          while (v17 != v18);
          v17 = (char *)*((_QWORD *)this + 23);
        }
        *((_QWORD *)this + 23) = v19;
        *((_QWORD *)this + 24) = v14;
        *((_QWORD *)this + 25) = v16;
        if (v17)
          operator delete(v17);
      }
      v42 = v2;
      if (Count >= 1)
      {
        for (i = 0; i != Count; ++i)
        {
          ValueAtIndex = (__CFDictionary *)CFArrayGetValueAtIndex(v8, i);
          v23 = operator new();
          BaseOpaqueObject::BaseOpaqueObject((BaseOpaqueObject *)v23);
          *(_QWORD *)v23 = &off_1E98B9618;
          *(_QWORD *)(v23 + 16) = 0;
          *(_BYTE *)(v23 + 24) = 1;
          *(_QWORD *)(v23 + 40) = 0;
          *(_QWORD *)(v23 + 48) = 0;
          *(_QWORD *)(v23 + 32) = 0;
          *(_BYTE *)(v23 + 56) = 1;
          MIDI::StreamState::StreamState((MIDI::StreamState *)(v23 + 72), 0);
          MIDI::StreamState::StreamState((MIDI::StreamState *)(v23 + 7240), 0);
          *(_DWORD *)(v23 + 14408) = 0;
          *(_BYTE *)(v23 + 14412) = 0;
          if (ValueAtIndex
            && (v24 = DictGetAndDelete(ValueAtIndex, CFSTR("owner")),
                XCFObject<__CFString const*>::Set(v23 + 16, v24),
                v25 = (const __CFData *)DictGetAndDelete(ValueAtIndex, CFSTR("data")),
                (unint64_t)CFDataGetLength(v25) >= 0xCC))
          {
            BytePtr = CFDataGetBytePtr(v25);
            for (j = 0; j != 64; j += 8)
            {
              v28 = &BytePtr[j];
              *((_DWORD *)v28 + 2) = 0;
              *((_DWORD *)v28 + 19) = 0;
            }
            MIDIConnection::SetParams((MIDIConnection *)v23, 0, v25);
            v30 = (uint64_t *)*((_QWORD *)this + 24);
            v29 = *((_QWORD *)this + 25);
            if ((unint64_t)v30 >= v29)
            {
              v32 = *((_QWORD *)this + 23);
              v33 = ((uint64_t)v30 - v32) >> 3;
              if ((unint64_t)(v33 + 1) >> 61)
                goto LABEL_40;
              v34 = v29 - v32;
              v35 = v34 >> 2;
              if (v34 >> 2 <= (unint64_t)(v33 + 1))
                v35 = v33 + 1;
              if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF8)
                v36 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v36 = v35;
              if (v36)
                v36 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v36);
              else
                v37 = 0;
              v38 = (uint64_t *)(v36 + 8 * v33);
              *v38 = v23;
              v31 = v38 + 1;
              v40 = (char *)*((_QWORD *)this + 23);
              v39 = (char *)*((_QWORD *)this + 24);
              if (v39 != v40)
              {
                do
                {
                  v41 = *((_QWORD *)v39 - 1);
                  v39 -= 8;
                  *--v38 = v41;
                }
                while (v39 != v40);
                v39 = (char *)*((_QWORD *)this + 23);
              }
              *((_QWORD *)this + 23) = v38;
              *((_QWORD *)this + 24) = v31;
              *((_QWORD *)this + 25) = v36 + 8 * v37;
              if (v39)
                operator delete(v39);
            }
            else
            {
              *v30 = v23;
              v31 = v30 + 1;
            }
            *((_QWORD *)this + 24) = v31;
          }
          else
          {
            (*(void (**)(uint64_t))(*(_QWORD *)v23 + 8))(v23);
          }
        }
      }
      CFRelease(v8);
      v2 = v42;
    }
    MIDIObject::FromDictionary(this, v2);
  }
}

void SetupManager::SchedulePrefSaver(SetupManager *this)
{
  __CFRunLoopTimer *v1;
  CFAbsoluteTime Current;

  if (!*((_BYTE *)this + 83))
  {
    *((_BYTE *)this + 83) = 1;
    v1 = (__CFRunLoopTimer *)*((_QWORD *)this + 12);
    Current = CFAbsoluteTimeGetCurrent();
    CFRunLoopTimerSetNextFireDate(v1, Current + 3.0);
  }
}

void MIDISetup::CheckWritePrefFile(MIDISetup *this)
{
  const __CFString *v1;
  int v2;
  CFStringRef *v3;
  CFStringRef *v4;
  NSObject *v6;
  const void *v7;
  CFDataRef Data;
  SetupManager *v9;
  const char *v10;
  NSObject *v11;
  const void *v12;
  const __CFString *v13;
  const __CFString *v14;
  SetupManager *v15;
  NSObject *v16;
  _BOOL8 v17;
  NSObject *v18;
  int v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  uint8_t *v24;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  const __CFString *v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v1 = (const __CFString *)*((_QWORD *)this + 26);
  v2 = *((unsigned __int8 *)this + 217);
  v3 = (CFStringRef *)MEMORY[0x1E0C9B260];
  v4 = (CFStringRef *)MEMORY[0x1E0C9B250];
  if (!*((_BYTE *)this + 217))
  {
    if (!*(_BYTE *)(SetupManager::instance(this) + 81))
      return;
    goto LABEL_15;
  }
  if (CFStringGetLength(*((CFStringRef *)this + 26)))
  {
    MIDIConfigGetFullPathToFile(v1, (char *)buf);
    gMIDISetup();
    v6 = gMIDISetup(void)::midiso;
    if (os_log_type_enabled((os_log_t)gMIDISetup(void)::midiso, OS_LOG_TYPE_DEBUG))
    {
      v19 = 136315650;
      v20 = "MIDISetup.cpp";
      v21 = 1024;
      v22 = 846;
      v23 = 2080;
      v24 = buf;
      _os_log_impl(&dword_1D4E88000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d Writing %s...", (uint8_t *)&v19, 0x1Cu);
    }
    v7 = (const void *)(*(uint64_t (**)(MIDISetup *))(*(_QWORD *)this + 56))(this);
    Data = CFPropertyListCreateData(0, v7, kCFPropertyListXMLFormat_v1_0, 0, 0);
    CFRelease(v7);
    if (WriteFileFromCFData((const char *)buf, Data))
    {
      CFRelease(Data);
      *(_BYTE *)(SetupManager::instance(v9) + 81) = 1;
      v10 = "success";
    }
    else
    {
      if (Data)
        CFRelease(Data);
      v10 = "failed";
    }
    gMIDISetup();
    v11 = gMIDISetup(void)::midiso;
    if (os_log_type_enabled((os_log_t)gMIDISetup(void)::midiso, OS_LOG_TYPE_DEBUG))
    {
      v19 = 136315650;
      v20 = "MIDISetup.cpp";
      v21 = 1024;
      v22 = 858;
      v23 = 2080;
      v24 = (uint8_t *)v10;
      _os_log_impl(&dword_1D4E88000, v11, OS_LOG_TYPE_DEBUG, "%25s:%-5d -> %s", (uint8_t *)&v19, 0x1Cu);
    }
  }
  v12 = (const void *)(*(uint64_t (**)(MIDISetup *))(*(_QWORD *)this + 56))(this);
  v13 = *v3;
  v14 = *v4;
  CFPreferencesSetValue(CFSTR("MIDISetup"), v12, CFSTR("com.apple.MIDI"), *v3, *v4);
  CFRelease(v12);
  *((_BYTE *)this + 217) = 0;
  if (*(_BYTE *)(SetupManager::instance(v15) + 81))
  {
LABEL_15:
    if (CFStringGetLength(v1))
    {
      v13 = *v3;
      v14 = *v4;
      CFPreferencesSetValue(CFSTR("CurrentSetupFilename"), v1, CFSTR("com.apple.MIDI"), *v3, *v4);
      gMIDISetup();
      v16 = gMIDISetup(void)::midiso;
      v17 = os_log_type_enabled((os_log_t)gMIDISetup(void)::midiso, OS_LOG_TYPE_DEBUG);
      if (v17)
      {
        *(_DWORD *)buf = 136315650;
        v26 = "MIDISetup.cpp";
        v27 = 1024;
        v28 = 876;
        v29 = 2112;
        v30 = v1;
        _os_log_impl(&dword_1D4E88000, v16, OS_LOG_TYPE_DEBUG, "%25s:%-5d Set current document to %@", buf, 0x1Cu);
      }
      *(_BYTE *)(SetupManager::instance((SetupManager *)v17) + 81) = 0;
    }
    else
    {
      *(_BYTE *)(SetupManager::instance(0) + 81) = 0;
      if (!v2)
        return;
      v13 = *v3;
      v14 = *v4;
    }
  }
  CFPreferencesSynchronize(CFSTR("com.apple.MIDI"), v13, v14);
  gMIDISetup();
  v18 = gMIDISetup(void)::midiso;
  if (os_log_type_enabled((os_log_t)gMIDISetup(void)::midiso, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136315394;
    v26 = "MIDISetup.cpp";
    v27 = 1024;
    v28 = 885;
    _os_log_impl(&dword_1D4E88000, v18, OS_LOG_TYPE_DEBUG, "%25s:%-5d Synchronized prefs", buf, 0x12u);
  }
}

void gMIDISetup(void)
{
  unsigned __int8 v0;

  if ((v0 & 1) == 0)
  {
    {
      gMIDISetup(void)::midiso = (uint64_t)os_log_create("com.apple.coremidi", "midiso");
    }
  }
}

_QWORD *OwnedPtrVector<MIDIConnection *>::~OwnedPtrVector(_QWORD *a1)
{
  char *v2;
  char *v3;
  char *v4;
  _BYTE *v5;
  uint64_t v6;
  char *v7;

  *a1 = &off_1E98B97D0;
  v2 = (char *)a1[1];
  v3 = (char *)a1[2];
  if (v2 != v3)
  {
    v4 = (char *)a1[1];
    do
    {
      if (*(_QWORD *)v4)
        (*(void (**)(_QWORD))(**(_QWORD **)v4 + 8))(*(_QWORD *)v4);
      v4 += 8;
    }
    while (v4 != v3);
    v5 = (_BYTE *)a1[2];
    v6 = v5 - v3;
    if (v5 != v3)
      memmove(v2, v3, v5 - v3);
    v7 = (char *)a1[1];
    a1[2] = &v2[v6];
    v2 = v7;
  }
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void MIDISetup::DeviceRemoveEffects(MIDISetup *this, MIDIDevice *a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v4 = *((_QWORD *)a2 + 11) - *((_QWORD *)a2 + 10);
  if ((int)(v4 >> 3) >= 1)
  {
    v5 = 0;
    v6 = v4 & 0x7FFFFFFF8;
    do
    {
      MIDISetup::EntityRemoveEffects(this, *(MIDIEntity **)(*((_QWORD *)a2 + 10) + v5));
      v5 += 8;
    }
    while (v6 != v5);
  }
  MIDISetup::ObjectRemoved(this, a2);
}

void MIDISetup::ObjectRemoved(MIDISetup *this, MIDIObject *a2)
{
  _DWORD *v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  int v11;

  if (!*(_BYTE *)(SetupManager::instance(this) + 80) && (!*((_BYTE *)a2 + 41) || *((_BYTE *)a2 + 40)))
  {
    *((_WORD *)a2 + 20) = 256;
    v4 = (_DWORD *)*((_QWORD *)a2 + 2);
    v7 = 0x1800000003;
    if (v4)
    {
      v8 = v4[2];
      v5 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v4 + 72))(v4);
    }
    else
    {
      v8 = 0;
      v5 = -1;
    }
    v6 = *((_DWORD *)a2 + 2);
    v9 = v5;
    v10 = v6;
    v11 = (*(uint64_t (**)(MIDIObject *))(*(_QWORD *)a2 + 72))(a2);
    MIDISetup::GenerateNotification(this, (uint64_t)&v7);
  }
}

void MIDISetup::EntityRemoveEffects(MIDISetup *this, MIDIEntity *a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  MIDIObject *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  MIDIObject *v11;

  v4 = *((_QWORD *)a2 + 10) - *((_QWORD *)a2 + 9);
  if ((int)(v4 >> 3) >= 1)
  {
    v5 = 0;
    v6 = v4 & 0x7FFFFFFF8;
    do
    {
      v7 = *(MIDIObject **)(*((_QWORD *)a2 + 9) + v5);
      remove<std::vector<MIDISource *>,MIDISource *>((_QWORD *)this + 11, (uint64_t)v7);
      MIDISetup::ObjectRemoved(this, v7);
      v5 += 8;
    }
    while (v6 != v5);
  }
  v8 = *((_QWORD *)a2 + 14) - *((_QWORD *)a2 + 13);
  if ((int)(v8 >> 3) >= 1)
  {
    v9 = 0;
    v10 = v8 & 0x7FFFFFFF8;
    do
    {
      v11 = *(MIDIObject **)(*((_QWORD *)a2 + 13) + v9);
      remove<std::vector<MIDISource *>,MIDISource *>((_QWORD *)this + 14, (uint64_t)v11);
      MIDISetup::ObjectRemoved(this, v11);
      v9 += 8;
    }
    while (v10 != v9);
  }
  MIDISetup::ObjectRemoved(this, a2);
}

void MIDISetup::GenerateNotification(SetupManager *a1, uint64_t a2)
{
  SetupManager *v4;
  uint64_t v5;
  SetupManager *v6;
  SetupManager *v7;

  if (!*((_BYTE *)a1 + 216))
  {
    v4 = (SetupManager *)SetupManager::instance(a1);
    if (*(SetupManager **)v4 == a1 || (v4 = (SetupManager *)SetupManager::instance(v4), !*(_QWORD *)v4))
    {
      v5 = SetupManager::instance(v4);
      SetupManager::AddNotification(v5, a2);
      if (!*((_BYTE *)a1 + 218))
      {
        *((_BYTE *)a1 + 217) = 1;
        v7 = (SetupManager *)SetupManager::instance(v6);
        SetupManager::SchedulePrefSaver(v7);
      }
    }
  }
}

void SetupManager::AddNotification(uint64_t a1, uint64_t a2)
{
  _OWORD *v4;
  uint64_t v5;
  __CFRunLoopTimer *v6;
  CFAbsoluteTime Current;

  if (!*(_BYTE *)(a1 + 80))
  {
    v4 = operator new(0x28uLL);
    v4[1] = *(_OWORD *)a2;
    *((_QWORD *)v4 + 4) = *(_QWORD *)(a2 + 16);
    v5 = *(_QWORD *)(a1 + 56);
    *(_QWORD *)v4 = v5;
    *((_QWORD *)v4 + 1) = a1 + 56;
    *(_QWORD *)(v5 + 8) = v4;
    *(_QWORD *)(a1 + 56) = v4;
    ++*(_QWORD *)(a1 + 72);
    if (!*(_BYTE *)(a1 + 82))
    {
      *(_BYTE *)(a1 + 82) = 1;
      v6 = *(__CFRunLoopTimer **)(a1 + 88);
      Current = CFAbsoluteTimeGetCurrent();
      CFRunLoopTimerSetNextFireDate(v6, Current + 0.25);
    }
  }
}

void OwnedPtrVector<MIDIConnection *>::~OwnedPtrVector(_QWORD *a1)
{
  OwnedPtrVector<MIDIConnection *>::~OwnedPtrVector(a1);
  JUMPOUT(0x1D826BA98);
}

void DeviceList::~DeviceList(DeviceList *this)
{
  void *v2;

  v2 = (void *)*((_QWORD *)this + 2);
  if (v2)
  {
    *((_QWORD *)this + 3) = v2;
    operator delete(v2);
  }
  BaseOpaqueObject::~BaseOpaqueObject(this);
}

{
  void *v2;

  v2 = (void *)*((_QWORD *)this + 2);
  if (v2)
  {
    *((_QWORD *)this + 3) = v2;
    operator delete(v2);
  }
  BaseOpaqueObject::~BaseOpaqueObject(this);
  JUMPOUT(0x1D826BA98);
}

void MIDISetup::ThruConnectionList::~ThruConnectionList(MIDISetup::ThruConnectionList *this)
{
  OwnedPtrVector<MIDIConnection *>::~OwnedPtrVector(this);
  JUMPOUT(0x1D826BA98);
}

void MIDISetup::MIDISetup(MIDISetup *this)
{
  uint64_t v2;

  BaseOpaqueObject::BaseOpaqueObject(this);
  *(_QWORD *)(v2 + 16) = 0;
  *(_QWORD *)(v2 + 24) = 0;
  *(_WORD *)(v2 + 32) = 1;
  *(_WORD *)(v2 + 40) = 0;
  *(_QWORD *)v2 = &off_1E98B9AD8;
  BaseOpaqueObject::BaseOpaqueObject((BaseOpaqueObject *)(v2 + 48));
  *(_OWORD *)((char *)this + 88) = 0u;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 6) = &off_1E98B91D0;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  BaseOpaqueObject::BaseOpaqueObject((MIDISetup *)((char *)this + 136));
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 17) = &off_1E98B91D0;
  *((_QWORD *)this + 23) = 0;
  *((_QWORD *)this + 24) = 0;
  *((_QWORD *)this + 21) = 0;
  *((_QWORD *)this + 22) = &off_1E98B9EF8;
  *((_QWORD *)this + 25) = 0;
  *((_QWORD *)this + 26) = &stru_1E98BB0B0;
  *((_WORD *)this + 108) = 0;
  *((_BYTE *)this + 218) = 0;
}

void sub_1D4ED92F0(_Unwind_Exception *a1)
{
  BaseOpaqueObject *v1;
  BaseOpaqueObject *v2;
  void **v3;
  void **v4;
  void *v6;
  void *v7;
  void *v8;

  v6 = (void *)*((_QWORD *)v1 + 14);
  if (v6)
  {
    *((_QWORD *)v1 + 15) = v6;
    operator delete(v6);
  }
  v7 = *v4;
  if (*v4)
  {
    *((_QWORD *)v1 + 12) = v7;
    operator delete(v7);
  }
  v8 = *v3;
  if (*v3)
  {
    *((_QWORD *)v1 + 9) = v8;
    operator delete(v8);
  }
  BaseOpaqueObject::~BaseOpaqueObject(v2);
  *(_QWORD *)v1 = off_1E98B9320;
  XCFObject<__CFDictionary const*>::~XCFObject((uint64_t)v1 + 24);
  BaseOpaqueObject::~BaseOpaqueObject(v1);
  _Unwind_Resume(a1);
}

void MIDISetup::ScanForDriverDevices(MIDISetup *this)
{
  MIDIDevice **v2;
  MIDIDevice **v3;
  uint64_t v4;
  MIDIServer *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  MIDIDevice **v10;
  void (**v11)(DeviceList *__hidden);
  unsigned int v12;
  MIDIDevice **v13;
  MIDIDevice **v14;
  uint64_t v15;

  v3 = (MIDIDevice **)*((_QWORD *)this + 8);
  v2 = (MIDIDevice **)*((_QWORD *)this + 9);
  if (v3 != v2)
  {
    while (1)
    {
      v4 = *((_QWORD *)*v3 + 8);
      if (!v4)
        break;
      if (*(_DWORD *)(v4 + 64) != 1)
        goto LABEL_6;
      MIDISetup::RemoveDevice(this, *v3);
      v3 = (MIDIDevice **)*((_QWORD *)this + 8);
      v2 = (MIDIDevice **)*((_QWORD *)this + 9);
LABEL_7:
      if (v3 == v2)
        goto LABEL_8;
    }
    MIDIObject::SetProperty(*v3, kMIDIPropertyOffline, 1);
    v2 = (MIDIDevice **)*((_QWORD *)this + 9);
LABEL_6:
    ++v3;
    goto LABEL_7;
  }
LABEL_8:
  BaseOpaqueObject::BaseOpaqueObject((BaseOpaqueObject *)&v11);
  v14 = 0;
  v15 = 0;
  v13 = 0;
  v11 = &off_1E98B91D0;
  v6 = MIDIServer::defaultInstance(v5)[33];
  v7 = *(_QWORD **)(v6 + 16);
  v8 = *(_QWORD **)(v6 + 24);
  if (v7 != v8)
  {
    v9 = v12;
    do
    {
      if (*(_DWORD *)(*v7 + 64) == 1)
        (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v7 + 80))(*v7, v9);
      ++v7;
    }
    while (v7 != v8);
  }
  v10 = v13;
  if (v13 != v14)
  {
    do
      MIDISetup::AddDevice(this, *v10++);
    while (v10 != v14);
    v10 = v13;
  }
  if (v10)
  {
    v14 = v10;
    operator delete(v10);
  }
  BaseOpaqueObject::~BaseOpaqueObject((BaseOpaqueObject *)&v11);
}

void sub_1D4ED9484(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  DeviceList::~DeviceList((DeviceList *)va);
  _Unwind_Resume(a1);
}

void MIDISetup::RemoveDevice(MIDISetup *this, MIDIDevice *a2)
{
  char *v4;
  MIDIDevice **v5;
  MIDIDevice **v6;
  int64_t v7;

  if (*((_QWORD *)a2 + 6))
    v4 = (char *)this + 48;
  else
    v4 = (char *)this + 136;
  v6 = (MIDIDevice **)*((_QWORD *)v4 + 2);
  v5 = (MIDIDevice **)*((_QWORD *)v4 + 3);
  if (v6 != v5)
  {
    while (*v6 != a2)
    {
      if (++v6 == v5)
      {
        v6 = (MIDIDevice **)*((_QWORD *)v4 + 3);
        break;
      }
    }
  }
  if (v6 != v5)
  {
    v7 = (char *)v5 - (char *)(v6 + 1);
    if (v5 != v6 + 1)
      memmove(v6, v6 + 1, (char *)v5 - (char *)(v6 + 1));
    *((_QWORD *)v4 + 3) = (char *)v6 + v7;
    MIDISetup::DeviceRemoveEffects(this, a2);
    if (a2)
      (*(void (**)(MIDIDevice *))(*(_QWORD *)a2 + 8))(a2);
  }
}

void MIDISetup::AddDevice(MIDISetup *this, MIDIDevice *a2)
{
  _QWORD *v4;
  MIDIDevice **v5;
  MIDIDevice **v6;
  MIDIDevice **v7;
  unint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  unint64_t v16;
  char *v17;
  char *v18;
  uint64_t v19;

  if (*((_QWORD *)a2 + 6))
    v4 = (_QWORD *)((char *)this + 48);
  else
    v4 = (_QWORD *)((char *)this + 136);
  v5 = (MIDIDevice **)v4[2];
  v6 = (MIDIDevice **)v4[3];
  v7 = v5;
  if (v5 != v6)
  {
    while (*v7 != a2)
    {
      if (++v7 == v6)
      {
        v7 = (MIDIDevice **)v4[3];
        break;
      }
    }
  }
  if (v7 == v6)
  {
    v8 = v4[4];
    if ((unint64_t)v6 >= v8)
    {
      v10 = v6 - v5;
      if ((unint64_t)(v10 + 1) >> 61)
        std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
      v11 = v8 - (_QWORD)v5;
      v12 = v11 >> 2;
      if (v11 >> 2 <= (unint64_t)(v10 + 1))
        v12 = v10 + 1;
      if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
        v13 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v13 = v12;
      if (v13)
        v13 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v13);
      else
        v14 = 0;
      v15 = (_QWORD *)(v13 + 8 * v10);
      v16 = v13 + 8 * v14;
      *v15 = a2;
      v9 = v15 + 1;
      v18 = (char *)v4[2];
      v17 = (char *)v4[3];
      if (v17 != v18)
      {
        do
        {
          v19 = *((_QWORD *)v17 - 1);
          v17 -= 8;
          *--v15 = v19;
        }
        while (v17 != v18);
        v17 = (char *)v4[2];
      }
      v4[2] = v15;
      v4[3] = v9;
      v4[4] = v16;
      if (v17)
        operator delete(v17);
    }
    else
    {
      *v6 = a2;
      v9 = v6 + 1;
    }
    v4[3] = v9;
    MIDISetup::DeviceAddEffects(this, a2, 0);
  }
}

void MIDISetup::DeviceAddEffects(MIDISetup *this, MIDIDevice *a2, char a3)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;

  MIDISetup::AssignUniqueID(this, a2);
  MIDISetup::ObjectAdded(this, a2);
  v6 = *((_QWORD *)a2 + 11) - *((_QWORD *)a2 + 10);
  if ((int)(v6 >> 3) >= 1)
  {
    v7 = 0;
    v8 = v6 & 0x7FFFFFFF8;
    do
    {
      MIDISetup::EntityAddEffects((MIDIConnection ***)this, *(MIDIEntity **)(*((_QWORD *)a2 + 10) + v7), a3);
      v7 += 8;
    }
    while (v8 != v7);
  }
}

uint64_t MIDISetup::AssignUniqueID(MIDISetup *this, MIDIObject *a2)
{
  int IntegerProperty;
  unsigned int v5;
  int v6;
  int v7;
  MIDIObject *ObjectByUniqueID;
  uint64_t result;
  BOOL v10;
  char v11;
  int v12;
  int v13;

  v12 = 0;
  IntegerProperty = MIDIObject::GetIntegerProperty(a2, kMIDIPropertyUniqueID, &v12);
  v5 = v12;
  if (IntegerProperty)
    v5 = 0;
  if (!v5)
  {
    v6 = rand();
    v5 = v6 ^ (2 * rand());
  }
  do
  {
    if (v5 <= 1)
      v7 = 1;
    else
      v7 = v5;
    ObjectByUniqueID = MIDISetup::FindObjectByUniqueID(this, v7, a2);
    v5 = v7 + 1;
  }
  while (ObjectByUniqueID);
  v13 = 0;
  result = MIDIObject::GetIntegerProperty(a2, kMIDIPropertyUniqueID, &v13);
  if ((_DWORD)result)
    v10 = 0;
  else
    v10 = v13 == v7;
  if (!v10)
  {
    v11 = *((_BYTE *)this + 218);
    *((_BYTE *)this + 218) = 0;
    result = MIDIObject::SetProperty(a2, kMIDIPropertyUniqueID, v7);
    *((_BYTE *)this + 218) = v11;
  }
  return result;
}

void MIDISetup::ObjectAdded(MIDISetup *this, MIDIObject *a2)
{
  _DWORD *v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  int v11;

  if (!*(_BYTE *)(SetupManager::instance(this) + 80) && (!*((_BYTE *)a2 + 40) || *((_BYTE *)a2 + 41)))
  {
    *((_WORD *)a2 + 20) = 1;
    v4 = (_DWORD *)*((_QWORD *)a2 + 2);
    v7 = 0x1800000002;
    if (v4)
    {
      v8 = v4[2];
      v5 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v4 + 72))(v4);
    }
    else
    {
      v8 = 0;
      v5 = -1;
    }
    v6 = *((_DWORD *)a2 + 2);
    v9 = v5;
    v10 = v6;
    v11 = (*(uint64_t (**)(MIDIObject *))(*(_QWORD *)a2 + 72))(a2);
    MIDISetup::GenerateNotification(this, (uint64_t)&v7);
  }
}

void MIDISetup::EntityAddEffects(MIDIConnection ***this, MIDIEntity *a2, char a3)
{
  MIDIObject *v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  char v9;
  uint64_t v10;
  MIDIObject *v11;
  MIDIConnection **v12;
  MIDIObject **v13;
  MIDIObject **v14;
  unint64_t v15;
  MIDIConnection **v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  MIDIObject **v22;
  MIDIConnection **v23;
  MIDIConnection **v24;
  MIDIObject *v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  MIDIObject *v29;
  MIDIConnection **v30;
  MIDIObject **v31;
  MIDIObject **v32;
  unint64_t v33;
  MIDIConnection **v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  MIDIObject **v40;
  MIDIConnection **v41;
  MIDIConnection **v42;
  MIDIObject *v43;
  MIDIConnection **i;
  MIDIConnection *v45;
  int v47;

  v47 = 0;
  v5 = (MIDIObject *)*((_QWORD *)a2 + 6);
  v6 = *((_QWORD *)v5 + 6);
  if (MIDIObject::GetIntegerProperty(v5, kMIDIPropertyAdvanceScheduleTimeMuSec, &v47))
    v47 = 0;
  MIDISetup::AssignUniqueID((MIDISetup *)this, a2);
  MIDISetup::ObjectAdded((MIDISetup *)this, a2);
  v7 = *((_QWORD *)a2 + 10) - *((_QWORD *)a2 + 9);
  if ((int)(v7 >> 3) < 1)
  {
    v9 = 0;
  }
  else
  {
    v8 = 0;
    v9 = 0;
    v10 = (v7 >> 3);
    do
    {
      v11 = *(MIDIObject **)(*((_QWORD *)a2 + 9) + 8 * v8);
      if (v6)
      {
        v12 = this[11];
        v13 = this[12];
        v14 = v12;
        if (v12 != v13)
        {
          while (*v14 != v11)
          {
            if (++v14 == v13)
            {
              v14 = this[12];
              break;
            }
          }
        }
        if (v14 == v13)
        {
          v15 = (unint64_t)this[13];
          if ((unint64_t)v13 >= v15)
          {
            v17 = v13 - v12;
            if ((unint64_t)(v17 + 1) >> 61)
              std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
            v18 = v15 - (_QWORD)v12;
            v19 = v18 >> 2;
            if (v18 >> 2 <= (unint64_t)(v17 + 1))
              v19 = v17 + 1;
            if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8)
              v20 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v20 = v19;
            if (v20)
              v20 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v20);
            else
              v21 = 0;
            v22 = (MIDIObject **)(v20 + 8 * v17);
            *v22 = v11;
            v16 = v22 + 1;
            v24 = this[11];
            v23 = this[12];
            if (v23 != v24)
            {
              do
              {
                v25 = *--v23;
                *--v22 = v25;
              }
              while (v23 != v24);
              v23 = this[11];
            }
            this[11] = v22;
            this[12] = v16;
            this[13] = (MIDIConnection **)(v20 + 8 * v21);
            if (v23)
              operator delete(v23);
          }
          else
          {
            *v13 = v11;
            v16 = v13 + 1;
          }
          this[12] = v16;
          v9 = 1;
        }
      }
      MIDISetup::AssignUniqueID((MIDISetup *)this, v11);
      MIDISetup::ObjectAdded((MIDISetup *)this, v11);
      ++v8;
    }
    while (v8 != v10);
  }
  v26 = *((_QWORD *)a2 + 14) - *((_QWORD *)a2 + 13);
  if ((int)(v26 >> 3) >= 1)
  {
    v27 = 0;
    v28 = (v26 >> 3);
    do
    {
      v29 = *(MIDIObject **)(*((_QWORD *)a2 + 13) + 8 * v27);
      if (v6)
      {
        v30 = this[14];
        v31 = this[15];
        v32 = v30;
        if (v30 != v31)
        {
          while (*v32 != v29)
          {
            if (++v32 == v31)
            {
              v32 = this[15];
              break;
            }
          }
        }
        if (v32 == v31)
        {
          v33 = (unint64_t)this[16];
          if ((unint64_t)v31 >= v33)
          {
            v35 = v31 - v30;
            if ((unint64_t)(v35 + 1) >> 61)
              std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
            v36 = v33 - (_QWORD)v30;
            v37 = v36 >> 2;
            if (v36 >> 2 <= (unint64_t)(v35 + 1))
              v37 = v35 + 1;
            if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF8)
              v38 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v38 = v37;
            if (v38)
              v38 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v38);
            else
              v39 = 0;
            v40 = (MIDIObject **)(v38 + 8 * v35);
            *v40 = v29;
            v34 = v40 + 1;
            v42 = this[14];
            v41 = this[15];
            if (v41 != v42)
            {
              do
              {
                v43 = *--v41;
                *--v40 = v43;
              }
              while (v41 != v42);
              v41 = this[14];
            }
            this[14] = v40;
            this[15] = v34;
            this[16] = (MIDIConnection **)(v38 + 8 * v39);
            if (v41)
              operator delete(v41);
          }
          else
          {
            *v31 = v29;
            v34 = v31 + 1;
          }
          this[15] = v34;
          v9 = 1;
        }
      }
      MIDISetup::AssignUniqueID((MIDISetup *)this, v29);
      *((_DWORD *)v29 + 217) = v47;
      MIDISetup::ObjectAdded((MIDISetup *)this, v29);
      ++v27;
    }
    while (v27 != v28);
  }
  if ((v9 & 1) != 0 && (a3 & 1) == 0)
  {
    for (i = this[23]; i != this[24]; ++i)
    {
      v45 = *i;
      MIDIConnection::MaintainEndpoints(v45, (MIDISetup *)this);
    }
  }
}

MIDIObject *MIDISetup::FindObjectByUniqueID(MIDISetup *this, int a2, MIDIObject *a3)
{
  MIDIObject *ObjectInDeviceListByUniqueID;
  SetupManager *IntegerProperty;
  MIDIObject **v8;
  MIDIObject **v9;
  SetupManager *v10;
  int v11;
  uint64_t v12;
  MIDIObject **v13;
  MIDIObject **v14;
  uint64_t v15;
  int v16;
  int v17;
  int v19;
  int v20;

  ObjectInDeviceListByUniqueID = MIDISetup::FindObjectInDeviceListByUniqueID((uint64_t)this + 48, a2, a3);
  if (!ObjectInDeviceListByUniqueID)
  {
    ObjectInDeviceListByUniqueID = MIDISetup::FindObjectInDeviceListByUniqueID((uint64_t)this + 136, a2, a3);
    if (!ObjectInDeviceListByUniqueID)
    {
      IntegerProperty = (SetupManager *)SetupManager::instance(0);
      v9 = (MIDIObject **)*((_QWORD *)IntegerProperty + 1);
      v8 = (MIDIObject **)*((_QWORD *)IntegerProperty + 2);
      if (v9 != v8)
      {
        v10 = IntegerProperty;
        do
        {
          ObjectInDeviceListByUniqueID = *v9;
          if (*v9 != a3)
          {
            v19 = 0;
            IntegerProperty = (SetupManager *)MIDIObject::GetIntegerProperty(ObjectInDeviceListByUniqueID, kMIDIPropertyUniqueID, &v19);
            v11 = v19;
            if ((_DWORD)IntegerProperty)
              v11 = 0;
            if (v11 == a2)
              return ObjectInDeviceListByUniqueID;
            v8 = (MIDIObject **)*((_QWORD *)v10 + 2);
          }
          ++v9;
        }
        while (v9 != v8);
      }
      v12 = SetupManager::instance(IntegerProperty);
      v14 = *(MIDIObject ***)(v12 + 32);
      v13 = *(MIDIObject ***)(v12 + 40);
      if (v14 != v13)
      {
        v15 = v12;
        do
        {
          ObjectInDeviceListByUniqueID = *v14;
          if (*v14 != a3)
          {
            v20 = 0;
            v16 = MIDIObject::GetIntegerProperty(ObjectInDeviceListByUniqueID, kMIDIPropertyUniqueID, &v20);
            v17 = v20;
            if (v16)
              v17 = 0;
            if (v17 == a2)
              return ObjectInDeviceListByUniqueID;
            v13 = *(MIDIObject ***)(v15 + 40);
          }
          ++v14;
        }
        while (v14 != v13);
      }
      return 0;
    }
  }
  return ObjectInDeviceListByUniqueID;
}

MIDIObject *MIDISetup::FindObjectInDeviceListByUniqueID(uint64_t a1, int a2, MIDIObject *a3)
{
  MIDIObject **v3;
  MIDIObject *v6;
  int IntegerProperty;
  int v8;
  unint64_t v9;
  uint64_t v10;
  MIDIObject *v11;
  int v12;
  int v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  MIDIObject *v17;
  int v18;
  int v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  uint64_t v27;
  int v28;

  v3 = *(MIDIObject ***)(a1 + 16);
  if (v3 == *(MIDIObject ***)(a1 + 24))
    return 0;
  while (1)
  {
    v6 = *v3;
    if (*v3 != a3)
    {
      v28 = 0;
      IntegerProperty = MIDIObject::GetIntegerProperty(v6, kMIDIPropertyUniqueID, &v28);
      v8 = v28;
      if (IntegerProperty)
        v8 = 0;
      if (v8 == a2)
        return v6;
    }
    v9 = *((_QWORD *)v6 + 11) - *((_QWORD *)v6 + 10);
    if ((int)(v9 >> 3) >= 1)
      break;
LABEL_27:
    if (++v3 == *(MIDIObject ***)(a1 + 24))
      return 0;
  }
  v10 = 0;
  v27 = (v9 >> 3);
  while (1)
  {
    v11 = *(MIDIObject **)(*((_QWORD *)v6 + 10) + 8 * v10);
    if (v11 != a3)
    {
      v28 = 0;
      v12 = MIDIObject::GetIntegerProperty(v11, kMIDIPropertyUniqueID, &v28);
      v13 = v28;
      if (v12)
        v13 = 0;
      if (v13 == a2)
        return v11;
    }
    v14 = *((_QWORD *)v11 + 10) - *((_QWORD *)v11 + 9);
    if ((int)(v14 >> 3) >= 1)
      break;
LABEL_19:
    v20 = *((_QWORD *)v11 + 14) - *((_QWORD *)v11 + 13);
    if ((int)(v20 >> 3) >= 1)
    {
      v21 = 0;
      v22 = v20 & 0x7FFFFFFF8;
      do
      {
        v17 = *(MIDIObject **)(*((_QWORD *)v11 + 13) + v21);
        if (v17 != a3)
        {
          v28 = 0;
          v23 = MIDIObject::GetIntegerProperty(v17, kMIDIPropertyUniqueID, &v28);
          v24 = v28;
          if (v23)
            v24 = 0;
          if (v24 == a2)
            return v17;
        }
        v21 += 8;
      }
      while (v22 != v21);
    }
    if (++v10 == v27)
      goto LABEL_27;
  }
  v15 = 0;
  v16 = v14 & 0x7FFFFFFF8;
  while (1)
  {
    v17 = *(MIDIObject **)(*((_QWORD *)v11 + 9) + v15);
    if (v17 != a3)
    {
      v28 = 0;
      v18 = MIDIObject::GetIntegerProperty(v17, kMIDIPropertyUniqueID, &v28);
      v19 = v28;
      if (v18)
        v19 = 0;
      if (v19 == a2)
        return v17;
    }
    v15 += 8;
    if (v16 == v15)
      goto LABEL_19;
  }
}

uint64_t MIDISetup::FromData(MIDISetup *this, const __CFData *a2)
{
  CFPropertyListRef v3;
  BOOL v4;
  CFErrorRef error;

  error = 0;
  v3 = CFPropertyListCreateWithData(0, a2, 0, 0, &error);
  if (error)
    v4 = 1;
  else
    v4 = v3 == 0;
  if (v4)
  {
    if (error)
      CFRelease(error);
    if (v3)
      CFRelease(v3);
    return 4294956456;
  }
  else
  {
    (*(void (**)(MIDISetup *, CFPropertyListRef))(*(_QWORD *)this + 64))(this, v3);
    CFRelease(v3);
    MIDISetup::CreationEffects(this);
    return 0;
  }
}

void MIDISetup::CreationEffects(MIDISetup *this)
{
  MIDIDevice **i;
  MIDIDevice **v3;
  MIDIDevice *v4;
  MIDIDevice **j;
  MIDIDevice *v6;
  MIDIConnection **k;
  MIDIConnection *v8;

  *((_BYTE *)this + 218) = 1;
  *((_QWORD *)this + 12) = *((_QWORD *)this + 11);
  *((_QWORD *)this + 15) = *((_QWORD *)this + 14);
  v3 = (MIDIDevice **)*((_QWORD *)this + 8);
  for (i = (MIDIDevice **)*((_QWORD *)this + 9); v3 != i; i = (MIDIDevice **)*((_QWORD *)this + 9))
  {
    v4 = *v3++;
    MIDISetup::DeviceAddEffects(this, v4, 1);
  }
  for (j = (MIDIDevice **)*((_QWORD *)this + 19); j != *((MIDIDevice ***)this + 20); ++j)
  {
    v6 = *j;
    MIDISetup::DeviceAddEffects(this, v6, 1);
  }
  *((_BYTE *)this + 218) = 0;
  for (k = (MIDIConnection **)*((_QWORD *)this + 23); k != *((MIDIConnection ***)this + 24); ++k)
  {
    v8 = *k;
    MIDIConnection::MaintainEndpoints(v8, this);
  }
}

_QWORD *MIDISetup::SetMIDIRunning(MIDISetup *this, int a2)
{
  char v2;
  MIDIServer *v3;
  int v4;
  MIDIServer *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *result;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;

  v2 = (char)this;
  v3 = (MIDIServer *)MIDIServer::defaultInstance(this, a2);
  if ((v2 & 1) == 0)
    return (_QWORD *)MIDIServer::defaultInstance(v3, v4);
  v5 = v3;
  v6 = *((_QWORD *)v3 + 111);
  v7 = *((_QWORD *)v3 + 112);
  if (v6 != v7)
  {
    do
    {
      UMPStream::EndpointManager::sendEndpointDiscoveryMessage((MIDIServer *)((char *)v5 + 792), *(unsigned int *)(v6 + 4));
      v6 += 8;
    }
    while (v6 != v7);
    v6 = *((_QWORD *)v5 + 111);
  }
  *((_QWORD *)v5 + 112) = v6;
  result = (_QWORD *)MIDIServer::defaultInstance(v3, v4);
  v9 = result;
  v10 = result[94];
  v11 = result[95];
  if (v10 != v11)
  {
    do
    {
      result = (_QWORD *)MIDICI::DeviceManager::sendDiscoveryInquiryMessage((MIDICI::DeviceManager *)(v9 + 78), *(unsigned int *)(v10 + 4), 0);
      v10 += 8;
    }
    while (v10 != v11);
    v10 = v9[94];
  }
  v9[95] = v10;
  return result;
}

uint64_t MIDISetup::GetDriverDevices(MIDISetup *this, MIDIDriverPlugin *a2)
{
  uint64_t v4;
  char **v5;
  uint64_t *i;
  uint64_t *v7;
  uint64_t v8;
  MIDIDriverPlugin *v9;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  char *v20;
  char *v21;
  uint64_t v22;

  v4 = operator new();
  BaseOpaqueObject::BaseOpaqueObject((BaseOpaqueObject *)v4);
  *(_QWORD *)(v4 + 16) = 0;
  v5 = (char **)(v4 + 16);
  *(_QWORD *)(v4 + 24) = 0;
  *(_QWORD *)(v4 + 32) = 0;
  *(_QWORD *)v4 = &off_1E98B91D0;
  std::vector<void const*>::reserve((void **)(v4 + 16), (uint64_t)(*((_QWORD *)this + 9) - *((_QWORD *)this + 8)) >> 3);
  v7 = (uint64_t *)*((_QWORD *)this + 8);
  for (i = (uint64_t *)*((_QWORD *)this + 9); v7 != i; ++v7)
  {
    v8 = *v7;
    if (a2)
    {
      v9 = *(MIDIDriverPlugin **)(v8 + 64);
      if (!v9 || v9 != a2)
        continue;
    }
    v12 = *(_QWORD **)(v4 + 24);
    v11 = *(_QWORD *)(v4 + 32);
    if ((unint64_t)v12 >= v11)
    {
      v14 = ((char *)v12 - *v5) >> 3;
      if ((unint64_t)(v14 + 1) >> 61)
        std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
      v15 = v11 - (_QWORD)*v5;
      v16 = v15 >> 2;
      if (v15 >> 2 <= (unint64_t)(v14 + 1))
        v16 = v14 + 1;
      if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8)
        v17 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v17 = v16;
      if (v17)
        v17 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v17);
      else
        v18 = 0;
      v19 = (_QWORD *)(v17 + 8 * v14);
      *v19 = v8;
      v13 = v19 + 1;
      v21 = *(char **)(v4 + 16);
      v20 = *(char **)(v4 + 24);
      if (v20 != v21)
      {
        do
        {
          v22 = *((_QWORD *)v20 - 1);
          v20 -= 8;
          *--v19 = v22;
        }
        while (v20 != v21);
        v20 = *v5;
      }
      *(_QWORD *)(v4 + 16) = v19;
      *(_QWORD *)(v4 + 24) = v13;
      *(_QWORD *)(v4 + 32) = v17 + 8 * v18;
      if (v20)
        operator delete(v20);
    }
    else
    {
      *v12 = v8;
      v13 = v12 + 1;
    }
    *(_QWORD *)(v4 + 24) = v13;
  }
  return v4;
}

void sub_1D4EDA218(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D826BA98](v1, 0x1081C40F159ABB6);
  _Unwind_Resume(a1);
}

MIDIServer *SetupManager::NotificationTimerCallback(MIDIServer *this, __CFRunLoopTimer *a2, void *a3)
{
  char *v4;
  _QWORD *v5;
  uint64_t *i;
  uint64_t *v7;
  uint64_t v8;
  uint64_t j;
  uint64_t v10;
  uint64_t v11;
  uint64_t *k;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v17;
  uint64_t *v18;
  _QWORD *v19;
  _QWORD *v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  __int128 v25;
  uint64_t v26;
  uint64_t v27[3];

  if (*((_QWORD *)a2 + 9))
  {
    v4 = (char *)a2 + 56;
    v5 = (_QWORD *)MIDIServer::defaultInstance(this, (int)a2);
    v7 = (uint64_t *)v5[25];
    for (i = (uint64_t *)v5[26]; v7 != i; ++v7)
    {
      v8 = *v7;
      if (!*(_QWORD *)(*v7 + 48))
      {
        for (j = *((_QWORD *)a2 + 8); (char *)j != v4; j = *(_QWORD *)(j + 8))
        {
          v10 = *(_QWORD *)(v8 + 56);
          if (v10)
            (*(void (**)(uint64_t, uint64_t))(v10 + 16))(v10, j + 16);
        }
        v27[0] = 0x800000001;
        v11 = *(_QWORD *)(v8 + 56);
        if (v11)
          (*(void (**)(uint64_t, uint64_t *))(v11 + 16))(v11, v27);
        i = (uint64_t *)v5[26];
      }
    }
    for (k = (uint64_t *)v5[29]; k != (uint64_t *)v5[30]; ++k)
    {
      v13 = *k;
      if (!*(_BYTE *)(*k + 13))
      {
        v14 = *((_QWORD *)a2 + 8);
        if ((char *)v14 != v4)
        {
          do
          {
            v15 = *(_DWORD *)(v14 + 16);
            if ((v15 - 4096) < 3 || v15 == 4)
              CFRetain(*(CFTypeRef *)(v14 + 32));
            v14 = *(_QWORD *)(v14 + 8);
          }
          while ((char *)v14 != v4);
          v17 = *((_QWORD *)a2 + 8);
          if ((char *)v17 != v4)
          {
            v18 = *(uint64_t **)(v13 + 304);
            v19 = operator new(0x28uLL);
            v20 = v19;
            *v19 = 0;
            v19[1] = 0;
            v21 = *(_OWORD *)(v17 + 16);
            v19[4] = *(_QWORD *)(v17 + 32);
            *((_OWORD *)v19 + 1) = v21;
            v22 = *(_QWORD *)(v17 + 8);
            if ((char *)v22 == v4)
            {
              v23 = 1;
            }
            else
            {
              v23 = 1;
              v24 = v19;
              do
              {
                v19 = operator new(0x28uLL);
                *v19 = v24;
                v19[1] = 0;
                v25 = *(_OWORD *)(v22 + 16);
                v19[4] = *(_QWORD *)(v22 + 32);
                *((_OWORD *)v19 + 1) = v25;
                v24[1] = v19;
                ++v23;
                v22 = *(_QWORD *)(v22 + 8);
                v24 = v19;
              }
              while ((char *)v22 != v4);
            }
            v26 = *v18;
            *(_QWORD *)(v26 + 8) = v20;
            *v20 = v26;
            *v18 = (uint64_t)v19;
            v19[1] = v18;
            *(_QWORD *)(v13 + 312) += v23;
          }
        }
        if (!*(_BYTE *)(v13 + 320))
          ClientProcess::DeliverNotifications((ClientProcess *)v13);
      }
    }
    this = (MIDIServer *)NotificationQueue::eraseall((_QWORD *)a2 + 7);
  }
  *((_BYTE *)a2 + 82) = 0;
  return this;
}

void sub_1D4EDA424(void *a1)
{
  _QWORD *v1;
  _QWORD *v2;

  __cxa_begin_catch(a1);
  do
  {
    v2 = (_QWORD *)*v1;
    operator delete(v1);
    v1 = v2;
  }
  while (v2);
  __cxa_rethrow();
}

void sub_1D4EDA444(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void SetupManager::PrefSaverTimerCallback(SetupManager *this, MIDISetup **a2, void *a3)
{
  if (*a2)
    MIDISetup::CheckWritePrefFile(*a2);
  *((_BYTE *)a2 + 83) = 0;
}

void UMPCIClients::instance(UMPCIClients *this)
{
  unsigned __int8 v1;
  UMPCIClients *v2;

  if ((v1 & 1) == 0)
  {
    if ((_DWORD)v2)
    {
      UMPCIClients::UMPCIClients(v2);
    }
  }
}

void sub_1D4EDA4D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void UMPCIClients::UMPCIClients(UMPCIClients *this)
{
  _QWORD *v1;
  void **v2;
  CFIndex v3;
  const __CFString *v4;
  const __CFString *v5;
  int v6;
  void *exception;
  void *v8;
  _QWORD v9[5];
  void *v10[2];
  unsigned __int8 v11;
  std::string __p;
  const __CFString *v13;
  std::string v14;

  std::string::basic_string[abi:ne180100]<0>(v10, "UMPCI shared client");
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3321888768;
  v9[2] = ___ZN12UMPCIClientsC2Ev_block_invoke;
  v9[3] = &__block_descriptor_40_ea8_32c50_ZTSKZN12UMPCIClientsC1EvEUlPK16MIDINotificationE__e30_v16__0r__MIDINotification_iI_8l;
  v9[4] = &UMPCIClients::instance(void)::all;
  v1 = v9;
  UMPCIClients::instance(void)::all = 0;
  if ((v11 & 0x80u) == 0)
    v2 = v10;
  else
    v2 = (void **)v10[0];
  if ((v11 & 0x80u) == 0)
    v3 = v11;
  else
    v3 = (CFIndex)v10[1];
  v4 = CFStringCreateWithBytes(0, (const UInt8 *)v2, v3, 0x8000100u, 0);
  v5 = v4;
  v13 = v4;
  if (!v4)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  v6 = MIDIClientCreateWithBlockInternal(v4, &UMPCIClients::instance(void)::all, v1, 1);
  std::string::basic_string[abi:ne180100]<0>(&__p, "Creating MIDI client failed miserably.");
  if (v6)
  {
    v8 = __cxa_allocate_exception(0x18uLL);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      std::string::__init_copy_ctor_external(&v14, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    else
      v14 = __p;
    MIDI::Exception::Exception((uint64_t)v8, v6, (uint64_t)&v14);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  CFRelease(v5);

  if ((char)v11 < 0)
    operator delete(v10[0]);
}

void sub_1D4EDA6A4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  void *v25;
  void *v26;
  uint64_t v27;

  __cxa_free_exception(v26);
  if (a25 < 0)
    operator delete(__p);
  applesauce::CF::StringRef::~StringRef((const void **)(v27 - 72));

  if (a19 < 0)
    operator delete(a14);
  __cxa_begin_catch(a1);
  __cxa_rethrow();
}

void sub_1D4EDA740(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void ___ZN12UMPCIClientsC2Ev_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  const __CFNumber *v3;
  MIDIUMPFunctionBlock *v4;
  void *v5;
  const __CFNumber *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  void *v11;
  void *v12;
  const __CFNumber *v13;
  void *v14;
  CFTypeRef v15;
  CFTypeRef v16;
  CFTypeRef v17;
  CFTypeRef v18;
  void *v19;
  void *v20;
  void *exception;
  id v22;
  int valuePtr;
  CFTypeRef cf;

  switch(*(_DWORD *)a2)
  {
    case 0x1000:
      v2 = *(_QWORD *)(a2 + 16);
      if (v2)
      {
        applesauce::CF::DictionaryRef::DictionaryRef((applesauce::CF::DictionaryRef *)&cf, *(CFTypeRef *)(a2 + 16));
        if (!cf)
        {
          exception = __cxa_allocate_exception(0x10uLL);
          MEMORY[0x1D826B7EC](exception, "Could not construct");
        }
        v3 = (const __CFNumber *)applesauce::CF::details::at_key<char const* const&>((const __CFDictionary *)cf, "type");
        if (v3)
        {
          valuePtr = 0;
          if (CFNumberGetValue(v3, kCFNumberIntType, &valuePtr))
          {
            switch(valuePtr)
            {
              case 1:
                v4 = -[MIDIUMPFunctionBlock initWithDescription:]([MIDIUMPFunctionBlock alloc], "initWithDescription:", v2);
                +[MIDIUMPEndpointManager sharedInstance](MIDIUMPEndpointManager, "sharedInstance");
                v5 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v5, "addFunctionBlock:", v4);
                goto LABEL_34;
              case 2:
                v4 = -[MIDIUMPEndpoint initWithDescription:]([MIDIUMPEndpoint alloc], "initWithDescription:", v2);
                +[MIDIUMPEndpointManager sharedInstance](MIDIUMPEndpointManager, "sharedInstance");
                v5 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v5, "addEndpoint:", v4);
                goto LABEL_34;
              case 3:
                v4 = -[MIDIUMPCIProfile initWithDescription:]([MIDIUMPCIProfile alloc], "initWithDescription:", v2);
                +[MIDICIDeviceManager sharedInstance](MIDICIDeviceManager, "sharedInstance");
                v5 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v5, "addProfile:", v4);
                goto LABEL_34;
              case 4:
                v4 = -[MIDICIDevice initWithDescription:]([MIDICIDevice alloc], "initWithDescription:", v2);
                +[MIDICIDeviceManager sharedInstance](MIDICIDeviceManager, "sharedInstance");
                v5 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v5, "addDevice:", v4);
LABEL_34:

                break;
              default:
                break;
            }
          }
        }
        if (cf)
          CFRelease(cf);
      }
      break;
    case 0x1001:
      v9 = *(unsigned int *)(a2 + 8);
      +[MIDIUMPEndpointManager sharedInstance](MIDIUMPEndpointManager, "sharedInstance");
      v22 = (id)objc_claimAutoreleasedReturnValue();
      if ((objc_msgSend(v22, "removeFunctionBlock:", v9) & 1) == 0)
      {
        +[MIDIUMPEndpointManager sharedInstance](MIDIUMPEndpointManager, "sharedInstance");
        v10 = (void *)objc_claimAutoreleasedReturnValue();
        if ((objc_msgSend(v10, "removeEndpoint:", v9) & 1) == 0)
        {
          +[MIDICIDeviceManager sharedInstance](MIDICIDeviceManager, "sharedInstance");
          v11 = (void *)objc_claimAutoreleasedReturnValue();
          if ((objc_msgSend(v11, "removeDevice:", v9) & 1) == 0)
          {
            +[MIDICIDeviceManager sharedInstance](MIDICIDeviceManager, "sharedInstance");
            v12 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v12, "removeProfile:", v9);

          }
        }

      }
      goto LABEL_18;
    case 0x1002:
      applesauce::CF::DictionaryRef::DictionaryRef((applesauce::CF::DictionaryRef *)&cf, *(CFTypeRef *)(a2 + 16));
      if (!cf)
      {
        v19 = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x1D826B7EC](v19, "Could not construct");
      }
      v6 = (const __CFNumber *)applesauce::CF::details::at_key<char const* const&>((const __CFDictionary *)cf, "object");
      if (v6)
        v7 = applesauce::CF::convert_as<unsigned int,0>(v6);
      else
        v7 = 0;
      if (!cf)
      {
        v20 = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x1D826B7EC](v20, "Could not construct");
      }
      v13 = applesauce::CF::DictionaryRef_proxy::at_as<UMPCIObjectType,char const* const&>((const __CFDictionary *)cf, "type");
      if (HIDWORD(v7) && (unint64_t)v13 >> 32)
      {
        switch((int)v13)
        {
          case 1:
            +[MIDIUMPEndpointManager sharedInstance](MIDIUMPEndpointManager, "sharedInstance");
            v14 = (void *)objc_claimAutoreleasedReturnValue();
            v15 = cf;
            cf = 0;
            objc_msgSend(v14, "updateFunctionBlock:description:", v7, v15);
            goto LABEL_28;
          case 2:
            +[MIDIUMPEndpointManager sharedInstance](MIDIUMPEndpointManager, "sharedInstance");
            v14 = (void *)objc_claimAutoreleasedReturnValue();
            v18 = cf;
            cf = 0;
            objc_msgSend(v14, "updateEndpoint:description:", v7, v18);
            goto LABEL_28;
          case 3:
            +[MIDICIDeviceManager sharedInstance](MIDICIDeviceManager, "sharedInstance");
            v14 = (void *)objc_claimAutoreleasedReturnValue();
            v16 = cf;
            cf = 0;
            objc_msgSend(v14, "updateProfile:description:", v7, v16);
            goto LABEL_28;
          case 4:
            +[MIDICIDeviceManager sharedInstance](MIDICIDeviceManager, "sharedInstance");
            v14 = (void *)objc_claimAutoreleasedReturnValue();
            v17 = cf;
            cf = 0;
            objc_msgSend(v14, "updateDevice:description:", v7, v17);
LABEL_28:

            break;
          default:
            break;
        }
      }
      if (cf)
        CFRelease(cf);
      break;
    case 0x1003:
      v8 = *(unsigned int *)(a2 + 8);
      +[MIDICIDeviceManager sharedInstance](MIDICIDeviceManager, "sharedInstance");
      v22 = (id)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v22, "setServerMUID:", v8);
LABEL_18:

      break;
    default:
      return;
  }
}

void sub_1D4EDAB84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10, uint64_t a11, CFTypeRef cf)
{
  void *v12;
  void *v13;
  void *v14;

  v14 = v12;

  if (cf)
    CFRelease(cf);
  _Unwind_Resume(a1);
}

uint64_t MIDI::Exception::Exception(uint64_t a1, int __val, uint64_t a3)
{
  std::string *v6;
  __int128 v7;
  uint64_t v8;
  std::string *v9;
  __int128 v10;
  unsigned int v11;
  void **v12;
  void *v13;
  void **v14;
  std::string::size_type v15;
  std::string *v16;
  __int128 v17;
  std::string v19;
  void *__p[2];
  std::string::size_type v21;
  std::string v22;
  std::string v23;
  std::string v24;

  std::to_string(&v22, __val);
  v6 = std::string::insert(&v22, 0, "Error code: ", 0xCuLL);
  v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v23.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v23.__r_.__value_.__l.__data_ = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  if (*(char *)(a3 + 23) < 0)
  {
    v8 = *(_QWORD *)(a3 + 8);
    if (v8)
      goto LABEL_3;
  }
  else
  {
    v8 = *(unsigned __int8 *)(a3 + 23);
    if (*(_BYTE *)(a3 + 23))
    {
LABEL_3:
      std::operator+<char>();
      v9 = std::string::append(&v19, ")", 1uLL);
      v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
      v21 = v9->__r_.__value_.__r.__words[2];
      *(_OWORD *)__p = v10;
      v9->__r_.__value_.__l.__size_ = 0;
      v9->__r_.__value_.__r.__words[2] = 0;
      v9->__r_.__value_.__r.__words[0] = 0;
      v11 = HIBYTE(v21);
      v12 = (void **)__p[0];
      v13 = __p[1];
      goto LABEL_6;
    }
  }
  v13 = 0;
  v12 = 0;
  v11 = 0;
  __p[0] = 0;
  __p[1] = 0;
  v21 = 0;
LABEL_6:
  if ((v11 & 0x80u) == 0)
    v14 = __p;
  else
    v14 = v12;
  if ((v11 & 0x80u) == 0)
    v15 = v11;
  else
    v15 = (std::string::size_type)v13;
  v16 = std::string::append(&v23, (const std::string::value_type *)v14, v15);
  v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  v24.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v17;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  std::runtime_error::runtime_error((std::runtime_error *)a1, &v24);
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v24.__r_.__value_.__l.__data_);
  if (SHIBYTE(v21) < 0)
    operator delete(__p[0]);
  if (v8 && SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v19.__r_.__value_.__l.__data_);
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v23.__r_.__value_.__l.__data_);
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v22.__r_.__value_.__l.__data_);
  *(_QWORD *)a1 = &off_1E98B6DD8;
  *(_DWORD *)(a1 + 16) = __val;
  return a1;
}

void sub_1D4EDAE18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a15 < 0)
    operator delete(__p);
  if (a33 < 0)
    operator delete(a28);
  if (a27 < 0)
    operator delete(a22);
  _Unwind_Resume(exception_object);
}

void MIDI::Exception::~Exception(std::runtime_error *this)
{
  std::runtime_error::~runtime_error(this);
  JUMPOUT(0x1D826BA98);
}

uint64_t __copy_helper_block_ea8_32c50_ZTSKZN12UMPCIClientsC1EvEUlPK16MIDINotificationE_(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  return result;
}

void sendUMPMessage(MIDIEndpointRef a1, uint64_t a2)
{
  unsigned __int8 v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  OSStatus v15;
  UMPCIClients *v16;
  MIDIClientRef v17;
  void *exception;
  MIDIEventList *evtlist[3];
  void *v20;
  _BYTE *v21;
  std::string __p;
  std::string v23;

  if ((v4 & 1) == 0)
  {
    if ((_DWORD)v16)
    {
      UMPCIClients::instance(v16);
      v17 = UMPCIClients::instance(void)::all;
      std::string::basic_string[abi:ne180100]<0>(&v23, "MIDI_CLIENT_UMPCI_PORT");
      MIDI::OutputPort::OutputPort(v17, (const UInt8 *)&v23);
      if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v23.__r_.__value_.__l.__data_);
    }
  }
  if ((*(_DWORD *)a2 & 0xFF0000) != 0)
    v5 = 1;
  else
    v5 = 3;
  if (*(_DWORD *)a2)
    v6 = v5;
  else
    v6 = 0;
  std::vector<unsigned char>::vector(&v20, ((2* (((unint64_t)(v6 + *(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8)) * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64)) & 0xFFFFFFFFFFFFFFF8)+ 28);
  v7 = (char *)v20;
  evtlist[0] = (MIDIEventList *)v20;
  evtlist[1] = (MIDIEventList *)(v21 - (_BYTE *)v20);
  *(_QWORD *)v20 = 1;
  evtlist[2] = (MIDIEventList *)(v7 + 8);
  *((_DWORD *)v7 + 4) = 0;
  if ((*(_DWORD *)a2 & 0xFF0000) != 0)
    v8 = 1;
  else
    v8 = 3;
  if (!*(_DWORD *)a2)
    v8 = 0;
  v9 = 806354944;
  if ((unint64_t)(v8 + *(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8)) < 7)
    v9 = 805306368;
  *(_OWORD *)&v23.__r_.__value_.__l.__data_ = (unint64_t)v9;
  midi::sysex7_packet::add_payload_byte((midi::sysex7_packet *)&v23);
  if ((unsigned __int16)*(_DWORD *)a2)
  {
    midi::sysex7_packet::add_payload_byte((midi::sysex7_packet *)&v23);
    midi::sysex7_packet::add_payload_byte((midi::sysex7_packet *)&v23);
  }
  v12 = a2 + 8;
  v10 = *(_QWORD *)(a2 + 8);
  v11 = *(_QWORD *)(v12 + 8);
  if (v10 == v11)
  {
    LODWORD(v14) = v23.__r_.__value_.__l.__data_;
  }
  else
  {
    v13 = ~v10 + v11;
    do
    {
      midi::sysex7_packet::add_payload_byte((midi::sysex7_packet *)&v23);
      LODWORD(v14) = v23.__r_.__value_.__l.__data_;
      if (((uint64_t)v23.__r_.__value_.__l.__data_ & 0xF0000) == 0x60000)
      {
        sendUMPMessage(unsigned int,unsigned char,midi::sysex7 const&)::$_0::operator()(evtlist, (unsigned int *)&v23);
        if (v13 >= 7)
          v14 = 807403520;
        else
          v14 = 808452096;
        *(_OWORD *)&v23.__r_.__value_.__l.__data_ = (unint64_t)v14;
      }
      ++v10;
      --v13;
    }
    while (v10 != v11);
  }
  if ((v14 & 0xF0000) != 0)
    sendUMPMessage(unsigned int,unsigned char,midi::sysex7 const&)::$_0::operator()(evtlist, (unsigned int *)&v23);
  v15 = MIDISendEventList(sendUMPMessage(unsigned int,unsigned char,midi::sysex7 const&)::port, a1, evtlist[0]);
  std::string::basic_string[abi:ne180100]<0>(&__p, "failed to send data to endpoint");
  if (v15)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      std::string::__init_copy_ctor_external(&v23, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    else
      v23 = __p;
    MIDI::Exception::Exception((uint64_t)exception, v15, (uint64_t)&v23);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (v20)
  {
    v21 = v20;
    operator delete(v20);
  }
}

void sub_1D4EDB170(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void MIDI::OutputPort::OutputPort(MIDIClientRef a1, const UInt8 *a2)
{
  CFIndex v3;
  CFIndex v4;
  const __CFString *v5;
  OSStatus v6;
  void *exception;
  void *v8;
  std::string __p;
  const __CFString *v10;
  std::string v11;

  sendUMPMessage(unsigned int,unsigned char,midi::sysex7 const&)::port = 0;
  v3 = *((_QWORD *)a2 + 1);
  if (*((char *)a2 + 23) >= 0)
  {
    v4 = a2[23];
  }
  else
  {
    a2 = *(const UInt8 **)a2;
    v4 = v3;
  }
  v5 = CFStringCreateWithBytes(0, a2, v4, 0x8000100u, 0);
  v10 = v5;
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  v6 = MIDIOutputPortCreate(a1, v5, (MIDIPortRef *)&sendUMPMessage(unsigned int,unsigned char,midi::sysex7 const&)::port);
  std::string::basic_string[abi:ne180100]<0>(&__p, "failed to create output port");
  if (v6)
  {
    v8 = __cxa_allocate_exception(0x18uLL);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      std::string::__init_copy_ctor_external(&v11, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    else
      v11 = __p;
    MIDI::Exception::Exception((uint64_t)v8, v6, (uint64_t)&v11);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  CFRelease(v5);
}

void sub_1D4EDB354(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, const void *a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  void *v21;
  MIDI::Port *v23;

  __cxa_free_exception(v21);
  if (a14 < 0)
    operator delete(__p);
  applesauce::CF::StringRef::~StringRef(&a15);
  MIDI::Port::~Port(v23);
  _Unwind_Resume(a1);
}

_QWORD *sendUMPMessage(unsigned int,unsigned char,midi::sysex7 const&)::$_0::operator()(_QWORD *result, unsigned int *a2)
{
  _QWORD *v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  int v8;
  BOOL v9;
  unsigned int v10;
  BOOL v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  BOOL v15;
  char v16;
  int v17;
  BOOL v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;

  v2 = result;
  v3 = *a2;
  v4 = *(_QWORD *)((char *)&unk_1D4F192E8 + ((v3 >> 25) & 0x78));
  v5 = result[2];
  v6 = *result + result[1];
  v7 = v3 & 0xF0000000;
  v8 = *(_DWORD *)(*result + 4);
  if (v5)
    v9 = v8 == 0;
  else
    v9 = 1;
  if (!v9)
  {
    v10 = *(_DWORD *)(v5 + 8);
    v11 = v10 >= 2;
    v12 = v10 - 2;
    if (v11 && *(_DWORD *)(v5 + 12) >> 28 == 3)
    {
      v13 = *(_DWORD *)(v5 + 4 * v12 + 12);
      if (v13 >> 28 == 3)
        v14 = (v13 >> 20) & 0xF;
      else
        v14 = 255;
      if (v14)
        v15 = v14 == 3;
      else
        v15 = 1;
      v16 = v15;
      v17 = 1;
LABEL_24:
      if ((v3 & 0xF0E00000) != 0x30000000)
      {
        v18 = (v7 != 805306368) != v17 && *(_QWORD *)v5 == 0;
        if (v18 && (v16 & 1) == 0)
        {
LABEL_31:
          v19 = *(unsigned int *)(v5 + 8);
          if (v5 + 4 * (v4 + v19) + 12 > v6)
            return result;
          goto LABEL_36;
        }
      }
      goto LABEL_33;
    }
LABEL_23:
    v17 = 0;
    v16 = 0;
    goto LABEL_24;
  }
  if (v8)
  {
    if (!v5)
    {
      if (v7 != 805306368)
        goto LABEL_31;
LABEL_33:
      v5 += 4 * *(unsigned int *)(v5 + 8) + 12;
      goto LABEL_34;
    }
    goto LABEL_23;
  }
LABEL_34:
  if (v5 + 4 * v4 + 12 > v6)
    return result;
  LODWORD(v19) = 0;
  *(_DWORD *)(*result + 4) = v8 + 1;
  *(_QWORD *)v5 = 0;
  *(_DWORD *)(v5 + 8) = 0;
LABEL_36:
  result = (_QWORD *)(v5 + 4 * v19 + 12);
  switch(v4)
  {
    case 0:
      break;
    case 1:
      goto LABEL_40;
    case 2:
      goto LABEL_39;
    case 3:
      goto LABEL_38;
    case 4:
      v20 = *a2++;
      *(_DWORD *)result = v20;
      result = (_QWORD *)(v5 + 4 * v19 + 16);
LABEL_38:
      v21 = *a2++;
      *(_DWORD *)result = v21;
      result = (_QWORD *)((char *)result + 4);
LABEL_39:
      v22 = *a2++;
      *(_DWORD *)result = v22;
      result = (_QWORD *)((char *)result + 4);
LABEL_40:
      *(_DWORD *)result = *a2;
      break;
    default:
      result = memmove(result, a2, 4 * v4);
      break;
  }
  *(_DWORD *)(v5 + 8) += v4;
  v2[2] = v5;
  return result;
}

void MIDI::Port::~Port(MIDI::Port *this)
{
  MIDIPortDispose(sendUMPMessage(unsigned int,unsigned char,midi::sysex7 const&)::port);
}

void CADeprecated::CAPThread::~CAPThread(CADeprecated::CAPThread *this)
{
  JUMPOUT(0x1D826BA98);
}

uint64_t CADeprecated::CAPThread::Start(uint64_t this)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  NSObject *v8;
  const char *v9;
  uint8_t *v10;
  _DWORD *exception;
  __int16 v12;
  pthread_t v13;
  sched_param v14;
  pthread_attr_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (atomic_load((unint64_t *)(this + 8)))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      LOWORD(v15.__sig) = 0;
      _os_log_error_impl(&dword_1D4E88000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, " CAPThread::Start: can't start because the thread is already running", (uint8_t *)&v15, 2u);
    }
    __break(1u);
  }
  if (!atomic_load((unint64_t *)(this + 8)))
  {
    v3 = this;
    v4 = pthread_attr_init(&v15);
    if (v4)
    {
      v7 = v4;
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        goto LABEL_22;
      LOWORD(v14.sched_priority) = 0;
      v8 = MEMORY[0x1E0C81028];
      v9 = " CAPThread::Start: Thread attributes could not be created.";
    }
    else
    {
      v5 = pthread_attr_setdetachstate(&v15, 2);
      if (!v5)
      {
        pthread_attr_getschedparam(&v15, &v14);
        v14.sched_priority = *(_DWORD *)(v3 + 104);
        pthread_attr_setschedparam(&v15, &v14);
        if (*(_BYTE *)(v3 + 122))
          pthread_attr_setschedpolicy(&v15, 4);
        v13 = 0;
        v6 = pthread_create(&v13, &v15, (void *(__cdecl *)(void *))CADeprecated::CAPThread::Entry, (void *)v3);
        if (!v6 && v13)
        {
          atomic_store((unint64_t)v13, (unint64_t *)(v3 + 8));
          return pthread_attr_destroy(&v15);
        }
        v7 = v6;
        if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        {
LABEL_22:
          exception = __cxa_allocate_exception(0x10uLL);
          *(_QWORD *)exception = &off_1E98B9410;
          exception[2] = v7;
        }
        v12 = 0;
        v8 = MEMORY[0x1E0C81028];
        v9 = " CAPThread::Start: Could not create a thread.";
        v10 = (uint8_t *)&v12;
LABEL_21:
        _os_log_error_impl(&dword_1D4E88000, v8, OS_LOG_TYPE_ERROR, v9, v10, 2u);
        goto LABEL_22;
      }
      v7 = v5;
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        goto LABEL_22;
      LOWORD(v14.sched_priority) = 0;
      v8 = MEMORY[0x1E0C81028];
      v9 = " CAPThread::Start: A thread could not be created in the detached state.";
    }
    v10 = (uint8_t *)&v14;
    goto LABEL_21;
  }
  return this;
}

uint64_t CADeprecated::CAPThread::Entry(CADeprecated::CAPThread *this, CADeprecated::CAPThread *a2)
{
  uint64_t (*v3)(_QWORD);
  uint64_t v4;

  atomic_store((unint64_t)pthread_self(), (unint64_t *)this + 1);
  if (*((_BYTE *)this + 40))
    pthread_setname_np((const char *)this + 40);
  if (*((_BYTE *)this + 121))
    CADeprecated::CAPThread::SetTimeConstraints(this, *((_DWORD *)this + 27), *((_DWORD *)this + 28), *((_DWORD *)this + 29), *((_BYTE *)this + 120));
  v3 = (uint64_t (*)(_QWORD))*((_QWORD *)this + 3);
  if (v3)
    v4 = v3(*((_QWORD *)this + 4));
  else
    v4 = 0;
  atomic_store(0, (unint64_t *)this + 1);
  if (*((_BYTE *)this + 123))
    (*(void (**)(CADeprecated::CAPThread *))(*(_QWORD *)this + 8))(this);
  return v4;
}

void CADeprecated::CAPThread::SetTimeConstraints(CADeprecated::CAPThread *this, int a2, int a3, int a4, char a5)
{
  int v6;
  _opaque_pthread_t *v7;
  thread_act_t v8;
  kern_return_t v9;
  kern_return_t v10;
  _BYTE v11[5];
  integer_t policy_info[2];
  int v13;
  int v14;
  uint8_t buf[4];
  kern_return_t v16;
  __int16 v17;
  _BYTE *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  *((_DWORD *)this + 27) = a2;
  *((_DWORD *)this + 28) = a3;
  *((_DWORD *)this + 29) = a4;
  *((_BYTE *)this + 120) = a5;
  *((_BYTE *)this + 121) = 1;
  if (atomic_load((unint64_t *)this + 1))
  {
    *(_QWORD *)policy_info = *(_QWORD *)((char *)this + 108);
    v6 = *((unsigned __int8 *)this + 120);
    v13 = *((_DWORD *)this + 29);
    v14 = v6;
    v7 = (_opaque_pthread_t *)atomic_load((unint64_t *)this + 1);
    v8 = pthread_mach_thread_np(v7);
    v9 = thread_policy_set(v8, 2u, policy_info, 4u);
    if (v9)
    {
      v11[0] = HIBYTE(v9);
      v11[1] = BYTE2(v9);
      v11[2] = BYTE1(v9);
      v10 = v9;
      v11[3] = v9;
      v11[4] = 0;
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109378;
        v16 = v10;
        v17 = 2080;
        v18 = v11;
        _os_log_error_impl(&dword_1D4E88000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, " CAPThread::SetTimeConstraints: thread_policy_set failed, Error: %d (%s)", buf, 0x12u);
      }
      __break(1u);
    }
  }
}

CADeprecated::CAPThread *CADeprecated::CAPThread::CAPThread(CADeprecated::CAPThread *this, void *(*a2)(void *), void *a3, unsigned int a4, BOOL a5, BOOL a6, const char *a7)
{
  int v7;
  _opaque_pthread_t *v10;
  _opaque_pthread_t *v11;

  v7 = (int)a3;
  *(_QWORD *)this = &off_1E98B9E18;
  *((_QWORD *)this + 1) = 0;
  v10 = pthread_self();
  *((_DWORD *)this + 4) = CADeprecated::CAPThread::getScheduledPriority(v10, v11);
  *((_QWORD *)this + 3) = CADeprecated::XThread::RunHelper;
  *((_QWORD *)this + 4) = a2;
  *((_DWORD *)this + 26) = v7;
  *((_DWORD *)this + 27) = 0;
  *((_QWORD *)this + 14) = 0;
  *((_DWORD *)this + 30) = 1;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  return this;
}

_opaque_pthread_t *CADeprecated::CAPThread::getScheduledPriority(_opaque_pthread_t *this, _opaque_pthread_t *a2)
{
  _opaque_pthread_t *v2;
  thread_inspect_t v3;
  thread_inspect_t v4;
  thread_inspect_t v5;
  thread_inspect_t v6;
  mach_msg_type_number_t thread_info_outCnt;
  integer_t v8[5];
  integer_t v9[5];
  integer_t v10[4];
  integer_t thread_info_out[5];
  int v12;

  if (this)
  {
    v2 = this;
    thread_info_outCnt = 10;
    v3 = pthread_mach_thread_np(this);
    thread_info(v3, 3u, thread_info_out, &thread_info_outCnt);
    switch(v12)
    {
      case 4:
        thread_info_outCnt = 4;
        v5 = pthread_mach_thread_np(v2);
        thread_info(v5, 0xCu, v10, &thread_info_outCnt);
        return (_opaque_pthread_t *)v10[1];
      case 2:
        thread_info_outCnt = 5;
        v6 = pthread_mach_thread_np(v2);
        thread_info(v6, 0xBu, v9, &thread_info_outCnt);
        return (_opaque_pthread_t *)v9[1];
      case 1:
        thread_info_outCnt = 5;
        v4 = pthread_mach_thread_np(v2);
        thread_info(v4, 0xAu, v8, &thread_info_outCnt);
        return (_opaque_pthread_t *)v8[1];
      default:
        return 0;
    }
  }
  return this;
}

void MIDIProcess::MIDIInPortThread::~MIDIInPortThread(MIDIProcess::MIDIInPortThread *this)
{
  JUMPOUT(0x1D826BA98);
}

uint64_t MIDIProcess::MIDIInPortThread::Start(MIDIProcess::MIDIInPortThread *this)
{
  CADeprecated::CAPThread::SetTimeConstraints(this, 0, 6000, 12000, 1);
  return CADeprecated::CAPThread::Start((uint64_t)this);
}

uint64_t MIDIProcess::MIDIInPortThread::RequestStop(MIDIProcess::MIDIInPortThread *this)
{
  int v1;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v1 = **(_DWORD **)(*((_QWORD *)this + 18) + 16);
  v3 = 0x2400000013;
  v4 = v1;
  v6 = 0;
  v5 = 0;
  v7 = 3;
  return mach_msg((mach_msg_header_t *)&v3, 1, 0x24u, 0, 0, 0, 0);
}

uint64_t MIDIProcess::MIDIInPortThread::Run(MIDIProcess::MIDIInPortThread *this)
{
  uint64_t v1;
  unsigned int *v2;
  uint64_t result;
  unsigned int v4;
  int v5;
  int v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t *i;
  uint64_t v12;
  uint64_t j;
  unsigned int v14;
  uint64_t v15;
  unsigned int *v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  uint64_t v21;
  int v22;
  int v23;
  _BYTE msg[28];
  uint64_t v25;
  unsigned int v26;
  _BYTE v27[32];
  _BYTE v28[28];
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  *((_BYTE *)this + 137) = 1;
  v1 = *((_QWORD *)this + 18);
  v2 = (unsigned int *)(v1 + 284);
  do
  {
    while (1)
    {
      while (1)
      {
        v22 = 32;
        v23 = 0;
        result = XServerMachPort::ReceiveMessage(**(_DWORD **)(v1 + 16), &v23, v27, &v22);
        if (v23 != 1)
          break;
        *(_QWORD *)msg = 1;
        while (MIDIIORingBufferReader::readPacketList(*(MIDIRingBuffer **)(v1 + 40), &v21, (uint64_t)msg))
        {
          if (*(_DWORD *)&msg[4])
          {
            v7 = v21;
            v6 = HIDWORD(v21);
            do
              v8 = __ldaxr(v2);
            while (__stlxr(v8 + 1, v2));
            while (*(_DWORD *)(v1 + 280))
            {
              do
                v9 = __ldaxr(v2);
              while (__stlxr(v9 - 1, v2));
              usleep(0x1F4u);
              do
                v10 = __ldaxr(v2);
              while (__stlxr(v10 + 1, v2));
            }
            for (i = *(uint64_t **)(v1 + 168); i != *(uint64_t **)(v1 + 176); ++i)
            {
              v12 = *i;
              if (*(_DWORD *)(*i + 4) == v7)
              {
                for (j = *(_QWORD *)(v12 + 32); j != *(_QWORD *)(v12 + 40); j += 16)
                {
                  if (*(_DWORD *)j == v6)
                  {
                    (*(void (**)(_QWORD, _BYTE *))(**(_QWORD **)(j + 8) + 16))(*(_QWORD *)(j + 8), msg);
                    goto LABEL_27;
                  }
                }
                goto LABEL_27;
              }
            }
            do
LABEL_27:
              v14 = __ldaxr(v2);
            while (__stlxr(v14 - 1, v2));
          }
        }
        v15 = *(_QWORD *)(v1 + 40);
        if (atomic_load((unsigned int *)(*(_QWORD *)(v15 + 88) + 16)))
        {
          v17 = (unsigned int *)(*(_QWORD *)(v15 + 88) + 24);
          do
            v18 = __ldaxr(v17);
          while (__stlxr(v18 | 1, v17));
          if (!v18)
          {
            v19 = atomic_load((unsigned int *)(*(_QWORD *)(*(_QWORD *)(v1 + 40) + 88) + 8));
            v20 = **(_DWORD **)(v1 + 24);
            *(_QWORD *)v28 = 0x2800000013;
            *(_DWORD *)&v28[8] = v20;
            *(_QWORD *)&v28[12] = 0;
            *(_QWORD *)&v28[20] = 0;
            v29 = 0x400000002;
            v30 = v19;
            mach_msg((mach_msg_header_t *)v28, 1, 0x28u, 0, 0, 0, 0);
          }
        }
      }
      if (v23 != 2)
        break;
      if (MIDIIORingBufferWriter::emptySecondaryQueue(*(os_unfair_lock_s **)(v1 + 48)))
      {
        v4 = atomic_load((unsigned int *)(*(_QWORD *)(*(_QWORD *)(v1 + 48) + 88) + 8));
        v5 = **(_DWORD **)(v1 + 24);
        *(_QWORD *)msg = 0x2800000013;
        *(_DWORD *)&msg[8] = v5;
        *(_QWORD *)&msg[12] = 0;
        *(_QWORD *)&msg[20] = 0;
        v25 = 0x400000001;
        v26 = v4;
        mach_msg((mach_msg_header_t *)msg, 1, 0x28u, 0, 0, 0, 0);
      }
    }
  }
  while (v23 != 3);
  return result;
}

void sub_1D4EDBE5C(_Unwind_Exception *a1)
{
  unsigned int *v1;
  unsigned int v2;

  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 - 1, v1));
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<LocalMIDIClient>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E98B9FD0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<LocalMIDIClient>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E98B9FD0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D826BA98);
}

void std::__shared_ptr_emplace<LocalMIDIClient>::__on_zero_shared(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 32);
  if (v1)
    _Block_release(v1);
}

char *LocalClientList::Copy(char **a1, char **a2)
{
  char **v4;
  char *result;
  int v6;
  uint64_t *v7;
  uint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;

  v4 = a1 + 11;
  result = (char *)(*((uint64_t (**)(char **))*a1 + 2))(a1);
  v6 = (int)result;
  if (v4 == a2)
    goto LABEL_34;
  v8 = (uint64_t *)a1[11];
  v7 = (uint64_t *)a1[12];
  v9 = ((char *)v7 - (char *)v8) >> 4;
  v10 = (uint64_t)a2[2];
  v11 = *a2;
  if (v9 > (v10 - (uint64_t)*a2) >> 4)
  {
    if (v11)
    {
      v12 = (uint64_t)a2[1];
      v13 = *a2;
      if ((char *)v12 != v11)
      {
        do
          v12 = std::shared_ptr<swix::connection::state>::~shared_ptr[abi:ne180100](v12 - 16);
        while ((char *)v12 != v11);
        v13 = *a2;
      }
      a2[1] = v11;
      operator delete(v13);
      v10 = 0;
      *a2 = 0;
      a2[1] = 0;
      a2[2] = 0;
    }
    if ((char *)v7 - (char *)v8 < 0)
      goto LABEL_44;
    v14 = v10 >> 3;
    if (v10 >> 3 <= v9)
      v14 = ((char *)v7 - (char *)v8) >> 4;
    v15 = (unint64_t)v10 >= 0x7FFFFFFFFFFFFFF0 ? 0xFFFFFFFFFFFFFFFLL : v14;
    if (v15 >> 60)
LABEL_44:
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>(v15);
    *a2 = result;
    a2[1] = result;
    a2[2] = &result[16 * v16];
    while (v8 != v7)
    {
      v17 = v8[1];
      *(_QWORD *)result = *v8;
      *((_QWORD *)result + 1) = v17;
      if (v17)
      {
        v18 = (unint64_t *)(v17 + 8);
        do
          v19 = __ldxr(v18);
        while (__stxr(v19 + 1, v18));
      }
      v8 += 2;
      result += 16;
    }
    a2[1] = result;
LABEL_34:
    if (!v6)
      return result;
    return (char *)(*((uint64_t (**)(char **))*a1 + 3))(a1);
  }
  result = a2[1];
  v20 = (result - v11) >> 4;
  if (v20 < v9)
  {
    v21 = &v8[2 * v20];
    if (result != v11)
    {
      do
      {
        v22 = *v8;
        v23 = v8[1];
        v8 += 2;
        result = (char *)std::shared_ptr<LocalMIDIClient>::operator=[abi:ne180100](v11, v22, v23);
        v11 += 16;
      }
      while (v8 != v21);
      v11 = a2[1];
    }
    v24 = v11;
    if (v21 != v7)
    {
      v24 = v11;
      do
      {
        v25 = v21[1];
        *(_QWORD *)v24 = *v21;
        *((_QWORD *)v24 + 1) = v25;
        if (v25)
        {
          v26 = (unint64_t *)(v25 + 8);
          do
            v27 = __ldxr(v26);
          while (__stxr(v27 + 1, v26));
        }
        v21 += 2;
        v24 += 16;
      }
      while (v21 != v7);
    }
    a2[1] = v24;
    if (!v6)
      return result;
    return (char *)(*((uint64_t (**)(char **))*a1 + 3))(a1);
  }
  if (v8 != v7)
  {
    do
    {
      v28 = *v8;
      v29 = v8[1];
      v8 += 2;
      std::shared_ptr<LocalMIDIClient>::operator=[abi:ne180100](v11, v28, v29);
      v11 += 16;
    }
    while (v8 != v7);
    result = a2[1];
  }
  while (result != v11)
    result = (char *)std::shared_ptr<swix::connection::state>::~shared_ptr[abi:ne180100]((uint64_t)(result - 16));
  a2[1] = v11;
  if (v6)
    return (char *)(*((uint64_t (**)(char **))*a1 + 3))(a1);
  return result;
}

void sub_1D4EDC0F8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  int v2;

  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

_QWORD *std::shared_ptr<LocalMIDIClient>::operator=[abi:ne180100](_QWORD *a1, uint64_t a2, uint64_t a3)
{
  unint64_t *v4;
  unint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;

  if (a3)
  {
    v4 = (unint64_t *)(a3 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  v6 = (std::__shared_weak_count *)a1[1];
  *a1 = a2;
  a1[1] = a3;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  return a1;
}

void LocalMIDIReceiver::~LocalMIDIReceiver(const void **this)
{
  char *v2;
  char *v3;
  void *v4;
  uint64_t v5;

  _Block_release(this[2]);
  _Block_release(this[3]);
  v2 = (char *)this[4];
  if (v2)
  {
    v3 = (char *)this[5];
    v4 = (void *)this[4];
    if (v3 != v2)
    {
      do
      {
        v5 = *((_QWORD *)v3 - 1);
        *((_QWORD *)v3 - 1) = 0;
        if (v5)
          (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
        v3 -= 16;
      }
      while (v3 != v2);
      v4 = (void *)this[4];
    }
    this[5] = v2;
    operator delete(v4);
  }
}

uint64_t caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<LocalMIDIReceiver::connectEndpoint(unsigned int,void *)::$_2>(caulk::inplace_function_detail::wrapper<LocalMIDIReceiver::connectEndpoint(unsigned int,void *)::$_2>)::{lambda(void *,MIDI::EventList const*&&)#1}::__invoke(_QWORD *a1, _QWORD *a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*a1 + 16))(*a1, *a2, a1[1]);
}

__n128 caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<LocalMIDIReceiver::connectEndpoint(unsigned int,void *)::$_2>(caulk::inplace_function_detail::wrapper<LocalMIDIReceiver::connectEndpoint(unsigned int,void *)::$_2>)::{lambda(void *,void *)#1}::__invoke(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  *a1 = *a2;
  return result;
}

__n128 caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<LocalMIDIReceiver::connectEndpoint(unsigned int,void *)::$_2>(caulk::inplace_function_detail::wrapper<LocalMIDIReceiver::connectEndpoint(unsigned int,void *)::$_2>)::{lambda(void *,void *)#2}::__invoke(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  *a1 = *a2;
  return result;
}

uint64_t caulk::inplace_function_detail::vtable<void,MIDI::LegacyPacketList const*>::vtable<LocalMIDIReceiver::connectEndpoint(unsigned int,void *)::$_1>(caulk::inplace_function_detail::wrapper<LocalMIDIReceiver::connectEndpoint(unsigned int,void *)::$_1>)::{lambda(void *,MIDI::LegacyPacketList const*&&)#1}::__invoke(_QWORD *a1, _QWORD *a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*a1 + 16))(*a1, *a2, a1[1]);
}

__n128 caulk::inplace_function_detail::vtable<void,MIDI::LegacyPacketList const*>::vtable<LocalMIDIReceiver::connectEndpoint(unsigned int,void *)::$_1>(caulk::inplace_function_detail::wrapper<LocalMIDIReceiver::connectEndpoint(unsigned int,void *)::$_1>)::{lambda(void *,void *)#1}::__invoke(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  *a1 = *a2;
  return result;
}

__n128 caulk::inplace_function_detail::vtable<void,MIDI::LegacyPacketList const*>::vtable<LocalMIDIReceiver::connectEndpoint(unsigned int,void *)::$_1>(caulk::inplace_function_detail::wrapper<LocalMIDIReceiver::connectEndpoint(unsigned int,void *)::$_1>)::{lambda(void *,void *)#2}::__invoke(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  *a1 = *a2;
  return result;
}

void LocalMIDIReceiverList::Add(uint64_t a1, int a2, int a3, int a4, const void *a5, const void *a6)
{
  uint64_t v12;
  int v13;
  uint64_t v14;
  unsigned int *v15;
  unsigned int v16;
  unint64_t v17;
  uint64_t *v18;
  _QWORD *v19;
  uint64_t *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  uint64_t *v26;
  uint64_t v27;
  unsigned int v28;

  v12 = a1 + 24;
  v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 24) + 16))(a1 + 24);
  v14 = operator new();
  *(_DWORD *)v14 = a2;
  *(_DWORD *)(v14 + 4) = a3;
  *(_DWORD *)(v14 + 8) = a4;
  *(_QWORD *)(v14 + 16) = _Block_copy(a5);
  *(_QWORD *)(v14 + 24) = _Block_copy(a6);
  *(_QWORD *)(v14 + 32) = 0;
  v15 = (unsigned int *)(a1 + 112);
  *(_QWORD *)(v14 + 40) = 0;
  *(_QWORD *)(v14 + 48) = 0;
  do
    v16 = __ldaxr(v15);
  while (__stlxr(v16 + 1, v15));
  while (*(_DWORD *)(a1 + 116))
    usleep(0x1F4u);
  v18 = *(uint64_t **)(a1 + 8);
  v17 = *(_QWORD *)(a1 + 16);
  if ((unint64_t)v18 >= v17)
  {
    v20 = *(uint64_t **)a1;
    v21 = ((uint64_t)v18 - *(_QWORD *)a1) >> 3;
    v22 = v21 + 1;
    if ((unint64_t)(v21 + 1) >> 61)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v23 = v17 - (_QWORD)v20;
    if (v23 >> 2 > v22)
      v22 = v23 >> 2;
    if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8)
      v24 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v24 = v22;
    if (v24)
    {
      if (v24 >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v25 = (char *)operator new(8 * v24);
    }
    else
    {
      v25 = 0;
    }
    v26 = (uint64_t *)&v25[8 * v21];
    *v26 = v14;
    v19 = v26 + 1;
    if (v18 != v20)
    {
      do
      {
        v27 = *--v18;
        *--v26 = v27;
      }
      while (v18 != v20);
      v18 = *(uint64_t **)a1;
    }
    *(_QWORD *)a1 = v26;
    *(_QWORD *)(a1 + 8) = v19;
    *(_QWORD *)(a1 + 16) = &v25[8 * v24];
    if (v18)
      operator delete(v18);
  }
  else
  {
    *v18 = v14;
    v19 = v18 + 1;
  }
  *(_QWORD *)(a1 + 8) = v19;
  do
    v28 = __ldaxr(v15);
  while (__stlxr(v28 - 1, v15));
  if (v13)
    (*(void (**)(uint64_t))(*(_QWORD *)v12 + 24))(v12);
}

void sub_1D4EDC42C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  int v2;

  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

uint64_t LocalMIDIReceiverList::Remove(LocalMIDIReceiverList *this, int a2)
{
  char *v4;
  uint64_t result;
  int v6;
  const void ***i;
  const void **v8;
  unsigned int *v9;
  unsigned int v10;
  const void ***v11;
  int64_t v12;
  unsigned int v13;

  v4 = (char *)this + 24;
  result = (*(uint64_t (**)(char *))(*((_QWORD *)this + 3) + 16))((char *)this + 24);
  v6 = result;
  for (i = *(const void ****)this; i != *((const void ****)this + 1); ++i)
  {
    v8 = *i;
    if (*((_DWORD *)*i + 1) == a2)
    {
      v9 = (unsigned int *)((char *)this + 112);
      do
        v10 = __ldaxr(v9);
      while (__stlxr(v10 + 1, v9));
      while (*((_DWORD *)this + 29))
        result = usleep(0x1F4u);
      v11 = (const void ***)*((_QWORD *)this + 1);
      v12 = (char *)v11 - (char *)(i + 1);
      if (v11 != i + 1)
        result = (uint64_t)memmove(i, i + 1, (char *)v11 - (char *)(i + 1));
      *((_QWORD *)this + 1) = (char *)i + v12;
      if (v8)
      {
        LocalMIDIReceiver::~LocalMIDIReceiver(v8);
        result = MEMORY[0x1D826BA98]();
      }
      do
        v13 = __ldaxr(v9);
      while (__stlxr(v13 - 1, v9));
      break;
    }
  }
  if (v6)
    return (*(uint64_t (**)(char *))(*(_QWORD *)v4 + 24))(v4);
  return result;
}

void sub_1D4EDC594(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  int v2;

  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

void LocalMIDIReceiverList::ReceiverConnectEndpoint(LocalMIDIReceiverList *this, int a2, int a3, void *a4, int a5)
{
  char *v10;
  int v11;
  int64x2_t **i;
  int64x2_t *v13;
  unsigned int *v14;
  unsigned int v15;
  _DWORD *v16;
  _DWORD *v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  unint64_t v35;
  char *v36;
  char *v37;
  unint64_t v38;
  uint64_t v39;
  char *v40;
  int v41;
  uint64_t v42;
  int64x2_t v43;
  char *v44;
  char *v45;
  uint64_t v46;
  unsigned int v47;
  uint64_t (**v48)();
  _QWORD v49[6];
  uint64_t (**v50)();
  _QWORD v51[7];

  v51[6] = *MEMORY[0x1E0C80C00];
  v10 = (char *)this + 24;
  v11 = (*(uint64_t (**)(char *))(*((_QWORD *)this + 3) + 16))((char *)this + 24);
  for (i = *(int64x2_t ***)this; i != *((int64x2_t ***)this + 1); ++i)
  {
    v13 = *i;
    if ((*i)->i32[1] == a2)
    {
      v14 = (unsigned int *)((char *)this + 112);
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 + 1, v14));
      while (*((_DWORD *)this + 29))
        usleep(0x1F4u);
      if (a5)
      {
        v16 = (_DWORD *)v13[2].i64[0];
        v17 = (_DWORD *)v13[2].i64[1];
        if (v16 != v17)
        {
          while (*v16 != a3)
          {
            v16 += 4;
            if (v16 == v17)
              goto LABEL_20;
          }
        }
        if (v16 == v17)
        {
LABEL_20:
          v20 = v13[1].i64[0];
          if (v20)
          {
            v48 = caulk::inplace_function<void ()(MIDI::LegacyPacketList const*),48ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<LocalMIDIReceiver::connectEndpoint(unsigned int,void *)::$_1>;
            v49[0] = v20;
            v49[1] = a4;
            v21 = (_QWORD *)operator new();
            v50 = caulk::inplace_function<void ()(MIDI::LegacyPacketList const*),48ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<LocalMIDIReceiver::connectEndpoint(unsigned int,void *)::$_1>;
            caulk::inplace_function_detail::vtable<void,MIDI::LegacyPacketList const*>::vtable<LocalMIDIReceiver::connectEndpoint(unsigned int,void *)::$_1>(caulk::inplace_function_detail::wrapper<LocalMIDIReceiver::connectEndpoint(unsigned int,void *)::$_1>)::{lambda(void *,void *)#1}::__invoke((__n128 *)v51, (__n128 *)v49);
            v22 = (uint64_t)v50;
            v50 = (uint64_t (**)())&caulk::inplace_function_detail::vtable<void,MIDI::LegacyPacketList const*>::empty;
            *v21 = &off_1E98B9EC8;
            v21[1] = v22;
            (*(void (**)(_QWORD *, _QWORD *))(v22 + 16))(v21 + 2, v51);
            bzero(v21 + 8, 0x300uLL);
            ((void (*)(_QWORD *))v50[3])(v51);
            ((void (*)(_QWORD *))v48[3])(v49);
          }
          else
          {
            v27 = v13->i32[2];
            v28 = v13[1].i64[1];
            v50 = caulk::inplace_function<void ()(MIDI::EventList const*),48ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<LocalMIDIReceiver::connectEndpoint(unsigned int,void *)::$_2>;
            v51[0] = v28;
            v51[1] = a4;
            MIDI::EventListDeliverer::create(&v48, v27, (uint64_t *)&v50);
            v21 = v48;
            v48 = 0;
            ((void (*)(_QWORD *))v50[3])(v51);
          }
          v30 = v13[2].u64[1];
          v29 = v13[3].u64[0];
          if (v30 >= v29)
          {
            v31 = v13[2].i64[0];
            v32 = (uint64_t)(v30 - v31) >> 4;
            v33 = v32 + 1;
            if ((unint64_t)(v32 + 1) >> 60)
              std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
            v34 = v29 - v31;
            if (v34 >> 3 > v33)
              v33 = v34 >> 3;
            if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF0)
              v35 = 0xFFFFFFFFFFFFFFFLL;
            else
              v35 = v33;
            if (v35 >> 60)
              std::__throw_bad_array_new_length[abi:ne180100]();
            v36 = (char *)operator new(16 * v35);
            v37 = &v36[16 * v32];
            *(_DWORD *)v37 = a3;
            *((_QWORD *)v37 + 1) = v21;
            v39 = v13[2].i64[0];
            v38 = v13[2].u64[1];
            if (v38 == v39)
            {
              v43 = vdupq_n_s64(v38);
              v40 = &v36[16 * v32];
            }
            else
            {
              v40 = &v36[16 * v32];
              do
              {
                v41 = *(_DWORD *)(v38 - 16);
                v38 -= 16;
                *((_DWORD *)v40 - 4) = v41;
                v40 -= 16;
                v42 = *(_QWORD *)(v38 + 8);
                *(_QWORD *)(v38 + 8) = 0;
                *((_QWORD *)v40 + 1) = v42;
              }
              while (v38 != v39);
              v43 = v13[2];
            }
            v18 = v37 + 16;
            v13[2].i64[0] = (uint64_t)v40;
            v13[2].i64[1] = (uint64_t)(v37 + 16);
            v13[3].i64[0] = (uint64_t)&v36[16 * v35];
            v45 = (char *)v43.i64[1];
            v44 = (char *)v43.i64[0];
            while (v45 != v44)
            {
              v46 = *((_QWORD *)v45 - 1);
              *((_QWORD *)v45 - 1) = 0;
              if (v46)
                (*(void (**)(uint64_t))(*(_QWORD *)v46 + 8))(v46);
              v45 -= 16;
            }
            if (v44)
              operator delete(v44);
          }
          else
          {
            *(_DWORD *)v30 = a3;
            *(_QWORD *)(v30 + 8) = v21;
            v18 = (char *)(v30 + 16);
          }
LABEL_59:
          v13[2].i64[1] = (uint64_t)v18;
        }
      }
      else
      {
        v18 = (char *)v13[2].i64[0];
        v19 = v13[2].i64[1];
        while (v18 != (char *)v19)
        {
          if (*(_DWORD *)v18 == a3)
          {
            if (v18 != (char *)v19)
            {
              v23 = v18 + 16;
              if (v18 + 16 != (char *)v19)
              {
                do
                {
                  if (*(_DWORD *)v23 != a3)
                  {
                    *(_DWORD *)v18 = *(_DWORD *)v23;
                    v24 = *((_QWORD *)v23 + 1);
                    *((_QWORD *)v23 + 1) = 0;
                    v25 = *((_QWORD *)v18 + 1);
                    *((_QWORD *)v18 + 1) = v24;
                    if (v25)
                      (*(void (**)(uint64_t))(*(_QWORD *)v25 + 8))(v25);
                    v18 += 16;
                  }
                  v23 += 16;
                }
                while (v23 != (char *)v19);
                v19 = v13[2].i64[1];
              }
            }
            if (v18 != (char *)v19)
            {
              while ((char *)v19 != v18)
              {
                v26 = *(_QWORD *)(v19 - 8);
                *(_QWORD *)(v19 - 8) = 0;
                if (v26)
                  (*(void (**)(uint64_t))(*(_QWORD *)v26 + 8))(v26);
                v19 -= 16;
              }
              goto LABEL_59;
            }
            goto LABEL_60;
          }
          v18 += 16;
        }
      }
      do
LABEL_60:
        v47 = __ldaxr(v14);
      while (__stlxr(v47 - 1, v14));
      break;
    }
  }
  if (v11)
    (*(void (**)(char *))(*(_QWORD *)v10 + 24))(v10);
}

void sub_1D4EDC9F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

uint64_t *MIDIProcess::defaultInstance(MIDIProcess *this)
{
  unsigned __int8 v1;
  unsigned __int8 v2;
  unsigned __int8 v4;
  MIDIProcessMIG *v5;
  uint64_t *v6;
  __guard *v7;
  MIDIProcessXPC *v8;

  {
    MIDIProcess::defaultInstance(int)::cachedVersion = CoreMIDIServerImplVersion();
  }
  if (MIDIProcess::defaultInstance(int)::cachedVersion == 1)
  {
    if ((v2 & 1) != 0)
      return &MIDIProcess::defaultInstance(int)::migImpl;
    if (!(_DWORD)v5)
      return &MIDIProcess::defaultInstance(int)::migImpl;
    MIDIProcessMIG::MIDIProcessMIG(v5);
    v6 = &MIDIProcess::defaultInstance(int)::migImpl;
  }
  else
  {
    if ((v4 & 1) != 0)
      return MIDIProcess::defaultInstance(int)::xpcImpl;
    if (!(_DWORD)v8)
      return MIDIProcess::defaultInstance(int)::xpcImpl;
    MIDIProcessXPC::MIDIProcessXPC(v8);
    v6 = MIDIProcess::defaultInstance(int)::xpcImpl;
  }
  __cxa_guard_release(v7);
  return v6;
}

void sub_1D4EDCBAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void MIDIProcess::~MIDIProcess(MIDIProcess *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;

  *(_QWORD *)this = off_1E98B7E50;
  TCFDictionaryBase::~TCFDictionaryBase((const void **)this + 49);
  TCFDictionaryBase::~TCFDictionaryBase((const void **)this + 48);
  *((_QWORD *)this + 36) = &off_1E98B9D98;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 312));
  LocalMIDIReceiverList::~LocalMIDIReceiverList((MIDIProcess *)((char *)this + 168));
  v5 = (void **)((char *)this + 144);
  std::vector<std::shared_ptr<LocalMIDIClient>>::__destroy_vector::operator()[abi:ne180100](&v5);
  *((_QWORD *)this + 7) = &off_1E98B9D98;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 80));
  v2 = *((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  std::unique_ptr<XClientMachPort>::reset[abi:ne180100]((mach_port_name_t **)this + 3, 0);
  std::unique_ptr<XServerMachPort>::reset[abi:ne180100]((mach_port_name_t **)this + 2, 0);
}

void MIDIProcess::WriteOutput<MIDI::LegacyPacketList>(uint64_t a1, uint64_t *a2, unsigned int *a3)
{
  uint64_t v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  unsigned int *v13;
  uint64_t (**v14)();
  __int128 v15;
  _BYTE msg[28];
  uint64_t v17;
  unsigned int v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD v21[128];

  v21[127] = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1 + 48);
  os_unfair_lock_lock((os_unfair_lock_t)(v6 + 100));
  v11 = *a2;
  v12 = 1;
  v14 = caulk::inplace_function<void ()(MIDI::EventList const*),48ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<MIDIIORingBufferWriter::copyPacketList(PacketHeader &,MIDIPacketList const*)::{lambda(MIDI::EventList const*)#1}>;
  *(_QWORD *)&v15 = v6;
  *((_QWORD *)&v15 + 1) = &v11;
  *(_QWORD *)msg = caulk::inplace_function<void ()(MIDI::EventList const*),48ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<MIDIIORingBufferWriter::copyPacketList(PacketHeader &,MIDIPacketList const*)::{lambda(MIDI::EventList const*)#1}>;
  *(_OWORD *)&msg[8] = v15;
  v20 = 1;
  v19 = v21;
  v13 = (unsigned int *)msg;
  MIDI::LegacyPacketList::traverse<MIDI::MIDIPacketList_to_MIDIEventList(MIDIPacketList const*,caulk::inplace_function<void ()(MIDI::EventList const*),48ul,8ul,caulk::inplace_function_detail::vtable>)::{lambda(MIDIPacket const*)#1}>(a3, &v13);
  MIDI::PacketizerBase<MIDI::EventList>::~PacketizerBase((uint64_t)msg);
  ((void (*)(__int128 *))v14[3])(&v15);
  v7 = (unsigned int *)(*(_QWORD *)(v6 + 88) + 20);
  do
    v8 = __ldaxr(v7);
  while (__stlxr(v8 | 1, v7));
  os_unfair_lock_unlock((os_unfair_lock_t)(v6 + 100));
  if (!v8)
  {
    v9 = atomic_load((unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 88) + 8));
    v10 = **(_DWORD **)(a1 + 24);
    *(_QWORD *)msg = 0x2800000013;
    *(_DWORD *)&msg[8] = v10;
    *(_QWORD *)&msg[20] = 0;
    *(_QWORD *)&msg[12] = 0;
    v17 = 0x400000001;
    v18 = v9;
    mach_msg((mach_msg_header_t *)msg, 1, 0x28u, 0, 0, 0, 0);
  }
}

void sub_1D4EDCE3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
  _Unwind_Resume(exception_object);
}

void caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<MIDIIORingBufferWriter::copyPacketList(PacketHeader &,MIDIPacketList const*)::{lambda(MIDI::EventList const*)#1}>(caulk::inplace_function_detail::wrapper<MIDIIORingBufferWriter::copyPacketList(PacketHeader &,MIDIPacketList const*)::{lambda(MIDI::EventList const*)#1}>)::{lambda(void *,MIDI::EventList const*&&)#1}::__invoke(int8x16_t *a1, uint64_t *a2)
{
  uint64_t v2;
  int8x16_t v3;

  v2 = *a2;
  v3 = vextq_s8(*a1, *a1, 8uLL);
  _ZN4MIDI9EventList8traverseIZN22MIDIIORingBufferWriter14copyPacketListER12PacketHeaderPK13MIDIEventListEUlPKT_E_EEvS7_OS8_(v2, v3.i64);
}

__n128 caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<MIDIIORingBufferWriter::copyPacketList(PacketHeader &,MIDIPacketList const*)::{lambda(MIDI::EventList const*)#1}>(caulk::inplace_function_detail::wrapper<MIDIIORingBufferWriter::copyPacketList(PacketHeader &,MIDIPacketList const*)::{lambda(MIDI::EventList const*)#1}>)::{lambda(void *,void *)#1}::__invoke(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  *a1 = *a2;
  return result;
}

__n128 caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<MIDIIORingBufferWriter::copyPacketList(PacketHeader &,MIDIPacketList const*)::{lambda(MIDI::EventList const*)#1}>(caulk::inplace_function_detail::wrapper<MIDIIORingBufferWriter::copyPacketList(PacketHeader &,MIDIPacketList const*)::{lambda(MIDI::EventList const*)#1}>)::{lambda(void *,void *)#2}::__invoke(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  *a1 = *a2;
  return result;
}

void _ZN4MIDI9EventList8traverseIZN22MIDIIORingBufferWriter14copyPacketListER12PacketHeaderPK13MIDIEventListEUlPKT_E_EEvS7_OS8_(uint64_t a1, uint64_t *a2)
{
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  unint64_t v9;
  unint64_t i;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  __int16 v14;

  if (*(_DWORD *)(a1 + 4))
  {
    v4 = 0;
    v5 = a1 + 8;
    do
    {
      v6 = *a2;
      v7 = a2[1];
      *(_QWORD *)(v6 + 8) = *(_QWORD *)v5;
      *(_WORD *)(v6 + 18) = 0;
      v8 = (char *)(v5 + 12);
      v9 = *(unsigned int *)(v5 + 8);
      if (v9 < 0xFB)
      {
        v14 = 4 * v9;
      }
      else
      {
        do
        {
          for (i = 0;
                i < 0xFB;
                i += MIDI::UniversalPacket::word_sizes[(unint64_t)*(unsigned int *)&v8[4 * i] >> 28])
          {
            v11 = i;
            if (i >= v9)
              break;
          }
          if (v11 >= v9)
            v12 = v9;
          else
            v12 = v11;
          *(_WORD *)(v6 + 18) = 4 * v12;
          MIDIIORingBufferWriter::writePacket2(v7, (char *)v6, v8);
          v13 = &v8[4 * v9];
          v9 -= v12;
          v8 = &v13[-4 * v9];
          v14 = 4 * v9;
        }
        while (4 * v9 > 0x3E8);
      }
      *(_WORD *)(v6 + 18) = v14;
      MIDIIORingBufferWriter::writePacket2(v7, (char *)v6, v8);
      v5 += 4 * *(unsigned int *)(v5 + 8) + 12;
      ++v4;
    }
    while (v4 < *(_DWORD *)(a1 + 4));
  }
}

uint64_t MIDIProcess::WriteOutput<MIDI::EventList>(uint64_t a1, uint64_t *a2, __int16 a3, uint64_t a4)
{
  uint64_t result;
  unsigned int v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  result = MIDIIORingBufferWriter::writePacketList<MIDI::EventList>(*(_QWORD *)(a1 + 48), a2, a3, a4);
  if ((_DWORD)result)
  {
    v6 = atomic_load((unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 88) + 8));
    v7 = **(_DWORD **)(a1 + 24);
    v8 = 0x2800000013;
    v9 = v7;
    v11 = 0;
    v10 = 0;
    v12 = 0x400000001;
    v13 = v6;
    return mach_msg((mach_msg_header_t *)&v8, 1, 0x28u, 0, 0, 0, 0);
  }
  return result;
}

BOOL MIDIIORingBufferWriter::writePacketList<MIDI::EventList>(uint64_t a1, uint64_t *a2, __int16 a3, uint64_t a4)
{
  os_unfair_lock_s *v8;
  unsigned int *v9;
  unsigned int v10;
  _BOOL8 v11;
  uint64_t v13;
  __int16 v14;
  uint64_t v15[2];

  v8 = (os_unfair_lock_s *)(a1 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 100));
  v13 = *a2;
  v14 = a3;
  v15[0] = (uint64_t)&v13;
  v15[1] = a1;
  _ZN4MIDI9EventList8traverseIZN22MIDIIORingBufferWriter14copyPacketListER12PacketHeaderPK13MIDIEventListEUlPKT_E_EEvS7_OS8_(a4, v15);
  v9 = (unsigned int *)(*(_QWORD *)(a1 + 88) + 20);
  do
    v10 = __ldaxr(v9);
  while (__stlxr(v10 | 1, v9));
  v11 = v10 == 0;
  os_unfair_lock_unlock(v8);
  return v11;
}

void sub_1D4EDD13C(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t MIDIProcess::Notify(char **this, const UniChar *a2, size_t a3)
{
  char v6;
  ObjectTreeCache *v7;
  size_t v8;
  size_t v9;
  char *v10;
  unint64_t v11;
  size_t v12;
  void *v13;
  const void *v14;
  unint64_t v15;
  size_t v16;
  int v17;
  uint64_t v18;
  NSObject *v19;
  const char *v20;
  uint32_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _DWORD __dst[4];
  CFTypeRef cf;
  char *v34;
  char *v35;
  uint64_t v36;
  _BYTE buf[12];
  __int16 v38;
  int v39;
  __int16 v40;
  int v41;
  __int16 v42;
  CFTypeRef v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v34 = 0;
  v35 = 0;
  v36 = 0;
  LocalClientList::Copy(this + 7, &v34);
  if (a3)
  {
    v6 = 0;
    v7 = (ObjectTreeCache *)(this + 36);
    do
    {
      v8 = *((unsigned int *)a2 + 1);
      if (a3 < v8)
      {
LABEL_38:
        v30 = 4294956458;
        goto LABEL_39;
      }
      memcpy(__dst, a2, v8);
      v9 = a3 - *((unsigned int *)a2 + 1);
      v10 = (char *)a2 + a3;
      a2 = (const UniChar *)((char *)a2 + *((unsigned int *)a2 + 1));
      if ((__dst[0] - 4096) >= 3)
      {
        if (__dst[0] != 4)
        {
          a3 = v9;
          goto LABEL_12;
        }
        v15 = *(unsigned int *)a2;
        v16 = v9 - 4;
        a3 = v16 - v15;
        if (v16 < v15)
          goto LABEL_38;
        cf = CFStringCreateWithCharacters(0, a2 + 2, v15 >> 1);
      }
      else
      {
        v11 = *(unsigned int *)a2;
        v12 = v9 - 4;
        a3 = v12 - v11;
        if (v12 < v11)
          goto LABEL_38;
        objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytesNoCopy:length:freeWhenDone:", a2 + 2);
        v13 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(MEMORY[0x1E0CB3710], "unarchiveObjectWithData:", v13);
        v14 = (const void *)objc_claimAutoreleasedReturnValue();

        cf = v14;
      }
      a2 = (const UniChar *)&v10[-a3];
LABEL_12:
      v17 = __dst[0];
      if (!(((__dst[0] - 4) < 0xFFFFFFFD) | v6 & 1))
      {
        ObjectTreeCache::Invalidate(v7);
        v6 = 1;
        v17 = __dst[0];
      }
      switch(v17)
      {
        case 1:
          gMIDIClientLog();
          v18 = gMIDIClientLog(void)::clilib;
          if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)&buf[4] = "MIDIProcess.cpp";
            v38 = 1024;
            v39 = 361;
            v19 = v18;
            v20 = "%25s:%-5d kMIDIMsgSetupChanged";
            v21 = 18;
            goto LABEL_26;
          }
          break;
        case 2:
          gMIDIClientLog();
          v23 = gMIDIClientLog(void)::clilib;
          if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = "MIDIProcess.cpp";
            v38 = 1024;
            v39 = 365;
            v40 = 1024;
            v41 = (int)cf;
            v19 = v23;
            v20 = "%25s:%-5d kMIDIMsgObjectAdded: 0x%x";
            goto LABEL_23;
          }
          break;
        case 3:
          gMIDIClientLog();
          v24 = gMIDIClientLog(void)::clilib;
          if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = "MIDIProcess.cpp";
            v38 = 1024;
            v39 = 369;
            v40 = 1024;
            v41 = (int)cf;
            v19 = v24;
            v20 = "%25s:%-5d kMIDIMsgObjectRemoved: 0x%x";
            goto LABEL_23;
          }
          break;
        case 4:
          gMIDIClientLog();
          v25 = gMIDIClientLog(void)::clilib;
          if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136315906;
            *(_QWORD *)&buf[4] = "MIDIProcess.cpp";
            v38 = 1024;
            v39 = 374;
            v40 = 1024;
            v41 = __dst[2];
            v42 = 2112;
            v43 = cf;
            v19 = v25;
            v20 = "%25s:%-5d kMIDIMsgPropertyChanged: 0x%x %@";
            v21 = 34;
            goto LABEL_26;
          }
          break;
        default:
          gMIDIClientLog();
          v22 = gMIDIClientLog(void)::clilib;
          if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = "MIDIProcess.cpp";
            v38 = 1024;
            v39 = 378;
            v40 = 1024;
            v41 = __dst[0];
            v19 = v22;
            v20 = "%25s:%-5d MIDI notification %d";
LABEL_23:
            v21 = 24;
LABEL_26:
            _os_log_impl(&dword_1D4E88000, v19, OS_LOG_TYPE_DEBUG, v20, buf, v21);
          }
          break;
      }
      v26 = v34;
      v27 = v35;
      while (v26 != v27)
      {
        v28 = *(_QWORD *)v26;
        if (__dst[0] < 4096 || *(_BYTE *)(v28 + 16))
        {
          v29 = *(_QWORD *)(v28 + 8);
          if (v29)
            (*(void (**)(uint64_t, _DWORD *))(v29 + 16))(v29, __dst);
        }
        v26 += 16;
      }
      if (__dst[0] == 4)
        CFRelease(cf);
    }
    while (a3);
  }
  v30 = 0;
LABEL_39:
  *(_QWORD *)buf = &v34;
  std::vector<std::shared_ptr<LocalMIDIClient>>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
  return v30;
}

void sub_1D4EDD59C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,void **a21)
{
  a21 = (void **)&a18;
  std::vector<std::shared_ptr<LocalMIDIClient>>::__destroy_vector::operator()[abi:ne180100](&a21);
  _Unwind_Resume(a1);
}

void ObjectTreeCache::Invalidate(ObjectTreeCache *this)
{
  int v2;
  const void *v3;

  v2 = (*(uint64_t (**)(ObjectTreeCache *))(*(_QWORD *)this + 16))(this);
  v3 = (const void *)*((_QWORD *)this + 11);
  if (v3)
  {
    CFRelease(v3);
    *((_QWORD *)this + 11) = 0;
  }
  if (v2)
    (*(void (**)(ObjectTreeCache *))(*(_QWORD *)this + 24))(this);
}

void sub_1D4EDD630(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  int v2;

  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

void MIDIProcess::createInPort(mach_port_name_t **this)
{
  mach_port_name_t *v2;
  ipc_space_t *v3;
  NSObject *v4;
  int v5;
  const char *v6;
  __int16 v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v2 = (mach_port_name_t *)operator new();
  v3 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
  if (!mach_port_allocate(*MEMORY[0x1E0C83DA0], 1u, v2))
  {
    if (!mach_port_insert_right(*v3, *v2, *v2, 0x14u))
    {
      std::unique_ptr<XServerMachPort>::reset[abi:ne180100](this + 2, v2);
      return;
    }
    mach_port_mod_refs(*v3, *v2, 1u, -1);
  }
  std::unique_ptr<XServerMachPort>::reset[abi:ne180100](this + 2, v2);
  gMIDIClientLog();
  v4 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_ERROR))
  {
    v5 = 136315394;
    v6 = "MIDIProcess.cpp";
    v7 = 1024;
    v8 = 403;
    _os_log_impl(&dword_1D4E88000, v4, OS_LOG_TYPE_ERROR, "%25s:%-5d Couldn't create MIDI In Port; CoreMIDI will not be usable",
      (uint8_t *)&v5,
      0x12u);
  }
}

void sub_1D4EDD7B8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D826BA98](v1, 0x1000C4052888210);
  _Unwind_Resume(a1);
}

void MIDIProcess::createInThread(MIDIProcess *this)
{
  uint64_t v2;
  unsigned int v3;
  BOOL v4;
  BOOL v5;
  const char *v6;
  uint64_t v7;
  NSObject *v8;
  pid_t v9;
  uint64_t v10;
  int v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  MIDIProcess *v16;
  __int16 v17;
  pid_t v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v2 = operator new();
  *(_QWORD *)v2 = off_1E98B9DE0;
  CADeprecated::CAPThread::CAPThread((CADeprecated::CAPThread *)v2, (void *(*)(void *))v2, (void *)0x1F, v3, v4, v5, v6);
  *(_QWORD *)(v2 + 128) = "MIDIInPortThread";
  *(_WORD *)(v2 + 136) = 0;
  *(_QWORD *)v2 = &off_1E98B9B60;
  *(_QWORD *)(v2 + 144) = this;
  CADeprecated::CAPThread::SetTimeConstraints((CADeprecated::CAPThread *)v2, 0, 6000, 12000, 1);
  CADeprecated::CAPThread::Start(v2);
  while (!*(_BYTE *)(v2 + 137))
    usleep(0x2710u);
  v7 = *((_QWORD *)this + 4);
  *((_QWORD *)this + 4) = v2;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  gMIDIClientLog();
  v8 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_INFO))
  {
    v9 = getpid();
    v10 = *((_QWORD *)this + 4);
    v11 = 136316162;
    v12 = "MIDIProcess.cpp";
    v13 = 1024;
    v14 = 417;
    v15 = 2048;
    v16 = this;
    v17 = 1024;
    v18 = v9;
    v19 = 2048;
    v20 = v10;
    _os_log_impl(&dword_1D4E88000, v8, OS_LOG_TYPE_INFO, "%25s:%-5d [+] MIDIProcess(%p)::Initialize() - pid %d, MIDI In thread %p", (uint8_t *)&v11, 0x2Cu);
  }
}

void sub_1D4EDD958(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1D826BA98](v1, 0x10F1C40D853C79DLL);
  _Unwind_Resume(a1);
}

void MIDIProcess::createOutPort(mach_port_name_t **this)
{
  mach_port_name_t *v2;
  NSObject *v3;
  mach_port_t special_port;
  const char *v5;
  __int16 v6;
  int v7;
  __int16 v8;
  const char *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  special_port = 0;
  task_get_special_port(*MEMORY[0x1E0C83DA0], 4, &special_port);
  if (bootstrap_look_up2())
  {
    v2 = 0;
  }
  else
  {
    v2 = (mach_port_name_t *)operator new();
    *v2 = 0;
  }
  std::unique_ptr<XClientMachPort>::reset[abi:ne180100](this + 3, v2);
  if (!this[3])
  {
    gMIDIClientLog();
    v3 = gMIDIClientLog(void)::clilib;
    if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_ERROR))
    {
      special_port = 136315650;
      v5 = "MIDIProcess.cpp";
      v6 = 1024;
      v7 = 432;
      v8 = 2080;
      v9 = "com.apple.midiserver.io";
      _os_log_impl(&dword_1D4E88000, v3, OS_LOG_TYPE_ERROR, "%25s:%-5d Couldn't connect to %s; CoreMIDI will not be usable",
        (uint8_t *)&special_port,
        0x1Cu);
    }
  }
}

void MIDIProcess::setupIOBuffers(MIDIProcess *this)
{
  pid_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char __str[64];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v2 = getpid();
  v3 = operator new();
  *(_QWORD *)(v3 + 16) = 0;
  *(_QWORD *)(v3 + 24) = 0;
  *(_DWORD *)(v3 + 36) = 0;
  *(_BYTE *)(v3 + 40) = 0;
  *(_OWORD *)(v3 + 44) = 0u;
  *(_OWORD *)(v3 + 60) = 0u;
  *(_QWORD *)(v3 + 88) = 0;
  *(_DWORD *)(v3 + 96) = 2;
  *(_QWORD *)v3 = &off_1E98B9A08;
  *(_QWORD *)(v3 + 8) = 0;
  v4 = *((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = v3;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
  snprintf(__str, 0x40uLL, "Apple MIDI %s %d", "in", v2);
  MIDIIORingBufferBase::Init(*((MIDIIORingBufferBase **)this + 5), 0, __str);
  v5 = operator new();
  *(_QWORD *)(v5 + 16) = 0;
  *(_QWORD *)(v5 + 24) = 0;
  *(_DWORD *)(v5 + 36) = 0;
  *(_BYTE *)(v5 + 40) = 0;
  *(_OWORD *)(v5 + 44) = 0u;
  *(_OWORD *)(v5 + 60) = 0u;
  *(_QWORD *)(v5 + 88) = 0;
  *(_DWORD *)(v5 + 96) = 0;
  *(_QWORD *)v5 = &off_1E98B9A28;
  *(_QWORD *)(v5 + 8) = 0;
  *(_QWORD *)(v5 + 144) = 0;
  *(_OWORD *)(v5 + 100) = 0u;
  *(_OWORD *)(v5 + 116) = 0u;
  *(_QWORD *)(v5 + 132) = 0;
  v6 = *((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = v5;
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  snprintf(__str, 0x40uLL, "Apple MIDI %s %d", "out", v2);
  MIDIIORingBufferBase::Init(*((MIDIIORingBufferBase **)this + 6), 0, __str);
}

void MIDIIORingBufferWriter::~MIDIIORingBufferWriter(MIDIIORingBufferWriter *this)
{
  void *v2;

  *(_QWORD *)this = &off_1E98B9A28;
  v2 = (void *)*((_QWORD *)this + 13);
  if (v2)
  {
    *((_QWORD *)this + 14) = v2;
    operator delete(v2);
  }
  MIDIRingBuffer::~MIDIRingBuffer(this);
}

{
  void *v2;

  *(_QWORD *)this = &off_1E98B9A28;
  v2 = (void *)*((_QWORD *)this + 13);
  if (v2)
  {
    *((_QWORD *)this + 14) = v2;
    operator delete(v2);
  }
  MIDIRingBuffer::~MIDIRingBuffer(this);
  JUMPOUT(0x1D826BA98);
}

void MIDIIORingBufferReader::~MIDIIORingBufferReader(MIDIIORingBufferReader *this)
{
  MIDIRingBuffer::~MIDIRingBuffer(this);
  JUMPOUT(0x1D826BA98);
}

void mshRelease(mach_port_name_t *a1)
{
  mach_port_name_t v2;
  ipc_space_t v3;
  mach_port_name_t v4;

  v2 = a1[1];
  if ((v2 & 1) == 0)
  {
    v3 = *MEMORY[0x1E0C83DA0];
    v4 = *a1;
    if ((v2 & 4) == 0)
      mach_port_mod_refs(*MEMORY[0x1E0C83DA0], *a1, 0, -1);
    mach_port_mod_refs(v3, v4, 1u, -1);
  }
  free(a1);
}

CFStringRef mshCopyDescription(unsigned int *a1)
{
  return CFStringCreateWithFormat(0, 0, CFSTR("<MSHRunLoopSource %p> {port = %x, callback = %p}"), a1, *a1, *((_QWORD *)a1 + 2));
}

BOOL mshEqual(_DWORD *a1, _DWORD *a2)
{
  return *a1 == *a2;
}

uint64_t mshHash(unsigned int *a1)
{
  return *a1;
}

uint64_t mshGetPort(unsigned int *a1)
{
  return *a1;
}

CFRunLoopSourceRef MSHCreateMIGServerSource(uint64_t a1, int a2, int a3, uint64_t a4)
{
  int perform_high;
  _DWORD *v8;
  ipc_space_t v9;
  CFRunLoopSourceRef result;
  mach_port_name_t v11;
  ipc_space_t v12;
  kern_return_t inserted;
  CFRunLoopSourceContext v14;

  perform_high = a3;
  HIDWORD(v14.perform) = a3;
  v8 = malloc_type_malloc(0x28uLL, 0x10A0040C7231A41uLL);
  v14.version = 1;
  v14.info = v8;
  v14.retain = 0;
  v14.release = (void (__cdecl *)(const void *))mshRelease;
  v14.copyDescription = (CFStringRef (__cdecl *)(const void *))mshCopyDescription;
  v14.equal = (Boolean (__cdecl *)(const void *, const void *))mshEqual;
  v14.hash = (CFHashCode (__cdecl *)(const void *))mshHash;
  v14.schedule = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))mshGetPort;
  v14.cancel = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))mshMIGPerform;
  v9 = *MEMORY[0x1E0C83DA0];
  if (!perform_high)
  {
    if (mach_port_allocate(*MEMORY[0x1E0C83DA0], 1u, (mach_port_name_t *)&v14.perform + 1))
      goto LABEL_9;
    inserted = mach_port_insert_right(v9, HIDWORD(v14.perform), HIDWORD(v14.perform), 0x14u);
    perform_high = HIDWORD(v14.perform);
    if (inserted)
    {
      v12 = v9;
      v11 = HIDWORD(v14.perform);
      goto LABEL_8;
    }
    a2 = 0;
  }
  *v8 = perform_high;
  v8[1] = a2;
  *((_QWORD *)v8 + 3) = 0;
  *((_QWORD *)v8 + 4) = a1;
  *((_QWORD *)v8 + 1) = a4;
  *((_QWORD *)v8 + 2) = 0;
  result = CFRunLoopSourceCreate(0, 0, &v14);
  if (result)
    return result;
  if ((a2 & 1) == 0)
  {
    mach_port_mod_refs(v9, HIDWORD(v14.perform), 0, -1);
    v11 = HIDWORD(v14.perform);
    v12 = v9;
LABEL_8:
    mach_port_mod_refs(v12, v11, 1u, -1);
  }
LABEL_9:
  free(v8);
  return 0;
}

uint64_t mshMIGPerform(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  int v7;
  int v8;
  int v10;
  mach_msg_header_t *v11;
  int v12;
  void (*v13)(uint64_t, mach_msg_header_t *);
  size_t v14;
  uint64_t v15;
  unsigned int v16;
  mach_port_t msgh_remote_port;
  int v18;
  uint64_t (*v19)(uint64_t, uint64_t, _QWORD);
  uint64_t v20;
  mach_port_mscount_t v21;
  mach_port_name_t v22;
  ipc_space_t v23;
  void (*v24)(uint64_t, _QWORD);
  mach_msg_option_t v25;
  mach_msg_return_t v26;
  FILE *v27;
  pid_t v28;
  uint64_t v30;
  mach_port_t previous;
  mach_port_mscount_t v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a4 + 32);
  v7 = *(_DWORD *)(a1 + 20);
  v8 = *(_DWORD *)(v6 + 8);
  if (*(_DWORD *)(v6 + 12) <= v7 || v7 < v8)
  {
    MEMORY[0x1E0C80A78]();
    v11 = (mach_msg_header_t *)&v30;
    v12 = 0;
    v13 = 0;
  }
  else
  {
    v13 = *(void (**)(uint64_t, mach_msg_header_t *))(v6 + 40 * (v7 - v8) + 40);
    v14 = MEMORY[0x1E0C80A78]();
    v11 = (mach_msg_header_t *)((char *)&previous - v15);
    if (v14 <= 0x2000)
    {
      v12 = 0;
    }
    else
    {
      v11 = (mach_msg_header_t *)malloc_type_malloc(v14, 0xE912E677uLL);
      v10 = *(_DWORD *)(a1 + 20);
      v12 = 1;
    }
  }
  v11->msgh_bits = *(_DWORD *)a1 & 0x1F;
  v16 = *(_DWORD *)(a1 + 8);
  v11->msgh_size = 36;
  *(_QWORD *)&v11->msgh_remote_port = v16;
  v11->msgh_id = v10 + 100;
  if (v13)
  {
    if ((*(_BYTE *)(a4 + 4) & 2) != 0)
      *(_DWORD *)(a1 + 12) = *(_QWORD *)(a4 + 8);
    v13(a1, v11);
    if ((v11->msgh_bits & 0x80000000) != 0)
      goto LABEL_30;
    msgh_remote_port = v11[1].msgh_remote_port;
    if (!msgh_remote_port)
      goto LABEL_30;
    if (msgh_remote_port == -305)
    {
      v11->msgh_remote_port = 0;
LABEL_38:
      if (v12)
        free(v11);
      return 0;
    }
LABEL_28:
    if ((*(_DWORD *)a1 & 0x80000000) != 0)
    {
      *(_DWORD *)(a1 + 8) = 0;
      mach_msg_destroy((mach_msg_header_t *)a1);
    }
LABEL_30:
    if (v11->msgh_remote_port)
    {
      if ((v11->msgh_bits & 0x1F) == 0x12)
        v25 = 1;
      else
        v25 = 17;
      v26 = mach_msg(v11, v25, v11->msgh_size, 0, 0, 0, 0);
      if ((v26 - 268435459) >= 2)
      {
        if (v26)
        {
          v27 = (FILE *)*MEMORY[0x1E0C80C10];
          v28 = getpid();
          fprintf(v27, "%d: badly generated MIG reply for port %x\n", v28, *(_DWORD *)a4);
        }
      }
      else
      {
        mach_msg_destroy(v11);
      }
    }
    goto LABEL_38;
  }
  v18 = *(_DWORD *)(a1 + 20);
  if (v18 == 71)
  {
    v24 = *(void (**)(uint64_t, _QWORD))(a4 + 24);
    if (v24)
      v24(a1, *(_QWORD *)(a4 + 8));
  }
  else
  {
    if (v18 != 70)
    {
      *(_QWORD *)&v11[1].msgh_bits = *MEMORY[0x1E0C804E8];
      v11[1].msgh_remote_port = -303;
      goto LABEL_28;
    }
    v19 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD))(a4 + 16);
    if (v19)
    {
      v20 = *(unsigned int *)(a1 + 32);
      v32 = *(_DWORD *)(a1 + 32);
      if (*(unsigned __int8 *)(a1 + 28) != *(unsigned __int8 *)(MEMORY[0x1E0C804E8] + 4))
        v20 = bswap32(v32);
      v21 = v19(v20, a1, *(_QWORD *)(a4 + 8));
      v32 = v21;
      if (v21)
      {
        previous = 0;
        v22 = *(_DWORD *)a4;
        v23 = *MEMORY[0x1E0C83DA0];
        mach_port_request_notification(*MEMORY[0x1E0C83DA0], v22, 70, v21, v22, 0x15u, &previous);
        if (previous)
          mach_port_mod_refs(v23, previous, 2u, -1);
      }
      else
      {
        *(_QWORD *)(a4 + 16) = 0;
      }
    }
  }
  return 0;
}

void sub_1D4EDE2DC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1D4EDE3E8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1D4EDE48C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1D4EDE5FC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1D4EDE700(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1D4EDE770(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  void *v9;
  void *v10;

  v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)MIDICIDiscoveryManager;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_1D4EDE9C8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t MIDI::EventList::size(MIDI::EventList *this)
{
  char *v1;
  int i;

  v1 = (char *)this + 8;
  for (i = *((_DWORD *)this + 1); i; --i)
    v1 += 4 * *((unsigned int *)v1 + 2) + 12;
  return v1 - (char *)this;
}

_DWORD *MIDI::EventList::create@<X0>(int a1@<W0>, uint64_t a2@<X1>, const void *a3@<X2>, uint64_t a4@<X3>, _QWORD *a5@<X8>)
{
  size_t v10;
  _DWORD *result;

  v10 = 4 * a4;
  result = malloc_type_malloc(4 * a4 + 20, 0x53A9EFB0uLL);
  *a5 = result;
  a5[1] = MIDI::packet_list_deleter;
  *result = a1;
  result[1] = 1;
  *((_QWORD *)result + 1) = a2;
  result[4] = a4;
  if (a4)
    return memmove(result + 5, a3, v10);
  return result;
}

void *MIDI::EventList::create@<X0>(MIDI::EventList *this@<X0>, _QWORD *a2@<X8>)
{
  char *v5;
  int i;
  size_t v7;
  _QWORD *v8;

  v5 = (char *)this + 8;
  for (i = *((_DWORD *)this + 1); i; --i)
    v5 += 4 * *((unsigned int *)v5 + 2) + 12;
  v7 = v5 - (char *)this;
  v8 = malloc_type_malloc(v5 - (char *)this, 0xAF997A63uLL);
  *v8 = *(unsigned int *)this;
  *a2 = v8;
  a2[1] = MIDI::packet_list_deleter;
  return memcpy(v8, this, v7);
}

_QWORD *MIDI::LegacyPacketList::dump(unsigned int *a1)
{
  uint64_t *v1;
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *result;
  unsigned int v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  char v15;
  char v16;

  v1 = (uint64_t *)MEMORY[0x1E0DE4A60];
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E0DE4A60], (uint64_t)"MIDIPacketList @ ", 17);
  v2 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v2, (uint64_t)", ", 2);
  v3 = (_QWORD *)std::ostream::operator<<();
  result = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)" packets:\n", 10);
  if (*a1)
  {
    v5 = 0;
    v6 = (unint64_t)(a1 + 1);
    do
    {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v1, (uint64_t)"  [", 3);
      v7 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)" ", 1);
      v8 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)"] ts ", 5);
      v9 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)", ", 2);
      v10 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)" bytes:", 7);
      if (*(_WORD *)(v6 + 8))
      {
        v11 = 0;
        do
        {
          v16 = 32;
          v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v1, (uint64_t)&v16, 1);
          v13 = *v1;
          *(_DWORD *)((char *)v1 + *(_QWORD *)(*v1 - 24) + 8) = *(_DWORD *)((_BYTE *)v1 + *(_QWORD *)(*v1 - 24) + 8) & 0xFFFFFFB5 | 8;
          *(uint64_t *)((char *)v1 + *(_QWORD *)(v13 - 24) + 24) = 2;
          std::operator<<[abi:ne180100]<std::char_traits<char>>(v12, 48);
          std::ostream::operator<<();
          ++v11;
        }
        while (v11 < *(unsigned __int16 *)(v6 + 8));
      }
      *(_DWORD *)((char *)v1 + *(_QWORD *)(*v1 - 24) + 8) = *(_DWORD *)((_BYTE *)v1 + *(_QWORD *)(*v1 - 24) + 8) & 0xFFFFFFB5 | 2;
      v15 = 10;
      result = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v1, (uint64_t)&v15, 1);
      v6 = (v6 + *(unsigned __int16 *)(v6 + 8) + 13) & 0xFFFFFFFFFFFFFFFCLL;
      ++v5;
    }
    while (v5 < *a1);
  }
  return result;
}

_QWORD *MIDI::EventList::dump(MIDI::EventList *this, const MIDI::EventList *a2)
{
  uint64_t *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *result;
  unsigned int v7;
  char *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *v13;
  char *v14;
  _QWORD *v15;
  uint64_t v16;
  char v18;
  char v19;

  v2 = (uint64_t *)MEMORY[0x1E0DE4A60];
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E0DE4A60], (uint64_t)"MIDIEvent @ ", 12);
  v3 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)", protocol ", 11);
  v4 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)", ", 2);
  v5 = (_QWORD *)std::ostream::operator<<();
  result = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)" packets:\n", 10);
  if (*((_DWORD *)this + 1))
  {
    v7 = 0;
    v8 = (char *)this + 8;
    do
    {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v2, (uint64_t)"  [", 3);
      v9 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)" ", 1);
      v10 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)"] ts ", 5);
      v11 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)", ", 2);
      v12 = *((unsigned int *)v8 + 2);
      v13 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)" words:", 7);
      if ((_DWORD)v12)
      {
        v14 = v8 + 12;
        do
        {
          v19 = 32;
          v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v2, (uint64_t)&v19, 1);
          v16 = *v2;
          *(_DWORD *)((char *)v2 + *(_QWORD *)(*v2 - 24) + 8) = *(_DWORD *)((_BYTE *)v2 + *(_QWORD *)(*v2 - 24) + 8) & 0xFFFFFFB5 | 8;
          *(uint64_t *)((char *)v2 + *(_QWORD *)(v16 - 24) + 24) = 8;
          std::operator<<[abi:ne180100]<std::char_traits<char>>(v15, 48);
          v14 += 4;
          std::ostream::operator<<();
          --v12;
        }
        while (v12);
      }
      *(_DWORD *)((char *)v2 + *(_QWORD *)(*v2 - 24) + 8) = *(_DWORD *)((_BYTE *)v2 + *(_QWORD *)(*v2 - 24) + 8) & 0xFFFFFFB5 | 2;
      v18 = 10;
      result = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v2, (uint64_t)&v18, 1);
      v8 += 4 * *((unsigned int *)v8 + 2) + 12;
      ++v7;
    }
    while (v7 < *((_DWORD *)this + 1));
  }
  return result;
}

void *MIDI::LegacyPacketList::create@<X0>(int a1@<W0>, uint64_t a2@<X1>, const void *a3@<X2>, size_t a4@<X3>, _QWORD *a5@<X8>)
{
  char *v9;
  void *result;

  if (a1 != 1)
    std::terminate();
  v9 = (char *)malloc_type_malloc(a4 + 14, 0x5D605258uLL);
  *(_DWORD *)v9 = 1;
  *(_QWORD *)(v9 + 4) = a2;
  *((_WORD *)v9 + 6) = a4;
  result = memcpy(v9 + 14, a3, a4);
  *a5 = v9;
  return result;
}

void MIDI::LegacyPacketListDeleter::operator()(int a1, void *a2)
{
  free(a2);
}

void MIDIServerXPC::~MIDIServerXPC(MIDIServerXPC *this)
{
  *(_QWORD *)this = &off_1E98B7FA0;
  *((_QWORD *)this + 116) = &off_1E98B8568;
  std::shared_ptr<swix::connection::state>::~shared_ptr[abi:ne180100]((uint64_t)this + 936);
  MIDIServer::~MIDIServer(this);
}

{
  *(_QWORD *)this = &off_1E98B7FA0;
  *((_QWORD *)this + 116) = &off_1E98B8568;
  std::shared_ptr<swix::connection::state>::~shared_ptr[abi:ne180100]((uint64_t)this + 936);
  MIDIServer::~MIDIServer(this);
  JUMPOUT(0x1D826BA98);
}

void MIDIServerXPC::Init(MIDIServerXPC *this, int a2)
{
  MIDIServer::Init(this, a2);
  swix::connection::activate((MIDIServerXPC *)((char *)this + 928));
}

void ClientProcessXPC::~ClientProcessXPC(ClientProcessXPC *this)
{
  ClientProcessXPC::~ClientProcessXPC(this);
  JUMPOUT(0x1D826BA98);
}

{
  ClientProcess *v2;
  uint64_t v3;

  *((_QWORD *)this + 2) = &unk_1E98B8158;
  v2 = (ClientProcessXPC *)((char *)this + 16);
  *(_QWORD *)this = &off_1E98B8110;
  v3 = *((_QWORD *)this + 45);
  *((_QWORD *)this + 44) = off_1E98B85B8;
  *((_QWORD *)this + 45) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  ClientProcess::~ClientProcess(v2);
  BaseOpaqueObject::~BaseOpaqueObject(this);
}

uint64_t ClientProcessXPC::PrintObject(ClientProcessXPC *this, __sFILE *a2)
{
  fprintf(a2, "<%s 0x%x [%p]>", "ClientProcessXPC", *((_DWORD *)this + 2), this);
  return fputc(10, a2);
}

BOOL TOpaqueObject<ClientProcessXPC,unsigned int,BaseOpaqueObject>::isa(uint64_t a1, void *a2)
{
  return a2 == &TOpaqueRTTI<ClientProcessXPC>::sRTTI || a2 == &BaseOpaqueObject::sBaseRTTI;
}

uint64_t ClientProcessXPC::GetRef(ClientProcessXPC *this)
{
  return *((unsigned int *)this + 2);
}

uint64_t ClientProcessXPC::Notify(uint64_t a1, CFDataRef *a2)
{
  const UInt8 *BytePtr;
  size_t Length;
  swix::connection *v6;
  applesauce::CF *exception;
  applesauce::CF *v9;
  xpc_object_t value;
  _BYTE v11[8];
  xpc_object_t xdict;

  if (!*a2)
  {
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  BytePtr = CFDataGetBytePtr(*a2);
  if (!*a2)
  {
    v9 = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(v9);
  }
  Length = CFDataGetLength(*a2);
  swix::data::data((swix::data *)&value, BytePtr, Length);
  swix::encode_message::encode_message((swix::encode_message *)v11, 220460584);
  xpc_dictionary_set_value(xdict, "data", value);
  v6 = *(swix::connection **)(a1 + 360);
  if (!v6)
    std::terminate();
  swix::connection::send(v6, (const swix::encode_message *)v11);
  xpc_release(xdict);
  xpc_release(value);
  return 0;
}

void sub_1D4EDF30C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1D4EDF32C(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EDF2A4);
}

void `non-virtual thunk to'ClientProcessXPC::~ClientProcessXPC(ClientProcessXPC *this)
{
  ClientProcessXPC::~ClientProcessXPC((ClientProcessXPC *)((char *)this - 16));
}

{
  ClientProcessXPC::~ClientProcessXPC((ClientProcessXPC *)((char *)this - 16));
  JUMPOUT(0x1D826BA98);
}

uint64_t ClientProcess::asMIGImpl(ClientProcess *this)
{
  return 0;
}

uint64_t `non-virtual thunk to'ClientProcessXPC::asXPCImpl(ClientProcessXPC *this)
{
  return (uint64_t)this - 16;
}

uint64_t `non-virtual thunk to'ClientProcessXPC::GetRef(ClientProcessXPC *this)
{
  return *((unsigned int *)this - 2);
}

uint64_t `non-virtual thunk to'ClientProcessXPC::Notify(uint64_t a1, CFDataRef *a2)
{
  ClientProcessXPC::Notify(a1 - 16, a2);
  return 0;
}

swix::data *swix::data::data(swix::data *this, const void *bytes, size_t length)
{
  xpc_object_t v4;

  v4 = xpc_data_create(bytes, length);
  *(_QWORD *)this = v4;
  if (!v4)
    *(_QWORD *)this = xpc_null_create();
  return this;
}

void MIDIServerXPC::XPCListener::~XPCListener(MIDIServerXPC::XPCListener *this)
{
  *(_QWORD *)this = &off_1E98B8568;
  std::shared_ptr<swix::connection::state>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &off_1E98B8568;
  std::shared_ptr<swix::connection::state>::~shared_ptr[abi:ne180100]((uint64_t)this + 8);
  JUMPOUT(0x1D826BA98);
}

uint64_t MIDIServerXPC::XPCListener::accept_connection(MIDIServerXPC::XPCListener *this, void **a2)
{
  void *v3;
  NSObject *v4;
  pid_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  MIDIServer *p_atoken;
  uint64_t v12;
  uint64_t *v13;
  MIDIServer *v14;
  int v15;
  uint64_t *v16;
  ClientTable *v17;
  ClientProcess **i;
  _QWORD *v19;
  uint64_t v20;
  void *v22[2];
  void *v23[2];
  __int128 v24;
  xpc_object_t v25;
  dispatch_object_t v26;
  uint64_t v27;
  __int16 v28;
  _BYTE v29[8];
  _BYTE v30[24];
  _BYTE *v31;
  char v32;
  std::string v33;
  void *__p;
  char v35;
  xpc_object_t v36;
  dispatch_object_t object;
  _BYTE v38[24];
  _BYTE *v39;
  char v40;
  std::string v41;
  char v42;
  audit_token_t atoken;
  char v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)v23 = 0u;
  v24 = 0u;
  *(_OWORD *)v22 = 0u;
  v3 = *a2;
  v25 = v3;
  if (v3)
    xpc_retain(v3);
  else
    v25 = xpc_null_create();
  v4 = MEMORY[0x1E0C80D38];
  dispatch_retain(MEMORY[0x1E0C80D38]);
  v26 = v4;
  gMIDIServerLog();
  v27 = gMIDIServerLog(void)::mdsrvr;
  v28 = 0;
  std::__optional_copy_base<swix::timeout_config,false>::__optional_copy_base[abi:ne180100](v29, *((_QWORD *)this + 1) + 96);
  xpc_connection_get_audit_token();
  memset(&atoken, 0, sizeof(atoken));
  v5 = audit_token_to_pid(&atoken);
  if (v5 == -1)
    v5 = getpid();
  v6 = *((_QWORD *)this + 3);
  v7 = operator new();
  swix::connection_config::connection_config(&v33, (const swix::connection_config *)v22);
  BaseOpaqueObject::BaseOpaqueObject((BaseOpaqueObject *)v7);
  *(_QWORD *)(v7 + 16) = &unk_1E98B8158;
  *(_DWORD *)(v7 + 24) = v5;
  *(_BYTE *)(v7 + 29) = 0;
  *(_BYTE *)(v7 + 32) = 0;
  *(_BYTE *)(v7 + 36) = 0;
  *(_BYTE *)(v7 + 40) = 0;
  *(_BYTE *)(v7 + 192) = 0;
  *(_BYTE *)(v7 + 200) = 0;
  *(_BYTE *)(v7 + 304) = 0;
  *(_QWORD *)(v7 + 312) = v7 + 312;
  *(_QWORD *)(v7 + 320) = v7 + 312;
  *(_QWORD *)(v7 + 328) = 0;
  *(_BYTE *)(v7 + 336) = 0;
  *(_QWORD *)v7 = &off_1E98B8110;
  *(_QWORD *)(v7 + 344) = v6;
  swix::connection_config::connection_config(&v41, (const swix::connection_config *)&v33);
  v42 = 1;
  LOBYTE(atoken.val[0]) = 0;
  v44 = 0;
  std::construct_at[abi:ne180100]<swix::connection_config,swix::connection_config,swix::connection_config*>((uint64_t)&atoken, (__int128 *)&v41);
  v44 = 1;
  swix::ipc_interface::ipc_interface((_QWORD *)(v7 + 352), (const swix::connection_config *)&atoken);
  std::__optional_destruct_base<swix::connection_config,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&atoken);
  *(_QWORD *)(v7 + 352) = &off_1E98B81C0;
  *(_QWORD *)(v7 + 368) = v7;
  std::__optional_destruct_base<swix::connection_config,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v41);
  if (v40)
  {
    v8 = v39;
    if (v39 == v38)
    {
      v9 = 4;
      v8 = v38;
    }
    else
    {
      if (!v39)
        goto LABEL_12;
      v9 = 5;
    }
    (*(void (**)(void))(*v8 + 8 * v9))();
  }
LABEL_12:
  if (object)
    dispatch_release(object);
  xpc_release(v36);
  v36 = 0;
  if (v35 < 0)
    operator delete(__p);
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v33.__r_.__value_.__l.__data_);
  *(_QWORD *)atoken.val = &off_1E98B8738;
  *(_QWORD *)&atoken.val[2] = v7;
  *(_QWORD *)&atoken.val[6] = &atoken;
  v10 = *(_QWORD *)(v7 + 360);
  if (!v10)
    std::terminate();
  std::function<void ()(swix::ipc_endpoint &,applesauce::xpc::object const&)>::operator=((_QWORD *)(v10 + 24), (uint64_t)&atoken);
  p_atoken = *(MIDIServer **)&atoken.val[6];
  if (*(audit_token_t **)&atoken.val[6] == &atoken)
  {
    v12 = 4;
    p_atoken = (MIDIServer *)&atoken;
    goto LABEL_23;
  }
  if (*(_QWORD *)&atoken.val[6])
  {
    v12 = 5;
LABEL_23:
    p_atoken = (MIDIServer *)(*(uint64_t (**)(void))(*(_QWORD *)p_atoken + 8 * v12))();
  }
  v13 = MIDIServer::defaultInstance(p_atoken) + 2;
  v14 = (MIDIServer *)(*(uint64_t (**)(uint64_t *))(*v13 + 16))(v13);
  v15 = (int)v14;
  v16 = MIDIServer::defaultInstance(v14);
  v17 = (ClientTable *)(v16 + 24);
  for (i = (ClientProcess **)v16[29]; i != (ClientProcess **)v16[30]; ++i)
  {
    if (*((_DWORD *)*i + 2) == v5)
    {
      ClientTable::ProcessQuit((ClientTable *)(v16 + 24), *i);
      break;
    }
  }
  ClientTable::AddProcess(v17, (ClientProcess *)(v7 + 16));
  if (v15)
    (*(void (**)(uint64_t *))(*v13 + 24))(v13);
  if (v32)
  {
    v19 = v31;
    if (v31 == v30)
    {
      v20 = 4;
      v19 = v30;
    }
    else
    {
      if (!v31)
        goto LABEL_37;
      v20 = 5;
    }
    (*(void (**)(void))(*v19 + 8 * v20))();
  }
LABEL_37:
  if (v26)
    dispatch_release(v26);
  xpc_release(v25);
  v25 = 0;
  if (SHIBYTE(v24) < 0)
    operator delete(v23[1]);
  if (SHIBYTE(v23[0]) < 0)
    operator delete(v22[0]);
  return 1;
}

void sub_1D4EDF858(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,xpc_object_t a25,dispatch_object_t object,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,char a52)
{
  uint64_t v52;
  uint64_t v53;
  int v54;

  if (v54)
    (*(void (**)(uint64_t))(*(_QWORD *)v53 + 24))(v53);
  if (v52)
    (*(void (**)(uint64_t))(*(_QWORD *)v52 + 8))(v52);
  swix::connection_config::~connection_config((swix::connection_config *)&a13);
  _Unwind_Resume(a1);
}

void std::__function::__func<MIDIServerXPC::XPCListener::accept_connection(applesauce::xpc::connection const&)::$_0,std::allocator<MIDIServerXPC::XPCListener::accept_connection(applesauce::xpc::connection const&)::$_0>,void ()(swix::ipc_endpoint &,applesauce::xpc::object const&)>::~__func()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *std::__function::__func<MIDIServerXPC::XPCListener::accept_connection(applesauce::xpc::connection const&)::$_0,std::allocator<MIDIServerXPC::XPCListener::accept_connection(applesauce::xpc::connection const&)::$_0>,void ()(swix::ipc_endpoint &,applesauce::xpc::object const&)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E98B8738;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<MIDIServerXPC::XPCListener::accept_connection(applesauce::xpc::connection const&)::$_0,std::allocator<MIDIServerXPC::XPCListener::accept_connection(applesauce::xpc::connection const&)::$_0>,void ()(swix::ipc_endpoint &,applesauce::xpc::object const&)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E98B8738;
  a2[1] = v2;
  return result;
}

void std::__function::__func<MIDIServerXPC::XPCListener::accept_connection(applesauce::xpc::connection const&)::$_0,std::allocator<MIDIServerXPC::XPCListener::accept_connection(applesauce::xpc::connection const&)::$_0>,void ()(swix::ipc_endpoint &,applesauce::xpc::object const&)>::operator()(uint64_t a1)
{
  _QWORD *v1;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  _QWORD *v6;
  MIDIServer *v7;
  ClientProcess *v8;
  uint64_t v9;
  MIDIServer *v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  _BYTE v16[24];
  _BYTE *v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD **)(*(_QWORD *)(a1 + 8) + 360);
  if (!v1)
    std::terminate();
  v3 = (std::__shared_weak_count *)v1[2];
  v14 = v1[1];
  v15 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  v6 = v16;
  v7 = (MIDIServer *)std::__function::__value_func<void ()(applesauce::iokit::io_object_holder)>::__value_func[abi:ne180100]((uint64_t)v16, (uint64_t)(v1 + 3));
  v18 = v1[7];
  MIDIServer::defaultInstance(v7);
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
    v10 = (MIDIServer *)(v9 + 16);
  else
    v10 = 0;
  MIDIServer::ClientDied(v10, v8);
  swix::connection::state::cancel_connection(v14, 0);
  if (v17 == v16)
  {
    v11 = 4;
  }
  else
  {
    if (!v17)
      goto LABEL_13;
    v11 = 5;
    v6 = v17;
  }
  (*(void (**)(_QWORD *))(*v6 + 8 * v11))(v6);
LABEL_13:
  if (v15)
  {
    v12 = (unint64_t *)&v15->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
}

void sub_1D4EDFB68(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<swix::connection::state>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t MIDIServerXPC_Server::queryServer(MIDIServerXPC_Server *this)
{
  return getpid() | 0x100000000;
}

void MIDIServerXPC_Server::registerProcess(uint64_t a1, uint64_t a2, int a3)
{
  _OWORD *v5;
  __int128 v6;
  MIDIServer *v7;
  int v8;
  uint64_t v9;
  uint64_t *v10;
  mach_port_name_t **i;
  mach_port_name_t *v12;
  mach_port_name_t v13;
  _BYTE v14[36];
  audit_token_t atoken;

  swix::ipc_interface::audit_token((swix::ipc_interface *)v14, *(_QWORD *)(a1 + 8));
  if (v14[32])
    v5 = v14;
  else
    v5 = &gBogusAuditToken;
  v6 = v5[1];
  *(_OWORD *)atoken.val = *v5;
  *(_OWORD *)&atoken.val[4] = v6;
  v7 = (MIDIServer *)audit_token_to_pid(&atoken);
  v8 = (int)v7;
  if ((_DWORD)v7 == -1)
  {
    v7 = (MIDIServer *)getpid();
    v8 = (int)v7;
  }
  v9 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 344);
  v10 = MIDIServer::defaultInstance(v7);
  for (i = (mach_port_name_t **)v10[29]; i != (mach_port_name_t **)v10[30]; ++i)
  {
    v12 = *i;
    if ((*i)[2] == v8)
    {
      v13 = xpc_mach_send_copy_right();
      ClientProcess::setupIO(v12, v13, a3);
      break;
    }
  }
  BackgroundAppManager::Update((BackgroundAppManager *)(v9 + 912));
}

void swix::ipc_interface::audit_token(swix::ipc_interface *this, uint64_t a2)
{
  void *v3;
  void *v4;

  if (a2)
  {
    swix::connection::state::xpc_connection((swix::connection::state *)&v4, *(_QWORD *)(a2 + 8));
    v3 = v4;
    if (MEMORY[0x1D826C5A8](v4) == MEMORY[0x1E0C812E0])
    {
      xpc_connection_get_audit_token();
      *(_OWORD *)this = 0u;
      *((_OWORD *)this + 1) = 0u;
      *((_BYTE *)this + 32) = 1;
    }
    else
    {
      *(_BYTE *)this = 0;
      *((_BYTE *)this + 32) = 0;
    }
    xpc_release(v3);
  }
  else
  {
    *(_BYTE *)this = 0;
    *((_BYTE *)this + 32) = 0;
  }
}

void sub_1D4EDFD50(void *a1)
{
  void *v1;

  xpc_release(v1);
  __clang_call_terminate(a1);
}

unint64_t MIDIServerXPC_Server::createClient(MIDIServerXPC_Server *this, xpc_object_t *a2)
{
  void **v3;
  __int128 v4;
  MIDIServer *v5;
  char *string_ptr;
  void **v7;
  CFIndex v8;
  const __CFString *v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  void *exception;
  void *__p[2];
  unsigned __int8 v16;
  char v17;
  audit_token_t atoken;

  swix::ipc_interface::audit_token((swix::ipc_interface *)__p, (uint64_t)this);
  if (v17)
    v3 = __p;
  else
    v3 = (void **)&gBogusAuditToken;
  v4 = *((_OWORD *)v3 + 1);
  *(_OWORD *)atoken.val = *(_OWORD *)v3;
  *(_OWORD *)&atoken.val[4] = v4;
  v5 = (MIDIServer *)audit_token_to_pid(&atoken);
  if ((_DWORD)v5 == -1)
    v5 = (MIDIServer *)getpid();
  atoken.val[0] = 0;
  string_ptr = (char *)xpc_string_get_string_ptr(*a2);
  std::string::basic_string[abi:ne180100]<0>(__p, string_ptr);
  if ((v16 & 0x80u) == 0)
    v7 = __p;
  else
    v7 = (void **)__p[0];
  if ((v16 & 0x80u) == 0)
    v8 = v16;
  else
    v8 = (CFIndex)__p[1];
  v9 = CFStringCreateWithBytes(0, (const UInt8 *)v7, v8, 0x8000100u, 0);
  if (!v9)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  if ((char)v16 < 0)
    operator delete(__p[0]);
  v10 = _MIDIClientCreate(v5, v9, (uint64_t)&atoken, 0);
  v11 = atoken.val[0];
  CFRelease(v9);
  if (v10)
    v12 = v10;
  else
    v12 = v11;
  return v12 | ((unint64_t)(v10 == 0) << 32);
}

void sub_1D4EDFEAC(void *a1)
{
  __clang_call_terminate(a1);
}

unint64_t MIDIServerXPC_Server::disposeClient(MIDIServerXPC_Server *this)
{
  unsigned int v1;

  v1 = _MIDIClientDispose(this);
  return v1 | ((unint64_t)(v1 == 0) << 32);
}

unint64_t MIDIServerXPC_Server::createInputPort(MIDIServerXPC_Server *this, xpc_object_t xstring, const swix::string *a3)
{
  int v3;
  char *string_ptr;
  void **v6;
  CFIndex v7;
  const __CFString *v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  void *exception;
  void *__p[2];
  unsigned __int8 v15;
  unsigned int v16;

  v3 = (int)a3;
  v16 = 0;
  string_ptr = (char *)xpc_string_get_string_ptr(xstring);
  std::string::basic_string[abi:ne180100]<0>(__p, string_ptr);
  if ((v15 & 0x80u) == 0)
    v6 = __p;
  else
    v6 = (void **)__p[0];
  if ((v15 & 0x80u) == 0)
    v7 = v15;
  else
    v7 = (CFIndex)__p[1];
  v8 = CFStringCreateWithBytes(0, (const UInt8 *)v6, v7, 0x8000100u, 0);
  if (!v8)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  if ((char)v15 < 0)
    operator delete(__p[0]);
  v9 = _MIDIInputPortCreate(this, v8, v3, &v16, 0, 0);
  v10 = v16;
  CFRelease(v8);
  if (v9)
    v11 = v9;
  else
    v11 = v10;
  return v11 | ((unint64_t)(v9 == 0) << 32);
}

void sub_1D4EDFFF8(void *a1)
{
  __clang_call_terminate(a1);
}

unint64_t MIDIServerXPC_Server::createOutputPort(MIDIServerXPC_Server *this, xpc_object_t xstring, const swix::string *a3)
{
  char *string_ptr;
  void **v5;
  CFIndex v6;
  const __CFString *v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  void *exception;
  void *__p[2];
  unsigned __int8 v14;
  unsigned int v15;

  v15 = 0;
  string_ptr = (char *)xpc_string_get_string_ptr(xstring);
  std::string::basic_string[abi:ne180100]<0>(__p, string_ptr);
  if ((v14 & 0x80u) == 0)
    v5 = __p;
  else
    v5 = (void **)__p[0];
  if ((v14 & 0x80u) == 0)
    v6 = v14;
  else
    v6 = (CFIndex)__p[1];
  v7 = CFStringCreateWithBytes(0, (const UInt8 *)v5, v6, 0x8000100u, 0);
  if (!v7)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  if ((char)v14 < 0)
    operator delete(__p[0]);
  v8 = _MIDIOutputPortCreate(this, v7, &v15);
  v9 = v15;
  CFRelease(v7);
  if (v8)
    v10 = v8;
  else
    v10 = v9;
  return v10 | ((unint64_t)(v8 == 0) << 32);
}

void sub_1D4EE010C(void *a1)
{
  __clang_call_terminate(a1);
}

unint64_t MIDIServerXPC_Server::disposePort(MIDIServerXPC_Server *this)
{
  unsigned int v1;

  v1 = _MIDIPortDispose(this);
  return v1 | ((unint64_t)(v1 == 0) << 32);
}

unint64_t MIDIServerXPC_Server::portConnectSource(MIDIServer *a1, int a2, uint64_t a3)
{
  unsigned int v3;

  v3 = _MIDIPortConnectSource(a1, a2, a3);
  return v3 | ((unint64_t)(v3 == 0) << 32);
}

unint64_t MIDIServerXPC_Server::portDisconnectSource(MIDIServerXPC_Server *this, int a2)
{
  unsigned int v2;

  v2 = _MIDIPortDisconnectSource(this, a2);
  return v2 | ((unint64_t)(v2 == 0) << 32);
}

uint64_t MIDIServerXPC_Server::acknowledgeNotification(uint64_t a1, uint64_t a2)
{
  _OWORD *v3;
  __int128 v4;
  MIDIServer *v5;
  int v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v13[4];
  char v14;
  audit_token_t atoken;

  swix::ipc_interface::audit_token((swix::ipc_interface *)v13, a1);
  if (v14)
    v3 = v13;
  else
    v3 = &gBogusAuditToken;
  v4 = v3[1];
  *(_OWORD *)atoken.val = *v3;
  *(_OWORD *)&atoken.val[4] = v4;
  v5 = (MIDIServer *)audit_token_to_pid(&atoken);
  v6 = (int)v5;
  if ((_DWORD)v5 == -1)
  {
    v5 = (MIDIServer *)getpid();
    v6 = (int)v5;
  }
  v7 = MIDIServer::defaultInstance(v5);
  v8 = v7[29];
  v9 = v7[30];
  while (v8 != v9)
  {
    v10 = *(_QWORD *)v8;
    if (*(_DWORD *)(*(_QWORD *)v8 + 8) == v6)
    {
      *(_BYTE *)(v10 + 320) = 0;
      if (*(_QWORD *)(v10 + 312))
        ClientProcess::DeliverNotifications((ClientProcess *)v10);
      break;
    }
    v8 += 8;
  }
  v13[0] = 0x100000000;
  v11 = *(_QWORD *)(a2 + 24);
  if (!v11)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v11 + 48))(v11, v13);
}

unint64_t MIDIServerXPC_Server::createSource(MIDIServerXPC_Server *this, xpc_object_t xstring, const swix::string *a3)
{
  MIDIProtocolID v3;
  char *string_ptr;
  void **v6;
  CFIndex v7;
  const __CFString *v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  void *exception;
  void *__p[2];
  unsigned __int8 v15;
  unsigned int v16;

  v3 = (int)a3;
  v16 = 0;
  string_ptr = (char *)xpc_string_get_string_ptr(xstring);
  std::string::basic_string[abi:ne180100]<0>(__p, string_ptr);
  if ((v15 & 0x80u) == 0)
    v6 = __p;
  else
    v6 = (void **)__p[0];
  if ((v15 & 0x80u) == 0)
    v7 = v15;
  else
    v7 = (CFIndex)__p[1];
  v8 = CFStringCreateWithBytes(0, (const UInt8 *)v6, v7, 0x8000100u, 0);
  if (!v8)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  if ((char)v15 < 0)
    operator delete(__p[0]);
  v9 = _MIDISourceCreate(this, v8, v3, &v16);
  v10 = v16;
  CFRelease(v8);
  if (v9)
    v11 = v9;
  else
    v11 = v10;
  return v11 | ((unint64_t)(v9 == 0) << 32);
}

void sub_1D4EE0370(void *a1)
{
  __clang_call_terminate(a1);
}

unint64_t MIDIServerXPC_Server::createDestination(MIDIServerXPC_Server *this, xpc_object_t xstring, const swix::string *a3)
{
  MIDIProtocolID v3;
  char *string_ptr;
  void **v6;
  CFIndex v7;
  const __CFString *v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  void *exception;
  void *__p[2];
  unsigned __int8 v15;
  unsigned int v16;

  v3 = (int)a3;
  v16 = 0;
  string_ptr = (char *)xpc_string_get_string_ptr(xstring);
  std::string::basic_string[abi:ne180100]<0>(__p, string_ptr);
  if ((v15 & 0x80u) == 0)
    v6 = __p;
  else
    v6 = (void **)__p[0];
  if ((v15 & 0x80u) == 0)
    v7 = v15;
  else
    v7 = (CFIndex)__p[1];
  v8 = CFStringCreateWithBytes(0, (const UInt8 *)v6, v7, 0x8000100u, 0);
  if (!v8)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  if ((char)v15 < 0)
    operator delete(__p[0]);
  v9 = _MIDIDestinationCreate(this, v8, v3, &v16, 0, 0);
  v10 = v16;
  CFRelease(v8);
  if (v9)
    v11 = v9;
  else
    v11 = v10;
  return v11 | ((unint64_t)(v9 == 0) << 32);
}

void sub_1D4EE0494(void *a1)
{
  __clang_call_terminate(a1);
}

unint64_t MIDIServerXPC_Server::disposeEndpoint(MIDIServerXPC_Server *this)
{
  unsigned int v1;

  v1 = _MIDIEndpointDispose(this);
  return v1 | ((unint64_t)(v1 == 0) << 32);
}

unint64_t MIDIServerXPC_Server::objectSetIntegerProperty(MIDIServerXPC_Server *this, xpc_object_t xstring, const swix::string *a3)
{
  int v3;
  char *string_ptr;
  void **v6;
  CFIndex v7;
  const __CFString *v8;
  unsigned int v9;
  void *exception;
  void *__p[2];
  unsigned __int8 v13;

  v3 = (int)a3;
  string_ptr = (char *)xpc_string_get_string_ptr(xstring);
  std::string::basic_string[abi:ne180100]<0>(__p, string_ptr);
  if ((v13 & 0x80u) == 0)
    v6 = __p;
  else
    v6 = (void **)__p[0];
  if ((v13 & 0x80u) == 0)
    v7 = v13;
  else
    v7 = (CFIndex)__p[1];
  v8 = CFStringCreateWithBytes(0, (const UInt8 *)v6, v7, 0x8000100u, 0);
  if (!v8)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  if ((char)v13 < 0)
    operator delete(__p[0]);
  v9 = _MIDIObjectSetIntegerProperty(this, v8, v3);
  CFRelease(v8);
  return v9 | ((unint64_t)(v9 == 0) << 32);
}

void sub_1D4EE05CC(void *a1)
{
  __clang_call_terminate(a1);
}

unint64_t MIDIServerXPC_Server::objectGetIntegerProperty(MIDIServerXPC_Server *this, xpc_object_t xstring, const swix::string *a3)
{
  char *string_ptr;
  void **v5;
  CFIndex v6;
  const __CFString *v7;
  unsigned int IntegerProperty;
  unsigned int v9;
  uint64_t v10;
  void *exception;
  void *__p[2];
  unsigned __int8 v14;

  string_ptr = (char *)xpc_string_get_string_ptr(xstring);
  std::string::basic_string[abi:ne180100]<0>(__p, string_ptr);
  if ((v14 & 0x80u) == 0)
    v5 = __p;
  else
    v5 = (void **)__p[0];
  if ((v14 & 0x80u) == 0)
    v6 = v14;
  else
    v6 = (CFIndex)__p[1];
  v7 = CFStringCreateWithBytes(0, (const UInt8 *)v5, v6, 0x8000100u, 0);
  if (!v7)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  if ((char)v14 < 0)
    operator delete(__p[0]);
  LODWORD(__p[0]) = 0;
  IntegerProperty = _MIDIObjectGetIntegerProperty(this, v7, (int *)__p);
  v9 = __p[0];
  CFRelease(v7);
  if (IntegerProperty)
    v10 = IntegerProperty;
  else
    v10 = v9;
  return v10 | ((unint64_t)(IntegerProperty == 0) << 32);
}

void sub_1D4EE06E0(void *a1)
{
  __clang_call_terminate(a1);
}

unint64_t MIDIServerXPC_Server::objectSetStringProperty(MIDIServerXPC_Server *this, xpc_object_t xstring, xpc_object_t *a3, const swix::string *a4)
{
  char *string_ptr;
  const UInt8 *p_p;
  CFIndex v8;
  const __CFString *v9;
  char *v10;
  const UInt8 *v11;
  CFIndex v12;
  CFStringRef v13;
  unsigned int v14;
  void *exception;
  void *v17;
  void *__p;
  CFIndex v19;
  unsigned __int8 v20;

  string_ptr = (char *)xpc_string_get_string_ptr(xstring);
  std::string::basic_string[abi:ne180100]<0>(&__p, string_ptr);
  if ((v20 & 0x80u) == 0)
    p_p = (const UInt8 *)&__p;
  else
    p_p = (const UInt8 *)__p;
  if ((v20 & 0x80u) == 0)
    v8 = v20;
  else
    v8 = v19;
  v9 = CFStringCreateWithBytes(0, p_p, v8, 0x8000100u, 0);
  if (!v9)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  if ((char)v20 < 0)
    operator delete(__p);
  v10 = (char *)xpc_string_get_string_ptr(*a3);
  std::string::basic_string[abi:ne180100]<0>(&__p, v10);
  if ((v20 & 0x80u) == 0)
    v11 = (const UInt8 *)&__p;
  else
    v11 = (const UInt8 *)__p;
  if ((v20 & 0x80u) == 0)
    v12 = v20;
  else
    v12 = v19;
  v13 = CFStringCreateWithBytes(0, v11, v12, 0x8000100u, 0);
  if (!v13)
  {
    v17 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v17, "Could not construct");
  }
  if ((char)v20 < 0)
    operator delete(__p);
  v14 = _MIDIObjectSetStringProperty(this, v9, (uint64_t)v13);
  CFRelease(v13);
  CFRelease(v9);
  return v14 | ((unint64_t)(v14 == 0) << 32);
}

void sub_1D4EE0888(void *a1)
{
  __clang_call_terminate(a1);
}

void MIDIServerXPC_Server::objectGetStringProperty(MIDIServerXPC_Server *this, MIDIServer *a2, xpc_object_t xstring)
{
  char *string_ptr;
  void **v6;
  CFIndex v7;
  const __CFString *v8;
  int StringProperty;
  BOOL v10;
  xpc_object_t v11;
  void **v12;
  void *exception;
  void *v14;
  xpc_object_t object;
  CFTypeRef cf;
  xpc_object_t v17;
  CFTypeRef v18;
  void *__p[2];
  unsigned __int8 v20;

  string_ptr = (char *)xpc_string_get_string_ptr(xstring);
  std::string::basic_string[abi:ne180100]<0>(__p, string_ptr);
  if ((v20 & 0x80u) == 0)
    v6 = __p;
  else
    v6 = (void **)__p[0];
  if ((v20 & 0x80u) == 0)
    v7 = v20;
  else
    v7 = (CFIndex)__p[1];
  v8 = CFStringCreateWithBytes(0, (const UInt8 *)v6, v7, 0x8000100u, 0);
  if (!v8)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  if ((char)v20 < 0)
    operator delete(__p[0]);
  v18 = 0;
  StringProperty = _MIDIObjectGetStringProperty(a2, v8, (const __CFString **)&v18);
  if (StringProperty)
    v10 = 1;
  else
    v10 = v18 == 0;
  if (v10)
  {
    v11 = xpc_null_create();
    v17 = v11;
    if (StringProperty)
    {
      *(_DWORD *)this = StringProperty;
      *((_BYTE *)this + 8) = 0;
    }
    else
    {
      swix::result<swix::string>::result((uint64_t)this, &v17);
      v11 = v17;
    }
    xpc_release(v11);
    v17 = 0;
  }
  else
  {
    applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cf, v18);
    if (!cf)
    {
      v14 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x1D826B7EC](v14, "Could not construct");
    }
    applesauce::CF::convert_to<std::string,0>((uint64_t)__p, (const __CFString *)cf);
    if (cf)
      CFRelease(cf);
    if ((v20 & 0x80u) == 0)
      v12 = __p;
    else
      v12 = (void **)__p[0];
    swix::string::string((swix::string *)&object, (const char *)v12);
    swix::result<swix::string>::result((uint64_t)this, &object);
    xpc_release(object);
    object = 0;
    if ((char)v20 < 0)
      operator delete(__p[0]);
  }
  CFRelease(v8);
}

void sub_1D4EE0A7C(void *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  __clang_call_terminate(a1);
}

uint64_t swix::result<swix::string>::result(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3;
  xpc_object_t v4;

  v3 = *a2;
  *a2 = xpc_null_create();
  *(_QWORD *)a1 = v3;
  v4 = xpc_null_create();
  *(_BYTE *)(a1 + 8) = 1;
  xpc_release(v4);
  return a1;
}

_QWORD *applesauce::CF::convert_to<std::string,0>(uint64_t a1, const __CFString *a2)
{
  CFTypeID TypeID;
  char *CStringPtr;
  CFIndex Length;
  UInt8 *v8;
  applesauce::CF *exception;
  CFIndex maxBufLen;
  CFRange v11;
  CFRange v12;

  TypeID = CFStringGetTypeID();
  if (TypeID != CFGetTypeID(a2))
  {
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::convert_error(exception);
  }
  CStringPtr = (char *)CFStringGetCStringPtr(a2, 0x8000100u);
  if (CStringPtr)
    return std::string::basic_string[abi:ne180100]<0>((_QWORD *)a1, CStringPtr);
  Length = CFStringGetLength(a2);
  maxBufLen = 0;
  v11.location = 0;
  v11.length = Length;
  CFStringGetBytes(a2, v11, 0x8000100u, 0, 0, 0, 0, &maxBufLen);
  std::string::basic_string[abi:ne180100]((_QWORD *)a1, maxBufLen, 0);
  if (*(char *)(a1 + 23) >= 0)
    v8 = (UInt8 *)a1;
  else
    v8 = *(UInt8 **)a1;
  v12.location = 0;
  v12.length = Length;
  return (_QWORD *)CFStringGetBytes(a2, v12, 0x8000100u, 0, 0, v8, maxBufLen, &maxBufLen);
}

void sub_1D4EE0C18()
{
  void *v0;

}

void sub_1D4EE0C30(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

swix::string *swix::string::string(swix::string *this, const char *string)
{
  xpc_object_t v3;

  v3 = xpc_string_create(string);
  *(_QWORD *)this = v3;
  if (!v3)
    *(_QWORD *)this = xpc_null_create();
  return this;
}

unint64_t MIDIServerXPC_Server::objectSetDataProperty(MIDIServerXPC_Server *this, xpc_object_t xstring, xpc_object_t *a3, const swix::data *a4)
{
  char *string_ptr;
  void **v7;
  CFIndex v8;
  const __CFString *v9;
  const UInt8 *bytes_ptr;
  size_t length;
  CFDataRef v12;
  unsigned int v13;
  void *exception;
  void *v16;
  void *__p[2];
  unsigned __int8 v18;

  string_ptr = (char *)xpc_string_get_string_ptr(xstring);
  std::string::basic_string[abi:ne180100]<0>(__p, string_ptr);
  if ((v18 & 0x80u) == 0)
    v7 = __p;
  else
    v7 = (void **)__p[0];
  if ((v18 & 0x80u) == 0)
    v8 = v18;
  else
    v8 = (CFIndex)__p[1];
  v9 = CFStringCreateWithBytes(0, (const UInt8 *)v7, v8, 0x8000100u, 0);
  if (!v9)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  if ((char)v18 < 0)
    operator delete(__p[0]);
  bytes_ptr = (const UInt8 *)xpc_data_get_bytes_ptr(*a3);
  length = xpc_data_get_length(*a3);
  v12 = CFDataCreate(0, bytes_ptr, length);
  if (!v12)
  {
    v16 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v16, "Could not construct");
  }
  applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)__p, v12);
  v13 = _MIDIObjectSetDataProperty(this, v9, (uint64_t)__p[0]);
  if (__p[0])
    CFRelease(__p[0]);
  CFRelease(v9);
  return v13 | ((unint64_t)(v13 == 0) << 32);
}

void sub_1D4EE0DF8(void *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  __clang_call_terminate(a1);
}

void MIDIServerXPC_Server::objectGetDataProperty(MIDIServerXPC_Server *this, MIDIServer *a2, xpc_object_t xstring)
{
  char *string_ptr;
  void **v6;
  CFIndex v7;
  const __CFString *v8;
  int DataProperty;
  BOOL v10;
  xpc_object_t v11;
  const UInt8 *BytePtr;
  size_t Length;
  void *exception;
  void *v15;
  xpc_object_t object;
  CFDataRef theData;
  xpc_object_t v18;
  void *__p[2];
  unsigned __int8 v20;

  string_ptr = (char *)xpc_string_get_string_ptr(xstring);
  std::string::basic_string[abi:ne180100]<0>(__p, string_ptr);
  if ((v20 & 0x80u) == 0)
    v6 = __p;
  else
    v6 = (void **)__p[0];
  if ((v20 & 0x80u) == 0)
    v7 = v20;
  else
    v7 = (CFIndex)__p[1];
  v8 = CFStringCreateWithBytes(0, (const UInt8 *)v6, v7, 0x8000100u, 0);
  if (!v8)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  if ((char)v20 < 0)
    operator delete(__p[0]);
  __p[0] = 0;
  DataProperty = _MIDIObjectGetDataProperty(a2, v8, (const __CFData **)__p);
  if (DataProperty)
    v10 = 1;
  else
    v10 = __p[0] == 0;
  if (v10)
  {
    v11 = xpc_null_create();
    v18 = v11;
    if (DataProperty)
    {
      *(_DWORD *)this = DataProperty;
      *((_BYTE *)this + 8) = 0;
    }
    else
    {
      swix::result<swix::data>::result((uint64_t)this, &v18);
      v11 = v18;
    }
    xpc_release(v11);
    v18 = 0;
  }
  else
  {
    applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)&theData, __p[0]);
    if (!theData || (BytePtr = CFDataGetBytePtr(theData), !theData))
    {
      v15 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x1D826B7EC](v15, "Could not construct");
    }
    Length = CFDataGetLength(theData);
    swix::data::data((swix::data *)&object, BytePtr, Length);
    swix::result<swix::data>::result((uint64_t)this, &object);
    xpc_release(object);
    object = 0;
    if (theData)
      CFRelease(theData);
  }
  CFRelease(v8);
}

void sub_1D4EE0FF4(void *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  __clang_call_terminate(a1);
}

uint64_t swix::result<swix::data>::result(uint64_t a1, xpc_object_t *a2)
{
  xpc_object_t v3;
  xpc_object_t v4;

  v3 = *a2;
  *a2 = xpc_null_create();
  *(_QWORD *)a1 = v3;
  v4 = xpc_null_create();
  *(_BYTE *)(a1 + 8) = 1;
  xpc_release(v4);
  return a1;
}

unint64_t MIDIServerXPC_Server::objectSetDictionaryProperty(MIDIServerXPC_Server *this, xpc_object_t xstring, xpc_object_t *a3, const swix::data *a4)
{
  char *string_ptr;
  void **v7;
  CFIndex v8;
  const __CFString *v9;
  const UInt8 *bytes_ptr;
  size_t length;
  CFDataRef v12;
  unsigned int v13;
  void *exception;
  void *v16;
  CFTypeRef cf;
  void *__p[2];
  unsigned __int8 v19;

  string_ptr = (char *)xpc_string_get_string_ptr(xstring);
  std::string::basic_string[abi:ne180100]<0>(__p, string_ptr);
  if ((v19 & 0x80u) == 0)
    v7 = __p;
  else
    v7 = (void **)__p[0];
  if ((v19 & 0x80u) == 0)
    v8 = v19;
  else
    v8 = (CFIndex)__p[1];
  v9 = CFStringCreateWithBytes(0, (const UInt8 *)v7, v8, 0x8000100u, 0);
  if (!v9)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  if ((char)v19 < 0)
    operator delete(__p[0]);
  bytes_ptr = (const UInt8 *)xpc_data_get_bytes_ptr(*a3);
  length = xpc_data_get_length(*a3);
  v12 = CFDataCreate(0, bytes_ptr, length);
  if (!v12)
  {
    v16 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v16, "Could not construct");
  }
  applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)__p, v12);
  applesauce::CF::make_DictionaryRef((applesauce::CF *)&cf, (const applesauce::CF::DataRef *)__p[0]);
  v13 = _MIDIObjectSetDictionaryProperty(this, v9, (uint64_t)cf);
  if (cf)
    CFRelease(cf);
  if (__p[0])
    CFRelease(__p[0]);
  CFRelease(v9);
  return v13 | ((unint64_t)(v13 == 0) << 32);
}

void sub_1D4EE1208(void *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  __clang_call_terminate(a1);
}

applesauce::CF::DictionaryRef *applesauce::CF::make_DictionaryRef(applesauce::CF *this, const applesauce::CF::DataRef *a2)
{
  CFPropertyListRef v3;
  const void *v4;
  CFTypeID v5;
  applesauce::CF::DictionaryRef *result;
  applesauce::CF *exception;

  if (!a2)
    goto LABEL_8;
  v3 = CFPropertyListCreateWithData(0, a2, 0, 0, 0);
  if (v3)
  {
    v4 = v3;
    v5 = CFGetTypeID(v3);
    if (v5 == CFDictionaryGetTypeID())
      return applesauce::CF::DictionaryRef::DictionaryRef(this, v4);
    CFRelease(v4);
LABEL_8:
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  result = (applesauce::CF::DictionaryRef *)CFDictionaryGetTypeID();
  if (result)
    goto LABEL_8;
  *(_QWORD *)this = 0;
  return result;
}

void sub_1D4EE12CC()
{
  void *v0;

}

void sub_1D4EE12EC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void MIDIServerXPC_Server::objectGetDictionaryProperty(MIDIServerXPC_Server *this, MIDIServer *a2, xpc_object_t xstring)
{
  char *string_ptr;
  void **v6;
  CFIndex v7;
  const __CFString *v8;
  int DictionaryProperty;
  BOOL v10;
  xpc_object_t v11;
  CFDataRef Data;
  const UInt8 *BytePtr;
  size_t Length;
  void *exception;
  void *v16;
  xpc_object_t object;
  CFDataRef theData;
  xpc_object_t v19;
  CFPropertyListRef propertyList;
  xpc_object_t v21;
  void *__p[2];
  unsigned __int8 v23;

  string_ptr = (char *)xpc_string_get_string_ptr(xstring);
  std::string::basic_string[abi:ne180100]<0>(__p, string_ptr);
  if ((v23 & 0x80u) == 0)
    v6 = __p;
  else
    v6 = (void **)__p[0];
  if ((v23 & 0x80u) == 0)
    v7 = v23;
  else
    v7 = (CFIndex)__p[1];
  v8 = CFStringCreateWithBytes(0, (const UInt8 *)v6, v7, 0x8000100u, 0);
  if (!v8)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  if ((char)v23 < 0)
    operator delete(__p[0]);
  __p[0] = 0;
  DictionaryProperty = _MIDIObjectGetDictionaryProperty(a2, v8, (CFTypeRef *)__p);
  if (DictionaryProperty)
    v10 = 1;
  else
    v10 = __p[0] == 0;
  if (v10)
  {
    v11 = xpc_null_create();
    v21 = v11;
    if (DictionaryProperty)
    {
      *(_DWORD *)this = DictionaryProperty;
      *((_BYTE *)this + 8) = 0;
    }
    else
    {
      swix::result<swix::data>::result((uint64_t)this, &v21);
      v11 = v21;
    }
    xpc_release(v11);
    v21 = 0;
  }
  else
  {
    applesauce::CF::DictionaryRef::DictionaryRef((applesauce::CF::DictionaryRef *)&propertyList, __p[0]);
    Data = CFPropertyListCreateData(0, propertyList, kCFPropertyListBinaryFormat_v1_0, 0, 0);
    if (Data)
    {
      applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)&theData, Data);
      if (!theData || (BytePtr = CFDataGetBytePtr(theData), !theData))
      {
        v16 = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x1D826B7EC](v16, "Could not construct");
      }
      Length = CFDataGetLength(theData);
      swix::data::data((swix::data *)&object, BytePtr, Length);
      swix::result<swix::data>::result((uint64_t)this, &object);
      xpc_release(object);
      object = 0;
      if (theData)
        CFRelease(theData);
    }
    else
    {
      v19 = xpc_null_create();
      swix::result<swix::data>::result((uint64_t)this, &v19);
      xpc_release(v19);
      v19 = 0;
    }
    if (propertyList)
      CFRelease(propertyList);
  }
  CFRelease(v8);
}

void sub_1D4EE152C(void *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  __clang_call_terminate(a1);
}

unint64_t MIDIServerXPC_Server::objectRemoveProperty(MIDIServerXPC_Server *this, xpc_object_t xstring, const swix::string *a3)
{
  char *string_ptr;
  void **v5;
  CFIndex v6;
  const __CFString *v7;
  unsigned int v8;
  void *exception;
  void *__p[2];
  unsigned __int8 v12;

  string_ptr = (char *)xpc_string_get_string_ptr(xstring);
  std::string::basic_string[abi:ne180100]<0>(__p, string_ptr);
  if ((v12 & 0x80u) == 0)
    v5 = __p;
  else
    v5 = (void **)__p[0];
  if ((v12 & 0x80u) == 0)
    v6 = v12;
  else
    v6 = (CFIndex)__p[1];
  v7 = CFStringCreateWithBytes(0, (const UInt8 *)v5, v6, 0x8000100u, 0);
  if (!v7)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  if ((char)v12 < 0)
    operator delete(__p[0]);
  v8 = _MIDIObjectRemoveProperty(this, v7);
  CFRelease(v7);
  return v8 | ((unint64_t)(v8 == 0) << 32);
}

void sub_1D4EE1658(void *a1)
{
  __clang_call_terminate(a1);
}

uint64_t MIDIServerXPC_Server::capabilityGetDiscoveryMUID(MIDIServerXPC_Server *this)
{
  return _MIDICapabilityGetDiscoveryMUID(this) | 0x100000000;
}

uint64_t MIDIServerXPC_Server::capabilityMUIDCollides(MIDIServerXPC_Server *this)
{
  return _MIDICapabilityMUIDCollides(this) | 0x100000000;
}

unint64_t MIDIServerXPC_Server::createSetup(MIDIServerXPC_Server *this)
{
  unsigned int v1;
  uint64_t v2;
  unsigned int v4;

  v4 = 0;
  v1 = _MIDISetupCreate((MIDIServer *)&v4);
  if (v1)
    v2 = v1;
  else
    v2 = v4;
  return v2 | ((unint64_t)(v1 == 0) << 32);
}

unint64_t MIDIServerXPC_Server::createSetupFromData(xpc_object_t *this, const swix::data *a2)
{
  const UInt8 *bytes_ptr;
  size_t length;
  CFDataRef v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  void *exception;
  CFTypeRef cf;
  unsigned int v12;

  v12 = 0;
  bytes_ptr = (const UInt8 *)xpc_data_get_bytes_ptr(*this);
  length = xpc_data_get_length(*this);
  v5 = CFDataCreate(0, bytes_ptr, length);
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)&cf, v5);
  v6 = _MIDISetupFromData((MIDIServer *)cf, &v12);
  v7 = v12;
  if (cf)
    CFRelease(cf);
  if (v6)
    v8 = v6;
  else
    v8 = v7;
  return v8 | ((unint64_t)(v6 == 0) << 32);
}

void sub_1D4EE17B8(void *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  __clang_call_terminate(a1);
}

unint64_t MIDIServerXPC_Server::installSetup(MIDIServerXPC_Server *this)
{
  unsigned int v1;

  v1 = _MIDISetupInstall(this);
  return v1 | ((unint64_t)(v1 == 0) << 32);
}

unint64_t MIDIServerXPC_Server::getCurrentSetup(MIDIServerXPC_Server *this)
{
  unsigned int Current;
  uint64_t v2;
  unsigned int v4;

  v4 = 0;
  Current = _MIDISetupGetCurrent((MIDIServer *)&v4);
  if (Current)
    v2 = Current;
  else
    v2 = v4;
  return v2 | ((unint64_t)(Current == 0) << 32);
}

unint64_t MIDIServerXPC_Server::createExternalDevice(MIDIServerXPC_Server *this, xpc_object_t *a2, xpc_object_t *a3, const swix::string *a4)
{
  char *string_ptr;
  const UInt8 *p_p;
  CFIndex v8;
  const __CFString *v9;
  char *v10;
  const UInt8 *v11;
  CFIndex v12;
  const __CFString *v13;
  char *v14;
  const UInt8 *v15;
  CFIndex v16;
  const __CFString *v17;
  unsigned int v18;
  MIDIDeviceRef v19;
  uint64_t v20;
  void *exception;
  void *v23;
  void *v24;
  void *__p;
  CFIndex v26;
  unsigned __int8 v27;
  MIDIDeviceRef outDevice;

  outDevice = 0;
  string_ptr = (char *)xpc_string_get_string_ptr(this);
  std::string::basic_string[abi:ne180100]<0>(&__p, string_ptr);
  if ((v27 & 0x80u) == 0)
    p_p = (const UInt8 *)&__p;
  else
    p_p = (const UInt8 *)__p;
  if ((v27 & 0x80u) == 0)
    v8 = v27;
  else
    v8 = v26;
  v9 = CFStringCreateWithBytes(0, p_p, v8, 0x8000100u, 0);
  if (!v9)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  if ((char)v27 < 0)
    operator delete(__p);
  v10 = (char *)xpc_string_get_string_ptr(*a2);
  std::string::basic_string[abi:ne180100]<0>(&__p, v10);
  if ((v27 & 0x80u) == 0)
    v11 = (const UInt8 *)&__p;
  else
    v11 = (const UInt8 *)__p;
  if ((v27 & 0x80u) == 0)
    v12 = v27;
  else
    v12 = v26;
  v13 = CFStringCreateWithBytes(0, v11, v12, 0x8000100u, 0);
  if (!v13)
  {
    v23 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v23, "Could not construct");
  }
  if ((char)v27 < 0)
    operator delete(__p);
  v14 = (char *)xpc_string_get_string_ptr(*a3);
  std::string::basic_string[abi:ne180100]<0>(&__p, v14);
  if ((v27 & 0x80u) == 0)
    v15 = (const UInt8 *)&__p;
  else
    v15 = (const UInt8 *)__p;
  if ((v27 & 0x80u) == 0)
    v16 = v27;
  else
    v16 = v26;
  v17 = CFStringCreateWithBytes(0, v15, v16, 0x8000100u, 0);
  if (!v17)
  {
    v24 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v24, "Could not construct");
  }
  if ((char)v27 < 0)
    operator delete(__p);
  v18 = MIDIDeviceCreate(0, v9, v13, v17, &outDevice);
  v19 = outDevice;
  CFRelease(v17);
  CFRelease(v13);
  CFRelease(v9);
  if (v18)
    v20 = v18;
  else
    v20 = v19;
  return v20 | ((unint64_t)(v18 == 0) << 32);
}

void sub_1D4EE1A6C(void *a1)
{
  __clang_call_terminate(a1);
}

unint64_t MIDIServerXPC_Server::deviceAddEntity(MIDIServerXPC_Server *this, xpc_object_t xstring, const swix::string *a3, int a4, int a5, int a6)
{
  MIDIProtocolID v9;
  char *string_ptr;
  void **v12;
  CFIndex v13;
  const __CFString *v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  void *exception;
  void *__p[2];
  unsigned __int8 v21;
  unsigned int v22;

  v9 = (int)a3;
  v22 = 0;
  string_ptr = (char *)xpc_string_get_string_ptr(xstring);
  std::string::basic_string[abi:ne180100]<0>(__p, string_ptr);
  if ((v21 & 0x80u) == 0)
    v12 = __p;
  else
    v12 = (void **)__p[0];
  if ((v21 & 0x80u) == 0)
    v13 = v21;
  else
    v13 = (CFIndex)__p[1];
  v14 = CFStringCreateWithBytes(0, (const UInt8 *)v12, v13, 0x8000100u, 0);
  if (!v14)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  if ((char)v21 < 0)
    operator delete(__p[0]);
  v15 = _MIDIDeviceAddEntity(this, v14, v9, a4, a5, a6, &v22);
  v16 = v22;
  CFRelease(v14);
  if (v15)
    v17 = v15;
  else
    v17 = v16;
  return v17 | ((unint64_t)(v15 == 0) << 32);
}

void sub_1D4EE1BC0(void *a1)
{
  __clang_call_terminate(a1);
}

unint64_t MIDIServerXPC_Server::deviceRemoveEntity(MIDIServerXPC_Server *this, int a2)
{
  unsigned int v2;

  v2 = _MIDIDeviceRemoveEntity(this, a2);
  return v2 | ((unint64_t)(v2 == 0) << 32);
}

unint64_t MIDIServerXPC_Server::entityAddOrRemoveEndpoints(MIDIServerXPC_Server *this, unint64_t a2, unint64_t a3)
{
  unsigned int v3;

  v3 = _MIDIEntityAddOrRemoveEndpoints(this, a2, a3);
  return v3 | ((unint64_t)(v3 == 0) << 32);
}

unint64_t MIDIServerXPC_Server::setupAddDevice(MIDIServerXPC_Server *this, int a2)
{
  unsigned int v2;

  if (a2)
    v2 = _MIDISetupAddExternalDevice(this);
  else
    v2 = _MIDISetupAddDevice(this);
  return v2 | ((unint64_t)(v2 == 0) << 32);
}

unint64_t MIDIServerXPC_Server::setupRemoveDevice(MIDIServerXPC_Server *this, int a2)
{
  unsigned int v2;

  if (a2)
    v2 = _MIDISetupRemoveExternalDevice(this);
  else
    v2 = _MIDISetupRemoveDevice(this);
  return v2 | ((unint64_t)(v2 == 0) << 32);
}

unint64_t MIDIServerXPC_Server::midiRestart(MIDIServerXPC_Server *this)
{
  unsigned int v1;

  v1 = _MIDIRestart(this);
  return v1 | ((unint64_t)(v1 == 0) << 32);
}

void MIDIServerXPC_Server::objectGetProperties(MIDIServerXPC_Server *this, MIDIServer *a2, int a3)
{
  int Properties;
  CFPropertyListRef v5;
  CFDataRef Data;
  const __CFData *v7;
  CFTypeID v8;
  const UInt8 *BytePtr;
  size_t Length;
  xpc_object_t v11;
  xpc_object_t object;
  xpc_object_t v13;
  xpc_object_t v14;
  CFPropertyListRef propertyList;

  propertyList = 0;
  Properties = _MIDIObjectGetProperties(a2, (CFMutableDictionaryRef *)&propertyList, a3);
  if (!Properties)
  {
    v5 = propertyList;
    if (propertyList)
    {
      Data = CFPropertyListCreateData(0, propertyList, kCFPropertyListBinaryFormat_v1_0, 0, 0);
      v7 = Data;
      if (Data)
      {
        v8 = CFGetTypeID(Data);
        if (v8 == CFDataGetTypeID())
        {
          BytePtr = CFDataGetBytePtr(v7);
          Length = CFDataGetLength(v7);
          swix::data::data((swix::data *)&object, BytePtr, Length);
          swix::result<swix::data>::result((uint64_t)this, &object);
          xpc_release(object);
          object = 0;
          CFRelease(v7);
LABEL_12:
          CFRelease(v5);
          return;
        }
        CFRelease(v7);
      }
      v13 = xpc_null_create();
      swix::result<swix::data>::result((uint64_t)this, &v13);
      xpc_release(v13);
      v13 = 0;
      goto LABEL_12;
    }
  }
  v11 = xpc_null_create();
  v14 = v11;
  if (Properties)
  {
    *(_DWORD *)this = Properties;
    *((_BYTE *)this + 8) = 0;
  }
  else
  {
    swix::result<swix::data>::result((uint64_t)this, &v14);
    v11 = v14;
  }
  xpc_release(v11);
}

unint64_t MIDIServerXPC_Server::flushOutput(MIDIServerXPC_Server *this)
{
  unsigned int v1;

  v1 = _MIDIFlushOutput((int)this);
  return v1 | ((unint64_t)(v1 == 0) << 32);
}

unint64_t MIDIServerXPC_Server::createThruConnection(MIDIServerXPC_Server *this, xpc_object_t *a2, xpc_object_t *a3)
{
  void **v5;
  __int128 v6;
  MIDIServer *v7;
  char *string_ptr;
  void **v9;
  CFIndex v10;
  CFStringRef v11;
  const void *v12;
  const UInt8 *bytes_ptr;
  size_t length;
  CFDataRef v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  void *v20;
  void *exception;
  unsigned int v22;
  void *__p[2];
  unsigned __int8 v24;
  char v25;
  audit_token_t atoken;

  swix::ipc_interface::audit_token((swix::ipc_interface *)__p, (uint64_t)this);
  if (v25)
    v5 = __p;
  else
    v5 = (void **)&gBogusAuditToken;
  v6 = *((_OWORD *)v5 + 1);
  *(_OWORD *)atoken.val = *(_OWORD *)v5;
  *(_OWORD *)&atoken.val[4] = v6;
  v7 = (MIDIServer *)audit_token_to_pid(&atoken);
  if ((_DWORD)v7 == -1)
    v7 = (MIDIServer *)getpid();
  v22 = 0;
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&atoken, "");
  if (MEMORY[0x1D826C5A8](*a2) == MEMORY[0x1E0C81390])
  {
    string_ptr = (char *)xpc_string_get_string_ptr(*a2);
    std::string::basic_string[abi:ne180100]<0>(__p, string_ptr);
    if ((v24 & 0x80u) == 0)
      v9 = __p;
    else
      v9 = (void **)__p[0];
    if ((v24 & 0x80u) == 0)
      v10 = v24;
    else
      v10 = (CFIndex)__p[1];
    v11 = CFStringCreateWithBytes(0, (const UInt8 *)v9, v10, 0x8000100u, 0);
    if (!v11)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x1D826B7EC](exception, "Could not construct");
    }
    v12 = *(const void **)atoken.val;
    *(_QWORD *)atoken.val = v11;
    if (v12)
      CFRelease(v12);
    if ((char)v24 < 0)
      operator delete(__p[0]);
  }
  bytes_ptr = (const UInt8 *)xpc_data_get_bytes_ptr(*a3);
  length = xpc_data_get_length(*a3);
  v15 = CFDataCreate(0, bytes_ptr, length);
  if (!v15)
  {
    v20 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v20, "Could not construct");
  }
  applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)__p, v15);
  v16 = _MIDIThruConnectionCreate(v7, *(const void **)atoken.val, (const __CFData *)__p[0], &v22);
  v17 = v22;
  if (__p[0])
    CFRelease(__p[0]);
  if (*(_QWORD *)atoken.val)
    CFRelease(*(CFTypeRef *)atoken.val);
  if (v16)
    v18 = v16;
  else
    v18 = v17;
  return v18 | ((unint64_t)(v16 == 0) << 32);
}

void sub_1D4EE2048(void *a1)
{
  __clang_call_terminate(a1);
}

unint64_t MIDIServerXPC_Server::disposeThruConnection(MIDIServerXPC_Server *this)
{
  unsigned int v1;

  v1 = _MIDIThruConnectionDispose(this);
  return v1 | ((unint64_t)(v1 == 0) << 32);
}

void MIDIServerXPC_Server::thruConnectionGetParams(MIDIServerXPC_Server *this, MIDIServer *a2)
{
  int Params;
  const UInt8 *BytePtr;
  size_t Length;
  xpc_object_t v6;
  void *exception;
  xpc_object_t object;
  CFDataRef theData;
  xpc_object_t v10;
  CFTypeRef cf;

  cf = 0;
  Params = _MIDIThruConnectionGetParams(a2, &cf);
  if (Params || !cf)
  {
    v6 = xpc_null_create();
    v10 = v6;
    if (Params)
    {
      *(_DWORD *)this = Params;
      *((_BYTE *)this + 8) = 0;
    }
    else
    {
      swix::result<swix::data>::result((uint64_t)this, &v10);
      v6 = v10;
    }
    xpc_release(v6);
  }
  else
  {
    applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)&theData, cf);
    if (!theData || (BytePtr = CFDataGetBytePtr(theData), !theData))
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x1D826B7EC](exception, "Could not construct");
    }
    Length = CFDataGetLength(theData);
    swix::data::data((swix::data *)&object, BytePtr, Length);
    swix::result<swix::data>::result((uint64_t)this, &object);
    xpc_release(object);
    object = 0;
    if (theData)
      CFRelease(theData);
  }
}

void sub_1D4EE21C4(void *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  __clang_call_terminate(a1);
}

unint64_t MIDIServerXPC_Server::thruConnectionSetParams(MIDIServerXPC_Server *this, xpc_object_t *a2, const swix::data *a3)
{
  const UInt8 *bytes_ptr;
  size_t length;
  CFDataRef v7;
  unsigned int v8;
  void *exception;
  CFTypeRef cf;

  bytes_ptr = (const UInt8 *)xpc_data_get_bytes_ptr(*a2);
  length = xpc_data_get_length(*a2);
  v7 = CFDataCreate(0, bytes_ptr, length);
  if (!v7)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)&cf, v7);
  v8 = _MIDIThruConnectionSetParams(this, (const __CFData *)cf);
  if (cf)
    CFRelease(cf);
  return v8 | ((unint64_t)(v8 == 0) << 32);
}

void sub_1D4EE22C0(void *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  __clang_call_terminate(a1);
}

void MIDIServerXPC_Server::thruConnectionFind(MIDIServerXPC_Server *this, xpc_object_t xstring)
{
  char *string_ptr;
  void **v4;
  CFIndex v5;
  MIDIServer *v6;
  int v7;
  BOOL v8;
  xpc_object_t v9;
  const UInt8 *BytePtr;
  size_t Length;
  void *exception;
  void *v13;
  xpc_object_t object;
  xpc_object_t v15;
  void *__p[2];
  unsigned __int8 v17;
  CFTypeRef cf;

  cf = 0;
  string_ptr = (char *)xpc_string_get_string_ptr(xstring);
  std::string::basic_string[abi:ne180100]<0>(__p, string_ptr);
  if ((v17 & 0x80u) == 0)
    v4 = __p;
  else
    v4 = (void **)__p[0];
  if ((v17 & 0x80u) == 0)
    v5 = v17;
  else
    v5 = (CFIndex)__p[1];
  v6 = (MIDIServer *)CFStringCreateWithBytes(0, (const UInt8 *)v4, v5, 0x8000100u, 0);
  if (!v6)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  if ((char)v17 < 0)
    operator delete(__p[0]);
  v7 = _MIDIThruConnectionFind(v6, (__CFData **)&cf);
  if (v7)
    v8 = 1;
  else
    v8 = cf == 0;
  if (v8)
  {
    v9 = xpc_null_create();
    v15 = v9;
    if (v7)
    {
      *(_DWORD *)this = v7;
      *((_BYTE *)this + 8) = 0;
    }
    else
    {
      swix::result<swix::data>::result((uint64_t)this, &v15);
      v9 = v15;
    }
    xpc_release(v9);
    v15 = 0;
  }
  else
  {
    applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)__p, cf);
    if (!__p[0] || (BytePtr = CFDataGetBytePtr((CFDataRef)__p[0]), !__p[0]))
    {
      v13 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x1D826B7EC](v13, "Could not construct");
    }
    Length = CFDataGetLength((CFDataRef)__p[0]);
    swix::data::data((swix::data *)&object, BytePtr, Length);
    swix::result<swix::data>::result((uint64_t)this, &object);
    xpc_release(object);
    object = 0;
    if (__p[0])
      CFRelease(__p[0]);
  }
  CFRelease(v6);
}

void sub_1D4EE24A8(void *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  __clang_call_terminate(a1);
}

unint64_t MIDIServerXPC_Server::objectFindByUniqueID(MIDIServerXPC_Server *this)
{
  unsigned int v1;
  uint64_t v2;
  unsigned int v4;
  unsigned int v5;

  v5 = 0;
  v4 = 0;
  v1 = _MIDIObjectFindByUniqueID(this, &v5, &v4);
  if (v1)
    v2 = v1;
  else
    v2 = v5;
  return v2 | ((unint64_t)v4 << 32);
}

void MIDIServerXPC_Server::getObjectTree(MIDIServerXPC_Server *this, int a2)
{
  uint64_t *v4;
  int v5;
  void *v6;
  unsigned int *bytes_ptr;
  size_t v8;
  unsigned int v9;
  xpc_object_t object;
  xpc_object_t xdata;
  void *v12;
  uint64_t v13;
  uint64_t v14;

  v4 = MIDIServer::defaultInstance(this) + 2;
  v5 = (*(uint64_t (**)(uint64_t *))(*v4 + 16))(v4);
  v12 = 0;
  v13 = 0;
  v14 = 0;
  ObjectTreeCache::GetObjectTree((MIDIServer *)&v12);
  v6 = v12;
  swix::data::data((swix::data *)&xdata, v12, v13 - (_QWORD)v12);
  if (a2)
  {
    bytes_ptr = (unsigned int *)xpc_data_get_bytes_ptr(xdata);
    v8 = xpc_data_get_length(xdata) >> 2;
    if ((int)v8 >= 1)
    {
      v9 = v8 + 1;
      do
      {
        *bytes_ptr = bswap32(*bytes_ptr);
        ++bytes_ptr;
        --v9;
      }
      while (v9 > 1);
    }
  }
  object = xdata;
  if (xdata)
    xpc_retain(xdata);
  else
    object = xpc_null_create();
  swix::result<swix::data>::result((uint64_t)this, &object);
  xpc_release(object);
  object = 0;
  xpc_release(xdata);
  if (v6)
    operator delete(v6);
  if (v5)
    (*(void (**)(uint64_t *))(*v4 + 24))(v4);
}

unint64_t MIDIServerXPC_Server::umpciObjectCreate(MIDIServerXPC_Server *this, int a2, xpc_object_t *a3)
{
  CFTypeRef *v5;
  __int128 v6;
  MIDIServer *v7;
  const UInt8 *bytes_ptr;
  size_t length;
  CFDataRef v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  void *exception;
  unsigned int v16;
  CFTypeRef cf[4];
  char v18;
  audit_token_t atoken;

  swix::ipc_interface::audit_token((swix::ipc_interface *)cf, (uint64_t)this);
  if (v18)
    v5 = cf;
  else
    v5 = (CFTypeRef *)&gBogusAuditToken;
  v6 = *((_OWORD *)v5 + 1);
  *(_OWORD *)atoken.val = *(_OWORD *)v5;
  *(_OWORD *)&atoken.val[4] = v6;
  v7 = (MIDIServer *)audit_token_to_pid(&atoken);
  if ((_DWORD)v7 == -1)
    v7 = (MIDIServer *)getpid();
  bytes_ptr = (const UInt8 *)xpc_data_get_bytes_ptr(*a3);
  length = xpc_data_get_length(*a3);
  v10 = CFDataCreate(0, bytes_ptr, length);
  if (!v10)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)cf, v10);
  applesauce::CF::make_DictionaryRef((applesauce::CF *)&atoken, (const applesauce::CF::DataRef *)cf[0]);
  v16 = 0;
  v11 = _UMPCIObjectCreate(v7, a2, *(const void **)atoken.val, (int *)&v16);
  v12 = v16;
  if (*(_QWORD *)atoken.val)
    CFRelease(*(CFTypeRef *)atoken.val);
  if (cf[0])
    CFRelease(cf[0]);
  if (v11)
    v13 = v11;
  else
    v13 = v12;
  return v13 | ((unint64_t)(v11 == 0) << 32);
}

void sub_1D4EE2790(void *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  __clang_call_terminate(a1);
}

unint64_t MIDIServerXPC_Server::umpciObjectDispose(MIDIServerXPC_Server *this)
{
  unsigned int v1;

  v1 = _UMPCIObjectDispose(this);
  return v1 | ((unint64_t)(v1 == 0) << 32);
}

unint64_t MIDIServerXPC_Server::umpciObjectSetDescription(MIDIServerXPC_Server *this, xpc_object_t *a2, const swix::data *a3)
{
  const UInt8 *bytes_ptr;
  size_t length;
  CFDataRef v7;
  unsigned int v8;
  void *exception;
  CFTypeRef cf;
  CFTypeRef v12;

  bytes_ptr = (const UInt8 *)xpc_data_get_bytes_ptr(*a2);
  length = xpc_data_get_length(*a2);
  v7 = CFDataCreate(0, bytes_ptr, length);
  if (!v7)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)&v12, v7);
  applesauce::CF::make_DictionaryRef((applesauce::CF *)&cf, (const applesauce::CF::DataRef *)v12);
  v8 = _UMPCIObjectSetDescription(this, cf);
  if (cf)
    CFRelease(cf);
  if (v12)
    CFRelease(v12);
  return v8 | ((unint64_t)(v8 == 0) << 32);
}

void sub_1D4EE28B8(void *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  __clang_call_terminate(a1);
}

unint64_t MIDIServerXPC_Server::umpciObjectSetEnableState(MIDIServerXPC_Server *this, int a2)
{
  unsigned int v2;

  v2 = _UMPCIObjectSetEnableState(this, a2);
  return v2 | ((unint64_t)(v2 == 0) << 32);
}

void MIDIServerXPC_Server::umpciGlobalState(MIDIServerXPC_Server *this)
{
  int v2;
  CFDataRef Data;
  const UInt8 *BytePtr;
  size_t Length;
  xpc_object_t v6;
  void *exception;
  xpc_object_t object;
  CFDataRef theData;
  xpc_object_t v10;
  CFPropertyListRef propertyList;
  xpc_object_t v12;
  CFTypeRef v13;

  v13 = 0;
  v2 = _UMPCIGlobalState((MIDIServer *)&v13);
  if (v2 || !v13)
  {
    v6 = xpc_null_create();
    v12 = v6;
    if (v2)
    {
      *(_DWORD *)this = v2;
      *((_BYTE *)this + 8) = 0;
    }
    else
    {
      swix::result<swix::data>::result((uint64_t)this, &v12);
      v6 = v12;
    }
    xpc_release(v6);
  }
  else
  {
    applesauce::CF::DictionaryRef::DictionaryRef((applesauce::CF::DictionaryRef *)&propertyList, v13);
    Data = CFPropertyListCreateData(0, propertyList, kCFPropertyListBinaryFormat_v1_0, 0, 0);
    if (Data)
    {
      applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)&theData, Data);
      if (!theData || (BytePtr = CFDataGetBytePtr(theData), !theData))
      {
        exception = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x1D826B7EC](exception, "Could not construct");
      }
      Length = CFDataGetLength(theData);
      swix::data::data((swix::data *)&object, BytePtr, Length);
      swix::result<swix::data>::result((uint64_t)this, &object);
      xpc_release(object);
      object = 0;
      if (theData)
        CFRelease(theData);
    }
    else
    {
      v10 = xpc_null_create();
      swix::result<swix::data>::result((uint64_t)this, &v10);
      xpc_release(v10);
      v10 = 0;
    }
    if (propertyList)
      CFRelease(propertyList);
  }
}

void sub_1D4EE2A7C(void *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  __clang_call_terminate(a1);
}

unint64_t MIDIServerXPC_Server::umpciDiscover(MIDIServerXPC_Server *this)
{
  unsigned int v1;

  v1 = _UMPCIDiscover(this);
  return v1 | ((unint64_t)(v1 == 0) << 32);
}

void CADeprecated::TimerTaskMgr::~TimerTaskMgr(CADeprecated::TimerTaskMgr *this)
{
  CADeprecated::TimerTaskMgr::~TimerTaskMgr(this);
  JUMPOUT(0x1D826BA98);
}

{
  void *v2;

  *(_QWORD *)this = &off_1E98B9C40;
  v2 = (void *)*((_QWORD *)this + 36);
  if (v2)
  {
    *((_QWORD *)this + 37) = v2;
    operator delete(v2);
  }
  CADeprecated::CAGuard::~CAGuard((CADeprecated::TimerTaskMgr *)((char *)this + 144));
}

uint64_t CADeprecated::TimerTaskMgr::RequestStop(CADeprecated::TimerTaskMgr *this)
{
  *((_BYTE *)this + 136) = 1;
  return CADeprecated::CAGuard::Notify((CADeprecated::TimerTaskMgr *)((char *)this + 144));
}

void CADeprecated::TimerTaskMgr::Run(CADeprecated::TimerTaskMgr *this)
{
  CADeprecated::CAMutex *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;

  v2 = (CADeprecated::TimerTaskMgr *)((char *)this + 144);
  CADeprecated::CAMutex::Lock((CADeprecated::TimerTaskMgr *)((char *)this + 144));
  if (!*((_BYTE *)this + 136))
  {
    while (1)
    {
      if (*((_QWORD *)this + 40) == -1)
      {
        v5 = (uint64_t *)*((_QWORD *)this + 37);
        v4 = -1;
      }
      else
      {
        v3 = mach_absolute_time();
        v4 = *((_QWORD *)this + 40);
        v5 = (uint64_t *)*((_QWORD *)this + 37);
        if (v3 >= v4)
        {
          *((_WORD *)this + 156) = 256;
          v6 = (uint64_t *)*((_QWORD *)this + 36);
          if (v6 != v5)
          {
            do
            {
              v7 = mach_absolute_time();
              v8 = (_QWORD *)*v6;
              if (*((_QWORD *)this + 35) + v7 >= *(_QWORD *)(*v6 + 8)
                && (v9 = v7,
                    v8[1] = -1,
                    CADeprecated::CAMutex::Unlock(v2),
                    (*(void (**)(_QWORD *, uint64_t))(*v8 + 16))(v8, v9),
                    CADeprecated::CAMutex::Lock(v2),
                    *((_BYTE *)this + 312)))
              {
                *((_BYTE *)this + 312) = 0;
                v6 = (uint64_t *)*((_QWORD *)this + 36);
              }
              else
              {
                ++v6;
              }
              v5 = v6;
            }
            while (v6 != *((uint64_t **)this + 37));
          }
          v4 = -1;
          *((_QWORD *)this + 40) = -1;
          *((_BYTE *)this + 313) = 0;
        }
      }
      v10 = (uint64_t *)*((_QWORD *)this + 36);
      if (v10 != v5)
      {
        v11 = -1;
        do
        {
          v12 = *v10++;
          v13 = *(_QWORD *)(v12 + 8);
          if (v13 < v11)
            v11 = v13;
        }
        while (v10 != v5);
        if (v11 < v4)
          break;
      }
      if (v4 != -1)
        goto LABEL_20;
      CADeprecated::CAGuard::Wait(v2);
LABEL_23:
      if (*((_BYTE *)this + 136))
        goto LABEL_24;
    }
    *((_QWORD *)this + 40) = v11;
LABEL_20:
    v14 = __udivti3();
    mach_absolute_time();
    v15 = __udivti3();
    if (v14 > v15)
      (*(void (**)(CADeprecated::CAMutex *, unint64_t))(*(_QWORD *)v2 + 64))(v2, v14 - v15);
    goto LABEL_23;
  }
LABEL_24:
  CADeprecated::CAMutex::Unlock(v2);
}

void CADeprecated::TimerTaskMgr::AddTask(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  int v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  uint64_t v16;

  v4 = (_QWORD *)(a1 + 144);
  v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 144) + 16))(a1 + 144);
  *(_QWORD *)(a2 + 8) = -1;
  v7 = (_QWORD *)v4[19];
  v6 = v4[20];
  if ((unint64_t)v7 >= v6)
  {
    v9 = *(_QWORD **)(a1 + 288);
    v10 = v7 - v9;
    v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 61)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v12 = v6 - (_QWORD)v9;
    if (v12 >> 2 > v11)
      v11 = v12 >> 2;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
      v13 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v13 = v11;
    if (v13)
    {
      if (v13 >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v14 = (char *)operator new(8 * v13);
    }
    else
    {
      v14 = 0;
    }
    v15 = &v14[8 * v10];
    *(_QWORD *)v15 = a2;
    v8 = v15 + 8;
    if (v7 != v9)
    {
      do
      {
        v16 = *--v7;
        *((_QWORD *)v15 - 1) = v16;
        v15 -= 8;
      }
      while (v7 != v9);
      v7 = *(_QWORD **)(a1 + 288);
    }
    *(_QWORD *)(a1 + 288) = v15;
    *(_QWORD *)(a1 + 296) = v8;
    *(_QWORD *)(a1 + 304) = &v14[8 * v13];
    if (v7)
      operator delete(v7);
  }
  else
  {
    *v7 = a2;
    v8 = v7 + 1;
  }
  *(_QWORD *)(a1 + 296) = v8;
  *(_BYTE *)(a1 + 312) = 1;
  if (v5)
    (*(void (**)(_QWORD *))(*v4 + 24))(v4);
}

void sub_1D4EE2E50(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  int v2;

  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

uint64_t CADeprecated::TimerTaskMgr::SetTaskNextWakeTime(uint64_t a1, uint64_t a2, unint64_t a3)
{
  CADeprecated::CAGuard *v6;
  uint64_t result;
  uint64_t *v8;
  uint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int v13;

  v6 = (CADeprecated::CAGuard *)(a1 + 144);
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 144) + 16))(a1 + 144);
  if (*(_QWORD *)(a2 + 8) <= a3)
    goto LABEL_12;
  *(_QWORD *)(a2 + 8) = a3;
  v8 = *(uint64_t **)(a1 + 288);
  v9 = *(uint64_t **)(a1 + 296);
  if (v8 == v9)
    goto LABEL_12;
  v10 = -1;
  do
  {
    v11 = *v8++;
    v12 = *(_QWORD *)(v11 + 8);
    if (v12 < v10)
      v10 = v12;
  }
  while (v8 != v9);
  if (v10 >= *(_QWORD *)(a1 + 320))
  {
LABEL_12:
    if ((_DWORD)result)
      return (*(uint64_t (**)(CADeprecated::CAGuard *))(*(_QWORD *)v6 + 24))(v6);
  }
  else
  {
    *(_QWORD *)(a1 + 320) = v10;
    v13 = *(unsigned __int8 *)(a1 + 313);
    if ((_DWORD)result)
      result = (*(uint64_t (**)(CADeprecated::CAGuard *))(*(_QWORD *)v6 + 24))(v6);
    if (!v13)
      return CADeprecated::CAGuard::Notify(v6);
  }
  return result;
}

void sub_1D4EE31F8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1D4EE32C8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1D4EE338C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1D4EE37EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18)
{
  void *v18;
  void *v19;
  void *v20;

  _Unwind_Resume(a1);
}

void sub_1D4EE3A0C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1D4EE3DC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, void *a12)
{
  void *v12;

  _Unwind_Resume(a1);
}

void sub_1D4EE3F2C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1D4EE3FC8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1D4EE408C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1D4EE43D0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void ObjectTreeCache::GetObjectTree(MIDIServer *a1)
{
  int *v2;
  int v3;
  unint64_t v4;
  int *v5;
  _DWORD *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  BOOL v10;
  unint64_t v11;
  uint64_t v12;
  int *v13;
  unint64_t v14;
  int v15;
  MIDIServer *v16;
  MIDIServer *v17;
  int v18;
  int v19;
  unint64_t v20;
  int *v21;
  _DWORD *v22;
  int *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  _DWORD *v29;
  int v30;
  MIDIServer *i;
  MIDIServer *v32;
  int *v33;
  int v34;
  unint64_t v35;
  int *v36;
  _DWORD *v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  int *v43;
  unint64_t v44;
  int v45;
  MIDIServer *v46;
  MIDIServer *v47;
  int v48;
  unint64_t v49;
  int *v50;
  _DWORD *v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  _DWORD *v57;
  int v58;
  int *v59;
  int v60;
  unint64_t v61;
  int *v62;
  _DWORD *v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  int *v69;
  unint64_t v70;
  int v71;
  MIDIServer *v72;
  MIDIServer *v73;
  int v74;
  unint64_t v75;
  int *v76;
  _DWORD *v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t v82;
  _DWORD *v83;
  int v84;
  int v85;
  int v86;
  unint64_t v87;
  int *v88;
  _DWORD *v89;
  int *v90;
  uint64_t v91;
  unint64_t v92;
  uint64_t v93;
  unint64_t v94;
  uint64_t v95;
  int *v96;
  unint64_t v97;
  int v98;
  MIDIServer *v99;
  MIDIServer *v100;
  int v101;
  int v102;
  unint64_t v103;
  int *v104;
  _DWORD *v105;
  int *v106;
  uint64_t v107;
  unint64_t v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  _DWORD *v112;
  int v113;
  MIDIServer *j;
  MIDIServer *v115;

  v2 = (int *)_MIDIGetNumberOfDevices(a1);
  v3 = (int)v2;
  v5 = (int *)*((_QWORD *)a1 + 1);
  v4 = *((_QWORD *)a1 + 2);
  if ((unint64_t)v5 >= v4)
  {
    v2 = *(int **)a1;
    v7 = ((uint64_t)v5 - *(_QWORD *)a1) >> 2;
    v8 = v7 + 1;
    if ((unint64_t)(v7 + 1) >> 62)
      goto LABEL_142;
    v9 = v4 - (_QWORD)v2;
    if (v9 >> 1 > v8)
      v8 = v9 >> 1;
    v10 = (unint64_t)v9 >= 0x7FFFFFFFFFFFFFFCLL;
    v11 = 0x3FFFFFFFFFFFFFFFLL;
    if (!v10)
      v11 = v8;
    if (v11)
    {
      v11 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(v11);
      v2 = *(int **)a1;
      v5 = (int *)*((_QWORD *)a1 + 1);
    }
    else
    {
      v12 = 0;
    }
    v13 = (int *)(v11 + 4 * v7);
    v14 = v11 + 4 * v12;
    *v13 = v3;
    v6 = v13 + 1;
    while (v5 != v2)
    {
      v15 = *--v5;
      *--v13 = v15;
    }
    *(_QWORD *)a1 = v13;
    *((_QWORD *)a1 + 1) = v6;
    *((_QWORD *)a1 + 2) = v14;
    if (v2)
      operator delete(v2);
  }
  else
  {
    *v5 = (int)v2;
    v6 = v5 + 1;
  }
  *((_QWORD *)a1 + 1) = v6;
  if (v3 >= 1)
  {
    v16 = 0;
    v17 = (MIDIServer *)v3;
    do
    {
      v18 = _MIDIGetDevice(v16);
      v19 = v18;
      v21 = (int *)*((_QWORD *)a1 + 1);
      v20 = *((_QWORD *)a1 + 2);
      if ((unint64_t)v21 >= v20)
      {
        v23 = *(int **)a1;
        v24 = ((uint64_t)v21 - *(_QWORD *)a1) >> 2;
        v25 = v24 + 1;
        if ((unint64_t)(v24 + 1) >> 62)
          goto LABEL_142;
        v26 = v20 - (_QWORD)v23;
        if (v26 >> 1 > v25)
          v25 = v26 >> 1;
        if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFFCLL)
          v27 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v27 = v25;
        if (v27)
        {
          v27 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(v27);
          v23 = *(int **)a1;
          v21 = (int *)*((_QWORD *)a1 + 1);
        }
        else
        {
          v28 = 0;
        }
        v29 = (_DWORD *)(v27 + 4 * v24);
        *v29 = v19;
        v22 = v29 + 1;
        while (v21 != v23)
        {
          v30 = *--v21;
          *--v29 = v30;
        }
        *(_QWORD *)a1 = v29;
        *((_QWORD *)a1 + 1) = v22;
        *((_QWORD *)a1 + 2) = v27 + 4 * v28;
        if (v23)
          operator delete(v23);
      }
      else
      {
        *v21 = v18;
        v22 = v21 + 1;
      }
      *((_QWORD *)a1 + 1) = v22;
      v16 = (MIDIServer *)((char *)v16 + 1);
    }
    while (v16 != v17);
    for (i = 0; i != v17; i = (MIDIServer *)((char *)i + 1))
    {
      v32 = (MIDIServer *)_MIDIGetDevice(i);
      AddDeviceChildren((uint64_t)a1, v32);
    }
  }
  v33 = (int *)_MIDIGetNumberOfSources((MIDIServer *)v2);
  v34 = (int)v33;
  v36 = (int *)*((_QWORD *)a1 + 1);
  v35 = *((_QWORD *)a1 + 2);
  if ((unint64_t)v36 >= v35)
  {
    v33 = *(int **)a1;
    v38 = ((uint64_t)v36 - *(_QWORD *)a1) >> 2;
    v39 = v38 + 1;
    if ((unint64_t)(v38 + 1) >> 62)
      goto LABEL_142;
    v40 = v35 - (_QWORD)v33;
    if (v40 >> 1 > v39)
      v39 = v40 >> 1;
    v10 = (unint64_t)v40 >= 0x7FFFFFFFFFFFFFFCLL;
    v41 = 0x3FFFFFFFFFFFFFFFLL;
    if (!v10)
      v41 = v39;
    if (v41)
    {
      v41 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(v41);
      v33 = *(int **)a1;
      v36 = (int *)*((_QWORD *)a1 + 1);
    }
    else
    {
      v42 = 0;
    }
    v43 = (int *)(v41 + 4 * v38);
    v44 = v41 + 4 * v42;
    *v43 = v34;
    v37 = v43 + 1;
    while (v36 != v33)
    {
      v45 = *--v36;
      *--v43 = v45;
    }
    *(_QWORD *)a1 = v43;
    *((_QWORD *)a1 + 1) = v37;
    *((_QWORD *)a1 + 2) = v44;
    if (v33)
      operator delete(v33);
  }
  else
  {
    *v36 = (int)v33;
    v37 = v36 + 1;
  }
  *((_QWORD *)a1 + 1) = v37;
  if (v34 >= 1)
  {
    v46 = 0;
    v47 = (MIDIServer *)v34;
    do
    {
      v33 = (int *)_MIDIGetSource(v46);
      v48 = (int)v33;
      v50 = (int *)*((_QWORD *)a1 + 1);
      v49 = *((_QWORD *)a1 + 2);
      if ((unint64_t)v50 >= v49)
      {
        v33 = *(int **)a1;
        v52 = ((uint64_t)v50 - *(_QWORD *)a1) >> 2;
        v53 = v52 + 1;
        if ((unint64_t)(v52 + 1) >> 62)
          goto LABEL_142;
        v54 = v49 - (_QWORD)v33;
        if (v54 >> 1 > v53)
          v53 = v54 >> 1;
        if ((unint64_t)v54 >= 0x7FFFFFFFFFFFFFFCLL)
          v55 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v55 = v53;
        if (v55)
        {
          v55 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(v55);
          v33 = *(int **)a1;
          v50 = (int *)*((_QWORD *)a1 + 1);
        }
        else
        {
          v56 = 0;
        }
        v57 = (_DWORD *)(v55 + 4 * v52);
        *v57 = v48;
        v51 = v57 + 1;
        while (v50 != v33)
        {
          v58 = *--v50;
          *--v57 = v58;
        }
        *(_QWORD *)a1 = v57;
        *((_QWORD *)a1 + 1) = v51;
        *((_QWORD *)a1 + 2) = v55 + 4 * v56;
        if (v33)
          operator delete(v33);
      }
      else
      {
        *v50 = (int)v33;
        v51 = v50 + 1;
      }
      *((_QWORD *)a1 + 1) = v51;
      v46 = (MIDIServer *)((char *)v46 + 1);
    }
    while (v46 != v47);
  }
  v59 = (int *)_MIDIGetNumberOfDestinations((MIDIServer *)v33);
  v60 = (int)v59;
  v62 = (int *)*((_QWORD *)a1 + 1);
  v61 = *((_QWORD *)a1 + 2);
  if ((unint64_t)v62 >= v61)
  {
    v59 = *(int **)a1;
    v64 = ((uint64_t)v62 - *(_QWORD *)a1) >> 2;
    v65 = v64 + 1;
    if ((unint64_t)(v64 + 1) >> 62)
      goto LABEL_142;
    v66 = v61 - (_QWORD)v59;
    if (v66 >> 1 > v65)
      v65 = v66 >> 1;
    v10 = (unint64_t)v66 >= 0x7FFFFFFFFFFFFFFCLL;
    v67 = 0x3FFFFFFFFFFFFFFFLL;
    if (!v10)
      v67 = v65;
    if (v67)
    {
      v67 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(v67);
      v59 = *(int **)a1;
      v62 = (int *)*((_QWORD *)a1 + 1);
    }
    else
    {
      v68 = 0;
    }
    v69 = (int *)(v67 + 4 * v64);
    v70 = v67 + 4 * v68;
    *v69 = v60;
    v63 = v69 + 1;
    while (v62 != v59)
    {
      v71 = *--v62;
      *--v69 = v71;
    }
    *(_QWORD *)a1 = v69;
    *((_QWORD *)a1 + 1) = v63;
    *((_QWORD *)a1 + 2) = v70;
    if (v59)
      operator delete(v59);
  }
  else
  {
    *v62 = (int)v59;
    v63 = v62 + 1;
  }
  *((_QWORD *)a1 + 1) = v63;
  if (v60 >= 1)
  {
    v72 = 0;
    v73 = (MIDIServer *)v60;
    do
    {
      v59 = (int *)_MIDIGetDestination(v72);
      v74 = (int)v59;
      v76 = (int *)*((_QWORD *)a1 + 1);
      v75 = *((_QWORD *)a1 + 2);
      if ((unint64_t)v76 >= v75)
      {
        v59 = *(int **)a1;
        v78 = ((uint64_t)v76 - *(_QWORD *)a1) >> 2;
        v79 = v78 + 1;
        if ((unint64_t)(v78 + 1) >> 62)
          goto LABEL_142;
        v80 = v75 - (_QWORD)v59;
        if (v80 >> 1 > v79)
          v79 = v80 >> 1;
        if ((unint64_t)v80 >= 0x7FFFFFFFFFFFFFFCLL)
          v81 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v81 = v79;
        if (v81)
        {
          v81 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(v81);
          v59 = *(int **)a1;
          v76 = (int *)*((_QWORD *)a1 + 1);
        }
        else
        {
          v82 = 0;
        }
        v83 = (_DWORD *)(v81 + 4 * v78);
        *v83 = v74;
        v77 = v83 + 1;
        while (v76 != v59)
        {
          v84 = *--v76;
          *--v83 = v84;
        }
        *(_QWORD *)a1 = v83;
        *((_QWORD *)a1 + 1) = v77;
        *((_QWORD *)a1 + 2) = v81 + 4 * v82;
        if (v59)
          operator delete(v59);
      }
      else
      {
        *v76 = (int)v59;
        v77 = v76 + 1;
      }
      *((_QWORD *)a1 + 1) = v77;
      v72 = (MIDIServer *)((char *)v72 + 1);
    }
    while (v72 != v73);
  }
  v85 = _MIDIGetNumberOfExternalDevices((MIDIServer *)v59);
  v86 = v85;
  v88 = (int *)*((_QWORD *)a1 + 1);
  v87 = *((_QWORD *)a1 + 2);
  if ((unint64_t)v88 < v87)
  {
    *v88 = v85;
    v89 = v88 + 1;
    goto LABEL_120;
  }
  v90 = *(int **)a1;
  v91 = ((uint64_t)v88 - *(_QWORD *)a1) >> 2;
  v92 = v91 + 1;
  if ((unint64_t)(v91 + 1) >> 62)
LABEL_142:
    std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
  v93 = v87 - (_QWORD)v90;
  if (v93 >> 1 > v92)
    v92 = v93 >> 1;
  v10 = (unint64_t)v93 >= 0x7FFFFFFFFFFFFFFCLL;
  v94 = 0x3FFFFFFFFFFFFFFFLL;
  if (!v10)
    v94 = v92;
  if (v94)
  {
    v94 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(v94);
    v90 = *(int **)a1;
    v88 = (int *)*((_QWORD *)a1 + 1);
  }
  else
  {
    v95 = 0;
  }
  v96 = (int *)(v94 + 4 * v91);
  v97 = v94 + 4 * v95;
  *v96 = v86;
  v89 = v96 + 1;
  while (v88 != v90)
  {
    v98 = *--v88;
    *--v96 = v98;
  }
  *(_QWORD *)a1 = v96;
  *((_QWORD *)a1 + 1) = v89;
  *((_QWORD *)a1 + 2) = v97;
  if (v90)
    operator delete(v90);
LABEL_120:
  *((_QWORD *)a1 + 1) = v89;
  if (v86 >= 1)
  {
    v99 = 0;
    v100 = (MIDIServer *)v86;
    do
    {
      v101 = _MIDIGetExternalDevice(v99);
      v102 = v101;
      v104 = (int *)*((_QWORD *)a1 + 1);
      v103 = *((_QWORD *)a1 + 2);
      if ((unint64_t)v104 >= v103)
      {
        v106 = *(int **)a1;
        v107 = ((uint64_t)v104 - *(_QWORD *)a1) >> 2;
        v108 = v107 + 1;
        if ((unint64_t)(v107 + 1) >> 62)
          goto LABEL_142;
        v109 = v103 - (_QWORD)v106;
        if (v109 >> 1 > v108)
          v108 = v109 >> 1;
        if ((unint64_t)v109 >= 0x7FFFFFFFFFFFFFFCLL)
          v110 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v110 = v108;
        if (v110)
        {
          v110 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(v110);
          v106 = *(int **)a1;
          v104 = (int *)*((_QWORD *)a1 + 1);
        }
        else
        {
          v111 = 0;
        }
        v112 = (_DWORD *)(v110 + 4 * v107);
        *v112 = v102;
        v105 = v112 + 1;
        while (v104 != v106)
        {
          v113 = *--v104;
          *--v112 = v113;
        }
        *(_QWORD *)a1 = v112;
        *((_QWORD *)a1 + 1) = v105;
        *((_QWORD *)a1 + 2) = v110 + 4 * v111;
        if (v106)
          operator delete(v106);
      }
      else
      {
        *v104 = v101;
        v105 = v104 + 1;
      }
      *((_QWORD *)a1 + 1) = v105;
      v99 = (MIDIServer *)((char *)v99 + 1);
    }
    while (v99 != v100);
    for (j = 0; j != v100; j = (MIDIServer *)((char *)j + 1))
    {
      v115 = (MIDIServer *)_MIDIGetExternalDevice(j);
      AddDeviceChildren((uint64_t)a1, v115);
    }
  }
}

void AddDeviceChildren(uint64_t a1, MIDIServer *a2)
{
  int NumberOfEntities;
  int v5;
  unint64_t v6;
  int *v7;
  _DWORD *v8;
  int *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  BOOL v13;
  unint64_t v14;
  uint64_t v15;
  int *v16;
  unint64_t v17;
  int v18;
  char *v19;
  char *v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  int Entity;
  int v25;
  unint64_t v26;
  int *v27;
  _DWORD *v28;
  int *v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  _DWORD *v35;
  int v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  char *v41;
  char *v42;
  int v43;
  char *v44;
  MIDIServer *v45;
  int NumberOfSources;
  int v47;
  unint64_t v48;
  int *v49;
  _DWORD *v50;
  int *v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  int *v57;
  int v58;
  unint64_t v59;
  uint64_t v60;
  int Source;
  int v62;
  unint64_t v63;
  int *v64;
  _DWORD *v65;
  int *v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  unint64_t v70;
  uint64_t v71;
  _DWORD *v72;
  int v73;
  int NumberOfDestinations;
  int v75;
  unint64_t v76;
  int *v77;
  _DWORD *v78;
  int *v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  int *v85;
  int v86;
  unint64_t v87;
  uint64_t v88;
  int Destination;
  int v90;
  unint64_t v91;
  int *v92;
  _DWORD *v93;
  int *v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  unint64_t v98;
  uint64_t v99;
  _DWORD *v100;
  int v101;
  char *v102;

  NumberOfEntities = _MIDIDeviceGetNumberOfEntities(a2);
  v5 = NumberOfEntities;
  v7 = *(int **)(a1 + 8);
  v6 = *(_QWORD *)(a1 + 16);
  if ((unint64_t)v7 >= v6)
  {
    v9 = *(int **)a1;
    v10 = ((uint64_t)v7 - *(_QWORD *)a1) >> 2;
    v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 62)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v12 = v6 - (_QWORD)v9;
    if (v12 >> 1 > v11)
      v11 = v12 >> 1;
    v13 = (unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL;
    v14 = 0x3FFFFFFFFFFFFFFFLL;
    if (!v13)
      v14 = v11;
    if (v14)
    {
      v14 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(v14);
      v9 = *(int **)a1;
      v7 = *(int **)(a1 + 8);
    }
    else
    {
      v15 = 0;
    }
    v16 = (int *)(v14 + 4 * v10);
    v17 = v14 + 4 * v15;
    *v16 = v5;
    v8 = v16 + 1;
    while (v7 != v9)
    {
      v18 = *--v7;
      *--v16 = v18;
    }
    *(_QWORD *)a1 = v16;
    *(_QWORD *)(a1 + 8) = v8;
    *(_QWORD *)(a1 + 16) = v17;
    if (v9)
      operator delete(v9);
  }
  else
  {
    *v7 = NumberOfEntities;
    v8 = v7 + 1;
  }
  *(_QWORD *)(a1 + 8) = v8;
  if (v5 >= 1)
  {
    v19 = 0;
    v20 = 0;
    v21 = 0;
    v22 = 0;
    v23 = v5;
    do
    {
      Entity = _MIDIDeviceGetEntity(a2, v22);
      v25 = Entity;
      v27 = *(int **)(a1 + 8);
      v26 = *(_QWORD *)(a1 + 16);
      if ((unint64_t)v27 >= v26)
      {
        v29 = *(int **)a1;
        v30 = ((uint64_t)v27 - *(_QWORD *)a1) >> 2;
        v31 = v30 + 1;
        if ((unint64_t)(v30 + 1) >> 62)
          std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
        v32 = v26 - (_QWORD)v29;
        if (v32 >> 1 > v31)
          v31 = v32 >> 1;
        v13 = (unint64_t)v32 >= 0x7FFFFFFFFFFFFFFCLL;
        v33 = 0x3FFFFFFFFFFFFFFFLL;
        if (!v13)
          v33 = v31;
        if (v33)
        {
          v33 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(v33);
          v29 = *(int **)a1;
          v27 = *(int **)(a1 + 8);
        }
        else
        {
          v34 = 0;
        }
        v35 = (_DWORD *)(v33 + 4 * v30);
        *v35 = v25;
        v28 = v35 + 1;
        while (v27 != v29)
        {
          v36 = *--v27;
          *--v35 = v36;
        }
        *(_QWORD *)a1 = v35;
        *(_QWORD *)(a1 + 8) = v28;
        *(_QWORD *)(a1 + 16) = v33 + 4 * v34;
        if (v29)
          operator delete(v29);
      }
      else
      {
        *v27 = Entity;
        v28 = v27 + 1;
      }
      *(_QWORD *)(a1 + 8) = v28;
      if ((unint64_t)v20 >= v21)
      {
        v37 = (v20 - v19) >> 2;
        v38 = v37 + 1;
        if ((unint64_t)(v37 + 1) >> 62)
          std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
        if ((uint64_t)(v21 - (_QWORD)v19) >> 1 > v38)
          v38 = (uint64_t)(v21 - (_QWORD)v19) >> 1;
        if (v21 - (unint64_t)v19 >= 0x7FFFFFFFFFFFFFFCLL)
          v39 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v39 = v38;
        if (v39)
          v39 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(v39);
        else
          v40 = 0;
        v41 = (char *)(v39 + 4 * v37);
        *(_DWORD *)v41 = v25;
        v42 = v41 + 4;
        while (v20 != v19)
        {
          v43 = *((_DWORD *)v20 - 1);
          v20 -= 4;
          *((_DWORD *)v41 - 1) = v43;
          v41 -= 4;
        }
        v21 = v39 + 4 * v40;
        if (v19)
          operator delete(v19);
        v19 = v41;
        v20 = v42;
      }
      else
      {
        *(_DWORD *)v20 = v25;
        v20 += 4;
      }
      ++v22;
    }
    while (v22 != v23);
    if (v19 != v20)
    {
      v44 = v19;
      do
      {
        v102 = v44;
        v45 = (MIDIServer *)*(unsigned int *)v44;
        NumberOfSources = _MIDIEntityGetNumberOfSources(v45);
        v47 = NumberOfSources;
        v49 = *(int **)(a1 + 8);
        v48 = *(_QWORD *)(a1 + 16);
        if ((unint64_t)v49 >= v48)
        {
          v51 = *(int **)a1;
          v52 = ((uint64_t)v49 - *(_QWORD *)a1) >> 2;
          v53 = v52 + 1;
          if ((unint64_t)(v52 + 1) >> 62)
            std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
          v54 = v48 - (_QWORD)v51;
          if (v54 >> 1 > v53)
            v53 = v54 >> 1;
          if ((unint64_t)v54 >= 0x7FFFFFFFFFFFFFFCLL)
            v55 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v55 = v53;
          if (v55)
          {
            v55 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(v55);
            v51 = *(int **)a1;
            v49 = *(int **)(a1 + 8);
          }
          else
          {
            v56 = 0;
          }
          v57 = (int *)(v55 + 4 * v52);
          *v57 = v47;
          v50 = v57 + 1;
          while (v49 != v51)
          {
            v58 = *--v49;
            *--v57 = v58;
          }
          *(_QWORD *)a1 = v57;
          *(_QWORD *)(a1 + 8) = v50;
          *(_QWORD *)(a1 + 16) = v55 + 4 * v56;
          if (v51)
            operator delete(v51);
        }
        else
        {
          *v49 = NumberOfSources;
          v50 = v49 + 1;
        }
        *(_QWORD *)(a1 + 8) = v50;
        if (v47 >= 1)
        {
          v59 = 0;
          v60 = v47;
          do
          {
            Source = _MIDIEntityGetSource(v45, v59);
            v62 = Source;
            v64 = *(int **)(a1 + 8);
            v63 = *(_QWORD *)(a1 + 16);
            if ((unint64_t)v64 >= v63)
            {
              v66 = *(int **)a1;
              v67 = ((uint64_t)v64 - *(_QWORD *)a1) >> 2;
              v68 = v67 + 1;
              if ((unint64_t)(v67 + 1) >> 62)
                std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
              v69 = v63 - (_QWORD)v66;
              if (v69 >> 1 > v68)
                v68 = v69 >> 1;
              if ((unint64_t)v69 >= 0x7FFFFFFFFFFFFFFCLL)
                v70 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v70 = v68;
              if (v70)
              {
                v70 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(v70);
                v66 = *(int **)a1;
                v64 = *(int **)(a1 + 8);
              }
              else
              {
                v71 = 0;
              }
              v72 = (_DWORD *)(v70 + 4 * v67);
              *v72 = v62;
              v65 = v72 + 1;
              while (v64 != v66)
              {
                v73 = *--v64;
                *--v72 = v73;
              }
              *(_QWORD *)a1 = v72;
              *(_QWORD *)(a1 + 8) = v65;
              *(_QWORD *)(a1 + 16) = v70 + 4 * v71;
              if (v66)
                operator delete(v66);
            }
            else
            {
              *v64 = Source;
              v65 = v64 + 1;
            }
            *(_QWORD *)(a1 + 8) = v65;
            ++v59;
          }
          while (v59 != v60);
        }
        NumberOfDestinations = _MIDIEntityGetNumberOfDestinations(v45);
        v75 = NumberOfDestinations;
        v77 = *(int **)(a1 + 8);
        v76 = *(_QWORD *)(a1 + 16);
        if ((unint64_t)v77 >= v76)
        {
          v79 = *(int **)a1;
          v80 = ((uint64_t)v77 - *(_QWORD *)a1) >> 2;
          v81 = v80 + 1;
          if ((unint64_t)(v80 + 1) >> 62)
            std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
          v82 = v76 - (_QWORD)v79;
          if (v82 >> 1 > v81)
            v81 = v82 >> 1;
          if ((unint64_t)v82 >= 0x7FFFFFFFFFFFFFFCLL)
            v83 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v83 = v81;
          if (v83)
          {
            v83 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(v83);
            v79 = *(int **)a1;
            v77 = *(int **)(a1 + 8);
          }
          else
          {
            v84 = 0;
          }
          v85 = (int *)(v83 + 4 * v80);
          *v85 = v75;
          v78 = v85 + 1;
          while (v77 != v79)
          {
            v86 = *--v77;
            *--v85 = v86;
          }
          *(_QWORD *)a1 = v85;
          *(_QWORD *)(a1 + 8) = v78;
          *(_QWORD *)(a1 + 16) = v83 + 4 * v84;
          if (v79)
            operator delete(v79);
        }
        else
        {
          *v77 = NumberOfDestinations;
          v78 = v77 + 1;
        }
        *(_QWORD *)(a1 + 8) = v78;
        if (v75 >= 1)
        {
          v87 = 0;
          v88 = v75;
          do
          {
            Destination = _MIDIEntityGetDestination(v45, v87);
            v90 = Destination;
            v92 = *(int **)(a1 + 8);
            v91 = *(_QWORD *)(a1 + 16);
            if ((unint64_t)v92 >= v91)
            {
              v94 = *(int **)a1;
              v95 = ((uint64_t)v92 - *(_QWORD *)a1) >> 2;
              v96 = v95 + 1;
              if ((unint64_t)(v95 + 1) >> 62)
                std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
              v97 = v91 - (_QWORD)v94;
              if (v97 >> 1 > v96)
                v96 = v97 >> 1;
              if ((unint64_t)v97 >= 0x7FFFFFFFFFFFFFFCLL)
                v98 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v98 = v96;
              if (v98)
              {
                v98 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(v98);
                v94 = *(int **)a1;
                v92 = *(int **)(a1 + 8);
              }
              else
              {
                v99 = 0;
              }
              v100 = (_DWORD *)(v98 + 4 * v95);
              *v100 = v90;
              v93 = v100 + 1;
              while (v92 != v94)
              {
                v101 = *--v92;
                *--v100 = v101;
              }
              *(_QWORD *)a1 = v100;
              *(_QWORD *)(a1 + 8) = v93;
              *(_QWORD *)(a1 + 16) = v98 + 4 * v99;
              if (v94)
                operator delete(v94);
            }
            else
            {
              *v92 = Destination;
              v93 = v92 + 1;
            }
            *(_QWORD *)(a1 + 8) = v93;
            ++v87;
          }
          while (v87 != v88);
        }
        v44 = v102 + 4;
      }
      while (v102 + 4 != v20);
    }
    if (v19)
      operator delete(v19);
  }
}

void sub_1D4EE50A8(_Unwind_Exception *exception_object)
{
  void *v1;

  if (v1)
    operator delete(v1);
  _Unwind_Resume(exception_object);
}

void ObjectTreeCache::AddChildNodeList(uint64_t a1, void *key, _DWORD *a3)
{
  unint64_t v5;
  unint64_t v6;

  v5 = key;
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 96), (const void *)key, a3);
  if (*a3)
  {
    v6 = 0;
    do
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 104), (const void *)a3[++v6], (const void *)v5);
    while (v6 < *a3);
  }
}

unsigned int *ObjectTreeCache::ParseDeviceChildren(uint64_t a1, void *a2, _DWORD *a3)
{
  uint64_t v5;
  unsigned int *v6;
  unint64_t v7;
  _DWORD *v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int *v11;
  unsigned int *v12;
  unint64_t v13;
  const void *v14;
  _DWORD *v15;
  unint64_t v16;

  ObjectTreeCache::AddChildNodeList(a1, a2, a3);
  v5 = *a3;
  v6 = &a3[v5 + 1];
  if ((_DWORD)v5)
  {
    v7 = 0;
    do
    {
      v8 = &a3[v7];
      v10 = v8[1];
      v9 = v8 + 1;
      ObjectTreeCache::AddChildNodeList(a1, (void *)v10, v6);
      v11 = &v6[*v6];
      v12 = v11 + 1;
      if (v11[1])
      {
        v13 = 0;
        v14 = (const void *)*v9;
        v15 = v11 + 2;
        do
        {
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 104), (const void *)v15[v13++], v14);
          v16 = *v12;
        }
        while (v13 < v16);
      }
      else
      {
        v16 = 0;
      }
      v6 = &v12[v16 + 1];
      ++v7;
    }
    while (v7 < *a3);
  }
  return v6;
}

void sub_1D4EE5288(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1D4EE5804(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19)
{
  void *v19;
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

void sub_1D4EE5AE8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1D4EE6054(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,_Unwind_Exception *exception_object)
{
  void *v22;
  void *v23;

  _Unwind_Resume(a1);
}

void sub_1D4EE6324(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p)
{
  if (__p)
    operator delete(__p);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EE6304);
}

void sub_1D4EE6360(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void MIDIConnection::~MIDIConnection(MIDIConnection *this)
{
  MIDIConnection::~MIDIConnection(this);
  JUMPOUT(0x1D826BA98);
}

{
  uint64_t *v2;
  uint64_t v3;
  void *v4;
  uint64_t *v5;
  uint64_t v6;
  void *v7;

  *(_QWORD *)this = &off_1E98B9618;
  MIDIConnection::ConnectToSources(this, 0);
  v2 = (uint64_t *)((char *)this + 14096);
  v3 = -7168;
  do
  {
    std::unique_ptr<std::map<unsigned short,unsigned short>>::reset[abi:ne180100](v2 + 38, 0);
    v4 = (void *)*v2;
    if (*v2)
    {
      v2[1] = (uint64_t)v4;
      operator delete(v4);
    }
    v2 -= 56;
    v3 += 448;
  }
  while (v3);
  v5 = (uint64_t *)((char *)this + 6928);
  v6 = -7168;
  do
  {
    std::unique_ptr<std::map<unsigned short,unsigned short>>::reset[abi:ne180100](v5 + 38, 0);
    v7 = (void *)*v5;
    if (*v5)
    {
      v5[1] = (uint64_t)v7;
      operator delete(v7);
    }
    v5 -= 56;
    v6 += 448;
  }
  while (v6);
  XCFObject<__CFData const*>::~XCFObject((uint64_t)this + 48);
  XCFObject<__CFString const*>::~XCFObject((uint64_t)this + 16);
  BaseOpaqueObject::~BaseOpaqueObject(this);
}

uint64_t MIDIConnection::PrintObject(MIDIConnection *this, __sFILE *a2)
{
  fprintf(a2, "<%s 0x%x [%p]>", "MIDIThruConnectionRef", *((_DWORD *)this + 2), this);
  return fputc(10, a2);
}

BOOL TOpaqueObject<MIDIConnection,unsigned int,BaseOpaqueObject>::isa(uint64_t a1, void *a2)
{
  return a2 == &TOpaqueRTTI<MIDIConnection>::sRTTI || a2 == &BaseOpaqueObject::sBaseRTTI;
}

void MIDIConnection::ConnectToSources(MIDIConnection *this, int a2)
{
  uint64_t v2;
  int v3;
  int *v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  MIDIConnection **v10;
  MIDIConnection **v11;
  _QWORD *v12;
  void (**v13)();
  uint64_t v14;
  uint64_t *v15;
  int v16;
  unint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  uint64_t *v20;
  int v21;
  int v22;
  MIDIConnection **v23;
  MIDIConnection **v24;
  int64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  char *v34;
  char *v35;
  uint64_t v36;
  MIDI::StreamState *v38;
  uint64_t *v39;
  _QWORD v40[6];
  void (**v41)();
  _QWORD v42[6];
  _QWORD *v43;
  uint64_t v44;
  _QWORD v45[130];

  v45[128] = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)this + 5);
  if (v2)
  {
    v3 = *(_DWORD *)(v2 + 4);
    if (v3 >= 1)
    {
      v6 = (int *)(v2 + 8);
      v38 = (MIDIConnection *)((char *)this + 72);
      while (1)
      {
        v7 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIEndpoint>::sRTTI, *v6);
        if (v7)
        {
          v8 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 80))(v7);
          if (v8)
            break;
        }
LABEL_51:
        v6 += 2;
        if (v3-- <= 1)
          return;
      }
      v9 = v8;
      if (a2)
      {
        v11 = (MIDIConnection **)v8[15];
        v10 = (MIDIConnection **)v8[16];
        if (v11 != v10)
        {
          while (*v11 != this)
          {
            if (++v11 == v10)
            {
              v11 = (MIDIConnection **)v8[16];
              break;
            }
          }
        }
        if (v11 == v10)
        {
          if (!v8[18])
          {
            v39 = (uint64_t *)caulk::inplace_function<void ()(MIDI::EventList const*),48ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<MIDISource::AddThruConnection(MIDIConnection *)::$_0>;
            v40[0] = v8;
            v12 = (_QWORD *)operator new();
            v41 = (void (**)())v39;
            ((void (*)(_QWORD *, _QWORD *))v39[1])(v42, v40);
            v13 = v41;
            v41 = &caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::empty;
            *v12 = &off_1E98B9E98;
            v12[1] = v13;
            ((void (*)(_QWORD *, _QWORD *))v13[2])(v12 + 2, v42);
            bzero(v12 + 8, 0x300uLL);
            ((void (*)(_QWORD *))v41[3])(v42);
            v14 = v9[18];
            v9[18] = v12;
            if (v14)
              (*(void (**)(uint64_t))(*(_QWORD *)v14 + 8))(v14);
            v8 = (_QWORD *)((uint64_t (*)(_QWORD *))v39[3])(v40);
          }
          v15 = MIDIServer::defaultInstance((MIDIServer *)v8) + 13;
          v16 = (*(uint64_t (**)(uint64_t *))(*v15 + 16))(v15);
          v18 = (_QWORD *)v9[16];
          v17 = v9[17];
          if ((unint64_t)v18 >= v17)
          {
            v27 = v9[15];
            v28 = ((uint64_t)v18 - v27) >> 3;
            if ((unint64_t)(v28 + 1) >> 61)
              std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
            v29 = v17 - v27;
            v30 = v29 >> 2;
            if (v29 >> 2 <= (unint64_t)(v28 + 1))
              v30 = v28 + 1;
            if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFF8)
              v31 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v31 = v30;
            if (v31)
              v31 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v31);
            else
              v32 = 0;
            v33 = (_QWORD *)(v31 + 8 * v28);
            *v33 = this;
            v19 = v33 + 1;
            v35 = (char *)v9[15];
            v34 = (char *)v9[16];
            if (v34 != v35)
            {
              do
              {
                v36 = *((_QWORD *)v34 - 1);
                v34 -= 8;
                *--v33 = v36;
              }
              while (v34 != v35);
              v34 = (char *)v9[15];
            }
            v9[15] = v33;
            v9[16] = v19;
            v9[17] = v31 + 8 * v32;
            if (v34)
              operator delete(v34);
          }
          else
          {
            *v18 = this;
            v19 = v18 + 1;
          }
          v9[16] = v19;
          if (v16)
            (*(void (**)(uint64_t *))(*v15 + 24))(v15);
        }
        goto LABEL_51;
      }
      v20 = MIDIServer::defaultInstance((MIDIServer *)v8) + 13;
      v21 = (*(uint64_t (**)(uint64_t *))(*v20 + 16))(v20);
      v22 = v21;
      v24 = (MIDIConnection **)v9[15];
      v23 = (MIDIConnection **)v9[16];
      if (v24 == v23)
      {
LABEL_22:
        if (!v21)
          goto LABEL_32;
      }
      else
      {
        while (*v24 != this)
        {
          if (++v24 == v23)
          {
            v24 = (MIDIConnection **)v9[16];
            goto LABEL_22;
          }
        }
        if (!*((_DWORD *)this + 3602))
        {
          v41 = (void (**)())caulk::inplace_function<void ()(MIDI::EventList const*),48ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<ConnectionEmitter::ConnectionEmitter(MIDIConnection *)::{lambda(MIDI::EventList const*)#1}>;
          v42[0] = &v41;
          v44 = 1;
          v43 = v45;
          v45[127] = this;
          MIDI::StreamState::reset(v38, (MIDI::Packetizer *)&v41);
          if (HIDWORD(v44))
          {
            v39 = &v44;
            ((void (*)(_QWORD *, uint64_t **))*v41)(v42, &v39);
          }
          HIDWORD(v44) = 0;
          v43 = v45;
          MIDI::PacketizerBase<MIDI::EventList>::~PacketizerBase((uint64_t)&v41);
          v23 = (MIDIConnection **)v9[16];
        }
        v25 = (char *)v23 - (char *)(v24 + 1);
        if (v23 != v24 + 1)
          memmove(v24, v24 + 1, (char *)v23 - (char *)(v24 + 1));
        v24 = (MIDIConnection **)((char *)v24 + v25);
        v9[16] = v24;
        if (!v22)
          goto LABEL_32;
      }
      (*(void (**)(uint64_t *))(*v20 + 24))(v20);
      v24 = (MIDIConnection **)v9[16];
LABEL_32:
      if ((MIDIConnection **)v9[15] == v24)
      {
        v26 = v9[18];
        v9[18] = 0;
        if (v26)
          (*(void (**)(uint64_t))(*(_QWORD *)v26 + 8))(v26);
      }
      goto LABEL_51;
    }
  }
}

void sub_1D4EE6970(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  uint64_t v22;
  char v23;

  if ((v23 & 1) != 0)
    (*(void (**)(uint64_t))(*(_QWORD *)v22 + 24))(v22);
  _Unwind_Resume(exception_object);
}

uint64_t XCFObject<__CFData const*>::~XCFObject(uint64_t a1)
{
  const void *v2;

  if (*(_BYTE *)(a1 + 8))
  {
    v2 = *(const void **)a1;
    if (*(_QWORD *)a1)
      CFRelease(v2);
  }
  return a1;
}

void XCFObject<__CFString const*>::Set(uint64_t a1, const void *a2)
{
  const void *v4;
  int v5;

  if (!*(_BYTE *)(a1 + 8))
  {
    *(_QWORD *)a1 = a2;
    *(_BYTE *)(a1 + 9) = 0;
    return;
  }
  v4 = *(const void **)a1;
  if (!*(_QWORD *)a1)
  {
    *(_QWORD *)a1 = a2;
    *(_BYTE *)(a1 + 9) = 0;
    if (!a2)
      return;
    goto LABEL_8;
  }
  CFRelease(v4);
  v5 = *(unsigned __int8 *)(a1 + 8);
  *(_QWORD *)a1 = a2;
  *(_BYTE *)(a1 + 9) = 0;
  if (a2 && v5)
LABEL_8:
    CFRetain(a2);
}

uint64_t MIDIConnection::SetParams(MIDIConnection *this, MIDISetup *a2, CFDataRef theData)
{
  const UInt8 *BytePtr;
  uint64_t result;
  const void *v8;
  int v9;
  unsigned int v10;
  unsigned __int16 *v11;
  int v12;
  unint64_t v13;

  if (!theData)
    return 4294967246;
  BytePtr = CFDataGetBytePtr(theData);
  if (CFDataGetLength(theData) < (uint64_t)(((unint64_t)*((unsigned __int16 *)BytePtr + 97) << 7)
                                          + 8 * *((unsigned __int16 *)BytePtr + 96)
                                          + 204))
    return 4294967246;
  ++*((_DWORD *)this + 3602);
  MIDIConnection::ConnectToSources(this, 0);
  if (*((_QWORD *)this + 5))
    *((_QWORD *)this + 5) = 0;
  if (*((_BYTE *)this + 56))
  {
    v8 = (const void *)*((_QWORD *)this + 6);
    if (v8)
    {
      CFRelease(v8);
      v9 = *((unsigned __int8 *)this + 56);
      *((_QWORD *)this + 6) = theData;
      *((_BYTE *)this + 57) = 0;
      if (!v9)
        goto LABEL_14;
    }
    else
    {
      *((_QWORD *)this + 6) = theData;
      *((_BYTE *)this + 57) = 0;
    }
    CFRetain(theData);
  }
  else
  {
    *((_QWORD *)this + 6) = theData;
    *((_BYTE *)this + 57) = 0;
  }
LABEL_14:
  *((_DWORD *)this + 17) = 0;
  *((_BYTE *)this + 64) = 0;
  if (*((_WORD *)BytePtr + 96))
  {
    v10 = *((unsigned __int16 *)BytePtr + 96) + 1;
    v11 = (unsigned __int16 *)(BytePtr + 206);
    do
    {
      v12 = *((unsigned __int8 *)v11 - 2);
      if (v12 == 1)
      {
        v13 = *v11;
        if (v13 <= 0x1F)
          *((_BYTE *)this + (v13 >> 3) + 68) |= 1 << (v13 & 7);
      }
      else if ((v12 & 6) != 0)
      {
        *((_BYTE *)this + 64) = 1;
      }
      --v10;
      v11 += 4;
    }
    while (v10 > 1);
  }
  *((_QWORD *)this + 5) = BytePtr;
  if (a2)
    MIDIConnection::MaintainEndpoints(this, a2);
  result = 0;
  --*((_DWORD *)this + 3602);
  return result;
}

void MIDIConnection::MaintainEndpoints(MIDIConnection *this, MIDISetup *a2)
{
  uint64_t v4;
  unsigned int v5;
  int *v6;
  SetupManager *IntegerProperty;
  int v8;
  MIDIObject **i;
  MIDIObject *v10;
  int v11;
  uint64_t v12;
  MIDIObject **v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  BOOL v20;
  unsigned int v21;
  int *v22;
  SetupManager *v23;
  int v24;
  MIDIObject **j;
  MIDIObject *v26;
  int v27;
  uint64_t v28;
  MIDIObject **v29;
  uint64_t v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;

  v4 = *((_QWORD *)this + 5);
  if (*(unsigned __int8 *)(v4 + 4) >= 8u)
    v5 = 8;
  else
    v5 = *(unsigned __int8 *)(v4 + 4);
  if (v5)
  {
    v6 = (int *)(v4 + 8);
    do
    {
      IntegerProperty = (SetupManager *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIEndpoint>::sRTTI, *v6);
      if (IntegerProperty)
        goto LABEL_22;
      v8 = v6[1];
      for (i = (MIDIObject **)*((_QWORD *)a2 + 11); i != *((MIDIObject ***)a2 + 12); ++i)
      {
        v10 = *i;
        v36 = 0;
        IntegerProperty = (SetupManager *)MIDIObject::GetIntegerProperty(v10, kMIDIPropertyUniqueID, &v36);
        v11 = v36;
        if ((_DWORD)IntegerProperty)
          v11 = 0;
        if (v11 == v8)
          goto LABEL_20;
      }
      v12 = SetupManager::instance(IntegerProperty);
      v13 = *(MIDIObject ***)(v12 + 8);
      if (v13 == *(MIDIObject ***)(v12 + 16))
      {
LABEL_19:
        v17 = 0;
        goto LABEL_21;
      }
      v14 = v12;
      while (1)
      {
        v10 = *v13;
        v36 = 0;
        v15 = MIDIObject::GetIntegerProperty(v10, kMIDIPropertyUniqueID, &v36);
        v16 = v36;
        if (v15)
          v16 = 0;
        if (v16 == v8)
          break;
        if (++v13 == *(MIDIObject ***)(v14 + 16))
          goto LABEL_19;
      }
LABEL_20:
      v17 = *((_DWORD *)v10 + 2);
LABEL_21:
      *v6 = v17;
      IntegerProperty = (SetupManager *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIEndpoint>::sRTTI, v17);
      if (IntegerProperty)
      {
LABEL_22:
        v36 = 0;
        v18 = MIDIObject::GetIntegerProperty(IntegerProperty, kMIDIPropertyUniqueID, &v36);
        v19 = v36;
        if (v18)
          v19 = 0;
        v6[1] = v19;
      }
      v6 += 2;
      v20 = v5-- > 1;
    }
    while (v20);
    v4 = *((_QWORD *)this + 5);
  }
  if (*(unsigned __int8 *)(v4 + 72) >= 8u)
    v21 = 8;
  else
    v21 = *(unsigned __int8 *)(v4 + 72);
  if (v21)
  {
    v22 = (int *)(v4 + 76);
    do
    {
      v23 = (SetupManager *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIEndpoint>::sRTTI, *v22);
      if (v23)
        goto LABEL_48;
      v24 = v22[1];
      for (j = (MIDIObject **)*((_QWORD *)a2 + 14); j != *((MIDIObject ***)a2 + 15); ++j)
      {
        v26 = *j;
        v36 = 0;
        v23 = (SetupManager *)MIDIObject::GetIntegerProperty(v26, kMIDIPropertyUniqueID, &v36);
        v27 = v36;
        if ((_DWORD)v23)
          v27 = 0;
        if (v27 == v24)
          goto LABEL_46;
      }
      v28 = SetupManager::instance(v23);
      v29 = *(MIDIObject ***)(v28 + 32);
      if (v29 == *(MIDIObject ***)(v28 + 40))
      {
LABEL_45:
        v33 = 0;
        goto LABEL_47;
      }
      v30 = v28;
      while (1)
      {
        v26 = *v29;
        v36 = 0;
        v31 = MIDIObject::GetIntegerProperty(v26, kMIDIPropertyUniqueID, &v36);
        v32 = v36;
        if (v31)
          v32 = 0;
        if (v32 == v24)
          break;
        if (++v29 == *(MIDIObject ***)(v30 + 40))
          goto LABEL_45;
      }
LABEL_46:
      v33 = *((_DWORD *)v26 + 2);
LABEL_47:
      *v22 = v33;
      v23 = (SetupManager *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIEndpoint>::sRTTI, v33);
      if (v23)
      {
LABEL_48:
        v36 = 0;
        v34 = MIDIObject::GetIntegerProperty(v23, kMIDIPropertyUniqueID, &v36);
        v35 = v36;
        if (v34)
          v35 = 0;
        v22[1] = v35;
      }
      v22 += 2;
      v20 = v21-- > 1;
    }
    while (v20);
  }
  MIDIConnection::ConnectToSources(this, 1);
}

uint64_t TransformValue(uint64_t result, int a2, unsigned int a3, unsigned __int16 *a4, int a5)
{
  unint64_t v5;
  unsigned int v6;
  unsigned int v7;
  unint64_t v8;
  int v9;

  v5 = *a4;
  switch(a2)
  {
    case 8:
      v6 = v5 + a3;
      goto LABEL_10;
    case 9:
      v6 = (v5 * a3 + 2048) >> 12;
      goto LABEL_10;
    case 10:
      if (v5 <= a3)
        v6 = a3;
      else
        v6 = *a4;
      goto LABEL_10;
    case 11:
      if (v5 >= a3)
        v6 = a3;
      else
        v6 = *a4;
      goto LABEL_10;
    case 12:
      if ((a3 & 0x80000000) != 0 || (int)a3 >= *(unsigned __int16 *)(result + 194))
        return result;
      v8 = result + 8 * *(unsigned __int16 *)(result + 192) + ((unint64_t)a3 << 7) + 204;
      if (a5)
      {
        v9 = *(unsigned __int8 *)(v8 + (v5 >> 7));
        v6 = v9 << 7;
        if ((v5 & 0x7F) != 0 && v5 >> 7 <= 0x7E)
          v6 += ((v5 & 0x7F) * (*(unsigned __int8 *)(v8 + (v5 >> 7) + 1) - v9)) & 0x1FFFFFF;
      }
      else
      {
        v6 = *(unsigned __int8 *)(v8 + *a4);
      }
LABEL_10:
      if (a5)
        v7 = 0x3FFF;
      else
        v7 = 127;
      if (v7 < v6)
        LOWORD(v6) = v7;
      *a4 = v6;
      return result;
    default:
      return result;
  }
}

_QWORD *caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<ConnectionEmitter::ConnectionEmitter(MIDIConnection *)::{lambda(MIDI::EventList const*)#1}>(caulk::inplace_function_detail::wrapper<ConnectionEmitter::ConnectionEmitter(MIDIConnection *)::{lambda(MIDI::EventList const*)#1}>)::{lambda(void *,MIDI::EventList const*&&)#1}::__invoke(_QWORD *result, const MIDI::EventList **a2)
{
  _QWORD *v2;
  uint64_t v3;
  int v4;
  const MIDI::EventList *v5;
  int *v6;
  unsigned int v7;

  v2 = *(_QWORD **)(*result + 1088);
  v3 = v2[5];
  v4 = *(_DWORD *)(v3 + 72);
  if (v4 >= 1)
  {
    v5 = *a2;
    v6 = (int *)(v3 + 76);
    v7 = v4 + 1;
    do
    {
      result = (_QWORD *)BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIEndpoint>::sRTTI, *v6);
      if (result)
      {
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 88))(result);
        if (result)
          result = MIDIDestination::SendPacketList(result, v2, v5);
      }
      v6 += 2;
      --v7;
    }
    while (v7 > 1);
  }
  return result;
}

_QWORD *caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<ConnectionEmitter::ConnectionEmitter(MIDIConnection *)::{lambda(MIDI::EventList const*)#1}>(caulk::inplace_function_detail::wrapper<ConnectionEmitter::ConnectionEmitter(MIDIConnection *)::{lambda(MIDI::EventList const*)#1}>)::{lambda(void *,void *)#1}::__invoke(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

_QWORD *caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<ConnectionEmitter::ConnectionEmitter(MIDIConnection *)::{lambda(MIDI::EventList const*)#1}>(caulk::inplace_function_detail::wrapper<ConnectionEmitter::ConnectionEmitter(MIDIConnection *)::{lambda(MIDI::EventList const*)#1}>)::{lambda(void *,void *)#2}::__invoke(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

void MIDICI::Device::~Device(MIDICI::Device *this)
{
  const void *v2;
  void **v3;

  v2 = (const void *)*((_QWORD *)this + 24);
  if (v2)
    CFRelease(v2);
  std::unique_ptr<PropertyExchange::RequestManager>::reset[abi:ne180100]((uint64_t *)this + 22, 0);
  v3 = (void **)((char *)this + 144);
  std::vector<std::unique_ptr<MIDICI::Profile>>::__destroy_vector::operator()[abi:ne180100](&v3);
  if (*((char *)this + 143) < 0)
    operator delete(*((void **)this + 15));
  *(_QWORD *)this = off_1E98B9320;
  XCFObject<__CFDictionary const*>::~XCFObject((uint64_t)this + 24);
  BaseOpaqueObject::~BaseOpaqueObject(this);
}

{
  const void *v2;
  void **v3;

  v2 = (const void *)*((_QWORD *)this + 24);
  if (v2)
    CFRelease(v2);
  std::unique_ptr<PropertyExchange::RequestManager>::reset[abi:ne180100]((uint64_t *)this + 22, 0);
  v3 = (void **)((char *)this + 144);
  std::vector<std::unique_ptr<MIDICI::Profile>>::__destroy_vector::operator()[abi:ne180100](&v3);
  if (*((char *)this + 143) < 0)
    operator delete(*((void **)this + 15));
  *(_QWORD *)this = off_1E98B9320;
  XCFObject<__CFDictionary const*>::~XCFObject((uint64_t)this + 24);
  BaseOpaqueObject::~BaseOpaqueObject(this);
  JUMPOUT(0x1D826BA98);
}

uint64_t MIDICI::Device::deserialize@<X0>(MIDICI::Device *this@<X0>, const __CFDictionary **a2@<X1>, uint64_t **a3@<X8>)
{
  uint64_t **v5;
  const __CFNumber *v6;
  int v7;
  unint64_t v8;
  int v9;
  const void *v10;
  const void *v11;
  CFTypeID TypeID;
  char v13;
  char v14;
  const __CFNumber *v15;
  int v16;
  unint64_t v17;
  int v18;
  const __CFNumber *v19;
  int v20;
  unint64_t v21;
  int v22;
  unsigned __int16 v23;
  char v24;
  unsigned __int16 v25;
  char v26;
  unsigned __int16 v27;
  char v28;
  unsigned __int16 v29;
  char v30;
  const __CFNumber *v31;
  unsigned __int8 v32;
  uint64_t v33;
  uint64_t v34;
  const __CFNumber *v35;
  unsigned __int8 v36;
  uint64_t v37;
  uint64_t v38;
  unsigned __int16 v39;
  char v40;
  unsigned __int16 v41;
  char v42;
  unsigned __int16 v43;
  char v44;
  const __CFArray *v45;
  const __CFDictionary *v46;
  unint64_t v47;
  const __CFArray *v48;
  unint64_t v49;
  char *v50;
  char *v51;
  uint64_t i;
  uint64_t v53;
  uint64_t v54;
  size_t v55;
  char *v56;
  char *v57;
  char *v58;
  char *v59;
  char v60;
  MIDICI::Profile *v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t *v64;
  _QWORD *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  char *v71;
  const __CFNumber *v72;
  unsigned __int8 v73;
  uint64_t v74;
  uint64_t v75;
  const void *v76;
  const __CFDictionary *v77;
  void *v79;
  void *exception;
  void *v81;
  void *v82;
  void *v83;
  void *v84;
  void *v85;
  void *v86;
  void *v87;
  void *v88;
  void *v89;
  void *v90;
  void *v91;
  void *v92;
  void *v93;
  void *v94;
  void *v95;
  void *v96;
  char *v97;
  _QWORD *v98;
  MIDICI::Device *v99;
  CFIndex v100;
  uint64_t **v101;
  const __CFDictionary *v102;
  const __CFArray *v103;
  const applesauce::CF::DictionaryRef *v104;
  CFIndex Count;
  uint64_t *v106[3];
  CFTypeRef cf;
  CFTypeRef v108;
  _BYTE v109[8];
  char *v110;
  const __CFDictionary *valuePtr;
  char v112;
  void *v113;
  char *v114;
  char *v115;
  unint64_t v116;
  char *v117;

  v5 = a3;
  a3[1] = 0;
  a3[2] = 0;
  *a3 = (uint64_t *)(a3 + 1);
  std::string::basic_string[abi:ne180100]<0>(&v113, "muid");
  if (!*a2)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  v6 = applesauce::CF::DictionaryRef_proxy::at_as<unsigned int,std::string const&>(*a2, (const UInt8 *)&v113);
  v7 = (int)v6;
  v8 = (unint64_t)v6 >> 32;
  if ((unint64_t)v6 >> 32)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>(v5, &v113, (uint64_t)&v113);
    v9 = v7;
  }
  else
  {
    v9 = 0;
  }
  if ((SHIBYTE(v115) & 0x80000000) == 0)
  {
    if (!v8)
      goto LABEL_8;
    goto LABEL_7;
  }
  operator delete(v113);
  if (v8)
LABEL_7:
    *((_DWORD *)this + 16) = v9 | v7 & 0xFFFFFF00;
LABEL_8:
  std::string::basic_string[abi:ne180100]<0>(&v113, "device_type");
  if (!*a2)
  {
    v81 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v81, "Could not construct");
  }
  v10 = applesauce::CF::details::at_key<std::string const&>(*a2, (const UInt8 *)&v113);
  if (v10
    && (v11 = v10, TypeID = CFNumberGetTypeID(), TypeID == CFGetTypeID(v11))
    && (LOBYTE(valuePtr) = 0, CFNumberGetValue((CFNumberRef)v11, kCFNumberCharType, &valuePtr)))
  {
    v13 = (char)valuePtr;
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>(v5, &v113, (uint64_t)&v113);
    v14 = 0;
  }
  else
  {
    v13 = 0;
    v14 = 1;
  }
  if ((SHIBYTE(v115) & 0x80000000) == 0)
  {
    if ((v14 & 1) != 0)
      goto LABEL_17;
    goto LABEL_16;
  }
  operator delete(v113);
  if ((v14 & 1) == 0)
LABEL_16:
    *((_BYTE *)this + 68) = v13;
LABEL_17:
  std::string::basic_string[abi:ne180100]<0>(&v113, "source");
  if (!*a2)
  {
    v82 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v82, "Could not construct");
  }
  v15 = applesauce::CF::DictionaryRef_proxy::at_as<unsigned int,std::string const&>(*a2, (const UInt8 *)&v113);
  v16 = (int)v15;
  v17 = (unint64_t)v15 >> 32;
  if ((unint64_t)v15 >> 32)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>(v5, &v113, (uint64_t)&v113);
    v18 = v16;
  }
  else
  {
    v18 = 0;
  }
  if ((SHIBYTE(v115) & 0x80000000) == 0)
  {
    if (!v17)
      goto LABEL_24;
    goto LABEL_23;
  }
  operator delete(v113);
  if (v17)
LABEL_23:
    *((_DWORD *)this + 18) = v18 | v16 & 0xFFFFFF00;
LABEL_24:
  std::string::basic_string[abi:ne180100]<0>(&v113, "destination");
  if (!*a2)
  {
    v83 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v83, "Could not construct");
  }
  v19 = applesauce::CF::DictionaryRef_proxy::at_as<unsigned int,std::string const&>(*a2, (const UInt8 *)&v113);
  v20 = (int)v19;
  v21 = (unint64_t)v19 >> 32;
  if ((unint64_t)v19 >> 32)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>(v5, &v113, (uint64_t)&v113);
    v22 = v20;
  }
  else
  {
    v22 = 0;
  }
  if ((SHIBYTE(v115) & 0x80000000) == 0)
  {
    if (!v21)
      goto LABEL_31;
    goto LABEL_30;
  }
  operator delete(v113);
  if (v21)
LABEL_30:
    *((_DWORD *)this + 19) = v22 | v20 & 0xFFFFFF00;
LABEL_31:
  std::string::basic_string[abi:ne180100]<0>(&v113, "device_info");
  if (!*a2)
  {
    v84 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v84, "Could not construct");
  }
  applesauce::CF::details::find_at_key_or_optional<applesauce::CF::DictionaryRef,std::string const&>(&valuePtr, *a2, (const UInt8 *)&v113);
  if (v112)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>(v5, &v113, (uint64_t)&v113);
  }
  else
  {
    std::__optional_destruct_base<applesauce::CF::DictionaryRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&valuePtr);
    LOBYTE(valuePtr) = 0;
    v112 = 0;
  }
  if (SHIBYTE(v115) < 0)
    operator delete(v113);
  if (v112)
  {
    MIDI2::DeviceInfo::deserialize((MIDI2::DeviceInfo *)v109, (MIDICI::Device *)((char *)this + 80), &valuePtr);
    std::__tree<std::string>::destroy(v110);
  }
  std::__optional_destruct_base<applesauce::CF::DictionaryRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&valuePtr);
  std::string::basic_string[abi:ne180100]<0>(&v113, "supports_protocol_negotiation");
  if (!*a2)
  {
    v85 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v85, "Could not construct");
  }
  v23 = applesauce::CF::details::find_at_key_or_optional<BOOL,std::string const&>(*a2, (const UInt8 *)&v113);
  if (v23 >= 0x100u)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>(v5, &v113, (uint64_t)&v113);
    v24 = v23;
  }
  else
  {
    v24 = 0;
  }
  if (SHIBYTE(v115) < 0)
    operator delete(v113);
  if (v23 >= 0x100u)
    *((_BYTE *)this + 92) = v24;
  std::string::basic_string[abi:ne180100]<0>(&v113, "supports_profile_capability");
  if (!*a2)
  {
    v86 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v86, "Could not construct");
  }
  v25 = applesauce::CF::details::find_at_key_or_optional<BOOL,std::string const&>(*a2, (const UInt8 *)&v113);
  if (v25 >= 0x100u)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>(v5, &v113, (uint64_t)&v113);
    v26 = v25;
  }
  else
  {
    v26 = 0;
  }
  if (SHIBYTE(v115) < 0)
    operator delete(v113);
  if (v25 >= 0x100u)
    *((_BYTE *)this + 93) = v26;
  std::string::basic_string[abi:ne180100]<0>(&v113, "supports_property_exchange_capability");
  if (!*a2)
  {
    v87 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v87, "Could not construct");
  }
  v27 = applesauce::CF::details::find_at_key_or_optional<BOOL,std::string const&>(*a2, (const UInt8 *)&v113);
  if (v27 >= 0x100u)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>(v5, &v113, (uint64_t)&v113);
    v28 = v27;
  }
  else
  {
    v28 = 0;
  }
  if (SHIBYTE(v115) < 0)
    operator delete(v113);
  if (v27 >= 0x100u)
    *((_BYTE *)this + 94) = v28;
  std::string::basic_string[abi:ne180100]<0>(&v113, "supports_process_inquiry_capability");
  if (!*a2)
  {
    v88 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v88, "Could not construct");
  }
  v29 = applesauce::CF::details::find_at_key_or_optional<BOOL,std::string const&>(*a2, (const UInt8 *)&v113);
  if (v29 >= 0x100u)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>(v5, &v113, (uint64_t)&v113);
    v30 = v29;
  }
  else
  {
    v30 = 0;
  }
  if (SHIBYTE(v115) < 0)
    operator delete(v113);
  if (v29 >= 0x100u)
    *((_BYTE *)this + 95) = v30;
  std::string::basic_string[abi:ne180100]<0>(&v113, "max_sysex_size");
  if (!*a2)
  {
    v89 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v89, "Could not construct");
  }
  v31 = applesauce::CF::details::find_at_key_or_optional<unsigned long long,std::string const&>(*a2, (const UInt8 *)&v113);
  v33 = v32;
  if (v32)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>(v5, &v113, (uint64_t)&v113);
    v34 = v31;
  }
  else
  {
    v34 = 0;
  }
  if (SHIBYTE(v115) < 0)
    operator delete(v113);
  if (v33)
    *((_QWORD *)this + 12) = v34 | (unint64_t)v31 & 0xFFFFFFFFFFFFFF00;
  std::string::basic_string[abi:ne180100]<0>(&v113, "max_property_requests");
  if (!*a2)
  {
    v90 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v90, "Could not construct");
  }
  v35 = applesauce::CF::details::find_at_key_or_optional<unsigned long long,std::string const&>(*a2, (const UInt8 *)&v113);
  v37 = v36;
  if (v36)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>(v5, &v113, (uint64_t)&v113);
    v38 = v35;
  }
  else
  {
    v38 = 0;
  }
  if (SHIBYTE(v115) < 0)
    operator delete(v113);
  if (v37)
    *((_QWORD *)this + 13) = v38 | (unint64_t)v35 & 0xFFFFFFFFFFFFFF00;
  std::string::basic_string[abi:ne180100]<0>(&v113, "enabled");
  if (!*a2)
  {
    v91 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v91, "Could not construct");
  }
  v39 = applesauce::CF::details::find_at_key_or_optional<BOOL,std::string const&>(*a2, (const UInt8 *)&v113);
  if (v39 >= 0x100u)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>(v5, &v113, (uint64_t)&v113);
    v40 = v39;
  }
  else
  {
    v40 = 0;
  }
  if (SHIBYTE(v115) < 0)
    operator delete(v113);
  if (v39 >= 0x100u)
    *((_BYTE *)this + 112) = v40;
  std::string::basic_string[abi:ne180100]<0>(&v113, "client_owned");
  if (!*a2)
  {
    v92 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v92, "Could not construct");
  }
  v41 = applesauce::CF::details::find_at_key_or_optional<BOOL,std::string const&>(*a2, (const UInt8 *)&v113);
  if (v41 >= 0x100u)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>(v5, &v113, (uint64_t)&v113);
    v42 = v41;
  }
  else
  {
    v42 = 0;
  }
  if (SHIBYTE(v115) < 0)
    operator delete(v113);
  if (v41 >= 0x100u)
    *((_BYTE *)this + 113) = v42;
  std::string::basic_string[abi:ne180100]<0>(&v113, "function_block_id");
  if (!*a2)
  {
    v93 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v93, "Could not construct");
  }
  v43 = applesauce::CF::details::find_at_key_or_optional<unsigned char,std::string const&>(*a2, (const UInt8 *)&v113);
  if (v43 >= 0x100u)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>(v5, &v113, (uint64_t)&v113);
    v44 = v43;
  }
  else
  {
    v44 = 0;
  }
  if (SHIBYTE(v115) < 0)
    operator delete(v113);
  if (v43 >= 0x100u)
    *((_BYTE *)this + 168) = v44;
  std::string::basic_string[abi:ne180100]<0>(&v113, "profiles");
  if (!*a2)
  {
    v94 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v94, "Could not construct");
  }
  applesauce::CF::details::find_at_key_or_optional<applesauce::CF::ArrayRef,std::string const&>(&valuePtr, *a2, (const UInt8 *)&v113);
  if (v112)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>(v5, &v113, (uint64_t)&v113);
  }
  else
  {
    std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&valuePtr);
    LOBYTE(valuePtr) = 0;
    v112 = 0;
  }
  if (SHIBYTE(v115) < 0)
    operator delete(v113);
  if (v112)
  {
    v45 = valuePtr;
    if (valuePtr)
    {
      Count = CFArrayGetCount(valuePtr);
      v46 = valuePtr;
      v100 = valuePtr ? CFArrayGetCount(valuePtr) : 0;
      if (Count)
      {
        v47 = 0;
        v98 = (_QWORD *)((char *)this + 144);
        v99 = this;
        v97 = (char *)this + 160;
        v101 = v5;
        v102 = v46;
        v103 = v45;
        v104 = (const applesauce::CF::DictionaryRef *)a2;
        while (1)
        {
          if (v45 == v46 && v47 == v100)
            goto LABEL_185;
          applesauce::CF::details::at_to<applesauce::CF::TypeRef>(&v108, v45, v47);
          applesauce::CF::TypeRef::operator applesauce::CF::DictionaryRef((applesauce::CF::DictionaryRef *)&cf, &v108);
          if (!cf)
          {
            v79 = __cxa_allocate_exception(0x10uLL);
            MEMORY[0x1D826B7EC](v79, "Could not construct");
          }
          v48 = (const __CFArray *)applesauce::CF::details::at_key<char const* const&>((const __CFDictionary *)cf, "id");
          if (v48 && (applesauce::CF::convert_as<std::vector<unsigned long long>,0>((uint64_t)&v113, v48), (_BYTE)v116))
          {
            v49 = 0;
            v50 = 0;
            v51 = 0;
            for (i = 0; i != 5; ++i)
            {
              v53 = *((_QWORD *)v113 + i);
              if (v51 >= v50)
              {
                v54 = (uint64_t)&v51[-v49 + 1];
                if (v54 < 0)
                  std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
                if (2 * (uint64_t)&v50[-v49] > (unint64_t)v54)
                  v54 = 2 * (_QWORD)&v50[-v49];
                if ((unint64_t)&v50[-v49] >= 0x3FFFFFFFFFFFFFFFLL)
                  v55 = 0x7FFFFFFFFFFFFFFFLL;
                else
                  v55 = v54;
                if (v55)
                  v56 = (char *)operator new(v55);
                else
                  v56 = 0;
                v57 = &v51[(_QWORD)v56 - v49];
                *v57 = v53;
                v58 = v57 + 1;
                if (v51 != (char *)v49)
                {
                  v59 = &v51[~v49];
                  do
                  {
                    v60 = *--v51;
                    (v59--)[(_QWORD)v56] = v60;
                  }
                  while (v51 != (char *)v49);
                  v57 = v56;
                }
                v50 = &v56[v55];
                if (v49)
                  operator delete((void *)v49);
                v49 = (unint64_t)v57;
                v51 = v58;
              }
              else
              {
                *v51++ = v53;
              }
            }
            this = v99;
            if ((_BYTE)v116)
            {
              v5 = v101;
              if (v113)
                operator delete(v113);
            }
            else
            {
              v5 = v101;
            }
          }
          else
          {
            v49 = 0;
            v51 = 0;
          }
          v61 = (MIDICI::Profile *)MIDICI::Device::profile(*((uint64_t **)this + 18), *((uint64_t **)this + 19), (void *)v49, (size_t)&v51[-v49]);
          if (!v61)
            break;
          MIDICI::Profile::deserialize(v61, (const __CFDictionary **)&cf, v106);
          a2 = (const __CFDictionary **)v104;
          std::__tree<std::string>::destroy((char *)v106[1]);
          if (v49)
            goto LABEL_163;
LABEL_164:
          if (cf)
            CFRelease(cf);
          v46 = v102;
          v45 = v103;
          if (v108)
            CFRelease(v108);
          if (++v47 == Count)
            goto LABEL_185;
        }
        a2 = (const __CFDictionary **)v104;
        v62 = operator new();
        MIDIObject::MIDIObject((MIDIObject *)v62);
        *(_BYTE *)(v62 + 44) = 0;
        *(_BYTE *)(v62 + 48) = 0;
        *(_QWORD *)(v62 + 56) = 0;
        *(_OWORD *)(v62 + 64) = 0u;
        *(_QWORD *)v62 = off_1E98B6EA0;
        *(_WORD *)(v62 + 118) = 0;
        *(_DWORD *)(v62 + 120) = 0;
        *(_OWORD *)(v62 + 80) = 0u;
        *(_OWORD *)(v62 + 96) = 0u;
        *(_QWORD *)(v62 + 109) = 0;
        MIDICI::Profile::deserialize((MIDICI::Profile *)v62, (const __CFDictionary **)&cf, (uint64_t **)&v113);
        std::__tree<std::string>::destroy(v114);
        v64 = (uint64_t *)*((_QWORD *)this + 19);
        v63 = *((_QWORD *)this + 20);
        if ((unint64_t)v64 >= v63)
        {
          v66 = ((uint64_t)v64 - *v98) >> 3;
          v5 = v101;
          if ((unint64_t)(v66 + 1) >> 61)
            std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
          v67 = v63 - *v98;
          v68 = v67 >> 2;
          if (v67 >> 2 <= (unint64_t)(v66 + 1))
            v68 = v66 + 1;
          if ((unint64_t)v67 >= 0x7FFFFFFFFFFFFFF8)
            v69 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v69 = v68;
          v117 = v97;
          if (v69)
            v69 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v69);
          else
            v70 = 0;
          v71 = (char *)(v69 + 8 * v66);
          v113 = (void *)v69;
          v114 = v71;
          v116 = v69 + 8 * v70;
          *(_QWORD *)v71 = v62;
          v115 = v71 + 8;
          std::vector<std::unique_ptr<UMPStream::FunctionBlock>>::__swap_out_circular_buffer(v98, &v113);
          v65 = (_QWORD *)*((_QWORD *)this + 19);
          std::__split_buffer<std::unique_ptr<MIDICI::Profile>>::~__split_buffer((uint64_t)&v113);
        }
        else
        {
          *v64 = v62;
          v65 = v64 + 1;
          v5 = v101;
        }
        *((_QWORD *)this + 19) = v65;
        if (!v49)
          goto LABEL_164;
LABEL_163:
        operator delete((void *)v49);
        goto LABEL_164;
      }
    }
  }
LABEL_185:
  std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&valuePtr);
  std::string::basic_string[abi:ne180100]<0>(&v113, "timestamp");
  if (!*a2)
  {
    v95 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v95, "Could not construct");
  }
  v72 = applesauce::CF::details::find_at_key_or_optional<unsigned long long,std::string const&>(*a2, (const UInt8 *)&v113);
  v74 = v73;
  if (v73)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>(v5, &v113, (uint64_t)&v113);
    v75 = v72;
  }
  else
  {
    v75 = 0;
  }
  if (SHIBYTE(v115) < 0)
    operator delete(v113);
  if (v74)
    *((_QWORD *)this + 7) = v75 | (unint64_t)v72 & 0xFFFFFFFFFFFFFF00;
  std::string::basic_string[abi:ne180100]<0>(&v113, "resource_list");
  if (!*a2)
  {
    v96 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v96, "Could not construct");
  }
  applesauce::CF::details::find_at_key_or_optional<applesauce::CF::ArrayRef,std::string const&>(&valuePtr, *a2, (const UInt8 *)&v113);
  if (v112)
  {
    std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string const&>(v5, &v113, (uint64_t)&v113);
  }
  else
  {
    std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&valuePtr);
    LOBYTE(valuePtr) = 0;
    v112 = 0;
  }
  if (SHIBYTE(v115) < 0)
    operator delete(v113);
  if (v112)
  {
    v76 = (const void *)*((_QWORD *)this + 24);
    v77 = valuePtr;
    *((_QWORD *)this + 24) = valuePtr;
    if (v77)
      CFRetain(v77);
    if (v76)
      CFRelease(v76);
  }
  return std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&valuePtr);
}

void sub_1D4EE8060(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char **a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,const void *a22,const void *a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  void *v27;
  uint64_t v28;

  std::default_delete<MIDICI::Profile>::operator()[abi:ne180100](v28);
  if (v27)
    operator delete(v27);
  applesauce::CF::DictionaryRef::~DictionaryRef(&a22);
  applesauce::CF::TypeRef::~TypeRef(&a23);
  std::__optional_destruct_base<applesauce::CF::ArrayRef,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&a27);
  std::__tree<std::string>::destroy(*a10);
  _Unwind_Resume(a1);
}

void MIDICI::Device::serialize(MIDICI::Device *this@<X0>, CFDictionaryRef *a2@<X8>)
{
  const void *v4;
  CFArrayRef v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  MIDICI::Profile **v14;
  MIDICI::Profile **i;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  unint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  CFDictionaryRef v27;
  __int128 v28;
  unint64_t v29;
  CFArrayRef v30;
  CFTypeRef v31;
  uint64_t v32;
  const void *v33;
  unint64_t *v34;
  void *exception;
  CFArrayRef v36;
  CFTypeRef v37;
  int v38;
  _QWORD v39[2];
  CFTypeRef cf;
  __int128 v41;
  unint64_t v42;
  void **valuePtr;
  __int128 v44;
  unint64_t v45;
  unint64_t *v46;
  CFDictionaryRef v47;
  _BYTE v48[16];
  uint64_t v49;
  uint64_t v50;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  _QWORD v55[2];
  _QWORD v56[2];
  _QWORD v57[2];
  _QWORD v58[2];
  uint64_t v59;
  uint64_t v60;
  _QWORD v61[2];
  _QWORD v62[2];
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  _QWORD v67[4];

  v67[2] = *MEMORY[0x1E0C80C00];
  v4 = (const void *)*((_QWORD *)this + 24);
  if (v4)
  {
    CFRetain(*((CFTypeRef *)this + 24));
    cf = v4;
  }
  else
  {
    v5 = CFArrayCreate(0, 0, 0, MEMORY[0x1E0C9B378]);
    applesauce::CF::ArrayRef::ArrayRef((applesauce::CF::ArrayRef *)&cf, v5);
  }
  v38 = *((_DWORD *)this + 2);
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned int>((applesauce::CF::TypeRef *)v48, "object", &v38);
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned int const&>((applesauce::CF::TypeRef *)&v49, "muid", (int *)this + 16);
  applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)&v50, "device_type");
  LOBYTE(valuePtr) = *((_BYTE *)this + 68);
  if (!CFNumberCreate(0, kCFNumberCharType, &valuePtr))
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned int const&>((applesauce::CF::TypeRef *)&v52, "source", (int *)this + 18);
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned int const&>((applesauce::CF::TypeRef *)&v53, "destination", (int *)this + 19);
  MIDI2::DeviceInfo::serialize((MIDI2::DeviceInfo *)&v37, (uint64_t)this + 80);
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,applesauce::CF::DictionaryRef>((applesauce::CF::TypeRef *)&v54, "device_info", &v37);
  applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)v55, "supports_protocol_negotiation");
  v6 = *MEMORY[0x1E0C9AE50];
  v7 = *MEMORY[0x1E0C9AE40];
  if (*((_BYTE *)this + 92))
    v8 = *MEMORY[0x1E0C9AE50];
  else
    v8 = *MEMORY[0x1E0C9AE40];
  v55[1] = v8;
  applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)v56, "supports_profile_capability");
  if (*((_BYTE *)this + 93))
    v9 = v6;
  else
    v9 = v7;
  v56[1] = v9;
  applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)v57, "supports_property_exchange_capability");
  if (*((_BYTE *)this + 94))
    v10 = v6;
  else
    v10 = v7;
  v57[1] = v10;
  applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)v58, "supports_process_inquiry_capability");
  if (*((_BYTE *)this + 95))
    v11 = v6;
  else
    v11 = v7;
  v58[1] = v11;
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned long long const&>((applesauce::CF::TypeRef *)&v59, "max_sysex_size", (uint64_t *)this + 12);
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned long long const&>((applesauce::CF::TypeRef *)&v60, "max_property_requests", (uint64_t *)this + 13);
  applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)v61, "enabled");
  if (*((_BYTE *)this + 112))
    v12 = v6;
  else
    v12 = v7;
  v61[1] = v12;
  applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)v62, "client_owned");
  if (*((_BYTE *)this + 113))
    v13 = v6;
  else
    v13 = v7;
  v62[1] = v13;
  v41 = 0uLL;
  v42 = 0;
  v14 = (MIDICI::Profile **)*((_QWORD *)this + 18);
  for (i = (MIDICI::Profile **)*((_QWORD *)this + 19); v14 != i; ++v14)
  {
    MIDICI::Profile::serialize(*v14, &v47);
    v16 = (_QWORD *)*((_QWORD *)&v41 + 1);
    if (*((_QWORD *)&v41 + 1) >= v42)
    {
      v17 = (_QWORD *)v41;
      v18 = (uint64_t)(*((_QWORD *)&v41 + 1) - v41) >> 3;
      v19 = v18 + 1;
      if ((unint64_t)(v18 + 1) >> 61)
        std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
      v20 = v42 - v41;
      if ((uint64_t)(v42 - v41) >> 2 > v19)
        v19 = v20 >> 2;
      if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8)
        v21 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v21 = v19;
      v46 = &v42;
      if (v21)
      {
        v21 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v21);
        v16 = (_QWORD *)*((_QWORD *)&v41 + 1);
        v17 = (_QWORD *)v41;
      }
      else
      {
        v22 = 0;
      }
      v23 = (_QWORD *)(v21 + 8 * v18);
      v24 = v21 + 8 * v22;
      v45 = v24;
      *v23 = v47;
      v25 = v23 + 1;
      v47 = 0;
      *((_QWORD *)&v44 + 1) = v23 + 1;
      if (v16 == v17)
      {
        v27 = 0;
      }
      else
      {
        do
        {
          v26 = *--v16;
          *--v23 = v26;
          *v16 = 0;
        }
        while (v16 != v17);
        v25 = (_QWORD *)*((_QWORD *)&v44 + 1);
        v24 = v45;
        v27 = v47;
      }
      v28 = v41;
      *(_QWORD *)&v41 = v23;
      *((_QWORD *)&v41 + 1) = v25;
      v44 = v28;
      v29 = v42;
      v42 = v24;
      v45 = v29;
      valuePtr = (void **)v28;
      std::__split_buffer<applesauce::CF::DictionaryRef>::~__split_buffer((uint64_t)&valuePtr);
      *((_QWORD *)&v41 + 1) = v25;
      if (v27)
        CFRelease(v27);
    }
    else
    {
      **((_QWORD **)&v41 + 1) = v47;
      *((_QWORD *)&v41 + 1) = v16 + 1;
    }
  }
  v30 = applesauce::CF::details::make_CFArrayRef<applesauce::CF::DictionaryRef>((uint64_t **)&v41);
  v36 = v30;
  valuePtr = (void **)&v41;
  std::vector<applesauce::CF::DictionaryRef>::__destroy_vector::operator()[abi:ne180100](&valuePtr);
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,applesauce::CF::ArrayRef>((applesauce::CF::TypeRef *)&v63, "profiles", (const void **)&v36);
  LODWORD(valuePtr) = 4;
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,UMPCIObjectType>((applesauce::CF::TypeRef *)&v64, "type", (int *)&valuePtr);
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned char const&>((applesauce::CF::TypeRef *)&v65, "function_block_id", (char *)this + 168);
  applesauce::CF::TypeRefPair::TypeRefPair<char const* const&,unsigned long long const&>((applesauce::CF::TypeRef *)&v66, "timestamp", (uint64_t *)this + 7);
  applesauce::CF::TypeRef::TypeRef((applesauce::CF::TypeRef *)v67, "resource_list");
  v31 = cf;
  if (cf)
    CFRetain(cf);
  v67[1] = v31;
  v39[0] = v48;
  v39[1] = 19;
  *a2 = applesauce::CF::details::make_CFDictionaryRef((uint64_t)v39);
  v32 = 38;
  do
  {
    v33 = *(const void **)&v48[v32 * 8 - 8];
    if (v33)
      CFRelease(v33);
    v34 = (&v46)[v32];
    if (v34)
      CFRelease(v34);
    v32 -= 2;
  }
  while (v32 * 8);
  if (v30)
    CFRelease(v30);
  if (v37)
    CFRelease(v37);
  if (cf)
    CFRelease(cf);
}

void sub_1D4EE87C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,CFTypeRef cf)
{
  _Unwind_Resume(exception_object);
}

uint64_t MIDICI::Device::getUMPCIType(MIDICI::Device *this)
{
  return 4;
}

applesauce::CF::ArrayRef *applesauce::CF::ArrayRef::ArrayRef(applesauce::CF::ArrayRef *this, CFTypeRef cf)
{
  CFTypeID v3;
  void *exception;

  *(_QWORD *)this = cf;
  if (cf)
  {
    v3 = CFGetTypeID(cf);
    if (v3 != CFArrayGetTypeID())
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x1D826B7EC](exception, "Could not construct");
    }
  }
  return this;
}

void sub_1D4EE8978(_Unwind_Exception *a1)
{
  CFTypeRef *v1;
  void *v2;

  __cxa_free_exception(v2);
  if (*v1)
    CFRelease(*v1);
  _Unwind_Resume(a1);
}

uint64_t MIDICI::Device::profile(uint64_t *a1, uint64_t *a2, void *__s2, size_t __n)
{
  uint64_t *v7;
  uint64_t v8;
  const void *v9;

  if (a1 == a2)
    return 0;
  v7 = a1;
  while (1)
  {
    v8 = *v7;
    v9 = *(const void **)(*v7 + 88);
    if (*(_QWORD *)(*v7 + 96) - (_QWORD)v9 == __n && !memcmp(v9, __s2, __n))
      break;
    if (++v7 == a2)
      return 0;
  }
  if (v7 == a2)
    return 0;
  else
    return v8;
}

uint64_t std::__split_buffer<std::unique_ptr<MIDICI::Profile>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 8;
    v4 = *(_QWORD *)(i - 8);
    *(_QWORD *)(i - 8) = 0;
    if (v4)
      std::default_delete<MIDICI::Profile>::operator()[abi:ne180100](v4);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

_QWORD *MIDICI::Device::addProfile(_QWORD *result, uint64_t *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD v18[5];

  v3 = result;
  v4 = result + 20;
  v5 = result[20];
  v6 = (_QWORD *)result[19];
  if ((unint64_t)v6 >= v5)
  {
    v9 = result + 18;
    v10 = result[18];
    v11 = ((uint64_t)v6 - v10) >> 3;
    if ((unint64_t)(v11 + 1) >> 61)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v12 = v5 - v10;
    v13 = v12 >> 2;
    if (v12 >> 2 <= (unint64_t)(v11 + 1))
      v13 = v11 + 1;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
      v14 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v14 = v13;
    v18[4] = v4;
    if (v14)
      v14 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v14);
    else
      v15 = 0;
    v16 = (_QWORD *)(v14 + 8 * v11);
    v18[0] = v14;
    v18[1] = v16;
    v18[3] = v14 + 8 * v15;
    v17 = *a2;
    *a2 = 0;
    *v16 = v17;
    v18[2] = v16 + 1;
    std::vector<std::unique_ptr<UMPStream::FunctionBlock>>::__swap_out_circular_buffer(v9, v18);
    v8 = (_QWORD *)v3[19];
    result = (_QWORD *)std::__split_buffer<std::unique_ptr<MIDICI::Profile>>::~__split_buffer((uint64_t)v18);
  }
  else
  {
    v7 = *a2;
    *a2 = 0;
    *v6 = v7;
    v8 = v6 + 1;
  }
  v3[19] = v8;
  return result;
}

_QWORD *MIDICI::Device::makeGetResourceListInquiryMessage(MIDICI::Device *this, uint64_t a2, unsigned int a3)
{
  uint64_t v6;
  uint64_t **v7;
  uint64_t *v8;
  uint64_t **v9;
  unsigned int v10;
  unsigned int v11;
  BOOL v12;
  char v13;
  uint64_t **v14;
  char v15;
  char *v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t v19;
  char *v20;
  std::string *v21;
  char *v22;
  std::string *v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  unsigned int v27;
  std::string *v28;
  __int128 v29;
  std::string *v30;
  __int128 v31;
  std::string *v32;
  __int128 v33;
  std::string *v34;
  __int128 v35;
  char *v36;
  unint64_t v37;
  _QWORD *result;
  uint64_t v39;
  const char *v40;
  int v41;
  const char *v42;
  const char *v43;
  void *__p[2];
  int64_t v45;
  void *v46[2];
  char v47;
  std::string::value_type __s[23];
  char v49;
  std::string v50;
  std::string v51;
  _QWORD v52[3];
  _QWORD *v53;
  _QWORD v54[3];
  _QWORD *v55;
  std::string v56;
  std::string *v57;
  std::string __src;
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  v52[0] = &off_1E98B7410;
  v52[1] = a2;
  v53 = v52;
  v6 = *(unsigned __int8 *)(a2 + 184);
  *(_BYTE *)(a2 + 184) = (v6 + 1) & 0x7F;
  v7 = *(uint64_t ***)(a2 + 176);
  v55 = v54;
  std::__function::__func<MIDICI::Device::makeGetResourceListInquiryMessage(int)::$_0,std::allocator<MIDICI::Device::makeGetResourceListInquiryMessage(int)::$_0>,void ()(caulk::expected<std::span<unsigned char const,18446744073709551615ul>,PropertyExchange::RequestError>)>::__clone((uint64_t)v52, v54);
  v9 = v7 + 1;
  v8 = v7[1];
  if (v8)
  {
    while (1)
    {
      while (1)
      {
        v9 = (uint64_t **)v8;
        v10 = *((_DWORD *)v8 + 8);
        if (v10 == a3)
          break;
        if (v10 <= a3)
        {
          if (v10 >= a3)
            v15 = 1;
          else
            v15 = -1;
          if ((v15 & 0x80) == 0)
            goto LABEL_24;
          goto LABEL_18;
        }
LABEL_12:
        v8 = *v9;
        v14 = v9;
        if (!*v9)
          goto LABEL_21;
      }
      v11 = *((unsigned __int8 *)v9 + 36);
      if (v6 < v11)
        goto LABEL_12;
      v12 = v11 == (_DWORD)v6;
      if (v11 >= v6)
        v13 = 1;
      else
        v13 = -1;
      if (v12)
        v13 = 0;
      if ((v13 & 0x80) == 0)
      {
LABEL_24:
        v16 = (char *)v9;
        goto LABEL_25;
      }
LABEL_18:
      v14 = v9 + 1;
      v8 = v9[1];
      if (!v8)
        goto LABEL_21;
    }
  }
  v14 = v7 + 1;
LABEL_21:
  v16 = (char *)operator new(0x68uLL);
  *((_QWORD *)v16 + 4) = a3 | (unint64_t)(v6 << 32);
  *(_OWORD *)(v16 + 40) = 0u;
  *(_OWORD *)(v16 + 56) = 0u;
  *(_OWORD *)(v16 + 72) = 0u;
  *(_OWORD *)(v16 + 88) = 0u;
  *(_QWORD *)v16 = 0;
  *((_QWORD *)v16 + 1) = 0;
  *((_QWORD *)v16 + 2) = v9;
  *v14 = (uint64_t *)v16;
  v17 = (uint64_t *)**v7;
  v18 = (uint64_t *)v16;
  if (v17)
  {
    *v7 = v17;
    v18 = *v14;
  }
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v7[1], v18);
  v7[2] = (uint64_t *)((char *)v7[2] + 1);
LABEL_25:
  *((_WORD *)v16 + 22) = 0;
  v16[46] = v6;
  v19 = (uint64_t)v55;
  if (!v55)
    goto LABEL_28;
  if (v55 != v54)
  {
    v19 = (*(uint64_t (**)(void))(*v55 + 16))();
LABEL_28:
    v57 = (std::string *)v19;
    goto LABEL_30;
  }
  v57 = &v56;
  (*(void (**)(_QWORD *, std::string *))(v54[0] + 24))(v54, &v56);
LABEL_30:
  v20 = v16 + 72;
  if (v16 + 72 != (char *)&v56)
  {
    v21 = v57;
    v22 = (char *)*((_QWORD *)v16 + 12);
    if (v57 == &v56)
    {
      if (v22 == v20)
      {
        (*(void (**)(std::string *, std::string *))(v56.__r_.__value_.__r.__words[0] + 24))(&v56, &__src);
        (*(void (**)(std::string *))(v57->__r_.__value_.__r.__words[0] + 32))(v57);
        v57 = 0;
        (*(void (**)(_QWORD, std::string *))(**((_QWORD **)v16 + 12) + 24))(*((_QWORD *)v16 + 12), &v56);
        (*(void (**)(_QWORD))(**((_QWORD **)v16 + 12) + 32))(*((_QWORD *)v16 + 12));
        *((_QWORD *)v16 + 12) = 0;
        v57 = &v56;
        (*(void (**)(std::string *, char *))(__src.__r_.__value_.__r.__words[0] + 24))(&__src, v16 + 72);
        (*(void (**)(std::string *))(__src.__r_.__value_.__r.__words[0] + 32))(&__src);
      }
      else
      {
        (*(void (**)(std::string *, char *))(v56.__r_.__value_.__r.__words[0] + 24))(&v56, v16 + 72);
        (*(void (**)(std::string *))(v57->__r_.__value_.__r.__words[0] + 32))(v57);
        v57 = (std::string *)*((_QWORD *)v16 + 12);
      }
      *((_QWORD *)v16 + 12) = v20;
    }
    else if (v22 == v20)
    {
      (*(void (**)(char *, std::string *))(*(_QWORD *)v20 + 24))(v16 + 72, &v56);
      (*(void (**)(_QWORD))(**((_QWORD **)v16 + 12) + 32))(*((_QWORD *)v16 + 12));
      *((_QWORD *)v16 + 12) = v57;
      v57 = &v56;
    }
    else
    {
      v57 = (std::string *)*((_QWORD *)v16 + 12);
      *((_QWORD *)v16 + 12) = v21;
    }
  }
  v23 = v57;
  if (v57 == &v56)
  {
    v24 = 4;
    v23 = &v56;
  }
  else
  {
    if (!v57)
      goto LABEL_44;
    v24 = 5;
  }
  (*(void (**)(void))(v23->__r_.__value_.__r.__words[0] + 8 * v24))();
LABEL_44:
  v25 = v55;
  if (v55 == v54)
  {
    v26 = 4;
    v25 = v54;
  }
  else
  {
    if (!v55)
      goto LABEL_49;
    v26 = 5;
  }
  (*(void (**)(void))(*v25 + 8 * v26))();
LABEL_49:
  v27 = *(_DWORD *)(a2 + 64);
  std::string::basic_string[abi:ne180100]<0>(&v50, "{\"");
  v49 = 8;
  strcpy(__s, "resource");
  v28 = std::string::append(&v50, __s, 8uLL);
  v29 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
  v51.__r_.__value_.__r.__words[2] = v28->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v51.__r_.__value_.__l.__data_ = v29;
  v28->__r_.__value_.__l.__size_ = 0;
  v28->__r_.__value_.__r.__words[2] = 0;
  v28->__r_.__value_.__r.__words[0] = 0;
  v30 = std::string::append(&v51, "\":\"", 3uLL);
  v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
  __src.__r_.__value_.__r.__words[2] = v30->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__src.__r_.__value_.__l.__data_ = v31;
  v30->__r_.__value_.__l.__size_ = 0;
  v30->__r_.__value_.__r.__words[2] = 0;
  v30->__r_.__value_.__r.__words[0] = 0;
  v47 = 12;
  strcpy((char *)v46, "ResourceList");
  v32 = std::string::append(&__src, (const std::string::value_type *)v46, 0xCuLL);
  v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
  v56.__r_.__value_.__r.__words[2] = v32->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v56.__r_.__value_.__l.__data_ = v33;
  v32->__r_.__value_.__l.__size_ = 0;
  v32->__r_.__value_.__r.__words[2] = 0;
  v32->__r_.__value_.__r.__words[0] = 0;
  v34 = std::string::append(&v56, "\"}", 2uLL);
  v35 = *(_OWORD *)&v34->__r_.__value_.__l.__data_;
  v45 = v34->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v35;
  v34->__r_.__value_.__l.__size_ = 0;
  v34->__r_.__value_.__r.__words[2] = 0;
  v34->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v56.__r_.__value_.__l.__data_);
  if (v47 < 0)
    operator delete(v46[0]);
  if (SHIBYTE(__src.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__src.__r_.__value_.__l.__data_);
  if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v51.__r_.__value_.__l.__data_);
  if (v49 < 0)
    operator delete(*(void **)__s);
  if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v50.__r_.__value_.__l.__data_);
  if (v45 >= 0)
    v36 = (char *)__p;
  else
    v36 = (char *)__p[0];
  if (v45 >= 0)
    v37 = HIBYTE(v45);
  else
    v37 = (unint64_t)__p[1];
  midi::ci::message::make_with_payload_size((midi::ci::message *)&v56, v37 + 9, 52, a3, v27, 127);
  if (v37 && !v36)
  {
    v40 = "!header.size || header.data";
    v41 = 264;
    v42 = "capability_inquiry.cpp";
    v43 = "make_property_data_message";
    goto LABEL_86;
  }
  if ((v6 & 0x80) != 0)
  {
    v40 = "value <= uint7_max";
    v41 = 208;
    v42 = "sysex.h";
    v43 = "add_uint7";
    goto LABEL_86;
  }
  __src.__r_.__value_.__s.__data_[0] = v6;
  std::vector<unsigned char>::__insert_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((uint64_t)&v56.__r_.__value_.__l.__size_, (char *)v56.__r_.__value_.__r.__words[2], (char *)&__src, &__src.__r_.__value_.__s.__data_[1], 1);
  if ((v37 & 0xC000) != 0)
  {
    v40 = "value <= uint14_max";
    v41 = 224;
    v42 = "sysex.h";
    v43 = "add_uint14";
    goto LABEL_86;
  }
  __src.__r_.__value_.__s.__data_[0] = v37 & 0x7F;
  __src.__r_.__value_.__s.__data_[1] = v37 >> 7;
  std::vector<unsigned char>::__insert_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((uint64_t)&v56.__r_.__value_.__l.__size_, (char *)v56.__r_.__value_.__r.__words[2], (char *)&__src, &__src.__r_.__value_.__s.__data_[2], 2);
  if (!v37)
    goto LABEL_74;
  if (!v36)
  {
    v40 = "d";
    v41 = 216;
    v42 = "sysex.h";
    v43 = "add_data";
LABEL_86:
    __assert_rtn(v43, v42, v41, v40);
  }
  std::vector<unsigned char>::__insert_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((uint64_t)&v56.__r_.__value_.__l.__size_, (char *)v56.__r_.__value_.__r.__words[2], v36, &v36[v37], v37);
LABEL_74:
  LOWORD(__src.__r_.__value_.__l.__data_) = 1;
  std::vector<unsigned char>::__insert_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((uint64_t)&v56.__r_.__value_.__l.__size_, (char *)v56.__r_.__value_.__r.__words[2], (char *)&__src, &__src.__r_.__value_.__s.__data_[2], 2);
  LOWORD(__src.__r_.__value_.__l.__data_) = 1;
  std::vector<unsigned char>::__insert_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((uint64_t)&v56.__r_.__value_.__l.__size_, (char *)v56.__r_.__value_.__r.__words[2], (char *)&__src, &__src.__r_.__value_.__s.__data_[2], 2);
  LOWORD(__src.__r_.__value_.__l.__data_) = 0;
  std::vector<unsigned char>::__insert_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>((uint64_t)&v56.__r_.__value_.__l.__size_, (char *)v56.__r_.__value_.__r.__words[2], (char *)&__src, &__src.__r_.__value_.__s.__data_[2], 2);
  if (SHIBYTE(v45) < 0)
    operator delete(__p[0]);
  *(_DWORD *)this = v56.__r_.__value_.__l.__data_;
  *(_OWORD *)((char *)this + 8) = *(_OWORD *)&v56.__r_.__value_.__r.__words[1];
  *((_QWORD *)this + 3) = v57;
  result = v53;
  if (v53 == v52)
  {
    v39 = 4;
    result = v52;
  }
  else
  {
    if (!v53)
      return result;
    v39 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v39))();
}

void sub_1D4EE9230(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,char a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44,uint64_t a45,uint64_t a46,uint64_t a47)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void std::__function::__func<MIDICI::Device::makeGetResourceListInquiryMessage(int)::$_0,std::allocator<MIDICI::Device::makeGetResourceListInquiryMessage(int)::$_0>,void ()(caulk::expected<std::span<unsigned char const,18446744073709551615ul>,PropertyExchange::RequestError>)>::~__func()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *std::__function::__func<MIDICI::Device::makeGetResourceListInquiryMessage(int)::$_0,std::allocator<MIDICI::Device::makeGetResourceListInquiryMessage(int)::$_0>,void ()(caulk::expected<std::span<unsigned char const,18446744073709551615ul>,PropertyExchange::RequestError>)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E98B7410;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<MIDICI::Device::makeGetResourceListInquiryMessage(int)::$_0,std::allocator<MIDICI::Device::makeGetResourceListInquiryMessage(int)::$_0>,void ()(caulk::expected<std::span<unsigned char const,18446744073709551615ul>,PropertyExchange::RequestError>)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E98B7410;
  a2[1] = v2;
  return result;
}

void std::__function::__func<MIDICI::Device::makeGetResourceListInquiryMessage(int)::$_0,std::allocator<MIDICI::Device::makeGetResourceListInquiryMessage(int)::$_0>,void ()(caulk::expected<std::span<unsigned char const,18446744073709551615ul>,PropertyExchange::RequestError>)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  lconv *v7;
  char v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  CFNumberRef v17;
  const void *v18;
  const std::string *v19;
  uint64_t *v20;
  _QWORD v21[3];
  _QWORD *v22;
  _BYTE v23[24];
  _BYTE *v24;
  _QWORD v25[3];
  _QWORD *v26;
  int v27;
  _QWORD v28[3];
  char v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char v40;
  _QWORD v41[3];
  _QWORD *v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  if (!*((_BYTE *)a2 + 16))
    return;
  v2 = *(_QWORD *)(a1 + 8);
  v3 = *a2;
  v4 = a2[1];
  v22 = 0;
  LOBYTE(v19) = 0;
  v20 = 0;
  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)&v19);
  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)&v19);
  v5 = (uint64_t)v22;
  if (!v22)
    goto LABEL_5;
  if (v22 != v21)
  {
    v5 = (*(uint64_t (**)(void))(*v22 + 16))();
LABEL_5:
    v24 = (_BYTE *)v5;
    goto LABEL_7;
  }
  v24 = v23;
  (*(void (**)(_QWORD *, _BYTE *))(v21[0] + 24))(v21, v23);
LABEL_7:
  std::__function::__value_func<BOOL ()(int,nlohmann::detail::parse_event_t,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> &)>::__value_func[abi:ne180100]((uint64_t)v41, (uint64_t)v23);
  v6 = (uint64_t)v42;
  if (!v42)
  {
LABEL_10:
    v26 = (_QWORD *)v6;
    goto LABEL_12;
  }
  if (v42 != v41)
  {
    v6 = (*(uint64_t (**)(_QWORD *))(*v42 + 16))(v42);
    goto LABEL_10;
  }
  v26 = v25;
  (*(void (**)(_QWORD *, _QWORD *))(v41[0] + 24))(v41, v25);
LABEL_12:
  v27 = 0;
  v28[0] = v3;
  v28[1] = v3 + v4;
  v28[2] = -1;
  v29 = 0;
  v30 = 0u;
  v31 = 0u;
  v32 = 0u;
  v33 = 0u;
  v34 = 0;
  v35 = "";
  v37 = 0;
  v38 = 0;
  v36 = 0;
  v7 = localeconv();
  if (!v7)
    __assert_rtn("get_decimal_point", "lexer.hpp", 136, "loc != nullptr");
  if (v7->decimal_point)
    v8 = *v7->decimal_point;
  else
    v8 = 46;
  v39 = v8;
  v40 = 0;
  v27 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::scan((uint64_t)v28);
  v9 = v42;
  if (v42 == v41)
  {
    v10 = 4;
    v9 = v41;
  }
  else
  {
    if (!v42)
      goto LABEL_21;
    v10 = 5;
  }
  (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_21:
  nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::parse((uint64_t)v25, (unsigned __int8 *)&v19);
  nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::~lexer((uint64_t)v28);
  v11 = v26;
  if (v26 == v25)
  {
    v12 = 4;
    v11 = v25;
  }
  else
  {
    if (!v26)
      goto LABEL_26;
    v12 = 5;
  }
  (*(void (**)(void))(*v11 + 8 * v12))();
LABEL_26:
  v13 = v24;
  if (v24 == v23)
  {
    v14 = 4;
    v13 = v23;
  }
  else
  {
    if (!v24)
      goto LABEL_31;
    v14 = 5;
  }
  (*(void (**)(void))(*v13 + 8 * v14))();
LABEL_31:
  v15 = v22;
  if (v22 == v21)
  {
    v16 = 4;
    v15 = v21;
    goto LABEL_35;
  }
  if (v22)
  {
    v16 = 5;
LABEL_35:
    (*(void (**)(void))(*v15 + 8 * v16))();
  }
  if (v19 == 9)
    v17 = 0;
  else
    v17 = ConvertJSONToCFType(&v19);
  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)&v19);
  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(&v20, v19);
  applesauce::CF::ArrayRef::ArrayRef((applesauce::CF::ArrayRef *)v25, v17);
  v18 = *(const void **)(v2 + 192);
  *(_QWORD *)(v2 + 192) = v25[0];
  v25[0] = v18;
  if (v18)
    CFRelease(v18);
}

void sub_1D4EE96B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _Unwind_Exception *exception_object, unsigned __int8 a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23)
{
  uint64_t **v23;

  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)&a10);
  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(v23, a10);
  _Unwind_Resume(a1);
}

CFNumberRef ConvertJSONToCFType(const std::string **a1)
{
  int v2;
  __CFArray *Mutable;
  unsigned __int8 **v4;
  int v5;
  std::string *p_p;
  unsigned __int8 *v7;
  const char *v8;
  CFStringRef v9;
  const void *v10;
  unsigned __int8 *v11;
  const void *v12;
  double v13;
  void *v14;
  std::string *p_valuePtr;
  uint64_t v16;
  nlohmann::detail::exception *exception;
  unint64_t v19;
  char *v20;
  std::string v21;
  uint64_t v22;
  unint64_t v23;
  void *v24;
  char v25;
  void *v26;
  char v27;
  std::string valuePtr;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  std::string __p;
  void *v34;
  char v35;
  std::string v36;

  v2 = *(unsigned __int8 *)a1;
  if (v2 == 2)
  {
    Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    *(_OWORD *)&valuePtr.__r_.__value_.__l.__data_ = (unint64_t)a1;
    valuePtr.__r_.__value_.__r.__words[2] = 0;
    v29 = 0;
    v30 = 0x8000000000000000;
    nlohmann::detail::iter_impl<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> const>::set_begin((unsigned __int8 **)&valuePtr);
    *(_OWORD *)&v21.__r_.__value_.__l.__data_ = (unint64_t)a1;
    v21.__r_.__value_.__r.__words[2] = 0;
    v22 = 0;
    v23 = 0x8000000000000000;
    nlohmann::detail::iter_impl<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> const>::set_end((unsigned __int8 **)&v21);
    while (!nlohmann::detail::iter_impl<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> const>::operator==((unsigned __int8 **)&valuePtr, (unsigned __int8 **)&v21))
    {
      v11 = nlohmann::detail::iter_impl<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> const>::operator*((unsigned __int8 **)&valuePtr);
      v12 = (const void *)ConvertJSONToCFType(v11);
      CFArrayAppendValue(Mutable, v12);
      CFRelease(v12);
      nlohmann::detail::iter_impl<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> const>::operator++((unsigned __int8 **)&valuePtr);
    }
  }
  else if (v2 == 1)
  {
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    nlohmann::detail::iter_impl<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> const>::iter_impl(&v21, (uint64_t)a1);
    nlohmann::detail::iter_impl<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> const>::set_begin((unsigned __int8 **)&v21);
    nlohmann::detail::iteration_proxy_value<nlohmann::detail::iter_impl<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> const>>::iteration_proxy_value((uint64_t)&valuePtr, (uint64_t)&v21);
    v4 = (unsigned __int8 **)nlohmann::detail::iter_impl<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> const>::iter_impl(&v36, (uint64_t)a1);
    nlohmann::detail::iter_impl<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> const>::set_end(v4);
    nlohmann::detail::iteration_proxy_value<nlohmann::detail::iter_impl<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> const>>::iteration_proxy_value((uint64_t)&v21, (uint64_t)&v36);
    while (!nlohmann::detail::iter_impl<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> const>::operator==((unsigned __int8 **)&valuePtr, (unsigned __int8 **)&v21))
    {
      if (!valuePtr.__r_.__value_.__r.__words[0])
        __assert_rtn("key", "iteration_proxy.hpp", 75, "anchor.m_object != nullptr");
      v5 = *valuePtr.__r_.__value_.__l.__data_;
      if (v5 == 1)
      {
        p_p = (std::string *)(valuePtr.__r_.__value_.__l.__size_ + 32);
      }
      else
      {
        p_p = (std::string *)&v34;
        if (v5 == 2)
        {
          p_p = &__p;
          if (v31 != v32)
          {
            std::to_string(&v36, v31);
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
              operator delete(__p.__r_.__value_.__l.__data_);
            __p = v36;
            v32 = v31;
            p_p = &__p;
          }
        }
      }
      v7 = nlohmann::detail::iter_impl<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> const>::operator*((unsigned __int8 **)&valuePtr);
      if ((p_p->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v8 = (const char *)p_p;
      else
        v8 = (const char *)p_p->__r_.__value_.__r.__words[0];
      v9 = CFStringCreateWithCString(0, v8, 0x8000100u);
      v10 = (const void *)ConvertJSONToCFType(v7);
      CFDictionarySetValue(Mutable, v9, v10);
      CFRelease(v9);
      CFRelease(v10);
      nlohmann::detail::iter_impl<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> const>::operator++((unsigned __int8 **)&valuePtr);
      ++v31;
    }
    if (v27 < 0)
      operator delete(v26);
    if (v25 < 0)
      operator delete(v24);
    if (v35 < 0)
      operator delete(v34);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      v14 = (void *)__p.__r_.__value_.__r.__words[0];
LABEL_33:
      operator delete(v14);
    }
  }
  else if ((v2 - 5) > 2)
  {
    if (v2 == 4)
    {
      v16 = MEMORY[0x1E0C9AE50];
      if (!*((_BYTE *)a1 + 8))
        v16 = MEMORY[0x1E0C9AE40];
      return *(CFNumberRef *)v16;
    }
    else
    {
      if (v2 != 3)
        return 0;
      memset(&valuePtr, 0, sizeof(valuePtr));
      std::string::operator=(&valuePtr, a1[1]);
      if ((valuePtr.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        p_valuePtr = &valuePtr;
      else
        p_valuePtr = (std::string *)valuePtr.__r_.__value_.__r.__words[0];
      Mutable = (__CFArray *)CFStringCreateWithCString(0, (const char *)p_valuePtr, 0x8000100u);
      if (SHIBYTE(valuePtr.__r_.__value_.__r.__words[2]) < 0)
      {
        v14 = (void *)valuePtr.__r_.__value_.__r.__words[0];
        goto LABEL_33;
      }
    }
  }
  else
  {
    switch(v2)
    {
      case 5:
        v13 = (double)(uint64_t)a1[1];
        break;
      case 7:
        v13 = *((double *)a1 + 1);
        break;
      case 6:
        v13 = (double)(unint64_t)a1[1];
        break;
      default:
        exception = (nlohmann::detail::exception *)__cxa_allocate_exception(0x20uLL);
        v19 = *(unsigned __int8 *)a1;
        if (v19 > 9)
          v20 = "number";
        else
          v20 = off_1E98BA368[v19];
        std::string::basic_string[abi:ne180100]<0>(&v21, v20);
        std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&valuePtr, "type must be number, but is ", &v21);
        nlohmann::detail::type_error::create(exception, 302, (uint64_t)&valuePtr);
    }
    *(double *)&valuePtr.__r_.__value_.__l.__data_ = v13;
    return CFNumberCreate(0, kCFNumberDoubleType, &valuePtr);
  }
  return Mutable;
}

void sub_1D4EE9BDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  void *v31;
  int v32;

  if (a31 < 0)
    operator delete(__p);
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v32 & 1) == 0)
LABEL_8:
      _Unwind_Resume(a1);
  }
  else if (!v32)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v31);
  goto LABEL_8;
}

BOOL nlohmann::detail::iter_impl<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> const>::operator==(unsigned __int8 **a1, unsigned __int8 **a2)
{
  unsigned __int8 *v2;
  int v3;
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  nlohmann::detail::exception *exception;
  _QWORD v8[3];

  v2 = *a1;
  if (*a1 != *a2)
  {
    exception = (nlohmann::detail::exception *)__cxa_allocate_exception(0x20uLL);
    std::string::basic_string[abi:ne180100]<0>(v8, "cannot compare iterators of different containers");
    nlohmann::detail::invalid_iterator::create(exception, 212, (uint64_t)v8);
  }
  if (!v2)
    __assert_rtn("operator==", "iter_impl.hpp", 405, "m_object != nullptr");
  v3 = *v2;
  if (v3 == 2)
  {
    v4 = a1[2];
    v5 = a2[2];
  }
  else if (v3 == 1)
  {
    v4 = a1[1];
    v5 = a2[1];
  }
  else
  {
    v4 = a1[4];
    v5 = a2[4];
  }
  return v4 == v5;
}

void sub_1D4EE9D6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  void *v15;
  int v16;

  if (a15 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0)
LABEL_6:
      _Unwind_Resume(a1);
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

unsigned __int8 *nlohmann::detail::iter_impl<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> const>::operator*(unsigned __int8 **a1)
{
  unsigned __int8 *result;
  int v3;
  nlohmann::detail::exception *v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  nlohmann::detail::exception *exception;
  _QWORD v8[3];

  result = *a1;
  if (!result)
    __assert_rtn("operator*", "iter_impl.hpp", 242, "m_object != nullptr");
  v3 = *result;
  if (v3 == 1)
  {
    v6 = a1[1];
    if (v6 == (unsigned __int8 *)(*((_QWORD *)result + 1) + 8))
      __assert_rtn("operator*", "iter_impl.hpp", 248, "m_it.object_iterator != m_object->m_value.object->end()");
    return v6 + 56;
  }
  else if (v3 == 2)
  {
    v5 = *(unsigned __int8 **)(*((_QWORD *)result + 1) + 8);
    result = a1[2];
    if (result == v5)
      __assert_rtn("operator*", "iter_impl.hpp", 254, "m_it.array_iterator != m_object->m_value.array->end()");
  }
  else
  {
    if (!*result)
    {
      exception = (nlohmann::detail::exception *)__cxa_allocate_exception(0x20uLL);
      std::string::basic_string[abi:ne180100]<0>(v8, "cannot get value");
      nlohmann::detail::invalid_iterator::create(exception, 214, (uint64_t)v8);
    }
    if (a1[4])
    {
      v4 = (nlohmann::detail::exception *)__cxa_allocate_exception(0x20uLL);
      std::string::basic_string[abi:ne180100]<0>(v8, "cannot get value");
      nlohmann::detail::invalid_iterator::create(v4, 214, (uint64_t)v8);
    }
  }
  return result;
}

void sub_1D4EE9F24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  void *v15;
  char v16;

  if (a15 < 0)
    operator delete(__p);
  if ((v16 & 1) != 0)
    __cxa_free_exception(v15);
  _Unwind_Resume(exception_object);
}

unsigned __int8 **nlohmann::detail::iter_impl<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> const>::operator++(unsigned __int8 **result)
{
  int v1;
  unsigned __int8 *v2;
  unsigned __int8 *v3;
  unsigned __int8 *v4;
  BOOL v5;

  if (!*result)
    __assert_rtn("operator++", "iter_impl.hpp", 324, "m_object != nullptr");
  v1 = **result;
  if (v1 == 2)
  {
    result[2] += 16;
  }
  else if (v1 == 1)
  {
    v2 = result[1];
    v3 = (unsigned __int8 *)*((_QWORD *)v2 + 1);
    if (v3)
    {
      do
      {
        v4 = v3;
        v3 = *(unsigned __int8 **)v3;
      }
      while (v3);
    }
    else
    {
      do
      {
        v4 = (unsigned __int8 *)*((_QWORD *)v2 + 2);
        v5 = *(_QWORD *)v4 == (_QWORD)v2;
        v2 = v4;
      }
      while (!v5);
    }
    result[1] = v4;
  }
  else
  {
    ++result[4];
  }
  return result;
}

uint64_t nlohmann::detail::iteration_proxy_value<nlohmann::detail::iter_impl<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> const>>::~iteration_proxy_value(uint64_t a1)
{
  if (*(char *)(a1 + 103) < 0)
    operator delete(*(void **)(a1 + 80));
  if (*(char *)(a1 + 79) < 0)
    operator delete(*(void **)(a1 + 56));
  return a1;
}

_QWORD *nlohmann::detail::iter_impl<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> const>::iter_impl(_QWORD *result, uint64_t a2)
{
  *result = a2;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  result[4] = 0x8000000000000000;
  if (!a2)
    __assert_rtn("iter_impl", "iter_impl.hpp", 88, "m_object != nullptr");
  return result;
}

unsigned __int8 **nlohmann::detail::iter_impl<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> const>::set_begin(unsigned __int8 **result)
{
  unsigned __int8 *v1;
  int v2;

  v1 = *result;
  if (!*result)
    __assert_rtn("set_begin", "iter_impl.hpp", 174, "m_object != nullptr");
  v2 = *v1;
  if (*v1)
  {
    if (v2 == 2)
    {
      result[2] = (unsigned __int8 *)**((_QWORD **)v1 + 1);
    }
    else if (v2 == 1)
    {
      result[1] = (unsigned __int8 *)**((_QWORD **)v1 + 1);
    }
    else
    {
      result[4] = 0;
    }
  }
  else
  {
    result[4] = (unsigned __int8 *)1;
  }
  return result;
}

unsigned __int8 **nlohmann::detail::iter_impl<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> const>::set_end(unsigned __int8 **result)
{
  unsigned __int8 *v1;
  int v2;

  v1 = *result;
  if (!*result)
    __assert_rtn("set_end", "iter_impl.hpp", 211, "m_object != nullptr");
  v2 = *v1;
  if (v2 == 2)
  {
    result[2] = *(unsigned __int8 **)(*((_QWORD *)v1 + 1) + 8);
  }
  else if (v2 == 1)
  {
    result[1] = (unsigned __int8 *)(*((_QWORD *)v1 + 1) + 8);
  }
  else
  {
    result[4] = (unsigned __int8 *)1;
  }
  return result;
}

uint64_t nlohmann::detail::iteration_proxy_value<nlohmann::detail::iter_impl<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>> const>>::iteration_proxy_value(uint64_t a1, uint64_t a2)
{
  __int128 v3;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  v3 = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 8) = v3;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  std::string::basic_string[abi:ne180100]<0>((_QWORD *)(a1 + 56), "0");
  std::string::basic_string[abi:ne180100]<0>((_QWORD *)(a1 + 80), "");
  return a1;
}

void nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::parse(uint64_t a1, unsigned __int8 *a2)
{
  _QWORD *v4;
  uint64_t v5;
  char v6;
  int v7;
  int v8;
  std::string::size_type size;
  std::string::size_type v10;
  uint64_t v11;
  std::string::size_type v12;
  int v13;
  int v14;
  int v15;
  int v16;
  uint64_t **v17;
  int v18;
  uint64_t **v19;
  int v20;
  unsigned __int8 v21;
  int v22;
  int v23;
  std::string::size_type v24;
  std::string::size_type v25;
  std::string::size_type v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  uint64_t *v35;
  int v36;
  uint64_t **v37;
  int v38;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  char v42[8];
  uint64_t *v43;
  _BYTE v44[8];
  uint64_t v45;
  char v46[8];
  uint64_t v47;
  std::string v48;
  std::string v49;
  std::string v50;
  std::exception v51;
  std::runtime_error v52;
  std::string v53;
  std::string __p;
  _BYTE v55[24];
  _BYTE *v56;
  unsigned __int8 *v57;
  __int128 v58;
  __int128 v59;
  char v60;
  char v61;
  char v62;
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)(a1 + 24))
  {
    v6 = *(_BYTE *)(a1 + 184);
    v57 = a2;
    v58 = 0u;
    v59 = 0u;
    v60 = 0;
    v61 = v6;
    memset(&__p, 0, sizeof(__p));
    while (1)
    {
      switch(*(_DWORD *)(a1 + 32))
      {
        case 1:
          LOBYTE(v51.__vftable) = 1;
          nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<BOOL &>(&v57, (unsigned __int8 *)&v51);
          goto LABEL_19;
        case 2:
          LOBYTE(v51.__vftable) = 0;
          nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<BOOL &>(&v57, (unsigned __int8 *)&v51);
          goto LABEL_19;
        case 3:
          nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<decltype(nullptr)>(&v57);
          goto LABEL_19;
        case 4:
          nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<std::string&>((uint64_t *)&v57, a1 + 120);
          goto LABEL_19;
        case 5:
          v51.__vftable = *(std::exception_vtbl **)(a1 + 160);
          nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<unsigned long long &>(&v57, (uint64_t *)&v51);
          goto LABEL_19;
        case 6:
          v51.__vftable = *(std::exception_vtbl **)(a1 + 152);
          nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<long long &>(&v57, (uint64_t *)&v51);
          goto LABEL_19;
        case 7:
          if ((*(_QWORD *)(a1 + 168) & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
          {
            nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get_token_string(&v53, *(unsigned __int8 **)(a1 + 96), *(unsigned __int8 **)(a1 + 104));
            nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get_token_string(&v48, *(unsigned __int8 **)(a1 + 96), *(unsigned __int8 **)(a1 + 104));
            std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&v49, "number overflow parsing '", &v48);
            std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&v50, &v49, "'");
            nlohmann::detail::out_of_range::create((nlohmann::detail::exception *)&v51, (uint64_t)&v50);
            nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error((uint64_t)&v57, (const nlohmann::detail::type_error *)&v51);
            v51.__vftable = (std::exception_vtbl *)&off_1E98B6FE0;
            std::runtime_error::~runtime_error(&v52);
            std::exception::~exception(&v51);
            if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v50.__r_.__value_.__l.__data_);
            goto LABEL_114;
          }
          v51.__vftable = *(std::exception_vtbl **)(a1 + 168);
          nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<double &>(&v57, (uint64_t *)&v51);
          goto LABEL_19;
        case 8:
          nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::start_array((uint64_t *)&v57);
          v7 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::scan(a1 + 40);
          *(_DWORD *)(a1 + 32) = v7;
          if (v7 == 10)
            goto LABEL_14;
          LOBYTE(v51.__vftable) = 1;
          std::vector<BOOL>::push_back((uint64_t)&__p, &v51);
          continue;
        case 9:
          nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::start_object((uint64_t *)&v57);
          v8 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::scan(a1 + 40);
          *(_DWORD *)(a1 + 32) = v8;
          if (v8 == 11)
          {
LABEL_14:
            *((_QWORD *)&v58 + 1) -= 8;
LABEL_19:
            size = __p.__r_.__value_.__l.__size_;
            if (!__p.__r_.__value_.__l.__size_)
            {
LABEL_73:
              if (__p.__r_.__value_.__r.__words[0])
                operator delete(__p.__r_.__value_.__l.__data_);
              nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)a2);
              v33 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::scan(a1 + 40);
              *(_DWORD *)(a1 + 32) = v33;
              if (v33 != 15)
              {
                nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get_token_string(&__p, *(unsigned __int8 **)(a1 + 96), *(unsigned __int8 **)(a1 + 104));
                v53 = *(std::string *)(a1 + 72);
                std::string::basic_string[abi:ne180100]<0>(&v49, "value");
                nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::exception_message(&v50, a1, 0xFu, (uint64_t)&v49);
                nlohmann::detail::parse_error::create((nlohmann::detail::exception *)&v51, (uint64_t *)&v53, (uint64_t)&v50);
                nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error((uint64_t)&v57, (const nlohmann::detail::type_error *)&v51);
                v51.__vftable = (std::exception_vtbl *)&off_1E98B6FE0;
                std::runtime_error::~runtime_error(&v52);
                std::exception::~exception(&v51);
                if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(v50.__r_.__value_.__l.__data_);
                if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(v49.__r_.__value_.__l.__data_);
                if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(__p.__r_.__value_.__l.__data_);
              }
              if (v60)
              {
                v42[0] = 9;
                v43 = 0;
                nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v42);
                nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v42);
                v34 = *a2;
                *a2 = 9;
                v42[0] = v34;
                v35 = (uint64_t *)*((_QWORD *)a2 + 1);
                *((_QWORD *)a2 + 1) = 0;
                v43 = v35;
                nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)a2);
                nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v42);
                nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(&v43, v34);
              }
              if ((_QWORD)v58)
                operator delete((void *)v58);
              return;
            }
            v10 = __p.__r_.__value_.__r.__words[0];
            v11 = *((_QWORD *)&v58 + 1);
            while (1)
            {
              v12 = size - 1;
              if (((*(_QWORD *)(v10 + (((size - 1) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (size - 1)) & 1) != 0)
              {
                v13 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::scan(a1 + 40);
                *(_DWORD *)(a1 + 32) = v13;
                if (v13 == 13)
                {
                  *((_QWORD *)&v58 + 1) = v11;
                  __p.__r_.__value_.__l.__size_ = size;
                  v15 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::scan(a1 + 40);
                  goto LABEL_33;
                }
                if (v13 != 10)
                {
                  *((_QWORD *)&v58 + 1) = v11;
                  __p.__r_.__value_.__l.__size_ = size;
                  nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get_token_string(&v53, *(unsigned __int8 **)(a1 + 96), *(unsigned __int8 **)(a1 + 104));
                  v50 = *(std::string *)(a1 + 72);
                  std::string::basic_string[abi:ne180100]<0>(&v48, "array");
                  nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::exception_message(&v49, a1, 0xAu, (uint64_t)&v48);
                  nlohmann::detail::parse_error::create((nlohmann::detail::exception *)&v51, (uint64_t *)&v50, (uint64_t)&v49);
                  nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error((uint64_t)&v57, (const nlohmann::detail::type_error *)&v51);
                  goto LABEL_113;
                }
              }
              else
              {
                v14 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::scan(a1 + 40);
                *(_DWORD *)(a1 + 32) = v14;
                if (v14 == 13)
                {
                  *((_QWORD *)&v58 + 1) = v11;
                  __p.__r_.__value_.__l.__size_ = size;
                  v16 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::scan(a1 + 40);
                  *(_DWORD *)(a1 + 32) = v16;
                  if (v16 == 4)
                  {
                    v17 = *(uint64_t ***)(*(_QWORD *)(v11 - 8) + 8);
                    v51.__vftable = (std::exception_vtbl *)(a1 + 120);
                    *((_QWORD *)&v59 + 1) = std::__tree<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::__map_value_compare<std::string,std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::less<void>,true>,std::allocator<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v17, (void **)(a1 + 120), (__int128 **)&v51)+ 56;
                    v18 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::scan(a1 + 40);
                    *(_DWORD *)(a1 + 32) = v18;
                    if (v18 == 12)
                    {
                      v15 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::scan(a1 + 40);
                      goto LABEL_33;
                    }
LABEL_126:
                    nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get_token_string(&v53, *(unsigned __int8 **)(a1 + 96), *(unsigned __int8 **)(a1 + 104));
                    v50 = *(std::string *)(a1 + 72);
                    std::string::basic_string[abi:ne180100]<0>(&v48, "object separator");
                    nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::exception_message(&v49, a1, 0xCu, (uint64_t)&v48);
                    nlohmann::detail::parse_error::create((nlohmann::detail::exception *)&v51, (uint64_t *)&v50, (uint64_t)&v49);
                    nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error((uint64_t)&v57, (const nlohmann::detail::type_error *)&v51);
LABEL_113:
                    v51.__vftable = (std::exception_vtbl *)&off_1E98B6FE0;
                    std::runtime_error::~runtime_error(&v52);
                    std::exception::~exception(&v51);
LABEL_114:
                    if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(v49.__r_.__value_.__l.__data_);
                    if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(v48.__r_.__value_.__l.__data_);
                    if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(v53.__r_.__value_.__l.__data_);
                    goto LABEL_73;
                  }
LABEL_125:
                  nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get_token_string(&v53, *(unsigned __int8 **)(a1 + 96), *(unsigned __int8 **)(a1 + 104));
                  v50 = *(std::string *)(a1 + 72);
                  std::string::basic_string[abi:ne180100]<0>(&v48, "object key");
                  nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::exception_message(&v49, a1, 4u, (uint64_t)&v48);
                  nlohmann::detail::parse_error::create((nlohmann::detail::exception *)&v51, (uint64_t *)&v50, (uint64_t)&v49);
                  nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error((uint64_t)&v57, (const nlohmann::detail::type_error *)&v51);
                  goto LABEL_113;
                }
                if (v14 != 11)
                {
                  *((_QWORD *)&v58 + 1) = v11;
                  __p.__r_.__value_.__l.__size_ = size;
                  nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get_token_string(&v53, *(unsigned __int8 **)(a1 + 96), *(unsigned __int8 **)(a1 + 104));
                  v50 = *(std::string *)(a1 + 72);
                  std::string::basic_string[abi:ne180100]<0>(&v48, "object");
                  nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::exception_message(&v49, a1, 0xBu, (uint64_t)&v48);
                  nlohmann::detail::parse_error::create((nlohmann::detail::exception *)&v51, (uint64_t *)&v50, (uint64_t)&v49);
                  nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error((uint64_t)&v57, (const nlohmann::detail::type_error *)&v51);
                  goto LABEL_113;
                }
              }
              v11 -= 8;
              --size;
              if (!v12)
              {
                *((_QWORD *)&v58 + 1) = v11;
                goto LABEL_73;
              }
            }
          }
          if (v8 != 4)
            goto LABEL_125;
          v19 = *(uint64_t ***)(*(_QWORD *)(*((_QWORD *)&v58 + 1) - 8) + 8);
          v51.__vftable = (std::exception_vtbl *)(a1 + 120);
          *((_QWORD *)&v59 + 1) = std::__tree<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::__map_value_compare<std::string,std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::less<void>,true>,std::allocator<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v19, (void **)(a1 + 120), (__int128 **)&v51)+ 56;
          v20 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::scan(a1 + 40);
          *(_DWORD *)(a1 + 32) = v20;
          if (v20 != 12)
            goto LABEL_126;
          LOBYTE(v51.__vftable) = 0;
          std::vector<BOOL>::push_back((uint64_t)&__p, &v51);
          v15 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::scan(a1 + 40);
LABEL_33:
          *(_DWORD *)(a1 + 32) = v15;
          break;
        case 0xE:
          nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get_token_string(&v53, *(unsigned __int8 **)(a1 + 96), *(unsigned __int8 **)(a1 + 104));
          v50 = *(std::string *)(a1 + 72);
          std::string::basic_string[abi:ne180100]<0>(&v48, "value");
          nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::exception_message(&v49, a1, 0, (uint64_t)&v48);
          nlohmann::detail::parse_error::create((nlohmann::detail::exception *)&v51, (uint64_t *)&v50, (uint64_t)&v49);
          nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error((uint64_t)&v57, (const nlohmann::detail::type_error *)&v51);
          goto LABEL_113;
        default:
          nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get_token_string(&v53, *(unsigned __int8 **)(a1 + 96), *(unsigned __int8 **)(a1 + 104));
          v50 = *(std::string *)(a1 + 72);
          std::string::basic_string[abi:ne180100]<0>(&v48, "value");
          nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::exception_message(&v49, a1, 0x10u, (uint64_t)&v48);
          nlohmann::detail::parse_error::create((nlohmann::detail::exception *)&v51, (uint64_t *)&v50, (uint64_t)&v49);
          nlohmann::detail::json_sax_dom_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error((uint64_t)&v57, (const nlohmann::detail::type_error *)&v51);
          goto LABEL_113;
      }
    }
  }
  std::__function::__value_func<void ()(applesauce::iokit::io_object_holder)>::__value_func[abi:ne180100]((uint64_t)v55, a1);
  nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::json_sax_dom_callback_parser((uint64_t)&v57, (uint64_t)a2, (uint64_t)v55, *(_BYTE *)(a1 + 184));
  v4 = v56;
  if (v56 == v55)
  {
    v5 = 4;
    v4 = v55;
    goto LABEL_38;
  }
  if (v56)
  {
    v5 = 5;
LABEL_38:
    (*(void (**)(void))(*v4 + 8 * v5))();
  }
  memset(&__p, 0, sizeof(__p));
  while (2)
  {
    v21 = 0;
    switch(*(_DWORD *)(a1 + 32))
    {
      case 1:
        v21 = 1;
        goto LABEL_42;
      case 2:
LABEL_42:
        nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<BOOL &>(&v57, v21);
        goto LABEL_53;
      case 3:
        nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<decltype(nullptr)>(&v57);
        goto LABEL_53;
      case 4:
        nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<std::string&>(&v57, a1 + 120);
        goto LABEL_53;
      case 5:
        nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<unsigned long long &>(&v57, *(uint64_t **)(a1 + 160));
        goto LABEL_53;
      case 6:
        nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<long long &>(&v57, *(uint64_t **)(a1 + 152));
        goto LABEL_53;
      case 7:
        if ((*(_QWORD *)(a1 + 168) & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000)
        {
          nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::handle_value<double &>(&v57, *(double *)(a1 + 168));
          goto LABEL_53;
        }
        nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get_token_string(&v53, *(unsigned __int8 **)(a1 + 96), *(unsigned __int8 **)(a1 + 104));
        nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get_token_string(&v48, *(unsigned __int8 **)(a1 + 96), *(unsigned __int8 **)(a1 + 104));
        std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&v49, "number overflow parsing '", &v48);
        std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&v50, &v49, "'");
        nlohmann::detail::out_of_range::create((nlohmann::detail::exception *)&v51, (uint64_t)&v50);
        nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error((uint64_t)&v57, (const nlohmann::detail::type_error *)&v51);
        v51.__vftable = (std::exception_vtbl *)&off_1E98B6FE0;
        std::runtime_error::~runtime_error(&v52);
        std::exception::~exception(&v51);
        if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v50.__r_.__value_.__l.__data_);
        goto LABEL_89;
      case 8:
        nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::start_array((uint64_t *)&v57);
        v22 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::scan(a1 + 40);
        *(_DWORD *)(a1 + 32) = v22;
        if (v22 == 10)
        {
          nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::end_array(&v57);
          goto LABEL_53;
        }
        LOBYTE(v51.__vftable) = 1;
        std::vector<BOOL>::push_back((uint64_t)&__p, &v51);
        continue;
      case 9:
        nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::start_object((uint64_t *)&v57);
        v23 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::scan(a1 + 40);
        *(_DWORD *)(a1 + 32) = v23;
        if (v23 != 11)
        {
          if (v23 != 4)
            goto LABEL_122;
          nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::key(&v57, (__int128 *)(a1 + 120));
          v32 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::scan(a1 + 40);
          *(_DWORD *)(a1 + 32) = v32;
          if (v32 != 12)
            goto LABEL_123;
          LOBYTE(v51.__vftable) = 0;
          std::vector<BOOL>::push_back((uint64_t)&__p, &v51);
          v29 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::scan(a1 + 40);
LABEL_68:
          *(_DWORD *)(a1 + 32) = v29;
          continue;
        }
        nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::end_object(&v57);
LABEL_53:
        v24 = __p.__r_.__value_.__l.__size_;
        if (!__p.__r_.__value_.__l.__size_)
          goto LABEL_95;
        v25 = __p.__r_.__value_.__r.__words[0];
        while (2)
        {
          v26 = v24 - 1;
          if (((*(_QWORD *)(v25 + (((v24 - 1) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v24 - 1)) & 1) != 0)
          {
            v27 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::scan(a1 + 40);
            *(_DWORD *)(a1 + 32) = v27;
            if (v27 == 13)
            {
              __p.__r_.__value_.__l.__size_ = v24;
              v29 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::scan(a1 + 40);
              goto LABEL_68;
            }
            if (v27 != 10)
            {
              __p.__r_.__value_.__l.__size_ = v24;
              nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get_token_string(&v53, *(unsigned __int8 **)(a1 + 96), *(unsigned __int8 **)(a1 + 104));
              v50 = *(std::string *)(a1 + 72);
              std::string::basic_string[abi:ne180100]<0>(&v48, "array");
              nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::exception_message(&v49, a1, 0xAu, (uint64_t)&v48);
              nlohmann::detail::parse_error::create((nlohmann::detail::exception *)&v51, (uint64_t *)&v50, (uint64_t)&v49);
              nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error((uint64_t)&v57, (const nlohmann::detail::type_error *)&v51);
              goto LABEL_88;
            }
            nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::end_array(&v57);
            goto LABEL_62;
          }
          v28 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::scan(a1 + 40);
          *(_DWORD *)(a1 + 32) = v28;
          if (v28 != 13)
          {
            if (v28 != 11)
            {
              __p.__r_.__value_.__l.__size_ = v24;
              nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get_token_string(&v53, *(unsigned __int8 **)(a1 + 96), *(unsigned __int8 **)(a1 + 104));
              v50 = *(std::string *)(a1 + 72);
              std::string::basic_string[abi:ne180100]<0>(&v48, "object");
              nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::exception_message(&v49, a1, 0xBu, (uint64_t)&v48);
              nlohmann::detail::parse_error::create((nlohmann::detail::exception *)&v51, (uint64_t *)&v50, (uint64_t)&v49);
              nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error((uint64_t)&v57, (const nlohmann::detail::type_error *)&v51);
              goto LABEL_88;
            }
            nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::end_object(&v57);
LABEL_62:
            --v24;
            if (!v26)
              goto LABEL_95;
            continue;
          }
          break;
        }
        __p.__r_.__value_.__l.__size_ = v24;
        v30 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::scan(a1 + 40);
        *(_DWORD *)(a1 + 32) = v30;
        if (v30 != 4)
        {
LABEL_122:
          nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get_token_string(&v53, *(unsigned __int8 **)(a1 + 96), *(unsigned __int8 **)(a1 + 104));
          v50 = *(std::string *)(a1 + 72);
          std::string::basic_string[abi:ne180100]<0>(&v48, "object key");
          nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::exception_message(&v49, a1, 4u, (uint64_t)&v48);
          nlohmann::detail::parse_error::create((nlohmann::detail::exception *)&v51, (uint64_t *)&v50, (uint64_t)&v49);
          nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error((uint64_t)&v57, (const nlohmann::detail::type_error *)&v51);
          goto LABEL_88;
        }
        nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::key(&v57, (__int128 *)(a1 + 120));
        v31 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::scan(a1 + 40);
        *(_DWORD *)(a1 + 32) = v31;
        if (v31 == 12)
        {
          v29 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::scan(a1 + 40);
          goto LABEL_68;
        }
LABEL_123:
        nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get_token_string(&v53, *(unsigned __int8 **)(a1 + 96), *(unsigned __int8 **)(a1 + 104));
        v50 = *(std::string *)(a1 + 72);
        std::string::basic_string[abi:ne180100]<0>(&v48, "object separator");
        nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::exception_message(&v49, a1, 0xCu, (uint64_t)&v48);
        nlohmann::detail::parse_error::create((nlohmann::detail::exception *)&v51, (uint64_t *)&v50, (uint64_t)&v49);
        nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error((uint64_t)&v57, (const nlohmann::detail::type_error *)&v51);
LABEL_88:
        v51.__vftable = (std::exception_vtbl *)&off_1E98B6FE0;
        std::runtime_error::~runtime_error(&v52);
        std::exception::~exception(&v51);
LABEL_89:
        if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v49.__r_.__value_.__l.__data_);
        if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v48.__r_.__value_.__l.__data_);
        if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v53.__r_.__value_.__l.__data_);
LABEL_95:
        if (__p.__r_.__value_.__r.__words[0])
          operator delete(__p.__r_.__value_.__l.__data_);
        nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)a2);
        v36 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::scan(a1 + 40);
        *(_DWORD *)(a1 + 32) = v36;
        if (v36 != 15)
        {
          nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get_token_string(&__p, *(unsigned __int8 **)(a1 + 96), *(unsigned __int8 **)(a1 + 104));
          v53 = *(std::string *)(a1 + 72);
          std::string::basic_string[abi:ne180100]<0>(&v49, "value");
          nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::exception_message(&v50, a1, 0xFu, (uint64_t)&v49);
          nlohmann::detail::parse_error::create((nlohmann::detail::exception *)&v51, (uint64_t *)&v53, (uint64_t)&v50);
          nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error((uint64_t)&v57, (const nlohmann::detail::type_error *)&v51);
          v51.__vftable = (std::exception_vtbl *)&off_1E98B6FE0;
          std::runtime_error::~runtime_error(&v52);
          std::exception::~exception(&v51);
          if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v50.__r_.__value_.__l.__data_);
          if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v49.__r_.__value_.__l.__data_);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
            operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (v62)
        {
          v46[0] = 9;
          v37 = (uint64_t **)&v47;
          v47 = 0;
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v46);
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v46);
          v38 = *a2;
          *a2 = 9;
          v46[0] = v38;
          v39 = *((_QWORD *)a2 + 1);
          *((_QWORD *)a2 + 1) = 0;
          v47 = v39;
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)a2);
          v40 = v46;
          goto LABEL_108;
        }
        if (*a2 == 9)
        {
          v44[0] = 0;
          v37 = (uint64_t **)&v45;
          v45 = 0;
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v44);
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v44);
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v44);
          v38 = *a2;
          *a2 = 0;
          v44[0] = v38;
          v41 = *((_QWORD *)a2 + 1);
          *((_QWORD *)a2 + 1) = 0;
          v45 = v41;
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)a2);
          v40 = v44;
LABEL_108:
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v40);
          nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(v37, v38);
        }
        nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::~json_sax_dom_callback_parser((uint64_t)&v57);
        return;
      case 0xE:
        nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get_token_string(&v53, *(unsigned __int8 **)(a1 + 96), *(unsigned __int8 **)(a1 + 104));
        v50 = *(std::string *)(a1 + 72);
        std::string::basic_string[abi:ne180100]<0>(&v48, "value");
        nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::exception_message(&v49, a1, 0, (uint64_t)&v48);
        nlohmann::detail::parse_error::create((nlohmann::detail::exception *)&v51, (uint64_t *)&v50, (uint64_t)&v49);
        nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error((uint64_t)&v57, (const nlohmann::detail::type_error *)&v51);
        goto LABEL_88;
      default:
        nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get_token_string(&v53, *(unsigned __int8 **)(a1 + 96), *(unsigned __int8 **)(a1 + 104));
        v50 = *(std::string *)(a1 + 72);
        std::string::basic_string[abi:ne180100]<0>(&v48, "value");
        nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::exception_message(&v49, a1, 0x10u, (uint64_t)&v48);
        nlohmann::detail::parse_error::create((nlohmann::detail::exception *)&v51, (uint64_t *)&v50, (uint64_t)&v49);
        nlohmann::detail::json_sax_dom_callback_parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>::parse_error((uint64_t)&v57, (const nlohmann::detail::type_error *)&v51);
        goto LABEL_88;
    }
  }
}

void sub_1D4EEB25C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,std::exception a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,char a50,uint64_t a51,uint64_t a52,uint64_t a53,char a54,void *a55)
{
  std::runtime_error *v55;

  a33.__vftable = (std::exception_vtbl *)&off_1E98B6FE0;
  std::runtime_error::~runtime_error(v55 + 1);
  std::exception::~exception(&a33);
  if (a26 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  if (a43 < 0)
    operator delete(a38);
  if (a44)
    operator delete(a44);
  if (a55)
    operator delete(a55);
  _Unwind_Resume(a1);
}

uint64_t nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::~lexer(uint64_t a1)
{
  void *v2;

  if (*(char *)(a1 + 103) < 0)
    operator delete(*(void **)(a1 + 80));
  v2 = *(void **)(a1 + 56);
  if (v2)
  {
    *(_QWORD *)(a1 + 64) = v2;
    operator delete(v2);
  }
  return a1;
}

_QWORD *nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::~parser(_QWORD *a1)
{
  _QWORD *v2;
  uint64_t v3;

  nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::~lexer((uint64_t)(a1 + 5));
  v2 = (_QWORD *)a1[3];
  if (v2 == a1)
  {
    v3 = 4;
    v2 = a1;
    goto LABEL_5;
  }
  if (v2)
  {
    v3 = 5;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }
  return a1;
}

uint64_t nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::scan(uint64_t a1)
{
  const char *v2;
  uint64_t v3;
  uint64_t result;
  uint64_t v6;
  std::string *v7;
  int v8;
  std::string *v9;
  uint64_t v10;
  uint64_t v11;
  std::string *v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  char byte_in_range;
  uint64_t v17;
  unsigned int codepoint;
  unsigned int v19;
  char v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  const char **v24;
  const char *v25;
  uint64_t v26;
  const char **v27;
  const char *v28;
  unint64_t v29;
  uint64_t v30;
  const char **v31;
  const char *v32;
  uint64_t v33;
  uint64_t v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)(a1 + 32))
  {
    if (nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get((int64x2_t *)a1) != 239)
    {
      nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::unget(a1);
      goto LABEL_7;
    }
    if (nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get((int64x2_t *)a1) != 187
      || nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get((int64x2_t *)a1) != 191)
    {
      v2 = "invalid BOM; must be 0xEF 0xBB 0xBF if given";
      goto LABEL_127;
    }
  }
  do
  {
LABEL_7:
    while (2)
    {
      nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get((int64x2_t *)a1);
      v3 = *(_QWORD *)(a1 + 16);
      if (v3 > 31)
      {
        if (v3 > 90)
        {
          if (v3 <= 109)
          {
            switch(v3)
            {
              case '[':
                return 8;
              case ']':
                return 10;
              case 'f':
                return nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::scan_literal((int64x2_t *)a1, "false", 5, 2);
              default:
                goto LABEL_124;
            }
          }
          else if (v3 > 122)
          {
            if (v3 == 123)
            {
              return 9;
            }
            else
            {
              if (v3 != 125)
                goto LABEL_124;
              return 11;
            }
          }
          else if (v3 == 110)
          {
            LODWORD(v35) = 1819047278;
            return nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::scan_literal((int64x2_t *)a1, (unsigned __int8 *)&v35, 4, 3);
          }
          else
          {
            if (v3 != 116)
              goto LABEL_124;
            LODWORD(v35) = 1702195828;
            return nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::scan_literal((int64x2_t *)a1, (unsigned __int8 *)&v35, 4, 1);
          }
        }
        switch(v3)
        {
          case ' ':
            continue;
          case '"':
            nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::reset(a1);
            if (*(_QWORD *)(a1 + 16) != 34)
              __assert_rtn("scan_string", "lexer.hpp", 250, "current == '\\\"'");
            while (2)
            {
              v14 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get((int64x2_t *)a1)
                  + 1;
              result = 4;
              v2 = "invalid string: missing closing quote";
              switch(v14)
              {
                case 0:
                  goto LABEL_127;
                case 1:
                  v2 = "invalid string: control character U+0000 (NUL) must be escaped to \\u0000";
                  goto LABEL_127;
                case 2:
                  v2 = "invalid string: control character U+0001 (SOH) must be escaped to \\u0001";
                  goto LABEL_127;
                case 3:
                  v2 = "invalid string: control character U+0002 (STX) must be escaped to \\u0002";
                  goto LABEL_127;
                case 4:
                  v2 = "invalid string: control character U+0003 (ETX) must be escaped to \\u0003";
                  goto LABEL_127;
                case 5:
                  v2 = "invalid string: control character U+0004 (EOT) must be escaped to \\u0004";
                  goto LABEL_127;
                case 6:
                  v2 = "invalid string: control character U+0005 (ENQ) must be escaped to \\u0005";
                  goto LABEL_127;
                case 7:
                  v2 = "invalid string: control character U+0006 (ACK) must be escaped to \\u0006";
                  goto LABEL_127;
                case 8:
                  v2 = "invalid string: control character U+0007 (BEL) must be escaped to \\u0007";
                  goto LABEL_127;
                case 9:
                  v2 = "invalid string: control character U+0008 (BS) must be escaped to \\u0008 or \\b";
                  goto LABEL_127;
                case 10:
                  v2 = "invalid string: control character U+0009 (HT) must be escaped to \\u0009 or \\t";
                  goto LABEL_127;
                case 11:
                  v2 = "invalid string: control character U+000A (LF) must be escaped to \\u000A or \\n";
                  goto LABEL_127;
                case 12:
                  v2 = "invalid string: control character U+000B (VT) must be escaped to \\u000B";
                  goto LABEL_127;
                case 13:
                  v2 = "invalid string: control character U+000C (FF) must be escaped to \\u000C or \\f";
                  goto LABEL_127;
                case 14:
                  v2 = "invalid string: control character U+000D (CR) must be escaped to \\u000D or \\r";
                  goto LABEL_127;
                case 15:
                  v2 = "invalid string: control character U+000E (SO) must be escaped to \\u000E";
                  goto LABEL_127;
                case 16:
                  v2 = "invalid string: control character U+000F (SI) must be escaped to \\u000F";
                  goto LABEL_127;
                case 17:
                  v2 = "invalid string: control character U+0010 (DLE) must be escaped to \\u0010";
                  goto LABEL_127;
                case 18:
                  v2 = "invalid string: control character U+0011 (DC1) must be escaped to \\u0011";
                  goto LABEL_127;
                case 19:
                  v2 = "invalid string: control character U+0012 (DC2) must be escaped to \\u0012";
                  goto LABEL_127;
                case 20:
                  v2 = "invalid string: control character U+0013 (DC3) must be escaped to \\u0013";
                  goto LABEL_127;
                case 21:
                  v2 = "invalid string: control character U+0014 (DC4) must be escaped to \\u0014";
                  goto LABEL_127;
                case 22:
                  v2 = "invalid string: control character U+0015 (NAK) must be escaped to \\u0015";
                  goto LABEL_127;
                case 23:
                  v2 = "invalid string: control character U+0016 (SYN) must be escaped to \\u0016";
                  goto LABEL_127;
                case 24:
                  v2 = "invalid string: control character U+0017 (ETB) must be escaped to \\u0017";
                  goto LABEL_127;
                case 25:
                  v2 = "invalid string: control character U+0018 (CAN) must be escaped to \\u0018";
                  goto LABEL_127;
                case 26:
                  v2 = "invalid string: control character U+0019 (EM) must be escaped to \\u0019";
                  goto LABEL_127;
                case 27:
                  v2 = "invalid string: control character U+001A (SUB) must be escaped to \\u001A";
                  goto LABEL_127;
                case 28:
                  v2 = "invalid string: control character U+001B (ESC) must be escaped to \\u001B";
                  goto LABEL_127;
                case 29:
                  v2 = "invalid string: control character U+001C (FS) must be escaped to \\u001C";
                  goto LABEL_127;
                case 30:
                  v2 = "invalid string: control character U+001D (GS) must be escaped to \\u001D";
                  goto LABEL_127;
                case 31:
                  v2 = "invalid string: control character U+001E (RS) must be escaped to \\u001E";
                  goto LABEL_127;
                case 32:
                  v2 = "invalid string: control character U+001F (US) must be escaped to \\u001F";
                  goto LABEL_127;
                case 33:
                case 34:
                case 36:
                case 37:
                case 38:
                case 39:
                case 40:
                case 41:
                case 42:
                case 43:
                case 44:
                case 45:
                case 46:
                case 47:
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                case 58:
                case 59:
                case 60:
                case 61:
                case 62:
                case 63:
                case 64:
                case 65:
                case 66:
                case 67:
                case 68:
                case 69:
                case 70:
                case 71:
                case 72:
                case 73:
                case 74:
                case 75:
                case 76:
                case 77:
                case 78:
                case 79:
                case 80:
                case 81:
                case 82:
                case 83:
                case 84:
                case 85:
                case 86:
                case 87:
                case 88:
                case 89:
                case 90:
                case 91:
                case 92:
                case 94:
                case 95:
                case 96:
                case 97:
                case 98:
                case 99:
                case 100:
                case 101:
                case 102:
                case 103:
                case 104:
                case 105:
                case 106:
                case 107:
                case 108:
                case 109:
                case 110:
                case 111:
                case 112:
                case 113:
                case 114:
                case 115:
                case 116:
                case 117:
                case 118:
                case 119:
                case 120:
                case 121:
                case 122:
                case 123:
                case 124:
                case 125:
                case 126:
                case 127:
                case 128:
                  LOBYTE(v15) = *(_BYTE *)(a1 + 16);
                  goto LABEL_53;
                case 35:
                  return result;
                case 93:
                  v17 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get((int64x2_t *)a1);
                  v2 = "invalid string: forbidden character after backslash";
                  if (v17 > 97)
                  {
                    switch(v17)
                    {
                      case 'n':
                        LOBYTE(v15) = 10;
                        break;
                      case 'o':
                      case 'p':
                      case 'q':
                      case 's':
                        goto LABEL_127;
                      case 'r':
                        LOBYTE(v15) = 13;
                        break;
                      case 't':
                        LOBYTE(v15) = 9;
                        break;
                      case 'u':
                        codepoint = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get_codepoint((int64x2_t *)a1);
                        v15 = codepoint;
                        if (codepoint == -1)
                          goto LABEL_178;
                        if ((codepoint & 0xFFFFFC00) == 0xD800)
                        {
                          if (nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get((int64x2_t *)a1) != 92
                            || nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get((int64x2_t *)a1) != 117)
                          {
                            goto LABEL_179;
                          }
                          v19 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get_codepoint((int64x2_t *)a1);
                          v20 = v19;
                          if (v19 == -1)
                          {
LABEL_178:
                            v2 = "invalid string: '\\u' must be followed by 4 hex digits";
                            goto LABEL_127;
                          }
                          if (v19 >> 10 != 55)
                          {
LABEL_179:
                            v2 = "invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF";
                            goto LABEL_127;
                          }
                          v21 = v19 + (v15 << 10) - 56613888;
                          std::string::push_back((std::string *)(a1 + 80), (v21 >> 18) | 0xF0);
                          std::string::push_back((std::string *)(a1 + 80), (v21 >> 12) & 0x3F | 0x80);
                          std::string::push_back((std::string *)(a1 + 80), (v21 >> 6) & 0x3F | 0x80);
                          LOBYTE(v15) = v20 & 0x3F | 0x80;
                        }
                        else
                        {
                          if ((codepoint & 0xFFFFFC00) == 0xDC00)
                          {
                            v2 = "invalid string: surrogate U+DC00..U+DFFF must follow U+D800..U+DBFF";
                            goto LABEL_127;
                          }
                          if (codepoint > 0x7F)
                          {
                            if (codepoint > 0x7FF)
                            {
                              std::string::push_back((std::string *)(a1 + 80), (codepoint >> 12) | 0xE0);
                              std::string::push_back((std::string *)(a1 + 80), (v15 >> 6) & 0x3F | 0x80);
                            }
                            else
                            {
                              std::string::push_back((std::string *)(a1 + 80), (codepoint >> 6) | 0xC0);
                            }
                            LOBYTE(v15) = v15 & 0x3F | 0x80;
                          }
                        }
                        break;
                      default:
                        if (v17 == 98)
                        {
                          LOBYTE(v15) = 8;
                        }
                        else
                        {
                          if (v17 != 102)
                            goto LABEL_127;
                          LOBYTE(v15) = 12;
                        }
                        break;
                    }
                  }
                  else
                  {
                    switch(v17)
                    {
                      case '"':
                        LOBYTE(v15) = 34;
                        break;
                      case '/':
                        LOBYTE(v15) = 47;
                        break;
                      case '\\':
                        LOBYTE(v15) = 92;
                        break;
                      default:
                        goto LABEL_127;
                    }
                  }
LABEL_53:
                  std::string::push_back((std::string *)(a1 + 80), v15);
                  continue;
                case 195:
                case 196:
                case 197:
                case 198:
                case 199:
                case 200:
                case 201:
                case 202:
                case 203:
                case 204:
                case 205:
                case 206:
                case 207:
                case 208:
                case 209:
                case 210:
                case 211:
                case 212:
                case 213:
                case 214:
                case 215:
                case 216:
                case 217:
                case 218:
                case 219:
                case 220:
                case 221:
                case 222:
                case 223:
                case 224:
                  v35 = xmmword_1D4F18AB0;
                  byte_in_range = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::next_byte_in_range(a1, (unint64_t *)&v35, 2uLL);
                  goto LABEL_56;
                case 225:
                  v35 = xmmword_1D4F193E0;
                  v36 = unk_1D4F193F0;
                  byte_in_range = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::next_byte_in_range(a1, (unint64_t *)&v35, 4uLL);
                  goto LABEL_56;
                case 226:
                case 227:
                case 228:
                case 229:
                case 230:
                case 231:
                case 232:
                case 233:
                case 234:
                case 235:
                case 236:
                case 237:
                case 239:
                case 240:
                  v35 = xmmword_1D4F19400;
                  v36 = unk_1D4F19410;
                  byte_in_range = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::next_byte_in_range(a1, (unint64_t *)&v35, 4uLL);
                  goto LABEL_56;
                case 238:
                  v35 = xmmword_1D4F19420;
                  v36 = unk_1D4F19430;
                  byte_in_range = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::next_byte_in_range(a1, (unint64_t *)&v35, 4uLL);
                  goto LABEL_56;
                case 241:
                  v35 = xmmword_1D4F19440;
                  v36 = unk_1D4F19450;
                  v37 = xmmword_1D4F19460;
                  byte_in_range = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::next_byte_in_range(a1, (unint64_t *)&v35, 6uLL);
                  goto LABEL_56;
                case 242:
                case 243:
                case 244:
                  v35 = xmmword_1D4F19470;
                  v36 = unk_1D4F19480;
                  v37 = xmmword_1D4F19490;
                  byte_in_range = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::next_byte_in_range(a1, (unint64_t *)&v35, 6uLL);
                  goto LABEL_56;
                case 245:
                  v35 = xmmword_1D4F194A0;
                  v36 = unk_1D4F194B0;
                  v37 = xmmword_1D4F194C0;
                  byte_in_range = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::next_byte_in_range(a1, (unint64_t *)&v35, 6uLL);
LABEL_56:
                  if ((byte_in_range & 1) == 0)
                    return 14;
                  continue;
                default:
                  v2 = "invalid string: ill-formed UTF-8 byte";
                  goto LABEL_127;
              }
            }
          case ',':
            return 13;
          case '-':
          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::reset(a1);
            v6 = *(_QWORD *)(a1 + 16);
            if ((unint64_t)(v6 - 49) < 9)
            {
              v7 = (std::string *)(a1 + 80);
              v8 = 5;
LABEL_18:
              std::string::push_back(v7, v6);
              v9 = (std::string *)(a1 + 80);
              while (1)
              {
                v10 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get((int64x2_t *)a1);
                if ((unint64_t)(v10 - 48) >= 0xA)
                  break;
                std::string::push_back((std::string *)(a1 + 80), *(_BYTE *)(a1 + 16));
              }
              if (v10 != 46)
              {
                if (v10 == 69 || v10 == 101)
                  goto LABEL_24;
LABEL_110:
                nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::unget(a1);
                *(_QWORD *)&v35 = 0;
                *__error() = 0;
                if (v8 == 6)
                {
                  v31 = (const char **)(a1 + 80);
                  v32 = (const char *)(a1 + 80);
                  if (*(char *)(a1 + 103) < 0)
                    v32 = *v31;
                  v33 = strtoll(v32, (char **)&v35, 10);
                  if (*(char *)(a1 + 103) < 0)
                  {
                    v31 = *(const char ***)(a1 + 80);
                    v34 = *(_QWORD *)(a1 + 88);
                  }
                  else
                  {
                    v34 = *(unsigned __int8 *)(a1 + 103);
                  }
                  if ((const char **)v35 != (const char **)((char *)v31 + v34))
                    __assert_rtn("scan_number", "lexer.hpp", 1191, "endptr == token_buffer.data() + token_buffer.size()");
                  if (!*__error())
                  {
                    *(_QWORD *)(a1 + 112) = v33;
                    return 6;
                  }
                }
                else
                {
                  v27 = (const char **)(a1 + 80);
                  v28 = (const char *)(a1 + 80);
                  if (*(char *)(a1 + 103) < 0)
                    v28 = *v27;
                  v29 = strtoull(v28, (char **)&v35, 10);
                  if (*(char *)(a1 + 103) < 0)
                  {
                    v27 = *(const char ***)(a1 + 80);
                    v30 = *(_QWORD *)(a1 + 88);
                  }
                  else
                  {
                    v30 = *(unsigned __int8 *)(a1 + 103);
                  }
                  if ((const char **)v35 != (const char **)((char *)v27 + v30))
                    __assert_rtn("scan_number", "lexer.hpp", 1175, "endptr == token_buffer.data() + token_buffer.size()");
                  if (!*__error())
                  {
                    *(_QWORD *)(a1 + 120) = v29;
                    return 5;
                  }
                }
LABEL_103:
                v24 = (const char **)(a1 + 80);
                v25 = (const char *)(a1 + 80);
                if (*(char *)(a1 + 103) < 0)
                  v25 = *v24;
                *(double *)(a1 + 128) = strtod(v25, (char **)&v35);
                if (*(char *)(a1 + 103) < 0)
                {
                  v24 = *(const char ***)(a1 + 80);
                  v26 = *(_QWORD *)(a1 + 88);
                }
                else
                {
                  v26 = *(unsigned __int8 *)(a1 + 103);
                }
                if ((const char **)v35 != (const char **)((char *)v24 + v26))
                  __assert_rtn("scan_number", "lexer.hpp", 1208, "endptr == token_buffer.data() + token_buffer.size()");
                return 7;
              }
              goto LABEL_97;
            }
            if (v6 == 48)
            {
              std::string::push_back((std::string *)(a1 + 80), 48);
              v8 = 5;
            }
            else
            {
              if (v6 != 45)
                __assert_rtn("scan_number", "lexer.hpp", 928, "false");
              v7 = (std::string *)(a1 + 80);
              std::string::push_back((std::string *)(a1 + 80), 45);
              v13 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get((int64x2_t *)a1);
              if ((unint64_t)(v13 - 49) < 9)
              {
                v6 = *(_QWORD *)(a1 + 16);
                v8 = 6;
                goto LABEL_18;
              }
              if (v13 != 48)
              {
                v2 = "invalid number; expected digit after '-'";
                goto LABEL_127;
              }
              std::string::push_back((std::string *)(a1 + 80), *(_BYTE *)(a1 + 16));
              v8 = 6;
            }
            v22 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get((int64x2_t *)a1);
            if (v22 == 101 || v22 == 69)
            {
              v9 = (std::string *)(a1 + 80);
              goto LABEL_24;
            }
            if (v22 != 46)
              goto LABEL_110;
            v9 = (std::string *)(a1 + 80);
LABEL_97:
            std::string::push_back(v9, *(_BYTE *)(a1 + 136));
            if ((unint64_t)(nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get((int64x2_t *)a1)
                                  - 48) > 9)
            {
              v2 = "invalid number; expected digit after '.'";
              goto LABEL_127;
            }
            v9 = (std::string *)(a1 + 80);
            do
            {
              std::string::push_back((std::string *)(a1 + 80), *(_BYTE *)(a1 + 16));
              v23 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get((int64x2_t *)a1);
            }
            while ((unint64_t)(v23 - 48) < 0xA);
            if (v23 != 101 && v23 != 69)
            {
LABEL_102:
              nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::unget(a1);
              *(_QWORD *)&v35 = 0;
              *__error() = 0;
              goto LABEL_103;
            }
LABEL_24:
            std::string::push_back(v9, *(_BYTE *)(a1 + 16));
            v11 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get((int64x2_t *)a1);
            if ((unint64_t)(v11 - 48) >= 0xA)
            {
              if (v11 != 45 && v11 != 43)
              {
                v2 = "invalid number; expected '+', '-', or digit after exponent";
                goto LABEL_127;
              }
              v12 = (std::string *)(a1 + 80);
              std::string::push_back((std::string *)(a1 + 80), *(_BYTE *)(a1 + 16));
              if ((unint64_t)(nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get((int64x2_t *)a1)
                                    - 48) >= 0xA)
              {
                v2 = "invalid number; expected digit after exponent sign";
                goto LABEL_127;
              }
            }
            else
            {
              v12 = (std::string *)(a1 + 80);
            }
            std::string::push_back(v12, *(_BYTE *)(a1 + 16));
            while ((unint64_t)(nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get((int64x2_t *)a1)
                                     - 48) <= 9)
              std::string::push_back((std::string *)(a1 + 80), *(_BYTE *)(a1 + 16));
            goto LABEL_102;
          case ':':
            return 12;
          default:
            goto LABEL_124;
        }
      }
      break;
    }
  }
  while ((unint64_t)(v3 - 9) < 2 || v3 == 13);
  if ((unint64_t)(v3 + 1) < 2)
    return 15;
LABEL_124:
  v2 = "invalid literal";
LABEL_127:
  *(_QWORD *)(a1 + 104) = v2;
  return 14;
}

void sub_1D4EEC220(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

void nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get_token_string(std::string *this, unsigned __int8 *a2, unsigned __int8 *a3)
{
  unsigned __int8 *v4;
  unsigned int v6;
  size_t v7;
  char __str[8];
  char v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)&this->__r_.__value_.__l.__data_ = 0uLL;
  this->__r_.__value_.__r.__words[2] = 0;
  if (a2 != a3)
  {
    v4 = a2;
    do
    {
      v6 = *v4;
      if (v6 > 0x1F)
      {
        std::string::push_back(this, v6);
      }
      else
      {
        v9 = 0;
        *(_QWORD *)__str = 0;
        snprintf(__str, 9uLL, "<U+%.4X>", v6);
        v7 = strlen(__str);
        std::string::append(this, __str, v7);
      }
      ++v4;
    }
    while (v4 != a3);
  }
}

void sub_1D4EEC2FC(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void nlohmann::detail::parser<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::exception_message(std::string *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v8;
  std::string *v9;
  __int128 v10;
  const std::string::value_type *v11;
  std::string::size_type v12;
  uint64_t v13;
  std::string *v14;
  __int128 v15;
  std::string *p_p;
  std::string::size_type size;
  std::string *v18;
  __int128 v19;
  std::string *v20;
  __int128 v21;
  const std::string::value_type *v22;
  std::string::size_type v23;
  void *v24;
  char *v25;
  std::string *v26;
  __int128 v27;
  const std::string::value_type *v28;
  std::string::size_type v29;
  char *v30;
  std::string *v31;
  __int128 v32;
  const std::string::value_type *v33;
  std::string::size_type v34;
  std::string __p;
  std::string v36;
  std::string v37;
  std::string v38;
  __int128 v39;
  int64_t v40;

  std::string::basic_string[abi:ne180100]<0>(a1, "syntax error ");
  v8 = *(unsigned __int8 *)(a4 + 23);
  if ((v8 & 0x80u) != 0)
    v8 = *(_QWORD *)(a4 + 8);
  if (v8)
  {
    std::operator+<char>();
    v9 = std::string::append(&v38, " ", 1uLL);
    v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    v40 = v9->__r_.__value_.__r.__words[2];
    v39 = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    if (v40 >= 0)
      v11 = (const std::string::value_type *)&v39;
    else
      v11 = (const std::string::value_type *)v39;
    if (v40 >= 0)
      v12 = HIBYTE(v40);
    else
      v12 = *((_QWORD *)&v39 + 1);
    std::string::append(a1, v11, v12);
    if (SHIBYTE(v40) < 0)
      operator delete((void *)v39);
    if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v38.__r_.__value_.__l.__data_);
  }
  std::string::append(a1, "- ", 2uLL);
  v13 = *(int *)(a2 + 32);
  if ((_DWORD)v13 == 14)
  {
    std::string::basic_string[abi:ne180100]<0>(&v36, *(char **)(a2 + 144));
    v14 = std::string::append(&v36, "; last read: '", 0xEuLL);
    v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    v37.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v37.__r_.__value_.__l.__data_ = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get_token_string(&__p, *(unsigned __int8 **)(a2 + 96), *(unsigned __int8 **)(a2 + 104));
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_p = &__p;
    else
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    else
      size = __p.__r_.__value_.__l.__size_;
    v18 = std::string::append(&v37, (const std::string::value_type *)p_p, size);
    v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v38.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v19;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    v20 = std::string::append(&v38, "'", 1uLL);
    v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
    v40 = v20->__r_.__value_.__r.__words[2];
    v39 = v21;
    v20->__r_.__value_.__l.__size_ = 0;
    v20->__r_.__value_.__r.__words[2] = 0;
    v20->__r_.__value_.__r.__words[0] = 0;
    if (v40 >= 0)
      v22 = (const std::string::value_type *)&v39;
    else
      v22 = (const std::string::value_type *)v39;
    if (v40 >= 0)
      v23 = HIBYTE(v40);
    else
      v23 = *((_QWORD *)&v39 + 1);
    std::string::append(a1, v22, v23);
    if (SHIBYTE(v40) < 0)
      operator delete((void *)v39);
    if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v38.__r_.__value_.__l.__data_);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v37.__r_.__value_.__l.__data_);
    if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0)
    {
      v24 = (void *)v36.__r_.__value_.__r.__words[0];
      goto LABEL_52;
    }
LABEL_49:
    if (!a3)
      return;
    goto LABEL_53;
  }
  if (v13 > 0x10)
    v25 = "unknown token";
  else
    v25 = off_1E98BA3B8[v13];
  std::string::basic_string[abi:ne180100]<0>(&v38, v25);
  v26 = std::string::insert(&v38, 0, "unexpected ", 0xBuLL);
  v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
  v40 = v26->__r_.__value_.__r.__words[2];
  v39 = v27;
  v26->__r_.__value_.__l.__size_ = 0;
  v26->__r_.__value_.__r.__words[2] = 0;
  v26->__r_.__value_.__r.__words[0] = 0;
  if (v40 >= 0)
    v28 = (const std::string::value_type *)&v39;
  else
    v28 = (const std::string::value_type *)v39;
  if (v40 >= 0)
    v29 = HIBYTE(v40);
  else
    v29 = *((_QWORD *)&v39 + 1);
  std::string::append(a1, v28, v29);
  if (SHIBYTE(v40) < 0)
    operator delete((void *)v39);
  if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    goto LABEL_49;
  v24 = (void *)v38.__r_.__value_.__r.__words[0];
LABEL_52:
  operator delete(v24);
  if (!a3)
    return;
LABEL_53:
  if (a3 > 0x10)
    v30 = "unknown token";
  else
    v30 = off_1E98BA3B8[a3];
  std::string::basic_string[abi:ne180100]<0>(&v38, v30);
  v31 = std::string::insert(&v38, 0, "; expected ", 0xBuLL);
  v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
  v40 = v31->__r_.__value_.__r.__words[2];
  v39 = v32;
  v31->__r_.__value_.__l.__size_ = 0;
  v31->__r_.__value_.__r.__words[2] = 0;
  v31->__r_.__value_.__r.__words[0] = 0;
  if (v40 >= 0)
    v33 = (const std::string::value_type *)&v39;
  else
    v33 = (const std::string::value_type *)v39;
  if (v40 >= 0)
    v34 = HIBYTE(v40);
  else
    v34 = *((_QWORD *)&v39 + 1);
  std::string::append(a1, v33, v34);
  if (SHIBYTE(v40) < 0)
    operator delete((void *)v39);
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v38.__r_.__value_.__l.__data_);
}

void sub_1D4EEC680(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  uint64_t v33;
  uint64_t v34;

  if (*(char *)(v34 - 41) < 0)
    operator delete(*(void **)(v34 - 64));
  if (a33 < 0)
    operator delete(__p);
  if (a14 < 0)
    operator delete(a9);
  if (a26 < 0)
    operator delete(a21);
  if (a20 < 0)
    operator delete(a15);
  if (*(char *)(v33 + 23) < 0)
    operator delete(*(void **)v33);
  _Unwind_Resume(exception_object);
}

uint64_t nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get(int64x2_t *a1)
{
  uint64_t v2;
  unsigned __int8 *v3;
  unint64_t v4;
  _BYTE *v5;
  uint64_t v6;
  unint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  unint64_t v10;
  size_t v11;
  uint64_t v12;
  char *v13;
  _BYTE *v14;
  char v15;
  uint64_t result;
  uint64_t v17;

  a1[2] = vaddq_s64(a1[2], vdupq_n_s64(1uLL));
  if (a1[1].i8[8])
  {
    a1[1].i8[8] = 0;
    v2 = a1[1].i64[0];
  }
  else
  {
    v3 = (unsigned __int8 *)a1->i64[0];
    if (a1->i64[0] == a1->i64[1])
    {
      v2 = -1;
    }
    else
    {
      v2 = *v3;
      a1->i64[0] = (uint64_t)(v3 + 1);
    }
    a1[1].i64[0] = v2;
  }
  if (v2 == -1)
    return -1;
  v5 = (_BYTE *)a1[4].i64[0];
  v4 = a1[4].u64[1];
  if ((unint64_t)v5 >= v4)
  {
    v7 = a1[3].u64[1];
    v8 = &v5[-v7];
    v9 = (uint64_t)&v5[-v7 + 1];
    if (v9 < 0)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v10 = v4 - v7;
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x3FFFFFFFFFFFFFFFLL)
      v11 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v11 = v9;
    if (v11)
      v12 = (uint64_t)operator new(v11);
    else
      v12 = 0;
    v13 = (char *)(v12 + v11);
    v8[v12] = v2;
    v6 = (uint64_t)&v8[v12 + 1];
    if (v5 == (_BYTE *)v7)
    {
      v12 += (uint64_t)v8;
    }
    else
    {
      v14 = &v5[~v7];
      do
      {
        v15 = *--v5;
        (v14--)[v12] = v15;
      }
      while (v5 != (_BYTE *)v7);
      v5 = (_BYTE *)a1[3].i64[1];
    }
    a1[3].i64[1] = v12;
    a1[4].i64[0] = v6;
    a1[4].i64[1] = (uint64_t)v13;
    if (v5)
      operator delete(v5);
  }
  else
  {
    *v5 = v2;
    v6 = (uint64_t)(v5 + 1);
  }
  a1[4].i64[0] = v6;
  result = a1[1].i64[0];
  if (result == 10)
  {
    v17 = a1[3].i64[0] + 1;
    a1[2].i64[1] = 0;
    a1[3].i64[0] = v17;
  }
  return result;
}

uint64_t nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::scan_literal(int64x2_t *a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4)
{
  unsigned __int8 *v6;
  uint64_t v7;
  unsigned __int8 v8;
  int v9;

  if (*a2 != a1[1].u8[0])
    __assert_rtn("scan_literal", "lexer.hpp", 1222, "char_traits<char_type>::to_char_type(current) == literal_text[0]");
  v6 = a2 + 1;
  v7 = a3 - 1;
  while (1)
  {
    v8 = nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get(a1);
    v9 = *v6++;
    if (v9 != v8)
      break;
    if (!--v7)
      return a4;
  }
  a1[6].i64[1] = (uint64_t)"invalid literal";
  return 14;
}

void nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::reset(uint64_t a1)
{
  _BYTE *v2;
  char v3;
  unint64_t v4;
  _BYTE *v5;
  unint64_t v6;
  uint64_t v7;
  size_t v8;
  _BYTE *v9;

  if (*(char *)(a1 + 103) < 0)
  {
    **(_BYTE **)(a1 + 80) = 0;
    *(_QWORD *)(a1 + 88) = 0;
  }
  else
  {
    *(_BYTE *)(a1 + 80) = 0;
    *(_BYTE *)(a1 + 103) = 0;
  }
  v2 = *(_BYTE **)(a1 + 56);
  *(_QWORD *)(a1 + 64) = v2;
  v3 = *(_BYTE *)(a1 + 16);
  v4 = *(_QWORD *)(a1 + 72);
  if ((unint64_t)v2 >= v4)
  {
    v6 = v4 - (_QWORD)v2;
    v7 = 2 * v6;
    if (2 * v6 <= 1)
      v7 = 1;
    if (v6 >= 0x3FFFFFFFFFFFFFFFLL)
      v8 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v8 = v7;
    v9 = operator new(v8);
    *v9 = v3;
    v5 = v9 + 1;
    *(_QWORD *)(a1 + 56) = v9;
    *(_QWORD *)(a1 + 64) = v9 + 1;
    *(_QWORD *)(a1 + 72) = &v9[v8];
    if (v2)
      operator delete(v2);
  }
  else
  {
    *v2 = v3;
    v5 = v2 + 1;
  }
  *(_QWORD *)(a1 + 64) = v5;
}

uint64_t nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::unget(uint64_t result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  v1 = (_QWORD *)(result + 40);
  v2 = *(_QWORD *)(result + 40);
  *(_BYTE *)(result + 24) = 1;
  --*(_QWORD *)(result + 32);
  if (v2 || (v1 = (_QWORD *)(result + 48), (v2 = *(_QWORD *)(result + 48)) != 0))
    *v1 = v2 - 1;
  if (*(_QWORD *)(result + 16) != -1)
  {
    v3 = *(_QWORD *)(result + 64);
    if (*(_QWORD *)(result + 56) == v3)
      __assert_rtn("unget", "lexer.hpp", 1314, "not token_string.empty()");
    *(_QWORD *)(result + 64) = v3 - 1;
  }
  return result;
}

uint64_t nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get_codepoint(int64x2_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  int v6;
  __int128 v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (a1[1].i64[0] != 117)
    __assert_rtn("get_codepoint", "lexer.hpp", 162, "current == 'u'");
  v2 = 0;
  LODWORD(v3) = 0;
  v8 = xmmword_1D4F18A90;
  do
  {
    v4 = *(_DWORD *)((char *)&v8 + v2);
    nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get(a1);
    v5 = a1[1].i64[0];
    if ((unint64_t)(v5 - 48) >= 0xA)
    {
      if ((unint64_t)(v5 - 65) >= 6)
      {
        if ((unint64_t)(v5 - 97) > 5)
          return 0xFFFFFFFFLL;
        v6 = -87;
      }
      else
      {
        v6 = -55;
      }
    }
    else
    {
      v6 = -48;
    }
    v3 = (((v6 + (_DWORD)v5) << v4) + v3);
    v2 += 4;
  }
  while (v2 != 16);
  if (v3 >= 0x10000)
    __assert_rtn("get_codepoint", "lexer.hpp", 188, "0x0000 <= codepoint and codepoint <= 0xFFFF");
  return v3;
}

uint64_t nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::next_byte_in_range(uint64_t a1, unint64_t *a2, unint64_t a3)
{
  std::string *v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t result;

  if (a3 > 6 || ((1 << a3) & 0x54) == 0)
    __assert_rtn("next_byte_in_range", "lexer.hpp", 209, "ranges.size() == 2 or ranges.size() == 4 or ranges.size() == 6");
  v6 = (std::string *)(a1 + 80);
  std::string::push_back((std::string *)(a1 + 80), *(_BYTE *)(a1 + 16));
  v7 = &a2[a3];
  while (1)
  {
    nlohmann::detail::lexer<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>,nlohmann::detail::iterator_input_adapter<unsigned char const*>>::get((int64x2_t *)a1);
    v8 = *(_QWORD *)(a1 + 16);
    if (*a2 > v8 || v8 > a2[1])
      break;
    std::string::push_back(v6, v8);
    a2 += 2;
    if (a2 == v7)
      return 1;
  }
  result = 0;
  *(_QWORD *)(a1 + 104) = "invalid string: ill-formed UTF-8 byte";
  return result;
}

void MIDICI::Device::handleGetProperty(_QWORD *a1, uint64_t *a2)
{
  unsigned __int8 *v3;
  unint64_t v4;
  unsigned __int8 v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t *v16;
  char v17;
  uint64_t *v18;
  BOOL v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  __int16 v31;
  uint64_t v32;
  unsigned __int8 *v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  __int128 *v40;
  uint64_t v41;
  uint64_t v42;
  std::string::size_type v43;
  const char *v44;
  int v45;
  const char *v46;
  const char *v47;
  nlohmann::detail::exception *exception;
  unint64_t v49;
  char *v50;
  std::string *v51;
  __int128 v52;
  _BYTE v53[8];
  uint64_t *v54;
  _BYTE v55[8];
  uint64_t *v56;
  std::string v57;
  __int128 v58;
  std::string::size_type v59;
  __int128 *v60;
  _BYTE v61[24];
  _BYTE *v62;
  uint64_t v63;

  v63 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v3 = *(unsigned __int8 **)(*a2 + 8);
    v4 = *(_QWORD *)(*a2 + 16) - (_QWORD)v3;
    if (v4 <= 0xB)
      __assert_rtn("make_uint28", "sysex.h", 249, "data_pos + 3 < data.size()");
    v6 = v3[12];
    v7 = v3[8] | (v3[9] << 7) | (v3[10] << 14) | (v3[11] << 21);
    v8 = std::__tree<std::__value_type<std::pair<unsigned int,unsigned char>,PropertyExchange::Request>,std::__map_value_compare<std::pair<unsigned int,unsigned char>,std::__value_type<std::pair<unsigned int,unsigned char>,PropertyExchange::Request>,std::less<std::pair<unsigned int,unsigned char>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,unsigned char>,PropertyExchange::Request>>>::find<std::pair<unsigned int,unsigned char>>((uint64_t)a1, v7, v6);
    if (a1 + 1 != (_QWORD *)v8)
    {
      if (v4 <= 0xE)
        __assert_rtn("make_uint14", "sysex.h", 232, "data_pos + 1 < data.size()");
      v9 = v8;
      v10 = (uint64_t)&v3[(v3[13] | ((unint64_t)v3[14] << 7)) + 15];
      v62 = 0;
      nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::parse<char const*>((uint64_t)v55, (uint64_t)(v3 + 15), v10, (uint64_t)v61);
      v11 = v62;
      if (v62 == v61)
      {
        v12 = 4;
        v11 = v61;
      }
      else
      {
        if (!v62)
          goto LABEL_10;
        v12 = 5;
      }
      (*(void (**)(void))(*v11 + 8 * v12))();
LABEL_10:
      if (v55[0] != 1)
        goto LABEL_25;
      v13 = v56;
      v14 = v56 + 1;
      v15 = v56[1];
      if (!v15)
        goto LABEL_25;
      v16 = v56 + 1;
      do
      {
        v17 = std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((const void **)(v15 + 32), "status");
        if (v17 >= 0)
          v18 = (uint64_t *)v15;
        else
          v18 = (uint64_t *)(v15 + 8);
        if (v17 >= 0)
          v16 = (uint64_t *)v15;
        v15 = *v18;
      }
      while (*v18);
      if (v16 == v14
        || ((int)(std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>((const void **)v16 + 4, "status") << 24) <= 0? (v19 = v14 == v16): (v19 = 1), v19))
      {
LABEL_25:
        LODWORD(v58) = 2;
        LOBYTE(v59) = 0;
        v20 = *(_QWORD *)(v9 + 96);
        if (!v20)
          std::__throw_bad_function_call[abi:ne180100]();
        goto LABEL_26;
      }
      v21 = std::__tree<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::__map_value_compare<std::string,std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>,std::less<void>,true>,std::allocator<std::__value_type<std::string,nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>>::find<char const*>((uint64_t)v13, "status");
      if (v14 == (uint64_t *)v21)
      {
        v44 = "m_value.object->find(key) != m_value.object->end()";
        v45 = 3713;
        v46 = "json.hpp";
        v47 = "operator[]";
        goto LABEL_68;
      }
      v22 = v21;
      switch(*(_BYTE *)(v21 + 56))
      {
        case 4:
          goto LABEL_46;
        case 5:
        case 6:
          v23 = *(_DWORD *)(v21 + 64);
          goto LABEL_33;
        case 7:
          v23 = (int)*(double *)(v21 + 64);
LABEL_33:
          if (v23 != 200)
          {
LABEL_46:
            LODWORD(v58) = 2;
            LOBYTE(v59) = 0;
            v20 = *(_QWORD *)(v9 + 96);
            if (!v20)
              std::__throw_bad_function_call[abi:ne180100]();
LABEL_26:
            (*(void (**)(uint64_t, __int128 *))(*(_QWORD *)v20 + 48))(v20, &v58);
            std::__tree<std::__value_type<std::pair<unsigned int,unsigned char>,PropertyExchange::Request>,std::__map_value_compare<std::pair<unsigned int,unsigned char>,std::__value_type<std::pair<unsigned int,unsigned char>,PropertyExchange::Request>,std::less<std::pair<unsigned int,unsigned char>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,unsigned char>,PropertyExchange::Request>>>::__erase_unique<std::pair<unsigned int,unsigned char>>(a1, v7, v6);
LABEL_27:
            nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v55);
            nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(&v56, v55[0]);
            return;
          }
          if (!*(_BYTE *)(v9 + 42))
          {
            v24 = *(_QWORD *)(*a2 + 8);
            v25 = *(_QWORD *)(*a2 + 16) - v24;
            if (v25 < 0xF
              || (v26 = *(unsigned __int8 *)(v24 + 13) | ((unint64_t)*(unsigned __int8 *)(v24 + 14) << 7),
                  v26 + 16 >= v25))
            {
              __assert_rtn("make_uint14", "sysex.h", 232, "data_pos + 1 < data.size()");
            }
            *(_WORD *)(v9 + 40) = *(unsigned __int8 *)(v26 + v24 + 15) | (*(unsigned __int8 *)(v24 + v26 + 16) << 7);
            *(_BYTE *)(v9 + 42) = 1;
          }
          v27 = *(_QWORD *)(*a2 + 8);
          v28 = *(_QWORD *)(*a2 + 16) - v27;
          if (v28 < 0xF
            || (v29 = *(unsigned __int8 *)(v27 + 13) | ((unint64_t)*(unsigned __int8 *)(v27 + 14) << 7),
                v29 + 20 >= v28))
          {
            __assert_rtn("make_uint14", "sysex.h", 232, "data_pos + 1 < data.size()");
          }
          v30 = *(unsigned __int8 *)(v29 + v27 + 19) | ((unint64_t)*(unsigned __int8 *)(v27 + v29 + 20) << 7);
          std::vector<unsigned char>::__insert_with_size[abi:ne180100]<unsigned char const*,unsigned char const*>(v9 + 48, *(char **)(v9 + 48), (char *)(v29 + v27 + 21), (char *)(v29 + v27 + 21 + v30), v30);
          v31 = *(_WORD *)(v9 + 44) + 1;
          *(_WORD *)(v9 + 44) = v31;
          v32 = *a2;
          if (*(_BYTE *)(v9 + 42))
          {
            v33 = *(unsigned __int8 **)(v32 + 8);
            v34 = *(_QWORD *)(v32 + 16) - (_QWORD)v33;
            if (v34 < 0xF || (v35 = v33[13] | ((unint64_t)v33[14] << 7), v35 + 16 >= v34))
            {
LABEL_67:
              v44 = "data_pos + 1 < data.size()";
              v45 = 232;
              v46 = "sysex.h";
              v47 = "make_uint14";
LABEL_68:
              __assert_rtn(v47, v46, v45, v44);
            }
            if ((v33[v35 + 15] | (v33[v35 + 16] << 7)) != v31)
            {
              LODWORD(v58) = 3;
              LOBYTE(v59) = 0;
              v20 = *(_QWORD *)(v9 + 96);
              if (!v20)
                std::__throw_bad_function_call[abi:ne180100]();
              goto LABEL_26;
            }
          }
          else
          {
            v33 = *(unsigned __int8 **)(v32 + 8);
          }
          if (v33[12] != *(unsigned __int8 *)(v9 + 46))
            goto LABEL_27;
          v36 = *(_QWORD *)(v32 + 16) - (_QWORD)v33;
          if (v36 >= 0xF)
          {
            v37 = v33[13] | ((unint64_t)v33[14] << 7);
            if (v37 + 16 < v36)
            {
              if ((v33[v37 + 15] | (v33[v37 + 16] << 7)) != v31)
                goto LABEL_27;
              v38 = *(_QWORD *)(v9 + 48);
              v39 = *(_QWORD *)(v9 + 56);
              v60 = 0;
              nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::parse<char const*>((uint64_t)v53, v38, v39, (uint64_t)&v58);
              v40 = v60;
              if (v60 == &v58)
              {
                v41 = 4;
                v40 = &v58;
              }
              else
              {
                if (!v60)
                {
LABEL_58:
                  if (v53[0] == 9)
                  {
                    LODWORD(v57.__r_.__value_.__l.__data_) = 3;
                    v57.__r_.__value_.__s.__data_[16] = 0;
                    v42 = *(_QWORD *)(v9 + 96);
                    if (!v42)
                      std::__throw_bad_function_call[abi:ne180100]();
                  }
                  else
                  {
                    v43 = *(_QWORD *)(v9 + 56) - *(_QWORD *)(v9 + 48);
                    v57.__r_.__value_.__r.__words[0] = *(_QWORD *)(v9 + 48);
                    v57.__r_.__value_.__l.__size_ = v43;
                    v57.__r_.__value_.__s.__data_[16] = 1;
                    v42 = *(_QWORD *)(v9 + 96);
                    if (!v42)
                      std::__throw_bad_function_call[abi:ne180100]();
                  }
                  (*(void (**)(uint64_t, std::string *))(*(_QWORD *)v42 + 48))(v42, &v57);
                  std::__tree<std::__value_type<std::pair<unsigned int,unsigned char>,PropertyExchange::Request>,std::__map_value_compare<std::pair<unsigned int,unsigned char>,std::__value_type<std::pair<unsigned int,unsigned char>,PropertyExchange::Request>,std::less<std::pair<unsigned int,unsigned char>>,true>,std::allocator<std::__value_type<std::pair<unsigned int,unsigned char>,PropertyExchange::Request>>>::__erase_unique<std::pair<unsigned int,unsigned char>>(a1, v7, v6);
                  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)v53);
                  nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy(&v54, v53[0]);
                  goto LABEL_27;
                }
                v41 = 5;
              }
              (*(void (**)(void))(*(_QWORD *)v40 + 8 * v41))();
              goto LABEL_58;
            }
          }
          goto LABEL_67;
        default:
          exception = (nlohmann::detail::exception *)__cxa_allocate_exception(0x20uLL);
          v49 = *(unsigned __int8 *)(v22 + 56);
          if (v49 > 9)
            v50 = "number";
          else
            v50 = off_1E98BA368[v49];
          std::string::basic_string[abi:ne180100]<0>(&v57, v50);
          v51 = std::string::insert(&v57, 0, "type must be number, but is ", 0x1CuLL);
          v52 = *(_OWORD *)&v51->__r_.__value_.__l.__data_;
          v59 = v51->__r_.__value_.__r.__words[2];
          v58 = v52;
          v51->__r_.__value_.__l.__size_ = 0;
          v51->__r_.__value_.__r.__words[2] = 0;
          v51->__r_.__value_.__r.__words[0] = 0;
          nlohmann::detail::type_error::create(exception, 302, (uint64_t)&v58);
      }
    }
  }
}

void sub_1D4EED2D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, unsigned __int8 a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  void *v31;
  int v32;

  if (a25 < 0)
    operator delete(__p);
  if (a19 < 0)
  {
    operator delete(a14);
    if ((v32 & 1) == 0)
    {
LABEL_8:
      nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::assert_invariant((uint64_t)&a12);
      nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>::json_value::destroy((uint64_t **)&a13, a12);
      _Unwind_Resume(a1);
    }
  }
  else if (!v32)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v31);
  goto LABEL_8;
}

void MIDIDevice::~MIDIDevice(MIDIDevice *this)
{
  MIDIDevice::~MIDIDevice(this);
  JUMPOUT(0x1D826BA98);
}

{
  char *v2;

  *(_QWORD *)this = &off_1E98B9260;
  v2 = (char *)this + 48;
  OwnedPtrVector<MIDIEntity *>::~OwnedPtrVector((_QWORD *)this + 9);
  XCFObject<__CFString const*>::~XCFObject((uint64_t)v2);
  *(_QWORD *)this = off_1E98B9320;
  XCFObject<__CFDictionary const*>::~XCFObject((uint64_t)this + 24);
  BaseOpaqueObject::~BaseOpaqueObject(this);
}

uint64_t MIDIDevice::PrintObject(MIDIDevice *this, __sFILE *a2)
{
  fprintf(a2, "<%s 0x%x [%p]>", "MIDIDeviceRef", *((_DWORD *)this + 2), this);
  fprintf(a2, " parent=0x%X", *((_QWORD *)this + 2));
  return fputc(10, a2);
}

uint64_t TOpaqueObject<MIDIDevice,unsigned int,MIDIObject>::isa(uint64_t a1, void *a2)
{
  _BOOL4 v3;

  v3 = a2 == &TOpaqueRTTI<MIDIObject>::sRTTI || a2 == &BaseOpaqueObject::sBaseRTTI;
  return a2 == &TOpaqueRTTI<MIDIDevice>::sRTTI || v3;
}

__CFDictionary *MIDIDevice::ToPList(CFDictionaryRef *this)
{
  __CFDictionary *v2;
  __CFArray *Mutable;
  _QWORD *v4;
  uint64_t v5;
  const void *v6;

  v2 = MIDIObject::ToDictionary(this[3]);
  Mutable = CFArrayCreateMutable(0, (this[11] - this[10]) >> 3, MEMORY[0x1E0C9B378]);
  v4 = this[10];
  while (v4 != (_QWORD *)this[11])
  {
    v5 = *v4++;
    v6 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 56))(v5);
    CFArrayAppendValue(Mutable, v6);
    CFRelease(v6);
  }
  CFDictionarySetValue(v2, CFSTR("entities"), Mutable);
  CFRelease(Mutable);
  return v2;
}

void MIDIDevice::FromPList(MIDIDevice *this, __CFDictionary *a2)
{
  const __CFArray *v4;
  const __CFString *v5;
  MIDIServer *v6;
  uint64_t v7;
  MIDIObject **v8;
  MIDIObject **v9;
  MIDIObject *v10;
  __CFString *v11;
  const void *v12;
  MIDIObject *v13;
  CFIndex Count;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  char *v18;
  uint64_t v19;
  char *v20;
  char *v21;
  char *v22;
  char *v23;
  uint64_t v24;
  CFIndex v25;
  const __CFDictionary *ValueAtIndex;
  uint64_t v27;
  unint64_t v28;
  uint64_t *v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t *v37;
  char *v38;
  char *v39;
  uint64_t v40;
  const __CFString *v41;
  __CFString *v42;

  if (!a2)
    return;
  v4 = (const __CFArray *)DictGetAndDelete(a2, CFSTR("entities"));
  MIDIObject::FromDictionary(this, a2);
  v41 = 0;
  if (MIDIObject::GetStringProperty(this, kMIDIPropertyDriverOwner, &v41))
  {
    if (!v4)
      return;
    goto LABEL_17;
  }
  v5 = v41;
  XCFObject<__CFString const*>::Set((uint64_t)this + 48, v41);
  if (!v5
    || (v7 = MIDIServer::defaultInstance(v6)[33],
        v8 = *(MIDIObject ***)(v7 + 16),
        v9 = *(MIDIObject ***)(v7 + 24),
        v8 == v9))
  {
LABEL_14:
    v13 = 0;
  }
  else
  {
    while (1)
    {
      v10 = *v8;
      v42 = 0;
      v11 = MIDIObject::GetStringProperty(v10, kMIDIPropertyName, (const __CFString **)&v42) ? 0 : v42;
      if (CFEqual(v11, v5))
        break;
      v12 = (const void *)*((_QWORD *)v10 + 6);
      if (v12)
      {
        if (CFEqual(v12, v5))
          break;
      }
      if (++v8 == v9)
        goto LABEL_14;
    }
    v13 = *v8;
  }
  *((_QWORD *)this + 8) = v13;
  CFRelease(v5);
  if (v4)
  {
LABEL_17:
    Count = CFArrayGetCount(v4);
    v15 = *((_QWORD *)this + 10);
    if ((int)Count > (unint64_t)((*((_QWORD *)this + 12) - v15) >> 3))
    {
      if (Count << 32 < 0)
LABEL_47:
        std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
      v16 = *((_QWORD *)this + 11) - v15;
      v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>((int)Count);
      v18 = &v17[v16 & 0xFFFFFFFFFFFFFFF8];
      v20 = &v17[8 * v19];
      v22 = (char *)*((_QWORD *)this + 10);
      v21 = (char *)*((_QWORD *)this + 11);
      v23 = v18;
      if (v21 != v22)
      {
        do
        {
          v24 = *((_QWORD *)v21 - 1);
          v21 -= 8;
          *((_QWORD *)v23 - 1) = v24;
          v23 -= 8;
        }
        while (v21 != v22);
        v21 = (char *)*((_QWORD *)this + 10);
      }
      *((_QWORD *)this + 10) = v23;
      *((_QWORD *)this + 11) = v18;
      *((_QWORD *)this + 12) = v20;
      if (v21)
        operator delete(v21);
    }
    if ((int)Count >= 1)
    {
      v25 = 0;
      do
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v4, v25);
        v27 = operator new();
        MIDIObject::MIDIObject((MIDIObject *)v27, this, &stru_1E98BB0B0);
        *(_QWORD *)v27 = &off_1E98B92C0;
        *(_QWORD *)(v27 + 48) = this;
        *(_DWORD *)(v27 + 56) = 1;
        *(_QWORD *)(v27 + 80) = 0;
        *(_QWORD *)(v27 + 88) = 0;
        *(_QWORD *)(v27 + 64) = &off_1E98B9790;
        *(_QWORD *)(v27 + 72) = 0;
        *(_QWORD *)(v27 + 112) = 0;
        *(_QWORD *)(v27 + 120) = 0;
        *(_QWORD *)(v27 + 96) = &off_1E98B97F0;
        *(_QWORD *)(v27 + 104) = 0;
        MIDIEntity::FromPList((MIDIEntity *)v27, ValueAtIndex);
        LODWORD(v42) = 0;
        if (MIDIObject::GetIntegerProperty((MIDIObject *)v27, kMIDIPropertyMaxSysExSpeed, (int *)&v42))
          MIDIObject::SetProperty((MIDIObject *)v27, kMIDIPropertyMaxSysExSpeed, 3125);
        v29 = (uint64_t *)*((_QWORD *)this + 11);
        v28 = *((_QWORD *)this + 12);
        if ((unint64_t)v29 >= v28)
        {
          v31 = *((_QWORD *)this + 10);
          v32 = ((uint64_t)v29 - v31) >> 3;
          if ((unint64_t)(v32 + 1) >> 61)
            goto LABEL_47;
          v33 = v28 - v31;
          v34 = v33 >> 2;
          if (v33 >> 2 <= (unint64_t)(v32 + 1))
            v34 = v32 + 1;
          if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8)
            v35 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v35 = v34;
          if (v35)
            v35 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v35);
          else
            v36 = 0;
          v37 = (uint64_t *)(v35 + 8 * v32);
          *v37 = v27;
          v30 = v37 + 1;
          v39 = (char *)*((_QWORD *)this + 10);
          v38 = (char *)*((_QWORD *)this + 11);
          if (v38 != v39)
          {
            do
            {
              v40 = *((_QWORD *)v38 - 1);
              v38 -= 8;
              *--v37 = v40;
            }
            while (v38 != v39);
            v38 = (char *)*((_QWORD *)this + 10);
          }
          *((_QWORD *)this + 10) = v37;
          *((_QWORD *)this + 11) = v30;
          *((_QWORD *)this + 12) = v35 + 8 * v36;
          if (v38)
            operator delete(v38);
        }
        else
        {
          *v29 = v27;
          v30 = v29 + 1;
        }
        *((_QWORD *)this + 11) = v30;
        ++v25;
      }
      while (v25 != Count);
    }
    CFRelease(v4);
  }
}

void sub_1D4EED88C(_Unwind_Exception *a1)
{
  BaseOpaqueObject *v1;

  OwnedPtrVector<MIDIDestination *>::~OwnedPtrVector((uint64_t)v1 + 96);
  OwnedPtrVector<MIDISource *>::~OwnedPtrVector((uint64_t)v1 + 64);
  *(_QWORD *)v1 = off_1E98B9320;
  XCFObject<__CFDictionary const*>::~XCFObject((uint64_t)v1 + 24);
  BaseOpaqueObject::~BaseOpaqueObject(v1);
  MEMORY[0x1D826BA98](v1, 0x10E1C40CE33DE92);
  _Unwind_Resume(a1);
}

uint64_t MIDIDevice::ObjectType(MIDIDevice *this)
{
  return 16 * (*((_QWORD *)this + 6) == 0);
}

void MIDIEntity::FromPList(MIDIEntity *this, CFDictionaryRef theDict)
{
  __CFDictionary *v2;
  const __CFNumber *Value;
  MIDIDriverPlugin *v5;
  const __CFArray *v6;
  const __CFArray *v7;
  int Count;
  CFIndex v9;
  uint64_t v10;
  const __CFDictionary *ValueAtIndex;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t *v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  char *v25;
  char *v26;
  uint64_t v27;
  const __CFArray *v28;
  const __CFArray *v29;
  int v30;
  char **v31;
  CFIndex v32;
  uint64_t v33;
  const __CFDictionary *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  NSObject *v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t *v45;
  _QWORD *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t *v52;
  char *v53;
  char *v54;
  uint64_t v55;
  __CFDictionary *v56;
  char **v57;
  uint8_t buf[4];
  const char *v59;
  __int16 v60;
  int v61;
  __int16 v62;
  uint64_t v63;
  __int16 v64;
  MIDIDriverPlugin *v65;
  __int16 v66;
  MIDIEntity *v67;
  __int16 v68;
  const __CFDictionary *v69;
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  if (theDict)
  {
    v2 = theDict;
    Value = (const __CFNumber *)CFDictionaryGetValue(theDict, kMIDIPropertyProtocolID);
    if (Value)
      CFNumberGetValue(Value, kCFNumberSInt32Type, (char *)this + 56);
    v5 = *(MIDIDriverPlugin **)(*((_QWORD *)this + 6) + 64);
    v6 = (const __CFArray *)DictGetAndDelete(v2, CFSTR("sources"));
    v56 = v2;
    if (v6)
    {
      v7 = v6;
      Count = CFArrayGetCount(v6);
      v57 = (char **)((char *)this + 72);
      std::vector<void const*>::reserve((void **)this + 9, Count);
      if (Count >= 1)
      {
        v9 = 0;
        v10 = Count;
        do
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v7, v9);
          v12 = operator new();
          MIDIEndpoint::MIDIEndpoint((MIDIEndpoint *)v12, v5, this, ValueAtIndex);
          *(_QWORD *)v12 = &off_1E98B9380;
          *(_OWORD *)(v12 + 96) = 0u;
          *(_WORD *)(v12 + 160) = 0;
          *(_QWORD *)(v12 + 168) = 0;
          *(_WORD *)(v12 + 176) = 0;
          *(_OWORD *)(v12 + 112) = 0u;
          *(_OWORD *)(v12 + 128) = 0u;
          *(_QWORD *)(v12 + 144) = 0;
          gMIDIDeviceTableLog();
          v13 = gMIDIDeviceTableLog(void)::dtable;
          if (os_log_type_enabled((os_log_t)gMIDIDeviceTableLog(void)::dtable, OS_LOG_TYPE_DEBUG))
          {
            v14 = *(unsigned int *)(v12 + 8);
            *(_DWORD *)buf = 136316418;
            v59 = "DeviceTable.cpp";
            v60 = 1024;
            v61 = 720;
            v62 = 2048;
            v63 = v14;
            v64 = 2048;
            v65 = v5;
            v66 = 2048;
            v67 = this;
            v68 = 2048;
            v69 = ValueAtIndex;
            _os_log_impl(&dword_1D4E88000, v13, OS_LOG_TYPE_DEBUG, "%25s:%-5d MIDISource(ref 0x%lx)::MIDISource() - driver:%p entity:%p plist:%p", buf, 0x3Au);
          }
          MIDISource::CreateCISniffer((uint64_t **)v12);
          if (*(_BYTE *)(v12 + 88))
          {
            v15 = operator new();
            *(_BYTE *)v15 = 0;
            *(_QWORD *)(v15 + 64) = 0;
            *(_OWORD *)(v15 + 16) = 0u;
            *(_OWORD *)(v15 + 32) = 0u;
            *(_OWORD *)(v15 + 44) = 0u;
          }
          else
          {
            v15 = 0;
          }
          *(_QWORD *)(v12 + 152) = v15;
          v17 = (uint64_t *)*((_QWORD *)this + 10);
          v16 = *((_QWORD *)this + 11);
          if ((unint64_t)v17 >= v16)
          {
            v19 = ((char *)v17 - *v57) >> 3;
            if ((unint64_t)(v19 + 1) >> 61)
              std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
            v20 = v16 - (_QWORD)*v57;
            v21 = v20 >> 2;
            if (v20 >> 2 <= (unint64_t)(v19 + 1))
              v21 = v19 + 1;
            if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8)
              v22 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v22 = v21;
            if (v22)
              v22 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v22);
            else
              v23 = 0;
            v24 = (uint64_t *)(v22 + 8 * v19);
            *v24 = v12;
            v18 = v24 + 1;
            v26 = (char *)*((_QWORD *)this + 9);
            v25 = (char *)*((_QWORD *)this + 10);
            if (v25 != v26)
            {
              do
              {
                v27 = *((_QWORD *)v25 - 1);
                v25 -= 8;
                *--v24 = v27;
              }
              while (v25 != v26);
              v25 = *v57;
            }
            *((_QWORD *)this + 9) = v24;
            *((_QWORD *)this + 10) = v18;
            *((_QWORD *)this + 11) = v22 + 8 * v23;
            if (v25)
              operator delete(v25);
          }
          else
          {
            *v17 = v12;
            v18 = v17 + 1;
          }
          *((_QWORD *)this + 10) = v18;
          ++v9;
        }
        while (v9 != v10);
      }
      CFRelease(v7);
      v2 = v56;
    }
    v28 = (const __CFArray *)DictGetAndDelete(v2, CFSTR("destinations"));
    if (v28)
    {
      v29 = v28;
      v30 = CFArrayGetCount(v28);
      v31 = (char **)((char *)this + 104);
      std::vector<void const*>::reserve((void **)this + 13, v30);
      if (v30 >= 1)
      {
        v32 = 0;
        v33 = v30;
        do
        {
          v34 = (const __CFDictionary *)CFArrayGetValueAtIndex(v29, v32);
          v35 = operator new();
          MIDIEndpoint::MIDIEndpoint((MIDIEndpoint *)v35, v5, this, v34);
          v36 = 0;
          *(_QWORD *)v35 = &off_1E98B9870;
          do
          {
            v37 = v35 + v36;
            *(_DWORD *)(v37 + 96) = 0;
            *(_QWORD *)(v37 + 104) = 0;
            *(_QWORD *)(v37 + 112) = 0;
            v36 += 24;
          }
          while (v36 != 384);
          v38 = -384;
          v39 = 0u;
          do
          {
            *(_QWORD *)&v40 = v35 + v38 + 864;
            *((_QWORD *)&v40 + 1) = v35 + v38 + 888;
            v41 = v40;
            vst3q_f64((double *)v40, *(float64x2x3_t *)(&v39 - 2));
            v38 += 48;
          }
          while (v38);
          *(_DWORD *)(v35 + 864) = 3125;
          *(_DWORD *)(v35 + 892) = 0;
          *(_QWORD *)(v35 + 876) = 0;
          *(_QWORD *)(v35 + 884) = 0;
          *(_QWORD *)(v35 + 868) = 0;
          gMIDIDeviceTableLog();
          v42 = gMIDIDeviceTableLog(void)::dtable;
          if (os_log_type_enabled((os_log_t)gMIDIDeviceTableLog(void)::dtable, OS_LOG_TYPE_DEBUG))
          {
            v43 = *(unsigned int *)(v35 + 8);
            *(_DWORD *)buf = 136316418;
            v59 = "DeviceTable.cpp";
            v60 = 1024;
            v61 = 1002;
            v62 = 2048;
            v63 = v43;
            v64 = 2048;
            v65 = v5;
            v66 = 2048;
            v67 = this;
            v68 = 2048;
            v69 = v34;
            _os_log_impl(&dword_1D4E88000, v42, OS_LOG_TYPE_DEBUG, "%25s:%-5d [*] MIDIDestination(ref 0x%lx)::MIDIDestination() - driver:%p entity:%p plist:%p", buf, 0x3Au);
          }
          MIDIDestination::Init(v35);
          v45 = (uint64_t *)*((_QWORD *)this + 14);
          v44 = *((_QWORD *)this + 15);
          if ((unint64_t)v45 >= v44)
          {
            v47 = ((char *)v45 - *v31) >> 3;
            if ((unint64_t)(v47 + 1) >> 61)
              std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
            v48 = v44 - (_QWORD)*v31;
            v49 = v48 >> 2;
            if (v48 >> 2 <= (unint64_t)(v47 + 1))
              v49 = v47 + 1;
            if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFF8)
              v50 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v50 = v49;
            if (v50)
              v50 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v50);
            else
              v51 = 0;
            v52 = (uint64_t *)(v50 + 8 * v47);
            *v52 = v35;
            v46 = v52 + 1;
            v54 = (char *)*((_QWORD *)this + 13);
            v53 = (char *)*((_QWORD *)this + 14);
            if (v53 != v54)
            {
              do
              {
                v55 = *((_QWORD *)v53 - 1);
                v53 -= 8;
                *--v52 = v55;
              }
              while (v53 != v54);
              v53 = *v31;
            }
            *((_QWORD *)this + 13) = v52;
            *((_QWORD *)this + 14) = v46;
            *((_QWORD *)this + 15) = v50 + 8 * v51;
            if (v53)
              operator delete(v53);
          }
          else
          {
            *v45 = v35;
            v46 = v45 + 1;
          }
          *((_QWORD *)this + 14) = v46;
          ++v32;
        }
        while (v32 != v33);
      }
      CFRelease(v29);
      v2 = v56;
    }
    MIDIObject::FromDictionary(this, v2);
  }
}

void sub_1D4EEDE94(_Unwind_Exception *a1)
{
  BaseOpaqueObject *v1;
  uint64_t v3;
  uint64_t i;

  v3 = *((_QWORD *)v1 + 109);
  *((_QWORD *)v1 + 109) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  for (i = 840; i != 456; i -= 24)
    std::__list_imp<MergeQueueElem>::clear((BaseOpaqueObject *)((char *)v1 + i));
  *(_QWORD *)v1 = off_1E98B9320;
  XCFObject<__CFDictionary const*>::~XCFObject((uint64_t)v1 + 24);
  BaseOpaqueObject::~BaseOpaqueObject(v1);
  MEMORY[0x1D826BA98](v1, 0x10E1C402D25DFBCLL);
  _Unwind_Resume(a1);
}

uint64_t OwnedPtrVector<MIDIDestination *>::~OwnedPtrVector(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = &off_1E98B97F0;
  OwnedPtrVector<MIDICIServerSession *>::erase((_QWORD *)a1, *(uint64_t **)(a1 + 8), *(uint64_t **)(a1 + 16));
  v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(_QWORD *)(a1 + 16) = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t OwnedPtrVector<MIDISource *>::~OwnedPtrVector(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = &off_1E98B9790;
  OwnedPtrVector<MIDICIServerSession *>::erase((_QWORD *)a1, *(uint64_t **)(a1 + 8), *(uint64_t **)(a1 + 16));
  v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(_QWORD *)(a1 + 16) = v2;
    operator delete(v2);
  }
  return a1;
}

void MIDIEndpoint::MIDIEndpoint(MIDIEndpoint *this, MIDIDriverPlugin *a2, MIDIEntity *a3, const __CFDictionary *a4)
{
  uint64_t v8;

  BaseOpaqueObject::BaseOpaqueObject(this);
  *(_QWORD *)(v8 + 16) = a3;
  *(_QWORD *)(v8 + 24) = 0;
  *(_WORD *)(v8 + 32) = 1;
  *(_WORD *)(v8 + 40) = 0;
  *(_QWORD *)v8 = off_1E98B9480;
  *(_DWORD *)(v8 + 44) = *((_DWORD *)a3 + 14);
  *(_QWORD *)(v8 + 48) = 0;
  *(_QWORD *)(v8 + 56) = a2;
  *(_DWORD *)(v8 + 92) = 0;
  *(_DWORD *)(v8 + 87) = 0;
  *(_QWORD *)(v8 + 64) = a3;
  *(_QWORD *)(v8 + 72) = 0;
  *(_QWORD *)(v8 + 80) = 0;
  MIDIObject::FromDictionary((MIDIObject *)v8, a4);
  MIDIEndpoint::SetIsVirtual(this);
}

void sub_1D4EEE0A8(_Unwind_Exception *a1)
{
  BaseOpaqueObject *v1;
  uint64_t v2;

  *(_QWORD *)v1 = off_1E98B9320;
  XCFObject<__CFDictionary const*>::~XCFObject(v2);
  BaseOpaqueObject::~BaseOpaqueObject(v1);
  _Unwind_Resume(a1);
}

void gMIDIDeviceTableLog(void)
{
  unsigned __int8 v0;

  if ((v0 & 1) == 0)
  {
    {
      gMIDIDeviceTableLog(void)::dtable = (uint64_t)os_log_create("com.apple.coremidi", "dtable");
    }
  }
}

uint64_t MIDIDestination::Init(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  uint64_t (**v4)();
  uint64_t v5;
  _QWORD *v6;
  uint64_t (**v7)();
  uint64_t v8;
  _QWORD *v9;
  uint64_t (**v10)();
  uint64_t v11;
  int v12;
  uint64_t (**v13)();
  uint64_t v14;
  uint64_t (**v15)();
  uint64_t v16[6];
  uint64_t (**v17)();
  _QWORD v18[6];
  uint64_t (**v19)();
  _QWORD v20[6];
  uint64_t (**v21)();
  uint64_t v22[6];
  uint64_t (**v23)();
  _QWORD v24[7];

  v1 = this;
  v24[6] = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(this + 56);
  if (v2)
  {
    if (*(int *)(v2 + 64) < 3)
    {
      v19 = caulk::inplace_function<void ()(MIDI::LegacyPacketList const*),48ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<MIDIDestination::Init(void)::$_1>;
      v20[0] = this;
      v9 = (_QWORD *)operator new();
      v23 = caulk::inplace_function<void ()(MIDI::LegacyPacketList const*),48ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<MIDIDestination::Init(void)::$_1>;
      caulk::inplace_function_detail::vtable<void,MIDI::LegacyPacketList const*>::vtable<MIDIDestination::Init(void)::$_1>(caulk::inplace_function_detail::wrapper<MIDIDestination::Init(void)::$_1>)::{lambda(void *,void *)#1}::__invoke(v24, v20);
      v10 = v23;
      v23 = (uint64_t (**)())&caulk::inplace_function_detail::vtable<void,MIDI::LegacyPacketList const*>::empty;
      *v9 = &off_1E98B9EC8;
      v9[1] = v10;
      ((void (*)(_QWORD *, _QWORD *))v10[2])(v9 + 2, v24);
      bzero(v9 + 8, 0x300uLL);
      ((void (*)(_QWORD *))v23[3])(v24);
      v11 = *(_QWORD *)(v1 + 872);
      *(_QWORD *)(v1 + 872) = v9;
      if (v11)
        (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
      return ((uint64_t (*)(_QWORD *))v19[3])(v20);
    }
    else
    {
      v3 = *(_DWORD *)(this + 44);
      v21 = caulk::inplace_function<void ()(MIDI::EventList const*),48ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<MIDIDestination::Init(void)::$_0>;
      v22[0] = this;
      MIDI::EventListDeliverer::create(&v23, v3, (uint64_t *)&v21);
      v4 = v23;
      v23 = 0;
      v5 = *(_QWORD *)(v1 + 872);
      *(_QWORD *)(v1 + 872) = v4;
      if (v5)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
        v23 = 0;
      }
      return ((uint64_t (*)(uint64_t *))v21[3])(v22);
    }
  }
  else if (*(_QWORD *)(this + 48))
  {
    if (*(_QWORD *)(this + 880))
    {
      v17 = caulk::inplace_function<void ()(MIDI::LegacyPacketList const*),48ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<MIDIDestination::Init(void)::$_2>;
      v18[0] = this;
      v6 = (_QWORD *)operator new();
      v23 = caulk::inplace_function<void ()(MIDI::LegacyPacketList const*),48ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<MIDIDestination::Init(void)::$_2>;
      caulk::inplace_function_detail::vtable<void,MIDI::LegacyPacketList const*>::vtable<MIDIDestination::Init(void)::$_2>(caulk::inplace_function_detail::wrapper<MIDIDestination::Init(void)::$_2>)::{lambda(void *,void *)#1}::__invoke(v24, v18);
      v7 = v23;
      v23 = (uint64_t (**)())&caulk::inplace_function_detail::vtable<void,MIDI::LegacyPacketList const*>::empty;
      *v6 = &off_1E98B9EC8;
      v6[1] = v7;
      ((void (*)(_QWORD *, _QWORD *))v7[2])(v6 + 2, v24);
      bzero(v6 + 8, 0x300uLL);
      ((void (*)(_QWORD *))v23[3])(v24);
      v8 = *(_QWORD *)(v1 + 872);
      *(_QWORD *)(v1 + 872) = v6;
      if (v8)
        (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
      return ((uint64_t (*)(_QWORD *))v17[3])(v18);
    }
    else if (*(_QWORD *)(this + 888))
    {
      v12 = *(_DWORD *)(this + 44);
      v15 = caulk::inplace_function<void ()(MIDI::EventList const*),48ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<MIDIDestination::Init(void)::$_3>;
      v16[0] = this;
      MIDI::EventListDeliverer::create(&v23, v12, (uint64_t *)&v15);
      v13 = v23;
      v23 = 0;
      v14 = *(_QWORD *)(v1 + 872);
      *(_QWORD *)(v1 + 872) = v13;
      if (v14)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v14 + 8))(v14);
        v23 = 0;
      }
      return ((uint64_t (*)(uint64_t *))v15[3])(v16);
    }
  }
  return this;
}

void sub_1D4EEE3F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

uint64_t caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<MIDIDestination::Init(void)::$_3>(caulk::inplace_function_detail::wrapper<MIDIDestination::Init(void)::$_3>)::{lambda(void *,MIDI::EventList const*&&)#1}::__invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)a1 + 888) + 16))();
}

_QWORD *caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<MIDIDestination::Init(void)::$_3>(caulk::inplace_function_detail::wrapper<MIDIDestination::Init(void)::$_3>)::{lambda(void *,void *)#1}::__invoke(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

_QWORD *caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<MIDIDestination::Init(void)::$_3>(caulk::inplace_function_detail::wrapper<MIDIDestination::Init(void)::$_3>)::{lambda(void *,void *)#2}::__invoke(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

uint64_t caulk::inplace_function_detail::vtable<void,MIDI::LegacyPacketList const*>::vtable<MIDIDestination::Init(void)::$_2>(caulk::inplace_function_detail::wrapper<MIDIDestination::Init(void)::$_2>)::{lambda(void *,MIDI::LegacyPacketList const*&&)#1}::__invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)a1 + 880) + 16))();
}

_QWORD *caulk::inplace_function_detail::vtable<void,MIDI::LegacyPacketList const*>::vtable<MIDIDestination::Init(void)::$_2>(caulk::inplace_function_detail::wrapper<MIDIDestination::Init(void)::$_2>)::{lambda(void *,void *)#1}::__invoke(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

_QWORD *caulk::inplace_function_detail::vtable<void,MIDI::LegacyPacketList const*>::vtable<MIDIDestination::Init(void)::$_2>(caulk::inplace_function_detail::wrapper<MIDIDestination::Init(void)::$_2>)::{lambda(void *,void *)#2}::__invoke(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

uint64_t *caulk::inplace_function_detail::vtable<void,MIDI::LegacyPacketList const*>::vtable<MIDIDestination::Init(void)::$_1>(caulk::inplace_function_detail::wrapper<MIDIDestination::Init(void)::$_1>)::{lambda(void *,MIDI::LegacyPacketList const*&&)#1}::__invoke(MIDIServer *a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *result;

  v2 = *a2;
  v3 = *(_QWORD *)a1;
  result = MIDIServer::defaultInstance(a1);
  if (*(_BYTE *)result[33])
    return (uint64_t *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD, _QWORD))(**(_QWORD **)(v3 + 56) + 104))(*(_QWORD *)(v3 + 56), v2, *(_QWORD *)(v3 + 72), *(_QWORD *)(v3 + 80));
  return result;
}

_QWORD *caulk::inplace_function_detail::vtable<void,MIDI::LegacyPacketList const*>::vtable<MIDIDestination::Init(void)::$_1>(caulk::inplace_function_detail::wrapper<MIDIDestination::Init(void)::$_1>)::{lambda(void *,void *)#1}::__invoke(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

_QWORD *caulk::inplace_function_detail::vtable<void,MIDI::LegacyPacketList const*>::vtable<MIDIDestination::Init(void)::$_1>(caulk::inplace_function_detail::wrapper<MIDIDestination::Init(void)::$_1>)::{lambda(void *,void *)#2}::__invoke(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

uint64_t *caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<MIDIDestination::Init(void)::$_0>(caulk::inplace_function_detail::wrapper<MIDIDestination::Init(void)::$_0>)::{lambda(void *,MIDI::EventList const*&&)#1}::__invoke(MIDIServer *a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *result;

  v2 = *a2;
  v3 = *(_QWORD *)a1;
  result = MIDIServer::defaultInstance(a1);
  if (*(_BYTE *)result[33])
    return (uint64_t *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD, _QWORD))(**(_QWORD **)(v3 + 56) + 144))(*(_QWORD *)(v3 + 56), v2, *(_QWORD *)(v3 + 72), *(_QWORD *)(v3 + 80));
  return result;
}

_QWORD *caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<MIDIDestination::Init(void)::$_0>(caulk::inplace_function_detail::wrapper<MIDIDestination::Init(void)::$_0>)::{lambda(void *,void *)#1}::__invoke(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

_QWORD *caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<MIDIDestination::Init(void)::$_0>(caulk::inplace_function_detail::wrapper<MIDIDestination::Init(void)::$_0>)::{lambda(void *,void *)#2}::__invoke(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

void MIDIDestination::~MIDIDestination(MIDIDestination *this)
{
  MIDIDestination::~MIDIDestination(this);
  JUMPOUT(0x1D826BA98);
}

{
  uint64_t v2;
  uint64_t i;

  *(_QWORD *)this = &off_1E98B9870;
  Scheduler::FlushEndpoint((Scheduler *)gScheduler, *((_DWORD *)this + 2));
  _Block_release(*((const void **)this + 110));
  _Block_release(*((const void **)this + 111));
  v2 = *((_QWORD *)this + 109);
  *((_QWORD *)this + 109) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  for (i = 840; i != 456; i -= 24)
    std::__list_imp<MergeQueueElem>::clear((MIDIDestination *)((char *)this + i));
  *(_QWORD *)this = off_1E98B9320;
  XCFObject<__CFDictionary const*>::~XCFObject((uint64_t)this + 24);
  BaseOpaqueObject::~BaseOpaqueObject(this);
}

uint64_t MIDIDestination::PrintObject(MIDIDestination *this, __sFILE *a2)
{
  fprintf(a2, "<%s 0x%x [%p]>", "MIDIEndpointRef", *((_DWORD *)this + 2), this);
  fprintf(a2, " parent=0x%X", *((_QWORD *)this + 2));
  return fputc(10, a2);
}

uint64_t TOpaqueObject<MIDIEndpoint,unsigned int,MIDIObject>::isa(uint64_t a1, void *a2)
{
  _BOOL4 v3;

  v3 = a2 == &TOpaqueRTTI<MIDIObject>::sRTTI || a2 == &BaseOpaqueObject::sBaseRTTI;
  return a2 == &TOpaqueRTTI<MIDIEndpoint>::sRTTI || v3;
}

uint64_t MIDIEndpoint::GetProperty(MIDIObjectRef *this, const __CFString *cf1, const void **a3, int a4)
{
  uint64_t v8;
  uint64_t v9;
  __CFString *Mutable;
  unint64_t v11;
  const UInt8 *BytePtr;
  unsigned int *v13;
  char v14;
  MIDIUniqueID v15;
  const __CFString *v16;
  const __CFString *v17;
  MIDIObject *v18;
  CFNumberRef v19;
  uint64_t result;
  MIDIObjectRef v21;
  int v22;
  CFStringRef v23;
  MIDIObjectType outObjectType[2];
  CFDataRef theData;
  CFStringRef str;

  if (!CFEqual(cf1, kMIDIPropertyDisplayName))
  {
    if (CFEqual(cf1, kMIDIPropertyProtocolID))
    {
      v19 = CFNumberCreate(0, kCFNumberSInt32Type, this + 11);
      result = 0;
      *a3 = v19;
      return result;
    }
    v18 = (MIDIObject *)this;
    v17 = cf1;
    return MIDIObject::GetProperty(v18, v17, a3, a4);
  }
  v8 = *((_QWORD *)this + 8);
  if (!v8 || (v9 = *(_QWORD *)(v8 + 48)) == 0)
  {
    v17 = kMIDIPropertyName;
    v18 = (MIDIObject *)this;
    return MIDIObject::GetProperty(v18, v17, a3, a4);
  }
  if (*(_QWORD *)(v9 + 48))
  {
    Mutable = CFStringCreateMutable(0, 0);
    theData = 0;
    str = 0;
    MIDIObject::GetIntegerOrDataProperty((MIDIObject *)this, kMIDIPropertyConnectionUniqueID, &theData, 0);
    if (theData)
    {
      v11 = (unint64_t)CFDataGetLength(theData) >> 2;
      if ((_DWORD)v11)
      {
        BytePtr = CFDataGetBytePtr(theData);
        if ((int)v11 >= 1)
        {
          v13 = (unsigned int *)BytePtr;
          v14 = 0;
          while (1)
          {
            v15 = bswap32(*v13);
            *(_QWORD *)outObjectType = 0;
            if (!MIDIObjectFindByUniqueID(v15, (MIDIObjectRef *)&outObjectType[1], outObjectType))
            {
              if ((outObjectType[0] & 0xFFFFFFFE) == 0x12)
              {
                v16 = EndpointName(outObjectType[1], 1);
                str = v16;
                if (v16)
                  goto LABEL_14;
              }
              else
              {
                str = 0;
                MIDIObjectGetStringProperty(outObjectType[1], kMIDIPropertyName, &str);
                v16 = str;
                if (str)
                {
LABEL_14:
                  if ((v14 & 1) != 0)
                  {
                    CheckLocalizeStrings();
                    CFStringAppend(Mutable, (CFStringRef)sMultipleEndpointSeparator);
                    v16 = str;
                  }
                  else
                  {
                    v14 = 1;
                  }
                  CFStringAppend(Mutable, v16);
                  CFRelease(str);
                }
              }
            }
            ++v13;
            LODWORD(v11) = v11 - 1;
            if (!(_DWORD)v11)
              goto LABEL_27;
          }
        }
      }
      v14 = 0;
LABEL_27:
      CFRelease(theData);
      if ((v14 & 1) != 0)
      {
        result = 0;
        *a3 = Mutable;
        return result;
      }
    }
    CFRelease(Mutable);
    v21 = this[2];
    v22 = 0;
  }
  else
  {
    v21 = this[2];
    v22 = 1;
  }
  v23 = EndpointName(v21, v22);
  *a3 = v23;
  if (v23)
    return 0;
  else
    return 4294956461;
}

uint64_t MIDIDestination::SetProperty(MIDIDestination *this, const __CFString *a2, const void *a3)
{
  uint64_t v5;

  v5 = MIDIObject::SetProperty((const __CFDictionary **)this, a2, a3);
  if ((_DWORD)v5 && CFEqual(a2, kMIDIPropertyAdvanceScheduleTimeMuSec))
    MIDIObject::GetIntegerProperty(this, a2, (int *)this + 217);
  return v5;
}

uint64_t MIDIDestination::ObjectType(MIDIDestination *this)
{
  uint64_t v1;
  uint64_t result;

  v1 = *((_QWORD *)this + 8);
  result = 3;
  if (v1)
  {
    if (*(_QWORD *)(*(_QWORD *)(v1 + 48) + 48))
      return 3;
    else
      return 19;
  }
  return result;
}

uint64_t MIDIEndpoint::IsSource(MIDIEndpoint *this)
{
  return 0;
}

uint64_t MIDIDestination::UpdateProtocol(uint64_t this, MIDIProtocolID a2)
{
  if (*(_DWORD *)(this + 44) != a2)
  {
    *(_DWORD *)(this + 44) = a2;
    return MIDIDestination::Init(this);
  }
  return this;
}

CFStringRef EndpointName(MIDIObjectRef a1, int a2)
{
  CFMutableStringRef Mutable;
  const __CFString *v5;
  MIDIObjectRef obj;
  MIDIEntityRef outEntity;
  CFStringRef str;
  CFRange v10;

  Mutable = CFStringCreateMutable(0, 0);
  str = 0;
  MIDIObjectGetStringProperty(a1, kMIDIPropertyName, &str);
  if (str)
  {
    CFStringAppend(Mutable, str);
    CFRelease(str);
  }
  outEntity = 0;
  MIDIEndpointGetEntity(a1, &outEntity);
  if (outEntity)
  {
    if (!CFStringGetLength(Mutable))
    {
      str = 0;
      MIDIObjectGetStringProperty(outEntity, kMIDIPropertyName, &str);
      if (str)
      {
        CFStringAppend(Mutable, str);
        CFRelease(str);
      }
    }
    obj = 0;
    MIDIEntityGetDevice(outEntity, &obj);
    if (obj)
    {
      str = 0;
      MIDIObjectGetStringProperty(obj, kMIDIPropertyName, &str);
      v5 = str;
      if (str)
      {
        if (a2)
        {
          if (MIDIDeviceGetNumberOfEntities(obj) < 2)
          {
            CFRelease(Mutable);
            return str;
          }
          v5 = str;
        }
        v10.length = CFStringGetLength(v5);
        v10.location = 0;
        if (CFStringCompareWithOptions(v5, Mutable, v10, 0))
        {
          if (CFStringGetLength(Mutable) >= 1)
          {
            CheckLocalizeStrings();
            CFStringInsert(Mutable, 0, (CFStringRef)sDeviceEntitySeparator);
          }
          CFStringInsert(Mutable, 0, str);
        }
        CFRelease(str);
      }
    }
  }
  return Mutable;
}

void CheckLocalizeStrings(void)
{
  CFBundleRef BundleWithIdentifier;

  if ((sLocalized & 1) == 0)
  {
    BundleWithIdentifier = CFBundleGetBundleWithIdentifier(CFSTR("com.apple.audio.midi.CoreMIDI"));
    sStringsBundle = (uint64_t)BundleWithIdentifier;
    if (BundleWithIdentifier)
    {
      CFRetain(BundleWithIdentifier);
      sDeviceEntitySeparator = (uint64_t)CFBundleCopyLocalizedString((CFBundleRef)sStringsBundle, (CFStringRef)sDeviceEntitySeparator, (CFStringRef)sDeviceEntitySeparator, CFSTR("MIDIServerLocalizable"));
      sMultipleEndpointSeparator = (uint64_t)CFBundleCopyLocalizedString((CFBundleRef)sStringsBundle, (CFStringRef)sMultipleEndpointSeparator, (CFStringRef)sMultipleEndpointSeparator, CFSTR("MIDIServerLocalizable"));
      sLocalized = 1;
    }
  }
}

MIDIObject *MIDIEndpoint::SetIsVirtual(MIDIEndpoint *this)
{
  MIDIObject *result;
  __CFString *v3;
  MIDIObject *v4;
  __CFString *v5;
  uint64_t v6;
  __CFString *v7;

  result = (MIDIObject *)*((_QWORD *)this + 7);
  if (result)
  {
    v7 = 0;
    if (MIDIObject::GetStringProperty(result, kMIDIPropertyName, (const __CFString **)&v7))
      v3 = 0;
    else
      v3 = v7;
    *((_BYTE *)this + 89) = CFStringCompare(v3, CFSTR("com.apple.AppleMIDIIACDriver"), 0) == kCFCompareEqualTo;
    v4 = (MIDIObject *)*((_QWORD *)this + 7);
    v7 = 0;
    if (MIDIObject::GetStringProperty(v4, kMIDIPropertyName, (const __CFString **)&v7))
      v5 = 0;
    else
      v5 = v7;
    result = (MIDIObject *)CFStringCompare(v5, CFSTR("com.apple.AppleMIDIUSBDriver"), 0);
    *((_BYTE *)this + 90) = result == 0;
  }
  if (*((_QWORD *)this + 6))
  {
    LOBYTE(v6) = 1;
  }
  else
  {
    v6 = *((_QWORD *)this + 7);
    if (v6)
      LOBYTE(v6) = *((_BYTE *)this + 89);
  }
  *((_BYTE *)this + 88) = v6;
  return result;
}

uint64_t MIDIEndpoint::IsDestination(MIDIEndpoint *this)
{
  return 0;
}

uint64_t **MIDISource::CreateCISniffer(uint64_t **this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t i;
  _BYTE *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD v12[3];
  _QWORD *v13;
  _QWORD v14[3];
  _QWORD *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v2 = (uint64_t *)operator new();
  v14[0] = &off_1E98B7140;
  v14[1] = this;
  v15 = v14;
  v12[0] = &off_1E98B7188;
  v13 = v12;
  *v2 = 0;
  v2[4] = (uint64_t)(v2 + 1);
  std::__function::__func<MIDISource::CreateCISniffer(void)::$_0,std::allocator<MIDISource::CreateCISniffer(void)::$_0>,void ()(MIDI::UniversalPacket const&,unsigned long long)>::__clone((uint64_t)v14, v2 + 1);
  v2[8] = (uint64_t)(v2 + 5);
  std::__function::__func<MIDISource::CreateCISniffer(void)::$_1,std::allocator<MIDISource::CreateCISniffer(void)::$_1>,void ()(unsigned char,BOOL)>::__clone((uint64_t)v12, v2 + 5);
  v3 = operator new();
  for (i = 0; i != 320; i += 20)
  {
    v5 = (_BYTE *)(v3 + i);
    *v5 = 0;
    v5[18] = 0;
  }
  v6 = *v2;
  *v2 = v3;
  if (v6)
    MEMORY[0x1D826BA98](v6, 0x1000C408516A477);
  v7 = v13;
  if (v13 == v12)
  {
    v8 = 4;
    v7 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_10;
    v8 = 5;
  }
  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_10:
  v9 = v15;
  if (v15 == v14)
  {
    v10 = 4;
    v9 = v14;
    goto LABEL_14;
  }
  if (v15)
  {
    v10 = 5;
LABEL_14:
    (*(void (**)(void))(*v9 + 8 * v10))();
  }
  return std::unique_ptr<MIDICISniffer>::reset[abi:ne180100](this + 21, v2);
}

void sub_1D4EEEECC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  uint64_t *v17;
  _QWORD *v18;
  _QWORD *v19;
  _QWORD *v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;

  v21 = (_QWORD *)v17[8];
  if (v21 == v19)
  {
    v22 = 4;
  }
  else
  {
    if (!v21)
      goto LABEL_6;
    v22 = 5;
    v19 = (_QWORD *)v17[8];
  }
  (*(void (**)(_QWORD *))(*v19 + 8 * v22))(v19);
LABEL_6:
  v23 = (_QWORD *)v17[4];
  if (v23 == v18)
  {
    v24 = 4;
  }
  else
  {
    if (!v23)
      goto LABEL_11;
    v24 = 5;
    v18 = (_QWORD *)v17[4];
  }
  (*(void (**)(_QWORD *))(*v18 + 8 * v24))(v18);
LABEL_11:
  v25 = *v17;
  *v17 = 0;
  if (v25)
    MEMORY[0x1D826BA98](v25, 0x1000C408516A477);
  v26 = a13;
  if (a13 == &a10)
  {
    v27 = 4;
    v26 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_18;
    v27 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v26 + 8 * v27))();
LABEL_18:
  v28 = a17;
  if (a17 == &a14)
  {
    v29 = 4;
    v28 = &a14;
  }
  else
  {
    if (!a17)
      goto LABEL_23;
    v29 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v28 + 8 * v29))();
LABEL_23:
  MEMORY[0x1D826BA98](v17, 0x1020C40AC0324D5);
  _Unwind_Resume(a1);
}

uint64_t **std::unique_ptr<MIDICISniffer>::reset[abi:ne180100](uint64_t **result, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    v3 = (uint64_t *)v2[8];
    if (v3 == v2 + 5)
    {
      v4 = 4;
      v3 = v2 + 5;
    }
    else
    {
      if (!v3)
        goto LABEL_8;
      v4 = 5;
    }
    (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_8:
    v5 = (uint64_t *)v2[4];
    if (v5 == v2 + 1)
    {
      v6 = 4;
      v5 = v2 + 1;
    }
    else
    {
      if (!v5)
        goto LABEL_13;
      v6 = 5;
    }
    (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_13:
    v7 = *v2;
    *v2 = 0;
    if (v7)
      MEMORY[0x1D826BA98](v7, 0x1000C408516A477);
    JUMPOUT(0x1D826BA98);
  }
  return result;
}

void std::__function::__func<MIDISource::CreateCISniffer(void)::$_1,std::allocator<MIDISource::CreateCISniffer(void)::$_1>,void ()(unsigned char,BOOL)>::~__func()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *std::__function::__func<MIDISource::CreateCISniffer(void)::$_1,std::allocator<MIDISource::CreateCISniffer(void)::$_1>,void ()(unsigned char,BOOL)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E98B7188;
  return result;
}

void std::__function::__func<MIDISource::CreateCISniffer(void)::$_1,std::allocator<MIDISource::CreateCISniffer(void)::$_1>,void ()(unsigned char,BOOL)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E98B7188;
}

void std::__function::__func<MIDISource::CreateCISniffer(void)::$_0,std::allocator<MIDISource::CreateCISniffer(void)::$_0>,void ()(MIDI::UniversalPacket const&,unsigned long long)>::~__func()
{
  JUMPOUT(0x1D826BA98);
}

_QWORD *std::__function::__func<MIDISource::CreateCISniffer(void)::$_0,std::allocator<MIDISource::CreateCISniffer(void)::$_0>,void ()(MIDI::UniversalPacket const&,unsigned long long)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_1E98B7140;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<MIDISource::CreateCISniffer(void)::$_0,std::allocator<MIDISource::CreateCISniffer(void)::$_0>,void ()(MIDI::UniversalPacket const&,unsigned long long)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_1E98B7140;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<MIDISource::CreateCISniffer(void)::$_0,std::allocator<MIDISource::CreateCISniffer(void)::$_0>,void ()(MIDI::UniversalPacket const&,unsigned long long)>::operator()(MIDIServer *a1, char *a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;

  v4 = *a3;
  v5 = *((_QWORD *)a1 + 1);
  v6 = MIDIServer::defaultInstance(a1);
  return AsyncMessenger::push(v6[78] + 32, 1, *(_DWORD *)(v5 + 8), v4, a2);
}

void MIDISource::~MIDISource(uint64_t **this)
{
  MIDISource::~MIDISource(this);
  JUMPOUT(0x1D826BA98);
}

{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  uint64_t *v5;

  *this = (uint64_t *)&off_1E98B9380;
  MIDISource::CloseInputConnections((MIDISource *)this);
  v2 = this[19];
  if (v2)
    MEMORY[0x1D826BA98](v2, 0x1000C40A4C6D0EALL);
  std::unique_ptr<MIDICISniffer>::reset[abi:ne180100](this + 21, 0);
  v3 = this[18];
  this[18] = 0;
  if (v3)
    (*(void (**)(uint64_t *))(*v3 + 8))(v3);
  v4 = this[15];
  if (v4)
  {
    this[16] = v4;
    operator delete(v4);
  }
  v5 = this[12];
  if (v5)
  {
    this[13] = v5;
    operator delete(v5);
  }
  *this = (uint64_t *)off_1E98B9320;
  XCFObject<__CFDictionary const*>::~XCFObject((uint64_t)(this + 3));
  BaseOpaqueObject::~BaseOpaqueObject((BaseOpaqueObject *)this);
}

uint64_t MIDISource::PrintObject(MIDISource *this, __sFILE *a2)
{
  fprintf(a2, "<%s 0x%x [%p]>", "MIDIEndpointRef", *((_DWORD *)this + 2), this);
  fprintf(a2, " parent=0x%X", *((_QWORD *)this + 2));
  return fputc(10, a2);
}

uint64_t MIDISource::ObjectType(MIDISource *this)
{
  uint64_t v1;
  uint64_t result;

  v1 = *((_QWORD *)this + 8);
  result = 2;
  if (v1)
  {
    if (*(_QWORD *)(*(_QWORD *)(v1 + 48) + 48))
      return 2;
    else
      return 18;
  }
  return result;
}

uint64_t MIDISource::UpdateProtocol(uint64_t this, MIDIProtocolID a2)
{
  if (*(_DWORD *)(this + 44) != a2)
    *(_DWORD *)(this + 44) = a2;
  return this;
}

uint64_t MIDISource::CloseInputConnections(MIDISource *this)
{
  uint64_t *v2;
  uint64_t result;
  int v4;
  _QWORD **v5;
  _QWORD **v6;

  v2 = MIDIServer::defaultInstance(this) + 13;
  result = (*(uint64_t (**)(uint64_t *))(*v2 + 16))(v2);
  v4 = result;
  v5 = (_QWORD **)*((_QWORD *)this + 12);
  v6 = (_QWORD **)*((_QWORD *)this + 13);
  if (v5 != v6)
  {
    do
      MIDIInputPort::RemoveConnectedSource(*v5++, (uint64_t)this);
    while (v5 != v6);
    *((_QWORD *)this + 13) = *((_QWORD *)this + 12);
    result = *((_QWORD *)this + 7);
    if (result)
      result = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)result + 112))(result, *((unsigned int *)this + 2), 0);
  }
  if (v4)
    return (*(uint64_t (**)(uint64_t *))(*v2 + 24))(v2);
  return result;
}

void sub_1D4EEF3B8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  int v2;

  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

void OwnedPtrVector<MIDIDestination *>::~OwnedPtrVector(uint64_t a1)
{
  OwnedPtrVector<MIDIDestination *>::~OwnedPtrVector(a1);
  JUMPOUT(0x1D826BA98);
}

void OwnedPtrVector<MIDISource *>::~OwnedPtrVector(uint64_t a1)
{
  OwnedPtrVector<MIDISource *>::~OwnedPtrVector(a1);
  JUMPOUT(0x1D826BA98);
}

void MIDIEntity::~MIDIEntity(uint64_t **this)
{
  MIDIEntity::~MIDIEntity(this);
  JUMPOUT(0x1D826BA98);
}

{
  uint64_t *v2;
  int v3;

  *this = (uint64_t *)&off_1E98B92C0;
  v2 = MIDIServer::defaultInstance((MIDIServer *)this) + 13;
  v3 = (*(uint64_t (**)(uint64_t *))(*v2 + 16))(v2);
  OwnedPtrVector<MIDICIServerSession *>::erase(this + 8, this[9], this[10]);
  OwnedPtrVector<MIDICIServerSession *>::erase(this + 12, this[13], this[14]);
  if (v3)
    (*(void (**)(uint64_t *))(*v2 + 24))(v2);
  OwnedPtrVector<MIDIDestination *>::~OwnedPtrVector((uint64_t)(this + 12));
  OwnedPtrVector<MIDISource *>::~OwnedPtrVector((uint64_t)(this + 8));
  *this = (uint64_t *)off_1E98B9320;
  XCFObject<__CFDictionary const*>::~XCFObject((uint64_t)(this + 3));
  BaseOpaqueObject::~BaseOpaqueObject((BaseOpaqueObject *)this);
}

uint64_t MIDIEntity::PrintObject(MIDIEntity *this, __sFILE *a2)
{
  fprintf(a2, "<%s 0x%x [%p]>", "MIDIEntityRef", *((_DWORD *)this + 2), this);
  fprintf(a2, " parent=0x%X", *((_QWORD *)this + 2));
  return fputc(10, a2);
}

uint64_t TOpaqueObject<MIDIEntity,unsigned int,MIDIObject>::isa(uint64_t a1, void *a2)
{
  _BOOL4 v3;

  v3 = a2 == &TOpaqueRTTI<MIDIObject>::sRTTI || a2 == &BaseOpaqueObject::sBaseRTTI;
  return a2 == &TOpaqueRTTI<MIDIEntity>::sRTTI || v3;
}

__CFDictionary *MIDIEntity::ToPList(CFDictionaryRef *this)
{
  __CFDictionary *v2;
  __CFArray *Mutable;
  _QWORD *v4;
  uint64_t v5;
  CFMutableDictionaryRef v6;
  __CFArray *v7;
  _QWORD *v8;
  uint64_t v9;
  CFMutableDictionaryRef v10;
  CFNumberRef v11;

  v2 = MIDIObject::ToDictionary(this[3]);
  Mutable = CFArrayCreateMutable(0, (this[10] - this[9]) >> 3, MEMORY[0x1E0C9B378]);
  v4 = this[9];
  while (v4 != (_QWORD *)this[10])
  {
    v5 = *v4++;
    v6 = MIDIObject::ToDictionary(*(CFDictionaryRef *)(v5 + 24));
    CFArrayAppendValue(Mutable, v6);
    CFRelease(v6);
  }
  CFDictionarySetValue(v2, CFSTR("sources"), Mutable);
  CFRelease(Mutable);
  v7 = CFArrayCreateMutable(0, (this[14] - this[13]) >> 3, MEMORY[0x1E0C9B378]);
  v8 = this[13];
  while (v8 != (_QWORD *)this[14])
  {
    v9 = *v8++;
    v10 = MIDIObject::ToDictionary(*(CFDictionaryRef *)(v9 + 24));
    CFArrayAppendValue(v7, v10);
    CFRelease(v10);
  }
  CFDictionarySetValue(v2, CFSTR("destinations"), v7);
  CFRelease(v7);
  v11 = CFNumberCreate(0, kCFNumberSInt32Type, this + 7);
  CFDictionarySetValue(v2, kMIDIPropertyProtocolID, v11);
  CFRelease(v11);
  return v2;
}

uint64_t MIDIEntity::ObjectType(MIDIEntity *this)
{
  if (*(_QWORD *)(*((_QWORD *)this + 6) + 48))
    return 1;
  else
    return 17;
}

_QWORD *OwnedPtrVector<MIDIEntity *>::~OwnedPtrVector(_QWORD *a1)
{
  char *v2;
  char *v3;
  char *v4;
  _BYTE *v5;
  uint64_t v6;
  char *v7;

  *a1 = &off_1E98B9770;
  v2 = (char *)a1[1];
  v3 = (char *)a1[2];
  if (v2 != v3)
  {
    v4 = (char *)a1[1];
    do
    {
      if (*(_QWORD *)v4)
        (*(void (**)(_QWORD))(**(_QWORD **)v4 + 8))(*(_QWORD *)v4);
      v4 += 8;
    }
    while (v4 != v3);
    v5 = (_BYTE *)a1[2];
    v6 = v5 - v3;
    if (v5 != v3)
      memmove(v2, v3, v5 - v3);
    v7 = (char *)a1[1];
    a1[2] = &v2[v6];
    v2 = v7;
  }
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void OwnedPtrVector<MIDIEntity *>::~OwnedPtrVector(_QWORD *a1)
{
  OwnedPtrVector<MIDIEntity *>::~OwnedPtrVector(a1);
  JUMPOUT(0x1D826BA98);
}

uint64_t DeviceList::PrintObject(DeviceList *this, __sFILE *a2)
{
  fprintf(a2, "<%s 0x%x [%p]>", "MIDIDeviceListRef", *((_DWORD *)this + 2), this);
  return fputc(10, a2);
}

BOOL TOpaqueObject<DeviceList,unsigned int,BaseOpaqueObject>::isa(uint64_t a1, void *a2)
{
  return a2 == &TOpaqueRTTI<DeviceList>::sRTTI || a2 == &BaseOpaqueObject::sBaseRTTI;
}

__CFArray *DeviceList::ToPList(DeviceList *this)
{
  __CFArray *Mutable;
  uint64_t *v3;
  uint64_t v4;
  const void *v5;

  Mutable = CFArrayCreateMutable(0, (uint64_t)(*((_QWORD *)this + 3) - *((_QWORD *)this + 2)) >> 3, MEMORY[0x1E0C9B378]);
  v3 = (uint64_t *)*((_QWORD *)this + 2);
  while (v3 != *((uint64_t **)this + 3))
  {
    v4 = *v3++;
    v5 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 56))(v4);
    CFArrayAppendValue(Mutable, v5);
    CFRelease(v5);
  }
  return Mutable;
}

void DeviceList::FromPList(DeviceList *this, CFArrayRef theArray)
{
  _QWORD *v4;
  void **v5;
  _QWORD *v6;
  int Count;
  CFIndex v8;
  uint64_t v9;
  __CFDictionary *ValueAtIndex;
  uint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  char *v21;
  char *v22;
  uint64_t v23;

  v6 = (_QWORD *)*((_QWORD *)this + 2);
  v4 = (_QWORD *)*((_QWORD *)this + 3);
  v5 = (void **)((char *)this + 16);
  if (v6 != v4)
  {
    do
    {
      if (*v6)
      {
        (*(void (**)(_QWORD))(*(_QWORD *)*v6 + 8))(*v6);
        v4 = (_QWORD *)*((_QWORD *)this + 3);
      }
      ++v6;
    }
    while (v6 != v4);
    if (*v5 != v4)
      *((_QWORD *)this + 3) = *v5;
  }
  if (theArray)
  {
    Count = CFArrayGetCount(theArray);
    std::vector<void const*>::reserve(v5, Count);
    if (Count >= 1)
    {
      v8 = 0;
      v9 = Count;
      do
      {
        ValueAtIndex = (__CFDictionary *)CFArrayGetValueAtIndex(theArray, v8);
        v11 = operator new();
        MIDIObject::MIDIObject((MIDIObject *)v11);
        *(_QWORD *)v11 = &off_1E98B9260;
        *(_QWORD *)(v11 + 48) = 0;
        *(_BYTE *)(v11 + 56) = 1;
        *(_QWORD *)(v11 + 88) = 0;
        *(_QWORD *)(v11 + 96) = 0;
        *(_QWORD *)(v11 + 72) = &off_1E98B9770;
        *(_QWORD *)(v11 + 80) = 0;
        *(_QWORD *)(v11 + 64) = 0;
        MIDIDevice::FromPList((MIDIDevice *)v11, ValueAtIndex);
        v13 = (uint64_t *)*((_QWORD *)this + 3);
        v12 = *((_QWORD *)this + 4);
        if ((unint64_t)v13 >= v12)
        {
          v15 = ((char *)v13 - (_BYTE *)*v5) >> 3;
          if ((unint64_t)(v15 + 1) >> 61)
            std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
          v16 = v12 - (_QWORD)*v5;
          v17 = v16 >> 2;
          if (v16 >> 2 <= (unint64_t)(v15 + 1))
            v17 = v15 + 1;
          if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8)
            v18 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v18 = v17;
          if (v18)
            v18 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<MIDIDriverPlugin>>>(v18);
          else
            v19 = 0;
          v20 = (uint64_t *)(v18 + 8 * v15);
          *v20 = v11;
          v14 = v20 + 1;
          v22 = (char *)*((_QWORD *)this + 2);
          v21 = (char *)*((_QWORD *)this + 3);
          if (v21 != v22)
          {
            do
            {
              v23 = *((_QWORD *)v21 - 1);
              v21 -= 8;
              *--v20 = v23;
            }
            while (v21 != v22);
            v21 = (char *)*v5;
          }
          *((_QWORD *)this + 2) = v20;
          *((_QWORD *)this + 3) = v14;
          *((_QWORD *)this + 4) = v18 + 8 * v19;
          if (v21)
            operator delete(v21);
        }
        else
        {
          *v13 = v11;
          v14 = v13 + 1;
        }
        *((_QWORD *)this + 3) = v14;
        ++v8;
      }
      while (v8 != v9);
    }
  }
}

void sub_1D4EEFB44(_Unwind_Exception *a1)
{
  BaseOpaqueObject *v1;

  OwnedPtrVector<MIDIEntity *>::~OwnedPtrVector((_QWORD *)v1 + 9);
  XCFObject<__CFString const*>::~XCFObject((uint64_t)v1 + 48);
  *(_QWORD *)v1 = off_1E98B9320;
  XCFObject<__CFDictionary const*>::~XCFObject((uint64_t)v1 + 24);
  BaseOpaqueObject::~BaseOpaqueObject(v1);
  MEMORY[0x1D826BA98](v1, 0x10E1C400F55952ELL);
  _Unwind_Resume(a1);
}

void MIDIDevice::MIDIDevice(MIDIDevice *this, MIDIDriverPlugin *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5)
{
  uint64_t v9;
  _QWORD *v10;
  __CFString *v11;
  __CFString *v12;

  MIDIObject::MIDIObject(this, 0, a3);
  *(_QWORD *)(v9 + 48) = 0;
  v10 = (_QWORD *)(v9 + 48);
  *(_QWORD *)v9 = &off_1E98B9260;
  *(_BYTE *)(v9 + 56) = 1;
  *(_QWORD *)(v9 + 72) = &off_1E98B9770;
  *(_QWORD *)(v9 + 88) = 0;
  *(_QWORD *)(v9 + 96) = 0;
  *(_QWORD *)(v9 + 80) = 0;
  *(_QWORD *)(v9 + 64) = a2;
  if (a2)
  {
    v12 = 0;
    if (MIDIObject::GetStringProperty(a2, kMIDIPropertyName, (const __CFString **)&v12))
      v11 = 0;
    else
      v11 = v12;
  }
  else
  {
    v11 = 0;
  }
  XCFObject<__CFString const*>::Set((uint64_t)v10, v11);
  if (*v10)
    (*(void (**)(MIDIDevice *, const CFStringRef))(*(_QWORD *)this + 40))(this, kMIDIPropertyDriverOwner);
  (*(void (**)(MIDIDevice *, const CFStringRef, const __CFString *))(*(_QWORD *)this + 40))(this, kMIDIPropertyManufacturer, a4);
  (*(void (**)(MIDIDevice *, const CFStringRef, const __CFString *))(*(_QWORD *)this + 40))(this, kMIDIPropertyModel, a5);
  *((_QWORD *)this + 2) = *((_QWORD *)this + 8);
}

void sub_1D4EEFCBC(_Unwind_Exception *a1)
{
  BaseOpaqueObject *v1;
  uint64_t v2;
  _QWORD *v3;

  OwnedPtrVector<MIDIEntity *>::~OwnedPtrVector(v3);
  XCFObject<__CFString const*>::~XCFObject(v2);
  *(_QWORD *)v1 = off_1E98B9320;
  XCFObject<__CFDictionary const*>::~XCFObject((uint64_t)v1 + 24);
  BaseOpaqueObject::~BaseOpaqueObject(v1);
  _Unwind_Resume(a1);
}

void MIDISource::MIDISource(MIDISource *this, MIDIDriverPlugin *a2, MIDIEntity *a3, MIDIProtocolID a4, const __CFString *a5)
{
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  MIDIEntity *v12;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  MIDIDriverPlugin *v20;
  __int16 v21;
  MIDIEntity **v22;
  __int16 v23;
  MIDIProtocolID v24;
  __int16 v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v12 = a3;
  MIDIEndpoint::MIDIEndpoint(this, 0, a2, a3, a4, 0);
  *(_QWORD *)v8 = &off_1E98B9380;
  *(_OWORD *)(v8 + 96) = 0u;
  *(_WORD *)(v8 + 160) = 0;
  *(_QWORD *)(v8 + 168) = 0;
  *(_WORD *)(v8 + 176) = 0;
  *(_OWORD *)(v8 + 112) = 0u;
  *(_OWORD *)(v8 + 128) = 0u;
  *(_QWORD *)(v8 + 144) = 0;
  gMIDIDeviceTableLog();
  v9 = gMIDIDeviceTableLog(void)::dtable;
  if (os_log_type_enabled((os_log_t)gMIDIDeviceTableLog(void)::dtable, OS_LOG_TYPE_DEBUG))
  {
    v10 = *((unsigned int *)this + 2);
    *(_DWORD *)buf = 136316674;
    v14 = "DeviceTable.cpp";
    v15 = 1024;
    v16 = 704;
    v17 = 2048;
    v18 = v10;
    v19 = 2048;
    v20 = a2;
    v21 = 2048;
    v22 = &v12;
    v23 = 1024;
    v24 = a4;
    v25 = 2112;
    v26 = 0;
    _os_log_impl(&dword_1D4E88000, v9, OS_LOG_TYPE_DEBUG, "%25s:%-5d MIDISource(ref 0x%lx)::MIDISource() - driver:%p entity:%p protocol:%d name:%@", buf, 0x40u);
  }
  MIDISource::CreateCISniffer((uint64_t **)this);
  if (*((_BYTE *)this + 88))
  {
    v11 = operator new();
    *(_BYTE *)v11 = 0;
    *(_QWORD *)(v11 + 64) = 0;
    *(_OWORD *)(v11 + 16) = 0u;
    *(_OWORD *)(v11 + 32) = 0u;
    *(_OWORD *)(v11 + 44) = 0u;
  }
  else
  {
    v11 = 0;
  }
  *((_QWORD *)this + 19) = v11;
}

void sub_1D4EEFE98(_Unwind_Exception *a1)
{
  BaseOpaqueObject *v1;
  uint64_t **v2;
  void **v3;
  uint64_t v5;
  void *v6;
  void *v7;

  std::unique_ptr<MIDICISniffer>::reset[abi:ne180100](v2, 0);
  v5 = *((_QWORD *)v1 + 18);
  *((_QWORD *)v1 + 18) = 0;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  v6 = (void *)*((_QWORD *)v1 + 15);
  if (v6)
  {
    *((_QWORD *)v1 + 16) = v6;
    operator delete(v6);
  }
  v7 = *v3;
  if (*v3)
  {
    *((_QWORD *)v1 + 13) = v7;
    operator delete(v7);
  }
  *(_QWORD *)v1 = off_1E98B9320;
  XCFObject<__CFDictionary const*>::~XCFObject((uint64_t)v1 + 24);
  BaseOpaqueObject::~BaseOpaqueObject(v1);
  _Unwind_Resume(a1);
}

void MIDIDestination::MIDIDestination(MIDIDestination *this, MIDIDriverPlugin *a2, MIDIEntity *a3, MIDIProtocolID a4, const __CFString *a5)
{
  uint64_t v9;
  _QWORD *v10;
  char *v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  NSObject *v16;
  uint64_t v17;
  int v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  MIDIDriverPlugin *v25;
  __int16 v26;
  MIDIEntity *v27;
  __int16 v28;
  MIDIProtocolID v29;
  __int16 v30;
  uint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  MIDIEndpoint::MIDIEndpoint(this, 0, a2, a3, a4, 0);
  v9 = 0;
  *v10 = &off_1E98B9870;
  do
  {
    v11 = (char *)this + v9;
    *((_DWORD *)v11 + 24) = 0;
    *((_QWORD *)v11 + 13) = 0;
    *((_QWORD *)v11 + 14) = 0;
    v9 += 24;
  }
  while (v9 != 384);
  v12 = -384;
  v13 = 0uLL;
  do
  {
    *(_QWORD *)&v14 = (char *)this + v12 + 864;
    *((_QWORD *)&v14 + 1) = (char *)this + v12 + 888;
    v15 = v14;
    vst3q_f64((double *)v14, *(float64x2x3_t *)(&v13 - 2));
    v12 += 48;
  }
  while (v12);
  *((_DWORD *)this + 216) = 3125;
  *((_DWORD *)this + 223) = 0;
  *(_QWORD *)((char *)this + 876) = 0;
  *(_QWORD *)((char *)this + 884) = 0;
  *(_QWORD *)((char *)this + 868) = 0;
  gMIDIDeviceTableLog();
  v16 = gMIDIDeviceTableLog(void)::dtable;
  if (os_log_type_enabled((os_log_t)gMIDIDeviceTableLog(void)::dtable, OS_LOG_TYPE_DEBUG))
  {
    v17 = *((unsigned int *)this + 2);
    v18 = 136316674;
    v19 = "DeviceTable.cpp";
    v20 = 1024;
    v21 = 986;
    v22 = 2048;
    v23 = v17;
    v24 = 2048;
    v25 = a2;
    v26 = 2048;
    v27 = a3;
    v28 = 1024;
    v29 = a4;
    v30 = 2112;
    v31 = 0;
    _os_log_impl(&dword_1D4E88000, v16, OS_LOG_TYPE_DEBUG, "%25s:%-5d [*] MIDIDestination(ref 0x%lx)::MIDIDestination() - driver:%p entity:%p protocol:%d name:%@", (uint8_t *)&v18, 0x40u);
  }
  MIDIDestination::Init((uint64_t)this);
}

void sub_1D4EF009C(_Unwind_Exception *a1)
{
  BaseOpaqueObject *v1;
  uint64_t v3;
  uint64_t i;

  v3 = *((_QWORD *)v1 + 109);
  *((_QWORD *)v1 + 109) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  for (i = 840; i != 456; i -= 24)
    std::__list_imp<MergeQueueElem>::clear((BaseOpaqueObject *)((char *)v1 + i));
  *(_QWORD *)v1 = off_1E98B9320;
  XCFObject<__CFDictionary const*>::~XCFObject((uint64_t)v1 + 24);
  BaseOpaqueObject::~BaseOpaqueObject(v1);
  _Unwind_Resume(a1);
}

void MIDIEndpoint::MIDIEndpoint(MIDIEndpoint *this, MIDIClient *a2, MIDIDriverPlugin *a3, MIDIEntity *a4, MIDIProtocolID a5, const __CFString *a6)
{
  uint64_t v10;

  MIDIObject::MIDIObject(this, a4, a6);
  *(_QWORD *)v10 = off_1E98B9480;
  *(_DWORD *)(v10 + 44) = a5;
  *(_QWORD *)(v10 + 48) = a2;
  *(_QWORD *)(v10 + 56) = a3;
  *(_DWORD *)(v10 + 92) = 0;
  *(_QWORD *)(v10 + 72) = 0;
  *(_QWORD *)(v10 + 80) = 0;
  *(_QWORD *)(v10 + 64) = a4;
  *(_DWORD *)(v10 + 87) = 0;
  MIDIEndpoint::SetIsVirtual((MIDIEndpoint *)v10);
}

void sub_1D4EF0168(_Unwind_Exception *a1)
{
  BaseOpaqueObject *v1;

  *(_QWORD *)v1 = off_1E98B9320;
  XCFObject<__CFDictionary const*>::~XCFObject((uint64_t)v1 + 24);
  BaseOpaqueObject::~BaseOpaqueObject(v1);
  _Unwind_Resume(a1);
}

BOOL MIDIEndpoint::IsPartOfLegacyDevice(MIDIEndpoint *this)
{
  uint64_t v1;
  MIDIObject *v2;
  BOOL v3;
  int v5;

  if (!*((_QWORD *)this + 7))
    return 0;
  v1 = *((_QWORD *)this + 8);
  if (!v1)
    return 0;
  v2 = *(MIDIObject **)(v1 + 48);
  v5 = 0;
  if (MIDIObject::GetIntegerProperty(v2, CFSTR("UMP Enabled"), &v5))
    v3 = 0;
  else
    v3 = v5 == 1;
  return !v3;
}

BOOL MIDIEndpoint::IsPartOfUMPDevice(MIDIEndpoint *this)
{
  uint64_t v1;
  MIDIObject *v2;
  int v5;

  if (!*((_QWORD *)this + 7))
    return 0;
  v1 = *((_QWORD *)this + 8);
  if (!v1)
    return 0;
  v2 = *(MIDIObject **)(v1 + 48);
  v5 = 0;
  return !MIDIObject::GetIntegerProperty(v2, CFSTR("UMP Enabled"), &v5) && v5 == 1;
}

MIDIObject *MIDIEndpoint::IsPartOfPhantomEntity(MIDIObject *this)
{
  int v2;

  if (this)
  {
    v2 = 0;
    return (MIDIObject *)(!MIDIObject::GetIntegerProperty(this, kMIDIPropertyUMPCanTransmitGroupless, &v2)
                       && v2 == 1);
  }
  return this;
}

BOOL MIDIEndpoint::IsPartOfUMPEndpoint(MIDIEndpoint *this)
{
  int IntegerProperty;
  _BOOL8 result;
  int v4;

  v4 = 0;
  IntegerProperty = MIDIObject::GetIntegerProperty(this, kMIDIPropertyUMPActiveGroupBitmap, &v4);
  result = 0;
  if (!IntegerProperty)
    return ((unsigned __int16)v4 & (unsigned __int16)(v4 - 1)) != 0 || (unsigned __int16)v4 == 0;
  return result;
}

uint64_t MIDISource::DisconnectPort(MIDIInputPort ***this, MIDIInputPort *a2)
{
  uint64_t *v4;
  int v5;
  int v6;
  MIDIInputPort **v7;
  MIDIInputPort **v8;
  MIDIInputPort **v9;
  uint64_t v10;
  int64_t v11;
  MIDIInputPort **v12;

  v4 = MIDIServer::defaultInstance((MIDIServer *)this) + 13;
  v5 = (*(uint64_t (**)(uint64_t *))(*v4 + 16))(v4);
  v6 = v5;
  v7 = this[12];
  v8 = this[13];
  if (v7 == v8)
  {
LABEL_5:
    v10 = 4294956463;
    if (!v5)
      return v10;
    goto LABEL_13;
  }
  v9 = this[12];
  while (*v9 != a2)
  {
    if (++v9 == v8)
      goto LABEL_5;
  }
  v11 = (char *)v8 - (char *)(v9 + 1);
  if (v8 != v9 + 1)
  {
    memmove(v9, v9 + 1, (char *)v8 - (char *)(v9 + 1));
    v7 = this[12];
  }
  this[13] = (MIDIInputPort **)((char *)v9 + v11);
  if (v7 == (MIDIInputPort **)((char *)v9 + v11))
  {
    v12 = this[7];
    if (v12)
      (*((void (**)(MIDIInputPort **, _QWORD, _QWORD))*v12 + 14))(v12, *((unsigned int *)this + 2), 0);
  }
  MIDIInputPort::RemoveConnectedSource(a2, (uint64_t)this);
  v10 = 0;
  if (v6)
LABEL_13:
    (*(void (**)(uint64_t *))(*v4 + 24))(v4);
  return v10;
}

void sub_1D4EF03CC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  int v2;

  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

uint64_t caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<MIDISource::AddThruConnection(MIDIConnection *)::$_0>(caulk::inplace_function_detail::wrapper<MIDISource::AddThruConnection(MIDIConnection *)::$_0>)::{lambda(void *,MIDI::EventList const*&&)#1}::__invoke(uint64_t result, _DWORD **a2)
{
  _QWORD *v2;
  _QWORD *v3;
  _DWORD *v4;
  unsigned __int8 *v5;
  uint64_t v6;
  _BYTE *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  _DWORD *v12;
  unint64_t v13;
  unint64_t v14;
  int v15;
  unsigned __int8 *v16;
  int v17;
  char v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  char v24;
  uint64_t v25;
  char v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  char v34;
  char v35;
  __int32 v36;
  unsigned int v37;
  unsigned int v38;
  unsigned __int16 *v39;
  char v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  char v46;
  unsigned int v47;
  uint64_t **v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  unsigned int v52;
  int v53;
  unsigned int v54;
  unsigned int v55;
  unsigned int v56;
  int v57;
  unsigned int v58;
  unsigned int v59;
  int v60;
  uint64_t v61;
  int8x8_t v62;
  int8x8_t v63;
  int8x8_t v64;
  int8x8_t v65;
  char v66;
  char *v67;
  uint64_t v68;
  uint64_t v69;
  int *v70;
  uint64_t v71;
  _DWORD *v73;
  _QWORD *v74;
  uint64_t v75;
  _BYTE *v76;
  _QWORD *v77;
  unsigned int v78;
  uint64_t v79;
  __int32 v80;
  int v81;
  unsigned int v82;
  unsigned int v83;
  int v84;
  uint64_t v85;
  unint64_t v86;
  unsigned __int16 v87[2];
  uint64_t *v88;
  uint64_t v89;
  uint64_t (**v90)();
  uint64_t (***v91)();
  _QWORD *v92;
  uint64_t v93;
  _QWORD v94[130];

  v94[128] = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD **)(*(_QWORD *)result + 120);
  v3 = *(_QWORD **)(*(_QWORD *)result + 128);
  if (v2 != v3)
  {
    v4 = *a2;
    v75 = (uint64_t)(*a2 + 2);
    v5 = MIDI::UniversalPacket::word_sizes;
    v73 = *a2;
    v74 = *(_QWORD **)(*(_QWORD *)result + 128);
    do
    {
      if (*v4 != 1)
LABEL_125:
        std::terminate();
      v6 = *v2;
      v7 = (_BYTE *)(*v2 + 14412);
      if (!*v7)
      {
        v8 = *(_QWORD *)(v6 + 40);
        if (v8)
        {
          *v7 = 1;
          v90 = caulk::inplace_function<void ()(MIDI::EventList const*),48ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<ConnectionEmitter::ConnectionEmitter(MIDIConnection *)::{lambda(MIDI::EventList const*)#1}>;
          v91 = &v90;
          v93 = 1;
          v92 = v94;
          v94[127] = v6;
          if ((int)v4[1] >= 1)
          {
            v9 = v4[1];
            v76 = v7;
            v77 = v2;
            v85 = v6 + 72;
            v79 = v6 + 7240;
            v10 = v75;
            do
            {
              v11 = *(unsigned int *)(v10 + 8);
              if ((_DWORD)v11)
              {
                v84 = v9;
                v12 = (_DWORD *)(v10 + 12);
                v86 = v10 + 12 + 4 * v11;
                do
                {
                  v13 = *v12;
                  v14 = v13 >> 28;
                  if (((*v12 >> 28) - 1) >= 2)
                  {
                    if ((_DWORD)v14 == 3)
                    {
                      v24 = *(_BYTE *)(v8 + 184);
                      if (!v24)
                      {
                        v25 = 0;
                        do
                        {
                          v26 = v24;
                          MIDI::Packetizer::add((MIDI::Packetizer *)&v90, *(_QWORD *)v10, v12[v25]);
                          v24 = 1;
                          v25 = 1;
                        }
                        while ((v26 & 1) == 0);
                        MIDI::StreamState::update_with_v1_packets(v85, v12, 2);
                        v12 += 2;
                      }
                    }
                  }
                  else
                  {
                    v15 = BYTE2(v13);
                    v16 = v5;
                    v17 = v13 & 0xFF000000;
                    v18 = BYTE2(*v12);
                    v5 = (unsigned __int8 *)BYTE1(v13);
                    v19 = *v12;
                    switch(BYTE2(v13) >> 4)
                    {
                      case 8:
                      case 9:
                        v20 = *(unsigned __int16 *)(v8 + 160);
                        if (v20 == 1)
                          goto LABEL_114;
                        v21 = *(unsigned __int16 *)(v8 + 164);
                        if (v21 == 1)
                          goto LABEL_114;
                        v22 = *(unsigned __int8 *)(v8 + 158);
                        v23 = *(unsigned __int8 *)(v8 + 159);
                        if (v22 <= v23)
                        {
                          if (BYTE1(v13) < v22)
                            goto LABEL_114;
                        }
                        else if (BYTE1(v13) >= v22)
                        {
                          goto LABEL_73;
                        }
                        if (BYTE1(v13) > v23)
                          goto LABEL_114;
LABEL_73:
                        v52 = *(unsigned __int8 *)(v8 + ((v13 >> 16) & 0xF) + 140);
                        if (v52 <= 0xF)
                        {
                          if (v20 >= 8)
                          {
                            v87[1] = (unsigned __int16)v5;
                            v53 = v17;
                            v83 = v19;
                            v54 = v21;
                            TransformValue(v8, v20, *(__int16 *)(v8 + 162), &v87[1], 0);
                            v21 = v54;
                            v19 = v83;
                            v17 = v53;
                            LODWORD(v5) = v87[1];
                          }
                          v15 = v18 & 0xF0 | v52;
                          v55 = *(unsigned __int8 *)(v8 + 156);
                          v56 = *(unsigned __int8 *)(v8 + 157);
                          v57 = v18 & 0xF0 | v52 & 0xF0;
                          if (!(v56 | v55))
                            goto LABEL_98;
                          if (v19 && v57 == 144)
                          {
                            if (v19 >= v55 && v19 <= v56)
                              goto LABEL_101;
                          }
                          else
                          {
                            if (v5 >= 0x80)
                              goto LABEL_125;
                            if (*(_BYTE *)(v85 + 448 * v52 + v5 + 4))
                            {
LABEL_98:
                              if (v19 || v57 == 128)
                              {
LABEL_101:
                                if (v21 >= 8)
                                {
                                  v87[1] = v19;
                                  v59 = *(__int16 *)(v8 + 166);
                                  v60 = v17;
                                  v61 = v8;
                                  v30 = v21;
LABEL_103:
                                  TransformValue(v61, v30, v59, &v87[1], 0);
                                  v17 = v60;
                                  v19 = v87[1];
                                }
                              }
                              else
                              {
                                v19 = 0;
                              }
LABEL_104:
                              LODWORD(v88) = (v15 << 16) | ((_DWORD)v5 << 8) | v19 | v17;
                              MIDI::Packetizer::add((MIDI::Packetizer *)&v90, *(_QWORD *)v10, (int)v88);
                              MIDI::StreamState::update_with_v1_packets(v85, &v88, 1);
                              v5 = v16;
                              break;
                            }
                          }
                        }
LABEL_114:
                        v5 = v16;
                        break;
                      case 0xA:
                        v30 = *(unsigned __int16 *)(v8 + 168);
                        if (v30 == 1)
                          goto LABEL_114;
                        v31 = *(unsigned __int8 *)(v8 + 158);
                        v32 = *(unsigned __int8 *)(v8 + 159);
                        if (v31 <= v32)
                        {
                          if (BYTE1(v13) < v31)
                            goto LABEL_114;
                        }
                        else if (BYTE1(v13) >= v31)
                        {
                          goto LABEL_84;
                        }
                        if (BYTE1(v13) > v32)
                          goto LABEL_114;
LABEL_84:
                        v58 = *(unsigned __int8 *)(v8 + ((v13 >> 16) & 0xF) + 140);
                        if (v58 > 0xF)
                          goto LABEL_114;
                        v15 = BYTE2(v13) & 0xF0 | v58;
                        if (v30 < 8)
                          goto LABEL_104;
                        v87[1] = *v12;
                        v59 = *(__int16 *)(v8 + 170);
                        v60 = v13 & 0xFF000000;
                        v61 = v8;
                        goto LABEL_103;
                      case 0xB:
                        if (*(_BYTE *)(v8 + 191))
                          goto LABEL_114;
                        v33 = *(unsigned __int8 *)(v8 + ((v13 >> 16) & 0xF) + 140);
                        if (v33 > 0xF)
                          goto LABEL_114;
                        v81 = v13 & 0xFF000000;
                        v82 = *v12;
                        *(_DWORD *)v87 = 0;
                        if ((MIDI::ControlState::interpret_control((MIDI::ControlState *)(v79 + 448 * ((v13 >> 16) & 0xF) + 296), BYTE1(v13), v13, &v87[1], v87) & 1) != 0)goto LABEL_114;
                        v15 = BYTE2(v13) & 0xF0 | v33;
                        v17 = v13 & 0xFF000000;
                        v19 = v13;
                        if (!*(_WORD *)(v8 + 192))
                          goto LABEL_104;
                        v34 = 0;
                        v35 = 0;
                        v36 = v87[1];
                        v37 = (v13 >> 8) & 0x3F;
                        v38 = *(unsigned __int16 *)(v8 + 192) + 1;
                        v39 = (unsigned __int16 *)(v8 + 210);
                        v78 = v37;
                        do
                        {
                          v40 = *((_BYTE *)v39 - 6);
                          switch(v40)
                          {
                            case 0:
                              if ((_DWORD)v5 == *(v39 - 2))
                                goto LABEL_45;
                              goto LABEL_54;
                            case 1:
                              if (v37 == *(v39 - 2))
                                goto LABEL_45;
                              goto LABEL_54;
                            case 2:
                            case 3:
                              if ((v36 & 0x4000) == 0)
                                goto LABEL_54;
                              v41 = v36 & 0x3FFF;
                              break;
                            case 4:
                            case 5:
                              if ((v36 & 0x8000) == 0)
                                goto LABEL_54;
                              v41 = v36 & 0x3FFF;
                              break;
                            default:
                              goto LABEL_54;
                          }
                          if (v41 == *(v39 - 2))
                          {
LABEL_45:
                            v42 = *(v39 - 1);
                            if (*(v39 - 1))
                            {
                              if (v42 == 2)
                              {
                                v43 = *v39;
                                v44 = v43 | 0x4000;
                                v35 = *((_BYTE *)v39 - 5);
                                v45 = v43 | ((v35 & 4) << 13);
                                if ((v35 & 2) != 0)
                                  v36 = v44;
                                else
                                  v36 = v45;
                                v34 = 1;
                              }
                              else
                              {
                                if (v42 == 1)
                                  goto LABEL_114;
                                v80 = v36;
                                TransformValue(v8, v42, (__int16)*v39, v87, 1);
                                v34 = 1;
                                v37 = v78;
                                v36 = v80;
                                v17 = v81;
                                v35 = v40;
                                v19 = v82;
                              }
                            }
                            else
                            {
                              v35 = *((_BYTE *)v39 - 6);
                            }
                          }
LABEL_54:
                          --v38;
                          v39 += 4;
                        }
                        while (v38 > 1);
                        if ((v34 & 1) == 0)
                          goto LABEL_104;
                        v46 = v35;
                        if ((v35 & 2) != 0)
                        {
                          v47 = v17 | (v15 << 16);
                          v62.i32[0] = (unsigned __int16)v36 >> 7;
                          v62.i32[1] = v36;
                          v63 = vand_s8(v62, (int8x8_t)0x7F0000007FLL);
                          v64 = vorr_s8((int8x8_t)vdup_n_s32(v47), (int8x8_t)0x640000006500);
                        }
                        else
                        {
                          if ((v35 & 4) == 0)
                          {
                            v47 = v17 | (v15 << 16);
                            v48 = &v88;
                            goto LABEL_108;
                          }
                          v47 = v17 | (v15 << 16);
                          v65.i32[0] = (unsigned __int16)v36 >> 7;
                          v65.i32[1] = v36;
                          v63 = vand_s8(v65, (int8x8_t)0x7F0000007FLL);
                          v64 = vorr_s8((int8x8_t)vdup_n_s32(v47), (int8x8_t)0x620000006300);
                        }
                        v88 = (uint64_t *)vorr_s8(v64, v63);
                        LOWORD(v36) = 6;
                        v48 = (uint64_t **)&v89;
LABEL_108:
                        v66 = v87[0];
                        *(_DWORD *)v48 = (v87[0] >> 7) & 0x7F | ((unsigned __int16)v36 << 8) | v47;
                        v67 = (char *)v48 + 4;
                        if ((v46 & 1) != 0)
                        {
                          v67 = (char *)(v48 + 1);
                          *((_DWORD *)v48 + 1) = (((unsigned __int16)v36 << 8) + 0x2000) | v47 | v66 & 0x7F;
                        }
                        v68 = (v67 - (char *)&v88) >> 2;
                        if (v67 != (char *)&v88)
                        {
                          v69 = 4 * v68;
                          v70 = (int *)&v88;
                          do
                          {
                            MIDI::Packetizer::add((MIDI::Packetizer *)&v90, *(_QWORD *)v10, *v70++);
                            v69 -= 4;
                          }
                          while (v69);
                        }
                        MIDI::StreamState::update_with_v1_packets(v85, &v88, v68);
                        goto LABEL_114;
                      case 0xC:
                        v27 = *(unsigned __int16 *)(v8 + 176);
                        if (v27 == 1)
                          goto LABEL_114;
                        v28 = *(unsigned __int8 *)(v8 + ((v13 >> 16) & 0xF) + 140);
                        if (v28 > 0xF)
                          goto LABEL_114;
                        v15 = BYTE2(v13) & 0xF0 | v28;
                        if (v27 < 8)
                          goto LABEL_104;
                        v87[1] = BYTE1(v13);
                        v29 = *(__int16 *)(v8 + 178);
                        goto LABEL_66;
                      case 0xD:
                        v27 = *(unsigned __int16 *)(v8 + 172);
                        if (v27 == 1)
                          goto LABEL_114;
                        v49 = *(unsigned __int8 *)(v8 + ((v13 >> 16) & 0xF) + 140);
                        if (v49 > 0xF)
                          goto LABEL_114;
                        v15 = BYTE2(v13) & 0xF0 | v49;
                        if (v27 < 8)
                          goto LABEL_104;
                        v87[1] = BYTE1(v13);
                        v29 = *(__int16 *)(v8 + 174);
LABEL_66:
                        TransformValue(v8, v27, v29, &v87[1], 0);
                        v19 = v13;
                        v17 = v13 & 0xFF000000;
                        LODWORD(v5) = v87[1];
                        goto LABEL_104;
                      case 0xE:
                        v50 = *(unsigned __int16 *)(v8 + 180);
                        if (v50 == 1)
                          goto LABEL_114;
                        v51 = *(unsigned __int8 *)(v8 + (WORD1(v13) & 0xF) + 140);
                        if (v51 > 0xF)
                          goto LABEL_114;
                        v15 = BYTE2(v13) & 0xF0 | v51;
                        if (v50 >= 8)
                        {
                          v87[1] = BYTE1(v13) + ((_WORD)v19 << 7);
                          TransformValue(v8, v50, *(__int16 *)(v8 + 182), &v87[1], 1);
                          v17 = v13 & 0xFF000000;
                          v19 = v87[1] >> 7;
                          LODWORD(v5) = v87[1] & 0x7F;
                        }
                        goto LABEL_104;
                      case 0xF:
                        switch(BYTE2(v13))
                        {
                          case 0xF1:
                            if (*(_BYTE *)(v8 + 185))
                              goto LABEL_114;
                            v15 = 241;
                            break;
                          case 0xF2:
                            if (*(_BYTE *)(v8 + 186))
                              goto LABEL_114;
                            v15 = 242;
                            break;
                          case 0xF3:
                            if (*(_BYTE *)(v8 + 186))
                              goto LABEL_114;
                            v15 = 243;
                            break;
                          case 0xF6:
                            if (*(_BYTE *)(v8 + 187))
                              goto LABEL_114;
                            v15 = 246;
                            break;
                          case 0xF8:
                          case 0xFA:
                          case 0xFB:
                          case 0xFC:
                            if (!*(_BYTE *)(v8 + 186))
                              goto LABEL_104;
                            goto LABEL_114;
                          default:
                            goto LABEL_104;
                        }
                        goto LABEL_104;
                      default:
                        break;
                    }
                  }
                  v12 += v5[v14];
                }
                while ((unint64_t)v12 < v86);
                v71 = *(unsigned int *)(v10 + 8);
                v9 = v84;
              }
              else
              {
                v71 = 0;
              }
              v10 += 4 * v71 + 12;
            }
            while (v9-- > 1);
            v7 = v76;
            v2 = v77;
            v4 = v73;
            v3 = v74;
            if (HIDWORD(v93))
            {
              v88 = &v93;
              ((void (*)(uint64_t (****)(), uint64_t **))*v90)(&v91, &v88);
            }
          }
          HIDWORD(v93) = 0;
          v92 = v94;
          *v7 = 0;
          result = MIDI::PacketizerBase<MIDI::EventList>::~PacketizerBase((uint64_t)&v90);
        }
      }
      ++v2;
    }
    while (v2 != v3);
  }
  return result;
}

void sub_1D4EF0C58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  MIDI::PacketizerBase<MIDI::EventList>::~PacketizerBase((uint64_t)&a28);
  _Unwind_Resume(a1);
}

_QWORD *caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<MIDISource::AddThruConnection(MIDIConnection *)::$_0>(caulk::inplace_function_detail::wrapper<MIDISource::AddThruConnection(MIDIConnection *)::$_0>)::{lambda(void *,void *)#1}::__invoke(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

_QWORD *caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<MIDISource::AddThruConnection(MIDIConnection *)::$_0>(caulk::inplace_function_detail::wrapper<MIDISource::AddThruConnection(MIDIConnection *)::$_0>)::{lambda(void *,void *)#2}::__invoke(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

uint64_t MIDISource::ReceivedPacketList(MIDISource *this, MIDIEventPacket *a2)
{
  unint64_t v4;
  uint64_t v5;
  unsigned __int8 v6;
  uint64_t *v7;
  unsigned int timeStamp_high;
  unsigned int *v9;
  unsigned int v10;
  int v11;
  unsigned int *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  int v19;
  int v20;
  unsigned int v21;
  BOOL v22;
  unsigned int v23;
  unsigned int v24;
  int v25;
  BOOL v26;
  char v27;
  int v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  int v32;
  int v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  int v37;
  BOOL v38;
  char v39;
  int v40;
  unsigned int *v41;
  unsigned int *v42;
  unsigned int v43;
  unsigned int v44;
  int v45;
  uint64_t v46;
  unsigned int *v47;
  unsigned int v48;
  unsigned int v49;
  _BOOL4 v51;
  _QWORD *v52;
  uint64_t v53;
  _QWORD *v54;
  unsigned int v55;
  MIDIEventPacket *v56;
  MIDISource *v57;
  __int128 v58;
  __int128 v59;
  uint64_t v60;
  __int128 v61;
  __int128 v62;
  uint64_t v63;
  UInt32 *v64;
  unsigned int v65;
  int v66;
  UInt32 *v67;
  MIDISource **v68;
  _QWORD v69[2];
  _DWORD v70[2];
  _DWORD v71[68];
  _DWORD *v72;
  uint64_t v73;
  _DWORD *v74;
  uint64_t v75;

  v75 = *MEMORY[0x1E0C80C00];
  if (*((_BYTE *)this + 161))
  {
    if (*((_BYTE *)this + 160))
    {
LABEL_3:
      v4 = atomic_load((unsigned __int16 *)this + 88);
      if ((_DWORD)v4)
      {
        v5 = 0;
        v6 = 0;
        do
        {
          if (((v4 >> v6) & 1) != 0)
          {
            v7 = (uint64_t *)*((_QWORD *)this + 21);
            MIDICISniffer::clearStateForGroup(v7, v6, 0, 0);
            *(_BYTE *)(*v7 + v5) = 0;
          }
          ++v6;
          v5 += 20;
        }
        while (v5 != 320);
        atomic_store(0, (unsigned __int16 *)this + 88);
      }
      v55 = 0;
      v69[0] = this;
      v69[1] = &v55;
      v72 = v70;
      v73 = 276;
      timeStamp_high = HIDWORD(a2->timeStamp);
      v70[0] = a2->timeStamp;
      v70[1] = 0;
      v74 = v71;
      v71[2] = 0;
      v56 = a2;
      v57 = this;
      v58 = 0u;
      v59 = 0u;
      v60 = 0;
      v67 = 0;
      v68 = &v57;
      v63 = 0;
      v64 = 0;
      v65 = timeStamp_high;
      if (timeStamp_high)
      {
        v63 = *(_QWORD *)&a2->wordCount;
        v64 = &a2->words[2];
        v67 = &a2->words[a2->words[1] + 2];
      }
      std::ranges::__find_if_impl[abi:ne180100]<MIDI::event_iterator<MIDI::detail::event_accessor>,MIDI::event_iterator<MIDI::detail::event_accessor>::sentinel,std::reference_wrapper<MIDISource::ReceivedPacketList(MIDI::EventList const*)::$_0>,std::identity>((MIDIServer *)&v61, (uint64_t)&v63, (uint64_t **)&v68);
      v58 = v61;
      v59 = v62;
      LOBYTE(v60) = 1;
      v9 = (unsigned int *)*((_QWORD *)&v62 + 1);
      v10 = v62;
      v11 = DWORD1(v62);
      v12 = (unsigned int *)*((_QWORD *)&v61 + 1);
      v13 = v61;
      while (1)
      {
        if (v12 == v9)
        {
          if (v10 < 2)
            goto LABEL_92;
          --v10;
          v13 = *(_QWORD *)v12;
          v14 = v12[2];
          v12 += 3;
          v9 = &v12[v14];
        }
        if (v12 == v9)
        {
LABEL_92:
          MIDI::ChunkedEventListEmitter<MIDISource::ReceivedPacketList(MIDI::EventList const*)::$_1>::flush((uint64_t)v69);
          return v55;
        }
        v15 = *v12;
        v16 = MIDI::UniversalPacket::word_sizes[v15 >> 28];
        v17 = (uint64_t)v74;
        if (!MIDI::UniversalPacket::word_sizes[v15 >> 28])
        {
          if (v74)
          {
            LODWORD(v16) = 0;
            goto LABEL_91;
          }
          goto LABEL_46;
        }
        v18 = (unint64_t)&v72[(unint64_t)v73 / 4];
        v19 = v15 & 0xF0000000;
        v20 = v72[1];
        if (v74)
        {
          if (v20)
            break;
        }
        if (!v20)
          goto LABEL_45;
        if (v74)
          goto LABEL_36;
        if (v19 != 805306368)
          goto LABEL_41;
LABEL_44:
        v17 = (uint64_t)&v74[v74[2] + 3];
LABEL_45:
        if (v17 + 4 * v16 + 12 <= v18)
        {
          v29 = 0;
          v72[1] = v20 + 1;
          *(_QWORD *)v17 = v13;
          *(_DWORD *)(v17 + 8) = 0;
LABEL_63:
          v41 = (unsigned int *)(v17 + 4 * v29 + 12);
          v42 = v12;
          switch((int)v16)
          {
            case 1:
              goto LABEL_67;
            case 2:
              goto LABEL_66;
            case 3:
              goto LABEL_65;
            case 4:
              v42 = v12 + 1;
              *v41 = *v12;
              v41 = (unsigned int *)(v17 + 4 * v29 + 16);
LABEL_65:
              v43 = *v42++;
              *v41++ = v43;
LABEL_66:
              v44 = *v42++;
              *v41++ = v44;
LABEL_67:
              *v41 = *v42;
              break;
            default:
              goto LABEL_88;
          }
          goto LABEL_89;
        }
LABEL_46:
        MIDI::ChunkedEventListEmitter<MIDISource::ReceivedPacketList(MIDI::EventList const*)::$_1>::flush((uint64_t)v69);
        v30 = *v12;
        v16 = MIDI::UniversalPacket::word_sizes[v30 >> 28];
        v17 = (uint64_t)v74;
        if (!MIDI::UniversalPacket::word_sizes[v30 >> 28])
        {
          v45 = 0;
          if (v74)
            goto LABEL_90;
          goto LABEL_91;
        }
        v31 = (unint64_t)&v72[(unint64_t)v73 / 4];
        v32 = v30 & 0xF0000000;
        v33 = v72[1];
        if (v74 && v33)
        {
          v34 = v74[2];
          v22 = v34 >= 2;
          v35 = v34 - 2;
          if (v22 && v74[3] >> 28 == 3)
          {
            v36 = v74[v35 + 3];
            if (v36 >> 28 == 3)
              v37 = (v36 >> 20) & 0xF;
            else
              v37 = 255;
            if (v37)
              v38 = v37 == 3;
            else
              v38 = 1;
            v39 = v38;
            v40 = 1;
          }
          else
          {
LABEL_72:
            v40 = 0;
            v39 = 0;
          }
          if ((v30 & 0xF0E00000) == 0x30000000 || (v32 != 805306368) == v40 || *(_QWORD *)v74 != v13 || (v39 & 1) != 0)
          {
LABEL_80:
            v17 = (uint64_t)&v74[v74[2] + 3];
LABEL_81:
            if (v17 + 4 * v16 + 12 > v31)
              goto LABEL_91;
            v46 = 0;
            v72[1] = v33 + 1;
            *(_QWORD *)v17 = v13;
            *(_DWORD *)(v17 + 8) = 0;
LABEL_83:
            v41 = (unsigned int *)(v17 + 4 * v46 + 12);
            v47 = v12;
            switch((int)v16)
            {
              case 1:
                goto LABEL_87;
              case 2:
                goto LABEL_86;
              case 3:
                goto LABEL_85;
              case 4:
                v47 = v12 + 1;
                *v41 = *v12;
                v41 = (unsigned int *)(v17 + 4 * v46 + 16);
LABEL_85:
                v48 = *v47++;
                *v41++ = v48;
LABEL_86:
                v49 = *v47++;
                *v41++ = v49;
LABEL_87:
                *v41 = *v47;
                break;
              default:
LABEL_88:
                memmove(v41, v12, 4 * v16);
                break;
            }
LABEL_89:
            *(_DWORD *)(v17 + 8) += v16;
            v45 = MIDI::UniversalPacket::word_sizes[(unint64_t)*v12 >> 28];
LABEL_90:
            v74 = (_DWORD *)v17;
            LODWORD(v16) = v45;
            goto LABEL_91;
          }
          goto LABEL_77;
        }
        if (!v33)
          goto LABEL_81;
        if (v74)
          goto LABEL_72;
        if (v32 == 805306368)
          goto LABEL_80;
LABEL_77:
        v46 = v74[2];
        if ((unint64_t)&v74[v46 + 3 + v16] <= v31)
          goto LABEL_83;
LABEL_91:
        v63 = v13;
        v64 = &v12[v16];
        v65 = v10;
        v66 = v11;
        v67 = v9;
        v68 = &v57;
        std::ranges::__find_if_impl[abi:ne180100]<MIDI::event_iterator<MIDI::detail::event_accessor>,MIDI::event_iterator<MIDI::detail::event_accessor>::sentinel,std::reference_wrapper<MIDISource::ReceivedPacketList(MIDI::EventList const*)::$_0>,std::identity>((MIDIServer *)&v61, (uint64_t)&v63, (uint64_t **)&v68);
        v12 = (unsigned int *)*((_QWORD *)&v61 + 1);
        v13 = v61;
        v10 = v62;
        v11 = DWORD1(v62);
        v9 = (unsigned int *)*((_QWORD *)&v62 + 1);
      }
      v21 = v74[2];
      v22 = v21 >= 2;
      v23 = v21 - 2;
      if (v22 && v74[3] >> 28 == 3)
      {
        v24 = v74[v23 + 3];
        if (v24 >> 28 == 3)
          v25 = (v24 >> 20) & 0xF;
        else
          v25 = 255;
        if (v25)
          v26 = v25 == 3;
        else
          v26 = 1;
        v27 = v26;
        v28 = 1;
      }
      else
      {
LABEL_36:
        v28 = 0;
        v27 = 0;
      }
      if ((v15 & 0xF0E00000) != 0x30000000 && (v19 != 805306368) != v28 && *(_QWORD *)v74 == v13 && (v27 & 1) == 0)
      {
LABEL_41:
        v29 = v74[2];
        if ((unint64_t)&v74[v29 + 3 + v16] <= v18)
          goto LABEL_63;
        goto LABEL_46;
      }
      goto LABEL_44;
    }
  }
  else
  {
    if (*((_BYTE *)this + 89))
      v51 = 0;
    else
      v51 = MIDIEndpoint::IsPartOfLegacyDevice(this)
         && (v52 = (_QWORD *)*((_QWORD *)this + 8)) != 0
         && v52[10] != v52[9]
         && (v54 = v52 + 13, v53 = v52[13], v54[1] != v53)
         && *(_DWORD *)(*(_QWORD *)v53 + 8)
         || MIDIEndpoint::IsPartOfUMPDevice(this)
         && (MIDIEndpoint::IsPartOfPhantomEntity(*((MIDIObject **)this + 8)) & 1) != 0
         || *((_QWORD *)this + 6) != 0;
    *((_WORD *)this + 80) = v51 | 0x100;
    if (v51)
      goto LABEL_3;
  }
  MIDISource::SchedulePacketList(this, a2);
  return 0;
}

void sub_1D4EF1258(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

void MIDISource::SchedulePacketList(MIDISource *this, MIDIEventPacket *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unsigned int v9;
  int v10;
  unsigned int v11;
  int v12;
  int timeStamp_high;
  UInt32 *p_wordCount;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unsigned int v18;
  int v19;
  int v20;
  uint64_t v21;
  const MIDIEventPacket *v22;
  int v23;
  unsigned int v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t v27;
  NSObject *v28;
  int v29;
  uint64_t v30;
  uint8_t buf[4];
  const char *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  MIDISource *v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  if (!HIDWORD(a2->timeStamp))
    return;
  v4 = *((_QWORD *)this + 19);
  if (!v4)
    goto LABEL_33;
  v30 = mach_absolute_time();
  mach_absolute_time();
  v5 = __udivti3();
  v6 = v5;
  v7 = *(_QWORD *)(v4 + 64);
  if (v7)
  {
    v8 = (v5 - v7) / 0x3B9ACA00uLL;
    if ((int)v8 < 8)
    {
      v29 = 0;
      goto LABEL_16;
    }
    if (v8 <= 0x10)
    {
      v9 = v8 - 7;
      v10 = *(_DWORD *)(v4 + 56);
      v11 = v9;
      do
      {
        *(_DWORD *)(v4 + 4 * v10 + 16) = 0;
        v12 = *(_DWORD *)(v4 + 56);
        if (v12 == 9)
          v10 = 0;
        else
          v10 = v12 + 1;
        *(_DWORD *)(v4 + 56) = v10;
        --v11;
      }
      while (v11);
      v7 += 1000000000 * v9;
    }
    else
    {
      *(_BYTE *)v4 = 0;
      v7 = v5 - 7000000000;
      *(_OWORD *)(v4 + 16) = 0u;
      *(_OWORD *)(v4 + 32) = 0u;
      *(_OWORD *)(v4 + 44) = 0u;
    }
  }
  else
  {
    *(_DWORD *)(v4 + 56) = 0;
    v7 = v5 - 7000000000;
  }
  *(_QWORD *)(v4 + 64) = v7;
  v29 = 1;
LABEL_16:
  timeStamp_high = HIDWORD(a2->timeStamp);
  if (timeStamp_high)
  {
    p_wordCount = &a2->wordCount;
    do
    {
      v15 = v6;
      if (*(_QWORD *)p_wordCount)
        v15 = __udivti3();
      v16 = (v15 - v7) / 0x3B9ACA00uLL;
      if (v16 <= 9)
      {
        v17 = v4 + 4 * ((*(_DWORD *)(v4 + 56) + (int)v16) % 10);
        *(_DWORD *)(v17 + 16) += 4 * p_wordCount[2];
      }
      p_wordCount += p_wordCount[2] + 3;
      --timeStamp_high;
    }
    while (timeStamp_high);
  }
  if (*(_BYTE *)v4)
  {
    if (v30 < *(_QWORD *)(v4 + 8))
      return;
    *(_BYTE *)v4 = 0;
  }
  if (!v29)
    goto LABEL_33;
  v18 = 0;
  v19 = *(_DWORD *)(v4 + 56);
  v20 = 6;
  do
  {
    v18 += *(_DWORD *)(v4 + 4 * v19 + 16);
    if (v19 == 9)
      v19 = 0;
    else
      ++v19;
    --v20;
  }
  while (v20);
  if (v18 < 0x15F96)
  {
LABEL_33:
    v21 = *((_QWORD *)this + 18);
    if (v21)
      (*(void (**)(uint64_t, MIDIEventPacket *))(*(_QWORD *)v21 + 16))(v21, a2);
    v22 = (const MIDIEventPacket *)&a2->wordCount;
    v23 = *((_DWORD *)this + 2);
    if (Scheduler::CheckSchedulePacket((Scheduler *)gScheduler, (uint64_t)this, v23, (MIDIProtocolID)LODWORD(a2->timeStamp), (const MIDIEventPacket *)&a2->wordCount))
    {
      if (HIDWORD(a2->timeStamp) >= 2)
      {
        v24 = 1;
        do
        {
          v22 = (const MIDIEventPacket *)((char *)v22 + 4 * v22->wordCount + 12);
          Scheduler::SchedulePacket(gScheduler, (uint64_t)this, v23, a2->timeStamp, v22);
          ++v24;
        }
        while (v24 < HIDWORD(a2->timeStamp));
      }
    }
    else
    {
      v25 = (uint64_t *)*((_QWORD *)this + 12);
      v26 = (uint64_t *)*((_QWORD *)this + 13);
      while (v25 != v26)
      {
        v27 = *v25++;
        MIDIInputPort::DeliverPacketsToInputPort(v27, (const MIDI::EventList *)a2, *((_DWORD *)this + 2));
      }
    }
    return;
  }
  *(_BYTE *)v4 = 1;
  *(_QWORD *)(v4 + 8) = v30 + 288000000;
  gMIDIDeviceTableLog();
  v28 = gMIDIDeviceTableLog(void)::dtable;
  if (os_log_type_enabled((os_log_t)gMIDIDeviceTableLog(void)::dtable, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315650;
    v32 = "DeviceTable.cpp";
    v33 = 1024;
    v34 = 916;
    v35 = 2048;
    v36 = this;
    _os_log_impl(&dword_1D4E88000, v28, OS_LOG_TYPE_ERROR, "%25s:%-5d feedback loop from MIDI source %p\n", buf, 0x1Cu);
  }
}

__n128 std::ranges::__find_if_impl[abi:ne180100]<MIDI::event_iterator<MIDI::detail::event_accessor>,MIDI::event_iterator<MIDI::detail::event_accessor>::sentinel,std::reference_wrapper<MIDISource::ReceivedPacketList(MIDI::EventList const*)::$_0>,std::identity>(MIDIServer *a1, uint64_t a2, uint64_t **a3)
{
  unsigned int *i;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unsigned int v10;
  BOOL v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  int v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  int v21;
  uint64_t *v22;
  unsigned int v23;
  int v24;
  char v25;
  int v26;
  uint64_t v27;
  int v28;
  int *v29;
  int v30;
  unsigned int v32;
  int v33;
  unsigned int v34;
  uint64_t v35;
  _BYTE *v36;
  uint64_t v37;
  char v38;
  char v39;
  unsigned int v40;
  uint64_t v41;
  uint64_t v42;
  unsigned __int8 *v43;
  unsigned int v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  int v49;
  int v50;
  int v51;
  uint64_t v52;
  unsigned int v53;
  unsigned int v54;
  _BYTE *v55;
  char v56;
  char v57;
  char v58;
  char v59;
  char v60;
  char v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  int v65;
  int v67;
  char v68;
  uint64_t *v69;
  __n128 result;
  __int128 v71;
  int v72;
  uint64_t v73;
  MIDIServer *v74;
  int v76;
  _BYTE v77[12];
  int v78;
  uint64_t v79;

  v74 = a1;
  for (i = *(unsigned int **)(a2 + 8); ; *(_QWORD *)(a2 + 8) = i)
  {
    v5 = *(_QWORD *)(a2 + 24);
    if (i == (unsigned int *)v5)
    {
      v6 = *(_DWORD *)(a2 + 16);
      if (v6 < 2)
        break;
      *(_DWORD *)(a2 + 16) = v6 - 1;
      *(_QWORD *)a2 = *(_QWORD *)i;
      *(_QWORD *)(a2 + 8) = i + 3;
      v5 = (uint64_t)&i[i[2] + 3];
      *(_QWORD *)(a2 + 24) = v5;
      i += 3;
    }
    if (i == (unsigned int *)v5)
      break;
    v7 = *(_QWORD *)a2;
    v8 = **a3;
    v9 = *i;
    v10 = v9 >> 28;
    if (v9 >> 28 == 15)
    {
      v69 = MIDIServer::defaultInstance(a1);
      AsyncMessenger::push(v69[99] + 32, 0, *(_DWORD *)(v8 + 8), v7, (char *)i);
      break;
    }
    if (v10)
      v11 = v10 == 15;
    else
      v11 = 1;
    if (v11)
      break;
    v12 = *(uint64_t **)(v8 + 168);
    v13 = *v12;
    v14 = (v9 >> 24) & 0xF;
    v15 = (char *)(*v12 + 20 * v14);
    v16 = *v15;
    if (*v15)
    {
      *(_QWORD *)v77 = *(_QWORD *)a2;
      v17 = v12[4];
      if (!v17)
        goto LABEL_95;
      a1 = (MIDIServer *)(*(uint64_t (**)(uint64_t, unsigned int *, _BYTE *))(*(_QWORD *)v17 + 48))(v17, i, v77);
      LODWORD(v9) = *i;
    }
    else
    {
      v24 = *(_DWORD *)(v13 + 20 * v14 + 4);
      if (v24 >= 1)
      {
        if ((v9 & 0xF0F80000) == 0x10F80000)
          break;
        if (v10 != 3 && (v24 - 4) > 0xFFFFFFFC)
        {
          v25 = 0;
          v26 = 0;
          goto LABEL_89;
        }
      }
    }
    v18 = v9 & 0xF0000;
    v76 = v16;
    if ((v9 & 0xF0E0FF00) == 0x30007E00 && v18 > 0x20000 && (v9 & 0xC0000) != 0)
    {
      v19 = i[1];
      if ((v19 & 0xFF000000) == 0xD000000)
      {
        if (BYTE2(v19) == 68)
          v20 = 5;
        else
          v20 = 3;
        if (BYTE2(v19) == 67)
          v21 = 4;
        else
          v21 = v20;
        v22 = v12;
        v23 = v14;
        goto LABEL_29;
      }
    }
    if ((v9 & 0xF0E00000) != 0x30000000)
      goto LABEL_36;
    if (v18 && (v9 & 0xFF00) == 0x7E00)
    {
      v22 = v12;
      v23 = v14;
      v21 = 2;
LABEL_29:
      a1 = (MIDIServer *)MIDICISniffer::clearStateForGroup(v22, v23, v21, 0);
      goto LABEL_36;
    }
    *(_DWORD *)(v13 + 20 * v14 + 4) = 1;
LABEL_36:
    v27 = v13 + 20 * v14;
    v30 = *(_DWORD *)(v27 + 4);
    v29 = (int *)(v27 + 4);
    v28 = v30;
    if (v30 >= 3 && *v15 == 0)
    {
      *(_QWORD *)v77 = v7;
      v64 = v12[4];
      if (!v64)
        goto LABEL_95;
      a1 = (MIDIServer *)(*(uint64_t (**)(uint64_t, unsigned int *, _BYTE *))(*(_QWORD *)v64 + 48))(v64, i, v77);
    }
    else if ((v28 - 1) <= 1)
    {
      v32 = *i;
      if ((*i & 0xF0000) != 0)
      {
        v33 = 0;
        v34 = 0;
        v35 = v13 + 20 * v14;
        v36 = (_BYTE *)(v35 + 18);
        v37 = v35 + 8;
        do
        {
          if (v34 <= 5)
          {
            if (v34 >= 2)
              v39 = 40;
            else
              v39 = 8;
            v40 = i[1];
            if (v34 < 2)
              v40 = v32;
            v38 = v40 >> (v39 + v33);
          }
          else
          {
            v38 = 0;
          }
          v41 = *v36;
          if (v41 >= 0xA)
            __assert_rtn("push_back", "MIDICISniffer.cpp", 34, "mSize < kMaxLen");
          *v36 = v41 + 1;
          *(_BYTE *)(v37 + v41) = v38;
          ++v34;
          v32 = *i;
          v33 -= 8;
        }
        while ((HIWORD(*i) & 0xF) > v34);
      }
      v42 = v13 + 20 * v14;
      v44 = *(unsigned __int8 *)(v42 + 18);
      v43 = (unsigned __int8 *)(v42 + 18);
      if (v44 > 3)
      {
        v45 = v13 + 20 * v14;
        v47 = *(unsigned __int8 *)(v45 + 8);
        v46 = v45 + 8;
        if (v47 == 126 && *(_BYTE *)(v13 + 20 * v14 + 10) == 13)
        {
          v73 = v46;
          v48 = v13 + 20 * v14;
          v49 = *(unsigned __int8 *)(v48 + 11);
          if (v49 == 68)
            v50 = 5;
          else
            v50 = 3;
          if (v49 == 67)
            v50 = 4;
          v72 = v50;
          v51 = ((_DWORD)v14 << 24) | 0x30000000 | *(_BYTE *)(v48 + 9) & 0x7F | 0x147E00;
          v78 = 0;
          v79 = v7;
          *(_DWORD *)v77 = v51;
          *(_QWORD *)&v77[4] = ((v49 & 0x7F) << 16) | 0xD000000u;
          v52 = v12[4];
          if (!v52)
LABEL_95:
            std::__throw_bad_function_call[abi:ne180100]();
          a1 = (MIDIServer *)(*(uint64_t (**)(uint64_t, _BYTE *, uint64_t *))(*(_QWORD *)v52 + 48))(v52, v77, &v79);
          v53 = *v43;
          if (v53 >= 5)
          {
            v54 = v53 - 4;
            if (v54 >= 6)
              v54 = 6;
            else
              v54 = v54;
            v55 = (_BYTE *)(v13 + 20 * v14);
            v56 = v55[12];
            v57 = v55[13];
            v58 = v55[14];
            v59 = v55[15];
            v60 = v55[16];
            v61 = v55[17];
            if ((v32 & 0xF0000000) == 0x30000000)
              v62 = v32 & 0xF00000;
            else
              v62 = 267386880;
            v78 = 0;
            v79 = v7;
            *(_DWORD *)v77 = v62 | (v54 << 16) | ((v56 & 0x7F) << 8) | v57 & 0x7F | ((_DWORD)v14 << 24) | 0x30000000;
            *(_QWORD *)&v77[4] = v61 & 0x7F | ((v60 & 0x7F) << 8) | ((v58 & 0x7F) << 24) | ((v59 & 0x7F) << 16);
            v63 = v12[4];
            if (!v63)
              goto LABEL_95;
            a1 = (MIDIServer *)(*(uint64_t (**)(uint64_t, _BYTE *, uint64_t *))(*(_QWORD *)v63 + 48))(v63, v77, &v79);
          }
          *(_DWORD *)(v73 + 7) = 0;
          *(_QWORD *)v73 = 0;
          *v29 = v72;
        }
        else
        {
          a1 = (MIDIServer *)MIDICISniffer::clearStateForGroup(v12, v14, 0, 0);
        }
      }
    }
    v65 = (*i >> 20) & 0xF;
    if (*i >> 28 != 3)
      v65 = -1;
    if (v65 != 3 && v65 != 0)
    {
      if (!v76)
        break;
      goto LABEL_90;
    }
    v67 = *v29;
    v26 = v76;
    if (*v29 == 4)
    {
      v68 = 1;
      goto LABEL_87;
    }
    if (v67 == 5)
    {
      v68 = 0;
      v26 = 0;
LABEL_87:
      *v15 = v68;
    }
    v25 = v67 > 2;
LABEL_89:
    a1 = (MIDIServer *)MIDICISniffer::clearStateForGroup(v12, v14, 0, v25);
    if (!v26)
      break;
LABEL_90:
    i = (unsigned int *)(*(_QWORD *)(a2 + 8)
                       + 4 * MIDI::UniversalPacket::word_sizes[(unint64_t)**(unsigned int **)(a2 + 8) >> 28]);
  }
  result = *(__n128 *)a2;
  v71 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)v74 = *(_OWORD *)a2;
  *((_OWORD *)v74 + 1) = v71;
  return result;
}

void MIDI::ChunkedEventListEmitter<MIDISource::ReceivedPacketList(MIDI::EventList const*)::$_1>::flush(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 296);
  if (*(_DWORD *)(v1 + 4))
  {
    if (!**(_DWORD **)(a1 + 8))
    {
      MIDISource::SchedulePacketList(*(MIDISource **)a1, (MIDIEventPacket *)v1);
      **(_DWORD **)(a1 + 8) = 0;
      v1 = *(_QWORD *)(a1 + 296);
    }
    *(_DWORD *)(v1 + 4) = 0;
    *(_QWORD *)(a1 + 312) = v1 + 8;
    *(_DWORD *)(v1 + 16) = 0;
  }
}

_QWORD *MIDIDestination::SendPacketList(_QWORD *this, void *a2, const MIDI::EventList *a3)
{
  uint64_t v4;
  unsigned int v5;
  int v6;
  const MIDIEventPacket *v7;
  void *v8;
  int *v9;
  uint64_t (**v10)();
  _QWORD v11[6];
  _QWORD *v12;
  int v13;
  int v14;
  _QWORD v15[128];

  v15[127] = *MEMORY[0x1E0C80C00];
  v8 = a2;
  if (*((_DWORD *)a3 + 1))
  {
    v4 = (uint64_t)this;
    if (*((_DWORD *)this + 217))
    {
      return MIDIDestination::SendPacketsNow(this, a2, a3);
    }
    else
    {
      v5 = 0;
      v7 = (const MIDIEventPacket *)((char *)a3 + 8);
      v6 = *(_DWORD *)a3;
      v10 = caulk::inplace_function<void ()(MIDI::EventList const*),48ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<MIDIDestination::SendPacketList(void *,MIDI::EventList const*)::$_0>;
      v11[0] = this;
      v13 = v6;
      v14 = 0;
      v11[1] = &v8;
      v12 = v15;
      do
      {
        if (v7->wordCount
          && (Scheduler::CheckSchedulePacket((Scheduler *)gScheduler, (uint64_t)v8, *(_DWORD *)(v4 + 8), (MIDIProtocolID)*(_DWORD *)a3, v7) & 1) == 0)
        {
          if (!v5 && *((_DWORD *)a3 + 1) == 1)
          {
            MIDIDestination::SendPacketsNow((_QWORD *)v4, v8, a3);
            return (_QWORD *)MIDI::PacketizerBase<MIDI::EventList>::~PacketizerBase((uint64_t)&v10);
          }
          MIDI::Packetizer::add((unsigned int *)&v10, v7);
        }
        v7 = (const MIDIEventPacket *)((char *)v7 + 4 * v7->wordCount + 12);
        ++v5;
      }
      while (v5 < *((_DWORD *)a3 + 1));
      if (v14)
      {
        v9 = &v13;
        ((void (*)(_QWORD *, int **))*v10)(v11, &v9);
      }
      v14 = 0;
      v12 = v15;
      return (_QWORD *)MIDI::PacketizerBase<MIDI::EventList>::~PacketizerBase((uint64_t)&v10);
    }
  }
  return this;
}

void sub_1D4EF1D74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  MIDI::PacketizerBase<MIDI::EventList>::~PacketizerBase((uint64_t)va);
  _Unwind_Resume(a1);
}

_QWORD *MIDIDestination::SendPacketsNow(_QWORD *this, void *a2, const MIDI::EventList *a3)
{
  int v3;
  MIDIDestination *v5;
  uint64_t v6;
  _QWORD *v7;
  _BYTE *v8;
  _BYTE *v9;
  char v10;
  __int128 *v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  unsigned int *v15;
  uint64_t v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v21;
  int v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  _BYTE *v27;
  _BYTE *v28;
  const MIDI::EventList *v29;
  _QWORD *v31;
  __int128 *v32;
  _QWORD v33[6];
  _QWORD v34[6];
  uint64_t (**v35)();
  _QWORD *v36;
  uint64_t (**v37)();
  _QWORD *v38;
  uint64_t (**v39)();
  _QWORD *v40;
  __int128 __s;
  _BYTE v42[24];
  __int128 v43;
  char v44;
  __int128 v45;
  char v46;
  _QWORD v47[5];

  v47[2] = *MEMORY[0x1E0C80C00];
  v3 = *((_DWORD *)a3 + 1);
  if (!v3)
    return this;
  v5 = (MIDIDestination *)this;
  v6 = 0;
  v47[0] = 0;
  v47[1] = 0;
  v31 = this + 12;
  v7 = this + 13;
  __s = 0uLL;
  do
  {
    if ((*((_DWORD *)v7 - 2) - 1) <= 1)
      v42[v6 - 16] = *v7 != (_QWORD)a2;
    ++v6;
    v7 += 3;
  }
  while (v6 != 16);
  v8 = memchr(&__s, 1, 0x10uLL);
  if (v8)
    v9 = v8;
  else
    v9 = v42;
  if (v9 - (_BYTE *)&__s == 16)
  {
    v10 = 0;
    LOBYTE(v45) = 0;
    v11 = (__int128 *)v47;
  }
  else
  {
    v45 = __s;
    v10 = 1;
    v11 = &v45;
  }
  v32 = v11;
  v46 = v10;
  v12 = 96;
  __s = 0uLL;
  do
  {
    if (*(_DWORD *)((char *)v5 + v12) == 2)
      *(_DWORD *)((char *)v5 + v12) = 1;
    v12 += 24;
  }
  while (v12 != 480);
  v29 = a3;
  v13 = (char *)a3 + 8;
  v39 = 0;
  v40 = 0;
  do
  {
    v14 = *((unsigned int *)v13 + 2);
    if ((_DWORD)v14)
    {
      v15 = (unsigned int *)(v13 + 12);
      v16 = (uint64_t)&v13[4 * v14 + 12];
      while (1)
      {
        v17 = *v15;
        v18 = *v15 >> 28;
        if (v18 && v18 != 15 && (BYTE2(v17) - 248 > 7 || ((1 << (BYTE2(v17) + 8)) & 0xDD) == 0))
          break;
LABEL_27:
        v15 += MIDI::UniversalPacket::word_sizes[(unint64_t)*v15 >> 28];
        if (v15 == (unsigned int *)v16)
        {
          v26 = *((unsigned int *)v13 + 2);
          goto LABEL_46;
        }
      }
      if (v18 == 3)
      {
        v21 = HIBYTE(v17) & 0xF;
        if (*((_BYTE *)v32 + v21))
          goto LABEL_37;
        v22 = (v17 >> 20) & 0xF;
        if (v22 == 3)
        {
          if (*((_BYTE *)&v39 + v21))
          {
            *((_BYTE *)&v39 + v21) = 0;
            LODWORD(v31[3 * v21]) = 0;
          }
          goto LABEL_37;
        }
        if (v22 != 2)
        {
          if (v22 != 1)
            goto LABEL_37;
          *((_BYTE *)&v39 + v21) = 1;
        }
        LODWORD(v31[3 * v21]) = 2;
        v23 = mach_absolute_time();
        v24 = &v31[3 * v21];
        v24[1] = a2;
        v24[2] = v23;
      }
      else
      {
        v21 = HIBYTE(v17) & 0xF;
      }
LABEL_37:
      if (v18 == 15)
        v25 = 255;
      else
        v25 = v21;
      if (*((_BYTE *)v32 + v25))
      {
        mach_absolute_time();
        if ((unint64_t)__udivti3() <= 0x1DCD64FF)
          v42[v25 - 16] = 1;
      }
      goto LABEL_27;
    }
    v26 = 0;
LABEL_46:
    v13 += 4 * v26 + 12;
    --v3;
  }
  while (v3);
  v27 = memchr(&__s, 1, 0x10uLL);
  if (v27)
    v28 = v27;
  else
    v28 = v42;
  if (v28 - (_BYTE *)&__s == 16)
    return (_QWORD *)MIDIDestination::DeliverAndDequeueIfNecessary(v5, v29, a2);
  v43 = __s;
  v44 = 1;
  v34[0] = MEMORY[0x1E0C809B0];
  v34[1] = 0x40000000;
  v34[2] = ___ZN15MIDIDestination14SendPacketsNowEPvPKN4MIDI9EventListE_block_invoke;
  v34[3] = &__block_descriptor_tmp_2517;
  v34[4] = v5;
  v34[5] = a2;
  *(_QWORD *)&__s = caulk::inplace_function<void ()(MIDIProtocolID,MIDIEventPacket const*),32ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<void({block_pointer})(MIDIProtocolID,MIDIEventPacket const*)>;
  *((_QWORD *)&__s + 1) = v34;
  v33[0] = MEMORY[0x1E0C809B0];
  v33[1] = 0x40000000;
  v33[2] = ___ZN15MIDIDestination14SendPacketsNowEPvPKN4MIDI9EventListE_block_invoke_20;
  v33[3] = &__block_descriptor_tmp_22;
  v33[4] = v5;
  v33[5] = a2;
  v39 = caulk::inplace_function<void ()(MIDI::EventList const*),32ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<void({block_pointer})(MIDI::EventList const*)>;
  v40 = v33;
  v37 = caulk::inplace_function<void ()(MIDI::EventList const*),32ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<void({block_pointer})(MIDI::EventList const*)>;
  v38 = v33;
  v35 = caulk::inplace_function<void ()(MIDIProtocolID,MIDIEventPacket const*),32ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<void({block_pointer})(MIDIProtocolID,MIDIEventPacket const*)>;
  v36 = v34;
  MIDI::sendOrDeferEventsOnActiveSysExGroups((MIDIEventPacket *)v29, (uint64_t)&v43, 16, (void (***)(_QWORD, _QWORD *))&v37, (uint64_t (***)(_QWORD, _DWORD *, _QWORD *))&v35);
  ((void (*)(_QWORD **))v35[3])(&v36);
  ((void (*)(_QWORD **))v37[3])(&v38);
  ((void (*)(_QWORD **))v39[3])(&v40);
  return (_QWORD *)(*(uint64_t (**)(char *))(__s + 24))((char *)&__s + 8);
}

void sub_1D4EF21B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

unsigned int *MIDI::Packetizer::add(unsigned int *this, const MIDIEventPacket *a2)
{
  unsigned int *v2;
  MIDITimeStamp timeStamp;
  UInt32 *words;
  uint64_t wordCount;
  unsigned int *v6;
  unint64_t v7;
  unsigned int v8;
  unsigned int v9;
  BOOL v10;
  unsigned int v11;
  BOOL v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  BOOL v16;
  char v17;
  int v18;
  int v19;
  BOOL v21;
  uint64_t v22;
  int v23;
  int v24;

  v2 = this;
  timeStamp = a2->timeStamp;
  words = a2->words;
  wordCount = a2->wordCount;
  v6 = (unsigned int *)*((_QWORD *)this + 7);
  if (!(_DWORD)wordCount)
  {
    if (v6)
      goto LABEL_48;
    goto LABEL_39;
  }
  v7 = (unint64_t)(this + 272);
  v8 = *words & 0xF0000000;
  v9 = this[17];
  if (v6)
    v10 = v9 == 0;
  else
    v10 = 1;
  if (!v10)
  {
    v11 = v6[2];
    v12 = v11 >= 2;
    v13 = v11 - 2;
    if (v12 && v6[3] >> 28 == 3)
    {
      v14 = v6[v13 + 3];
      if (v14 >> 28 == 3)
        v15 = (v14 >> 20) & 0xF;
      else
        v15 = 255;
      if (v15)
        v16 = v15 == 3;
      else
        v16 = 1;
      v17 = v16;
      v18 = 1;
LABEL_27:
      v19 = (v8 != 805306368) ^ v18;
      v21 = *(_QWORD *)v6 != timeStamp || v19 == 0 || (*words & 0xF0E00000) == 805306368;
      if (!v21 && (v17 & 1) == 0)
      {
LABEL_35:
        v22 = v6[2];
        if ((unint64_t)&v6[v22 + 3 + wordCount] <= v7)
          goto LABEL_41;
LABEL_39:
        this = (unsigned int *)MIDI::PacketizerBase<MIDI::EventList>::begin_new_packet((uint64_t)this, a2->timeStamp, (int *)words, wordCount);
        v6 = this;
        goto LABEL_48;
      }
      goto LABEL_37;
    }
LABEL_26:
    v18 = 0;
    v17 = 0;
    goto LABEL_27;
  }
  if (!v9)
    goto LABEL_38;
  if (v6)
    goto LABEL_26;
  if (v8 != 805306368)
    goto LABEL_35;
LABEL_37:
  v6 += v6[2] + 3;
LABEL_38:
  if ((unint64_t)&v6[wordCount + 3] > v7)
    goto LABEL_39;
  LODWORD(v22) = 0;
  this[17] = v9 + 1;
  *(_QWORD *)v6 = timeStamp;
  v6[2] = 0;
LABEL_41:
  this = &v6[v22 + 3];
  switch((int)wordCount)
  {
    case 1:
      goto LABEL_45;
    case 2:
      goto LABEL_44;
    case 3:
      goto LABEL_43;
    case 4:
      words = &a2->words[1];
      *this = a2->words[0];
      this = &v6[v22 + 4];
LABEL_43:
      v23 = *words++;
      *this++ = v23;
LABEL_44:
      v24 = *words++;
      *this++ = v24;
LABEL_45:
      *this = *words;
      break;
    default:
      this = (unsigned int *)memmove(this, a2->words, 4 * wordCount);
      break;
  }
  v6[2] += wordCount;
LABEL_48:
  *((_QWORD *)v2 + 7) = v6;
  return this;
}

_QWORD *caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<MIDIDestination::SendPacketList(void *,MIDI::EventList const*)::$_0>(caulk::inplace_function_detail::wrapper<MIDIDestination::SendPacketList(void *,MIDI::EventList const*)::$_0>)::{lambda(void *,MIDI::EventList const*&&)#1}::__invoke(uint64_t a1, const MIDI::EventList **a2)
{
  return MIDIDestination::SendPacketsNow(*(_QWORD **)a1, **(void ***)(a1 + 8), *a2);
}

__n128 caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<MIDIDestination::SendPacketList(void *,MIDI::EventList const*)::$_0>(caulk::inplace_function_detail::wrapper<MIDIDestination::SendPacketList(void *,MIDI::EventList const*)::$_0>)::{lambda(void *,void *)#1}::__invoke(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  *a1 = *a2;
  return result;
}

__n128 caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<MIDIDestination::SendPacketList(void *,MIDI::EventList const*)::$_0>(caulk::inplace_function_detail::wrapper<MIDIDestination::SendPacketList(void *,MIDI::EventList const*)::$_0>)::{lambda(void *,void *)#2}::__invoke(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  *a1 = *a2;
  return result;
}

void sub_1D4EF25F8(_Unwind_Exception *a1)
{
  void *v1;

  MIDI::packet_list_deleter(v1);
  _Unwind_Resume(a1);
}

uint64_t ___ZN15MIDIDestination14SendPacketsNowEPvPKN4MIDI9EventListE_block_invoke_20(uint64_t a1, const MIDI::EventList *a2)
{
  return MIDIDestination::DeliverAndDequeueIfNecessary(*(MIDIDestination **)(a1 + 32), a2, *(void **)(a1 + 40));
}

uint64_t MIDIDestination::DeliverAndDequeueIfNecessary(MIDIDestination *this, const MIDI::EventList *a2, void *a3)
{
  char *v4;
  int *v5;
  int v6;
  char *v7;
  unint64_t v8;
  _DWORD *v9;
  NSObject *v11;
  int v12;
  int v13;
  unint64_t v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  int *v18;
  int v19;
  uint64_t v20;
  _DWORD *v21;
  unint64_t v22;
  unint64_t v23;
  BOOL v24;
  unsigned int v25;
  char *v26;
  unsigned int v27;
  BOOL v28;
  int v29;
  uint64_t result;
  uint64_t i;
  int v33;
  NSObject *v34;
  uint64_t v35;
  char *v36;
  char *v37;
  char *v38;
  char *v39;
  NSObject *v40;
  uint64_t v41;
  uint64_t v42;
  char **v43;
  uint64_t v44;
  char *v45;
  char *v47;
  void *v49;
  uint64_t (**v50)();
  _QWORD v51[4];
  _BYTE buf[12];
  __int16 v53;
  int v54;
  __int16 v55;
  uint64_t v56;
  __int16 v57;
  uint64_t v58;
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  v4 = (char *)this + 96;
  v5 = (int *)((char *)this + 96);
  v6 = *((_DWORD *)a2 + 1);
  if (v6)
  {
    v7 = (char *)a2 + 8;
    do
    {
      v9 = v7 + 12;
      v8 = *((unsigned int *)v7 + 3);
      if (v8 >> 28 == 3)
      {
        if ((v5[6 * ((v8 >> 24) & 0xF)] - 1) <= 1
          && (*(_DWORD *)((char *)v9 + ((4 * *((unsigned int *)v7 + 2)) & 0x3FFFFFFF8) - 8) & 0xF0F00000) == 808452096)
        {
          gSysExUtilitiesLog();
          v11 = gSysExUtilitiesLog(void)::sysexu;
          if (os_log_type_enabled((os_log_t)gSysExUtilitiesLog(void)::sysexu, OS_LOG_TYPE_DEBUG))
          {
            v12 = *v9 >> 28;
            v13 = 255;
            if (v12 && v12 != 15)
              v13 = HIBYTE(*v9) & 0xF;
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = "MIDISysExUtilities.cpp";
            v53 = 1024;
            v54 = 135;
            v55 = 1024;
            LODWORD(v56) = v13;
            _os_log_impl(&dword_1D4E88000, v11, OS_LOG_TYPE_DEBUG, "%25s:%-5d [?] SysExStateMonitor::MaintainSysExState() - leaving SysEx on group %d", buf, 0x18u);
          }
          v14 = *v9;
          v15 = v14 >> 28;
          v16 = (v14 >> 24) & 0xF;
          if (v15 == 15)
            LODWORD(v16) = 255;
          if (!v15)
            LODWORD(v16) = 255;
          v5[6 * v16] = 3;
        }
      }
      else
      {
        v17 = 0;
        v18 = v5;
        while (1)
        {
          v19 = *v18;
          v18 += 6;
          if ((v19 - 1) < 2)
            break;
          if (++v17 == 16)
            goto LABEL_41;
        }
        v20 = *((unsigned int *)v7 + 2);
        if ((_DWORD)v20)
        {
          v21 = &v9[v20];
          do
          {
            v22 = *v9;
            v23 = v22 >> 28;
            if (*v9 >> 28)
              v24 = (_DWORD)v23 == 15;
            else
              v24 = 1;
            if (!v24)
            {
              v25 = BYTE3(v22) & 0xF;
              if ((_DWORD)v23 == 15)
                v25 = 255;
              v26 = &v4[24 * v25];
              if ((*(_DWORD *)v26 - 1) <= 1)
              {
                v27 = BYTE2(v22) - 248;
                v28 = v27 > 7;
                v29 = (1 << v27) & 0xDD;
                if (v28 || v29 == 0)
                  *(_DWORD *)v26 = 3;
              }
            }
            v9 += MIDI::UniversalPacket::word_sizes[v23];
          }
          while (v9 != v21);
        }
      }
LABEL_41:
      v7 += 4 * *((unsigned int *)v7 + 2) + 12;
      --v6;
    }
    while (v6);
  }
  result = MIDIDestination::DeliverPacketsToDestination(this, a2);
  for (i = 0; i != 16; ++i)
  {
    v33 = *v5;
    v5 += 6;
    if (v33 == 3)
    {
      gMIDIDeviceTableLog();
      v34 = gMIDIDeviceTableLog(void)::dtable;
      if (os_log_type_enabled((os_log_t)gMIDIDeviceTableLog(void)::dtable, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = "DeviceTable.cpp";
        v53 = 1024;
        v54 = 1151;
        _os_log_impl(&dword_1D4E88000, v34, OS_LOG_TYPE_DEBUG, "%25s:%-5d      !!! preparing to dequeue...", buf, 0x12u);
      }
      v35 = 0;
      v50 = caulk::inplace_function<void ()(MIDI::EventList const*,void *),32ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<MIDIDestination::DeliverAndDequeueIfNecessary(MIDI::EventList const*,void *)::$_0>;
      v51[0] = this;
      v47 = (char *)this + 480;
      while (1)
      {
        v36 = &v4[24 * v35];
        if (*(_DWORD *)v36 == 3)
        {
          *(_DWORD *)v36 = 0;
          v37 = &v47[24 * v35];
          v38 = (char *)*((_QWORD *)v37 + 1);
          if (v38 != v37)
            break;
        }
LABEL_60:
        if (++v35 == 16)
          return ((uint64_t (*)(_QWORD *))v50[3])(v51);
      }
      v39 = &v4[24 * v35 + 8];
      while ((*(_DWORD *)v36 - 1) > 1 || *((_QWORD *)v38 + 4) == *(_QWORD *)v39)
      {
        *(_QWORD *)buf = *((_QWORD *)v38 + 2);
        v49 = a3;
        ((void (*)(_QWORD *, _BYTE *, void **))*v50)(v51, buf, &v49);
        v44 = *(_QWORD *)v38;
        v45 = (char *)*((_QWORD *)v38 + 1);
        *(_QWORD *)(v44 + 8) = v45;
        **((_QWORD **)v38 + 1) = v44;
        --*((_QWORD *)v37 + 2);
        std::__list_imp<MergeQueueElem>::__delete_node[abi:ne180100]<>(v38);
        v43 = (char **)(v37 + 8);
        v38 = v45;
        if (*(_DWORD *)v36 == 3)
          goto LABEL_58;
LABEL_59:
        if (v38 == v37)
          goto LABEL_60;
      }
      gSysExUtilitiesLog();
      v40 = gSysExUtilitiesLog(void)::sysexu;
      if (os_log_type_enabled((os_log_t)gSysExUtilitiesLog(void)::sysexu, OS_LOG_TYPE_DEBUG))
      {
        v41 = *((_QWORD *)v38 + 4);
        v42 = *(_QWORD *)v39;
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = "MIDISysExUtilities.cpp";
        v53 = 1024;
        v54 = 179;
        v55 = 2048;
        v56 = v41;
        v57 = 2048;
        v58 = v42;
        _os_log_impl(&dword_1D4E88000, v40, OS_LOG_TYPE_DEBUG, "%25s:%-5d [?] SysExStateMonitor::dequeue() - port %p != %p, leaving enqueued", buf, 0x26u);
      }
      v43 = (char **)(v38 + 8);
LABEL_58:
      v38 = *v43;
      goto LABEL_59;
    }
  }
  return result;
}

void sub_1D4EF2AEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

uint64_t MIDIDestination::DeliverPacketsToDestination(MIDIDestination *this, const MIDI::EventList *a2)
{
  uint64_t v4;
  int **v5;
  int **i;
  int *v7;
  _QWORD *v8;
  void (**v9)();
  uint64_t result;
  uint64_t v11;
  int *v12;
  unsigned int v13;
  uint64_t (**v14)();
  _QWORD v15[6];
  void (**v16)();
  _QWORD v17[7];

  v17[6] = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(MIDIServer::defaultInstance(this, (int)a2) + 264);
  v13 = *((_DWORD *)this + 2);
  v5 = *(int ***)(v4 + 40);
  for (i = *(int ***)(v4 + 48); v5 != i; ++v5)
  {
    v7 = *v5;
    v12 = v7;
    if (v7[16] < 3)
    {
      v14 = caulk::inplace_function<void ()(MIDI::LegacyPacketList const*),48ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<MIDIDriverMgr::DoMonitoring(unsigned int,MIDIEventList const*)::{lambda(MIDIPacketList const*)#1}>;
      v15[0] = &v12;
      v15[1] = &v13;
      v8 = (_QWORD *)operator new();
      v16 = (void (**)())v14;
      ((void (*)(_QWORD *, _QWORD *))v14[1])(v17, v15);
      v9 = v16;
      v16 = &caulk::inplace_function_detail::vtable<void,MIDI::LegacyPacketList const*>::empty;
      *v8 = &off_1E98B9EC8;
      v8[1] = v9;
      ((void (*)(_QWORD *, _QWORD *))v9[2])(v8 + 2, v17);
      bzero(v8 + 8, 0x300uLL);
      ((void (*)(_QWORD *))v16[3])(v17);
      ((void (*)(_QWORD *))v14[3])(v15);
      (*(void (**)(_QWORD *, const MIDI::EventList *))(*v8 + 16))(v8, a2);
      (*(void (**)(_QWORD *))(*v8 + 8))(v8);
    }
    else
    {
      (*(void (**)(int *, _QWORD, const MIDI::EventList *))(*(_QWORD *)v7 + 136))(v7, v13, a2);
    }
  }
  result = *((_QWORD *)this + 109);
  if (result)
    return (*(uint64_t (**)(uint64_t, const MIDI::EventList *))(*(_QWORD *)result + 16))(result, a2);
  v11 = *((_QWORD *)this + 6);
  if (v11)
  {
    result = *(_QWORD *)(v11 + 48);
    if (result)
      return ClientProcess::DeliverPacketsToClient(result, *((_DWORD *)this + 2), *((_DWORD *)this + 2), a2);
  }
  return result;
}

void sub_1D4EF2D68(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t caulk::inplace_function_detail::vtable<void,MIDI::EventList const*,void *>::vtable<MIDIDestination::DeliverAndDequeueIfNecessary(MIDI::EventList const*,void *)::$_0>(caulk::inplace_function_detail::wrapper<MIDIDestination::DeliverAndDequeueIfNecessary(MIDI::EventList const*,void *)::$_0>)::{lambda(void *,MIDI::EventList const*&&,void *&&)#1}::__invoke(MIDIDestination **a1, const MIDI::EventList **a2, void **a3)
{
  return MIDIDestination::DeliverAndDequeueIfNecessary(*a1, *a2, *a3);
}

_QWORD *caulk::inplace_function_detail::vtable<void,MIDI::EventList const*,void *>::vtable<MIDIDestination::DeliverAndDequeueIfNecessary(MIDI::EventList const*,void *)::$_0>(caulk::inplace_function_detail::wrapper<MIDIDestination::DeliverAndDequeueIfNecessary(MIDI::EventList const*,void *)::$_0>)::{lambda(void *,void *)#1}::__invoke(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

_QWORD *caulk::inplace_function_detail::vtable<void,MIDI::EventList const*,void *>::vtable<MIDIDestination::DeliverAndDequeueIfNecessary(MIDI::EventList const*,void *)::$_0>(caulk::inplace_function_detail::wrapper<MIDIDestination::DeliverAndDequeueIfNecessary(MIDI::EventList const*,void *)::$_0>)::{lambda(void *,void *)#2}::__invoke(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

uint64_t caulk::inplace_function_detail::vtable<void,MIDI::LegacyPacketList const*>::vtable<MIDIDriverMgr::DoMonitoring(unsigned int,MIDIEventList const*)::{lambda(MIDIPacketList const*)#1}>(caulk::inplace_function_detail::wrapper<MIDIDriverMgr::DoMonitoring(unsigned int,MIDIEventList const*)::{lambda(MIDIPacketList const*)#1}>)::{lambda(void *,MIDI::LegacyPacketList const*&&)#1}::__invoke(unsigned int **a1, _QWORD *a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)*a1 + 128))(*(_QWORD *)*a1, *a1[1], *a2);
}

__n128 caulk::inplace_function_detail::vtable<void,MIDI::LegacyPacketList const*>::vtable<MIDIDriverMgr::DoMonitoring(unsigned int,MIDIEventList const*)::{lambda(MIDIPacketList const*)#1}>(caulk::inplace_function_detail::wrapper<MIDIDriverMgr::DoMonitoring(unsigned int,MIDIEventList const*)::{lambda(MIDIPacketList const*)#1}>)::{lambda(void *,void *)#1}::__invoke(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  *a1 = *a2;
  return result;
}

__n128 caulk::inplace_function_detail::vtable<void,MIDI::LegacyPacketList const*>::vtable<MIDIDriverMgr::DoMonitoring(unsigned int,MIDIEventList const*)::{lambda(MIDIPacketList const*)#1}>(caulk::inplace_function_detail::wrapper<MIDIDriverMgr::DoMonitoring(unsigned int,MIDIEventList const*)::{lambda(MIDIPacketList const*)#1}>)::{lambda(void *,void *)#2}::__invoke(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  *a1 = *a2;
  return result;
}

uint64_t caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<void({block_pointer})(MIDI::EventList const*)>(caulk::inplace_function_detail::wrapper<void({block_pointer})(MIDI::EventList const*)>)::{lambda(void *,MIDI::EventList const*&&)#1}::__invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)a1 + 16))();
}

_QWORD *caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<void({block_pointer})(MIDI::EventList const*)>(caulk::inplace_function_detail::wrapper<void({block_pointer})(MIDI::EventList const*)>)::{lambda(void *,void *)#1}::__invoke(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

_QWORD *caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<void({block_pointer})(MIDI::EventList const*)>(caulk::inplace_function_detail::wrapper<void({block_pointer})(MIDI::EventList const*)>)::{lambda(void *,void *)#2}::__invoke(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

uint64_t caulk::inplace_function_detail::vtable<void,MIDIProtocolID,MIDIEventPacket const*>::vtable<void({block_pointer})(MIDIProtocolID,MIDIEventPacket const*)>(caulk::inplace_function_detail::wrapper<void({block_pointer})(MIDIProtocolID,MIDIEventPacket const*)>)::{lambda(void *,MIDIProtocolID&&,MIDIEventPacket const*&&)#1}::__invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)a1 + 16))();
}

_QWORD *caulk::inplace_function_detail::vtable<void,MIDIProtocolID,MIDIEventPacket const*>::vtable<void({block_pointer})(MIDIProtocolID,MIDIEventPacket const*)>(caulk::inplace_function_detail::wrapper<void({block_pointer})(MIDIProtocolID,MIDIEventPacket const*)>)::{lambda(void *,void *)#1}::__invoke(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

_QWORD *caulk::inplace_function_detail::vtable<void,MIDIProtocolID,MIDIEventPacket const*>::vtable<void({block_pointer})(MIDIProtocolID,MIDIEventPacket const*)>(caulk::inplace_function_detail::wrapper<void({block_pointer})(MIDIProtocolID,MIDIEventPacket const*)>)::{lambda(void *,void *)#2}::__invoke(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

uint64_t ClientProcess::asXPCImpl(ClientProcess *this)
{
  return 0;
}

void ClientProcessMIG::~ClientProcessMIG(mach_port_name_t *this)
{
  ClientProcessMIG::~ClientProcessMIG(this);
  JUMPOUT(0x1D826BA98);
}

{
  ClientProcess::~ClientProcess((ClientProcess *)(this + 4));
  *(_QWORD *)this = &off_1E98B9B98;
  CADeprecated::XMachPortSendRight::~XMachPortSendRight(this + 3);
  BaseOpaqueObject::~BaseOpaqueObject((BaseOpaqueObject *)this);
}

uint64_t ClientProcessMIG::PrintObject(ClientProcessMIG *this, __sFILE *a2)
{
  fprintf(a2, "<%s 0x%x [%p]>", "ClientProcessLegacy", *((_DWORD *)this + 2), this);
  return fputc(10, a2);
}

uint64_t TOpaqueObject<ClientProcessMIG,unsigned int,CADeprecated::XMachServer::Client>::isa(uint64_t a1, void *a2)
{
  _BOOL4 v3;

  v3 = a2 == &TOpaqueRTTI<CADeprecated::XMachServer::Client>::sRTTI || a2 == &BaseOpaqueObject::sBaseRTTI;
  return a2 == &TOpaqueRTTI<ClientProcessMIG>::sRTTI || v3;
}

uint64_t ClientProcessMIG::GetRef(ClientProcessMIG *this)
{
  return *((unsigned int *)this + 2);
}

uint64_t ClientProcessMIG::Notify(uint64_t a1, CFDataRef *a2)
{
  int v3;
  const UInt8 *BytePtr;
  const __CFData *v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  applesauce::CF *exception;
  applesauce::CF *v11;
  _BYTE v12[12];
  mach_port_name_t name[4];
  const UInt8 *v14;
  int v15;
  int Length;
  uint64_t v17;
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (!*a2)
  {
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  v3 = *(_DWORD *)(a1 + 12);
  BytePtr = CFDataGetBytePtr(*a2);
  v5 = *a2;
  if (!*a2)
  {
    v11 = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(v11);
  }
  v14 = BytePtr;
  v15 = 16777472;
  Length = CFDataGetLength(v5);
  v17 = *MEMORY[0x1E0C804E8];
  v18 = Length;
  *(_QWORD *)v12 = 2147483667;
  *(_DWORD *)&v12[8] = v3;
  *(_OWORD *)name = xmmword_1D4F18AC0;
  if (MEMORY[0x1E0C85B60])
    voucher_mach_msg_set((mach_msg_header_t *)v12);
  v6 = mach_msg((mach_msg_header_t *)v12, 17, 0x38u, 0, 0, 0x493E0u, 0);
  v7 = v6;
  if ((_DWORD)v6 == 268435460)
  {
    if ((*(_WORD *)v12 & 0x1F00) == 0x1100)
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], name[0]);
    mach_msg_destroy((mach_msg_header_t *)v12);
  }
  else if (!(_DWORD)v6)
  {
    return v7;
  }
  gServerClientProcessLog();
  v8 = gServerClientProcessLog(void)::cliprc;
  if (os_log_type_enabled((os_log_t)gServerClientProcessLog(void)::cliprc, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)v12 = 136315650;
    *(_QWORD *)&v12[4] = "ClientProcess.cpp";
    LOWORD(name[0]) = 1024;
    *(mach_port_name_t *)((char *)name + 2) = 245;
    HIWORD(name[1]) = 1024;
    name[2] = v7;
    _os_log_impl(&dword_1D4E88000, v8, OS_LOG_TYPE_ERROR, "%25s:%-5d MIDIClientCallbackSender_Notify returned error %d", v12, 0x18u);
  }
  return v7;
}

void sub_1D4EF3154(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'ClientProcessMIG::~ClientProcessMIG(mach_port_name_t *this)
{
  ClientProcessMIG::~ClientProcessMIG(this - 4);
}

{
  ClientProcessMIG::~ClientProcessMIG(this - 4);
  JUMPOUT(0x1D826BA98);
}

uint64_t `non-virtual thunk to'ClientProcessMIG::asMIGImpl(ClientProcessMIG *this)
{
  return (uint64_t)this - 16;
}

uint64_t `non-virtual thunk to'ClientProcessMIG::GetRef(ClientProcessMIG *this)
{
  return *((unsigned int *)this - 2);
}

uint64_t `non-virtual thunk to'ClientProcessMIG::Notify(uint64_t a1, CFDataRef *a2)
{
  return ClientProcessMIG::Notify(a1 - 16, a2);
}

void ClientProcess::~ClientProcess(ClientProcess *this)
{
  void *v2;

  *(_QWORD *)this = off_1E98B9530;
  NotificationQueue::~NotificationQueue((ClientProcess *)((char *)this + 296));
  if (*((_BYTE *)this + 288))
    MIDIRingBuffer::~MIDIRingBuffer((ClientProcess *)((char *)this + 184));
  if (*((_BYTE *)this + 176))
  {
    *((_QWORD *)this + 3) = &off_1E98B9A28;
    v2 = (void *)*((_QWORD *)this + 16);
    if (v2)
    {
      *((_QWORD *)this + 17) = v2;
      operator delete(v2);
    }
    MIDIRingBuffer::~MIDIRingBuffer((ClientProcess *)((char *)this + 24));
  }
  if (*((_BYTE *)this + 20))
    XClientMachPort::~XClientMachPort((mach_port_name_t *)this + 4);
}

void CADeprecated::XMachServer::Client::~Client(mach_port_name_t *this)
{
  *(_QWORD *)this = &off_1E98B9B98;
  CADeprecated::XMachPortSendRight::~XMachPortSendRight(this + 3);
  BaseOpaqueObject::~BaseOpaqueObject((BaseOpaqueObject *)this);
}

{
  *(_QWORD *)this = &off_1E98B9B98;
  CADeprecated::XMachPortSendRight::~XMachPortSendRight(this + 3);
  BaseOpaqueObject::~BaseOpaqueObject((BaseOpaqueObject *)this);
  JUMPOUT(0x1D826BA98);
}

BOOL TOpaqueObject<CADeprecated::XMachServer::Client,unsigned int,BaseOpaqueObject>::isa(uint64_t a1, void *a2)
{
  return a2 == &TOpaqueRTTI<CADeprecated::XMachServer::Client>::sRTTI || a2 == &BaseOpaqueObject::sBaseRTTI;
}

void gServerClientProcessLog(void)
{
  unsigned __int8 v0;

  if ((v0 & 1) == 0)
  {
    {
      gServerClientProcessLog(void)::cliprc = (uint64_t)os_log_create("com.apple.coremidi", "cliprc");
    }
  }
}

void ClientProcess::DeliverNotifications(ClientProcess *this)
{
  __CFData *Mutable;
  uint64_t i;
  CFTypeRef cf;
  UInt8 bytes[16];
  uint64_t v6;

  *((_BYTE *)this + 320) = 1;
  Mutable = CFDataCreateMutable(0, 0);
  for (i = *((_QWORD *)this + 38); (ClientProcess *)i != (ClientProcess *)((char *)this + 296); i = *(_QWORD *)(i + 8))
    ClientNotification::serialize((UInt8 *)(i + 16), Mutable);
  NotificationQueue::eraseall((_QWORD *)this + 37);
  *(_OWORD *)bytes = xmmword_1D4F19558;
  v6 = 0;
  ClientNotification::serialize(bytes, Mutable);
  applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)&cf, Mutable);
  (*(void (**)(ClientProcess *, CFTypeRef *))(*(_QWORD *)this + 40))(this, &cf);
  if (cf)
    CFRelease(cf);
}

void sub_1D4EF3440(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  applesauce::CF::DataRef::~DataRef((const void **)va);
  _Unwind_Resume(a1);
}

void ClientProcess::setupIO(mach_port_name_t *this, mach_port_name_t a2, int a3)
{
  unsigned int v6;
  int v7;
  void *v8;
  __int128 v9;
  char __str[64];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v6 = (*(uint64_t (**)(mach_port_name_t *))(*(_QWORD *)this + 32))(this);
  if (*((_BYTE *)this + 20))
    XClientMachPort::~XClientMachPort(this + 4);
  this[4] = a2;
  *((_BYTE *)this + 20) = 1;
  if (a3)
    v7 = 4;
  else
    v7 = 0;
  if (*((_BYTE *)this + 176))
  {
    *((_QWORD *)this + 3) = &off_1E98B9A28;
    v8 = (void *)*((_QWORD *)this + 16);
    if (v8)
    {
      *((_QWORD *)this + 17) = v8;
      operator delete(v8);
    }
    MIDIRingBuffer::~MIDIRingBuffer((MIDIRingBuffer *)(this + 6));
  }
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  this[15] = 0;
  *((_BYTE *)this + 64) = 0;
  v9 = 0uLL;
  *(_OWORD *)(this + 17) = 0u;
  *(_OWORD *)(this + 21) = 0u;
  *((_QWORD *)this + 14) = 0;
  this[30] = v7 | 2;
  *((_QWORD *)this + 3) = &off_1E98B9A28;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 21) = 0;
  *(_OWORD *)(this + 31) = 0u;
  *(_OWORD *)(this + 35) = 0u;
  *(_QWORD *)(this + 39) = 0;
  *((_BYTE *)this + 176) = 1;
  if (*((_BYTE *)this + 288))
  {
    MIDIRingBuffer::~MIDIRingBuffer((MIDIRingBuffer *)(this + 46));
    v9 = 0uLL;
  }
  *((_QWORD *)this + 25) = 0;
  *((_QWORD *)this + 26) = 0;
  this[55] = 0;
  *((_BYTE *)this + 224) = 0;
  *(_OWORD *)(this + 57) = v9;
  *(_OWORD *)(this + 61) = v9;
  *((_QWORD *)this + 34) = 0;
  this[70] = v7;
  *((_QWORD *)this + 23) = &off_1E98B9A08;
  *((_QWORD *)this + 24) = 0;
  *((_BYTE *)this + 288) = 1;
  *((_BYTE *)this + 12) = a3;
  snprintf(__str, 0x40uLL, "Apple MIDI %s %d", "in", this[2]);
  MIDIIORingBufferBase::Init((MIDIIORingBufferBase *)(this + 6), v6, __str);
  snprintf(__str, 0x40uLL, "Apple MIDI %s %d", "out", this[2]);
  MIDIIORingBufferBase::Init((MIDIIORingBufferBase *)(this + 46), v6, __str);
}

uint64_t ClientProcess::DeliverPacketsToClient(uint64_t this, unsigned int a2, unsigned int a3, const MIDI::EventList *a4)
{
  uint64_t v4;
  int v5;
  unint64_t v6;
  _BYTE msg[28];
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(this + 13))
  {
    v4 = this;
    v6 = __PAIR64__(a3, a2);
    this = MIDIIORingBufferWriter::writePacketList<MIDI::EventList>(this + 24, (uint64_t *)&v6, *(_DWORD *)a4, (uint64_t)a4);
    if ((_DWORD)this)
    {
      v5 = *(_DWORD *)(v4 + 16);
      *(_QWORD *)msg = 0x2400000013;
      *(_DWORD *)&msg[8] = v5;
      *(_QWORD *)&msg[20] = 0;
      *(_QWORD *)&msg[12] = 0;
      v8 = 1;
      return mach_msg((mach_msg_header_t *)msg, 1, 0x24u, 0, 0, 0, 0);
    }
  }
  return this;
}

void gMIDIClientLog(void)
{
  unsigned __int8 v0;

  if ((v0 & 1) == 0)
  {
    {
      gMIDIClientLog(void)::clilib = (uint64_t)os_log_create("com.apple.coremidi", "client");
    }
  }
}

OSStatus MIDIObjectSetIntegerProperty(MIDIObjectRef obj, CFStringRef propertyID, SInt32 value)
{
  uint64_t v3;
  MIDIServer *v5;
  NSObject *v6;
  _BOOL8 v7;
  CFStringRef v8;
  unsigned int v9;
  uint64_t *v10;
  ClientInterface *v11;
  unsigned int v12;
  _UNKNOWN **v13;
  NSObject *v14;
  _BYTE v16[32];
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  unint64_t v24;
  __int16 v25;
  CFStringRef v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  uint64_t v31;

  v3 = *(_QWORD *)&value;
  v5 = *(MIDIServer **)&obj;
  v31 = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v6 = gMIDIClientLog(void)::clilib;
  v7 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v7)
  {
    *(_DWORD *)buf = 136316674;
    v8 = CFSTR("(null)");
    v18 = "MIDIClientLib.cpp";
    v19 = 1024;
    if (propertyID)
      v8 = propertyID;
    v20 = 217;
    v21 = 2080;
    v22 = "MIDIObjectSetIntegerProperty";
    v23 = 2048;
    v24 = v5;
    v25 = 2112;
    v26 = v8;
    v27 = 1024;
    v28 = v3;
    v29 = 1024;
    v30 = v3;
    _os_log_impl(&dword_1D4E88000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s(%p) \"%@\" = %d (0x%x)", buf, 0x3Cu);
  }
  if ((gInMIDIServer & 1) != 0)
  {
    v9 = _MIDIObjectSetIntegerProperty(v5, propertyID, v3);
  }
  else
  {
    v10 = MIDIProcess::defaultInstance((MIDIProcess *)v7);
    v11 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v10 + 56))(v10);
    v12 = v11;
    if ((_DWORD)v11)
      goto LABEL_10;
    v13 = ClientInterface::global(v11);
    v9 = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *, CFStringRef, uint64_t))*v13 + 11))(v13, v5, propertyID, v3);
  }
  v12 = v9;
LABEL_10:
  gMIDIClientLog();
  v14 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v16, v12);
    *(_DWORD *)buf = 136315906;
    v18 = "MIDIClientLib.cpp";
    v19 = 1024;
    v20 = 224;
    v21 = 2080;
    v22 = "MIDIObjectSetIntegerProperty";
    v23 = 2080;
    v24 = (unint64_t)v16;
    _os_log_impl(&dword_1D4E88000, v14, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s%s", buf, 0x26u);
  }
  return v12;
}

OSStatus MIDIObjectGetIntegerProperty(MIDIObjectRef obj, CFStringRef propertyID, SInt32 *outValue)
{
  MIDIServer *v5;
  NSObject *v6;
  _BOOL8 v7;
  CFStringRef v8;
  unsigned int IntegerProperty;
  unsigned int v10;
  uint64_t *v11;
  ClientInterface *v12;
  _UNKNOWN **v13;
  NSObject *v14;
  SInt32 v15;
  _BYTE v17[32];
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  _BYTE v25[18];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (!outValue)
    return -50;
  v5 = *(MIDIServer **)&obj;
  gMIDIClientLog();
  v6 = gMIDIClientLog(void)::clilib;
  v7 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v7)
  {
    *(_DWORD *)buf = 136316162;
    v8 = CFSTR("(null)");
    v19 = "MIDIClientLib.cpp";
    if (propertyID)
      v8 = propertyID;
    v20 = 1024;
    v21 = 232;
    v22 = 2080;
    v23 = "MIDIObjectGetIntegerProperty";
    v24 = 2048;
    *(_QWORD *)v25 = v5;
    *(_WORD *)&v25[8] = 2112;
    *(_QWORD *)&v25[10] = v8;
    _os_log_impl(&dword_1D4E88000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s(%p) \"%@\"", buf, 0x30u);
  }
  *outValue = 0;
  if ((gInMIDIServer & 1) != 0)
  {
    IntegerProperty = _MIDIObjectGetIntegerProperty(v5, propertyID, outValue);
  }
  else
  {
    v11 = MIDIProcess::defaultInstance((MIDIProcess *)v7);
    v12 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v11 + 56))(v11);
    v10 = v12;
    if ((_DWORD)v12)
      goto LABEL_12;
    v13 = ClientInterface::global(v12);
    IntegerProperty = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *, CFStringRef, SInt32 *))*v13 + 10))(v13, v5, propertyID, outValue);
  }
  v10 = IntegerProperty;
LABEL_12:
  gMIDIClientLog();
  v14 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    v15 = *outValue;
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v17, v10);
    *(_DWORD *)buf = 136316162;
    v19 = "MIDIClientLib.cpp";
    v20 = 1024;
    v21 = 240;
    v22 = 2080;
    v23 = "MIDIObjectGetIntegerProperty";
    v24 = 1024;
    *(_DWORD *)v25 = v15;
    *(_WORD *)&v25[4] = 2080;
    *(_QWORD *)&v25[6] = v17;
    _os_log_impl(&dword_1D4E88000, v14, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s = %d%s", buf, 0x2Cu);
  }
  return v10;
}

OSStatus MIDIObjectSetStringProperty(MIDIObjectRef obj, CFStringRef propertyID, CFStringRef str)
{
  MIDIServer *v5;
  NSObject *v6;
  _BOOL8 v7;
  CFStringRef v8;
  CFStringRef v9;
  unsigned int v10;
  uint64_t *v11;
  ClientInterface *v12;
  unsigned int v13;
  _UNKNOWN **v14;
  NSObject *v15;
  _BYTE v17[32];
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  unint64_t v25;
  __int16 v26;
  CFStringRef v27;
  __int16 v28;
  CFStringRef v29;
  uint64_t v30;

  v5 = *(MIDIServer **)&obj;
  v30 = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v6 = gMIDIClientLog(void)::clilib;
  v7 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v7)
  {
    *(_DWORD *)buf = 136316418;
    v8 = CFSTR("(null)");
    v19 = "MIDIClientLib.cpp";
    v20 = 1024;
    if (propertyID)
      v9 = propertyID;
    else
      v9 = CFSTR("(null)");
    v21 = 247;
    v22 = 2080;
    if (str)
      v8 = str;
    v23 = "MIDIObjectSetStringProperty";
    v24 = 2048;
    v25 = v5;
    v26 = 2112;
    v27 = v9;
    v28 = 2112;
    v29 = v8;
    _os_log_impl(&dword_1D4E88000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s(%p) \"%@\" = %@", buf, 0x3Au);
  }
  if ((gInMIDIServer & 1) != 0)
  {
    v10 = _MIDIObjectSetStringProperty(v5, propertyID, (uint64_t)str);
  }
  else
  {
    v11 = MIDIProcess::defaultInstance((MIDIProcess *)v7);
    v12 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v11 + 56))(v11);
    v13 = v12;
    if ((_DWORD)v12)
      goto LABEL_13;
    v14 = ClientInterface::global(v12);
    v10 = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *, CFStringRef, CFStringRef))*v14 + 13))(v14, v5, propertyID, str);
  }
  v13 = v10;
LABEL_13:
  gMIDIClientLog();
  v15 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v17, v13);
    *(_DWORD *)buf = 136315906;
    v19 = "MIDIClientLib.cpp";
    v20 = 1024;
    v21 = 254;
    v22 = 2080;
    v23 = "MIDIObjectSetStringProperty";
    v24 = 2080;
    v25 = (unint64_t)v17;
    _os_log_impl(&dword_1D4E88000, v15, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s%s", buf, 0x26u);
  }
  return v13;
}

OSStatus MIDIObjectGetStringProperty(MIDIObjectRef obj, CFStringRef propertyID, CFStringRef *str)
{
  MIDIServer *v5;
  NSObject *v6;
  _BOOL8 v7;
  CFStringRef v8;
  unsigned int StringProperty;
  unsigned int v10;
  uint64_t *v11;
  ClientInterface *v12;
  _UNKNOWN **v13;
  NSObject *v14;
  CFStringRef v15;
  _BYTE v17[32];
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  CFStringRef v25;
  __int16 v26;
  _BYTE *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (!str)
    return -50;
  v5 = *(MIDIServer **)&obj;
  *str = 0;
  gMIDIClientLog();
  v6 = gMIDIClientLog(void)::clilib;
  v7 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v7)
  {
    *(_DWORD *)buf = 136316162;
    if (propertyID)
      v8 = propertyID;
    else
      v8 = CFSTR("(null)");
    v19 = "MIDIClientLib.cpp";
    v20 = 1024;
    v21 = 263;
    v22 = 2080;
    v23 = "MIDIObjectGetStringProperty";
    v24 = 2048;
    v25 = (CFStringRef)v5;
    v26 = 2112;
    v27 = v8;
    _os_log_impl(&dword_1D4E88000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s(%p) \"%@\"", buf, 0x30u);
  }
  if ((gInMIDIServer & 1) != 0)
  {
    StringProperty = _MIDIObjectGetStringProperty(v5, propertyID, str);
  }
  else
  {
    v11 = MIDIProcess::defaultInstance((MIDIProcess *)v7);
    v12 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v11 + 56))(v11);
    v10 = v12;
    if ((_DWORD)v12)
      goto LABEL_13;
    v13 = ClientInterface::global(v12);
    StringProperty = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *, CFStringRef, CFStringRef *))*v13 + 12))(v13, v5, propertyID, str);
  }
  v10 = StringProperty;
LABEL_13:
  gMIDIClientLog();
  v14 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    if (*str)
      v15 = *str;
    else
      v15 = CFSTR("(null)");
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v17, v10);
    *(_DWORD *)buf = 136316162;
    v19 = "MIDIClientLib.cpp";
    v20 = 1024;
    v21 = 270;
    v22 = 2080;
    v23 = "MIDIObjectGetStringProperty";
    v24 = 2112;
    v25 = v15;
    v26 = 2080;
    v27 = v17;
    _os_log_impl(&dword_1D4E88000, v14, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s = %@%s", buf, 0x30u);
  }
  return v10;
}

OSStatus MIDIObjectSetDataProperty(MIDIObjectRef obj, CFStringRef propertyID, CFDataRef data)
{
  MIDIServer *v5;
  NSObject *v6;
  _BOOL8 v7;
  CFDataRef v8;
  CFStringRef v9;
  unsigned int v10;
  uint64_t *v11;
  ClientInterface *v12;
  unsigned int v13;
  _UNKNOWN **v14;
  NSObject *v15;
  _BYTE v17[32];
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  unint64_t v25;
  __int16 v26;
  CFStringRef v27;
  __int16 v28;
  CFDataRef v29;
  uint64_t v30;

  v5 = *(MIDIServer **)&obj;
  v30 = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v6 = gMIDIClientLog(void)::clilib;
  v7 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v7)
  {
    *(_DWORD *)buf = 136316418;
    v8 = (CFDataRef)CFSTR("(null)");
    v19 = "MIDIClientLib.cpp";
    v20 = 1024;
    if (propertyID)
      v9 = propertyID;
    else
      v9 = CFSTR("(null)");
    v21 = 277;
    v22 = 2080;
    if (data)
      v8 = data;
    v23 = "MIDIObjectSetDataProperty";
    v24 = 2048;
    v25 = v5;
    v26 = 2112;
    v27 = v9;
    v28 = 2112;
    v29 = v8;
    _os_log_impl(&dword_1D4E88000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s(%p) \"%@\" = %@", buf, 0x3Au);
  }
  if ((gInMIDIServer & 1) != 0)
  {
    v10 = _MIDIObjectSetDataProperty(v5, propertyID, (uint64_t)data);
  }
  else
  {
    v11 = MIDIProcess::defaultInstance((MIDIProcess *)v7);
    v12 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v11 + 56))(v11);
    v13 = v12;
    if ((_DWORD)v12)
      goto LABEL_13;
    v14 = ClientInterface::global(v12);
    v10 = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *, CFStringRef, CFDataRef))*v14 + 15))(v14, v5, propertyID, data);
  }
  v13 = v10;
LABEL_13:
  gMIDIClientLog();
  v15 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v17, v13);
    *(_DWORD *)buf = 136315906;
    v19 = "MIDIClientLib.cpp";
    v20 = 1024;
    v21 = 284;
    v22 = 2080;
    v23 = "MIDIObjectSetDataProperty";
    v24 = 2080;
    v25 = (unint64_t)v17;
    _os_log_impl(&dword_1D4E88000, v15, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s%s", buf, 0x26u);
  }
  return v13;
}

OSStatus MIDIObjectGetDataProperty(MIDIObjectRef obj, CFStringRef propertyID, CFDataRef *outData)
{
  MIDIServer *v5;
  NSObject *v6;
  _BOOL8 v7;
  CFStringRef v8;
  unsigned int DataProperty;
  unsigned int v10;
  uint64_t *v11;
  ClientInterface *v12;
  _UNKNOWN **v13;
  NSObject *v14;
  CFDataRef v15;
  _BYTE v17[32];
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  CFDataRef v25;
  __int16 v26;
  _BYTE *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (!outData)
    return -50;
  v5 = *(MIDIServer **)&obj;
  *outData = 0;
  gMIDIClientLog();
  v6 = gMIDIClientLog(void)::clilib;
  v7 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v7)
  {
    *(_DWORD *)buf = 136316162;
    if (propertyID)
      v8 = propertyID;
    else
      v8 = CFSTR("(null)");
    v19 = "MIDIClientLib.cpp";
    v20 = 1024;
    v21 = 293;
    v22 = 2080;
    v23 = "MIDIObjectGetDataProperty";
    v24 = 2048;
    v25 = (CFDataRef)v5;
    v26 = 2112;
    v27 = v8;
    _os_log_impl(&dword_1D4E88000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s(%p) \"%@\"", buf, 0x30u);
  }
  if ((gInMIDIServer & 1) != 0)
  {
    DataProperty = _MIDIObjectGetDataProperty(v5, propertyID, outData);
  }
  else
  {
    v11 = MIDIProcess::defaultInstance((MIDIProcess *)v7);
    v12 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v11 + 56))(v11);
    v10 = v12;
    if ((_DWORD)v12)
      goto LABEL_13;
    v13 = ClientInterface::global(v12);
    DataProperty = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *, CFStringRef, CFDataRef *))*v13 + 14))(v13, v5, propertyID, outData);
  }
  v10 = DataProperty;
LABEL_13:
  gMIDIClientLog();
  v14 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    if (*outData)
      v15 = *outData;
    else
      v15 = (CFDataRef)CFSTR("(null)");
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v17, v10);
    *(_DWORD *)buf = 136316162;
    v19 = "MIDIClientLib.cpp";
    v20 = 1024;
    v21 = 300;
    v22 = 2080;
    v23 = "MIDIObjectGetDataProperty";
    v24 = 2112;
    v25 = v15;
    v26 = 2080;
    v27 = v17;
    _os_log_impl(&dword_1D4E88000, v14, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s = %@%s", buf, 0x30u);
  }
  return v10;
}

OSStatus MIDIObjectSetDictionaryProperty(MIDIObjectRef obj, CFStringRef propertyID, CFDictionaryRef dict)
{
  MIDIServer *v5;
  NSObject *v6;
  _BOOL8 v7;
  CFDictionaryRef v8;
  CFStringRef v9;
  unsigned int v10;
  uint64_t *v11;
  ClientInterface *v12;
  unsigned int v13;
  _UNKNOWN **v14;
  NSObject *v15;
  _BYTE v17[32];
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  unint64_t v25;
  __int16 v26;
  CFStringRef v27;
  __int16 v28;
  CFDictionaryRef v29;
  uint64_t v30;

  v5 = *(MIDIServer **)&obj;
  v30 = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v6 = gMIDIClientLog(void)::clilib;
  v7 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v7)
  {
    *(_DWORD *)buf = 136316418;
    v8 = (CFDictionaryRef)CFSTR("(null)");
    v19 = "MIDIClientLib.cpp";
    v20 = 1024;
    if (propertyID)
      v9 = propertyID;
    else
      v9 = CFSTR("(null)");
    v21 = 307;
    v22 = 2080;
    if (dict)
      v8 = dict;
    v23 = "MIDIObjectSetDictionaryProperty";
    v24 = 2048;
    v25 = v5;
    v26 = 2112;
    v27 = v9;
    v28 = 2112;
    v29 = v8;
    _os_log_impl(&dword_1D4E88000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s(%p) \"%@\" = %@", buf, 0x3Au);
  }
  if ((gInMIDIServer & 1) != 0)
  {
    v10 = _MIDIObjectSetDictionaryProperty(v5, propertyID, (uint64_t)dict);
  }
  else
  {
    v11 = MIDIProcess::defaultInstance((MIDIProcess *)v7);
    v12 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v11 + 56))(v11);
    v13 = v12;
    if ((_DWORD)v12)
      goto LABEL_13;
    v14 = ClientInterface::global(v12);
    v10 = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *, CFStringRef, CFDictionaryRef))*v14 + 17))(v14, v5, propertyID, dict);
  }
  v13 = v10;
LABEL_13:
  gMIDIClientLog();
  v15 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v17, v13);
    *(_DWORD *)buf = 136315906;
    v19 = "MIDIClientLib.cpp";
    v20 = 1024;
    v21 = 314;
    v22 = 2080;
    v23 = "MIDIObjectSetDictionaryProperty";
    v24 = 2080;
    v25 = (unint64_t)v17;
    _os_log_impl(&dword_1D4E88000, v15, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s%s", buf, 0x26u);
  }
  return v13;
}

OSStatus MIDIObjectGetDictionaryProperty(MIDIObjectRef obj, CFStringRef propertyID, CFDictionaryRef *outDict)
{
  MIDIServer *v5;
  NSObject *v6;
  _BOOL8 v7;
  CFStringRef v8;
  unsigned int DictionaryProperty;
  unsigned int v10;
  uint64_t *v11;
  ClientInterface *v12;
  _UNKNOWN **v13;
  NSObject *v14;
  CFDictionaryRef v15;
  _BYTE v17[32];
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  CFDictionaryRef v25;
  __int16 v26;
  _BYTE *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (!outDict)
    return -50;
  v5 = *(MIDIServer **)&obj;
  *outDict = 0;
  gMIDIClientLog();
  v6 = gMIDIClientLog(void)::clilib;
  v7 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v7)
  {
    *(_DWORD *)buf = 136316162;
    if (propertyID)
      v8 = propertyID;
    else
      v8 = CFSTR("(null)");
    v19 = "MIDIClientLib.cpp";
    v20 = 1024;
    v21 = 323;
    v22 = 2080;
    v23 = "MIDIObjectGetDictionaryProperty";
    v24 = 2048;
    v25 = (CFDictionaryRef)v5;
    v26 = 2112;
    v27 = v8;
    _os_log_impl(&dword_1D4E88000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s(%p) \"%@\"", buf, 0x30u);
  }
  if ((gInMIDIServer & 1) != 0)
  {
    DictionaryProperty = _MIDIObjectGetDictionaryProperty(v5, propertyID, (CFTypeRef *)outDict);
  }
  else
  {
    v11 = MIDIProcess::defaultInstance((MIDIProcess *)v7);
    v12 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v11 + 56))(v11);
    v10 = v12;
    if ((_DWORD)v12)
      goto LABEL_13;
    v13 = ClientInterface::global(v12);
    DictionaryProperty = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *, CFStringRef, CFDictionaryRef *))*v13 + 16))(v13, v5, propertyID, outDict);
  }
  v10 = DictionaryProperty;
LABEL_13:
  gMIDIClientLog();
  v14 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    if (*outDict)
      v15 = *outDict;
    else
      v15 = (CFDictionaryRef)CFSTR("(null)");
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v17, v10);
    *(_DWORD *)buf = 136316162;
    v19 = "MIDIClientLib.cpp";
    v20 = 1024;
    v21 = 330;
    v22 = 2080;
    v23 = "MIDIObjectGetDictionaryProperty";
    v24 = 2112;
    v25 = v15;
    v26 = 2080;
    v27 = v17;
    _os_log_impl(&dword_1D4E88000, v14, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s = %@%s", buf, 0x30u);
  }
  return v10;
}

OSStatus MIDIObjectRemoveProperty(MIDIObjectRef obj, CFStringRef propertyID)
{
  MIDIServer *v3;
  NSObject *v4;
  _BOOL8 v5;
  CFStringRef v6;
  unsigned int v7;
  uint64_t *v8;
  ClientInterface *v9;
  unsigned int v10;
  _UNKNOWN **v11;
  NSObject *v12;
  _BYTE v14[32];
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  unint64_t v22;
  __int16 v23;
  CFStringRef v24;
  uint64_t v25;

  v3 = *(MIDIServer **)&obj;
  v25 = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v4 = gMIDIClientLog(void)::clilib;
  v5 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v5)
  {
    *(_DWORD *)buf = 136316162;
    v6 = CFSTR("(null)");
    v16 = "MIDIClientLib.cpp";
    v17 = 1024;
    if (propertyID)
      v6 = propertyID;
    v18 = 338;
    v19 = 2080;
    v20 = "MIDIObjectRemoveProperty";
    v21 = 2048;
    v22 = v3;
    v23 = 2112;
    v24 = v6;
    _os_log_impl(&dword_1D4E88000, v4, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s(%p) \"%@\"", buf, 0x30u);
  }
  if ((gInMIDIServer & 1) != 0)
  {
    v7 = _MIDIObjectRemoveProperty(v3, propertyID);
  }
  else
  {
    v8 = MIDIProcess::defaultInstance((MIDIProcess *)v5);
    v9 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v8 + 56))(v8);
    v10 = v9;
    if ((_DWORD)v9)
      goto LABEL_10;
    v11 = ClientInterface::global(v9);
    v7 = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *, CFStringRef))*v11 + 19))(v11, v3, propertyID);
  }
  v10 = v7;
LABEL_10:
  gMIDIClientLog();
  v12 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v14, v10);
    *(_DWORD *)buf = 136315906;
    v16 = "MIDIClientLib.cpp";
    v17 = 1024;
    v18 = 345;
    v19 = 2080;
    v20 = "MIDIObjectRemoveProperty";
    v21 = 2080;
    v22 = (unint64_t)v14;
    _os_log_impl(&dword_1D4E88000, v12, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s%s", buf, 0x26u);
  }
  return v10;
}

ItemCount MIDIGetNumberOfDevices(void)
{
  MIDIServer *v0;
  uint64_t *v2;
  int *v3;
  ItemCount v4;
  CADeprecated::CAMutex *v5[2];
  int v6;

  if ((gInMIDIServer & 1) != 0)
    return _MIDIGetNumberOfDevices(v0);
  v2 = MIDIProcess::defaultInstance(v0);
  if (!(*(unsigned int (**)(uint64_t *))(*v2 + 56))(v2))
  {
    v6 = 0;
    ObjectTreeCache::ObjectTreeAccessor::ObjectTreeAccessor((ObjectTreeCache::ObjectTreeAccessor *)v5, (CFMutableDictionaryRef *)v2 + 36, (const __CFData *(*)(void *, int *))v2, &v6, v3);
    if (!v6)
    {
      v4 = **((unsigned int **)v5[0] + 14);
      ObjectTreeCache::ObjectTreeAccessor::~ObjectTreeAccessor(v5);
      return v4;
    }
    ObjectTreeCache::ObjectTreeAccessor::~ObjectTreeAccessor(v5);
  }
  return 0;
}

ObjectTreeCache::ObjectTreeAccessor *ObjectTreeCache::ObjectTreeAccessor::ObjectTreeAccessor(ObjectTreeCache::ObjectTreeAccessor *this, CFMutableDictionaryRef *a2, const __CFData *(*a3)(void *, int *), int *a4, int *a5)
{
  uint64_t v10;
  int v11;
  const __CFData *v12;
  CFMutableDictionaryRef v13;
  const UInt8 *BytePtr;
  uint64_t v15;
  unsigned int *v16;
  unint64_t v17;
  unsigned int *v18;
  unsigned int v19;
  unsigned int *v20;
  __CFDictionary *v21;
  uint64_t v22;
  unsigned int v23;
  unint64_t v24;
  unsigned int *v25;
  int v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)this = a2;
  *((_BYTE *)this + 8) = CADeprecated::CAMutex::Lock((CADeprecated::CAMutex *)a2);
  if (a2[11])
  {
LABEL_2:
    *a4 = 0;
    return this;
  }
  v10 = (*(uint64_t (**)(_QWORD, int *))(*(_QWORD *)a3 + 64))(a3, a4);
  v11 = *a4;
  if (!*a4)
  {
    v12 = (const __CFData *)v10;
    v13 = a2[11];
    if (v13)
      CFRelease(v13);
    a2[11] = v12;
    CFDictionaryRemoveAllValues(a2[12]);
    CFDictionaryRemoveAllValues(a2[13]);
    BytePtr = CFDataGetBytePtr(v12);
    a2[14] = (CFMutableDictionaryRef)BytePtr;
    v15 = *(unsigned int *)BytePtr;
    v16 = (unsigned int *)&BytePtr[4 * v15 + 4];
    if ((_DWORD)v15)
    {
      v17 = 0;
      do
      {
        v16 = ObjectTreeCache::ParseDeviceChildren((uint64_t)a2, (void *)*(unsigned int *)&BytePtr[4 * v17++ + 4], v16);
        BytePtr = (const UInt8 *)a2[14];
      }
      while (v17 < *(unsigned int *)BytePtr);
    }
    a2[15] = (CFMutableDictionaryRef)v16;
    v18 = &v16[*v16];
    v19 = v18[1];
    a2[16] = (CFMutableDictionaryRef)++v18;
    v20 = &v18[v19];
    v23 = v20[1];
    v21 = (__CFDictionary *)(v20 + 1);
    v22 = v23;
    a2[17] = v21;
    if (v23)
    {
      v24 = 0;
      v25 = (unsigned int *)((char *)v21 + 4 * v22 + 4);
      do
      {
        v25 = ObjectTreeCache::ParseDeviceChildren((uint64_t)a2, (void *)*((unsigned int *)v21 + ++v24), v25);
        v21 = a2[17];
      }
      while (v24 < *(unsigned int *)v21);
    }
    goto LABEL_2;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    v26 = 136315650;
    v27 = "ObjectTreeCache.h";
    v28 = 1024;
    v29 = 54;
    v30 = 1024;
    v31 = v11;
    _os_log_impl(&dword_1D4E88000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%25s:%-5d ObjectTreeCache: refresh status %d", (uint8_t *)&v26, 0x18u);
  }
  return this;
}

void ObjectTreeCache::ObjectTreeAccessor::~ObjectTreeAccessor(CADeprecated::CAMutex **this)
{
  if (*((_BYTE *)this + 8))
    CADeprecated::CAMutex::Unlock(*this);
}

MIDIDeviceRef MIDIGetDevice(ItemCount deviceIndex0)
{
  unsigned int v1;
  uint64_t *v3;
  int *v4;
  MIDIDeviceRef v5;
  unsigned int *v6;
  CADeprecated::CAMutex *v7[2];
  int v8;

  v1 = deviceIndex0;
  if ((gInMIDIServer & 1) != 0)
    return _MIDIGetDevice((MIDIServer *)deviceIndex0);
  v3 = MIDIProcess::defaultInstance((MIDIProcess *)deviceIndex0);
  if (!(*(unsigned int (**)(uint64_t *))(*v3 + 56))(v3))
  {
    v8 = 0;
    ObjectTreeCache::ObjectTreeAccessor::ObjectTreeAccessor((ObjectTreeCache::ObjectTreeAccessor *)v7, (CFMutableDictionaryRef *)v3 + 36, (const __CFData *(*)(void *, int *))v3, &v8, v4);
    if (!v8)
    {
      v6 = (unsigned int *)*((_QWORD *)v7[0] + 14);
      if (*v6 <= v1)
        v5 = 0;
      else
        v5 = v6[v1 + 1];
      ObjectTreeCache::ObjectTreeAccessor::~ObjectTreeAccessor(v7);
      return v5;
    }
    ObjectTreeCache::ObjectTreeAccessor::~ObjectTreeAccessor(v7);
  }
  return 0;
}

ItemCount MIDIGetNumberOfExternalDevices(void)
{
  MIDIServer *v0;
  uint64_t *v2;
  int *v3;
  ItemCount v4;
  CADeprecated::CAMutex *v5[2];
  int v6;

  if ((gInMIDIServer & 1) != 0)
    return _MIDIGetNumberOfExternalDevices(v0);
  v2 = MIDIProcess::defaultInstance(v0);
  if (!(*(unsigned int (**)(uint64_t *))(*v2 + 56))(v2))
  {
    v6 = 0;
    ObjectTreeCache::ObjectTreeAccessor::ObjectTreeAccessor((ObjectTreeCache::ObjectTreeAccessor *)v5, (CFMutableDictionaryRef *)v2 + 36, (const __CFData *(*)(void *, int *))v2, &v6, v3);
    if (!v6)
    {
      v4 = **((unsigned int **)v5[0] + 17);
      ObjectTreeCache::ObjectTreeAccessor::~ObjectTreeAccessor(v5);
      return v4;
    }
    ObjectTreeCache::ObjectTreeAccessor::~ObjectTreeAccessor(v5);
  }
  return 0;
}

MIDIDeviceRef MIDIGetExternalDevice(ItemCount deviceIndex0)
{
  unsigned int v1;
  uint64_t *v3;
  int *v4;
  MIDIDeviceRef v5;
  unsigned int *v6;
  CADeprecated::CAMutex *v7[2];
  int v8;

  v1 = deviceIndex0;
  if ((gInMIDIServer & 1) != 0)
    return _MIDIGetExternalDevice((MIDIServer *)deviceIndex0);
  v3 = MIDIProcess::defaultInstance((MIDIProcess *)deviceIndex0);
  if (!(*(unsigned int (**)(uint64_t *))(*v3 + 56))(v3))
  {
    v8 = 0;
    ObjectTreeCache::ObjectTreeAccessor::ObjectTreeAccessor((ObjectTreeCache::ObjectTreeAccessor *)v7, (CFMutableDictionaryRef *)v3 + 36, (const __CFData *(*)(void *, int *))v3, &v8, v4);
    if (!v8)
    {
      v6 = (unsigned int *)*((_QWORD *)v7[0] + 17);
      if (*v6 <= v1)
        v5 = 0;
      else
        v5 = v6[v1 + 1];
      ObjectTreeCache::ObjectTreeAccessor::~ObjectTreeAccessor(v7);
      return v5;
    }
    ObjectTreeCache::ObjectTreeAccessor::~ObjectTreeAccessor(v7);
  }
  return 0;
}

ItemCount MIDIGetNumberOfSources(void)
{
  MIDIServer *v0;
  uint64_t *v2;
  int *v3;
  ItemCount v4;
  CADeprecated::CAMutex *v5[2];
  int v6;

  if ((gInMIDIServer & 1) != 0)
    return _MIDIGetNumberOfSources(v0);
  v2 = MIDIProcess::defaultInstance(v0);
  if (!(*(unsigned int (**)(uint64_t *))(*v2 + 56))(v2))
  {
    v6 = 0;
    ObjectTreeCache::ObjectTreeAccessor::ObjectTreeAccessor((ObjectTreeCache::ObjectTreeAccessor *)v5, (CFMutableDictionaryRef *)v2 + 36, (const __CFData *(*)(void *, int *))v2, &v6, v3);
    if (!v6)
    {
      v4 = **((unsigned int **)v5[0] + 15);
      ObjectTreeCache::ObjectTreeAccessor::~ObjectTreeAccessor(v5);
      return v4;
    }
    ObjectTreeCache::ObjectTreeAccessor::~ObjectTreeAccessor(v5);
  }
  return 0;
}

MIDIEndpointRef MIDIGetSource(ItemCount sourceIndex0)
{
  unsigned int v1;
  uint64_t *v3;
  int *v4;
  MIDIEndpointRef v5;
  unsigned int *v6;
  CADeprecated::CAMutex *v7[2];
  int v8;

  v1 = sourceIndex0;
  if ((gInMIDIServer & 1) != 0)
    return _MIDIGetSource((MIDIServer *)sourceIndex0);
  v3 = MIDIProcess::defaultInstance((MIDIProcess *)sourceIndex0);
  if (!(*(unsigned int (**)(uint64_t *))(*v3 + 56))(v3))
  {
    v8 = 0;
    ObjectTreeCache::ObjectTreeAccessor::ObjectTreeAccessor((ObjectTreeCache::ObjectTreeAccessor *)v7, (CFMutableDictionaryRef *)v3 + 36, (const __CFData *(*)(void *, int *))v3, &v8, v4);
    if (!v8)
    {
      v6 = (unsigned int *)*((_QWORD *)v7[0] + 15);
      if (*v6 <= v1)
        v5 = 0;
      else
        v5 = v6[v1 + 1];
      ObjectTreeCache::ObjectTreeAccessor::~ObjectTreeAccessor(v7);
      return v5;
    }
    ObjectTreeCache::ObjectTreeAccessor::~ObjectTreeAccessor(v7);
  }
  return 0;
}

ItemCount MIDIGetNumberOfDestinations(void)
{
  MIDIServer *v0;
  uint64_t *v2;
  int *v3;
  ItemCount v4;
  CADeprecated::CAMutex *v5[2];
  int v6;

  if ((gInMIDIServer & 1) != 0)
    return _MIDIGetNumberOfDestinations(v0);
  v2 = MIDIProcess::defaultInstance(v0);
  if (!(*(unsigned int (**)(uint64_t *))(*v2 + 56))(v2))
  {
    v6 = 0;
    ObjectTreeCache::ObjectTreeAccessor::ObjectTreeAccessor((ObjectTreeCache::ObjectTreeAccessor *)v5, (CFMutableDictionaryRef *)v2 + 36, (const __CFData *(*)(void *, int *))v2, &v6, v3);
    if (!v6)
    {
      v4 = **((unsigned int **)v5[0] + 16);
      ObjectTreeCache::ObjectTreeAccessor::~ObjectTreeAccessor(v5);
      return v4;
    }
    ObjectTreeCache::ObjectTreeAccessor::~ObjectTreeAccessor(v5);
  }
  return 0;
}

MIDIEndpointRef MIDIGetDestination(ItemCount destIndex0)
{
  unsigned int v1;
  uint64_t *v3;
  int *v4;
  MIDIEndpointRef v5;
  unsigned int *v6;
  CADeprecated::CAMutex *v7[2];
  int v8;

  v1 = destIndex0;
  if ((gInMIDIServer & 1) != 0)
    return _MIDIGetDestination((MIDIServer *)destIndex0);
  v3 = MIDIProcess::defaultInstance((MIDIProcess *)destIndex0);
  if (!(*(unsigned int (**)(uint64_t *))(*v3 + 56))(v3))
  {
    v8 = 0;
    ObjectTreeCache::ObjectTreeAccessor::ObjectTreeAccessor((ObjectTreeCache::ObjectTreeAccessor *)v7, (CFMutableDictionaryRef *)v3 + 36, (const __CFData *(*)(void *, int *))v3, &v8, v4);
    if (!v8)
    {
      v6 = (unsigned int *)*((_QWORD *)v7[0] + 16);
      if (*v6 <= v1)
        v5 = 0;
      else
        v5 = v6[v1 + 1];
      ObjectTreeCache::ObjectTreeAccessor::~ObjectTreeAccessor(v7);
      return v5;
    }
    ObjectTreeCache::ObjectTreeAccessor::~ObjectTreeAccessor(v7);
  }
  return 0;
}

ItemCount MIDIDeviceGetNumberOfEntities(MIDIDeviceRef device)
{
  if ((gInMIDIServer & 1) != 0)
    return _MIDIDeviceGetNumberOfEntities(*(MIDIServer **)&device);
  else
    return CountChildrenOfNode(*(MIDIProcess **)&device, 0);
}

uint64_t CountChildrenOfNode(MIDIProcess *a1, int a2)
{
  unsigned int v3;
  CFMutableDictionaryRef *v4;
  int *v5;
  uint64_t v6;
  unsigned int *Value;
  CADeprecated::CAMutex *v9[2];
  int v10;

  if ((gInMIDIServer & 1) != 0)
    return 0;
  v3 = a1;
  v4 = (CFMutableDictionaryRef *)MIDIProcess::defaultInstance(a1);
  if ((*((unsigned int (**)(CFMutableDictionaryRef *))*v4 + 7))(v4))
    return 0;
  v10 = 0;
  ObjectTreeCache::ObjectTreeAccessor::ObjectTreeAccessor((ObjectTreeCache::ObjectTreeAccessor *)v9, v4 + 36, (const __CFData *(*)(void *, int *))v4, &v10, v5);
  if (v10 || (Value = (unsigned int *)CFDictionaryGetValue(*((CFDictionaryRef *)v9[0] + 12), (const void *)v3)) == 0)
  {
    v6 = 0;
  }
  else
  {
    if (a2)
      Value += *Value + 1;
    v6 = *Value;
  }
  ObjectTreeCache::ObjectTreeAccessor::~ObjectTreeAccessor(v9);
  return v6;
}

void sub_1D4EF51D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  ObjectTreeCache::ObjectTreeAccessor::~ObjectTreeAccessor((CADeprecated::CAMutex **)va);
  _Unwind_Resume(a1);
}

MIDIEntityRef MIDIDeviceGetEntity(MIDIDeviceRef device, ItemCount entityIndex0)
{
  if ((gInMIDIServer & 1) != 0)
    return _MIDIDeviceGetEntity(*(MIDIServer **)&device, entityIndex0);
  else
    return GetChildOfNode(*(MIDIProcess **)&device, entityIndex0, 0);
}

uint64_t GetChildOfNode(MIDIProcess *a1, unsigned int a2, int a3)
{
  unsigned int v5;
  CFMutableDictionaryRef *v6;
  int *v7;
  uint64_t v8;
  unsigned int *Value;
  CADeprecated::CAMutex *v11[2];
  int v12;

  if ((gInMIDIServer & 1) != 0)
    return 0;
  v5 = a1;
  v6 = (CFMutableDictionaryRef *)MIDIProcess::defaultInstance(a1);
  if ((*((unsigned int (**)(CFMutableDictionaryRef *))*v6 + 7))(v6))
    return 0;
  v12 = 0;
  ObjectTreeCache::ObjectTreeAccessor::ObjectTreeAccessor((ObjectTreeCache::ObjectTreeAccessor *)v11, v6 + 36, (const __CFData *(*)(void *, int *))v6, &v12, v7);
  v8 = 0;
  if (!v12)
  {
    Value = (unsigned int *)CFDictionaryGetValue(*((CFDictionaryRef *)v11[0] + 12), (const void *)v5);
    if (!Value)
      goto LABEL_11;
    if (a3)
      Value += *Value + 1;
    if (*Value > a2)
      v8 = Value[a2 + 1];
    else
LABEL_11:
      v8 = 0;
  }
  ObjectTreeCache::ObjectTreeAccessor::~ObjectTreeAccessor(v11);
  return v8;
}

void sub_1D4EF52D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  ObjectTreeCache::ObjectTreeAccessor::~ObjectTreeAccessor((CADeprecated::CAMutex **)va);
  _Unwind_Resume(a1);
}

ItemCount MIDIEntityGetNumberOfSources(MIDIEntityRef entity)
{
  if ((gInMIDIServer & 1) != 0)
    return _MIDIEntityGetNumberOfSources(*(MIDIServer **)&entity);
  else
    return CountChildrenOfNode(*(MIDIProcess **)&entity, 0);
}

MIDIEndpointRef MIDIEntityGetSource(MIDIEntityRef entity, ItemCount sourceIndex0)
{
  if ((gInMIDIServer & 1) != 0)
    return _MIDIEntityGetSource(*(MIDIServer **)&entity, sourceIndex0);
  else
    return GetChildOfNode(*(MIDIProcess **)&entity, sourceIndex0, 0);
}

ItemCount MIDIEntityGetNumberOfDestinations(MIDIEntityRef entity)
{
  if ((gInMIDIServer & 1) != 0)
    return _MIDIEntityGetNumberOfDestinations(*(MIDIServer **)&entity);
  else
    return CountChildrenOfNode(*(MIDIProcess **)&entity, 1);
}

MIDIEndpointRef MIDIEntityGetDestination(MIDIEntityRef entity, ItemCount destIndex0)
{
  if ((gInMIDIServer & 1) != 0)
    return _MIDIEntityGetDestination(*(MIDIServer **)&entity, destIndex0);
  else
    return GetChildOfNode(*(MIDIProcess **)&entity, destIndex0, 1);
}

OSStatus MIDIEntityGetDevice(MIDIEntityRef inEntity, MIDIDeviceRef *outDevice)
{
  uint64_t *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  OSStatus v8;
  CFMutableDictionaryRef *v9;
  int *v10;
  MIDIDeviceRef Value;
  CADeprecated::CAMutex *v13[2];
  int v14;

  if ((gInMIDIServer & 1) != 0)
  {
    v4 = MIDIServer::defaultInstance(*(MIDIServer **)&inEntity) + 2;
    v5 = (*(uint64_t (**)(uint64_t *))(*v4 + 16))(v4);
    if (outDevice)
    {
      v6 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIEntity>::sRTTI, inEntity);
      if (v6)
      {
        v7 = *(_QWORD *)(v6 + 16);
        *outDevice = 0;
        if (v7)
        {
          v8 = 0;
          *outDevice = *(_DWORD *)(v7 + 8);
        }
        else
        {
          v8 = -10842;
        }
        LOBYTE(outDevice) = 1;
        if (!v5)
          goto LABEL_16;
        goto LABEL_15;
      }
      LOBYTE(outDevice) = 0;
    }
    v8 = 0;
    if (!v5)
    {
LABEL_16:
      if ((outDevice & 1) == 0)
        return -50;
      return v8;
    }
LABEL_15:
    (*(void (**)(uint64_t *))(*v4 + 24))(v4);
    goto LABEL_16;
  }
  v9 = (CFMutableDictionaryRef *)MIDIProcess::defaultInstance(*(MIDIProcess **)&inEntity);
  if ((*((unsigned int (**)(CFMutableDictionaryRef *))*v9 + 7))(v9))
    return 0;
  v14 = 0;
  ObjectTreeCache::ObjectTreeAccessor::ObjectTreeAccessor((ObjectTreeCache::ObjectTreeAccessor *)v13, v9 + 36, (const __CFData *(*)(void *, int *))v9, &v14, v10);
  if (v14)
  {
    ObjectTreeCache::ObjectTreeAccessor::~ObjectTreeAccessor(v13);
    return 0;
  }
  Value = CFDictionaryGetValue(*((CFDictionaryRef *)v13[0] + 13), (const void *)inEntity);
  *outDevice = Value;
  if (Value)
    v8 = 0;
  else
    v8 = -10842;
  ObjectTreeCache::ObjectTreeAccessor::~ObjectTreeAccessor(v13);
  return v8;
}

void sub_1D4EF547C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  ObjectTreeCache::ObjectTreeAccessor::~ObjectTreeAccessor((CADeprecated::CAMutex **)va);
  _Unwind_Resume(a1);
}

void sub_1D4EF5494(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  char v11;

  if ((v11 & 1) != 0)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
    __cxa_begin_catch(a1);
    std::exception::~exception(&a10);
    __cxa_end_catch();
    JUMPOUT(0x1D4EF5434);
  }
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EF5464);
}

OSStatus MIDIEndpointGetEntity(MIDIEndpointRef inEndpoint, MIDIEntityRef *outEntity)
{
  uint64_t *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  OSStatus v8;
  CFMutableDictionaryRef *v9;
  int *v10;
  MIDIEntityRef Value;
  CADeprecated::CAMutex *v13[2];
  int v14;

  if ((gInMIDIServer & 1) != 0)
  {
    v4 = MIDIServer::defaultInstance(*(MIDIServer **)&inEndpoint) + 2;
    v5 = (*(uint64_t (**)(uint64_t *))(*v4 + 16))(v4);
    if (outEntity)
    {
      v6 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIEndpoint>::sRTTI, inEndpoint);
      if (v6)
      {
        v7 = *(_QWORD *)(v6 + 16);
        *outEntity = 0;
        if (v7)
        {
          v8 = 0;
          *outEntity = *(_DWORD *)(v7 + 8);
        }
        else
        {
          v8 = -10842;
        }
        LOBYTE(outEntity) = 1;
        if (!v5)
          goto LABEL_16;
        goto LABEL_15;
      }
      LOBYTE(outEntity) = 0;
    }
    v8 = 0;
    if (!v5)
    {
LABEL_16:
      if ((outEntity & 1) == 0)
        return -50;
      return v8;
    }
LABEL_15:
    (*(void (**)(uint64_t *))(*v4 + 24))(v4);
    goto LABEL_16;
  }
  v9 = (CFMutableDictionaryRef *)MIDIProcess::defaultInstance(*(MIDIProcess **)&inEndpoint);
  if ((*((unsigned int (**)(CFMutableDictionaryRef *))*v9 + 7))(v9))
    return 0;
  v14 = 0;
  ObjectTreeCache::ObjectTreeAccessor::ObjectTreeAccessor((ObjectTreeCache::ObjectTreeAccessor *)v13, v9 + 36, (const __CFData *(*)(void *, int *))v9, &v14, v10);
  if (v14)
  {
    ObjectTreeCache::ObjectTreeAccessor::~ObjectTreeAccessor(v13);
    return 0;
  }
  Value = CFDictionaryGetValue(*((CFDictionaryRef *)v13[0] + 13), (const void *)inEndpoint);
  *outEntity = Value;
  if (Value)
    v8 = 0;
  else
    v8 = -10842;
  ObjectTreeCache::ObjectTreeAccessor::~ObjectTreeAccessor(v13);
  return v8;
}

void sub_1D4EF5660(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  ObjectTreeCache::ObjectTreeAccessor::~ObjectTreeAccessor((CADeprecated::CAMutex **)va);
  _Unwind_Resume(a1);
}

void sub_1D4EF5678(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
  uint64_t v10;
  char v11;

  if ((v11 & 1) != 0)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  if (a2 == 2)
  {
    __cxa_get_exception_ptr(a1);
    a10.__vftable = (std::exception_vtbl *)(MEMORY[0x1E0DE5050] + 16);
    __cxa_begin_catch(a1);
    std::exception::~exception(&a10);
    __cxa_end_catch();
    JUMPOUT(0x1D4EF5618);
  }
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EF5648);
}

OSStatus MIDIClientCreate(CFStringRef name, MIDINotifyProc notifyProc, void *notifyRefCon, MIDIClientRef *outClient)
{
  _QWORD v5[6];

  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = __MIDIClientCreate_block_invoke;
  v5[3] = &__block_descriptor_tmp_2629;
  v5[4] = notifyProc;
  v5[5] = notifyRefCon;
  return MIDIClientCreateWithBlockInternal(name, (int *)outClient, v5, 0);
}

uint64_t MIDIClientCreateWithBlockInternal(const __CFString *a1, int *a2, const void *a3, char a4)
{
  NSObject *v8;
  _BOOL8 v9;
  uint64_t v10;
  uint64_t *v11;
  ClientInterface *v12;
  _UNKNOWN **v13;
  int v14;
  int v15;
  _QWORD *v16;
  unint64_t v17;
  _OWORD *v18;
  uint64_t v19;
  const char *v20;
  NSObject *v21;
  uint32_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  char *v28;
  uint64_t v29;
  char *v30;
  _QWORD *v31;
  _QWORD *v32;
  char *v33;
  __int128 v34;
  int64x2_t v35;
  _OWORD *v36;
  uint64_t v37;
  void *v38;
  std::__shared_weak_count *v39;
  unint64_t *p_shared_owners;
  unint64_t v41;
  uint64_t v42;
  int v43;
  _BYTE v45[32];
  _BYTE buf[18];
  __int16 v47;
  const char *v48;
  __int16 v49;
  _BYTE v50[18];
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v8 = gMIDIClientLog(void)::clilib;
  v9 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v9)
  {
    *(_DWORD *)buf = 136316162;
    *(_QWORD *)&buf[4] = "MIDIClientLib.cpp";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 663;
    v47 = 2080;
    v48 = "MIDIClientCreateWithBlockInternal";
    v49 = 2112;
    *(_QWORD *)v50 = a1;
    *(_WORD *)&v50[8] = 2048;
    *(_QWORD *)&v50[10] = a3;
    _os_log_impl(&dword_1D4E88000, v8, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s \"%@\", block %p", buf, 0x30u);
  }
  if ((gInMIDIServer & 1) != 0)
  {
    v10 = _MIDIClientCreate(0, a1, (uint64_t)a2, a3);
    if (!a2)
    {
LABEL_14:
      gMIDIClientLog();
      v19 = gMIDIClientLog(void)::clilib;
      if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
      {
        ErrorFormatter::ErrorFormatter((ErrorFormatter *)v45, v10);
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = "MIDIClientLib.cpp";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 679;
        v47 = 2080;
        v48 = "MIDIClientCreateWithBlockInternal";
        v49 = 2080;
        *(_QWORD *)v50 = v45;
        v20 = "%25s:%-5d <-%s: (null ptr)%s";
        v21 = v19;
        v22 = 38;
LABEL_42:
        _os_log_impl(&dword_1D4E88000, v21, OS_LOG_TYPE_DEBUG, v20, buf, v22);
        return v10;
      }
      return v10;
    }
  }
  else
  {
    if (!a2)
    {
      v10 = 4294967246;
      goto LABEL_14;
    }
    v11 = MIDIProcess::defaultInstance((MIDIProcess *)v9);
    v12 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v11 + 56))(v11);
    v10 = (uint64_t)v12;
    if (!(_DWORD)v12)
    {
      v13 = ClientInterface::global(v12);
      v10 = (*((uint64_t (**)(_UNKNOWN **, const __CFString *, int *))*v13 + 2))(v13, a1, a2);
      if (!(_DWORD)v10)
      {
        v14 = *a2;
        v15 = (*(uint64_t (**)(uint64_t *))(v11[7] + 16))(v11 + 7);
        v16 = operator new(0x30uLL);
        v16[1] = 0;
        v16[2] = 0;
        *v16 = &off_1E98B9FD0;
        *((_DWORD *)v16 + 6) = v14;
        v16[4] = 0;
        *((_BYTE *)v16 + 40) = a4;
        if (a3)
          v16[4] = _Block_copy(a3);
        *(_QWORD *)buf = v16 + 3;
        *(_QWORD *)&buf[8] = v16;
        v18 = (_OWORD *)v11[19];
        v17 = v11[20];
        if ((unint64_t)v18 >= v17)
        {
          v23 = v11[18];
          v24 = ((uint64_t)v18 - v23) >> 4;
          v25 = v24 + 1;
          if ((unint64_t)(v24 + 1) >> 60)
            std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
          v26 = v17 - v23;
          if (v26 >> 3 > v25)
            v25 = v26 >> 3;
          if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF0)
            v27 = 0xFFFFFFFFFFFFFFFLL;
          else
            v27 = v25;
          v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<nlohmann::basic_json<std::map,std::vector,std::string,BOOL,long long,unsigned long long,double,std::allocator,nlohmann::adl_serializer,std::vector<unsigned char>>>>(v27);
          v30 = &v28[16 * v24];
          *(_OWORD *)v30 = *(_OWORD *)buf;
          *(_QWORD *)buf = 0;
          *(_QWORD *)&buf[8] = 0;
          v32 = (_QWORD *)v11[18];
          v31 = (_QWORD *)v11[19];
          if (v31 == v32)
          {
            v35 = vdupq_n_s64((unint64_t)v31);
            v33 = &v28[16 * v24];
          }
          else
          {
            v33 = &v28[16 * v24];
            do
            {
              v34 = *((_OWORD *)v31 - 1);
              v31 -= 2;
              *((_OWORD *)v33 - 1) = v34;
              v33 -= 16;
              *v31 = 0;
              v31[1] = 0;
            }
            while (v31 != v32);
            v35 = *((int64x2_t *)v11 + 9);
          }
          v36 = v30 + 16;
          v11[18] = (uint64_t)v33;
          v11[19] = (uint64_t)(v30 + 16);
          v11[20] = (uint64_t)&v28[16 * v29];
          v37 = v35.i64[1];
          v38 = (void *)v35.i64[0];
          while ((void *)v37 != v38)
            v37 = std::shared_ptr<swix::connection::state>::~shared_ptr[abi:ne180100](v37 - 16);
          if (v38)
          {
            operator delete(v38);
            v39 = *(std::__shared_weak_count **)&buf[8];
            v11[19] = (uint64_t)v36;
            if (v39)
            {
              p_shared_owners = (unint64_t *)&v39->__shared_owners_;
              do
                v41 = __ldaxr(p_shared_owners);
              while (__stlxr(v41 - 1, p_shared_owners));
              if (!v41)
              {
                ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
                std::__shared_weak_count::__release_weak(v39);
              }
            }
          }
          else
          {
            v11[19] = (uint64_t)v36;
          }
        }
        else
        {
          *v18 = *(_OWORD *)buf;
          v11[19] = (uint64_t)(v18 + 1);
        }
        if (v15)
          (*(void (**)(uint64_t *))(v11[7] + 24))(v11 + 7);
        v10 = 0;
      }
    }
  }
  gMIDIClientLog();
  v42 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    v43 = *a2;
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v45, v10);
    *(_DWORD *)buf = 136316162;
    *(_QWORD *)&buf[4] = "MIDIClientLib.cpp";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 679;
    v47 = 2080;
    v48 = "MIDIClientCreateWithBlockInternal";
    v49 = 1024;
    *(_DWORD *)v50 = v43;
    *(_WORD *)&v50[4] = 2080;
    *(_QWORD *)&v50[6] = v45;
    v20 = "%25s:%-5d <-%s: 0x%x%s";
    v21 = v42;
    v22 = 44;
    goto LABEL_42;
  }
  return v10;
}

void sub_1D4EF5BC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

OSStatus MIDIClientCreateWithBlock(CFStringRef name, MIDIClientRef *outClient, MIDINotifyBlock notifyBlock)
{
  return MIDIClientCreateWithBlockInternal(name, (int *)outClient, notifyBlock, 0);
}

OSStatus MIDIClientDispose(MIDIClientRef client)
{
  MIDIServer *v1;
  NSObject *v2;
  _BOOL8 v3;
  unsigned int v4;
  uint64_t *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  ClientInterface *v14;
  unint64_t v15;
  unsigned int *v16;
  uint64_t v17;
  const void ***v18;
  const void **v19;
  unsigned int v20;
  char *v21;
  int64_t v22;
  unsigned int v23;
  _UNKNOWN **v25;
  int v26;
  BOOL v27;
  NSObject *v28;
  CADeprecated::XThread *v29;
  CADeprecated::XThread *v30;
  CADeprecated::XThread *v31;
  NSObject *v32;
  int v34;
  void **v35[4];
  _BYTE buf[28];
  __int16 v37;
  void ***v38;
  uint64_t v39;

  v1 = *(MIDIServer **)&client;
  v39 = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v2 = gMIDIClientLog(void)::clilib;
  v3 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v3)
  {
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = "MIDIClientLib.cpp";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 688;
    *(_WORD *)&buf[18] = 2080;
    *(_QWORD *)&buf[20] = "MIDIClientDispose";
    v37 = 1024;
    LODWORD(v38) = (_DWORD)v1;
    _os_log_impl(&dword_1D4E88000, v2, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s 0x%x", buf, 0x22u);
  }
  if ((gInMIDIServer & 1) != 0)
  {
    v4 = _MIDIClientDispose(v1);
  }
  else
  {
    v5 = MIDIProcess::defaultInstance((MIDIProcess *)v3);
    v4 = (*(uint64_t (**)(uint64_t *))(*v5 + 56))(v5);
    if (!v4)
    {
      v6 = (*(uint64_t (**)(uint64_t *))(v5[7] + 16))(v5 + 7);
      v8 = v5[18];
      v7 = v5[19];
      if (v8 != v7)
      {
        while (**(_DWORD **)v8 != (_DWORD)v1)
        {
          v8 += 16;
          if (v8 == v7)
            goto LABEL_22;
        }
      }
      if (v8 != v7)
      {
        v9 = v8 + 16;
        if (v8 + 16 != v7)
        {
          do
          {
            v10 = *(_OWORD *)v9;
            *(_QWORD *)v9 = 0;
            *(_QWORD *)(v9 + 8) = 0;
            v11 = *(std::__shared_weak_count **)(v8 + 8);
            *(_OWORD *)v8 = v10;
            if (v11)
            {
              p_shared_owners = (unint64_t *)&v11->__shared_owners_;
              do
                v13 = __ldaxr(p_shared_owners);
              while (__stlxr(v13 - 1, p_shared_owners));
              if (!v13)
              {
                ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
                std::__shared_weak_count::__release_weak(v11);
              }
            }
            v9 += 16;
            v8 += 16;
          }
          while (v9 != v7);
          v7 = v5[19];
        }
        while (v7 != v8)
        {
          v7 -= 16;
          std::shared_ptr<swix::connection::state>::~shared_ptr[abi:ne180100](v7);
        }
        v5[19] = v8;
      }
LABEL_22:
      if (v6)
        (*(void (**)(uint64_t *))(v5[7] + 24))(v5 + 7);
      v14 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(v5[24] + 16))(v5 + 24);
      v34 = (int)v14;
      v15 = v5[22] - v5[21];
      if ((int)(v15 >> 3) >= 1)
      {
        v16 = (unsigned int *)(v5 + 35);
        v17 = (v15 >> 3);
        do
        {
          v18 = (const void ***)(v5[21] + 8 * (v17 - 1));
          v19 = *v18;
          if (*(_DWORD *)*v18 == (_DWORD)v1)
          {
            do
              v20 = __ldaxr(v16);
            while (__stlxr(v20 + 1, v16));
            while (*((_DWORD *)v5 + 71))
              usleep(0x1F4u);
            v21 = (char *)v5[22];
            v22 = v21 - (char *)(v18 + 1);
            if (v21 != (char *)(v18 + 1))
              memmove(v18, v18 + 1, v21 - (char *)(v18 + 1));
            v5[22] = (uint64_t)v18 + v22;
            LocalMIDIReceiver::~LocalMIDIReceiver(v19);
            v14 = (ClientInterface *)MEMORY[0x1D826BA98]();
            do
              v23 = __ldaxr(v16);
            while (__stlxr(v23 - 1, v16));
          }
        }
        while (v17-- > 1);
      }
      if (v34)
        v14 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(v5[24] + 24))(v5 + 24);
      v25 = ClientInterface::global(v14);
      v4 = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *))*v25 + 3))(v25, v1);
      memset(buf, 0, 24);
      LocalClientList::Copy((char **)v5 + 7, (char **)buf);
      if (*(_QWORD *)&buf[8] - *(_QWORD *)buf == 16)
      {
        v26 = **(_DWORD **)v5[18];
        v35[0] = (void **)buf;
        std::vector<std::shared_ptr<LocalMIDIClient>>::__destroy_vector::operator()[abi:ne180100](v35);
        if (v26)
          v27 = gClientState == v26;
        else
          v27 = 0;
        if (v27)
        {
          gSysexSender();
          v28 = gSysexSender(void)::ssxsnd;
          if (os_log_type_enabled((os_log_t)gSysexSender(void)::ssxsnd, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)&buf[4] = "SysexSender.cpp";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 233;
            _os_log_impl(&dword_1D4E88000, v28, OS_LOG_TYPE_DEBUG, "%25s:%-5d [?] SysexSenderShutDown()", buf, 0x12u);
          }
          gAborting = 1;
          std::mutex::lock(&stru_1EFEFC9E0);
          v29 = (CADeprecated::XThread *)SysexSender<MIDISysexSendRequest,false>::sInstance;
          if (SysexSender<MIDISysexSendRequest,false>::sInstance)
          {
            std::mutex::lock(&gCreateDisposeLock);
            *((_BYTE *)v29 + 123) = 1;
            CADeprecated::XThread::Stop(v29);
            SysexSender<MIDISysexSendRequest,false>::sInstance = 0;
            std::mutex::unlock(&gCreateDisposeLock);
          }
          v30 = (CADeprecated::XThread *)SysexSender<MIDISysexSendRequestUMP,false>::sInstance;
          if (SysexSender<MIDISysexSendRequestUMP,false>::sInstance)
          {
            std::mutex::lock(&gCreateDisposeLockUMP);
            *((_BYTE *)v30 + 123) = 1;
            CADeprecated::XThread::Stop(v30);
            SysexSender<MIDISysexSendRequestUMP,false>::sInstance = 0;
            std::mutex::unlock(&gCreateDisposeLockUMP);
          }
          v31 = (CADeprecated::XThread *)SysexSender<MIDISysexSendRequestUMP,true>::sInstance;
          if (SysexSender<MIDISysexSendRequestUMP,true>::sInstance)
          {
            std::mutex::lock(&gCreateDisposeLockUMP8);
            *((_BYTE *)v31 + 123) = 1;
            CADeprecated::XThread::Stop(v31);
            SysexSender<MIDISysexSendRequestUMP,true>::sInstance = 0;
            std::mutex::unlock(&gCreateDisposeLockUMP8);
          }
          MIDIPortDispose(dword_1EFEFC9DC);
          dword_1EFEFC9DC = 0;
          MIDIClientDispose(gClientState);
          gClientState = 0;
          gAborting = 0;
          std::mutex::unlock(&stru_1EFEFC9E0);
        }
      }
      else
      {
        v35[0] = (void **)buf;
        std::vector<std::shared_ptr<LocalMIDIClient>>::__destroy_vector::operator()[abi:ne180100](v35);
      }
    }
  }
  gMIDIClientLog();
  v32 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v35, v4);
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = "MIDIClientLib.cpp";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 701;
    *(_WORD *)&buf[18] = 2080;
    *(_QWORD *)&buf[20] = "MIDIClientDispose";
    v37 = 2080;
    v38 = v35;
    _os_log_impl(&dword_1D4E88000, v32, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s%s", buf, 0x26u);
  }
  return v4;
}

void sub_1D4EF619C(_Unwind_Exception *a1)
{
  std::mutex::unlock(&gCreateDisposeLockUMP8);
  std::mutex::unlock(&stru_1EFEFC9E0);
  _Unwind_Resume(a1);
}

uint64_t MIDICapabilityGetDiscoveryMUID(MIDIServer *a1)
{
  uint64_t DiscoveryMUID;
  unsigned int v2;
  uint64_t *v3;
  ClientInterface *v4;
  _UNKNOWN **v5;
  uint64_t v6;
  NSObject *v7;
  _BYTE v9[32];
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  _BYTE *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if ((gInMIDIServer & 1) != 0)
  {
    DiscoveryMUID = _MIDICapabilityGetDiscoveryMUID(a1);
    v2 = 0;
  }
  else
  {
    v3 = MIDIProcess::defaultInstance(a1);
    v4 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v3 + 56))(v3);
    if ((_DWORD)v4)
    {
      v2 = v4;
      DiscoveryMUID = 0;
    }
    else
    {
      v5 = ClientInterface::global(v4);
      v6 = (*((uint64_t (**)(_UNKNOWN **))*v5 + 23))(v5);
      if ((v6 & 0xFF00000000) != 0)
        v2 = 0;
      else
        v2 = v6;
      if ((v6 & 0xFF00000000) != 0)
        DiscoveryMUID = v6;
      else
        DiscoveryMUID = 0;
    }
  }
  gMIDIClientLog();
  v7 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v9, v2);
    *(_DWORD *)buf = 136315906;
    v11 = "MIDIClientLib.cpp";
    v12 = 1024;
    v13 = 720;
    v14 = 2080;
    v15 = "MIDICapabilityGetDiscoveryMUID";
    v16 = 2080;
    v17 = v9;
    _os_log_impl(&dword_1D4E88000, v7, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s%s", buf, 0x26u);
  }
  return DiscoveryMUID;
}

BOOL MIDICapabilityMUIDCollides(MIDIServer *a1)
{
  _BOOL8 v2;
  unsigned int v3;
  uint64_t *v4;
  ClientInterface *v5;
  _UNKNOWN **v6;
  uint64_t v7;
  NSObject *v8;
  _BYTE v10[32];
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  _BYTE *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if ((gInMIDIServer & 1) != 0)
  {
    v2 = _MIDICapabilityMUIDCollides(a1);
    v3 = 0;
  }
  else
  {
    v4 = MIDIProcess::defaultInstance(a1);
    v5 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v4 + 56))(v4);
    if ((_DWORD)v5)
    {
      v3 = v5;
      v2 = 0;
    }
    else
    {
      v6 = ClientInterface::global(v5);
      v7 = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *))*v6 + 24))(v6, a1);
      if ((v7 & 0xFF00000000) != 0)
        v3 = 0;
      else
        v3 = v7;
      v2 = (v7 & 0xFF00000000) != 0 && v7 != 0;
    }
  }
  gMIDIClientLog();
  v8 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v10, v3);
    *(_DWORD *)buf = 136315906;
    v12 = "MIDIClientLib.cpp";
    v13 = 1024;
    v14 = 739;
    v15 = 2080;
    v16 = "MIDICapabilityMUIDCollides";
    v17 = 2080;
    v18 = v10;
    _os_log_impl(&dword_1D4E88000, v8, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s%s", buf, 0x26u);
  }
  return v2;
}

OSStatus MIDIInputPortCreate(MIDIClientRef client, CFStringRef portName, MIDIReadProc readProc, void *refCon, MIDIPortRef *outPort)
{
  _QWORD v6[6];

  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __MIDIInputPortCreate_block_invoke;
  v6[3] = &__block_descriptor_tmp_5;
  v6[4] = readProc;
  v6[5] = refCon;
  return MIDIInputPortCreateInternal(*(MIDIServer **)&client, portName, 1, (int *)outPort, v6, 0);
}

uint64_t MIDIInputPortCreateInternal(MIDIServer *a1, const __CFString *a2, uint64_t a3, int *a4, const void *a5, const void *a6)
{
  NSObject *v12;
  _BOOL8 v13;
  uint64_t v14;
  uint64_t *v15;
  ClientInterface *v16;
  _UNKNOWN **v17;
  uint64_t v18;
  int v19;
  const char *v20;
  NSObject *v21;
  uint32_t v22;
  uint64_t v23;
  _BYTE v25[32];
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  const char *v31;
  __int16 v32;
  _BYTE v33[14];
  __int16 v34;
  const void *v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v12 = gMIDIClientLog(void)::clilib;
  v13 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v13)
  {
    *(_DWORD *)buf = 136316418;
    v27 = "MIDIClientLib.cpp";
    v28 = 1024;
    v29 = 749;
    v30 = 2080;
    v31 = "MIDIInputPortCreateInternal";
    v32 = 1024;
    *(_DWORD *)v33 = (_DWORD)a1;
    *(_WORD *)&v33[4] = 2112;
    *(_QWORD *)&v33[6] = a2;
    v34 = 2048;
    v35 = a5;
    _os_log_impl(&dword_1D4E88000, v12, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s 0x%x \"%@\", block %p", buf, 0x36u);
  }
  if ((gInMIDIServer & 1) != 0)
  {
    v14 = _MIDIInputPortCreate(a1, a2, a3, a4, a5, a6);
    if (!a4)
    {
LABEL_13:
      gMIDIClientLog();
      v23 = gMIDIClientLog(void)::clilib;
      if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
      {
        ErrorFormatter::ErrorFormatter((ErrorFormatter *)v25, v14);
        *(_DWORD *)buf = 136315906;
        v27 = "MIDIClientLib.cpp";
        v28 = 1024;
        v29 = 759;
        v30 = 2080;
        v31 = "MIDIInputPortCreateInternal";
        v32 = 2080;
        *(_QWORD *)v33 = v25;
        v20 = "%25s:%-5d <-%s: (null ptr)%s";
        v21 = v23;
        v22 = 38;
        goto LABEL_15;
      }
      return v14;
    }
  }
  else
  {
    if (!a4)
    {
      v14 = 4294967246;
      goto LABEL_13;
    }
    v15 = MIDIProcess::defaultInstance((MIDIProcess *)v13);
    v16 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v15 + 56))(v15);
    v14 = (uint64_t)v16;
    if (!(_DWORD)v16)
    {
      v17 = ClientInterface::global(v16);
      v14 = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *, const __CFString *, uint64_t, int *))*v17 + 42))(v17, a1, a2, a3, a4);
      if (!(_DWORD)v14)
        LocalMIDIReceiverList::Add((uint64_t)(v15 + 21), (int)a1, *a4, a3, a5, a6);
    }
  }
  gMIDIClientLog();
  v18 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    v19 = *a4;
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v25, v14);
    *(_DWORD *)buf = 136316162;
    v27 = "MIDIClientLib.cpp";
    v28 = 1024;
    v29 = 759;
    v30 = 2080;
    v31 = "MIDIInputPortCreateInternal";
    v32 = 1024;
    *(_DWORD *)v33 = v19;
    *(_WORD *)&v33[4] = 2080;
    *(_QWORD *)&v33[6] = v25;
    v20 = "%25s:%-5d <-%s: 0x%x%s";
    v21 = v18;
    v22 = 44;
LABEL_15:
    _os_log_impl(&dword_1D4E88000, v21, OS_LOG_TYPE_DEBUG, v20, buf, v22);
  }
  return v14;
}

OSStatus MIDIInputPortCreateWithBlock(MIDIClientRef client, CFStringRef portName, MIDIPortRef *outPort, MIDIReadBlock readBlock)
{
  return MIDIInputPortCreateInternal(*(MIDIServer **)&client, portName, 1, (int *)outPort, readBlock, 0);
}

OSStatus MIDIInputPortCreateWithProtocol(MIDIClientRef client, CFStringRef portName, MIDIProtocolID protocol, MIDIPortRef *outPort, MIDIReceiveBlock receiveBlock)
{
  return MIDIInputPortCreateInternal(*(MIDIServer **)&client, portName, *(uint64_t *)&protocol, (int *)outPort, 0, receiveBlock);
}

OSStatus MIDIOutputPortCreate(MIDIClientRef client, CFStringRef portName, MIDIPortRef *outPort)
{
  MIDIServer *v5;
  NSObject *v6;
  _BOOL8 v7;
  int v8;
  uint64_t *v9;
  ClientInterface *v10;
  _UNKNOWN **v11;
  uint64_t v12;
  MIDIPortRef v13;
  const char *v14;
  NSObject *v15;
  uint32_t v16;
  uint64_t v17;
  _BYTE v19[32];
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  const char *v25;
  __int16 v26;
  _WORD v27[17];

  v5 = *(MIDIServer **)&client;
  *(_QWORD *)&v27[13] = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v6 = gMIDIClientLog(void)::clilib;
  v7 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v7)
  {
    *(_DWORD *)buf = 136316162;
    v21 = "MIDIClientLib.cpp";
    v22 = 1024;
    v23 = 790;
    v24 = 2080;
    v25 = "MIDIOutputPortCreate";
    v26 = 1024;
    *(_DWORD *)v27 = (_DWORD)v5;
    v27[2] = 2112;
    *(_QWORD *)&v27[3] = portName;
    _os_log_impl(&dword_1D4E88000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s 0x%x \"%@\"", buf, 0x2Cu);
  }
  if ((gInMIDIServer & 1) != 0)
  {
    v8 = _MIDIOutputPortCreate(v5, portName, outPort);
    if (!outPort)
    {
LABEL_12:
      gMIDIClientLog();
      v17 = gMIDIClientLog(void)::clilib;
      if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
      {
        ErrorFormatter::ErrorFormatter((ErrorFormatter *)v19, v8);
        *(_DWORD *)buf = 136315906;
        v21 = "MIDIClientLib.cpp";
        v22 = 1024;
        v23 = 798;
        v24 = 2080;
        v25 = "MIDIOutputPortCreate";
        v26 = 2080;
        *(_QWORD *)v27 = v19;
        v14 = "%25s:%-5d <-%s: (null ptr)%s";
        v15 = v17;
        v16 = 38;
        goto LABEL_14;
      }
      return v8;
    }
  }
  else
  {
    if (!outPort)
    {
      v8 = -50;
      goto LABEL_12;
    }
    v9 = MIDIProcess::defaultInstance((MIDIProcess *)v7);
    v10 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v9 + 56))(v9);
    v8 = (int)v10;
    if (!(_DWORD)v10)
    {
      v11 = ClientInterface::global(v10);
      v8 = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *, CFStringRef, MIDIPortRef *))*v11 + 4))(v11, v5, portName, outPort);
    }
  }
  gMIDIClientLog();
  v12 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    v13 = *outPort;
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v19, v8);
    *(_DWORD *)buf = 136316162;
    v21 = "MIDIClientLib.cpp";
    v22 = 1024;
    v23 = 798;
    v24 = 2080;
    v25 = "MIDIOutputPortCreate";
    v26 = 1024;
    *(_DWORD *)v27 = v13;
    v27[2] = 2080;
    *(_QWORD *)&v27[3] = v19;
    v14 = "%25s:%-5d <-%s: 0x%x%s";
    v15 = v12;
    v16 = 44;
LABEL_14:
    _os_log_impl(&dword_1D4E88000, v15, OS_LOG_TYPE_DEBUG, v14, buf, v16);
  }
  return v8;
}

OSStatus MIDIPortDispose(MIDIPortRef port)
{
  MIDIServer *v1;
  NSObject *v2;
  _BOOL8 v3;
  unsigned int v4;
  uint64_t *v5;
  unsigned int v6;
  ClientInterface *v7;
  _UNKNOWN **v8;
  NSObject *v9;
  _BYTE v11[32];
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  _BYTE *v19;
  uint64_t v20;

  v1 = *(MIDIServer **)&port;
  v20 = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v2 = gMIDIClientLog(void)::clilib;
  v3 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v3)
  {
    *(_DWORD *)buf = 136315906;
    v13 = "MIDIClientLib.cpp";
    v14 = 1024;
    v15 = 805;
    v16 = 2080;
    v17 = "MIDIPortDispose";
    v18 = 1024;
    LODWORD(v19) = (_DWORD)v1;
    _os_log_impl(&dword_1D4E88000, v2, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s 0x%x", buf, 0x22u);
  }
  if ((gInMIDIServer & 1) != 0)
  {
    v4 = _MIDIPortDispose(v1);
  }
  else
  {
    v5 = MIDIProcess::defaultInstance((MIDIProcess *)v3);
    v6 = (*(uint64_t (**)(uint64_t *))(*v5 + 56))(v5);
    if (v6)
      goto LABEL_8;
    v7 = (ClientInterface *)LocalMIDIReceiverList::Remove((LocalMIDIReceiverList *)(v5 + 21), (int)v1);
    v8 = ClientInterface::global(v7);
    v4 = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *))*v8 + 5))(v8, v1);
  }
  v6 = v4;
LABEL_8:
  gMIDIClientLog();
  v9 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v11, v6);
    *(_DWORD *)buf = 136315906;
    v13 = "MIDIClientLib.cpp";
    v14 = 1024;
    v15 = 813;
    v16 = 2080;
    v17 = "MIDIPortDispose";
    v18 = 2080;
    v19 = v11;
    _os_log_impl(&dword_1D4E88000, v9, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s%s", buf, 0x26u);
  }
  return v6;
}

OSStatus MIDIPortConnectSource(MIDIPortRef port, MIDIEndpointRef source, void *connRefCon)
{
  uint64_t v4;
  MIDIServer *v5;
  NSObject *v6;
  _BOOL8 v7;
  unsigned int v8;
  uint64_t *v9;
  ClientInterface *v10;
  _UNKNOWN **v11;
  NSObject *v12;
  _BYTE v14[32];
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  _BYTE v22[10];
  __int16 v23;
  void *v24;
  uint64_t v25;

  v4 = *(_QWORD *)&source;
  v5 = *(MIDIServer **)&port;
  v25 = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v6 = gMIDIClientLog(void)::clilib;
  v7 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v7)
  {
    *(_DWORD *)buf = 136316418;
    v16 = "MIDIClientLib.cpp";
    v17 = 1024;
    v18 = 820;
    v19 = 2080;
    v20 = "MIDIPortConnectSource";
    v21 = 1024;
    *(_DWORD *)v22 = (_DWORD)v5;
    *(_WORD *)&v22[4] = 1024;
    *(_DWORD *)&v22[6] = v4;
    v23 = 2048;
    v24 = connRefCon;
    _os_log_impl(&dword_1D4E88000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s 0x%x src 0x%x, connRefCon %p", buf, 0x32u);
  }
  if ((gInMIDIServer & 1) != 0)
  {
    v8 = _MIDIPortConnectSource(v5, v4, (uint64_t)connRefCon);
  }
  else
  {
    v9 = MIDIProcess::defaultInstance((MIDIProcess *)v7);
    v10 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v9 + 56))(v9);
    v8 = v10;
    if (!(_DWORD)v10)
    {
      v11 = ClientInterface::global(v10);
      v8 = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *, uint64_t, void *))*v11 + 6))(v11, v5, v4, connRefCon);
      if (!v8)
        LocalMIDIReceiverList::ReceiverConnectEndpoint((LocalMIDIReceiverList *)(v9 + 21), (int)v5, v4, connRefCon, 1);
    }
  }
  gMIDIClientLog();
  v12 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v14, v8);
    *(_DWORD *)buf = 136315906;
    v16 = "MIDIClientLib.cpp";
    v17 = 1024;
    v18 = 829;
    v19 = 2080;
    v20 = "MIDIPortConnectSource";
    v21 = 2080;
    *(_QWORD *)v22 = v14;
    _os_log_impl(&dword_1D4E88000, v12, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s%s", buf, 0x26u);
  }
  return v8;
}

OSStatus MIDIPortDisconnectSource(MIDIPortRef port, MIDIEndpointRef source)
{
  uint64_t v2;
  MIDIServer *v3;
  NSObject *v4;
  _BOOL8 v5;
  unsigned int v6;
  uint64_t *v7;
  unsigned int v8;
  ClientInterface *v9;
  _UNKNOWN **v10;
  NSObject *v11;
  _BYTE v13[32];
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  _WORD v21[9];

  v2 = *(_QWORD *)&source;
  v3 = *(MIDIServer **)&port;
  *(_QWORD *)&v21[5] = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v4 = gMIDIClientLog(void)::clilib;
  v5 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v5)
  {
    *(_DWORD *)buf = 136316162;
    v15 = "MIDIClientLib.cpp";
    v16 = 1024;
    v17 = 836;
    v18 = 2080;
    v19 = "MIDIPortDisconnectSource";
    v20 = 1024;
    *(_DWORD *)v21 = (_DWORD)v3;
    v21[2] = 1024;
    *(_DWORD *)&v21[3] = v2;
    _os_log_impl(&dword_1D4E88000, v4, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s 0x%x 0x%x", buf, 0x28u);
  }
  if ((gInMIDIServer & 1) != 0)
  {
    v6 = _MIDIPortDisconnectSource(v3, v2);
  }
  else
  {
    v7 = MIDIProcess::defaultInstance((MIDIProcess *)v5);
    v8 = (*(uint64_t (**)(uint64_t *))(*v7 + 56))(v7);
    if (v8)
      goto LABEL_8;
    LocalMIDIReceiverList::ReceiverConnectEndpoint((LocalMIDIReceiverList *)(v7 + 21), (int)v3, v2, 0, 0);
    v10 = ClientInterface::global(v9);
    v6 = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *, uint64_t))*v10 + 7))(v10, v3, v2);
  }
  v8 = v6;
LABEL_8:
  gMIDIClientLog();
  v11 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v13, v8);
    *(_DWORD *)buf = 136315906;
    v15 = "MIDIClientLib.cpp";
    v16 = 1024;
    v17 = 844;
    v18 = 2080;
    v19 = "MIDIPortDisconnectSource";
    v20 = 2080;
    *(_QWORD *)v21 = v13;
    _os_log_impl(&dword_1D4E88000, v11, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s%s", buf, 0x26u);
  }
  return v8;
}

OSStatus MIDIDestinationCreate(MIDIClientRef client, CFStringRef name, MIDIReadProc readProc, void *refCon, MIDIEndpointRef *outDest)
{
  _QWORD v6[6];

  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __MIDIDestinationCreate_block_invoke;
  v6[3] = &__block_descriptor_tmp_6;
  v6[4] = readProc;
  v6[5] = refCon;
  return MIDIDestinationCreateInternal(*(MIDIServer **)&client, name, 1, (int *)outDest, v6, 0);
}

uint64_t MIDIDestinationCreateInternal(MIDIServer *a1, const __CFString *a2, uint64_t a3, int *a4, const void *a5, const void *a6)
{
  NSObject *v12;
  CFTypeID MainBundle;
  uint64_t v14;
  const __CFArray *v15;
  uint64_t v16;
  const char *v17;
  NSObject *v18;
  uint32_t v19;
  uint64_t *v20;
  ClientInterface *v21;
  _UNKNOWN **v22;
  uint64_t v23;
  int v24;
  CFTypeID v26;
  uint8_t v27[32];
  uint8_t buf[4];
  const char *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  const char *v33;
  __int16 v34;
  _BYTE v35[14];
  __int16 v36;
  int v37;
  __int16 v38;
  const void *v39;
  __int16 v40;
  const void *v41;
  uint64_t v42;
  CFRange v43;

  v42 = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v12 = gMIDIClientLog(void)::clilib;
  MainBundle = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if ((_DWORD)MainBundle)
  {
    *(_DWORD *)buf = 136316930;
    v29 = "MIDIClientLib.cpp";
    v30 = 1024;
    v31 = 853;
    v32 = 2080;
    v33 = "MIDIDestinationCreateInternal";
    v34 = 1024;
    *(_DWORD *)v35 = (_DWORD)a1;
    *(_WORD *)&v35[4] = 2112;
    *(_QWORD *)&v35[6] = a2;
    v36 = 1024;
    v37 = a3;
    v38 = 2048;
    v39 = a5;
    v40 = 2048;
    v41 = a6;
    _os_log_impl(&dword_1D4E88000, v12, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s 0x%x \"%@\", protocol %d, block %p %p", buf, 0x46u);
  }
  if ((gInMIDIServer & 1) == 0)
  {
    if (CheckVirtualEndpointCreation(void)::virtualEndpointsAllowed < 0)
    {
      CheckVirtualEndpointCreation(void)::virtualEndpointsAllowed = 0;
      MainBundle = (CFTypeID)CFBundleGetMainBundle();
      if (MainBundle)
      {
        MainBundle = (CFTypeID)CFBundleGetValueForInfoDictionaryKey((CFBundleRef)MainBundle, CFSTR("UIBackgroundModes"));
        if (MainBundle)
        {
          v15 = (const __CFArray *)MainBundle;
          v26 = CFGetTypeID((CFTypeRef)MainBundle);
          MainBundle = CFArrayGetTypeID();
          if (v26 == MainBundle)
          {
            v43.length = CFArrayGetCount(v15);
            v43.location = 0;
            MainBundle = CFArrayContainsValue(v15, v43, CFSTR("audio"));
            if ((_DWORD)MainBundle)
            {
              CheckVirtualEndpointCreation(void)::virtualEndpointsAllowed = 1;
              if (a4)
              {
LABEL_9:
                if ((gInMIDIServer & 1) != 0)
                {
                  v14 = 0xFFFFFFFFLL;
                }
                else
                {
                  v20 = MIDIProcess::defaultInstance((MIDIProcess *)MainBundle);
                  v21 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v20 + 56))(v20);
                  v14 = (uint64_t)v21;
                  if (!(_DWORD)v21)
                  {
                    v22 = ClientInterface::global(v21);
                    v14 = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *, const __CFString *, uint64_t, int *))*v22
                           + 43))(v22, a1, a2, a3, a4);
                    ObjectTreeCache::Invalidate((ObjectTreeCache *)(v20 + 36));
                    if (!(_DWORD)v14)
                    {
                      LocalMIDIReceiverList::Add((uint64_t)(v20 + 21), (int)a1, *a4, a3, a5, a6);
                      LocalMIDIReceiverList::ReceiverConnectEndpoint((LocalMIDIReceiverList *)(v20 + 21), *a4, *a4, 0, 1);
                    }
                  }
                }
                goto LABEL_24;
              }
LABEL_16:
              v14 = 4294967246;
              goto LABEL_17;
            }
          }
        }
      }
      if (CheckVirtualEndpointCreation(void)::virtualEndpointsAllowed)
      {
LABEL_8:
        if (a4)
          goto LABEL_9;
        goto LABEL_16;
      }
    }
    else if (CheckVirtualEndpointCreation(void)::virtualEndpointsAllowed)
    {
      goto LABEL_8;
    }
    return 4294956452;
  }
  v14 = _MIDIDestinationCreate(a1, a2, (MIDIProtocolID)a3, a4, a5, a6);
  if (!a4)
  {
LABEL_17:
    gMIDIClientLog();
    v16 = gMIDIClientLog(void)::clilib;
    if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
    {
      ErrorFormatter::ErrorFormatter((ErrorFormatter *)v27, v14);
      *(_DWORD *)buf = 136315906;
      v29 = "MIDIClientLib.cpp";
      v30 = 1024;
      v31 = 870;
      v32 = 2080;
      v33 = "MIDIDestinationCreateInternal";
      v34 = 2080;
      *(_QWORD *)v35 = v27;
      v17 = "%25s:%-5d <-%s: (null ptr)%s";
      v18 = v16;
      v19 = 38;
LABEL_26:
      _os_log_impl(&dword_1D4E88000, v18, OS_LOG_TYPE_DEBUG, v17, buf, v19);
      return v14;
    }
    return v14;
  }
LABEL_24:
  gMIDIClientLog();
  v23 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    v24 = *a4;
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v27, v14);
    *(_DWORD *)buf = 136316162;
    v29 = "MIDIClientLib.cpp";
    v30 = 1024;
    v31 = 870;
    v32 = 2080;
    v33 = "MIDIDestinationCreateInternal";
    v34 = 1024;
    *(_DWORD *)v35 = v24;
    *(_WORD *)&v35[4] = 2080;
    *(_QWORD *)&v35[6] = v27;
    v17 = "%25s:%-5d <-%s: 0x%x%s";
    v18 = v23;
    v19 = 44;
    goto LABEL_26;
  }
  return v14;
}

OSStatus MIDIDestinationCreateWithBlock(MIDIClientRef client, CFStringRef name, MIDIEndpointRef *outDest, MIDIReadBlock readBlock)
{
  return MIDIDestinationCreateInternal(*(MIDIServer **)&client, name, 1, (int *)outDest, readBlock, 0);
}

OSStatus MIDIDestinationCreateWithProtocol(MIDIClientRef client, CFStringRef name, MIDIProtocolID protocol, MIDIEndpointRef *outDest, MIDIReceiveBlock readBlock)
{
  return MIDIDestinationCreateInternal(*(MIDIServer **)&client, name, *(uint64_t *)&protocol, (int *)outDest, 0, readBlock);
}

OSStatus MIDISourceCreate(MIDIClientRef client, CFStringRef name, MIDIEndpointRef *outSrc)
{
  return MIDISourceCreateWithProtocol(client, name, kMIDIProtocol_1_0, outSrc);
}

OSStatus MIDISourceCreateWithProtocol(MIDIClientRef client, CFStringRef name, MIDIProtocolID protocol, MIDIEndpointRef *outSrc)
{
  uint64_t v5;
  MIDIServer *v7;
  NSObject *v8;
  CFTypeID MainBundle;
  int v10;
  const __CFArray *v11;
  CFTypeID v12;
  uint64_t v13;
  const char *v14;
  NSObject *v15;
  uint32_t v16;
  uint64_t *v17;
  ClientInterface *v18;
  _UNKNOWN **v19;
  uint64_t v20;
  MIDIEndpointRef v21;
  _BYTE v23[32];
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  int v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  _WORD v31[17];
  CFRange v32;

  v5 = *(_QWORD *)&protocol;
  v7 = *(MIDIServer **)&client;
  *(_QWORD *)&v31[13] = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v8 = gMIDIClientLog(void)::clilib;
  MainBundle = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if ((_DWORD)MainBundle)
  {
    *(_DWORD *)buf = 136316162;
    v25 = "MIDIClientLib.cpp";
    v26 = 1024;
    v27 = 904;
    v28 = 2080;
    v29 = "MIDISourceCreateWithProtocol";
    v30 = 1024;
    *(_DWORD *)v31 = (_DWORD)v7;
    v31[2] = 2112;
    *(_QWORD *)&v31[3] = name;
    _os_log_impl(&dword_1D4E88000, v8, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s 0x%x \"%@\"", buf, 0x2Cu);
  }
  if ((gInMIDIServer & 1) == 0)
  {
    if (CheckVirtualEndpointCreation(void)::virtualEndpointsAllowed < 0)
    {
      CheckVirtualEndpointCreation(void)::virtualEndpointsAllowed = 0;
      MainBundle = (CFTypeID)CFBundleGetMainBundle();
      if (MainBundle)
      {
        MainBundle = (CFTypeID)CFBundleGetValueForInfoDictionaryKey((CFBundleRef)MainBundle, CFSTR("UIBackgroundModes"));
        if (MainBundle)
        {
          v11 = (const __CFArray *)MainBundle;
          v12 = CFGetTypeID((CFTypeRef)MainBundle);
          MainBundle = CFArrayGetTypeID();
          if (v12 == MainBundle)
          {
            v32.length = CFArrayGetCount(v11);
            v32.location = 0;
            MainBundle = CFArrayContainsValue(v11, v32, CFSTR("audio"));
            if ((_DWORD)MainBundle)
            {
              CheckVirtualEndpointCreation(void)::virtualEndpointsAllowed = 1;
              if (outSrc)
              {
LABEL_9:
                if ((gInMIDIServer & 1) != 0)
                {
                  v10 = -1;
                }
                else
                {
                  v17 = MIDIProcess::defaultInstance((MIDIProcess *)MainBundle);
                  v18 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v17 + 56))(v17);
                  v10 = (int)v18;
                  if (!(_DWORD)v18)
                  {
                    v19 = ClientInterface::global(v18);
                    v10 = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *, CFStringRef, uint64_t, MIDIEndpointRef *))*v19
                           + 8))(v19, v7, name, v5, outSrc);
                    ObjectTreeCache::Invalidate((ObjectTreeCache *)(v17 + 36));
                  }
                }
                goto LABEL_23;
              }
LABEL_16:
              v10 = -50;
              goto LABEL_17;
            }
          }
        }
      }
      if (CheckVirtualEndpointCreation(void)::virtualEndpointsAllowed)
      {
LABEL_8:
        if (outSrc)
          goto LABEL_9;
        goto LABEL_16;
      }
    }
    else if (CheckVirtualEndpointCreation(void)::virtualEndpointsAllowed)
    {
      goto LABEL_8;
    }
    return -10844;
  }
  v10 = _MIDISourceCreate(v7, name, (MIDIProtocolID)v5, outSrc);
  if (!outSrc)
  {
LABEL_17:
    gMIDIClientLog();
    v13 = gMIDIClientLog(void)::clilib;
    if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
    {
      ErrorFormatter::ErrorFormatter((ErrorFormatter *)v23, v10);
      *(_DWORD *)buf = 136315906;
      v25 = "MIDIClientLib.cpp";
      v26 = 1024;
      v27 = 916;
      v28 = 2080;
      v29 = "MIDISourceCreateWithProtocol";
      v30 = 2080;
      *(_QWORD *)v31 = v23;
      v14 = "%25s:%-5d <-%s: (null ptr)%s";
      v15 = v13;
      v16 = 38;
LABEL_25:
      _os_log_impl(&dword_1D4E88000, v15, OS_LOG_TYPE_DEBUG, v14, buf, v16);
      return v10;
    }
    return v10;
  }
LABEL_23:
  gMIDIClientLog();
  v20 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    v21 = *outSrc;
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v23, v10);
    *(_DWORD *)buf = 136316162;
    v25 = "MIDIClientLib.cpp";
    v26 = 1024;
    v27 = 916;
    v28 = 2080;
    v29 = "MIDISourceCreateWithProtocol";
    v30 = 1024;
    *(_DWORD *)v31 = v21;
    v31[2] = 2080;
    *(_QWORD *)&v31[3] = v23;
    v14 = "%25s:%-5d <-%s: 0x%x%s";
    v15 = v20;
    v16 = 44;
    goto LABEL_25;
  }
  return v10;
}

OSStatus MIDIEndpointDispose(MIDIEndpointRef endpt)
{
  MIDIServer *v1;
  NSObject *v2;
  _BOOL8 v3;
  unsigned int v4;
  uint64_t *v5;
  ClientInterface *v6;
  _UNKNOWN **v7;
  NSObject *v8;
  _BYTE v10[32];
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  _BYTE *v18;
  uint64_t v19;

  v1 = *(MIDIServer **)&endpt;
  v19 = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v2 = gMIDIClientLog(void)::clilib;
  v3 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v3)
  {
    *(_DWORD *)buf = 136315906;
    v12 = "MIDIClientLib.cpp";
    v13 = 1024;
    v14 = 923;
    v15 = 2080;
    v16 = "MIDIEndpointDispose";
    v17 = 1024;
    LODWORD(v18) = (_DWORD)v1;
    _os_log_impl(&dword_1D4E88000, v2, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s 0x%x", buf, 0x22u);
  }
  if ((gInMIDIServer & 1) != 0)
  {
    v4 = _MIDIEndpointDispose(v1);
  }
  else
  {
    v5 = MIDIProcess::defaultInstance((MIDIProcess *)v3);
    v4 = (*(uint64_t (**)(uint64_t *))(*v5 + 56))(v5);
    if (!v4)
    {
      v6 = (ClientInterface *)LocalMIDIReceiverList::Remove((LocalMIDIReceiverList *)(v5 + 21), (int)v1);
      v7 = ClientInterface::global(v6);
      v4 = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *))*v7 + 9))(v7, v1);
      ObjectTreeCache::Invalidate((ObjectTreeCache *)(v5 + 36));
    }
  }
  gMIDIClientLog();
  v8 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v10, v4);
    *(_DWORD *)buf = 136315906;
    v12 = "MIDIClientLib.cpp";
    v13 = 1024;
    v14 = 932;
    v15 = 2080;
    v16 = "MIDIEndpointDispose";
    v17 = 2080;
    v18 = v10;
    _os_log_impl(&dword_1D4E88000, v8, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s%s", buf, 0x26u);
  }
  return v4;
}

OSStatus MIDISend(MIDIPortRef port, MIDIEndpointRef dest, const MIDIPacketList *pktlist)
{
  OSStatus result;
  uint64_t *v7;
  _QWORD v8[3];
  OSStatus v9;
  MIDIEndpointRef v10;
  MIDIPortRef v11;
  unsigned int *v12;
  uint64_t (**v13)();
  _QWORD *v14;
  uint64_t v15[9];
  _QWORD v16[128];

  v16[127] = *MEMORY[0x1E0C80C00];
  v10 = dest;
  v11 = port;
  v9 = 0;
  if (!pktlist)
    return -50;
  if ((gInMIDIServer & 1) != 0)
  {
    v8[0] = &v9;
    v8[1] = &v11;
    v8[2] = &v10;
    v13 = caulk::inplace_function<void ()(MIDI::EventList const*),48ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<std::reference_wrapper<MIDISend::$_0>>;
    v14 = v8;
    v15[0] = (uint64_t)caulk::inplace_function<void ()(MIDI::EventList const*),48ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<std::reference_wrapper<MIDISend::$_0>>;
    v15[1] = (uint64_t)v8;
    v15[8] = 1;
    v15[7] = (uint64_t)v16;
    v12 = (unsigned int *)v15;
    MIDI::LegacyPacketList::traverse<MIDI::MIDIPacketList_to_MIDIEventList(MIDIPacketList const*,caulk::inplace_function<void ()(MIDI::EventList const*),48ul,8ul,caulk::inplace_function_detail::vtable>)::{lambda(MIDIPacket const*)#1}>(&pktlist->numPackets, &v12);
    MIDI::PacketizerBase<MIDI::EventList>::~PacketizerBase((uint64_t)v15);
    ((void (*)(_QWORD **))v13[3])(&v14);
    return v9;
  }
  else
  {
    v7 = MIDIProcess::defaultInstance(*(MIDIProcess **)&port);
    result = (*(uint64_t (**)(uint64_t *))(*v7 + 56))(v7);
    if (!result)
    {
      v15[0] = __PAIR64__(dest, port);
      MIDIProcess::WriteOutput<MIDI::LegacyPacketList>((uint64_t)v7, v15, &pktlist->numPackets);
      return 0;
    }
  }
  return result;
}

void sub_1D4EF7B50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  _Unwind_Resume(exception_object);
}

_DWORD ***caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<std::reference_wrapper<MIDISend::$_0>>(caulk::inplace_function_detail::wrapper<std::reference_wrapper<MIDISend::$_0>>)::{lambda(void *,MIDI::EventList const*&&)#1}::__invoke(_DWORD ***result, const MIDI::EventList **a2)
{
  _DWORD **v2;

  v2 = *result;
  if (!***result)
  {
    result = (_DWORD ***)_MIDISend((MIDIServer *)*v2[1], *v2[2], *a2);
    **v2 = (_DWORD)result;
  }
  return result;
}

_QWORD *caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<std::reference_wrapper<MIDISend::$_0>>(caulk::inplace_function_detail::wrapper<std::reference_wrapper<MIDISend::$_0>>)::{lambda(void *,void *)#1}::__invoke(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

_QWORD *caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<std::reference_wrapper<MIDISend::$_0>>(caulk::inplace_function_detail::wrapper<std::reference_wrapper<MIDISend::$_0>>)::{lambda(void *,void *)#2}::__invoke(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  return result;
}

OSStatus MIDISendEventList(MIDIPortRef port, MIDIEndpointRef dest, const MIDIEventList *evtlist)
{
  OSStatus result;
  uint64_t *v7;
  unint64_t v8;

  if (!evtlist)
    return -50;
  if ((gInMIDIServer & 1) != 0)
    return _MIDISend(*(MIDIServer **)&port, dest, (const MIDI::EventList *)evtlist);
  v7 = MIDIProcess::defaultInstance(*(MIDIProcess **)&port);
  result = (*(uint64_t (**)(uint64_t *))(*v7 + 56))(v7);
  if (!result)
  {
    v8 = __PAIR64__(dest, port);
    MIDIProcess::WriteOutput<MIDI::EventList>((uint64_t)v7, (uint64_t *)&v8, evtlist->protocol, (uint64_t)evtlist);
    return 0;
  }
  return result;
}

OSStatus MIDIReceived(MIDIEndpointRef src, const MIDIPacketList *pktlist)
{
  OSStatus result;
  uint64_t *v5;
  OSStatus v6;
  MIDIEndpointRef v7;
  uint64_t (***v8)();
  uint64_t (**v9)();
  __int128 v10;
  uint64_t (**v11)();
  __int128 v12;
  _QWORD *v13;
  uint64_t v14;
  _QWORD v15[128];

  v15[127] = *MEMORY[0x1E0C80C00];
  v6 = 0;
  v7 = src;
  if (!pktlist)
    return -50;
  if ((gInMIDIServer & 1) != 0)
  {
    v9 = caulk::inplace_function<void ()(MIDI::EventList const*),48ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<MIDIReceived::$_0>;
    *(_QWORD *)&v10 = &v6;
    *((_QWORD *)&v10 + 1) = &v7;
    v11 = caulk::inplace_function<void ()(MIDI::EventList const*),48ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<MIDIReceived::$_0>;
    v12 = v10;
    v14 = 1;
    v13 = v15;
    v8 = &v11;
    MIDI::LegacyPacketList::traverse<MIDI::MIDIPacketList_to_MIDIEventList(MIDIPacketList const*,caulk::inplace_function<void ()(MIDI::EventList const*),48ul,8ul,caulk::inplace_function_detail::vtable>)::{lambda(MIDIPacket const*)#1}>(&pktlist->numPackets, (unsigned int **)&v8);
    MIDI::PacketizerBase<MIDI::EventList>::~PacketizerBase((uint64_t)&v11);
    ((void (*)(__int128 *))v9[3])(&v10);
    return v6;
  }
  else
  {
    v5 = MIDIProcess::defaultInstance(*(MIDIProcess **)&src);
    result = (*(uint64_t (**)(uint64_t *))(*v5 + 56))(v5);
    if (!result)
    {
      LODWORD(v11) = 0;
      HIDWORD(v11) = src;
      MIDIProcess::WriteOutput<MIDI::LegacyPacketList>((uint64_t)v5, (uint64_t *)&v11, &pktlist->numPackets);
      return 0;
    }
  }
  return result;
}

void sub_1D4EF7DB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  _Unwind_Resume(exception_object);
}

_DWORD **caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<MIDIReceived::$_0>(caulk::inplace_function_detail::wrapper<MIDIReceived::$_0>)::{lambda(void *,MIDI::EventList const*&&)#1}::__invoke(_DWORD **result, MIDIEventPacket **a2)
{
  _DWORD **v2;

  if (!**result)
  {
    v2 = result;
    result = (_DWORD **)_MIDIReceived((MIDIServer *)*result[1], *a2);
    **v2 = (_DWORD)result;
  }
  return result;
}

__n128 caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<MIDIReceived::$_0>(caulk::inplace_function_detail::wrapper<MIDIReceived::$_0>)::{lambda(void *,void *)#1}::__invoke(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  *a1 = *a2;
  return result;
}

__n128 caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<MIDIReceived::$_0>(caulk::inplace_function_detail::wrapper<MIDIReceived::$_0>)::{lambda(void *,void *)#2}::__invoke(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  *a1 = *a2;
  return result;
}

OSStatus MIDIReceivedEventList(MIDIEndpointRef src, const MIDIEventList *evtlist)
{
  OSStatus result;
  uint64_t *v5;
  uint64_t v6;

  if (!evtlist)
    return -50;
  if ((gInMIDIServer & 1) != 0)
    return _MIDIReceived(*(MIDIServer **)&src, (MIDIEventPacket *)evtlist);
  v5 = MIDIProcess::defaultInstance(*(MIDIProcess **)&src);
  result = (*(uint64_t (**)(uint64_t *))(*v5 + 56))(v5);
  if (!result)
  {
    LODWORD(v6) = 0;
    HIDWORD(v6) = src;
    MIDIProcess::WriteOutput<MIDI::EventList>((uint64_t)v5, &v6, evtlist->protocol, (uint64_t)evtlist);
    return 0;
  }
  return result;
}

ClientInterface *MIDISetupInstall_Priv(MIDIProcess *this)
{
  ClientInterface *result;
  uint64_t *v3;
  _UNKNOWN **v4;
  uint64_t v5;

  if ((gInMIDIServer & 1) != 0)
    return (ClientInterface *)_MIDISetupInstall(this);
  v3 = MIDIProcess::defaultInstance(this);
  result = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v3 + 56))(v3);
  if (!(_DWORD)result)
  {
    v4 = ClientInterface::global(result);
    v5 = (*((uint64_t (**)(_UNKNOWN **, MIDIProcess *))*v4 + 40))(v4, this);
    ObjectTreeCache::Invalidate((ObjectTreeCache *)(v3 + 36));
    return (ClientInterface *)v5;
  }
  return result;
}

uint64_t MIDISetupGetCurrent_Priv(MIDIProcess *a1)
{
  uint64_t *v2;
  uint64_t result;
  _UNKNOWN **v4;

  if (!a1)
    return 4294967246;
  v2 = MIDIProcess::defaultInstance(a1);
  result = (*(uint64_t (**)(uint64_t *))(*v2 + 56))(v2);
  if (!(_DWORD)result)
  {
    v4 = ClientInterface::global((ClientInterface *)result);
    return (*((uint64_t (**)(_UNKNOWN **, MIDIProcess *))*v4 + 39))(v4, a1);
  }
  return result;
}

OSStatus MIDIExternalDeviceCreate(CFStringRef name, CFStringRef manufacturer, CFStringRef model, MIDIDeviceRef *outDevice)
{
  NSObject *v9;
  _BOOL8 v10;
  int v11;
  uint64_t v12;
  const char *v13;
  NSObject *v14;
  uint32_t v15;
  uint64_t *v16;
  ClientInterface *v17;
  _UNKNOWN **v18;
  uint64_t v19;
  MIDIDeviceRef v20;
  char __str[32];
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  _BYTE v29[18];
  __int16 v30;
  CFStringRef v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if ((gInMIDIServer & 1) != 0)
    return MIDIDeviceCreate(0, name, manufacturer, model, outDevice);
  gMIDIClientLog();
  v9 = gMIDIClientLog(void)::clilib;
  v10 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v10)
  {
    *(_DWORD *)buf = 136316418;
    v23 = "MIDIClientLib.cpp";
    v24 = 1024;
    v25 = 1129;
    v26 = 2080;
    v27 = "MIDIExternalDeviceCreate";
    v28 = 2112;
    *(_QWORD *)v29 = name;
    *(_WORD *)&v29[8] = 2112;
    *(_QWORD *)&v29[10] = manufacturer;
    v30 = 2112;
    v31 = model;
    _os_log_impl(&dword_1D4E88000, v9, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s \"%@\", manuf \"%@\", model \"%@\"", buf, 0x3Au);
  }
  if (outDevice)
  {
    if ((gInMIDIServer & 1) != 0)
    {
      v11 = -1;
    }
    else
    {
      v16 = MIDIProcess::defaultInstance((MIDIProcess *)v10);
      v17 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v16 + 56))(v16);
      v11 = (int)v17;
      if (!(_DWORD)v17)
      {
        v18 = ClientInterface::global(v17);
        v11 = (*((uint64_t (**)(_UNKNOWN **, CFStringRef, CFStringRef, CFStringRef, MIDIDeviceRef *))*v18 + 25))(v18, name, manufacturer, model, outDevice);
        ObjectTreeCache::Invalidate((ObjectTreeCache *)(v16 + 36));
      }
    }
    gMIDIClientLog();
    v19 = gMIDIClientLog(void)::clilib;
    if (!os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
      return v11;
    v20 = *outDevice;
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)__str, v11);
    *(_DWORD *)buf = 136316162;
    v23 = "MIDIClientLib.cpp";
    v24 = 1024;
    v25 = 1139;
    v26 = 2080;
    v27 = "MIDIExternalDeviceCreate";
    v28 = 1024;
    *(_DWORD *)v29 = v20;
    *(_WORD *)&v29[4] = 2080;
    *(_QWORD *)&v29[6] = __str;
    v13 = "%25s:%-5d <-%s: 0x%x%s";
    v14 = v19;
    v15 = 44;
  }
  else
  {
    gMIDIClientLog();
    v12 = gMIDIClientLog(void)::clilib;
    if (!os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
      return -50;
    v11 = -50;
    CAX4CCString::CAX4CCString((CAX4CCString *)buf, 0xFFFFFFCE);
    snprintf(__str, 0x20uLL, " *** error %s", (const char *)buf);
    *(_DWORD *)buf = 136315906;
    v23 = "MIDIClientLib.cpp";
    v24 = 1024;
    v25 = 1139;
    v26 = 2080;
    v27 = "MIDIExternalDeviceCreate";
    v28 = 2080;
    *(_QWORD *)v29 = __str;
    v13 = "%25s:%-5d <-%s: (null ptr)%s";
    v14 = v12;
    v15 = 38;
  }
  _os_log_impl(&dword_1D4E88000, v14, OS_LOG_TYPE_DEBUG, v13, buf, v15);
  return v11;
}

OSStatus MIDIDeviceNewEntity(MIDIDeviceRef device, CFStringRef name, MIDIProtocolID protocol, Boolean embedded, ItemCount numSourceEndpoints, ItemCount numDestinationEndpoints, MIDIEntityRef *newEntity)
{
  uint64_t v10;
  uint64_t v11;
  MIDIServer *v13;
  NSObject *v14;
  _BOOL8 v15;
  int v16;
  uint64_t *v17;
  ClientInterface *v18;
  _UNKNOWN **v19;
  uint64_t v20;
  MIDIEntityRef v21;
  const char *v22;
  NSObject *v23;
  uint32_t v24;
  uint64_t v25;
  _BYTE v27[32];
  uint8_t buf[4];
  const char *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  const char *v33;
  __int16 v34;
  _BYTE v35[14];
  __int16 v36;
  int v37;
  __int16 v38;
  int v39;
  __int16 v40;
  int v41;
  uint64_t v42;

  v10 = embedded;
  v11 = *(_QWORD *)&protocol;
  v13 = *(MIDIServer **)&device;
  v42 = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v14 = gMIDIClientLog(void)::clilib;
  v15 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v15)
  {
    *(_DWORD *)buf = 136316930;
    v29 = "MIDIClientLib.cpp";
    v30 = 1024;
    v31 = 1148;
    v32 = 2080;
    v33 = "MIDIDeviceNewEntity";
    v34 = 1024;
    *(_DWORD *)v35 = (_DWORD)v13;
    *(_WORD *)&v35[4] = 2112;
    *(_QWORD *)&v35[6] = name;
    v36 = 1024;
    v37 = v10;
    v38 = 1024;
    v39 = numSourceEndpoints;
    v40 = 1024;
    v41 = numDestinationEndpoints;
    _os_log_impl(&dword_1D4E88000, v14, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s 0x%x \"%@\" embedded %d, %d sources, %d dests", buf, 0x3Eu);
  }
  if ((gInMIDIServer & 1) != 0)
  {
    v16 = _MIDIDeviceAddEntity(v13, name, (MIDIProtocolID)v11, v10, numSourceEndpoints, numDestinationEndpoints, newEntity);
    if (!newEntity)
    {
LABEL_12:
      gMIDIClientLog();
      v25 = gMIDIClientLog(void)::clilib;
      if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
      {
        ErrorFormatter::ErrorFormatter((ErrorFormatter *)v27, v16);
        *(_DWORD *)buf = 136315906;
        v29 = "MIDIClientLib.cpp";
        v30 = 1024;
        v31 = 1157;
        v32 = 2080;
        v33 = "MIDIDeviceNewEntity";
        v34 = 2080;
        *(_QWORD *)v35 = v27;
        v22 = "%25s:%-5d <-%s: (null ptr)%s";
        v23 = v25;
        v24 = 38;
        goto LABEL_14;
      }
      return v16;
    }
  }
  else
  {
    if (!newEntity)
    {
      v16 = -50;
      goto LABEL_12;
    }
    v17 = MIDIProcess::defaultInstance((MIDIProcess *)v15);
    v18 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v17 + 56))(v17);
    v16 = (int)v18;
    if (!(_DWORD)v18)
    {
      v19 = ClientInterface::global(v18);
      v16 = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *, CFStringRef, uint64_t, uint64_t, ItemCount, ItemCount, MIDIEntityRef *))*v19
             + 26))(v19, v13, name, v11, v10, numSourceEndpoints, numDestinationEndpoints, newEntity);
      ObjectTreeCache::Invalidate((ObjectTreeCache *)(v17 + 36));
    }
  }
  gMIDIClientLog();
  v20 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    v21 = *newEntity;
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v27, v16);
    *(_DWORD *)buf = 136316162;
    v29 = "MIDIClientLib.cpp";
    v30 = 1024;
    v31 = 1157;
    v32 = 2080;
    v33 = "MIDIDeviceNewEntity";
    v34 = 1024;
    *(_DWORD *)v35 = v21;
    *(_WORD *)&v35[4] = 2080;
    *(_QWORD *)&v35[6] = v27;
    v22 = "%25s:%-5d <-%s: 0x%x%s";
    v23 = v20;
    v24 = 44;
LABEL_14:
    _os_log_impl(&dword_1D4E88000, v23, OS_LOG_TYPE_DEBUG, v22, buf, v24);
  }
  return v16;
}

OSStatus MIDIDeviceAddEntity(MIDIDeviceRef device, CFStringRef name, Boolean embedded, ItemCount numSourceEndpoints, ItemCount numDestinationEndpoints, MIDIEntityRef *newEntity)
{
  return MIDIDeviceNewEntity(device, name, kMIDIProtocol_1_0, embedded, numSourceEndpoints, numDestinationEndpoints, newEntity);
}

OSStatus MIDIDeviceRemoveEntity(MIDIDeviceRef device, MIDIEntityRef entity)
{
  uint64_t v2;
  MIDIServer *v3;
  NSObject *v4;
  _BOOL8 v5;
  unsigned int v6;
  uint64_t *v7;
  ClientInterface *v8;
  _UNKNOWN **v9;
  NSObject *v10;
  _BYTE v12[32];
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  _WORD v20[9];

  v2 = *(_QWORD *)&entity;
  v3 = *(MIDIServer **)&device;
  *(_QWORD *)&v20[5] = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v4 = gMIDIClientLog(void)::clilib;
  v5 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v5)
  {
    *(_DWORD *)buf = 136316162;
    v14 = "MIDIClientLib.cpp";
    v15 = 1024;
    v16 = 1169;
    v17 = 2080;
    v18 = "MIDIDeviceRemoveEntity";
    v19 = 1024;
    *(_DWORD *)v20 = (_DWORD)v3;
    v20[2] = 1024;
    *(_DWORD *)&v20[3] = v2;
    _os_log_impl(&dword_1D4E88000, v4, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s 0x%x 0x%x", buf, 0x28u);
  }
  if ((gInMIDIServer & 1) != 0)
  {
    v6 = _MIDIDeviceRemoveEntity(v3, v2);
  }
  else
  {
    v7 = MIDIProcess::defaultInstance((MIDIProcess *)v5);
    v8 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v7 + 56))(v7);
    v6 = v8;
    if (!(_DWORD)v8)
    {
      v9 = ClientInterface::global(v8);
      v6 = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *, uint64_t))*v9 + 27))(v9, v3, v2);
      ObjectTreeCache::Invalidate((ObjectTreeCache *)(v7 + 36));
    }
  }
  gMIDIClientLog();
  v10 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v12, v6);
    *(_DWORD *)buf = 136315906;
    v14 = "MIDIClientLib.cpp";
    v15 = 1024;
    v16 = 1177;
    v17 = 2080;
    v18 = "MIDIDeviceRemoveEntity";
    v19 = 2080;
    *(_QWORD *)v20 = v12;
    _os_log_impl(&dword_1D4E88000, v10, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s%s", buf, 0x26u);
  }
  return v6;
}

OSStatus MIDIEntityAddOrRemoveEndpoints(MIDIEntityRef entity, ItemCount numSourceEndpoints, ItemCount numDestinationEndpoints)
{
  MIDIServer *v5;
  NSObject *v6;
  _BOOL8 v7;
  unsigned int v8;
  uint64_t *v9;
  ClientInterface *v10;
  _UNKNOWN **v11;
  NSObject *v12;
  _BYTE v14[32];
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  _BYTE v22[10];
  __int16 v23;
  int v24;
  uint64_t v25;

  v5 = *(MIDIServer **)&entity;
  v25 = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v6 = gMIDIClientLog(void)::clilib;
  v7 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v7)
  {
    *(_DWORD *)buf = 136316418;
    v16 = "MIDIClientLib.cpp";
    v17 = 1024;
    v18 = 1184;
    v19 = 2080;
    v20 = "MIDIEntityAddOrRemoveEndpoints";
    v21 = 1024;
    *(_DWORD *)v22 = (_DWORD)v5;
    *(_WORD *)&v22[4] = 1024;
    *(_DWORD *)&v22[6] = numSourceEndpoints;
    v23 = 1024;
    v24 = numDestinationEndpoints;
    _os_log_impl(&dword_1D4E88000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s 0x%x %d sources, %d dests", buf, 0x2Eu);
  }
  if ((gInMIDIServer & 1) != 0)
  {
    v8 = _MIDIEntityAddOrRemoveEndpoints(v5, numSourceEndpoints, numDestinationEndpoints);
  }
  else
  {
    v9 = MIDIProcess::defaultInstance((MIDIProcess *)v7);
    v10 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v9 + 56))(v9);
    v8 = v10;
    if (!(_DWORD)v10)
    {
      v11 = ClientInterface::global(v10);
      v8 = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *, ItemCount, ItemCount))*v11 + 28))(v11, v5, numSourceEndpoints, numDestinationEndpoints);
      ObjectTreeCache::Invalidate((ObjectTreeCache *)(v9 + 36));
    }
  }
  gMIDIClientLog();
  v12 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v14, v8);
    *(_DWORD *)buf = 136315906;
    v16 = "MIDIClientLib.cpp";
    v17 = 1024;
    v18 = 1192;
    v19 = 2080;
    v20 = "MIDIEntityAddOrRemoveEndpoints";
    v21 = 2080;
    *(_QWORD *)v22 = v14;
    _os_log_impl(&dword_1D4E88000, v12, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s%s", buf, 0x26u);
  }
  return v8;
}

OSStatus MIDISetupAddExternalDevice(MIDIDeviceRef device)
{
  MIDIServer *v1;
  NSObject *v2;
  _BOOL8 v3;
  unsigned int v4;
  uint64_t *v5;
  ClientInterface *v6;
  _UNKNOWN **v7;
  NSObject *v8;
  _BYTE v10[32];
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  _BYTE *v18;
  uint64_t v19;

  v1 = *(MIDIServer **)&device;
  v19 = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v2 = gMIDIClientLog(void)::clilib;
  v3 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v3)
  {
    *(_DWORD *)buf = 136315906;
    v12 = "MIDIClientLib.cpp";
    v13 = 1024;
    v14 = 1199;
    v15 = 2080;
    v16 = "MIDISetupAddExternalDevice";
    v17 = 1024;
    LODWORD(v18) = (_DWORD)v1;
    _os_log_impl(&dword_1D4E88000, v2, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s 0x%x", buf, 0x22u);
  }
  if ((gInMIDIServer & 1) != 0)
  {
    v4 = _MIDISetupAddExternalDevice(v1);
  }
  else
  {
    v5 = MIDIProcess::defaultInstance((MIDIProcess *)v3);
    v6 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v5 + 56))(v5);
    v4 = v6;
    if (!(_DWORD)v6)
    {
      v7 = ClientInterface::global(v6);
      v4 = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *))*v7 + 29))(v7, v1);
      ObjectTreeCache::Invalidate((ObjectTreeCache *)(v5 + 36));
    }
  }
  gMIDIClientLog();
  v8 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v10, v4);
    *(_DWORD *)buf = 136315906;
    v12 = "MIDIClientLib.cpp";
    v13 = 1024;
    v14 = 1207;
    v15 = 2080;
    v16 = "MIDISetupAddExternalDevice";
    v17 = 2080;
    v18 = v10;
    _os_log_impl(&dword_1D4E88000, v8, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s%s", buf, 0x26u);
  }
  return v4;
}

OSStatus MIDISetupRemoveExternalDevice(MIDIDeviceRef device)
{
  MIDIServer *v1;
  NSObject *v2;
  _BOOL8 v3;
  unsigned int v4;
  uint64_t *v5;
  ClientInterface *v6;
  _UNKNOWN **v7;
  NSObject *v8;
  _BYTE v10[32];
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  _BYTE *v18;
  uint64_t v19;

  v1 = *(MIDIServer **)&device;
  v19 = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v2 = gMIDIClientLog(void)::clilib;
  v3 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v3)
  {
    *(_DWORD *)buf = 136315906;
    v12 = "MIDIClientLib.cpp";
    v13 = 1024;
    v14 = 1214;
    v15 = 2080;
    v16 = "MIDISetupRemoveExternalDevice";
    v17 = 1024;
    LODWORD(v18) = (_DWORD)v1;
    _os_log_impl(&dword_1D4E88000, v2, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s 0x%x", buf, 0x22u);
  }
  if ((gInMIDIServer & 1) != 0)
  {
    v4 = _MIDISetupRemoveExternalDevice(v1);
  }
  else
  {
    v5 = MIDIProcess::defaultInstance((MIDIProcess *)v3);
    v6 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v5 + 56))(v5);
    v4 = v6;
    if (!(_DWORD)v6)
    {
      v7 = ClientInterface::global(v6);
      v4 = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *))*v7 + 30))(v7, v1);
      ObjectTreeCache::Invalidate((ObjectTreeCache *)(v5 + 36));
    }
  }
  gMIDIClientLog();
  v8 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v10, v4);
    *(_DWORD *)buf = 136315906;
    v12 = "MIDIClientLib.cpp";
    v13 = 1024;
    v14 = 1222;
    v15 = 2080;
    v16 = "MIDISetupRemoveExternalDevice";
    v17 = 2080;
    v18 = v10;
    _os_log_impl(&dword_1D4E88000, v8, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s%s", buf, 0x26u);
  }
  return v4;
}

OSStatus MIDIRestart(void)
{
  NSObject *v0;
  _BOOL8 v1;
  unsigned int v2;
  uint64_t *v3;
  ClientInterface *v4;
  unsigned int v5;
  _UNKNOWN **v6;
  NSObject *v7;
  _BYTE v9[32];
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  const char *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v0 = gMIDIClientLog(void)::clilib;
  v1 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v1)
  {
    *(_DWORD *)buf = 136315906;
    v11 = "MIDIClientLib.cpp";
    v12 = 1024;
    v13 = 1229;
    v14 = 2080;
    v15 = "MIDIRestart";
    v16 = 2080;
    v17 = "";
    _os_log_impl(&dword_1D4E88000, v0, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s %s", buf, 0x26u);
  }
  if ((gInMIDIServer & 1) != 0)
  {
    v2 = _MIDIRestart((MIDIServer *)v1);
  }
  else
  {
    v3 = MIDIProcess::defaultInstance((MIDIProcess *)v1);
    v4 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v3 + 56))(v3);
    v5 = v4;
    if ((_DWORD)v4)
      goto LABEL_8;
    v6 = ClientInterface::global(v4);
    v2 = (*((uint64_t (**)(_UNKNOWN **))*v6 + 22))(v6);
  }
  v5 = v2;
LABEL_8:
  gMIDIClientLog();
  v7 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v9, v5);
    *(_DWORD *)buf = 136315906;
    v11 = "MIDIClientLib.cpp";
    v12 = 1024;
    v13 = 1236;
    v14 = 2080;
    v15 = "MIDIRestart";
    v16 = 2080;
    v17 = v9;
    _os_log_impl(&dword_1D4E88000, v7, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s%s", buf, 0x26u);
  }
  return v5;
}

OSStatus MIDIObjectGetProperties(MIDIObjectRef obj, CFPropertyListRef *outProperties, Boolean deep)
{
  uint64_t v3;
  MIDIServer *v5;
  NSObject *v6;
  _BOOL8 v7;
  int Properties;
  int v9;
  uint64_t *v10;
  ClientInterface *v11;
  _UNKNOWN **v12;
  uint64_t v13;
  const __CFString *v14;
  const char *v15;
  NSObject *v16;
  uint32_t v17;
  uint64_t v18;
  _BYTE v20[32];
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  _BYTE v28[10];
  _BYTE *v29;
  uint64_t v30;

  v3 = deep;
  v5 = *(MIDIServer **)&obj;
  v30 = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v6 = gMIDIClientLog(void)::clilib;
  v7 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v7)
  {
    *(_DWORD *)buf = 136316162;
    v22 = "MIDIClientLib.cpp";
    v24 = 1243;
    v25 = 2080;
    v23 = 1024;
    v26 = "MIDIObjectGetProperties";
    v27 = 1024;
    *(_DWORD *)v28 = (_DWORD)v5;
    *(_WORD *)&v28[4] = 1024;
    *(_DWORD *)&v28[6] = v3;
    _os_log_impl(&dword_1D4E88000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s 0x%x deep %d", buf, 0x28u);
  }
  if (outProperties)
  {
    *outProperties = 0;
    if ((gInMIDIServer & 1) != 0)
    {
      Properties = _MIDIObjectGetProperties(v5, (CFMutableDictionaryRef *)outProperties, v3);
    }
    else
    {
      v10 = MIDIProcess::defaultInstance((MIDIProcess *)v7);
      v11 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v10 + 56))(v10);
      v9 = (int)v11;
      if ((_DWORD)v11)
        goto LABEL_11;
      v12 = ClientInterface::global(v11);
      Properties = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *, CFPropertyListRef *, uint64_t))*v12 + 18))(v12, v5, outProperties, v3);
    }
    v9 = Properties;
LABEL_11:
    gMIDIClientLog();
    v13 = gMIDIClientLog(void)::clilib;
    if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
    {
      if (*outProperties)
        v14 = (const __CFString *)*outProperties;
      else
        v14 = CFSTR("(null)");
      ErrorFormatter::ErrorFormatter((ErrorFormatter *)v20, v9);
      *(_DWORD *)buf = 136316162;
      v22 = "MIDIClientLib.cpp";
      v23 = 1024;
      v24 = 1252;
      v25 = 2080;
      v26 = "MIDIObjectGetProperties";
      v27 = 2112;
      *(_QWORD *)v28 = v14;
      *(_WORD *)&v28[8] = 2080;
      v29 = v20;
      v15 = "%25s:%-5d <-%s: %@%s";
      v16 = v13;
      v17 = 48;
      goto LABEL_19;
    }
    return v9;
  }
  if (gInMIDIServer == 1)
    v9 = _MIDIObjectGetProperties(v5, 0, v3);
  else
    v9 = -50;
  gMIDIClientLog();
  v18 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v20, v9);
    *(_DWORD *)buf = 136315906;
    v22 = "MIDIClientLib.cpp";
    v23 = 1024;
    v24 = 1252;
    v25 = 2080;
    v26 = "MIDIObjectGetProperties";
    v27 = 2080;
    *(_QWORD *)v28 = v20;
    v15 = "%25s:%-5d <-%s: (null ptr)%s";
    v16 = v18;
    v17 = 38;
LABEL_19:
    _os_log_impl(&dword_1D4E88000, v16, OS_LOG_TYPE_DEBUG, v15, buf, v17);
  }
  return v9;
}

OSStatus MIDISetupAddDevice(MIDIDeviceRef device)
{
  MIDIServer *v1;
  NSObject *v2;
  _BOOL8 v3;
  unsigned int v4;
  uint64_t *v5;
  ClientInterface *v6;
  _UNKNOWN **v7;
  NSObject *v8;
  _BYTE v10[32];
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  _BYTE *v18;
  uint64_t v19;

  v1 = *(MIDIServer **)&device;
  v19 = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v2 = gMIDIClientLog(void)::clilib;
  v3 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v3)
  {
    *(_DWORD *)buf = 136315906;
    v12 = "MIDIClientLib.cpp";
    v13 = 1024;
    v14 = 1259;
    v15 = 2080;
    v16 = "MIDISetupAddDevice";
    v17 = 1024;
    LODWORD(v18) = (_DWORD)v1;
    _os_log_impl(&dword_1D4E88000, v2, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s 0x%x", buf, 0x22u);
  }
  if ((gInMIDIServer & 1) != 0)
  {
    v4 = _MIDISetupAddDevice(v1);
  }
  else
  {
    v5 = MIDIProcess::defaultInstance((MIDIProcess *)v3);
    v6 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v5 + 56))(v5);
    v4 = v6;
    if (!(_DWORD)v6)
    {
      v7 = ClientInterface::global(v6);
      v4 = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *))*v7 + 31))(v7, v1);
      ObjectTreeCache::Invalidate((ObjectTreeCache *)(v5 + 36));
    }
  }
  gMIDIClientLog();
  v8 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v10, v4);
    *(_DWORD *)buf = 136315906;
    v12 = "MIDIClientLib.cpp";
    v13 = 1024;
    v14 = 1267;
    v15 = 2080;
    v16 = "MIDISetupAddDevice";
    v17 = 2080;
    v18 = v10;
    _os_log_impl(&dword_1D4E88000, v8, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s%s", buf, 0x26u);
  }
  return v4;
}

OSStatus MIDISetupRemoveDevice(MIDIDeviceRef device)
{
  MIDIServer *v1;
  NSObject *v2;
  _BOOL8 v3;
  unsigned int v4;
  uint64_t *v5;
  ClientInterface *v6;
  _UNKNOWN **v7;
  NSObject *v8;
  _BYTE v10[32];
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  _BYTE *v18;
  uint64_t v19;

  v1 = *(MIDIServer **)&device;
  v19 = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v2 = gMIDIClientLog(void)::clilib;
  v3 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v3)
  {
    *(_DWORD *)buf = 136315906;
    v12 = "MIDIClientLib.cpp";
    v13 = 1024;
    v14 = 1274;
    v15 = 2080;
    v16 = "MIDISetupRemoveDevice";
    v17 = 1024;
    LODWORD(v18) = (_DWORD)v1;
    _os_log_impl(&dword_1D4E88000, v2, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s 0x%x", buf, 0x22u);
  }
  if ((gInMIDIServer & 1) != 0)
  {
    v4 = _MIDISetupRemoveDevice(v1);
  }
  else
  {
    v5 = MIDIProcess::defaultInstance((MIDIProcess *)v3);
    v6 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v5 + 56))(v5);
    v4 = v6;
    if (!(_DWORD)v6)
    {
      v7 = ClientInterface::global(v6);
      v4 = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *))*v7 + 32))(v7, v1);
      ObjectTreeCache::Invalidate((ObjectTreeCache *)(v5 + 36));
    }
  }
  gMIDIClientLog();
  v8 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v10, v4);
    *(_DWORD *)buf = 136315906;
    v12 = "MIDIClientLib.cpp";
    v13 = 1024;
    v14 = 1282;
    v15 = 2080;
    v16 = "MIDISetupRemoveDevice";
    v17 = 2080;
    v18 = v10;
    _os_log_impl(&dword_1D4E88000, v8, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s%s", buf, 0x26u);
  }
  return v4;
}

OSStatus MIDIFlushOutput(MIDIEndpointRef dest)
{
  uint64_t v1;
  NSObject *v2;
  _BOOL8 v3;
  unsigned int v4;
  uint64_t *v5;
  ClientInterface *v6;
  unsigned int v7;
  _UNKNOWN **v8;
  NSObject *v9;
  _BYTE v11[32];
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  _BYTE *v19;
  uint64_t v20;

  v1 = *(_QWORD *)&dest;
  v20 = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v2 = gMIDIClientLog(void)::clilib;
  v3 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v3)
  {
    *(_DWORD *)buf = 136315906;
    v13 = "MIDIClientLib.cpp";
    v14 = 1024;
    v15 = 1306;
    v16 = 2080;
    v17 = "MIDIFlushOutput";
    v18 = 1024;
    LODWORD(v19) = v1;
    _os_log_impl(&dword_1D4E88000, v2, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s 0x%x", buf, 0x22u);
  }
  if ((gInMIDIServer & 1) != 0)
  {
    v4 = _MIDIFlushOutput(v1);
  }
  else
  {
    v5 = MIDIProcess::defaultInstance((MIDIProcess *)v3);
    v6 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v5 + 56))(v5);
    v7 = v6;
    if ((_DWORD)v6)
      goto LABEL_8;
    v8 = ClientInterface::global(v6);
    v4 = (*((uint64_t (**)(_UNKNOWN **, uint64_t))*v8 + 21))(v8, v1);
  }
  v7 = v4;
LABEL_8:
  gMIDIClientLog();
  v9 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v11, v7);
    *(_DWORD *)buf = 136315906;
    v13 = "MIDIClientLib.cpp";
    v14 = 1024;
    v15 = 1313;
    v16 = 2080;
    v17 = "MIDIFlushOutput";
    v18 = 2080;
    v19 = v11;
    _os_log_impl(&dword_1D4E88000, v9, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s%s", buf, 0x26u);
  }
  return v7;
}

OSStatus MIDIThruConnectionCreate(CFStringRef inPersistentOwnerID, CFDataRef inConnectionParams, MIDIThruConnectionRef *outConnection)
{
  NSObject *v6;
  _BOOL8 v7;
  CFDataRef v8;
  CFStringRef v9;
  int v10;
  uint64_t *v11;
  ClientInterface *v12;
  _UNKNOWN **v13;
  uint64_t v14;
  MIDIThruConnectionRef v15;
  const char *v16;
  NSObject *v17;
  uint32_t v18;
  uint64_t v19;
  _BYTE v21[32];
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  _BYTE v29[18];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v6 = gMIDIClientLog(void)::clilib;
  v7 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v7)
  {
    v8 = (CFDataRef)CFSTR("(null)");
    *(_DWORD *)buf = 136316162;
    v23 = "MIDIClientLib.cpp";
    v24 = 1024;
    if (inPersistentOwnerID)
      v9 = inPersistentOwnerID;
    else
      v9 = CFSTR("(null)");
    v25 = 1320;
    v26 = 2080;
    v27 = "MIDIThruConnectionCreate";
    if (inConnectionParams)
      v8 = inConnectionParams;
    v28 = 2112;
    *(_QWORD *)v29 = v9;
    *(_WORD *)&v29[8] = 2112;
    *(_QWORD *)&v29[10] = v8;
    _os_log_impl(&dword_1D4E88000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s owner \"%@\", %@", buf, 0x30u);
  }
  if ((gInMIDIServer & 1) != 0)
  {
    v10 = _MIDIThruConnectionCreate(0, inPersistentOwnerID, inConnectionParams, outConnection);
    if (!outConnection)
    {
LABEL_17:
      gMIDIClientLog();
      v19 = gMIDIClientLog(void)::clilib;
      if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
      {
        ErrorFormatter::ErrorFormatter((ErrorFormatter *)v21, v10);
        *(_DWORD *)buf = 136315906;
        v23 = "MIDIClientLib.cpp";
        v24 = 1024;
        v25 = 1330;
        v26 = 2080;
        v27 = "MIDIThruConnectionCreate";
        v28 = 2080;
        *(_QWORD *)v29 = v21;
        v16 = "%25s:%-5d <-%s: (null ptr)%s";
        v17 = v19;
        v18 = 38;
        goto LABEL_19;
      }
      return v10;
    }
  }
  else
  {
    if (!outConnection)
    {
      v10 = -50;
      goto LABEL_17;
    }
    v11 = MIDIProcess::defaultInstance((MIDIProcess *)v7);
    v12 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v11 + 56))(v11);
    v10 = (int)v12;
    if (!(_DWORD)v12)
    {
      v13 = ClientInterface::global(v12);
      v10 = (*((uint64_t (**)(_UNKNOWN **, CFStringRef, CFDataRef, MIDIThruConnectionRef *))*v13 + 33))(v13, inPersistentOwnerID, inConnectionParams, outConnection);
    }
  }
  gMIDIClientLog();
  v14 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    v15 = *outConnection;
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v21, v10);
    *(_DWORD *)buf = 136316162;
    v23 = "MIDIClientLib.cpp";
    v24 = 1024;
    v25 = 1330;
    v26 = 2080;
    v27 = "MIDIThruConnectionCreate";
    v28 = 1024;
    *(_DWORD *)v29 = v15;
    *(_WORD *)&v29[4] = 2080;
    *(_QWORD *)&v29[6] = v21;
    v16 = "%25s:%-5d <-%s: 0x%x%s";
    v17 = v14;
    v18 = 44;
LABEL_19:
    _os_log_impl(&dword_1D4E88000, v17, OS_LOG_TYPE_DEBUG, v16, buf, v18);
  }
  return v10;
}

OSStatus MIDIThruConnectionDispose(MIDIThruConnectionRef connection)
{
  MIDIServer *v1;
  NSObject *v2;
  _BOOL8 v3;
  unsigned int v4;
  uint64_t *v5;
  ClientInterface *v6;
  unsigned int v7;
  _UNKNOWN **v8;
  NSObject *v9;
  _BYTE v11[32];
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  _BYTE *v19;
  uint64_t v20;

  v1 = *(MIDIServer **)&connection;
  v20 = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v2 = gMIDIClientLog(void)::clilib;
  v3 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v3)
  {
    *(_DWORD *)buf = 136315906;
    v13 = "MIDIClientLib.cpp";
    v14 = 1024;
    v15 = 1337;
    v16 = 2080;
    v17 = "MIDIThruConnectionDispose";
    v18 = 1024;
    LODWORD(v19) = (_DWORD)v1;
    _os_log_impl(&dword_1D4E88000, v2, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s 0x%x", buf, 0x22u);
  }
  if ((gInMIDIServer & 1) != 0)
  {
    v4 = _MIDIThruConnectionDispose(v1);
  }
  else
  {
    v5 = MIDIProcess::defaultInstance((MIDIProcess *)v3);
    v6 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v5 + 56))(v5);
    v7 = v6;
    if ((_DWORD)v6)
      goto LABEL_8;
    v8 = ClientInterface::global(v6);
    v4 = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *))*v8 + 34))(v8, v1);
  }
  v7 = v4;
LABEL_8:
  gMIDIClientLog();
  v9 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v11, v7);
    *(_DWORD *)buf = 136315906;
    v13 = "MIDIClientLib.cpp";
    v14 = 1024;
    v15 = 1344;
    v16 = 2080;
    v17 = "MIDIThruConnectionDispose";
    v18 = 2080;
    v19 = v11;
    _os_log_impl(&dword_1D4E88000, v9, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s%s", buf, 0x26u);
  }
  return v7;
}

OSStatus MIDIThruConnectionGetParams(MIDIThruConnectionRef connection, CFDataRef *outConnectionParams)
{
  MIDIServer *v3;
  NSObject *v4;
  _BOOL8 v5;
  int Params;
  uint64_t *v7;
  ClientInterface *v8;
  _UNKNOWN **v9;
  uint64_t v10;
  CFDataRef v11;
  const char *v12;
  NSObject *v13;
  uint32_t v14;
  uint64_t v15;
  _BYTE v17[32];
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  _BYTE *v25;
  __int16 v26;
  _BYTE *v27;
  uint64_t v28;

  v3 = *(MIDIServer **)&connection;
  v28 = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v4 = gMIDIClientLog(void)::clilib;
  v5 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v5)
  {
    *(_DWORD *)buf = 136315906;
    v19 = "MIDIClientLib.cpp";
    v20 = 1024;
    v21 = 1351;
    v22 = 2080;
    v23 = "MIDIThruConnectionGetParams";
    v24 = 1024;
    LODWORD(v25) = (_DWORD)v3;
    _os_log_impl(&dword_1D4E88000, v4, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s 0x%x", buf, 0x22u);
  }
  if ((gInMIDIServer & 1) != 0)
  {
    Params = _MIDIThruConnectionGetParams(v3, outConnectionParams);
    if (!outConnectionParams)
    {
LABEL_15:
      gMIDIClientLog();
      v15 = gMIDIClientLog(void)::clilib;
      if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
      {
        ErrorFormatter::ErrorFormatter((ErrorFormatter *)v17, Params);
        *(_DWORD *)buf = 136315906;
        v19 = "MIDIClientLib.cpp";
        v20 = 1024;
        v21 = 1359;
        v22 = 2080;
        v23 = "MIDIThruConnectionGetParams";
        v24 = 2080;
        v25 = v17;
        v12 = "%25s:%-5d <-%s: (null ptr)%s";
        v13 = v15;
        v14 = 38;
LABEL_17:
        _os_log_impl(&dword_1D4E88000, v13, OS_LOG_TYPE_DEBUG, v12, buf, v14);
        return Params;
      }
      return Params;
    }
  }
  else
  {
    if (!outConnectionParams)
    {
      Params = -50;
      goto LABEL_15;
    }
    v7 = MIDIProcess::defaultInstance((MIDIProcess *)v5);
    v8 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v7 + 56))(v7);
    Params = (int)v8;
    if (!(_DWORD)v8)
    {
      v9 = ClientInterface::global(v8);
      Params = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *, CFDataRef *))*v9 + 35))(v9, v3, outConnectionParams);
    }
  }
  gMIDIClientLog();
  v10 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    if (*outConnectionParams)
      v11 = *outConnectionParams;
    else
      v11 = (CFDataRef)CFSTR("(null)");
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v17, Params);
    *(_DWORD *)buf = 136316162;
    v19 = "MIDIClientLib.cpp";
    v20 = 1024;
    v21 = 1359;
    v22 = 2080;
    v23 = "MIDIThruConnectionGetParams";
    v24 = 2112;
    v25 = v11;
    v26 = 2080;
    v27 = v17;
    v12 = "%25s:%-5d <-%s: %@%s";
    v13 = v10;
    v14 = 48;
    goto LABEL_17;
  }
  return Params;
}

OSStatus MIDIThruConnectionSetParams(MIDIThruConnectionRef connection, CFDataRef inConnectionParams)
{
  MIDIServer *v3;
  NSObject *v4;
  _BOOL8 v5;
  CFDataRef v6;
  unsigned int v7;
  uint64_t *v8;
  ClientInterface *v9;
  unsigned int v10;
  _UNKNOWN **v11;
  NSObject *v12;
  _BYTE v14[32];
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  _WORD v22[17];

  v3 = *(MIDIServer **)&connection;
  *(_QWORD *)&v22[13] = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v4 = gMIDIClientLog(void)::clilib;
  v5 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v5)
  {
    v6 = (CFDataRef)CFSTR("(null)");
    *(_DWORD *)buf = 136316162;
    if (inConnectionParams)
      v6 = inConnectionParams;
    v16 = "MIDIClientLib.cpp";
    v17 = 1024;
    v18 = 1366;
    v19 = 2080;
    v20 = "MIDIThruConnectionSetParams";
    v21 = 1024;
    *(_DWORD *)v22 = (_DWORD)v3;
    v22[2] = 2112;
    *(_QWORD *)&v22[3] = v6;
    _os_log_impl(&dword_1D4E88000, v4, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s 0x%x %@", buf, 0x2Cu);
  }
  if ((gInMIDIServer & 1) != 0)
  {
    v7 = _MIDIThruConnectionSetParams(v3, inConnectionParams);
  }
  else
  {
    v8 = MIDIProcess::defaultInstance((MIDIProcess *)v5);
    v9 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v8 + 56))(v8);
    v10 = v9;
    if ((_DWORD)v9)
      goto LABEL_10;
    v11 = ClientInterface::global(v9);
    v7 = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *, CFDataRef))*v11 + 36))(v11, v3, inConnectionParams);
  }
  v10 = v7;
LABEL_10:
  gMIDIClientLog();
  v12 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v14, v10);
    *(_DWORD *)buf = 136315906;
    v16 = "MIDIClientLib.cpp";
    v17 = 1024;
    v18 = 1373;
    v19 = 2080;
    v20 = "MIDIThruConnectionSetParams";
    v21 = 2080;
    *(_QWORD *)v22 = v14;
    _os_log_impl(&dword_1D4E88000, v12, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s%s", buf, 0x26u);
  }
  return v10;
}

OSStatus MIDIThruConnectionFind(CFStringRef inPersistentOwnerID, CFDataRef *outConnectionList)
{
  NSObject *v4;
  _BOOL8 v5;
  CFStringRef v6;
  int v7;
  uint64_t *v8;
  ClientInterface *v9;
  _UNKNOWN **v10;
  uint64_t v11;
  CFDataRef v12;
  const char *v13;
  NSObject *v14;
  uint32_t v15;
  uint64_t v16;
  _BYTE v18[32];
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  _BYTE *v26;
  __int16 v27;
  _BYTE *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v4 = gMIDIClientLog(void)::clilib;
  v5 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v5)
  {
    v6 = CFSTR("(null)");
    *(_DWORD *)buf = 136315906;
    v20 = "MIDIClientLib.cpp";
    if (inPersistentOwnerID)
      v6 = inPersistentOwnerID;
    v21 = 1024;
    v22 = 1380;
    v23 = 2080;
    v24 = "MIDIThruConnectionFind";
    v25 = 2112;
    v26 = v6;
    _os_log_impl(&dword_1D4E88000, v4, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s %@", buf, 0x26u);
  }
  if ((gInMIDIServer & 1) != 0)
  {
    v7 = _MIDIThruConnectionFind((MIDIServer *)inPersistentOwnerID, outConnectionList);
    if (!outConnectionList)
    {
LABEL_17:
      gMIDIClientLog();
      v16 = gMIDIClientLog(void)::clilib;
      if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
      {
        ErrorFormatter::ErrorFormatter((ErrorFormatter *)v18, v7);
        *(_DWORD *)buf = 136315906;
        v20 = "MIDIClientLib.cpp";
        v21 = 1024;
        v22 = 1388;
        v23 = 2080;
        v24 = "MIDIThruConnectionFind";
        v25 = 2080;
        v26 = v18;
        v13 = "%25s:%-5d <-%s: (null ptr)%s";
        v14 = v16;
        v15 = 38;
LABEL_19:
        _os_log_impl(&dword_1D4E88000, v14, OS_LOG_TYPE_DEBUG, v13, buf, v15);
        return v7;
      }
      return v7;
    }
  }
  else
  {
    if (!outConnectionList)
    {
      v7 = -50;
      goto LABEL_17;
    }
    v8 = MIDIProcess::defaultInstance((MIDIProcess *)v5);
    v9 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v8 + 56))(v8);
    v7 = (int)v9;
    if (!(_DWORD)v9)
    {
      v10 = ClientInterface::global(v9);
      v7 = (*((uint64_t (**)(_UNKNOWN **, CFStringRef, CFDataRef *))*v10 + 37))(v10, inPersistentOwnerID, outConnectionList);
    }
  }
  gMIDIClientLog();
  v11 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    if (*outConnectionList)
      v12 = *outConnectionList;
    else
      v12 = (CFDataRef)CFSTR("(null)");
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v18, v7);
    *(_DWORD *)buf = 136316162;
    v20 = "MIDIClientLib.cpp";
    v21 = 1024;
    v22 = 1388;
    v23 = 2080;
    v24 = "MIDIThruConnectionFind";
    v25 = 2112;
    v26 = v12;
    v27 = 2080;
    v28 = v18;
    v13 = "%25s:%-5d <-%s: %@%s";
    v14 = v11;
    v15 = 48;
    goto LABEL_19;
  }
  return v7;
}

OSStatus MIDIObjectFindByUniqueID(MIDIUniqueID inUniqueID, MIDIObjectRef *outObject, MIDIObjectType *outObjectType)
{
  MIDIServer *v5;
  NSObject *v6;
  _BOOL8 v7;
  OSStatus v8;
  uint64_t *v9;
  ClientInterface *v10;
  OSStatus v11;
  _UNKNOWN **v12;
  NSObject *v13;
  MIDIObjectRef v14;
  MIDIObjectType v15;
  int v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  MIDIObjectRef v24;
  __int16 v25;
  MIDIObjectType v26;
  __int16 v27;
  OSStatus v28;
  uint64_t v29;

  v5 = *(MIDIServer **)&inUniqueID;
  v29 = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v6 = gMIDIClientLog(void)::clilib;
  v7 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v7)
  {
    v17 = 136315906;
    v18 = "MIDIClientLib.cpp";
    v19 = 1024;
    v20 = 1395;
    v21 = 2080;
    v22 = "MIDIObjectFindByUniqueID";
    v23 = 1024;
    v24 = v5;
    _os_log_impl(&dword_1D4E88000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s 0x%x", (uint8_t *)&v17, 0x22u);
  }
  if ((gInMIDIServer & 1) != 0)
  {
    v8 = _MIDIObjectFindByUniqueID(v5, outObject, outObjectType);
  }
  else
  {
    v9 = MIDIProcess::defaultInstance((MIDIProcess *)v7);
    v10 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v9 + 56))(v9);
    v11 = (int)v10;
    if ((_DWORD)v10)
      goto LABEL_8;
    v12 = ClientInterface::global(v10);
    v8 = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *, MIDIObjectRef *, MIDIObjectType *))*v12 + 20))(v12, v5, outObject, outObjectType);
  }
  v11 = v8;
LABEL_8:
  gMIDIClientLog();
  v13 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    if (outObject)
    {
      v14 = *outObject;
      if (outObjectType)
      {
LABEL_11:
        v15 = *outObjectType;
LABEL_14:
        v17 = 136316418;
        v18 = "MIDIClientLib.cpp";
        v19 = 1024;
        v20 = 1402;
        v21 = 2080;
        v22 = "MIDIObjectFindByUniqueID";
        v23 = 1024;
        v24 = v14;
        v25 = 1024;
        v26 = v15;
        v27 = 1024;
        v28 = v11;
        _os_log_impl(&dword_1D4E88000, v13, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s: obj 0x%x, type 0x%x, err %d", (uint8_t *)&v17, 0x2Eu);
        return v11;
      }
    }
    else
    {
      v14 = 0;
      if (outObjectType)
        goto LABEL_11;
    }
    v15 = kMIDIObjectType_Device;
    goto LABEL_14;
  }
  return v11;
}

OSStatus MIDIBluetoothDriverActivateAllConnections(void)
{
  MIDIProcess *v0;
  uint64_t *v1;
  OSStatus v2;
  MIDIObjectRef NullDevice;
  NSObject *v4;
  int v6;
  const char *v7;
  __int16 v8;
  int v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  OSStatus v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if ((gInMIDIServer & 1) != 0
    || (v1 = MIDIProcess::defaultInstance(v0), (v2 = (*(uint64_t (**)(uint64_t *))(*v1 + 56))(v1)) == 0))
  {
    NullDevice = FindNullDevice();
    if (!NullDevice)
      return -10833;
    v2 = MIDIObjectSetIntegerProperty(NullDevice, CFSTR("activate all devices"), 1);
  }
  gMIDIClientLog();
  v4 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_INFO))
  {
    v6 = 136315906;
    v7 = "MIDIClientLib.cpp";
    v8 = 1024;
    v9 = 1432;
    v10 = 2080;
    v11 = "MIDIBluetoothDriverActivateAllConnections";
    v12 = 1024;
    v13 = v2;
    _os_log_impl(&dword_1D4E88000, v4, OS_LOG_TYPE_INFO, "%25s:%-5d <-%s: err %d", (uint8_t *)&v6, 0x22u);
  }
  return v2;
}

uint64_t FindNullDevice(void)
{
  ItemCount v0;
  ItemCount v1;
  ItemCount i;
  uint64_t v3;
  uint64_t v4;
  SInt32 outValue;
  CFStringRef str;

  v0 = MIDIGetNumberOfDevices();
  if (v0)
  {
    v1 = v0;
    for (i = 0; i != v1; ++i)
    {
      v3 = MIDIGetDevice(i);
      if ((_DWORD)v3)
      {
        v4 = v3;
        str = 0;
        MIDIObjectGetStringProperty(v3, kMIDIPropertyDriverOwner, &str);
        if (str)
        {
          if (CFEqual(str, CFSTR("com.apple.AppleMIDIBluetoothDriver")))
          {
            CFRelease(str);
            outValue = 0;
            MIDIObjectGetIntegerProperty(v4, CFSTR("is BLE MIDI null device"), &outValue);
            if (outValue)
              return v4;
          }
          else if (str)
          {
            CFRelease(str);
          }
        }
      }
    }
  }
  return 0;
}

OSStatus MIDIBluetoothDriverDisconnect(CFStringRef uuid)
{
  uint64_t *v2;
  OSStatus v3;
  MIDIObjectRef NullDevice;
  NSObject *v5;
  int v7;
  const char *v8;
  __int16 v9;
  int v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  OSStatus v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if ((gInMIDIServer & 1) != 0
    || (v2 = MIDIProcess::defaultInstance((MIDIProcess *)uuid),
        (v3 = (*(uint64_t (**)(uint64_t *))(*v2 + 56))(v2)) == 0))
  {
    NullDevice = FindNullDevice();
    if (!NullDevice)
      return -10833;
    v3 = MIDIObjectSetStringProperty(NullDevice, CFSTR("disconnect device"), uuid);
  }
  gMIDIClientLog();
  v5 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_INFO))
  {
    v7 = 136315906;
    v8 = "MIDIClientLib.cpp";
    v9 = 1024;
    v10 = 1448;
    v11 = 2080;
    v12 = "MIDIBluetoothDriverDisconnect";
    v13 = 1024;
    v14 = v3;
    _os_log_impl(&dword_1D4E88000, v5, OS_LOG_TYPE_INFO, "%25s:%-5d <-%s: err %d", (uint8_t *)&v7, 0x22u);
  }
  return v3;
}

uint64_t UMPCIObjectCreate(uint64_t a1, const void *a2, int *a3)
{
  NSObject *v6;
  CFTypeID MainBundle;
  uint64_t v8;
  const __CFArray *v9;
  CFTypeID v10;
  uint64_t v11;
  const char *v12;
  NSObject *v13;
  uint32_t v14;
  uint64_t *v15;
  ClientInterface *v16;
  _UNKNOWN **v17;
  uint64_t v18;
  int v19;
  _BYTE v21[32];
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  _WORD v29[17];
  CFRange v30;

  *(_QWORD *)&v29[13] = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v6 = gMIDIClientLog(void)::clilib;
  MainBundle = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if ((_DWORD)MainBundle)
  {
    *(_DWORD *)buf = 136315906;
    v23 = "MIDIClientLib.cpp";
    v24 = 1024;
    v25 = 1457;
    v26 = 2080;
    v27 = "UMPCIObjectCreate";
    v28 = 1024;
    *(_DWORD *)v29 = a1;
    _os_log_impl(&dword_1D4E88000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s \"0x%x", buf, 0x22u);
  }
  if ((gInMIDIServer & 1) == 0)
  {
    if (CheckVirtualEndpointCreation(void)::virtualEndpointsAllowed < 0)
    {
      CheckVirtualEndpointCreation(void)::virtualEndpointsAllowed = 0;
      MainBundle = (CFTypeID)CFBundleGetMainBundle();
      if (MainBundle)
      {
        MainBundle = (CFTypeID)CFBundleGetValueForInfoDictionaryKey((CFBundleRef)MainBundle, CFSTR("UIBackgroundModes"));
        if (MainBundle)
        {
          v9 = (const __CFArray *)MainBundle;
          v10 = CFGetTypeID((CFTypeRef)MainBundle);
          MainBundle = CFArrayGetTypeID();
          if (v10 == MainBundle)
          {
            v30.length = CFArrayGetCount(v9);
            v30.location = 0;
            MainBundle = CFArrayContainsValue(v9, v30, CFSTR("audio"));
            if ((_DWORD)MainBundle)
            {
              CheckVirtualEndpointCreation(void)::virtualEndpointsAllowed = 1;
              if (a3)
              {
LABEL_9:
                if ((gInMIDIServer & 1) != 0)
                {
                  v8 = 0xFFFFFFFFLL;
                }
                else
                {
                  v15 = MIDIProcess::defaultInstance((MIDIProcess *)MainBundle);
                  v16 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v15 + 56))(v15);
                  v8 = (uint64_t)v16;
                  if (!(_DWORD)v16)
                  {
                    v17 = ClientInterface::global(v16);
                    v8 = (*((uint64_t (**)(_UNKNOWN **, uint64_t, const void *, int *))*v17 + 44))(v17, a1, a2, a3);
                  }
                }
                goto LABEL_23;
              }
LABEL_16:
              v8 = 4294967246;
              goto LABEL_17;
            }
          }
        }
      }
      if (CheckVirtualEndpointCreation(void)::virtualEndpointsAllowed)
      {
LABEL_8:
        if (a3)
          goto LABEL_9;
        goto LABEL_16;
      }
    }
    else if (CheckVirtualEndpointCreation(void)::virtualEndpointsAllowed)
    {
      goto LABEL_8;
    }
    return 4294956452;
  }
  v8 = _UMPCIObjectCreate(0, a1, a2, a3);
  if (!a3)
  {
LABEL_17:
    gMIDIClientLog();
    v11 = gMIDIClientLog(void)::clilib;
    if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
    {
      ErrorFormatter::ErrorFormatter((ErrorFormatter *)v21, v8);
      *(_DWORD *)buf = 136315906;
      v23 = "MIDIClientLib.cpp";
      v24 = 1024;
      v25 = 1469;
      v26 = 2080;
      v27 = "UMPCIObjectCreate";
      v28 = 2080;
      *(_QWORD *)v29 = v21;
      v12 = "%25s:%-5d <-%s: (null ptr)%s";
      v13 = v11;
      v14 = 38;
LABEL_25:
      _os_log_impl(&dword_1D4E88000, v13, OS_LOG_TYPE_DEBUG, v12, buf, v14);
      return v8;
    }
    return v8;
  }
LABEL_23:
  gMIDIClientLog();
  v18 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    v19 = *a3;
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v21, v8);
    *(_DWORD *)buf = 136316162;
    v23 = "MIDIClientLib.cpp";
    v24 = 1024;
    v25 = 1469;
    v26 = 2080;
    v27 = "UMPCIObjectCreate";
    v28 = 1024;
    *(_DWORD *)v29 = v19;
    v29[2] = 2080;
    *(_QWORD *)&v29[3] = v21;
    v12 = "%25s:%-5d <-%s: 0x%x%s";
    v13 = v18;
    v14 = 44;
    goto LABEL_25;
  }
  return v8;
}

uint64_t UMPCIObjectSetDescription(MIDIServer *a1, const void *a2)
{
  NSObject *v4;
  _BOOL8 v5;
  uint64_t v6;
  uint64_t *v7;
  ClientInterface *v8;
  uint64_t v9;
  _UNKNOWN **v10;
  NSObject *v11;
  _BYTE v13[32];
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  _BYTE *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v4 = gMIDIClientLog(void)::clilib;
  v5 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v5)
  {
    *(_DWORD *)buf = 136315906;
    v15 = "MIDIClientLib.cpp";
    v16 = 1024;
    v17 = 1497;
    v18 = 2080;
    v19 = "UMPCIObjectSetDescription";
    v20 = 1024;
    LODWORD(v21) = (_DWORD)a1;
    _os_log_impl(&dword_1D4E88000, v4, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s 0x%x", buf, 0x22u);
  }
  if ((gInMIDIServer & 1) != 0)
  {
    v6 = _UMPCIObjectSetDescription(a1, a2);
  }
  else
  {
    v7 = MIDIProcess::defaultInstance((MIDIProcess *)v5);
    v8 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v7 + 56))(v7);
    v9 = (uint64_t)v8;
    if ((_DWORD)v8)
      goto LABEL_8;
    v10 = ClientInterface::global(v8);
    v6 = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *, const void *))*v10 + 47))(v10, a1, a2);
  }
  v9 = v6;
LABEL_8:
  gMIDIClientLog();
  v11 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v13, v9);
    *(_DWORD *)buf = 136315906;
    v15 = "MIDIClientLib.cpp";
    v16 = 1024;
    v17 = 1505;
    v18 = 2080;
    v19 = "UMPCIObjectSetDescription";
    v20 = 2080;
    v21 = v13;
    _os_log_impl(&dword_1D4E88000, v11, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s%s", buf, 0x26u);
  }
  return v9;
}

uint64_t UMPCIObjectSetEnableState(MIDIServer *a1, uint64_t a2)
{
  NSObject *v4;
  _BOOL8 v5;
  const char *v6;
  uint64_t v7;
  uint64_t *v8;
  ClientInterface *v9;
  uint64_t v10;
  _UNKNOWN **v11;
  NSObject *v12;
  _BYTE v14[32];
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  _WORD v22[17];

  *(_QWORD *)&v22[13] = *MEMORY[0x1E0C80C00];
  gMIDIClientLog();
  v4 = gMIDIClientLog(void)::clilib;
  v5 = os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG);
  if (v5)
  {
    v6 = "true";
    *(_DWORD *)buf = 136316162;
    v16 = "MIDIClientLib.cpp";
    v17 = 1024;
    if (!(_DWORD)a2)
      v6 = "false";
    v18 = 1513;
    v19 = 2080;
    v20 = "UMPCIObjectSetEnableState";
    v21 = 1024;
    *(_DWORD *)v22 = (_DWORD)a1;
    v22[2] = 2080;
    *(_QWORD *)&v22[3] = v6;
    _os_log_impl(&dword_1D4E88000, v4, OS_LOG_TYPE_DEBUG, "%25s:%-5d ->%s 0x%x %s", buf, 0x2Cu);
  }
  if ((gInMIDIServer & 1) != 0)
  {
    v7 = _UMPCIObjectSetEnableState(a1, a2);
  }
  else
  {
    v8 = MIDIProcess::defaultInstance((MIDIProcess *)v5);
    v9 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v8 + 56))(v8);
    v10 = (uint64_t)v9;
    if ((_DWORD)v9)
      goto LABEL_10;
    v11 = ClientInterface::global(v9);
    v7 = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *, uint64_t))*v11 + 48))(v11, a1, a2);
  }
  v10 = v7;
LABEL_10:
  gMIDIClientLog();
  v12 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v14, v10);
    *(_DWORD *)buf = 136315906;
    v16 = "MIDIClientLib.cpp";
    v17 = 1024;
    v18 = 1521;
    v19 = 2080;
    v20 = "UMPCIObjectSetEnableState";
    v21 = 2080;
    *(_QWORD *)v22 = v14;
    _os_log_impl(&dword_1D4E88000, v12, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s%s", buf, 0x26u);
  }
  return v10;
}

uint64_t UMPCIGlobalState(MIDIServer *a1)
{
  uint64_t v2;
  uint64_t *v3;
  ClientInterface *v4;
  uint64_t v5;
  _UNKNOWN **v6;
  NSObject *v7;
  _BYTE v9[32];
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  _BYTE *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if ((gInMIDIServer & 1) != 0)
  {
    v2 = _UMPCIGlobalState(a1);
  }
  else
  {
    v3 = MIDIProcess::defaultInstance(a1);
    v4 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v3 + 56))(v3);
    v5 = (uint64_t)v4;
    if ((_DWORD)v4)
      goto LABEL_6;
    v6 = ClientInterface::global(v4);
    v2 = (*((uint64_t (**)(_UNKNOWN **, MIDIServer *))*v6 + 49))(v6, a1);
  }
  v5 = v2;
LABEL_6:
  gMIDIClientLog();
  v7 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v9, v5);
    *(_DWORD *)buf = 136315906;
    v11 = "MIDIClientLib.cpp";
    v12 = 1024;
    v13 = 1536;
    v14 = 2080;
    v15 = "UMPCIGlobalState";
    v16 = 2080;
    v17 = v9;
    _os_log_impl(&dword_1D4E88000, v7, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s%s", buf, 0x26u);
  }
  return v5;
}

uint64_t UMPCIDiscover(MIDIServer *a1)
{
  uint64_t v1;
  uint64_t *v2;
  ClientInterface *v3;
  uint64_t v4;
  _UNKNOWN **v5;
  NSObject *v6;
  _BYTE v8[32];
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  _BYTE *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if ((gInMIDIServer & 1) != 0)
  {
    v1 = _UMPCIDiscover(a1);
  }
  else
  {
    v2 = MIDIProcess::defaultInstance(a1);
    v3 = (ClientInterface *)(*(uint64_t (**)(uint64_t *))(*v2 + 56))(v2);
    v4 = (uint64_t)v3;
    if ((_DWORD)v3)
      goto LABEL_6;
    v5 = ClientInterface::global(v3);
    v1 = (*((uint64_t (**)(_UNKNOWN **))*v5 + 50))(v5);
  }
  v4 = v1;
LABEL_6:
  gMIDIClientLog();
  v6 = gMIDIClientLog(void)::clilib;
  if (os_log_type_enabled((os_log_t)gMIDIClientLog(void)::clilib, OS_LOG_TYPE_DEBUG))
  {
    ErrorFormatter::ErrorFormatter((ErrorFormatter *)v8, v4);
    *(_DWORD *)buf = 136315906;
    v10 = "MIDIClientLib.cpp";
    v11 = 1024;
    v12 = 1550;
    v13 = 2080;
    v14 = "UMPCIDiscover";
    v15 = 2080;
    v16 = v8;
    _os_log_impl(&dword_1D4E88000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d <-%s%s", buf, 0x26u);
  }
  return v4;
}

void FlushManager::~FlushManager(FlushManager *this)
{
  FlushManager::~FlushManager(this);
  JUMPOUT(0x1D826BA98);
}

{
  MIDIObjectRef **v2;
  MIDIObjectRef *v3;
  OSStatus IntegerProperty;
  SInt32 v5;
  BOOL v6;
  MIDITimeStamp v7;
  int v8;
  uint64_t v9;
  MIDIObjectRef *v10;
  int v11;
  unsigned int v12;
  int v13;
  MIDIObjectRef **v14;
  SInt32 outValue;
  MIDIEventPacket v16;

  *(_QWORD *)this = &off_1E98B9460;
  v2 = (MIDIObjectRef **)*((_QWORD *)this + 1);
  if (v2 != *((MIDIObjectRef ***)this + 2))
  {
    do
    {
      v3 = *v2;
      outValue = 0;
      IntegerProperty = MIDIObjectGetIntegerProperty(*v3, kMIDIPropertyMaxSysExSpeed, &outValue);
      v5 = outValue;
      if (IntegerProperty)
        v6 = 1;
      else
        v6 = outValue == 0;
      if (v6)
      {
        v5 = 3125;
        outValue = 3125;
      }
      v7 = mach_absolute_time();
      v14 = v2;
      v8 = 0;
      v9 = (3 * (0xB2D05E00uLL / v5) * (unsigned __int128)0x20C49BA5E353F7DuLL) >> 64;
      v16.wordCount = 1;
      v10 = v3 + 1;
      do
      {
        v11 = 0;
        v12 = 0;
        v13 = v8 << 16;
        do
        {
          if (((*((unsigned __int8 *)v10 + ((unint64_t)v12 >> 3)) >> (v12 & 7)) & 1) != 0)
          {
            v16.timeStamp = v7;
            v16.words[0] = v13 | v11 | 0x20800040;
            Scheduler::SchedulePacket(*((_QWORD *)this + 4), 0, *v3, kMIDIProtocol_1_0, &v16);
            v7 += v9;
          }
          ++v12;
          v11 += 256;
        }
        while (v12 != 128);
        if (*((_BYTE *)v10 + 16))
        {
          v16.words[0] = v13 | 0x20B04000;
          Scheduler::SchedulePacket(*((_QWORD *)this + 4), 0, *v3, kMIDIProtocol_1_0, &v16);
          v7 += v9;
        }
        if (*((_BYTE *)v10 + 17))
        {
          v16.words[0] = v13 | 0x20E00040;
          Scheduler::SchedulePacket(*((_QWORD *)this + 4), 0, *v3, kMIDIProtocol_1_0, &v16);
          v7 += v9;
        }
        ++v8;
        v10 += 5;
      }
      while (v8 != 16);
      v2 = v14 + 1;
    }
    while (v14 + 1 != *((MIDIObjectRef ***)this + 2));
  }
  OwnedPtrVector<FlushDest *>::~OwnedPtrVector(this);
}

_QWORD *OwnedPtrVector<FlushDest *>::~OwnedPtrVector(_QWORD *a1)
{
  char *v2;
  char *v3;
  char *v4;
  _BYTE *v5;
  uint64_t v6;
  char *v7;

  *a1 = &off_1E98B9850;
  v2 = (char *)a1[1];
  v3 = (char *)a1[2];
  if (v2 != v3)
  {
    v4 = (char *)a1[1];
    do
    {
      if (*(_QWORD *)v4)
        MEMORY[0x1D826BA98](*(_QWORD *)v4, 0x1000C4082BDDFCDLL);
      v4 += 8;
    }
    while (v4 != v3);
    v5 = (_BYTE *)a1[2];
    v6 = v5 - v3;
    if (v5 != v3)
      memmove(v2, v3, v5 - v3);
    v7 = (char *)a1[1];
    a1[2] = &v2[v6];
    v2 = v7;
  }
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t Scheduler::SchedulePacket(uint64_t this, uint64_t a2, int a3, MIDIProtocolID a4, const MIDIEventPacket *a5)
{
  uint64_t v9;
  MIDITimeStamp timeStamp;
  uint64_t wordCount;
  _DWORD *v12;
  __int128 v13;
  int v14;
  uint64_t **v15;
  uint64_t *v16;
  uint64_t **v17;
  _QWORD *v18;
  MIDITimeStamp v19;
  BOOL v20;
  _QWORD *v21;
  uint64_t *v22;
  uint64_t *v23;
  uint64_t **v24;
  uint64_t *v25;
  uint64_t **v26;
  uint64_t *v27;
  uint64_t **v28;
  BOOL v29;
  uint64_t v30;
  uint64_t v31;
  _DWORD *v32;
  __int128 v33;

  if (!*(_BYTE *)(this + 144))
  {
    v9 = this;
    timeStamp = a5->timeStamp;
    wordCount = a5->wordCount;
    v12 = malloc_type_malloc(4 * wordCount + 20, 0x53A9EFB0uLL);
    v32 = v12;
    *v12 = a4;
    v12[1] = 1;
    *((_QWORD *)v12 + 1) = timeStamp;
    v12[4] = wordCount;
    if ((_DWORD)wordCount)
      memmove(v12 + 5, a5->words, 4 * wordCount);
    *(_QWORD *)&v13 = v32;
    *((_QWORD *)&v13 + 1) = MIDI::packet_list_deleter;
    v33 = v13;
    v14 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v9 + 24) + 16))(v9 + 24);
    v15 = (uint64_t **)(v9 + 128);
    v16 = *(uint64_t **)(v9 + 128);
    v17 = (uint64_t **)(v9 + 128);
    if (v16)
    {
      v17 = (uint64_t **)(v9 + 128);
      v18 = *(_QWORD **)(v9 + 128);
      do
      {
        v19 = v18[4];
        v20 = timeStamp >= v19;
        if (timeStamp >= v19)
          v21 = v18 + 1;
        else
          v21 = v18;
        if (!v20)
          v17 = (uint64_t **)v18;
        v18 = (_QWORD *)*v21;
      }
      while (*v21);
    }
    v22 = (uint64_t *)operator new(0x50uLL);
    v23 = v22;
    v22[4] = timeStamp;
    v22[5] = timeStamp;
    v22[6] = a2;
    *((_DWORD *)v22 + 14) = a3;
    *((_OWORD *)v22 + 4) = v33;
    if (v15 == v17 || (unint64_t)v17[4] >= timeStamp)
    {
      v25 = *v17;
      v26 = v17;
      if (*(uint64_t ***)(v9 + 120) == v17)
        goto LABEL_32;
      if (v25)
      {
        v27 = *v17;
        do
        {
          v26 = (uint64_t **)v27;
          v27 = (uint64_t *)v27[1];
        }
        while (v27);
      }
      else
      {
        v28 = v17;
        do
        {
          v26 = (uint64_t **)v28[2];
          v29 = *v26 == (uint64_t *)v28;
          v28 = v26;
        }
        while (v29);
      }
      if (timeStamp >= (unint64_t)v26[4])
      {
LABEL_32:
        if (v25)
          v15 = v26;
        else
          v15 = v17;
        if (v25)
          v24 = v26 + 1;
        else
          v24 = v17;
      }
      else
      {
LABEL_27:
        v24 = v15;
        if (v16)
        {
          do
          {
            v15 = (uint64_t **)v16;
            if (timeStamp < v16[4])
            {
              v16 = (uint64_t *)*v16;
              goto LABEL_27;
            }
            v16 = (uint64_t *)v16[1];
          }
          while (v16);
LABEL_38:
          v24 = v15 + 1;
        }
      }
    }
    else
    {
      while (1)
      {
        v24 = v15;
        if (!v16)
          break;
        while (1)
        {
          v15 = (uint64_t **)v16;
          if (v16[4] >= timeStamp)
            break;
          v16 = (uint64_t *)v16[1];
          if (!v16)
            goto LABEL_38;
        }
        v16 = (uint64_t *)*v16;
      }
    }
    *v22 = 0;
    v22[1] = 0;
    v22[2] = (uint64_t)v15;
    *v24 = v22;
    v30 = **(_QWORD **)(v9 + 120);
    if (v30)
    {
      *(_QWORD *)(v9 + 120) = v30;
      v23 = *v24;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v9 + 128), v23);
    ++*(_QWORD *)(v9 + 136);
    v31 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIEndpoint>::sRTTI, a3);
    if (v31)
      ++*(_DWORD *)(v31 + 92);
    this = CADeprecated::TimerTaskMgr::SetTaskNextWakeTime(gMIDITimerThread, v9, timeStamp);
    if (v14)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v9 + 24) + 24))(v9 + 24);
  }
  return this;
}

void sub_1D4EFB568(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int128 a9)
{
  uint64_t v9;
  int v10;
  void *v11;
  __int128 v13;
  __int128 v14;

  MIDI::packet_list_deleter(v11);
  *((_QWORD *)&v13 + 1) = *((_QWORD *)&a9 + 1);
  *(_QWORD *)&v13 = 0;
  v14 = v13;
  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 24))(v9);
  if ((_QWORD)v14)
    (*((void (**)(void))&v14 + 1))();
  _Unwind_Resume(a1);
}

void OwnedPtrVector<FlushDest *>::~OwnedPtrVector(_QWORD *a1)
{
  OwnedPtrVector<FlushDest *>::~OwnedPtrVector(a1);
  JUMPOUT(0x1D826BA98);
}

void Scheduler::~Scheduler(Scheduler *this)
{
  *(_QWORD *)this = &off_1E98B9B38;
  std::__tree<std::__value_type<unsigned long long,ScheduledEvent>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,ScheduledEvent>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,ScheduledEvent>>>::destroy(*((_QWORD **)this + 16));
  *((_QWORD *)this + 3) = &off_1E98B9D98;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 48));
}

{
  *(_QWORD *)this = &off_1E98B9B38;
  std::__tree<std::__value_type<unsigned long long,ScheduledEvent>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,ScheduledEvent>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,ScheduledEvent>>>::destroy(*((_QWORD **)this + 16));
  *((_QWORD *)this + 3) = &off_1E98B9D98;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 48));
  JUMPOUT(0x1D826BA98);
}

uint64_t Scheduler::Perform(Scheduler *this)
{
  CADeprecated::CAMutex *v2;
  char *v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  void (*v8)(_DWORD *);
  _DWORD *v9;
  uint64_t v10;
  MIDIServer *v11;
  uint64_t *v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int v16;
  const MIDIEventPacket *v17;
  MIDIServer *v18;
  uint64_t *v19;
  int v20;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t (**v25)();
  _QWORD v26[6];
  _QWORD *v27;
  uint64_t v28;
  _QWORD v29[129];

  v29[127] = *MEMORY[0x1E0C80C00];
  v2 = (Scheduler *)((char *)this + 24);
  CADeprecated::CAMutex::Lock((Scheduler *)((char *)this + 24));
  v22 = 0;
  v23 = 0;
  v25 = caulk::inplace_function<void ()(MIDI::EventList const*),48ul,8ul,caulk::inplace_function_detail::vtable>::k_wrapper_vtable<Scheduler::Perform(unsigned long long)::$_0>;
  v26[0] = &v23;
  v28 = 1;
  v26[1] = &v22;
  v27 = v29;
  if (*((_DWORD *)this + 34))
  {
    v3 = (char *)this + 120;
    while (1)
    {
      v4 = *(_QWORD *)(*(_QWORD *)v3 + 40);
      if (v4 > *((_QWORD *)this + 14) + mach_absolute_time())
        break;
      v5 = *(_QWORD *)v3;
      v6 = *(_QWORD *)(*(_QWORD *)v3 + 48);
      v7 = *(_DWORD *)(*(_QWORD *)v3 + 56);
      v9 = *(_DWORD **)(*(_QWORD *)v3 + 64);
      v8 = *(void (**)(_DWORD *))(*(_QWORD *)v3 + 72);
      *(_QWORD *)(*(_QWORD *)v3 + 64) = 0;
      v10 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIEndpoint>::sRTTI, v7);
      if (v10)
        --*(_DWORD *)(v10 + 92);
      std::__tree<std::__value_type<unsigned long long,ScheduledEvent>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,ScheduledEvent>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,ScheduledEvent>>>::erase((_QWORD *)this + 15, v5);
      CADeprecated::CAMutex::Unlock(v2);
      v12 = MIDIServer::defaultInstance(v11) + 13;
      v13 = (*(uint64_t (**)(uint64_t *))(*v12 + 16))(v12);
      v14 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIEndpoint>::sRTTI, v7);
      if (v14 != v23 || v6 != v22 || *v9 != (_DWORD)v28)
      {
        if (HIDWORD(v28))
        {
          v24 = &v28;
          ((void (*)(_QWORD *, uint64_t **))*v25)(v26, &v24);
        }
        v15 = *v9;
        v27 = v29;
        v28 = v15;
        v22 = v6;
        v23 = v14;
        if (*v9 != v15)
          std::terminate();
      }
      if (v9[1])
      {
        v16 = 0;
        v17 = (const MIDIEventPacket *)(v9 + 2);
        do
        {
          MIDI::Packetizer::add((unsigned int *)&v25, v17);
          v17 = (const MIDIEventPacket *)((char *)v17 + 4 * v17->wordCount + 12);
          ++v16;
        }
        while (v16 < v9[1]);
      }
      if (v13)
        (*(void (**)(uint64_t *))(*v12 + 24))(v12);
      CADeprecated::CAMutex::Lock(v2);
      v8(v9);
      if (!*((_DWORD *)this + 34))
        goto LABEL_20;
    }
    CADeprecated::TimerTaskMgr::SetTaskNextWakeTime(gMIDITimerThread, (uint64_t)this, v4);
  }
LABEL_20:
  CADeprecated::CAMutex::Unlock(v2);
  if (HIDWORD(v28))
  {
    v19 = MIDIServer::defaultInstance(v18) + 13;
    v20 = (*(uint64_t (**)(uint64_t *))(*v19 + 16))(v19);
    if (HIDWORD(v28))
    {
      v24 = &v28;
      ((void (*)(_QWORD *, uint64_t **))*v25)(v26, &v24);
    }
    HIDWORD(v28) = 0;
    v27 = v29;
    if (v20)
      (*(void (**)(uint64_t *))(*v19 + 24))(v19);
  }
  return MIDI::PacketizerBase<MIDI::EventList>::~PacketizerBase((uint64_t)&v25);
}

void sub_1D4EFB95C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

_QWORD *std::__tree<std::__value_type<unsigned long long,ScheduledEvent>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,ScheduledEvent>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,ScheduledEvent>>>::erase(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  BOOL v6;
  uint64_t *v7;
  uint64_t v8;

  v3 = *(_QWORD **)(a2 + 8);
  if (v3)
  {
    do
    {
      v4 = v3;
      v3 = (_QWORD *)*v3;
    }
    while (v3);
  }
  else
  {
    v5 = (_QWORD *)a2;
    do
    {
      v4 = (_QWORD *)v5[2];
      v6 = *v4 == (_QWORD)v5;
      v5 = v4;
    }
    while (!v6);
  }
  if (*a1 == a2)
    *a1 = v4;
  v7 = (uint64_t *)a1[1];
  --a1[2];
  std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v7, (uint64_t *)a2);
  v8 = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a2 + 64) = 0;
  if (v8)
    (*(void (**)(void))(a2 + 72))();
  operator delete((void *)a2);
  return v4;
}

uint64_t **caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<Scheduler::Perform(unsigned long long)::$_0>(caulk::inplace_function_detail::wrapper<Scheduler::Perform(unsigned long long)::$_0>)::{lambda(void *,MIDI::EventList const*&&)#1}::__invoke(uint64_t **result, const MIDI::EventList **a2)
{
  uint64_t v2;
  const MIDI::EventList *v3;
  void *v4;
  _QWORD *v5;
  uint64_t **v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;

  v2 = **result;
  if (v2)
  {
    v3 = *a2;
    v4 = (void *)*result[1];
    v5 = (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 88))(**result);
    if (v5)
    {
      return (uint64_t **)MIDIDestination::SendPacketsNow(v5, v4, v3);
    }
    else
    {
      result = (uint64_t **)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 80))(v2);
      if (result)
      {
        v6 = result;
        v7 = result[12];
        v8 = result[13];
        while (v7 != v8)
        {
          v9 = *v7++;
          result = (uint64_t **)MIDIInputPort::DeliverPacketsToInputPort(v9, v3, *((_DWORD *)v6 + 2));
        }
      }
    }
  }
  return result;
}

__n128 caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<Scheduler::Perform(unsigned long long)::$_0>(caulk::inplace_function_detail::wrapper<Scheduler::Perform(unsigned long long)::$_0>)::{lambda(void *,void *)#1}::__invoke(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  *a1 = *a2;
  return result;
}

__n128 caulk::inplace_function_detail::vtable<void,MIDI::EventList const*>::vtable<Scheduler::Perform(unsigned long long)::$_0>(caulk::inplace_function_detail::wrapper<Scheduler::Perform(unsigned long long)::$_0>)::{lambda(void *,void *)#2}::__invoke(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  *a1 = *a2;
  return result;
}

void std::__tree<std::__value_type<unsigned long long,ScheduledEvent>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,ScheduledEvent>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,ScheduledEvent>>>::destroy(_QWORD *a1)
{
  uint64_t v2;

  if (a1)
  {
    std::__tree<std::__value_type<unsigned long long,ScheduledEvent>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,ScheduledEvent>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,ScheduledEvent>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned long long,ScheduledEvent>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,ScheduledEvent>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,ScheduledEvent>>>::destroy(a1[1]);
    v2 = a1[8];
    a1[8] = 0;
    if (v2)
      ((void (*)(void))a1[9])();
    operator delete(a1);
  }
}

uint64_t Scheduler::CheckSchedulePacket(Scheduler *this, uint64_t a2, int a3, MIDIProtocolID a4, const MIDIEventPacket *a5)
{
  char *v10;
  int v11;
  uint64_t v12;
  MIDITimeStamp timeStamp;
  uint64_t v14;

  v10 = (char *)this + 24;
  v11 = (*(uint64_t (**)(char *))(*((_QWORD *)this + 3) + 16))((char *)this + 24);
  v12 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIEndpoint>::sRTTI, a3);
  if (v12)
  {
    if (*(int *)(v12 + 92) > 0
      || (timeStamp = a5->timeStamp, timeStamp > *((_QWORD *)this + 14) + mach_absolute_time()))
    {
      Scheduler::SchedulePacket((uint64_t)this, a2, a3, a4, a5);
      v14 = 1;
      if (!v11)
        return v14;
      goto LABEL_7;
    }
  }
  v14 = 0;
  if (v11)
LABEL_7:
    (*(void (**)(char *))(*(_QWORD *)v10 + 24))(v10);
  return v14;
}

void sub_1D4EFBC98(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  int v2;

  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(exception_object);
}

void Scheduler::FlushAllOutput(Scheduler *this)
{
  char *v2;
  int v3;
  char *v4;
  char **v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  BOOL v11;
  _QWORD v12[5];

  v2 = (char *)this + 24;
  v3 = (*(uint64_t (**)(char *))(*((_QWORD *)this + 3) + 16))((char *)this + 24);
  v12[0] = &off_1E98B9460;
  memset(&v12[1], 0, 24);
  v12[4] = this;
  v4 = (char *)this + 128;
  v7 = (char *)*((_QWORD *)this + 15);
  v5 = (char **)((char *)this + 120);
  v6 = v7;
  if (v7 != v4)
  {
    do
    {
      FlushManagerBase::InspectEvent(v12, *((_DWORD *)v6 + 14), *((_QWORD *)v6 + 8));
      v8 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIEndpoint>::sRTTI, *((_DWORD *)v6 + 14));
      if (v8)
        --*(_DWORD *)(v8 + 92);
      v9 = (char *)*((_QWORD *)v6 + 1);
      if (v9)
      {
        do
        {
          v10 = v9;
          v9 = *(char **)v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          v10 = (char *)*((_QWORD *)v6 + 2);
          v11 = *(_QWORD *)v10 == (_QWORD)v6;
          v6 = v10;
        }
        while (!v11);
      }
      v6 = v10;
    }
    while (v10 != v4);
    v6 = *v5;
  }
  for (;
        v4 != v6;
        v6 = (char *)std::__tree<std::__value_type<unsigned long long,ScheduledEvent>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,ScheduledEvent>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,ScheduledEvent>>>::erase(v5, (uint64_t)v6))
  {
    ;
  }
  FlushManager::~FlushManager((FlushManager *)v12);
  if (v3)
    (*(void (**)(char *))(*(_QWORD *)v2 + 24))(v2);
}

void sub_1D4EFBDDC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  int v3;
  va_list va;

  va_start(va, a2);
  FlushManager::~FlushManager((FlushManager *)va);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  _Unwind_Resume(a1);
}

void FlushManagerBase::InspectEvent(_QWORD *a1, int a2, uint64_t a3)
{
  _QWORD *i;
  _DWORD *v7;
  _DWORD *v8;
  uint64_t j;
  _DWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  char *v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int *v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  int v30;
  unsigned int v31;
  unsigned int v32;
  BOOL v33;
  int v34;
  uint64_t v35;
  uint64_t v36;

  for (i = (_QWORD *)a1[1]; i != (_QWORD *)a1[2]; ++i)
  {
    v7 = (_DWORD *)*i;
    if (*(_DWORD *)*i == a2)
      goto LABEL_25;
  }
  v8 = (_DWORD *)operator new();
  v7 = v8;
  *v8 = a2;
  for (j = 1; j != 81; j += 5)
  {
    v10 = &v8[j];
    *(_QWORD *)v10 = 0;
    *((_QWORD *)v10 + 1) = 0;
    *((_WORD *)v10 + 8) = 0;
  }
  v12 = (_QWORD *)a1[2];
  v11 = a1[3];
  if ((unint64_t)v12 >= v11)
  {
    v14 = (_QWORD *)a1[1];
    v15 = v12 - v14;
    v16 = v15 + 1;
    if ((unint64_t)(v15 + 1) >> 61)
      std::vector<CADeprecated::XMachServer::Client *>::__throw_length_error[abi:ne180100]();
    v17 = v11 - (_QWORD)v14;
    if (v17 >> 2 > v16)
      v16 = v17 >> 2;
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8)
      v18 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v18 = v16;
    if (v18)
    {
      if (v18 >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v19 = (char *)operator new(8 * v18);
    }
    else
    {
      v19 = 0;
    }
    v20 = &v19[8 * v15];
    *(_QWORD *)v20 = v7;
    v13 = v20 + 8;
    if (v12 != v14)
    {
      do
      {
        v21 = *--v12;
        *((_QWORD *)v20 - 1) = v21;
        v20 -= 8;
      }
      while (v12 != v14);
      v12 = (_QWORD *)a1[1];
    }
    a1[1] = v20;
    a1[2] = v13;
    a1[3] = &v19[8 * v18];
    if (v12)
      operator delete(v12);
  }
  else
  {
    *v12 = v8;
    v13 = v12 + 1;
  }
  a1[2] = v13;
LABEL_25:
  v22 = *(_DWORD *)(a3 + 4);
  if (v22)
  {
    v23 = 0;
    v24 = a3 + 8;
    do
    {
      v25 = *(unsigned int *)(v24 + 8);
      if ((_DWORD)v25)
      {
        v26 = (unsigned int *)(v24 + 12);
        v27 = v24 + 12 + 4 * v25;
        do
        {
          v28 = *v26;
          v29 = v28 >> 28;
          if (*v26 >> 28 == 4)
          {
            v30 = *((unsigned __int16 *)v26 + 3);
          }
          else if ((_DWORD)v29 == 2)
          {
            v30 = *v26 & 0x7F;
          }
          else
          {
            v30 = 0;
          }
          v31 = (v28 >> 20) & 0xF;
          v32 = WORD1(v28) & 0xF;
          if (v31 == 8 || (v31 == 9 ? (v33 = v30 == 0) : (v33 = 0), v33))
          {
            v34 = 1 << (BYTE1(v28) & 7);
            v35 = (uint64_t)&v7[5 * v32] + ((v28 >> 11) & 0xF);
            *(_BYTE *)(v35 + 4) |= v34;
          }
          else if (v31 == 14)
          {
            BYTE1(v7[5 * v32 + 5]) = 1;
          }
          else if ((*v26 & 0x7F00) == 0x4000 && v31 == 11)
          {
            LOBYTE(v7[5 * v32 + 5]) = 1;
          }
          v26 += MIDI::UniversalPacket::word_sizes[v29];
        }
        while ((unint64_t)v26 < v27);
        v36 = *(unsigned int *)(v24 + 8);
        v22 = *(_DWORD *)(a3 + 4);
      }
      else
      {
        v36 = 0;
      }
      v24 += 4 * v36 + 12;
      ++v23;
    }
    while (v23 < v22);
  }
}

void Scheduler::FlushEndpoint(Scheduler *this, int a2)
{
  char *v4;
  int v5;
  char *v6;
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  _QWORD *v11;
  char *v12;
  BOOL v13;
  uint64_t v14;
  _QWORD v15[5];

  v4 = (char *)this + 24;
  v5 = (*(uint64_t (**)(char *))(*((_QWORD *)this + 3) + 16))((char *)this + 24);
  v15[0] = &off_1E98B9460;
  memset(&v15[1], 0, 24);
  v15[4] = this;
  v6 = (char *)this + 128;
  v9 = (char *)*((_QWORD *)this + 15);
  v7 = (_QWORD *)((char *)this + 120);
  v8 = (uint64_t)v9;
  if (v9 != v6)
  {
    do
    {
      v10 = *(char **)(v8 + 8);
      v11 = (_QWORD *)v8;
      if (v10)
      {
        do
        {
          v12 = v10;
          v10 = *(char **)v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          v12 = (char *)v11[2];
          v13 = *(_QWORD *)v12 == (_QWORD)v11;
          v11 = v12;
        }
        while (!v13);
      }
      if (*(_DWORD *)(v8 + 56) == a2)
      {
        FlushManagerBase::InspectEvent(v15, a2, *(_QWORD *)(v8 + 64));
        v14 = BaseOpaqueObject::ResolveOpaqueRef((uint64_t)&TOpaqueRTTI<MIDIEndpoint>::sRTTI, *(_DWORD *)(v8 + 56));
        if (v14)
          --*(_DWORD *)(v14 + 92);
        std::__tree<std::__value_type<unsigned long long,ScheduledEvent>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,ScheduledEvent>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,ScheduledEvent>>>::erase(v7, v8);
      }
      v8 = (uint64_t)v12;
    }
    while (v12 != v6);
  }
  FlushManager::~FlushManager((FlushManager *)v15);
  if (v5)
    (*(void (**)(char *))(*(_QWORD *)v4 + 24))(v4);
}

void sub_1D4EFC180(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  int v3;
  va_list va;

  va_start(va, a2);
  FlushManager::~FlushManager((FlushManager *)va);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  _Unwind_Resume(a1);
}

void sub_1D4EFC228(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1D4EFC334(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1D4EFC3BC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1D4EFC4EC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1D4EFCA70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,FILE *a47,void *a48)
{
  void *v48;

  if (a19 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void XPCClient::~XPCClient(XPCClient *this)
{
  JUMPOUT(0x1D826BA98);
}

uint64_t XPCClient::MIDIClientCreateWithBlock(XPCClient *this, CFTypeRef cf, unsigned int *a3)
{
  MIDIProcess *v5;
  uint64_t *v6;
  uint64_t v7;
  void **v8;
  const swix::encode_message *v9;
  uint64_t v10;
  uint64_t v11;
  void *exception;
  xpc_object_t value;
  void *__p[2];
  char v16;
  CFTypeRef cfa;
  xpc_object_t object;
  int v19;
  xpc_object_t v20;

  if (!cf)
  {
    cfa = 0;
LABEL_20:
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  CFRetain(cf);
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cfa, cf);
  if (!cfa)
    goto LABEL_20;
  applesauce::CF::convert_to<std::string,0>((uint64_t)__p, (const __CFString *)cfa);
  v5 = (MIDIProcess *)cfa;
  if (cfa)
    CFRelease(cfa);
  v6 = MIDIProcess::defaultInstance(v5);
  v7 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v6 + 8))(v6) + 432);
  if (v16 >= 0)
    v8 = __p;
  else
    v8 = (void **)__p[0];
  swix::string::string((swix::string *)&value, (const char *)v8);
  swix::encode_message::encode_message((swix::encode_message *)&v19, 220460582);
  xpc_dictionary_set_value(v20, "name", value);
  v9 = *(const swix::encode_message **)(v7 + 8);
  if (!v9)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)&cfa, v9, &v19);
  v10 = swix::coder<int>::decode(object, ".error");
  if ((_DWORD)v10)
  {
    v11 = 0;
  }
  else
  {
    v10 = swix::coder<unsigned int>::decode(object, "client");
    v11 = 0x100000000;
  }
  xpc_release(object);
  xpc_release(v20);
  xpc_release(value);
  if ((v11 & 0x100000000) != 0 || !(_DWORD)v10)
  {
    *a3 = v10;
    v10 = 0;
  }
  if (v16 < 0)
    operator delete(__p[0]);
  return v10;
}

void sub_1D4EFCDC8(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t object)
{
  xpc_release(object);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EFCD44);
}

void sub_1D4EFCE2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

unint64_t XPCClient::MIDIClientDispose(XPCClient *this, unsigned int a2)
{
  uint64_t *v3;
  uint64_t v4;
  const swix::encode_message *v5;
  unsigned int v6;
  unint64_t v7;
  _BYTE v9[8];
  xpc_object_t object;
  int v11;
  xpc_object_t xdict;

  v3 = MIDIProcess::defaultInstance(this);
  v4 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v3 + 8))(v3) + 432);
  swix::encode_message::encode_message((swix::encode_message *)&v11, 220460583);
  xpc_dictionary_set_uint64(xdict, "client", a2);
  v5 = *(const swix::encode_message **)(v4 + 8);
  if (!v5)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)v9, v5, &v11);
  v6 = swix::coder<int>::decode(object, ".error");
  xpc_release(object);
  v7 = (unint64_t)(v6 == 0) << 32;
  xpc_release(xdict);
  if ((v7 | v6) >= 0x100000000)
    return 0x100000000;
  else
    return v7 | v6;
}

void sub_1D4EFCF34(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object)
{
  xpc_release(object);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EFCEFCLL);
}

uint64_t XPCClient::MIDIOutputPortCreate(XPCClient *this, unsigned int a2, CFTypeRef cf, unsigned int *a4)
{
  MIDIProcess *v7;
  uint64_t *v8;
  uint64_t v9;
  void **v10;
  const swix::encode_message *v11;
  uint64_t v12;
  uint64_t v13;
  void *exception;
  xpc_object_t value;
  void *__p[2];
  char v18;
  CFTypeRef cfa;
  xpc_object_t object;
  int v21;
  xpc_object_t v22;

  if (!cf)
  {
    cfa = 0;
LABEL_20:
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  CFRetain(cf);
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cfa, cf);
  if (!cfa)
    goto LABEL_20;
  applesauce::CF::convert_to<std::string,0>((uint64_t)__p, (const __CFString *)cfa);
  v7 = (MIDIProcess *)cfa;
  if (cfa)
    CFRelease(cfa);
  v8 = MIDIProcess::defaultInstance(v7);
  v9 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v8 + 8))(v8) + 432);
  if (v18 >= 0)
    v10 = __p;
  else
    v10 = (void **)__p[0];
  swix::string::string((swix::string *)&value, (const char *)v10);
  swix::encode_message::encode_message((swix::encode_message *)&v21, 220460590);
  xpc_dictionary_set_uint64(v22, "client", a2);
  xpc_dictionary_set_value(v22, "name", value);
  v11 = *(const swix::encode_message **)(v9 + 8);
  if (!v11)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)&cfa, v11, &v21);
  v12 = swix::coder<int>::decode(object, ".error");
  if ((_DWORD)v12)
  {
    v13 = 0;
  }
  else
  {
    v12 = swix::coder<unsigned int>::decode(object, "portRef");
    v13 = 0x100000000;
  }
  xpc_release(object);
  xpc_release(v22);
  xpc_release(value);
  if ((v13 & 0x100000000) != 0 || !(_DWORD)v12)
  {
    *a4 = v12;
    v12 = 0;
  }
  if (v18 < 0)
    operator delete(__p[0]);
  return v12;
}

void sub_1D4EFD11C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t object)
{
  xpc_release(object);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EFD098);
}

void sub_1D4EFD180(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

unint64_t XPCClient::MIDIPortDispose(XPCClient *this, unsigned int a2)
{
  uint64_t *v3;
  uint64_t v4;
  const swix::encode_message *v5;
  unsigned int v6;
  unint64_t v7;
  _BYTE v9[8];
  xpc_object_t object;
  int v11;
  xpc_object_t xdict;

  v3 = MIDIProcess::defaultInstance(this);
  v4 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v3 + 8))(v3) + 432);
  swix::encode_message::encode_message((swix::encode_message *)&v11, 220460591);
  xpc_dictionary_set_uint64(xdict, "portRef", a2);
  v5 = *(const swix::encode_message **)(v4 + 8);
  if (!v5)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)v9, v5, &v11);
  v6 = swix::coder<int>::decode(object, ".error");
  xpc_release(object);
  v7 = (unint64_t)(v6 == 0) << 32;
  xpc_release(xdict);
  if ((v7 | v6) >= 0x100000000)
    return 0x100000000;
  else
    return v7 | v6;
}

void sub_1D4EFD288(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object)
{
  xpc_release(object);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EFD250);
}

unint64_t XPCClient::MIDIPortConnectSource(XPCClient *this, unsigned int a2, unsigned int a3, void *a4)
{
  uint64_t *v7;
  uint64_t v8;
  const swix::encode_message *v9;
  unsigned int v10;
  unint64_t v11;
  uint64_t v13;
  xpc_object_t object;
  int v15;
  xpc_object_t xdict;
  void *bytes;

  v7 = MIDIProcess::defaultInstance(this);
  v8 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v7 + 8))(v7) + 432);
  bytes = a4;
  swix::encode_message::encode_message((swix::encode_message *)&v15, 220460592);
  xpc_dictionary_set_uint64(xdict, "port", a2);
  xpc_dictionary_set_uint64(xdict, "source", a3);
  xpc_dictionary_set_data(xdict, "connRefCon", &bytes, 8uLL);
  v9 = *(const swix::encode_message **)(v8 + 8);
  if (!v9)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)&v13, v9, &v15);
  v10 = swix::coder<int>::decode(object, ".error");
  xpc_release(object);
  v11 = (unint64_t)(v10 == 0) << 32;
  xpc_release(xdict);
  if ((v11 | v10) >= 0x100000000)
    return 0x100000000;
  else
    return v11 | v10;
}

void sub_1D4EFD3DC(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object)
{
  xpc_release(object);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EFD3A0);
}

unint64_t XPCClient::MIDIPortDisconnectSource(XPCClient *this, unsigned int a2, unsigned int a3)
{
  uint64_t *v5;
  uint64_t v6;
  const swix::encode_message *v7;
  unsigned int v8;
  unint64_t v9;
  _BYTE v11[8];
  xpc_object_t object;
  int v13;
  xpc_object_t xdict;

  v5 = MIDIProcess::defaultInstance(this);
  v6 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v5 + 8))(v5) + 432);
  swix::encode_message::encode_message((swix::encode_message *)&v13, 220460593);
  xpc_dictionary_set_uint64(xdict, "port", a2);
  xpc_dictionary_set_uint64(xdict, "source", a3);
  v7 = *(const swix::encode_message **)(v6 + 8);
  if (!v7)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)v11, v7, &v13);
  v8 = swix::coder<int>::decode(object, ".error");
  xpc_release(object);
  v9 = (unint64_t)(v8 == 0) << 32;
  xpc_release(xdict);
  if ((v9 | v8) >= 0x100000000)
    return 0x100000000;
  else
    return v9 | v8;
}

void sub_1D4EFD510(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object)
{
  xpc_release(object);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EFD4D4);
}

uint64_t XPCClient::MIDISourceCreateWithProtocol(XPCClient *this, unsigned int a2, CFTypeRef cf, MIDIProtocolID a4, unsigned int *a5)
{
  MIDIProcess *v9;
  uint64_t *v10;
  uint64_t v11;
  void **v12;
  const swix::encode_message *v13;
  uint64_t v14;
  uint64_t v15;
  void *exception;
  xpc_object_t value;
  void *__p[2];
  char v20;
  CFTypeRef cfa;
  xpc_object_t object;
  int v23;
  xpc_object_t v24;

  if (!cf)
  {
    cfa = 0;
LABEL_20:
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  CFRetain(cf);
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cfa, cf);
  if (!cfa)
    goto LABEL_20;
  applesauce::CF::convert_to<std::string,0>((uint64_t)__p, (const __CFString *)cfa);
  v9 = (MIDIProcess *)cfa;
  if (cfa)
    CFRelease(cfa);
  v10 = MIDIProcess::defaultInstance(v9);
  v11 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v10 + 8))(v10) + 432);
  if (v20 >= 0)
    v12 = __p;
  else
    v12 = (void **)__p[0];
  swix::string::string((swix::string *)&value, (const char *)v12);
  swix::encode_message::encode_message((swix::encode_message *)&v23, 220460586);
  xpc_dictionary_set_uint64(v24, "client", a2);
  xpc_dictionary_set_value(v24, "name", value);
  xpc_dictionary_set_int64(v24, "proto", a4);
  v13 = *(const swix::encode_message **)(v11 + 8);
  if (!v13)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)&cfa, v13, &v23);
  v14 = swix::coder<int>::decode(object, ".error");
  if ((_DWORD)v14)
  {
    v15 = 0;
  }
  else
  {
    v14 = swix::coder<unsigned int>::decode(object, "sourceRef");
    v15 = 0x100000000;
  }
  xpc_release(object);
  xpc_release(v24);
  xpc_release(value);
  if ((v15 & 0x100000000) != 0 || !(_DWORD)v14)
  {
    *a5 = v14;
    v14 = 0;
  }
  if (v20 < 0)
    operator delete(__p[0]);
  return v14;
}

void sub_1D4EFD710(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t object)
{
  xpc_release(object);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EFD68CLL);
}

void sub_1D4EFD774(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

unint64_t XPCClient::MIDIEndpointDispose(XPCClient *this, unsigned int a2)
{
  uint64_t *v3;
  uint64_t v4;
  const swix::encode_message *v5;
  unsigned int v6;
  unint64_t v7;
  _BYTE v9[8];
  xpc_object_t object;
  int v11;
  xpc_object_t xdict;

  v3 = MIDIProcess::defaultInstance(this);
  v4 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v3 + 8))(v3) + 432);
  swix::encode_message::encode_message((swix::encode_message *)&v11, 220460588);
  xpc_dictionary_set_uint64(xdict, "endpointRef", a2);
  v5 = *(const swix::encode_message **)(v4 + 8);
  if (!v5)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)v9, v5, &v11);
  v6 = swix::coder<int>::decode(object, ".error");
  xpc_release(object);
  v7 = (unint64_t)(v6 == 0) << 32;
  xpc_release(xdict);
  if ((v7 | v6) >= 0x100000000)
    return 0x100000000;
  else
    return v7 | v6;
}

void sub_1D4EFD87C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object)
{
  xpc_release(object);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EFD844);
}

int64_t XPCClient::MIDIObjectGetIntegerProperty(XPCClient *this, unsigned int a2, CFTypeRef cf, int *a4)
{
  MIDIProcess *v7;
  uint64_t *v8;
  uint64_t v9;
  void **v10;
  const swix::encode_message *v11;
  int64_t v12;
  uint64_t v13;
  void *exception;
  xpc_object_t value;
  void *__p[2];
  char v18;
  CFTypeRef cfa;
  xpc_object_t object;
  int v21;
  xpc_object_t v22;

  if (!cf)
  {
    cfa = 0;
LABEL_20:
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  CFRetain(cf);
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cfa, cf);
  if (!cfa)
    goto LABEL_20;
  applesauce::CF::convert_to<std::string,0>((uint64_t)__p, (const __CFString *)cfa);
  v7 = (MIDIProcess *)cfa;
  if (cfa)
    CFRelease(cfa);
  v8 = MIDIProcess::defaultInstance(v7);
  v9 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v8 + 8))(v8) + 432);
  if (v18 >= 0)
    v10 = __p;
  else
    v10 = (void **)__p[0];
  swix::string::string((swix::string *)&value, (const char *)v10);
  swix::encode_message::encode_message((swix::encode_message *)&v21, 220460595);
  xpc_dictionary_set_uint64(v22, "object", a2);
  xpc_dictionary_set_value(v22, "propertyID", value);
  v11 = *(const swix::encode_message **)(v9 + 8);
  if (!v11)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)&cfa, v11, &v21);
  v12 = swix::coder<int>::decode(object, ".error");
  if ((_DWORD)v12)
  {
    v13 = 0;
  }
  else
  {
    v12 = swix::coder<int>::decode(object, "value");
    v13 = 0x100000000;
  }
  xpc_release(object);
  xpc_release(v22);
  xpc_release(value);
  if ((v13 & 0x100000000) != 0 || !(_DWORD)v12)
  {
    *a4 = v12;
    v12 = 0;
  }
  if (v18 < 0)
    operator delete(__p[0]);
  return v12;
}

void sub_1D4EFDA64(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t object)
{
  xpc_release(object);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EFD9E0);
}

void sub_1D4EFDAC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

unint64_t XPCClient::MIDIObjectSetIntegerProperty(XPCClient *this, unsigned int a2, CFTypeRef cf, int a4)
{
  MIDIProcess *v7;
  uint64_t *v8;
  uint64_t v9;
  void **v10;
  const swix::encode_message *v11;
  unsigned int v12;
  unint64_t v13;
  void *exception;
  xpc_object_t value;
  void *__p[2];
  char v18;
  CFTypeRef cfa;
  xpc_object_t object;
  int v21;
  xpc_object_t v22;

  if (!cf)
  {
    cfa = 0;
LABEL_17:
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  CFRetain(cf);
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cfa, cf);
  if (!cfa)
    goto LABEL_17;
  applesauce::CF::convert_to<std::string,0>((uint64_t)__p, (const __CFString *)cfa);
  v7 = (MIDIProcess *)cfa;
  if (cfa)
    CFRelease(cfa);
  v8 = MIDIProcess::defaultInstance(v7);
  v9 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v8 + 8))(v8) + 432);
  if (v18 >= 0)
    v10 = __p;
  else
    v10 = (void **)__p[0];
  swix::string::string((swix::string *)&value, (const char *)v10);
  swix::encode_message::encode_message((swix::encode_message *)&v21, 220460594);
  xpc_dictionary_set_uint64(v22, "object", a2);
  xpc_dictionary_set_value(v22, "propertyID", value);
  xpc_dictionary_set_int64(v22, "value", a4);
  v11 = *(const swix::encode_message **)(v9 + 8);
  if (!v11)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)&cfa, v11, &v21);
  v12 = swix::coder<int>::decode(object, ".error");
  xpc_release(object);
  v13 = (unint64_t)(v12 == 0) << 32;
  xpc_release(v22);
  xpc_release(value);
  if (v18 < 0)
    operator delete(__p[0]);
  if ((v13 | v12) >= 0x100000000)
    return 0x100000000;
  else
    return v13 | v12;
}

void sub_1D4EFDCB0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t object)
{
  xpc_release(object);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EFDC1CLL);
}

void sub_1D4EFDD00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

unint64_t XPCClient::MIDIObjectGetStringProperty(XPCClient *this, unsigned int a2, CFTypeRef cf, const __CFString **a4)
{
  MIDIProcess *v7;
  uint64_t *v8;
  uint64_t v9;
  void **v10;
  const swix::encode_message *v11;
  unsigned int v12;
  int v13;
  unint64_t v14;
  xpc_object_t v15;
  xpc_object_t v16;
  xpc_object_t v17;
  char *string_ptr;
  const UInt8 *p_cfa;
  CFIndex v20;
  const __CFString *v21;
  void *exception;
  void *v24;
  xpc_object_t value;
  void *__p[2];
  char v27;
  xpc_object_t v28;
  CFTypeRef cfa;
  xpc_object_t object;
  unsigned __int8 v31;
  int v32;
  xpc_object_t v33;

  if (!cf)
  {
    cfa = 0;
LABEL_34:
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  CFRetain(cf);
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cfa, cf);
  if (!cfa)
    goto LABEL_34;
  applesauce::CF::convert_to<std::string,0>((uint64_t)__p, (const __CFString *)cfa);
  v7 = (MIDIProcess *)cfa;
  if (cfa)
    CFRelease(cfa);
  v8 = MIDIProcess::defaultInstance(v7);
  v9 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v8 + 8))(v8) + 432);
  if (v27 >= 0)
    v10 = __p;
  else
    v10 = (void **)__p[0];
  swix::string::string((swix::string *)&value, (const char *)v10);
  swix::encode_message::encode_message((swix::encode_message *)&v32, 220460597);
  xpc_dictionary_set_uint64(v33, "object", a2);
  xpc_dictionary_set_value(v33, "propertyID", value);
  v11 = *(const swix::encode_message **)(v9 + 8);
  if (!v11)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)&cfa, v11, &v32);
  v12 = swix::coder<int>::decode(object, ".error");
  if (v12)
  {
    v13 = 0;
    v14 = v12;
  }
  else
  {
    v15 = xpc_null_create();
    swix::xpcobj_coder<swix::string>::decode(&v28, object, "value");
    v16 = v28;
    v17 = xpc_null_create();
    v28 = v17;
    xpc_release(v15);
    xpc_release(v17);
    if (v16)
    {
      xpc_retain(v16);
      v14 = (unint64_t)v16;
    }
    else
    {
      v14 = (unint64_t)xpc_null_create();
    }
    xpc_release(v16);
    v13 = 1;
  }
  xpc_release(object);
  xpc_release(v33);
  xpc_release(value);
  if (v13 || !(_DWORD)v14)
  {
    string_ptr = (char *)xpc_string_get_string_ptr((xpc_object_t)v14);
    std::string::basic_string[abi:ne180100]<0>(&cfa, string_ptr);
    if ((v31 & 0x80u) == 0)
      p_cfa = (const UInt8 *)&cfa;
    else
      p_cfa = (const UInt8 *)cfa;
    if ((v31 & 0x80u) == 0)
      v20 = v31;
    else
      v20 = (CFIndex)object;
    v21 = CFStringCreateWithBytes(0, p_cfa, v20, 0x8000100u, 0);
    if (!v21)
    {
      v24 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x1D826B7EC](v24, "Could not construct");
    }
    if ((char)v31 < 0)
      operator delete((void *)cfa);
    *a4 = v21;
    if (v13)
      xpc_release((xpc_object_t)v14);
    v14 = 0;
  }
  if (v27 < 0)
    operator delete(__p[0]);
  return v14;
}

void sub_1D4EFDFC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *__p, xpc_object_t object, int a19, __int16 a20,char a21,char a22)
{
  void *v22;
  int v23;

  if (a22 < 0)
    operator delete(__p);
  if (v23)
    xpc_release(v22);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

unint64_t XPCClient::MIDIObjectSetStringProperty(XPCClient *this, unsigned int a2, CFTypeRef cf, const __CFString *a4)
{
  MIDIProcess *v7;
  uint64_t *v8;
  uint64_t v9;
  void **v10;
  void **v11;
  const swix::encode_message *v12;
  unsigned int v13;
  unint64_t v14;
  void *exception;
  void *v17;
  xpc_object_t v18;
  xpc_object_t value;
  void *__p[2];
  char v21;
  void *v22[2];
  char v23;
  CFTypeRef cfa;
  xpc_object_t object;
  int v26;
  xpc_object_t v27;

  if (!cf)
  {
    cfa = 0;
LABEL_27:
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  CFRetain(cf);
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cfa, cf);
  if (!cfa)
    goto LABEL_27;
  applesauce::CF::convert_to<std::string,0>((uint64_t)v22, (const __CFString *)cfa);
  if (cfa)
    CFRelease(cfa);
  if (a4)
    CFRetain(a4);
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cfa, a4);
  if (!cfa)
  {
    v17 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v17, "Could not construct");
  }
  applesauce::CF::convert_to<std::string,0>((uint64_t)__p, (const __CFString *)cfa);
  v7 = (MIDIProcess *)cfa;
  if (cfa)
    CFRelease(cfa);
  v8 = MIDIProcess::defaultInstance(v7);
  v9 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v8 + 8))(v8) + 432);
  if (v23 >= 0)
    v10 = v22;
  else
    v10 = (void **)v22[0];
  swix::string::string((swix::string *)&value, (const char *)v10);
  if (v21 >= 0)
    v11 = __p;
  else
    v11 = (void **)__p[0];
  swix::string::string((swix::string *)&v18, (const char *)v11);
  swix::encode_message::encode_message((swix::encode_message *)&v26, 220460596);
  xpc_dictionary_set_uint64(v27, "object", a2);
  xpc_dictionary_set_value(v27, "propertyID", value);
  xpc_dictionary_set_value(v27, "value", v18);
  v12 = *(const swix::encode_message **)(v9 + 8);
  if (!v12)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)&cfa, v12, &v26);
  v13 = swix::coder<int>::decode(object, ".error");
  xpc_release(object);
  v14 = (unint64_t)(v13 == 0) << 32;
  xpc_release(v27);
  xpc_release(v18);
  xpc_release(value);
  if (v21 < 0)
    operator delete(__p[0]);
  if (v23 < 0)
    operator delete(v22[0]);
  if ((v14 | v13) >= 0x100000000)
    return 0x100000000;
  else
    return v14 | v13;
}

void sub_1D4EFE310(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,const void *a24,xpc_object_t object)
{
  void *v25;

  __cxa_free_exception(v25);
  applesauce::CF::StringRef::~StringRef(&a24);
  if (a23 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t XPCClient::MIDIObjectGetDataProperty(XPCClient *this, unsigned int a2, CFTypeRef cf, CFTypeRef *a4)
{
  MIDIProcess *v7;
  uint64_t *v8;
  uint64_t v9;
  void **v10;
  const swix::encode_message *v11;
  int v12;
  xpc_object_t v13;
  xpc_object_t v14;
  xpc_object_t v15;
  uint64_t v16;
  xpc_object_t v17;
  const UInt8 *bytes_ptr;
  size_t length;
  CFDataRef v20;
  void *exception;
  void *v23;
  xpc_object_t value;
  xpc_object_t v25;
  char v26;
  void *__p[2];
  char v28;
  xpc_object_t v29;
  CFTypeRef cfa;
  xpc_object_t object;
  int v32;
  xpc_object_t v33;

  if (!cf)
  {
    cfa = 0;
LABEL_26:
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  CFRetain(cf);
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cfa, cf);
  if (!cfa)
    goto LABEL_26;
  applesauce::CF::convert_to<std::string,0>((uint64_t)__p, (const __CFString *)cfa);
  v7 = (MIDIProcess *)cfa;
  if (cfa)
    CFRelease(cfa);
  v8 = MIDIProcess::defaultInstance(v7);
  v9 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v8 + 8))(v8) + 432);
  if (v28 >= 0)
    v10 = __p;
  else
    v10 = (void **)__p[0];
  swix::string::string((swix::string *)&value, (const char *)v10);
  swix::encode_message::encode_message((swix::encode_message *)&v32, 220460599);
  xpc_dictionary_set_uint64(v33, "object", a2);
  xpc_dictionary_set_value(v33, "propertyID", value);
  v11 = *(const swix::encode_message **)(v9 + 8);
  if (!v11)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)&cfa, v11, &v32);
  v12 = swix::coder<int>::decode(object, ".error");
  if (v12)
  {
    LODWORD(v25) = v12;
    v26 = 0;
  }
  else
  {
    v13 = xpc_null_create();
    swix::xpcobj_coder<swix::data>::decode(&v29, object, "value");
    v14 = v29;
    v15 = xpc_null_create();
    v29 = v15;
    xpc_release(v13);
    xpc_release(v15);
    std::__tuple_leaf<0ul,swix::data,false>::__tuple_leaf[abi:ne180100](&v25, v14);
    v26 = 1;
    xpc_release(v14);
  }
  xpc_release(object);
  xpc_release(v33);
  xpc_release(value);
  if (v26 || (v16 = v25, !(_DWORD)v25))
  {
    v17 = v25;
    if (v25)
      xpc_retain(v25);
    else
      v17 = xpc_null_create();
    bytes_ptr = (const UInt8 *)xpc_data_get_bytes_ptr(v17);
    length = xpc_data_get_length(v17);
    v20 = CFDataCreate(0, bytes_ptr, length);
    if (!v20)
    {
      v23 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x1D826B7EC](v23, "Could not construct");
    }
    applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)&cfa, v20);
    *a4 = cfa;
    xpc_release(v17);
    if (v26)
      xpc_release(v25);
    v16 = 0;
  }
  if (v28 < 0)
    operator delete(__p[0]);
  return v16;
}

void sub_1D4EFE68C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, char a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, char a19, xpc_object_t a20)
{
  void *v20;
  void *v21;

  __cxa_free_exception(v21);
  xpc_release(v20);
  if (a11)
    xpc_release(object);
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

unint64_t XPCClient::MIDIObjectSetDataProperty(XPCClient *this, unsigned int a2, CFTypeRef cf, const __CFData *a4)
{
  const UInt8 *BytePtr;
  size_t Length;
  MIDIProcess *v9;
  uint64_t *v10;
  uint64_t v11;
  void **v12;
  const swix::encode_message *v13;
  unsigned int v14;
  unint64_t v15;
  void *exception;
  xpc_object_t value;
  xpc_object_t v19;
  void *__p[2];
  char v21;
  CFTypeRef cfa;
  xpc_object_t object;
  int v24;
  xpc_object_t v25;

  if (!cf)
  {
    cfa = 0;
LABEL_17:
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  CFRetain(cf);
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cfa, cf);
  if (!cfa)
    goto LABEL_17;
  applesauce::CF::convert_to<std::string,0>((uint64_t)__p, (const __CFString *)cfa);
  if (cfa)
    CFRelease(cfa);
  BytePtr = CFDataGetBytePtr(a4);
  Length = CFDataGetLength(a4);
  v9 = swix::data::data((swix::data *)&v19, BytePtr, Length);
  v10 = MIDIProcess::defaultInstance(v9);
  v11 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v10 + 8))(v10) + 432);
  if (v21 >= 0)
    v12 = __p;
  else
    v12 = (void **)__p[0];
  swix::string::string((swix::string *)&value, (const char *)v12);
  swix::encode_message::encode_message((swix::encode_message *)&v24, 220460598);
  xpc_dictionary_set_uint64(v25, "object", a2);
  xpc_dictionary_set_value(v25, "propertyID", value);
  xpc_dictionary_set_value(v25, "value", v19);
  v13 = *(const swix::encode_message **)(v11 + 8);
  if (!v13)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)&cfa, v13, &v24);
  v14 = swix::coder<int>::decode(object, ".error");
  xpc_release(object);
  v15 = (unint64_t)(v14 == 0) << 32;
  xpc_release(v25);
  xpc_release(value);
  xpc_release(v19);
  if (v21 < 0)
    operator delete(__p[0]);
  if ((v15 | v14) >= 0x100000000)
    return 0x100000000;
  else
    return v15 | v14;
}

void sub_1D4EFE974(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t object)
{
  xpc_release(object);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EFE8D4);
}

void sub_1D4EFE9C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  xpc_release(object);
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t XPCClient::MIDIObjectGetDictionaryProperty(XPCClient *this, unsigned int a2, CFTypeRef cf, const __CFDictionary **a4)
{
  MIDIProcess *v7;
  uint64_t *v8;
  uint64_t v9;
  void **v10;
  const swix::encode_message *v11;
  int v12;
  xpc_object_t v13;
  xpc_object_t v14;
  xpc_object_t v15;
  uint64_t v16;
  xpc_object_t v17;
  const UInt8 *bytes_ptr;
  size_t length;
  CFDataRef v20;
  void *exception;
  void *v23;
  xpc_object_t value;
  xpc_object_t v25;
  char v26;
  void *__p[2];
  char v28;
  xpc_object_t v29;
  CFTypeRef cfa;
  xpc_object_t object;
  const __CFDictionary *v32;
  xpc_object_t v33;

  if (!cf)
  {
    cfa = 0;
LABEL_28:
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  CFRetain(cf);
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cfa, cf);
  if (!cfa)
    goto LABEL_28;
  applesauce::CF::convert_to<std::string,0>((uint64_t)__p, (const __CFString *)cfa);
  v7 = (MIDIProcess *)cfa;
  if (cfa)
    CFRelease(cfa);
  v8 = MIDIProcess::defaultInstance(v7);
  v9 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v8 + 8))(v8) + 432);
  if (v28 >= 0)
    v10 = __p;
  else
    v10 = (void **)__p[0];
  swix::string::string((swix::string *)&value, (const char *)v10);
  swix::encode_message::encode_message((swix::encode_message *)&v32, 220460601);
  xpc_dictionary_set_uint64(v33, "object", a2);
  xpc_dictionary_set_value(v33, "propertyID", value);
  v11 = *(const swix::encode_message **)(v9 + 8);
  if (!v11)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)&cfa, v11, (int *)&v32);
  v12 = swix::coder<int>::decode(object, ".error");
  if (v12)
  {
    LODWORD(v25) = v12;
    v26 = 0;
  }
  else
  {
    v13 = xpc_null_create();
    swix::xpcobj_coder<swix::data>::decode(&v29, object, "value");
    v14 = v29;
    v15 = xpc_null_create();
    v29 = v15;
    xpc_release(v13);
    xpc_release(v15);
    std::__tuple_leaf<0ul,swix::data,false>::__tuple_leaf[abi:ne180100](&v25, v14);
    v26 = 1;
    xpc_release(v14);
  }
  xpc_release(object);
  xpc_release(v33);
  xpc_release(value);
  if (v26 || (v16 = v25, !(_DWORD)v25))
  {
    v17 = v25;
    if (v25)
      xpc_retain(v25);
    else
      v17 = xpc_null_create();
    bytes_ptr = (const UInt8 *)xpc_data_get_bytes_ptr(v17);
    length = xpc_data_get_length(v17);
    v20 = CFDataCreate(0, bytes_ptr, length);
    if (!v20)
    {
      v23 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x1D826B7EC](v23, "Could not construct");
    }
    applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)&cfa, v20);
    applesauce::CF::make_DictionaryRef((applesauce::CF *)&v32, (const applesauce::CF::DataRef *)cfa);
    *a4 = v32;
    if (cfa)
      CFRelease(cfa);
    xpc_release(v17);
    if (v26)
      xpc_release(v25);
    v16 = 0;
  }
  if (v28 < 0)
    operator delete(__p[0]);
  return v16;
}

void sub_1D4EFECB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, char a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, char a19, xpc_object_t a20)
{
  void *v20;
  void *v21;

  __cxa_free_exception(v21);
  xpc_release(v20);
  if (a11)
    xpc_release(object);
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

unint64_t XPCClient::MIDIObjectSetDictionaryProperty(XPCClient *this, unsigned int a2, CFTypeRef cf, const __CFDictionary *a4)
{
  CFDataRef Data;
  const UInt8 *BytePtr;
  size_t Length;
  MIDIProcess *v10;
  uint64_t *v11;
  uint64_t v12;
  void **v13;
  const swix::encode_message *v14;
  unsigned int v15;
  unint64_t v16;
  void *exception;
  void *v19;
  void *v20;
  xpc_object_t value;
  xpc_object_t v22;
  CFDataRef theData;
  void *__p[2];
  char v25;
  CFTypeRef cfa;
  xpc_object_t object;
  int v28;
  xpc_object_t v29;

  if (!cf)
  {
    cfa = 0;
LABEL_21:
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  CFRetain(cf);
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cfa, cf);
  if (!cfa)
    goto LABEL_21;
  applesauce::CF::convert_to<std::string,0>((uint64_t)__p, (const __CFString *)cfa);
  if (cfa)
    CFRelease(cfa);
  Data = CFPropertyListCreateData(0, a4, kCFPropertyListBinaryFormat_v1_0, 0, 0);
  applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)&theData, Data);
  if (!theData)
  {
    v19 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v19, "Could not construct");
  }
  BytePtr = CFDataGetBytePtr(theData);
  if (!theData)
  {
    v20 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v20, "Could not construct");
  }
  Length = CFDataGetLength(theData);
  v10 = swix::data::data((swix::data *)&v22, BytePtr, Length);
  v11 = MIDIProcess::defaultInstance(v10);
  v12 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v11 + 8))(v11) + 432);
  if (v25 >= 0)
    v13 = __p;
  else
    v13 = (void **)__p[0];
  swix::string::string((swix::string *)&value, (const char *)v13);
  swix::encode_message::encode_message((swix::encode_message *)&v28, 220460600);
  xpc_dictionary_set_uint64(v29, "object", a2);
  xpc_dictionary_set_value(v29, "propertyID", value);
  xpc_dictionary_set_value(v29, "value", v22);
  v14 = *(const swix::encode_message **)(v12 + 8);
  if (!v14)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)&cfa, v14, &v28);
  v15 = swix::coder<int>::decode(object, ".error");
  xpc_release(object);
  v16 = (unint64_t)(v15 == 0) << 32;
  xpc_release(v29);
  xpc_release(value);
  xpc_release(v22);
  if (theData)
    CFRelease(theData);
  if (v25 < 0)
    operator delete(__p[0]);
  if ((v16 | v15) >= 0x100000000)
    return 0x100000000;
  else
    return v16 | v15;
}

void sub_1D4EFF03C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t a11, const void *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, xpc_object_t object)
{
  void *v20;

  __cxa_free_exception(v20);
  applesauce::CF::DataRef::~DataRef(&a12);
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t XPCClient::MIDIObjectGetProperties(XPCClient *this, unsigned int a2, const void **a3, int a4)
{
  uint64_t *v7;
  uint64_t v8;
  const swix::encode_message *v9;
  int v10;
  xpc_object_t v11;
  xpc_object_t v12;
  xpc_object_t v13;
  uint64_t result;
  xpc_object_t v15;
  const UInt8 *bytes_ptr;
  size_t length;
  CFDataRef v18;
  void *exception;
  xpc_object_t v20;
  char v21;
  xpc_object_t v22;
  CFDataRef data;
  xpc_object_t object;
  int v25;
  xpc_object_t xdict;

  v7 = MIDIProcess::defaultInstance(this);
  v8 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v7 + 8))(v7) + 432);
  swix::encode_message::encode_message((swix::encode_message *)&v25, 220460616);
  xpc_dictionary_set_uint64(xdict, "object", a2);
  xpc_dictionary_set_BOOL(xdict, "deep", a4 != 0);
  v9 = *(const swix::encode_message **)(v8 + 8);
  if (!v9)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)&data, v9, &v25);
  v10 = swix::coder<int>::decode(object, ".error");
  if (v10)
  {
    LODWORD(v20) = v10;
    v21 = 0;
  }
  else
  {
    v11 = xpc_null_create();
    swix::xpcobj_coder<swix::data>::decode(&v22, object, "properties");
    v12 = v22;
    v13 = xpc_null_create();
    v22 = v13;
    xpc_release(v11);
    xpc_release(v13);
    std::__tuple_leaf<0ul,swix::data,false>::__tuple_leaf[abi:ne180100](&v20, v12);
    v21 = 1;
    xpc_release(v12);
  }
  xpc_release(object);
  xpc_release(xdict);
  if (v21 || (result = v20, !(_DWORD)v20))
  {
    v15 = v20;
    if (v20)
      xpc_retain(v20);
    else
      v15 = xpc_null_create();
    bytes_ptr = (const UInt8 *)xpc_data_get_bytes_ptr(v15);
    length = xpc_data_get_length(v15);
    v18 = CFDataCreate(0, bytes_ptr, length);
    if (!v18)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x1D826B7EC](exception, "Could not construct");
    }
    applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)&data, v18);
    *a3 = CFPropertyListCreateWithData(0, data, 0, 0, 0);
    if (data)
      CFRelease(data);
    xpc_release(v15);
    if (v21)
      xpc_release(v20);
    return 0;
  }
  return result;
}

void sub_1D4EFF330(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, char a10, uint64_t a11, char a12, xpc_object_t a13)
{
  void *v13;
  void *v14;

  __cxa_free_exception(v14);
  xpc_release(v13);
  if (a10)
    xpc_release(object);
  _Unwind_Resume(a1);
}

unint64_t XPCClient::MIDIObjectRemoveProperty(XPCClient *this, unsigned int a2, CFTypeRef cf)
{
  MIDIProcess *v5;
  uint64_t *v6;
  uint64_t v7;
  void **v8;
  const swix::encode_message *v9;
  unsigned int v10;
  unint64_t v11;
  void *exception;
  xpc_object_t value;
  void *__p[2];
  char v16;
  CFTypeRef cfa;
  xpc_object_t object;
  int v19;
  xpc_object_t v20;

  if (!cf)
  {
    cfa = 0;
LABEL_17:
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  CFRetain(cf);
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cfa, cf);
  if (!cfa)
    goto LABEL_17;
  applesauce::CF::convert_to<std::string,0>((uint64_t)__p, (const __CFString *)cfa);
  v5 = (MIDIProcess *)cfa;
  if (cfa)
    CFRelease(cfa);
  v6 = MIDIProcess::defaultInstance(v5);
  v7 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v6 + 8))(v6) + 432);
  if (v16 >= 0)
    v8 = __p;
  else
    v8 = (void **)__p[0];
  swix::string::string((swix::string *)&value, (const char *)v8);
  swix::encode_message::encode_message((swix::encode_message *)&v19, 220460602);
  xpc_dictionary_set_uint64(v20, "object", a2);
  xpc_dictionary_set_value(v20, "propertyID", value);
  v9 = *(const swix::encode_message **)(v7 + 8);
  if (!v9)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)&cfa, v9, &v19);
  v10 = swix::coder<int>::decode(object, ".error");
  xpc_release(object);
  v11 = (unint64_t)(v10 == 0) << 32;
  xpc_release(v20);
  xpc_release(value);
  if (v16 < 0)
    operator delete(__p[0]);
  if ((v11 | v10) >= 0x100000000)
    return 0x100000000;
  else
    return v11 | v10;
}

void sub_1D4EFF594(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t object)
{
  xpc_release(object);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EFF504);
}

void sub_1D4EFF5E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t XPCClient::MIDIObjectFindByUniqueID(XPCClient *this, int a2, unsigned int *a3, MIDIObjectType *a4)
{
  uint64_t *v7;
  uint64_t v8;
  const swix::encode_message *v9;
  uint64_t v10;
  MIDIObjectType v11;
  uint64_t v12;
  _BYTE v14[8];
  xpc_object_t object;
  int v16;
  xpc_object_t xdict;

  v7 = MIDIProcess::defaultInstance(this);
  v8 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v7 + 8))(v7) + 432);
  swix::encode_message::encode_message((swix::encode_message *)&v16, 220460623);
  xpc_dictionary_set_int64(xdict, "uniqueID", a2);
  v9 = *(const swix::encode_message **)(v8 + 8);
  if (!v9)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)v14, v9, &v16);
  v10 = swix::coder<int>::decode(object, ".error");
  if ((_DWORD)v10)
  {
    v11 = kMIDIObjectType_Device;
    v12 = 0;
  }
  else
  {
    v10 = swix::coder<unsigned int>::decode(object, "object");
    v11 = swix::coder<int>::decode(object, "objectType");
    v12 = 1;
  }
  xpc_release(object);
  xpc_release(xdict);
  if (v12 || !(_DWORD)v10)
  {
    if (a3)
      *a3 = v10;
    v10 = 0;
    if (a4)
      *a4 = v11;
  }
  return v10;
}

void sub_1D4EFF738(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object)
{
  xpc_release(object);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EFF6F4);
}

unint64_t XPCClient::MIDIFlushOutput(XPCClient *this, unsigned int a2)
{
  uint64_t *v3;
  uint64_t v4;
  const swix::encode_message *v5;
  unsigned int v6;
  unint64_t v7;
  _BYTE v9[8];
  xpc_object_t object;
  int v11;
  xpc_object_t xdict;

  v3 = MIDIProcess::defaultInstance(this);
  v4 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v3 + 8))(v3) + 432);
  swix::encode_message::encode_message((swix::encode_message *)&v11, 220460617);
  xpc_dictionary_set_uint64(xdict, "destination", a2);
  v5 = *(const swix::encode_message **)(v4 + 8);
  if (!v5)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)v9, v5, &v11);
  v6 = swix::coder<int>::decode(object, ".error");
  xpc_release(object);
  v7 = (unint64_t)(v6 == 0) << 32;
  xpc_release(xdict);
  if ((v7 | v6) >= 0x100000000)
    return 0x100000000;
  else
    return v7 | v6;
}

void sub_1D4EFF860(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object)
{
  xpc_release(object);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EFF828);
}

unint64_t XPCClient::MIDIRestart(XPCClient *this)
{
  uint64_t *v1;
  uint64_t v2;
  const swix::encode_message *v3;
  unsigned int v4;
  unint64_t v5;
  _BYTE v7[8];
  xpc_object_t object;
  int v9;
  xpc_object_t v10;

  v1 = MIDIProcess::defaultInstance(this);
  v2 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v1 + 8))(v1) + 432);
  swix::encode_message::encode_message((swix::encode_message *)&v9, 220460615);
  v3 = *(const swix::encode_message **)(v2 + 8);
  if (!v3)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)v7, v3, &v9);
  v4 = swix::coder<int>::decode(object, ".error");
  xpc_release(object);
  v5 = (unint64_t)(v4 == 0) << 32;
  xpc_release(v10);
  if ((v5 | v4) >= 0x100000000)
    return 0x100000000;
  else
    return v5 | v4;
}

void sub_1D4EFF95C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object)
{
  xpc_release(object);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EFF924);
}

uint64_t XPCClient::MIDICapabilityGetDiscoveryMUID(XPCClient *this)
{
  uint64_t *v1;
  uint64_t v2;
  const swix::encode_message *v3;
  unsigned int v4;
  unint64_t v5;
  unint64_t v6;
  BOOL v7;
  uint64_t v8;
  _BYTE v10[8];
  xpc_object_t object;
  int v12;
  xpc_object_t v13;

  v1 = MIDIProcess::defaultInstance(this);
  v2 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v1 + 8))(v1) + 432);
  swix::encode_message::encode_message((swix::encode_message *)&v12, 220460603);
  v3 = *(const swix::encode_message **)(v2 + 8);
  if (!v3)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)v10, v3, &v12);
  v4 = swix::coder<int>::decode(object, ".error");
  if (v4)
  {
    v5 = 0;
  }
  else
  {
    v4 = swix::coder<unsigned int>::decode(object, "muid");
    v5 = 0x100000000;
  }
  xpc_release(object);
  xpc_release(v13);
  v6 = HIDWORD(v5);
  if (!v4)
    LODWORD(v6) = 1;
  v7 = (_DWORD)v6 == 0;
  v8 = 0x100000000;
  if (v7)
    v8 = 0;
  return v8 | v4;
}

void sub_1D4EFFA74(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object)
{
  xpc_release(object);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EFFA38);
}

unint64_t XPCClient::MIDICapabilityMUIDCollides(XPCClient *this, unsigned int a2)
{
  uint64_t *v3;
  uint64_t v4;
  const swix::encode_message *v5;
  int v6;
  BOOL v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  unint64_t v12;
  _BYTE v14[8];
  xpc_object_t object;
  int v16;
  xpc_object_t xdict;

  v3 = MIDIProcess::defaultInstance(this);
  v4 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v3 + 8))(v3) + 432);
  swix::encode_message::encode_message((swix::encode_message *)&v16, 220460604);
  xpc_dictionary_set_uint64(xdict, "muid", a2);
  v5 = *(const swix::encode_message **)(v4 + 8);
  if (!v5)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)v14, v5, &v16);
  v6 = swix::coder<int>::decode(object, ".error");
  v7 = v6;
  if (v6)
  {
    v8 = 0;
    v9 = v6 & 0xFFFFFF00;
  }
  else
  {
    v7 = xpc_dictionary_get_BOOL(object, "collides");
    v9 = 0;
    v8 = 0x100000000;
  }
  xpc_release(object);
  xpc_release(xdict);
  v10 = v9 & 0xFFFFFF00 | v7;
  v11 = v10 & 0xFFFFFF00;
  v12 = (unint64_t)(v10 == 0) << 32;
  if ((v8 & 0x100000000) != 0)
  {
    v12 = 0x100000000;
    v11 = 0;
  }
  return v12 | v11 & 0xFFFFFFFFFFFFFF00 | v10;
}

void sub_1D4EFFBCC(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object)
{
  xpc_release(object);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EFFB80);
}

uint64_t XPCClient::MIDIExternalDeviceCreate(XPCClient *this, CFTypeRef cf, const __CFString *a3, const __CFString *a4, unsigned int *a5)
{
  MIDIProcess *v9;
  uint64_t *v10;
  uint64_t v11;
  void **v12;
  void **v13;
  void **v14;
  const swix::encode_message *v15;
  uint64_t v16;
  uint64_t v17;
  void *exception;
  void *v20;
  void *v21;
  xpc_object_t object;
  xpc_object_t v23;
  xpc_object_t value;
  void *__p[2];
  char v26;
  void *v27[2];
  char v28;
  void *v29[2];
  char v30;
  __CFString *v31;
  void *v32;
  int v33;
  xpc_object_t v34;

  if (!cf)
  {
    v31 = 0;
LABEL_40:
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  CFRetain(cf);
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v31, cf);
  if (!v31)
    goto LABEL_40;
  applesauce::CF::convert_to<std::string,0>((uint64_t)v29, v31);
  if (v31)
    CFRelease(v31);
  if (a3)
    CFRetain(a3);
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v31, a3);
  if (!v31)
  {
    v20 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v20, "Could not construct");
  }
  applesauce::CF::convert_to<std::string,0>((uint64_t)v27, v31);
  if (v31)
    CFRelease(v31);
  if (a4)
    CFRetain(a4);
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v31, a4);
  if (!v31)
  {
    v21 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](v21, "Could not construct");
  }
  applesauce::CF::convert_to<std::string,0>((uint64_t)__p, v31);
  v9 = (MIDIProcess *)v31;
  if (v31)
    CFRelease(v31);
  v10 = MIDIProcess::defaultInstance(v9);
  v11 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v10 + 8))(v10) + 432);
  if (v30 >= 0)
    v12 = v29;
  else
    v12 = (void **)v29[0];
  swix::string::string((swix::string *)&value, (const char *)v12);
  if (v28 >= 0)
    v13 = v27;
  else
    v13 = (void **)v27[0];
  swix::string::string((swix::string *)&v23, (const char *)v13);
  if (v26 >= 0)
    v14 = __p;
  else
    v14 = (void **)__p[0];
  swix::string::string((swix::string *)&object, (const char *)v14);
  swix::encode_message::encode_message((swix::encode_message *)&v33, 220460609);
  xpc_dictionary_set_value(v34, "name", value);
  xpc_dictionary_set_value(v34, "manufacturer", v23);
  xpc_dictionary_set_value(v34, "model", object);
  v15 = *(const swix::encode_message **)(v11 + 8);
  if (!v15)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)&v31, v15, &v33);
  v16 = swix::coder<int>::decode(v32, ".error");
  if ((_DWORD)v16)
  {
    v17 = 0;
  }
  else
  {
    v16 = swix::coder<unsigned int>::decode(v32, "device");
    v17 = 0x100000000;
  }
  xpc_release(v32);
  xpc_release(v34);
  xpc_release(object);
  xpc_release(v23);
  xpc_release(value);
  if ((v17 & 0x100000000) != 0 || !(_DWORD)v16)
  {
    *a5 = v16;
    v16 = 0;
  }
  if (v26 < 0)
    operator delete(__p[0]);
  if (v28 < 0)
    operator delete(v27[0]);
  if (v30 < 0)
    operator delete(v29[0]);
  return v16;
}

void sub_1D4EFFF18(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;

  xpc_release(*(xpc_object_t *)(v27 - 80));
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4EFFDFCLL);
}

void sub_1D4EFFFB4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object, xpc_object_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  xpc_release(object);
  xpc_release(a12);
  if (a18 < 0)
    operator delete(__p);
  if (a24 < 0)
    operator delete(a19);
  if (a30 < 0)
    operator delete(a25);
  JUMPOUT(0x1D4F00068);
}

void sub_1D4EFFFE0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a21 < 0)
    operator delete(a16);
  if (a27 < 0)
    operator delete(a22);
  JUMPOUT(0x1D4F00068);
}

void sub_1D4EFFFE8()
{
  JUMPOUT(0x1D4F00048);
}

void sub_1D4EFFFF0()
{
  void *v0;
  uint64_t v1;

  __cxa_free_exception(v0);
  applesauce::CF::StringRef::~StringRef((const void **)(v1 - 88));
  JUMPOUT(0x1D4F00068);
}

uint64_t XPCClient::MIDIDeviceNewEntity(XPCClient *this, unsigned int a2, CFTypeRef cf, MIDIProtocolID a4, int a5, uint64_t a6, uint64_t a7, unsigned int *a8)
{
  MIDIProcess *v15;
  uint64_t *v16;
  uint64_t v17;
  void **v18;
  const swix::encode_message *v19;
  uint64_t v20;
  uint64_t v21;
  void *exception;
  xpc_object_t value;
  void *__p[2];
  char v26;
  CFTypeRef cfa;
  xpc_object_t object;
  int v29;
  xpc_object_t xdict;

  if (!cf)
  {
    cfa = 0;
LABEL_20:
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  CFRetain(cf);
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cfa, cf);
  if (!cfa)
    goto LABEL_20;
  applesauce::CF::convert_to<std::string,0>((uint64_t)__p, (const __CFString *)cfa);
  v15 = (MIDIProcess *)cfa;
  if (cfa)
    CFRelease(cfa);
  v16 = MIDIProcess::defaultInstance(v15);
  v17 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v16 + 8))(v16) + 432);
  if (v26 >= 0)
    v18 = __p;
  else
    v18 = (void **)__p[0];
  swix::string::string((swix::string *)&value, (const char *)v18);
  swix::encode_message::encode_message((swix::encode_message *)&v29, 220460610);
  xpc_dictionary_set_uint64(xdict, "device", a2);
  xpc_dictionary_set_value(xdict, "name", value);
  xpc_dictionary_set_int64(xdict, "proto", a4);
  xpc_dictionary_set_BOOL(xdict, "embedded", a5 != 0);
  xpc_dictionary_set_uint64(xdict, "numSourceEndpoints", a6);
  xpc_dictionary_set_uint64(xdict, "numDestinationEndpoints", a7);
  v19 = *(const swix::encode_message **)(v17 + 8);
  if (!v19)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)&cfa, v19, &v29);
  v20 = swix::coder<int>::decode(object, ".error");
  if ((_DWORD)v20)
  {
    v21 = 0;
  }
  else
  {
    v20 = swix::coder<unsigned int>::decode(object, "entity");
    v21 = 0x100000000;
  }
  xpc_release(object);
  xpc_release(xdict);
  xpc_release(value);
  if ((v21 & 0x100000000) != 0 || !(_DWORD)v20)
  {
    *a8 = v20;
    v20 = 0;
  }
  if (v26 < 0)
    operator delete(__p[0]);
  return v20;
}

void sub_1D4F0027C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, xpc_object_t object)
{
  xpc_release(object);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4F001F0);
}

void sub_1D4F002E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

unint64_t XPCClient::MIDIDeviceRemoveEntity(XPCClient *this, unsigned int a2, unsigned int a3)
{
  uint64_t *v5;
  uint64_t v6;
  const swix::encode_message *v7;
  unsigned int v8;
  unint64_t v9;
  _BYTE v11[8];
  xpc_object_t object;
  int v13;
  xpc_object_t xdict;

  v5 = MIDIProcess::defaultInstance(this);
  v6 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v5 + 8))(v5) + 432);
  swix::encode_message::encode_message((swix::encode_message *)&v13, 220460611);
  xpc_dictionary_set_uint64(xdict, "device", a2);
  xpc_dictionary_set_uint64(xdict, "entity", a3);
  v7 = *(const swix::encode_message **)(v6 + 8);
  if (!v7)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)v11, v7, &v13);
  v8 = swix::coder<int>::decode(object, ".error");
  xpc_release(object);
  v9 = (unint64_t)(v8 == 0) << 32;
  xpc_release(xdict);
  if ((v9 | v8) >= 0x100000000)
    return 0x100000000;
  else
    return v9 | v8;
}

void sub_1D4F00408(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object)
{
  xpc_release(object);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4F003CCLL);
}

unint64_t XPCClient::MIDIEntityAddOrRemoveEndpoints(XPCClient *this, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v7;
  uint64_t v8;
  const swix::encode_message *v9;
  unsigned int v10;
  unint64_t v11;
  _BYTE v13[8];
  xpc_object_t object;
  int v15;
  xpc_object_t xdict;

  v7 = MIDIProcess::defaultInstance(this);
  v8 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v7 + 8))(v7) + 432);
  swix::encode_message::encode_message((swix::encode_message *)&v15, 220460612);
  xpc_dictionary_set_uint64(xdict, "entity", a2);
  xpc_dictionary_set_uint64(xdict, "numSourceEndpoints", a3);
  xpc_dictionary_set_uint64(xdict, "numDestinationEndpoints", a4);
  v9 = *(const swix::encode_message **)(v8 + 8);
  if (!v9)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)v13, v9, &v15);
  v10 = swix::coder<int>::decode(object, ".error");
  xpc_release(object);
  v11 = (unint64_t)(v10 == 0) << 32;
  xpc_release(xdict);
  if ((v11 | v10) >= 0x100000000)
    return 0x100000000;
  else
    return v11 | v10;
}

void sub_1D4F00554(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object)
{
  xpc_release(object);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4F00518);
}

unint64_t XPCClient::MIDISetupAddExternalDevice(XPCClient *this, unsigned int a2)
{
  uint64_t *v3;
  uint64_t v4;
  unint64_t result;

  v3 = MIDIProcess::defaultInstance(this);
  v4 = (*(uint64_t (**)(uint64_t *))(*v3 + 8))(v3);
  result = MIDIServerXPC_Client::setupAddDevice(*(MIDIServerXPC_Client **)(v4 + 432), a2, 1);
  if (result >= 0x100000000)
    return 0x100000000;
  return result;
}

unint64_t XPCClient::MIDISetupRemoveExternalDevice(XPCClient *this, unsigned int a2)
{
  uint64_t *v3;
  uint64_t v4;
  unint64_t result;

  v3 = MIDIProcess::defaultInstance(this);
  v4 = (*(uint64_t (**)(uint64_t *))(*v3 + 8))(v3);
  result = MIDIServerXPC_Client::setupRemoveDevice(*(MIDIServerXPC_Client **)(v4 + 432), a2, 1);
  if (result >= 0x100000000)
    return 0x100000000;
  return result;
}

unint64_t XPCClient::MIDISetupAddDevice(XPCClient *this, unsigned int a2)
{
  uint64_t *v3;
  uint64_t v4;
  unint64_t result;

  v3 = MIDIProcess::defaultInstance(this);
  v4 = (*(uint64_t (**)(uint64_t *))(*v3 + 8))(v3);
  result = MIDIServerXPC_Client::setupAddDevice(*(MIDIServerXPC_Client **)(v4 + 432), a2, 0);
  if (result >= 0x100000000)
    return 0x100000000;
  return result;
}

unint64_t XPCClient::MIDISetupRemoveDevice(XPCClient *this, unsigned int a2)
{
  uint64_t *v3;
  uint64_t v4;
  unint64_t result;

  v3 = MIDIProcess::defaultInstance(this);
  v4 = (*(uint64_t (**)(uint64_t *))(*v3 + 8))(v3);
  result = MIDIServerXPC_Client::setupRemoveDevice(*(MIDIServerXPC_Client **)(v4 + 432), a2, 0);
  if (result >= 0x100000000)
    return 0x100000000;
  return result;
}

uint64_t XPCClient::MIDIThruConnectionCreate(XPCClient *this, const __CFString *a2, CFDataRef theData, unsigned int *a4)
{
  const UInt8 *BytePtr;
  size_t Length;
  MIDIProcess *v9;
  MIDIProcess *v10;
  const char *p_p;
  MIDIProcess *v12;
  uint64_t *v13;
  uint64_t v14;
  const swix::encode_message *v15;
  uint64_t v16;
  uint64_t v17;
  void *exception;
  CFTypeRef cf;
  xpc_object_t value;
  void *__p;
  xpc_object_t v23;
  char v24;
  xpc_object_t object;
  xpc_object_t xdict;

  BytePtr = CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  swix::data::data((swix::data *)&value, BytePtr, Length);
  v9 = (MIDIProcess *)xpc_null_create();
  v10 = v9;
  if (a2)
  {
    CFRetain(a2);
    applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cf, a2);
    if (!cf)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x1D826B7EC](exception, "Could not construct");
    }
    applesauce::CF::convert_to<std::string,0>((uint64_t)&__p, (const __CFString *)cf);
    if (v24 >= 0)
      p_p = (const char *)&__p;
    else
      p_p = (const char *)__p;
    swix::string::string((swix::string *)&object, p_p);
    v12 = (MIDIProcess *)object;
    object = xpc_null_create();
    xpc_release(v10);
    xpc_release(object);
    object = 0;
    if (v24 < 0)
      operator delete(__p);
    v9 = (MIDIProcess *)cf;
    if (cf)
      CFRelease(cf);
    v10 = v12;
  }
  v13 = MIDIProcess::defaultInstance(v9);
  v14 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v13 + 8))(v13) + 432);
  swix::encode_message::encode_message((swix::encode_message *)&object, 220460618);
  xpc_dictionary_set_value(xdict, "persistentOwnerID", v10);
  xpc_dictionary_set_value(xdict, "connectionParams", value);
  v15 = *(const swix::encode_message **)(v14 + 8);
  if (!v15)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)&__p, v15, (int *)&object);
  v16 = swix::coder<int>::decode(v23, ".error");
  if ((_DWORD)v16)
  {
    v17 = 0;
  }
  else
  {
    v16 = swix::coder<unsigned int>::decode(v23, "conn");
    v17 = 0x100000000;
  }
  xpc_release(v23);
  xpc_release(xdict);
  if ((v17 & 0x100000000) != 0 || !(_DWORD)v16)
  {
    *a4 = v16;
    v16 = 0;
  }
  xpc_release(v10);
  xpc_release(value);
  return v16;
}

void sub_1D4F008B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, xpc_object_t object, void *__p, xpc_object_t a13, int a14, __int16 a15, char a16, char a17)
{
  void *v17;
  void *v18;

  __cxa_free_exception(v18);
  applesauce::CF::StringRef::~StringRef(&a10);
  xpc_release(v17);
  xpc_release(object);
  _Unwind_Resume(a1);
}

unint64_t XPCClient::MIDIThruConnectionDispose(XPCClient *this, unsigned int a2)
{
  uint64_t *v3;
  uint64_t v4;
  const swix::encode_message *v5;
  unsigned int v6;
  unint64_t v7;
  _BYTE v9[8];
  xpc_object_t object;
  int v11;
  xpc_object_t xdict;

  v3 = MIDIProcess::defaultInstance(this);
  v4 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v3 + 8))(v3) + 432);
  swix::encode_message::encode_message((swix::encode_message *)&v11, 220460619);
  xpc_dictionary_set_uint64(xdict, "conn", a2);
  v5 = *(const swix::encode_message **)(v4 + 8);
  if (!v5)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)v9, v5, &v11);
  v6 = swix::coder<int>::decode(object, ".error");
  xpc_release(object);
  v7 = (unint64_t)(v6 == 0) << 32;
  xpc_release(xdict);
  if ((v7 | v6) >= 0x100000000)
    return 0x100000000;
  else
    return v7 | v6;
}

void sub_1D4F00A50(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object)
{
  xpc_release(object);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4F00A18);
}

uint64_t XPCClient::MIDIThruConnectionGetParams(XPCClient *this, unsigned int a2, const __CFData **a3)
{
  uint64_t *v5;
  uint64_t v6;
  const swix::encode_message *v7;
  int v8;
  xpc_object_t v9;
  xpc_object_t v10;
  xpc_object_t v11;
  uint64_t result;
  xpc_object_t v13;
  const UInt8 *bytes_ptr;
  size_t length;
  CFDataRef v16;
  void *exception;
  xpc_object_t v18;
  char v19;
  xpc_object_t v20;
  const __CFData *v21;
  xpc_object_t object;
  int v23;
  xpc_object_t xdict;

  v5 = MIDIProcess::defaultInstance(this);
  v6 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v5 + 8))(v5) + 432);
  swix::encode_message::encode_message((swix::encode_message *)&v23, 220460620);
  xpc_dictionary_set_uint64(xdict, "conn", a2);
  v7 = *(const swix::encode_message **)(v6 + 8);
  if (!v7)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)&v21, v7, &v23);
  v8 = swix::coder<int>::decode(object, ".error");
  if (v8)
  {
    LODWORD(v18) = v8;
    v19 = 0;
  }
  else
  {
    v9 = xpc_null_create();
    swix::xpcobj_coder<swix::data>::decode(&v20, object, "params");
    v10 = v20;
    v11 = xpc_null_create();
    v20 = v11;
    xpc_release(v9);
    xpc_release(v11);
    std::__tuple_leaf<0ul,swix::data,false>::__tuple_leaf[abi:ne180100](&v18, v10);
    v19 = 1;
    xpc_release(v10);
  }
  xpc_release(object);
  xpc_release(xdict);
  if (v19 || (result = v18, !(_DWORD)v18))
  {
    v13 = v18;
    if (v18)
      xpc_retain(v18);
    else
      v13 = xpc_null_create();
    bytes_ptr = (const UInt8 *)xpc_data_get_bytes_ptr(v13);
    length = xpc_data_get_length(v13);
    v16 = CFDataCreate(0, bytes_ptr, length);
    if (!v16)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x1D826B7EC](exception, "Could not construct");
    }
    applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)&v21, v16);
    *a3 = v21;
    xpc_release(v13);
    if (v19)
      xpc_release(v18);
    return 0;
  }
  return result;
}

void sub_1D4F00C64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object, char a10, uint64_t a11, uint64_t a12, xpc_object_t a13)
{
  void *v13;
  void *v14;

  __cxa_free_exception(v14);
  xpc_release(v13);
  if (a10)
    xpc_release(object);
  _Unwind_Resume(a1);
}

unint64_t XPCClient::MIDIThruConnectionSetParams(XPCClient *this, unsigned int a2, CFDataRef theData)
{
  const UInt8 *BytePtr;
  size_t Length;
  MIDIProcess *v7;
  uint64_t *v8;
  uint64_t v9;
  const swix::encode_message *v10;
  unsigned int v11;
  unint64_t v12;
  xpc_object_t value;
  _BYTE v15[8];
  xpc_object_t object;
  int v17;
  xpc_object_t xdict;

  BytePtr = CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  v7 = swix::data::data((swix::data *)&value, BytePtr, Length);
  v8 = MIDIProcess::defaultInstance(v7);
  v9 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v8 + 8))(v8) + 432);
  swix::encode_message::encode_message((swix::encode_message *)&v17, 220460621);
  xpc_dictionary_set_uint64(xdict, "conn", a2);
  xpc_dictionary_set_value(xdict, "connectionParams", value);
  v10 = *(const swix::encode_message **)(v9 + 8);
  if (!v10)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)v15, v10, &v17);
  v11 = swix::coder<int>::decode(object, ".error");
  xpc_release(object);
  v12 = (unint64_t)(v11 == 0) << 32;
  xpc_release(xdict);
  xpc_release(value);
  if ((v12 | v11) >= 0x100000000)
    return 0x100000000;
  else
    return v12 | v11;
}

void sub_1D4F00E44(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object)
{
  xpc_release(object);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4F00DFCLL);
}

void sub_1D4F00E94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object)
{
  xpc_release(object);
  _Unwind_Resume(a1);
}

uint64_t XPCClient::MIDIThruConnectionFind(XPCClient *this, CFTypeRef cf, const __CFData **a3)
{
  const char *p_p;
  MIDIProcess *v6;
  uint64_t *v7;
  uint64_t v8;
  const swix::encode_message *v9;
  int v10;
  xpc_object_t v11;
  xpc_object_t v12;
  xpc_object_t v13;
  uint64_t v14;
  xpc_object_t v15;
  const UInt8 *bytes_ptr;
  size_t length;
  CFDataRef v18;
  void *exception;
  void *v21;
  xpc_object_t v22;
  char v23;
  xpc_object_t value;
  xpc_object_t v25;
  void *__p;
  xpc_object_t object;
  char v28;
  __CFString *v29;
  xpc_object_t v30;

  if (!cf)
  {
    v29 = 0;
LABEL_26:
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  CFRetain(cf);
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&v29, cf);
  if (!v29)
    goto LABEL_26;
  applesauce::CF::convert_to<std::string,0>((uint64_t)&__p, v29);
  if (v28 >= 0)
    p_p = (const char *)&__p;
  else
    p_p = (const char *)__p;
  swix::string::string((swix::string *)&value, p_p);
  if (v28 < 0)
    operator delete(__p);
  v6 = (MIDIProcess *)v29;
  if (v29)
    CFRelease(v29);
  v7 = MIDIProcess::defaultInstance(v6);
  v8 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v7 + 8))(v7) + 432);
  swix::encode_message::encode_message((swix::encode_message *)&v29, 220460622);
  xpc_dictionary_set_value(v30, "persistentOwnerID", value);
  v9 = *(const swix::encode_message **)(v8 + 8);
  if (!v9)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)&__p, v9, (int *)&v29);
  v10 = swix::coder<int>::decode(object, ".error");
  if (v10)
  {
    LODWORD(v22) = v10;
    v23 = 0;
  }
  else
  {
    v11 = xpc_null_create();
    swix::xpcobj_coder<swix::data>::decode(&v25, object, "connectionList");
    v12 = v25;
    v13 = xpc_null_create();
    v25 = v13;
    xpc_release(v11);
    xpc_release(v13);
    std::__tuple_leaf<0ul,swix::data,false>::__tuple_leaf[abi:ne180100](&v22, v12);
    v23 = 1;
    xpc_release(v12);
  }
  xpc_release(object);
  xpc_release(v30);
  if (v23 || (v14 = v22, !(_DWORD)v22))
  {
    v15 = v22;
    if (v22)
      xpc_retain(v22);
    else
      v15 = xpc_null_create();
    bytes_ptr = (const UInt8 *)xpc_data_get_bytes_ptr(v15);
    length = xpc_data_get_length(v15);
    v18 = CFDataCreate(0, bytes_ptr, length);
    if (!v18)
    {
      v21 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x1D826B7EC](v21, "Could not construct");
    }
    applesauce::CF::DataRef::DataRef((applesauce::CF::DataRef *)&__p, v18);
    *a3 = (const __CFData *)__p;
    xpc_release(v15);
    if (v23)
      xpc_release(v22);
    v14 = 0;
  }
  xpc_release(value);
  return v14;
}

void sub_1D4F01114(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, xpc_object_t object, char a11, xpc_object_t a12, uint64_t a13, void *__p, xpc_object_t a15, int a16, __int16 a17, char a18, char a19)
{
  void *v19;
  void *v20;

  __cxa_free_exception(v20);
  xpc_release(v19);
  if (a11)
    xpc_release(object);
  xpc_release(a12);
  _Unwind_Resume(a1);
}

uint64_t XPCClient::MIDISetupCreate_Priv(XPCClient *this, unsigned int *a2)
{
  uint64_t *v3;
  uint64_t v4;
  const swix::encode_message *v5;
  uint64_t v6;
  uint64_t v7;
  _BYTE v9[8];
  xpc_object_t object;
  int v11;
  xpc_object_t v12;

  v3 = MIDIProcess::defaultInstance(this);
  v4 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v3 + 8))(v3) + 432);
  swix::encode_message::encode_message((swix::encode_message *)&v11, 220460605);
  v5 = *(const swix::encode_message **)(v4 + 8);
  if (!v5)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)v9, v5, &v11);
  v6 = swix::coder<int>::decode(object, ".error");
  if ((_DWORD)v6)
  {
    v7 = 0;
  }
  else
  {
    v6 = swix::coder<unsigned int>::decode(object, "setup");
    v7 = 0x100000000;
  }
  xpc_release(object);
  xpc_release(v12);
  if ((v7 & 0x100000000) != 0 || !(_DWORD)v6)
  {
    *a2 = v6;
    return 0;
  }
  return v6;
}

void sub_1D4F01300(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object)
{
  xpc_release(object);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4F012CCLL);
}

uint64_t XPCClient::MIDISetupGetCurrent_Priv(XPCClient *this, unsigned int *a2)
{
  uint64_t *v3;
  uint64_t v4;
  const swix::encode_message *v5;
  uint64_t v6;
  uint64_t v7;
  _BYTE v9[8];
  xpc_object_t object;
  int v11;
  xpc_object_t v12;

  v3 = MIDIProcess::defaultInstance(this);
  v4 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v3 + 8))(v3) + 432);
  swix::encode_message::encode_message((swix::encode_message *)&v11, 220460608);
  v5 = *(const swix::encode_message **)(v4 + 8);
  if (!v5)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)v9, v5, &v11);
  v6 = swix::coder<int>::decode(object, ".error");
  if ((_DWORD)v6)
  {
    v7 = 0;
  }
  else
  {
    v6 = swix::coder<unsigned int>::decode(object, "setup");
    v7 = 0x100000000;
  }
  xpc_release(object);
  xpc_release(v12);
  if ((v7 & 0x100000000) != 0 || !(_DWORD)v6)
  {
    *a2 = v6;
    return 0;
  }
  return v6;
}

void sub_1D4F01424(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object)
{
  xpc_release(object);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4F013F0);
}

unint64_t XPCClient::MIDISetupInstall_Priv(XPCClient *this, unsigned int a2)
{
  uint64_t *v3;
  uint64_t v4;
  const swix::encode_message *v5;
  unsigned int v6;
  unint64_t v7;
  _BYTE v9[8];
  xpc_object_t object;
  int v11;
  xpc_object_t xdict;

  v3 = MIDIProcess::defaultInstance(this);
  v4 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v3 + 8))(v3) + 432);
  swix::encode_message::encode_message((swix::encode_message *)&v11, 220460607);
  xpc_dictionary_set_uint64(xdict, "setup", a2);
  v5 = *(const swix::encode_message **)(v4 + 8);
  if (!v5)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)v9, v5, &v11);
  v6 = swix::coder<int>::decode(object, ".error");
  xpc_release(object);
  v7 = (unint64_t)(v6 == 0) << 32;
  xpc_release(xdict);
  if ((v7 | v6) >= 0x100000000)
    return 0x100000000;
  else
    return v7 | v6;
}

void sub_1D4F01544(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object)
{
  xpc_release(object);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4F0150CLL);
}

uint64_t XPCClient::MIDISetupFromData_Priv(XPCClient *this, CFDataRef theData, unsigned int *a3)
{
  const UInt8 *BytePtr;
  size_t Length;
  MIDIProcess *v7;
  uint64_t *v8;
  uint64_t v9;
  const swix::encode_message *v10;
  uint64_t v11;
  uint64_t v12;
  xpc_object_t value;
  _BYTE v15[8];
  xpc_object_t object;
  int v17;
  xpc_object_t xdict;

  BytePtr = CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  v7 = swix::data::data((swix::data *)&value, BytePtr, Length);
  v8 = MIDIProcess::defaultInstance(v7);
  v9 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v8 + 8))(v8) + 432);
  swix::encode_message::encode_message((swix::encode_message *)&v17, 220460606);
  xpc_dictionary_set_value(xdict, "data", value);
  v10 = *(const swix::encode_message **)(v9 + 8);
  if (!v10)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)v15, v10, &v17);
  v11 = swix::coder<int>::decode(object, ".error");
  if ((_DWORD)v11)
  {
    v12 = 0;
  }
  else
  {
    v11 = swix::coder<unsigned int>::decode(object, "setup");
    v12 = 0x100000000;
  }
  xpc_release(object);
  xpc_release(xdict);
  if ((v12 & 0x100000000) != 0 || !(_DWORD)v11)
  {
    *a3 = v11;
    v11 = 0;
  }
  xpc_release(value);
  return v11;
}

void sub_1D4F016A0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, xpc_object_t object)
{
  xpc_release(object);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1D4F01664);
}

void sub_1D4F01704(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, xpc_object_t object)
{
  xpc_release(object);
  _Unwind_Resume(a1);
}

uint64_t XPCClient::MIDIInputPortCreateInternal(XPCClient *this, unsigned int a2, CFTypeRef cf, MIDIProtocolID a4, unsigned int *a5)
{
  MIDIProcess *v9;
  uint64_t *v10;
  uint64_t v11;
  void **v12;
  const swix::encode_message *v13;
  uint64_t v14;
  uint64_t v15;
  void *exception;
  xpc_object_t value;
  void *__p[2];
  char v20;
  CFTypeRef cfa;
  xpc_object_t object;
  int v23;
  xpc_object_t v24;

  if (!cf)
  {
    cfa = 0;
LABEL_20:
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x1D826B7EC](exception, "Could not construct");
  }
  CFRetain(cf);
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cfa, cf);
  if (!cfa)
    goto LABEL_20;
  applesauce::CF::convert_to<std::string,0>((uint64_t)__p, (const __CFString *)cfa);
  v9 = (MIDIProcess *)cfa;
  if (cfa)
    CFRelease(cfa);
  v10 = MIDIProcess::defaultInstance(v9);
  v11 = *(_QWORD *)((*(uint64_t (**)(uint64_t *))(*v10 + 8))(v10) + 432);
  if (v20 >= 0)
    v12 = __p;
  else
    v12 = (void **)__p[0];
  swix::string::string((swix::string *)&value, (const char *)v12);
  swix::encode_message::encode_message((swix::encode_message *)&v23, 220460589);
  xpc_dictionary_set_uint64(v24, "client", a2);
  xpc_dictionary_set_value(v24, "name", value);
  xpc_dictionary_set_int64(v24, "proto", a4);
  v13 = *(const swix::encode_message **)(v11 + 8);
  if (!v13)
    std::terminate();
  swix::connection::send_and_await_reply((swix::connection *)&cfa, v13, &v23);
  v14 = swix::coder<int>::decode(object, ".error");
  if ((_DWORD)v14)
  {
    v15 = 0;
  }
  else
  {
    v14 = swix::coder<unsigned int>::decode(object, "portRef");
    v15 = 0x100000000;
  }
  xpc_release(object);
  xpc_release(v24);
  xpc_release(value);
  if ((v15 & 0x100000000) != 0 || !(_DWORD)v14)
  {
    *a5 = v14;
    v14 = 0;
  }
  if (v20 < 0)
    operator delete(__p[0]);
  return v14;
}

