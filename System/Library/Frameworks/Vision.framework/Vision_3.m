uint64_t tplTracker_IFFT_2D(uint64_t a1, char *a2, _QWORD *a3, int32x4_t a4)
{
  uint64_t v4;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  _QWORD *v12;
  char *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;

  v4 = 6780;
  if (a1 && a3)
  {
    v8 = 0;
    v9 = 72;
    do
    {
      v10 = tplTracker_IFFT_3324(a1 + v8, (uint64_t)&a2[v8], a4);
      if (v10 != 128)
        return v10;
      v8 += 576;
      --v9;
    }
    while (v9);
    if (a2)
    {
      v11 = 0;
      v12 = a3;
      v13 = a2;
      do
      {
        v14 = 0;
        v15 = v12;
        do
        {
          *v15 = *(_QWORD *)&v13[v14];
          v15 += 72;
          v14 += 8;
        }
        while ((_DWORD)v14 != 576);
        v13 += 576;
        ++v12;
        ++v11;
      }
      while (v11 != 72);
      v16 = 0;
      v17 = 72;
      while (1)
      {
        v4 = tplTracker_IFFT_3324((uint64_t)&a3[v16], (uint64_t)&a2[v16 * 8], a4);
        if (v4 != 128)
          break;
        v16 += 72;
        if (!--v17)
        {
          memcpy(a3, a2, 0xA200uLL);
          return v4;
        }
      }
    }
    else
    {
      return 6780;
    }
  }
  return v4;
}

void sub_1A14963BC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14964C0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14965D4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1496CB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, void *a18, void *a19)
{
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;

  _Unwind_Resume(a1);
}

void sub_1A1497788(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, CVPixelBufferRef *a11, __CVBuffer **a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,void *__p,uint64_t a49)
{
  apple::vision::libraries::autotrace::BitmapToContourEnvironment::~BitmapToContourEnvironment((apple::vision::libraries::autotrace::BitmapToContourEnvironment *)&a41);
  apple::vision::CVPixelBufferWrapper::BaseAddressLock<1ull>::~BaseAddressLock(a11);
  apple::vision::CVPixelBufferWrapper::~CVPixelBufferWrapper(a12);

  _Unwind_Resume(a1);
}

void sub_1A1497914(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14979A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t BinSerializer_fseek(FILE *__stream, _BYTE *a2)
{
  char v3;
  unsigned __int8 *v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  unsigned int v8;
  _OWORD v10[2];
  uint64_t v11;

  v3 = *a2;
  if (*a2)
  {
    v4 = a2 + 1;
    v5 = 5381;
    do
    {
      v5 = 33 * v5 + v3;
      v6 = *v4++;
      v3 = v6;
    }
    while (v6);
  }
  else
  {
    v5 = 5381;
  }
  v7 = 370;
  while (1)
  {
    v11 = 0;
    memset(v10, 0, sizeof(v10));
    if (!fread(v10, 0x28uLL, 1uLL, __stream))
      break;
    if (*(_QWORD *)&v10[0] == v5)
    {
      fseek(__stream, -40, 1);
      return 384;
    }
    v8 = WORD4(v10[0]) - 1;
    if (v8 >= 9)
      return 371;
    fseek(__stream, qword_1A15E49C0[v8] * v11, 1);
  }
  return v7;
}

uint64_t BinSerializer_fgetBlobInfo(FILE *a1, _BYTE *a2, _QWORD *a3, _WORD *a4, _QWORD *a5, _QWORD *a6, _QWORD *a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v18;
  __int128 v19;
  uint64_t v20;

  v14 = MEMORY[0x1A1B0AEBC]();
  if (a2)
  {
    fseek(a1, 0, 0);
    v15 = BinSerializer_fseek(a1, a2);
    if ((v15 & 0x80) != 0)
    {
      v20 = 0;
      v18 = 0u;
      v19 = 0u;
      if (fread(&v18, 0x28uLL, 1uLL, a1))
      {
        *a3 = v18;
        *a4 = WORD4(v18);
        v16 = *((_QWORD *)&v19 + 1);
        *a5 = v19;
        *a6 = v16;
        *a7 = v20;
      }
      else
      {
        v15 = 373;
      }
    }
  }
  else
  {
    v15 = 381;
  }
  fseek(a1, v14, 0);
  return v15;
}

uint64_t BinSerializer_freadInBytes(FILE *__stream, _BYTE *a2, _QWORD *a3, size_t *a4)
{
  uint64_t v7;
  size_t v8;
  void *v9;
  _OWORD v11[2];
  size_t size;

  if (!__stream)
    return 381;
  if (a2)
  {
    v7 = BinSerializer_fseek(__stream, a2);
    if ((v7 & 0x80) == 0)
      return v7;
  }
  else
  {
    v7 = 384;
  }
  size = 0;
  memset(v11, 0, sizeof(v11));
  if (fread(v11, 0x28uLL, 1uLL, __stream) != 1)
    return 373;
  if (WORD4(v11[0]) != 9)
    return 371;
  v8 = size;
  *a4 = size;
  v9 = malloc_type_malloc(v8, 0x100004077774924uLL);
  *a3 = v9;
  if (!v9)
    return 379;
  if (fread(v9, 1uLL, v8, __stream) != v8)
    return 373;
  return v7;
}

uint64_t BinSerializer_convertFloats(uint64_t a1, float *a2, float *__dst)
{
  uint64_t *v3;
  uint64_t v4;
  double v5;
  float v6;
  float v7;
  unsigned int v8;
  uint64_t v9;
  double v10;
  float v11;
  float v12;
  unsigned int v13;

  v3 = &CVML_status_notImplementedError;
  switch(*(_WORD *)(a1 + 8))
  {
    case 1:
      v4 = *(_QWORD *)(a1 + 32);
      if (!v4)
        goto LABEL_13;
      v5 = *(double *)(a1 + 16);
      v6 = *(double *)(a1 + 24) - v5;
      v7 = v5;
      v3 = &CVML_status_ok;
      do
      {
        v8 = *(unsigned __int8 *)a2;
        a2 = (float *)((char *)a2 + 1);
        *__dst++ = (float)((float)(v6 * (float)v8) / 255.0) + v7;
        --v4;
      }
      while (v4);
      break;
    case 2:
      v9 = *(_QWORD *)(a1 + 32);
      if (!v9)
        goto LABEL_13;
      v10 = *(double *)(a1 + 16);
      v11 = *(double *)(a1 + 24) - v10;
      v12 = v10;
      v3 = &CVML_status_ok;
      do
      {
        v13 = *(unsigned __int16 *)a2;
        a2 = (float *)((char *)a2 + 2);
        *__dst++ = (float)((float)(v11 * (float)v13) / 65535.0) + v12;
        --v9;
      }
      while (v9);
      break;
    case 3:
      if (a2 != __dst)
        memcpy(__dst, a2, 4 * *(_QWORD *)(a1 + 32));
LABEL_13:
      v3 = &CVML_status_ok;
      break;
    case 4:
      return (*v3 + 128) | 0x100;
    default:
      v3 = &CVML_status_invalidType;
      break;
  }
  return (*v3 + 128) | 0x100;
}

uint64_t BinSerializer_freadInFloat(FILE *__stream, _BYTE *a2, int a3, float **a4, size_t *a5)
{
  uint64_t v9;
  size_t v10;
  float *v11;
  float *v12;
  float *v13;
  size_t v14;
  _OWORD v16[2];
  size_t v17;

  if (!__stream)
    return 381;
  if (!a2 || (v9 = BinSerializer_fseek(__stream, a2), (v9 & 0x80) != 0))
  {
    v17 = 0;
    memset(v16, 0, sizeof(v16));
    if (fread(v16, 0x28uLL, 1uLL, __stream) != 1)
      return 373;
    v10 = v17;
    *a5 = v17;
    if (a3)
    {
      v11 = (float *)malloc_type_malloc(4 * v10, 0x100004052888210uLL);
      *a4 = v11;
      if (!v11)
        return 379;
    }
    else
    {
      v11 = *a4;
      if (!*a4)
        return 379;
    }
    v9 = 383;
    switch(WORD4(v16[0]))
    {
      case 1:
        v12 = (float *)malloc_type_malloc(v10, 0x100004077774924uLL);
        if (!v12)
          return 379;
        v13 = v12;
        v14 = 1;
        goto LABEL_15;
      case 2:
        v12 = (float *)malloc_type_malloc(2 * v10, 0x6A054704uLL);
        if (!v12)
          return 379;
        v13 = v12;
        v14 = 2;
LABEL_15:
        if (fread(v12, v14, v10, __stream) == v10)
          goto LABEL_20;
        free(v13);
        return 373;
      case 3:
        if (fread(v11, 4uLL, v10, __stream) != v10)
          return 373;
        v13 = *a4;
LABEL_20:
        v9 = BinSerializer_convertFloats((uint64_t)v16, v13, *a4);
        if (v13 != *a4)
          free(v13);
        return v9;
      case 4:
        return v9;
      default:
        return 371;
    }
  }
  return v9;
}

void sub_1A1498228(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1A1498404(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1498678(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  void *v17;

  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void sub_1A14987E0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14989A4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1498AD8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1498BAC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1498C90(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1499338(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, void *a14, uint64_t a15, void *a16, void *a17)
{
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

void sub_1A14994CC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1499518(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A149960C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1499650(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A149969C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A14996E4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1499730(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A1499780(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14997D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A1499938(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A1499ADC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A1499C4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A1499CA0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1499E10(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1499EA8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1499FDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  void *v9;

  a9.super_class = (Class)VNSequenceRequestHandler;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_1A149A12C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A149A240(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A149A360(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A149A484(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A149A5A8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A149A6C0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A149A758(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A149A7A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A149A808(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1A149A898(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1A149A908(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1A149A9C8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A149ABB0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<vision::mod::ImageClassifierGlimmer>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453B6F0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<vision::mod::ImageClassifierGlimmer>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453B6F0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A1B0A898);
}

uint64_t std::__shared_ptr_emplace<vision::mod::ImageClassifierGlimmer>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void releaseContourDatabaseMemory(uint64_t a1)
{
  void *v2;
  void **v3;
  int v4;
  int v5;
  void **v6;

  v2 = *(void **)(a1 + 8);
  if (v2)
  {
    free(v2);
    *(_QWORD *)(a1 + 8) = 0;
  }
  v3 = *(void ***)(a1 + 16);
  if (v3)
  {
    v4 = *(_DWORD *)a1;
    if (*(int *)a1 >= 1)
    {
      v5 = 0;
      v6 = v3 + 7;
      do
      {
        if (*v6)
        {
          free(*v6);
          *v6 = 0;
          v4 = *(_DWORD *)a1;
        }
        ++v5;
        v6 += 5;
      }
      while (v5 < v4);
      v3 = *(void ***)(a1 + 16);
    }
    free(v3);
    *(_QWORD *)(a1 + 16) = 0;
  }
}

uint64_t SelfClosureContourHeal(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _BYTE *v12;
  int v13;
  uint64_t v14;
  _QWORD *v15;
  unsigned __int16 *v16;
  uint64_t v17;
  uint64_t v18;
  unsigned __int16 *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  __int16 *v27;
  uint64_t v28;
  int v29;
  int v30;
  uint64_t v31;
  _WORD *v32;
  uint64_t v33;
  _WORD *v34;
  uint64_t v35;
  _WORD *v36;
  uint64_t result;
  uint64_t v38;
  unsigned __int16 *v39;
  unsigned int v40;
  unsigned int v41;
  uint64_t v42;
  __int16 *v43;
  uint64_t v44;
  uint64_t v45;
  __int16 *v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  int v51;
  int *v52;
  _QWORD *v53;
  _BYTE *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unsigned __int16 v60;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67;
  int v68;
  _BYTE v70[2];
  _BYTE v71[22];

  *(_QWORD *)&v71[6] = *MEMORY[0x1E0C80C00];
  v7 = a1[1];
  v50 = *a1;
  v8 = *((_QWORD *)a1 + 1);
  v9 = *((_QWORD *)a1 + 2);
  v68 = a3;
  v56 = a3 << 32;
  if ((int)v7 >= 1)
  {
    v10 = 0;
    v51 = a3;
    v58 = a1[1];
    v59 = *((_QWORD *)a1 + 2);
    v57 = *((_QWORD *)a1 + 1);
    do
    {
      v11 = v9 + 40 * *(unsigned __int16 *)(v8 + 2 * v10);
      v13 = *(unsigned __int8 *)(v11 + 8);
      v12 = (_BYTE *)(v11 + 8);
      if (!v13 && *(_BYTE *)(v9 + 40 * *(unsigned __int16 *)(v8 + 2 * v10)))
      {
        v60 = *(_WORD *)(v8 + 2 * v10);
        v14 = v9 + 40 * v60;
        v16 = *(unsigned __int16 **)(v14 + 16);
        v15 = (_QWORD *)(v14 + 16);
        v17 = *v16;
        v65 = (__int16)v17;
        v18 = v16[1];
        v19 = &v16[2 * *((int *)v15 - 3)];
        v20 = *(v19 - 2);
        v64 = (__int16)v20;
        v21 = *(v19 - 1);
        v62 = (__int16)v18;
        v63 = (__int16)v21;
        v22 = v17 | (v18 << 16);
        v23 = v20 | (v21 << 16);
        v66 = v22 | v66 & 0xFFFFFFFF00000000;
        v67 = v23 | v67 & 0xFFFFFFFF00000000;
        v24 = healCenters(v66, v23, (uint64_t)v70);
        if (v24)
        {
          v52 = (int *)v15 - 3;
          v53 = v15;
          v55 = v12;
          v25 = 0;
          v26 = v24;
          v27 = (__int16 *)v71;
          while (1)
          {
            v28 = *(v27 - 1);
            v29 = *v27;
            v6 = v6 & 0xFFFFFFFF00000000 | v22;
            v5 = v5 & 0xFFFFFFFF00000000 | v23;
            v30 = heal((_BYTE *)(v28 + a2 + (v29 - 1) * (uint64_t)v68 - 1), v68, v6, v5, (uint64_t)v70, v25);
            if ((v30 & 0x80000000) == 0)
              break;
            v27 += 2;
            if (v26 == ++v25)
              goto LABEL_9;
          }
          v9 = v59;
          if ((a5 & 1) == 0)
          {
            *(_WORD *)(a4 + 2 * v65 + ((v56 * v62) >> 31)) = 0;
            *(_WORD *)(a4 + 2 * v64 + ((v56 * v63) >> 31)) = 0;
          }
          switch(v30)
          {
            case 0:
              v31 = *v52;
              v32 = (_WORD *)(*v53 + 4 * v31);
              *v32 = v28;
              v32[1] = v29;
              *v52 = v31 + 1;
              v33 = a2;
              goto LABEL_19;
            case 1:
              v33 = a2;
              *(_BYTE *)(a2 + v65 + ((v56 * v62) >> 32)) = 0;
              v34 = (_WORD *)*v53;
              *v34 = v28;
              v34[1] = v29;
              goto LABEL_19;
            case 2:
              v33 = a2;
              *(_BYTE *)(a2 + v64 + ((v56 * v63) >> 32)) = 0;
              v35 = *v53 + 4 * *v52;
              *(_WORD *)(v35 - 4) = v28;
              *(_WORD *)(v35 - 2) = v29;
              goto LABEL_19;
            case 3:
              v33 = a2;
              *(_BYTE *)(a2 + v65 + ((v56 * v62) >> 32)) = 0;
              *(_BYTE *)(a2 + v64 + ((v56 * v63) >> 32)) = 0;
              v36 = (_WORD *)*v53;
              *v36 = v28;
              v36[1] = v29;
              --*v52;
LABEL_19:
              *(_BYTE *)(v33 + v28 + v29 * (uint64_t)v51) = 1;
              break;
            default:
              break;
          }
          *v55 = 1;
        }
        else
        {
LABEL_9:
          if (a5)
          {
            *(_WORD *)(a4 + 2 * v65 + ((v56 * v62) >> 31)) = v60;
            *(_WORD *)(a4 + 2 * v64 + ((v56 * v63) >> 31)) = v60;
          }
          v9 = v59;
        }
        v8 = v57;
        v7 = v58;
      }
      ++v10;
    }
    while (v10 != v7);
  }
  result = v56;
  if (a5 && (int)v7 < v50 - 1)
  {
    v38 = v50 - 1 - (uint64_t)(int)v7;
    v39 = (unsigned __int16 *)(v8 + 2 * (int)v7);
    do
    {
      v41 = *v39++;
      v40 = v41;
      if (!*(_BYTE *)(v9 + 40 * v41 + 8))
      {
        v42 = v9 + 40 * v40;
        v43 = *(__int16 **)(v42 + 16);
        v44 = *v43;
        v45 = v43[1];
        v46 = &v43[2 * *(int *)(v42 + 4)];
        v47 = *(v46 - 2);
        v48 = *(v46 - 1);
        v49 = -v40;
        *(_WORD *)(a4 + 2 * v44 + ((v56 * v45) >> 31)) = v49;
        *(_WORD *)(a4 + 2 * v47 + ((v56 * v48) >> 31)) = v49;
      }
      --v38;
    }
    while (v38);
  }
  return result;
}

uint64_t healCenters(unint64_t a1, int a2, uint64_t a3)
{
  int v3;
  int v4;
  unsigned int v5;
  unsigned int v6;
  BOOL v7;
  BOOL v8;
  BOOL v9;
  BOOL v10;
  _BOOL4 v11;
  int v12;
  uint64_t result;
  int v14;

  v3 = (__int16)a2 - (__int16)a1;
  v4 = (a2 >> 16) - ((int)a1 >> 16);
  if (v3 >= 0)
    v5 = (__int16)a2 - (__int16)a1;
  else
    v5 = (__int16)a1 - (__int16)a2;
  if (v4 >= 0)
    v6 = (a2 >> 16) - ((int)a1 >> 16);
  else
    v6 = ((int)a1 >> 16) - (a2 >> 16);
  v7 = v5 > 2 || v6 > 2;
  if (!v7 && (v5 <= 1 ? (v8 = v6 > 1) : (v8 = 1), v8))
  {
    v9 = HIWORD(a2) == WORD1(a1) || v6 == 2;
    v10 = v5 == 2 && v9;
    v11 = (unsigned __int16)a2 == (unsigned __int16)a1 && v6 == 2;
    if (v10 || v11)
    {
      *(_WORD *)a3 = a1 + (v3 >> 1);
      *(_WORD *)(a3 + 2) = (v4 >> 1) + WORD1(a1);
      *(_DWORD *)(a3 + 4) = 0;
      return 1;
    }
    else
    {
      if (v5 == 2)
      {
        v12 = a1 + (v3 >> 1);
        *(_WORD *)a3 = v12;
        *(_WORD *)(a3 + 2) = WORD1(a1);
        *(_WORD *)(a3 + 4) = v12;
        *(_WORD *)(a3 + 6) = HIWORD(a2);
      }
      else
      {
        if (v6 != 2)
          __assert_rtn("healCenters", "Contours.c", 133, "ady == 2");
        *(_WORD *)a3 = a1;
        v14 = (a1 >> 16) + (v4 >> 1);
        *(_WORD *)(a3 + 2) = v14;
        *(_WORD *)(a3 + 4) = a2;
        *(_WORD *)(a3 + 6) = v14;
      }
      return 2;
    }
  }
  else
  {
    result = 0;
    *(_QWORD *)a3 = 0;
  }
  return result;
}

uint64_t heal(_BYTE *a1, int a2, int a3, int a4, uint64_t a5, unsigned int a6)
{
  __int16 *v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  unsigned int v13;
  BOOL v14;
  uint64_t result;
  _BOOL4 v17;
  BOOL v18;

  v6 = (__int16 *)(a5 + 4 * a6);
  v7 = *v6;
  v8 = v6[1];
  v9 = 3 * ((__int16)a3 - v7) - v8 + (a3 >> 16);
  v10 = v9 + 5;
  v11 = 3 * ((__int16)a4 - v7) - v8 + (a4 >> 16);
  v12 = v11 + 5;
  switch((*a1 | (8 * a1[1]) | (32 * a1[2]) | (2 * a1[a2]) | (a1[a2 + 2] << 6) | (4 * a1[2 * a2]) | (16 * a1[2 * a2 + 1])) | (a1[2 * a2 + 2] << 7))
  {
    case 12:
    case 17:
    case 24:
    case 34:
    case 36:
    case 48:
    case 65:
    case 66:
    case 68:
    case 129:
    case 130:
    case 136:
      return 0;
    case 13:
    case 25:
    case 44:
    case 56:
    case 137:
    case 168:
      if (v11 == -1)
        v13 = 2;
      else
        v13 = -1;
      v14 = v10 == 4;
      goto LABEL_18;
    case 21:
    case 28:
    case 52:
    case 145:
    case 152:
    case 176:
      if (v11 == 1)
        v13 = 2;
      else
        v13 = -1;
      v14 = v10 == 6;
      goto LABEL_18;
    case 29:
    case 60:
    case 153:
    case 184:
      v17 = v9 == -1 && v12 == 6;
      v18 = v12 == 4 && v10 == 6;
      goto LABEL_52;
    case 35:
    case 38:
    case 67:
    case 70:
    case 131:
    case 134:
      if (v11 == -3)
        v13 = 2;
      else
        v13 = -1;
      v14 = v10 == 2;
      goto LABEL_18;
    case 50:
      if ((v10 & 0xFFFFFFFB) == 2)
        return 1;
      if ((v12 & 0xFFFFFFFB) != 2)
        __assert_rtn("heal", "Contours.c", 213, "(endpoint2 == 6)|| (endpoint2 == 2)");
      return 2;
    case 76:
      result = 1;
      if (v9 != -1 && v9 != 3)
      {
        result = 2;
        if (v11 != -1 && v11 != 3)
          __assert_rtn("heal", "Contours.c", 207, "(endpoint2 == 4)|| (endpoint2 == 8)");
      }
      return result;
    case 81:
      if ((v9 | 2) == 3)
        return 1;
      if ((v11 | 2) != 3)
        __assert_rtn("heal", "Contours.c", 210, "(endpoint2 == 8)|| (endpoint2 == 6)");
      return 2;
    case 97:
    case 98:
    case 100:
    case 193:
    case 194:
    case 196:
      if (v11 == 3)
        v13 = 2;
      else
        v13 = -1;
      v14 = v10 == 8;
LABEL_18:
      if (v14)
        return 1;
      else
        return v13;
    case 99:
    case 102:
    case 195:
      v17 = v9 == -3 && v12 == 8;
      v18 = v12 == 2 && v10 == 8;
LABEL_52:
      if (v18 || v17)
        return 3;
      else
        return 0xFFFFFFFFLL;
    case 138:
      if ((v9 | 2) == 0xFFFFFFFF)
        return 1;
      if ((v11 | 2) != 0xFFFFFFFF)
        __assert_rtn("heal", "Contours.c", 216, "(endpoint2 == 2)|| (endpoint2 == 4)");
      return 2;
    default:
      return 0xFFFFFFFFLL;
  }
}

uint64_t testJoin(__int16 *a1, uint64_t a2, uint64_t a3, _WORD *a4)
{
  uint64_t v4;
  uint64_t v5;
  __int16 v6;
  __int16 v7;
  uint64_t v8;
  __int16 v9;
  uint64_t v10;
  int v11;
  uint64_t n;
  uint64_t i;
  uint64_t ii;
  uint64_t jj;
  uint64_t kk;
  uint64_t j;
  uint64_t k;
  uint64_t m;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  _BYTE v24[44];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  v5 = a1[1];
  v6 = 3 * (v5 - a1[3]) + v4 - a1[2];
  if ((unsigned __int16)(v6 - 5) <= 0xFFF6u)
    __assert_rtn("testJoin", "Contours.c", 427, "(orn >= 0) && (orn <= 8)");
  v7 = *a1;
  v8 = a2 + 2 * v4;
  v9 = a1[1];
  v10 = a3 << 32;
  v11 = *(__int16 *)(v8 + (((a3 << 32) * v5) >> 31));
  switch(v6)
  {
    case 0:
      __assert_rtn("testJoin", "Contours.c", 443, "orn != 4");
    case 1:
      for (i = 0; i != 11; ++i)
      {
        *(_WORD *)&v24[2 * i + 22] = v7 - testJoin_sy[i];
        *(_WORD *)&v24[2 * i] = v9 + testJoin_sx[i];
      }
      break;
    case 2:
      for (j = 0; j != 11; ++j)
      {
        *(_WORD *)&v24[2 * j + 22] = v7 + testJoin_rx[j];
        *(_WORD *)&v24[2 * j] = v9 - testJoin_ry[j];
      }
      break;
    case 3:
      for (k = 0; k != 11; ++k)
      {
        *(_WORD *)&v24[2 * k + 22] = v7 + testJoin_sx[k];
        *(_WORD *)&v24[2 * k] = v9 - testJoin_sy[k];
      }
      break;
    case 4:
      for (m = 0; m != 11; ++m)
      {
        *(_WORD *)&v24[2 * m + 22] = v7 - testJoin_rx[m];
        *(_WORD *)&v24[2 * m] = v9 - testJoin_ry[m];
      }
      break;
    default:
      switch(v6)
      {
        case -4:
          for (n = 0; n != 11; ++n)
          {
            *(_WORD *)&v24[2 * n + 22] = v7 + testJoin_rx[n];
            *(_WORD *)&v24[2 * n] = v9 + testJoin_ry[n];
          }
          break;
        case -3:
          for (ii = 0; ii != 11; ++ii)
          {
            *(_WORD *)&v24[2 * ii + 22] = v7 + testJoin_sx[ii];
            *(_WORD *)&v24[2 * ii] = v9 + testJoin_sy[ii];
          }
          break;
        case -2:
          for (jj = 0; jj != 11; ++jj)
          {
            *(_WORD *)&v24[2 * jj + 22] = v7 - testJoin_rx[jj];
            *(_WORD *)&v24[2 * jj] = v9 + testJoin_ry[jj];
          }
          break;
        case -1:
          for (kk = 0; kk != 11; ++kk)
          {
            *(_WORD *)&v24[2 * kk + 22] = v7 + testJoin_sy[kk];
            *(_WORD *)&v24[2 * kk] = v9 + testJoin_sx[kk];
          }
          break;
        default:
          goto LABEL_28;
      }
      break;
  }
LABEL_28:
  v20 = 0;
  result = 0;
  do
  {
    v22 = *(__int16 *)&v24[v20 + 22];
    v23 = (v10 * *(__int16 *)&v24[v20]) >> 31;
    if (*(_WORD *)(a2 + 2 * v22 + v23))
    {
      if ((_DWORD)result)
        goto LABEL_35;
      v7 = *(_WORD *)&v24[v20 + 22];
      v9 = *(_WORD *)&v24[v20];
      result = *(__int16 *)(a2 + 2 * v22 + v23);
    }
    v20 += 2;
  }
  while (v20 != 22);
  if ((_DWORD)result == v11 || (int)result <= 0)
  {
LABEL_35:
    v7 = 0;
    v9 = 0;
    result = 0;
  }
  *a4 = v7;
  a4[1] = v9;
  return result;
}

int8x16_t canonicalizeQuad(uint64_t a1, float a2)
{
  int8x16_t result;
  uint64_t v3;
  float *v4;
  int v5;
  float v6;
  float v7;
  uint64_t v8;
  __int128 v9;

  if (a2 < 0.0)
  {
    result = vextq_s8(*(int8x16_t *)a1, *(int8x16_t *)a1, 8uLL);
    *(int8x16_t *)a1 = vextq_s8(*(int8x16_t *)(a1 + 16), *(int8x16_t *)(a1 + 16), 8uLL);
    *(int8x16_t *)(a1 + 16) = result;
  }
  v3 = 0;
  v4 = (float *)(a1 + 4);
  v5 = -1;
  result.i32[0] = 1399379109;
  do
  {
    v6 = *v4;
    v7 = (float)(v6 * v6) + (float)(*(v4 - 1) * *(v4 - 1));
    if (v7 <= *(float *)result.i32 && (v7 != *(float *)result.i32 || v6 < *(float *)(a1 + 8 * v5 + 4)))
    {
      *(float *)result.i32 = (float)(v6 * v6) + (float)(*(v4 - 1) * *(v4 - 1));
      v5 = v3;
    }
    ++v3;
    v4 += 2;
  }
  while (v3 != 4);
  switch(v5)
  {
    case 1:
      result.i64[0] = *(_QWORD *)a1;
      v9 = *(_OWORD *)(a1 + 8);
      *(_QWORD *)(a1 + 16) = *(_QWORD *)(a1 + 24);
      *(_OWORD *)a1 = v9;
      *(_QWORD *)(a1 + 24) = result.i64[0];
      break;
    case 2:
      result = *(int8x16_t *)a1;
      *(_OWORD *)a1 = *(_OWORD *)(a1 + 16);
      *(int8x16_t *)(a1 + 16) = result;
      break;
    case 3:
      v8 = *(_QWORD *)(a1 + 16);
      *(_OWORD *)(a1 + 8) = *(_OWORD *)a1;
      result.i64[0] = *(_QWORD *)(a1 + 24);
      *(_QWORD *)(a1 + 24) = v8;
      *(_QWORD *)a1 = result.i64[0];
      break;
  }
  return result;
}

uint64_t **std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(uint64_t **a1, int a2, _DWORD *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  int v8;
  _DWORD *v9;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = operator new(0x48uLL);
    v9[8] = *a3;
    *((_QWORD *)v9 + 6) = 0;
    *((_QWORD *)v9 + 7) = 0;
    *((_QWORD *)v9 + 5) = 0;
    *((_BYTE *)v9 + 64) = 0;
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at(a1, (uint64_t)v7, v6, (uint64_t *)v9);
    return (uint64_t **)v9;
  }
  return v7;
}

uint64_t vision::mod::LandmarkDetectorDNN_Options::LandmarkDetectorDNN_Options(uint64_t a1, int a2)
{
  _DWORD *v3;
  uint64_t **v4;
  uint64_t **v5;
  uint64_t **v6;
  uint64_t **v7;
  uint64_t **v8;
  uint64_t **v9;
  uint64_t **v10;
  uint64_t **v11;
  uint64_t **v12;
  uint64_t **v13;
  uint64_t **v14;
  uint64_t **v15;
  uint64_t **v16;
  uint64_t **v17;
  uint64_t **v18;
  uint64_t **v19;
  uint64_t **v20;
  char *v21;
  uint64_t **v22;
  char *v23;
  uint64_t **v24;
  uint64_t **v25;
  uint64_t **v26;
  uint64_t **v27;
  uint64_t **v28;
  uint64_t **v29;
  uint64_t **v30;
  uint64_t **v31;
  uint64_t **v32;
  uint64_t **v33;
  uint64_t **v34;
  uint64_t **v35;
  uint64_t **v36;
  uint64_t **v37;
  char *v38;
  uint64_t **v39;
  char *v40;
  uint64_t **v41;
  char *v42;
  _QWORD *exception;
  int v45;

  *(_BYTE *)a1 = a2;
  *(_OWORD *)(a1 + 4) = xmmword_1A15FB420;
  *(_QWORD *)(a1 + 24) = 0;
  v3 = (_DWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 48) = a1 + 56;
  v4 = (uint64_t **)(a1 + 48);
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 72) = a1 + 80;
  v5 = (uint64_t **)(a1 + 72);
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 96) = a1 + 104;
  v6 = (uint64_t **)(a1 + 96);
  *(_QWORD *)(a1 + 112) = 0;
  if (a2 == 2)
  {
    *(_BYTE *)(a1 + 47) = 5;
    *v3 = 1734438249;
    *(_BYTE *)(a1 + 28) = 101;
    *(_BYTE *)(a1 + 29) = 0;
    v45 = 1;
    v22 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>((uint64_t **)(a1 + 48), 1, &v45);
    if (*((char *)v22 + 63) < 0)
    {
      v22[6] = (uint64_t *)12;
      v23 = (char *)v22[5];
    }
    else
    {
      v23 = (char *)(v22 + 5);
      *((_BYTE *)v22 + 63) = 12;
    }
    strcpy(v23, "landmarks_63");
    v45 = 1;
    *((_BYTE *)std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v4, 1, &v45)+ 64) = 0;
    v45 = 1;
    v33 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v5, 1, &v45);
    v34 = v33 + 5;
    if (*((char *)v33 + 63) < 0)
      operator delete(*v34);
    *v34 = 0;
    v34[1] = 0;
    v34[2] = 0;
    v45 = 1;
    *((_BYTE *)std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v5, 1, &v45)+ 64) = 0;
    v45 = 1;
    v35 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v6, 1, &v45);
    v36 = v35 + 5;
    if (*((char *)v35 + 63) < 0)
      operator delete(*v36);
    *v36 = 0;
    v36[1] = 0;
    v36[2] = 0;
    v45 = 1;
    *((_BYTE *)std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v6, 1, &v45)+ 64) = 0;
    v45 = 2;
    v37 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v4, 2, &v45);
    if (*((char *)v37 + 63) < 0)
    {
      v37[6] = (uint64_t *)12;
      v38 = (char *)v37[5];
    }
    else
    {
      v38 = (char *)(v37 + 5);
      *((_BYTE *)v37 + 63) = 12;
    }
    strcpy(v38, "landmarks_76");
    v45 = 2;
    *((_BYTE *)std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v4, 2, &v45)+ 64) = 1;
    v45 = 2;
    v39 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v5, 2, &v45);
    if (*((char *)v39 + 63) < 0)
    {
      v39[6] = (uint64_t *)10;
      v40 = (char *)v39[5];
    }
    else
    {
      v40 = (char *)(v39 + 5);
      *((_BYTE *)v39 + 63) = 10;
    }
    strcpy(v40, "confidence");
    v45 = 2;
    *((_BYTE *)std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v5, 2, &v45)+ 64) = 0;
    v45 = 2;
    v41 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v6, 2, &v45);
    if (*((char *)v41 + 63) < 0)
    {
      v41[6] = (uint64_t *)9;
      v42 = (char *)v41[5];
    }
    else
    {
      v42 = (char *)(v41 + 5);
      *((_BYTE *)v41 + 63) = 9;
    }
    strcpy(v42, "occlusion");
    v45 = 2;
    v19 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v6, 2, &v45);
  }
  else
  {
    if (a2 == 1)
    {
      *(_BYTE *)(a1 + 47) = 5;
      *v3 = 1734438249;
      *(_BYTE *)(a1 + 28) = 101;
      *(_BYTE *)(a1 + 29) = 0;
      v45 = 1;
      v20 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>((uint64_t **)(a1 + 48), 1, &v45);
      if (*((char *)v20 + 63) < 0)
      {
        v20[6] = (uint64_t *)9;
        v21 = (char *)v20[5];
      }
      else
      {
        v21 = (char *)(v20 + 5);
        *((_BYTE *)v20 + 63) = 9;
      }
      strcpy(v21, "landmarks");
      v45 = 1;
      *((_BYTE *)std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v4, 1, &v45)+ 64) = 0;
      v45 = 1;
      v24 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v5, 1, &v45);
      v25 = v24 + 5;
      if (*((char *)v24 + 63) < 0)
        operator delete(*v25);
      *v25 = 0;
      v25[1] = 0;
      v25[2] = 0;
      v45 = 1;
      *((_BYTE *)std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v5, 1, &v45)+ 64) = 0;
      v45 = 1;
      v26 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v6, 1, &v45);
      v27 = v26 + 5;
      if (*((char *)v26 + 63) < 0)
        operator delete(*v27);
      *v27 = 0;
      v27[1] = 0;
      v27[2] = 0;
      v45 = 1;
      *((_BYTE *)std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v6, 1, &v45)+ 64) = 0;
      v45 = 2;
      v28 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v4, 2, &v45);
      v29 = v28 + 5;
      if (*((char *)v28 + 63) < 0)
        operator delete(*v29);
      *v29 = 0;
      v29[1] = 0;
      v29[2] = 0;
      v45 = 2;
      *((_BYTE *)std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v4, 2, &v45)+ 64) = 0;
      v45 = 2;
      v30 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v5, 2, &v45);
      v31 = v30 + 5;
      if (*((char *)v30 + 63) < 0)
        operator delete(*v31);
      *v31 = 0;
      v31[1] = 0;
      v31[2] = 0;
      v45 = 2;
      *((_BYTE *)std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v5, 2, &v45)+ 64) = 0;
      v45 = 2;
      v32 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v6, 2, &v45);
      v18 = v32 + 5;
      if (*((char *)v32 + 63) < 0)
        operator delete(*v18);
    }
    else
    {
      if (a2)
      {
        exception = __cxa_allocate_exception(8uLL);
        *exception = 2935;
        __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
      }
      *(_QWORD *)v3 = 0;
      *(_QWORD *)(a1 + 32) = 0;
      *(_QWORD *)(a1 + 40) = 0;
      v45 = 1;
      v7 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>((uint64_t **)(a1 + 48), 1, &v45);
      v8 = v7 + 5;
      if (*((char *)v7 + 63) < 0)
        operator delete(*v8);
      *v8 = 0;
      v8[1] = 0;
      v8[2] = 0;
      v45 = 1;
      *((_BYTE *)std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v4, 1, &v45)+ 64) = 0;
      v45 = 1;
      v9 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v5, 1, &v45);
      v10 = v9 + 5;
      if (*((char *)v9 + 63) < 0)
        operator delete(*v10);
      *v10 = 0;
      v10[1] = 0;
      v10[2] = 0;
      v45 = 1;
      *((_BYTE *)std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v5, 1, &v45)+ 64) = 0;
      v45 = 1;
      v11 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v6, 1, &v45);
      v12 = v11 + 5;
      if (*((char *)v11 + 63) < 0)
        operator delete(*v12);
      *v12 = 0;
      v12[1] = 0;
      v12[2] = 0;
      v45 = 1;
      *((_BYTE *)std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v6, 1, &v45)+ 64) = 0;
      v45 = 2;
      v13 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v4, 2, &v45);
      v14 = v13 + 5;
      if (*((char *)v13 + 63) < 0)
        operator delete(*v14);
      *v14 = 0;
      v14[1] = 0;
      v14[2] = 0;
      v45 = 2;
      *((_BYTE *)std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v4, 2, &v45)+ 64) = 0;
      v45 = 2;
      v15 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v5, 2, &v45);
      v16 = v15 + 5;
      if (*((char *)v15 + 63) < 0)
        operator delete(*v16);
      *v16 = 0;
      v16[1] = 0;
      v16[2] = 0;
      v45 = 2;
      *((_BYTE *)std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v5, 2, &v45)+ 64) = 0;
      v45 = 2;
      v17 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v6, 2, &v45);
      v18 = v17 + 5;
      if (*((char *)v17 + 63) < 0)
        operator delete(*v18);
    }
    *v18 = 0;
    v18[1] = 0;
    v18[2] = 0;
    v45 = 2;
    v19 = std::__tree<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::__map_value_compare<vision::mod::_constellationType,std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>,std::less<vision::mod::_constellationType>,true>,std::allocator<std::__value_type<vision::mod::_constellationType,std::pair<std::string,BOOL>>>>::__emplace_unique_key_args<vision::mod::_constellationType,std::piecewise_construct_t const&,std::tuple<vision::mod::_constellationType&&>,std::tuple<>>(v6, 2, &v45);
  }
  *((_BYTE *)v19 + 64) = 0;
  return a1;
}

void sub_1A149C088(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;

  std::__tree<std::__value_type<unsigned char,std::string>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,std::string>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,std::string>>>::destroy(*(char **)(v1 + 104));
  std::__tree<std::__value_type<unsigned char,std::string>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,std::string>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,std::string>>>::destroy(*(char **)(v1 + 80));
  std::__tree<std::__value_type<unsigned char,std::string>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,std::string>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,std::string>>>::destroy(*(char **)(v1 + 56));
  if (*(char *)(v1 + 47) < 0)
    operator delete(*v2);
  _Unwind_Resume(a1);
}

void vision::mod::LandmarkDetectorDNN_Options::getBlobNamesOutput(std::vector<std::string> *this, uint64_t **a2, int a3)
{
  _QWORD *v6;
  char v7;
  uint64_t v8;
  char v9;
  int v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t *v13;
  std::vector<std::string>::pointer end;
  std::vector<std::string>::pointer v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t *v18;
  std::vector<std::string>::pointer v19;
  std::vector<std::string>::pointer v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t *v23;
  std::vector<std::string>::pointer v24;
  std::vector<std::string>::pointer v25;

  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  v6 = operator new(8uLL);
  v7 = 0;
  v8 = 0;
  *v6 = 0x200000001;
  do
  {
    v9 = v7;
    v10 = *((_DWORD *)v6 + v8);
    v11 = std::map<vision::mod::_constellationType,std::pair<std::string,BOOL>>::at(a2[7], v10);
    v12 = *((unsigned __int8 *)v11 + 23);
    if ((v12 & 0x80u) != 0)
      v12 = v11[1];
    if (v12
      && *((unsigned __int8 *)std::map<vision::mod::_constellationType,std::pair<std::string,BOOL>>::at(a2[7], v10) + 24) == a3)
    {
      v13 = std::map<vision::mod::_constellationType,std::pair<std::string,BOOL>>::at(a2[7], v10);
      end = this->__end_;
      if (end >= this->__end_cap_.__value_)
      {
        v15 = std::vector<std::string>::__push_back_slow_path<std::string const&>(this, (__int128 *)v13);
      }
      else
      {
        std::vector<std::string>::__construct_one_at_end[abi:ne180100]<std::string const&>((uint64_t)this, (__int128 *)v13);
        v15 = end + 1;
      }
      this->__end_ = v15;
    }
    v16 = std::map<vision::mod::_constellationType,std::pair<std::string,BOOL>>::at(a2[10], v10);
    v17 = *((unsigned __int8 *)v16 + 23);
    if ((v17 & 0x80u) != 0)
      v17 = v16[1];
    if (v17
      && *((unsigned __int8 *)std::map<vision::mod::_constellationType,std::pair<std::string,BOOL>>::at(a2[10], v10) + 24) == a3)
    {
      v18 = std::map<vision::mod::_constellationType,std::pair<std::string,BOOL>>::at(a2[10], v10);
      v19 = this->__end_;
      if (v19 >= this->__end_cap_.__value_)
      {
        v20 = std::vector<std::string>::__push_back_slow_path<std::string const&>(this, (__int128 *)v18);
      }
      else
      {
        std::vector<std::string>::__construct_one_at_end[abi:ne180100]<std::string const&>((uint64_t)this, (__int128 *)v18);
        v20 = v19 + 1;
      }
      this->__end_ = v20;
    }
    v21 = std::map<vision::mod::_constellationType,std::pair<std::string,BOOL>>::at(a2[13], v10);
    v22 = *((unsigned __int8 *)v21 + 23);
    if ((v22 & 0x80u) != 0)
      v22 = v21[1];
    if (v22
      && *((unsigned __int8 *)std::map<vision::mod::_constellationType,std::pair<std::string,BOOL>>::at(a2[13], v10) + 24) == a3)
    {
      v23 = std::map<vision::mod::_constellationType,std::pair<std::string,BOOL>>::at(a2[13], v10);
      v24 = this->__end_;
      if (v24 >= this->__end_cap_.__value_)
      {
        v25 = std::vector<std::string>::__push_back_slow_path<std::string const&>(this, (__int128 *)v23);
      }
      else
      {
        std::vector<std::string>::__construct_one_at_end[abi:ne180100]<std::string const&>((uint64_t)this, (__int128 *)v23);
        v25 = v24 + 1;
      }
      this->__end_ = v25;
    }
    v7 = 1;
    v8 = 1;
  }
  while ((v9 & 1) == 0);
  operator delete(v6);
}

void sub_1A149C29C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t *std::map<vision::mod::_constellationType,std::pair<std::string,BOOL>>::at(uint64_t *a1, int a2)
{
  int v2;

  if (!a1)
LABEL_8:
    std::__throw_out_of_range[abi:ne180100]("map::at:  key not found");
  while (1)
  {
    while (1)
    {
      v2 = *((_DWORD *)a1 + 8);
      if (v2 <= a2)
        break;
      a1 = (uint64_t *)*a1;
      if (!a1)
        goto LABEL_8;
    }
    if (v2 >= a2)
      return a1 + 5;
    a1 = (uint64_t *)a1[1];
    if (!a1)
      goto LABEL_8;
  }
}

void vision::mod::LandmarkDetectorDNN_Options::getBlobNamesOutput(std::vector<std::string> *this, uint64_t **a2)
{
  std::vector<std::string>::pointer begin;
  std::string *end;
  int64_t v6;
  std::string *value;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  std::string *v13;
  std::string *v14;
  std::string *v15;
  std::vector<std::string>::pointer v16;
  __int128 v17;
  std::string *v18;
  uint64_t v19;
  __int128 *v20;
  __int128 v21;
  std::string *v22;
  uint64_t v23;
  std::string *v24;
  uint64_t v25;
  __int128 v26;
  std::string *v27;
  std::__split_buffer<std::string>::pointer v28;
  __int128 v29;
  __int128 v30;
  std::string *v31;
  std::string *v32;
  std::vector<std::string> v33;
  std::__split_buffer<std::string> v34;
  _QWORD v35[3];
  char v36;
  std::__split_buffer<std::string>::pointer v37;
  std::__split_buffer<std::string>::pointer v38;

  vision::mod::LandmarkDetectorDNN_Options::getBlobNamesOutput(this, a2, 0);
  vision::mod::LandmarkDetectorDNN_Options::getBlobNamesOutput(&v33, a2, 1);
  begin = v33.__begin_;
  if ((char *)v33.__end_ - (char *)v33.__begin_ >= 1)
  {
    end = this->__end_;
    v6 = v33.__end_ - v33.__begin_;
    value = this->__end_cap_.__value_;
    if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * (((char *)value - (char *)end) >> 3)) >= v6)
    {
      if (v6 <= 0)
      {
        v13 = &v33.__begin_[v6];
        v14 = &end[v6];
        v15 = &end[-v6];
        v16 = this->__end_;
        if (v15 < end)
        {
          v16 = this->__end_;
          do
          {
            v17 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
            v16->__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v16->__r_.__value_.__l.__data_ = v17;
            ++v16;
            v15->__r_.__value_.__l.__size_ = 0;
            v15->__r_.__value_.__r.__words[2] = 0;
            v15->__r_.__value_.__r.__words[0] = 0;
            ++v15;
          }
          while (v15 < end);
        }
        this->__end_ = v16;
        if (end != v14)
        {
          v18 = end - 1;
          v19 = 8 * (((char *)end - (char *)v14) >> 3);
          do
          {
            if (SHIBYTE(v18->__r_.__value_.__r.__words[2]) < 0)
              operator delete(v18->__r_.__value_.__l.__data_);
            v20 = (__int128 *)((char *)&end[-1] + v19);
            v21 = *v20;
            v18->__r_.__value_.__r.__words[2] = end->__r_.__value_.__r.__words[(unint64_t)v19 / 8 - 1];
            *(_OWORD *)&v18->__r_.__value_.__l.__data_ = v21;
            --v18;
            end->__r_.__value_.__s.__data_[v19 - 1] = 0;
            *(_BYTE *)v20 = 0;
            v19 -= 24;
          }
          while (v19);
        }
        while (begin != v13)
          std::string::operator=(end++, begin++);
      }
      else
      {
        this->__end_ = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>((uint64_t)&this->__end_cap_, (__int128 *)v33.__begin_, (__int128 *)v33.__end_, this->__end_);
      }
    }
    else
    {
      v8 = 0xAAAAAAAAAAAAAAABLL * (((char *)end - (char *)this->__begin_) >> 3);
      v9 = v8 + v6;
      if (v8 + v6 > 0xAAAAAAAAAAAAAAALL)
        std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
      v10 = 0xAAAAAAAAAAAAAAABLL * (((char *)value - (char *)this->__begin_) >> 3);
      if (2 * v10 > v9)
        v9 = 2 * v10;
      if (v10 >= 0x555555555555555)
        v11 = 0xAAAAAAAAAAAAAAALL;
      else
        v11 = v9;
      v34.__end_cap_.__value_ = (std::allocator<std::string> *)&this->__end_cap_;
      if (v11)
        v11 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(v11);
      else
        v12 = 0;
      v22 = (std::string *)(v11 + 24 * v8);
      v34.__first_ = (std::__split_buffer<std::string>::pointer)v11;
      v34.__begin_ = v22;
      v34.__end_ = v22;
      v34.__end_cap_.__value_ = (std::string *)(v11 + 24 * v12);
      v23 = 3 * v6;
      v24 = &v22[v6];
      v25 = 8 * v23;
      do
      {
        if (SHIBYTE(begin->__r_.__value_.__r.__words[2]) < 0)
        {
          std::string::__init_copy_ctor_external(v22, begin->__r_.__value_.__l.__data_, begin->__r_.__value_.__l.__size_);
        }
        else
        {
          v26 = *(_OWORD *)&begin->__r_.__value_.__l.__data_;
          v22->__r_.__value_.__r.__words[2] = begin->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v22->__r_.__value_.__l.__data_ = v26;
        }
        ++v22;
        ++begin;
        v25 -= 24;
      }
      while (v25);
      v34.__end_ = v24;
      v34.__begin_ = (std::__split_buffer<std::string>::pointer)std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::string>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>>((uint64_t)&this->__end_cap_, (uint64_t)end, (uint64_t)end, (uint64_t)this->__begin_, (uint64_t)this->__begin_, (uint64_t)v34.__begin_, (uint64_t)v34.__begin_);
      v27 = this->__end_;
      v28 = v34.__end_;
      v37 = v34.__end_;
      v38 = v34.__end_;
      v35[0] = &this->__end_cap_;
      v35[1] = &v37;
      v35[2] = &v38;
      if (end != v27)
      {
        do
        {
          v29 = *(_OWORD *)&end->__r_.__value_.__l.__data_;
          v28->__r_.__value_.__r.__words[2] = end->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v28->__r_.__value_.__l.__data_ = v29;
          ++v28;
          end->__r_.__value_.__l.__size_ = 0;
          end->__r_.__value_.__r.__words[2] = 0;
          end->__r_.__value_.__r.__words[0] = 0;
          ++end;
        }
        while (end != v27);
        v38 = v28;
      }
      v36 = 1;
      std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::string*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v35);
      v30 = *(_OWORD *)&this->__begin_;
      v31 = v34.__end_cap_.__value_;
      this->__begin_ = v34.__begin_;
      this->__end_ = v28;
      *(_OWORD *)&v34.__begin_ = v30;
      v32 = this->__end_cap_.__value_;
      this->__end_cap_.__value_ = v31;
      v34.__end_cap_.__value_ = v32;
      v34.__first_ = (std::__split_buffer<std::string>::pointer)v30;
      std::__split_buffer<std::string>::~__split_buffer(&v34);
    }
  }
  v34.__first_ = (std::__split_buffer<std::string>::pointer)&v33;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v34);
}

void sub_1A149C644(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, std::__split_buffer<std::string> *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void **a17)
{
  uint64_t v17;
  uint64_t v18;

  *(_QWORD *)(v17 + 8) = v18;
  a17 = (void **)&a9;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&a17);
  a17 = (void **)v17;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&a17);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::FaceIDKmeansParams::serialize()
{
  _QWORD *v0;
  _QWORD *v1;
  uint64_t *v2;
  _QWORD *v4;
  _QWORD *v5;

  v0 = (_QWORD *)std::ostream::write();
  if ((*((_BYTE *)v0 + *(_QWORD *)(*v0 - 24) + 32) & 5) != 0
    || (v1 = (_QWORD *)std::ostream::write(), (*((_BYTE *)v1 + *(_QWORD *)(*v1 - 24) + 32) & 5) != 0))
  {
    v2 = &CVML_status_IOError;
  }
  else
  {
    v4 = (_QWORD *)std::ostream::write();
    v2 = &CVML_status_IOError;
    if ((*((_BYTE *)v4 + *(_QWORD *)(*v4 - 24) + 32) & 5) == 0)
    {
      v5 = (_QWORD *)std::ostream::write();
      if ((*((_BYTE *)v5 + *(_QWORD *)(*v5 - 24) + 32) & 5) == 0)
        v2 = &CVML_status_ok;
    }
  }
  return (*v2 + 128) | 0x1E00;
}

uint64_t vision::mod::FaceIDKmeansParams::deserialize()
{
  _QWORD *v0;
  _QWORD *v1;
  uint64_t *v2;
  _QWORD *v4;
  _QWORD *v5;

  v0 = (_QWORD *)std::istream::read();
  if ((*((_BYTE *)v0 + *(_QWORD *)(*v0 - 24) + 32) & 5) != 0
    || (v1 = (_QWORD *)std::istream::read(), (*((_BYTE *)v1 + *(_QWORD *)(*v1 - 24) + 32) & 5) != 0))
  {
    v2 = &CVML_status_IOError;
  }
  else
  {
    v4 = (_QWORD *)std::istream::read();
    v2 = &CVML_status_IOError;
    if ((*((_BYTE *)v4 + *(_QWORD *)(*v4 - 24) + 32) & 5) == 0)
    {
      v5 = (_QWORD *)std::istream::read();
      if ((*((_BYTE *)v5 + *(_QWORD *)(*v5 - 24) + 32) & 5) == 0)
        v2 = &CVML_status_ok;
    }
  }
  return (*v2 + 128) | 0x1E00;
}

double vision::mod::FaceIDModel::FaceIDModel(vision::mod::FaceIDModel *this, int a2, int a3, int a4, int a5, float a6, int a7, int a8)
{
  double result;

  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_DWORD *)this + 8) = 1065353216;
  *((_DWORD *)this + 10) = a2;
  *((_DWORD *)this + 11) = a4;
  *((_DWORD *)this + 12) = a3;
  *((_DWORD *)this + 13) = a5;
  *((_DWORD *)this + 14) = a8;
  *((float *)this + 15) = a6;
  *((_DWORD *)this + 16) = a7;
  *(_QWORD *)&result = 0x12C0000000ALL;
  *(_QWORD *)((char *)this + 68) = 0x12C0000000ALL;
  *((_QWORD *)this + 10) = 0x3F1A36E2EB1C432DLL;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *((_QWORD *)this + 15) = 0;
  *((_BYTE *)this + 128) = 1;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *((_QWORD *)this + 21) = 0;
  *((_BYTE *)this + 176) = 1;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *((_DWORD *)this + 54) = 1065353216;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_DWORD *)this + 64) = 1065353216;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *((_BYTE *)this + 312) = 1;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((_OWORD *)this + 23) = 0u;
  *((_BYTE *)this + 384) = 1;
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 408) = 0u;
  *((_BYTE *)this + 424) = 1;
  *((_OWORD *)this + 27) = 0u;
  *((_OWORD *)this + 28) = 0u;
  *((_BYTE *)this + 464) = 1;
  *(_OWORD *)((char *)this + 472) = 0u;
  *(_OWORD *)((char *)this + 488) = 0u;
  *((_BYTE *)this + 504) = 1;
  *((_OWORD *)this + 32) = 0u;
  *((_OWORD *)this + 33) = 0u;
  *((_BYTE *)this + 544) = 1;
  *(_OWORD *)((char *)this + 552) = 0u;
  *(_OWORD *)((char *)this + 568) = 0u;
  *((_BYTE *)this + 584) = 1;
  *((_QWORD *)this + 76) = 0;
  *((_QWORD *)this + 74) = 0;
  *((_QWORD *)this + 75) = 0;
  return result;
}

_QWORD *std::__hash_table<std::__hash_value_type<long long,int>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,int>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,int>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,int>>>::find<long long>(_QWORD *a1, unint64_t a2)
{
  int8x8_t v2;
  uint8x8_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *result;
  unint64_t v7;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = (uint8x8_t)vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    v4 = a2;
    if (*(_QWORD *)&v2 <= a2)
      v4 = a2 % *(_QWORD *)&v2;
  }
  else
  {
    v4 = (*(_QWORD *)&v2 - 1) & a2;
  }
  v5 = *(_QWORD **)(*a1 + 8 * v4);
  if (!v5)
    return 0;
  result = (_QWORD *)*v5;
  if (*v5)
  {
    do
    {
      v7 = result[1];
      if (v7 == a2)
      {
        if (result[2] == a2)
          return result;
      }
      else
      {
        if (v3.u32[0] > 1uLL)
        {
          if (v7 >= *(_QWORD *)&v2)
            v7 %= *(_QWORD *)&v2;
        }
        else
        {
          v7 &= *(_QWORD *)&v2 - 1;
        }
        if (v7 != v4)
          return 0;
      }
      result = (_QWORD *)*result;
    }
    while (result);
  }
  return result;
}

_QWORD *std::__hash_table<std::__hash_value_type<int,std::vector<int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<int>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t *a1, int a2, _DWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  void **v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  int8x8_t prime;
  void *v19;
  void *v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;
  uint8x8_t v24;
  unint64_t v25;
  uint8x8_t v26;
  uint64_t v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  unint64_t v32;
  void *v34;

  v6 = a2;
  v7 = a1[1];
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = (v7 - 1) & a2;
    }
    v9 = *(void ***)(*a1 + 8 * v3);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2)
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  v12 = a1 + 2;
  v10 = operator new(0x30uLL);
  *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v10[4] = 0;
  v10[5] = 0;
  v10[3] = 0;
  v13 = (float)(unint64_t)(a1[3] + 1);
  v14 = *((float *)a1 + 8);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    v15 = 1;
    if (v7 >= 3)
      v15 = (v7 & (v7 - 1)) != 0;
    v16 = v15 | (2 * v7);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      prime = (int8x8_t)v17;
    else
      prime = (int8x8_t)v16;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v7 = a1[1];
    }
    if (*(_QWORD *)&prime > v7)
      goto LABEL_30;
    if (*(_QWORD *)&prime < v7)
    {
      v25 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v7 < 3 || (v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
      {
        v25 = std::__next_prime(v25);
      }
      else
      {
        v27 = 1 << -(char)__clz(v25 - 1);
        if (v25 >= 2)
          v25 = v27;
      }
      if (*(_QWORD *)&prime <= v25)
        prime = (int8x8_t)v25;
      if (*(_QWORD *)&prime >= v7)
      {
        v7 = a1[1];
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v19 = operator new(8 * *(_QWORD *)&prime);
          v20 = (void *)*a1;
          *a1 = (uint64_t)v19;
          if (v20)
            operator delete(v20);
          v21 = 0;
          a1[1] = (uint64_t)prime;
          do
            *(_QWORD *)(*a1 + 8 * v21++) = 0;
          while (*(_QWORD *)&prime != v21);
          v22 = (_QWORD *)*v12;
          if (*v12)
          {
            v23 = v22[1];
            v24 = (uint8x8_t)vcnt_s8(prime);
            v24.i16[0] = vaddlv_u8(v24);
            if (v24.u32[0] > 1uLL)
            {
              if (v23 >= *(_QWORD *)&prime)
                v23 %= *(_QWORD *)&prime;
            }
            else
            {
              v23 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*a1 + 8 * v23) = v12;
            v28 = (_QWORD *)*v22;
            if (*v22)
            {
              do
              {
                v29 = v28[1];
                if (v24.u32[0] > 1uLL)
                {
                  if (v29 >= *(_QWORD *)&prime)
                    v29 %= *(_QWORD *)&prime;
                }
                else
                {
                  v29 &= *(_QWORD *)&prime - 1;
                }
                if (v29 != v23)
                {
                  if (!*(_QWORD *)(*a1 + 8 * v29))
                  {
                    *(_QWORD *)(*a1 + 8 * v29) = v22;
                    goto LABEL_55;
                  }
                  *v22 = *v28;
                  *v28 = **(_QWORD **)(*a1 + 8 * v29);
                  **(_QWORD **)(*a1 + 8 * v29) = v28;
                  v28 = v22;
                }
                v29 = v23;
LABEL_55:
                v22 = v28;
                v28 = (_QWORD *)*v28;
                v23 = v29;
              }
              while (v28);
            }
          }
          v7 = (unint64_t)prime;
          goto LABEL_59;
        }
        v34 = (void *)*a1;
        *a1 = 0;
        if (v34)
          operator delete(v34);
        v7 = 0;
        a1[1] = 0;
      }
    }
LABEL_59:
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
  }
  v30 = *a1;
  v31 = *(_QWORD **)(*a1 + 8 * v3);
  if (v31)
  {
    *v10 = *v31;
LABEL_72:
    *v31 = v10;
    goto LABEL_73;
  }
  *v10 = *v12;
  *v12 = v10;
  *(_QWORD *)(v30 + 8 * v3) = v12;
  if (*v10)
  {
    v32 = *(_QWORD *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7)
        v32 %= v7;
    }
    else
    {
      v32 &= v7 - 1;
    }
    v31 = (_QWORD *)(*a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  ++a1[3];
  return v10;
}

void sub_1A149CE08(_Unwind_Exception *a1)
{
  _QWORD *v1;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,std::vector<unsigned int>>,void *>>>::operator()[abi:ne180100](1, v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<std::__hash_value_type<long long,int>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,int>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,int>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,int>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(float *a1, unint64_t a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v5;
  unint64_t v7;
  uint8x8_t v8;
  void **v9;
  _QWORD *v10;
  unint64_t v11;
  float v12;
  float v13;
  _BOOL8 v14;
  unint64_t v15;
  unint64_t v16;
  int8x8_t prime;
  void *v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;
  uint8x8_t v23;
  unint64_t v24;
  uint8x8_t v25;
  uint64_t v26;
  _QWORD *v27;
  unint64_t v28;
  _QWORD *v29;
  _QWORD *v30;
  unint64_t v31;
  _QWORD *v33;

  v5 = a2;
  v7 = *((_QWORD *)a1 + 1);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = (v7 - 1) & a2;
    }
    v9 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2)
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  v10 = operator new(0x20uLL);
  *v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  *((_DWORD *)v10 + 6) = 0;
  v12 = (float)(unint64_t)(*((_QWORD *)a1 + 3) + 1);
  v13 = a1[8];
  if (v7 && (float)(v13 * (float)v7) >= v12)
  {
    v5 = v3;
    goto LABEL_64;
  }
  v14 = 1;
  if (v7 >= 3)
    v14 = (v7 & (v7 - 1)) != 0;
  v15 = v14 | (2 * v7);
  v16 = vcvtps_u32_f32(v12 / v13);
  if (v15 <= v16)
    prime = (int8x8_t)v16;
  else
    prime = (int8x8_t)v15;
  if (*(_QWORD *)&prime == 1)
  {
    prime = (int8x8_t)2;
  }
  else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
  {
    prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    v7 = *((_QWORD *)a1 + 1);
  }
  if (*(_QWORD *)&prime <= v7)
  {
    if (*(_QWORD *)&prime >= v7)
      goto LABEL_60;
    v24 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
    if (v7 < 3 || (v25 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
    {
      v24 = std::__next_prime(v24);
    }
    else
    {
      v26 = 1 << -(char)__clz(v24 - 1);
      if (v24 >= 2)
        v24 = v26;
    }
    if (*(_QWORD *)&prime <= v24)
      prime = (int8x8_t)v24;
    if (*(_QWORD *)&prime >= v7)
    {
      v7 = *((_QWORD *)a1 + 1);
      goto LABEL_60;
    }
    if (!*(_QWORD *)&prime)
    {
      v33 = *(_QWORD **)a1;
      *(_QWORD *)a1 = 0;
      if (v33)
        operator delete(v33);
      v7 = 0;
      *((_QWORD *)a1 + 1) = 0;
      goto LABEL_60;
    }
  }
  if (*(_QWORD *)&prime >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  v18 = operator new(8 * *(_QWORD *)&prime);
  v19 = *(_QWORD **)a1;
  *(_QWORD *)a1 = v18;
  if (v19)
    operator delete(v19);
  v20 = 0;
  *((int8x8_t *)a1 + 1) = prime;
  do
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v20++) = 0;
  while (*(_QWORD *)&prime != v20);
  v21 = (_QWORD *)*((_QWORD *)a1 + 2);
  if (v21)
  {
    v22 = v21[1];
    v23 = (uint8x8_t)vcnt_s8(prime);
    v23.i16[0] = vaddlv_u8(v23);
    if (v23.u32[0] > 1uLL)
    {
      if (v22 >= *(_QWORD *)&prime)
        v22 %= *(_QWORD *)&prime;
    }
    else
    {
      v22 &= *(_QWORD *)&prime - 1;
    }
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v22) = a1 + 4;
    v27 = (_QWORD *)*v21;
    if (*v21)
    {
      do
      {
        v28 = v27[1];
        if (v23.u32[0] > 1uLL)
        {
          if (v28 >= *(_QWORD *)&prime)
            v28 %= *(_QWORD *)&prime;
        }
        else
        {
          v28 &= *(_QWORD *)&prime - 1;
        }
        if (v28 != v22)
        {
          if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v28))
          {
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v28) = v21;
            goto LABEL_56;
          }
          *v21 = *v27;
          *v27 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v28);
          **(_QWORD **)(*(_QWORD *)a1 + 8 * v28) = v27;
          v27 = v21;
        }
        v28 = v22;
LABEL_56:
        v21 = v27;
        v27 = (_QWORD *)*v27;
        v22 = v28;
      }
      while (v27);
    }
  }
  v7 = (unint64_t)prime;
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v5)
      v5 %= v7;
  }
  else
  {
    v5 &= v7 - 1;
  }
LABEL_64:
  v29 = *(_QWORD **)a1;
  v30 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v5);
  if (v30)
  {
    *v10 = *v30;
LABEL_72:
    *v30 = v10;
    goto LABEL_73;
  }
  *v10 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = v10;
  v29[v5] = a1 + 4;
  if (*v10)
  {
    v31 = *(_QWORD *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v31 >= v7)
        v31 %= v7;
    }
    else
    {
      v31 &= v7 - 1;
    }
    v30 = (_QWORD *)(*(_QWORD *)a1 + 8 * v31);
    goto LABEL_72;
  }
LABEL_73:
  ++*((_QWORD *)a1 + 3);
  return v10;
}

void sub_1A149D1F8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

char *vision::mod::CVMLMatrix<double,16ul>::reset(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v6;

  if (*(_BYTE *)(a1 + 40))
  {
    v6 = *(void **)a1;
    if (*(_QWORD *)a1)
      free(v6);
  }
  *(_QWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_BYTE *)(a1 + 40) = 1;
  return vision::mod::CVMLMatrix<double,16ul>::initialize_(a1, a2, a3);
}

char *vision::mod::CVMLMatrix<double,16ul>::initialize_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  char *result;
  uint64_t v8;
  std::bad_alloc *exception;
  std::bad_alloc *v10;

  v6 = ((a3 << 63 >> 63) & ((16 - 8 * (unint64_t)(a3 & 1)) >> 3)) + a3;
  result = (char *)malloc_type_calloc(8 * a2 * v6 + 15, 1uLL, 0x6E22AE6BuLL);
  if (!result)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    v10 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v10, MEMORY[0x1E0DE4EA8], MEMORY[0x1E0DE4DC0]);
  }
  v8 = 16 - (result & 0xF);
  if ((result & 0xF) == 0)
    v8 = 0;
  *(_QWORD *)a1 = result;
  *(_QWORD *)(a1 + 8) = &result[v8];
  *(_QWORD *)(a1 + 24) = a3;
  *(_QWORD *)(a1 + 32) = v6;
  *(_QWORD *)(a1 + 16) = a2;
  *(_BYTE *)(a1 + 40) = 1;
  return result;
}

_QWORD *std::__hash_table<std::__hash_value_type<int,std::pair<int,int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::pair<int,int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::pair<int,int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::pair<int,int>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(float *a1, int a2, int *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  void **v9;
  _QWORD *v10;
  unint64_t v11;
  int v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  int8x8_t prime;
  void *v19;
  _QWORD *v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;
  uint8x8_t v24;
  unint64_t v25;
  uint8x8_t v26;
  uint64_t v27;
  _QWORD *v28;
  unint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  unint64_t v32;
  _QWORD *v34;

  v6 = a2;
  v7 = *((_QWORD *)a1 + 1);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = (v7 - 1) & a2;
    }
    v9 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2)
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  v10 = operator new(0x20uLL);
  *v10 = 0;
  v10[1] = v6;
  v12 = *a3;
  *((_DWORD *)v10 + 5) = 0;
  *((_DWORD *)v10 + 6) = 0;
  *((_DWORD *)v10 + 4) = v12;
  v13 = (float)(unint64_t)(*((_QWORD *)a1 + 3) + 1);
  v14 = a1[8];
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    v15 = 1;
    if (v7 >= 3)
      v15 = (v7 & (v7 - 1)) != 0;
    v16 = v15 | (2 * v7);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      prime = (int8x8_t)v17;
    else
      prime = (int8x8_t)v16;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v7 = *((_QWORD *)a1 + 1);
    }
    if (*(_QWORD *)&prime > v7)
      goto LABEL_30;
    if (*(_QWORD *)&prime < v7)
    {
      v25 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v7 < 3 || (v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
      {
        v25 = std::__next_prime(v25);
      }
      else
      {
        v27 = 1 << -(char)__clz(v25 - 1);
        if (v25 >= 2)
          v25 = v27;
      }
      if (*(_QWORD *)&prime <= v25)
        prime = (int8x8_t)v25;
      if (*(_QWORD *)&prime >= v7)
      {
        v7 = *((_QWORD *)a1 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v19 = operator new(8 * *(_QWORD *)&prime);
          v20 = *(_QWORD **)a1;
          *(_QWORD *)a1 = v19;
          if (v20)
            operator delete(v20);
          v21 = 0;
          *((int8x8_t *)a1 + 1) = prime;
          do
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v21++) = 0;
          while (*(_QWORD *)&prime != v21);
          v22 = (_QWORD *)*((_QWORD *)a1 + 2);
          if (v22)
          {
            v23 = v22[1];
            v24 = (uint8x8_t)vcnt_s8(prime);
            v24.i16[0] = vaddlv_u8(v24);
            if (v24.u32[0] > 1uLL)
            {
              if (v23 >= *(_QWORD *)&prime)
                v23 %= *(_QWORD *)&prime;
            }
            else
            {
              v23 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = a1 + 4;
            v28 = (_QWORD *)*v22;
            if (*v22)
            {
              do
              {
                v29 = v28[1];
                if (v24.u32[0] > 1uLL)
                {
                  if (v29 >= *(_QWORD *)&prime)
                    v29 %= *(_QWORD *)&prime;
                }
                else
                {
                  v29 &= *(_QWORD *)&prime - 1;
                }
                if (v29 != v23)
                {
                  if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v29))
                  {
                    *(_QWORD *)(*(_QWORD *)a1 + 8 * v29) = v22;
                    goto LABEL_55;
                  }
                  *v22 = *v28;
                  *v28 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v29);
                  **(_QWORD **)(*(_QWORD *)a1 + 8 * v29) = v28;
                  v28 = v22;
                }
                v29 = v23;
LABEL_55:
                v22 = v28;
                v28 = (_QWORD *)*v28;
                v23 = v29;
              }
              while (v28);
            }
          }
          v7 = (unint64_t)prime;
          goto LABEL_59;
        }
        v34 = *(_QWORD **)a1;
        *(_QWORD *)a1 = 0;
        if (v34)
          operator delete(v34);
        v7 = 0;
        *((_QWORD *)a1 + 1) = 0;
      }
    }
LABEL_59:
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
  }
  v30 = *(_QWORD **)a1;
  v31 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v31)
  {
    *v10 = *v31;
LABEL_72:
    *v31 = v10;
    goto LABEL_73;
  }
  *v10 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = v10;
  v30[v3] = a1 + 4;
  if (*v10)
  {
    v32 = *(_QWORD *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7)
        v32 %= v7;
    }
    else
    {
      v32 &= v7 - 1;
    }
    v31 = (_QWORD *)(*(_QWORD *)a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  ++*((_QWORD *)a1 + 3);
  return v10;
}

void sub_1A149D700(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::CVMLMatrix<double,16ul>::ptr(_QWORD *a1, unint64_t a2)
{
  _QWORD *v3;
  std::logic_error *exception;
  std::string v5;
  uint64_t v6;
  uint64_t v7;

  if (a1[2] <= a2)
  {
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v6);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v6, (uint64_t)"row index ", 10);
    v3 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)" of ", 4);
    std::ostream::operator<<();
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>(&v5, (uint64_t)&v7);
    std::logic_error::logic_error(exception, &v5);
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
    __cxa_throw(exception, (struct type_info *)off_1E452A5D0, MEMORY[0x1E0DE42E0]);
  }
  return a1[1] + 8 * a1[4] * a2;
}

{
  _QWORD *v3;
  std::logic_error *exception;
  std::string v5;
  uint64_t v6;
  uint64_t v7;

  if (a1[2] <= a2)
  {
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v6);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v6, (uint64_t)"row index ", 10);
    v3 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)" of ", 4);
    std::ostream::operator<<();
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>(&v5, (uint64_t)&v7);
    std::logic_error::logic_error(exception, &v5);
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
    __cxa_throw(exception, (struct type_info *)off_1E452A5D0, MEMORY[0x1E0DE42E0]);
  }
  return a1[1] + 8 * a1[4] * a2;
}

void sub_1A149D7FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  void *v15;
  int v16;

  if (a14 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

uint64_t std::ostringstream::basic_ostringstream[abi:ne180100](uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  std::ios_base *v6;

  v2 = MEMORY[0x1E0DE4FE0];
  v3 = MEMORY[0x1E0DE4FE0] + 64;
  *(_QWORD *)(a1 + 112) = MEMORY[0x1E0DE4FE0] + 64;
  v4 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 8);
  v5 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 16);
  *(_QWORD *)a1 = v4;
  *(_QWORD *)(a1 + *(_QWORD *)(v4 - 24)) = v5;
  v6 = (std::ios_base *)(a1 + *(_QWORD *)(*(_QWORD *)a1 - 24));
  std::ios_base::init(v6, (void *)(a1 + 8));
  v6[1].__vftable = 0;
  v6[1].__fmtflags_ = -1;
  *(_QWORD *)a1 = v2 + 24;
  *(_QWORD *)(a1 + 112) = v3;
  std::streambuf::basic_streambuf();
  *(_QWORD *)(a1 + 8) = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 16;
  return a1;
}

void sub_1A149D908(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::ostream::~ostream();
  MEMORY[0x1A1B0A808](v1);
  _Unwind_Resume(a1);
}

uint64_t std::ostringstream::~ostringstream(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = MEMORY[0x1E0DE4F60];
  v3 = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)a1 = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)(a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 24);
  *(_QWORD *)(a1 + 8) = MEMORY[0x1E0DE4FB8] + 16;
  if (*(char *)(a1 + 95) < 0)
    operator delete(*(void **)(a1 + 72));
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1A1B0A808](a1 + 112);
  return a1;
}

uint64_t vision::mod::CVMLMatrix<double,16ul>::mean(uint64_t result, _QWORD *a2, char a3)
{
  _QWORD *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  double v9;
  std::logic_error *exception;

  v4 = (_QWORD *)result;
  if ((a3 & 1) != 0)
  {
    result = (uint64_t)vision::mod::CVMLVector<double,16ul>::reset((uint64_t)a2, *(_QWORD *)(result + 24));
    v5 = v4[3];
  }
  else
  {
    v5 = *(_QWORD *)(result + 24);
    if (a2[2] < v5)
    {
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::out_of_range::out_of_range[abi:ne180100](exception, "vector length < cols");
      __cxa_throw(exception, (struct type_info *)off_1E452A5D0, MEMORY[0x1E0DE42E0]);
    }
  }
  if (v5)
  {
    v6 = 0;
    v7 = v4[2];
    do
    {
      if (v7)
      {
        v8 = 0;
        v9 = 0.0;
        do
        {
          result = vision::mod::CVMLMatrix<double,16ul>::ptr(v4, v8);
          v9 = v9 + *(double *)(result + 8 * v6);
          ++v8;
          v7 = v4[2];
        }
        while (v8 < v7);
        v5 = v4[3];
      }
      else
      {
        v9 = 0.0;
      }
      *(double *)(a2[1] + 8 * a2[3] * v6++) = v9 / (double)v7;
    }
    while (v6 < v5);
  }
  return result;
}

void sub_1A149DAA8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void vision::mod::CVMLMatrix<double,16ul>::rowNorms(uint64_t a1, _QWORD *a2, char a3)
{
  unint64_t v5;
  unint64_t v6;
  const double *v7;
  std::logic_error *exception;

  if ((a3 & 1) != 0)
  {
    vision::mod::CVMLVector<double,16ul>::reset((uint64_t)a2, *(_QWORD *)(a1 + 16));
    v5 = *(_QWORD *)(a1 + 16);
  }
  else
  {
    v5 = *(_QWORD *)(a1 + 16);
    if (a2[2] < v5)
    {
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::out_of_range::out_of_range[abi:ne180100](exception, "vector length < rows");
      __cxa_throw(exception, (struct type_info *)off_1E452A5D0, MEMORY[0x1E0DE42E0]);
    }
  }
  if (v5)
  {
    v6 = 0;
    do
    {
      v7 = (const double *)vision::mod::CVMLMatrix<double,16ul>::ptr((_QWORD *)a1, v6);
      *(double *)(a2[1] + 8 * a2[3] * v6++) = cblas_ddot(*(_DWORD *)(a1 + 24), v7, 1, v7, 1);
    }
    while (v6 < *(_QWORD *)(a1 + 16));
  }
}

void sub_1A149DB88(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1A149DC84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  void *v15;
  int v16;

  if (a14 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

_QWORD *vision::mod::broadcastAdd<double,16ul>(_QWORD *a1, _QWORD *a2, int a3, _QWORD *a4)
{
  _QWORD *result;
  uint64_t v5;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v6[0] = &off_1E453B158;
  v7 = v6;
  vision::mod::broadcast<double,16ul>(a1, a2, (uint64_t)v6, a3, a4);
  result = v7;
  if (v7 == v6)
  {
    v5 = 4;
    result = v6;
  }
  else
  {
    if (!v7)
      return result;
    v5 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v5))();
}

void sub_1A149DD68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t vision::mod::broadcast<double,16ul>(_QWORD *a1, _QWORD *a2, uint64_t a3, int a4, _QWORD *a5)
{
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t i;
  uint64_t v20;
  double *v21;
  uint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  std::logic_error *exception;
  struct type_info *v33;
  void (*v34)(void *);
  double *v35;

  v9 = a1[2];
  if (v9 > a5[2] && a1[3] > a5[3])
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "matrix size too small for output");
    v33 = (struct type_info *)off_1E452A5D0;
    v34 = (void (*)(void *))MEMORY[0x1E0DE42E0];
    goto LABEL_27;
  }
  if (a4 != 1)
  {
    if (a4)
    {
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::invalid_argument::invalid_argument[abi:ne180100](exception, "unknown axis value");
LABEL_26:
      v33 = (struct type_info *)off_1E452A5E0;
      v34 = (void (*)(void *))MEMORY[0x1E0DE4360];
LABEL_27:
      __cxa_throw(exception, v33, v34);
    }
    if (a2[2] == a1[3])
    {
      v10 = vision::mod::CVMLMatrix<double,16ul>::ptr(a1, 0);
      v11 = a1[4];
      result = vision::mod::CVMLMatrix<double,16ul>::ptr(a5, 0);
      v13 = a1[2];
      if (v13)
      {
        v14 = result;
        v15 = 0;
        v16 = a1[3];
        v17 = 8 * a5[4];
        v18 = 8 * v11;
        do
        {
          if (v16)
          {
            for (i = 0; i < v16; ++i)
            {
              result = std::function<double ()(double,double)>::operator()(*(_QWORD *)(a3 + 24), *(double *)(v10 + 8 * i), *(double *)(a2[1] + 8 * a2[3] * i));
              *(_QWORD *)(v14 + 8 * i) = v20;
              v16 = a1[3];
            }
            v13 = a1[2];
          }
          ++v15;
          v14 += v17;
          v10 += v18;
        }
        while (v15 < v13);
      }
      return result;
    }
LABEL_25:
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "broadcast op: dimension mismatch");
    goto LABEL_26;
  }
  if (a2[2] != v9)
    goto LABEL_25;
  v21 = (double *)vision::mod::CVMLMatrix<double,16ul>::ptr(a1, 0);
  v22 = a1[4];
  result = vision::mod::CVMLMatrix<double,16ul>::ptr(a5, 0);
  v23 = a1[3];
  if (v23)
  {
    v24 = (_QWORD *)result;
    v25 = 0;
    v26 = a1[2];
    v27 = 8 * a5[4];
    v28 = 8 * v22;
    do
    {
      if (v26)
      {
        v29 = 0;
        v35 = v21;
        v30 = v24;
        do
        {
          result = std::function<double ()(double,double)>::operator()(*(_QWORD *)(a3 + 24), *v21, *(double *)(a2[1] + 8 * a2[3] * v29));
          *v30 = v31;
          ++v29;
          v26 = a1[2];
          v30 = (_QWORD *)((char *)v30 + v27);
          v21 = (double *)((char *)v21 + v28);
        }
        while (v29 < v26);
        v23 = a1[3];
        v21 = v35;
      }
      ++v25;
      ++v24;
      ++v21;
    }
    while (v25 < v23);
  }
  return result;
}

void sub_1A149E008(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::invalid_argument::invalid_argument[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5038] + 16);
  return result;
}

uint64_t std::function<double ()(double,double)>::operator()(uint64_t a1, double a2, double a3)
{
  double v4;
  double v5;

  v4 = a3;
  v5 = a2;
  if (!a1)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, double *, double *))(*(_QWORD *)a1 + 48))(a1, &v5, &v4);
}

void std::__function::__func<void vision::mod::broadcastAdd<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1},std::allocator<void vision::mod::broadcastAdd<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1}>,double ()(double,double)>::~__func()
{
  JUMPOUT(0x1A1B0A898);
}

_QWORD *std::__function::__func<void vision::mod::broadcastAdd<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1},std::allocator<void vision::mod::broadcastAdd<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1}>,double ()(double,double)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E453B158;
  return result;
}

void std::__function::__func<void vision::mod::broadcastAdd<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1},std::allocator<void vision::mod::broadcastAdd<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1}>,double ()(double,double)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E453B158;
}

double std::__function::__func<void vision::mod::broadcastAdd<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1},std::allocator<void vision::mod::broadcastAdd<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1}>,double ()(double,double)>::operator()(uint64_t a1, double *a2, double *a3)
{
  return *a2 + *a3;
}

uint64_t std::__function::__func<void vision::mod::broadcastAdd<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1},std::allocator<void vision::mod::broadcastAdd<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1}>,double ()(double,double)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN6vision3mod12broadcastAddIdLm16EEEvRKNS0_10CVMLMatrixIT_XT0_EEERKNS0_10CVMLVectorIS3_XT0_EEEiRS4_bEUlddE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void vision::mod::broadcastAdd<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1},std::allocator<void vision::mod::broadcastAdd<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1}>,double ()(double,double)>::target_type()
{
}

_QWORD *std::vector<double>::vector(_QWORD *a1, unint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<long long>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_1A149E184(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *vision::mod::CVMLVector<double,16ul>::initialize_(uint64_t a1, uint64_t a2)
{
  char *result;
  uint64_t v5;
  std::bad_alloc *exception;
  std::bad_alloc *v7;

  result = (char *)malloc_type_calloc(8 * a2 + 15, 1uLL, 0xA9532734uLL);
  if (!result)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    v7 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v7, MEMORY[0x1E0DE4EA8], MEMORY[0x1E0DE4DC0]);
  }
  v5 = 16 - (result & 0xF);
  if ((result & 0xF) == 0)
    v5 = 0;
  *(_QWORD *)a1 = result;
  *(_QWORD *)(a1 + 8) = &result[v5];
  *(_QWORD *)(a1 + 16) = a2;
  *(_QWORD *)(a1 + 24) = 1;
  *(_BYTE *)(a1 + 32) = 1;
  return result;
}

void vision::mod::Kmeans<double,16ul>::labelEstimation_(_QWORD *a1, int a2, uint64_t a3, void **a4, _QWORD *a5, void *__b, double *a7, double *a8)
{
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  double *v19;
  double *v20;
  _DWORD *v21;
  uint64_t v22;
  double v23;
  double v24;
  double v25;

  v16 = a1[2];
  v17 = 8 * v16;
  if (v16)
  {
    memset(__b, 255, 4 * v16);
    memset_pattern16(a7, &unk_1A15FB7D0, 8 * v16);
  }
  vision::mod::euclideanDistances<double,16ul>(a3, a1, a5, a4);
  if (a2 >= 1)
  {
    v18 = 0;
    do
    {
      v19 = (double *)vision::mod::CVMLMatrix<double,16ul>::ptr(a5, v18);
      if (v16)
      {
        v20 = a7;
        v21 = __b;
        v22 = v16;
        do
        {
          v23 = *v19;
          if (*v19 < *v20)
          {
            *v21 = v18;
            *v20 = v23;
          }
          ++v21;
          ++v20;
          ++v19;
          --v22;
        }
        while (v22);
      }
      ++v18;
    }
    while (v18 != a2);
  }
  v24 = 0.0;
  if (v16)
  {
    do
    {
      v25 = *a7++;
      v24 = v24 + v25;
      v17 -= 8;
    }
    while (v17);
  }
  *a8 = v24;
}

void *std::get_temporary_buffer[abi:ne180100]<unsigned long>(uint64_t a1)
{
  unint64_t v1;
  const std::nothrow_t *v2;
  void *result;
  BOOL v4;

  if (a1 < 1)
    return 0;
  if (a1 >= 0xFFFFFFFFFFFFFFFLL)
    v1 = 0xFFFFFFFFFFFFFFFLL;
  else
    v1 = a1;
  v2 = (const std::nothrow_t *)MEMORY[0x1E0DE4E10];
  while (1)
  {
    result = operator new(8 * v1, v2);
    if (result)
      break;
    v4 = v1 > 1;
    v1 >>= 1;
    if (!v4)
      return 0;
  }
  return result;
}

uint64_t *std::__stable_sort<std::_ClassicAlgPolicy,void vision::mod::argsort<double const*>(double const*,double const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(uint64_t *result, uint64_t *a2, uint64_t **a3, unint64_t a4, uint64_t *a5, uint64_t a6)
{
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  double v18;
  uint64_t v19;
  uint64_t *v20;
  char *v22;
  unint64_t v23;
  uint64_t *v24;
  unint64_t v25;
  uint64_t *v26;
  char *v27;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t v30;
  double v31;
  double v32;
  uint64_t v33;
  uint64_t v34;

  if (a4 >= 2)
  {
    v8 = (char *)result;
    if (a4 == 2)
    {
      v9 = *(a2 - 1);
      v10 = *result;
      if (*(double *)(**a3 + 8 * v9) > *(double *)(**a3 + 8 * *result))
      {
        *result = v9;
        *(a2 - 1) = v10;
      }
    }
    else if ((uint64_t)a4 > 128)
    {
      v22 = (char *)a5;
      v23 = a4 >> 1;
      v24 = &result[a4 >> 1];
      v25 = a4 >> 1;
      if ((uint64_t)a4 <= a6)
      {
        std::__stable_sort_move<std::_ClassicAlgPolicy,void vision::mod::argsort<double const*>(double const*,double const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(result, v24, a3, v25, a5);
        v26 = (uint64_t *)&v22[8 * v23];
        result = std::__stable_sort_move<std::_ClassicAlgPolicy,void vision::mod::argsort<double const*>(double const*,double const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>((uint64_t *)&v8[8 * (a4 >> 1)], a2, a3, a4 - (a4 >> 1), v26);
        v27 = &v22[8 * a4];
        v28 = *a3;
        v29 = v26;
        while (v29 != (uint64_t *)v27)
        {
          v30 = *v29;
          v31 = *(double *)(*v28 + 8 * *v29);
          v32 = *(double *)(*v28 + 8 * *(_QWORD *)v22);
          if (v31 <= v32)
            v30 = *(_QWORD *)v22;
          v22 += 8 * (v31 <= v32);
          v29 += v31 > v32;
          *(_QWORD *)v8 = v30;
          v8 += 8;
          if (v22 == (char *)v26)
          {
            if (v29 != (uint64_t *)v27)
            {
              v33 = 0;
              do
              {
                *(_QWORD *)&v8[v33 * 8] = v29[v33];
                ++v33;
              }
              while (&v29[v33] != (uint64_t *)v27);
            }
            return result;
          }
        }
        if (v22 != (char *)v26)
        {
          v34 = 0;
          do
          {
            *(_QWORD *)&v8[v34] = *(_QWORD *)&v22[v34];
            v34 += 8;
          }
          while (&v22[v34] != (char *)v26);
        }
      }
      else
      {
        std::__stable_sort<std::_ClassicAlgPolicy,void vision::mod::argsort<double const*>(double const*,double const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(result, v24, a3, v25, a5, a6);
        std::__stable_sort<std::_ClassicAlgPolicy,void vision::mod::argsort<double const*>(double const*,double const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(&v8[8 * (a4 >> 1)], a2, a3, a4 - (a4 >> 1), v22, a6);
        return (uint64_t *)std::__inplace_merge<std::_ClassicAlgPolicy,void vision::mod::argsort<double const*>(double const*,double const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(v8, &v8[8 * (a4 >> 1)], (char *)a2, a3, a4 >> 1, a4 - (a4 >> 1), v22, a6);
      }
    }
    else if (result != a2)
    {
      v12 = result + 1;
      if (result + 1 != a2)
      {
        v13 = 0;
        v14 = **a3;
        v15 = result;
        do
        {
          v17 = *v15;
          v16 = v15[1];
          v15 = v12;
          v18 = *(double *)(v14 + 8 * v16);
          if (v18 > *(double *)(v14 + 8 * v17))
          {
            v19 = v13;
            while (1)
            {
              *(uint64_t *)((char *)result + v19 + 8) = v17;
              if (!v19)
                break;
              v17 = *(uint64_t *)((char *)result + v19 - 8);
              v19 -= 8;
              if (v18 <= *(double *)(v14 + 8 * v17))
              {
                v20 = (uint64_t *)((char *)result + v19 + 8);
                goto LABEL_15;
              }
            }
            v20 = result;
LABEL_15:
            *v20 = v16;
          }
          v12 = v15 + 1;
          v13 += 8;
        }
        while (v15 + 1 != a2);
      }
    }
  }
  return result;
}

uint64_t *std::__stable_sort_move<std::_ClassicAlgPolicy,void vision::mod::argsort<double const*>(double const*,double const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(uint64_t *result, uint64_t *a2, uint64_t **a3, unint64_t a4, uint64_t *a5)
{
  uint64_t *v5;
  uint64_t *v7;
  uint64_t v10;
  uint64_t v11;
  double v12;
  double v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t v27;
  double v28;
  double v29;
  uint64_t v30;
  uint64_t v31;

  if (a4)
  {
    v5 = a5;
    v7 = result;
    if (a4 == 1)
    {
LABEL_8:
      *v5 = *v7;
      return result;
    }
    if (a4 == 2)
    {
      v10 = *(a2 - 1);
      v11 = **a3;
      v12 = *(double *)(v11 + 8 * v10);
      v13 = *(double *)(v11 + 8 * *result);
      if (v12 <= v13)
        v10 = *result;
      *a5 = v10;
      v5 = a5 + 1;
      if (v12 <= v13)
        v7 = a2 - 1;
      goto LABEL_8;
    }
    if ((uint64_t)a4 > 8)
    {
      v24 = &result[a4 >> 1];
      std::__stable_sort<std::_ClassicAlgPolicy,void vision::mod::argsort<double const*>(double const*,double const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(result, v24, a3, a4 >> 1, a5, a4 >> 1);
      result = (uint64_t *)std::__stable_sort<std::_ClassicAlgPolicy,void vision::mod::argsort<double const*>(double const*,double const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(&v7[a4 >> 1], a2, a3, a4 - (a4 >> 1), &v5[a4 >> 1], a4 - (a4 >> 1));
      v25 = *a3;
      v26 = &v7[a4 >> 1];
      while (v26 != a2)
      {
        v27 = *v26;
        v28 = *(double *)(*v25 + 8 * *v26);
        v29 = *(double *)(*v25 + 8 * *v7);
        if (v28 <= v29)
          v27 = *v7;
        v26 += v28 > v29;
        v7 += v28 <= v29;
        *v5++ = v27;
        if (v7 == v24)
        {
          if (v26 != a2)
          {
            v30 = 0;
            do
            {
              v5[v30] = v26[v30];
              ++v30;
            }
            while (&v26[v30] != a2);
          }
          return result;
        }
      }
      if (v7 != v24)
      {
        v31 = 0;
        do
        {
          v5[v31] = v7[v31];
          ++v31;
        }
        while (&v7[v31] != v24);
      }
    }
    else if (result != a2)
    {
      v14 = result + 1;
      *a5 = *result;
      if (result + 1 != a2)
      {
        v15 = 0;
        v16 = **a3;
        v17 = a5;
        v18 = a5;
        do
        {
          v20 = *v18++;
          v19 = v20;
          if (*(double *)(v16 + 8 * *v14) <= *(double *)(v16 + 8 * v20))
          {
            *v18 = *v14;
          }
          else
          {
            v17[1] = v19;
            v21 = a5;
            if (v17 != a5)
            {
              v22 = v15;
              while (1)
              {
                v21 = (uint64_t *)((char *)a5 + v22);
                v23 = *(uint64_t *)((char *)a5 + v22 - 8);
                if (*(double *)(v16 + 8 * *v14) <= *(double *)(v16 + 8 * v23))
                  break;
                *v21 = v23;
                v22 -= 8;
                if (!v22)
                {
                  v21 = a5;
                  break;
                }
              }
            }
            *v21 = *v14;
          }
          ++v14;
          v15 += 8;
          v17 = v18;
        }
        while (v14 != a2);
      }
    }
  }
  return result;
}

char *std::__inplace_merge<std::_ClassicAlgPolicy,void vision::mod::argsort<double const*>(double const*,double const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(char *result, char *a2, char *a3, uint64_t **a4, uint64_t a5, uint64_t a6, char *a7, uint64_t a8)
{
  uint64_t v10;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t **v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  char *v20;
  unint64_t v21;
  unint64_t v22;
  char *v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  char *v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  uint64_t v35;
  char *v36;
  char *v37;
  uint64_t **v38;
  char *v39;
  uint64_t v40;
  char *v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  uint64_t *v46;
  uint64_t v47;
  double v48;
  double v49;
  uint64_t v50;
  uint64_t v51;
  char *v52;
  uint64_t v53;

  if (a6)
  {
    v10 = a6;
    v13 = result;
    while (v10 > a8 && a5 > a8)
    {
      if (!a5)
        return result;
      v14 = **a4;
      while (1)
      {
        v15 = *(_QWORD *)v13;
        if (*(double *)(v14 + 8 * *(_QWORD *)a2) > *(double *)(v14 + 8 * *(_QWORD *)v13))
          break;
        v13 += 8;
        if (!--a5)
          return result;
      }
      v51 = a8;
      v52 = a3;
      if (a5 >= v10)
      {
        if (a5 == 1)
        {
          *(_QWORD *)v13 = *(_QWORD *)a2;
          *(_QWORD *)a2 = v15;
          return result;
        }
        v16 = a4;
        if (a5 >= 0)
          v27 = a5;
        else
          v27 = a5 + 1;
        v26 = v27 >> 1;
        v20 = &v13[8 * (v27 >> 1)];
        v19 = a3;
        if (a3 != a2)
        {
          v28 = (a3 - a2) >> 3;
          v19 = a2;
          do
          {
            v29 = v28 >> 1;
            v30 = &v19[8 * (v28 >> 1)];
            v32 = *(_QWORD *)v30;
            v31 = v30 + 8;
            v28 += ~(v28 >> 1);
            if (*(double *)(v14 + 8 * v32) > *(double *)(v14 + 8 * *(_QWORD *)v20))
              v19 = v31;
            else
              v28 = v29;
          }
          while (v28);
        }
        v18 = (v19 - a2) >> 3;
      }
      else
      {
        v16 = a4;
        if (v10 >= 0)
          v17 = v10;
        else
          v17 = v10 + 1;
        v18 = v17 >> 1;
        v19 = &a2[8 * (v17 >> 1)];
        v20 = a2;
        if (a2 != v13)
        {
          v21 = (a2 - v13) >> 3;
          v20 = v13;
          do
          {
            v22 = v21 >> 1;
            v23 = &v20[8 * (v21 >> 1)];
            v25 = *(_QWORD *)v23;
            v24 = v23 + 8;
            v21 += ~(v21 >> 1);
            if (*(double *)(v14 + 8 * *(_QWORD *)v19) > *(double *)(v14 + 8 * v25))
              v21 = v22;
            else
              v20 = v24;
          }
          while (v21);
        }
        v26 = (v20 - v13) >> 3;
      }
      a5 -= v26;
      v10 -= v18;
      v33 = v26;
      v34 = std::__rotate[abi:ne180100]<std::_ClassicAlgPolicy,unsigned long *,unsigned long *>(v20, a2, v19);
      v35 = v33;
      v36 = v34;
      if (v35 + v18 >= a5 + v10)
      {
        v39 = v52;
        v53 = v35;
        result = (char *)std::__inplace_merge<std::_ClassicAlgPolicy,void vision::mod::argsort<double const*>(double const*,double const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(v34, v19, v39, v16, a5, v10, a7, v51);
        v19 = v20;
        a4 = v16;
        a8 = v51;
        v10 = v18;
        a5 = v53;
        a3 = v36;
      }
      else
      {
        v37 = v20;
        a4 = v16;
        v38 = v16;
        a8 = v51;
        result = (char *)std::__inplace_merge<std::_ClassicAlgPolicy,void vision::mod::argsort<double const*>(double const*,double const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(v13, v37, v34, v38, v35, v18, a7, v51);
        v13 = v36;
        a3 = v52;
      }
      a2 = v19;
      if (!v10)
        return result;
    }
    if (a5 <= v10)
    {
      if (v13 != a2)
      {
        v44 = 0;
        do
        {
          *(_QWORD *)&a7[v44] = *(_QWORD *)&v13[v44];
          v44 += 8;
        }
        while (&v13[v44] != a2);
        v45 = &a7[v44];
        if (v45 != a7)
        {
          v46 = *a4;
          while (a2 != a3)
          {
            v47 = *(_QWORD *)a2;
            v48 = *(double *)(*v46 + 8 * *(_QWORD *)a2);
            v49 = *(double *)(*v46 + 8 * *(_QWORD *)a7);
            if (v48 <= v49)
              v47 = *(_QWORD *)a7;
            a7 += 8 * (v48 <= v49);
            a2 += 8 * (v48 > v49);
            *(_QWORD *)v13 = v47;
            v13 += 8;
            if (a7 == v45)
              return result;
          }
          return (char *)memmove(v13, a7, v45 - a7);
        }
      }
    }
    else if (a2 != a3)
    {
      v40 = 0;
      do
      {
        *(_QWORD *)&a7[v40] = *(_QWORD *)&a2[v40];
        v40 += 8;
      }
      while (&a2[v40] != a3);
      v41 = &a7[v40];
      if (v41 != a7)
      {
        v42 = a3 - 8;
        while (a2 != v13)
        {
          v43 = *((_QWORD *)v41 - 1);
          if (*(double *)(**a4 + 8 * v43) <= *(double *)(**a4 + 8 * *((_QWORD *)a2 - 1)))
          {
            v41 -= 8;
          }
          else
          {
            v43 = *((_QWORD *)a2 - 1);
            a2 -= 8;
          }
          *(_QWORD *)v42 = v43;
          v42 -= 8;
          if (v41 == a7)
            return result;
        }
        v50 = 0;
        do
        {
          *(_QWORD *)&v42[v50] = *(_QWORD *)&v41[v50 - 8];
          v50 -= 8;
        }
        while (&v41[v50] != a7);
      }
    }
  }
  return result;
}

char *std::__rotate[abi:ne180100]<std::_ClassicAlgPolicy,unsigned long *,unsigned long *>(char *__src, char *a2, char *a3)
{
  char *v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v11;
  int64_t v12;
  char *v13;
  uint64_t v14;
  size_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  char *v23;
  char *v24;
  BOOL v25;
  char v26;
  uint64_t v27;

  v3 = a3;
  if (__src != a2)
  {
    if (a2 == a3)
    {
      return __src;
    }
    else if (__src + 8 == a2)
    {
      v11 = *(_QWORD *)__src;
      v12 = a3 - a2;
      memmove(__src, a2, a3 - a2);
      v3 = &__src[v12];
      *(_QWORD *)v3 = v11;
    }
    else if (a2 + 8 == a3)
    {
      v13 = a3 - 8;
      v14 = *((_QWORD *)a3 - 1);
      v3 = __src + 8;
      v15 = a3 - 8 - __src;
      if (v13 != __src)
        memmove(__src + 8, __src, v15);
      *(_QWORD *)__src = v14;
    }
    else
    {
      v5 = (a2 - __src) >> 3;
      if (v5 == (a3 - a2) >> 3)
      {
        v6 = 0;
        do
        {
          v7 = *(_QWORD *)&__src[v6];
          *(_QWORD *)&__src[v6] = *(_QWORD *)&a2[v6];
          v8 = &__src[v6 + 8];
          *(_QWORD *)&a2[v6] = v7;
          v9 = (uint64_t)&a2[v6 + 8];
          v6 += 8;
        }
        while (v8 != a2 && v9 != (_QWORD)a3);
        return a2;
      }
      else
      {
        v16 = (a3 - a2) >> 3;
        v17 = (a2 - __src) >> 3;
        do
        {
          v18 = v17;
          v17 = v16;
          v16 = v18 % v16;
        }
        while (v16);
        if (v17)
        {
          v19 = &__src[8 * v17];
          do
          {
            v21 = *((_QWORD *)v19 - 1);
            v19 -= 8;
            v20 = v21;
            v22 = &v19[8 * v5];
            v23 = v19;
            do
            {
              v24 = v23;
              v23 = v22;
              *(_QWORD *)v24 = *(_QWORD *)v22;
              v25 = __OFSUB__(v5, (a3 - v22) >> 3);
              v27 = v5 - ((a3 - v22) >> 3);
              v26 = (v27 < 0) ^ v25;
              v22 = &__src[8 * v27];
              if (v26)
                v22 = &v23[8 * v5];
            }
            while (v22 != v19);
            *(_QWORD *)v23 = v20;
          }
          while (v19 != __src);
        }
        return &__src[8 * ((a3 - a2) >> 3)];
      }
    }
  }
  return v3;
}

void vision::mod::euclideanDistances<double,16ul>(uint64_t a1, _QWORD *a2, _QWORD *a3, void **a4)
{
  unint64_t v7;
  void **v8;
  void **v9;
  unint64_t v10;
  double *v11;
  uint64_t i;
  unint64_t v13;
  unint64_t v14;
  std::logic_error *exception;
  struct type_info *v16;
  void (*v17)(void *);
  void *v18[2];
  __int128 v19;
  char v20;
  void *v21[2];
  __int128 v22;
  char v23;

  if (*(_QWORD *)(a1 + 24) != a2[3])
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "dimensions of data points mismatch");
    v16 = (struct type_info *)off_1E452A5E0;
    v17 = (void (*)(void *))MEMORY[0x1E0DE4360];
LABEL_26:
    __cxa_throw(exception, v16, v17);
  }
  if (*(_QWORD *)(a1 + 16) > a3[2] || (v7 = a2[2], v7 > a3[3]))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "output distance matrix too small");
    v16 = (struct type_info *)off_1E452A5D0;
    v17 = (void (*)(void *))MEMORY[0x1E0DE42E0];
    goto LABEL_26;
  }
  v8 = a4;
  *(_OWORD *)v21 = 0u;
  v22 = 0u;
  v23 = 1;
  if (!a4)
  {
    vision::mod::CVMLVector<double,16ul>::reset((uint64_t)v21, v7);
    v8 = v21;
    vision::mod::CVMLMatrix<double,16ul>::rowNorms((uint64_t)a2, v21, 0);
  }
  *(_OWORD *)v18 = 0u;
  v19 = 0u;
  v9 = v8;
  v20 = 1;
  if ((_QWORD *)a1 != a2)
  {
    vision::mod::CVMLVector<double,16ul>::reset((uint64_t)v18, *(_QWORD *)(a1 + 16));
    v9 = v18;
    vision::mod::CVMLMatrix<double,16ul>::rowNorms(a1, v18, 0);
  }
  vision::mod::matMult<double,16ul>(a1, a2, 1, a3, 0, -2.0, 0.0);
  vision::mod::broadcastAdd<double,16ul>(a3, v9, 1, a3);
  vision::mod::broadcastAdd<double,16ul>(a3, v8, 0, a3);
  if (a3[2])
  {
    v10 = 0;
    do
    {
      v11 = (double *)vision::mod::CVMLMatrix<double,16ul>::ptr(a3, v10);
      for (i = a3[3]; i; --i)
      {
        *v11 = fmax(*v11, 0.0);
        ++v11;
      }
      ++v10;
      v13 = a3[2];
    }
    while (v10 < v13);
    if ((_QWORD *)a1 == a2 && v13)
    {
      v14 = 0;
      do
      {
        *(_QWORD *)(vision::mod::CVMLMatrix<double,16ul>::ptr(a3, v14) + 8 * v14) = 0;
        ++v14;
      }
      while (v14 < a3[2]);
    }
  }
  if (v20 && v18[0])
    free(v18[0]);
  if (v23)
  {
    if (v21[0])
      free(v21[0]);
  }
}

void sub_1A149EF30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  void *v19;

  __cxa_free_exception(v19);
  _Unwind_Resume(a1);
}

char *vision::mod::CVMLVector<double,16ul>::reset(uint64_t a1, uint64_t a2)
{
  void *v4;

  if (*(_BYTE *)(a1 + 32))
  {
    v4 = *(void **)a1;
    if (*(_QWORD *)a1)
      free(v4);
  }
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_BYTE *)(a1 + 32) = 1;
  return vision::mod::CVMLVector<double,16ul>::initialize_(a1, a2);
}

void vision::mod::matMult<double,16ul>(uint64_t a1, _QWORD *a2, int a3, _QWORD *a4, char a5, double a6, double a7)
{
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  int v17;
  int v18;
  int *v19;
  BOOL v20;
  CBLAS_TRANSPOSE v21;
  int v22;
  const double *v23;
  int v24;
  const double *__B;
  uint64_t __ldb;
  double *__C;
  std::logic_error *exception;
  struct type_info *v29;
  void (*v30)(void *);

  v13 = *(_QWORD *)(a1 + 24);
  if ((a3 & 1) != 0)
  {
    if (v13 == a2[3])
    {
      v14 = a2 + 2;
      goto LABEL_6;
    }
LABEL_17:
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "matrix size mismatch");
    v29 = (struct type_info *)off_1E452A5E0;
    v30 = (void (*)(void *))MEMORY[0x1E0DE4360];
    goto LABEL_19;
  }
  if (v13 != a2[2])
    goto LABEL_17;
  v14 = a2 + 3;
LABEL_6:
  v15 = *(_QWORD *)(a1 + 16);
  v16 = *v14;
  if ((a5 & 1) == 0)
  {
    if (a4[2] >= v15 && a4[3] >= v16)
      goto LABEL_10;
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "matrix size too small for output");
    v29 = (struct type_info *)off_1E452A5D0;
    v30 = (void (*)(void *))MEMORY[0x1E0DE42E0];
LABEL_19:
    __cxa_throw(exception, v29, v30);
  }
  vision::mod::CVMLMatrix<double,16ul>::reset((uint64_t)a4, v15, v16);
LABEL_10:
  v17 = *(_DWORD *)(a1 + 16);
  v18 = *(_DWORD *)(a1 + 24);
  v19 = (int *)(a2 + 2);
  v20 = a3 == 0;
  if (a3)
    v21 = CblasTrans;
  else
    v21 = CblasNoTrans;
  if (v20)
    v19 = (int *)(a2 + 3);
  v22 = *v19;
  v23 = (const double *)vision::mod::CVMLMatrix<double,16ul>::ptr((_QWORD *)a1, 0);
  v24 = *(_DWORD *)(a1 + 32);
  __B = (const double *)vision::mod::CVMLMatrix<double,16ul>::ptr(a2, 0);
  __ldb = a2[4];
  __C = (double *)vision::mod::CVMLMatrix<double,16ul>::ptr(a4, 0);
  cblas_dgemm(CblasRowMajor, CblasNoTrans, v21, v17, v22, v18, a6, v23, v24, __B, __ldb, a7, __C, a4[4]);
}

void sub_1A149F1A0(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t std::uniform_int_distribution<int>::operator()<std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>(std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> *this, _DWORD *a2)
{
  uint64_t result;
  int v4;
  unsigned int v5;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unsigned int v11;
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v12;

  result = a2[1];
  v4 = result - *a2;
  if ((_DWORD)result != *a2)
  {
    v5 = v4 + 1;
    if (v4 == -1)
    {
      return std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(this);
    }
    else
    {
      v7 = __clz(v5);
      v8 = 31;
      if (((v5 << v7) & 0x7FFFFFFF) != 0)
        v8 = 32;
      v9 = v8 - v7;
      v10 = v9 >> 5;
      if ((v9 & 0x1F) != 0)
        ++v10;
      if (v10 <= v9)
        v11 = 0xFFFFFFFF >> -(v9 / v10);
      else
        v11 = 0;
      do
        v12 = std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(this) & v11;
      while (v12 >= v5);
      return *a2 + v12;
    }
  }
  return result;
}

std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> *this)
{
  size_t i;
  size_t v2;
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v3;

  i = this->__i_;
  v2 = (i + 1) % 0x270;
  v3 = this->__x_[(i + 397) % 0x270] ^ ((this->__x_[v2] & 0x7FFFFFFE | this->__x_[i] & 0x80000000) >> 1) ^ ((int)(this->__x_[v2] << 31) >> 31) & 0x9908B0DF;
  this->__x_[i] = v3;
  this->__i_ = v2;
  LODWORD(i) = ((v3 ^ (v3 >> 11)) << 7) & 0x9D2C5680 ^ v3 ^ (v3 >> 11);
  return ((_DWORD)i << 15) & 0xEFC60000 ^ i ^ ((((_DWORD)i << 15) & 0xEFC60000 ^ i) >> 18);
}

void std::__function::__func<void vision::mod::broadcastMinus<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1},std::allocator<void vision::mod::broadcastMinus<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1}>,double ()(double,double)>::~__func()
{
  JUMPOUT(0x1A1B0A898);
}

_QWORD *std::__function::__func<void vision::mod::broadcastMinus<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1},std::allocator<void vision::mod::broadcastMinus<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1}>,double ()(double,double)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E453B208;
  return result;
}

void std::__function::__func<void vision::mod::broadcastMinus<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1},std::allocator<void vision::mod::broadcastMinus<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1}>,double ()(double,double)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E453B208;
}

double std::__function::__func<void vision::mod::broadcastMinus<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1},std::allocator<void vision::mod::broadcastMinus<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1}>,double ()(double,double)>::operator()(uint64_t a1, double *a2, double *a3)
{
  return *a2 - *a3;
}

uint64_t std::__function::__func<void vision::mod::broadcastMinus<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1},std::allocator<void vision::mod::broadcastMinus<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1}>,double ()(double,double)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN6vision3mod14broadcastMinusIdLm16EEEvRKNS0_10CVMLMatrixIT_XT0_EEERKNS0_10CVMLVectorIS3_XT0_EEEiRS4_bEUlddE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void vision::mod::broadcastMinus<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1},std::allocator<void vision::mod::broadcastMinus<double,16ul>(vision::mod::CVMLMatrix<double,16ul> const&,vision::mod::CVMLVector<double,16ul> const&,int,vision::mod::CVMLMatrix<double,16ul>&,BOOL)::{lambda(double,double)#1}>,double ()(double,double)>::target_type()
{
}

void vision::mod::FaceIDModel::shrinkD_(vision::mod::FaceIDModel *this, int a2)
{
  uint64_t v3;
  void *v4;
  void *v5;
  const void *v6;
  uint64_t v7;
  void *v8;
  const void *v9;
  void *v10[5];
  char v11;

  v3 = a2;
  vision::mod::CVMLMatrix<double,16ul>::initialize_((uint64_t)v10, a2, *((_QWORD *)this + 14));
  v4 = (void *)*((_QWORD *)this + 15);
  if (v4 == v10[4])
  {
    v5 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v10, 0);
    v6 = (const void *)vision::mod::CVMLMatrix<double,16ul>::ptr((_QWORD *)this + 11, 0);
    v7 = 8 * v3;
    memcpy(v5, v6, 8 * v3 * *((_QWORD *)this + 15));
    vision::mod::CVMLMatrix<double,16ul>::reset((uint64_t)this + 88, v3, *((_QWORD *)this + 14));
    v8 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr((_QWORD *)this + 11, 0);
    v9 = (const void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v10, 0);
    memcpy(v8, v9, v7 * (_QWORD)v4);
  }
  else
  {
    syslog(5, "ERROR: stride mismatch");
  }
  if (v11)
  {
    if (v10[0])
      free(v10[0]);
  }
}

void sub_1A149F4BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  if (a14)
  {
    if (a9)
      free(a9);
  }
  _Unwind_Resume(exception_object);
}

void vision::mod::FaceIDModel::createPrintsDictionary_(uint64_t a1, vision::mod::ImageDescriptorBufferAbstract *a2, uint64_t a3)
{
  uint64_t *v4;
  int v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t *v10;
  int v11;
  int v12;
  int64_t i;
  uint64_t v14;
  double *v15;
  unint64_t v16;
  unsigned int v17;
  double v18;
  _DWORD *DataForKthDescriptor;
  double v20;
  double *v21;
  uint64_t v22;
  double v23;
  double v24;
  double v25;
  float *v26;
  double *v27;
  uint64_t v28;
  float v29;
  uint64_t *v30;
  unsigned int v31;
  unint64_t v32;
  uint64_t v33;
  int *v34;
  uint64_t v35;
  int v36;
  int *v37;
  int *v38;
  int v39;
  int v40;
  void **v41;
  unint64_t v42;
  float *v43;
  double *v44;
  uint64_t v45;
  float v46;
  _QWORD *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int *v52;
  int v53;
  _QWORD *v54;
  int *v55;
  int v56;
  uint64_t v58;
  int v59;
  void *__p[2];
  char v61;
  uint64_t v62;
  _QWORD v63[10];
  char v64;
  uint64_t v65;
  unint64_t v66;
  int *v67;
  uint64_t v68;
  int v69;
  _QWORD *v70;

  v4 = *(uint64_t **)(a1 + 200);
  v5 = 0;
  if (v4)
  {
    v6 = *(_QWORD *)a3;
    v7 = *(_QWORD *)(a3 + 8);
    do
    {
      v8 = std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::find<int>(v6, v7, *((_DWORD *)v4 + 4));
      if (v8)
        v5 = (int)(fmin((double)*(int *)(a1 + 56), (double)(unint64_t)((v8[4] - v8[3]) >> 2)) + (double)v5);
      else
        v5 += *((_DWORD *)v4 + 6);
      v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  v54 = (_QWORD *)(a1 + 136);
  vision::mod::CVMLMatrix<double,16ul>::reset(a1 + 136, v5, *(_QWORD *)(a1 + 112));
  v58 = *((_QWORD *)a2 + 9);
  v9 = *((_QWORD *)a2 + 12);
  v53 = v5;
  syslog(5, "FaceID: labels=%lu printDSize=%d num_prints=%d dimensionality=%d", *(_QWORD *)(a1 + 208), v5, v58, v9);
  LOBYTE(v62) = 0;
  std::vector<BOOL>::vector(&v70, (int)v58, (unsigned __int8 *)&v62);
  v10 = *(uint64_t **)(a1 + 200);
  if (v10)
  {
    v56 = 0;
    v49 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
    v50 = *MEMORY[0x1E0DE4F60];
    v48 = MEMORY[0x1E0DE4FB8] + 16;
    do
    {
      v69 = *((_DWORD *)v10 + 4);
      v11 = v69;
      v59 = v69;
      v12 = 0;
      if (*((int *)v10 + 6) >= 1)
      {
        for (i = *((int *)v10 + 5); i < *((int *)v10 + 6) + (uint64_t)*((int *)v10 + 5); ++i)
        {
          v14 = vision::mod::CVMLMatrix<double,16ul>::ptr((_QWORD *)(a1 + 88), i);
          if ((int)v58 < 1)
            goto LABEL_26;
          v15 = (double *)v14;
          v16 = 0;
          v17 = -1;
          v18 = 1000.0;
          do
          {
            if (((*(_QWORD *)((char *)v70 + ((v16 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v16) & 1) == 0)
            {
              DataForKthDescriptor = (_DWORD *)vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(a2, v16);
              v20 = 0.0;
              if ((int)v9 >= 1)
              {
                v21 = v15;
                v22 = v9;
                do
                {
                  v23 = *v21++;
                  v24 = v23;
                  LODWORD(v23) = *DataForKthDescriptor++;
                  v20 = v20 + (v24 - *(float *)&v23) * (v24 - *(float *)&v23);
                  --v22;
                }
                while (v22);
              }
              v25 = sqrt(v20);
              if (v25 < v18)
              {
                v18 = v25;
                v17 = v16;
              }
            }
            ++v16;
          }
          while (v16 != v58);
          if ((v17 & 0x80000000) != 0)
          {
LABEL_26:
            v11 = v59;
            syslog(5, "FaceID: could not find a close enough faceprint for label %d", v59);
          }
          else
          {
            *(_QWORD *)((char *)v70 + (((unint64_t)v17 >> 3) & 0x1FFFFFF8)) |= 1 << v17;
            if (v12 + v56 >= v53)
            {
              syslog(5, "FaceID: row %d + %d has exceeded the prints count of %d", v56, v12, v53);
              goto LABEL_64;
            }
            v26 = (float *)vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(a2, v17);
            v27 = (double *)vision::mod::CVMLMatrix<double,16ul>::ptr(v54, v12 + v56);
            v11 = v59;
            if ((int)v9 >= 1)
            {
              v28 = v9;
              do
              {
                v29 = *v26++;
                *v27++ = v29;
                --v28;
              }
              while (v28);
            }
            ++v12;
          }
        }
      }
      v30 = std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::find<int>(*(_QWORD *)a3, *(_QWORD *)(a3 + 8), v11);
      v67 = 0;
      v68 = 0;
      v66 = 0;
      std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(&v66, (const void *)v30[3], v30[4], (v30[4] - v30[3]) >> 2);
      v31 = *(_DWORD *)(a1 + 64) + ((*(_DWORD *)(a1 + 64) / 0x7FFFFFFFu) | ((*(_DWORD *)(a1 + 64) / 0x7FFFFFFFu) << 31));
      if (v31 <= 1)
        v31 = 1;
      LODWORD(__p[0]) = v31;
      v52 = (int *)v66;
      v55 = v67;
      if ((uint64_t)((uint64_t)v67 - v66) >= 5)
      {
        v32 = (unint64_t)(v67 - 1);
        if ((unint64_t)(v67 - 1) > v66)
        {
          v33 = (((unint64_t)v67 - v66) >> 2) - 1;
          v34 = (int *)v66;
          do
          {
            v62 = 0;
            v63[0] = v33;
            v35 = std::uniform_int_distribution<long>::operator()<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>>((uint64_t)__p, &v62);
            if (v35)
            {
              v36 = *v34;
              *v34 = v34[v35];
              v34[v35] = v36;
            }
            ++v34;
            --v33;
          }
          while ((unint64_t)v34 < v32);
        }
      }
      v37 = v52;
      if (v55 == v52)
      {
        v40 = v59;
      }
      else
      {
        std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v62);
        if (v52 != v55 - 1)
        {
          v38 = v52;
          do
          {
            std::ostream::operator<<();
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v62, (uint64_t)" ", 1);
            ++v38;
          }
          while (v38 != v55 - 1);
        }
        std::ostream::operator<<();
        v39 = *(_DWORD *)(a1 + 56);
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(__p, (uint64_t)v63);
        v40 = v59;
        v41 = __p;
        if (v61 < 0)
          v41 = (void **)__p[0];
        syslog(5, "FaceID: %d slots for %s", v39, (const char *)v41);
        if (v61 < 0)
          operator delete(__p[0]);
        v62 = v50;
        *(_QWORD *)((char *)&v63[-1] + *(_QWORD *)(v50 - 24)) = v49;
        v63[0] = v48;
        if (v64 < 0)
          operator delete((void *)v63[8]);
        std::streambuf::~streambuf();
        std::ostream::~ostream();
        MEMORY[0x1A1B0A808](&v65);
        while (v12 < *(_DWORD *)(a1 + 56))
        {
          v42 = *v37;
          if ((int)v42 >= (int)v58)
          {
            syslog(5, "FaceID: cannot place label %d with %d slots", *v37, v58);
            break;
          }
          if ((v70[v42 >> 6] & (1 << v42)) != 0)
          {
            v40 = v59;
          }
          else
          {
            syslog(5, "FaceID: taking slot %d", *v37);
            v70[v42 >> 6] |= 1 << v42;
            v43 = (float *)vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(a2, v42);
            v44 = (double *)vision::mod::CVMLMatrix<double,16ul>::ptr(v54, v12 + v56);
            v40 = v59;
            if ((int)v9 >= 1)
            {
              v45 = v9;
              do
              {
                v46 = *v43++;
                *v44++ = v46;
                --v45;
              }
              while (v45);
            }
            ++v12;
          }
          if (++v37 == v55)
            break;
        }
      }
      syslog(5, "FaceID: label %d -> %d...%d", v40, v56, v12 + v56 - 1);
      v47 = std::__hash_table<std::__hash_value_type<int,std::pair<int,int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::pair<int,int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::pair<int,int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::pair<int,int>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((float *)(a1 + 224), v40, &v69);
      *((_DWORD *)v47 + 5) = v56;
      *((_DWORD *)v47 + 6) = v12;
      if (v52)
        operator delete(v52);
      v10 = (uint64_t *)*v10;
      v56 += v12;
    }
    while (v10);
  }
LABEL_64:
  if (v70)
    operator delete(v70);
}

void sub_1A149FB00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,char a37)
{
  uint64_t v37;
  void *v39;

  v39 = *(void **)(v37 - 128);
  if (v39)
    operator delete(v39);
  _Unwind_Resume(exception_object);
}

uint64_t std::uniform_int_distribution<long>::operator()<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>>(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  _BYTE v10[64];

  result = a2[1];
  v5 = result - *a2;
  if (result != *a2)
  {
    v6 = v5 + 1;
    if (v5 == -1)
    {
      std::__independent_bits_engine<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>,unsigned long>::__independent_bits_engine((uint64_t)v10, a1, 0x40uLL);
      return std::__independent_bits_engine<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>,unsigned long>::__eval((uint64_t)v10);
    }
    else
    {
      v7 = __clz(v6);
      v8 = 63;
      if (((v6 << v7) & 0x7FFFFFFFFFFFFFFFLL) != 0)
        v8 = 64;
      std::__independent_bits_engine<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>,unsigned long>::__independent_bits_engine((uint64_t)v10, a1, v8 - v7);
      do
        v9 = std::__independent_bits_engine<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>,unsigned long>::__eval((uint64_t)v10);
      while (v9 >= v6);
      return *a2 + v9;
    }
  }
  return result;
}

uint64_t std::__independent_bits_engine<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>,unsigned long>::__independent_bits_engine(uint64_t result, uint64_t a2, unint64_t a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unsigned int v6;
  unsigned int v7;

  *(_QWORD *)result = a2;
  *(_QWORD *)(result + 8) = a3;
  if (a3 % 0x1E)
    v3 = a3 / 0x1E + 1;
  else
    v3 = a3 / 0x1E;
  v4 = a3 / v3;
  *(_QWORD *)(result + 16) = a3 / v3;
  *(_QWORD *)(result + 24) = v3;
  v5 = (-1 << (a3 / v3)) & 0x7FFFFFFE;
  if (a3 / v3 >= 0x40)
    v5 = 0;
  *(_QWORD *)(result + 40) = v5;
  if ((v5 ^ 0x7FFFFFFE) > v5 / v3)
  {
    ++v3;
    v4 = a3 / v3;
    *(_QWORD *)(result + 16) = a3 / v3;
    *(_QWORD *)(result + 24) = v3;
    if (a3 / v3 > 0x3F)
    {
      *(_QWORD *)(result + 32) = v3 - a3 + (v3 << 6);
      *(_QWORD *)(result + 40) = 0;
      LOBYTE(v4) = 64;
      goto LABEL_15;
    }
    *(_QWORD *)(result + 40) = (-1 << v4) & 0x7FFFFFFE;
  }
  *(_QWORD *)(result + 32) = v3 + a3 / v3 * v3 - a3;
  if (v4 >= 0x3F)
  {
LABEL_15:
    *(_QWORD *)(result + 48) = 0;
    v6 = -1;
    *(_DWORD *)(result + 56) = 0xFFFFFFFF >> -(char)v4;
    goto LABEL_16;
  }
  *(_QWORD *)(result + 48) = 0x3FFFFFFFuLL >> v4 << (v4 + 1);
  v6 = -1;
  v7 = 0xFFFFFFFF >> -(char)v4;
  if (!v4)
    v7 = 0;
  *(_DWORD *)(result + 56) = v7;
  if (v4 <= 0x1E)
    v6 = 0xFFFFFFFF >> ~(_BYTE)v4;
LABEL_16:
  *(_DWORD *)(result + 60) = v6;
  return result;
}

uint64_t std::__independent_bits_engine<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>,unsigned long>::__eval(uint64_t a1)
{
  unint64_t v2;
  uint64_t result;
  uint64_t v4;
  unint64_t v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  BOOL v9;
  unsigned int v10;
  int v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unsigned int *v15;
  unint64_t v16;
  unint64_t v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  unint64_t v24;
  uint64_t v25;

  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
  {
    result = 0;
    v4 = 0;
    v5 = *(_QWORD *)(a1 + 16);
    v6 = **(_DWORD **)a1;
    do
    {
      do
      {
        v7 = v6 / 0xADC8;
        v8 = 48271 * (v6 % 0xADC8);
        v7 *= 3399;
        v9 = v8 >= v7;
        v10 = v8 - v7;
        if (v9)
          v11 = 0;
        else
          v11 = 0x7FFFFFFF;
        v6 = v11 + v10;
        v12 = v6 - 1;
      }
      while (*(_QWORD *)(a1 + 40) <= v12);
      v13 = result << v5;
      if (v5 >= 0x40)
        v13 = 0;
      result = v13 + (*(_DWORD *)(a1 + 56) & v12);
      ++v4;
    }
    while (v4 != v2);
    **(_DWORD **)a1 = v6;
  }
  else
  {
    result = 0;
  }
  v14 = *(_QWORD *)(a1 + 24);
  if (v2 < v14)
  {
    v15 = *(unsigned int **)a1;
    v16 = *(_QWORD *)(a1 + 48);
    v17 = *(_QWORD *)(a1 + 16);
    v18 = *(_DWORD *)(a1 + 60);
    v19 = *v15;
    while (1)
    {
      v20 = v19 / 0xADC8;
      v21 = 48271 * (v19 % 0xADC8);
      v20 *= 3399;
      v9 = v21 >= v20;
      v22 = v21 - v20;
      if (v9)
        v23 = 0;
      else
        v23 = 0x7FFFFFFF;
      v19 = v23 + v22;
      v24 = v19 - 1;
      if (v16 > v24)
      {
        v25 = result << (v17 + 1);
        if (v17 >= 0x3F)
          v25 = 0;
        result = v25 + (v18 & v24);
        if (++v2 == v14)
          break;
      }
    }
    *v15 = v19;
  }
  return result;
}

uint64_t vision::mod::FaceIDModel::buildModel(uint64_t a1, _QWORD *a2, _QWORD *a3, uint64_t a4)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  double v12;
  const char *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v17;
  _QWORD *v18;
  unint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  _QWORD *v23;
  int v24;
  int v25;
  _QWORD *v26;
  unint64_t *v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint8x8_t v32;
  _QWORD *v33;
  _QWORD *i;
  unint64_t v35;
  _QWORD *v36;
  float v37;
  _BOOL8 v38;
  unint64_t v39;
  unint64_t v40;
  int8x8_t prime;
  void *v42;
  void *v43;
  uint64_t v44;
  _QWORD **v45;
  unint64_t v46;
  uint8x8_t v47;
  unint64_t v48;
  uint8x8_t v49;
  uint64_t v50;
  _QWORD *j;
  unint64_t v52;
  uint64_t v53;
  _QWORD *v54;
  unint64_t v55;
  void *v56;
  uint64_t *k;
  unint64_t v58;
  uint8x8_t v59;
  unint64_t v60;
  _QWORD *v61;
  _QWORD *m;
  unint64_t v63;
  unint64_t v64;
  _QWORD *v65;
  _QWORD *v66;
  unint64_t v67;
  char *v68;
  _DWORD *v69;
  char *v70;
  uint64_t v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t v75;
  _DWORD *v76;
  int v77;
  uint64_t *v78;
  int *v79;
  int *v80;
  unint64_t v81;
  int v82;
  int *v83;
  uint64_t v84;
  unint64_t v85;
  unint64_t v86;
  uint64_t v87;
  int *v88;
  int v89;
  uint64_t *v90;
  int v91;
  __int128 v92;
  uint64_t *v93;
  unint64_t v94;
  _QWORD *v95;
  _QWORD *v96;
  uint64_t v97;
  uint64_t n;
  int *v99;
  uint64_t *v100;
  int *v101;
  int *v102;
  int v103;
  unint64_t *v104;
  uint64_t v105;
  _QWORD *v106;
  int v107;
  int *v108;
  _QWORD *v109;
  void *v110;
  const void *v111;
  int v112;
  _QWORD *v113;
  uint64_t *v114;
  uint64_t v115;
  int v116;
  _QWORD *v117;
  _QWORD *v118;
  uint64_t v119;
  uint64_t ii;
  uint64_t *v121;
  vision::mod::FaceIDModel *v122;
  int v123;
  uint64_t *v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  vision::mod::FaceIDModel *v129;
  uint64_t v130;
  int v131;
  int v132;
  uint64_t v133;
  uint64_t v134;
  unint64_t v135;
  uint64_t v136;
  int v137;
  double *v138;
  float *v139;
  uint64_t v140;
  float v141;
  uint64_t v142;
  const char *v143;
  uint64_t *v144;
  uint64_t v145;
  uint64_t v146;
  int v147;
  int v148;
  unint64_t v149;
  unint64_t v150;
  uint64_t v151;
  int v152;
  double *v153;
  float *v154;
  uint64_t v155;
  float v156;
  uint64_t v157;
  unint64_t v158;
  int v159;
  uint64_t v160;
  unint64_t v161;
  unint64_t v162;
  double v163;
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v164;
  uint64_t v165;
  uint64_t v166;
  unint64_t v167;
  unint64_t v168;
  double *v169;
  uint64_t v170;
  uint64_t v171;
  std::vector<int>::size_type v172;
  double *v173;
  double v174;
  uint64_t v175;
  uint64_t v176;
  double v177;
  double *v178;
  std::vector<int>::size_type v179;
  uint64_t v180;
  double v181;
  double v182;
  uint64_t v183;
  int v184;
  int v185;
  _QWORD *v186;
  unint64_t v187;
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> *p_p;
  uint64_t v189;
  double v190;
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v191;
  uint64_t jj;
  uint64_t kk;
  uint64_t v194;
  double v195;
  unint64_t v196;
  std::vector<int>::size_type v197;
  int v198;
  void *v199;
  uint64_t v200;
  const void *v201;
  size_t v202;
  double *v203;
  unint64_t v204;
  double *v205;
  uint64_t v206;
  std::vector<int>::pointer begin;
  double *v208;
  double v209;
  double v210;
  double *v211;
  double v212;
  uint64_t v213;
  double *v214;
  double v215;
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v216;
  double v217;
  std::vector<int>::pointer v218;
  std::vector<int>::size_type v219;
  std::vector<int>::size_type v220;
  double *v221;
  double *v222;
  double v223;
  unint64_t v224;
  void *v225;
  const void *v226;
  uint64_t v227;
  double *v228;
  uint64_t v229;
  char *v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  double v236;
  uint64_t v237;
  double *v238;
  double v239;
  double v240;
  double *v241;
  double v242;
  void *v243;
  const void *v244;
  void *v245;
  std::vector<int>::size_type v246;
  uint64_t v247;
  int v248;
  unint64_t v249;
  unint64_t mm;
  void *v251;
  const void *v252;
  std::vector<int>::pointer v253;
  std::vector<int>::pointer v254;
  unint64_t v255;
  uint64_t v256;
  void *v257;
  uint64_t nn;
  unint64_t i1;
  unint64_t v260;
  int v261;
  const double *v262;
  double *v263;
  unint64_t v264;
  char *v265;
  char *v266;
  uint64_t i2;
  uint64_t v268;
  unint64_t v269;
  unint64_t v270;
  uint64_t v271;
  char *v272;
  char *v273;
  int v274;
  uint64_t *v275;
  uint64_t *v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t *v279;
  uint64_t v280;
  uint64_t v281;
  size_t v282;
  uint64_t v283;
  unint64_t v284;
  void *v285;
  const void *v286;
  double v287;
  unint64_t i3;
  void *v289;
  const void *v290;
  int v291;
  const double *v292;
  double *v293;
  double *v294;
  double v295;
  uint64_t v296;
  double v297;
  double v298;
  double v300;
  unint64_t i4;
  void *v302;
  const void *v303;
  _QWORD *v304;
  uint64_t v305;
  unint64_t v306;
  unsigned int v307;
  unint64_t *v308;
  std::logic_error *v309;
  std::logic_error *v310;
  std::logic_error *v311;
  std::logic_error *v312;
  std::logic_error *v313;
  std::logic_error *v314;
  void *v315;
  const void *v316;
  unint64_t v317;
  void *v318;
  _QWORD *v319;
  unint64_t v320;
  uint64_t v321;
  uint64_t v322;
  __int128 v323;
  int v324;
  int v325;
  unint64_t v326;
  unint64_t v327;
  std::logic_error *exception;
  uint64_t v329;
  uint64_t v330;
  int v331;
  float *v332;
  std::vector<int>::size_type v333;
  uint64_t v334;
  uint64_t *v335;
  int v336;
  int v337;
  uint64_t *v338;
  int v339;
  int v340;
  int v341;
  int v342;
  void *v343;
  int v344;
  uint64_t v345;
  vision::mod::FaceIDModel *v346;
  uint64_t v348;
  unint64_t v349;
  _QWORD **v350;
  uint64_t v351;
  __int128 v352;
  __int128 v353;
  int v354;
  _OWORD v355[2];
  int v356;
  void *v357[2];
  unint64_t v358;
  unint64_t v359;
  uint64_t v360;
  char v361;
  void *v362[2];
  std::vector<int>::size_type v363;
  unint64_t v364;
  uint64_t v365;
  char v366;
  unsigned int v367;
  double v368;
  void *v369;
  void *v370;
  unint64_t v371;
  unint64_t v372;
  uint64_t v373;
  char v374;
  void *v375[2];
  __int128 v376;
  char v377;
  void *v378[2];
  __int128 v379;
  char v380;
  double v381;
  std::vector<int>::value_type v382[2];
  double *v383;
  char v384;
  std::vector<int> v385;
  void *v386[2];
  __int128 v387;
  uint64_t v388;
  char v389;
  void *v390[2];
  unint64_t v391;
  unint64_t v392;
  uint64_t v393;
  char v394;
  void *v395[2];
  __int128 v396;
  int v397;
  char v398;
  void *__src;
  double *v400;
  std::vector<int> v401;
  void *__dst;
  void *v403;
  std::vector<int>::value_type __x[2];
  std::vector<int>::value_type *v405;
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> __p;
  uint64_t v407;

  v407 = *MEMORY[0x1E0C80C00];
  v5 = a2[12];
  v6 = a2[9];
  if (a2[8])
    v7 = v5 == 0;
  else
    v7 = 1;
  if (v7 || v6 == 0)
  {
    syslog(5, "FaceID: invalid image descriptor buffer for training");
    return 7804;
  }
  if (v6 != (uint64_t)(a3[1] - *a3) >> 2)
  {
    syslog(5, "FaceID: size mismatch between descriptors and their labels");
    return 7804;
  }
  if (*(int *)(a1 + 48) < 1)
  {
    syslog(5, "ERROR: negative or zero minElems_");
LABEL_28:
    v14 = &CVML_status_invalidParameter;
    goto LABEL_29;
  }
  if (*(int *)(a1 + 44) < 1)
  {
    syslog(5, "ERROR: negative or zero maxNumIds_");
    goto LABEL_28;
  }
  if (*(int *)(a1 + 52) < 1)
  {
    syslog(5, "ERROR: negative or zero minNumIds_");
    goto LABEL_28;
  }
  if (*(int *)(a1 + 72) < 1)
  {
    syslog(5, "ERROR: negative or zero maxIter_");
    goto LABEL_28;
  }
  if (*(int *)(a1 + 68) < 1)
  {
    v13 = "ERROR: negative or zero nInits_ in kmeans";
LABEL_27:
    syslog(5, v13);
    goto LABEL_28;
  }
  v12 = *(double *)(a1 + 80);
  v13 = "ERROR: invalid tol_ in kmeans";
  if (v12 >= 1.0 || v12 <= 0.0)
    goto LABEL_27;
  v14 = &CVML_status_ok;
LABEL_29:
  v17 = *v14 + 128;
  if (v17 != 128)
    return v17 | 0x1E00;
  v346 = (vision::mod::FaceIDModel *)a1;
  memset(v355, 0, sizeof(v355));
  v356 = 1065353216;
  v352 = 0u;
  v353 = 0u;
  v354 = 1065353216;
  v19 = (unint64_t *)a2[1];
  v18 = (_QWORD *)a2[2];
  v20 = (uint64_t)(a3[1] - *a3) >> 2;
  v21 = a2[9];
  if (v18 - v19 != v20 || v21 != v20)
  {
    syslog(5, "ERROR: size mismatch - descIds=%lu labels=%lu descriptors=%lu", v18 - v19, (uint64_t)(a3[1] - *a3) >> 2, v21);
    syslog(5, "ERROR: error happened in searching updated labels");
    goto LABEL_129;
  }
  v334 = a4;
  if (v18 == v19)
  {
    memset(&__p, 0, 32);
    __p.__x_[8] = 1065353216;
    goto LABEL_131;
  }
  v22 = 0;
  do
  {
    v23 = std::__hash_table<std::__hash_value_type<long long,int>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,int>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,int>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,int>>>::find<long long>(v346, v19[v22]);
    if (v23)
    {
      v24 = *((_DWORD *)v23 + 6);
      v25 = *(_DWORD *)(*a3 + 4 * v22);
      v26 = a2;
      if (v24 == v25)
        goto LABEL_41;
      if ((v24 & 0x80000000) == 0)
      {
        std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>((float *)&v352, v24, v24);
        v25 = *(_DWORD *)(*a3 + 4 * v22);
      }
    }
    else
    {
      v25 = *(_DWORD *)(*a3 + 4 * v22);
      v26 = a2;
      if (v25 == -1)
        goto LABEL_41;
    }
    if ((v25 & 0x80000000) == 0)
      std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>((float *)&v352, v25, v25);
LABEL_41:
    ++v22;
    v28 = v26 + 1;
    v19 = (unint64_t *)v26[1];
    v27 = (unint64_t *)v28[1];
  }
  while (v22 < v27 - v19);
  memset(&__p, 0, 32);
  __p.__x_[8] = 1065353216;
  if (v19 != v27)
  {
    v29 = 0;
    v30 = 0;
    while (1)
    {
      v31 = *v19;
      if (v29)
      {
        v32 = (uint8x8_t)vcnt_s8((int8x8_t)v29);
        v32.i16[0] = vaddlv_u8(v32);
        if (v32.u32[0] > 1uLL)
        {
          v4 = *v19;
          if (v31 >= v29)
            v4 = v31 % v29;
        }
        else
        {
          v4 = (v29 - 1) & v31;
        }
        v33 = *(_QWORD **)(*(_QWORD *)__p.__x_ + 8 * v4);
        if (v33)
        {
          for (i = (_QWORD *)*v33; i; i = (_QWORD *)*i)
          {
            v35 = i[1];
            if (v35 == v31)
            {
              if (i[2] == v31)
                goto LABEL_116;
            }
            else
            {
              if (v32.u32[0] > 1uLL)
              {
                if (v35 >= v29)
                  v35 %= v29;
              }
              else
              {
                v35 &= v29 - 1;
              }
              if (v35 != v4)
                break;
            }
          }
        }
      }
      v36 = operator new(0x18uLL);
      *v36 = 0;
      v36[1] = v31;
      v36[2] = *v19;
      v37 = (float)(unint64_t)(v30 + 1);
      if (!v29 || (float)(*(float *)&__p.__x_[8] * (float)v29) < v37)
        break;
LABEL_106:
      v53 = *(_QWORD *)__p.__x_;
      v54 = *(_QWORD **)(*(_QWORD *)__p.__x_ + 8 * v4);
      if (v54)
      {
        *v36 = *v54;
      }
      else
      {
        *v36 = *(_QWORD *)&__p.__x_[4];
        *(_QWORD *)&__p.__x_[4] = v36;
        *(_QWORD *)(v53 + 8 * v4) = &__p.__x_[4];
        if (!*v36)
          goto LABEL_115;
        v55 = *(_QWORD *)(*v36 + 8);
        if ((v29 & (v29 - 1)) != 0)
        {
          if (v55 >= v29)
            v55 %= v29;
        }
        else
        {
          v55 &= v29 - 1;
        }
        v54 = (_QWORD *)(*(_QWORD *)__p.__x_ + 8 * v55);
      }
      *v54 = v36;
LABEL_115:
      v30 = ++*(_QWORD *)&__p.__x_[6];
LABEL_116:
      if (++v19 == v27)
        goto LABEL_131;
    }
    v38 = (v29 & (v29 - 1)) != 0;
    if (v29 < 3)
      v38 = 1;
    v39 = v38 | (2 * v29);
    v40 = vcvtps_u32_f32(v37 / *(float *)&__p.__x_[8]);
    if (v39 <= v40)
      prime = (int8x8_t)v40;
    else
      prime = (int8x8_t)v39;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v29 = *(_QWORD *)&__p.__x_[2];
    }
    if (*(_QWORD *)&prime <= v29)
    {
      if (*(_QWORD *)&prime < v29)
      {
        v48 = vcvtps_u32_f32((float)*(unint64_t *)&__p.__x_[6] / *(float *)&__p.__x_[8]);
        if (v29 < 3 || (v49 = (uint8x8_t)vcnt_s8((int8x8_t)v29), v49.i16[0] = vaddlv_u8(v49), v49.u32[0] > 1uLL))
        {
          v48 = std::__next_prime(v48);
        }
        else
        {
          v50 = 1 << -(char)__clz(v48 - 1);
          if (v48 >= 2)
            v48 = v50;
        }
        if (*(_QWORD *)&prime <= v48)
          prime = (int8x8_t)v48;
        if (*(_QWORD *)&prime >= v29)
        {
          v29 = *(_QWORD *)&__p.__x_[2];
        }
        else
        {
          if (prime)
            goto LABEL_72;
          v56 = *(void **)__p.__x_;
          *(_QWORD *)__p.__x_ = 0;
          if (v56)
            operator delete(v56);
          v29 = 0;
          *(_QWORD *)&__p.__x_[2] = 0;
        }
      }
    }
    else
    {
LABEL_72:
      if (*(_QWORD *)&prime >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v42 = operator new(8 * *(_QWORD *)&prime);
      v43 = *(void **)__p.__x_;
      *(_QWORD *)__p.__x_ = v42;
      if (v43)
        operator delete(v43);
      v44 = 0;
      *(int8x8_t *)&__p.__x_[2] = prime;
      do
        *(_QWORD *)(*(_QWORD *)__p.__x_ + 8 * v44++) = 0;
      while (*(_QWORD *)&prime != v44);
      v45 = *(_QWORD ***)&__p.__x_[4];
      if (*(_QWORD *)&__p.__x_[4])
      {
        v46 = *(_QWORD *)(*(_QWORD *)&__p.__x_[4] + 8);
        v47 = (uint8x8_t)vcnt_s8(prime);
        v47.i16[0] = vaddlv_u8(v47);
        if (v47.u32[0] > 1uLL)
        {
          if (v46 >= *(_QWORD *)&prime)
            v46 %= *(_QWORD *)&prime;
        }
        else
        {
          v46 &= *(_QWORD *)&prime - 1;
        }
        *(_QWORD *)(*(_QWORD *)__p.__x_ + 8 * v46) = &__p.__x_[4];
        for (j = *v45; j; v46 = v52)
        {
          v52 = j[1];
          if (v47.u32[0] > 1uLL)
          {
            if (v52 >= *(_QWORD *)&prime)
              v52 %= *(_QWORD *)&prime;
          }
          else
          {
            v52 &= *(_QWORD *)&prime - 1;
          }
          if (v52 != v46)
          {
            if (!*(_QWORD *)(*(_QWORD *)__p.__x_ + 8 * v52))
            {
              *(_QWORD *)(*(_QWORD *)__p.__x_ + 8 * v52) = v45;
              goto LABEL_97;
            }
            *v45 = (_QWORD *)*j;
            *j = **(_QWORD **)(*(_QWORD *)__p.__x_ + 8 * v52);
            **(_QWORD **)(*(_QWORD *)__p.__x_ + 8 * v52) = j;
            j = v45;
          }
          v52 = v46;
LABEL_97:
          v45 = (_QWORD **)j;
          j = (_QWORD *)*j;
        }
      }
      v29 = (unint64_t)prime;
    }
    if ((v29 & (v29 - 1)) != 0)
    {
      if (v31 >= v29)
        v4 = v31 % v29;
      else
        v4 = v31;
    }
    else
    {
      v4 = (v29 - 1) & v31;
    }
    goto LABEL_106;
  }
LABEL_131:
  for (k = (uint64_t *)*((_QWORD *)v346 + 2); k; k = (uint64_t *)*k)
  {
    if (*(_QWORD *)&__p.__x_[2])
    {
      v58 = k[2];
      v59 = (uint8x8_t)vcnt_s8(*(int8x8_t *)&__p.__x_[2]);
      v59.i16[0] = vaddlv_u8(v59);
      if (v59.u32[0] > 1uLL)
      {
        v60 = k[2];
        if (v58 >= *(_QWORD *)&__p.__x_[2])
          v60 = v58 % *(_QWORD *)&__p.__x_[2];
      }
      else
      {
        v60 = (*(_QWORD *)&__p.__x_[2] - 1) & v58;
      }
      v61 = *(_QWORD **)(*(_QWORD *)__p.__x_ + 8 * v60);
      if (v61)
      {
        for (m = (_QWORD *)*v61; m; m = (_QWORD *)*m)
        {
          v63 = m[1];
          if (v63 == v58)
          {
            if (m[2] == v58)
              goto LABEL_149;
          }
          else
          {
            if (v59.u32[0] > 1uLL)
            {
              if (v63 >= *(_QWORD *)&__p.__x_[2])
                v63 %= *(_QWORD *)&__p.__x_[2];
            }
            else
            {
              v63 &= *(_QWORD *)&__p.__x_[2] - 1;
            }
            if (v63 != v60)
              break;
          }
        }
      }
    }
    std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>((float *)&v352, *((_DWORD *)k + 6), *((_DWORD *)k + 6));
LABEL_149:
    ;
  }
  if (a2[2] != a2[1])
  {
    v64 = 0;
    do
    {
      v65 = std::__hash_table<std::__hash_value_type<int,std::vector<int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<int>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t *)v355, *(_DWORD *)(*a3 + 4 * v64), (_DWORD *)(*a3 + 4 * v64));
      v66 = v65;
      v68 = (char *)v65[4];
      v67 = v65[5];
      if ((unint64_t)v68 >= v67)
      {
        v70 = (char *)v65[3];
        v71 = (v68 - v70) >> 2;
        v72 = v71 + 1;
        if ((unint64_t)(v71 + 1) >> 62)
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        v73 = v67 - (_QWORD)v70;
        if (v73 >> 1 > v72)
          v72 = v73 >> 1;
        if ((unint64_t)v73 >= 0x7FFFFFFFFFFFFFFCLL)
          v74 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v74 = v72;
        if (v74)
        {
          v74 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v74);
          v70 = (char *)v66[3];
          v68 = (char *)v66[4];
        }
        else
        {
          v75 = 0;
        }
        v76 = (_DWORD *)(v74 + 4 * v71);
        *v76 = v64;
        v69 = v76 + 1;
        while (v68 != v70)
        {
          v77 = *((_DWORD *)v68 - 1);
          v68 -= 4;
          *--v76 = v77;
        }
        v66[3] = v76;
        v66[4] = v69;
        v66[5] = v74 + 4 * v75;
        if (v70)
          operator delete(v70);
      }
      else
      {
        *(_DWORD *)v68 = v64;
        v69 = v68 + 4;
      }
      v66[4] = v69;
      ++v64;
    }
    while (v64 < (uint64_t)(a2[2] - a2[1]) >> 3);
  }
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table((uint64_t)&__p);
  if (!*((_QWORD *)&v353 + 1))
  {
    v15 = 7808;
    goto LABEL_520;
  }
  v78 = (uint64_t *)*((_QWORD *)v346 + 25);
  v350 = (_QWORD **)((char *)v346 + 200);
  v79 = 0;
  v80 = 0;
  if (v78)
  {
    v81 = 0;
    v339 = 0;
    do
    {
      v82 = *((_DWORD *)v78 + 4);
      if (!std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::find<int>(&v352, v82))
      {
        if ((unint64_t)v80 >= v81)
        {
          v84 = v80 - v79;
          v85 = v84 + 1;
          if ((unint64_t)(v84 + 1) >> 62)
            std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
          if ((uint64_t)(v81 - (_QWORD)v79) >> 1 > v85)
            v85 = (uint64_t)(v81 - (_QWORD)v79) >> 1;
          if (v81 - (unint64_t)v79 >= 0x7FFFFFFFFFFFFFFCLL)
            v86 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v86 = v85;
          if (v86)
          {
            v86 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v86);
            v82 = *((_DWORD *)v78 + 4);
          }
          else
          {
            v87 = 0;
          }
          v88 = (int *)(v86 + 4 * v84);
          *v88 = v82;
          v83 = v88 + 1;
          while (v80 != v79)
          {
            v89 = *--v80;
            *--v88 = v89;
          }
          v81 = v86 + 4 * v87;
          if (v79)
            operator delete(v79);
          v79 = v88;
        }
        else
        {
          *v80 = v82;
          v83 = v80 + 1;
        }
        v339 += *((_DWORD *)v78 + 6);
        v80 = v83;
      }
      v78 = (uint64_t *)*v78;
    }
    while (v78);
  }
  else
  {
    v339 = 0;
  }
  v90 = (uint64_t *)v353;
  v91 = v339;
  if ((_QWORD)v353)
  {
    v92 = v355[0];
    v91 = v339;
    do
    {
      v93 = std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::find<int>(v92, *((unint64_t *)&v92 + 1), *((_DWORD *)v90 + 4));
      if (v93)
      {
        v94 = (unint64_t)(v93[4] - v93[3]) >> 2;
        if (*((_DWORD *)v346 + 10) < (int)v94)
          LODWORD(v94) = *((_DWORD *)v346 + 10);
        v91 += v94;
      }
      v90 = (uint64_t *)*v90;
    }
    while (v90);
  }
  v332 = (float *)((char *)v346 + 184);
  if (*((_QWORD *)v346 + 3))
  {
    v95 = (_QWORD *)*((_QWORD *)v346 + 2);
    if (v95)
    {
      do
      {
        v96 = (_QWORD *)*v95;
        operator delete(v95);
        v95 = v96;
      }
      while (v96);
    }
    *((_QWORD *)v346 + 2) = 0;
    v97 = *((_QWORD *)v346 + 1);
    if (v97)
    {
      for (n = 0; n != v97; ++n)
        *(_QWORD *)(*(_QWORD *)v346 + 8 * n) = 0;
    }
    *((_QWORD *)v346 + 3) = 0;
  }
  if (v79 == v80)
  {
LABEL_216:
    v105 = (int)v5;
    vision::mod::CVMLMatrix<double,16ul>::reset((uint64_t)v346 + 136, 0, (int)v5);
    if (!v339)
    {
      vision::mod::CVMLMatrix<double,16ul>::reset((uint64_t)v346 + 88, v91, (int)v5);
      if (*((_QWORD *)v346 + 26))
      {
        v117 = *v350;
        if (*v350)
        {
          do
          {
            v118 = (_QWORD *)*v117;
            operator delete(v117);
            v117 = v118;
          }
          while (v118);
        }
        *((_QWORD *)v346 + 25) = 0;
        v119 = *((_QWORD *)v346 + 24);
        if (v119)
        {
          for (ii = 0; ii != v119; ++ii)
            *(_QWORD *)(*(_QWORD *)v332 + 8 * ii) = 0;
        }
        v116 = 0;
        *((_QWORD *)v346 + 26) = 0;
      }
      else
      {
        v116 = 0;
      }
      v15 = 7808;
      goto LABEL_239;
    }
    vision::mod::CVMLMatrix<double,16ul>::initialize_((uint64_t)&__p, v339, (int)v5);
    *(_OWORD *)v395 = 0u;
    v396 = 0u;
    v397 = 1065353216;
    if (*((_QWORD *)v346 + 14) == (int)v5 && *(_QWORD *)&__p.__x_[8] == *((_QWORD *)v346 + 15))
    {
      v348 = *(_QWORD *)&__p.__x_[8];
      v106 = (_QWORD *)((char *)v346 + 88);
      if (v79 == v80)
      {
        v107 = 0;
      }
      else
      {
        v107 = 0;
        v108 = v79;
        do
        {
          v109 = std::__hash_table<std::__hash_value_type<int,std::pair<int,int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::pair<int,int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::pair<int,int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::pair<int,int>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(v332, *v108, v108);
          v110 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(&__p, v107);
          v111 = (const void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v106, *((int *)v109 + 5));
          memcpy(v110, v111, 8 * *((_QWORD *)v346 + 15) * *((int *)v109 + 6));
          v112 = *((_DWORD *)v109 + 6);
          v113 = std::__hash_table<std::__hash_value_type<int,std::pair<int,int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::pair<int,int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::pair<int,int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::pair<int,int>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((float *)v395, *v108, v108);
          *((_DWORD *)v113 + 5) = v107;
          *((_DWORD *)v113 + 6) = v112;
          v107 += *((_DWORD *)v109 + 6);
          ++v108;
        }
        while (v108 != v80);
      }
      vision::mod::CVMLMatrix<double,16ul>::reset((uint64_t)v106, v91, v105);
      if (v107 == v339)
      {
        if (*((_QWORD *)v346 + 15) == v348)
        {
          v315 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v106, 0);
          v316 = (const void *)vision::mod::CVMLMatrix<double,16ul>::ptr(&__p, 0);
          memcpy(v315, v316, 8 * v348 * *(_QWORD *)&__p.__x_[4]);
          v318 = (void *)*((_QWORD *)v346 + 23);
          v317 = *((_QWORD *)v346 + 24);
          v319 = v395[0];
          v320 = (unint64_t)v395[1];
          v322 = *((_QWORD *)v346 + 25);
          v321 = *((_QWORD *)v346 + 26);
          v323 = v396;
          v324 = *((_DWORD *)v346 + 54);
          v325 = v397;
          *((void **)v346 + 23) = v395[0];
          *((_QWORD *)v346 + 24) = v320;
          v395[0] = v318;
          v395[1] = (void *)v317;
          *(_OWORD *)((char *)v346 + 200) = v323;
          *(_QWORD *)&v396 = v322;
          *((_QWORD *)&v396 + 1) = v321;
          *((_DWORD *)v346 + 54) = v325;
          v397 = v324;
          if (*((_QWORD *)&v323 + 1))
          {
            v326 = *(_QWORD *)(v323 + 8);
            if ((v320 & (v320 - 1)) != 0)
            {
              if (v326 >= v320)
                v326 %= v320;
            }
            else
            {
              v326 &= v320 - 1;
            }
            v319[v326] = v350;
          }
          if (v321)
          {
            v327 = *(_QWORD *)(v396 + 8);
            if ((v317 & (v317 - 1)) != 0)
            {
              if (v327 >= v317)
                v327 %= v317;
            }
            else
            {
              v327 &= v317 - 1;
            }
            *((_QWORD *)v395[0] + v327) = &v396;
          }
          v114 = &CVML_status_ok;
          goto LABEL_225;
        }
        v107 = v339;
        syslog(5, "ERROR: size or stride mismatch");
      }
      else
      {
        syslog(5, "ERROR: size or stride mismatch");
      }
    }
    else
    {
      v107 = 0;
      syslog(5, "ERROR: dimension or stride mismatch");
    }
    v114 = &CVML_status_inconsistentState;
    v339 = v107;
LABEL_225:
    v115 = *v114;
    std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table((uint64_t)v395);
    if (LOBYTE(__p.__x_[10]) && *(_QWORD *)__p.__x_)
      free(*(void **)__p.__x_);
    v15 = (v115 + 128) | 0x1E00;
    v116 = v339;
    goto LABEL_239;
  }
  v99 = v79;
  while (1)
  {
    v100 = std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::find<int>(*(uint64_t *)&v355[0], *((unint64_t *)&v355[0] + 1), *v99);
    if (!v100)
      break;
    v101 = (int *)v100[3];
    v102 = (int *)v100[4];
    while (v101 != v102)
    {
      v103 = *v99;
      v104 = (unint64_t *)(a2[1] + 8 * *v101);
      *((_DWORD *)std::__hash_table<std::__hash_value_type<long long,int>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,int>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,int>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,int>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>((float *)v346, *v104, v104)+ 6) = v103;
      ++v101;
    }
    if (++v99 == v80)
      goto LABEL_216;
  }
  syslog(5, "ERROR: incomplete labelInfo");
  v116 = 0;
  v15 = 7806;
LABEL_239:
  if (v79)
    operator delete(v79);
  if (v15 != 128)
  {
    syslog(5, "ERROR: error happened in initializing global dictionary");
    goto LABEL_520;
  }
  v340 = v116;
  v121 = (uint64_t *)v353;
  if (!(_QWORD)v353)
  {
    v122 = v346;
    goto LABEL_516;
  }
  v336 = 0;
  v122 = v346;
  v329 = MEMORY[0x1E0DE5028] + 16;
  v330 = MEMORY[0x1E0DE5038] + 16;
  while (2)
  {
    v123 = *((_DWORD *)v121 + 4);
    v124 = std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::find<int>(*(uint64_t *)&v355[0], *((unint64_t *)&v355[0] + 1), v123);
    if (!v124)
      goto LABEL_265;
    v125 = v124[3];
    v338 = v124;
    v126 = v124[4] - v125;
    if (!v126)
      goto LABEL_265;
    v335 = v121;
    v367 = v123;
    v127 = a2[12];
    v128 = (int)v127;
    if ((int)v127 != *((_QWORD *)v122 + 14))
    {
      v143 = "ERROR: dimension mismatch between input data and global dictionary";
LABEL_258:
      v144 = &CVML_status_inconsistentState;
LABEL_259:
      syslog(5, v143);
      v15 = (*v144 + 128) | 0x1E00;
      goto LABEL_260;
    }
    v129 = v122;
    v130 = a2[7];
    v131 = *((_DWORD *)a2 + 16);
    v132 = *((_DWORD *)a2 + 18);
    v133 = v127 << 32;
    if (*((_DWORD *)v129 + 10) >= (int)((unint64_t)v126 >> 2))
    {
      v150 = 0;
      v151 = 4 * (int)v127;
      while (1)
      {
        v152 = *(_DWORD *)(v125 + 4 * v150);
        v143 = "ERROR: index out of range";
        v144 = &CVML_status_internalError;
        if (v152 >= v132 || v152 < 0)
          goto LABEL_259;
        v153 = (double *)vision::mod::CVMLMatrix<double,16ul>::ptr((_QWORD *)v346 + 11, v340 + (int)v150);
        if (v133)
        {
          v154 = (float *)(v130 + v152 * (uint64_t)v131);
          v155 = v151;
          do
          {
            v156 = *v154++;
            *v153++ = v156;
            v155 -= 4;
          }
          while (v155);
        }
        ++v150;
        v125 = v338[3];
        v157 = v338[4] - v125;
        if (v150 >= v157 >> 2)
        {
          if (std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::find<int>(v332, v123))
          {
            v143 = "ERROR: duplicated labels detected when build sub-dictionary";
            goto LABEL_258;
          }
          v185 = *((_DWORD *)v346 + 10);
          v186 = std::__hash_table<std::__hash_value_type<int,std::pair<int,int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::pair<int,int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::pair<int,int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::pair<int,int>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(v332, v123, (int *)&v367);
          v187 = (unint64_t)v157 >> 2;
          if (v185 < (int)((unint64_t)v157 >> 2))
            LODWORD(v187) = v185;
          *((_DWORD *)v186 + 5) = v340;
          *((_DWORD *)v186 + 6) = v187;
          v183 = 7808;
          goto LABEL_501;
        }
      }
    }
    vision::mod::CVMLMatrix<double,16ul>::initialize_((uint64_t)v362, (int)(v126 >> 2), (int)v127);
    v134 = v338[3];
    if (v338[4] != v134)
    {
      v135 = 0;
      v136 = 4 * v128;
      while (1)
      {
        v137 = *(_DWORD *)(v134 + 4 * v135);
        if (v137 >= v132 || v137 < 0)
          break;
        v138 = (double *)vision::mod::CVMLMatrix<double,16ul>::ptr(v362, (int)v135);
        if (v133)
        {
          v139 = (float *)(v130 + v137 * (uint64_t)v131);
          v140 = v136;
          do
          {
            v141 = *v139++;
            *v138++ = v141;
            v140 -= 4;
          }
          while (v140);
        }
        ++v135;
        v134 = v338[3];
        v142 = v338[4] - v134;
        if (v135 >= v142 >> 2)
          goto LABEL_277;
      }
      syslog(5, "ERROR: index out of range");
      v184 = 1;
      v183 = 7808;
      v15 = 7806;
      goto LABEL_497;
    }
    v142 = 0;
LABEL_277:
    v158 = (unint64_t)v142 >> 2;
    v159 = *((_DWORD *)v346 + 10);
    if (v159 >= (int)v158)
      v160 = v158;
    else
      v160 = v159;
    v161 = *((_QWORD *)v346 + 13);
    if (v161 <= v340 || (int)v160 + (uint64_t)v340 > v161)
    {
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(exception, "row index out of range");
LABEL_546:
      exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
      __cxa_throw(exception, (struct type_info *)off_1E452A5D0, MEMORY[0x1E0DE42E0]);
    }
    v333 = (int)v160;
    v162 = *((_QWORD *)v346 + 14);
    if (!v162)
    {
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(exception, "col index out of range");
      goto LABEL_546;
    }
    v163 = *((double *)v346 + 10);
    v164 = *((_DWORD *)v346 + 16);
    v165 = *(_QWORD *)((char *)v346 + 68);
    v166 = *((_QWORD *)v346 + 15);
    v357[0] = (void *)(*((_QWORD *)v346 + 12) + 8 * v166 * v340);
    v357[1] = v357[0];
    v358 = (int)v160;
    v359 = v162;
    v360 = v166;
    v361 = 0;
    v331 = v165;
    if ((int)v165 < 1 || (v341 = HIDWORD(v165), v165 <= 0))
    {
      syslog(5, "ERROR: invalid parameters in kmeans");
      v183 = 7804;
      syslog(5, "ERROR: kmeans error %lu", 7804);
      v184 = 1;
      v15 = 7804;
    }
    else
    {
      v167 = v364;
      vision::mod::CVMLVector<double,16ul>::initialize_((uint64_t)&__p, v364);
      if (*(_QWORD *)&__p.__x_[4] < v364)
      {
        v314 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(v314, "vector length < cols");
        v314->__vftable = (std::logic_error_vtbl *)v329;
        __cxa_throw(v314, (struct type_info *)off_1E452A5D0, MEMORY[0x1E0DE42E0]);
      }
      vision::mod::CVMLMatrix<double,16ul>::mean((uint64_t)v362, &__p, 0);
      v168 = v364;
      v169 = *(double **)&__p.__x_[2];
      if (v364)
      {
        v170 = 0;
        v171 = *(_QWORD *)&__p.__x_[6];
        v173 = (double *)v362[1];
        v172 = v363;
        v174 = (double)v363;
        v175 = 8 * v365;
        do
        {
          v176 = v171 * v170;
          if (v172)
          {
            v177 = 0.0;
            v178 = v173;
            v179 = v172;
            do
            {
              v177 = v177 + (*v178 - v169[v176]) * (*v178 - v169[v176]);
              v178 = (double *)((char *)v178 + v175);
              --v179;
            }
            while (v179);
          }
          else
          {
            v177 = 0.0;
          }
          v169[v176] = v177 / v174;
          ++v170;
          ++v173;
        }
        while (v170 != v168);
      }
      if (v167)
      {
        v180 = 8 * v167;
        v181 = 0.0;
        do
        {
          v182 = *v169++;
          v181 = v181 + v182;
          v180 -= 8;
        }
        while (v180);
      }
      else
      {
        v181 = 0.0;
      }
      if (LOBYTE(__p.__x_[8]) && *(_QWORD *)__p.__x_)
        free(*(void **)__p.__x_);
      *(_OWORD *)v378 = 0u;
      v379 = 0u;
      v380 = 1;
      vision::mod::CVMLMatrix<double,16ul>::mean((uint64_t)v362, v378, 1);
      *(_QWORD *)__p.__x_ = &off_1E453B208;
      *(_QWORD *)&__p.__x_[6] = &__p;
      vision::mod::broadcast<double,16ul>(v362, v378, (uint64_t)&__p, 0, v362);
      p_p = *(std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> **)&__p.__x_[6];
      if (*(std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> **)&__p.__x_[6] == &__p)
      {
        p_p = &__p;
        v189 = 4;
LABEL_311:
        (*(void (**)(void))(*(_QWORD *)p_p->__x_ + 8 * v189))();
      }
      else if (*(_QWORD *)&__p.__x_[6])
      {
        v189 = 5;
        goto LABEL_311;
      }
      *(_OWORD *)v375 = 0u;
      v376 = 0u;
      v377 = 1;
      vision::mod::CVMLMatrix<double,16ul>::rowNorms((uint64_t)v362, v375, 1);
      vision::mod::CVMLMatrix<double,16ul>::initialize_((uint64_t)&v369, (int)v160, v364);
      v190 = v181 / (double)v167 * v163;
      v191 = 5489;
      __p.__x_[0] = 5489;
      for (jj = 1; jj != 624; ++jj)
      {
        v191 = jj + 1812433253 * (v191 ^ (v191 >> 30));
        __p.__x_[jj] = v191;
      }
      __p.__i_ = 0;
      if ((v164 & 0x80000000) == 0)
      {
        __p.__x_[0] = v164;
        for (kk = 1; kk != 624; ++kk)
        {
          v164 = kk + 1812433253 * (v164 ^ (v164 >> 30));
          __p.__x_[kk] = v164;
        }
        __p.__i_ = 0;
      }
      if (v331 >= 1)
      {
        v337 = 0;
        v342 = (int)log((double)(int)v160);
        LODWORD(v194) = v342 + 2;
        if (v342 + 2 <= 1)
          v194 = 1;
        else
          v194 = v194;
        v349 = v342 + 2;
        v351 = v194;
        v195 = 1.79769313e308;
        v345 = v160;
        while (1)
        {
          v197 = v363;
          v196 = v364;
          LODWORD(v405) = 0;
          HIDWORD(v405) = v363 - 1;
          v198 = std::uniform_int_distribution<int>::operator()<std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>(&__p, &v405);
          v199 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(&v369, 0);
          v200 = v198;
          v201 = (const void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v362, v198);
          v202 = 8 * v196;
          memcpy(v199, v201, 8 * v196);
          vision::mod::CVMLMatrix<double,16ul>::initialize_((uint64_t)v395, 1, v197);
          if (!v371)
            break;
          if (!v372 || v196 > v372)
          {
            v312 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
            std::logic_error::logic_error(v312, "col index out of range");
LABEL_511:
            v312->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
            __cxa_throw(v312, (struct type_info *)off_1E452A5D0, MEMORY[0x1E0DE42E0]);
          }
          v390[0] = v370;
          v390[1] = v370;
          v391 = 1;
          v392 = v196;
          v393 = v373;
          v394 = 0;
          vision::mod::euclideanDistances<double,16ul>((uint64_t)v390, v362, v395, v375);
          if (v394 && v390[0])
            free(v390[0]);
          v203 = (double *)v395[1];
          *((_QWORD *)v395[1] + v200) = 0;
          vision::mod::CVMLMatrix<double,16ul>::initialize_((uint64_t)v390, v349, v196);
          vision::mod::CVMLMatrix<double,16ul>::initialize_((uint64_t)v386, v349, v197);
          std::vector<unsigned long>::vector(v382, v349);
          std::vector<double>::vector(&__dst, v197);
          std::vector<double>::vector(&__src, v197);
          std::vector<double>::vector(&v385, v197);
          if ((int)v160 >= 2)
          {
            v204 = 1;
            do
            {
              v205 = (double *)vision::mod::CVMLMatrix<double,16ul>::ptr(v395, 0);
              v206 = vision::mod::CVMLMatrix<double,16ul>::ptr(v395, 0) + 8 * v197;
              begin = v385.__begin_;
              if (v205 != (double *)v206)
              {
                v209 = *v205;
                v208 = v205 + 1;
                v210 = v209;
                *(double *)v385.__begin_ = v209;
                if (v208 != (double *)v206)
                {
                  v211 = (double *)(begin + 2);
                  do
                  {
                    v212 = *v208++;
                    v210 = v210 + v212;
                    *v211++ = v210;
                  }
                  while (v208 != (double *)v206);
                }
              }
              if (!begin || !v197)
              {
                v311 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
                std::logic_error::logic_error(v311, "empty cumsum vector");
                v311->__vftable = (std::logic_error_vtbl *)v330;
                __cxa_throw(v311, (struct type_info *)off_1E452A5E0, MEMORY[0x1E0DE4360]);
              }
              if (v342 != -2)
              {
                v213 = 0;
                v214 = *(double **)v382;
                v215 = *(double *)&begin[2 * v197 - 2];
                do
                {
                  v216 = std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(&__p) >> 5;
                  v217 = v215
                       * (((double)(std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(&__p) >> 6)
                         + (double)v216 * 67108864.0)
                        * 1.11022302e-16);
                  v218 = begin;
                  v219 = v197;
                  do
                  {
                    v220 = v219 >> 1;
                    v221 = (double *)&v218[2 * (v219 >> 1)];
                    v223 = *v221;
                    v222 = v221 + 1;
                    v219 += ~(v219 >> 1);
                    if (v223 < v217)
                      v218 = (std::vector<int>::pointer)v222;
                    else
                      v219 = v220;
                  }
                  while (v219);
                  *(_QWORD *)&v214[v213++] = ((char *)v218 - (char *)begin) >> 3;
                }
                while (v213 != v349);
                if (v342 >= -1)
                {
                  v224 = 0;
                  do
                  {
                    v225 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v390, v224);
                    v226 = (const void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v362, *(_QWORD *)(*(_QWORD *)v382 + 8 * v224));
                    memcpy(v225, v226, v202);
                    ++v224;
                  }
                  while (v351 != v224);
                }
              }
              vision::mod::euclideanDistances<double,16ul>((uint64_t)v390, v362, v386, v375);
              if (v342 < -1)
              {
                LODWORD(v235) = -1;
              }
              else
              {
                v227 = 0;
                v228 = *(double **)v382;
                v229 = v351;
                v230 = (char *)v386[1];
                v231 = v388;
                do
                {
                  v232 = *(_QWORD *)v228++;
                  *(_QWORD *)&v230[8 * v227 + 8 * v232] = 0;
                  v227 += v231;
                  --v229;
                }
                while (v229);
                v233 = 0;
                v234 = 8 * v231;
                LODWORD(v235) = -1;
                v236 = 1.79769313e308;
                do
                {
                  v237 = 0;
                  v238 = (double *)__src;
                  do
                  {
                    v239 = *(double *)&v230[8 * v237];
                    if (v239 >= v203[v237])
                      v239 = v203[v237];
                    v238[v237++] = v239;
                  }
                  while (v197 != v237);
                  v240 = 0.0;
                  if (v238 != v400)
                  {
                    v241 = v238;
                    do
                    {
                      v242 = *v241++;
                      v240 = v240 + v242;
                    }
                    while (v241 != v400);
                  }
                  if ((_DWORD)v235 == -1 || v240 < v236 && v236 - v240 > 1.0e-14)
                  {
                    v235 = *(_QWORD *)(*(_QWORD *)v382 + 8 * v233);
                    memcpy(__dst, v238, 8 * v197);
                    v236 = v240;
                  }
                  ++v233;
                  v230 += v234;
                }
                while (v233 != v351);
              }
              v243 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(&v369, v204);
              v244 = (const void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v362, (int)v235);
              memcpy(v243, v244, v202);
              v245 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v395, 0);
              memcpy(v245, __dst, 8 * v197);
              ++v204;
              v160 = v345;
            }
            while (v204 != v345);
          }
          if (v385.__begin_)
          {
            v385.__end_ = v385.__begin_;
            operator delete(v385.__begin_);
          }
          if (__src)
          {
            v400 = (double *)__src;
            operator delete(__src);
          }
          if (__dst)
          {
            v403 = __dst;
            operator delete(__dst);
          }
          if (*(_QWORD *)v382)
          {
            v383 = *(double **)v382;
            operator delete(*(void **)v382);
          }
          if (v389 && v386[0])
            free(v386[0]);
          if (v394 && v390[0])
            free(v390[0]);
          if (v398 && v395[0])
            free(v395[0]);
          v368 = 0.0;
          v246 = v363;
          v247 = v364;
          __x[0] = -1;
          std::vector<int>::vector(&v401, v363, __x);
          std::vector<double>::vector(&__src, v246);
          vision::mod::CVMLMatrix<double,16ul>::initialize_((uint64_t)v395, v333, v247);
          vision::mod::CVMLMatrix<double,16ul>::initialize_((uint64_t)v390, v333, v247);
          v388 = 0;
          *(_OWORD *)v386 = 0u;
          v387 = 0u;
          v389 = 1;
          vision::mod::CVMLMatrix<double,16ul>::reset((uint64_t)v386, v333, v246);
          v382[0] = 0;
          std::vector<int>::vector(&v385, v333, v382);
          v368 = 1.79769313e308;
          vision::mod::CVMLVector<double,16ul>::initialize_((uint64_t)v382, v333);
          if (v341 >= 1)
          {
            v248 = 0;
            v249 = v396;
            while (2)
            {
              if (v249 < v371 || *((_QWORD *)&v396 + 1) < v372)
              {
                v309 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
                std::logic_error::logic_error(v309, "output matrix size too small");
                v309->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
                __cxa_throw(v309, (struct type_info *)off_1E452A5D0, MEMORY[0x1E0DE42E0]);
              }
              if (v371)
              {
                for (mm = 0; mm < v371; ++mm)
                {
                  v251 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v395, mm);
                  v252 = (const void *)vision::mod::CVMLMatrix<double,16ul>::ptr(&v369, mm);
                  memcpy(v251, v252, 8 * v372);
                }
              }
              v344 = v248;
              v381 = 0.0;
              vision::mod::Kmeans<double,16ul>::labelEstimation_(v362, v160, (uint64_t)&v369, v375, v386, v401.__begin_, (double *)__src, &v381);
              v253 = v401.__begin_;
              v343 = __src;
              v254 = v385.__begin_;
              v256 = v363;
              v255 = v364;
              bzero(v385.__begin_, 4 * v333);
              v257 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(&v369, 0);
              bzero(v257, 8 * v333 * v373);
              if (v256)
              {
                for (nn = 0; nn != v256; ++nn)
                  ++v254[v253[nn]];
                for (i1 = 0; i1 != v256; ++i1)
                {
                  v260 = v253[i1];
                  v261 = v254[v260];
                  v262 = (const double *)vision::mod::CVMLMatrix<double,16ul>::ptr(v362, i1);
                  v263 = (double *)vision::mod::CVMLMatrix<double,16ul>::ptr(&v369, v260);
                  cblas_daxpy(v255, 1.0 / (double)v261, v262, 1, v263, 1);
                }
              }
              if ((int)v160 < 1)
                goto LABEL_437;
              v264 = 0;
              v265 = 0;
              v266 = 0;
              for (i2 = 0; i2 != v160; ++i2)
              {
                if (!v254[i2])
                {
                  if ((unint64_t)v265 >= v264)
                  {
                    v268 = (v265 - v266) >> 2;
                    v269 = v268 + 1;
                    if ((unint64_t)(v268 + 1) >> 62)
                      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
                    if ((uint64_t)(v264 - (_QWORD)v266) >> 1 > v269)
                      v269 = (uint64_t)(v264 - (_QWORD)v266) >> 1;
                    if (v264 - (unint64_t)v266 >= 0x7FFFFFFFFFFFFFFCLL)
                      v270 = 0x3FFFFFFFFFFFFFFFLL;
                    else
                      v270 = v269;
                    if (v270)
                      v270 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v270);
                    else
                      v271 = 0;
                    v272 = (char *)(v270 + 4 * v268);
                    *(_DWORD *)v272 = i2;
                    v273 = v272 + 4;
                    while (v265 != v266)
                    {
                      v274 = *((_DWORD *)v265 - 1);
                      v265 -= 4;
                      *((_DWORD *)v272 - 1) = v274;
                      v272 -= 4;
                    }
                    v264 = v270 + 4 * v271;
                    if (v266)
                      operator delete(v266);
                    v265 = v273;
                    v266 = v272;
                    v160 = v345;
                  }
                  else
                  {
                    *(_DWORD *)v265 = i2;
                    v265 += 4;
                  }
                }
              }
              if (v265 == v266)
                goto LABEL_435;
              std::vector<unsigned long>::vector(&__dst, v256);
              v275 = (uint64_t *)__dst;
              *(_QWORD *)__x = v343;
              v276 = (uint64_t *)((char *)__dst + 8 * v256);
              if (v256)
              {
                v277 = 0;
                v278 = 8 * v256;
                do
                {
                  v275[v277] = v277;
                  ++v277;
                  v278 -= 8;
                }
                while (v278);
                v405 = __x;
                if (v256 > 128)
                {
                  v279 = (uint64_t *)std::get_temporary_buffer[abi:ne180100]<unsigned long>(v256);
                  std::__stable_sort<std::_ClassicAlgPolicy,void vision::mod::argsort<double const*>(double const*,double const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(v275, v276, (uint64_t **)&v405, v256, v279, v280);
                  if (v279)
                    operator delete(v279);
LABEL_426:
                  if (v265 != v266)
                  {
                    v281 = 0;
                    v282 = 8 * v255;
                    if ((unint64_t)((v265 - v266) >> 2) <= 1)
                      v283 = 1;
                    else
                      v283 = (v265 - v266) >> 2;
                    do
                    {
                      v284 = *((_QWORD *)__dst + v281);
                      v285 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(&v369, *(int *)&v266[4 * v281]);
                      v286 = (const void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v362, v284);
                      memcpy(v285, v286, v282);
                      ++v281;
                    }
                    while (v283 != v281);
                    v265 = v266;
                  }
                  if (__dst)
                  {
                    v403 = __dst;
                    operator delete(__dst);
                    v265 = v266;
                  }
                  v266 = v265;
LABEL_435:
                  if (v266)
                    operator delete(v266);
LABEL_437:
                  v287 = v381;
                  if (v381 < v368)
                  {
                    if (v391 < v371 || v392 < v372)
                    {
                      v310 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
                      std::logic_error::logic_error(v310, "output matrix size too small");
                      v310->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
                      __cxa_throw(v310, (struct type_info *)off_1E452A5D0, MEMORY[0x1E0DE42E0]);
                    }
                    if (v371)
                    {
                      for (i3 = 0; i3 < v371; ++i3)
                      {
                        v289 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v390, i3);
                        v290 = (const void *)vision::mod::CVMLMatrix<double,16ul>::ptr(&v369, i3);
                        memcpy(v289, v290, 8 * v372);
                      }
                    }
                    v368 = v287;
                  }
                  v249 = v396;
                  v291 = v397;
                  v292 = (const double *)vision::mod::CVMLMatrix<double,16ul>::ptr(&v369, 0);
                  v293 = (double *)vision::mod::CVMLMatrix<double,16ul>::ptr(v395, 0);
                  cblas_daxpy(v291 * v249, -1.0, v292, 1, v293, 1);
                  vision::mod::CVMLMatrix<double,16ul>::rowNorms((uint64_t)v395, v382, 0);
                  if ((_DWORD)v160)
                  {
                    v294 = v383;
                    v295 = 0.0;
                    v296 = 8 * v333;
                    do
                    {
                      v297 = *v294++;
                      v295 = v295 + v297;
                      v296 -= 8;
                    }
                    while (v296);
                  }
                  else
                  {
                    v295 = 0.0;
                  }
                  v298 = sqrt(v295);
                  v248 = v344 + 1;
                  if (v298 <= v190 || v248 == v341)
                  {
                    if (v298 > 0.0)
                      vision::mod::Kmeans<double,16ul>::labelEstimation_(v362, v160, (uint64_t)v390, v375, v386, v401.__begin_, (double *)__src, &v368);
                    goto LABEL_456;
                  }
                  continue;
                }
              }
              else
              {
                v405 = __x;
              }
              break;
            }
            std::__stable_sort<std::_ClassicAlgPolicy,void vision::mod::argsort<double const*>(double const*,double const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(v275, v276, (uint64_t **)&v405, v256, 0, 0);
            goto LABEL_426;
          }
LABEL_456:
          if (v384 && *(_QWORD *)v382)
            free(*(void **)v382);
          if (v385.__begin_)
          {
            v385.__end_ = v385.__begin_;
            operator delete(v385.__begin_);
          }
          if (v389 && v386[0])
            free(v386[0]);
          if (v394 && v390[0])
            free(v390[0]);
          if (v398 && v395[0])
            free(v395[0]);
          if (__src)
          {
            v400 = (double *)__src;
            operator delete(__src);
          }
          if (v401.__begin_)
          {
            v401.__end_ = v401.__begin_;
            operator delete(v401.__begin_);
          }
          v300 = v368;
          if (v368 < v195)
          {
            if (v358 < v371 || v359 < v372)
            {
              v313 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
              std::logic_error::logic_error(v313, "output matrix size too small");
              v313->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
              __cxa_throw(v313, (struct type_info *)off_1E452A5D0, MEMORY[0x1E0DE42E0]);
            }
            if (v371)
            {
              for (i4 = 0; i4 < v371; ++i4)
              {
                v302 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v357, i4);
                v303 = (const void *)vision::mod::CVMLMatrix<double,16ul>::ptr(&v369, i4);
                memcpy(v302, v303, 8 * v372);
              }
            }
            v195 = v300;
          }
          if (++v337 == v331)
            goto LABEL_482;
        }
        v312 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(v312, "row index out of range");
        goto LABEL_511;
      }
LABEL_482:
      vision::mod::broadcastAdd<double,16ul>(v362, v378, 0, v362);
      vision::mod::broadcastAdd<double,16ul>(v357, v378, 0, v357);
      if (v374 && v369)
        free(v369);
      if (v377 && v375[0])
        free(v375[0]);
      if (v380 && v378[0])
        free(v378[0]);
      v15 = v367;
      if (std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::find<int>(v332, v367))
      {
        syslog(5, "ERROR: duplicated labels detected when build sub-dictionary");
        v184 = 1;
        v183 = 7808;
        v15 = 7784;
      }
      else
      {
        v304 = std::__hash_table<std::__hash_value_type<int,std::pair<int,int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::pair<int,int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::pair<int,int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::pair<int,int>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(v332, v15, (int *)&v367);
        v184 = 0;
        *((_DWORD *)v304 + 5) = v340;
        *((_DWORD *)v304 + 6) = v160;
        v183 = 7808;
      }
    }
    if (v361 && v357[0])
      free(v357[0]);
LABEL_497:
    if (v366 && v362[0])
      free(v362[0]);
    if (!v184)
    {
LABEL_501:
      v305 = v338[3];
      if (v338[4] != v305)
      {
        v306 = 0;
        v307 = v367;
        do
        {
          v308 = (unint64_t *)(a2[1] + 8 * *(int *)(v305 + 4 * v306));
          *((_DWORD *)std::__hash_table<std::__hash_value_type<long long,int>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,int>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,int>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,int>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>((float *)v346, *v308, v308)+ 6) = v307;
          ++v306;
          v305 = v338[3];
        }
        while (v306 < (v338[4] - v305) >> 2);
      }
      v15 = v183;
    }
LABEL_260:
    if (v15 == 128)
    {
      v146 = v338[3];
      v145 = v338[4];
      v147 = *((_DWORD *)v346 + 10);
      ++v336;
      v148 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v334 + 8))(v334);
      v149 = (unint64_t)(v145 - v146) >> 2;
      if (v147 < (int)v149)
        LODWORD(v149) = v147;
      v340 += v149;
      if (!v148)
      {
        v122 = v346;
        v121 = v335;
LABEL_265:
        v121 = (uint64_t *)*v121;
        if (!v121)
          goto LABEL_516;
        continue;
      }
      v122 = v346;
      if (v336 != DWORD2(v353))
      {
        vision::mod::FaceIDModel::shrinkD_(v346, v340);
        v15 = 7779;
      }
LABEL_516:
      if (*((_QWORD *)v122 + 13) == v340)
      {
        vision::mod::FaceIDModel::createPrintsDictionary_((uint64_t)v122, (vision::mod::ImageDescriptorBufferAbstract *)a2, (uint64_t)v355);
        vision::mod::FeatureSignSparseCoder<double,16ul>::initialize((uint64_t)v122 + 264, (_QWORD *)v122 + 11);
        goto LABEL_520;
      }
      syslog(5, "ERROR: size mismatch in the end: bad memory access");
LABEL_129:
      v15 = 7784;
      goto LABEL_520;
    }
    break;
  }
  syslog(5, "ERROR: error happened in building subdictionary");
LABEL_520:
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table((uint64_t)&v352);
  std::__hash_table<std::__hash_value_type<int,std::vector<int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<int>>>>::~__hash_table((uint64_t)v355);
  return v15;
}

void sub_1A14A23B4()
{
  void *v0;
  char v1;
  void *v2;
  char v3;

  __cxa_end_catch();
  if (v1 && v0)
    free(v0);
  if (v3)
  {
    if (v2)
      free(v2);
  }
  JUMPOUT(0x1A14A24E8);
}

void sub_1A14A23C8()
{
  JUMPOUT(0x1A14A2408);
}

void sub_1A14A2464()
{
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table((uint64_t)&STACK[0x2C0]);
  if (LOBYTE(STACK[0x378]))
  {
    if (STACK[0x350])
      free((void *)STACK[0x350]);
  }
  JUMPOUT(0x1A14A24DCLL);
}

void sub_1A14A2490(void *a1, int a2)
{
  void *v2;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;

  operator delete(v2);
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table((uint64_t)&STACK[0x350]);
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table((uint64_t)&v6);
  std::__hash_table<std::__hash_value_type<int,std::vector<int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<int>>>>::~__hash_table((uint64_t)&v7);
  switch(a2)
  {
    case 3:
      __cxa_begin_catch(a1);
      syslog(5, "ERROR: memory allocation error");
      __cxa_end_catch();
      break;
    case 2:
      __cxa_begin_catch(a1);
      syslog(5, "ERROR: an unexpected exception thrown");
      __cxa_end_catch();
      break;
    case 1:
      v5 = __cxa_begin_catch(a1);
      syslog(5, "ERROR: Caught unexpected failure with status code %lld", *v5);
      __cxa_end_catch();
      break;
    default:
      JUMPOUT(0x1A14A25B8);
  }
  JUMPOUT(0x1A149FF44);
}

void sub_1A14A24AC(void *a1, int a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;

  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table(&v5);
  std::__hash_table<std::__hash_value_type<int,std::vector<int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<int>>>>::~__hash_table(&v6);
  switch(a2)
  {
    case 3:
      __cxa_begin_catch(a1);
      syslog(5, "ERROR: memory allocation error");
      __cxa_end_catch();
      break;
    case 2:
      __cxa_begin_catch(a1);
      syslog(5, "ERROR: an unexpected exception thrown");
      __cxa_end_catch();
      break;
    case 1:
      v4 = __cxa_begin_catch(a1);
      syslog(5, "ERROR: Caught unexpected failure with status code %lld", *v4);
      __cxa_end_catch();
      break;
    default:
      JUMPOUT(0x1A14A25B8);
  }
  JUMPOUT(0x1A149FF44);
}

void sub_1A14A24C0()
{
  JUMPOUT(0x1A14A24C8);
}

void sub_1A14A24D4(void *a1, int a2)
{
  void *v2;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;

  if (v2)
    operator delete(v2);
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table((uint64_t)&v6);
  std::__hash_table<std::__hash_value_type<int,std::vector<int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<int>>>>::~__hash_table((uint64_t)&v7);
  switch(a2)
  {
    case 3:
      __cxa_begin_catch(a1);
      syslog(5, "ERROR: memory allocation error");
      __cxa_end_catch();
      break;
    case 2:
      __cxa_begin_catch(a1);
      syslog(5, "ERROR: an unexpected exception thrown");
      __cxa_end_catch();
      break;
    case 1:
      v5 = __cxa_begin_catch(a1);
      syslog(5, "ERROR: Caught unexpected failure with status code %lld", *v5);
      __cxa_end_catch();
      break;
    default:
      JUMPOUT(0x1A14A25B8);
  }
  JUMPOUT(0x1A149FF44);
}

void sub_1A14A2580(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A14A258C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A14A2598(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A14A25A4(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

void vision::mod::FeatureSignSparseCoder<double,16ul>::initialize(uint64_t a1, _QWORD *a2)
{
  unint64_t v4;
  unint64_t v5;
  std::vector<int>::size_type v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char *v13;
  char *v14;
  uint64_t v15;
  char *v16;
  void *v17;
  char *v18;
  uint64_t v19;
  char *v20;
  void *v21;
  char *v22;
  uint64_t v23;
  char *v24;
  void *v25;
  char *v26;
  uint64_t v27;
  char *v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;
  std::bad_alloc *exception;
  std::bad_alloc *v39;
  unint64_t v40;
  char *v41;
  std::string *v42;
  __int128 v43;
  std::string *v44;
  __int128 v45;
  std::string *v46;
  std::string::size_type size;
  std::string *v48;
  std::string::size_type v49;
  const std::string::value_type *v50;
  int v51;
  std::bad_alloc *v52;
  std::string *v53;
  uint64_t v54;
  uint64_t v55;
  size_t __val;
  void **v57;
  std::string v58;
  std::string v59;
  std::string v60;
  std::string v61;
  _DWORD v62[4];

  free(*(void **)(a1 + 80));
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)a1 = a2;
  v4 = a2[2];
  v5 = a2[3];
  if (v5 >= v4)
    v6 = a2[2];
  else
    v6 = a2[3];
  v7 = (((uint64_t)(v4 << 63) >> 63) & ((16 - ((8 * v4) & 8)) >> 3)) + v4;
  v8 = v7 * 8 * v4 + 15;
  v9 = 8 * v4 + 15;
  v10 = 8 * v5 + 15;
  v55 = 8 * v6 + 15;
  v54 = 8 * (v6 + 1) + 15;
  __val = 16 * (v55 + v10) + 8 * (v54 + v9 + v8) + 112;
  v11 = (char *)malloc_type_calloc(__val, 1uLL, 0xBE09D42DuLL);
  *(_QWORD *)(a1 + 80) = v11;
  if (!v11)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    v39 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v39, MEMORY[0x1E0DE4EA8], MEMORY[0x1E0DE4DC0]);
  }
  v12 = 16 - (v11 & 0xF);
  if ((v11 & 0xF) == 0)
    v12 = 0;
  v13 = &v11[v12];
  v57 = (void **)(a1 + 8);
  if (*(_BYTE *)(a1 + 48) && *v57)
    free(*v57);
  v14 = &v13[8 * v8];
  v15 = 16 - (v14 & 0xF);
  *(_QWORD *)(a1 + 8) = v13;
  *(_QWORD *)(a1 + 16) = v13;
  *(_QWORD *)(a1 + 24) = v4;
  *(_QWORD *)(a1 + 32) = v4;
  *(_QWORD *)(a1 + 40) = v7;
  *(_BYTE *)(a1 + 48) = 0;
  if ((v14 & 0xF) == 0)
    v15 = 0;
  v16 = &v14[v15];
  if (*(_BYTE *)(a1 + 120))
  {
    v17 = *(void **)(a1 + 88);
    if (v17)
      free(v17);
  }
  v18 = &v16[8 * v9];
  v19 = 16 - (v18 & 0xF);
  *(_QWORD *)(a1 + 88) = v16;
  *(_QWORD *)(a1 + 96) = v16;
  *(_QWORD *)(a1 + 104) = v4;
  *(_QWORD *)(a1 + 112) = 1;
  *(_BYTE *)(a1 + 120) = 0;
  if ((v18 & 0xF) == 0)
    v19 = 0;
  v20 = &v18[v19];
  if (*(_BYTE *)(a1 + 160))
  {
    v21 = *(void **)(a1 + 128);
    if (v21)
      free(v21);
  }
  v22 = &v20[8 * v55];
  v23 = 16 - (v22 & 0xF);
  *(_QWORD *)(a1 + 128) = v20;
  *(_QWORD *)(a1 + 136) = v20;
  *(_QWORD *)(a1 + 144) = v6;
  *(_QWORD *)(a1 + 152) = 1;
  *(_BYTE *)(a1 + 160) = 0;
  if ((v22 & 0xF) == 0)
    v23 = 0;
  v24 = &v22[v23];
  if (*(_BYTE *)(a1 + 200))
  {
    v25 = *(void **)(a1 + 168);
    if (v25)
      free(v25);
  }
  v26 = &v24[8 * v10];
  v27 = 16 - (v26 & 0xF);
  *(_QWORD *)(a1 + 168) = v24;
  *(_QWORD *)(a1 + 176) = v24;
  *(_QWORD *)(a1 + 184) = v5;
  *(_QWORD *)(a1 + 192) = 1;
  *(_BYTE *)(a1 + 200) = 0;
  if ((v26 & 0xF) == 0)
    v27 = 0;
  v28 = (uint64_t)&v26[v27];
  if (*(_BYTE *)(a1 + 240))
  {
    v29 = *(void **)(a1 + 208);
    if (v29)
      free(v29);
  }
  v30 = v28 + 8 * v10;
  v31 = 16 - (v30 & 0xF);
  *(_QWORD *)(a1 + 208) = v28;
  *(_QWORD *)(a1 + 216) = v28;
  *(_QWORD *)(a1 + 224) = v5;
  *(_QWORD *)(a1 + 232) = 1;
  *(_BYTE *)(a1 + 240) = 0;
  if ((v30 & 0xF) == 0)
    v31 = 0;
  v32 = v30 + v31;
  if (*(_BYTE *)(a1 + 280))
  {
    v33 = *(void **)(a1 + 248);
    if (v33)
      free(v33);
  }
  v34 = v32 + 8 * v54;
  v35 = 16 - (v34 & 0xF);
  *(_QWORD *)(a1 + 248) = v32;
  *(_QWORD *)(a1 + 256) = v32;
  *(_QWORD *)(a1 + 272) = 1;
  *(_QWORD *)(a1 + 264) = v6 + 1;
  *(_BYTE *)(a1 + 280) = 0;
  if ((v34 & 0xF) == 0)
    v35 = 0;
  v36 = v34 + v35;
  if (*(_BYTE *)(a1 + 320))
  {
    v37 = *(void **)(a1 + 288);
    if (v37)
      free(v37);
  }
  *(_QWORD *)(a1 + 288) = v36;
  *(_QWORD *)(a1 + 296) = v36;
  *(_QWORD *)(a1 + 304) = v6;
  *(_QWORD *)(a1 + 312) = 1;
  *(_BYTE *)(a1 + 320) = 0;
  if (v36 + 8 * v55 - *(_QWORD *)(a1 + 80) > __val)
  {
    v40 = v36 + 8 * v55 - *(_QWORD *)(a1 + 80);
    v41 = (char *)__cxa_allocate_exception(0x20uLL);
    std::to_string(&v59, v40);
    v42 = std::string::insert(&v59, 0, "aligned buffer allocation of ", 0x1DuLL);
    v43 = *(_OWORD *)&v42->__r_.__value_.__l.__data_;
    v60.__r_.__value_.__r.__words[2] = v42->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v60.__r_.__value_.__l.__data_ = v43;
    v42->__r_.__value_.__l.__size_ = 0;
    v42->__r_.__value_.__r.__words[2] = 0;
    v42->__r_.__value_.__r.__words[0] = 0;
    v44 = std::string::append(&v60, " exceeded calculated size of ", 0x1DuLL);
    v45 = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
    v61.__r_.__value_.__r.__words[2] = v44->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v61.__r_.__value_.__l.__data_ = v45;
    v44->__r_.__value_.__l.__size_ = 0;
    v44->__r_.__value_.__r.__words[2] = 0;
    v44->__r_.__value_.__r.__words[0] = 0;
    std::to_string(&v58, __val);
    if ((v58.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v46 = &v58;
    else
      v46 = (std::string *)v58.__r_.__value_.__r.__words[0];
    if ((v58.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(v58.__r_.__value_.__r.__words[2]);
    else
      size = v58.__r_.__value_.__l.__size_;
    v48 = std::string::append(&v61, (const std::string::value_type *)v46, size);
    v50 = (const std::string::value_type *)v48->__r_.__value_.__r.__words[0];
    v49 = v48->__r_.__value_.__l.__size_;
    v62[0] = v48->__r_.__value_.__r.__words[2];
    *(_DWORD *)((char *)v62 + 3) = *(_DWORD *)((char *)&v48->__r_.__value_.__r.__words[2] + 3);
    v51 = SHIBYTE(v48->__r_.__value_.__r.__words[2]);
    v48->__r_.__value_.__l.__size_ = 0;
    v48->__r_.__value_.__r.__words[2] = 0;
    v48->__r_.__value_.__r.__words[0] = 0;
    v52 = std::bad_alloc::bad_alloc((std::bad_alloc *)v41);
    v52->__vftable = (std::bad_alloc_vtbl *)off_1E453AC40;
    v53 = (std::string *)&v52[1];
    if (v51 < 0)
    {
      std::string::__init_copy_ctor_external(v53, v50, v49);
    }
    else
    {
      *((_QWORD *)v41 + 1) = v50;
      *((_QWORD *)v41 + 2) = v49;
      *((_DWORD *)v41 + 6) = v62[0];
      *(_DWORD *)(v41 + 27) = *(_DWORD *)((char *)v62 + 3);
      v41[31] = v51;
    }
  }
  std::vector<unsigned int>::resize((std::vector<int> *)(a1 + 328), v6);
  vision::mod::matMult<double,16ul>((uint64_t)a2, a2, 1, v57, 0, 1.0, 0.0);
}

void sub_1A14A2A00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  std::bad_alloc *v39;
  void *v40;

  std::bad_alloc::~bad_alloc(v39);
  operator delete(v40);
  if (a20 < 0)
    operator delete(__p);
  if (a39 < 0)
    operator delete(a34);
  if (a32 < 0)
    operator delete(a27);
  if (a26 < 0)
    operator delete(a21);
  __cxa_free_exception(v39);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<int,std::vector<int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<int>>>>::~__hash_table(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;
  void *v5;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      v4 = (void *)v2[3];
      if (v4)
      {
        v2[4] = v4;
        operator delete(v4);
      }
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v5 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v5)
    operator delete(v5);
  return a1;
}

void vision::mod::FeatureSignSparseCoder_bad_alloc::~FeatureSignSparseCoder_bad_alloc(std::bad_alloc *this)
{
  this->__vftable = (std::bad_alloc_vtbl *)off_1E453AC40;
  if (SHIBYTE(this[3].__vftable) < 0)
    operator delete(this[1].__vftable);
  std::bad_alloc::~bad_alloc(this);
}

{
  this->__vftable = (std::bad_alloc_vtbl *)off_1E453AC40;
  if (SHIBYTE(this[3].__vftable) < 0)
    operator delete(this[1].__vftable);
  std::bad_alloc::~bad_alloc(this);
  JUMPOUT(0x1A1B0A898);
}

uint64_t vision::mod::FeatureSignSparseCoder_bad_alloc::what(vision::mod::FeatureSignSparseCoder_bad_alloc *this)
{
  uint64_t result;

  result = (uint64_t)this + 8;
  if (*((char *)this + 31) < 0)
    return *(_QWORD *)result;
  return result;
}

uint64_t vision::mod::FaceIDModel::predict(uint64_t a1, _QWORD *a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  double *v12;
  float *v13;
  uint64_t v14;
  float v15;
  float v16;
  uint64_t v17;
  unint64_t v18;
  void *v19;
  _QWORD *v20;
  std::vector<int>::size_type v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  int64_t v25;
  size_t v26;
  unint64_t v27;
  size_t v28;
  void *v29;
  char *v30;
  char *v31;
  char *v32;
  char *v33;
  char v34;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  const void *v39;
  void *v40;
  int v41;
  uint64_t v42;
  double v43;
  int v44;
  double v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  std::vector<int>::pointer begin;
  double *v51;
  uint64_t v52;
  double *v53;
  uint64_t v54;
  uint64_t v55;
  double v56;
  double v57;
  std::vector<int>::pointer v58;
  uint64_t *v59;
  uint64_t v60;
  uint64_t v61;
  __CLPK_doublereal *v62;
  int v63;
  std::vector<int>::pointer v64;
  _QWORD *v65;
  uint64_t v66;
  uint64_t v67;
  __CLPK_integer v68;
  __CLPK_doublereal *v69;
  double v70;
  uint64_t v71;
  void *v72;
  const void *v73;
  int v74;
  std::vector<int>::pointer v75;
  double *v76;
  uint64_t v77;
  uint64_t v78;
  double *v79;
  uint64_t v80;
  uint64_t v81;
  double v82;
  __CLPK_doublereal *v83;
  uint64_t v84;
  std::vector<int>::pointer v85;
  double *v86;
  uint64_t v87;
  double *v88;
  uint64_t v89;
  uint64_t v90;
  __CLPK_integer v91;
  __CLPK_doublereal *v92;
  uint64_t *v93;
  double *v94;
  uint64_t v95;
  uint64_t v96;
  std::vector<int>::pointer v97;
  double *v98;
  uint64_t v99;
  double *v100;
  uint64_t v101;
  uint64_t v102;
  int v103;
  double *v104;
  uint64_t v105;
  double *v106;
  double v107;
  double v108;
  double v109;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  double *v114;
  uint64_t v115;
  double *v116;
  double *v117;
  double *v118;
  uint64_t v119;
  double v120;
  uint64_t v121;
  double v122;
  const double *v123;
  double v124;
  double v125;
  uint64_t v126;
  double v127;
  double v128;
  _BOOL4 v130;
  double v131;
  double v132;
  double v133;
  double v134;
  int v135;
  std::vector<int>::pointer v136;
  double *v137;
  uint64_t v138;
  double v139;
  uint64_t v140;
  int *v141;
  uint64_t v142;
  int *v143;
  std::vector<int>::pointer v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  const char *v148;
  uint64_t v149;
  uint64_t v150;
  int v151;
  int v152;
  uint64_t v153;
  char *v154;
  size_t v155;
  uint64_t v156;
  uint64_t v157;
  char *v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  int v162;
  uint64_t v163;
  double v164;
  double v165;
  uint64_t v166;
  uint64_t v167;
  int *v168;
  uint64_t v169;
  uint64_t v170;
  int v171;
  int64_t v172;
  int v173;
  uint64_t v174;
  void *v175;
  const void *v176;
  __int128 v177;
  int *value;
  BOOL v179;
  int v180;
  std::vector<int>::pointer v181;
  uint64_t v182;
  __CLPK_doublereal *v183;
  uint64_t v184;
  uint64_t v185;
  BOOL v186;
  uint64_t v187;
  uint64_t v188;
  unint64_t v189;
  unint64_t v190;
  uint64_t v191;
  unint64_t v192;
  unint64_t v193;
  unint64_t v194;
  char *v195;
  uint64_t v196;
  uint64_t v197;
  _QWORD *v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  _QWORD *v203;
  uint64_t *v204;
  __int128 v205;
  unint64_t v206;
  size_t v207;
  uint64_t v208;
  unint64_t v209;
  unint64_t v210;
  unint64_t v211;
  uint64_t v213;
  uint64_t *v214;
  unint64_t i;
  void *v216;
  const void *v217;
  uint64_t v218;
  double *v219;
  uint64_t v220;
  unint64_t v221;
  std::logic_error *v222;
  std::logic_error *v223;
  std::logic_error *v224;
  std::logic_error *v225;
  std::logic_error *exception;
  std::logic_error *v227;
  unint64_t v228;
  uint64_t v229;
  int v230;
  uint64_t __n;
  int v232;
  int v233[2];
  unint64_t v234;
  void *__src;
  uint64_t v236;
  const void *v237;
  int v238;
  int v239;
  int __incX[2];
  int __incXa[2];
  uint64_t v243;
  uint64_t v244;
  int v245[2];
  int v246[2];
  char *v247;
  void *v249[2];
  __int128 v250;
  uint64_t v251;
  char v252;
  void *v253[2];
  unint64_t v254;
  uint64_t v255;
  char v256;
  void *v257;
  double *v258;
  uint64_t v259;
  uint64_t v260;
  char v261;
  void *v262[2];
  __int128 v263;
  uint64_t *v264;
  char v265;
  std::vector<int> v266;
  int __N;
  void *__p;
  char *v269;
  char *v270;
  _QWORD *v271;
  _QWORD *v272;
  __int128 v273;
  _QWORD v274[3];
  char v275;
  std::vector<int> v276;
  void *v277[2];
  __int128 v278;
  uint64_t v279;
  char v280;
  char __diag;
  char __trans;
  __CLPK_integer __lda[2];
  double *v284;
  uint64_t v285;
  uint64_t v286;
  char v287;
  char __uplo;
  __CLPK_integer __nrhs[2];
  double *v290;
  uint64_t v291;
  uint64_t v292;
  char v293;
  __CLPK_integer __info[2];
  __CLPK_integer __ldb[2];
  __CLPK_integer v296[2];
  void *v297;
  uint64_t v298;
  __int128 v299;
  char v300;

  v3 = a2[8];
  v4 = a2[12];
  v5 = (int)v3 < 1 || (int)v4 < 1;
  if (v5 || (v6 = a2[9], (v6 & 0x80000000) != 0))
  {
    syslog(5, "ERROR: invalid image descriptor buffer");
    return 7804;
  }
  v7 = a2[7];
  if (*(_QWORD *)(a1 + 24))
  {
    if (*(float *)(a1 + 60) <= 0.0)
    {
      v8 = &CVML_status_invalidParameter;
      syslog(5, "ERROR: negative or zero sparsity");
    }
    else if (*(_QWORD *)(a1 + 104) && *(_QWORD *)(a1 + 112))
    {
      if (*(_QWORD *)(a1 + 208))
      {
        v8 = &CVML_status_ok;
      }
      else
      {
        v8 = &CVML_status_inconsistentState;
        syslog(5, "ERROR: empty dictionary labels");
      }
    }
    else
    {
      v8 = &CVML_status_inconsistentState;
      syslog(5, "ERROR: empty dictionary D_");
    }
  }
  else
  {
    v8 = &CVML_status_inconsistentState;
    syslog(5, "ERROR: empty usedIds_");
  }
  if ((*(_BYTE *)v8 + 0x80) != 128)
    return (*v8 + 128) | 0x1E00;
  if (!(_DWORD)v6)
    return 7808;
  v10 = v4;
  v234 = v6;
  vision::mod::CVMLMatrix<double,16ul>::initialize_((uint64_t)v253, v6, v4);
  v11 = 0;
  do
  {
    v12 = (double *)vision::mod::CVMLMatrix<double,16ul>::ptr(v253, v11);
    if (v10)
    {
      v13 = (float *)(v7 + v11 * (int)v3);
      v14 = 4 * v10;
      do
      {
        v15 = *v13++;
        *v12++ = v15;
        v14 -= 4;
      }
      while (v14);
    }
    ++v11;
  }
  while (v11 != v6);
  v251 = 0;
  *(_OWORD *)v249 = 0u;
  v250 = 0u;
  v252 = 1;
  v16 = *(float *)(a1 + 60);
  if (v16 <= 0.0)
  {
    syslog(5, "lambda must be > 0");
    v9 = 7804;
LABEL_45:
    syslog(5, "ERROR: error happened in sparse coding");
    goto LABEL_46;
  }
  if (!*(_QWORD *)(a1 + 344) || (v17 = *(_QWORD *)(a1 + 264)) == 0)
  {
    syslog(5, "encoder is not initialized");
    v9 = 7796;
    goto LABEL_45;
  }
  *(double *)(a1 + 320) = v16;
  *(_BYTE *)(a1 + 328) = 0;
  v18 = v254;
  vision::mod::CVMLMatrix<double,16ul>::reset((uint64_t)v249, v254, *(_QWORD *)(v17 + 16));
  v19 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v249, 0);
  v236 = v10;
  bzero(v19, 8 * v251 * v250);
  v279 = 0;
  *(_OWORD *)v277 = 0u;
  v278 = 0u;
  v280 = 1;
  vision::mod::matMult<double,16ul>((uint64_t)v253, *(_QWORD **)(a1 + 264), 1, v277, 1, 1.0, 0.0);
  *(_QWORD *)(a1 + 336) = v277;
  v264 = 0;
  v263 = 0u;
  v265 = 1;
  memset(&v266, 0, sizeof(v266));
  __p = 0;
  v269 = 0;
  memset(v274, 0, sizeof(v274));
  v273 = 0u;
  v275 = 1;
  memset(&v276, 0, sizeof(v276));
  v270 = 0;
  v271 = 0;
  __N = 0;
  v20 = *(_QWORD **)(a1 + 264);
  if (v20[3] >= v20[2])
    v21 = v20[2];
  else
    v21 = v20[3];
  *(_OWORD *)v262 = 0uLL;
  vision::mod::CVMLMatrix<double,16ul>::reset((uint64_t)v262, v21, v21);
  vision::mod::CVMLMatrix<double,16ul>::reset((uint64_t)&v273, v20[2], v20[3]);
  std::vector<unsigned int>::resize(&v266, v21);
  std::vector<unsigned int>::resize(&v276, v21);
  v22 = v20[2];
  v24 = (uint64_t)__p;
  v23 = v269;
  v25 = v269 - (_BYTE *)__p;
  v26 = v22 - (v269 - (_BYTE *)__p);
  if (v22 <= v269 - (_BYTE *)__p)
  {
    if (v22 < v269 - (_BYTE *)__p)
    {
      v23 = (char *)__p + v22;
      v269 = (char *)__p + v22;
    }
  }
  else
  {
    if (v270 - v269 >= v26)
    {
      v32 = (char *)__p + v22;
      bzero(v269, v26);
      v269 = &v23[v26];
    }
    else
    {
      if ((v22 & 0x8000000000000000) != 0)
        std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
      v27 = 2 * (v270 - (_BYTE *)__p);
      if (v27 <= v22)
        v27 = v20[2];
      if ((unint64_t)(v270 - (_BYTE *)__p) >= 0x3FFFFFFFFFFFFFFFLL)
        v28 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v28 = v27;
      v29 = operator new(v28);
      v30 = (char *)v29 + v25;
      v31 = (char *)v29 + v28;
      v32 = (char *)v29 + v22;
      bzero(v30, v26);
      if (v23 == (char *)v24)
      {
        v29 = v30;
      }
      else
      {
        v33 = &v23[~v24];
        do
        {
          v34 = *--v23;
          (v33--)[(_QWORD)v29] = v34;
        }
        while (v23 != (char *)v24);
        v23 = (char *)__p;
      }
      __p = v29;
      v269 = v32;
      v270 = v31;
      if (v23)
      {
        operator delete(v23);
        v32 = v269;
      }
    }
    v24 = (uint64_t)__p;
    v18 = v254;
    v23 = v32;
  }
  bzero((void *)v24, (size_t)&v23[-v24]);
  v271 = (_QWORD *)(a1 + 272);
  v272 = v20;
  __N = 0;
  if (!v18)
  {
    v186 = 0;
    v37 = v236;
    goto LABEL_237;
  }
  v36 = 0;
  v37 = v236;
  while (2)
  {
    v228 = v36;
    __N = 0;
    bzero(__p, v269 - (_BYTE *)__p);
    if (v18 <= v228)
    {
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(exception, "row index out of range");
      exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
      __cxa_throw(exception, (struct type_info *)off_1E452A5D0, MEMORY[0x1E0DE42E0]);
    }
    __src = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v253, v228);
    if ((unint64_t)v278 <= v228)
    {
      v227 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(v227, "row index out of range");
      v227->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
      __cxa_throw(v227, (struct type_info *)off_1E452A5D0, MEMORY[0x1E0DE42E0]);
    }
    *(_QWORD *)v233 = v255;
    v38 = vision::mod::CVMLMatrix<double,16ul>::ptr(v277, v228);
    if ((unint64_t)v250 <= v228)
    {
      v225 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(v225, "row index out of range");
      v225->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
      __cxa_throw(v225, (struct type_info *)off_1E452A5D0, MEMORY[0x1E0DE42E0]);
    }
    v39 = (const void *)v38;
    v40 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v249, v228);
    v41 = 0;
    v257 = v40;
    v258 = (double *)v40;
    v259 = *((_QWORD *)&v250 + 1);
    v260 = 1;
    v261 = 0;
    v230 = DWORD2(v250);
    __n = 8 * SDWORD2(v250);
    v229 = DWORD2(v250);
    v237 = v39;
    while (2)
    {
      v232 = v41;
      memcpy(*(void **)(a1 + 360), v39, __n);
      vision::mod::matVecMult<double,16ul>(a1 + 272, 0, (uint64_t)&v257, a1 + 352, -1.0);
      if (v230 < 1)
      {
        v44 = -1;
        v43 = 0.0;
      }
      else
      {
        v42 = 0;
        v43 = 0.0;
        v44 = -1;
        do
        {
          if (!*((_BYTE *)__p + v42))
          {
            v45 = fabs(*(double *)(*(_QWORD *)(a1 + 360) + 8 * *(_QWORD *)(a1 + 376) * v42));
            if (v45 > v43)
            {
              v43 = v45;
              v44 = v42;
            }
          }
          ++v42;
        }
        while (v229 != v42);
      }
      if (v43 <= *(double *)(a1 + 320))
      {
LABEL_228:
        v24 = 7552;
        goto LABEL_229;
      }
      v46 = __N;
      v47 = __N;
      v48 = *(_QWORD *)(a1 + 400);
      v49 = *(_QWORD *)(a1 + 416);
      if (__N >= 1)
      {
        begin = v266.__begin_;
        v51 = *(double **)(a1 + 400);
        v52 = __N;
        v53 = v258;
        v54 = v260;
        do
        {
          v55 = *begin++;
          if (v53[v54 * v55] < 0.0)
            v56 = -1.0;
          else
            v56 = 1.0;
          *v51 = v56;
          v51 += v49;
          --v52;
        }
        while (v52);
      }
      if (*(double *)(*(_QWORD *)(a1 + 360) + 8 * *(_QWORD *)(a1 + 376) * v44) < 0.0)
        v57 = 1.0;
      else
        v57 = -1.0;
      *(double *)(v48 + 8 * v49 * v47) = v57;
      if (v44 < 0 && v44 >= *((_DWORD *)v271 + 4))
      {
        syslog(5, "ERROR: dictionary index out of range");
        v59 = &CVML_status_internalError;
      }
      else
      {
        v58 = v266.__begin_;
        if (v46 == ((unint64_t)((char *)v266.__end_ - (char *)v266.__begin_) >> 2))
        {
          syslog(5, "ERROR: sparsity constraint is too small, increase lambda");
          v59 = &CVML_status_smallSparsity;
        }
        else
        {
          if ((_DWORD)v47)
          {
            v60 = vision::mod::CVMLMatrix<double,16ul>::ptr(v271, v44);
            v61 = vision::mod::CVMLMatrix<double,16ul>::ptr(v262, __N);
            v62 = (__CLPK_doublereal *)v61;
            v63 = __N;
            if (__N >= 1)
            {
              v64 = v266.__begin_;
              v65 = (_QWORD *)v61;
              v66 = __N;
              do
              {
                v67 = *v64++;
                *v65++ = *(_QWORD *)(v60 + 8 * v67);
                --v66;
              }
              while (v66);
            }
            v68 = (int)v264;
            v69 = (__CLPK_doublereal *)vision::mod::CVMLMatrix<double,16ul>::ptr(v262, 0);
            __uplo = 85;
            __trans = 84;
            __diag = 78;
            v296[0] = v63;
            __nrhs[0] = 1;
            __lda[0] = v68;
            __ldb[0] = v63;
            __info[0] = 0;
            dtrtrs_(&__uplo, &__trans, &__diag, v296, __nrhs, v69, __lda, v62, __ldb, __info);
            if (__info[0] < 0)
            {
              v59 = &CVML_status_LAPACKError;
              goto LABEL_99;
            }
            v70 = cblas_ddot(__N, v62, 1, v62, 1);
            v71 = __N;
            v62[__N] = sqrt(fmax(*(double *)(v60 + 8 * v44) - v70, 0.0));
            v58 = v266.__begin_;
          }
          else
          {
            v71 = 0;
            *(double *)v262[1] = sqrt(*(double *)(v271[1] + 8 * (v44 + v44 * v271[4])));
          }
          v58[v71] = v44;
          *((_BYTE *)__p + v44) = 1;
          v72 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(&v273, __N);
          v73 = (const void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v272, v44);
          memcpy(v72, v73, 8 * v272[3]);
          ++__N;
          v59 = &CVML_status_ok;
        }
      }
LABEL_99:
      v24 = (*v59 + 128) | 0x1D00;
      if (v24 != 7552)
        goto LABEL_229;
      v74 = 0;
      v39 = v237;
      while (v74 <= 99)
      {
        *(_QWORD *)v245 = __N;
        if (v74 && __N >= 1)
        {
          v75 = v266.__begin_;
          v76 = v258;
          v77 = v260;
          v78 = __N;
          v79 = *(double **)(a1 + 400);
          v80 = 8 * *(_QWORD *)(a1 + 416);
          do
          {
            v81 = *v75++;
            if (v76[v77 * v81] < 0.0)
              v82 = -1.0;
            else
              v82 = 1.0;
            *v79 = v82;
            v79 = (double *)((char *)v79 + v80);
            --v78;
          }
          while (v78);
        }
        v83 = *(__CLPK_doublereal **)(a1 + 360);
        v243 = *(_QWORD *)(a1 + 376);
        v84 = 8 * v243;
        if (v245[0] >= 1)
        {
          v85 = v266.__begin_;
          v86 = *(double **)(a1 + 400);
          v87 = 8 * *(_QWORD *)(a1 + 416);
          v88 = *(double **)(a1 + 360);
          v89 = *(_QWORD *)v245;
          do
          {
            v90 = *v85++;
            *v88 = *((double *)v39 + v90) - *(double *)(a1 + 320) * *v86;
            v88 = (double *)((char *)v88 + v84);
            v86 = (double *)((char *)v86 + v87);
            --v89;
          }
          while (v89);
        }
        v91 = (int)v264;
        v92 = (__CLPK_doublereal *)vision::mod::CVMLMatrix<double,16ul>::ptr(v262, 0);
        __uplo = 85;
        v296[0] = v245[0];
        __nrhs[0] = 1;
        __lda[0] = v91;
        __ldb[0] = v245[0];
        __info[0] = 0;
        dpotrs_(&__uplo, v296, __nrhs, v92, __lda, v83, __ldb, __info);
        v93 = &CVML_status_ok;
        if (__info[0] < 0)
        {
          syslog(5, "ERROR: illegal value when solving linear equations");
          v93 = &CVML_status_LAPACKError;
        }
        v24 = (*v93 + 128) | 0x1D00;
        if (v24 != 7552)
          goto LABEL_229;
        v94 = *(double **)(a1 + 400);
        v95 = *(_QWORD *)(a1 + 416);
        *(_QWORD *)__lda = v94;
        v284 = v94;
        v286 = v95;
        v285 = v245[0];
        v287 = 0;
        *(_QWORD *)__incX = v95;
        v96 = 8 * v95;
        if (v245[0] >= 1)
        {
          v97 = v266.__begin_;
          v98 = v94;
          v99 = *(_QWORD *)v245;
          v100 = v258;
          v101 = v260;
          do
          {
            v102 = *v97++;
            *v98 = v100[v101 * v102];
            v98 = (double *)((char *)v98 + v96);
            --v99;
          }
          while (v99);
        }
        if (!v245[0])
        {
          LODWORD(v112) = __N;
LABEL_222:
          v39 = v237;
          if ((int)v112 >= 1)
          {
            v181 = v266.__begin_;
            v182 = v112;
            v183 = v258;
            v184 = v260;
            do
            {
              v185 = *v181++;
              v183[v184 * v185] = *v83;
              v83 = (__CLPK_doublereal *)((char *)v83 + v84);
              --v182;
            }
            while (v182);
          }
          v37 = v236;
          break;
        }
        v103 = 0;
        v104 = v94;
        v105 = v245[0];
        v106 = v83;
        do
        {
          v107 = *v104;
          if (fabs(*v104) > 2.22044605e-16)
          {
            v108 = *v106;
            if (fabs(*v106) > 2.22044605e-16
              && (v107 <= 0.0 || v108 <= 0.0)
              && (v107 >= 0.0 || v108 >= 0.0)
              && vabdd_f64(v108, v107) >= 2.22044605e-16)
            {
              v109 = (0.0 - v107) / (v108 - v107);
              if (v109 >= 0.0 && v109 <= 1.0)
              {
                v111 = v103++;
                *(double *)(*(_QWORD *)(a1 + 520) + 8 * *(_QWORD *)(a1 + 536) * v111) = v109;
              }
            }
          }
          v106 = (double *)((char *)v106 + v84);
          v104 = (double *)((char *)v104 + v96);
          --v105;
        }
        while (v105);
        v112 = __N;
        if (!v103)
          goto LABEL_222;
        v239 = v74;
        v113 = (v103 + 1);
        v238 = v103;
        *(_QWORD *)(*(_QWORD *)(a1 + 520) + 8 * *(_QWORD *)(a1 + 536) * v103) = 0x3FF0000000000000;
        std::__sort<std::__less<double,double> &,double *>();
        *(_QWORD *)v296 = vision::mod::CVMLMatrix<double,16ul>::ptr(&v273, 0);
        v297 = *(void **)v296;
        v298 = __N;
        v299 = *(_OWORD *)&v274[1];
        v300 = 0;
        v114 = *(double **)(a1 + 560);
        v115 = *(_QWORD *)(a1 + 576);
        *(_QWORD *)__nrhs = v114;
        v290 = v114;
        v292 = v115;
        v291 = (int)v112;
        v293 = 0;
        if ((int)v112 >= 1)
        {
          v116 = v83;
          v117 = v94;
          v118 = v114;
          v119 = v112;
          do
          {
            *v118 = *v116 - *v117;
            v118 += v115;
            v117 = (double *)((char *)v117 + v96);
            v116 = (double *)((char *)v116 + v84);
            --v119;
          }
          while (v119);
        }
        vision::mod::matVecMult<double,16ul>((uint64_t)v296, 1, (uint64_t)__nrhs, a1 + 432, 0.0);
        v120 = cblas_ddot(*(_DWORD *)(a1 + 448), *(const double **)(a1 + 440), *(_DWORD *)(a1 + 456), *(const double **)(a1 + 440), *(_DWORD *)(a1 + 456));
        v121 = *(_QWORD *)(a1 + 496);
        if (v121 == 1)
          memcpy(*(void **)(a1 + 480), __src, 8 * *(_QWORD *)v233);
        else
          cblas_dcopy(v233[0], (const double *)__src, 1, *(double **)(a1 + 480), v121);
        vision::mod::matVecMult<double,16ul>((uint64_t)v296, 1, (uint64_t)__lda, a1 + 472, -1.0);
        v122 = cblas_ddot(*(_DWORD *)(a1 + 448), *(const double **)(a1 + 440), *(_DWORD *)(a1 + 456), *(const double **)(a1 + 480), *(_DWORD *)(a1 + 496));
        v123 = v83;
        v124 = *(double *)(a1 + 320);
        v125 = cblas_dasum(v245[0], v94, __incX[0]);
        if (v238 < 0)
        {
          v131 = 0.0;
LABEL_157:
          catlas_daxpby(v245[0], v131, v123, v243, 1.0 - v131, v94, __incX[0]);
          v74 = v239;
          if ((int)v112 < 1)
          {
            if (!__N)
              goto LABEL_188;
            v135 = 0;
            v168 = v276.__begin_;
            v141 = v276.__begin_;
            v37 = v236;
            v39 = v237;
          }
          else
          {
            v135 = 0;
            v136 = v266.__begin_;
            v137 = v258;
            v138 = v260;
            do
            {
              v139 = *v94;
              if (fabs(*v94) < 2.22044605e-16)
              {
                *v94 = 0.0;
                *(_DWORD *)(*(_QWORD *)(a1 + 592) + 4 * v135) = *v136;
                v139 = 0.0;
                ++v135;
              }
              v140 = *v136++;
              v137[v138 * v140] = v139;
              v94 = (double *)((char *)v94 + v96);
              --v112;
            }
            while (v112);
            if (!__N)
            {
LABEL_188:
              v37 = v236;
              v39 = v237;
              syslog(5, "ERROR: empty active set: nothing to delete");
LABEL_191:
              v170 = 0;
              goto LABEL_204;
            }
            v141 = v276.__begin_;
            v37 = v236;
            v39 = v237;
            if (v135 >= 1)
            {
              v142 = 0;
              v143 = *(int **)(a1 + 592);
              v144 = v266.__begin_;
              do
              {
                v141[v142] = -1;
                if (__N < 1)
                {
LABEL_189:
                  v148 = "ERROR: index to delete not in active set";
LABEL_190:
                  syslog(5, v148);
                  goto LABEL_191;
                }
                v145 = 0;
                while (v144[v145] != v143[v142])
                {
                  if (__N == ++v145)
                    goto LABEL_189;
                }
                v141[v142++] = v145;
              }
              while (v142 != v135);
              std::__introsort<std::_ClassicAlgPolicy,std::greater<int> &,int *,false>(v141, &v141[v135], 126 - 2 * __clz(v135), 1);
              v146 = 0;
              do
              {
                v147 = v276.__begin_[v146];
                if ((v147 & 0x80000000) != 0)
                {
                  syslog(5, "ERROR: row index to delete out of range");
                  goto LABEL_191;
                }
                *(_QWORD *)v246 = v146;
                v148 = "ERROR: row index to delete out of range";
                if (__N <= (int)v147)
                  goto LABEL_190;
                v149 = vision::mod::CVMLMatrix<double,16ul>::ptr(v262, 0);
                v150 = v149;
                v151 = (int)v264;
                v152 = v147 * (_DWORD)v264;
                LODWORD(v153) = __N - 1;
                if (__N - 1 > (int)v147)
                {
                  v154 = (char *)(v149 + 8 * v152);
                  v155 = 8 * v147 + 16;
                  v156 = 8 * (int)v264;
                  v157 = v147;
                  do
                  {
                    v158 = &v154[v156];
                    memcpy(v154, &v154[v156], v155);
                    ++v157;
                    v153 = __N - 1;
                    v155 += 8;
                    v154 = v158;
                  }
                  while (v157 < v153);
                }
                *(double *)__info = 0.0;
                *(double *)__ldb = 0.0;
                if ((int)v153 > (int)v147)
                {
                  v159 = 8 * v152;
                  v160 = v150 + 8 * v147 + 8 * v151;
                  v161 = 8 * v151 + 8;
                  v162 = -2 - v147;
                  v163 = v150 + 8 * v147;
                  do
                  {
                    cblas_drotg((double *)(v163 + v159), (double *)(v163 + v159 + 8), (double *)__ldb, (double *)__info);
                    v165 = *(double *)__info;
                    v164 = *(double *)__ldb;
                    if (*(double *)(v163 + v159) < 0.0)
                    {
                      *(double *)(v163 + v159) = fabs(*(double *)(v163 + v159));
                      v164 = -v164;
                      v165 = -v165;
                      *(double *)__info = v165;
                      *(double *)__ldb = v164;
                    }
                    *(_QWORD *)(v163 + v159 + 8) = 0;
                    cblas_drot(v162 + __N, (double *)(v160 + v159), v151, (double *)(v160 + v159 + 8), v151, v164, v165);
                    ++v147;
                    v160 += v161;
                    --v162;
                    v163 += v161;
                  }
                  while (v147 < __N - 1);
                }
                v166 = v135;
                v146 = *(_QWORD *)v246 + 1;
                v37 = v236;
                v39 = v237;
                v74 = v239;
              }
              while (*(_QWORD *)v246 + 1 != v135);
              do
              {
                v167 = *v143++;
                *((_BYTE *)__p + v167) = 0;
                --v166;
              }
              while (v166);
              goto LABEL_195;
            }
            v168 = &v276.__begin_[v135];
            if (v135)
            {
              v169 = 126 - 2 * __clz(v135);
              goto LABEL_194;
            }
          }
          v169 = 0;
LABEL_194:
          std::__introsort<std::_ClassicAlgPolicy,std::greater<int> &,int *,false>(v141, v168, v169, 1);
LABEL_195:
          v171 = __N;
          if (__N >= 1)
          {
            v172 = 0;
            v173 = 0;
            do
            {
              v174 = v266.__begin_[v172];
              if (*((_BYTE *)__p + v174))
              {
                v276.__begin_[v173] = v174;
                if (v172 != v173)
                {
                  v175 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(&v273, v173);
                  v176 = (const void *)vision::mod::CVMLMatrix<double,16ul>::ptr(&v273, v172);
                  memcpy(v175, v176, 8 * v274[1]);
                }
                ++v173;
                v171 = __N;
              }
              ++v172;
            }
            while (v172 < v171);
          }
          v170 = 0;
          v177 = *(_OWORD *)&v266.__begin_;
          *(_OWORD *)&v266.__begin_ = *(_OWORD *)&v276.__begin_;
          *(_OWORD *)&v276.__begin_ = v177;
          value = v266.__end_cap_.__value_;
          v266.__end_cap_.__value_ = v276.__end_cap_.__value_;
          v276.__end_cap_.__value_ = value;
          __N = v171 - v135;
          goto LABEL_204;
        }
        v126 = 0;
        v127 = v120 * 0.5;
        v128 = v124 * v125;
        v130 = *(_QWORD *)__incX == 1 && v115 == 1;
        v131 = 0.0;
        while (1)
        {
          v132 = *(double *)(*(_QWORD *)(a1 + 520) + 8 * *(_QWORD *)(a1 + 536) * v126);
          if (v130)
            memcpy(v114, v94, 8 * v245[0]);
          else
            cblas_dcopy(v245[0], v94, __incX[0], v114, v115);
          catlas_daxpby(v245[0], v132, v123, v243, 1.0 - v132, v114, v115);
          v133 = *(double *)(a1 + 320);
          v134 = v122 * v132 + v127 * v132 * v132 + v133 * cblas_dasum(v112, v114, v115);
          if (v134 >= v128)
            break;
          ++v126;
          v128 = v134;
          v131 = v132;
          if (v113 == v126)
          {
            v131 = v132;
            goto LABEL_157;
          }
        }
        if ((_DWORD)v126)
          goto LABEL_157;
        v170 = 1;
        v37 = v236;
        v39 = v237;
        v74 = v239;
LABEL_204:
        if (v293 && *(_QWORD *)__nrhs)
          free(*(void **)__nrhs);
        if (v300 && *(_QWORD *)v296)
          free(*(void **)v296);
        v179 = v170 == 0;
        if (v170)
          v180 = 3;
        else
          v180 = 0;
        if (v179)
          ++v74;
        if (v287 && *(_QWORD *)__lda)
          free(*(void **)__lda);
        if (v180)
          break;
      }
      if (v74 != 100)
      {
        v41 = v232 + 1;
        if (v232 == 999)
          goto LABEL_228;
        continue;
      }
      break;
    }
    v24 = 7528;
LABEL_229:
    v186 = v24 != 7552;
    if (v261 && v257)
      free(v257);
    if (v24 == 7552)
    {
      v36 = v228 + 1;
      v18 = v254;
      if (v228 + 1 >= v254)
      {
        v186 = 0;
        LOBYTE(v24) = 0x80;
        break;
      }
      continue;
    }
    break;
  }
LABEL_237:
  if (v276.__begin_)
  {
    v276.__end_ = v276.__begin_;
    operator delete(v276.__begin_);
  }
  if (v275 && (_QWORD)v273)
    free((void *)v273);
  v273 = 0u;
  memset(v274, 0, sizeof(v274));
  v275 = 1;
  if (__p)
  {
    v269 = (char *)__p;
    operator delete(__p);
  }
  if (v266.__begin_)
  {
    v266.__end_ = v266.__begin_;
    operator delete(v266.__begin_);
  }
  if (v265 && v262[0])
    free(v262[0]);
  if (v280 && v277[0])
    free(v277[0]);
  if (v186 && v24 != 128)
  {
    v9 = v24 | 0x1E00;
    goto LABEL_45;
  }
  vision::mod::CVMLVector<double,16ul>::initialize_((uint64_t)__nrhs, v234);
  vision::mod::CVMLMatrix<double,16ul>::initialize_((uint64_t)v277, v234, v37);
  v188 = *a3;
  v187 = a3[1];
  v189 = 0xAAAAAAAAAAAAAAABLL * ((v187 - *a3) >> 3);
  v190 = v234 - v189;
  if (v234 <= v189)
  {
    if (v234 < v189)
    {
      v199 = v188 + 24 * v234;
      if (v187 != v199)
      {
        do
        {
          v200 = v187 - 24;
          std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*(_QWORD **)(v187 - 16));
          v187 = v200;
        }
        while (v200 != v199);
      }
      a3[1] = v199;
    }
  }
  else
  {
    v191 = a3[2];
    if (0xAAAAAAAAAAAAAAABLL * ((v191 - v187) >> 3) >= v190)
    {
      v201 = v187 + 24 * v190;
      v202 = 24 * v234 - 8 * ((v187 - *a3) >> 3);
      v203 = (_QWORD *)(v187 + 8);
      do
      {
        *v203 = 0;
        v203[1] = 0;
        *(v203 - 1) = v203;
        v203 += 3;
        v202 -= 24;
      }
      while (v202);
      a3[1] = v201;
    }
    else
    {
      v264 = a3 + 2;
      v192 = 0xAAAAAAAAAAAAAAABLL * ((v191 - v188) >> 3);
      v193 = 0x5555555555555556 * ((v191 - v188) >> 3);
      if (v193 <= v234)
        v193 = v234;
      if (v192 >= 0x555555555555555)
        v194 = 0xAAAAAAAAAAAAAAALL;
      else
        v194 = v193;
      v195 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(v194);
      v262[0] = v195;
      v262[1] = &v195[24 * v189];
      *((_QWORD *)&v263 + 1) = &v195[24 * v196];
      v197 = 24 * v234 - 24 * v189;
      v198 = (char *)v262[1] + 8;
      do
      {
        *v198 = 0;
        v198[1] = 0;
        *(v198 - 1) = v198;
        v198 += 3;
        v197 -= 24;
      }
      while (v197);
      *(_QWORD *)&v263 = &v195[24 * v234];
      std::vector<std::map<int,double>>::__swap_out_circular_buffer(a3, v262);
      std::__split_buffer<std::map<int,double>>::~__split_buffer((uint64_t)v262);
    }
  }
  v204 = *(uint64_t **)(a1 + 200);
  if (v204)
  {
    v205 = v250;
    v244 = v251;
    v247 = (char *)v249[1];
    v206 = v254;
    *(_QWORD *)__incXa = v255;
    v207 = 8 * v255;
    while (1)
    {
      v209 = *((int *)v204 + 5);
      v208 = *((int *)v204 + 6);
      v210 = *(_QWORD *)(a1 + 104);
      v211 = v208 + v209;
      if (v210 <= v209 || v211 > v210)
        break;
      v213 = *(_QWORD *)(a1 + 112);
      if (!v213)
      {
        v222 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(v222, "col index out of range");
        goto LABEL_300;
      }
      v214 = *(uint64_t **)(a1 + 120);
      v262[0] = (void *)(*(_QWORD *)(a1 + 96) + 8 * (_QWORD)v214 * v209);
      v262[1] = v262[0];
      *(_QWORD *)&v263 = v208;
      *((_QWORD *)&v263 + 1) = v213;
      v264 = v214;
      v265 = 0;
      if (!(_QWORD)v205)
      {
        v223 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(v223, "row index out of range");
        goto LABEL_302;
      }
      if (*((_QWORD *)&v205 + 1) <= v209 || v211 > *((_QWORD *)&v205 + 1))
      {
        v223 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(v223, "col index out of range");
LABEL_302:
        v223->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
        __cxa_throw(v223, (struct type_info *)off_1E452A5D0, MEMORY[0x1E0DE42E0]);
      }
      *(_QWORD *)v296 = &v247[8 * v209];
      v297 = *(void **)v296;
      v298 = v205;
      *(_QWORD *)&v299 = v208;
      *((_QWORD *)&v299 + 1) = v244;
      v300 = 0;
      if ((unint64_t)v278 < v206 || *((_QWORD *)&v278 + 1) < *(_QWORD *)__incXa)
      {
        v224 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(v224, "output matrix size too small");
        v224->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
        __cxa_throw(v224, (struct type_info *)off_1E452A5D0, MEMORY[0x1E0DE42E0]);
      }
      if (v206)
      {
        for (i = 0; i != v206; ++i)
        {
          v216 = (void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v277, i);
          v217 = (const void *)vision::mod::CVMLMatrix<double,16ul>::ptr(v253, i);
          memcpy(v216, v217, v207);
        }
      }
      vision::mod::matMult<double,16ul>((uint64_t)v296, v262, 0, v277, 0, -1.0, 1.0);
      vision::mod::CVMLMatrix<double,16ul>::rowNorms((uint64_t)v277, __nrhs, 0);
      v218 = 0;
      v219 = v290;
      v220 = 8 * v292;
      v221 = v234;
      do
      {
        *((double *)std::__tree<std::__value_type<int,double>,std::__map_value_compare<int,std::__value_type<int,double>,std::less<int>,true>,std::allocator<std::__value_type<int,double>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t **)(*a3 + v218), *((_DWORD *)v204 + 4), (_DWORD *)v204 + 4)+ 5) = fmax(1.0 - *v219, 0.0);
        v218 += 24;
        v219 = (double *)((char *)v219 + v220);
        --v221;
      }
      while (v221);
      v204 = (uint64_t *)*v204;
      if (!v204)
        goto LABEL_290;
    }
    v222 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v222, "row index out of range");
LABEL_300:
    v222->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
    __cxa_throw(v222, (struct type_info *)off_1E452A5D0, MEMORY[0x1E0DE42E0]);
  }
LABEL_290:
  if (v280 && v277[0])
    free(v277[0]);
  if (v293 && *(_QWORD *)__nrhs)
    free(*(void **)__nrhs);
  v9 = 7808;
LABEL_46:
  if (v252 && v249[0])
    free(v249[0]);
  if (v256 && v253[0])
    free(v253[0]);
  return v9;
}

void sub_1A14A43E0(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,char a40,uint64_t a41,void *a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  if (LOBYTE(STACK[0x248]) && STACK[0x220])
    free((void *)STACK[0x220]);
  if (LOBYTE(STACK[0x2A8]) && STACK[0x288])
    free((void *)STACK[0x288]);
  if (a40 && a35)
    free(a35);
  if (a47 && a42)
    free(a42);
  if (a2 == 2)
  {
    __cxa_begin_catch(a1);
    syslog(5, "ERROR: memory allocation failed");
    __cxa_end_catch();
  }
  else
  {
    if (a2 != 1)
      _Unwind_Resume(a1);
    __cxa_begin_catch(a1);
    syslog(5, "ERROR: unexpected exception thrown");
    __cxa_end_catch();
  }
  JUMPOUT(0x1A14A2F98);
}

uint64_t **std::__tree<std::__value_type<int,double>,std::__map_value_compare<int,std::__value_type<int,double>,std::less<int>,true>,std::allocator<std::__value_type<int,double>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t **a1, int a2, _DWORD *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  int v8;
  _DWORD *v9;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = operator new(0x30uLL);
    v9[8] = *a3;
    *((_QWORD *)v9 + 5) = 0;
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at(a1, (uint64_t)v7, v6, (uint64_t *)v9);
    return (uint64_t **)v9;
  }
  return v7;
}

uint64_t *std::vector<std::map<int,double>>::__swap_out_circular_buffer(uint64_t *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v3 = *result;
  v2 = result[1];
  v4 = a2[1];
  if (v2 != *result)
  {
    v5 = 0;
    do
    {
      v6 = v4 + v5;
      *(_QWORD *)(v6 - 24) = *(_QWORD *)(v2 + v5 - 24);
      v7 = (uint64_t *)(v2 + v5 - 16);
      v8 = *v7;
      *(_QWORD *)(v4 + v5 - 16) = *v7;
      v9 = v4 + v5 - 16;
      v10 = *(_QWORD *)(v2 + v5 - 8);
      *(_QWORD *)(v6 - 8) = v10;
      if (v10)
      {
        *(_QWORD *)(v8 + 16) = v9;
        *(_QWORD *)(v2 + v5 - 24) = v7;
        *v7 = 0;
        *(_QWORD *)(v2 + v5 - 8) = 0;
      }
      else
      {
        *(_QWORD *)(v6 - 24) = v9;
      }
      v5 -= 24;
    }
    while (v2 + v5 != v3);
    v4 += v5;
  }
  a2[1] = v4;
  v11 = *result;
  *result = v4;
  a2[1] = v11;
  v12 = result[1];
  result[1] = a2[2];
  a2[2] = v12;
  v13 = result[2];
  result[2] = a2[3];
  a2[3] = v13;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<std::map<int,double>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 24;
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*(_QWORD **)(i - 16));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t vision::mod::ActiveSet<double,16ul>::~ActiveSet(uint64_t a1)
{
  void *v2;
  void **v3;
  void *v4;
  void *v5;

  v2 = *(void **)(a1 + 168);
  if (v2)
  {
    *(_QWORD *)(a1 + 176) = v2;
    operator delete(v2);
  }
  v3 = (void **)(a1 + 120);
  if (*(_BYTE *)(a1 + 160) && *v3)
    free(*v3);
  *(_QWORD *)(a1 + 152) = 0;
  *(_OWORD *)v3 = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_BYTE *)(a1 + 160) = 1;
  v4 = *(void **)(a1 + 80);
  if (v4)
  {
    *(_QWORD *)(a1 + 88) = v4;
    operator delete(v4);
  }
  v5 = *(void **)(a1 + 48);
  if (v5)
  {
    *(_QWORD *)(a1 + 56) = v5;
    operator delete(v5);
  }
  if (*(_BYTE *)(a1 + 40) && *(_QWORD *)a1)
    free(*(void **)a1);
  *(_QWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_BYTE *)(a1 + 40) = 1;
  return a1;
}

void vision::mod::matVecMult<double,16ul>(uint64_t a1, int a2, uint64_t a3, uint64_t a4, double a5)
{
  uint64_t v10;
  _QWORD *v11;
  int v12;
  int v13;
  const double *v14;
  CBLAS_TRANSPOSE v15;
  std::logic_error *exception;
  struct type_info *v17;
  void (*v18)(void *);

  v10 = *(_QWORD *)(a3 + 16);
  if ((a2 & 1) != 0)
  {
    if (*(_QWORD *)(a1 + 16) == v10)
    {
      v11 = (_QWORD *)(a1 + 24);
      goto LABEL_6;
    }
LABEL_12:
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "matrix vector size mismatch");
    v17 = (struct type_info *)off_1E452A5E0;
    v18 = (void (*)(void *))MEMORY[0x1E0DE4360];
LABEL_13:
    __cxa_throw(exception, v17, v18);
  }
  if (*(_QWORD *)(a1 + 24) != v10)
    goto LABEL_12;
  v11 = (_QWORD *)(a1 + 16);
LABEL_6:
  if (*v11 != *(_QWORD *)(a4 + 16))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "vector size too small for output");
    v17 = (struct type_info *)off_1E452A5D0;
    v18 = (void (*)(void *))MEMORY[0x1E0DE42E0];
    goto LABEL_13;
  }
  v12 = *(_DWORD *)(a1 + 16);
  v13 = *(_DWORD *)(a1 + 24);
  v14 = (const double *)vision::mod::CVMLMatrix<double,16ul>::ptr((_QWORD *)a1, 0);
  if (a2)
    v15 = CblasTrans;
  else
    v15 = CblasNoTrans;
  cblas_dgemv(CblasRowMajor, v15, v12, v13, 1.0, v14, *(_DWORD *)(a1 + 32), *(const double **)(a3 + 8), *(_DWORD *)(a3 + 24), a5, *(double **)(a4 + 8), *(_QWORD *)(a4 + 24));
}

void sub_1A14A4A24(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::FaceIDModel::serialize(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t *v9;
  _QWORD *v10;
  _DWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t *v17;
  std::vector<int>::pointer begin;
  std::vector<int>::pointer v19;
  _DWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  _QWORD *v24;
  uint64_t *v25;
  std::vector<int>::pointer v26;
  std::vector<int>::pointer v27;
  std::vector<int>::pointer v28;
  _QWORD *v29;
  _QWORD *v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  std::vector<int> v36;
  std::vector<int> v37;
  std::vector<int> v38;
  _DWORD v39[7];
  std::vector<int> v40;
  std::vector<int> v41;
  _DWORD __n[7];
  void *__p;
  void *v44;
  int v45;
  char v46[35];
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  _BYTE v51[29];
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  memset(v51, 0, sizeof(v51));
  v50 = 0u;
  v49 = 0u;
  v48 = 0u;
  v47 = 0u;
  *(_OWORD *)&v46[19] = 0u;
  strcpy(v46, "FaceIDModel_v1_d18");
  v2 = (_QWORD *)std::ostream::write();
  if ((*((_BYTE *)v2 + *(_QWORD *)(*v2 - 24) + 32) & 5) != 0)
    return 7797;
  v3 = (_QWORD *)std::ostream::write();
  if ((*((_BYTE *)v3 + *(_QWORD *)(*v3 - 24) + 32) & 5) != 0)
    return 7797;
  v4 = (_QWORD *)std::ostream::write();
  if ((*((_BYTE *)v4 + *(_QWORD *)(*v4 - 24) + 32) & 5) != 0)
    return 7797;
  v5 = (_QWORD *)std::ostream::write();
  if ((*((_BYTE *)v5 + *(_QWORD *)(*v5 - 24) + 32) & 5) != 0)
    return 7797;
  v6 = (_QWORD *)std::ostream::write();
  if ((*((_BYTE *)v6 + *(_QWORD *)(*v6 - 24) + 32) & 5) != 0)
    return 7797;
  v7 = (_QWORD *)std::ostream::write();
  if ((*((_BYTE *)v7 + *(_QWORD *)(*v7 - 24) + 32) & 5) != 0)
    return 7797;
  v8 = (_QWORD *)std::ostream::write();
  if ((*((_BYTE *)v8 + *(_QWORD *)(*v8 - 24) + 32) & 5) != 0
    || vision::mod::FaceIDKmeansParams::serialize() != 128)
  {
    return 7797;
  }
  v45 = a1[3];
  std::vector<long long>::vector(&__p, v45);
  std::vector<int>::vector((std::vector<int> *)&__n[1], v45);
  v9 = (uint64_t *)a1[2];
  if (v9)
  {
    v10 = __p;
    v11 = *(_DWORD **)&__n[1];
    do
    {
      *v10++ = v9[2];
      *v11++ = *((_DWORD *)v9 + 6);
      v9 = (uint64_t *)*v9;
    }
    while (v9);
  }
  v12 = (_QWORD *)std::ostream::write();
  if ((*((_BYTE *)v12 + *(_QWORD *)(*v12 - 24) + 32) & 5) != 0
    || (v13 = (_QWORD *)std::ostream::write(), (*((_BYTE *)v13 + *(_QWORD *)(*v13 - 24) + 32) & 5) != 0)
    || (v14 = (_QWORD *)std::ostream::write(), (*((_BYTE *)v14 + *(_QWORD *)(*v14 - 24) + 32) & 5) != 0))
  {
    v15 = 7797;
  }
  else
  {
    v44 = __p;
    *(_QWORD *)&__n[3] = *(_QWORD *)&__n[1];
    v15 = vision::mod::_serialize(a1 + 11);
    if (v15 == 128)
    {
      __n[0] = a1[26];
      std::vector<int>::vector(&v41, __n[0]);
      std::vector<int>::vector(&v40, __n[0]);
      std::vector<int>::vector((std::vector<int> *)&v39[1], __n[0]);
      v17 = (uint64_t *)a1[25];
      if (v17)
      {
        begin = v41.__begin_;
        v19 = v40.__begin_;
        v20 = *(_DWORD **)&v39[1];
        do
        {
          *begin++ = *((_DWORD *)v17 + 4);
          *v19++ = *((_DWORD *)v17 + 5);
          *v20++ = *((_DWORD *)v17 + 6);
          v17 = (uint64_t *)*v17;
        }
        while (v17);
      }
      v21 = (_QWORD *)std::ostream::write();
      if ((*((_BYTE *)v21 + *(_QWORD *)(*v21 - 24) + 32) & 5) != 0
        || (v22 = (_QWORD *)std::ostream::write(), (*((_BYTE *)v22 + *(_QWORD *)(*v22 - 24) + 32) & 5) != 0)
        || (v23 = (_QWORD *)std::ostream::write(), (*((_BYTE *)v23 + *(_QWORD *)(*v23 - 24) + 32) & 5) != 0)
        || (v24 = (_QWORD *)std::ostream::write(), (*((_BYTE *)v24 + *(_QWORD *)(*v24 - 24) + 32) & 5) != 0))
      {
        v15 = 7797;
      }
      else
      {
        v15 = vision::mod::_serialize(a1 + 17);
        if (v15 == 128)
        {
          v39[0] = a1[31];
          std::vector<int>::vector(&v38, v39[0]);
          std::vector<int>::vector(&v37, v39[0]);
          std::vector<int>::vector(&v36, v39[0]);
          v25 = (uint64_t *)a1[30];
          if (v25)
          {
            v26 = v38.__begin_;
            v27 = v37.__begin_;
            v28 = v36.__begin_;
            do
            {
              *v26++ = *((_DWORD *)v25 + 4);
              *v27++ = *((_DWORD *)v25 + 5);
              *v28++ = *((_DWORD *)v25 + 6);
              v25 = (uint64_t *)*v25;
            }
            while (v25);
          }
          v29 = (_QWORD *)std::ostream::write();
          if ((*((_BYTE *)v29 + *(_QWORD *)(*v29 - 24) + 32) & 5) != 0
            || (v30 = (_QWORD *)std::ostream::write(), (*((_BYTE *)v30 + *(_QWORD *)(*v30 - 24) + 32) & 5) != 0))
          {
            v31 = &CVML_status_IOError;
          }
          else
          {
            v34 = (_QWORD *)std::ostream::write();
            v31 = &CVML_status_IOError;
            if ((*((_BYTE *)v34 + *(_QWORD *)(*v34 - 24) + 32) & 5) == 0)
            {
              v35 = (_QWORD *)std::ostream::write();
              if ((*((_BYTE *)v35 + *(_QWORD *)(*v35 - 24) + 32) & 5) == 0)
                v31 = &CVML_status_ok;
            }
          }
          v32 = *v31;
          if (v36.__begin_)
          {
            v36.__end_ = v36.__begin_;
            operator delete(v36.__begin_);
          }
          v33 = v32 + 128;
          if (v37.__begin_)
          {
            v37.__end_ = v37.__begin_;
            operator delete(v37.__begin_);
          }
          v15 = v33 | 0x1E00;
          if (v38.__begin_)
          {
            v38.__end_ = v38.__begin_;
            operator delete(v38.__begin_);
          }
        }
      }
      if (*(_QWORD *)&v39[1])
      {
        *(_QWORD *)&v39[3] = *(_QWORD *)&v39[1];
        operator delete(*(void **)&v39[1]);
      }
      if (v40.__begin_)
      {
        v40.__end_ = v40.__begin_;
        operator delete(v40.__begin_);
      }
      if (v41.__begin_)
      {
        v41.__end_ = v41.__begin_;
        operator delete(v41.__begin_);
      }
    }
  }
  if (*(_QWORD *)&__n[1])
  {
    *(_QWORD *)&__n[3] = *(_QWORD *)&__n[1];
    operator delete(*(void **)&__n[1]);
  }
  if (__p)
  {
    v44 = __p;
    operator delete(__p);
  }
  return v15;
}

void sub_1A14A5028(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34)
{
  if (__p)
    operator delete(__p);
  if (a16)
    operator delete(a16);
  if (a20)
    operator delete(a20);
  if (a23)
    operator delete(a23);
  if (a26)
    operator delete(a26);
  if (a30)
    operator delete(a30);
  if (a33)
    operator delete(a33);
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<long long>::vector(_QWORD *a1, unint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<long long>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_1A14A5154(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

std::vector<int> *__cdecl std::vector<int>::vector(std::vector<int> *this, std::vector<int>::size_type __n)
{
  std::vector<int>::pointer end;

  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    std::vector<float>::__vallocate[abi:ne180100](this, __n);
    end = this->__end_;
    bzero(end, 4 * __n);
    this->__end_ = &end[__n];
  }
  return this;
}

void sub_1A14A51C8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t vision::mod::_serialize(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v6;
  uint64_t *v7;
  _QWORD *v8;
  int v9;

  v9 = a1[2];
  v2 = (_QWORD *)std::ostream::write();
  if ((*((_BYTE *)v2 + *(_QWORD *)(*v2 - 24) + 32) & 5) != 0
    || (v3 = (_QWORD *)std::ostream::write(), (*((_BYTE *)v3 + *(_QWORD *)(*v3 - 24) + 32) & 5) != 0))
  {
    v4 = -11;
  }
  else
  {
    v6 = (_QWORD *)std::ostream::write();
    if ((*((_BYTE *)v6 + *(_QWORD *)(*v6 - 24) + 32) & 5) != 0
      || v9 >= 1
      && (vision::mod::CVMLMatrix<double,16ul>::ptr(a1, 0),
          v8 = (_QWORD *)std::ostream::write(),
          (*((_BYTE *)v8 + *(_QWORD *)(*v8 - 24) + 32) & 5) != 0))
    {
      v7 = &CVML_status_IOError;
    }
    else
    {
      v7 = &CVML_status_ok;
    }
    v4 = *v7;
  }
  return (v4 + 128) | 0x1E00;
}

uint64_t vision::mod::FaceIDModel::deserialize(uint64_t a1)
{
  _QWORD *v2;
  BOOL v4;
  int v5;
  BOOL v6;
  BOOL v7;
  char v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  void **v26;
  _QWORD *v27;
  _QWORD *v28;
  _QWORD *v29;
  _QWORD *v30;
  uint64_t v31;
  int v32;
  int v33;
  _QWORD *v34;
  _QWORD *v35;
  _QWORD *v36;
  _QWORD *v37;
  _QWORD *v38;
  char v39;
  uint64_t v40;
  int v41;
  int v42;
  _QWORD *v43;
  std::vector<int> v44;
  std::vector<int> v45;
  std::vector<int> v46;
  _DWORD v47[7];
  std::vector<int> v48;
  std::vector<int> v49;
  _DWORD v50[7];
  void *__p;
  void *v52;
  _DWORD __n[3];
  _QWORD v54[17];

  v54[15] = *MEMORY[0x1E0C80C00];
  v2 = (_QWORD *)std::istream::read();
  if ((*((_BYTE *)v2 + *(_QWORD *)(*v2 - 24) + 32) & 5) != 0)
    return 7797;
  v4 = *(_QWORD *)&__n[1] == 0x6F4D444965636146
    && v54[0] == 0x645F31765F6C6564
    && *(_QWORD *)((char *)v54 + 3) == 0x3831645F31765FLL;
  v5 = !v4;
  if (v4
    || (*(_QWORD *)&__n[1] == 0x6F4D444965636146 ? (v6 = v54[0] == 0x645F31765F6C6564) : (v6 = 0),
        v6 ? (v7 = *(_QWORD *)((char *)v54 + 3) == 0x3731645F31765FLL) : (v7 = 0),
        v7))
  {
    v10 = 1;
  }
  else
  {
    if (*(_QWORD *)&__n[1] != 0x6F4D444965636146
      || v54[0] != 0x645F31765F6C6564
      || *(_QWORD *)((char *)v54 + 3) != 0x3631645F31765FLL)
    {
      syslog(5, "ERROR: incorrect header");
      return 7797;
    }
    v10 = 0;
  }
  v11 = (_QWORD *)std::istream::read();
  if ((*((_BYTE *)v11 + *(_QWORD *)(*v11 - 24) + 32) & 5) != 0)
    return 7797;
  v12 = (_QWORD *)std::istream::read();
  if ((*((_BYTE *)v12 + *(_QWORD *)(*v12 - 24) + 32) & 5) != 0)
    return 7797;
  v13 = (_QWORD *)std::istream::read();
  if ((*((_BYTE *)v13 + *(_QWORD *)(*v13 - 24) + 32) & 5) != 0)
    return 7797;
  v14 = (_QWORD *)std::istream::read();
  if ((*((_BYTE *)v14 + *(_QWORD *)(*v14 - 24) + 32) & 5) != 0)
    return 7797;
  if (!v5)
  {
    v20 = (_QWORD *)std::istream::read();
    if ((*((_BYTE *)v20 + *(_QWORD *)(*v20 - 24) + 32) & 5) != 0)
      return 7797;
  }
  v15 = (_QWORD *)std::istream::read();
  if ((*((_BYTE *)v15 + *(_QWORD *)(*v15 - 24) + 32) & 5) != 0)
    return 7797;
  if (vision::mod::FaceIDKmeansParams::deserialize() != 128)
    return 7797;
  __n[0] = 0;
  v16 = (_QWORD *)std::istream::read();
  if ((*((_BYTE *)v16 + *(_QWORD *)(*v16 - 24) + 32) & 5) != 0)
    return 7797;
  std::vector<long long>::vector(&__p, __n[0]);
  std::vector<int>::vector((std::vector<int> *)&v50[1], __n[0]);
  v17 = (_QWORD *)std::istream::read();
  if ((*((_BYTE *)v17 + *(_QWORD *)(*v17 - 24) + 32) & 5) == 0)
  {
    v18 = (_QWORD *)std::istream::read();
    if ((*((_BYTE *)v18 + *(_QWORD *)(*v18 - 24) + 32) & 5) == 0)
    {
      if (__n[0] >= 1)
      {
        v22 = 0;
        v23 = 0;
        do
        {
          v24 = *(_DWORD *)(*(_QWORD *)&v50[1] + 4 * v23);
          *((_DWORD *)std::__hash_table<std::__hash_value_type<long long,int>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,int>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,int>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,int>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>((float *)a1, *(_QWORD *)((char *)__p + v22), (char *)__p + v22)+ 6) = v24;
          ++v23;
          v22 += 8;
        }
        while (v23 < __n[0]);
      }
      v52 = __p;
      *(_QWORD *)&v50[3] = *(_QWORD *)&v50[1];
      v19 = vision::mod::_deserialize();
      if (v19 != 128)
        goto LABEL_39;
      v25 = *(_QWORD *)(a1 + 112);
      v26 = (void **)(a1 + 136);
      vision::mod::CVMLMatrix<double,16ul>::reset(a1 + 136, 0, v25);
      if (*(_BYTE *)(a1 + 176) && *v26)
        free(*v26);
      *(_QWORD *)(a1 + 168) = 0;
      *(_OWORD *)v26 = 0u;
      *(_OWORD *)(a1 + 152) = 0u;
      *(_BYTE *)(a1 + 176) = 1;
      v19 = 7808;
      if (!v25 || !*(_QWORD *)(a1 + 104))
        goto LABEL_39;
      v50[0] = 0;
      v27 = (_QWORD *)std::istream::read();
      if ((*((_BYTE *)v27 + *(_QWORD *)(*v27 - 24) + 32) & 5) == 0)
      {
        std::vector<int>::vector(&v49, v50[0]);
        std::vector<int>::vector(&v48, v50[0]);
        std::vector<int>::vector((std::vector<int> *)&v47[1], v50[0]);
        v28 = (_QWORD *)std::istream::read();
        if ((*((_BYTE *)v28 + *(_QWORD *)(*v28 - 24) + 32) & 5) != 0)
          goto LABEL_60;
        v29 = (_QWORD *)std::istream::read();
        if ((*((_BYTE *)v29 + *(_QWORD *)(*v29 - 24) + 32) & 5) != 0)
          goto LABEL_60;
        v30 = (_QWORD *)std::istream::read();
        if ((*((_BYTE *)v30 + *(_QWORD *)(*v30 - 24) + 32) & 5) != 0)
          goto LABEL_60;
        if (v50[0] >= 1)
        {
          v31 = 0;
          do
          {
            v32 = v48.__begin_[v31];
            v33 = *(_DWORD *)(*(_QWORD *)&v47[1] + 4 * v31);
            v34 = std::__hash_table<std::__hash_value_type<int,std::pair<int,int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::pair<int,int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::pair<int,int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::pair<int,int>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((float *)(a1 + 184), v49.__begin_[v31], &v49.__begin_[v31]);
            *((_DWORD *)v34 + 5) = v32;
            *((_DWORD *)v34 + 6) = v33;
            ++v31;
          }
          while (v31 < v50[0]);
        }
        if ((v10 & 1) != 0)
        {
          v19 = vision::mod::_deserialize();
          if (v19 != 128)
            goto LABEL_61;
        }
        if (v5)
          goto LABEL_73;
        v47[0] = 0;
        v35 = (_QWORD *)std::istream::read();
        if ((*((_BYTE *)v35 + *(_QWORD *)(*v35 - 24) + 32) & 5) != 0)
          goto LABEL_60;
        std::vector<int>::vector(&v46, v47[0]);
        std::vector<int>::vector(&v45, v47[0]);
        std::vector<int>::vector(&v44, v47[0]);
        v36 = (_QWORD *)std::istream::read();
        if ((*((_BYTE *)v36 + *(_QWORD *)(*v36 - 24) + 32) & 5) != 0
          || (v37 = (_QWORD *)std::istream::read(), (*((_BYTE *)v37 + *(_QWORD *)(*v37 - 24) + 32) & 5) != 0)
          || (v38 = (_QWORD *)std::istream::read(), (*((_BYTE *)v38 + *(_QWORD *)(*v38 - 24) + 32) & 5) != 0))
        {
          v39 = 0;
        }
        else
        {
          if (v47[0] >= 1)
          {
            v40 = 0;
            do
            {
              v41 = v45.__begin_[v40];
              v42 = v44.__begin_[v40];
              v43 = std::__hash_table<std::__hash_value_type<int,std::pair<int,int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::pair<int,int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::pair<int,int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::pair<int,int>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((float *)(a1 + 224), v46.__begin_[v40], &v46.__begin_[v40]);
              *((_DWORD *)v43 + 5) = v41;
              *((_DWORD *)v43 + 6) = v42;
              ++v40;
            }
            while (v40 < v47[0]);
          }
          v39 = 1;
        }
        if (v44.__begin_)
        {
          v44.__end_ = v44.__begin_;
          operator delete(v44.__begin_);
        }
        if (v45.__begin_)
        {
          v45.__end_ = v45.__begin_;
          operator delete(v45.__begin_);
        }
        if (v46.__begin_)
        {
          v46.__end_ = v46.__begin_;
          operator delete(v46.__begin_);
        }
        if ((v39 & 1) == 0)
        {
LABEL_60:
          v19 = 7797;
        }
        else
        {
LABEL_73:
          vision::mod::FeatureSignSparseCoder<double,16ul>::initialize(a1 + 264, (_QWORD *)(a1 + 88));
          v19 = 7808;
        }
LABEL_61:
        if (*(_QWORD *)&v47[1])
        {
          *(_QWORD *)&v47[3] = *(_QWORD *)&v47[1];
          operator delete(*(void **)&v47[1]);
        }
        if (v48.__begin_)
        {
          v48.__end_ = v48.__begin_;
          operator delete(v48.__begin_);
        }
        if (v49.__begin_)
        {
          v49.__end_ = v49.__begin_;
          operator delete(v49.__begin_);
        }
        goto LABEL_39;
      }
    }
  }
  v19 = 7797;
LABEL_39:
  if (*(_QWORD *)&v50[1])
  {
    *(_QWORD *)&v50[3] = *(_QWORD *)&v50[1];
    operator delete(*(void **)&v50[1]);
  }
  if (__p)
  {
    v52 = __p;
    operator delete(__p);
  }
  return v19;
}

void sub_1A14A5A90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34)
{
  if (__p)
    operator delete(__p);
  if (a13)
    operator delete(a13);
  if (a16)
    operator delete(a16);
  if (a20)
    operator delete(a20);
  if (a23)
    operator delete(a23);
  if (a26)
    operator delete(a26);
  if (a30)
    operator delete(a30);
  if (a33)
    operator delete(a33);
  _Unwind_Resume(exception_object);
}

uint64_t vision::mod::_deserialize()
{
  _QWORD *v0;
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v4;
  uint64_t *v5;

  v0 = (_QWORD *)std::istream::read();
  if ((*((_BYTE *)v0 + *(_QWORD *)(*v0 - 24) + 32) & 5) != 0
    || (v1 = (_QWORD *)std::istream::read(), (*((_BYTE *)v1 + *(_QWORD *)(*v1 - 24) + 32) & 5) != 0))
  {
    v2 = -11;
  }
  else
  {
    v4 = (_QWORD *)std::istream::read();
    v5 = &CVML_status_IOError;
    if ((*((_BYTE *)v4 + *(_QWORD *)(*v4 - 24) + 32) & 5) == 0)
      v5 = &CVML_status_ok;
    v2 = *v5;
  }
  return (v2 + 128) | 0x1E00;
}

uint64_t vision::mod::FaceIDModel::getIdentityTrainingData(_QWORD *a1, int a2, vision::mod::ImageDescriptorBufferAbstract **a3)
{
  unint64_t v3;
  uint8x8_t v6;
  unint64_t v7;
  uint64_t **v8;
  uint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v13;
  uint64_t v14;
  void *v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  vision::mod::ImageDescriptorBufferAbstract *v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t shared_owners;
  double *v22;
  float *v23;
  uint64_t v24;
  double v25;
  float v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  unint64_t *v31;
  unint64_t v32;
  std::__shared_weak_count *v33;
  uint64_t v34;
  std::__shared_weak_count *v35;
  void *__p[3];

  v3 = a1[29];
  if (!v3)
    goto LABEL_17;
  v6 = (uint8x8_t)vcnt_s8((int8x8_t)v3);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    v7 = a2;
    if (v3 <= a2)
      v7 = a2 % v3;
  }
  else
  {
    v7 = (v3 - 1) & a2;
  }
  v8 = *(uint64_t ***)(a1[28] + 8 * v7);
  if (!v8 || (v9 = *v8) == 0)
  {
LABEL_17:
    v11 = -4;
    return (v11 + 128) | 0x1E00;
  }
  while (1)
  {
    v10 = v9[1];
    if (v10 == a2)
      break;
    if (v6.u32[0] > 1uLL)
    {
      if (v10 >= v3)
        v10 %= v3;
    }
    else
    {
      v10 &= v3 - 1;
    }
    if (v10 != v7)
      goto LABEL_17;
LABEL_16:
    v9 = (uint64_t *)*v9;
    if (!v9)
      goto LABEL_17;
  }
  if (*((_DWORD *)v9 + 4) != a2)
    goto LABEL_16;
  v13 = *((unsigned int *)v9 + 6);
  if ((int)v13 >= 1 && (v14 = a1[20]) != 0)
  {
    v34 = *((int *)v9 + 5);
    std::vector<long long>::vector(__p, v13);
    v15 = malloc_type_calloc(v13, 4 * v14, 0xF783D623uLL);
    if (v15)
    {
      v16 = (std::__shared_weak_count *)operator new(0x90uLL);
      v16->__shared_owners_ = 0;
      p_shared_owners = (unint64_t *)&v16->__shared_owners_;
      v16->__shared_weak_owners_ = 0;
      v16->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453B958;
      v18 = (vision::mod::ImageDescriptorBufferAbstract *)&v16[1];
      vision::mod::ImageDescriptorBufferAbstract::ImageDescriptorBufferAbstract((uint64_t)&v16[1], (_QWORD **)__p, v15, 4 * v14, (int)v13, 1);
      v19 = 0;
      v20 = a1 + 17;
      v16[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1E453A8D0;
      LODWORD(v16[5].__shared_owners_) = 1;
      v16[5].__shared_weak_owners_ = 0;
      v16[5].__vftable = (std::__shared_weak_count_vtbl *)(v14 & 0x3FFFFFFFFFFFFFFFLL);
      v35 = v16;
      v33 = v16;
      shared_owners = v16[3].__shared_owners_;
      do
      {
        v22 = (double *)vision::mod::CVMLMatrix<double,16ul>::ptr(v20, v19 + v34);
        v23 = (float *)(shared_owners + 4 * v14 * v19);
        v24 = 8 * v14;
        do
        {
          v25 = *v22++;
          v26 = v25;
          *v23++ = v26;
          v24 -= 8;
        }
        while (v24);
        vision::mod::ImageDescriptorBufferAbstract::setDescriptorIdForKthDescriptor(v18, v19, v19 + v34);
        ++v19;
      }
      while (v19 != (int)v13);
      do
        v27 = __ldxr(p_shared_owners);
      while (__stxr(v27 + 1, p_shared_owners));
      v28 = (std::__shared_weak_count *)a3[1];
      *a3 = v18;
      a3[1] = (vision::mod::ImageDescriptorBufferAbstract *)v33;
      if (v28)
      {
        v29 = (unint64_t *)&v28->__shared_owners_;
        do
          v30 = __ldaxr(v29);
        while (__stlxr(v30 - 1, v29));
        if (!v30)
        {
          ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
          std::__shared_weak_count::__release_weak(v28);
        }
      }
      if (v35)
      {
        v31 = (unint64_t *)&v35->__shared_owners_;
        do
          v32 = __ldaxr(v31);
        while (__stlxr(v32 - 1, v31));
        if (!v32)
        {
          ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
          std::__shared_weak_count::__release_weak(v35);
        }
      }
      v11 = 0;
    }
    else
    {
      syslog(5, "ERROR: Failed to allocate descriptor data of count %d, stride %d", v13, 4 * v14);
      v11 = -5;
    }
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
  else
  {
    v11 = -24;
  }
  return (v11 + 128) | 0x1E00;
}

void sub_1A14A5FDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, void *__p, uint64_t a17)
{
  std::__shared_weak_count *v17;
  void *v19;

  std::__shared_weak_count::~__shared_weak_count(v17);
  operator delete(v19);
  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void sub_1A14A6E18(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t _getModelDropForConfigurationOptions(void *a1, _DWORD *a2, _QWORD *a3)
{
  id v5;
  void *v6;
  void *v7;
  uint64_t v8;

  v5 = a1;
  +[VNValidationUtilities originatingRequestSpecifierInOptions:specifyingRequestClass:error:](VNValidationUtilities, "originatingRequestSpecifierInOptions:specifyingRequestClass:error:", v5, objc_opt_class(), a3);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = v6;
  if (!v6)
    goto LABEL_6;
  if (objc_msgSend(v6, "requestRevision") != 3)
  {
    if (a3)
    {
      +[VNError errorForUnsupportedRequestSpecifier:](VNError, "errorForUnsupportedRequestSpecifier:", v7);
      v8 = 0;
      *a3 = (id)objc_claimAutoreleasedReturnValue();
      goto LABEL_7;
    }
LABEL_6:
    v8 = 0;
    goto LABEL_7;
  }
  v8 = 1;
  *a2 = 1;
LABEL_7:

  return v8;
}

void sub_1A14A6EE8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14A6F8C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14A7060(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14A7624(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  void *v9;
  void *v10;
  void *v11;
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void sub_1A14A77EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  void *v5;
  void *v6;
  void *v7;
  va_list va;

  va_start(va, a5);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void sub_1A14A797C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  void *v5;
  void *v6;
  void *v7;
  va_list va;

  va_start(va, a5);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

Class ___ZL31getVCPHandPoseImageRequestClassv_block_invoke(uint64_t a1)
{
  Class result;
  void *v3;
  SEL v4;

  VideoProcessingLibrary();
  result = objc_getClass("VCPHandPoseImageRequest");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    getVCPHandPoseImageRequestClass(void)::softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  else
  {
    v3 = (void *)abort_report_np();
    return +[VNHumanHandPoseDetector recognizedPointsObservationClass](v3, v4);
  }
  return result;
}

void sub_1A14A7BB4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14A7CA0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14A7D2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A14A7DC8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14A7E5C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14A7ED8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14A7F90(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14A807C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14A8264(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void vision::mod::ColorGaborImageDescriptorBuffer::~ColorGaborImageDescriptorBuffer(void **this)
{
  vision::mod::ImageDescriptorBufferAbstract::~ImageDescriptorBufferAbstract(this);
  JUMPOUT(0x1A1B0A898);
}

float *vision::mod::ColorGaborImageDescriptorBuffer::computeDistancesFrom@<X0>(vision::mod::ColorGaborImageDescriptorBuffer *this@<X0>, const vision::mod::ImageDescriptorBufferAbstract *a2@<X1>, float **a3@<X8>)
{
  unint64_t DataForKthDescriptor;
  unint64_t v6;
  uint64_t v7;
  float v8;
  uint16x8_t v9;
  float32x4_t v10;
  uint16x8_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float v15;
  float32x4_t v16;
  float v17;
  uint64_t v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  uint64_t v27;
  float v28;
  float v29;
  float v30;
  float v31;
  uint16x4_t *v32;
  uint16x4_t *v33;
  float v34;
  int v35;
  unint64_t v36;
  int v37;
  float v38;
  float v39;
  uint16x4_t v40;
  float32x4_t v41;
  uint16x4_t v42;
  float32x4_t v43;
  float v44;
  float v45;
  BOOL v46;
  float v47;
  float v48;
  float v49;
  BOOL v50;
  float v51;
  float v52;
  float *v53;
  float *result;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  DataForKthDescriptor = vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(this, 0);
  v6 = vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(a2, 0);
  v7 = 0;
  v8 = 0.0;
  do
  {
    v9 = *(uint16x8_t *)(DataForKthDescriptor + v7);
    v10 = vcvtq_f32_u32(vmovl_high_u16(v9));
    v11 = *(uint16x8_t *)(v6 + v7);
    v12 = vsubq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v9.i8)), vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v11.i8)));
    v13 = vsubq_f32(v10, vcvtq_f32_u32(vmovl_high_u16(v11)));
    v14 = vmulq_f32(v13, v13);
    HIWORD(v15) = v14.i16[3];
    v16 = vmulq_f32(v12, v12);
    HIWORD(v17) = v16.i16[7];
    v8 = (float)((float)((float)((float)((float)((float)((float)(v8 + v16.f32[0]) + v16.f32[1]) + v16.f32[2])
                                       + v16.f32[3])
                               + v14.f32[0])
                       + v14.f32[1])
               + v14.f32[2])
       + v14.f32[3];
    v7 += 16;
  }
  while (v7 != 64);
  v18 = 0;
  v19 = 0.0;
  v20 = 0.0;
  v21 = 0.0;
  do
  {
    LOWORD(v15) = *(_WORD *)(DataForKthDescriptor + 64 + 2 * v18);
    LOWORD(v17) = *(_WORD *)(v6 + 64 + 2 * v18);
    v22 = (float)LODWORD(v15);
    v17 = (float)LODWORD(v17);
    if (v18 >= 8)
      v23 = -0.0;
    else
      v23 = v22;
    v21 = v21 + v23;
    if (v18 >= 8)
      v24 = -0.0;
    else
      v24 = v17;
    v20 = v20 + v24;
    v15 = sqrtf(v22 * v17);
    v19 = v19 + v15;
    ++v18;
  }
  while ((_DWORD)v18 != 36);
  v25 = v21 / 65535.0;
  v26 = sqrtf(v8) / 65535.0;
  if ((float)(v21 / 65535.0) > 0.97 || (float)(v20 / 65535.0) > 0.97)
  {
    v48 = v26 + v26;
    goto LABEL_40;
  }
  v27 = 0;
  v28 = 1.0 - (float)(v19 / 65535.0);
  v29 = 0.0;
  v30 = 0.0;
  do
  {
    LOWORD(v25) = *(_WORD *)(DataForKthDescriptor + 64 + v27);
    LOWORD(v17) = *(_WORD *)(v6 + 64 + v27);
    v17 = (float)LODWORD(v17) / 65535.0;
    v31 = v29 + (float)((float)LODWORD(v25) / 65535.0);
    v29 = v31 - v17;
    v25 = vabds_f32(v31, v17);
    v30 = v30 + v25;
    v27 += 2;
  }
  while (v27 != 72);
  v32 = (uint16x4_t *)(v6 + 64);
  v33 = (uint16x4_t *)(DataForKthDescriptor + 64);
  v34 = 1.0;
  v35 = 1;
  v36 = 28;
  v37 = 1;
  v38 = 1.0;
  v39 = 0.0;
  do
  {
    v40 = *v33++;
    v41 = vcvtq_f32_u32(vmovl_u16(v40));
    v42 = *v32++;
    v43 = vcvtq_f32_u32(vmovl_u16(v42));
    v43.f32[0] = (float)((float)(v43.f32[0] + 0.0) + v43.f32[1]) + v43.f32[2];
    v44 = v43.f32[0] + v43.f32[3];
    v45 = (float)((float)((float)(v41.f32[0] + 0.0) + v41.f32[1]) + v41.f32[2]) + v41.f32[3];
    v46 = v38 < v45;
    if (v38 < v45)
      v38 = v45;
    v36 += 4;
    if (v46)
      v37 = v36;
    if (v34 < v44)
    {
      v34 = v43.f32[0] + v43.f32[3];
      v35 = v36;
    }
    v39 = v39 + sqrtf(v45 * v44);
  }
  while (v36 < 0x40);
  v47 = (float)(v39 / -65535.0) + 1.0;
  if (v37 == v35)
  {
    if (v37 == 32)
    {
      v47 = v28;
      goto LABEL_32;
    }
    if ((float)(v28 / v47) > 3.0)
    {
      v47 = (float)(v47 * 0.75) + v28 * 0.25;
      goto LABEL_32;
    }
    goto LABEL_31;
  }
  if (v30 >= 2.5)
LABEL_31:
    v47 = (float)(v28 + v47) * 0.5;
LABEL_32:
  if (v26 >= v47)
    v49 = v47;
  else
    v49 = v26;
  v50 = v47 < 0.05 || v26 < 0.05;
  v51 = v49 + v49;
  v48 = v26 + v47;
  if (v50)
    v48 = v51;
LABEL_40:
  v52 = v48 * 1.4;
  if ((float)(v48 * 1.4) > 0.6)
    v52 = 1.0 - expf(-(float)((float)(v52 + 0.3572) * (float)(v52 + 0.3572)));
  v53 = (float *)operator new(4uLL);
  *a3 = v53;
  *v53 = v52;
  result = v53 + 1;
  a3[1] = result;
  a3[2] = result;
  return result;
}

void vision::mod::ColorGaborImageDescriptorBuffer::computeSelfDistances(vision::mod::ColorGaborImageDescriptorBuffer *this)
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
  *exception = 3711;
  __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
}

uint64_t vision::mod::ColorGaborImageDescriptorBuffer::getDescriptorLengthInBytes(vision::mod::ColorGaborImageDescriptorBuffer *this)
{
  return 136;
}

void vision::mod::ColorGaborImageDescriptorProcessor::~ColorGaborImageDescriptorProcessor(vision::mod::ColorGaborImageDescriptorProcessor *this)
{
  JUMPOUT(0x1A1B0A898);
}

uint64_t vision::mod::ImageDescriptorProcessorAbstract::computeDescriptorForImage_RGBA8888(vision::mod::ImageDescriptorProcessorAbstract *this, const vImage_Buffer *a2, vision::mod::ImageDescriptorBufferAbstract *a3)
{
  syslog(5, "ERROR: This descriptor processor does not know how to handle RGBA8888 images", a3);
  return 3711;
}

uint64_t vision::mod::ImageDescriptorProcessorAbstract::computeDescriptorForImage_BGRA8888(vision::mod::ImageDescriptorProcessorAbstract *this, const vImage_Buffer *a2, vision::mod::ImageDescriptorBufferAbstract *a3)
{
  syslog(5, "ERROR: This descriptor processor does not know how to handle BGRA8888 images", a3);
  return 3711;
}

uint64_t vision::mod::ImageDescriptorProcessorAbstract::computeDescriptorForImage_Planar8(vision::mod::ImageDescriptorProcessorAbstract *this, const vImage_Buffer *a2, vision::mod::ImageDescriptorBufferAbstract *a3)
{
  syslog(5, "ERROR: This descriptor processor does not know how to handle Planar8 images", a3);
  return 3711;
}

uint64_t vision::mod::ColorGaborImageDescriptorProcessor::computeDescriptorForImage(vision::mod::ColorGaborImageDescriptorProcessor *this, __CVBuffer *a2, vision::mod::ImageDescriptorBufferAbstract *a3)
{
  void *v6;
  const std::nothrow_t *v7;
  _OWORD *v8;
  char *v9;
  DSPSplitComplex *v10;
  char **v11;
  _QWORD *v12;
  DSPSplitComplex v13;
  NSObject *v14;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  NSObject *v18;
  DSPSplitComplex *v19;
  float *imagp;
  uint64_t imagp_low;
  size_t v22;
  float *realp;
  uint64_t v24;
  size_t v25;
  float *v26;
  uint64_t v27;
  size_t v28;
  float *v29;
  uint64_t v30;
  size_t v31;
  float *v32;
  uint64_t v33;
  size_t v34;
  float *v35;
  uint64_t v36;
  size_t v37;
  float *v38;
  uint64_t v39;
  size_t v40;
  float *v41;
  uint64_t v42;
  size_t v43;
  void *v44;
  float *v45;
  char *v46;
  float *v47;
  uint64_t v48;
  size_t v49;
  int v50;
  int v51;
  int32x4_t v52;
  __int128 v57;
  __int128 v58;
  int32x2_t v59;
  int32x4_t v60;
  float *v61;
  int32x4_t v62;
  int32x4_t v63;
  __int128 v64;
  float *v65;
  int imagp_high;
  int v67;
  int v68;
  int v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  int v73;
  int v74;
  uint64_t v75;
  int v76;
  float *v77;
  float *v78;
  DSPSplitComplex *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  float *v87;
  float *v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  int v97;
  int v98;
  int v99;
  int v100;
  int v101;
  float *v102;
  uint64_t v103;
  int v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  int *v109;
  uint64_t v110;
  int v111;
  int v112;
  NSObject *v113;
  size_t Width;
  size_t Height;
  float v116;
  float v117;
  _OWORD *v118;
  float *v119;
  vision::mod::ColorGaborImageDescriptorProcessor *v120;
  void *v121;
  uint64_t *v122;
  OSStatus v123;
  unsigned int v124;
  unsigned int v125;
  int v126;
  unsigned __int8 *BaseAddressOfPlane;
  int v128;
  OpaqueFFTSetup *fftsetup;
  NSObject *v130;
  uint64_t v131;
  size_t v132;
  size_t v133;
  void *v134;
  void *v135;
  int v136;
  int v137;
  int v138;
  signed int v139;
  uint64_t v140;
  float v141;
  int realp_high;
  float *v143;
  int v144;
  int v145;
  float *v146;
  uint64_t i;
  signed int v148;
  int v149;
  float v150;
  float v151;
  float *v152;
  float v153;
  int v154;
  float *v155;
  float *v156;
  float *v157;
  uint64_t v158;
  float v159;
  float v160;
  uint64_t v161;
  float *v162;
  float *v163;
  float *v164;
  float v165;
  float v166;
  uint64_t v167;
  float32x4_t *v168;
  float *v169;
  float32x4_t v170;
  float32x4_t v171;
  float32x4_t v172;
  float *v173;
  __int128 v174;
  __int128 v175;
  __int128 v176;
  __n128 v177;
  size_t v178;
  size_t v179;
  __CVBuffer *v180;
  float *v181;
  float *v182;
  float *v183;
  int v184;
  int v185;
  int BytesPerRow;
  char *BaseAddress;
  float v188;
  int v189;
  int v190;
  int v191;
  int v192;
  uint64_t v193;
  int v194;
  int v195;
  char *v196;
  int v197;
  uint64_t v198;
  int v199;
  float *v200;
  float *v201;
  float *v202;
  uint64_t v203;
  char *v204;
  float v205;
  float v206;
  float v207;
  float v208;
  float v209;
  float v210;
  float v211;
  float v212;
  float v213;
  float v214;
  float v215;
  float v216;
  float v217;
  float v218;
  float v219;
  int v220;
  float v221;
  float v224;
  uint64_t v225;
  uint64_t v226;
  float v227;
  int v228;
  float *v229;
  float *v230;
  float *v231;
  uint64_t v232;
  float *v233;
  size_t v234;
  uint64_t v235;
  uint64_t v237;
  float *v238;
  float *v239;
  float *v240;
  float v241;
  DSPSplitComplex *v242;
  DSPSplitComplex *__C;
  void *v244;
  vision::mod::ColorGaborImageDescriptorProcessor *v245;
  __CVBuffer *pixelBuffer;
  float *v247;
  _OWORD *v248;
  DSPSplitComplex *__A;
  float *v250;
  __int128 v251;
  float *v252;
  int32x4_t v253;
  int32x4_t v254;
  __int128 v255;
  __int128 v256;
  float *v257;
  float *v258;
  float *v259;
  CVPixelBufferRef pixelBufferOut;
  VTPixelTransferSessionRef pixelTransferSessionOut;
  DSPSplitComplex *context;
  int v263;
  int v264;
  DSPSplitComplex *v265;
  int v266;
  int v267;
  DSPSplitComplex *v268;
  int v269;
  int v270;
  DSPSplitComplex *v271;
  int v272;
  int v273;
  uint64_t v274;

  v274 = *MEMORY[0x1E0C80C00];
  vision::mod::ImageDescriptorBufferAbstract::resizeForDescriptorsCount(a3, 1uLL, 0);
  v6 = (void *)*((_QWORD *)a3 + 7);
  v257 = 0;
  v258 = 0;
  v259 = 0;
  v7 = (const std::nothrow_t *)MEMORY[0x1E0DE4E10];
  v8 = operator new[](0x88uLL, MEMORY[0x1E0DE4E10]);
  v9 = (char *)operator new(0xD8uLL, v7);
  if (v9)
  {
    v10 = (DSPSplitComplex *)v9;
    *((_OWORD *)v9 + 3) = 0u;
    *((_OWORD *)v9 + 6) = 0u;
    v11 = (char **)(v9 + 96);
    *((_QWORD *)v9 + 17) = 0;
    v12 = v9 + 136;
    *(_OWORD *)v9 = 0u;
    *((_OWORD *)v9 + 1) = 0u;
    *((_OWORD *)v9 + 4) = 0u;
    *((_QWORD *)v9 + 10) = 0;
    *((_OWORD *)v9 + 7) = 0u;
    *((_QWORD *)v9 + 18) = 0;
    *((_QWORD *)v9 + 19) = 0;
    *((_DWORD *)v9 + 22) = -1;
    *((_QWORD *)v9 + 16) = 0;
    *((_QWORD *)v9 + 4) = 0;
    *((_DWORD *)v9 + 10) = 0;
    *((_WORD *)v9 + 80) = 0;
    *(_OWORD *)(v9 + 200) = 0u;
    *(_OWORD *)(v9 + 184) = 0u;
    *(_OWORD *)(v9 + 168) = 0u;
    if (!v8)
    {
      v123 = -108;
      goto LABEL_248;
    }
    __C = (DSPSplitComplex *)(v9 + 48);
    v244 = v6;
    v245 = this;
    v9[161] = 1;
    v248 = v8;
    __A = (DSPSplitComplex *)v9;
    ma::GaborFilters::Destroy((ma::GaborFilters *)v9);
    LOBYTE(__A[10].realp) = 1;
    v13.realp = (float *)0x8000000080;
    v13.imagp = (float *)0x8000000080;
    __A[1] = v13;
    LODWORD(__A[2].imagp) = 7;
    __A[2].realp = (float *)0x700000007;
    LODWORD(__A[5].imagp) = 0x4000;
    v14 = MEMORY[0x1E0C80D50];
    v15 = dispatch_queue_attr_make_with_autorelease_frequency(MEMORY[0x1E0C80D50], DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    __A[10].imagp = (float *)dispatch_queue_create("com.apple.VN.createGaborFilterBankGCDQueueName", v15);
    v16 = dispatch_queue_attr_make_with_autorelease_frequency(v14, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    __A[11].realp = (float *)dispatch_queue_create("com.apple.VN.extractGaborDescriptorGCDQueueName", v16);
    v17 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    __A[11].imagp = (float *)dispatch_queue_create("com.apple.VN.gaborReadySyncQueueName", v17);
    v18 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    __A[12].realp = (float *)dispatch_queue_create("com.apple.VN.gaborDescriptorReadySyncQueueName", v18);
    v19 = __A;
    __A[5].realp = (float *)vDSP_create_fftsetup(SLODWORD(__A[2].realp), 0);
    imagp = __A[3].imagp;
    if (!imagp)
    {
      imagp_low = SLODWORD(__A[5].imagp);
      if ((int)imagp_low < 0)
        v22 = -1;
      else
        v22 = 4 * imagp_low;
      imagp = (float *)operator new[](v22, MEMORY[0x1E0DE4E10]);
      __A[3].imagp = imagp;
    }
    v252 = imagp;
    realp = __A[4].realp;
    v242 = __A + 4;
    if (!realp)
    {
      v24 = SLODWORD(__A[5].imagp);
      if ((int)v24 < 0)
        v25 = -1;
      else
        v25 = 4 * v24;
      realp = (float *)operator new[](v25, MEMORY[0x1E0DE4E10]);
      __A[4].realp = realp;
    }
    v250 = realp;
    v26 = __A[4].imagp;
    if (!v26)
    {
      v27 = SLODWORD(__A[5].imagp);
      if ((int)v27 < 0)
        v28 = -1;
      else
        v28 = 4 * v27;
      v26 = (float *)operator new[](v28, MEMORY[0x1E0DE4E10]);
      __A[4].imagp = v26;
    }
    v29 = __A[6].imagp;
    if (!v29)
    {
      v30 = SLODWORD(__A[5].imagp);
      if ((int)v30 < 0)
        v31 = -1;
      else
        v31 = 4 * v30;
      v29 = (float *)operator new[](v31, MEMORY[0x1E0DE4E10]);
      __A[6].imagp = v29;
    }
    v247 = v29;
    v32 = __A[7].imagp;
    if (!v32)
    {
      v33 = SLODWORD(__A[5].imagp);
      if ((int)v33 < 0)
        v34 = -1;
      else
        v34 = 4 * v33;
      v32 = (float *)operator new[](v34, MEMORY[0x1E0DE4E10]);
      __A[7].imagp = v32;
    }
    pixelBuffer = a2;
    v35 = __A[7].realp;
    if (!v35)
    {
      v36 = SLODWORD(__A[5].imagp);
      if ((int)v36 < 0)
        v37 = -1;
      else
        v37 = 4 * v36;
      v35 = (float *)operator new[](v37, MEMORY[0x1E0DE4E10]);
      __A[7].realp = v35;
    }
    v38 = __A->realp;
    if (!__A->realp)
    {
      v39 = SLODWORD(__A[5].imagp);
      if ((int)v39 < 0)
        v40 = -1;
      else
        v40 = 4 * v39;
      v38 = (float *)operator new[](v40, MEMORY[0x1E0DE4E10]);
      __A->realp = v38;
    }
    v41 = __A->imagp;
    if (!v41)
    {
      v42 = SLODWORD(__A[5].imagp);
      if ((int)v42 < 0)
        v43 = -1;
      else
        v43 = 4 * v42;
      v41 = (float *)operator new[](v43, MEMORY[0x1E0DE4E10]);
      __A->imagp = v41;
    }
    __A[8].realp = (float *)0x800000004;
    v44 = __A[8].imagp;
    if (!v44)
    {
      v44 = operator new[](0x80uLL, MEMORY[0x1E0DE4E10]);
      *v12 = v44;
    }
    v45 = __A[9].realp;
    if (!v45)
    {
      v45 = (float *)operator new[](0x40uLL, MEMORY[0x1E0DE4E10]);
      __A[9].realp = v45;
    }
    v46 = *v11;
    if (!*v11)
    {
      v46 = (char *)operator new[](0x200uLL, MEMORY[0x1E0DE4E10]);
      *v11 = v46;
    }
    v47 = __A[9].imagp;
    if (!v47)
    {
      v48 = SLODWORD(__A[5].imagp);
      if ((int)v48 < 0)
        v49 = -1;
      else
        v49 = v48 << 7;
      v47 = (float *)operator new[](v49, MEMORY[0x1E0DE4E10]);
      __A[9].imagp = v47;
    }
    if (!v252 || !v250 || !v26 || !v32 || !v35 || !v38 || !v41 || !v44 || !v45 || !v247 || !v46 || !v47)
    {
      ma::GaborFilters::Destroy((ma::GaborFilters *)__A);
      v118 = v248;
      v10 = __A;
      LOBYTE(__A[10].realp) = 0;
      goto LABEL_104;
    }
    v50 = 0;
    v51 = 0;
    v52 = vdupq_n_s32(0x3EB33333u);
    __asm { FMOV            V2.4S, #1.0 }
    v57 = xmmword_1A15FB580;
    v58 = xmmword_1A15FB590;
    do
    {
      v251 = v58;
      v253 = v52;
      v255 = _Q2;
      v256 = v57;
      *(float *)v59.i32 = 0.2 / powf(1.85, (float)v50);
      v254 = vdupq_lane_s32(v59, 0);
      v58 = v251;
      v52 = v253;
      v60 = v254;
      _Q2 = v255;
      v57 = v256;
      v61 = (float *)&v46[4 * v51];
      v62 = v253;
      v63 = v254;
      v64 = v255;
      vst4q_f32(v61, *(float32x4x4_t *)(&v58 - 3));
      v65 = (float *)&v46[4 * v51 + 64];
      vst4q_f32(v65, *(float32x4x4_t *)v52.i8);
      v51 += 32;
      ++v50;
    }
    while (v50 != 4);
    bzero(v41, 4 * SLODWORD(__A[5].imagp));
    LOBYTE(__A[10].realp) = 1;
    v67 = (int)__A[1].imagp;
    imagp_high = HIDWORD(__A[1].imagp);
    if (v67 >= 0)
      v68 = (int)__A[1].imagp;
    else
      v68 = v67 + 1;
    if (imagp_high >= 0)
      v69 = HIDWORD(__A[1].imagp);
    else
      v69 = imagp_high + 1;
    if (imagp_high >= 2)
    {
      v70 = 0;
      v71 = (v68 >> 1);
      v72 = (v69 >> 1);
      v73 = -(v69 >> 1);
      v74 = v73;
      do
      {
        if (v67 >= 2)
        {
          v75 = v70;
          v76 = -(int)v71;
          v79 = v19 + 7;
          v77 = v19[7].realp;
          v78 = v79->imagp;
          do
          {
            v78[v75] = sqrtf((float)(v74 * v74 + v76 * v76));
            v77[v75++] = atan2f((float)v74, (float)v76++);
          }
          while (v76 < (int)v71);
          v70 = v75;
          v19 = __A;
        }
        ++v74;
      }
      while (v74 < (int)v72);
      v80 = 0;
      v81 = 0;
      v82 = 4 * v67 * (uint64_t)(int)v72;
      v83 = 4 * v67;
      v84 = 4 * ((int)v71 + v67 * (uint64_t)(int)v72);
      v85 = 4 * (int)v71;
      do
      {
        if (v67 >= 2)
        {
          v86 = 0;
          v87 = v19[7].realp;
          v88 = v19[7].imagp;
          v89 = (uint64_t)v87 + v82;
          v90 = (uint64_t)v88 + v82;
          v91 = (uint64_t)v87 + v84;
          v92 = (uint64_t)v88 + v84;
          v93 = (uint64_t)v87 + v80;
          v94 = (uint64_t)v87 + v85;
          v95 = (uint64_t)v88 + v85;
          v96 = (uint64_t)v88 + v80;
          do
          {
            v97 = *(_DWORD *)(v96 + 4 * v86);
            *(_DWORD *)(v96 + 4 * v86) = *(_DWORD *)(v92 + 4 * v86);
            *(_DWORD *)(v92 + 4 * v86) = v97;
            v98 = *(_DWORD *)(v90 + 4 * v86);
            *(_DWORD *)(v90 + 4 * v86) = *(_DWORD *)(v95 + 4 * v86);
            *(_DWORD *)(v95 + 4 * v86) = v98;
            v99 = *(_DWORD *)(v93 + 4 * v86);
            *(_DWORD *)(v93 + 4 * v86) = *(_DWORD *)(v91 + 4 * v86);
            *(_DWORD *)(v91 + 4 * v86) = v99;
            v100 = *(_DWORD *)(v89 + 4 * v86);
            *(_DWORD *)(v89 + 4 * v86) = *(_DWORD *)(v94 + 4 * v86);
            *(_DWORD *)(v94 + 4 * v86++) = v100;
          }
          while (v71 != v86);
        }
        ++v81;
        v82 += v83;
        v84 += v83;
        v80 += v83;
        v85 += v83;
      }
      while (v81 != v72);
      v101 = 0;
      do
      {
        if (v67 >= 2)
        {
          v102 = v19->realp;
          v103 = v101;
          v104 = -(int)v71;
          do
          {
            v102[v103++] = expf((float)(v73 * v73 + v104 * v104) * -0.043322);
            ++v104;
          }
          while (v104 < (int)v71);
          v101 = v103;
          v19 = __A;
        }
        ++v73;
      }
      while (v73 < (int)v72);
      v105 = 0;
      v106 = 0;
      v107 = v67 * (uint64_t)(int)v72;
      v108 = (int)v71 + v107;
      do
      {
        if (v67 >= 2)
        {
          v109 = (int *)((char *)v19->realp + v105);
          v110 = v71;
          do
          {
            v111 = *v109;
            *v109 = v109[v108];
            v109[v108] = v111;
            v112 = v109[v107];
            v109[v107] = v109[(int)v71];
            v109[(int)v71] = v112;
            ++v109;
            --v110;
          }
          while (v110);
        }
        ++v106;
        v105 += v83;
      }
      while (v106 != v72);
    }
    v113 = dispatch_group_create();
    context = v19;
    v263 = v67;
    v264 = 0;
    v265 = v19;
    v266 = v67;
    v267 = 1;
    v268 = v19;
    v269 = v67;
    v270 = 2;
    v271 = v19;
    v272 = v67;
    v273 = 3;
    dispatch_group_async_f(v113, (dispatch_queue_t)v19[10].imagp, &context, (dispatch_function_t)ma::GaborFilters::DispatchHelperCreateGabor);
    dispatch_group_async_f(v113, (dispatch_queue_t)v19[10].imagp, &v265, (dispatch_function_t)ma::GaborFilters::DispatchHelperCreateGabor);
    dispatch_group_async_f(v113, (dispatch_queue_t)v19[10].imagp, &v268, (dispatch_function_t)ma::GaborFilters::DispatchHelperCreateGabor);
    dispatch_group_async_f(v113, (dispatch_queue_t)v19[10].imagp, &v271, (dispatch_function_t)ma::GaborFilters::DispatchHelperCreateGabor);
    dispatch_group_wait(v113, 0xFFFFFFFFFFFFFFFFLL);
    dispatch_release(v113);
    pixelTransferSessionOut = 0;
    pixelBufferOut = 0;
    Width = CVPixelBufferGetWidth(pixelBuffer);
    Height = CVPixelBufferGetHeight(pixelBuffer);
    v116 = (float)Width;
    v117 = (float)Height;
    if (fminf((float)Width, (float)Height) < 16.0)
    {
      v118 = v248;
      v10 = __A;
      v119 = __A[9].realp;
      *((_OWORD *)v119 + 2) = 0u;
      *((_OWORD *)v119 + 3) = 0u;
      *(_OWORD *)v119 = 0u;
      *((_OWORD *)v119 + 1) = 0u;
      v121 = v244;
      v120 = v245;
LABEL_150:
      if (!BYTE1(v10[10].realp))
      {
        v123 = -50;
        goto LABEL_247;
      }
      v173 = v10[9].realp;
      v174 = *((_OWORD *)v173 + 3);
      v176 = *(_OWORD *)v173;
      v175 = *((_OWORD *)v173 + 1);
      v118[2] = *((_OWORD *)v173 + 2);
      v118[3] = v174;
      *v118 = v176;
      v118[1] = v175;
      if (v257)
      {
LABEL_152:
        pixelTransferSessionOut = 0;
        context = 0;
        v123 = VTPixelTransferSessionCreate(0, (VTPixelTransferSessionRef *)&context);
        if (!v123)
        {
          v178 = CVPixelBufferGetWidth(pixelBuffer);
          v179 = CVPixelBufferGetHeight(pixelBuffer);
          v123 = CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v178, v179, 0x20u, 0, &pixelTransferSessionOut);
          v180 = pixelTransferSessionOut;
          if (!v123)
          {
            v123 = VTPixelTransferSessionTransferImage((VTPixelTransferSessionRef)context, pixelBuffer, pixelTransferSessionOut);
            v180 = pixelTransferSessionOut;
            if (!v123)
            {
              if (CVPixelBufferGetPixelFormatType(pixelTransferSessionOut) == 32
                && (v181 = v257) != 0
                && (v182 = v258) != 0
                && (v183 = v259) != 0)
              {
                *((_OWORD *)v257 + 7) = 0u;
                *((_OWORD *)v181 + 8) = 0u;
                *((_OWORD *)v181 + 5) = 0u;
                *((_OWORD *)v181 + 6) = 0u;
                *((_OWORD *)v181 + 3) = 0u;
                *((_OWORD *)v181 + 4) = 0u;
                *((_OWORD *)v181 + 1) = 0u;
                *((_OWORD *)v181 + 2) = 0u;
                *(_OWORD *)v181 = 0u;
                *((_OWORD *)v182 + 7) = 0u;
                *((_OWORD *)v182 + 8) = 0u;
                *((_OWORD *)v182 + 5) = 0u;
                *((_OWORD *)v182 + 6) = 0u;
                *((_OWORD *)v182 + 3) = 0u;
                *((_OWORD *)v182 + 4) = 0u;
                *((_OWORD *)v182 + 1) = 0u;
                *((_OWORD *)v182 + 2) = 0u;
                *(_OWORD *)v182 = 0u;
                *((_OWORD *)v183 + 7) = 0u;
                *((_OWORD *)v183 + 8) = 0u;
                *((_OWORD *)v183 + 5) = 0u;
                *((_OWORD *)v183 + 6) = 0u;
                *((_OWORD *)v183 + 3) = 0u;
                *((_OWORD *)v183 + 4) = 0u;
                *((_OWORD *)v183 + 1) = 0u;
                *((_OWORD *)v183 + 2) = 0u;
                *(_OWORD *)v183 = 0u;
                CVPixelBufferLockBaseAddress(v180, 1uLL);
                v184 = CVPixelBufferGetWidth(v180);
                v185 = CVPixelBufferGetHeight(v180);
                BytesPerRow = CVPixelBufferGetBytesPerRow(v180);
                BaseAddress = (char *)CVPixelBufferGetBaseAddress(v180);
                if (v185 >= 0)
                  v189 = v185;
                else
                  v189 = v185 + 7;
                v190 = v189 >> 3;
                v191 = v185 - (v189 >> 3);
                if (v190 >= v191)
                {
                  v192 = 0;
                }
                else
                {
                  v192 = 0;
                  v193 = BytesPerRow;
                  if (v184 >= 0)
                    v194 = v184;
                  else
                    v194 = v184 + 7;
                  v195 = v194 >> 3;
                  v196 = &BaseAddress[BytesPerRow * (uint64_t)v190];
                  v197 = v184 - (v194 >> 3);
                  v198 = (uint64_t)v194 >> 3;
                  v199 = v184 - 2 * v195;
                  v200 = v257;
                  v201 = v258;
                  v202 = v259;
                  do
                  {
                    if ((int)v198 < v197)
                    {
                      v203 = v198;
                      do
                      {
                        v204 = &v196[4 * (int)v203];
                        LOBYTE(v188) = v204[1];
                        v205 = (float)LODWORD(v188);
                        LOBYTE(v188) = v204[2];
                        v206 = (float)LODWORD(v188);
                        LOBYTE(v188) = v204[3];
                        v207 = (float)LODWORD(v188);
                        if (v206 >= v205)
                          v208 = v205;
                        else
                          v208 = v206;
                        if (v208 > v207)
                          v208 = v207;
                        if (v205 >= v206)
                          v209 = v205;
                        else
                          v209 = v206;
                        if (v209 >= v207)
                          v210 = v209;
                        else
                          v210 = v207;
                        v211 = v210 - v208;
                        if (v211 == 0.0)
                          v212 = 0.1;
                        else
                          v212 = v211;
                        v213 = 0.0;
                        v214 = 0.0;
                        v215 = 0.0;
                        if (v210 > 0.0)
                        {
                          v214 = v212 / v210;
                          v216 = (float)((float)(v205 - v206) / v212) + 4.0;
                          if (v210 == v206)
                            v216 = (float)((float)(v207 - v205) / v212) + 2.0;
                          v217 = (float)(v206 - v207) / v212;
                          if (v210 == v205)
                            v218 = v217;
                          else
                            v218 = v216;
                          v219 = v218 / 6.0;
                          v215 = v219 + 1.0;
                          if (v219 >= 0.0)
                            v215 = v219;
                          v213 = v210;
                        }
                        v220 = 0;
                        v221 = v213 / 255.0;
                        if ((float)(v213 / 255.0) >= 0.2 && v214 <= 0.1 && v221 < 0.8)
                          v220 = (int)(float)(floorf((float)(v221 + -0.2) * 10.0) + 1.0);
                        if (v221 >= 0.8 && v214 < 0.1 && v221 <= 1.0)
                          v220 = 7;
                        if (v221 <= 1.0 && v221 >= 0.2 && v214 >= 0.1 && v214 <= 1.0)
                        {
                          v224 = v215 * 360.0;
                          if (v224 > 22.0)
                          {
                            v225 = 0;
                            while (v225 != 6)
                            {
                              v226 = v225 + 1;
                              v227 = (float)ma::HSVHistogram::GenerateHistogramsRgbSpace(__CVBuffer *)::kPivots[++v225];
                              if (v224 <= v227)
                              {
                                if ((unint64_t)(v226 - 1) >= 6)
                                  LODWORD(v226) = v226 - 7;
                                goto LABEL_215;
                              }
                            }
                          }
                          LODWORD(v226) = 0;
LABEL_215:
                          if (v221 < 0.7)
                            v228 = 8;
                          else
                            v228 = 9;
                          v220 = (v228 | (2 * (v214 >= 0.65))) + 4 * v226;
                          v10 = __A;
                        }
                        v200[v220] = v200[v220] + 1.0;
                        v201[v220] = v201[v220] + (float)(int)v203;
                        v188 = v202[v220] + (float)v190;
                        v202[v220] = v188;
                        ++v203;
                      }
                      while (v203 != v197);
                      v192 += v199;
                    }
                    v196 += v193;
                    ++v190;
                  }
                  while (v190 != v191);
                }
                CVPixelBufferUnlockBaseAddress(v180, 1uLL);
                v237 = 0;
                v238 = v257;
                v239 = v258;
                v240 = v259;
                do
                {
                  if (v192 < 1)
                    v241 = 0.0;
                  else
                    v241 = v238[v237] / (float)v192;
                  v238[v237] = v241;
                  if (v192 * v184 < 1)
                  {
                    v239[v237] = 0.0;
                    v240[v237] = 0.0;
                  }
                  else
                  {
                    v239[v237] = v239[v237] / (float)((float)v184 * (float)v192);
                    v240[v237] = v240[v237] / (float)((float)v185 * (float)v192);
                  }
                  ++v237;
                }
                while (v237 != 36);
                v123 = 0;
              }
              else
              {
                v123 = -50;
              }
              v180 = pixelTransferSessionOut;
            }
          }
          if (v180)
          {
            CFRelease(v180);
            pixelTransferSessionOut = 0;
          }
        }
        if (context)
          CFRelease(context);
        if (!v123)
        {
          v232 = 0;
          v233 = v257;
          v177.n128_u32[0] = 1199570688;
          do
          {
            *((_WORD *)v118 + v232 + 32) = (int)(float)(v233[v232] * 65535.0);
            ++v232;
          }
          while (v232 != 36);
          v234 = (*(uint64_t (**)(vision::mod::ColorGaborImageDescriptorProcessor *, __n128))(*(_QWORD *)v120 + 128))(v120, v177);
          memcpy(v121, v118, v234);
          v123 = 0;
        }
        goto LABEL_247;
      }
      v229 = (float *)operator new[](0x90uLL, MEMORY[0x1E0DE4E10]);
      v257 = v229;
      v230 = v258;
      if (!v258)
      {
        v230 = (float *)operator new[](0x90uLL, MEMORY[0x1E0DE4E10]);
        v258 = v230;
      }
      v231 = v259;
      if (!v259)
      {
        v231 = (float *)operator new[](0x90uLL, MEMORY[0x1E0DE4E10]);
        v259 = v231;
      }
      if (v229)
      {
        if (v230 && v231)
          goto LABEL_152;
        MEMORY[0x1A1B0A880](v229, 0x1000C8052888210);
        v230 = v258;
      }
      v257 = 0;
      if (v230)
        MEMORY[0x1A1B0A880](v230, 0x1000C8052888210);
      v258 = 0;
      if (v259)
        MEMORY[0x1A1B0A880](v259, 0x1000C8052888210);
      v259 = 0;
LABEL_104:
      v123 = -108;
LABEL_247:
      MEMORY[0x1A1B0A880](v118, 0x1000C80BDFB0063);
LABEL_248:
      ma::GaborFilters::Destroy((ma::GaborFilters *)v10);
      MEMORY[0x1A1B0A898](v10, 0x10B0C406B6CA85BLL);
      v122 = &CVML_status_internalError;
      if (!v123)
        v122 = &CVML_status_ok;
      goto LABEL_250;
    }
    v124 = (vcvtps_s32_f32((float)(v117 * 128.0) / v116) + 1) & 0xFFFFFFFE;
    v125 = (vcvtps_s32_f32((float)(v116 * 128.0) / v117) + 1) & 0xFFFFFFFE;
    if (v116 <= v117)
    {
      v126 = 128;
    }
    else
    {
      v124 = 128;
      v126 = v125;
    }
    HIDWORD(__A[12].imagp) = v126;
    LODWORD(__A[13].realp) = v124;
    v123 = VTPixelTransferSessionCreate(0, &pixelTransferSessionOut);
    if (!v123)
    {
      if (CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], SHIDWORD(__A[12].imagp), SLODWORD(__A[13].realp), 0x34323076u, 0, &pixelBufferOut))
      {
LABEL_110:
        v123 = 3710;
        goto LABEL_145;
      }
      v123 = VTPixelTransferSessionTransferImage(pixelTransferSessionOut, pixelBuffer, pixelBufferOut);
      if (!v123)
      {
        HIDWORD(__A[13].realp) = CVPixelBufferGetBytesPerRowOfPlane(pixelBufferOut, 0);
        CVPixelBufferLockBaseAddress(pixelBufferOut, 1uLL);
        BaseAddressOfPlane = (unsigned __int8 *)CVPixelBufferGetBaseAddressOfPlane(pixelBufferOut, 0);
        if (!BaseAddressOfPlane)
          goto LABEL_110;
        v128 = (int)__A[1].imagp;
        fftsetup = vDSP_create_fftsetup(SLODWORD(__A[2].realp), 0);
        v130 = dispatch_group_create();
        context = __A;
        v263 = v128;
        v264 = 0;
        v265 = __A;
        v266 = v128;
        v267 = 1;
        v268 = __A;
        v269 = v128;
        v270 = 2;
        v272 = v128;
        v273 = 3;
        v131 = SLODWORD(__A[5].imagp);
        v132 = 4 * v131;
        if ((int)v131 < 0)
          v133 = -1;
        else
          v133 = 4 * v131;
        v271 = __A;
        v134 = operator new[](v133, MEMORY[0x1E0DE4E10]);
        v135 = v134;
        v136 = HIDWORD(__A[12].imagp) - 128;
        if (HIDWORD(__A[12].imagp) == 128)
        {
          v137 = (int)((double)(LODWORD(__A[13].realp) - 128) * 0.5);
        }
        else
        {
          v137 = 0;
          v136 = (int)((double)v136 * 0.5);
        }
        if (v134)
        {
          v138 = 0;
          v139 = 0;
          v140 = v131;
          v141 = 1.0 / (double)(int)v131;
          realp_high = HIDWORD(__A[13].realp);
          v143 = __A[6].imagp;
          v144 = v136 + v137 * realp_high;
          v145 = 255;
          v146 = v143;
          do
          {
            for (i = 0; i != 128; ++i)
            {
              v148 = BaseAddressOfPlane[v144 + i];
              if (v145 >= v148)
                v145 = BaseAddressOfPlane[v144 + i];
              if (v139 <= v148)
                v139 = BaseAddressOfPlane[v144 + i];
              v146[i] = (float)v148;
            }
            ++v138;
            v144 += realp_high;
            v146 += 128;
          }
          while (v138 != 128);
          v149 = v139 - v145;
          if (v149 < 1)
            v150 = 255.0;
          else
            v150 = 255.0 / (float)v149;
          if ((int)v140 >= 1)
          {
            v151 = (float)v145;
            v152 = v143;
            do
            {
              v153 = log((float)(v150 * (float)(*v152 - v151)) + 1.0);
              *v152++ = v153;
              --v140;
            }
            while (v140);
          }
          memcpy(v135, v143, v132);
          __A[3].realp = v143;
          bzero(__A[3].imagp, v132);
          vDSP_fft2d_zip((FFTSetup)__A[5].realp, __C, 1, 0, HIDWORD(__A[2].realp), LODWORD(__A[2].imagp), 1);
          vDSP_zvmul(__A, 1, __C, 1, v242, 1, SLODWORD(__A[5].imagp), 1);
          vDSP_fft2d_zip((FFTSetup)__A[5].realp, v242, 1, 0, HIDWORD(__A[2].realp), LODWORD(__A[2].imagp), -1);
          v154 = (int)__A[5].imagp;
          if (v154 >= 1)
          {
            v155 = __A[4].realp;
            v156 = __A[6].imagp;
            v157 = (float *)v135;
            v158 = LODWORD(__A[5].imagp);
            do
            {
              v159 = *v155++;
              v160 = *v157 + (float)((float)-v141 * v159);
              *v157++ = v160;
              *v156++ = v160 * v160;
              --v158;
            }
            while (v158);
          }
          bzero(__A[3].imagp, 4 * v154);
          vDSP_fft2d_zip((FFTSetup)__A[5].realp, __C, 1, 0, HIDWORD(__A[2].realp), LODWORD(__A[2].imagp), 1);
          vDSP_zvmul(__A, 1, __C, 1, v242, 1, SLODWORD(__A[5].imagp), 1);
          vDSP_fft2d_zip((FFTSetup)__A[5].realp, v242, 1, 0, HIDWORD(__A[2].realp), LODWORD(__A[2].imagp), -1);
          v161 = LODWORD(__A[5].imagp);
          if ((int)v161 >= 1)
          {
            v162 = __A[4].realp;
            v163 = __A[6].imagp;
            v164 = (float *)v135;
            do
            {
              v165 = sqrtf(fabsf(*v162 * v141));
              *v162++ = v165;
              v166 = *v164++;
              *v163++ = v166 / (float)(v165 + 0.2);
              --v161;
            }
            while (v161);
          }
          MEMORY[0x1A1B0A880](v135, 0x1000C8052888210);
          bzero(__A[3].imagp, 4 * SLODWORD(__A[5].imagp));
          vDSP_fft2d_zip(fftsetup, __C, 1, 0, HIDWORD(__A[2].realp), LODWORD(__A[2].imagp), 1);
          dispatch_group_async_f(v130, (dispatch_queue_t)__A[11].realp, &context, (dispatch_function_t)ma::GaborFilters::DispatchHelperDescriptor);
          dispatch_group_async_f(v130, (dispatch_queue_t)__A[11].realp, &v265, (dispatch_function_t)ma::GaborFilters::DispatchHelperDescriptor);
          dispatch_group_async_f(v130, (dispatch_queue_t)__A[11].realp, &v268, (dispatch_function_t)ma::GaborFilters::DispatchHelperDescriptor);
          dispatch_group_async_f(v130, (dispatch_queue_t)__A[11].realp, &v271, (dispatch_function_t)ma::GaborFilters::DispatchHelperDescriptor);
          dispatch_group_wait(v130, 0xFFFFFFFFFFFFFFFFLL);
          dispatch_release(v130);
          v167 = 0;
          v168 = (float32x4_t *)__A[8].imagp;
          v169 = __A[9].realp;
          v170 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
          do
          {
            v172 = *v168;
            v171 = v168[1];
            v168 += 2;
            *(int16x8_t *)&v169[v167] = vuzp1q_s16((int16x8_t)vcvtq_u32_f32(vmulq_f32(v172, v170)), (int16x8_t)vcvtq_u32_f32(vmulq_f32(v171, v170)));
            v167 += 4;
          }
          while (v167 != 16);
          v123 = 0;
        }
        else
        {
          v123 = -108;
        }
        vDSP_destroy_fftsetup(fftsetup);
        CVPixelBufferUnlockBaseAddress(pixelBufferOut, 1uLL);
      }
    }
LABEL_145:
    if (pixelBufferOut)
    {
      CFRelease(pixelBufferOut);
      pixelBufferOut = 0;
    }
    if (pixelTransferSessionOut)
      CFRelease(pixelTransferSessionOut);
    v118 = v248;
    v10 = __A;
    v121 = v244;
    v120 = v245;
    if (v123)
      goto LABEL_247;
    goto LABEL_150;
  }
  if (v8)
    MEMORY[0x1A1B0A880](v8, 0x1000C80BDFB0063);
  v122 = &CVML_status_internalError;
LABEL_250:
  v235 = *v122;
  ma::HSVHistogram::~HSVHistogram((ma::HSVHistogram *)&v257);
  return (v235 + 128) | 0xE00;
}

void sub_1A14A9A58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
  ma::HSVHistogram::~HSVHistogram((ma::HSVHistogram *)&a34);
  _Unwind_Resume(a1);
}

_QWORD *vision::mod::ColorGaborImageDescriptorProcessor::createDescriptorBuffer@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v3;
  _QWORD *result;

  v3 = operator new(0x78uLL);
  v3[1] = 0;
  v3[2] = 0;
  *v3 = &off_1E453BA38;
  v3[4] = 0;
  v3[5] = 0;
  v3[9] = 0;
  v3[8] = 0;
  v3[6] = 0;
  v3[7] = v3 + 8;
  *((_OWORD *)v3 + 5) = 0u;
  *((_OWORD *)v3 + 6) = 0u;
  *((_BYTE *)v3 + 112) = 0;
  a1[1] = v3;
  v3[3] = &off_1E453ABB0;
  result = v3 + 3;
  *a1 = result;
  return result;
}

uint64_t vision::mod::ImageDescriptorProcessorAbstract::computeDescriptorsForImages_RGBA8888(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  uint64_t v14;
  std::__shared_weak_count *v15;

  v4 = *a2;
  v5 = a2[1];
  if (*a2 == v5)
    return 3712;
  while (!a3 || ((*(uint64_t (**)(uint64_t))(a3 + 16))(a3) & 1) == 0)
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(_QWORD *)a1 + 64))(&v14, a1);
    v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 16))(a1, v4, v14);
    if ((v9 & 0x80) != 0)
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a4 + 40))(a4, v14);
    v10 = v15;
    if (v15)
    {
      p_shared_owners = (unint64_t *)&v15->__shared_owners_;
      do
        v12 = __ldaxr(p_shared_owners);
      while (__stlxr(v12 - 1, p_shared_owners));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    if ((v9 & 0x80) != 0)
    {
      v4 += 32;
      if (v4 != v5)
        continue;
    }
    return v9;
  }
  return 3683;
}

void sub_1A14A9BF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::ImageDescriptorProcessorAbstract::computeDescriptorsForImages_BGRA8888(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  uint64_t v14;
  std::__shared_weak_count *v15;

  v4 = *a2;
  v5 = a2[1];
  if (*a2 == v5)
    return 3712;
  while (!a3 || ((*(uint64_t (**)(uint64_t))(a3 + 16))(a3) & 1) == 0)
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(_QWORD *)a1 + 64))(&v14, a1);
    v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 24))(a1, v4, v14);
    if ((v9 & 0x80) != 0)
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a4 + 40))(a4, v14);
    v10 = v15;
    if (v15)
    {
      p_shared_owners = (unint64_t *)&v15->__shared_owners_;
      do
        v12 = __ldaxr(p_shared_owners);
      while (__stlxr(v12 - 1, p_shared_owners));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    if ((v9 & 0x80) != 0)
    {
      v4 += 32;
      if (v4 != v5)
        continue;
    }
    return v9;
  }
  return 3683;
}

void sub_1A14A9D10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::ImageDescriptorProcessorAbstract::computeDescriptorsForImages_Planar8(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  uint64_t v14;
  std::__shared_weak_count *v15;

  v4 = *a2;
  v5 = a2[1];
  if (*a2 == v5)
    return 3712;
  while (!a3 || ((*(uint64_t (**)(uint64_t))(a3 + 16))(a3) & 1) == 0)
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(_QWORD *)a1 + 64))(&v14, a1);
    v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 32))(a1, v4, v14);
    if ((v9 & 0x80) != 0)
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a4 + 40))(a4, v14);
    v10 = v15;
    if (v15)
    {
      p_shared_owners = (unint64_t *)&v15->__shared_owners_;
      do
        v12 = __ldaxr(p_shared_owners);
      while (__stlxr(v12 - 1, p_shared_owners));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    if ((v9 & 0x80) != 0)
    {
      v4 += 32;
      if (v4 != v5)
        continue;
    }
    return v9;
  }
  return 3683;
}

void sub_1A14A9E2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::ImageDescriptorProcessorAbstract::wipeLayersMemory(vision::mod::ImageDescriptorProcessorAbstract *this)
{
  syslog(5, "ERROR: Not implemented for this class");
  return 3711;
}

uint64_t vision::mod::ImageDescriptorProcessorAbstract::setPriority(vision::mod::ImageDescriptorProcessorAbstract *this)
{
  syslog(5, "Not implemented for this class");
  return 3711;
}

uint64_t vision::mod::ColorGaborImageDescriptorProcessor::getDescriptorLengthInBytes(vision::mod::ColorGaborImageDescriptorProcessor *this)
{
  return 136;
}

uint64_t vision::mod::ImageDescriptorProcessorAbstract::getRequiredImageChannelDepth(vision::mod::ImageDescriptorProcessorAbstract *this)
{
  return 0;
}

float vision::mod::ImageDescriptorProcessorAbstract::getRequiredImageSize(vision::mod::ImageDescriptorProcessorAbstract *this)
{
  return NAN;
}

void std::__shared_ptr_emplace<vision::mod::ColorGaborImageDescriptorBuffer>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453BA38;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<vision::mod::ColorGaborImageDescriptorBuffer>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453BA38;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A1B0A898);
}

uint64_t std::__shared_ptr_emplace<vision::mod::ColorGaborImageDescriptorBuffer>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void sub_1A14A9FE0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14AA090(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14AA110(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14AA298(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14AA428(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14AA4FC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14AA6BC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14AA800(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1A14AA88C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14AA9FC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14AAE40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  va_list va;

  va_start(va, a14);

  std::__optional_destruct_base<std::tuple<std::unordered_map<NSString * {__strong},__CVBuffer *>,std::unordered_map<NSString * {__strong},espresso_buffer_t>>,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A14ABA14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,void *a25,void *a26,void *a27,void *a28,void *a29,void *a30,void *a31,uint64_t a32,uint64_t a33,void *a34,void *a35,void *a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,id a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  id a71;
  void *v71;
  void *v72;
  uint64_t v73;

  std::__hash_table<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>>>::~__hash_table((uint64_t)&a37);

  _Block_object_dispose(&STACK[0x258], 8);
  _Block_object_dispose(&STACK[0x330], 8);

  _Block_object_dispose(&STACK[0x360], 8);
  _Block_object_dispose(&STACK[0x398], 8);
  std::deque<-[VNPersonSegmentationGeneratorLearnedMattingTiled _processTiledImageBuffer:inputMaskObservation:options:qosClass:error:]::OutputTileData>::~deque[abi:ne180100](a11);

  _Block_object_dispose(&STACK[0x450], 8);
  _Block_object_dispose(&STACK[0x480], 8);

  _Block_object_dispose(&STACK[0x4B0], 8);
  _Block_object_dispose(&STACK[0x5B0], 8);
  _Block_object_dispose(&STACK[0x5D0], 8);
  _Block_object_dispose((const void *)(v73 - 256), 8);

  _Unwind_Resume(a1);
}

void sub_1A14AC02C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__17281(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__17282(uint64_t a1)
{

}

double __Block_byref_object_copy__35(_QWORD *a1, _QWORD *a2)
{
  double result;

  a1[6] = a2[6];
  a1[7] = a2[7];
  a1[8] = a2[8];
  a1[9] = a2[9];
  result = 0.0;
  *((_OWORD *)a2 + 3) = 0u;
  *((_OWORD *)a2 + 4) = 0u;
  a1[10] = a2[10];
  a1[11] = a2[11];
  a2[10] = 0;
  a2[11] = 0;
  return result;
}

uint64_t __Block_byref_object_dispose__36(uint64_t a1)
{
  return std::deque<-[VNPersonSegmentationGeneratorLearnedMattingTiled _processTiledImageBuffer:inputMaskObservation:options:qosClass:error:]::OutputTileData>::~deque[abi:ne180100](a1 + 48);
}

uint64_t __Block_byref_object_copy__37_17284(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 48) = *(_DWORD *)(a2 + 48);
  return result;
}

void sub_1A14AC538(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14AC7B8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A14ACA68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  void *v27;
  uint64_t v28;

  _Block_object_dispose(&a27, 8);
  _Block_object_dispose((const void *)(v28 - 160), 8);

  _Unwind_Resume(a1);
}

void sub_1A14AD37C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, void *a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35)
{
  void *v35;
  uint64_t v36;

  operator delete(__p);
  operator delete(v35);

  _Block_object_dispose(&a29, 8);
  std::__hash_table<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>>>::~__hash_table((uint64_t)&a35);
  _Block_object_dispose((const void *)(v36 - 120), 8);

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__55(uint64_t a1, uint64_t a2)
{
  return std::__hash_table<std::__hash_value_type<NSString * {__strong},__CVBuffer *>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},__CVBuffer *>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},__CVBuffer *>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},__CVBuffer *>>>::__hash_table(a1 + 48, (uint64_t *)(a2 + 48));
}

uint64_t __Block_byref_object_dispose__56(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>>>::~__hash_table(a1 + 48);
}

void sub_1A14AD54C(void *a1)
{
  objc_begin_catch(a1);
  JUMPOUT(0x1A14AD4F0);
}

void sub_1A14AD568()
{
  int v0;

  if (v0)
    JUMPOUT(0x1A14AD570);
  JUMPOUT(0x1A14AD574);
}

void sub_1A14AD5D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A14AD63C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A14ADBA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, _QWORD *a16, uint64_t a17, uint64_t a18, _QWORD *a19)
{
  void *v19;
  void *v20;

  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(a16);
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(a19);

  _Unwind_Resume(a1);
}

void sub_1A14ADEC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, _QWORD *a11)
{
  void *v11;

  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(a11);

  _Unwind_Resume(a1);
}

void sub_1A14ADF78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<float,MPClusteringTreeNode *>,std::__map_value_compare<float,std::__value_type<float,MPClusteringTreeNode *>,std::less<float>,true>,std::allocator<std::__value_type<float,MPClusteringTreeNode *>>>::__emplace_multi<std::pair<float,MPClusteringTreeNode *>>(uint64_t **a1, uint64_t a2, float a3)
{
  uint64_t *v6;
  uint64_t *v7;
  uint64_t **v8;
  uint64_t **v9;
  uint64_t **v10;
  uint64_t *v11;
  uint64_t *result;

  v6 = (uint64_t *)operator new(0x30uLL);
  v7 = v6;
  *((float *)v6 + 8) = a3;
  v6[5] = a2;
  v8 = a1 + 1;
  v9 = (uint64_t **)a1[1];
  if (v9)
  {
    do
    {
      while (1)
      {
        v8 = v9;
        if (*((float *)v9 + 8) <= a3)
          break;
        v9 = (uint64_t **)*v9;
        v10 = v8;
        if (!*v8)
          goto LABEL_8;
      }
      v9 = (uint64_t **)v9[1];
    }
    while (v9);
    v10 = v8 + 1;
  }
  else
  {
    v10 = a1 + 1;
  }
LABEL_8:
  *v6 = 0;
  v6[1] = 0;
  v6[2] = (uint64_t)v8;
  *v10 = v6;
  v11 = (uint64_t *)**a1;
  if (v11)
  {
    *a1 = v11;
    v7 = *v10;
  }
  result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v7);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *std::__tree<std::__value_type<int,MPClusteringTreeNode *>,std::__map_value_compare<int,std::__value_type<int,MPClusteringTreeNode *>,std::less<int>,true>,std::allocator<std::__value_type<int,MPClusteringTreeNode *>>>::__emplace_unique_key_args<int,std::pair<int,MPClusteringTreeNode *>>(uint64_t *result, int a2, int a3, uint64_t a4)
{
  uint64_t *v6;
  uint64_t v7;
  uint64_t **v8;
  _QWORD *v9;
  int v10;
  _DWORD *v11;
  uint64_t v12;
  uint64_t *v13;

  v6 = result;
  v8 = (uint64_t **)(result + 1);
  v7 = result[1];
  if (v7)
  {
    while (1)
    {
      while (1)
      {
        v9 = (_QWORD *)v7;
        v10 = *(_DWORD *)(v7 + 32);
        if (v10 <= a2)
          break;
        v7 = *v9;
        v8 = (uint64_t **)v9;
        if (!*v9)
          goto LABEL_9;
      }
      if (v10 >= a2)
        break;
      v7 = v9[1];
      if (!v7)
      {
        v8 = (uint64_t **)(v9 + 1);
        goto LABEL_9;
      }
    }
  }
  else
  {
    v9 = result + 1;
LABEL_9:
    v11 = operator new(0x30uLL);
    v11[8] = a3;
    *((_QWORD *)v11 + 5) = a4;
    *(_QWORD *)v11 = 0;
    *((_QWORD *)v11 + 1) = 0;
    *((_QWORD *)v11 + 2) = v9;
    *v8 = (uint64_t *)v11;
    v12 = *(_QWORD *)*v6;
    if (v12)
    {
      *v6 = v12;
      v13 = *v8;
    }
    else
    {
      v13 = (uint64_t *)v11;
    }
    result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)v6[1], v13);
    ++v6[2];
  }
  return result;
}

void MPClusteringTreeNode::getLeafNodes(MPClusteringTreeNode *this, uint64_t a2)
{
  id var0;
  char *v5;
  _QWORD *v6;
  char *v7;
  char *v8;
  MPClusteringTreeNode v9;

  this->var0 = 0;
  *(_QWORD *)&this->var1 = 0;
  *(_QWORD *)&this->var3 = 0;
  if (*(_QWORD *)(a2 + 24) && *(_QWORD *)(a2 + 32))
  {
    MPClusteringTreeNode::getLeafNodes(&v9);
    MPClusteringTreeNode::getLeafNodes((MPClusteringTreeNode *)&v7);
    var0 = v9.var0;
    std::vector<MPClusteringTreeNode *>::__insert_with_size[abi:ne180100]<std::__wrap_iter<MPClusteringTreeNode **>,std::__wrap_iter<MPClusteringTreeNode **>>((uint64_t)this, 0, (char *)v9.var0, *(char **)&v9.var1, (uint64_t)(*(_QWORD *)&v9.var1 - (unint64_t)v9.var0) >> 3);
    v5 = v7;
    std::vector<MPClusteringTreeNode *>::__insert_with_size[abi:ne180100]<std::__wrap_iter<MPClusteringTreeNode **>,std::__wrap_iter<MPClusteringTreeNode **>>((uint64_t)this, *(char **)&this->var1, v7, v8, (v8 - v7) >> 3);
    if (v5)
      operator delete(v5);
    if (var0)
      operator delete(var0);
  }
  else
  {
    v6 = operator new(8uLL);
    this->var0 = v6;
    *v6++ = a2;
    *(_QWORD *)&this->var1 = v6;
    *(_QWORD *)&this->var3 = v6;
  }
}

void sub_1A14AE260(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v12;
  void *v13;
  void *v14;
  void *v16;

  if (v14)
    operator delete(v14);
  if (v13)
    operator delete(v13);
  v16 = *(void **)v12;
  if (*(_QWORD *)v12)
  {
    *(_QWORD *)(v12 + 8) = v16;
    operator delete(v16);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<MPClusteringTreeNode *>::__insert_with_size[abi:ne180100]<std::__wrap_iter<MPClusteringTreeNode **>,std::__wrap_iter<MPClusteringTreeNode **>>(uint64_t a1, char *__dst, char *__src, char *a4, uint64_t a5)
{
  char *v6;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  int64_t v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  uint64_t v25;
  _QWORD *v26;
  char *v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  char *v31;
  char *v32;
  uint64_t v33;
  unint64_t v34;
  _BYTE *v35;
  uint64_t v36;
  char *v37;

  if (a5 < 1)
    return;
  v6 = __src;
  v10 = *(_QWORD *)(a1 + 8);
  v9 = *(_QWORD *)(a1 + 16);
  if (a5 > (uint64_t)(v9 - v10) >> 3)
  {
    v11 = *(char **)a1;
    v12 = a5 + ((uint64_t)(v10 - *(_QWORD *)a1) >> 3);
    if (v12 >> 61)
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    v13 = (__dst - v11) >> 3;
    v14 = v9 - (_QWORD)v11;
    if (v14 >> 2 > v12)
      v12 = v14 >> 2;
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8)
      v15 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v15 = v12;
    if (v15)
      v15 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v15);
    else
      v16 = 0;
    v26 = (_QWORD *)(v15 + 8 * v13);
    v27 = (char *)&v26[a5];
    v28 = 8 * a5;
    v29 = v26;
    do
    {
      v30 = *(_QWORD *)v6;
      v6 += 8;
      *v29++ = v30;
      v28 -= 8;
    }
    while (v28);
    v31 = *(char **)a1;
    if (*(char **)a1 != __dst)
    {
      v32 = __dst;
      do
      {
        v33 = *((_QWORD *)v32 - 1);
        v32 -= 8;
        *--v26 = v33;
      }
      while (v32 != v31);
    }
    v34 = v15 + 8 * v16;
    v35 = *(_BYTE **)(a1 + 8);
    v36 = v35 - __dst;
    if (v35 != __dst)
      memmove(v27, __dst, v35 - __dst);
    v37 = *(char **)a1;
    *(_QWORD *)a1 = v26;
    *(_QWORD *)(a1 + 8) = &v27[v36];
    *(_QWORD *)(a1 + 16) = v34;
    if (v37)
      operator delete(v37);
    return;
  }
  v17 = v10 - (_QWORD)__dst;
  v18 = (uint64_t)(v10 - (_QWORD)__dst) >> 3;
  if (v18 >= a5)
  {
    v19 = &__src[8 * a5];
    v21 = *(char **)(a1 + 8);
LABEL_17:
    v22 = &__dst[8 * a5];
    v23 = &v21[-8 * a5];
    v24 = v21;
    if ((unint64_t)v23 < v10)
    {
      v24 = v21;
      do
      {
        v25 = *(_QWORD *)v23;
        v23 += 8;
        *(_QWORD *)v24 = v25;
        v24 += 8;
      }
      while ((unint64_t)v23 < v10);
    }
    *(_QWORD *)(a1 + 8) = v24;
    if (v21 != v22)
      memmove(&v21[-8 * ((v21 - v22) >> 3)], __dst, v21 - v22);
    if (v19 != v6)
      memmove(__dst, v6, v19 - v6);
    return;
  }
  v19 = &__src[8 * v18];
  v20 = a4 - v19;
  if (a4 != v19)
    memmove(*(void **)(a1 + 8), &__src[8 * v18], a4 - v19);
  v21 = (char *)(v10 + v20);
  *(_QWORD *)(a1 + 8) = v10 + v20;
  if (v17 >= 1)
    goto LABEL_17;
}

void MPClusteringTreeNode::freeNodeAndItsSubtree(MPClusteringTreeNode *this)
{
  MPClusteringTreeNode *var5;
  MPClusteringTreeNode *var6;

  var5 = this->var5;
  if (var5)
    MPClusteringTreeNode::freeNodeAndItsSubtree(var5);
  var6 = this->var6;
  if (var6)
    MPClusteringTreeNode::freeNodeAndItsSubtree(var6);
  free(this);
}

void sub_1A14AE558(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  void *v9;
  void *v10;

  v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)VNEspressoResources;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_1A14AE600(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14AE8DC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14AE9B8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14AEAD4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1A14AEE8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,char a32)
{
  void *v32;
  void *v33;
  void *v34;

  _Unwind_Resume(a1);
}

void sub_1A14AF03C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1A14AF694(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16)
{
  void *v16;
  void *v17;

  _Unwind_Resume(a1);
}

void sub_1A14AF864(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14AF928(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14AFBF4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14AFDC4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t ctpl_trackerDelete(_QWORD *a1)
{
  void ***v2;
  uint64_t *v3;

  if (a1)
  {
    v2 = (void ***)a1[9];
    if (v2)
      tplTrackerResampler_free(v2 + 42655);
    free(v2);
    free(a1);
    v3 = &CVML_status_ok;
  }
  else
  {
    v3 = &CVML_status_invalidParameter;
  }
  return (*v3 + 128) | 0x1A00;
}

void vision::mod::ImageAnalyzer_CustomClassifier::~ImageAnalyzer_CustomClassifier(vision::mod::ImageAnalyzer_CustomClassifier *this)
{
  void **v2;

  if (!*((_BYTE *)this + 240))
    espresso_plan_destroy();
  espresso_context_destroy();
  v2 = (void **)((char *)this + 312);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v2);
  vision::mod::ImageAnalyzer_CustomClassifierOptions::~ImageAnalyzer_CustomClassifierOptions((void **)this);
}

void vision::mod::ImageAnalyzer_CustomClassifierOptions::~ImageAnalyzer_CustomClassifierOptions(void **this)
{
  if (*((char *)this + 191) < 0)
    operator delete(this[21]);
  if (*((char *)this + 167) < 0)
    operator delete(this[18]);
  if (*((char *)this + 143) < 0)
    operator delete(this[15]);
  if (*((char *)this + 119) < 0)
    operator delete(this[12]);
  if (*((char *)this + 95) < 0)
    operator delete(this[9]);
  if (*((char *)this + 71) < 0)
    operator delete(this[6]);
  if (*((char *)this + 47) < 0)
    operator delete(this[3]);
  if (*((char *)this + 23) < 0)
    operator delete(*this);
}

void ***vision::mod::ImageAnalyzer_CustomClassifier::performInference(void ***a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v8;
  void **v9;
  uint64_t v10;
  uint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  void **v18;
  _DWORD *v19;
  _DWORD *v20;
  uint64_t v21;
  int v22;
  uint64_t *v23;
  uint64_t v24;
  __int128 *v25;
  _BYTE *v26;
  _BYTE *v27;
  __int128 v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  char *v34;
  char *v35;
  std::string *v36;
  __int128 v37;
  _QWORD *exception;
  _QWORD *v40;
  void ***v41;
  char *v42;
  unint64_t v43;
  unint64_t p_size;
  char *v45;
  void **v46;
  _DWORD *v47;
  _DWORD *v48;
  void **v49;

  v8 = operator new();
  *(_QWORD *)v8 = 0;
  *(_QWORD *)(v8 + 8) = 0;
  *(_QWORD *)(v8 + 16) = 0;
  v9 = (void **)(v8 + 16);
  v49 = (void **)v8;
  v10 = *(_QWORD *)(a2 + 320) - *(_QWORD *)(a2 + 312);
  if (v10)
  {
    v11 = (uint64_t *)v8;
    v12 = 0xAAAAAAAAAAAAAAABLL * (v10 >> 3);
    if (v12 >> 59)
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    v46 = v9;
    v42 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<vImage_Buffer>>(v12);
    v43 = (unint64_t)v42;
    p_size = (unint64_t)v42;
    v45 = &v42[32 * v13];
    std::vector<std::pair<std::string,float>>::__swap_out_circular_buffer(v11, &v42);
    std::__split_buffer<std::pair<std::string,float>>::~__split_buffer((uint64_t)&v42);
  }
  v14 = *(_DWORD *)(a3 + 168);
  switch(v14)
  {
    case 262152:
      v15 = 1;
      break;
    case 65568:
      v15 = 4;
      break;
    case 65552:
      v15 = 2;
      break;
    default:
      exception = __cxa_allocate_exception(8uLL);
      *exception = 8563;
      __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
  }
  memcpy(*(void **)(a2 + 336), *(const void **)(a3 + 8), *(_QWORD *)(a3 + 160) * v15 * *(_QWORD *)(a3 + 120));
  v16 = *(_OWORD *)(a3 + 40);
  *(_OWORD *)(a2 + 352) = *(_OWORD *)(a3 + 24);
  *(_OWORD *)(a2 + 368) = v16;
  v17 = *(_OWORD *)(a3 + 72);
  *(_OWORD *)(a2 + 384) = *(_OWORD *)(a3 + 56);
  *(_OWORD *)(a2 + 400) = v17;
  *(_OWORD *)(a2 + 416) = *(_OWORD *)(a3 + 88);
  *(_OWORD *)(a2 + 432) = *(_OWORD *)(a3 + 104);
  *(_OWORD *)(a2 + 448) = *(_OWORD *)(a3 + 120);
  *(_OWORD *)(a2 + 464) = *(_OWORD *)(a3 + 136);
  *(_OWORD *)(a2 + 480) = *(_OWORD *)(a3 + 152);
  *(_DWORD *)(a2 + 496) = *(_DWORD *)(a3 + 168);
  if (espresso_plan_execute_sync())
  {
    espresso_plan_get_error_info();
    v18 = 0;
    *a4 = 8539;
  }
  else
  {
    vision::mod::ImageAnalyzer_Tensor1D<float>::ImageAnalyzer_Tensor1D((uint64_t)&v42, (__int128 *)(a2 + 504), 0);
    vision::mod::ImageAnalyzer_Tensor1D<float>::getVectorFromTensor(&v47, (unint64_t *)&v42);
    vision::mod::ImageAnalyzer_Tensor1D<float>::~ImageAnalyzer_Tensor1D((uint64_t)&v42);
    v19 = v47;
    v20 = v48;
    if (v47 != v48)
    {
      v40 = a4;
      v41 = a1;
      v21 = 0;
      do
      {
        v22 = *v19;
        v23 = (uint64_t *)v49;
        v24 = *(_QWORD *)(a2 + 312);
        v25 = (__int128 *)(v24 + v21);
        v26 = v49[1];
        v27 = v49[2];
        if (v26 >= v27)
        {
          v29 = (v26 - (_BYTE *)*v49) >> 5;
          if ((unint64_t)(v29 + 1) >> 59)
            std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
          v30 = v27 - (_BYTE *)*v49;
          v31 = v30 >> 4;
          if (v30 >> 4 <= (unint64_t)(v29 + 1))
            v31 = v29 + 1;
          if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFE0)
            v32 = 0x7FFFFFFFFFFFFFFLL;
          else
            v32 = v31;
          v46 = v49 + 2;
          if (v32)
          {
            v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<vImage_Buffer>>(v32);
          }
          else
          {
            v34 = 0;
            v33 = 0;
          }
          v36 = (std::string *)&v34[32 * v29];
          v42 = v34;
          v43 = (unint64_t)v36;
          p_size = (unint64_t)v36;
          v45 = &v34[32 * v33];
          if (*(char *)(v24 + v21 + 23) < 0)
          {
            std::string::__init_copy_ctor_external(v36, *(const std::string::value_type **)(v24 + v21), *(_QWORD *)(v24 + v21 + 8));
            v36 = (std::string *)p_size;
          }
          else
          {
            v37 = *v25;
            v36->__r_.__value_.__r.__words[2] = *((_QWORD *)v25 + 2);
            *(_OWORD *)&v36->__r_.__value_.__l.__data_ = v37;
          }
          *(_DWORD *)&v34[32 * v29 + 24] = v22;
          p_size = (unint64_t)&v36[1].__r_.__value_.__l.__size_;
          std::vector<std::pair<std::string,float>>::__swap_out_circular_buffer(v23, &v42);
          v35 = (char *)v23[1];
          std::__split_buffer<std::pair<std::string,float>>::~__split_buffer((uint64_t)&v42);
        }
        else
        {
          if (*((char *)v25 + 23) < 0)
          {
            std::string::__init_copy_ctor_external((std::string *)v49[1], *(const std::string::value_type **)(v24 + v21), *(_QWORD *)(v24 + v21 + 8));
          }
          else
          {
            v28 = *v25;
            *((_QWORD *)v26 + 2) = *((_QWORD *)v25 + 2);
            *(_OWORD *)v26 = v28;
          }
          *((_DWORD *)v26 + 6) = v22;
          v35 = v26 + 32;
          v23[1] = (uint64_t)(v26 + 32);
        }
        v23[1] = (uint64_t)v35;
        ++v19;
        v21 += 24;
      }
      while (v19 != v20);
      v19 = v47;
      a4 = v40;
      a1 = v41;
    }
    if (v19)
    {
      v48 = v19;
      operator delete(v19);
    }
    *a4 = 8576;
    v18 = v49;
    v49 = 0;
  }
  *a1 = v18;
  return std::unique_ptr<std::vector<std::pair<std::string,float>>>::reset[abi:ne180100](&v49);
}

void sub_1A14B0324(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  va_list va;

  va_start(va, a3);
  vision::mod::ImageAnalyzer_Tensor1D<float>::~ImageAnalyzer_Tensor1D((uint64_t)va);
  std::unique_ptr<std::vector<std::pair<std::string,float>>>::reset[abi:ne180100]((void ***)(v3 - 112));
  _Unwind_Resume(a1);
}

void ***std::unique_ptr<std::vector<std::pair<std::string,float>>>::reset[abi:ne180100](void ***result)
{
  void **v1;
  void **v2;

  v1 = *result;
  *result = 0;
  if (v1)
  {
    v2 = v1;
    std::vector<std::pair<std::string,float>>::__destroy_vector::operator()[abi:ne180100](&v2);
    JUMPOUT(0x1A1B0A898);
  }
  return result;
}

void sub_1A14B053C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A14B0668(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14B0754(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  void **v9;
  _QWORD *v10;
  unint64_t v11;
  float v12;
  float v13;
  _BOOL8 v14;
  unint64_t v15;
  unint64_t v16;
  size_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;

  v6 = a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & a2;
    }
    v9 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2)
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  v10 = operator new(0x30uLL);
  *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v10[4] = 0;
  v10[5] = 0;
  v10[3] = 0;
  v12 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    v14 = 1;
    if (v7 >= 3)
      v14 = (v7 & (v7 - 1)) != 0;
    v15 = v14 | (2 * v7);
    v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16)
      v17 = v16;
    else
      v17 = v15;
    std::__hash_table<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>>>::__rehash<true>(a1, v17);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & v6;
    }
  }
  v18 = *(_QWORD *)a1;
  v19 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v19)
  {
    *v10 = *v19;
LABEL_38:
    *v19 = v10;
    goto LABEL_39;
  }
  *v10 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v10;
  *(_QWORD *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    v20 = *(_QWORD *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7)
        v20 %= v7;
    }
    else
    {
      v20 &= v7 - 1;
    }
    v19 = (_QWORD *)(*(_QWORD *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v10;
}

void sub_1A14B098C(_Unwind_Exception *a1)
{
  void **v1;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,void *>>>::operator()[abi:ne180100](1, v1);
  _Unwind_Resume(a1);
}

void vision::mod::ImageAnalyzer::loadLabels(std::vector<std::string> *this, const char *a2)
{
  std::locale::id *v3;
  const std::locale::facet *v4;
  unsigned __int8 v5;
  std::vector<std::string>::pointer end;
  __int128 v7;
  std::vector<std::string>::pointer v8;
  void *__p[2];
  std::string::size_type v10;
  std::locale v11;
  _QWORD v12[2];
  _BYTE v13[408];
  _QWORD v14[20];

  v14[19] = *MEMORY[0x1E0C80C00];
  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (a2 && *a2)
  {
    __p[0] = 0;
    __p[1] = 0;
    v10 = 0;
    std::ifstream::basic_ifstream(v12);
    v3 = (std::locale::id *)MEMORY[0x1E0DE4A90];
    while (1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)v12 + *(_QWORD *)(v12[0] - 24)));
      v4 = std::locale::use_facet(&v11, v3);
      v5 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v4->__vftable[2].~facet_0)(v4, 10);
      std::locale::~locale(&v11);
      std::getline[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v12, (uint64_t)__p, v5);
      if ((v13[*(_QWORD *)(v12[0] - 24) + 16] & 5) != 0)
        break;
      end = this->__end_;
      if (end >= this->__end_cap_.__value_)
      {
        v8 = std::vector<std::string>::__push_back_slow_path<std::string const&>(this, (__int128 *)__p);
      }
      else
      {
        if (SHIBYTE(v10) < 0)
        {
          std::string::__init_copy_ctor_external(this->__end_, (const std::string::value_type *)__p[0], (std::string::size_type)__p[1]);
        }
        else
        {
          v7 = *(_OWORD *)__p;
          end->__r_.__value_.__r.__words[2] = v10;
          *(_OWORD *)&end->__r_.__value_.__l.__data_ = v7;
        }
        v8 = end + 1;
        this->__end_ = end + 1;
      }
      this->__end_ = v8;
    }
    v12[0] = *MEMORY[0x1E0DE4F40];
    *(_QWORD *)((char *)v12 + *(_QWORD *)(v12[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F40] + 24);
    MEMORY[0x1A1B0A694](v13);
    std::istream::~istream();
    MEMORY[0x1A1B0A808](v14);
    if (SHIBYTE(v10) < 0)
      operator delete(__p[0]);
  }
}

void sub_1A14B0B44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, std::locale a16, uint64_t a17)
{
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_rethrow();
  }
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&a17);
  _Unwind_Resume(a1);
}

void sub_1A14B0BCC(void *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  JUMPOUT(0x1A14B0BC4);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::unordered_set<std::string>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::unordered_set<std::string>>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table((uint64_t)v1 + 24);
    operator delete(v1);
  }
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,void *>>>::operator()[abi:ne180100](char a1, void **__p)
{
  void **v3;

  if (a1)
  {
    v3 = __p + 3;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v3);
  }
  if (__p)
    operator delete(__p);
}

uint64_t vision::mod::_isBooleanFlag(uint64_t a1, _BYTE *a2)
{
  std::string *v3;
  std::string *p_p;
  uint64_t v5;
  std::string __p;

  if (*(char *)(a1 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a1, *(_QWORD *)(a1 + 8));
  else
    __p = *(std::string *)a1;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v3 = (std::string *)((char *)&__p + HIBYTE(__p.__r_.__value_.__r.__words[2]));
  else
    v3 = (std::string *)(__p.__r_.__value_.__r.__words[0] + __p.__r_.__value_.__l.__size_);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  while (p_p != v3)
  {
    p_p->__r_.__value_.__s.__data_[0] = __tolower(p_p->__r_.__value_.__s.__data_[0]);
    p_p = (std::string *)((char *)p_p + 1);
  }
  if (std::string::compare(&__p, "true"))
  {
    if (std::string::compare(&__p, "false"))
    {
      v5 = 0;
      goto LABEL_21;
    }
    if (!a2)
      goto LABEL_20;
    LOBYTE(v5) = 0;
LABEL_19:
    *a2 = v5;
LABEL_20:
    v5 = 1;
    goto LABEL_21;
  }
  v5 = 1;
  if (a2)
    goto LABEL_19;
LABEL_21:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return v5;
}

void sub_1A14B0D64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t *std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(_QWORD *a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  uint64_t **v9;
  uint64_t *i;
  unint64_t v11;
  char *v12;
  _QWORD *v13;
  uint64_t v14;
  _QWORD *v15;
  const std::string::value_type **v16;
  _QWORD *v17;
  _QWORD *v18;
  _QWORD *v19;
  BOOL v20;
  uint64_t **v21;
  uint64_t **v22;
  uint64_t *v23;
  _QWORD *v24;
  char *v25;
  uint64_t *v26;
  _QWORD *v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t j;
  uint64_t (***v32)();
  uint64_t v33;
  _QWORD *v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t **v37;
  const std::string::value_type **v38;
  _QWORD *v39;
  _QWORD *v40;
  _QWORD *v41;
  uint64_t **v42;
  char *v43;
  uint64_t *v44;
  _QWORD *v45;
  _QWORD *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t (***v49)();
  uint64_t v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t *v53;
  uint64_t **v54;
  const std::string::value_type **v55;
  _QWORD *v56;
  _QWORD *v57;
  _QWORD *v58;
  uint64_t **v59;
  char *v60;
  uint64_t *v61;
  _QWORD *v62;
  _QWORD *v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  int8x8_t v67;
  uint64_t (***v68)();
  uint64_t v69;
  float v70;
  float v71;
  _BOOL8 v72;
  unint64_t v73;
  unint64_t v74;
  int8x8_t prime;
  unint64_t v76;
  void *v77;
  void *v78;
  uint64_t v79;
  _QWORD *v80;
  unint64_t v81;
  uint8x8_t v82;
  unint64_t v83;
  uint8x8_t v84;
  uint64_t v85;
  _QWORD *v86;
  unint64_t v87;
  _QWORD *v88;
  unint64_t v89;
  void *v91;
  unint64_t v92;
  _QWORD *v93;
  float *v94;
  unint64_t v95;
  char *v96;
  _QWORD v97[2];
  char v98;
  char *v99;
  _QWORD *v100;
  char v101;
  _QWORD *v102;
  _QWORD v103[3];
  uint64_t (**v104)();
  uint64_t (*v105)(vision::mod *__hidden, unint64_t);
  uint64_t (***v106)();
  _QWORD v107[3];
  uint64_t (**v108)();
  uint64_t (*v109)(vision::mod *__hidden, unint64_t);
  uint64_t (***v110)();
  _QWORD v111[3];
  uint64_t (**v112)();
  uint64_t (*v113)(vision::mod *__hidden, unint64_t);
  uint64_t (***v114)();
  _QWORD v115[3];
  uint64_t (**v116)();
  void *v117;
  _QWORD v118[3];

  v118[1] = *MEMORY[0x1E0C80C00];
  v6 = a2;
  v7 = a1[1];
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & a2;
    }
    v9 = *(uint64_t ***)(*a1 + 8 * v3);
    if (v9)
    {
      for (i = *v9; i; i = (uint64_t *)*i)
      {
        v11 = i[1];
        if (v11 == a2)
        {
          if (*((_DWORD *)i + 4) == a2)
            return i;
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7)
              v11 %= v7;
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3)
            break;
        }
      }
    }
  }
  v12 = (char *)operator new(0x90uLL);
  v97[0] = v12;
  v97[1] = a1 + 2;
  v93 = a1 + 2;
  v98 = 0;
  *(_QWORD *)v12 = 0;
  *((_QWORD *)v12 + 1) = v6;
  *((_DWORD *)v12 + 4) = *a3;
  *(_OWORD *)(v12 + 24) = 0u;
  *(_OWORD *)(v12 + 40) = 0u;
  *(_OWORD *)(v12 + 56) = 0u;
  *(_OWORD *)(v12 + 72) = 0u;
  *(_OWORD *)(v12 + 88) = 0u;
  *(_OWORD *)(v12 + 104) = 0u;
  *(_OWORD *)(v12 + 120) = 0u;
  *((_QWORD *)v12 + 17) = 0;
  std::string::basic_string[abi:ne180100]<0>((_QWORD *)v12 + 3, "unknown");
  v92 = v6;
  *((_QWORD *)v12 + 7) = 0;
  *((_QWORD *)v12 + 8) = 0;
  *((_QWORD *)v12 + 6) = v12 + 56;
  v96 = v12;
  std::string::basic_string[abi:ne180100]<0>(v103, "noMapping");
  v104 = &off_1E453B050;
  v105 = (uint64_t (*)(vision::mod *__hidden, unint64_t))vision::mod::readParametersNoMapping;
  v106 = &v104;
  std::string::basic_string[abi:ne180100]<0>(v107, "1DAffineMapping");
  v108 = &off_1E453B050;
  v109 = (uint64_t (*)(vision::mod *__hidden, unint64_t))vision::mod::readParameters1DAffineMapping;
  v110 = &v108;
  std::string::basic_string[abi:ne180100]<0>(v111, "1DLogisticMapping");
  v95 = v7;
  v112 = &off_1E453B050;
  v113 = (uint64_t (*)(vision::mod *__hidden, unint64_t))vision::mod::readParameters1DLogisticMapping;
  v114 = &v112;
  std::string::basic_string[abi:ne180100]<0>(v115, "1DPairwiseAffineMapping");
  v94 = (float *)a1;
  v13 = 0;
  v14 = 0;
  v116 = &off_1E453B050;
  v117 = vision::mod::readParameters1DPairwiseAffineMapping;
  v118[0] = &v116;
  *((_QWORD *)v12 + 10) = 0;
  *((_QWORD *)v12 + 11) = 0;
  v15 = v12 + 80;
  *((_QWORD *)v12 + 9) = v12 + 80;
  while (1)
  {
    v16 = (const std::string::value_type **)&v103[7 * v14];
    v17 = v15;
    if (*((_QWORD **)v96 + 9) == v15)
      goto LABEL_33;
    v18 = v13;
    v19 = v15;
    if (v13)
    {
      do
      {
        v17 = v18;
        v18 = (_QWORD *)v18[1];
      }
      while (v18);
    }
    else
    {
      do
      {
        v17 = (_QWORD *)v19[2];
        v20 = *v17 == (_QWORD)v19;
        v19 = v17;
      }
      while (v20);
    }
    if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v17 + 4, &v103[7 * v14]) & 0x80) != 0)
    {
LABEL_33:
      v21 = (uint64_t **)v15;
      v22 = (uint64_t **)v15;
      if (v13)
      {
        v22 = (uint64_t **)(v17 + 1);
        if (v17[1])
          goto LABEL_48;
        v21 = (uint64_t **)v17;
      }
    }
    else
    {
      v21 = (uint64_t **)v15;
      v22 = (uint64_t **)v15;
      if (v13)
      {
        v23 = v13;
        do
        {
          while (1)
          {
            v21 = (uint64_t **)v23;
            v24 = v23 + 4;
            if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&v103[7 * v14], v23 + 4) & 0x80) == 0)break;
            v23 = *v21;
            v22 = v21;
            if (!*v21)
              goto LABEL_36;
          }
          if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v24, &v103[7 * v14]) & 0x80) == 0)
            goto LABEL_48;
          v22 = v21 + 1;
          v23 = v21[1];
        }
        while (v23);
      }
    }
LABEL_36:
    v25 = (char *)operator new(0x58uLL);
    v26 = (uint64_t *)v25;
    v99 = v25;
    v100 = v15;
    v101 = 0;
    if (*((char *)v16 + 23) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)(v25 + 32), *v16, (std::string::size_type)v16[1]);
    }
    else
    {
      *((_OWORD *)v25 + 2) = *(_OWORD *)v16;
      *((_QWORD *)v25 + 6) = v16[2];
    }
    v27 = &v103[7 * v14];
    v28 = (_QWORD *)v27[6];
    if (v28)
    {
      if (v28 == v27 + 3)
      {
        v26[10] = (uint64_t)(v26 + 7);
        (*(void (**)(_QWORD *))(v27[3] + 24))(v27 + 3);
        goto LABEL_45;
      }
      v29 = (*(uint64_t (**)(_QWORD *))(*v28 + 16))(v28);
    }
    else
    {
      v29 = 0;
    }
    v26[10] = v29;
LABEL_45:
    v101 = 1;
    *v26 = 0;
    v26[1] = 0;
    v26[2] = (uint64_t)v21;
    *v22 = v26;
    v30 = **((_QWORD **)v96 + 9);
    if (v30)
    {
      *((_QWORD *)v96 + 9) = v30;
      v26 = *v22;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)v96 + 10), v26);
    ++*((_QWORD *)v96 + 11);
    v99 = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,void *>>>>::reset[abi:ne180100]((uint64_t)&v99);
LABEL_48:
    if (++v14 == 4)
      break;
    v13 = (_QWORD *)*v15;
  }
  for (j = 0; j != -28; j -= 7)
  {
    v32 = (uint64_t (***)())v118[j];
    if (&(&v116)[j] == v32)
    {
      v32 = &(&v116)[j];
      v33 = 4;
    }
    else
    {
      if (!v32)
        goto LABEL_56;
      v33 = 5;
    }
    ((void (*)(uint64_t (***)()))(*v32)[v33])(v32);
LABEL_56:
    if (SHIBYTE(v115[j + 2]) < 0)
      operator delete((void *)v115[j]);
  }
  std::string::basic_string[abi:ne180100]<0>(v103, "noMapping");
  v104 = &off_1E453AFF8;
  v105 = vision::mod::getOutputSizeNoMapping;
  v106 = &v104;
  std::string::basic_string[abi:ne180100]<0>(v107, "1DAffineMapping");
  v108 = &off_1E453AFF8;
  v109 = vision::mod::getOutputSize1DAffineMapping;
  v110 = &v108;
  std::string::basic_string[abi:ne180100]<0>(v111, "1DLogisticMapping");
  v112 = &off_1E453AFF8;
  v113 = vision::mod::getOutputSize1DLogisticMapping;
  v114 = &v112;
  std::string::basic_string[abi:ne180100]<0>(v115, "1DPairwiseAffineMapping");
  v34 = 0;
  v35 = 0;
  v116 = &off_1E453AFF8;
  v117 = vision::mod::getOutputSize1DPairwiseAffineMapping;
  *((_QWORD *)v96 + 13) = 0;
  *((_QWORD *)v96 + 14) = 0;
  v36 = (uint64_t *)(v96 + 104);
  v118[0] = &v116;
  v37 = (uint64_t **)(v96 + 96);
  *((_QWORD *)v96 + 12) = v96 + 104;
  while (2)
  {
    v38 = (const std::string::value_type **)&v103[7 * v35];
    v39 = v96 + 104;
    if (*v37 != v36)
    {
      v40 = v34;
      v41 = v96 + 104;
      if (v34)
      {
        do
        {
          v39 = v40;
          v40 = (_QWORD *)v40[1];
        }
        while (v40);
      }
      else
      {
        do
        {
          v39 = (_QWORD *)v41[2];
          v20 = *v39 == (_QWORD)v41;
          v41 = v39;
        }
        while (v20);
      }
      if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v39 + 4, &v103[7 * v35]) & 0x80) == 0)
      {
        v42 = (uint64_t **)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__find_equal<std::string>((uint64_t)v37, &v102, &v103[7 * v35]);
        goto LABEL_69;
      }
    }
    if (!v34)
    {
      v102 = v96 + 104;
      v42 = (uint64_t **)(v96 + 104);
      goto LABEL_72;
    }
    v102 = v39;
    v42 = (uint64_t **)(v39 + 1);
LABEL_69:
    if (!*v42)
    {
LABEL_72:
      v43 = (char *)operator new(0x58uLL);
      v44 = (uint64_t *)v43;
      v99 = v43;
      v100 = v96 + 104;
      v101 = 0;
      if (*((char *)v38 + 23) < 0)
      {
        std::string::__init_copy_ctor_external((std::string *)(v43 + 32), *v38, (std::string::size_type)v38[1]);
      }
      else
      {
        *((_OWORD *)v43 + 2) = *(_OWORD *)v38;
        *((_QWORD *)v43 + 6) = v38[2];
      }
      v45 = &v103[7 * v35];
      v46 = (_QWORD *)v45[6];
      if (v46)
      {
        if (v46 != v45 + 3)
        {
          v47 = (*(uint64_t (**)(_QWORD *))(*v46 + 16))(v46);
          goto LABEL_79;
        }
        v44[10] = (uint64_t)(v44 + 7);
        (*(void (**)(_QWORD *))(v45[3] + 24))(v45 + 3);
      }
      else
      {
        v47 = 0;
LABEL_79:
        v44[10] = v47;
      }
      v101 = 1;
      std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at(v37, (uint64_t)v102, v42, v44);
      v99 = 0;
      std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,void *>>>>::reset[abi:ne180100]((uint64_t)&v99);
    }
    if (++v35 != 4)
    {
      v34 = (_QWORD *)*v36;
      continue;
    }
    break;
  }
  v48 = 0;
  while (2)
  {
    v49 = (uint64_t (***)())v118[v48];
    if (&(&v116)[v48] == v49)
    {
      v49 = &(&v116)[v48];
      v50 = 4;
LABEL_89:
      ((void (*)(uint64_t (***)()))(*v49)[v50])(v49);
    }
    else if (v49)
    {
      v50 = 5;
      goto LABEL_89;
    }
    if (SHIBYTE(v115[v48 + 2]) < 0)
      operator delete((void *)v115[v48]);
    v48 -= 7;
    if (v48 != -28)
      continue;
    break;
  }
  std::string::basic_string[abi:ne180100]<0>(v103, "noMapping");
  v104 = &off_1E453B0A8;
  v105 = (uint64_t (*)(vision::mod *__hidden, unint64_t))vision::mod::computeNoMapping;
  v106 = &v104;
  std::string::basic_string[abi:ne180100]<0>(v107, "1DAffineMapping");
  v108 = &off_1E453B0A8;
  v109 = (uint64_t (*)(vision::mod *__hidden, unint64_t))vision::mod::compute1DAffineMapping;
  v110 = &v108;
  std::string::basic_string[abi:ne180100]<0>(v111, "1DLogisticMapping");
  v112 = &off_1E453B0A8;
  v113 = (uint64_t (*)(vision::mod *__hidden, unint64_t))vision::mod::compute1DLogisticMapping;
  v114 = &v112;
  std::string::basic_string[abi:ne180100]<0>(v115, "1DPairwiseAffineMapping");
  v51 = 0;
  v52 = 0;
  v116 = &off_1E453B0A8;
  v117 = vision::mod::compute1DPairwiseAffineMapping;
  *((_QWORD *)v96 + 16) = 0;
  *((_QWORD *)v96 + 17) = 0;
  v53 = (uint64_t *)(v96 + 128);
  v118[0] = &v116;
  v54 = (uint64_t **)(v96 + 120);
  *((_QWORD *)v96 + 15) = v96 + 128;
  while (2)
  {
    v55 = (const std::string::value_type **)&v103[7 * v52];
    v56 = v96 + 128;
    if (*v54 != v53)
    {
      v57 = v51;
      v58 = v96 + 128;
      if (v51)
      {
        do
        {
          v56 = v57;
          v57 = (_QWORD *)v57[1];
        }
        while (v57);
      }
      else
      {
        do
        {
          v56 = (_QWORD *)v58[2];
          v20 = *v56 == (_QWORD)v58;
          v58 = v56;
        }
        while (v20);
      }
      if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v56 + 4, &v103[7 * v52]) & 0x80) == 0)
      {
        v59 = (uint64_t **)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__find_equal<std::string>((uint64_t)v54, &v102, &v103[7 * v52]);
        goto LABEL_103;
      }
    }
    if (!v51)
    {
      v102 = v96 + 128;
      v59 = (uint64_t **)(v96 + 128);
      goto LABEL_106;
    }
    v102 = v56;
    v59 = (uint64_t **)(v56 + 1);
LABEL_103:
    if (!*v59)
    {
LABEL_106:
      v60 = (char *)operator new(0x58uLL);
      v61 = (uint64_t *)v60;
      v99 = v60;
      v100 = v96 + 128;
      v101 = 0;
      if (*((char *)v55 + 23) < 0)
      {
        std::string::__init_copy_ctor_external((std::string *)(v60 + 32), *v55, (std::string::size_type)v55[1]);
      }
      else
      {
        *((_OWORD *)v60 + 2) = *(_OWORD *)v55;
        *((_QWORD *)v60 + 6) = v55[2];
      }
      v62 = &v103[7 * v52];
      v63 = (_QWORD *)v62[6];
      if (v63)
      {
        if (v63 != v62 + 3)
        {
          v64 = (*(uint64_t (**)(_QWORD *))(*v63 + 16))(v63);
          goto LABEL_113;
        }
        v61[10] = (uint64_t)(v61 + 7);
        (*(void (**)(_QWORD *))(v62[3] + 24))(v62 + 3);
      }
      else
      {
        v64 = 0;
LABEL_113:
        v61[10] = v64;
      }
      v101 = 1;
      std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at(v54, (uint64_t)v102, v59, v61);
      v99 = 0;
      std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,void *>>>>::reset[abi:ne180100]((uint64_t)&v99);
    }
    if (++v52 != 4)
    {
      v51 = (_QWORD *)*v53;
      continue;
    }
    break;
  }
  v65 = 0;
  v66 = v3;
  v67 = (int8x8_t)v95;
  while (2)
  {
    v68 = (uint64_t (***)())v118[v65];
    if (&(&v116)[v65] == v68)
    {
      v68 = &(&v116)[v65];
      v69 = 4;
LABEL_123:
      ((void (*)(uint64_t (***)()))(*v68)[v69])(v68);
    }
    else if (v68)
    {
      v69 = 5;
      goto LABEL_123;
    }
    if (SHIBYTE(v115[v65 + 2]) < 0)
      operator delete((void *)v115[v65]);
    v65 -= 7;
    if (v65 != -28)
      continue;
    break;
  }
  v98 = 1;
  v70 = (float)(unint64_t)(*((_QWORD *)v94 + 3) + 1);
  v71 = v94[8];
  if (!v95 || (float)(v71 * (float)v95) < v70)
  {
    v72 = 1;
    if (v95 >= 3)
      v72 = (v95 & (v95 - 1)) != 0;
    v73 = v72 | (2 * v95);
    v74 = vcvtps_u32_f32(v70 / v71);
    if (v73 <= v74)
      prime = (int8x8_t)v74;
    else
      prime = (int8x8_t)v73;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
      v76 = v92;
    }
    else
    {
      v76 = v92;
      if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
        prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    }
    v67 = *(int8x8_t *)(v94 + 2);
    if (*(_QWORD *)&prime <= *(_QWORD *)&v67)
    {
      if (*(_QWORD *)&prime < *(_QWORD *)&v67)
      {
        v83 = vcvtps_u32_f32((float)*((unint64_t *)v94 + 3) / v94[8]);
        if (*(_QWORD *)&v67 < 3uLL || (v84 = (uint8x8_t)vcnt_s8(v67), v84.i16[0] = vaddlv_u8(v84), v84.u32[0] > 1uLL))
        {
          v83 = std::__next_prime(v83);
        }
        else
        {
          v85 = 1 << -(char)__clz(v83 - 1);
          if (v83 >= 2)
            v83 = v85;
        }
        if (*(_QWORD *)&prime <= v83)
          prime = (int8x8_t)v83;
        if (*(_QWORD *)&prime >= *(_QWORD *)&v67)
        {
          v67 = *(int8x8_t *)(v94 + 2);
        }
        else
        {
          if (prime)
            goto LABEL_139;
          v91 = *(void **)v94;
          *(_QWORD *)v94 = 0;
          if (v91)
            operator delete(v91);
          v67 = 0;
          *((_QWORD *)v94 + 1) = 0;
        }
      }
    }
    else
    {
LABEL_139:
      if (*(_QWORD *)&prime >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v77 = operator new(8 * *(_QWORD *)&prime);
      v78 = *(void **)v94;
      *(_QWORD *)v94 = v77;
      if (v78)
        operator delete(v78);
      v79 = 0;
      *((int8x8_t *)v94 + 1) = prime;
      do
        *(_QWORD *)(*(_QWORD *)v94 + 8 * v79++) = 0;
      while (*(_QWORD *)&prime != v79);
      v80 = (_QWORD *)*v93;
      if (*v93)
      {
        v81 = v80[1];
        v82 = (uint8x8_t)vcnt_s8(prime);
        v82.i16[0] = vaddlv_u8(v82);
        if (v82.u32[0] > 1uLL)
        {
          if (v81 >= *(_QWORD *)&prime)
            v81 %= *(_QWORD *)&prime;
        }
        else
        {
          v81 &= *(_QWORD *)&prime - 1;
        }
        *(_QWORD *)(*(_QWORD *)v94 + 8 * v81) = v93;
        v86 = (_QWORD *)*v80;
        if (*v80)
        {
          do
          {
            v87 = v86[1];
            if (v82.u32[0] > 1uLL)
            {
              if (v87 >= *(_QWORD *)&prime)
                v87 %= *(_QWORD *)&prime;
            }
            else
            {
              v87 &= *(_QWORD *)&prime - 1;
            }
            if (v87 != v81)
            {
              if (!*(_QWORD *)(*(_QWORD *)v94 + 8 * v87))
              {
                *(_QWORD *)(*(_QWORD *)v94 + 8 * v87) = v80;
                goto LABEL_164;
              }
              *v80 = *v86;
              *v86 = **(_QWORD **)(*(_QWORD *)v94 + 8 * v87);
              **(_QWORD **)(*(_QWORD *)v94 + 8 * v87) = v86;
              v86 = v80;
            }
            v87 = v81;
LABEL_164:
            v80 = v86;
            v86 = (_QWORD *)*v86;
            v81 = v87;
          }
          while (v86);
        }
      }
      v67 = prime;
    }
    if ((*(_QWORD *)&v67 & (*(_QWORD *)&v67 - 1)) != 0)
    {
      if (*(_QWORD *)&v67 <= v76)
        v66 = v76 % *(_QWORD *)&v67;
      else
        v66 = v76;
    }
    else
    {
      v66 = (v67.i32[0] - 1) & v76;
    }
  }
  v88 = *(_QWORD **)(*(_QWORD *)v94 + 8 * v66);
  i = (uint64_t *)v97[0];
  if (v88)
  {
    *(_QWORD *)v97[0] = *v88;
    goto LABEL_181;
  }
  *(_QWORD *)v97[0] = *((_QWORD *)v94 + 2);
  *((_QWORD *)v94 + 2) = i;
  *(_QWORD *)(*(_QWORD *)v94 + 8 * v66) = v93;
  if (*i)
  {
    v89 = *(_QWORD *)(*i + 8);
    if ((*(_QWORD *)&v67 & (*(_QWORD *)&v67 - 1)) != 0)
    {
      if (v89 >= *(_QWORD *)&v67)
        v89 %= *(_QWORD *)&v67;
    }
    else
    {
      v89 &= *(_QWORD *)&v67 - 1;
    }
    v88 = (_QWORD *)(*(_QWORD *)v94 + 8 * v89);
LABEL_181:
    *v88 = i;
  }
  v97[0] = 0;
  ++*((_QWORD *)v94 + 3);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>,void *>>>>::reset[abi:ne180100]((uint64_t)v97);
  return i;
}

void sub_1A14B1A1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>,void *>>>>::reset[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::destroy(*a1);
    std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::destroy(a1[1]);
    std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<float>>,0>((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void std::__tree<std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>>>::destroy(*a1);
    std::__tree<std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>>>::destroy(a1[1]);
    std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,0>((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,0>(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = (_QWORD *)(a1 + 24);
  v3 = *(_QWORD **)(a1 + 48);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<vision::mod::ImageAnalyzer_AnalysisType const,vision::mod::ImageAnalyzer_PostProcessor>,0>((uint64_t)v1 + 16);
    operator delete(v1);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<vision::mod::ImageAnalyzer_AnalysisType const,vision::mod::ImageAnalyzer_PostProcessor>,0>(uint64_t a1)
{
  std::__tree<std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>>>::destroy(*(_QWORD **)(a1 + 112));
  std::__tree<std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>>>::destroy(*(_QWORD **)(a1 + 88));
  std::__tree<std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>>>::destroy(*(_QWORD **)(a1 + 64));
  std::__tree<std::__value_type<std::string,std::vector<float>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<float>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<float>>>>::destroy(*(_QWORD **)(a1 + 40));
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
}

uint64_t std::pair<std::string const,std::function<long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>>::~pair(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = (_QWORD *)(a1 + 24);
  v3 = *(_QWORD **)(a1 + 48);
  if (v3 == v2)
  {
    v4 = 4;
    v3 = v2;
  }
  else
  {
    if (!v3)
      goto LABEL_6;
    v4 = 5;
  }
  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  return a1;
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,0>((uint64_t)v1 + 32);
    operator delete(v1);
  }
}

void std::__function::__func<std::__bind<long long (&)(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>,std::allocator<std::__bind<long long (&)(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>>,long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>::~__func()
{
  JUMPOUT(0x1A1B0A898);
}

__n128 std::__function::__func<std::__bind<long long (&)(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>,std::allocator<std::__bind<long long (&)(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>>,long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E453B0A8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<std::__bind<long long (&)(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>,std::allocator<std::__bind<long long (&)(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>>,long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E453B0A8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind<long long (&)(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>,std::allocator<std::__bind<long long (&)(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>>,long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a2, a3, a4);
}

uint64_t std::__function::__func<std::__bind<long long (&)(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>,std::allocator<std::__bind<long long (&)(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>>,long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), 0x80000001A15E57D3))
    return a1 + 8;
  else
    return 0;
}

void *std::__function::__func<std::__bind<long long (&)(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>,std::allocator<std::__bind<long long (&)(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>>,long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>::target_type()
{
}

void std::__function::__func<std::__bind<unsigned long (&)(unsigned long),std::placeholders::__ph<1> const&>,std::allocator<std::__bind<unsigned long (&)(unsigned long),std::placeholders::__ph<1> const&>>,unsigned long ()(unsigned long)>::~__func()
{
  JUMPOUT(0x1A1B0A898);
}

__n128 std::__function::__func<std::__bind<unsigned long (&)(unsigned long),std::placeholders::__ph<1> const&>,std::allocator<std::__bind<unsigned long (&)(unsigned long),std::placeholders::__ph<1> const&>>,unsigned long ()(unsigned long)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E453AFF8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<std::__bind<unsigned long (&)(unsigned long),std::placeholders::__ph<1> const&>,std::allocator<std::__bind<unsigned long (&)(unsigned long),std::placeholders::__ph<1> const&>>,unsigned long ()(unsigned long)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E453AFF8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind<unsigned long (&)(unsigned long),std::placeholders::__ph<1> const&>,std::allocator<std::__bind<unsigned long (&)(unsigned long),std::placeholders::__ph<1> const&>>,unsigned long ()(unsigned long)>::operator()(uint64_t a1, _QWORD *a2)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 8))(*a2);
}

uint64_t std::__function::__func<std::__bind<unsigned long (&)(unsigned long),std::placeholders::__ph<1> const&>,std::allocator<std::__bind<unsigned long (&)(unsigned long),std::placeholders::__ph<1> const&>>,unsigned long ()(unsigned long)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), 0x80000001A15E5596))
    return a1 + 8;
  else
    return 0;
}

void *std::__function::__func<std::__bind<unsigned long (&)(unsigned long),std::placeholders::__ph<1> const&>,std::allocator<std::__bind<unsigned long (&)(unsigned long),std::placeholders::__ph<1> const&>>,unsigned long ()(unsigned long)>::target_type()
{
}

void std::__function::__func<std::__bind<long long (&)(__sFILE *,char const*,std::map<std::string,std::vector<float>> &),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>,std::allocator<std::__bind<long long (&)(__sFILE *,char const*,std::map<std::string,std::vector<float>> &),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>>,long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>::~__func()
{
  JUMPOUT(0x1A1B0A898);
}

__n128 std::__function::__func<std::__bind<long long (&)(__sFILE *,char const*,std::map<std::string,std::vector<float>> &),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>,std::allocator<std::__bind<long long (&)(__sFILE *,char const*,std::map<std::string,std::vector<float>> &),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>>,long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_1E453B050;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<std::__bind<long long (&)(__sFILE *,char const*,std::map<std::string,std::vector<float>> &),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>,std::allocator<std::__bind<long long (&)(__sFILE *,char const*,std::map<std::string,std::vector<float>> &),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>>,long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_1E453B050;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind<long long (&)(__sFILE *,char const*,std::map<std::string,std::vector<float>> &),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>,std::allocator<std::__bind<long long (&)(__sFILE *,char const*,std::map<std::string,std::vector<float>> &),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>>,long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>::operator()(uint64_t a1, _QWORD *a2, _QWORD *a3, uint64_t a4)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(a1 + 8))(*a2, *a3, a4);
}

uint64_t std::__function::__func<std::__bind<long long (&)(__sFILE *,char const*,std::map<std::string,std::vector<float>> &),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>,std::allocator<std::__bind<long long (&)(__sFILE *,char const*,std::map<std::string,std::vector<float>> &),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>>,long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"NSt3__16__bindIRFxP7__sFILEPKcRNS_3mapINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_6vectorIfNS9_IfEEEENS_4lessISB_EENS9_INS_4pairIKSB_SE_EEEEEEEJRKNS_12placeholders4__phILi1EEERKNSQ_ILi2EEERKNSQ_ILi3EEEEEE"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<std::__bind<long long (&)(__sFILE *,char const*,std::map<std::string,std::vector<float>> &),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>,std::allocator<std::__bind<long long (&)(__sFILE *,char const*,std::map<std::string,std::vector<float>> &),std::placeholders::__ph<1> const&,std::placeholders::__ph<2> const&,std::placeholders::__ph<3> const&>>,long long ()(__sFILE *,char const*,std::map<std::string,std::vector<float>> &)>::target_type()
{
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::string>,void *>>>::operator()[abi:ne180100](char a1, void **__p)
{
  if (a1)
  {
    if (*((char *)__p + 47) < 0)
      operator delete(__p[3]);
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

void std::vector<std::vector<std::string>>::__assign_with_size[abi:ne180100]<std::vector<std::string>*,std::vector<std::string>*>(uint64_t a1, __int128 **a2, __int128 **a3, unint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  std::vector<std::string> *v10;
  void **v11;
  std::vector<std::string> *v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  std::string *v16;
  __int128 **v17;
  std::vector<std::string> *v18;
  void **v19;
  void **v20;

  v9 = a1 + 16;
  v8 = *(_QWORD *)(a1 + 16);
  v10 = *(std::vector<std::string> **)a1;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - *(_QWORD *)a1) >> 3) < a4)
  {
    if (v10)
    {
      v11 = *(void ***)(a1 + 8);
      v12 = *(std::vector<std::string> **)a1;
      if (v11 != (void **)v10)
      {
        do
        {
          v11 -= 3;
          v20 = v11;
          std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v20);
        }
        while (v11 != (void **)v10);
        v12 = *(std::vector<std::string> **)a1;
      }
      *(_QWORD *)(a1 + 8) = v10;
      operator delete(v12);
      v8 = 0;
      *(_QWORD *)a1 = 0;
      *(_QWORD *)(a1 + 8) = 0;
      *(_QWORD *)(a1 + 16) = 0;
    }
    if (a4 > 0xAAAAAAAAAAAAAAALL)
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    v13 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 3);
    v14 = 2 * v13;
    if (2 * v13 <= a4)
      v14 = a4;
    if (v13 >= 0x555555555555555)
      v15 = 0xAAAAAAAAAAAAAAALL;
    else
      v15 = v14;
    std::vector<std::string>::__vallocate[abi:ne180100]((_QWORD *)a1, v15);
    v16 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<std::string>>,std::vector<std::string>*,std::vector<std::string>*,std::vector<std::string>*>(v9, a2, a3, *(std::string **)(a1 + 8));
    goto LABEL_16;
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 8) - (_QWORD)v10) >> 3) < a4)
  {
    v17 = &a2[(uint64_t)(*(_QWORD *)(a1 + 8) - (_QWORD)v10) >> 3];
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<std::string> *,std::vector<std::string> *,std::vector<std::string> *>((uint64_t)a2, (uint64_t)v17, v10);
    v16 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<std::string>>,std::vector<std::string>*,std::vector<std::string>*,std::vector<std::string>*>(v9, v17, a3, *(std::string **)(a1 + 8));
LABEL_16:
    *(_QWORD *)(a1 + 8) = v16;
    return;
  }
  v18 = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<std::string> *,std::vector<std::string> *,std::vector<std::string> *>((uint64_t)a2, (uint64_t)a3, v10);
  v19 = *(void ***)(a1 + 8);
  while (v19 != (void **)v18)
  {
    v19 -= 3;
    v20 = v19;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v20);
  }
  *(_QWORD *)(a1 + 8) = v18;
}

void sub_1A14B2264(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1A14B226C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::_DetachedTreeCache::~_DetachedTreeCache[abi:ne180100](uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::destroy(*(char **)(a1 + 16));
  v2 = *(_QWORD *)(a1 + 8);
  if (v2)
  {
    v3 = *(_QWORD *)(v2 + 16);
    if (v3)
    {
      do
      {
        v2 = v3;
        v3 = *(_QWORD *)(v3 + 16);
      }
      while (v3);
      *(_QWORD *)(a1 + 8) = v2;
    }
    std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::destroy((char *)v2);
  }
  return a1;
}

void std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,float>,void *>>>::operator()[abi:ne180100](char a1, void **__p)
{
  if (a1)
  {
    if (*((char *)__p + 55) < 0)
      operator delete(__p[4]);
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

uint64_t *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<std::vector<float>> *,std::vector<std::vector<float>> *,std::vector<std::vector<float>> *>(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t *v5;

  if (a1 != a2)
  {
    v5 = a1;
    do
    {
      if (v5 != a3)
        std::vector<std::vector<float>>::__assign_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(a3, *v5, v5[1], 0xAAAAAAAAAAAAAAABLL * ((v5[1] - *v5) >> 3));
      v5 += 3;
      a3 += 3;
    }
    while (v5 != a2);
  }
  return a3;
}

_QWORD *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<std::vector<float>>>,std::vector<std::vector<float>>*,std::vector<std::vector<float>>*,std::vector<std::vector<float>>*>(uint64_t a1, uint64_t *a2, uint64_t *a3, _QWORD *a4)
{
  _QWORD *v4;
  uint64_t *v6;
  _QWORD v8[3];
  char v9;
  _QWORD *v10;
  _QWORD *v11;

  v4 = a4;
  v10 = a4;
  v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  v9 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      *v4 = 0;
      v4[1] = 0;
      v4[2] = 0;
      std::vector<std::vector<float>>::__init_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(v4, *v6, v6[1], 0xAAAAAAAAAAAAAAABLL * ((v6[1] - *v6) >> 3));
      v4 = v11 + 3;
      v11 += 3;
      v6 += 3;
    }
    while (v6 != a3);
  }
  v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<float>>>,std::vector<std::vector<float>>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_1A14B2424(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<float>>>,std::vector<std::vector<float>>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void std::vector<std::vector<std::vector<float>>>::__vdeallocate(void ***a1)
{
  void **v1;
  void **v3;
  void **v4;
  void **v5;

  v1 = *a1;
  if (*a1)
  {
    v3 = a1[1];
    v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        v3 -= 3;
        v5 = v3;
        std::vector<std::vector<long long>>::__destroy_vector::operator()[abi:ne180100](&v5);
      }
      while (v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

char *std::vector<std::vector<std::vector<float>>>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  uint64_t v3;
  char *result;

  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
  v3 = 3 * a2;
  result = (char *)operator new(24 * a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v3];
  return result;
}

_QWORD *std::vector<std::vector<float>>::__init_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;

  if (a4)
  {
    v6 = result;
    std::vector<std::string>::__vallocate[abi:ne180100](result, a4);
    result = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float>*,std::vector<float>*,std::vector<float>*>((uint64_t)(v6 + 2), a2, a3, (_QWORD *)v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1A14B2558(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<std::vector<long long>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<float>>>,std::vector<std::vector<float>>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  void **v3;
  void **v4;
  void **v5;

  if (!*(_BYTE *)(a1 + 24))
  {
    v3 = **(void ****)(a1 + 16);
    v4 = **(void ****)(a1 + 8);
    while (v3 != v4)
    {
      v3 -= 3;
      v5 = v3;
      std::vector<std::vector<long long>>::__destroy_vector::operator()[abi:ne180100](&v5);
    }
  }
  return a1;
}

_QWORD *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float>*,std::vector<float>*,std::vector<float>*>(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  _QWORD *v4;
  uint64_t v6;
  _QWORD v8[3];
  char v9;
  _QWORD *v10;
  _QWORD *v11;

  v4 = a4;
  v10 = a4;
  v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  v9 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      *v4 = 0;
      v4[1] = 0;
      v4[2] = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v4, *(const void **)v6, *(_QWORD *)(v6 + 8), (uint64_t)(*(_QWORD *)(v6 + 8) - *(_QWORD *)v6) >> 2);
      v4 = v11 + 3;
      v11 += 3;
      v6 += 24;
    }
    while (v6 != a3);
  }
  v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<unsigned int>>,std::vector<unsigned int>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_1A14B2674(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<unsigned int>>,std::vector<unsigned int>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void std::vector<std::vector<float>>::__assign_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(uint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  char *v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  void *v19;
  void *v20;

  v9 = (uint64_t)(a1 + 2);
  v8 = a1[2];
  v10 = (char *)*a1;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - *a1) >> 3) < a4)
  {
    if (v10)
    {
      std::vector<std::vector<long long>>::__clear[abi:ne180100](a1);
      operator delete((void *)*a1);
      v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 > 0xAAAAAAAAAAAAAAALL)
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    v11 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 3);
    v12 = 2 * v11;
    if (2 * v11 <= a4)
      v12 = a4;
    if (v11 >= 0x555555555555555)
      v13 = 0xAAAAAAAAAAAAAAALL;
    else
      v13 = v12;
    std::vector<std::string>::__vallocate[abi:ne180100](a1, v13);
    v14 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float>*,std::vector<float>*,std::vector<float>*>(v9, a2, a3, (_QWORD *)a1[1]);
    goto LABEL_13;
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[1] - (uint64_t)v10) >> 3) < a4)
  {
    v15 = a2 + 8 * ((a1[1] - (uint64_t)v10) >> 3);
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<unsigned int> *,std::vector<unsigned int> *,std::vector<unsigned int> *>(a2, v15, v10);
    v14 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float>*,std::vector<float>*,std::vector<float>*>(v9, v15, a3, (_QWORD *)a1[1]);
LABEL_13:
    a1[1] = (uint64_t)v14;
    return;
  }
  v16 = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<unsigned int> *,std::vector<unsigned int> *,std::vector<unsigned int> *>(a2, a3, v10);
  v17 = (char *)a1[1];
  if (v17 != v16)
  {
    v18 = (char *)a1[1];
    do
    {
      v20 = (void *)*((_QWORD *)v18 - 3);
      v18 -= 24;
      v19 = v20;
      if (v20)
      {
        *((_QWORD *)v17 - 2) = v19;
        operator delete(v19);
      }
      v17 = v18;
    }
    while (v18 != v16);
  }
  a1[1] = (uint64_t)v16;
}

void sub_1A14B27F8(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1A14B2800(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

std::vector<std::string> *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<std::string> *,std::vector<std::string> *,std::vector<std::string> *>(uint64_t a1, uint64_t a2, std::vector<std::string> *a3)
{
  uint64_t v5;

  if (a1 != a2)
  {
    v5 = a1;
    do
    {
      if ((std::vector<std::string> *)v5 != a3)
        std::vector<std::string>::__assign_with_size[abi:ne180100]<std::string*,std::string*>(a3, *(std::string **)v5, *(__int128 **)(v5 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(v5 + 8) - *(_QWORD *)v5) >> 3));
      v5 += 24;
      ++a3;
    }
    while (v5 != a2);
  }
  return a3;
}

std::string *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<std::string>>,std::vector<std::string>*,std::vector<std::string>*,std::vector<std::string>*>(uint64_t a1, __int128 **a2, __int128 **a3, std::string *a4)
{
  std::string *v4;
  __int128 **v6;
  _QWORD v8[3];
  char v9;
  std::string *v10;
  std::string *v11;

  v4 = a4;
  v10 = a4;
  v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  v9 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      v4->__r_.__value_.__r.__words[0] = 0;
      v4->__r_.__value_.__l.__size_ = 0;
      v4->__r_.__value_.__r.__words[2] = 0;
      std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(v4, *v6, v6[1], 0xAAAAAAAAAAAAAAABLL * (((char *)v6[1] - (char *)*v6) >> 3));
      v4 = ++v11;
      v6 += 3;
    }
    while (v6 != a3);
  }
  v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::string>>,std::vector<std::string>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_1A14B2920(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::string>>,std::vector<std::string>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::string>>,std::vector<std::string>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  void **v3;
  void **v4;
  void **v5;

  if (!*(_BYTE *)(a1 + 24))
  {
    v3 = **(void ****)(a1 + 16);
    v4 = **(void ****)(a1 + 8);
    while (v3 != v4)
    {
      v3 -= 3;
      v5 = v3;
      std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v5);
    }
  }
  return a1;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<std::vector<std::string>> *,std::vector<std::vector<std::string>> *,std::vector<std::vector<std::string>> *>(__int128 ***a1, __int128 ***a2, uint64_t a3)
{
  __int128 ***v5;

  if (a1 != a2)
  {
    v5 = a1;
    do
    {
      if (v5 != (__int128 ***)a3)
        std::vector<std::vector<std::string>>::__assign_with_size[abi:ne180100]<std::vector<std::string>*,std::vector<std::string>*>(a3, *v5, v5[1], 0xAAAAAAAAAAAAAAABLL * (v5[1] - *v5));
      v5 += 3;
      a3 += 24;
    }
    while (v5 != a2);
  }
  return a3;
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<std::vector<std::string>>>,std::vector<std::vector<std::string>>*,std::vector<std::vector<std::string>>*,std::vector<std::vector<std::string>>*>(uint64_t a1, __int128 ***a2, __int128 ***a3, uint64_t a4)
{
  uint64_t v4;
  __int128 ***v6;
  __int128 **v7;
  __int128 **v8;
  _QWORD v10[3];
  char v11;
  uint64_t v12;
  _QWORD v13[2];
  char v14;

  v4 = a4;
  v12 = a4;
  v13[0] = a4;
  v10[0] = a1;
  v10[1] = &v12;
  v10[2] = v13;
  v11 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      *(_QWORD *)v4 = 0;
      *(_QWORD *)(v4 + 8) = 0;
      *(_QWORD *)(v4 + 16) = 0;
      v7 = *v6;
      v8 = v6[1];
      v13[1] = v4;
      v14 = 0;
      if (v8 != v7)
      {
        std::vector<std::string>::__vallocate[abi:ne180100]((_QWORD *)v4, 0xAAAAAAAAAAAAAAABLL * (v8 - v7));
        *(_QWORD *)(v4 + 8) = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<std::string>>,std::vector<std::string>*,std::vector<std::string>*,std::vector<std::string>*>(v4 + 16, v7, v8, *(std::string **)(v4 + 8));
        v4 = v13[0];
      }
      v4 += 24;
      v13[0] = v4;
      v6 += 3;
    }
    while (v6 != a3);
  }
  v11 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<std::string>>>,std::vector<std::vector<std::string>>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v10);
  return v4;
}

void sub_1A14B2AE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void **a15)
{
  std::vector<std::vector<std::string>>::__destroy_vector::operator()[abi:ne180100](&a15);
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<std::string>>>,std::vector<std::vector<std::string>>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<std::string>>>,std::vector<std::vector<std::string>>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  void **v3;
  void **v4;
  void **v5;

  if (!*(_BYTE *)(a1 + 24))
  {
    v3 = **(void ****)(a1 + 16);
    v4 = **(void ****)(a1 + 8);
    while (v3 != v4)
    {
      v3 -= 3;
      v5 = v3;
      std::vector<std::vector<std::string>>::__destroy_vector::operator()[abi:ne180100](&v5);
    }
  }
  return a1;
}

void std::__shared_ptr_emplace<vision::mod::ImageAnalyzerConcrete>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453B680;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<vision::mod::ImageAnalyzerConcrete>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453B680;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A1B0A898);
}

void std::__shared_ptr_emplace<vision::mod::ImageAnalyzerConcrete>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2;
  void **v3;
  void **v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  void *v10;
  void *v11;
  _QWORD *v12;
  _QWORD *v13;
  void *v14;
  char *v15;
  char *v16;
  void *v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  _QWORD *v24;
  _QWORD *v25;
  void *v26;
  void **v27;
  void **v28;
  void *v29;
  void **v30;

  if (*(_BYTE *)(a1 + 656))
  {
    espresso_plan_destroy();
    espresso_context_destroy();
  }
  v2 = *(_QWORD *)(a1 + 1080);
  *(_QWORD *)(a1 + 1080) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *(void ***)(a1 + 1008);
  if (v3)
  {
    do
    {
      v4 = (void **)*v3;
      if (*((char *)v3 + 39) < 0)
        operator delete(v3[2]);
      operator delete(v3);
      v3 = v4;
    }
    while (v4);
  }
  v5 = *(void **)(a1 + 992);
  *(_QWORD *)(a1 + 992) = 0;
  if (v5)
    operator delete(v5);
  v6 = *(_QWORD *)(a1 + 968);
  if (v6)
  {
    v7 = *(_QWORD *)(a1 + 976);
    v8 = *(void **)(a1 + 968);
    if (v7 != v6)
    {
      v9 = *(_QWORD *)(a1 + 976);
      do
      {
        v11 = *(void **)(v9 - 24);
        v9 -= 24;
        v10 = v11;
        if (v11)
        {
          *(_QWORD *)(v7 - 16) = v10;
          operator delete(v10);
        }
        v7 = v9;
      }
      while (v9 != v6);
      v8 = *(void **)(a1 + 968);
    }
    *(_QWORD *)(a1 + 976) = v6;
    operator delete(v8);
  }
  v12 = *(_QWORD **)(a1 + 944);
  if (v12)
  {
    do
    {
      v13 = (_QWORD *)*v12;
      std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table((uint64_t)(v12 + 3));
      operator delete(v12);
      v12 = v13;
    }
    while (v13);
  }
  v14 = *(void **)(a1 + 928);
  *(_QWORD *)(a1 + 928) = 0;
  if (v14)
    operator delete(v14);
  v15 = *(char **)(a1 + 904);
  if (v15)
  {
    do
    {
      v16 = *(char **)v15;
      v30 = (void **)(v15 + 24);
      std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v30);
      operator delete(v15);
      v15 = v16;
    }
    while (v16);
  }
  v17 = *(void **)(a1 + 888);
  *(_QWORD *)(a1 + 888) = 0;
  if (v17)
    operator delete(v17);
  v18 = *(_QWORD **)(a1 + 864);
  if (v18)
  {
    do
    {
      v19 = (_QWORD *)*v18;
      operator delete(v18);
      v18 = v19;
    }
    while (v19);
  }
  v20 = *(void **)(a1 + 848);
  *(_QWORD *)(a1 + 848) = 0;
  if (v20)
    operator delete(v20);
  v21 = *(_QWORD **)(a1 + 824);
  if (v21)
  {
    do
    {
      v22 = (_QWORD *)*v21;
      operator delete(v21);
      v21 = v22;
    }
    while (v22);
  }
  v23 = *(void **)(a1 + 808);
  *(_QWORD *)(a1 + 808) = 0;
  if (v23)
    operator delete(v23);
  v24 = *(_QWORD **)(a1 + 784);
  if (v24)
  {
    do
    {
      v25 = (_QWORD *)*v24;
      std::__destroy_at[abi:ne180100]<std::pair<vision::mod::ImageAnalyzer_AnalysisType const,vision::mod::ImageAnalyzer_PostProcessor>,0>((uint64_t)(v24 + 2));
      operator delete(v24);
      v24 = v25;
    }
    while (v25);
  }
  v26 = *(void **)(a1 + 768);
  *(_QWORD *)(a1 + 768) = 0;
  if (v26)
    operator delete(v26);
  v27 = *(void ***)(a1 + 744);
  if (v27)
  {
    do
    {
      v28 = (void **)*v27;
      if (*((char *)v27 + 47) < 0)
        operator delete(v27[3]);
      operator delete(v27);
      v27 = v28;
    }
    while (v28);
  }
  v29 = *(void **)(a1 + 728);
  *(_QWORD *)(a1 + 728) = 0;
  if (v29)
    operator delete(v29);
  if (*(char *)(a1 + 695) < 0)
    operator delete(*(void **)(a1 + 672));
  std::unique_ptr<vision::mod::ImageProcessing_Preprocessor>::reset[abi:ne180100]((uint64_t *)(a1 + 664), 0);
  vision::mod::ImageAnalyzer_Options::~ImageAnalyzer_Options((vision::mod::ImageAnalyzer_Options *)(a1 + 24));
}

_QWORD *std::vector<unsigned long>::__init_with_size[abi:ne180100]<unsigned long *,unsigned long *>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<long long>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1A14B2E40(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t vision::mod::ImageAnalyzer_PostProcessor::getOutputSize(vision::mod::ImageAnalyzer_PostProcessor *this, uint64_t a2)
{
  uint64_t **v4;
  uint64_t *v5;
  uint64_t **v6;
  std::string *v7;
  uint64_t v8;
  _QWORD *exception;
  _QWORD v11[2];
  char v12;
  uint64_t v13;

  if (!std::string::compare((const std::string *)this, "unknown"))
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = 8564;
    __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
  }
  v4 = (uint64_t **)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__find_equal<std::string>((uint64_t)this + 72, &v13, this);
  v5 = *v4;
  if (!*v4)
  {
    v6 = v4;
    v5 = (uint64_t *)operator new(0x58uLL);
    v11[0] = v5;
    v11[1] = (char *)this + 80;
    v12 = 0;
    v7 = (std::string *)(v5 + 4);
    if (*((char *)this + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)this, *((_QWORD *)this + 1));
    }
    else
    {
      *(_OWORD *)&v7->__r_.__value_.__l.__data_ = *(_OWORD *)this;
      v5[6] = *((_QWORD *)this + 2);
    }
    v5[10] = 0;
    v12 = 1;
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at((uint64_t **)this + 9, v13, v6, v5);
    v11[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,void *>>>>::reset[abi:ne180100]((uint64_t)v11);
  }
  v11[0] = a2;
  v8 = v5[10];
  if (!v8)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)v8 + 48))(v8, v11);
}

void sub_1A14B2F70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,void *>>>>::reset[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType const&>,std::tuple<>>(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  void **v9;
  _QWORD *v10;
  unint64_t v11;
  float v12;
  float v13;
  _BOOL8 v14;
  unint64_t v15;
  unint64_t v16;
  size_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;

  v6 = a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & a2;
    }
    v9 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2)
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  v10 = operator new(0x30uLL);
  *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v10[4] = 0;
  v10[5] = 0;
  v10[3] = 0;
  v12 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    v14 = 1;
    if (v7 >= 3)
      v14 = (v7 & (v7 - 1)) != 0;
    v15 = v14 | (2 * v7);
    v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16)
      v17 = v16;
    else
      v17 = v15;
    std::__hash_table<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>>>::__rehash<true>(a1, v17);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & v6;
    }
  }
  v18 = *(_QWORD *)a1;
  v19 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v19)
  {
    *v10 = *v19;
LABEL_38:
    *v19 = v10;
    goto LABEL_39;
  }
  *v10 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v10;
  *(_QWORD *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    v20 = *(_QWORD *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7)
        v20 %= v7;
    }
    else
    {
      v20 &= v7 - 1;
    }
    v19 = (_QWORD *)(*(_QWORD *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v10;
}

void sub_1A14B3188(_Unwind_Exception *a1)
{
  void **v1;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,void *>>>::operator()[abi:ne180100](1, v1);
  _Unwind_Resume(a1);
}

char *std::__hash_table<std::__hash_value_type<std::string,espresso_buffer_t>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,espresso_buffer_t>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,espresso_buffer_t>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,espresso_buffer_t>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t *a1, unsigned __int8 *a2, __int128 **a3)
{
  unint64_t v3;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  unint64_t v14;
  std::string *v15;
  __int128 *v16;
  __int128 v17;
  _QWORD *v18;
  float v19;
  float v20;
  _BOOL8 v21;
  unint64_t v22;
  unint64_t v23;
  int8x8_t prime;
  void *v25;
  void *v26;
  uint64_t v27;
  _QWORD *v28;
  unint64_t v29;
  uint8x8_t v30;
  unint64_t v31;
  uint8x8_t v32;
  uint64_t v33;
  _QWORD *v34;
  unint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  unint64_t v38;
  void *v40;

  v7 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)a2);
  v8 = v7;
  v9 = a1[1];
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      v3 = v7;
      if (v7 >= v9)
        v3 = v7 % v9;
    }
    else
    {
      v3 = (v9 - 1) & v7;
    }
    v12 = *(void ***)(*a1 + 8 * v3);
    if (v12)
    {
      v13 = (char *)*v12;
      if (*v12)
      {
        do
        {
          v14 = *((_QWORD *)v13 + 1);
          if (v14 == v8)
          {
            if (std::equal_to<std::string>::operator()[abi:ne180100]((unsigned __int8 *)v13 + 16, a2))
              return v13;
          }
          else
          {
            if (v11 > 1)
            {
              if (v14 >= v9)
                v14 %= v9;
            }
            else
            {
              v14 &= v9 - 1;
            }
            if (v14 != v3)
              break;
          }
          v13 = *(char **)v13;
        }
        while (v13);
      }
    }
  }
  v13 = (char *)operator new(0xD0uLL);
  *(_QWORD *)v13 = 0;
  *((_QWORD *)v13 + 1) = v8;
  v15 = (std::string *)(v13 + 16);
  v16 = *a3;
  if (*((char *)*a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v15, *(const std::string::value_type **)v16, *((_QWORD *)v16 + 1));
  }
  else
  {
    v17 = *v16;
    *((_QWORD *)v13 + 4) = *((_QWORD *)v16 + 2);
    *(_OWORD *)&v15->__r_.__value_.__l.__data_ = v17;
  }
  v18 = a1 + 2;
  *((_QWORD *)v13 + 25) = 0;
  *(_OWORD *)(v13 + 184) = 0u;
  *(_OWORD *)(v13 + 168) = 0u;
  *(_OWORD *)(v13 + 152) = 0u;
  *(_OWORD *)(v13 + 136) = 0u;
  *(_OWORD *)(v13 + 120) = 0u;
  *(_OWORD *)(v13 + 104) = 0u;
  *(_OWORD *)(v13 + 88) = 0u;
  *(_OWORD *)(v13 + 72) = 0u;
  *(_OWORD *)(v13 + 56) = 0u;
  *(_OWORD *)(v13 + 40) = 0u;
  v19 = (float)(unint64_t)(a1[3] + 1);
  v20 = *((float *)a1 + 8);
  if (!v9 || (float)(v20 * (float)v9) < v19)
  {
    v21 = 1;
    if (v9 >= 3)
      v21 = (v9 & (v9 - 1)) != 0;
    v22 = v21 | (2 * v9);
    v23 = vcvtps_u32_f32(v19 / v20);
    if (v22 <= v23)
      prime = (int8x8_t)v23;
    else
      prime = (int8x8_t)v22;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    }
    v9 = a1[1];
    if (*(_QWORD *)&prime > v9)
      goto LABEL_33;
    if (*(_QWORD *)&prime < v9)
    {
      v31 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v9 < 3 || (v32 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v32.i16[0] = vaddlv_u8(v32), v32.u32[0] > 1uLL))
      {
        v31 = std::__next_prime(v31);
      }
      else
      {
        v33 = 1 << -(char)__clz(v31 - 1);
        if (v31 >= 2)
          v31 = v33;
      }
      if (*(_QWORD *)&prime <= v31)
        prime = (int8x8_t)v31;
      if (*(_QWORD *)&prime >= v9)
      {
        v9 = a1[1];
      }
      else
      {
        if (prime)
        {
LABEL_33:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v25 = operator new(8 * *(_QWORD *)&prime);
          v26 = (void *)*a1;
          *a1 = (uint64_t)v25;
          if (v26)
            operator delete(v26);
          v27 = 0;
          a1[1] = (uint64_t)prime;
          do
            *(_QWORD *)(*a1 + 8 * v27++) = 0;
          while (*(_QWORD *)&prime != v27);
          v28 = (_QWORD *)*v18;
          if (*v18)
          {
            v29 = v28[1];
            v30 = (uint8x8_t)vcnt_s8(prime);
            v30.i16[0] = vaddlv_u8(v30);
            if (v30.u32[0] > 1uLL)
            {
              if (v29 >= *(_QWORD *)&prime)
                v29 %= *(_QWORD *)&prime;
            }
            else
            {
              v29 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*a1 + 8 * v29) = v18;
            v34 = (_QWORD *)*v28;
            if (*v28)
            {
              do
              {
                v35 = v34[1];
                if (v30.u32[0] > 1uLL)
                {
                  if (v35 >= *(_QWORD *)&prime)
                    v35 %= *(_QWORD *)&prime;
                }
                else
                {
                  v35 &= *(_QWORD *)&prime - 1;
                }
                if (v35 != v29)
                {
                  if (!*(_QWORD *)(*a1 + 8 * v35))
                  {
                    *(_QWORD *)(*a1 + 8 * v35) = v28;
                    goto LABEL_58;
                  }
                  *v28 = *v34;
                  *v34 = **(_QWORD **)(*a1 + 8 * v35);
                  **(_QWORD **)(*a1 + 8 * v35) = v34;
                  v34 = v28;
                }
                v35 = v29;
LABEL_58:
                v28 = v34;
                v34 = (_QWORD *)*v34;
                v29 = v35;
              }
              while (v34);
            }
          }
          v9 = (unint64_t)prime;
          goto LABEL_62;
        }
        v40 = (void *)*a1;
        *a1 = 0;
        if (v40)
          operator delete(v40);
        v9 = 0;
        a1[1] = 0;
      }
    }
LABEL_62:
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
  }
  v36 = *a1;
  v37 = *(_QWORD **)(*a1 + 8 * v3);
  if (v37)
  {
    *(_QWORD *)v13 = *v37;
LABEL_75:
    *v37 = v13;
    goto LABEL_76;
  }
  *(_QWORD *)v13 = *v18;
  *v18 = v13;
  *(_QWORD *)(v36 + 8 * v3) = v18;
  if (*(_QWORD *)v13)
  {
    v38 = *(_QWORD *)(*(_QWORD *)v13 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v38 >= v9)
        v38 %= v9;
    }
    else
    {
      v38 &= v9 - 1;
    }
    v37 = (_QWORD *)(*a1 + 8 * v38);
    goto LABEL_75;
  }
LABEL_76:
  ++a1[3];
  return v13;
}

void sub_1A14B35E0(_Unwind_Exception *a1)
{
  void **v1;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,float>,void *>>>::operator()[abi:ne180100](0, v1);
  _Unwind_Resume(a1);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<espresso_buffer_t>>(unint64_t a1)
{
  if (a1 >= 0x186186186186187)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(168 * a1);
}

vision::mod::ImageAnalyzer *vision::mod::ImageAnalyzer::analyzeUsingCVPixelBuffer(vision::mod::ImageAnalyzer *this, int a2, __CVBuffer *a3)
{
  unint64_t v3;
  uint64_t *v5;
  uint64_t *v6;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  void **v11;
  _QWORD *v12;
  unint64_t v13;
  float v14;
  float v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  size_t v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;
  uint64_t *v23;
  int v24;
  unint64_t v25;
  unsigned int *v26;
  int v27;
  unsigned int v28;
  int v29;
  BOOL v30;
  char v31;
  unint64_t v32;
  uint8x8_t v33;
  uint64_t **v34;
  uint64_t *i;
  unint64_t v36;
  char *v37;
  float v38;
  float v39;
  _BOOL8 v40;
  unint64_t v41;
  unint64_t v42;
  size_t v43;
  uint64_t v44;
  _QWORD *v45;
  unint64_t v46;
  int8x8_t v47;
  unint64_t v48;
  uint8x8_t v49;
  unint64_t v50;
  uint64_t **v51;
  uint64_t *v52;
  unint64_t v53;
  _QWORD *v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  char *v58;
  uint64_t OutputSize;
  _QWORD *v60;
  unsigned int v61;
  char *v62;
  unint64_t v63;
  int8x8_t v64;
  unint64_t v65;
  uint8x8_t v66;
  unint64_t v67;
  char *v68;
  uint64_t *v69;
  unsigned __int8 **v70;
  unsigned __int8 *v71;
  unint64_t v72;
  _QWORD *v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  uint8x8_t v77;
  void **v78;
  _QWORD *v79;
  unint64_t v80;
  float v81;
  float v82;
  _BOOL8 v83;
  unint64_t v84;
  unint64_t v85;
  size_t v86;
  uint64_t v87;
  _QWORD *v88;
  unint64_t v89;
  uint64_t v90;
  char *v91;
  uint64_t v92;
  int v93;
  uint64_t v94;
  uint64_t v95;
  _QWORD *v96;
  unint64_t v97;
  unint64_t v98;
  unint64_t v99;
  uint64_t v100;
  unint64_t v101;
  unint64_t v102;
  unint64_t v103;
  unint64_t v104;
  uint64_t v105;
  std::string *v106;
  unint64_t v107;
  _QWORD *v108;
  _QWORD *v109;
  unint64_t v110;
  unint64_t v111;
  uint64_t v112;
  unint64_t v113;
  uint64_t v114;
  char *v115;
  char *v116;
  char *v117;
  size_t v118;
  char *v119;
  __int128 v120;
  _QWORD *v121;
  _QWORD *v122;
  void *v123;
  void *v124;
  _QWORD *v125;
  _QWORD *v126;
  void *v127;
  void *v128;
  uint64_t v129;
  uint64_t v130;
  _QWORD *v131;
  char *v132;
  void **v133;
  char *v134;
  uint64_t v135;
  unint64_t v136;
  uint64_t v137;
  uint64_t v138;
  _QWORD *v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  unint64_t v143;
  char *v144;
  uint64_t v145;
  char *v146;
  char *v147;
  size_t v148;
  char *v149;
  char *v150;
  char *v151;
  __int128 v152;
  __int128 v153;
  __int128 v154;
  __int128 v155;
  __int128 v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  char *v160;
  uint64_t v161;
  char v162;
  char v163;
  uint64_t v164;
  __int128 v165;
  uint64_t *v166;
  unsigned int v167;
  int v168;
  unsigned int v169;
  int v170;
  int v171;
  unsigned int v172;
  _QWORD *v174;
  _QWORD *exception;
  uint64_t v176;
  uint64_t v177;
  _QWORD *v178;
  uint64_t v179;
  unsigned __int8 *v180;
  _QWORD *v181;
  _QWORD *v182;
  std::string::size_type v183;
  std::string::size_type v184;
  std::string::size_type v185;
  uint64_t *v186;
  _QWORD *v187;
  _QWORD *v188;
  uint64_t v189;
  uint64_t *v191;
  __int128 __dst;
  std::string::size_type v193;
  std::string v194;
  void *__p;
  char v196;
  uint64_t v197;
  std::__split_buffer<std::string> __v;

  v5 = (uint64_t *)((char *)this + 824);
  v6 = (uint64_t *)*((_QWORD *)this + 105);
  if (v6)
  {
    v7 = (_QWORD *)((char *)this + 840);
    v8 = *((_QWORD *)this + 104);
    do
    {
      v9 = *((unsigned int *)v6 + 4);
      if (v8)
      {
        v10 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
        v10.i16[0] = vaddlv_u8(v10);
        if (v10.u32[0] > 1uLL)
        {
          v3 = *((unsigned int *)v6 + 4);
          if (v8 <= v9)
            v3 = v9 % v8;
        }
        else
        {
          v3 = ((_DWORD)v8 - 1) & v9;
        }
        v11 = *(void ***)(*v5 + 8 * v3);
        if (v11)
        {
          v12 = *v11;
          if (*v11)
          {
            do
            {
              v13 = v12[1];
              if (v13 == v9)
              {
                if (*((_DWORD *)v12 + 4) == (_DWORD)v9)
                  goto LABEL_41;
              }
              else
              {
                if (v10.u32[0] > 1uLL)
                {
                  if (v13 >= v8)
                    v13 %= v8;
                }
                else
                {
                  v13 &= v8 - 1;
                }
                if (v13 != v3)
                  break;
              }
              v12 = (_QWORD *)*v12;
            }
            while (v12);
          }
        }
      }
      v12 = operator new(0x18uLL);
      *v12 = 0;
      v12[1] = v9;
      *((_DWORD *)v12 + 4) = *((_DWORD *)v6 + 4);
      *((_BYTE *)v12 + 20) = 0;
      v14 = (float)(unint64_t)(*((_QWORD *)this + 106) + 1);
      v15 = *((float *)this + 214);
      if (!v8 || (float)(v15 * (float)v8) < v14)
      {
        v16 = (v8 & (v8 - 1)) != 0;
        if (v8 < 3)
          v16 = 1;
        v17 = v16 | (2 * v8);
        v18 = vcvtps_u32_f32(v14 / v15);
        if (v17 <= v18)
          v19 = v18;
        else
          v19 = v17;
        std::__hash_table<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>>>::__rehash<true>((uint64_t)v5, v19);
        v8 = *((_QWORD *)this + 104);
        if ((v8 & (v8 - 1)) != 0)
        {
          if (v8 <= v9)
            v3 = v9 % v8;
          else
            v3 = v9;
        }
        else
        {
          v3 = ((_DWORD)v8 - 1) & v9;
        }
      }
      v20 = *v5;
      v21 = *(_QWORD **)(*v5 + 8 * v3);
      if (v21)
      {
        *v12 = *v21;
      }
      else
      {
        *v12 = *v7;
        *v7 = v12;
        *(_QWORD *)(v20 + 8 * v3) = v7;
        if (!*v12)
          goto LABEL_40;
        v22 = *(_QWORD *)(*v12 + 8);
        if ((v8 & (v8 - 1)) != 0)
        {
          if (v22 >= v8)
            v22 %= v8;
        }
        else
        {
          v22 &= v8 - 1;
        }
        v21 = (_QWORD *)(*v5 + 8 * v22);
      }
      *v21 = v12;
LABEL_40:
      ++*((_QWORD *)this + 106);
LABEL_41:
      *((_BYTE *)v12 + 20) = 0;
      v6 = (uint64_t *)*v6;
    }
    while (v6);
  }
  v179 = (uint64_t)v5;
  v181 = (_QWORD *)((char *)this + 720);
  v23 = (uint64_t *)*((_QWORD *)this + 90);
  v24 = a2;
  if (!v23)
    goto LABEL_216;
  v191 = (uint64_t *)((char *)this + 784);
  v186 = (uint64_t *)((char *)this + 704);
  v188 = (_QWORD *)((char *)this + 864);
  v184 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
  v185 = *MEMORY[0x1E0DE4F60];
  v182 = (_QWORD *)((char *)this + 800);
  v178 = (_QWORD *)((char *)this + 744);
  v180 = (unsigned __int8 *)this + 216;
  v183 = MEMORY[0x1E0DE4FB8] + 16;
  do
  {
    v26 = (unsigned int *)(v23 + 2);
    v25 = *((unsigned int *)v23 + 4);
    if (!(_DWORD)v25)
      goto LABEL_49;
    v27 = -1;
    v28 = *((_DWORD *)v23 + 4);
    do
    {
      ++v27;
      v30 = v28 > 1;
      v28 >>= 1;
    }
    while (v30);
    if (v27 == -1)
LABEL_49:
      v29 = 0;
    else
      v29 = 1 << v27;
    v30 = (v29 & v24) != 0 || v25 > 0x2000;
    v31 = !v30;
    if ((_DWORD)v25 == 64 || (v31 & 1) != 0)
      goto LABEL_215;
    if (*((char *)v23 + 47) < 0)
    {
      if (!v23[4])
      {
LABEL_296:
        exception = __cxa_allocate_exception(8uLL);
        v176 = 8574;
        goto LABEL_297;
      }
    }
    else if (!*((_BYTE *)v23 + 47))
    {
      goto LABEL_296;
    }
    v32 = *((_QWORD *)this + 99);
    if (v32)
    {
      v33 = (uint8x8_t)vcnt_s8((int8x8_t)v32);
      v33.i16[0] = vaddlv_u8(v33);
      if (v33.u32[0] > 1uLL)
      {
        v3 = *((unsigned int *)v23 + 4);
        if (v32 <= v25)
          v3 = v25 % v32;
      }
      else
      {
        v3 = ((_DWORD)v32 - 1) & v25;
      }
      v34 = *(uint64_t ***)(*v191 + 8 * v3);
      if (v34)
      {
        for (i = *v34; i; i = (uint64_t *)*i)
        {
          v36 = i[1];
          if (v36 == v25)
          {
            if (*((_DWORD *)i + 4) == (_DWORD)v25)
              goto LABEL_100;
          }
          else
          {
            if (v33.u32[0] > 1uLL)
            {
              if (v36 >= v32)
                v36 %= v32;
            }
            else
            {
              v36 &= v32 - 1;
            }
            if (v36 != v3)
              break;
          }
        }
      }
    }
    v37 = (char *)operator new(0xC0uLL);
    *(_QWORD *)v37 = 0;
    *((_QWORD *)v37 + 1) = v25;
    *((_DWORD *)v37 + 4) = *v26;
    *((_QWORD *)v37 + 23) = 0;
    *(_OWORD *)(v37 + 168) = 0u;
    *(_OWORD *)(v37 + 152) = 0u;
    *(_OWORD *)(v37 + 136) = 0u;
    *(_OWORD *)(v37 + 120) = 0u;
    *(_OWORD *)(v37 + 104) = 0u;
    *(_OWORD *)(v37 + 88) = 0u;
    *(_OWORD *)(v37 + 72) = 0u;
    *(_OWORD *)(v37 + 56) = 0u;
    *(_OWORD *)(v37 + 40) = 0u;
    *(_OWORD *)(v37 + 24) = 0u;
    v38 = (float)(unint64_t)(*((_QWORD *)this + 101) + 1);
    v39 = *((float *)this + 204);
    if (!v32 || (float)(v39 * (float)v32) < v38)
    {
      v40 = (v32 & (v32 - 1)) != 0;
      if (v32 < 3)
        v40 = 1;
      v41 = v40 | (2 * v32);
      v42 = vcvtps_u32_f32(v38 / v39);
      if (v41 <= v42)
        v43 = v42;
      else
        v43 = v41;
      std::__hash_table<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>>>::__rehash<true>((uint64_t)v191, v43);
      v32 = *((_QWORD *)this + 99);
      if ((v32 & (v32 - 1)) != 0)
      {
        if (v32 <= v25)
          v3 = v25 % v32;
        else
          v3 = v25;
      }
      else
      {
        v3 = ((_DWORD)v32 - 1) & v25;
      }
    }
    v44 = *v191;
    v45 = *(_QWORD **)(*v191 + 8 * v3);
    if (v45)
    {
      *(_QWORD *)v37 = *v45;
    }
    else
    {
      *(_QWORD *)v37 = *v182;
      *v182 = v37;
      *(_QWORD *)(v44 + 8 * v3) = v182;
      if (!*(_QWORD *)v37)
        goto LABEL_99;
      v46 = *(_QWORD *)(*(_QWORD *)v37 + 8);
      if ((v32 & (v32 - 1)) != 0)
      {
        if (v46 >= v32)
          v46 %= v32;
      }
      else
      {
        v46 &= v32 - 1;
      }
      v45 = (_QWORD *)(*v191 + 8 * v46);
    }
    *v45 = v37;
LABEL_99:
    ++*((_QWORD *)this + 101);
LABEL_100:
    if (espresso_network_bind_buffer())
      goto LABEL_295;
    v47 = *(int8x8_t *)((char *)this + 872);
    v24 = a2;
    if (!*(_QWORD *)&v47)
      goto LABEL_215;
    v48 = *v26;
    v49 = (uint8x8_t)vcnt_s8(v47);
    v49.i16[0] = vaddlv_u8(v49);
    if (v49.u32[0] > 1uLL)
    {
      v50 = *v26;
      if (*(_QWORD *)&v47 <= v48)
        v50 = v48 % *(_QWORD *)&v47;
    }
    else
    {
      v50 = (v47.i32[0] - 1) & v48;
    }
    v51 = *(uint64_t ***)(*v188 + 8 * v50);
    if (!v51)
      goto LABEL_215;
    v52 = *v51;
    if (!v52)
      goto LABEL_215;
    while (1)
    {
      v53 = v52[1];
      if (v53 == v48)
        break;
      if (v49.u32[0] > 1uLL)
      {
        if (v53 >= *(_QWORD *)&v47)
          v53 %= *(_QWORD *)&v47;
      }
      else
      {
        v53 &= *(_QWORD *)&v47 - 1;
      }
      if (v53 != v50)
        goto LABEL_215;
LABEL_116:
      v52 = (uint64_t *)*v52;
      if (!v52)
        goto LABEL_215;
    }
    if (*((_DWORD *)v52 + 4) != (_DWORD)v48)
      goto LABEL_116;
    v54 = std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType const&>,std::tuple<>>((uint64_t)v188, v48, (_DWORD *)v23 + 4);
    v56 = v54[3];
    v55 = v54[4];
    v57 = *v26 & a2;
    if (v57 <= 31)
    {
      v3 = 4;
      if (v57 == 2)
      {
        LODWORD(v194.__r_.__value_.__l.__data_) = 2;
        v3 = 2;
        v68 = std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>((uint64_t)v191, 2u, &v194);
        OutputSize = *((_QWORD *)v68 + 14)
                   * *((_QWORD *)v68 + 13)
                   * *((_QWORD *)v68 + 15)
                   * *((_QWORD *)v68 + 16)
                   * *((_QWORD *)v68 + 17);
        if (!std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>>>::find<vision::mod::ImageAnalyzer_AnalysisType>(v178, 2u))goto LABEL_151;
        LODWORD(v194.__r_.__value_.__l.__data_) = 2;
        v60 = (_QWORD *)((char *)this + 744);
        v61 = 2;
      }
      else
      {
        if (v57 != 4)
          goto LABEL_300;
        LODWORD(v194.__r_.__value_.__l.__data_) = 4;
        v62 = std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>((uint64_t)v191, 4u, &v194);
        OutputSize = *((_QWORD *)v62 + 14)
                   * *((_QWORD *)v62 + 13)
                   * *((_QWORD *)v62 + 15)
                   * *((_QWORD *)v62 + 16)
                   * *((_QWORD *)v62 + 17);
        if (!std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>>>::find<vision::mod::ImageAnalyzer_AnalysisType>(v178, 2u))goto LABEL_151;
        LODWORD(v194.__r_.__value_.__l.__data_) = 4;
        v60 = (_QWORD *)((char *)this + 744);
        v61 = 4;
      }
LABEL_135:
      v69 = std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(v60, v61, &v194);
      OutputSize = vision::mod::ImageAnalyzer_PostProcessor::getOutputSize((vision::mod::ImageAnalyzer_PostProcessor *)(v69 + 3), OutputSize);
      goto LABEL_151;
    }
    v3 = 4096;
    if (v57 == 32)
    {
      LODWORD(v194.__r_.__value_.__l.__data_) = 32;
      OutputSize = *((_QWORD *)std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>((uint64_t)v191, 0x20u, &v194)+ 15);
      goto LABEL_151;
    }
    if (v57 != 64)
    {
      if (v57 != 4096)
        goto LABEL_300;
      LODWORD(v194.__r_.__value_.__l.__data_) = 4096;
      v58 = std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>((uint64_t)v191, 0x1000u, &v194);
      OutputSize = *((_QWORD *)v58 + 14)
                 * *((_QWORD *)v58 + 13)
                 * *((_QWORD *)v58 + 15)
                 * *((_QWORD *)v58 + 16)
                 * *((_QWORD *)v58 + 17);
      if (!std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>>>::find<vision::mod::ImageAnalyzer_AnalysisType>(v178, 0x1000u))goto LABEL_151;
      LODWORD(v194.__r_.__value_.__l.__data_) = 4096;
      v60 = (_QWORD *)((char *)this + 744);
      v61 = 4096;
      goto LABEL_135;
    }
    if (!*((_BYTE *)this + 461))
    {
      OutputSize = *(_QWORD *)(**((_QWORD **)this + 118) + 264);
      goto LABEL_151;
    }
    v177 = v54[4];
    v63 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)v180);
    v64 = *(int8x8_t *)((char *)this + 976);
    if (!*(_QWORD *)&v64)
      goto LABEL_298;
    v65 = v63;
    v66 = (uint8x8_t)vcnt_s8(v64);
    v66.i16[0] = vaddlv_u8(v66);
    v3 = v66.u32[0];
    if (v66.u32[0] > 1uLL)
    {
      v67 = v63;
      if (v63 >= *(_QWORD *)&v64)
        v67 = v63 % *(_QWORD *)&v64;
    }
    else
    {
      v67 = (*(_QWORD *)&v64 - 1) & v63;
    }
    v70 = *(unsigned __int8 ***)(*((_QWORD *)this + 121) + 8 * v67);
    if (!v70 || (v71 = *v70) == 0)
LABEL_298:
      std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
    while (2)
    {
      v72 = *((_QWORD *)v71 + 1);
      if (v72 != v65)
      {
        if (v3 > 1)
        {
          if (v72 >= *(_QWORD *)&v64)
            v72 %= *(_QWORD *)&v64;
        }
        else
        {
          v72 &= *(_QWORD *)&v64 - 1;
        }
        if (v72 != v67)
          goto LABEL_298;
LABEL_149:
        v71 = *(unsigned __int8 **)v71;
        if (!v71)
          goto LABEL_298;
        continue;
      }
      break;
    }
    if (!std::equal_to<std::string>::operator()[abi:ne180100](v71 + 16, v180))
      goto LABEL_149;
    OutputSize = *((_QWORD *)v71 + 17);
    v55 = v177;
LABEL_151:
    if (v55 == v56)
    {
      v24 = a2;
      if (!OutputSize)
        goto LABEL_215;
      v74 = 0;
      while (2)
      {
        std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v194);
        v75 = *v26;
        v76 = *((_QWORD *)this + 89);
        if (v76)
        {
          v77 = (uint8x8_t)vcnt_s8((int8x8_t)v76);
          v77.i16[0] = vaddlv_u8(v77);
          if (v77.u32[0] > 1uLL)
          {
            v3 = *v26;
            if (v76 <= v75)
              v3 = v75 % v76;
          }
          else
          {
            v3 = ((_DWORD)v76 - 1) & v75;
          }
          v78 = *(void ***)(*v186 + 8 * v3);
          if (v78)
          {
            v79 = *v78;
            if (*v78)
            {
              do
              {
                v80 = v79[1];
                if (v80 == v75)
                {
                  if (*((_DWORD *)v79 + 4) == (_DWORD)v75)
                    goto LABEL_194;
                }
                else
                {
                  if (v77.u32[0] > 1uLL)
                  {
                    if (v80 >= v76)
                      v80 %= v76;
                  }
                  else
                  {
                    v80 &= v76 - 1;
                  }
                  if (v80 != v3)
                    break;
                }
                v79 = (_QWORD *)*v79;
              }
              while (v79);
            }
          }
        }
        v79 = operator new(0x30uLL);
        *v79 = 0;
        v79[1] = v75;
        *((_DWORD *)v79 + 4) = *v26;
        v79[4] = 0;
        v79[5] = 0;
        v79[3] = 0;
        v81 = (float)(unint64_t)(*((_QWORD *)this + 91) + 1);
        v82 = *((float *)this + 184);
        if (!v76 || (float)(v82 * (float)v76) < v81)
        {
          v83 = (v76 & (v76 - 1)) != 0;
          if (v76 < 3)
            v83 = 1;
          v84 = v83 | (2 * v76);
          v85 = vcvtps_u32_f32(v81 / v82);
          if (v84 <= v85)
            v86 = v85;
          else
            v86 = v84;
          std::__hash_table<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>>>::__rehash<true>((uint64_t)v186, v86);
          v76 = *((_QWORD *)this + 89);
          if ((v76 & (v76 - 1)) != 0)
          {
            if (v76 <= v75)
              v3 = v75 % v76;
            else
              v3 = v75;
          }
          else
          {
            v3 = ((_DWORD)v76 - 1) & v75;
          }
        }
        v87 = *v186;
        v88 = *(_QWORD **)(*v186 + 8 * v3);
        if (v88)
        {
          *v79 = *v88;
          goto LABEL_192;
        }
        *v79 = *v181;
        *v181 = v79;
        *(_QWORD *)(v87 + 8 * v3) = v181;
        if (*v79)
        {
          v89 = *(_QWORD *)(*v79 + 8);
          if ((v76 & (v76 - 1)) != 0)
          {
            if (v89 >= v76)
              v89 %= v76;
          }
          else
          {
            v89 &= v76 - 1;
          }
          v88 = (_QWORD *)(*v186 + 8 * v89);
LABEL_192:
          *v88 = v79;
        }
        ++*((_QWORD *)this + 91);
LABEL_194:
        v92 = v79[3];
        v91 = (char *)(v79 + 3);
        v90 = v92;
        v93 = v91[23];
        if (v93 >= 0)
          v94 = (uint64_t)v91;
        else
          v94 = v90;
        if (v93 >= 0)
          v95 = v91[23];
        else
          v95 = *((_QWORD *)v91 + 1);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v194, v94, v95);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v194, (uint64_t)"-", 1);
        std::ostream::operator<<();
        v96 = std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType const&>,std::tuple<>>((uint64_t)v188, *v26, (_DWORD *)v23 + 4);
        std::stringbuf::str[abi:ne180100]<std::allocator<char>>(&__dst, (uint64_t)&v194.__r_.__value_.__l.__size_);
        v97 = v96[5];
        v98 = v96[4];
        if (v98 >= v97)
        {
          v100 = v96[3];
          v101 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v98 - v100) >> 3);
          v102 = v101 + 1;
          if (v101 + 1 > 0xAAAAAAAAAAAAAAALL)
            std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
          v103 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v97 - v100) >> 3);
          if (2 * v103 > v102)
            v102 = 2 * v103;
          if (v103 >= 0x555555555555555)
            v104 = 0xAAAAAAAAAAAAAAALL;
          else
            v104 = v102;
          __v.__end_cap_.__value_ = (std::allocator<std::string> *)(v96 + 5);
          if (v104)
            v104 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(v104);
          else
            v105 = 0;
          v106 = (std::string *)(v104 + 24 * v101);
          __v.__first_ = (std::__split_buffer<std::string>::pointer)v104;
          __v.__begin_ = v106;
          __v.__end_cap_.__value_ = (std::string *)(v104 + 24 * v105);
          *(_OWORD *)&v106->__r_.__value_.__l.__data_ = __dst;
          v106->__r_.__value_.__r.__words[2] = v193;
          __dst = 0uLL;
          v193 = 0;
          __v.__end_ = v106 + 1;
          std::vector<std::string>::__swap_out_circular_buffer((std::vector<std::string> *)v96 + 1, &__v);
          v99 = v96[4];
          std::__split_buffer<std::string>::~__split_buffer(&__v);
          v24 = a2;
        }
        else
        {
          *(_OWORD *)v98 = __dst;
          *(_QWORD *)(v98 + 16) = v193;
          v99 = v98 + 24;
        }
        v96[4] = v99;
        v194.__r_.__value_.__r.__words[0] = v185;
        *(std::string::size_type *)((char *)v194.__r_.__value_.__r.__words + *(_QWORD *)(v185 - 24)) = v184;
        v194.__r_.__value_.__l.__size_ = v183;
        if (v196 < 0)
          operator delete(__p);
        std::streambuf::~streambuf();
        std::ostream::~ostream();
        MEMORY[0x1A1B0A808](&v197);
        if (++v74 == OutputSize)
          goto LABEL_215;
        continue;
      }
    }
    v73 = std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType const&>,std::tuple<>>((uint64_t)v188, *v26, (_DWORD *)v23 + 4);
    v24 = a2;
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v73[4] - v73[3]) >> 3) != OutputSize)
    {
LABEL_300:
      exception = __cxa_allocate_exception(8uLL);
      v176 = 8572;
LABEL_297:
      *exception = v176;
      __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
    }
LABEL_215:
    v23 = (uint64_t *)*v23;
  }
  while (v23);
LABEL_216:
  if ((v24 & 0x40) == 0)
    goto LABEL_275;
  if (!*((_BYTE *)this + 461))
  {
    v107 = *((_QWORD *)this + 54);
    v108 = (_QWORD *)*((_QWORD *)this + 119);
    v109 = (_QWORD *)*((_QWORD *)this + 118);
    v110 = 0xAAAAAAAAAAAAAAABLL * (v108 - v109);
    v111 = v107 - v110;
    if (v107 <= v110)
    {
      if (v107 < v110)
      {
        v125 = &v109[3 * v107];
        if (v108 != v125)
        {
          v126 = (_QWORD *)*((_QWORD *)this + 119);
          do
          {
            v128 = (void *)*(v126 - 3);
            v126 -= 3;
            v127 = v128;
            if (v128)
            {
              *(v108 - 2) = v127;
              operator delete(v127);
            }
            v108 = v126;
          }
          while (v126 != v125);
        }
        *((_QWORD *)this + 119) = v125;
      }
    }
    else
    {
      v112 = *((_QWORD *)this + 120);
      if (0xAAAAAAAAAAAAAAABLL * ((v112 - (uint64_t)v108) >> 3) >= v111)
      {
        bzero(*((void **)this + 119), 24 * ((24 * v111 - 24) / 0x18) + 24);
        *((_QWORD *)this + 119) = &v108[3 * ((24 * v111 - 24) / 0x18) + 3];
      }
      else
      {
        if (v107 > 0xAAAAAAAAAAAAAAALL)
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        v113 = 0xAAAAAAAAAAAAAAABLL * ((v112 - (uint64_t)v109) >> 3);
        if (2 * v113 > v107)
          v107 = 2 * v113;
        if (v113 >= 0x555555555555555)
          v107 = 0xAAAAAAAAAAAAAAALL;
        if (v107 > 0xAAAAAAAAAAAAAAALL)
          std::__throw_bad_array_new_length[abi:ne180100]();
        v114 = 3 * v107;
        v115 = (char *)operator new(24 * v107);
        v116 = &v115[8 * (v108 - v109)];
        v117 = &v115[8 * v114];
        v118 = 24 * ((24 * v111 - 24) / 0x18) + 24;
        bzero(v116, v118);
        v119 = &v116[v118];
        if (v108 == v109)
        {
          *((_QWORD *)this + 118) = v116;
          *((_QWORD *)this + 119) = v119;
          *((_QWORD *)this + 120) = v117;
        }
        else
        {
          do
          {
            *((_QWORD *)v116 - 3) = 0;
            *((_QWORD *)v116 - 2) = 0;
            v116 -= 24;
            *((_QWORD *)v116 + 2) = 0;
            v120 = *(_OWORD *)(v108 - 3);
            v108 -= 3;
            *(_OWORD *)v116 = v120;
            *((_QWORD *)v116 + 2) = v108[2];
            *v108 = 0;
            v108[1] = 0;
            v108[2] = 0;
          }
          while (v108 != v109);
          v121 = (_QWORD *)*((_QWORD *)this + 118);
          v108 = (_QWORD *)*((_QWORD *)this + 119);
          *((_QWORD *)this + 118) = v116;
          *((_QWORD *)this + 119) = v119;
          *((_QWORD *)this + 120) = v117;
          if (v108 != v121)
          {
            v122 = v108;
            do
            {
              v124 = (void *)*(v122 - 3);
              v122 -= 3;
              v123 = v124;
              if (v124)
              {
                *(v108 - 2) = v123;
                operator delete(v123);
              }
              v108 = v122;
            }
            while (v122 != v121);
            v108 = v121;
          }
        }
        if (v108)
          operator delete(v108);
      }
    }
    if (!*((_QWORD *)this + 54))
      goto LABEL_275;
    v129 = 0;
    while (1)
    {
      v130 = *((_QWORD *)this + 118);
      v131 = (_QWORD *)(v130 + 24 * v129);
      v133 = (void **)(v131 + 1);
      v132 = (char *)v131[1];
      v134 = (char *)*v131;
      v135 = (uint64_t)&v132[-*v131];
      v136 = 0xCF3CF3CF3CF3CF3DLL * (v135 >> 3);
      if (v136 > 1)
      {
        if (v135 == 336)
          goto LABEL_266;
        v160 = v134 + 336;
      }
      else
      {
        v137 = v130 + 24 * v129;
        v140 = *(_QWORD *)(v137 + 16);
        v139 = (_QWORD *)(v137 + 16);
        v138 = v140;
        if (0xCF3CF3CF3CF3CF3DLL * ((v140 - (uint64_t)v132) >> 3) < 2 - v136)
        {
          v187 = v139;
          v141 = 0xCF3CF3CF3CF3CF3DLL * ((v138 - (uint64_t)v134) >> 3);
          v142 = 2 * v141;
          if (2 * v141 <= 2)
            v142 = 2;
          if (v141 >= 0xC30C30C30C30C3)
            v143 = 0x186186186186186;
          else
            v143 = v142;
          v144 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<espresso_buffer_t>>(v143);
          v189 = v145;
          v146 = &v144[8 * (v135 >> 3)];
          v147 = v144;
          v148 = 168 * ((168 - v135) / 0xA8uLL) + 168;
          bzero(v146, v148);
          v149 = (char *)*v133;
          v150 = (char *)*v131;
          v151 = v146;
          if (*v133 != (void *)*v131)
          {
            do
            {
              v152 = *(_OWORD *)(v149 - 168);
              v153 = *(_OWORD *)(v149 - 152);
              *(_OWORD *)(v151 - 136) = *(_OWORD *)(v149 - 136);
              *(_OWORD *)(v151 - 152) = v153;
              *(_OWORD *)(v151 - 168) = v152;
              v154 = *(_OWORD *)(v149 - 120);
              v155 = *(_OWORD *)(v149 - 104);
              v156 = *(_OWORD *)(v149 - 88);
              *(_OWORD *)(v151 - 72) = *(_OWORD *)(v149 - 72);
              *(_OWORD *)(v151 - 88) = v156;
              *(_OWORD *)(v151 - 104) = v155;
              *(_OWORD *)(v151 - 120) = v154;
              v157 = *(_OWORD *)(v149 - 56);
              v158 = *(_OWORD *)(v149 - 40);
              v159 = *(_OWORD *)(v149 - 24);
              *((_QWORD *)v151 - 1) = *((_QWORD *)v149 - 1);
              *(_OWORD *)(v151 - 24) = v159;
              *(_OWORD *)(v151 - 40) = v158;
              *(_OWORD *)(v151 - 56) = v157;
              v151 -= 168;
              v149 -= 168;
            }
            while (v149 != v150);
            v149 = (char *)*v131;
          }
          *v131 = v151;
          *v133 = &v146[v148];
          *v187 = &v147[168 * v189];
          if (v149)
            operator delete(v149);
          goto LABEL_266;
        }
        bzero(v132, 168 * ((168 - v135) / 0xA8uLL) + 168);
        v160 = &v132[168 * ((168 - v135) / 0xA8uLL) + 168];
      }
      *v133 = v160;
LABEL_266:
      v161 = 0;
      v162 = 1;
      do
      {
        v163 = v162;
        v164 = *(_QWORD *)(*((_QWORD *)this + 64) + 24 * v129) + 24 * v161;
        if (*(char *)(v164 + 23) < 0)
        {
          std::string::__init_copy_ctor_external(&v194, *(const std::string::value_type **)v164, *(_QWORD *)(v164 + 8));
        }
        else
        {
          v165 = *(_OWORD *)v164;
          v194.__r_.__value_.__r.__words[2] = *(_QWORD *)(v164 + 16);
          *(_OWORD *)&v194.__r_.__value_.__l.__data_ = v165;
        }
        if (espresso_network_bind_buffer())
        {
          espresso_plan_get_error_info();
          v174 = __cxa_allocate_exception(8uLL);
          *v174 = 8539;
          __cxa_throw(v174, MEMORY[0x1E0DE4F28], 0);
        }
        if (SHIBYTE(v194.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v194.__r_.__value_.__l.__data_);
        v162 = 0;
        v161 = 1;
      }
      while ((v163 & 1) != 0);
      if ((unint64_t)++v129 >= *((_QWORD *)this + 54))
        goto LABEL_275;
    }
  }
  v194.__r_.__value_.__r.__words[0] = (std::string::size_type)this + 216;
  std::__hash_table<std::__hash_value_type<std::string,espresso_buffer_t>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,espresso_buffer_t>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,espresso_buffer_t>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,espresso_buffer_t>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t *)this + 121, (unsigned __int8 *)this + 216, (__int128 **)&v194);
  if (espresso_network_bind_buffer())
    goto LABEL_295;
  v194.__r_.__value_.__r.__words[0] = (std::string::size_type)this + 240;
  std::__hash_table<std::__hash_value_type<std::string,espresso_buffer_t>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,espresso_buffer_t>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,espresso_buffer_t>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,espresso_buffer_t>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t *)this + 121, (unsigned __int8 *)this + 240, (__int128 **)&v194);
  if (espresso_network_bind_buffer())
    goto LABEL_295;
LABEL_275:
  if (espresso_network_bind_cvpixelbuffer() || espresso_plan_execute_sync())
  {
LABEL_295:
    espresso_plan_get_error_info();
    exception = __cxa_allocate_exception(8uLL);
    v176 = 8539;
    goto LABEL_297;
  }
  v166 = (uint64_t *)*v181;
  if (*v181)
  {
    do
    {
      v167 = *((_DWORD *)v166 + 4);
      if (!v167)
        goto LABEL_283;
      v168 = -1;
      v169 = *((_DWORD *)v166 + 4);
      do
      {
        ++v168;
        v30 = v169 > 1;
        v169 >>= 1;
      }
      while (v30);
      if (v168 == -1)
LABEL_283:
        v170 = 0;
      else
        v170 = 1 << v168;
      if ((v170 & a2) != 0)
      {
        if (!v167)
          goto LABEL_290;
        v171 = -1;
        do
        {
          ++v171;
          v30 = v167 > 1;
          v167 >>= 1;
        }
        while (v30);
        if (v171 == -1)
LABEL_290:
          v172 = 0;
        else
          v172 = 1 << v171;
        LODWORD(v194.__r_.__value_.__l.__data_) = v172;
        *((_BYTE *)std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(v179, v172, &v194)+ 20) = 1;
      }
      v166 = (uint64_t *)*v166;
    }
    while (v166);
  }
  return this;
}

void sub_1A14B492C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (a31 < 0)
    operator delete(__p);
  std::ostringstream::~ostringstream((uint64_t)&a32);
  _Unwind_Resume(a1);
}

char *std::__hash_table<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1, unsigned __int8 *a2, __int128 **a3)
{
  unint64_t v3;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  unint64_t v14;
  _QWORD *v15;
  std::string *v16;
  __int128 *v17;
  __int128 v18;
  float v19;
  float v20;
  _BOOL8 v21;
  unint64_t v22;
  unint64_t v23;
  size_t v24;
  uint64_t v25;
  _QWORD *v26;
  unint64_t v27;
  _QWORD v29[2];
  char v30;

  v7 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)a2);
  v8 = v7;
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      v3 = v7;
      if (v7 >= v9)
        v3 = v7 % v9;
    }
    else
    {
      v3 = (v9 - 1) & v7;
    }
    v12 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v12)
    {
      v13 = (char *)*v12;
      if (*v12)
      {
        do
        {
          v14 = *((_QWORD *)v13 + 1);
          if (v14 == v8)
          {
            if (std::equal_to<std::string>::operator()[abi:ne180100]((unsigned __int8 *)v13 + 16, a2))
              return v13;
          }
          else
          {
            if (v11 > 1)
            {
              if (v14 >= v9)
                v14 %= v9;
            }
            else
            {
              v14 &= v9 - 1;
            }
            if (v14 != v3)
              break;
          }
          v13 = *(char **)v13;
        }
        while (v13);
      }
    }
  }
  v15 = (_QWORD *)(a1 + 16);
  v13 = (char *)operator new(0x40uLL);
  v29[0] = v13;
  v29[1] = a1 + 16;
  v30 = 0;
  *(_QWORD *)v13 = 0;
  *((_QWORD *)v13 + 1) = v8;
  v16 = (std::string *)(v13 + 16);
  v17 = *a3;
  if (*((char *)*a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v16, *(const std::string::value_type **)v17, *((_QWORD *)v17 + 1));
  }
  else
  {
    v18 = *v17;
    *((_QWORD *)v13 + 4) = *((_QWORD *)v17 + 2);
    *(_OWORD *)&v16->__r_.__value_.__l.__data_ = v18;
  }
  *((_QWORD *)v13 + 5) = 0;
  *((_QWORD *)v13 + 6) = 0;
  *((_QWORD *)v13 + 7) = 0;
  v30 = 1;
  v19 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v20 = *(float *)(a1 + 32);
  if (!v9 || (float)(v20 * (float)v9) < v19)
  {
    v21 = 1;
    if (v9 >= 3)
      v21 = (v9 & (v9 - 1)) != 0;
    v22 = v21 | (2 * v9);
    v23 = vcvtps_u32_f32(v19 / v20);
    if (v22 <= v23)
      v24 = v23;
    else
      v24 = v22;
    std::__hash_table<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>>>::__rehash<true>(a1, v24);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
  }
  v25 = *(_QWORD *)a1;
  v26 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v26)
  {
    *(_QWORD *)v13 = *v26;
LABEL_41:
    *v26 = v13;
    goto LABEL_42;
  }
  *(_QWORD *)v13 = *v15;
  *v15 = v13;
  *(_QWORD *)(v25 + 8 * v3) = v15;
  if (*(_QWORD *)v13)
  {
    v27 = *(_QWORD *)(*(_QWORD *)v13 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v27 >= v9)
        v27 %= v9;
    }
    else
    {
      v27 &= v9 - 1;
    }
    v26 = (_QWORD *)(*(_QWORD *)a1 + 8 * v27);
    goto LABEL_41;
  }
LABEL_42:
  v29[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,void *>>>>::reset[abi:ne180100]((uint64_t)v29);
  return v13;
}

void sub_1A14B4C10(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,void *>>>>::reset[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<std::tuple<float,_Geometry2D_rect2D_>>::reserve(uint64_t a1)
{
  _BYTE *v1;
  _BYTE *v3;
  char *v4;
  char *v5;
  char *v6;
  char *v7;
  __int128 v8;

  v1 = *(_BYTE **)a1;
  if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 2) <= 0x18)
  {
    v3 = *(_BYTE **)(a1 + 8);
    v4 = (char *)operator new(0x1F4uLL);
    v5 = &v4[20 * ((v3 - v1) / 20)];
    v6 = v5;
    if (v3 != v1)
    {
      v7 = &v4[20 * ((v3 - v1) / 20)];
      do
      {
        v6 = v7 - 20;
        v8 = *(_OWORD *)(v3 - 20);
        *((_DWORD *)v7 - 1) = *((_DWORD *)v3 - 1);
        *(_OWORD *)(v7 - 20) = v8;
        v3 -= 20;
        v7 -= 20;
      }
      while (v3 != v1);
    }
    *(_QWORD *)a1 = v6;
    *(_QWORD *)(a1 + 8) = v5;
    *(_QWORD *)(a1 + 16) = v4 + 500;
    if (v1)
      operator delete(v1);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<float,_Geometry2D_rect2D_>>>(unint64_t a1)
{
  if (a1 >= 0xCCCCCCCCCCCCCCDLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(20 * a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::vector<float>>,0>((uint64_t)v1 + 16);
    operator delete(v1);
  }
}

BOOL vision::mod::sortDetectionsByConfidence(float *a1, float *a2)
{
  return *a1 > *a2;
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(std::tuple<float,_Geometry2D_rect2D_>,std::tuple<float,_Geometry2D_rect2D_>),std::tuple<float,_Geometry2D_rect2D_>*,false>(uint64_t a1, int *a2, uint64_t (**a3)(__int128 *, __int128 *), uint64_t a4, char a5)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  __int128 *v12;
  uint64_t v13;
  int v14;
  uint64_t (*v15)(__int128 *, __int128 *);
  int v16;
  int v17;
  int v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t (*v21)(__int128 *, __int128 *);
  int v22;
  int *v23;
  int *v24;
  uint64_t (*v25)(__int128 *, __int128 *);
  int v26;
  int v27;
  int *v28;
  uint64_t (*v29)(__int128 *, __int128 *);
  int v30;
  char v31;
  int *v32;
  int v33;
  int v34;
  __int128 v35;
  uint64_t (*v36)(__int128 *, __int128 *);
  int v37;
  __int128 v38;
  uint64_t (*v39)(__int128 *, __int128 *);
  BOOL v40;
  BOOL v41;
  int v42;
  uint64_t (*v43)(__int128 *, __int128 *);
  __int128 v44;
  unint64_t v45;
  int *v46;
  uint64_t (*v47)(__int128 *, __int128 *);
  __int128 v48;
  char v49;
  unint64_t v50;
  uint64_t (*v51)(__int128 *, __int128 *);
  __int128 v52;
  int v53;
  _OWORD *v54;
  int *v55;
  int *v56;
  uint64_t (*v57)(__int128 *, __int128 *);
  __int128 v58;
  _OWORD *v59;
  char v60;
  int v61;
  __int128 v62;
  int v63;
  uint64_t (*v64)(__int128 *, __int128 *);
  __int128 v65;
  int v66;
  uint64_t (*v67)(__int128 *, __int128 *);
  uint64_t (*v68)(__int128 *, __int128 *);
  int v69;
  int v70;
  int v71;
  int *v72;
  uint64_t v73;
  int *v74;
  int *v75;
  uint64_t (*v76)(__int128 *, __int128 *);
  int v77;
  int v78;
  int v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t (*v83)(__int128 *, __int128 *);
  __int128 v84;
  char v85;
  _DWORD *v86;
  _OWORD *v87;
  int64_t v88;
  int64_t v89;
  int64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t (*v94)(__int128 *, __int128 *);
  int v95;
  int v96;
  int *v97;
  uint64_t (*v98)(__int128 *, __int128 *);
  int v99;
  int v100;
  char v101;
  int v102;
  int *v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t (*v106)(__int128 *, __int128 *);
  int v107;
  int v108;
  uint64_t (*v109)(__int128 *, __int128 *);
  int v110;
  int64_t v111;
  int *v112;
  uint64_t v113;
  int v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t (*v121)(__int128 *, __int128 *);
  int v122;
  int v123;
  _OWORD *v124;
  uint64_t v125;
  unint64_t v126;
  uint64_t v127;
  uint64_t (*v128)(__int128 *, __int128 *);
  int v129;
  int v130;
  int v131;
  uint64_t v132;
  uint64_t (*v133)(__int128 *, __int128 *);
  int v134;
  int *v136;
  _OWORD *v137;
  int *v138;
  uint64_t (*v139)(__int128 *, __int128 *);
  int v140;
  int v141;
  int v142;
  _OWORD *v143;
  _OWORD *v144;
  uint64_t (*v145)(__int128 *, __int128 *);
  __int128 v146;
  char v147;
  __int128 *v148;
  __int128 *v149;
  int *v151;
  uint64_t v152;
  int64_t v154;
  int *v155;
  int *v156;
  __int128 v157;
  int v158;
  __int128 v159;
  int v160;
  __int128 v161;
  int v162;
  __int128 v163;
  int v164;
  __int128 v165;
  int v166;
  _OWORD v167[2];
  __int128 v168;
  __int128 v169;
  _BYTE v170[20];
  _BYTE v171[20];
  _BYTE v172[20];
  __int128 v173;
  int v174;
  _BYTE v175[20];
  _BYTE v176[20];
  _BYTE v177[20];
  _BYTE v178[20];
  _BYTE v179[20];

char *std::vector<std::tuple<float,_Geometry2D_rect2D_>>::__assign_with_size[abi:ne180100]<std::tuple<float,_Geometry2D_rect2D_>*,std::tuple<float,_Geometry2D_rect2D_>*>(char **a1, __int128 *a2, __int128 *a3, unint64_t a4)
{
  __int128 *v6;
  uint64_t v8;
  char *result;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  char *v14;
  __int128 v15;
  uint64_t v16;
  void **v17;
  char *v18;
  char *v19;
  unint64_t v20;
  __int128 *v21;
  char *v22;
  __int128 v23;
  char *v24;

  v6 = a2;
  v8 = (uint64_t)a1[2];
  result = *a1;
  if (0xCCCCCCCCCCCCCCCDLL * ((v8 - (uint64_t)result) >> 2) >= a4)
  {
    v19 = a1[1];
    v17 = (void **)(a1 + 1);
    v18 = v19;
    v20 = 0xCCCCCCCCCCCCCCCDLL * ((v19 - result) >> 2);
    if (v20 >= a4)
    {
      v24 = result;
      while (v6 != a3)
      {
        *(_DWORD *)v24 = *(_DWORD *)v6;
        *(_OWORD *)(v24 + 4) = *(__int128 *)((char *)v6 + 4);
        v24 += 20;
        v6 = (__int128 *)((char *)v6 + 20);
      }
      v16 = v24 - result;
    }
    else
    {
      v21 = (__int128 *)((char *)a2 + 20 * v20);
      if (v18 != result)
      {
        do
        {
          *(_DWORD *)result = *(_DWORD *)v6;
          *(_OWORD *)(result + 4) = *(__int128 *)((char *)v6 + 4);
          v6 = (__int128 *)((char *)v6 + 20);
          result += 20;
        }
        while (v6 != v21);
        result = (char *)*v17;
      }
      v22 = result;
      if (v21 != a3)
      {
        v22 = result;
        do
        {
          v23 = *v21;
          *((_DWORD *)v22 + 4) = *((_DWORD *)v21 + 4);
          *(_OWORD *)v22 = v23;
          v22 += 20;
          v21 = (__int128 *)((char *)v21 + 20);
        }
        while (v21 != a3);
      }
      v16 = v22 - result;
    }
  }
  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 > 0xCCCCCCCCCCCCCCCLL)
      goto LABEL_28;
    v10 = 0xCCCCCCCCCCCCCCCDLL * (v8 >> 2);
    v11 = 2 * v10;
    if (2 * v10 <= a4)
      v11 = a4;
    v12 = v10 >= 0x666666666666666 ? 0xCCCCCCCCCCCCCCCLL : v11;
    if (v12 > 0xCCCCCCCCCCCCCCCLL)
LABEL_28:
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::tuple<float,_Geometry2D_rect2D_>>>(v12);
    a1[1] = result;
    *a1 = result;
    a1[2] = &result[20 * v13];
    v14 = result;
    if (v6 != a3)
    {
      v14 = result;
      do
      {
        v15 = *v6;
        *((_DWORD *)v14 + 4) = *((_DWORD *)v6 + 4);
        *(_OWORD *)v14 = v15;
        v14 += 20;
        v6 = (__int128 *)((char *)v6 + 20);
      }
      while (v6 != a3);
    }
    v16 = v14 - result;
    v17 = (void **)(a1 + 1);
  }
  *v17 = &result[v16];
  return result;
}

__n128 std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::tuple<float,_Geometry2D_rect2D_>,std::tuple<float,_Geometry2D_rect2D_>),std::tuple<float,_Geometry2D_rect2D_>*>(__int128 *a1, __int128 *a2, __int128 *a3, uint64_t (**a4)(__int128 *, __int128 *))
{
  uint64_t (*v8)(__int128 *, __int128 *);
  char v9;
  uint64_t (*v10)(__int128 *, __int128 *);
  int v11;
  __n128 *v12;
  int v13;
  __n128 result;
  int v15;
  __int128 v16;
  uint64_t (*v17)(__int128 *, __int128 *);
  __int128 v18;
  int v19;
  __n128 v20;
  uint64_t (*v21)(__int128 *, __int128 *);
  __int128 v22;
  int v23;
  __int128 v24;
  int v25;
  __int128 v26;
  int v27;
  __int128 v28;
  int v29;
  __int128 v30;
  int v31;
  __int128 v32;
  int v33;
  __int128 v34;
  int v35;
  __int128 v36;
  int v37;
  __int128 v38;
  int v39;
  __int128 v40;
  int v41;

  v8 = *a4;
  v40 = *a2;
  v41 = *((_DWORD *)a2 + 4);
  v38 = *a1;
  v39 = *((_DWORD *)a1 + 4);
  v9 = v8(&v40, &v38);
  v10 = *a4;
  if ((v9 & 1) != 0)
  {
    v28 = *a3;
    v29 = *((_DWORD *)a3 + 4);
    v26 = *a2;
    v27 = *((_DWORD *)a2 + 4);
    v11 = v10(&v28, &v26);
    v12 = (__n128 *)((char *)a1 + 4);
    v13 = *(_DWORD *)a1;
    if (v11)
    {
      *(_DWORD *)a1 = *(_DWORD *)a3;
    }
    else
    {
      *(_DWORD *)a1 = *(_DWORD *)a2;
      *(_DWORD *)a2 = v13;
      v20 = *v12;
      *v12 = *(__n128 *)((char *)a2 + 4);
      *(__int128 *)((char *)a2 + 4) = (__int128)v20;
      v21 = *a4;
      v24 = *a3;
      v25 = *((_DWORD *)a3 + 4);
      v23 = *((_DWORD *)a2 + 4);
      v22 = *a2;
      if (!v21(&v24, &v22))
        return result;
      v12 = (__n128 *)((char *)a2 + 4);
      v13 = *(_DWORD *)a2;
      *(_DWORD *)a2 = *(_DWORD *)a3;
    }
    *(_DWORD *)a3 = v13;
    result = *v12;
    *v12 = *(__n128 *)((char *)a3 + 4);
    *(__int128 *)((char *)a3 + 4) = (__int128)result;
  }
  else
  {
    v36 = *a3;
    v37 = *((_DWORD *)a3 + 4);
    v34 = *a2;
    v35 = *((_DWORD *)a2 + 4);
    if (v10(&v36, &v34))
    {
      v15 = *(_DWORD *)a2;
      *(_DWORD *)a2 = *(_DWORD *)a3;
      *(_DWORD *)a3 = v15;
      v16 = *(__int128 *)((char *)a2 + 4);
      *(__int128 *)((char *)a2 + 4) = *(__int128 *)((char *)a3 + 4);
      *(__int128 *)((char *)a3 + 4) = v16;
      v17 = *a4;
      v33 = *((_DWORD *)a2 + 4);
      v32 = *a2;
      v18 = *a1;
      v31 = *((_DWORD *)a1 + 4);
      v30 = v18;
      if (v17(&v32, &v30))
      {
        v19 = *(_DWORD *)a1;
        *(_DWORD *)a1 = *(_DWORD *)a2;
        *(_DWORD *)a2 = v19;
        result = *(__n128 *)((char *)a1 + 4);
        *(__int128 *)((char *)a1 + 4) = *(__int128 *)((char *)a2 + 4);
        *(__int128 *)((char *)a2 + 4) = (__int128)result;
      }
    }
  }
  return result;
}

__n128 std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::tuple<float,_Geometry2D_rect2D_>,std::tuple<float,_Geometry2D_rect2D_>),std::tuple<float,_Geometry2D_rect2D_>*>(int *a1, __int128 *a2, __int128 *a3, __int128 *a4, uint64_t (**a5)(__int128 *, __int128 *))
{
  uint64_t (*v10)(__int128 *, __int128 *);
  __n128 result;
  int v12;
  __int128 v13;
  uint64_t (*v14)(__int128 *, __int128 *);
  __int128 v15;
  int v16;
  __int128 v17;
  uint64_t (*v18)(__int128 *, __int128 *);
  __int128 v19;
  int v20;
  __int128 v21;
  int v22;
  __int128 v23;
  int v24;
  __int128 v25;
  int v26;
  __int128 v27;
  int v28;
  __int128 v29;
  int v30;
  __int128 v31;
  int v32;

  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::tuple<float,_Geometry2D_rect2D_>,std::tuple<float,_Geometry2D_rect2D_>),std::tuple<float,_Geometry2D_rect2D_>*>((__int128 *)a1, a2, a3, a5);
  v10 = *a5;
  v31 = *a4;
  v32 = *((_DWORD *)a4 + 4);
  v29 = *a3;
  v30 = *((_DWORD *)a3 + 4);
  if (v10(&v31, &v29))
  {
    v12 = *(_DWORD *)a3;
    *(_DWORD *)a3 = *(_DWORD *)a4;
    *(_DWORD *)a4 = v12;
    v13 = *(__int128 *)((char *)a3 + 4);
    *(__int128 *)((char *)a3 + 4) = *(__int128 *)((char *)a4 + 4);
    *(__int128 *)((char *)a4 + 4) = v13;
    v14 = *a5;
    v28 = *((_DWORD *)a3 + 4);
    v27 = *a3;
    v15 = *a2;
    v26 = *((_DWORD *)a2 + 4);
    v25 = v15;
    if (v14(&v27, &v25))
    {
      v16 = *(_DWORD *)a2;
      *(_DWORD *)a2 = *(_DWORD *)a3;
      *(_DWORD *)a3 = v16;
      v17 = *(__int128 *)((char *)a2 + 4);
      *(__int128 *)((char *)a2 + 4) = *(__int128 *)((char *)a3 + 4);
      *(__int128 *)((char *)a3 + 4) = v17;
      v18 = *a5;
      v24 = *((_DWORD *)a2 + 4);
      v23 = *a2;
      v19 = *(_OWORD *)a1;
      v22 = a1[4];
      v21 = v19;
      if (v18(&v23, &v21))
      {
        v20 = *a1;
        *a1 = *(_DWORD *)a2;
        *(_DWORD *)a2 = v20;
        result = *(__n128 *)(a1 + 1);
        *(_OWORD *)(a1 + 1) = *(__int128 *)((char *)a2 + 4);
        *(__int128 *)((char *)a2 + 4) = (__int128)result;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::tuple<float,_Geometry2D_rect2D_>,std::tuple<float,_Geometry2D_rect2D_>),std::tuple<float,_Geometry2D_rect2D_>*>(__int128 *a1, __int128 *a2, __int128 *a3, __int128 *a4, __int128 *a5, uint64_t (**a6)(__int128 *, __int128 *))
{
  uint64_t (*v12)(__int128 *, __int128 *);
  __n128 result;
  int v14;
  __int128 v15;
  uint64_t (*v16)(__int128 *, __int128 *);
  __int128 v17;
  int v18;
  __int128 v19;
  uint64_t (*v20)(__int128 *, __int128 *);
  __int128 v21;
  int v22;
  __int128 v23;
  uint64_t (*v24)(__int128 *, __int128 *);
  __int128 v25;
  int v26;
  __int128 v27;
  int v28;
  __int128 v29;
  int v30;
  __int128 v31;
  int v32;
  __int128 v33;
  int v34;
  __int128 v35;
  int v36;
  __int128 v37;
  int v38;
  __int128 v39;
  int v40;
  __int128 v41;
  int v42;

  std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::tuple<float,_Geometry2D_rect2D_>,std::tuple<float,_Geometry2D_rect2D_>),std::tuple<float,_Geometry2D_rect2D_>*>((int *)a1, a2, a3, a4, a6);
  v12 = *a6;
  v41 = *a5;
  v42 = *((_DWORD *)a5 + 4);
  v39 = *a4;
  v40 = *((_DWORD *)a4 + 4);
  if (v12(&v41, &v39))
  {
    v14 = *(_DWORD *)a4;
    *(_DWORD *)a4 = *(_DWORD *)a5;
    *(_DWORD *)a5 = v14;
    v15 = *(__int128 *)((char *)a4 + 4);
    *(__int128 *)((char *)a4 + 4) = *(__int128 *)((char *)a5 + 4);
    *(__int128 *)((char *)a5 + 4) = v15;
    v16 = *a6;
    v38 = *((_DWORD *)a4 + 4);
    v37 = *a4;
    v17 = *a3;
    v36 = *((_DWORD *)a3 + 4);
    v35 = v17;
    if (v16(&v37, &v35))
    {
      v18 = *(_DWORD *)a3;
      *(_DWORD *)a3 = *(_DWORD *)a4;
      *(_DWORD *)a4 = v18;
      v19 = *(__int128 *)((char *)a3 + 4);
      *(__int128 *)((char *)a3 + 4) = *(__int128 *)((char *)a4 + 4);
      *(__int128 *)((char *)a4 + 4) = v19;
      v20 = *a6;
      v34 = *((_DWORD *)a3 + 4);
      v33 = *a3;
      v21 = *a2;
      v32 = *((_DWORD *)a2 + 4);
      v31 = v21;
      if (v20(&v33, &v31))
      {
        v22 = *(_DWORD *)a2;
        *(_DWORD *)a2 = *(_DWORD *)a3;
        *(_DWORD *)a3 = v22;
        v23 = *(__int128 *)((char *)a2 + 4);
        *(__int128 *)((char *)a2 + 4) = *(__int128 *)((char *)a3 + 4);
        *(__int128 *)((char *)a3 + 4) = v23;
        v24 = *a6;
        v30 = *((_DWORD *)a2 + 4);
        v29 = *a2;
        v25 = *a1;
        v28 = *((_DWORD *)a1 + 4);
        v27 = v25;
        if (v24(&v29, &v27))
        {
          v26 = *(_DWORD *)a1;
          *(_DWORD *)a1 = *(_DWORD *)a2;
          *(_DWORD *)a2 = v26;
          result = *(__n128 *)((char *)a1 + 4);
          *(__int128 *)((char *)a1 + 4) = *(__int128 *)((char *)a2 + 4);
          *(__int128 *)((char *)a2 + 4) = (__int128)result;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::tuple<float,_Geometry2D_rect2D_>,std::tuple<float,_Geometry2D_rect2D_>),std::tuple<float,_Geometry2D_rect2D_>*>(__int128 *a1, int *a2, uint64_t (**a3)(__int128 *, __int128 *))
{
  unint64_t v6;
  _BOOL8 result;
  uint64_t (*v8)(__int128 *, __int128 *);
  int v9;
  __int128 v10;
  __int128 *v11;
  __int128 *v12;
  uint64_t v13;
  int v14;
  uint64_t (*v15)(__int128 *, __int128 *);
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t (*v21)(__int128 *, __int128 *);
  char v22;
  __int128 *v23;
  _OWORD *v24;
  __int128 v25;
  int v26;
  int v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  int v31;
  __int128 v32;
  int v33;
  __int128 v34;
  int v35;
  __int128 v36;
  int v37;

  v6 = 0xCCCCCCCCCCCCCCCDLL * (((char *)a2 - (char *)a1) >> 2);
  result = 1;
  switch(v6)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      v8 = *a3;
      v36 = *(_OWORD *)(a2 - 5);
      v37 = *(a2 - 1);
      v34 = *a1;
      v35 = *((_DWORD *)a1 + 4);
      if (v8(&v36, &v34))
      {
        v9 = *(_DWORD *)a1;
        *(_DWORD *)a1 = *(a2 - 5);
        *(a2 - 5) = v9;
        v10 = *(__int128 *)((char *)a1 + 4);
        *(__int128 *)((char *)a1 + 4) = *((_OWORD *)a2 - 1);
        *((_OWORD *)a2 - 1) = v10;
      }
      return 1;
    case 3uLL:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::tuple<float,_Geometry2D_rect2D_>,std::tuple<float,_Geometry2D_rect2D_>),std::tuple<float,_Geometry2D_rect2D_>*>(a1, (__int128 *)((char *)a1 + 20), (__int128 *)(a2 - 5), a3);
      return 1;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::tuple<float,_Geometry2D_rect2D_>,std::tuple<float,_Geometry2D_rect2D_>),std::tuple<float,_Geometry2D_rect2D_>*>((int *)a1, (__int128 *)((char *)a1 + 20), (__int128 *)((char *)a1 + 40), (__int128 *)(a2 - 5), a3);
      return 1;
    case 5uLL:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::tuple<float,_Geometry2D_rect2D_>,std::tuple<float,_Geometry2D_rect2D_>),std::tuple<float,_Geometry2D_rect2D_>*>(a1, (__int128 *)((char *)a1 + 20), (__int128 *)((char *)a1 + 40), (__int128 *)((char *)a1 + 60), (__int128 *)(a2 - 5), a3);
      return 1;
    default:
      v11 = (__int128 *)((char *)a1 + 40);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(std::tuple<float,_Geometry2D_rect2D_>,std::tuple<float,_Geometry2D_rect2D_>),std::tuple<float,_Geometry2D_rect2D_>*>(a1, (__int128 *)((char *)a1 + 20), (__int128 *)((char *)a1 + 40), a3);
      v12 = (__int128 *)((char *)a1 + 60);
      if ((int *)((char *)a1 + 60) == a2)
        return 1;
      v13 = 0;
      v14 = 0;
      break;
  }
  while (1)
  {
    v15 = *a3;
    v32 = *v12;
    v33 = *((_DWORD *)v12 + 4);
    v16 = *((_DWORD *)v11 + 4);
    v30 = *v11;
    v31 = v16;
    if (v15(&v32, &v30))
    {
      v17 = *(_DWORD *)v12;
      v29 = *(__int128 *)((char *)v12 + 4);
      v18 = v13;
      while (1)
      {
        v19 = v18;
        v20 = (uint64_t)a1 + v18;
        *(_DWORD *)(v20 + 60) = *(_DWORD *)(v20 + 40);
        *(_OWORD *)(v20 + 64) = *(_OWORD *)(v20 + 44);
        if (v19 == -40)
          break;
        v21 = *a3;
        v27 = v17;
        v28 = v29;
        v25 = *(_OWORD *)(v20 + 20);
        v26 = *(_DWORD *)(v20 + 36);
        v22 = v21((__int128 *)&v27, &v25);
        v18 = v19 - 20;
        if ((v22 & 1) == 0)
        {
          v23 = (__int128 *)((char *)a1 + v18 + 60);
          v24 = (__int128 *)((char *)a1 + v19 + 44);
          goto LABEL_12;
        }
      }
      v24 = (_OWORD *)(v20 + 44);
      v23 = a1;
LABEL_12:
      *(_DWORD *)v23 = v17;
      *v24 = v29;
      if (++v14 == 8)
        return (int *)((char *)v12 + 20) == a2;
    }
    v11 = v12;
    v13 += 20;
    v12 = (__int128 *)((char *)v12 + 20);
    if (v12 == (__int128 *)a2)
      return 1;
  }
}

uint64_t vision::mod::ImageAnalyzer_PostProcessor::process(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t **v6;
  uint64_t **v7;
  uint64_t *v8;
  uint64_t **v9;
  std::string *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *exception;
  _QWORD v15[2];
  char v16;
  uint64_t v17;

  v6 = (uint64_t **)(a1 + 96);
  v7 = (uint64_t **)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__find_equal<std::string>(a1 + 96, &v17, (_QWORD *)a1);
  v8 = *v7;
  if (!*v7)
  {
    v9 = v7;
    v8 = (uint64_t *)operator new(0x58uLL);
    v15[0] = v8;
    v15[1] = a1 + 104;
    v16 = 0;
    v10 = (std::string *)(v8 + 4);
    if (*(char *)(a1 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v10, *(const std::string::value_type **)a1, *(_QWORD *)(a1 + 8));
    }
    else
    {
      *(_OWORD *)&v10->__r_.__value_.__l.__data_ = *(_OWORD *)a1;
      v8[6] = *(_QWORD *)(a1 + 16);
    }
    v8[10] = 0;
    v16 = 1;
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at(v6, v17, v9, v8);
    v15[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,void *>>>>::reset[abi:ne180100]((uint64_t)v15);
  }
  v11 = v8[10];
  if (!v11)
    std::__throw_bad_function_call[abi:ne180100]();
  v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v11 + 48))(v11, a1 + 24, a2, a3);
  if ((v12 & 0x80) == 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = v12;
    __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
  }
  return a1;
}

void sub_1A14B6464(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::function<long long ()(std::map<std::string,std::vector<float>> const&,std::vector<float> const&,std::vector<float>&)>>,void *>>>>::reset[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::ImageAnalyzer::getSceneLabelsConfidences(vision::mod::ImageAnalyzer *this, float a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  char *v7;
  uint64_t *v8;
  _BYTE *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void **p_p;
  int v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint8x8_t v20;
  unint64_t v21;
  void **v22;
  char *v23;
  unint64_t v24;
  std::string *v25;
  __int128 v26;
  float v27;
  _BOOL8 v28;
  unint64_t v29;
  unint64_t v30;
  size_t v31;
  uint64_t v32;
  _QWORD *v33;
  unint64_t v34;
  uint64_t *i;
  int v36;
  _QWORD *exception;
  _QWORD *v39;
  uint64_t v40;
  uint64_t *v41;
  __int128 *v42;
  uint64_t *DisallowedLabels;
  __int128 v44;
  __int128 v45;
  float v46;
  __int128 v47;
  void *__p;
  void *v49;
  uint64_t v50;
  _BYTE *v51;
  _BYTE *v52;

  v4 = (uint64_t)this;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_DWORD *)this + 8) = 1065353216;
  v44 = 0u;
  v45 = 0u;
  v46 = 1.0;
  v5 = a3 + 864;
  LODWORD(__p) = 2;
  v6 = std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(a3 + 864, 2u, &__p);
  std::__hash_table<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>>>::__rehash<true>((uint64_t)&v44, vcvtps_u32_f32((float)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6[4] - v6[3]) >> 3)) / 1.0));
  LODWORD(__p) = 2;
  if (!*((_BYTE *)std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(a3 + 824, 2u, &__p)+ 20))
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = 8574;
    __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
  }
  if (*(_BYTE *)(a3 + 384))
  {
    v39 = __cxa_allocate_exception(8uLL);
    *v39 = 8575;
    __cxa_throw(v39, MEMORY[0x1E0DE4F28], 0);
  }
  LODWORD(v47) = 2;
  v7 = std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,espresso_buffer_t>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(a3 + 784, 2u, &v47);
  vision::mod::ImageAnalyzer_Tensor1D<float>::ImageAnalyzer_Tensor1D((uint64_t)&__p, (__int128 *)(v7 + 24), 0);
  vision::mod::ImageAnalyzer_Tensor1D<float>::getVectorFromTensor(&v51, (unint64_t *)&__p);
  vision::mod::ImageAnalyzer_Tensor1D<float>::~ImageAnalyzer_Tensor1D((uint64_t)&__p);
  __p = 0;
  v49 = 0;
  v50 = 0;
  v41 = std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>>>::find<vision::mod::ImageAnalyzer_AnalysisType>((_QWORD *)(a3 + 744), 2u);
  if (v41)
  {
    LODWORD(v47) = 2;
    v8 = std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,vision::mod::ImageAnalyzer_PostProcessor>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>((_QWORD *)(a3 + 744), 2u, &v47);
    vision::mod::ImageAnalyzer_PostProcessor::process((uint64_t)(v8 + 3), (uint64_t)&v51, (uint64_t)&__p);
  }
  DisallowedLabels = vision::mod::ImageAnalyzer::getDisallowedLabels(a3, 2u);
  v9 = v51;
  v10 = v41;
  if ((int)((unint64_t)(v52 - v51) >> 2) >= 1)
  {
    v11 = 0;
    v12 = DisallowedLabels[3];
    v42 = (__int128 *)(a3 + 1008);
    v40 = v4;
    while (1)
    {
      LODWORD(v47) = 2;
      v13 = std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,std::vector<std::string>>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>(v5, 2u, &v47)[3];
      v14 = v13 + 24 * v11;
      if (!v12
        || !std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(DisallowedLabels, (unsigned __int8 *)(v13 + 24 * v11)))
      {
        break;
      }
LABEL_54:
      ++v11;
      v9 = v51;
      if (v11 >= (int)((unint64_t)(v52 - v51) >> 2))
      {
        v4 = v40;
        goto LABEL_56;
      }
    }
    p_p = &__p;
    if (!v10)
      p_p = (void **)&v51;
    v16 = *((_DWORD *)*p_p + v11);
    v47 = *v42;
    v17 = std::__string_hash<char>::operator()[abi:ne180100](v14);
    v18 = v17;
    v19 = *((_QWORD *)&v44 + 1);
    if (*((_QWORD *)&v44 + 1))
    {
      v20 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v44 + 8));
      v20.i16[0] = vaddlv_u8(v20);
      v21 = v20.u32[0];
      if (v20.u32[0] > 1uLL)
      {
        v4 = v17;
        if (v17 >= *((_QWORD *)&v44 + 1))
          v4 = v17 % *((_QWORD *)&v44 + 1);
      }
      else
      {
        v4 = (*((_QWORD *)&v44 + 1) - 1) & v17;
      }
      v22 = *(void ***)(v44 + 8 * v4);
      if (v22)
      {
        v23 = (char *)*v22;
        if (*v22)
        {
          while (1)
          {
            v24 = *((_QWORD *)v23 + 1);
            if (v24 == v18)
            {
              if (std::equal_to<std::string>::operator()[abi:ne180100]((unsigned __int8 *)v23 + 16, (unsigned __int8 *)v14))
              {
                v10 = v41;
                goto LABEL_53;
              }
            }
            else
            {
              if (v21 > 1)
              {
                if (v24 >= v19)
                  v24 %= v19;
              }
              else
              {
                v24 &= v19 - 1;
              }
              if (v24 != v4)
              {
LABEL_27:
                v10 = v41;
                break;
              }
            }
            v23 = *(char **)v23;
            if (!v23)
              goto LABEL_27;
          }
        }
      }
    }
    v23 = (char *)operator new(0x40uLL);
    *(_QWORD *)v23 = 0;
    *((_QWORD *)v23 + 1) = v18;
    v25 = (std::string *)(v23 + 16);
    if (*(char *)(v14 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v25, *(const std::string::value_type **)v14, *(_QWORD *)(v14 + 8));
    }
    else
    {
      v26 = *(_OWORD *)v14;
      *((_QWORD *)v23 + 4) = *(_QWORD *)(v14 + 16);
      *(_OWORD *)&v25->__r_.__value_.__l.__data_ = v26;
    }
    *((_QWORD *)v23 + 5) = 0;
    *((_QWORD *)v23 + 6) = 0;
    *((_DWORD *)v23 + 14) = 0;
    v27 = (float)(unint64_t)(*((_QWORD *)&v45 + 1) + 1);
    if (!v19 || (float)(v46 * (float)v19) < v27)
    {
      v28 = (v19 & (v19 - 1)) != 0;
      if (v19 < 3)
        v28 = 1;
      v29 = v28 | (2 * v19);
      v30 = vcvtps_u32_f32(v27 / v46);
      if (v29 <= v30)
        v31 = v30;
      else
        v31 = v29;
      std::__hash_table<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>>>::__rehash<true>((uint64_t)&v44, v31);
      v19 = *((_QWORD *)&v44 + 1);
      if ((*((_QWORD *)&v44 + 1) & (*((_QWORD *)&v44 + 1) - 1)) != 0)
      {
        if (v18 >= *((_QWORD *)&v44 + 1))
          v4 = v18 % *((_QWORD *)&v44 + 1);
        else
          v4 = v18;
      }
      else
      {
        v4 = (*((_QWORD *)&v44 + 1) - 1) & v18;
      }
    }
    v32 = v44;
    v33 = *(_QWORD **)(v44 + 8 * v4);
    if (v33)
    {
      *(_QWORD *)v23 = *v33;
    }
    else
    {
      *(_QWORD *)v23 = v45;
      *(_QWORD *)&v45 = v23;
      *(_QWORD *)(v32 + 8 * v4) = &v45;
      if (!*(_QWORD *)v23)
        goto LABEL_52;
      v34 = *(_QWORD *)(*(_QWORD *)v23 + 8);
      if ((v19 & (v19 - 1)) != 0)
      {
        if (v34 >= v19)
          v34 %= v19;
      }
      else
      {
        v34 &= v19 - 1;
      }
      v33 = (_QWORD *)(v44 + 8 * v34);
    }
    *v33 = v23;
LABEL_52:
    ++*((_QWORD *)&v45 + 1);
LABEL_53:
    *((_DWORD *)v23 + 10) = v16;
    *(_OWORD *)(v23 + 44) = v47;
    goto LABEL_54;
  }
LABEL_56:
  if (__p)
  {
    v49 = __p;
    operator delete(__p);
    v9 = v51;
  }
  if (v9)
  {
    v52 = v9;
    operator delete(v9);
  }
  for (i = (uint64_t *)v45; i; i = (uint64_t *)*i)
  {
    v36 = *((_DWORD *)i + 10);
    __p = i + 2;
    *((_DWORD *)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v4, (unsigned __int8 *)i + 16, (__int128 **)&__p)+ 10) = v36;
  }
  return std::__hash_table<std::__hash_value_type<std::string,std::tuple<float,_Geometry2D_rect2D_>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::tuple<float,_Geometry2D_rect2D_>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::tuple<float,_Geometry2D_rect2D_>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::tuple<float,_Geometry2D_rect2D_>>>>::~__hash_table((uint64_t)&v44);
}

void sub_1A14B695C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25)
{
  uint64_t v25;
  uint64_t v26;
  void *v28;

  if (__p)
  {
    a25 = (uint64_t)__p;
    operator delete(__p);
  }
  v28 = *(void **)(v26 - 128);
  if (v28)
  {
    *(_QWORD *)(v26 - 120) = v28;
    operator delete(v28);
  }
  std::__hash_table<std::__hash_value_type<std::string,std::tuple<float,_Geometry2D_rect2D_>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::tuple<float,_Geometry2D_rect2D_>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::tuple<float,_Geometry2D_rect2D_>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::tuple<float,_Geometry2D_rect2D_>>>>::~__hash_table((uint64_t)&a15);
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table(v25);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::tuple<float,_Geometry2D_rect2D_>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::tuple<float,_Geometry2D_rect2D_>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::tuple<float,_Geometry2D_rect2D_>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::tuple<float,_Geometry2D_rect2D_>>>>::~__hash_table(uint64_t a1)
{
  void **v2;
  void **v3;
  void *v4;

  v2 = *(void ***)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (void **)*v2;
      if (*((char *)v2 + 39) < 0)
        operator delete(v2[2]);
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

uint64_t vision::mod::ImageAnalyzer::getSlidersAdjustments(vision::mod::ImageAnalyzer *this, _QWORD *a2)
{
  unint64_t v2;
  _QWORD *v3;
  uint64_t result;
  uint64_t *v6;
  unint64_t v7;
  int v8;
  unsigned int v9;
  BOOL v10;
  int8x8_t v11;
  uint8x8_t v12;
  unint64_t v13;
  uint64_t **v14;
  uint64_t *v15;
  unint64_t v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  _QWORD *v25;
  uint8x8_t v26;
  unint64_t v27;
  uint64_t **v28;
  uint64_t *i;
  unint64_t v30;
  _QWORD *v31;
  std::string *v32;
  __int128 v33;
  float v34;
  float v35;
  _BOOL8 v36;
  unint64_t v37;
  unint64_t v38;
  int8x8_t prime;
  void *v40;
  void *v41;
  uint64_t v42;
  _QWORD *v43;
  unint64_t v44;
  uint8x8_t v45;
  unint64_t v46;
  uint8x8_t v47;
  uint64_t v48;
  _QWORD *v49;
  unint64_t v50;
  _QWORD *v51;
  unint64_t v52;
  void *v53;
  void *v54;
  _QWORD *exception;
  _QWORD *v56;
  unint64_t v57[23];
  __int128 v58;
  uint64_t v59;
  __int128 v60[10];
  uint64_t v61;
  _QWORD v62[2];
  char v63;

  v3 = a2;
  LODWORD(v57[0]) = 256;
  result = (uint64_t)std::__hash_table<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>,std::__unordered_map_hasher<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::__unordered_map_equal<vision::mod::ImageAnalyzer_AnalysisType,std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>,std::equal_to<vision::mod::ImageAnalyzer_AnalysisType>,std::hash<vision::mod::ImageAnalyzer_AnalysisType>,true>,std::allocator<std::__hash_value_type<vision::mod::ImageAnalyzer_AnalysisType,BOOL>>>::__emplace_unique_key_args<vision::mod::ImageAnalyzer_AnalysisType,std::piecewise_construct_t const&,std::tuple<vision::mod::ImageAnalyzer_AnalysisType&&>,std::tuple<>>((uint64_t)(a2 + 103), 0x100u, v57);
  if (!*(_BYTE *)(result + 20))
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = 8574;
    __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
  }
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_DWORD *)this + 8) = 1065353216;
  v6 = (uint64_t *)v3[90];
  if (v6)
  {
    v56 = (_QWORD *)((char *)this + 16);
LABEL_4:
    v7 = *((unsigned int *)v6 + 4);
    if (!(_DWORD)v7)
      goto LABEL_104;
    v8 = -1;
    v9 = *((_DWORD *)v6 + 4);
    do
    {
      ++v8;
      v10 = v9 > 1;
      v9 >>= 1;
    }
    while (v10);
    if (v8 != 8)
      goto LABEL_104;
    v11 = (int8x8_t)v3[99];
    if (!*(_QWORD *)&v11)
      goto LABEL_116;
    v12 = (uint8x8_t)vcnt_s8(v11);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      v13 = *((unsigned int *)v6 + 4);
      if (*(_QWORD *)&v11 <= v7)
        v13 = v7 % *(_QWORD *)&v11;
    }
    else
    {
      v13 = (v11.i32[0] - 1) & v7;
    }
    v14 = *(uint64_t ***)(v3[98] + 8 * v13);
    if (!v14 || (v15 = *v14) == 0)
LABEL_116:
      std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
    while (1)
    {
      v16 = v15[1];
      if (v16 == v7)
      {
        if (*((_DWORD *)v15 + 4) == (_DWORD)v7)
        {
          v17 = *(_OWORD *)(v15 + 17);
          v18 = *(_OWORD *)(v15 + 21);
          v60[8] = *(_OWORD *)(v15 + 19);
          v60[9] = v18;
          v61 = v15[23];
          v19 = *(_OWORD *)(v15 + 9);
          v20 = *(_OWORD *)(v15 + 13);
          v60[4] = *(_OWORD *)(v15 + 11);
          v60[5] = v20;
          v60[6] = *(_OWORD *)(v15 + 15);
          v60[7] = v17;
          v21 = *(_OWORD *)(v15 + 5);
          v60[0] = *(_OWORD *)(v15 + 3);
          v60[1] = v21;
          v60[2] = *(_OWORD *)(v15 + 7);
          v60[3] = v19;
          vision::mod::ImageAnalyzer_Tensor1D<float>::ImageAnalyzer_Tensor1D((uint64_t)v57, v60, 1);
          vision::mod::ImageAnalyzer_Tensor1D<float>::getVectorFromTensor(&v58, v57);
          v22 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)(v6 + 3));
          v23 = v22;
          v24 = *((_QWORD *)this + 1);
          if (v24)
          {
            v25 = v3;
            v26 = (uint8x8_t)vcnt_s8((int8x8_t)v24);
            v26.i16[0] = vaddlv_u8(v26);
            v27 = v26.u32[0];
            if (v26.u32[0] > 1uLL)
            {
              v2 = v22;
              if (v22 >= v24)
                v2 = v22 % v24;
            }
            else
            {
              v2 = (v24 - 1) & v22;
            }
            v28 = *(uint64_t ***)(*(_QWORD *)this + 8 * v2);
            if (v28)
            {
              for (i = *v28; i; i = (uint64_t *)*i)
              {
                v30 = i[1];
                if (v30 == v23)
                {
                  if (std::equal_to<std::string>::operator()[abi:ne180100]((unsigned __int8 *)i + 16, (unsigned __int8 *)v6 + 24))
                  {
                    v3 = v25;
                    goto LABEL_101;
                  }
                }
                else
                {
                  if (v27 > 1)
                  {
                    if (v30 >= v24)
                      v30 %= v24;
                  }
                  else
                  {
                    v30 &= v24 - 1;
                  }
                  if (v30 != v2)
                    break;
                }
              }
            }
            v3 = v25;
          }
          v31 = operator new(0x40uLL);
          v62[0] = v31;
          v62[1] = (char *)this + 16;
          v63 = 0;
          *v31 = 0;
          v31[1] = v23;
          v32 = (std::string *)(v31 + 2);
          if (*((char *)v6 + 47) < 0)
          {
            std::string::__init_copy_ctor_external(v32, (const std::string::value_type *)v6[3], v6[4]);
          }
          else
          {
            v33 = *(_OWORD *)(v6 + 3);
            v31[4] = v6[5];
            *(_OWORD *)&v32->__r_.__value_.__l.__data_ = v33;
          }
          v31[5] = 0;
          v31[6] = 0;
          v31[7] = 0;
          v63 = 1;
          v34 = (float)(unint64_t)(*((_QWORD *)this + 3) + 1);
          v35 = *((float *)this + 8);
          if (!v24 || (float)(v35 * (float)v24) < v34)
          {
            v36 = (v24 & (v24 - 1)) != 0;
            if (v24 < 3)
              v36 = 1;
            v37 = v36 | (2 * v24);
            v38 = vcvtps_u32_f32(v34 / v35);
            if (v37 <= v38)
              prime = (int8x8_t)v38;
            else
              prime = (int8x8_t)v37;
            if (*(_QWORD *)&prime == 1)
            {
              prime = (int8x8_t)2;
            }
            else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
            {
              prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
            }
            v24 = *((_QWORD *)this + 1);
            if (*(_QWORD *)&prime <= v24)
            {
              if (*(_QWORD *)&prime < v24)
              {
                v46 = vcvtps_u32_f32((float)*((unint64_t *)this + 3) / *((float *)this + 8));
                if (v24 < 3
                  || (v47 = (uint8x8_t)vcnt_s8((int8x8_t)v24), v47.i16[0] = vaddlv_u8(v47), v47.u32[0] > 1uLL))
                {
                  v46 = std::__next_prime(v46);
                }
                else
                {
                  v48 = 1 << -(char)__clz(v46 - 1);
                  if (v46 >= 2)
                    v46 = v48;
                }
                if (*(_QWORD *)&prime <= v46)
                  prime = (int8x8_t)v46;
                if (*(_QWORD *)&prime >= v24)
                {
                  v24 = *((_QWORD *)this + 1);
                }
                else
                {
                  if (prime)
                    goto LABEL_57;
                  v54 = *(void **)this;
                  *(_QWORD *)this = 0;
                  if (v54)
                    operator delete(v54);
                  v24 = 0;
                  *((_QWORD *)this + 1) = 0;
                }
              }
            }
            else
            {
LABEL_57:
              if (*(_QWORD *)&prime >> 61)
                std::__throw_bad_array_new_length[abi:ne180100]();
              v40 = operator new(8 * *(_QWORD *)&prime);
              v41 = *(void **)this;
              *(_QWORD *)this = v40;
              if (v41)
                operator delete(v41);
              v42 = 0;
              *((int8x8_t *)this + 1) = prime;
              do
                *(_QWORD *)(*(_QWORD *)this + 8 * v42++) = 0;
              while (*(_QWORD *)&prime != v42);
              v43 = (_QWORD *)*v56;
              if (*v56)
              {
                v44 = v43[1];
                v45 = (uint8x8_t)vcnt_s8(prime);
                v45.i16[0] = vaddlv_u8(v45);
                if (v45.u32[0] > 1uLL)
                {
                  if (v44 >= *(_QWORD *)&prime)
                    v44 %= *(_QWORD *)&prime;
                }
                else
                {
                  v44 &= *(_QWORD *)&prime - 1;
                }
                *(_QWORD *)(*(_QWORD *)this + 8 * v44) = v56;
                v49 = (_QWORD *)*v43;
                if (*v43)
                {
                  do
                  {
                    v50 = v49[1];
                    if (v45.u32[0] > 1uLL)
                    {
                      if (v50 >= *(_QWORD *)&prime)
                        v50 %= *(_QWORD *)&prime;
                    }
                    else
                    {
                      v50 &= *(_QWORD *)&prime - 1;
                    }
                    if (v50 != v44)
                    {
                      if (!*(_QWORD *)(*(_QWORD *)this + 8 * v50))
                      {
                        *(_QWORD *)(*(_QWORD *)this + 8 * v50) = v43;
                        goto LABEL_82;
                      }
                      *v43 = *v49;
                      *v49 = **(_QWORD **)(*(_QWORD *)this + 8 * v50);
                      **(_QWORD **)(*(_QWORD *)this + 8 * v50) = v49;
                      v49 = v43;
                    }
                    v50 = v44;
LABEL_82:
                    v43 = v49;
                    v49 = (_QWORD *)*v49;
                    v44 = v50;
                  }
                  while (v49);
                }
              }
              v24 = (unint64_t)prime;
            }
            if ((v24 & (v24 - 1)) != 0)
            {
              if (v23 >= v24)
                v2 = v23 % v24;
              else
                v2 = v23;
            }
            else
            {
              v2 = (v24 - 1) & v23;
            }
          }
          v51 = *(_QWORD **)(*(_QWORD *)this + 8 * v2);
          i = (uint64_t *)v62[0];
          if (v51)
          {
            *(_QWORD *)v62[0] = *v51;
            goto LABEL_99;
          }
          *(_QWORD *)v62[0] = *((_QWORD *)this + 2);
          *((_QWORD *)this + 2) = i;
          *(_QWORD *)(*(_QWORD *)this + 8 * v2) = v56;
          if (*i)
          {
            v52 = *(_QWORD *)(*i + 8);
            if ((v24 & (v24 - 1)) != 0)
            {
              if (v52 >= v24)
                v52 %= v24;
            }
            else
            {
              v52 &= v24 - 1;
            }
            v51 = (_QWORD *)(*(_QWORD *)this + 8 * v52);
LABEL_99:
            *v51 = i;
          }
          v62[0] = 0;
          ++*((_QWORD *)this + 3);
          std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,void *>>>>::reset[abi:ne180100]((uint64_t)v62);
LABEL_101:
          v53 = (void *)i[5];
          if (v53)
          {
            i[6] = (uint64_t)v53;
            operator delete(v53);
            i[5] = 0;
            i[6] = 0;
            i[7] = 0;
          }
          *(_OWORD *)(i + 5) = v58;
          i[7] = v59;
          v59 = 0;
          v58 = 0uLL;
          result = vision::mod::ImageAnalyzer_Tensor1D<float>::~ImageAnalyzer_Tensor1D((uint64_t)v57);
LABEL_104:
          v6 = (uint64_t *)*v6;
          if (!v6)
            return result;
          goto LABEL_4;
        }
      }
      else
      {
        if (v12.u32[0] > 1uLL)
        {
          if (v16 >= *(_QWORD *)&v11)
            v16 %= *(_QWORD *)&v11;
        }
        else
        {
          v16 &= *(_QWORD *)&v11 - 1;
        }
        if (v16 != v13)
          goto LABEL_116;
      }
      v15 = (uint64_t *)*v15;
      if (!v15)
        goto LABEL_116;
    }
  }
  return result;
}

void sub_1A14B70AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34)
{
  uint64_t v34;
  uint64_t v35;

  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,void *>>>>::reset[abi:ne180100](v35 - 120);
  if (__p)
  {
    a34 = (uint64_t)__p;
    operator delete(__p);
  }
  vision::mod::ImageAnalyzer_Tensor1D<float>::~ImageAnalyzer_Tensor1D((uint64_t)&a10);
  std::__hash_table<std::__hash_value_type<std::string,std::vector<float>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<float>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<float>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<float>>>>::~__hash_table(v34);
  _Unwind_Resume(a1);
}

void sub_1A14B71A4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14B73B4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void BmMixedBufSize::BmMixedBufSize(BmMixedBufSize *this)
{
  *(_QWORD *)this = 0;
}

void sub_1A14B794C(_Unwind_Exception *a1, int a2)
{
  void *v2;
  uint64_t v3;
  void *v4;

  MEMORY[0x1A1B0A898](v3, 0x10F1C40885E7AD1);
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x1A14B78ECLL);
  }

  _Unwind_Resume(a1);
}

void sub_1A14B79DC()
{
  JUMPOUT(0x1A14B79ACLL);
}

void sub_1A14B7CE4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A14B7CFC()
{
  __cxa_end_catch();
  JUMPOUT(0x1A14B7D04);
}

void sub_1A14B7F38(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A14B7F50()
{
  __cxa_end_catch();
  JUMPOUT(0x1A14B7F58);
}

void sub_1A14B8044(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14B80C8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14B82A8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1A14B8428(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id a22)
{
  void *v22;
  uint64_t v23;

  _Block_object_dispose(&a17, 8);
  _Block_object_dispose((const void *)(v23 - 80), 8);

  _Unwind_Resume(a1);
}

void sub_1A14B85A0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__17739(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__17740(uint64_t a1)
{

}

void sub_1A14B87E4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14B8914(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A14B89C4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14B8A78(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14B8B64(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  v6 = v5;

  _Unwind_Resume(a1);
}

void sub_1A14B8BF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A14B8DA0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A14B8E20(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id _unavailableTensorKeyError(NSString *a1)
{
  NSString *v1;
  void *v2;
  void *v3;

  v1 = a1;
  v2 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("VNDetectionprintTensor '%@' is not available"), v1);
  +[VNError errorForInvalidArgumentWithLocalizedDescription:](VNError, "errorForInvalidArgumentWithLocalizedDescription:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  return v3;
}

void sub_1A14B8EDC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14B9098(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14B9208(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v5 = v4;

  _Unwind_Resume(a1);
}

void vision::mod::FaceBoxPoseAligner<signed char>::loadERTModel(uint64_t *a1, _QWORD *a2)
{
  uint64_t SizeFromBytesHelper;
  unsigned __int8 *v5;
  std::__shared_weak_count *v6;
  const void *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  size_t v10;
  void *v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  unint64_t v16;
  unint64_t v17;
  char *v18;
  size_t v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  char *v28;
  uint64_t v29;
  char *v30;
  char *v31;
  void *v32;
  void *v33;
  unint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  uint64_t v38;
  __int128 v39;
  int64x2_t v40;
  _QWORD *v41;
  _QWORD *v42;
  void *v43;
  void *v44;
  _QWORD *v45;
  void *v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  _DWORD *v52;
  _BYTE *v53;
  char *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  _DWORD *v58;
  int *v59;
  uint64_t v60;
  int *v61;
  _DWORD *v62;
  uint64_t i;
  int v64;
  _QWORD *v65;
  void *v66;
  uint64_t v67;
  _QWORD *v68;
  _QWORD *exception;
  void *v70;
  void *v71;
  uint64_t v72;
  void *v73[3];
  void *v74[3];
  void *__dst[3];
  void *__p;
  int64x2_t v77;
  _QWORD v78[32];
  const void *v79;
  std::__shared_weak_count *v80;

  std::string::basic_string[abi:ne180100]<0>(&__p, "ERTFaceBox::ERTNumCascadeStages");
  if (v77.i8[15] < 0)
    operator delete(__p);
  std::string::basic_string[abi:ne180100]<0>(&__p, "ERTFaceBox::ERTNumTrees");
  if (v77.i8[15] < 0)
    operator delete(__p);
  std::string::basic_string[abi:ne180100]<0>(&__p, "ERTFaceBox::ERTNumPredictions");
  if (v77.i8[15] < 0)
    operator delete(__p);
  memset(v74, 0, sizeof(v74));
  std::string::basic_string[abi:ne180100]<0>(&__p, "ERTFaceBox::ERTNodesThresholds");
  if (v77.i8[15] < 0)
    operator delete(__p);
  memset(v73, 0, sizeof(v73));
  std::string::basic_string[abi:ne180100]<0>(&__p, "ERTFaceBox::ERTNodesPredictions");
  if (v77.i8[15] < 0)
    operator delete(__p);
  std::string::basic_string[abi:ne180100]<0>(&v70, "ERTFaceBox::ERTNodesFeatureIDs");
  v79 = 0;
  v80 = 0;
  v5 = std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(a2, (unsigned __int8 *)&v70);
  if (!v5 || *((_DWORD *)v5 + 10) != 1)
  {
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&__p);
    v65 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v77.i64[1], (uint64_t)"Error: ", 7);
    if (v72 >= 0)
      v66 = &v70;
    else
      v66 = v70;
    if (v72 >= 0)
      v67 = HIBYTE(v72);
    else
      v67 = (uint64_t)v71;
    v68 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v65, (uint64_t)v66, v67);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v68, (uint64_t)" failed to load from ERT model file!", 36);
    exception = __cxa_allocate_exception(0x20uLL);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>(__dst, (uint64_t)v78);
  }
  v7 = (const void *)*((_QWORD *)v5 + 6);
  v6 = (std::__shared_weak_count *)*((_QWORD *)v5 + 7);
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v79 = v7;
  v80 = v6;
  v10 = *((_QWORD *)v5 + 8);
  if (v10 >= 8)
  {
    v11 = std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v10 >> 3);
    bzero(v11, v10 & 0xFFFFFFFFFFFFFFF8);
  }
  else
  {
    v11 = 0;
  }
  memcpy(v11, v7, v10);
  if (v6)
  {
    v12 = (unint64_t *)&v6->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  if (SHIBYTE(v72) < 0)
    operator delete(v70);
  memset(__dst, 0, sizeof(__dst));
  std::string::basic_string[abi:ne180100]<0>(&__p, "ERTFaceBox::ERTNodesLeafFlags");
  if (v77.i8[15] < 0)
    operator delete(__p);
  v14 = a1[1] * *a1;
  if (v14)
  {
    v15 = 0;
    v16 = (char *)__dst[1] - (char *)__dst[0];
    v17 = ((char *)__dst[1] - (char *)__dst[0]) / v14;
    a1[2] = v17;
    v70 = 0;
    v71 = 0;
    v72 = 0;
    if (v14 <= v16)
    {
      std::vector<vision::mod::ERTTreeNode>::__vallocate[abi:ne180100](&v70, v17);
      v18 = (char *)v71;
      v19 = 48 * ((48 * v17 - 48) / 0x30) + 48;
      bzero(v71, v19);
      v15 = &v18[v19];
      v71 = v15;
    }
    v20 = a1[11];
    v21 = (_QWORD *)a1[12];
    v22 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v21 - v20) >> 3);
    v23 = v14 - v22;
    if (v14 <= v22)
    {
      if (v14 < v22)
      {
        v41 = (_QWORD *)(v20 + 24 * v14);
        if (v21 != v41)
        {
          v42 = (_QWORD *)a1[12];
          do
          {
            v44 = (void *)*(v42 - 3);
            v42 -= 3;
            v43 = v44;
            if (v44)
            {
              *(v21 - 2) = v43;
              operator delete(v43);
            }
            v21 = v42;
          }
          while (v42 != v41);
        }
        a1[12] = (uint64_t)v41;
      }
    }
    else
    {
      v24 = a1[13];
      if (0xAAAAAAAAAAAAAAABLL * ((v24 - (uint64_t)v21) >> 3) >= v23)
      {
        v45 = &v21[3 * v23];
        v46 = v70;
        v47 = 0xAAAAAAAAAAAAAAABLL * ((v15 - (_BYTE *)v70) >> 4);
        v48 = 24 * v14 - 8 * (((uint64_t)v21 - v20) >> 3);
        do
        {
          *v21 = 0;
          v21[1] = 0;
          v21[2] = 0;
          std::vector<vision::mod::ERTTreeNode>::__init_with_size[abi:ne180100]<vision::mod::ERTTreeNode*,vision::mod::ERTTreeNode*>(v21, v46, (uint64_t)v15, v47);
          v21 += 3;
          v48 -= 24;
        }
        while (v48);
        a1[12] = (uint64_t)v45;
      }
      else
      {
        if (v14 > 0xAAAAAAAAAAAAAAALL)
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        v25 = 0xAAAAAAAAAAAAAAABLL * ((v24 - v20) >> 3);
        v26 = 2 * v25;
        if (2 * v25 <= v14)
          v26 = v14;
        if (v25 >= 0x555555555555555)
          v27 = 0xAAAAAAAAAAAAAAALL;
        else
          v27 = v26;
        v78[1] = a1 + 13;
        if (v27 > 0xAAAAAAAAAAAAAAALL)
          std::__throw_bad_array_new_length[abi:ne180100]();
        v28 = (char *)operator new(24 * v27);
        v29 = 3 * v22;
        v30 = &v28[24 * v22];
        __p = v28;
        v77.i64[0] = (uint64_t)v30;
        v77.i64[1] = (uint64_t)v30;
        v78[0] = &v28[24 * v27];
        v31 = &v28[24 * v14];
        v32 = v70;
        v33 = v71;
        v34 = 0xAAAAAAAAAAAAAAABLL * (((_BYTE *)v71 - (_BYTE *)v70) >> 4);
        v35 = 24 * v14 - 8 * v29;
        do
        {
          *(_QWORD *)v30 = 0;
          *((_QWORD *)v30 + 1) = 0;
          *((_QWORD *)v30 + 2) = 0;
          std::vector<vision::mod::ERTTreeNode>::__init_with_size[abi:ne180100]<vision::mod::ERTTreeNode*,vision::mod::ERTTreeNode*>(v30, v32, (uint64_t)v33, v34);
          v30 += 24;
          v35 -= 24;
        }
        while (v35);
        v77.i64[1] = (uint64_t)v31;
        v37 = (_QWORD *)a1[11];
        v36 = (_QWORD *)a1[12];
        v38 = v77.i64[0];
        if (v36 == v37)
        {
          v40 = vdupq_n_s64((unint64_t)v36);
        }
        else
        {
          do
          {
            *(_QWORD *)(v38 - 24) = 0;
            *(_QWORD *)(v38 - 16) = 0;
            v38 -= 24;
            *(_QWORD *)(v38 + 16) = 0;
            v39 = *(_OWORD *)(v36 - 3);
            v36 -= 3;
            *(_OWORD *)v38 = v39;
            *(_QWORD *)(v38 + 16) = v36[2];
            *v36 = 0;
            v36[1] = 0;
            v36[2] = 0;
          }
          while (v36 != v37);
          v40 = *(int64x2_t *)(a1 + 11);
          v31 = (char *)v77.i64[1];
        }
        a1[11] = v38;
        a1[12] = (uint64_t)v31;
        v77 = v40;
        v49 = a1[13];
        a1[13] = v78[0];
        v78[0] = v49;
        __p = (void *)v40.i64[0];
        std::__split_buffer<std::vector<long long>>::~__split_buffer((uint64_t)&__p);
      }
    }
    if (v70)
      operator delete(v70);
    v50 = 0;
    v51 = a1[2];
    v52 = v74[0];
    v53 = __dst[0];
    v54 = (char *)v73[0];
    do
    {
      if (v51)
      {
        v55 = 0;
        v56 = v51 * v50;
        v57 = *(_QWORD *)(a1[11] + 24 * v50);
        v58 = (_DWORD *)(v57 + 16);
        v59 = (int *)v54;
        do
        {
          v60 = v57 + 48 * v55;
          *(_DWORD *)v60 = v52[v56 + v55];
          *(_QWORD *)(v60 + 8) = *((_QWORD *)v11 + v56 + v55);
          *(_BYTE *)(v60 + 44) = v53[v56 + v55] != 0;
          v61 = v59;
          v62 = v58;
          for (i = SizeFromBytesHelper; i; --i)
          {
            v64 = *v61++;
            *v62++ = v64;
          }
          ++v55;
          v58 += 12;
          v59 += SizeFromBytesHelper;
        }
        while (v55 != v51);
      }
      ++v50;
      v54 += 4 * v51 * SizeFromBytesHelper;
    }
    while (v50 != v14);
  }
  else
  {
    syslog(5, "Loading ERT model failed - unexpected zero number of trees");
  }
  if (__dst[0])
  {
    __dst[1] = __dst[0];
    operator delete(__dst[0]);
  }
  if (v11)
    operator delete(v11);
  if (v73[0])
    operator delete(v73[0]);
  if (v74[0])
    operator delete(v74[0]);
}

#error "1A14B9A7C: call analysis failed (funcsize=44)"

void vision::mod::FaceBoxPoseAligner<signed char>::loadGlobalShifts(_QWORD *a1, char **a2)
{
  void *__p[2];
  char v5;

  std::string::basic_string[abi:ne180100]<0>(__p, "ERTFaceBox::ERTGlobalShift");
  if (v5 < 0)
    operator delete(__p[0]);
}

#error "1A14B9B44: call analysis failed (funcsize=22)"

void vision::mod::FaceBoxPoseAligner<signed char>::loadXYPairs(uint64_t a1, _QWORD *a2, char **a3)
{
  void *__p[2];
  char v7;

  std::string::basic_string[abi:ne180100]<0>(__p, "ERTFaceBox::ERTNumXYPairs");
  if (v7 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(__p, "ERTFaceBox::ERTXYPairs");
  if (v7 < 0)
    operator delete(__p[0]);
}

#error "1A14B9C50: call analysis failed (funcsize=23)"

void vision::mod::FaceBoxPoseAligner<signed char>::loadDefaultPixelValue(_QWORD *a1, _BYTE *a2)
{
  _BYTE *v4;
  _QWORD *exception;
  void *__p[2];
  char v7;
  _BYTE *v8;
  _BYTE *v9;
  uint64_t v10;

  v8 = 0;
  v9 = 0;
  v10 = 0;
  std::string::basic_string[abi:ne180100]<0>(__p, "ERTFaceBox::ERTDefaultPixelValue");
  if (v7 < 0)
    operator delete(__p[0]);
  v4 = v8;
  if (v9 == v8)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    std::string::basic_string[abi:ne180100]<0>(__p, "ERROR: ERTDefaultPixelValue failed to load from ERT model file!");
  }
  *a2 = *v8;
  v9 = v4;
  operator delete(v4);
}

#error "1A14B9DCC: call analysis failed (funcsize=34)"

void vision::mod::FaceBoxPoseAligner<signed char>::loadDefaultFeatureValue(_QWORD *a1, _BYTE *a2)
{
  unsigned __int8 *v4;
  std::__shared_weak_count *v5;
  const void *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  size_t v9;
  _BYTE *v10;
  _BYTE *v11;
  unint64_t *v12;
  unint64_t v13;
  _QWORD *v14;
  void **v15;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *exception;
  _QWORD *v19;
  void *__p[2];
  unsigned __int8 v21;
  __int128 __dst;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  const void *v26;
  std::__shared_weak_count *v27;

  std::string::basic_string[abi:ne180100]<0>(__p, "ERTFaceBox::ERTDefaultFeatureValue");
  v26 = 0;
  v27 = 0;
  v4 = std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(a1, (unsigned __int8 *)__p);
  if (!v4 || *((_DWORD *)v4 + 10) != 1)
  {
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v23);
    v14 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v24, (uint64_t)"Error: ", 7);
    if ((v21 & 0x80u) == 0)
      v15 = __p;
    else
      v15 = (void **)__p[0];
    if ((v21 & 0x80u) == 0)
      v16 = v21;
    else
      v16 = (uint64_t)__p[1];
    v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)v15, v16);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)" failed to load from ERT model file!", 36);
    exception = __cxa_allocate_exception(0x20uLL);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>(&__dst, (uint64_t)&v25);
  }
  v6 = (const void *)*((_QWORD *)v4 + 6);
  v5 = (std::__shared_weak_count *)*((_QWORD *)v4 + 7);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  v26 = v6;
  v27 = v5;
  v9 = *((_QWORD *)v4 + 8);
  if (v9)
  {
    if ((v9 & 0x8000000000000000) != 0)
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    v10 = operator new(*((_QWORD *)v4 + 8));
    v11 = &v10[v9];
    bzero(v10, v9);
  }
  else
  {
    v10 = 0;
    v11 = 0;
  }
  memcpy(v10, v6, v9);
  if (v5)
  {
    v12 = (unint64_t *)&v5->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  if ((char)v21 < 0)
    operator delete(__p[0]);
  if (v11 == v10)
  {
    v19 = __cxa_allocate_exception(0x20uLL);
    std::string::basic_string[abi:ne180100]<0>(&v23, "ERROR: ERTDefaultFeatureValue failed to load from ERT model file!");
  }
  *a2 = *v10;
  operator delete(v10);
}

#error "1A14BA114: call analysis failed (funcsize=42)"

_QWORD *vision::mod::`anonymous namespace'::BoxAlignerException::BoxAlignerException(_QWORD *a1, __int128 *a2)
{
  std::string *v3;
  __int128 v4;

  *a1 = off_1E453A190;
  v3 = (std::string *)(a1 + 1);
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v3, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v4 = *a2;
    v3->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&v3->__r_.__value_.__l.__data_ = v4;
  }
  return a1;
}

void sub_1A14BA1A0(_Unwind_Exception *a1)
{
  std::exception *v1;

  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void vision::mod::`anonymous namespace'::BoxAlignerException::~BoxAlignerException(std::exception *this)
{
  this->__vftable = (std::exception_vtbl *)off_1E453A190;
  if (SHIBYTE(this[3].__vftable) < 0)
    operator delete(this[1].__vftable);
  std::exception::~exception(this);
}

{
  this->__vftable = (std::exception_vtbl *)off_1E453A190;
  if (SHIBYTE(this[3].__vftable) < 0)
    operator delete(this[1].__vftable);
  std::exception::~exception(this);
  JUMPOUT(0x1A1B0A898);
}

uint64_t vision::mod::`anonymous namespace'::BoxAlignerException::what(vision::mod::_anonymous_namespace_::BoxAlignerException *this)
{
  uint64_t result;

  result = (uint64_t)this + 8;
  if (*((char *)this + 31) < 0)
    return *(_QWORD *)result;
  return result;
}

void vision::mod::`anonymous namespace'::readTypedVectorFromBytesHelper<unsigned char>(uint64_t a1, _QWORD *a2, unint64_t *a3)
{
  unsigned __int8 *v5;
  std::__shared_weak_count *v6;
  const void *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  size_t v10;
  void *v11;
  size_t v12;
  unint64_t *v13;
  unint64_t v14;
  _QWORD *v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *exception;
  __int128 v21;
  _BYTE v22[16];
  uint64_t v23;
  uint64_t v24;
  const void *v25;
  std::__shared_weak_count *v26;

  v25 = 0;
  v26 = 0;
  v5 = std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(a2, (unsigned __int8 *)a1);
  if (!v5 || *((_DWORD *)v5 + 10) != 1)
  {
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v22);
    v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v23, (uint64_t)"Error: ", 7);
    v16 = *(char *)(a1 + 23);
    if (v16 >= 0)
      v17 = a1;
    else
      v17 = *(_QWORD *)a1;
    if (v16 >= 0)
      v18 = *(unsigned __int8 *)(a1 + 23);
    else
      v18 = *(_QWORD *)(a1 + 8);
    v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, v17, v18);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)" failed to load from ERT model file!", 36);
    exception = __cxa_allocate_exception(0x20uLL);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>(&v21, (uint64_t)&v24);
  }
  v7 = (const void *)*((_QWORD *)v5 + 6);
  v6 = (std::__shared_weak_count *)*((_QWORD *)v5 + 7);
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v25 = v7;
  v26 = v6;
  v10 = *((_QWORD *)v5 + 8);
  v11 = (void *)*a3;
  v12 = a3[1] - *a3;
  if (v10 <= v12)
  {
    if (v10 < v12)
      a3[1] = (unint64_t)v11 + v10;
  }
  else
  {
    std::vector<unsigned char>::__append(a3, v10 - v12);
    v11 = (void *)*a3;
  }
  memcpy(v11, v7, v10);
  if (v6)
  {
    v13 = (unint64_t *)&v6->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_1A14BA3F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  void *v15;
  int v16;
  uint64_t v17;

  if (a14 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0)
    {
LABEL_6:
      std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a15);
      std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](v17 - 64);
      _Unwind_Resume(a1);
    }
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

uint64_t vision::mod::`anonymous namespace'::readSizeFromBytesHelper(uint64_t a1, _QWORD *a2)
{
  unsigned __int8 *v3;
  uint64_t *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  _QWORD *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *exception;
  _QWORD *v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  __int128 v23;
  _BYTE v24[16];
  uint64_t v25;
  _BYTE v26[256];
  uint64_t *v27;
  std::__shared_weak_count *v28;

  v27 = 0;
  v28 = 0;
  v3 = std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(a2, (unsigned __int8 *)a1);
  if (!v3 || *((_DWORD *)v3 + 10) != 1)
  {
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v24);
    v11 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v25, (uint64_t)"Error: ", 7);
    v12 = *(char *)(a1 + 23);
    if (v12 >= 0)
      v13 = a1;
    else
      v13 = *(_QWORD *)a1;
    if (v12 >= 0)
      v14 = *(unsigned __int8 *)(a1 + 23);
    else
      v14 = *(_QWORD *)(a1 + 8);
    v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, v13, v14);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)" failed to load from ERT model file!", 36);
    exception = __cxa_allocate_exception(0x20uLL);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>(&v23, (uint64_t)v26);
  }
  v4 = (uint64_t *)*((_QWORD *)v3 + 6);
  v5 = (std::__shared_weak_count *)*((_QWORD *)v3 + 7);
  if (!v5)
  {
    v27 = (uint64_t *)*((_QWORD *)v3 + 6);
    if (*((_QWORD *)v3 + 8) == 8)
      return *v4;
LABEL_21:
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v24);
    v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v25, (uint64_t)"Error: ", 7);
    v18 = *(char *)(a1 + 23);
    if (v18 >= 0)
      v19 = a1;
    else
      v19 = *(_QWORD *)a1;
    if (v18 >= 0)
      v20 = *(unsigned __int8 *)(a1 + 23);
    else
      v20 = *(_QWORD *)(a1 + 8);
    v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, v19, v20);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)" unexpected size of value", 25);
    v22 = __cxa_allocate_exception(0x20uLL);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>(&v23, (uint64_t)v26);
  }
  p_shared_owners = (unint64_t *)&v5->__shared_owners_;
  do
    v7 = __ldxr(p_shared_owners);
  while (__stxr(v7 + 1, p_shared_owners));
  v27 = v4;
  v28 = v5;
  if (*((_QWORD *)v3 + 8) != 8)
    goto LABEL_21;
  v8 = *v4;
  do
    v9 = __ldaxr(p_shared_owners);
  while (__stlxr(v9 - 1, p_shared_owners));
  if (!v9)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  return v8;
}

void sub_1A14BA640(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  void *v15;
  int v16;
  uint64_t v17;

  if (a14 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0)
    {
LABEL_6:
      std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a15);
      std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](v17 - 48);
      _Unwind_Resume(a1);
    }
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

void vision::mod::`anonymous namespace'::readTypedVectorFromBytesHelper<float>(uint64_t a1, _QWORD *a2, char **a3)
{
  unsigned __int8 *v5;
  std::__shared_weak_count *v6;
  const void *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  size_t v10;
  unint64_t *v11;
  unint64_t v12;
  _QWORD *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *exception;
  __int128 v19;
  _BYTE v20[16];
  uint64_t v21;
  uint64_t v22;
  const void *v23;
  std::__shared_weak_count *v24;

  v23 = 0;
  v24 = 0;
  v5 = std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(a2, (unsigned __int8 *)a1);
  if (!v5 || *((_DWORD *)v5 + 10) != 1)
  {
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v20);
    v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v21, (uint64_t)"Error: ", 7);
    v14 = *(char *)(a1 + 23);
    if (v14 >= 0)
      v15 = a1;
    else
      v15 = *(_QWORD *)a1;
    if (v14 >= 0)
      v16 = *(unsigned __int8 *)(a1 + 23);
    else
      v16 = *(_QWORD *)(a1 + 8);
    v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, v15, v16);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)" failed to load from ERT model file!", 36);
    exception = __cxa_allocate_exception(0x20uLL);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>(&v19, (uint64_t)&v22);
  }
  v7 = (const void *)*((_QWORD *)v5 + 6);
  v6 = (std::__shared_weak_count *)*((_QWORD *)v5 + 7);
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v23 = v7;
  v24 = v6;
  v10 = *((_QWORD *)v5 + 8);
  std::vector<float>::resize(a3, v10 >> 2);
  memcpy(*a3, v7, v10);
  if (v6)
  {
    v11 = (unint64_t *)&v6->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void sub_1A14BA820(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  void *v15;
  int v16;
  uint64_t v17;

  if (a14 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0)
    {
LABEL_6:
      std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a15);
      std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](v17 - 64);
      _Unwind_Resume(a1);
    }
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

_QWORD *std::vector<vision::mod::ERTTreeNode>::__init_with_size[abi:ne180100]<vision::mod::ERTTreeNode*,vision::mod::ERTTreeNode*>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<vision::mod::ERTTreeNode>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8 - 3);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1A14BA8D8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<vision::mod::ERTTreeNode>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  uint64_t v3;
  char *result;

  if (a2 >= 0x555555555555556)
    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
  v3 = 3 * a2;
  result = (char *)operator new(48 * a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v3];
  return result;
}

void sub_1A14BAC50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  void *v14;
  void *v15;

  if (__p)
    operator delete(__p);
  if (a13)
    operator delete(a13);

  _Unwind_Resume(a1);
}

void sub_1A14BAE6C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A14BB008(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14BB388(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14BB430(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14BB544(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A14BB884(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;

  _Unwind_Resume(a1);
}

void addSpan(int *a1, uint64_t a2)
{
  int v4;
  int v5;
  _QWORD *v6;
  unsigned int v7;
  _QWORD *v8;

  if (!a1)
    __assert_rtn("addSpan", "Spans.c", 88, "spl != NULL");
  v4 = *a1;
  v5 = a1[1];
  if (*a1 < v5 - 1)
  {
    v6 = (_QWORD *)*((_QWORD *)a1 + 1);
LABEL_9:
    v6[v4] = a2;
    ++*a1;
    return;
  }
  if (v5 <= 2)
    v7 = 4;
  else
    v7 = 2 * v5;
  v8 = malloc_type_malloc(8 * v7, 0x100004000313F17uLL);
  if (v8)
  {
    v6 = v8;
    memcpy(v8, *((const void **)a1 + 1), 8 * *a1);
    bzero(&v6[*a1], 8 * (int)(v7 - *a1));
    a1[1] = v7;
    free(*((void **)a1 + 1));
    *((_QWORD *)a1 + 1) = v6;
    v4 = *a1;
    goto LABEL_9;
  }
}

void sub_1A14BCA28(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14BCB44(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14BCBEC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14BCDE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, void *a17)
{
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;

  _Unwind_Resume(a1);
}

void sub_1A14BCE40()
{
  JUMPOUT(0x1A14BCE2CLL);
}

void sub_1A14BCE48()
{
  JUMPOUT(0x1A14BCE30);
}

void sub_1A14BCE50()
{
  JUMPOUT(0x1A14BCE34);
}

void sub_1A14BD1AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;

  _Unwind_Resume(a1);
}

void sub_1A14BD324(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14BD710(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, _Unwind_Exception *exception_object, void *a17, void *a18, void *a19, uint64_t a20,uint64_t a21,char a22)
{
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;

  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a22);
  _Unwind_Resume(a1);
}

void sub_1A14BDBFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  std::__shared_weak_count *v11;
  void *v13;

  std::__shared_weak_count::~__shared_weak_count(v11);
  operator delete(v13);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

BOOL horizonDetectionFFT(uint64_t a1, int a2, int a3, int a4, float *a5, int a6)
{
  int Angles;
  float v8;
  float v9;
  float v10;
  float v12;
  _QWORD v13[4];

  v13[0] = a1;
  v13[1] = a4;
  v13[2] = a3;
  v13[3] = a2;
  Angles = HorizonDetection::getAngles((uint64_t)v13, a6 != 0, &v12, (float *)v13, 0.0);
  if (Angles == 1)
  {
    v8 = (float)(v12 * -180.0) / 3.14159265;
    if (v8 <= 135.0)
    {
      if (v8 < 45.0)
      {
LABEL_7:
        v10 = v8 * 3.14159265 / -180.0;
        *a5 = v10;
        return Angles == 1;
      }
      v9 = -90.0;
    }
    else
    {
      v9 = -180.0;
    }
    v8 = v8 + v9;
    goto LABEL_7;
  }
  return Angles == 1;
}

unint64_t HorizonDetection::getAngles(uint64_t a1, int a2, float *a3, float *a4, float a5)
{
  unint64_t v10;
  unint64_t v11;
  int v12;
  CGColorSpaceRef DeviceRGB;
  CGColorSpace *v14;
  CGDataProvider *v15;
  size_t v16;
  CGImage *v17;
  CGContext *v18;
  CGImage *Image;
  _DWORD *v20;
  _DWORD *v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float *v30;
  _DWORD *v31;
  float *v32;
  uint64_t i;
  float v34;
  __float2 v35;
  float v36;
  float v37;
  __float2 v38;
  float v39;
  float v40;
  __float2 v41;
  float v42;
  float v43;
  float v44;
  int v45;
  float v46;
  int v47;
  uint64_t v48;
  float *v49;
  float *v50;
  float v51;
  float v52;
  uint64_t v53;
  int v54;
  float v55;
  int v56;
  float *v57;
  float *v58;
  int32x2_t v59;
  float *v60;
  float v61;
  BOOL v62;
  float v63;
  float32x4_t v64;
  uint64_t v65;
  float v66;
  float32x4_t *v67;
  float32x4_t v68;
  float v69;
  float *v70;
  float *v71;
  float v72;
  float *v73;
  unint64_t v74;
  unint64_t v75;
  float *v76;
  float v77;
  float *v78;
  float *v79;
  float v80;
  float *v81;
  float *v82;
  float *j;
  std::bad_alloc *exception;
  std::bad_alloc *v86;
  float v87;
  void *v88[3];
  void *v89[3];
  void *v90[3];
  void *data[3];
  vImage_Buffer dest;
  vImage_Buffer src;
  float *v94;
  float *v95;
  uint64_t v96;
  uint64_t v97;
  void *v98[3];
  CGRect v99;

  ++HorizonDetection::frameCount_;
  v11 = *(_QWORD *)(a1 + 8);
  v10 = *(_QWORD *)(a1 + 16);
  if (a2)
    v12 = 4;
  else
    v12 = 1;
  std::vector<unsigned char,apple::vision::AlignedAllocator<unsigned char,32ul>>::vector(data, (v12 << 16));
  if (a2)
    DeviceRGB = CGColorSpaceCreateDeviceRGB();
  else
    DeviceRGB = CGColorSpaceCreateDeviceGray();
  v14 = DeviceRGB;
  v15 = CGDataProviderCreateWithData(0, *(const void **)a1, *(_QWORD *)(a1 + 8) * *(_QWORD *)(a1 + 24), 0);
  if (a2)
    v16 = 32;
  else
    v16 = 8;
  v17 = CGImageCreate(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 8), 8uLL, v16, *(_QWORD *)(a1 + 24), v14, 5u, v15, 0, 1, kCGRenderingIntentDefault);
  v18 = CGBitmapContextCreate(data[0], 0x100uLL, 0x100uLL, 8uLL, (v12 << 8), v14, 5u);
  CGContextSetInterpolationQuality(v18, kCGInterpolationHigh);
  v99.size.width = 256.0;
  v99.origin.x = 0.0;
  v99.origin.y = 0.0;
  v99.size.height = 256.0;
  CGContextDrawImage(v18, v99, v17);
  Image = CGBitmapContextCreateImage(v18);
  CGContextRelease(v18);
  CGImageRelease(v17);
  CGImageRelease(Image);
  CGDataProviderRelease(v15);
  CGColorSpaceRelease(v14);
  std::vector<unsigned char,apple::vision::AlignedAllocator<unsigned char,32ul>>::vector(v90, 0x10000uLL);
  cannyEdgeWithGradientOutput((_BYTE *)data[0], v90[0], 0, 0, 0.55, 0.7);
  thinBin((__int128 *)v90[0]);
  std::vector<float,apple::vision::AlignedAllocator<float,32ul>>::vector(v98, 0x10000);
  *(int64x2_t *)&src.height = vdupq_n_s64(0x100uLL);
  src.rowBytes = 256;
  dest.data = v98[0];
  *(_OWORD *)&dest.height = *(_OWORD *)&src.height;
  dest.rowBytes = 1024;
  src.data = v90[0];
  vImageConvert_Planar8toPlanarF(&src, &dest, 1.0, 0.0, 0);
  std::vector<float,apple::vision::AlignedAllocator<float,32ul>>::vector(v89, 0x10000);
  fftGrayMag((const DSPComplex *)v98[0], (_DWORD *)v89[0], 0);
  if (v98[0])
  {
    v98[1] = v98[0];
    free(v98[0]);
  }
  std::vector<float,apple::vision::AlignedAllocator<float,32ul>>::vector(v88, 1440);
  fftProject((uint64_t)v89[0], (float *)v88[0], (float *)&src, 0.0);
  std::vector<float,apple::vision::AlignedAllocator<float,32ul>>::vector(&v94, 1440);
  std::vector<float,apple::vision::AlignedAllocator<float,32ul>>::vector(&src, 1440);
  std::vector<float,apple::vision::AlignedAllocator<float,32ul>>::vector(&dest, 1440);
  std::vector<float,apple::vision::AlignedAllocator<float,32ul>>::vector(v98, 1440);
  v20 = malloc_type_aligned_alloc(0x20uLL, 0x1680uLL, 0x100004052888210uLL);
  v21 = v20;
  v87 = a5;
  if (!v20)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    v86 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v86, MEMORY[0x1E0DE4EA8], MEMORY[0x1E0DE4DC0]);
  }
  v22 = (float)v10 / (float)v11;
  v23 = (float)v11 / (float)v10;
  bzero(v20 + 1, 0x167CuLL);
  if (v22 >= v23)
    v24 = 1.0;
  else
    v24 = (float)v11 / (float)v10;
  if (v22 >= v23)
    v25 = (float)v10 / (float)v11;
  else
    v25 = 1.0;
  v26 = atan2f(v25 * -0.0010908, v24 * 1.0) * 458.366236 + 1440.0;
  v27 = atan2f(v25 * 0.0010908, v24 * 1.0) * 458.366236;
  v28 = modff(v26, (float *)&v97 + 1);
  v29 = modff(v27, (float *)&v97);
  v30 = (float *)src.data;
  *(float *)src.data = 1.0 - v28;
  v31 = dest.data;
  *(float *)dest.data = v29;
  v32 = (float *)v98[0];
  *(_DWORD *)v98[0] = 0;
  *v21 = 0;
  for (i = 1; i != 1440; ++i)
  {
    v34 = (float)((float)(int)i + -0.5) * 3.14159265 / 1440.0;
    v35 = __sincosf_stret(v34);
    v36 = atan2f(v25 * v35.__sinval, v24 * v35.__cosval) * 458.366236;
    v37 = (float)(int)i * 3.14159265 / 1440.0;
    v38 = __sincosf_stret(v37);
    v39 = atan2f(v25 * v38.__sinval, v24 * v38.__cosval) * 458.366236;
    v40 = (float)((float)(int)i + 0.5) * 3.14159265 / 1440.0;
    v41 = __sincosf_stret(v40);
    v42 = atan2f(v25 * v41.__sinval, v24 * v41.__cosval) * 458.366236;
    v97 = 0;
    v43 = modff(v36, (float *)&v97 + 1);
    v44 = modff(v42, (float *)&v97);
    v45 = (int)*((float *)&v97 + 1);
    v46 = *(float *)&v97;
    v21[i] = (int)v39;
    v47 = (int)v46 - v45;
    if (v47 == 2)
    {
      v30[i] = 1.0 - v43;
      v31[i] = 1065353216;
      goto LABEL_27;
    }
    if (v47 != 1)
    {
      if (v47)
        continue;
      v30[i] = 0.0;
      v44 = v44 - v43;
      goto LABEL_29;
    }
    if (v45 == (int)v39)
    {
      v30[i] = 0.0;
      *(float *)&v31[i] = 1.0 - v43;
LABEL_27:
      v32[i] = v44;
      continue;
    }
    v30[i] = 1.0 - v43;
LABEL_29:
    *(float *)&v31[i] = v44;
    v32[i] = 0.0;
  }
  v48 = 0;
  v49 = (float *)v88[0];
  v50 = v94;
  do
  {
    v51 = v49[v48];
    v52 = v51 * *(float *)&v31[v48];
    v53 = (int)v21[v48];
    if (v53 >= 1)
      v54 = -1;
    else
      v54 = 1439;
    v55 = v32[v48];
    v50[v54 + (int)v53] = (float)(v51 * v30[v48]) + v50[v54 + (int)v53];
    if (v53 <= 1438)
      v56 = v53 + 1;
    else
      v56 = v53 - 1439;
    v50[v53] = v52 + v50[v53];
    v50[v56] = (float)(v51 * v55) + v50[v56];
    ++v48;
  }
  while (v48 != 1440);
  free(v21);
  free(v32);
  free(v31);
  free(v30);
  v57 = v94;
  v58 = v95;
  v94 = 0;
  v95 = 0;
  v96 = 0;
  v59.i32[0] = *(__int32 *)std::__minmax_element_impl[abi:ne180100]<std::__wrap_iter<float *>,std::__wrap_iter<float *>,std::__identity,std::__less<void,void>>(v57, v58);
  v61 = *v60;
  if (*v60 != 1.0 && (*(float *)v59.i32 != 0.0 ? (v62 = *(float *)v59.i32 == v61) : (v62 = 0), v62))
  {
    if ((char *)v58 - (char *)v57 >= 1)
      memset_pattern16(v57, &unk_1A15FB810, 4 * (((unint64_t)((char *)v58 - (char *)v57) >> 2) - ((unint64_t)((char *)v58 - (char *)v57) > 3))+ 4);
  }
  else
  {
    v63 = v61 - *(float *)v59.i32;
    v64 = (float32x4_t)vdupq_lane_s32(v59, 0);
    v65 = 0x3FFFFFFFFFFFFA60;
    v66 = 1.0 / v63;
    do
    {
      v67 = (float32x4_t *)&v57[v65];
      v68 = vmulq_n_f32(vsubq_f32(*(float32x4_t *)&v57[v65 + 1444], v64), v66);
      v67[360] = vmulq_n_f32(vsubq_f32(*(float32x4_t *)&v57[v65 + 1440], v64), v66);
      v67[361] = v68;
      v65 += 8;
    }
    while (v65 * 4);
  }
  if (v57 == v58)
  {
    v70 = a3;
  }
  else
  {
    v69 = 0.0;
    v70 = a3;
    v71 = v57;
    do
    {
      v72 = *v71;
      v73 = a3;
      if (v70 != a3)
      {
        v74 = ((char *)v70 - (char *)a3) >> 3;
        v73 = a3;
        do
        {
          v75 = v74 >> 1;
          v76 = &v73[2 * (v74 >> 1)];
          v77 = v76[1];
          v78 = v76 + 2;
          v74 += ~(v74 >> 1);
          if (v77 < v72)
            v74 = v75;
          else
            v73 = v78;
        }
        while (v74);
      }
      if (v73 != a4)
      {
        v79 = a3;
        v80 = (float)(v69 * -3.1416) / 1440.0;
        if (v73 == a3)
        {
LABEL_61:
          if (v73 == v70)
          {
LABEL_65:
            v81 = v70;
          }
          else
          {
            v81 = v73;
            while (vabds_f32(*v81, v80) >= v87)
            {
              v81 += 2;
              if (v81 == v70)
                goto LABEL_65;
            }
            if (v81 != v70)
            {
              for (j = v81 + 2; j != v70; j += 2)
              {
                if (vabds_f32(*j, v80) >= v87)
                {
                  *(_QWORD *)v81 = *(_QWORD *)j;
                  v81 += 2;
                }
              }
            }
          }
          v82 = v81 + 2;
          if (v82 <= a4)
            v70 = v82;
          else
            v70 = a4;
          if (v73 < v70 && v70 - 2 != v73)
            memmove(v73 + 2, v73, (char *)(v70 - 2) - (char *)v73);
          *v73 = v80;
          v73[1] = v72;
        }
        else
        {
          while (vabds_f32(*v79, v80) >= v87)
          {
            v79 += 2;
            if (v79 == v73)
              goto LABEL_61;
          }
        }
      }
      v69 = v69 + 1.0;
      ++v71;
    }
    while (v71 != v58);
  }
  if (v57)
    free(v57);
  if (v88[0])
  {
    v88[1] = v88[0];
    free(v88[0]);
  }
  if (v89[0])
  {
    v89[1] = v89[0];
    free(v89[0]);
  }
  if (v90[0])
  {
    v90[1] = v90[0];
    free(v90[0]);
  }
  if (data[0])
  {
    data[1] = data[0];
    free(data[0]);
  }
  return (unint64_t)((char *)v70 - (char *)a3) >> 3;
}

void sub_1A14BE51C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33)
{
  if (a24)
    free(a24);
  if (a28)
    free(a28);
  if (a32)
    free(a32);
  if (a12)
    free(a12);
  if (a15)
    free(a15);
  if (a18)
    free(a18);
  if (a21)
    free(a21);
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<float,apple::vision::AlignedAllocator<float,32ul>>::vector(_QWORD *a1, uint64_t a2)
{
  size_t v4;
  char *v5;
  char *v6;
  std::bad_alloc *exception;
  std::bad_alloc *v9;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v4 = 4 * a2;
  v5 = (char *)malloc_type_aligned_alloc(0x20uLL, 4 * a2, 0x100004052888210uLL);
  v6 = v5;
  if (!v5)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    v9 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v9, MEMORY[0x1E0DE4EA8], MEMORY[0x1E0DE4DC0]);
  }
  *a1 = v5;
  a1[2] = &v5[4 * a2];
  bzero(v5, v4);
  a1[1] = &v6[v4];
  return a1;
}

void sub_1A14BE6CC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    free(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<unsigned char,apple::vision::AlignedAllocator<unsigned char,32ul>>::vector(_QWORD *a1, size_t size)
{
  char *v4;
  char *v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v4 = (char *)apple::vision::AlignedAllocator<unsigned char,32ul>::allocate(size);
  *a1 = v4;
  v5 = &v4[size];
  a1[2] = &v4[size];
  bzero(v4, size);
  a1[1] = v5;
  return a1;
}

void sub_1A14BE73C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    free(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t horizonDetectionFFTAngles(uint64_t a1, int a2, int a3, int a4, int a5, int a6, float *a7, float a8)
{
  _QWORD v9[4];

  v9[0] = a1;
  v9[1] = a4;
  v9[2] = a3;
  v9[3] = a2;
  return HorizonDetection::getAngles((uint64_t)v9, a5, a7, &a7[2 * a6], a8);
}

void sub_1A14BE840(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14BEA20(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1A14BEDE0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14BEE44(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14BEE90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A14BF064(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14BF148(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

char *std::vector<vImage_Buffer>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 59)
    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<vImage_Buffer>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[32 * v4];
  return result;
}

void sub_1A14BF57C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1A14C0070(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20,void *a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,void *__p,uint64_t a59,uint64_t a60,void *a61,uint64_t a62)
{
  void *v62;
  void *v63;

  if (__p)
    operator delete(__p);
  if (a61)
    operator delete(a61);

  _Unwind_Resume(a1);
}

void sub_1A14C0280(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14C03D8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14C0570(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14C06A8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14C0780(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14C092C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14C0990(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14C09DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A14C0C64(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14C0E48(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<vision::mod::GazeFollowPredictorConcrete>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453B840;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<vision::mod::GazeFollowPredictorConcrete>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453B840;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A1B0A898);
}

void std::__shared_ptr_emplace<vision::mod::GazeFollowPredictorConcrete>::__on_zero_shared(uint64_t a1)
{
  vision::mod::GazeFollowPredictor::releaseCachedImageBuffers((void **)(a1 + 24));
  if (espresso_plan_destroy())
  {
    syslog(5, "[Espresso Error]: Failed to destroy the existing GazeFollow espresso plan");
LABEL_5:
    syslog(5, "[Error]: Failed to destroy GazeFollowPredictor object");
    goto LABEL_6;
  }
  *(_QWORD *)(a1 + 376) = 0;
  if (espresso_context_destroy())
  {
    syslog(5, "[Espresso Error]: Failed to destroy the existing GazeFollow context");
    goto LABEL_5;
  }
  *(_QWORD *)(a1 + 368) = 0;
LABEL_6:
  if (*(char *)(a1 + 927) < 0)
    operator delete(*(void **)(a1 + 904));
}

double vision::mod::GazeFollowPredictor::releaseCachedImageBuffers(void **this)
{
  double result;

  free(this[12]);
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  free(this[16]);
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  free(this[20]);
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  free(this[24]);
  result = 0.0;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  return result;
}

void std::vector<std::vector<float>>::resize(uint64_t *a1, unint64_t a2, uint64_t a3)
{
  uint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  void *v22;
  void *v23;
  _QWORD *v24;
  uint64_t v25;
  _QWORD v26[2];
  char *v27;
  char *v28;
  _QWORD *v29;

  v5 = *a1;
  v6 = (_QWORD *)a1[1];
  v7 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v6 - *a1) >> 3);
  v8 = a2 - v7;
  if (a2 <= v7)
  {
    if (a2 < v7)
    {
      v20 = (_QWORD *)(v5 + 24 * a2);
      if (v6 != v20)
      {
        v21 = (_QWORD *)a1[1];
        do
        {
          v23 = (void *)*(v21 - 3);
          v21 -= 3;
          v22 = v23;
          if (v23)
          {
            *(v6 - 2) = v22;
            operator delete(v22);
          }
          v6 = v21;
        }
        while (v21 != v20);
      }
      a1[1] = (uint64_t)v20;
    }
  }
  else
  {
    v10 = a1[2];
    if (0xAAAAAAAAAAAAAAABLL * ((v10 - (uint64_t)v6) >> 3) >= v8)
    {
      v24 = &v6[3 * v8];
      v25 = 24 * a2 - 8 * (((uint64_t)v6 - *a1) >> 3);
      do
      {
        *v6 = 0;
        v6[1] = 0;
        v6[2] = 0;
        std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v6, *(const void **)a3, *(_QWORD *)(a3 + 8), (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 2);
        v6 += 3;
        v25 -= 24;
      }
      while (v25);
      a1[1] = (uint64_t)v24;
    }
    else
    {
      if (a2 > 0xAAAAAAAAAAAAAAALL)
        std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
      v29 = a1 + 2;
      v11 = 0xAAAAAAAAAAAAAAABLL * ((v10 - v5) >> 3);
      v12 = 2 * v11;
      if (2 * v11 <= a2)
        v12 = a2;
      if (v11 >= 0x555555555555555)
        v13 = 0xAAAAAAAAAAAAAAALL;
      else
        v13 = v12;
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(v13);
      v15 = &v14[24 * v7];
      v26[0] = v14;
      v26[1] = v15;
      v27 = v15;
      v28 = &v14[24 * v16];
      v17 = 3 * a2;
      v18 = &v14[24 * a2];
      v19 = 8 * v17 - 24 * v7;
      do
      {
        *(_QWORD *)v15 = 0;
        *((_QWORD *)v15 + 1) = 0;
        *((_QWORD *)v15 + 2) = 0;
        std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v15, *(const void **)a3, *(_QWORD *)(a3 + 8), (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 2);
        v15 += 24;
        v19 -= 24;
      }
      while (v19);
      v27 = v18;
      std::vector<std::vector<float>>::__swap_out_circular_buffer(a1, v26);
      std::__split_buffer<std::vector<long long>>::~__split_buffer((uint64_t)v26);
    }
  }
}

void sub_1A14C1284(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  uint64_t v12;
  uint64_t v13;

  *(_QWORD *)(v12 + 8) = v13;
  _Unwind_Resume(exception_object);
}

void std::vector<float>::resize(char **a1, unint64_t a2, _DWORD *a3)
{
  char *v5;
  char *v6;
  unint64_t v7;
  char *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t v14;
  char *v15;
  char *v16;
  uint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  char *i;
  int v22;
  char *v23;
  uint64_t v24;

  v6 = *a1;
  v5 = a1[1];
  v7 = (v5 - *a1) >> 2;
  if (a2 <= v7)
  {
    if (a2 < v7)
      a1[1] = &v6[4 * a2];
  }
  else
  {
    v9 = a1[2];
    if (a2 - v7 <= (v9 - v5) >> 2)
    {
      v23 = &v5[4 * (a2 - v7)];
      v24 = 4 * a2 - 4 * v7;
      do
      {
        *(_DWORD *)v5 = *a3;
        v5 += 4;
        v24 -= 4;
      }
      while (v24);
      a1[1] = v23;
    }
    else
    {
      if (a2 >> 62)
        std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
      v10 = v9 - v6;
      v11 = (v9 - v6) >> 1;
      if (v11 <= a2)
        v11 = a2;
      if (v10 >= 0x7FFFFFFFFFFFFFFCLL)
        v12 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v12 = v11;
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v12);
      v15 = &v13[4 * v7];
      v16 = &v13[4 * a2];
      v17 = 4 * a2 - 4 * v7;
      v18 = v15;
      do
      {
        *(_DWORD *)v18 = *a3;
        v18 += 4;
        v17 -= 4;
      }
      while (v17);
      v19 = &v13[4 * v14];
      v20 = *a1;
      for (i = a1[1]; i != v20; i -= 4)
      {
        v22 = *((_DWORD *)i - 1);
        *((_DWORD *)v15 - 1) = v22;
        v15 -= 4;
      }
      *a1 = v15;
      a1[1] = v16;
      a1[2] = v19;
      if (v20)
        operator delete(v20);
    }
  }
}

_QWORD *std::vector<std::vector<float>>::__swap_out_circular_buffer(_QWORD *result, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  __int128 v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;

  v3 = (_QWORD *)*result;
  v2 = (_QWORD *)result[1];
  v4 = a2[1];
  while (v2 != v3)
  {
    *(_QWORD *)(v4 - 24) = 0;
    *(_QWORD *)(v4 - 16) = 0;
    v4 -= 24;
    *(_QWORD *)(v4 + 16) = 0;
    v5 = *(_OWORD *)(v2 - 3);
    v2 -= 3;
    *(_OWORD *)v4 = v5;
    *(_QWORD *)(v4 + 16) = v2[2];
    *v2 = 0;
    v2[1] = 0;
    v2[2] = 0;
  }
  a2[1] = v4;
  v6 = (_QWORD *)*result;
  *result = v4;
  a2[1] = v6;
  v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t vision::mod::GazeFollowPredictor::postProcessGazeLabels(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  float v4;
  float v5;
  uint64_t v6;
  int v8;
  signed int v9;
  uint64_t i;
  float v11;
  float v12;
  int v14;
  int v15;
  signed int v16;
  int v17;
  int v18;

  if (a2 != a3)
  {
    v4 = *(float *)a4;
    v5 = *(float *)(a4 + 8);
    v6 = a2;
    do
    {
      if (!*(_DWORD *)(v6 + 16) && *(float *)(v6 + 48) >= v4 && (*(float *)(v6 + 12) >= v5 || *(float *)(v6 + 8) >= v5))
      {
        v8 = 0;
        v9 = *(_DWORD *)(a4 + 4);
        for (i = a2; i != a3; i += 136)
        {
          if (*(_DWORD *)(i + 16) != -1
            && (vabds_f32(*(float *)v6, *(float *)i) >= 0.00000011921
             || vabds_f32(*(float *)(v6 + 4), *(float *)(i + 4)) >= 0.00000011921))
          {
            v11 = *(float *)(i + 8);
            v12 = *(float *)(i + 12);
            if (v12 >= v5 || v11 >= v5)
            {
              v14 = *(_DWORD *)(v6 + 52);
              v15 = v14
                  - llroundf((float)(*(float *)i + (float)(v12 * 0.5))* (float)(unint64_t)(*(_QWORD *)(result + 232) - 1));
              if (v15 < 0)
                v15 = -v15;
              if (v15 <= v9)
              {
                v16 = *(_DWORD *)(v6 + 56)
                    - llroundf((float)((float)(v11 * 0.5) + *(float *)(i + 4))* (float)(unint64_t)(*(_QWORD *)(result + 240) - 1));
                if (v16 < 0)
                  v16 = -v16;
                if (v16 <= v9)
                {
                  *(_DWORD *)(v6 + 16) = 3;
                  *(_DWORD *)(v6 + 60) = v8;
                  break;
                }
              }
              v17 = v14 - *(_DWORD *)(i + 52);
              if (v17 < 0)
                v17 = -v17;
              if (v17 <= v9)
              {
                v18 = *(_DWORD *)(v6 + 56) - *(_DWORD *)(i + 56);
                if (v18 < 0)
                  v18 = *(_DWORD *)(i + 56) - *(_DWORD *)(v6 + 56);
                if (v18 <= v9 && *(float *)(i + 48) >= v4)
                  *(_DWORD *)(v6 + 16) = 4;
              }
            }
          }
          ++v8;
        }
      }
      v6 += 136;
    }
    while (v6 != a3);
  }
  return result;
}

void sub_1A14C161C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14C17B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_1A14C18E0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14C1964(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14C19C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A14C1A10(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14C1A5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A14C1B74(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14C1C20(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14C1E44(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_1A14C2554(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, void *a19, void *a20,void *a21,void *a22)
{
  void *v22;
  void *v23;

  _Unwind_Resume(a1);
}

void sub_1A14C2D58(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14C36DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id *a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,void *a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,void *a29,void *a30,void *a31)
{
  void *v31;
  uint64_t v32;
  void *v34;

  objc_destroyWeak((id *)&STACK[0x2D8]);
  _Block_object_dispose(&STACK[0x2E0], 8);
  _Block_object_dispose((const void *)(v32 - 248), 8);

  v34 = *(void **)(v32 - 200);
  if (v34)
  {
    *(_QWORD *)(v32 - 192) = v34;
    operator delete(v34);
  }

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__18622(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__18623(uint64_t a1)
{

}

uint64_t __Block_byref_object_copy__34_18624(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 48) = *(_DWORD *)(a2 + 48);
  return result;
}

void sub_1A14C3AEC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14C3DDC()
{
  __break(1u);
}

void sub_1A14C3E30(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21)
{
  void *v21;
  void *v22;

  objc_end_catch();

  JUMPOUT(0x1A14C3E7CLL);
}

void sub_1A14C3F1C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14C4124(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, void *a17, void *a18, void *a19)
{
  void *v19;

  _Unwind_Resume(a1);
}

void sub_1A14C42C4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14C436C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14C43BC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14C4474(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14C4748(_Unwind_Exception *a1, int a2)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  id v9;
  id v10;
  void *v11;
  void *v12;
  void *v13;

  if (a2 == 1)
  {
    v9 = objc_begin_catch(a1);
    v10 = objc_alloc(MEMORY[0x1E0CB3940]);
    objc_msgSend(v9, "reason");
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    v11 = (void *)objc_msgSend(v10, "initWithFormat:", CFSTR("Failed to unarchive VNFaceLandmarkRegion object. Error: %@"));

    +[VNError errorForInternalErrorWithLocalizedDescription:](VNError, "errorForInternalErrorWithLocalizedDescription:", v11);
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "failWithError:", v12);

    objc_end_catch();
    JUMPOUT(0x1A14C4534);
  }

  _Unwind_Resume(a1);
}

void sub_1A14C4854()
{
  void *v0;
  void *v1;
  void *v2;

  objc_end_catch();
  JUMPOUT(0x1A14C47ACLL);
}

void sub_1A14C4940(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A14C4A28(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14C4BEC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A14C4CD8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14C4F5C(_Unwind_Exception *a1, int a2)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v8;
  id v10;
  id v11;
  void *v12;
  void *v13;
  void *v14;

  v8 = v5;

  if (a2 == 1)
  {
    v10 = objc_begin_catch(a1);
    v11 = objc_alloc(MEMORY[0x1E0CB3940]);
    objc_msgSend(v10, "reason");
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    v12 = (void *)objc_msgSend(v11, "initWithFormat:", CFSTR("Failed to unarchive VNFaceLandmarkRegion2D object. Error: %@"));

    +[VNError errorForInternalErrorWithLocalizedDescription:](VNError, "errorForInternalErrorWithLocalizedDescription:", v12);
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "failWithError:", v13);

    objc_end_catch();
    JUMPOUT(0x1A14C4F34);
  }

  _Unwind_Resume(a1);
}

void sub_1A14C518C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14C5338(void *a1)
{
  os_unfair_lock_s *v1;

  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A14C5360()
{
  objc_end_catch();
  JUMPOUT(0x1A14C5368);
}

void sub_1A14C550C(void *a1)
{
  os_unfair_lock_s *v1;

  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A14C5538()
{
  objc_end_catch();
  JUMPOUT(0x1A14C5540);
}

void sub_1A14C56AC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14C58E4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A14C59F4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14C5C34(_Unwind_Exception *a1, int a2)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v8;
  id v10;
  id v11;
  void *v12;
  void *v13;
  void *v14;

  v8 = v5;

  if (a2 == 1)
  {
    v10 = objc_begin_catch(a1);
    v11 = objc_alloc(MEMORY[0x1E0CB3940]);
    objc_msgSend(v10, "reason");
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    v12 = (void *)objc_msgSend(v11, "initWithFormat:", CFSTR("Failed to unarchive VNFaceLandmarkRegion3D object. Error: %@"));

    +[VNError errorForInternalErrorWithLocalizedDescription:](VNError, "errorForInternalErrorWithLocalizedDescription:", v12);
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "failWithError:", v13);

    objc_end_catch();
    JUMPOUT(0x1A14C5C0CLL);
  }

  _Unwind_Resume(a1);
}

void sub_1A14C5E28(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14C5F40(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14C6340(_Unwind_Exception *a1, int a2)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  id v10;
  id v11;
  void *v12;
  void *v13;
  void *v14;

  if (a2 == 1)
  {
    v10 = objc_begin_catch(a1);
    v11 = objc_alloc(MEMORY[0x1E0CB3940]);
    objc_msgSend(v10, "reason");
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    v12 = (void *)objc_msgSend(v11, "initWithFormat:", CFSTR("Failed to unarchive VNFaceLandmarks object. Error: %@"));

    +[VNError errorForInternalErrorWithLocalizedDescription:](VNError, "errorForInternalErrorWithLocalizedDescription:", v12);
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "failWithError:", v13);

    objc_end_catch();
    JUMPOUT(0x1A14C61D0);
  }

  _Unwind_Resume(a1);
}

void sub_1A14C6488()
{
  void *v0;
  void *v1;
  void *v2;

  objc_end_catch();
  JUMPOUT(0x1A14C6384);
}

void sub_1A14C65FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A14C6844(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14C6B54(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v5 = v3;

  _Unwind_Resume(a1);
}

void sub_1A14C6C3C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14C6E68(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A14C708C(_Unwind_Exception *a1, int a2)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  id v8;
  id v9;
  void *v10;
  void *v11;
  void *v12;

  if (a2 == 1)
  {
    v8 = objc_begin_catch(a1);
    v9 = objc_alloc(MEMORY[0x1E0CB3940]);
    objc_msgSend(v8, "reason");
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    v10 = (void *)objc_msgSend(v9, "initWithFormat:", CFSTR("Failed to unarchive VNFaceLandmarks2D object. Error: %@"));

    +[VNError errorForInternalErrorWithLocalizedDescription:](VNError, "errorForInternalErrorWithLocalizedDescription:", v10);
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "failWithError:", v11);

    objc_end_catch();
    JUMPOUT(0x1A14C7060);
  }

  _Unwind_Resume(a1);
}

void sub_1A14C7250(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14C74FC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14C7664(void *a1)
{
  os_unfair_lock_s *v1;
  void *v2;
  void *v3;

  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A14C76A0(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A14C77E4(void *a1)
{
  os_unfair_lock_s *v1;
  void *v2;

  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A14C782C(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A14C7920(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14C79E0(void *a1)
{
  os_unfair_lock_s *v1;

  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A14C79F8(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A14C7AA0(void *a1)
{
  os_unfair_lock_s *v1;

  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A14C7AB8(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A14C7B60(void *a1)
{
  os_unfair_lock_s *v1;

  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A14C7B78(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A14C7C20(void *a1)
{
  os_unfair_lock_s *v1;

  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A14C7C38(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A14C7CE0(void *a1)
{
  os_unfair_lock_s *v1;

  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A14C7CF8(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A14C7DA0(void *a1)
{
  os_unfair_lock_s *v1;

  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A14C7DB8(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A14C7E60(void *a1)
{
  os_unfair_lock_s *v1;

  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A14C7E78(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A14C7F20(void *a1)
{
  os_unfair_lock_s *v1;

  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A14C7F38(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A14C7FE0(void *a1)
{
  os_unfair_lock_s *v1;

  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A14C7FF8(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A14C80A0(void *a1)
{
  os_unfair_lock_s *v1;

  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A14C80B8(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A14C8160(void *a1)
{
  os_unfair_lock_s *v1;

  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A14C8178(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A14C8290(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A14C84DC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14C8604(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14C8700(_Unwind_Exception *a1, int a2)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  id v8;
  id v9;
  void *v10;
  void *v11;
  void *v12;

  if (a2 == 1)
  {
    v8 = objc_begin_catch(a1);
    v9 = objc_alloc(MEMORY[0x1E0CB3940]);
    objc_msgSend(v8, "reason");
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    v10 = (void *)objc_msgSend(v9, "initWithFormat:", CFSTR("Failed to unarchive VNFaceLandmarks3D object. Error: %@"));

    +[VNError errorForInternalErrorWithLocalizedDescription:](VNError, "errorForInternalErrorWithLocalizedDescription:", v10);
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "failWithError:", v11);

    objc_end_catch();
    JUMPOUT(0x1A14C86CCLL);
  }

  _Unwind_Resume(a1);
}

void sub_1A14C88F8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14C8A04(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14C8B54(void *a1)
{
  os_unfair_lock_s *v1;
  void *v2;
  void *v3;

  if (v2)
    operator delete(v2);
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A14C8B94(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A14C8C68(void *a1)
{
  os_unfair_lock_s *v1;
  void *v2;

  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A14C8C90(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A14C8D64(void *a1)
{
  os_unfair_lock_s *v1;
  void *v2;

  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A14C8D8C(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A14C8E60(void *a1)
{
  os_unfair_lock_s *v1;
  void *v2;

  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A14C8E88(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A14C8F5C(void *a1)
{
  os_unfair_lock_s *v1;
  void *v2;

  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A14C8F84(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A14C9058(void *a1)
{
  os_unfair_lock_s *v1;
  void *v2;

  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A14C9080(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A14C9154(void *a1)
{
  os_unfair_lock_s *v1;
  void *v2;

  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A14C917C(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A14C9250(void *a1)
{
  os_unfair_lock_s *v1;
  void *v2;

  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A14C9278(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A14C934C(void *a1)
{
  os_unfair_lock_s *v1;
  void *v2;

  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A14C9374(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A14C9448(void *a1)
{
  os_unfair_lock_s *v1;
  void *v2;

  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A14C9470(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A14C9544(void *a1)
{
  os_unfair_lock_s *v1;
  void *v2;

  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A14C956C(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

unint64_t straightLineLSQ(__int16 *a1, int a2)
{
  int v2;
  int v3;
  float v4;
  float v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  __int16 *v11;
  int v12;
  int v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  int v22;
  float v23;
  float v24;

  if (a2 == 2)
  {
    v2 = *a1;
    v3 = a1[1];
    v4 = (float)(a1[2] - v2) / (float)(a1[3] - v3);
    v5 = (float)v3 - (float)(v4 * (float)v2);
  }
  else
  {
    if (a2 < 1)
    {
      v14 = 0.0;
      v16 = 0.0;
      v15 = 0.0;
      v17 = 0.0;
    }
    else
    {
      v6 = 0;
      v7 = 0;
      v8 = 0;
      v9 = 0;
      v10 = a2;
      v11 = a1;
      do
      {
        v12 = *v11;
        v13 = v11[1];
        v9 += v12;
        v8 += v13;
        v7 += v12 * v12;
        v6 += v13 * v12;
        v11 += 2;
        --v10;
      }
      while (v10);
      v14 = (float)v9;
      v15 = (float)v7;
      v16 = (float)v8;
      v17 = (float)v6;
    }
    v18 = v14 / (float)a2;
    v19 = -(float)(v18 * (float)a2);
    v20 = v15 + (float)(v19 * v18);
    if (v20 == 0.0)
    {
      v5 = (float)*a1;
      v4 = INFINITY;
    }
    else
    {
      v21 = v16 / (float)a2;
      v4 = (float)(v17 + (float)(v19 * v21)) / v20;
      v5 = v21 - (float)(v4 * v18);
      if (a2 >= 1)
      {
        v22 = 0;
        v23 = -1.0;
        do
        {
          v24 = vabds_f32((float)a1[1] + (float)((float)-v4 * (float)*a1), v5);
          if (v24 > v23)
            v23 = v24;
          ++v22;
          a1 += 2;
        }
        while (a2 != v22);
      }
    }
  }
  return LODWORD(v4) | ((unint64_t)LODWORD(v5) << 32);
}

unint64_t straightLineWLSQ(__int16 *a1, int a2)
{
  int v2;
  int v3;
  float v4;
  float v5;
  int v6;
  __int16 *v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  int v14;
  float v15;
  float v16;
  float v17;
  int v18;
  int v19;
  int v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  int v30;
  int v31;
  float v32;
  float v33;
  float v34;

  v2 = *a1;
  v3 = a1[1];
  if (a2 == 2)
  {
    v4 = (float)(a1[3] - v3) / (float)(a1[2] - v2);
    v5 = (float)v3 - (float)(v4 * (float)v2);
  }
  else
  {
    v5 = (float)v3;
    if (a2 < 2)
      goto LABEL_17;
    v6 = 0;
    v7 = a1 + 2;
    v8 = (float)v2;
    v9 = (float)((float)v2 * v5) * 0.5;
    v10 = (float)(v8 * v8) * 0.5;
    v11 = v5 * 0.5;
    v12 = (float)v2 * 0.5;
    v13 = 0.0;
    v14 = 1;
    v15 = (float)v3;
    v16 = (float)v2;
    v17 = 0.5;
    do
    {
      v18 = *v7;
      v19 = v7[1];
      if (v3 != v19)
      {
        v20 = v2 + v18;
        v21 = (float)v20 * 0.5;
        v22 = v21 - v16;
        if (v6)
        {
          if (v22 > v13)
            v13 = v21 - v16;
          v12 = v12 + (float)(v16 * v13);
          v11 = v11 + (float)(v15 * v13);
          v10 = v10 + (float)((float)(v16 * v16) * v13);
          v9 = v9 + (float)((float)(v16 * v15) * v13);
          v17 = v17 + v13;
        }
        v15 = (float)(v3 + v19) * 0.5;
        ++v6;
        v16 = (float)v20 * 0.5;
        v13 = v22;
      }
      ++v14;
      v7 += 2;
      v3 = v19;
      v2 = v18;
    }
    while (a2 != v14);
    if (v6)
    {
      v23 = (float)a1[2 * (a2 - 2) + 2];
      v24 = v23 - v16;
      if ((float)(v23 - v16) <= v13)
        v24 = v13;
      v25 = (float)(v17 + v24) + 0.5;
      v26 = (float)((float)(v12 + (float)(v16 * v24)) + (float)(v23 * 0.5)) / v25;
      v27 = -(float)(v25 * v26);
      v28 = (float)((float)(v10 + (float)((float)(v16 * v16) * v24)) + (float)((float)(v23 * v23) * 0.5))
          + (float)(v27 * v26);
      if (v28 == 0.0)
      {
        v4 = INFINITY;
        v5 = v8;
      }
      else
      {
        v30 = 0;
        v31 = a1[2 * (a2 - 2) + 3];
        v32 = (float)((float)(v11 + (float)(v15 * v24)) + (float)((float)v31 * 0.5)) / v25;
        v4 = (float)((float)((float)(v9 + (float)((float)(v16 * v15) * v24)) + (float)((float)(v23 * (float)v31) * 0.5))
                   + (float)(v27 * v32))
           / v28;
        v5 = v32 - (float)(v4 * v26);
        v33 = -1.0;
        do
        {
          v34 = vabds_f32((float)a1[1] + (float)((float)-v4 * (float)*a1), v5);
          if (v34 > v33)
            v33 = v34;
          ++v30;
          a1 += 2;
        }
        while (a2 != v30);
      }
    }
    else
    {
LABEL_17:
      v4 = 0.0;
    }
  }
  return LODWORD(v4) | ((unint64_t)LODWORD(v5) << 32);
}

float Lsq2Leq(uint64_t a1)
{
  float v1;
  float result;

  if (fabsf(*(float *)&a1) == INFINITY)
    return 1.0;
  v1 = 1.0 / sqrtf((float)(*(float *)&a1 * *(float *)&a1) + 1.0);
  result = -(float)(*(float *)&a1 * v1);
  if ((float)(v1 * COERCE_FLOAT(HIDWORD(a1) ^ 0x80000000)) > 0.0)
    return -(float)(v1 * (float)-*(float *)&a1);
  return result;
}

uint64_t applyCoordTransform(uint64_t result, uint64_t a2, int a3)
{
  int v3;
  _DWORD *v4;
  unint64_t v5;
  int v6;
  _WORD *v7;
  _WORD *v8;

  if ((result & 1) != 0 && a3 >= 1)
  {
    v3 = a3;
    v4 = (_DWORD *)a2;
    do
    {
      HIDWORD(v5) = *v4;
      LODWORD(v5) = *v4;
      *v4++ = v5 >> 16;
      --v3;
    }
    while (v3);
  }
  if ((result & 0x100) != 0 && a3 >= 1)
  {
    v6 = a3;
    v7 = (_WORD *)a2;
    do
    {
      *v7 = -*v7;
      v7 += 2;
      --v6;
    }
    while (v6);
  }
  if ((result & 0x10000) != 0 && a3 >= 1)
  {
    v8 = (_WORD *)(a2 + 2);
    do
    {
      *v8 = -*v8;
      v8 += 2;
      --a3;
    }
    while (a3);
  }
  return result;
}

void sub_1A14C9D60(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14CA0C4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A14CA228(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14CA330(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14CA41C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14CA560(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14CA630(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14CA70C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14CA7E8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14CA8B8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14CA9BC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14CAAA0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14CAB70(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14CAC54(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14CAD68(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14CAE54(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14CAF80(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A14CB068(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14CB144(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14CB214(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14CB30C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14CB494(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14CB58C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14CB718(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14CB828(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14CB8B4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14CB954(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14CBA4C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14CBBD8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

BOOL _validatePercentageValue(void *a1, _QWORD *a2, double a3)
{
  id v5;
  _BOOL8 v6;
  void *v7;

  v5 = a1;
  v6 = a3 <= 1.0 && a3 >= 0.0;
  if (!v6 && a2)
  {
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", a3);
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    +[VNError errorForInvalidOption:named:localizedDescription:](VNError, "errorForInvalidOption:named:localizedDescription:", v7, v5, 0);
    *a2 = (id)objc_claimAutoreleasedReturnValue();

  }
  return v6;
}

void sub_1A14CBCD0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14CBD5C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14CBE54(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14CC3E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *exc_buf, void *a12, void *a13, void *__p, uint64_t a15, uint64_t a16, void *a17, uint64_t a18)
{
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;

  if (a2)
  {

    if (__p)
      operator delete(__p);

    if (a17)
      operator delete(a17);

    objc_begin_catch(a1);
    JUMPOUT(0x1A14CC25CLL);
  }
  _Unwind_Resume(a1);
}

void std::vector<_Geometry2D_point2D_>::push_back[abi:ne180100](void **a1, _QWORD *a2)
{
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  char *v14;
  char *v15;
  uint64_t v16;

  v5 = a1[1];
  v4 = (unint64_t)a1[2];
  if ((unint64_t)v5 >= v4)
  {
    v7 = ((char *)v5 - (_BYTE *)*a1) >> 3;
    if ((unint64_t)(v7 + 1) >> 61)
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    v8 = v4 - (_QWORD)*a1;
    v9 = v8 >> 2;
    if (v8 >> 2 <= (unint64_t)(v7 + 1))
      v9 = v7 + 1;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8)
      v10 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v10 = v9;
    if (v10)
      v10 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v10);
    else
      v11 = 0;
    v12 = (_QWORD *)(v10 + 8 * v7);
    v13 = v10 + 8 * v11;
    *v12 = *a2;
    v6 = v12 + 1;
    v15 = (char *)*a1;
    v14 = (char *)a1[1];
    if (v14 != *a1)
    {
      do
      {
        v16 = *((_QWORD *)v14 - 1);
        v14 -= 8;
        *--v12 = v16;
      }
      while (v14 != v15);
      v14 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v6;
    a1[2] = (void *)v13;
    if (v14)
      operator delete(v14);
  }
  else
  {
    *v5 = *a2;
    v6 = v5 + 1;
  }
  a1[1] = v6;
}

void sub_1A14CCDCC(_Unwind_Exception *a1, int a2)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v7;

  v7 = v5;

  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x1A14CCCD4);
  }

  _Unwind_Resume(a1);
}

void sub_1A14CCFD8(_Unwind_Exception *a1, int a2)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v7;

  v7 = v5;

  if (a2 == 1)
  {
    objc_begin_catch(a1);
    objc_end_catch();
    JUMPOUT(0x1A14CCF6CLL);
  }

  _Unwind_Resume(a1);
}

void sub_1A14CD1E0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  v6 = v5;

  _Unwind_Resume(a1);
}

void sub_1A14CD4C8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14CD4E0(void *exc_buf, int a2)
{
  if (a2 == 1)
  {
    objc_begin_catch(exc_buf);
    objc_end_catch();
    JUMPOUT(0x1A14CD3B4);
  }
  JUMPOUT(0x1A14CD4D0);
}

void sub_1A14CD6DC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14CD79C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14CDBB0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1A14CDF0C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14CE56C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

BOOL apple::vision::VNGetSerializingClassCodeForClassName(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return +[VNClassRegistrar getClassCode:forClassName:error:](VNClassRegistrar, "getClassCode:forClassName:error:", a2, a1, a3);
}

void sub_1A14CE880(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14CEA68(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_1A14CEB78(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14CEBF8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14CED70(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14CEEFC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14CEFD0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14CF0CC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14CF894(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

uint64_t vision::mod::FaceID3KmeansParams::serialize()
{
  _QWORD *v0;
  _QWORD *v1;
  uint64_t *v2;
  _QWORD *v4;
  _QWORD *v5;

  v0 = (_QWORD *)std::ostream::write();
  if ((*((_BYTE *)v0 + *(_QWORD *)(*v0 - 24) + 32) & 5) != 0
    || (v1 = (_QWORD *)std::ostream::write(), (*((_BYTE *)v1 + *(_QWORD *)(*v1 - 24) + 32) & 5) != 0))
  {
    v2 = &CVML_status_IOError;
  }
  else
  {
    v4 = (_QWORD *)std::ostream::write();
    v2 = &CVML_status_IOError;
    if ((*((_BYTE *)v4 + *(_QWORD *)(*v4 - 24) + 32) & 5) == 0)
    {
      v5 = (_QWORD *)std::ostream::write();
      if ((*((_BYTE *)v5 + *(_QWORD *)(*v5 - 24) + 32) & 5) == 0)
        v2 = &CVML_status_ok;
    }
  }
  return (*v2 + 128) | 0x2B00;
}

uint64_t vision::mod::FaceID3KmeansParams::deserialize()
{
  _QWORD *v0;
  _QWORD *v1;
  uint64_t *v2;
  _QWORD *v4;
  _QWORD *v5;

  v0 = (_QWORD *)std::istream::read();
  if ((*((_BYTE *)v0 + *(_QWORD *)(*v0 - 24) + 32) & 5) != 0
    || (v1 = (_QWORD *)std::istream::read(), (*((_BYTE *)v1 + *(_QWORD *)(*v1 - 24) + 32) & 5) != 0))
  {
    v2 = &CVML_status_IOError;
  }
  else
  {
    v4 = (_QWORD *)std::istream::read();
    v2 = &CVML_status_IOError;
    if ((*((_BYTE *)v4 + *(_QWORD *)(*v4 - 24) + 32) & 5) == 0)
    {
      v5 = (_QWORD *)std::istream::read();
      if ((*((_BYTE *)v5 + *(_QWORD *)(*v5 - 24) + 32) & 5) == 0)
        v2 = &CVML_status_ok;
    }
  }
  return (*v2 + 128) | 0x2B00;
}

_QWORD *std::__hash_table<std::__hash_value_type<int,std::vector<long long>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<long long>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<long long>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<long long>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t *a1, int a2, _DWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  void **v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  int8x8_t prime;
  void *v19;
  void *v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;
  uint8x8_t v24;
  unint64_t v25;
  uint8x8_t v26;
  uint64_t v27;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  unint64_t v32;
  void *v34;

  v6 = a2;
  v7 = a1[1];
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = (v7 - 1) & a2;
    }
    v9 = *(void ***)(*a1 + 8 * v3);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2)
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  v12 = a1 + 2;
  v10 = operator new(0x30uLL);
  *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v10[4] = 0;
  v10[5] = 0;
  v10[3] = 0;
  v13 = (float)(unint64_t)(a1[3] + 1);
  v14 = *((float *)a1 + 8);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    v15 = 1;
    if (v7 >= 3)
      v15 = (v7 & (v7 - 1)) != 0;
    v16 = v15 | (2 * v7);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      prime = (int8x8_t)v17;
    else
      prime = (int8x8_t)v16;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v7 = a1[1];
    }
    if (*(_QWORD *)&prime > v7)
      goto LABEL_30;
    if (*(_QWORD *)&prime < v7)
    {
      v25 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v7 < 3 || (v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
      {
        v25 = std::__next_prime(v25);
      }
      else
      {
        v27 = 1 << -(char)__clz(v25 - 1);
        if (v25 >= 2)
          v25 = v27;
      }
      if (*(_QWORD *)&prime <= v25)
        prime = (int8x8_t)v25;
      if (*(_QWORD *)&prime >= v7)
      {
        v7 = a1[1];
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v19 = operator new(8 * *(_QWORD *)&prime);
          v20 = (void *)*a1;
          *a1 = (uint64_t)v19;
          if (v20)
            operator delete(v20);
          v21 = 0;
          a1[1] = (uint64_t)prime;
          do
            *(_QWORD *)(*a1 + 8 * v21++) = 0;
          while (*(_QWORD *)&prime != v21);
          v22 = (_QWORD *)*v12;
          if (*v12)
          {
            v23 = v22[1];
            v24 = (uint8x8_t)vcnt_s8(prime);
            v24.i16[0] = vaddlv_u8(v24);
            if (v24.u32[0] > 1uLL)
            {
              if (v23 >= *(_QWORD *)&prime)
                v23 %= *(_QWORD *)&prime;
            }
            else
            {
              v23 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*a1 + 8 * v23) = v12;
            v28 = (_QWORD *)*v22;
            if (*v22)
            {
              do
              {
                v29 = v28[1];
                if (v24.u32[0] > 1uLL)
                {
                  if (v29 >= *(_QWORD *)&prime)
                    v29 %= *(_QWORD *)&prime;
                }
                else
                {
                  v29 &= *(_QWORD *)&prime - 1;
                }
                if (v29 != v23)
                {
                  if (!*(_QWORD *)(*a1 + 8 * v29))
                  {
                    *(_QWORD *)(*a1 + 8 * v29) = v22;
                    goto LABEL_55;
                  }
                  *v22 = *v28;
                  *v28 = **(_QWORD **)(*a1 + 8 * v29);
                  **(_QWORD **)(*a1 + 8 * v29) = v28;
                  v28 = v22;
                }
                v29 = v23;
LABEL_55:
                v22 = v28;
                v28 = (_QWORD *)*v28;
                v23 = v29;
              }
              while (v28);
            }
          }
          v7 = (unint64_t)prime;
          goto LABEL_59;
        }
        v34 = (void *)*a1;
        *a1 = 0;
        if (v34)
          operator delete(v34);
        v7 = 0;
        a1[1] = 0;
      }
    }
LABEL_59:
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
  }
  v30 = *a1;
  v31 = *(_QWORD **)(*a1 + 8 * v3);
  if (v31)
  {
    *v10 = *v31;
LABEL_72:
    *v31 = v10;
    goto LABEL_73;
  }
  *v10 = *v12;
  *v12 = v10;
  *(_QWORD *)(v30 + 8 * v3) = v12;
  if (*v10)
  {
    v32 = *(_QWORD *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7)
        v32 %= v7;
    }
    else
    {
      v32 &= v7 - 1;
    }
    v31 = (_QWORD *)(*a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  ++a1[3];
  return v10;
}

void sub_1A14CFEDC(_Unwind_Exception *a1)
{
  _QWORD *v1;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,std::vector<unsigned int>>,void *>>>::operator()[abi:ne180100](1, v1);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::FaceID3Model::buildModel(uint64_t a1, vision::mod::ImageDescriptorBufferAbstract *a2, uint64_t *a3, uint64_t a4)
{
  BOOL v4;
  uint64_t v6;
  double v10;
  const char *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v15;
  unint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  unint64_t v19;
  char *v20;
  _DWORD *v21;
  char *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  _DWORD *v28;
  int v29;
  uint64_t v30;
  int v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  const void *DataForKthDescriptor;
  void *v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  double v49;
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v50;
  unint64_t v51;
  uint64_t v52;
  float *v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  float *v57;
  float v58;
  uint64_t v59;
  uint64_t v60;
  float v61;
  float *v62;
  uint64_t v63;
  uint64_t v64;
  float v65;
  float v66;
  char *v67;
  char *v68;
  unint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  unint64_t v73;
  uint64_t v74;
  char *v75;
  void *v76;
  uint64_t v77;
  void *v78;
  uint64_t v79;
  void *v80;
  int v81;
  uint64_t DeepCopy;
  uint64_t v83;
  char *v84;
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> *v85;
  uint64_t v86;
  float v87;
  float v88;
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v89;
  uint64_t i;
  uint64_t j;
  uint64_t v92;
  float v93;
  __int128 v94;
  int v95;
  void *v96;
  const void *v97;
  uint64_t v98;
  int v99;
  _DWORD *v100;
  uint64_t v101;
  uint64_t v102;
  int *v103;
  uint64_t v104;
  std::vector<int>::pointer begin;
  float *v106;
  int v107;
  float v108;
  float *v109;
  float v110;
  uint64_t v111;
  float *v112;
  float v113;
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v114;
  float v115;
  float v116;
  std::vector<int>::pointer v117;
  unint64_t v118;
  unint64_t v119;
  float *v120;
  float *v121;
  float v122;
  unint64_t v123;
  void *v124;
  const void *v125;
  uint64_t v126;
  float *v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  float v132;
  _DWORD *v133;
  uint64_t v134;
  float *v135;
  float v136;
  float v137;
  float *v138;
  float v139;
  void *v140;
  const void *v141;
  void *v142;
  __int128 v143;
  int v144;
  unint64_t v145;
  unint64_t k;
  void *v147;
  const void *v148;
  std::vector<int>::pointer v149;
  std::vector<int>::pointer v150;
  uint64_t v151;
  uint64_t v152;
  void *v153;
  uint64_t m;
  unint64_t n;
  unint64_t v156;
  int v157;
  const float *v158;
  float *v159;
  unint64_t v160;
  char *v161;
  char *v162;
  uint64_t ii;
  uint64_t v164;
  unint64_t v165;
  unint64_t v166;
  uint64_t v167;
  char *v168;
  char *v169;
  int v170;
  uint64_t *v171;
  uint64_t *v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t *v175;
  uint64_t v176;
  uint64_t v177;
  size_t v178;
  uint64_t v179;
  unint64_t v180;
  void *v181;
  const void *v182;
  float v183;
  unint64_t jj;
  void *v185;
  const void *v186;
  int v187;
  const float *v188;
  float *v189;
  float *v190;
  float v191;
  uint64_t v192;
  float v193;
  float v194;
  float v196;
  unint64_t kk;
  void *v198;
  const void *v199;
  char *v200;
  char *v201;
  unint64_t v202;
  uint64_t v203;
  int v204;
  uint64_t v205;
  unint64_t v206;
  unint64_t v207;
  uint64_t v208;
  char *v209;
  void *v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  char *v215;
  std::logic_error *v216;
  std::logic_error *v217;
  std::logic_error *v218;
  std::logic_error *v219;
  std::logic_error *v220;
  std::logic_error *exception;
  uint64_t v222;
  uint64_t v223;
  uint64_t *v224;
  int v225;
  uint64_t v226;
  int v227;
  uint64_t *v228;
  int v229;
  float *v230;
  vision::mod::FaceID3Model *v231;
  vision::mod::ImageDescriptorBufferAbstract *v232;
  uint64_t v233;
  int v234;
  std::vector<int>::size_type v235;
  int v236;
  size_t v237;
  uint64_t v238;
  unint64_t v239;
  void *v240;
  uint64_t __n;
  int __na;
  unint64_t v243;
  uint64_t v244;
  __int128 v245;
  __int128 v246;
  int v247;
  _OWORD v248[2];
  int v249;
  void *v250[2];
  __int128 v251;
  char v252;
  void *v253[2];
  __int128 v254;
  uint64_t v255;
  char v256;
  void *v257[2];
  __int128 v258;
  uint64_t v259;
  char v260;
  int v261;
  float v262;
  void *v263;
  void *v264;
  unint64_t v265;
  unint64_t v266;
  uint64_t v267;
  char v268;
  void *v269[2];
  __int128 v270;
  char v271;
  void *v272[2];
  __int128 v273;
  char v274;
  float v275;
  std::vector<int>::value_type v276[2];
  float *v277;
  char v278;
  std::vector<int> v279;
  void *__p[2];
  __int128 v281;
  uint64_t v282;
  char v283;
  void *v284;
  float *v285;
  unint64_t v286;
  unint64_t v287;
  uint64_t v288;
  char v289;
  void *v290;
  uint64_t v291;
  unint64_t v292;
  unint64_t v293;
  int v294;
  char v295;
  void *__src;
  float *v297;
  std::vector<int> v298;
  void *__dst;
  void *v300;
  std::vector<int>::value_type __x[2];
  std::vector<int>::value_type *v302;
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> v303;
  uint64_t v304;

  v304 = *MEMORY[0x1E0C80C00];
  if (*((_QWORD *)a2 + 8))
    v4 = *((_QWORD *)a2 + 12) == 0;
  else
    v4 = 1;
  if (v4 || (v6 = *((_QWORD *)a2 + 9)) == 0)
  {
    syslog(5, "ERROR: invalid image descriptor buffer for training");
    return 11132;
  }
  if (v6 != (a3[1] - *a3) >> 2)
  {
    syslog(5, "ERROR: size mismatch between descriptors and their labels");
    return 11132;
  }
  if (*(int *)a1 < 1)
  {
    syslog(5, "ERROR: negative or zero maxElems_");
  }
  else if (*(int *)(a1 + 4) < 1)
  {
    syslog(5, "ERROR: negative or zero maxNumIds_");
  }
  else if (*(int *)(a1 + 16) < 1)
  {
    syslog(5, "ERROR: negative or zero maxIter_");
  }
  else
  {
    if (*(int *)(a1 + 12) < 1)
    {
      v11 = "ERROR: negative or zero nInits_ in kmeans";
    }
    else
    {
      v10 = *(double *)(a1 + 24);
      v11 = "ERROR: invalid tol_ in kmeans";
      if (v10 < 1.0 && v10 > 0.0)
      {
        v12 = &CVML_status_ok;
        goto LABEL_24;
      }
    }
    syslog(5, v11);
  }
  v12 = &CVML_status_invalidParameter;
LABEL_24:
  v13 = (*v12 + 128) | 0x2B00;
  if (v13 == 11136)
  {
    memset(v248, 0, sizeof(v248));
    v249 = 1065353216;
    v245 = 0u;
    v246 = 0u;
    v247 = 1065353216;
    v15 = *a3;
    if (a3[1] == *a3)
    {
LABEL_359:
      v13 = 11136;
      goto LABEL_360;
    }
    v16 = 0;
    do
    {
      v17 = std::__hash_table<std::__hash_value_type<int,std::vector<int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<int>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t *)v248, *(_DWORD *)(v15 + 4 * v16), (_DWORD *)(v15 + 4 * v16));
      v18 = v17;
      v20 = (char *)v17[4];
      v19 = v17[5];
      if ((unint64_t)v20 >= v19)
      {
        v22 = (char *)v17[3];
        v23 = (v20 - v22) >> 2;
        v24 = v23 + 1;
        if ((unint64_t)(v23 + 1) >> 62)
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        v25 = v19 - (_QWORD)v22;
        if (v25 >> 1 > v24)
          v24 = v25 >> 1;
        if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFFCLL)
          v26 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v26 = v24;
        if (v26)
        {
          v26 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v26);
          v22 = (char *)v18[3];
          v20 = (char *)v18[4];
        }
        else
        {
          v27 = 0;
        }
        v28 = (_DWORD *)(v26 + 4 * v23);
        *v28 = v16;
        v21 = v28 + 1;
        while (v20 != v22)
        {
          v29 = *((_DWORD *)v20 - 1);
          v20 -= 4;
          *--v28 = v29;
        }
        v18[3] = v28;
        v18[4] = v21;
        v18[5] = v26 + 4 * v27;
        if (v22)
          operator delete(v22);
      }
      else
      {
        *(_DWORD *)v20 = v16;
        v21 = v20 + 4;
      }
      v18[4] = v21;
      std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>((float *)&v245, *(_DWORD *)(*a3 + 4 * v16), *(_DWORD *)(*a3 + 4 * v16));
      ++v16;
      v15 = *a3;
    }
    while (v16 < (a3[1] - *a3) >> 2);
    v13 = 11136;
    if (*((_QWORD *)&v246 + 1))
    {
      v30 = v246;
      if ((_QWORD)v246)
      {
        v231 = (vision::mod::FaceID3Model *)a1;
        v232 = a2;
        v226 = a4;
        v229 = 0;
        v230 = (float *)(a1 + 96);
        v224 = (uint64_t *)(a1 + 56);
        v222 = MEMORY[0x1E0DE5028] + 16;
        v223 = MEMORY[0x1E0DE5038] + 16;
        while (1)
        {
          v228 = (uint64_t *)v30;
          v31 = *(_DWORD *)(v30 + 16);
          v32 = std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::find<int>(*(uint64_t *)&v248[0], *((unint64_t *)&v248[0] + 1), v31);
          v261 = v31;
          v34 = v32[3];
          v33 = v32[4];
          v35 = v33 - v34;
          if (v33 == v34)
            goto LABEL_347;
          v36 = v32;
          v37 = *((_QWORD *)v232 + 12);
          v38 = *((_QWORD *)v231 + 6);
          v39 = (int)v37;
          if (v38 && (int)v37 != *(_QWORD *)(v38 + 96))
          {
            syslog(5, "ERROR: dimension mismatch between input data and global dictionary");
            v13 = 11112;
LABEL_365:
            syslog(5, "ERROR: error happened in building subdictionary");
            goto LABEL_360;
          }
          v40 = v35 >> 2;
          vision::mod::CVMLMatrix<float,16ul>::initialize_((uint64_t)v257, v35 >> 2, (int)v37);
          v233 = v37 << 32;
          v41 = v36[3];
          if (v36[4] != v41)
          {
            v42 = 0;
            do
            {
              DataForKthDescriptor = (const void *)vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(v232, *(int *)(v41 + 4 * v42));
              v44 = (void *)vision::mod::CVMLMatrix<float,16ul>::ptr(v257, v42);
              if (v233)
                memmove(v44, DataForKthDescriptor, v233 >> 30);
              ++v42;
              v41 = v36[3];
            }
            while (v42 < (v36[4] - v41) >> 2);
          }
          v45 = *(int *)v231;
          if ((int)v45 >= (int)((unint64_t)v35 >> 2))
          {
            v67 = 0;
            v68 = 0;
            v69 = 0;
            v70 = 0;
            __p[1] = 0;
            __p[0] = 0;
            *(_QWORD *)&v281 = 0;
            while (1)
            {
              *(_QWORD *)v303.__x_ = 0;
              if (vision::mod::FaceID3Model::generateDescriptorID_(v231, (uint64_t *)&v303) != 11136)
                break;
              if ((unint64_t)v67 >= v69)
              {
                v71 = (v67 - v68) >> 3;
                v72 = v71 + 1;
                if ((unint64_t)(v71 + 1) >> 61)
                {
                  *(_QWORD *)&v281 = v69;
                  __p[0] = v68;
                  std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
                }
                if ((uint64_t)(v69 - (_QWORD)v68) >> 2 > v72)
                  v72 = (uint64_t)(v69 - (_QWORD)v68) >> 2;
                if (v69 - (unint64_t)v68 >= 0x7FFFFFFFFFFFFFF8)
                  v73 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v73 = v72;
                if (v73)
                  v73 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v73);
                else
                  v74 = 0;
                v75 = (char *)(v73 + 8 * v71);
                *(_QWORD *)v75 = *(_QWORD *)v303.__x_;
                v76 = v75 + 8;
                while (v67 != v68)
                {
                  v77 = *((_QWORD *)v67 - 1);
                  v67 -= 8;
                  *((_QWORD *)v75 - 1) = v77;
                  v75 -= 8;
                }
                v69 = v73 + 8 * v74;
                __p[1] = v76;
                if (v68)
                  operator delete(v68);
                v68 = v75;
                v67 = (char *)v76;
              }
              else
              {
                *(_QWORD *)v67 = *(_QWORD *)v303.__x_;
                v67 += 8;
              }
              __p[1] = v67;
              *((_DWORD *)std::__hash_table<std::__hash_value_type<long long,int>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,int>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,int>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,int>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(v230, *(unint64_t *)v303.__x_, &v303)+ 6) = v31;
              if (++v70 == v40)
              {
                *(_QWORD *)&v281 = v69;
                __p[0] = v68;
                v78 = (void *)vision::mod::CVMLMatrix<float,16ul>::ptr(v257, 0);
                vision::mod::ImageDescriptorBufferAbstract::ImageDescriptorBufferAbstract((uint64_t)&v303, (_QWORD **)__p, v78, v233 >> 30, (v67 - v68) >> 3, 0);
                v303.__x_[26] = 1;
                *(_QWORD *)&v303.__x_[28] = 0;
                *(_QWORD *)v303.__x_ = &off_1E453A8D0;
                *(_QWORD *)&v303.__x_[24] = (unint64_t)(v233 >> 30) >> 2;
                v79 = *((_QWORD *)v231 + 6);
                if (v79)
                {
                  (*(void (**)(uint64_t, std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> *))(*(_QWORD *)v79 + 40))(v79, &v303);
                }
                else
                {
                  DeepCopy = vision::mod::ImageDescriptorBufferAbstract::createDeepCopy((vision::mod::ImageDescriptorBufferAbstract *)&v303);
                  v83 = *((_QWORD *)v231 + 6);
                  *((_QWORD *)v231 + 6) = DeepCopy;
                  if (v83)
                    (*(void (**)(uint64_t))(*(_QWORD *)v83 + 8))(v83);
                }
                v84 = (char *)std::__hash_table<std::__hash_value_type<int,std::vector<long long>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<long long>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<long long>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<long long>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(v224, v261, &v261);
                std::vector<long long>::__assign_with_size[abi:ne180100]<long long *,long long *>(v84 + 24, v68, (uint64_t)v67, (v67 - v68) >> 3);
                *(_QWORD *)v303.__x_ = &off_1E453A8D0;
                free(*(void **)&v303.__x_[28]);
                vision::mod::ImageDescriptorBufferAbstract::~ImageDescriptorBufferAbstract((void **)&v303);
                if (__p[0])
                  operator delete(__p[0]);
                goto LABEL_341;
              }
            }
            *(_QWORD *)&v281 = v69;
            __p[0] = v68;
            if (v68)
            {
              __p[1] = v68;
              operator delete(v68);
            }
            v13 = 11107;
LABEL_338:
            if (v260 && v257[0])
              free(v257[0]);
            goto LABEL_346;
          }
          v235 = *(int *)v231;
          vision::mod::CVMLMatrix<float,16ul>::initialize_((uint64_t)v253, v45, v39);
          vision::mod::CVMLVector<float,16ul>::initialize_((uint64_t)v250, v39);
          LODWORD(v46) = v235;
          v47 = *((_DWORD *)v231 + 8);
          if (v47 != 1)
            break;
          vision::mod::CVMLMatrix<float,16ul>::mean((uint64_t)v257, v250, 0);
          v80 = v250[1];
LABEL_294:
          __p[1] = 0;
          __p[0] = 0;
          *(_QWORD *)&v281 = 0;
          if ((_DWORD)v46)
          {
            v200 = 0;
            v201 = 0;
            v202 = 0;
            v203 = 0;
            v204 = v261;
            while (1)
            {
              *(_QWORD *)v303.__x_ = 0;
              if (vision::mod::FaceID3Model::generateDescriptorID_(v231, (uint64_t *)&v303) != 11136)
                break;
              if ((unint64_t)v200 >= v202)
              {
                v205 = (v200 - v201) >> 3;
                v206 = v205 + 1;
                if ((unint64_t)(v205 + 1) >> 61)
                {
                  *(_QWORD *)&v281 = v202;
                  __p[0] = v201;
                  std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
                }
                if ((uint64_t)(v202 - (_QWORD)v201) >> 2 > v206)
                  v206 = (uint64_t)(v202 - (_QWORD)v201) >> 2;
                if (v202 - (unint64_t)v201 >= 0x7FFFFFFFFFFFFFF8)
                  v207 = 0x1FFFFFFFFFFFFFFFLL;
                else
                  v207 = v206;
                if (v207)
                  v207 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v207);
                else
                  v208 = 0;
                v209 = (char *)(v207 + 8 * v205);
                *(_QWORD *)v209 = *(_QWORD *)v303.__x_;
                v210 = v209 + 8;
                while (v200 != v201)
                {
                  v211 = *((_QWORD *)v200 - 1);
                  v200 -= 8;
                  *((_QWORD *)v209 - 1) = v211;
                  v209 -= 8;
                }
                v202 = v207 + 8 * v208;
                __p[1] = v210;
                if (v201)
                  operator delete(v201);
                v201 = v209;
                v200 = (char *)v210;
              }
              else
              {
                *(_QWORD *)v200 = *(_QWORD *)v303.__x_;
                v200 += 8;
              }
              __p[1] = v200;
              *((_DWORD *)std::__hash_table<std::__hash_value_type<long long,int>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,int>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,int>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,int>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(v230, *(unint64_t *)v303.__x_, &v303)+ 6) = v204;
              if (++v203 == v235)
              {
                *(_QWORD *)&v281 = v202;
                __p[0] = v201;
                goto LABEL_317;
              }
            }
            *(_QWORD *)&v281 = v202;
            __p[0] = v201;
            v81 = 1;
            v13 = 11107;
          }
          else
          {
            v201 = 0;
            v200 = 0;
LABEL_317:
            vision::mod::ImageDescriptorBufferAbstract::ImageDescriptorBufferAbstract((uint64_t)&v303, (_QWORD **)__p, v80, v233 >> 30, (v200 - v201) >> 3, 0);
            v303.__x_[26] = 1;
            *(_QWORD *)&v303.__x_[28] = 0;
            *(_QWORD *)v303.__x_ = &off_1E453A8D0;
            *(_QWORD *)&v303.__x_[24] = (unint64_t)(v233 >> 30) >> 2;
            v212 = *((_QWORD *)v231 + 6);
            if (v212)
            {
              (*(void (**)(uint64_t, std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> *))(*(_QWORD *)v212 + 40))(v212, &v303);
            }
            else
            {
              v213 = vision::mod::ImageDescriptorBufferAbstract::createDeepCopy((vision::mod::ImageDescriptorBufferAbstract *)&v303);
              v214 = *((_QWORD *)v231 + 6);
              *((_QWORD *)v231 + 6) = v213;
              if (v214)
                (*(void (**)(uint64_t))(*(_QWORD *)v214 + 8))(v214);
            }
            v215 = (char *)std::__hash_table<std::__hash_value_type<int,std::vector<long long>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<long long>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<long long>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<long long>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(v224, v261, &v261);
            std::vector<long long>::__assign_with_size[abi:ne180100]<long long *,long long *>(v215 + 24, v201, (uint64_t)v200, (v200 - v201) >> 3);
            if (v252 && v250[0])
              free(v250[0]);
            *(_OWORD *)v250 = 0u;
            v251 = 0u;
            v252 = 1;
            if (v256 && v253[0])
              free(v253[0]);
            v255 = 0;
            *(_OWORD *)v253 = 0u;
            v254 = 0u;
            v256 = 1;
            *(_QWORD *)v303.__x_ = &off_1E453A8D0;
            free(*(void **)&v303.__x_[28]);
            vision::mod::ImageDescriptorBufferAbstract::~ImageDescriptorBufferAbstract((void **)&v303);
            v81 = 0;
            v201 = (char *)__p[0];
            v13 = 11136;
          }
          if (v201)
          {
            __p[1] = v201;
            operator delete(v201);
          }
LABEL_331:
          if (v252 && v250[0])
            free(v250[0]);
          if (v256 && v253[0])
            free(v253[0]);
          if (v81)
            goto LABEL_338;
LABEL_341:
          if (v260 && v257[0])
            free(v257[0]);
          v259 = 0;
          *(_OWORD *)v257 = 0u;
          v258 = 0u;
          v13 = 11136;
          v260 = 1;
LABEL_346:
          if (v13 != 11136)
            goto LABEL_365;
LABEL_347:
          ++v229;
          if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v226 + 8))(v226))
          {
            if (v229 == DWORD2(v246))
              v13 = 11136;
            else
              v13 = 11107;
            goto LABEL_360;
          }
          v30 = *v228;
          if (!*v228)
            goto LABEL_359;
        }
        if (v47)
        {
          syslog(5, "ERROR: unknown index mode");
          v81 = 1;
          v13 = 11132;
          goto LABEL_331;
        }
        v48 = *(_QWORD *)((char *)v231 + 12);
        v225 = v48;
        if ((int)v48 < 1 || (v234 = HIDWORD(v48), v48 <= 0))
        {
          syslog(5, "ERROR: invalid parameters in kmeans");
          syslog(5, "ERROR: kmeans error");
          v81 = 1;
          v13 = 11136;
          goto LABEL_331;
        }
        v49 = *((double *)v231 + 3);
        v50 = *((_DWORD *)v231 + 2);
        v51 = *((_QWORD *)&v258 + 1);
        vision::mod::CVMLVector<float,16ul>::initialize_((uint64_t)&v284, *((uint64_t *)&v258 + 1));
        if (v286 < *((_QWORD *)&v258 + 1))
        {
          exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          std::logic_error::logic_error(exception, "vector length < cols");
          exception->__vftable = (std::logic_error_vtbl *)v222;
          __cxa_throw(exception, (struct type_info *)off_1E452A5D0, MEMORY[0x1E0DE42E0]);
        }
        vision::mod::CVMLMatrix<float,16ul>::mean((uint64_t)v257, &v284, 0);
        v52 = *((_QWORD *)&v258 + 1);
        v53 = v285;
        if (*((_QWORD *)&v258 + 1))
        {
          v54 = 0;
          v55 = v287;
          v57 = (float *)v257[1];
          v56 = v258;
          v58 = (float)(unint64_t)v258;
          v59 = 4 * v259;
          do
          {
            v60 = v55 * v54;
            if (v56)
            {
              v61 = 0.0;
              v62 = v57;
              v63 = v56;
              do
              {
                v61 = v61 + (float)((float)(*v62 - v53[v60]) * (float)(*v62 - v53[v60]));
                v62 = (float *)((char *)v62 + v59);
                --v63;
              }
              while (v63);
            }
            else
            {
              v61 = 0.0;
            }
            v53[v60] = v61 / v58;
            ++v54;
            ++v57;
          }
          while (v54 != v52);
        }
        if (v51)
        {
          v64 = 4 * v51;
          v65 = 0.0;
          do
          {
            v66 = *v53++;
            v65 = v65 + v66;
            v64 -= 4;
          }
          while (v64);
        }
        else
        {
          v65 = 0.0;
        }
        if ((_BYTE)v288 && v284)
          free(v284);
        *(_OWORD *)v272 = 0u;
        v273 = 0u;
        v274 = 1;
        vision::mod::CVMLMatrix<float,16ul>::mean((uint64_t)v257, v272, 1);
        *(_QWORD *)v303.__x_ = &off_1E453B260;
        *(_QWORD *)&v303.__x_[6] = &v303;
        vision::mod::broadcast<float,16ul>(v257, v272, (uint64_t)&v303, 0, v257);
        v85 = *(std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> **)&v303.__x_[6];
        if (*(std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> **)&v303.__x_[6] == &v303)
        {
          v85 = &v303;
          v86 = 4;
        }
        else
        {
          if (!*(_QWORD *)&v303.__x_[6])
            goto LABEL_114;
          v86 = 5;
        }
        (*(void (**)(void))(*(_QWORD *)v85->__x_ + 8 * v86))();
LABEL_114:
        *(_OWORD *)v269 = 0u;
        v270 = 0u;
        v271 = 1;
        vision::mod::CVMLMatrix<float,16ul>::rowNorms((uint64_t)v257, v269, 1);
        vision::mod::CVMLMatrix<float,16ul>::initialize_((uint64_t)&v263, v235, *((uint64_t *)&v258 + 1));
        v87 = v49;
        v88 = (float)(v65 / (float)v51) * v87;
        v89 = 5489;
        v303.__x_[0] = 5489;
        for (i = 1; i != 624; ++i)
        {
          v89 = i + 1812433253 * (v89 ^ (v89 >> 30));
          v303.__x_[i] = v89;
        }
        v303.__i_ = 0;
        if ((v50 & 0x80000000) == 0)
        {
          v303.__x_[0] = v50;
          for (j = 1; j != 624; ++j)
          {
            v50 = j + 1812433253 * (v50 ^ (v50 >> 30));
            v303.__x_[j] = v50;
          }
          v303.__i_ = 0;
        }
        if (v225 >= 1)
        {
          v227 = 0;
          v236 = (int)log((double)(int)v235);
          LODWORD(v92) = v236 + 2;
          if (v236 + 2 <= 1)
            v92 = 1;
          else
            v92 = v92;
          v243 = v236 + 2;
          v244 = v92;
          v238 = 4 * v235;
          v93 = 3.4028e38;
          while (1)
          {
            v94 = v258;
            LODWORD(v302) = 0;
            HIDWORD(v302) = v258 - 1;
            v95 = std::uniform_int_distribution<int>::operator()<std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>(&v303, &v302);
            v96 = (void *)vision::mod::CVMLMatrix<float,16ul>::ptr(&v263, 0);
            v97 = (const void *)vision::mod::CVMLMatrix<float,16ul>::ptr(v257, v95);
            v237 = 4 * *((_QWORD *)&v94 + 1);
            memcpy(v96, v97, 4 * *((_QWORD *)&v94 + 1));
            vision::mod::CVMLMatrix<float,16ul>::initialize_((uint64_t)&v290, 1, v94);
            if (!v265)
              break;
            if (!v266 || *((_QWORD *)&v94 + 1) > v266)
            {
              v219 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
              std::logic_error::logic_error(v219, "col index out of range");
LABEL_356:
              v219->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
              __cxa_throw(v219, (struct type_info *)off_1E452A5D0, MEMORY[0x1E0DE42E0]);
            }
            v284 = v264;
            v285 = (float *)v264;
            v286 = 1;
            v287 = *((_QWORD *)&v94 + 1);
            v288 = v267;
            v289 = 0;
            vision::mod::euclideanDistances<float,16ul>((uint64_t)&v284, v257, &v290, v269);
            if (v289 && v284)
              free(v284);
            v98 = v291;
            *(_DWORD *)(v291 + 4 * v95) = 0;
            v99 = v236 + 2;
            vision::mod::CVMLMatrix<float,16ul>::initialize_((uint64_t)&v284, v243, *((uint64_t *)&v94 + 1));
            vision::mod::CVMLMatrix<float,16ul>::initialize_((uint64_t)__p, v243, v94);
            std::vector<unsigned long>::vector(v276, v243);
            std::vector<float>::vector(&__dst, v94);
            std::vector<float>::vector(&__src, v94);
            std::vector<float>::vector(&v279, v94);
            if ((int)v46 >= 2)
            {
              __n = 4 * v94;
              v100 = __p[1];
              v101 = v282;
              v102 = 4 * v282;
              v239 = 1;
              do
              {
                v103 = (int *)vision::mod::CVMLMatrix<float,16ul>::ptr(&v290, 0);
                v104 = vision::mod::CVMLMatrix<float,16ul>::ptr(&v290, 0) + 4 * v94;
                begin = v279.__begin_;
                if (v103 != (int *)v104)
                {
                  v107 = *v103;
                  v106 = (float *)(v103 + 1);
                  v108 = *(float *)&v107;
                  *v279.__begin_ = v107;
                  if (v106 != (float *)v104)
                  {
                    v109 = (float *)(begin + 1);
                    do
                    {
                      v110 = *v106++;
                      v108 = v108 + v110;
                      *v109++ = v108;
                    }
                    while (v106 != (float *)v104);
                  }
                }
                if (!begin || !(_QWORD)v94)
                {
                  v218 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
                  std::logic_error::logic_error(v218, "empty cumsum vector");
                  v218->__vftable = (std::logic_error_vtbl *)v223;
                  __cxa_throw(v218, (struct type_info *)off_1E452A5E0, MEMORY[0x1E0DE4360]);
                }
                if (v99)
                {
                  v111 = 0;
                  v112 = *(float **)v276;
                  v113 = *(float *)&begin[v94 - 1];
                  do
                  {
                    v114 = std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(&v303) >> 5;
                    v115 = ((double)(std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(&v303) >> 6)
                          + (double)v114 * 67108864.0)
                         * 1.11022302e-16;
                    v116 = v113 * v115;
                    v117 = begin;
                    v118 = v94;
                    do
                    {
                      v119 = v118 >> 1;
                      v120 = (float *)&v117[v118 >> 1];
                      v122 = *v120;
                      v121 = v120 + 1;
                      v118 += ~(v118 >> 1);
                      if (v122 < v116)
                        v117 = (std::vector<int>::pointer)v121;
                      else
                        v118 = v119;
                    }
                    while (v118);
                    *(_QWORD *)&v112[2 * v111++] = v117 - begin;
                    v99 = v236 + 2;
                  }
                  while (v111 != v243);
                  if (v236 >= -1)
                  {
                    v123 = 0;
                    do
                    {
                      v124 = (void *)vision::mod::CVMLMatrix<float,16ul>::ptr(&v284, v123);
                      v125 = (const void *)vision::mod::CVMLMatrix<float,16ul>::ptr(v257, *(_QWORD *)(*(_QWORD *)v276 + 8 * v123));
                      memcpy(v124, v125, v237);
                      ++v123;
                    }
                    while (v244 != v123);
                  }
                }
                vision::mod::euclideanDistances<float,16ul>((uint64_t)&v284, v257, __p, v269);
                if (v236 < -1)
                {
                  LODWORD(v131) = -1;
                }
                else
                {
                  v126 = 0;
                  v127 = *(float **)v276;
                  v128 = v244;
                  do
                  {
                    v129 = *(_QWORD *)v127;
                    v127 += 2;
                    v100[v126 + v129] = 0;
                    v126 += v101;
                    --v128;
                  }
                  while (v128);
                  v130 = 0;
                  LODWORD(v131) = -1;
                  v132 = 3.4028e38;
                  v133 = v100;
                  do
                  {
                    v134 = 0;
                    v135 = (float *)__src;
                    do
                    {
                      v136 = *(float *)&v133[v134];
                      if (v136 >= *(float *)(v98 + 4 * v134))
                        v136 = *(float *)(v98 + 4 * v134);
                      v135[v134++] = v136;
                    }
                    while ((_QWORD)v94 != v134);
                    v137 = 0.0;
                    if (v135 != v297)
                    {
                      v138 = v135;
                      do
                      {
                        v139 = *v138++;
                        v137 = v137 + v139;
                      }
                      while (v138 != v297);
                    }
                    if ((_DWORD)v131 == -1 || v137 < v132 && (float)(v132 - v137) > 1.0e-14)
                    {
                      v131 = *(_QWORD *)(*(_QWORD *)v276 + 8 * v130);
                      memcpy(__dst, v135, __n);
                      v132 = v137;
                    }
                    ++v130;
                    v133 = (_DWORD *)((char *)v133 + v102);
                  }
                  while (v130 != v244);
                }
                v140 = (void *)vision::mod::CVMLMatrix<float,16ul>::ptr(&v263, v239);
                v141 = (const void *)vision::mod::CVMLMatrix<float,16ul>::ptr(v257, (int)v131);
                memcpy(v140, v141, v237);
                v142 = (void *)vision::mod::CVMLMatrix<float,16ul>::ptr(&v290, 0);
                memcpy(v142, __dst, __n);
                ++v239;
              }
              while (v239 != v235);
            }
            if (v279.__begin_)
            {
              v279.__end_ = v279.__begin_;
              operator delete(v279.__begin_);
            }
            v46 = v235;
            if (__src)
            {
              v297 = (float *)__src;
              operator delete(__src);
            }
            if (__dst)
            {
              v300 = __dst;
              operator delete(__dst);
            }
            if (*(_QWORD *)v276)
            {
              v277 = *(float **)v276;
              operator delete(*(void **)v276);
            }
            if (v283 && __p[0])
              free(__p[0]);
            if (v289 && v284)
              free(v284);
            if (v295 && v290)
              free(v290);
            v262 = 0.0;
            v143 = v258;
            __x[0] = -1;
            std::vector<int>::vector(&v298, v258, __x);
            std::vector<float>::vector(&__src, v143);
            vision::mod::CVMLMatrix<float,16ul>::initialize_((uint64_t)&v290, v235, *((uint64_t *)&v143 + 1));
            vision::mod::CVMLMatrix<float,16ul>::initialize_((uint64_t)&v284, v235, *((uint64_t *)&v143 + 1));
            v282 = 0;
            *(_OWORD *)__p = 0u;
            v281 = 0u;
            v283 = 1;
            vision::mod::CVMLMatrix<float,16ul>::initialize_((uint64_t)__p, v235, v143);
            v276[0] = 0;
            std::vector<int>::vector(&v279, v235, v276);
            v262 = 3.4028e38;
            vision::mod::CVMLVector<float,16ul>::initialize_((uint64_t)v276, v235);
            if (v234 >= 1)
            {
              v144 = 0;
              v145 = v292;
              while (2)
              {
                if (v145 < v265 || v293 < v266)
                {
                  v216 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
                  std::logic_error::logic_error(v216, "output matrix size too small");
                  v216->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
                  __cxa_throw(v216, (struct type_info *)off_1E452A5D0, MEMORY[0x1E0DE42E0]);
                }
                if (v265)
                {
                  for (k = 0; k < v265; ++k)
                  {
                    v147 = (void *)vision::mod::CVMLMatrix<float,16ul>::ptr(&v290, k);
                    v148 = (const void *)vision::mod::CVMLMatrix<float,16ul>::ptr(&v263, k);
                    memcpy(v147, v148, 4 * v266);
                  }
                }
                __na = v144;
                v275 = 0.0;
                vision::mod::Kmeans<float,16ul>::labelEstimation_(v257, v46, (uint64_t)&v263, v269, __p, v298.__begin_, (float *)__src, &v275);
                v149 = v298.__begin_;
                v240 = __src;
                v150 = v279.__begin_;
                v151 = *((_QWORD *)&v258 + 1);
                v152 = v258;
                bzero(v279.__begin_, v238);
                v153 = (void *)vision::mod::CVMLMatrix<float,16ul>::ptr(&v263, 0);
                bzero(v153, v267 * v238);
                if (v152)
                {
                  for (m = 0; m != v152; ++m)
                    ++v150[v149[m]];
                  for (n = 0; n != v152; ++n)
                  {
                    v156 = v149[n];
                    v157 = v150[v156];
                    v158 = (const float *)vision::mod::CVMLMatrix<float,16ul>::ptr(v257, n);
                    v159 = (float *)vision::mod::CVMLMatrix<float,16ul>::ptr(&v263, v156);
                    cblas_saxpy(v151, 1.0 / (float)v157, v158, 1, v159, 1);
                  }
                }
                if ((int)v46 < 1)
                  goto LABEL_239;
                v160 = 0;
                v161 = 0;
                v162 = 0;
                for (ii = 0; ii != v46; ++ii)
                {
                  if (!v150[ii])
                  {
                    if ((unint64_t)v161 >= v160)
                    {
                      v164 = (v161 - v162) >> 2;
                      v165 = v164 + 1;
                      if ((unint64_t)(v164 + 1) >> 62)
                        std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
                      if ((uint64_t)(v160 - (_QWORD)v162) >> 1 > v165)
                        v165 = (uint64_t)(v160 - (_QWORD)v162) >> 1;
                      if (v160 - (unint64_t)v162 >= 0x7FFFFFFFFFFFFFFCLL)
                        v166 = 0x3FFFFFFFFFFFFFFFLL;
                      else
                        v166 = v165;
                      if (v166)
                        v166 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v166);
                      else
                        v167 = 0;
                      v168 = (char *)(v166 + 4 * v164);
                      *(_DWORD *)v168 = ii;
                      v169 = v168 + 4;
                      while (v161 != v162)
                      {
                        v170 = *((_DWORD *)v161 - 1);
                        v161 -= 4;
                        *((_DWORD *)v168 - 1) = v170;
                        v168 -= 4;
                      }
                      v160 = v166 + 4 * v167;
                      if (v162)
                        operator delete(v162);
                      v161 = v169;
                      v162 = v168;
                      v46 = v235;
                    }
                    else
                    {
                      *(_DWORD *)v161 = ii;
                      v161 += 4;
                    }
                  }
                }
                if (v161 == v162)
                  goto LABEL_237;
                std::vector<unsigned long>::vector(&__dst, v152);
                v171 = (uint64_t *)__dst;
                *(_QWORD *)__x = v240;
                v172 = (uint64_t *)((char *)__dst + 8 * v152);
                if (v152)
                {
                  v173 = 0;
                  v174 = 8 * v152;
                  do
                  {
                    v171[v173] = v173;
                    ++v173;
                    v174 -= 8;
                  }
                  while (v174);
                  v302 = __x;
                  if (v152 > 128)
                  {
                    v175 = (uint64_t *)std::get_temporary_buffer[abi:ne180100]<unsigned long>(v152);
                    std::__stable_sort<std::_ClassicAlgPolicy,void vision::mod::argsort<float const*>(float const*,float const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(v171, v172, (uint64_t **)&v302, v152, v175, v176);
                    if (v175)
                      operator delete(v175);
LABEL_228:
                    if (v161 != v162)
                    {
                      v177 = 0;
                      v178 = 4 * v151;
                      if ((unint64_t)((v161 - v162) >> 2) <= 1)
                        v179 = 1;
                      else
                        v179 = (v161 - v162) >> 2;
                      do
                      {
                        v180 = *((_QWORD *)__dst + v177);
                        v181 = (void *)vision::mod::CVMLMatrix<float,16ul>::ptr(&v263, *(int *)&v162[4 * v177]);
                        v182 = (const void *)vision::mod::CVMLMatrix<float,16ul>::ptr(v257, v180);
                        memcpy(v181, v182, v178);
                        ++v177;
                      }
                      while (v179 != v177);
                      v161 = v162;
                    }
                    if (__dst)
                    {
                      v300 = __dst;
                      operator delete(__dst);
                      v161 = v162;
                    }
                    v162 = v161;
LABEL_237:
                    if (v162)
                      operator delete(v162);
LABEL_239:
                    v183 = v275;
                    if (v275 < v262)
                    {
                      if (v286 < v265 || v287 < v266)
                      {
                        v217 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
                        std::logic_error::logic_error(v217, "output matrix size too small");
                        v217->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
                        __cxa_throw(v217, (struct type_info *)off_1E452A5D0, MEMORY[0x1E0DE42E0]);
                      }
                      if (v265)
                      {
                        for (jj = 0; jj < v265; ++jj)
                        {
                          v185 = (void *)vision::mod::CVMLMatrix<float,16ul>::ptr(&v284, jj);
                          v186 = (const void *)vision::mod::CVMLMatrix<float,16ul>::ptr(&v263, jj);
                          memcpy(v185, v186, 4 * v266);
                        }
                      }
                      v262 = v183;
                    }
                    v145 = v292;
                    v187 = v294;
                    v188 = (const float *)vision::mod::CVMLMatrix<float,16ul>::ptr(&v263, 0);
                    v189 = (float *)vision::mod::CVMLMatrix<float,16ul>::ptr(&v290, 0);
                    cblas_saxpy(v187 * v145, -1.0, v188, 1, v189, 1);
                    vision::mod::CVMLMatrix<float,16ul>::rowNorms((uint64_t)&v290, v276, 0);
                    if ((_DWORD)v235)
                    {
                      v190 = v277;
                      v191 = 0.0;
                      v192 = 4 * v235;
                      do
                      {
                        v193 = *v190++;
                        v191 = v191 + v193;
                        v192 -= 4;
                      }
                      while (v192);
                    }
                    else
                    {
                      v191 = 0.0;
                    }
                    v194 = sqrtf(v191);
                    v144 = __na + 1;
                    if (v194 <= v88 || v144 == v234)
                    {
                      if (v194 > 0.0)
                        vision::mod::Kmeans<float,16ul>::labelEstimation_(v257, v235, (uint64_t)&v284, v269, __p, v298.__begin_, (float *)__src, &v262);
                      goto LABEL_258;
                    }
                    continue;
                  }
                }
                else
                {
                  v302 = __x;
                }
                break;
              }
              std::__stable_sort<std::_ClassicAlgPolicy,void vision::mod::argsort<float const*>(float const*,float const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(v171, v172, (uint64_t **)&v302, v152, 0, 0);
              goto LABEL_228;
            }
LABEL_258:
            if (v278 && *(_QWORD *)v276)
              free(*(void **)v276);
            if (v279.__begin_)
            {
              v279.__end_ = v279.__begin_;
              operator delete(v279.__begin_);
            }
            if (v283 && __p[0])
              free(__p[0]);
            if (v289 && v284)
              free(v284);
            if (v295 && v290)
              free(v290);
            if (__src)
            {
              v297 = (float *)__src;
              operator delete(__src);
            }
            if (v298.__begin_)
            {
              v298.__end_ = v298.__begin_;
              operator delete(v298.__begin_);
            }
            v196 = v262;
            if (v262 < v93)
            {
              if ((unint64_t)v254 < v265 || *((_QWORD *)&v254 + 1) < v266)
              {
                v220 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
                std::logic_error::logic_error(v220, "output matrix size too small");
                v220->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
                __cxa_throw(v220, (struct type_info *)off_1E452A5D0, MEMORY[0x1E0DE42E0]);
              }
              if (v265)
              {
                for (kk = 0; kk < v265; ++kk)
                {
                  v198 = (void *)vision::mod::CVMLMatrix<float,16ul>::ptr(v253, kk);
                  v199 = (const void *)vision::mod::CVMLMatrix<float,16ul>::ptr(&v263, kk);
                  memcpy(v198, v199, 4 * v266);
                }
              }
              v93 = v196;
            }
            if (++v227 == v225)
              goto LABEL_284;
          }
          v219 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          std::logic_error::logic_error(v219, "row index out of range");
          goto LABEL_356;
        }
LABEL_284:
        vision::mod::broadcastAdd<float,16ul>(v257, v272, 0, v257);
        vision::mod::broadcastAdd<float,16ul>(v253, v272, 0, v253);
        if (v268 && v263)
          free(v263);
        if (v271 && v269[0])
          free(v269[0]);
        if (v274 && v272[0])
          free(v272[0]);
        v80 = (void *)vision::mod::CVMLMatrix<float,16ul>::ptr(v253, 0);
        goto LABEL_294;
      }
    }
LABEL_360:
    std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table((uint64_t)&v245);
    std::__hash_table<std::__hash_value_type<int,std::vector<int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<int>>>>::~__hash_table((uint64_t)v248);
  }
  return v13;
}

void sub_1A14D1BD8()
{
  void *v0;
  char v1;
  void *v2;
  char v3;

  __cxa_end_catch();
  if (v1 && v0)
    free(v0);
  if (v3)
  {
    if (v2)
      free(v2);
  }
  JUMPOUT(0x1A14D1D0CLL);
}

void sub_1A14D1BF4(void *a1, int a2)
{
  void *v2;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  char v8;
  void *v9;
  char v10;
  void *v11;
  char v12;

  vision::mod::ImageDescriptorBufferFloat32::~ImageDescriptorBufferFloat32((void **)&STACK[0x378]);
  if (v2)
  {
    STACK[0x298] = (unint64_t)v2;
    operator delete(v2);
  }
  if (v8 && v7)
    free(v7);
  if (v10 && v9)
    free(v9);
  if (v12 && v11)
    free(v11);
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table((uint64_t)&v5);
  std::__hash_table<std::__hash_value_type<int,std::vector<int>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::vector<int>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::vector<int>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::vector<int>>>>::~__hash_table((uint64_t)&v6);
  if (a2 == 2)
  {
    __cxa_begin_catch(a1);
    syslog(5, "ERROR: memory allocation error");
    __cxa_end_catch();
  }
  else
  {
    if (a2 != 1)
      JUMPOUT(0x1A14D1DB4);
    __cxa_begin_catch(a1);
    syslog(5, "ERROR: an unexpected exception thrown");
    __cxa_end_catch();
  }
  JUMPOUT(0x1A14CFFDCLL);
}

void sub_1A14D1CD4()
{
  unint64_t v0;
  unint64_t v1;

  STACK[0x2A0] = v1;
  STACK[0x290] = v0;
  JUMPOUT(0x1A14D1CE4);
}

void sub_1A14D1CF8()
{
  JUMPOUT(0x1A14D1D20);
}

void sub_1A14D1D88(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A14D1D94(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A14D1DA0(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

char *vision::mod::CVMLMatrix<float,16ul>::initialize_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;
  uint64_t v7;
  char *result;
  uint64_t v9;
  std::bad_alloc *exception;
  std::bad_alloc *v11;

  v6 = (16 - ((4 * (int)a3) & 0xCuLL)) >> 2;
  if (((4 * (int)a3) & 0xCLL) == 0)
    v6 = 0;
  v7 = v6 + a3;
  result = (char *)malloc_type_calloc(4 * a2 * (v6 + a3) + 15, 1uLL, 0x6E22AE6BuLL);
  if (!result)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    v11 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v11, MEMORY[0x1E0DE4EA8], MEMORY[0x1E0DE4DC0]);
  }
  v9 = 16 - (result & 0xF);
  if ((result & 0xF) == 0)
    v9 = 0;
  *(_QWORD *)a1 = result;
  *(_QWORD *)(a1 + 8) = &result[v9];
  *(_QWORD *)(a1 + 24) = a3;
  *(_QWORD *)(a1 + 32) = v7;
  *(_QWORD *)(a1 + 16) = a2;
  *(_BYTE *)(a1 + 40) = 1;
  return result;
}

uint64_t vision::mod::CVMLMatrix<float,16ul>::ptr(_QWORD *a1, unint64_t a2)
{
  _QWORD *v3;
  std::logic_error *exception;
  std::string v5;
  uint64_t v6;
  uint64_t v7;

  if (a1[2] <= a2)
  {
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v6);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v6, (uint64_t)"row index ", 10);
    v3 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)" of ", 4);
    std::ostream::operator<<();
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>(&v5, (uint64_t)&v7);
    std::logic_error::logic_error(exception, &v5);
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
    __cxa_throw(exception, (struct type_info *)off_1E452A5D0, MEMORY[0x1E0DE42E0]);
  }
  return a1[1] + 4 * a1[4] * a2;
}

{
  _QWORD *v3;
  std::logic_error *exception;
  std::string v5;
  uint64_t v6;
  uint64_t v7;

  if (a1[2] <= a2)
  {
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v6);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v6, (uint64_t)"row index ", 10);
    v3 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)" of ", 4);
    std::ostream::operator<<();
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>(&v5, (uint64_t)&v7);
    std::logic_error::logic_error(exception, &v5);
    exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
    __cxa_throw(exception, (struct type_info *)off_1E452A5D0, MEMORY[0x1E0DE42E0]);
  }
  return a1[1] + 4 * a1[4] * a2;
}

void sub_1A14D1F64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  void *v15;
  int v16;

  if (a14 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

char *vision::mod::CVMLVector<float,16ul>::initialize_(uint64_t a1, uint64_t a2)
{
  char *result;
  uint64_t v5;
  std::bad_alloc *exception;
  std::bad_alloc *v7;

  result = (char *)malloc_type_calloc(4 * a2 + 15, 1uLL, 0xA9532734uLL);
  if (!result)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    v7 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v7, MEMORY[0x1E0DE4EA8], MEMORY[0x1E0DE4DC0]);
  }
  v5 = 16 - (result & 0xF);
  if ((result & 0xF) == 0)
    v5 = 0;
  *(_QWORD *)a1 = result;
  *(_QWORD *)(a1 + 8) = &result[v5];
  *(_QWORD *)(a1 + 16) = a2;
  *(_QWORD *)(a1 + 24) = 1;
  *(_BYTE *)(a1 + 32) = 1;
  return result;
}

uint64_t vision::mod::CVMLMatrix<float,16ul>::mean(uint64_t result, _QWORD *a2, char a3)
{
  _QWORD *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  double v9;
  float v10;
  std::logic_error *exception;

  v4 = (_QWORD *)result;
  if ((a3 & 1) != 0)
  {
    result = (uint64_t)vision::mod::CVMLVector<float,16ul>::reset((uint64_t)a2, *(_QWORD *)(result + 24));
    v5 = v4[3];
  }
  else
  {
    v5 = *(_QWORD *)(result + 24);
    if (a2[2] < v5)
    {
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::out_of_range::out_of_range[abi:ne180100](exception, "vector length < cols");
      __cxa_throw(exception, (struct type_info *)off_1E452A5D0, MEMORY[0x1E0DE42E0]);
    }
  }
  if (v5)
  {
    v6 = 0;
    v7 = v4[2];
    do
    {
      if (v7)
      {
        v8 = 0;
        v9 = 0.0;
        do
        {
          result = vision::mod::CVMLMatrix<float,16ul>::ptr(v4, v8);
          v9 = v9 + *(float *)(result + 4 * v6);
          ++v8;
          v7 = v4[2];
        }
        while (v8 < v7);
        v5 = v4[3];
      }
      else
      {
        v9 = 0.0;
      }
      v10 = v9 / (double)v7;
      *(float *)(a2[1] + 4 * a2[3] * v6++) = v10;
    }
    while (v6 < v5);
  }
  return result;
}

void sub_1A14D2134(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::FaceID3Model::generateDescriptorID_(vision::mod::FaceID3Model *this, uint64_t *a2)
{
  _QWORD *v3;
  int v4;
  uint64_t v5;
  int v6;

  v3 = (_QWORD *)((char *)this + 96);
  v4 = 10001;
  v5 = 11136;
  while (1)
  {
    v6 = rand();
    *a2 = v6;
    if (!std::__hash_table<std::__hash_value_type<long long,int>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,int>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,int>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,int>>>::find<long long>(v3, v6))break;
    if (!--v4)
    {
      syslog(5, "reach maximum try to find the descriptorID");
      return 11107;
    }
  }
  return v5;
}

char *vision::mod::CVMLVector<float,16ul>::reset(uint64_t a1, uint64_t a2)
{
  void *v4;

  if (*(_BYTE *)(a1 + 32))
  {
    v4 = *(void **)a1;
    if (*(_QWORD *)a1)
      free(v4);
  }
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_BYTE *)(a1 + 32) = 1;
  return vision::mod::CVMLVector<float,16ul>::initialize_(a1, a2);
}

void vision::mod::CVMLMatrix<float,16ul>::rowNorms(uint64_t a1, _QWORD *a2, char a3)
{
  unint64_t v5;
  unint64_t v6;
  const float *v7;
  std::logic_error *exception;

  if ((a3 & 1) != 0)
  {
    vision::mod::CVMLVector<float,16ul>::reset((uint64_t)a2, *(_QWORD *)(a1 + 16));
    v5 = *(_QWORD *)(a1 + 16);
  }
  else
  {
    v5 = *(_QWORD *)(a1 + 16);
    if (a2[2] < v5)
    {
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::out_of_range::out_of_range[abi:ne180100](exception, "vector length < rows");
      __cxa_throw(exception, (struct type_info *)off_1E452A5D0, MEMORY[0x1E0DE42E0]);
    }
  }
  if (v5)
  {
    v6 = 0;
    do
    {
      v7 = (const float *)vision::mod::CVMLMatrix<float,16ul>::ptr((_QWORD *)a1, v6);
      *(float *)(a2[1] + 4 * a2[3] * v6++) = cblas_sdot(*(_DWORD *)(a1 + 24), v7, 1, v7, 1);
    }
    while (v6 < *(_QWORD *)(a1 + 16));
  }
}

void sub_1A14D22C8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1A14D23C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  void *v15;
  int v16;

  if (a14 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

_QWORD *vision::mod::broadcastAdd<float,16ul>(_QWORD *a1, _QWORD *a2, int a3, _QWORD *a4)
{
  _QWORD *result;
  uint64_t v5;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v6[0] = &off_1E453B1B0;
  v7 = v6;
  vision::mod::broadcast<float,16ul>(a1, a2, (uint64_t)v6, a3, a4);
  result = v7;
  if (v7 == v6)
  {
    v5 = 4;
    result = v6;
  }
  else
  {
    if (!v7)
      return result;
    v5 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v5))();
}

void sub_1A14D24A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v14;
  uint64_t v15;

  v14 = a13;
  if (a13 == &a10)
  {
    v15 = 4;
    v14 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t vision::mod::broadcast<float,16ul>(_QWORD *a1, _QWORD *a2, uint64_t a3, int a4, _QWORD *a5)
{
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t i;
  int v20;
  float *v21;
  uint64_t v22;
  unint64_t v23;
  _DWORD *v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  _DWORD *v30;
  int v31;
  std::logic_error *exception;
  struct type_info *v33;
  void (*v34)(void *);
  float *v35;

  v9 = a1[2];
  if (v9 > a5[2] && a1[3] > a5[3])
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "matrix size too small for output");
    v33 = (struct type_info *)off_1E452A5D0;
    v34 = (void (*)(void *))MEMORY[0x1E0DE42E0];
    goto LABEL_27;
  }
  if (a4 != 1)
  {
    if (a4)
    {
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::invalid_argument::invalid_argument[abi:ne180100](exception, "unknown axis value");
LABEL_26:
      v33 = (struct type_info *)off_1E452A5E0;
      v34 = (void (*)(void *))MEMORY[0x1E0DE4360];
LABEL_27:
      __cxa_throw(exception, v33, v34);
    }
    if (a2[2] == a1[3])
    {
      v10 = vision::mod::CVMLMatrix<float,16ul>::ptr(a1, 0);
      v11 = a1[4];
      result = vision::mod::CVMLMatrix<float,16ul>::ptr(a5, 0);
      v13 = a1[2];
      if (v13)
      {
        v14 = result;
        v15 = 0;
        v16 = a1[3];
        v17 = 4 * a5[4];
        v18 = 4 * v11;
        do
        {
          if (v16)
          {
            for (i = 0; i < v16; ++i)
            {
              result = std::function<float ()(float,float)>::operator()(*(_QWORD *)(a3 + 24), *(float *)(v10 + 4 * i), *(float *)(a2[1] + 4 * a2[3] * i));
              *(_DWORD *)(v14 + 4 * i) = v20;
              v16 = a1[3];
            }
            v13 = a1[2];
          }
          ++v15;
          v14 += v17;
          v10 += v18;
        }
        while (v15 < v13);
      }
      return result;
    }
LABEL_25:
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "broadcast op: dimension mismatch");
    goto LABEL_26;
  }
  if (a2[2] != v9)
    goto LABEL_25;
  v21 = (float *)vision::mod::CVMLMatrix<float,16ul>::ptr(a1, 0);
  v22 = a1[4];
  result = vision::mod::CVMLMatrix<float,16ul>::ptr(a5, 0);
  v23 = a1[3];
  if (v23)
  {
    v24 = (_DWORD *)result;
    v25 = 0;
    v26 = a1[2];
    v27 = 4 * a5[4];
    v28 = 4 * v22;
    do
    {
      if (v26)
      {
        v29 = 0;
        v35 = v21;
        v30 = v24;
        do
        {
          result = std::function<float ()(float,float)>::operator()(*(_QWORD *)(a3 + 24), *v21, *(float *)(a2[1] + 4 * a2[3] * v29));
          *v30 = v31;
          ++v29;
          v26 = a1[2];
          v30 = (_DWORD *)((char *)v30 + v27);
          v21 = (float *)((char *)v21 + v28);
        }
        while (v29 < v26);
        v23 = a1[3];
        v21 = v35;
      }
      ++v25;
      ++v24;
      ++v21;
    }
    while (v25 < v23);
  }
  return result;
}

void sub_1A14D2748(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t std::function<float ()(float,float)>::operator()(uint64_t a1, float a2, float a3)
{
  float v4;
  float v5;

  v5 = a2;
  v4 = a3;
  if (!a1)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, float *, float *))(*(_QWORD *)a1 + 48))(a1, &v5, &v4);
}

void std::__function::__func<void vision::mod::broadcastAdd<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1},std::allocator<void vision::mod::broadcastAdd<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1}>,float ()(float,float)>::~__func()
{
  JUMPOUT(0x1A1B0A898);
}

_QWORD *std::__function::__func<void vision::mod::broadcastAdd<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1},std::allocator<void vision::mod::broadcastAdd<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1}>,float ()(float,float)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E453B1B0;
  return result;
}

void std::__function::__func<void vision::mod::broadcastAdd<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1},std::allocator<void vision::mod::broadcastAdd<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1}>,float ()(float,float)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E453B1B0;
}

float std::__function::__func<void vision::mod::broadcastAdd<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1},std::allocator<void vision::mod::broadcastAdd<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1}>,float ()(float,float)>::operator()(uint64_t a1, float *a2, float *a3)
{
  return *a2 + *a3;
}

uint64_t std::__function::__func<void vision::mod::broadcastAdd<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1},std::allocator<void vision::mod::broadcastAdd<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1}>,float ()(float,float)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN6vision3mod12broadcastAddIfLm16EEEvRKNS0_10CVMLMatrixIT_XT0_EEERKNS0_10CVMLVectorIS3_XT0_EEEiRS4_bEUlffE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void vision::mod::broadcastAdd<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1},std::allocator<void vision::mod::broadcastAdd<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1}>,float ()(float,float)>::target_type()
{
}

void vision::mod::Kmeans<float,16ul>::labelEstimation_(_QWORD *a1, int a2, uint64_t a3, void **a4, _QWORD *a5, void *__b, float *a7, float *a8)
{
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  float *v19;
  float *v20;
  _DWORD *v21;
  uint64_t v22;
  float v23;
  float v24;
  float v25;

  v16 = a1[2];
  v17 = 4 * v16;
  if (v16)
  {
    memset(__b, 255, 4 * v16);
    memset_pattern16(a7, &unk_1A15FB7F0, 4 * v16);
  }
  vision::mod::euclideanDistances<float,16ul>(a3, a1, a5, a4);
  if (a2 >= 1)
  {
    v18 = 0;
    do
    {
      v19 = (float *)vision::mod::CVMLMatrix<float,16ul>::ptr(a5, v18);
      if (v16)
      {
        v20 = a7;
        v21 = __b;
        v22 = v16;
        do
        {
          v23 = *v19;
          if (*v19 < *v20)
          {
            *v21 = v18;
            *v20 = v23;
          }
          ++v21;
          ++v20;
          ++v19;
          --v22;
        }
        while (v22);
      }
      ++v18;
    }
    while (v18 != a2);
  }
  v24 = 0.0;
  if (v16)
  {
    do
    {
      v25 = *a7++;
      v24 = v24 + v25;
      v17 -= 4;
    }
    while (v17);
  }
  *a8 = v24;
}

uint64_t *std::__stable_sort<std::_ClassicAlgPolicy,void vision::mod::argsort<float const*>(float const*,float const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(uint64_t *result, uint64_t *a2, uint64_t **a3, unint64_t a4, uint64_t *a5, uint64_t a6)
{
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  float v18;
  uint64_t v19;
  uint64_t *v20;
  char *v22;
  unint64_t v23;
  uint64_t *v24;
  unint64_t v25;
  uint64_t *v26;
  char *v27;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t v30;
  float v31;
  float v32;
  uint64_t v33;
  uint64_t v34;

  if (a4 >= 2)
  {
    v8 = (char *)result;
    if (a4 == 2)
    {
      v9 = *(a2 - 1);
      v10 = *result;
      if (*(float *)(**a3 + 4 * v9) > *(float *)(**a3 + 4 * *result))
      {
        *result = v9;
        *(a2 - 1) = v10;
      }
    }
    else if ((uint64_t)a4 > 128)
    {
      v22 = (char *)a5;
      v23 = a4 >> 1;
      v24 = &result[a4 >> 1];
      v25 = a4 >> 1;
      if ((uint64_t)a4 <= a6)
      {
        std::__stable_sort_move<std::_ClassicAlgPolicy,void vision::mod::argsort<float const*>(float const*,float const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(result, v24, a3, v25, a5);
        v26 = (uint64_t *)&v22[8 * v23];
        result = std::__stable_sort_move<std::_ClassicAlgPolicy,void vision::mod::argsort<float const*>(float const*,float const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>((uint64_t *)&v8[8 * (a4 >> 1)], a2, a3, a4 - (a4 >> 1), v26);
        v27 = &v22[8 * a4];
        v28 = *a3;
        v29 = v26;
        while (v29 != (uint64_t *)v27)
        {
          v30 = *v29;
          v31 = *(float *)(*v28 + 4 * *v29);
          v32 = *(float *)(*v28 + 4 * *(_QWORD *)v22);
          if (v31 <= v32)
            v30 = *(_QWORD *)v22;
          v22 += 8 * (v31 <= v32);
          v29 += v31 > v32;
          *(_QWORD *)v8 = v30;
          v8 += 8;
          if (v22 == (char *)v26)
          {
            if (v29 != (uint64_t *)v27)
            {
              v33 = 0;
              do
              {
                *(_QWORD *)&v8[v33 * 8] = v29[v33];
                ++v33;
              }
              while (&v29[v33] != (uint64_t *)v27);
            }
            return result;
          }
        }
        if (v22 != (char *)v26)
        {
          v34 = 0;
          do
          {
            *(_QWORD *)&v8[v34] = *(_QWORD *)&v22[v34];
            v34 += 8;
          }
          while (&v22[v34] != (char *)v26);
        }
      }
      else
      {
        std::__stable_sort<std::_ClassicAlgPolicy,void vision::mod::argsort<float const*>(float const*,float const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(result, v24, a3, v25, a5, a6);
        std::__stable_sort<std::_ClassicAlgPolicy,void vision::mod::argsort<float const*>(float const*,float const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(&v8[8 * (a4 >> 1)], a2, a3, a4 - (a4 >> 1), v22, a6);
        return (uint64_t *)std::__inplace_merge<std::_ClassicAlgPolicy,void vision::mod::argsort<float const*>(float const*,float const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(v8, &v8[8 * (a4 >> 1)], (char *)a2, a3, a4 >> 1, a4 - (a4 >> 1), v22, a6);
      }
    }
    else if (result != a2)
    {
      v12 = result + 1;
      if (result + 1 != a2)
      {
        v13 = 0;
        v14 = **a3;
        v15 = result;
        do
        {
          v17 = *v15;
          v16 = v15[1];
          v15 = v12;
          v18 = *(float *)(v14 + 4 * v16);
          if (v18 > *(float *)(v14 + 4 * v17))
          {
            v19 = v13;
            while (1)
            {
              *(uint64_t *)((char *)result + v19 + 8) = v17;
              if (!v19)
                break;
              v17 = *(uint64_t *)((char *)result + v19 - 8);
              v19 -= 8;
              if (v18 <= *(float *)(v14 + 4 * v17))
              {
                v20 = (uint64_t *)((char *)result + v19 + 8);
                goto LABEL_15;
              }
            }
            v20 = result;
LABEL_15:
            *v20 = v16;
          }
          v12 = v15 + 1;
          v13 += 8;
        }
        while (v15 + 1 != a2);
      }
    }
  }
  return result;
}

uint64_t *std::__stable_sort_move<std::_ClassicAlgPolicy,void vision::mod::argsort<float const*>(float const*,float const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(uint64_t *result, uint64_t *a2, uint64_t **a3, unint64_t a4, uint64_t *a5)
{
  uint64_t *v5;
  uint64_t *v7;
  uint64_t v10;
  uint64_t v11;
  float v12;
  float v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t v27;
  float v28;
  float v29;
  uint64_t v30;
  uint64_t v31;

  if (a4)
  {
    v5 = a5;
    v7 = result;
    if (a4 == 1)
    {
LABEL_8:
      *v5 = *v7;
      return result;
    }
    if (a4 == 2)
    {
      v10 = *(a2 - 1);
      v11 = **a3;
      v12 = *(float *)(v11 + 4 * v10);
      v13 = *(float *)(v11 + 4 * *result);
      if (v12 <= v13)
        v10 = *result;
      *a5 = v10;
      v5 = a5 + 1;
      if (v12 <= v13)
        v7 = a2 - 1;
      goto LABEL_8;
    }
    if ((uint64_t)a4 > 8)
    {
      v24 = &result[a4 >> 1];
      std::__stable_sort<std::_ClassicAlgPolicy,void vision::mod::argsort<float const*>(float const*,float const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(result, v24, a3, a4 >> 1, a5, a4 >> 1);
      result = (uint64_t *)std::__stable_sort<std::_ClassicAlgPolicy,void vision::mod::argsort<float const*>(float const*,float const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(&v7[a4 >> 1], a2, a3, a4 - (a4 >> 1), &v5[a4 >> 1], a4 - (a4 >> 1));
      v25 = *a3;
      v26 = &v7[a4 >> 1];
      while (v26 != a2)
      {
        v27 = *v26;
        v28 = *(float *)(*v25 + 4 * *v26);
        v29 = *(float *)(*v25 + 4 * *v7);
        if (v28 <= v29)
          v27 = *v7;
        v26 += v28 > v29;
        v7 += v28 <= v29;
        *v5++ = v27;
        if (v7 == v24)
        {
          if (v26 != a2)
          {
            v30 = 0;
            do
            {
              v5[v30] = v26[v30];
              ++v30;
            }
            while (&v26[v30] != a2);
          }
          return result;
        }
      }
      if (v7 != v24)
      {
        v31 = 0;
        do
        {
          v5[v31] = v7[v31];
          ++v31;
        }
        while (&v7[v31] != v24);
      }
    }
    else if (result != a2)
    {
      v14 = result + 1;
      *a5 = *result;
      if (result + 1 != a2)
      {
        v15 = 0;
        v16 = **a3;
        v17 = a5;
        v18 = a5;
        do
        {
          v20 = *v18++;
          v19 = v20;
          if (*(float *)(v16 + 4 * *v14) <= *(float *)(v16 + 4 * v20))
          {
            *v18 = *v14;
          }
          else
          {
            v17[1] = v19;
            v21 = a5;
            if (v17 != a5)
            {
              v22 = v15;
              while (1)
              {
                v21 = (uint64_t *)((char *)a5 + v22);
                v23 = *(uint64_t *)((char *)a5 + v22 - 8);
                if (*(float *)(v16 + 4 * *v14) <= *(float *)(v16 + 4 * v23))
                  break;
                *v21 = v23;
                v22 -= 8;
                if (!v22)
                {
                  v21 = a5;
                  break;
                }
              }
            }
            *v21 = *v14;
          }
          ++v14;
          v15 += 8;
          v17 = v18;
        }
        while (v14 != a2);
      }
    }
  }
  return result;
}

char *std::__inplace_merge<std::_ClassicAlgPolicy,void vision::mod::argsort<float const*>(float const*,float const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(char *result, char *a2, char *a3, uint64_t **a4, uint64_t a5, uint64_t a6, char *a7, uint64_t a8)
{
  uint64_t v10;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t **v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  char *v20;
  unint64_t v21;
  unint64_t v22;
  char *v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  char *v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  uint64_t v35;
  char *v36;
  char *v37;
  uint64_t **v38;
  char *v39;
  uint64_t v40;
  char *v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  uint64_t *v46;
  uint64_t v47;
  float v48;
  float v49;
  uint64_t v50;
  uint64_t v51;
  char *v52;
  uint64_t v53;

  if (a6)
  {
    v10 = a6;
    v13 = result;
    while (v10 > a8 && a5 > a8)
    {
      if (!a5)
        return result;
      v14 = **a4;
      while (1)
      {
        v15 = *(_QWORD *)v13;
        if (*(float *)(v14 + 4 * *(_QWORD *)a2) > *(float *)(v14 + 4 * *(_QWORD *)v13))
          break;
        v13 += 8;
        if (!--a5)
          return result;
      }
      v51 = a8;
      v52 = a3;
      if (a5 >= v10)
      {
        if (a5 == 1)
        {
          *(_QWORD *)v13 = *(_QWORD *)a2;
          *(_QWORD *)a2 = v15;
          return result;
        }
        v16 = a4;
        if (a5 >= 0)
          v27 = a5;
        else
          v27 = a5 + 1;
        v26 = v27 >> 1;
        v20 = &v13[8 * (v27 >> 1)];
        v19 = a3;
        if (a3 != a2)
        {
          v28 = (a3 - a2) >> 3;
          v19 = a2;
          do
          {
            v29 = v28 >> 1;
            v30 = &v19[8 * (v28 >> 1)];
            v32 = *(_QWORD *)v30;
            v31 = v30 + 8;
            v28 += ~(v28 >> 1);
            if (*(float *)(v14 + 4 * v32) > *(float *)(v14 + 4 * *(_QWORD *)v20))
              v19 = v31;
            else
              v28 = v29;
          }
          while (v28);
        }
        v18 = (v19 - a2) >> 3;
      }
      else
      {
        v16 = a4;
        if (v10 >= 0)
          v17 = v10;
        else
          v17 = v10 + 1;
        v18 = v17 >> 1;
        v19 = &a2[8 * (v17 >> 1)];
        v20 = a2;
        if (a2 != v13)
        {
          v21 = (a2 - v13) >> 3;
          v20 = v13;
          do
          {
            v22 = v21 >> 1;
            v23 = &v20[8 * (v21 >> 1)];
            v25 = *(_QWORD *)v23;
            v24 = v23 + 8;
            v21 += ~(v21 >> 1);
            if (*(float *)(v14 + 4 * *(_QWORD *)v19) > *(float *)(v14 + 4 * v25))
              v21 = v22;
            else
              v20 = v24;
          }
          while (v21);
        }
        v26 = (v20 - v13) >> 3;
      }
      a5 -= v26;
      v10 -= v18;
      v33 = v26;
      v34 = std::__rotate[abi:ne180100]<std::_ClassicAlgPolicy,unsigned long *,unsigned long *>(v20, a2, v19);
      v35 = v33;
      v36 = v34;
      if (v35 + v18 >= a5 + v10)
      {
        v39 = v52;
        v53 = v35;
        result = (char *)std::__inplace_merge<std::_ClassicAlgPolicy,void vision::mod::argsort<float const*>(float const*,float const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(v34, v19, v39, v16, a5, v10, a7, v51);
        v19 = v20;
        a4 = v16;
        a8 = v51;
        v10 = v18;
        a5 = v53;
        a3 = v36;
      }
      else
      {
        v37 = v20;
        a4 = v16;
        v38 = v16;
        a8 = v51;
        result = (char *)std::__inplace_merge<std::_ClassicAlgPolicy,void vision::mod::argsort<float const*>(float const*,float const*,unsigned long *,BOOL)::{lambda(unsigned long,unsigned long)#2} &,unsigned long *>(v13, v37, v34, v38, v35, v18, a7, v51);
        v13 = v36;
        a3 = v52;
      }
      a2 = v19;
      if (!v10)
        return result;
    }
    if (a5 <= v10)
    {
      if (v13 != a2)
      {
        v44 = 0;
        do
        {
          *(_QWORD *)&a7[v44] = *(_QWORD *)&v13[v44];
          v44 += 8;
        }
        while (&v13[v44] != a2);
        v45 = &a7[v44];
        if (v45 != a7)
        {
          v46 = *a4;
          while (a2 != a3)
          {
            v47 = *(_QWORD *)a2;
            v48 = *(float *)(*v46 + 4 * *(_QWORD *)a2);
            v49 = *(float *)(*v46 + 4 * *(_QWORD *)a7);
            if (v48 <= v49)
              v47 = *(_QWORD *)a7;
            a7 += 8 * (v48 <= v49);
            a2 += 8 * (v48 > v49);
            *(_QWORD *)v13 = v47;
            v13 += 8;
            if (a7 == v45)
              return result;
          }
          return (char *)memmove(v13, a7, v45 - a7);
        }
      }
    }
    else if (a2 != a3)
    {
      v40 = 0;
      do
      {
        *(_QWORD *)&a7[v40] = *(_QWORD *)&a2[v40];
        v40 += 8;
      }
      while (&a2[v40] != a3);
      v41 = &a7[v40];
      if (v41 != a7)
      {
        v42 = a3 - 8;
        while (a2 != v13)
        {
          v43 = *((_QWORD *)v41 - 1);
          if (*(float *)(**a4 + 4 * v43) <= *(float *)(**a4 + 4 * *((_QWORD *)a2 - 1)))
          {
            v41 -= 8;
          }
          else
          {
            v43 = *((_QWORD *)a2 - 1);
            a2 -= 8;
          }
          *(_QWORD *)v42 = v43;
          v42 -= 8;
          if (v41 == a7)
            return result;
        }
        v50 = 0;
        do
        {
          *(_QWORD *)&v42[v50] = *(_QWORD *)&v41[v50 - 8];
          v50 -= 8;
        }
        while (&v41[v50] != a7);
      }
    }
  }
  return result;
}

void vision::mod::euclideanDistances<float,16ul>(uint64_t a1, _QWORD *a2, _QWORD *a3, void **a4)
{
  unint64_t v7;
  void **v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  const float *v12;
  int v13;
  const float *__B;
  uint64_t __ldb;
  float *__C;
  unint64_t v17;
  float *v18;
  uint64_t i;
  unint64_t v20;
  unint64_t v21;
  std::logic_error *exception;
  struct type_info *v23;
  void (*v24)(void *);
  std::logic_error *v25;
  void (*v26)(void *);
  struct type_info *v27;
  void **v28;
  void **v29;
  void *v30[2];
  __int128 v31;
  char v32;
  void *v33[2];
  __int128 v34;
  char v35;

  if (*(_QWORD *)(a1 + 24) != a2[3])
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "dimensions of data points mismatch");
    v23 = (struct type_info *)off_1E452A5E0;
    v24 = (void (*)(void *))MEMORY[0x1E0DE4360];
LABEL_29:
    __cxa_throw(exception, v23, v24);
  }
  if (*(_QWORD *)(a1 + 16) > a3[2] || (v7 = a2[2], v7 > a3[3]))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "output distance matrix too small");
    v23 = (struct type_info *)off_1E452A5D0;
    v24 = (void (*)(void *))MEMORY[0x1E0DE42E0];
    goto LABEL_29;
  }
  v8 = a4;
  *(_OWORD *)v33 = 0u;
  v34 = 0u;
  v35 = 1;
  if (!a4)
  {
    vision::mod::CVMLVector<float,16ul>::reset((uint64_t)v33, v7);
    v8 = v33;
    vision::mod::CVMLMatrix<float,16ul>::rowNorms((uint64_t)a2, v33, 0);
  }
  *(_OWORD *)v30 = 0u;
  v31 = 0u;
  v28 = v8;
  v29 = v8;
  v32 = 1;
  if ((_QWORD *)a1 != a2)
  {
    vision::mod::CVMLVector<float,16ul>::reset((uint64_t)v30, *(_QWORD *)(a1 + 16));
    v29 = v30;
    vision::mod::CVMLMatrix<float,16ul>::rowNorms(a1, v30, 0);
  }
  v9 = *(_QWORD *)(a1 + 24);
  if (v9 != a2[3])
  {
    v25 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v25, "matrix size mismatch");
    v25->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5038] + 16);
    v26 = (void (*)(void *))MEMORY[0x1E0DE4360];
    v27 = (struct type_info *)off_1E452A5E0;
    goto LABEL_32;
  }
  v10 = *(_QWORD *)(a1 + 16);
  if (a3[2] < v10 || (v11 = a2[2], a3[3] < v11))
  {
    v25 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(v25, "matrix size too small for output");
    v25->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
    v26 = (void (*)(void *))MEMORY[0x1E0DE42E0];
    v27 = (struct type_info *)off_1E452A5D0;
LABEL_32:
    __cxa_throw(v25, v27, v26);
  }
  v12 = (const float *)vision::mod::CVMLMatrix<float,16ul>::ptr((_QWORD *)a1, 0);
  v13 = *(_DWORD *)(a1 + 32);
  __B = (const float *)vision::mod::CVMLMatrix<float,16ul>::ptr(a2, 0);
  __ldb = a2[4];
  __C = (float *)vision::mod::CVMLMatrix<float,16ul>::ptr(a3, 0);
  cblas_sgemm(CblasRowMajor, CblasNoTrans, CblasTrans, v10, v11, v9, -2.0, v12, v13, __B, __ldb, 0.0, __C, a3[4]);
  vision::mod::broadcastAdd<float,16ul>(a3, v29, 1, a3);
  vision::mod::broadcastAdd<float,16ul>(a3, v28, 0, a3);
  if (a3[2])
  {
    v17 = 0;
    do
    {
      v18 = (float *)vision::mod::CVMLMatrix<float,16ul>::ptr(a3, v17);
      for (i = a3[3]; i; --i)
      {
        *v18 = fmaxf(*v18, 0.0);
        ++v18;
      }
      ++v17;
      v20 = a3[2];
    }
    while (v17 < v20);
    if ((_QWORD *)a1 == a2 && v20)
    {
      v21 = 0;
      do
      {
        *(_DWORD *)(vision::mod::CVMLMatrix<float,16ul>::ptr(a3, v21) + 4 * v21) = 0;
        ++v21;
      }
      while (v21 < a3[2]);
    }
  }
  if (v32 && v30[0])
    free(v30[0]);
  if (v35)
  {
    if (v33[0])
      free(v33[0]);
  }
}

void sub_1A14D34B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25)
{
  void *v25;

  __cxa_free_exception(v25);
  if (a19 && a15)
    free(a15);
  if (a25)
  {
    if (a21)
      free(a21);
  }
  _Unwind_Resume(a1);
}

void std::__function::__func<void vision::mod::broadcastMinus<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1},std::allocator<void vision::mod::broadcastMinus<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1}>,float ()(float,float)>::~__func()
{
  JUMPOUT(0x1A1B0A898);
}

_QWORD *std::__function::__func<void vision::mod::broadcastMinus<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1},std::allocator<void vision::mod::broadcastMinus<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1}>,float ()(float,float)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_1E453B260;
  return result;
}

void std::__function::__func<void vision::mod::broadcastMinus<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1},std::allocator<void vision::mod::broadcastMinus<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1}>,float ()(float,float)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_1E453B260;
}

float std::__function::__func<void vision::mod::broadcastMinus<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1},std::allocator<void vision::mod::broadcastMinus<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1}>,float ()(float,float)>::operator()(uint64_t a1, float *a2, float *a3)
{
  return *a2 - *a3;
}

uint64_t std::__function::__func<void vision::mod::broadcastMinus<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1},std::allocator<void vision::mod::broadcastMinus<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1}>,float ()(float,float)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN6vision3mod14broadcastMinusIfLm16EEEvRKNS0_10CVMLMatrixIT_XT0_EEERKNS0_10CVMLVectorIS3_XT0_EEEiRS4_bEUlffE_"))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void vision::mod::broadcastMinus<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1},std::allocator<void vision::mod::broadcastMinus<float,16ul>(vision::mod::CVMLMatrix<float,16ul> const&,vision::mod::CVMLVector<float,16ul> const&,int,vision::mod::CVMLMatrix<float,16ul>&,BOOL)::{lambda(float,float)#1}>,float ()(float,float)>::target_type()
{
}

uint64_t vision::mod::FaceID3Model::getIdentityTrainingData(vision::mod::FaceID3Model *this, vision::mod::FaceID3Model *a2, uint64_t *a3, uint64_t *a4)
{
  int v5;
  uint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  unint64_t v11;
  uint64_t result;
  uint64_t **v13;
  uint64_t *v14;
  uint64_t *v15;
  unint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;

  v5 = (int)a3;
  v8 = vision::mod::FaceID3Model::checkTestingParams_(a2);
  *a4 = v8;
  if (v8 != 11136)
  {
    result = 0;
    goto LABEL_23;
  }
  v9 = *((_QWORD *)a2 + 8);
  if (!v9)
    goto LABEL_21;
  v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
  v10.i16[0] = vaddlv_u8(v10);
  if (v10.u32[0] > 1uLL)
  {
    v11 = v5;
    if (v9 <= v5)
      v11 = v5 % v9;
  }
  else
  {
    v11 = (v9 - 1) & v5;
  }
  v13 = *(uint64_t ***)(*((_QWORD *)a2 + 7) + 8 * v11);
  if (!v13 || (v14 = *v13) == 0)
  {
LABEL_21:
    v15 = &CVML_status_invalidParameter;
    goto LABEL_22;
  }
  v15 = &CVML_status_invalidParameter;
  while (1)
  {
    v16 = v14[1];
    if (v16 == v5)
      break;
    if (v10.u32[0] > 1uLL)
    {
      if (v16 >= v9)
        v16 %= v9;
    }
    else
    {
      v16 &= v9 - 1;
    }
    if (v16 != v11)
      goto LABEL_22;
LABEL_19:
    v14 = (uint64_t *)*v14;
    if (!v14)
      goto LABEL_22;
  }
  if (*((_DWORD *)v14 + 4) != v5)
    goto LABEL_19;
  v18 = v14[3];
  v19 = v14[4];
  v17 = v14 + 3;
  if (v19 == v18)
  {
    v15 = &CVML_status_inconsistentState;
LABEL_22:
    result = 0;
    *a4 = (*v15 + 128) | 0x2B00;
  }
  else
  {
    result = (*(uint64_t (**)(_QWORD, uint64_t *))(**((_QWORD **)a2 + 6) + 32))(*((_QWORD *)a2 + 6), v17);
    if (!result)
    {
      v15 = &CVML_status_memoryAllocationError;
      goto LABEL_22;
    }
  }
LABEL_23:
  *(_QWORD *)this = result;
  return result;
}

uint64_t vision::mod::FaceID3Model::checkTestingParams_(vision::mod::FaceID3Model *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t *v3;

  v1 = *((_QWORD *)this + 15);
  if (!v1)
  {
    syslog(5, "ERROR: empty dictIds_");
LABEL_10:
    v3 = &CVML_status_inconsistentState;
    return (*v3 + 128) | 0x2B00;
  }
  if (!*((_QWORD *)this + 10))
  {
    syslog(5, "ERROR: empty labels");
    goto LABEL_10;
  }
  v2 = *(_QWORD *)(*((_QWORD *)this + 6) + 72);
  if (!v2)
  {
    syslog(5, "ERROR: empty dictionary data");
    goto LABEL_10;
  }
  if (v1 != v2)
  {
    syslog(5, "ERROR: number of elements dismatch between dictIds_ and dictData_");
    goto LABEL_10;
  }
  v3 = &CVML_status_ok;
  return (*v3 + 128) | 0x2B00;
}

uint64_t vision::mod::FaceID3Model::predict(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  BOOL v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  vision::mod::ImageDescriptorBufferFloat32 *v11;
  uint64_t v12;
  uint64_t v13;
  float *v14;
  float *v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  float v19;
  int v20;
  _QWORD *v21;
  _QWORD **v22;
  _QWORD *v23;
  _QWORD **v24;
  int v25;
  _QWORD *v26;
  double v27;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t *v30;
  uint64_t *v31;
  uint64_t *v32;
  char *v33;
  unint64_t v34;
  char *v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  char *v41;
  char *v42;
  char *v43;
  char *v44;
  uint64_t *v45;
  uint64_t *v46;
  unint64_t v47;
  uint64_t v48;
  char *v49;
  uint64_t *v50;
  BOOL v51;
  uint64_t *v52;
  float v53;
  float v54;
  double v55;
  double v56;
  uint64_t *v57;
  uint64_t *v58;
  double v59;
  uint64_t *v60;
  float v61;
  double v62;
  uint64_t *v63;
  uint64_t *v64;
  uint64_t *v65;
  int v66;
  _QWORD *v67;
  _QWORD **v68;
  _QWORD *v69;
  _QWORD **v70;
  int v71;
  _QWORD *v72;
  uint64_t *v73;
  uint64_t *v74;
  _QWORD *v75;
  unint64_t v76;
  _QWORD *v77;
  _QWORD *v78;
  uint64_t v79;
  unint64_t v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  uint64_t v84;
  _QWORD *v85;
  _QWORD *v86;
  _QWORD *v87;
  _QWORD *v88;
  uint64_t v89;
  uint64_t *v90;
  uint64_t v91;
  uint64_t *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t *v97;
  _QWORD *v98;
  uint64_t v99;
  uint64_t *v100;
  _QWORD *v101;
  uint64_t v102;
  void *__p;
  float *v104;
  uint64_t v105;
  uint64_t v106;
  void *v107;
  _BYTE *v108;
  uint64_t v109;
  uint64_t *v110;
  _QWORD *v111;
  unint64_t v112;
  unint64_t v113;
  uint64_t *v114;

  v3 = *(int *)(a2 + 64) < 1 || *(_DWORD *)(a2 + 96) < 1;
  if (v3 || (v4 = a2, v5 = *(_QWORD *)(a2 + 72), (v5 & 0x80000000) != 0))
  {
    syslog(5, "ERROR: invalid image descriptor buffer");
    return 11132;
  }
  if ((_DWORD)v5)
  {
    result = vision::mod::FaceID3Model::checkTestingParams_((vision::mod::FaceID3Model *)a1);
    if (result != 11136)
      return result;
    v9 = *(_QWORD *)(a1 + 48);
    v108 = 0;
    v109 = 0;
    v107 = 0;
    std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>(&v107, *(const void **)(v9 + 8), *(_QWORD *)(v9 + 16), (uint64_t)(*(_QWORD *)(v9 + 16) - *(_QWORD *)(v9 + 8)) >> 3);
    vision::mod::FaceID3Model::normalizeDescriptor_((vision::mod::FaceID3Model *)&v106, *(vision::mod::ImageDescriptorBufferFloat32 **)(a1 + 48));
    v93 = v5;
    v10 = 0;
    v90 = a3 + 2;
    v91 = v4;
    v92 = a3;
    do
    {
      v11 = (vision::mod::ImageDescriptorBufferFloat32 *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 16))(v4);
      (*(void (**)(uint64_t, vision::mod::ImageDescriptorBufferFloat32 *, uint64_t))(*(_QWORD *)v4 + 112))(v4, v11, v10);
      vision::mod::FaceID3Model::normalizeDescriptor_((vision::mod::FaceID3Model *)&v105, v11);
      v96 = v10;
      v13 = v105;
      v12 = v106;
      *(_DWORD *)(v105 + 104) = *(_DWORD *)(a1 + 44);
      v94 = v12;
      (*(void (**)(void **__return_ptr, uint64_t))(*(_QWORD *)v13 + 80))(&__p, v13);
      v14 = (float *)__p;
      v15 = v104;
      while (v14 != v15)
      {
        *v14 = *v14 + *v14;
        ++v14;
      }
      v101 = 0;
      v102 = 0;
      v100 = (uint64_t *)&v101;
      v16 = v107;
      if (v108 == v107)
        goto LABEL_40;
      v17 = 0;
      v18 = (unint64_t)((v108 - (_BYTE *)v107) >> 3) <= 1 ? 1 : (v108 - (_BYTE *)v107) >> 3;
      do
      {
        v110 = (uint64_t *)v16[v17];
        v19 = 1.0 - *((float *)__p + v17);
        v20 = *((_DWORD *)std::__hash_table<std::__hash_value_type<long long,int>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,int>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,int>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,int>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>((float *)(a1 + 96), (unint64_t)v110, &v110)+ 6);
        LODWORD(v97) = v20;
        v21 = v101;
        if (!v101)
          goto LABEL_25;
        v22 = &v101;
        do
        {
          v23 = v21;
          v24 = v22;
          v25 = *((_DWORD *)v21 + 8);
          v26 = v21 + 1;
          if (v25 >= v20)
          {
            v26 = v23;
            v22 = (_QWORD **)v23;
          }
          v21 = (_QWORD *)*v26;
        }
        while (v21);
        if (v22 == &v101)
          goto LABEL_25;
        if (v25 < v20)
          v23 = v24;
        if (v20 >= *((_DWORD *)v23 + 8))
        {
          v27 = v19;
          if (*((double *)std::__tree<std::__value_type<int,double>,std::__map_value_compare<int,std::__value_type<int,double>,std::less<int>,true>,std::allocator<std::__value_type<int,double>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&v100, v20, &v97)+ 5) >= v27)v27 = *((double *)std::__tree<std::__value_type<int,double>,std::__map_value_compare<int,std::__value_type<int,double>,std::less<int>,true>,std::allocator<std::__value_type<int,double>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&v100, v20, &v97)+ 5);
          *((double *)std::__tree<std::__value_type<int,double>,std::__map_value_compare<int,std::__value_type<int,double>,std::less<int>,true>,std::allocator<std::__value_type<int,double>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&v100, v20, &v97)+ 5) = v27;
        }
        else
        {
LABEL_25:
          *((double *)std::__tree<std::__value_type<int,double>,std::__map_value_compare<int,std::__value_type<int,double>,std::less<int>,true>,std::allocator<std::__value_type<int,double>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&v100, v20, &v97)+ 5) = v19;
        }
        ++v17;
      }
      while (v17 != v18);
      if (v102 != 1)
      {
LABEL_40:
        v95 = v13;
        v32 = v100;
        if (v100 == (uint64_t *)&v101)
        {
          v33 = 0;
          v34 = 0;
        }
        else
        {
          v33 = 0;
          v34 = 0;
          v35 = 0;
          do
          {
            v36 = *((_DWORD *)v32 + 8);
            v37 = v32[5];
            if (v34 >= (unint64_t)v35)
            {
              v38 = (uint64_t)(v34 - (_QWORD)v33) >> 4;
              v39 = v38 + 1;
              if ((unint64_t)(v38 + 1) >> 60)
                std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
              if ((v35 - v33) >> 3 > v39)
                v39 = (v35 - v33) >> 3;
              if ((unint64_t)(v35 - v33) >= 0x7FFFFFFFFFFFFFF0)
                v40 = 0xFFFFFFFFFFFFFFFLL;
              else
                v40 = v39;
              if (v40)
              {
                if (v40 >> 60)
                  std::__throw_bad_array_new_length[abi:ne180100]();
                v41 = (char *)operator new(16 * v40);
              }
              else
              {
                v41 = 0;
              }
              v42 = &v41[16 * v38];
              *(_DWORD *)v42 = v36;
              *((_QWORD *)v42 + 1) = v37;
              if ((char *)v34 == v33)
              {
                v44 = &v41[16 * v38];
              }
              else
              {
                v43 = &v41[16 * v38];
                do
                {
                  v44 = v43 - 16;
                  *((_OWORD *)v43 - 1) = *(_OWORD *)(v34 - 16);
                  v34 -= 16;
                  v43 -= 16;
                }
                while ((char *)v34 != v33);
              }
              v35 = &v41[16 * v40];
              v34 = (unint64_t)(v42 + 16);
              if (v33)
                operator delete(v33);
              v33 = v44;
            }
            else
            {
              *(_DWORD *)v34 = v36;
              *(_QWORD *)(v34 + 8) = v37;
              v34 += 16;
            }
            v45 = (uint64_t *)v32[1];
            if (v45)
            {
              do
              {
                v46 = v45;
                v45 = (uint64_t *)*v45;
              }
              while (v45);
            }
            else
            {
              do
              {
                v46 = (uint64_t *)v32[2];
                v51 = *v46 == (_QWORD)v32;
                v32 = v46;
              }
              while (!v51);
            }
            v32 = v46;
          }
          while (v46 != (uint64_t *)&v101);
        }
        v47 = 126 - 2 * __clz((uint64_t)(v34 - (_QWORD)v33) >> 4);
        if ((char *)v34 == v33)
          v48 = 0;
        else
          v48 = v47;
        std::__introsort<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *,false>((double *)v33, v34, v48, 1);
        v111 = 0;
        v112 = 0;
        v49 = v33;
        v110 = (uint64_t *)&v111;
        if ((char *)v34 == v33)
        {
          v98 = 0;
          v99 = 0;
          v97 = (uint64_t *)&v98;
          v13 = v95;
          v29 = v92;
        }
        else
        {
          do
          {
            v50 = (uint64_t *)*((_QWORD *)v49 + 1);
            std::__tree<std::__value_type<int,double>,std::__map_value_compare<int,std::__value_type<int,double>,std::less<int>,true>,std::allocator<std::__value_type<int,double>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&v110, *(_DWORD *)v49, v49)[5] = v50;
            v49 += 16;
            v51 = v112 >= *(int *)(a1 + 40) || v49 == (char *)v34;
          }
          while (!v51);
          v52 = v110;
          v98 = 0;
          v99 = 0;
          v97 = (uint64_t *)&v98;
          v13 = v95;
          v29 = v92;
          if (v110 != (uint64_t *)&v111)
          {
            v53 = *(float *)(a1 + 36);
            v54 = 0.0;
            do
            {
              v55 = *((double *)v52 + 5);
              *((double *)std::__tree<std::__value_type<int,double>,std::__map_value_compare<int,std::__value_type<int,double>,std::less<int>,true>,std::allocator<std::__value_type<int,double>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&v97, *((_DWORD *)v52 + 8), (_DWORD *)v52 + 8)+ 5) = v55 / v53;
              v53 = *(float *)(a1 + 36);
              v56 = exp(*((double *)v52 + 5) / v53);
              v57 = (uint64_t *)v52[1];
              if (v57)
              {
                do
                {
                  v58 = v57;
                  v57 = (uint64_t *)*v57;
                }
                while (v57);
              }
              else
              {
                do
                {
                  v58 = (uint64_t *)v52[2];
                  v51 = *v58 == (_QWORD)v52;
                  v52 = v58;
                }
                while (!v51);
              }
              v59 = v56 + v54;
              v54 = v59;
              v52 = v58;
            }
            while (v58 != (uint64_t *)&v111);
            v60 = v97;
            if (v97 != (uint64_t *)&v98)
            {
              v61 = v59;
              v62 = logf(v61);
              do
              {
                *((long double *)v60 + 5) = exp(*((double *)v60 + 5) - v62);
                v63 = (uint64_t *)v60[1];
                if (v63)
                {
                  do
                  {
                    v64 = v63;
                    v63 = (uint64_t *)*v63;
                  }
                  while (v63);
                }
                else
                {
                  do
                  {
                    v64 = (uint64_t *)v60[2];
                    v51 = *v64 == (_QWORD)v60;
                    v60 = v64;
                  }
                  while (!v51);
                }
                v60 = v64;
              }
              while (v64 != (uint64_t *)&v98);
            }
          }
        }
        v65 = v100;
        if (v100 != (uint64_t *)&v101)
        {
          do
          {
            v66 = *((_DWORD *)v65 + 8);
            v67 = v98;
            if (!v98)
              goto LABEL_107;
            v68 = &v98;
            do
            {
              v69 = v67;
              v70 = v68;
              v71 = *((_DWORD *)v67 + 8);
              v72 = v67 + 1;
              if (v71 >= v66)
              {
                v72 = v69;
                v68 = (_QWORD **)v69;
              }
              v67 = (_QWORD *)*v72;
            }
            while (v67);
            if (v68 == &v98)
              goto LABEL_107;
            if (v71 < v66)
              v69 = v70;
            if (v66 < *((_DWORD *)v69 + 8))
LABEL_107:
              std::__tree<std::__value_type<int,double>,std::__map_value_compare<int,std::__value_type<int,double>,std::less<int>,true>,std::allocator<std::__value_type<int,double>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&v97, v66, (_DWORD *)v65 + 8)[5] = 0;
            v73 = (uint64_t *)v65[1];
            if (v73)
            {
              do
              {
                v74 = v73;
                v73 = (uint64_t *)*v73;
              }
              while (v73);
            }
            else
            {
              do
              {
                v74 = (uint64_t *)v65[2];
                v51 = *v74 == (_QWORD)v65;
                v65 = v74;
              }
              while (!v51);
            }
            v65 = v74;
          }
          while (v74 != (uint64_t *)&v101);
        }
        std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(v111);
        if (v33)
          operator delete(v33);
      }
      else
      {
        v98 = 0;
        v99 = 0;
        v97 = (uint64_t *)&v98;
        v28 = v100;
        v29 = v92;
        if (v100 != (uint64_t *)&v101)
        {
          do
          {
            *((double *)std::__tree<std::__value_type<int,double>,std::__map_value_compare<int,std::__value_type<int,double>,std::less<int>,true>,std::allocator<std::__value_type<int,double>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&v97, *((_DWORD *)v28 + 8), (_DWORD *)v28 + 8)+ 5) = fmax(fmin(*((double *)v28 + 5), 1.0), 0.0);
            v30 = (uint64_t *)v28[1];
            if (v30)
            {
              do
              {
                v31 = v30;
                v30 = (uint64_t *)*v30;
              }
              while (v30);
            }
            else
            {
              do
              {
                v31 = (uint64_t *)v28[2];
                v51 = *v31 == (_QWORD)v28;
                v28 = v31;
              }
              while (!v51);
            }
            v28 = v31;
          }
          while (v31 != (uint64_t *)&v101);
        }
      }
      v75 = (_QWORD *)v29[1];
      v76 = v29[2];
      if ((unint64_t)v75 >= v76)
      {
        v80 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v75 - *v29) >> 3);
        v81 = v80 + 1;
        v4 = v91;
        if (v80 + 1 > 0xAAAAAAAAAAAAAAALL)
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        v82 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v76 - *v29) >> 3);
        if (2 * v82 > v81)
          v81 = 2 * v82;
        if (v82 >= 0x555555555555555)
          v83 = 0xAAAAAAAAAAAAAAALL;
        else
          v83 = v81;
        v114 = v90;
        if (v83)
          v83 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(v83);
        else
          v84 = 0;
        v86 = (_QWORD *)(v83 + 24 * v80);
        v110 = (uint64_t *)v83;
        v111 = v86;
        v113 = v83 + 24 * v84;
        *v86 = v97;
        v87 = v98;
        v86[1] = v98;
        v88 = v86 + 1;
        v89 = v99;
        v86[2] = v99;
        if (v89)
        {
          v87[2] = v88;
          v97 = (uint64_t *)&v98;
          v98 = 0;
          v99 = 0;
        }
        else
        {
          *v86 = v88;
        }
        v112 = (unint64_t)(v86 + 3);
        std::vector<std::map<int,double>>::__swap_out_circular_buffer(v29, &v110);
        v85 = (_QWORD *)v29[1];
        std::__split_buffer<std::map<int,double>>::~__split_buffer((uint64_t)&v110);
      }
      else
      {
        *v75 = v97;
        v77 = v98;
        v75[1] = v98;
        v78 = v75 + 1;
        v79 = v99;
        v75[2] = v99;
        v4 = v91;
        if (v79)
        {
          v77[2] = v78;
          v97 = (uint64_t *)&v98;
          v98 = 0;
          v99 = 0;
        }
        else
        {
          *v75 = v78;
        }
        v85 = v75 + 3;
      }
      v29[1] = (uint64_t)v85;
      std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(v98);
      std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(v101);
      if (__p)
      {
        v104 = (float *)__p;
        operator delete(__p);
      }
      (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
      v10 = v96 + 1;
    }
    while (v96 + 1 != v93);
    if (v94)
      (*(void (**)(uint64_t))(*(_QWORD *)v94 + 8))(v94);
    if (v107)
      operator delete(v107);
  }
  return 11136;
}

void sub_1A14D3FF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32)
{
  if (__p)
    operator delete(__p);
  if (a2 == 2)
  {
    __cxa_begin_catch(exception_object);
    syslog(5, "ERROR: memory allocation failed");
    __cxa_end_catch();
  }
  else
  {
    if (a2 != 1)
      _Unwind_Resume(exception_object);
    __cxa_begin_catch(exception_object);
    syslog(5, "ERROR: unexpected exception thrown");
    __cxa_end_catch();
  }
  JUMPOUT(0x1A14D3FB4);
}

uint64_t vision::mod::FaceID3Model::normalizeDescriptor_(vision::mod::FaceID3Model *this, vision::mod::ImageDescriptorBufferFloat32 *a2)
{
  uint64_t v4;
  unint64_t v5;
  vDSP_Length v6;
  float *DataForKthDescriptor;
  uint64_t result;
  float __B;
  float __C;

  v4 = *((_QWORD *)a2 + 9);
  if (v4)
  {
    v5 = 0;
    v6 = *((_QWORD *)a2 + 12);
    do
    {
      DataForKthDescriptor = (float *)vision::mod::ImageDescriptorBufferAbstract::getDataForKthDescriptor(a2, v5);
      __C = 0.0;
      vDSP_svesq(DataForKthDescriptor, 1, &__C, v6);
      __B = 1.0 / sqrtf(__C);
      vDSP_vsmul(DataForKthDescriptor, 1, &__B, DataForKthDescriptor, 1, v6);
      ++v5;
    }
    while (v4 != v5);
  }
  result = (*(uint64_t (**)(vision::mod::ImageDescriptorBufferFloat32 *))(*(_QWORD *)a2 + 24))(a2);
  *(_QWORD *)this = result;
  return result;
}

double *std::__introsort<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *,false>(double *result, unint64_t a2, uint64_t a3, char a4)
{
  double *v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  double *v12;
  int v13;
  uint64_t v14;
  double v15;
  int v16;
  double *v17;
  double *v18;
  unint64_t v19;
  unint64_t v20;
  double v21;
  unint64_t v22;
  double v23;
  unint64_t v24;
  int v25;
  uint64_t v26;
  double v27;
  double v28;
  BOOL v29;
  double *v30;
  double v31;
  double *v32;
  double v33;
  unint64_t v34;
  unint64_t v35;
  double v36;
  int v37;
  int v38;
  uint64_t v39;
  double v40;
  double v41;
  double v42;
  double v43;
  int v44;
  double v45;
  double v46;
  int v47;
  double v48;
  double v49;
  int v50;
  int v51;
  double v52;
  int v53;
  double v54;
  int v55;
  double *v56;
  BOOL v58;
  uint64_t v59;
  double *v60;
  double v61;
  double v62;
  int v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  int64_t v67;
  int64_t v68;
  int64_t v69;
  uint64_t v70;
  unint64_t v71;
  double v72;
  double v73;
  unint64_t v74;
  int v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  int v81;
  uint64_t v82;
  unint64_t v83;
  unint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  unint64_t v88;
  double v89;
  double v90;
  int v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v95;
  double v96;
  double v97;
  int v98;
  unint64_t v99;
  double v100;

  v7 = result;
LABEL_2:
  v8 = (unint64_t)v7;
  while (2)
  {
    v7 = (double *)v8;
    v9 = a2 - v8;
    v10 = (uint64_t)(a2 - v8) >> 4;
    switch(v10)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        v42 = *(double *)(a2 - 8);
        v43 = *(double *)(v8 + 8);
        if (v42 > v43)
        {
          v44 = *(_DWORD *)v8;
          *(_DWORD *)v8 = *(_DWORD *)(a2 - 16);
          *(_DWORD *)(a2 - 16) = v44;
          *(double *)(v8 + 8) = v42;
          *(double *)(a2 - 8) = v43;
        }
        return result;
      case 3uLL:
        return std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>((double *)v8, (double *)(v8 + 16), (double *)(a2 - 16));
      case 4uLL:
        return std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>((double *)v8, (double *)(v8 + 16), (double *)(v8 + 32), a2 - 16);
      case 5uLL:
        result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>((double *)v8, (double *)(v8 + 16), (double *)(v8 + 32), v8 + 48);
        v45 = *(double *)(a2 - 8);
        v46 = *(double *)(v8 + 56);
        if (v45 > v46)
        {
          v47 = *(_DWORD *)(v8 + 48);
          *(_DWORD *)(v8 + 48) = *(_DWORD *)(a2 - 16);
          *(_DWORD *)(a2 - 16) = v47;
          *(double *)(v8 + 56) = v45;
          *(double *)(a2 - 8) = v46;
          v48 = *(double *)(v8 + 56);
          v49 = *(double *)(v8 + 40);
          if (v48 > v49)
          {
            v50 = *(_DWORD *)(v8 + 32);
            v51 = *(_DWORD *)(v8 + 48);
            *(_DWORD *)(v8 + 32) = v51;
            *(_DWORD *)(v8 + 48) = v50;
            *(double *)(v8 + 40) = v48;
            *(double *)(v8 + 56) = v49;
            v52 = *(double *)(v8 + 24);
            if (v48 > v52)
            {
              v53 = *(_DWORD *)(v8 + 16);
              *(_DWORD *)(v8 + 16) = v51;
              *(_DWORD *)(v8 + 32) = v53;
              *(double *)(v8 + 24) = v48;
              *(double *)(v8 + 40) = v52;
              v54 = *(double *)(v8 + 8);
              if (v48 > v54)
              {
                v55 = *(_DWORD *)v8;
                *(_DWORD *)v8 = v51;
                *(_DWORD *)(v8 + 16) = v55;
                *(double *)(v8 + 8) = v48;
                *(double *)(v8 + 24) = v54;
              }
            }
          }
        }
        return result;
      default:
        if (v9 <= 383)
        {
          v56 = (double *)(v8 + 16);
          v58 = v8 == a2 || v56 == (double *)a2;
          if ((a4 & 1) != 0)
          {
            if (!v58)
            {
              v59 = 0;
              v60 = (double *)v8;
              do
              {
                v61 = v60[3];
                v62 = v60[1];
                v60 = v56;
                if (v61 > v62)
                {
                  v63 = *(_DWORD *)v56;
                  v64 = v59;
                  while (1)
                  {
                    v65 = v8 + v64;
                    *(_DWORD *)(v65 + 16) = *(_DWORD *)(v8 + v64);
                    *(_QWORD *)(v65 + 24) = *(_QWORD *)(v8 + v64 + 8);
                    if (!v64)
                      break;
                    v64 -= 16;
                    if (v61 <= *(double *)(v65 - 8))
                    {
                      v66 = v8 + v64 + 16;
                      goto LABEL_80;
                    }
                  }
                  v66 = v8;
LABEL_80:
                  *(_DWORD *)v66 = v63;
                  *(double *)(v66 + 8) = v61;
                }
                v56 = v60 + 2;
                v59 += 16;
              }
              while (v60 + 2 != (double *)a2);
            }
          }
          else if (!v58)
          {
            v95 = v8 + 8;
            do
            {
              v96 = v7[3];
              v97 = v7[1];
              v7 = v56;
              if (v96 > v97)
              {
                v98 = *(_DWORD *)v56;
                v99 = v95;
                do
                {
                  *(_DWORD *)(v99 + 8) = *(_DWORD *)(v99 - 8);
                  *(_QWORD *)(v99 + 16) = *(_QWORD *)v99;
                  v100 = *(double *)(v99 - 16);
                  v99 -= 16;
                }
                while (v96 > v100);
                *(_DWORD *)(v99 + 8) = v98;
                *(double *)(v99 + 16) = v96;
              }
              v56 = v7 + 2;
              v95 += 16;
            }
            while (v7 + 2 != (double *)a2);
          }
          return result;
        }
        if (!a3)
        {
          if (v8 != a2)
          {
            v67 = (v10 - 2) >> 1;
            v68 = v67;
            do
            {
              v69 = v68;
              if (v67 >= v68)
              {
                v70 = (2 * v68) | 1;
                v71 = v8 + 16 * v70;
                if (2 * v69 + 2 < (uint64_t)v10 && *(double *)(v71 + 8) > *(double *)(v71 + 24))
                {
                  v71 += 16;
                  v70 = 2 * v69 + 2;
                }
                v72 = *(double *)(v71 + 8);
                v73 = *(double *)(v8 + 16 * v69 + 8);
                if (v72 <= v73)
                {
                  v74 = v8 + 16 * v69;
                  v75 = *(_DWORD *)v74;
                  do
                  {
                    v76 = v74;
                    v74 = v71;
                    *(_DWORD *)v76 = *(_DWORD *)v71;
                    *(double *)(v76 + 8) = v72;
                    if (v67 < v70)
                      break;
                    v77 = 2 * v70;
                    v70 = (2 * v70) | 1;
                    v71 = v8 + 16 * v70;
                    v78 = v77 + 2;
                    if (v78 < (uint64_t)v10 && *(double *)(v71 + 8) > *(double *)(v71 + 24))
                    {
                      v71 += 16;
                      v70 = v78;
                    }
                    v72 = *(double *)(v71 + 8);
                  }
                  while (v72 <= v73);
                  *(_DWORD *)v74 = v75;
                  *(double *)(v74 + 8) = v73;
                }
              }
              v68 = v69 - 1;
            }
            while (v69);
            v79 = (unint64_t)v9 >> 4;
            do
            {
              v80 = 0;
              v81 = *(_DWORD *)v8;
              v82 = *(_QWORD *)(v8 + 8);
              v83 = v8;
              do
              {
                v84 = v83;
                v83 += 16 * (v80 + 1);
                v85 = 2 * v80;
                v80 = (2 * v80) | 1;
                v86 = v85 + 2;
                if (v86 < v79 && *(double *)(v83 + 8) > *(double *)(v83 + 24))
                {
                  v83 += 16;
                  v80 = v86;
                }
                *(_DWORD *)v84 = *(_DWORD *)v83;
                *(_QWORD *)(v84 + 8) = *(_QWORD *)(v83 + 8);
              }
              while (v80 <= (uint64_t)((unint64_t)(v79 - 2) >> 1));
              if (v83 == a2 - 16)
              {
                *(_DWORD *)v83 = v81;
                *(_QWORD *)(v83 + 8) = v82;
              }
              else
              {
                *(_DWORD *)v83 = *(_DWORD *)(a2 - 16);
                *(_QWORD *)(v83 + 8) = *(_QWORD *)(a2 - 8);
                *(_DWORD *)(a2 - 16) = v81;
                *(_QWORD *)(a2 - 8) = v82;
                v87 = v83 - v8 + 16;
                if (v87 >= 17)
                {
                  v88 = (((unint64_t)v87 >> 4) - 2) >> 1;
                  v89 = *(double *)(v8 + 16 * v88 + 8);
                  v90 = *(double *)(v83 + 8);
                  if (v89 > v90)
                  {
                    v91 = *(_DWORD *)v83;
                    do
                    {
                      v92 = v88;
                      v93 = v83;
                      v83 = v8 + 16 * v92;
                      *(_DWORD *)v93 = *(_DWORD *)v83;
                      *(double *)(v93 + 8) = v89;
                      if (!v92)
                        break;
                      v88 = (v92 - 1) >> 1;
                      v89 = *(double *)(v8 + 16 * v88 + 8);
                    }
                    while (v89 > v90);
                    *(_DWORD *)v83 = v91;
                    *(double *)(v8 + 16 * v92 + 8) = v90;
                  }
                }
              }
              a2 -= 16;
            }
            while (v79-- > 2);
          }
          return result;
        }
        v11 = v10 >> 1;
        v12 = (double *)(v8 + 16 * (v10 >> 1));
        if ((unint64_t)v9 < 0x801)
        {
          result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>(&v7[2 * (v10 >> 1)], v7, (double *)(a2 - 16));
        }
        else
        {
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>(v7, &v7[2 * (v10 >> 1)], (double *)(a2 - 16));
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>(v7 + 2, v12 - 2, (double *)(a2 - 32));
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>(v7 + 4, &v7[2 * v11 + 2], (double *)(a2 - 48));
          result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>(v12 - 2, v12, &v7[2 * v11 + 2]);
          v13 = *(_DWORD *)v7;
          *(_DWORD *)v7 = *(_DWORD *)v12;
          *(_DWORD *)v12 = v13;
          v14 = *((_QWORD *)v7 + 1);
          v7[1] = v12[1];
          *((_QWORD *)v12 + 1) = v14;
        }
        --a3;
        if ((a4 & 1) == 0)
        {
          v15 = v7[1];
          if (*(v7 - 1) > v15)
            goto LABEL_12;
          if (v15 <= *(double *)(a2 - 8))
          {
            v32 = v7 + 2;
            do
            {
              v8 = (unint64_t)v32;
              if ((unint64_t)v32 >= a2)
                break;
              v33 = v32[1];
              v32 += 2;
            }
            while (v15 <= v33);
          }
          else
          {
            v30 = v7;
            do
            {
              v8 = (unint64_t)(v30 + 2);
              v31 = v30[3];
              v30 += 2;
            }
            while (v15 <= v31);
          }
          v34 = a2;
          if (v8 < a2)
          {
            v35 = a2;
            do
            {
              v34 = v35 - 16;
              v36 = *(double *)(v35 - 8);
              v35 -= 16;
            }
            while (v15 > v36);
          }
          v37 = *(_DWORD *)v7;
          while (v8 < v34)
          {
            v38 = *(_DWORD *)v8;
            *(_DWORD *)v8 = *(_DWORD *)v34;
            *(_DWORD *)v34 = v38;
            v39 = *(_QWORD *)(v8 + 8);
            *(_QWORD *)(v8 + 8) = *(_QWORD *)(v34 + 8);
            *(_QWORD *)(v34 + 8) = v39;
            do
            {
              v40 = *(double *)(v8 + 24);
              v8 += 16;
            }
            while (v15 <= v40);
            do
            {
              v41 = *(double *)(v34 - 8);
              v34 -= 16;
            }
            while (v15 > v41);
          }
          if ((double *)(v8 - 16) != v7)
          {
            *(_DWORD *)v7 = *(_DWORD *)(v8 - 16);
            v7[1] = *(double *)(v8 - 8);
          }
          a4 = 0;
          *(_DWORD *)(v8 - 16) = v37;
          *(double *)(v8 - 8) = v15;
          continue;
        }
        v15 = v7[1];
LABEL_12:
        v16 = *(_DWORD *)v7;
        v17 = v7;
        do
        {
          v18 = v17;
          v17 += 2;
        }
        while (v18[3] > v15);
        v19 = a2;
        if (v18 == v7)
        {
          v22 = a2;
          while ((unint64_t)v17 < v22)
          {
            v20 = v22 - 16;
            v23 = *(double *)(v22 - 8);
            v22 -= 16;
            if (v23 > v15)
              goto LABEL_22;
          }
          v20 = v22;
        }
        else
        {
          do
          {
            v20 = v19 - 16;
            v21 = *(double *)(v19 - 8);
            v19 -= 16;
          }
          while (v21 <= v15);
        }
LABEL_22:
        v8 = (unint64_t)v17;
        if ((unint64_t)v17 < v20)
        {
          v24 = v20;
          do
          {
            v25 = *(_DWORD *)v8;
            *(_DWORD *)v8 = *(_DWORD *)v24;
            *(_DWORD *)v24 = v25;
            v26 = *(_QWORD *)(v8 + 8);
            *(_QWORD *)(v8 + 8) = *(_QWORD *)(v24 + 8);
            *(_QWORD *)(v24 + 8) = v26;
            do
            {
              v27 = *(double *)(v8 + 24);
              v8 += 16;
            }
            while (v27 > v15);
            do
            {
              v28 = *(double *)(v24 - 8);
              v24 -= 16;
            }
            while (v28 <= v15);
          }
          while (v8 < v24);
        }
        if ((double *)(v8 - 16) != v7)
        {
          *(_DWORD *)v7 = *(_DWORD *)(v8 - 16);
          v7[1] = *(double *)(v8 - 8);
        }
        *(_DWORD *)(v8 - 16) = v16;
        *(double *)(v8 - 8) = v15;
        if ((unint64_t)v17 < v20)
        {
LABEL_33:
          result = (double *)std::__introsort<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *,false>(v7, v8 - 16, a3, a4 & 1);
          a4 = 0;
          continue;
        }
        v29 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>((uint64_t)v7, v8 - 16);
        result = (double *)std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>(v8, a2);
        if (!(_DWORD)result)
        {
          if (v29)
            continue;
          goto LABEL_33;
        }
        a2 = v8 - 16;
        if (!v29)
          goto LABEL_2;
        return result;
    }
  }
}

double *std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>(double *result, double *a2, double *a3)
{
  double v3;
  double v4;
  double v5;
  int v6;
  int v7;
  double v8;
  double v9;
  int v10;
  double v11;

  v3 = a2[1];
  v4 = result[1];
  v5 = a3[1];
  if (v3 <= v4)
  {
    if (v5 > v3)
    {
      v7 = *(_DWORD *)a2;
      *(_DWORD *)a2 = *(_DWORD *)a3;
      *(_DWORD *)a3 = v7;
      a2[1] = v5;
      a3[1] = v3;
      v8 = a2[1];
      v9 = result[1];
      if (v8 > v9)
      {
        v10 = *(_DWORD *)result;
        *(_DWORD *)result = *(_DWORD *)a2;
        *(_DWORD *)a2 = v10;
        result[1] = v8;
        a2[1] = v9;
      }
    }
  }
  else
  {
    v6 = *(_DWORD *)result;
    if (v5 <= v3)
    {
      *(_DWORD *)result = *(_DWORD *)a2;
      *(_DWORD *)a2 = v6;
      result[1] = v3;
      a2[1] = v4;
      v11 = a3[1];
      if (v11 <= v4)
        return result;
      *(_DWORD *)a2 = *(_DWORD *)a3;
      *(_DWORD *)a3 = v6;
      a2[1] = v11;
    }
    else
    {
      *(_DWORD *)result = *(_DWORD *)a3;
      *(_DWORD *)a3 = v6;
      result[1] = v5;
    }
    a3[1] = v4;
  }
  return result;
}

double *std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>(double *a1, double *a2, double *a3, uint64_t a4)
{
  double *result;
  double v9;
  double v10;
  int v11;
  double v12;
  double v13;
  int v14;
  double v15;
  double v16;
  int v17;

  result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>(a1, a2, a3);
  v9 = *(double *)(a4 + 8);
  v10 = a3[1];
  if (v9 > v10)
  {
    v11 = *(_DWORD *)a3;
    *(_DWORD *)a3 = *(_DWORD *)a4;
    *(_DWORD *)a4 = v11;
    a3[1] = v9;
    *(double *)(a4 + 8) = v10;
    v12 = a3[1];
    v13 = a2[1];
    if (v12 > v13)
    {
      v14 = *(_DWORD *)a2;
      *(_DWORD *)a2 = *(_DWORD *)a3;
      *(_DWORD *)a3 = v14;
      a2[1] = v12;
      a3[1] = v13;
      v15 = a2[1];
      v16 = a1[1];
      if (v15 > v16)
      {
        v17 = *(_DWORD *)a1;
        *(_DWORD *)a1 = *(_DWORD *)a2;
        *(_DWORD *)a2 = v17;
        a1[1] = v15;
        a2[1] = v16;
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 result;
  double v6;
  double v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  double v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  double v18;
  double v19;
  int v20;
  double v21;
  double v22;
  int v23;
  int v24;
  double v25;
  int v26;
  double v27;
  int v28;

  v4 = (a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = *(double *)(a2 - 8);
      v7 = *(double *)(a1 + 8);
      if (v6 > v7)
      {
        v8 = *(_DWORD *)a1;
        *(_DWORD *)a1 = *(_DWORD *)(a2 - 16);
        *(_DWORD *)(a2 - 16) = v8;
        *(double *)(a1 + 8) = v6;
        *(double *)(a2 - 8) = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>((double *)a1, (double *)(a1 + 16), (double *)(a2 - 16));
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>((double *)a1, (double *)(a1 + 16), (double *)(a1 + 32), a2 - 16);
      return 1;
    case 5:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>((double *)a1, (double *)(a1 + 16), (double *)(a1 + 32), a1 + 48);
      v18 = *(double *)(a2 - 8);
      v19 = *(double *)(a1 + 56);
      if (v18 > v19)
      {
        v20 = *(_DWORD *)(a1 + 48);
        *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 - 16);
        *(_DWORD *)(a2 - 16) = v20;
        *(double *)(a1 + 56) = v18;
        *(double *)(a2 - 8) = v19;
        v21 = *(double *)(a1 + 56);
        v22 = *(double *)(a1 + 40);
        if (v21 > v22)
        {
          v23 = *(_DWORD *)(a1 + 32);
          v24 = *(_DWORD *)(a1 + 48);
          *(_DWORD *)(a1 + 32) = v24;
          *(_DWORD *)(a1 + 48) = v23;
          *(double *)(a1 + 40) = v21;
          *(double *)(a1 + 56) = v22;
          v25 = *(double *)(a1 + 24);
          if (v21 > v25)
          {
            v26 = *(_DWORD *)(a1 + 16);
            *(_DWORD *)(a1 + 16) = v24;
            *(_DWORD *)(a1 + 32) = v26;
            *(double *)(a1 + 24) = v21;
            *(double *)(a1 + 40) = v25;
            v27 = *(double *)(a1 + 8);
            if (v21 > v27)
            {
              v28 = *(_DWORD *)a1;
              *(_DWORD *)a1 = v24;
              *(_DWORD *)(a1 + 16) = v28;
              *(double *)(a1 + 8) = v21;
              *(double *)(a1 + 24) = v27;
            }
          }
        }
      }
      return 1;
    default:
      v9 = a1 + 32;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::FaceID3Model::softmax_(std::map<int,double> const&)::$_0 &,std::pair<int,double> *>((double *)a1, (double *)(a1 + 16), (double *)(a1 + 32));
      v10 = a1 + 48;
      if (a1 + 48 == a2)
        return 1;
      v11 = 0;
      v12 = 0;
      break;
  }
  while (1)
  {
    v13 = *(double *)(v10 + 8);
    if (v13 > *(double *)(v9 + 8))
    {
      v14 = *(_DWORD *)v10;
      v15 = v11;
      while (1)
      {
        v16 = a1 + v15;
        *(_DWORD *)(v16 + 48) = *(_DWORD *)(a1 + v15 + 32);
        *(_QWORD *)(v16 + 56) = *(_QWORD *)(a1 + v15 + 40);
        if (v15 == -32)
          break;
        v15 -= 16;
        if (v13 <= *(double *)(v16 + 24))
        {
          v17 = a1 + v15 + 48;
          goto LABEL_13;
        }
      }
      v17 = a1;
LABEL_13:
      *(_DWORD *)v17 = v14;
      *(double *)(v17 + 8) = v13;
      if (++v12 == 8)
        return v10 + 16 == a2;
    }
    v9 = v10;
    v11 += 16;
    v10 += 16;
    if (v10 == a2)
      return 1;
  }
}

uint64_t vision::mod::FaceID3Model::serialize(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t *v8;
  _QWORD *v9;
  std::vector<int>::pointer begin;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *v17;
  void *v18;
  uint64_t *v19;
  _QWORD *v20;
  _QWORD *v21;
  void *v22[4];
  std::vector<int> v23;
  void *__p;
  void *v25;
  _BYTE __n[148];

  *(_QWORD *)&__n[140] = *MEMORY[0x1E0C80C00];
  strcpy(&__n[4], "FaceID3Model_v1_d16");
  v2 = (_QWORD *)std::ostream::write();
  if ((*((_BYTE *)v2 + *(_QWORD *)(*v2 - 24) + 32) & 5) != 0
    || (v3 = (_QWORD *)std::ostream::write(), (*((_BYTE *)v3 + *(_QWORD *)(*v3 - 24) + 32) & 5) != 0)
    || (v4 = (_QWORD *)std::ostream::write(), (*((_BYTE *)v4 + *(_QWORD *)(*v4 - 24) + 32) & 5) != 0)
    || (v5 = (_QWORD *)std::ostream::write(), (*((_BYTE *)v5 + *(_QWORD *)(*v5 - 24) + 32) & 5) != 0)
    || (v6 = (_QWORD *)std::ostream::write(), (*((_BYTE *)v6 + *(_QWORD *)(*v6 - 24) + 32) & 5) != 0)
    || (v7 = (_QWORD *)std::ostream::write(), (*((_BYTE *)v7 + *(_QWORD *)(*v7 - 24) + 32) & 5) != 0)
    || vision::mod::FaceID3KmeansParams::serialize() != 11136)
  {
    v12 = -11;
    return (v12 + 128) | 0x2B00;
  }
  *(_DWORD *)__n = a1[15];
  std::vector<long long>::vector(&__p, *(int *)__n);
  std::vector<int>::vector(&v23, *(int *)__n);
  v8 = (uint64_t *)a1[14];
  if (v8)
  {
    v9 = __p;
    begin = v23.__begin_;
    do
    {
      *v9++ = v8[2];
      *begin++ = *((_DWORD *)v8 + 6);
      v8 = (uint64_t *)*v8;
    }
    while (v8);
  }
  v11 = (_QWORD *)std::ostream::write();
  if ((*((_BYTE *)v11 + *(_QWORD *)(*v11 - 24) + 32) & 5) == 0)
  {
    if (!*(_DWORD *)__n)
    {
      v12 = 0;
      goto LABEL_13;
    }
    v14 = (_QWORD *)std::ostream::write();
    if ((*((_BYTE *)v14 + *(_QWORD *)(*v14 - 24) + 32) & 5) == 0)
    {
      v15 = (_QWORD *)std::ostream::write();
      if ((*((_BYTE *)v15 + *(_QWORD *)(*v15 - 24) + 32) & 5) == 0)
      {
        v25 = __p;
        v23.__end_ = v23.__begin_;
        v16 = a1[6];
        if (*(_QWORD *)(v16 + 72) == *(int *)__n)
        {
          v22[3] = *(void **)(v16 + 96);
          memset(v22, 0, 24);
          std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>(v22, *(const void **)(v16 + 8), *(_QWORD *)(v16 + 16), (uint64_t)(*(_QWORD *)(v16 + 16) - *(_QWORD *)(v16 + 8)) >> 3);
          v17 = (_QWORD *)std::ostream::write();
          v18 = v22[0];
          if ((*((_BYTE *)v17 + *(_QWORD *)(*v17 - 24) + 32) & 5) != 0)
          {
            v19 = &CVML_status_IOError;
          }
          else
          {
            v20 = (_QWORD *)std::ostream::write();
            v19 = &CVML_status_IOError;
            if ((*((_BYTE *)v20 + *(_QWORD *)(*v20 - 24) + 32) & 5) == 0)
            {
              v21 = (_QWORD *)std::ostream::write();
              if ((*((_BYTE *)v21 + *(_QWORD *)(*v21 - 24) + 32) & 5) == 0)
                v19 = &CVML_status_ok;
            }
          }
          v12 = *v19;
          if (v18)
            operator delete(v18);
          goto LABEL_13;
        }
        syslog(5, "ERROR: number of elements dismatch between dictIds_ and dictData_");
      }
    }
  }
  v12 = -11;
LABEL_13:
  if (v23.__begin_)
  {
    v23.__end_ = v23.__begin_;
    operator delete(v23.__begin_);
  }
  if (__p)
  {
    v25 = __p;
    operator delete(__p);
  }
  return (v12 + 128) | 0x2B00;
}

void sub_1A14D510C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, void *a17, uint64_t a18)
{
  if (__p)
    operator delete(__p);
  if (a17)
    operator delete(a17);
  _Unwind_Resume(exception_object);
}

void vision::mod::FaceID3Model::deserialize(_QWORD *a1, uint64_t a2, _QWORD *a3)
{
  _QWORD *v5;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  _DWORD __n[3];
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  _QWORD v21[2];
  _QWORD v22[16];

  v22[15] = *MEMORY[0x1E0C80C00];
  *a3 = 11136;
  v5 = (_QWORD *)std::istream::read();
  if ((*((_BYTE *)v5 + *(_QWORD *)(*v5 - 24) + 32) & 5) != 0)
    goto LABEL_19;
  if (v21[1] != 0x4D33444965636146
    || v22[0] != 0x5F31765F6C65646FLL
    || *(_QWORD *)((char *)v22 + 3) != 0x3631645F31765F6CLL)
  {
    syslog(5, "ERROR: incorrect header");
LABEL_19:
    *a3 = 11125;
    *a1 = 0;
    return;
  }
  v20 = 0;
  v21[0] = 0;
  v19 = 0;
  v8 = (_QWORD *)std::istream::read();
  if ((*((_BYTE *)v8 + *(_QWORD *)(*v8 - 24) + 32) & 5) != 0)
    goto LABEL_19;
  v9 = (_QWORD *)std::istream::read();
  if ((*((_BYTE *)v9 + *(_QWORD *)(*v9 - 24) + 32) & 5) != 0)
    goto LABEL_19;
  v10 = (_QWORD *)std::istream::read();
  if ((*((_BYTE *)v10 + *(_QWORD *)(*v10 - 24) + 32) & 5) != 0)
    goto LABEL_19;
  v11 = (_QWORD *)std::istream::read();
  if ((*((_BYTE *)v11 + *(_QWORD *)(*v11 - 24) + 32) & 5) != 0)
    goto LABEL_19;
  v12 = (_QWORD *)std::istream::read();
  if ((*((_BYTE *)v12 + *(_QWORD *)(*v12 - 24) + 32) & 5) != 0)
    goto LABEL_19;
  v16 = 0xA00000001;
  v17 = 300;
  v18 = 0x3F1A36E2EB1C432DLL;
  if (vision::mod::FaceID3KmeansParams::deserialize() != 11136)
    goto LABEL_19;
  std::make_unique[abi:ne180100]<vision::mod::FaceID3Model,int &,int &,int &,vision::mod::FaceIDIndexMode &,float &>((uint64_t *)&__n[1], (_DWORD *)v21 + 1, (int *)v21, (int *)&v16, &v19, (int *)&v20 + 1);
  v13 = *(_QWORD *)&__n[1];
  *(_DWORD *)(*(_QWORD *)&__n[1] + 44) = v20;
  __n[0] = 0;
  v14 = (_QWORD *)std::istream::read();
  if ((*((_BYTE *)v14 + *(_QWORD *)(*v14 - 24) + 32) & 5) != 0)
  {
    *a3 = 11125;
    *a1 = 0;
  }
  else
  {
    *(_QWORD *)&__n[1] = 0;
    *a1 = v13;
  }
  std::unique_ptr<vision::mod::FaceID3Model>::reset[abi:ne180100]((vision::mod::FaceID3Model **)&__n[1]);
}

void sub_1A14D56D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,vision::mod::FaceID3Model *a37)
{
  vision::mod::ImageDescriptorBufferFloat32::~ImageDescriptorBufferFloat32(&a11);
  if (__p)
  {
    a27 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a30)
  {
    a31 = (uint64_t)a30;
    operator delete(a30);
  }
  if (a33)
  {
    a34 = (uint64_t)a33;
    operator delete(a33);
  }
  std::unique_ptr<vision::mod::FaceID3Model>::reset[abi:ne180100](&a37);
  _Unwind_Resume(a1);
}

uint64_t std::make_unique[abi:ne180100]<vision::mod::FaceID3Model,int &,int &,int &,vision::mod::FaceIDIndexMode &,float &>(uint64_t *a1, _DWORD *a2, int *a3, int *a4, int *a5, int *a6)
{
  uint64_t result;
  int v13;
  int v14;
  int v15;
  int v16;

  result = operator new();
  v13 = *a3;
  v14 = *a4;
  v15 = *a5;
  v16 = *a6;
  *(_DWORD *)result = *a2;
  *(_DWORD *)(result + 4) = v13;
  *(_DWORD *)(result + 8) = v14;
  *(_QWORD *)(result + 12) = 0x12C0000000ALL;
  *(_QWORD *)(result + 24) = 0x3F1A36E2EB1C432DLL;
  *(_DWORD *)(result + 32) = v15;
  *(_DWORD *)(result + 36) = v16;
  *(_QWORD *)(result + 40) = 0x20000000FLL;
  *(_OWORD *)(result + 48) = 0u;
  *(_OWORD *)(result + 64) = 0u;
  *(_QWORD *)(result + 80) = 0;
  *(_DWORD *)(result + 88) = 1065353216;
  *(_OWORD *)(result + 96) = 0u;
  *(_OWORD *)(result + 112) = 0u;
  *(_DWORD *)(result + 128) = 1065353216;
  if (v15 == 1)
    *(_DWORD *)result = 1;
  *a1 = result;
  return result;
}

void std::vector<long long>::push_back[abi:ne180100](uint64_t a1, _QWORD *a2)
{
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  BOOL v11;
  unint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  uint64_t v16;

  v5 = *(_QWORD **)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 16);
  if ((unint64_t)v5 >= v4)
  {
    v7 = *(_QWORD **)a1;
    v8 = ((uint64_t)v5 - *(_QWORD *)a1) >> 3;
    v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    v10 = v4 - (_QWORD)v7;
    if (v10 >> 2 > v9)
      v9 = v10 >> 2;
    v11 = (unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8;
    v12 = 0x1FFFFFFFFFFFFFFFLL;
    if (!v11)
      v12 = v9;
    if (v12)
    {
      v12 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v12);
      v7 = *(_QWORD **)a1;
      v5 = *(_QWORD **)(a1 + 8);
    }
    else
    {
      v13 = 0;
    }
    v14 = (_QWORD *)(v12 + 8 * v8);
    v15 = v12 + 8 * v13;
    *v14 = *a2;
    v6 = v14 + 1;
    while (v5 != v7)
    {
      v16 = *--v5;
      *--v14 = v16;
    }
    *(_QWORD *)a1 = v14;
    *(_QWORD *)(a1 + 8) = v6;
    *(_QWORD *)(a1 + 16) = v15;
    if (v7)
      operator delete(v7);
  }
  else
  {
    *v5 = *a2;
    v6 = v5 + 1;
  }
  *(_QWORD *)(a1 + 8) = v6;
}

void sub_1A14D59C0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14D5A24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  void *v9;
  void *v10;

  v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)VNPixelBufferMLFeatureProvider;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_1A14D5AB8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14D5B38(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14D5C48(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A14D5CC8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14D5DE0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A14D5F14(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A14D5FB0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14D61B8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;

  _Unwind_Resume(a1);
}

void sub_1A14D62D8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14D6408(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14D6518(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  _Unwind_Resume(a1);
}

void sub_1A14D665C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A14D6720(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14D6A10(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A14D71D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16)
{
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;

  _Unwind_Resume(a1);
}

void sub_1A14D74D8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A14D7870(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

void sub_1A14D7924()
{
  JUMPOUT(0x1A14D7918);
}

void sub_1A14D89E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,void *a23,void *a24,void *a25,void *a26,void *a27,void *a28,void *a29,void *a30,void *a31,void *a32,void *a33,void *a34,void *a35,void *a36,void *a37,void *a38,void *a39)
{

  _Unwind_Resume(a1);
}

void sub_1A14D8F28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A14D8FDC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14D93FC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_1A14D9534(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14D9628(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__20258(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__20259(uint64_t a1)
{

}

void sub_1A14D9A40(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1A14D9C0C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

uint64_t _createValueConfidenceCurveForValidPairData(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  float v6;
  uint64_t result;
  id v8;
  _OWORD v9[2];
  int v10;
  _OWORD v11[2];
  int v12;
  uint64_t v13;

  v4 = 0;
  v5 = 0;
  v13 = *MEMORY[0x1E0C80C00];
  v12 = 0;
  memset(v11, 0, sizeof(v11));
  v10 = 0;
  memset(v9, 0, sizeof(v9));
  do
  {
    v6 = *(float *)(a1 + v4 + 4);
    if (v6 >= 0.0)
    {
      *((_DWORD *)v11 + v5) = *(_DWORD *)(a1 + v4);
      *((float *)v9 + v5++) = v6;
    }
    v4 += 8;
  }
  while (v4 != 72);
  if (!v5)
  {
    result = 0;
    goto LABEL_9;
  }
  objc_msgSend(MEMORY[0x1E0DC6D08], "curveWithValues:confidences:count:error:", v11, v9, v5, a3);
  result = objc_claimAutoreleasedReturnValue();
  if (result)
  {
LABEL_9:
    v8 = objc_retainAutorelease((id)result);
    *a2 = v8;

    return 1;
  }
  return result;
}

uint64_t _getValueForConfidence(void *a1, float *a2, int a3, float *a4, _QWORD *a5, float a6)
{
  id v11;
  _BOOL4 v12;
  float *v13;
  uint64_t v14;
  float v15;
  uint64_t v16;
  float v17;
  float v18;
  uint64_t v19;
  float *v20;
  float *v21;
  float v22;
  float v23;
  float v24;
  float *v25;
  float v26;
  float v27;

  v11 = a1;
  v12 = _validateValueConfidencePair(a2, v11, a5);
  if (!a3)
  {
    if (v12)
    {
      if (a2[1] > a6)
      {
        v13 = a2 + 2;
        v16 = 1;
        while (_validateValueConfidencePair(v13, v11, a5))
        {
          v17 = v13[1];
          if (v17 < a6)
          {
            v25 = &a2[2 * v16];
            v21 = v25 - 2;
            v26 = *(v25 - 1) - v17;
            if (v26 == 0.0)
              v27 = 0.5;
            else
              v27 = (float)(a6 - v17) / v26;
LABEL_28:
            v18 = *v21 + (float)(v27 * (float)(*v13 - *v21));
            goto LABEL_29;
          }
          if (v17 == a6)
          {
LABEL_20:
            v18 = *v13;
            goto LABEL_29;
          }
          ++v16;
          v13 += 2;
          if (v16 == 9)
          {
LABEL_17:
            v18 = a2[16];
            goto LABEL_29;
          }
        }
        goto LABEL_18;
      }
      goto LABEL_19;
    }
LABEL_18:
    v19 = 0;
    goto LABEL_30;
  }
  if (!v12)
    goto LABEL_18;
  if (a2[1] < a6)
  {
    v13 = a2 + 2;
    v14 = 1;
    while (_validateValueConfidencePair(v13, v11, a5))
    {
      v15 = v13[1];
      if (v15 > a6)
      {
        v20 = &a2[2 * v14];
        v21 = v20 - 2;
        v22 = *(v20 - 1);
        v23 = v15 - v22;
        if (v23 == 0.0)
          v24 = 0.5;
        else
          v24 = (float)(a6 - v22) / v23;
        v27 = 1.0 - v24;
        goto LABEL_28;
      }
      if (v15 == a6)
        goto LABEL_20;
      ++v14;
      v13 += 2;
      if (v14 == 9)
        goto LABEL_17;
    }
    goto LABEL_18;
  }
LABEL_19:
  v18 = *a2;
LABEL_29:
  *a4 = v18;
  v19 = 1;
LABEL_30:

  return v19;
}

BOOL _validateValueConfidencePair(float *a1, void *a2, _QWORD *a3)
{
  float v3;
  void *v5;
  void *v6;
  float v7;
  id v8;
  double v9;
  void *v10;
  void *v11;

  v3 = a1[1];
  if (a3 && v3 < 0.0)
  {
    v5 = (void *)MEMORY[0x1E0CB3940];
    v6 = (void *)MEMORY[0x1E0CB37E8];
    v7 = *a1;
    v8 = a2;
    *(float *)&v9 = v7;
    objc_msgSend(v6, "numberWithFloat:", v9);
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "stringWithFormat:", CFSTR("no %@ is defined at %@"), v8, v10);
    v11 = (void *)objc_claimAutoreleasedReturnValue();

    +[VNError errorForOutOfBoundsErrorWithLocalizedDescription:](VNError, "errorForOutOfBoundsErrorWithLocalizedDescription:", v11);
    *a3 = (id)objc_claimAutoreleasedReturnValue();

  }
  return v3 >= 0.0;
}

uint64_t _getConfidenceForValue(void *a1, float *a2, int a3, float *a4, _QWORD *a5, float a6)
{
  id v11;
  float *v12;
  uint64_t v13;
  float v14;
  uint64_t v15;
  float *v16;
  float *v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float *v22;

  v11 = a1;
  if (!_validateValueConfidencePair(a2, v11, a5))
  {
LABEL_9:
    v15 = 0;
    goto LABEL_22;
  }
  if (*a2 < a6)
  {
    v12 = a2 + 2;
    v13 = 1;
    while (_validateValueConfidencePair(v12, v11, a5))
    {
      if (*v12 > a6)
      {
        v16 = &a2[2 * v13];
        v18 = *(v16 - 2);
        v17 = v16 - 2;
        v19 = v18;
        v20 = *v12 - v18;
        if (v20 == 0.0)
          v21 = 0.5;
        else
          v21 = (float)(a6 - v19) / v20;
        if (a3)
        {
          v22 = v17;
        }
        else
        {
          v21 = 1.0 - v21;
          v22 = v12;
        }
        if (a3)
          v17 = v12;
        v14 = v22[1] + (float)(v21 * (float)(v17[1] - v22[1]));
        goto LABEL_21;
      }
      if (*v12 == a6)
      {
        v14 = a2[2 * v13 + 1];
        goto LABEL_21;
      }
      ++v13;
      v12 += 2;
      if (v13 == 9)
      {
        v14 = a2[17];
        goto LABEL_21;
      }
    }
    goto LABEL_9;
  }
  v14 = a2[1];
LABEL_21:
  *a4 = v14;
  v15 = 1;
LABEL_22:

  return v15;
}

void sub_1A14DB76C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  if (a2)
  {
    objc_begin_catch(exception_object);
    free(a13);
    objc_exception_rethrow();
  }
  _Unwind_Resume(exception_object);
}

void sub_1A14DB948(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A14DB968(void *a1)
{
  objc_begin_catch(a1);
  JUMPOUT(0x1A14DB858);
}

uint64_t _parseValueConfidenceArrayWithIncreasingConfidences(void *a1, uint64_t a2, int a3)
{
  id v5;
  uint64_t v6;
  float v7;
  float v8;
  float v9;
  float *v10;
  void *v11;
  int v12;
  double v13;
  uint64_t v14;
  void *v15;
  int v16;
  unint64_t v17;
  uint64_t v18;

  v5 = a1;
  if (objc_msgSend(v5, "count") == 18)
  {
    v6 = 0;
    v7 = 1.0;
    v8 = 0.0;
    if (a3)
      v7 = 0.0;
    while (1)
    {
      v9 = v7;
      v10 = (float *)(a2 + 4 * v6);
      objc_msgSend(v5, "objectAtIndex:", v6);
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v11, "floatValue");
      *(_DWORD *)v10 = v12;

      if (*v10 < v8)
        break;
      v14 = v6 + 1;
      *(float *)&v13 = *v10;
      objc_msgSend(v5, "objectAtIndex:", v14, v13);
      v15 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v15, "floatValue");
      *((_DWORD *)v10 + 1) = v16;

      v7 = v10[1];
      if (v7 >= 0.0)
      {
        if (a3)
        {
          if (v7 < v9)
            break;
        }
        else if (v7 > v9)
        {
          break;
        }
      }
      v8 = *v10;
      v17 = v14 - 1;
      v6 = v14 + 1;
      if (v17 >= 0x10)
      {
        v18 = 1;
        goto LABEL_13;
      }
    }
  }
  v18 = 0;
LABEL_13:

  return v18;
}

void polynomialFit(const double *a1, double *a2, double *a3, int a4, const double *a5, const double *a6, const double *a7)
{
  double *v10;
  double v11;
  double *v12;
  _QWORD *v13;
  double *v14;
  double *v15;
  double *v16;
  void *v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  double *v21;
  double *v22;
  uint64_t v23;
  double v24;
  uint64_t v25;
  uint64_t v26;
  double *v27;
  double v28;
  double *v29;
  uint64_t v30;
  double v31;
  uint64_t v32;
  double *v33;
  uint64_t v34;
  double *v35;
  double v36;
  double *v37;
  double *v38;
  uint64_t v39;
  double v40;
  double v41;
  double v42;
  uint64_t v43;
  double *v44;
  double v45;
  double *v46;
  double *v47;
  uint64_t v48;
  double v49;
  double v50;
  double v51;
  unint64_t v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  _QWORD *v57;
  double *v58;
  double *v59;
  double v60;
  uint64_t i;
  double *v62;
  char *v63;
  uint64_t v64;
  uint64_t v65;
  double v66;
  double v67;
  uint64_t j;
  double *v69;
  unint64_t v70;
  double *v71;
  double v72;
  double *v73;
  unint64_t v74;
  double *v75;
  double v76;
  double v77;
  double v78;
  unint64_t v79;
  double v80;
  double *v81;
  unint64_t v82;
  uint64_t v84;
  char *v85;
  __int128 v87;
  uint64_t v88;
  void *__p;
  _BYTE *v90;

  std::vector<double>::vector(&__p, 4uLL);
  v10 = (double *)__p;
  v11 = *a2;
  v12 = (double *)malloc_type_calloc(9uLL, 8uLL, 0x100004000313F17uLL);
  v13 = malloc_type_malloc(0x30uLL, 0x100004000313F17uLL);
  v14 = (double *)malloc_type_malloc(0x18uLL, 0x100004000313F17uLL);
  v15 = (double *)malloc_type_calloc(3uLL, 8uLL, 0x100004000313F17uLL);
  v16 = (double *)malloc_type_calloc(3uLL, 8uLL, 0x100004000313F17uLL);
  v17 = malloc_type_calloc(3 * a4, 8uLL, 0x100004000313F17uLL);
  v18 = v17;
  v19 = 8 * a4;
  if (a4 >= 1)
  {
    v20 = 0;
    v21 = (double *)v17;
    do
    {
      *((_QWORD *)v17 + v20) = 0x3FF0000000000000;
      v22 = v21;
      v23 = 2;
      do
      {
        v24 = (a2[v20] - v11) * *v22;
        v22 = (double *)((char *)v22 + v19);
        *v22 = v24;
        --v23;
      }
      while (v23);
      ++v20;
      ++v21;
    }
    while (v20 != a4);
  }
  v25 = 0;
  if (a4 <= 1)
    v26 = 1;
  else
    v26 = a4;
  v27 = (double *)v17;
  do
  {
    if (a4 <= 0)
    {
      v28 = v16[v25];
    }
    else
    {
      v28 = v16[v25];
      v29 = v27;
      v30 = v26;
      do
      {
        v31 = *v29++;
        v28 = v28 + v31 * v31;
        v16[v25] = v28;
        --v30;
      }
      while (v30);
    }
    v16[v25++] = sqrt(v28);
    v27 = (double *)((char *)v27 + v19);
  }
  while (v25 != 3);
  v32 = 0;
  v33 = (double *)v17;
  do
  {
    v34 = 0;
    v35 = (double *)v17;
    do
    {
      v36 = 0.0;
      if (a4 >= 1)
      {
        v37 = v35;
        v38 = v33;
        v39 = v26;
        do
        {
          v40 = *v37++;
          v41 = v40;
          v42 = *v38++;
          v36 = v36 + v41 * v42;
          --v39;
        }
        while (v39);
      }
      v12[3 * v32 + v34] = v36 / (v16[v34] * v16[v32]);
      ++v34;
      v35 = (double *)((char *)v35 + v19);
    }
    while (v34 != 3);
    ++v32;
    v33 = (double *)((char *)v33 + v19);
  }
  while (v32 != 3);
  v43 = 0;
  v44 = (double *)v17;
  do
  {
    if (a4 <= 0)
    {
      v45 = v15[v43];
    }
    else
    {
      v45 = v15[v43];
      v46 = v44;
      v47 = a3;
      v48 = a4;
      do
      {
        v49 = *v46++;
        v50 = v49;
        v51 = *v47++;
        v45 = v50 * v51 + v45;
        v15[v43] = v45;
        --v48;
      }
      while (v48);
    }
    v15[v43] = v45 / v16[v43];
    ++v43;
    v44 = (double *)((char *)v44 + v19);
  }
  while (v43 != 3);
  v52 = 0;
  v53 = (char *)(v13 + 1);
  v54 = 1;
  v55 = 8;
  v56 = 16;
  v57 = v13;
  v58 = (double *)v13;
  v59 = v12;
  do
  {
    v60 = *v59;
    *v58 = *v59;
    if (v52)
    {
      for (i = 0; i != v52; ++i)
      {
        v60 = v60 - *(double *)&v57[i] * *(double *)&v57[i];
        *v58 = v60;
      }
    }
    if (v60 < *v59 * 0.000000001)
      v60 = *v59 * 0.000000001;
    *v58 = sqrt(v60);
    if (v52 <= 1)
    {
      v62 = &v58[v52 + 1];
      v63 = v53;
      v64 = v56;
      v65 = v54;
      do
      {
        v66 = v59[1];
        ++v59;
        v67 = v66;
        *v62 = v66;
        if (v52)
        {
          for (j = 0; j != v52; ++j)
          {
            v67 = v67 - *(double *)&v63[8 * j] * *(double *)&v57[j];
            *v62 = v67;
          }
        }
        *v62 = v67 / *v58;
        v62 += ++v65;
        v63 += v64;
        v64 += 8;
      }
      while (v65 != 3);
    }
    v58 += v52 + 2;
    v59 += v52 + 2;
    ++v54;
    v57 = (_QWORD *)((char *)v57 + v55);
    v55 += 8;
    v53 += v56;
    v56 += 8;
    ++v52;
  }
  while (v52 != 3);
  v69 = (double *)malloc_type_calloc(3uLL, 8uLL, 0x100004000313F17uLL);
  v70 = 0;
  v71 = (double *)v13;
  do
  {
    v72 = v15[v70];
    v69[v70] = v72;
    if (v70)
    {
      v73 = v69;
      v74 = v70;
      v75 = v71;
      do
      {
        v76 = *v75++;
        v77 = v76;
        v78 = *v73++;
        v72 = v72 - v77 * v78;
        v69[v70] = v72;
        --v74;
      }
      while (v74);
    }
    else
    {
      v75 = v71;
    }
    v71 = v75 + 1;
    v69[v70++] = v72 / *v75;
  }
  while (v70 != 3);
  do
  {
    v79 = v70 - 1;
    v80 = v69[v70 - 1];
    v14[v70 - 1] = v80;
    if (v70 <= 2)
    {
      v81 = &v75[v70];
      v82 = v70;
      do
      {
        v80 = v80 - *v81 * v14[v82];
        v14[v79] = v80;
        v81 += ++v82;
      }
      while ((_DWORD)v82 != 3);
    }
    v14[v79] = v80 / *v75;
    v75 -= v70;
  }
  while (v70-- > 1);
  free(v69);
  v84 = 0;
  v10[3] = v11;
  do
  {
    v10[v84] = v14[v84] / v16[v84];
    ++v84;
  }
  while (v84 != 3);
  free(v12);
  free(v13);
  free(v14);
  free(v15);
  free(v16);
  free(v18);
  v87 = 0uLL;
  v88 = 0;
  std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>(&v87, __p, (uint64_t)v90, (v90 - (_BYTE *)__p) >> 3);
  a1[3] = 0.0;
  v85 = (char *)operator new(0x28uLL);
  *(_QWORD *)v85 = &off_1E453B100;
  *(_OWORD *)(v85 + 8) = v87;
  *((_QWORD *)v85 + 3) = v88;
  *((_QWORD *)v85 + 4) = 2;
  *((_QWORD *)a1 + 3) = v85;
  if (__p)
  {
    v90 = __p;
    operator delete(__p);
  }
}

void sub_1A14DC004(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (__p)
    operator delete(__p);
  if (a16)
    operator delete(a16);
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<long long>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1A14DC090(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::__function::__func<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0,std::allocator<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0>,std::vector<double> ()(double)>::~__func(_QWORD *a1)
{
  void *v2;

  *a1 = &off_1E453B100;
  v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void std::__function::__func<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0,std::allocator<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0>,std::vector<double> ()(double)>::~__func(_QWORD *a1)
{
  void *v2;

  *a1 = &off_1E453B100;
  v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  JUMPOUT(0x1A1B0A898);
}

_QWORD *std::__function::__func<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0,std::allocator<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0>,std::vector<double> ()(double)>::__clone(uint64_t a1)
{
  _QWORD *v2;

  v2 = operator new(0x28uLL);
  *v2 = &off_1E453B100;
  v2[2] = 0;
  v2[3] = 0;
  v2[1] = 0;
  std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>(v2 + 1, *(const void **)(a1 + 8), *(_QWORD *)(a1 + 16), (uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8)) >> 3);
  v2[4] = *(_QWORD *)(a1 + 32);
  return v2;
}

void sub_1A14DC18C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__function::__func<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0,std::allocator<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0>,std::vector<double> ()(double)>::__clone(uint64_t a1, _QWORD *a2)
{
  _QWORD *result;

  *a2 = &off_1E453B100;
  a2[2] = 0;
  a2[3] = 0;
  a2[1] = 0;
  result = std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>(a2 + 1, *(const void **)(a1 + 8), *(_QWORD *)(a1 + 16), (uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8)) >> 3);
  a2[4] = *(_QWORD *)(a1 + 32);
  return result;
}

void std::__function::__func<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0,std::allocator<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0>,std::vector<double> ()(double)>::destroy(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(_QWORD *)(a1 + 16) = v2;
    operator delete(v2);
  }
}

void std::__function::__func<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0,std::allocator<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0>,std::vector<double> ()(double)>::destroy_deallocate(_QWORD *__p)
{
  void *v2;

  v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }
  operator delete(__p);
}

_QWORD *std::__function::__func<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0,std::allocator<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0>,std::vector<double> ()(double)>::operator()@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>(a2, *(const void **)(a1 + 8), *(_QWORD *)(a1 + 16), (uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8)) >> 3);
}

uint64_t std::__function::__func<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0,std::allocator<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0>,std::vector<double> ()(double)>::target(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"Z13polynomialFitPKdS0_mmS0_S0_S0_E3$_0"))
    return a1 + 8;
  else
    return 0;
}

void *std::__function::__func<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0,std::allocator<polynomialFit(double const*,double const*,unsigned long,unsigned long,double const*,double const*,double const*)::$_0>,std::vector<double> ()(double)>::target_type()
{
}

void sub_1A14DC52C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14DC714(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1A14DC94C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14DCBD8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A14DCDD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;

  v15 = v14;

  _Unwind_Resume(a1);
}

void ctrTrackerInitialization_freeContext(void *a1)
{
  uint64_t i;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  void *v11;

  if (a1)
  {
    if (*(_QWORD *)a1)
    {
      for (i = 2048; i != 2112; i += 16)
      {
        free(*(void **)(*(_QWORD *)a1 + i));
        free(*(void **)(*(_QWORD *)a1 + i + 8));
      }
      free(*(void **)(*(_QWORD *)a1 + 2112));
      free(*(void **)(*(_QWORD *)a1 + 2120));
      v3 = *(void **)a1;
    }
    else
    {
      v3 = 0;
    }
    free(v3);
    v4 = *((_QWORD *)a1 + 2);
    if (v4)
    {
      free(*(void **)(v4 + 245992));
      free(*(void **)(*((_QWORD *)a1 + 2) + 246000));
      free(*(void **)(*((_QWORD *)a1 + 2) + 246008));
      free(*(void **)(*((_QWORD *)a1 + 2) + 246016));
      v5 = 4;
      v6 = 245936;
      do
      {
        free(*(void **)(*((_QWORD *)a1 + 2) + v6 - 8));
        free(*(void **)(*((_QWORD *)a1 + 2) + v6));
        v6 += 16;
        --v5;
      }
      while (v5);
      v7 = 246032;
      v8 = 3;
      do
      {
        free(*(void **)(*((_QWORD *)a1 + 2) + v7 - 8));
        free(*(void **)(*((_QWORD *)a1 + 2) + v7));
        v7 += 16;
        --v8;
      }
      while (v8);
      vDSP_destroy_fftsetup(*(FFTSetup *)(*((_QWORD *)a1 + 2) + 250200));
      v9 = (void *)*((_QWORD *)a1 + 2);
    }
    else
    {
      v9 = 0;
    }
    free(v9);
    v10 = *((_QWORD *)a1 + 4);
    if (v10)
    {
      free(*(void **)(v10 + 65632));
      free(*(void **)(*((_QWORD *)a1 + 4) + 65640));
      v11 = (void *)*((_QWORD *)a1 + 4);
    }
    else
    {
      v11 = 0;
    }
    free(v11);
    free(*((void **)a1 + 1));
    tplTrackerResampler_free((void ***)a1 + 3);
    free(a1);
  }
}

void sub_1A14DD06C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14DD0FC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14DD204(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14DD300(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14DD688(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, uint64_t a13, void *a14, void *a15, void *a16, void *a17, void *a18)
{
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

void sub_1A14DD840(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14DDB28(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14DDD40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, void *a20)
{
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  uint64_t v24;

  _Block_object_dispose((const void *)(v24 - 152), 8);
  _Block_object_dispose((const void *)(v24 - 120), 8);

  _Unwind_Resume(a1);
}

void sub_1A14DDE94(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14DE248(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32)
{
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  uint64_t v36;

  *(_QWORD *)(v36 - 112) = &a13;
  std::vector<std::pair<std::string,float>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v36 - 112));

  _Block_object_dispose(&a26, 8);
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table((uint64_t)&a32);

  _Unwind_Resume(a1);
}

void sub_1A14DE618(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42)
{
  void *v42;
  void *v43;
  void *v44;
  uint64_t v45;

  _Block_object_dispose(&a36, 8);
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table((uint64_t)&a42);
  _Block_object_dispose((const void *)(v45 - 192), 8);
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table(v45 - 144);

  _Unwind_Resume(a1);
}

void sub_1A14DE904(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void sub_1A14DE9B0()
{
  JUMPOUT(0x1A14DE9A4);
}

void sub_1A14DEE7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18)
{
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__20660(uint64_t a1, uint64_t a2)
{
  return std::__hash_table<std::__hash_value_type<NSString * {__strong},__CVBuffer *>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},__CVBuffer *>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},__CVBuffer *>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},__CVBuffer *>>>::__hash_table(a1 + 48, (uint64_t *)(a2 + 48));
}

uint64_t __Block_byref_object_dispose__20661(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table(a1 + 48);
}

void sub_1A14DF46C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  void *v14;
  void *v15;

  a9 = (void **)&a14;
  std::vector<std::pair<std::string,float>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void vision::mod::ImageClassifierAbstract::classifyDescriptors(vision::mod::ImageClassifierAbstract *this, const vision::mod::ImageDescriptorBufferAbstract *a2, _QWORD *a3, int a4)
{
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  int v11;
  float v12;
  unint64_t v13;
  float v14;
  float v15;
  __int128 *v16;
  int64x2_t *i;
  int64x2_t *v18;
  __int32 v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  _QWORD *exception;
  __int128 v24;
  uint64_t v25;
  __int128 v26;
  uint64_t v27;
  _OWORD v28[2];
  int v29;
  int64x2_t v30;
  uint64_t v31;
  std::__shared_weak_count *v32;
  int64x2_t *v33;
  std::__shared_weak_count *v34;
  void **v35;

  (*(void (**)(int64x2_t **__return_ptr, const vision::mod::ImageDescriptorBufferAbstract *))(*(_QWORD *)a2 + 24))(&v33, a2);
  (*(void (**)(uint64_t *__return_ptr))(v33->i64[0] + 64))(&v31);
  v8 = v34;
  if (v34)
  {
    p_shared_owners = (unint64_t *)&v34->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  vision::mod::ImageClassifierAbstract::classifyDescriptorsNoComulative(&v30, a2, a3, a4);
  memset(v28, 0, sizeof(v28));
  v29 = 1065353216;
  v26 = 0uLL;
  v27 = 0;
  v11 = *((_DWORD *)a2 + 24);
  if (v11 == 1)
  {
    v14 = *((float *)a2 + 25);
    v15 = *((float *)a2 + 26);
    ImageClassifier_getBatchCumulativeLabels((uint64_t)&v33, v30.i64, *((_DWORD *)a2 + 28));
    ImageClassifier_getLabelsAuto((uint64_t *)&v24, v35, v28, v14, v15);
  }
  else
  {
    if (v11)
    {
      exception = __cxa_allocate_exception(8uLL);
      *exception = 3955;
      __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
    }
    v12 = *((float *)a2 + 25);
    v13 = *((int *)a2 + 27);
    ImageClassifier_getBatchCumulativeLabels((uint64_t)&v33, v30.i64, *((_DWORD *)a2 + 28));
    ImageClassifier_getLabels((uint64_t *)&v24, v35, v28, v13, v12);
  }
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__deallocate_node(v35);
  v16 = (__int128 *)v33;
  v33 = 0;
  if (v16)
    operator delete(v16);
  std::vector<std::pair<std::string,float>>::__vdeallocate((uint64_t *)&v26);
  v26 = v24;
  v27 = v25;
  v25 = 0;
  v24 = 0uLL;
  v33 = (int64x2_t *)&v24;
  std::vector<std::pair<std::string,float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v33);
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_DWORD *)this + 8) = 1065353216;
  v18 = (int64x2_t *)*((_QWORD *)&v26 + 1);
  for (i = (int64x2_t *)v26; i != v18; i += 2)
  {
    v19 = i[1].i32[2];
    v33 = i;
    *((_DWORD *)std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)this, (unsigned __int8 *)i, (__int128 **)&v33)+ 10) = v19;
  }
  v33 = (int64x2_t *)&v26;
  std::vector<std::pair<std::string,float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v33);
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__deallocate_node(0);
  v33 = &v30;
  std::vector<std::unordered_map<std::string,float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v33);
  v20 = v32;
  if (v32)
  {
    v21 = (unint64_t *)&v32->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
}

void sub_1A14DF754(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, void **a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  uint64_t v23;

  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table(v23 - 104);
  a9 = (void **)&a13;
  std::vector<std::pair<std::string,float>>::__destroy_vector::operator()[abi:ne180100](&a9);
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table((uint64_t)&a17);
  a17 = (void **)&a23;
  std::vector<std::unordered_map<std::string,float>>::__destroy_vector::operator()[abi:ne180100](&a17);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](v23 - 120);
  _Unwind_Resume(a1);
}

void vision::mod::ImageClassifierAbstract::classifyDescriptorsNoComulative(int64x2_t *this, const vision::mod::ImageDescriptorBufferAbstract *a2, _QWORD *a3, int a4)
{
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  void *v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  void *v21;
  uint64_t *v22;
  uint64_t *v23;
  int64x2_t v24;
  unint64_t v25;
  void *v26;
  void *v27;
  std::__shared_weak_count *v28;
  unint64_t *p_shared_owners;
  unint64_t v30;
  void *v31[2];
  void *v32[2];
  int v33;
  void *v34[2];
  void *v35;
  int v36;
  uint64_t v37;
  std::__shared_weak_count *v38;
  void *__p;
  void *v40[2];
  unint64_t v41;
  int64x2_t *v42;

  (*(void (**)(void **__return_ptr, const vision::mod::ImageDescriptorBufferAbstract *))(*(_QWORD *)a2 + 24))(&__p, a2);
  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)__p + 64))(&v37);
  v8 = (std::__shared_weak_count *)v40[0];
  if (v40[0])
  {
    v9 = (unint64_t *)((char *)v40[0] + 8);
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  this->i64[0] = 0;
  this->i64[1] = 0;
  this[1].i64[0] = 0;
  if (a3[9])
  {
    v11 = 0;
    do
    {
      (*(void (**)(_QWORD *, uint64_t, unint64_t))(*a3 + 112))(a3, v37, v11);
      (*(void (**)(void **__return_ptr, const vision::mod::ImageDescriptorBufferAbstract *, uint64_t))(*(_QWORD *)a2 + 56))(v34, a2, v37);
      *(_OWORD *)v31 = 0u;
      *(_OWORD *)v32 = 0u;
      v33 = 1065353216;
      if (a4)
      {
        vision::mod::ImageClassifierAbstract::ImageClassifier_filterdisallowedListedLabels((uint64_t)&__p, (uint64_t)a2, (uint64_t)v34);
        std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__move_assign((uint64_t)v31, (uint64_t *)&__p);
        std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__deallocate_node((void **)v40[1]);
        v12 = __p;
        __p = 0;
        if (v12)
          operator delete(v12);
      }
      else
      {
        v33 = v36;
        std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<std::string,float>,void *> *>>(v31, (uint64_t *)v35);
      }
      v14 = this->u64[1];
      v13 = this[1].u64[0];
      if (v14 >= v13)
      {
        v16 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v14 - this->i64[0]) >> 3);
        v17 = v16 + 1;
        if (v16 + 1 > 0x666666666666666)
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        v18 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v13 - this->i64[0]) >> 3);
        if (2 * v18 > v17)
          v17 = 2 * v18;
        if (v18 >= 0x333333333333333)
          v19 = 0x666666666666666;
        else
          v19 = v17;
        v42 = this + 1;
        if (v19)
          v19 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unordered_map<std::string,float>>>(v19);
        else
          v20 = 0;
        __p = (void *)v19;
        v40[0] = (void *)(v19 + 40 * v16);
        v40[1] = v40[0];
        v41 = v19 + 40 * v20;
        std::unordered_map<std::string,float>::unordered_map((uint64_t)v40[0], (uint64_t)v31);
        v21 = v40[0];
        v15 = (char *)v40[1] + 40;
        v40[1] = (char *)v40[1] + 40;
        v23 = (uint64_t *)this->i64[0];
        v22 = (uint64_t *)this->i64[1];
        if (v22 == (uint64_t *)this->i64[0])
        {
          v24 = vdupq_n_s64((unint64_t)v22);
        }
        else
        {
          do
          {
            v22 -= 5;
            v21 = (void *)std::__hash_table<std::__hash_value_type<NSString * {__strong},__CVBuffer *>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},__CVBuffer *>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},__CVBuffer *>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},__CVBuffer *>>>::__hash_table((uint64_t)v21 - 40, v22);
          }
          while (v22 != v23);
          v24 = *this;
          v15 = (char *)v40[1];
        }
        this->i64[0] = (uint64_t)v21;
        this->i64[1] = (uint64_t)v15;
        *(int64x2_t *)v40 = v24;
        v25 = this[1].u64[0];
        this[1].i64[0] = v41;
        v41 = v25;
        __p = (void *)v24.i64[0];
        std::__split_buffer<std::unordered_map<std::string,float>>::~__split_buffer((uint64_t)&__p);
      }
      else
      {
        std::unordered_map<std::string,float>::unordered_map(this->i64[1], (uint64_t)v31);
        v15 = (char *)(v14 + 40);
        this->i64[1] = v14 + 40;
      }
      this->i64[1] = (uint64_t)v15;
      std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__deallocate_node((void **)v32[0]);
      v26 = v31[0];
      v31[0] = 0;
      if (v26)
        operator delete(v26);
      std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__deallocate_node((void **)v35);
      v27 = v34[0];
      v34[0] = 0;
      if (v27)
        operator delete(v27);
      ++v11;
    }
    while (a3[9] > v11);
  }
  v28 = v38;
  if (v38)
  {
    p_shared_owners = (unint64_t *)&v38->__shared_owners_;
    do
      v30 = __ldaxr(p_shared_owners);
    while (__stlxr(v30 - 1, p_shared_owners));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
}

void sub_1A14DFACC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_list va;

  va_start(va, a14);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::unordered_map<std::string,float>::unordered_map(uint64_t a1, uint64_t a2)
{
  unsigned __int8 *i;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>>>::__rehash<true>(a1, *(_QWORD *)(a2 + 8));
  for (i = *(unsigned __int8 **)(a2 + 16); i; i = *(unsigned __int8 **)i)
    std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,float> const&>(a1, i + 16, (uint64_t)(i + 16));
  return a1;
}

void sub_1A14DFB98(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<std::unordered_map<std::string,float>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 40;
    std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table(i - 40);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void sub_1A14E045C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33)
{
  void *v33;
  void *v34;
  uint64_t v35;
  void *v37;

  if (__p)
    operator delete(__p);

  v37 = *(void **)(v35 - 144);
  if (v37)
  {
    *(_QWORD *)(v35 - 136) = v37;
    operator delete(v37);
  }
  _Unwind_Resume(a1);
}

void sub_1A14E065C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20)
{
  void *v20;

  vision::mod::ImageDescriptorAugmenterAbstract::~ImageDescriptorAugmenterAbstract((vision::mod::ImageDescriptorAugmenterAbstract *)&a9);

  _Unwind_Resume(a1);
}

_QWORD *std::vector<vImage_Buffer>::__init_with_size[abi:ne180100]<vImage_Buffer*,vImage_Buffer*>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<vImage_Buffer>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1A14E06E0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *__copy_helper_block_ea8_56c55_ZTSNSt3__16vectorI13vImage_BufferNS_9allocatorIS1_EEEE(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;

  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  v2 = (_QWORD *)(a1 + 56);
  v2[2] = 0;
  return std::vector<vImage_Buffer>::__init_with_size[abi:ne180100]<vImage_Buffer*,vImage_Buffer*>(v2, *(const void **)(a2 + 56), *(_QWORD *)(a2 + 64), (uint64_t)(*(_QWORD *)(a2 + 64) - *(_QWORD *)(a2 + 56)) >> 5);
}

void __destroy_helper_block_ea8_56c55_ZTSNSt3__16vectorI13vImage_BufferNS_9allocatorIS1_EEEE(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 56);
  if (v2)
  {
    *(_QWORD *)(a1 + 64) = v2;
    operator delete(v2);
  }
}

void sub_1A14E07FC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14E08A0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14E0900(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1A14E09CC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14E0A90(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14E0CB8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<int,ObservedParabola>,std::__map_value_compare<int,std::__value_type<int,ObservedParabola>,std::less<int>,true>,std::allocator<std::__value_type<int,ObservedParabola>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<int,ObservedParabola>,std::__map_value_compare<int,std::__value_type<int,ObservedParabola>,std::less<int>,true>,std::allocator<std::__value_type<int,ObservedParabola>>>::destroy(*a1);
    std::__tree<std::__value_type<int,ObservedParabola>,std::__map_value_compare<int,std::__value_type<int,ObservedParabola>,std::less<int>,true>,std::allocator<std::__value_type<int,ObservedParabola>>>::destroy(a1[1]);
    std::__destroy_at[abi:ne180100]<std::pair<int const,ObservedParabola>,0>((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void std::__tree<std::__value_type<int,InternalObservedParabola>,std::__map_value_compare<int,std::__value_type<int,InternalObservedParabola>,std::less<int>,true>,std::allocator<std::__value_type<int,InternalObservedParabola>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<int,InternalObservedParabola>,std::__map_value_compare<int,std::__value_type<int,InternalObservedParabola>,std::less<int>,true>,std::allocator<std::__value_type<int,InternalObservedParabola>>>::destroy(*a1);
    std::__tree<std::__value_type<int,InternalObservedParabola>,std::__map_value_compare<int,std::__value_type<int,InternalObservedParabola>,std::less<int>,true>,std::allocator<std::__value_type<int,InternalObservedParabola>>>::destroy(a1[1]);
    InternalObservedParabola::~InternalObservedParabola((InternalObservedParabola *)(a1 + 6));
    operator delete(a1);
  }
}

void InternalObservedParabola::~InternalObservedParabola(InternalObservedParabola *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;

  v2 = (void *)*((_QWORD *)this + 91);
  if (v2)
  {
    *((_QWORD *)this + 92) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 85);
  if (v3)
  {
    *((_QWORD *)this + 86) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 82);
  if (v4)
  {
    *((_QWORD *)this + 83) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 13);
  if (v5)
  {
    *((_QWORD *)this + 14) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 10);
  if (v6)
  {
    *((_QWORD *)this + 11) = v6;
    operator delete(v6);
  }
  v7 = (void *)*((_QWORD *)this + 7);
  if (v7)
  {
    *((_QWORD *)this + 8) = v7;
    operator delete(v7);
  }
  v8 = (void *)*((_QWORD *)this + 1);
  if (v8)
  {
    *((_QWORD *)this + 2) = v8;
    operator delete(v8);
  }

}

void std::__destroy_at[abi:ne180100]<std::pair<int const,ObservedParabola>,0>(uint64_t a1)
{
  void *v2;
  void *v3;

  v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(_QWORD *)(a1 + 56) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 24);
  if (v3)
  {
    *(_QWORD *)(a1 + 32) = v3;
    operator delete(v3);
  }

}

BOOL sortPointsByXThenY(double *a1, double *a2)
{
  if (*a1 > *a2)
    return 1;
  if (*a1 == *a2)
    return a1[1] > a2[1];
  return 0;
}

double *sanitize(double **a1, __int128 **a2, int a3, int a4)
{
  __int128 *v8;
  __int128 *v9;
  unint64_t v10;
  uint64_t v11;
  __int128 *v12;
  __int128 *v13;
  double *result;
  unint64_t v15;
  double *v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  __int128 v22;
  __int128 v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  _OWORD *v29;
  __int128 v30;
  __int128 v31;
  unint64_t v32;
  __int128 v33;
  __int128 v34;
  double *v35;
  BOOL (*v37)(double *, double *);

  v8 = *a2;
  v9 = a2[1];
  v10 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * (v9 - v8));
  v37 = sortPointsByXThenY;
  if (v9 == v8)
    v11 = 0;
  else
    v11 = v10;
  std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*,false>(v8, v9, (unsigned int (**)(__int128 *, __int128 *))&v37, v11, 1);
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v12 = *a2;
  v13 = a2[1];
  result = (double *)operator new(0x30uLL);
  v15 = (unint64_t)((char *)v13 - (char *)v12) >> 4;
  v16 = result + 6;
  v17 = *(v13 - 3);
  v18 = *(v13 - 1);
  *((_OWORD *)result + 1) = *(v13 - 2);
  *((_OWORD *)result + 2) = v18;
  *(_OWORD *)result = v17;
  *a1 = result;
  a1[1] = result + 6;
  a1[2] = result + 6;
  v19 = (-1431655765 * v15 - 2);
  if ((v19 & 0x80000000) == 0)
  {
    do
    {
      v20 = (uint64_t)&(*a2)[3 * v19];
      if (vabdd_f64(*(double *)v20, *(v16 - 6)) > (double)a3
        || vabdd_f64(*(double *)(v20 + 8), *(v16 - 5)) > (double)a4)
      {
        v21 = (unint64_t)a1[2];
        if ((unint64_t)v16 >= v21)
        {
          v24 = 0xAAAAAAAAAAAAAAABLL * (((char *)v16 - (char *)result) >> 4);
          v25 = v24 + 1;
          if (v24 + 1 > 0x555555555555555)
            std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
          v26 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v21 - (_QWORD)result) >> 4);
          if (2 * v26 > v25)
            v25 = 2 * v26;
          if (v26 >= 0x2AAAAAAAAAAAAAALL)
            v27 = 0x555555555555555;
          else
            v27 = v25;
          if (v27)
          {
            v27 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<std::string,std::vector<BOOL>>>>(v27);
            result = *a1;
          }
          else
          {
            v28 = 0;
          }
          v29 = (_OWORD *)(v27 + 48 * v24);
          v30 = *(_OWORD *)v20;
          v31 = *(_OWORD *)(v20 + 32);
          v29[1] = *(_OWORD *)(v20 + 16);
          v29[2] = v31;
          *v29 = v30;
          if (v16 == result)
          {
            v35 = (double *)(v27 + 48 * v24);
          }
          else
          {
            v32 = v27 + 48 * v24;
            do
            {
              v33 = *((_OWORD *)v16 - 3);
              v34 = *((_OWORD *)v16 - 2);
              v35 = (double *)(v32 - 48);
              *(_OWORD *)(v32 - 20) = *(_OWORD *)((char *)v16 - 20);
              *(_OWORD *)(v32 - 48) = v33;
              *(_OWORD *)(v32 - 32) = v34;
              v16 -= 6;
              v32 -= 48;
            }
            while (v16 != result);
          }
          v16 = (double *)(v29 + 3);
          *a1 = v35;
          a1[1] = (double *)(v29 + 3);
          a1[2] = (double *)(v27 + 48 * v28);
          if (result)
          {
            operator delete(result);
            result = *a1;
          }
          else
          {
            result = v35;
          }
        }
        else
        {
          v22 = *(_OWORD *)v20;
          v23 = *(_OWORD *)(v20 + 32);
          *((_OWORD *)v16 + 1) = *(_OWORD *)(v20 + 16);
          *((_OWORD *)v16 + 2) = v23;
          *(_OWORD *)v16 = v22;
          v16 += 6;
        }
        a1[1] = v16;
      }
    }
    while (v19-- > 0);
  }
  return result;
}

void sub_1A14E13C4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*,false>(__int128 *a1, __int128 *a2, unsigned int (**a3)(__int128 *, __int128 *), uint64_t a4, char a5)
{
  __int128 *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  __int128 *v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  unsigned int (*v21)(__int128 *, __int128 *);
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 *v28;
  __int128 *v29;
  uint64_t (*v30)(__int128 *, __int128 *);
  __int128 v31;
  __int128 v32;
  __int128 *v33;
  __int128 *v34;
  __int128 *v35;
  unsigned int (*v36)(__int128 *, __int128 *);
  __int128 v37;
  __int128 v38;
  unsigned int v39;
  __int128 *v40;
  unsigned int (*v41)(__int128 *, __int128 *);
  __int128 v42;
  __int128 v43;
  char v44;
  __int128 *v45;
  __int128 *v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  uint64_t (*v52)(__int128 *, __int128 *);
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  unsigned int (*v58)(__int128 *, __int128 *);
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  BOOL v63;
  BOOL v64;
  __int128 v65;
  __int128 v66;
  uint64_t (*v67)(__int128 *, __int128 *);
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 *v72;
  unsigned int (*v73)(__int128 *, __int128 *);
  __int128 v74;
  __int128 v75;
  char v76;
  __int128 *v77;
  unsigned int (*v78)(__int128 *, __int128 *);
  __int128 v79;
  __int128 v80;
  unsigned int v81;
  __int128 *v82;
  __int128 *v83;
  unsigned int (*v84)(__int128 *, __int128 *);
  __int128 v85;
  __int128 v86;
  char v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  unsigned int (*v97)(__int128 *, __int128 *);
  __int128 v98;
  __int128 v99;
  __int128 v100;
  unsigned int (*v101)(__int128 *, __int128 *);
  __int128 *v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  unsigned int (*v107)(__int128 *, __int128 *);
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 *v118;
  BOOL v120;
  __int128 *v121;
  uint64_t v122;
  __int128 *v123;
  __int128 *v124;
  unsigned int (*v125)(__int128 *, __int128 *);
  __int128 v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  uint64_t v132;
  _OWORD *v133;
  __int128 v134;
  uint64_t (*v135)(__int128 *, __int128 *);
  __int128 v136;
  __int128 v137;
  __int128 *v138;
  __int128 v139;
  __int128 v140;
  int64_t v141;
  int64_t v142;
  uint64_t v143;
  __int128 *v144;
  unsigned int (*v145)(__int128 *, __int128 *);
  __int128 v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  __int128 *v150;
  uint64_t (*v151)(__int128 *, __int128 *);
  __int128 v152;
  __int128 v153;
  __int128 v154;
  __int128 v155;
  __int128 v156;
  __int128 v157;
  __int128 *v158;
  __int128 v159;
  __int128 v160;
  uint64_t v161;
  unsigned int (*v162)(__int128 *, __int128 *);
  __int128 v163;
  __int128 v164;
  __int128 v165;
  __int128 v166;
  unsigned int (*v167)(__int128 *, __int128 *);
  __int128 v168;
  __int128 v169;
  __int128 v170;
  __int128 v171;
  int64_t v172;
  __int128 *v173;
  uint64_t v174;
  __int128 v175;
  __int128 v176;
  uint64_t v177;
  uint64_t v178;
  __int128 *v179;
  __int128 *v180;
  uint64_t v181;
  uint64_t v182;
  unsigned int (*v183)(__int128 *, __int128 *);
  __int128 v184;
  __int128 v185;
  __int128 v186;
  __int128 v187;
  __int128 v188;
  __int128 v189;
  __int128 v190;
  __int128 v191;
  __int128 v192;
  __int128 v193;
  uint64_t v194;
  unint64_t v195;
  __int128 *v196;
  unsigned int (*v197)(__int128 *, __int128 *);
  __int128 v198;
  __int128 v199;
  __int128 v200;
  __int128 v201;
  __int128 v202;
  __int128 v203;
  __int128 *v204;
  __int128 v205;
  __int128 v206;
  uint64_t (*v207)(__int128 *, __int128 *);
  __int128 v208;
  __int128 v209;
  __int128 v210;
  __int128 v211;
  __int128 v212;
  __int128 v213;
  __int128 *v215;
  unsigned int (*v216)(__int128 *, __int128 *);
  __int128 v217;
  __int128 v218;
  __int128 v219;
  __int128 v220;
  __int128 v221;
  __int128 v222;
  __int128 *v223;
  __int128 *v224;
  __int128 v225;
  unsigned int (*v226)(__int128 *, __int128 *);
  __int128 v227;
  __int128 v228;
  char v229;
  __int128 v230;
  __int128 v231;
  __int128 *v232;
  __int128 *v233;
  __int128 *v235;
  __int128 *v236;
  __int128 *v237;
  int64_t v238;
  _OWORD v239[3];
  _OWORD v240[3];
  _OWORD v241[3];
  _OWORD v242[3];
  _OWORD v243[3];
  _OWORD v244[3];
  __int128 v245;
  __int128 v246;
  __int128 v247;
  __int128 v248;
  __int128 v249;
  __int128 v250;
  __int128 v251;
  __int128 v252;
  __int128 v253;
  __int128 v254;
  __int128 v255;
  __int128 v256;
  __int128 v257;
  _BYTE v258[32];
  __int128 v259;
  _BYTE v260[32];
  __int128 v261;
  __int128 v262;
  __int128 v263;
  __int128 v264;
  _BYTE v265[32];
  __int128 v266;
  _BYTE v267[32];
  __int128 v268;
  _BYTE v269[32];

double std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*>(_OWORD *a1, _OWORD *a2, _OWORD *a3, unsigned int (**a4)(_QWORD, _QWORD))
{
  unsigned int (*v8)(_QWORD, _QWORD);
  __int128 v9;
  __int128 v10;
  char v11;
  unsigned int (*v12)(_QWORD, _QWORD);
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  double result;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  unsigned int (*v28)(_QWORD, _QWORD);
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  unsigned int (*v43)(_QWORD, _QWORD);
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  _OWORD v51[3];
  _OWORD v52[3];
  _OWORD v53[3];
  _OWORD v54[3];
  _OWORD v55[3];
  _OWORD v56[3];
  _OWORD v57[3];
  _OWORD v58[3];
  _OWORD v59[3];
  _OWORD v60[3];
  _BYTE v61[32];

  v8 = *a4;
  v9 = a2[1];
  v60[0] = *a2;
  v60[1] = v9;
  v60[2] = a2[2];
  v10 = a1[1];
  v59[0] = *a1;
  v59[1] = v10;
  v59[2] = a1[2];
  v11 = v8(v60, v59);
  v12 = *a4;
  if ((v11 & 1) != 0)
  {
    v13 = a3[1];
    v54[0] = *a3;
    v54[1] = v13;
    v54[2] = a3[2];
    v14 = a2[1];
    v53[0] = *a2;
    v53[1] = v14;
    v53[2] = a2[2];
    if (v12(v54, v53))
    {
      v16 = a1[1];
      v15 = a1[2];
      v17 = *a1;
      *(_OWORD *)v61 = v16;
      *(_OWORD *)&v61[16] = v15;
      v18 = *(_OWORD *)((char *)a3 + 28);
      v19 = a3[1];
      *a1 = *a3;
      a1[1] = v19;
      *(_OWORD *)((char *)a1 + 28) = v18;
    }
    else
    {
      v38 = a1[2];
      v40 = *a1;
      *(_OWORD *)v61 = a1[1];
      v39 = *(_OWORD *)v61;
      *(_OWORD *)&v61[16] = v38;
      v41 = *(_OWORD *)((char *)a2 + 28);
      v42 = a2[1];
      *a1 = *a2;
      a1[1] = v42;
      *(_OWORD *)((char *)a1 + 28) = v41;
      *a2 = v40;
      a2[1] = v39;
      *(_OWORD *)((char *)a2 + 28) = *(_OWORD *)&v61[12];
      v43 = *a4;
      v44 = *a3;
      v45 = a3[2];
      v52[1] = a3[1];
      v52[2] = v45;
      v46 = *a2;
      v47 = a2[1];
      v51[2] = a2[2];
      v52[0] = v44;
      v51[0] = v46;
      v51[1] = v47;
      if (!v43(v52, v51))
        return result;
      v16 = a2[1];
      v48 = a2[2];
      v17 = *a2;
      *(_OWORD *)v61 = v16;
      *(_OWORD *)&v61[16] = v48;
      v49 = *(_OWORD *)((char *)a3 + 28);
      v50 = a3[1];
      *a2 = *a3;
      a2[1] = v50;
      *(_OWORD *)((char *)a2 + 28) = v49;
    }
    *a3 = v17;
    a3[1] = v16;
    result = *(double *)&v61[12];
    *(_OWORD *)((char *)a3 + 28) = *(_OWORD *)&v61[12];
  }
  else
  {
    v20 = a3[1];
    v58[0] = *a3;
    v58[1] = v20;
    v58[2] = a3[2];
    v21 = a2[1];
    v57[0] = *a2;
    v57[1] = v21;
    v57[2] = a2[2];
    if (v12(v58, v57))
    {
      v23 = a2[2];
      v25 = *a2;
      *(_OWORD *)v61 = a2[1];
      v24 = *(_OWORD *)v61;
      *(_OWORD *)&v61[16] = v23;
      v26 = *(_OWORD *)((char *)a3 + 28);
      v27 = a3[1];
      *a2 = *a3;
      a2[1] = v27;
      *(_OWORD *)((char *)a2 + 28) = v26;
      *a3 = v25;
      a3[1] = v24;
      *(_OWORD *)((char *)a3 + 28) = *(_OWORD *)&v61[12];
      v28 = *a4;
      v29 = *a2;
      v30 = a2[2];
      v56[1] = a2[1];
      v56[2] = v30;
      v31 = *a1;
      v32 = a1[1];
      v55[2] = a1[2];
      v56[0] = v29;
      v55[0] = v31;
      v55[1] = v32;
      if (v28(v56, v55))
      {
        v33 = a1[2];
        v35 = *a1;
        *(_OWORD *)v61 = a1[1];
        v34 = *(_OWORD *)v61;
        *(_OWORD *)&v61[16] = v33;
        v36 = *(_OWORD *)((char *)a2 + 28);
        v37 = a2[1];
        *a1 = *a2;
        a1[1] = v37;
        *(_OWORD *)((char *)a1 + 28) = v36;
        *a2 = v35;
        a2[1] = v34;
        result = *(double *)&v61[12];
        *(_OWORD *)((char *)a2 + 28) = *(_OWORD *)&v61[12];
      }
    }
  }
  return result;
}

double std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*>(__int128 *a1, __int128 *a2, __int128 *a3, __int128 *a4, unsigned int (**a5)(_QWORD, _QWORD))
{
  unsigned int (*v10)(_QWORD, _QWORD);
  __int128 v11;
  __int128 v12;
  double result;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  unsigned int (*v19)(_QWORD, _QWORD);
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  unsigned int (*v29)(_QWORD, _QWORD);
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  _OWORD v39[3];
  _OWORD v40[3];
  _OWORD v41[3];
  _OWORD v42[3];
  _OWORD v43[3];
  _OWORD v44[3];
  _BYTE v45[32];

  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*>(a1, a2, a3, a5);
  v10 = *a5;
  v11 = a4[1];
  v44[0] = *a4;
  v44[1] = v11;
  v44[2] = a4[2];
  v12 = a3[1];
  v43[0] = *a3;
  v43[1] = v12;
  v43[2] = a3[2];
  if (v10(v44, v43))
  {
    v14 = a3[2];
    v16 = *a3;
    *(_OWORD *)v45 = a3[1];
    v15 = *(_OWORD *)v45;
    *(_OWORD *)&v45[16] = v14;
    v17 = *(__int128 *)((char *)a4 + 28);
    v18 = a4[1];
    *a3 = *a4;
    a3[1] = v18;
    *(__int128 *)((char *)a3 + 28) = v17;
    *a4 = v16;
    a4[1] = v15;
    *(__int128 *)((char *)a4 + 28) = *(_OWORD *)&v45[12];
    v19 = *a5;
    v20 = *a3;
    v21 = a3[2];
    v42[1] = a3[1];
    v42[2] = v21;
    v22 = *a2;
    v23 = a2[1];
    v41[2] = a2[2];
    v42[0] = v20;
    v41[0] = v22;
    v41[1] = v23;
    if (v19(v42, v41))
    {
      v24 = a2[2];
      v26 = *a2;
      *(_OWORD *)v45 = a2[1];
      v25 = *(_OWORD *)v45;
      *(_OWORD *)&v45[16] = v24;
      v27 = *(__int128 *)((char *)a3 + 28);
      v28 = a3[1];
      *a2 = *a3;
      a2[1] = v28;
      *(__int128 *)((char *)a2 + 28) = v27;
      *a3 = v26;
      a3[1] = v25;
      *(__int128 *)((char *)a3 + 28) = *(_OWORD *)&v45[12];
      v29 = *a5;
      v30 = *a2;
      v31 = a2[2];
      v40[1] = a2[1];
      v40[2] = v31;
      v32 = *a1;
      v33 = a1[1];
      v39[2] = a1[2];
      v40[0] = v30;
      v39[0] = v32;
      v39[1] = v33;
      if (v29(v40, v39))
      {
        v34 = a1[2];
        v36 = *a1;
        *(_OWORD *)v45 = a1[1];
        v35 = *(_OWORD *)v45;
        *(_OWORD *)&v45[16] = v34;
        v37 = *(__int128 *)((char *)a2 + 28);
        v38 = a2[1];
        *a1 = *a2;
        a1[1] = v38;
        *(__int128 *)((char *)a1 + 28) = v37;
        *a2 = v36;
        a2[1] = v35;
        result = *(double *)&v45[12];
        *(__int128 *)((char *)a2 + 28) = *(_OWORD *)&v45[12];
      }
    }
  }
  return result;
}

double std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*>(__int128 *a1, __int128 *a2, __int128 *a3, __int128 *a4, __int128 *a5, unsigned int (**a6)(_QWORD, _QWORD))
{
  unsigned int (*v12)(_QWORD, _QWORD);
  __int128 v13;
  __int128 v14;
  double result;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  unsigned int (*v21)(_QWORD, _QWORD);
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  unsigned int (*v31)(_QWORD, _QWORD);
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  unsigned int (*v41)(_QWORD, _QWORD);
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  _OWORD v51[3];
  _OWORD v52[3];
  _OWORD v53[3];
  _OWORD v54[3];
  _OWORD v55[3];
  _OWORD v56[3];
  _OWORD v57[3];
  _OWORD v58[3];
  _BYTE v59[32];

  std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*>(a1, a2, a3, a4, a6);
  v12 = *a6;
  v13 = a5[1];
  v58[0] = *a5;
  v58[1] = v13;
  v58[2] = a5[2];
  v14 = a4[1];
  v57[0] = *a4;
  v57[1] = v14;
  v57[2] = a4[2];
  if (v12(v58, v57))
  {
    v16 = a4[2];
    v18 = *a4;
    *(_OWORD *)v59 = a4[1];
    v17 = *(_OWORD *)v59;
    *(_OWORD *)&v59[16] = v16;
    v19 = *(__int128 *)((char *)a5 + 28);
    v20 = a5[1];
    *a4 = *a5;
    a4[1] = v20;
    *(__int128 *)((char *)a4 + 28) = v19;
    *a5 = v18;
    a5[1] = v17;
    *(__int128 *)((char *)a5 + 28) = *(_OWORD *)&v59[12];
    v21 = *a6;
    v22 = *a4;
    v23 = a4[2];
    v56[1] = a4[1];
    v56[2] = v23;
    v24 = *a3;
    v25 = a3[1];
    v55[2] = a3[2];
    v56[0] = v22;
    v55[0] = v24;
    v55[1] = v25;
    if (v21(v56, v55))
    {
      v26 = a3[2];
      v28 = *a3;
      *(_OWORD *)v59 = a3[1];
      v27 = *(_OWORD *)v59;
      *(_OWORD *)&v59[16] = v26;
      v29 = *(__int128 *)((char *)a4 + 28);
      v30 = a4[1];
      *a3 = *a4;
      a3[1] = v30;
      *(__int128 *)((char *)a3 + 28) = v29;
      *a4 = v28;
      a4[1] = v27;
      *(__int128 *)((char *)a4 + 28) = *(_OWORD *)&v59[12];
      v31 = *a6;
      v32 = *a3;
      v33 = a3[2];
      v54[1] = a3[1];
      v54[2] = v33;
      v34 = *a2;
      v35 = a2[1];
      v53[2] = a2[2];
      v54[0] = v32;
      v53[0] = v34;
      v53[1] = v35;
      if (v31(v54, v53))
      {
        v36 = a2[2];
        v38 = *a2;
        *(_OWORD *)v59 = a2[1];
        v37 = *(_OWORD *)v59;
        *(_OWORD *)&v59[16] = v36;
        v39 = *(__int128 *)((char *)a3 + 28);
        v40 = a3[1];
        *a2 = *a3;
        a2[1] = v40;
        *(__int128 *)((char *)a2 + 28) = v39;
        *a3 = v38;
        a3[1] = v37;
        *(__int128 *)((char *)a3 + 28) = *(_OWORD *)&v59[12];
        v41 = *a6;
        v42 = *a2;
        v43 = a2[2];
        v52[1] = a2[1];
        v52[2] = v43;
        v44 = *a1;
        v45 = a1[1];
        v51[2] = a1[2];
        v52[0] = v42;
        v51[0] = v44;
        v51[1] = v45;
        if (v41(v52, v51))
        {
          v46 = a1[2];
          v48 = *a1;
          *(_OWORD *)v59 = a1[1];
          v47 = *(_OWORD *)v59;
          *(_OWORD *)&v59[16] = v46;
          v49 = *(__int128 *)((char *)a2 + 28);
          v50 = a2[1];
          *a1 = *a2;
          a1[1] = v50;
          *(__int128 *)((char *)a1 + 28) = v49;
          *a2 = v48;
          a2[1] = v47;
          result = *(double *)&v59[12];
          *(__int128 *)((char *)a2 + 28) = *(_OWORD *)&v59[12];
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*>(__int128 *a1, __int128 *a2, unsigned int (**a3)(_QWORD, _QWORD))
{
  unint64_t v6;
  _BOOL8 result;
  unsigned int (*v8)(_QWORD, _QWORD);
  __int128 v9;
  __int128 v10;
  __int128 *v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 *v17;
  __int128 *v18;
  uint64_t v19;
  int v20;
  unsigned int (*v21)(_QWORD, _QWORD);
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;
  _OWORD *v27;
  __int128 v28;
  unsigned int (*v29)(_QWORD, _QWORD);
  __int128 v30;
  __int128 *v31;
  __int128 v32;
  _OWORD v33[3];
  _OWORD v34[3];
  _OWORD v35[3];
  _OWORD v36[3];
  _OWORD v37[3];
  _OWORD v38[3];
  __int128 v39;
  _BYTE v40[32];

  v6 = 0xAAAAAAAAAAAAAAABLL * (a2 - a1);
  result = 1;
  switch(v6)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      v8 = *a3;
      v9 = *(a2 - 2);
      v38[0] = *(a2 - 3);
      v38[1] = v9;
      v38[2] = *(a2 - 1);
      v10 = a1[1];
      v37[0] = *a1;
      v37[1] = v10;
      v37[2] = a1[2];
      if (v8(v38, v37))
      {
        v11 = a2 - 3;
        v12 = a1[2];
        v14 = *a1;
        *(_OWORD *)v40 = a1[1];
        v13 = *(_OWORD *)v40;
        *(_OWORD *)&v40[16] = v12;
        v15 = *(__int128 *)((char *)a2 - 20);
        v16 = *(a2 - 2);
        *a1 = *(a2 - 3);
        a1[1] = v16;
        *(__int128 *)((char *)a1 + 28) = v15;
        *v11 = v14;
        v11[1] = v13;
        *(__int128 *)((char *)v11 + 28) = *(_OWORD *)&v40[12];
      }
      return 1;
    case 3uLL:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*>(a1, a1 + 3, a2 - 3, a3);
      return 1;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*>(a1, a1 + 3, a1 + 6, a2 - 3, a3);
      return 1;
    case 5uLL:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*>(a1, a1 + 3, a1 + 6, a1 + 9, a2 - 3, a3);
      return 1;
    default:
      v17 = a1 + 6;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGPointWithPts,CGPointWithPts),CGPointWithPts*>(a1, a1 + 3, a1 + 6, a3);
      v18 = a1 + 9;
      if (a1 + 9 == a2)
        return 1;
      v19 = 0;
      v20 = 0;
      break;
  }
  while (1)
  {
    v21 = *a3;
    v22 = v18[1];
    v36[0] = *v18;
    v36[1] = v22;
    v36[2] = v18[2];
    v23 = *v17;
    v24 = v17[2];
    v35[1] = v17[1];
    v35[2] = v24;
    v35[0] = v23;
    if (v21(v36, v35))
    {
      v25 = v18[1];
      v39 = *v18;
      *(_OWORD *)v40 = v25;
      *(_OWORD *)&v40[16] = v18[2];
      v26 = v19;
      while (1)
      {
        v27 = (__int128 *)((char *)a1 + v26);
        v28 = *(__int128 *)((char *)a1 + v26 + 112);
        v27[9] = *(__int128 *)((char *)a1 + v26 + 96);
        v27[10] = v28;
        *(_OWORD *)((char *)v27 + 172) = *(__int128 *)((char *)a1 + v26 + 124);
        if (v26 == -96)
          break;
        v29 = *a3;
        v34[0] = v39;
        v34[1] = *(_OWORD *)v40;
        v34[2] = *(_OWORD *)&v40[16];
        v30 = v27[4];
        v33[0] = v27[3];
        v33[1] = v30;
        v33[2] = v27[5];
        v26 -= 48;
        if ((((uint64_t (*)(_OWORD *, _OWORD *))v29)(v34, v33) & 1) == 0)
        {
          v31 = (__int128 *)((char *)a1 + v26 + 144);
          goto LABEL_12;
        }
      }
      v31 = a1;
LABEL_12:
      v32 = *(_OWORD *)v40;
      *v31 = v39;
      v31[1] = v32;
      *(__int128 *)((char *)v31 + 28) = *(_OWORD *)&v40[12];
      if (++v20 == 8)
        return v18 + 3 == a2;
    }
    v17 = v18;
    v19 += 48;
    v18 += 3;
    if (v18 == a2)
      return 1;
  }
}

void sanitizeAllFrames(void **a1, _QWORD *a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  uint64_t v7;
  double *v10;
  double v11;
  double v12;
  double v13;
  double v14;
  __int128 v15;
  uint64_t v16;
  unint64_t v17;
  _QWORD *v18;
  unint64_t v19;
  unint64_t v20;
  double *v21;
  int v22;
  unint64_t v23;
  double *v24;
  __int128 v25;
  double *v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  __int128 v33;
  unint64_t v34;
  __int128 v35;
  __int128 v36;
  unint64_t v37;
  double *v38;
  double *v39;
  uint64_t v40;
  __int128 v41;
  __int128 v42;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a3 != a4)
  {
    v7 = a3;
    v10 = 0;
    v11 = (double)a5;
    v12 = (double)a6;
    while (1)
    {
      v14 = *(double *)v7;
      v13 = *(double *)(v7 + 8);
      v15 = *(_OWORD *)(v7 + 32);
      v41 = *(_OWORD *)(v7 + 16);
      v42 = v15;
      v16 = a2[1];
      if (a2[2] != v16)
        break;
LABEL_17:
      v24 = (double *)a1[2];
      if (v10 >= v24)
      {
        v26 = (double *)*a1;
        v27 = 0xAAAAAAAAAAAAAAABLL * (((char *)v10 - (_BYTE *)*a1) >> 4);
        v28 = v27 + 1;
        if (v27 + 1 > 0x555555555555555)
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        v29 = 0xAAAAAAAAAAAAAAABLL * (((char *)v24 - (char *)v26) >> 4);
        if (2 * v29 > v28)
          v28 = 2 * v29;
        if (v29 >= 0x2AAAAAAAAAAAAAALL)
          v30 = 0x555555555555555;
        else
          v30 = v28;
        if (v30)
          v30 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<std::string,std::vector<BOOL>>>>(v30);
        else
          v31 = 0;
        v32 = v30 + 48 * v27;
        *(double *)v32 = v14;
        *(double *)(v32 + 8) = v13;
        v33 = v42;
        *(_OWORD *)(v32 + 16) = v41;
        *(_OWORD *)(v32 + 32) = v33;
        if (v10 == v26)
        {
          v37 = v30 + 48 * v27;
        }
        else
        {
          v34 = v30 + 48 * v27;
          do
          {
            v35 = *((_OWORD *)v10 - 3);
            v36 = *((_OWORD *)v10 - 2);
            v37 = v34 - 48;
            *(_OWORD *)(v34 - 20) = *(_OWORD *)((char *)v10 - 20);
            *(_OWORD *)(v34 - 48) = v35;
            *(_OWORD *)(v34 - 32) = v36;
            v10 -= 6;
            v34 -= 48;
          }
          while (v10 != v26);
        }
        v10 = (double *)(v32 + 48);
        *a1 = (void *)v37;
        a1[1] = (void *)(v32 + 48);
        a1[2] = (void *)(v30 + 48 * v31);
        if (v26)
          operator delete(v26);
      }
      else
      {
        *v10 = v14;
        v10[1] = v13;
        v25 = v42;
        *((_OWORD *)v10 + 1) = v41;
        *((_OWORD *)v10 + 2) = v25;
        v10 += 6;
      }
      a1[1] = v10;
LABEL_36:
      v7 += 48;
      if (v7 == a4)
        return;
    }
    v17 = a2[4];
    v18 = (_QWORD *)(v16 + 8 * (v17 / 0xAA));
    v19 = *v18 + 24 * (v17 % 0xAA);
    v20 = *(_QWORD *)(v16 + 8 * ((a2[5] + v17) / 0xAA)) + 24 * ((a2[5] + v17) % 0xAA);
    while (1)
    {
      if (v19 == v20)
        goto LABEL_17;
      v38 = 0;
      v39 = 0;
      v40 = 0;
      std::vector<CGPointWithPts>::__init_with_size[abi:ne180100]<CGPointWithPts*,CGPointWithPts*>(&v38, *(const void **)v19, *(_QWORD *)(v19 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(v19 + 8) - *(_QWORD *)v19) >> 4));
      v21 = v38;
      if (v38 == v39)
        break;
      while (vabdd_f64(*v21, v14) >= v11 || vabdd_f64(v21[1], v13) >= v12)
      {
        v21 += 6;
        if (v21 == v39)
          goto LABEL_10;
      }
      v22 = 0;
      if (v38)
        goto LABEL_11;
LABEL_12:
      if (!v22)
        goto LABEL_36;
      v19 += 24;
      if (v19 - *v18 == 4080)
      {
        v23 = v18[1];
        ++v18;
        v19 = v23;
      }
    }
LABEL_10:
    v22 = 1;
    if (!v38)
      goto LABEL_12;
LABEL_11:
    operator delete(v38);
    goto LABEL_12;
  }
}

void sub_1A14E2A38(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v2;

  if (v2)
  {
    *(_QWORD *)(v1 + 8) = v2;
    operator delete(v2);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<CGPointWithPts>::__init_with_size[abi:ne180100]<CGPointWithPts*,CGPointWithPts*>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<CGPointWithPts>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8 - 4);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1A14E2AC0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<CGPointWithPts>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0x555555555555556)
    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<std::string,std::vector<BOOL>>>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[48 * v4];
  return result;
}

void sub_1A14E61B0(_Unwind_Exception *a1)
{
  void *v1;

  if (v1)
    operator delete(v1);
  _Unwind_Resume(a1);
}

char *std::vector<CGPointWithPts>::__assign_with_size[abi:ne180100]<CGPointWithPts*,CGPointWithPts*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  void **v13;
  char *v14;
  _BYTE *v15;
  char *v16;
  uint64_t v17;
  size_t v18;
  void *v19;
  char *v20;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - *(_QWORD *)result) >> 4) < a4)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 > 0x555555555555555)
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    v10 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 4);
    v11 = 2 * v10;
    if (2 * v10 <= a4)
      v11 = a4;
    if (v10 >= 0x2AAAAAAAAAAAAAALL)
      v12 = 0x555555555555555;
    else
      v12 = v11;
    result = std::vector<CGPointWithPts>::__vallocate[abi:ne180100](v7, v12);
    v14 = (char *)v7[1];
    v13 = (void **)(v7 + 1);
    v9 = v14;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v17 - 4;
      v19 = v9;
      v20 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v13 = (void **)(result + 8);
  v15 = (_BYTE *)*((_QWORD *)result + 1);
  if (0xAAAAAAAAAAAAAAABLL * ((v15 - v9) >> 4) >= a4)
    goto LABEL_16;
  v16 = &__src[16 * ((v15 - v9) >> 4)];
  if (v15 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v15 - v9 - 4);
    v9 = (char *)*v13;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v17 - 4;
    v19 = v9;
    v20 = v16;
LABEL_18:
    result = (char *)memmove(v19, v20, v18);
  }
LABEL_19:
  *v13 = &v9[v17];
  return result;
}

void sub_1A14E66F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  _Unwind_Resume(exception_object);
}

void InternalObservedParabola::InternalObservedParabola(InternalObservedParabola *this)
{
  __int128 v2;
  int v3;

  *(_OWORD *)((char *)this + 56) = 0u;
  *((_DWORD *)this + 12) = 0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *((_QWORD *)this + 15) = 0;
  v2 = *MEMORY[0x1E0C9D538];
  *((_OWORD *)this + 8) = xmmword_1A15FB610;
  *((_OWORD *)this + 9) = v2;
  *((_OWORD *)this + 11) = xmmword_1A15FB620;
  *((_DWORD *)this + 40) = 0;
  *((_OWORD *)this + 12) = xmmword_1A15FB630;
  *((_OWORD *)this + 13) = xmmword_1A15FB640;
  *((_OWORD *)this + 14) = xmmword_1A15FB650;
  *((_OWORD *)this + 15) = xmmword_1A15DFF10;
  *((_OWORD *)this + 16) = xmmword_1A15FB660;
  *((_OWORD *)this + 17) = xmmword_1A15FB640;
  *((_OWORD *)this + 18) = xmmword_1A15FB650;
  *((_OWORD *)this + 19) = xmmword_1A15DFF10;
  *((_OWORD *)this + 20) = xmmword_1A15FB660;
  *((_OWORD *)this + 21) = xmmword_1A15FB640;
  *((_OWORD *)this + 22) = xmmword_1A15FB650;
  *((_OWORD *)this + 23) = xmmword_1A15FB670;
  *((_OWORD *)this + 24) = xmmword_1A15FB680;
  *((_OWORD *)this + 25) = 0u;
  *((_OWORD *)this + 26) = 0u;
  *((_OWORD *)this + 27) = xmmword_1A15FB690;
  *((_OWORD *)this + 28) = xmmword_1A15FB6A0;
  *((_OWORD *)this + 29) = xmmword_1A15FB6B0;
  *((_OWORD *)this + 30) = xmmword_1A15FB6C0;
  *((_OWORD *)this + 31) = 0u;
  *((_OWORD *)this + 32) = 0u;
  *((_OWORD *)this + 33) = 0u;
  *((_OWORD *)this + 34) = 0u;
  *((_OWORD *)this + 35) = 0u;
  *((_OWORD *)this + 36) = xmmword_1A15DFF10;
  *((_OWORD *)this + 37) = xmmword_1A15FB660;
  *((_OWORD *)this + 38) = xmmword_1A15FB640;
  *((_OWORD *)this + 39) = xmmword_1A15FB650;
  *(_QWORD *)((char *)this + 717) = 0;
  *((_OWORD *)this + 43) = 0u;
  *((_OWORD *)this + 44) = 0u;
  *((_OWORD *)this + 41) = 0u;
  *((_OWORD *)this + 42) = 0u;
  *((_OWORD *)this + 40) = 0u;
  v3 = 0;
  std::vector<float>::vector((_QWORD *)this + 91, 4uLL, &v3);
  *((_QWORD *)this + 94) = 0;
}

void sub_1A14E6900(_Unwind_Exception *a1)
{
  uint64_t v1;
  KalmanFilter *v2;
  void **v3;
  void *v5;
  void *v6;
  void *v7;
  void *v8;

  KalmanFilter::~KalmanFilter(v2);
  v5 = *(void **)(v1 + 104);
  if (v5)
  {
    *(_QWORD *)(v1 + 112) = v5;
    operator delete(v5);
  }
  v6 = *(void **)(v1 + 80);
  if (v6)
  {
    *(_QWORD *)(v1 + 88) = v6;
    operator delete(v6);
  }
  v7 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 64) = v7;
    operator delete(v7);
  }
  v8 = *(void **)(v1 + 8);
  if (v8)
  {
    *(_QWORD *)(v1 + 16) = v8;
    operator delete(v8);
  }

  _Unwind_Resume(a1);
}

float32x4_t KalmanFilter::updateMeasurementAndPredict(KalmanFilter *this, CGPoint a2)
{
  double y;
  double x;
  unint64_t v5;
  CGPoint *v6;
  CGPoint *v7;
  CGPoint *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  BOOL v12;
  unint64_t v13;
  uint64_t v14;
  double *v15;
  unint64_t v16;
  uint64_t v17;
  __int128 v18;
  simd_float4 v19;
  double v20;
  double v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  int32x4_t v26;
  const float *v27;
  int32x4_t v28;
  int32x4_t v29;
  simd_float4 v30;
  uint64_t v31;
  int32x4_t v32;
  int32x4_t v33;
  int32x4_t v34;
  int32x4_t v35;
  int32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  uint64_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  uint64_t v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  int32x4_t v55;
  int32x4_t v56;
  int32x4_t v57;
  int32x4_t v58;
  int32x4_t v59;
  int32x4_t v60;
  int32x4_t v61;
  int32x4_t v62;
  uint64_t v63;
  float32x4_t v64;
  float32x4_t v65;
  simd_float4x4 v66;
  uint64_t v67;
  uint64_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  uint64_t v77;
  float32x4_t v78;
  float32x4_t v79;
  float32x4_t v80;
  float32x4_t v81;
  float v82;
  float v83;
  float v84;
  float v85;
  float32x4_t v86;
  float32x4_t v87;
  int32x4_t v88;
  int32x4_t v89;
  float32x4_t v90;
  int32x4_t v91;
  int32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t result;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  simd_float4 v103;
  simd_float4 v104;
  simd_float4 v105;
  simd_float4 v106;
  simd_float4 v107;
  simd_float4 v108;
  simd_float4 v109;
  simd_float4 v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4x4_t v120;
  simd_float4x4 v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  simd_float4x4 v126;
  float32x4x4_t v127;

  y = a2.y;
  x = a2.x;
  v6 = (CGPoint *)*((_QWORD *)this + 61);
  v5 = *((_QWORD *)this + 62);
  if ((unint64_t)v6 >= v5)
  {
    v8 = (CGPoint *)*((_QWORD *)this + 60);
    v9 = v6 - v8;
    v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 60)
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    v11 = v5 - (_QWORD)v8;
    if (v11 >> 3 > v10)
      v10 = v11 >> 3;
    v12 = (unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0;
    v13 = 0xFFFFFFFFFFFFFFFLL;
    if (!v12)
      v13 = v10;
    if (v13)
    {
      v13 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<vision::mod::DescriptorItemSideInfo>>(v13);
      v8 = (CGPoint *)*((_QWORD *)this + 60);
      v6 = (CGPoint *)*((_QWORD *)this + 61);
    }
    else
    {
      v14 = 0;
    }
    v15 = (double *)(v13 + 16 * v9);
    v16 = v13 + 16 * v14;
    *v15 = x;
    v15[1] = y;
    v7 = (CGPoint *)(v15 + 2);
    if (v6 != v8)
    {
      do
      {
        *((CGPoint *)v15 - 1) = v6[-1];
        v15 -= 2;
        --v6;
      }
      while (v6 != v8);
      v8 = (CGPoint *)*((_QWORD *)this + 60);
    }
    *((_QWORD *)this + 60) = v15;
    *((_QWORD *)this + 61) = v7;
    *((_QWORD *)this + 62) = v16;
    if (v8)
      operator delete(v8);
  }
  else
  {
    *v6 = a2;
    v7 = v6 + 1;
  }
  v17 = 0;
  *((_QWORD *)this + 61) = v7;
  v18 = *((_OWORD *)this + 20);
  v19 = *((simd_float4 *)this + 21);
  v20 = x - *(float *)&v18;
  *((double *)this + 66) = v20;
  v21 = y - *((float *)&v18 + 1);
  *((double *)this + 67) = v21;
  v23 = *(float32x4_t *)this;
  v22 = *((float32x4_t *)this + 1);
  v25 = *((float32x4_t *)this + 2);
  v24 = *((float32x4_t *)this + 3);
  v26 = vzip1q_s32(*(int32x4_t *)this, (int32x4_t)v25);
  v27 = (const float *)((char *)this + 64);
  v127 = vld4q_f32(v27);
  v120 = v127;
  v28 = vzip1q_s32((int32x4_t)v22, (int32x4_t)v24);
  v29 = vzip1q_s32(v26, v28);
  v119 = *((float32x4_t *)this + 29);
  v30 = *((simd_float4 *)this + 22);
  v127.val[0] = (float32x4_t)*((_OWORD *)this + 23);
  v127.val[1] = (float32x4_t)*((_OWORD *)this + 24);
  v121.columns[0] = v19;
  v121.columns[1] = v30;
  v121.columns[2] = (simd_float4)v127.val[0];
  v121.columns[3] = (simd_float4)v127.val[1];
  do
  {
    *(float32x4_t *)((char *)&v122 + v17 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v23, COERCE_FLOAT(*(_OWORD *)&v121.columns[v17])), v22, *(float32x2_t *)v121.columns[v17].f32, 1), v25, (float32x4_t)v121.columns[v17], 2), v24, (float32x4_t)v121.columns[v17], 3);
    ++v17;
  }
  while (v17 != 4);
  v31 = 0;
  v32 = vzip2q_s32((int32x4_t)v23, (int32x4_t)v25);
  v33 = vzip2q_s32((int32x4_t)v22, (int32x4_t)v24);
  v34 = vzip1q_s32(v32, v33);
  v35 = vzip2q_s32(v26, v28);
  v36 = vzip2q_s32(v32, v33);
  v37 = v122;
  v38 = v123;
  v39 = v124;
  v40 = v125;
  v121.columns[0] = (simd_float4)v29;
  v121.columns[1] = (simd_float4)v35;
  v115 = (float32x4_t)v35;
  v116 = (float32x4_t)v34;
  v121.columns[2] = (simd_float4)v34;
  v121.columns[3] = (simd_float4)v36;
  v117 = (float32x4_t)v36;
  do
  {
    *(float32x4_t *)((char *)&v122 + v31 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v37, COERCE_FLOAT(*(_OWORD *)&v121.columns[v31])), v38, *(float32x2_t *)v121.columns[v31].f32, 1), v39, (float32x4_t)v121.columns[v31], 2), v40, (float32x4_t)v121.columns[v31], 3);
    ++v31;
  }
  while (v31 != 4);
  v41 = 0;
  v42 = vaddq_f32(v122, *((float32x4_t *)this + 12));
  v43 = vaddq_f32(v123, *((float32x4_t *)this + 13));
  v44 = vaddq_f32(v124, *((float32x4_t *)this + 14));
  v45 = vaddq_f32(v125, *((float32x4_t *)this + 15));
  v46 = *((float32x4_t *)this + 8);
  v47 = *((float32x4_t *)this + 9);
  v48 = *((float32x4_t *)this + 10);
  v49 = *((float32x4_t *)this + 11);
  v121.columns[0] = (simd_float4)v42;
  v121.columns[1] = (simd_float4)v43;
  v121.columns[2] = (simd_float4)v44;
  v121.columns[3] = (simd_float4)v45;
  do
  {
    *(float32x4_t *)((char *)&v122 + v41 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v46, COERCE_FLOAT(*(_OWORD *)&v121.columns[v41])), v47, *(float32x2_t *)v121.columns[v41].f32, 1), v48, (float32x4_t)v121.columns[v41], 2), v49, (float32x4_t)v121.columns[v41], 3);
    ++v41;
  }
  while (v41 != 4);
  v50 = 0;
  v51 = v122;
  v52 = v123;
  v53 = v124;
  v54 = v125;
  v55 = vzip1q_s32((int32x4_t)v46, (int32x4_t)v48);
  v105 = (simd_float4)v49;
  v106 = (simd_float4)v48;
  v103 = (simd_float4)v47;
  v104 = (simd_float4)v46;
  v56 = vzip2q_s32((int32x4_t)v46, (int32x4_t)v48);
  v57 = vzip1q_s32((int32x4_t)v47, (int32x4_t)v49);
  v58 = vzip2q_s32((int32x4_t)v47, (int32x4_t)v49);
  v59 = vzip1q_s32(v55, v57);
  v60 = vzip2q_s32(v55, v57);
  v61 = vzip1q_s32(v56, v58);
  v62 = vzip2q_s32(v56, v58);
  v121.columns[0] = (simd_float4)v59;
  v121.columns[1] = (simd_float4)v60;
  v121.columns[2] = (simd_float4)v61;
  v121.columns[3] = (simd_float4)v62;
  do
  {
    *(float32x4_t *)((char *)&v122 + v50 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v51, COERCE_FLOAT(*(_OWORD *)&v121.columns[v50])), v52, *(float32x2_t *)v121.columns[v50].f32, 1), v53, (float32x4_t)v121.columns[v50], 2), v54, (float32x4_t)v121.columns[v50], 3);
    ++v50;
  }
  while (v50 != 4);
  v118 = (float32x4_t)v29;
  v63 = 0;
  v66.columns[2] = (simd_float4)v124;
  v66.columns[3] = (simd_float4)v125;
  v64 = *((float32x4_t *)this + 18);
  v65 = *((float32x4_t *)this + 19);
  v66.columns[0] = (simd_float4)vaddq_f32(v122, *((float32x4_t *)this + 16));
  v66.columns[1] = (simd_float4)vaddq_f32(v123, *((float32x4_t *)this + 17));
  v111 = (float32x4_t)v59;
  v112 = (float32x4_t)v60;
  v121.columns[0] = (simd_float4)v59;
  v121.columns[1] = (simd_float4)v60;
  v113 = (float32x4_t)v61;
  v114 = (float32x4_t)v62;
  v121.columns[2] = (simd_float4)v61;
  v121.columns[3] = (simd_float4)v62;
  do
  {
    *(float32x4_t *)((char *)&v122 + v63 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v42, COERCE_FLOAT(*(_OWORD *)&v121.columns[v63])), v43, *(float32x2_t *)v121.columns[v63].f32, 1), v44, (float32x4_t)v121.columns[v63], 2), v45, (float32x4_t)v121.columns[v63], 3);
    ++v63;
  }
  while (v63 != 4);
  v107 = (simd_float4)v45;
  v108 = (simd_float4)v44;
  v109 = (simd_float4)v43;
  v110 = (simd_float4)v42;
  v66.columns[2] = (simd_float4)vaddq_f32((float32x4_t)v66.columns[2], v64);
  v66.columns[3] = (simd_float4)vaddq_f32((float32x4_t)v66.columns[3], v65);
  v101 = v122;
  v102 = v123;
  v99 = v125;
  v100 = v124;
  v126 = __invert_f4(v66);
  v67 = 0;
  v121 = v126;
  do
  {
    *(float32x4_t *)((char *)&v122 + v67 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v101, COERCE_FLOAT(*(_OWORD *)&v121.columns[v67])), v102, *(float32x2_t *)v121.columns[v67].f32, 1), v100, (float32x4_t)v121.columns[v67], 2), v99, (float32x4_t)v121.columns[v67], 3);
    ++v67;
  }
  while (v67 != 4);
  v68 = 0;
  v69 = v122;
  v70 = v123;
  v71 = v124;
  v72 = v125;
  v73 = *((float32x4_t *)this + 25);
  v74 = *((float32x4_t *)this + 26);
  v75 = *((float32x4_t *)this + 27);
  v76 = *((float32x4_t *)this + 28);
  v121.columns[0] = v104;
  v121.columns[1] = v103;
  v121.columns[2] = v106;
  v121.columns[3] = v105;
  do
  {
    *(float32x4_t *)((char *)&v122 + v68 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v69, COERCE_FLOAT(*(_OWORD *)&v121.columns[v68])), v70, *(float32x2_t *)v121.columns[v68].f32, 1), v71, (float32x4_t)v121.columns[v68], 2), v72, (float32x4_t)v121.columns[v68], 3);
    ++v68;
  }
  while (v68 != 4);
  v77 = 0;
  v78 = vsubq_f32(v73, v122);
  v79 = vsubq_f32(v74, v123);
  v80 = vsubq_f32(v75, v124);
  v81 = vsubq_f32(v76, v125);
  v121.columns[0] = v110;
  v121.columns[1] = v109;
  v121.columns[2] = v108;
  v121.columns[3] = v107;
  do
  {
    *(float32x4_t *)((char *)&v122 + v77 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v78, COERCE_FLOAT(*(_OWORD *)&v121.columns[v77])), v79, *(float32x2_t *)v121.columns[v77].f32, 1), v80, (float32x4_t)v121.columns[v77], 2), v81, (float32x4_t)v121.columns[v77], 3);
    ++v77;
  }
  while (v77 != 4);
  v82 = x;
  v83 = y;
  v84 = v20;
  v85 = v21;
  v86.i64[0] = __PAIR64__(LODWORD(v83), LODWORD(v82));
  v86.i64[1] = __PAIR64__(LODWORD(v85), LODWORD(v84));
  v87 = vaddq_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v118, v82), v115, v83), v116, v84), v117, v85), vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v120.val[0], v119.f32[0]), v120.val[1], *(float32x2_t *)v119.f32, 1), v120.val[2], v119, 2), v120.val[3], v119, 3));
  v88 = vzip2q_s32((int32x4_t)v69, (int32x4_t)v71);
  v89 = vzip2q_s32((int32x4_t)v70, (int32x4_t)v72);
  v90 = vsubq_f32(v86, vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v111, v87.f32[0]), v112, *(float32x2_t *)v87.f32, 1), v113, v87, 2), v114, v87, 3));
  v91 = vzip1q_s32((int32x4_t)v69, (int32x4_t)v71);
  v92 = vzip1q_s32((int32x4_t)v70, (int32x4_t)v72);
  v93 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)vzip1q_s32(v91, v92), v90.f32[0]), (float32x4_t)vzip2q_s32(v91, v92), *(float32x2_t *)v90.f32, 1), (float32x4_t)vzip1q_s32(v88, v89), v90, 2), (float32x4_t)vzip2q_s32(v88, v89), v90, 3);
  v94 = v122;
  v95 = v123;
  v96 = v124;
  v97 = v125;
  result = vaddq_f32(v87, v93);
  *((float32x4_t *)this + 20) = result;
  *((float32x4_t *)this + 21) = v94;
  *((float32x4_t *)this + 22) = v95;
  *((float32x4_t *)this + 23) = v96;
  *((float32x4_t *)this + 24) = v97;
  return result;
}

uint64_t *std::__tree<std::__value_type<int,InternalObservedParabola>,std::__map_value_compare<int,std::__value_type<int,InternalObservedParabola>,std::less<int>,true>,std::allocator<std::__value_type<int,InternalObservedParabola>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t **a1, int a2, _DWORD *a3)
{
  uint64_t *v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t *v8;
  int v9;
  _DWORD *v10;
  uint64_t *v11;
  uint64_t v13[2];
  char v14;

  v6 = (uint64_t)(a1 + 1);
  v5 = a1[1];
  v7 = (uint64_t *)(a1 + 1);
  v8 = (uint64_t *)(a1 + 1);
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v8 = v5;
        v9 = *((_DWORD *)v5 + 8);
        if (v9 <= a2)
          break;
        v5 = (uint64_t *)*v8;
        v7 = v8;
        if (!*v8)
          goto LABEL_8;
      }
      if (v9 >= a2)
        break;
      v5 = (uint64_t *)v8[1];
      if (!v5)
      {
        v7 = v8 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    v10 = operator new(0x330uLL);
    v13[0] = (uint64_t)v10;
    v13[1] = v6;
    v14 = 0;
    v10[8] = *a3;
    bzero(v10 + 12, 0x300uLL);
    InternalObservedParabola::InternalObservedParabola((InternalObservedParabola *)(v10 + 12));
    v14 = 1;
    *(_QWORD *)v10 = 0;
    *((_QWORD *)v10 + 1) = 0;
    *((_QWORD *)v10 + 2) = v8;
    *v7 = (uint64_t)v10;
    v11 = (uint64_t *)**a1;
    if (v11)
    {
      *a1 = v11;
      v10 = (_DWORD *)*v7;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], (uint64_t *)v10);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    v8 = (uint64_t *)v13[0];
    v13[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<int,InternalObservedParabola>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<int,InternalObservedParabola>,void *>>>>::reset[abi:ne180100](v13);
  }
  return v8;
}

void sub_1A14E70B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__tree_node<std::__value_type<int,InternalObservedParabola>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<int,InternalObservedParabola>,void *>>>>::reset[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t InternalObservedParabola::operator=(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  int v7;
  __int128 v8;
  __int128 v9;
  int v10;

  objc_storeStrong((id *)a1, *(id *)a2);
  if (a1 == a2)
  {
    v8 = *(_OWORD *)(a2 + 128);
    v9 = *(_OWORD *)(a2 + 144);
    *(_DWORD *)(a1 + 160) = *(_DWORD *)(a2 + 160);
    *(_OWORD *)(a1 + 128) = v8;
    *(_OWORD *)(a1 + 144) = v9;
    memcpy((void *)(a1 + 176), (const void *)(a2 + 176), 0x1E0uLL);
    *(_OWORD *)(a1 + 704) = *(_OWORD *)(a2 + 704);
    v10 = *(_DWORD *)(a2 + 720);
    *(_BYTE *)(a1 + 724) = *(_BYTE *)(a2 + 724);
    *(_DWORD *)(a1 + 720) = v10;
  }
  else
  {
    std::vector<CGPointWithPts>::__assign_with_size[abi:ne180100]<CGPointWithPts*,CGPointWithPts*>((char *)(a1 + 8), *(char **)(a2 + 8), *(_QWORD *)(a2 + 16), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8)) >> 4));
    v4 = *(_OWORD *)(a2 + 32);
    *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = v4;
    std::vector<CGPointWithPts>::__assign_with_size[abi:ne180100]<CGPointWithPts*,CGPointWithPts*>((char *)(a1 + 56), *(char **)(a2 + 56), *(_QWORD *)(a2 + 64), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a2 + 64) - *(_QWORD *)(a2 + 56)) >> 4));
    std::vector<long long>::__assign_with_size[abi:ne180100]<long long *,long long *>((char *)(a1 + 80), *(char **)(a2 + 80), *(_QWORD *)(a2 + 88), (uint64_t)(*(_QWORD *)(a2 + 88) - *(_QWORD *)(a2 + 80)) >> 3);
    std::vector<long long>::__assign_with_size[abi:ne180100]<long long *,long long *>((char *)(a1 + 104), *(char **)(a2 + 104), *(_QWORD *)(a2 + 112), (uint64_t)(*(_QWORD *)(a2 + 112) - *(_QWORD *)(a2 + 104)) >> 3);
    v5 = *(_OWORD *)(a2 + 128);
    v6 = *(_OWORD *)(a2 + 144);
    *(_DWORD *)(a1 + 160) = *(_DWORD *)(a2 + 160);
    *(_OWORD *)(a1 + 128) = v5;
    *(_OWORD *)(a1 + 144) = v6;
    memcpy((void *)(a1 + 176), (const void *)(a2 + 176), 0x1E0uLL);
    std::vector<CGPoint>::__assign_with_size[abi:ne180100]<CGPoint*,CGPoint*>((char *)(a1 + 656), *(char **)(a2 + 656), *(_QWORD *)(a2 + 664), (uint64_t)(*(_QWORD *)(a2 + 664) - *(_QWORD *)(a2 + 656)) >> 4);
    std::vector<CGPoint>::__assign_with_size[abi:ne180100]<CGPoint*,CGPoint*>((char *)(a1 + 680), *(char **)(a2 + 680), *(_QWORD *)(a2 + 688), (uint64_t)(*(_QWORD *)(a2 + 688) - *(_QWORD *)(a2 + 680)) >> 4);
    *(_OWORD *)(a1 + 704) = *(_OWORD *)(a2 + 704);
    v7 = *(_DWORD *)(a2 + 720);
    *(_BYTE *)(a1 + 724) = *(_BYTE *)(a2 + 724);
    *(_DWORD *)(a1 + 720) = v7;
    std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)(a1 + 728), *(char **)(a2 + 728), *(_QWORD *)(a2 + 736), (uint64_t)(*(_QWORD *)(a2 + 736) - *(_QWORD *)(a2 + 728)) >> 2);
  }
  *(_QWORD *)(a1 + 752) = *(_QWORD *)(a2 + 752);
  return a1;
}

char *std::vector<CGPoint>::__assign_with_size[abi:ne180100]<CGPoint*,CGPoint*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 4)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 60)
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 3;
    if (v8 >> 3 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0)
      v11 = 0xFFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<vision::mod::DescriptorItemSideInfo>::__vallocate[abi:ne180100](v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 4;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[16 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

void std::unique_ptr<std::__tree_node<std::__value_type<int,InternalObservedParabola>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<int,InternalObservedParabola>,void *>>>>::reset[abi:ne180100](uint64_t *a1)
{
  uint64_t v1;

  v1 = *a1;
  *a1 = 0;
  if (v1)
  {
    if (*((_BYTE *)a1 + 16))
      InternalObservedParabola::~InternalObservedParabola((InternalObservedParabola *)(v1 + 48));
    operator delete((void *)v1);
  }
}

void KalmanFilter::~KalmanFilter(KalmanFilter *this)
{
  void *v2;
  void *v3;

  v2 = (void *)*((_QWORD *)this + 63);
  if (v2)
  {
    *((_QWORD *)this + 64) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 60);
  if (v3)
  {
    *((_QWORD *)this + 61) = v3;
    operator delete(v3);
  }
}

void std::unique_ptr<std::__tree_node<std::__value_type<int,ObservedParabola>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<int,ObservedParabola>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<int const,ObservedParabola>,0>((uint64_t)v1 + 32);
    operator delete(v1);
  }
}

_QWORD *std::vector<double>::vector(_QWORD *a1, unint64_t a2, _QWORD *a3)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<long long>::__vallocate[abi:ne180100](a1, a2);
    v6 = (_QWORD *)a1[1];
    v7 = &v6[a2];
    v8 = 8 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 8;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_1A14E7468(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::deque<std::vector<CGPointWithPts>>::push_back(_QWORD *a1, uint64_t a2)
{
  char *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  int64_t v21;
  char *v22;
  uint64_t v23;
  char *v24;
  char *v25;
  uint64_t v26;
  void *v27;
  void *v28;
  unint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  __int128 v34;
  void *v35;
  __int128 v36;
  uint64_t v37;
  __int128 v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  char *v42;
  uint64_t v43;
  char *v44;
  uint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  char *v48;
  uint64_t v49;
  char *v50;
  unint64_t v51;
  uint64_t v52;
  char *v53;
  uint64_t v54;
  uint64_t *v55;
  char *v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  uint64_t v60;
  char *v61;
  char *v62;
  char *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  char *v71;
  int64_t v72;
  uint64_t v73;
  unint64_t v74;
  char *v75;
  uint64_t v76;
  uint64_t i;
  _QWORD *v78;
  char *v79;
  _BYTE *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  unint64_t v85;
  char *v86;
  uint64_t v87;
  char *v88;
  uint64_t v89;
  uint64_t v90;
  char *v91;
  uint64_t *v92;
  uint64_t v93;
  uint64_t v94;
  char *v95;
  _QWORD *v96;
  _QWORD *result;
  unint64_t v98;
  char *v99;
  uint64_t v100;
  char *v101;
  uint64_t *v102;
  uint64_t v103;
  uint64_t v104;
  char *v105;
  uint64_t v106;
  char *v107;
  __int128 v108;
  __int128 v109;
  uint64_t v110;
  __int128 v111;
  uint64_t v112;
  __int128 v113;

  v4 = (char *)a1[2];
  v5 = (char *)a1[1];
  v6 = v4 - v5;
  if (v4 == v5)
    v7 = 0;
  else
    v7 = 170 * ((v4 - v5) >> 3) - 1;
  v8 = a1[4];
  v9 = a1[5] + v8;
  if (v7 == v9)
  {
    if (v8 >= 0xAA)
    {
      a1[4] = v8 - 170;
      v12 = *(_QWORD *)v5;
      v10 = v5 + 8;
      v11 = v12;
      a1[1] = v10;
      if ((char *)a1[3] == v4)
      {
        v13 = (uint64_t)&v10[-*a1];
        if ((unint64_t)v10 <= *a1)
        {
          if (v4 == (char *)*a1)
            v41 = 1;
          else
            v41 = (uint64_t)&v4[-*a1] >> 2;
          v42 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v41);
          v44 = &v42[8 * (v41 >> 2)];
          v45 = (uint64_t *)a1[1];
          v4 = v44;
          v46 = a1[2] - (_QWORD)v45;
          if (v46)
          {
            v4 = &v44[v46 & 0xFFFFFFFFFFFFFFF8];
            v47 = 8 * (v46 >> 3);
            v48 = &v42[8 * (v41 >> 2)];
            do
            {
              v49 = *v45++;
              *(_QWORD *)v48 = v49;
              v48 += 8;
              v47 -= 8;
            }
            while (v47);
          }
          v50 = (char *)*a1;
          *a1 = v42;
          a1[1] = v44;
          a1[2] = v4;
          a1[3] = &v42[8 * v43];
          if (v50)
          {
            operator delete(v50);
            v4 = (char *)a1[2];
          }
        }
        else
        {
          v14 = v13 >> 3;
          v15 = v13 >> 3 < -1;
          v16 = (v13 >> 3) + 2;
          if (v15)
            v17 = v16;
          else
            v17 = v14 + 1;
          v18 = -(v17 >> 1);
          v19 = v17 >> 1;
          v20 = &v10[-8 * v19];
          v21 = v4 - v10;
          if (v4 == v10)
          {
            v22 = v4;
          }
          else
          {
            memmove(&v10[-8 * v19], v10, v4 - v10);
            v22 = (char *)a1[1];
          }
          v4 = &v20[v21];
          a1[1] = &v22[8 * v18];
          a1[2] = &v20[v21];
        }
      }
      *(_QWORD *)v4 = v11;
LABEL_82:
      a1[2] += 8;
LABEL_83:
      v5 = (char *)a1[1];
      v9 = a1[5] + a1[4];
      goto LABEL_84;
    }
    v23 = v6 >> 3;
    v24 = (char *)a1[3];
    v25 = (char *)*a1;
    v26 = (uint64_t)&v24[-*a1];
    if (v6 >> 3 < (unint64_t)(v26 >> 3))
    {
      v27 = operator new(0xFF0uLL);
      v28 = v27;
      if (v24 == v4)
      {
        if (v25 == v5)
        {
          if (v4 == v5)
            v51 = 1;
          else
            v51 = v26 >> 2;
          v52 = 2 * v51;
          v53 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v51);
          v5 = &v53[(v52 + 6) & 0xFFFFFFFFFFFFFFF8];
          v55 = (uint64_t *)a1[1];
          v56 = v5;
          v57 = a1[2] - (_QWORD)v55;
          if (v57)
          {
            v56 = &v5[v57 & 0xFFFFFFFFFFFFFFF8];
            v58 = 8 * (v57 >> 3);
            v59 = v5;
            do
            {
              v60 = *v55++;
              *(_QWORD *)v59 = v60;
              v59 += 8;
              v58 -= 8;
            }
            while (v58);
          }
          v61 = (char *)*a1;
          *a1 = v53;
          a1[1] = v5;
          a1[2] = v56;
          a1[3] = &v53[8 * v54];
          if (v61)
          {
            operator delete(v61);
            v5 = (char *)a1[1];
          }
        }
        *((_QWORD *)v5 - 1) = v28;
        v62 = (char *)a1[1];
        v63 = (char *)a1[2];
        a1[1] = v62 - 8;
        v64 = *((_QWORD *)v62 - 1);
        a1[1] = v62;
        if (v63 == (char *)a1[3])
        {
          v65 = (uint64_t)&v62[-*a1];
          if ((unint64_t)v62 <= *a1)
          {
            if (v63 == (char *)*a1)
              v98 = 1;
            else
              v98 = (uint64_t)&v63[-*a1] >> 2;
            v99 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v98);
            v101 = &v99[8 * (v98 >> 2)];
            v102 = (uint64_t *)a1[1];
            v63 = v101;
            v103 = a1[2] - (_QWORD)v102;
            if (v103)
            {
              v63 = &v101[v103 & 0xFFFFFFFFFFFFFFF8];
              v104 = 8 * (v103 >> 3);
              v105 = &v99[8 * (v98 >> 2)];
              do
              {
                v106 = *v102++;
                *(_QWORD *)v105 = v106;
                v105 += 8;
                v104 -= 8;
              }
              while (v104);
            }
            v107 = (char *)*a1;
            *a1 = v99;
            a1[1] = v101;
            a1[2] = v63;
            a1[3] = &v99[8 * v100];
            if (v107)
            {
              operator delete(v107);
              v63 = (char *)a1[2];
            }
          }
          else
          {
            v66 = v65 >> 3;
            v15 = v65 >> 3 < -1;
            v67 = (v65 >> 3) + 2;
            if (v15)
              v68 = v67;
            else
              v68 = v66 + 1;
            v69 = -(v68 >> 1);
            v70 = v68 >> 1;
            v71 = &v62[-8 * v70];
            v72 = v63 - v62;
            if (v63 != v62)
            {
              memmove(&v62[-8 * v70], v62, v63 - v62);
              v62 = (char *)a1[1];
            }
            v63 = &v71[v72];
            a1[1] = &v62[8 * v69];
            a1[2] = &v71[v72];
          }
        }
        *(_QWORD *)v63 = v64;
      }
      else
      {
        *(_QWORD *)v4 = v27;
      }
      goto LABEL_82;
    }
    if (v24 == v25)
      v29 = 1;
    else
      v29 = v26 >> 2;
    v30 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v29);
    v32 = v31;
    v33 = &v30[8 * v23];
    *(_QWORD *)&v34 = v30;
    *((_QWORD *)&v34 + 1) = v33;
    v111 = v34;
    v35 = operator new(0xFF0uLL);
    *(_QWORD *)&v36 = v33;
    *((_QWORD *)&v36 + 1) = &v30[8 * v32];
    if (v23 == v32)
    {
      v37 = 8 * v23;
      *(_QWORD *)&v38 = v111;
      if (v6 >= 1)
      {
        v39 = v37 >> 3;
        if (v39 >= -1)
          v40 = v39 + 1;
        else
          v40 = v39 + 2;
        v33 -= 8 * (v40 >> 1);
        *(_QWORD *)&v36 = v33;
        *((_QWORD *)&v38 + 1) = v33;
        goto LABEL_56;
      }
      v73 = v37 >> 2;
      if (v4 == v5)
        v74 = 1;
      else
        v74 = v73;
      v75 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v74);
      v33 = &v75[8 * (v74 >> 2)];
      *(_QWORD *)&v38 = v75;
      *((_QWORD *)&v38 + 1) = v33;
      *(_QWORD *)&v36 = v33;
      *((_QWORD *)&v36 + 1) = &v75[8 * v76];
      if (!v30)
        goto LABEL_56;
      v108 = v36;
      v111 = v38;
      operator delete(v30);
      v36 = v108;
    }
    v38 = v111;
LABEL_56:
    *(_QWORD *)v33 = v35;
    *(_QWORD *)&v36 = v36 + 8;
    for (i = a1[2]; i != a1[1]; i -= 8)
    {
      v78 = (_QWORD *)*((_QWORD *)&v38 + 1);
      if (*((_QWORD *)&v38 + 1) == (_QWORD)v38)
      {
        v80 = (_BYTE *)v36;
        if ((unint64_t)v36 >= *((_QWORD *)&v36 + 1))
        {
          if (*((_QWORD *)&v36 + 1) == *((_QWORD *)&v38 + 1))
            v85 = 1;
          else
            v85 = (uint64_t)(*((_QWORD *)&v36 + 1) - *((_QWORD *)&v38 + 1)) >> 2;
          v86 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v85);
          v79 = &v86[(2 * v85 + 6) & 0xFFFFFFFFFFFFFFF8];
          v88 = v79;
          v89 = v80 - (_BYTE *)v78;
          if (v80 != (_BYTE *)v78)
          {
            v88 = &v79[v89 & 0xFFFFFFFFFFFFFFF8];
            v90 = 8 * (v89 >> 3);
            v91 = v79;
            v92 = v78;
            do
            {
              v93 = *v92++;
              *(_QWORD *)v91 = v93;
              v91 += 8;
              v90 -= 8;
            }
            while (v90);
          }
          *(_QWORD *)&v38 = v86;
          *((_QWORD *)&v38 + 1) = v79;
          *(_QWORD *)&v36 = v88;
          *((_QWORD *)&v36 + 1) = &v86[8 * v87];
          if (v78)
          {
            v109 = v36;
            v113 = v38;
            operator delete(v78);
            v36 = v109;
            v38 = v113;
          }
        }
        else
        {
          v81 = (uint64_t)(*((_QWORD *)&v36 + 1) - v36) >> 3;
          if (v81 >= -1)
            v82 = v81 + 1;
          else
            v82 = v81 + 2;
          v83 = v82 >> 1;
          v84 = v36 + 8 * (v82 >> 1);
          v79 = (char *)(v84 - (v36 - *((_QWORD *)&v38 + 1)));
          if ((_QWORD)v36 == *((_QWORD *)&v38 + 1))
          {
            v80 = (_BYTE *)*((_QWORD *)&v38 + 1);
          }
          else
          {
            v110 = *((_QWORD *)&v36 + 1);
            v112 = v38;
            memmove((void *)(v84 - (v36 - *((_QWORD *)&v38 + 1))), *((const void **)&v38 + 1), v36 - *((_QWORD *)&v38 + 1));
            *((_QWORD *)&v36 + 1) = v110;
            *(_QWORD *)&v38 = v112;
          }
          *((_QWORD *)&v38 + 1) = v79;
          *(_QWORD *)&v36 = &v80[8 * v83];
        }
      }
      else
      {
        v79 = (char *)*((_QWORD *)&v38 + 1);
      }
      v94 = *(_QWORD *)(i - 8);
      *((_QWORD *)v79 - 1) = v94;
      *((_QWORD *)&v38 + 1) -= 8;
    }
    v95 = (char *)*a1;
    *(_OWORD *)a1 = v38;
    *((_OWORD *)a1 + 1) = v36;
    if (v95)
      operator delete(v95);
    goto LABEL_83;
  }
LABEL_84:
  v96 = (_QWORD *)(*(_QWORD *)&v5[8 * (v9 / 0xAA)] + 24 * (v9 % 0xAA));
  *v96 = 0;
  v96[1] = 0;
  v96[2] = 0;
  result = std::vector<CGPointWithPts>::__init_with_size[abi:ne180100]<CGPointWithPts*,CGPointWithPts*>(v96, *(const void **)a2, *(_QWORD *)(a2 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 4));
  ++a1[5];
  return result;
}

void sub_1A14E7A10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, __int128 a11)
{
  void *v11;

  operator delete(v11);
  if ((_QWORD)a11)
    operator delete((void *)a11);
  _Unwind_Resume(a1);
}

void vision::mod::ImageClassifierGlimmer::~ImageClassifierGlimmer(vision::mod::ImageClassifierGlimmer *this)
{
  *(_QWORD *)this = &off_1E453A600;
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)this + 120);
  vision::mod::ImageClassifierAbstract::~ImageClassifierAbstract(this);
}

{
  *(_QWORD *)this = &off_1E453A600;
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)this + 120);
  vision::mod::ImageClassifierAbstract::~ImageClassifierAbstract(this);
  JUMPOUT(0x1A1B0A898);
}

uint64_t vision::mod::ImageClassifierGlimmer::getDescriptorProcessor@<X0>(uint64_t this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  v2 = *(uint64_t **)(this + 120);
  v4 = *v2;
  v3 = v2[1];
  *a2 = v4;
  a2[1] = v3;
  if (v3)
  {
    v5 = (unint64_t *)(v3 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  return this;
}

uint64_t vision::mod::ImageClassifierGlimmer::setDescriptorProcessor(uint64_t a1, uint64_t *a2)
{
  _QWORD *v3;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  const char *v8;
  int v9;
  _BYTE *v10;
  FILE *v11;
  FILE *v12;
  unsigned __int8 v13;
  void *v14;
  FILE *v15;
  FILE *v16;
  uint64_t v17;
  uint64_t v18;
  size_t v19;
  __int128 v20;
  void *v21;
  void *v22;
  _QWORD *exception;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  std::string v28;
  unint64_t v29;

  v3 = *(_QWORD **)(a1 + 120);
  if (!v3)
  {
    exception = __cxa_allocate_exception(8uLL);
    v25 = 3965;
    goto LABEL_23;
  }
  std::shared_ptr<vision::mod::ImageDescriptorProcessorAbstract>::operator=[abi:ne180100](v3, *a2, a2[1]);
  v5 = *(_QWORD **)(a1 + 120);
  if (!*a2)
  {
    v5[5] = 0;
    return a1;
  }
  v6 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v5 + 128))(*v5);
  v7 = *(_QWORD *)(a1 + 120);
  *(_QWORD *)(v7 + 40) = v6 >> 2;
  v8 = (const char *)(v7 + 56);
  v9 = *(char *)(v7 + 79);
  if (*(_BYTE *)(v7 + 48))
  {
    if (v9 < 0)
      v8 = *(const char **)v8;
    v10 = (_BYTE *)(v7 + 80);
    if (*(char *)(v7 + 103) < 0)
      v10 = *(_BYTE **)v10;
    v11 = fopen(v8, "rb");
    if (v11)
    {
      v12 = v11;
      v28.__r_.__value_.__r.__words[0] = 0;
      v29 = 0;
      fseek(v11, 0, 0);
      v13 = BinSerializer_freadInBytes(v12, v10, &v28, &v29);
      v14 = (void *)v28.__r_.__value_.__r.__words[0];
      if (v28.__r_.__value_.__r.__words[0] && v13 == 128)
      {
        vision::mod::ImageClassifierGlimmer::private_t::loadData((vision::mod::ImageClassifierGlimmer::private_t *)v7, v28.__r_.__value_.__l.__data_, v29, -1431655765 * ((*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8)) >> 3));
        free(v14);
        fclose(v12);
        return a1;
      }
      fclose(v12);
      free(v14);
      exception = __cxa_allocate_exception(8uLL);
      v25 = 3957;
LABEL_23:
      *exception = v25;
      __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
    }
LABEL_21:
    exception = __cxa_allocate_exception(8uLL);
    v25 = 3964;
    goto LABEL_23;
  }
  if (v9 < 0)
    v8 = *(const char **)v8;
  v15 = fopen(v8, "rb");
  if (!v15)
    goto LABEL_21;
  v16 = v15;
  v17 = MEMORY[0x1A1B0AEBC]();
  fseek(v16, 0, 2);
  v18 = MEMORY[0x1A1B0AEBC](v16);
  fseek(v16, v17, 0);
  v19 = v18 - v17;
  memset(&v28, 0, sizeof(v28));
  std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(&v28, *(__int128 **)(a1 + 8), *(__int128 **)(a1 + 16), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8)) >> 3));
  v20 = *(_OWORD *)&v28.__r_.__value_.__l.__data_;
  v21 = malloc_type_malloc(v19, 0xAF147757uLL);
  v22 = v21;
  if (!v21)
  {
    fclose(v16);
    v26 = __cxa_allocate_exception(8uLL);
    *v26 = 3963;
    __cxa_throw(v26, MEMORY[0x1E0DE4F28], 0);
  }
  if (fread(v21, 1uLL, v19, v16) != v19)
  {
    free(v22);
    fclose(v16);
    v27 = __cxa_allocate_exception(8uLL);
    *v27 = 3964;
    __cxa_throw(v27, MEMORY[0x1E0DE4F28], 0);
  }
  vision::mod::ImageClassifierGlimmer::private_t::loadData((vision::mod::ImageClassifierGlimmer::private_t *)v7, v22, v19, -1431655765 * ((*((_QWORD *)&v20 + 1) - (_QWORD)v20) >> 3));
  free(v22);
  fclose(v16);
  v29 = (unint64_t)&v28;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v29);
  return a1;
}

void sub_1A14E7DC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

void vision::mod::ImageClassifierGlimmer::classifyDescriptorHandler(__int128 **this@<X0>, const vision::mod::ImageDescriptorBufferAbstract *a2@<X1>, uint64_t a3@<X8>)
{
  __int128 *v6;
  std::string::size_type size;
  uint64_t v8;
  __int128 *v9;
  uint64_t v10;
  const float *v11;
  uint64_t v12;
  float v13;
  float v14;
  const float *v15;
  float v16;
  float v17;
  float v18;
  char *v19;
  float v20;
  std::string v21;
  __int128 *v22;
  std::string *v23;

  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_DWORD *)(a3 + 32) = 1065353216;
  memset(&v21, 0, sizeof(v21));
  std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(&v21, this[1], this[2], 0xAAAAAAAAAAAAAAABLL * (((char *)this[2] - (char *)this[1]) >> 3));
  size = v21.__r_.__value_.__l.__size_;
  v6 = (__int128 *)v21.__r_.__value_.__r.__words[0];
  if (v21.__r_.__value_.__r.__words[0] != v21.__r_.__value_.__l.__size_)
  {
    v8 = 0;
    do
    {
      v9 = this[15];
      v10 = *((_QWORD *)v9 + 5);
      v11 = (const float *)*((_QWORD *)a2 + 7);
      v12 = *((_QWORD *)v9 + 2);
      v13 = cblas_sasum(v10, v11, 1);
      v14 = cblas_snrm2(v10, v11, 1);
      v15 = (const float *)(v12 + 4 * v10 * v8);
      v16 = cblas_sasum(v10, v15, 1);
      v17 = cblas_snrm2(v10, v15, 1);
      v18 = cblas_sdot(v10, v11, 1, v15, 1);
      v22 = v6;
      v19 = std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a3, (unsigned __int8 *)v6, &v22);
      v20 = fmax((float)((float)((float)(v14 * v14) - (float)((float)(v13 * v13) / (float)(int)v10))* (float)((float)(v17 * v17) - (float)((float)(v16 * v16) / (float)(int)v10))), 0.000001);
      *((float *)v19 + 10) = 1.0
                           / (float)(expf((float)((float)(1.0 / sqrtf(v20))* (float)(v18 - (float)((float)(v13 * v16) / (float)(int)v10)))* -10.0)+ 1.0);
      ++v8;
      v6 = (__int128 *)((char *)v6 + 24);
    }
    while (v6 != (__int128 *)size);
  }
  v23 = &v21;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v23);
}

void sub_1A14E7FC8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void vision::mod::ImageClassifierGlimmer::classifyImage_RGBA8888(uint64_t a1@<X8>)
{
  _QWORD *exception;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  exception = __cxa_allocate_exception(8uLL);
  *exception = 3967;
  __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
}

void sub_1A14E803C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void vision::mod::ImageClassifierGlimmer::classifyImage_BGRA8888(uint64_t a1@<X8>)
{
  _QWORD *exception;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  exception = __cxa_allocate_exception(8uLL);
  *exception = 3967;
  __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
}

void sub_1A14E8094(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void vision::mod::ImageClassifierGlimmer::classifyImage_Planar8(uint64_t a1@<X8>)
{
  _QWORD *exception;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  exception = __cxa_allocate_exception(8uLL);
  *exception = 3967;
  __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
}

void sub_1A14E80EC(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void vision::mod::ImageClassifierGlimmer::private_t::loadData(vision::mod::ImageClassifierGlimmer::private_t *this, void *a2, size_t a3, int a4)
{
  uint64_t v7;
  unint64_t v8;
  void **v9;
  _QWORD *exception;

  v7 = a4;
  v8 = *((_QWORD *)this + 5) * a4;
  v9 = (void **)((char *)this + 16);
  std::vector<float>::resize((char **)this + 2, v8);
  if (a3 == 4 * v8)
  {
    memcpy(*v9, a2, a3);
  }
  else
  {
    if (v8 != a3)
    {
      exception = __cxa_allocate_exception(8uLL);
      *exception = 3964;
      __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
    }
    vDSP_vfltu8((const unsigned __int8 *)a2, 1, *((float **)this + 2), 1, *((_QWORD *)this + 5) * v7);
  }
}

void std::__shared_ptr_emplace<vision::mod::ImageClassifierGlimmer::private_t>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453B6B8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<vision::mod::ImageClassifierGlimmer::private_t>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453B6B8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A1B0A898);
}

uint64_t std::__shared_ptr_emplace<vision::mod::ImageClassifierGlimmer::private_t>::__on_zero_shared(uint64_t a1)
{
  void *v2;

  if (*(char *)(a1 + 127) < 0)
    operator delete(*(void **)(a1 + 104));
  if (*(char *)(a1 + 103) < 0)
    operator delete(*(void **)(a1 + 80));
  v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(_QWORD *)(a1 + 48) = v2;
    operator delete(v2);
  }
  return std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](a1 + 24);
}

void normalizeArray(float *a1, unsigned int a2)
{
  float v2;
  uint64_t v3;
  uint64_t v4;
  float v5;
  float v6;
  float v7;
  int __pattern4;

  v2 = *a1;
  v3 = a2;
  v4 = 1;
  v5 = *a1;
  do
  {
    v6 = a1[v4];
    if (v6 <= v2)
    {
      if (v6 < v5)
        v5 = a1[v4];
    }
    else
    {
      v2 = a1[v4];
    }
    ++v4;
  }
  while (a2 != v4);
  if (v5 == v2)
  {
    if (v5 != 0.0 && v2 != 1.0)
    {
      __pattern4 = 1065353216;
      memset_pattern4(a1, &__pattern4, 4 * a2);
    }
  }
  else
  {
    v7 = 1.0 / (float)(v2 - v5);
    do
    {
      *a1 = v7 * (float)(*a1 - v5);
      ++a1;
      --v3;
    }
    while (v3);
  }
}

void boxFilter(float *a1, unsigned int a2, unsigned int a3, int a4, float *a5)
{
  float *v10;
  int v11;
  uint64_t v12;
  float *v13;
  unint64_t v14;
  int v15;
  float *v16;
  float v17;
  double v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  float *v22;
  unint64_t v23;
  int v24;
  unint64_t v25;
  uint64_t v26;
  float v27;
  float v28;
  unint64_t v29;
  float *v30;
  float v31;
  float *v32;
  uint64_t v33;
  unint64_t v34;
  float v35;
  float *v36;
  unsigned int v37;
  float v38;
  float v39;
  uint64_t v40;
  unsigned int v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  float v46;
  float v47;
  uint64_t v48;
  uint64_t v49;
  float v50;
  unint64_t v51;
  float v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  float *v56;
  uint64_t v57;
  unsigned int v58;
  float v59;
  float *v60;
  uint64_t v61;
  float v62;
  uint64_t v63;
  int v64;
  unsigned int v65;
  uint64_t v66;
  uint64_t v67;
  float v68;
  int v69;
  unsigned int v70;
  uint64_t v71;

  v10 = (float *)malloc_type_malloc(4 * a2, 0x100004052888210uLL);
  v11 = 0;
  v12 = a2 - (a3 >> 1);
  if ((a4 & 1) != 0)
    v13 = v10;
  else
    v13 = a5;
  v14 = a3 >> 1;
  v15 = a2 - (a3 | 1) + 1;
  if ((a4 & 1) != 0)
    v16 = a5;
  else
    v16 = v10;
  v17 = 1.0 / (float)a3;
  v18 = v17;
  if (v14 <= 1)
    v19 = 1;
  else
    v19 = v14;
  v20 = a2 - (a3 & 0xFFFFFFFE);
  v21 = a2 + (a3 >> 1) - (a3 & 0xFFFFFFFE);
  do
  {
    v22 = a1;
    a1 = v16;
    v23 = 0;
    if ((a3 & 1) != 0)
    {
      v51 = v14 + 1;
      do
      {
        v52 = 0.0;
        v53 = v23;
        do
          v52 = v52 + v22[(v12 + v53++)];
        while (v53 < v14);
        v54 = 0;
        do
          v52 = v52 + v22[v54++];
        while (v51 != v54);
        a1[v23++] = v17 * v52;
        ++v51;
      }
      while (v23 != v19);
      v55 = 0;
      v56 = v22;
      v57 = a3 >> 1;
      v58 = a3 | 1;
      do
      {
        v59 = 0.0;
        if (v57 - v14 < (v14 + 1 + v57))
        {
          v60 = v56;
          v61 = v58;
          do
          {
            v62 = *v60++;
            v59 = v59 + v62;
            --v61;
          }
          while (v55 != v61);
        }
        a1[v57++] = v17 * v59;
        ++v55;
        ++v58;
        ++v56;
      }
      while (v55 != v20);
      if (a3 >= 2)
      {
        v63 = 0;
        v64 = v15;
        v65 = a3 - 1;
        v66 = 1;
        v67 = v12;
        do
        {
          v68 = 0.0;
          if (v67 - v12 < (unint64_t)(a3 - 1))
          {
            v69 = v64;
            v70 = v65;
            do
            {
              v68 = v68 + v22[v69++];
              --v70;
            }
            while (v70);
          }
          if ((_DWORD)v67 - (_DWORD)v12 != -1)
          {
            v71 = 0;
            do
              v68 = v68 + v22[v71++];
            while (v66 != v71);
          }
          a1[v67++] = v17 * v68;
          ++v63;
          ++v66;
          --v65;
          ++v64;
        }
        while (v63 != v14);
      }
    }
    else
    {
      v24 = v12;
      v25 = v14 + 1;
      do
      {
        v26 = 0;
        v27 = 0.0;
        v28 = 0.0;
        do
        {
          if (v26)
            v28 = v28 + v22[(v24 + v26)];
          else
            v27 = v27 + v22[(v12 + v23)];
          ++v26;
        }
        while (v23 + v26 < v14);
        v29 = v25;
        v30 = v22;
        do
        {
          if (v29 == 1)
            v27 = v27 + v22[v23 + v14];
          else
            v28 = v28 + *v30;
          ++v30;
          --v29;
        }
        while (v29);
        v31 = (v28 + v27 * 0.5) * v18;
        a1[v23++] = v31;
        ++v25;
        ++v24;
      }
      while (v23 != v19);
      v32 = v22 + 1;
      v33 = a3 >> 1;
      do
      {
        v34 = (v14 + v33);
        v35 = 0.0;
        if (v33 - v14 + 1 < v34)
        {
          v36 = v32;
          v37 = (a3 & 0xFFFFFFFE) - 1;
          do
          {
            v38 = *v36++;
            v35 = v35 + v38;
            --v37;
          }
          while (v37);
        }
        v39 = (v35 + (float)(v22[v33 - v14] + v22[v34]) * 0.5) * v18;
        a1[v33++] = v39;
        ++v32;
      }
      while (v21 != (_DWORD)v33);
      if (a3 >= 2)
      {
        v40 = 0;
        v41 = a3;
        v42 = v15;
        v43 = 1;
        v44 = v12;
        do
        {
          v45 = v44 - v12;
          v46 = 0.0;
          v47 = 0.0;
          if (v44 - v12 < (unint64_t)a3)
          {
            v48 = 0;
            do
            {
              if (v48)
                v46 = v46 + v22[(v42 + v48)];
              else
                v47 = v47 + v22[(v15 + v45)];
              ++v48;
            }
            while (v41 != (_DWORD)v48);
          }
          if ((_DWORD)v44 - (_DWORD)v12 != -1)
          {
            v49 = 0;
            do
            {
              if (v40 == v49)
                v47 = v47 + v22[v45];
              else
                v46 = v46 + v22[v49];
              ++v49;
            }
            while (v43 != v49);
          }
          v50 = (v46 + v47 * 0.5) * v18;
          a1[v44++] = v50;
          ++v40;
          ++v43;
          ++v42;
          --v41;
        }
        while (v40 != v14);
      }
    }
    if (v11)
      v16 = v22;
    else
      v16 = v13;
    ++v11;
  }
  while (v11 != a4);
  if (v10)
    free(v10);
}

void findPeaks(float *a1, int a2, float *a3, _DWORD *a4, float a5, float a6)
{
  size_t v10;
  uint64_t v11;
  float *v12;
  float *v13;
  float *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  float v21;
  uint64_t v22;
  uint64_t v23;
  float v24;
  float *v25;
  uint64_t v26;
  float v27;
  int v28;
  int v29;
  int v30;
  int v31;
  float v32;
  float v33;
  int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  int v39;
  int v40;
  float v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  uint64_t v52;
  float v53;
  float v54;
  float v55;
  int v56;
  int v57;
  uint64_t v58;
  float v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  float v71;
  float v72;
  float v73;
  int v74;
  int v75;
  int v76;
  int v77;
  float v78;
  int v79;
  int v80;
  int v81;
  int v82;
  int v83;
  float v84;
  float v85;
  int v86;
  int v87;
  int v88;
  float *v89;
  float v90;
  float *v91;
  float v92;
  float v93;
  float v94;
  float v95;
  float v96;
  float v97;
  float v98;
  float v99;
  float v100;
  float v101;
  float v102;
  float v103;
  float *v104;
  float v105;
  BOOL v106;
  int v107;
  float *v108;
  float v110;
  float v111;
  int v112;
  int v113;
  int v114;
  float v115;
  uint64_t v116;
  float v117;
  float v118;
  int v119;
  uint64_t v120;
  int v121;
  int v123;
  int v124;
  int v125;
  int v126;
  float v127;
  __int128 v128;
  uint64_t v129;

  v10 = 4 * a2;
  v11 = a2;
  v12 = (float *)malloc_type_malloc(v10, 0x100004052888210uLL);
  v13 = (float *)malloc_type_malloc(v10, 0x100004052888210uLL);
  v14 = v13;
  v15 = 0;
  v16 = (a2 - 1);
  *v12 = (float)(a1[1] - a1[v16]) * 0.5;
  v17 = v16 - 1;
  do
  {
    v12[v15 + 1] = (float)(a1[v15 + 2] - a1[v15]) * 0.5;
    ++v15;
  }
  while (v17 != v15);
  v18 = 0;
  v19 = (a2 - 2);
  v12[v16] = (float)(*a1 - a1[v19]) * 0.5;
  *v13 = (float)(a1[1] + (float)(*a1 * -2.0)) + a1[v16];
  do
  {
    v13[v18 + 1] = (float)(a1[v18 + 2] + (float)(a1[v18 + 1] * -2.0)) + a1[v18];
    ++v18;
    --v17;
  }
  while (v17);
  v20 = 0;
  v13[v16] = (float)(*a1 + (float)(a1[v16] * -2.0)) + a1[v19];
  v21 = (float)a2;
  if (a6 > 0.0)
    a5 = 0.0;
  v22 = (a2 + 1);
  v23 = 1;
  v24 = 0.5;
  v25 = a3;
  v118 = (float)a2;
  v110 = a5;
  v111 = a6;
  v120 = v11;
  do
  {
    if (v23 == v11)
      v26 = 0;
    else
      v26 = v23;
    if (v12[v23 - 1] <= 0.0)
      goto LABEL_211;
    v27 = v12[v26];
    if (v27 > 0.0)
      goto LABEL_211;
    if (v27 == 0.0)
    {
      v28 = v26;
      while (1)
      {
        v29 = v28 >= a2 ? a2 : 0;
        v30 = v28 - v29;
        if (v12[v30] < 0.0)
          break;
        if (++v28 >= (int)v26 + a2)
          goto LABEL_211;
      }
      v31 = v26;
      if ((_DWORD)v26 == -1)
        goto LABEL_211;
    }
    else
    {
      v30 = v26;
      v31 = v23 - 1;
    }
    v32 = v14[v23 - 1];
    if (v32 >= 0.0 && (v33 = v14[v26], v33 <= 0.0) || v32 <= 0.0 && (v33 = v14[v26], v33 >= 0.0))
    {
      if (v23 == 1)
        v34 = a2;
      else
        v34 = v23 - 1;
      v31 = v34 - 1;
      if ((_DWORD)v26 == (_DWORD)v16)
        v30 = 0;
      else
        v30 = v26 + 1;
      if ((float)(v32 + v14[v31]) >= 0.0 || (float)(v33 + v14[v30]) >= 0.0)
        goto LABEL_211;
      if (v32 >= 0.0)
        v30 = v26;
    }
    v35 = 0;
    v36 = v31;
    v37 = v30;
    v38 = -1;
    v39 = v31;
    v40 = -1;
    v41 = (float)((float)(a1[v31] + a1[v30]) * v24) * v24;
    v42 = 0xFFFFFFFFLL;
    v43 = 0xFFFFFFFFLL;
    v44 = -1;
    v45 = -1;
    do
    {
      if (v39 >= a2)
        v46 = a2;
      else
        v46 = 0;
      if (v39 >= 0)
        v47 = -v46;
      else
        v47 = a2;
      v48 = v47 + v39;
      v49 = v47 + v39 - a2;
      if (v47 + v39 <= a2)
        v50 = 0;
      else
        v50 = a2;
      if (v48 >= 1)
        v51 = -v50;
      else
        v51 = a2;
      v52 = (v48 + v51 - 1);
      v53 = a1[v48];
      if (v53 < v41)
      {
        if (!v35)
        {
          v45 = v52;
          v44 = v48;
        }
        LODWORD(v43) = v52;
        LODWORD(v42) = v48;
        v40 = v52;
        v38 = v48;
        break;
      }
      if (v12[(int)v52] < 0.0 && v12[v48] >= 0.0)
      {
        v40 = v52;
        v38 = v48;
      }
      v54 = v14[(int)v52];
      if (v35)
      {
        if (v54 >= 0.0 || (v55 = v14[v48], v55 < 0.0) || v12[v48] >= 0.0)
        {
          v35 = 1;
          goto LABEL_93;
        }
      }
      else if (v54 <= 0.0 || (v55 = v14[v48], v55 > 0.0))
      {
        v35 = 0;
        goto LABEL_93;
      }
      if (v55 != 0.0)
      {
        if (v35)
        {
          v58 = v52;
        }
        else
        {
          v45 = v52;
          v44 = v48;
          v58 = v43;
        }
        if (v35)
          v52 = v48;
        else
          v52 = v42;
        if (!v35)
          goto LABEL_88;
        goto LABEL_89;
      }
      while (1)
      {
        if (v48 >= a2)
          v56 = a2;
        else
          v56 = 0;
        if (v48 >= 0)
          v57 = -v56;
        else
          v57 = a2;
        v58 = (v57 + v48);
        if (a1[(int)v58] < v41)
        {
          if (!v35)
          {
            v45 = v57 + v48;
            v44 = v52;
            goto LABEL_88;
          }
          goto LABEL_89;
        }
        v59 = v14[(int)v58];
        if (!v35)
          break;
        if (v59 > 0.0)
        {
          LODWORD(v43) = v57 + v48;
          LODWORD(v42) = v52;
          if ((_DWORD)v58 == -1)
            goto LABEL_172;
          goto LABEL_101;
        }
LABEL_74:
        if (--v48 <= v49)
          goto LABEL_87;
      }
      if (v59 >= 0.0)
        goto LABEL_74;
      v45 = v57 + v48;
      v44 = v52;
LABEL_87:
      v58 = v43;
      v52 = v42;
      if (!v35)
      {
LABEL_88:
        if (v45 != -1)
          goto LABEL_89;
LABEL_172:
        LODWORD(v16) = a2 - 1;
        goto LABEL_211;
      }
LABEL_89:
      if ((_DWORD)v58 == -1 && v35 == 1)
        goto LABEL_172;
      if (v35)
      {
        LODWORD(v43) = v58;
        LODWORD(v42) = v52;
        break;
      }
      v35 = 1;
      v43 = v58;
      v42 = v52;
LABEL_93:
      --v39;
    }
    while (v39 > v31 - a2);
LABEL_101:
    v60 = 0;
    v61 = v30 + a2;
    v62 = -1;
    v63 = v30;
    v64 = -1;
    v124 = -1;
    v125 = -1;
    v123 = -1;
    v126 = -1;
    while (1)
    {
      v65 = v63 >= a2 ? a2 : 0;
      v66 = v63 >= 0 ? -v65 : a2;
      v67 = v66 + v63;
      v68 = v66 + v63 <= a2 ? 0 : a2;
      v69 = v67 >= 1 ? -v68 : a2;
      v70 = v67 + v69 - 1;
      v71 = a1[v67];
      if (v71 < v41)
        break;
      if (v12[v70] < 0.0 && v12[v67] >= 0.0)
      {
        v64 = v70;
        v62 = v67;
      }
      v72 = v14[v70];
      if (v60)
      {
        if (v72 <= 0.0 || (v73 = v14[v67], v73 > 0.0) || v12[v67] <= 0.0)
        {
          v60 = 1;
          goto LABEL_163;
        }
      }
      else if (v72 >= 0.0 || (v73 = v14[v67], v73 < 0.0))
      {
        v60 = 0;
        goto LABEL_163;
      }
      if (v73 == 0.0)
      {
        v74 = v67 + a2;
        while (1)
        {
          v75 = v67 >= a2 ? a2 : 0;
          v76 = v67 >= 0 ? -v75 : a2;
          v77 = v76 + v67;
          if (a1[v76 + v67] < v41)
            break;
          v78 = v14[v77];
          if (v60)
          {
            if (v78 < 0.0)
            {
              v124 = v76 + v67;
              v125 = v70;
              if (v77 != -1)
                goto LABEL_174;
              goto LABEL_171;
            }
          }
          else if (v78 > 0.0)
          {
            v79 = v76 + v67;
            v123 = v70;
            v77 = v124;
            v70 = v125;
            goto LABEL_158;
          }
          if (++v67 >= v74)
          {
            v77 = v124;
            v70 = v125;
            v79 = v126;
            if (!v60)
              goto LABEL_158;
            goto LABEL_159;
          }
        }
        v79 = v126;
        if (!v60)
          v79 = v76 + v67;
        v81 = v123;
        if (!v60)
          v81 = v70;
        v123 = v81;
        if (!v60)
          goto LABEL_158;
      }
      else
      {
        v79 = v126;
        if (!v60)
          v79 = v70;
        v80 = v123;
        if (!v60)
          v80 = v67;
        v123 = v80;
        if (v60)
          v77 = v70;
        else
          v77 = v124;
        v70 = v125;
        if (v60)
        {
          v70 = v67;
        }
        else
        {
LABEL_158:
          if (v79 == -1)
            goto LABEL_171;
        }
      }
LABEL_159:
      if (v77 == -1 && v60 == 1)
      {
LABEL_171:
        v11 = v120;
        goto LABEL_172;
      }
      v126 = v79;
      if (v60)
      {
        v124 = v77;
        v125 = v70;
        goto LABEL_174;
      }
      v60 = 1;
      v124 = v77;
      v125 = v70;
LABEL_163:
      if (++v63 >= v61)
        goto LABEL_174;
    }
    v82 = v126;
    if (!v60)
      v82 = v70;
    v125 = v67;
    v126 = v82;
    v83 = v123;
    if (!v60)
      v83 = v67;
    v123 = v83;
    v124 = v70;
    v62 = v67;
    v64 = v70;
LABEL_174:
    v84 = (float)-v12[v30] / (float)(v12[v31] - v12[v30]);
    v121 = v20;
    LODWORD(v16) = a2 - 1;
    v119 = v64;
    if (v31 >= v30)
    {
      v113 = v38;
      v114 = v42;
      v42 = v31;
      v116 = v30;
      v112 = v40;
      v86 = v45;
      v87 = v62;
      v88 = v44;
      v85 = fmodf((float)(v21 + (float)(v84 * (float)(v31 - v61))) + (float)v61, v21);
      v44 = v88;
      v62 = v87;
      v45 = v86;
      v40 = v112;
      v38 = v113;
      v37 = v116;
      v36 = v42;
      LODWORD(v42) = v114;
      v22 = (a2 + 1);
      v20 = v121;
      v25 = a3;
      LODWORD(v16) = a2 - 1;
    }
    else
    {
      v85 = (float)v30 + (float)(v84 * (float)(v31 - v30));
    }
    v89 = &v25[6 * v20];
    v89[1] = v85;
    v90 = a1[v37] + (float)(v84 * (float)(a1[v36] - a1[v37]));
    v89[5] = v90;
    if (v90 < a5)
    {
      v11 = v120;
      goto LABEL_211;
    }
    v91 = &v25[6 * v20];
    v92 = 0.5;
    if (v53 >= v41)
      v92 = (float)-v14[(int)v42] / (float)(v14[(int)v43] - v14[(int)v42]);
    v115 = v12[v44];
    v117 = v12[v45];
    if ((int)v43 >= (int)v42)
      v93 = fmodf((float)(v21 + (float)(v92 * (float)(v43 - (v42 + a2)))) + (float)(v42 + a2), v21);
    else
      v93 = (float)(int)v42 + (float)(v92 * (float)(v43 - v42));
    v94 = 0.5;
    if (v53 >= v41)
      v94 = (float)-v12[v38] / (float)(v12[v40] - v12[v38]);
    if (v40 >= v38)
      v95 = fmodf((float)(v21 + (float)(v94 * (float)(v40 - (v38 + a2)))) + (float)(v38 + a2), v21);
    else
      v95 = (float)v38 + (float)(v94 * (float)(v40 - v38));
    if (v53 < v41)
      v96 = v93;
    else
      v96 = v95;
    a3[6 * v121 + 2] = v96;
    v127 = v12[v126];
    v97 = v12[v123];
    v98 = 0.5;
    if (v71 >= v41)
      v98 = (float)-v14[v125] / (float)(v14[v124] - v14[v125]);
    if (v124 >= v125)
      v99 = fmodf((float)(v118 + (float)(v98 * (float)(v124 - (v125 + a2)))) + (float)(v125 + a2), v118);
    else
      v99 = (float)v125 + (float)(v98 * (float)(v124 - v125));
    v100 = 0.5;
    if (v71 >= v41)
      v100 = (float)-v12[v62] / (float)(v12[v119] - v12[v62]);
    if (v119 >= v62)
    {
      v21 = (float)a2;
      v101 = fmodf((float)(v118 + (float)(v100 * (float)(v119 - (v62 + a2)))) + (float)(v62 + a2), v118);
      v25 = a3;
      LODWORD(v16) = a2 - 1;
      v11 = v120;
      v20 = v121;
    }
    else
    {
      v101 = (float)v62 + (float)(v100 * (float)(v119 - v62));
      v25 = a3;
      LODWORD(v16) = a2 - 1;
      v11 = v120;
      v20 = v121;
      v21 = (float)a2;
    }
    v22 = (a2 + 1);
    v102 = fabsf(v115 + (float)(v84 * (float)(v117 - v115)));
    v103 = fabsf(v97 + (float)(v94 * (float)(v127 - v97)));
    if (v71 < v41)
      v101 = v99;
    v104 = &v25[6 * v121];
    v105 = -0.0;
    if (v96 >= v101)
      v105 = v21;
    v104[3] = v101;
    v104[4] = (float)(v101 + v105) - v96;
    if (v102 <= v103)
      v106 = v103 < v111;
    else
      v106 = v102 < v111;
    a5 = v110;
    v24 = 0.5;
    if (!v106)
    {
      *v91 = 0.0;
      if (++v20 == 200)
      {
        *a4 = 200;
        goto LABEL_213;
      }
    }
LABEL_211:
    ++v23;
  }
  while (v23 != v22);
  *a4 = v20;
  if (v20)
  {
LABEL_213:
    if (v25[1] > v25[7])
    {
      v128 = *(_OWORD *)v25;
      v129 = *((_QWORD *)v25 + 2);
      v107 = v20 - 1;
      if (v20 == 1)
      {
        v107 = 0;
      }
      else
      {
        memmove(v25, v25 + 6, 24 * (v20 - 1));
        v25 = a3;
      }
      v108 = &v25[6 * v107];
      *(_OWORD *)v108 = v128;
      *((_QWORD *)v108 + 2) = v129;
    }
  }
  free(v12);
  free(v14);
}

void sub_1A14E9338(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t **std::__tree<std::__value_type<unsigned char,std::string>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,std::string>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,std::string>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char &&>,std::tuple<>>(uint64_t **a1, unsigned __int8 a2, _BYTE *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  unsigned int v8;
  _BYTE *v9;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = *((unsigned __int8 *)v5 + 32);
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = operator new(0x40uLL);
    v9[32] = *a3;
    *((_QWORD *)v9 + 6) = 0;
    *((_QWORD *)v9 + 7) = 0;
    *((_QWORD *)v9 + 5) = 0;
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at(a1, (uint64_t)v7, v6, (uint64_t *)v9);
    return (uint64_t **)v9;
  }
  return v7;
}

void sub_1A14E9DD4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14EA01C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_1A14EA1B8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14EA234(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14EA51C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A14EA70C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1A14EAE9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, void *a12, void *a13, uint64_t a14, void *a15, void *a16, void *a17, void *a18, void *a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,void *a24,void *a25,void *a26,void *a27,void *a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  void *a64;
  char a66;
  void *__p;
  void *v72;
  void *v73;

  _Block_object_dispose(&a66, 8);
  if (__p)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_1A14EB138(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

_QWORD *__Block_byref_object_copy__42(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;

  v2 = a2[7];
  result[6] = a2[6];
  result[7] = v2;
  result[8] = a2[8];
  a2[6] = 0;
  a2[7] = 0;
  a2[8] = 0;
  return result;
}

void __Block_byref_object_dispose__43(uint64_t a1)
{
  void *v1;

  v1 = *(void **)(a1 + 48);
  if (v1)
    operator delete(v1);
}

void sub_1A14EB370(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14EBA80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;

  if (a2)
  {

    objc_begin_catch(exception_object);
    JUMPOUT(0x1A14EB9FCLL);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A14EBD1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1A14EBD80(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14EBF2C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  v7 = v5;

  _Unwind_Resume(a1);
}

void sub_1A14EC340(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21,void *a22,void *a23,void *a24)
{
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;

  _Unwind_Resume(a1);
}

void sub_1A14EC694(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _Unwind_Exception *exception_object)
{
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

void sub_1A14EC790(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1A14EC974(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id a24)
{
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;

  _Block_object_dispose(&a19, 8);
  _Unwind_Resume(a1);
}

void sub_1A14ECA78(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__21028(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__21029(uint64_t a1)
{

}

void sub_1A14ECE60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21,void *a22,void *a23)
{
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;

  _Unwind_Resume(a1);
}

uint64_t vision::mod::ObjectTrackerOptions::clone(vision::mod::ObjectTrackerOptions *this)
{
  uint64_t result;
  uint64_t v3;

  result = operator new();
  v3 = *((_QWORD *)this + 1);
  *(_QWORD *)result = &off_1E453A560;
  *(_QWORD *)(result + 8) = v3;
  *(_DWORD *)(result + 16) = *((_DWORD *)this + 4);
  return result;
}

uint64_t vision::mod::ObjectTrackerAbstract::reset(vision::mod::ObjectTrackerAbstract *this)
{
  uint64_t result;

  result = (*(uint64_t (**)(vision::mod::ObjectTrackerAbstract *))(*(_QWORD *)this + 56))(this);
  if (result == 128)
  {
    result = (*(uint64_t (**)(vision::mod::ObjectTrackerAbstract *))(*(_QWORD *)this + 48))(this);
    if (result == 128)
      return 6784;
  }
  return result;
}

uint64_t vision::mod::ObjectTrackerAbstract::update()
{
  return 6784;
}

vision::mod::ObjectTrackerAbstract *vision::mod::ObjectTrackerAbstract::ObjectTrackerAbstract(vision::mod::ObjectTrackerAbstract *this, vision::mod::ObjectDetectorAbstract *a2, const vision::mod::ObjectTrackerOptions *a3)
{
  uint64_t v4;
  _QWORD *v5;

  *(_QWORD *)this = off_1E453A5B0;
  *((_QWORD *)this + 1) = 0;
  v4 = (**(uint64_t (***)(vision::mod::ObjectDetectorAbstract *))a2)(a2);
  *((_QWORD *)this + 2) = v4;
  v5 = (_QWORD *)operator new();
  *v5 = &off_1E453BE98;
  v5[1] = 0;
  v5[2] = 0;
  v5[3] = v4;
  *((_QWORD *)this + 3) = v5;
  return this;
}

void sub_1A14ED3A8(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    MEMORY[0x1A1B0A898](v1, 0x10A1C40DF6760FDLL);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<vision::mod::ObjectTrackerOptions *,std::shared_ptr<vision::mod::ObjectTrackerOptions>::__shared_ptr_default_delete<vision::mod::ObjectTrackerOptions,vision::mod::ObjectTrackerOptions>,std::allocator<vision::mod::ObjectTrackerOptions>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A1B0A898);
}

uint64_t std::__shared_ptr_pointer<vision::mod::ObjectTrackerOptions *,std::shared_ptr<vision::mod::ObjectTrackerOptions>::__shared_ptr_default_delete<vision::mod::ObjectTrackerOptions,vision::mod::ObjectTrackerOptions>,std::allocator<vision::mod::ObjectTrackerOptions>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    JUMPOUT(0x1A1B0A898);
  return result;
}

uint64_t std::__shared_ptr_pointer<vision::mod::ObjectTrackerOptions *,std::shared_ptr<vision::mod::ObjectTrackerOptions>::__shared_ptr_default_delete<vision::mod::ObjectTrackerOptions,vision::mod::ObjectTrackerOptions>,std::allocator<vision::mod::ObjectTrackerOptions>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"NSt3__110shared_ptrIN6vision3mod20ObjectTrackerOptionsEE27__shared_ptr_default_deleteIS3_S3_EE"))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1A14ED558(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14ED8B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12)
{
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

void sub_1A14EE03C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, __CVBuffer *a20,__CVBuffer *a21,__CVBuffer *a22,uint64_t a23,uint64_t a24,__CVBuffer *a25)
{
  void *v25;
  void *v26;

  if (a2)
  {

    apple::vision::CVPixelBufferWrapper::~CVPixelBufferWrapper(&a25);
    apple::vision::CVPixelBufferWrapper::~CVPixelBufferWrapper(&a20);
    apple::vision::CVPixelBufferWrapper::~CVPixelBufferWrapper(&a21);
    apple::vision::CVPixelBufferWrapper::~CVPixelBufferWrapper(&a22);

    objc_begin_catch(exception_object);
    JUMPOUT(0x1A14EE010);
  }
  _Unwind_Resume(exception_object);
}

CVPixelBufferRef NtCreatePixelBuffer(int a1, int a2, IOSurfaceRef *a3)
{
  __CFDictionary *Mutable;
  const void *v7;
  CFNumberRef v8;
  const void *v9;
  CFNumberRef v10;
  const void *v11;
  CFNumberRef v12;
  const void *v13;
  int v14;
  int v15;
  CFNumberRef v16;
  __CFDictionary *v17;
  const void *v18;
  CFNumberRef v19;
  CVReturn v20;
  CVPixelBufferRef result;
  CVPixelBufferRef valuePtr;

  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v7 = (const void *)*MEMORY[0x1E0CBC1E0];
  LODWORD(valuePtr) = a1;
  v8 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(Mutable, v7, v8);
  CFRelease(v8);
  v9 = (const void *)*MEMORY[0x1E0CBC008];
  LODWORD(valuePtr) = a2;
  v10 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(Mutable, v9, v10);
  CFRelease(v10);
  v11 = (const void *)*MEMORY[0x1E0CBC070];
  LODWORD(valuePtr) = 1111970369;
  v12 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(Mutable, v11, v12);
  CFRelease(v12);
  v13 = (const void *)*MEMORY[0x1E0CBBF08];
  v14 = 4 * a1 + 63;
  if (v14 <= 0)
    v15 = -(-v14 & 0x3F);
  else
    v15 = v14 & 0x3F;
  LODWORD(valuePtr) = v14 - v15;
  v16 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(Mutable, v13, v16);
  CFRelease(v16);
  *a3 = IOSurfaceCreate(Mutable);
  CFRelease(Mutable);
  if (!*a3)
    return 0;
  v17 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v18 = (const void *)*MEMORY[0x1E0CA9040];
  LODWORD(valuePtr) = 1111970369;
  v19 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(v17, v18, v19);
  CFRelease(v19);
  valuePtr = 0;
  v20 = CVPixelBufferCreateWithIOSurface((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *a3, v17, &valuePtr);
  result = 0;
  if (!v20)
  {
    CFRelease(v17);
    return valuePtr;
  }
  return result;
}

uint64_t NtDestroyTracker(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    if (*(_DWORD *)result == -1430532899)
    {
      if (!*(_BYTE *)(result + 4089))
      {
        espresso_plan_destroy();
        *(_QWORD *)(v1 + 16) = 0;
        espresso_context_destroy();
        *(_QWORD *)(v1 + 8) = 0;
        espresso_plan_destroy();
        *(_QWORD *)(v1 + 384) = 0;
        espresso_context_destroy();
        *(_QWORD *)(v1 + 376) = 0;
      }
      TtTrkRpnStop(*(_QWORD **)(v1 + 1104));
      CFRelease(*(CFTypeRef *)(v1 + 4080));
      CFRelease(*(CFTypeRef *)(v1 + 4064));
      CVPixelBufferRelease(*(CVPixelBufferRef *)(v1 + 4072));
      CVPixelBufferRelease(*(CVPixelBufferRef *)(v1 + 4056));
      TtTrkRpnDestroy(*(TtTrkRpnNode ***)(v1 + 1104));
      v2 = *(_QWORD *)(v1 + 3504);
      if (v2)
        MEMORY[0x1A1B0A880](v2, 0x1000C8077774924);
      JUMPOUT(0x1A1B0A898);
    }
  }
  return result;
}

void *NtLockCvPixelBuffers(uint64_t a1)
{
  void *result;

  CVPixelBufferLockBaseAddress(*(CVPixelBufferRef *)(a1 + 4056), 0);
  CVPixelBufferLockBaseAddress(*(CVPixelBufferRef *)(a1 + 4072), 0);
  *(_QWORD *)(a1 + 3204) = CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a1 + 4056));
  result = CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)(a1 + 4072));
  *(_QWORD *)(a1 + 3216) = result;
  return result;
}

uint64_t EspressoExemplarPlanExecuteSynced(uint64_t a1)
{
  uint64_t result;

  result = espresso_plan_execute_sync();
  *(_DWORD *)(a1 + 1080) = result;
  return result;
}

uint64_t EspressoInstancePlanExecuteSynced(uint64_t a1)
{
  uint64_t result;

  result = espresso_plan_execute_sync();
  *(_DWORD *)(a1 + 1080) = result;
  return result;
}

void sub_1A14EEAD8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14EEB88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)VNMRCDetector;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_1A14EF02C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14EF394(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__21234(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__21235(uint64_t a1)
{

}

void sub_1A14F040C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  void *v20;

  if (a2)
  {

    objc_begin_catch(exception_object);
    JUMPOUT(0x1A14F03B4);
  }
  _Unwind_Resume(exception_object);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<DetectedRectangle>>(unint64_t a1)
{
  if (a1 >= 0x924924924924925)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(28 * a1);
}

void std::__introsort<std::_ClassicAlgPolicy,nonMaxSuppression(std::vector<DetectedRectangle> &,float)::$_0 &,DetectedRectangle*,false>(uint64_t a1, _OWORD *a2, uint64_t a3, char a4)
{
  __int128 *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  __int128 *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  float v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  float *v22;
  float *v23;
  float v24;
  float *v25;
  float v26;
  float *v27;
  __int128 v28;
  float v29;
  float v30;
  __int128 *v31;
  __int128 v32;
  BOOL v33;
  uint64_t v34;
  float v35;
  unint64_t v36;
  float v37;
  float *v38;
  float *v39;
  float v40;
  uint64_t v41;
  __int128 v42;
  float v43;
  float v44;
  __int128 *v45;
  __int128 v46;
  __int128 v47;
  _OWORD *v48;
  _OWORD *v49;
  _OWORD *v50;
  __int128 v51;
  _OWORD *v52;
  BOOL v54;
  uint64_t v55;
  unint64_t v56;
  _OWORD *v57;
  float v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  int64_t v63;
  int64_t v64;
  int64_t v65;
  uint64_t v66;
  unint64_t v67;
  float v68;
  unint64_t v69;
  uint64_t v70;
  _OWORD *v71;
  __int128 v72;
  uint64_t v73;
  uint64_t v74;
  int64_t v75;
  uint64_t v76;
  unint64_t v77;
  _OWORD *v78;
  uint64_t v79;
  uint64_t v80;
  int64_t v81;
  __int128 v82;
  __int128 v83;
  uint64_t v84;
  unint64_t v85;
  float v86;
  uint64_t v87;
  _OWORD *v88;
  __int128 v89;
  uint64_t v91;
  float v92;
  uint64_t v93;
  float v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  _BYTE v98[28];
  _BYTE v99[28];
  _BYTE v100[28];
  _BYTE v101[28];
  _BYTE v102[28];
  _BYTE v103[28];
  _BYTE v104[28];
  _BYTE v105[28];
  __int128 v106;
  __int128 v107;
  _BYTE v108[28];
  __int128 v109;

__n128 std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,nonMaxSuppression(std::vector<DetectedRectangle> &,float)::$_0 &,DetectedRectangle*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  float v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  _BYTE v10[28];
  _BYTE v11[28];
  _BYTE v12[28];
  _BYTE v13[28];

  result.n128_u32[0] = *(_DWORD *)(a2 + 16);
  v4 = *(float *)(a3 + 16);
  if (result.n128_f32[0] <= *(float *)(a1 + 16))
  {
    if (v4 > result.n128_f32[0])
    {
      *(_OWORD *)v11 = *(_OWORD *)a2;
      *(_OWORD *)&v11[12] = *(_OWORD *)(a2 + 12);
      v6 = *(_OWORD *)(a3 + 12);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)(a2 + 12) = v6;
      *(_OWORD *)(a3 + 12) = *(_OWORD *)&v11[12];
      result = *(__n128 *)v11;
      *(_OWORD *)a3 = *(_OWORD *)v11;
      result.n128_u32[0] = *(_DWORD *)(a2 + 16);
      if (result.n128_f32[0] > *(float *)(a1 + 16))
      {
        *(_OWORD *)v12 = *(_OWORD *)a1;
        *(_OWORD *)&v12[12] = *(_OWORD *)(a1 + 12);
        v7 = *(_OWORD *)(a2 + 12);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 12) = v7;
        *(_OWORD *)(a2 + 12) = *(_OWORD *)&v12[12];
        result = *(__n128 *)v12;
        *(_OWORD *)a2 = *(_OWORD *)v12;
      }
    }
  }
  else
  {
    if (v4 <= result.n128_f32[0])
    {
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)&v13[12] = *(_OWORD *)(a1 + 12);
      v8 = *(_OWORD *)(a2 + 12);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_OWORD *)(a1 + 12) = v8;
      *(_OWORD *)(a2 + 12) = *(_OWORD *)&v13[12];
      result = *(__n128 *)v13;
      *(_OWORD *)a2 = *(_OWORD *)v13;
      result.n128_u32[0] = *(_DWORD *)(a3 + 16);
      if (result.n128_f32[0] <= *(float *)(a2 + 16))
        return result;
      *(_OWORD *)v10 = *(_OWORD *)a2;
      *(_OWORD *)&v10[12] = *(_OWORD *)(a2 + 12);
      v9 = *(_OWORD *)(a3 + 12);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)(a2 + 12) = v9;
    }
    else
    {
      *(_OWORD *)v10 = *(_OWORD *)a1;
      *(_OWORD *)&v10[12] = *(_OWORD *)(a1 + 12);
      v5 = *(_OWORD *)(a3 + 12);
      *(_OWORD *)a1 = *(_OWORD *)a3;
      *(_OWORD *)(a1 + 12) = v5;
    }
    *(_OWORD *)(a3 + 12) = *(_OWORD *)&v10[12];
    result = *(__n128 *)v10;
    *(_OWORD *)a3 = *(_OWORD *)v10;
  }
  return result;
}

__n128 std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,nonMaxSuppression(std::vector<DetectedRectangle> &,float)::$_0 &,DetectedRectangle*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __n128 result;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  _BYTE v12[28];
  _BYTE v13[28];
  _BYTE v14[28];

  result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,nonMaxSuppression(std::vector<DetectedRectangle> &,float)::$_0 &,DetectedRectangle*>(a1, a2, a3);
  result.n128_u32[0] = *(_DWORD *)(a4 + 16);
  if (result.n128_f32[0] > *(float *)(a3 + 16))
  {
    *(_OWORD *)v12 = *(_OWORD *)a3;
    *(_OWORD *)&v12[12] = *(_OWORD *)(a3 + 12);
    v9 = *(_OWORD *)(a4 + 12);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(_OWORD *)(a3 + 12) = v9;
    *(_OWORD *)(a4 + 12) = *(_OWORD *)&v12[12];
    result = *(__n128 *)v12;
    *(_OWORD *)a4 = *(_OWORD *)v12;
    result.n128_u32[0] = *(_DWORD *)(a3 + 16);
    if (result.n128_f32[0] > *(float *)(a2 + 16))
    {
      *(_OWORD *)v13 = *(_OWORD *)a2;
      *(_OWORD *)&v13[12] = *(_OWORD *)(a2 + 12);
      v10 = *(_OWORD *)(a3 + 12);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)(a2 + 12) = v10;
      *(_OWORD *)(a3 + 12) = *(_OWORD *)&v13[12];
      result = *(__n128 *)v13;
      *(_OWORD *)a3 = *(_OWORD *)v13;
      result.n128_u32[0] = *(_DWORD *)(a2 + 16);
      if (result.n128_f32[0] > *(float *)(a1 + 16))
      {
        *(_OWORD *)v14 = *(_OWORD *)a1;
        *(_OWORD *)&v14[12] = *(_OWORD *)(a1 + 12);
        v11 = *(_OWORD *)(a2 + 12);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 12) = v11;
        *(_OWORD *)(a2 + 12) = *(_OWORD *)&v14[12];
        result = *(__n128 *)v14;
        *(_OWORD *)a2 = *(_OWORD *)v14;
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,nonMaxSuppression(std::vector<DetectedRectangle> &,float)::$_0 &,DetectedRectangle*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int128 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  float v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _OWORD *v16;
  _OWORD *v17;
  _OWORD *v18;
  __int128 v19;
  _BYTE v20[28];
  __int128 v21;
  _BYTE v22[28];
  _BYTE v23[28];
  _BYTE v24[28];
  _BYTE v25[28];

  v4 = 0x6DB6DB6DB6DB6DB7 * ((a2 - a1) >> 2);
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (*(float *)(a2 - 12) > *(float *)(a1 + 16))
      {
        *(_OWORD *)v20 = *(_OWORD *)a1;
        *(_OWORD *)&v20[12] = *(_OWORD *)(a1 + 12);
        v6 = *(_OWORD *)(a2 - 16);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 28);
        *(_OWORD *)(a1 + 12) = v6;
        *(_OWORD *)(a2 - 16) = *(_OWORD *)&v20[12];
        *(_OWORD *)(a2 - 28) = *(_OWORD *)v20;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,nonMaxSuppression(std::vector<DetectedRectangle> &,float)::$_0 &,DetectedRectangle*>(a1, a1 + 28, a2 - 28);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,nonMaxSuppression(std::vector<DetectedRectangle> &,float)::$_0 &,DetectedRectangle*>(a1, a1 + 28, a1 + 56, a2 - 28);
      return 1;
    case 5:
      v16 = (_OWORD *)(a1 + 28);
      v17 = (_OWORD *)(a1 + 56);
      v18 = (_OWORD *)(a1 + 84);
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,nonMaxSuppression(std::vector<DetectedRectangle> &,float)::$_0 &,DetectedRectangle*>(a1, a1 + 28, a1 + 56, a1 + 84);
      if (*(float *)(a2 - 12) > *(float *)(a1 + 100))
      {
        *(_OWORD *)v22 = *v18;
        *(_OWORD *)&v22[12] = *(_OWORD *)(a1 + 96);
        v19 = *(_OWORD *)(a2 - 16);
        *v18 = *(_OWORD *)(a2 - 28);
        *(_OWORD *)(a1 + 96) = v19;
        *(_OWORD *)(a2 - 16) = *(_OWORD *)&v22[12];
        *(_OWORD *)(a2 - 28) = *(_OWORD *)v22;
        if (*(float *)(a1 + 100) > *(float *)(a1 + 72))
        {
          *(_OWORD *)v23 = *v17;
          *(_OWORD *)&v23[12] = *(_OWORD *)(a1 + 68);
          *v17 = *v18;
          *(_OWORD *)(a1 + 68) = *(_OWORD *)(a1 + 96);
          *v18 = *(_OWORD *)v23;
          *(_OWORD *)(a1 + 96) = *(_OWORD *)&v23[12];
          if (*(float *)(a1 + 72) > *(float *)(a1 + 44))
          {
            *(_OWORD *)v24 = *v16;
            *(_OWORD *)&v24[12] = *(_OWORD *)(a1 + 40);
            *v16 = *v17;
            *(_OWORD *)(a1 + 40) = *(_OWORD *)(a1 + 68);
            *v17 = *(_OWORD *)v24;
            *(_OWORD *)(a1 + 68) = *(_OWORD *)&v24[12];
            if (*(float *)(a1 + 44) > *(float *)(a1 + 16))
            {
              *(_OWORD *)v25 = *(_OWORD *)a1;
              *(_OWORD *)&v25[12] = *(_OWORD *)(a1 + 12);
              *(_OWORD *)a1 = *v16;
              *(_OWORD *)(a1 + 12) = *(_OWORD *)(a1 + 40);
              *v16 = *(_OWORD *)v25;
              *(_OWORD *)(a1 + 40) = *(_OWORD *)&v25[12];
            }
          }
        }
      }
      return 1;
    default:
      v7 = a1 + 56;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,nonMaxSuppression(std::vector<DetectedRectangle> &,float)::$_0 &,DetectedRectangle*>(a1, a1 + 28, a1 + 56);
      v8 = a1 + 84;
      if (a1 + 84 == a2)
        return 1;
      v9 = 0;
      v10 = 0;
      break;
  }
  while (1)
  {
    v11 = *(float *)(v8 + 16);
    if (v11 > *(float *)(v7 + 16))
    {
      v21 = *(_OWORD *)v8;
      v12 = *(_QWORD *)(v8 + 20);
      v13 = v9;
      while (1)
      {
        v14 = a1 + v13;
        *(_OWORD *)(v14 + 84) = *(_OWORD *)(a1 + v13 + 56);
        *(_OWORD *)(v14 + 96) = *(_OWORD *)(a1 + v13 + 68);
        if (v13 == -56)
          break;
        v13 -= 28;
        if (v11 <= *(float *)(v14 + 44))
        {
          v15 = a1 + v13 + 84;
          goto LABEL_13;
        }
      }
      v15 = a1;
LABEL_13:
      *(_OWORD *)v15 = v21;
      *(float *)(v15 + 16) = v11;
      *(_QWORD *)(v15 + 20) = v12;
      if (++v10 == 8)
        return v8 + 28 == a2;
    }
    v7 = v8;
    v9 += 28;
    v8 += 28;
    if (v8 == a2)
      return 1;
  }
}

void qd_trimImageBorders(char **a1)
{
  int v2;
  int v3;
  char *v4;
  int v5;
  int v6;
  uint64_t v7;
  char *v8;
  int v9;
  char *v10;
  int v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  char *v16;
  size_t v17;
  int v18;
  char *v19;

  v2 = *((_DWORD *)a1 + 4);
  v3 = *((_DWORD *)a1 + 2);
  v4 = a1[3];
  v5 = (v2 + 1) >> 1;
  if (v5 >= (v3 + 1) >> 1)
    v5 = (v3 + 1) >> 1;
  if (v5 >= 4)
    v6 = 4;
  else
    v6 = v5;
  v7 = (int)v4;
  if (v5 >= 1)
  {
    v8 = *a1;
    v9 = v6;
    do
    {
      bzero(v8, (int)v4);
      v8 += (int)v4;
      --v9;
    }
    while (v9);
    v10 = &(*a1)[(v3 - v6) * (uint64_t)(int)v4];
    v11 = v6;
    do
    {
      bzero(v10, (int)v4);
      v10 += (int)v4;
      --v11;
    }
    while (v11);
  }
  v12 = v3 - 2 * v6;
  if (v12 >= 1)
  {
    v13 = (int)v4 / v2;
    v14 = v12 & ~(v12 >> 31);
    v15 = v6 * (uint64_t)(int)v4;
    v16 = &(*a1)[v15];
    v17 = v6 * v13;
    v18 = v14;
    do
    {
      bzero(v16, v17);
      v16 += v7;
      --v18;
    }
    while (v18);
    v19 = &(*a1)[v15 + (v2 - v6) * v13];
    do
    {
      bzero(v19, v17);
      v19 += v7;
      --v14;
    }
    while (v14);
  }
}

void sub_1A14F17CC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A14F1858(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A14F1988(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14F1B08(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14F21A4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14F2478(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_1A14F2638(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1A14F272C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14F2900(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A14F2BB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{

  _Unwind_Resume(a1);
}

void sub_1A14F2F64(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14F3094(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1A14F3478(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  void *v11;

  if (v11)
    operator delete(v11);
  _Unwind_Resume(a1);
}

void sub_1A14F38B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1A14F3AD8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14F3C58(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14F447C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,char a28)
{
  std::mutex *v28;

  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::pair<std::shared_ptr<cvml::util::mapped_model_file>,int>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::pair<std::shared_ptr<cvml::util::mapped_model_file>,int>>,void *>>>>::reset[abi:ne180100]((uint64_t)&a28);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a22);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a26);
  std::mutex::unlock(v28);
  if (a21 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_1A14F45C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  void *v15;
  std::mutex *v16;

  std::mutex::unlock(v16);
  if (a15 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_1A14F465C(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<cvml::util::model_file_cache>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  void *v5;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    std::mutex::~mutex((std::mutex *)(v2 + 40));
    v3 = *(_QWORD **)(v2 + 16);
    if (v3)
    {
      do
      {
        v4 = (_QWORD *)*v3;
        std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::pair<std::shared_ptr<cvml::util::mapped_model_file>,int>>,0>((uint64_t)(v3 + 2));
        operator delete(v3);
        v3 = v4;
      }
      while (v4);
    }
    v5 = *(void **)v2;
    *(_QWORD *)v2 = 0;
    if (v5)
      operator delete(v5);
    JUMPOUT(0x1A1B0A898);
  }
  return result;
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::pair<std::shared_ptr<cvml::util::mapped_model_file>,int>>,0>(uint64_t a1)
{
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](a1 + 24);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::pair<std::shared_ptr<cvml::util::mapped_model_file>,int>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::pair<std::shared_ptr<cvml::util::mapped_model_file>,int>>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::pair<std::shared_ptr<cvml::util::mapped_model_file>,int>>,0>((uint64_t)v1 + 16);
    operator delete(v1);
  }
}

void cvml::util::mapped_model_file::~mapped_model_file(cvml::util::mapped_model_file *this)
{
  *(_QWORD *)this = &off_1E4539F48;
  *((_QWORD *)this + 1) = 0;
}

{
  *(_QWORD *)this = &off_1E4539F48;
  *((_QWORD *)this + 1) = 0;
  JUMPOUT(0x1A1B0A898);
}

void cvml::util::mapped_model_file::base_address(cvml::util::mapped_model_file *this)
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
}

void cvml::util::mapped_model_file::ptrFile(cvml::util::mapped_model_file *this)
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
}

uint64_t cvml::util::mapped_model_file::cleanup(cvml::util::mapped_model_file *this)
{
  return (*(uint64_t (**)(cvml::util::mapped_model_file *))(*(_QWORD *)this + 48))(this);
}

uint64_t cvml::util::mapped_model_file::reset(uint64_t this)
{
  *(_QWORD *)(this + 8) = 0;
  return this;
}

void cvml::util::mapped_model_file_open::~mapped_model_file_open(cvml::util::mapped_model_file_open *this)
{
  *(_QWORD *)this = &off_1E4539F48;
  *((_QWORD *)this + 1) = 0;
}

{
  *(_QWORD *)this = &off_1E4539F48;
  *((_QWORD *)this + 1) = 0;
  JUMPOUT(0x1A1B0A898);
}

uint64_t cvml::util::mapped_model_file_open::base_address(cvml::util::mapped_model_file_open *this)
{
  return *((_QWORD *)this + 3);
}

uint64_t cvml::util::mapped_model_file_open::advise(cvml::util::mapped_model_file_open *this, int a2)
{
  uint64_t result;

  result = *((_QWORD *)this + 3);
  if (result)
  {
    result = madvise((void *)result, *((_QWORD *)this + 1), a2);
    if ((_DWORD)result)
    {
      syslog(3, "Error %s when executing %s in file %s:%d\n", "::madvidse failed", "virtual void cvml::util::mapped_model_file_open::advise(int) const", "/Library/Caches/com.apple.xbs/Sources/Vision/VisionKitFramework/VN/algorithm_util/mapped_model_file.h", 155);
      __assert_rtn("syslog_assert_failed", "common_defines.h", 24, "false");
    }
  }
  return result;
}

uint64_t cvml::util::mapped_model_file_open::cleanup(cvml::util::mapped_model_file_open *this)
{
  void *v2;
  size_t v3;
  int v4;

  v2 = (void *)*((_QWORD *)this + 3);
  if (v2)
  {
    v3 = *((_QWORD *)this + 1);
    if (v3)
    {
      munmap(v2, v3);
      *((_QWORD *)this + 3) = 0;
    }
  }
  v4 = *((_DWORD *)this + 4);
  if (v4 != -1)
  {
    close(v4);
    *((_DWORD *)this + 4) = -1;
  }
  return (*(uint64_t (**)(cvml::util::mapped_model_file_open *))(*(_QWORD *)this + 48))(this);
}

uint64_t cvml::util::mapped_model_file_open::reset(uint64_t this)
{
  *(_DWORD *)(this + 16) = -1;
  *(_QWORD *)(this + 24) = 0;
  *(_QWORD *)(this + 8) = 0;
  return this;
}

void std::__shared_ptr_emplace<cvml::util::mapped_model_file_open>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453B3A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<cvml::util::mapped_model_file_open>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453B3A8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A1B0A898);
}

uint64_t std::__shared_ptr_emplace<cvml::util::mapped_model_file_open>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void cvml::util::mapped_model_file_fopen::~mapped_model_file_fopen(cvml::util::mapped_model_file_fopen *this)
{
  *(_QWORD *)this = &off_1E4539F48;
  *((_QWORD *)this + 1) = 0;
}

{
  *(_QWORD *)this = &off_1E4539F48;
  *((_QWORD *)this + 1) = 0;
  JUMPOUT(0x1A1B0A898);
}

uint64_t cvml::util::mapped_model_file_fopen::ptrFile(cvml::util::mapped_model_file_fopen *this)
{
  return *((_QWORD *)this + 2);
}

uint64_t cvml::util::mapped_model_file_fopen::cleanup(cvml::util::mapped_model_file_fopen *this)
{
  FILE *v2;

  v2 = (FILE *)*((_QWORD *)this + 2);
  if (v2)
  {
    fclose(v2);
    *((_QWORD *)this + 2) = 0;
  }
  return (*(uint64_t (**)(cvml::util::mapped_model_file_fopen *))(*(_QWORD *)this + 48))(this);
}

uint64_t cvml::util::mapped_model_file_fopen::reset(uint64_t this)
{
  *(_QWORD *)(this + 8) = 0;
  *(_QWORD *)(this + 16) = 0;
  return this;
}

void std::__shared_ptr_emplace<cvml::util::mapped_model_file_fopen>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453B3E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<cvml::util::mapped_model_file_fopen>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453B3E0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A1B0A898);
}

uint64_t std::__shared_ptr_emplace<cvml::util::mapped_model_file_fopen>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void sub_1A14F4BC8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t apple::vision::libraries::autotrace::actionF(uint64_t a1, __int32 a2, int8x8_t a3, int8x8_t a4)
{
  uint64_t result;
  apple::vision::libraries::autotrace::EPolygon *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int32x2_t v18;
  int32x2_t v19;
  int32x2_t v20;
  int v21;
  BOOL v22;
  unint64_t v23;
  unint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  char *v31;
  char *v32;
  uint64_t v33;
  char *v34;
  _BYTE *v35;
  _BYTE *v36;
  int v37;
  char v38;

  result = apple::vision::libraries::autotrace::EPolygonList::newPolygon((apple::vision::libraries::autotrace::EPolygonList *)(a1 + 16), 50, 1);
  if (result)
  {
    v9 = (apple::vision::libraries::autotrace::EPolygon *)result;
    v10 = *(_QWORD *)(a1 + 24);
    result = (uint64_t)apple::vision::libraries::autotrace::EPolygon::addPointAtEnd((apple::vision::libraries::autotrace::EPolygon *)result);
    if (result)
    {
      v11 = (_QWORD *)result;
      result = (uint64_t)apple::vision::libraries::autotrace::EPolygon::addPointAtEnd(v9);
      if (result)
      {
        v18.i32[0] = 0;
        v19.i32[0] = a2;
        v20 = (int32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32(vceq_s32(v19, v18), 0), a3, a4);
        *v11 = v20;
        if (*(_BYTE *)(a1 + 40))
        {
          VNValidatedLog(4, (uint64_t)CFSTR("%s: attempt to leave an open left end when a left end is already open"), v12, v13, v14, v15, v16, v17, (uint64_t)"actionF");
          return 0;
        }
        else
        {
          v20.i32[0] = 0;
          v21 = -858993459 * (((unint64_t)v9 - v10) >> 3);
          v19.i32[0] = a2;
          *(_BYTE *)(a1 + 40) = 1;
          *(_DWORD *)(a1 + 44) = v21;
          *(_BYTE *)(a1 + 48) = a2 == 0;
          *(int8x8_t *)result = vbsl_s8((int8x8_t)vdup_lane_s32(vceq_s32(v19, v20), 0), a4, a3);
          v22 = a2 == 1;
          v24 = *(_QWORD *)(a1 + 88);
          v23 = *(_QWORD *)(a1 + 96);
          if (v24 >= v23)
          {
            v26 = *(_QWORD *)(a1 + 80);
            v27 = (uint64_t)(v24 - v26) >> 3;
            v28 = v27 + 1;
            if ((unint64_t)(v27 + 1) >> 61)
              std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
            v29 = v23 - v26;
            if (v29 >> 2 > v28)
              v28 = v29 >> 2;
            if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFF8)
              v30 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v30 = v28;
            v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v30);
            v32 = &v31[8 * v27];
            v34 = &v31[8 * v33];
            *(_DWORD *)v32 = v21;
            v32[4] = v22;
            v25 = v32 + 8;
            v36 = *(_BYTE **)(a1 + 80);
            v35 = *(_BYTE **)(a1 + 88);
            if (v35 != v36)
            {
              do
              {
                v37 = *((_DWORD *)v35 - 2);
                v35 -= 8;
                v38 = v35[4];
                *((_DWORD *)v32 - 2) = v37;
                v32 -= 8;
                v32[4] = v38;
              }
              while (v35 != v36);
              v35 = *(_BYTE **)(a1 + 80);
            }
            *(_QWORD *)(a1 + 80) = v32;
            *(_QWORD *)(a1 + 88) = v25;
            *(_QWORD *)(a1 + 96) = v34;
            if (v35)
              operator delete(v35);
          }
          else
          {
            *(_DWORD *)v24 = v21;
            *(_BYTE *)(v24 + 4) = v22;
            v25 = (char *)(v24 + 8);
          }
          *(_QWORD *)(a1 + 88) = v25;
          return 1;
        }
      }
    }
  }
  return result;
}

char *apple::vision::libraries::autotrace::actionD(uint64_t a1, float32x2_t a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  int v12;
  int v13;
  uint64_t v14;
  _DWORD *v15;
  int v16;
  int8x8_t v17;
  char *result;
  apple::vision::libraries::autotrace::EPolygon *v19;
  unint64_t v20;
  unint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  char *v28;
  char *v29;
  uint64_t v30;
  char *v31;
  _BYTE *v32;
  _BYTE *v33;
  int v34;
  char v35;

  if (!*(_BYTE *)(a1 + 40))
  {
    VNValidatedLog(4, (uint64_t)CFSTR("%s: attempt to connect to a left end when there is no left end open"), a5, a6, a7, a8, a9, a10, (uint64_t)"actionD");
    return 0;
  }
  v12 = *(_DWORD *)(a1 + 44);
  v13 = *(unsigned __int8 *)(a1 + 48);
  v14 = *(_QWORD *)(a1 + 24);
  v15 = (_DWORD *)(v14 + 40 * v12);
  if (*(_BYTE *)(a1 + 48))
    v16 = v15[4];
  else
    v16 = v15[4] + *v15 - 1;
  v17 = vmvn_s8((int8x8_t)vceq_f32(*(float32x2_t *)(*(_QWORD *)(v14 + 40 * v12 + 8) + 8 * v16), a2));
  if (((v17.i32[0] | v17.i32[1]) & 1) != 0)
  {
    VNValidatedLog(4, (uint64_t)CFSTR("%s: left end point does not match connected point"), a5, a6, a7, a8, a9, a10, (uint64_t)"actionD");
    return 0;
  }
  v19 = (apple::vision::libraries::autotrace::EPolygon *)(v14 + 40 * v12);
  if (v13)
  {
    result = apple::vision::libraries::autotrace::EPolygon::addPointAtStart(v19);
    if (!result)
      return result;
  }
  else
  {
    result = apple::vision::libraries::autotrace::EPolygon::addPointAtEnd(v19);
    if (!result)
      return result;
  }
  *(double *)result = a3;
  *(_BYTE *)(a1 + 40) = 0;
  v21 = *(_QWORD *)(a1 + 88);
  v20 = *(_QWORD *)(a1 + 96);
  if (v21 >= v20)
  {
    v23 = *(_QWORD *)(a1 + 80);
    v24 = (uint64_t)(v21 - v23) >> 3;
    v25 = v24 + 1;
    if ((unint64_t)(v24 + 1) >> 61)
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    v26 = v20 - v23;
    if (v26 >> 2 > v25)
      v25 = v26 >> 2;
    if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8)
      v27 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v27 = v25;
    v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v27);
    v29 = &v28[8 * v24];
    v31 = &v28[8 * v30];
    *(_DWORD *)v29 = v12;
    v29[4] = v13;
    v22 = v29 + 8;
    v33 = *(_BYTE **)(a1 + 80);
    v32 = *(_BYTE **)(a1 + 88);
    if (v32 != v33)
    {
      do
      {
        v34 = *((_DWORD *)v32 - 2);
        v32 -= 8;
        v35 = v32[4];
        *((_DWORD *)v29 - 2) = v34;
        v29 -= 8;
        v29[4] = v35;
      }
      while (v32 != v33);
      v32 = *(_BYTE **)(a1 + 80);
    }
    *(_QWORD *)(a1 + 80) = v29;
    *(_QWORD *)(a1 + 88) = v22;
    *(_QWORD *)(a1 + 96) = v31;
    if (v32)
      operator delete(v32);
  }
  else
  {
    *(_DWORD *)v21 = v12;
    *(_BYTE *)(v21 + 4) = v13;
    v22 = (char *)(v21 + 8);
  }
  *(_QWORD *)(a1 + 88) = v22;
  return (char *)1;
}

uint64_t apple::vision::libraries::autotrace::actionE(uint64_t a1, float32x2_t a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  int v12;
  int v13;
  uint64_t v14;
  _DWORD *v15;
  int v16;
  int8x8_t v17;
  uint64_t result;
  apple::vision::libraries::autotrace::EPolygon *v19;

  if (!*(_BYTE *)(a1 + 40))
  {
    VNValidatedLog(4, (uint64_t)CFSTR("%s: attempt to connect to a left end when there is no left end open"), a5, a6, a7, a8, a9, a10, (uint64_t)"actionE");
    return 0;
  }
  v12 = *(_DWORD *)(a1 + 44);
  v13 = *(unsigned __int8 *)(a1 + 48);
  v14 = *(_QWORD *)(a1 + 24);
  v15 = (_DWORD *)(v14 + 40 * v12);
  if (*(_BYTE *)(a1 + 48))
    v16 = v15[4];
  else
    v16 = v15[4] + *v15 - 1;
  v17 = vmvn_s8((int8x8_t)vceq_f32(*(float32x2_t *)(*(_QWORD *)(v14 + 40 * v12 + 8) + 8 * v16), a2));
  if (((v17.i32[0] | v17.i32[1]) & 1) != 0)
  {
    VNValidatedLog(4, (uint64_t)CFSTR("%s: left end point does not match connected point"), a5, a6, a7, a8, a9, a10, (uint64_t)"actionE");
    return 0;
  }
  v19 = (apple::vision::libraries::autotrace::EPolygon *)(v14 + 40 * v12);
  if (v13)
  {
    result = (uint64_t)apple::vision::libraries::autotrace::EPolygon::addPointAtStart(v19);
    if (!result)
      return result;
  }
  else
  {
    result = (uint64_t)apple::vision::libraries::autotrace::EPolygon::addPointAtEnd(v19);
    if (!result)
      return result;
  }
  *(double *)result = a3;
  result = 1;
  *(_BYTE *)(a1 + 40) = 1;
  *(_DWORD *)(a1 + 44) = v12;
  *(_BYTE *)(a1 + 48) = v13;
  return result;
}

uint64_t apple::vision::libraries::autotrace::actionB(uint64_t a1, float32x2_t a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v12;
  int *v13;
  int v14;
  char v15;
  uint64_t v16;
  _DWORD *v17;
  int v18;
  int8x8_t v19;
  uint64_t result;
  apple::vision::libraries::autotrace::EPolygon *v21;

  if (*(_BYTE *)(a1 + 40))
  {
    VNValidatedLog(4, (uint64_t)CFSTR("%s: no connection to open left end"), a5, a6, a7, a8, a9, a10, (uint64_t)"actionB");
    return 0;
  }
  v12 = *(int *)(a1 + 52);
  v13 = (int *)(*(_QWORD *)(a1 + 56) + 8 * v12);
  *(_DWORD *)(a1 + 52) = v12 + 1;
  v14 = *v13;
  v15 = *((_BYTE *)v13 + 4);
  v16 = *(_QWORD *)(a1 + 24);
  v17 = (_DWORD *)(v16 + 40 * *v13);
  if (v15)
    v18 = v17[4];
  else
    v18 = v17[4] + *v17 - 1;
  v19 = vmvn_s8((int8x8_t)vceq_f32(*(float32x2_t *)(*(_QWORD *)(v16 + 40 * v14 + 8) + 8 * v18), a2));
  if (((v19.i32[0] | v19.i32[1]) & 1) != 0)
  {
    VNValidatedLog(4, (uint64_t)CFSTR("%s: top open end point does not match connected point"), a5, a6, a7, a8, a9, a10, (uint64_t)"actionB");
    return 0;
  }
  v21 = (apple::vision::libraries::autotrace::EPolygon *)(v16 + 40 * v14);
  if (!*((_BYTE *)v13 + 4))
  {
    result = (uint64_t)apple::vision::libraries::autotrace::EPolygon::addPointAtEnd(v21);
    if (!result)
      return result;
LABEL_14:
    *(double *)result = a3;
    result = 1;
    *(_BYTE *)(a1 + 40) = 1;
    *(_DWORD *)(a1 + 44) = v14;
    *(_BYTE *)(a1 + 48) = v15;
    return result;
  }
  result = (uint64_t)apple::vision::libraries::autotrace::EPolygon::addPointAtStart(v21);
  if (result)
    goto LABEL_14;
  return result;
}

char *apple::vision::libraries::autotrace::actionC(uint64_t a1, float32x2_t a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v12;
  int *v13;
  int v14;
  char v15;
  uint64_t v16;
  _DWORD *v17;
  int v18;
  int8x8_t v19;
  char *result;
  apple::vision::libraries::autotrace::EPolygon *v21;
  unint64_t v22;
  unint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char *v30;
  char *v31;
  uint64_t v32;
  char *v33;
  _BYTE *v34;
  _BYTE *v35;
  int v36;
  char v37;

  if (*(_BYTE *)(a1 + 40))
  {
    VNValidatedLog(4, (uint64_t)CFSTR("%s: no connection to open left end"), a5, a6, a7, a8, a9, a10, (uint64_t)"actionC");
    return 0;
  }
  v12 = *(int *)(a1 + 52);
  v13 = (int *)(*(_QWORD *)(a1 + 56) + 8 * v12);
  *(_DWORD *)(a1 + 52) = v12 + 1;
  v14 = *v13;
  v15 = *((_BYTE *)v13 + 4);
  v16 = *(_QWORD *)(a1 + 24);
  v17 = (_DWORD *)(v16 + 40 * *v13);
  if (v15)
    v18 = v17[4];
  else
    v18 = v17[4] + *v17 - 1;
  v19 = vmvn_s8((int8x8_t)vceq_f32(*(float32x2_t *)(*(_QWORD *)(v16 + 40 * v14 + 8) + 8 * v18), a2));
  if (((v19.i32[0] | v19.i32[1]) & 1) != 0)
  {
    VNValidatedLog(4, (uint64_t)CFSTR("%s: top open end point does not match connected point"), a5, a6, a7, a8, a9, a10, (uint64_t)"actionC");
    return 0;
  }
  v21 = (apple::vision::libraries::autotrace::EPolygon *)(v16 + 40 * v14);
  if (*((_BYTE *)v13 + 4))
  {
    result = apple::vision::libraries::autotrace::EPolygon::addPointAtStart(v21);
    if (!result)
      return result;
  }
  else
  {
    result = apple::vision::libraries::autotrace::EPolygon::addPointAtEnd(v21);
    if (!result)
      return result;
  }
  *(double *)result = a3;
  *(_BYTE *)(a1 + 40) = 0;
  v23 = *(_QWORD *)(a1 + 88);
  v22 = *(_QWORD *)(a1 + 96);
  if (v23 >= v22)
  {
    v25 = *(_QWORD *)(a1 + 80);
    v26 = (uint64_t)(v23 - v25) >> 3;
    v27 = v26 + 1;
    if ((unint64_t)(v26 + 1) >> 61)
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    v28 = v22 - v25;
    if (v28 >> 2 > v27)
      v27 = v28 >> 2;
    if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFF8)
      v29 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v29 = v27;
    v30 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v29);
    v31 = &v30[8 * v26];
    v33 = &v30[8 * v32];
    *(_DWORD *)v31 = v14;
    v31[4] = v15;
    v24 = v31 + 8;
    v35 = *(_BYTE **)(a1 + 80);
    v34 = *(_BYTE **)(a1 + 88);
    if (v34 != v35)
    {
      do
      {
        v36 = *((_DWORD *)v34 - 2);
        v34 -= 8;
        v37 = v34[4];
        *((_DWORD *)v31 - 2) = v36;
        v31 -= 8;
        v31[4] = v37;
      }
      while (v34 != v35);
      v34 = *(_BYTE **)(a1 + 80);
    }
    *(_QWORD *)(a1 + 80) = v31;
    *(_QWORD *)(a1 + 88) = v24;
    *(_QWORD *)(a1 + 96) = v33;
    if (v34)
      operator delete(v34);
  }
  else
  {
    *(_DWORD *)v23 = v14;
    *(_BYTE *)(v23 + 4) = v15;
    v24 = (char *)(v23 + 8);
  }
  *(_QWORD *)(a1 + 88) = v24;
  return (char *)1;
}

char *apple::vision::libraries::autotrace::actionA(uint64_t a1, float32x2_t a2, float32x2_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v12;
  uint64_t v13;
  int v14;
  _BYTE *v15;
  uint64_t v16;
  int v17;
  int v18;
  _DWORD *v19;
  uint64_t v20;
  char *v21;
  float32x2_t **v22;
  char *v23;
  int8x8_t v24;
  int8x8_t v25;
  apple::vision::libraries::autotrace::EPolygon *v26;
  char *result;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int *v34;
  uint64_t v35;
  float32x2_t *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  float32x2_t *v43;
  uint64_t v44;
  uint64_t v45;
  float v46;
  uint64_t v47;
  int v48;
  float32x2_t v49;
  float32x2_t v50;
  uint64_t v51;
  int v52;
  int v53;
  float32x2_t v54;
  int32x2_t v55;
  int v56;
  uint64_t v57;
  float v58;
  float v59;
  float32x2_t *v60;
  float32x2_t v61;
  float32x2_t v62;
  float32x2_t v63;
  float32x2_t v64;
  int *v65;
  int *v66;
  EPolygon *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  apple::vision::libraries::autotrace::EPolygon *v73;
  int v74;
  uint64_t v75;
  void **v76;
  uint64_t v77;
  float32x2_t v78;
  int v79;
  int v80;
  uint64_t v81;
  void **v82;
  uint64_t v83;
  int8x8_t v84;
  int v85;
  char *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  char *v93;
  void *v94;
  uint64_t v95;
  _DWORD *v96;
  uint64_t v97;
  int *v98;
  int *v99;
  int *v100;
  int *v101;
  int v102;
  int v103;
  uint64_t v104;
  double v105;
  EPolygon *v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  unsigned int *v112;
  apple::vision::libraries::autotrace::EPolygon *v113;
  int v114;
  _DWORD *v115;
  uint64_t v116;
  unint64_t v117;
  _DWORD *v118;
  uint64_t v119;
  unint64_t v120;
  int v121;
  int v122;
  apple::vision::libraries::autotrace::EPolygon *v123;

  if (*(_BYTE *)(a1 + 40))
  {
    v12 = *(int *)(a1 + 52);
    v13 = *(_QWORD *)(a1 + 56) + 8 * v12;
    *(_DWORD *)(a1 + 52) = v12 + 1;
    v14 = *(_DWORD *)v13;
    v15 = (_BYTE *)(v13 + 4);
    v16 = *(_QWORD *)(a1 + 24);
    if (*(_BYTE *)(v13 + 4))
    {
      v17 = *(_DWORD *)(v16 + 40 * v14 + 16);
      v18 = v17;
    }
    else
    {
      v19 = (_DWORD *)(v16 + 40 * v14);
      v17 = v19[4];
      v18 = v17 + *v19 - 1;
    }
    v20 = v16 + 40 * v14;
    v23 = *(char **)(v20 + 8);
    v22 = (float32x2_t **)(v20 + 8);
    v21 = v23;
    v24 = vmvn_s8((int8x8_t)vceq_f32(*(float32x2_t *)&v23[8 * v18], a2));
    if (((v24.i32[0] | v24.i32[1]) & 1) != 0)
    {
      VNValidatedLog(4, (uint64_t)CFSTR("%s: top open end point does not match connected point"), a5, a6, a7, a8, a9, a10, (uint64_t)"actionA");
      return 0;
    }
    if (*(unsigned __int8 *)(a1 + 48) == *(unsigned __int8 *)(v13 + 4))
    {
      VNValidatedLog(4, (uint64_t)CFSTR("%s: polygon front/back ends should be opposite on closure"), a5, a6, a7, a8, a9, a10, (uint64_t)"actionA");
      return 0;
    }
    if (*(_DWORD *)(a1 + 44) == v14)
    {
      if (!*(_BYTE *)(a1 + 48))
        v17 = v17 + *(_DWORD *)(v16 + 40 * v14) - 1;
      v25 = vmvn_s8((int8x8_t)vceq_f32(*(float32x2_t *)&v21[8 * v17], a3));
      if (((v25.i32[0] | v25.i32[1]) & 1) != 0)
      {
        VNValidatedLog(4, (uint64_t)CFSTR("%s: left end point does not match connected point"), a5, a6, a7, a8, a9, a10, (uint64_t)"actionA");
        return 0;
      }
      v34 = (int *)(v16 + 40 * v14);
      v35 = *v34;
      v36 = (float32x2_t *)malloc_type_malloc(8 * v35, 0x100004000313F17uLL);
      if (!v36)
      {
        VNValidatedLog(4, (uint64_t)CFSTR("%s: could not trim extract polygons point list"), v37, v38, v39, v40, v41, v42, (uint64_t)"closePolygon");
        return 0;
      }
      v43 = v36;
      v44 = v16 + 40 * v14;
      memmove(v36, &v21[8 * *(int *)(v44 + 16)], 8 * v35);
      *(_DWORD *)(v44 + 16) = 0;
      *(_DWORD *)(v44 + 4) = v35;
      free(v21);
      *v22 = v43;
      *(_BYTE *)(v44 + 20) = 1;
      v45 = *v34;
      v46 = *(float *)(a1 + 8) * *(float *)(a1 + 8);
      if ((int)v45 >= 1)
      {
        v47 = 0;
        v48 = 0;
        while (v47)
        {
          v49 = vsub_f32(v43[v47], v43[v47 - 1]);
          if (vmlas_n_f32(COERCE_FLOAT(vmul_f32(v49, v49).i32[1]), v49.f32[0], v49.f32[0]) > v46)
          {
            if (v47 != v48)
            {
              v50 = v43[v47];
              goto LABEL_27;
            }
            goto LABEL_28;
          }
LABEL_29:
          if (v45 == ++v47)
            goto LABEL_38;
        }
        if (v48)
        {
          v50 = *v43;
LABEL_27:
          v43[v48] = v50;
        }
LABEL_28:
        ++v48;
        goto LABEL_29;
      }
      v48 = 0;
LABEL_38:
      v54 = vsub_f32(*v43, v43[(int)v45 - 1]);
      v55 = (int32x2_t)vmul_f32(v54, v54);
      v56 = v48 - (vmlas_n_f32(*(float *)&v55.i32[1], v54.f32[0], v54.f32[0]) <= v46);
      *v34 = v56;
      if (v56 > 2)
      {
        if (*(_BYTE *)a1)
        {
          v57 = 0;
          v55.i32[0] = *(_DWORD *)(a1 + 4);
          v58 = (float)(*(float *)v55.i32 * 2.0) + -2.0;
          v59 = (float)(*(float *)v55.i32 * -3.0) + 3.0;
          v60 = *v22;
          v61 = (float32x2_t)vdup_lane_s32(v55, 0);
          do
          {
            v62 = v60[v57];
            v63 = vrndm_f32(v62);
            v64 = vsub_f32(v62, v63);
            v60[v57++] = vadd_f32(v63, vmla_f32(vmla_f32(vmul_f32(v64, vmul_n_f32(v64, v59)), v64, vmul_f32(v64, vmul_n_f32(v64, v58))), v64, v61));
          }
          while ((int)v57 < *v34);
        }
        if (*(_BYTE *)(a1 + 144))
        {
          v65 = (int *)(a1 + 16);
          v66 = (int *)apple::vision::libraries::autotrace::EPolygonList::containsPolygon((apple::vision::libraries::autotrace::EPolygonList *)(a1 + 16), (EPolygon *)v34);
          if (v66)
          {
            do
            {
              v73 = (apple::vision::libraries::autotrace::EPolygon *)v66;
              v74 = v66[7];
              if (v74 == -1)
                break;
              v66 = (int *)apple::vision::libraries::autotrace::EPolygonList::containsPolygonInChildList((apple::vision::libraries::autotrace::EPolygonList *)(a1 + 16), v74, v67, **((double **)v34 + 1));
            }
            while (v66);
            apple::vision::libraries::autotrace::EPolygonList::insertPolygon((apple::vision::libraries::autotrace::EPolygonList *)(a1 + 16), v73, (apple::vision::libraries::autotrace::EPolygon *)v34, v68, v69, v70, v71, v72);
          }
          else
          {
            v102 = *v65;
            if (*v65 >= 1)
            {
              v103 = 0;
              v104 = *(_QWORD *)(a1 + 24);
              do
              {
                if ((int *)v104 != v34 && !*(_BYTE *)(v104 + 21))
                {
                  if (*(_BYTE *)(v104 + 20))
                  {
                    v105 = **(double **)(v104 + 8);
                    if (apple::vision::libraries::autotrace::EPolygon::containsPoint((unsigned int *)v34, v105))
                    {
                      v112 = (unsigned int *)v34;
                      do
                      {
                        v113 = (apple::vision::libraries::autotrace::EPolygon *)v112;
                        v114 = v112[7];
                        if (v114 == -1)
                          break;
                        v112 = apple::vision::libraries::autotrace::EPolygonList::containsPolygonInChildList((apple::vision::libraries::autotrace::EPolygonList *)(a1 + 16), v114, v106, v105);
                      }
                      while (v112);
                      apple::vision::libraries::autotrace::EPolygonList::insertPolygon((apple::vision::libraries::autotrace::EPolygonList *)(a1 + 16), v113, (apple::vision::libraries::autotrace::EPolygon *)v104, v107, v108, v109, v110, v111);
                      v102 = *v65;
                    }
                  }
                }
                ++v103;
                v104 += 40;
              }
              while (v103 < v102);
            }
          }
        }
      }
      else
      {
        apple::vision::libraries::autotrace::EPolygonList::freePolygon((apple::vision::libraries::autotrace::EPolygonList *)(a1 + 16), (apple::vision::libraries::autotrace::EPolygon *)v34);
      }
    }
    else
    {
      v26 = (apple::vision::libraries::autotrace::EPolygon *)(v16 + 40 * v14);
      if (*(_BYTE *)(v13 + 4))
      {
        result = apple::vision::libraries::autotrace::EPolygon::addPointAtStart(v26);
        if (!result)
          return result;
      }
      else
      {
        result = apple::vision::libraries::autotrace::EPolygon::addPointAtEnd(v26);
        if (!result)
          return result;
      }
      *(double *)result = *(double *)&a3;
      if (*v15 == *(_BYTE *)(a1 + 48))
      {
        VNValidatedLog(4, (uint64_t)CFSTR("%s: join polygons occurs at wrong ends"), v28, v29, v30, v31, v32, v33, (uint64_t)"joinOpenEnds");
        return 0;
      }
      v51 = *(_QWORD *)(a1 + 24);
      v52 = *(_DWORD *)v13;
      if (*v15)
        v53 = *(_DWORD *)(v51 + 40 * v52 + 16);
      else
        v53 = *(_DWORD *)(v51 + 40 * v52 + 16) + *(_DWORD *)(v51 + 40 * v52) - 1;
      v75 = v51 + 40 * v52;
      v77 = *(_QWORD *)(v75 + 8);
      v76 = (void **)(v75 + 8);
      v78 = *(float32x2_t *)(v77 + 8 * v53);
      v79 = *(_DWORD *)(a1 + 44);
      if (*(_BYTE *)(a1 + 48))
        v80 = *(_DWORD *)(v51 + 40 * v79 + 16);
      else
        v80 = *(_DWORD *)(v51 + 40 * v79 + 16) + *(_DWORD *)(v51 + 40 * v79) - 1;
      v81 = v51 + 40 * v79;
      v83 = *(_QWORD *)(v81 + 8);
      v82 = (void **)(v81 + 8);
      v84 = vmvn_s8((int8x8_t)vceq_f32(v78, *(float32x2_t *)(v83 + 8 * v80)));
      if (((v84.i32[0] | v84.i32[1]) & 1) != 0)
      {
        VNValidatedLog(4, (uint64_t)CFSTR("%s: join polygons point does not match connected point"), v28, v29, v30, v31, v32, v33, (uint64_t)"joinOpenEnds");
        return 0;
      }
      v123 = (apple::vision::libraries::autotrace::EPolygon *)(v51 + 40 * v52);
      v85 = *(_DWORD *)(v51 + 40 * v79) + *(_DWORD *)v123;
      v122 = v85 + 99;
      v86 = (char *)malloc_type_malloc(8 * (v85 + 99), 0x100004000313F17uLL);
      if (!v86)
      {
        VNValidatedLog(4, (uint64_t)CFSTR("%s: could not extend extract polygons point list"), v87, v88, v89, v90, v91, v92, (uint64_t)"joinOpenEnds");
        return 0;
      }
      v93 = v86;
      v94 = v86 + 400;
      v121 = v85 - 1;
      if (*v15)
      {
        v95 = v51 + 40 * v79;
        v97 = *(int *)(v95 + 16);
        v96 = (_DWORD *)(v95 + 16);
        v98 = (int *)(v51 + 40 * v79);
        memmove(v94, (char *)*v82 + 8 * v97, 8 * *v98 - 8);
        v99 = (int *)(v51 + 40 * v52 + 16);
        v100 = v98;
        v101 = (int *)(v51 + 40 * v52);
      }
      else
      {
        memmove(v94, (char *)*v76 + 8 * *(int *)(v51 + 40 * v52 + 16), 8 * *(int *)v123 - 8);
        v100 = (int *)(v51 + 40 * v52);
        v99 = (int *)(v51 + 40 * v79 + 16);
        v76 = v82;
        v98 = (int *)(v51 + 40 * v79);
        v101 = v98;
        v96 = v99;
      }
      memmove(&v93[8 * *v100 + 392], (char *)*v76 + 8 * *v99, 8 * *v101);
      *v96 = 50;
      *v98 = v121;
      *(_DWORD *)(v51 + 40 * v79 + 4) = v122;
      free(*v82);
      *v82 = v93;
      apple::vision::libraries::autotrace::EPolygonList::freePolygon((apple::vision::libraries::autotrace::EPolygonList *)(a1 + 16), v123);
      v115 = *(_DWORD **)(a1 + 56);
      v116 = *(_QWORD *)(a1 + 64) - (_QWORD)v115;
      if (v116)
      {
        v117 = v116 >> 3;
        if (v117 <= 1)
          v117 = 1;
        do
        {
          if (*v115 == v52)
            *v115 = v79;
          v115 += 2;
          --v117;
        }
        while (v117);
      }
      v118 = *(_DWORD **)(a1 + 80);
      v119 = *(_QWORD *)(a1 + 88) - (_QWORD)v118;
      if (v119)
      {
        v120 = v119 >> 3;
        if (v120 <= 1)
          v120 = 1;
        do
        {
          if (*v118 == v52)
            *v118 = v79;
          v118 += 2;
          --v120;
        }
        while (v120);
      }
      if (*(_DWORD *)(a1 + 44) == v52)
        *(_DWORD *)(a1 + 44) = v79;
    }
    *(_BYTE *)(a1 + 40) = 0;
    return (char *)1;
  }
  VNValidatedLog(4, (uint64_t)CFSTR("%s: attempt to connect to a left end when there is no left end open"), a5, a6, a7, a8, a9, a10, (uint64_t)"actionA");
  return 0;
}

void apple::vision::libraries::autotrace::encodePolygonData(apple::vision::libraries::autotrace *this, apple::vision::libraries::autotrace::BitmapToContourEnvironment *a2, apple::vision::libraries::autotrace::EPolygon *a3)
{
  apple::vision::libraries::autotrace::BitString *v4;
  char *v5;
  int *v6;
  float32x2_t *v7;
  float64x2_t v8;
  uint64_t v9;
  int32x2_t v10;
  __int16 *v11;
  uint64_t v12;
  float32x2_t *v13;
  _WORD *v14;
  float32x2_t v15;
  int32x2_t v16;
  int32x2_t v17;
  unsigned int v18;
  int v19;
  unsigned int v20;
  int v21;
  unsigned int v22;
  int v23;
  unsigned int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  uint64_t v32;
  signed int v33;
  int v34;
  __int16 *v35;
  int v36;
  int v37;
  unsigned int v38;
  int v39;
  uint64_t v40;
  signed int v41;
  int v42;
  __int16 *v43;
  int v44;
  int v45;
  unsigned int v46;
  int v47;
  unsigned int v48;
  int v49;
  int v50;
  unsigned int v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  __int16 *v56;
  int v57;
  uint64_t v58;
  int v59;
  unsigned int v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  int v68;
  __int16 *v69;
  int v70;
  unsigned int v71;
  apple::vision::libraries::autotrace::EPolygon *v72;
  int i;
  apple::vision::libraries::autotrace::BitmapToContourEnvironment *v74;
  apple::vision::libraries::autotrace::BitmapToContourEnvironment *v76;
  int32x2_t v77;

  v4 = (apple::vision::libraries::autotrace *)((char *)this + 104);
  v5 = (char *)malloc_type_malloc(4 * *(_DWORD *)a2 + 8, 0xB5F44F28uLL);
  v6 = (int *)v5;
  v7 = (float32x2_t *)*((_QWORD *)a2 + 1);
  v8 = (float64x2_t)vdupq_n_s64(0x4070000000000000uLL);
  v76 = a2;
  v9 = *(unsigned int *)a2;
  v10 = vmovn_s64(vcvtq_s64_f64(vrndxq_f64(vmulq_f64(vcvtq_f64_f32(*v7), v8))));
  *(_DWORD *)v5 = v9;
  v77 = v10;
  *(int32x2_t *)(v5 + 4) = v10;
  v11 = (__int16 *)(v5 + 12);
  if ((int)v9 >= 2)
  {
    v12 = v9 - 1;
    v13 = v7 + 1;
    v14 = v5 + 12;
    do
    {
      v15 = *v13++;
      v16 = vmovn_s64(vcvtq_s64_f64(vrndxq_f64(vmulq_f64(vcvtq_f64_f32(v15), v8))));
      v17 = vsub_s32(v16, v10);
      v14[1] = v17.i16[2];
      *v14 = v17.i16[0];
      v14 += 2;
      v10 = v16;
      --v12;
    }
    while (v12);
  }
  apple::vision::libraries::autotrace::BitString::writeBit(v4, 0);
  v18 = 0x80000000;
  v19 = 32;
  do
  {
    apple::vision::libraries::autotrace::BitString::writeBit(v4, (v18 & v9) != 0);
    v18 >>= 1;
    --v19;
  }
  while (v19);
  v20 = 0x80000000;
  v21 = 32;
  do
  {
    apple::vision::libraries::autotrace::BitString::writeBit(v4, (v20 & v77.i32[0]) != 0);
    v20 >>= 1;
    --v21;
  }
  while (v21);
  v22 = 0x80000000;
  v23 = 32;
  do
  {
    apple::vision::libraries::autotrace::BitString::writeBit(v4, (v22 & v77.i32[1]) != 0);
    v22 >>= 1;
    --v23;
  }
  while (v23);
  v24 = 8;
  v25 = 4;
  do
  {
    apple::vision::libraries::autotrace::BitString::writeBit(v4, v24 > 7);
    v24 >>= 1;
    --v25;
  }
  while (v25);
  v26 = *v6;
  if (*v6 >= 2)
  {
    v27 = 1;
    do
    {
      v28 = v26 - 1;
      v29 = *v11;
      if (v27 >= v26 - 1)
      {
        v30 = 0;
        v31 = 0;
      }
      else
      {
        v30 = v11[2] + v29;
        v31 = v11[3] + v11[1];
      }
      v32 = 4294967040;
      if (v29 == -256 || v30 == -256 || v30 == -512 || (v32 = 256, v29 == 256) || v30 == 256 || v30 == 512)
      {
        v34 = v27;
        if (v27 < v26)
        {
          v35 = v11;
          v34 = v27;
          do
          {
            v36 = *v35;
            if (v34 >= v28)
              v37 = 0;
            else
              v37 = v35[2] + v36;
            if ((_DWORD)v32 == v36)
            {
              v38 = 1;
            }
            else
            {
              v38 = 2;
              if (v37 != (_DWORD)v32 && v37 != 2 * (_DWORD)v32)
                break;
            }
            v34 += v38;
            v35 += 2 * v38;
          }
          while (v34 < v26);
        }
        v33 = v34 - v27;
      }
      else
      {
        v32 = 0;
        v33 = 0;
      }
      v39 = (unsigned __int16)v11[1];
      v40 = 4294967040;
      if (v39 == 65280 || v31 == -256 || v31 == -512 || (v40 = 256, v39 == 256) || v31 == 256 || v31 == 512)
      {
        v42 = v27;
        if (v27 < v26)
        {
          v43 = v11;
          v42 = v27;
          do
          {
            v44 = v43[1];
            if (v42 >= v28)
              v45 = 0;
            else
              v45 = v43[3] + v44;
            if ((_DWORD)v40 == v44)
            {
              v46 = 1;
            }
            else
            {
              v46 = 2;
              if (v45 != (_DWORD)v40 && v45 != 2 * (_DWORD)v40)
                break;
            }
            v42 += v46;
            v43 += 2 * v46;
          }
          while (v42 < v26);
        }
        v41 = v42 - v27;
      }
      else
      {
        v40 = 0;
        v41 = 0;
      }
      if (v33 | v41)
      {
        if (v33 >= v41)
        {
          apple::vision::libraries::autotrace::encodeRunStart(v4, 0, v32, v33);
          v67 = *v6;
          v68 = v27;
          if (v27 < *v6)
          {
            v69 = v11;
            v68 = v27;
            do
            {
              v61 = *v69;
              if (v68 >= v67 - 1)
                v70 = 0;
              else
                v70 = v69[2] + (_DWORD)v61;
              if ((_DWORD)v32 == (_DWORD)v61)
              {
                apple::vision::libraries::autotrace::encodeRunContinuationOneSample(v4, (apple::vision::libraries::autotrace::BitString *)v69[1]);
                v71 = 1;
              }
              else
              {
                if (v70 != (_DWORD)v32 && v70 != 2 * (_DWORD)v32)
                  break;
                apple::vision::libraries::autotrace::encodeRunContinuationTwoSamples(v4, (apple::vision::libraries::autotrace::BitString *)v32, v61, v69[2], v69[1], v69[3], v65, v66);
                v71 = 2;
              }
              v68 += v71;
              v69 += 2 * v71;
              v67 = *v6;
            }
            while (v68 < *v6);
          }
          if (v68 - v27 != v33)
            VNValidatedLog(4, (uint64_t)CFSTR("%s: run length doesn't match up (%d vs %d) for an x run direction %d"), v61, v62, v63, v64, v65, v66, (uint64_t)"encodePolygonData");
        }
        else
        {
          apple::vision::libraries::autotrace::encodeRunStart(v4, (apple::vision::libraries::autotrace::BitString *)1, v40, v41);
          v55 = *v6;
          if (v27 < *v6)
          {
            v56 = v11;
            v57 = v27;
            do
            {
              v58 = v56[1];
              if (v57 >= v55 - 1)
                v59 = 0;
              else
                v59 = v56[3] + (_DWORD)v58;
              if ((_DWORD)v40 == (_DWORD)v58)
              {
                apple::vision::libraries::autotrace::encodeRunContinuationOneSample(v4, (apple::vision::libraries::autotrace::BitString *)*v56);
                v60 = 1;
              }
              else
              {
                if (v59 != (_DWORD)v40 && v59 != 2 * (_DWORD)v40)
                  break;
                apple::vision::libraries::autotrace::encodeRunContinuationTwoSamples(v4, (apple::vision::libraries::autotrace::BitString *)v40, v58, v56[3], *v56, v56[2], v53, v54);
                v60 = 2;
              }
              v57 += v60;
              v56 += 2 * v60;
              v55 = *v6;
            }
            while (v57 < *v6);
          }
          v33 = v41;
        }
      }
      else
      {
        apple::vision::libraries::autotrace::BitString::writeBit(v4, 0);
        v47 = (unsigned __int16)v29 + 512;
        v48 = 512;
        v49 = 10;
        do
        {
          apple::vision::libraries::autotrace::BitString::writeBit(v4, (v48 & v47) != 0);
          v48 >>= 1;
          --v49;
        }
        while (v49);
        v50 = v39 + 512;
        v51 = 512;
        v52 = 10;
        do
        {
          apple::vision::libraries::autotrace::BitString::writeBit(v4, (v51 & v50) != 0);
          v51 >>= 1;
          --v52;
        }
        while (v52);
        v33 = 1;
      }
      v27 += v33;
      v11 += 2 * v33;
      v26 = *v6;
    }
    while (v27 < *v6);
  }
  if (*((_DWORD *)v76 + 7) != -1)
  {
    apple::vision::libraries::autotrace::BitString::writeBit(v4, 1);
    apple::vision::libraries::autotrace::BitString::writeBit(v4, 0);
    for (i = *((_DWORD *)v76 + 7); i != -1; i = *((_DWORD *)v74 + 6))
    {
      v74 = (apple::vision::libraries::autotrace::BitmapToContourEnvironment *)(*((_QWORD *)this + 3) + 40 * i);
      apple::vision::libraries::autotrace::encodePolygonData(this, v74, v72);
    }
    apple::vision::libraries::autotrace::BitString::writeBit(v4, 1);
    apple::vision::libraries::autotrace::BitString::writeBit(v4, 1);
  }
  free(v6);
}

void apple::vision::libraries::autotrace::BitmapToContourEnvironment::~BitmapToContourEnvironment(apple::vision::libraries::autotrace::BitmapToContourEnvironment *this)
{
  void *v2;
  void *v3;
  void *v4;

  apple::vision::libraries::autotrace::EPolygonList::term((apple::vision::libraries::autotrace::BitmapToContourEnvironment *)((char *)this + 16));
  v2 = (void *)*((_QWORD *)this + 13);
  if (v2)
  {
    *((_QWORD *)this + 14) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 10);
  if (v3)
  {
    *((_QWORD *)this + 11) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 7);
  if (v4)
  {
    *((_QWORD *)this + 8) = v4;
    operator delete(v4);
  }
}

void apple::vision::libraries::autotrace::encodeRunStart(apple::vision::libraries::autotrace *this, apple::vision::libraries::autotrace::BitString *a2, int a3, unsigned int a4)
{
  int v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  unsigned int v16;
  int v17;
  unsigned int v18;
  const __CFString *v19;
  int v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  int v24;
  unsigned int v25;
  int v26;

  v6 = (int)a2;
  apple::vision::libraries::autotrace::BitString::writeBit(this, 1);
  if (v6)
  {
    if (a3 == -256)
    {
      v17 = 2;
      v18 = 2;
      do
      {
        apple::vision::libraries::autotrace::BitString::writeBit(this, v18 > 1);
        v18 >>= 1;
        --v17;
      }
      while (v17);
      goto LABEL_21;
    }
    if (a3 == 256)
    {
      v14 = 2;
      do
      {
        apple::vision::libraries::autotrace::BitString::writeBit(this, 1);
        --v14;
      }
      while (v14);
      goto LABEL_21;
    }
    v19 = CFSTR("%s: illegal direction %d in y run");
  }
  else
  {
    if (a3 == -256)
    {
      v20 = 2;
      do
      {
        apple::vision::libraries::autotrace::BitString::writeBit(this, 0);
        --v20;
      }
      while (v20);
      goto LABEL_21;
    }
    if (a3 == 256)
    {
      v15 = 2;
      v16 = 2;
      do
      {
        apple::vision::libraries::autotrace::BitString::writeBit(this, v16 & 1);
        v16 >>= 1;
        --v15;
      }
      while (v15);
      goto LABEL_21;
    }
    v19 = CFSTR("%s: illegal direction %d in x run");
  }
  VNValidatedLog(4, (uint64_t)v19, v8, v9, v10, v11, v12, v13, (uint64_t)"encodeRunStart");
LABEL_21:
  if (a4 >= 0x10)
  {
    v24 = 4;
    do
    {
      apple::vision::libraries::autotrace::BitString::writeBit(this, 1);
      --v24;
    }
    while (v24);
    v25 = 0x80000000;
    v26 = 32;
    do
    {
      apple::vision::libraries::autotrace::BitString::writeBit(this, (v25 & a4) != 0);
      v25 >>= 1;
      --v26;
    }
    while (v26);
  }
  else
  {
    v21 = a4 - 1;
    v22 = 8;
    v23 = 4;
    do
    {
      apple::vision::libraries::autotrace::BitString::writeBit(this, (v22 & v21) != 0);
      v22 >>= 1;
      --v23;
    }
    while (v23);
  }
}

void apple::vision::libraries::autotrace::encodeRunContinuationOneSample(apple::vision::libraries::autotrace *this, apple::vision::libraries::autotrace::BitString *a2)
{
  int v2;
  unsigned int v4;
  int v5;
  int v6;
  int v7;
  unsigned int v8;

  v2 = (int)a2;
  apple::vision::libraries::autotrace::BitString::writeBit(this, 0);
  if (v2 >= 0)
    v4 = v2;
  else
    v4 = -v2;
  v5 = 5;
  if (v4 >= 0x10)
  {
    do
    {
      apple::vision::libraries::autotrace::BitString::writeBit(this, 1);
      --v5;
    }
    while (v5);
    v5 = 10;
    v6 = 512;
  }
  else
  {
    v6 = 15;
  }
  v7 = v6 + v2;
  v8 = 1 << (v5 - 1);
  do
  {
    apple::vision::libraries::autotrace::BitString::writeBit(this, (v8 & v7) != 0);
    v8 >>= 1;
    --v5;
  }
  while (v5);
}

void apple::vision::libraries::autotrace::encodeRunContinuationTwoSamples(apple::vision::libraries::autotrace *this, apple::vision::libraries::autotrace::BitString *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  int v9;
  int v10;
  int v12;
  unsigned int v13;
  int v14;
  int v15;
  unsigned int v16;
  int v17;
  int v18;
  unsigned int v19;
  int v20;
  int v21;
  unsigned int v22;
  int v23;

  v8 = a6;
  v9 = a5;
  v10 = a3;
  if ((_DWORD)a4 + (_DWORD)a3 == (_DWORD)a2)
  {
    v12 = 2;
    v13 = 2;
    do
    {
      apple::vision::libraries::autotrace::BitString::writeBit(this, v13 > 1);
      v13 >>= 1;
      --v12;
    }
    while (v12);
  }
  else if ((_DWORD)a4 + (_DWORD)a3 == 2 * (_DWORD)a2)
  {
    v14 = 2;
    do
    {
      apple::vision::libraries::autotrace::BitString::writeBit(this, 1);
      --v14;
    }
    while (v14);
  }
  else
  {
    VNValidatedLog(4, (uint64_t)CFSTR("%s: illegal two sample direction sum along run"), a3, a4, a5, a6, a7, a8, (uint64_t)"encodeRunContinuationTwoSamples");
  }
  v15 = v10 + 512;
  v16 = 512;
  v17 = 10;
  do
  {
    apple::vision::libraries::autotrace::BitString::writeBit(this, (v16 & v15) != 0);
    v16 >>= 1;
    --v17;
  }
  while (v17);
  v18 = v9 + 512;
  v19 = 512;
  v20 = 10;
  do
  {
    apple::vision::libraries::autotrace::BitString::writeBit(this, (v19 & v18) != 0);
    v19 >>= 1;
    --v20;
  }
  while (v20);
  v21 = v8 + 512;
  v22 = 512;
  v23 = 10;
  do
  {
    apple::vision::libraries::autotrace::BitString::writeBit(this, (v22 & v21) != 0);
    v22 >>= 1;
    --v23;
  }
  while (v23);
}

void sub_1A14F6488(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  void *v9;

  a9.super_class = (Class)VNSession;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_1A14F65CC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14F67E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{

  _Unwind_Resume(a1);
}

void sub_1A14F69A0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14F6A68(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  objc_end_catch();

  _Unwind_Resume(a1);
}

void sub_1A14F6B54(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  objc_end_catch();

  _Unwind_Resume(a1);
}

void sub_1A14F6C1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A14F6CD4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  objc_end_catch();

  _Unwind_Resume(a1);
}

void sub_1A14F6DA4(_Unwind_Exception *a1)
{
  void *v1;

  objc_end_catch();

  _Unwind_Resume(a1);
}

void sub_1A14F6E7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  objc_end_catch();

  _Unwind_Resume(a1);
}

void sub_1A14F7274(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12)
{
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;

  _Unwind_Resume(a1);
}

void sub_1A14F7534(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;

  v16 = v13;

  _Unwind_Resume(a1);
}

void sub_1A14F7770(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14F78E8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14F79E0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14F7AC4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14F7D58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21)
{
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;

  objc_end_catch();

  _Unwind_Resume(a1);
}

void sub_1A14F7F1C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14F7FB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A14F804C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  objc_end_catch();

  _Unwind_Resume(a1);
}

void sub_1A14F8168(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void ___ZL29_asyncProcessingDispatchQueuev_block_invoke()
{
  dispatch_queue_t v0;
  void *v1;
  NSObject *v2;

  dispatch_queue_attr_make_with_autorelease_frequency(MEMORY[0x1E0C80D50], DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v2 = objc_claimAutoreleasedReturnValue();
  v0 = dispatch_queue_create("com.apple.VNSession", v2);
  v1 = (void *)_asyncProcessingDispatchQueue(void)::ourProcessingDispatchQueue;
  _asyncProcessingDispatchQueue(void)::ourProcessingDispatchQueue = (uint64_t)v0;

}

void sub_1A14F8278(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14F835C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14F8528(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  void *v11;

  if (__p)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_1A14F8780(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14F8A44(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14F8C44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1A14F97F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

_QWORD *std::vector<CGPoint>::vector(_QWORD *a1, unint64_t a2, _OWORD *a3)
{
  _OWORD *v6;
  _OWORD *v7;
  uint64_t v8;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<vision::mod::DescriptorItemSideInfo>::__vallocate[abi:ne180100](a1, a2);
    v6 = (_OWORD *)a1[1];
    v7 = &v6[a2];
    v8 = 16 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 16;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_1A14F9A98(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__shuffle[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<CGPoint *>,std::__wrap_iter<CGPoint *>,std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>>(unint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 *v4;
  unint64_t v5;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  _QWORD v11[4];

  if ((uint64_t)(a2 - a1) >= 17)
  {
    v4 = (__int128 *)a1;
    v5 = a2 - 16;
    if (a2 - 16 > a1)
    {
      v7 = ((a2 - a1) >> 4) - 1;
      do
      {
        v11[0] = 0;
        v11[1] = v7;
        v8 = std::uniform_int_distribution<long>::operator()<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>>(a3, v11);
        if (v8)
        {
          v9 = *v4;
          *v4 = v4[v8];
          v4[v8] = v9;
        }
        ++v4;
        --v7;
      }
      while ((unint64_t)v4 < v5);
    }
  }
  return a2;
}

void sub_1A14F9CCC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14FA0E8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A14FA37C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  v11 = v10;

  _Unwind_Resume(a1);
}

void sub_1A14FA63C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14FA8EC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14FAA60(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14FABC8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14FAE90(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14FAF3C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14FB158(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  uint64_t v3;

  MEMORY[0x1A1B0A898](v3, 0x10B1C40765A9CC9);

  _Unwind_Resume(a1);
}

void sub_1A14FB5C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class __getAVDepthDataClass_block_invoke(uint64_t a1)
{
  Class result;
  void *v3;

  if (!AVFoundationLibraryCore_frameworkLibrary)
  {
    AVFoundationLibraryCore_frameworkLibrary = _sl_dlopen();
    if (!AVFoundationLibraryCore_frameworkLibrary)
    {
      abort_report_np();
      goto LABEL_6;
    }
  }
  while (1)
  {
    result = objc_getClass("AVDepthData");
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
    if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
      break;
LABEL_6:
    v3 = (void *)abort_report_np();
    free(v3);
  }
  getAVDepthDataClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

void sub_1A14FB8E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

void sub_1A14FB99C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14FBB14(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14FBC74(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A14FBCE8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14FBD3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A14FBDD4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14FC078(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14FC1B8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A14FC38C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A14FC4B8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14FC5A4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14FC6B0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14FC934(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14FCD38(_Unwind_Exception *exception_object, int a2)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  if (a2)
  {

    objc_begin_catch(exception_object);
    objc_exception_rethrow();
  }
  _Unwind_Resume(exception_object);
}

void sub_1A14FCFB8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14FD1C8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14FD2B8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14FD31C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14FD368(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A14FD3B4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14FD410(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1A14FD468(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14FD4C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1A14FD51C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14FD578(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1A14FD5CC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14FD618(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A14FD660(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14FD6AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A14FD6F4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14FD740(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A14FD790(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14FD7E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A14FE25C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14FE308(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14FE434(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14FE7D8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14FEA58(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A14FEAD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1A14FEB30(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14FEB90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1A14FEBE8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14FEC34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A14FEC7C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14FECC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A14FED10(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14FED5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A14FEDA4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14FEDF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A14FEE38(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14FEE84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A14FEECC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14FEF20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A14FEF70(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14FEFBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A14FF004(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14FF050(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A14FF098(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14FF1F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20)
{
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

void sub_1A14FF3F8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  _Unwind_Resume(a1);
}

void sub_1A14FF4BC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id _sequenceKeyComponentForArray(NSArray *a1)
{
  NSArray *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  v1 = a1;
  if (v1)
  {
    v2 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99E60]), "initWithArray:", v1);
    objc_msgSend(v2, "allObjects");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    v4 = (void *)MEMORY[0x1E0CB3940];
    objc_msgSend(v3, "componentsJoinedByString:", CFSTR(","));
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "stringWithFormat:", CFSTR("[%@]"), v5);
    v6 = (void *)objc_claimAutoreleasedReturnValue();

  }
  else
  {
    v6 = 0;
  }

  return v6;
}

void sub_1A14FF658(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A14FF70C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14FF804(void *a1)
{
  os_unfair_lock_s *v1;

  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A14FF818(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A14FFA80(_Unwind_Exception *exception_object, int a2)
{
  os_unfair_lock_s *v2;
  void *v3;

  if (a2)
  {

    objc_begin_catch(exception_object);
    os_unfair_lock_unlock(v2);
    objc_exception_rethrow();
  }
  _Unwind_Resume(exception_object);
}

void sub_1A14FFC98(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A14FFDA4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14FFEC4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A14FFFFC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A1500100(void *a1)
{
  uint64_t v1;
  os_unfair_lock_s *v2;

  objc_begin_catch(a1);
  os_unfair_lock_unlock(v2);
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v1 + 16));
  objc_exception_rethrow();
}

void sub_1A150011C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  objc_end_catch();

  _Unwind_Resume(a1);
}

void sub_1A1500204(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1500400(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A15005C0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A1500708(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1500834(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A15008EC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1A1500AA4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1500C28(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1500CA8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1500D5C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1500E14(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1500EAC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1500F64(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1501050(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A1501124(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1501240(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A15013AC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A1501670(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A1501820(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15018C0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1501960(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1501AFC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A1501CAC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1501D64(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A1501E5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void sub_1A1502190(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,void *a27,void *a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,id a40)
{
  void *v40;
  void *v41;
  void *v42;

  _Block_object_dispose(&a31, 8);
  _Block_object_dispose(&a35, 8);

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__29_23236(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__30_23237(uint64_t a1)
{

}

void sub_1A1502300(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A150235C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1502444(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A150275C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12)
{
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;

  _Unwind_Resume(a1);
}

void sub_1A1502A8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  void *v16;
  void *v17;
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

void sub_1A1503100(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20)
{
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;

  _Unwind_Resume(a1);
}

void sub_1A150345C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A150362C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,id a28)
{
  void *v28;
  void *v29;
  uint64_t v30;

  _Block_object_dispose(&a23, 8);
  _Block_object_dispose((const void *)(v30 - 144), 8);

  _Unwind_Resume(a1);
}

void sub_1A1503810(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1505044(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,void *a54,uint64_t a55,void *a56,uint64_t a57,uint64_t a58,uint64_t a59,void *a60,void *a61,_Unwind_Exception *exception_object)
{
  void *v62;
  void *v63;
  void *v64;
  void *v65;

  _Unwind_Resume(a1);
}

void sub_1A150562C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,uint64_t a52,void *a53,uint64_t a54,void *a55,uint64_t a56,void *a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62)
{
  void *v62;
  void *v63;
  void *v64;

  if (v64)
    operator delete(v64);

  JUMPOUT(0x1A1505604);
}

void sub_1A1505658()
{
  JUMPOUT(0x1A1505700);
}

void sub_1A1505660(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,uint64_t a52,void *a53,uint64_t a54,void *a55,uint64_t a56,void *a57)
{
  void *v57;
  void *v58;
  void *v59;
  void *v60;
  void *v61;

  if (v57)
    operator delete(v57);
  if (v61)
    operator delete(v61);

  JUMPOUT(0x1A1505604);
}

void sub_1A1505678(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,void *a50,void *a51,void *a52,void *a53,uint64_t a54,void *a55,uint64_t a56,void *a57,void *a58)
{
  void *v58;
  void *v59;
  void *v60;
  void *v61;

  JUMPOUT(0x1A1505604);
}

void sub_1A1505990(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

void sub_1A1505D3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, void *a11, void *a12)
{
  void *v12;
  void *v13;
  void *v14;

  _Unwind_Resume(a1);
}

void sub_1A15060A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, uint64_t a12, void *a13)
{

  _Unwind_Resume(a1);
}

void sub_1A15061A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1A15062F8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A150668C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *exc_buf, void *a10, void *a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15)
{
  void *v15;
  void *v16;
  void *v17;
  void *v18;

  if (a2)
  {

    objc_begin_catch(a1);
    JUMPOUT(0x1A1506608);
  }
  _Unwind_Resume(a1);
}

void sub_1A1506898(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1506AB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void sub_1A1506B40(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1506CF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18)
{
  void *v18;
  void *v19;
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

void sub_1A1506E20(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1506EFC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1507058(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  void *v16;
  void *v17;
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

void sub_1A15071A4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A1507AF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19, void *a20,void *a21,uint64_t a22,uint64_t a23,_Unwind_Exception *exception_object,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56)
{

  _Unwind_Resume(a1);
}

void sub_1A1507D44()
{
  JUMPOUT(0x1A1507D80);
}

void sub_1A1507E08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1A1507E88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1A1507F08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1A15081FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void sub_1A150834C(_Unwind_Exception *a1)
{
  void *v1;

  objc_end_catch();

  _Unwind_Resume(a1);
}

void sub_1A1508458(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;

  v13 = v12;

  _Unwind_Resume(a1);
}

void sub_1A1508524(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A15086F8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A1508870(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  void *v16;
  void *v17;
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

void sub_1A15089A4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A1508CA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;
  void *v19;
  void *v20;

  _Unwind_Resume(a1);
}

void sub_1A1508FB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  void *v15;
  void *v16;
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

void sub_1A1509178(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1509240(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1509A04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{

  _Unwind_Resume(a1);
}

void sub_1A1509B00(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1509BDC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A1509E68(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;

  v8 = v6;

  _Unwind_Resume(a1);
}

void sub_1A150A1AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object, void *a11, void *a12, void *a13, void *a14)
{
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

void sub_1A150A31C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A150A3DC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A150A49C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A150A5D0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A150A910(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

void sub_1A150AA0C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A150AB54(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A150AC6C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A150AD80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void sub_1A150AE90(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A150AFC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A150B1AC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1A150B2BC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A150B4AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28)
{
  void *v28;
  uint64_t v29;
  void *v31;

  _Block_object_dispose((const void *)(v29 - 152), 8);
  v31 = *(void **)(v29 - 104);
  if (v31)
  {
    *(_QWORD *)(v29 - 96) = v31;
    operator delete(v31);
  }

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__23475(__n128 *a1, __n128 *a2)
{
  __n128 result;

  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__23476(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(_QWORD *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void sub_1A150B6AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{
  void *v20;
  void *v21;
  uint64_t v22;

  _Block_object_dispose(&a15, 8);

  _Block_object_dispose((const void *)(v22 - 64), 8);
  _Unwind_Resume(a1);
}

uint64_t ImageProcessing_smoothGaussian_createKernelForPlanarF(float **a1, int *a2, float a3, float a4)
{
  float *v5;
  uint64_t v6;
  float *v7;
  float *v10;
  BOOL v11;
  float v12;
  float *v13;
  uint64_t v14;
  float v15;
  float v16;
  int v17;
  float *v18;
  float *v19;
  float v20;

  if (a1)
  {
    v5 = 0;
    v6 = 4220;
    if (a3 <= 0.0)
    {
      v7 = 0;
    }
    else
    {
      v7 = 0;
      if (a4 > 0.0)
      {
        LODWORD(v6) = vcvtps_s32_f32(a3 * a4);
        *a2 = (2 * v6) | 1;
        v5 = (float *)malloc_type_malloc(4 * ((int)v6 + 1), 0x100004052888210uLL);
        v10 = (float *)malloc_type_malloc(4 * *a2, 0x100004052888210uLL);
        v7 = v10;
        if (v5)
          v11 = v10 == 0;
        else
          v11 = 1;
        if (v11)
        {
          v6 = 4219;
        }
        else
        {
          v5[(int)v6] = 1.0;
          if ((int)v6 <= 0)
          {
            v10[(int)v6] = 1.0;
          }
          else
          {
            v12 = (float)-(int)v6;
            v13 = v5;
            v14 = v6;
            v15 = 1.0;
            do
            {
              v16 = expf((float)(v12 / a3) * (float)((float)(v12 / a3) * -0.5));
              *v13++ = v16;
              v15 = v15 + (float)(v16 * 2.0);
              v12 = v12 + 1.0;
              --v14;
            }
            while (v14);
            v7[(int)v6] = v5[(int)v6] / v15;
            v17 = *a2 - 1;
            v18 = v5;
            v19 = v7;
            do
            {
              v20 = *v18++;
              *v19++ = v20 / v15;
              v7[v17--] = v20 / v15;
              --v6;
            }
            while (v6);
          }
          *a1 = v7;
          v6 = 4224;
          v7 = 0;
        }
      }
    }
  }
  else
  {
    v5 = 0;
    v7 = 0;
    v6 = 4221;
  }
  free(v5);
  free(v7);
  return v6;
}

apple::vision::libraries::autotrace::ContourToPath *apple::vision::libraries::autotrace::ContourToPath::ContourToPath(apple::vision::libraries::autotrace::ContourToPath *this, float a2)
{
  char *v3;

  *(_QWORD *)this = 0x40A000003DA3D70ALL;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_DWORD *)this + 10) = 0;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_QWORD *)this + 14) = 0;
  v3 = (char *)operator new(0x4B0uLL);
  *((_QWORD *)this + 12) = v3;
  *(_OWORD *)((char *)this + 120) = 0u;
  *((_QWORD *)this + 13) = v3;
  *((_QWORD *)this + 14) = v3 + 1200;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *((_DWORD *)this + 2) = 1036831949;
  *((_QWORD *)this + 2) = CGPathCreateMutable();
  return this;
}

void sub_1A150BE34(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  void **v2;
  void *v4;
  void *v5;
  void *v6;

  v4 = (void *)v1[18];
  if (v4)
  {
    v1[19] = v4;
    operator delete(v4);
  }
  v5 = *v2;
  if (*v2)
  {
    v1[16] = v5;
    operator delete(v5);
  }
  v6 = (void *)v1[12];
  if (v6)
  {
    v1[13] = v6;
    operator delete(v6);
  }
  _Unwind_Resume(exception_object);
}

uint64_t apple::vision::libraries::autotrace::ContourToPath::autoTrace(apple::vision::libraries::autotrace::ContourToPath *this, const apple::vision::libraries::autotrace::EPolygonList *a2, const apple::vision::libraries::autotrace::EPolygon *a3, uint64_t a4, uint64_t a5, float *a6, uint64_t a7, uint64_t a8)
{
  float32x2_t *v11;
  float32x2_t v12;
  float32x2_t v13;
  float v14;
  int v15;
  float32x2_t v16;
  float32x2_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int *v26;
  float *v27;
  float *v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  int v32;
  float32x2_t v33;
  float v34;
  float *v35;
  float v36;
  float *v37;
  float *v38;
  int v39;
  unsigned int *v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  float32x2_t v46;
  uint64_t v47;
  int v48;
  int32x2_t v49;
  int v50;
  int v51;
  BOOL v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  int v58;
  uint64_t v59;
  int v60;
  int v61;
  int v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  float v74;
  int v75;
  int v76;
  unint64_t v77;
  char **v78;
  EPolygon *v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t v82;
  int v83;
  int v84;
  unint64_t v85;
  int v86;
  int v87;
  uint64_t v88;
  int v89;
  uint64_t v90;
  float v91;
  float v92;
  float v93;
  float v94;
  uint64_t v98;
  float v99;
  float v100;
  float v101;
  float v102;
  float v103;
  float v104;
  float v105;
  float v106;
  float v107;
  float v108;
  float v109;
  float v110;
  float v111;
  int v112;
  unint64_t v113;
  uint64_t v114;
  float v115;
  int v116;
  int v117;
  int v118;
  float v119;
  float v120;
  float v121;
  int i;
  int v123;
  int v124;
  float v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  float v130;
  uint64_t v131;
  float v132;
  float v133;
  float v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  int v138;
  float v139;
  float v140;
  uint64_t v141;
  uint64_t v142;
  int v143;
  float v144;
  int v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  apple::vision::libraries::autotrace *v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  float v155;
  float *v156;
  float *v157;
  float v158;
  uint64_t v159;
  float v160;
  apple::vision::libraries::autotrace *v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  float v169;
  float v170;
  float v171;
  float v172;
  BOOL v173;
  int *v174;
  int *v175;
  unint64_t v176;
  apple::vision::libraries::autotrace::CornerList *v177;
  float v178;
  float v179;
  float v180;
  float v181;
  float v184;
  float v185;
  float v188;
  float v189;
  float v190;
  float v191;
  uint64_t v194;
  unint64_t v195;
  unint64_t v196;
  uint64_t v197;
  char *v198;
  int *v199;
  int *v200;
  uint64_t v201;
  int v202;
  int32x2_t v203;
  int32x2_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  char *v210;
  char *v211;
  char *v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  char *v221;
  int *v222;
  char *v223;
  int *v224;
  char v225;
  char *v226;
  int v227;
  int v228;
  char *v229;
  char *v230;
  int64_t v231;
  char *v232;
  char *v233;
  int64_t v234;
  char *v235;
  char *v236;
  unint64_t v237;
  unint64_t v239;
  int v240;
  unint64_t v241;
  int64_t v242;
  int64_t v243;
  int v244;
  char *v245;
  int v246;
  int v247;
  int v248;
  int v249;
  int v250;
  int v251;
  int v252;
  int v253;
  int v254;
  int v255;
  int v256;
  int v257;
  int v258;
  int v259;
  int v260;
  int v262;
  int64_t v263;
  uint64_t v264;
  uint64_t v265;
  unint64_t v266;
  _DWORD *v267;
  char *v268;
  char *v269;
  char *v270;
  char *v271;
  uint64_t v272;
  int64_t v273;
  uint64_t v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  float v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  int v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  uint64_t v287;
  _BYTE *v288;
  char v289;
  int v290;
  int *v291;
  int v292;
  apple::vision::libraries::autotrace::CornerList *Corner;
  int v294;
  uint64_t v295;
  apple::vision::libraries::autotrace::CornerList *v296;
  int v297;
  int v298;
  int v299;
  int v300;
  int v301;
  unsigned int v302;
  int v303;
  float v304;
  float v305;
  void *v306;
  char *v307;
  uint64_t v308;
  unint64_t v309;
  BOOL v310;
  char *v311;
  uint64_t v312;
  unint64_t v313;
  uint64_t v314;
  uint64_t v315;
  uint64_t v316;
  unint64_t v317;
  int v318;
  uint64_t v319;
  int v320;
  float v321;
  float v322;
  unint64_t v323;
  uint64_t v324;
  uint64_t v325;
  int *v326;
  int *v327;
  int v328;
  int v329;
  uint64_t v330;
  _BYTE *v331;
  char v332;
  int v333;
  apple::vision::libraries::autotrace::CornerList *v334;
  int v335;
  int v336;
  apple::vision::libraries::autotrace::CornerList *v337;
  int v338;
  int v339;
  int v340;
  int v341;
  int v342;
  uint64_t v343;
  uint64_t v344;
  uint64_t v345;
  int v346;
  uint64_t v347;
  uint64_t v348;
  char v349;
  int v350;
  uint64_t v351;
  uint64_t v352;
  uint64_t v353;
  float v354;
  uint64_t v355;
  float v356;
  float v357;
  uint64_t v358;
  uint64_t v359;
  float v360;
  float v361;
  uint64_t v362;
  float v363;
  float v364;
  float v365;
  uint64_t v366;
  float *v367;
  float v368;
  float v369;
  BOOL v370;
  float v371;
  float v372;
  float v373;
  float v374;
  int v375;
  float v376;
  float v377;
  uint64_t v378;
  int v379;
  int v380;
  float *v381;
  float v382;
  BOOL v383;
  float v384;
  float v385;
  float v386;
  int v387;
  uint64_t v388;
  uint64_t v389;
  uint64_t v390;
  int v391;
  uint64_t v392;
  uint64_t v393;
  uint64_t v394;
  int v395;
  int v396;
  int v397;
  uint64_t v398;
  BOOL v399;
  int v400;
  int v401;
  uint64_t v402;
  uint64_t v403;
  uint64_t v404;
  int v405;
  uint64_t v406;
  uint64_t v407;
  uint64_t v408;
  void *v409;
  char *v410;
  uint64_t v411;
  unint64_t v412;
  uint64_t v413;
  uint64_t v414;
  uint64_t v415;
  uint64_t v416;
  uint64_t v417;
  uint64_t v418;
  uint64_t v419;
  uint64_t v420;
  uint64_t v421;
  uint64_t v422;
  uint64_t v423;
  uint64_t v424;
  uint64_t v425;
  uint64_t v426;
  uint64_t v427;
  uint64_t v428;
  uint64_t v429;
  uint64_t v430;
  uint64_t v431;
  uint64_t v432;
  uint64_t v433;
  uint64_t v434;
  uint64_t v435;
  uint64_t v436;
  uint64_t v437;
  uint64_t v438;
  uint64_t v439;
  uint64_t v440;
  uint64_t v441;
  uint64_t v442;
  uint64_t v443;
  uint64_t v444;
  uint64_t v445;
  uint64_t v446;
  uint64_t v447;
  __n128 v448;
  int v449;
  int v450;
  uint64_t *v451;
  int v452;
  int v453;
  char **v454;
  int8x8_t v455;
  int v456;
  int32x2_t v457;
  unint64_t v458;
  int32x2_t v459;
  int v460;
  float v461;
  char v462;
  void *__p;
  _BYTE *v464;
  uint64_t v465;
  float v466[3];

  if (*(int *)a3 < 1)
  {
    v14 = 0.0;
  }
  else
  {
    v11 = (float32x2_t *)*((_QWORD *)a3 + 1);
    v12 = *v11;
    v13 = vsub_f32(v11[*(_DWORD *)a3 - 1], *v11);
    v14 = 0.0;
    v15 = *(_DWORD *)a3;
    do
    {
      v16 = *v11++;
      v17 = vsub_f32(v16, v12);
      v14 = v14 + vmul_lane_f32(vsub_f32(v17, v13), vadd_f32(v17, v13), 1).f32[0] * 0.5;
      v13 = v17;
      --v15;
    }
    while (v15);
  }
  if (*(_DWORD *)a3 <= *((_DWORD *)this + 10))
  {
    *((_QWORD *)this + 3) = a3;
    *((_QWORD *)this + 4) = a2;
  }
  else
  {
    apple::vision::libraries::autotrace::ContourToPath::freeAutoTraceStructures(this);
    *((_QWORD *)this + 3) = a3;
    *((_QWORD *)this + 4) = a2;
    v18 = *(int *)a3;
    *((_QWORD *)this + 6) = malloc_type_malloc(4 * v18, 0x100004052888210uLL);
    *((_QWORD *)this + 10) = malloc_type_malloc(4 * v18, 0x100004052888210uLL);
    *((_QWORD *)this + 11) = malloc_type_malloc(4 * v18, 0x100004052888210uLL);
    *((_QWORD *)this + 7) = malloc_type_malloc(4 * v18, 0x100004052888210uLL);
    *((_QWORD *)this + 8) = malloc_type_malloc(4 * v18, 0x100004052888210uLL);
    v19 = malloc_type_malloc(4 * v18, 0x100004052888210uLL);
    *((_QWORD *)this + 9) = v19;
    if (!*((_QWORD *)this + 6)
      || !*((_QWORD *)this + 10)
      || !*((_QWORD *)this + 11)
      || !*((_QWORD *)this + 7)
      || !*((_QWORD *)this + 8)
      || !v19)
    {
      VNValidatedLog(4, (uint64_t)CFSTR("%s: could not allocate auto trace structures"), v20, a4, a5, (uint64_t)a6, a7, a8, (uint64_t)"installAutoTraceStructures");
      apple::vision::libraries::autotrace::ContourToPath::freeAutoTraceStructures(this);
      return 0;
    }
    *((_DWORD *)this + 10) = v18;
  }
  if (fabsf(v14) < 3.0)
  {
    CGPathMoveToPoint(*((CGMutablePathRef *)this + 2), 0, COERCE_FLOAT(**((_QWORD **)a3 + 1)), COERCE_FLOAT(HIDWORD(**((_QWORD **)a3 + 1))));
    LODWORD(v21) = *(_DWORD *)a3;
    if (*(int *)a3 >= 1)
    {
      v22 = 0;
      v23 = 1;
      do
      {
        LODWORD(v24) = ++v22;
        if (v23 >= (int)v21)
        {
          v24 = v23 - (int)v21;
          if (v24 >= (int)v21)
            v24 %= (int)v21;
        }
        CGPathAddLineToPoint(*((CGMutablePathRef *)this + 2), 0, COERCE_FLOAT(*(_QWORD *)(*((_QWORD *)a3 + 1) + 8 * (int)v24)), COERCE_FLOAT(HIDWORD(*(_QWORD *)(*((_QWORD *)a3 + 1) + 8 * (int)v24))));
        v21 = *(int *)a3;
        v173 = v23++ < v21;
      }
      while (v173);
    }
    CGPathCloseSubpath(*((CGMutablePathRef *)this + 2));
    return 1;
  }
  v26 = (unsigned int *)*((_QWORD *)this + 3);
  v27 = (float *)*v26;
  if ((_DWORD)v27)
  {
    v28 = (float *)*((_QWORD *)this + 6);
    if ((int)v27 < 1)
      goto LABEL_35;
    v29 = 0;
    v30 = *((_QWORD *)v26 + 1);
    do
    {
      v31 = v29 + 1;
      if ((int)v29 + 1 >= (int)v27)
        v32 = (int)v27;
      else
        v32 = 0;
      v33 = vsub_f32(*(float32x2_t *)(v30 - 8 * v32 + 8 * v29 + 8), *(float32x2_t *)(v30 + 8 * v29));
      v34 = atan2f(v33.f32[1], v33.f32[0]) * 0.15915;
      if (v34 < 0.0)
        v34 = v34 + 1.0;
      v28[v29++] = v34;
    }
    while ((_DWORD)v27 != v31);
    if ((int)v27 > 23)
    {
      if (v27 > 0x37)
      {
        apple::vision::libraries::autotrace::ContourToPath::filterAngleBuffer(v28, *((float **)this + 10), (float *)(int)v27, 3, *(float *)this);
        v37 = (float *)*((_QWORD *)this + 10);
        v36 = *(float *)this;
        if (v27 > 0x77)
        {
          apple::vision::libraries::autotrace::ContourToPath::filterAngleBuffer(v37, *((float **)this + 11), v27, 7, v36);
          v37 = (float *)*((_QWORD *)this + 11);
          v35 = (float *)*((_QWORD *)this + 7);
          v36 = *(float *)this;
          v38 = (float *)(int)v27;
          v39 = 15;
        }
        else
        {
          v35 = (float *)*((_QWORD *)this + 7);
          v38 = (float *)(int)v27;
          v39 = 7;
        }
      }
      else
      {
        v35 = (float *)*((_QWORD *)this + 7);
        v36 = *(float *)this;
        v37 = v28;
        v38 = v27;
        v39 = 3;
      }
      apple::vision::libraries::autotrace::ContourToPath::filterAngleBuffer(v37, v35, v38, v39, v36);
    }
    else
    {
LABEL_35:
      memmove(*((void **)this + 7), v28, 4 * (int)v27);
    }
  }
  v40 = (unsigned int *)*((_QWORD *)this + 3);
  v41 = *((_QWORD *)v40 + 1);
  v42 = *v40;
  LOBYTE(v466[0]) = 0;
  __p = 0;
  v464 = 0;
  v465 = 0;
  if ((int)v42 > 0)
  {
    v43 = 0;
    a5 = 0;
    v44 = 0;
    v45 = -1;
    v46 = (float32x2_t)vdup_n_s32(0x3A83126Fu);
    do
    {
      v47 = v43 + 1;
      if (v43 + 1 >= v42)
        v48 = v42;
      else
        v48 = 0;
      v49 = vcgt_f32(v46, vabd_f32(*(float32x2_t *)(v41 - 8 * v48 + 8 * v43 + 8), *(float32x2_t *)(v41 + 8 * v43)));
      if ((v49.i8[0] & 1) != 0)
        v50 = 1;
      else
        v50 = -1;
      if ((v49.i8[4] & 1) != 0)
        v51 = 0;
      else
        v51 = v50;
      if (v51 == v45)
      {
        a5 = (a5 + 1);
      }
      else
      {
        a4 = v47 + -v48;
        if (v45 == 1)
        {
          apple::vision::libraries::autotrace::ContourToPath::addVerticalLine((_DWORD *)**((unsigned int **)this + 3), *(_QWORD *)(*((_QWORD *)this + 3) + 8), v44, v47 - v48, a5, &__p, v466);
        }
        else if (!v45)
        {
          apple::vision::libraries::autotrace::ContourToPath::addHorizontalLine((_DWORD *)**((unsigned int **)this + 3), *(_QWORD *)(*((_QWORD *)this + 3) + 8), v44, v47 - v48, a5, &__p, v466);
        }
        if (LOBYTE(v466[0]))
          goto LABEL_67;
        a5 = 1;
        v44 = v43;
        v45 = v51;
      }
      ++v43;
    }
    while (v42 != v47);
    if (v45 == 1)
    {
      apple::vision::libraries::autotrace::ContourToPath::addVerticalLine((_DWORD *)**((unsigned int **)this + 3), *(_QWORD *)(*((_QWORD *)this + 3) + 8), v44, 0, a5, &__p, v466);
    }
    else if (!v45)
    {
      apple::vision::libraries::autotrace::ContourToPath::addHorizontalLine((_DWORD *)**((unsigned int **)this + 3), *(_QWORD *)(*((_QWORD *)this + 3) + 8), v44, 0, a5, &__p, v466);
    }
    if (LOBYTE(v466[0]))
    {
LABEL_67:
      v52 = 0;
      goto LABEL_68;
    }
    v311 = (char *)__p;
    if (v464 == __p)
    {
      if (__p)
        operator delete(__p);
      goto LABEL_71;
    }
    v312 = 0;
    v313 = 0;
    while (1)
    {
      apple::vision::libraries::autotrace::ContourToPath::insertPairIntoInterestingPoints((uint64_t)this, (uint64_t)&v311[v312], *(_DWORD *)&v311[v312 + 8], *(_DWORD *)&v311[v312 + 12], (uint64_t *)this + 15, v466);
      v52 = LOBYTE(v466[0]) == 0;
      if (LOBYTE(v466[0]))
        break;
      v313 += 2;
      v311 = (char *)__p;
      v312 += 16;
      if (v313 >= (v464 - (_BYTE *)__p) >> 3)
      {
        v52 = 1;
        break;
      }
    }
LABEL_68:
    if (__p)
      operator delete(__p);
    if (!v52)
    {
      VNValidatedLog(4, (uint64_t)CFSTR("%s: failing findOrthogonalLines"), v44, a4, a5, (uint64_t)a6, a7, a8, (uint64_t)"autoTrace");
      return 0;
    }
  }
LABEL_71:
  v53 = **((unsigned int **)this + 3);
  if ((int)v53 >= 1)
  {
    v54 = 0;
    v55 = *((_QWORD *)this + 6);
    v56 = *((_QWORD *)this + 10);
    do
    {
      if (v54)
        v57 = 0;
      else
        v57 = v53;
      v58 = v54 + v57 - 1;
      v59 = v54 + 1;
      if (v54 + 1 >= v53)
        v60 = v53;
      else
        v60 = 0;
      v61 = v59 - v60;
      if (v58 <= 0)
        v62 = v53;
      else
        v62 = 0;
      v63 = *(float *)(v55 + 4 * (v58 + v62 - 1));
      v64 = -2.0;
      v65 = -1.0;
      v66 = 0.0;
      v67 = 0.0;
      while (1)
      {
        v68 = v63;
        v63 = *(float *)(v55 + 4 * v58);
        v69 = v63 - v68;
        v70 = rintf(v63 - v68);
        v71 = (float)(v63 - v68) - v70;
        v72 = vabds_f32(v69, v70);
        if (v72 <= v65)
        {
          v73 = v66;
          if (v72 <= v64)
          {
            v71 = v67;
            v74 = v65;
            v72 = v64;
          }
          else
          {
            v74 = v65;
          }
        }
        else
        {
          v73 = v71;
          v71 = v66;
          v74 = v72;
          v72 = v65;
        }
        if (v58 == v61)
          break;
        v75 = v58 + 1;
        if (v75 >= (int)v53)
          v76 = v53;
        else
          v76 = 0;
        v58 = v75 - v76;
        v66 = v73;
        v67 = v71;
        v65 = v74;
        v64 = v72;
      }
      *(float *)(v56 + 4 * v54++) = v73 + v71;
    }
    while (v59 != v53);
    v77 = 0;
    v78 = (char **)((char *)this + 120);
    v457 = vdup_n_s32(v53 >> 1);
    v459 = vdup_n_s32(-(v53 >> 1));
    v455 = (int8x8_t)vdup_n_s32(v53);
    do
    {
      LODWORD(__p) = 0;
      v466[0] = 0.0;
      v461 = 0.0;
      v79 = (EPolygon *)*((_QWORD *)this + 3);
      v80 = *(_DWORD *)v79;
      v81 = v77 - 2;
      v82 = v77 - 2 - v80;
      if ((uint64_t)(v77 - 2) >= v80)
      {
        if (v82 >= v80)
          v82 %= v80;
      }
      else if (v77 > 1)
      {
        LODWORD(v82) = v77 - 2;
      }
      else
      {
        LODWORD(v82) = v81 + v80;
        if ((uint64_t)(v81 + v80) < 0)
        {
          LODWORD(v82) = v77 - 2;
          if ((_DWORD)v80)
            v82 = (uint64_t)(v81 + v80) % v80 + v80;
        }
      }
      if (v77)
        v83 = 0;
      else
        v83 = *(_DWORD *)v79;
      v84 = v77 + v83 - 1;
      v85 = v77 + 1;
      if ((uint64_t)(v77 + 1) >= v80)
        v86 = *(_DWORD *)v79;
      else
        v86 = 0;
      v87 = v85 - v86;
      v88 = (v77 + 2);
      v89 = v88 - v80;
      if (v88 - v80 >= v80)
        v89 = (v88 - v80) % v80;
      if ((uint64_t)(v77 + 2) >= v80)
        LODWORD(v88) = v89;
      v90 = *((_QWORD *)this + 10);
      v91 = fabsf(*(float *)(v90 + 4 * (int)v82));
      v92 = fabsf(*(float *)(v90 + 4 * v84));
      v93 = fabsf(*(float *)(v90 + 4 * v77));
      v94 = fabsf(*(float *)(v90 + 4 * v87));
      if (v92 == v93 && v91 < v93 && v94 < v93)
      {
        v115 = v93 * 0.75;
        if (v91 <= v115)
          v116 = v84;
        else
          v116 = v82;
        if (v94 <= v115)
          v117 = v77;
        else
          v117 = v85 - v86;
        v98 = *((_QWORD *)this + 6);
      }
      else
      {
        if (v92 >= v93 || v94 >= v93)
          goto LABEL_320;
        v98 = *((_QWORD *)this + 6);
        v99 = *(float *)(v98 + 4 * v84);
        v100 = *(float *)(v98 + 4 * (int)v82);
        v101 = v99 - v100;
        v102 = rintf(v99 - v100);
        v103 = vabds_f32(v99 - v100, v102);
        v104 = *(float *)(v98 + 4 * v77);
        v105 = v104 - v99;
        v106 = rintf(v104 - v99);
        v107 = vabds_f32(v104 - v99, v106);
        v108 = *(float *)(v98 + 4 * v87);
        v109 = v108 - v104;
        v110 = rintf(v109);
        v111 = vabds_f32(v109, v110);
        if (v111 > v107 || (v112 = v77, v103 > v107))
        {
          if (v103 <= v111)
            v112 = v87;
          else
            v112 = v84;
        }
        v113 = v77 - 3;
        v114 = v77 - 3 - v80;
        if ((uint64_t)(v77 - 3) >= v80)
        {
          if (v114 >= v80)
            LODWORD(v114) = v114 % v80;
        }
        else
        {
          LODWORD(v114) = v77 - 3;
          if (v77 <= 2)
          {
            v114 = v113 + v80;
            if ((uint64_t)(v113 + v80) < 0)
              v114 = v114 % v80 + v80;
          }
        }
        v178 = v101 - v102;
        v179 = v105 - v106;
        if (v112 == v84)
        {
          v180 = v100 - *(float *)(v98 + 4 * (int)v114);
          v181 = v92 * 0.75;
          if ((float)(v178 * (float)(v180 - rintf(v180))) <= 0.0 || v91 <= v181)
            v116 = v84;
          else
            v116 = v82;
          if ((float)(v178 * v179) <= 0.0 || v93 <= v181)
            v117 = v84;
          else
            v117 = v77;
        }
        else
        {
          v184 = v109 - v110;
          if (v77 == v112)
          {
            v185 = v93 * 0.75;
            if ((float)(v178 * v179) <= 0.0 || v92 <= v185)
              v116 = v77;
            else
              v116 = v84;
            if ((float)(v179 * v184) <= 0.0 || v94 <= v185)
              v117 = v77;
            else
              v117 = v87;
          }
          else
          {
            if (v112 != v87)
              goto LABEL_320;
            v188 = fabsf(*(float *)(v90 + 4 * (int)v88));
            v189 = *(float *)(v98 + 4 * (int)v88) - v108;
            v190 = v189 - rintf(v189);
            v191 = v94 * 0.75;
            if ((float)(v179 * v184) <= 0.0 || v93 <= v191)
              v116 = v87;
            else
              v116 = v77;
            if ((float)(v184 * v190) <= 0.0 || v188 <= v191)
              v117 = v87;
            else
              v117 = v88;
          }
        }
      }
      if (v116 <= 0)
        v118 = *(_DWORD *)v79;
      else
        v118 = 0;
      v119 = *(float *)(v98 + 4 * v116);
      v120 = v119 - *(float *)(v98 + 4 * (v116 + v118 - 1));
      v121 = (float)(v120 - rintf(v120)) + 0.0;
      for (i = v116; i != v117; v119 = *(float *)(v98 + 4 * i))
      {
        v123 = i + 1;
        if (v123 >= (int)v80)
          v124 = *(_DWORD *)v79;
        else
          v124 = 0;
        i = v123 - v124;
        v125 = *(float *)(v98 + 4 * i) - v119;
        v121 = v121 + (float)(v125 - rintf(v125));
      }
      v126 = v117;
      v127 = v117 + 1;
      v128 = v116 + v80;
      v130 = 0.0;
      v131 = 5;
      v132 = 0.0;
      v133 = 0.0;
      v134 = 0.0;
      do
      {
        v135 = v116 + v131 - 6;
        if (v135 >= v80)
        {
          v129 = v116 - v80;
          v137 = v129 + v131 - 6;
          if (v137 >= v80)
            v135 = v137 % v80;
          else
            LODWORD(v135) = v129 + v131 - 6;
        }
        else if (v135 < 0)
        {
          v136 = v128 + v131 - 6;
          if (v136 >= 0)
            LODWORD(v135) = v128 + v131 - 6;
          if (v136 < 0)
            v135 = v136 % v80 + v80;
        }
        if ((int)v135 <= 0)
          v138 = *(_DWORD *)v79;
        else
          v138 = 0;
        v139 = *(float *)(v98 + 4 * (int)v135);
        v140 = *(float *)(v98 + 4 * ((int)v135 + v138 - 1));
        if (v127 >= v80)
        {
          if (v127 - v80 >= v80)
            LODWORD(v141) = v127;
          else
            LODWORD(v141) = v127 - v80;
          if (v127 - v80 >= v80)
            v141 = (v127 - v80) % v80;
        }
        else
        {
          LODWORD(v141) = v127;
          if (v127 < 0)
          {
            v142 = v80 + v127;
            LODWORD(v141) = v80 + v127 < 0 ? v127 : (int)v80 + (int)v127;
            if (v142 < 0)
              v141 = v142 % v80 + v80;
          }
        }
        v134 = v134 + (float)((float)(v139 - v140) - rintf(v139 - v140));
        if ((int)v141 <= 0)
          v143 = *(_DWORD *)v79;
        else
          v143 = 0;
        v144 = *(float *)(v98 + 4 * (int)v141) - *(float *)(v98 + 4 * ((int)v141 + v143 - 1));
        v133 = v133 + (float)(v144 - rintf(v144));
        if (v131 == 3)
        {
          v132 = v134;
          v130 = v133;
        }
        ++v127;
        --v131;
      }
      while (v131);
      v145 = v116 - 4;
      v146 = v116 - 4;
      if (v116 - 4 >= (int)v80)
      {
        v148 = v145 - v80;
        if (v146 - v80 >= v80)
          v146 = v148 % v80;
        else
          v146 -= v80;
      }
      else if (v116 <= 3)
      {
        v147 = v145 + v80;
        if (v146 + v80 < 0 == __OFADD__(v146, v80))
          v146 += v80;
        if (v147 < 0)
          v146 = v147 % v80 + v80;
      }
      v149 = (apple::vision::libraries::autotrace *)apple::vision::libraries::autotrace::ContourToPath::LRLine(v79, (const EPolygon *)v146, &__p, &v461, (float *)a5, a6);
      if ((_DWORD)v149)
      {
        v155 = *(float *)&__p;
        v158 = apple::vision::libraries::autotrace::straightLineDistanceDeltaToleranceAtAngle(v149, *(float *)&__p, v150, v151, v152, a5, (uint64_t)a6, v153, v154);
        if (v117 >= (int)v80)
        {
          v126 = v117 - v80 >= v80 ? (v117 - v80) % v80 : v117 - v80;
        }
        else if (v117 < 0)
        {
          v159 = v117 + v80;
          if (v159 < 0 == __OFADD__(v117, v80))
            v126 = v117 + v80;
          if (v159 < 0)
            v126 = v159 % v80 + v80;
        }
        v160 = v461;
        v161 = (apple::vision::libraries::autotrace *)apple::vision::libraries::autotrace::ContourToPath::LRLine(*((EPolygon **)this + 3), (const EPolygon *)v126, v466, &v461, v156, v157);
        if ((_DWORD)v161)
        {
          v169 = apple::vision::libraries::autotrace::straightLineDistanceDeltaToleranceAtAngle(v161, v155, v162, v163, v164, a5, (uint64_t)a6, v165, v166);
          if (vabds_f32(v155 - v466[0], rintf(v155 - v466[0])) >= 0.0625)
          {
            v170 = fabsf(v121);
            if (v170 >= 0.0625
              && (v160 < v158 || fabsf(v134) < (float)(v170 * 0.3) || (float)(v121 * v134) < 0.0)
              && (v461 < v169 || fabsf(v133) < (float)(v170 * 0.3) || (float)(v121 * v133) < 0.0))
            {
              v171 = v170 * 0.6;
              v172 = fabsf(v130);
              v173 = fabsf(v132) <= v171 && v172 <= v171;
              if (v173)
              {
                v174 = (int *)*((_QWORD *)this + 12);
                v175 = (int *)*((_QWORD *)this + 13);
                if (v175 == v174 || *(v175 - 2) <= v116 || *(v175 - 3) >= v116)
                {
                  v176 = *((_QWORD *)this + 14);
                  if ((unint64_t)v175 >= v176)
                  {
                    v194 = ((char *)v175 - (char *)v174) / 12;
                    v195 = v194 + 1;
                    if ((unint64_t)(v194 + 1) > 0x1555555555555555)
                      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
                    v454 = v78;
                    v196 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v176 - (_QWORD)v174) >> 2);
                    if (2 * v196 > v195)
                      v195 = 2 * v196;
                    if (v196 >= 0xAAAAAAAAAAAAAAALL)
                      v195 = 0x1555555555555555;
                    if (v195 > 0x1555555555555555)
                      std::__throw_bad_array_new_length[abi:ne180100]();
                    v197 = 3 * v195;
                    v198 = (char *)operator new(12 * v195);
                    v199 = (int *)&v198[12 * v194];
                    *v199 = v116;
                    v199[1] = v117;
                    v199[2] = -100;
                    v200 = v199;
                    if (v175 != v174)
                    {
                      do
                      {
                        v201 = *(_QWORD *)(v175 - 3);
                        v175 -= 3;
                        v202 = v175[2];
                        *(_QWORD *)(v200 - 3) = v201;
                        v200 -= 3;
                        v200[2] = v202;
                      }
                      while (v175 != v174);
                      v175 = v174;
                    }
                    v177 = (apple::vision::libraries::autotrace::CornerList *)(v199 + 3);
                    *((_QWORD *)this + 12) = v200;
                    *((_QWORD *)this + 13) = v199 + 3;
                    *((_QWORD *)this + 14) = &v198[4 * v197];
                    if (v175)
                      operator delete(v175);
                    v78 = v454;
                  }
                  else
                  {
                    *v175 = v116;
                    v175[1] = v117;
                    v177 = (apple::vision::libraries::autotrace::CornerList *)(v175 + 3);
                    v175[2] = -100;
                  }
                  *((_QWORD *)this + 13) = v177;
                  if (!apple::vision::libraries::autotrace::CornerList::findCorner(*((apple::vision::libraries::autotrace::CornerList **)this + 12), v177, **((unsigned int **)this + 3), v77, 0, (uint64_t)a6, v167, v168))
                  {
                    v203 = vsub_s32(*(int32x2_t *)((char *)v177 - 12), vdup_n_s32(v77));
                    v204 = vabs_s32(vadd_s32((int32x2_t)vbsl_s8((int8x8_t)vcgt_s32(v459, v203), v455, (int8x8_t)vneg_s32((int32x2_t)vand_s8(v455, (int8x8_t)vcgt_s32(v203, v457)))), v203));
                    if ((vcgt_u32((uint32x2_t)vdup_lane_s32(v204, 1), (uint32x2_t)v204).u8[0] & 1) != 0)
                      LODWORD(v77) = *(_QWORD *)((char *)v177 - 12);
                    else
                      LODWORD(v77) = HIDWORD(*(_QWORD *)((char *)v177 - 12));
                  }
                  *((_DWORD *)v177 - 1) = v77;
                  v205 = apple::vision::libraries::autotrace::ContourToPath::addInterestingPointAtIndex(v77, 1, v78);
                  if (!v205)
                    goto LABEL_436;
                  v210 = (char *)v205;
                  if (*(_DWORD *)(v205 + 4) == 1)
                  {
                    v211 = (char *)*((_QWORD *)this + 15);
                    v212 = (char *)*((_QWORD *)this + 16);
                    v213 = v210 - v211;
                    v214 = (v210 - v211) >> 3;
                    v215 = v214 - 1;
                    v216 = (v212 - v211) >> 3;
                    if (v214 <= v216)
                    {
                      if (v213 > 7)
                      {
                        LODWORD(v217) = v214 - 1;
                      }
                      else
                      {
                        LODWORD(v217) = v216 + v215;
                        if (v216 + v215 < 0)
                        {
                          LODWORD(v217) = v214 - 1;
                          if (v212 != v211)
                            v217 = (v216 + v215) % v216 + v216;
                        }
                      }
                    }
                    else
                    {
                      LODWORD(v217) = v215 - v216;
                      if (v215 - v216 >= v216)
                      {
                        LODWORD(v217) = v214 - 1;
                        if (v212 != v211)
                          v217 = (v215 - v216) % v216;
                      }
                    }
                    v218 = v214 + 1;
                    v219 = v218 - v216;
                    if (v218 >= v216)
                    {
                      LODWORD(v220) = v218 - v216;
                      if (v219 >= v216)
                      {
                        LODWORD(v220) = v218;
                        if (v212 != v211)
                          v220 = v219 % v216;
                      }
                    }
                    else if (v213 > -9)
                    {
                      LODWORD(v220) = v218;
                    }
                    else
                    {
                      LODWORD(v220) = v216 + v218;
                      if (v216 + v218 < 0)
                      {
                        LODWORD(v220) = v218;
                        if (v212 != v211)
                          v220 = (v216 + v218) % v216 + v216;
                      }
                    }
                    v221 = &v211[8 * (int)v217];
                    v222 = (int *)(v221 + 4);
                    if ((v221[4] & 2) != 0)
                    {
                      v223 = &v211[8 * (int)v220];
                      v225 = v223[4];
                      v224 = (int *)(v223 + 4);
                      if ((v225 & 4) != 0)
                      {
                        v226 = &v211[8 * (int)v220];
                        *((_DWORD *)v210 + 1) = 0;
                        if ((int)((v53 & ((*(_DWORD *)v210 - *(_DWORD *)v221) >> 31))
                                 + *(_DWORD *)v210
                                 - *(_DWORD *)v221) >= (int)((v53 & ((*(_DWORD *)v226 - *(_DWORD *)v210) >> 31))
                                                           + *(_DWORD *)v226
                                                           - *(_DWORD *)v210))
                        {
                          v228 = *v224;
                          if ((_DWORD)v220)
                          {
                            *v224 = v228 | 1;
                            *(_DWORD *)v226 = *((_DWORD *)v177 - 3);
                          }
                          else
                          {
                            *((_DWORD *)v210 + 1) = v228;
                            *v224 = 0;
                          }
                        }
                        else
                        {
                          v227 = *v222;
                          if (v210 == v211)
                          {
                            *((_DWORD *)v210 + 1) = v227;
                            *v222 = 0;
                          }
                          else
                          {
                            *v222 = v227 | 1;
                            *(_DWORD *)v221 = *((_DWORD *)v177 - 2);
                          }
                        }
                      }
                    }
                    if (v211 == v212)
                    {
                      v212 = v211;
                      v229 = v211;
                    }
                    else
                    {
                      v229 = v211;
                      while (*((_DWORD *)v229 + 1))
                      {
                        v229 += 8;
                        if (v229 == v212)
                        {
                          v229 = v212;
                          goto LABEL_317;
                        }
                      }
                      if (v229 != v212)
                      {
                        v230 = v229 + 8;
                        if (v229 + 8 != v212)
                        {
                          do
                          {
                            if (*((_DWORD *)v230 + 1))
                            {
                              *(_QWORD *)v229 = *(_QWORD *)v230;
                              v229 += 8;
                            }
                            v230 += 8;
                          }
                          while (v230 != v212);
                          v211 = (char *)*((_QWORD *)this + 15);
                          v212 = (char *)*((_QWORD *)this + 16);
                        }
                      }
                    }
LABEL_317:
                    v231 = v229 - v211;
                    v232 = &v211[v231];
                    v233 = &v211[v231 + 8];
                    v234 = v212 - v233;
                    if (v212 != v233)
                    {
                      memmove(&v211[v231], v233, v212 - v233);
                      v211 = *v78;
                    }
                    *((_QWORD *)this + 16) = &v232[v234];
                    qsort(v211, (&v232[v234] - v211) >> 3, 8uLL, (int (__cdecl *)(const void *, const void *))apple::vision::libraries::autotrace::ContourToPath::ipCompare);
                  }
                }
              }
            }
          }
        }
      }
LABEL_320:
      v77 = v85;
    }
    while (v85 != v53);
  }
  qsort(*((void **)this + 12), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)this + 13) - *((_QWORD *)this + 12)) >> 2), 0xCuLL, (int (__cdecl *)(const void *, const void *))apple::vision::libraries::autotrace::ContourToPath::cornerCompare);
  v236 = (char *)*((_QWORD *)this + 12);
  v235 = (char *)*((_QWORD *)this + 13);
  v237 = 0xAAAAAAAAAAAAAAABLL * ((v235 - v236) >> 2);
  if (v237 >= 2 && v235 != v236)
  {
    v239 = 0;
    v240 = (int)v53 >> 1;
    do
    {
      v241 = v239++;
      LODWORD(v242) = v239;
      if ((uint64_t)v239 >= (int)v237)
      {
        v243 = v239 - (int)v237;
        LODWORD(v242) = v239 - v237;
        if (v243 >= (int)v237)
        {
          LODWORD(v242) = v239;
          if (v237 << 32)
            v242 = v243 % (int)v237;
        }
      }
      v244 = v242;
      v245 = &v236[12 * (int)v242];
      v246 = *(_DWORD *)&v236[12 * v241];
      v247 = *(_DWORD *)&v236[12 * v241 + 4];
      v248 = v246 - v240;
      v249 = v246 + v240;
      if (v246 + v240 >= v247)
        v250 = 0;
      else
        v250 = v53;
      v251 = v247 - v250;
      if (v248 > v247)
        v252 = v247 + v53;
      else
        v252 = v251;
      v253 = *(_DWORD *)v245;
      v254 = *(_DWORD *)&v236[12 * v244 + 4];
      if (v249 >= *(_DWORD *)v245)
        v255 = 0;
      else
        v255 = v53;
      v256 = v253 - v255;
      if (v248 > v253)
        v257 = v253 + v53;
      else
        v257 = v256;
      if (v249 >= v254)
        v258 = 0;
      else
        v258 = v53;
      v259 = v254 - v258;
      if (v248 > v254)
        v260 = v254 + v53;
      else
        v260 = v259;
      if (v257 <= v252 && v260 >= v246)
      {
        v262 = *(_DWORD *)&v236[12 * v244 + 8];
        v263 = v235 - (v245 + 12);
        if (v235 != v245 + 12)
          memmove(v245, v245 + 12, v235 - (v245 + 12));
        v235 = &v245[v263];
        *((_QWORD *)this + 13) = &v245[v263];
        v264 = *((_QWORD *)this + 15);
        v265 = *((_QWORD *)this + 16) - v264;
        if (v265)
        {
          v266 = v265 >> 3;
          if (v266 <= 1)
            v266 = 1;
          v267 = (_DWORD *)(v264 + 4);
          do
          {
            if (*(v267 - 1) == v262)
              *v267 &= ~1u;
            v267 += 2;
            --v266;
          }
          while (v266);
        }
      }
      v236 = (char *)*((_QWORD *)this + 12);
      v237 = 0xAAAAAAAAAAAAAAABLL * ((v235 - v236) >> 2);
    }
    while (v237 > v239);
  }
  v269 = (char *)*((_QWORD *)this + 15);
  v268 = (char *)*((_QWORD *)this + 16);
  if (v269 == v268)
  {
    v268 = (char *)*((_QWORD *)this + 15);
    v270 = v268;
  }
  else
  {
    v270 = (char *)*((_QWORD *)this + 15);
    while (*((_DWORD *)v270 + 1))
    {
      v270 += 8;
      if (v270 == v268)
      {
        v270 = (char *)*((_QWORD *)this + 16);
        goto LABEL_375;
      }
    }
    if (v270 != v268)
    {
      v271 = v270 + 8;
      if (v270 + 8 != v268)
      {
        do
        {
          if (*((_DWORD *)v271 + 1))
          {
            *(_QWORD *)v270 = *(_QWORD *)v271;
            v270 += 8;
          }
          v271 += 8;
        }
        while (v271 != v268);
        v269 = (char *)*((_QWORD *)this + 15);
        v268 = (char *)*((_QWORD *)this + 16);
      }
    }
  }
LABEL_375:
  v272 = (uint64_t)(v270 + 8);
  v273 = v268 - (v270 + 8);
  if (v268 != v270 + 8)
  {
    memmove(v270, (const void *)v272, v268 - (v270 + 8));
    v269 = (char *)*((_QWORD *)this + 15);
  }
  *((_QWORD *)this + 16) = &v270[v273];
  if (&v270[v273] == v269
    && !apple::vision::libraries::autotrace::ContourToPath::addInterestingPointAtIndex(0, 64, (_QWORD *)this + 15))
  {
LABEL_436:
    VNValidatedLog(4, (uint64_t)CFSTR("%s: failing findCorners"), v206, v207, a5, (uint64_t)a6, v208, v209, (uint64_t)"autoTrace");
    return 0;
  }
  v466[0] = 0.0;
  v461 = 0.0;
  v274 = **((unsigned int **)this + 3);
  if ((int)v274 >= 1)
  {
    v275 = 0;
    v276 = *((_QWORD *)this + 7);
    v277 = *((_QWORD *)this + 8);
    do
    {
      if (v275)
        v278 = 0;
      else
        v278 = v274;
      v279 = *(float *)(v276 + 4 * (v278 + v275) - 4) - *(float *)(v276 + 4 * v275);
      *(float *)(v277 + 4 * v275++) = v279 - rintf(v279);
    }
    while (v274 != v275);
  }
  v462 = 0;
  __p = 0;
  v464 = 0;
  v465 = 0;
  v280 = *((_QWORD *)this + 15);
  v281 = *((_QWORD *)this + 16) - v280;
  v451 = (uint64_t *)((char *)this + 120);
  if (!v281)
  {
LABEL_430:
    v310 = 1;
    goto LABEL_438;
  }
  v282 = 0;
  v283 = 0;
  v284 = v281 >> 3;
  v460 = (int)v274 >> 1;
  v285 = 1;
  do
  {
    ++v283;
    LODWORD(v286) = v285;
    if (v284 <= v285)
    {
      if (v285 - v284 >= v284)
        v286 = (v285 - v284) % v284;
      else
        LODWORD(v286) = v283 - v284;
    }
    if ((*(_BYTE *)(v280 + v282 + 4) & 1) != 0)
    {
      v287 = v280 + 8 * (int)v286;
      v289 = *(_BYTE *)(v287 + 4);
      v288 = (_BYTE *)(v287 + 4);
      if ((v289 & 1) != 0)
      {
        v290 = *(_DWORD *)(v280 + v282);
        v291 = (int *)(v280 + 8 * (int)v286);
        v292 = *v291;
        Corner = apple::vision::libraries::autotrace::CornerList::findCorner(*((apple::vision::libraries::autotrace::CornerList **)this + 12), *((apple::vision::libraries::autotrace::CornerList **)this + 13), **((unsigned int **)this + 3), v290, 1, (uint64_t)a6, v208, v209);
        if (!Corner)
          goto LABEL_437;
        v272 = *((unsigned int *)Corner + 1);
        if ((*v288 & 1) != 0)
        {
          v295 = *((unsigned int *)Corner + 1);
          v296 = apple::vision::libraries::autotrace::CornerList::findCorner(*((apple::vision::libraries::autotrace::CornerList **)this + 12), *((apple::vision::libraries::autotrace::CornerList **)this + 13), **((unsigned int **)this + 3), *v291, 1, (uint64_t)a6, v208, v209);
          v272 = v295;
          if (!v296)
          {
LABEL_437:
            v310 = 0;
            goto LABEL_438;
          }
          v294 = *(_DWORD *)v296;
        }
        else
        {
          v294 = v292;
        }
        if (v292 <= v290)
        {
          v298 = v272 - *(_DWORD *)(v280 + v282);
          if (v298 < 0)
            v298 = *(_DWORD *)(v280 + v282) - v272;
          v297 = v294;
          if (v298 > v460)
            goto LABEL_409;
          v299 = v294 - *v291;
          if (v299 < 0)
            v299 = *v291 - v294;
          if (v299 <= v460)
          {
            if (v294 <= (int)v272 - (int)v274)
              goto LABEL_393;
          }
          else
          {
LABEL_409:
            if (v294 <= (int)v272)
              goto LABEL_393;
          }
        }
        else
        {
          v297 = v294;
          if (v294 <= (int)v272)
            goto LABEL_393;
        }
        v300 = v297 - v272;
        if (v297 <= (int)v272)
          v301 = v274;
        else
          v301 = 0;
        v302 = v301 + v300;
        if (v301 + v300 >= 1)
        {
          v303 = v272;
          apple::vision::libraries::autotrace::ContourToPath::computeAngleSumAndRange(this, v272, v297, v466, &v461);
          v304 = fabsf(v466[0]);
          if (v302 > 0xF || v304 >= 0.000027778 || v461 >= 0.000027778)
          {
            if (v302 >= 0x15 && v304 > 0.0043056 && v304 < 0.027778)
            {
              v305 = v461 / fmaxf(v304, 0.01);
              if (v305 > 0.965 && v305 < 1.17)
              {
                apple::vision::libraries::autotrace::ContourToPath::appendInterestingPointAtIndex(v303, 8, &__p);
                apple::vision::libraries::autotrace::ContourToPath::appendInterestingPointAtIndex(v297, 16, &__p);
              }
            }
          }
          else
          {
            apple::vision::libraries::autotrace::ContourToPath::appendInterestingPointAtIndex(v303, 2, &__p);
            apple::vision::libraries::autotrace::ContourToPath::appendInterestingPointAtIndex(v297, 4, &__p);
          }
        }
      }
    }
LABEL_393:
    v280 = *((_QWORD *)this + 15);
    v284 = (*((_QWORD *)this + 16) - v280) >> 3;
    v282 += 8;
    v173 = v284 > (unint64_t)v285++;
  }
  while (v173);
  v307 = (char *)__p;
  v306 = v464;
  if (v464 == __p)
  {
    v310 = 1;
    if (v464)
      goto LABEL_439;
  }
  else
  {
    v308 = 0;
    v309 = 0;
    while (1)
    {
      apple::vision::libraries::autotrace::ContourToPath::insertPairIntoInterestingPoints((uint64_t)this, (uint64_t)&v307[v308], *(_DWORD *)&v307[v308 + 8], *(_DWORD *)&v307[v308 + 12], v451, &v462);
      v310 = v462 == 0;
      if (v462)
        break;
      v309 += 2;
      v307 = (char *)__p;
      v308 += 16;
      if (v309 >= (v464 - (_BYTE *)__p) >> 3)
        goto LABEL_430;
    }
LABEL_438:
    v306 = __p;
    if (__p)
LABEL_439:
      operator delete(v306);
  }
  if (!v310)
  {
    VNValidatedLog(4, (uint64_t)CFSTR("%s: failing findShortLinesAndShallowCurves"), v206, v207, a5, (uint64_t)a6, v208, v209, (uint64_t)"autoTrace");
    return 0;
  }
  LOBYTE(v461) = 0;
  v466[0] = 0.0;
  v314 = **((int **)this + 3);
  __p = 0;
  v464 = 0;
  v465 = 0;
  v315 = *((_QWORD *)this + 15);
  v316 = *((_QWORD *)this + 16) - v315;
  if (!v316)
  {
LABEL_641:
    v399 = 1;
    goto LABEL_642;
  }
  v317 = 0;
  v318 = 0;
  v319 = v316 >> 3;
  v452 = (int)v314 >> 1;
  v453 = 0;
  if ((int)v314 >= 0)
    v320 = v314;
  else
    v320 = v314 + 1;
  v449 = v320 >> 1;
  v450 = -(v320 >> 1);
  v321 = 0.0;
  v322 = 0.0;
  while (2)
  {
    v456 = v318;
    v323 = v317;
    LODWORD(v324) = v317 + 1;
    v458 = v317 + 1;
    v325 = v317 + 1 - v319;
    if ((uint64_t)(v317 + 1) >= v319)
    {
      LODWORD(v324) = v317 + 1 - v319;
      if (v325 >= v319)
        v324 = v325 % v319;
    }
    v326 = (int *)(v315 + 8 * v317);
    v327 = (int *)(v315 + 8 * (int)v324);
    v328 = *v326;
    v329 = *v327;
    v330 = v315 + 8 * v323;
    v332 = *(_BYTE *)(v330 + 4);
    v331 = (_BYTE *)(v330 + 4);
    if ((v332 & 1) != 0)
    {
      v334 = apple::vision::libraries::autotrace::CornerList::findCorner(*((apple::vision::libraries::autotrace::CornerList **)this + 12), *((apple::vision::libraries::autotrace::CornerList **)this + 13), **((unsigned int **)this + 3), *v326, 1, (uint64_t)a6, v208, v209);
      if (!v334)
        goto LABEL_628;
      v333 = *((_DWORD *)v334 + 1);
    }
    else
    {
      v333 = *v326;
    }
    v335 = v329;
    if ((*(_BYTE *)(v315 + 8 * (int)v324 + 4) & 1) != 0)
    {
      v336 = v333;
      v337 = apple::vision::libraries::autotrace::CornerList::findCorner(*((apple::vision::libraries::autotrace::CornerList **)this + 12), *((apple::vision::libraries::autotrace::CornerList **)this + 13), **((unsigned int **)this + 3), *v327, 1, (uint64_t)a6, v208, v209);
      if (!v337)
        goto LABEL_628;
      v335 = *(_DWORD *)v337;
      v333 = v336;
    }
    if (v329 > v328)
      goto LABEL_463;
    v338 = v333 - *v326;
    if (v338 < 0)
      v338 = *v326 - v333;
    if (v338 > v452)
      goto LABEL_463;
    v339 = v335 - *v327;
    if (v339 < 0)
      v339 = *v327 - v335;
    if (v339 > v452)
    {
LABEL_463:
      if (v335 > v333)
        goto LABEL_464;
      goto LABEL_483;
    }
    if (v335 <= v333 - (int)v314)
      goto LABEL_483;
LABEL_464:
    v340 = v335 - v333;
    if (v335 == v333)
    {
      if (*((_QWORD *)this + 16) - *((_QWORD *)this + 15) >= 9uLL)
      {
        VNValidatedLog(4, (uint64_t)CFSTR("%s: zero length curve in findNonOrthogonalLines at point index %d"), v206, v207, a5, (uint64_t)a6, v208, v209, (uint64_t)"findNonOrthogonalLines");
        goto LABEL_641;
      }
    }
    else if (v340 >= 0xFFFFFFFE
           && (int)v314 >= 101
           && *((_QWORD *)this + 16) - *((_QWORD *)this + 15) >= 0x11uLL)
    {
      VNValidatedLog(4, (uint64_t)CFSTR("%s: findNonOrthogonalLines with reversed point indexes %d and %d"), v206, v207, a5, (uint64_t)a6, v208, v209, (uint64_t)"findNonOrthogonalLines");
      goto LABEL_641;
    }
    if (v340 <= 0)
      v341 = v314;
    else
      v341 = 0;
    if ((*v331 & 0xA) != 0)
    {
LABEL_483:
      v317 = v458;
      v318 = v456;
    }
    else
    {
      v317 = v458;
      v318 = v456;
      if (v341 + v340 >= 21)
      {
        v342 = v333 + 10;
        v343 = v333 + 10;
        if (v333 + 10 >= (int)v314)
        {
          v345 = v342 - v314;
          if (v343 - v314 >= v314)
          {
            if ((_DWORD)v314)
              v343 = v345 % v314;
          }
          else
          {
            LODWORD(v343) = v343 - v314;
          }
        }
        else if (v333 <= -11)
        {
          v344 = v342 + v314;
          if (v343 + v314 < 0 == __OFADD__(v343, v314))
            LODWORD(v343) = v343 + v314;
          if (v344 < 0 && (_DWORD)v314)
            v343 = v344 % v314 + v314;
        }
        v346 = v335 - 11;
        LODWORD(v347) = v335 - 11;
        if (v335 - 11 >= (int)v314)
        {
          if (v346 - v314 >= v314)
          {
            if ((_DWORD)v314)
              v347 = (v346 - v314) % v314;
          }
          else
          {
            LODWORD(v347) = v346 - v314;
          }
        }
        else if (v335 <= 10)
        {
          v348 = v346 + v314;
          if (v348 < 0 == __OFADD__(v346, v314))
            LODWORD(v347) = v346 + v314;
          if (v348 < 0 && (_DWORD)v314)
            v347 = v348 % v314 + v314;
        }
        if ((_DWORD)v343 != (_DWORD)v347)
        {
          v349 = 0;
          v350 = -1;
          do
          {
            v351 = *((_QWORD *)this + 6);
            v352 = v314 + (int)v343;
            v353 = (int)v343 - v314;
            v354 = 0.0;
            v355 = -10;
            v356 = *(float *)(v351 + 4 * (int)v343);
            v357 = v356;
            do
            {
              v358 = (int)v343 + v355;
              if (v358 >= v314)
              {
                if (v353 + v355 >= v314)
                {
                  if ((_DWORD)v314)
                    v358 = (v353 + v355) % v314;
                }
                else
                {
                  LODWORD(v358) = v353 + v355;
                }
              }
              else if (v358 < 0)
              {
                v359 = v352 + v355;
                if (v352 + v355 >= 0)
                  LODWORD(v358) = v352 + v355;
                if (v359 < 0 && (_DWORD)v314)
                  v358 = v359 % v314 + v314;
              }
              v360 = *(float *)(v351 + 4 * (int)v358)
                   - rintf(*(float *)(v351 + 4 * (int)v358) - *(float *)(v351 + 4 * (int)v343));
              if (v360 > v356)
                v361 = v360;
              else
                v361 = v356;
              if (v360 >= v357)
                v356 = v361;
              else
                v357 = v360;
              v354 = v354 + v360;
              ++v355;
            }
            while (v355 != 11);
            v362 = 0;
            v363 = v354 / 21.0;
            v364 = (float)(v354 / 21.0) - (float)((float)(int)floorf((float)(v354 / 21.0) * 4.0) * 0.25);
            if (v364 > 0.125)
              v364 = 0.25 - v364;
            v365 = v364 * 360.0;
            do
            {
              v366 = v362 + 2;
              if (v362 == 20)
              {
                VNValidatedLog(4, (uint64_t)CFSTR("%s: angle %.3f not found in straightLineAngleDeltaToleranceAtAngle"), v206, v207, a5, (uint64_t)a6, v208, v209, (uint64_t)"straightLineAngleDeltaToleranceAtAngle");
                v373 = 12.235;
                goto LABEL_534;
              }
              v367 = &apple::vision::libraries::autotrace::SLADT[v362];
              v368 = *v367;
              v369 = v367[2];
              v370 = *v367 > v365 || v365 > v369;
              v362 = v366;
            }
            while (v370);
            v371 = (float)(v365 - v368) / (float)(v369 - v368);
            v372 = apple::vision::libraries::autotrace::SLADT[(((_DWORD)v366 - 2) & 0xFFFFFFFE) + 1];
            v373 = v372
                 + (float)(v371 * (float)(apple::vision::libraries::autotrace::SLADT[(v366 & 0xFFFFFFFE) + 1] - v372));
            if (v373 < 3.1)
              v373 = 3.1;
LABEL_534:
            v374 = v356 - v363;
            if ((float)(v363 - v357) > (float)(v356 - v363))
              v374 = v363 - v357;
            if (v374 <= v373)
            {
              if ((v349 & 1) != 0)
              {
                if (v350 + 1 >= (int)v314)
                  v375 = v314;
                else
                  v375 = 0;
                v376 = v363;
                v377 = v321;
                if (v363 >= v322)
                {
                  v376 = v322;
                  v377 = v321;
                  if (v363 > v321)
                  {
                    v376 = v322;
                    v377 = v363;
                  }
                }
                v378 = 0;
                v379 = v350 + 1 - v375;
                while (1)
                {
                  v380 = v378 + 2;
                  if (v378 == 6)
                    break;
                  v381 = &apple::vision::libraries::autotrace::SLGADT[v378];
                  v382 = v381[2];
                  v383 = *v381 > v365 || v365 > v382;
                  v378 += 2;
                  if (!v383)
                  {
                    v384 = (float)(v365 - *v381) / (float)(v382 - *v381);
                    v385 = apple::vision::libraries::autotrace::SLGADT[((v380 - 2) & 0xFFFFFFFE) + 1];
                    v386 = v385
                         + (float)(v384
                                 * (float)(apple::vision::libraries::autotrace::SLGADT[(v380 & 0xFFFFFFFE) + 1] - v385));
                    goto LABEL_553;
                  }
                }
                v386 = 1.0;
                VNValidatedLog(4, (uint64_t)CFSTR("%s: angle %.3f not found in straightLineGatheredAngleDeltaToleranceAtAngle"), v206, v207, a5, (uint64_t)a6, v208, v209, (uint64_t)"straightLineGatheredAngleDeltaToleranceAtAngle");
LABEL_553:
                if ((_DWORD)v343 == v379 && (float)(v377 - v376) <= v386)
                {
                  ++v318;
                  v349 = 1;
                  v350 = v343;
                  v322 = v376;
                  v321 = v377;
                }
                else
                {
                  v387 = v453 - 10;
                  v388 = v453 - 10;
                  if (v453 - 10 >= (int)v314)
                  {
                    v390 = v387 - v314;
                    if (v388 - v314 >= v314)
                    {
                      if ((_DWORD)v314)
                        v388 = v390 % v314;
                    }
                    else
                    {
                      LODWORD(v388) = v388 - v314;
                    }
                  }
                  else if (v453 <= 9)
                  {
                    v389 = v387 + v314;
                    if (v388 + v314 < 0 == __OFADD__(v388, v314))
                      LODWORD(v388) = v388 + v314;
                    if (v389 < 0 && (_DWORD)v314)
                      v388 = v389 % v314 + v314;
                  }
                  v391 = v318 + 20 + v388;
                  v392 = v391;
                  if (v391 >= (int)v314)
                  {
                    v394 = v391 - v314;
                    if (v392 - v314 >= v314)
                    {
                      if ((_DWORD)v314)
                        v392 = v394 % v314;
                    }
                    else
                    {
                      LODWORD(v392) = v392 - v314;
                    }
                  }
                  else if (v391 < 0)
                  {
                    v393 = v391 + v314;
                    if (v392 + v314 < 0 == __OFADD__(v392, v314))
                      LODWORD(v392) = v392 + v314;
                    if (v393 < 0 && (_DWORD)v314)
                      v392 = v393 % v314 + v314;
                  }
                  LODWORD(v466[0]) = v392;
                  if (apple::vision::libraries::autotrace::ContourToPath::outputLineAtIndex((uint64_t)this, v388, v318 + 20, &__p, v466, &v461))
                  {
                    v395 = v347 - LODWORD(v466[0]);
                    if ((int)v347 - LODWORD(v466[0]) >= v449)
                      v396 = v314;
                    else
                      v396 = 0;
                    if (v395 >= v450)
                      v397 = -v396;
                    else
                      v397 = v314;
                    if (v395 + v397 < 9)
                      goto LABEL_484;
                    v343 = SLODWORD(v466[0]) + 9;
                    if (LODWORD(v466[0]) + 9 >= (int)v314)
                    {
                      if (v343 - v314 >= v314)
                      {
                        if ((_DWORD)v314)
                          v343 = (v343 - v314) % v314;
                      }
                      else
                      {
                        LODWORD(v343) = v343 - v314;
                      }
                    }
                    else if (SLODWORD(v466[0]) <= -10)
                    {
                      v398 = v343 + v314;
                      if (v343 + v314 < 0 == __OFADD__(v343, v314))
                        LODWORD(v343) = v343 + v314;
                      if (v398 < 0 && (_DWORD)v314)
                        v343 = v398 % v314 + v314;
                    }
                  }
                  v349 = 0;
                  v399 = 0;
                  if (LOBYTE(v461))
                    goto LABEL_642;
                }
              }
              else
              {
                v318 = 1;
                v350 = v343;
                v453 = v343;
                v322 = v363;
                v321 = v363;
                v349 = 1;
              }
            }
            if ((int)v343 + 1 >= (int)v314)
              v400 = v314;
            else
              v400 = 0;
            if ((_DWORD)v343 != (_DWORD)v347)
              LODWORD(v343) = v343 + 1 - v400;
          }
          while ((_DWORD)v343 != (_DWORD)v347);
          if ((v349 & 1) != 0)
          {
            v401 = v453 - 10;
            v402 = v453 - 10;
            if (v453 - 10 >= (int)v314)
            {
              v404 = v401 - v314;
              if (v402 - v314 >= v314)
              {
                if ((_DWORD)v314)
                  v402 = v404 % v314;
              }
              else
              {
                LODWORD(v402) = v402 - v314;
              }
            }
            else if (v453 <= 9)
            {
              v403 = v401 + v314;
              if (v402 + v314 < 0 == __OFADD__(v402, v314))
                LODWORD(v402) = v402 + v314;
              if (v403 < 0 && (_DWORD)v314)
                v402 = v403 % v314 + v314;
            }
            v405 = v318 + 19 + v402;
            v406 = v405;
            if (v405 >= (int)v314)
            {
              v408 = v405 - v314;
              if (v406 - v314 >= v314)
              {
                if ((_DWORD)v314)
                  v406 = v408 % v314;
              }
              else
              {
                LODWORD(v406) = v406 - v314;
              }
            }
            else if (v405 < 0)
            {
              v407 = v405 + v314;
              if (v406 + v314 < 0 == __OFADD__(v406, v314))
                LODWORD(v406) = v406 + v314;
              if (v407 < 0 && (_DWORD)v314)
                v406 = v407 % v314 + v314;
            }
            LODWORD(v466[0]) = v406;
            apple::vision::libraries::autotrace::ContourToPath::outputLineAtIndex((uint64_t)this, v402, v318 + 19, &__p, v466, &v461);
            v317 = v458;
            if (LOBYTE(v461))
            {
LABEL_628:
              v399 = 0;
              goto LABEL_642;
            }
          }
        }
      }
    }
LABEL_484:
    v315 = *((_QWORD *)this + 15);
    v319 = (*((_QWORD *)this + 16) - v315) >> 3;
    if (v319 > v317)
      continue;
    break;
  }
  v410 = (char *)__p;
  v409 = v464;
  if (v464 == __p)
  {
    v399 = 1;
    goto LABEL_643;
  }
  v411 = 0;
  v412 = 0;
  while (1)
  {
    apple::vision::libraries::autotrace::ContourToPath::insertPairIntoInterestingPoints((uint64_t)this, (uint64_t)&v410[v411], *(_DWORD *)&v410[v411 + 8], *(_DWORD *)&v410[v411 + 12], v451, &v461);
    v399 = LOBYTE(v461) == 0;
    if (LOBYTE(v461))
      break;
    v412 += 2;
    v410 = (char *)__p;
    v411 += 16;
    if (v412 >= (v464 - (_BYTE *)__p) >> 3)
      goto LABEL_641;
  }
LABEL_642:
  v409 = __p;
LABEL_643:
  if (v409)
    operator delete(v409);
  if (v399)
  {
    if (apple::vision::libraries::autotrace::ContourToPath::findInflectionPoints(this, v272, v206, v207, a5, (uint64_t)a6, v208, v209))
    {
      if ((apple::vision::libraries::autotrace::ContourToPath::cutUpCurves(this, v413, v414, v415, v416, v417, v418, v419) & 1) != 0)
      {
        if ((apple::vision::libraries::autotrace::ContourToPath::coalesceStraightLines(this, v420, v421, v422, v423, v424, v425, v426) & 1) != 0)
        {
          apple::vision::libraries::autotrace::ContourToPath::extractCurveRecords(this, v427, v428, v429, v430, v431, v432, v433);
          apple::vision::libraries::autotrace::ContourToPath::computeCurveTangents(this, v434, v435, v436, v437, v438, v439, v440);
          apple::vision::libraries::autotrace::ContourToPath::computePoints(this, v441, v442, v443, v444, v445, v446, v447);
          apple::vision::libraries::autotrace::ContourToPath::findSubdividedCurves(this, v448);
          apple::vision::libraries::autotrace::ContourToPath::convertToPaths(this);
          return 1;
        }
        VNValidatedLog(4, (uint64_t)CFSTR("%s: failing coalesceStraightLines"), v428, v429, v430, v431, v432, v433, (uint64_t)"autoTrace");
      }
      else
      {
        VNValidatedLog(4, (uint64_t)CFSTR("%s: failing cutUpCurves"), v421, v422, v423, v424, v425, v426, (uint64_t)"autoTrace");
      }
    }
    else
    {
      VNValidatedLog(4, (uint64_t)CFSTR("%s: failing findInflectionPoints"), v414, v415, v416, v417, v418, v419, (uint64_t)"autoTrace");
    }
  }
  else
  {
    VNValidatedLog(4, (uint64_t)CFSTR("%s: failing findNonOrthogonalLines"), v206, v207, a5, (uint64_t)a6, v208, v209, (uint64_t)"autoTrace");
  }
  return 0;
}

void sub_1A150DDE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void apple::vision::libraries::autotrace::ContourToPath::~ContourToPath(CGPathRef *this)
{
  const CGPath *v2;
  const CGPath *v3;
  const CGPath *v4;

  CGPathRelease(this[2]);
  apple::vision::libraries::autotrace::ContourToPath::freeAutoTraceStructures((apple::vision::libraries::autotrace::ContourToPath *)this);
  v2 = this[18];
  if (v2)
  {
    this[19] = v2;
    operator delete(v2);
  }
  v3 = this[15];
  if (v3)
  {
    this[16] = v3;
    operator delete(v3);
  }
  v4 = this[12];
  if (v4)
  {
    this[13] = v4;
    operator delete(v4);
  }
}

void apple::vision::libraries::autotrace::ContourToPath::freeAutoTraceStructures(apple::vision::libraries::autotrace::ContourToPath *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  v2 = (void *)*((_QWORD *)this + 6);
  if (v2)
  {
    free(v2);
    *((_QWORD *)this + 6) = 0;
  }
  v3 = (void *)*((_QWORD *)this + 10);
  if (v3)
  {
    free(v3);
    *((_QWORD *)this + 10) = 0;
  }
  v4 = (void *)*((_QWORD *)this + 11);
  if (v4)
  {
    free(v4);
    *((_QWORD *)this + 11) = 0;
  }
  v5 = (void *)*((_QWORD *)this + 7);
  if (v5)
  {
    free(v5);
    *((_QWORD *)this + 7) = 0;
  }
  v6 = (void *)*((_QWORD *)this + 8);
  if (v6)
  {
    free(v6);
    *((_QWORD *)this + 8) = 0;
  }
  v7 = (void *)*((_QWORD *)this + 9);
  if (v7)
  {
    free(v7);
    *((_QWORD *)this + 9) = 0;
  }
  *((_DWORD *)this + 10) = 0;
}

BOOL apple::vision::libraries::autotrace::ContourToPath::findInflectionPoints(apple::vision::libraries::autotrace::ContourToPath *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  apple::vision::libraries::autotrace::ContourToPath *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  int *v19;
  int v20;
  signed int *v21;
  uint64_t v22;
  signed int v23;
  int v24;
  int v25;
  int v26;
  signed int v27;
  int v28;
  apple::vision::libraries::autotrace::CornerList *Corner;
  int v30;
  int v31;
  int v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  int *v36;
  char v37;
  uint64_t v38;
  int v39;
  apple::vision::libraries::autotrace::CornerList *v40;
  uint64_t v41;
  int *v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  signed int v48;
  uint64_t v49;
  float v50;
  int v51;
  int v52;
  int v53;
  float v54;
  int v55;
  int v56;
  int v57;
  BOOL v58;
  _BYTE *v59;
  uint64_t v60;
  char *v61;
  char *v62;
  char *v63;
  uint64_t v64;
  _BOOL8 v65;
  void *v66;
  unint64_t v67;
  unint64_t v68;
  unsigned int *v69;
  uint64_t v70;
  BOOL v72;
  _QWORD *v74;
  int *v75;
  uint64_t v76;
  void *__p;
  void *v79;
  uint64_t v80;

  v8 = **((_DWORD **)this + 3);
  __p = 0;
  v79 = 0;
  v80 = 0;
  v9 = *((_QWORD *)this + 15);
  v10 = *((_QWORD *)this + 16) - v9;
  if (!v10)
  {
    v65 = 1;
    goto LABEL_101;
  }
  v11 = this;
  v74 = (_QWORD *)((char *)this + 120);
  v12 = 0;
  v13 = 0;
  v14 = v10 >> 3;
  do
  {
    v15 = v13 + 1;
    v16 = v15 - v14;
    if (v15 >= v14)
    {
      if (v16 >= v14)
        v16 %= v14;
    }
    else
    {
      LODWORD(v16) = v13 + 1;
      if (v13 <= -2)
      {
        v16 = v14 + v15;
        if (v14 + v15 < 0)
          v16 = v16 % v14 + v14;
      }
    }
    v17 = v9 + 8 * v12;
    v20 = *(_DWORD *)(v17 + 4);
    v19 = (int *)(v17 + 4);
    v18 = v20;
    if ((v20 & 0xA) == 0)
    {
      v76 = v12;
      v21 = (signed int *)(v9 + 8 * (int)v16);
      v22 = *(unsigned int *)(v9 + 8 * v12);
      v23 = *v21;
      v24 = *v21 - v22;
      if (*v21 <= (int)v22)
        v25 = v8;
      else
        v25 = 0;
      v26 = v25 + v24;
      if ((v18 & 1) != 0)
      {
        v28 = v25 + v24;
        Corner = apple::vision::libraries::autotrace::CornerList::findCorner(*((apple::vision::libraries::autotrace::CornerList **)v11 + 12), *((apple::vision::libraries::autotrace::CornerList **)v11 + 13), **((unsigned int **)v11 + 3), v22, 1, a6, a7, a8);
        if (!Corner)
          goto LABEL_91;
        v27 = *((_DWORD *)Corner + 1);
        v30 = v22;
        v26 = v28;
        while (v30 != v27)
        {
          v31 = v30 + 1;
          if (v31 >= v8)
            v32 = v8;
          else
            v32 = 0;
          v30 = v31 - v32;
          --v28;
          if (v30 == v23)
          {
            v27 = v23;
            break;
          }
        }
      }
      else
      {
        v27 = v22;
        v28 = v25 + v24;
      }
      v33 = (int)v16;
      if (v27 != v23 || v28)
      {
        v35 = v9 + 8 * (int)v16;
        v37 = *(_BYTE *)(v35 + 4);
        v36 = (int *)(v35 + 4);
        if ((v37 & 1) != 0)
        {
          v75 = v36;
          v38 = (int)v16;
          v39 = v26;
          v40 = apple::vision::libraries::autotrace::CornerList::findCorner(*((apple::vision::libraries::autotrace::CornerList **)this + 12), *((apple::vision::libraries::autotrace::CornerList **)this + 13), **((unsigned int **)this + 3), *v21, 1, a6, a7, a8);
          if (!v40)
            goto LABEL_91;
          if (v23 == (_DWORD)v22)
          {
            v23 = v22;
            v26 = v39;
            v33 = v38;
            v36 = v75;
          }
          else
          {
            v26 = v39;
            v33 = v38;
            v36 = v75;
            while (v23 != *(_DWORD *)v40)
            {
              if (v23 <= 0)
                v45 = v8;
              else
                v45 = 0;
              v23 = v23 + v45 - 1;
              --v28;
              if (v23 == (_DWORD)v22)
              {
                v23 = v22;
                goto LABEL_49;
              }
            }
            v23 = *(_DWORD *)v40;
          }
        }
LABEL_49:
        if (v28 > 3)
        {
          if (!apple::vision::libraries::autotrace::ContourToPath::addInterestingPointAtIndex(v27, 8, &__p))
            goto LABEL_91;
          LOBYTE(v47) = *(float *)(*((_QWORD *)this + 8) + 4 * v27) > 0.0;
          v48 = v27;
          do
          {
            v49 = *((_QWORD *)this + 8);
            v50 = *(float *)(v49 + 4 * v48);
            v51 = v47 & 1;
            if (v51 == v50 <= 0.0)
            {
              if (v48 <= 0)
                v53 = v8;
              else
                v53 = 0;
              v54 = *(float *)(v49 + 4 * (v48 + v53 - 1));
              v52 = v48 + 1;
              if (v48 + 1 >= v8)
                v55 = v8;
              else
                v55 = 0;
              v47 = (float)((float)((float)(v50 + v54) + *(float *)(v49 + 4 * (v52 - v55))) * 0.33333) > 0.0;
              if (v51 != v47
                && (v8 & ((v48 - v27) >> 31)) + v48 - v27 >= 6
                && (v8 & ((v23 - v48) >> 31)) + v23 - v48 >= 6
                && (!apple::vision::libraries::autotrace::ContourToPath::addInterestingPointAtIndex(v48, 16, &__p)
                 || !apple::vision::libraries::autotrace::ContourToPath::addInterestingPointAtIndex(v48, 32, &__p)
                 || !apple::vision::libraries::autotrace::ContourToPath::addInterestingPointAtIndex(v48, 8, &__p)))
              {
                goto LABEL_91;
              }
            }
            else
            {
              v52 = v48 + 1;
            }
            if (v52 >= v8)
              v56 = v8;
            else
              v56 = 0;
            v48 = v52 - v56;
          }
          while (v52 - v56 != v23);
          v11 = this;
          if (!apple::vision::libraries::autotrace::ContourToPath::addInterestingPointAtIndex(v23, 16, &__p))
          {
LABEL_91:
            v65 = 0;
            goto LABEL_101;
          }
        }
        else
        {
          v46 = *v19;
          if ((*v19 & 1) == 0)
          {
            v11 = this;
            goto LABEL_10;
          }
          v57 = *v36;
          v58 = (v46 & 0xA) != 0 || (*v36 & 1) == 0;
          v11 = this;
          if (!v58)
          {
            if (v26 >= 3)
            {
              *v19 = v46 | 8;
              *v36 |= 0x10u;
              goto LABEL_10;
            }
            if ((v46 & 0x10) != 0)
            {
              v57 |= 0x10u;
              *v36 = v57;
              v46 = *v19;
            }
            if ((v46 & 4) != 0)
              *v36 = v57 | 4;
            goto LABEL_84;
          }
        }
      }
      else
      {
        v34 = *v19;
        if ((*v19 & 1) == 0)
        {
          v11 = this;
          goto LABEL_10;
        }
        v11 = this;
        if ((v34 & 0xA) == 0)
        {
          v41 = v9 + 8 * (int)v16;
          v44 = *(_DWORD *)(v41 + 4);
          v42 = (int *)(v41 + 4);
          v43 = v44;
          if ((v44 & 1) != 0)
          {
            if (v26 >= 3)
            {
              *v19 = v34 | 8;
              *v42 |= 0x10u;
              goto LABEL_10;
            }
            if ((v34 & 0x10) != 0)
            {
              v43 |= 0x10u;
              *v42 = v43;
              v34 = *v19;
            }
            if ((v34 & 4) != 0)
              *v42 = v43 | 4;
LABEL_84:
            v60 = *((_QWORD *)v11 + 15);
            v59 = (_BYTE *)*((_QWORD *)v11 + 16);
            if (((uint64_t)&v59[-v60] >> 3) - 1 == v76)
            {
              v61 = v59 - 8;
            }
            else
            {
              v62 = (char *)(v60 + 8 * v33);
              v63 = v62 - 8;
              v64 = v59 - v62;
              if (v59 != v62)
                memmove(v62 - 8, v62, v59 - v62);
              v61 = &v63[v64];
            }
            *((_QWORD *)v11 + 16) = v61;
            --v13;
          }
        }
      }
    }
LABEL_10:
    v12 = ++v13;
    v9 = *((_QWORD *)v11 + 15);
    v14 = (*((_QWORD *)v11 + 16) - v9) >> 3;
  }
  while (v14 > (unint64_t)v13);
  v66 = v79;
  if (v79 == __p)
  {
    v65 = 1;
    if (v79)
      goto LABEL_102;
  }
  else
  {
    v67 = ((_BYTE *)v79 - (_BYTE *)__p) >> 3;
    if (v67 <= 1)
      v67 = 1;
    v68 = v67 - 1;
    v69 = (unsigned int *)((char *)__p + 4);
    do
    {
      v70 = apple::vision::libraries::autotrace::ContourToPath::addInterestingPointAtIndex(*(v69 - 1), *v69, v74);
      v65 = v70 != 0;
      v72 = v68-- != 0;
      if (!v70)
        break;
      v69 += 2;
    }
    while (v72);
LABEL_101:
    v66 = __p;
    if (__p)
LABEL_102:
      operator delete(v66);
  }
  return v65;
}

void sub_1A150E40C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t apple::vision::libraries::autotrace::ContourToPath::cutUpCurves(apple::vision::libraries::autotrace::ContourToPath *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char *v8;
  char *v9;
  char *v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  float v19;
  unint64_t v20;
  int v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  BOOL v28;
  int v29;
  int v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  float v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  int v59;
  uint64_t v60;
  _BOOL8 v61;
  uint64_t v62;
  apple::vision::libraries::autotrace::CornerList *Corner;
  _BOOL8 v64;
  uint64_t v65;
  _BOOL8 v66;
  apple::vision::libraries::autotrace::CornerList *v67;
  int v68;
  int v69;
  BOOL v70;
  void *v71;
  char *v72;
  uint64_t v73;
  unint64_t v74;
  unsigned int *v75;
  uint64_t v76;
  unsigned int v77;
  int v78;
  BOOL v79;
  int v80;
  uint64_t v82;
  _QWORD *v84;
  int v85;
  uint64_t v86;
  char v88;
  void *__p;
  void *v90;
  uint64_t v91;

  v10 = (char *)*((_QWORD *)this + 15);
  v8 = (char *)this + 120;
  v9 = v10;
  v11 = **((unsigned int **)v8 - 12);
  v12 = (char *)*((_QWORD *)v8 + 1);
  v13 = v12 - v10;
  if (v12 - v10 == 8)
  {
    v14 = *((_DWORD *)v9 + 1) != 64 || (int)v11 < 1;
    if (!v14)
    {
      v15 = 0;
      v16 = *((_QWORD *)this + 7);
      while (1)
      {
        v17 = v15 + 1;
        v18 = v11 - 1 == v15 ? 0 : v15 + 1;
        v19 = *(float *)(v16 + 4 * v15);
        if (v19 <= 0.5 && *(float *)(v16 + 4 * v18) >= 0.5)
          break;
        if (v19 >= 0.5 && *(float *)(v16 + 4 * v18) <= 0.5)
          break;
        ++v15;
        if (v11 == v17)
          goto LABEL_17;
      }
      *(_DWORD *)v9 = v15;
      *((_DWORD *)v9 + 1) = 24;
    }
  }
LABEL_17:
  if (v12 == v9)
  {
    __p = 0;
    v90 = 0;
    v82 = 1;
    v91 = 0;
LABEL_128:
    v71 = __p;
    if (!__p)
      return v82;
LABEL_129:
    v90 = v71;
    operator delete(v71);
    return v82;
  }
  v84 = v8;
  v20 = 0;
  v21 = v11;
  v22 = v13 >> 3;
  do
  {
    v23 = v20++;
    LODWORD(v24) = v20;
    v25 = v20 - v22;
    if ((uint64_t)v20 >= v22)
    {
      LODWORD(v24) = v20 - v22;
      if (v25 >= v22)
        v24 = v25 % v22;
    }
    if ((v9[8 * v23 + 4] & 8) != 0)
    {
      v26 = *(_DWORD *)&v9[8 * v23];
      v27 = *(_DWORD *)&v9[8 * (int)v24];
      v28 = __OFSUB__(v27, v26);
      v29 = v27 - v26;
      v30 = (v29 < 0) ^ v28 | (v29 == 0) ? v11 : 0;
      v31 = (v30 + v29);
      if ((int)v31 >= 1)
      {
        v32 = 0;
        v34 = *((_QWORD *)this + 8);
        v33 = *((_QWORD *)this + 9);
        do
        {
          v35 = v26;
          v36 = *(float *)(v34 + 4 * v26);
          if ((_DWORD)v11 == (_DWORD)v31)
          {
            v37 = -1;
            v38 = 1 - (int)v11;
            v39 = (int)v11 + 1;
            a6 = ~(uint64_t)(int)v11;
            a7 = (int)v11 - 1;
            a8 = 1;
            do
            {
              v40 = a8 + v35;
              LODWORD(v41) = a8 + v35 - v11;
              if (a8 + v35 >= (int)v11)
              {
                if (v35 + v38 >= (int)v11)
                  v41 = (v35 + v38) % (int)v11;
              }
              else
              {
                LODWORD(v41) = a8 + v35;
                if (v40 < 0)
                {
                  if (v35 + v39 < 0)
                    v41 = (v35 + v39) % (int)v11 + (int)v11;
                  else
                    LODWORD(v41) = v40 + v11;
                }
              }
              v42 = v35 - a8;
              v43 = v35 + v37;
              if (v35 + v37 >= (int)v11)
              {
                if (v35 + a6 >= (int)v11)
                  v43 = (v35 + a6) % (int)v11;
                else
                  LODWORD(v43) = v42 - v11;
              }
              else if (v43 < 0)
              {
                if (v35 + a7 < 0)
                  v43 = (v35 + a7) % (int)v11 + (int)v11;
                else
                  LODWORD(v43) = v42 + v11;
              }
              ++a8;
              --v37;
              --a7;
              v36 = (float)(v36 + *(float *)(v34 + 4 * (int)v41)) + *(float *)(v34 + 4 * (int)v43);
              --a6;
              ++v39;
              ++v38;
            }
            while (v37 != -5);
            v44 = 9;
          }
          else
          {
            v45 = 1;
            a6 = -1;
            a7 = ~(uint64_t)(int)v11;
            a8 = (int)v11 - 1;
            v46 = 1 - (int)v11;
            v47 = (int)v11 + 1;
            v44 = 1;
            do
            {
              if (v45 < (uint64_t)(v31 - v32))
              {
                v48 = v26 + v45;
                if (v48 >= (int)v11)
                {
                  if (v26 + v46 >= (int)v11)
                  {
                    if ((_DWORD)v11)
                      v48 = (v26 + v46) % (int)v11;
                  }
                  else
                  {
                    LODWORD(v48) = v26 + v46;
                  }
                }
                else if (v48 < 0)
                {
                  v49 = v26 + v47;
                  if (v49 >= 0)
                    LODWORD(v48) = v26 + v47;
                  if (v49 < 0 && (_DWORD)v11)
                    v48 = v49 % (int)v11 + (int)v11;
                }
                v36 = v36 + *(float *)(v34 + 4 * (int)v48);
                ++v44;
              }
              if (v32 >= v45)
              {
                v50 = v26 + a6;
                if (v50 >= (int)v11)
                {
                  if (v26 + a7 >= (int)v11)
                  {
                    if ((_DWORD)v11)
                      v50 = (v26 + a7) % (int)v11;
                  }
                  else
                  {
                    LODWORD(v50) = v26 + a7;
                  }
                }
                else if (v50 < 0)
                {
                  v51 = v26 + a8;
                  if (v51 >= 0)
                    LODWORD(v50) = v26 + a8;
                  if (v51 < 0 && (_DWORD)v11)
                    v50 = v51 % (int)v11 + (int)v11;
                }
                v36 = v36 + *(float *)(v34 + 4 * (int)v50);
                ++v44;
              }
              ++v45;
              ++v47;
              ++v46;
              --a6;
              --a8;
              --a7;
            }
            while (v45 != 5);
          }
          *(float *)(v33 + 4 * v35) = v36 / (float)v44;
          v52 = v35 + 1;
          if (v52 >= (int)v11)
            v53 = v11;
          else
            v53 = 0;
          v26 = v52 - v53;
          ++v32;
        }
        while (v32 != v31);
      }
    }
  }
  while (v20 < v22);
  v54 = 0;
  v55 = 0;
  __p = 0;
  v90 = 0;
  v85 = (int)v11 >> 1;
  v56 = 1;
  v91 = 0;
  do
  {
    v57 = v55 + 1;
    v86 = v57;
    if (v22 <= v56)
    {
      v57 = v56 - v22;
      if (v56 - v22 >= v22)
        v57 %= v22;
    }
    v58 = &v9[8 * (int)v57];
    v59 = *(_DWORD *)&v9[v54];
    v60 = *(unsigned int *)v58;
    if ((v9[v54 + 4] & 1) != 0)
    {
      Corner = apple::vision::libraries::autotrace::CornerList::findCorner(*((apple::vision::libraries::autotrace::CornerList **)this + 12), *((apple::vision::libraries::autotrace::CornerList **)this + 13), **((unsigned int **)this + 3), *(unsigned int *)&v9[v54], 1, a6, a7, a8);
      if (!Corner)
        goto LABEL_126;
      v62 = *((unsigned int *)Corner + 1);
      v61 = (_DWORD)v62 == v59;
    }
    else
    {
      v61 = 1;
      v62 = *(unsigned int *)&v9[v54];
    }
    if ((v9[8 * (int)v57 + 4] & 1) != 0)
    {
      v66 = v61;
      v67 = apple::vision::libraries::autotrace::CornerList::findCorner(*((apple::vision::libraries::autotrace::CornerList **)this + 12), *((apple::vision::libraries::autotrace::CornerList **)this + 13), **((unsigned int **)this + 3), *(unsigned int *)v58, 1, a6, a7, a8);
      if (!v67)
        goto LABEL_126;
      v65 = *(unsigned int *)v67;
      v64 = (_DWORD)v65 == (_DWORD)v60;
      v61 = v66;
    }
    else
    {
      v64 = 1;
      v65 = v60;
    }
    if ((int)v60 > v59)
      goto LABEL_99;
    v68 = v62 - *(_DWORD *)&v9[v54];
    if (v68 < 0)
      v68 = *(_DWORD *)&v9[v54] - v62;
    if (v68 > v85)
      goto LABEL_99;
    v69 = v65 - *(_DWORD *)v58;
    if (v69 < 0)
      v69 = *(_DWORD *)v58 - v65;
    if (v69 <= v85)
    {
      if ((int)v65 <= (int)v62 - v21)
        goto LABEL_108;
    }
    else
    {
LABEL_99:
      if ((int)v65 <= (int)v62)
        goto LABEL_108;
    }
    v70 = (_DWORD)v62 == (_DWORD)v65 && (!v61 || !v64);
    if (!v70
      && (v9[v54 + 4] & 8) != 0
      && !apple::vision::libraries::autotrace::ContourToPath::cutUpCurve((uint64_t)this, v62, v61, v65, v64, &__p, a7, a8))
    {
LABEL_126:
      v82 = 0;
      goto LABEL_128;
    }
LABEL_108:
    v55 = v86;
    v9 = (char *)*((_QWORD *)this + 15);
    v22 = (uint64_t)(*((_QWORD *)this + 16) - (_QWORD)v9) >> 3;
    v54 += 8;
    v14 = v22 > (unint64_t)v56++;
  }
  while (v14);
  v72 = (char *)__p;
  v71 = v90;
  if (v90 != __p)
  {
    v73 = 0;
    v74 = 0;
    while (1)
    {
      v88 = 0;
      v75 = (unsigned int *)&v72[v73];
      v77 = *v75;
      v76 = v75[1];
      v78 = apple::vision::libraries::autotrace::ContourToPath::indexOfNewInterestingPointAtPointIndex(*v75, *((_QWORD *)this + 15), *((_QWORD *)this + 16), &v88);
      if (v88)
        v79 = (v76 & 0x18) == 24;
      else
        v79 = 0;
      if (!v79)
        goto LABEL_123;
      v80 = *(_DWORD *)(*v84 + 8 * v78 + 4);
      if ((v80 & 0x18) != 8 && (v80 & 0x18) != 16)
        break;
LABEL_124:
      ++v74;
      v72 = (char *)__p;
      v73 += 8;
      if (v74 >= ((_BYTE *)v90 - (_BYTE *)__p) >> 3)
      {
        v82 = 1;
        goto LABEL_128;
      }
    }
    if ((v80 & 4) != 0)
      v76 = 8;
    else
      v76 = v76;
LABEL_123:
    if (!apple::vision::libraries::autotrace::ContourToPath::addInterestingPointAtIndex(v77, v76, v84))
      goto LABEL_126;
    goto LABEL_124;
  }
  v82 = 1;
  if (v90)
    goto LABEL_129;
  return v82;
}

void sub_1A150EA2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t apple::vision::libraries::autotrace::ContourToPath::coalesceStraightLines(apple::vision::libraries::autotrace::ContourToPath *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char *v8;
  char *v9;
  apple::vision::libraries::autotrace::ContourToPath *v10;
  uint64_t v11;
  int v12;
  unint64_t v13;
  int *v14;
  uint64_t v15;
  float v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  uint64_t v21;
  char *v22;
  int v23;
  unint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  int v33;
  int v34;
  float v35;
  float v36;
  float v37;
  float v38;
  uint64_t v39;
  uint64_t v40;
  float v41;
  char v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  char *v48;
  char *v49;
  int64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  int *v59;
  int v60;
  int v61;
  BOOL v62;
  int v63;
  int v64;
  uint64_t v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  int v72;
  float v73;
  float v74;
  float v75;
  int v76;
  float v77;
  uint64_t v78;
  uint64_t v79;
  char *v80;
  const void *v81;
  size_t v82;
  char *v83;
  unint64_t v84;
  unint64_t v85;
  uint64_t v86;
  int v87;
  uint64_t v88;
  uint64_t v89;
  char *v90;
  int v91;
  _BYTE *v92;
  int v93;
  int *v94;
  uint64_t v95;
  int *v96;
  int v97;
  int v98;
  char *v99;
  int v100;
  unsigned int *v101;
  int v102;
  float v103;
  apple::vision::libraries::autotrace::ContourToPath *v104;
  int v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  int v111;
  int v112;
  float v113;
  int v114;
  int v115;
  float v116;
  unsigned int v117;
  unsigned int v118;
  unint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  char *v126;
  int v127;
  char *v128;
  int v129;
  int v130;
  char *v131;
  unsigned int *v132;
  unsigned int v133;
  unsigned int v134;
  int v135;
  uint64_t v136;
  char *v137;
  size_t v138;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  float32x2_t v143;
  uint64_t v144;
  uint64_t v145;
  int v146;
  _BYTE v148[76];
  float v149;
  float v150;
  float v151;
  uint64_t v152;
  float v153;
  float v154;
  uint64_t v155;
  float v156;
  BOOL v157;
  float v158[300];
  uint64_t v159;

  v159 = *MEMORY[0x1E0C80C00];
  v156 = 0.0;
  v155 = 0;
  v154 = 0.0;
  v149 = 0.0;
  v150 = 0.0;
  v9 = (char *)*((_QWORD *)this + 15);
  v8 = (char *)*((_QWORD *)this + 16);
  if (v8 == v9)
    return 1;
  v10 = this;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = (int *)*((_QWORD *)this + 3);
  v140 = *((_QWORD *)v14 + 1);
  v146 = *v14;
  v153 = 0.0;
  v152 = 0;
  v151 = 0.0;
  v157 = 0;
  v15 = (v8 - v9) >> 3;
  v16 = 0.0;
  v17 = 1;
  v18 = 12;
  do
  {
    v19 = v13;
    v20 = &v9[8 * v13++];
    if ((v20[4] & 2) != 0)
    {
      LODWORD(v21) = v13;
      if (v15 > v13)
      {
        v22 = &v9[v18];
        v21 = v17;
        while (1)
        {
          v23 = *(_DWORD *)v22;
          v22 += 8;
          if ((v23 & 7) != 6)
            break;
          if (v15 == ++v21)
          {
            LODWORD(v21) = v15;
            break;
          }
        }
      }
      if (v13 != v21 && v19 < v21)
      {
        v141 = v19;
        v142 = v13;
        v24 = 0;
        v25 = (v12 + v21);
        v144 = v11;
        v26 = v19;
        do
        {
          ++v26;
          v27 = *((_QWORD *)this + 15);
          v28 = *((_QWORD *)this + 16);
          v29 = (v28 - v27) >> 3;
          LODWORD(v30) = v26;
          if (v29 <= (uint64_t)(v17 + v24))
          {
            v31 = v17 + v24 - v29;
            LODWORD(v30) = v17 + v24 - v29;
            if (v31 >= v29)
            {
              LODWORD(v30) = v26;
              if (v28 != v27)
                v30 = v31 % v29;
            }
          }
          v32 = *(_DWORD *)(v27 + v11);
          v33 = *(_DWORD *)(v27 + 8 * (int)v30) - v32;
          v34 = (v146 & (v33 >> 31)) + v33;
          apple::vision::libraries::autotrace::ATRRecord::ATRRecord((uint64_t)v148, *((const EPolygon **)this + 3), v32, v34);
          apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)v148, &v157, &v153, (float *)&v152 + 1);
          if (v24 <= 0x12B)
          {
            apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)**((unsigned int **)this + 3), *(const EPolygon **)(*((_QWORD *)this + 3) + 8), v32, v34, v157, *((float *)&v152 + 1), v35);
            v158[v24] = v36;
          }
          ++v24;
          v11 += 8;
        }
        while (v25 != v24);
        if (v25 < 0x12C)
        {
          v38 = v158[0];
          v11 = v144;
          if (v25 < 2)
          {
            LODWORD(v40) = 1;
            v43 = v158[0];
            v42 = 1;
            v10 = this;
LABEL_41:
            if ((_DWORD)v40 == (_DWORD)v25)
            {
LABEL_42:
              v9 = (char *)*((_QWORD *)v10 + 15);
              v8 = (char *)*((_QWORD *)v10 + 16);
              v48 = &v9[8 * v25];
              v49 = &v48[8 * v25 - 8];
              if (v48 != v49)
              {
                v50 = v8 - v49;
                if (v8 != v49)
                {
                  memmove(v48, v49, v8 - v49);
                  v9 = (char *)*((_QWORD *)v10 + 15);
                }
                v8 = &v48[v50];
                *((_QWORD *)v10 + 16) = &v48[v50];
              }
              v13 = v142;
              if ((((float)(v43 - v38) > 0.00055556) & v42) == 1)
              {
                *(_DWORD *)&v9[8 * v141 + 4] = *(_DWORD *)&v9[8 * v141 + 4] & 0xFFFFFFF5 | 8;
                LODWORD(v51) = v142;
                if (v142 >= (v8 - v9) >> 3)
                {
                  v52 = (v8 - v9) >> 3;
                  LODWORD(v51) = v142 - v52;
                  if (v142 - v52 >= v52)
                  {
                    LODWORD(v51) = v142;
                    if (v8 != v9)
                      v51 = (v142 - v52) % v52;
                  }
                }
                *(_DWORD *)&v9[8 * (int)v51 + 4] = *(_DWORD *)&v9[8 * (int)v51 + 4] & 0xFFFFFFEB | 0x10;
              }
            }
            else
            {
              v9 = (char *)*((_QWORD *)v10 + 15);
              v8 = (char *)*((_QWORD *)v10 + 16);
              v13 = v142;
            }
            goto LABEL_53;
          }
          v37 = v158[0];
          v10 = this;
        }
        else
        {
          VNValidatedLog(4, (uint64_t)CFSTR("%s: too many straight lines in a row"), a3, a4, a5, a6, a7, a8, (uint64_t)"coalesceStraightLines");
          v10 = this;
          v11 = v144;
          v37 = v158[0];
          v38 = v158[0];
        }
        v39 = (v12 + v21);
        v40 = 1;
        v41 = v37;
        v42 = 1;
        v43 = v37;
        while (1)
        {
          v44 = v41 - rintf(v41 - v37);
          v41 = v158[v40];
          v45 = v41 - rintf(v41 - v37);
          v46 = v45 > v43 ? v45 : v43;
          if (v45 >= v38)
            v43 = v46;
          else
            v38 = v45;
          v47 = (float)(v45 - v44) >= 0.0 ? 1.0 : -1.0;
          if (v40 == 1)
          {
            v16 = v47;
          }
          else if (v16 != v47)
          {
            v42 = 0;
          }
          if (vabds_f32(v45, v44) > 0.0097222)
            goto LABEL_41;
          if (v39 == ++v40)
            goto LABEL_42;
        }
      }
    }
LABEL_53:
    v15 = (v8 - v9) >> 3;
    ++v17;
    --v12;
    v18 += 8;
    v11 += 8;
  }
  while (v15 > v13);
  if (v8 != v9)
  {
    v53 = 0;
    v54 = 0;
    v55 = -1;
    while (2)
    {
      v56 = v54++;
      v57 = v54;
      if (v15 <= v55 + 2)
      {
        v57 = v55 - v15 + 2;
        if (v57 >= v15)
          v57 %= v15;
      }
      v58 = v57 << 32;
      v59 = (int *)&v9[8 * (int)v57];
      v60 = *(_DWORD *)&v9[v53];
      v61 = *(_DWORD *)&v9[v53 + 4];
      v62 = (~v61 & 0x12) == 0 && (v146 & ((*v59 - v60) >> 31)) + *v59 - v60 <= 3;
      if (v62)
      {
        v63 = *(_DWORD *)&v9[8 * (int)v57 + 4];
        if ((v63 & 8) != 0 && ((v63 | v61) & 1) == 0)
        {
          v64 = v56 - 1;
          v145 = v55 + 1;
          if (v15 >= v55 + 1)
          {
            LODWORD(v65) = v55;
            if (v55 == -1)
            {
              if (v15 - 1 < 0)
                v65 = (v15 - 1) % v15 + v15;
              else
                LODWORD(v65) = v15 + v64;
            }
          }
          else if (v55 - v15 >= v15)
          {
            v65 = (v55 - v15) % v15;
          }
          else
          {
            LODWORD(v65) = v64 - v15;
          }
          a3 = *(unsigned int *)&v9[8 * (int)v65];
          if ((v146 & ((v60 - (int)a3) >> 31)) + v60 - (int)a3 >= 3)
          {
            v66 = v146;
            if (v60 > 0)
              v66 = 0;
            apple::vision::libraries::autotrace::ContourToPath::findTangentBackwardsFrom(v10, v60 + v66 - 1, a3, &v156, (float *)&v155 + 1, &v157, &v153, (float *)&v152 + 1);
            v67 = (v58 + 0x100000000) >> 32;
            v68 = *((_QWORD *)v10 + 15);
            v69 = *((_QWORD *)v10 + 16);
            v70 = (v69 - v68) >> 3;
            if (v67 >= v70)
            {
              LODWORD(v71) = v67 - v70;
              if (v67 - v70 >= v70)
              {
                v71 = (v58 + 0x100000000) >> 32;
                if (v69 != v68)
                  v71 = (v67 - v70) % v70;
              }
            }
            else if (v58 + 0x100000000 < 0)
            {
              LODWORD(v71) = v70 + v67;
              if (v70 + v67 < 0)
              {
                v71 = (v58 + 0x100000000) >> 32;
                if (v69 != v68)
                  v71 = (v70 + v67) % v70 + v70;
              }
            }
            else
            {
              v71 = (v58 + 0x100000000) >> 32;
            }
            a3 = *(unsigned int *)(v68 + 8 * (int)v71);
            v72 = *v59;
            if ((v146 & (((int)a3 - v72) >> 31)) + (int)a3 - v72 >= 3)
            {
              apple::vision::libraries::autotrace::ContourToPath::findTangentForwardsFrom(v10, v72, a3, (float *)&v155, &v154, &v157, &v153, (float *)&v152 + 1);
              v73 = atan2f(*((float *)&v155 + 1), v156) * 0.15915;
              v74 = atan2f(v154, *(float *)&v155);
              v75 = (float)(v74 * 0.15915) - rintf((float)(v74 * 0.15915) - v73);
              if (vabds_f32(v73, v75) <= 0.0083333)
              {
                v76 = v146;
                if (*v59 > 0)
                  v76 = 0;
                v143 = vsub_f32(*(float32x2_t *)(v140 + 8 * (*v59 + v76 - 1)), *(float32x2_t *)(v140 + 8 * *(int *)&v9[v53]));
                v77 = atan2f(v143.f32[1], v143.f32[0]);
                if ((float)(sqrtf(vmlas_n_f32(vmuls_lane_f32(v143.f32[1], v143, 1), v143.f32[0], v143.f32[0]))
                           * sinf(fabsf((float)((float)(v77 * 0.15915) - rintf((float)(v77 * 0.15915) - v73))+ (float)((float)(v73 + v75) * -0.5))* 6.2832)) < 0.33333)
                {
                  if (v145 < (int)v57)
                  {
                    v78 = *((_QWORD *)v10 + 16);
                    v79 = *((_QWORD *)v10 + 15) + 8 * (int)v57;
                    v80 = (char *)(v79 - 8);
                    v81 = (const void *)(v79 + 8);
                    v82 = v78 - (v79 + 8);
                    if (v78 == v79 + 8)
                      goto LABEL_99;
LABEL_98:
                    memmove(v80, v81, v82);
                    goto LABEL_99;
                  }
                  if ((_DWORD)v57
                    || (v80 = (char *)*((_QWORD *)v10 + 15),
                        v83 = (char *)*((_QWORD *)v10 + 16),
                        v145 != ((v83 - v80) >> 3) - 1))
                  {
                    VNValidatedLog(4, (uint64_t)CFSTR("%s: our assumptions have failed"), a3, a4, a5, a6, a7, a8, (uint64_t)"coalesceStraightLines");
                    v80 = (char *)*((_QWORD *)v10 + 15);
                    v83 = (char *)*((_QWORD *)v10 + 16);
                  }
                  v81 = v80 + 16;
                  v82 = v83 - (v80 + 16);
                  if (v83 != v80 + 16)
                    goto LABEL_98;
LABEL_99:
                  *((_QWORD *)v10 + 16) = &v80[v82];
                }
              }
            }
          }
        }
      }
      v9 = (char *)*((_QWORD *)v10 + 15);
      v84 = *((_QWORD *)v10 + 16);
      v15 = (uint64_t)(v84 - (_QWORD)v9) >> 3;
      v85 = v55 + 2;
      ++v55;
      v53 += 8;
      if (v15 > v85)
        continue;
      break;
    }
    if ((char *)v84 != v9)
    {
      v86 = 0;
      v87 = 0;
      while (1)
      {
        v88 = v87 + 1;
        v89 = v88 - v15;
        if (v88 >= v15)
        {
          if (v89 >= v15)
            v89 %= v15;
        }
        else
        {
          v89 = v87 + 1;
          if (v87 <= -2)
          {
            v89 = v15 + v88;
            if (v15 + v88 < 0)
              v89 = v89 % v15 + v15;
          }
        }
        v90 = &v9[8 * v86];
        v93 = *((_DWORD *)v90 + 1);
        v92 = v90 + 4;
        v91 = v93;
        if ((v93 & 8) == 0)
          goto LABEL_144;
        v94 = (int *)&v9[8 * v86];
        v95 = v89 << 32;
        v96 = (int *)&v9[8 * (int)v89];
        a3 = *v96;
        v97 = *v94;
        v98 = (v146 & (((int)a3 - v97) >> 31)) + a3 - v97;
        if (v98 > 34)
          goto LABEL_144;
        v99 = &v9[8 * (int)v89];
        v102 = *((_DWORD *)v99 + 1);
        v101 = (unsigned int *)(v99 + 4);
        v100 = v102;
        if ((v102 & 0x10) == 0)
        {
LABEL_180:
          VNValidatedLog(4, (uint64_t)CFSTR("%s: curve (starting at %d) not balanced"), a3, a4, a5, a6, a7, a8, (uint64_t)"coalesceStraightLines");
          return 0;
        }
        if (!(v100 & 8 | v91 & 0x10))
          goto LABEL_144;
        if (((v100 | v91) & 1) != 0)
          goto LABEL_144;
        apple::vision::libraries::autotrace::ContourToPath::computeAngleSumAndRange(this, v97, a3, (float *)&v152, &v151);
        v103 = 1.0 / (float)v98;
        if (fabsf(v103 * *(float *)&v152) > 0.00027778 || (float)(v103 * v151) > 0.00027778)
          goto LABEL_144;
        if ((*v92 & 0x10) != 0)
          break;
        v104 = this;
        if ((*(_BYTE *)v101 & 8) != 0)
        {
          v105 = v87 - 1;
          v106 = (uint64_t)(v84 - (_QWORD)v9) >> 3;
          if (v87 - 1 >= v106)
          {
            LODWORD(v107) = v105 - v106;
            if (v105 - v106 >= v106)
            {
              LODWORD(v107) = v87 - 1;
              if ((char *)v84 != v9)
                v107 = (v105 - v106) % v106;
            }
          }
          else if (v87 <= 0)
          {
            LODWORD(v107) = v106 + v105;
            if (v106 + v105 < 0)
            {
              LODWORD(v107) = v87 - 1;
              if ((char *)v84 != v9)
                v107 = (v106 + v105) % v106 + v106;
            }
          }
          else
          {
            LODWORD(v107) = v87 - 1;
          }
          v114 = *(_DWORD *)&v9[8 * (int)v107];
          v115 = (v146 & ((*v94 - v114) >> 31)) + *v94 - v114;
          apple::vision::libraries::autotrace::ContourToPath::computeAngleSumAndRange(this, v114, *v94, &v150, &v149);
          v116 = 1.0 / (float)v115;
          if (fabsf(v150 * v116) <= 0.00027778 && (float)(v116 * v149) <= 0.00027778)
          {
            *v96 = *v94;
            v117 = *(_DWORD *)v92;
            v118 = *v101;
            if ((*(_DWORD *)v92 & 4) != 0)
            {
              v118 |= 4u;
              *v101 = v118;
              v117 = *(_DWORD *)v92;
            }
            v104 = this;
            *v101 = v118 & 0xFFFFFFEF | (16 * ((v117 >> 4) & 1));
            v119 = v84 - (_QWORD)(v94 + 2);
            if ((int *)v84 != v94 + 2)
              memmove(v94, v94 + 2, v84 - (_QWORD)(v94 + 2));
            v84 -= 8;
            *((_QWORD *)this + 16) = (char *)v94 + v119;
            --v87;
            goto LABEL_145;
          }
          goto LABEL_144;
        }
LABEL_145:
        v86 = ++v87;
        v9 = (char *)*((_QWORD *)v104 + 15);
        v15 = (uint64_t)(v84 - (_QWORD)v9) >> 3;
        if (v15 <= (unint64_t)v87)
        {
          if ((char *)v84 != v9)
          {
            v120 = 0;
            v121 = 0;
            v122 = -8;
            v123 = 1;
            while (1)
            {
              v124 = v121++;
              LODWORD(v125) = v121;
              if (v15 <= v123)
              {
                v125 = v123 - v15;
                if (v123 - v15 >= v15)
                  v125 %= v15;
              }
              v126 = &v9[v120];
              v127 = *(_DWORD *)&v9[v120 + 4];
              if ((v127 & 8) == 0)
                goto LABEL_178;
              v128 = &v9[8 * (int)v125];
              v129 = *(_DWORD *)v126;
              v130 = (v146 & ((*(_DWORD *)v128 - v129) >> 31)) + *(_DWORD *)v128 - v129;
              if (v130 > 5)
                goto LABEL_178;
              v131 = &v9[8 * (int)v125];
              v134 = *((_DWORD *)v131 + 1);
              v132 = (unsigned int *)(v131 + 4);
              v133 = v134;
              if ((v134 & 0x10) == 0)
                goto LABEL_180;
              if (!(v133 & 8 | *(_DWORD *)&v9[v120 + 4] & 0x10) || ((v133 | v127) & 1) != 0 || v130 > 2)
                goto LABEL_178;
              if ((v127 & 0x10) != 0)
                break;
              if ((v133 & 8) != 0)
              {
                *(_DWORD *)v128 = v129;
                if ((v127 & 4) != 0)
                {
                  v133 |= 4u;
                  *v132 = v133;
                  v135 = *((_DWORD *)v126 + 1) & 0x10;
                }
                else
                {
                  v135 = 0;
                }
                *v132 = v133 & 0xFFFFFFEF | v135;
                v136 = v122 + v84 - (_QWORD)v9;
                if (&v9[v120 + 8] != (char *)v84)
                {
                  v137 = &v9[8 * v123];
                  v138 = v122 + v84 - (_QWORD)v9;
LABEL_176:
                  memmove(v126, v137, v138);
                }
                goto LABEL_177;
              }
LABEL_178:
              v15 = (uint64_t)(v84 - (_QWORD)v9) >> 3;
              v120 += 8;
              v122 -= 8;
              v62 = v15 > (unint64_t)v123++;
              if (!v62)
                return 1;
            }
            if ((v127 & 4) != 0)
              *v132 = v133 & 0xFFFFFFEB | 4;
            v136 = v84 - (_QWORD)&v9[8 * v124] - 8;
            if (&v9[v120 + 8] != (char *)v84)
            {
              v137 = &v9[8 * v123];
              v138 = v122 + v84 - (_QWORD)v9;
              goto LABEL_176;
            }
LABEL_177:
            v84 = (unint64_t)&v9[v120 + (v136 & 0xFFFFFFFFFFFFFFF8)];
            *((_QWORD *)v104 + 16) = v84;
            v9 = (char *)*((_QWORD *)v104 + 15);
            goto LABEL_178;
          }
          return 1;
        }
      }
      v108 = (v95 + 0x100000000) >> 32;
      v109 = (uint64_t)(v84 - (_QWORD)v9) >> 3;
      if (v108 >= v109)
      {
        LODWORD(v110) = v108 - v109;
        if (v108 - v109 >= v109)
        {
          v110 = (v95 + 0x100000000) >> 32;
          if ((char *)v84 != v9)
            v110 = (v108 - v109) % v109;
        }
      }
      else if (v95 + 0x100000000 < 0)
      {
        LODWORD(v110) = v109 + v108;
        if (v109 + v108 < 0)
        {
          v110 = (v95 + 0x100000000) >> 32;
          if ((char *)v84 != v9)
            v110 = (v109 + v108) % v109 + v109;
        }
      }
      else
      {
        v110 = (v95 + 0x100000000) >> 32;
      }
      v111 = *(_DWORD *)&v9[8 * (int)v110];
      v112 = (v146 & ((v111 - *v96) >> 31)) + v111 - *v96;
      apple::vision::libraries::autotrace::ContourToPath::computeAngleSumAndRange(this, *v96, v111, &v150, &v149);
      v113 = 1.0 / (float)v112;
      if (fabsf(v150 * v113) <= 0.00027778 && (float)(v113 * v149) <= 0.00027778)
      {
        v104 = this;
        if ((_DWORD)v89)
        {
          if ((int *)v84 != v96)
            memmove(v96 - 2, &v9[8 * (int)v89], v84 - (_QWORD)v96);
          v84 -= 8;
        }
        else
        {
          v84 -= 8;
        }
        *((_QWORD *)this + 16) = v84;
        --v87;
        goto LABEL_145;
      }
LABEL_144:
      v104 = this;
      goto LABEL_145;
    }
  }
  return 1;
}

void apple::vision::libraries::autotrace::ContourToPath::extractCurveRecords(apple::vision::libraries::autotrace::ContourToPath *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int *v16;
  int v17;
  int *v18;
  apple::vision::libraries::autotrace::CornerList *Corner;
  uint64_t v20;
  apple::vision::libraries::autotrace::CornerList *v21;
  int v22;
  uint64_t v23;
  _DWORD *v24;
  char v25;
  apple::vision::libraries::autotrace::CornerList *v26;
  unsigned int v27;
  int v28;
  int v29;
  unint64_t v30;
  BOOL v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unsigned int *v45;
  _DWORD *v46;
  apple::vision::libraries::autotrace::CornerList *v47;
  apple::vision::libraries::autotrace::CornerList *v48;
  int v49;
  apple::vision::libraries::autotrace::CornerList *v50;
  int v51;
  int v52;
  _OWORD *v53;
  unint64_t v54;
  _OWORD *v55;
  uint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  uint64_t v61;
  _OWORD *v62;
  char *v63;
  char *v64;
  _OWORD *v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  int v70;
  int v71;

  v71 = **((_DWORD **)this + 3);
  v9 = *((_QWORD *)this + 15);
  v10 = *((_QWORD *)this + 16);
  v11 = (v10 - v9) >> 3;
  if (v10 != v9)
  {
    v12 = 0;
    v13 = 0;
    v14 = 1;
    v10 = *((_QWORD *)this + 15);
    while (1)
    {
      LODWORD(v15) = ++v13;
      if (v11 <= v14)
      {
        v15 = v14 - v11;
        if (v14 - v11 >= v11)
          v15 %= v11;
      }
      v16 = (unsigned int *)(v10 + v12);
      v17 = *(_DWORD *)(v10 + v12 + 4);
      if ((v17 & 0xA) == 0)
        goto LABEL_20;
      if ((v17 & 1) != 0)
      {
        Corner = apple::vision::libraries::autotrace::CornerList::findCorner(*((apple::vision::libraries::autotrace::CornerList **)this + 12), *((apple::vision::libraries::autotrace::CornerList **)this + 13), **((unsigned int **)this + 3), *v16, 0, a6, a7, a8);
        v18 = (int *)((char *)Corner + 4);
        if (!Corner)
          v18 = (int *)(v10 + v12);
      }
      else
      {
        v18 = (int *)(v10 + v12);
      }
      v20 = (int)v15;
      v21 = (apple::vision::libraries::autotrace::CornerList *)(v10 + 8 * (int)v15);
      v22 = *v18;
      v23 = v10 + 8 * v20;
      v25 = *(_BYTE *)(v23 + 4);
      v24 = (_DWORD *)(v23 + 4);
      if ((v25 & 1) != 0)
      {
        v26 = apple::vision::libraries::autotrace::CornerList::findCorner(*((apple::vision::libraries::autotrace::CornerList **)this + 12), *((apple::vision::libraries::autotrace::CornerList **)this + 13), **((unsigned int **)this + 3), *(unsigned int *)v21, 0, a6, a7, a8);
        if (v26)
          v21 = v26;
      }
      if (*(_DWORD *)v21 != v22)
        goto LABEL_20;
      v27 = v16[1];
      if ((v27 & 8) != 0)
        break;
      if ((v27 & 2) != 0)
      {
        v28 = -5;
        v29 = -3;
LABEL_19:
        v16[1] = v27 & v29;
        *v24 &= v28;
      }
LABEL_20:
      v10 = *((_QWORD *)this + 15);
      v30 = *((_QWORD *)this + 16);
      v11 = (uint64_t)(v30 - v10) >> 3;
      v12 += 8;
      v31 = v11 > (unint64_t)v14++;
      if (!v31)
        goto LABEL_23;
    }
    v28 = -17;
    v29 = -9;
    goto LABEL_19;
  }
  v30 = *((_QWORD *)this + 16);
LABEL_23:
  v32 = (v11 - 1);
  if ((int)v32 >= 0)
  {
    v33 = v32 + 1;
    v34 = 8 * v32;
    v35 = v34 ^ 0xFFFFFFFFFFFFFFF8;
    do
    {
      v36 = *((_QWORD *)this + 15);
      v37 = v36 + v34;
      if (!*(_DWORD *)(v36 + v34 + 4))
      {
        v38 = v35 + v30 - v36;
        if (v37 + 8 != v30)
          memmove((void *)v37, (const void *)(v37 + 8), v35 + v30 - v36);
        v30 = v36 + v34 + (v38 & 0xFFFFFFFFFFFFFFF8);
        *((_QWORD *)this + 16) = v30;
      }
      v34 -= 8;
      v35 += 8;
      v31 = v33-- <= 1;
    }
    while (!v31);
    v10 = *((_QWORD *)this + 15);
  }
  v39 = v30 - v10;
  if (v39)
  {
    v40 = 0;
    v41 = v39 >> 3;
    while (1)
    {
      v42 = v40++;
      LODWORD(v43) = v40;
      v44 = v40 - v41;
      if ((uint64_t)v40 >= v41)
      {
        LODWORD(v43) = v40 - v41;
        if (v44 >= v41)
          v43 = v44 % v41;
      }
      v45 = (unsigned int *)(v10 + 8 * v42);
      v46 = v45 + 1;
      if ((v45[1] & 0xA) == 0)
        goto LABEL_67;
      if ((v45[1] & 1) != 0)
      {
        v47 = apple::vision::libraries::autotrace::CornerList::findCorner(*((apple::vision::libraries::autotrace::CornerList **)this + 12), *((apple::vision::libraries::autotrace::CornerList **)this + 13), **((unsigned int **)this + 3), *v45, 0, a6, a7, a8);
        if (v47)
          v45 = (unsigned int *)((char *)v47 + 4);
      }
      v48 = (apple::vision::libraries::autotrace::CornerList *)(v10 + 8 * (int)v43);
      v49 = *v45;
      if ((*((_BYTE *)v48 + 4) & 1) != 0)
      {
        v50 = apple::vision::libraries::autotrace::CornerList::findCorner(*((apple::vision::libraries::autotrace::CornerList **)this + 12), *((apple::vision::libraries::autotrace::CornerList **)this + 13), **((unsigned int **)this + 3), *(unsigned int *)v48, 0, a6, a7, a8);
        if (v50)
          v48 = v50;
      }
      v51 = *(_DWORD *)v48;
      v52 = *(_DWORD *)v48 - v49;
      if (v51 == v49)
        goto LABEL_67;
      v53 = (_OWORD *)*((_QWORD *)this + 19);
      v54 = *((_QWORD *)this + 20);
      if ((unint64_t)v53 >= v54)
      {
        v56 = *((_QWORD *)this + 18);
        v57 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v53 - v56) >> 5);
        v58 = v57 + 1;
        if (v57 + 1 > 0x2AAAAAAAAAAAAAALL)
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        v59 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v54 - v56) >> 5);
        if (2 * v59 > v58)
          v58 = 2 * v59;
        if (v59 >= 0x155555555555555)
          v60 = 0x2AAAAAAAAAAAAAALL;
        else
          v60 = v58;
        if (v60)
          v60 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<apple::vision::libraries::autotrace::Curve>>(v60);
        else
          v61 = 0;
        v62 = (_OWORD *)(v60 + 96 * v57);
        v62[4] = 0u;
        v62[5] = 0u;
        v62[2] = 0u;
        v62[3] = 0u;
        *v62 = 0u;
        v62[1] = 0u;
        v64 = (char *)*((_QWORD *)this + 18);
        v63 = (char *)*((_QWORD *)this + 19);
        v65 = v62;
        if (v63 != v64)
        {
          do
          {
            v66 = *((_OWORD *)v63 - 5);
            *(v65 - 6) = *((_OWORD *)v63 - 6);
            *(v65 - 5) = v66;
            v67 = *((_OWORD *)v63 - 4);
            v68 = *((_OWORD *)v63 - 3);
            v69 = *((_OWORD *)v63 - 1);
            *(v65 - 2) = *((_OWORD *)v63 - 2);
            *(v65 - 1) = v69;
            *(v65 - 4) = v67;
            *(v65 - 3) = v68;
            v65 -= 6;
            v63 -= 96;
          }
          while (v63 != v64);
          v63 = (char *)*((_QWORD *)this + 18);
        }
        v55 = v62 + 6;
        *((_QWORD *)this + 18) = v65;
        *((_QWORD *)this + 19) = v62 + 6;
        *((_QWORD *)this + 20) = v60 + 96 * v61;
        if (v63)
          operator delete(v63);
      }
      else
      {
        v53[4] = 0u;
        v53[5] = 0u;
        v53[2] = 0u;
        v53[3] = 0u;
        v55 = v53 + 6;
        *v53 = 0u;
        v53[1] = 0u;
      }
      *((_QWORD *)this + 19) = v55;
      if ((*v46 & 8) != 0)
        break;
      if ((*v46 & 2) != 0)
      {
        v70 = 0;
LABEL_65:
        *((_DWORD *)v55 - 24) = v70;
      }
      *((_DWORD *)v55 - 23) = v42;
      *((_DWORD *)v55 - 22) = v49;
      *((_DWORD *)v55 - 11) = v43;
      *((_DWORD *)v55 - 10) = v51;
      *((_DWORD *)v55 - 1) = (v71 & (v52 >> 31)) + v52;
LABEL_67:
      v10 = *((_QWORD *)this + 15);
      v41 = (*((_QWORD *)this + 16) - v10) >> 3;
      if (v41 <= v40)
        return;
    }
    v70 = 1;
    goto LABEL_65;
  }
}

void apple::vision::libraries::autotrace::ContourToPath::computeCurveTangents(apple::vision::libraries::autotrace::ContourToPath *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  apple::vision::libraries::autotrace::ContourToPath *v10;
  unint64_t v11;
  int *v12;
  uint64_t v13;
  int64_t v14;
  int v15;
  float *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _DWORD *v20;
  _DWORD *v21;
  uint64_t v22;
  uint64_t v23;
  _DWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  int v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  BOOL v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  float v52;
  unint64_t v53;
  int v54;
  int v55;
  float v56;
  BOOL v57;
  float v58;
  float v59;
  float v60;
  float v61;
  uint64_t v62;
  int v63;
  int v64;
  unint64_t v65;
  uint64_t v66;
  int v67;
  int *v68;
  int v69;
  float v70;
  int v71;
  BOOL v72;
  float v73;
  float v74;
  float v75;
  float v76;
  uint64_t v77;
  int v78;
  int *v79;
  int v80;
  float v81;
  float v82;
  float v83;
  float v84;
  float v85;
  uint64_t v86;
  int v87;
  float32x2_t v88;
  float v89;
  float v90;
  float v91;
  uint64_t v92;
  int v93;
  int *v94;
  int v95;
  float v96;
  int v97;
  BOOL v98;
  float v99;
  float v100;
  int v101;
  float32x2_t v102;
  float v103;
  float v104;
  float v105;
  uint64_t v106;
  int v107;
  float32x2_t v108;
  float v109;
  float v110;
  float v111;
  __float2 v112;
  uint64_t v113;
  uint64_t v114;
  int v115;
  int *v116;
  int v117;
  float v118;
  int v119;
  BOOL v120;
  float v121;
  float v122;
  float v123;
  float v124;
  uint64_t v125;
  int v126;
  float32x2_t v127;
  float v128;
  float v129;
  float v130;
  __float2 v131;
  uint64_t v132;
  uint64_t v133;
  int v134;
  float32x2_t v135;
  float v136;
  float v137;
  float v138;
  __float2 v139;
  uint64_t v140;
  uint64_t v141;
  __float2 v142;
  float32x2_t *v143;
  float32x2_t *v144;
  float32x2_t *v145;
  float32x2_t v146;
  uint64_t v147;
  int v148;
  __float2 v149;
  uint64_t v150;
  float v151;
  float v152;
  int v154;
  BOOL v155;
  float v156;
  float v157;
  float v158;
  float32x2_t v159;
  unint64_t v160;
  float v161;
  float v162;
  float v163;
  float v164;
  uint64_t v165;
  int v166;
  float v167;
  float v168[19];
  unint64_t v169;
  BOOL v170;
  unsigned int v171;
  uint64_t v172;
  BOOL v173;

  v170 = 0;
  v169 = 0;
  v8 = *((_QWORD *)this + 18);
  v9 = *((_QWORD *)this + 19) - v8;
  if (v9)
  {
    v10 = this;
    v11 = 0;
    v12 = (int *)*((_QWORD *)this + 3);
    v13 = *v12;
    v165 = *((_QWORD *)v12 + 1);
    v14 = 0xAAAAAAAAAAAAAAABLL * (v9 >> 5);
    v15 = (int)v13 / 8;
    if ((int)v13 / 8 <= 1)
      v15 = 1;
    if ((int)v13 >= 48)
      v15 = 6;
    v154 = v15;
    v16 = (float *)&qword_1A15FAFF8[1];
    do
    {
      v17 = v11++;
      LODWORD(v18) = v11;
      v19 = v11 - v14;
      if ((uint64_t)v11 >= v14)
      {
        LODWORD(v18) = v11 - v14;
        if (v19 >= v14)
          v18 = v19 % v14;
      }
      v20 = (_DWORD *)(v8 + 96 * v17);
      v166 = v18;
      v21 = (_DWORD *)(v8 + 96 * (int)v18);
      v22 = *((_QWORD *)v10 + 15);
      v24 = v20 + 13;
      v23 = (int)v20[13];
      v25 = (int)v21[1];
      if ((_DWORD)v23 == (_DWORD)v25)
      {
        v26 = v22 + 8 * v23;
      }
      else
      {
        v27 = (int)v23 + 1;
        v28 = *((_QWORD *)v10 + 16);
        v29 = (v28 - v22) >> 3;
        if (v27 >= v29)
        {
          LODWORD(v30) = v27 - v29;
          if (v27 - v29 >= v29)
          {
            LODWORD(v30) = v23 + 1;
            if (v28 != v22)
              v30 = (v27 - v29) % v29;
          }
        }
        else
        {
          LODWORD(v30) = v23 + 1;
          if ((int)v23 <= -2)
          {
            LODWORD(v30) = v29 + v27;
            if (v29 + v27 < 0)
            {
              LODWORD(v30) = v23 + 1;
              if (v28 != v22)
                v30 = (v29 + v27) % v29 + v29;
            }
          }
        }
        if ((_DWORD)v25 == (_DWORD)v30)
        {
          if ((*(_BYTE *)(v22 + 8 * v23 + 4) & 1) != 0)
            goto LABEL_86;
          v26 = v22 + 8 * v25;
        }
        else
        {
          v31 = v23 + 2;
          v32 = v23 + 2 - v29;
          if (v23 + 2 >= v29)
          {
            LODWORD(v33) = v23 + 2 - v29;
            if (v32 >= v29)
            {
              LODWORD(v33) = v23 + 2;
              if (v28 != v22)
                v33 = v32 % v29;
            }
          }
          else if ((int)v23 > -3)
          {
            LODWORD(v33) = v23 + 2;
          }
          else
          {
            LODWORD(v33) = v29 + v31;
            if (v29 + v31 < 0)
            {
              LODWORD(v33) = v23 + 2;
              if (v28 != v22)
                v33 = (v29 + v31) % v29 + v29;
            }
          }
          if ((_DWORD)v25 != (_DWORD)v33)
          {
            VNValidatedLog(4, (uint64_t)CFSTR("%s: too many interesting points in between curves/lines"), a3, a4, a5, a6, a7, a8, (uint64_t)"computeCurveTangents");
            return;
          }
          v34 = v27 - v29;
          if (v27 >= v29)
          {
            LODWORD(v35) = v27 - v29;
            if (v34 >= v29)
            {
              LODWORD(v35) = v23 + 1;
              if (v28 != v22)
                v35 = v34 % v29;
            }
          }
          else if ((int)v23 > -2)
          {
            LODWORD(v35) = v23 + 1;
          }
          else
          {
            LODWORD(v35) = v29 + v27;
            if (v29 + v27 < 0)
            {
              LODWORD(v35) = v23 + 1;
              if (v28 != v22)
                v35 = (v29 + v27) % v29 + v29;
            }
          }
          v26 = v22 + 8 * (int)v35;
        }
      }
      if ((*(_BYTE *)(v26 + 4) & 1) != 0)
      {
LABEL_86:
        if (*v20)
        {
          v173 = 0;
          v168[0] = 0.0;
          v172 = 0;
          v171 = 0;
          v62 = v8 + 96 * v17;
          apple::vision::libraries::autotrace::ContourToPath::findTangentBackwardsFrom(v10, *(_DWORD *)(v62 + 56), *(_DWORD *)(v62 + 8), (float *)&v172, (float *)&v171, &v173, v168, (float *)&v172 + 1);
          v63 = HIDWORD(v172);
          *(_QWORD *)(v62 + 64) = __PAIR64__(v171, v172);
          *(_BYTE *)(v62 + 80) = v173;
          *(float *)(v62 + 84) = v168[0];
          *(_DWORD *)(v62 + 88) = v63;
          v64 = v166;
        }
        else
        {
          v65 = v11;
          v66 = v8 + 96 * v17;
          if (*(int *)(v66 + 92) <= 2)
            v67 = 2;
          else
            v67 = *(_DWORD *)(v66 + 92);
          v69 = *(_DWORD *)(v66 + 8);
          v68 = (int *)(v66 + 8);
          apple::vision::libraries::autotrace::ATRRecord::ATRRecord((uint64_t)v168, *((const EPolygon **)v10 + 3), v69, v67);
          v64 = v166;
          if ((apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)v168, &v170, (float *)&v169 + 1, (float *)&v169) & 1) != 0)
          {
            v71 = *v68;
            v72 = v170;
            v73 = *(float *)&v169;
            apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)**((unsigned int **)v10 + 3), *(const EPolygon **)(*((_QWORD *)v10 + 3) + 8), v71, v67, v170, *(float *)&v169, v70);
            v75 = v74 * 6.2832;
            v76 = *((float *)&v169 + 1);
          }
          else
          {
            v86 = *v68;
            if ((int)v86 + 1 >= (int)v13)
              v87 = v13;
            else
              v87 = 0;
            v88 = vsub_f32(*(float32x2_t *)(v165 + 8 * ((int)v86 + 1 - v87)), *(float32x2_t *)(v165 + 8 * v86));
            LODWORD(v156) = *(_QWORD *)(v165 + 8 * v86);
            v161 = v88.f32[0];
            LODWORD(v89) = HIDWORD(*(_QWORD *)(v165 + 8 * v86));
            v90 = v88.f32[1];
            v75 = atan2f(v88.f32[1], v88.f32[0]);
            if (v75 < 0.0)
            {
              v91 = v75 + 6.28318531;
              v75 = v91;
            }
            if (fabsf(v161) <= fabsf(v90))
            {
              v72 = 0;
              v170 = 0;
              v73 = v161 / v90;
              *(float *)&v169 = v73;
              v76 = v156 - (float)(v73 * v89);
            }
            else
            {
              v72 = 1;
              v170 = 1;
              v73 = v90 / v161;
              *(float *)&v169 = v73;
              v76 = v89 - (float)(v73 * v156);
            }
            *((float *)&v169 + 1) = v76;
          }
          v11 = v65;
          v112 = __sincosf_stret(v75);
          v113 = v8 + 96 * v17;
          *(_QWORD *)(v113 + 64) = __PAIR64__(LODWORD(v112.__sinval), LODWORD(v112.__cosval));
          *(_BYTE *)(v113 + 80) = v72;
          *(float *)(v113 + 84) = v76;
          *(float *)(v113 + 88) = v73;
        }
        if (*v21)
        {
          apple::vision::libraries::autotrace::ContourToPath::computeCurveStartTangentAtCorner(v10, (uint64_t)v21);
        }
        else
        {
          v114 = v8 + 96 * v64;
          if (*(int *)(v114 + 92) <= 2)
            v115 = 2;
          else
            v115 = *(_DWORD *)(v114 + 92);
          v117 = *(_DWORD *)(v114 + 8);
          v116 = (int *)(v114 + 8);
          apple::vision::libraries::autotrace::ATRRecord::ATRRecord((uint64_t)v168, *((const EPolygon **)v10 + 3), v117, v115);
          if ((apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)v168, &v170, (float *)&v169 + 1, (float *)&v169) & 1) != 0)
          {
            v119 = *v116;
            v120 = v170;
            LODWORD(v121) = v169;
            apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)**((unsigned int **)v10 + 3), *(const EPolygon **)(*((_QWORD *)v10 + 3) + 8), v119, v115, v170, *(float *)&v169, v118);
            v123 = v122 * 6.2832;
            v124 = *((float *)&v169 + 1);
          }
          else
          {
            v125 = *v116;
            if ((int)v125 + 1 >= (int)v13)
              v126 = v13;
            else
              v126 = 0;
            v127 = vsub_f32(*(float32x2_t *)(v165 + 8 * ((int)v125 + 1 - v126)), *(float32x2_t *)(v165 + 8 * v125));
            v167 = v127.f32[0];
            LODWORD(v163) = *(_QWORD *)(v165 + 8 * v125);
            LODWORD(v128) = HIDWORD(*(_QWORD *)(v165 + 8 * v125));
            v129 = v127.f32[1];
            v123 = atan2f(v127.f32[1], v127.f32[0]);
            if (v123 < 0.0)
            {
              v130 = v123 + 6.28318531;
              v123 = v130;
            }
            if (fabsf(v167) <= fabsf(v129))
            {
              v120 = 0;
              v170 = 0;
              v121 = v167 / v129;
              v124 = v163 - (float)(v121 * v128);
            }
            else
            {
              v120 = 1;
              v170 = 1;
              v121 = v129 / v167;
              v124 = v128 - (float)(v121 * v163);
            }
            v169 = __PAIR64__(LODWORD(v124), LODWORD(v121));
          }
          v131 = __sincosf_stret(v123);
          v132 = v8 + 96 * v64;
          *(_QWORD *)(v132 + 24) = __PAIR64__(LODWORD(v131.__sinval), LODWORD(v131.__cosval));
          *(_BYTE *)(v132 + 40) = v120;
          *(float *)(v132 + 44) = v124;
          *(float *)(v132 + 48) = v121;
        }
        goto LABEL_166;
      }
      if (!*v20)
      {
        v160 = v11;
        v77 = v8 + 96 * v17;
        if (*(int *)(v77 + 92) <= 2)
          v78 = 2;
        else
          v78 = *(_DWORD *)(v77 + 92);
        v80 = *(_DWORD *)(v77 + 8);
        v79 = (int *)(v77 + 8);
        apple::vision::libraries::autotrace::ATRRecord::ATRRecord((uint64_t)v168, *((const EPolygon **)v10 + 3), v80, v78);
        if ((apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)v168, &v170, (float *)&v169 + 1, (float *)&v169) & 1) != 0)
        {
          LODWORD(v82) = v169;
          v155 = v170;
          apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)**((unsigned int **)v10 + 3), *(const EPolygon **)(*((_QWORD *)v10 + 3) + 8), *v79, v78, v170, *(float *)&v169, v81);
          v84 = v83 * 6.2832;
          v85 = *((float *)&v169 + 1);
        }
        else
        {
          v106 = *v79;
          if ((int)v106 + 1 >= (int)v13)
            v107 = v13;
          else
            v107 = 0;
          v108 = vsub_f32(*(float32x2_t *)(v165 + 8 * ((int)v106 + 1 - v107)), *(float32x2_t *)(v165 + 8 * v106));
          LODWORD(v151) = *(_QWORD *)(v165 + 8 * v106);
          v152 = v108.f32[0];
          LODWORD(v109) = HIDWORD(*(_QWORD *)(v165 + 8 * v106));
          v110 = v108.f32[1];
          v84 = atan2f(v108.f32[1], v108.f32[0]);
          if (v84 < 0.0)
          {
            v111 = v84 + 6.28318531;
            v84 = v111;
          }
          if (fabsf(v152) <= fabsf(v110))
          {
            v155 = 0;
            v170 = 0;
            v82 = v152 / v110;
            v85 = v151 - (float)(v82 * v109);
          }
          else
          {
            v155 = 1;
            v170 = 1;
            v82 = v110 / v152;
            v85 = v109 - (float)(v82 * v151);
          }
          v169 = __PAIR64__(LODWORD(v85), LODWORD(v82));
        }
        v142 = __sincosf_stret(v84);
        v143 = (float32x2_t *)(v8 + 96 * v17);
        v143[8] = (float32x2_t)__PAIR64__(LODWORD(v142.__sinval), LODWORD(v142.__cosval));
        v143[10].i8[0] = v155;
        v143[10].f32[1] = v85;
        v143[11].f32[0] = v82;
        apple::vision::libraries::autotrace::ContourToPath::computeCurveStartTangentAtCorner(v10, (uint64_t)v21);
        v144 = (float32x2_t *)(v8 + 96 * v166);
        v146 = v144[3];
        v145 = v144 + 3;
        v159 = v143[8];
        if ((float)(fabsf(acosf(vmlas_n_f32(COERCE_FLOAT(vmul_f32(v146, v159).i32[1]), v159.f32[0], v146.f32[0])))
                   * 0.15915) >= 0.013889)
        {
          v11 = v160;
          v16 = (float *)(qword_1A15FAFF8 + 8);
          if (*(_DWORD *)(v8 + 96 * v17 + 56) != *(_DWORD *)(v8 + 96 * v166 + 8) && *v24 != -1)
            *(_DWORD *)(v22 + 8 * v23 + 4) |= 1u;
        }
        else
        {
          *v145 = v159;
          v147 = v8 + 96 * v166;
          *(_BYTE *)(v147 + 40) = v170;
          v148 = v169;
          *(_DWORD *)(v147 + 44) = HIDWORD(v169);
          *(_DWORD *)(v147 + 48) = v148;
          v11 = v160;
          v16 = (float *)(qword_1A15FAFF8 + 8);
        }
        v10 = this;
        goto LABEL_167;
      }
      if (*v21)
      {
        v36 = v8 + 96 * v17;
        v37 = *(_DWORD *)(v36 + 92);
        v38 = *(int *)(v36 + 56);
        v39 = v8 + 96 * v166;
        v40 = *(_DWORD *)(v39 + 92);
        v41 = *(int *)(v39 + 8);
        v42 = v154;
        do
        {
          if (v37 >= v42)
            v43 = v42;
          else
            v43 = v37;
          v44 = v38 - v43;
          if ((int)v44 >= (int)v13)
          {
            v46 = v44 - v13;
            if (v44 - v13 >= v13)
            {
              v47 = (_DWORD)v13 == 0;
            }
            else
            {
              LODWORD(v44) = v44 - v13;
              v47 = 1;
            }
            if (!v47)
              v44 = v46 % v13;
          }
          else if ((v44 & 0x80000000) != 0)
          {
            v45 = v44 + v13;
            if (v44 + v13 < 0 == __OFADD__(v44, v13))
              LODWORD(v44) = v44 + v13;
            if (v45 < 0 && (_DWORD)v13)
              v44 = v45 % v13 + v13;
          }
          if (v40 > v42)
            v48 = v42 + 1;
          else
            v48 = v40;
          v49 = v41 + v48;
          if ((int)v49 >= (int)v13)
          {
            if (v49 - v13 >= v13)
            {
              if ((_DWORD)v13)
                v49 = (v49 - v13) % v13;
            }
            else
            {
              LODWORD(v49) = v49 - v13;
            }
          }
          else if ((v49 & 0x80000000) != 0)
          {
            v50 = v49 + v13;
            if (v49 + v13 < 0 == __OFADD__(v49, v13))
              LODWORD(v49) = v49 + v13;
            if (v50 < 0 && (_DWORD)v13)
              v49 = v50 % v13 + v13;
          }
          v51 = v42 + 1;
          if (v51 - 1 < 3)
            break;
          v52 = *(float *)(*((_QWORD *)v10 + 7) + 4 * (int)v49) - *(float *)(*((_QWORD *)v10 + 7) + 4 * (int)v44);
          v42 = v51 - 2;
        }
        while (vabds_f32(v52, rintf(v52)) >= v16[196]);
        v53 = v11;
        if ((int)v49 <= (int)v44)
          v54 = v13;
        else
          v54 = 0;
        if (v54 + (int)v49 - (int)v44 <= 2)
          v55 = 2;
        else
          v55 = v54 + v49 - v44;
        apple::vision::libraries::autotrace::ATRRecord::ATRRecord((uint64_t)v168, *((const EPolygon **)v10 + 3), v44, v55);
        if ((apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)v168, &v170, (float *)&v169 + 1, (float *)&v169) & 1) != 0)
        {
          v57 = v170;
          LODWORD(v58) = v169;
          apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)**((unsigned int **)v10 + 3), *(const EPolygon **)(*((_QWORD *)v10 + 3) + 8), v44, v55, v170, *(float *)&v169, v56);
          v60 = v59 * 6.2832;
          v61 = *((float *)&v169 + 1);
        }
        else
        {
          if ((int)v44 + 1 >= (int)v13)
            v101 = v13;
          else
            v101 = 0;
          v102 = vsub_f32(*(float32x2_t *)(v165 + 8 * ((int)v44 + 1 - v101)), *(float32x2_t *)(v165 + 8 * (int)v44));
          v157 = v102.f32[0];
          LODWORD(v162) = *(_QWORD *)(v165 + 8 * (int)v44);
          LODWORD(v103) = HIDWORD(*(_QWORD *)(v165 + 8 * (int)v44));
          v104 = v102.f32[1];
          v60 = atan2f(v102.f32[1], v102.f32[0]);
          if (v60 < 0.0)
          {
            v105 = v60 + 6.28318531;
            v60 = v105;
          }
          if (fabsf(v157) <= fabsf(v104))
          {
            v57 = 0;
            v170 = 0;
            v58 = v157 / v104;
            *(float *)&v169 = v58;
            v61 = v162 - (float)(v58 * v103);
          }
          else
          {
            v57 = 1;
            v170 = 1;
            v58 = v104 / v157;
            *(float *)&v169 = v58;
            v61 = v103 - (float)(v58 * v162);
          }
          *((float *)&v169 + 1) = v61;
        }
        v11 = v53;
        v139 = __sincosf_stret(v60);
        v140 = v8 + 96 * v166;
        *(_QWORD *)(v140 + 24) = __PAIR64__(LODWORD(v139.__sinval), LODWORD(v139.__cosval));
        *(_BYTE *)(v140 + 40) = v57;
        *(float *)(v140 + 44) = v61;
        *(float *)(v140 + 48) = v58;
        v141 = v8 + 96 * v17;
        *(_QWORD *)(v141 + 64) = __PAIR64__(LODWORD(v139.__sinval), LODWORD(v139.__cosval));
        *(_BYTE *)(v141 + 80) = v57;
      }
      else
      {
        v92 = v8 + 96 * v166;
        if (*(int *)(v92 + 92) <= 2)
          v93 = 2;
        else
          v93 = *(_DWORD *)(v92 + 92);
        v95 = *(_DWORD *)(v92 + 8);
        v94 = (int *)(v92 + 8);
        apple::vision::libraries::autotrace::ATRRecord::ATRRecord((uint64_t)v168, *((const EPolygon **)v10 + 3), v95, v93);
        if ((apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)v168, &v170, (float *)&v169 + 1, (float *)&v169) & 1) != 0)
        {
          v97 = *v94;
          v98 = v170;
          LODWORD(v58) = v169;
          apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)**((unsigned int **)v10 + 3), *(const EPolygon **)(*((_QWORD *)v10 + 3) + 8), v97, v93, v170, *(float *)&v169, v96);
          v100 = v99 * 6.2832;
          v61 = *((float *)&v169 + 1);
        }
        else
        {
          v133 = *v94;
          if ((int)v133 + 1 >= (int)v13)
            v134 = v13;
          else
            v134 = 0;
          v135 = vsub_f32(*(float32x2_t *)(v165 + 8 * ((int)v133 + 1 - v134)), *(float32x2_t *)(v165 + 8 * v133));
          v158 = v135.f32[0];
          LODWORD(v164) = *(_QWORD *)(v165 + 8 * v133);
          LODWORD(v136) = HIDWORD(*(_QWORD *)(v165 + 8 * v133));
          v137 = v135.f32[1];
          v100 = atan2f(v135.f32[1], v135.f32[0]);
          if (v100 < 0.0)
          {
            v138 = v100 + 6.28318531;
            v100 = v138;
          }
          if (fabsf(v158) <= fabsf(v137))
          {
            v98 = 0;
            v170 = 0;
            v58 = v158 / v137;
            v61 = v164 - (float)(v58 * v136);
          }
          else
          {
            v98 = 1;
            v170 = 1;
            v58 = v137 / v158;
            v61 = v136 - (float)(v58 * v164);
          }
          v169 = __PAIR64__(LODWORD(v61), LODWORD(v58));
        }
        v149 = __sincosf_stret(v100);
        v150 = v8 + 96 * v166;
        *(_QWORD *)(v150 + 24) = __PAIR64__(LODWORD(v149.__sinval), LODWORD(v149.__cosval));
        *(_BYTE *)(v150 + 40) = v98;
        *(float *)(v150 + 44) = v61;
        *(float *)(v150 + 48) = v58;
        v141 = v8 + 96 * v17;
        *(_QWORD *)(v141 + 64) = __PAIR64__(LODWORD(v149.__sinval), LODWORD(v149.__cosval));
        *(_BYTE *)(v141 + 80) = v98;
      }
      *(float *)(v141 + 84) = v61;
      *(float *)(v141 + 88) = v58;
LABEL_166:
      v16 = (float *)(qword_1A15FAFF8 + 8);
LABEL_167:
      v8 = *((_QWORD *)v10 + 18);
      v14 = 0xAAAAAAAAAAAAAAABLL * ((*((_QWORD *)v10 + 19) - v8) >> 5);
    }
    while (v14 > v11);
  }
}

void apple::vision::libraries::autotrace::ContourToPath::computePoints(apple::vision::libraries::autotrace::ContourToPath *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  float v25;
  float v26;
  float v27;
  uint64_t v28;
  float32x2_t v29;
  float v30;
  float v31;
  float v32;
  float v33;
  uint64_t v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  int v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  uint64_t v49;
  float v50;
  float v51;
  float v52;
  unsigned int v53;
  unsigned int v54;
  uint64_t v55;
  _QWORD *v56;
  uint64_t v57;

  v9 = *((_QWORD *)this + 18);
  v8 = *((_QWORD *)this + 19);
  v10 = v8 - v9;
  if (v8 != v9)
  {
    v11 = 0;
    v12 = 0;
    v13 = *(_QWORD *)(*((_QWORD *)this + 3) + 8);
    v14 = 0xAAAAAAAAAAAAAAABLL * (v10 >> 5);
    v15 = 1;
    do
    {
      LODWORD(v16) = ++v12;
      if (v14 <= v15)
      {
        v16 = v15 - v14;
        if (v15 - v14 >= v14)
          v16 %= v14;
      }
      v17 = v16;
      v18 = *((_QWORD *)this + 15);
      v19 = *(int *)(v9 + v11 + 52);
      v20 = v18 + 8 * v19;
      v21 = *(int *)(v9 + 96 * v17 + 4);
      if ((_DWORD)v19 == (_DWORD)v21)
      {
        if ((*(_BYTE *)(v20 + 4) & 1) != 0)
          goto LABEL_50;
      }
      else
      {
        v22 = (int)v19 + 1;
        a4 = *((_QWORD *)this + 16);
        v23 = (a4 - v18) >> 3;
        if (v22 >= v23)
        {
          a8 = v22 - v23;
          a7 = v22 - v23;
          if (v22 - v23 >= v23)
          {
            a7 = (int)v19 + 1;
            if (a4 != v18)
              a7 = a8 % v23;
          }
        }
        else
        {
          a7 = (int)v19 + 1;
          if ((int)v19 <= -2)
          {
            a7 = v23 + v22;
            if (v23 + v22 < 0)
            {
              a8 = a7 / v23;
              a7 = a7 % v23 + v23;
              if (a4 == v18)
                a7 = (int)v19 + 1;
            }
          }
        }
        if ((_DWORD)v21 == (_DWORD)a7)
        {
          if ((*(_BYTE *)(v18 + 8 * v19 + 4) & 1) != 0)
            goto LABEL_50;
          if ((*(_BYTE *)(v18 + 8 * v21 + 4) & 1) != 0)
          {
            v20 = v18 + 8 * v21;
LABEL_50:
            v35 = *(float *)(v9 + v11 + 88);
            if (*(_BYTE *)(v9 + v11 + 80))
              v36 = *(float *)(v9 + v11 + 88);
            else
              v36 = -1.0;
            if (*(_BYTE *)(v9 + v11 + 80))
              v35 = -1.0;
            v37 = sqrtf((float)(v35 * v35) + (float)(v36 * v36));
            if (v37 == 0.0)
              goto LABEL_68;
            v19 = v9 + 96 * v17;
            v38 = *(float *)(v19 + 48);
            v39 = *(_BYTE *)(v19 + 40) ? *(float *)(v19 + 48) : -1.0;
            if (*(_BYTE *)(v19 + 40))
              v38 = -1.0;
            v40 = sqrtf((float)(v38 * v38) + (float)(v39 * v39));
            if (v40 == 0.0)
              goto LABEL_68;
            v41 = *(_DWORD *)v20;
            v42 = 1.0 / v37;
            v43 = v36 * (float)(1.0 / v37);
            v44 = v35 * (float)(1.0 / v37);
            v45 = 1.0 / v40;
            v46 = v39 * v45;
            v47 = v38 * v45;
            v48 = (float)(v43 * (float)(v38 * v45)) - (float)(v44 * v46);
            if (fabsf(v48) >= 0.08)
            {
              v50 = v42 * *(float *)(v9 + v11 + 84);
              v51 = *(float *)(v19 + 44) * v45;
              v52 = 1.0 / v48;
              *(float *)&v53 = (float)((float)(v44 * v51) - (float)(v50 * v47)) * v52;
              *(float *)&v54 = (float)((float)(v50 * v46) - (float)(v43 * v51)) * v52;
              v55 = v9 + 96 * v17;
              *(_QWORD *)(v55 + 16) = __PAIR64__(v54, v53);
              v56 = (_QWORD *)(v55 + 16);
              *((_DWORD *)v56 - 2) = v41;
              v57 = *(_QWORD *)(v13 + 8 * v41);
              if ((float)((float)((float)(*((float *)&v57 + 1) - *(float *)&v54)
                                 * (float)(*((float *)&v57 + 1) - *(float *)&v54))
                         + (float)((float)(*(float *)&v57 - *(float *)&v53) * (float)(*(float *)&v57 - *(float *)&v53))) > 16.0)
                *v56 = v57;
            }
            else
            {
              v49 = v9 + 96 * v17;
              *(_QWORD *)(v49 + 16) = *(_QWORD *)(v13 + 8 * v41);
              *(_DWORD *)(v49 + 8) = v41;
            }
            goto LABEL_66;
          }
        }
        else
        {
          v20 = v19 + 2;
          a8 = v19 + 2 - v23;
          if (v19 + 2 >= v23)
          {
            a7 = v19 + 2 - v23;
            if (a8 >= v23)
            {
              a7 = v19 + 2;
              if (a4 != v18)
              {
                v20 = a8 / v23;
                a7 = a8 % v23;
              }
            }
          }
          else if ((int)v19 > -3)
          {
            a7 = v19 + 2;
          }
          else
          {
            a8 = v23 + v20;
            a7 = v23 + v20;
            if (v23 + v20 < 0)
            {
              a7 = v19 + 2;
              if (a4 != v18)
              {
                v20 = a8 % v23;
                a7 = a8 % v23 + v23;
              }
            }
          }
          if ((_DWORD)v21 != (_DWORD)a7)
            return;
          v21 = v22 - v23;
          if (v22 >= v23)
          {
            v19 = v22 - v23;
            if (v21 >= v23)
            {
              v19 = v22;
              if (a4 != v18)
                v19 = v21 % v23;
            }
          }
          else if ((int)v19 > -2)
          {
            v19 = (int)v19 + 1;
          }
          else
          {
            v21 = v23 + v22;
            v19 = v23 + v22;
            if (v23 + v22 < 0)
            {
              v19 = v22;
              if (a4 != v18)
                v19 = v21 % v23 + v23;
            }
          }
          if ((*(_BYTE *)(v18 + 8 * (int)v19 + 4) & 1) != 0)
          {
            v20 = v18 + 8 * (int)v19;
            goto LABEL_50;
          }
        }
      }
      v24 = v9 + 96 * v17;
      v25 = *(float *)(v24 + 48);
      if (*(_BYTE *)(v24 + 40))
        v26 = *(float *)(v24 + 48);
      else
        v26 = -1.0;
      if (*(_BYTE *)(v24 + 40))
        v25 = -1.0;
      v27 = sqrtf((float)(v25 * v25) + (float)(v26 * v26));
      if (v27 == 0.0)
      {
LABEL_68:
        VNValidatedLog(4, (uint64_t)CFSTR("%s: degenerate line"), v19, a4, v21, v20, a7, a8, (uint64_t)"computePoints");
        return;
      }
      v28 = v9 + 96 * v17;
      v29 = *(float32x2_t *)(v13 + 8 * *(int *)(v28 + 8));
      v30 = 1.0 / v27;
      v31 = v26 * v30;
      v32 = v25 * v30;
      v33 = vmlas_n_f32(vmuls_lane_f32(v32, v29, 1), v31, v29.f32[0]) + (float)(v30 * *(float *)(v28 + 44));
      *(float *)&v34 = v29.f32[0] - (float)(v33 * v31);
      *((float *)&v34 + 1) = v29.f32[1] - (float)(v33 * v32);
      *(_QWORD *)(v28 + 16) = v34;
LABEL_66:
      v9 = *((_QWORD *)this + 18);
      v14 = 0xAAAAAAAAAAAAAAABLL * ((*((_QWORD *)this + 19) - v9) >> 5);
      v11 += 96;
    }
    while (v14 > (unint64_t)v15++);
  }
}

void apple::vision::libraries::autotrace::ContourToPath::findSubdividedCurves(apple::vision::libraries::autotrace::ContourToPath *this, __n128 a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  int v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int64_t v14;
  uint64_t v15;
  uint64_t v16;

  v3 = *((_QWORD *)this + 18);
  v2 = *((_QWORD *)this + 19);
  if (v2 != v3)
  {
    v5 = 0;
    v6 = 0;
    v7 = 0xAAAAAAAAAAAAAAABLL * ((v2 - v3) >> 5);
    do
    {
      if (*(_DWORD *)(v3 + 96 * v5))
      {
        apple::vision::libraries::autotrace::ContourToPath::makeCurve(this, v6, 0, a2);
        v8 = v6 - v7;
        v3 = *((_QWORD *)this + 18);
        v2 = *((_QWORD *)this + 19);
        v9 = (v2 - v3) >> 5;
        v7 = 0xAAAAAAAAAAAAAAABLL * v9;
        v6 = v8 - 1431655765 * v9;
      }
      else
      {
        v7 = 0xAAAAAAAAAAAAAAABLL * ((v2 - v3) >> 5);
      }
      v5 = ++v6;
    }
    while (v7 > v6);
    if (v2 != v3)
    {
      v10 = 0;
      do
      {
        if (*(_DWORD *)(v3 + 96 * v10))
        {
          v11 = v10 + 1;
        }
        else
        {
          *(_QWORD *)(v3 + 96 * v10 + 32) = *(_QWORD *)(v3 + 96 * v10 + 16);
          v11 = v10 + 1;
          v12 = *((_QWORD *)this + 18);
          v13 = *((_QWORD *)this + 19);
          v14 = 0xAAAAAAAAAAAAAAABLL * ((v13 - v12) >> 5);
          LODWORD(v15) = v10 + 1;
          v16 = v10 + 1 - v14;
          if ((uint64_t)(v10 + 1) >= v14)
          {
            LODWORD(v15) = v10 + 1 - v14;
            if (v16 >= v14)
            {
              LODWORD(v15) = v10 + 1;
              if (v13 != v12)
                v15 = v16 % v14;
            }
          }
          *(_QWORD *)(v12 + 96 * v10 + 72) = *(_QWORD *)(v12 + 96 * (int)v15 + 16);
          v3 = *((_QWORD *)this + 18);
          v2 = *((_QWORD *)this + 19);
        }
        v10 = v11;
      }
      while (0xAAAAAAAAAAAAAAABLL * ((v2 - v3) >> 5) > v11);
    }
  }
}

void apple::vision::libraries::autotrace::ContourToPath::convertToPaths(apple::vision::libraries::autotrace::ContourToPath *this)
{
  uint64_t v1;
  __int128 v3;
  __int128 v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  BOOL v14;
  BOOL v15;
  CGAffineTransform v16;

  v1 = *((_QWORD *)this + 18);
  if (*((_QWORD *)this + 19) != v1)
  {
    v3 = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 32);
    v4 = *MEMORY[0x1E0C9BAA8];
    *(_OWORD *)&v16.c = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 16);
    *(_OWORD *)&v16.tx = v3;
    *(_OWORD *)&v16.a = v4;
    CGPathMoveToPoint(*((CGMutablePathRef *)this + 2), &v16, COERCE_FLOAT(*(_QWORD *)(v1 + 16)), COERCE_FLOAT(HIDWORD(*(_QWORD *)(v1 + 16))));
    v5 = *((_QWORD *)this + 18);
    v6 = *((_QWORD *)this + 19) - v5;
    if (v6)
    {
      v7 = 0;
      v8 = 0;
      v9 = 0xAAAAAAAAAAAAAAABLL * (v6 >> 5);
      v10 = 1;
      do
      {
        LODWORD(v11) = ++v8;
        if (v9 <= v10)
        {
          v11 = v10 - v9;
          if (v10 - v9 >= v9)
            v11 %= v9;
        }
        v12 = v11;
        v13 = *(_DWORD *)(v5 + v7);
        if (v13 == 1)
        {
          CGPathAddCurveToPoint(*((CGMutablePathRef *)this + 2), &v16, COERCE_FLOAT(*(_QWORD *)(v5 + v7 + 32)), COERCE_FLOAT(HIDWORD(*(_QWORD *)(v5 + v7 + 32))), COERCE_FLOAT(*(_QWORD *)(v5 + v7 + 72)), COERCE_FLOAT(HIDWORD(*(_QWORD *)(v5 + v7 + 72))), COERCE_FLOAT(*(_QWORD *)(v5 + 96 * v12 + 16)), COERCE_FLOAT(HIDWORD(*(_QWORD *)(v5 + 96 * v12 + 16))));
        }
        else if (!v13)
        {
          CGPathAddLineToPoint(*((CGMutablePathRef *)this + 2), &v16, COERCE_FLOAT(*(_QWORD *)(v5 + 96 * v12 + 16)), COERCE_FLOAT(HIDWORD(*(_QWORD *)(v5 + 96 * v12 + 16))));
        }
        v5 = *((_QWORD *)this + 18);
        v9 = 0xAAAAAAAAAAAAAAABLL * ((*((_QWORD *)this + 19) - v5) >> 5);
        v7 += 96;
        v14 = v9 >= (unint64_t)v10;
        v15 = v9 == v10++;
      }
      while (!v15 && v14);
    }
    CGPathCloseSubpath(*((CGMutablePathRef *)this + 2));
  }
}

void apple::vision::libraries::autotrace::ContourToPath::makeCurve(apple::vision::libraries::autotrace::ContourToPath *this, int a2, int a3, __n128 a4)
{
  int v4;
  int v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  float32x2_t v15;
  float32x2_t v16;
  float v17;
  float v18;
  float v19;
  int *v20;
  uint64_t v21;
  uint64_t v22;
  float32x2_t *v23;
  uint64_t v24;
  int v25;
  int v26;
  int v27;
  int v28;
  float v29;
  uint64_t v30;
  float v31;
  float v32;
  int v33;
  int v34;
  float32x2_t v35;
  float32x2_t v36;
  uint64_t v37;
  int *v38;
  int v39;
  int v40;
  float32x2_t v43;
  float v44;
  int v45;
  int v46;
  int v51;
  float v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  float v60;
  float v61;
  float v62;
  float v63;
  float32x2_t v64;
  float32x2_t v65;
  int32x2_t v66;
  int8x8_t v67;
  float32x2_t v68;
  float32x2_t v69;
  float32x2_t v70;
  unsigned __int8 v71;
  float32x2_t v72;
  float32x2_t v73;
  float v74;
  float v75;
  float v76;
  float v77;
  float v78;
  float v79;
  float32x2_t v80;
  float32x2_t v81;
  int32x2_t v82;
  int8x8_t v85;
  float32x2_t v86;
  float32x2_t v87;
  float32x2_t v89;
  float32x2_t *v90;
  float32x2_t v91;
  float32x2_t v92;
  float32x2_t v93;
  float32x2_t v94;
  float32x2_t v95;
  float32x2_t v96;
  int8x8_t v98;
  float32x2_t v99;
  float32x2_t v100;
  float32x2_t v101;
  float32x2_t v102;
  float32x2_t v103;
  float32x2_t v104;
  int8x8_t v105;
  float32x2_t v106;
  float32x2_t v107;
  float32x2_t v109;
  float32x2_t v110;
  float v112;
  float v113;
  float v114;
  float v115;
  int v118;
  int v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  _OWORD *v124;
  unint64_t v125;
  unint64_t v126;
  uint64_t v127;
  unint64_t v128;
  unint64_t v129;
  unint64_t v130;
  unint64_t v131;
  uint64_t v132;
  _OWORD *v133;
  unint64_t v134;
  char *v135;
  char *v136;
  __int128 v137;
  __int128 v138;
  __int128 v139;
  __int128 v140;
  uint64_t v141;
  char *v142;
  unint64_t v143;
  _OWORD *v144;
  _OWORD *v145;
  char *v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  __int128 v150;
  char *v151;
  __int128 v152;
  __int128 v153;
  __int128 v154;
  __int128 v155;
  unint64_t v156;
  unint64_t v157;
  uint64_t v158;
  unint64_t v159;
  uint64_t v160;
  char *v161;
  char *v162;
  char *v163;
  uint64_t v164;
  int v165;
  unint64_t v166;
  char *v167;
  uint64_t v168;
  void *v169;
  char *v170;
  __int128 v171;
  __int128 v172;
  __int128 v173;
  __int128 v174;
  char *v175;
  char *v176;
  char *v177;
  __int128 v178;
  __int128 v179;
  __int128 v180;
  __int128 v181;
  char *v182;
  char *v183;
  int64_t v184;
  char *v185;
  size_t v186;
  char *v187;
  void *v188;
  int v189;
  int v190;
  uint64_t v191;
  uint64_t v192;
  int v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  int v200;
  apple::vision::libraries::autotrace::ATRRecord *v201;
  BOOL v202;
  int v203;
  float v204;
  float v205;
  __float2 v206;
  int v207;
  uint64_t v208;
  float v209;
  float32x2_t v210;
  int *v211;
  int *v212;
  int v214;
  int v215;
  _DWORD *v216;
  int *v217;
  uint64_t v218;
  int v220;
  int v221;
  float32x2_t v222;
  float32x2_t v223;
  float v224;
  float v225;
  float v226;
  float v227;
  float v228;
  float v229;
  __int32 v230;
  float32x2_t v231;
  float32x2_t v232;
  float32x2_t v233;
  float32x2_t v234;
  float32x2_t v235;
  float32x2_t v236;
  float32x2_t v237;
  float v238;
  float32x2_t v239;
  float v240;
  float32x2_t v241;
  float v242;
  float32x2_t v243;
  char v244[76];
  uint64_t v245;
  uint64_t v246;
  BOOL v247;

  v4 = a3;
  v5 = a2;
  v7 = a2;
  v8 = a2 + 1;
  v10 = *((_QWORD *)this + 18);
  v9 = *((_QWORD *)this + 19);
  v11 = 0xAAAAAAAAAAAAAAABLL * ((v9 - v10) >> 5);
  v12 = v8 - v11;
  if (v8 >= v11)
  {
    _ZF = v9 == v10;
    v13 = v12 % v11;
    if (_ZF)
      LODWORD(v13) = a2 + 1;
    if (v12 >= v11)
      LODWORD(v12) = v13;
  }
  else
  {
    LODWORD(v12) = a2 + 1;
    if (a2 <= -2)
    {
      v12 = v11 + v8;
      if (v11 + v8 < 0)
      {
        if (v9 == v10)
          LODWORD(v12) = a2 + 1;
        else
          LODWORD(v12) = v12 % (uint64_t)(0xAAAAAAAAAAAAAAABLL * ((v9 - v10) >> 5)) - 1431655765 * ((v9 - v10) >> 5);
      }
    }
  }
  v14 = (_QWORD *)(v10 + 96 * a2);
  v15 = (float32x2_t)v14[3];
  v16 = (float32x2_t)v14[8];
  v17 = v15.f32[1];
  v18 = v16.f32[1];
  v19 = vmlas_n_f32((float)-v15.f32[1] * v16.f32[0], v16.f32[1], v15.f32[0]);
  if (v19 == 0.0)
  {
    *(_DWORD *)(v10 + 96 * a2) = 0;
    return;
  }
  v215 = a2 + 1;
  v20 = (int *)*((_QWORD *)this + 3);
  v21 = *((_QWORD *)v20 + 1);
  v22 = *v20;
  v23 = (float32x2_t *)(v10 + 96 * (int)v12);
  v24 = v10 + 96 * a2;
  v25 = *(_DWORD *)(v24 + 8);
  v212 = (int *)(v24 + 8);
  v26 = *(_DWORD *)(v24 + 56);
  v216 = (_DWORD *)(v24 + 56);
  v217 = v20;
  if (v25 + 1 >= (int)v22)
    v27 = *v20;
  else
    v27 = 0;
  v28 = v25 + 1 - v27;
  v29 = 0.0;
  if (v28 != v26)
  {
    v30 = *((_QWORD *)this + 6);
    v31 = *(float *)(v30 + 4 * v25);
    do
    {
      v32 = *(float *)(v30 + 4 * v28);
      v29 = v29 + (float)((float)(v32 - v31) - rintf(v32 - v31));
      v33 = v28 + 1;
      if (v33 >= (int)v22)
        v34 = v22;
      else
        v34 = 0;
      v28 = v33 - v34;
      v31 = v32;
    }
    while (v28 != v26);
  }
  v35 = (float32x2_t)v14[2];
  v36 = v23[2];
  v247 = 0;
  v37 = v10 + 96 * a2;
  v40 = *(_DWORD *)(v37 + 92);
  v38 = (int *)(v37 + 92);
  v39 = v40;
  if (fabsf(v29) > 0.25 && a3 <= 19 && v39 >= 2)
    goto LABEL_108;
  v211 = v38;
  v218 = a2;
  v43 = vsub_f32(v36, v35);
  v44 = v36.f32[1] - v35.f32[1];
  if (v39 / 4 <= 1)
    v45 = 1;
  else
    v45 = v39 / 4;
  v220 = v39;
  if (3 * v39 / 4 >= v39)
    v46 = v39 - 1;
  else
    v46 = 3 * v39 / 4;
  if (v45 >= v46)
  {
    v234 = vneg_f32(v16);
    v7 = a2;
    v39 = v220;
    goto LABEL_76;
  }
  v209 = v36.f32[1] - v35.f32[1];
  v226 = (float)(v35.f32[1] + v36.f32[1]) * 0.5;
  v227 = 0.5 * vadd_f32(v35, v36).f32[0];
  v234 = vneg_f32(v16);
  __asm { FMOV            V14.2S, #0.25 }
  v222 = vmla_f32(v35, _D14, v43);
  __asm { FMOV            V10.2S, #0.75 }
  v210 = v43;
  v223 = vmla_f32(v35, _D10, v43);
  v51 = -1;
  v225 = 0.0;
  v238 = 1000000.0;
  __asm
  {
    FMOV            V11.2S, #-3.0
    FMOV            V13.2S, #3.0
  }
  v54 = 1.0 / v19;
  v224 = 0.0;
  v230 = v16.i32[0];
  v231 = v15;
  v228 = v16.f32[1];
  v229 = v15.f32[1];
  v235 = v35;
  v232 = v36;
  do
  {
    v55 = v25 + v45;
    v56 = v25 + v45;
    if (v25 + v45 >= (int)v22)
    {
      v58 = v55 - v22;
      if (v56 - v22 >= v22)
      {
        _ZF = (_DWORD)v22 == 0;
      }
      else
      {
        LODWORD(v56) = v56 - v22;
        _ZF = 1;
      }
      if (!_ZF)
        v56 = v58 % v22;
    }
    else if ((v56 & 0x80000000) != 0)
    {
      v57 = v55 + v22;
      if (v56 + v22 < 0 == __OFADD__(v56, v22))
        LODWORD(v56) = v56 + v22;
      if (v57 < 0 && (_DWORD)v22)
        v56 = v57 % v22 + v22;
    }
    v60 = (float)(COERCE_FLOAT(*(_QWORD *)(v21 + 8 * (int)v56)) - v227) * 2.6667;
    v61 = (float)(COERCE_FLOAT(HIDWORD(*(_QWORD *)(v21 + 8 * (int)v56))) - v226) * -2.6667;
    v62 = v54 * (float)((float)(v16.f32[0] * v61) + (float)(v60 * v18));
    v63 = v54 * (float)((float)(v15.f32[0] * v61) + (float)(v60 * v17));
    v64 = vmla_n_f32(v35, v15, v62);
    v65 = vmla_n_f32(v36, v234, v63);
    v66 = vceq_f32(v35, v64);
    v67 = (int8x8_t)vceq_f32(v65, v36);
    v240 = v63;
    v242 = v62;
    if ((v66.i8[0] & 1) != 0)
    {
      v68 = (float32x2_t)__PAIR64__(v64.u32[1], v65.u32[0]);
      if ((vand_s8((int8x8_t)vdup_lane_s32(v66, 1), v67).u8[0] & 1) != 0)
      {
        v69 = v222;
        if ((v67.i8[4] & 1) != 0)
          goto LABEL_57;
      }
    }
    else
    {
      v68 = (float32x2_t)__PAIR64__(v64.u32[1], v65.u32[0]);
    }
    v70 = (float32x2_t)__PAIR64__(v68.u32[1], v64.u32[0]);
    v68.i32[1] = v65.i32[1];
    v69 = vmla_f32(v35, _D14, vmla_f32(vmul_f32(vmla_f32(vmul_f32(vsub_f32(vmla_f32(v36, _D11, vsub_f32(v68, v70)), v35), _D14), _D13, vadd_f32(vmla_f32(v35, (float32x2_t)0xC0000000C0000000, v70), v68)), _D14), _D13, vsub_f32(v70, v35)));
    if ((v66.i8[0] & 1) == 0)
    {
      v72 = (float32x2_t)__PAIR64__(v64.u32[1], v65.u32[0]);
LABEL_61:
      v64.i32[1] = v72.i32[1];
      v72.i32[1] = v65.i32[1];
      v73 = vmla_f32(v35, _D10, vmla_f32(vmul_f32(vmla_f32(vmul_f32(vsub_f32(vmla_f32(v36, _D11, vsub_f32(v72, v64)), v35), _D10), _D13, vadd_f32(vmla_f32(v35, (float32x2_t)0xC0000000C0000000, v64), v72)), _D10), _D13, vsub_f32(v64, v35)));
      goto LABEL_62;
    }
LABEL_57:
    v71 = vand_s8((int8x8_t)vdup_lane_s32(v66, 1), v67).u8[0];
    v72 = (float32x2_t)__PAIR64__(v64.u32[1], v65.u32[0]);
    if ((v71 & 1) == 0)
      goto LABEL_61;
    v73 = v223;
    if ((v67.i8[4] & 1) == 0)
      goto LABEL_61;
LABEL_62:
    v74 = apple::vision::libraries::autotrace::ContourToPath::squaredDistanceFromCurve(v22, v21, v25, v56, v69);
    a4.n128_f32[0] = v74
                   + apple::vision::libraries::autotrace::ContourToPath::squaredDistanceFromCurve(v22, v21, v56, v26, v73);
    if (a4.n128_f32[0] >= v238)
    {
      v35 = v235;
      v15 = v231;
      v36 = v232;
      v16.i32[0] = v230;
LABEL_68:
      v18 = v228;
      v17 = v229;
      goto LABEL_69;
    }
    v16.i32[0] = v230;
    if (v242 < 0.0)
    {
      v35 = v235;
      v15 = v231;
      v36 = v232;
      goto LABEL_68;
    }
    v35 = v235;
    v15 = v231;
    v36 = v232;
    v18 = v228;
    v17 = v229;
    if (v240 >= 0.0)
    {
      v51 = v56;
      v238 = a4.n128_f32[0];
      v224 = v242;
      v225 = v240;
    }
LABEL_69:
    ++v45;
  }
  while (v46 != v45);
  if (v51 == -1)
  {
    v5 = a2;
    v7 = v218;
    v4 = a3;
    v39 = v220;
    v43 = v210;
    v44 = v209;
    goto LABEL_76;
  }
  v7 = v218;
  v4 = a3;
  v39 = v220;
  v43 = v210;
  v44 = v209;
  if (v29 >= 3.0)
  {
    v5 = a2;
    v76 = v224;
    v75 = v225;
  }
  else
  {
    v5 = a2;
    v76 = v224;
    v75 = v225;
    if (v220 > 19)
      goto LABEL_77;
LABEL_76:
    v76 = sqrtf((float)(v44 * v44) + (float)(v43.f32[0] * v43.f32[0])) / 3.0;
    v75 = v76;
  }
LABEL_77:
  if (v4 > 19
    || (v77 = sqrtf((float)(v44 * v44) + (float)(v43.f32[0] * v43.f32[0])),
        v78 = 1.0 / fmaxf(v77, 0.001),
        (float)((float)((float)((float)(v18 * (float)(v44 * v78)) + (float)(v16.f32[0] * (float)(v43.f32[0] * v78)))
                      * v75)
              + (float)(v76
                      * (float)((float)(v17 * (float)(v44 * v78)) + (float)(v15.f32[0] * (float)(v43.f32[0] * v78))))) <= v77))
  {
    a4.n128_u32[1] = v234.u32[1];
    v246 = 0;
    a4.n128_u32[0] = 0;
    v236 = vmla_n_f32(v35, v15, v76);
    v233 = vmla_n_f32(v36, v234, v75);
    apple::vision::libraries::autotrace::ContourToPath::goodnessOfFit(v217, v25, v39, (float *)&v246 + 1, (float *)&v246, a4, 0.0, v236, v233);
    if (*((float *)&v246 + 1) > *((float *)this + 1) && v4 <= 19 && *(float *)&v246 > *((float *)this + 2))
    {
      v39 = *v211;
      v25 = *v212;
      goto LABEL_108;
    }
    v90 = (float32x2_t *)(v10 + 96 * (int)v7);
    v90[4] = v236;
    v91 = v233;
    goto LABEL_125;
  }
  if (v39 > 29)
    goto LABEL_108;
  v79 = v77 / 3.0;
  v80 = vmla_n_f32(v35, v15, v79);
  v81 = vmla_n_f32(v36, v234, v79);
  v82 = vceq_f32(v35, v80);
  __asm
  {
    FMOV            V2.2S, #-3.0
    FMOV            V1.2S, #3.0
  }
  v239 = v81;
  v241 = v80;
  if ((v82.i8[0] & 1) == 0)
  {
    v86 = (float32x2_t)__PAIR64__(v35.u32[1], v36.u32[0]);
    v87 = (float32x2_t)__PAIR64__(v80.u32[1], v81.u32[0]);
LABEL_90:
    v92 = (float32x2_t)__PAIR64__(v87.u32[1], v80.u32[0]);
    v93 = (float32x2_t)__PAIR64__(v86.u32[1], v35.u32[0]);
    v94 = vsub_f32((float32x2_t)__PAIR64__(v87.u32[1], v80.u32[0]), (float32x2_t)__PAIR64__(v86.u32[1], v35.u32[0]));
    v95 = vmla_f32((float32x2_t)__PAIR64__(v86.u32[1], v35.u32[0]), (float32x2_t)0xC0000000C0000000, (float32x2_t)__PAIR64__(v87.u32[1], v80.u32[0]));
    v87.i32[1] = v81.i32[1];
    v86.i32[1] = v36.i32[1];
    v96 = vsub_f32(vmla_f32(v86, _D2, vsub_f32(v87, v92)), v93);
    __asm { FMOV            V6.2S, #0.25 }
    v89 = vmla_f32(v93, _D6, vmla_f32(vmul_f32(vmla_f32(vmul_f32(v96, _D6), _D1, vadd_f32(v95, v87)), _D6), _D1, v94));
    if ((v82.i8[0] & 1) != 0)
      goto LABEL_91;
    v99 = (float32x2_t)__PAIR64__(v35.u32[1], v36.u32[0]);
    v100 = (float32x2_t)__PAIR64__(v80.u32[1], v81.u32[0]);
    goto LABEL_95;
  }
  v85 = (int8x8_t)vceq_f32(v81, v36);
  v86 = (float32x2_t)__PAIR64__(v35.u32[1], v36.u32[0]);
  v87 = (float32x2_t)__PAIR64__(v80.u32[1], v81.u32[0]);
  if ((vand_s8((int8x8_t)vdup_lane_s32(v82, 1), v85).u32[0] & 1) == 0 || (v85.i8[4] & 1) == 0)
    goto LABEL_90;
  __asm { FMOV            V4.2S, #0.25 }
  v89 = vmla_f32(v35, _D4, v43);
LABEL_91:
  v98 = (int8x8_t)vceq_f32(v81, v36);
  v99 = (float32x2_t)__PAIR64__(v35.u32[1], v36.u32[0]);
  v100 = (float32x2_t)__PAIR64__(v80.u32[1], v81.u32[0]);
  if ((vand_s8((int8x8_t)vdup_lane_s32(v82, 1), v98).u32[0] & 1) == 0 || (v98.i8[4] & 1) == 0)
  {
LABEL_95:
    v102 = (float32x2_t)__PAIR64__(v100.u32[1], v80.u32[0]);
    v103 = (float32x2_t)__PAIR64__(v99.u32[1], v35.u32[0]);
    v104 = vmla_f32((float32x2_t)__PAIR64__(v99.u32[1], v35.u32[0]), (float32x2_t)0xC0000000C0000000, (float32x2_t)__PAIR64__(v100.u32[1], v80.u32[0]));
    v100.i32[1] = v81.i32[1];
    v99.i32[1] = v36.i32[1];
    v101 = vmla_f32(v103, (float32x2_t)0x3F0000003F000000, vmla_f32(vmul_f32(vmla_f32(vmul_f32(vsub_f32(vmla_f32(v99, _D2, vsub_f32(v100, v102)), v103), (float32x2_t)0x3F0000003F000000), _D1, vadd_f32(v104, v100)), (float32x2_t)0x3F0000003F000000), _D1, vsub_f32(v102, v103)));
    if ((v82.i8[0] & 1) != 0)
      goto LABEL_96;
    v243 = v101;
    v106 = (float32x2_t)__PAIR64__(v35.u32[1], v36.u32[0]);
    v107 = (float32x2_t)__PAIR64__(v80.u32[1], v81.u32[0]);
    goto LABEL_100;
  }
  v101 = vmla_f32(v35, (float32x2_t)0x3F0000003F000000, v43);
LABEL_96:
  v105 = (int8x8_t)vceq_f32(v81, v36);
  v106 = (float32x2_t)__PAIR64__(v35.u32[1], v36.u32[0]);
  v107 = (float32x2_t)__PAIR64__(v80.u32[1], v81.u32[0]);
  v243 = v101;
  if ((vand_s8((int8x8_t)vdup_lane_s32(v82, 1), v105).u32[0] & 1) != 0 && (v105.i8[4] & 1) != 0)
  {
    __asm { FMOV            V1.2S, #0.75 }
    v109 = vmla_f32(v35, _D1, v43);
    goto LABEL_101;
  }
LABEL_100:
  v110 = (float32x2_t)__PAIR64__(v107.u32[1], v80.u32[0]);
  v35.i32[1] = v106.i32[1];
  v107.i32[1] = v81.i32[1];
  v106.i32[1] = v36.i32[1];
  __asm { FMOV            V3.2S, #0.75 }
  v109 = vmla_f32(v35, _D3, vmla_f32(vmul_f32(vmla_f32(vmul_f32(vsub_f32(vmla_f32(v106, _D2, vsub_f32(v107, v110)), v35), _D3), _D1, vadd_f32(vmla_f32(v35, (float32x2_t)0xC0000000C0000000, v110), v107)), _D3), _D1, vsub_f32(v110, v35)));
LABEL_101:
  v237 = v109;
  v112 = apple::vision::libraries::autotrace::ContourToPath::squaredDistanceFromCurve(v22, v21, v25, v26, v89);
  v113 = apple::vision::libraries::autotrace::ContourToPath::squaredDistanceFromCurve(v22, v21, v25, v26, v243);
  v114 = apple::vision::libraries::autotrace::ContourToPath::squaredDistanceFromCurve(v22, v21, v25, v26, v237);
  v115 = *((float *)this + 2) * *((float *)this + 2);
  if (v112 < v115 && v113 < v115 && v114 < v115)
  {
    v90 = (float32x2_t *)(v10 + 96 * (int)v7);
    v90[4] = v241;
    v91 = v239;
LABEL_125:
    v90[9] = v91;
    return;
  }
LABEL_108:
  if (v39 >= 0)
    v118 = v39;
  else
    v118 = v39 + 1;
  v119 = v25 + (v118 >> 1);
  v120 = v119;
  if (v119 >= (int)v22)
  {
    v122 = v119 - v22;
    LODWORD(v121) = v120 - v22;
    if (v120 - v22 >= v22)
    {
      LODWORD(v121) = v120;
      if ((_DWORD)v22)
        v121 = v122 % v22;
    }
  }
  else if (v119 < 0)
  {
    v123 = v119 + v22;
    LODWORD(v121) = v120 + v22;
    if (v120 + v22 < 0)
    {
      LODWORD(v121) = v120;
      if ((_DWORD)v22)
        v121 = v123 % v22 + v22;
    }
  }
  else
  {
    LODWORD(v121) = v25 + (v118 >> 1);
  }
  if (v25 != (_DWORD)v121 && *v216 != (_DWORD)v121)
  {
    v214 = v5;
    v124 = (_OWORD *)*((_QWORD *)this + 19);
    v125 = *((_QWORD *)this + 20);
    if ((unint64_t)v124 < v125)
    {
      v124[4] = 0u;
      v124[5] = 0u;
      v124[2] = 0u;
      v124[3] = 0u;
      *v124 = 0u;
      v124[1] = 0u;
      v126 = (unint64_t)(v124 + 6);
      goto LABEL_141;
    }
    v127 = *((_QWORD *)this + 18);
    v128 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v124 - v127) >> 5);
    v129 = v128 + 1;
    if (v128 + 1 > 0x2AAAAAAAAAAAAAALL)
      goto LABEL_200;
    v130 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v125 - v127) >> 5);
    if (2 * v130 > v129)
      v129 = 2 * v130;
    if (v130 >= 0x155555555555555)
      v131 = 0x2AAAAAAAAAAAAAALL;
    else
      v131 = v129;
    if (v131)
      v131 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<apple::vision::libraries::autotrace::Curve>>(v131);
    else
      v132 = 0;
    v133 = (_OWORD *)(v131 + 96 * v128);
    v134 = v131 + 96 * v132;
    v133[4] = 0u;
    v133[5] = 0u;
    v133[2] = 0u;
    v133[3] = 0u;
    *v133 = 0u;
    v133[1] = 0u;
    v126 = (unint64_t)(v133 + 6);
    v136 = (char *)*((_QWORD *)this + 18);
    v135 = (char *)*((_QWORD *)this + 19);
    if (v135 != v136)
    {
      do
      {
        v137 = *((_OWORD *)v135 - 5);
        *(v133 - 6) = *((_OWORD *)v135 - 6);
        *(v133 - 5) = v137;
        v138 = *((_OWORD *)v135 - 4);
        v139 = *((_OWORD *)v135 - 3);
        v140 = *((_OWORD *)v135 - 1);
        *(v133 - 2) = *((_OWORD *)v135 - 2);
        *(v133 - 1) = v140;
        *(v133 - 4) = v138;
        *(v133 - 3) = v139;
        v133 -= 6;
        v135 -= 96;
      }
      while (v135 != v136);
      v135 = (char *)*((_QWORD *)this + 18);
    }
    *((_QWORD *)this + 18) = v133;
    *((_QWORD *)this + 19) = v126;
    *((_QWORD *)this + 20) = v134;
    if (v135)
      operator delete(v135);
LABEL_141:
    *((_QWORD *)this + 19) = v126;
    v141 = *((_QWORD *)this + 18);
    v142 = (char *)(v141 + 96 * (int)v7);
    v143 = *((_QWORD *)this + 20);
    if (v126 < v143)
    {
      if (v142 == (char *)v126)
      {
        *((_QWORD *)this + 19) = v126 + 96;
      }
      else
      {
        v144 = v142 + 96;
        v145 = (_OWORD *)(v126 - 96);
        v146 = (char *)v126;
        if (v126 >= 0x60)
        {
          v146 = (char *)v126;
          do
          {
            v147 = v145[1];
            *(_OWORD *)v146 = *v145;
            *((_OWORD *)v146 + 1) = v147;
            v148 = v145[2];
            v149 = v145[3];
            v150 = v145[5];
            *((_OWORD *)v146 + 4) = v145[4];
            *((_OWORD *)v146 + 5) = v150;
            *((_OWORD *)v146 + 2) = v148;
            *((_OWORD *)v146 + 3) = v149;
            v145 += 6;
            v146 += 96;
          }
          while ((unint64_t)v145 < v126);
        }
        *((_QWORD *)this + 19) = v146;
        if ((_OWORD *)v126 != v144)
        {
          memmove(v142 + 96, v142, v126 - (_QWORD)v144);
          v146 = (char *)*((_QWORD *)this + 19);
        }
        v151 = &v142[96 * (v146 > v142)];
        v152 = *((_OWORD *)v151 + 1);
        *(_OWORD *)v142 = *(_OWORD *)v151;
        *((_OWORD *)v142 + 1) = v152;
        v153 = *((_OWORD *)v151 + 2);
        v154 = *((_OWORD *)v151 + 3);
        v155 = *((_OWORD *)v151 + 5);
        *((_OWORD *)v142 + 4) = *((_OWORD *)v151 + 4);
        *((_OWORD *)v142 + 5) = v155;
        *((_OWORD *)v142 + 2) = v153;
        *((_OWORD *)v142 + 3) = v154;
      }
      goto LABEL_177;
    }
    v156 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v126 - v141) >> 5) + 1;
    if (v156 > 0x2AAAAAAAAAAAAAALL)
LABEL_200:
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    v157 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v143 - v141) >> 5);
    v158 = 2 * v157;
    if (2 * v157 <= v156)
      v158 = v156;
    if (v157 >= 0x155555555555555)
      v159 = 0x2AAAAAAAAAAAAAALL;
    else
      v159 = v158;
    if (v159)
    {
      v161 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<apple::vision::libraries::autotrace::Curve>>(v159);
    }
    else
    {
      v161 = 0;
      v160 = 0;
    }
    v162 = &v161[96 * (int)v7];
    v163 = &v161[96 * v160];
    v221 = v39;
    if (v160 != v7)
      goto LABEL_169;
    if (v214 >= 1)
    {
      v164 = v7 + 2;
      v165 = v7;
      if (v7 >= -1)
        v164 = v7 + 1;
      v162 -= 96 * (v164 >> 1);
      goto LABEL_170;
    }
    v166 = v214 ? 2 * v7 : 1;
    v167 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<apple::vision::libraries::autotrace::Curve>>(v166);
    v162 = &v167[96 * (v166 >> 2)];
    v163 = &v167[96 * v168];
    if (v161)
    {
      v165 = v7;
      v169 = v161;
      v170 = v163;
      operator delete(v169);
      v163 = v170;
    }
    else
    {
LABEL_169:
      v165 = v7;
    }
LABEL_170:
    v171 = *((_OWORD *)v142 + 1);
    *(_OWORD *)v162 = *(_OWORD *)v142;
    *((_OWORD *)v162 + 1) = v171;
    v172 = *((_OWORD *)v142 + 2);
    v173 = *((_OWORD *)v142 + 3);
    v174 = *((_OWORD *)v142 + 5);
    *((_OWORD *)v162 + 4) = *((_OWORD *)v142 + 4);
    *((_OWORD *)v162 + 5) = v174;
    *((_OWORD *)v162 + 2) = v172;
    *((_OWORD *)v162 + 3) = v173;
    v175 = (char *)*((_QWORD *)this + 18);
    v7 = (uint64_t)v162;
    if (v175 != v142)
    {
      v176 = v142;
      v177 = v162;
      do
      {
        v178 = *((_OWORD *)v176 - 5);
        *((_OWORD *)v177 - 6) = *((_OWORD *)v176 - 6);
        *((_OWORD *)v177 - 5) = v178;
        v179 = *((_OWORD *)v176 - 4);
        v180 = *((_OWORD *)v176 - 3);
        v181 = *((_OWORD *)v176 - 1);
        v7 = (uint64_t)(v177 - 96);
        *((_OWORD *)v177 - 2) = *((_OWORD *)v176 - 2);
        *((_OWORD *)v177 - 1) = v181;
        *((_OWORD *)v177 - 4) = v179;
        *((_OWORD *)v177 - 3) = v180;
        v176 -= 96;
        v177 -= 96;
      }
      while (v176 != v175);
    }
    v182 = v162 + 96;
    v183 = (char *)*((_QWORD *)this + 19);
    v184 = v183 - v142;
    if (v183 != v142)
    {
      v185 = v142;
      v186 = v183 - v142;
      v187 = v163;
      memmove(v182, v185, v186);
      v163 = v187;
    }
    v188 = (void *)*((_QWORD *)this + 18);
    *((_QWORD *)this + 18) = v7;
    *((_QWORD *)this + 19) = &v182[v184];
    *((_QWORD *)this + 20) = v163;
    LODWORD(v7) = v165;
    v39 = v221;
    if (v188)
      operator delete(v188);
LABEL_177:
    v189 = v118 >> 1;
    v190 = v39 - (v118 >> 1);
    v191 = *((_QWORD *)this + 18);
    v192 = v191 + 96 * (int)v7;
    *(_DWORD *)(v192 + 52) = -1;
    *(_DWORD *)(v192 + 56) = v121;
    *(_DWORD *)(v192 + 92) = v189;
    *(_DWORD *)(v192 + 100) = -1;
    *(_DWORD *)(v192 + 104) = v121;
    *(_QWORD *)(v192 + 112) = *(_QWORD *)(v21 + 8 * (int)v121);
    *(_DWORD *)(v192 + 188) = v190;
    if (v189 >= 6)
      v189 = 6;
    v193 = v121 - v189;
    v194 = (int)v121 - v189;
    if (v193 >= (int)v22)
    {
      v196 = v193 - v22;
      LODWORD(v195) = v194 - v22;
      if (v194 - v22 >= v22)
      {
        LODWORD(v195) = v194;
        if ((_DWORD)v22)
          v195 = v196 % v22;
      }
    }
    else if ((v194 & 0x80000000) != 0)
    {
      v197 = v193 + v22;
      LODWORD(v195) = v194 + v22;
      if (v194 + v22 < 0)
      {
        LODWORD(v195) = v194;
        if ((_DWORD)v22)
          v195 = v197 % v22 + v22;
      }
    }
    else
    {
      LODWORD(v195) = v193;
    }
    if (v190 >= 7)
      v190 = 7;
    LODWORD(v198) = v190 + v121;
    v199 = (int)v198;
    if ((int)v198 >= (int)v22)
    {
      LODWORD(v198) = v198 - v22;
      if (v199 - v22 >= v22)
      {
        LODWORD(v198) = v199;
        if ((_DWORD)v22)
          v198 = (v199 - v22) % v22;
      }
    }
    else if ((v198 & 0x80000000) != 0)
    {
      LODWORD(v198) = v198 + v22;
      if (v199 + v22 < 0)
      {
        LODWORD(v198) = v199;
        if ((_DWORD)v22)
          v198 = (v199 + v22) % v22 + v22;
      }
    }
    v245 = 0;
    v200 = (v22 & (((int)v198 - (int)v195) >> 31)) + v198 - v195;
    v201 = (apple::vision::libraries::autotrace::ATRRecord *)apple::vision::libraries::autotrace::ATRRecord::ATRRecord((uint64_t)v244, *((const EPolygon **)this + 3), v195, v200);
    apple::vision::libraries::autotrace::ATRRecord::LinearRegression(v201, &v247, (float *)&v245 + 1, (float *)&v245);
    v202 = v247;
    v203 = v245;
    apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)**((unsigned int **)this + 3), *(const EPolygon **)(*((_QWORD *)this + 3) + 8), v195, v200, v247, *(float *)&v245, v204);
    v206 = __sincosf_stret(v205 * 6.2832);
    *(_QWORD *)(v192 + 120) = __PAIR64__(LODWORD(v206.__sinval), LODWORD(v206.__cosval));
    *(_BYTE *)(v192 + 136) = v202;
    v207 = HIDWORD(v245);
    *(_DWORD *)(v192 + 140) = HIDWORD(v245);
    *(_DWORD *)(v192 + 144) = v203;
    v208 = v191 + 96 * (int)v7;
    *(_QWORD *)(v208 + 64) = __PAIR64__(LODWORD(v206.__sinval), LODWORD(v206.__cosval));
    *(_BYTE *)(v208 + 80) = v202;
    *(_DWORD *)(v208 + 84) = v207;
    *(_DWORD *)(v208 + 88) = v203;
    apple::vision::libraries::autotrace::ContourToPath::makeCurve(this, v215, a3 + 1);
    apple::vision::libraries::autotrace::ContourToPath::makeCurve(this, v214, a3 + 1);
  }
}

void sub_1A1511B6C(_Unwind_Exception *exception_object)
{
  void *v1;

  if (v1)
    operator delete(v1);
  _Unwind_Resume(exception_object);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<apple::vision::libraries::autotrace::Curve>>(unint64_t a1)
{
  if (a1 >= 0x2AAAAAAAAAAAAABLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(96 * a1);
}

float apple::vision::libraries::autotrace::ContourToPath::squaredDistanceFromCurve(int a1, uint64_t a2, int a3, int a4, float32x2_t a5)
{
  int v5;
  float32x2_t v6;
  float v7;
  int v8;
  int v9;
  float32x2_t v10;
  float v11;

  v5 = a3 + 1;
  v6 = vsub_f32(a5, *(float32x2_t *)(a2 + 8 * a3));
  v7 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v6, v6).i32[1]), v6.f32[0], v6.f32[0]);
  while (1)
  {
    v8 = v5 >= a1 ? a1 : 0;
    v9 = v5 - v8;
    if (v9 == a4)
      break;
    v10 = vsub_f32(a5, *(float32x2_t *)(a2 + 8 * v9));
    v11 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v10, v10).i32[1]), v10.f32[0], v10.f32[0]);
    if (v11 < v7)
      v7 = v11;
    v5 = v9 + 1;
  }
  return v7;
}

void apple::vision::libraries::autotrace::ContourToPath::goodnessOfFit(int *a1, int a2, int a3, float *a4, float *a5, __n128 a6, float a7, float32x2_t a8, float32x2_t a9)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  float32x2_t v23;
  float32x2_t v29;
  float32x2_t v30;
  int v32;
  int v33;
  float32x2_t v35;
  int v36;
  int v37;
  float v38;
  int v39;
  int v40;
  float v42;
  float v43;
  float v45;
  double v46;
  __n128 v47;
  float v48;
  float v49;
  float32x2_t v50;
  double v51;

  v14 = *((_QWORD *)a1 + 1);
  v15 = *a1;
  LODWORD(v16) = a3 + a2;
  v17 = a3 + a2;
  if (a3 + a2 >= (int)v15)
  {
    v18 = (int)v16 - v15;
    LODWORD(v16) = v16 - v15;
    if (v17 - v15 >= v15)
    {
      LODWORD(v16) = a3 + a2;
      if ((_DWORD)v15)
        v16 = v18 % v15;
    }
  }
  else if ((v17 & 0x80000000) != 0)
  {
    v19 = v15 + (int)v16;
    LODWORD(v16) = v15 + v16;
    if (v15 + v17 < 0)
    {
      LODWORD(v16) = a3 + a2;
      if ((_DWORD)v15)
        v16 = v19 % v15 + v15;
    }
  }
  v20 = *(float32x2_t *)(v14 + 8 * a2);
  v21 = *(float32x2_t *)(v14 + 8 * (int)v16);
  if (a3 < 3)
    goto LABEL_25;
  v22 = vsub_f32(a8, v20);
  v23 = vsub_f32(v21, a9);
  __asm { FMOV            V6.2S, #3.0 }
  v29 = vmul_f32(vadd_f32(vmla_f32(v20, _D6, vadd_f32(a8, a9)), v21), (float32x2_t)0x3E0000003E000000);
  v30 = vsub_f32(vadd_f32(v23, a8), v20);
  __asm { FMOV            V4.2S, #0.25 }
  v32 = a2 + 1 >= (int)v15 ? *a1 : 0;
  v33 = a2 + 1 - v32;
  _D6 = *(float32x2_t *)(v14 + 8 * v33);
  v35 = vmul_f32(v30, _D4);
  v36 = a3 - 2;
  v37 = -1;
  v38 = 1.0e12;
  do
  {
    if (v33 + 1 >= (int)v15)
      v39 = *a1;
    else
      v39 = 0;
    v40 = v33 + 1 - v39;
    LODWORD(_S17) = HIDWORD(*(_QWORD *)(v14 + 8 * v40));
    LODWORD(v42) = vsub_f32(*(float32x2_t *)(v14 + 8 * v40), _D6).u32[0];
    v43 = vmlas_n_f32((float)(_S17 - _D6.f32[1]) * (float)(_S17 - _D6.f32[1]), v42, v42);
    __asm { FMLS            S18, S17, V6.S[0] }
    v45 = fabsf(_S18) / sqrtf(v43);
    _D6.i32[0] = vsub_f32(v29, _D6).u32[0];
    _D6.f32[0] = sqrtf(vmlas_n_f32((float)(v29.f32[1] - _D6.f32[1]) * (float)(v29.f32[1] - _D6.f32[1]), _D6.f32[0], _D6.f32[0]));
    if (!_ZF)
      _D6.f32[0] = v45;
    if (_D6.f32[0] < v38)
    {
      v37 = v33;
      v38 = _D6.f32[0];
    }
    _D6 = *(float32x2_t *)(v14 + 8 * v40);
    v33 = v33 + 1 - v39;
    --v36;
  }
  while (v36);
  if (v37 == -1)
  {
LABEL_25:
    v50 = vsub_f32(v21, v20);
    v48 = sqrtf(vmlas_n_f32(COERCE_FLOAT(vmul_f32(v50, v50).i32[1]), v50.f32[0], v50.f32[0]));
    v49 = fmaxf(a6.n128_f32[0], a7);
  }
  else
  {
    v51 = COERCE_DOUBLE(vmla_f32(v29, (float32x2_t)0x3F0000003F000000, v35));
    v46 = COERCE_DOUBLE(vmla_f32(v21, (float32x2_t)0xBF000000BF000000, v23));
    v47 = apple::vision::libraries::autotrace::ContourToPath::goodnessOfFit(a1, a6, v38, COERCE_DOUBLE(vmla_f32(v20, (float32x2_t)0x3F0000003F000000, v22)), COERCE_DOUBLE(vmla_f32(v29, (float32x2_t)0xBF000000BF000000, v35)));
    v47.n128_f32[0] = v38;
    apple::vision::libraries::autotrace::ContourToPath::goodnessOfFit(a1, v47, a7, v51, v46);
    v48 = 0.0 + 0.0;
    v49 = fmaxf(0.0, 0.0);
  }
  *a4 = v48;
  *a5 = v49;
}

float apple::vision::libraries::autotrace::ContourToPath::computeCurveStartTangentAtCorner(apple::vision::libraries::autotrace::ContourToPath *a1, uint64_t a2)
{
  int v3;
  float result;
  unsigned int v5;
  uint64_t v6;
  float v7;
  BOOL v8;

  v8 = 0;
  v7 = 0.0;
  v6 = 0;
  v5 = 0;
  apple::vision::libraries::autotrace::ContourToPath::findTangentForwardsFrom(a1, *(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 56), (float *)&v6, (float *)&v5, &v8, &v7, (float *)&v6 + 1);
  v3 = HIDWORD(v6);
  *(_QWORD *)(a2 + 24) = __PAIR64__(v5, v6);
  *(_BYTE *)(a2 + 40) = v8;
  result = v7;
  *(float *)(a2 + 44) = v7;
  *(_DWORD *)(a2 + 48) = v3;
  return result;
}

void apple::vision::libraries::autotrace::ContourToPath::findTangentForwardsFrom(apple::vision::libraries::autotrace::ContourToPath *this, int a2, int a3, float *a4, float *a5, BOOL *a6, float *a7, float *a8)
{
  float *v8;
  int *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  float32x2_t v20;
  int8x8_t v21;
  float v22;
  float v23;
  float v24;
  int v25;
  int v26;
  int v27;
  float v29;
  int v30;
  int v31;
  int v33;
  int v34;
  int v35;
  BOOL *v37;
  int v38;
  int v39;
  int v41;
  int v42;
  int v43;
  float *v44;
  float *v45;
  const EPolygon **v46;
  BOOL v47;
  int v48;
  float v49;
  float v50;
  __float2 v51;
  int v52;
  int v53;
  int v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  apple::vision::libraries::autotrace *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  float v68;
  float v69;
  float v70;
  apple::vision::libraries::autotrace *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  __float2 v79;
  uint64_t v80;
  int v81;
  int8x8_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  BOOL v86;
  unsigned int v87;
  unsigned int v88;
  uint64_t v89;
  int v90;
  int v91;
  int v92;
  float v93;
  float v94;
  _BOOL4 v96;
  int v97;
  unsigned int v98;
  float32x2_t v100;
  float32x2_t v101;
  unsigned int v102;
  float v103;
  float v104;
  float v105;
  int v106;
  int v107;
  BOOL v108;
  float v109;
  uint64_t v110;
  uint64_t v111;
  char v112;
  float v113;
  float v114;
  int8x8_t v115;
  float *v116;
  float *v118;
  float *v119;
  float32x2_t v120;
  _OWORD v121[4];
  uint64_t v122;
  _OWORD v123[4];
  uint64_t v124;
  uint64_t v125;
  BOOL v126[9];

  v8 = a7;
  v126[0] = 0;
  v125 = 0;
  v14 = (int *)*((_QWORD *)this + 3);
  v15 = *((_QWORD *)v14 + 1);
  v16 = *v14;
  v17 = a2 + 1;
  if ((int)v17 >= (int)v16)
    v18 = *v14;
  else
    v18 = 0;
  v19 = v17 - v18;
  v20 = *(float32x2_t *)(v15 + 8 * a2);
  v21 = (int8x8_t)vsub_f32(*(float32x2_t *)(v15 + 8 * v19), v20);
  v22 = fabsf(*(float *)v21.i32);
  v23 = *(float *)&v21.i32[1];
  v24 = fabsf(*(float *)&v21.i32[1]);
  if (v22 <= (float)(v24 * 4.0))
  {
    if (v24 <= (float)(v22 * 4.0))
    {
      v119 = a5;
      v37 = a6;
    }
    else
    {
      v29 = *(float *)v21.i32;
      v25 = a3;
      if (*(float *)v21.i32 >= 0.0)
      {
        if ((_DWORD)v19 != a3)
        {
          v25 = v19;
          do
          {
            v38 = v25 + 1;
            if (v38 >= (int)v16)
              v39 = *v14;
            else
              v39 = 0;
            v25 = v38 - v39;
            v29 = COERCE_FLOAT(*(_QWORD *)(v15 + 8 * v25)) - v20.f32[0];
          }
          while (v29 <= 1.0 && v25 != a3);
        }
        if (v29 > 1.0)
          goto LABEL_56;
      }
      else
      {
        if ((_DWORD)v19 != a3)
        {
          v25 = v19;
          do
          {
            v30 = v25 + 1;
            if (v30 >= (int)v16)
              v31 = *v14;
            else
              v31 = 0;
            v25 = v30 - v31;
            v29 = COERCE_FLOAT(*(_QWORD *)(v15 + 8 * v25)) - v20.f32[0];
          }
          while (v29 >= -1.0 && v25 != a3);
        }
        if (v29 < -1.0)
          goto LABEL_56;
      }
      v119 = a5;
      v37 = a6;
      *(float *)v21.i32 = v29;
    }
  }
  else
  {
    if (*(float *)&v21.i32[1] >= 0.0)
    {
      v33 = a3;
      if ((_DWORD)v19 != a3)
      {
        v33 = v19;
        do
        {
          v34 = v33 + 1;
          if (v34 >= (int)v16)
            v35 = *v14;
          else
            v35 = 0;
          v33 = v34 - v35;
          v23 = *(float *)(v15 + 4 + 8 * v33) - v20.f32[1];
        }
        while (v23 <= 1.0 && v33 != a3);
      }
      v25 = v33;
      if (v23 > 1.0)
        goto LABEL_56;
    }
    else
    {
      v25 = a3;
      if ((_DWORD)v19 != a3)
      {
        v25 = v19;
        do
        {
          v26 = v25 + 1;
          if (v26 >= (int)v16)
            v27 = *v14;
          else
            v27 = 0;
          v25 = v26 - v27;
          v23 = *(float *)(v15 + 4 + 8 * v25) - v20.f32[1];
        }
        while (v23 >= -1.0 && v25 != a3);
      }
      if (v23 < -1.0)
      {
LABEL_56:
        v41 = v25 - a2;
        if (v41 >= -1)
          v42 = 0;
        else
          v42 = *v14;
        v43 = v41 + v42 + 1;
        v44 = a4;
        v45 = a8;
        apple::vision::libraries::autotrace::ATRRecord::ATRRecord((uint64_t)v123, (const EPolygon *)v14, a2, v43);
        apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)v123, v126, (float *)&v125 + 1, (float *)&v125);
        v46 = (const EPolygon **)*((_QWORD *)this + 3);
        v47 = v126[0];
        v48 = v125;
        apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)*(unsigned int *)v46, v46[1], a2, v43, v126[0], *(float *)&v125, v49);
        v51 = __sincosf_stret(v50 * 6.2832);
        *v44 = v51.__cosval;
        *a5 = v51.__sinval;
        *a6 = v47;
        *v8 = *((float *)&v125 + 1);
        *(_DWORD *)v45 = v48;
        return;
      }
    }
    v119 = a5;
    v37 = a6;
    *(float *)&v21.i32[1] = v23;
  }
  v52 = (v16 & ((a3 - a2) >> 31)) + a3 - a2;
  if (v52 > 10)
  {
    v115 = v21;
    v116 = a4;
    v118 = a8;
    apple::vision::libraries::autotrace::ATRRecord::ATRRecord((uint64_t)v123, (const EPolygon *)v14, a2, 10);
    apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)v123, v126, (float *)&v125 + 1, (float *)&v125);
    v53 = v126[0];
    v54 = HIDWORD(v125);
    v55 = *(float *)&v125;
    v56 = apple::vision::libraries::autotrace::ATRRecord::MaxDistanceFromLine((int **)v123, v126[0], *((float *)&v125 + 1), *(float *)&v125);
    apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)**((unsigned int **)this + 3), *(const EPolygon **)(*((_QWORD *)this + 3) + 8), a2, 10, v53, v55, v57);
    v59 = v58;
    if (v56 < apple::vision::libraries::autotrace::straightLineDistanceDeltaToleranceAtAngle(v60, v58, v61, v62, v63, v64, v65, v66, v67))
    {
      if (v52 < 0x15)
        goto LABEL_65;
      apple::vision::libraries::autotrace::ATRRecord::ATRRecord((uint64_t)v121, *((const EPolygon **)this + 3), a2, 20);
      v123[2] = v121[2];
      v123[3] = v121[3];
      v124 = v122;
      v123[0] = v121[0];
      v123[1] = v121[1];
      apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)v123, v126, (float *)&v125 + 1, (float *)&v125);
      v53 = v126[0];
      v54 = HIDWORD(v125);
      v55 = *(float *)&v125;
      v68 = apple::vision::libraries::autotrace::ATRRecord::MaxDistanceFromLine((int **)v123, v126[0], *((float *)&v125 + 1), *(float *)&v125);
      apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)**((unsigned int **)this + 3), *(const EPolygon **)(*((_QWORD *)this + 3) + 8), a2, 20, v53, v55, v69);
      v59 = v70;
      if (v68 < apple::vision::libraries::autotrace::straightLineDistanceDeltaToleranceAtAngle(v71, v70, v72, v73, v74, v75, v76, v77, v78))
      {
LABEL_65:
        v79 = __sincosf_stret(v59 * 6.2832);
        *v116 = v79.__cosval;
        *v119 = v79.__sinval;
        *v37 = v53;
        *(_DWORD *)a7 = v54;
        *v118 = v55;
        return;
      }
    }
    v8 = a7;
    a8 = v118;
    a4 = v116;
    v21 = v115;
  }
  v80 = 0;
  v81 = 0;
  v82 = 0;
  do
  {
    v83 = v80 + a2;
    v84 = v83 - v16;
    if (v83 >= v16)
    {
      if (v84 >= v16)
      {
        v86 = (_DWORD)v16 == 0;
      }
      else
      {
        LODWORD(v83) = v80 + a2 - v16;
        v86 = 1;
      }
      if (!v86)
        v83 = v84 % v16;
    }
    else if (v83 < 0)
    {
      v85 = v83 + v16;
      if (v83 + v16 < 0 == __OFADD__(v83, v16))
        LODWORD(v83) = v83 + v16;
      if (v85 < 0 && (_DWORD)v16)
        v83 = v85 % v16 + v16;
    }
    if ((_DWORD)v83 == a3)
    {
      v87 = 0;
    }
    else
    {
      v88 = 0;
      v89 = (int)v83;
      v90 = v83;
      while (1)
      {
        v91 = v90 + 1;
        v92 = v90 + 1 >= (int)v16 ? v16 : 0;
        v90 = v91 - v92;
        v87 = v88 + 1;
        v21 = (int8x8_t)vsub_f32(*(float32x2_t *)(v15 + 8 * v90), *(float32x2_t *)(v15 + 8 * (int)v83));
        v93 = fabsf(*(float *)v21.i32);
        v94 = fabsf(*(float *)&v21.i32[1]);
        if (v93 == 2.0 || v94 == 2.0)
          break;
        v96 = v93 != 1.0;
        if (v94 == 1.0)
          v96 = 0;
        v97 = v96 | v81;
        v81 |= v97 ^ 1;
        if ((v97 & 1) != 0)
          v98 = -1;
        else
          v98 = 0;
        v82 = vbsl_s8((int8x8_t)vdup_n_s32(v98), v82, v21);
        v88 = v87;
        if (v90 == a3)
          goto LABEL_102;
      }
      if (v90 != a3 && v88 < 4)
      {
        v102 = 1;
        goto LABEL_106;
      }
    }
LABEL_102:
    ++v80;
  }
  while (v80 != 3);
  if ((v81 & 1) == 0)
  {
    v100 = *(float32x2_t *)(v15 + 8 * a2);
    v101 = vsub_f32(*(float32x2_t *)(v15 + 8 * v19), v100);
    LODWORD(v83) = a2;
    goto LABEL_107;
  }
  v102 = 0;
  v89 = (int)v83;
LABEL_106:
  v101 = (float32x2_t)vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v102), 0x1FuLL)), v21, v82);
  v100 = *(float32x2_t *)(v15 + 8 * v89);
LABEL_107:
  v103 = 1.0 / fmaxf(sqrtf(vmlas_n_f32(vmuls_lane_f32(v101.f32[1], v101, 1), v101.f32[0], v101.f32[0])), 0.001);
  v104 = v103 * v101.f32[0];
  v105 = vmuls_lane_f32(v103, v101, 1);
  if (v87 == 2)
  {
    v106 = v83 + 1;
    if (v106 >= (int)v16)
      v107 = v16;
    else
      v107 = 0;
    v100 = vmul_f32(vadd_f32(v100, *(float32x2_t *)(v15 + 8 * (v106 - v107))), (float32x2_t)0x3F0000003F000000);
  }
  v108 = fabsf(v104) <= fabsf(v105);
  v109 = v104 / v105;
  v110 = 1;
  v111 = !v108;
  if (v108)
  {
    v112 = 0;
  }
  else
  {
    v110 = 0;
    v109 = v105 / v104;
    v112 = 1;
  }
  v120 = v100;
  v113 = *(float *)((unint64_t)&v120 | (4 * v111));
  v114 = *(float *)((unint64_t)&v120 | (4 * v110));
  *a4 = v104;
  *v119 = v105;
  *v37 = v112;
  *v8 = v113 - (float)(v109 * v114);
  *a8 = v109;
}

float apple::vision::libraries::autotrace::straightLineDistanceDeltaToleranceAtAngle(apple::vision::libraries::autotrace *this, float a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;
  float v10;
  float v11;
  uint64_t v12;
  float *v13;
  float v14;
  float v15;
  BOOL v16;
  float v17;
  float v18;

  v9 = 0;
  v10 = a2 - (float)((float)(int)floorf(a2 * 4.0) * 0.25);
  if (v10 > 0.125)
    v10 = 0.25 - v10;
  v11 = v10 * 360.0;
  while (1)
  {
    v12 = v9 + 2;
    if (v9 == 14)
      break;
    v13 = &apple::vision::libraries::autotrace::SLDDT[v9];
    v14 = *v13;
    v15 = v13[2];
    v16 = *v13 > v11 || v11 > v15;
    v9 = v12;
    if (!v16)
    {
      v17 = (float)(v11 - v14) / (float)(v15 - v14);
      v18 = apple::vision::libraries::autotrace::SLDDT[(((_DWORD)v12 - 2) & 0xFFFFFFFE) + 1];
      return v18 + (float)(v17 * (float)(apple::vision::libraries::autotrace::SLDDT[(v12 & 0xFFFFFFFE) + 1] - v18));
    }
  }
  VNValidatedLog(4, (uint64_t)CFSTR("%s: angle %.3f not found in straightLineDistanceDeltaToleranceAtAngle"), a4, a5, a6, a7, a8, a9, (uint64_t)"straightLineDistanceDeltaToleranceAtAngle");
  return 0.099;
}

void apple::vision::libraries::autotrace::ContourToPath::findTangentBackwardsFrom(apple::vision::libraries::autotrace::ContourToPath *this, int a2, int a3, float *a4, float *a5, BOOL *a6, float *a7, float *a8)
{
  float *v8;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  float32x2_t v18;
  int8x8_t v19;
  float v20;
  float v21;
  float v22;
  int v23;
  int v24;
  float v28;
  int v29;
  int v33;
  int v34;
  float *v35;
  BOOL *v36;
  float *v37;
  BOOL v38;
  int v39;
  float v40;
  float v41;
  __float2 v42;
  int v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  apple::vision::libraries::autotrace *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  float *v64;
  int v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  float v70;
  float v71;
  float v72;
  apple::vision::libraries::autotrace *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  __float2 v81;
  uint64_t v82;
  int v83;
  int8x8_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  BOOL v88;
  unsigned int v89;
  unsigned int v90;
  uint64_t v91;
  int v92;
  int v93;
  float v94;
  float v95;
  _BOOL4 v97;
  int v98;
  unsigned int v99;
  float32x2_t v101;
  float32x2_t v102;
  unsigned int v103;
  float32x2_t v104;
  int v105;
  float32x2_t v106;
  unsigned __int8 v107;
  float32x2_t v108;
  uint64_t v109;
  BOOL v111;
  int8x8_t v116;
  float *v117;
  float *v118;
  BOOL *v119;
  float *v121;
  float32x2_t v122;
  _OWORD v123[4];
  uint64_t v124;
  _OWORD v125[4];
  uint64_t v126;
  uint64_t v127;
  BOOL v128[9];

  v8 = a8;
  v128[0] = 0;
  v127 = 0;
  v13 = (int *)*((_QWORD *)this + 3);
  v14 = *((_QWORD *)v13 + 1);
  v15 = *v13;
  if (a2 <= 0)
    v16 = *v13;
  else
    v16 = 0;
  v17 = a2 + (uint64_t)v16 - 1;
  v18 = *(float32x2_t *)(v14 + 8 * a2);
  v19 = (int8x8_t)vsub_f32(*(float32x2_t *)(v14 + 8 * v17), v18);
  v20 = fabsf(*(float *)v19.i32);
  v21 = *(float *)&v19.i32[1];
  v22 = fabsf(*(float *)&v19.i32[1]);
  if (v20 <= (float)(v22 * 4.0))
  {
    if (v22 <= (float)(v20 * 4.0))
    {
      v121 = a7;
    }
    else
    {
      v28 = *(float *)v19.i32;
      v23 = a3;
      if ((_DWORD)v17 != a3)
      {
        v23 = a2 + v16 - 1;
        do
        {
          if (v23 <= 0)
            v29 = *v13;
          else
            v29 = 0;
          v23 = v23 + v29 - 1;
          v28 = COERCE_FLOAT(*(_QWORD *)(v14 + 8 * v23)) - v18.f32[0];
        }
        while (v28 >= -1.0 && v28 <= 1.0 && v23 != a3);
      }
      if (v28 < -1.0 || v28 > 1.0)
        goto LABEL_42;
      v121 = a7;
      *(float *)v19.i32 = v28;
    }
  }
  else
  {
    v23 = a3;
    if ((_DWORD)v17 != a3)
    {
      v23 = a2 + v16 - 1;
      do
      {
        if (v23 <= 0)
          v24 = *v13;
        else
          v24 = 0;
        v23 = v23 + v24 - 1;
        v21 = *(float *)(v14 + 4 + 8 * v23) - v18.f32[1];
      }
      while (v21 >= -1.0 && v21 <= 1.0 && v23 != a3);
    }
    if (v21 < -1.0 || v21 > 1.0)
    {
LABEL_42:
      if (a2 - v23 >= -1)
        v33 = 0;
      else
        v33 = *v13;
      v34 = a2 - v23 + v33 + 1;
      v35 = a4;
      v36 = a6;
      v37 = a5;
      apple::vision::libraries::autotrace::ATRRecord::ATRRecord((uint64_t)v125, (const EPolygon *)v13, v23, v34);
      apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)v125, v128, (float *)&v127 + 1, (float *)&v127);
      v38 = v128[0];
      v39 = v127;
      apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)**((unsigned int **)this + 3), *(const EPolygon **)(*((_QWORD *)this + 3) + 8), v23, v34, v128[0], *(float *)&v127, v40);
      v42 = __sincosf_stret(v41 * 6.2832);
      *v35 = v42.__cosval;
      *v37 = v42.__sinval;
      *v36 = v38;
      *a7 = *((float *)&v127 + 1);
      *(_DWORD *)v8 = v39;
      return;
    }
    v121 = a7;
    *(float *)&v19.i32[1] = v21;
  }
  v43 = (v15 & ((a2 - a3) >> 31)) + a2 - a3;
  if (v43 > 10)
  {
    v44 = a2 - 10;
    v45 = a2 - 10;
    v119 = a6;
    v117 = a4;
    v118 = a5;
    v116 = v19;
    if (a2 - 10 >= (int)v15)
    {
      v48 = v44 - v15;
      LODWORD(v47) = v45 - v15;
      if (v45 - v15 >= v15)
      {
        LODWORD(v47) = a2 - 10;
        if ((_DWORD)v15)
          v47 = v48 % v15;
      }
    }
    else if (a2 > 9)
    {
      LODWORD(v47) = a2 - 10;
    }
    else
    {
      v46 = v15 + v44;
      LODWORD(v47) = v15 + v45;
      if (v15 + v45 < 0)
      {
        LODWORD(v47) = a2 - 10;
        if ((_DWORD)v15)
          v47 = v46 % v15 + v15;
      }
    }
    apple::vision::libraries::autotrace::ATRRecord::ATRRecord((uint64_t)v125, (const EPolygon *)v13, v47, 10);
    apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)v125, v128, (float *)&v127 + 1, (float *)&v127);
    v49 = v128[0];
    v50 = HIDWORD(v127);
    v51 = *(float *)&v127;
    v52 = apple::vision::libraries::autotrace::ATRRecord::MaxDistanceFromLine((int **)v125, v128[0], *((float *)&v127 + 1), *(float *)&v127);
    apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)**((unsigned int **)this + 3), *(const EPolygon **)(*((_QWORD *)this + 3) + 8), v47, 10, v49, v51, v53);
    v55 = v54;
    if (v52 < apple::vision::libraries::autotrace::straightLineDistanceDeltaToleranceAtAngle(v56, v54, v57, v58, v59, v60, v61, v62, v63))
    {
      _CF = v43 >= 0x15;
      v64 = a8;
      if (!_CF)
        goto LABEL_72;
      v65 = a2 - 20;
      v66 = a2 - 20;
      if (a2 - 20 >= (int)v15)
      {
        v69 = v65 - v15;
        LODWORD(v68) = v66 - v15;
        if (v66 - v15 >= v15)
        {
          LODWORD(v68) = a2 - 20;
          if ((_DWORD)v15)
            v68 = v69 % v15;
        }
      }
      else if (a2 > 19)
      {
        LODWORD(v68) = a2 - 20;
      }
      else
      {
        v67 = v15 + v65;
        LODWORD(v68) = v15 + v66;
        if (v15 + v66 < 0)
        {
          LODWORD(v68) = a2 - 20;
          if ((_DWORD)v15)
            v68 = v67 % v15 + v15;
        }
      }
      apple::vision::libraries::autotrace::ATRRecord::ATRRecord((uint64_t)v123, *((const EPolygon **)this + 3), v68, 20);
      v125[2] = v123[2];
      v125[3] = v123[3];
      v126 = v124;
      v125[0] = v123[0];
      v125[1] = v123[1];
      apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)v125, v128, (float *)&v127 + 1, (float *)&v127);
      v49 = v128[0];
      v50 = HIDWORD(v127);
      v51 = *(float *)&v127;
      v70 = apple::vision::libraries::autotrace::ATRRecord::MaxDistanceFromLine((int **)v125, v128[0], *((float *)&v127 + 1), *(float *)&v127);
      apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)**((unsigned int **)this + 3), *(const EPolygon **)(*((_QWORD *)this + 3) + 8), v68, 20, v49, v51, v71);
      v55 = v72;
      if (v70 < apple::vision::libraries::autotrace::straightLineDistanceDeltaToleranceAtAngle(v73, v72, v74, v75, v76, v77, v78, v79, v80))
      {
        v64 = a8;
LABEL_72:
        v81 = __sincosf_stret(v55 * 6.2832);
        *v117 = v81.__cosval;
        *v118 = v81.__sinval;
        *v119 = v49;
        *(_DWORD *)v121 = v50;
        *v64 = v51;
        return;
      }
    }
    a6 = v119;
    v8 = a8;
    a4 = v117;
    a5 = v118;
    v19 = v116;
  }
  v82 = 0;
  v83 = 0;
  v84 = 0;
  do
  {
    v85 = a2 - v82;
    v86 = v85 - v15;
    if (v85 >= v15)
    {
      if (v86 >= v15)
      {
        v88 = (_DWORD)v15 == 0;
      }
      else
      {
        LODWORD(v85) = a2 - v82 - v15;
        v88 = 1;
      }
      if (!v88)
        v85 = v86 % v15;
    }
    else if (v85 < 0)
    {
      v87 = v85 + v15;
      if (v85 + v15 < 0 == __OFADD__(v85, v15))
        LODWORD(v85) = v85 + v15;
      if (v87 < 0 && (_DWORD)v15)
        v85 = v87 % v15 + v15;
    }
    if ((_DWORD)v85 == a3)
    {
      v89 = 0;
    }
    else
    {
      v90 = 0;
      v91 = (int)v85;
      v92 = v85;
      while (1)
      {
        v93 = v92 <= 0 ? v15 : 0;
        v92 = v92 + v93 - 1;
        v89 = v90 + 1;
        v19 = (int8x8_t)vsub_f32(*(float32x2_t *)(v14 + 8 * (int)v85), *(float32x2_t *)(v14 + 8 * v92));
        v94 = fabsf(*(float *)v19.i32);
        v95 = fabsf(*(float *)&v19.i32[1]);
        if (v94 == 2.0 || v95 == 2.0)
          break;
        v97 = v94 != 1.0;
        if (v95 == 1.0)
          v97 = 0;
        v98 = v97 | v83;
        v83 |= v98 ^ 1;
        if ((v98 & 1) != 0)
          v99 = -1;
        else
          v99 = 0;
        v84 = vbsl_s8((int8x8_t)vdup_n_s32(v99), v84, v19);
        v90 = v89;
        if (v92 == a3)
          goto LABEL_109;
      }
      _CF = v92 == a3 || v90 >= 4;
      if (!_CF)
      {
        v103 = 1;
        goto LABEL_113;
      }
    }
LABEL_109:
    ++v82;
  }
  while (v82 != 3);
  if ((v83 & 1) == 0)
  {
    v101 = *(float32x2_t *)(v14 + 8 * a2);
    v102 = vsub_f32(v101, *(float32x2_t *)(v14 + 8 * v17));
    LODWORD(v85) = a2;
    goto LABEL_114;
  }
  v103 = 0;
  v91 = (int)v85;
LABEL_113:
  v102 = (float32x2_t)vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v103), 0x1FuLL)), v19, v84);
  v101 = *(float32x2_t *)(v14 + 8 * v91);
LABEL_114:
  v104 = vmul_n_f32(v102, 1.0 / fmaxf(sqrtf(vmlas_n_f32(COERCE_FLOAT(vmul_f32(v102, v102).i32[1]), v102.f32[0], v102.f32[0])), 0.001));
  if (v89 == 2)
  {
    if ((int)v85 <= 0)
      v105 = v15;
    else
      v105 = 0;
    v101 = vmul_f32(vadd_f32(v101, *(float32x2_t *)(v14 + 8 * ((int)v85 + v105 - 1))), (float32x2_t)0x3F0000003F000000);
  }
  v106 = vabs_f32(v104);
  v107 = vcgt_f32(v106, (float32x2_t)vdup_lane_s32((int32x2_t)v106, 1)).u8[0];
  v108 = (float32x2_t)vdup_lane_s32((int32x2_t)v104, 1);
  if ((v107 & 1) != 0)
  {
    v109 = 0;
    _S2 = vdiv_f32(v108, v104).u32[0];
    v111 = 1;
  }
  else
  {
    v111 = 0;
    _S2 = vdiv_f32(v104, v108).u32[0];
    v109 = 1;
  }
  v122 = v101;
  _S3 = *(_DWORD *)((unint64_t)&v122 | (4 * v109));
  *a4 = v104.f32[0];
  __asm { FMLS            S0, S3, V2.S[0] }
  *a5 = v104.f32[1];
  *a6 = v111;
  *(_DWORD *)v121 = _S0;
  *(_DWORD *)v8 = _S2;
}

apple::vision::libraries::autotrace::CornerList *apple::vision::libraries::autotrace::CornerList::findCorner(apple::vision::libraries::autotrace::CornerList *this, apple::vision::libraries::autotrace::CornerList *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  int v9;
  unint64_t v10;
  int v11;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  int *v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;

  if (*(_DWORD *)this <= *((_DWORD *)this + 1))
    v8 = 0;
  else
    v8 = a3;
  v9 = *(_DWORD *)this - v8;
  v10 = 0xAAAAAAAAAAAAAAABLL * ((a2 - this) >> 2);
  v11 = *((_DWORD *)a2 - 2);
  if (v11 < *((_DWORD *)a2 - 3) && v10 > 1)
    v13 = a3;
  else
    v13 = 0;
  if ((int)a4 + (int)a3 <= v13 + v11)
    v14 = a4 + a3;
  else
    v14 = a4;
  if ((int)a4 - (int)a3 >= v9)
    v14 = a4 - a3;
  if ((int)v10 >= 1)
  {
    v15 = 0;
    v16 = (int)a3 >> 1;
    do
    {
      v17 = ((int)v10 + v15) >> 1;
      v18 = (uint64_t)((int)v10 + v15) >> 1;
      v19 = (int *)((char *)this + 12 * v17);
      if ((v10 + v15) > 1)
      {
        v23 = *v19;
        v24 = *((_DWORD *)this + 3 * (int)v18 + 1);
        if (*v19 + v16 >= v24)
          v25 = 0;
        else
          v25 = a3;
        a4 = (v24 - v25);
        a6 = (v24 + a3);
        if (*v19 - v16 > v24)
          v20 = v24 + a3;
        else
          v20 = a4;
      }
      else
      {
        v20 = *((_DWORD *)this + 3 * (int)v18 + 1);
        v21 = *v19;
        if (v20 + v16 >= *v19)
          v22 = 0;
        else
          v22 = a3;
        a4 = (v21 - v22);
        a6 = (v21 + a3);
        if (v20 - v16 > v21)
          v23 = v21 + a3;
        else
          v23 = a4;
      }
      if (v20 >= v14)
      {
        LODWORD(v10) = ((int)v10 + v15) >> 1;
        if (v23 <= v14)
          return (apple::vision::libraries::autotrace::CornerList *)v19;
      }
      else
      {
        v15 = v17 + 1;
      }
    }
    while (v15 < (int)v10);
  }
  while (this != a2)
  {
    if (*((_DWORD *)this + 2) == v14)
      return this;
    this = (apple::vision::libraries::autotrace::CornerList *)((char *)this + 12);
  }
  if ((_DWORD)a5)
    VNValidatedLog(4, (uint64_t)CFSTR("%s: find corner could not find index"), a3, a4, a5, a6, a7, a8, (uint64_t)"findCorner");
  return 0;
}

float apple::vision::libraries::autotrace::ContourToPath::computeAngleSumAndRange(apple::vision::libraries::autotrace::ContourToPath *this, int a2, int a3, float *a4, float *a5)
{
  uint64_t v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  int v11;
  int v12;
  float result;

  v5 = *((_QWORD *)this + 7);
  v6 = *(float *)(v5 + 4 * a2);
  v7 = 0.0;
  v8 = v6;
  v9 = v6;
  do
  {
    v10 = *(float *)(v5 + 4 * a2) - rintf(*(float *)(v5 + 4 * a2) - v6);
    if (v10 >= v8)
    {
      if (v10 > v9)
        v9 = v10;
    }
    else
    {
      v8 = v10;
    }
    v7 = v7 + *(float *)(*((_QWORD *)this + 8) + 4 * a2);
    v11 = a2 + 1;
    if (a2 + 1 >= **((_DWORD **)this + 3))
      v12 = **((_DWORD **)this + 3);
    else
      v12 = 0;
    a2 = v11 - v12;
  }
  while (v11 - v12 != a3);
  *a4 = v7;
  result = v9 - v8;
  *a5 = v9 - v8;
  return result;
}

uint64_t apple::vision::libraries::autotrace::ContourToPath::cutUpCurve(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  float v19;
  unsigned int v20;
  uint64_t v21;
  float v22;
  float v23;
  int v24;
  int v25;
  float v26;
  BOOL v27;
  int v28;
  signed int v29;
  signed int v30;
  signed int v31;
  uint64_t v32;
  float v33;
  float v34;
  uint64_t v35;
  BOOL v36;
  BOOL v37;
  BOOL v38;
  BOOL v39;
  BOOL v40;
  uint64_t result;
  int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char v46;
  float v47;
  float v48;

  v14 = **(int **)(a1 + 24);
  v15 = a4 - a2;
  if ((_DWORD)a4 == (_DWORD)a2)
  {
    if (*(_QWORD *)(a1 + 128) - *(_QWORD *)(a1 + 120) >= 9uLL)
    {
      VNValidatedLog(4, (uint64_t)CFSTR("%s: zero length curve in cutUpCurve at point index %d"), a3, a4, a5, (uint64_t)a6, a7, a8, (uint64_t)"cutUpCurve");
      return 1;
    }
  }
  else if (v15 >= 0xFFFFFFFE
         && (int)v14 >= 101
         && *(_QWORD *)(a1 + 128) - *(_QWORD *)(a1 + 120) >= 0x11uLL)
  {
    VNValidatedLog(4, (uint64_t)CFSTR("%s: cutUpCurve with reversed point indexes %d and %d"), a3, a4, a5, (uint64_t)a6, a7, a8, (uint64_t)"cutUpCurve");
    return 1;
  }
  v48 = 0.0;
  if (v15 <= 0)
    v16 = v14;
  else
    v16 = 0;
  apple::vision::libraries::autotrace::ContourToPath::computeAngleSumAndRange((apple::vision::libraries::autotrace::ContourToPath *)a1, a2, a4, &v48, &v47);
  if (fabsf(v48) <= 0.16667)
    return 1;
  v17 = v16 + v15;
  v18 = *(_QWORD *)(a1 + 72);
  v19 = fabsf(*(float *)(v18 + 4 * (int)a2));
  v20 = a2;
  LODWORD(v21) = a2;
  v22 = v19;
  do
  {
    v23 = fabsf(*(float *)(v18 + 4 * (int)v20));
    v19 = v19 + v23;
    if (v23 <= v22)
      v21 = v21;
    else
      v21 = v20;
    if (v23 > v22)
      v22 = v23;
    v24 = v20 + 1;
    if (v24 >= (int)v14)
      v25 = v14;
    else
      v25 = 0;
    v20 = v24 - v25;
  }
  while (v20 != (_DWORD)a4);
  v26 = v22 / (float)(v19 / (float)v17);
  v27 = v26 < 2.2 || (_DWORD)v21 == (_DWORD)a2;
  if (v27 || v26 <= 1.9)
    goto LABEL_27;
  LODWORD(v43) = v21 - a2;
  v44 = (int)v21 - (int)a2;
  if ((int)v21 - (int)a2 >= (int)v14)
  {
    LODWORD(v43) = v43 - v14;
    if (v44 - v14 >= v14)
    {
      LODWORD(v43) = v21 - a2;
      if ((_DWORD)v14)
        v43 = (v44 - v14) % v14;
    }
  }
  else if ((v44 & 0x80000000) != 0)
  {
    LODWORD(v43) = v43 + v14;
    if (v44 + v14 < 0)
    {
      LODWORD(v43) = v21 - a2;
      if ((_DWORD)v14)
        v43 = (v44 + v14) % v14 + v14;
    }
  }
  if (v17 / 5 >= (int)v43 || 4 * v17 / 5 <= (int)v43)
  {
LABEL_27:
    if ((int)a2 + 1 >= (int)v14)
      v28 = v14;
    else
      v28 = 0;
    v29 = a2 + 1 - v28;
    if (v29 == (_DWORD)a4)
      return 1;
    v30 = a2;
    while (1)
    {
      v31 = v30;
      v30 = v29;
      v32 = *(_QWORD *)(a1 + 56);
      v33 = *(float *)(v32 + 4 * v31);
      v34 = *(float *)(v32 + 4 * v30) - rintf(*(float *)(v32 + 4 * v30) - v33);
      v35 = ((v31 == (_DWORD)a2) & a3) != 0 ? 8 : 24;
      if (v33 <= 0.0 && v34 >= 0.0
        || v33 >= 0.0 && v34 <= 0.0
        || (v33 <= 0.25 ? (v36 = v34 < 0.25) : (v36 = 1),
            !v36
         || (v33 >= 0.25 ? (v37 = v34 > 0.25) : (v37 = 1),
             !v37
          || (v33 <= 0.5 ? (v38 = v34 < 0.5) : (v38 = 1),
              !v38
           || (v33 >= 0.5 ? (v39 = v34 > 0.5) : (v39 = 1),
               !v39
            || (v33 <= 0.75 ? (v40 = v34 < 0.75) : (v40 = 1),
                !v40 || v33 >= 0.75 && v34 <= 0.75 || v33 <= 1.0 && v34 >= 1.0 || v33 >= 1.0 && v34 <= 1.0))))))
      {
        result = apple::vision::libraries::autotrace::ContourToPath::addInterestingPointAtIndex(v31, v35, a6);
        if (!result)
          break;
      }
      if (v30 + 1 >= (int)v14)
        v42 = v14;
      else
        v42 = 0;
      v29 = v30 + 1 - v42;
      if (v29 == (_DWORD)a4)
        return 1;
    }
  }
  else
  {
    result = apple::vision::libraries::autotrace::ContourToPath::addInterestingPointAtIndex(v21, 16, a6);
    if (result)
    {
      result = apple::vision::libraries::autotrace::ContourToPath::addInterestingPointAtIndex(v21, 8, a6);
      if (result)
      {
        v45 = (_DWORD)v21 == (_DWORD)a4 ? a5 : 0;
        result = apple::vision::libraries::autotrace::ContourToPath::cutUpCurve(a1, a2, a3, v21, v45, a6);
        if ((_DWORD)result)
        {
          v46 = apple::vision::libraries::autotrace::ContourToPath::cutUpCurve(a1, v21, 0, a4, a5, a6);
          result = 0;
          if ((v46 & 1) != 0)
            return 1;
        }
      }
    }
  }
  return result;
}

uint64_t apple::vision::libraries::autotrace::ContourToPath::indexOfNewInterestingPointAtPointIndex(int a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  unint64_t v5;
  uint64_t result;
  uint64_t v7;
  int v8;
  int v9;

  *a4 = 0;
  v5 = (a3 - a2) >> 3;
  if ((int)v5 < 1)
  {
    result = 0;
  }
  else
  {
    LODWORD(result) = 0;
    v7 = (a3 - a2) >> 3;
    do
    {
      v8 = ((int)v7 + (int)result) >> 1;
      v9 = *(_DWORD *)(a2 + 8 * v8);
      if (v9 < a1)
        result = (v8 + 1);
      else
        result = result;
      if (v9 >= a1)
        LODWORD(v7) = v8;
    }
    while ((int)result < (int)v7);
  }
  if (v5 > (int)result && *(_DWORD *)(a2 + 8 * (int)result) == a1)
  {
    *a4 = 1;
  }
  else if (v5 == (int)result)
  {
    return 0;
  }
  else
  {
    return result;
  }
  return result;
}

uint64_t apple::vision::libraries::autotrace::ContourToPath::addInterestingPointAtIndex(unsigned int a1, uint64_t a2, _QWORD *a3)
{
  int v4;
  char *v6;
  char *v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  char *v13;
  unint64_t v14;
  char *v15;
  char *v16;
  _QWORD *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  char *v23;
  unint64_t v24;
  char *v25;
  char *v26;
  unint64_t v27;
  char *v28;
  uint64_t v29;
  char *v30;
  char *v31;
  char *v32;
  uint64_t v33;
  char *v34;
  int64_t v35;
  char *v36;

  v4 = a2;
  v7 = (char *)*a3;
  v6 = (char *)a3[1];
  v8 = (uint64_t)&v6[-*a3] >> 3;
  if ((int)v8 < 1)
  {
    v12 = 0;
  }
  else
  {
    v9 = 0;
    v10 = (uint64_t)&v6[-*a3] >> 3;
    do
    {
      v11 = ((int)v10 + v9) >> 1;
      if (*(_DWORD *)&v7[8 * v11] >= (signed int)a1)
        LODWORD(v10) = ((int)v10 + v9) >> 1;
      else
        v9 = v11 + 1;
    }
    while (v9 < (int)v10);
    v12 = v9;
  }
  v13 = &v7[8 * v12];
  if (v8 > v12 && *(_DWORD *)v13 == a1)
  {
    *(_DWORD *)&v7[8 * v12 + 4] |= a2;
  }
  else
  {
    v14 = a3[2];
    if ((unint64_t)v6 >= v14)
    {
      v19 = v8 + 1;
      if ((v8 + 1) >> 61)
        std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
      v20 = v14 - (_QWORD)v7;
      if (v20 >> 2 > v19)
        v19 = v20 >> 2;
      if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8)
        v21 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v21 = v19;
      if (v21)
      {
        v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v21);
      }
      else
      {
        v23 = 0;
        v22 = 0;
      }
      v25 = &v23[8 * v12];
      v26 = &v23[8 * v22];
      if (v12 == v22)
      {
        if (v12 < 1)
        {
          if (v12)
            v27 = 2 * v12;
          else
            v27 = 1;
          v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v27);
          v25 = &v28[8 * (v27 >> 2)];
          v26 = &v28[8 * v29];
          if (v23)
            operator delete(v23);
        }
        else
        {
          v25 -= 8 * ((unint64_t)(v12 + 1) >> 1);
        }
      }
      *(_DWORD *)v25 = a1;
      *((_DWORD *)v25 + 1) = v4;
      v30 = (char *)*a3;
      v31 = v25;
      if ((char *)*a3 != v13)
      {
        v32 = v13;
        v31 = v25;
        do
        {
          v33 = *((_QWORD *)v32 - 1);
          v32 -= 8;
          *((_QWORD *)v31 - 1) = v33;
          v31 -= 8;
        }
        while (v32 != v30);
      }
      v34 = (char *)a3[1];
      v35 = v34 - v13;
      if (v34 != v13)
        memmove(v25 + 8, v13, v34 - v13);
      v36 = (char *)*a3;
      *a3 = v31;
      a3[1] = &v25[v35 + 8];
      a3[2] = v26;
      if (v36)
        operator delete(v36);
    }
    else if (v13 == v6)
    {
      *(_DWORD *)v6 = a1;
      *(_DWORD *)&v7[8 * v12 + 4] = a2;
      a3[1] = v6 + 8;
    }
    else
    {
      v15 = v13 + 8;
      v16 = v6 - 8;
      v17 = (_QWORD *)a3[1];
      while (v16 < v6)
      {
        v18 = *(_QWORD *)v16;
        v16 += 8;
        *v17++ = v18;
      }
      v24 = a1 | (unint64_t)(a2 << 32);
      a3[1] = v17;
      if (v6 != v15)
        memmove(&v6[-8 * ((v6 - v15) >> 3)], v13, v6 - v15);
      *(_QWORD *)v13 = v24;
    }
    return *a3 + 8 * v12;
  }
  return (uint64_t)v13;
}

void sub_1A15134F4(_Unwind_Exception *exception_object)
{
  void *v1;

  if (v1)
    operator delete(v1);
  _Unwind_Resume(exception_object);
}

BOOL apple::vision::libraries::autotrace::ContourToPath::outputLineAtIndex(uint64_t a1, int a2, int a3, void **a4, _DWORD *a5, _BYTE *a6)
{
  int v9;
  const EPolygon *v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _BOOL4 v18;
  float v19;
  float v20;
  float v21;
  apple::vision::libraries::autotrace *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  float v30;
  float v31;
  float v32;
  int v33;
  int v34;
  int v35;
  unsigned int v36;
  int v37;
  uint64_t *v38;
  int v39;
  int v40;
  float64x2_t v42;
  float64x2_t v43;
  int v50;
  int v51;
  int v52;
  uint64_t *v53;
  int v54;
  int v55;
  uint64_t *v56;
  int v57;
  uint64_t v58;
  float *v59;
  float *v60;
  int v61;
  int v62;
  int v63;
  int i;
  uint64_t v68;
  float *v69;
  float *v70;
  int v71;
  int v72;
  _BOOL4 v73;
  float v74;
  float v75;
  float v76;
  apple::vision::libraries::autotrace *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  float v85;
  float v86;
  int v87;
  uint64_t v88;
  int v89;
  int v90;
  int v91;
  float v92;
  float v93;
  int v94;
  float32x2_t v95;
  float64x2_t v96;
  float *v97;
  float *v98;
  int v99;
  _BOOL4 v100;
  float v101;
  float v102;
  apple::vision::libraries::autotrace *v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  float v111;
  int v112;
  uint64_t v113;
  float32x2_t v114;
  float64x2_t v115;
  float *v116;
  float *v117;
  int v118;
  _BOOL4 v119;
  float v120;
  float v121;
  apple::vision::libraries::autotrace *v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  float v130;
  _BOOL8 result;
  _DWORD *v132;
  int v133;
  int v134;
  int v135;
  float v136;
  float v137;
  BOOL v138;
  int *v139;
  int v140;
  int v141;
  float64x2_t v142;
  float64x2_t v143;
  double v144;
  float v145;
  float v146;
  uint64_t v147;
  uint64_t v148;
  BOOL v149;

  v9 = a3;
  v12 = *(const EPolygon **)(a1 + 24);
  v13 = *(_DWORD *)v12;
  v133 = a2;
  v14 = a3 + a2;
  v15 = a3 + a2;
  if (v14 >= (int)v13)
  {
    v17 = v14 - v13;
    if ((_DWORD)v13)
      v15 = (v15 - v13) % v13;
    if (v17 >= v13)
      LODWORD(v16) = v15;
    else
      LODWORD(v16) = v17;
  }
  else
  {
    LODWORD(v16) = v14;
    if (v14 < 0)
    {
      v16 = v13 + v14;
      if (v16 < 0)
      {
        if ((_DWORD)v13)
          v16 = v16 % v13 + v13;
        else
          LODWORD(v16) = v14;
      }
    }
  }
  v148 = 0;
  v149 = 0;
  apple::vision::libraries::autotrace::ATRRecord::ATRRecord((uint64_t)&v139, v12, v133, a3);
  apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)&v139, &v149, (float *)&v148 + 1, (float *)&v148);
  v18 = v149;
  v19 = *(float *)&v148;
  v20 = apple::vision::libraries::autotrace::ATRRecord::MaxDistanceFromLine(&v139, v149, *((float *)&v148 + 1), *(float *)&v148);
  apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)**(unsigned int **)(a1 + 24), *(const EPolygon **)(*(_QWORD *)(a1 + 24) + 8), v133, v9, v18, v19, v21);
  v31 = apple::vision::libraries::autotrace::straightLineDistanceDeltaToleranceAtAngle(v22, v30, v23, v24, v25, v26, v27, v28, v29);
  v32 = v31;
  if (v9 < 51 || v20 <= v31)
  {
    v87 = v133;
    goto LABEL_93;
  }
  v135 = v13;
  v132 = a5;
  v138 = 0;
  v136 = 0.0;
  v137 = 0.0;
  v33 = v9 - 1;
  v34 = v133;
  v134 = v16;
  v35 = v16;
  do
  {
    v36 = v9;
    v37 = v33;
    v38 = (uint64_t *)*((_QWORD *)v139 + 1);
    v39 = *v139;
    v40 = v141;
    _Q3 = vcvtq_f64_f32((float32x2_t)v38[v140]);
    v42 = vsubq_f64(v142, _Q3);
    v43 = vmlsq_f64(v143, _Q3, _Q3);
    v142 = v42;
    v143 = v43;
    _D4 = _Q3.f64[1];
    __asm { FMLS            D0, D4, V3.D[0] }
    v144 = _D0;
    if (v140 + 1 >= v39)
      v50 = v39;
    else
      v50 = 0;
    v51 = v140 + 1 - v50;
    v52 = v141 - 1;
    v140 = v51;
    --v141;
    v53 = &v38[v51];
    _VF = __OFSUB__(v40, 2);
    v54 = v40 - 2;
    if (v54 < 0 == _VF)
    {
      v55 = 0;
      v56 = &v38[v51];
      v57 = v51;
      do
      {
        v58 = *v56;
        if (v55)
        {
          v59 = &v145;
          if (*(float *)&v58 < v145 || (v59 = (float *)&v147, *(float *)&v58 > *(float *)&v147))
            *(_DWORD *)v59 = v58;
          LODWORD(v58) = HIDWORD(v58);
          if (*((float *)&v58 + 1) >= v146)
          {
            v60 = (float *)&v147 + 1;
            if (*((float *)&v58 + 1) <= *((float *)&v147 + 1))
              goto LABEL_30;
            goto LABEL_29;
          }
        }
        else
        {
          LODWORD(v145) = *v56;
          v147 = v58;
          LODWORD(v58) = HIDWORD(v58);
        }
        v60 = &v146;
LABEL_29:
        *(_DWORD *)v60 = v58;
LABEL_30:
        v61 = v57 + 1;
        ++v56;
        if (v57 + 1 < v39)
          ++v57;
        else
          v57 = 0;
        if (v61 >= v39)
          v56 = v38;
        ++v55;
      }
      while (v52 != v55);
    }
    if (v34 + 1 >= v135)
      v62 = v135;
    else
      v62 = 0;
    if (v54 + v51 >= v39)
      v63 = v39;
    else
      v63 = 0;
    _Q3 = vcvtq_f64_f32((float32x2_t)v38[v54 + v51 - v63]);
    v142 = vsubq_f64(v42, _Q3);
    v143 = vmlsq_f64(v43, _Q3, _Q3);
    _D1 = _Q3.f64[1];
    __asm { FMLS            D0, D1, V3.D[0] }
    v144 = _D0;
    v141 = v54;
    if (v52 >= 2)
    {
      for (i = 0; v54 != i; ++i)
      {
        v68 = *v53;
        if (i)
        {
          v69 = &v145;
          if (*(float *)&v68 < v145 || (v69 = (float *)&v147, *(float *)&v68 > *(float *)&v147))
            *(_DWORD *)v69 = v68;
          LODWORD(v68) = HIDWORD(v68);
          if (*((float *)&v68 + 1) >= v146)
          {
            v70 = (float *)&v147 + 1;
            if (*((float *)&v68 + 1) <= *((float *)&v147 + 1))
              goto LABEL_54;
            goto LABEL_53;
          }
        }
        else
        {
          LODWORD(v145) = *v53;
          v147 = v68;
          LODWORD(v68) = HIDWORD(v68);
        }
        v70 = &v146;
LABEL_53:
        *(_DWORD *)v70 = v68;
LABEL_54:
        v71 = v51 + 1;
        ++v53;
        if (v51 + 1 < v39)
          ++v51;
        else
          v51 = 0;
        if (v71 >= v39)
          v53 = v38;
      }
    }
    v34 = v34 + 1 - v62;
    if (v35 <= 0)
      v72 = v135;
    else
      v72 = 0;
    v35 = v35 + v72 - 1;
    v9 -= 2;
    apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)&v139, &v138, &v137, &v136);
    v73 = v138;
    v74 = v136;
    v75 = apple::vision::libraries::autotrace::ATRRecord::MaxDistanceFromLine(&v139, v138, v137, v136);
    apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)**(unsigned int **)(a1 + 24), *(const EPolygon **)(*(_QWORD *)(a1 + 24) + 8), v34, v36 - 2, v73, v74, v76);
    v86 = apple::vision::libraries::autotrace::straightLineDistanceDeltaToleranceAtAngle(v77, v85, v78, v79, v80, v81, v82, v83, v84);
    if (v75 <= v86)
      break;
    v33 = v37 - 2;
  }
  while (v36 > 0x34);
  _CF = v36 >= 0x35;
  v87 = v133;
  if (_CF)
  {
    do
    {
      v88 = *((_QWORD *)v139 + 1);
      v89 = *v139;
      v90 = v141++;
      v91 = v35;
      v92 = v86;
      v93 = v75;
      v94 = v140 + v90;
      if (v94 < v89)
        v89 = 0;
      v95 = *(float32x2_t *)(v88 + 8 * (v94 - v89));
      v96 = vcvtq_f64_f32(v95);
      v142 = vaddq_f64(v142, v96);
      v143 = vmlaq_f64(v143, v96, v96);
      v144 = vmlad_n_f64(v144, v96.f64[1], v96.f64[0]);
      v97 = &v145;
      if (v95.f32[0] < v145 || (v97 = (float *)&v147, v95.f32[0] > *(float *)&v147))
        *v97 = v95.f32[0];
      v98 = &v146;
      if (v95.f32[1] < v146 || (v98 = (float *)&v147 + 1, v95.f32[1] > *((float *)&v147 + 1)))
        *v98 = v95.f32[1];
      if (v35 + 1 >= v135)
        v99 = v135;
      else
        v99 = 0;
      v35 = v35 + 1 - v99;
      apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)&v139, &v138, &v137, &v136);
      v100 = v138;
      v101 = v136;
      v75 = apple::vision::libraries::autotrace::ATRRecord::MaxDistanceFromLine(&v139, v138, v137, v136);
      apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)**(unsigned int **)(a1 + 24), *(const EPolygon **)(*(_QWORD *)(a1 + 24) + 8), v34, v37, v100, v101, v102);
      v86 = apple::vision::libraries::autotrace::straightLineDistanceDeltaToleranceAtAngle(v103, v111, v104, v105, v106, v107, v108, v109, v110);
      ++v37;
    }
    while (v75 <= v86);
    do
    {
      v87 = v34;
      v32 = v92;
      v20 = v93;
      v134 = v91;
      v112 = v140 - 1;
      if (v140 <= 0)
        v112 += *v139;
      v113 = *((_QWORD *)v139 + 1);
      v140 = v112;
      ++v141;
      v114 = *(float32x2_t *)(v113 + 8 * v112);
      v115 = vcvtq_f64_f32(v114);
      v142 = vaddq_f64(v142, v115);
      v143 = vmlaq_f64(v143, v115, v115);
      v144 = vmlad_n_f64(v144, v115.f64[1], v115.f64[0]);
      v116 = &v145;
      if (v114.f32[0] < v145 || (v116 = (float *)&v147, v114.f32[0] > *(float *)&v147))
        *v116 = v114.f32[0];
      v117 = &v146;
      if (v114.f32[1] < v146 || (v117 = (float *)&v147 + 1, v114.f32[1] > *((float *)&v147 + 1)))
        *v117 = v114.f32[1];
      if (v34 <= 0)
        v118 = v135;
      else
        v118 = 0;
      v34 = v34 + v118 - 1;
      apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)&v139, &v138, &v137, &v136);
      v119 = v138;
      v120 = v136;
      v93 = apple::vision::libraries::autotrace::ATRRecord::MaxDistanceFromLine(&v139, v138, v137, v136);
      apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)**(unsigned int **)(a1 + 24), *(const EPolygon **)(*(_QWORD *)(a1 + 24) + 8), v34, v37, v119, v120, v121);
      v92 = apple::vision::libraries::autotrace::straightLineDistanceDeltaToleranceAtAngle(v122, v130, v123, v124, v125, v126, v127, v128, v129);
      ++v37;
      v91 = v35;
    }
    while (v93 <= v92);
  }
  a5 = v132;
  LODWORD(v16) = v134;
LABEL_93:
  if (v20 <= v32)
  {
    apple::vision::libraries::autotrace::ContourToPath::appendInterestingPointAtIndex(v87, 2, a4);
    apple::vision::libraries::autotrace::ContourToPath::appendInterestingPointAtIndex(v16, 4, a4);
    *a5 = v16;
  }
  result = v20 <= v32;
  *a6 = 0;
  return result;
}

uint64_t apple::vision::libraries::autotrace::ContourToPath::insertPairIntoInterestingPoints(uint64_t result, uint64_t a2, unsigned int a3, unsigned int a4, uint64_t *a5, _BYTE *a6)
{
  uint64_t v6;
  signed int v7;
  BOOL v8;
  unsigned int v10;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _DWORD *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  int v34;
  apple::vision::libraries::autotrace::CornerList *Corner;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  unsigned int *v44;
  char v45;
  BOOL v46;
  char v47;
  BOOL v48;
  char v49;
  BOOL v50;
  char v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  _DWORD *v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  BOOL v59;
  uint64_t v60;
  int v61;
  apple::vision::libraries::autotrace::CornerList *v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  uint64_t v72;
  uint64_t v73;
  _DWORD *v74;
  int v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  int v80;
  unsigned int v81;
  __int16 v84;

  *a6 = 0;
  v7 = *(_DWORD *)a2;
  v6 = *(unsigned int *)(a2 + 4);
  v8 = (a4 & 4) == 0 || (*(_DWORD *)(a2 + 4) & 2) == 0;
  if (v7 == a3)
    return result;
  v10 = a3;
  v12 = result;
  v13 = **(_DWORD **)(result + 24);
  v84 = 0;
  v14 = a5[1];
  if (v14 == *a5)
    goto LABEL_175;
  v80 = v13;
  v81 = v6;
  v15 = apple::vision::libraries::autotrace::ContourToPath::indexOfNewInterestingPointAtPointIndex(v7, *a5, v14, (_BYTE *)&v84 + 1);
  result = apple::vision::libraries::autotrace::ContourToPath::indexOfNewInterestingPointAtPointIndex(v10, *a5, a5[1], &v84);
  v19 = v15 + 1;
  v21 = *a5;
  v20 = a5[1];
  v22 = (v20 - *a5) >> 3;
  if (v19 >= v22)
  {
    LODWORD(v23) = v19 - v22;
    if (v19 - v22 >= v22)
    {
      LODWORD(v23) = v15 + 1;
      if (v20 != v21)
        v23 = (v19 - v22) % v22;
    }
  }
  else if (v15 > -2)
  {
    LODWORD(v23) = v15 + 1;
  }
  else
  {
    LODWORD(v23) = v22 + v19;
    if (v22 + v19 < 0)
    {
      LODWORD(v23) = v15 + 1;
      if (v20 != v21)
        v23 = (v22 + v19) % v22 + v22;
    }
  }
  v24 = v15 - 1;
  v25 = v24 - v22;
  if (v24 >= v22)
  {
    LODWORD(v26) = v24 - v22;
    if (v25 >= v22)
    {
      LODWORD(v26) = v15 - 1;
      if (v20 != v21)
        v26 = v25 % v22;
    }
  }
  else if (v15 <= 0)
  {
    LODWORD(v26) = v22 + v24;
    if (v22 + v24 < 0)
    {
      LODWORD(v26) = v15 - 1;
      if (v20 != v21)
        v26 = (v22 + v24) % v22 + v22;
    }
  }
  else
  {
    LODWORD(v26) = v15 - 1;
  }
  v27 = v15;
  if (v15 == (_DWORD)result)
  {
    if (!v84 || !HIBYTE(v84) && (_BYTE)v84)
    {
      v28 = v21 + 8 * (int)v26;
      goto LABEL_33;
    }
    if (*(_QWORD *)(v12 + 128) - *(_QWORD *)(v12 + 120) == 8)
    {
      v6 = v81;
      if (*(_DWORD *)(v21 + 8 * v15 + 4) == 64)
        *(_DWORD *)(a2 + 4) &= ~0x40u;
      goto LABEL_175;
    }
LABEL_174:
    v6 = v81;
LABEL_175:
    result = apple::vision::libraries::autotrace::ContourToPath::addInterestingPointAtIndex(v7, v6, a5);
    if (result)
    {
      result = apple::vision::libraries::autotrace::ContourToPath::addInterestingPointAtIndex(v10, a4, a5);
      if (result)
      {
        v21 = *a5;
        v20 = a5[1];
        goto LABEL_185;
      }
    }
    *a6 = 1;
    return result;
  }
  v29 = (_DWORD *)(v21 + 8 * v15);
  if ((_DWORD)result != (_DWORD)v23)
  {
    v30 = (int)result - 1;
    v31 = v30 - v22;
    if (v30 >= v22)
    {
      LODWORD(v32) = v30 - v22;
      if (v31 >= v22)
      {
        LODWORD(v32) = result - 1;
        if (v20 != v21)
          v32 = v31 % v22;
      }
    }
    else if ((int)result <= 0)
    {
      LODWORD(v32) = v22 + v30;
      if (v22 + v30 < 0)
      {
        LODWORD(v32) = result - 1;
        if (v20 != v21)
          v32 = (v22 + v30) % v22 + v22;
      }
    }
    else
    {
      LODWORD(v32) = result - 1;
    }
    v44 = (unsigned int *)(v21 + 8 * (int)v32);
    if (HIBYTE(v84) | v84)
      v45 = 1;
    else
      v45 = v8;
    if ((v45 & 1) == 0)
    {
      if ((*(_BYTE *)(v21 + 8 * v27 + 4) & 2) != 0 && (*(_BYTE *)(v21 + 8 * (int)v32 + 4) & 4) != 0)
      {
        *v29 = v7;
        *v44 = v10;
      }
      goto LABEL_185;
    }
    if (HIBYTE(v84))
      v46 = v84 == 0;
    else
      v46 = 0;
    v47 = !v46 || v8;
    if ((v47 & 1) == 0)
    {
      v6 = v81;
      if ((*(_BYTE *)(v21 + 8 * v27 + 4) & 2) == 0)
        goto LABEL_185;
      *v44 = v10;
      goto LABEL_175;
    }
    if (HIBYTE(v84))
      v48 = 1;
    else
      v48 = v84 == 0;
    v49 = v48 || v8;
    if ((v49 & 1) != 0)
    {
      if (HIBYTE(v84))
        v50 = v84 == 0;
      else
        v50 = 1;
      v51 = v50 || v8;
      if ((v51 & 1) != 0
        || (*(_BYTE *)(v21 + 8 * v27 + 4) & 2) == 0
        || (*(_BYTE *)(v21 + 8 * (int)result + 4) & 4) == 0)
      {
        goto LABEL_185;
      }
      v52 = result;
      LODWORD(v53) = apple::vision::libraries::autotrace::wrapIndex(v7 + 1, (v20 - *a5) >> 3);
      if ((_DWORD)v53 != v52)
      {
        v6 = v81;
        do
        {
          v54 = v21 + 8 * (int)v53;
          v56 = *(_DWORD *)(v54 + 4);
          v55 = (_DWORD *)(v54 + 4);
          if ((v56 & 0xFFFFFFF9) == 0)
            *v55 = 0;
          v57 = (int)v53 + 1;
          v58 = v57 - v22;
          if (v57 >= v22)
          {
            if (v58 >= v22)
              LODWORD(v53) = v53 + 1;
            else
              LODWORD(v53) = v57 - v22;
            if (v58 >= v22 && v20 != v21)
              v53 = v58 % v22;
          }
          else
          {
            v59 = (int)v53 <= -2;
            LODWORD(v53) = v53 + 1;
            if (v59)
            {
              v60 = v22 + v57;
              LODWORD(v53) = v22 + v57 < 0 != __OFADD__(v22, v57) ? v57 : (int)v22 + (int)v57;
              if (v60 < 0 && v20 != v21)
                v53 = v60 % v22 + v22;
            }
          }
        }
        while (v52 != (_DWORD)v53);
        goto LABEL_175;
      }
    }
    else if ((*(_BYTE *)(v21 + 8 * (int)result + 4) & 4) != 0 && (*(_BYTE *)(v21 + 8 * v27 + 4) & 2) != 0)
    {
      *v29 = v7;
      v71 = result;
      LODWORD(v72) = apple::vision::libraries::autotrace::wrapIndex(v7 + 1, v22);
      if ((_DWORD)v72 != v71)
      {
        v6 = v81;
        do
        {
          v73 = v21 + 8 * (int)v72;
          v75 = *(_DWORD *)(v73 + 4);
          v74 = (_DWORD *)(v73 + 4);
          if ((v75 & 0xFFFFFFF9) == 0)
            *v74 = 0;
          v76 = (int)v72 + 1;
          v77 = v76 - v22;
          if (v76 >= v22)
          {
            if (v77 >= v22)
              LODWORD(v72) = v72 + 1;
            else
              LODWORD(v72) = v76 - v22;
            if (v77 >= v22 && v20 != v21)
              v72 = v77 % v22;
          }
          else
          {
            v59 = (int)v72 <= -2;
            LODWORD(v72) = v72 + 1;
            if (v59)
            {
              v78 = v22 + v76;
              LODWORD(v72) = v22 + v76 < 0 != __OFADD__(v22, v76) ? v76 : (int)v22 + (int)v76;
              if (v78 < 0 && v20 != v21)
                v72 = v78 % v22 + v22;
            }
          }
        }
        while (v71 != (_DWORD)v72);
        goto LABEL_175;
      }
    }
    goto LABEL_174;
  }
  if (HIBYTE(v84) && !(_BYTE)v84)
  {
    v28 = v21 + 8 * v27;
LABEL_33:
    v6 = v81;
    if ((*(_BYTE *)(v28 + 4) & 0xA) != 0)
      goto LABEL_185;
    goto LABEL_175;
  }
  if (!HIBYTE(v84) || !(_BYTE)v84)
  {
    if (!v84)
    {
      v34 = *(_DWORD *)(v21 + 8 * v27 + 4);
      if (v34 == 1)
      {
        Corner = apple::vision::libraries::autotrace::CornerList::findCorner(*(apple::vision::libraries::autotrace::CornerList **)(v12 + 96), *(apple::vision::libraries::autotrace::CornerList **)(v12 + 104), **(unsigned int **)(v12 + 24), *v29, 1, v16, v17, v18);
        v36 = *v29 - v7;
        if (v80 >= 0)
          v37 = v80;
        else
          v37 = v80 + 1;
        v38 = -(v37 >> 1);
        if (v36 >= v38)
          v39 = 0;
        else
          v39 = v80;
        v40 = v39 + v36;
        if (v40 < 0)
          v40 = -v40;
        v41 = v10 - *v29;
        if (v41 >= v38)
          v42 = 0;
        else
          v42 = v80;
        v43 = v42 + v41;
        if (v43 < 0)
          v43 = -v43;
        if (v40 >= v43)
        {
          v6 = v81;
          if (Corner)
            v10 = *((_DWORD *)Corner + 2);
          else
            *v29 = v10;
        }
        else
        {
          v6 = v81;
          if (Corner)
            v7 = *((_DWORD *)Corner + 2);
          else
            *v29 = v7;
        }
        goto LABEL_175;
      }
      if ((v34 & 4) == 0 || (*(_DWORD *)(v21 + 8 * (int)v26 + 4) & 2) == 0)
      {
        v6 = v81;
        if ((v34 & 2) != 0)
          goto LABEL_185;
        goto LABEL_175;
      }
      v7 = *(_DWORD *)(v21 + 8 * (int)v26);
LABEL_172:
      *v29 = v10;
      goto LABEL_174;
    }
    if (HIBYTE(v84) || !(_BYTE)v84)
      goto LABEL_185;
    v61 = *(_DWORD *)(v21 + 8 * v27 + 4);
    if ((v61 & 2) == 0)
    {
      if (v61 != 1)
        goto LABEL_185;
      v62 = apple::vision::libraries::autotrace::CornerList::findCorner(*(apple::vision::libraries::autotrace::CornerList **)(v12 + 96), *(apple::vision::libraries::autotrace::CornerList **)(v12 + 104), **(unsigned int **)(v12 + 24), *v29, 1, v16, v17, v18);
      v63 = *v29 - v7;
      if (v80 >= 0)
        v64 = v80;
      else
        v64 = v80 + 1;
      v65 = -(v64 >> 1);
      if (v63 >= v65)
        v66 = 0;
      else
        v66 = v80;
      v67 = v66 + v63;
      if (v67 < 0)
        v67 = -v67;
      v68 = v10 - *v29;
      if (v68 >= v65)
        v69 = 0;
      else
        v69 = v80;
      v70 = v69 + v68;
      if (v70 < 0)
        v70 = -v70;
      if (v67 >= v70)
      {
        if (v62)
        {
          v10 = *((_DWORD *)v62 + 2);
          goto LABEL_174;
        }
        goto LABEL_172;
      }
      if (v62)
      {
        v7 = *((_DWORD *)v62 + 2);
        goto LABEL_174;
      }
    }
    *v29 = v7;
    goto LABEL_174;
  }
  v33 = *(_DWORD *)(v21 + 8 * v27 + 4);
  if (v8)
  {
    v6 = v81;
    if ((v33 & 8) != 0)
      goto LABEL_185;
  }
  else
  {
    v6 = v81;
    if ((v33 & 2) != 0)
      goto LABEL_185;
  }
  if ((v33 & 0xA) == 0)
    goto LABEL_175;
  while (1)
  {
LABEL_185:
    if (v21 == v20)
    {
      v21 = v20;
      goto LABEL_187;
    }
    if (!*(_DWORD *)(v21 + 4))
      break;
    v21 += 8;
  }
  if (v21 != v20)
  {
    v79 = v21 + 8;
    if (v21 + 8 != v20)
    {
      do
      {
        if (*(_DWORD *)(v79 + 4))
        {
          *(_QWORD *)v21 = *(_QWORD *)v79;
          v21 += 8;
        }
        v79 += 8;
      }
      while (v79 != v20);
      v20 = a5[1];
    }
  }
LABEL_187:
  if (v20 != v21 + 8)
    result = (uint64_t)memmove((void *)v21, (const void *)(v21 + 8), v20 - (v21 + 8));
  a5[1] = v20 - 8;
  return result;
}

uint64_t apple::vision::libraries::autotrace::wrapIndex(uint64_t this, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = this;
  v3 = this - a2;
  if (this >= a2)
  {
    this -= a2;
    if (v3 >= a2)
    {
      this = v2;
      if (a2)
        return v3 % a2;
    }
  }
  else if (this < 0)
  {
    v4 = a2 + this;
    this += a2;
    if (a2 + v2 < 0)
    {
      this = v2;
      if (a2)
        return v4 % a2 + a2;
    }
  }
  return this;
}

_DWORD *apple::vision::libraries::autotrace::ContourToPath::appendInterestingPointAtIndex(int a1, int a2, void **a3)
{
  unint64_t v6;
  _DWORD *v7;
  _DWORD *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  uint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v7 = a3[1];
  v6 = (unint64_t)a3[2];
  if ((unint64_t)v7 >= v6)
  {
    v9 = ((char *)v7 - (_BYTE *)*a3) >> 3;
    v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    v11 = v6 - (_QWORD)*a3;
    if (v11 >> 2 > v10)
      v10 = v11 >> 2;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v10;
    v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v12);
    v14 = &v13[8 * v9];
    v16 = &v13[8 * v15];
    *(_DWORD *)v14 = a1;
    *((_DWORD *)v14 + 1) = a2;
    v8 = v14 + 8;
    v18 = (char *)*a3;
    v17 = (char *)a3[1];
    if (v17 != *a3)
    {
      do
      {
        v19 = *((_QWORD *)v17 - 1);
        v17 -= 8;
        *((_QWORD *)v14 - 1) = v19;
        v14 -= 8;
      }
      while (v17 != v18);
      v17 = (char *)*a3;
    }
    *a3 = v14;
    a3[1] = v8;
    a3[2] = v16;
    if (v17)
      operator delete(v17);
  }
  else
  {
    *v7 = a1;
    v7[1] = a2;
    v8 = v7 + 2;
  }
  a3[1] = v8;
  return v8 - 2;
}

uint64_t apple::vision::libraries::autotrace::ContourToPath::ipCompare(apple::vision::libraries::autotrace::ContourToPath *this, _DWORD *a2, const void *a3)
{
  return (*(_DWORD *)this - *a2);
}

uint64_t apple::vision::libraries::autotrace::ContourToPath::cornerCompare(apple::vision::libraries::autotrace::ContourToPath *this, _DWORD *a2, const void *a3)
{
  return (*(_DWORD *)this - *a2);
}

uint64_t apple::vision::libraries::autotrace::ContourToPath::LRLine(EPolygon *this, const EPolygon *a2, _DWORD *a3, float *a4, float *a5, float *a6)
{
  int v8;
  uint64_t v10;
  _BOOL4 v11;
  float v12;
  float v13;
  int v14;
  int *v16[9];
  uint64_t v17;
  BOOL v18;

  v8 = (int)a2;
  v18 = 0;
  v17 = 0;
  apple::vision::libraries::autotrace::ATRRecord::ATRRecord((uint64_t)v16, this, (int)a2, 5);
  v10 = apple::vision::libraries::autotrace::ATRRecord::LinearRegression((apple::vision::libraries::autotrace::ATRRecord *)v16, &v18, (float *)&v17 + 1, (float *)&v17);
  if ((_DWORD)v10)
  {
    v11 = v18;
    v12 = *(float *)&v17;
    *a4 = apple::vision::libraries::autotrace::ATRRecord::MaxDistanceFromLine(v16, v18, *((float *)&v17 + 1), *(float *)&v17);
    apple::vision::libraries::autotrace::ATRAngleOfLine((apple::vision::libraries::autotrace *)*(_DWORD *)this, *((const EPolygon **)this + 1), v8, 5, v11, v12, v13);
    *a3 = v14;
  }
  return v10;
}

_DWORD *apple::vision::libraries::autotrace::ContourToPath::addHorizontalLine(_DWORD *result, uint64_t a2, int a3, int a4, int a5, void **a6, _BYTE *a7)
{
  int v7;
  int v8;
  int v10;
  float v11;
  int v12;
  int v13;
  int v14;
  float v15;
  float v16;
  float v17;
  uint64_t v18;
  int v19;
  int v20;
  float v21;
  int v23;
  int v24;
  float i;
  int v27;
  int v28;

  *a7 = 0;
  if (a5 >= 10)
  {
    v7 = a4;
    v8 = a4 <= 0 ? (int)result : 0;
    if (vabds_f32(*(float *)(a2 + 8 * a3 + 4), *(float *)(a2 + 8 * (a4 + v8 - 1) + 4)) < 0.001)
    {
      if (a3 >= a4)
      {
        v15 = NAN;
      }
      else
      {
        v10 = 0;
        v11 = 0.0;
        v12 = a3;
        do
        {
          v11 = v11 + *(float *)(a2 + 4 + 8 * v12);
          ++v10;
          v13 = v12 + 1;
          if (v13 >= (int)result)
            v14 = (int)result;
          else
            v14 = 0;
          v12 = v13 - v14;
        }
        while (v12 < a4);
        v15 = v11 / (float)v10;
      }
      v16 = v15 + -0.023;
      v17 = v15 + 0.023;
      v18 = a2 + 4;
      do
      {
        if (a3 <= 0)
          v19 = (int)result;
        else
          v19 = 0;
        v20 = v19 + a3;
        a3 = v20 - 1;
        v21 = *(float *)(v18 + 8 * (v20 - 1));
      }
      while (v21 >= v16 && v21 <= v17);
      if (v20 >= (int)result)
        v23 = (int)result;
      else
        v23 = 0;
      v24 = v20 - v23;
      for (i = *(float *)(a2 + 8 * a4 + 4); i >= v16 && i <= v17; i = *(float *)(v18 + 8 * (v27 - v28)))
      {
        v27 = v7 + 1;
        if (v7 + 1 >= (int)result)
          v28 = (int)result;
        else
          v28 = 0;
        v7 = v27 - v28;
      }
      apple::vision::libraries::autotrace::ContourToPath::appendInterestingPointAtIndex(v24, 2, a6);
      return apple::vision::libraries::autotrace::ContourToPath::appendInterestingPointAtIndex(v7, 4, a6);
    }
  }
  return result;
}

_DWORD *apple::vision::libraries::autotrace::ContourToPath::addVerticalLine(_DWORD *result, uint64_t a2, int a3, int a4, int a5, void **a6, _BYTE *a7)
{
  int v7;
  int v8;
  int v10;
  float v11;
  int v12;
  int v13;
  int v14;
  float v15;
  float v16;
  float v17;
  int v18;
  int v19;
  uint64_t v20;
  int v22;
  int v23;
  uint64_t v24;
  int v26;

  *a7 = 0;
  if (a5 >= 10)
  {
    v7 = a4;
    v8 = a4 <= 0 ? (int)result : 0;
    if (vabds_f32(COERCE_FLOAT(*(_QWORD *)(a2 + 8 * a3)), COERCE_FLOAT(*(_QWORD *)(a2 + 8 * (a4 + v8 - 1)))) < 0.001)
    {
      if (a3 >= a4)
      {
        v15 = NAN;
      }
      else
      {
        v10 = 0;
        v11 = 0.0;
        v12 = a3;
        do
        {
          v11 = v11 + COERCE_FLOAT(*(_QWORD *)(a2 + 8 * v12));
          ++v10;
          v13 = v12 + 1;
          if (v13 >= (int)result)
            v14 = (int)result;
          else
            v14 = 0;
          v12 = v13 - v14;
        }
        while (v12 < a4);
        v15 = v11 / (float)v10;
      }
      v16 = v15 + -0.023;
      v17 = v15 + 0.023;
      do
      {
        if (a3 <= 0)
          v18 = (int)result;
        else
          v18 = 0;
        v19 = v18 + a3;
        a3 = v19 - 1;
        v20 = *(_QWORD *)(a2 + 8 * (v19 - 1));
      }
      while (*(float *)&v20 >= v16 && *(float *)&v20 <= v17);
      if (v19 >= (int)result)
        v22 = (int)result;
      else
        v22 = 0;
      v23 = v19 - v22;
      while (1)
      {
        v24 = *(_QWORD *)(a2 + 8 * v7);
        if (*(float *)&v24 < v16 || *(float *)&v24 > v17)
          break;
        if (v7 + 1 >= (int)result)
          v26 = (int)result;
        else
          v26 = 0;
        v7 = v7 + 1 - v26;
      }
      apple::vision::libraries::autotrace::ContourToPath::appendInterestingPointAtIndex(v23, 2, a6);
      return apple::vision::libraries::autotrace::ContourToPath::appendInterestingPointAtIndex(v7, 4, a6);
    }
  }
  return result;
}

float *apple::vision::libraries::autotrace::ContourToPath::filterAngleBuffer(float *this, float *a2, float *a3, int a4, float a5)
{
  int v5;
  float *v6;
  float v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  float v15;
  float v16;
  float v17;
  float v18;
  int v19;
  int v20;
  int v21;

  v5 = 0;
  v6 = this;
  do
  {
    v7 = *v6;
    if (v5)
      v8 = 0;
    else
      v8 = (int)a3;
    v9 = v5 + v8;
    ++v5;
    v10 = v9 - 1;
    if (v5 >= (int)a3)
      v11 = (int)a3;
    else
      v11 = 0;
    v12 = v5 - v11;
    v13 = 1;
    v14 = a4;
    v15 = *v6;
    do
    {
      v16 = this[v12] - rintf(this[v12] - v7);
      if (vabds_f32(v16, v7) >= a5)
        v16 = -0.0;
      else
        ++v13;
      v17 = v15 + v16;
      v18 = this[v10] - rintf(this[v10] - v7);
      if (vabds_f32(v18, v7) >= a5)
        v18 = -0.0;
      else
        ++v13;
      v15 = v17 + v18;
      v19 = v12 + 1;
      if (v19 >= (int)a3)
        v20 = (int)a3;
      else
        v20 = 0;
      v12 = v19 - v20;
      if (v10 <= 0)
        v21 = (int)a3;
      else
        v21 = 0;
      v10 = v10 + v21 - 1;
      --v14;
    }
    while (v14);
    *a2++ = (float)(v15 / (float)v13) - floorf(v15 / (float)v13);
    ++v6;
  }
  while (v5 != (_DWORD)a3);
  return this;
}

uint64_t cvml::util::`anonymous namespace'::fileExistsAtPath(uint64_t *a1)
{
  void *v2;
  uint64_t *v3;
  void *v4;
  void *v5;
  uint64_t v6;

  v2 = (void *)MEMORY[0x1A1B0B060]();
  if (*((char *)a1 + 23) >= 0)
    v3 = a1;
  else
    v3 = (uint64_t *)*a1;
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB3620], "defaultManager");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "fileExistsAtPath:", v4);

  objc_autoreleasePoolPop(v2);
  return v6;
}

void sub_1A151486C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void cvml::util::`anonymous namespace'::generateTemporaryFilePath(cvml::util::_anonymous_namespace_ *this)
{
  uint64_t v1;
  void *v2;
  int v3;
  void *v4;
  void *v5;
  void *v6;
  const char *v7;
  size_t v8;
  size_t v9;
  void **p_dst;
  uint64_t v11;
  uint64_t v12;
  size_t v13;
  void **v14;
  BOOL v15;
  void *v16;
  int v17;
  void *context;
  void *v20;
  void **__dst;
  size_t v22;
  int64_t v23;

  v1 = MEMORY[0x1A1B0B060]();
  NSTemporaryDirectory();
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB3620], "defaultManager");
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  context = (void *)v1;
  if (v2)
  {
    v3 = 5;
    while (1)
    {
      v4 = (void *)MEMORY[0x1A1B0B060]();
      objc_msgSend(MEMORY[0x1E0CB3A28], "UUID");
      v5 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v5, "UUIDString");
      v6 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v6)
        break;
      v7 = (const char *)objc_msgSend(objc_retainAutorelease(v6), "UTF8String");
      v8 = strlen(v7);
      if (v8 >= 0x7FFFFFFFFFFFFFF8)
        std::string::__throw_length_error[abi:ne180100]();
      v9 = v8;
      if (v8 >= 0x17)
      {
        v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v8 | 7) != 0x17)
          v11 = v8 | 7;
        v12 = v11 + 1;
        p_dst = (void **)operator new(v11 + 1);
        v22 = v9;
        v23 = v12 | 0x8000000000000000;
        __dst = p_dst;
        goto LABEL_12;
      }
      HIBYTE(v23) = v8;
      p_dst = (void **)&__dst;
      if (v8)
        goto LABEL_12;
LABEL_13:
      *((_BYTE *)p_dst + v9) = 0;

      objc_autoreleasePoolPop(v4);
      v13 = v22;
      if (v23 < 0)
      {
        v14 = __dst;
      }
      else
      {
        v13 = HIBYTE(v23);
        v14 = (void **)&__dst;
      }
      if (v13 == 11
        && (*v14 == (void *)0x494C41564E492323
          ? (v15 = *(void **)((char *)v14 + 3) == (void *)0x232344494C41564ELL)
          : (v15 = 0),
            v15))
      {
        v17 = 4;
        if ((v23 & 0x8000000000000000) == 0)
          goto LABEL_27;
      }
      else
      {
        objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@%s"), v2, v14, context);
        v16 = (void *)objc_claimAutoreleasedReturnValue();
        if (v16 && (objc_msgSend(v20, "fileExistsAtPath:", v16) & 1) == 0)
        {
          std::string::basic_string[abi:ne180100]<0>(this, (char *)objc_msgSend(objc_retainAutorelease(v16), "UTF8String"));
          v17 = 1;
        }
        else
        {
          v17 = 0;
        }

        if ((v23 & 0x8000000000000000) == 0)
          goto LABEL_27;
      }
      operator delete(__dst);
LABEL_27:
      if ((v17 | 4) != 4)
        goto LABEL_33;
      if (!--v3)
      {
        v17 = 0;
        goto LABEL_33;
      }
    }
    HIBYTE(v23) = 11;
    p_dst = (void **)&__dst;
    v9 = 11;
    v7 = "##INVALID##";
LABEL_12:
    memmove(p_dst, v7, v9);
    goto LABEL_13;
  }
  *((_BYTE *)this + 23) = 11;
  strcpy((char *)this, "##INVALID##");
  v17 = 1;
LABEL_33:

  objc_autoreleasePoolPop(context);
  if (!v17)
  {
    *((_BYTE *)this + 23) = 11;
    strcpy((char *)this, "##INVALID##");
  }
}

void sub_1A1514B50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  void *v19;

  _Unwind_Resume(a1);
}

uint64_t cvml::util::`anonymous namespace'::moveFile(uint64_t *a1, uint64_t *a2)
{
  unsigned int v2;
  void *v5;
  uint64_t *v6;
  void *v7;
  uint64_t *v8;
  void *v9;
  void *v10;
  int v11;

  v5 = (void *)MEMORY[0x1A1B0B060]();
  if (*((char *)a2 + 23) >= 0)
    v6 = a2;
  else
    v6 = (uint64_t *)*a2;
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v6);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  if (*((char *)a1 + 23) >= 0)
    v8 = a1;
  else
    v8 = (uint64_t *)*a1;
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v8);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB3620], "defaultManager");
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  v11 = objc_msgSend(v10, "fileExistsAtPath:", v7);
  if (v11)
    v2 = objc_msgSend(v10, "moveItemAtPath:toPath:error:", v7, v9, 0);

  objc_autoreleasePoolPop(v5);
  return v11 & v2;
}

void sub_1A1514C80(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t cvml::util::`anonymous namespace'::removeFile(uint64_t *a1)
{
  unsigned int v1;
  void *v3;
  uint64_t *v4;
  void *v5;
  void *v6;
  int v7;

  v3 = (void *)MEMORY[0x1A1B0B060]();
  if (*((char *)a1 + 23) >= 0)
    v4 = a1;
  else
    v4 = (uint64_t *)*a1;
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB3620], "defaultManager");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = objc_msgSend(v6, "fileExistsAtPath:", v5);
  if (v7)
    v1 = objc_msgSend(v6, "removeItemAtPath:error:", v5, 0);

  objc_autoreleasePoolPop(v3);
  return v7 & v1;
}

void sub_1A1514D4C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t cvml::util::MMapFileBackingStore::MMapFileBackingStore(uint64_t a1, uint64_t a2)
{
  std::string *v4;
  __int128 *v5;
  __int128 v6;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  v4 = (std::string *)(a1 + 16);
  v5 = (__int128 *)(a2 + 16);
  if (*(char *)(a2 + 39) < 0)
  {
    std::string::__init_copy_ctor_external(v4, *(const std::string::value_type **)(a2 + 16), *(_QWORD *)(a2 + 24));
  }
  else
  {
    v6 = *v5;
    v4->__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 32);
    *(_OWORD *)&v4->__r_.__value_.__l.__data_ = v6;
  }
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_BYTE *)(a1 + 48) = *(_BYTE *)(a2 + 48);
  *(_QWORD *)a2 = -1;
  *(_DWORD *)(a2 + 8) = -1;
  if (*(char *)(a2 + 39) < 0)
    operator delete(*(void **)v5);
  *((_BYTE *)v5 + 32) = 0;
  *v5 = 0u;
  v5[1] = 0u;
  return a1;
}

uint64_t cvml::util::MMapFileBackingStore::create(cvml::util::MMapFileBackingStore *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  void **v9;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  std::string *v27;
  const __CFString *v29;
  const __CFString *v30;
  _QWORD *v31;
  _QWORD *v32;
  _QWORD *exception;
  uint64_t v34;
  char __buf;
  void *__p[2];
  uint64_t v37;

  v8 = (void *)HIBYTE(v37);
  if (v37 >= 0)
  {
    v9 = __p;
  }
  else
  {
    v8 = __p[1];
    v9 = (void **)__p[0];
  }
  if (v8 == (void *)11
    && *v9 == (void *)0x494C41564E492323
    && *(void **)((char *)v9 + 3) == (void *)0x232344494C41564ELL)
  {
    v29 = CFSTR("MMapFileBackingStore::create -- Could not generate a valid path for temporary file");
LABEL_25:
    VNValidatedLog(4, (uint64_t)v29, v2, v3, v4, v5, v6, v7, v34);
    exception = __cxa_allocate_exception(8uLL);
    *exception = MEMORY[0x1E0DE5060] + 16;
    __cxa_throw(exception, MEMORY[0x1E0DE4EB0], (void (*)(void *))MEMORY[0x1E0DE4DD0]);
  }
  v11 = open((const char *)v9, 1538, 438);
  if (v11 == -1)
  {
    v29 = CFSTR("MMapFileBackingStore::create -- Could not open temporary file for mmaping");
    goto LABEL_25;
  }
  v12 = v11;
  if (lseek(v11, (off_t)this - 1, 0) == -1)
  {
    v30 = CFSTR("MMapFileBackingStore::create -- Unable to grow file to desired capacity -- seek");
    goto LABEL_23;
  }
  __buf = 32;
  if (write(v12, &__buf, 1uLL) != 1)
  {
    VNValidatedLog(4, (uint64_t)CFSTR("MMapFileBackingStore::create -- Unable to grow file to desired capacity -- write"), v19, v20, v21, v22, v23, v24, v34);
    v31 = __cxa_allocate_exception(8uLL);
    *v31 = MEMORY[0x1E0DE5060] + 16;
    __cxa_throw(v31, MEMORY[0x1E0DE4EB0], (void (*)(void *))MEMORY[0x1E0DE4DD0]);
  }
  v25 = mmap(0, (size_t)this, 3, 1, v12, 0);
  if (v25 == (void *)-1)
  {
    v30 = CFSTR("MMapFileBackingStore::create -- Memory mapping failed for temporary file");
LABEL_23:
    VNValidatedLog(4, (uint64_t)v30, v13, v14, v15, v16, v17, v18, v34);
    v32 = __cxa_allocate_exception(8uLL);
    *v32 = MEMORY[0x1E0DE5060] + 16;
    __cxa_throw(v32, MEMORY[0x1E0DE4EB0], (void (*)(void *))MEMORY[0x1E0DE4DD0]);
  }
  v26 = operator new();
  *(_QWORD *)v26 = v25;
  *(_DWORD *)(v26 + 8) = v12;
  v27 = (std::string *)(v26 + 16);
  if (SHIBYTE(v37) < 0)
  {
    std::string::__init_copy_ctor_external(v27, (const std::string::value_type *)__p[0], (std::string::size_type)__p[1]);
  }
  else
  {
    *(_OWORD *)&v27->__r_.__value_.__l.__data_ = *(_OWORD *)__p;
    *(_QWORD *)(v26 + 32) = v37;
  }
  *(_QWORD *)(v26 + 40) = this;
  *(_BYTE *)(v26 + 48) = 1;
  if (SHIBYTE(v37) < 0)
    operator delete(__p[0]);
  return v26;
}

#error "1A15150E8: call analysis failed (funcsize=47)"

uint64_t cvml::util::MMapFileBackingStore::createByMappingDirectlyFromFile(const char *a1, int a2)
{
  const char *v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  off_t v18;
  int v19;
  void *v20;
  uint64_t v21;
  std::string *v22;
  _QWORD *exception;
  const __CFString *v25;
  _QWORD *v26;
  uint64_t v27;

  v3 = a1;
  if (a1[23] < 0)
    a1 = *(const char **)a1;
  v4 = open(a1, 2, 438);
  v11 = v4;
  if (v4 == -1)
  {
    VNValidatedLog(4, (uint64_t)CFSTR("MMapFileBackingStore::createByMappingDirectlyFromFile -- Could not open temporary file for mmaping"), v5, v6, v7, v8, v9, v10, v27);
    exception = __cxa_allocate_exception(8uLL);
    *exception = MEMORY[0x1E0DE5060] + 16;
    __cxa_throw(exception, MEMORY[0x1E0DE4EB0], (void (*)(void *))MEMORY[0x1E0DE4DD0]);
  }
  v18 = lseek(v4, 0, 2);
  if (v18 == -1)
  {
    v25 = CFSTR("MMapFileBackingStore::createByMappingDirectlyFromFile -- error seeking in provided file");
    goto LABEL_16;
  }
  if (a2)
    v19 = 3;
  else
    v19 = 1;
  v20 = mmap(0, v18, v19, 1, v11, 0);
  if (v20 == (void *)-1)
  {
    v25 = CFSTR("MMapFileBackedBuffer::createByMappingDirectlyFromFile -- Memory mapping failed for temporary file");
LABEL_16:
    VNValidatedLog(4, (uint64_t)v25, v12, v13, v14, v15, v16, v17, v27);
    v26 = __cxa_allocate_exception(8uLL);
    *v26 = MEMORY[0x1E0DE5060] + 16;
    __cxa_throw(v26, MEMORY[0x1E0DE4EB0], (void (*)(void *))MEMORY[0x1E0DE4DD0]);
  }
  v21 = operator new();
  *(_QWORD *)v21 = v20;
  *(_DWORD *)(v21 + 8) = v11;
  v22 = (std::string *)(v21 + 16);
  if (v3[23] < 0)
  {
    std::string::__init_copy_ctor_external(v22, *(const std::string::value_type **)v3, *((_QWORD *)v3 + 1));
  }
  else
  {
    *(_OWORD *)&v22->__r_.__value_.__l.__data_ = *(_OWORD *)v3;
    *(_QWORD *)(v21 + 32) = *((_QWORD *)v3 + 2);
  }
  *(_QWORD *)(v21 + 40) = v18;
  *(_BYTE *)(v21 + 48) = a2;
  return v21;
}

void sub_1A1515308(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1A1B0A898](v1, 0x1092C40A95E0729);
  _Unwind_Resume(a1);
}

#error "1A151538C: call analysis failed (funcsize=26)"

void sub_1A151539C()
{
  __cxa_end_catch();
  JUMPOUT(0x1A1515324);
}

uint64_t cvml::util::`anonymous namespace'::writeBackingStoreToFile<cvml::util::MMapFileBackingStore>(uint64_t a1, _QWORD *a2)
{
  unint64_t v2;
  int v5;
  void **v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  unint64_t i;
  size_t v15;
  ssize_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  void **v36;
  void *v37;
  uint64_t v38;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _QWORD *v54;
  uint64_t v55;
  _QWORD *exception;
  const __CFString *v57;
  _QWORD *v58;
  uint64_t v59;
  char *v60;
  uint64_t v61;
  uint64_t v62;
  __int128 v63;
  int64_t v64;
  void *v65[2];
  char v66;
  void *__p[2];
  uint64_t v68;

  v2 = a2[5];
  if (!v2)
    return 0;
  HIBYTE(v68) = 11;
  strcpy((char *)__p, "##INVALID##");
  if (v66 >= 0)
    v6 = v65;
  else
    v6 = (void **)v65[0];
  v13 = open((const char *)v6, 1538, 438);
  if (v13 == -1)
  {
    if (*(char *)(a1 + 23) >= 0)
      v55 = a1;
    else
      v55 = *(_QWORD *)a1;
    VNValidatedLog(4, (uint64_t)CFSTR("writeBackingStoreToFile-- Could not create file: '%s'"), v7, v8, v9, v10, v11, v12, v55);
    exception = __cxa_allocate_exception(8uLL);
    *exception = MEMORY[0x1E0DE5060] + 16;
    __cxa_throw(exception, MEMORY[0x1E0DE4EB0], (void (*)(void *))MEMORY[0x1E0DE4DD0]);
  }
  for (i = 0; i < v2; i += v16)
  {
    if (v2 - i >= 0x4000)
      v15 = 0x4000;
    else
      v15 = v2 - i;
    v16 = write(v13, (const void *)(*a2 + i), v15);
    if (v16 <= 0)
    {
      VNValidatedLog(4, (uint64_t)CFSTR("writeBackingStoreToFile-- error writing out data"), v17, v18, v19, v20, v21, v22, v62);
      v54 = __cxa_allocate_exception(8uLL);
      *v54 = MEMORY[0x1E0DE5060] + 16;
      __cxa_throw(v54, MEMORY[0x1E0DE4EB0], (void (*)(void *))MEMORY[0x1E0DE4DD0]);
    }
  }
  if (close(v13) == -1)
  {
    v57 = CFSTR("writeBackingStoreToFile-- error closing file, file could be corrupt");
LABEL_44:
    VNValidatedLog(4, (uint64_t)v57, v23, v24, v25, v26, v27, v28, v62);
    goto LABEL_45;
  }
  if (v5)
  {
    if (SHIBYTE(v68) < 0)
      operator delete(__p[0]);
    v68 = v64;
    *(_OWORD *)__p = v63;
    v35 = HIBYTE(v64);
    if (v64 < 0)
      v35 = *((_QWORD *)&v63 + 1);
    if (v35 != 11)
      goto LABEL_25;
    v36 = __p;
    if (v64 < 0)
      v36 = (void **)__p[0];
    v37 = *v36;
    v38 = *(uint64_t *)((char *)v36 + 3);
    if (v37 == (void *)0x494C41564E492323 && v38 == 0x232344494C41564ELL)
    {
      if (*(char *)(a1 + 23) >= 0)
        v61 = a1;
      else
        v61 = *(_QWORD *)a1;
      VNValidatedLog(4, (uint64_t)CFSTR("writeBackingStoreToFile -- File exists at output path '%s', and we cannot safely overwrite this file"), v29, v30, v31, v32, v33, v34, v61);
    }
    else
    {
LABEL_25:
        goto LABEL_26;
      if (*(char *)(a1 + 23) >= 0)
        v59 = a1;
      else
        v59 = *(_QWORD *)a1;
      VNValidatedLog(4, (uint64_t)CFSTR("writeBackingStoreToFile-- File exists at output path '%s', and could not copy file to temporary directory"), v40, v41, v42, v43, v44, v45, v59);
      if (SHIBYTE(v68) < 0)
      {
        __p[1] = (void *)11;
        v60 = (char *)__p[0];
      }
      else
      {
        HIBYTE(v68) = 11;
        v60 = (char *)__p;
      }
      strcpy(v60, "##INVALID##");
    }
LABEL_45:
    v58 = __cxa_allocate_exception(8uLL);
    *v58 = MEMORY[0x1E0DE5060] + 16;
    __cxa_throw(v58, MEMORY[0x1E0DE4EB0], (void (*)(void *))MEMORY[0x1E0DE4DD0]);
  }
LABEL_26:
  {
    v57 = CFSTR("writeBackingStoreToFile-- Could not move file from temporary directory");
    goto LABEL_44;
  }
  if (v5
  {
    VNValidatedLog(4, (uint64_t)CFSTR("writeBackingStoreToFile -- Non critical error -- Could not remove original file after rename"), v46, v47, v48, v49, v50, v51, v62);
  }
  v52 = 1;
  if (v66 < 0)
    operator delete(v65[0]);
  if (SHIBYTE(v68) < 0)
    operator delete(__p[0]);
  return v52;
}

#error "1A1515780: call analysis failed (funcsize=64)"

void cvml::util::MMapFileBackingStore::~MMapFileBackingStore(cvml::util::MMapFileBackingStore *this)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  v2 = *(void **)this;
  if (v2 != (void *)-1 && munmap(v2, *((_QWORD *)this + 5)))
    VNValidatedLog(4, (uint64_t)CFSTR("MMapFileBackingStore::destructor -- could not unmap file"), v3, v4, v5, v6, v7, v8, v23);
  v9 = *((_DWORD *)this + 2);
  if (v9 != -1 && close(v9) == -1)
    VNValidatedLog(4, (uint64_t)CFSTR("MMapFileBackingStore::destructor -- error closing file"), v10, v11, v12, v13, v14, v15, v23);
  if (*((_BYTE *)this + 48))
  {
    v16 = (_QWORD *)((char *)this + 16);
    {
      {
        if (*((char *)this + 39) < 0)
          v16 = (_QWORD *)*v16;
        VNValidatedLog(4, (uint64_t)CFSTR("MMapFileBackingStore::destructor -- Could not remove temporary file '%s'"), v17, v18, v19, v20, v21, v22, (uint64_t)v16);
      }
    }
  }
  if (*((char *)this + 39) < 0)
    operator delete(*((void **)this + 2));
}

BOOL cvml::util::MMapFileBackingStore::growStorage(cvml::util::MMapFileBackingStore *this, cvml::util::MMapFileBackingStore *a2)
{
  uint64_t v3;
  _BOOL8 v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  uint64_t v16;
  std::__shared_weak_count *v17;

  if (!a2 || *((_QWORD *)this + 5) >= (unint64_t)a2)
    return 0;
  v3 = cvml::util::MMapFileBackingStore::create(a2);
  std::shared_ptr<cvml::util::MMapFileBackingStore>::shared_ptr[abi:ne180100]<cvml::util::MMapFileBackingStore,void>(&v16, v3);
  v4 = v16 != 0;
  if (v16)
  {
    memcpy(*(void **)v16, *(const void **)this, *((_QWORD *)this + 5));
    v5 = (_QWORD *)v16;
    v6 = *(_QWORD *)this;
    *(_QWORD *)this = *(_QWORD *)v16;
    *v5 = v6;
    v7 = v16;
    LODWORD(v6) = *((_DWORD *)this + 2);
    *((_DWORD *)this + 2) = *(_DWORD *)(v16 + 8);
    *(_DWORD *)(v7 + 8) = v6;
    v8 = *((_QWORD *)this + 4);
    v9 = *((_OWORD *)this + 1);
    v10 = *(_QWORD *)(v7 + 32);
    *((_OWORD *)this + 1) = *(_OWORD *)(v7 + 16);
    *((_QWORD *)this + 4) = v10;
    *(_OWORD *)(v7 + 16) = v9;
    *(_QWORD *)(v7 + 32) = v8;
    v11 = *((_QWORD *)this + 5);
    *((_QWORD *)this + 5) = *(_QWORD *)(v7 + 40);
    *(_QWORD *)(v7 + 40) = v11;
    LOBYTE(v11) = *((_BYTE *)this + 48);
    *((_BYTE *)this + 48) = *(_BYTE *)(v7 + 48);
    *(_BYTE *)(v7 + 48) = v11;
  }
  v12 = v17;
  if (v17)
  {
    p_shared_owners = (unint64_t *)&v17->__shared_owners_;
    do
      v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  return v4;
}

uint64_t cvml::util::MMapFileBackingStore::writeToFile(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  size_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  unsigned __int8 *v9;
  unsigned __int8 *i;

  v4 = *(unsigned __int8 *)(a2 + 23);
  v5 = *(_QWORD *)(a2 + 8);
  if ((v4 & 0x80u) == 0)
    v6 = *(unsigned __int8 *)(a2 + 23);
  else
    v6 = *(_QWORD *)(a2 + 8);
  v7 = *(unsigned __int8 *)(a1 + 39);
  v8 = (char)v7;
  if ((v7 & 0x80u) != 0)
    v7 = *(_QWORD *)(a1 + 24);
  if (v6 != v7)
  if (v8 >= 0)
    v9 = (unsigned __int8 *)(a1 + 16);
  else
    v9 = *(unsigned __int8 **)(a1 + 16);
  if ((v4 & 0x80) != 0)
  {
    if (!memcmp(*(const void **)a2, v9, v5))
      return 0;
  }
  if ((_DWORD)v4)
  {
    for (i = (unsigned __int8 *)a2; *i == *v9; ++i)
    {
      ++v9;
      if (!--v4)
        return 0;
    }
  }
  return 0;
}

void sub_1A1515BA0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1515C30(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1515C7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A1515D14(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1515DAC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1515F7C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_1A1516204(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A1516454(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1516560(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15165FC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1516AFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  void *v16;
  void *v17;
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

void sub_1A1517D6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, void *a14, uint64_t a15, void *a16, id *a17, id *a18, void *a19, void *a20,void *a21,void *a22,void *a23,void *a24,void *a25,void *a26,void *a27,void *a28,void *a29,uint64_t a30,uint64_t a31,void *a32,void *a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,uint64_t a41,id *a42,uint64_t a43,void *a44)
{

  objc_destroyWeak(a18);
  objc_destroyWeak(a17);

  _Block_object_dispose(&STACK[0x4B0], 8);
  _Block_object_dispose(&STACK[0x4D0], 8);

  _Block_object_dispose(&STACK[0x500], 8);
  objc_destroyWeak((id *)&STACK[0x530]);
  _Block_object_dispose(&STACK[0x538], 8);
  _Block_object_dispose(&STACK[0x570], 8);

  _Unwind_Resume(a1);
}

void sub_1A1518448(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A15184B0()
{
  JUMPOUT(0x1A15184A4);
}

void sub_1A1518684(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,id a30)
{
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  uint64_t v34;

  _Block_object_dispose(&a25, 8);
  _Block_object_dispose((const void *)(v34 - 160), 8);

  _Unwind_Resume(a1);
}

void sub_1A1518B28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,void *a25,void *a26,void *a27,void *a28,void *a29,void *a30,void *a31,void *a32,void *a33,void *a34,void *a35,void *a36,void *a37,void *a38)
{
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;

  _Unwind_Resume(a1);
}

void sub_1A1519130(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,id a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,id a30)
{
  void *v30;
  void *v31;
  void *v32;

  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table((uint64_t)&a13);

  _Block_object_dispose(&a25, 8);
  _Unwind_Resume(a1);
}

void sub_1A1519368(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  void *v3;
  va_list va;

  va_start(va, a3);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)va);

  _Unwind_Resume(a1);
}

void sub_1A1519890(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
  void *v18;
  void *v19;
  void *v20;

  if (a17 < 0)
    operator delete(__p);
  __p = &a18;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);

  _Unwind_Resume(a1);
}

void sub_1A15199BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_1A1519A5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_1A1519AFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void std::default_delete<vision::mod::ImageAnalyzer_PCA>::operator()[abi:ne180100](uint64_t a1)
{
  void *v2;

  v2 = *(void **)a1;
  if (v2)
  {
    *(_QWORD *)(a1 + 8) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x1A1B0A898);
}

void sub_1A1519D84(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id _knownIdentifiersForCustomClassifier(vision::mod::ImageAnalyzer_CustomClassifier *a1, __int128 *a2)
{
  std::string *v2;
  void *v3;
  id v4;
  void *v5;
  std::string::size_type i;
  std::string::size_type size;
  id v8;
  std::string::size_type v9;
  NSString *v10;
  std::string v12;
  std::string *v13;

  memset(&v12, 0, sizeof(v12));
  v2 = std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(&v12, (__int128 *)a1, a2, 0xAAAAAAAAAAAAAAABLL * (((char *)a2 - (char *)a1) >> 3));
  v3 = (void *)MEMORY[0x1A1B0B060](v2);
  v4 = objc_alloc(MEMORY[0x1E0C99DE8]);
  v5 = (void *)objc_msgSend(v4, "initWithCapacity:", 0xAAAAAAAAAAAAAAABLL* ((uint64_t)(v12.__r_.__value_.__l.__size_ - v12.__r_.__value_.__r.__words[0]) >> 3));
  size = v12.__r_.__value_.__l.__size_;
  for (i = v12.__r_.__value_.__r.__words[0]; i != size; i += 24)
  {
    v8 = objc_alloc(MEMORY[0x1E0CB3940]);
    v9 = i;
    if (*(char *)(i + 23) < 0)
      v9 = *(_QWORD *)i;
    v10 = (NSString *)objc_msgSend(v8, "initWithUTF8String:", v9);
    if (_isAcceptableClassificationIdentifier(v10, 0))
      objc_msgSend(v5, "addObject:", v10);

  }
  objc_autoreleasePoolPop(v3);
  v13 = &v12;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v13);
  return v5;
}

void sub_1A1519E90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t _isAcceptableClassificationIdentifier(NSString *a1, VNDisallowedList *a2)
{
  NSString *v3;
  VNDisallowedList *v4;
  uint64_t v5;

  v3 = a1;
  v4 = a2;
  if (-[NSString hasPrefix:](v3, "hasPrefix:", CFSTR("CVML_UNKNOWN_")))
    v5 = 0;
  else
    v5 = -[VNDisallowedList containsIdentifier:](v4, "containsIdentifier:", v3) ^ 1;

  return v5;
}

void sub_1A1519F34(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A151B3E8(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    if (SLOBYTE(STACK[0x277]) < 0)
      operator delete((void *)STACK[0x260]);
    if (SLOBYTE(STACK[0x297]) < 0)
      operator delete((void *)STACK[0x280]);
    if (SLOBYTE(STACK[0x2D7]) < 0)
      JUMPOUT(0x1A151B454);
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1A151B45C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55)
{
  std::unique_ptr<vision::mod::ImageAnalyzer_CustomClassifier>::reset[abi:ne180100]((vision::mod::ImageAnalyzer_CustomClassifier **)&STACK[0x2A0]);
  vision::mod::ImageAnalyzer_CustomClassifierOptions::~ImageAnalyzer_CustomClassifierOptions(&a55);
  JUMPOUT(0x1A151B470);
}

void sub_1A151B4BC(_Unwind_Exception *a1, int a2)
{
  if (a2)
    JUMPOUT(0x1A151B4C4);
  _Unwind_Resume(a1);
}

vision::mod::ImageAnalyzer_CustomClassifier *std::unique_ptr<vision::mod::ImageAnalyzer_CustomClassifier>::reset[abi:ne180100](vision::mod::ImageAnalyzer_CustomClassifier **a1)
{
  vision::mod::ImageAnalyzer_CustomClassifier *result;

  result = *a1;
  *a1 = 0;
  if (result)
  {
    vision::mod::ImageAnalyzer_CustomClassifier::~ImageAnalyzer_CustomClassifier(result);
    JUMPOUT(0x1A1B0A898);
  }
  return result;
}

void std::__shared_ptr_pointer<vision::mod::ImageAnalyzer_CustomClassifier  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A1B0A898);
}

vision::mod::ImageAnalyzer_CustomClassifier *std::__shared_ptr_pointer<vision::mod::ImageAnalyzer_CustomClassifier  *>::__on_zero_shared(uint64_t a1)
{
  vision::mod::ImageAnalyzer_CustomClassifier *result;

  result = *(vision::mod::ImageAnalyzer_CustomClassifier **)(a1 + 24);
  if (result)
  {
    vision::mod::ImageAnalyzer_CustomClassifier::~ImageAnalyzer_CustomClassifier(result);
    JUMPOUT(0x1A1B0A898);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<vision::mod::ImageAnalyzer_CustomClassifier  *>::__get_deleter(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"NSt3__114default_deleteIN6vision3mod30ImageAnalyzer_CustomClassifierEEE"))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1A151B6C8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A151B7F4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A151BB80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void std::vector<std::shared_ptr<vision::mod::ImageAnalyzer_CustomClassifier>>::push_back[abi:ne180100](char **a1, __int128 *a2)
{
  unint64_t v4;
  char *v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  char *v9;
  char *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  __int128 v17;
  unint64_t *v18;
  unint64_t v19;
  char *v20;
  __int128 v21;
  int64x2_t v22;
  uint64_t v23;
  void *v24;

  v5 = a1[1];
  v4 = (unint64_t)a1[2];
  if ((unint64_t)v5 >= v4)
  {
    v10 = *a1;
    v11 = (v5 - *a1) >> 4;
    v12 = v11 + 1;
    if ((unint64_t)(v11 + 1) >> 60)
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    v13 = v4 - (_QWORD)v10;
    if (v13 >> 3 > v12)
      v12 = v13 >> 3;
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF0)
      v14 = 0xFFFFFFFFFFFFFFFLL;
    else
      v14 = v12;
    if (v14 >> 60)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v15 = (char *)operator new(16 * v14);
    v16 = &v15[16 * v11];
    v17 = *a2;
    *(_OWORD *)v16 = *a2;
    if (*((_QWORD *)&v17 + 1))
    {
      v18 = (unint64_t *)(*((_QWORD *)&v17 + 1) + 8);
      do
        v19 = __ldxr(v18);
      while (__stxr(v19 + 1, v18));
      v10 = *a1;
      v5 = a1[1];
    }
    if (v5 == v10)
    {
      v22 = vdupq_n_s64((unint64_t)v5);
      v20 = &v15[16 * v11];
    }
    else
    {
      v20 = &v15[16 * v11];
      do
      {
        v21 = *((_OWORD *)v5 - 1);
        v5 -= 16;
        *((_OWORD *)v20 - 1) = v21;
        v20 -= 16;
        *(_QWORD *)v5 = 0;
        *((_QWORD *)v5 + 1) = 0;
      }
      while (v5 != v10);
      v22 = *(int64x2_t *)a1;
    }
    v9 = v16 + 16;
    *a1 = v20;
    a1[1] = v16 + 16;
    a1[2] = &v15[16 * v14];
    v23 = v22.i64[1];
    v24 = (void *)v22.i64[0];
    while ((void *)v23 != v24)
      v23 = std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](v23 - 16);
    if (v24)
      operator delete(v24);
  }
  else
  {
    v6 = *((_QWORD *)a2 + 1);
    *(_QWORD *)v5 = *(_QWORD *)a2;
    *((_QWORD *)v5 + 1) = v6;
    if (v6)
    {
      v7 = (unint64_t *)(v6 + 8);
      do
        v8 = __ldxr(v7);
      while (__stxr(v8 + 1, v7));
    }
    v9 = v5 + 16;
  }
  a1[1] = v9;
}

void std::__shared_ptr_emplace<std::vector<std::shared_ptr<vision::mod::ImageAnalyzer_CustomClassifier>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453BB88;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::vector<std::shared_ptr<vision::mod::ImageAnalyzer_CustomClassifier>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453BB88;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A1B0A898);
}

void std::__shared_ptr_emplace<std::vector<std::shared_ptr<vision::mod::ImageAnalyzer_CustomClassifier>>>::__on_zero_shared(uint64_t a1)
{
  void *v1;
  uint64_t v3;
  void *v4;

  v1 = *(void **)(a1 + 24);
  if (v1)
  {
    v3 = *(_QWORD *)(a1 + 32);
    v4 = v1;
    if ((void *)v3 != v1)
    {
      do
        v3 = std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](v3 - 16);
      while ((void *)v3 != v1);
      v4 = *(void **)(a1 + 24);
    }
    *(_QWORD *)(a1 + 32) = v1;
    operator delete(v4);
  }
}

uint64_t __Block_byref_object_copy__23953(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__23954(uint64_t a1)
{

}

void sub_1A151BE14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A151F4D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21,void *a22,void *a23,void *a24)
{
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;

  _Unwind_Resume(a1);
}

void sub_1A151F648(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A151F7D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,void *a34)
{
  void *v34;
  void *v35;
  void *v36;

  free(a32);
  free(a34);

  _Unwind_Resume(a1);
}

void sub_1A1521624(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,void *a34,char a35)
{

  std::__hash_table<std::__hash_value_type<std::string,std::vector<float>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<float>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<float>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<float>>>>::~__hash_table((uint64_t)&a35);
  _Unwind_Resume(a1);
}

void sub_1A1521B4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  void *v5;
  void *v6;
  void *v7;
  uint64_t v8;
  void **v10;
  va_list va;
  uint64_t v12;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v10 = va_arg(va1, void **);
  v12 = va_arg(va1, _QWORD);
  std::unique_ptr<std::vector<std::pair<std::string,float>>>::reset[abi:ne180100]((void ***)va);
  vision::mod::ImageAnalyzer_Tensor1D<float>::~ImageAnalyzer_Tensor1D((uint64_t)va1);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](v8 - 120);

  _Unwind_Resume(a1);
}

void sub_1A1521E78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  void *v5;
  void *v6;
  void *v7;
  uint64_t v8;
  void **v10;
  va_list va;
  uint64_t v12;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v10 = va_arg(va1, void **);
  v12 = va_arg(va1, _QWORD);
  std::unique_ptr<std::vector<std::pair<std::string,float>>>::reset[abi:ne180100]((void ***)va);
  vision::mod::ImageAnalyzer_Tensor1D<float>::~ImageAnalyzer_Tensor1D((uint64_t)va1);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](v8 - 120);

  _Unwind_Resume(a1);
}

void sub_1A15221A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  void *v5;
  void *v6;
  void *v7;
  uint64_t v8;
  void **v10;
  va_list va;
  uint64_t v12;
  va_list va1;

  va_start(va1, a5);
  va_start(va, a5);
  v10 = va_arg(va1, void **);
  v12 = va_arg(va1, _QWORD);
  std::unique_ptr<std::vector<std::pair<std::string,float>>>::reset[abi:ne180100]((void ***)va);
  vision::mod::ImageAnalyzer_Tensor1D<float>::~ImageAnalyzer_Tensor1D((uint64_t)va1);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](v8 - 120);

  _Unwind_Resume(a1);
}

void sub_1A1522590(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{

  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(uint64_t a1, unsigned __int8 *a2, __int128 **a3)
{
  unint64_t v3;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  unint64_t v11;
  void **v12;
  void *i;
  unint64_t v14;
  _QWORD *v15;
  __int128 *v16;
  __int128 v17;
  float v18;
  float v19;
  _BOOL8 v20;
  unint64_t v21;
  unint64_t v22;
  size_t v23;
  uint64_t v24;
  _QWORD *v25;
  unint64_t v26;
  _QWORD v28[2];
  char v29;

  v7 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)a2);
  v8 = v7;
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      v3 = v7;
      if (v7 >= v9)
        v3 = v7 % v9;
    }
    else
    {
      v3 = (v9 - 1) & v7;
    }
    v12 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v12)
    {
      for (i = *v12; i; i = *(void **)i)
      {
        v14 = *((_QWORD *)i + 1);
        if (v14 == v8)
        {
          if (std::equal_to<std::string>::operator()[abi:ne180100]((unsigned __int8 *)i + 16, a2))
            return i;
        }
        else
        {
          if (v11 > 1)
          {
            if (v14 >= v9)
              v14 %= v9;
          }
          else
          {
            v14 &= v9 - 1;
          }
          if (v14 != v3)
            break;
        }
      }
    }
  }
  v15 = (_QWORD *)(a1 + 16);
  i = operator new(0x40uLL);
  v28[0] = i;
  v28[1] = a1 + 16;
  *(_QWORD *)i = 0;
  *((_QWORD *)i + 1) = v8;
  v16 = *a3;
  v17 = **a3;
  *((_QWORD *)i + 4) = *((_QWORD *)*a3 + 2);
  *((_OWORD *)i + 1) = v17;
  *((_QWORD *)v16 + 1) = 0;
  *((_QWORD *)v16 + 2) = 0;
  *(_QWORD *)v16 = 0;
  *((_QWORD *)i + 6) = 0;
  *((_QWORD *)i + 7) = 0;
  *((_QWORD *)i + 5) = 0;
  v29 = 1;
  v18 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v19 = *(float *)(a1 + 32);
  if (!v9 || (float)(v19 * (float)v9) < v18)
  {
    v20 = 1;
    if (v9 >= 3)
      v20 = (v9 & (v9 - 1)) != 0;
    v21 = v20 | (2 * v9);
    v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22)
      v23 = v22;
    else
      v23 = v21;
    std::__hash_table<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},espresso_buffer_t>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},espresso_buffer_t>>>::__rehash<true>(a1, v23);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
  }
  v24 = *(_QWORD *)a1;
  v25 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v25)
  {
    *(_QWORD *)i = *v25;
LABEL_38:
    *v25 = i;
    goto LABEL_39;
  }
  *(_QWORD *)i = *v15;
  *v15 = i;
  *(_QWORD *)(v24 + 8 * v3) = v15;
  if (*(_QWORD *)i)
  {
    v26 = *(_QWORD *)(*(_QWORD *)i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v26 >= v9)
        v26 %= v9;
    }
    else
    {
      v26 &= v9 - 1;
    }
    v25 = (_QWORD *)(*(_QWORD *)a1 + 8 * v26);
    goto LABEL_38;
  }
LABEL_39:
  v28[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,void *>>>>::reset[abi:ne180100]((uint64_t)v28);
  return i;
}

void sub_1A15228B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::tuple<float,_Geometry2D_rect2D_>>>,void *>>>>::reset[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A1522C6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;

  if (a2)
  {

    objc_begin_catch(exception_object);
    JUMPOUT(0x1A1522BE0);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A1522EB8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1522FE4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1523338(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20,void *a21)
{
  void *v21;
  void *v22;
  void *v23;

  _Unwind_Resume(a1);
}

void sub_1A15234B0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1523A70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20)
{
  void *v20;
  void *v21;
  uint64_t v22;

  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](v22 - 128);
  _Unwind_Resume(a1);
}

void sub_1A1523DDC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  va_list va1;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  va_list va2;

  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v10 = va_arg(va2, _QWORD);
  v12 = va_arg(va2, _QWORD);
  v13 = va_arg(va2, _QWORD);
  v14 = va_arg(va2, _QWORD);
  v15 = va_arg(va2, _QWORD);
  v16 = va_arg(va2, _QWORD);

  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table((uint64_t)va);
  std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::~__hash_table((uint64_t)va1);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)va2);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_72c74_ZTSNSt3__110shared_ptrIN6vision3mod33ImageClassifier_HierarchicalModelEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(result + 72) = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(result + 80) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_ea8_72c74_ZTSNSt3__110shared_ptrIN6vision3mod33ImageClassifier_HierarchicalModelEEE(uint64_t a1)
{
  return std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](a1 + 72);
}

void sub_1A1524330(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, os_unfair_lock_s *a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,void *__p,uint64_t a27,uint64_t a28,char *a29)
{
  a29 = &a13;
  std::vector<std::pair<std::string,BOOL>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a29);
  objc_begin_catch(a1);
  os_unfair_lock_unlock(a11 + 66);
  objc_exception_rethrow();
}

void sub_1A15243FC(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<std::vector<std::tuple<std::string,float,BOOL>> const,std::allocator<std::vector<std::tuple<std::string,float,BOOL>> const>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453B370;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::vector<std::tuple<std::string,float,BOOL>> const,std::allocator<std::vector<std::tuple<std::string,float,BOOL>> const>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453B370;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A1B0A898);
}

void std::__shared_ptr_emplace<std::vector<std::tuple<std::string,float,BOOL>> const,std::allocator<std::vector<std::tuple<std::string,float,BOOL>> const>>::__on_zero_shared(uint64_t a1)
{
  void **v1;

  v1 = (void **)(a1 + 24);
  std::vector<std::pair<std::string,BOOL>>::__destroy_vector::operator()[abi:ne180100](&v1);
}

void sub_1A1524510(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1524748(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__312(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 48) = *(_DWORD *)(a2 + 48);
  return result;
}

void sub_1A1524984(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1524C6C()
{
  __break(1u);
}

void sub_1A1524CC0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20)
{
  void *v20;
  void *v21;

  objc_end_catch();

  JUMPOUT(0x1A1524D0CLL);
}

void sub_1A1524F30(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15251F0()
{
  __break(1u);
}

void sub_1A1525214(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, uint64_t a17, void *a18, void *a19, void *a20,void *a21)
{
  void *v21;
  void *v22;

  objc_end_catch();

  JUMPOUT(0x1A1525290);
}

void sub_1A1525228(void *a1)
{
  void *v1;
  void *v2;

  objc_begin_catch(a1);
  JUMPOUT(0x1A15251B4);
}

void sub_1A1525234(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A15254BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, uint64_t a17, void *a18, void *a19, void *a20)
{
  void *v20;
  uint64_t v21;

  _Block_object_dispose((const void *)(v21 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_1A1525750(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void _recordBestClassificationObservations(void *a1, void *a2)
{
  id v3;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t i;
  void *v8;
  void *v9;
  void *v10;
  float v11;
  float v12;
  float v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  _BYTE v18[128];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  v17 = 0u;
  v4 = a2;
  v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v14, v18, 16);
  if (v5)
  {
    v6 = *(_QWORD *)v15;
    do
    {
      for (i = 0; i != v5; ++i)
      {
        if (*(_QWORD *)v15 != v6)
          objc_enumerationMutation(v4);
        v8 = *(void **)(*((_QWORD *)&v14 + 1) + 8 * i);
        objc_msgSend(v8, "identifier", (_QWORD)v14);
        v9 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v3, "objectForKeyedSubscript:", v9);
        v10 = (void *)objc_claimAutoreleasedReturnValue();
        if (!v10 || (objc_msgSend(v8, "confidence"), v12 = v11, objc_msgSend(v10, "confidence"), v12 > v13))
          objc_msgSend(v3, "setObject:forKeyedSubscript:", v8, v9);

      }
      v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v14, v18, 16);
    }
    while (v5);
  }

}

void sub_1A1525958(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1525A8C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1525B1C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1525D3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, void *a17, void *a18, void *a19)
{
  void *v19;

  _Unwind_Resume(a1);
}

void _configureImageAnalyzerOptionsForSceneNetV3ObjDetNet(vision::mod::ImageAnalyzer_Options *a1)
{
  _QWORD *v2;
  int32x2_t *v3;
  _QWORD *v4;
  _QWORD *v5;
  int32x2_t *v6;
  _QWORD *v7;
  _QWORD *v8;
  int32x2_t *v9;
  _QWORD *v10;
  _QWORD *v11;
  int32x2_t *v12;
  _QWORD *v13;
  _QWORD *v14;
  int32x2_t *v15;
  _QWORD *v16;
  _QWORD *v17;
  int32x2_t *v18;
  _QWORD *v19;
  _QWORD *v20;
  int32x2_t *v21;
  _QWORD *v22;
  _QWORD *v23;
  int32x2_t *v24;
  _QWORD *v25;
  _QWORD *v26;
  int32x2_t *v27;
  _QWORD *v28;
  _QWORD *v29;
  int32x2_t *v30;
  _QWORD *v31;
  _QWORD *v32;
  int32x2_t *v33;
  _QWORD *v34;
  _QWORD *v35;
  int32x2_t *v36;
  _QWORD *v37;
  _QWORD *v38;
  uint64_t *v39;
  unint64_t v40;
  unint64_t v41;
  _QWORD *v42;
  uint64_t *v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t *v46;
  uint64_t i;
  void **v48;
  void **v49;
  uint64_t j;
  uint64_t k;
  _QWORD *v52;
  uint64_t m;
  _QWORD *v54;
  uint64_t n;
  _QWORD *v56;
  uint64_t ii;
  void *v58;
  unint64_t v59;
  char *v60;
  uint64_t v61;
  unint64_t v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  unint64_t v66;
  char *v67;
  char *v68;
  uint64_t v69;
  char *v70;
  char *v71;
  _QWORD *v72;
  _QWORD *v73;
  __int128 v74;
  _QWORD *v75;
  char *v76;
  uint64_t v77;
  unint64_t v78;
  void *v79;
  uint64_t v80;
  char v81;
  char *v82;
  uint64_t v83;
  _QWORD *v84;
  int v85;
  size_t v86;
  __int128 *v87;
  const void *p_p;
  uint64_t v89;
  __int128 v90;
  __int128 *v91;
  const void *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t **v95;
  void *v96;
  void **v97;
  char v98;
  void *v99;
  _QWORD *v100;
  _QWORD *v101;
  int32x2_t *v102;
  int32x2_t *v103;
  int32x2_t *v104;
  _QWORD *v105;
  _QWORD *v106;
  _QWORD *v107;
  void *v108;
  _QWORD *v109;
  _QWORD *v110;
  int32x2_t *v111;
  int32x2_t *v112;
  _QWORD v113[10];
  _QWORD *v114;
  _QWORD v115[2];
  uint64_t v116;
  _QWORD **v117;
  _QWORD *v118;
  _QWORD *v119;
  int32x2_t *v120;
  int32x2_t *v121;
  int32x2_t *v122;
  _QWORD *v123;
  _QWORD *v124;
  _QWORD *v125;
  _QWORD *v126;
  _QWORD *v127;
  _QWORD *v128;
  int32x2_t *v129;
  int32x2_t *v130;
  int32x2_t *v131;
  _QWORD *v132;
  _QWORD *v133;
  _QWORD *v134;
  _QWORD *v135;
  _QWORD *v136;
  _QWORD *v137;
  int32x2_t *v138;
  int32x2_t *v139;
  int32x2_t *v140;
  _QWORD *v141;
  _QWORD *v142;
  _QWORD *v143;
  __int128 v144;
  _QWORD *v145;
  int32x2_t *v146;
  int32x2_t *v147;
  int32x2_t *v148;
  _QWORD *v149;
  _QWORD *v150;
  _QWORD *v151;
  _QWORD *v152;
  _QWORD *v153;
  _QWORD *v154;
  int32x2_t *v155;
  int32x2_t *v156;
  int32x2_t *v157;
  _QWORD *v158;
  _QWORD *v159;
  _QWORD *v160;
  _QWORD *v161;
  _QWORD *v162;
  _QWORD *v163;
  int32x2_t *v164;
  int32x2_t *v165;
  int32x2_t *v166;
  _QWORD *v167;
  _QWORD *v168;
  _QWORD *v169;
  void *__p;
  _QWORD *v171;
  _QWORD *v172;
  int32x2_t *v173;
  int32x2_t *v174;
  int32x2_t *v175;
  _QWORD *v176;
  _QWORD *v177;
  _QWORD *v178;
  _QWORD *v179;
  _QWORD *v180;
  _QWORD *v181;
  int32x2_t *v182;
  int32x2_t *v183;
  int32x2_t *v184;
  _QWORD *v185;
  _QWORD *v186;
  _QWORD *v187;
  _QWORD *v188;
  _QWORD *v189;
  _QWORD *v190;
  int32x2_t *v191;
  int32x2_t *v192;
  int32x2_t *v193;
  _QWORD *v194;
  _QWORD *v195;
  _QWORD *v196;
  _QWORD *v197;
  _QWORD *v198;
  _QWORD *v199;
  _QWORD *v200;
  _QWORD *v201;
  _QWORD *v202;
  _QWORD *v203;
  _QWORD *v204;
  _QWORD *v205;
  _QWORD *v206;
  _QWORD *v207;
  _QWORD *v208;
  uint64_t v209[2];

  v209[0] = *MEMORY[0x1E0C80C00];
  *((_DWORD *)a1 + 113) = 1065353216;
  *((_BYTE *)a1 + 461) = 0;
  *(_OWORD *)((char *)a1 + 424) = xmmword_1A15FB6F0;
  v2 = operator new(8uLL);
  v99 = v2;
  *v2 = 0x3DA05BC03E1B3D08;
  v100 = v2 + 1;
  v101 = v2 + 1;
  v3 = (int32x2_t *)operator new(8uLL);
  v102 = v3;
  *v3 = vdup_n_s32(0x3DD70A3Du);
  v103 = v3 + 1;
  v104 = v3 + 1;
  v4 = operator new(8uLL);
  v105 = v4;
  *v4 = 0x3E147AE13D92A305;
  v106 = v4 + 1;
  v107 = v4 + 1;
  v5 = operator new(8uLL);
  v108 = v5;
  *v5 = 0x3DCAF4F13E441893;
  v109 = v5 + 1;
  v110 = v5 + 1;
  v6 = (int32x2_t *)operator new(8uLL);
  v111 = v6;
  *v6 = vdup_n_s32(0x3E07E282u);
  v112 = v6 + 1;
  v113[0] = v6 + 1;
  v7 = operator new(8uLL);
  v113[1] = v7;
  *v7 = 0x3E3B7E913DB9C0ECLL;
  v113[2] = v7 + 1;
  v113[3] = v7 + 1;
  v8 = operator new(8uLL);
  v113[4] = v8;
  *v8 = 0x3E004EA53E778034;
  v113[5] = v8 + 1;
  v113[6] = v8 + 1;
  v9 = (int32x2_t *)operator new(8uLL);
  v113[7] = v9;
  *v9 = vdup_n_s32(0x3E2B9F56u);
  v113[8] = v9 + 1;
  v113[9] = v9 + 1;
  v10 = operator new(8uLL);
  v114 = v10;
  *v10 = 0x3E6CA57A3DEAE7D5;
  v115[0] = v10 + 1;
  v115[1] = v10 + 1;
  v198 = 0;
  v199 = 0;
  v197 = 0;
  __p = &v197;
  LOBYTE(v171) = 0;
  v197 = operator new(0xD8uLL);
  v198 = v197;
  v199 = v197 + 27;
  v198 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float> const*,std::vector<float> const*,std::vector<float>*>((uint64_t)&v199, (uint64_t)&v99, (uint64_t)&v116, v197);
  v11 = operator new(8uLL);
  __p = v11;
  *v11 = 0x3E147AE13E98BAC7;
  v172 = v11 + 1;
  v171 = v11 + 1;
  v173 = 0;
  v175 = 0;
  v174 = 0;
  v12 = (int32x2_t *)operator new(8uLL);
  v173 = v12;
  *v12 = vdup_n_s32(0x3E58ADACu);
  v175 = v12 + 1;
  v174 = v12 + 1;
  v176 = 0;
  v178 = 0;
  v177 = 0;
  v13 = operator new(8uLL);
  v176 = v13;
  *v13 = 0x3E9C28F63E1B3D08;
  v178 = v13 + 1;
  v177 = v13 + 1;
  v179 = 0;
  v181 = 0;
  v180 = 0;
  v14 = operator new(8uLL);
  v179 = v14;
  *v14 = 0x3E3B7E913EC0AA65;
  v181 = v14 + 1;
  v180 = v14 + 1;
  v182 = 0;
  v184 = 0;
  v183 = 0;
  v15 = (int32x2_t *)operator new(8uLL);
  v182 = v15;
  *v15 = vdup_n_s32(0x3E88C155u);
  v184 = v15 + 1;
  v183 = v15 + 1;
  v185 = 0;
  v187 = 0;
  v186 = 0;
  v16 = operator new(8uLL);
  v185 = v16;
  *v16 = 0x3EC4F7663E441893;
  v187 = v16 + 1;
  v186 = v16 + 1;
  v188 = 0;
  v190 = 0;
  v189 = 0;
  v17 = operator new(8uLL);
  v188 = v17;
  *v17 = 0x3E6CA57A3EF2F1AALL;
  v190 = v17 + 1;
  v189 = v17 + 1;
  v191 = 0;
  v193 = 0;
  v192 = 0;
  v18 = (int32x2_t *)operator new(8uLL);
  v191 = v18;
  *v18 = vdup_n_s32(0x3EAC7E28u);
  v193 = v18 + 1;
  v192 = v18 + 1;
  v194 = 0;
  v196 = 0;
  v195 = 0;
  v19 = operator new(8uLL);
  v194 = v19;
  *v19 = 0x3EF85F073E778034;
  v196 = v19 + 1;
  v195 = v19 + 1;
  v201 = 0;
  v202 = 0;
  v200 = 0;
  *(_QWORD *)&v144 = &v200;
  BYTE8(v144) = 0;
  v200 = operator new(0xD8uLL);
  v201 = v200;
  v202 = v200 + 27;
  v201 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float> const*,std::vector<float> const*,std::vector<float>*>((uint64_t)&v202, (uint64_t)&__p, (uint64_t)&v197, v200);
  v20 = operator new(8uLL);
  *(_QWORD *)&v144 = v20;
  *v20 = 0x3E9C28F63F1AE148;
  v145 = v20 + 1;
  *((_QWORD *)&v144 + 1) = v20 + 1;
  v146 = 0;
  v148 = 0;
  v147 = 0;
  v21 = (int32x2_t *)operator new(8uLL);
  v146 = v21;
  *v21 = vdup_n_s32(0x3ED9999Au);
  v148 = v21 + 1;
  v147 = v21 + 1;
  v149 = 0;
  v151 = 0;
  v150 = 0;
  v22 = operator new(8uLL);
  v149 = v22;
  *v22 = 0x3F192A303E98BAC7;
  v151 = v22 + 1;
  v150 = v22 + 1;
  v152 = 0;
  v154 = 0;
  v153 = 0;
  v23 = operator new(8uLL);
  v152 = v23;
  *v23 = 0x3EC4F7663F4339C1;
  v154 = v23 + 1;
  v153 = v23 + 1;
  v155 = 0;
  v157 = 0;
  v156 = 0;
  v24 = (int32x2_t *)operator new(8uLL);
  v155 = v24;
  *v24 = vdup_n_s32(0x3F092A30u);
  v157 = v24 + 1;
  v156 = v24 + 1;
  v158 = 0;
  v160 = 0;
  v159 = 0;
  v25 = operator new(8uLL);
  v158 = v25;
  *v25 = 0x3F4113403EC0AA65;
  v160 = v25 + 1;
  v159 = v25 + 1;
  v161 = 0;
  v163 = 0;
  v162 = 0;
  v26 = operator new(8uLL);
  v161 = v26;
  *v26 = 0x3EF85F073F7617C2;
  v163 = v26 + 1;
  v162 = v26 + 1;
  v164 = 0;
  v166 = 0;
  v165 = 0;
  v27 = (int32x2_t *)operator new(8uLL);
  v164 = v27;
  *v27 = vdup_n_s32(0x3F2CF41Fu);
  v166 = v27 + 1;
  v165 = v27 + 1;
  v167 = 0;
  v169 = 0;
  v168 = 0;
  v28 = operator new(8uLL);
  v167 = v28;
  *v28 = 0x3F7361133EF2F1AALL;
  v169 = v28 + 1;
  v168 = v28 + 1;
  v204 = 0;
  v205 = 0;
  v203 = 0;
  v117 = &v203;
  LOBYTE(v118) = 0;
  v203 = operator new(0xD8uLL);
  v204 = v203;
  v205 = v203 + 27;
  v204 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float> const*,std::vector<float> const*,std::vector<float>*>((uint64_t)&v205, (uint64_t)&v144, (uint64_t)&__p, v203);
  v29 = operator new(8uLL);
  v117 = (_QWORD **)v29;
  *v29 = 0x3F192A303F9A3D71;
  v118 = v29 + 1;
  v119 = v29 + 1;
  v120 = 0;
  v121 = 0;
  v122 = 0;
  v30 = (int32x2_t *)operator new(8uLL);
  v120 = v30;
  *v30 = vdup_n_s32(0x3F5A0275u);
  v121 = v30 + 1;
  v122 = v30 + 1;
  v123 = 0;
  v124 = 0;
  v125 = 0;
  v31 = operator new(8uLL);
  v123 = v31;
  *v31 = 0x3F9B15B53F1AE148;
  v124 = v31 + 1;
  v125 = v31 + 1;
  v126 = 0;
  v127 = 0;
  v128 = 0;
  v32 = operator new(8uLL);
  v126 = v32;
  *v32 = 0x3F4113403FC2617CLL;
  v127 = v32 + 1;
  v128 = v32 + 1;
  v129 = 0;
  v130 = 0;
  v131 = 0;
  v33 = (int32x2_t *)operator new(8uLL);
  v129 = v33;
  *v33 = vdup_n_s32(0x3F89652Cu);
  v130 = v33 + 1;
  v131 = v33 + 1;
  v132 = 0;
  v133 = 0;
  v134 = 0;
  v34 = operator new(8uLL);
  v132 = v34;
  *v34 = 0x3FC374BC3F4339C1;
  v133 = v34 + 1;
  v134 = v34 + 1;
  v135 = 0;
  v136 = 0;
  v137 = 0;
  v35 = operator new(8uLL);
  v135 = v35;
  *v35 = 0x3F7361133FF4F41FLL;
  v136 = v35 + 1;
  v137 = v35 + 1;
  v138 = 0;
  v139 = 0;
  v140 = 0;
  v36 = (int32x2_t *)operator new(8uLL);
  v138 = v36;
  *v36 = vdup_n_s32(0x3FAD2BD4u);
  v139 = v36 + 1;
  v140 = v36 + 1;
  v141 = 0;
  v142 = 0;
  v143 = 0;
  v37 = operator new(8uLL);
  v141 = v37;
  *v37 = 0x3FF64F763F7617C2;
  v143 = v37 + 1;
  v142 = v37 + 1;
  v207 = 0;
  v208 = 0;
  v206 = 0;
  v97 = (void **)&v206;
  v98 = 0;
  v206 = operator new(0xD8uLL);
  v207 = v206;
  v208 = v206 + 27;
  v207 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float> const*,std::vector<float> const*,std::vector<float>*>((uint64_t)&v208, (uint64_t)&v117, (uint64_t)&v144, v206);
  v38 = (_QWORD *)((char *)a1 + 552);
  v39 = (uint64_t *)*((_QWORD *)a1 + 67);
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)a1 + 69) - (_QWORD)v39) >> 3) < 4)
  {
    std::vector<std::vector<std::vector<float>>>::__vdeallocate((void ***)a1 + 67);
    v40 = 0x5555555555555556 * ((uint64_t)(*v38 - *((_QWORD *)a1 + 67)) >> 3);
    if (v40 <= 4)
      v40 = 4;
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*v38 - *((_QWORD *)a1 + 67)) >> 3) >= 0x555555555555555)
      v41 = 0xAAAAAAAAAAAAAAALL;
    else
      v41 = v40;
    std::vector<std::vector<std::vector<float>>>::__vallocate[abi:ne180100]((_QWORD *)a1 + 67, v41);
    v42 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<std::vector<float>>>,std::vector<std::vector<float>> const*,std::vector<std::vector<float>> const*,std::vector<std::vector<float>>*>((uint64_t)a1 + 552, (uint64_t *)&v197, v209, *((_QWORD **)a1 + 68));
LABEL_16:
    *((_QWORD *)a1 + 68) = v42;
    goto LABEL_25;
  }
  v43 = (uint64_t *)*((_QWORD *)a1 + 68);
  v44 = 0xAAAAAAAAAAAAAAABLL * (v43 - v39);
  if (v44 < 4)
  {
    if (v43 != v39)
    {
      v45 = 8 * (v43 - v39);
      v46 = (uint64_t *)&v197;
      do
      {
        if (v46 != v39)
          std::vector<std::vector<float>>::__assign_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(v39, *v46, v46[1], 0xAAAAAAAAAAAAAAABLL * ((v46[1] - *v46) >> 3));
        v46 += 3;
        v39 += 3;
        v45 -= 24;
      }
      while (v45);
      v39 = (uint64_t *)*((_QWORD *)a1 + 68);
    }
    v42 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<std::vector<float>>>,std::vector<std::vector<float>> const*,std::vector<std::vector<float>> const*,std::vector<std::vector<float>>*>((uint64_t)a1 + 552, (uint64_t *)&(&v197)[3 * v44], v209, v39);
    goto LABEL_16;
  }
  for (i = 0; i != 12; i += 3)
  {
    if (&v197 != (_QWORD **)v39)
      std::vector<std::vector<float>>::__assign_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(&v39[i], (uint64_t)(&v197)[i], (uint64_t)(&v197)[i + 1], 0xAAAAAAAAAAAAAAABLL * ((&v197)[i + 1] - (&v197)[i]));
  }
  v48 = (void **)(v39 + 12);
  v49 = (void **)*((_QWORD *)a1 + 68);
  while (v49 != v48)
  {
    v49 -= 3;
    v97 = v49;
    std::vector<std::vector<long long>>::__destroy_vector::operator()[abi:ne180100](&v97);
  }
  *((_QWORD *)a1 + 68) = v48;
LABEL_25:
  for (j = 9; j != -3; j -= 3)
  {
    v97 = (void **)&(&v197)[j];
    std::vector<std::vector<long long>>::__destroy_vector::operator()[abi:ne180100](&v97);
  }
  for (k = 0; k != -27; k -= 3)
  {
    v52 = (&v141)[k];
    if (v52)
    {
      (&v142)[k] = v52;
      operator delete(v52);
    }
  }
  for (m = 0; m != -27; m -= 3)
  {
    v54 = (&v167)[m];
    if (v54)
    {
      (&v168)[m] = v54;
      operator delete(v54);
    }
  }
  for (n = 0; n != -27; n -= 3)
  {
    v56 = (&v194)[n];
    if (v56)
    {
      (&v195)[n] = v56;
      operator delete(v56);
    }
  }
  for (ii = 0; ii != -27; ii -= 3)
  {
    v58 = (void *)v115[ii - 1];
    if (v58)
    {
      v115[ii] = v58;
      operator delete(v58);
    }
  }
  v59 = *((_QWORD *)a1 + 54);
  v60 = (char *)*((_QWORD *)a1 + 65);
  v61 = *((_QWORD *)a1 + 64);
  v62 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v60[-v61] >> 3);
  v63 = v59 - v62;
  if (v59 > v62)
  {
    v64 = *((_QWORD *)a1 + 66);
    if (0xAAAAAAAAAAAAAAABLL * ((v64 - (uint64_t)v60) >> 3) >= v63)
    {
      bzero(*((void **)a1 + 65), 24 * ((24 * v63 - 24) / 0x18) + 24);
      *((_QWORD *)a1 + 65) = &v60[24 * ((24 * v63 - 24) / 0x18) + 24];
      goto LABEL_66;
    }
    if (v59 > 0xAAAAAAAAAAAAAAALL)
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    v65 = 0xAAAAAAAAAAAAAAABLL * ((v64 - v61) >> 3);
    if (2 * v65 > v59)
      v59 = 2 * v65;
    if (v65 >= 0x555555555555555)
      v66 = 0xAAAAAAAAAAAAAAALL;
    else
      v66 = v59;
    v67 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(v66);
    v68 = &v67[24 * v62];
    v70 = &v67[24 * v69];
    bzero(v68, 24 * ((24 * v63 - 24) / 0x18) + 24);
    v71 = &v68[24 * ((24 * v63 - 24) / 0x18) + 24];
    v72 = (_QWORD *)*((_QWORD *)a1 + 65);
    v73 = (_QWORD *)*((_QWORD *)a1 + 64);
    if (v72 == v73)
    {
      *((_QWORD *)a1 + 64) = v68;
      *((_QWORD *)a1 + 65) = v71;
      *((_QWORD *)a1 + 66) = v70;
      if (!v72)
        goto LABEL_66;
    }
    else
    {
      do
      {
        *((_QWORD *)v68 - 3) = 0;
        *((_QWORD *)v68 - 2) = 0;
        v68 -= 24;
        *((_QWORD *)v68 + 2) = 0;
        v74 = *(_OWORD *)(v72 - 3);
        v72 -= 3;
        *(_OWORD *)v68 = v74;
        *((_QWORD *)v68 + 2) = v72[2];
        *v72 = 0;
        v72[1] = 0;
        v72[2] = 0;
      }
      while (v72 != v73);
      v75 = (_QWORD *)*((_QWORD *)a1 + 64);
      v72 = (_QWORD *)*((_QWORD *)a1 + 65);
      *((_QWORD *)a1 + 64) = v68;
      *((_QWORD *)a1 + 65) = v71;
      *((_QWORD *)a1 + 66) = v70;
      if (v72 != v75)
      {
        do
        {
          v72 -= 3;
          v99 = v72;
          std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v99);
        }
        while (v72 != v75);
        v72 = v75;
      }
      if (!v72)
        goto LABEL_66;
    }
    operator delete(v72);
    goto LABEL_66;
  }
  if (v59 < v62)
  {
    v76 = (char *)(v61 + 24 * v59);
    while (v60 != v76)
    {
      v60 -= 24;
      v99 = v60;
      std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v99);
    }
    *((_QWORD *)a1 + 65) = v76;
  }
LABEL_66:
  if (*((_QWORD *)a1 + 54))
  {
    v77 = 0;
    v78 = 0;
    v79 = (void *)*MEMORY[0x1E0DE4F60];
    v96 = *(void **)(MEMORY[0x1E0DE4F60] + 24);
    v80 = MEMORY[0x1E0DE4FB8] + 16;
    do
    {
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v99);
      v81 = *((_BYTE *)a1 + 415);
      if (v81 >= 0)
        v82 = (char *)a1 + 392;
      else
        v82 = (char *)*((_QWORD *)a1 + 49);
      if (v81 >= 0)
        v83 = *((unsigned __int8 *)a1 + 415);
      else
        v83 = *((_QWORD *)a1 + 50);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v99, (uint64_t)v82, v83);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v99, (uint64_t)"_scale_", 7);
      v84 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v84, (uint64_t)"/", 1);
      std::stringbuf::str[abi:ne180100]<std::allocator<char>>(&__p, (uint64_t)&v100);
      std::vector<std::string>::resize((std::vector<std::string> *)(*((_QWORD *)a1 + 64) + v77), 2uLL);
      v85 = SHIBYTE(v172);
      if (SHIBYTE(v172) >= 0)
        v86 = HIBYTE(v172);
      else
        v86 = (size_t)v171;
      std::string::basic_string[abi:ne180100]((uint64_t)&v144, v86 + 7);
      if (SHIBYTE(v145) >= 0)
        v87 = &v144;
      else
        v87 = (__int128 *)v144;
      if (v86)
      {
        if (v85 >= 0)
          p_p = &__p;
        else
          p_p = __p;
        memmove(v87, p_p, v86);
      }
      strcpy((char *)v87 + v86, "offsets");
      v89 = *(_QWORD *)(*((_QWORD *)a1 + 64) + v77);
      if (*(char *)(v89 + 23) < 0)
        operator delete(*(void **)v89);
      v90 = v144;
      *(_QWORD *)(v89 + 16) = v145;
      *(_OWORD *)v89 = v90;
      std::string::basic_string[abi:ne180100]((uint64_t)&v144, v86 + 6);
      if (SHIBYTE(v145) >= 0)
        v91 = &v144;
      else
        v91 = (__int128 *)v144;
      if (v86)
      {
        if (v85 >= 0)
          v92 = &__p;
        else
          v92 = __p;
        memmove(v91, v92, v86);
      }
      strcpy((char *)v91 + v86, "scores");
      v93 = *(_QWORD *)(*((_QWORD *)a1 + 64) + v77);
      v94 = v93 + 24;
      if (*(char *)(v93 + 47) < 0)
        operator delete(*(void **)v94);
      *(_OWORD *)v94 = v144;
      *(_QWORD *)(v94 + 16) = v145;
      if (v85 < 0)
        operator delete(__p);
      v99 = v79;
      *(void **)((char *)&v99 + *((_QWORD *)v79 - 3)) = v96;
      v100 = (_QWORD *)v80;
      if (SHIBYTE(v110) < 0)
        operator delete(v108);
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      MEMORY[0x1A1B0A808](v113);
      ++v78;
      v77 += 24;
    }
    while (v78 < *((_QWORD *)a1 + 54));
  }
  *((_DWORD *)a1 + 104) = 30;
  std::string::basic_string[abi:ne180100]<0>(&v99, "aircraft");
  v95 = (uint64_t **)((char *)a1 + 560);
  __p = &v99;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v95, &v99, (_OWORD **)&__p)+ 14) = 1036831949;
  if (SHIBYTE(v101) < 0)
    operator delete(v99);
  std::string::basic_string[abi:ne180100]<0>(&v99, "automobile");
  __p = &v99;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v95, &v99, (_OWORD **)&__p)+ 14) = 1045556101;
  if (SHIBYTE(v101) < 0)
    operator delete(v99);
  std::string::basic_string[abi:ne180100]<0>(&v99, "bicycle");
  __p = &v99;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v95, &v99, (_OWORD **)&__p)+ 14) = 1045220557;
  if (SHIBYTE(v101) < 0)
    operator delete(v99);
  std::string::basic_string[abi:ne180100]<0>(&v99, "bird");
  __p = &v99;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v95, &v99, (_OWORD **)&__p)+ 14) = 1042536202;
  if (SHIBYTE(v101) < 0)
    operator delete(v99);
  std::string::basic_string[abi:ne180100]<0>(&v99, "bottle");
  __p = &v99;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v95, &v99, (_OWORD **)&__p)+ 14) = 1036831949;
  if (SHIBYTE(v101) < 0)
    operator delete(v99);
  std::string::basic_string[abi:ne180100]<0>(&v99, "bus");
  __p = &v99;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v95, &v99, (_OWORD **)&__p)+ 14) = 1045891645;
  if (SHIBYTE(v101) < 0)
    operator delete(v99);
  std::string::basic_string[abi:ne180100]<0>(&v99, "canine");
  __p = &v99;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v95, &v99, (_OWORD **)&__p)+ 14) = 1041865114;
  if (SHIBYTE(v101) < 0)
    operator delete(v99);
  std::string::basic_string[abi:ne180100]<0>(&v99, "consumer_electronics");
  __p = &v99;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v95, &v99, (_OWORD **)&__p)+ 14) = 1047233823;
  if (SHIBYTE(v101) < 0)
    operator delete(v99);
  std::string::basic_string[abi:ne180100]<0>(&v99, "feline");
  __p = &v99;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v95, &v99, (_OWORD **)&__p)+ 14) = 1043207291;
  if (SHIBYTE(v101) < 0)
    operator delete(v99);
  std::string::basic_string[abi:ne180100]<0>(&v99, "fruit");
  __p = &v99;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v95, &v99, (_OWORD **)&__p)+ 14) = 1041932222;
  if (SHIBYTE(v101) < 0)
    operator delete(v99);
  std::string::basic_string[abi:ne180100]<0>(&v99, "vegetable");
  __p = &v99;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v95, &v99, (_OWORD **)&__p)+ 14) = 1041932222;
  if (SHIBYTE(v101) < 0)
    operator delete(v99);
  std::string::basic_string[abi:ne180100]<0>(&v99, "furniture");
  __p = &v99;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v95, &v99, (_OWORD **)&__p)+ 14) = 1038174126;
  if (SHIBYTE(v101) < 0)
    operator delete(v99);
  std::string::basic_string[abi:ne180100]<0>(&v99, "headgear");
  __p = &v99;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v95, &v99, (_OWORD **)&__p)+ 14) = 1043207291;
  if (SHIBYTE(v101) < 0)
    operator delete(v99);
  std::string::basic_string[abi:ne180100]<0>(&v99, "kite");
  __p = &v99;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v95, &v99, (_OWORD **)&__p)+ 14) = 1045891645;
  if (SHIBYTE(v101) < 0)
    operator delete(v99);
  std::string::basic_string[abi:ne180100]<0>(&v99, "fish");
  __p = &v99;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v95, &v99, (_OWORD **)&__p)+ 14) = 1044549468;
  if (SHIBYTE(v101) < 0)
    operator delete(v99);
  std::string::basic_string[abi:ne180100]<0>(&v99, "seafood");
  __p = &v99;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v95, &v99, (_OWORD **)&__p)+ 14) = 1044549468;
  if (SHIBYTE(v101) < 0)
    operator delete(v99);
  std::string::basic_string[abi:ne180100]<0>(&v99, "computer_monitor");
  __p = &v99;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v95, &v99, (_OWORD **)&__p)+ 14) = 1042200658;
  if (SHIBYTE(v101) < 0)
    operator delete(v99);
  std::string::basic_string[abi:ne180100]<0>(&v99, "motorcycle");
  __p = &v99;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v95, &v99, (_OWORD **)&__p)+ 14) = 1045891645;
  if (SHIBYTE(v101) < 0)
    operator delete(v99);
  std::string::basic_string[abi:ne180100]<0>(&v99, "musical_instrument");
  __p = &v99;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v95, &v99, (_OWORD **)&__p)+ 14) = 1044019308;
  if (SHIBYTE(v101) < 0)
    operator delete(v99);
  std::string::basic_string[abi:ne180100]<0>(&v99, "document");
  __p = &v99;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v95, &v99, (_OWORD **)&__p)+ 14) = 1036831949;
  if (SHIBYTE(v101) < 0)
    operator delete(v99);
  std::string::basic_string[abi:ne180100]<0>(&v99, "people");
  __p = &v99;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v95, &v99, (_OWORD **)&__p)+ 14) = 1039784739;
  if (SHIBYTE(v101) < 0)
    operator delete(v99);
  std::string::basic_string[abi:ne180100]<0>(&v99, "food");
  __p = &v99;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v95, &v99, (_OWORD **)&__p)+ 14) = 1040187392;
  if (SHIBYTE(v101) < 0)
    operator delete(v99);
  std::string::basic_string[abi:ne180100]<0>(&v99, "sign");
  __p = &v99;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v95, &v99, (_OWORD **)&__p)+ 14) = 1041194025;
  if (SHIBYTE(v101) < 0)
    operator delete(v99);
  std::string::basic_string[abi:ne180100]<0>(&v99, "watersport");
  __p = &v99;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v95, &v99, (_OWORD **)&__p)+ 14) = 1045891645;
  if (SHIBYTE(v101) < 0)
    operator delete(v99);
  std::string::basic_string[abi:ne180100]<0>(&v99, "train");
  __p = &v99;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v95, &v99, (_OWORD **)&__p)+ 14) = 1046025863;
  if (SHIBYTE(v101) < 0)
    operator delete(v99);
  std::string::basic_string[abi:ne180100]<0>(&v99, "ungulate");
  __p = &v99;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v95, &v99, (_OWORD **)&__p)+ 14) = 1041999331;
  if (SHIBYTE(v101) < 0)
    operator delete(v99);
  std::string::basic_string[abi:ne180100]<0>(&v99, "watercraft");
  __p = &v99;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v95, &v99, (_OWORD **)&__p)+ 14) = 1045287666;
  if (SHIBYTE(v101) < 0)
    operator delete(v99);
  std::string::basic_string[abi:ne180100]<0>(&v99, "flower");
  __p = &v99;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v95, &v99, (_OWORD **)&__p)+ 14) = 1042536202;
  if (SHIBYTE(v101) < 0)
    operator delete(v99);
  std::string::basic_string[abi:ne180100]<0>(&v99, "appliance");
  __p = &v99;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v95, &v99, (_OWORD **)&__p)+ 14) = 1038174126;
  if (SHIBYTE(v101) < 0)
    operator delete(v99);
  std::string::basic_string[abi:ne180100]<0>(&v99, "sports_equipment");
  __p = &v99;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v95, &v99, (_OWORD **)&__p)+ 14) = 1038174126;
  if (SHIBYTE(v101) < 0)
    operator delete(v99);
  std::string::basic_string[abi:ne180100]<0>(&v99, "tool");
  __p = &v99;
  *((_DWORD *)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v95, &v99, (_OWORD **)&__p)+ 14) = 1038174126;
  if (SHIBYTE(v101) < 0)
    operator delete(v99);
}

void sub_1A152754C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,char a48)
{
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t i;
  uint64_t v53;
  void *v54;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  void *v58;
  uint64_t v59;
  void *v60;

  *(_QWORD *)(v48 + 544) = v49;
  for (i = 72; i != -24; i -= 24)
  {
    a13 = v50 - 192 + i;
    std::vector<std::vector<long long>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a13);
  }
  v53 = 0;
  while (1)
  {
    v54 = *(void **)(&a48 + v53 + 192);
    if (v54)
    {
      *(_QWORD *)(&a48 + v53 + 200) = v54;
      operator delete(v54);
    }
    v53 -= 24;
    if (v53 == -216)
    {
      v55 = 0;
      while (1)
      {
        v56 = *(void **)((char *)&STACK[0x210] + v55 + 192);
        if (v56)
        {
          *(unint64_t *)((char *)&STACK[0x210] + v55 + 200) = (unint64_t)v56;
          operator delete(v56);
        }
        v55 -= 24;
        if (v55 == -216)
        {
          v57 = 0;
          while (1)
          {
            v58 = *(void **)((char *)&STACK[0x2E8] + v57 + 192);
            if (v58)
            {
              *(unint64_t *)((char *)&STACK[0x2E8] + v57 + 200) = (unint64_t)v58;
              operator delete(v58);
            }
            v57 -= 24;
            if (v57 == -216)
            {
              v59 = 0;
              while (1)
              {
                v60 = *(void **)((char *)&__p + v59 + 192);
                if (v60)
                {
                  *(void **)((char *)&__p + v59 + 200) = v60;
                  operator delete(v60);
                }
                v59 -= 24;
                if (v59 == -216)
                  _Unwind_Resume(a1);
              }
            }
          }
        }
      }
    }
  }
}

void sub_1A1527B0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  void *v29;
  void *v30;

  if (a29 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

uint64_t vision::mod::ImageAnalyzer::initHasher(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t result;
  _QWORD *exception;

  v4 = operator new();
  vision::mod::ImageDescriptorProcessorHyperplaneLSH::ImageDescriptorProcessorHyperplaneLSH(v4, a2);
  result = *(_QWORD *)(a1 + 1056);
  *(_QWORD *)(a1 + 1056) = v4;
  if (result)
  {
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
    if (!*(_QWORD *)(a1 + 1056))
    {
      exception = __cxa_allocate_exception(8uLL);
      *exception = 8574;
      __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
    }
  }
  return result;
}

void sub_1A1527C08(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1A1B0A898](v1, 0x1081C40D47BEB4BLL);
  _Unwind_Resume(a1);
}

_QWORD *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float> const*,std::vector<float> const*,std::vector<float>*>(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  _QWORD *v4;
  uint64_t v6;
  _QWORD v8[3];
  char v9;
  _QWORD *v10;
  _QWORD *v11;

  v4 = a4;
  v10 = a4;
  v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  v9 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      *v4 = 0;
      v4[1] = 0;
      v4[2] = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v4, *(const void **)v6, *(_QWORD *)(v6 + 8), (uint64_t)(*(_QWORD *)(v6 + 8) - *(_QWORD *)v6) >> 2);
      v4 = v11 + 3;
      v11 += 3;
      v6 += 24;
    }
    while (v6 != a3);
  }
  v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<unsigned int>>,std::vector<unsigned int>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_1A1527CC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<unsigned int>>,std::vector<unsigned int>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void std::vector<std::string>::resize(std::vector<std::string> *this, std::vector<std::string>::size_type __sz)
{
  std::vector<std::string>::pointer begin;
  std::vector<std::string>::pointer end;
  unint64_t v5;
  unint64_t v6;
  std::string *value;
  unint64_t v8;
  std::vector<std::string>::size_type v9;
  unint64_t v10;
  std::string *v11;
  std::string *v12;
  uint64_t v13;
  size_t v14;
  std::string *v15;
  size_t v16;
  std::__split_buffer<std::string> __v;

  begin = this->__begin_;
  end = this->__end_;
  v5 = 0xAAAAAAAAAAAAAAABLL * (((char *)end - (char *)this->__begin_) >> 3);
  v6 = __sz - v5;
  if (__sz <= v5)
  {
    if (__sz < v5)
    {
      v15 = &begin[__sz];
      while (end != v15)
      {
        if (SHIBYTE(end[-1].__r_.__value_.__r.__words[2]) < 0)
          operator delete(end[-1].__r_.__value_.__l.__data_);
        --end;
      }
      this->__end_ = v15;
    }
  }
  else
  {
    value = this->__end_cap_.__value_;
    if (0xAAAAAAAAAAAAAAABLL * (((char *)value - (char *)end) >> 3) >= v6)
    {
      v16 = 24 * ((24 * v6 - 24) / 0x18) + 24;
      bzero(this->__end_, v16);
      this->__end_ = (std::vector<std::string>::pointer)((char *)end + v16);
    }
    else
    {
      if (__sz > 0xAAAAAAAAAAAAAAALL)
        std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
      __v.__end_cap_.__value_ = (std::allocator<std::string> *)&this->__end_cap_;
      v8 = 0xAAAAAAAAAAAAAAABLL * (((char *)value - (char *)begin) >> 3);
      v9 = 2 * v8;
      if (2 * v8 <= __sz)
        v9 = __sz;
      if (v8 >= 0x555555555555555)
        v10 = 0xAAAAAAAAAAAAAAALL;
      else
        v10 = v9;
      v11 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(v10);
      v12 = v11 + v5;
      __v.__first_ = v11;
      __v.__begin_ = v12;
      __v.__end_cap_.__value_ = &v11[v13];
      v14 = 24 * ((24 * v6 - 24) / 0x18) + 24;
      bzero(v12, v14);
      __v.__end_ = (std::string *)((char *)v12 + v14);
      std::vector<std::string>::__swap_out_circular_buffer(this, &__v);
      std::__split_buffer<std::string>::~__split_buffer(&__v);
    }
  }
}

_QWORD *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<std::vector<float>>>,std::vector<std::vector<float>> const*,std::vector<std::vector<float>> const*,std::vector<std::vector<float>>*>(uint64_t a1, uint64_t *a2, uint64_t *a3, _QWORD *a4)
{
  _QWORD *v4;
  uint64_t *v6;
  _QWORD v8[3];
  char v9;
  _QWORD *v10;
  _QWORD *v11;

  v4 = a4;
  v10 = a4;
  v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  v9 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      *v4 = 0;
      v4[1] = 0;
      v4[2] = 0;
      std::vector<std::vector<float>>::__init_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(v4, *v6, v6[1], 0xAAAAAAAAAAAAAAABLL * ((v6[1] - *v6) >> 3));
      v4 = v11 + 3;
      v11 += 3;
      v6 += 3;
    }
    while (v6 != a3);
  }
  v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<float>>>,std::vector<std::vector<float>>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_1A1527F04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<float>>>,std::vector<std::vector<float>>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_1A1528034(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A152811C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A15281F4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1A1528314(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A15283FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1A15284EC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__391(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

uint64_t __Block_byref_object_dispose__392(uint64_t a1)
{
  return std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](a1 + 48);
}

void sub_1A152878C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1528860(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1528A4C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A1528EA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void sub_1A15290A0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A1529104(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1529158(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A15291A4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1529200(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1A1529254(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15292A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A15292F0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A152933C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A1529384(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15293D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A1529418(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1529464(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A152958C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1529600(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1529704(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15297CC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1529980(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A15299D4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1529A20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A1529A6C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1529AB4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1529AFC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1529D54(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  v6 = v5;

  _Unwind_Resume(a1);
}

void sub_1A1529EFC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t computeChannelGradientForX(uint64_t result, unsigned __int16 a2)
{
  int v2;
  int v3;
  uint64_t v4;
  _WORD *v5;
  __int16 *v6;
  int v7;
  _WORD *v8;
  _WORD *v9;
  uint64_t v10;
  int v11;
  __int16 v12;

  v2 = *(_DWORD *)(result + 148);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = result + 8 * a2;
    v5 = *(_WORD **)(v4 + 40);
    v6 = *(__int16 **)(v4 + 16);
    v7 = *(_DWORD *)(result + 144);
    do
    {
      v8 = v6 + 1;
      *v5 = v6[1] - *v6;
      v9 = v5 + 1;
      if (v7 >= 3)
      {
        v10 = 0;
        v11 = v7 - 2;
        do
        {
          result = (unsigned __int16)v6[v10 + 2];
          v5[v10 + 1] = result - v6[v10];
          ++v10;
          --v11;
        }
        while (v11);
        v5 = (_WORD *)((char *)v5 + v10 * 2);
        v9 = v5 + 1;
        v6 = (__int16 *)((char *)v6 + v10 * 2);
        v8 = v6 + 1;
      }
      v12 = *v6;
      v6 += 2;
      v5 += 2;
      *v9 = *v8 - v12;
      ++v3;
    }
    while (v3 != v2);
  }
  return result;
}

uint64_t computeChannelGradientForY(uint64_t result, unsigned __int16 a2)
{
  uint64_t v2;
  __int16 *v3;
  int v4;
  _WORD *v5;
  int v6;
  __int16 *v7;
  __int16 *v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  __int16 *v14;
  __int16 v15;
  __int16 v16;
  __int16 v17;

  v2 = result + 8 * a2;
  v3 = *(__int16 **)(v2 + 16);
  v4 = *(_DWORD *)(result + 144);
  v5 = *(_WORD **)(v2 + 64);
  if (v4 < 1)
  {
    v8 = v3;
  }
  else
  {
    v6 = *(_DWORD *)(result + 144);
    v7 = v3;
    do
    {
      v8 = v7 + 1;
      *v5++ = v7[v4] - *v7;
      ++v7;
      --v6;
    }
    while (v6);
  }
  v9 = *(_DWORD *)(result + 148);
  if (v9 >= 3)
  {
    v10 = v9 - 2;
    v11 = 1;
    do
    {
      if (v4 < 1)
      {
        v8 = v3;
      }
      else
      {
        v12 = 0;
        LODWORD(result) = v4;
        do
        {
          v5[v12] = v3[2 * v4 + v12] - v3[v12];
          ++v12;
          result = (result - 1);
        }
        while ((_DWORD)result);
        v8 = &v3[v12];
        v5 = (_WORD *)((char *)v5 + v12 * 2);
      }
      v3 += v4;
    }
    while (v11++ != v10);
  }
  if (v4 >= 1)
  {
    v14 = &v3[v4];
    do
    {
      v16 = *v14++;
      v15 = v16;
      v17 = *v8++;
      *v5++ = v15 - v17;
      --v4;
    }
    while (v4);
  }
  return result;
}

void cannyEdgeWithGradientOutput(_BYTE *a1, void *a2, char *a3, char *a4, float a5, float a6)
{
  char *v12;
  float v13;
  float v14;
  float v15;
  _WORD *v16;
  _WORD *v17;
  _WORD *v18;
  int v19;
  float *v20;
  _BYTE *v21;
  float v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  float v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  float v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  float v34;
  unsigned int v35;
  float v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int v39;
  float v40;
  unsigned int v41;
  float v42;
  unsigned int v43;
  unsigned int v44;
  unsigned int v45;
  float v46;
  unsigned int v47;
  float v48;
  float *v49;
  int v50;
  uint64_t v51;
  float *v52;
  _BYTE *v53;
  float v54;
  float v55;
  float v56;
  float v57;
  unsigned int v58;
  unsigned int v59;
  float v60;
  unsigned int v62;
  float v63;
  unsigned int v64;
  float v65;
  unsigned int v66;
  unsigned int v67;
  unsigned int v68;
  float v69;
  unsigned int v70;
  float v71;
  unsigned int v72;
  unsigned int v73;
  unsigned int v74;
  float v75;
  unsigned int v76;
  float v77;
  unsigned int v78;
  unsigned int v79;
  unsigned int v80;
  float v81;
  unsigned int v82;
  unsigned int v83;
  unsigned int v84;
  float v85;
  unsigned int v86;
  unsigned int v87;
  unsigned int v88;
  float v89;
  unsigned int v90;
  int v91;
  int v92;
  char *v93;
  char *v94;
  int v95;
  _WORD *v96;
  _WORD *v97;
  _WORD *v98;
  float v99;
  float v100;
  float v101;
  float v102;
  uint64_t v103;
  float *v104;
  float v105;
  double v106;
  int v107;
  int v108;
  int v109;
  char *v110;
  char *v111;
  char *v112;
  char *v113;
  char *v114;
  char *v115;
  char *v116;
  char *v117;
  char *v118;
  uint64_t v119;
  int v120;
  __int16 v121;
  __int16 v122;
  unsigned int v123;
  unsigned int v124;
  unsigned int v125;
  __int16 v126;
  __int16 v127;
  __int16 v128;
  _BYTE *v129;
  uint64_t v130;
  unsigned int v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  int v135;
  _BYTE *v136;
  int v137;
  uint64_t v138;
  unsigned __int16 *v139;
  int v140;
  int v141;
  int v142;
  int v143;
  int v144;
  int v145;
  unsigned int v146;
  int v147;
  uint64_t v148;
  uint64_t v149;
  __int16 v150;
  uint64_t v151;
  uint64_t v152;
  __int16 v153;
  __int16 v154;
  __int16 v155;
  uint64_t v156;
  __int16 v157;
  __int16 v158;
  __int16 v159;
  float v160;
  float v161;
  float v162;
  int v163;
  float v164;
  char v165;
  uint64_t v166;
  unsigned int v167;
  unint64_t v168;
  int v170;
  unsigned int v171;
  unsigned int v172;
  unint64_t v173;
  int v174;
  int v175;
  int v176;
  uint64_t v177;
  int v178;
  unsigned int v180;
  _BYTE *v181;
  int v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  void *v191[5];
  char *v192;
  char *v193;
  char *v194;
  char *v195;
  char *v196;
  char *v197;
  char *v198;
  char *v199;
  char *v200;
  _BYTE *v201;
  char *v202;
  char *v203;
  uint64_t v204;
  uint64_t v205;
  _QWORD v206[6];

  v206[5] = *MEMORY[0x1E0C80C00];
  v205 = 0x10000000100;
  v12 = (char *)malloc_type_calloc(0x1C0000uLL, 1uLL, 0x44DB6DABuLL);
  v191[0] = v12;
  if (!v12)
    __assert_rtn("initializeCannyEdgeContext", "cannyEdge.c", 261, "context->blockAddress");
  v16 = v12 + 786432;
  v191[1] = v12;
  v191[2] = v12 + 786432;
  v17 = v12 + 917504;
  v18 = v12 + 0x100000;
  v191[3] = v12 + 917504;
  v191[4] = v12 + 0x100000;
  v198 = v12 + 1179648;
  v199 = v12 + 1310720;
  v192 = v12;
  v193 = v12 + 0x20000;
  v194 = v12 + 0x40000;
  v195 = v12 + 393216;
  v196 = v12 + 0x80000;
  v197 = v12 + 655360;
  v200 = v12 + 1441792;
  v201 = v12 + 786432;
  v202 = v12 + 1572864;
  v203 = v12;
  if (a3)
    v198 = a3;
  if (a4)
    v199 = a4;
  v19 = 0;
  v20 = (float *)v12;
  v204 = 0;
  do
  {
    LOBYTE(v13) = *a1;
    LOBYTE(v14) = a1[4];
    v21 = a1 + 8;
    v22 = (float)((float)LODWORD(v14) * 0.21868) + (float)((float)LODWORD(v13) * 0.53192);
    *(float *)&v23 = (float)a1[8];
    *(float *)&v24 = (float)(v22 + (float)(*(float *)&v23 * 0.015195)) / 0.7658;
    *v20 = *(float *)&v24;
    LOBYTE(v24) = a1[1];
    LOBYTE(v23) = a1[5];
    *(float *)&v25 = (float)v23 * 0.21868;
    v26 = *(float *)&v25 + (float)((float)v24 * 0.53192);
    LOBYTE(v25) = a1[9];
    *(float *)&v27 = (float)v25;
    *(float *)&v28 = (float)(v26 + (float)(*(float *)&v27 * 0.015195)) / 0.7658;
    v20[1] = *(float *)&v28;
    LOBYTE(v28) = a1[2];
    LOBYTE(v27) = a1[6];
    *(float *)&v29 = (float)v27 * 0.21868;
    v30 = *(float *)&v29 + (float)((float)v28 * 0.53192);
    LOBYTE(v29) = a1[10];
    *(float *)&v31 = (float)v29;
    *(float *)&v32 = (float)(v30 + (float)(*(float *)&v31 * 0.015195)) / 0.7658;
    v20[2] = *(float *)&v32;
    LOBYTE(v32) = *a1;
    LOBYTE(v31) = a1[4];
    *(float *)&v33 = (float)v31 * 0.53192;
    v34 = *(float *)&v33 + (float)((float)v32 * 0.21868);
    LOBYTE(v33) = a1[8];
    *(float *)&v35 = (float)v33;
    v36 = v34 + (float)(*(float *)&v35 * 0.21868);
    LOBYTE(v35) = a1[12];
    *(float *)&v37 = (float)v35;
    *(float *)&v38 = (float)(v36 + (float)(*(float *)&v37 * 0.015195)) / 0.98448;
    v20[3] = *(float *)&v38;
    LOBYTE(v38) = a1[1];
    LOBYTE(v37) = a1[5];
    *(float *)&v39 = (float)v37 * 0.53192;
    v40 = *(float *)&v39 + (float)((float)v38 * 0.21868);
    LOBYTE(v39) = a1[9];
    *(float *)&v41 = (float)v39;
    v42 = v40 + (float)(*(float *)&v41 * 0.21868);
    LOBYTE(v41) = a1[13];
    *(float *)&v43 = (float)v41;
    *(float *)&v44 = (float)(v42 + (float)(*(float *)&v43 * 0.015195)) / 0.98448;
    v20[4] = *(float *)&v44;
    LOBYTE(v44) = a1[2];
    LOBYTE(v43) = a1[6];
    *(float *)&v45 = (float)v43 * 0.53192;
    v46 = *(float *)&v45 + (float)((float)v44 * 0.21868);
    LOBYTE(v45) = a1[10];
    *(float *)&v47 = (float)v45;
    v48 = v46 + (float)(*(float *)&v47 * 0.21868);
    LOBYTE(v47) = a1[14];
    v20[5] = (float)(v48 + (float)((float)v47 * 0.015195)) / 0.98448;
    v49 = v20 + 6;
    v50 = 2;
    do
    {
      v51 = 0;
      v52 = v49;
      v53 = v21;
      *(_QWORD *)v49 = 0;
      v49[2] = 0.0;
      v54 = 0.0;
      v55 = 0.0;
      v56 = 0.0;
      do
      {
        v57 = gaussianKernel[v51];
        LOBYTE(v15) = a1[v51 * 4];
        *(float *)&v58 = (float)LODWORD(v15);
        v54 = v54 + (float)(v57 * *(float *)&v58);
        *v49 = v54;
        LOBYTE(v58) = a1[v51 * 4 + 1];
        *(float *)&v59 = (float)v58;
        v55 = v55 + (float)(v57 * *(float *)&v59);
        v49[1] = v55;
        LOBYTE(v59) = a1[v51 * 4 + 2];
        v15 = (float)v59;
        v56 = v56 + (float)(v57 * v15);
        v49[2] = v56;
        ++v51;
      }
      while (v51 != 5);
      *v49 = v54 / 0.99967;
      v49[1] = v55 / 0.99967;
      v60 = v56 / 0.99967;
      v49[2] = v56 / 0.99967;
      v49 += 3;
      v21 += 4;
      a1 += 4;
    }
    while (v50++ != 253);
    LOBYTE(v60) = *(v53 - 4);
    LOBYTE(v56) = *v53;
    *(float *)&v62 = (float)LODWORD(v56) * 0.21868;
    v63 = *(float *)&v62 + (float)((float)LODWORD(v60) * 0.015195);
    LOBYTE(v62) = v53[4];
    *(float *)&v64 = (float)v62;
    v65 = v63 + (float)(*(float *)&v64 * 0.53192);
    LOBYTE(v64) = v53[8];
    *(float *)&v66 = (float)v64;
    *(float *)&v67 = (float)(v65 + (float)(*(float *)&v66 * 0.21868)) / 0.98448;
    v52[3] = *(float *)&v67;
    LOBYTE(v67) = *(v53 - 3);
    LOBYTE(v66) = v53[1];
    *(float *)&v68 = (float)v66 * 0.21868;
    v69 = *(float *)&v68 + (float)((float)v67 * 0.015195);
    LOBYTE(v68) = v53[5];
    *(float *)&v70 = (float)v68;
    v71 = v69 + (float)(*(float *)&v70 * 0.53192);
    LOBYTE(v70) = v53[9];
    *(float *)&v72 = (float)v70;
    *(float *)&v73 = (float)(v71 + (float)(*(float *)&v72 * 0.21868)) / 0.98448;
    v52[4] = *(float *)&v73;
    LOBYTE(v73) = *(v53 - 2);
    LOBYTE(v72) = v53[2];
    *(float *)&v74 = (float)v72 * 0.21868;
    v75 = *(float *)&v74 + (float)((float)v73 * 0.015195);
    LOBYTE(v74) = v53[6];
    *(float *)&v76 = (float)v74;
    v77 = v75 + (float)(*(float *)&v76 * 0.53192);
    LOBYTE(v76) = v53[10];
    *(float *)&v78 = (float)v76;
    *(float *)&v79 = (float)(v77 + (float)(*(float *)&v78 * 0.21868)) / 0.98448;
    v52[5] = *(float *)&v79;
    LOBYTE(v79) = *v53;
    LOBYTE(v78) = v53[4];
    *(float *)&v80 = (float)v78 * 0.21868;
    v81 = *(float *)&v80 + (float)((float)v79 * 0.015195);
    LOBYTE(v80) = v53[8];
    *(float *)&v82 = (float)v80;
    *(float *)&v83 = (float)(v81 + (float)(*(float *)&v82 * 0.53192)) / 0.7658;
    v52[6] = *(float *)&v83;
    LOBYTE(v83) = v53[1];
    LOBYTE(v82) = v53[5];
    *(float *)&v84 = (float)v82 * 0.21868;
    v85 = *(float *)&v84 + (float)((float)v83 * 0.015195);
    LOBYTE(v84) = v53[9];
    *(float *)&v86 = (float)v84;
    *(float *)&v87 = (float)(v85 + (float)(*(float *)&v86 * 0.53192)) / 0.7658;
    v52[7] = *(float *)&v87;
    LOBYTE(v87) = v53[2];
    LOBYTE(v86) = v53[6];
    *(float *)&v88 = (float)v86 * 0.21868;
    v89 = *(float *)&v88 + (float)((float)v87 * 0.015195);
    LOBYTE(v88) = v53[10];
    v14 = (float)v88;
    v13 = (float)(v89 + (float)(v14 * 0.53192)) / 0.7658;
    v52[8] = v13;
    v20 = v52 + 9;
    a1 = v53 + 12;
    ++v19;
  }
  while (v19 != 256);
  v90 = 0;
  v91 = 2;
  do
  {
    v92 = 0;
    v93 = v12;
    v206[0] = v12 - 6144;
    v206[1] = v12 - 3072;
    v94 = v12 + 6144;
    v12 += 3072;
    v206[2] = v93;
    v206[3] = v12;
    v206[4] = v94;
    v95 = 257 - v90;
    if (v90 < 0xFE)
      v95 = 4;
    v96 = v18;
    v97 = v17;
    v98 = v16;
    do
    {
      v99 = 0.0;
      v100 = 0.0;
      v101 = 0.0;
      v102 = 0.0;
      if ((int)((2 - v90) & ~((int)(2 - v90) >> 31)) < v95)
      {
        v103 = v91 & ~(v91 >> 31);
        do
        {
          v104 = (float *)v206[v103];
          v105 = gaussianKernel[v103];
          v99 = v99 + (float)(v105 * *v104);
          v100 = v100 + (float)(v105 * v104[1]);
          v101 = v101 + (float)(v105 * v104[2]);
          v102 = v102 + v105;
          v206[v103++] = v104 + 3;
        }
        while (v103 < v95);
      }
      v106 = v102;
      *v98++ = (int)(v99 * 90.0 / v106 + 0.5);
      *v97++ = (int)(v100 * 90.0 / v106 + 0.5);
      *v96++ = (int)(v101 * 90.0 / v106 + 0.5);
      ++v92;
    }
    while (v92 != 256);
    ++v90;
    v16 += 256;
    v17 += 256;
    v18 += 256;
    --v91;
  }
  while (v90 != 256);
  computeChannelGradientForX((uint64_t)v191, 0);
  computeChannelGradientForX((uint64_t)v191, 1u);
  computeChannelGradientForX((uint64_t)v191, 2u);
  computeChannelGradientForY((uint64_t)v191, 0);
  computeChannelGradientForY((uint64_t)v191, 1u);
  computeChannelGradientForY((uint64_t)v191, 2u);
  v108 = v205;
  v107 = HIDWORD(v205);
  if (SHIDWORD(v205) >= 1)
  {
    v109 = 0;
    v111 = v199;
    v110 = v200;
    v113 = v197;
    v112 = v198;
    v115 = v195;
    v114 = v196;
    v117 = v193;
    v116 = v194;
    v118 = v192;
    do
    {
      if (v108 >= 1)
      {
        v119 = 0;
        v120 = v108;
        do
        {
          v121 = *(_WORD *)&v118[v119];
          v122 = *(_WORD *)&v117[v119];
          v123 = v121 * v121 + *(__int16 *)&v115[v119] * *(__int16 *)&v115[v119];
          v124 = v122 * v122 + *(__int16 *)&v114[v119] * *(__int16 *)&v114[v119];
          v125 = *(__int16 *)&v116[v119] * *(__int16 *)&v116[v119] + *(__int16 *)&v113[v119] * *(__int16 *)&v113[v119];
          if (v124 > v125)
          {
            v126 = *(_WORD *)&v114[v119];
          }
          else
          {
            v122 = *(_WORD *)&v116[v119];
            v126 = *(_WORD *)&v113[v119];
          }
          if (v123 > v125)
          {
            v127 = *(_WORD *)&v115[v119];
          }
          else
          {
            v121 = *(_WORD *)&v116[v119];
            v127 = *(_WORD *)&v113[v119];
          }
          if (v123 > v124)
          {
            v128 = v127;
          }
          else
          {
            v123 = *(__int16 *)&v117[v119] * *(__int16 *)&v117[v119] + *(__int16 *)&v114[v119] * *(__int16 *)&v114[v119];
            v121 = v122;
            v128 = v126;
          }
          if (v123 <= v125)
            v123 = *(__int16 *)&v116[v119] * *(__int16 *)&v116[v119] + *(__int16 *)&v113[v119] * *(__int16 *)&v113[v119];
          *(_WORD *)&v112[v119] = v121;
          *(_WORD *)&v111[v119] = v128;
          *(_WORD *)&v110[v119] = (int)sqrtf((float)(int)v123 + 0.5);
          v119 += 2;
          --v120;
        }
        while (v120);
        v118 += v119;
        v117 += v119;
        v110 += v119;
        v111 += v119;
        v112 += v119;
        v113 += v119;
        v114 += v119;
        v115 += v119;
        v116 += v119;
      }
      ++v109;
    }
    while (v109 != v107);
  }
  v129 = v201;
  if (v108 >= 1)
  {
    v130 = 0;
    do
    {
      v129[v130] = 0;
      v108 = v205;
      ++v130;
    }
    while ((int)v130 < (int)v205);
    v129 += v130;
    v107 = HIDWORD(v205);
  }
  if (v107 < 3)
  {
    v131 = 0;
    goto LABEL_72;
  }
  v131 = 0;
  v132 = (uint64_t)&v200[2 * v108 + 2];
  v133 = (uint64_t)&v199[2 * v108 + 2];
  v134 = (uint64_t)&v198[2 * v108 + 2];
  v135 = 1;
  do
  {
    *v129 = 0;
    v136 = v129 + 1;
    v137 = v205;
    if ((int)v205 < 3)
      goto LABEL_69;
    v138 = 0;
    do
    {
      v139 = (unsigned __int16 *)(v132 + 2 * v138);
      v140 = *(__int16 *)(v134 + 2 * v138);
      v141 = (v140 >> 31) | 1;
      v142 = *(__int16 *)(v133 + 2 * v138);
      v143 = (v142 >> 31) | 1;
      if (v142 >= 0)
        LOWORD(v144) = *(_WORD *)(v133 + 2 * v138);
      else
        v144 = -v142;
      if (v140 >= 0)
        LOWORD(v145) = *(_WORD *)(v134 + 2 * v138);
      else
        v145 = -v140;
      v146 = (unsigned __int16)v145;
      v147 = v143 * v137;
      if (v140 >= 0)
        v148 = 1;
      else
        v148 = -1;
      v149 = 2 * v148 + 2 * v147;
      v150 = *(unsigned __int16 *)((char *)v139 - v149);
      v151 = v147 - v141;
      if (v146 >= (unsigned __int16)v144)
        v151 = 0;
      v152 = 2 * v151 + 2 * v148;
      v153 = *(unsigned __int16 *)((char *)v139 + v149);
      v154 = *(unsigned __int16 *)((char *)v139 - v152);
      v155 = *(unsigned __int16 *)((char *)v139 + v152);
      v156 = *v139;
      v157 = v154 - v156;
      LOWORD(v139) = v155 - v156;
      v158 = v150 - v154;
      v159 = v153 - v155;
      v160 = (float)v140;
      v161 = (float)v142;
      v162 = (float)v141;
      v163 = v143 * v141;
      if (v146 >= (unsigned __int16)v144)
      {
        if ((float)((float)((float)(v161 * (float)(v163 * v158)) + (float)((float)v157 * v160)) * v162) >= 0.0)
          goto LABEL_65;
        v164 = (float)(__int16)v139;
        LODWORD(v139) = v159;
      }
      else
      {
        if ((float)((float)((float)(v161 * (float)(v163 * v157)) + (float)((float)v158 * v160)) * v162) >= 0.0)
          goto LABEL_65;
        v164 = (float)v159;
        LODWORD(v139) = (__int16)v139;
      }
      if ((float)((float)((float)(v161 * (float)(v163 * (int)v139)) + (float)(v164 * v160)) * v162) > 0.0)
      {
LABEL_65:
        v165 = 0;
        goto LABEL_67;
      }
      ++v131;
      ++*(_DWORD *)&v202[4 * v156];
      v165 = 0x80;
LABEL_67:
      v129[v138 + 1] = v165;
      v137 = v205;
      ++v138;
    }
    while ((int)v138 + 1 < (int)v205 - 1);
    v129 += v138;
    v136 = v129 + 1;
LABEL_69:
    *v136 = 0;
    v108 = v205;
    v134 += 2 * (int)v205;
    v129 += 2;
    ++v135;
    v133 += 2 * (int)v205;
    v132 += 2 * (int)v205;
  }
  while (v135 < HIDWORD(v205) - 1);
LABEL_72:
  if (v108 >= 1)
  {
    v166 = 0;
    do
    {
      v129[v166] = 0;
      v108 = v205;
      ++v166;
    }
    while ((int)v166 < (int)v205);
  }
  v167 = 0xFFFF;
  do
  {
    v168 = v167 - 1;
    if (v167 < 2)
      break;
  }
  while (!*(_DWORD *)&v202[4 * v167--]);
  v170 = 1;
  if (v168 >= 2)
  {
    v171 = (int)((float)((float)v131 * a6) + 0.5);
    v172 = *((_DWORD *)v202 + 1);
    if (v172 < v171)
    {
      v173 = 2;
      do
      {
        v170 = v173;
        if (v173 >= v168)
          break;
        v172 += *(_DWORD *)&v202[4 * v173++];
      }
      while (v172 < v171);
    }
  }
  WORD2(v204) = v170;
  HIWORD(v204) = (int)((float)((float)v170 * a5) + 0.5);
  LODWORD(v204) = 0;
  v174 = HIDWORD(v205);
  bzero(a2, v108 * HIDWORD(v205));
  if (v174 < 3)
  {
    v180 = 0;
  }
  else
  {
    v175 = 1;
    do
    {
      if (v108 >= 3)
      {
        v176 = 1;
        do
        {
          v177 = (v176 + v175 * v108);
          v178 = *(unsigned __int16 *)&v200[2 * v177];
          if (v178 <= SHIWORD(v204))
          {
            v201[v177] = 0;
          }
          else if (v201[v177] == 128 && v178 >= SWORD2(v204))
          {
            v201[v177] = -1;
            *((_BYTE *)a2 + v177) = -1;
            *(_DWORD *)&v203[4 * v204] = v177;
            LODWORD(v204) = v204 + 1;
          }
          ++v176;
          v108 = v205;
        }
        while (v176 < (int)v205 - 1);
        v174 = HIDWORD(v205);
      }
      ++v175;
    }
    while (v175 < v174 - 1);
    v180 = v204;
  }
  while (v180)
  {
    LODWORD(v204) = --v180;
    v181 = v201;
    v182 = *(_DWORD *)&v203[4 * v180];
    v183 = (v182 - 1);
    if (v201[v183] == 128)
    {
      v201[v183] = -1;
      *((_BYTE *)a2 + v183) = -1;
      *(_DWORD *)&v203[4 * v204] = v183;
      v108 = v205;
      v180 = v204 + 1;
      LODWORD(v204) = v204 + 1;
      v181 = v201;
    }
    v184 = (v183 - v108);
    if (v181[v184] == 128)
    {
      v181[v184] = -1;
      *((_BYTE *)a2 + v184) = -1;
      *(_DWORD *)&v203[4 * v204] = v184;
      v108 = v205;
      v180 = v204 + 1;
      LODWORD(v204) = v204 + 1;
      v181 = v201;
    }
    v185 = (v108 + v183);
    if (v181[v185] == 128)
    {
      v181[v185] = -1;
      *((_BYTE *)a2 + v185) = -1;
      *(_DWORD *)&v203[4 * v204] = v185;
      v180 = v204 + 1;
      LODWORD(v204) = v204 + 1;
      v181 = v201;
    }
    v186 = (v182 + 1);
    if (v181[v186] == 128)
    {
      v181[v186] = -1;
      *((_BYTE *)a2 + v186) = -1;
      *(_DWORD *)&v203[4 * v204] = v186;
      v180 = v204 + 1;
      LODWORD(v204) = v204 + 1;
      v181 = v201;
    }
    v108 = v205;
    v187 = (v186 - v205);
    if (v181[v187] == 128)
    {
      v181[v187] = -1;
      *((_BYTE *)a2 + v187) = -1;
      *(_DWORD *)&v203[4 * v204] = v187;
      v108 = v205;
      v180 = v204 + 1;
      LODWORD(v204) = v204 + 1;
      v181 = v201;
    }
    v188 = (v108 + v186);
    if (v181[v188] == 128)
    {
      v181[v188] = -1;
      *((_BYTE *)a2 + v188) = -1;
      *(_DWORD *)&v203[4 * v204] = v188;
      v108 = v205;
      v180 = v204 + 1;
      LODWORD(v204) = v204 + 1;
      v181 = v201;
    }
    v189 = (v108 + v182);
    if (v181[v189] == 128)
    {
      v181[v189] = -1;
      *((_BYTE *)a2 + v189) = -1;
      *(_DWORD *)&v203[4 * v204] = v189;
      v108 = v205;
      v180 = v204 + 1;
      LODWORD(v204) = v204 + 1;
      v181 = v201;
    }
    v190 = (v182 - v108);
    if (v181[v190] == 128)
    {
      v181[v190] = -1;
      *((_BYTE *)a2 + v190) = -1;
      *(_DWORD *)&v203[4 * v204] = v190;
      v108 = v205;
      v180 = v204 + 1;
      LODWORD(v204) = v204 + 1;
    }
    if (v180 > HIDWORD(v205) * v108)
      __assert_rtn("thresholdAndConnectCandidateEdges", "cannyEdge.c", 725, "context->edgeStackSize <= context->width*context->height");
  }
  free(v191[0]);
}

uint64_t BresenhamCoords(int a1, int a2, uint64_t a3)
{
  int v3;
  unsigned int v4;
  int v5;
  int v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  _WORD *v13;
  int v14;
  unsigned int v15;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  _WORD *v20;
  int v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  _WORD *v26;
  int v27;
  int v28;
  int v29;
  int v30;
  uint64_t v31;
  _WORD *v32;
  int v33;
  unsigned int v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  _WORD *v39;
  int v40;
  int v41;
  int v42;
  int v43;
  uint64_t v44;
  _WORD *v45;
  int v46;
  int v47;
  int v48;
  uint64_t v49;
  _WORD *v50;
  int v51;
  int v52;
  int v53;
  int v54;
  uint64_t v55;
  _WORD *v56;
  int v57;

  v3 = (__int16)a1;
  v4 = (__int16)a2 - (__int16)a1;
  v5 = a2 >> 16;
  v6 = a1 >> 16;
  v7 = (a2 >> 16) - (a1 >> 16);
  if ((v4 & 0x80000000) != 0)
  {
    v15 = (__int16)a1 - (__int16)a2;
    if ((v7 & 0x80000000) != 0)
    {
      v34 = v4 - v7;
      if (v4 > v7)
      {
        v35 = -2 * v4;
        v36 = 2 * (v7 - v4);
        v37 = v7 + 2 * v15;
        v38 = 1 - v7;
        v39 = (_WORD *)(a3 + 2);
        do
        {
          *(v39 - 1) = v3;
          if (v37 <= 0)
            v40 = v35;
          else
            v40 = v36;
          LOWORD(v3) = v3 - (v37 > 0);
          *v39 = v6;
          v39 += 2;
          v37 += v40;
          --v6;
          --v38;
        }
        while (v38);
        v4 = (a1 >> 16) - (a2 >> 16);
        return v4 + 1;
      }
      v52 = -2 * v7;
      v53 = 2 * v34;
      v54 = v4 + 2 * ((a1 >> 16) - (a2 >> 16));
      v55 = 1 - v4;
      v56 = (_WORD *)(a3 + 2);
      do
      {
        *v56 = v6;
        if (v54 <= 0)
          v57 = v52;
        else
          v57 = v53;
        LOWORD(v6) = v6 - (v54 > 0);
        *(v56 - 1) = v3;
        v54 += v57;
        --v3;
        v56 += 2;
        --v55;
      }
      while (v55);
    }
    else
    {
      if (v15 < v7)
      {
        v16 = -2 * v4;
        v17 = 2 * (v15 - v7);
        v18 = v16 - v7;
        v19 = (v5 - v6 + 1);
        v20 = (_WORD *)(a3 + 2);
        do
        {
          *(v20 - 1) = v3;
          if (v18 <= 0)
            v21 = v16;
          else
            v21 = v17;
          LOWORD(v3) = v3 - (v18 > 0);
          *v20 = v6;
          v20 += 2;
          v18 += v21;
          ++v6;
          --v19;
        }
        while (v19);
        goto LABEL_19;
      }
      v41 = 2 * v7;
      v42 = 2 * (v4 + v7);
      v43 = v4 + 2 * v7;
      v44 = 1 - v4;
      v45 = (_WORD *)(a3 + 2);
      do
      {
        *v45 = v6;
        if (v43 <= 0)
          v46 = v41;
        else
          v46 = v42;
        if (v43 > 0)
          LOWORD(v6) = v6 + 1;
        *(v45 - 1) = v3;
        v43 += v46;
        --v3;
        v45 += 2;
        --v44;
      }
      while (v44);
    }
LABEL_63:
    v4 = v15;
    return v4 + 1;
  }
  if ((v7 & 0x80000000) != 0)
  {
    v15 = (a1 >> 16) - (a2 >> 16);
    if (v15 <= v4)
    {
      v47 = -2 * v7;
      v48 = v47 - v4;
      v49 = ((__int16)a2 - (__int16)a1 + 1);
      v50 = (_WORD *)(a3 + 2);
      do
      {
        *v50 = v6;
        if (v48 <= 0)
          v51 = v47;
        else
          v51 = 2 * ((a1 >> 16) - (a2 >> 16) - v4);
        LOWORD(v6) = v6 - (v48 > 0);
        *(v50 - 1) = v3;
        v48 += v51;
        ++v3;
        v50 += 2;
        --v49;
      }
      while (v49);
      return v4 + 1;
    }
    v22 = 2 * v4;
    v23 = 2 * (v4 + v7);
    v24 = v7 + 2 * v4;
    v25 = 1 - v7;
    v26 = (_WORD *)(a3 + 2);
    do
    {
      *(v26 - 1) = v3;
      if (v24 <= 0)
        v27 = v22;
      else
        v27 = v23;
      if (v24 > 0)
        LOWORD(v3) = v3 + 1;
      *v26 = v6;
      v26 += 2;
      v24 += v27;
      --v6;
      --v25;
    }
    while (v25);
    goto LABEL_63;
  }
  v8 = v7 - v4;
  if (v7 > v4)
  {
    v9 = 2 * v4;
    v10 = 2 * (v4 - v7);
    v11 = v9 - v7;
    v12 = (v5 - v6 + 1);
    v13 = (_WORD *)(a3 + 2);
    do
    {
      *(v13 - 1) = v3;
      if (v11 <= 0)
        v14 = v9;
      else
        v14 = v10;
      if (v11 > 0)
        LOWORD(v3) = v3 + 1;
      *v13 = v6;
      v13 += 2;
      v11 += v14;
      ++v6;
      --v12;
    }
    while (v12);
LABEL_19:
    v4 = (a2 >> 16) - (a1 >> 16);
    return v4 + 1;
  }
  v28 = 2 * v7;
  v29 = 2 * v8;
  v30 = v28 - v4;
  v31 = ((__int16)a2 - (__int16)a1 + 1);
  v32 = (_WORD *)(a3 + 2);
  do
  {
    *v32 = v6;
    if (v30 <= 0)
      v33 = v28;
    else
      v33 = v29;
    if (v30 > 0)
      LOWORD(v6) = v6 + 1;
    *(v32 - 1) = v3;
    v30 += v33;
    ++v3;
    v32 += 2;
    --v31;
  }
  while (v31);
  return v4 + 1;
}

void sub_1A152BA08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25)
{
  void *v25;
  void *v26;
  uint64_t v27;
  void *v29;

  if (__p)
  {
    a25 = (uint64_t)__p;
    operator delete(__p);
  }
  v29 = *(void **)(v27 - 104);
  if (v29)
  {
    *(_QWORD *)(v27 - 96) = v29;
    operator delete(v29);
  }
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a20);
  if (a17 < 0)
    operator delete(a12);

  _Unwind_Resume(a1);
}

void sub_1A152C1B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A152C200(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  void *v27;
  uint64_t v28;

  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](v28 - 128);
  if (v27)
    operator delete(v27);
  objc_begin_catch(a1);
  JUMPOUT(0x1A152C04CLL);
}

void sub_1A152C3F8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A152C5C4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<vision::mod::ImageClassifierEspresso>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453B760;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<vision::mod::ImageClassifierEspresso>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453B760;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A1B0A898);
}

uint64_t std::__shared_ptr_emplace<vision::mod::ImageClassifierEspresso>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void sub_1A152C8A0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A152CA50(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A152CF1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20)
{

  _Unwind_Resume(a1);
}

void sub_1A152D240(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A152D7A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, uint64_t a14, void *a15, void *a16, void *a17)
{
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

void sub_1A152DAFC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A152DCD0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_1A152DE4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A152DEC0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A152E098(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void vision::mod::ImageDescriptorProcessorHyperplaneLSH::~ImageDescriptorProcessorHyperplaneLSH(void **this)
{
  *this = &off_1E453AF20;
  free(this[3]);
  this[3] = 0;
}

{
  *this = &off_1E453AF20;
  free(this[3]);
  this[3] = 0;
  JUMPOUT(0x1A1B0A898);
}

_QWORD *vision::mod::ImageDescriptorProcessorHyperplaneLSH::createDescriptorBuffer@<X0>(vision::mod::ImageDescriptorProcessorHyperplaneLSH *this@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *result;

  v4 = operator new(0x90uLL);
  v4[1] = 0;
  v4[2] = 0;
  *v4 = &off_1E453B958;
  v4[4] = 0;
  v4[5] = 0;
  v4[9] = 0;
  v4[8] = 0;
  v4[6] = 0;
  v4[7] = v4 + 8;
  *((_OWORD *)v4 + 5) = 0u;
  *((_OWORD *)v4 + 6) = 0u;
  *((_BYTE *)v4 + 112) = 0;
  *((_DWORD *)v4 + 32) = 1;
  v4[17] = 0;
  v4[15] = *((int *)this + 3);
  a2[1] = v4;
  v4[3] = &off_1E453A8D0;
  result = v4 + 3;
  *a2 = result;
  return result;
}

uint64_t vision::mod::ImageDescriptorProcessorHasher::getDescriptorLengthInBytes(vision::mod::ImageDescriptorProcessorHasher *this)
{
  return 4 * *((int *)this + 3);
}

void vision::mod::ImageDescriptorProcessorHyperplaneLSH::hashFeature(const float **this, const float *__B, float *__C)
{
  _QWORD *exception;
  float v6;
  float v7;
  float *__D[3];
  float __Ca;
  float __Ba;

  if (!__B || !__C)
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = 3709;
    __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
  }
  vDSP_mmul(this[3], 1, __B, 1, __C, 1, *((int *)this + 3), 1uLL, *((int *)this + 2));
  __Ba = 0.0;
  __Ca = 1.0;
  std::vector<float>::vector(__D, *((int *)this + 3));
  vDSP_vthrsc(__C, 1, &__Ba, &__Ca, __D[0], 1, *((int *)this + 3));
  v6 = 1.0;
  v7 = 0.0;
  vDSP_vclip(__D[0], 1, &v7, &v6, __C, 1, *((int *)this + 3));
  if (__D[0])
  {
    __D[1] = __D[0];
    operator delete(__D[0]);
  }
}

void sub_1A152E348(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void vision::mod::ImageDescriptorProcessorHyperplaneLSH::encodeHash(uint64_t a1, float *a2, uint64_t a3)
{
  vision::mod::ImageDescriptorProcessorHasher::base64EncodeHash(a2, *(_DWORD *)(a1 + 12) / *(_DWORD *)(a1 + 16), 1, a3);
}

FILE *tearDownAndSignalErr(float **a1, float **a2, float **a3, __sFILE **a4, uint64_t a5)
{
  FILE *result;
  _QWORD *exception;

  free(*a1);
  *a1 = 0;
  free(*a2);
  *a2 = 0;
  free(*a3);
  *a3 = 0;
  result = *a4;
  if (*a4)
  {
    result = (FILE *)fclose(result);
    *a4 = 0;
  }
  if ((a5 & 0x80) == 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = a5;
    __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
  }
  return result;
}

uint64_t vision::mod::ImageDescriptorProcessorHyperplaneLSH::ImageDescriptorProcessorHyperplaneLSH(uint64_t a1, uint64_t a2)
{
  float **v4;
  const char *v5;
  FILE *v6;
  FILE *v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  const char *v11;
  FILE *v12;
  FILE *v13;
  uint64_t v14;
  uint64_t v15;
  float **v16;
  float **v17;
  float **v18;
  __sFILE **v19;
  uint64_t v20;
  int v21;
  _QWORD *exception;
  uint64_t v24;
  float *v25;
  float *v26;
  float *v27;
  __sFILE *v28;
  uint64_t v29;
  float *v30;
  float *v31;
  float *v32;
  __sFILE *v33;

  *(_DWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = &off_1E453AF20;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  v4 = (float **)(a1 + 24);
  if (*(char *)(a2 + 23) >= 0)
    v5 = (const char *)a2;
  else
    v5 = *(const char **)a2;
  v6 = fopen(v5, "rb");
  v28 = v6;
  if (!v6)
    goto LABEL_29;
  v7 = v6;
  v26 = 0;
  v27 = 0;
  v24 = 1;
  v25 = 0;
  v8 = BinSerializer_freadInFloat(v6, "hash_size", 1, &v27, (size_t *)&v24);
  if (v8 == 384)
  {
    *(_DWORD *)(a1 + 12) = (int)*v27;
  }
  else
  {
    tearDownAndSignalErr(&v27, &v26, &v25, &v28, v8);
    v7 = v28;
  }
  *(_DWORD *)(a1 + 16) = 1;
  if (BinSerializer_freadInFloat(v7, "num_hashes", 1, &v26, (size_t *)&v24) == 384)
  {
    *(_DWORD *)(a1 + 16) = (int)*v26;
    v9 = BinSerializer_freadInFloat(v7, "feat_size", 1, &v25, (size_t *)&v24);
    if (v9 == 384)
    {
      v10 = (int)*v25;
      *(_DWORD *)(a1 + 8) = v10;
    }
    else
    {
      tearDownAndSignalErr(&v27, &v26, &v25, &v28, v9);
      v10 = *(_DWORD *)(a1 + 8);
      v7 = v28;
    }
    v24 = *(int *)(a1 + 12) * (uint64_t)v10;
    v15 = BinSerializer_freadInFloat(v7, "projection_matrix", 1, v4, (size_t *)&v24);
    if (v15 != 384)
      tearDownAndSignalErr(&v27, &v26, &v25, &v28, v15);
    v16 = &v27;
    v17 = &v26;
    v18 = &v25;
    v19 = &v28;
    goto LABEL_28;
  }
  v11 = *(char *)(a2 + 23) >= 0 ? (const char *)a2 : *(const char **)a2;
  v12 = fopen(v11, "rb");
  v33 = v12;
  if (!v12)
  {
LABEL_29:
    exception = __cxa_allocate_exception(8uLL);
    *exception = 3701;
    __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
  }
  v13 = v12;
  v32 = 0;
  v30 = 0;
  v31 = 0;
  v14 = BinSerializer_freadInFloat(v12, "hash_size", 1, &v32, (size_t *)&v29);
  if (v14 == 384)
  {
    *(_DWORD *)(a1 + 12) = (int)*v32;
  }
  else
  {
    tearDownAndSignalErr(&v32, &v31, &v30, &v33, v14);
    v13 = v33;
  }
  v20 = BinSerializer_freadInFloat(v13, "feat_size", 1, &v30, (size_t *)&v29);
  if (v20 == 384)
  {
    v21 = (int)*v30;
    *(_DWORD *)(a1 + 8) = v21;
  }
  else
  {
    tearDownAndSignalErr(&v32, &v31, &v30, &v33, v20);
    v21 = *(_DWORD *)(a1 + 8);
    v13 = v33;
  }
  v29 = *(int *)(a1 + 12) * (uint64_t)v21;
  v15 = BinSerializer_freadInFloat(v13, "projection_matrix", 1, v4, (size_t *)&v29);
  if (v15 != 384)
    tearDownAndSignalErr(&v32, &v31, &v30, &v33, v15);
  v16 = &v32;
  v17 = &v31;
  v18 = &v30;
  v19 = &v33;
LABEL_28:
  tearDownAndSignalErr(v16, v17, v18, v19, v15);
  return a1;
}

void sub_1A152EAB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  void *v9;
  void *v10;

  v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)VNCCCharBoxContext;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_1A152EF1C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A152F628(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A1531C5C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1533398(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15337BC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1533E34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  void *v11;

  _Unwind_Resume(a1);
}

void sub_1A1534CFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,void *__p,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51)
{
  void *v51;

  _Unwind_Resume(a1);
}

void sub_1A15398D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,void *a31)
{
  void *v31;

  _Unwind_Resume(a1);
}

void sub_1A153A318(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A153A804(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, void *a12, void *a13, void *a14, void *a15)
{
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void sub_1A153AB3C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<int,int>,std::__map_value_compare<int,std::__value_type<int,int>,std::less<int>,true>,std::allocator<std::__value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t **a1, int a2, unsigned int *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  int v8;
  uint64_t *v9;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = (uint64_t *)operator new(0x28uLL);
    *(uint64_t *)((char *)v9 + 28) = *a3;
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at(a1, (uint64_t)v7, v6, v9);
    return v9;
  }
  return (uint64_t *)v7;
}

uint64_t **std::__tree<std::__value_type<int,__CCCharBox>,std::__map_value_compare<int,std::__value_type<int,__CCCharBox>,std::less<int>,true>,std::allocator<std::__value_type<int,__CCCharBox>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t **a1, int a2, _DWORD *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  int v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = (uint64_t *)v7;
    v7 = (uint64_t **)operator new(0x30uLL);
    *((_DWORD *)v7 + 7) = *a3;
    v7[4] = 0;
    *((_WORD *)v7 + 20) = 0;
    *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *v6 = (uint64_t *)v7;
    v10 = (uint64_t *)**a1;
    v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

uint64_t **std::__tree<std::__value_type<int,unsigned char>,std::__map_value_compare<int,std::__value_type<int,unsigned char>,std::less<int>,true>,std::allocator<std::__value_type<int,unsigned char>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t **a1, int a2, _DWORD *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  int v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = (uint64_t *)v7;
    v7 = (uint64_t **)operator new(0x28uLL);
    *((_DWORD *)v7 + 7) = *a3;
    *((_BYTE *)v7 + 32) = 0;
    *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *v6 = (uint64_t *)v7;
    v10 = (uint64_t *)**a1;
    v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void vision::mod::LandmarkDetectorDNN_Options::~LandmarkDetectorDNN_Options(vision::mod::LandmarkDetectorDNN_Options *this)
{
  std::__tree<std::__value_type<unsigned char,std::string>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,std::string>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,std::string>>>::destroy(*((char **)this + 13));
  std::__tree<std::__value_type<unsigned char,std::string>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,std::string>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,std::string>>>::destroy(*((char **)this + 10));
  std::__tree<std::__value_type<unsigned char,std::string>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,std::string>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,std::string>>>::destroy(*((char **)this + 7));
  if (*((char *)this + 47) < 0)
    operator delete(*((void **)this + 3));
}

uint64_t std::map<vision::mod::_constellationType,std::pair<std::string,BOOL>>::map[abi:ne180100](uint64_t a1, _QWORD *a2)
{
  uint64_t **v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t *v6;
  uint64_t **v7;
  uint64_t v8;
  uint64_t **v9;
  BOOL v10;
  int v11;
  uint64_t **v12;
  uint64_t **v13;
  char *v14;
  std::string *v15;
  __int128 v16;
  int v17;
  _QWORD *v18;
  _QWORD *v19;

  *(_QWORD *)(a1 + 8) = 0;
  v3 = (uint64_t **)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = a1 + 8;
  v4 = a2 + 1;
  v5 = (_QWORD *)*a2;
  if ((_QWORD *)*a2 != a2 + 1)
  {
    do
    {
      v6 = *(uint64_t **)(a1 + 8);
      v7 = v3;
      if (*(uint64_t ***)a1 == v3)
        goto LABEL_8;
      v8 = *(_QWORD *)(a1 + 8);
      v9 = v3;
      if (v6)
      {
        do
        {
          v7 = (uint64_t **)v8;
          v8 = *(_QWORD *)(v8 + 8);
        }
        while (v8);
      }
      else
      {
        do
        {
          v7 = (uint64_t **)v9[2];
          v10 = *v7 == (uint64_t *)v9;
          v9 = v7;
        }
        while (v10);
      }
      v11 = *((_DWORD *)v5 + 8);
      if (*((_DWORD *)v7 + 8) < v11)
      {
LABEL_8:
        if (v6)
          v12 = v7;
        else
          v12 = v3;
        if (v6)
          v13 = v7 + 1;
        else
          v13 = v3;
      }
      else
      {
        v12 = v3;
        v13 = v3;
        if (v6)
        {
          v13 = v3;
          while (1)
          {
            while (1)
            {
              v12 = (uint64_t **)v6;
              v17 = *((_DWORD *)v6 + 8);
              if (v11 >= v17)
                break;
              v6 = *v12;
              v13 = v12;
              if (!*v12)
                goto LABEL_15;
            }
            if (v17 >= v11)
              break;
            v13 = v12 + 1;
            v6 = v12[1];
            if (!v6)
              goto LABEL_15;
          }
        }
      }
      if (!*v13)
      {
LABEL_15:
        v14 = (char *)operator new(0x48uLL);
        *((_DWORD *)v14 + 8) = *((_DWORD *)v5 + 8);
        v15 = (std::string *)(v14 + 40);
        if (*((char *)v5 + 63) < 0)
        {
          std::string::__init_copy_ctor_external(v15, (const std::string::value_type *)v5[5], v5[6]);
        }
        else
        {
          v16 = *(_OWORD *)(v5 + 5);
          *((_QWORD *)v14 + 7) = v5[7];
          *(_OWORD *)&v15->__r_.__value_.__l.__data_ = v16;
        }
        v14[64] = *((_BYTE *)v5 + 64);
        std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at((uint64_t **)a1, (uint64_t)v12, v13, (uint64_t *)v14);
      }
      v18 = (_QWORD *)v5[1];
      if (v18)
      {
        do
        {
          v19 = v18;
          v18 = (_QWORD *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          v19 = (_QWORD *)v5[2];
          v10 = *v19 == (_QWORD)v5;
          v5 = v19;
        }
        while (!v10);
      }
      v5 = v19;
    }
    while (v19 != v4);
  }
  return a1;
}

void sub_1A153AF84(_Unwind_Exception *a1)
{
  void *v1;
  char **v2;

  operator delete(v1);
  std::__tree<std::__value_type<unsigned char,std::string>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,std::string>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,std::string>>>::destroy(*v2);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::LandmarkDetectorDNN::checkConstellation(uint64_t result, int a2)
{
  _QWORD *exception;

  if (vision::mod::constellationTypeSize[a2] != result)
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = 2942;
    __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
  }
  return result;
}

void vision::mod::ImageProcessing_Preprocessor::mapCoordinatesDestinationToSource(uint64_t a1, float *a2, uint64_t a3)
{
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float *v20;
  float *v21;
  uint64_t v22;
  vDSP_Length v23;
  float *v24;
  float *v25;
  int v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  _QWORD *exception;
  float v33;
  float v34;
  float v35[2];
  float v36;
  float v37[3];

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  Geometry2D_mallocCart2D((_QWORD *)a1, *(_DWORD *)(a3 + 16));
  v7 = a2[32];
  v6 = a2[33];
  v9 = a2[34];
  v8 = a2[35];
  v10 = (float)(v7 * v8) - (float)(v6 * v9);
  if (fabsf(v10) < 0.00000011921)
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = 1902;
LABEL_27:
    __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
  }
  v11 = v8 / v10;
  v12 = (float)-v6 / v10;
  v33 = v11;
  v34 = v12;
  v13 = (float)-v9 / v10;
  v14 = v7 / v10;
  v35[0] = v13;
  v35[1] = v14;
  v15 = a2[36];
  v16 = a2[37];
  v17 = v13 * v16;
  v18 = -(float)((float)(v13 * v16) + (float)(v11 * v15));
  v19 = v14 * v16;
  v36 = v18;
  v37[0] = -(float)(v19 + (float)(v12 * v15));
  if (a3 == a1)
    goto LABEL_25;
  v20 = *(float **)a3;
  if (!*(_QWORD *)a3)
    goto LABEL_25;
  v21 = *(float **)(a3 + 8);
  if (!v21)
    goto LABEL_25;
  v22 = 1916;
  if (!a1)
    goto LABEL_26;
  v23 = *(unsigned int *)(a3 + 16);
  if ((int)v23 < 1)
    goto LABEL_26;
  v24 = *(float **)a1;
  if (!*(_QWORD *)a1 || (v25 = *(float **)(a1 + 8)) == 0)
  {
LABEL_25:
    v22 = 1916;
LABEL_26:
    exception = __cxa_allocate_exception(8uLL);
    *exception = v22;
    goto LABEL_27;
  }
  v26 = *(_DWORD *)(a1 + 16);
  v22 = 1916;
  if (v26 < 1 || (_DWORD)v23 != v26)
    goto LABEL_26;
  if (fabsf(v11 + -1.0) > 0.0001
    || fabsf(v12) > 0.0001
    || fabsf(v13) > 0.0001
    || fabsf(v14 + -1.0) > 0.0001
    || fabsf(v18) > 0.0001
    || fabsf(-(float)(v19 + (float)(v12 * v15))) > 0.0001)
  {
    if ((int)v23 > 7)
    {
      vDSP_vfill(&v36, v24, 1, v23);
      vDSP_vfill(v37, *(float **)(a1 + 8), 1, *(int *)(a1 + 16));
      vDSP_vsma(*(const float **)a3, 1, &v33, *(const float **)a1, 1, *(float **)a1, 1, *(int *)(a1 + 16));
      vDSP_vsma(*(const float **)a3, 1, &v34, *(const float **)(a1 + 8), 1, *(float **)(a1 + 8), 1, *(int *)(a1 + 16));
      vDSP_vsma(*(const float **)(a3 + 8), 1, v35, *(const float **)a1, 1, *(float **)a1, 1, *(int *)(a1 + 16));
      vDSP_vsma(*(const float **)(a3 + 8), 1, (const float *)((unint64_t)&v33 | 0xC), *(const float **)(a1 + 8), 1, *(float **)(a1 + 8), 1, *(int *)(a1 + 16));
    }
    else
    {
      v27 = v17 + (float)(v11 * v15);
      v28 = v19 + (float)(v12 * v15);
      do
      {
        *v24++ = (float)((float)(v13 * *v21) + (float)(v11 * *v20)) - v27;
        v29 = *v20++;
        v30 = v29;
        v31 = *v21++;
        *v25++ = (float)((float)(v14 * v31) + (float)(v12 * v30)) - v28;
        --v23;
      }
      while (v23);
    }
  }
  else
  {
    v22 = Geometry2D_copyCart2D(a3, a1);
    if ((v22 & 0x80) == 0)
      goto LABEL_26;
  }
}

void sub_1A153B560(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  void *v11;
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

void sub_1A153B70C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A153B93C(_Unwind_Exception *a1, uint64_t a2, void *a3, ...)
{
  va_list va;

  va_start(va, a3);

  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A153BD64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,void *a56)
{
  void *v56;
  void *v57;
  void *v58;
  void **v59;
  uint64_t v60;

  vision::mod::ImageDescriptorBufferFloat32::~ImageDescriptorBufferFloat32(v59);

  _Block_object_dispose(&a43, 8);
  _Block_object_dispose(&a51, 8);

  _Block_object_dispose((const void *)(v60 - 256), 8);
  vision::mod::ImageDescriptorBufferFloat32::~ImageDescriptorBufferFloat32((void **)(v60 - 208));

  _Unwind_Resume(a1);
}

void sub_1A153BF00(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A153C020(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  void *v15;
  void *v16;
  void *v17;

  _Unwind_Resume(a1);
}

void sub_1A153C114(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  void *v13;

  _Unwind_Resume(a1);
}

void sub_1A153C500(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  uint64_t v8;

  std::istream::~istream();
  std::streambuf::~streambuf();

  _Unwind_Resume(a1);
}

void sub_1A153C724(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  uint64_t v3;

  std::ostream::~ostream();
  std::streambuf::~streambuf();

  _Unwind_Resume(a1);
}

void sub_1A153C91C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v7;
  void *v8;
  va_list va;

  va_start(va, a7);

  _Block_object_dispose(va, 8);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](v7);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__102_25205(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

uint64_t __Block_byref_object_dispose__103_25206(uint64_t a1)
{
  return std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](a1 + 48);
}

uint64_t ___ZL15_newFaceIDModeliPU15__autoreleasingP7NSError_block_invoke_25208(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  unint64_t *v5;
  unint64_t v6;
  __int128 v8;

  v2 = operator new(0x280uLL);
  v2[1] = 0;
  v2[2] = 0;
  *v2 = &off_1E453B450;
  vision::mod::FaceIDModel::FaceIDModel((vision::mod::FaceIDModel *)(v2 + 3), *(_DWORD *)(a1 + 40), 1, 10000, 1, 0.1, 1, 20);
  *(_QWORD *)&v8 = v3;
  *((_QWORD *)&v8 + 1) = v2;
  std::shared_ptr<vision::mod::ImageAnalyzer>::operator=[abi:ne180100](*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48, &v8);
  v4 = (std::__shared_weak_count *)*((_QWORD *)&v8 + 1);
  if (*((_QWORD *)&v8 + 1))
  {
    v5 = (unint64_t *)(*((_QWORD *)&v8 + 1) + 8);
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 - 1, v5));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return 1;
}

void sub_1A153CA78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1A153CB3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__33(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__34(uint64_t a1)
{

}

uint64_t __Block_byref_object_copy__25215(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 48) = &off_1E453A1B8;
  *(_QWORD *)(result + 56) = *(_QWORD *)(a2 + 56);
  return result;
}

void sub_1A153CE64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, char a15, uint64_t a16, uint64_t a17, void **a18)
{
  void *v18;

  a18 = (void **)&a15;
  std::vector<std::map<int,double>>::__destroy_vector::operator()[abi:ne180100](&a18);

  _Unwind_Resume(a1);
}

void sub_1A153CFCC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A153DACC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,void *a21,void *a22,void *a23,void *a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,char a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,void *__p,uint64_t a51,uint64_t a52,char a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58)
{
  void *v58;
  uint64_t v59;

  if (v58)
    operator delete(v58);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](v59 - 112);

  _Unwind_Resume(a1);
}

void sub_1A153DDE4(void *a1)
{
  os_unfair_lock_s *v1;

  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_1A153DDF8(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A153E004(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A153E258(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;

  if (__p)
    operator delete(__p);

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__25316(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__25317(uint64_t a1)
{

}

void sub_1A153E340(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A153E4E8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_1A153E664(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A153E7A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void sub_1A153E9C8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A153EA74(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A153EB04(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A153EBA8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A153EC54(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A153ED04(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A153EDAC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A153EEA4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A153EF2C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A153F014(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A153F09C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A153F17C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A153F1E0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A153F264(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A153F368(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A153F5A8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A153F670(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A153F90C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A153FB68(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A153FD04(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A153FD84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1A153FDDC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A153FE3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1A153FE94(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A153FEE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A153FF28(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A153FF74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A153FFBC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1540008(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A1540050(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15400A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A15400F4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1540224(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A1540404(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  _Unwind_Resume(a1);
}

void sub_1A15404E8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id _sequenceKeyComponentForArray(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  v1 = a1;
  if (v1)
  {
    v2 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99E60]), "initWithArray:", v1);
    objc_msgSend(v2, "allObjects");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    v4 = (void *)MEMORY[0x1E0CB3940];
    objc_msgSend(v3, "componentsJoinedByString:", CFSTR(","));
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "stringWithFormat:", CFSTR("[%@]"), v5);
    v6 = (void *)objc_claimAutoreleasedReturnValue();

  }
  else
  {
    v6 = 0;
  }

  return v6;
}

void sub_1A15405F0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A15406A4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A154072C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1540820(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A15408C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1A1540944(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1540A6C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A1540AD0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1540B30(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1540CC0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1540DB8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

int *appendDequeElement(int *a1, void *__src)
{
  int v4;
  int v5;
  uint64_t v6;

  if (a1)
  {
    v4 = a1[3];
    v5 = a1[1];
    if (v4 == v5 - 1)
    {
      reallocDeque(a1, 2 * v5, 1, 0);
      v4 = a1[3];
    }
    v6 = v4 + 1;
    a1[3] = v6;
    memcpy((void *)(*((_QWORD *)a1 + 2) + *a1 * v6), __src, *a1);
  }
  return a1;
}

int *reallocDeque(int *a1, int a2, int a3, int a4)
{
  char *v8;
  char *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  void *v14;

  v8 = (char *)malloc_type_malloc(*a1 * (uint64_t)a2, 0x1EA6628AuLL);
  v9 = v8;
  v10 = a1[2];
  v11 = a1[3] - v10;
  if (a4)
    v12 = a3;
  else
    v12 = 0;
  v13 = v12 + ((a2 - a3 + ~v11) >> 1);
  memcpy(&v8[v13 * *a1], (const void *)(*((_QWORD *)a1 + 2) + *a1 * v10), *a1 + *a1 * v11);
  a1[2] = v13;
  a1[3] = v13 + v11;
  v14 = (void *)*((_QWORD *)a1 + 2);
  if (v14)
    free(v14);
  *((_QWORD *)a1 + 2) = v9;
  a1[1] = a2;
  return a1;
}

int *prependDequeElement(int *a1, void *__src)
{
  int v4;
  uint64_t v5;

  if (a1)
  {
    v4 = a1[2];
    if (!v4)
    {
      reallocDeque(a1, 2 * a1[1], 1, 1);
      v4 = a1[2];
    }
    v5 = v4 - 1;
    a1[2] = v5;
    memcpy((void *)(*((_QWORD *)a1 + 2) + *a1 * v5), __src, *a1);
  }
  return a1;
}

uint64_t appendDeque(uint64_t a1, int *a2, int a3)
{
  int v6;
  int v7;
  int v8;
  int v9;
  _WORD *v10;
  uint64_t v11;
  int v12;

  if (a1 && a2)
  {
    v6 = a2[3] - a2[2] + 1;
    v7 = *(_DWORD *)(a1 + 12);
    v8 = v7 + v6;
    if (v7 + v6 >= *(_DWORD *)(a1 + 4))
    {
      reallocDeque((int *)a1, 2 * (v6 + v7 - *(_DWORD *)(a1 + 8)) + 2, a2[3] - a2[2] + 1, 0);
      v7 = *(_DWORD *)(a1 + 12);
      v8 = v7 + v6;
    }
    v9 = *(_DWORD *)a1;
    v10 = (_WORD *)(*(_QWORD *)(a1 + 16) + v9 + v9 * v7);
    *(_DWORD *)(a1 + 12) = v8;
    v11 = *((_QWORD *)a2 + 2);
    v12 = *a2;
    if (a3)
      reverseCopy(v10, (char *)(v11 + v12 * (uint64_t)a2[3]), v9, v6);
    else
      memcpy(v10, (const void *)(v11 + v12 * (uint64_t)a2[2]), v12 * (uint64_t)v6);
  }
  return a1;
}

uint64_t prependDeque(uint64_t a1, int *a2, int a3)
{
  int v6;
  int v7;
  int v8;
  _WORD *v9;
  uint64_t v10;
  int v11;

  if (a1 && a2)
  {
    v6 = a2[3] - a2[2] + 1;
    v7 = *(_DWORD *)(a1 + 8);
    v8 = v7 - v6;
    if (v7 - v6 < 0)
    {
      reallocDeque((int *)a1, 2 * (v6 + *(_DWORD *)(a1 + 12) - v7) + 2, a2[3] - a2[2] + 1, 1);
      v8 = *(_DWORD *)(a1 + 8) - v6;
    }
    *(_DWORD *)(a1 + 8) = v8;
    v9 = (_WORD *)(*(_QWORD *)(a1 + 16) + *(_DWORD *)a1 * v8);
    v10 = *((_QWORD *)a2 + 2);
    v11 = *a2;
    if (a3)
      reverseCopy(v9, (char *)(v10 + v11 * (uint64_t)a2[3]), *(_DWORD *)a1, v6);
    else
      memcpy(v9, (const void *)(v10 + v11 * (uint64_t)a2[2]), v11 * (uint64_t)v6);
  }
  return a1;
}

float Projections_computeMeanStdTable(float *a1, int a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t v4;
  float *v5;
  float *v6;
  float v7;
  float result;

  *a3 = 0;
  *a4 = 0;
  if (a2 >= 1)
  {
    v4 = (a2 + 1) - 1;
    v5 = (float *)(a4 + 1);
    v6 = (float *)(a3 + 1);
    do
    {
      *v6 = *(v6 - 1) + *a1;
      ++v6;
      v7 = *a1++;
      result = *(v5 - 1) + (float)(v7 * v7);
      *v5++ = result;
      --v4;
    }
    while (v4);
  }
  return result;
}

void sub_1A1541324(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1541380(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  void *v9;
  void *v10;

  v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)VNContour;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_1A1541508(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1541638(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15418D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12)
{
  void *v12;

  _Unwind_Resume(a1);
}

void sub_1A1541A48(void *exc_buf, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  os_unfair_lock_s *v10;

  objc_begin_catch(exc_buf);
  os_unfair_lock_unlock(v10);
  objc_exception_rethrow();
}

void sub_1A1541A84(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A1541B80(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1541D34(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void RamerDouglasPeucker(uint64_t a1, void **a2, float a3, double a4, double a5, double a6)
{
  float32x2_t *v6;
  uint64_t v7;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float32x2_t v15;
  float32x2_t v16;
  int8x8_t v17;
  float32x2_t v23;
  uint64_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float v27;
  uint64_t v28;
  uint64_t v29;
  const void *v30;
  char *v31;
  char *v32;
  int64_t v33;
  unint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  unint64_t v38;
  _QWORD *v39;
  unint64_t v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  char *v45;
  uint64_t v46;
  char *v47;
  char *v48;
  char *v49;
  uint64_t v50;
  float32x2_t *v51;
  unint64_t v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  char *v59;
  unint64_t v60;
  char *v61;
  void *v62;
  char *v63;
  char *v64;
  char *v65;
  uint64_t v66;
  char *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  uint64_t v72;
  int64_t v73;
  char *v74;
  unint64_t v75;
  char *v76;
  char *v77;
  uint64_t v78;
  char *v79;
  char *v80;
  char *v81;
  uint64_t v82;
  _QWORD *v83;
  char *v84;
  uint64_t v85;
  _QWORD *v86;
  uint64_t v87;
  char *v88;
  char *v89;
  uint64_t v90;
  unint64_t v91;
  char *v92;
  uint64_t v93;
  void *v94;
  void *__p[3];
  void *v96[3];
  void *v97;
  _BYTE *v98;
  uint64_t v99;
  void *v100;
  uint64_t v101;
  uint64_t v102;

  v6 = *(float32x2_t **)a1;
  v7 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if ((unint64_t)v7 < 0x10)
    return;
  v11 = v7 >> 3;
  v12 = (v7 >> 3) - 1;
  if (v12 < 2)
  {
    v14 = 0;
    v16.i32[0] = 0;
  }
  else
  {
    v13 = 0;
    v14 = 0;
    v15 = vsub_f32(v6[v12], *v6);
    v16 = vmul_f32(v15, v15);
    *(float *)&a6 = sqrtf(vaddv_f32(v16));
    v16.i32[0] = 0;
    v17 = (int8x8_t)vdup_lane_s32((int32x2_t)vmvn_s8(vorr_s8((int8x8_t)vcgt_f32(v16, *(float32x2_t *)&a6), (int8x8_t)vcgt_f32(*(float32x2_t *)&a6, v16))), 0);
    *(float *)&a6 = fabsf(*(float *)&a6);
    __asm { FMOV            V5.2S, #1.0 }
    v23 = vdiv_f32(v15, (float32x2_t)vbsl_s8(v17, _D5, (int8x8_t)vdup_lane_s32(*(int32x2_t *)&a6, 0)));
    v24 = v11 - 2;
    do
    {
      v25 = vsub_f32(v6[v13 + 1], *v6);
      v26 = vsub_f32(v25, vmul_n_f32(v23, vmlas_n_f32(COERCE_FLOAT(vmul_f32(v23, v25).i32[1]), v23.f32[0], v25.f32[0])));
      v27 = fabsf(sqrtf(vaddv_f32(vmul_f32(v26, v26))));
      if (v27 > v16.f32[0])
        v14 = v13 + 1;
      v28 = v13 + 1;
      if (v27 > v16.f32[0])
        v16.f32[0] = v27;
      ++v13;
    }
    while (v24 != v28);
  }
  if (v16.f32[0] > a3)
  {
    v100 = 0;
    v101 = 0;
    v102 = 0;
    v97 = 0;
    v98 = 0;
    v99 = 0;
    memset(v96, 0, sizeof(v96));
    _ZNSt3__16vectorIDv2_fNS_9allocatorIS1_EEE16__init_with_sizeB8ne180100INS_11__wrap_iterIPKS1_EES9_EEvT_T0_m(v96, v6, (uint64_t)&v6[v14 + 1], (8 * v14 + 8) >> 3);
    v29 = *(_QWORD *)(a1 + 8);
    v30 = (const void *)(*(_QWORD *)a1 + 8 * v14);
    memset(__p, 0, sizeof(__p));
    _ZNSt3__16vectorIDv2_fNS_9allocatorIS1_EEE16__init_with_sizeB8ne180100INS_11__wrap_iterIPKS1_EES9_EEvT_T0_m(__p, v30, v29, (v29 - (uint64_t)v30) >> 3);
    RamerDouglasPeucker(v96, &v100, a3);
    RamerDouglasPeucker(__p, &v97, a3);
    v31 = (char *)v100;
    v32 = (char *)(v101 - 8);
    v33 = v101 - 8 - (_QWORD)v100;
    v34 = v33 >> 3;
    v35 = (uint64_t)a2[2];
    v36 = (char *)*a2;
    if (v33 >> 3 <= (unint64_t)((v35 - (uint64_t)*a2) >> 3))
    {
      v59 = (char *)a2[1];
      v60 = (v59 - v36) >> 3;
      if (v60 < v34)
      {
        v61 = (char *)v100 + 8 * v60;
        if (v59 != v36)
        {
          memmove(*a2, v100, v59 - v36);
          v36 = (char *)a2[1];
        }
        v33 = v32 - v61;
        if (v32 == v61)
          goto LABEL_52;
        v62 = v36;
        v63 = v61;
        goto LABEL_51;
      }
    }
    else
    {
      if (v36)
      {
        a2[1] = v36;
        operator delete(v36);
        v35 = 0;
        *a2 = 0;
        a2[1] = 0;
        a2[2] = 0;
      }
      if (v33 < 0)
        std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
      v37 = v35 >> 2;
      if (v35 >> 2 <= v34)
        v37 = v33 >> 3;
      if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF8)
        v38 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v38 = v37;
      std::vector<long long>::__vallocate[abi:ne180100](a2, v38);
      v36 = (char *)a2[1];
    }
    if (v32 == v31)
    {
LABEL_52:
      v64 = &v36[v33];
      a2[1] = v64;
      v65 = (char *)v97;
      if (v98 - (_BYTE *)v97 >= 1)
      {
        v66 = (v98 - (_BYTE *)v97) >> 3;
        v67 = (char *)a2[2];
        if (v66 <= (v67 - v64) >> 3)
        {
          if (v66 <= 0)
          {
            v79 = (char *)v97 + 8 * v66;
            v80 = &v64[-8 * v66];
            v81 = v64;
            if (v80 < v64)
            {
              v81 = v64;
              do
              {
                v82 = *(_QWORD *)v80;
                v80 += 8;
                *(_QWORD *)v81 = v82;
                v81 += 8;
              }
              while (v80 < v64);
            }
            a2[1] = v81;
            if (v64 != &v64[8 * v66])
              memmove(&v64[-8 * ((-8 * v66) >> 3)], v64, -8 * v66);
            if (v79 != v65)
              memmove(v64, v65, v79 - v65);
          }
          else
          {
            v73 = v98 - (_BYTE *)v97;
            if (v98 != v97)
              memmove(v64, v97, v98 - (_BYTE *)v97);
            a2[1] = &v64[v73];
          }
        }
        else
        {
          v68 = (v64 - (_BYTE *)*a2) >> 3;
          if ((unint64_t)(v68 + v66) >> 61)
            std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
          v69 = v67 - (_BYTE *)*a2;
          v70 = v69 >> 2;
          if (v69 >> 2 <= (unint64_t)(v68 + v66))
            v70 = v68 + v66;
          if ((unint64_t)v69 >= 0x7FFFFFFFFFFFFFF8)
            v71 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v71 = v70;
          if (v71)
            v71 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v71);
          else
            v72 = 0;
          v83 = (_QWORD *)(v71 + 8 * v68);
          v84 = (char *)&v83[v66];
          v85 = 8 * v66;
          v86 = v83;
          do
          {
            v87 = *(_QWORD *)v65;
            v65 += 8;
            *v86++ = v87;
            v85 -= 8;
          }
          while (v85);
          v88 = (char *)*a2;
          if (*a2 != v64)
          {
            v89 = v64;
            do
            {
              v90 = *((_QWORD *)v89 - 1);
              v89 -= 8;
              *--v83 = v90;
            }
            while (v89 != v88);
          }
          v91 = v71 + 8 * v72;
          v92 = (char *)a2[1];
          v93 = v92 - v64;
          if (v92 != v64)
            memmove(v84, v64, v92 - v64);
          v94 = *a2;
          *a2 = v83;
          a2[1] = &v84[v93];
          a2[2] = (void *)v91;
          if (v94)
            operator delete(v94);
        }
      }
      if (__p[0])
        operator delete(__p[0]);
      if (v96[0])
        operator delete(v96[0]);
      if (v97)
        operator delete(v97);
      if (v100)
        operator delete(v100);
      return;
    }
    v62 = v36;
    v63 = v31;
LABEL_51:
    memmove(v62, v63, v33);
    goto LABEL_52;
  }
  v39 = *a2;
  a2[1] = *a2;
  v40 = (unint64_t)a2[2];
  if ((unint64_t)v39 >= v40)
  {
    v42 = v40 - (_QWORD)v39;
    v43 = v42 >> 2;
    if ((unint64_t)(v42 >> 2) <= 1)
      v43 = 1;
    if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFF8)
      v44 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v44 = v43;
    v45 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v44);
    v47 = &v45[8 * v46];
    *(float32x2_t *)v45 = *v6;
    v41 = v45 + 8;
    v49 = (char *)*a2;
    v48 = (char *)a2[1];
    if (v48 != *a2)
    {
      do
      {
        v50 = *((_QWORD *)v48 - 1);
        v48 -= 8;
        *((_QWORD *)v45 - 1) = v50;
        v45 -= 8;
      }
      while (v48 != v49);
      v48 = (char *)*a2;
    }
    *a2 = v45;
    a2[1] = v41;
    a2[2] = v47;
    if (v48)
      operator delete(v48);
  }
  else
  {
    *v39 = *v6;
    v41 = (char *)(v39 + 1);
  }
  a2[1] = v41;
  v51 = *(float32x2_t **)a1;
  v52 = (unint64_t)a2[2];
  if ((unint64_t)v41 >= v52)
  {
    v54 = (v41 - (_BYTE *)*a2) >> 3;
    if ((unint64_t)(v54 + 1) >> 61)
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    v55 = v52 - (_QWORD)*a2;
    v56 = v55 >> 2;
    if (v55 >> 2 <= (unint64_t)(v54 + 1))
      v56 = v54 + 1;
    if ((unint64_t)v55 >= 0x7FFFFFFFFFFFFFF8)
      v57 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v57 = v56;
    if (v57)
      v57 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v57);
    else
      v58 = 0;
    v74 = (char *)(v57 + 8 * v54);
    v75 = v57 + 8 * v58;
    *(float32x2_t *)v74 = v51[v12];
    v53 = v74 + 8;
    v77 = (char *)*a2;
    v76 = (char *)a2[1];
    if (v76 != *a2)
    {
      do
      {
        v78 = *((_QWORD *)v76 - 1);
        v76 -= 8;
        *((_QWORD *)v74 - 1) = v78;
        v74 -= 8;
      }
      while (v76 != v77);
      v76 = (char *)*a2;
    }
    *a2 = v74;
    a2[1] = v53;
    a2[2] = (void *)v75;
    if (v76)
      operator delete(v76);
  }
  else
  {
    *(float32x2_t *)v41 = v51[v12];
    v53 = v41 + 8;
  }
  a2[1] = v53;
}

void sub_1A1542468(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18)
{
  if (__p)
    operator delete(__p);
  if (a12)
    operator delete(a12);
  if (a15)
    operator delete(a15);
  if (a18)
    operator delete(a18);
  _Unwind_Resume(exception_object);
}

_QWORD *_ZNSt3__16vectorIDv2_fNS_9allocatorIS1_EEE16__init_with_sizeB8ne180100INS_11__wrap_iterIPKS1_EES9_EEvT_T0_m(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<long long>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1A1542518(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A15425E8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t vision::mod::CVMLCanceller::signal(uint64_t this)
{
  *(_BYTE *)(this + 8) = 1;
  return this;
}

BOOL vision::mod::CVMLCanceller::shouldStop(vision::mod::CVMLCanceller *this, int a2)
{
  int v2;

  v2 = *((_DWORD *)this + 3);
  if (v2 <= 0)
    return *((_BYTE *)this + 8) != 0;
  else
    return v2 <= a2;
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::shared_ptr<vision::mod::ImageDescriptorBufferFloat32>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::shared_ptr<vision::mod::ImageDescriptorBufferFloat32>>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::pair<std::shared_ptr<cvml::util::mapped_model_file>,int>>,0>((uint64_t)v1 + 32);
    operator delete(v1);
  }
}

void std::vector<std::string>::__assign_with_size[abi:ne180100]<std::string const*,std::string const*>(std::vector<std::string> *a1, std::string *__str, __int128 *a3, unint64_t a4)
{
  __int128 *v6;
  uint64_t p_end_cap;
  std::string *begin;
  unint64_t v10;
  unint64_t v11;
  std::string *v12;
  std::string *end;
  __int128 *v14;
  uint64_t v15;

  v6 = (__int128 *)__str;
  p_end_cap = (uint64_t)&a1->__end_cap_;
  begin = a1->__begin_;
  if (0xAAAAAAAAAAAAAAABLL * (((char *)a1->__end_cap_.__value_ - (char *)a1->__begin_) >> 3) < a4)
  {
    std::vector<std::string>::__vdeallocate(a1);
    v10 = 0x5555555555555556 * (((char *)a1->__end_cap_.__value_ - (char *)a1->__begin_) >> 3);
    if (v10 <= a4)
      v10 = a4;
    if (0xAAAAAAAAAAAAAAABLL * (((char *)a1->__end_cap_.__value_ - (char *)a1->__begin_) >> 3) >= 0x555555555555555)
      v11 = 0xAAAAAAAAAAAAAAALL;
    else
      v11 = v10;
    std::vector<std::string>::__vallocate[abi:ne180100](a1, v11);
    v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>(p_end_cap, v6, a3, a1->__end_);
LABEL_14:
    a1->__end_ = v12;
    return;
  }
  end = a1->__end_;
  if (0xAAAAAAAAAAAAAAABLL * (((char *)end - (char *)begin) >> 3) < a4)
  {
    v14 = (__int128 *)(&__str->__r_.__value_.__l.__data_ + (((char *)end - (char *)begin) >> 3));
    if (end != begin)
    {
      v15 = 8 * (((char *)end - (char *)begin) >> 3);
      do
      {
        std::string::operator=(begin, (const std::string *)v6);
        v6 = (__int128 *)((char *)v6 + 24);
        ++begin;
        v15 -= 24;
      }
      while (v15);
      begin = a1->__end_;
    }
    v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>(p_end_cap, v14, a3, begin);
    goto LABEL_14;
  }
  if (__str != (std::string *)a3)
  {
    do
    {
      std::string::operator=(begin, (const std::string *)v6);
      v6 = (__int128 *)((char *)v6 + 24);
      ++begin;
    }
    while (v6 != a3);
    end = a1->__end_;
  }
  while (end != begin)
  {
    if (SHIBYTE(end[-1].__r_.__value_.__r.__words[2]) < 0)
      operator delete(end[-1].__r_.__value_.__l.__data_);
    --end;
  }
  a1->__end_ = begin;
}

void sub_1A15427F8(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<vision::mod::ConcreteFaceprintAndAttributes>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453BA00;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<vision::mod::ConcreteFaceprintAndAttributes>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453BA00;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A1B0A898);
}

uint64_t std::__shared_ptr_emplace<vision::mod::ConcreteFaceprintAndAttributes>::__on_zero_shared(uint64_t a1)
{
  void *v2;
  void *v3;
  void **v5;

  if (*(_BYTE *)(a1 + 144))
  {
    if (espresso_plan_destroy())
    {
      syslog(5, "[Error] Fail to destroy the existing espresso plan");
    }
    else
    {
      *(_QWORD *)(a1 + 120) = 0;
      if (espresso_context_destroy())
        syslog(5, "[Error] Fail to destroy the existing espresso context");
      else
        *(_QWORD *)(a1 + 112) = 0;
    }
  }
  std::__tree<std::__value_type<std::string,std::shared_ptr<vision::mod::ImageDescriptorBufferFloat32>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<vision::mod::ImageDescriptorBufferFloat32>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<vision::mod::ImageDescriptorBufferFloat32>>>>::destroy(*(_QWORD **)(a1 + 6752));
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](a1 + 6728);
  std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::destroy(*(char **)(a1 + 6704));
  v5 = (void **)(a1 + 6672);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v5);
  v5 = (void **)(a1 + 6648);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v5);
  v5 = (void **)(a1 + 6280);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v5);
  v5 = (void **)(a1 + 6256);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v5);
  v2 = *(void **)(a1 + 6232);
  if (v2)
  {
    *(_QWORD *)(a1 + 6240) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 6208);
  if (v3)
  {
    *(_QWORD *)(a1 + 6216) = v3;
    operator delete(v3);
  }
  if (*(char *)(a1 + 87) < 0)
    operator delete(*(void **)(a1 + 64));
  if (*(char *)(a1 + 63) < 0)
    operator delete(*(void **)(a1 + 40));
  return std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](a1 + 24);
}

uint64_t vision::mod::FaceprintAndAttributes::getFaceAttributesOutput(uint64_t a1, uint64_t **a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t *v5;
  int v6;
  void **v7;
  char *v8;
  uint64_t **v9;
  std::string *v10;
  __int128 v11;
  _QWORD *v12;
  _QWORD *v13;
  BOOL v14;
  uint64_t v16;

  if (*(_BYTE *)(a1 + 6620))
  {
    v2 = *(_QWORD **)(a1 + 6672);
    v3 = (_QWORD *)(a1 + 6680);
    if (v2 == (_QWORD *)(a1 + 6680))
    {
      v5 = &CVML_status_ok;
    }
    else
    {
      v5 = &CVML_status_ok;
      do
      {
        v6 = *((_DWORD *)v2 + 14);
        v7 = (void **)std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::__find_equal<std::string>((uint64_t)a2, &v16, v2 + 4);
        v8 = (char *)*v7;
        if (!*v7)
        {
          v9 = (uint64_t **)v7;
          v8 = (char *)operator new(0x40uLL);
          v10 = (std::string *)(v8 + 32);
          if (*((char *)v2 + 55) < 0)
          {
            std::string::__init_copy_ctor_external(v10, (const std::string::value_type *)v2[4], v2[5]);
          }
          else
          {
            v11 = *((_OWORD *)v2 + 2);
            *((_QWORD *)v8 + 6) = v2[6];
            *(_OWORD *)&v10->__r_.__value_.__l.__data_ = v11;
          }
          *((_DWORD *)v8 + 14) = 0;
          std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at(a2, v16, v9, (uint64_t *)v8);
        }
        *((_DWORD *)v8 + 14) = v6;
        v12 = (_QWORD *)v2[1];
        if (v12)
        {
          do
          {
            v13 = v12;
            v12 = (_QWORD *)*v12;
          }
          while (v12);
        }
        else
        {
          do
          {
            v13 = (_QWORD *)v2[2];
            v14 = *v13 == (_QWORD)v2;
            v2 = v13;
          }
          while (!v14);
        }
        v2 = v13;
      }
      while (v13 != v3);
    }
  }
  else
  {
    v5 = &CVML_status_IOError;
  }
  return (*v5 + 128) | 0x2300;
}

void sub_1A1542AA8(_Unwind_Exception *a1)
{
  void **v1;

  std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,float>,void *>>>::operator()[abi:ne180100](0, v1);
  _Unwind_Resume(a1);
}

_QWORD *std::shared_ptr<float>::shared_ptr[abi:ne180100]<float,void (*)(void *),void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_1E453BFE8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  v4[4] = MEMORY[0x1E0C834A8];
  a1[1] = v4;
  return a1;
}

void sub_1A1542B20(void *a1)
{
  void *v1;

  __cxa_begin_catch(a1);
  free(v1);
  __cxa_rethrow();
}

void sub_1A1542B34(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<float *,void (*)(void *),std::allocator<float>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A1B0A898);
}

uint64_t std::__shared_ptr_pointer<float *,void (*)(void *),std::allocator<float>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), 0x80000001A15FABCALL))
    return a1 + 32;
  else
    return 0;
}

void sub_1A154334C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1543500(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A15436FC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1543858(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1543930(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1543A54(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1543CC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12)
{
  void *v12;
  void *v13;
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

void sub_1A1543D88(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1543DD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A1543E1C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1543E68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A1543EB0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1543EFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A15440A8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A154437C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1544740(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1A15448C0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A154491C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1544994(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A15449E4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1544A5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A1544AAC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1544B28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A1544B78(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1544BF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A1544C40(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1544CB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A1544D00(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1544D68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A1544DB0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1544DFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A1544EFC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1544FB8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1545060(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15450FC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1545160(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15451DC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A15452A8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1545318(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A154538C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A154541C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A15454B4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A1545574(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15456D8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1545804(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15458F4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1545C14(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A1545C70(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1545CBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A1545D04(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1545D50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A1545D98(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1545DE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A1545EDC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1545FA4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15461A0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A1546460(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  v7 = v6;

  _Unwind_Resume(a1);
}

void sub_1A15465C8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1546688(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1546750(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A15468CC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A154696C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1546A0C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1546C14(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1A1546CB8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1546CFC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1546D48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A1546E40(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A1546FA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A1547BC4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1547CE0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1547DF4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1547EAC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1547F58(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A15481F4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;

  _Unwind_Resume(a1);
}

void sub_1A1548494(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A1548638(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;

  _Unwind_Resume(a1);
}

void sub_1A1548928(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;

  _Unwind_Resume(a1);
}

void sub_1A1548A48(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1548CB8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1548E6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  void *v15;
  void *v16;
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

void sub_1A1548FCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  void *v13;
  void *v14;
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void sub_1A1549270(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  void *v15;
  void *v16;
  void *v17;

  _Unwind_Resume(a1);
}

void sub_1A1549A28(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59)
{
  if (a2)
  {
    apple::vision::fgbg::ConnectedComponentResult::~ConnectedComponentResult((apple::vision::fgbg::ConnectedComponentResult *)&a59);
    apple::vision::fgbg::ConnectedComponentResult::~ConnectedComponentResult((apple::vision::fgbg::ConnectedComponentResult *)&STACK[0x240]);

    objc_begin_catch(a1);
    JUMPOUT(0x1A1549994);
  }
  _Unwind_Resume(a1);
}

void sub_1A1549E74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11)
{

  _Unwind_Resume(a1);
}

void sub_1A154A01C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A154A30C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *__p, uint64_t a14)
{
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

void sub_1A154A5A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18)
{
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;

  _Unwind_Resume(a1);
}

void sub_1A154A6A8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A154A9F0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A154AC58(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A154AE20(_Unwind_Exception *a1)
{
  void *v1;
  uint64_t v2;
  void *v3;
  void *v5;

  v5 = *(void **)v2;
  if (*(_QWORD *)v2)
  {
    *(_QWORD *)(v2 + 8) = v5;
    operator delete(v5);
  }

  _Unwind_Resume(a1);
}

void sub_1A154AF30(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A154B0FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v4;
  va_list va;

  va_start(va, a4);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)(v4 - 64));
  vision::mod::LandmarkDetectorDNN_Options::~LandmarkDetectorDNN_Options((vision::mod::LandmarkDetectorDNN_Options *)va);
  _Unwind_Resume(a1);
}

void sub_1A154B234(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  *(_QWORD *)(v2 - 56) = va;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)(v2 - 56));
  vision::mod::LandmarkDetectorDNN_Options::~LandmarkDetectorDNN_Options((vision::mod::LandmarkDetectorDNN_Options *)va1);
  _Unwind_Resume(a1);
}

void sub_1A154B494(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*(_QWORD **)(v1 + 8));
  MEMORY[0x1A1B0A898](v1, 0x1020C4062D53EE8);
  _Unwind_Resume(a1);
}

void sub_1A154B548(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A154B62C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A154B928(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  void *v13;

  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void sub_1A154BB0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  void *v13;

  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void sub_1A154BE44(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A154C064(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A154C6F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15)
{

  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<vision::mod::LandmarkDetectorDNN>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453B610;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<vision::mod::LandmarkDetectorDNN>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453B610;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A1B0A898);
}

void std::__shared_ptr_emplace<vision::mod::LandmarkDetectorDNN>::__on_zero_shared(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 264))
  {
    espresso_plan_destroy();
    espresso_context_destroy();
  }
  std::unique_ptr<vision::mod::ImageProcessing_Preprocessor>::reset[abi:ne180100]((uint64_t *)(a1 + 256), 0);
  std::__tree<std::__value_type<std::string,float>,std::__map_value_compare<std::string,std::__value_type<std::string,float>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,float>>>::destroy(*(char **)(a1 + 192));
  std::__tree<std::__value_type<unsigned char,std::string>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,std::string>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,std::string>>>::destroy(*(char **)(a1 + 168));
  std::__tree<std::__value_type<unsigned char,std::string>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,std::string>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,std::string>>>::destroy(*(char **)(a1 + 144));
  std::__tree<std::__value_type<unsigned char,std::string>,std::__map_value_compare<unsigned char,std::__value_type<unsigned char,std::string>,std::less<unsigned char>,true>,std::allocator<std::__value_type<unsigned char,std::string>>>::destroy(*(char **)(a1 + 120));
  if (*(char *)(a1 + 111) < 0)
    operator delete(*(void **)(a1 + 88));
}

CGColorSpaceRef VNColorspaceForFormat(int a1, int *a2)
{
  CGColorSpaceRef result;
  int v4;
  CFStringRef *v5;

  if (a1 > 1094862673)
  {
    if (a1 <= 1278226487)
    {
      if (a1 == 1094862674)
      {
        result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
        v4 = 8193;
        goto LABEL_21;
      }
      if (a1 == 1111970369)
      {
        result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
        v4 = 8194;
        goto LABEL_21;
      }
      goto LABEL_18;
    }
    if (a1 == 1278226534 || a1 == 1278226488)
      goto LABEL_15;
    goto LABEL_18;
  }
  if (a1 <= 875704421)
  {
    if (a1 == 32)
    {
      result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
      v4 = 2;
      goto LABEL_21;
    }
    if (a1 != 40)
      goto LABEL_18;
LABEL_15:
    v5 = (CFStringRef *)MEMORY[0x1E0C9D978];
LABEL_19:
    result = CGColorSpaceCreateWithName(*v5);
    goto LABEL_20;
  }
  if (a1 != 875704422 && a1 != 875704438)
  {
LABEL_18:
    v5 = (CFStringRef *)MEMORY[0x1E0C9DA10];
    goto LABEL_19;
  }
  result = CGColorSpaceCreateDeviceRGB();
LABEL_20:
  v4 = 0;
LABEL_21:
  if (a2)
    *a2 = v4;
  return result;
}

uint64_t VNCVPixelBufferCreateUsingIOSurface(size_t width, size_t height, OSType pixelFormatType, CFDictionaryRef theDict, CVPixelBufferRef *a5)
{
  const __CFDictionary *v10;
  const __CFAllocator *v11;
  CFIndex Count;
  CFIndex v13;
  const __CFDictionary *v14;
  uint64_t v15;
  CVPixelBufferRef pixelBufferOut;

  if (!a5)
    return 4294960635;
  if (VNIOSurfaceBackedPixelBufferAttributes::onceToken != -1)
    dispatch_once(&VNIOSurfaceBackedPixelBufferAttributes::onceToken, &__block_literal_global_26832);
  v10 = (const __CFDictionary *)VNIOSurfaceBackedPixelBufferAttributes::pixelBufferAttributes;
  v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (theDict)
  {
    Count = CFDictionaryGetCount(theDict);
    v13 = CFDictionaryGetCount(v10);
    theDict = CFDictionaryCreateMutableCopy(v11, v13 + Count, theDict);
    CFDictionaryApplyFunction(v10, (CFDictionaryApplierFunction)_mergeKeysAndValuesIntoTargetCFMutableDictionary, theDict);
  }
  pixelBufferOut = 0;
  if (theDict)
    v14 = theDict;
  else
    v14 = v10;
  v15 = CVPixelBufferCreate(v11, width, height, pixelFormatType, v14, &pixelBufferOut);
  if (theDict)
    CFRelease(theDict);
  if (!(_DWORD)v15)
    *a5 = pixelBufferOut;
  return v15;
}

void _mergeKeysAndValuesIntoTargetCFMutableDictionary(const void *key, const void *value, CFMutableDictionaryRef theDict)
{
  CFDictionaryAddValue(theDict, key, value);
}

void sub_1A154CF18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  void *v9;
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1A154CFE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  v12 = v11;

  _Unwind_Resume(a1);
}

void sub_1A154D05C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A154D0E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1A154D24C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A154D3F4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A154D678(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_1A154D78C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A154D924(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A154D9FC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A154DC80(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A154DFA4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A154E27C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_1A154E3BC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A154E418(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A154E47C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A154E584(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A154E9D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,char *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  void *v32;
  void *v33;

  __p = &a24;
  std::vector<vision::mod::DetectedObject>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);

  _Unwind_Resume(a1);
}

void sub_1A154EAD4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A154EB48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1A154EDA0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  v7 = v6;

  _Unwind_Resume(a1);
}

void sub_1A154FB50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, uint64_t a17, uint64_t a18, void *a19, id *a20,void *a21,void *a22,uint64_t a23,void *a24,void *a25,void *a26,void *a27,void *a28,void *a29,void *a30,uint64_t a31,void *a32,void *a33,void *a34,uint64_t a35,void *a36,void *a37)
{
  void *v37;
  uint64_t v38;
  void *v40;

  __cxa_guard_abort(&_ZGVZZ128__VNANFDMultiDetector_internalProcessUsingQualityOfServiceClass_options_regionOfInterest_warningRecorder_error_progressHandler__EUb_E27duplicatedObjectToBeRemoved);

  objc_destroyWeak((id *)&STACK[0x310]);
  _Block_object_dispose(&STACK[0x318], 8);
  _Block_object_dispose((const void *)(v38 - 240), 8);

  v40 = *(void **)(v38 - 192);
  if (v40)
  {
    *(_QWORD *)(v38 - 184) = v40;
    operator delete(v40);
  }

  _Unwind_Resume(a1);
}

void sub_1A1550040(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A15507DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, uint64_t a19, void *a20,void *a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41,void *a42,void *a43,void *a44,void *a45,void *a46,void *a47)
{
  void *v47;
  void *v48;

  _Unwind_Resume(a1);
}

void sub_1A1550C88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;

  _Unwind_Resume(a1);
}

void sub_1A1551290(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14)
{
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

void sub_1A15514C4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_1A155155C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1551618(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1A1551D30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,id a56)
{
  void *v56;

  _Block_object_dispose(&a51, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__27154(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__27155(uint64_t a1)
{

}

uint64_t __Block_byref_object_copy__86(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 48) = *(_DWORD *)(a2 + 48);
  return result;
}

void sub_1A15520F8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A155244C()
{
  __break(1u);
}

void sub_1A15524CC()
{
  objc_end_catch();
  JUMPOUT(0x1A15524D4);
}

void sub_1A1552594(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{

  _Unwind_Resume(a1);
}

uint64_t ___Z51VNRecognizedObjectObservationsOnlySortingComparatorv_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v4;
  id v5;
  uint64_t v6;

  v4 = a2;
  v5 = a3;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0 && (objc_opt_isKindOfClass() & 1) != 0)
  {
    v6 = __VNDefaultRecognizedObjectObservationsSortingComparator_block_invoke((uint64_t)&__block_literal_global_91_33192, v4, v5);

  }
  else
  {
    v6 = 0;
  }

  return v6;
}

void sub_1A1552648(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A15526EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{

  _Unwind_Resume(a1);
}

void sub_1A1552790(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{

  _Unwind_Resume(a1);
}

void sub_1A1552918(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1552B54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, void *a17, void *a18)
{
  void *v18;

  _Unwind_Resume(a1);
}

void fftGrayMag(const DSPComplex *a1, _DWORD *a2, float *a3)
{
  _DWORD *v4;
  _DWORD *v6;
  float *v7;
  float *v8;
  float *v9;
  float *v10;
  float *v11;
  DSPComplex *v12;
  uint64_t v13;
  float v14;
  uint64_t v15;
  float *v16;
  float v17;
  OpaqueFFTSetup *fftsetup;
  float *realp;
  float *imagp;
  float *v21;
  float *v22;
  uint64_t i;
  float *v24;
  uint64_t v25;
  int v26;
  float *v27;
  float *v28;
  float *v29;
  float *v30;
  float *v31;
  uint64_t j;
  float v33;
  _DWORD *v34;
  float *v35;
  float *v36;
  uint64_t k;
  float *v38;
  float *v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  float *v43;
  float *v44;
  _DWORD *v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  _DWORD *v49;
  uint64_t v50;
  _DWORD *v51;
  __int128 v52;
  int v53;
  _DWORD *v54;
  uint64_t m;
  __int128 v56;
  int v57;
  _DWORD *v58;
  uint64_t n;
  __int128 v60;
  void *v61;
  void *v62;
  float *v63;
  float *v64;
  DSPSplitComplex v65;
  DSPSplitComplex __C;
  DSPSplitComplex __Z;

  v4 = a2;
  v6 = a2 + 0x8000;
  v7 = a3 + 0x8000;
  v62 = malloc_type_malloc(0x40000uLL, 0x100004052888210uLL);
  v61 = malloc_type_malloc(0x40000uLL, 0x100004052888210uLL);
  v8 = (float *)malloc_type_malloc(0x20000uLL, 0x100004052888210uLL);
  v9 = (float *)malloc_type_malloc(0x20000uLL, 0x100004052888210uLL);
  v10 = (float *)malloc_type_malloc(0x20000uLL, 0x100004052888210uLL);
  v64 = (float *)malloc_type_malloc(0x20000uLL, 0x100004052888210uLL);
  v11 = (float *)malloc_type_malloc(0x20000uLL, 0x100004052888210uLL);
  v63 = (float *)malloc_type_malloc(0x20000uLL, 0x100004052888210uLL);
  v12 = (DSPComplex *)malloc_type_malloc(0x40000uLL, 0x100004052888210uLL);
  bzero(v12, 0x40000uLL);
  v13 = 0;
  do
  {
    v14 = *(float *)((char *)&a1->real + v13) - *(float *)((char *)&a1[32640].real + v13);
    *(float *)((char *)&v12->real + v13) = v14;
    *(float *)((char *)&v12[32640].real + v13) = -v14;
    v13 += 4;
  }
  while ((_DWORD)v13 != 1024);
  v15 = 0;
  do
  {
    v16 = (float *)&v12[v15];
    v17 = a1[v15].real - a1[v15 + 127].imag;
    *v16 = v12[v15].real + v17;
    v16[255] = v12[v15 + 127].imag - v17;
    v15 += 128;
  }
  while ((_DWORD)(v15 * 8) != 0x40000);
  __Z.realp = v11;
  __Z.imagp = v63;
  __C.realp = v8;
  __C.imagp = v9;
  v65.realp = v10;
  v65.imagp = v64;
  vDSP_ctoz(a1, 2, &__Z, 1, 0x8000uLL);
  fftsetup = vDSP_create_fftsetup(8uLL, 0);
  vDSP_fft2d_zrop(fftsetup, &__Z, 1, 0, &__C, 1, 0, 8uLL, 8uLL, 1);
  vDSP_ctoz(v12, 2, &__Z, 1, 0x8000uLL);
  vDSP_fft2d_zrop(fftsetup, &__Z, 1, 0, &v65, 1, 0, 8uLL, 8uLL, 1);
  realp = __C.realp;
  imagp = __C.imagp;
  if (a3)
  {
    v21 = v65.realp;
    v22 = v65.imagp;
    *__C.realp = *__C.realp - (float)(*v65.realp * *a3);
    *imagp = *imagp - (float)(*v22 * a3[128]);
    realp[128] = realp[128] - (float)(v21[128] * *v7);
    imagp[128] = imagp[128] - (float)(v22[128] * v7[128]);
    for (i = 256; i != 0x8000; i += 256)
      realp[i] = realp[i] - (float)(v21[i] * a3[i]);
    v24 = a3 + 384;
    v25 = 0x3FFFFFFFFFFF8100;
    do
    {
      imagp[v25 + 0x8000] = imagp[v25 + 0x8000] - (float)(v22[v25 + 0x8000] * *v24);
      v24 += 256;
      v25 += 256;
    }
    while (v25 * 4);
    v26 = 0;
    v27 = imagp + 1;
    v28 = v22 + 1;
    v29 = realp + 1;
    v30 = v21 + 1;
    v31 = a3 + 1;
    do
    {
      for (j = 0; j != 127; ++j)
      {
        v33 = v31[j];
        v29[j] = v29[j] - (float)(v30[j] * v33);
        v27[j] = v27[j] - (float)(v28[j] * v33);
      }
      ++v26;
      v27 += 128;
      v28 += 128;
      v29 += 128;
      v30 += 128;
      v31 += 256;
    }
    while (v26 != 256);
  }
  *v4 = *(_DWORD *)realp;
  v34 = v4 + 128;
  v4[128] = *(_DWORD *)imagp;
  *v6 = *((_DWORD *)realp + 128);
  v6[128] = *((_DWORD *)imagp + 128);
  v35 = realp + 256;
  v36 = (float *)(v4 + 256);
  for (k = 65280; k != 0x8000; k -= 256)
  {
    *v36 = sqrtf((float)(v35[128] * v35[128]) + (float)(*v35 * *v35));
    *(float *)&v4[k & 0xFFFFFF00] = sqrtf((float)(v35[128] * v35[128]) + (float)(*v35 * *v35));
    v35 += 256;
    v36 += 256;
  }
  v38 = imagp + 256;
  v39 = (float *)(v4 + 384);
  v40 = 127;
  v41 = 65408;
  do
  {
    *v39 = sqrtf((float)(v38[128] * v38[128]) + (float)(*v38 * *v38));
    *(float *)&v4[v41 & 0xFFFFFF80] = sqrtf((float)(v38[128] * v38[128]) + (float)(*v38 * *v38));
    v38 += 256;
    v39 += 256;
    v41 -= 256;
    --v40;
  }
  while (v40);
  v42 = 0;
  v43 = imagp + 1;
  v44 = realp + 1;
  v45 = v4;
  do
  {
    v46 = 0;
    v47 = 255;
    do
    {
      *(float *)&v45[v46 + 1] = sqrtf((float)(v43[v46] * v43[v46]) + (float)(v44[v46] * v44[v46]));
      *(float *)&v45[v47] = sqrtf((float)(v43[v46] * v43[v46]) + (float)(v44[v46] * v44[v46]));
      ++v46;
      --v47;
    }
    while (v46 != 127);
    ++v42;
    v45 += 256;
    v43 += 128;
    v44 += 128;
  }
  while (v42 != 256);
  v48 = 0;
  v49 = v4;
  do
  {
    v50 = 0;
    v51 = v49 + 32896;
    do
    {
      v52 = *(_OWORD *)&v49[v50];
      *(_OWORD *)&v49[v50] = *(_OWORD *)&v51[v50];
      *(_OWORD *)&v51[v50] = v52;
      v50 += 4;
    }
    while (v50 != 128);
    v49 += 256;
    ++v48;
  }
  while (v48 != 128);
  v53 = 0;
  v54 = v6;
  do
  {
    for (m = 0; m != 128; m += 4)
    {
      v56 = *(_OWORD *)&v34[m];
      *(_OWORD *)&v34[m] = *(_OWORD *)&v54[m];
      *(_OWORD *)&v54[m] = v56;
    }
    v34 += 256;
    v54 += 256;
    ++v53;
  }
  while (v53 != 128);
  v57 = 0;
  v58 = v4 + 65280;
  do
  {
    for (n = 0; n != 128; n += 4)
    {
      v60 = *(_OWORD *)&v4[n + 256];
      *(_OWORD *)&v4[n + 256] = *(_OWORD *)&v58[n];
      *(_OWORD *)&v58[n] = v60;
    }
    v58 -= 256;
    ++v57;
    v4 += 256;
  }
  while (v57 != 127);
  vDSP_destroy_fftsetup(fftsetup);
  free(v12);
  free(v11);
  free(v63);
  free(v9);
  free(v8);
  free(v64);
  free(v10);
  free(v62);
  free(v61);
  v6[128] = 0;
}

float fftProject(uint64_t a1, float *a2, float *a3, float a4)
{
  float *v5;
  unsigned int v7;
  int v8;
  char *v9;
  int i;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  float v16;
  float v17;
  uint64_t v18;
  float v19;
  float result;

  v5 = a2;
  v7 = vcvtms_s32_f32(a4 * 126.0);
  v8 = v7 * v7;
  bzero(a2, 0x1680uLL);
  v9 = (char *)malloc_type_malloc(0x1680uLL, 0x100004052888210uLL);
  bzero(v9, 0x1680uLL);
  for (i = -1; i != 127; ++i)
  {
    v11 = vcvtms_s32_f32(sqrtf((float)(15876 - i * i)) + 0.5);
    if (v8 - i * i >= 0 && (v12 = (int)(float)-floorf(sqrtf((float)(v8 - i * i)) + 0.5), v12 < 1))
    {
      innerLoopBlock(-v11, v12 - 1, i, (uint64_t)v5, (uint64_t)v9, a1);
      v13 = 1 - v12;
    }
    else
    {
      v13 = -v11;
    }
    innerLoopBlock(v13, v11, i, (uint64_t)v5, (uint64_t)v9, a1);
  }
  v14 = 0;
  v15 = 0;
  v16 = 0.0;
  do
  {
    v17 = v5[v14] / *(float *)&v9[4 * v14];
    *(float *)&v9[4 * v14] = v17;
    if (v17 > v16)
    {
      v15 = v14;
      v16 = v17;
    }
    ++v14;
  }
  while (v14 != 1440);
  v18 = 5756;
  v19 = 1.0 / v16;
  do
  {
    *v5++ = v19 * *(float *)&v9[v18];
    v18 -= 4;
  }
  while (v18 != -4);
  free(v9);
  result = (float)(1439 - v15) * 0.125;
  *a3 = result;
  return result;
}

void innerLoopBlock(int a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v9;
  float v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  uint64_t v21;
  float v22;
  float v23;
  float v24;
  int v25;
  float v26;

  if (a1 <= a2)
  {
    v9 = a3 * a3;
    v10 = (float)a3;
    v11 = a1;
    v12 = (a3 << 8) + 32896;
    v13 = a2 + 1;
    while (1)
    {
      v15 = atan2f(v10, (float)(int)v11);
      if (v15 < 0.0)
      {
        v16 = v15 + 6.28318531;
        v15 = v16;
      }
      v21 = (v9 + v11 * v11);
      v17 = (float)((float)(0.70711 / sqrtf((float)(int)v21)) * 1440.0) / 3.14159265;
      v18 = v15 / 3.14159265 * 1440.0;
      v19 = v18 - v17;
      v20 = v17 + v18;
      LODWORD(v14) = vcvtms_s32_f32(v19 + 0.5);
      LODWORD(v21) = vcvtms_s32_f32(v20 + 0.5);
      if ((_DWORD)v21 != (_DWORD)v14)
        break;
      if (v14 <= 0x59F)
      {
        v22 = v20 - v19;
        *(float *)(a4 + 4 * v14) = *(float *)(a4 + 4 * v14)
                                                 + (float)(*(float *)(a6 + 4 * (v11 + v12)) * v22);
LABEL_26:
        *(float *)(a5 + 4 * v14) = v22 + *(float *)(a5 + 4 * v14);
      }
LABEL_27:
      if (v13 == (_DWORD)++v11)
        return;
    }
    if ((_DWORD)v21 - (_DWORD)v14 == 1)
    {
      if (v19 >= 0.0 && (int)v14 <= 1439)
      {
        v23 = (float)(v14 + 1) - v19;
        *(float *)(a4 + 4 * (int)v14) = *(float *)(a4 + 4 * (int)v14)
                                        + (float)(*(float *)(a6 + 4 * (v11 + v12)) * v23);
        *(float *)(a5 + 4 * (int)v14) = v23 + *(float *)(a5 + 4 * (int)v14);
      }
      if ((v21 & 0x80000000) != 0 || v20 >= 1440.0)
        goto LABEL_27;
      v22 = (float)(v21 - 1) - v20;
      v24 = *(float *)(a6 + 4 * (v11 + v12));
    }
    else
    {
      v24 = *(float *)(a6 + 4 * (v11 + v12));
      v25 = v14 + 1;
      if ((v14 & 0x80000000) == 0 && v19 < 1440.0)
      {
        v26 = (float)v25 - v19;
        *(float *)(a4 + 4 * v14) = *(float *)(a4 + 4 * v14) + (float)(v24 * v26);
        *(float *)(a5 + 4 * v14) = v26 + *(float *)(a5 + 4 * v14);
      }
      if (v25 < (int)v21)
      {
        do
        {
          if (v25 - 1 >= -1 && v25 <= 1439)
          {
            *(float *)(a4 + 4 * v25) = v24 + *(float *)(a4 + 4 * v25);
            *(float *)(a5 + 4 * v25) = *(float *)(a5 + 4 * v25) + 1.0;
          }
          ++v25;
        }
        while ((_DWORD)v21 != v25);
      }
      if (v21 > 0x59F)
        goto LABEL_27;
      v22 = (float)(v21 - 1) - v20;
    }
    *(float *)(a4 + 4 * v21) = *(float *)(a4 + 4 * v21) + (float)(v24 * v22);
    v14 = v21;
    goto LABEL_26;
  }
}

void vision::mod::GreedyClusterer::~GreedyClusterer(vision::mod::GreedyClusterer *this)
{
  vision::mod::GreedyClusterer::~GreedyClusterer(this);
  JUMPOUT(0x1A1B0A898);
}

{
  char *v2;

  *(_QWORD *)this = &off_1E453A2B8;
  v2 = (char *)this + 24;
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)this + 56);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)this + 40);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)v2);
}

BOOL vision::mod::GreedyClusterer::serializeStatus(vision::mod::GreedyClusterer *this, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  std::string *p_s;
  uint64_t v23;
  std::string *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  char v33;
  char v34;
  std::string::size_type size;
  std::string *p_str;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD *exception;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  void *__p[2];
  char v52;
  std::string __str;
  std::string __s;

  VNValidatedLog(1, (uint64_t)CFSTR("  GreedyClusterer::serializeStatus - enter"), a3, a4, a5, a6, a7, a8, v48);
  if (a2 == -1)
  {
    VNValidatedLog(4, (uint64_t)CFSTR("  GreedyClusterer: Failed to open file - skipping serialization"), v10, v11, v12, v13, v14, v15, v49);
  }
  else
  {
    vision::mod::GreedyClusterer::private_t::clusters_t::newMapFilePath(&__s, *((_QWORD *)this + 7));
    getRelativePath(&__str, *((char **)this + 7), &__s);
    if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_s = &__s;
    else
      p_s = (std::string *)__s.__r_.__value_.__r.__words[0];
    VNValidatedLog(1, (uint64_t)CFSTR("  GreedyClusterer::serializeStatus - saving map file: %s"), v16, v17, v18, v19, v20, v21, (uint64_t)p_s);
    v23 = *((_QWORD *)this + 7);
    if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v24 = &__s;
    else
      v24 = (std::string *)__s.__r_.__value_.__r.__words[0];
    std::string::basic_string[abi:ne180100]<0>(__p, (char *)v24);
    v31 = *(_QWORD *)(v23 + 88);
    if (v31 || (v31 = *(_QWORD *)(v23 + 72)) != 0)
    {
      v32 = cvml::util::MMapFileBackingStore::writeToFile(v31, (uint64_t)__p);
      v33 = 0;
    }
    else
    {
      v32 = 0;
      v33 = 1;
    }
    if (v52 < 0)
      operator delete(__p[0]);
    if (v32)
      v34 = v33;
    else
      v34 = 1;
    if ((v34 & 1) != 0)
    {
      VNValidatedLog(4, (uint64_t)CFSTR("  GreedyClusterer: failed to save the file"), v25, v26, v27, v28, v29, v30, v50);
      exception = __cxa_allocate_exception(8uLL);
      *exception = 5236;
      __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
    }
    size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      size = __str.__r_.__value_.__l.__size_;
    __p[0] = (void *)size;
    write(a2, __p, 8uLL);
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_str = &__str;
    else
      p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
    write(a2, p_str, (size_t)__p[0]);
    std::string::operator=((std::string *)(*((_QWORD *)this + 7) + 24), &__str);
    write(a2, (const void *)(*((_QWORD *)this + 7) + 104), 4uLL);
    write(a2, (const void *)(*((_QWORD *)this + 7) + 112), 8uLL);
    __p[0] = (void *)((uint64_t)(*(_QWORD *)(*((_QWORD *)this + 7) + 56) - *(_QWORD *)(*((_QWORD *)this + 7) + 48)) >> 2);
    write(a2, __p, 8uLL);
    v43 = *(_QWORD *)(*((_QWORD *)this + 7) + 48);
    if ((int)((unint64_t)(*(_QWORD *)(*((_QWORD *)this + 7) + 56) - v43) >> 2) >= 1)
    {
      v44 = 0;
      v45 = 0;
      do
      {
        write(a2, (const void *)(v43 + v44), 4uLL);
        ++v45;
        v43 = *(_QWORD *)(*((_QWORD *)this + 7) + 48);
        v44 += 4;
      }
      while (v45 < (int)((unint64_t)(*(_QWORD *)(*((_QWORD *)this + 7) + 56) - v43) >> 2));
    }
    VNValidatedLog(1, (uint64_t)CFSTR("  GreedyClusterer::serializeStatus - done"), v37, v38, v39, v40, v41, v42, v50);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__str.__r_.__value_.__l.__data_);
    if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__s.__r_.__value_.__l.__data_);
  }
  return a2 != -1;
}

void sub_1A1553A18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a21 < 0)
    operator delete(__p);
  if (a27 < 0)
    operator delete(a22);
  _Unwind_Resume(exception_object);
}

uint64_t vision::mod::GreedyClusterer::deserializeStatus(vision::mod::GreedyClusterer *this, int a2, int a3)
{
  void **v6;
  uint64_t OnlyFromContentsOfFile;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v25;
  int v26;
  std::vector<int>::size_type __sz;
  std::string __p;
  void *__b[2];
  char v30;
  size_t v31;

  v31 = 0;
  read(a2, &v31, 8uLL);
  std::string::basic_string[abi:ne180100](__b, v31, 48);
  if (v30 >= 0)
    v6 = __b;
  else
    v6 = (void **)__b[0];
  read(a2, v6, v31);
  createFullPath(&__p, *((_QWORD *)this + 7), (uint64_t)__b);
  if (a3)
  {
    OnlyFromContentsOfFile = cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>::createReadOnlyFromContentsOfFile((uint64_t)&__p);
    v8 = *((_QWORD *)this + 7);
    std::shared_ptr<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>>::reset[abi:ne180100]((_QWORD *)(v8 + 72));
    std::shared_ptr<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore> const>::reset[abi:ne180100]<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore> const,void>(v8 + 88, OnlyFromContentsOfFile);
  }
  else
  {
    v15 = cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>::createFromContentsOfFile((uint64_t)&__p);
    v16 = (uint64_t *)*((_QWORD *)this + 7);
    std::shared_ptr<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>>::reset[abi:ne180100]<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>,void>((uint64_t)(v16 + 9), v15);
    std::shared_ptr<vision::mod::ImageDescriptorProcessorAbstract>::operator=[abi:ne180100](v16 + 11, v16[9], v16[10]);
  }
  v17 = (_QWORD *)*((_QWORD *)this + 7);
  v18 = v17[11];
  if (v17[9])
  {
    if (!v18)
      v18 = v17[9];
  }
  else if (!v18)
  {
    VNValidatedLog(4, (uint64_t)CFSTR("  GreedyClusterer::deserializeStatus - failed to load memory map file"), v9, v10, v11, v12, v13, v14, v25);
    goto LABEL_19;
  }
  if (*(_DWORD *)(*(_QWORD *)v18 + 16) != 528)
  {
    VNValidatedLog(4, (uint64_t)CFSTR("  GreedyClusterer::deserializeStatus - loaded a corrupt file as expected element size does not match"), v9, v10, v11, v12, v13, v14, v25);
    v23 = *((_QWORD *)this + 7);
    std::shared_ptr<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>>::reset[abi:ne180100]((_QWORD *)(v23 + 72));
    std::shared_ptr<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>>::reset[abi:ne180100]((_QWORD *)(v23 + 88));
LABEL_19:
    v22 = 0;
    goto LABEL_20;
  }
  read(a2, v17 + 13, 4uLL);
  read(a2, (void *)(*((_QWORD *)this + 7) + 112), 8uLL);
  __sz = 0;
  read(a2, &__sz, 8uLL);
  std::vector<unsigned int>::resize((std::vector<int> *)(*((_QWORD *)this + 7) + 48), __sz);
  if ((int)((*(_QWORD *)(*((_QWORD *)this + 7) + 56) - *(_QWORD *)(*((_QWORD *)this + 7) + 48)) >> 2) >= 1)
  {
    v19 = 0;
    do
    {
      v26 = 0;
      read(a2, &v26, 4uLL);
      v20 = *((_QWORD *)this + 7);
      v21 = *(_QWORD *)(v20 + 48);
      *(_DWORD *)(v21 + 4 * v19++) = v26;
    }
    while (v19 < (int)((unint64_t)(*(_QWORD *)(v20 + 56) - v21) >> 2));
  }
  v22 = 1;
LABEL_20:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (v30 < 0)
    operator delete(__b[0]);
  return v22;
}

void sub_1A1553C8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a17 < 0)
    operator delete(__p);
  if (a23 < 0)
    operator delete(a18);
  _Unwind_Resume(exception_object);
}

void sub_1A1553DC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  if (a15 < 0)
    operator delete(__p);
  if (*(char *)(v15 + 23) < 0)
    operator delete(*(void **)v15);
  _Unwind_Resume(exception_object);
}

void vision::mod::GreedyClusterer::private_t::clusters_t::newMapFilePath(std::string *a1, uint64_t a2)
{
  int v4;
  const std::string::value_type *v5;
  std::string::size_type v6;
  std::string *v7;
  __int128 v8;
  void **v9;
  std::string::size_type v10;
  std::string *v11;
  void *__p[2];
  unsigned __int8 v13;
  std::string v14;
  std::string v15;
  char out[40];
  unsigned __int8 uu[8];
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)uu = 0;
  v18 = 0;
  MEMORY[0x1A1B0B8E8](uu);
  memset(out, 0, 37);
  uuid_unparse(uu, out);
  std::string::basic_string[abi:ne180100]<0>(&v14, out);
  v4 = *(char *)(a2 + 23);
  if (v4 >= 0)
    v5 = (const std::string::value_type *)a2;
  else
    v5 = *(const std::string::value_type **)a2;
  if (v4 >= 0)
    v6 = *(unsigned __int8 *)(a2 + 23);
  else
    v6 = *(_QWORD *)(a2 + 8);
  v7 = std::string::insert(&v14, 0, v5, v6);
  v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
  v15.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v15.__r_.__value_.__l.__data_ = v8;
  v7->__r_.__value_.__l.__size_ = 0;
  v7->__r_.__value_.__r.__words[2] = 0;
  v7->__r_.__value_.__r.__words[0] = 0;
  std::string::basic_string[abi:ne180100]<0>(__p, ".cmap");
  if ((v13 & 0x80u) == 0)
    v9 = __p;
  else
    v9 = (void **)__p[0];
  if ((v13 & 0x80u) == 0)
    v10 = v13;
  else
    v10 = (std::string::size_type)__p[1];
  v11 = std::string::append(&v15, (const std::string::value_type *)v9, v10);
  *a1 = *v11;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  if ((char)v13 < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v15.__r_.__value_.__l.__data_);
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v14.__r_.__value_.__l.__data_);
}

void sub_1A1553F34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0)
    operator delete(__p);
  if (a26 < 0)
    operator delete(a21);
  if (a20 < 0)
    operator delete(a15);
  _Unwind_Resume(exception_object);
}

void vision::mod::GreedyClustererFaces::~GreedyClustererFaces(vision::mod::GreedyClustererFaces *this)
{
  vision::mod::GreedyClustererFaces::~GreedyClustererFaces(this);
  JUMPOUT(0x1A1B0A898);
}

{
  vision::mod::GreedyClusterer *v2;

  *(_QWORD *)this = &off_1E453A450;
  *((_QWORD *)this + 1) = &unk_1E453A530;
  v2 = (vision::mod::GreedyClustererFaces *)((char *)this + 8);
  if (*((char *)this + 207) < 0)
    operator delete(*((void **)this + 23));
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*((_QWORD **)this + 21));
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*((_QWORD **)this + 18));
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*((_QWORD **)this + 15));
  std::__tree<std::__value_type<unsigned long,std::list<long long>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::list<long long>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::list<long long>>>>::destroy(*((_QWORD **)this + 12));
  vision::mod::GreedyClusterer::~GreedyClusterer(v2);
}

uint64_t vision::mod::GreedyClustererFaces::update(uint64_t a1, _QWORD *lpsrc, uint64_t **a3)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t updated;
  double v10;
  unint64_t *v11;
  float *v12;
  float *v13;
  float *v21;
  float v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  float v28;
  float v29;
  float v30;
  char v31;
  char v32;
  std::__shared_weak_count *v33;
  unint64_t *p_shared_owners;
  unint64_t v35;
  unint64_t *v36;
  std::__shared_weak_count *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  void *__p;
  float *v42;
  uint64_t v43;

  if (!v6)
    return 5244;
  v7 = v6[12];
  if (v7 != 129)
  {
    if (v7 == 128)
    {
      __p = 0;
      v42 = 0;
      v43 = 0;
      v38 = 0;
      v39 = 0;
      v40 = 0;
      return vision::mod::GreedyClustererFaces::updateInternal(a1, lpsrc, &__p, &v38, a3);
    }
    return 5244;
  }
  __p = 0;
  v42 = 0;
  v43 = 0;
  vision::mod::descriptorBufferUnpackedScores(&v36, lpsrc, (uint64_t)&__p, 128);
  v11 = v36;
  v12 = (float *)__p;
  v13 = v42;
  if (__p != v42)
  {
    __asm
    {
      FMOV            V3.2S, #1.0
      FMOV            V4.2D, #-2.0
      FMOV            V5.2D, #3.0
    }
    v21 = (float *)__p;
    do
    {
      *(float *)&v10 = *v21;
      v22 = 1.0;
      if (*v21 >= -0.5)
      {
        v23 = vdiv_f32(vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&v10, 0), (float32x2_t)0xBF7EB852BF79999ALL), (float32x2_t)0x3BA3D7003C9374A0);
        v24 = (float32x2_t)vbic_s8((int8x8_t)v23, (int8x8_t)vcltz_f32(v23));
        v25 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v24, _D3), (int8x8_t)_D3, (int8x8_t)v24);
        v26 = vmla_f32(_D3, (float32x2_t)0xBEB2B020BE99999ALL, vcvt_f32_f64(vmulq_f64(vmlaq_f64(_Q5, _Q4, vcvtq_f64_f32(v25)), vcvtq_f64_f32(vmul_f32(v25, v25)))));
        v27 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v26, _D3), (int8x8_t)_D3, (int8x8_t)v26);
        v28 = (float)(*(float *)&v10 + -0.96) / 0.01;
        if (v28 < 0.0)
          v28 = 0.0;
        if (v28 > 1.0)
          v28 = 1.0;
        v29 = (v28 * -2.0 + 3.0) * (float)(v28 * v28);
        v30 = (float)(v29 * 0.349) + 0.651;
        if (v30 > 1.0)
          v30 = 1.0;
        v10 = (float)(v30 * vmul_lane_f32(v27, v27, 1).f32[0]) * 1.25 / 1.1;
        v22 = v10;
      }
      *v21++ = v22;
    }
    while (v21 != v13);
  }
  v31 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 8))(*(_QWORD *)(a1 + 32));
  if (v12 == v13)
    v32 = 1;
  else
    v32 = v31;
  if ((v32 & 1) == 0)
    memset_pattern16(v12, &unk_1A15FB810, (((char *)v13 - (char *)v12 - 4) & 0xFFFFFFFFFFFFFFFCLL) + 4);
  v38 = 0;
  v39 = 0;
  v40 = 0;
  updated = vision::mod::GreedyClustererFaces::updateInternal(a1, v11, &__p, &v38, a3);
  v33 = v37;
  if (v37)
  {
    p_shared_owners = (unint64_t *)&v37->__shared_owners_;
    do
      v35 = __ldaxr(p_shared_owners);
    while (__stlxr(v35 - 1, p_shared_owners));
    if (!v35)
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
    }
  }
  if (__p)
    operator delete(__p);
  return updated;
}

void sub_1A1554294(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v9;

  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  if (v9)
    operator delete(v9);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::GreedyClustererFaces::remove()
{
  return 5248;
}

uint64_t vision::mod::GreedyClustererFaces::affinityForFace(vision::mod::GreedyClustererFaces *a1, uint64_t *a2, _QWORD *a3, uint64_t a4)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  _QWORD *v15;
  std::__shared_weak_count *v16;
  void *__p[3];

  if (vision::mod::GreedyClustererFaces::isFaceIdInClustererState(a1, (uint64_t)a2))
  {
    if (v8)
    {
      v9 = v8[12];
      if (v9 == 129)
      {
        memset(__p, 0, sizeof(__p));
        vision::mod::descriptorBufferUnpackedScores(&v15, a3, (uint64_t)__p, 128);
        v11 = vision::mod::GreedyClustererFaces::affinityForFaceInternal((uint64_t)a1, a2, v15, a4);
        v12 = v16;
        if (v16)
        {
          p_shared_owners = (unint64_t *)&v16->__shared_owners_;
          do
            v14 = __ldaxr(p_shared_owners);
          while (__stlxr(v14 - 1, p_shared_owners));
          if (!v14)
          {
            ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
            std::__shared_weak_count::__release_weak(v12);
          }
        }
        if (__p[0])
          operator delete(__p[0]);
        return v11;
      }
      if (v9 == 128)
        return vision::mod::GreedyClustererFaces::affinityForFaceInternal((uint64_t)a1, a2, a3, a4);
    }
  }
  return 5244;
}

void sub_1A15543E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p)
{
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a10);
  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(uint64_t a1, uint64_t a2, void **a3, uint64_t **a4)
{
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  _BYTE *v12;
  uint64_t v13;
  unint64_t v14;
  float v15;
  uint64_t *v16;
  double v17;
  unint64_t v18;
  const void *v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  vDSP_Length v23;
  float v24;
  uint64_t *v25;
  uint64_t **v26;
  BOOL v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  _BYTE *v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t *v39;
  uint64_t v40;
  float v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  _QWORD *v45;
  _QWORD *v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  _QWORD *v52;
  char *v53;
  char *v54;
  _QWORD *v55;
  _QWORD *v57;
  _QWORD *exception;
  uint64_t v59;
  char *v60;
  uint64_t v62;
  void *v63;
  void *v64;
  uint64_t v65;
  float *__B[3];
  float *__A[3];
  _BYTE v68[260];
  float __C[3];

  vision::mod::dist_greedy_status_t::dist_greedy_status_t((uint64_t)v68, *(_DWORD *)(*(_QWORD *)(a1 + 64) + 104), *(_DWORD *)(a1 + 28));
  v7 = *(int *)(*(_QWORD *)(a1 + 64) + 104);
  LODWORD(v62) = 0;
  std::vector<float>::vector(__A, v7, &v62);
  v8 = *(int *)(*(_QWORD *)(a1 + 64) + 104);
  LODWORD(v62) = 0;
  std::vector<float>::vector(__B, v8, &v62);
  v9 = *(_QWORD *)(a1 + 152);
  if (v9)
  {
    if (v9 >> 60)
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<vision::mod::DescriptorItemSideInfo>>(v9);
    v60 = &v10[16 * v11];
    v12 = v10;
  }
  else
  {
    v12 = 0;
    v60 = 0;
  }
  v13 = *(_QWORD *)(a1 + 64);
  if (*(_BYTE *)(v13 + 120))
  {
    *(_BYTE *)(v13 + 120) = 0;
    exception = __cxa_allocate_exception(8uLL);
    *exception = 5219;
    __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
  }
  vision::mod::GreedyClustererFaces::getAverageDescriptorOfClusterContainingFace((_QWORD *)a1, a2, (uint64_t)a4, __A[0]);
  v14 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 200))(a1, a2);
  v59 = a2;
  v15 = 0.0;
  if (v14 <= 0xA)
    v15 = (float)((float)((float)((float)v14 + -1.0) / -10.0) + 1.0) * 0.05;
  v16 = *a4;
  if (*a4 != (uint64_t *)(a4 + 1))
  {
    v17 = *(float *)(*(_QWORD *)(a1 + 32) + 8) * 1.1;
    v18 = (unint64_t)v12;
    while (1)
    {
      v19 = (const void *)v16[5];
      v62 = v16[4];
      v64 = 0;
      v65 = 0;
      v63 = 0;
      std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>(&v63, v19, v16[6], (v16[6] - (uint64_t)v19) >> 3);
      v20 = v63;
      if (v64 == v63)
      {
        v20 = v64;
      }
      else
      {
        v21 = *(_QWORD *)(a1 + 64);
        if (*(_BYTE *)(v21 + 120))
        {
          *(_BYTE *)(v21 + 120) = 0;
          v57 = __cxa_allocate_exception(8uLL);
          *v57 = 5219;
          __cxa_throw(v57, MEMORY[0x1E0DE4F28], 0);
        }
        v22 = v62;
        vision::mod::GreedyClustererFaces::getAverageDescriptorOfClusterContainingFace((_QWORD *)a1, v62, (uint64_t)a4, __B[0]);
        v23 = *(int *)(*(_QWORD *)(a1 + 64) + 104);
        __C[0] = 0.0;
        vDSP_dotpr(__A[0], 1, __B[0], 1, __C, v23);
        v24 = (float)((float)(__C[0] + 1.0) * -0.5) + 1.0;
        if (v17 > (float)(v15 + v24))
        {
          if (v18 >= (unint64_t)v60)
          {
            v28 = (uint64_t)(v18 - (_QWORD)v12) >> 4;
            v29 = v28 + 1;
            if ((unint64_t)(v28 + 1) >> 60)
              std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
            if ((v60 - v12) >> 3 > v29)
              v29 = (v60 - v12) >> 3;
            if ((unint64_t)(v60 - v12) >= 0x7FFFFFFFFFFFFFF0)
              v30 = 0xFFFFFFFFFFFFFFFLL;
            else
              v30 = v29;
            if (v30)
              v30 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<vision::mod::DescriptorItemSideInfo>>(v30);
            else
              v31 = 0;
            v32 = v30 + 16 * v28;
            *(_QWORD *)v32 = v22;
            *(float *)(v32 + 8) = v24;
            if ((_BYTE *)v18 == v12)
            {
              v34 = (_BYTE *)(v30 + 16 * v28);
            }
            else
            {
              v33 = v30 + 16 * v28;
              do
              {
                v34 = (_BYTE *)(v33 - 16);
                *(_OWORD *)(v33 - 16) = *(_OWORD *)(v18 - 16);
                v18 -= 16;
                v33 -= 16;
              }
              while ((_BYTE *)v18 != v12);
            }
            v60 = (char *)(v30 + 16 * v31);
            v18 = v32 + 16;
            if (v12)
              operator delete(v12);
            v12 = v34;
          }
          else
          {
            *(_QWORD *)v18 = v22;
            *(float *)(v18 + 8) = v24;
            v18 += 16;
          }
          v20 = v63;
          if (!v63)
            goto LABEL_18;
LABEL_17:
          v64 = v20;
          operator delete(v20);
          goto LABEL_18;
        }
      }
      if (v20)
        goto LABEL_17;
LABEL_18:
      v25 = (uint64_t *)v16[1];
      if (v25)
      {
        do
        {
          v26 = (uint64_t **)v25;
          v25 = (uint64_t *)*v25;
        }
        while (v25);
      }
      else
      {
        do
        {
          v26 = (uint64_t **)v16[2];
          v27 = *v26 == v16;
          v16 = (uint64_t *)v26;
        }
        while (!v27);
      }
      v16 = (uint64_t *)v26;
      if (v26 == a4 + 1)
        goto LABEL_45;
    }
  }
  v18 = (unint64_t)v12;
LABEL_45:
  v35 = 126 - 2 * __clz((uint64_t)(v18 - (_QWORD)v12) >> 4);
  if ((_BYTE *)v18 == v12)
    v36 = 0;
  else
    v36 = v35;
  std::__introsort<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *,false>((float *)v12, v18, v36, 1);
  v37 = v59;
  if ((_BYTE *)v18 != v12)
  {
    v38 = (uint64_t *)v12;
    do
    {
      v62 = *v38;
      v39 = std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(a4, v62, &v62);
      v40 = *std::map<long long,unsigned long>::at(*(_QWORD **)(a1 + 144), *v38);
      if (v40 != *std::map<long long,unsigned long>::at(*(_QWORD **)(a1 + 144), v37))
      {
        v41 = 1.0 - *((float *)v38 + 2);
        v42 = *(_QWORD *)v39[5];
        v43 = LODWORD(v41);
        v45 = a3[1];
        v44 = (unint64_t)a3[2];
        if ((unint64_t)v45 >= v44)
        {
          v47 = ((char *)v45 - (_BYTE *)*a3) >> 4;
          v48 = v47 + 1;
          if ((unint64_t)(v47 + 1) >> 60)
            std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
          v49 = v44 - (_QWORD)*a3;
          if (v49 >> 3 > v48)
            v48 = v49 >> 3;
          if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF0)
            v50 = 0xFFFFFFFFFFFFFFFLL;
          else
            v50 = v48;
          if (v50)
            v50 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<vision::mod::DescriptorItemSideInfo>>(v50);
          else
            v51 = 0;
          v52 = (_QWORD *)(v50 + 16 * v47);
          *v52 = v42;
          v52[1] = v43;
          v54 = (char *)*a3;
          v53 = (char *)a3[1];
          v55 = v52;
          if (v53 == *a3)
          {
            v37 = v59;
          }
          else
          {
            v37 = v59;
            do
            {
              *((_OWORD *)v55 - 1) = *((_OWORD *)v53 - 1);
              v55 -= 2;
              v53 -= 16;
            }
            while (v53 != v54);
            v53 = (char *)*a3;
          }
          v46 = v52 + 2;
          *a3 = v55;
          a3[1] = v52 + 2;
          a3[2] = (void *)(v50 + 16 * v51);
          if (v53)
            operator delete(v53);
        }
        else
        {
          *v45 = v42;
          v45[1] = LODWORD(v41);
          v46 = v45 + 2;
          v37 = v59;
        }
        a3[1] = v46;
      }
      v38 += 2;
    }
    while (v38 != (uint64_t *)v18);
  }
  if (v12)
    operator delete(v12);
  if (__B[0])
  {
    __B[1] = __B[0];
    operator delete(__B[0]);
  }
  if (__A[0])
  {
    __A[1] = __A[0];
    operator delete(__A[0]);
  }
  vision::mod::dist_greedy_status_t::~dist_greedy_status_t((vision::mod::dist_greedy_status_t *)v68);
  return 5248;
}

void sub_1A1554950(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,char a23)
{
  void *v23;

  if (v23)
    operator delete(v23);
  if (__p)
    operator delete(__p);
  if (a20)
    operator delete(a20);
  vision::mod::dist_greedy_status_t::~dist_greedy_status_t((vision::mod::dist_greedy_status_t *)&a23);
  _Unwind_Resume(a1);
}

void vision::mod::GreedyClustererFaces::serialize(vision::mod::GreedyClustererFaces *this@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X7>, _QWORD *a8@<X8>)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  std::string *p_s;
  std::string *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  vision::mod::GreedyClustererFaces *v26;
  vision::mod::GreedyClustererFaces *v27;
  vision::mod::GreedyClustererFaces *v28;
  BOOL v29;
  vision::mod::GreedyClustererFaces *v30;
  vision::mod::GreedyClustererFaces *v31;
  vision::mod::GreedyClustererFaces *v32;
  std::string::size_type size;
  uint64_t v34;
  _QWORD *v35;
  unsigned __int8 *v36;
  std::string *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  std::string *p_buf;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  std::string *p_str;
  std::__shared_weak_count *v53;
  unint64_t *v54;
  unint64_t v55;
  _QWORD *v56;
  uint64_t v57;
  uint64_t v58;
  std::string __str;
  std::string __buf;
  __int128 v61;
  std::string __s;

  VNValidatedLog(1, (uint64_t)CFSTR("  GreedyClustererFaces::serialize - enter"), a2, a3, a4, a5, a6, a7, v57);
  v10 = *((_QWORD *)this + 8);
  if (*(_QWORD *)(v10 + 72) || *(_QWORD *)(v10 + 88))
  {
    vision::mod::GreedyClusterer::private_t::clusters_t::newMapFilePath(&__s, v10);
    if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_s = &__s;
    else
      p_s = (std::string *)__s.__r_.__value_.__r.__words[0];
    VNValidatedLog(1, (uint64_t)CFSTR("  GreedyClustererFaces::serialize - cachefile: %s"), v11, v12, v13, v14, v15, v16, (uint64_t)p_s);
    if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v18 = &__s;
    else
      v18 = (std::string *)__s.__r_.__value_.__r.__words[0];
    v25 = open((const char *)v18, 1537, 438);
    if (v25 == -1)
    {
      VNValidatedLog(4, (uint64_t)CFSTR("  GreedyClustererFaces::serialize - error creating new map file for serialization"), v19, v20, v21, v22, v23, v24, v58);
      *a8 = 0;
      a8[1] = 0;
    }
    else
    {
      vision::mod::GreedyClusterer::serializeStatus((vision::mod::GreedyClustererFaces *)((char *)this + 8), v25, v19, v20, v21, v22, v23, v24);
      __buf.__r_.__value_.__r.__words[0] = *((_QWORD *)this + 16);
      write(v25, &__buf, 8uLL);
      v26 = (vision::mod::GreedyClustererFaces *)*((_QWORD *)this + 14);
      if (v26 != (vision::mod::GreedyClustererFaces *)((char *)this + 120))
      {
        do
        {
          write(v25, (char *)v26 + 32, 8uLL);
          write(v25, (char *)v26 + 40, 8uLL);
          v27 = (vision::mod::GreedyClustererFaces *)*((_QWORD *)v26 + 1);
          if (v27)
          {
            do
            {
              v28 = v27;
              v27 = *(vision::mod::GreedyClustererFaces **)v27;
            }
            while (v27);
          }
          else
          {
            do
            {
              v28 = (vision::mod::GreedyClustererFaces *)*((_QWORD *)v26 + 2);
              v29 = *(_QWORD *)v28 == (_QWORD)v26;
              v26 = v28;
            }
            while (!v29);
          }
          v26 = v28;
        }
        while (v28 != (vision::mod::GreedyClustererFaces *)((char *)this + 120));
      }
      __buf.__r_.__value_.__r.__words[0] = *((_QWORD *)this + 19);
      write(v25, &__buf, 8uLL);
      v30 = (vision::mod::GreedyClustererFaces *)*((_QWORD *)this + 17);
      if (v30 != (vision::mod::GreedyClustererFaces *)((char *)this + 144))
      {
        do
        {
          write(v25, (char *)v30 + 32, 8uLL);
          write(v25, (char *)v30 + 40, 8uLL);
          v31 = (vision::mod::GreedyClustererFaces *)*((_QWORD *)v30 + 1);
          if (v31)
          {
            do
            {
              v32 = v31;
              v31 = *(vision::mod::GreedyClustererFaces **)v31;
            }
            while (v31);
          }
          else
          {
            do
            {
              v32 = (vision::mod::GreedyClustererFaces *)*((_QWORD *)v30 + 2);
              v29 = *(_QWORD *)v32 == (_QWORD)v30;
              v30 = v32;
            }
            while (!v29);
          }
          v30 = v32;
        }
        while (v32 != (vision::mod::GreedyClustererFaces *)((char *)this + 144));
      }
      close(v25);
      size = HIBYTE(__s.__r_.__value_.__r.__words[2]);
      if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        size = __s.__r_.__value_.__l.__size_;
      std::allocate_shared[abi:ne180100]<std::vector<unsigned char>,std::allocator<std::vector<unsigned char>>,unsigned long,void>(&v61, size + 53);
      v34 = *(_QWORD *)v61;
      v35 = *(_QWORD **)v61;
      *v35 = 0x2714C1457E25;
      v36 = (unsigned __int8 *)(v35 + 3);
      if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v37 = &__s;
      else
        v37 = (std::string *)__s.__r_.__value_.__r.__words[0];
      if ((calculateChecksumMD5ForFile((const char *)v37, v36) & 1) != 0)
      {
        createFullPath(&__buf, *((_QWORD *)this + 8), *((_QWORD *)this + 8) + 24);
        if ((__buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          p_buf = &__buf;
        else
          p_buf = (std::string *)__buf.__r_.__value_.__r.__words[0];
        if ((calculateChecksumMD5ForFile((const char *)p_buf, (unsigned __int8 *)(v34 + 8)) & 1) == 0)
          VNValidatedLog(4, (uint64_t)CFSTR("  GreedyClustererFaces::serialize - error calculating checksum for cluster data file"), v45, v46, v47, v48, v49, v50, v58);
        getRelativePath(&__str, *((char **)this + 8), &__s);
        v51 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          p_str = &__str;
        }
        else
        {
          v51 = __str.__r_.__value_.__r.__words[1];
          p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)(v34 + 40) = v51;
        memcpy((void *)(v34 + 44), p_str, (v51 + 1));
        std::string::operator=((std::string *)((char *)this + 184), &__str);
        *(_OWORD *)a8 = v61;
        v61 = 0uLL;
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__str.__r_.__value_.__l.__data_);
        if (SHIBYTE(__buf.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__buf.__r_.__value_.__l.__data_);
      }
      else
      {
        VNValidatedLog(4, (uint64_t)CFSTR("  GreedyClustererFaces::serialize - error calculating checksum for cluster data file"), v38, v39, v40, v41, v42, v43, v58);
        *a8 = 0;
        a8[1] = 0;
        v53 = (std::__shared_weak_count *)*((_QWORD *)&v61 + 1);
        if (*((_QWORD *)&v61 + 1))
        {
          v54 = (unint64_t *)(*((_QWORD *)&v61 + 1) + 8);
          do
            v55 = __ldaxr(v54);
          while (__stlxr(v55 - 1, v54));
          if (!v55)
          {
            ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
            std::__shared_weak_count::__release_weak(v53);
          }
        }
      }
    }
    if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__s.__r_.__value_.__l.__data_);
  }
  else
  {
    v56 = operator new(0x30uLL);
    v56[1] = 0;
    v56[2] = 0;
    *v56 = &off_1E453BC30;
    v56[4] = 0;
    v56[5] = 0;
    a8[1] = v56;
    v56[3] = 0;
    *a8 = v56 + 3;
  }
}

void sub_1A1554D58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,char a23)
{
  uint64_t v23;

  if (a22 < 0)
    operator delete(__p);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a23);
  if (*(char *)(v23 - 49) < 0)
    operator delete(*(void **)(v23 - 72));
  _Unwind_Resume(a1);
}

uint64_t vision::mod::GreedyClustererFaces::anomalyForGroup(vision::mod::GreedyClustererFaces *a1, uint64_t **a2, uint64_t a3, _DWORD *a4)
{
  uint64_t *v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t *v15;
  uint64_t *v16;
  unint64_t v17;
  char *v18;
  _QWORD *v19;
  char *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  BOOL v30;
  _QWORD *v31;
  void *v32;
  unint64_t v33;
  uint64_t *v34;
  int v35;
  unint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  void *v39;
  unint64_t v40;
  void *v41;
  float v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  _BYTE *v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t *v55;
  _QWORD *v56[3];
  void *v57[7];
  void *v58;
  unint64_t v59;
  int v60;
  void *v61;
  void *__p;
  _BYTE *v63;
  _OWORD v64[3];
  void *v65;
  unint64_t v66;
  int v67;
  void *v68;
  uint64_t *v69;
  _QWORD *v70[3];

  if (vision::mod::GreedyClustererFaces::isFaceIdInClustererState(a1, a3))
  {
    v9 = *a2;
    v8 = a2[1];
    if (v8 != *a2)
    {
      v10 = (_QWORD *)((char *)a1 + 144);
      if (*((_QWORD *)a1 + 18))
      {
        while (1)
        {
          v11 = *v9;
          v12 = (_QWORD *)*((_QWORD *)a1 + 18);
          while (1)
          {
            v13 = v12[4];
            if (v11 >= v13)
              break;
LABEL_8:
            v12 = (_QWORD *)*v12;
            if (!v12)
              goto LABEL_42;
          }
          if (v13 < v11)
            break;
          if (++v9 == v8)
          {
            v70[0] = 0;
            v70[1] = 0;
            v69 = (uint64_t *)v70;
            v14 = (_QWORD *)*((_QWORD *)a1 + 17);
            if (v14 != v10)
            {
              do
              {
                v64[0] = *((_OWORD *)v14 + 2);
                v15 = std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(&v69, *((uint64_t *)&v64[0] + 1), (uint64_t *)v64 + 1);
                v16 = v15;
                v18 = (char *)v15[6];
                v17 = v15[7];
                if ((unint64_t)v18 >= v17)
                {
                  v20 = (char *)v15[5];
                  v21 = (v18 - v20) >> 3;
                  v22 = v21 + 1;
                  if ((unint64_t)(v21 + 1) >> 61)
                    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
                  v23 = v17 - (_QWORD)v20;
                  if (v23 >> 2 > v22)
                    v22 = v23 >> 2;
                  if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8)
                    v24 = 0x1FFFFFFFFFFFFFFFLL;
                  else
                    v24 = v22;
                  if (v24)
                  {
                    v24 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v24);
                    v20 = (char *)v16[5];
                    v18 = (char *)v16[6];
                  }
                  else
                  {
                    v25 = 0;
                  }
                  v26 = (_QWORD *)(v24 + 8 * v21);
                  *v26 = *(_QWORD *)&v64[0];
                  v19 = v26 + 1;
                  while (v18 != v20)
                  {
                    v27 = *((_QWORD *)v18 - 1);
                    v18 -= 8;
                    *--v26 = v27;
                  }
                  v16[5] = (uint64_t)v26;
                  v16[6] = (uint64_t)v19;
                  v16[7] = v24 + 8 * v25;
                  if (v20)
                    operator delete(v20);
                }
                else
                {
                  *(_QWORD *)v18 = *(_QWORD *)&v64[0];
                  v19 = v18 + 8;
                }
                v16[6] = (uint64_t)v19;
                v28 = (_QWORD *)v14[1];
                if (v28)
                {
                  do
                  {
                    v29 = v28;
                    v28 = (_QWORD *)*v28;
                  }
                  while (v28);
                }
                else
                {
                  do
                  {
                    v29 = (_QWORD *)v14[2];
                    v30 = *v29 == (_QWORD)v14;
                    v14 = v29;
                  }
                  while (!v30);
                }
                v14 = v29;
              }
              while (v29 != v10);
            }
            v31 = operator new(8uLL);
            *v31 = a3;
            v57[1] = v31 + 1;
            v57[2] = v31 + 1;
            v57[0] = v31;
            v32 = malloc_type_malloc(4 * *(int *)(*((_QWORD *)a1 + 8) + 104), 0x100004052888210uLL);
            v33 = *(int *)(*((_QWORD *)a1 + 8) + 104);
            vision::mod::ImageDescriptorBufferAbstract::ImageDescriptorBufferAbstract((uint64_t)v64, (_QWORD **)v57, v32, v33, 1, 1);
            v67 = 1;
            v68 = 0;
            *(_QWORD *)&v64[0] = &off_1E453A8D0;
            v66 = v33 >> 2;
            operator delete(v31);
            if (!v65)
            {
              v44 = 5243;
              goto LABEL_63;
            }
            v67 = 2;
            vision::mod::GreedyClustererFaces::getAverageDescriptorOfClusterContainingFace(a1, a3, (uint64_t)&v69, v65);
            std::vector<std::pair<float,unsigned long>>::vector((char **)&__p, a2[1] - *a2);
            v34 = *a2;
            v55 = a2[1];
            if (*a2 == v55)
            {
              v36 = 0;
LABEL_47:
              v46 = 126 - 2 * __clz((v63 - (_BYTE *)__p) >> 4);
              if (v63 == __p)
                v47 = 0;
              else
                v47 = v46;
              std::__introsort<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *,false>((uint64_t)__p, (unint64_t)v63, v47, 1);
              v48 = a2[1];
              v49 = __p;
              v50 = (char *)v48 - (char *)*a2;
              if (v48 == *a2)
              {
                v44 = 5248;
                goto LABEL_59;
              }
              v51 = 0;
              v52 = 0;
              v53 = v50 >> 3;
              if (v53 <= 1)
                v53 = 1;
              v54 = 8;
              v44 = 5248;
              while (1)
              {
                v52 += *(_QWORD *)((char *)__p + v54);
                if (v52 >= v36 >> 1)
                  break;
                ++v51;
                v54 += 16;
                if (v53 == v51)
                  goto LABEL_59;
              }
              *a4 = *((_DWORD *)__p + 4 * v51);
              v44 = 5248;
            }
            else
            {
              v35 = 0;
              v36 = 0;
              while (1)
              {
                v37 = *v34;
                v38 = operator new(8uLL);
                *v38 = v37;
                v56[1] = v38 + 1;
                v56[2] = v38 + 1;
                v56[0] = v38;
                v39 = malloc_type_malloc(4 * *(int *)(*((_QWORD *)a1 + 8) + 104), 0x100004052888210uLL);
                v40 = *(int *)(*((_QWORD *)a1 + 8) + 104);
                vision::mod::ImageDescriptorBufferAbstract::ImageDescriptorBufferAbstract((uint64_t)v57, v56, v39, v40, 1, 1);
                v60 = 1;
                v61 = 0;
                v57[0] = &off_1E453A8D0;
                v59 = v40 >> 2;
                operator delete(v38);
                v60 = 2;
                v41 = v58;
                if (v58)
                {
                  vision::mod::GreedyClustererFaces::getAverageDescriptorOfClusterContainingFace(a1, v37, (uint64_t)&v69, v58);
                  v42 = vision::mod::ImageDescriptorBufferFloat32::computeDistanceFrom((vision::mod::ImageDescriptorBufferFloat32 *)v57, (const vision::mod::ImageDescriptorBufferAbstract *)v64);
                  *((float *)__p + 4 * v35) = v42;
                  v43 = (*(uint64_t (**)(vision::mod::GreedyClustererFaces *, uint64_t))(*(_QWORD *)a1 + 200))(a1, v37);
                  *((_QWORD *)__p + 2 * v35 + 1) = v43;
                  v36 += v43;
                  ++v35;
                }
                v57[0] = &off_1E453A8D0;
                free(v61);
                vision::mod::ImageDescriptorBufferAbstract::~ImageDescriptorBufferAbstract(v57);
                if (!v41)
                  break;
                if (++v34 == v55)
                  goto LABEL_47;
              }
              v49 = __p;
              v44 = 5243;
LABEL_59:
              if (!v49)
              {
LABEL_63:
                *(_QWORD *)&v64[0] = &off_1E453A8D0;
                free(v68);
                vision::mod::ImageDescriptorBufferAbstract::~ImageDescriptorBufferAbstract((void **)v64);
                std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::destroy(v70[0]);
                return v44;
              }
            }
            v63 = v49;
            operator delete(v49);
            goto LABEL_63;
          }
        }
        ++v12;
        goto LABEL_8;
      }
LABEL_42:
      syslog(5, "FaceId=%lld not present in clustering", a3);
    }
  }
  return 5244;
}

void sub_1A1555284(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,uint64_t a32,void *a33)
{
  uint64_t v33;

  vision::mod::ImageDescriptorBufferFloat32::~ImageDescriptorBufferFloat32(&a33);
  std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::destroy(*(_QWORD **)(v33 - 104));
  _Unwind_Resume(a1);
}

uint64_t vision::mod::GreedyClustererFaces::computeClusterLookupMapL0(uint64_t a1, uint64_t **a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  unint64_t v8;
  char *v9;
  _QWORD *v10;
  char *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  BOOL v21;

  v2 = *(_QWORD **)(a1 + 112);
  v3 = (_QWORD *)(a1 + 120);
  if (v2 != (_QWORD *)(a1 + 120))
  {
    do
    {
      v5 = std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(a2, v2[4], v2 + 4);
      v6 = v5;
      v7 = v2[5];
      v9 = (char *)v5[6];
      v8 = v5[7];
      if ((unint64_t)v9 >= v8)
      {
        v11 = (char *)v5[5];
        v12 = (v9 - v11) >> 3;
        v13 = v12 + 1;
        if ((unint64_t)(v12 + 1) >> 61)
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        v14 = v8 - (_QWORD)v11;
        if (v14 >> 2 > v13)
          v13 = v14 >> 2;
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8)
          v15 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v15 = v13;
        if (v15)
        {
          v15 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v15);
          v11 = (char *)v6[5];
          v9 = (char *)v6[6];
        }
        else
        {
          v16 = 0;
        }
        v17 = (_QWORD *)(v15 + 8 * v12);
        *v17 = v7;
        v10 = v17 + 1;
        while (v9 != v11)
        {
          v18 = *((_QWORD *)v9 - 1);
          v9 -= 8;
          *--v17 = v18;
        }
        v6[5] = (uint64_t)v17;
        v6[6] = (uint64_t)v10;
        v6[7] = v15 + 8 * v16;
        if (v11)
          operator delete(v11);
      }
      else
      {
        *(_QWORD *)v9 = v7;
        v10 = v9 + 8;
      }
      v6[6] = (uint64_t)v10;
      v19 = (_QWORD *)v2[1];
      if (v19)
      {
        do
        {
          v20 = v19;
          v19 = (_QWORD *)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          v20 = (_QWORD *)v2[2];
          v21 = *v20 == (_QWORD)v2;
          v2 = v20;
        }
        while (!v21);
      }
      v2 = v20;
    }
    while (v20 != v3);
  }
  return 5248;
}

uint64_t vision::mod::GreedyClustererFaces::computeClusterMapL0(uint64_t a1, uint64_t **a2)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *i;
  uint64_t *v6;
  uint64_t *v7;
  unint64_t v8;
  char *v9;
  _QWORD *v10;
  char *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  BOOL v21;
  uint64_t v23;

  v2 = *(_QWORD **)(a1 + 88);
  v3 = (_QWORD *)(a1 + 96);
  if (v2 != (_QWORD *)(a1 + 96))
  {
    do
    {
      for (i = (_QWORD *)v2[6]; i != v2 + 5; i = (_QWORD *)i[1])
      {
        v23 = v2[4];
        v6 = std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(a2, v23, &v23);
        v7 = v6;
        v9 = (char *)v6[6];
        v8 = v6[7];
        if ((unint64_t)v9 >= v8)
        {
          v11 = (char *)v6[5];
          v12 = (v9 - v11) >> 3;
          v13 = v12 + 1;
          if ((unint64_t)(v12 + 1) >> 61)
            std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
          v14 = v8 - (_QWORD)v11;
          if (v14 >> 2 > v13)
            v13 = v14 >> 2;
          if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8)
            v15 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v15 = v13;
          if (v15)
          {
            v15 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v15);
            v11 = (char *)v7[5];
            v9 = (char *)v7[6];
          }
          else
          {
            v16 = 0;
          }
          v17 = (_QWORD *)(v15 + 8 * v12);
          *v17 = i[2];
          v10 = v17 + 1;
          while (v9 != v11)
          {
            v18 = *((_QWORD *)v9 - 1);
            v9 -= 8;
            *--v17 = v18;
          }
          v7[5] = (uint64_t)v17;
          v7[6] = (uint64_t)v10;
          v7[7] = v15 + 8 * v16;
          if (v11)
            operator delete(v11);
        }
        else
        {
          *(_QWORD *)v9 = i[2];
          v10 = v9 + 8;
        }
        v7[6] = (uint64_t)v10;
      }
      v19 = (_QWORD *)v2[1];
      if (v19)
      {
        do
        {
          v20 = v19;
          v19 = (_QWORD *)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          v20 = (_QWORD *)v2[2];
          v21 = *v20 == (_QWORD)v2;
          v2 = v20;
        }
        while (!v21);
      }
      v2 = v20;
    }
    while (v20 != v3);
  }
  return 5248;
}

uint64_t vision::mod::GreedyClustererFaces::computeClusterLookupMapL1(uint64_t a1, uint64_t **a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t *v5;
  uint64_t *v6;
  unint64_t v7;
  char *v8;
  _QWORD *v9;
  char *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  BOOL v20;

  v2 = *(_QWORD **)(a1 + 136);
  v3 = (_QWORD *)(a1 + 144);
  if (v2 != (_QWORD *)(a1 + 144))
  {
    do
    {
      v5 = std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(a2, v2[4], v2 + 4);
      v6 = v5;
      v8 = (char *)v5[6];
      v7 = v5[7];
      if ((unint64_t)v8 >= v7)
      {
        v10 = (char *)v5[5];
        v11 = (v8 - v10) >> 3;
        v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 61)
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        v13 = v7 - (_QWORD)v10;
        if (v13 >> 2 > v12)
          v12 = v13 >> 2;
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8)
          v14 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v14 = v12;
        if (v14)
        {
          v14 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v14);
          v10 = (char *)v6[5];
          v8 = (char *)v6[6];
        }
        else
        {
          v15 = 0;
        }
        v16 = (_QWORD *)(v14 + 8 * v11);
        *v16 = v2[5];
        v9 = v16 + 1;
        while (v8 != v10)
        {
          v17 = *((_QWORD *)v8 - 1);
          v8 -= 8;
          *--v16 = v17;
        }
        v6[5] = (uint64_t)v16;
        v6[6] = (uint64_t)v9;
        v6[7] = v14 + 8 * v15;
        if (v10)
          operator delete(v10);
      }
      else
      {
        *(_QWORD *)v8 = v2[5];
        v9 = v8 + 8;
      }
      v6[6] = (uint64_t)v9;
      v18 = (_QWORD *)v2[1];
      if (v18)
      {
        do
        {
          v19 = v18;
          v18 = (_QWORD *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          v19 = (_QWORD *)v2[2];
          v20 = *v19 == (_QWORD)v2;
          v2 = v19;
        }
        while (!v20);
      }
      v2 = v19;
    }
    while (v19 != v3);
  }
  return 5248;
}

uint64_t vision::mod::GreedyClustererFaces::getLevel0FacesToClusterContaining(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6;
  _QWORD *v7;
  uint64_t *v8;
  uint64_t *v9;

  if (vision::mod::GreedyClustererFaces::isFaceIdInClustererState((vision::mod::GreedyClustererFaces *)a1, a2))
  {
    v6 = *(_QWORD *)(a1 + 64);
    v7 = std::map<long long,unsigned long>::at(*(_QWORD **)(a1 + 120), a2);
    v8 = std::map<unsigned long,std::list<long long>>::at(*(_QWORD **)(a1 + 96), *(_QWORD *)(**(_QWORD **)(v6 + 88)+ *(unsigned int *)v7 * (unint64_t)*(unsigned int *)(**(_QWORD **)(v6 + 88) + 16)+ 24));
    if (v8 != a3)
      std::list<long long>::__assign_with_sentinel[abi:ne180100]<std::__list_const_iterator<long long,void *>,std::__list_const_iterator<long long,void *>>(a3, v8[1], (uint64_t)v8);
    v9 = &CVML_status_ok;
  }
  else
  {
    v9 = &CVML_status_invalidParameter;
  }
  return (*v9 + 128) | 0x1400;
}

uint64_t vision::mod::GreedyClustererFaces::getDistanceBetweenLevel0ClustersContaining(vision::mod::GreedyClustererFaces *this, uint64_t a2, uint64_t a3, float *a4)
{
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  unint64_t v16;
  int v17;
  int v18;
  _BYTE v19[260];
  float __C;

  if (!vision::mod::GreedyClustererFaces::isFaceIdInClustererState(this, a2)
    || !vision::mod::GreedyClustererFaces::isFaceIdInClustererState(this, a3))
  {
    return 5244;
  }
  v8 = *((_QWORD *)this + 8);
  v9 = std::map<long long,unsigned long>::at(*((_QWORD **)this + 15), a2);
  v10 = *(_QWORD *)(v8 + 88);
  if (v10)
    v11 = *(_QWORD *)v10 + *(unsigned int *)v9 * (unint64_t)*(unsigned int *)(*(_QWORD *)v10 + 16) + 24;
  else
    v11 = 0;
  v13 = *((_QWORD *)this + 8);
  v14 = std::map<long long,unsigned long>::at(*((_QWORD **)this + 15), a3);
  v15 = *(_QWORD *)(v13 + 88);
  if (v15)
    v16 = *(_QWORD *)v15 + *(unsigned int *)v14 * (unint64_t)*(unsigned int *)(*(_QWORD *)v15 + 16) + 24;
  else
    v16 = 0;
  v17 = (*(uint64_t (**)(vision::mod::GreedyClustererFaces *))(*(_QWORD *)this + 168))(this);
  vision::mod::dist_greedy_status_t::dist_greedy_status_t((uint64_t)v19, v17, 2);
  v18 = (*(uint64_t (**)(vision::mod::GreedyClustererFaces *))(*(_QWORD *)this + 168))(this);
  __C = 0.0;
  vDSP_dotpr((const float *)(v11 + 16), 1, (const float *)(v16 + 16), 1, &__C, v18);
  *a4 = (float)((float)(__C + 1.0) * -0.5) + 1.0;
  vision::mod::dist_greedy_status_t::~dist_greedy_status_t((vision::mod::dist_greedy_status_t *)v19);
  return 5248;
}

void sub_1A15558D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  vision::mod::dist_greedy_status_t::~dist_greedy_status_t((vision::mod::dist_greedy_status_t *)va);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::GreedyClustererFaces::getDistanceBetweenLevel1ClustersContaining(vision::mod::GreedyClustererFaces *a1, uint64_t a2, uint64_t **a3, uint64_t a4, char **a5)
{
  unint64_t v10;
  int v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  unint64_t v17;
  vDSP_Length v18;
  uint64_t v20;
  float *__B[3];
  _DWORD v22[64];
  void *v23[3];
  float __C;

  if (!vision::mod::GreedyClustererFaces::isFaceIdInClustererState(a1, a2))
    return 5244;
  v10 = *(int *)(*((_QWORD *)a1 + 8) + 104);
  v22[0] = 0;
  std::vector<float>::vector(v23, v10, v22);
  vision::mod::GreedyClustererFaces::getAverageDescriptorOfClusterContainingFace(a1, a2, a4, v23[0]);
  v11 = (*(uint64_t (**)(vision::mod::GreedyClustererFaces *))(*(_QWORD *)a1 + 168))(a1);
  vision::mod::dist_greedy_status_t::dist_greedy_status_t((uint64_t)v22, v11, 2);
  std::vector<float>::resize(a5, a3[1] - *a3);
  v12 = *a3;
  v13 = a3[1];
  if (*a3 == v13)
  {
    v15 = &CVML_status_ok;
  }
  else
  {
    v14 = 0;
    v15 = &CVML_status_invalidParameter;
    while (1)
    {
      v16 = *v12;
      if ((vision::mod::GreedyClustererFaces::isFaceIdInClustererState(a1, *v12) & 1) == 0)
        break;
      v17 = *(int *)(*((_QWORD *)a1 + 8) + 104);
      __C = 0.0;
      std::vector<float>::vector(__B, v17, &__C);
      vision::mod::GreedyClustererFaces::getAverageDescriptorOfClusterContainingFace(a1, v16, a4, __B[0]);
      v18 = *(int *)(*((_QWORD *)a1 + 8) + 104);
      __C = 0.0;
      vDSP_dotpr((const float *)v23[0], 1, __B[0], 1, &__C, v18);
      *(float *)&(*a5)[v14] = (float)((float)(__C + 1.0) * -0.5) + 1.0;
      if (__B[0])
      {
        __B[1] = __B[0];
        operator delete(__B[0]);
      }
      ++v12;
      v14 += 4;
      if (v12 == v13)
      {
        v15 = &CVML_status_ok;
        break;
      }
    }
  }
  v20 = *v15;
  vision::mod::dist_greedy_status_t::~dist_greedy_status_t((vision::mod::dist_greedy_status_t *)v22);
  if (v23[0])
  {
    v23[1] = v23[0];
    operator delete(v23[0]);
  }
  return (v20 + 128) | 0x1400;
}

void sub_1A1555AAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13)
{
  uint64_t v13;
  void *v15;

  vision::mod::dist_greedy_status_t::~dist_greedy_status_t((vision::mod::dist_greedy_status_t *)&a13);
  v15 = *(void **)(v13 - 128);
  if (v15)
  {
    *(_QWORD *)(v13 - 120) = v15;
    operator delete(v15);
  }
  _Unwind_Resume(a1);
}

uint64_t vision::mod::GreedyClustererFaces::computeClusterMapL1(uint64_t a1, uint64_t **a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t *v5;
  uint64_t *v6;
  unint64_t v7;
  char *v8;
  _QWORD *v9;
  char *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  BOOL v20;
  __int128 v22;

  v2 = *(_QWORD **)(a1 + 136);
  v3 = (_QWORD *)(a1 + 144);
  if (v2 != (_QWORD *)(a1 + 144))
  {
    do
    {
      v22 = *((_OWORD *)v2 + 2);
      v5 = std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(a2, *((uint64_t *)&v22 + 1), (uint64_t *)&v22 + 1);
      v6 = v5;
      v8 = (char *)v5[6];
      v7 = v5[7];
      if ((unint64_t)v8 >= v7)
      {
        v10 = (char *)v5[5];
        v11 = (v8 - v10) >> 3;
        v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 61)
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        v13 = v7 - (_QWORD)v10;
        if (v13 >> 2 > v12)
          v12 = v13 >> 2;
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8)
          v14 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v14 = v12;
        if (v14)
        {
          v14 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v14);
          v10 = (char *)v6[5];
          v8 = (char *)v6[6];
        }
        else
        {
          v15 = 0;
        }
        v16 = (_QWORD *)(v14 + 8 * v11);
        *v16 = v22;
        v9 = v16 + 1;
        while (v8 != v10)
        {
          v17 = *((_QWORD *)v8 - 1);
          v8 -= 8;
          *--v16 = v17;
        }
        v6[5] = (uint64_t)v16;
        v6[6] = (uint64_t)v9;
        v6[7] = v14 + 8 * v15;
        if (v10)
          operator delete(v10);
      }
      else
      {
        *(_QWORD *)v8 = v22;
        v9 = v8 + 8;
      }
      v6[6] = (uint64_t)v9;
      v18 = (_QWORD *)v2[1];
      if (v18)
      {
        do
        {
          v19 = v18;
          v18 = (_QWORD *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          v19 = (_QWORD *)v2[2];
          v20 = *v19 == (_QWORD)v2;
          v2 = v19;
        }
        while (!v20);
      }
      v2 = v19;
    }
    while (v19 != v3);
  }
  return 5248;
}

uint64_t vision::mod::GreedyClustererFaces::getClusterIdForFaceId(vision::mod::GreedyClustererFaces *this, uint64_t a2)
{
  if (vision::mod::GreedyClustererFaces::isFaceIdInClustererState(this, a2))
    return *std::map<long long,unsigned long>::at(*((_QWORD **)this + 18), a2);
  else
    return -1;
}

uint64_t vision::mod::GreedyClustererFaces::getMaximumFaceId(vision::mod::GreedyClustererFaces *this)
{
  _QWORD *v1;
  char *v2;
  uint64_t result;
  _QWORD *v4;
  _QWORD *v5;
  BOOL v6;

  v1 = (_QWORD *)*((_QWORD *)this + 17);
  v2 = (char *)this + 144;
  if (v1 == (_QWORD *)((char *)this + 144))
    return 0;
  result = 0;
  do
  {
    if (result <= v1[4])
      result = v1[4];
    v4 = (_QWORD *)v1[1];
    if (v4)
    {
      do
      {
        v5 = v4;
        v4 = (_QWORD *)*v4;
      }
      while (v4);
    }
    else
    {
      do
      {
        v5 = (_QWORD *)v1[2];
        v6 = *v5 == (_QWORD)v1;
        v1 = v5;
      }
      while (!v6);
    }
    v1 = v5;
  }
  while (v5 != (_QWORD *)v2);
  return result;
}

double vision::mod::GreedyClustererFaces::getClusteredIds(uint64_t a1, uint64_t a2)
{
  void *v3;
  double result;
  __int128 v5;
  uint64_t v6;

  allKeys<long long,unsigned long>((char **)&v5, (_QWORD *)(a1 + 112));
  v3 = *(void **)a2;
  if (*(_QWORD *)a2)
  {
    *(_QWORD *)(a2 + 8) = v3;
    operator delete(v3);
  }
  result = *(double *)&v5;
  *(_OWORD *)a2 = v5;
  *(_QWORD *)(a2 + 16) = v6;
  return result;
}

void vision::mod::GreedyClustererFaces::getClusters(vision::mod::GreedyClustererFaces *this@<X0>, uint64_t *a2@<X8>)
{
  char *v3;
  char *v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t *v7;
  unint64_t v8;
  char *v9;
  _QWORD *v10;
  char *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  char *v19;
  char *v20;
  BOOL v21;
  uint64_t *v22;
  const void *v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t *v27;
  uint64_t v28;
  void *__p[3];
  uint64_t *v30;
  _QWORD *v31[2];

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v31[0] = 0;
  v31[1] = 0;
  v30 = (uint64_t *)v31;
  v3 = (char *)*((_QWORD *)this + 17);
  v4 = (char *)this + 144;
  if (v3 != (char *)this + 144)
  {
    do
    {
      v5 = *((_QWORD *)v3 + 4);
      v28 = *((_QWORD *)v3 + 5);
      v6 = std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(&v30, v28, &v28);
      v7 = v6;
      v9 = (char *)v6[6];
      v8 = v6[7];
      if ((unint64_t)v9 >= v8)
      {
        v11 = (char *)v6[5];
        v12 = (v9 - v11) >> 3;
        v13 = v12 + 1;
        if ((unint64_t)(v12 + 1) >> 61)
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        v14 = v8 - (_QWORD)v11;
        if (v14 >> 2 > v13)
          v13 = v14 >> 2;
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8)
          v15 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v15 = v13;
        if (v15)
        {
          v15 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v15);
          v11 = (char *)v7[5];
          v9 = (char *)v7[6];
        }
        else
        {
          v16 = 0;
        }
        v17 = (_QWORD *)(v15 + 8 * v12);
        *v17 = v5;
        v10 = v17 + 1;
        while (v9 != v11)
        {
          v18 = *((_QWORD *)v9 - 1);
          v9 -= 8;
          *--v17 = v18;
        }
        v7[5] = (uint64_t)v17;
        v7[6] = (uint64_t)v10;
        v7[7] = v15 + 8 * v16;
        if (v11)
          operator delete(v11);
      }
      else
      {
        *(_QWORD *)v9 = v5;
        v10 = v9 + 8;
      }
      v7[6] = (uint64_t)v10;
      v19 = (char *)*((_QWORD *)v3 + 1);
      if (v19)
      {
        do
        {
          v20 = v19;
          v19 = *(char **)v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          v20 = (char *)*((_QWORD *)v3 + 2);
          v21 = *(_QWORD *)v20 == (_QWORD)v3;
          v3 = v20;
        }
        while (!v21);
      }
      v3 = v20;
    }
    while (v20 != v4);
    v22 = v30;
    if (v30 != (uint64_t *)v31)
    {
      do
      {
        v23 = (const void *)v22[5];
        v28 = v22[4];
        memset(__p, 0, sizeof(__p));
        std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>(__p, v23, v22[6], (v22[6] - (uint64_t)v23) >> 3);
        v24 = a2[1];
        if (v24 >= a2[2])
        {
          v25 = std::vector<std::vector<long long>>::__push_back_slow_path<std::vector<long long> const&>(a2, (uint64_t)__p);
        }
        else
        {
          std::vector<std::vector<long long>>::__construct_one_at_end[abi:ne180100]<std::vector<long long> const&>((uint64_t)a2, (uint64_t)__p);
          v25 = v24 + 24;
        }
        a2[1] = v25;
        if (__p[0])
          operator delete(__p[0]);
        v26 = (uint64_t *)v22[1];
        if (v26)
        {
          do
          {
            v27 = v26;
            v26 = (uint64_t *)*v26;
          }
          while (v26);
        }
        else
        {
          do
          {
            v27 = (uint64_t *)v22[2];
            v21 = *v27 == (_QWORD)v22;
            v22 = v27;
          }
          while (!v21);
        }
        v22 = v27;
      }
      while (v27 != (uint64_t *)v31);
    }
  }
  std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::destroy(v31[0]);
}

void sub_1A1555F6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, _QWORD *a15)
{
  std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::destroy(a15);
  std::vector<std::vector<long long>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a10);
  _Unwind_Resume(a1);
}

void vision::mod::GreedyClustererFaces::getAllClustersFromState(vision::mod::GreedyClustererFaces *this@<X0>, uint64_t *a2@<X8>)
{
  char *v3;
  char *v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t *v7;
  unint64_t v8;
  char *v9;
  _QWORD *v10;
  char *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  char *v19;
  char *v20;
  BOOL v21;
  uint64_t *v22;
  const void *v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t *v27;
  uint64_t v28;
  void *__p[3];
  uint64_t *v30;
  _QWORD *v31[2];

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v31[0] = 0;
  v31[1] = 0;
  v30 = (uint64_t *)v31;
  v3 = (char *)*((_QWORD *)this + 17);
  v4 = (char *)this + 144;
  if (v3 != (char *)this + 144)
  {
    do
    {
      v5 = *((_QWORD *)v3 + 4);
      v28 = *((_QWORD *)v3 + 5);
      v6 = std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(&v30, v28, &v28);
      v7 = v6;
      v9 = (char *)v6[6];
      v8 = v6[7];
      if ((unint64_t)v9 >= v8)
      {
        v11 = (char *)v6[5];
        v12 = (v9 - v11) >> 3;
        v13 = v12 + 1;
        if ((unint64_t)(v12 + 1) >> 61)
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        v14 = v8 - (_QWORD)v11;
        if (v14 >> 2 > v13)
          v13 = v14 >> 2;
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8)
          v15 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v15 = v13;
        if (v15)
        {
          v15 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v15);
          v11 = (char *)v7[5];
          v9 = (char *)v7[6];
        }
        else
        {
          v16 = 0;
        }
        v17 = (_QWORD *)(v15 + 8 * v12);
        *v17 = v5;
        v10 = v17 + 1;
        while (v9 != v11)
        {
          v18 = *((_QWORD *)v9 - 1);
          v9 -= 8;
          *--v17 = v18;
        }
        v7[5] = (uint64_t)v17;
        v7[6] = (uint64_t)v10;
        v7[7] = v15 + 8 * v16;
        if (v11)
          operator delete(v11);
      }
      else
      {
        *(_QWORD *)v9 = v5;
        v10 = v9 + 8;
      }
      v7[6] = (uint64_t)v10;
      v19 = (char *)*((_QWORD *)v3 + 1);
      if (v19)
      {
        do
        {
          v20 = v19;
          v19 = *(char **)v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          v20 = (char *)*((_QWORD *)v3 + 2);
          v21 = *(_QWORD *)v20 == (_QWORD)v3;
          v3 = v20;
        }
        while (!v21);
      }
      v3 = v20;
    }
    while (v20 != v4);
    v22 = v30;
    if (v30 != (uint64_t *)v31)
    {
      do
      {
        v23 = (const void *)v22[5];
        v28 = v22[4];
        memset(__p, 0, sizeof(__p));
        std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>(__p, v23, v22[6], (v22[6] - (uint64_t)v23) >> 3);
        v24 = a2[1];
        if (v24 >= a2[2])
        {
          v25 = std::vector<std::vector<long long>>::__push_back_slow_path<std::vector<long long> const&>(a2, (uint64_t)__p);
        }
        else
        {
          std::vector<std::vector<long long>>::__construct_one_at_end[abi:ne180100]<std::vector<long long> const&>((uint64_t)a2, (uint64_t)__p);
          v25 = v24 + 24;
        }
        a2[1] = v25;
        if (__p[0])
          operator delete(__p[0]);
        v26 = (uint64_t *)v22[1];
        if (v26)
        {
          do
          {
            v27 = v26;
            v26 = (uint64_t *)*v26;
          }
          while (v26);
        }
        else
        {
          do
          {
            v27 = (uint64_t *)v22[2];
            v21 = *v27 == (_QWORD)v22;
            v22 = v27;
          }
          while (!v21);
        }
        v22 = v27;
      }
      while (v27 != (uint64_t *)v31);
    }
  }
  std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::destroy(v31[0]);
}

void sub_1A15561C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, _QWORD *a15)
{
  std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::destroy(a15);
  std::vector<std::vector<long long>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a10);
  _Unwind_Resume(a1);
}

void vision::mod::GreedyClustererFaces::getIdsForCluster(_QWORD *a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  unint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  _QWORD *v25;
  unint64_t v26;
  _QWORD *v27;
  _QWORD *v28;
  _QWORD *v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  uint64_t v36;
  _QWORD *v37;
  _QWORD *v38;
  BOOL v39;
  _QWORD *exception;

  if ((vision::mod::GreedyClustererFaces::isFaceIdInClustererState((vision::mod::GreedyClustererFaces *)a1, a2) & 1) == 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = 5244;
    __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
  }
  v8 = a1 + 18;
  v9 = *std::map<long long,unsigned long>::at((_QWORD *)a1[18], a2);
  std::vector<long long>::reserve((void **)a3, a1[19] + 1);
  if (a4)
  {
    v10 = std::__hash_table<std::__hash_value_type<long long,long long>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,long long>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,long long>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,long long>>>::__equal_range_multi<long long>(a4, v9);
    if (v10 != v11)
    {
      v12 = v10;
      v13 = v11;
      v14 = *(_QWORD **)(a3 + 8);
      do
      {
        v15 = *(_QWORD *)(a3 + 16);
        if ((unint64_t)v14 >= v15)
        {
          v17 = *(_QWORD **)a3;
          v18 = ((uint64_t)v14 - *(_QWORD *)a3) >> 3;
          v19 = v18 + 1;
          if ((unint64_t)(v18 + 1) >> 61)
            goto LABEL_49;
          v20 = v15 - (_QWORD)v17;
          if (v20 >> 2 > v19)
            v19 = v20 >> 2;
          if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8)
            v21 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v21 = v19;
          if (v21)
          {
            v21 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v21);
            v17 = *(_QWORD **)a3;
            v14 = *(_QWORD **)(a3 + 8);
          }
          else
          {
            v22 = 0;
          }
          v23 = (_QWORD *)(v21 + 8 * v18);
          *v23 = v12[3];
          v16 = v23 + 1;
          while (v14 != v17)
          {
            v24 = *--v14;
            *--v23 = v24;
          }
          *(_QWORD *)a3 = v23;
          *(_QWORD *)(a3 + 8) = v16;
          *(_QWORD *)(a3 + 16) = v21 + 8 * v22;
          if (v17)
            operator delete(v17);
        }
        else
        {
          *v14 = v12[3];
          v16 = v14 + 1;
        }
        *(_QWORD *)(a3 + 8) = v16;
        v12 = (_QWORD *)*v12;
        v14 = v16;
      }
      while (v12 != v13);
    }
  }
  else
  {
    v25 = (_QWORD *)a1[17];
    if (v25 != v8)
    {
      do
      {
        if (v25[5] == v9)
        {
          v27 = *(_QWORD **)(a3 + 8);
          v26 = *(_QWORD *)(a3 + 16);
          if ((unint64_t)v27 >= v26)
          {
            v29 = *(_QWORD **)a3;
            v30 = ((uint64_t)v27 - *(_QWORD *)a3) >> 3;
            v31 = v30 + 1;
            if ((unint64_t)(v30 + 1) >> 61)
LABEL_49:
              std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
            v32 = v26 - (_QWORD)v29;
            if (v32 >> 2 > v31)
              v31 = v32 >> 2;
            if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF8)
              v33 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v33 = v31;
            if (v33)
            {
              v33 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v33);
              v29 = *(_QWORD **)a3;
              v27 = *(_QWORD **)(a3 + 8);
            }
            else
            {
              v34 = 0;
            }
            v35 = (_QWORD *)(v33 + 8 * v30);
            *v35 = v25[4];
            v28 = v35 + 1;
            while (v27 != v29)
            {
              v36 = *--v27;
              *--v35 = v36;
            }
            *(_QWORD *)a3 = v35;
            *(_QWORD *)(a3 + 8) = v28;
            *(_QWORD *)(a3 + 16) = v33 + 8 * v34;
            if (v29)
              operator delete(v29);
          }
          else
          {
            *v27 = v25[4];
            v28 = v27 + 1;
          }
          *(_QWORD *)(a3 + 8) = v28;
        }
        v37 = (_QWORD *)v25[1];
        if (v37)
        {
          do
          {
            v38 = v37;
            v37 = (_QWORD *)*v37;
          }
          while (v37);
        }
        else
        {
          do
          {
            v38 = (_QWORD *)v25[2];
            v39 = *v38 == (_QWORD)v25;
            v25 = v38;
          }
          while (!v39);
        }
        v25 = v38;
      }
      while (v38 != v8);
    }
  }
}

uint64_t vision::mod::GreedyClustererFaces::descriptorLength(vision::mod::GreedyClustererFaces *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 8);
  if (v1)
    return *(int *)(v1 + 104);
  else
    return 0;
}

uint64_t vision::mod::GreedyClustererFaces::getAverageDescriptorsOfClusters(vision::mod::GreedyClustererFaces *a1, uint64_t **a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  void *v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *v14[3];
  void *v15[13];
  int v16;
  void *v17;
  _QWORD **v18;
  _QWORD *v19[3];

  v19[0] = 0;
  v19[1] = 0;
  v18 = v19;
  v6 = (*(uint64_t (**)(vision::mod::GreedyClustererFaces *, _QWORD ***))(*(_QWORD *)a1 + 112))(a1, &v18);
  if (v6 == 5248)
  {
    v7 = *a2;
    v8 = a2[1];
    if (*a2 == v8)
    {
LABEL_7:
      v6 = 5248;
    }
    else
    {
      v6 = 5243;
      while (1)
      {
        v9 = *v7;
        v10 = malloc_type_malloc(4 * *(int *)(*((_QWORD *)a1 + 8) + 104), 0x100004052888210uLL);
        if (!v10)
          break;
        if ((vision::mod::GreedyClustererFaces::isFaceIdInClustererState(a1, v9) & 1) == 0)
        {
          free(v10);
          v6 = 5244;
          break;
        }
        vision::mod::GreedyClustererFaces::getAverageDescriptorOfClusterContainingFace(a1, v9, (uint64_t)&v18, v10);
        v11 = operator new(8uLL);
        *v11 = v9;
        v14[1] = v11 + 1;
        v14[2] = v11 + 1;
        v14[0] = v11;
        v12 = *(int *)(*((_QWORD *)a1 + 8) + 104);
        vision::mod::ImageDescriptorBufferAbstract::ImageDescriptorBufferAbstract((uint64_t)v15, v14, v10, 4 * v12, 1, 1);
        v16 = 1;
        v17 = 0;
        v15[0] = &off_1E453A8D0;
        v15[12] = (void *)(v12 & 0x3FFFFFFFFFFFFFFFLL);
        operator delete(v11);
        (*(void (**)(uint64_t, void **))(*(_QWORD *)a3 + 40))(a3, v15);
        v15[0] = &off_1E453A8D0;
        free(v17);
        vision::mod::ImageDescriptorBufferAbstract::~ImageDescriptorBufferAbstract(v15);
        if (++v7 == v8)
          goto LABEL_7;
      }
    }
  }
  std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::destroy(v19[0]);
  return v6;
}

void sub_1A1556620(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::destroy(*(_QWORD **)(v1 - 104));
  _Unwind_Resume(a1);
}

uint64_t vision::mod::GreedyClustererFaces::cancelLongRunning(uint64_t this)
{
  *(_BYTE *)(*(_QWORD *)(this + 64) + 120) = 1;
  return this;
}

uint64_t vision::mod::GreedyClustererFaces::removeIds(uint64_t **this, uint64_t *a2, uint64_t **a3)
{
  uint64_t v4;
  unint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t *v14;
  __int32 *v15;
  __int32 *v16;
  __int32 *v17;
  __int32 *v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __int32 *v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t *v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t *v31;
  uint64_t *v32;
  uint64_t *v33;
  uint64_t **v34;
  BOOL v35;
  uint64_t *v36;
  uint64_t v37;
  _QWORD *exception;
  uint64_t v41;
  uint64_t **v42;
  uint64_t *v43;
  uint64_t v44;
  __int32 v45;

  v43 = 0;
  v44 = 0;
  v42 = &v43;
  v4 = *a2;
  if (a2[1] == *a2)
  {
LABEL_40:
    vision::mod::GreedyClustererFaces::computeDeltaAfterUpdate((uint64_t)this, a3, (uint64_t *)&v42);
    v36 = &CVML_status_ok;
  }
  else
  {
    v6 = 0;
    while (1)
    {
      v7 = (uint64_t *)(v4 + 8 * v6);
      if ((vision::mod::GreedyClustererFaces::isFaceIdInClustererState((vision::mod::GreedyClustererFaces *)this, *v7) & 1) == 0)
        break;
      v41 = 0;
      v8 = (uint64_t)std::__tree<std::__value_type<long long,unsigned long>,std::__map_value_compare<long long,std::__value_type<long long,unsigned long>,std::less<long long>,true>,std::allocator<std::__value_type<long long,unsigned long>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(this + 14, *v7, (uint64_t **)v7)[5];
      v41 = v8;
      std::__tree<long long>::__emplace_unique_key_args<long long,long long>((uint64_t *)&v42, v8, v8);
      v9 = this[8][9];
      if (v9)
        v10 = *(_QWORD *)v9 + v8 * (unint64_t)*(unsigned int *)(*(_QWORD *)v9 + 16) + 24;
      else
        v10 = 0;
      --*(_DWORD *)(v10 + 8);
      v11 = std::__tree<std::__value_type<unsigned long,std::list<long long>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::list<long long>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::list<long long>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(this + 11, v8, &v41);
      v12 = v11 + 5;
      v13 = (uint64_t *)std::remove[abi:ne180100]<std::__list_iterator<long long,void *>,long long>(v11[6], (uint64_t)(v11 + 5), v7);
      std::list<long long>::erase((uint64_t)v12, v13, v12);
      std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__erase_unique<long long>(this + 14, *v7);
      std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__erase_unique<long long>(this + 17, *v7);
      if (!*(_DWORD *)(v10 + 8))
      {
        v14 = this[8];
        v45 = v8;
        v15 = (__int32 *)v14[7];
        v16 = wmemchr((__int32 *)v14[6], v8, ((uint64_t)v15 - v14[6]) >> 2);
        if (v16)
          v17 = v16;
        else
          v17 = v15;
        v18 = (__int32 *)v14[7];
        if (v17 == v18 || (v19 = (_QWORD *)v14[9]) == 0)
        {
          exception = __cxa_allocate_exception(8uLL);
          *exception = 5246;
          __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
        }
        v20 = *v19;
        if (*(_DWORD *)(*v19 + 12) > v8)
        {
          v21 = v19[7];
          v22 = v8 >> 6;
          v23 = *(_QWORD *)(v21 + 8 * v22);
          if ((v23 & (1 << v8)) != 0)
          {
            *(_DWORD *)(v20 + *(_QWORD *)v20 + 4 * *(unsigned int *)(v20 + 8)) = v8;
            *(_QWORD *)(v21 + 8 * v22) = v23 & ~(1 << v8);
            ++*(_DWORD *)(v20 + 8);
          }
        }
        v24 = std::remove[abi:ne180100]<std::__wrap_iter<unsigned int *>,unsigned int>((__int32 *)v14[6], v18, &v45);
        if ((__int32 *)v14[7] != v24)
          v14[7] = (uint64_t)v24;
        std::__tree<std::__value_type<unsigned long,std::list<long long>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::list<long long>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::list<long long>>>>::__erase_unique<unsigned long>(this + 11, v8);
        if (v43)
        {
          v25 = (uint64_t *)&v43;
          v26 = v43;
          do
          {
            v27 = v26;
            v28 = v25;
            v29 = v26[4];
            v30 = v26 + 1;
            if (v29 >= v8)
              v25 = v26;
            else
              ++v26;
            v26 = (uint64_t *)*v26;
          }
          while (v26);
          if (v25 != (uint64_t *)&v43)
          {
            if (v29 < v8)
              v27 = v28;
            if (v8 >= v27[4])
            {
              v31 = v28 + 1;
              if (v29 >= v8)
                v31 = v30;
              v32 = (uint64_t *)*v31;
              v33 = v25;
              if (*v31)
              {
                do
                {
                  v34 = (uint64_t **)v32;
                  v32 = (uint64_t *)*v32;
                }
                while (v32);
              }
              else
              {
                do
                {
                  v34 = (uint64_t **)v33[2];
                  v35 = *v34 == v33;
                  v33 = (uint64_t *)v34;
                }
                while (!v35);
              }
              if (v42 == (uint64_t **)v25)
                v42 = v34;
              --v44;
              std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v43, v25);
              operator delete(v25);
            }
          }
        }
      }
      ++v6;
      v4 = *a2;
      if (v6 >= (a2[1] - *a2) >> 3)
        goto LABEL_40;
    }
    v36 = &CVML_status_invalidParameter;
  }
  v37 = (*v36 + 128) | 0x1400;
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(v43);
  return v37;
}

void sub_1A15569B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, _QWORD *a14)
{
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(a14);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::GreedyClustererFaces::getCountForCluster(vision::mod::GreedyClustererFaces *this, uint64_t a2)
{
  char *v4;
  _QWORD *v5;
  char *v6;
  uint64_t v7;
  BOOL v8;
  _QWORD *v9;
  char *v10;
  uint64_t result;
  uint64_t v12;
  char *v13;
  char *v14;
  BOOL v15;

  if (!vision::mod::GreedyClustererFaces::isFaceIdInClustererState(this, a2))
    return 0;
  v4 = (char *)this + 144;
  v5 = (_QWORD *)*((_QWORD *)this + 18);
  if (!v5)
    goto LABEL_12;
  v6 = (char *)this + 144;
  do
  {
    v7 = v5[4];
    v8 = v7 < a2;
    if (v7 >= a2)
      v9 = v5;
    else
      v9 = v5 + 1;
    if (!v8)
      v6 = (char *)v5;
    v5 = (_QWORD *)*v9;
  }
  while (*v9);
  if (v6 == v4 || *((_QWORD *)v6 + 4) > a2)
LABEL_12:
    v6 = (char *)this + 144;
  v10 = (char *)*((_QWORD *)this + 17);
  if (v10 == v4)
    return 0;
  result = 0;
  v12 = *((_QWORD *)v6 + 5);
  do
  {
    if (*((_QWORD *)v10 + 5) == v12)
      ++result;
    v13 = (char *)*((_QWORD *)v10 + 1);
    if (v13)
    {
      do
      {
        v14 = v13;
        v13 = *(char **)v13;
      }
      while (v13);
    }
    else
    {
      do
      {
        v14 = (char *)*((_QWORD *)v10 + 2);
        v15 = *(_QWORD *)v14 == (_QWORD)v10;
        v10 = v14;
      }
      while (!v15);
    }
    v10 = v14;
  }
  while (v14 != v4);
  return result;
}

void `non-virtual thunk to'vision::mod::GreedyClustererFaces::~GreedyClustererFaces(vision::mod::GreedyClustererFaces *this)
{
  vision::mod::GreedyClustererFaces::~GreedyClustererFaces((vision::mod::GreedyClustererFaces *)((char *)this - 8));
}

{
  vision::mod::GreedyClustererFaces::~GreedyClustererFaces((vision::mod::GreedyClustererFaces *)((char *)this - 8));
  JUMPOUT(0x1A1B0A898);
}

uint64_t vision::mod::GreedyClustererFaces::isFaceIdInClustererState(vision::mod::GreedyClustererFaces *this, uint64_t a2)
{
  _QWORD *v2;
  const char *v3;
  uint64_t v4;
  _QWORD *v6;
  uint64_t v7;

  v2 = (_QWORD *)*((_QWORD *)this + 18);
  if (!v2)
  {
    v3 = "FaceId=%lld not present in clustering";
LABEL_9:
    syslog(5, v3, a2);
    return 0;
  }
  v3 = "FaceId=%lld not present in clustering";
  while (1)
  {
    v4 = v2[4];
    if (v4 <= a2)
      break;
LABEL_6:
    v2 = (_QWORD *)*v2;
    if (!v2)
      goto LABEL_9;
  }
  if (v4 < a2)
  {
    ++v2;
    goto LABEL_6;
  }
  v6 = (_QWORD *)*((_QWORD *)this + 15);
  if (!v6)
  {
    syslog(5, "FaceId=%lld not present in l0 clustering");
    return 0;
  }
  v3 = "FaceId=%lld not present in l0 clustering";
  while (1)
  {
    v7 = v6[4];
    if (v7 <= a2)
      break;
LABEL_17:
    v6 = (_QWORD *)*v6;
    if (!v6)
      goto LABEL_9;
  }
  if (v7 < a2)
  {
    ++v6;
    goto LABEL_17;
  }
  return 1;
}

uint64_t *std::__tree<long long>::__emplace_unique_key_args<long long,long long>(uint64_t *result, uint64_t a2, uint64_t a3)
{
  uint64_t **v4;
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  uint64_t v8;
  uint64_t *v9;

  v4 = (uint64_t **)result;
  v6 = (uint64_t **)(result + 1);
  v5 = (uint64_t *)result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = v5[4];
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = (uint64_t **)(result + 1);
LABEL_9:
    v9 = (uint64_t *)operator new(0x28uLL);
    v9[4] = a3;
    return std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at(v4, (uint64_t)v7, v6, v9);
  }
  return result;
}

void vision::mod::GreedyClustererFaces::computeDeltaAfterUpdate(uint64_t a1, uint64_t **a2, uint64_t *a3)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  void **v10;
  void **v11;
  void **v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t *v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  void **v20;
  uint64_t *v21;
  char *v22;
  uint64_t v23;
  uint64_t ***v24;
  uint64_t **v25;
  void (__cdecl *v26)(std::__shared_weak_count *__hidden);
  std::__shared_weak_count *v27;
  unint64_t shared_weak_owners;
  std::__shared_weak_count_vtbl *shared_owners;
  void (__cdecl **p_on_zero_shared)(std::__shared_count *__hidden);
  std::__shared_weak_count_vtbl *v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  _QWORD *v38;
  uint64_t **v39;
  uint64_t ***v40;
  void **v41;
  void **v42;
  std::__shared_weak_count *v43;
  unint64_t *v44;
  unint64_t v45;
  unint64_t v46;
  uint64_t *v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  _QWORD *v51;
  _QWORD *v52;
  uint64_t v53;
  uint64_t v54;
  std::__shared_weak_count *v55;
  unint64_t v56;
  uint64_t *v57;
  _QWORD *v58;
  std::__shared_weak_count_vtbl *v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  uint64_t *v65;
  uint64_t *v66;
  uint64_t ***v67;
  uint64_t v68;
  uint64_t ***i;
  uint64_t v70;
  uint64_t **v71;
  uint64_t ***v72;
  uint64_t *v73;
  unint64_t v74;
  unint64_t v75;
  std::__shared_weak_count *v76;
  uint64_t *v77;
  unint64_t v78;
  uint64_t v79;
  uint64_t *v80;
  unint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  unint64_t v85;
  uint64_t *v86;
  uint64_t v87;
  unsigned int v88;
  uint64_t *v89;
  uint64_t *v90;
  uint64_t *v91;
  unint64_t v92;
  uint64_t *v93;
  unint64_t v94;
  uint64_t *v95;
  unint64_t v96;
  uint64_t *v97;
  unint64_t v98;
  uint64_t *v99;
  unint64_t v100;
  uint64_t *v101;
  unint64_t v102;
  uint64_t v103;
  _QWORD *v104;
  uint64_t DeepCopy;
  const void **v106;
  const void **v107;
  uint64_t ***v108;
  uint64_t ***v109;
  BOOL v110;
  uint64_t *v111;
  uint64_t v112;
  uint64_t ***v113;
  unsigned int v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  double v120;
  unint64_t v121;
  double v122;
  double v123;
  double v124;
  uint64_t v125;
  float *v126;
  float *v127;
  float v128;
  float v129;
  float v130;
  uint64_t *v131;
  unint64_t v132;
  unsigned int *v133;
  unint64_t v134;
  int *v135;
  int *v136;
  uint64_t v137;
  uint64_t v138;
  int *v139;
  uint64_t v140;
  unint64_t v141;
  unint64_t v142;
  uint64_t v143;
  int *v144;
  uint64_t v145;
  unint64_t v146;
  uint64_t v147;
  char *v148;
  int *v149;
  char *v150;
  uint64_t v151;
  unint64_t v152;
  uint64_t v153;
  unint64_t v154;
  uint64_t v155;
  int *v156;
  void *v157;
  int v158;
  char *v159;
  unint64_t v160;
  uint64_t v161;
  unsigned int v162;
  unint64_t v163;
  unint64_t v164;
  unint64_t v166;
  unsigned int v167;
  unsigned int v168;
  unint64_t v169;
  int v170;
  unint64_t v171;
  float v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  unsigned int v176;
  unint64_t v177;
  double v178;
  unint64_t v179;
  double v180;
  double v181;
  double v182;
  unint64_t v183;
  float *v184;
  float *v185;
  uint64_t v186;
  float v187;
  float v188;
  float v189;
  unsigned int v190;
  unint64_t v191;
  unint64_t v192;
  unint64_t v193;
  unint64_t v194;
  uint64_t v195;
  char *v196;
  char *v197;
  _QWORD *v198;
  char *v199;
  uint64_t v200;
  unint64_t v201;
  uint64_t v202;
  unint64_t v203;
  uint64_t v204;
  unint64_t *v205;
  unint64_t *v206;
  unint64_t *v207;
  unint64_t v208;
  uint64_t v209;
  unint64_t *v210;
  unint64_t v211;
  unint64_t *v212;
  unint64_t v213;
  unint64_t v214;
  unint64_t *v215;
  unint64_t v216;
  uint64_t *v217;
  _QWORD *v218;
  uint64_t v219;
  unint64_t *v220;
  unint64_t *v221;
  unint64_t v222;
  unint64_t *v223;
  unint64_t v224;
  _QWORD *v225;
  _QWORD *v226;
  unint64_t v227;
  BOOL v228;
  _QWORD *v229;
  _QWORD *v230;
  unint64_t v231;
  _QWORD *v232;
  unint64_t v233;
  BOOL v234;
  _QWORD *v235;
  _QWORD *v236;
  _QWORD *v237;
  unint64_t v238;
  char *v239;
  char *v240;
  uint64_t v241;
  char *v242;
  uint64_t v243;
  unint64_t v244;
  unint64_t v245;
  uint64_t v246;
  char *v247;
  uint64_t v248;
  std::__shared_weak_count *v249;
  char **v250;
  uint64_t *v251;
  std::__shared_weak_count *v252;
  unint64_t *v253;
  unint64_t v254;
  unint64_t *v255;
  unint64_t v256;
  char *v257;
  unint64_t v258;
  uint64_t v259;
  uint64_t v260;
  std::__shared_weak_count *v261;
  uint64_t *v262;
  uint64_t *v263;
  uint64_t v264;
  uint64_t *v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t *v269;
  uint64_t v270;
  _QWORD *v271;
  uint64_t v272;
  uint64_t v273;
  unint64_t v274;
  uint64_t *v275;
  uint64_t *v276;
  uint64_t **v277;
  uint64_t *v278;
  uint64_t v279;
  unint64_t v280;
  uint64_t v281;
  unint64_t v282;
  uint64_t v283;
  uint64_t *v284;
  uint64_t *v285;
  uint64_t *v286;
  uint64_t *v287;
  std::__shared_weak_count *v288;
  uint64_t *v289;
  unint64_t v290;
  _QWORD *v291;
  _QWORD *v292;
  _QWORD *v293;
  _QWORD *exception;
  _QWORD *v295;
  std::__shared_weak_count *v296;
  std::__shared_weak_count *v297;
  uint64_t **v298;
  std::__shared_weak_count *v299;
  uint64_t *v300;
  uint64_t v302;
  uint64_t *v303;
  uint64_t v305;
  unint64_t *j;
  uint64_t ***v307;
  std::__shared_weak_count *v308;
  std::__shared_weak_count *v309;
  std::__shared_weak_count *v310;
  unint64_t v311;
  std::__shared_weak_count *v312;
  std::__shared_weak_count *v313;
  unint64_t *v314;
  std::__shared_weak_count *v315;
  uint64_t ***v316;
  std::__shared_weak_count *v317;
  uint64_t ***v318;
  std::__shared_weak_count *v319;
  uint64_t ***v320;
  uint64_t ***v321;
  uint64_t v322;
  void *__p[2];
  __int128 v324;
  __int128 v325;
  uint64_t v326;
  uint64_t ***v327;
  std::__shared_weak_count *v328;
  uint64_t ***v329;
  _QWORD *v330[2];
  uint64_t v331[2];
  unint64_t *v332;
  std::__shared_weak_count *v333;
  uint64_t *v334;
  uint64_t *v335;
  _QWORD *v336;
  float __C;
  char **v338;
  char *v339;
  unint64_t v340;

  *(_BYTE *)(a1 + 80) = 1;
  v4 = (std::__shared_weak_count *)operator new(0x30uLL);
  v4->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v4->__shared_owners_;
  v4->__shared_weak_owners_ = 0;
  v4[1].__vftable = 0;
  v4->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453BBC0;
  v4[1].__shared_owners_ = 0;
  v4[1].__shared_weak_owners_ = 0;
  v314 = (unint64_t *)&v4[1];
  v315 = v4;
  v312 = v4 + 1;
  v313 = v4;
  v296 = v4;
  do
    v6 = __ldxr(p_shared_owners);
  while (__stxr(v6 + 1, p_shared_owners));
  __p[1] = 0;
  *(_QWORD *)&v324 = 0;
  __p[0] = &__p[1];
  v339 = 0;
  v340 = 0;
  v338 = &v339;
  v7 = *(_QWORD **)(a1 + 136);
  v298 = (uint64_t **)(a1 + 136);
  if (v7 == (_QWORD *)(a1 + 144))
    goto LABEL_121;
  do
  {
    v8 = v7[5];
    v9 = *std::map<long long,unsigned long>::at(*(_QWORD **)(a1 + 120), v7[4]);
    v10 = (void **)__p[1];
    v11 = &__p[1];
    v12 = &__p[1];
    if (__p[1])
    {
      while (1)
      {
        while (1)
        {
          v12 = v10;
          v13 = (uint64_t)v10[4];
          if (v8 >= v13)
            break;
          v10 = (void **)*v12;
          v11 = v12;
          if (!*v12)
            goto LABEL_11;
        }
        if (v13 >= v8)
          break;
        v10 = (void **)v12[1];
        if (!v10)
        {
          v11 = v12 + 1;
          goto LABEL_11;
        }
      }
      v14 = (uint64_t *)v12;
    }
    else
    {
LABEL_11:
      v14 = (uint64_t *)operator new(0x40uLL);
      v14[7] = 0;
      v14[6] = 0;
      v14[4] = v8;
      v14[5] = (uint64_t)(v14 + 6);
      *v14 = 0;
      v14[1] = 0;
      v14[2] = (uint64_t)v12;
      *v11 = v14;
      v15 = v14;
      if (*(_QWORD *)__p[0])
      {
        __p[0] = *(void **)__p[0];
        v15 = (uint64_t *)*v11;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)__p[1], v15);
      *(_QWORD *)&v324 = v324 + 1;
    }
    std::__tree<long long>::__emplace_unique_key_args<long long,long long>(v14 + 5, v9, v9);
    v16 = (_QWORD *)a3[1];
    if (!v16)
      goto LABEL_22;
    while (1)
    {
      v17 = v16[4];
      if (v9 >= v17)
        break;
LABEL_19:
      v16 = (_QWORD *)*v16;
      if (!v16)
        goto LABEL_22;
    }
    if (v17 < v9)
    {
      ++v16;
      goto LABEL_19;
    }
    std::__tree<long long>::__emplace_unique_key_args<long long,long long>((uint64_t *)&v338, v8, v8);
LABEL_22:
    v18 = (_QWORD *)v7[1];
    if (v18)
    {
      do
      {
        v19 = v18;
        v18 = (_QWORD *)*v18;
      }
      while (v18);
    }
    else
    {
      do
      {
        v19 = (_QWORD *)v7[2];
        v110 = *v19 == (_QWORD)v7;
        v7 = v19;
      }
      while (!v110);
    }
    v7 = v19;
  }
  while (v19 != (_QWORD *)(a1 + 144));
  v20 = (void **)__p[0];
  if (__p[0] == &__p[1])
    goto LABEL_121;
  while (2)
  {
    v334 = (uint64_t *)v20[4];
    std::set<long long>::set[abi:ne180100](&v335, v20 + 5);
    v21 = v334;
    std::set<long long>::set[abi:ne180100](&v329, &v335);
    v22 = v339;
    if (!v339)
    {
LABEL_34:
      v24 = v329;
      if (v329 != v330)
      {
        LODWORD(v25) = -1;
        do
        {
          v26 = (void (__cdecl *)(std::__shared_weak_count *__hidden))v24[4];
          if ((_DWORD)v25 == -1)
          {
            v25 = v24[4];
          }
          else
          {
            if ((uint64_t)v26 <= (int)v25)
              __assert_rtn("computeInitialMergingList", "GreedyClustering.cpp", 1781, "L0 > mergingTo");
            v27 = v312;
            shared_owners = (std::__shared_weak_count_vtbl *)v312->__shared_owners_;
            shared_weak_owners = v312->__shared_weak_owners_;
            if ((unint64_t)shared_owners >= shared_weak_owners)
            {
              v31 = v312->__vftable;
              v32 = ((char *)shared_owners - (char *)v312->__vftable) >> 4;
              v33 = v32 + 1;
              if ((unint64_t)(v32 + 1) >> 60)
                std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
              v34 = shared_weak_owners - (_QWORD)v31;
              if (v34 >> 3 > v33)
                v33 = v34 >> 3;
              v228 = (unint64_t)v34 >= 0x7FFFFFFFFFFFFFF0;
              v35 = 0xFFFFFFFFFFFFFFFLL;
              if (!v228)
                v35 = v33;
              if (v35)
              {
                v35 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<vision::mod::DescriptorItemSideInfo>>(v35);
                v31 = v312->__vftable;
                shared_owners = (std::__shared_weak_count_vtbl *)v312->__shared_owners_;
              }
              else
              {
                v36 = 0;
              }
              v37 = (_QWORD *)(v35 + 16 * v32);
              *v37 = (int)v25;
              v37[1] = v26;
              v38 = v37;
              if (shared_owners != v31)
              {
                do
                {
                  *((_OWORD *)v38 - 1) = *(_OWORD *)&shared_owners[-1].__get_deleter;
                  v38 -= 2;
                  shared_owners = (std::__shared_weak_count_vtbl *)((char *)shared_owners - 16);
                }
                while (shared_owners != v31);
                v31 = v27->__vftable;
              }
              p_on_zero_shared = (void (__cdecl **)(std::__shared_count *__hidden))(v37 + 2);
              v27->__vftable = (std::__shared_weak_count_vtbl *)v38;
              v27->__shared_owners_ = (uint64_t)(v37 + 2);
              v27->__shared_weak_owners_ = v35 + 16 * v36;
              if (v31)
                operator delete(v31);
            }
            else
            {
              shared_owners->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))(int)v25;
              shared_owners->~__shared_weak_count_0 = v26;
              p_on_zero_shared = &shared_owners->__on_zero_shared;
            }
            v27->__shared_owners_ = (uint64_t)p_on_zero_shared;
          }
          v39 = v24[1];
          if (v39)
          {
            do
            {
              v40 = (uint64_t ***)v39;
              v39 = (uint64_t **)*v39;
            }
            while (v39);
          }
          else
          {
            do
            {
              v40 = (uint64_t ***)v24[2];
              v110 = *v40 == (uint64_t **)v24;
              v24 = v40;
            }
            while (!v110);
          }
          v24 = v40;
        }
        while (v40 != v330);
      }
      goto LABEL_61;
    }
    while (2)
    {
      v23 = *((_QWORD *)v22 + 4);
      if ((uint64_t)v21 < v23)
      {
LABEL_33:
        v22 = *(char **)v22;
        if (!v22)
          goto LABEL_34;
        continue;
      }
      break;
    }
    if (v23 < (uint64_t)v21)
    {
      v22 += 8;
      goto LABEL_33;
    }
    v43 = (std::__shared_weak_count *)operator new(0x30uLL);
    v43->__shared_owners_ = 0;
    v44 = (unint64_t *)&v43->__shared_owners_;
    v43->__shared_weak_owners_ = 0;
    v43->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453BBC0;
    v43[1].__shared_owners_ = 0;
    v43[1].__shared_weak_owners_ = 0;
    v43[1].__vftable = 0;
    v309 = v43 + 1;
    v310 = v43;
    v332 = (unint64_t *)&v43[1];
    v333 = v43;
    do
      v45 = __ldxr(v44);
    while (__stxr(v45 + 1, v44));
    vision::mod::GreedyClusterer::computeMergePairs(a1 + 8, &v329, &v329, (uint64_t *)&v332, 0);
    do
      v46 = __ldaxr(v44);
    while (__stlxr(v46 - 1, v44));
    if (!v46)
    {
      ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
      std::__shared_weak_count::__release_weak(v43);
    }
    v321 = 0;
    v322 = 0;
    v320 = (uint64_t ***)&v321;
    v47 = (uint64_t *)v309->__vftable;
    v48 = (uint64_t *)v309->__shared_owners_;
    while (v47 != v48)
    {
      v50 = *v47;
      v49 = v47[1];
      std::__tree<long long>::__emplace_unique_key_args<long long,long long>((uint64_t *)&v320, *v47, *v47);
      std::__tree<long long>::__emplace_unique_key_args<long long,long long>((uint64_t *)&v320, v49, v49);
      v51 = (_QWORD *)a3[1];
      if (v51)
      {
        v52 = (_QWORD *)a3[1];
        do
        {
          v53 = v52[4];
          if (v50 >= v53)
          {
            if (v53 >= v50)
              goto LABEL_102;
            ++v52;
          }
          v52 = (_QWORD *)*v52;
        }
        while (v52);
        do
        {
          v54 = v51[4];
          if (v49 >= v54)
          {
            if (v54 >= v49)
              goto LABEL_102;
            ++v51;
          }
          v51 = (_QWORD *)*v51;
        }
        while (v51);
      }
      v55 = v312;
      v57 = (uint64_t *)v312->__shared_owners_;
      v56 = v312->__shared_weak_owners_;
      if ((unint64_t)v57 >= v56)
      {
        v59 = v312->__vftable;
        v60 = ((char *)v57 - (char *)v312->__vftable) >> 4;
        v61 = v60 + 1;
        if ((unint64_t)(v60 + 1) >> 60)
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        v62 = v56 - (_QWORD)v59;
        if (v62 >> 3 > v61)
          v61 = v62 >> 3;
        v228 = (unint64_t)v62 >= 0x7FFFFFFFFFFFFFF0;
        v63 = 0xFFFFFFFFFFFFFFFLL;
        if (!v228)
          v63 = v61;
        if (v63)
        {
          v63 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<vision::mod::DescriptorItemSideInfo>>(v63);
          v59 = v312->__vftable;
          v57 = (uint64_t *)v312->__shared_owners_;
        }
        else
        {
          v64 = 0;
        }
        v65 = (uint64_t *)(v63 + 16 * v60);
        *v65 = v50;
        v65[1] = v49;
        v66 = v65;
        if (v57 != (uint64_t *)v59)
        {
          do
          {
            *((_OWORD *)v66 - 1) = *((_OWORD *)v57 - 1);
            v66 -= 2;
            v57 -= 2;
          }
          while (v57 != (uint64_t *)v59);
          v59 = v55->__vftable;
        }
        v58 = v65 + 2;
        v55->__vftable = (std::__shared_weak_count_vtbl *)v66;
        v55->__shared_owners_ = (uint64_t)(v65 + 2);
        v55->__shared_weak_owners_ = v63 + 16 * v64;
        if (v59)
          operator delete(v59);
      }
      else
      {
        *v57 = v50;
        v57[1] = v49;
        v58 = v57 + 2;
      }
      v55->__shared_owners_ = (uint64_t)v58;
LABEL_102:
      v47 += 2;
    }
    v67 = v329;
    if (v329 != v330)
    {
      do
      {
        v68 = (uint64_t)v67[4];
        for (i = v321; i; i = (uint64_t ***)*i)
        {
          v70 = (uint64_t)i[4];
          if (v68 >= v70)
          {
            if (v70 >= v68)
              goto LABEL_110;
            ++i;
          }
        }
        std::__tree<long long>::__emplace_unique_key_args<long long,long long>(a3, v68, (uint64_t)v67[4]);
LABEL_110:
        v71 = v67[1];
        if (v71)
        {
          do
          {
            v72 = (uint64_t ***)v71;
            v71 = (uint64_t **)*v71;
          }
          while (v71);
        }
        else
        {
          do
          {
            v72 = (uint64_t ***)v67[2];
            v110 = *v72 == (uint64_t **)v67;
            v67 = v72;
          }
          while (!v110);
        }
        v67 = v72;
      }
      while (v72 != v330);
    }
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(v321);
    if (v310)
    {
      v73 = &v310->__shared_owners_;
      do
        v74 = __ldaxr((unint64_t *)v73);
      while (__stlxr(v74 - 1, (unint64_t *)v73));
      if (!v74)
      {
        ((void (*)(std::__shared_weak_count *))v310->__on_zero_shared)(v310);
        std::__shared_weak_count::__release_weak(v310);
      }
    }
LABEL_61:
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(v330[0]);
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(v336);
    v41 = (void **)v20[1];
    if (v41)
    {
      do
      {
        v42 = v41;
        v41 = (void **)*v41;
      }
      while (v41);
    }
    else
    {
      do
      {
        v42 = (void **)v20[2];
        v110 = *v42 == v20;
        v20 = v42;
      }
      while (!v110);
    }
    v20 = v42;
    if (v42 != &__p[1])
      continue;
    break;
  }
LABEL_121:
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(v339);
  std::__tree<std::__value_type<unsigned int,std::set<unsigned int>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::set<unsigned int>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::set<unsigned int>>>>::destroy((_QWORD *)__p[1]);
  do
    v75 = __ldaxr(p_shared_owners);
  while (__stlxr(v75 - 1, p_shared_owners));
  if (!v75)
  {
    ((void (*)(std::__shared_weak_count *))v296->__on_zero_shared)(v296);
    std::__shared_weak_count::__release_weak(v296);
  }
  v76 = v315;
  v307 = (uint64_t ***)v314;
  v308 = v315;
  if (v315)
  {
    v77 = &v315->__shared_owners_;
    do
      v78 = __ldxr((unint64_t *)v77);
    while (__stxr(v78 + 1, (unint64_t *)v77));
    v79 = a1 + 8;
    v318 = (uint64_t ***)v314;
    v319 = v315;
    v80 = &v315->__shared_owners_;
    do
      v81 = __ldxr((unint64_t *)v80);
    while (__stxr(v81 + 1, (unint64_t *)v80));
    v82 = a1;
  }
  else
  {
    v82 = a1;
    v79 = a1 + 8;
    v318 = (uint64_t ***)v314;
    v319 = 0;
  }
  v83 = *(_QWORD *)(v82 + 64);
  v297 = v315;
  if (*(_QWORD *)(v83 + 56) != *(_QWORD *)(v83 + 48))
  {
    v302 = v79;
    vision::mod::dist_greedy_status_t::dist_greedy_status_t((uint64_t)&v334, *(_DWORD *)(v83 + 104), *(_DWORD *)(a1 + 28));
    v84 = *(_QWORD *)(a1 + 64);
    v339 = 0;
    v340 = 0;
    v338 = &v339;
    if (*(_QWORD *)(v84 + 56) != *(_QWORD *)(v84 + 48))
    {
      v85 = 0;
      v86 = (uint64_t *)*a3;
      v87 = v84;
      do
      {
        v88 = *(_DWORD *)(*(_QWORD *)(v84 + 48) + 4 * v85);
        if (v88 != *(_DWORD *)(**(_QWORD **)(v87 + 72)
                              + *(unsigned int *)(**(_QWORD **)(v87 + 72) + 16) * (unint64_t)v88
                              + 24))
          __assert_rtn("getMergeableClusters", "GreedyClustering.cpp", 978, "ci == clusterID");
        if (v86 == a3 + 1 || v86[4] != v88)
        {
          std::__tree<long long>::__emplace_unique_key_args<long long,long long>((uint64_t *)&v338, (int)v88, (int)v88);
          v87 = *(_QWORD *)(a1 + 64);
        }
        else
        {
          v89 = (uint64_t *)v86[1];
          if (v89)
          {
            do
            {
              v86 = v89;
              v89 = (uint64_t *)*v89;
            }
            while (v89);
          }
          else
          {
            do
            {
              v90 = v86;
              v86 = (uint64_t *)v86[2];
            }
            while ((uint64_t *)*v86 != v90);
          }
        }
        ++v85;
      }
      while (v85 < (uint64_t)(*(_QWORD *)(v87 + 56) - *(_QWORD *)(v87 + 48)) >> 2);
    }
    v332 = v314;
    v333 = v315;
    if (v315)
    {
      v91 = &v315->__shared_owners_;
      do
        v92 = __ldxr((unint64_t *)v91);
      while (__stxr(v92 + 1, (unint64_t *)v91));
    }
    vision::mod::GreedyClusterer::computeMergePairs(v302, &v338, a3, (uint64_t *)&v332, 1);
    if (v315)
    {
      v93 = &v315->__shared_owners_;
      do
        v94 = __ldaxr((unint64_t *)v93);
      while (__stlxr(v94 - 1, (unint64_t *)v93));
      if (!v94)
      {
        ((void (*)(std::__shared_weak_count *))v315->__on_zero_shared)(v315);
        std::__shared_weak_count::__release_weak(v315);
      }
    }
    v331[0] = (uint64_t)v318;
    v331[1] = (uint64_t)v319;
    if (v319)
    {
      v95 = &v319->__shared_owners_;
      do
        v96 = __ldxr((unint64_t *)v95);
      while (__stxr(v96 + 1, (unint64_t *)v95));
    }
    vision::mod::GreedyClusterer::computeMergePairs(v302, a3, a3, v331, 0);
    if (v319)
    {
      v97 = &v319->__shared_owners_;
      do
        v98 = __ldaxr((unint64_t *)v97);
      while (__stlxr(v98 - 1, (unint64_t *)v97));
      if (!v98)
      {
        ((void (*)(std::__shared_weak_count *))v319->__on_zero_shared)(v319);
        std::__shared_weak_count::__release_weak(v319);
      }
    }
    v327 = v318;
    v328 = v319;
    if (v319)
    {
      v99 = &v319->__shared_owners_;
      do
        v100 = __ldxr((unint64_t *)v99);
      while (__stxr(v100 + 1, (unint64_t *)v99));
    }
    vision::mod::GreedyClusterer::getConnectedComponents((uint64_t *)&v329, v302, *v318, v318[1]);
    if (v319)
    {
      v101 = &v319->__shared_owners_;
      do
        v102 = __ldaxr((unint64_t *)v101);
      while (__stlxr(v102 - 1, (unint64_t *)v101));
      if (!v102)
      {
        ((void (*)(std::__shared_weak_count *))v319->__on_zero_shared)(v319);
        std::__shared_weak_count::__release_weak(v319);
      }
    }
    v103 = *(_QWORD *)(a1 + 64);
    *(_OWORD *)__p = 0u;
    v324 = 0u;
    v325 = 0u;
    v326 = 0;
    v104 = *(_QWORD **)(v103 + 72);
    if (!v104)
    {
      exception = __cxa_allocate_exception(8uLL);
      *exception = 5215;
      __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
    }
    DeepCopy = cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>::createDeepCopy(v104);
    if (!DeepCopy)
    {
      syslog(5, "GreedyClusterer::clusters_t: Cannot clone MMapVector object");
      v295 = __cxa_allocate_exception(8uLL);
      *v295 = 5246;
      __cxa_throw(v295, MEMORY[0x1E0DE4F28], 0);
    }
    std::shared_ptr<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>>::reset[abi:ne180100]<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>,void>((uint64_t)&v324 + 8, DeepCopy);
    std::shared_ptr<vision::mod::ImageDescriptorProcessorAbstract>::operator=[abi:ne180100]((_QWORD *)&v325 + 1, *((uint64_t *)&v324 + 1), v325);
    if (__p != (void **)(v103 + 48))
      std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)__p, *(char **)(v103 + 48), *(_QWORD *)(v103 + 56), (uint64_t)(*(_QWORD *)(v103 + 56) - *(_QWORD *)(v103 + 48)) >> 2);
    v106 = (const void **)v329;
    v107 = (const void **)v330[0];
    if (v329 != v330[0])
    {
      do
      {
        v320 = 0;
        v321 = 0;
        v322 = 0;
        std::vector<unsigned long>::__init_with_size[abi:ne180100]<unsigned long *,unsigned long *>(&v320, *v106, (uint64_t)v106[1], ((_BYTE *)v106[1] - (_BYTE *)*v106) >> 3);
        v108 = v320;
        v109 = v321;
        v110 = (unint64_t)((char *)v321 - (char *)v320) < 9 || v320 == v321;
        if (!v110)
        {
          v111 = (uint64_t *)*((_QWORD *)&v324 + 1);
          v112 = 0xFFFFFFFFLL;
          v113 = v320;
          do
          {
            v114 = *(_DWORD *)v113;
            if (v112 == 0xFFFFFFFFLL)
            {
              v112 = *(unsigned int *)v113;
            }
            else
            {
              v115 = *v111;
              v116 = *v111 + 24;
              v117 = *(unsigned int *)(*v111 + 16);
              v118 = v117 * v112;
              v119 = v116 + v117 * v112;
              v120 = (double)*(int *)(v119 + 8);
              v121 = v116 + v114 * (unint64_t)v117;
              v122 = (double)*(int *)(v121 + 8);
              v123 = v120 + v122;
              v124 = 1.0 / (v120 + v122);
              v125 = *(unsigned int *)(*(_QWORD *)(a1 + 64) + 104);
              if ((int)v125 >= 1)
              {
                v126 = (float *)(v115 + 40 + v114 * (unint64_t)v117);
                v127 = (float *)(v115 + 40 + v118);
                do
                {
                  v128 = *v126++;
                  v129 = v124 * (v120 * *v127 + v122 * v128);
                  *v127++ = v129;
                  --v125;
                }
                while (v125);
              }
              v130 = v124 * (v122 * *(float *)(v121 + 12) + *(float *)(v119 + 12) * v120);
              *(float *)(v119 + 12) = v130;
              *(_DWORD *)(v119 + 8) = (int)v123;
              *(_DWORD *)(v116 + v114 * (unint64_t)*(unsigned int *)(v115 + 16) + 8) = 0;
            }
            ++v113;
          }
          while (v113 != v109);
        }
        if (v108)
          operator delete(v108);
        v106 += 3;
      }
      while (v106 != v107);
    }
    v320 = v318;
    v321 = (uint64_t ***)v319;
    if (v319)
    {
      v131 = &v319->__shared_owners_;
      do
        v132 = __ldxr((unint64_t *)v131);
      while (__stxr(v132 + 1, (unint64_t *)v131));
    }
    v299 = v319;
    if ((*(unsigned int (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32)))
    {
      v133 = (unsigned int *)__p[0];
      if (__p[0] == __p[1])
      {
        v139 = 0;
        v136 = 0;
      }
      else
      {
        v134 = 0;
        v135 = 0;
        v136 = 0;
        do
        {
          if (!*((_QWORD *)&v324 + 1))
          {
            v292 = __cxa_allocate_exception(8uLL);
            *v292 = 5246;
            __cxa_throw(v292, MEMORY[0x1E0DE4F28], 0);
          }
          v137 = *v133;
          v138 = *(unsigned int *)(**((_QWORD **)&v324 + 1)
                                 + *(unsigned int *)(**((_QWORD **)&v324 + 1) + 16)
                                 * (unint64_t)v137
                                 + 32);
          if ((unint64_t)v135 >= v134)
          {
            v140 = ((char *)v135 - (char *)v136) >> 3;
            v141 = v140 + 1;
            if ((unint64_t)(v140 + 1) >> 61)
              std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
            if ((uint64_t)(v134 - (_QWORD)v136) >> 2 > v141)
              v141 = (uint64_t)(v134 - (_QWORD)v136) >> 2;
            if (v134 - (unint64_t)v136 >= 0x7FFFFFFFFFFFFFF8)
              v142 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v142 = v141;
            if (v142)
              v142 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v142);
            else
              v143 = 0;
            v144 = (int *)(v142 + 8 * v140);
            *(_QWORD *)v144 = v137 | (v138 << 32);
            v139 = v144 + 2;
            if (v135 != v136)
            {
              do
              {
                v145 = *((_QWORD *)v135 - 1);
                v135 -= 2;
                *((_QWORD *)v144 - 1) = v145;
                v144 -= 2;
              }
              while (v135 != v136);
              v135 = v136;
            }
            v136 = v144;
            v134 = v142 + 8 * v143;
            if (v135)
              operator delete(v135);
          }
          else
          {
            *(_QWORD *)v135 = v137 | (v138 << 32);
            v139 = v135 + 2;
          }
          ++v133;
          v135 = v139;
        }
        while (v133 != __p[1]);
      }
      v146 = 126 - 2 * __clz(((char *)v139 - (char *)v136) >> 3);
      if (v139 == v136)
        v147 = 0;
      else
        v147 = v146;
      std::__introsort<std::_ClassicAlgPolicy,vision::mod::GreedyClusterer::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*,false>(v136, v139, v147, 1);
      v148 = (char *)__p[0];
      __p[1] = __p[0];
      if (v139 != v136)
      {
        v149 = v136;
        do
        {
          if ((unint64_t)v148 >= (unint64_t)v324)
          {
            v150 = (char *)__p[0];
            v151 = (v148 - (char *)__p[0]) >> 2;
            v152 = v151 + 1;
            if ((unint64_t)(v151 + 1) >> 62)
              std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
            v153 = v324 - (unint64_t)__p[0];
            if ((uint64_t)(v324 - (unint64_t)__p[0]) >> 1 > v152)
              v152 = v153 >> 1;
            if ((unint64_t)v153 >= 0x7FFFFFFFFFFFFFFCLL)
              v154 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v154 = v152;
            if (v154)
            {
              v154 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v154);
              v150 = (char *)__p[0];
              v148 = (char *)__p[1];
            }
            else
            {
              v155 = 0;
            }
            v156 = (int *)(v154 + 4 * v151);
            *v156 = *v149;
            v157 = v156 + 1;
            while (v148 != v150)
            {
              v158 = *((_DWORD *)v148 - 1);
              v148 -= 4;
              *--v156 = v158;
            }
            __p[0] = v156;
            __p[1] = v157;
            *(_QWORD *)&v324 = v154 + 4 * v155;
            if (v150)
              operator delete(v150);
            v148 = (char *)v157;
          }
          else
          {
            *(_DWORD *)v148 = *v149;
            v148 += 4;
          }
          __p[1] = v148;
          v149 += 2;
        }
        while (v149 != v139);
        v139 = v136;
      }
      if (v139)
      {
        operator delete(v139);
        v148 = (char *)__p[1];
      }
      v159 = (char *)__p[0];
      if (v148 != __p[0])
      {
        v160 = 0;
        v305 = *(unsigned int *)(*(_QWORD *)(a1 + 64) + 104);
        v161 = 1;
        while (1)
        {
          v162 = *(_DWORD *)&v159[4 * v160];
          v163 = v160 + 1;
          v164 = (v148 - v159) >> 2;
          if (*(int *)(**((_QWORD **)&v324 + 1)
                      + *(unsigned int *)(**((_QWORD **)&v324 + 1) + 16) * (unint64_t)v162
                      + 32) >= 31
            && v164 > v163)
          {
            break;
          }
LABEL_283:
          if (v160 <= 2)
          {
            ++v161;
            ++v160;
            if (v164 > v163)
              continue;
          }
          goto LABEL_285;
        }
        v166 = v161;
        while (2)
        {
          v167 = *(_DWORD *)&v159[4 * v166];
          if (*((_QWORD *)&v324 + 1))
          {
            v168 = *(_DWORD *)(**((_QWORD **)&v324 + 1) + 16);
            v169 = **((_QWORD **)&v324 + 1) + 24 + v168 * (unint64_t)v167;
            v170 = *(_DWORD *)(v169 + 8);
            if (v170)
            {
              v171 = **((_QWORD **)&v324 + 1) + 24 + v168 * (unint64_t)v162;
              if ((float)((float)*(int *)(v171 + 8) * 0.1) >= (float)v170)
              {
                v172 = sqrtf(*(float *)(v171 + 12) * *(float *)(v169 + 12));
                v173 = v171 + 16;
LABEL_256:
                __C = 0.0;
                vDSP_dotpr((const float *)v173, 1, (const float *)(v169 + 16), 1, &__C, (int)v305);
                if ((float)((float)((float)(__C + 1.0) * -0.5) + 1.0) < (float)(v172 * 0.21))
                {
                  v174 = **((_QWORD **)&v324 + 1);
                  v175 = **((_QWORD **)&v324 + 1) + 24;
                  v176 = *(_DWORD *)(**((_QWORD **)&v324 + 1) + 16);
                  v177 = v175 + v176 * (unint64_t)v162;
                  v178 = (double)*(int *)(v177 + 8);
                  v179 = v175 + v176 * (unint64_t)v167;
                  v180 = (double)*(int *)(v179 + 8);
                  v181 = v178 + v180;
                  v182 = 1.0 / (v178 + v180);
                  if ((int)v305 >= 1)
                  {
                    v183 = v176 * (unint64_t)v162;
                    v184 = (float *)(v174 + 40 + v176 * (unint64_t)v167);
                    v185 = (float *)(v174 + 40 + v183);
                    v186 = v305;
                    do
                    {
                      v187 = *v184++;
                      v188 = v182 * (v178 * *v185 + v180 * v187);
                      *v185++ = v188;
                      --v186;
                    }
                    while (v186);
                  }
                  v189 = v182 * (v180 * *(float *)(v179 + 12) + *(float *)(v177 + 12) * v178);
                  *(float *)(v177 + 12) = v189;
                  *(_DWORD *)(v177 + 8) = (int)v181;
                  *(_DWORD *)(v175 + *(unsigned int *)(v174 + 16) * (unint64_t)v167 + 8) = 0;
                  v190 = *(_DWORD *)(v174 + 16);
                  v191 = *(_QWORD *)(v175 + v190 * (unint64_t)v167);
                  v192 = *(_QWORD *)(v175 + v190 * (unint64_t)v162);
                  if (v191 <= v192)
                    v193 = v192;
                  else
                    v193 = v191;
                  if (v191 >= v192)
                    v194 = v192;
                  else
                    v194 = v191;
                  v195 = (uint64_t)v320;
                  v197 = (char *)v320[1];
                  v196 = (char *)v320[2];
                  if (v197 >= v196)
                  {
                    v199 = (char *)*v320;
                    v200 = (v197 - (char *)*v320) >> 4;
                    v201 = v200 + 1;
                    if ((unint64_t)(v200 + 1) >> 60)
                      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
                    v202 = v196 - v199;
                    if (v202 >> 3 > v201)
                      v201 = v202 >> 3;
                    v228 = (unint64_t)v202 >= 0x7FFFFFFFFFFFFFF0;
                    v203 = 0xFFFFFFFFFFFFFFFLL;
                    if (!v228)
                      v203 = v201;
                    if (v203)
                    {
                      v203 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<vision::mod::DescriptorItemSideInfo>>(v203);
                      v199 = *(char **)v195;
                      v197 = *(char **)(v195 + 8);
                    }
                    else
                    {
                      v204 = 0;
                    }
                    v205 = (unint64_t *)(v203 + 16 * v200);
                    *v205 = v194;
                    v205[1] = v193;
                    v206 = v205;
                    if (v197 != v199)
                    {
                      do
                      {
                        *((_OWORD *)v206 - 1) = *((_OWORD *)v197 - 1);
                        v206 -= 2;
                        v197 -= 16;
                      }
                      while (v197 != v199);
                      v199 = *(char **)v195;
                    }
                    v198 = v205 + 2;
                    *(_QWORD *)v195 = v206;
                    *(_QWORD *)(v195 + 8) = v205 + 2;
                    *(_QWORD *)(v195 + 16) = v203 + 16 * v204;
                    if (v199)
                      operator delete(v199);
                  }
                  else
                  {
                    *(_QWORD *)v197 = v194;
                    *((_QWORD *)v197 + 1) = v193;
                    v198 = v197 + 16;
                  }
                  *(_QWORD *)(v195 + 8) = v198;
                }
              }
            }
          }
          else if (MEMORY[8] && (float)((float)MEMORY[8] * 0.1) >= (float)MEMORY[8])
          {
            v169 = 0;
            v172 = sqrtf(MEMORY[0xC] * MEMORY[0xC]);
            v173 = 16;
            goto LABEL_256;
          }
          ++v166;
          v159 = (char *)__p[0];
          v148 = (char *)__p[1];
          v164 = ((char *)__p[1] - (char *)__p[0]) >> 2;
          if (v164 <= v166)
            goto LABEL_283;
          continue;
        }
      }
    }
LABEL_285:
    v76 = v297;
    v79 = v302;
    if (v299)
    {
      v207 = (unint64_t *)&v299->__shared_owners_;
      do
        v208 = __ldaxr(v207);
      while (__stlxr(v208 - 1, v207));
      if (!v208)
      {
        ((void (*)(std::__shared_weak_count *))v299->__on_zero_shared)(v299);
        std::__shared_weak_count::__release_weak(v299);
      }
    }
    vision::mod::GreedyClustererWithTorso::private_t::clusters_t::~clusters_t((vision::mod::GreedyClustererWithTorso::private_t::clusters_t *)__p);
    __p[0] = &v329;
    std::vector<std::vector<CGPoint>>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
    std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(v339);
    vision::mod::dist_greedy_status_t::~dist_greedy_status_t((vision::mod::dist_greedy_status_t *)&v334);
  }
  v209 = a1;
  if (v76)
  {
    v210 = (unint64_t *)&v76->__shared_owners_;
    do
      v211 = __ldaxr(v210);
    while (__stlxr(v211 - 1, v210));
    if (!v211)
    {
      ((void (*)(std::__shared_weak_count *))v76->__on_zero_shared)(v76);
      std::__shared_weak_count::__release_weak(v76);
    }
  }
  v316 = v307;
  v317 = v308;
  if (v308)
  {
    v212 = (unint64_t *)&v308->__shared_owners_;
    do
      v213 = __ldxr(v212);
    while (__stxr(v213 + 1, v212));
    v329 = v307;
    v330[0] = &v308->__vftable;
    do
      v214 = __ldxr(v212);
    while (__stxr(v214 + 1, v212));
  }
  else
  {
    v329 = v307;
    v330[0] = 0;
  }
  vision::mod::GreedyClusterer::getConnectedComponents((uint64_t *)&v334, v79, *v307, v307[1]);
  if (v308)
  {
    v215 = (unint64_t *)&v308->__shared_owners_;
    do
      v216 = __ldaxr(v215);
    while (__stlxr(v216 - 1, v215));
    if (!v216)
    {
      ((void (*)(std::__shared_weak_count *))v308->__on_zero_shared)(v308);
      std::__shared_weak_count::__release_weak(v308);
    }
  }
  v309 = 0;
  v310 = 0;
  v311 = 0;
  v217 = v334;
  v300 = v335;
  if (v334 != v335)
  {
    v218 = (_QWORD *)(a1 + 96);
    do
    {
      __p[0] = 0;
      __p[1] = 0;
      *(_QWORD *)&v324 = 0;
      std::vector<unsigned long>::__init_with_size[abi:ne180100]<unsigned long *,unsigned long *>(__p, (const void *)*v217, v217[1], (v217[1] - *v217) >> 3);
      v219 = *(_QWORD *)(v209 + 64);
      if (*(_BYTE *)(v219 + 120))
      {
        *(_BYTE *)(v219 + 120) = 0;
        v291 = __cxa_allocate_exception(8uLL);
        *v291 = 5219;
        __cxa_throw(v291, MEMORY[0x1E0DE4F28], 0);
      }
      v338 = 0;
      v339 = 0;
      v340 = 0;
      v221 = (unint64_t *)__p[0];
      v220 = (unint64_t *)__p[1];
      if (__p[0] == __p[1])
      {
        v222 = 0;
      }
      else
      {
        v222 = 0;
        v223 = (unint64_t *)__p[0];
        do
        {
          if (*v218)
          {
            v224 = *v223;
            v225 = (_QWORD *)(a1 + 96);
            v226 = (_QWORD *)*v218;
            do
            {
              v227 = v226[4];
              v228 = v227 >= v224;
              if (v227 >= v224)
                v229 = v226;
              else
                v229 = v226 + 1;
              if (v228)
                v225 = v226;
              v226 = (_QWORD *)*v229;
            }
            while (*v229);
            if (v225 != v218 && v224 >= v225[4])
              v222 += v225[7];
          }
          ++v223;
        }
        while (v223 != __p[1]);
      }
      std::vector<long long>::reserve((void **)&v338, v222);
      v303 = v217;
      for (j = v220; v221 != v220; ++v221)
      {
        v230 = (_QWORD *)*v218;
        if (*v218)
        {
          v231 = *v221;
          v232 = (_QWORD *)(a1 + 96);
          do
          {
            v233 = v230[4];
            v234 = v233 >= v231;
            if (v233 >= v231)
              v235 = v230;
            else
              v235 = v230 + 1;
            if (v234)
              v232 = v230;
            v230 = (_QWORD *)*v235;
          }
          while (*v235);
          if (v232 != v218 && v231 >= v232[4])
          {
            v236 = v232 + 5;
            v237 = (_QWORD *)v232[6];
            if (v237 != v232 + 5)
            {
              v239 = v339;
              v238 = v340;
              v240 = (char *)v338;
              do
              {
                v241 = v237[2];
                if ((unint64_t)v239 >= v238)
                {
                  v243 = (v239 - v240) >> 3;
                  v244 = v243 + 1;
                  if ((unint64_t)(v243 + 1) >> 61)
                  {
                    v340 = v238;
                    v338 = (char **)v240;
                    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
                  }
                  if ((uint64_t)(v238 - (_QWORD)v240) >> 2 > v244)
                    v244 = (uint64_t)(v238 - (_QWORD)v240) >> 2;
                  if (v238 - (unint64_t)v240 >= 0x7FFFFFFFFFFFFFF8)
                    v245 = 0x1FFFFFFFFFFFFFFFLL;
                  else
                    v245 = v244;
                  if (v245)
                    v245 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v245);
                  else
                    v246 = 0;
                  v247 = (char *)(v245 + 8 * v243);
                  *(_QWORD *)v247 = v241;
                  v242 = v247 + 8;
                  while (v239 != v240)
                  {
                    v248 = *((_QWORD *)v239 - 1);
                    v239 -= 8;
                    *((_QWORD *)v247 - 1) = v248;
                    v247 -= 8;
                  }
                  v238 = v245 + 8 * v246;
                  v339 = v242;
                  if (v240)
                    operator delete(v240);
                  v240 = v247;
                }
                else
                {
                  *(_QWORD *)v239 = v241;
                  v242 = v239 + 8;
                }
                v339 = v242;
                v237 = (_QWORD *)v237[1];
                v239 = v242;
              }
              while (v237 != v236);
              v340 = v238;
              v338 = (char **)v240;
              v220 = j;
            }
          }
        }
      }
      v249 = v310;
      if ((unint64_t)v310 >= v311)
      {
        v252 = (std::__shared_weak_count *)std::vector<std::vector<long long>>::__push_back_slow_path<std::vector<long long> const&>((uint64_t *)&v309, (uint64_t)&v338);
        v209 = a1;
        v251 = v303;
        v250 = v338;
      }
      else
      {
        v310->__vftable = 0;
        v249->__shared_owners_ = 0;
        v249->__shared_weak_owners_ = 0;
        v250 = v338;
        std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>(v249, v338, (uint64_t)v339, (v339 - (char *)v338) >> 3);
        v209 = a1;
        v251 = v303;
        v252 = v249 + 1;
      }
      v310 = v252;
      if (v250)
        operator delete(v250);
      if (__p[0])
        operator delete(__p[0]);
      v217 = v251 + 3;
    }
    while (v217 != v300);
  }
  __p[0] = &v334;
  std::vector<std::vector<CGPoint>>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
  if (v308)
  {
    v253 = (unint64_t *)&v308->__shared_owners_;
    do
      v254 = __ldaxr(v253);
    while (__stlxr(v254 - 1, v253));
    if (!v254)
    {
      ((void (*)(std::__shared_weak_count *))v308->__on_zero_shared)(v308);
      std::__shared_weak_count::__release_weak(v308);
    }
  }
  if (v297)
  {
    v255 = (unint64_t *)&v297->__shared_owners_;
    do
      v256 = __ldaxr(v255);
    while (__stlxr(v256 - 1, v255));
    if (!v256)
    {
      ((void (*)(std::__shared_weak_count *))v297->__on_zero_shared)(v297);
      std::__shared_weak_count::__release_weak(v297);
    }
  }
  v257 = (char *)v314[1];
  v258 = 126 - 2 * __clz((uint64_t)&v257[-*v314] >> 4);
  if (v257 == (char *)*v314)
    v259 = 0;
  else
    v259 = v258;
  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *,false>(*v314, v257, v259, 1);
  v335 = 0;
  v336 = 0;
  v334 = (uint64_t *)&v335;
  v260 = (uint64_t)v309;
  v261 = v310;
  while ((std::__shared_weak_count *)v260 != v261)
  {
    v263 = *(uint64_t **)v260;
    v262 = *(uint64_t **)(v260 + 8);
    if (v262 != *(uint64_t **)v260)
    {
      v264 = *v263;
      v265 = *(uint64_t **)v260;
      do
      {
        v267 = *v265++;
        v266 = v267;
        if (v267 < v264)
          v264 = v266;
      }
      while (v265 != v262);
      do
      {
        std::__tree<std::__value_type<long long,long long>,std::__map_value_compare<long long,std::__value_type<long long,long long>,std::less<long long>,true>,std::allocator<std::__value_type<long long,long long>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(&v334, *v263, v263)[5] = v264;
        ++v263;
      }
      while (v263 != v262);
    }
    v260 += 24;
  }
  v268 = *(_QWORD *)(a1 + 64);
  if (*(_BYTE *)(v268 + 120))
  {
    *(_BYTE *)(v268 + 120) = 0;
    v293 = __cxa_allocate_exception(8uLL);
    *v293 = 5219;
    __cxa_throw(v293, MEMORY[0x1E0DE4F28], 0);
  }
  v269 = v334;
  if (v334 != (uint64_t *)&v335)
  {
    do
    {
      v270 = v269[4];
      v271 = (_QWORD *)(a1 + 144);
      while (1)
      {
        v271 = (_QWORD *)*v271;
        if (!v271)
          break;
        v272 = v271[4];
        if (v270 >= v272)
        {
          if (v272 >= v270)
          {
            if (std::__tree<std::__value_type<long long,long long>,std::__map_value_compare<long long,std::__value_type<long long,long long>,std::less<long long>,true>,std::allocator<std::__value_type<long long,long long>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(v298, v269[4], v269 + 4)[5] == v269[5])goto LABEL_420;
            v270 = v269[4];
            break;
          }
          ++v271;
        }
      }
      v273 = v269[5];
      v275 = a2[1];
      v274 = (unint64_t)a2[2];
      if ((unint64_t)v275 >= v274)
      {
        v278 = *a2;
        v279 = ((char *)v275 - (char *)*a2) >> 4;
        v280 = v279 + 1;
        if ((unint64_t)(v279 + 1) >> 60)
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        v281 = v274 - (_QWORD)v278;
        if (v281 >> 3 > v280)
          v280 = v281 >> 3;
        if ((unint64_t)v281 >= 0x7FFFFFFFFFFFFFF0)
          v282 = 0xFFFFFFFFFFFFFFFLL;
        else
          v282 = v280;
        if (v282)
        {
          v282 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<vision::mod::DescriptorItemSideInfo>>(v282);
          v278 = *a2;
          v275 = a2[1];
        }
        else
        {
          v283 = 0;
        }
        v284 = (uint64_t *)(v282 + 16 * v279);
        *v284 = v270;
        v284[1] = v273;
        v285 = v284;
        if (v275 == v278)
        {
          v277 = a2;
        }
        else
        {
          v277 = a2;
          do
          {
            *((_OWORD *)v285 - 1) = *((_OWORD *)v275 - 1);
            v285 -= 2;
            v275 -= 2;
          }
          while (v275 != v278);
          v278 = *a2;
        }
        v276 = v284 + 2;
        *v277 = v285;
        v277[1] = v284 + 2;
        v277[2] = (uint64_t *)(v282 + 16 * v283);
        if (v278)
          operator delete(v278);
      }
      else
      {
        *v275 = v270;
        v275[1] = v273;
        v276 = v275 + 2;
        v277 = a2;
      }
      v277[1] = v276;
LABEL_420:
      v286 = (uint64_t *)v269[1];
      if (v286)
      {
        do
        {
          v287 = v286;
          v286 = (uint64_t *)*v286;
        }
        while (v286);
      }
      else
      {
        do
        {
          v287 = (uint64_t *)v269[2];
          v110 = *v287 == (_QWORD)v269;
          v269 = v287;
        }
        while (!v110);
      }
      v269 = v287;
    }
    while (v287 != (uint64_t *)&v335);
  }
  *(_BYTE *)(a1 + 80) = 0;
  if (v298 != &v334)
    std::__tree<std::__value_type<long long,long long>,std::__map_value_compare<long long,std::__value_type<long long,long long>,std::less<long long>,true>,std::allocator<std::__value_type<long long,long long>>>::__assign_multi<std::__tree_const_iterator<std::__value_type<long long,long long>,std::__tree_node<std::__value_type<long long,long long>,void *> *,long>>((uint64_t)v298, v334, &v335);
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(v335);
  v334 = (uint64_t *)&v309;
  std::vector<std::vector<long long>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v334);
  v288 = v315;
  if (v315)
  {
    v289 = &v315->__shared_owners_;
    do
      v290 = __ldaxr((unint64_t *)v289);
    while (__stlxr(v290 - 1, (unint64_t *)v289));
    if (!v290)
    {
      ((void (*)(std::__shared_weak_count *))v288->__on_zero_shared)(v288);
      std::__shared_weak_count::__release_weak(v288);
    }
  }
}

void sub_1A15584EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,char a26,uint64_t a27,char a28,uint64_t a29,char a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,char *__p,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,char a48,uint64_t a49,char a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54)
{
  uint64_t v54;

  vision::mod::GreedyClustererWithTorso::private_t::clusters_t::~clusters_t((vision::mod::GreedyClustererWithTorso::private_t::clusters_t *)&__p);
  __p = &a45;
  std::vector<std::vector<CGPoint>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*(_QWORD **)(v54 - 152));
  vision::mod::dist_greedy_status_t::~dist_greedy_status_t((vision::mod::dist_greedy_status_t *)&a52);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a30);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a19);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a26);
  _Unwind_Resume(a1);
}

unint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *,false>(unint64_t result, char *a2, uint64_t a3, char a4)
{
  unint64_t *v7;
  unint64_t *v8;
  unint64_t *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t *v13;
  __int128 v14;
  unint64_t v15;
  unint64_t v16;
  BOOL v17;
  char v18;
  unint64_t v19;
  unint64_t v20;
  BOOL v21;
  unint64_t v22;
  unint64_t *v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t v26;
  BOOL v27;
  char v28;
  unint64_t v29;
  BOOL v30;
  char *v31;
  char *v32;
  unint64_t v33;
  BOOL v34;
  char v35;
  unint64_t v36;
  BOOL v37;
  char v38;
  char *v39;
  unint64_t v40;
  BOOL v41;
  char v42;
  unint64_t v43;
  BOOL v44;
  char v45;
  unint64_t v46;
  unint64_t *v47;
  unint64_t v48;
  unint64_t *v49;
  unint64_t v50;
  BOOL v51;
  char v52;
  unint64_t v53;
  BOOL v54;
  unint64_t *v55;
  unint64_t v56;
  BOOL v57;
  char v58;
  unint64_t v59;
  BOOL v60;
  BOOL v61;
  unint64_t v62;
  char v63;
  unint64_t v64;
  BOOL v65;
  char v66;
  unint64_t *v67;
  unint64_t *v68;
  char v69;
  unint64_t v70;
  BOOL v71;
  unint64_t v72;
  BOOL v73;
  char v74;
  unint64_t v75;
  BOOL v76;
  char v77;
  unint64_t *v78;
  char *v79;
  unint64_t v80;
  BOOL v81;
  char v82;
  unint64_t v83;
  BOOL v84;
  unint64_t v85;
  unint64_t v86;
  unint64_t v87;
  unint64_t *v88;
  unint64_t v89;
  BOOL v90;
  char v91;
  unint64_t v92;
  BOOL v93;
  unint64_t *v94;
  unint64_t v95;
  BOOL v96;
  char v97;
  unint64_t v98;
  BOOL v99;
  unint64_t v100;
  char v101;
  unint64_t v102;
  unint64_t v103;
  BOOL v104;
  BOOL v105;
  unint64_t v106;
  char *v107;
  BOOL v109;
  uint64_t v110;
  unint64_t *v111;
  char *v112;
  unint64_t v113;
  unint64_t v114;
  char v115;
  unint64_t v116;
  unint64_t v117;
  BOOL v118;
  unint64_t v119;
  uint64_t v120;
  char *v121;
  uint64_t v122;
  char v123;
  unint64_t v124;
  BOOL v125;
  unint64_t *v126;
  int64_t v127;
  int64_t v128;
  int64_t v129;
  uint64_t v130;
  unint64_t *v131;
  unint64_t v132;
  BOOL v133;
  char v134;
  unint64_t v135;
  unint64_t v136;
  BOOL v137;
  unint64_t *v138;
  unint64_t v139;
  unint64_t v140;
  char v141;
  unint64_t v142;
  unint64_t v143;
  BOOL v144;
  unint64_t v145;
  unint64_t *v146;
  uint64_t v147;
  unint64_t v148;
  BOOL v149;
  char v150;
  unint64_t v151;
  unint64_t v152;
  BOOL v153;
  char v154;
  unint64_t v155;
  BOOL v156;
  uint64_t v157;
  uint64_t v158;
  unint64_t v159;
  unint64_t v160;
  uint64_t v161;
  uint64_t v162;
  unint64_t *v163;
  uint64_t v164;
  unint64_t *v165;
  uint64_t v166;
  uint64_t v167;
  unint64_t v168;
  BOOL v169;
  char v170;
  unint64_t v171;
  unint64_t v172;
  BOOL v173;
  char v174;
  uint64_t v175;
  unint64_t v176;
  unint64_t *v177;
  unint64_t v178;
  unint64_t v179;
  char v180;
  unint64_t v181;
  BOOL v182;
  unint64_t v183;
  unint64_t v184;
  BOOL v185;
  unint64_t *v187;
  char *v188;
  unint64_t v189;
  unint64_t v190;
  char v191;
  unint64_t v192;
  unint64_t v193;
  BOOL v194;
  unint64_t v195;
  unint64_t *v196;
  char v197;
  unint64_t v198;
  BOOL v199;

  v7 = (unint64_t *)result;
LABEL_2:
  v8 = (unint64_t *)(a2 - 16);
  v9 = v7;
  while (2)
  {
    v7 = v9;
    v10 = a2 - (char *)v9;
    v11 = (a2 - (char *)v9) >> 4;
    switch(v11)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        v100 = *v9;
        v101 = -1;
        if (*v8 >= *v9)
          v101 = 1;
        if (*v8 == *v9)
        {
          v102 = *((_QWORD *)a2 - 1);
          v103 = v9[1];
          v104 = v102 >= v103;
          v105 = v102 == v103;
          v101 = -1;
          if (v104)
            v101 = 1;
          if (v105)
            v101 = 0;
        }
        if (v101 < 0)
        {
          *v9 = *v8;
          *((_QWORD *)a2 - 2) = v100;
          v106 = v9[1];
          v9[1] = *((_QWORD *)a2 - 1);
          *((_QWORD *)a2 - 1) = v106;
        }
        return result;
      case 3uLL:
        return (unint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(v9, v9 + 2, (uint64_t *)a2 - 2);
      case 4uLL:
        return (unint64_t)std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(v9, v9 + 2, (uint64_t *)v9 + 4, (uint64_t *)a2 - 2);
      case 5uLL:
        return (unint64_t)std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(v9, v9 + 2, (uint64_t *)v9 + 4, (uint64_t *)v9 + 6, (uint64_t *)a2 - 2);
      default:
        if (v10 <= 383)
        {
          v107 = (char *)(v9 + 2);
          v109 = v9 == (unint64_t *)a2 || v107 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v109)
            {
              v110 = 0;
              v111 = v9;
              do
              {
                v112 = v107;
                v113 = v111[2];
                v114 = *v111;
                if (v113 >= *v111)
                  v115 = 1;
                else
                  v115 = -1;
                if (v113 == *v111)
                {
                  v116 = v111[3];
                  v117 = v111[1];
                  v118 = v116 == v117;
                  v115 = v116 >= v117 ? 1 : -1;
                  if (v118)
                    v115 = 0;
                }
                if (v115 < 0)
                {
                  v119 = v111[3];
                  v120 = v110;
                  while (1)
                  {
                    v121 = (char *)v9 + v120;
                    v122 = *(unint64_t *)((char *)v9 + v120 + 8);
                    *((_QWORD *)v121 + 2) = v114;
                    *((_QWORD *)v121 + 3) = v122;
                    if (!v120)
                      break;
                    v114 = *((_QWORD *)v121 - 2);
                    if (v113 >= v114)
                      v123 = 1;
                    else
                      v123 = -1;
                    if (v113 == v114)
                    {
                      v124 = *(unint64_t *)((char *)v9 + v120 - 8);
                      v125 = v119 == v124;
                      v123 = v119 >= v124 ? 1 : -1;
                      if (v125)
                        v123 = 0;
                    }
                    v120 -= 16;
                    if ((v123 & 0x80) == 0)
                    {
                      v126 = (unint64_t *)((char *)v9 + v120 + 16);
                      goto LABEL_227;
                    }
                  }
                  v126 = v9;
LABEL_227:
                  *v126 = v113;
                  v126[1] = v119;
                }
                v107 = v112 + 16;
                v110 += 16;
                v111 = (unint64_t *)v112;
              }
              while (v112 + 16 != a2);
            }
          }
          else if (!v109)
          {
            v187 = v9 + 3;
            do
            {
              v188 = v107;
              v189 = v7[2];
              v190 = *v7;
              if (v189 >= *v7)
                v191 = 1;
              else
                v191 = -1;
              if (v189 == *v7)
              {
                v192 = v7[3];
                v193 = v7[1];
                v194 = v192 == v193;
                v191 = v192 >= v193 ? 1 : -1;
                if (v194)
                  v191 = 0;
              }
              if (v191 < 0)
              {
                v195 = v7[3];
                v196 = v187;
                do
                {
                  *(v196 - 1) = v190;
                  *v196 = *(v196 - 2);
                  v190 = *(v196 - 5);
                  if (v189 >= v190)
                    v197 = 1;
                  else
                    v197 = -1;
                  if (v189 == v190)
                  {
                    v198 = *(v196 - 4);
                    v199 = v195 == v198;
                    v197 = v195 >= v198 ? 1 : -1;
                    if (v199)
                      v197 = 0;
                  }
                  v196 -= 2;
                }
                while (v197 < 0);
                *(v196 - 1) = v189;
                *v196 = v195;
              }
              v107 = v188 + 16;
              v187 += 2;
              v7 = (unint64_t *)v188;
            }
            while (v188 + 16 != a2);
          }
          return result;
        }
        if (!a3)
        {
          if (v9 != (unint64_t *)a2)
          {
            v127 = (v11 - 2) >> 1;
            v128 = v127;
            do
            {
              v129 = v128;
              if (v127 >= v128)
              {
                v130 = (2 * v128) | 1;
                v131 = &v9[2 * v130];
                if (2 * v129 + 2 < (uint64_t)v11)
                {
                  v132 = v131[2];
                  v133 = *v131 == v132;
                  if (*v131 >= v132)
                    v134 = 1;
                  else
                    v134 = -1;
                  if (v133)
                  {
                    v135 = v9[2 * v130 + 1];
                    v136 = v131[3];
                    v137 = v135 == v136;
                    v134 = v135 >= v136 ? 1 : -1;
                    if (v137)
                      v134 = 0;
                  }
                  if (v134 < 0)
                  {
                    v131 += 2;
                    v130 = 2 * v129 + 2;
                  }
                }
                v138 = &v9[2 * v129];
                v139 = *v131;
                v140 = *v138;
                if (*v131 >= *v138)
                  v141 = 1;
                else
                  v141 = -1;
                if (*v131 == *v138)
                {
                  v142 = v131[1];
                  v143 = v9[2 * v129 + 1];
                  v144 = v142 == v143;
                  v141 = v142 >= v143 ? 1 : -1;
                  if (v144)
                    v141 = 0;
                }
                if ((v141 & 0x80) == 0)
                {
                  v145 = v138[1];
                  do
                  {
                    v146 = v138;
                    v138 = v131;
                    *v146 = v139;
                    v146[1] = v131[1];
                    if (v127 < v130)
                      break;
                    v147 = (2 * v130) | 1;
                    v131 = &v9[2 * v147];
                    v130 = 2 * v130 + 2;
                    if (v130 >= (uint64_t)v11)
                    {
                      v130 = v147;
                    }
                    else
                    {
                      v148 = v131[2];
                      v149 = *v131 == v148;
                      if (*v131 >= v148)
                        v150 = 1;
                      else
                        v150 = -1;
                      if (v149)
                      {
                        v151 = v9[2 * v147 + 1];
                        v152 = v131[3];
                        v153 = v151 == v152;
                        v150 = v151 >= v152 ? 1 : -1;
                        if (v153)
                          v150 = 0;
                      }
                      if (v150 < 0)
                        v131 += 2;
                      else
                        v130 = v147;
                    }
                    v139 = *v131;
                    if (*v131 >= v140)
                      v154 = 1;
                    else
                      v154 = -1;
                    if (*v131 == v140)
                    {
                      v155 = v131[1];
                      v156 = v155 == v145;
                      v154 = v155 >= v145 ? 1 : -1;
                      if (v156)
                        v154 = 0;
                    }
                  }
                  while ((v154 & 0x80) == 0);
                  *v138 = v140;
                  v138[1] = v145;
                }
              }
              v128 = v129 - 1;
            }
            while (v129);
            v157 = (unint64_t)v10 >> 4;
            do
            {
              v158 = 0;
              v159 = *v9;
              v160 = v9[1];
              v161 = v157 - 2;
              if (v157 < 2)
                v161 = v157 - 1;
              v162 = v161 >> 1;
              v163 = v9;
              do
              {
                v164 = v158 + 1;
                v165 = &v163[2 * v158 + 2];
                result = 2 * v158;
                v166 = (2 * v158) | 1;
                v167 = 2 * v158 + 2;
                if (v167 < v157)
                {
                  result = (unint64_t)(v165 + 2);
                  v168 = v165[2];
                  v169 = *v165 == v168;
                  if (*v165 >= v168)
                    v170 = 1;
                  else
                    v170 = -1;
                  if (v169)
                  {
                    v171 = v163[2 * v164 + 1];
                    v172 = v165[3];
                    v173 = v171 == v172;
                    if (v171 >= v172)
                      v174 = 1;
                    else
                      v174 = -1;
                    if (v173)
                      v170 = 0;
                    else
                      v170 = v174;
                  }
                  if (v170 < 0)
                  {
                    v165 += 2;
                    v166 = v167;
                  }
                }
                *v163 = *v165;
                v163[1] = v165[1];
                v163 = v165;
                v158 = v166;
              }
              while (v166 <= v162);
              if (v165 == (unint64_t *)(a2 - 16))
              {
                *v165 = v159;
                v165[1] = v160;
              }
              else
              {
                *v165 = *((_QWORD *)a2 - 2);
                v165[1] = *((_QWORD *)a2 - 1);
                *((_QWORD *)a2 - 2) = v159;
                *((_QWORD *)a2 - 1) = v160;
                v175 = (char *)v165 - (char *)v9 + 16;
                if (v175 >= 17)
                {
                  v176 = (unint64_t)((v175 >> 4) - 2) >> 1;
                  v177 = &v9[2 * v176];
                  v178 = *v177;
                  v179 = *v165;
                  if (*v177 >= *v165)
                    v180 = 1;
                  else
                    v180 = -1;
                  if (*v177 == *v165)
                  {
                    v181 = v177[1];
                    result = v165[1];
                    v182 = v181 == result;
                    v180 = v181 >= result ? 1 : -1;
                    if (v182)
                      v180 = 0;
                  }
                  if (v180 < 0)
                  {
                    v183 = v165[1];
                    do
                    {
                      result = (unint64_t)v165;
                      v165 = v177;
                      *(_QWORD *)result = v178;
                      *(_QWORD *)(result + 8) = v177[1];
                      if (!v176)
                        break;
                      v176 = (v176 - 1) >> 1;
                      v177 = &v9[2 * v176];
                      v178 = *v177;
                      if (*v177 >= v179)
                        result = 1;
                      else
                        result = 255;
                      if (*v177 == v179)
                      {
                        v184 = v177[1];
                        v185 = v184 == v183;
                        result = v184 >= v183 ? 1 : 255;
                        if (v185)
                          result = 0;
                      }
                    }
                    while ((result & 0x80) != 0);
                    *v165 = v179;
                    v165[1] = v183;
                  }
                }
              }
              a2 -= 16;
            }
            while (v157-- > 2);
          }
          return result;
        }
        v12 = v11 >> 1;
        v13 = &v9[2 * (v11 >> 1)];
        if ((unint64_t)v10 < 0x801)
        {
          result = (unint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(&v7[2 * (v11 >> 1)], v7, (uint64_t *)a2 - 2);
        }
        else
        {
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(v7, &v7[2 * (v11 >> 1)], (uint64_t *)a2 - 2);
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(v7 + 2, v13 - 2, (uint64_t *)a2 - 4);
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(v7 + 4, &v7[2 * v12 + 2], (uint64_t *)a2 - 6);
          result = (unint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(v13 - 2, v13, (uint64_t *)&v7[2 * v12 + 2]);
          v14 = *(_OWORD *)v7;
          *(_OWORD *)v7 = *(_OWORD *)v13;
          *(_OWORD *)v13 = v14;
        }
        --a3;
        v15 = *v7;
        if ((a4 & 1) == 0)
        {
          v16 = *(v7 - 2);
          v17 = v16 == v15;
          if (v16 >= v15)
            v18 = 1;
          else
            v18 = -1;
          if (v17)
          {
            v19 = *(v7 - 1);
            v20 = v7[1];
            v21 = v19 == v20;
            v18 = v19 >= v20 ? 1 : -1;
            if (v21)
              v18 = 0;
          }
          if ((v18 & 0x80) == 0)
          {
            v62 = v7[1];
            if (v15 >= *v8)
              v63 = 1;
            else
              v63 = -1;
            if (v15 == *v8)
            {
              v64 = *((_QWORD *)a2 - 1);
              v65 = v62 == v64;
              if (v62 >= v64)
                v66 = 1;
              else
                v66 = -1;
              if (v65)
                v63 = 0;
              else
                v63 = v66;
            }
            v67 = v7;
            if (v63 < 0)
            {
              do
              {
                v9 = v67 + 2;
                v72 = v67[2];
                v73 = v15 == v72;
                if (v15 >= v72)
                  v74 = 1;
                else
                  v74 = -1;
                if (v73)
                {
                  v75 = v67[3];
                  v76 = v62 == v75;
                  if (v62 >= v75)
                    v77 = 1;
                  else
                    v77 = -1;
                  if (v76)
                    v74 = 0;
                  else
                    v74 = v77;
                }
                v67 = v9;
              }
              while ((v74 & 0x80) == 0);
            }
            else
            {
              v68 = v7 + 2;
              do
              {
                v9 = v68;
                if (v68 >= (unint64_t *)a2)
                  break;
                if (v15 >= *v68)
                  v69 = 1;
                else
                  v69 = -1;
                if (v15 == *v68)
                {
                  v70 = v68[1];
                  v71 = v62 == v70;
                  v69 = v62 >= v70 ? 1 : -1;
                  if (v71)
                    v69 = 0;
                }
                v68 += 2;
              }
              while ((v69 & 0x80) == 0);
            }
            v78 = (unint64_t *)a2;
            if (v9 < (unint64_t *)a2)
            {
              v79 = a2;
              v78 = (unint64_t *)a2;
              do
              {
                v80 = *(v78 - 2);
                v78 -= 2;
                v81 = v15 == v80;
                if (v15 >= v80)
                  v82 = 1;
                else
                  v82 = -1;
                if (v81)
                {
                  v83 = *((_QWORD *)v79 - 1);
                  v84 = v62 == v83;
                  v82 = v62 >= v83 ? 1 : -1;
                  if (v84)
                    v82 = 0;
                }
                v79 = (char *)v78;
              }
              while (v82 < 0);
            }
            if (v9 < v78)
            {
              v85 = *v9;
              v86 = *v78;
              do
              {
                *v9 = v86;
                *v78 = v85;
                v87 = v9[1];
                v9[1] = v78[1];
                v78[1] = v87;
                v88 = v9;
                do
                {
                  v89 = v9[2];
                  v9 += 2;
                  v85 = v89;
                  v90 = v15 == v89;
                  if (v15 >= v89)
                    v91 = 1;
                  else
                    v91 = -1;
                  if (v90)
                  {
                    v92 = v88[3];
                    v93 = v62 == v92;
                    v91 = v62 >= v92 ? 1 : -1;
                    if (v93)
                      v91 = 0;
                  }
                  v88 = v9;
                }
                while ((v91 & 0x80) == 0);
                v94 = v78;
                do
                {
                  v95 = *(v78 - 2);
                  v78 -= 2;
                  v86 = v95;
                  v96 = v15 == v95;
                  if (v15 >= v95)
                    v97 = 1;
                  else
                    v97 = -1;
                  if (v96)
                  {
                    v98 = *(v94 - 1);
                    v99 = v62 == v98;
                    v97 = v62 >= v98 ? 1 : -1;
                    if (v99)
                      v97 = 0;
                  }
                  v94 = v78;
                }
                while (v97 < 0);
              }
              while (v9 < v78);
            }
            if (v9 - 2 != v7)
            {
              *v7 = *(v9 - 2);
              v7[1] = *(v9 - 1);
            }
            a4 = 0;
            *(v9 - 2) = v15;
            *(v9 - 1) = v62;
            continue;
          }
        }
        v22 = v7[1];
        v23 = v7;
        v24 = v7;
        do
        {
          v26 = v24[2];
          v24 += 2;
          v25 = v26;
          v27 = v26 == v15;
          if (v26 >= v15)
            v28 = 1;
          else
            v28 = -1;
          if (v27)
          {
            v29 = v23[3];
            v30 = v29 == v22;
            v28 = v29 >= v22 ? 1 : -1;
            if (v30)
              v28 = 0;
          }
          v23 = v24;
        }
        while (v28 < 0);
        v31 = a2;
        if (v24 - 2 == v7)
        {
          v39 = a2;
          while (v24 < (unint64_t *)v39)
          {
            v32 = v39 - 16;
            v40 = *((_QWORD *)v39 - 2);
            v41 = v40 == v15;
            if (v40 >= v15)
              v42 = 1;
            else
              v42 = -1;
            if (v41)
            {
              v43 = *((_QWORD *)v39 - 1);
              v44 = v43 == v22;
              if (v43 >= v22)
                v45 = 1;
              else
                v45 = -1;
              if (v44)
                v42 = 0;
              else
                v42 = v45;
            }
            v39 = v32;
            if (v42 < 0)
              goto LABEL_63;
          }
          v32 = v39;
        }
        else
        {
          do
          {
            v32 = v31 - 16;
            v33 = *((_QWORD *)v31 - 2);
            v34 = v33 == v15;
            if (v33 >= v15)
              v35 = 1;
            else
              v35 = -1;
            if (v34)
            {
              v36 = *((_QWORD *)v31 - 1);
              v37 = v36 == v22;
              if (v36 >= v22)
                v38 = 1;
              else
                v38 = -1;
              if (v37)
                v35 = 0;
              else
                v35 = v38;
            }
            v31 = v32;
          }
          while ((v35 & 0x80) == 0);
        }
LABEL_63:
        if (v24 >= (unint64_t *)v32)
        {
          v9 = v24;
        }
        else
        {
          v46 = *(_QWORD *)v32;
          v9 = v24;
          v47 = (unint64_t *)v32;
          do
          {
            *v9 = v46;
            *v47 = v25;
            v48 = v9[1];
            v9[1] = v47[1];
            v47[1] = v48;
            v49 = v9;
            do
            {
              v50 = v9[2];
              v9 += 2;
              v25 = v50;
              v51 = v50 == v15;
              if (v50 >= v15)
                v52 = 1;
              else
                v52 = -1;
              if (v51)
              {
                v53 = v49[3];
                v54 = v53 == v22;
                v52 = v53 >= v22 ? 1 : -1;
                if (v54)
                  v52 = 0;
              }
              v49 = v9;
            }
            while (v52 < 0);
            v55 = v47;
            do
            {
              v56 = *(v47 - 2);
              v47 -= 2;
              v46 = v56;
              v57 = v56 == v15;
              if (v56 >= v15)
                v58 = 1;
              else
                v58 = -1;
              if (v57)
              {
                v59 = *(v55 - 1);
                v60 = v59 == v22;
                v58 = v59 >= v22 ? 1 : -1;
                if (v60)
                  v58 = 0;
              }
              v55 = v47;
            }
            while ((v58 & 0x80) == 0);
          }
          while (v9 < v47);
        }
        if (v9 - 2 != v7)
        {
          *v7 = *(v9 - 2);
          v7[1] = *(v9 - 1);
        }
        *(v9 - 2) = v15;
        *(v9 - 1) = v22;
        if (v24 < (unint64_t *)v32)
        {
LABEL_97:
          result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *,false>(v7, v9 - 2, a3, a4 & 1);
          a4 = 0;
          continue;
        }
        v61 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(v7, (char *)v9 - 16);
        result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(v9, a2);
        if (!(_DWORD)result)
        {
          if (v61)
            continue;
          goto LABEL_97;
        }
        a2 = (char *)(v9 - 2);
        if (!v61)
          goto LABEL_2;
        return result;
    }
  }
}

unint64_t *std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(unint64_t *result, unint64_t *a2, uint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;
  char v5;
  unint64_t v6;
  unint64_t v7;
  BOOL v8;
  BOOL v9;
  char v10;
  unint64_t v11;
  char v12;
  unint64_t v13;
  unint64_t v14;
  BOOL v15;
  char v16;
  unint64_t *v17;
  uint64_t v18;
  unint64_t v19;
  char v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  BOOL v24;
  unint64_t v25;
  unint64_t v26;
  char v27;
  unint64_t v28;
  BOOL v29;
  char v30;
  unint64_t *v31;
  unint64_t v32;

  v3 = *a2;
  v4 = *result;
  if (*a2 >= *result)
    v5 = 1;
  else
    v5 = -1;
  if (*a2 == *result)
  {
    v6 = a2[1];
    v7 = result[1];
    v8 = v6 >= v7;
    v9 = v6 == v7;
    v10 = -1;
    if (v8)
      v10 = 1;
    if (v9)
      v5 = 0;
    else
      v5 = v10;
  }
  v11 = *a3;
  v12 = -1;
  if (*a3 >= v3)
    v12 = 1;
  if (v5 < 0)
  {
    if (v11 == v3)
    {
      v22 = a3[1];
      v23 = a2[1];
      v8 = v22 >= v23;
      v24 = v22 == v23;
      v12 = -1;
      if (v8)
        v12 = 1;
      if (v24)
        v12 = 0;
    }
    if (v12 < 0)
    {
      *result++ = v11;
      *a3 = v4;
      v31 = (unint64_t *)(a3 + 1);
    }
    else
    {
      *result = v3;
      *a2 = v4;
      v25 = result[1];
      result[1] = a2[1];
      a2[1] = v25;
      v26 = *a2;
      v27 = -1;
      if (*a3 >= *a2)
        v27 = 1;
      if (*a3 == *a2)
      {
        v28 = a3[1];
        v8 = v28 >= v25;
        v29 = v28 == v25;
        v30 = -1;
        if (v8)
          v30 = 1;
        if (v29)
          v27 = 0;
        else
          v27 = v30;
      }
      if ((v27 & 0x80) == 0)
        return result;
      *a2 = *a3;
      *a3 = v26;
      v31 = (unint64_t *)(a3 + 1);
      result = a2 + 1;
    }
    v17 = v31;
    goto LABEL_51;
  }
  if (v11 == v3)
  {
    v13 = a3[1];
    v14 = a2[1];
    v8 = v13 >= v14;
    v15 = v13 == v14;
    v16 = -1;
    if (v8)
      v16 = 1;
    if (v15)
      v12 = 0;
    else
      v12 = v16;
  }
  if (v12 < 0)
  {
    *a2 = v11;
    *a3 = v3;
    v17 = a2 + 1;
    v18 = a2[1];
    a2[1] = a3[1];
    a3[1] = v18;
    v19 = *result;
    v20 = -1;
    if (*a2 >= *result)
      v20 = 1;
    if (*a2 == *result)
    {
      v21 = result[1];
      v20 = -1;
      if (*v17 >= v21)
        v20 = 1;
      if (*v17 == v21)
        v20 = 0;
    }
    if (v20 < 0)
    {
      *result++ = *a2;
      *a2 = v19;
LABEL_51:
      v32 = *result;
      *result = *v17;
      *v17 = v32;
    }
  }
  return result;
}

unint64_t *std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(unint64_t *a1, unint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  unint64_t *result;
  uint64_t v9;
  char v10;
  unint64_t v11;
  unint64_t v12;
  BOOL v13;
  BOOL v14;
  uint64_t v15;
  unint64_t v16;
  char v17;
  unint64_t v18;
  unint64_t v19;
  BOOL v20;
  uint64_t v21;
  unint64_t v22;
  char v23;
  unint64_t v24;
  unint64_t v25;
  BOOL v26;
  unint64_t v27;

  result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(a1, a2, a3);
  v9 = *a3;
  v10 = -1;
  if (*a4 >= (unint64_t)*a3)
    v10 = 1;
  if (*a4 == *a3)
  {
    v11 = a4[1];
    v12 = a3[1];
    v13 = v11 >= v12;
    v14 = v11 == v12;
    v10 = -1;
    if (v13)
      v10 = 1;
    if (v14)
      v10 = 0;
  }
  if (v10 < 0)
  {
    *a3 = *a4;
    *a4 = v9;
    v15 = a3[1];
    a3[1] = a4[1];
    a4[1] = v15;
    v16 = *a2;
    v17 = -1;
    if (*a3 >= *a2)
      v17 = 1;
    if (*a3 == *a2)
    {
      v18 = a3[1];
      v19 = a2[1];
      v13 = v18 >= v19;
      v20 = v18 == v19;
      v17 = -1;
      if (v13)
        v17 = 1;
      if (v20)
        v17 = 0;
    }
    if (v17 < 0)
    {
      *a2 = *a3;
      *a3 = v16;
      v21 = a2[1];
      a2[1] = a3[1];
      a3[1] = v21;
      v22 = *a1;
      v23 = -1;
      if (*a2 >= *a1)
        v23 = 1;
      if (*a2 == *a1)
      {
        v24 = a2[1];
        v25 = a1[1];
        v13 = v24 >= v25;
        v26 = v24 == v25;
        v23 = -1;
        if (v13)
          v23 = 1;
        if (v26)
          v23 = 0;
      }
      if (v23 < 0)
      {
        *a1 = *a2;
        *a2 = v22;
        v27 = a1[1];
        a1[1] = a2[1];
        a2[1] = v27;
      }
    }
  }
  return result;
}

unint64_t *std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(unint64_t *a1, unint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  unint64_t *result;
  uint64_t v11;
  char v12;
  unint64_t v13;
  unint64_t v14;
  BOOL v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  unint64_t v20;
  unint64_t v21;
  BOOL v22;
  uint64_t v23;
  unint64_t v24;
  char v25;
  unint64_t v26;
  unint64_t v27;
  BOOL v28;
  uint64_t v29;
  unint64_t v30;
  char v31;
  unint64_t v32;
  unint64_t v33;
  BOOL v34;
  unint64_t v35;

  result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(a1, a2, a3, a4);
  v11 = *a4;
  v12 = -1;
  if (*a5 >= (unint64_t)*a4)
    v12 = 1;
  if (*a5 == *a4)
  {
    v13 = a5[1];
    v14 = a4[1];
    v15 = v13 >= v14;
    v16 = v13 == v14;
    v12 = -1;
    if (v15)
      v12 = 1;
    if (v16)
      v12 = 0;
  }
  if (v12 < 0)
  {
    *a4 = *a5;
    *a5 = v11;
    v17 = a4[1];
    a4[1] = a5[1];
    a5[1] = v17;
    v18 = *a3;
    v19 = -1;
    if (*a4 >= (unint64_t)*a3)
      v19 = 1;
    if (*a4 == *a3)
    {
      v20 = a4[1];
      v21 = a3[1];
      v15 = v20 >= v21;
      v22 = v20 == v21;
      v19 = -1;
      if (v15)
        v19 = 1;
      if (v22)
        v19 = 0;
    }
    if (v19 < 0)
    {
      *a3 = *a4;
      *a4 = v18;
      v23 = a3[1];
      a3[1] = a4[1];
      a4[1] = v23;
      v24 = *a2;
      v25 = -1;
      if (*a3 >= *a2)
        v25 = 1;
      if (*a3 == *a2)
      {
        v26 = a3[1];
        v27 = a2[1];
        v15 = v26 >= v27;
        v28 = v26 == v27;
        v25 = -1;
        if (v15)
          v25 = 1;
        if (v28)
          v25 = 0;
      }
      if (v25 < 0)
      {
        *a2 = *a3;
        *a3 = v24;
        v29 = a2[1];
        a2[1] = a3[1];
        a3[1] = v29;
        v30 = *a1;
        v31 = -1;
        if (*a2 >= *a1)
          v31 = 1;
        if (*a2 == *a1)
        {
          v32 = a2[1];
          v33 = a1[1];
          v15 = v32 >= v33;
          v34 = v32 == v33;
          v31 = -1;
          if (v15)
            v31 = 1;
          if (v34)
            v31 = 0;
        }
        if (v31 < 0)
        {
          *a1 = *a2;
          *a2 = v30;
          v35 = a1[1];
          a1[1] = a2[1];
          a2[1] = v35;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(unint64_t *a1, char *a2)
{
  uint64_t v4;
  _BOOL8 result;
  unint64_t v6;
  unint64_t v7;
  char v8;
  unint64_t v9;
  unint64_t v10;
  BOOL v11;
  BOOL v12;
  unint64_t v13;
  char *v14;
  char *v15;
  uint64_t v16;
  int v17;
  unint64_t v18;
  unint64_t v19;
  char v20;
  unint64_t v21;
  unint64_t v22;
  BOOL v23;
  unint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  char v28;
  unint64_t v29;
  BOOL v30;
  unint64_t *v31;

  v4 = (a2 - (char *)a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = *((_QWORD *)a2 - 2);
      v7 = *a1;
      v8 = -1;
      if (v6 >= *a1)
        v8 = 1;
      if (v6 == *a1)
      {
        v9 = *((_QWORD *)a2 - 1);
        v10 = a1[1];
        v11 = v9 >= v10;
        v12 = v9 == v10;
        v8 = -1;
        if (v11)
          v8 = 1;
        if (v12)
          v8 = 0;
      }
      if (v8 < 0)
      {
        *a1 = v6;
        *((_QWORD *)a2 - 2) = v7;
        v13 = a1[1];
        a1[1] = *((_QWORD *)a2 - 1);
        *((_QWORD *)a2 - 1) = v13;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(a1, a1 + 2, (uint64_t *)a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(a1, a1 + 2, (uint64_t *)a1 + 4, (uint64_t *)a2 - 2);
      return 1;
    case 5:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(a1, a1 + 2, (uint64_t *)a1 + 4, (uint64_t *)a1 + 6, (uint64_t *)a2 - 2);
      return 1;
    default:
      v14 = (char *)(a1 + 4);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long,unsigned long> *>(a1, a1 + 2, (uint64_t *)a1 + 4);
      v15 = (char *)(a1 + 6);
      if (a1 + 6 == (unint64_t *)a2)
        return 1;
      v16 = 0;
      v17 = 0;
      break;
  }
  while (1)
  {
    v18 = *(_QWORD *)v15;
    v19 = *(_QWORD *)v14;
    if (*(_QWORD *)v15 >= *(_QWORD *)v14)
      v20 = 1;
    else
      v20 = -1;
    if (*(_QWORD *)v15 == *(_QWORD *)v14)
    {
      v21 = *((_QWORD *)v15 + 1);
      v22 = *((_QWORD *)v14 + 1);
      v23 = v21 == v22;
      v20 = v21 >= v22 ? 1 : -1;
      if (v23)
        v20 = 0;
    }
    if (v20 < 0)
    {
      v24 = *((_QWORD *)v15 + 1);
      v25 = v16;
      while (1)
      {
        v26 = (unint64_t *)((char *)a1 + v25);
        v27 = *(unint64_t *)((char *)a1 + v25 + 40);
        v26[6] = v19;
        v26[7] = v27;
        if (v25 == -32)
          break;
        v19 = v26[2];
        if (v18 >= v19)
          v28 = 1;
        else
          v28 = -1;
        if (v18 == v19)
        {
          v29 = *(unint64_t *)((char *)a1 + v25 + 24);
          v30 = v24 == v29;
          v28 = v24 >= v29 ? 1 : -1;
          if (v30)
            v28 = 0;
        }
        v25 -= 16;
        if ((v28 & 0x80) == 0)
        {
          v31 = (unint64_t *)((char *)a1 + v25 + 48);
          goto LABEL_38;
        }
      }
      v31 = a1;
LABEL_38:
      *v31 = v18;
      v31[1] = v24;
      if (++v17 == 8)
        return v15 + 16 == a2;
    }
    v14 = v15;
    v16 += 16;
    v15 += 16;
    if (v15 == a2)
      return 1;
  }
}

void vision::mod::GreedyClusterer::getConnectedComponents(uint64_t *a1, uint64_t a2, uint64_t **a3, uint64_t **a4)
{
  uint64_t **v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t **v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t **v13;
  uint64_t *v14;
  uint64_t *v15;
  _QWORD *v16;
  unint64_t *v17;
  unint64_t *v18;
  unint64_t v19;
  int v20;
  uint64_t v21;
  _QWORD **v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t *v33;
  uint64_t *v34;
  uint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  __int128 v38;
  int64x2_t v39;
  uint64_t *v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  _QWORD *v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  unint64_t v48;
  uint64_t v49;
  unint64_t *v50;
  unint64_t *v51;
  unint64_t v52;
  uint64_t **v53;
  uint64_t **v54;
  uint64_t *i;
  uint64_t *v56;
  _QWORD *v57;
  _QWORD *v58;
  _QWORD *exception;
  uint64_t v60;
  unint64_t v61;
  _QWORD *v62;
  void *__p;
  uint64_t v64;
  uint64_t *v65;
  _QWORD *v66[2];
  uint64_t *v67;
  _QWORD *v68[2];
  uint64_t *v69;
  int64x2_t v70;
  uint64_t *v71;
  _QWORD *v72;

  v68[0] = 0;
  v68[1] = 0;
  v67 = (uint64_t *)v68;
  if (a3 != a4)
  {
    v7 = a3;
    do
    {
      v8 = *v7;
      v9 = v7[1];
      v69 = v8;
      v65 = v9;
      v10 = std::__tree<std::__value_type<unsigned long,std::list<unsigned long>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::list<unsigned long>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::list<unsigned long>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(&v67, (unint64_t)v8, &v69);
      v11 = (uint64_t *)operator new(0x18uLL);
      v11[2] = (uint64_t)v9;
      v12 = v10[5];
      v10 += 5;
      *v11 = (uint64_t)v12;
      v11[1] = (uint64_t)v10;
      v12[1] = (uint64_t)v11;
      *v10 = v11;
      v10[2] = (uint64_t *)((char *)v10[2] + 1);
      v13 = std::__tree<std::__value_type<unsigned long,std::list<unsigned long>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::list<unsigned long>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::list<unsigned long>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(&v67, (unint64_t)v9, &v65);
      v14 = (uint64_t *)operator new(0x18uLL);
      v14[2] = (uint64_t)v8;
      v15 = v13[5];
      v13 += 5;
      *v14 = (uint64_t)v15;
      v14[1] = (uint64_t)v13;
      v15[1] = (uint64_t)v14;
      *v13 = v14;
      v13[2] = (uint64_t *)((char *)v13[2] + 1);
      v7 += 2;
    }
    while (v7 != a4);
  }
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v66[0] = 0;
  v66[1] = 0;
  v64 = 0;
  v65 = (uint64_t *)v66;
  v62 = &v62;
  __p = &v62;
  v16 = operator new(0x18uLL);
  v16[1] = &v62;
  v16[2] = 0;
  *v16 = &v62;
  v62 = v16;
  __p = v16;
  v64 = 1;
  v60 = *(_QWORD *)(a2 + 56);
  if (*(_BYTE *)(v60 + 120))
  {
LABEL_61:
    *(_BYTE *)(v60 + 120) = 0;
    exception = __cxa_allocate_exception(8uLL);
    *exception = 5219;
    __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
  }
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
LABEL_6:
  v61 = 0;
  v21 = v64;
  if (v64)
  {
    v22 = (_QWORD **)__p;
    v23 = *((_QWORD *)__p + 1);
    v24 = *((_QWORD *)__p + 2);
    v61 = v24;
    v25 = *(_QWORD *)__p;
    *(_QWORD *)(v25 + 8) = v23;
    *v22[1] = v25;
    v64 = v21 - 1;
    operator delete(v22);
    goto LABEL_37;
  }
  v27 = (_QWORD *)a1[1];
  v26 = a1[2];
  if ((unint64_t)v27 >= v26)
  {
    v29 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v27 - *a1) >> 3);
    v30 = v29 + 1;
    if (v29 + 1 > 0xAAAAAAAAAAAAAAALL)
      std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
    v31 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v26 - *a1) >> 3);
    if (2 * v31 > v30)
      v30 = 2 * v31;
    if (v31 >= 0x555555555555555)
      v32 = 0xAAAAAAAAAAAAAAALL;
    else
      v32 = v30;
    v72 = a1 + 2;
    if (v32)
    {
      if (v32 > 0xAAAAAAAAAAAAAAALL)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v33 = (uint64_t *)operator new(24 * v32);
    }
    else
    {
      v33 = 0;
    }
    v34 = &v33[3 * v29];
    v69 = v33;
    v70.i64[0] = (uint64_t)v34;
    v70.i64[1] = (uint64_t)v34;
    v71 = &v33[3 * v32];
    v34[1] = 0;
    v34[2] = 0;
    *v34 = 0;
    std::vector<unsigned long>::__init_with_size[abi:ne180100]<unsigned long *,unsigned long *>(v34, v17, (uint64_t)v18, v18 - v17);
    v35 = v70.i64[0];
    v28 = v70.i64[1] + 24;
    v70.i64[1] += 24;
    v37 = (_QWORD *)*a1;
    v36 = (_QWORD *)a1[1];
    if (v36 == (_QWORD *)*a1)
    {
      v39 = vdupq_n_s64((unint64_t)v36);
    }
    else
    {
      do
      {
        *(_QWORD *)(v35 - 24) = 0;
        *(_QWORD *)(v35 - 16) = 0;
        v35 -= 24;
        *(_QWORD *)(v35 + 16) = 0;
        v38 = *(_OWORD *)(v36 - 3);
        v36 -= 3;
        *(_OWORD *)v35 = v38;
        *(_QWORD *)(v35 + 16) = v36[2];
        *v36 = 0;
        v36[1] = 0;
        v36[2] = 0;
      }
      while (v36 != v37);
      v39 = *(int64x2_t *)a1;
      v28 = v70.i64[1];
    }
    *a1 = v35;
    a1[1] = v28;
    v70 = v39;
    v40 = (uint64_t *)a1[2];
    a1[2] = (uint64_t)v71;
    v71 = v40;
    v69 = (uint64_t *)v39.i64[0];
    std::__split_buffer<std::vector<long long>>::~__split_buffer((uint64_t)&v69);
  }
  else
  {
    *v27 = 0;
    v27[1] = 0;
    v27[2] = 0;
    std::vector<unsigned long>::__init_with_size[abi:ne180100]<unsigned long *,unsigned long *>(v27, v17, (uint64_t)v18, v18 - v17);
    v28 = (uint64_t)(v27 + 3);
    a1[1] = (uint64_t)(v27 + 3);
  }
  a1[1] = v28;
  v41 = *(_QWORD *)(v60 + 48);
  v42 = (*(_QWORD *)(v60 + 56) - v41) >> 2;
  if (v42 > v20)
  {
    v43 = v20;
LABEL_27:
    v24 = *(int *)(v41 + 4 * v43);
    if (!v66[0])
      goto LABEL_36;
    v44 = v66[0];
    while (1)
    {
      v45 = v44[4];
      if (v45 <= v24)
      {
        if (v45 >= v24)
        {
          if (++v43 != v42)
            goto LABEL_27;
          break;
        }
        ++v44;
      }
      v44 = (_QWORD *)*v44;
      if (!v44)
      {
        v20 = v43;
LABEL_36:
        v61 = *(int *)(v41 + 4 * v43);
        ++v20;
        v18 = v17;
LABEL_37:
        *((_BYTE *)std::__tree<std::__value_type<unsigned long,BOOL>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,BOOL>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,BOOL>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(&v65, v24, (uint64_t **)&v61)+ 40) = 1;
        if ((unint64_t)v18 >= v19)
        {
          v46 = v18 - v17;
          v47 = v46 + 1;
          if ((unint64_t)(v46 + 1) >> 61)
            std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
          if ((uint64_t)(v19 - (_QWORD)v17) >> 2 > v47)
            v47 = (uint64_t)(v19 - (_QWORD)v17) >> 2;
          if (v19 - (unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8)
            v48 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v48 = v47;
          if (v48)
            v48 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned long>>(v48);
          else
            v49 = 0;
          v50 = (unint64_t *)(v48 + 8 * v46);
          *v50 = v24;
          v51 = v50 + 1;
          while (v18 != v17)
          {
            v52 = *--v18;
            *--v50 = v52;
          }
          v19 = v48 + 8 * v49;
          if (v17)
            operator delete(v17);
          v17 = v50;
          v18 = v51;
        }
        else
        {
          *v18++ = v24;
        }
        v53 = std::__tree<std::__value_type<unsigned long,std::list<unsigned long>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::list<unsigned long>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::list<unsigned long>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(&v67, v61, (uint64_t **)&v61);
        v54 = v53 + 5;
        for (i = v53[6]; i != (uint64_t *)v54; i = (uint64_t *)i[1])
        {
          v56 = (uint64_t *)i[2];
          v69 = v56;
          if (!*((_BYTE *)std::__tree<std::__value_type<unsigned long,BOOL>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,BOOL>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,BOOL>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(&v65, (unint64_t)v56, &v69)+ 40))
          {
            v57 = operator new(0x18uLL);
            v57[1] = &v62;
            v57[2] = v56;
            v58 = v62;
            *v57 = v62;
            v58[1] = v57;
            v62 = v57;
            ++v64;
          }
        }
        if (*(_BYTE *)(*(_QWORD *)(a2 + 56) + 120))
        {
          v60 = *(_QWORD *)(a2 + 56);
          goto LABEL_61;
        }
        goto LABEL_6;
      }
    }
  }
  if (v17)
    operator delete(v17);
  std::__list_imp<long long>::clear(&v62);
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(v66[0]);
  std::__tree<std::__value_type<unsigned long,std::list<long long>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::list<long long>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::list<long long>>>>::destroy(v68[0]);
}

void sub_1A1559B78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void **a16, _QWORD *a17, uint64_t a18, uint64_t a19, _QWORD *a20)
{
  std::__list_imp<long long>::clear(&a13);
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(a17);
  std::vector<std::vector<CGPoint>>::__destroy_vector::operator()[abi:ne180100](&a16);
  std::__tree<std::__value_type<unsigned long,std::list<long long>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::list<long long>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::list<long long>>>>::destroy(a20);
  _Unwind_Resume(a1);
}

uint64_t **std::__tree<std::__value_type<unsigned long,std::list<unsigned long>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::list<unsigned long>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::list<unsigned long>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(uint64_t **a1, unint64_t a2, uint64_t **a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  unint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = v5[4];
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = (uint64_t *)v7;
    v7 = (uint64_t **)operator new(0x40uLL);
    v7[4] = *a3;
    v7[5] = (uint64_t *)(v7 + 5);
    v7[6] = (uint64_t *)(v7 + 5);
    v7[7] = 0;
    *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *v6 = (uint64_t *)v7;
    v10 = (uint64_t *)**a1;
    v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

uint64_t **std::__tree<std::__value_type<unsigned long,BOOL>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,BOOL>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,BOOL>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(uint64_t **a1, unint64_t a2, uint64_t **a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  unint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = v5[4];
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = (uint64_t *)v7;
    v7 = (uint64_t **)operator new(0x30uLL);
    v7[4] = *a3;
    *((_BYTE *)v7 + 40) = 0;
    *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *v6 = (uint64_t *)v7;
    v10 = (uint64_t *)**a1;
    v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void vision::mod::GreedyClusterer::computeMergePairs(uint64_t a1, _QWORD *a2, _QWORD *a3, uint64_t *a4, int a5)
{
  uint64_t v5;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  float v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  BOOL v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  unint64_t v25;
  uint64_t v26;
  float v27;
  vDSP_Length v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t *v37;
  _QWORD *v38;
  uint64_t v39;
  uint64_t *v40;
  unint64_t *v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  BOOL v45;
  unint64_t v46;
  uint64_t v47;
  unint64_t *v48;
  unint64_t *v49;
  _QWORD *v50;
  _QWORD *v51;
  _QWORD *v52;
  _QWORD *v53;
  _QWORD *v54;
  int v56;
  _BYTE v57[260];
  float __C[3];

  v5 = *(_QWORD *)(a1 + 56);
  if (*(_QWORD *)(v5 + 56) != *(_QWORD *)(v5 + 48))
  {
    v9 = a1;
    vision::mod::dist_greedy_status_t::dist_greedy_status_t((uint64_t)v57, *(_DWORD *)(v5 + 104), *(_DWORD *)(a1 + 20));
    v12 = (_QWORD *)*a2;
    v10 = a2 + 1;
    v11 = v12;
    if (v12 != v10)
    {
      v13 = *(float *)(*(_QWORD *)(v9 + 24) + 12);
      v14 = a3 + 1;
      v54 = v10;
      v56 = a5;
      while (1)
      {
        v15 = (_QWORD *)*a3;
        if ((_QWORD *)*a3 != v14)
          break;
LABEL_48:
        v52 = (_QWORD *)v11[1];
        if (v52)
        {
          do
          {
            v53 = v52;
            v52 = (_QWORD *)*v52;
          }
          while (v52);
        }
        else
        {
          do
          {
            v53 = (_QWORD *)v11[2];
            v19 = *v53 == (_QWORD)v11;
            v11 = v53;
          }
          while (!v19);
        }
        v11 = v53;
        if (v53 == v54)
          goto LABEL_54;
      }
      v16 = v11[4];
      v17 = v16;
      while (1)
      {
        v18 = v15[4];
        v19 = v18 <= v16 && a5 == 0;
        if (!v19)
        {
          v20 = *(_QWORD *)(v9 + 56);
          v21 = *(uint64_t **)(v20 + 72);
          if (v21)
          {
            v22 = *v21;
            v23 = v22 + 24;
            v24 = *(_DWORD *)(v22 + 16);
            v25 = v22 + 24 + v18 * (unint64_t)v24;
            if (*(_DWORD *)(v25 + 8))
            {
              v26 = v23 + v17 * (unint64_t)v24;
              if (*(float *)(v25 + 12) >= *(float *)(v26 + 12))
                v27 = *(float *)(v26 + 12);
              else
                v27 = *(float *)(v25 + 12);
LABEL_17:
              v28 = *(int *)(v20 + 104);
              __C[0] = 0.0;
              vDSP_dotpr((const float *)(v26 + 16), 1, (const float *)(v25 + 16), 1, __C, v28);
              if ((float)((float)((float)(__C[0] + 1.0) * -0.5) + 1.0) < (float)(v13 * v27))
              {
                v29 = **(_QWORD **)(*(_QWORD *)(v9 + 56) + 72);
                v30 = v29 + 24;
                LODWORD(v29) = *(_DWORD *)(v29 + 16);
                v31 = *(_QWORD *)(v30 + v18 * (unint64_t)v29);
                v32 = *(_QWORD *)(v30 + v17 * (unint64_t)v29);
                if (v31 >= v32)
                  v33 = v32;
                else
                  v33 = v31;
                if (v31 <= v32)
                  v34 = v32;
                else
                  v34 = v31;
                v35 = *a4;
                v37 = *(unint64_t **)(*a4 + 8);
                v36 = *(_QWORD *)(*a4 + 16);
                if ((unint64_t)v37 >= v36)
                {
                  v39 = v9;
                  v40 = a4;
                  v41 = *(unint64_t **)v35;
                  v42 = ((uint64_t)v37 - *(_QWORD *)v35) >> 4;
                  v43 = v42 + 1;
                  if ((unint64_t)(v42 + 1) >> 60)
                    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
                  v44 = v36 - (_QWORD)v41;
                  if (v44 >> 3 > v43)
                    v43 = v44 >> 3;
                  v45 = (unint64_t)v44 >= 0x7FFFFFFFFFFFFFF0;
                  v46 = 0xFFFFFFFFFFFFFFFLL;
                  if (!v45)
                    v46 = v43;
                  if (v46)
                  {
                    v46 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<vision::mod::DescriptorItemSideInfo>>(v46);
                    v41 = *(unint64_t **)v35;
                    v37 = *(unint64_t **)(v35 + 8);
                  }
                  else
                  {
                    v47 = 0;
                  }
                  v48 = (unint64_t *)(v46 + 16 * v42);
                  *v48 = v33;
                  v48[1] = v34;
                  v49 = v48;
                  a4 = v40;
                  if (v37 == v41)
                  {
                    v9 = v39;
                    v17 = v16;
                  }
                  else
                  {
                    v17 = v16;
                    do
                    {
                      *((_OWORD *)v49 - 1) = *((_OWORD *)v37 - 1);
                      v49 -= 2;
                      v37 -= 2;
                    }
                    while (v37 != v41);
                    v41 = *(unint64_t **)v35;
                    v9 = v39;
                  }
                  v38 = v48 + 2;
                  *(_QWORD *)v35 = v49;
                  *(_QWORD *)(v35 + 8) = v48 + 2;
                  *(_QWORD *)(v35 + 16) = v46 + 16 * v47;
                  a5 = v56;
                  if (v41)
                    operator delete(v41);
                }
                else
                {
                  *v37 = v33;
                  v37[1] = v34;
                  v38 = v37 + 2;
                  v17 = v16;
                }
                *(_QWORD *)(v35 + 8) = v38;
              }
            }
          }
          else if (MEMORY[8])
          {
            v26 = 0;
            v25 = 0;
            v27 = MEMORY[0xC];
            goto LABEL_17;
          }
        }
        v50 = (_QWORD *)v15[1];
        if (v50)
        {
          do
          {
            v51 = v50;
            v50 = (_QWORD *)*v50;
          }
          while (v50);
        }
        else
        {
          do
          {
            v51 = (_QWORD *)v15[2];
            v19 = *v51 == (_QWORD)v15;
            v15 = v51;
          }
          while (!v19);
        }
        v15 = v51;
        if (v51 == v14)
          goto LABEL_48;
      }
    }
LABEL_54:
    vision::mod::dist_greedy_status_t::~dist_greedy_status_t((vision::mod::dist_greedy_status_t *)v57);
  }
}

void sub_1A155A0A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  vision::mod::dist_greedy_status_t::~dist_greedy_status_t((vision::mod::dist_greedy_status_t *)va);
  _Unwind_Resume(a1);
}

int *std::__introsort<std::_ClassicAlgPolicy,vision::mod::GreedyClusterer::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*,false>(int *result, int *a2, uint64_t a3, char a4)
{
  int *v7;
  int *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  int *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int *v16;
  int *v17;
  int *v18;
  int *v19;
  int v20;
  int *v21;
  int v22;
  int *v23;
  int v24;
  int v25;
  int v26;
  int v27;
  BOOL v28;
  uint64_t v29;
  uint64_t v30;
  int *v31;
  int v32;
  int *v33;
  int v34;
  int *v35;
  int *v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int *v44;
  BOOL v46;
  uint64_t v47;
  int *v48;
  int v49;
  int v50;
  int v51;
  int v52;
  uint64_t v53;
  char *v54;
  int v55;
  int *v56;
  int64_t v57;
  int64_t v58;
  int64_t v59;
  uint64_t v60;
  int *v61;
  int v62;
  int v63;
  int *v64;
  int v65;
  int v66;
  int *v67;
  uint64_t v68;
  uint64_t v69;
  int v70;
  int v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  int *v75;
  int *v76;
  uint64_t v77;
  uint64_t v78;
  int v79;
  int v80;
  uint64_t v81;
  unint64_t v82;
  int *v83;
  int v84;
  int v85;
  int *v86;
  int *v88;
  int v89;
  int v90;
  uint64_t v91;
  uint64_t v92;
  int *v93;
  int v94;
  int v95;

  v7 = result;
LABEL_2:
  v8 = v7;
  while (2)
  {
    v7 = v8;
    v9 = (char *)a2 - (char *)v8;
    v10 = ((char *)a2 - (char *)v8) >> 3;
    switch(v10)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        if (*(a2 - 1) > v8[1])
        {
          v42 = *v8;
          *v8 = *(a2 - 2);
          *(a2 - 2) = v42;
          v43 = v8[1];
          v8[1] = *(a2 - 1);
          *(a2 - 1) = v43;
        }
        return result;
      case 3uLL:
        return std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(v8, v8 + 2, a2 - 2);
      case 4uLL:
        return std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(v8, v8 + 2, v8 + 4, a2 - 2);
      case 5uLL:
        return std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(v8, v8 + 2, v8 + 4, v8 + 6, a2 - 2);
      default:
        if (v9 <= 191)
        {
          v44 = v8 + 2;
          v46 = v8 == a2 || v44 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v46)
            {
              v47 = 0;
              v48 = v8;
              do
              {
                v49 = v48[3];
                v50 = v48[1];
                v48 = v44;
                if (v49 > v50)
                {
                  v51 = *v44;
                  v52 = v48[1];
                  v53 = v47;
                  while (1)
                  {
                    v54 = (char *)v8 + v53;
                    v55 = *(int *)((char *)v8 + v53 + 4);
                    *((_DWORD *)v54 + 2) = *(int *)((char *)v8 + v53);
                    *((_DWORD *)v54 + 3) = v55;
                    if (!v53)
                      break;
                    v53 -= 8;
                    if (*((_DWORD *)v54 - 1) >= v52)
                    {
                      v56 = (int *)((char *)v8 + v53 + 8);
                      goto LABEL_75;
                    }
                  }
                  v56 = v8;
LABEL_75:
                  *v56 = v51;
                  v56[1] = v52;
                }
                v44 = v48 + 2;
                v47 += 8;
              }
              while (v48 + 2 != a2);
            }
          }
          else if (!v46)
          {
            v88 = v8 + 1;
            do
            {
              v89 = v7[3];
              v90 = v7[1];
              v7 = v44;
              if (v89 > v90)
              {
                v91 = *(_QWORD *)v44;
                v92 = HIDWORD(*(_QWORD *)v7);
                v93 = v88;
                do
                {
                  v94 = *v93;
                  v93[1] = *(v93 - 1);
                  v93[2] = v94;
                  v95 = *(v93 - 2);
                  v93 -= 2;
                }
                while (v95 < (int)v92);
                v93[1] = v91;
                v93[2] = v92;
              }
              v44 = v7 + 2;
              v88 += 2;
            }
            while (v7 + 2 != a2);
          }
          return result;
        }
        if (!a3)
        {
          if (v8 != a2)
          {
            v57 = (v10 - 2) >> 1;
            v58 = v57;
            do
            {
              v59 = v58;
              if (v57 >= v58)
              {
                v60 = (2 * v58) | 1;
                v61 = &v8[2 * v60];
                if (2 * v59 + 2 < (uint64_t)v10)
                {
                  v62 = v61[1];
                  v63 = v61[3];
                  v61 += 2 * (v62 > v63);
                  if (v62 > v63)
                    v60 = 2 * v59 + 2;
                }
                v64 = &v8[2 * v59];
                if (v61[1] <= v64[1])
                {
                  v65 = *v64;
                  v66 = v64[1];
                  do
                  {
                    v67 = v64;
                    v64 = v61;
                    *v67 = *v61;
                    v67[1] = v61[1];
                    if (v57 < v60)
                      break;
                    v68 = (2 * v60) | 1;
                    v61 = &v8[2 * v68];
                    v69 = 2 * v60 + 2;
                    if (v69 < (uint64_t)v10)
                    {
                      v70 = v61[1];
                      v71 = v61[3];
                      v61 += 2 * (v70 > v71);
                      if (v70 > v71)
                        v68 = v69;
                    }
                    result = (int *)v61[1];
                    v60 = v68;
                  }
                  while ((int)result <= v66);
                  *v64 = v65;
                  v64[1] = v66;
                }
              }
              v58 = v59 - 1;
            }
            while (v59);
            v72 = (unint64_t)v9 >> 3;
            do
            {
              v73 = 0;
              v74 = *(_QWORD *)v8;
              v75 = v8;
              do
              {
                v76 = &v75[2 * v73 + 2];
                v77 = (2 * v73) | 1;
                v78 = 2 * v73 + 2;
                if (v78 < v72)
                {
                  v79 = v76[1];
                  v80 = v76[3];
                  v76 += 2 * (v79 > v80);
                  if (v79 > v80)
                    v77 = v78;
                }
                *v75 = *v76;
                v75[1] = v76[1];
                v75 = v76;
                v73 = v77;
              }
              while (v77 <= (uint64_t)((unint64_t)(v72 - 2) >> 1));
              if (v76 == a2 - 2)
              {
                *(_QWORD *)v76 = v74;
              }
              else
              {
                *v76 = *(a2 - 2);
                v76[1] = *(a2 - 1);
                *((_QWORD *)a2 - 1) = v74;
                v81 = (char *)v76 - (char *)v8 + 8;
                if (v81 >= 9)
                {
                  v82 = (unint64_t)((v81 >> 3) - 2) >> 1;
                  v83 = &v8[2 * v82];
                  if (v83[1] > v76[1])
                  {
                    v84 = *v76;
                    v85 = v76[1];
                    do
                    {
                      v86 = v76;
                      v76 = v83;
                      *v86 = *v83;
                      v86[1] = v83[1];
                      if (!v82)
                        break;
                      v82 = (v82 - 1) >> 1;
                      v83 = &v8[2 * v82];
                    }
                    while (v83[1] > v85);
                    *v76 = v84;
                    v76[1] = v85;
                  }
                }
              }
              a2 -= 2;
            }
            while (v72-- > 2);
          }
          return result;
        }
        v11 = v10 >> 1;
        v12 = &v8[2 * (v10 >> 1)];
        if ((unint64_t)v9 < 0x401)
        {
          result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(&v7[2 * (v10 >> 1)], v7, a2 - 2);
        }
        else
        {
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(v7, &v7[2 * (v10 >> 1)], a2 - 2);
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(v7 + 2, v12 - 2, a2 - 4);
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(v7 + 4, &v7[2 * v11 + 2], a2 - 6);
          result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(v12 - 2, v12, &v7[2 * v11 + 2]);
          v13 = *(_QWORD *)v7;
          *(_QWORD *)v7 = *(_QWORD *)v12;
          *(_QWORD *)v12 = v13;
        }
        --a3;
        if ((a4 & 1) == 0 && *(v7 - 1) <= v7[1])
        {
          v29 = *(_QWORD *)v7;
          v30 = HIDWORD(*(_QWORD *)v7);
          if (*(a2 - 1) >= (int)v30)
          {
            v33 = v7 + 2;
            do
            {
              v8 = v33;
              if (v33 >= a2)
                break;
              v34 = v33[1];
              v33 += 2;
            }
            while (v34 >= (int)v30);
          }
          else
          {
            v31 = v7;
            do
            {
              v8 = v31 + 2;
              v32 = v31[3];
              v31 += 2;
            }
            while (v32 >= (int)v30);
          }
          v35 = a2;
          if (v8 < a2)
          {
            v36 = a2;
            do
            {
              v35 = v36 - 2;
              v37 = *(v36 - 1);
              v36 -= 2;
            }
            while (v37 < (int)v30);
          }
          while (v8 < v35)
          {
            v38 = *v8;
            *v8 = *v35;
            *v35 = v38;
            v39 = v8[1];
            v8[1] = v35[1];
            v35[1] = v39;
            do
            {
              v40 = v8[3];
              v8 += 2;
            }
            while (v40 >= (int)v30);
            do
            {
              v41 = *(v35 - 1);
              v35 -= 2;
            }
            while (v41 < (int)v30);
          }
          if (v8 - 2 != v7)
          {
            *v7 = *(v8 - 2);
            v7[1] = *(v8 - 1);
          }
          a4 = 0;
          *(v8 - 2) = v29;
          *(v8 - 1) = v30;
          continue;
        }
        v14 = *(_QWORD *)v7;
        v15 = HIDWORD(*(_QWORD *)v7);
        v16 = v7;
        do
        {
          v17 = v16;
          v16 += 2;
        }
        while (v17[3] > (int)v15);
        v18 = a2;
        if (v17 == v7)
        {
          v21 = a2;
          while (v16 < v21)
          {
            v19 = v21 - 2;
            v22 = *(v21 - 1);
            v21 -= 2;
            if (v22 > (int)v15)
              goto LABEL_21;
          }
          v19 = v21;
        }
        else
        {
          do
          {
            v19 = v18 - 2;
            v20 = *(v18 - 1);
            v18 -= 2;
          }
          while (v20 <= (int)v15);
        }
LABEL_21:
        v8 = v16;
        if (v16 < v19)
        {
          v23 = v19;
          do
          {
            v24 = *v8;
            *v8 = *v23;
            *v23 = v24;
            v25 = v8[1];
            v8[1] = v23[1];
            v23[1] = v25;
            do
            {
              v26 = v8[3];
              v8 += 2;
            }
            while (v26 > (int)v15);
            do
            {
              v27 = *(v23 - 1);
              v23 -= 2;
            }
            while (v27 <= (int)v15);
          }
          while (v8 < v23);
        }
        if (v8 - 2 != v7)
        {
          *v7 = *(v8 - 2);
          v7[1] = *(v8 - 1);
        }
        *(v8 - 2) = v14;
        *(v8 - 1) = v15;
        if (v16 < v19)
        {
LABEL_32:
          result = (int *)std::__introsort<std::_ClassicAlgPolicy,vision::mod::GreedyClusterer::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*,false>(v7, v8 - 2, a3, a4 & 1);
          a4 = 0;
          continue;
        }
        v28 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClusterer::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(v7, v8 - 2);
        result = (int *)std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClusterer::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(v8, a2);
        if (!(_DWORD)result)
        {
          if (v28)
            continue;
          goto LABEL_32;
        }
        a2 = v8 - 2;
        if (!v28)
          goto LABEL_2;
        return result;
    }
  }
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClusterer::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(int *a1, int *a2)
{
  uint64_t v4;
  _BOOL8 result;
  int v6;
  int v7;
  int *v8;
  int *v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  _DWORD *v15;
  int v16;
  int *v17;

  v4 = ((char *)a2 - (char *)a1) >> 3;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (*(a2 - 1) > a1[1])
      {
        v6 = *a1;
        *a1 = *(a2 - 2);
        *(a2 - 2) = v6;
        v7 = a1[1];
        a1[1] = *(a2 - 1);
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(a1, a1 + 2, a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1;
    case 5:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2);
      return 1;
    default:
      v8 = a1 + 4;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererWithTorso::private_t::clusters_t::sort(void)::{lambda(std::tuple<unsigned int,int> const&,std::tuple<unsigned int,int> const&)#1} &,std::tuple<unsigned int,int>*>(a1, a1 + 2, a1 + 4);
      v9 = a1 + 6;
      if (a1 + 6 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    if (v9[1] > v8[1])
    {
      v12 = *v9;
      v13 = v9[1];
      v14 = v10;
      while (1)
      {
        v15 = (int *)((char *)a1 + v14);
        v16 = *(int *)((char *)a1 + v14 + 20);
        v15[6] = *(int *)((char *)a1 + v14 + 16);
        v15[7] = v16;
        if (v14 == -16)
          break;
        v14 -= 8;
        if (v15[3] >= v13)
        {
          v17 = (int *)((char *)a1 + v14 + 24);
          goto LABEL_12;
        }
      }
      v17 = a1;
LABEL_12:
      *v17 = v12;
      v17[1] = v13;
      if (++v11 == 8)
        return v9 + 2 == a2;
    }
    v8 = v9;
    v10 += 8;
    v9 += 2;
    if (v9 == a2)
      return 1;
  }
}

_QWORD *std::set<long long>::set[abi:ne180100](_QWORD *a1, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t **v6;
  uint64_t **v7;
  uint64_t *v8;
  _QWORD *v9;
  _QWORD *v10;
  BOOL v11;
  uint64_t v13;
  uint64_t v14;

  a1[1] = 0;
  v3 = a1 + 1;
  a1[2] = 0;
  *a1 = a1 + 1;
  v4 = a2 + 1;
  v5 = (_QWORD *)*a2;
  if ((_QWORD *)*a2 != a2 + 1)
  {
    do
    {
      v6 = (uint64_t **)std::__tree<long long>::__find_equal<long long>(a1, v3, &v14, &v13, v5[4]);
      if (!*v6)
      {
        v7 = v6;
        v8 = (uint64_t *)operator new(0x28uLL);
        v8[4] = v5[4];
        std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::__insert_node_at((uint64_t **)a1, v14, v7, v8);
      }
      v9 = (_QWORD *)v5[1];
      if (v9)
      {
        do
        {
          v10 = v9;
          v9 = (_QWORD *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          v10 = (_QWORD *)v5[2];
          v11 = *v10 == (_QWORD)v5;
          v5 = v10;
        }
        while (!v11);
      }
      v5 = v10;
    }
    while (v10 != v4);
  }
  return a1;
}

void sub_1A155AA10(_Unwind_Exception *a1)
{
  _QWORD **v1;

  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__tree<long long>::__find_equal<long long>(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, uint64_t a5)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  BOOL v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  uint64_t v19;

  v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = a2[4], v6 > a5))
  {
    v7 = *a2;
    if ((_QWORD *)*a1 == a2)
    {
      v9 = a2;
LABEL_18:
      if (v7)
      {
        *a3 = v9;
        return v9 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v7)
    {
      v8 = (_QWORD *)*a2;
      do
      {
        v9 = v8;
        v8 = (_QWORD *)v8[1];
      }
      while (v8);
    }
    else
    {
      v12 = a2;
      do
      {
        v9 = (_QWORD *)v12[2];
        v13 = *v9 == (_QWORD)v12;
        v12 = v9;
      }
      while (v13);
    }
    if (v9[4] < a5)
      goto LABEL_18;
    v14 = (_QWORD *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v15 = v14;
          v16 = v14[4];
          if (v16 <= a5)
            break;
          v14 = (_QWORD *)*v15;
          v5 = v15;
          if (!*v15)
            goto LABEL_43;
        }
        if (v16 >= a5)
          break;
        v5 = v15 + 1;
        v14 = (_QWORD *)v15[1];
      }
      while (v14);
      goto LABEL_43;
    }
LABEL_42:
    v15 = a1 + 1;
LABEL_43:
    *a3 = v15;
    return v5;
  }
  if (v6 >= a5)
  {
    *a3 = a2;
    *a4 = a2;
    return a4;
  }
  v10 = a2[1];
  if (v10)
  {
    v11 = (_QWORD *)a2[1];
    do
    {
      a4 = v11;
      v11 = (_QWORD *)*v11;
    }
    while (v11);
  }
  else
  {
    v17 = a2;
    do
    {
      a4 = (_QWORD *)v17[2];
      v13 = *a4 == (_QWORD)v17;
      v17 = a4;
    }
    while (!v13);
  }
  if (a4 != v5 && a4[4] <= a5)
  {
    v18 = (_QWORD *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v15 = v18;
          v19 = v18[4];
          if (v19 <= a5)
            break;
          v18 = (_QWORD *)*v15;
          v5 = v15;
          if (!*v15)
            goto LABEL_43;
        }
        if (v19 >= a5)
          break;
        v5 = v15 + 1;
        v18 = (_QWORD *)v15[1];
      }
      while (v18);
      goto LABEL_43;
    }
    goto LABEL_42;
  }
  if (v10)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

void std::__shared_ptr_emplace<std::vector<std::pair<unsigned long,unsigned long>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453BBC0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::vector<std::pair<unsigned long,unsigned long>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453BBC0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A1B0A898);
}

void std::__shared_ptr_emplace<std::vector<std::pair<unsigned long,unsigned long>>>::__on_zero_shared(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(_QWORD *)(a1 + 32) = v2;
    operator delete(v2);
  }
}

void vision::mod::GreedyClustererFaces::getAverageDescriptorOfClusterContainingFace(_QWORD *a1, uint64_t a2, uint64_t a3, void *a4)
{
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  BOOL v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *exception;
  uint64_t v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t *v20;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  BOOL v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  float __B;
  uint64_t v32;

  if ((vision::mod::GreedyClustererFaces::isFaceIdInClustererState((vision::mod::GreedyClustererFaces *)a1, a2) & 1) == 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    v17 = 5244;
    goto LABEL_20;
  }
  if (!a4)
  {
    exception = __cxa_allocate_exception(8uLL);
    v17 = 5245;
LABEL_20:
    *exception = v17;
    __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
  }
  memset(a4, 48, 4 * *(int *)(a1[8] + 104));
  v8 = (_QWORD *)a1[18];
  if (!v8)
    goto LABEL_13;
  v9 = a1 + 18;
  do
  {
    v10 = v8[4];
    v11 = v10 < a2;
    if (v10 >= a2)
      v12 = v8;
    else
      v12 = v8 + 1;
    if (!v11)
      v9 = v8;
    v8 = (_QWORD *)*v12;
  }
  while (*v12);
  if (v9 == a1 + 18 || v9[4] > a2)
LABEL_13:
    v9 = a1 + 18;
  v13 = v9[5];
  v32 = v13;
  v14 = *(_QWORD **)(a3 + 8);
  if (!v14)
  {
LABEL_19:
    exception = __cxa_allocate_exception(8uLL);
    v17 = 5224;
    goto LABEL_20;
  }
  while (1)
  {
    v15 = v14[4];
    if (v13 >= v15)
      break;
LABEL_18:
    v14 = (_QWORD *)*v14;
    if (!v14)
      goto LABEL_19;
  }
  if (v15 < v13)
  {
    ++v14;
    goto LABEL_18;
  }
  v18 = std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>((uint64_t **)a3, v13, &v32);
  v20 = (uint64_t *)v18[5];
  v19 = (uint64_t *)v18[6];
  __B = 1.0 / (float)(unint64_t)(v19 - v20);
  if (v19 != v20)
  {
    v21 = a1 + 15;
    do
    {
      v22 = (_QWORD *)*v21;
      if (!*v21)
        goto LABEL_33;
      v23 = *v20;
      v24 = a1 + 15;
      do
      {
        v25 = v22[4];
        v26 = v25 < v23;
        if (v25 >= v23)
          v27 = v22;
        else
          v27 = v22 + 1;
        if (!v26)
          v24 = v22;
        v22 = (_QWORD *)*v27;
      }
      while (*v27);
      if (v24 == v21 || v23 < v24[4])
LABEL_33:
        v24 = a1 + 15;
      v28 = a1[8];
      v29 = *(_QWORD *)(v28 + 88);
      if (v29)
        v30 = *(_QWORD *)v29
            + *((unsigned int *)v24 + 10) * (unint64_t)*(unsigned int *)(*(_QWORD *)v29 + 16)
            + 24;
      else
        v30 = 0;
      vDSP_vadd((const float *)(v30 + 16), 1, (const float *)a4, 1, (float *)a4, 1, *(int *)(v28 + 104));
      ++v20;
    }
    while (v20 != v19);
  }
  vDSP_vsmul((const float *)a4, 1, &__B, (float *)a4, 1, *(int *)(a1[8] + 104));
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *,false>(uint64_t result, unint64_t a2, uint64_t a3, char a4)
{
  uint64_t v7;
  _DWORD *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  float v14;
  uint64_t v15;
  float v16;
  uint64_t v17;
  float v18;
  unint64_t v19;
  unint64_t v20;
  float v21;
  float v22;
  float *v23;
  float v24;
  float v25;
  float v26;
  float *v27;
  uint64_t v28;
  float v29;
  float v30;
  BOOL v31;
  float v32;
  unint64_t v33;
  unint64_t v34;
  float v35;
  float v36;
  float v37;
  uint64_t v38;
  float v39;
  float v40;
  float v41;
  uint64_t v42;
  float v43;
  uint64_t v44;
  float v45;
  float v46;
  uint64_t v47;
  uint64_t v48;
  float v49;
  uint64_t v50;
  float v51;
  uint64_t v52;
  unint64_t v53;
  BOOL v55;
  uint64_t v56;
  unint64_t v57;
  unint64_t v58;
  float v59;
  float v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  int64_t v65;
  int64_t v66;
  int64_t v67;
  uint64_t v68;
  unint64_t v69;
  unint64_t v70;
  float v71;
  float v72;
  float v73;
  uint64_t v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  float v80;
  uint64_t v81;
  unint64_t v82;
  unint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t v87;
  unint64_t v88;
  float v89;
  float v90;
  float v91;
  uint64_t v92;
  unint64_t v93;
  float *v95;
  uint64_t v96;
  float v97;
  float v98;
  uint64_t v99;
  float *v100;
  float *v101;
  uint64_t v102;

  v7 = result;
LABEL_2:
  v8 = (_DWORD *)(a2 - 16);
  v9 = v7;
  while (2)
  {
    v7 = v9;
    v10 = a2 - v9;
    v11 = (uint64_t)(a2 - v9) >> 4;
    switch(v11)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        v41 = *(float *)v9;
        if (*(float *)v8 < *(float *)v9)
        {
          *(_DWORD *)v9 = *v8;
          *(float *)(a2 - 16) = v41;
          v42 = *(_QWORD *)(v9 + 8);
          *(_QWORD *)(v9 + 8) = *(_QWORD *)(a2 - 8);
          *(_QWORD *)(a2 - 8) = v42;
        }
        return result;
      case 3uLL:
        return std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(v9, v9 + 16, a2 - 16);
      case 4uLL:
        return std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(v9, v9 + 16, v9 + 32, a2 - 16);
      case 5uLL:
        result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(v9, v9 + 16, v9 + 32, v9 + 48);
        v43 = *(float *)(v9 + 48);
        if (*(float *)v8 < v43)
        {
          *(_DWORD *)(v9 + 48) = *v8;
          *(float *)(a2 - 16) = v43;
          v44 = *(_QWORD *)(v9 + 56);
          *(_QWORD *)(v9 + 56) = *(_QWORD *)(a2 - 8);
          *(_QWORD *)(a2 - 8) = v44;
          v45 = *(float *)(v9 + 48);
          v46 = *(float *)(v9 + 32);
          if (v45 < v46)
          {
            *(float *)(v9 + 32) = v45;
            *(float *)(v9 + 48) = v46;
            v47 = *(_QWORD *)(v9 + 40);
            v48 = *(_QWORD *)(v9 + 56);
            *(_QWORD *)(v9 + 40) = v48;
            *(_QWORD *)(v9 + 56) = v47;
            v49 = *(float *)(v9 + 16);
            if (v45 < v49)
            {
              *(float *)(v9 + 16) = v45;
              *(float *)(v9 + 32) = v49;
              v50 = *(_QWORD *)(v9 + 24);
              *(_QWORD *)(v9 + 24) = v48;
              *(_QWORD *)(v9 + 40) = v50;
              v51 = *(float *)v9;
              if (v45 < *(float *)v9)
              {
                *(float *)v9 = v45;
                *(float *)(v9 + 16) = v51;
                v52 = *(_QWORD *)(v9 + 8);
                *(_QWORD *)(v9 + 8) = v48;
                *(_QWORD *)(v9 + 24) = v52;
              }
            }
          }
        }
        return result;
      default:
        if (v10 <= 383)
        {
          v53 = v9 + 16;
          v55 = v9 == a2 || v53 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v55)
            {
              v56 = 0;
              v57 = v9;
              do
              {
                v58 = v53;
                v59 = *(float *)(v57 + 16);
                v60 = *(float *)v57;
                if (v59 < *(float *)v57)
                {
                  v61 = *(_QWORD *)(v57 + 24);
                  v62 = v56;
                  while (1)
                  {
                    v63 = v9 + v62;
                    *(float *)(v63 + 16) = v60;
                    *(_QWORD *)(v63 + 24) = *(_QWORD *)(v9 + v62 + 8);
                    if (!v62)
                      break;
                    v60 = *(float *)(v63 - 16);
                    v62 -= 16;
                    if (v59 >= v60)
                    {
                      v64 = v9 + v62 + 16;
                      goto LABEL_80;
                    }
                  }
                  v64 = v9;
LABEL_80:
                  *(float *)v64 = v59;
                  *(_QWORD *)(v64 + 8) = v61;
                }
                v53 = v58 + 16;
                v56 += 16;
                v57 = v58;
              }
              while (v58 + 16 != a2);
            }
          }
          else if (!v55)
          {
            v95 = (float *)(v9 + 24);
            do
            {
              v96 = v53;
              v97 = *(float *)(v7 + 16);
              v98 = *(float *)v7;
              if (v97 < *(float *)v7)
              {
                v99 = *(_QWORD *)(v7 + 24);
                v100 = v95;
                do
                {
                  v101 = v100;
                  *(v100 - 2) = v98;
                  v102 = *((_QWORD *)v100 - 2);
                  v100 -= 4;
                  *(_QWORD *)v101 = v102;
                  v98 = *(v101 - 10);
                }
                while (v97 < v98);
                *(v100 - 2) = v97;
                *(_QWORD *)v100 = v99;
              }
              v53 = v96 + 16;
              v95 += 4;
              v7 = v96;
            }
            while (v96 + 16 != a2);
          }
          return result;
        }
        if (!a3)
        {
          if (v9 != a2)
          {
            v65 = (v11 - 2) >> 1;
            v66 = v65;
            do
            {
              v67 = v66;
              if (v65 >= v66)
              {
                v68 = (2 * v66) | 1;
                v69 = v9 + 16 * v68;
                if (2 * v67 + 2 < (uint64_t)v11 && *(float *)v69 < *(float *)(v69 + 16))
                {
                  v69 += 16;
                  v68 = 2 * v67 + 2;
                }
                v70 = v9 + 16 * v67;
                v71 = *(float *)v70;
                v72 = *(float *)v69;
                v73 = *(float *)v70;
                if (*(float *)v69 >= *(float *)v70)
                {
                  v74 = *(_QWORD *)(v70 + 8);
                  do
                  {
                    v75 = v70;
                    v70 = v69;
                    *(float *)v75 = v72;
                    *(_QWORD *)(v75 + 8) = *(_QWORD *)(v69 + 8);
                    if (v65 < v68)
                      break;
                    v76 = 2 * v68;
                    v68 = (2 * v68) | 1;
                    v69 = v9 + 16 * v68;
                    v77 = v76 + 2;
                    if (v77 < (uint64_t)v11)
                    {
                      result = v69 + 16;
                      if (*(float *)v69 < *(float *)(v69 + 16))
                      {
                        v69 += 16;
                        v68 = v77;
                      }
                    }
                    v72 = *(float *)v69;
                  }
                  while (*(float *)v69 >= v73);
                  *(float *)v70 = v71;
                  *(_QWORD *)(v70 + 8) = v74;
                }
              }
              v66 = v67 - 1;
            }
            while (v67);
            v78 = (unint64_t)v10 >> 4;
            do
            {
              v79 = 0;
              v80 = *(float *)v9;
              v81 = *(_QWORD *)(v9 + 8);
              v82 = v9;
              do
              {
                v83 = v82;
                v82 += 16 * v79 + 16;
                v84 = 2 * v79;
                v79 = (2 * v79) | 1;
                v85 = v84 + 2;
                if (v85 < v78 && *(float *)v82 < *(float *)(v82 + 16))
                {
                  v82 += 16;
                  v79 = v85;
                }
                *(_DWORD *)v83 = *(_DWORD *)v82;
                *(_QWORD *)(v83 + 8) = *(_QWORD *)(v82 + 8);
              }
              while (v79 <= (uint64_t)((unint64_t)(v78 - 2) >> 1));
              if (v82 == a2 - 16)
              {
                *(float *)v82 = v80;
                *(_QWORD *)(v82 + 8) = v81;
              }
              else
              {
                *(_DWORD *)v82 = *(_DWORD *)(a2 - 16);
                *(_QWORD *)(v82 + 8) = *(_QWORD *)(a2 - 8);
                *(float *)(a2 - 16) = v80;
                *(_QWORD *)(a2 - 8) = v81;
                v86 = v82 - v9 + 16;
                if (v86 >= 17)
                {
                  v87 = (((unint64_t)v86 >> 4) - 2) >> 1;
                  v88 = v9 + 16 * v87;
                  v89 = *(float *)v82;
                  v90 = *(float *)v88;
                  v91 = *(float *)v82;
                  if (*(float *)v88 < *(float *)v82)
                  {
                    v92 = *(_QWORD *)(v82 + 8);
                    do
                    {
                      v93 = v82;
                      v82 = v88;
                      *(float *)v93 = v90;
                      *(_QWORD *)(v93 + 8) = *(_QWORD *)(v88 + 8);
                      if (!v87)
                        break;
                      v87 = (v87 - 1) >> 1;
                      v88 = v9 + 16 * v87;
                      v90 = *(float *)v88;
                    }
                    while (*(float *)v88 < v91);
                    *(float *)v82 = v89;
                    *(_QWORD *)(v82 + 8) = v92;
                  }
                }
              }
              a2 -= 16;
            }
            while (v78-- > 2);
          }
          return result;
        }
        v12 = v11 >> 1;
        v13 = v9 + 16 * (v11 >> 1);
        if ((unint64_t)v10 < 0x801)
        {
          result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(v7 + 16 * (v11 >> 1), v7, a2 - 16);
        }
        else
        {
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(v7, v7 + 16 * (v11 >> 1), a2 - 16);
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(v7 + 16, v13 - 16, a2 - 32);
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(v7 + 32, v7 + 16 + 16 * v12, a2 - 48);
          result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(v13 - 16, v13, v7 + 16 + 16 * v12);
          v14 = *(float *)v7;
          *(_DWORD *)v7 = *(_DWORD *)v13;
          *(float *)v13 = v14;
          v15 = *(_QWORD *)(v7 + 8);
          *(_QWORD *)(v7 + 8) = *(_QWORD *)(v13 + 8);
          *(_QWORD *)(v13 + 8) = v15;
        }
        --a3;
        if ((a4 & 1) == 0)
        {
          v16 = *(float *)v7;
          v17 = *(_QWORD *)(v7 + 8);
          v18 = *(float *)v7;
          if (*(float *)(v7 - 16) < *(float *)v7)
            goto LABEL_12;
          if (v18 >= *(float *)v8)
          {
            v33 = v7 + 16;
            do
            {
              v9 = v33;
              if (v33 >= a2)
                break;
              v33 += 16;
            }
            while (v18 >= *(float *)v9);
          }
          else
          {
            v9 = v7;
            do
            {
              v32 = *(float *)(v9 + 16);
              v9 += 16;
            }
            while (v18 >= v32);
          }
          v34 = a2;
          if (v9 < a2)
          {
            v34 = a2;
            do
            {
              v35 = *(float *)(v34 - 16);
              v34 -= 16;
            }
            while (v18 < v35);
          }
          if (v9 < v34)
          {
            v36 = *(float *)v9;
            v37 = *(float *)v34;
            do
            {
              *(float *)v9 = v37;
              *(float *)v34 = v36;
              v38 = *(_QWORD *)(v9 + 8);
              *(_QWORD *)(v9 + 8) = *(_QWORD *)(v34 + 8);
              *(_QWORD *)(v34 + 8) = v38;
              do
              {
                v39 = *(float *)(v9 + 16);
                v9 += 16;
                v36 = v39;
              }
              while (v18 >= v39);
              do
              {
                v40 = *(float *)(v34 - 16);
                v34 -= 16;
                v37 = v40;
              }
              while (v18 < v40);
            }
            while (v9 < v34);
          }
          if (v9 - 16 != v7)
          {
            *(_DWORD *)v7 = *(_DWORD *)(v9 - 16);
            *(_QWORD *)(v7 + 8) = *(_QWORD *)(v9 - 8);
          }
          a4 = 0;
          *(float *)(v9 - 16) = v16;
          *(_QWORD *)(v9 - 8) = v17;
          continue;
        }
        v16 = *(float *)v7;
        v17 = *(_QWORD *)(v7 + 8);
        v18 = *(float *)v7;
LABEL_12:
        v19 = v7;
        do
        {
          v20 = v19;
          v21 = *(float *)(v19 + 16);
          v19 += 16;
          v22 = v21;
        }
        while (v18 > v21);
        v23 = (float *)a2;
        if (v20 == v7)
        {
          v23 = (float *)a2;
          do
          {
            if (v19 >= (unint64_t)v23)
              break;
            v25 = *(v23 - 4);
            v23 -= 4;
          }
          while (v18 <= v25);
        }
        else
        {
          do
          {
            v24 = *(v23 - 4);
            v23 -= 4;
          }
          while (v18 <= v24);
        }
        if (v19 >= (unint64_t)v23)
        {
          v9 = v19;
        }
        else
        {
          v26 = *v23;
          v9 = v19;
          v27 = v23;
          do
          {
            *(float *)v9 = v26;
            *v27 = v22;
            v28 = *(_QWORD *)(v9 + 8);
            *(_QWORD *)(v9 + 8) = *((_QWORD *)v27 + 1);
            *((_QWORD *)v27 + 1) = v28;
            do
            {
              v29 = *(float *)(v9 + 16);
              v9 += 16;
              v22 = v29;
            }
            while (v18 > v29);
            do
            {
              v30 = *(v27 - 4);
              v27 -= 4;
              v26 = v30;
            }
            while (v18 <= v30);
          }
          while (v9 < (unint64_t)v27);
        }
        if (v9 - 16 != v7)
        {
          *(_DWORD *)v7 = *(_DWORD *)(v9 - 16);
          *(_QWORD *)(v7 + 8) = *(_QWORD *)(v9 - 8);
        }
        *(float *)(v9 - 16) = v16;
        *(_QWORD *)(v9 - 8) = v17;
        if (v19 < (unint64_t)v23)
        {
LABEL_33:
          result = std::__introsort<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *,false>(v7, v9 - 16, a3, a4 & 1);
          a4 = 0;
          continue;
        }
        v31 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(v7, v9 - 16);
        result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(v9, a2);
        if (!(_DWORD)result)
        {
          if (v31)
            continue;
          goto LABEL_33;
        }
        a2 = v9 - 16;
        if (!v31)
          goto LABEL_2;
        return result;
    }
  }
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 result;
  float v6;
  uint64_t v7;
  float *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  float v12;
  float v13;
  float v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  float v19;
  uint64_t v20;
  float v21;
  float v22;
  uint64_t v23;
  uint64_t v24;
  float v25;
  uint64_t v26;
  float v27;
  uint64_t v28;

  v4 = (a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = *(float *)a1;
      if (*(float *)(a2 - 16) < *(float *)a1)
      {
        *(_DWORD *)a1 = *(_DWORD *)(a2 - 16);
        *(float *)(a2 - 16) = v6;
        v7 = *(_QWORD *)(a1 + 8);
        *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 - 8);
        *(_QWORD *)(a2 - 8) = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(a1, a1 + 16, a2 - 16);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(a1, a1 + 16, a1 + 32, a2 - 16);
      return 1;
    case 5:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(a1, a1 + 16, a1 + 32, a1 + 48);
      v19 = *(float *)(a1 + 48);
      if (*(float *)(a2 - 16) < v19)
      {
        *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 - 16);
        *(float *)(a2 - 16) = v19;
        v20 = *(_QWORD *)(a1 + 56);
        *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 - 8);
        *(_QWORD *)(a2 - 8) = v20;
        v21 = *(float *)(a1 + 48);
        v22 = *(float *)(a1 + 32);
        if (v21 < v22)
        {
          *(float *)(a1 + 32) = v21;
          *(float *)(a1 + 48) = v22;
          v23 = *(_QWORD *)(a1 + 40);
          v24 = *(_QWORD *)(a1 + 56);
          *(_QWORD *)(a1 + 40) = v24;
          *(_QWORD *)(a1 + 56) = v23;
          v25 = *(float *)(a1 + 16);
          if (v21 < v25)
          {
            *(float *)(a1 + 16) = v21;
            *(float *)(a1 + 32) = v25;
            v26 = *(_QWORD *)(a1 + 24);
            *(_QWORD *)(a1 + 24) = v24;
            *(_QWORD *)(a1 + 40) = v26;
            v27 = *(float *)a1;
            if (v21 < *(float *)a1)
            {
              *(float *)a1 = v21;
              *(float *)(a1 + 16) = v27;
              v28 = *(_QWORD *)(a1 + 8);
              *(_QWORD *)(a1 + 8) = v24;
              *(_QWORD *)(a1 + 24) = v28;
            }
          }
        }
      }
      return 1;
    default:
      v8 = (float *)(a1 + 32);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFacesWithTorso::anomalyForGroup(std::vector<long long> const&,long long,float &)::$_0 &,std::pair<float,unsigned long> *>(a1, a1 + 16, a1 + 32);
      v9 = a1 + 48;
      if (a1 + 48 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *(float *)v9;
    v13 = *(float *)v9;
    v14 = *v8;
    if (*(float *)v9 < *v8)
    {
      v15 = *(_QWORD *)(v9 + 8);
      v16 = v10;
      while (1)
      {
        v17 = a1 + v16;
        *(float *)(v17 + 48) = v14;
        *(_QWORD *)(v17 + 56) = *(_QWORD *)(a1 + v16 + 40);
        if (v16 == -32)
          break;
        v14 = *(float *)(v17 + 16);
        v16 -= 16;
        if (v13 >= v14)
        {
          v18 = a1 + v16 + 48;
          goto LABEL_13;
        }
      }
      v18 = a1;
LABEL_13:
      *(float *)v18 = v12;
      *(_QWORD *)(v18 + 8) = v15;
      if (++v11 == 8)
        return v9 + 16 == a2;
    }
    v8 = (float *)v9;
    v10 += 16;
    v9 += 16;
    if (v9 == a2)
      return 1;
  }
}

float *std::__introsort<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *,false>(float *result, unint64_t a2, uint64_t a3, char a4)
{
  float *v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  float *v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  float v16;
  float v17;
  float *v18;
  float *v19;
  unint64_t v20;
  unint64_t v21;
  float v22;
  unint64_t v23;
  float v24;
  unint64_t v25;
  uint64_t v26;
  int v27;
  float v28;
  float v29;
  BOOL v30;
  float *v31;
  float v32;
  float *v33;
  float v34;
  unint64_t v35;
  unint64_t v36;
  float v37;
  uint64_t v38;
  int v39;
  float v40;
  float v41;
  float v42;
  float v43;
  uint64_t v44;
  float v45;
  float v46;
  uint64_t v47;
  float v48;
  float v49;
  uint64_t v50;
  uint64_t v51;
  float v52;
  uint64_t v53;
  float v54;
  uint64_t v55;
  unint64_t v56;
  BOOL v58;
  uint64_t v59;
  unint64_t v60;
  unint64_t v61;
  float v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  int64_t v67;
  int64_t v68;
  int64_t v69;
  uint64_t v70;
  unint64_t v71;
  unint64_t v72;
  float v73;
  uint64_t v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  int v81;
  unint64_t v82;
  unint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t v87;
  unint64_t v88;
  float v89;
  uint64_t v90;
  unint64_t v91;
  unint64_t v93;
  float *v94;
  float v95;
  uint64_t v96;
  unint64_t v97;
  float v98;

  v7 = result;
LABEL_2:
  v8 = (unint64_t)v7;
  while (2)
  {
    v7 = (float *)v8;
    v9 = a2 - v8;
    v10 = (uint64_t)(a2 - v8) >> 4;
    switch(v10)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        v42 = *(float *)(a2 - 8);
        v43 = *(float *)(v8 + 8);
        if (v42 < v43)
        {
          v44 = *(_QWORD *)v8;
          *(_QWORD *)v8 = *(_QWORD *)(a2 - 16);
          *(_QWORD *)(a2 - 16) = v44;
          *(float *)(v8 + 8) = v42;
          *(float *)(a2 - 8) = v43;
        }
        return result;
      case 3uLL:
        return std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>((float *)v8, (float *)(v8 + 16), (float *)(a2 - 16));
      case 4uLL:
        return std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>((float *)v8, (float *)(v8 + 16), (float *)(v8 + 32), a2 - 16);
      case 5uLL:
        result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>((float *)v8, (float *)(v8 + 16), (float *)(v8 + 32), v8 + 48);
        v45 = *(float *)(a2 - 8);
        v46 = *(float *)(v8 + 56);
        if (v45 < v46)
        {
          v47 = *(_QWORD *)(v8 + 48);
          *(_QWORD *)(v8 + 48) = *(_QWORD *)(a2 - 16);
          *(_QWORD *)(a2 - 16) = v47;
          *(float *)(v8 + 56) = v45;
          *(float *)(a2 - 8) = v46;
          v48 = *(float *)(v8 + 56);
          v49 = *(float *)(v8 + 40);
          if (v48 < v49)
          {
            v50 = *(_QWORD *)(v8 + 32);
            v51 = *(_QWORD *)(v8 + 48);
            *(_QWORD *)(v8 + 32) = v51;
            *(_QWORD *)(v8 + 48) = v50;
            *(float *)(v8 + 40) = v48;
            *(float *)(v8 + 56) = v49;
            v52 = *(float *)(v8 + 24);
            if (v48 < v52)
            {
              v53 = *(_QWORD *)(v8 + 16);
              *(_QWORD *)(v8 + 16) = v51;
              *(_QWORD *)(v8 + 32) = v53;
              *(float *)(v8 + 24) = v48;
              *(float *)(v8 + 40) = v52;
              v54 = *(float *)(v8 + 8);
              if (v48 < v54)
              {
                v55 = *(_QWORD *)v8;
                *(_QWORD *)v8 = v51;
                *(_QWORD *)(v8 + 16) = v55;
                *(float *)(v8 + 8) = v48;
                *(float *)(v8 + 24) = v54;
              }
            }
          }
        }
        return result;
      default:
        if (v9 <= 383)
        {
          v56 = v8 + 16;
          v58 = v8 == a2 || v56 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v58)
            {
              v59 = 0;
              v60 = v8;
              do
              {
                v61 = v56;
                v62 = *(float *)(v60 + 24);
                if (v62 < *(float *)(v60 + 8))
                {
                  v63 = *(_QWORD *)(v60 + 16);
                  v64 = v59;
                  while (1)
                  {
                    v65 = v8 + v64;
                    *(_QWORD *)(v65 + 16) = *(_QWORD *)(v8 + v64);
                    *(_DWORD *)(v65 + 24) = *(_DWORD *)(v8 + v64 + 8);
                    if (!v64)
                      break;
                    v64 -= 16;
                    if (v62 >= *(float *)(v65 - 8))
                    {
                      v66 = v8 + v64 + 16;
                      goto LABEL_79;
                    }
                  }
                  v66 = v8;
LABEL_79:
                  *(_QWORD *)v66 = v63;
                  *(float *)(v66 + 8) = v62;
                }
                v56 = v61 + 16;
                v59 += 16;
                v60 = v61;
              }
              while (v61 + 16 != a2);
            }
          }
          else if (!v58)
          {
            v93 = v8 + 8;
            do
            {
              v94 = (float *)v56;
              v95 = v7[6];
              if (v95 < v7[2])
              {
                v96 = *((_QWORD *)v7 + 2);
                v97 = v93;
                do
                {
                  *(_QWORD *)(v97 + 8) = *(_QWORD *)(v97 - 8);
                  *(_DWORD *)(v97 + 16) = *(_DWORD *)v97;
                  v98 = *(float *)(v97 - 16);
                  v97 -= 16;
                }
                while (v95 < v98);
                *(_QWORD *)(v97 + 8) = v96;
                *(float *)(v97 + 16) = v95;
              }
              v56 = (unint64_t)(v94 + 4);
              v93 += 16;
              v7 = v94;
            }
            while (v94 + 4 != (float *)a2);
          }
          return result;
        }
        if (!a3)
        {
          if (v8 != a2)
          {
            v67 = (v10 - 2) >> 1;
            v68 = v67;
            do
            {
              v69 = v68;
              if (v67 >= v68)
              {
                v70 = (2 * v68) | 1;
                v71 = v8 + 16 * v70;
                if (2 * v69 + 2 < (uint64_t)v10 && *(float *)(v71 + 8) < *(float *)(v71 + 24))
                {
                  v71 += 16;
                  v70 = 2 * v69 + 2;
                }
                v72 = v8 + 16 * v69;
                v73 = *(float *)(v72 + 8);
                if (*(float *)(v71 + 8) >= v73)
                {
                  v74 = *(_QWORD *)v72;
                  do
                  {
                    v75 = v72;
                    v72 = v71;
                    *(_QWORD *)v75 = *(_QWORD *)v71;
                    *(_DWORD *)(v75 + 8) = *(_DWORD *)(v71 + 8);
                    if (v67 < v70)
                      break;
                    v76 = 2 * v70;
                    v70 = (2 * v70) | 1;
                    v71 = v8 + 16 * v70;
                    v77 = v76 + 2;
                    if (v77 < (uint64_t)v10 && *(float *)(v71 + 8) < *(float *)(v71 + 24))
                    {
                      v71 += 16;
                      v70 = v77;
                    }
                  }
                  while (*(float *)(v71 + 8) >= v73);
                  *(_QWORD *)v72 = v74;
                  *(float *)(v72 + 8) = v73;
                }
              }
              v68 = v69 - 1;
            }
            while (v69);
            v78 = (unint64_t)v9 >> 4;
            do
            {
              v79 = 0;
              v80 = *(_QWORD *)v8;
              v81 = *(_DWORD *)(v8 + 8);
              v82 = v8;
              do
              {
                v83 = v82;
                v82 += 16 * v79 + 16;
                v84 = 2 * v79;
                v79 = (2 * v79) | 1;
                v85 = v84 + 2;
                if (v85 < v78 && *(float *)(v82 + 8) < *(float *)(v82 + 24))
                {
                  v82 += 16;
                  v79 = v85;
                }
                *(_QWORD *)v83 = *(_QWORD *)v82;
                *(_DWORD *)(v83 + 8) = *(_DWORD *)(v82 + 8);
              }
              while (v79 <= (uint64_t)((unint64_t)(v78 - 2) >> 1));
              if (v82 == a2 - 16)
              {
                *(_QWORD *)v82 = v80;
                *(_DWORD *)(v82 + 8) = v81;
              }
              else
              {
                *(_QWORD *)v82 = *(_QWORD *)(a2 - 16);
                *(_DWORD *)(v82 + 8) = *(_DWORD *)(a2 - 8);
                *(_QWORD *)(a2 - 16) = v80;
                *(_DWORD *)(a2 - 8) = v81;
                v86 = v82 - v8 + 16;
                if (v86 >= 17)
                {
                  v87 = (((unint64_t)v86 >> 4) - 2) >> 1;
                  v88 = v8 + 16 * v87;
                  v89 = *(float *)(v82 + 8);
                  if (*(float *)(v88 + 8) < v89)
                  {
                    v90 = *(_QWORD *)v82;
                    do
                    {
                      v91 = v82;
                      v82 = v88;
                      *(_QWORD *)v91 = *(_QWORD *)v88;
                      *(_DWORD *)(v91 + 8) = *(_DWORD *)(v88 + 8);
                      if (!v87)
                        break;
                      v87 = (v87 - 1) >> 1;
                      v88 = v8 + 16 * v87;
                    }
                    while (*(float *)(v88 + 8) < v89);
                    *(_QWORD *)v82 = v90;
                    *(float *)(v82 + 8) = v89;
                  }
                }
              }
              a2 -= 16;
            }
            while (v78-- > 2);
          }
          return result;
        }
        v11 = v10 >> 1;
        v12 = (float *)(v8 + 16 * (v10 >> 1));
        if ((unint64_t)v9 < 0x801)
        {
          result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>(&v7[4 * (v10 >> 1)], v7, (float *)(a2 - 16));
        }
        else
        {
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>(v7, &v7[4 * (v10 >> 1)], (float *)(a2 - 16));
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>(v7 + 4, v12 - 4, (float *)(a2 - 32));
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>(v7 + 8, &v7[4 * v11 + 4], (float *)(a2 - 48));
          result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>(v12 - 4, v12, &v7[4 * v11 + 4]);
          v13 = *(_QWORD *)v7;
          *(_QWORD *)v7 = *(_QWORD *)v12;
          *(_QWORD *)v12 = v13;
          v14 = *((_DWORD *)v7 + 2);
          v7[2] = v12[2];
          *((_DWORD *)v12 + 2) = v14;
        }
        --a3;
        v15 = *(_QWORD *)v7;
        if ((a4 & 1) == 0)
        {
          v16 = v7[2];
          v17 = v16;
          if (*(v7 - 2) < v16)
            goto LABEL_12;
          if (v16 >= *(float *)(a2 - 8))
          {
            v33 = v7 + 4;
            do
            {
              v8 = (unint64_t)v33;
              if ((unint64_t)v33 >= a2)
                break;
              v34 = v33[2];
              v33 += 4;
            }
            while (v16 >= v34);
          }
          else
          {
            v31 = v7;
            do
            {
              v8 = (unint64_t)(v31 + 4);
              v32 = v31[6];
              v31 += 4;
            }
            while (v16 >= v32);
          }
          v35 = a2;
          if (v8 < a2)
          {
            v36 = a2;
            do
            {
              v35 = v36 - 16;
              v37 = *(float *)(v36 - 8);
              v36 -= 16;
            }
            while (v16 < v37);
          }
          while (v8 < v35)
          {
            v38 = *(_QWORD *)v8;
            *(_QWORD *)v8 = *(_QWORD *)v35;
            *(_QWORD *)v35 = v38;
            v39 = *(_DWORD *)(v8 + 8);
            *(_DWORD *)(v8 + 8) = *(_DWORD *)(v35 + 8);
            *(_DWORD *)(v35 + 8) = v39;
            do
            {
              v40 = *(float *)(v8 + 24);
              v8 += 16;
            }
            while (v16 >= v40);
            do
            {
              v41 = *(float *)(v35 - 8);
              v35 -= 16;
            }
            while (v16 < v41);
          }
          if ((float *)(v8 - 16) != v7)
          {
            *(_QWORD *)v7 = *(_QWORD *)(v8 - 16);
            v7[2] = *(float *)(v8 - 8);
          }
          a4 = 0;
          *(_QWORD *)(v8 - 16) = v15;
          *(float *)(v8 - 8) = v16;
          continue;
        }
        v16 = v7[2];
        v17 = v16;
LABEL_12:
        v18 = v7;
        do
        {
          v19 = v18;
          v18 += 4;
        }
        while (v17 > v19[6]);
        v20 = a2;
        if (v19 == v7)
        {
          v23 = a2;
          while ((unint64_t)v18 < v23)
          {
            v21 = v23 - 16;
            v24 = *(float *)(v23 - 8);
            v23 -= 16;
            if (v17 > v24)
              goto LABEL_22;
          }
          v21 = v23;
        }
        else
        {
          do
          {
            v21 = v20 - 16;
            v22 = *(float *)(v20 - 8);
            v20 -= 16;
          }
          while (v17 <= v22);
        }
LABEL_22:
        v8 = (unint64_t)v18;
        if ((unint64_t)v18 < v21)
        {
          v25 = v21;
          do
          {
            v26 = *(_QWORD *)v8;
            *(_QWORD *)v8 = *(_QWORD *)v25;
            *(_QWORD *)v25 = v26;
            v27 = *(_DWORD *)(v8 + 8);
            *(_DWORD *)(v8 + 8) = *(_DWORD *)(v25 + 8);
            *(_DWORD *)(v25 + 8) = v27;
            do
            {
              v28 = *(float *)(v8 + 24);
              v8 += 16;
            }
            while (v17 > v28);
            do
            {
              v29 = *(float *)(v25 - 8);
              v25 -= 16;
            }
            while (v17 <= v29);
          }
          while (v8 < v25);
        }
        if ((float *)(v8 - 16) != v7)
        {
          *(_QWORD *)v7 = *(_QWORD *)(v8 - 16);
          v7[2] = *(float *)(v8 - 8);
        }
        *(_QWORD *)(v8 - 16) = v15;
        *(float *)(v8 - 8) = v16;
        if ((unint64_t)v18 < v21)
        {
LABEL_33:
          result = (float *)std::__introsort<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *,false>(v7, v8 - 16, a3, a4 & 1);
          a4 = 0;
          continue;
        }
        v30 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>((uint64_t)v7, v8 - 16);
        result = (float *)std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>(v8, a2);
        if (!(_DWORD)result)
        {
          if (v30)
            continue;
          goto LABEL_33;
        }
        a2 = v8 - 16;
        if (!v30)
          goto LABEL_2;
        return result;
    }
  }
}

float *std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>(float *result, float *a2, float *a3)
{
  uint64_t v3;
  float v4;
  float v5;
  float v6;
  uint64_t v7;
  float v8;
  float v9;
  uint64_t v10;
  float v11;

  v3 = *(_QWORD *)a2;
  v4 = a2[2];
  v5 = result[2];
  v6 = a3[2];
  if (v4 >= v5)
  {
    if (v6 < v4)
    {
      *(_QWORD *)a2 = *(_QWORD *)a3;
      *(_QWORD *)a3 = v3;
      a2[2] = v6;
      a3[2] = v4;
      v8 = a2[2];
      v9 = result[2];
      if (v8 < v9)
      {
        v10 = *(_QWORD *)result;
        *(_QWORD *)result = *(_QWORD *)a2;
        *(_QWORD *)a2 = v10;
        result[2] = v8;
        a2[2] = v9;
      }
    }
  }
  else
  {
    v7 = *(_QWORD *)result;
    if (v6 >= v4)
    {
      *(_QWORD *)result = v3;
      *(_QWORD *)a2 = v7;
      result[2] = v4;
      a2[2] = v5;
      v11 = a3[2];
      if (v11 >= v5)
        return result;
      *(_QWORD *)a2 = *(_QWORD *)a3;
      *(_QWORD *)a3 = v7;
      a2[2] = v11;
    }
    else
    {
      *(_QWORD *)result = *(_QWORD *)a3;
      *(_QWORD *)a3 = v7;
      result[2] = v6;
    }
    a3[2] = v5;
  }
  return result;
}

float *std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>(float *a1, float *a2, float *a3, uint64_t a4)
{
  float *result;
  float v9;
  float v10;
  uint64_t v11;
  float v12;
  float v13;
  uint64_t v14;
  float v15;
  float v16;
  uint64_t v17;

  result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>(a1, a2, a3);
  v9 = *(float *)(a4 + 8);
  v10 = a3[2];
  if (v9 < v10)
  {
    v11 = *(_QWORD *)a3;
    *(_QWORD *)a3 = *(_QWORD *)a4;
    *(_QWORD *)a4 = v11;
    a3[2] = v9;
    *(float *)(a4 + 8) = v10;
    v12 = a3[2];
    v13 = a2[2];
    if (v12 < v13)
    {
      v14 = *(_QWORD *)a2;
      *(_QWORD *)a2 = *(_QWORD *)a3;
      *(_QWORD *)a3 = v14;
      a2[2] = v12;
      a3[2] = v13;
      v15 = a2[2];
      v16 = a1[2];
      if (v15 < v16)
      {
        v17 = *(_QWORD *)a1;
        *(_QWORD *)a1 = *(_QWORD *)a2;
        *(_QWORD *)a2 = v17;
        a1[2] = v15;
        a2[2] = v16;
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 result;
  float v6;
  float v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  float v18;
  float v19;
  uint64_t v20;
  float v21;
  float v22;
  uint64_t v23;
  uint64_t v24;
  float v25;
  uint64_t v26;
  float v27;
  uint64_t v28;

  v4 = (a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = *(float *)(a2 - 8);
      v7 = *(float *)(a1 + 8);
      if (v6 < v7)
      {
        v8 = *(_QWORD *)a1;
        *(_QWORD *)a1 = *(_QWORD *)(a2 - 16);
        *(_QWORD *)(a2 - 16) = v8;
        *(float *)(a1 + 8) = v6;
        *(float *)(a2 - 8) = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>((float *)a1, (float *)(a1 + 16), (float *)(a2 - 16));
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>((float *)a1, (float *)(a1 + 16), (float *)(a1 + 32), a2 - 16);
      return 1;
    case 5:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>((float *)a1, (float *)(a1 + 16), (float *)(a1 + 32), a1 + 48);
      v18 = *(float *)(a2 - 8);
      v19 = *(float *)(a1 + 56);
      if (v18 < v19)
      {
        v20 = *(_QWORD *)(a1 + 48);
        *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 - 16);
        *(_QWORD *)(a2 - 16) = v20;
        *(float *)(a1 + 56) = v18;
        *(float *)(a2 - 8) = v19;
        v21 = *(float *)(a1 + 56);
        v22 = *(float *)(a1 + 40);
        if (v21 < v22)
        {
          v23 = *(_QWORD *)(a1 + 32);
          v24 = *(_QWORD *)(a1 + 48);
          *(_QWORD *)(a1 + 32) = v24;
          *(_QWORD *)(a1 + 48) = v23;
          *(float *)(a1 + 40) = v21;
          *(float *)(a1 + 56) = v22;
          v25 = *(float *)(a1 + 24);
          if (v21 < v25)
          {
            v26 = *(_QWORD *)(a1 + 16);
            *(_QWORD *)(a1 + 16) = v24;
            *(_QWORD *)(a1 + 32) = v26;
            *(float *)(a1 + 24) = v21;
            *(float *)(a1 + 40) = v25;
            v27 = *(float *)(a1 + 8);
            if (v21 < v27)
            {
              v28 = *(_QWORD *)a1;
              *(_QWORD *)a1 = v24;
              *(_QWORD *)(a1 + 16) = v28;
              *(float *)(a1 + 8) = v21;
              *(float *)(a1 + 24) = v27;
            }
          }
        }
      }
      return 1;
    default:
      v9 = a1 + 32;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,vision::mod::GreedyClustererFaces::getSimilarFacesToClusterContaining(long long,std::vector<std::pair<long long,float>> &,std::map<long long,std::vector<long long>> &)::$_0 &,std::pair<unsigned long,float> *>((float *)a1, (float *)(a1 + 16), (float *)(a1 + 32));
      v10 = a1 + 48;
      if (a1 + 48 == a2)
        return 1;
      v11 = 0;
      v12 = 0;
      break;
  }
  while (1)
  {
    v13 = *(float *)(v10 + 8);
    if (v13 < *(float *)(v9 + 8))
    {
      v14 = *(_QWORD *)v10;
      v15 = v11;
      while (1)
      {
        v16 = a1 + v15;
        *(_QWORD *)(v16 + 48) = *(_QWORD *)(a1 + v15 + 32);
        *(_DWORD *)(v16 + 56) = *(_DWORD *)(a1 + v15 + 40);
        if (v15 == -32)
          break;
        v15 -= 16;
        if (v13 >= *(float *)(v16 + 24))
        {
          v17 = a1 + v15 + 48;
          goto LABEL_13;
        }
      }
      v17 = a1;
LABEL_13:
      *(_QWORD *)v17 = v14;
      *(float *)(v17 + 8) = v13;
      if (++v12 == 8)
        return v10 + 16 == a2;
    }
    v9 = v10;
    v11 += 16;
    v10 += 16;
    if (v10 == a2)
      return 1;
  }
}

uint64_t vision::mod::GreedyClustererFaces::affinityForFaceInternal(uint64_t a1, uint64_t *a2, _QWORD *a3, uint64_t a4)
{
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t *v14;
  unint64_t v15;
  const float *v16;
  const float *v17;
  vDSP_Length v18;
  float v19;
  unint64_t v20;
  float *v21;
  float *v22;
  float *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  float *v29;
  int v30;
  uint64_t v31;
  _BYTE v32[256];
  uint64_t *v33;
  float __C;

  v33 = a2;
  if (!vision::mod::GreedyClustererFaces::isFaceIdInClustererState((vision::mod::GreedyClustererFaces *)a1, (uint64_t)a2))return 5244;
  vision::mod::dist_greedy_status_t::dist_greedy_status_t((uint64_t)v32, *(_DWORD *)(*(_QWORD *)(a1 + 64) + 104), *(_DWORD *)(a1 + 28));
  v8 = (unint64_t)std::__tree<std::__value_type<long long,unsigned long>,std::__map_value_compare<long long,std::__value_type<long long,unsigned long>,std::less<long long>,true>,std::allocator<std::__value_type<long long,unsigned long>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>((uint64_t **)(a1 + 112), (uint64_t)a2, &v33)[5];
  if (v8 >= (uint64_t)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 56) - *(_QWORD *)(*(_QWORD *)(a1 + 64) + 48)) >> 2)
  {
    v14 = &CVML_status_inconsistentState;
  }
  else
  {
    v9 = (*(uint64_t (**)(_QWORD *))(*a3 + 104))(a3);
    v10 = *(_QWORD *)(a1 + 64);
    if (*(_DWORD *)(v10 + 104) == v9 >> 2)
    {
      v11 = *(_QWORD *)(v10 + 72);
      if (v11)
        v12 = *(_QWORD *)v11 + v8 * (unint64_t)*(unsigned int *)(*(_QWORD *)v11 + 16) + 24;
      else
        v12 = 0;
      std::vector<float>::reserve((void **)a4, a3[9]);
      if (a3[9])
      {
        v15 = 0;
        v16 = (const float *)(v12 + 16);
        v14 = &CVML_status_ok;
        do
        {
          v17 = (const float *)(a3[7] + 4 * (a3[8] >> 2) * v15);
          v18 = *(int *)(*(_QWORD *)(a1 + 64) + 104);
          __C = 0.0;
          vDSP_dotpr(v17, 1, v16, 1, &__C, v18);
          v19 = 1.0 - (float)((float)((float)(__C + 1.0) * -0.5) + 1.0);
          v21 = *(float **)(a4 + 8);
          v20 = *(_QWORD *)(a4 + 16);
          if ((unint64_t)v21 >= v20)
          {
            v23 = *(float **)a4;
            v24 = ((uint64_t)v21 - *(_QWORD *)a4) >> 2;
            v25 = v24 + 1;
            if ((unint64_t)(v24 + 1) >> 62)
              std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
            v26 = v20 - (_QWORD)v23;
            if (v26 >> 1 > v25)
              v25 = v26 >> 1;
            if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFFCLL)
              v27 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v27 = v25;
            if (v27)
            {
              v27 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v27);
              v23 = *(float **)a4;
              v21 = *(float **)(a4 + 8);
            }
            else
            {
              v28 = 0;
            }
            v29 = (float *)(v27 + 4 * v24);
            *v29 = v19;
            v22 = v29 + 1;
            while (v21 != v23)
            {
              v30 = *((_DWORD *)v21-- - 1);
              *((_DWORD *)v29-- - 1) = v30;
            }
            *(_QWORD *)a4 = v29;
            *(_QWORD *)(a4 + 8) = v22;
            *(_QWORD *)(a4 + 16) = v27 + 4 * v28;
            if (v23)
              operator delete(v23);
          }
          else
          {
            *v21 = v19;
            v22 = v21 + 1;
          }
          *(_QWORD *)(a4 + 8) = v22;
          ++v15;
        }
        while (a3[9] > v15);
      }
      else
      {
        v14 = &CVML_status_ok;
      }
    }
    else
    {
      v14 = &CVML_status_invalidParameter;
    }
  }
  v31 = *v14;
  vision::mod::dist_greedy_status_t::~dist_greedy_status_t((vision::mod::dist_greedy_status_t *)v32);
  return (v31 + 128) | 0x1400;
}

void sub_1A155C5E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  vision::mod::dist_greedy_status_t::~dist_greedy_status_t((vision::mod::dist_greedy_status_t *)&a9);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::GreedyClustererFaces::updateInternal(uint64_t a1, unint64_t *lpsrc, _QWORD *a3, _QWORD *a4, uint64_t **a5)
{
  _DWORD *v8;
  unint64_t v9;
  int v10;
  int v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v18;
  cvml::util::MMapFileBackingStore *v19;
  uint64_t *v20;
  unint64_t v21;
  float v22;
  float *v23;
  float v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  float v32;
  uint64_t v33;
  unsigned int *v34;
  unsigned int *v35;
  float v36;
  unsigned int v37;
  unsigned int v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  float v42;
  unint64_t v44;
  int v45;
  double v46;
  double v47;
  double v48;
  float *v49;
  float *v50;
  uint64_t v51;
  float v52;
  float v53;
  unint64_t v54;
  float v55;
  unint64_t v56;
  cvml::util::MMapFileBackingStore *v57;
  uint64_t v58;
  int v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  uint64x2_t v67;
  _DWORD *v68;
  int v69;
  int64x2_t v70;
  int32x2_t v71;
  unsigned int v72;
  _QWORD *v73;
  uint64_t *v74;
  uint64_t v75;
  unsigned int v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  char *v80;
  _DWORD *v81;
  char *v82;
  uint64_t v83;
  unint64_t v84;
  uint64_t v85;
  BOOL v86;
  unint64_t v87;
  uint64_t v88;
  _DWORD *v89;
  int v90;
  uint64_t *v91;
  uint64_t *v92;
  _QWORD *v93;
  uint64_t v94;
  _QWORD *v95;
  uint64_t *v96;
  uint64_t *v97;
  unint64_t v98;
  uint64_t *v99;
  uint64_t *v100;
  uint64_t *v101;
  _QWORD *v102;
  uint64_t v103;
  unint64_t *p_shared_owners;
  unint64_t v105;
  _QWORD *v107;
  _QWORD *v108;
  _QWORD *exception;
  _QWORD *v110;
  uint64_t v111;
  _QWORD *v112;
  _QWORD *v113;
  uint64_t v114;
  unint64_t *v115;
  uint64_t **v116;
  uint64_t v117;
  unsigned int v118;
  unint64_t v119;
  uint64_t v120;
  unint64_t v121;
  unint64_t v124;
  float *v125;
  int v126;
  int64x2_t v127;
  uint64_t **v128;
  std::__shared_weak_count *v129;
  uint64_t *v130;
  uint64_t *v131;
  uint64_t v132;
  uint64_t *v133[32];
  uint64_t __C[2];

  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = 5244;
    __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
  }
  if (lpsrc[9] != (uint64_t)(lpsrc[2] - lpsrc[1]) >> 3)
    syslog(5, "wrong number of descriptors id in descriptor buffer");
  v131 = 0;
  v132 = 0;
  v130 = (uint64_t *)&v131;
  v116 = a5;
  if (!v8)
  {
    syslog(5, "GreedyClusterer::addDescriptors must be called with a ImageDescriptorBufferFloat32 buffer");
LABEL_104:
    v110 = __cxa_allocate_exception(8uLL);
    v111 = 5244;
    goto LABEL_106;
  }
  if (v8[26] != *(_DWORD *)(a1 + 28))
  {
    syslog(5, "For consistency, GreedyClusterer::addDescriptors must be called with a ImageDescriptorBufferFloat32 having the same distance mode as GreedyClusterer::distance_mode");
    goto LABEL_104;
  }
  v125 = (float *)lpsrc[7];
  v9 = *((int *)lpsrc + 16);
  v10 = (*(uint64_t (**)(unint64_t *))(*lpsrc + 104))(lpsrc);
  if (!v125)
  {
    v110 = __cxa_allocate_exception(8uLL);
    v111 = 5245;
LABEL_106:
    *v110 = v111;
    __cxa_throw(v110, MEMORY[0x1E0DE4F28], 0);
  }
  v11 = v10;
  v12 = lpsrc[9];
  v13 = (std::__shared_weak_count *)operator new(0x30uLL);
  v13->__shared_owners_ = 0;
  v13->__shared_weak_owners_ = 0;
  v13->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453BCA0;
  v14 = (unint64_t)v11 >> 2;
  v128 = (uint64_t **)std::vector<unsigned long>::vector(&v13[1].__vftable, v12);
  v129 = v13;
  v15 = *(_QWORD *)(a1 + 64);
  v16 = *(_DWORD *)(v15 + 104);
  if (v16 != (_DWORD)v14 && v16 != 0)
  {
    v112 = __cxa_allocate_exception(8uLL);
    *v112 = 5244;
    __cxa_throw(v112, MEMORY[0x1E0DE4F28], 0);
  }
  v115 = lpsrc;
  *(_DWORD *)(v15 + 104) = v14;
  vision::mod::dist_greedy_status_t::dist_greedy_status_t((uint64_t)v133, (unint64_t)v11 >> 2, *(_DWORD *)(a1 + 28));
  v18 = *(_QWORD *)(a1 + 64);
  if (!*(_QWORD *)(v18 + 72) && !*(_QWORD *)(v18 + 88))
  {
    if (*(_DWORD *)(v18 + 104) != 128)
      __assert_rtn("addDescriptors", "GreedyClustering.cpp", 692, "elementSize == ELEMENT_SIZE");
    v19 = cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>::create((cvml::util::MMapFileBackingStore *)0x210);
    if (!v19)
    {
      v113 = __cxa_allocate_exception(8uLL);
      *v113 = 5246;
      __cxa_throw(v113, MEMORY[0x1E0DE4F28], 0);
    }
    v20 = *(uint64_t **)(a1 + 64);
    std::shared_ptr<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>>::reset[abi:ne180100]<cvml::util::BackedBuffer<cvml::util::MMapFileBackingStore>,void>((uint64_t)(v20 + 9), (uint64_t)v19);
    std::shared_ptr<vision::mod::ImageDescriptorProcessorAbstract>::operator=[abi:ne180100](v20 + 11, v20[9], v20[10]);
  }
  v124 = (unint64_t)v11 >> 2;
  if (!v12)
    goto LABEL_80;
  v21 = 0;
  v22 = *(float *)(*(_QWORD *)(a1 + 32) + 8) * *(float *)(a1 + 16);
  v23 = v125;
  v121 = v9 >> 2;
  v120 = (int)(v9 >> 2);
  v117 = ((unint64_t)v11 >> 2);
  v127 = vdupq_n_s64(2uLL);
  v119 = v12;
  do
  {
    v24 = 1.0;
    if (v21 < (uint64_t)(a3[1] - *a3) >> 2)
      v24 = *(float *)(*a3 + 4 * v21);
    if (v21 >= (uint64_t)(a4[1] - *a4) >> 2)
      v25 = 1;
    else
      v25 = *(_DWORD *)(*a4 + 4 * v21);
    v126 = v25;
    v32 = v24
        * (***(float (****)(_QWORD, uint64_t, unint64_t))(a1 + 32))(*(_QWORD *)(a1 + 32), (uint64_t)&v125[v21 * v120], v121);
    v33 = *(_QWORD *)(a1 + 64);
    v35 = *(unsigned int **)(v33 + 48);
    v34 = *(unsigned int **)(v33 + 56);
    if (v35 == v34)
      goto LABEL_44;
    v36 = 0.0;
    v37 = -1;
    do
    {
      v38 = *v35;
      v39 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 72);
      if (v39)
      {
        v40 = *(_QWORD *)v39 + *(unsigned int *)(*(_QWORD *)v39 + 16) * (unint64_t)v38;
        if (*(int *)(v40 + 32) < 1)
          goto LABEL_37;
        v41 = v40 + 24;
      }
      else
      {
        if (MEMORY[8] < 1)
          goto LABEL_37;
        v41 = 0;
      }
      LODWORD(__C[0]) = 0;
      vDSP_dotpr((const float *)(v41 + 16), 1, &v125[v21 * v120], 1, (float *)__C, (int)v124);
      v42 = (float)((float)(*(float *)__C + 1.0) * -0.5) + 1.0;
      if (v42 < v22 && (v42 < v36 || v37 == -1))
      {
        v36 = (float)((float)(*(float *)__C + 1.0) * -0.5) + 1.0;
        v37 = v38;
      }
LABEL_37:
      ++v35;
    }
    while (v35 != v34);
    v33 = *(_QWORD *)(a1 + 64);
    if ((v37 & 0x80000000) == 0)
    {
      v44 = **(_QWORD **)(v33 + 72) + *(unsigned int *)(**(_QWORD **)(v33 + 72) + 16) * (unint64_t)v37;
      v45 = *(_DWORD *)(v44 + 32);
      v46 = (double)v126 + (double)v45;
      v47 = (double)v126 / v46;
      v48 = (double)v45 / v46;
      v12 = v119;
      if ((int)v124 >= 1)
      {
        v49 = (float *)(v44 + 40);
        v50 = v23;
        v51 = v117;
        do
        {
          v52 = *v50++;
          v53 = v47 * v52 + *v49 * v48;
          *v49++ = v53;
          --v51;
        }
        while (v51);
      }
      v54 = v44 + 24;
      *(_DWORD *)(v54 + 8) = v45 + v126;
      v55 = v47 * v32 + *(float *)(v54 + 12) * v48;
      *(float *)(v54 + 12) = v55;
      v56 = *(_QWORD *)v54;
      goto LABEL_79;
    }
    v12 = v119;
LABEL_44:
    v57 = *(cvml::util::MMapFileBackingStore **)(v33 + 72);
    if (!v57)
      goto LABEL_99;
    v58 = *(_QWORD *)v57;
    v59 = *(_DWORD *)(*(_QWORD *)v57 + 8);
    if (v59)
      goto LABEL_58;
    v60 = *(unsigned int *)(v58 + 12);
    if ((_DWORD)v60)
      v61 = (2 * v60);
    else
      v61 = 256;
    if (v61 <= v60
      || (v118 = *(_DWORD *)(v58 + 16),
          v62 = v61 * (unint64_t)v118,
          !cvml::util::MMapFileBackingStore::growStorage(v57, (cvml::util::MMapFileBackingStore *)(v62 + 24 + 4 * v61))))
    {
      VNValidatedLog(4, (uint64_t)CFSTR("BackedBuffer<BackingStore>::allocateElement -- could not allocate new element because grow failed"), v26, v27, v28, v29, v30, v31, v114);
LABEL_99:
      v108 = __cxa_allocate_exception(8uLL);
      *v108 = 5246;
      __cxa_throw(v108, MEMORY[0x1E0DE4F28], 0);
    }
    v63 = 0;
    v64 = *(_QWORD *)v57;
    v65 = (4 * v61 - 4 * v60 - 4) >> 2;
    v66 = (v65 + 2) & 0x7FFFFFFFFFFFFFFELL;
    v67 = (uint64x2_t)vdupq_n_s64(v65);
    v68 = (_DWORD *)(*(_QWORD *)v57 + v62 + 28);
    v69 = -2;
    v70 = (int64x2_t)xmmword_1A15DD910;
    do
    {
      v71 = vmovn_s64((int64x2_t)vcgeq_u64(v67, (uint64x2_t)v70));
      if ((v71.i8[0] & 1) != 0)
        *(v68 - 1) = v61 + v69 + 1;
      if ((v71.i8[4] & 1) != 0)
        *v68 = v61 + (v63 ^ 0xFFFFFFFE);
      v63 += 2;
      v70 = vaddq_s64(v70, v127);
      v69 -= 2;
      v68 += 2;
    }
    while (v66 != v63);
    *(_QWORD *)v64 = v62 + 24;
    *(_DWORD *)(v64 + 12) = v61;
    *(_DWORD *)(v64 + 16) = v118;
    *(_DWORD *)(v64 + 8) = v61 - v60;
    std::vector<BOOL>::resize((uint64_t)v57 + 56, v61, 0);
    v58 = *(_QWORD *)v57;
    v59 = *(_DWORD *)(*(_QWORD *)v57 + 8);
    v12 = v119;
LABEL_58:
    v72 = v59 - 1;
    *(_DWORD *)(v58 + 8) = v72;
    v56 = *(unsigned int *)(v58 + *(_QWORD *)v58 + 4 * v72);
    *(_QWORD *)(*((_QWORD *)v57 + 7) + ((v56 >> 3) & 0x1FFFFFF8)) |= 1 << v56;
    if ((_DWORD)v56 == -1)
      goto LABEL_99;
    v73 = *(_QWORD **)(a1 + 64);
    v74 = (uint64_t *)v73[9];
    if (!v74)
    {
      v107 = __cxa_allocate_exception(8uLL);
      *v107 = 5246;
      __cxa_throw(v107, MEMORY[0x1E0DE4F28], 0);
    }
    v75 = *v74;
    v76 = *(_DWORD *)(v75 + 16);
    if ((int)v124 >= 1)
    {
      v77 = 0;
      do
      {
        *(float *)(v75 + v76 * (unint64_t)v56 + 40 + v77 * 4) = v23[v77];
        ++v77;
      }
      while (v117 != v77);
    }
    v78 = v75 + v76 * (unint64_t)v56;
    *(_QWORD *)(v78 + 24) = v56;
    v78 += 24;
    *(float *)(v78 + 12) = v32;
    *(_DWORD *)(v78 + 8) = v126;
    v80 = (char *)v73[7];
    v79 = v73[8];
    if ((unint64_t)v80 >= v79)
    {
      v82 = (char *)v73[6];
      v83 = (v80 - v82) >> 2;
      v84 = v83 + 1;
      if ((unint64_t)(v83 + 1) >> 62)
        std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
      v85 = v79 - (_QWORD)v82;
      if (v85 >> 1 > v84)
        v84 = v85 >> 1;
      v86 = (unint64_t)v85 >= 0x7FFFFFFFFFFFFFFCLL;
      v87 = 0x3FFFFFFFFFFFFFFFLL;
      if (!v86)
        v87 = v84;
      if (v87)
      {
        v87 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v87);
        v82 = (char *)v73[6];
        v80 = (char *)v73[7];
      }
      else
      {
        v88 = 0;
      }
      v89 = (_DWORD *)(v87 + 4 * v83);
      *v89 = v56;
      v81 = v89 + 1;
      while (v80 != v82)
      {
        v90 = *((_DWORD *)v80 - 1);
        v80 -= 4;
        *--v89 = v90;
      }
      v73[6] = v89;
      v73[7] = v81;
      v73[8] = v87 + 4 * v88;
      if (v82)
        operator delete(v82);
    }
    else
    {
      *(_DWORD *)v80 = v56;
      v81 = v80 + 4;
    }
    v73[7] = v81;
LABEL_79:
    (*v128)[v21++] = v56;
    v23 += v120;
  }
  while (v21 != v12);
LABEL_80:
  vision::mod::dist_greedy_status_t::~dist_greedy_status_t((vision::mod::dist_greedy_status_t *)v133);
  v91 = *v128;
  v92 = v128[1];
  if (*v128 != v92)
  {
    do
    {
      v93 = operator new(0x28uLL);
      v94 = *v91;
      v93[4] = *v91;
      v95 = std::__tree<long long>::__find_equal<long long>(&v130, &v131, v133, __C, v94);
      if (*v95)
      {
        operator delete(v93);
      }
      else
      {
        v96 = v133[0];
        *v93 = 0;
        v93[1] = 0;
        v93[2] = v96;
        *v95 = v93;
        if (*v130)
        {
          v130 = (uint64_t *)*v130;
          v93 = (_QWORD *)*v95;
        }
        std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v131, v93);
        ++v132;
      }
      ++v91;
    }
    while (v91 != v92);
    v97 = *v128;
    if (v128[1] != *v128)
    {
      v98 = 0;
      do
      {
        v133[0] = *(uint64_t **)(v115[1] + 8 * v98);
        v99 = v133[0];
        v100 = (uint64_t *)v97[v98];
        __C[0] = (uint64_t)v100;
        v101 = std::__tree<std::__value_type<unsigned long,std::list<long long>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::list<long long>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::list<long long>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>((uint64_t **)(a1 + 88), (unint64_t)v100, __C);
        v102 = operator new(0x18uLL);
        v102[2] = v99;
        v103 = v101[5];
        v101 += 5;
        *v102 = v103;
        v102[1] = v101;
        *(_QWORD *)(v103 + 8) = v102;
        *v101 = (uint64_t)v102;
        ++v101[2];
        std::__tree<std::__value_type<long long,unsigned long>,std::__map_value_compare<long long,std::__value_type<long long,unsigned long>,std::less<long long>,true>,std::allocator<std::__value_type<long long,unsigned long>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>((uint64_t **)(a1 + 112), (uint64_t)v99, v133)[5] = v100;
        ++v98;
        v97 = *v128;
      }
      while (v98 < v128[1] - *v128);
    }
  }
  if (v129)
  {
    p_shared_owners = (unint64_t *)&v129->__shared_owners_;
    do
      v105 = __ldaxr(p_shared_owners);
    while (__stlxr(v105 - 1, p_shared_owners));
    if (!v105)
    {
      ((void (*)(std::__shared_weak_count *))v129->__on_zero_shared)(v129);
      std::__shared_weak_count::__release_weak(v129);
    }
  }
  vision::mod::GreedyClustererFaces::computeDeltaAfterUpdate(a1, v116, (uint64_t *)&v130);
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(v131);
  return 5248;
}

void sub_1A155CF30(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,_QWORD *a33,uint64_t a34,char a35)
{
  uint64_t v37;

  vision::mod::dist_greedy_status_t::~dist_greedy_status_t((vision::mod::dist_greedy_status_t *)&a35);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a30);
  if (a2 == 1)
  {
    v37 = *(_QWORD *)__cxa_begin_catch(a1);
    __cxa_end_catch();
    if (v37 == 5248)
      JUMPOUT(0x1A155CDA0);
    JUMPOUT(0x1A155CDB4);
  }
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(a33);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<std::vector<unsigned long>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453BCA0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::vector<unsigned long>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453BCA0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A1B0A898);
}

void std::__shared_ptr_emplace<std::vector<unsigned long>>::__on_zero_shared(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(_QWORD *)(a1 + 32) = v2;
    operator delete(v2);
  }
}

void std::allocate_shared[abi:ne180100]<vision::mod::GreedyClustererFaces,std::allocator<vision::mod::GreedyClustererFaces>,char const*&,std::shared_ptr<std::vector<unsigned char>> &,BOOL &,std::shared_ptr<apple::vision::GreedyClusteringParamsWrapper> const&,void>(_QWORD *a1, char *a2, uint64_t **a3, char a4, uint64_t *a5)
{
  char *v9;
  void **v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _BOOL4 v17;
  int v18;
  char *v19;
  uint64_t *v20;
  char *v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t *v24;
  _QWORD *v25;
  uint64_t v26;
  _QWORD *v27;
  _QWORD *v28;
  BOOL v29;
  void *__p[2];
  uint64_t v32;
  int v33;
  std::string v34;
  std::string __s;
  uint64_t *v36;
  uint64_t *v37;

  v9 = (char *)operator new(0xF0uLL);
  *((_QWORD *)v9 + 1) = 0;
  *((_QWORD *)v9 + 2) = 0;
  *(_QWORD *)v9 = &off_1E453B648;
  *((_QWORD *)v9 + 3) = off_1E453A1D8;
  vision::mod::GreedyClusterer::GreedyClusterer((uint64_t)(v9 + 32), a2, a5);
  *((_QWORD *)v9 + 26) = 0;
  v10 = (void **)(v9 + 208);
  *((_QWORD *)v9 + 3) = &off_1E453A450;
  *((_QWORD *)v9 + 4) = &unk_1E453A530;
  *((_QWORD *)v9 + 15) = 0;
  *((_QWORD *)v9 + 14) = v9 + 120;
  *((_QWORD *)v9 + 16) = 0;
  *((_QWORD *)v9 + 18) = 0;
  v11 = v9 + 144;
  *((_QWORD *)v9 + 17) = v9 + 144;
  v12 = v9 + 136;
  *((_QWORD *)v9 + 21) = 0;
  *((_QWORD *)v9 + 20) = v9 + 168;
  *((_QWORD *)v9 + 19) = 0;
  *((_QWORD *)v9 + 24) = 0;
  *((_QWORD *)v9 + 25) = 0;
  *((_QWORD *)v9 + 22) = 0;
  *((_QWORD *)v9 + 23) = v9 + 192;
  *((_QWORD *)v9 + 27) = 0;
  *((_QWORD *)v9 + 28) = 0;
  v9[232] = 0;
  memset(&__s, 0, sizeof(__s));
  memset(&v34, 0, sizeof(v34));
  v33 = -1;
  std::string::basic_string[abi:ne180100]<0>(__p, a2);
  v16 = vision::mod::GreedyClustererFaces::pasreAndVerifyClustererState((uint64_t)__p, **a3, &__s, &v34, &v33, v13, v14, v15);
  if (SHIBYTE(v32) < 0)
    operator delete(__p[0]);
  if (v16 == 5248)
  {
    v17 = a4 != 0;
    v18 = v33;
    if ((vision::mod::GreedyClusterer::deserializeStatus((vision::mod::GreedyClusterer *)(v9 + 32), v33, v17) & 1) != 0)
    {
      __p[0] = 0;
      read(v18, __p, 8uLL);
      if (__p[0])
      {
        v19 = 0;
        do
        {
          v37 = 0;
          read(v18, &v37, 8uLL);
          v36 = 0;
          read(v18, &v36, 8uLL);
          v20 = v36;
          std::__tree<std::__value_type<long long,unsigned long>,std::__map_value_compare<long long,std::__value_type<long long,unsigned long>,std::less<long long>,true>,std::allocator<std::__value_type<long long,unsigned long>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>((uint64_t **)v9 + 17, (uint64_t)v37, &v37)[5] = v20;
          ++v19;
        }
        while (v19 < __p[0]);
      }
      __p[0] = 0;
      read(v18, __p, 8uLL);
      if (__p[0])
      {
        v21 = 0;
        do
        {
          v37 = 0;
          read(v18, &v37, 8uLL);
          v36 = 0;
          read(v18, &v36, 8uLL);
          v22 = (uint64_t)v36;
          std::__tree<std::__value_type<long long,long long>,std::__map_value_compare<long long,std::__value_type<long long,long long>,std::less<long long>,true>,std::allocator<std::__value_type<long long,long long>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>((uint64_t **)v9 + 20, (uint64_t)v37, (uint64_t *)&v37)[5] = v22;
          ++v21;
        }
        while (v21 < __p[0]);
      }
      v23 = (_QWORD *)*v12;
      if ((_QWORD *)*v12 != v11)
      {
        do
        {
          v24 = std::__tree<std::__value_type<unsigned long,std::list<long long>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::list<long long>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::list<long long>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>((uint64_t **)v9 + 14, v23[5], v23 + 5);
          v25 = operator new(0x18uLL);
          v25[2] = v23[4];
          v26 = v24[5];
          v24 += 5;
          *v25 = v26;
          v25[1] = v24;
          *(_QWORD *)(v26 + 8) = v25;
          *v24 = (uint64_t)v25;
          ++v24[2];
          v27 = (_QWORD *)v23[1];
          if (v27)
          {
            do
            {
              v28 = v27;
              v27 = (_QWORD *)*v27;
            }
            while (v27);
          }
          else
          {
            do
            {
              v28 = (_QWORD *)v23[2];
              v29 = *v28 == (_QWORD)v23;
              v23 = v28;
            }
            while (!v29);
          }
          v23 = v28;
        }
        while (v28 != v11);
      }
      close(v18);
      getRelativePath(__p, *((char **)v9 + 11), &__s);
      if (v9[231] < 0)
        operator delete(*v10);
      *(_OWORD *)v10 = *(_OWORD *)__p;
      *((_QWORD *)v9 + 28) = v32;
      v9[232] = 1;
    }
    else
    {
      close(v18);
    }
  }
  if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v34.__r_.__value_.__l.__data_);
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__s.__r_.__value_.__l.__data_);
  *a1 = v9 + 24;
  a1[1] = v9;
}

void sub_1A155D394(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _QWORD **a10, _QWORD **a11, _QWORD **a12, vision::mod::GreedyClusterer *a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  void **v33;
  uint64_t v34;
  _QWORD **v35;
  void *v37;

  if (a27 < 0)
    operator delete(__p);
  if (a33 < 0)
    operator delete(a28);
  if (*(char *)(v34 + 231) < 0)
    operator delete(*v33);
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*a10);
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*a11);
  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*v35);
  std::__tree<std::__value_type<unsigned long,std::list<long long>>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,std::list<long long>>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,std::list<long long>>>>::destroy(*a12);
  vision::mod::GreedyClusterer::~GreedyClusterer(a13);
  std::__shared_weak_count::~__shared_weak_count((std::__shared_weak_count *)v34);
  operator delete(v37);
  _Unwind_Resume(a1);
}

uint64_t std::allocate_shared[abi:ne180100]<vision::mod::GreedyClustererFaces,std::allocator<vision::mod::GreedyClustererFaces>,char const*&,std::shared_ptr<apple::vision::GreedyClusteringParamsWrapper> const&,void>(_QWORD *a1, char *a2, uint64_t *a3)
{
  _QWORD *v6;
  uint64_t result;

  v6 = operator new(0xF0uLL);
  v6[1] = 0;
  v6[2] = 0;
  *v6 = &off_1E453B648;
  v6[3] = off_1E453A1D8;
  result = vision::mod::GreedyClusterer::GreedyClusterer((uint64_t)(v6 + 4), a2, a3);
  v6[3] = &off_1E453A450;
  v6[4] = &unk_1E453A530;
  v6[15] = 0;
  v6[14] = v6 + 15;
  v6[18] = 0;
  v6[16] = 0;
  v6[17] = v6 + 18;
  v6[21] = 0;
  v6[19] = 0;
  v6[20] = v6 + 21;
  v6[25] = 0;
  v6[26] = 0;
  v6[24] = 0;
  v6[22] = 0;
  v6[23] = v6 + 24;
  v6[27] = 0;
  v6[28] = 0;
  *((_BYTE *)v6 + 232) = 1;
  *a1 = v6 + 3;
  a1[1] = v6;
  return result;
}

void sub_1A155D504(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;
  void *v3;

  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::GreedyClusterer::GreedyClusterer(uint64_t a1, char *a2, uint64_t *a3)
{
  _QWORD *v4;
  std::string **v5;
  char *v8;
  __int128 v9;
  std::string *v10;
  __int128 v11;
  std::string *v12;
  std::string::size_type size;
  void **v14;
  std::string::size_type v15;
  _QWORD *exception;
  void *__p[2];
  int64_t v19;

  *(_QWORD *)a1 = &off_1E453A2B8;
  *(_QWORD *)(a1 + 8) = 0x13F000000;
  *(_BYTE *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 2;
  *(_OWORD *)(a1 + 24) = 0u;
  v4 = (_QWORD *)(a1 + 24);
  *(_OWORD *)(a1 + 56) = 0u;
  v5 = (std::string **)(a1 + 56);
  *(_OWORD *)(a1 + 40) = 0u;
  *(_BYTE *)(a1 + 72) = 0;
  if (!*a3)
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = 5245;
    __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
  }
  v8 = (char *)operator new(0x98uLL);
  *((_QWORD *)v8 + 1) = 0;
  *((_QWORD *)v8 + 2) = 0;
  *(_QWORD *)v8 = &off_1E453B530;
  *(_OWORD *)(v8 + 40) = 0u;
  *(_OWORD *)(v8 + 56) = 0u;
  *(_OWORD *)(v8 + 72) = 0u;
  *(_OWORD *)(v8 + 88) = 0u;
  *(_OWORD *)(v8 + 104) = 0u;
  *(_OWORD *)(v8 + 120) = 0u;
  *(_OWORD *)(v8 + 136) = 0u;
  *(_OWORD *)(v8 + 24) = 0u;
  *(_QWORD *)&v9 = v8 + 24;
  *((_QWORD *)&v9 + 1) = v8;
  *(_OWORD *)v5 = v9;
  if (a2)
  {
    std::string::basic_string[abi:ne180100]<0>(__p, a2);
    v10 = *v5;
    if (SHIBYTE((*v5)->__r_.__value_.__r.__words[2]) < 0)
      operator delete(v10->__r_.__value_.__l.__data_);
    v11 = *(_OWORD *)__p;
    v10->__r_.__value_.__r.__words[2] = v19;
    *(_OWORD *)&v10->__r_.__value_.__l.__data_ = v11;
    v12 = *v5;
    if (SHIBYTE((*v5)->__r_.__value_.__r.__words[2]) < 0)
    {
      v12 = (std::string *)v12->__r_.__value_.__r.__words[0];
      size = (*v5)->__r_.__value_.__l.__size_;
    }
    else
    {
      size = HIBYTE((*v5)->__r_.__value_.__r.__words[2]);
    }
    if (v12->__r_.__value_.__s.__data_[size - 1] != 47)
    {
      std::string::basic_string[abi:ne180100]<0>(__p, "/");
      if (v19 >= 0)
        v14 = __p;
      else
        v14 = (void **)__p[0];
      if (v19 >= 0)
        v15 = HIBYTE(v19);
      else
        v15 = (std::string::size_type)__p[1];
      std::string::append(*v5, (const std::string::value_type *)v14, v15);
      if (SHIBYTE(v19) < 0)
        operator delete(__p[0]);
    }
  }
  std::shared_ptr<vision::mod::ImageDescriptorProcessorAbstract>::operator=[abi:ne180100](v4, *a3, a3[1]);
  return a1;
}

void sub_1A155D6BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (a15 < 0)
    operator delete(__p);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](v17);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](v15 + 40);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](v16);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<vision::mod::GreedyClusterer::private_t>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453B530;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<vision::mod::GreedyClusterer::private_t>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453B530;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A1B0A898);
}

void std::__shared_ptr_emplace<vision::mod::GreedyClusterer::private_t>::__on_zero_shared(uint64_t a1)
{
  vision::mod::GreedyClustererWithTorso::private_t::clusters_t::~clusters_t((vision::mod::GreedyClustererWithTorso::private_t::clusters_t *)(a1 + 72));
  if (*(char *)(a1 + 71) < 0)
    operator delete(*(void **)(a1 + 48));
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
}

void std::__shared_ptr_emplace<vision::mod::GreedyClustererFaces>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453B648;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<vision::mod::GreedyClustererFaces>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453B648;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A1B0A898);
}

uint64_t std::__shared_ptr_emplace<vision::mod::GreedyClustererFaces>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t vision::mod::GreedyClustererFaces::pasreAndVerifyClustererState(uint64_t a1, uint64_t a2, std::string *a3, std::string *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  std::string *p_str;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  std::string *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  std::string *v30;
  void **v31;
  std::string *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t *v39;
  const __CFString *v40;
  uint64_t v41;
  std::string::size_type v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  std::string *v50;
  std::string *v51;
  uint64_t v52;
  std::string v53;
  size_t __len;
  void *__p[2];
  char v56;
  std::string __str;

  if (*(_DWORD *)a2 != -1052410331)
  {
    v40 = CFSTR("  Clusterer - couldn't find sanity value\n");
LABEL_25:
    VNValidatedLog(4, (uint64_t)v40, (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v52);
    v41 = -2;
    return (v41 + 128) | 0x1400;
  }
  if (*(_DWORD *)(a2 + 4) != 10004)
  {
    v52 = *(unsigned int *)(a2 + 4);
    v40 = CFSTR("  Clusterer - versions mismatch (serialized: %d, current: %d");
    goto LABEL_25;
  }
  std::string::basic_string[abi:ne180100]<0>(__p, (char *)(a2 + 44));
  createFullPath(&__str, a1, (uint64_t)__p);
  if (v56 < 0)
    operator delete(__p[0]);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_str = &__str;
  else
    p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
  v20 = verifyChecksumMD5ForFile((const char *)p_str, (_QWORD *)(a2 + 24));
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v21 = &__str;
  else
    v21 = (std::string *)__str.__r_.__value_.__r.__words[0];
  if ((v20 & 1) != 0)
  {
    v28 = open((const char *)v21, 0);
    v29 = SHIBYTE(__str.__r_.__value_.__r.__words[2]);
    if (v28 != -1)
    {
      v30 = (std::string *)__str.__r_.__value_.__r.__words[0];
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v30 = &__str;
      VNValidatedLog(1, (uint64_t)CFSTR("  GreedyClustererFaces: Opening '%s'"), v22, v23, v24, v25, v26, v27, (uint64_t)v30);
      __len = 0;
      read(v28, &__len, 8uLL);
      std::string::basic_string[abi:ne180100](__p, __len, 48);
      if (v56 >= 0)
        v31 = __p;
      else
        v31 = (void **)__p[0];
      read(v28, v31, __len);
      createFullPath(&v53, a1, (uint64_t)__p);
      if ((v53.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v32 = &v53;
      else
        v32 = (std::string *)v53.__r_.__value_.__r.__words[0];
      if ((verifyChecksumMD5ForFile((const char *)v32, (_QWORD *)(a2 + 8)) & 1) != 0)
      {
        *a5 = v28;
        lseek(v28, 0, 0);
        std::string::operator=(a3, &__str);
        std::string::operator=(a4, &v53);
        v39 = &CVML_status_ok;
      }
      else
      {
        v51 = &v53;
        if ((v53.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v51 = (std::string *)v53.__r_.__value_.__r.__words[0];
        VNValidatedLog(4, (uint64_t)CFSTR("  Clusterer - data checksum mismatch for file: %s"), v33, v34, v35, v36, v37, v38, (uint64_t)v51);
        close(v28);
        v39 = &CVML_status_internalError;
      }
      v41 = *v39;
      if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v53.__r_.__value_.__l.__data_);
      if (v56 < 0)
        operator delete(__p[0]);
      goto LABEL_39;
    }
    v43 = __str.__r_.__value_.__r.__words[0];
    __error();
    v50 = &__str;
    if (v29 < 0)
      v50 = (std::string *)v43;
    VNValidatedLog(4, (uint64_t)CFSTR("  GreedyClustererFaces: Failed to open '%s': errno=%d"), v44, v45, v46, v47, v48, v49, (uint64_t)v50);
  }
  else
  {
    VNValidatedLog(4, (uint64_t)CFSTR("  Clusterer - data checksum mismatch for file: %s"), v14, v15, v16, v17, v18, v19, (uint64_t)v21);
  }
  v41 = -2;
LABEL_39:
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  return (v41 + 128) | 0x1400;
}

void sub_1A155DA8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a23 < 0)
    operator delete(__p);
  if (a29 < 0)
    operator delete(a24);
  _Unwind_Resume(exception_object);
}

void sub_1A155DB9C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A155DCD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_1A155DD9C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A155DF34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;
  void *v15;
  uint64_t v16;

  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](v16 - 48);
  _Unwind_Resume(a1);
}

void sub_1A155E07C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A155E18C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A155E200(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A155E2E8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A155E3A0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A155E428(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A155E5E8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_1A155E68C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A155E6DC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A155E720(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL _addRelationshipsToHierarchicalModel(uint64_t **a1, void *a2, _QWORD *a3)
{
  id v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t *v9;
  _BOOL8 v10;
  uint64_t v11;
  void *v12;
  std::string *v13;
  void *v14;
  void *v15;
  std::string v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v5 = a2;
  if (objc_msgSend(v5, "count"))
  {
    v18 = 0;
    v19 = 0;
    v20 = 0;
    +[VNEspressoModelClassifier convertRelationships:toStdRelationships:](VNEspressoModelClassifier, "convertRelationships:toStdRelationships:", v5, &v18);
    memset(&v17, 0, sizeof(v17));
    v6 = v18;
    v7 = v19;
    v8 = &CVML_status_ok;
    while (v6 != v7)
    {
      v9 = *a1;
      if (!std::__hash_table<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,vision::mod::ImageClassfier_GraphNode *>>>::find<std::string>(*a1, (unsigned __int8 *)v6))
      {
        std::string::operator=(&v17, (const std::string *)v6);
        v8 = &CVML_status_invalidParameter;
        break;
      }
      vision::mod::ImageClassfier_Graph::addParentChildRelation(v9, (__int128 *)v6, (__int128 *)(v6 + 24));
      v6 += 48;
    }
    v11 = (*(_DWORD *)v8 + 0x80);
    v10 = v11 == 128;
    if (a3 && v11 != 128)
    {
      v12 = (void *)MEMORY[0x1E0CB3940];
      if ((v17.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v13 = &v17;
      else
        v13 = (std::string *)v17.__r_.__value_.__r.__words[0];
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v13, 4);
      v14 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v12, "stringWithFormat:", CFSTR("The classification identifier '%@' does not exist in the hierarchy"), v14);
      v15 = (void *)objc_claimAutoreleasedReturnValue();

      +[VNError errorWithCode:message:](VNError, "errorWithCode:message:", 14, v15);
      *a3 = (id)objc_claimAutoreleasedReturnValue();

    }
    if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v17.__r_.__value_.__l.__data_);
    v17.__r_.__value_.__r.__words[0] = (std::string::size_type)&v18;
    std::vector<std::pair<std::string,std::string>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v17);
  }
  else
  {
    v10 = 1;
  }

  return v10;
}

void sub_1A155E900(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  void *v17;

  if (a16 < 0)
    operator delete(__p);
  __p = &a17;
  std::vector<std::pair<std::string,std::string>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);

  _Unwind_Resume(a1);
}

void sub_1A155E9D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void sub_1A155EBEC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void VNNSDataStreambuf::~VNNSDataStreambuf(id *this)
{

  std::streambuf::~streambuf();
}

{

  std::streambuf::~streambuf();
  JUMPOUT(0x1A1B0A898);
}

uint64_t VNNSDataStreambuf::underflow(VNNSDataStreambuf *this)
{
  return 0xFFFFFFFFLL;
}

void VNNSMutableDataStreambuf::~VNNSMutableDataStreambuf(id *this)
{

  std::streambuf::~streambuf();
}

{

  std::streambuf::~streambuf();
  JUMPOUT(0x1A1B0A898);
}

uint64_t VNNSMutableDataStreambuf::overflow(id *this, int a2)
{
  unsigned __int8 v2;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;

  if (a2 == -1)
    return 0;
  v2 = a2;
  v4 = objc_msgSend(this[8], "length");
  v5 = (unint64_t)this[10];
  if (v5 >= v4)
  {
    objc_msgSend(this[8], "setLength:", (v5 & 0xFFFFFFFFFFFFFFE0) + 32);
    v6 = objc_msgSend(this[8], "mutableBytes");
    this[9] = (id)v6;
    if (v6)
      goto LABEL_4;
  }
  else
  {
    v6 = (uint64_t)this[9];
    if (v6)
    {
LABEL_4:
      *((_BYTE *)this[10] + v6) = v2;
      this[10] = (char *)this[10] + 1;
      return v2;
    }
  }
  return 0xFFFFFFFFLL;
}

void VNNSDataStreambuf::VNNSDataStreambuf(VNNSDataStreambuf *this, NSData *a2)
{
  NSData *v3;
  NSData *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = a2;
  std::streambuf::basic_streambuf();
  *(_QWORD *)this = &off_1E4539E48;
  v4 = v3;
  *((_QWORD *)this + 8) = v4;
  v5 = -[NSData bytes](v4, "bytes");
  v6 = objc_msgSend(*((id *)this + 8), "length");
  *((_QWORD *)this + 2) = v5;
  *((_QWORD *)this + 3) = v5;
  *((_QWORD *)this + 4) = v5 + v6;

}

void sub_1A155EE10(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;

  std::streambuf::~streambuf();
  _Unwind_Resume(a1);
}

void VNNSMutableDataStreambuf::VNNSMutableDataStreambuf(VNNSMutableDataStreambuf *this)
{
  _QWORD *v2;
  uint64_t v3;
  void *v4;

  v2 = (_QWORD *)std::streambuf::basic_streambuf();
  *v2 = &off_1E4539EC8;
  v2[9] = 0;
  v2[10] = 0;
  v2[8] = 0;
  v3 = objc_msgSend(objc_alloc(MEMORY[0x1E0C99DF0]), "initWithCapacity:", 1024);
  v4 = (void *)*((_QWORD *)this + 8);
  *((_QWORD *)this + 8) = v3;

}

void sub_1A155EE94(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::streambuf::~streambuf();
  _Unwind_Resume(a1);
}

void sub_1A155F858(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A155F92C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A155FA74(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A155FD8C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1A155FF04(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A1560018(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1560158(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1560364(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1A15605E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, void *a12)
{
  void *v12;

  _Unwind_Resume(a1);
}

void sub_1A1560780(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A1560960(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A1560A40(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1560AE0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1560CE0(void *a1)
{
  objc_begin_catch(a1);
  JUMPOUT(0x1A1560CB4);
}

void sub_1A1560DCC(void *a1)
{
  objc_begin_catch(a1);
  JUMPOUT(0x1A1560DA4);
}

void sub_1A1560DD8(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A1560EA4(void *a1)
{
  objc_begin_catch(a1);
  JUMPOUT(0x1A1560E64);
}

void sub_1A1560EB0(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A1560F78(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A1560F98(void *a1)
{
  objc_begin_catch(a1);
  JUMPOUT(0x1A1560F58);
}

void sub_1A1561004(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1561128(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A15611A8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1561344(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1561474(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A15615B4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A1561730(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1A1561808(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15618A8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1561944(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1561A7C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A1561C44(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A1561D80(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A1561F10(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A1561FD4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A156209C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A1562174(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A156225C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A15623A8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A15624EC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A15627C4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A15628D8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A1562AA4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A1562BE8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A1562FB8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A15630CC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t tplTrackerResampler_lumaDownscale8N(_QWORD *a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7)
{
  unint64_t v13;
  double v14;
  uint64_t result;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned __int8 *v26;
  unsigned int v27;
  unsigned __int8 *v28;
  unint64_t v29;
  int v30;

  if (!a6)
    return 6780;
  v13 = 8 * a6;
  v14 = log2((double)(v13 * v13));
  if (v13 > a5)
    return 6784;
  v16 = 0;
  v17 = 0;
  v18 = v14;
  v19 = *a1 + a2 + a1[3] * a3;
  if (a4 / v13 <= 1)
    v20 = 1;
  else
    v20 = a4 / v13;
  v21 = a5 / v13;
  if (a5 / v13 <= 1)
    v21 = 1;
  result = 6784;
  do
  {
    if (v13 <= a4)
    {
      v22 = 0;
      v23 = v19;
      do
      {
        v24 = 0;
        v25 = a1[3];
        v26 = (unsigned __int8 *)(v23 + v16 * v25);
        v27 = 1 << v18 >> 1;
        do
        {
          v28 = v26;
          v29 = v13;
          do
          {
            v30 = *v28++;
            v27 += v30;
            --v29;
          }
          while (v29);
          ++v24;
          v26 += v25;
        }
        while (v24 != v13);
        *(_BYTE *)(a7 + v22++) = v27 >> v18;
        v23 += v13;
      }
      while (v22 != v20);
    }
    a7 += a4 / v13;
    ++v17;
    v16 += v13;
  }
  while (v17 != v21);
  return result;
}

uint64_t tplTrackerResampler_chromaDownscale8N(_QWORD *a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v16;
  double v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  unsigned int v33;
  uint64_t v34;
  unint64_t v35;

  if (!a6)
    return 6780;
  v16 = 8 * a6;
  v17 = log2((double)(v16 * v16));
  if (v16 > a5)
    return 6784;
  v19 = 0;
  v20 = 0;
  v21 = a4 / v16;
  v22 = v17;
  v23 = *a1 + a1[3] * a3 + 2 * a2;
  if (a4 / v16 <= 1)
    v24 = 1;
  else
    v24 = a4 / v16;
  v25 = a5 / v16;
  if (a5 / v16 <= 1)
    v25 = 1;
  v26 = 16 * a6;
  result = 6784;
  do
  {
    if (v16 <= a4)
    {
      v27 = 0;
      v28 = v23;
      do
      {
        v29 = 0;
        v30 = a1[3];
        v31 = v28 + v19 * v30;
        v32 = 1 << v22 >> 1;
        v33 = v32;
        do
        {
          v34 = 0;
          v35 = v16;
          do
          {
            v33 += *(unsigned __int8 *)(v31 + v34);
            v32 += *(unsigned __int8 *)(v31 + v34 + 1);
            v34 += 2;
            --v35;
          }
          while (v35);
          ++v29;
          v31 += v30;
        }
        while (v29 != v16);
        *(_BYTE *)(a7 + v27) = v33 >> v22;
        *(_BYTE *)(a8 + v27++) = v32 >> v22;
        v28 += v26;
      }
      while (v27 != v24);
    }
    a7 += v21;
    a8 += v21;
    ++v20;
    v19 += v16;
  }
  while (v20 != v25);
  return result;
}

uint64_t revertSegmentCoordinateSystem(uint64_t result, int a2, int a3)
{
  _DWORD *v3;
  _WORD *v4;
  int v5;
  int v6;
  _WORD *v7;
  unint64_t v8;
  float v9;
  float v10;
  float v11;
  float v12;

  v3 = *(_DWORD **)(result + 40);
  if ((a3 & 0x10000) != 0 && a2 >= 1)
  {
    v4 = (_WORD *)v3 + 1;
    v5 = a2;
    do
    {
      *v4 = -*v4;
      v4 += 2;
      --v5;
    }
    while (v5);
  }
  if ((a3 & 0x100) != 0 && a2 >= 1)
  {
    v6 = a2;
    v7 = v3;
    do
    {
      *v7 = -*v7;
      v7 += 2;
      --v6;
    }
    while (v6);
  }
  if ((a3 & 1) != 0 && a2 >= 1)
  {
    do
    {
      HIDWORD(v8) = *v3;
      LODWORD(v8) = *v3;
      *v3++ = v8 >> 16;
      --a2;
    }
    while (a2);
  }
  v9 = *(float *)(result + 20);
  v10 = *(float *)(result + 24);
  v11 = *(float *)(result + 28);
  if ((*(_QWORD *)&a3 & 0x10000) != 0)
  {
    v11 = -v11;
    v9 = -v9;
  }
  if ((a3 & 0x100) != 0)
  {
    v11 = -v11;
    v10 = -v10;
  }
  if ((a3 & 1) != 0)
    v12 = v9;
  else
    v12 = v10;
  if ((a3 & 1) != 0)
    v9 = v10;
  *(float *)(result + 20) = v9;
  *(float *)(result + 24) = v12;
  *(float *)(result + 28) = v11;
  return result;
}

unsigned __int16 *findDiff(unsigned __int16 *result, int a2, char a3, _WORD *a4, _WORD *a5)
{
  int v5;
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  int v9;
  unsigned __int16 *v10;
  uint64_t v11;
  int v12;
  unsigned __int16 *v13;
  uint64_t v14;
  int v15;
  __int16 v16;
  unsigned __int16 *v17;
  uint64_t v18;
  int v19;
  __int16 v20;

  v5 = *result;
  v6 = result[1];
  if ((a3 & 1) != 0)
  {
    if (a2 < 2)
    {
      LODWORD(v8) = 1;
    }
    else
    {
      v7 = result + 2;
      v8 = 1;
      while (1)
      {
        v9 = *v7;
        v7 += 2;
        if (v5 != v9)
          break;
        if (a2 == ++v8)
        {
          LODWORD(v8) = a2;
          break;
        }
      }
    }
    if ((_DWORD)v8 == a2)
      LOWORD(v8) = 0;
    *a4 = v8;
    if ((a3 & 2) == 0)
    {
LABEL_3:
      if (!a5)
        return result;
      goto LABEL_23;
    }
  }
  else if ((a3 & 2) == 0)
  {
    goto LABEL_3;
  }
  if (a2 < 2)
  {
    LODWORD(v11) = 1;
  }
  else
  {
    v10 = result + 3;
    v11 = 1;
    while (1)
    {
      v12 = *v10;
      v10 += 2;
      if (v6 != v12)
        break;
      if (a2 == ++v11)
      {
        LODWORD(v11) = a2;
        break;
      }
    }
  }
  if ((_DWORD)v11 == a2)
    LOWORD(v11) = 0;
  a4[1] = v11;
  if (a5)
  {
LABEL_23:
    if ((a3 & 1) != 0)
    {
      if (a2 < 2)
      {
        LODWORD(v14) = 1;
      }
      else
      {
        v13 = &result[2 * a2 - 2];
        v14 = 1;
        while (1)
        {
          v15 = *v13;
          v13 -= 2;
          if (v5 != v15)
            break;
          if (a2 == ++v14)
          {
            LODWORD(v14) = a2;
            break;
          }
        }
      }
      v16 = v14 - 1;
      if ((_DWORD)v14 == a2)
        v16 = 0;
      *a5 = v16;
    }
    if ((a3 & 2) != 0)
    {
      if (a2 < 2)
      {
        LODWORD(v18) = 1;
      }
      else
      {
        v17 = &result[2 * a2 - 1];
        v18 = 1;
        while (1)
        {
          v19 = *v17;
          v17 -= 2;
          if (v6 != v19)
            break;
          if (a2 == ++v18)
          {
            LODWORD(v18) = a2;
            break;
          }
        }
      }
      v20 = v18 - 1;
      if ((_DWORD)v18 == a2)
        v20 = 0;
      a5[1] = v20;
    }
  }
  return result;
}

void splitSegmentIntoStraightSegments(uint64_t *a1, uint64_t a2, unint64_t a3, int *a4, float a5)
{
  int v5;
  int v8;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  unsigned int v13;
  uint64_t v14;
  __int16 *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  float v19;
  int v20;
  int v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  float v25;
  int v26;
  int v27;
  uint64_t *v28;
  int v29;
  unint64_t v30;
  float v31;
  int v32;
  int v33;

  v5 = *((_DWORD *)a1 + 3);
  if (v5 >= 6)
  {
    v8 = a3;
    v10 = a1;
    v11 = a1[5];
    v12 = HIDWORD(a3);
    if (SHIDWORD(a3) <= 1)
      LODWORD(v12) = 1;
    if ((int)v12 >= v5 - 2)
      v13 = v5 - 2;
    else
      v13 = v12;
    v14 = allocSegments(a4, 1);
    *(_QWORD *)v14 = *v10;
    *v10 = v14;
    *(_DWORD *)(v14 + 12) = v5 - v13;
    v15 = (__int16 *)(v11 + 4 * v13);
    *(_QWORD *)(v14 + 40) = v15;
    *((_DWORD *)v10 + 3) = v13 + 1;
    v16 = straightLineWLSQ((__int16 *)v10[5], v13 + 1);
    v18 = v17;
    v19 = *(float *)&v17;
    *((float *)v10 + 5) = Lsq2Leq(a2);
    *((_DWORD *)v10 + 6) = v20;
    *((_DWORD *)v10 + 7) = v21;
    *((_DWORD *)v10 + 4) = v8;
    if (v19 > a5)
    {
      splitSegmentIntoStraightSegments(v10, v16, v18, a4, a5);
      v15 = *(__int16 **)(v14 + 40);
    }
    v22 = straightLineWLSQ(v15, *(_DWORD *)(v14 + 12));
    v24 = v23;
    v25 = *(float *)&v23;
    *(float *)(v14 + 20) = Lsq2Leq(v22);
    *(_DWORD *)(v14 + 24) = v26;
    *(_DWORD *)(v14 + 28) = v27;
    *(_DWORD *)(v14 + 16) = v24;
    if (v25 > a5)
      splitSegmentIntoStraightSegments(v14, v22, v24, a4, a5);
    do
    {
      v28 = v10;
      v10 = (uint64_t *)*v10;
    }
    while (v10 != (uint64_t *)v14);
    v29 = *((_DWORD *)v28 + 3) + *(_DWORD *)(v14 + 12) - 1;
    v30 = straightLineWLSQ((__int16 *)v28[5], v29);
    if (v31 <= a5)
    {
      *((_DWORD *)v28 + 3) = v29;
      *((float *)v28 + 4) = v31;
      *((float *)v28 + 5) = Lsq2Leq(v30);
      *((_DWORD *)v28 + 6) = v32;
      *((_DWORD *)v28 + 7) = v33;
      *v28 = *(_QWORD *)v14;
      *(_BYTE *)(v14 + 8) = 0;
    }
  }
}

uint64_t mergeSegments(float *a1, uint64_t a2, float a3)
{
  uint64_t v4;
  uint64_t v6;
  float *v7;
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  __int16 *v12;
  float v13;
  float v14;
  float v15;
  float *v16;
  uint64_t v17;
  float *v18;
  int v19;
  int v20;
  __int16 *v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  int v28;
  int v29;
  int v30;
  uint64_t *v31;
  float *v32;
  float v33;
  float v34;
  int v35;
  _QWORD v38[2];

  v4 = a2;
  v38[1] = *MEMORY[0x1E0C80C00];
  v38[0] = (a2 - 1);
  MEMORY[0x1E0C80A78](a1);
  v7 = (float *)((char *)v38 - v6);
  if (v8 < 2)
    return v4;
  v9 = 0;
  do
  {
    v10 = (v4 - 2);
    if ((int)v4 < 2)
      return v4;
    v11 = v4 - 1;
    v12 = (__int16 *)*((_QWORD *)a1 + 5);
    v13 = a1[5];
    v14 = a1[6];
    v15 = a1[7];
    v16 = v7;
    v17 = (v4 - 1);
    v18 = a1;
    do
    {
      v18 = *(float **)v18;
      v19 = *v12;
      v20 = v12[1];
      v12 = (__int16 *)*((_QWORD *)v18 + 5);
      v21 = &v12[2 * *((int *)v18 + 3)];
      v22 = (float)(v14 * (float)*(v21 - 1)) + (float)(v13 * (float)*(v21 - 2));
      v23 = v18[5];
      v14 = v18[6];
      v24 = v15 + v22;
      v25 = v18[7];
      v26 = fabsf(v24);
      v27 = fabsf(v25 + (float)((float)(v14 * (float)v20) + (float)(v23 * (float)v19)));
      if (v26 <= v27)
        v26 = v27;
      *v16++ = v26;
      v15 = v25;
      v13 = v23;
      --v17;
    }
    while (v17);
    v28 = 0;
    v29 = 0;
    v30 = 1;
    v31 = (uint64_t *)a1;
    while (v28 != (_DWORD)v10)
    {
      v32 = &v7[v28];
      v33 = v32[1];
      if (*v32 > v33)
        v34 = v32[1];
      else
        v34 = *v32;
      if (v34 > a3)
      {
        v31 = (uint64_t *)*v31;
LABEL_20:
        v35 = 2;
        goto LABEL_21;
      }
      ++v29;
      if (*v32 <= v33)
      {
        mergeSegment(v31);
        goto LABEL_20;
      }
      mergeSegment((uint64_t *)*v31);
      v31 = (uint64_t *)*v31;
      v35 = 3;
LABEL_21:
      v31 = (uint64_t *)*v31;
      v28 += v35;
LABEL_22:
      if (v28 < v11 && v30++ < v11)
        continue;
      goto LABEL_26;
    }
    if (v7[v10] > a3)
    {
      v31 = 0;
      v28 = v4;
      goto LABEL_22;
    }
    ++v29;
    mergeSegment(v31);
LABEL_26:
    v4 = (v4 - v29);
    if (!v29)
      break;
    if ((_DWORD)v4 == 1)
      break;
    ++v9;
  }
  while (v9 != LODWORD(v38[0]));
  return v4;
}

void mergeSegment(uint64_t *a1)
{
  uint64_t *v1;
  int v3;
  unint64_t v4;
  int v5;
  int v6;
  int v7;

  v1 = (uint64_t *)*a1;
  if (!*a1)
    __assert_rtn("mergeSegment", "SegmentUtilities.c", 453, "sPtr2 != NULL");
  v3 = *((_DWORD *)a1 + 3) + *((_DWORD *)v1 + 3) - 1;
  *((_DWORD *)a1 + 3) = v3;
  *a1 = *v1;
  *((_BYTE *)v1 + 8) = 0;
  v4 = straightLineLSQ((__int16 *)a1[5], v3);
  *((_DWORD *)a1 + 4) = v5;
  *((float *)a1 + 5) = Lsq2Leq(v4);
  *((_DWORD *)a1 + 6) = v6;
  *((_DWORD *)a1 + 7) = v7;
}

void sub_1A1563C2C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A1563D84(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A1564B3C(_Unwind_Exception *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x1A1564AD4);
  }
  _Unwind_Resume(exc_buf);
}

void sub_1A1565B20(_Unwind_Exception *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x1A1565AB8);
  }
  _Unwind_Resume(exc_buf);
}

void sub_1A15662F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A1566378(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1566488(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1A15664E8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1566534(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A156660C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A15666A8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15666F8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15667D8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A15668AC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1566950(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1566A18(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1566E74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12, void *a13, void *a14)
{
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

void sub_1A1567194(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A15672D4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1567394(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1567444(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15674F8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15675AC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15676AC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A15677C0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A15678E4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1567A24(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A1567CAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11)
{
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;

  _Unwind_Resume(a1);
}

void sub_1A1567D9C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1567DE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A1567EDC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1567F20(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1567F6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A1567FB4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1568000(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A156812C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A156824C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1568500(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1A15686B8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15687DC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1568C18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

void sub_1A1569088(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12)
{
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

void sub_1A15695A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, void *a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,void *a27)
{
  void *v27;
  void *v28;
  void *v29;
  void *v30;

  _Unwind_Resume(a1);
}

void sub_1A15697B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A1569B68(void *a1)
{
  objc_begin_catch(a1);
  JUMPOUT(0x1A15699E0);
}

void sub_1A1569B9C()
{
  int v0;

  if (v0)
    JUMPOUT(0x1A1569BA4);
  JUMPOUT(0x1A1569BA8);
}

void *lockedPixelBufferToImageBuffer<Pixel_UHVH>(_QWORD *a1, CVPixelBufferRef pixelBuffer)
{
  size_t Width;
  size_t Height;
  size_t BytesPerRow;
  void *result;

  Width = CVPixelBufferGetWidth(pixelBuffer);
  Height = CVPixelBufferGetHeight(pixelBuffer);
  BytesPerRow = CVPixelBufferGetBytesPerRow(pixelBuffer);
  result = CVPixelBufferGetBaseAddress(pixelBuffer);
  *a1 = result;
  a1[1] = Height;
  a1[2] = Width;
  a1[3] = BytesPerRow;
  return result;
}

uint64_t ___Z21convertAndResizeImageI10Pixel_UFVFS0_EvRKN5apple6vision11ImageBufferIT_S4_EERKNS3_IT0_S8_EE_block_invoke(uint64_t result, unint64_t a2)
{
  float v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  float v6;
  uint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float *v13;
  float v14;
  float v15;
  signed int v16;
  uint64_t v17;
  float *v18;
  float *v19;
  float *v20;
  float *v21;
  float v22;
  float v23;
  float v24;
  float v25;

  v2 = *(float *)(result + 72) * (float)a2;
  v3 = (int)vcvtms_s32_f32(v2);
  v4 = *(_QWORD *)(result + 32);
  if (v4 >= v3 + 1)
    v4 = v3 + 1;
  v5 = *(_QWORD *)(result + 56);
  if (v5 >= 1)
  {
    v6 = v2 - floorf(v2);
    v7 = *(uint64_t **)(result + 40);
    v8 = (unint64_t)v7[3] >> 3;
    v9 = *v7;
    v10 = v9 + 8 * v8 * v3;
    v11 = v9 + 8 * v4 * v8;
    v12 = *(_QWORD *)(result + 64);
    v13 = (float *)(**(_QWORD **)(result + 48) + 8 * a2 * (*(_QWORD *)(*(_QWORD *)(result + 48) + 24) >> 3) + 4);
    v14 = 0.0;
    do
    {
      v15 = v14 - floorf(v14);
      v16 = vcvtms_s32_f32(v14);
      if (v12 >= v16 + 1)
        v17 = v16 + 1;
      else
        v17 = v12;
      v18 = (float *)(v10 + 8 * v16);
      v19 = (float *)(v10 + 8 * v17);
      v20 = (float *)(v11 + 8 * v16);
      v21 = (float *)(v11 + 8 * v17);
      v22 = *v18 + (float)(v15 * (float)(*v19 - *v18));
      v23 = v20[1];
      v24 = v21[1];
      v25 = v18[1] + (float)(v15 * (float)(v19[1] - v18[1]));
      *(v13 - 1) = (float)(v22 + (float)(v6 * (float)((float)(*v20 + (float)(v15 * (float)(*v21 - *v20))) - v22)))
                 * *(float *)(result + 80);
      *v13 = *(float *)(result + 84)
           * (float)(v25 + (float)(v6 * (float)((float)(v23 + (float)(v15 * (float)(v24 - v23))) - v25)));
      v13 += 2;
      v14 = v14 + *(float *)(result + 76);
      --v5;
    }
    while (v5);
  }
  return result;
}

uint64_t ___Z21convertAndResizeImageI10Pixel_UFVF10Pixel_UHVHEvRKN5apple6vision11ImageBufferIT_S5_EERKNS4_IT0_S9_EE_block_invoke(uint64_t result, unint64_t a2)
{
  float v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  float v6;
  uint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float v13;
  float v14;
  float v15;
  _WORD *v16;
  float v17;
  signed int v18;
  float v19;
  uint64_t v20;
  float *v21;
  float *v22;
  float *v23;
  float *v24;
  float v25;
  float v26;
  float v27;
  float v28;

  v2 = *(float *)(result + 72) * (float)a2;
  v3 = (int)vcvtms_s32_f32(v2);
  v4 = *(_QWORD *)(result + 32);
  if (v4 >= v3 + 1)
    v4 = v3 + 1;
  v5 = *(_QWORD *)(result + 56);
  if (v5 >= 1)
  {
    v6 = v2 - floorf(v2);
    v7 = *(uint64_t **)(result + 40);
    v8 = (unint64_t)v7[3] >> 3;
    v9 = *v7;
    v10 = v9 + 8 * v8 * v3;
    v11 = v9 + 8 * v4 * v8;
    v12 = *(_QWORD *)(result + 64);
    v14 = *(float *)(result + 80);
    v13 = *(float *)(result + 84);
    v15 = *(float *)(result + 76);
    v16 = (_WORD *)(**(_QWORD **)(result + 48) + 4 * a2 * (*(_QWORD *)(*(_QWORD *)(result + 48) + 24) >> 2) + 2);
    v17 = 0.0;
    do
    {
      v18 = vcvtms_s32_f32(v17);
      v19 = v17 - floorf(v17);
      if (v12 >= v18 + 1)
        v20 = v18 + 1;
      else
        v20 = v12;
      v21 = (float *)(v10 + 8 * v18);
      v22 = (float *)(v11 + 8 * v18);
      v23 = (float *)(v10 + 8 * v20);
      v24 = (float *)(v11 + 8 * v20);
      v25 = v22[1];
      v26 = v24[1];
      v27 = *v21 + (float)(v19 * (float)(*v23 - *v21));
      v28 = v21[1] + (float)(v19 * (float)(v23[1] - v21[1]));
      _S6 = (float)(v27 + (float)(v6 * (float)((float)(*v22 + (float)(v19 * (float)(*v24 - *v22))) - v27))) * v14;
      __asm { FCVT            H6, S6 }
      *(v16 - 1) = LOWORD(_S6);
      _S5 = v13 * (float)(v28 + (float)(v6 * (float)((float)(v25 + (float)(v19 * (float)(v26 - v25))) - v28)));
      __asm { FCVT            H5, S5 }
      *v16 = LOWORD(_S5);
      v17 = v17 + v15;
      v16 += 2;
      --v5;
    }
    while (v5);
  }
  return result;
}

uint64_t ___Z21convertAndResizeImageI10Pixel_UHVH10Pixel_UFVFEvRKN5apple6vision11ImageBufferIT_S5_EERKNS4_IT0_S9_EE_block_invoke(uint64_t result, unint64_t a2)
{
  float v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  float v6;
  uint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float *v13;
  float v14;
  float v15;
  signed int v16;
  uint64_t v17;
  __int16 *v18;
  __int16 *v19;
  _WORD *v20;
  __int16 *v21;
  float v30;
  float v34;
  float v37;

  v2 = *(float *)(result + 72) * (float)a2;
  v3 = (int)vcvtms_s32_f32(v2);
  v4 = *(_QWORD *)(result + 32);
  if (v4 >= v3 + 1)
    v4 = v3 + 1;
  v5 = *(_QWORD *)(result + 56);
  if (v5 >= 1)
  {
    v6 = v2 - floorf(v2);
    v7 = *(uint64_t **)(result + 40);
    v8 = (unint64_t)v7[3] >> 2;
    v9 = *v7;
    v10 = v9 + 4 * v8 * v3;
    v11 = v9 + 4 * v4 * v8;
    v12 = *(_QWORD *)(result + 64);
    v13 = (float *)(**(_QWORD **)(result + 48) + 8 * a2 * (*(_QWORD *)(*(_QWORD *)(result + 48) + 24) >> 3) + 4);
    v14 = 0.0;
    do
    {
      v15 = v14 - floorf(v14);
      v16 = vcvtms_s32_f32(v14);
      if (v12 >= v16 + 1)
        v17 = v16 + 1;
      else
        v17 = v12;
      v18 = (__int16 *)(v10 + 4 * v16);
      v19 = (__int16 *)(v10 + 4 * v17);
      v20 = (_WORD *)(v11 + 4 * v16);
      v21 = (__int16 *)(v11 + 4 * v17);
      _H3 = *v18;
      __asm { FCVT            S3, H3 }
      _H4 = *v19;
      __asm { FCVT            S4, H4 }
      v30 = _S3 + (float)(v15 * (float)(_S4 - _S3));
      LOWORD(_S4) = *v20;
      __asm { FCVT            S4, H4 }
      _H5 = *v21;
      __asm { FCVT            S5, H5 }
      v34 = v30 + (float)(v6 * (float)((float)(_S4 + (float)(v15 * (float)(_S5 - _S4))) - v30));
      LOWORD(_S4) = v18[1];
      __asm { FCVT            S4, H4 }
      LOWORD(_S5) = v19[1];
      __asm { FCVT            S5, H5 }
      v37 = _S4 + (float)(v15 * (float)(_S5 - _S4));
      LOWORD(_S5) = v20[1];
      __asm { FCVT            S5, H5 }
      _H6 = v21[1];
      __asm { FCVT            S6, H6 }
      *(v13 - 1) = v34 * *(float *)(result + 80);
      *v13 = *(float *)(result + 84)
           * (float)(v37 + (float)(v6 * (float)((float)(_S5 + (float)(v15 * (float)(_S6 - _S5))) - v37)));
      v13 += 2;
      v14 = v14 + *(float *)(result + 76);
      --v5;
    }
    while (v5);
  }
  return result;
}

uint64_t ___Z21convertAndResizeImageI10Pixel_UHVHS0_EvRKN5apple6vision11ImageBufferIT_S4_EERKNS3_IT0_S8_EE_block_invoke(uint64_t result, unint64_t a2)
{
  float v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  float v6;
  uint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float v13;
  float v14;
  float v15;
  _WORD *v16;
  float v17;
  signed int v18;
  float v19;
  uint64_t v20;
  __int16 *v21;
  __int16 *v22;
  __int16 *v23;
  __int16 *v24;
  float v34;
  float v39;
  float v43;

  v2 = *(float *)(result + 72) * (float)a2;
  v3 = (int)vcvtms_s32_f32(v2);
  v4 = *(_QWORD *)(result + 32);
  if (v4 >= v3 + 1)
    v4 = v3 + 1;
  v5 = *(_QWORD *)(result + 56);
  if (v5 >= 1)
  {
    v6 = v2 - floorf(v2);
    v7 = *(uint64_t **)(result + 40);
    v8 = (unint64_t)v7[3] >> 2;
    v9 = *v7;
    v10 = v9 + 4 * v8 * v3;
    v11 = v9 + 4 * v4 * v8;
    v12 = *(_QWORD *)(result + 64);
    v14 = *(float *)(result + 80);
    v13 = *(float *)(result + 84);
    v15 = *(float *)(result + 76);
    v16 = (_WORD *)(**(_QWORD **)(result + 48) + 4 * a2 * (*(_QWORD *)(*(_QWORD *)(result + 48) + 24) >> 2) + 2);
    v17 = 0.0;
    do
    {
      v18 = vcvtms_s32_f32(v17);
      v19 = v17 - floorf(v17);
      if (v12 >= v18 + 1)
        v20 = v18 + 1;
      else
        v20 = v12;
      v21 = (__int16 *)(v10 + 4 * v18);
      v22 = (__int16 *)(v10 + 4 * v20);
      v23 = (__int16 *)(v11 + 4 * v18);
      v24 = (__int16 *)(v11 + 4 * v20);
      _H6 = *v21;
      __asm { FCVT            S6, H6 }
      _H7 = *v22;
      __asm { FCVT            S7, H7 }
      _H16 = *v23;
      v34 = _S6 + (float)(v19 * (float)(_S7 - _S6));
      __asm { FCVT            S7, H16 }
      _H16 = *v24;
      __asm { FCVT            S16, H16 }
      _H17 = v21[1];
      v39 = _S7 + (float)(v19 * (float)(_S16 - _S7));
      __asm { FCVT            S16, H17 }
      _H17 = v22[1];
      __asm { FCVT            S17, H17 }
      v43 = _S16 + (float)(v19 * (float)(_S17 - _S16));
      LOWORD(_S17) = v23[1];
      __asm { FCVT            S17, H17 }
      _H18 = v24[1];
      __asm { FCVT            S18, H18 }
      _S6 = (float)(v34 + (float)(v6 * (float)(v39 - v34))) * v14;
      __asm { FCVT            H6, S6 }
      *(v16 - 1) = LOWORD(_S6);
      _S5 = v13 * (float)(v43 + (float)(v6 * (float)((float)(_S17 + (float)(v19 * (float)(_S18 - _S17))) - v43)));
      __asm { FCVT            H5, S5 }
      *v16 = LOWORD(_S5);
      v17 = v17 + v15;
      v16 += 2;
      --v5;
    }
    while (v5);
  }
  return result;
}

void sub_1A156A238(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

id getVCPRequestFrameWidthPropertyKey(void)
{
  id *v0;
  void *v1;
  _Unwind_Exception *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (id *)getVCPRequestFrameWidthPropertyKeySymbolLoc(void)::ptr;
  v7 = getVCPRequestFrameWidthPropertyKeySymbolLoc(void)::ptr;
  if (!getVCPRequestFrameWidthPropertyKeySymbolLoc(void)::ptr)
  {
    v1 = (void *)VideoProcessingLibrary();
    v0 = (id *)dlsym(v1, "VCPRequestFrameWidthPropertyKey");
    v5[3] = (uint64_t)v0;
    getVCPRequestFrameWidthPropertyKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (!v0)
  {
    dlerror();
    v3 = (_Unwind_Exception *)abort_report_np();
    _Block_object_dispose(&v4, 8);
    _Unwind_Resume(v3);
  }
  return *v0;
}

id getVCPRequestFrameHeightPropertyKey(void)
{
  id *v0;
  void *v1;
  _Unwind_Exception *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (id *)getVCPRequestFrameHeightPropertyKeySymbolLoc(void)::ptr;
  v7 = getVCPRequestFrameHeightPropertyKeySymbolLoc(void)::ptr;
  if (!getVCPRequestFrameHeightPropertyKeySymbolLoc(void)::ptr)
  {
    v1 = (void *)VideoProcessingLibrary();
    v0 = (id *)dlsym(v1, "VCPRequestFrameHeightPropertyKey");
    v5[3] = (uint64_t)v0;
    getVCPRequestFrameHeightPropertyKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (!v0)
  {
    dlerror();
    v3 = (_Unwind_Exception *)abort_report_np();
    _Block_object_dispose(&v4, 8);
    _Unwind_Resume(v3);
  }
  return *v0;
}

id getVCPRequestMotionFlowComputationAccuracyPropertyKey(void)
{
  id *v0;
  void *v1;
  _Unwind_Exception *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (id *)getVCPRequestMotionFlowComputationAccuracyPropertyKeySymbolLoc(void)::ptr;
  v7 = getVCPRequestMotionFlowComputationAccuracyPropertyKeySymbolLoc(void)::ptr;
  if (!getVCPRequestMotionFlowComputationAccuracyPropertyKeySymbolLoc(void)::ptr)
  {
    v1 = (void *)MediaAnalysisLibrary();
    v0 = (id *)dlsym(v1, "VCPRequestMotionFlowComputationAccuracyPropertyKey");
    v5[3] = (uint64_t)v0;
    getVCPRequestMotionFlowComputationAccuracyPropertyKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (!v0)
  {
    dlerror();
    v3 = (_Unwind_Exception *)abort_report_np();
    _Block_object_dispose(&v4, 8);
    _Unwind_Resume(v3);
  }
  return *v0;
}

id getVCPRequestForceCPUPropertyKey(void)
{
  id *v0;
  void *v1;
  _Unwind_Exception *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (id *)getVCPRequestForceCPUPropertyKeySymbolLoc(void)::ptr;
  v7 = getVCPRequestForceCPUPropertyKeySymbolLoc(void)::ptr;
  if (!getVCPRequestForceCPUPropertyKeySymbolLoc(void)::ptr)
  {
    v1 = (void *)VideoProcessingLibrary();
    v0 = (id *)dlsym(v1, "VCPRequestForceCPUPropertyKey");
    v5[3] = (uint64_t)v0;
    getVCPRequestForceCPUPropertyKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (!v0)
  {
    dlerror();
    v3 = (_Unwind_Exception *)abort_report_np();
    _Block_object_dispose(&v4, 8);
    _Unwind_Resume(v3);
  }
  return *v0;
}

id getVCPMotionFlowRequestClass(void)
{
  void *v0;
  id v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2050000000;
  v0 = (void *)getVCPMotionFlowRequestClass(void)::softClass;
  v7 = getVCPMotionFlowRequestClass(void)::softClass;
  if (!getVCPMotionFlowRequestClass(void)::softClass)
  {
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 3221225472;
    v3[2] = ___ZL28getVCPMotionFlowRequestClassv_block_invoke;
    v3[3] = &unk_1E4548FA8;
    v3[4] = &v4;
    ___ZL28getVCPMotionFlowRequestClassv_block_invoke((uint64_t)v3);
    v0 = (void *)v5[3];
  }
  v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_1A156A5EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class ___ZL28getVCPMotionFlowRequestClassv_block_invoke(uint64_t a1)
{
  Class result;

  MediaAnalysisLibrary();
  result = objc_getClass("VCPMotionFlowRequest");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    getVCPMotionFlowRequestClass(void)::softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  else
  {
    abort_report_np();
    return (Class)MediaAnalysisLibrary();
  }
  return result;
}

uint64_t MediaAnalysisLibrary(void)
{
  uint64_t v0;
  void *v2;

  if (MediaAnalysisLibraryCore(char **)::frameworkLibrary)
    return MediaAnalysisLibraryCore(char **)::frameworkLibrary;
  MediaAnalysisLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
  v0 = MediaAnalysisLibraryCore(char **)::frameworkLibrary;
  if (!MediaAnalysisLibraryCore(char **)::frameworkLibrary)
  {
    v2 = (void *)abort_report_np();
    free(v2);
  }
  return v0;
}

void sub_1A156AAAC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A156AB18(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A156AB80(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A156ABE8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A156AC50(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A156ACB8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A156AD20(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A156AD88(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A156ADF0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A156AE58(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A156AEC0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A156AF28(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A156AF90(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A156B268(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void sub_1A156B408(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A156B4F4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A156B718(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_1A156B808(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A156BACC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;

  _Unwind_Resume(a1);
}

void sub_1A156BB94(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A156BC24(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1A156BDF8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_1A156BF6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void sub_1A156C074(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void sub_1A156C130(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  v12 = v11;

  _Unwind_Resume(a1);
}

void sub_1A156C1D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  v12 = v11;

  _Unwind_Resume(a1);
}

void sub_1A156C27C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  v12 = v11;

  _Unwind_Resume(a1);
}

void sub_1A156C32C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  v12 = v11;

  _Unwind_Resume(a1);
}

void sub_1A156C3DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  v12 = v11;

  _Unwind_Resume(a1);
}

void sub_1A156C4B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void sub_1A156C558(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  v12 = v11;

  _Unwind_Resume(a1);
}

void sub_1A156C604(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  v12 = v11;

  _Unwind_Resume(a1);
}

void sub_1A156C6B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  v12 = v11;

  _Unwind_Resume(a1);
}

void sub_1A156C750(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  v12 = v11;

  _Unwind_Resume(a1);
}

void sub_1A156C7F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  v12 = v11;

  _Unwind_Resume(a1);
}

void sub_1A156C960(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t vision::mod::readBinSerializedModelValues(char *a1, unint64_t *a2, _QWORD *a3)
{
  FILE *v6;
  FILE *v7;
  _QWORD *exception;
  uint64_t v10;
  void *__p;
  char v12;

  if (!a1)
  {
    exception = __cxa_allocate_exception(8uLL);
    v10 = 381;
    goto LABEL_8;
  }
  v6 = fopen(a1, "rb");
  if (!v6)
  {
    std::string::basic_string[abi:ne180100]<0>(&__p, a1);
    if (v12 < 0)
      operator delete(__p);
    exception = __cxa_allocate_exception(8uLL);
    v10 = 373;
LABEL_8:
    *exception = v10;
    __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
  }
  v7 = v6;
  vision::mod::readBinSerializedModelValues(v6, 0, a2, a3);
  return fclose(v7);
}

void vision::mod::readBinSerializedModelValues(FILE *a1, const char *a2, unint64_t *a3, _QWORD *a4)
{
  std::string::size_type v8;
  std::string *v9;
  __int128 v10;
  unint64_t v11;
  const void *v12;
  size_t v13;
  size_t v14;
  std::string *v15;
  void **v16;
  char *v17;
  std::string *v18;
  float *v19;
  std::__shared_weak_count *v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  unint64_t v23;
  const void *v24;
  size_t v25;
  size_t v26;
  std::string *v27;
  void **v28;
  char *v29;
  std::string *v30;
  float *v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  char *v37;
  void **v38;
  std::string::size_type v39;
  std::string *v40;
  __int128 v41;
  std::string *v42;
  _QWORD *v43;
  _QWORD *v44;
  _QWORD *exception;
  std::string v46;
  float *v47;
  uint64_t v48;
  std::string v49;
  void *__p[2];
  int64_t v51;

  if (!a1)
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = 381;
    __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
  }
  if (a2)
  {
    std::string::basic_string[abi:ne180100]<0>(&v49, "::");
    v8 = strlen(a2);
    v9 = std::string::insert(&v49, 0, a2, v8);
    v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    v51 = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)__p = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v49.__r_.__value_.__l.__data_);
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "");
  }
  if (*a3)
  {
    v11 = 0;
    do
    {
      v12 = *(const void **)(a3[1] + 8 * v11);
      if (v51 >= 0)
        v13 = HIBYTE(v51);
      else
        v13 = (size_t)__p[1];
      v14 = strlen(*(const char **)(a3[1] + 8 * v11));
      std::string::basic_string[abi:ne180100]((uint64_t)&v49, v13 + v14);
      if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v15 = &v49;
      else
        v15 = (std::string *)v49.__r_.__value_.__r.__words[0];
      if (v13)
      {
        if (v51 >= 0)
          v16 = __p;
        else
          v16 = (void **)__p[0];
        memmove(v15, v16, v13);
      }
      v17 = (char *)v15 + v13;
      if (v14)
        memmove(v17, v12, v14);
      v17[v14] = 0;
      if (!std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(a4, (unsigned __int8 *)&v49))
      {
        v47 = 0;
        v48 = 0;
        if (fseek(a1, 0, 0) == -1)
        {
          v43 = __cxa_allocate_exception(8uLL);
          *v43 = 373;
          __cxa_throw(v43, MEMORY[0x1E0DE4F28], 0);
        }
        if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v18 = &v49;
        else
          v18 = (std::string *)v49.__r_.__value_.__r.__words[0];
        if (BinSerializer_freadInFloat(a1, v18, 1, &v47, (size_t *)&v48) == 128)
        {
          v19 = v47;
          v46.__r_.__value_.__r.__words[0] = (std::string::size_type)v47;
          v20 = (std::__shared_weak_count *)operator new();
          v20->__shared_owners_ = 0;
          p_shared_owners = (unint64_t *)&v20->__shared_owners_;
          v20->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453C020;
          v20->__shared_weak_owners_ = 0;
          v20[1].__vftable = (std::__shared_weak_count_vtbl *)v19;
          v46.__r_.__value_.__l.__size_ = (std::string::size_type)v20;
          vision::mod::ModelValues::setModelValues((uint64_t)a4, (__int128 *)&v49, (uint64_t)v19, v20, v48);
          do
            v22 = __ldaxr(p_shared_owners);
          while (__stlxr(v22 - 1, p_shared_owners));
          if (!v22)
          {
            ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
            std::__shared_weak_count::__release_weak(v20);
          }
        }
      }
      if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v49.__r_.__value_.__l.__data_);
      ++v11;
    }
    while (v11 < *a3);
  }
  if (a3[2])
  {
    v23 = 0;
    do
    {
      v24 = *(const void **)(a3[3] + 8 * v23);
      if (v51 >= 0)
        v25 = HIBYTE(v51);
      else
        v25 = (size_t)__p[1];
      v26 = strlen(*(const char **)(a3[3] + 8 * v23));
      std::string::basic_string[abi:ne180100]((uint64_t)&v49, v25 + v26);
      if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v27 = &v49;
      else
        v27 = (std::string *)v49.__r_.__value_.__r.__words[0];
      if (v25)
      {
        if (v51 >= 0)
          v28 = __p;
        else
          v28 = (void **)__p[0];
        memmove(v27, v28, v25);
      }
      v29 = (char *)v27 + v25;
      if (v26)
        memmove(v29, v24, v26);
      v29[v26] = 0;
      if (!std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(a4, (unsigned __int8 *)&v49))
      {
        v47 = 0;
        v48 = 0;
        if (fseek(a1, 0, 0) == -1)
        {
          v44 = __cxa_allocate_exception(8uLL);
          *v44 = 373;
          __cxa_throw(v44, MEMORY[0x1E0DE4F28], 0);
        }
        if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v30 = &v49;
        else
          v30 = (std::string *)v49.__r_.__value_.__r.__words[0];
        if (BinSerializer_freadInBytes(a1, v30, &v47, (size_t *)&v48) == 128)
        {
          v31 = v47;
          v46.__r_.__value_.__r.__words[0] = (std::string::size_type)v47;
          v32 = (std::__shared_weak_count *)operator new();
          v32->__shared_owners_ = 0;
          v33 = (unint64_t *)&v32->__shared_owners_;
          v32->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453C090;
          v32->__shared_weak_owners_ = 0;
          v32[1].__vftable = (std::__shared_weak_count_vtbl *)v31;
          v46.__r_.__value_.__l.__size_ = (std::string::size_type)v32;
          vision::mod::ModelValues::setModelValues((uint64_t)a4, (__int128 *)&v49, (uint64_t)v31, v32, v48);
          do
            v34 = __ldaxr(v33);
          while (__stlxr(v34 - 1, v33));
          if (!v34)
          {
            ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
            std::__shared_weak_count::__release_weak(v32);
          }
        }
      }
      if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v49.__r_.__value_.__l.__data_);
      ++v23;
    }
    while (v23 < a3[2]);
  }
  if (a3[4])
  {
    v35 = 0;
    v36 = 0;
    do
    {
      v37 = *(char **)(a3[5] + 8 * v36);
      if (a2)
      {
        if (v37)
        {
          std::string::basic_string[abi:ne180100]<0>(&v46, v37);
          if (v51 >= 0)
            v38 = __p;
          else
            v38 = (void **)__p[0];
          if (v51 >= 0)
            v39 = HIBYTE(v51);
          else
            v39 = (std::string::size_type)__p[1];
          v40 = std::string::insert(&v46, 0, (const std::string::value_type *)v38, v39);
          v41 = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
          v49.__r_.__value_.__r.__words[2] = v40->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v49.__r_.__value_.__l.__data_ = v41;
          v40->__r_.__value_.__l.__size_ = 0;
          v40->__r_.__value_.__r.__words[2] = 0;
          v40->__r_.__value_.__r.__words[0] = 0;
          if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v42 = &v49;
          else
            v42 = (std::string *)v49.__r_.__value_.__r.__words[0];
          vision::mod::readBinSerializedModelValues(a1, v42, a3[6] + v35, a4);
          if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v49.__r_.__value_.__l.__data_);
          if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v46.__r_.__value_.__l.__data_);
        }
        else
        {
          vision::mod::readBinSerializedModelValues(a1, a2, a3[6] + v35, a4);
        }
      }
      else
      {
        vision::mod::readBinSerializedModelValues(a1, v37, a3[6] + v35, a4);
      }
      ++v36;
      v35 += 56;
    }
    while (v36 < a3[4]);
  }
  if (SHIBYTE(v51) < 0)
    operator delete(__p[0]);
}

void sub_1A156CF84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1A156CF98(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a10);
  if (a20 < 0)
    operator delete(__p);
  if (a27 < 0)
    JUMPOUT(0x1A156D064);
  JUMPOUT(0x1A156D068);
}

void sub_1A156CFA8(void *a1)
{
  void *v1;

  __cxa_begin_catch(a1);
  free(v1);
  __cxa_rethrow();
}

void sub_1A156CFBC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  __cxa_end_catch();
  if (a20 < 0)
    JUMPOUT(0x1A156D040);
  JUMPOUT(0x1A156D058);
}

void sub_1A156CFCC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a10);
  if (a20 < 0)
    JUMPOUT(0x1A156D040);
  JUMPOUT(0x1A156D058);
}

void sub_1A156CFDC(void *a1)
{
  void *v1;

  __cxa_begin_catch(a1);
  free(v1);
  __cxa_rethrow();
}

void sub_1A156CFF0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  __cxa_end_catch();
  if (a20 < 0)
    JUMPOUT(0x1A156D040);
  JUMPOUT(0x1A156D058);
}

void sub_1A156D000()
{
  JUMPOUT(0x1A156D008);
}

void sub_1A156D018(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a23 < 0)
    operator delete(__p);
  if (a15 < 0)
    JUMPOUT(0x1A156D040);
  if (a30 < 0)
    JUMPOUT(0x1A156D064);
  JUMPOUT(0x1A156D068);
}

void sub_1A156D048()
{
  JUMPOUT(0x1A156D058);
}

void std::__shared_ptr_pointer<unsigned char *,vision::mod::readBinSerializedModelValues(__sFILE *,char const*,vision::mod::BinSerializedModelFileInfo const&,vision::mod::ModelValues &,BOOL)::$_1,std::allocator<unsigned char>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A1B0A898);
}

void std::__shared_ptr_pointer<unsigned char *,vision::mod::readBinSerializedModelValues(__sFILE *,char const*,vision::mod::BinSerializedModelFileInfo const&,vision::mod::ModelValues &,BOOL)::$_1,std::allocator<unsigned char>>::__on_zero_shared(uint64_t a1)
{
  free(*(void **)(a1 + 24));
}

uint64_t std::__shared_ptr_pointer<unsigned char *,vision::mod::readBinSerializedModelValues(__sFILE *,char const*,vision::mod::BinSerializedModelFileInfo const&,vision::mod::ModelValues &,BOOL)::$_1,std::allocator<unsigned char>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN6vision3mod28readBinSerializedModelValuesEP7__sFILEPKcRKNS0_26BinSerializedModelFileInfoERNS0_11ModelValuesEbE3$_1"))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void std::__shared_ptr_pointer<float *,vision::mod::readBinSerializedModelValues(__sFILE *,char const*,vision::mod::BinSerializedModelFileInfo const&,vision::mod::ModelValues &,BOOL)::$_0,std::allocator<float>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A1B0A898);
}

void std::__shared_ptr_pointer<float *,vision::mod::readBinSerializedModelValues(__sFILE *,char const*,vision::mod::BinSerializedModelFileInfo const&,vision::mod::ModelValues &,BOOL)::$_0,std::allocator<float>>::__on_zero_shared(uint64_t a1)
{
  free(*(void **)(a1 + 24));
}

uint64_t std::__shared_ptr_pointer<float *,vision::mod::readBinSerializedModelValues(__sFILE *,char const*,vision::mod::BinSerializedModelFileInfo const&,vision::mod::ModelValues &,BOOL)::$_0,std::allocator<float>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), (uint64_t)"ZN6vision3mod28readBinSerializedModelValuesEP7__sFILEPKcRKNS0_26BinSerializedModelFileInfoERNS0_11ModelValuesEbE3$_0"))
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1A156D1DC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A156D310(void *exc_buf)
{
  objc_begin_catch(exc_buf);
  JUMPOUT(0x1A156D2DCLL);
}

void sub_1A156D460(void *a1)
{
  void *v1;
  void *v2;

  objc_begin_catch(a1);
  JUMPOUT(0x1A156D42CLL);
}

void sub_1A156D7CC(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, uint64_t a12, void *a13, void *a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,void *a21,void *a22)
{
  void *v22;
  void *v23;
  void *v24;
  void *v25;

  objc_begin_catch(a1);
  JUMPOUT(0x1A156D790);
}

void sub_1A156D930(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A156D950(void *a1)
{
  objc_begin_catch(a1);
  JUMPOUT(0x1A156D910);
}

void sub_1A156DA84(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A156DC7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  void *v12;
  void *v13;
  void *v14;

  _Unwind_Resume(a1);
}

void sub_1A156DF2C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1A156E004(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A156E0B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A156E130(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A156E298(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A156E428(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A156E4F4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A156E6B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A156E730(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A156E898(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A156EA28(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A156EB9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  void *v15;

  _Unwind_Resume(a1);
}

void sub_1A156EC7C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void vision::mod::Face3D::~Face3D(vision::mod::Face3D *this)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 6);
  if (v2)
    MEMORY[0x1A1B0A880](v2, 0x1000C8052888210);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)this + 24);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)this + 8);
}

void sub_1A156EF00(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A156F000(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A156F0B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A156F17C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A156F7E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23)
{
  void *v23;

  _Unwind_Resume(a1);
}

void sub_1A156FAD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void Projections_computeShiftBruteForce(uint64_t a1, int a2, _QWORD *a3, uint64_t a4, int a5, _QWORD *a6, int a7, float *a8, float *a9)
{
  float *v13;
  int v14;
  size_t v15;
  float *v16;
  int v17;
  float v18;
  float v19;
  float *v20;
  float v21;
  float v22;
  float v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  int32x2_t v28;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  float v40;
  float v41;
  unsigned int v42;
  int v43;
  float v44;
  float *v45;
  uint64_t v46;
  int v47;
  float v48;
  int32x2_t v49;
  float32x2_t v50;
  int8x8_t v51;
  int8x8_t v52;
  float32x2_t v53;
  float32x2_t v54;
  float32x2_t v55;
  float32x2_t v56;
  int8x8_t v57;
  int8x8_t v58;
  float32x2_t v59;
  float v60;
  char v61;
  int v62;
  int v63;
  float v64;
  uint64_t v65;
  float *v66;
  float v67;
  uint64_t v68;
  float *v70;
  int v71;
  int v72;
  int v73;
  float *v78;
  float *v79;
  unsigned int v80;
  unsigned int v81;
  int v82;
  float __C[3];

  v13 = a9;
  if (a2 <= a5)
    v14 = a5;
  else
    v14 = a2;
  v15 = 8 * v14;
  v78 = (float *)malloc_type_malloc(v15, 0x100004052888210uLL);
  v16 = (float *)malloc_type_malloc(v15, 0x100004052888210uLL);
  *v16 = 3.4028e38;
  v17 = 1 - a2;
  v79 = a8;
  v18 = *a8;
  v19 = 0.0;
  if (*a8 >= (float)(1 - a2))
  {
    v21 = (float)(a5 - 1);
    v20 = v78;
    if (v18 <= v21)
    {
      v22 = v18 - (float)v17;
      v23 = v21 - v18;
      if (v22 > v23)
        v23 = v22;
      v19 = 0.0 / v23;
    }
  }
  else
  {
    v20 = v78;
  }
  if (v17 >= a5)
  {
    v63 = 0;
    v60 = 3.4028e38;
  }
  else
  {
    v24 = 0;
    v25 = (a5 + a2 - 1);
    v26 = a2 - 1;
    v72 = a7;
    v73 = a5 - 1;
    v27 = -a2;
    v28 = vdup_n_s32(0x7F7FFFFFu);
    __asm { FMOV            V11.2S, #1.0 }
    v34 = a2 - 1;
    v71 = a5 + a2 - 2;
    v35 = v71;
    do
    {
      v36 = v27 + v24 + 1;
      v37 = v17 & ~(v17 >> 31);
      if (v35 >= v26)
        v38 = v26;
      else
        v38 = v35;
      v39 = v27 + v24 + v38 - v37 + 2;
      if (v39 >= a7)
      {
        v42 = v37 + v34;
        v43 = v73;
        if (v73 >= (int)v24)
          v43 = v24;
        v82 = v43;
        v80 = v42;
        v81 = v36 & ~(v36 >> 31);
        v44 = *v79;
        __C[0] = 0.0;
        v45 = v16;
        v46 = v25;
        v47 = v17;
        vDSP_dotpr((const float *)(a1 + 4 * v42), 1, (const float *)(a4 + 4 * v81), 1, __C, v39);
        v17 = v47;
        v25 = v46;
        a7 = v72;
        v16 = v45;
        v20 = v78;
        __C[0] = __C[0] / (float)v39;
        v48 = (float)(*(float *)(*a3 + 4 * (v38 + 1)) - *(float *)(*a3 + 4 * (int)v80)) / (float)v39;
        *(float *)v49.i32 = (float)((float)((float)(*(float *)(a3[1] + 4 * (v38 + 1))
                                                  - *(float *)(a3[1] + 4 * (int)v80))
                                          / (float)v39)
                                  - (float)(v48 * v48))
                          + 0.0;
        v50 = (float32x2_t)vdup_lane_s32(v49, 0);
        v51 = (int8x8_t)vceqz_f32(v50);
        v52 = (int8x8_t)vcgt_s32((int32x2_t)v50, v28);
        v53 = vrsqrte_f32(v50);
        v54 = (float32x2_t)vorr_s8(v52, v51);
        v55 = vmul_f32((float32x2_t)v49, (float32x2_t)vbsl_s8((int8x8_t)v54, _D11, (int8x8_t)vmul_f32(v53, vrsqrts_f32(v53, vmul_n_f32(v53, *(float *)v49.i32)))));
        *(float *)v52.i32 = (float)(int)(v82 - v81 + 1);
        v53.f32[0] = (float)(*(float *)(*a6 + 4 * (v82 + 1)) - *(float *)(*a6 + 4 * v81)) / *(float *)v52.i32;
        v54.f32[0] = (float)((float)((float)(*(float *)(a6[1] + 4 * (v82 + 1)) - *(float *)(a6[1] + 4 * v81))
                                   / *(float *)v52.i32)
                           - (float)(v53.f32[0] * v53.f32[0]))
                   + 0.0;
        v56 = (float32x2_t)vdup_lane_s32((int32x2_t)v54, 0);
        v57 = (int8x8_t)vceqz_f32(v56);
        v58 = (int8x8_t)vcgt_s32((int32x2_t)v56, v28);
        v59 = vrsqrte_f32(v56);
        v54.f32[0] = vmul_f32(v55, vmul_f32(v54, (float32x2_t)vbsl_s8(vorr_s8(v58, v57), _D11, (int8x8_t)vmul_f32(v59, vrsqrts_f32(v59, vmul_n_f32(v59, v54.f32[0])))))).f32[0];
        v40 = (float)(v27 + v24 + 1);
        v41 = (float)((float)((float)(v54.f32[0] - __C[0]) + (float)(v48 * v53.f32[0]))
                    / (float)(v54.f32[0] + v54.f32[0]))
            + (float)(v19 * vabds_f32(v44, v40));
      }
      else
      {
        v40 = (float)v36;
        v41 = 3.4028e38;
      }
      v20[v24] = v40;
      v16[v24++] = v41;
      ++v17;
      --v35;
      --v34;
    }
    while (v25 != v24);
    v60 = *v16;
    v13 = a9;
    if (v25 < 2)
    {
      v63 = 0;
    }
    else
    {
      v61 = 0;
      v62 = 0;
      v63 = 0;
      v64 = 3.4028e38;
      v65 = 1;
LABEL_23:
      v66 = &v16[v65];
      do
      {
        v67 = *v66;
        if (v60 > *v66)
        {
          v63 = (int)v20[v65];
          v60 = *v66;
        }
        v68 = v65 + 1;
        if (v65 < v71 && v64 > v67 && *(v66 - 1) > v67 && v66[1] > v67)
        {
          v62 = (int)v20[v65];
          v61 = 1;
          ++v65;
          v64 = *v66;
          if (v68 != v25)
            goto LABEL_23;
          *v79 = (float)v62;
          *a9 = v67;
          goto LABEL_42;
        }
        ++v66;
        ++v65;
      }
      while (v25 != v68);
      if ((v61 & 1) != 0)
        goto LABEL_41;
    }
  }
  v62 = v63;
  v64 = v60;
LABEL_41:
  *v79 = (float)v62;
  *v13 = v64;
  if (v20)
  {
LABEL_42:
    v70 = v16;
    free(v20);
    v16 = v70;
  }
  free(v16);
}

void sub_1A15701CC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1570504(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A1571394(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *exc_bufa, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,void *a22)
{
  void *v22;
  void *v23;
  void *v24;
  void *v25;

  if (a2)
  {

    objc_begin_catch(a1);
    JUMPOUT(0x1A15710C0);
  }
  _Unwind_Resume(a1);
}

void sub_1A15720E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24)
{
  uint64_t v24;

  if (__p)
    operator delete(__p);
  MEMORY[0x1A1B0A880](v24, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void sub_1A1572440(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_1A1572AE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19, uint64_t a20,void *a21,void *a22,uint64_t a23,void *a24)
{
  void *v24;

  _Unwind_Resume(a1);
}

void sub_1A1572CE0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1572E04(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

_WORD *reverseCopy(_WORD *__dst, char *__src, int a3, int a4)
{
  int v4;
  _WORD *v6;
  char v7;
  __int16 v8;
  size_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;

  v4 = a4;
  v6 = __dst;
  switch(a3)
  {
    case 1:
      if (a4 >= 1)
      {
        do
        {
          v7 = *__src--;
          *(_BYTE *)v6 = v7;
          v6 = (_WORD *)((char *)v6 + 1);
          --v4;
        }
        while (v4);
      }
      break;
    case 2:
      if (a4 >= 1)
      {
        do
        {
          v8 = *(_WORD *)__src;
          __src -= 2;
          *v6++ = v8;
          --v4;
        }
        while (v4);
      }
      break;
    case 4:
      if (a4 >= 1)
      {
        do
        {
          v11 = *(_DWORD *)__src;
          __src -= 4;
          *(_DWORD *)v6 = v11;
          v6 += 2;
          --v4;
        }
        while (v4);
      }
      break;
    case 8:
      if (a4 >= 1)
      {
        do
        {
          v12 = *(_QWORD *)__src;
          __src -= 8;
          *(_QWORD *)v6 = v12;
          v6 += 4;
          --v4;
        }
        while (v4);
      }
      break;
    default:
      if (a4 >= 1)
      {
        v9 = a3;
        v10 = -(uint64_t)a3;
        do
        {
          __dst = memcpy(v6, __src, v9);
          v6 = (_WORD *)((char *)v6 + v9);
          __src += v10;
          --v4;
        }
        while (v4);
      }
      break;
  }
  return __dst;
}

void saveImage(const char *a1, uint64_t a2)
{
  CGColorSpace *DeviceRGB;
  CGDataProvider *v5;
  unsigned int v6;
  CGBitmapInfo v7;
  CGImage *v8;
  CFIndex v9;
  const __CFURL *v10;
  const __CFURL *v11;
  CGImageDestination *v12;
  CGImageDestination *v13;

  DeviceRGB = CGColorSpaceCreateDeviceRGB();
  v5 = CGDataProviderCreateWithData(0, *(const void **)a2, *(_QWORD *)(a2 + 16) * *(_QWORD *)(a2 + 24), 0);
  v6 = *(_DWORD *)(a2 + 32) - 2;
  if (v6 > 5)
    v7 = 0;
  else
    v7 = dword_1A15F9FDC[v6];
  v8 = CGImageCreate(*(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 16), 8uLL, 0x20uLL, *(_QWORD *)(a2 + 24), DeviceRGB, v7, v5, 0, 0, kCGRenderingIntentDefault);
  v9 = strlen(a1);
  v10 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)a1, v9, 0);
  if (v10)
  {
    v11 = v10;
    v12 = CGImageDestinationCreateWithURL(v10, CFSTR("public.png"), 1uLL, 0);
    if (v12)
    {
      v13 = v12;
      CGImageDestinationAddImage(v12, v8, 0);
      CGImageDestinationFinalize(v13);
      CFRelease(v13);
    }
    CFRelease(v11);
  }
  CGDataProviderRelease(v5);
  CGImageRelease(v8);
  CGColorSpaceRelease(DeviceRGB);
}

void saveY(const char *a1, uint64_t a2)
{
  int v2;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  void *v10;
  void *v11;
  int v12;
  char *v13;
  int v14;
  char *v15;
  int v16;
  char *v17;
  char *v18;
  char v19;
  _QWORD v20[4];
  uint64_t v21;
  uint64_t v22;

  v2 = *(_DWORD *)(a2 + 32);
  if (v2 == 4 || v2 == 1)
  {
    v21 = 0;
    v22 = 0;
    if (v2 == 1 || v2 == 4)
    {
      v6 = *(_QWORD *)(a2 + 8);
      v7 = *(_QWORD *)(a2 + 16);
      v20[1] = v6;
      v20[2] = v7;
      v8 = (4 * v6 + 12) & 0xFFFFFFFFFFFFFFF0;
      v20[3] = v8;
      LODWORD(v21) = 2;
      if (v8 * v7)
      {
        v10 = malloc_type_calloc(v8 * v7, 1uLL, 0x100004077774924uLL);
        v20[0] = v10;
        if (v10)
        {
          v11 = v10;
          if ((int)v7 > 0)
          {
            v12 = 0;
            v13 = *(char **)a2;
            if ((int)v6 <= 1)
              v14 = 1;
            else
              v14 = v6;
            v15 = (char *)v10;
            do
            {
              v16 = v14;
              v17 = v15;
              v18 = v13;
              if ((int)v6 >= 1)
              {
                do
                {
                  *v17 = *v18;
                  v17[1] = *v18;
                  v19 = *v18++;
                  v17[2] = v19;
                  v17[3] = -1;
                  v17 += 4;
                  --v16;
                }
                while (v16);
              }
              ++v12;
              v13 += *(_QWORD *)(a2 + 24);
              v15 += v8;
            }
            while (v12 < (int)v7);
          }
          saveImage(a1, (uint64_t)v20);
          free(v11);
        }
        else
        {
          printf("convertYUV420ToRGBA8888: failed to allocate %lu bytes\n");
        }
      }
      else
      {
        printf("convertYUV420ToRGBA8888: invalid dst size of %lu x %lu\n");
      }
    }
    else
    {
      puts("convertYUV420ToRGBA8888: src must be YUV420 format!");
    }
  }
}

const char *saveCVPixelBuffer(const char *result, CVPixelBufferRef pixelBuffer)
{
  __CVBuffer *v2;
  const char *v3;
  signed int PixelFormatType;
  size_t v5;
  unint64_t v6;
  unsigned __int8 *BaseAddressOfPlane;
  unsigned __int8 *v8;
  size_t BytesPerRowOfPlane;
  uint64_t v10;
  unint64_t v11;
  _BYTE *v12;
  int32x4_t v13;
  int32x4_t v14;
  size_t v15;
  unsigned int v16;
  _BYTE *v17;
  size_t v18;
  uint64_t v19;
  int v20;
  unsigned int v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  int32x2_t v25;
  int32x4_t v26;
  int32x4_t v27;
  int32x4_t v28;
  int32x4_t v29;
  int32x4_t v30;
  size_t v31;
  _BYTE *v32;
  BOOL v33;
  int v34;
  __CVBuffer *v35;
  char *v36;
  void *BaseAddress;
  size_t Width;
  size_t Height;
  size_t BytesPerRow;
  uint64_t v41;
  uint64_t v42;

  if (pixelBuffer)
  {
    v2 = pixelBuffer;
    v3 = result;
    PixelFormatType = CVPixelBufferGetPixelFormatType(pixelBuffer);
    CVPixelBufferLockBaseAddress(v2, 1uLL);
    if (PixelFormatType > 1111970368)
    {
      switch(PixelFormatType)
      {
        case 1111970369:
          v34 = 7;
          break;
        case 1278226488:
          LODWORD(v41) = 4;
          Width = CVPixelBufferGetWidth(v2);
          Height = CVPixelBufferGetHeight(v2);
          BaseAddress = CVPixelBufferGetBaseAddress(v2);
          v42 = 0;
          BytesPerRow = CVPixelBufferGetBytesPerRow(v2);
          saveY(v3, (uint64_t)&BaseAddress);
          return (const char *)CVPixelBufferUnlockBaseAddress(v2, 1uLL);
        case 1380401729:
          v34 = 2;
          break;
        default:
          return (const char *)CVPixelBufferUnlockBaseAddress(v2, 1uLL);
      }
    }
    else
    {
      if (PixelFormatType != 32)
      {
        if (PixelFormatType == 875704422 || PixelFormatType == 875704438)
        {
          v5 = CVPixelBufferGetWidth(v2);
          v6 = CVPixelBufferGetHeight(v2);
          BaseAddressOfPlane = (unsigned __int8 *)CVPixelBufferGetBaseAddressOfPlane(v2, 0);
          v8 = (unsigned __int8 *)CVPixelBufferGetBaseAddressOfPlane(v2, 1uLL);
          v35 = v2;
          BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(v2, 0);
          v42 = 0;
          Width = v5;
          Height = v6;
          v10 = 4 * v5;
          BytesPerRow = 4 * v5;
          v41 = 2;
          v36 = (char *)malloc_type_calloc(4 * v5, v6, 0xF81350A0uLL);
          BaseAddress = v36;
          if (v6)
          {
            LODWORD(v11) = 0;
            v12 = v36 + 7;
            v13.i64[0] = 0x10000000100;
            v13.i64[1] = 0x10000000100;
            v14.i64[0] = 0xFF000000FFLL;
            v14.i64[1] = 0xFF000000FFLL;
            v15 = v5;
            do
            {
              if (v15)
              {
                v16 = 2;
                v17 = v12;
                v18 = BytesPerRowOfPlane;
                v19 = 1;
                do
                {
                  v20 = v8[v19] - 128;
                  v21 = 717 * v20 + 256;
                  v22 = v8[v19 - 1] - 128;
                  v23 = -176 * v22 - 365 * v20;
                  v24 = 904 * v22 + 256;
                  v25.i32[0] = BaseAddressOfPlane[v18];
                  v25.i32[1] = BaseAddressOfPlane[v18 + 1];
                  v26.u64[1] = (unint64_t)vshl_n_s32(v25, 9uLL);
                  v26.i32[0] = BaseAddressOfPlane[v19 - 1] << 9;
                  v26.i32[1] = BaseAddressOfPlane[v19] << 9;
                  v27.i32[0] = (int)(v24 + v26.i32[0]) >> 9;
                  v27.i32[1] = (int)(v24 + v26.i32[1]) >> 9;
                  v27.u64[1] = (unint64_t)vshr_n_s32(vadd_s32(vdup_n_s32(v24), (int32x2_t)v26.u64[1]), 9uLL);
                  v28 = vminq_s32(vmaxq_s32(vshrq_n_s32(vaddq_s32(vdupq_n_s32(v21), v26), 9uLL), (int32x4_t)0), v14);
                  v29 = vminq_s32(vmaxq_s32(vshrq_n_s32(vaddq_s32(vaddq_s32(vdupq_n_s32(v23), v13), v26), 9uLL), (int32x4_t)0), v14);
                  v30 = vminq_s32(vmaxq_s32(v27, (int32x4_t)0), v14);
                  *(v17 - 7) = v28.i8[0];
                  *(v17 - 6) = v29.i8[0];
                  *(v17 - 5) = v30.i8[0];
                  *(v17 - 4) = -1;
                  v31 = v16 - 1;
                  if (v5 > v31)
                  {
                    *(v17 - 3) = v28.i8[4];
                    *(v17 - 2) = v29.i8[4];
                    *(v17 - 1) = v30.i8[4];
                    *v17 = -1;
                  }
                  if (v6 > (v11 | 1))
                  {
                    v32 = &v17[v10];
                    v17[v10 - 7] = v28.i8[8];
                    v17[v10 - 6] = v29.i8[8];
                    v17[v10 - 5] = v30.i8[8];
                    v17[v10 - 4] = -1;
                    if (v5 > v31)
                    {
                      *(v32 - 3) = v28.i8[12];
                      *(v32 - 2) = v29.i8[12];
                      *(v32 - 1) = v30.i8[12];
                      *v32 = -1;
                    }
                  }
                  v33 = v5 > v16;
                  v16 += 2;
                  v18 += 2;
                  v17 += 8;
                  v19 += 2;
                }
                while (v33);
                v15 = v5;
              }
              v11 = (v11 + 2);
              BaseAddressOfPlane += 2 * BytesPerRowOfPlane;
              v8 += BytesPerRowOfPlane;
              v12 += 8 * v5;
            }
            while (v6 > v11);
          }
          saveImage(v3, (uint64_t)&BaseAddress);
          if (v36)
            free(v36);
          v2 = v35;
        }
        return (const char *)CVPixelBufferUnlockBaseAddress(v2, 1uLL);
      }
      v34 = 3;
    }
    LODWORD(v41) = v34;
    Width = CVPixelBufferGetWidth(v2);
    Height = CVPixelBufferGetHeight(v2);
    BaseAddress = CVPixelBufferGetBaseAddress(v2);
    BytesPerRow = CVPixelBufferGetBytesPerRow(v2);
    saveImage(v3, (uint64_t)&BaseAddress);
    return (const char *)CVPixelBufferUnlockBaseAddress(v2, 1uLL);
  }
  return result;
}

void saveVImage(const char *a1, unsigned __int8 **a2, int a3)
{
  int v5;
  size_t v6;
  unsigned __int8 *v7;
  void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  _BYTE *v12;
  unsigned __int8 *i;
  double v14;
  int8x16_t v15;
  uint64_t v16;
  void *v17;
  void *v18;
  uint64_t v19;
  unsigned __int8 *v20;
  char *v21;
  char v23;
  _OWORD v24[2];
  __int128 v25;

  v25 = 0u;
  memset(v24, 0, sizeof(v24));
  if (a3 <= 1278226533)
  {
    if (a3 == 32)
    {
      v5 = 3;
    }
    else
    {
      if (a3 != 1111970369)
      {
        if (a3 == 1278226488)
        {
          LODWORD(v25) = 1;
          *(int8x16_t *)((char *)v24 + 8) = vextq_s8(*(int8x16_t *)(a2 + 1), *(int8x16_t *)(a2 + 1), 8uLL);
          *(_QWORD *)&v24[0] = *a2;
          *((_QWORD *)&v24[1] + 1) = a2[3];
          saveY(a1, (uint64_t)v24);
        }
        return;
      }
      v5 = 7;
    }
LABEL_12:
    LODWORD(v25) = v5;
    *(int8x16_t *)((char *)v24 + 8) = vextq_s8(*(int8x16_t *)(a2 + 1), *(int8x16_t *)(a2 + 1), 8uLL);
    *(_QWORD *)&v24[0] = *a2;
    *((_QWORD *)&v24[1] + 1) = a2[3];
    saveImage(a1, (uint64_t)v24);
    return;
  }
  switch(a3)
  {
    case 1278226534:
      LODWORD(v25) = 1;
      v6 = (size_t)a2[1];
      v7 = a2[2];
      *((_QWORD *)&v24[0] + 1) = v7;
      *(_QWORD *)&v24[1] = v6;
      *((_QWORD *)&v24[1] + 1) = (unint64_t)(v7 + 3) & 0xFFFFFFFFFFFFFFFCLL;
      v8 = malloc_type_calloc(*((size_t *)&v24[1] + 1), v6, 0x333A50DuLL);
      v9 = v8;
      *(_QWORD *)&v24[0] = v8;
      *((_QWORD *)&v25 + 1) = 0;
      if (v6)
      {
        v10 = 0;
        v11 = (uint64_t)*a2;
        v12 = v8;
        do
        {
          if (v7)
          {
            for (i = 0; i != v7; ++i)
            {
              v14 = fmax(*(float *)(v11 + 4 * (_QWORD)i), 0.0);
              if (v14 > 1.0)
                v14 = 1.0;
              i[(_QWORD)v12] = (int)(v14 * 255.0 + 0.5);
            }
          }
          ++v10;
          v12 += (unint64_t)(v7 + 3) & 0xFFFFFFFFFFFFFFFCLL;
          v11 += (uint64_t)a2[3];
        }
        while (v10 != v6);
      }
      saveY(a1, (uint64_t)v24);
      free(v9);
      break;
    case 1280061496:
      LODWORD(v25) = 1;
      v15 = *(int8x16_t *)(a2 + 1);
      *(int8x16_t *)((char *)v24 + 8) = vextq_s8(v15, v15, 8uLL);
      *((_QWORD *)&v24[1] + 1) = a2[3];
      v16 = v15.i64[0];
      v17 = malloc_type_calloc(*((size_t *)&v24[1] + 1), v15.u64[0], 0x4AD6B520uLL);
      v18 = v17;
      *(_QWORD *)&v24[0] = v17;
      *((_QWORD *)&v25 + 1) = 0;
      v19 = *((_QWORD *)&v24[1] + 1) * v16;
      if (*((_QWORD *)&v24[1] + 1) * v16)
      {
        v20 = *a2;
        v21 = (char *)v17;
        do
        {
          if (*v20++)
            v23 = -1;
          else
            v23 = 0;
          *v21++ = v23;
          --v19;
        }
        while (v19);
      }
      saveY(a1, (uint64_t)v24);
      free(v18);
      break;
    case 1380401729:
      v5 = 2;
      goto LABEL_12;
    default:
      return;
  }
}

void sub_1A1573CFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  uint64_t v30;

  _Block_object_dispose(&a30, 8);
  _Block_object_dispose((const void *)(v30 - 152), 8);
  _Unwind_Resume(a1);
}

id VNEntityIdentificationModelErrorWithLocalizedDescriptionAndUnderlyingError(uint64_t a1, void *a2, void *a3)
{
  objc_class *v5;
  id v6;
  id v7;
  id v8;
  void *v9;
  void *v10;

  v5 = (objc_class *)MEMORY[0x1E0C99D80];
  v6 = a3;
  v7 = a2;
  v8 = [v5 alloc];
  v9 = (void *)objc_msgSend(v8, "initWithObjectsAndKeys:", v7, *MEMORY[0x1E0CB2D50], v6, *MEMORY[0x1E0CB3388], 0);

  VNEntityIdentificationModelErrorWithUserInfo(a1, v9);
  v10 = (void *)objc_claimAutoreleasedReturnValue();

  return v10;
}

id VNEntityIdentificationModelErrorWithUserInfo(uint64_t a1, void *a2)
{
  objc_class *v3;
  id v4;
  void *v5;

  v3 = (objc_class *)MEMORY[0x1E0CB35C8];
  v4 = a2;
  v5 = (void *)objc_msgSend([v3 alloc], "initWithDomain:code:userInfo:", CFSTR("com.apple.vis.VNEntityIdentificationModel"), a1, v4);

  return v5;
}

id VNEntityIdentificationModelErrorForUnknownEntityUniqueIdentifier(uint64_t a1)
{
  void *v1;
  void *v2;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("unknown entity (%@)"), a1);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  VNEntityIdentificationModelErrorWithLocalizedDescriptionAndUnderlyingError(7, v1, 0);
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  return v2;
}

void sub_1A1575310(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A1575684(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 128), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__29432(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__29433(uint64_t a1)
{

}

void ___writeVersion1EntityAndObservations_block_invoke(_QWORD *a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id v6;
  void *v7;
  void *v8;
  void *v9;
  CC_MD5_CTX *v10;
  void *v11;
  uint64_t v12;
  id *v13;
  void *v14;
  id v15;
  id v16;
  unint64_t v17;
  void *v18;
  void *v19;
  void *v20;
  id v21;
  char v22;
  id obj;

  v6 = a2;
  v7 = (void *)MEMORY[0x1A1B0B060]();
  v8 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB36F8]), "initRequiringSecureCoding:", 1);
  objc_msgSend(v8, "setOutputFormat:", 200);
  objc_msgSend(v8, "vn_encodeEntityUniqueIdentifier:forKey:", a1[4], CFSTR("E"));
  objc_msgSend(v8, "encodeObject:forKey:", v6, CFSTR("O"));
  objc_msgSend(v8, "finishEncoding");
  objc_msgSend(v8, "encodedData");
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  v10 = (CC_MD5_CTX *)a1[8];
  v11 = (void *)a1[5];
  v12 = *(_QWORD *)(a1[6] + 8);
  v14 = *(void **)(v12 + 40);
  v13 = (id *)(v12 + 40);
  obj = v14;
  v15 = v9;
  v16 = v11;
  v17 = objc_msgSend(v15, "length");
  if (HIDWORD(v17))
  {
    v18 = (void *)MEMORY[0x1E0CB3940];
    VNPersonsModelIOStringForTag(1160466208);
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v18, "stringWithFormat:", CFSTR("tag %@ has a data overflow to %lu bytes"), v19, v17);
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    VNEntityIdentificationModelErrorWithLocalizedDescriptionAndUnderlyingError(1, v20, 0);
    obj = (id)objc_claimAutoreleasedReturnValue();

    objc_storeStrong(v13, obj);
LABEL_4:
    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = 0;
    *a5 = 1;
    goto LABEL_5;
  }
  v21 = objc_retainAutorelease(v15);
  v22 = VNEntityIdentificationModelIOWriteTaggedBufferToOutputStream(1160466208, (const void *)objc_msgSend(v21, "bytes"), v17, v16, v10, &obj);

  objc_storeStrong(v13, obj);
  if ((v22 & 1) == 0)
    goto LABEL_4;
LABEL_5:

  objc_autoreleasePoolPop(v7);
}

void sub_1A1576D28(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1A15773A0(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

id VNEntityIdentificationModelErrorForReadOnlyModelWithLocalizedDescription(void *a1)
{
  objc_class *v1;
  id v2;
  id v3;
  void *v4;
  void *v5;

  v1 = (objc_class *)MEMORY[0x1E0C99D80];
  v2 = a1;
  v3 = [v1 alloc];
  v4 = (void *)objc_msgSend(v3, "initWithObjectsAndKeys:", v2, *MEMORY[0x1E0CB2D50], 0);

  VNEntityIdentificationModelErrorWithUserInfo(6, v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  return v5;
}

uint64_t VNEntityIdentificationModelApplyTagValue(void *a1, uint64_t a2, objc_class *a3, void *a4, void *a5, uint64_t a6)
{
  id v11;
  id v12;
  void *v13;
  id v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  objc_class *v19;
  void *v20;
  void *v21;
  void *v22;

  v11 = a4;
  v12 = a5;
  v13 = (void *)MEMORY[0x1E0CB37E8];
  v14 = a1;
  objc_msgSend(v13, "numberWithUnsignedInt:", a2);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v14, "objectForKeyedSubscript:", v15);
  v16 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v16)
    goto LABEL_4;
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_msgSend(v11, "setValue:forKeyPath:", v16, v12);
LABEL_4:
    a6 = 1;
    goto LABEL_7;
  }
  if (a6)
  {
    v17 = (void *)MEMORY[0x1E0CB3940];
    VNPersonsModelIOStringForTag(a2);
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    v19 = (objc_class *)objc_opt_class();
    NSStringFromClass(v19);
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    NSStringFromClass(a3);
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v17, "stringWithFormat:", CFSTR("model data object %@ is a %@, not the expected %@"), v18, v20, v21);
    v22 = (void *)objc_claimAutoreleasedReturnValue();

    VNEntityIdentificationModelErrorWithLocalizedDescriptionAndUnderlyingError(3, v22, 0);
    *(_QWORD *)a6 = (id)objc_claimAutoreleasedReturnValue();

    a6 = 0;
  }
LABEL_7:

  return a6;
}

uint64_t _readTaggedObjectOfClass(void *a1, uint64_t a2, uint64_t a3, void *a4, CC_MD5_CTX *a5, _QWORD *a6)
{
  id v11;
  id v12;
  id v13;
  id v14;
  id v15;
  const void *v16;
  id v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  uint64_t v23;
  uint64_t v24;
  BOOL (*v25)(uint64_t, _QWORD *);
  void *v26;
  id v27;
  uint64_t *v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t (*v34)(uint64_t, uint64_t);
  void (*v35)(uint64_t);
  id v36;

  v11 = a1;
  v12 = a4;
  v13 = v11;
  LODWORD(v31) = 0;
  if (!VNEntityIdentificationModelIOReadUInt32FromInputStream(v13, &v31, a5, a6))
  {

    v17 = 0;
LABEL_13:
    v19 = 0;
    goto LABEL_14;
  }
  v14 = objc_alloc(MEMORY[0x1E0C99DF0]);
  v15 = objc_retainAutorelease((id)objc_msgSend(v14, "initWithLength:", v31));
  v16 = (const void *)objc_msgSend(v15, "mutableBytes");
  if (v16)
  {
    if (VNEntityIdentificationModelIOReadBufferFromInputStream(v13, v31, v16, a5, a6))
    {
      v17 = v15;
      goto LABEL_9;
    }
  }
  else if (a6)
  {
    +[VNError errorForMemoryAllocationFailure](VNError, "errorForMemoryAllocationFailure");
    v17 = 0;
    *a6 = (id)objc_claimAutoreleasedReturnValue();
    goto LABEL_9;
  }
  v17 = 0;
LABEL_9:

  if (!v17)
    goto LABEL_13;
  v31 = 0;
  v32 = &v31;
  v33 = 0x3032000000;
  v34 = __Block_byref_object_copy__29432;
  v35 = __Block_byref_object_dispose__29433;
  v36 = 0;
  v23 = MEMORY[0x1E0C809B0];
  v24 = 3221225472;
  v25 = ___readTaggedObjectOfClass_block_invoke;
  v26 = &unk_1E4548320;
  v17 = v17;
  v30 = a2;
  v28 = &v31;
  v29 = a3;
  v27 = v17;
  v18 = _Block_copy(&v23);
  v19 = VNExecuteBlock(v18, (uint64_t)a6);
  if ((v19 & 1) != 0)
  {
    v20 = v32[5];
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", a2, v23, v24, v25, v26);
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v12, "setObject:forKeyedSubscript:", v20, v21);

  }
  _Block_object_dispose(&v31, 8);

LABEL_14:
  return v19;
}

void sub_1A1577984(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL ___readTaggedObjectOfClass_block_invoke(uint64_t a1, _QWORD *a2)
{
  void *v4;
  void *v5;
  Class *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  id v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  _BOOL8 v14;
  void *v15;
  void *v16;
  void *v17;
  id v18;
  id v20;

  v4 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3710]), "initForReadingFromData:error:", *(_QWORD *)(a1 + 32), a2);
  v5 = v4;
  if (v4)
  {
    objc_msgSend(v4, "setRequiresSecureCoding:", 1);
    objc_msgSend(v5, "setDecodingFailurePolicy:", 1);
    if (*(_DWORD *)(a1 + 56) == 1953326188)
      objc_msgSend(v5, "setClass:forClassName:", objc_opt_class(), CFSTR("VNEntityIdentificationModelTrainedModel"));
    v6 = (Class *)(a1 + 48);
    v7 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99E60]), "initWithObjects:count:", a1 + 48, 1);
    v8 = *MEMORY[0x1E0CB2CD0];
    v20 = 0;
    objc_msgSend(v5, "decodeTopLevelObjectOfClasses:forKey:error:", v7, v8, &v20);
    v9 = objc_claimAutoreleasedReturnValue();
    v10 = v20;
    v11 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    v12 = *(void **)(v11 + 40);
    *(_QWORD *)(v11 + 40) = v9;

    v13 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
    v14 = v13 != 0;
    if (a2 && !v13)
    {
      if (v10)
      {
        *a2 = objc_retainAutorelease(v10);
      }
      else
      {
        v15 = (void *)MEMORY[0x1E0CB3940];
        NSStringFromClass(*v6);
        v16 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v15, "stringWithFormat:", CFSTR("could not decode object of class %@"), v16);
        v17 = (void *)objc_claimAutoreleasedReturnValue();
        VNEntityIdentificationModelErrorWithLocalizedDescriptionAndUnderlyingError(1, v17, 0);
        v18 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
        *a2 = v18;

      }
    }

  }
  else
  {
    v14 = 0;
  }

  return v14;
}

id VNEntityIdentificationModelErrorForUnsupportedAlgorithm(void *a1)
{
  objc_class *v1;
  id v2;
  id v3;
  objc_class *v4;
  void *v5;
  void *v6;
  void *v7;

  v1 = (objc_class *)MEMORY[0x1E0CB3940];
  v2 = a1;
  v3 = [v1 alloc];
  v4 = (objc_class *)objc_opt_class();

  NSStringFromClass(v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = (void *)objc_msgSend(v3, "initWithFormat:", CFSTR("unsupported algorithm %@"), v5);

  VNEntityIdentificationModelErrorWithLocalizedDescriptionAndUnderlyingError(11, v6, 0);
  v7 = (void *)objc_claimAutoreleasedReturnValue();

  return v7;
}

#error "1A1578198: call analysis failed (funcsize=22)"

void sub_1A1578A18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11)
{
  void *v11;
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

void sub_1A1578CD8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1578E90(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15790B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A15793B4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  v7 = v6;

  _Unwind_Resume(a1);
}

void sub_1A15795B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A15799BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class ___ZL30getABPKSkeletonDefinitionClassv_block_invoke(uint64_t a1)
{
  Class result;
  void *v3;

  if (!AltruisticBodyPoseKitLibraryCore(char **)::frameworkLibrary)
  {
    AltruisticBodyPoseKitLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
    if (!AltruisticBodyPoseKitLibraryCore(char **)::frameworkLibrary)
    {
      abort_report_np();
      goto LABEL_6;
    }
  }
  while (1)
  {
    result = objc_getClass("ABPKSkeletonDefinition");
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
    if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
      break;
LABEL_6:
    v3 = (void *)abort_report_np();
    free(v3);
  }
  getABPKSkeletonDefinitionClass(void)::softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

void sub_1A1579B9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A1579C90(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1579E04(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1A1579EDC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1579F70(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A157A004(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A157A11C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A157A258(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A157A31C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A157A38C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)VNShotflowNetwork;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_1A157A500(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A157ABDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,uint64_t a24,char a25)
{
  uint64_t v25;
  void *v27;

  v27 = *(void **)(v25 - 112);
  if (v27)
  {
    *(_QWORD *)(v25 - 104) = v27;
    operator delete(v27);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A157AF7C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A157B080(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A157B94C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34)
{

  _Unwind_Resume(a1);
}

void sub_1A157BFF4(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<espresso_buffer_t>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453B338;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<espresso_buffer_t>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453B338;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A1B0A898);
}

void sub_1A157C444(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A157C538(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1A1B0A898](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

void sub_1A157C5CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1A1B0A898](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

void sub_1A157C69C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A157C960(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  void *v7;
  va_list va;

  va_start(va, a7);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)va);

  _Unwind_Resume(a1);
}

void sub_1A157CAF0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A157CC9C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1A1B0A898](v1, 0x10C402FEFCB83);
  _Unwind_Resume(a1);
}

void sub_1A157CD30(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1A1B0A898](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

void sub_1A157CDC4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1A1B0A898](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

void sub_1A157CE44(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1A1B0A898](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

void sub_1A157CF14(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A157D1D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  void *v7;
  va_list va;

  va_start(va, a7);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)va);

  _Unwind_Resume(a1);
}

void sub_1A157D380(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1A1B0A898](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

void sub_1A157D414(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1A1B0A898](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

void sub_1A157D4AC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1A1B0A898](v1, 0x80C40D6874129);
  _Unwind_Resume(a1);
}

void sub_1A157D594(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1A1B0A898](v1, 0x10C402FEFCB83);
  _Unwind_Resume(a1);
}

void sub_1A157D664(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A157DCFC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  void *v4;
  uint64_t v5;
  va_list va;
  uint64_t v7;
  uint64_t v8;
  va_list va1;
  uint64_t v10;
  uint64_t v11;
  va_list va2;
  uint64_t v13;
  uint64_t v14;
  va_list va3;
  uint64_t v16;
  uint64_t v17;
  va_list va4;
  uint64_t v19;
  va_list va5;

  va_start(va5, a2);
  va_start(va4, a2);
  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v8 = va_arg(va2, _QWORD);
  v10 = va_arg(va2, _QWORD);
  va_copy(va3, va2);
  v11 = va_arg(va3, _QWORD);
  v13 = va_arg(va3, _QWORD);
  va_copy(va4, va3);
  v14 = va_arg(va4, _QWORD);
  v16 = va_arg(va4, _QWORD);
  va_copy(va5, va4);
  v17 = va_arg(va5, _QWORD);
  v19 = va_arg(va5, _QWORD);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)va2);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)va3);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)va4);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)va5);
  v4 = *(void **)(v2 - 88);
  if (v4)
  {
    *(_QWORD *)(v2 - 80) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(a1);
}

void sub_1A157DED8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A157E1C8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A157E308(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1A1B0A898](v1, 0x10C402FEFCB83);
  _Unwind_Resume(a1);
}

void sub_1A157E468(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1A1B0A898](v1, 0x10C402FEFCB83);
  _Unwind_Resume(a1);
}

void sub_1A157EA2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, char a14, uint64_t a15, char a16, uint64_t a17, char a18, uint64_t a19, void *__p,uint64_t a21)
{
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a10);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a12);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a14);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a16);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a18);
  if (__p)
  {
    a21 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1A157EBF0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A157EF04(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A157F050(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1A1B0A898](v1, 0x10C402FEFCB83);
  _Unwind_Resume(a1);
}

void sub_1A157F614(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, char a14, uint64_t a15, char a16, uint64_t a17, char a18, uint64_t a19, void *__p,uint64_t a21)
{
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a10);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a12);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a14);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a16);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a18);
  if (__p)
  {
    a21 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1A157F7D8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A157FAEC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A157FC7C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x1A1B0A898](v1, 0x10C402FEFCB83);
  _Unwind_Resume(a1);
}

void sub_1A1580430(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, char a14, uint64_t a15, char a16, uint64_t a17, void *__p, uint64_t a19)
{
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a10);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a12);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a14);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a16);
  if (__p)
  {
    a19 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1A1580600(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1580A5C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1580B60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A1580DA4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

BOOL QuadDetect(const vImage_Buffer *a1, uint64_t a2, void *a3, void *a4, int *a5)
{
  vImagePixelCount width;
  vImagePixelCount height;
  vImagePixelCount v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  int v20;
  float v21;
  float v22;
  vImagePixelCount v23;
  vImagePixelCount v24;
  char *v25;
  char *v26;
  char *v27;
  char *v28;
  void *v29;
  uint64_t v30;
  float v31;
  float v32;
  uint64_t i;
  uint64_t v34;
  __int128 *p_kernel;
  uint64_t v36;
  float v37;
  char *v38;
  char *v39;
  vImagePixelCount v40;
  vImagePixelCount v41;
  vDSP_Length v42;
  void *v43;
  float *v44;
  void *v45;
  char *v46;
  char *v47;
  int v48;
  int v49;
  size_t v50;
  int v51;
  char *v52;
  size_t v53;
  char *v54;
  int v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  char *v61;
  uint64_t v62;
  char *v63;
  char *v64;
  int v65;
  uint64_t v66;
  char *v67;
  char *v68;
  uint64_t v69;
  char *v70;
  char *v71;
  unsigned int v72;
  unsigned int v73;
  float v74;
  int v75;
  float v76;
  float v77;
  int v78;
  int v79;
  BOOL v80;
  int v81;
  int v82;
  int v83;
  int v84;
  int v85;
  int v86;
  float v87;
  char *v88;
  char *v89;
  int v90;
  char *v91;
  uint64_t v92;
  int v93;
  _BYTE *v94;
  size_t v95;
  _BYTE *v96;
  char *v97;
  _BYTE *v98;
  int v99;
  _BYTE *v100;
  uint64_t v101;
  unsigned int v102;
  unsigned int v103;
  int v104;
  char *v105;
  _BYTE *v106;
  size_t v107;
  _BYTE *v108;
  char *v109;
  _BYTE *v110;
  int v111;
  _BYTE *v112;
  uint64_t v113;
  unsigned int v114;
  unsigned int v115;
  char *v116;
  int v117;
  uint64_t v118;
  int v119;
  _BYTE *v120;
  size_t v121;
  _BYTE *v122;
  uint64_t v123;
  char *v124;
  _BYTE *v125;
  int v126;
  _BYTE *v127;
  uint64_t v128;
  unsigned int v129;
  unsigned int v130;
  int v131;
  int v132;
  size_t v133;
  char *v134;
  char *v135;
  size_t v136;
  void *v137;
  unsigned __int8 *v138;
  _QWORD *v139;
  int v140;
  _QWORD *v141;
  uint64_t v142;
  unint64_t v143;
  unsigned int v144;
  unsigned __int8 *v145;
  char *v146;
  size_t v147;
  uint64_t v148;
  char *v149;
  uint64_t v150;
  int v151;
  uint64_t v152;
  char *v153;
  uint64_t v154;
  int v155;
  int *v156;
  int v157;
  int v158;
  int v159;
  int v160;
  int v161;
  int v162;
  int *v163;
  int v164;
  int v165;
  int v166;
  int v167;
  int v168;
  int v169;
  int v170;
  int *v171;
  int v172;
  int v173;
  int v174;
  int v175;
  int v176;
  int v177;
  int v178;
  int v179;
  int v180;
  int v181;
  int v182;
  int v183;
  int v184;
  int v185;
  int v186;
  int *v187;
  int v188;
  int v189;
  int v190;
  int v191;
  int v192;
  int v193;
  int v194;
  uint64_t v195;
  unsigned int v196;
  int v197;
  char v198;
  int *v199;
  int v200;
  uint64_t v201;
  unsigned __int8 *v202;
  _BYTE *v203;
  _BYTE *v204;
  int v205;
  int v206;
  char v207;
  uint64_t v208;
  int v209;
  vImagePixelCount v210;
  vImagePixelCount v211;
  void *v212;
  int **v213;
  int v214;
  const void *v215;
  int v216;
  int v217;
  int v218;
  int v219;
  BOOL v220;
  char *v221;
  int v222;
  char *v223;
  int v224;
  vImagePixelCount v225;
  vImagePixelCount v226;
  void *v227;
  const void *v228;
  int **v229;
  int v230;
  int v231;
  int v232;
  int v233;
  int v234;
  BOOL v235;
  int v236;
  char *v237;
  int v238;
  vImagePixelCount v239;
  vImagePixelCount v240;
  void *v241;
  const void *v242;
  int **v243;
  int v244;
  int v245;
  int v246;
  int v247;
  int v248;
  BOOL v249;
  int v250;
  char *v251;
  int v252;
  vImagePixelCount v253;
  vImagePixelCount v254;
  void *v255;
  const void *v256;
  int **v257;
  int v258;
  int v259;
  int v260;
  int v261;
  int v262;
  BOOL v263;
  int v264;
  char *v265;
  int v266;
  vImagePixelCount v267;
  vImagePixelCount v268;
  void *v269;
  const void *v270;
  int **v271;
  int v272;
  int v273;
  int v274;
  int v275;
  int v276;
  BOOL v277;
  int v278;
  char *v279;
  int v280;
  vImagePixelCount v281;
  vImagePixelCount v282;
  void *v283;
  const void *v284;
  int **v285;
  int v286;
  int v287;
  int v288;
  int v289;
  int v290;
  BOOL v291;
  int v292;
  char *v293;
  int v294;
  vImagePixelCount v295;
  vImagePixelCount v296;
  void *v297;
  const void *v298;
  int **v299;
  int v300;
  int v301;
  int v302;
  int v303;
  int v304;
  BOOL v305;
  int v306;
  char *v307;
  int v308;
  vImagePixelCount v309;
  vImagePixelCount v310;
  void *v311;
  const void *v312;
  int **v313;
  int v314;
  int v315;
  int v316;
  int v317;
  int v318;
  BOOL v319;
  int v320;
  unint64_t v321;
  void *v322;
  uint64_t v323;
  uint64_t v324;
  unsigned int v325;
  int v326;
  unsigned __int8 v327;
  uint64_t v328;
  int v329;
  vImagePixelCount v330;
  vImagePixelCount v331;
  void *v332;
  int **v333;
  int v334;
  const void *v335;
  int v336;
  int v337;
  int v338;
  int v339;
  BOOL v340;
  char *v341;
  int v342;
  char *v343;
  int v344;
  vImagePixelCount v345;
  vImagePixelCount v346;
  void *v347;
  const void *v348;
  int **v349;
  int v350;
  int v351;
  int v352;
  int v353;
  int v354;
  BOOL v355;
  int v356;
  char *v357;
  int v358;
  vImagePixelCount v359;
  vImagePixelCount v360;
  void *v361;
  const void *v362;
  int **v363;
  int v364;
  int v365;
  int v366;
  int v367;
  int v368;
  BOOL v369;
  int v370;
  char *v371;
  int v372;
  vImagePixelCount v373;
  vImagePixelCount v374;
  void *v375;
  const void *v376;
  int **v377;
  int v378;
  int v379;
  int v380;
  int v381;
  int v382;
  BOOL v383;
  int v384;
  char *v385;
  int v386;
  vImagePixelCount v387;
  vImagePixelCount v388;
  void *v389;
  const void *v390;
  int **v391;
  int v392;
  int v393;
  int v394;
  int v395;
  int v396;
  BOOL v397;
  int v398;
  char *v399;
  int v400;
  vImagePixelCount v401;
  vImagePixelCount v402;
  void *v403;
  const void *v404;
  int **v405;
  int v406;
  int v407;
  int v408;
  int v409;
  int v410;
  BOOL v411;
  int v412;
  char *v413;
  int v414;
  vImagePixelCount v415;
  vImagePixelCount v416;
  void *v417;
  const void *v418;
  int **v419;
  int v420;
  int v421;
  int v422;
  int v423;
  int v424;
  BOOL v425;
  int v426;
  char *v427;
  int v428;
  vImagePixelCount v429;
  vImagePixelCount v430;
  void *v431;
  const void *v432;
  int **v433;
  int v434;
  int v435;
  int v436;
  int v437;
  int v438;
  BOOL v439;
  int v440;
  char *v441;
  unsigned __int8 *v442;
  uint64_t v443;
  void **v444;
  int data;
  vImagePixelCount v446;
  int v447;
  unint64_t v448;
  vDSP_Length *v449;
  const unsigned __int16 *v450;
  float *v451;
  float v452;
  unint64_t v453;
  signed int v454;
  _DWORD **v455;
  uint64_t v456;
  signed int v457;
  int v458;
  int v459;
  int v460;
  int v461;
  BOOL v462;
  _BOOL8 v463;
  uint64_t v464;
  vDSP_Length *v465;
  unsigned __int16 *v466;
  uint64_t v467;
  uint64_t v468;
  uint64_t v469;
  void *v470;
  vImagePixelCount v471;
  uint64_t v472;
  __int16 *v473;
  int v474;
  float v475;
  vImagePixelCount v476;
  int v477;
  int v478;
  _DWORD *v479;
  _DWORD *v480;
  uint64_t v481;
  uint64_t v482;
  __int16 v483;
  vImagePixelCount v484;
  uint64_t v485;
  vImagePixelCount v486;
  unsigned __int16 *v487;
  uint64_t v488;
  unsigned __int16 *v489;
  size_t data_low;
  unsigned int v491;
  char *v492;
  uint64_t v493;
  uint64_t v494;
  uint64_t v495;
  __int16 *v496;
  uint64_t v497;
  int v498;
  uint64_t v499;
  _BYTE *v500;
  uint64_t v501;
  int v502;
  int v503;
  __int16 *v504;
  char *v505;
  char *v506;
  int v507;
  _DWORD *v508;
  int v509;
  int v510;
  __int16 *v511;
  char *v512;
  int *v513;
  int v514;
  _DWORD *v515;
  int v516;
  __int16 *v517;
  char *v518;
  int *v519;
  int v520;
  _DWORD *v521;
  int v522;
  __int16 *v523;
  char *v524;
  int *v525;
  int v526;
  _DWORD *v527;
  int v528;
  __int16 *v529;
  void *v530;
  char *v531;
  int v532;
  char *v533;
  uint64_t v534;
  int v535;
  __int16 *v536;
  void *v537;
  _WORD *v538;
  int v539;
  int *v540;
  unint64_t v541;
  int v542;
  __int16 *v543;
  char *v544;
  int *v545;
  uint64_t v546;
  int v547;
  int v548;
  __int16 *v549;
  void *v550;
  char *v551;
  int *v552;
  unint64_t v553;
  int v554;
  int v555;
  __int16 *v556;
  size_t v557;
  __int16 *v558;
  size_t v559;
  __int16 *v560;
  __int16 *v561;
  const void *v562;
  size_t v563;
  uint64_t v564;
  int v565;
  __int16 *v566;
  __int16 v567;
  uint64_t v568;
  int v569;
  __int16 v570;
  int v571;
  uint64_t v572;
  int v573;
  __int16 *v574;
  __int16 v575;
  uint64_t v576;
  int v577;
  __int16 v578;
  int v579;
  uint64_t v580;
  int v581;
  __int16 *v582;
  __int16 v583;
  uint64_t v584;
  int v585;
  __int16 v586;
  int v587;
  uint64_t v588;
  __int16 *v589;
  uint64_t v590;
  uint64_t v591;
  uint64_t v592;
  uint64_t v593;
  uint64_t v594;
  uint64_t v595;
  int v596;
  vImagePixelCount v597;
  vImagePixelCount v598;
  int v599;
  float v600;
  float v601;
  uint64_t v602;
  int v603;
  int v604;
  uint64_t v605;
  unsigned int v606;
  _WORD *v607;
  unsigned __int16 *v608;
  char *v609;
  uint64_t v610;
  __int16 *v611;
  _WORD *v612;
  __int16 *v613;
  vImage_Buffer *v614;
  int v615;
  int v616;
  BOOL v617;
  int v618;
  int v619;
  unint64_t v621;
  unint64_t v622;
  unint64_t v623;
  uint64_t v624;
  int *v625;
  uint64_t v626;
  int *v627;
  int v628;
  int v629;
  int *v630;
  int v631;
  int v632;
  int v633;
  int v634;
  unsigned int v635;
  unsigned int v636;
  BOOL v637;
  _BOOL4 v638;
  unsigned int v639;
  uint64_t v640;
  uint64_t v641;
  unint64_t v642;
  unint64_t v643;
  unint64_t v644;
  float v645;
  int v646;
  int v647;
  int v648;
  _QWORD *v649;
  int v650;
  int v651;
  int j;
  uint64_t v653;
  unsigned int v654;
  int v655;
  int v656;
  BOOL v657;
  char *v658;
  unsigned int v659;
  char v660;
  int v661;
  int v662;
  int v663;
  int v664;
  int v665;
  char *v666;
  int v667;
  int v668;
  int v671;
  char *v672;
  int v673;
  int v674;
  unsigned __int16 *v677;
  int v678;
  BOOL v679;
  int v680;
  int v681;
  signed int v682;
  signed int v683;
  BOOL v684;
  int v685;
  uint64_t v686;
  float v687;
  void *v688;
  int v689;
  uint64_t v690;
  unsigned int v691;
  unsigned int v692;
  vImagePixelCount v693;
  int v694;
  _BYTE *v695;
  vImagePixelCount v696;
  _BYTE *v697;
  int v698;
  vImagePixelCount v699;
  uint64_t *v700;
  uint64_t *v701;
  uint64_t v702;
  __int16 *v703;
  int v704;
  int v705;
  uint64_t v706;
  int v707;
  int v708;
  unint64_t v709;
  unint64_t v710;
  uint64_t BridgeSegment;
  uint64_t v712;
  uint64_t v713;
  uint64_t v714;
  __int16 *v715;
  char *v716;
  uint64_t v717;
  float *v718;
  int v719;
  unsigned int v720;
  char *v721;
  vDSP_Length *v722;
  float *v723;
  float32x2_t *v724;
  _BYTE *v725;
  vDSP_Length v726;
  float *v727;
  float v732;
  float *v733;
  uint64_t m;
  uint64_t v735;
  float32x2_t v736;
  char *v737;
  __int128 v738;
  __int128 v739;
  signed int v740;
  int v741;
  vDSP_Length v742;
  float32x4_t *v743;
  int v744;
  float *v745;
  uint64_t v746;
  uint64_t v747;
  vDSP_Length v748;
  uint64_t v749;
  char *v750;
  float v751;
  float32x4_t v752;
  float32x4_t v753;
  uint64_t v754;
  int *v755;
  uint64_t v756;
  vDSP_Length v757;
  float32x4_t *v758;
  float32x4_t v759;
  float32x4_t v760;
  float32x4_t v761;
  float32x4_t *v762;
  float v763;
  float *v764;
  void *v765;
  int *v766;
  float *v767;
  float v768;
  uint64_t k;
  int v770;
  void *v771;
  int v772;
  void **v773;
  int v774;
  void *v779;
  _BYTE *v780;
  int v781;
  uint64_t v782;
  char *v783;
  char *v784;
  float *__E;
  __int16 v786;
  int v787;
  vImagePixelCount v788;
  uint64_t v789;
  uint64_t data_high;
  vImagePixelCount v791;
  uint64_t v792;
  unint64_t v793;
  unint64_t v794;
  uint64_t v795;
  vImagePixelCount v796;
  uint64_t v797;
  size_t v798;
  int v799;
  uint64_t v800;
  void *__NR;
  vDSP_Length __NRa;
  size_t v803;
  uint64_t v804;
  int v805;
  size_t v806;
  int v807;
  _BYTE *v808;
  char *v809;
  void *v810;
  void *v811;
  size_t __n;
  uint64_t __na;
  size_t v814;
  uint64_t v815;
  int v816;
  void *v817;
  unsigned __int8 *v818;
  unint64_t v819;
  unint64_t v820;
  unint64_t v821;
  int v822;
  unsigned int *v823;
  uint64_t v824;
  int v825;
  size_t v826;
  char **v827;
  int v828;
  char *v829;
  uint64_t v830;
  char *v831;
  size_t v832;
  uint64_t v833;
  char *v834;
  __int16 v835;
  uint64_t size;
  char *sizea;
  unsigned __int8 *sizeb;
  size_t sizec;
  int sized;
  __int16 sizee;
  uint64_t v842;
  int *v843;
  int v844;
  __int16 v845;
  int v846;
  const void **v847;
  vImagePixelCount v848;
  __int16 v849;
  unint64_t v850;
  int *v851;
  unint64_t __src;
  float *__srca;
  void *v854[2];
  __int128 v855;
  vImage_Buffer v856;
  vImage_Buffer v857;
  vImage_Buffer v858;
  vImage_Buffer v859;
  vImage_Buffer v860;
  vImage_Buffer v861;
  vImage_Buffer src;
  vImage_Buffer dest;
  vImage_Buffer destB;
  vImage_Buffer destG;
  int v866;
  vImage_Buffer destR;
  vImage_Buffer v868;
  _BYTE v869[32];
  int v870;
  vImage_Buffer destA;
  __int128 kernel;
  __int128 v873;
  __int128 v874;
  __int128 v875;
  __int128 v876;
  __int128 v877;
  __int128 v878;
  uint64_t v879;
  float32x4x2_t v880;

  v879 = *MEMORY[0x1E0C80C00];
  height = a1->height;
  width = a1->width;
  v9 = height * width;
  *(_OWORD *)v854 = 0u;
  v855 = 0u;
  v10 = *(float *)(a2 + 4) * 3.14159265 / 180.0;
  *(float *)(a2 + 76) = sinf(v10);
  v11 = *(float *)(a2 + 24);
  if (*(float *)(a2 + 40) >= v11)
    v12 = *(float *)(a2 + 24);
  else
    v12 = *(float *)(a2 + 40);
  *(float *)(a2 + 40) = v12;
  v13 = (float)(90.0 - v12) * 3.14159265 / 180.0;
  *(float *)(a2 + 80) = fabsf(sinf(v13));
  v14 = (float)(90.0 - v11) * 3.14159265 / 180.0;
  v15 = sinf(v14);
  v16 = *(float *)(a2 + 12) + 1.0;
  *(float *)(a2 + 84) = fabsf(v15);
  *(float *)(a2 + 88) = v16;
  v17 = *(float *)(a2 + 44);
  v18 = v12 * 3.14159265 / 180.0;
  v19 = (float)((float)(v17 * cosf(v18)) * 12.566)
      / (float)((float)((float)(v17 + 1.0) + (float)(v17 + 1.0)) * (float)((float)(v17 + 1.0) + (float)(v17 + 1.0)));
  v796 = width;
  v798 = height * width;
  __NR = (void *)height;
  if ((int)height >= (int)width)
    v20 = width;
  else
    v20 = height;
  v21 = *(float *)(a2 + 64) * (float)v20;
  *(float *)(a2 + 92) = v19;
  *(float *)(a2 + 96) = v21;
  v22 = *(float *)(a2 + 28);
  *(float *)(a2 + 100) = floorf(v21 * *(float *)(a2 + 32));
  *(_DWORD *)(a2 + 104) = 1094713344;
  v792 = a2;
  *(float *)(a2 + 108) = v22 * v22;
  size = 4 * v9;
  __E = (float *)malloc_type_malloc(4 * v9, 0x100004052888210uLL);
  v23 = a1->height;
  v24 = a1->width;
  v866 = v23 * v24;
  v25 = (char *)malloc_type_malloc(4 * v23 * v24, 0xC428C5D6uLL);
  destA.width = v24;
  destA.rowBytes = v24;
  destA.height = v23;
  destA.data = v25;
  destR.width = v24;
  destR.rowBytes = v24;
  destR.height = v23;
  destR.data = &v25[v23 * v24];
  destG.width = v24;
  destG.rowBytes = v24;
  destG.height = v23;
  destG.data = &v25[2 * v23 * v24];
  destB.width = v24;
  destB.rowBytes = v24;
  destB.height = v23;
  destB.data = &v25[3 * v23 * v24];
  vImageConvert_ARGB8888toPlanar8(a1, &destA, &destR, &destG, &destB, 0);
  v26 = (char *)malloc_type_malloc(12 * v23 * v24, 0x100004052888210uLL);
  dest.width = v24;
  dest.rowBytes = 4 * v24;
  dest.height = v23;
  dest.data = v26;
  src.width = v24;
  src.rowBytes = 4 * v24;
  src.height = v23;
  src.data = &v26[4 * v23 * v24];
  v868.width = v24;
  v868.rowBytes = 4 * v24;
  v868.height = v23;
  v868.data = &v26[8 * v23 * v24];
  vImageConvert_Planar8toPlanarF(&destG, &dest, 255.0, 0.0, 0);
  vImageConvert_Planar8toPlanarF(&destR, &src, 255.0, 0.0, 0);
  vImageConvert_Planar8toPlanarF(&destA, &v868, 255.0, 0.0, 0);
  HIDWORD(v850) = 1112806349;
  __src = 3256219162;
  kernel = xmmword_1A15FB770;
  v873 = xmmword_1A15FB780;
  LODWORD(v874) = 1108735514;
  v27 = (char *)malloc_type_malloc(12 * v23 * v24, 0x100004052888210uLL);
  v861.width = v24;
  v861.rowBytes = 4 * v24;
  v861.height = v23;
  v861.data = v27;
  v860.width = v24;
  v860.rowBytes = 4 * v24;
  v860.height = v23;
  v860.data = &v27[4 * v23 * v24];
  v859.width = v24;
  v859.rowBytes = 4 * v24;
  v859.height = v23;
  v859.data = &v27[8 * v23 * v24];
  vImageConvolve_PlanarF(&dest, &v861, 0, 0, 0, (const float *)&kernel, 3u, 3u, 0.0, 4u);
  vImageConvolve_PlanarF(&src, &v860, 0, 0, 0, (const float *)&kernel, 3u, 3u, 0.0, 4u);
  vImageConvolve_PlanarF(&v868, &v859, 0, 0, 0, (const float *)&kernel, 3u, 3u, 0.0, 4u);
  vDSP_vmaxmg((const float *)v861.data, 1, (const float *)v860.data, 1, (float *)v861.data, 1, v23 * v24);
  vDSP_vmaxmg((const float *)v861.data, 1, (const float *)v859.data, 1, (float *)v861.data, 1, v23 * v24);
  vvnintf((float *)v861.data, (const float *)v861.data, &v866);
  *(_OWORD *)v869 = xmmword_1A15FB790;
  *(_OWORD *)&v869[16] = xmmword_1A15FB7A0;
  v870 = 1108735514;
  v28 = (char *)malloc_type_malloc(12 * v23 * v24, 0x100004052888210uLL);
  v858.width = v24;
  v858.rowBytes = 4 * v24;
  v858.height = v23;
  v858.data = v28;
  v857.width = v24;
  v857.rowBytes = 4 * v24;
  v857.height = v23;
  v857.data = &v28[4 * v23 * v24];
  v856.width = v24;
  v856.rowBytes = 4 * v24;
  v856.data = &v28[8 * v23 * v24];
  v856.height = v23;
  vImageConvolve_PlanarF(&dest, &v858, 0, 0, 0, (const float *)v869, 3u, 3u, 0.0, 4u);
  vImageConvolve_PlanarF(&src, &v857, 0, 0, 0, (const float *)v869, 3u, 3u, 0.0, 4u);
  vImageConvolve_PlanarF(&v868, &v856, 0, 0, 0, (const float *)v869, 3u, 3u, 0.0, 4u);
  vDSP_vmaxmg((const float *)v858.data, 1, (const float *)v857.data, 1, (float *)v858.data, 1, v23 * v24);
  vDSP_vmaxmg((const float *)v858.data, 1, (const float *)v856.data, 1, (float *)v858.data, 1, v23 * v24);
  vvnintf((float *)v858.data, (const float *)v858.data, &v866);
  vDSP_vmma((const float *)v861.data, 1, (const float *)v861.data, 1, (const float *)v858.data, 1, (const float *)v858.data, 1, __E, 1, v23 * v24);
  if (v25)
    free(v25);
  if (v26)
    free(v26);
  if (v27)
    free(v27);
  if (v28)
    free(v28);
  destG.width = v796;
  destG.height = height;
  destG.rowBytes = 4 * v796;
  v29 = malloc_type_malloc(size, 0x100004052888210uLL);
  v30 = 0;
  destG.data = v29;
  v31 = 0.0;
  do
  {
    v32 = expf((float)((float)((float)(int)v30 * 2.5) * 0.5)* (float)((float)((float)((float)(int)v30 * 2.5) * 0.5) * -0.5));
    *(float *)&v869[4 * v30 + 8] = v32;
    v31 = v31 + (float)(v32 * 2.0);
    ++v30;
  }
  while (v30 != 3);
  for (i = 8; i != 20; i += 4)
    *(float *)&v869[i] = (float)(1.0 / (float)(v31 + -1.0)) * *(float *)&v869[i];
  v34 = 0;
  *(int32x2_t *)v869 = vrev64_s32(*(int32x2_t *)&v869[12]);
  p_kernel = &kernel;
  do
  {
    v36 = 0;
    v37 = *(float *)&v869[4 * v34];
    do
    {
      *(float *)((char *)p_kernel + v36) = v37 * *(float *)&v869[v36];
      v36 += 4;
    }
    while (v36 != 20);
    p_kernel = (__int128 *)((char *)p_kernel + 20);
    ++v34;
  }
  while (v34 != 5);
  vDSP_f5x5(__E, height, v796, (const float *)&kernel, (float *)v29);
  LODWORD(destA.data) = v798;
  vvsqrtf((float *)destG.data, (const float *)destG.data, (const int *)&destA);
  vvsqrtf((float *)destG.data, (const float *)destG.data, (const int *)&destA);
  destB.width = v796;
  destB.height = height;
  destB.rowBytes = 2 * v796;
  sizea = (char *)malloc_type_malloc(2 * v798, 0x1000040BDFB0063uLL);
  destB.data = sizea;
  dest.width = v796;
  dest.height = height;
  dest.rowBytes = 2 * v796;
  v38 = (char *)malloc_type_malloc(2 * v798, 0x1000040BDFB0063uLL);
  dest.data = v38;
  src.width = v796;
  src.height = height;
  src.rowBytes = 2 * v796;
  v39 = (char *)malloc_type_malloc(2 * v798, 0x1000040BDFB0063uLL);
  src.data = v39;
  v40 = destG.width;
  v41 = destG.height;
  v42 = destG.height * destG.width;
  LODWORD(v868.data) = LODWORD(destG.height) * LODWORD(destG.width);
  kernel = xmmword_1A15FB770;
  v873 = xmmword_1A15FB780;
  LODWORD(v874) = 1108735514;
  v43 = malloc_type_malloc(4 * destG.height * destG.width, 0x100004052888210uLL);
  destA.width = v40;
  destA.rowBytes = 4 * v40;
  destA.height = v41;
  destA.data = v43;
  v44 = (float *)malloc_type_malloc(4 * v42, 0x100004052888210uLL);
  vImageConvolve_PlanarF(&destG, &destA, 0, 0, 0, (const float *)&kernel, 3u, 3u, 0.0, 4u);
  vvintf((float *)destA.data, (const float *)destA.data, (const int *)&v868);
  vDSP_vfixr16((const float *)destA.data, 1, (__int16 *)v38, 1, v42);
  *(_OWORD *)v869 = xmmword_1A15FB790;
  *(_OWORD *)&v869[16] = xmmword_1A15FB7A0;
  v870 = 1108735514;
  v45 = malloc_type_malloc(4 * v42, 0x100004052888210uLL);
  destR.width = v40;
  destR.rowBytes = 4 * v40;
  destR.height = v41;
  destR.data = v45;
  vImageConvolve_PlanarF(&destG, &destR, 0, 0, 0, (const float *)v869, 3u, 3u, 0.0, 4u);
  vvintf((float *)destR.data, (const float *)destR.data, (const int *)&v868);
  vDSP_vfixr16((const float *)destR.data, 1, (__int16 *)v39, 1, v42);
  vDSP_vdist((const float *)destA.data, 1, (const float *)destR.data, 1, v44, 1, v42);
  vDSP_vfixru16(v44, 1, (unsigned __int16 *)sizea, 1, v42);
  if (v43)
    free(v43);
  if (v44)
    free(v44);
  if (v45)
    free(v45);
  qd_trimImageBorders((char **)&destB);
  qd_trimImageBorders((char **)&dest);
  qd_trimImageBorders((char **)&src);
  v46 = (char *)malloc_type_malloc(v798, 0x100004077774924uLL);
  v47 = v46;
  if ((int)__NR >= 4)
    v48 = 4;
  else
    v48 = (int)__NR;
  v49 = v796;
  v50 = v48 * (uint64_t)(int)v796;
  bzero(v46, v50);
  v51 = (_DWORD)__NR - v48;
  bzero(&v47[((int)__NR - v48) * (uint64_t)(int)v796], v50);
  v780 = v47;
  if (v48 < (int)__NR - v48)
  {
    v52 = &v47[v50];
    v53 = (int)v796;
    v54 = &v47[v50 + (int)v796 - v48];
    v55 = (int)__NR;
    if ((int)__NR >= 4)
      v55 = 4;
    v56 = v48;
    do
    {
      if ((int)__NR >= 1)
      {
        v57 = 0;
        do
        {
          v52[v57] = 0;
          v54[v57++] = 0;
        }
        while (v55 != (_DWORD)v57);
      }
      ++v56;
      v52 += (int)v796;
      v54 += (int)v796;
    }
    while (v56 != v51);
    v58 = v48 + v48 * (uint64_t)(int)v796;
    v59 = 2 * v58;
    v60 = 2 * (int)v796;
    v61 = &v47[v58];
    v62 = (uint64_t)&sizea[v60 - 2];
    v63 = sizea + 2;
    v64 = &sizea[-v60];
    v65 = v48;
    while (v48 >= (int)v796 - v48)
    {
LABEL_68:
      ++v65;
      v61 += (int)v796;
      v39 += v60;
      v38 += v60;
      v62 += v60;
      v63 += v60;
      v64 += v60;
      if (v65 == v51)
      {
        v49 = v796;
        goto LABEL_71;
      }
    }
    v66 = 0;
    v67 = v64;
    v68 = v63;
    v69 = v62;
    v70 = v38;
    v71 = v39;
    while (1)
    {
      v72 = *(unsigned __int16 *)&v68[v59 - 2];
      if (*(_WORD *)&v68[v59 - 2])
        break;
      v80 = 0;
LABEL_67:
      v61[v66++] = v80;
      v71 += 2;
      v70 += 2;
      v69 += 2;
      v68 += 2;
      v67 += 2;
      if ((_DWORD)v796 - 2 * v48 == (_DWORD)v66)
        goto LABEL_68;
    }
    v73 = *(__int16 *)&v70[v59];
    v74 = (float)-v73 / (float)v72;
    v75 = *(__int16 *)&v71[v59];
    v76 = (float)v75 / (float)v72;
    if ((v73 & 0x80000000) != 0)
    {
      if ((v75 & 0x80000000) == 0)
      {
        if ((signed int)-v73 < v75)
        {
          v77 = (float)(v76 * (float)(int)(*(__int16 *)&v67[v59] - v72))
              + (float)((float)(*(__int16 *)&v67[v59 + 2] - *(__int16 *)&v67[v59]) * v74);
          v78 = *(__int16 *)(v69 + v59 + 2);
          v79 = *(__int16 *)(v69 + v59) - v78;
          goto LABEL_52;
        }
        v77 = (float)(v76 * (float)(*(__int16 *)&v67[v59 + 2] - *(__int16 *)&v68[v59]))
            + (float)((float)(int)(*(__int16 *)&v68[v59] - v72) * v74);
        v83 = *(__int16 *)&v68[v59 - 4];
        v84 = *(__int16 *)(v69 + v59);
        v79 = v83 - v72;
LABEL_59:
        v81 = v84 - v83;
        goto LABEL_64;
      }
      if (v75 <= v73)
      {
        v77 = (float)(v76 * (float)(int)(v72 - *(__int16 *)(v69 + v59 + 2)))
            + (float)((float)(*(__int16 *)(v69 + v59 + 4) - *(__int16 *)(v69 + v59 + 2)) * v74);
        v82 = *(__int16 *)&v67[v59];
        v79 = *(__int16 *)&v67[v59 - 2] - v82;
        goto LABEL_63;
      }
      v77 = (float)(v76 * (float)(*(__int16 *)&v68[v59] - *(__int16 *)(v69 + v59 + 4)))
          + (float)((float)(int)(*(__int16 *)&v68[v59] - v72) * v74);
      v85 = *(__int16 *)&v68[v59 - 4];
      v86 = *(__int16 *)&v67[v59 - 2];
      v79 = v85 - v72;
    }
    else
    {
      if ((v75 & 0x80000000) == 0)
      {
        if (v73 < v75)
        {
          v77 = (float)(v76 * (float)(int)(*(__int16 *)&v67[v59] - v72))
              + (float)((float)(*(__int16 *)&v67[v59] - *(__int16 *)&v67[v59 - 2]) * v74);
          v78 = *(__int16 *)(v69 + v59 + 2);
          v79 = v78 - *(__int16 *)(v69 + v59 + 4);
LABEL_52:
          v81 = v78 - v72;
LABEL_64:
          v80 = 0;
          if (v77 <= 0.0)
          {
            v87 = (float)(v76 * (float)v81) + (float)((float)v79 * v74);
            if (v87 <= 0.0)
              v80 = v87 != 0.0;
          }
          goto LABEL_67;
        }
        v77 = (float)(v76 * (float)(*(__int16 *)&v67[v59 - 2] - *(__int16 *)&v68[v59 - 4]))
            + (float)((float)(int)(v72 - *(__int16 *)&v68[v59 - 4]) * v74);
        v83 = *(__int16 *)&v68[v59];
        v84 = *(__int16 *)(v69 + v59 + 4);
        v79 = v72 - v83;
        goto LABEL_59;
      }
      if ((int)v73 < -v75)
      {
        v77 = (float)(v76 * (float)(int)(v72 - *(__int16 *)(v69 + v59 + 2)))
            + (float)((float)(*(__int16 *)(v69 + v59 + 2) - *(__int16 *)(v69 + v59)) * v74);
        v82 = *(__int16 *)&v67[v59];
        v79 = v82 - *(__int16 *)&v67[v59 + 2];
LABEL_63:
        v81 = v72 - v82;
        goto LABEL_64;
      }
      v77 = (float)(v76 * (float)(*(__int16 *)&v68[v59 - 4] - *(__int16 *)(v69 + v59)))
          + (float)((float)(int)(v72 - *(__int16 *)&v68[v59 - 4]) * v74);
      v85 = *(__int16 *)&v68[v59];
      v86 = *(__int16 *)&v67[v59 + 2];
      v79 = v72 - v85;
    }
    v81 = v85 - v86;
    goto LABEL_64;
  }
  v53 = (int)v796;
LABEL_71:
  v88 = (char *)malloc_type_malloc(v798, 0x100004077774924uLL);
  v89 = (char *)malloc_type_malloc(v798, 0x100004077774924uLL);
  bzero(v89, v53);
  v779 = v89;
  v784 = v88;
  if ((int)__NR < 4)
  {
    bzero(v89, v53);
    bzero(v88, v53);
    v105 = v88;
  }
  else
  {
    v90 = (_DWORD)__NR - 2;
    v91 = v89;
    v92 = (v49 - 1);
    v93 = 1;
    v94 = v780;
    do
    {
      if (v93 == 1)
        v95 = v53;
      else
        v95 = 0;
      v96 = &v94[v95];
      v97 = &v91[v95];
      *v97 = 0;
      if (v92 < 2)
      {
        v103 = 1;
      }
      else
      {
        v98 = v96 + 2;
        v99 = (8 * (v96[-v53 + 1] & 1)) & 0xC8 | (16 * (v96[1] & 1)) & 0xD8 | (32 * (v96[v53 + 1] & 1)) | v96[-v53] & 1 | (2 * (*v96 & 1)) & 0xFB | (4 * (v96[v53] & 1));
        v100 = v97 + 1;
        v101 = v92 - 1;
        do
        {
          v102 = ((*v98 & 1) << 7) | ((v98[-v53] & 1) << 6) | ((v98[v53] & 1) << 8) | v99;
          *v100++ = qdthin1[v102];
          v99 = v102 >> 3;
          ++v98;
          --v101;
        }
        while (v101);
        v103 = v49 - 1;
      }
      v94 = &v96[v53];
      v97[v103] = 0;
      v91 = &v97[v53];
      ++v93;
    }
    while (v93 != v90);
    bzero(v91, v53);
    bzero(v784, v53);
    v104 = 1;
    v105 = v784;
    v106 = v89;
    do
    {
      if (v104 == 1)
        v107 = v53;
      else
        v107 = 0;
      v108 = &v106[v107];
      v109 = &v105[v107];
      *v109 = 0;
      if (v92 < 2)
      {
        v115 = 1;
      }
      else
      {
        v110 = v108 + 2;
        v111 = (8 * (v108[-v53 + 1] & 1)) & 0xC8 | (16 * (v108[1] & 1)) & 0xD8 | (32 * (v108[v53 + 1] & 1)) | v108[-v53] & 1 | (2 * (*v108 & 1)) & 0xFB | (4 * (v108[v53] & 1));
        v112 = v109 + 1;
        v113 = v92 - 1;
        do
        {
          v114 = ((*v110 & 1) << 7) | ((v110[-v53] & 1) << 6) | ((v110[v53] & 1) << 8) | v111;
          *v112++ = qdthin2[v114];
          v111 = v114 >> 3;
          ++v110;
          --v113;
        }
        while (v113);
        v115 = v49 - 1;
      }
      v106 = &v108[v53];
      v109[v115] = 0;
      v105 = &v109[v53];
      ++v104;
    }
    while (v104 != v90);
  }
  bzero(v105, v53);
  *(_QWORD *)&v869[16] = v796;
  *(_QWORD *)&v869[8] = __NR;
  *(_QWORD *)&v869[24] = v796;
  v116 = (char *)malloc_type_malloc(v798, 0x100004077774924uLL);
  *(_QWORD *)v869 = v116;
  v117 = *(_DWORD *)&v869[24];
  bzero(v116, v53);
  if ((int)__NR >= 4)
  {
    v118 = (v796 - 1);
    v119 = 1;
    v120 = v784;
    do
    {
      if (v119 == 1)
        v121 = v53;
      else
        v121 = 0;
      v122 = &v120[v121];
      if (v119 == 1)
        v123 = v117;
      else
        v123 = 0;
      v124 = &v116[v123];
      *v124 = 0;
      if (v118 < 2)
      {
        v130 = 1;
      }
      else
      {
        v125 = v122 + 2;
        v126 = (8 * (v122[-v53 + 1] & 1)) & 0xC8 | (16 * (v122[1] & 1)) & 0xD8 | (32 * (v122[v53 + 1] & 1)) | v122[-v53] & 1 | (2 * (*v122 & 1)) & 0xFB | (4 * (v122[v53] & 1));
        v127 = v124 + 1;
        v128 = v118 - 1;
        do
        {
          v129 = ((*v125 & 1) << 7) | ((v125[-v53] & 1) << 6) | ((v125[v53] & 1) << 8) | v126;
          *v127++ = *((_BYTE *)&triplet + v129);
          v126 = v129 >> 3;
          ++v125;
          --v128;
        }
        while (v128);
        v130 = v796 - 1;
      }
      v120 = &v122[v53];
      v124[v130] = 0;
      v116 = &v124[v117];
      _ZF = v119++ == (_DWORD)__NR - 3;
    }
    while (!_ZF);
  }
  bzero(v116, v53);
  destR.data = 0;
  destR.width = (vImagePixelCount)malloc_type_calloc(0x4000uLL, 0x28uLL, 0x102004082217F83uLL);
  destR.height = 0;
  v846 = *(_DWORD *)(v792 + 36);
  v131 = *(_DWORD *)&v869[16];
  v132 = *(_DWORD *)&v869[8];
  v826 = *(_QWORD *)v869;
  v133 = *(int *)&v869[16];
  v831 = (char *)malloc_type_calloc(4uLL, *(int *)&v869[16], 0x3E277EDEuLL);
  v803 = v133;
  v134 = (char *)malloc_type_calloc(4uLL, v133, 0x310C36A0uLL);
  v135 = (char *)malloc_type_malloc(24 * ((v131 >> 1) + 1), 0x108004098BBCF0FuLL);
  v807 = v131 >> 1;
  v136 = (uint64_t)((v131 >> 1) + 8) >> 3;
  v137 = malloc_type_calloc(v136, 1uLL, 0x100004077774924uLL);
  sizeb = (unsigned __int8 *)malloc_type_calloc(v136, 1uLL, 0x100004077774924uLL);
  v138 = (unsigned __int8 *)malloc_type_calloc(v136, 1uLL, 0x100004077774924uLL);
  v820 = (unint64_t)v137;
  v806 = v136;
  memset(v137, 255, v136);
  v139 = malloc_type_calloc(0x4000uLL, 8uLL, 0x2004093837F09uLL);
  if ((v131 & 0x80000000) == 0)
  {
    v140 = ((v131 >> 1) & ~(v131 >> 31)) + 1;
    v141 = v135;
    do
    {
      if (v141)
      {
        *v141 = 0x2000000004;
        v141[2] = malloc_type_malloc(0x80uLL, 0xE36368ECuLL);
        v141[1] = 0xF00000010;
      }
      v141 += 3;
      --v140;
    }
    while (v140);
  }
  LODWORD(kernel) = 0;
  __n = (size_t)v139;
  v805 = v131;
  LODWORD(v142) = 0;
  if (v132 >= 3)
  {
    v816 = 0;
    v143 = (v131 - 1);
    v800 = 4 * v131;
    v814 = ((v131 >> 4) & ~(v131 >> 31)) + 1;
    if ((int)v806 <= 1)
      v144 = 1;
    else
      v144 = v806;
    v799 = v132 - 2;
    v842 = 192 * v144;
    v822 = 1;
    v821 = (v131 - 1);
    while (1)
    {
      v146 = v831;
      v145 = sizeb;
      v831 = v134;
      sizeb = v138;
      v147 = v826 + v803;
      v826 += v803;
      v818 = v145;
      v809 = v146;
      if (v131 >= 3)
        break;
LABEL_220:
      bzero(v809, v800);
      if ((v131 & 0x80000000) == 0)
      {
        v201 = 0;
        v202 = v818;
        v203 = (_BYTE *)v820;
        v204 = sizeb;
        v205 = v846;
        do
        {
          v206 = *v202;
          v850 = (unint64_t)(v202 + 1);
          __src = (unint64_t)(v204 + 1);
          v207 = v206 & ~*v204;
          if ((v206 & (*v204 ^ 0xFF)) == 0)
            goto LABEL_335;
          if ((v206 & ~*v204 & 1) != 0)
          {
            v208 = (uint64_t)&v135[v201];
            if (v135)
              v209 = *(_DWORD *)(v208 + 12) - *(_DWORD *)(v208 + 8) + 1;
            else
              v209 = 0;
            if (v209 >= v205)
            {
              if ((int)v142 >= 0x3FFF)
                __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 276, "cidcnt < MAX_CONTOURS");
              v142 = (int)v142 + 1;
              LODWORD(destR.data) = v142;
              v210 = destR.width;
              v211 = destR.width + 40 * v142;
              *(_DWORD *)(v211 + 4) = v209;
              *(_BYTE *)v211 = 1;
              *(_DWORD *)(v211 + 12) = 0;
              *(_QWORD *)(v211 + 24) = 0;
              v212 = malloc_type_malloc(4 * (v209 + 2), 0x100004052888210uLL);
              *(_QWORD *)(v211 + 16) = v212;
              v213 = (int **)(v211 + 16);
              if (v135 && (v214 = *(_DWORD *)&v135[v201 + 8], v214 <= *(_DWORD *)&v135[v201 + 12]))
                v215 = (const void *)(*(_QWORD *)&v135[v201 + 16] + *(int *)&v135[v201] * (uint64_t)v214);
              else
                v215 = 0;
              memcpy(v212, v215, 4 * v209);
              v216 = (*v213)[v209 - 1];
              v217 = **v213;
              v218 = (__int16)v217 - (__int16)v216;
              if (v218 < 0)
                v218 = (__int16)v216 - (__int16)v217;
              if (v218 > 1)
              {
                v220 = 0;
              }
              else
              {
                v219 = (v217 >> 16) - (v216 >> 16);
                if (v219 < 0)
                  v219 = -v219;
                v220 = v219 < 2;
              }
              *(_BYTE *)(v210 + 40 * v142 + 8) = v220;
            }
            else
            {
              eraseContourPixels(v208, *(uint64_t *)v869, *(int *)&v869[24]);
            }
            *v203 |= 1u;
            if (v135)
            {
              v221 = &v135[v201];
              v222 = *(int *)&v135[v201 + 4] >> 1;
              *((_DWORD *)v221 + 2) = v222;
              *((_DWORD *)v221 + 3) = v222 - 1;
            }
          }
          if ((v207 & 2) != 0)
          {
            v223 = &v135[v201];
            v224 = *(_DWORD *)&v135[v201 + 36] - *(_DWORD *)&v135[v201 + 32] + 1;
            if (v224 >= v205)
            {
              if ((int)v142 >= 0x3FFF)
                __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 277, "cidcnt < MAX_CONTOURS");
              v142 = (int)v142 + 1;
              LODWORD(destR.data) = v142;
              v225 = destR.width;
              v226 = destR.width + 40 * v142;
              *(_DWORD *)(v226 + 4) = v224;
              *(_BYTE *)v226 = 1;
              *(_DWORD *)(v226 + 12) = 0;
              *(_QWORD *)(v226 + 24) = 0;
              v227 = malloc_type_malloc(4 * (v224 + 2), 0x100004052888210uLL);
              v228 = 0;
              *(_QWORD *)(v226 + 16) = v227;
              v229 = (int **)(v226 + 16);
              v230 = *((_DWORD *)v223 + 8);
              if (v230 <= *((_DWORD *)v223 + 9))
                v228 = (const void *)(*(_QWORD *)&v135[v201 + 40] + *(int *)&v135[v201 + 24] * (uint64_t)v230);
              memcpy(v227, v228, 4 * v224);
              v231 = (*v229)[v224 - 1];
              v232 = **v229;
              v233 = (__int16)v232 - (__int16)v231;
              if (v233 < 0)
                v233 = (__int16)v231 - (__int16)v232;
              if (v233 > 1)
              {
                v235 = 0;
              }
              else
              {
                v234 = (v232 >> 16) - (v231 >> 16);
                if (v234 < 0)
                  v234 = -v234;
                v235 = v234 < 2;
              }
              *(_BYTE *)(v225 + 40 * v142 + 8) = v235;
              v205 = v846;
            }
            else
            {
              eraseContourPixels((uint64_t)&v135[v201 + 24], *(uint64_t *)v869, *(int *)&v869[24]);
            }
            *v203 |= 2u;
            v236 = *(int *)&v135[v201 + 28] >> 1;
            *((_DWORD *)v223 + 8) = v236;
            *((_DWORD *)v223 + 9) = v236 - 1;
          }
          if ((v207 & 4) != 0)
          {
            v237 = &v135[v201];
            v238 = *(_DWORD *)&v135[v201 + 60] - *(_DWORD *)&v135[v201 + 56] + 1;
            if (v238 >= v205)
            {
              if ((int)v142 >= 0x3FFF)
                __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 278, "cidcnt < MAX_CONTOURS");
              v142 = (int)v142 + 1;
              LODWORD(destR.data) = v142;
              v239 = destR.width;
              v240 = destR.width + 40 * v142;
              *(_DWORD *)(v240 + 4) = v238;
              *(_BYTE *)v240 = 1;
              *(_DWORD *)(v240 + 12) = 0;
              *(_QWORD *)(v240 + 24) = 0;
              v241 = malloc_type_malloc(4 * (v238 + 2), 0x100004052888210uLL);
              v242 = 0;
              *(_QWORD *)(v240 + 16) = v241;
              v243 = (int **)(v240 + 16);
              v244 = *((_DWORD *)v237 + 14);
              if (v244 <= *((_DWORD *)v237 + 15))
                v242 = (const void *)(*(_QWORD *)&v135[v201 + 64] + *(int *)&v135[v201 + 48] * (uint64_t)v244);
              memcpy(v241, v242, 4 * v238);
              v245 = (*v243)[v238 - 1];
              v246 = **v243;
              v247 = (__int16)v246 - (__int16)v245;
              if (v247 < 0)
                v247 = (__int16)v245 - (__int16)v246;
              if (v247 > 1)
              {
                v249 = 0;
              }
              else
              {
                v248 = (v246 >> 16) - (v245 >> 16);
                if (v248 < 0)
                  v248 = -v248;
                v249 = v248 < 2;
              }
              *(_BYTE *)(v239 + 40 * v142 + 8) = v249;
              v205 = v846;
            }
            else
            {
              eraseContourPixels((uint64_t)&v135[v201 + 48], *(uint64_t *)v869, *(int *)&v869[24]);
            }
            *v203 |= 4u;
            v250 = *(int *)&v135[v201 + 52] >> 1;
            *((_DWORD *)v237 + 14) = v250;
            *((_DWORD *)v237 + 15) = v250 - 1;
          }
          if ((v207 & 8) != 0)
          {
            v251 = &v135[v201];
            v252 = *(_DWORD *)&v135[v201 + 84] - *(_DWORD *)&v135[v201 + 80] + 1;
            if (v252 >= v205)
            {
              if ((int)v142 >= 0x3FFF)
                __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 279, "cidcnt < MAX_CONTOURS");
              v142 = (int)v142 + 1;
              LODWORD(destR.data) = v142;
              v253 = destR.width;
              v254 = destR.width + 40 * v142;
              *(_DWORD *)(v254 + 4) = v252;
              *(_BYTE *)v254 = 1;
              *(_DWORD *)(v254 + 12) = 0;
              *(_QWORD *)(v254 + 24) = 0;
              v255 = malloc_type_malloc(4 * (v252 + 2), 0x100004052888210uLL);
              v256 = 0;
              *(_QWORD *)(v254 + 16) = v255;
              v257 = (int **)(v254 + 16);
              v258 = *((_DWORD *)v251 + 20);
              if (v258 <= *((_DWORD *)v251 + 21))
                v256 = (const void *)(*(_QWORD *)&v135[v201 + 88] + *(int *)&v135[v201 + 72] * (uint64_t)v258);
              memcpy(v255, v256, 4 * v252);
              v259 = (*v257)[v252 - 1];
              v260 = **v257;
              v261 = (__int16)v260 - (__int16)v259;
              if (v261 < 0)
                v261 = (__int16)v259 - (__int16)v260;
              if (v261 > 1)
              {
                v263 = 0;
              }
              else
              {
                v262 = (v260 >> 16) - (v259 >> 16);
                if (v262 < 0)
                  v262 = -v262;
                v263 = v262 < 2;
              }
              *(_BYTE *)(v253 + 40 * v142 + 8) = v263;
              v205 = v846;
            }
            else
            {
              eraseContourPixels((uint64_t)&v135[v201 + 72], *(uint64_t *)v869, *(int *)&v869[24]);
            }
            *v203 |= 8u;
            v264 = *(int *)&v135[v201 + 76] >> 1;
            *((_DWORD *)v251 + 20) = v264;
            *((_DWORD *)v251 + 21) = v264 - 1;
          }
          if ((v207 & 0x10) != 0)
          {
            v265 = &v135[v201];
            v266 = *(_DWORD *)&v135[v201 + 108] - *(_DWORD *)&v135[v201 + 104] + 1;
            if (v266 >= v205)
            {
              if ((int)v142 >= 0x3FFF)
                __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 280, "cidcnt < MAX_CONTOURS");
              v142 = (int)v142 + 1;
              LODWORD(destR.data) = v142;
              v267 = destR.width;
              v268 = destR.width + 40 * v142;
              *(_DWORD *)(v268 + 4) = v266;
              *(_BYTE *)v268 = 1;
              *(_DWORD *)(v268 + 12) = 0;
              *(_QWORD *)(v268 + 24) = 0;
              v269 = malloc_type_malloc(4 * (v266 + 2), 0x100004052888210uLL);
              v270 = 0;
              *(_QWORD *)(v268 + 16) = v269;
              v271 = (int **)(v268 + 16);
              v272 = *((_DWORD *)v265 + 26);
              if (v272 <= *((_DWORD *)v265 + 27))
                v270 = (const void *)(*(_QWORD *)&v135[v201 + 112] + *(int *)&v135[v201 + 96] * (uint64_t)v272);
              memcpy(v269, v270, 4 * v266);
              v273 = (*v271)[v266 - 1];
              v274 = **v271;
              v275 = (__int16)v274 - (__int16)v273;
              if (v275 < 0)
                v275 = (__int16)v273 - (__int16)v274;
              if (v275 > 1)
              {
                v277 = 0;
              }
              else
              {
                v276 = (v274 >> 16) - (v273 >> 16);
                if (v276 < 0)
                  v276 = -v276;
                v277 = v276 < 2;
              }
              *(_BYTE *)(v267 + 40 * v142 + 8) = v277;
              v205 = v846;
            }
            else
            {
              eraseContourPixels((uint64_t)&v135[v201 + 96], *(uint64_t *)v869, *(int *)&v869[24]);
            }
            *v203 |= 0x10u;
            v278 = *(int *)&v135[v201 + 100] >> 1;
            *((_DWORD *)v265 + 26) = v278;
            *((_DWORD *)v265 + 27) = v278 - 1;
          }
          if ((v207 & 0x20) != 0)
          {
            v279 = &v135[v201];
            v280 = *(_DWORD *)&v135[v201 + 132] - *(_DWORD *)&v135[v201 + 128] + 1;
            if (v280 >= v205)
            {
              if ((int)v142 >= 0x3FFF)
                __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 281, "cidcnt < MAX_CONTOURS");
              v142 = (int)v142 + 1;
              LODWORD(destR.data) = v142;
              v281 = destR.width;
              v282 = destR.width + 40 * v142;
              *(_DWORD *)(v282 + 4) = v280;
              *(_BYTE *)v282 = 1;
              *(_DWORD *)(v282 + 12) = 0;
              *(_QWORD *)(v282 + 24) = 0;
              v283 = malloc_type_malloc(4 * (v280 + 2), 0x100004052888210uLL);
              v284 = 0;
              *(_QWORD *)(v282 + 16) = v283;
              v285 = (int **)(v282 + 16);
              v286 = *((_DWORD *)v279 + 32);
              if (v286 <= *((_DWORD *)v279 + 33))
                v284 = (const void *)(*(_QWORD *)&v135[v201 + 136] + *(int *)&v135[v201 + 120] * (uint64_t)v286);
              memcpy(v283, v284, 4 * v280);
              v287 = (*v285)[v280 - 1];
              v288 = **v285;
              v289 = (__int16)v288 - (__int16)v287;
              if (v289 < 0)
                v289 = (__int16)v287 - (__int16)v288;
              if (v289 > 1)
              {
                v291 = 0;
              }
              else
              {
                v290 = (v288 >> 16) - (v287 >> 16);
                if (v290 < 0)
                  v290 = -v290;
                v291 = v290 < 2;
              }
              *(_BYTE *)(v281 + 40 * v142 + 8) = v291;
              v205 = v846;
            }
            else
            {
              eraseContourPixels((uint64_t)&v135[v201 + 120], *(uint64_t *)v869, *(int *)&v869[24]);
            }
            *v203 |= 0x20u;
            v292 = *(int *)&v135[v201 + 124] >> 1;
            *((_DWORD *)v279 + 32) = v292;
            *((_DWORD *)v279 + 33) = v292 - 1;
          }
          if ((v207 & 0x40) != 0)
          {
            v293 = &v135[v201];
            v294 = *(_DWORD *)&v135[v201 + 156] - *(_DWORD *)&v135[v201 + 152] + 1;
            if (v294 >= v205)
            {
              if ((int)v142 >= 0x3FFF)
                __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 282, "cidcnt < MAX_CONTOURS");
              v142 = (int)v142 + 1;
              LODWORD(destR.data) = v142;
              v295 = destR.width;
              v296 = destR.width + 40 * v142;
              *(_DWORD *)(v296 + 4) = v294;
              *(_BYTE *)v296 = 1;
              *(_DWORD *)(v296 + 12) = 0;
              *(_QWORD *)(v296 + 24) = 0;
              v297 = malloc_type_malloc(4 * (v294 + 2), 0x100004052888210uLL);
              v298 = 0;
              *(_QWORD *)(v296 + 16) = v297;
              v299 = (int **)(v296 + 16);
              v300 = *((_DWORD *)v293 + 38);
              if (v300 <= *((_DWORD *)v293 + 39))
                v298 = (const void *)(*(_QWORD *)&v135[v201 + 160] + *(int *)&v135[v201 + 144] * (uint64_t)v300);
              memcpy(v297, v298, 4 * v294);
              v301 = (*v299)[v294 - 1];
              v302 = **v299;
              v303 = (__int16)v302 - (__int16)v301;
              if (v303 < 0)
                v303 = (__int16)v301 - (__int16)v302;
              if (v303 > 1)
              {
                v305 = 0;
              }
              else
              {
                v304 = (v302 >> 16) - (v301 >> 16);
                if (v304 < 0)
                  v304 = -v304;
                v305 = v304 < 2;
              }
              *(_BYTE *)(v295 + 40 * v142 + 8) = v305;
              v205 = v846;
            }
            else
            {
              eraseContourPixels((uint64_t)&v135[v201 + 144], *(uint64_t *)v869, *(int *)&v869[24]);
            }
            *v203 |= 0x40u;
            v306 = *(int *)&v135[v201 + 148] >> 1;
            *((_DWORD *)v293 + 38) = v306;
            *((_DWORD *)v293 + 39) = v306 - 1;
          }
          if (v207 < 0)
          {
            v307 = &v135[v201];
            v308 = *(_DWORD *)&v135[v201 + 180] - *(_DWORD *)&v135[v201 + 176] + 1;
            if (v308 >= v205)
            {
              if ((int)v142 >= 0x3FFF)
                __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 283, "cidcnt < MAX_CONTOURS");
              v142 = (int)v142 + 1;
              LODWORD(destR.data) = v142;
              v309 = destR.width;
              v310 = destR.width + 40 * v142;
              *(_DWORD *)(v310 + 4) = v308;
              *(_BYTE *)v310 = 1;
              *(_DWORD *)(v310 + 12) = 0;
              *(_QWORD *)(v310 + 24) = 0;
              v311 = malloc_type_malloc(4 * (v308 + 2), 0x100004052888210uLL);
              v312 = 0;
              *(_QWORD *)(v310 + 16) = v311;
              v313 = (int **)(v310 + 16);
              v314 = *((_DWORD *)v307 + 44);
              if (v314 <= *((_DWORD *)v307 + 45))
                v312 = (const void *)(*(_QWORD *)&v135[v201 + 184] + *(int *)&v135[v201 + 168] * (uint64_t)v314);
              memcpy(v311, v312, 4 * v308);
              v315 = (*v313)[v308 - 1];
              v316 = **v313;
              v317 = (__int16)v316 - (__int16)v315;
              if (v317 < 0)
                v317 = (__int16)v315 - (__int16)v316;
              if (v317 > 1)
              {
                v319 = 0;
              }
              else
              {
                v318 = (v316 >> 16) - (v315 >> 16);
                if (v318 < 0)
                  v318 = -v318;
                v319 = v318 < 2;
              }
              v204 = (_BYTE *)__src;
              v202 = (unsigned __int8 *)v850;
              *(_BYTE *)(v309 + 40 * v142 + 8) = v319;
              v205 = v846;
            }
            else
            {
              eraseContourPixels((uint64_t)&v135[v201 + 168], *(uint64_t *)v869, *(int *)&v869[24]);
              v204 = (_BYTE *)__src;
              v202 = (unsigned __int8 *)v850;
            }
            *v203 |= 0x80u;
            v320 = *(int *)&v135[v201 + 172] >> 1;
            *((_DWORD *)v307 + 44) = v320;
            *((_DWORD *)v307 + 45) = v320 - 1;
          }
          else
          {
LABEL_335:
            v204 = (_BYTE *)__src;
            v202 = (unsigned __int8 *)v850;
          }
          v201 += 192;
          ++v203;
        }
        while (v842 != v201);
      }
      v321 = (unint64_t)v818;
      bzero(v818, v806);
      v138 = v818;
      v322 = v809;
      v139 = (_QWORD *)__n;
      v134 = v809;
      _ZF = v822++ == v799;
      v131 = v805;
      v143 = v821;
      if (_ZF)
        goto LABEL_355;
    }
    v148 = 1;
    v149 = v134;
    do
    {
      if (*(_BYTE *)(v147 + v148))
      {
        v150 = v148 + 1;
        v151 = *(_DWORD *)&v146[4 * v148] + *(_DWORD *)&v146[4 * v148 - 4] + *(_DWORD *)&v146[4 * v148 + 4];
      }
      else
      {
        v151 = 0;
        v150 = v148 + 1;
      }
      *(_DWORD *)&v134[4 * v148] = v151;
      v148 = v150;
    }
    while (v150 != v143);
    v152 = 1;
    while (1)
    {
      if (*(_BYTE *)(v147 + v152))
      {
        v153 = &v149[4 * v152];
        v154 = *(int *)v153;
        v155 = *((_DWORD *)v153 - 1);
        LOWORD(kernel) = v152;
        WORD1(kernel) = v822;
        if ((_DWORD)v154)
        {
          if (v155)
          {
            if ((_DWORD)v154 != v155)
            {
              if ((int)v154 <= v155)
                v170 = v155;
              else
                v170 = v154;
              if ((int)v154 >= v155)
                LODWORD(v154) = v155;
              v171 = (int *)v139[(int)v154];
              v172 = *(_DWORD *)(*((_QWORD *)v171 + 2) + *v171 * (uint64_t)v171[3]);
              v173 = (__int16)v172 - (__int16)kernel;
              if (v173 < 0)
                v173 = (__int16)kernel - (__int16)v172;
              if (v173 > 1)
                goto LABEL_187;
              v174 = (v172 >> 16) - ((int)kernel >> 16);
              if (v174 < 0)
                v174 = -v174;
              if (v174 >= 2)
              {
LABEL_187:
                v184 = *(_DWORD *)(*((_QWORD *)v171 + 2) + *v171 * (uint64_t)v171[2]);
                v185 = (__int16)v184 - (__int16)kernel;
                if (v185 < 0)
                  v185 = (__int16)kernel - (__int16)v184;
                if (v185 > 1)
                  goto LABEL_927;
                v186 = (v184 >> 16) - ((int)kernel >> 16);
                if (v186 < 0)
                  v186 = -v186;
                if (v186 >= 2)
LABEL_927:
                  __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 155, "pneighbor(*(Pcoord *)dequeFirst(dbLookup[mnid]), pix)");
                v175 = 0;
              }
              else
              {
                v175 = 1;
              }
              v187 = (int *)v139[v170];
              v188 = *(_DWORD *)(*((_QWORD *)v187 + 2) + *v187 * (uint64_t)v187[3]);
              v189 = (__int16)v188 - (__int16)kernel;
              if (v189 < 0)
                v189 = (__int16)kernel - (__int16)v188;
              if (v189 > 1)
                goto LABEL_201;
              v190 = (v188 >> 16) - ((int)kernel >> 16);
              if (v190 < 0)
                v190 = -v190;
              if (v190 >= 2)
              {
LABEL_201:
                v192 = *(_DWORD *)(*((_QWORD *)v187 + 2) + *v187 * (uint64_t)v187[2]);
                v193 = (__int16)v192 - (__int16)kernel;
                if (v193 < 0)
                  v193 = (__int16)kernel - (__int16)v192;
                if (v193 > 1)
                  goto LABEL_928;
                v194 = (v192 >> 16) - ((int)kernel >> 16);
                if (v194 < 0)
                  v194 = ((int)kernel >> 16) - (v192 >> 16);
                if (v194 >= 2)
LABEL_928:
                  __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 163, "pneighbor(*(Pcoord *)dequeFirst(dbLookup[nid]), pix)");
                v191 = 0;
              }
              else
              {
                v191 = 2;
              }
              __asm { BR              X9 }
            }
            v156 = (int *)v139[v154];
            v157 = *(_DWORD *)(*((_QWORD *)v156 + 2) + *v156 * (uint64_t)v156[3]);
            v158 = (__int16)v157 - (__int16)kernel;
            if (v158 < 0)
              v158 = (__int16)kernel - (__int16)v157;
            if (v158 > 1)
              goto LABEL_136;
            v159 = (v157 >> 16) - ((int)kernel >> 16);
            if (v159 < 0)
              v159 = -v159;
            if (v159 > 1)
            {
LABEL_136:
              v160 = *(_DWORD *)(*((_QWORD *)v156 + 2) + *v156 * (uint64_t)v156[2]);
              v161 = (__int16)v160 - (__int16)kernel;
              if (v161 < 0)
                v161 = (__int16)kernel - (__int16)v160;
              v149 = v134;
              if (v161 > 1)
                goto LABEL_926;
              v162 = (v160 >> 16) - ((int)kernel >> 16);
              if (v162 < 0)
                v162 = ((int)kernel >> 16) - (v160 >> 16);
              if (v162 >= 2)
LABEL_926:
                __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 202, "pneighbor(*(Pcoord *)dequeFirst(dbLookup[mid]), pix)");
              goto LABEL_184;
            }
LABEL_157:
            appendDequeElement(v156, &kernel);
            v149 = v134;
          }
          else
          {
            v156 = (int *)v139[v154];
            v167 = *(_DWORD *)(*((_QWORD *)v156 + 2) + *v156 * (uint64_t)v156[3]);
            v168 = (__int16)v167 - (__int16)kernel;
            if (v168 < 0)
              v168 = (__int16)kernel - (__int16)v167;
            if (v168 <= 1)
            {
              v169 = (v167 >> 16) - ((int)kernel >> 16);
              if (v169 < 0)
                v169 = -v169;
              if (v169 <= 1)
                goto LABEL_157;
            }
            v180 = *(_DWORD *)(*((_QWORD *)v156 + 2) + *v156 * (uint64_t)v156[2]);
            v181 = (__int16)v180 - (__int16)kernel;
            if (v181 < 0)
              v181 = (__int16)kernel - (__int16)v180;
            v149 = v134;
            if (v181 > 1)
              goto LABEL_925;
            v182 = (v180 >> 16) - ((int)kernel >> 16);
            if (v182 < 0)
              v182 = ((int)kernel >> 16) - (v180 >> 16);
            if (v182 >= 2)
LABEL_925:
              __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 215, "pneighbor(*(Pcoord *)dequeFirst(dbLookup[mid]), pix)");
LABEL_184:
            prependDequeElement(v156, &kernel);
          }
          v183 = -1431655765 * ((v139[v154] - (_QWORD)v135) >> 3);
          sizeb[v183 >> 3] |= 1 << (v183 & 7);
LABEL_186:
          v147 = v826;
          v143 = v821;
          goto LABEL_219;
        }
        if (v155)
        {
          v163 = (int *)v139[v155];
          v164 = *(_DWORD *)(*((_QWORD *)v163 + 2) + *v163 * (uint64_t)v163[3]);
          v165 = (__int16)v164 - (__int16)kernel;
          if (v165 < 0)
            v165 = (__int16)kernel - (__int16)v164;
          if (v165 > 1)
            goto LABEL_170;
          v166 = (v164 >> 16) - ((int)kernel >> 16);
          if (v166 < 0)
            v166 = -v166;
          if (v166 > 1)
          {
LABEL_170:
            v176 = *(_DWORD *)(*((_QWORD *)v163 + 2) + *v163 * (uint64_t)v163[2]);
            v177 = (__int16)v176 - (__int16)kernel;
            if (v177 < 0)
              v177 = (__int16)kernel - (__int16)v176;
            if (v177 > 1)
              goto LABEL_924;
            v178 = (v176 >> 16) - ((int)kernel >> 16);
            if (v178 < 0)
              v178 = ((int)kernel >> 16) - (v176 >> 16);
            if (v178 >= 2)
LABEL_924:
              __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 229, "pneighbor(*(Pcoord *)dequeFirst(dbLookup[pid]), pix)");
            prependDequeElement(v163, &kernel);
          }
          else
          {
            appendDequeElement(v163, &kernel);
          }
          v179 = -1431655765 * ((v139[v155] - (_QWORD)v135) >> 3);
          sizeb[v179 >> 3] |= 1 << (v179 & 7);
          *(_DWORD *)&v134[4 * v152] = v155;
          v149 = v134;
          goto LABEL_186;
        }
        if (v816 > 16382)
        {
          LODWORD(v850) = 0;
          v441 = v809;
          v810 = v134;
          v442 = v818;
          v819 = (unint64_t)sizeb;
          goto LABEL_492;
        }
        v195 = 0;
        ++v816;
        v149 = v134;
        while (1)
        {
          v196 = *(unsigned __int8 *)(v820 + v195);
          if (*(_BYTE *)(v820 + v195))
            break;
          if (v814 == ++v195)
            goto LABEL_941;
        }
        v197 = 8 * v195;
        if ((v196 & 1) == 0)
        {
          do
          {
            v198 = v196;
            ++v197;
            v196 >>= 1;
          }
          while ((v198 & 2) == 0);
        }
        if (v197 > v807 || v197 == -1)
LABEL_941:
          __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 250, "loc != -1");
        *(_BYTE *)(v820 + (v197 >> 3)) &= ~(1 << (v197 & 7));
        v199 = (int *)&v135[24 * v197];
        v139[v816] = v199;
        appendDequeElement(v199, &kernel);
        v143 = v821;
        v147 = v826;
        v200 = -1431655765 * ((v139[v816] - (_QWORD)v135) >> 3);
        sizeb[v200 >> 3] |= 1 << (v200 & 7);
        *(_DWORD *)&v134[4 * v152] = v816;
      }
LABEL_219:
      if (++v152 == v143)
        goto LABEL_220;
    }
  }
  v322 = v134;
  v321 = (unint64_t)v138;
LABEL_355:
  v810 = v322;
  v819 = v321;
  LODWORD(v850) = 1;
  if (v131 < 0)
  {
    v441 = v831;
    v442 = sizeb;
  }
  else
  {
    v323 = 0;
    v324 = 0;
    if ((int)v806 <= 1)
      v325 = 1;
    else
      v325 = v806;
    __src = 192 * v325;
    v326 = v846;
    do
    {
      v327 = sizeb[v324];
      if (!v327)
        goto LABEL_473;
      if ((sizeb[v324] & 1) != 0)
      {
        v328 = (uint64_t)&v135[v323];
        if (v135)
          v329 = *(_DWORD *)(v328 + 12) - *(_DWORD *)(v328 + 8) + 1;
        else
          v329 = 0;
        if (v329 >= v326)
        {
          if ((int)v142 >= 0x3FFF)
            __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 303, "cidcnt < MAX_CONTOURS");
          v142 = (int)v142 + 1;
          LODWORD(destR.data) = v142;
          v330 = destR.width;
          v331 = destR.width + 40 * v142;
          *(_DWORD *)(v331 + 4) = v329;
          *(_BYTE *)v331 = 1;
          *(_DWORD *)(v331 + 12) = 0;
          *(_QWORD *)(v331 + 24) = 0;
          v332 = malloc_type_malloc(4 * (v329 + 2), 0x100004052888210uLL);
          *(_QWORD *)(v331 + 16) = v332;
          v333 = (int **)(v331 + 16);
          if (v135 && (v334 = *(_DWORD *)&v135[v323 + 8], v334 <= *(_DWORD *)&v135[v323 + 12]))
            v335 = (const void *)(*(_QWORD *)&v135[v323 + 16] + *(int *)&v135[v323] * (uint64_t)v334);
          else
            v335 = 0;
          memcpy(v332, v335, 4 * v329);
          v336 = (*v333)[v329 - 1];
          v337 = **v333;
          v338 = (__int16)v337 - (__int16)v336;
          if (v338 < 0)
            v338 = (__int16)v336 - (__int16)v337;
          if (v338 > 1)
          {
            v340 = 0;
          }
          else
          {
            v339 = (v337 >> 16) - (v336 >> 16);
            if (v339 < 0)
              v339 = -v339;
            v340 = v339 < 2;
          }
          v326 = v846;
          *(_BYTE *)(v330 + 40 * v142 + 8) = v340;
        }
        else
        {
          eraseContourPixels(v328, *(uint64_t *)v869, *(int *)&v869[24]);
        }
        *(_BYTE *)(v820 + v324) |= 1u;
        if (v135)
        {
          v341 = &v135[v323];
          v342 = *(int *)&v135[v323 + 4] >> 1;
          *((_DWORD *)v341 + 2) = v342;
          *((_DWORD *)v341 + 3) = v342 - 1;
        }
      }
      if ((v327 & 2) != 0)
      {
        v343 = &v135[v323];
        v344 = *(_DWORD *)&v135[v323 + 36] - *(_DWORD *)&v135[v323 + 32] + 1;
        if (v344 >= v326)
        {
          if ((int)v142 >= 0x3FFF)
            __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 304, "cidcnt < MAX_CONTOURS");
          v142 = (int)v142 + 1;
          LODWORD(destR.data) = v142;
          v345 = destR.width;
          v346 = destR.width + 40 * v142;
          *(_DWORD *)(v346 + 4) = v344;
          *(_BYTE *)v346 = 1;
          *(_DWORD *)(v346 + 12) = 0;
          *(_QWORD *)(v346 + 24) = 0;
          v347 = malloc_type_malloc(4 * (v344 + 2), 0x100004052888210uLL);
          v348 = 0;
          *(_QWORD *)(v346 + 16) = v347;
          v349 = (int **)(v346 + 16);
          v350 = *((_DWORD *)v343 + 8);
          if (v350 <= *((_DWORD *)v343 + 9))
            v348 = (const void *)(*(_QWORD *)&v135[v323 + 40] + *(int *)&v135[v323 + 24] * (uint64_t)v350);
          memcpy(v347, v348, 4 * v344);
          v351 = (*v349)[v344 - 1];
          v352 = **v349;
          v353 = (__int16)v352 - (__int16)v351;
          if (v353 < 0)
            v353 = (__int16)v351 - (__int16)v352;
          if (v353 > 1)
          {
            v355 = 0;
          }
          else
          {
            v354 = (v352 >> 16) - (v351 >> 16);
            if (v354 < 0)
              v354 = -v354;
            v355 = v354 < 2;
          }
          *(_BYTE *)(v345 + 40 * v142 + 8) = v355;
          v326 = v846;
        }
        else
        {
          eraseContourPixels((uint64_t)&v135[v323 + 24], *(uint64_t *)v869, *(int *)&v869[24]);
        }
        *(_BYTE *)(v820 + v324) |= 2u;
        v356 = *(int *)&v135[v323 + 28] >> 1;
        *((_DWORD *)v343 + 8) = v356;
        *((_DWORD *)v343 + 9) = v356 - 1;
      }
      if ((v327 & 4) != 0)
      {
        v357 = &v135[v323];
        v358 = *(_DWORD *)&v135[v323 + 60] - *(_DWORD *)&v135[v323 + 56] + 1;
        if (v358 >= v326)
        {
          if ((int)v142 >= 0x3FFF)
            __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 305, "cidcnt < MAX_CONTOURS");
          v142 = (int)v142 + 1;
          LODWORD(destR.data) = v142;
          v359 = destR.width;
          v360 = destR.width + 40 * v142;
          *(_DWORD *)(v360 + 4) = v358;
          *(_BYTE *)v360 = 1;
          *(_DWORD *)(v360 + 12) = 0;
          *(_QWORD *)(v360 + 24) = 0;
          v361 = malloc_type_malloc(4 * (v358 + 2), 0x100004052888210uLL);
          v362 = 0;
          *(_QWORD *)(v360 + 16) = v361;
          v363 = (int **)(v360 + 16);
          v364 = *((_DWORD *)v357 + 14);
          if (v364 <= *((_DWORD *)v357 + 15))
            v362 = (const void *)(*(_QWORD *)&v135[v323 + 64] + *(int *)&v135[v323 + 48] * (uint64_t)v364);
          memcpy(v361, v362, 4 * v358);
          v365 = (*v363)[v358 - 1];
          v366 = **v363;
          v367 = (__int16)v366 - (__int16)v365;
          if (v367 < 0)
            v367 = (__int16)v365 - (__int16)v366;
          if (v367 > 1)
          {
            v369 = 0;
          }
          else
          {
            v368 = (v366 >> 16) - (v365 >> 16);
            if (v368 < 0)
              v368 = -v368;
            v369 = v368 < 2;
          }
          *(_BYTE *)(v359 + 40 * v142 + 8) = v369;
          v326 = v846;
        }
        else
        {
          eraseContourPixels((uint64_t)&v135[v323 + 48], *(uint64_t *)v869, *(int *)&v869[24]);
        }
        *(_BYTE *)(v820 + v324) |= 4u;
        v370 = *(int *)&v135[v323 + 52] >> 1;
        *((_DWORD *)v357 + 14) = v370;
        *((_DWORD *)v357 + 15) = v370 - 1;
      }
      if ((v327 & 8) != 0)
      {
        v371 = &v135[v323];
        v372 = *(_DWORD *)&v135[v323 + 84] - *(_DWORD *)&v135[v323 + 80] + 1;
        if (v372 >= v326)
        {
          if ((int)v142 >= 0x3FFF)
            __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 306, "cidcnt < MAX_CONTOURS");
          v142 = (int)v142 + 1;
          LODWORD(destR.data) = v142;
          v373 = destR.width;
          v374 = destR.width + 40 * v142;
          *(_DWORD *)(v374 + 4) = v372;
          *(_BYTE *)v374 = 1;
          *(_DWORD *)(v374 + 12) = 0;
          *(_QWORD *)(v374 + 24) = 0;
          v375 = malloc_type_malloc(4 * (v372 + 2), 0x100004052888210uLL);
          v376 = 0;
          *(_QWORD *)(v374 + 16) = v375;
          v377 = (int **)(v374 + 16);
          v378 = *((_DWORD *)v371 + 20);
          if (v378 <= *((_DWORD *)v371 + 21))
            v376 = (const void *)(*(_QWORD *)&v135[v323 + 88] + *(int *)&v135[v323 + 72] * (uint64_t)v378);
          memcpy(v375, v376, 4 * v372);
          v379 = (*v377)[v372 - 1];
          v380 = **v377;
          v381 = (__int16)v380 - (__int16)v379;
          if (v381 < 0)
            v381 = (__int16)v379 - (__int16)v380;
          if (v381 > 1)
          {
            v383 = 0;
          }
          else
          {
            v382 = (v380 >> 16) - (v379 >> 16);
            if (v382 < 0)
              v382 = -v382;
            v383 = v382 < 2;
          }
          *(_BYTE *)(v373 + 40 * v142 + 8) = v383;
          v326 = v846;
        }
        else
        {
          eraseContourPixels((uint64_t)&v135[v323 + 72], *(uint64_t *)v869, *(int *)&v869[24]);
        }
        *(_BYTE *)(v820 + v324) |= 8u;
        v384 = *(int *)&v135[v323 + 76] >> 1;
        *((_DWORD *)v371 + 20) = v384;
        *((_DWORD *)v371 + 21) = v384 - 1;
      }
      if ((v327 & 0x10) != 0)
      {
        v385 = &v135[v323];
        v386 = *(_DWORD *)&v135[v323 + 108] - *(_DWORD *)&v135[v323 + 104] + 1;
        if (v386 >= v326)
        {
          if ((int)v142 >= 0x3FFF)
            __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 307, "cidcnt < MAX_CONTOURS");
          v142 = (int)v142 + 1;
          LODWORD(destR.data) = v142;
          v387 = destR.width;
          v388 = destR.width + 40 * v142;
          *(_DWORD *)(v388 + 4) = v386;
          *(_BYTE *)v388 = 1;
          *(_DWORD *)(v388 + 12) = 0;
          *(_QWORD *)(v388 + 24) = 0;
          v389 = malloc_type_malloc(4 * (v386 + 2), 0x100004052888210uLL);
          v390 = 0;
          *(_QWORD *)(v388 + 16) = v389;
          v391 = (int **)(v388 + 16);
          v392 = *((_DWORD *)v385 + 26);
          if (v392 <= *((_DWORD *)v385 + 27))
            v390 = (const void *)(*(_QWORD *)&v135[v323 + 112] + *(int *)&v135[v323 + 96] * (uint64_t)v392);
          memcpy(v389, v390, 4 * v386);
          v393 = (*v391)[v386 - 1];
          v394 = **v391;
          v395 = (__int16)v394 - (__int16)v393;
          if (v395 < 0)
            v395 = (__int16)v393 - (__int16)v394;
          if (v395 > 1)
          {
            v397 = 0;
          }
          else
          {
            v396 = (v394 >> 16) - (v393 >> 16);
            if (v396 < 0)
              v396 = -v396;
            v397 = v396 < 2;
          }
          *(_BYTE *)(v387 + 40 * v142 + 8) = v397;
          v326 = v846;
        }
        else
        {
          eraseContourPixels((uint64_t)&v135[v323 + 96], *(uint64_t *)v869, *(int *)&v869[24]);
        }
        *(_BYTE *)(v820 + v324) |= 0x10u;
        v398 = *(int *)&v135[v323 + 100] >> 1;
        *((_DWORD *)v385 + 26) = v398;
        *((_DWORD *)v385 + 27) = v398 - 1;
      }
      if ((v327 & 0x20) != 0)
      {
        v399 = &v135[v323];
        v400 = *(_DWORD *)&v135[v323 + 132] - *(_DWORD *)&v135[v323 + 128] + 1;
        if (v400 >= v326)
        {
          if ((int)v142 >= 0x3FFF)
            __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 308, "cidcnt < MAX_CONTOURS");
          v142 = (int)v142 + 1;
          LODWORD(destR.data) = v142;
          v401 = destR.width;
          v402 = destR.width + 40 * v142;
          *(_DWORD *)(v402 + 4) = v400;
          *(_BYTE *)v402 = 1;
          *(_DWORD *)(v402 + 12) = 0;
          *(_QWORD *)(v402 + 24) = 0;
          v403 = malloc_type_malloc(4 * (v400 + 2), 0x100004052888210uLL);
          v404 = 0;
          *(_QWORD *)(v402 + 16) = v403;
          v405 = (int **)(v402 + 16);
          v406 = *((_DWORD *)v399 + 32);
          if (v406 <= *((_DWORD *)v399 + 33))
            v404 = (const void *)(*(_QWORD *)&v135[v323 + 136] + *(int *)&v135[v323 + 120] * (uint64_t)v406);
          memcpy(v403, v404, 4 * v400);
          v407 = (*v405)[v400 - 1];
          v408 = **v405;
          v409 = (__int16)v408 - (__int16)v407;
          if (v409 < 0)
            v409 = (__int16)v407 - (__int16)v408;
          if (v409 > 1)
          {
            v411 = 0;
          }
          else
          {
            v410 = (v408 >> 16) - (v407 >> 16);
            if (v410 < 0)
              v410 = -v410;
            v411 = v410 < 2;
          }
          *(_BYTE *)(v401 + 40 * v142 + 8) = v411;
          v326 = v846;
        }
        else
        {
          eraseContourPixels((uint64_t)&v135[v323 + 120], *(uint64_t *)v869, *(int *)&v869[24]);
        }
        *(_BYTE *)(v820 + v324) |= 0x20u;
        v412 = *(int *)&v135[v323 + 124] >> 1;
        *((_DWORD *)v399 + 32) = v412;
        *((_DWORD *)v399 + 33) = v412 - 1;
      }
      if ((v327 & 0x40) != 0)
      {
        v413 = &v135[v323];
        v414 = *(_DWORD *)&v135[v323 + 156] - *(_DWORD *)&v135[v323 + 152] + 1;
        if (v414 >= v326)
        {
          if ((int)v142 >= 0x3FFF)
            __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 309, "cidcnt < MAX_CONTOURS");
          v142 = (int)v142 + 1;
          LODWORD(destR.data) = v142;
          v415 = destR.width;
          v416 = destR.width + 40 * v142;
          *(_DWORD *)(v416 + 4) = v414;
          *(_BYTE *)v416 = 1;
          *(_DWORD *)(v416 + 12) = 0;
          *(_QWORD *)(v416 + 24) = 0;
          v417 = malloc_type_malloc(4 * (v414 + 2), 0x100004052888210uLL);
          v418 = 0;
          *(_QWORD *)(v416 + 16) = v417;
          v419 = (int **)(v416 + 16);
          v420 = *((_DWORD *)v413 + 38);
          if (v420 <= *((_DWORD *)v413 + 39))
            v418 = (const void *)(*(_QWORD *)&v135[v323 + 160] + *(int *)&v135[v323 + 144] * (uint64_t)v420);
          memcpy(v417, v418, 4 * v414);
          v421 = (*v419)[v414 - 1];
          v422 = **v419;
          v423 = (__int16)v422 - (__int16)v421;
          if (v423 < 0)
            v423 = (__int16)v421 - (__int16)v422;
          if (v423 > 1)
          {
            v425 = 0;
          }
          else
          {
            v424 = (v422 >> 16) - (v421 >> 16);
            if (v424 < 0)
              v424 = -v424;
            v425 = v424 < 2;
          }
          *(_BYTE *)(v415 + 40 * v142 + 8) = v425;
          v326 = v846;
        }
        else
        {
          eraseContourPixels((uint64_t)&v135[v323 + 144], *(uint64_t *)v869, *(int *)&v869[24]);
        }
        *(_BYTE *)(v820 + v324) |= 0x40u;
        v426 = *(int *)&v135[v323 + 148] >> 1;
        *((_DWORD *)v413 + 38) = v426;
        *((_DWORD *)v413 + 39) = v426 - 1;
      }
      if ((v327 & 0x80) != 0)
      {
        v427 = &v135[v323];
        v428 = *(_DWORD *)&v135[v323 + 180] - *(_DWORD *)&v135[v323 + 176] + 1;
        if (v428 >= v326)
        {
          if ((int)v142 >= 0x3FFF)
            __assert_rtn("ConnectedComponents", "ConnectedComponents.c", 310, "cidcnt < MAX_CONTOURS");
          v142 = (int)v142 + 1;
          LODWORD(destR.data) = v142;
          v429 = destR.width;
          v430 = destR.width + 40 * v142;
          *(_DWORD *)(v430 + 4) = v428;
          *(_BYTE *)v430 = 1;
          *(_DWORD *)(v430 + 12) = 0;
          *(_QWORD *)(v430 + 24) = 0;
          v431 = malloc_type_malloc(4 * (v428 + 2), 0x100004052888210uLL);
          v432 = 0;
          *(_QWORD *)(v430 + 16) = v431;
          v433 = (int **)(v430 + 16);
          v434 = *((_DWORD *)v427 + 44);
          if (v434 <= *((_DWORD *)v427 + 45))
            v432 = (const void *)(*(_QWORD *)&v135[v323 + 184] + *(int *)&v135[v323 + 168] * (uint64_t)v434);
          memcpy(v431, v432, 4 * v428);
          v435 = (*v433)[v428 - 1];
          v436 = **v433;
          v437 = (__int16)v436 - (__int16)v435;
          if (v437 < 0)
            v437 = (__int16)v435 - (__int16)v436;
          if (v437 > 1)
          {
            v439 = 0;
          }
          else
          {
            v438 = (v436 >> 16) - (v435 >> 16);
            if (v438 < 0)
              v438 = -v438;
            v439 = v438 < 2;
          }
          v139 = (_QWORD *)__n;
          *(_BYTE *)(v429 + 40 * v142 + 8) = v439;
          v326 = v846;
        }
        else
        {
          eraseContourPixels((uint64_t)&v135[v323 + 168], *(uint64_t *)v869, *(int *)&v869[24]);
          v139 = (_QWORD *)__n;
        }
        *(_BYTE *)(v820 + v324) |= 0x80u;
        v440 = *(int *)&v135[v323 + 172] >> 1;
        *((_DWORD *)v427 + 44) = v440;
        *((_DWORD *)v427 + 45) = v440 - 1;
      }
      else
      {
LABEL_473:
        v139 = (_QWORD *)__n;
      }
      ++v324;
      v323 += 192;
    }
    while (__src != v323);
    LODWORD(v850) = 1;
    v441 = v831;
    v442 = sizeb;
    v131 = v805;
  }
LABEL_492:
  if (v441)
    free(v441);
  if (v810)
    free(v810);
  if (v820)
    free((void *)v820);
  if (v442)
    free(v442);
  if (v819)
    free((void *)v819);
  if (v139)
    free(v139);
  if (v135)
  {
    if ((v131 & 0x80000000) == 0)
    {
      v443 = (v807 & ~(v807 >> 31)) + 1;
      v444 = (void **)(v135 + 16);
      do
      {
        if (*v444)
          free(*v444);
        v444 += 3;
        --v443;
      }
      while (v443);
    }
    free(v135);
  }
  if ((v850 & 1) == 0)
  {
    if (__E)
      free(__E);
    if (destG.data)
    {
      free(destG.data);
      destG.data = 0;
    }
    if (destB.data)
      free(destB.data);
    if (dest.data)
      free(dest.data);
    if (src.data)
      free(src.data);
    if (v780)
      free(v780);
    if (v784)
      free(v784);
    if (v779)
      free(v779);
    if (*(_QWORD *)v869)
    {
      free(*(void **)v869);
      *(_QWORD *)v869 = 0;
    }
    releaseContourDatabaseMemory((uint64_t)&destR);
    v463 = 0;
    *a5 = 0;
    return v463;
  }
  data = (int)destR.data;
  v446 = destR.width;
  v447 = LODWORD(destR.data) + 1;
  v448 = LODWORD(destR.data) + 1;
  v449 = (vDSP_Length *)malloc_type_malloc(8 * v448, 0x100004000313F17uLL);
  v450 = (const unsigned __int16 *)malloc_type_malloc(2 * v447, 0x1000040BDFB0063uLL);
  v451 = (float *)malloc_type_malloc(4 * v447, 0x100004052888210uLL);
  v452 = *(float *)(v792 + 100);
  *v450 = 0;
  *v449 = 0;
  if (data < 1)
  {
    v453 = 0;
  }
  else
  {
    LODWORD(v453) = 0;
    v454 = vcvtms_s32_f32(v452);
    v455 = (_DWORD **)(v446 + 56);
    v456 = 1;
    do
    {
      v457 = *((_DWORD *)v455 - 3);
      if (v457 <= v454)
        v453 = v453;
      else
        v453 = (v453 + 1);
      v450[v456] = v457;
      v458 = (*v455)[v457 - 1];
      v459 = **v455;
      v460 = (__int16)v459 - (__int16)v458;
      if (v460 < 0)
        v460 = (__int16)v458 - (__int16)v459;
      if (v460 > 1)
      {
        v462 = 0;
      }
      else
      {
        v461 = (v459 >> 16) - (v458 >> 16);
        if (v461 < 0)
          v461 = -v461;
        v462 = v461 < 2;
      }
      *((_BYTE *)v455 - 8) = v462;
      v449[v456] = v456;
      ++v456;
      v455 += 5;
    }
    while (v448 != v456);
  }
  vDSP_vfltu16(v450, 1, v451, 1, v448);
  vDSP_vsorti(v451, v449, 0, v448, -1);
  if ((data & 0x80000000) == 0)
  {
    v464 = v448;
    v465 = v449;
    v466 = (unsigned __int16 *)v450;
    do
    {
      v467 = *v465++;
      *v466++ = v467;
      --v464;
    }
    while (v464);
  }
  destR.height = (vImagePixelCount)v450;
  HIDWORD(destR.data) = v453;
  if (v451)
    free(v451);
  free(v449);
  v854[1] = __NR;
  *(_QWORD *)&v855 = v796;
  *((_QWORD *)&v855 + 1) = 2 * v796;
  v854[0] = malloc_type_calloc(v798, 2uLL, 0x1000040BDFB0063uLL);
  SelfClosureContourHeal((int *)&destR, *(uint64_t *)v869, *(uint64_t *)&v869[16], (uint64_t)v854[0], 1);
  v468 = *(_QWORD *)&v869[16];
  v469 = *(_QWORD *)v869;
  v470 = v854[0];
  v471 = destR.width;
  data_high = HIDWORD(destR.data);
  v791 = destR.height;
  LODWORD(v861.data) = 0;
  LODWORD(v860.data) = 0;
  if (SHIDWORD(destR.data) >= 1)
  {
    v472 = 0;
    v473 = 0;
    v474 = vcvtms_s32_f32(*(float *)(v792 + 100));
    v475 = *(float *)(v792 + 88);
    v782 = *(_QWORD *)&v869[16] << 32;
    v783 = (char *)v854[0];
    v781 = *(_DWORD *)&v869[16];
    v788 = destR.width;
    v787 = v474;
    while (*(_BYTE *)(v471 + 40 * *(__int16 *)(v791 + 2 * v472) + 8)
         || !*(_BYTE *)(v471 + 40 * *(__int16 *)(v791 + 2 * v472)))
    {
LABEL_686:
      if (++v472 == data_high)
      {
        v469 = *(_QWORD *)v869;
        v468 = *(_QWORD *)&v869[16];
        v470 = v854[0];
        goto LABEL_688;
      }
    }
    v786 = *(_WORD *)(v791 + 2 * v472);
    v476 = v471 + 40 * v786;
    v847 = (const void **)(v476 + 16);
    v823 = (unsigned int *)(v476 + 4);
    v477 = 1;
    v789 = v472;
    while (1)
    {
      v478 = v477;
      v479 = *v847;
      LODWORD(v850) = v478;
      if ((v478 & 1) != 0)
      {
        v480 = *v847;
        v481 = 1;
      }
      else
      {
        v482 = (int)*v823;
        v480 = &v479[v482 - 1];
        v481 = v482 - 2;
      }
      __src = *v480;
      LODWORD(destA.data) = *v480;
      HIDWORD(destA.data) = v479[v481];
      v483 = testJoin((__int16 *)&destA, (uint64_t)v854[0], v855, &v861);
      if (v483)
      {
        v484 = v471 + 40 * v483;
        v485 = *(int *)(v484 + 4);
        v843 = (int *)(v484 + 4);
        if ((int)v485 > v474)
        {
          v486 = v471 + 40 * v483;
          v487 = *(unsigned __int16 **)(v486 + 16);
          v827 = (char **)(v486 + 16);
          v808 = (_BYTE *)v486;
          if (__PAIR64__(WORD1(v861.data), LOWORD(v861.data)) == __PAIR64__(v487[1], *v487))
          {
            LODWORD(v868.data) = *(_DWORD *)v487;
            v488 = 1;
          }
          else
          {
            v489 = &v487[2 * v485 - 2];
            if (__PAIR64__(WORD1(v861.data), LOWORD(v861.data)) != __PAIR64__(v489[1], *v489))
              __assert_rtn("AdjacentContourHeal", "Contours.c", 603, "PCOORD_EQUAL(joinPoint, LAST_PCOORD(cPtrN))");
            LODWORD(v868.data) = *(_DWORD *)v489;
            v488 = v485 - 2;
          }
          HIDWORD(v868.data) = *(_DWORD *)&v487[2 * v488];
          if (testJoin((__int16 *)&v868, (uint64_t)v854[0], v855, &v860) == v786)
          {
            v811 = (void *)(int)*v823;
            v820 = *v843;
            data_low = LODWORD(v861.data);
            v793 = v793 & 0xFFFFFFFF00000000 | __src;
            v794 = v794 & 0xFFFFFFFF00000000 | LODWORD(v861.data);
            v491 = healCenters(v793, (int)v861.data, (uint64_t)&kernel);
            if (v491)
              break;
          }
        }
      }
LABEL_685:
      v477 = 0;
      if ((v850 & 1) == 0)
        goto LABEL_686;
    }
    v492 = *v827;
    sizec = data_low;
    if ((v850 & 1) != 0)
    {
      if (*(unsigned __int16 *)v492 != (unsigned __int16)data_low || *((unsigned __int16 *)v492 + 1) != WORD1(data_low))
      {
        v493 = *v843 - 1;
        if (*(unsigned __int16 *)&v492[4 * v493] != (unsigned __int16)data_low
          || *(unsigned __int16 *)&v492[4 * v493 + 2] != WORD1(data_low))
        {
          __assert_rtn("AdjacentContourHeal", "Contours.c", 635, "PCOORD_EQUAL(joinPoint, LAST_PCOORD(cPtrN))");
        }
LABEL_578:
        LODWORD(v821) = 0;
        goto LABEL_579;
      }
    }
    else
    {
      v494 = *v843 - 1;
      if (*(unsigned __int16 *)&v492[4 * v494] != (unsigned __int16)data_low
        || *(unsigned __int16 *)&v492[4 * v494 + 2] != WORD1(data_low))
      {
        if (*(unsigned __int16 *)v492 != (unsigned __int16)data_low
          || *((unsigned __int16 *)v492 + 1) != WORD1(data_low))
        {
          __assert_rtn("AdjacentContourHeal", "Contours.c", 641, "PCOORD_EQUAL(joinPoint, FIRST_PCOORD(cPtrN))");
        }
        goto LABEL_578;
      }
    }
    LODWORD(v821) = 1;
LABEL_579:
    v495 = 0;
    v795 = (int)v820 - 1;
    v797 = (int)v811 - 1;
    v804 = 4 * v795;
    v819 = 4 * v797;
    v815 = 4 * ((int)v820 + (int)v811 + 2);
    __NRa = 4 * (int)v820;
    __na = 4 * (_QWORD)v811;
    v832 = v491;
    while (1)
    {
      v496 = (__int16 *)&kernel + 2 * v495;
      v497 = *v496;
      v498 = v496[1];
      v499 = v469;
      v500 = (_BYTE *)(v497 + v469 + (v498 - 1) * (uint64_t)(int)v468 - 1);
      v453 = v453 & 0xFFFFFFFF00000000 | __src;
      v448 = v448 & 0xFFFFFFFF00000000 | sizec;
      v501 = v468;
      v502 = heal(v500, v468, v453, v448, (uint64_t)&kernel, v495);
      if ((v502 & 0x80000000) == 0)
      {
        v503 = v502;
        switch(v502)
        {
          case 0:
            v504 = (__int16 *)malloc_type_malloc(4 * ((int)v820 + (int)v811 + 3), 0x100004052888210uLL);
            v473 = v504;
            if ((v850 & 1) != 0)
            {
              v505 = *v827;
              if ((_DWORD)v821)
              {
                if ((int)v820 >= 1)
                {
                  v506 = &v505[4 * *v843 - 4];
                  v507 = v820;
                  v508 = v504;
                  do
                  {
                    v509 = *(_DWORD *)v506;
                    v506 -= 4;
                    *v508++ = v509;
                    --v507;
                  }
                  while (v507);
                }
              }
              else
              {
                memcpy(v504, v505, __NRa);
              }
              v556 = &v473[2 * (int)v820];
              *(_DWORD *)v556 = *(_DWORD *)v496;
              v530 = v556 + 2;
              v531 = (char *)*v847;
              v557 = 4 * (_QWORD)v811;
              goto LABEL_636;
            }
            memcpy(v504, *v847, __na);
            v529 = &v473[2 * (_QWORD)v811];
            *(_DWORD *)v529 = *(_DWORD *)v496;
            v530 = v529 + 2;
            v531 = *v827;
            if (!(_DWORD)v821)
            {
              v557 = 4 * (int)v820;
LABEL_636:
              memcpy(v530, v531, v557);
              goto LABEL_637;
            }
            v532 = v820;
            if ((int)v820 >= 1)
            {
              v533 = &v531[4 * *v843 - 4];
              v534 = 4 * (_QWORD)v811 + 4;
              do
              {
                v535 = *(_DWORD *)v533;
                v533 -= 4;
                *(_DWORD *)((char *)v473 + v534) = v535;
                v534 += 4;
                --v532;
              }
              while (v532);
            }
LABEL_637:
            v510 = v820 + (_DWORD)v811 + 3;
LABEL_645:
            v564 = *v823;
            if ((int)v564 <= 1)
            {
              v571 = 0;
            }
            else
            {
              v565 = 0;
              v566 = (__int16 *)((char *)*v847 + 6);
              v567 = *(_WORD *)*v847;
              v568 = v564 - 1;
              do
              {
                v569 = *(v566 - 1);
                v570 = *(v566 - 1);
                v565 += (v567 - v569) * *v566;
                v566 += 2;
                v567 = v570;
                --v568;
              }
              while (v568);
              v571 = v565 + (v569 - *(__int16 *)*v847) * *((__int16 *)*v847 + 1);
            }
            if (v571 < 0)
              v571 = -v571;
            v572 = *v843;
            if ((int)v572 < 2)
            {
              v579 = 0;
            }
            else
            {
              v573 = 0;
              v574 = (__int16 *)(*v827 + 6);
              v575 = *(_WORD *)*v827;
              v576 = v572 - 1;
              do
              {
                v577 = *(v574 - 1);
                v578 = *(v574 - 1);
                v573 += (v575 - v577) * *v574;
                v574 += 2;
                v575 = v578;
                --v576;
              }
              while (v576);
              v579 = v573 + (v577 - *(__int16 *)*v827) * *((__int16 *)*v827 + 1);
            }
            v580 = (v510 - 2);
            if (v579 < 0)
              v579 = -v579;
            if (v510 < 4)
            {
              v587 = 0;
            }
            else
            {
              v581 = 0;
              v582 = v473 + 3;
              v583 = *v473;
              v584 = v580 - 1;
              do
              {
                v585 = *(v582 - 1);
                v586 = *(v582 - 1);
                v581 += (v583 - v585) * *v582;
                v582 += 2;
                v583 = v586;
                --v584;
              }
              while (v584);
              v587 = v581 + (v585 - *v473) * v473[1];
            }
            if (v587 < 0)
              v587 = -v587;
            if (v571 <= v579)
              v571 = v579;
            if ((float)(v475 * (float)v587) >= (float)v571)
            {
              v588 = v510 - 3;
              if ((v850 & 1) != 0)
                v588 = 0;
              v589 = &v473[2 * v588];
              v590 = v589[1];
              v591 = *v589;
              v592 = v782 * SWORD1(__src);
              *(_WORD *)&v783[2 * (__int16)__src + (v592 >> 31)] = 0;
              v593 = v782 * SWORD1(sizec);
              *(_WORD *)&v783[2 * (__int16)sizec + (v593 >> 31)] = 0;
              *(_WORD *)&v783[2 * v591 + ((v782 * v590) >> 31)] = v786;
              *(_BYTE *)(v499 + v497 + v498 * (uint64_t)v781) = 1;
              if (v503 == 1)
              {
                v594 = (__int16)__src;
                v595 = v592 >> 32;
                v468 = v501;
                v469 = v499;
                v471 = v788;
                v472 = v789;
                v474 = v787;
              }
              else
              {
                v594 = (__int16)sizec;
                v595 = v593 >> 32;
                v471 = v788;
                v472 = v789;
                v474 = v787;
                if (v503 == 3)
                {
                  *(_BYTE *)(v499 + (__int16)__src + (v592 >> 32)) = 0;
                  v468 = v501;
                  v469 = v499;
                }
                else
                {
                  _ZF = v503 == 2;
                  v468 = v501;
                  v469 = v499;
                  if (!_ZF)
                  {
LABEL_682:
                    if (*v847)
                      free((void *)*v847);
                    *v847 = v473;
                    *v823 = v580;
                    *v808 = 0;
                    goto LABEL_685;
                  }
                }
              }
              *(_BYTE *)(v469 + v594 + v595) = 0;
              goto LABEL_682;
            }
            if (v473)
            {
              free(v473);
              v473 = 0;
            }
            break;
          case 1:
            v511 = (__int16 *)malloc_type_malloc(v815, 0x100004052888210uLL);
            v473 = v511;
            if ((v850 & 1) != 0)
            {
              v512 = *v827;
              if ((_DWORD)v821)
              {
                if ((int)v820 >= 1)
                {
                  v513 = (int *)&v512[4 * *v843 - 4];
                  v514 = v820;
                  v515 = v511;
                  do
                  {
                    v516 = *v513--;
                    *v515++ = v516;
                    --v514;
                  }
                  while (v514);
                }
              }
              else
              {
                memcpy(v511, v512, __NRa);
              }
              v558 = &v473[2 * (int)v820];
              *(_DWORD *)v558 = *(_DWORD *)v496;
              v537 = v558 + 2;
              v538 = (char *)*v847 + 4;
              v559 = 4 * ((int)v811 - 1);
              goto LABEL_640;
            }
            memcpy(v511, *v847, v819);
            v536 = &v473[2 * v797];
            *(_DWORD *)v536 = *(_DWORD *)v496;
            v537 = v536 + 2;
            v538 = *v827;
            if (!(_DWORD)v821)
            {
              v559 = 4 * (int)v820;
              goto LABEL_640;
            }
            v539 = v820;
            if ((int)v820 >= 1)
            {
              v540 = (int *)&v538[2 * *v843 - 2];
              v541 = v819 + 4;
              do
              {
                v542 = *v540--;
                *(_DWORD *)((char *)v473 + v541) = v542;
                v541 += 4;
                --v539;
              }
              while (v539);
            }
            goto LABEL_641;
          case 2:
            v517 = (__int16 *)malloc_type_malloc(v815, 0x100004052888210uLL);
            v473 = v517;
            if ((v850 & 1) != 0)
            {
              v518 = *v827;
              if ((_DWORD)v821)
              {
                if ((int)v820 >= 2)
                {
                  v519 = (int *)&v518[4 * *v843 - 4];
                  v520 = v820 - 1;
                  v521 = v517;
                  do
                  {
                    v522 = *v519--;
                    *v521++ = v522;
                    --v520;
                  }
                  while (v520);
                }
              }
              else
              {
                memcpy(v517, v518, v804);
              }
              v560 = &v473[2 * v795];
              *(_DWORD *)v560 = *(_DWORD *)v496;
              v537 = v560 + 2;
              v538 = *v847;
              v559 = 4 * (_QWORD)v811;
              goto LABEL_640;
            }
            memcpy(v517, *v847, __na);
            v543 = &v473[2 * (_QWORD)v811];
            *(_DWORD *)v543 = *(_DWORD *)v496;
            v537 = v543 + 2;
            v544 = *v827;
            if (!(_DWORD)v821)
            {
              v538 = v544 + 4;
              v559 = 4 * v795;
LABEL_640:
              memcpy(v537, v538, v559);
              goto LABEL_641;
            }
            if ((int)v820 >= 2)
            {
              v545 = (int *)&v544[4 * *v843 - 8];
              v546 = 4 * (_QWORD)v811 + 4;
              v547 = v820 - 1;
              do
              {
                v548 = *v545--;
                *(_DWORD *)((char *)v473 + v546) = v548;
                v546 += 4;
                --v547;
              }
              while (v547);
            }
LABEL_641:
            v510 = v820 + (_DWORD)v811 + 2;
            goto LABEL_645;
          case 3:
            v523 = (__int16 *)malloc_type_malloc(4 * ((int)v820 + (int)v811 + 1), 0x100004052888210uLL);
            v473 = v523;
            if ((v850 & 1) != 0)
            {
              v524 = *v827;
              if ((_DWORD)v821)
              {
                if ((int)v820 >= 2)
                {
                  v525 = (int *)&v524[4 * *v843 - 4];
                  v526 = v820 - 1;
                  v527 = v523;
                  do
                  {
                    v528 = *v525--;
                    *v527++ = v528;
                    --v526;
                  }
                  while (v526);
                }
              }
              else
              {
                memcpy(v523, v524, v804);
              }
              v561 = &v473[2 * v795];
              *(_DWORD *)v561 = *(_DWORD *)v496;
              v550 = v561 + 2;
              v562 = (char *)*v847 + 4;
              v563 = 4 * ((int)v811 - 1);
              goto LABEL_643;
            }
            memcpy(v523, *v847, v819);
            v549 = &v473[2 * v797];
            *(_DWORD *)v549 = *(_DWORD *)v496;
            v550 = v549 + 2;
            v551 = *v827;
            if (!(_DWORD)v821)
            {
              v562 = v551 + 4;
              v563 = 4 * v795;
LABEL_643:
              memcpy(v550, v562, v563);
              goto LABEL_644;
            }
            if ((int)v820 >= 2)
            {
              v552 = (int *)&v551[4 * *v843 - 8];
              v553 = v819 + 4;
              v554 = v820 - 1;
              do
              {
                v555 = *v552--;
                *(_DWORD *)((char *)v473 + v553) = v555;
                v553 += 4;
                --v554;
              }
              while (v554);
            }
LABEL_644:
            v510 = v820 + (_DWORD)v811 + 1;
            goto LABEL_645;
          default:
            v510 = 0;
            goto LABEL_645;
        }
      }
      v468 = v501;
      ++v495;
      v469 = v499;
      if (v495 == v832)
      {
        v471 = v788;
        v472 = v789;
        v474 = v787;
        goto LABEL_685;
      }
    }
  }
LABEL_688:
  SelfClosureContourHeal((int *)&destR, v469, v468, (uint64_t)v470, 0);
  v868.data = (void *)0x800000000001;
  v868.height = (vImagePixelCount)malloc_type_calloc(0x8000uLL, 0x30uLL, 0x1020040D9DE8CEBuLL);
  v844 = (int)destR.data;
  if (SLODWORD(destR.data) < 1)
    goto LABEL_817;
  v596 = 1;
  v597 = destR.width;
  v598 = destR.width;
  while (2)
  {
    v599 = *(unsigned __int8 *)(v598 + 40);
    v598 += 40;
    if (!v599)
      goto LABEL_744;
    v600 = *(float *)v792;
    v601 = *(float *)(v792 + 8);
    kernel = 0uLL;
    *((_QWORD *)&kernel + 1) = malloc_type_calloc(8uLL, 8uLL, 0x100004000313F17uLL);
    DWORD1(kernel) = 8 * (*((_QWORD *)&kernel + 1) != 0);
    v602 = *(unsigned int *)(v597 + 44);
    if ((int)v602 <= 1)
      __assert_rtn("splitIntoMonotonicSpans", "SegmentUtilities.c", 85, "cPtr->nPnts > 1");
    v848 = v598;
    LODWORD(v850) = v596;
    v603 = (unsigned __int16)v596 | ((unsigned __int16)v596 << 16);
    v604 = *(unsigned __int8 *)(v597 + 48);
    v605 = (v602 - 1);
    if (*(_BYTE *)(v597 + 48))
      v606 = *(_DWORD *)(v597 + 44);
    else
      v606 = v602 - 1;
    __src = v597;
    v607 = *(_WORD **)(v597 + 56);
    v608 = (unsigned __int16 *)malloc_type_malloc(4 * v606, 0x100004052888210uLL);
    v609 = (char *)v608;
    v610 = 0;
    do
    {
      v611 = (__int16 *)&v608[v610];
      *v611 = v607[v610 + 2] - v607[v610];
      v611[1] = v607[v610 + 3] - v607[v610 + 1];
      v610 += 2;
    }
    while (2 * (v602 - 1) != v610);
    if (v604)
    {
      v612 = &v607[2 * v605];
      v613 = (__int16 *)&v608[2 * v605];
      *v613 = *v607 - *v612;
      v613[1] = v607[1] - v612[1];
      v614 = &v861;
    }
    else
    {
      v614 = 0;
    }
    LODWORD(destA.data) = 0;
    LODWORD(v861.data) = 0;
    v615 = (__int16)*v608;
    if (v615 < 0)
      v615 = -v615;
    v616 = (unsigned __int16)v615;
    v617 = (unsigned __int16)v615 == 1;
    v618 = (__int16)v608[1];
    if (v618 < 0)
      v618 = -v618;
    v619 = (unsigned __int16)v618;
    findDiff(v608, v606, v617 | (2 * ((unsigned __int16)v618 == 1)), &destA, v614);
    _ZF = v616 == 1 && LOWORD(destA.data) == 0;
    if (_ZF || v619 == 1 && !WORD1(destA.data))
    {
      if (v604)
        __assert_rtn("splitIntoMonotonicSpans", "SegmentUtilities.c", 130, "!closedP");
      addSpan((int *)&kernel, v602 << 32);
      goto LABEL_712;
    }
    sized = v604;
    v654 = SWORD1(v861.data);
    v655 = SLOWORD(v861.data) + SLOWORD(destA.data);
    v656 = SWORD1(v861.data) + SWORD1(destA.data);
    v657 = v655 < v656;
    if (v655 >= v656)
    {
      if (SLOWORD(v861.data) >= 1)
      {
        v659 = SLOWORD(v861.data);
        v834 = (char *)malloc_type_malloc(4 * v606, 0x100004052888210uLL);
        v824 = 4 * v659;
        v829 = (char *)malloc_type_malloc(4 * ((int)v602 + 1), 0x100004052888210uLL);
        memcpy(&v834[v824], v609, 4 * (int)(v606 - v659));
        memcpy(v834, &v609[4 * (v606 - v659)], v824);
        memcpy(&v829[v824], v607, 4 * (int)(v602 - v659));
        memcpy(v829, &v607[2 * (int)(v602 - v659)], v824);
        *(_QWORD *)(__src + 56) = v829;
        free(v607);
        free(v609);
        v609 = v834;
        v607 = v829;
      }
    }
    else
    {
      if (SWORD1(v861.data) >= 1)
      {
        v828 = SWORD1(v861.data) + SWORD1(destA.data);
        v658 = (char *)malloc_type_malloc(4 * v606, 0x100004052888210uLL);
        v821 = (unint64_t)malloc_type_malloc(4 * ((int)v602 + 1), 0x100004052888210uLL);
        v833 = 4 * v654;
        memcpy(&v658[v833], v609, 4 * (int)(v606 - v654));
        memcpy(v658, &v609[4 * (v606 - v654)], v833);
        memcpy((void *)(v821 + v833), v607, 4 * (int)(v602 - v654));
        memcpy((void *)v821, &v607[2 * (int)(v602 - v654)], v833);
        *(_QWORD *)(__src + 56) = v821;
        free(v607);
        free(v609);
        v656 = v828;
        v609 = v658;
        v607 = (_WORD *)v821;
      }
      v655 = v656;
    }
    if (sized)
      *(_DWORD *)&v607[2 * v602] = *(_DWORD *)v607;
    v660 = 0;
    v661 = 0;
    while (1)
    {
      v662 = v655 - v661;
      if (v657)
      {
        if (v655 > v661)
        {
          v663 = 0;
          v664 = -1;
          v665 = -1;
          v666 = &v609[4 * v661];
          while (1)
          {
            v668 = *(__int16 *)v666;
            v666 += 4;
            v667 = v668;
            if (v668 < 0 && v665 == -1)
              v665 = v663;
            if (v664 == -1 && v667 > 0)
              v664 = v663;
            if ((v665 & 0x80000000) == 0 && (v664 & 0x80000000) == 0)
              break;
            if (v662 == ++v663)
              goto LABEL_791;
          }
LABEL_792:
          if (v665 > v664)
            v664 = v665;
          v655 = v664 + v661;
          goto LABEL_795;
        }
      }
      else if (v655 > v661)
      {
        v671 = 0;
        v664 = -1;
        v665 = -1;
        v672 = &v609[4 * v661 + 2];
        while (1)
        {
          v674 = *(__int16 *)v672;
          v672 += 4;
          v673 = v674;
          if (v674 < 0 && v665 == -1)
            v665 = v671;
          if (v664 == -1 && v673 > 0)
            v664 = v671;
          if ((v665 & 0x80000000) == 0 && (v664 & 0x80000000) == 0)
            goto LABEL_792;
          if (v662 == ++v671)
            goto LABEL_791;
        }
      }
      if ((v660 & 1) == 0)
      {
LABEL_791:
        v660 = 0;
        goto LABEL_796;
      }
      v655 = v661 - 1;
LABEL_795:
      v660 = 1;
LABEL_796:
      if (v606 == v655)
        break;
      addSpan((int *)&kernel, v661 | ((unint64_t)(v655 - v661) << 32));
      if ((int)v606 < v655)
        __assert_rtn("splitIntoMonotonicSpans", "SegmentUtilities.c", 268, "idx <= monoLength");
      v677 = (unsigned __int16 *)&v609[4 * v655];
      v678 = (__int16)*v677;
      if (v678 < 0)
        v678 = -v678;
      v679 = (unsigned __int16)v678 == 1;
      v680 = (__int16)v677[1];
      if (v680 < 0)
        v680 = -v680;
      v681 = (unsigned __int16)v680;
      LODWORD(destA.data) = 0;
      findDiff(v677, v606 - v655, v679 | (2 * ((unsigned __int16)v680 == 1)), &destA, 0);
      v682 = SLOWORD(destA.data);
      if (v679 && LOWORD(destA.data) == 0)
        v682 = v606 - v655;
      v683 = SWORD1(destA.data);
      if (WORD1(destA.data))
        v684 = 0;
      else
        v684 = v681 == 1;
      if (v684)
        v683 = v606 - v655;
      v657 = v682 < v683;
      if (v682 > v683)
        v683 = v682;
      v661 = v655;
      v637 = (int)v606 <= v655;
      v655 += v683;
      if (v637)
        goto LABEL_712;
    }
    addSpan((int *)&kernel, v661 | ((unint64_t)(v606 - v661 + 1) << 32));
    if (v609)
LABEL_712:
      free(v609);
    v621 = __src;
    v622 = *(_QWORD *)(__src + 56);
    v623 = kernel;
    v624 = allocSegments((int *)&v868, kernel);
    v625 = (int *)*((_QWORD *)&kernel + 1);
    *(_DWORD *)(__src + 52) = v623;
    *(_QWORD *)(__src + 64) = v624;
    v626 = v624;
    v627 = v625;
    if ((int)v623 >= 2)
    {
      v628 = v623 - 1;
      v627 = v625;
      v626 = v624;
      do
      {
        *(_DWORD *)(v626 + 12) = v627[1] + 1;
        *(_QWORD *)(v626 + 40) = v622 + 4 * *v627;
        v626 = *(_QWORD *)v626;
        v627 += 2;
        --v628;
      }
      while (v628);
    }
    *(_DWORD *)(v626 + 12) = v627[1];
    *(_QWORD *)(v626 + 40) = v622 + 4 * *v627;
    v629 = 0;
    if (v624)
    {
      do
      {
        v630 = *(int **)(v624 + 40);
        v631 = *(_DWORD *)(v624 + 12);
        v632 = v630[v631 - 1];
        v633 = (__int16)v632 - (__int16)*v630;
        v634 = (v632 >> 16) - (*v630 >> 16);
        if (v634 >= 0)
          v635 = v634;
        else
          v635 = -v634;
        if (v633 >= 0)
          v636 = v633;
        else
          v636 = -v633;
        v637 = v635 > v636;
        v638 = v635 > v636;
        if (v637)
          v639 = v634;
        else
          v639 = v633;
        if (v637)
          v634 = v633;
        v640 = v634 & 0x10000 | v638 | (v639 >> 31 << 8);
        applyCoordTransform(v640, (uint64_t)v630, v631);
        v641 = *(_QWORD *)v624;
        v642 = straightLineWLSQ(*(__int16 **)(v624 + 40), *(_DWORD *)(v624 + 12));
        v644 = v643;
        v645 = *(float *)&v643;
        *(_DWORD *)(v624 + 16) = v643;
        *(float *)(v624 + 20) = Lsq2Leq(v642);
        *(_DWORD *)(v624 + 24) = v646;
        *(_DWORD *)(v624 + 28) = v647;
        if (v600 < v645)
          splitSegmentIntoStraightSegments((uint64_t *)v624, v642, v644, (int *)&v868, v600);
        if (v641 == v624)
        {
          v651 = 0;
        }
        else
        {
          v648 = -1;
          v649 = (_QWORD *)v624;
          do
          {
            v650 = v648;
            v649 = (_QWORD *)*v649;
            ++v648;
          }
          while (v649 != (_QWORD *)v641);
          if (v648)
          {
            v651 = mergeSegments((float *)v624, (v650 + 2), v601);
            if (v651 >= 2)
            {
              for (j = 1; j != v651; ++j)
              {
                v622 = v622 & 0xFFFFFFFFFF000000 | v640;
                revertSegmentCoordinateSystem(v624, *(_DWORD *)(v624 + 12) - 1, v622);
                *(_DWORD *)(v624 + 32) = v603;
                v624 = *(_QWORD *)v624;
              }
            }
          }
          else
          {
            v651 = 1;
          }
        }
        v653 = v624;
        v623 = v623 & 0xFFFFFFFFFF000000 | v640;
        revertSegmentCoordinateSystem(v624, *(_DWORD *)(v624 + 12), v623);
        *(_DWORD *)(v624 + 32) = v603;
        v629 += v651;
        v624 = v641;
      }
      while (v641);
      v621 = __src;
      *(_QWORD *)(__src + 72) = v653;
      v625 = (int *)*((_QWORD *)&kernel + 1);
    }
    *(_DWORD *)(v621 + 52) = v629;
    v596 = v850;
    v598 = v848;
    if (v625)
      free(v625);
LABEL_744:
    v597 = v598;
    _ZF = v596++ == v844;
    if (!_ZF)
      continue;
    break;
  }
LABEL_817:
  v685 = *(_DWORD *)&v869[8] + *(_DWORD *)&v869[16];
  AnnealContours((uint64_t)&destR, (_DWORD *)v792, *(_DWORD *)&v869[8] + *(_DWORD *)&v869[16]);
  MergeContours((uint64_t)&destR, v792, v685, (uint64_t)&v868, (uint64_t)v869, (uint64_t)v854, 0);
  AnnealContours((uint64_t)&destR, (_DWORD *)v792, v685);
  MergeContours((uint64_t)&destR, v792, v685, (uint64_t)&v868, (uint64_t)v869, (uint64_t)v854, 1);
  AnnealContours((uint64_t)&destR, (_DWORD *)v792, v685);
  MergeContours((uint64_t)&destR, v792, v685, (uint64_t)&v868, (uint64_t)v869, (uint64_t)v854, 1);
  AnnealContours((uint64_t)&destR, (_DWORD *)v792, v685);
  v686 = HIDWORD(destR.data);
  v687 = *(float *)(v792 + 104);
  v688 = malloc_type_malloc(4 * v685, 0x100004052888210uLL);
  v689 = *(_DWORD *)(v792 + 76);
  LODWORD(destA.data) = *(_DWORD *)(v792 + 8);
  HIDWORD(destA.data) = v689;
  destA.height = *(unsigned int *)(v792 + 16);
  destA.width = (vImagePixelCount)v688;
  *(_QWORD *)&kernel = 0;
  v873 = 0u;
  v877 = 0u;
  v878 = 0u;
  v875 = 0u;
  v876 = 0u;
  v874 = 0u;
  *((_QWORD *)&kernel + 1) = v869;
  *(_QWORD *)&v873 = v854;
  v817 = v688;
  *(_QWORD *)&v876 = v688;
  if ((int)v686 >= 1)
  {
    v690 = 0;
    v691 = llroundf(v687);
    v692 = v691 * v691;
    v830 = v686;
    v825 = v691 * v691;
    do
    {
      v693 = destR.width;
      v694 = *(__int16 *)(destR.height + 2 * v690);
      v695 = (_BYTE *)(destR.width + 40 * *(__int16 *)(destR.height + 2 * v690));
      if (*v695)
      {
        v696 = destR.width + 40 * *(__int16 *)(destR.height + 2 * v690);
        v698 = *(unsigned __int8 *)(v696 + 8);
        v697 = (_BYTE *)(v696 + 8);
        if (!v698)
        {
          v699 = destR.width + 40 * *(__int16 *)(destR.height + 2 * v690);
          v702 = *(_QWORD *)(v699 + 32);
          v700 = (uint64_t *)(v699 + 32);
          v701 = (uint64_t *)v702;
          v703 = *(__int16 **)(*(v700 - 1) + 40);
          v704 = *v703;
          v705 = v703[1];
          v706 = *(_QWORD *)(v702 + 40) + 4 * *(int *)(v702 + 12);
          v707 = *(__int16 *)(v706 - 4);
          v708 = *(__int16 *)(v706 - 2);
          if ((v704 - v707) * (v704 - v707) + (v705 - v708) * (v705 - v708) <= v692)
          {
            v835 = v707;
            sizee = v708;
            v709 = (unsigned __int16)v707 | ((unint64_t)(unsigned __int16)v708 << 16);
            v849 = v704;
            v845 = v705;
            v710 = (unsigned __int16)v704 | ((unint64_t)(unsigned __int16)v705 << 16);
            v850 = v709 | v850 & 0xFFFFFFFF00000000;
            __src = v710 | __src & 0xFFFFFFFF00000000;
            if (checkBridgeCrossing((uint64_t)&kernel, (unsigned __int16)v707 | ((unsigned __int16)v708 << 16), (unsigned __int16)v704 | ((unsigned __int16)v705 << 16)))
            {
              v819 = v819 & 0xFFFFFFFF00000000 | ((unint64_t)(unsigned __int16)v694 << 16);
              v820 = v709 | v820 & 0xFFFFFFFF00000000;
              v821 = v710 | v821 & 0xFFFFFFFF00000000;
              BridgeSegment = createBridgeSegment((int *)&v868, (unsigned __int16)v694 << 16, v709, v710);
              *v701 = BridgeSegment;
              *v700 = BridgeSegment;
              ++*(_DWORD *)(v693 + 40 * v694 + 12);
              *v697 = 1;
              v712 = *(unsigned int *)(BridgeSegment + 12);
              if ((int)v712 >= 1)
              {
                v713 = *(_QWORD *)v869;
                v714 = *(_QWORD *)&v869[24] << 32;
                v715 = (__int16 *)(*(_QWORD *)(BridgeSegment + 40) + 2);
                do
                {
                  *(_BYTE *)(v713 + *(v715 - 1) + ((v714 * *v715) >> 32)) = 1;
                  v715 += 2;
                  --v712;
                }
                while (v712);
              }
              v716 = (char *)v854[0];
              v717 = *((_QWORD *)&v855 + 1);
              *(_WORD *)((char *)v854[0] + 2 * v835 + *((_QWORD *)&v855 + 1) * sizee) = 0;
              *(_WORD *)&v716[2 * v849 + v717 * v845] = 0;
              AnnealContour((uint64_t)v695, (uint64_t)&destA);
            }
            v686 = v830;
            v692 = v825;
          }
        }
      }
      ++v690;
    }
    while (v690 != v686);
  }
  if (v817)
    free(v817);
  v718 = (float *)malloc_type_malloc(32 * SHIDWORD(destR.data), 0x1000040E0EAB150uLL);
  v719 = Contours2Quads((uint64_t)&destR, (float *)v792, (uint64_t *)v869, (uint64_t)v718, HIDWORD(destR.data));
  v720 = v719;
  if (v719 < 2)
  {
    v741 = v719;
    v765 = a3;
    v766 = a5;
    if (v719 == 1)
    {
      v767 = v718 + 1;
      v768 = 0.0;
      for (k = 1; k != 5; ++k)
      {
        v768 = v768 + (float)((float)(*(v767 - 1) * v718[2 * (k & 3) + 1]) - (float)(v718[2 * (k & 3)] * *v767));
        v767 += 2;
      }
      canonicalizeQuad((uint64_t)v718, v768);
      v741 = 1;
    }
  }
  else
  {
    v721 = (char *)malloc_type_malloc(32 * v719, 0x1000040E0EAB150uLL);
    v722 = (vDSP_Length *)malloc_type_malloc(8 * v720, 0x100004000313F17uLL);
    v723 = (float *)malloc_type_malloc(4 * v720, 0x100004052888210uLL);
    v724 = (float32x2_t *)malloc_type_calloc(v720, 8uLL, 0x100004000313F17uLL);
    v725 = malloc_type_malloc(v720, 0x100004077774924uLL);
    v851 = (int *)malloc_type_malloc(4 * v720, 0x100004052888210uLL);
    v726 = 0;
    v727 = v718 + 1;
    __asm { FMOV            V9.2S, #0.25 }
    __srca = v718;
    do
    {
      v732 = 0.0;
      v733 = v727;
      for (m = 1; m != 5; ++m)
      {
        v732 = v732 + (float)((float)(*(v733 - 1) * v718[2 * (m & 3) + 1]) - (float)(v718[2 * (m & 3)] * *v733));
        v733 += 2;
      }
      canonicalizeQuad((uint64_t)v718, v732);
      v735 = 0;
      v723[v726] = fabsf(v732);
      v722[v726] = v726;
      v725[v726] = 1;
      v736 = 0;
      do
      {
        v736 = vadd_f32(v736, *(float32x2_t *)&v718[v735]);
        v735 += 2;
      }
      while (v735 != 6);
      v724[v726] = vmul_f32(v736, _D9);
      v737 = &v721[32 * v726];
      v738 = *(_OWORD *)v718;
      v739 = *((_OWORD *)v718 + 1);
      v718 += 8;
      *(_OWORD *)v737 = v738;
      *((_OWORD *)v737 + 1) = v739;
      ++v726;
      v727 += 8;
    }
    while (v726 != v720);
    vDSP_vsorti(v723, v722, 0, v720, -1);
    v740 = 0;
    v741 = 0;
    v718 = __srca;
    do
    {
      v742 = v722[v740];
      if (v725[v742])
      {
        v743 = (float32x4_t *)&v721[32 * v742];
        if (++v740 >= (int)v720)
          goto LABEL_854;
        v744 = 0;
        v745 = (float *)&v724[v742];
        v746 = v740;
        v747 = (uint64_t)&v721[32 * v742 + 4];
        while (1)
        {
          v748 = v722[v746];
          if (v725[v748])
          {
            if ((float)((float)((float)(v745[1] - v724[v748].f32[1]) * (float)(v745[1] - v724[v748].f32[1]))
                       + (float)((float)(*v745 - v724[v748].f32[0]) * (float)(*v745 - v724[v748].f32[0]))) <= 100.0)
              break;
          }
LABEL_848:
          if (v720 == (_DWORD)++v746)
            goto LABEL_849;
        }
        v749 = 0;
        v750 = &v721[32 * v748];
        while (1)
        {
          v751 = *(float *)(v747 + v749 - 4) - *(float *)&v750[v749];
          if ((float)((float)((float)(*(float *)(v747 + v749) - *(float *)&v750[v749 + 4])
                             * (float)(*(float *)(v747 + v749) - *(float *)&v750[v749 + 4]))
                     + (float)(v751 * v751)) > 100.0)
            break;
          v749 += 8;
          if (v749 == 24)
          {
            v851[v744++] = v746;
            goto LABEL_848;
          }
        }
LABEL_849:
        if (v744)
        {
          v753 = *v743;
          v752 = v743[1];
          if (v744 <= 0)
          {
            v760 = (float32x4_t)vuzp1q_s32((int32x4_t)v753, (int32x4_t)v752);
            v759 = (float32x4_t)vuzp2q_s32((int32x4_t)v753, (int32x4_t)v752);
          }
          else
          {
            v754 = v744;
            v755 = v851;
            do
            {
              v756 = *v755++;
              v757 = v722[v756];
              v725[v757] = 0;
              v758 = (float32x4_t *)&v721[32 * v757];
              v752 = vaddq_f32(v758[1], v752);
              v753 = vaddq_f32(*v758, v753);
              --v754;
            }
            while (v754);
            v759 = (float32x4_t)vuzp2q_s32((int32x4_t)v753, (int32x4_t)v752);
            v760 = (float32x4_t)vuzp1q_s32((int32x4_t)v753, (int32x4_t)v752);
          }
          v763 = 1.0 / (float)(v744 + 1);
          v880.val[0] = vmulq_n_f32(v760, v763);
          v880.val[1] = vmulq_n_f32(v759, v763);
          v764 = &__srca[8 * v741];
          vst2q_f32(v764, v880);
        }
        else
        {
LABEL_854:
          v761 = v743[1];
          v762 = (float32x4_t *)&__srca[8 * v741];
          *v762 = *v743;
          v762[1] = v761;
        }
        ++v741;
      }
      else
      {
        ++v740;
      }
    }
    while (v740 < (int)v720);
    if (v721)
      free(v721);
    v765 = a3;
    if (v722)
      free(v722);
    v766 = a5;
    if (v723)
      free(v723);
    if (v724)
      free(v724);
    if (v725)
      free(v725);
    if (v851)
      free(v851);
  }
  if (v741 >= *(_DWORD *)(v792 + 72))
    v770 = *(_DWORD *)(v792 + 72);
  else
    v770 = v741;
  memcpy(v765, v718, 32 * v770);
  v463 = v770 > 0;
  if (v770 >= 1)
    memset_pattern16(a4, &unk_1A15FB810, 4 * v770);
  *v766 = v770;
  if (v718)
    free(v718);
  if (__E)
    free(__E);
  if (destG.data)
  {
    free(destG.data);
    destG.data = 0;
  }
  if (destB.data)
    free(destB.data);
  if (dest.data)
    free(dest.data);
  if (src.data)
    free(src.data);
  if (v780)
    free(v780);
  if (v784)
    free(v784);
  if (v779)
    free(v779);
  if (*(_QWORD *)v869)
  {
    free(*(void **)v869);
    *(_QWORD *)v869 = 0;
  }
  if (v854[0])
  {
    free(v854[0]);
    v854[0] = 0;
  }
  releaseContourDatabaseMemory((uint64_t)&destR);
  v771 = (void *)v868.height;
  if (v868.height)
  {
    v772 = (int)v868.data;
    if (SLODWORD(v868.data) >= 2)
    {
      v773 = (void **)(v868.height + 88);
      v774 = 1;
      do
      {
        if (*((_BYTE *)v773 - 32) && *((__int16 *)v773 - 4) <= 0 && *v773)
        {
          free(*v773);
          *v773 = 0;
          v772 = (int)v868.data;
        }
        ++v774;
        v773 += 6;
      }
      while (v774 < v772);
      v771 = (void *)v868.height;
    }
    free(v771);
  }
  return v463;
}

void sub_1A1585E74(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A1586EC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21,void *a22,void *a23,void *a24,void *a25)
{
  void *v25;
  void *v26;
  void *v27;

  _Unwind_Resume(a1);
}

void sub_1A15875EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, uint64_t a12, void *a13, void *a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,void *a23,void *a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,id a32)
{
  void *v32;
  void *v33;

  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__30091(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__30092(uint64_t a1)
{

}

void sub_1A158780C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A15878CC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A15879C8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1A1587DF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

void sub_1A1588108(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14)
{
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

void sub_1A1588208(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1A1588444(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void vision::mod::ImageDescriptor_EspressoSmartCam::~ImageDescriptor_EspressoSmartCam(vision::mod::ImageDescriptor_EspressoSmartCam *this)
{
  *(_QWORD *)this = &off_1E453AC98;
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)this + 48);
}

{
  *(_QWORD *)this = &off_1E453AC98;
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)this + 48);
  JUMPOUT(0x1A1B0A898);
}

uint64_t vision::mod::ImageDescriptor_EspressoSmartCam::getRequiredImageType(vision::mod::ImageDescriptor_EspressoSmartCam *this)
{
  return 6;
}

void std::__shared_ptr_emplace<vision::mod::ImageDescriptor_EspressoSmartCam>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453BAA8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<vision::mod::ImageDescriptor_EspressoSmartCam>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453BAA8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A1B0A898);
}

uint64_t std::__shared_ptr_emplace<vision::mod::ImageDescriptor_EspressoSmartCam>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void sub_1A15885E4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15886AC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A158874C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1588A80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

void sub_1A1588BA0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1588BEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A1588CD0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void computePhogDescriptor(_BYTE *a1, void **a2)
{
  float *v3;
  _DWORD *v4;
  float *v5;
  uint64_t i;
  long double v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE *v11;
  float *v12;
  _DWORD *v13;
  uint64_t j;
  float v15;
  uint64_t v16;
  float v17;
  uint64_t k;
  float v19;
  uint64_t m;
  unsigned int v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  unsigned int v26;
  _DWORD *v27;
  float *v28;
  char *v29;
  float *v30;
  float *v31;
  float *v32;
  BOOL v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  int v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  int v43;
  float *v44;
  float v45;
  int v46;
  uint64_t v47;
  char *v48;
  double v49;
  float32x4_t v50;
  float64x2_t v51;
  float64x2_t v52;
  uint64_t v53;
  float64x2_t v54;
  _DWORD *v56;
  float *v57;
  float *v58;
  _DWORD *v59;
  float *v60;
  int v61;
  int v62;
  int v63;
  _BYTE v64[48];
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  v3 = (float *)malloc_type_malloc(0x2400uLL, 0x7AA728CFuLL);
  v4 = malloc_type_malloc(0x2400uLL, 0x81089231uLL);
  v60 = (float *)malloc_type_malloc(0x2400uLL, 0x60497EF4uLL);
  v59 = malloc_type_malloc(0x2400uLL, 0xCBE22EA3uLL);
  v5 = (float *)malloc_type_malloc(0x2400uLL, 0xBECD2043uLL);
  v58 = (float *)malloc_type_malloc(0x2400uLL, 0x76638E7EuLL);
  for (i = 0; i != 4; ++i)
  {
    v7 = ldexp(1.0, i);
    *(_DWORD *)&v64[4 * i + 32] = (int)v7;
    v8 = 48 / (int)v7;
    *(_DWORD *)&v64[4 * i + 16] = v8;
    *(_DWORD *)&v64[4 * i] = v8;
  }
  v9 = 0;
  v10 = 0;
  v11 = a1 + 1;
  v13 = v59;
  v12 = v60;
  do
  {
    for (j = 0; j != 47; ++j)
    {
      LOBYTE(v7) = v11[j];
      v15 = (float)LODWORD(v7);
      v3[v9 + j] = v15;
      LOBYTE(v15) = v11[j - 1];
      *(float *)&v7 = (float)LODWORD(v15);
      v4[v9 + 1 + j] = LODWORD(v7);
    }
    v16 = 48 * v10 + 47;
    LOBYTE(v7) = a1[v16];
    v17 = (float)LODWORD(v7);
    v3[v16] = v17;
    LOBYTE(v17) = a1[48 * v10];
    *(float *)&v7 = (float)LODWORD(v17);
    v4[48 * v10++] = LODWORD(v7);
    v9 += 48;
    v11 += 48;
  }
  while (v10 != 48);
  for (k = 0; k != 2256; ++k)
  {
    LOBYTE(v7) = a1[k + 48];
    v19 = (float)LODWORD(v7);
    v60[k] = v19;
    LOBYTE(v19) = a1[k];
    *(float *)&v7 = (float)LODWORD(v19);
    v59[k + 48] = LODWORD(v7);
  }
  for (m = 0; m != 48; ++m)
  {
    LOBYTE(v7) = *a1;
    *(float *)&v21 = (float)LODWORD(v7);
    v59[m] = v21;
    LOBYTE(v21) = a1[2256];
    *(float *)&v7 = (float)v21;
    v60[m + 2256] = *(float *)&v7;
    ++a1;
  }
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v56 = v4;
  v57 = v3;
  do
  {
    v25 = 0;
    v62 = v23;
    v61 = v24;
    v63 = v22;
    v26 = v22 - 1;
    v27 = &v13[v24];
    v28 = &v12[v24];
    v29 = (char *)&v4[v24];
    v30 = &v3[v24];
    v31 = &v58[v23];
    v32 = &v5[v23];
    do
    {
      v33 = (_DWORD)v25 == 47 || (_DWORD)v25 == 0;
      v34 = (float)(v30[v25] - *(float *)&v29[4 * v25]) * 0.5;
      if (v33)
        v34 = v30[v25] - *(float *)&v29[4 * v25];
      v35 = (float)(v28[v25] - *(float *)&v27[v25]) * 0.5;
      if (v26 >= 0x2E)
        v35 = v28[v25] - *(float *)&v27[v25];
      v36 = sqrtf((float)(v35 * v35) + (float)(v34 * v34));
      if (v34 == 0.0)
        v37 = 0.00001;
      else
        v37 = v34;
      v38 = (atan2f(v35, v37) + 3.14159265) * 180.0 / 3.14159265;
      v32[v25] = v36;
      v31[v25++] = ceilf(v38 / 45.0);
    }
    while ((_DWORD)v25 != 48);
    v23 = v62 + 48;
    v24 = v61 + 48;
    v22 = v63 + 1;
    v4 = v56;
    v3 = v57;
    v13 = v59;
    v12 = v60;
  }
  while (v63 != 47);
  bzero(*a2, 0xAA0uLL);
  v39 = 0;
  LODWORD(v40) = 0;
  do
  {
    v41 = 0;
    v40 = (int)v40;
    do
    {
      v42 = 0;
      v43 = (int)(float)(v58[v40] + -1.0);
      v44 = (float *)*a2;
      do
      {
        v45 = v5[v40];
        if (v45 > 0.0)
        {
          v46 = dword_1A15FB820[v42]
              + v43
              + 8
              * (v39 / *(_DWORD *)&v64[v42 * 4] + *(_DWORD *)&v64[v42 * 4 + 32] * (v41 / *(_DWORD *)&v64[v42 * 4 + 16]));
          v44[v46] = v45 + v44[v46];
        }
        ++v42;
      }
      while (v42 != 4);
      ++v40;
      ++v41;
    }
    while (v41 != 48);
    ++v39;
  }
  while (v39 != 48);
  v47 = 0;
  v48 = (char *)*a2;
  v49 = 0.0;
  do
  {
    v50 = *(float32x4_t *)&v48[v47];
    v51 = vcvt_hight_f64_f32(v50);
    v52 = vcvtq_f64_f32(*(float32x2_t *)v50.f32);
    v49 = v49 + v52.f64[0] + v52.f64[1] + v51.f64[0] + v51.f64[1];
    v47 += 16;
  }
  while (v47 != 2720);
  v53 = 0;
  v54 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v49, 0);
  do
  {
    *(float32x4_t *)&v48[v53] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(vcvtq_f64_f32(*(float32x2_t *)&v48[v53]), v54)), vdivq_f64(vcvt_hight_f64_f32(*(float32x4_t *)&v48[v53]), v54));
    v53 += 16;
  }
  while (v53 != 2720);
  free(v57);
  free(v56);
  free(v59);
  free(v60);
  free(v5);
  free(v58);
}

void vision::mod::LandmarkAttributes::init(_QWORD *a1, _QWORD *a2, char a3)
{
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  unsigned __int8 *v15;
  unsigned __int8 *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  unsigned __int8 *v24;
  unsigned __int8 *v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  unsigned __int8 *v33;
  unsigned __int8 *v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t *v37;
  unint64_t v38;
  std::__shared_weak_count *v39;
  unint64_t *v40;
  unint64_t v41;
  unsigned __int8 *v42;
  unsigned __int8 *v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t *v46;
  unint64_t v47;
  std::__shared_weak_count *v48;
  unint64_t *v49;
  unint64_t v50;
  unsigned __int8 *v51;
  unsigned __int8 *v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t *v55;
  unint64_t v56;
  std::__shared_weak_count *v57;
  unint64_t *v58;
  unint64_t v59;
  unsigned __int8 *v60;
  unsigned __int8 *v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t *v64;
  unint64_t v65;
  std::__shared_weak_count *v66;
  unint64_t *v67;
  unint64_t v68;
  char v69;
  _QWORD *exception;
  void *__p[2];
  char v72;
  __int128 v73;

  std::string::basic_string[abi:ne180100]<0>(__p, "scorPdiffParameters");
  v6 = std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(a2, (unsigned __int8 *)__p);
  v7 = v6;
  if (v6)
  {
    if (*((_DWORD *)v6 + 10) == 2)
    {
      v9 = *((_QWORD *)v6 + 6);
      v8 = *((_QWORD *)v6 + 7);
      if (v8)
      {
        v10 = (unint64_t *)(v8 + 8);
        do
          v11 = __ldxr(v10);
        while (__stxr(v11 + 1, v10));
      }
      *(_QWORD *)&v73 = v9;
      *((_QWORD *)&v73 + 1) = v8;
      std::shared_ptr<vision::mod::ImageAnalyzer>::operator=[abi:ne180100]((uint64_t)(a1 + 1), &v73);
      v12 = (std::__shared_weak_count *)*((_QWORD *)&v73 + 1);
      if (*((_QWORD *)&v73 + 1))
      {
        v13 = (unint64_t *)(*((_QWORD *)&v73 + 1) + 8);
        do
          v14 = __ldaxr(v13);
        while (__stlxr(v14 - 1, v13));
        if (!v14)
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
      }
      *a1 = *((_QWORD *)v7 + 8);
      LOBYTE(v7) = 1;
    }
    else
    {
      LOBYTE(v7) = 0;
    }
  }
  if (v72 < 0)
    operator delete(__p[0]);
  if ((v7 & 1) == 0)
    goto LABEL_108;
  std::string::basic_string[abi:ne180100]<0>(__p, "exprParameters");
  v15 = std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(a2, (unsigned __int8 *)__p);
  v16 = v15;
  if (v15)
  {
    if (*((_DWORD *)v15 + 10) == 2)
    {
      v18 = *((_QWORD *)v15 + 6);
      v17 = *((_QWORD *)v15 + 7);
      if (v17)
      {
        v19 = (unint64_t *)(v17 + 8);
        do
          v20 = __ldxr(v19);
        while (__stxr(v20 + 1, v19));
      }
      *(_QWORD *)&v73 = v18;
      *((_QWORD *)&v73 + 1) = v17;
      std::shared_ptr<vision::mod::ImageAnalyzer>::operator=[abi:ne180100]((uint64_t)(a1 + 11), &v73);
      v21 = (std::__shared_weak_count *)*((_QWORD *)&v73 + 1);
      if (*((_QWORD *)&v73 + 1))
      {
        v22 = (unint64_t *)(*((_QWORD *)&v73 + 1) + 8);
        do
          v23 = __ldaxr(v22);
        while (__stlxr(v23 - 1, v22));
        if (!v23)
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }
      a1[10] = *((_QWORD *)v16 + 8);
      LOBYTE(v16) = 1;
    }
    else
    {
      LOBYTE(v16) = 0;
    }
  }
  if (v72 < 0)
    operator delete(__p[0]);
  if ((v16 & 1) == 0)
    goto LABEL_108;
  std::string::basic_string[abi:ne180100]<0>(__p, "blinkParametersApp");
  v24 = std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(a2, (unsigned __int8 *)__p);
  v25 = v24;
  if (v24)
  {
    if (*((_DWORD *)v24 + 10) == 2)
    {
      v27 = *((_QWORD *)v24 + 6);
      v26 = *((_QWORD *)v24 + 7);
      if (v26)
      {
        v28 = (unint64_t *)(v26 + 8);
        do
          v29 = __ldxr(v28);
        while (__stxr(v29 + 1, v28));
      }
      *(_QWORD *)&v73 = v27;
      *((_QWORD *)&v73 + 1) = v26;
      std::shared_ptr<vision::mod::ImageAnalyzer>::operator=[abi:ne180100]((uint64_t)(a1 + 20), &v73);
      v30 = (std::__shared_weak_count *)*((_QWORD *)&v73 + 1);
      if (*((_QWORD *)&v73 + 1))
      {
        v31 = (unint64_t *)(*((_QWORD *)&v73 + 1) + 8);
        do
          v32 = __ldaxr(v31);
        while (__stlxr(v32 - 1, v31));
        if (!v32)
        {
          ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
          std::__shared_weak_count::__release_weak(v30);
        }
      }
      a1[19] = *((_QWORD *)v25 + 8);
      LOBYTE(v25) = 1;
    }
    else
    {
      LOBYTE(v25) = 0;
    }
  }
  if (v72 < 0)
    operator delete(__p[0]);
  if ((v25 & 1) == 0)
    goto LABEL_108;
  std::string::basic_string[abi:ne180100]<0>(__p, "smileBlinkParametersGeo");
  v33 = std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(a2, (unsigned __int8 *)__p);
  v34 = v33;
  if (v33)
  {
    if (*((_DWORD *)v33 + 10) == 2)
    {
      v36 = *((_QWORD *)v33 + 6);
      v35 = *((_QWORD *)v33 + 7);
      if (v35)
      {
        v37 = (unint64_t *)(v35 + 8);
        do
          v38 = __ldxr(v37);
        while (__stxr(v38 + 1, v37));
      }
      *(_QWORD *)&v73 = v36;
      *((_QWORD *)&v73 + 1) = v35;
      std::shared_ptr<vision::mod::ImageAnalyzer>::operator=[abi:ne180100]((uint64_t)(a1 + 17), &v73);
      v39 = (std::__shared_weak_count *)*((_QWORD *)&v73 + 1);
      if (*((_QWORD *)&v73 + 1))
      {
        v40 = (unint64_t *)(*((_QWORD *)&v73 + 1) + 8);
        do
          v41 = __ldaxr(v40);
        while (__stlxr(v41 - 1, v40));
        if (!v41)
        {
          ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
          std::__shared_weak_count::__release_weak(v39);
        }
      }
      a1[16] = *((_QWORD *)v34 + 8);
      LOBYTE(v34) = 1;
    }
    else
    {
      LOBYTE(v34) = 0;
    }
  }
  if (v72 < 0)
    operator delete(__p[0]);
  if ((v34 & 1) == 0)
    goto LABEL_108;
  std::string::basic_string[abi:ne180100]<0>(__p, "lmarkQuality");
  v42 = std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(a2, (unsigned __int8 *)__p);
  v43 = v42;
  if (v42)
  {
    if (*((_DWORD *)v42 + 10) == 2)
    {
      v45 = *((_QWORD *)v42 + 6);
      v44 = *((_QWORD *)v42 + 7);
      if (v44)
      {
        v46 = (unint64_t *)(v44 + 8);
        do
          v47 = __ldxr(v46);
        while (__stxr(v47 + 1, v46));
      }
      *(_QWORD *)&v73 = v45;
      *((_QWORD *)&v73 + 1) = v44;
      std::shared_ptr<vision::mod::ImageAnalyzer>::operator=[abi:ne180100]((uint64_t)(a1 + 4), &v73);
      v48 = (std::__shared_weak_count *)*((_QWORD *)&v73 + 1);
      if (*((_QWORD *)&v73 + 1))
      {
        v49 = (unint64_t *)(*((_QWORD *)&v73 + 1) + 8);
        do
          v50 = __ldaxr(v49);
        while (__stlxr(v50 - 1, v49));
        if (!v50)
        {
          ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
          std::__shared_weak_count::__release_weak(v48);
        }
      }
      a1[3] = *((_QWORD *)v43 + 8);
      LOBYTE(v43) = 1;
    }
    else
    {
      LOBYTE(v43) = 0;
    }
  }
  if (v72 < 0)
    operator delete(__p[0]);
  if ((v43 & 1) == 0)
    goto LABEL_108;
  std::string::basic_string[abi:ne180100]<0>(__p, "exprParamsv1");
  v51 = std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(a2, (unsigned __int8 *)__p);
  v52 = v51;
  if (v51)
  {
    if (*((_DWORD *)v51 + 10) == 2)
    {
      v54 = *((_QWORD *)v51 + 6);
      v53 = *((_QWORD *)v51 + 7);
      if (v53)
      {
        v55 = (unint64_t *)(v53 + 8);
        do
          v56 = __ldxr(v55);
        while (__stxr(v56 + 1, v55));
      }
      *(_QWORD *)&v73 = v54;
      *((_QWORD *)&v73 + 1) = v53;
      std::shared_ptr<vision::mod::ImageAnalyzer>::operator=[abi:ne180100]((uint64_t)(a1 + 14), &v73);
      v57 = (std::__shared_weak_count *)*((_QWORD *)&v73 + 1);
      if (*((_QWORD *)&v73 + 1))
      {
        v58 = (unint64_t *)(*((_QWORD *)&v73 + 1) + 8);
        do
          v59 = __ldaxr(v58);
        while (__stlxr(v59 - 1, v58));
        if (!v59)
        {
          ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
          std::__shared_weak_count::__release_weak(v57);
        }
      }
      a1[13] = *((_QWORD *)v52 + 8);
      LOBYTE(v52) = 1;
    }
    else
    {
      LOBYTE(v52) = 0;
    }
  }
  if (v72 < 0)
    operator delete(__p[0]);
  if ((v52 & 1) == 0)
    goto LABEL_108;
  if ((a3 & 1) == 0)
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "pupilMeanStd");
    v60 = std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(a2, (unsigned __int8 *)__p);
    if (v60 && (v61 = v60, *((_DWORD *)v60 + 10) == 2))
    {
      v63 = *((_QWORD *)v60 + 6);
      v62 = *((_QWORD *)v60 + 7);
      if (v62)
      {
        v64 = (unint64_t *)(v62 + 8);
        do
          v65 = __ldxr(v64);
        while (__stxr(v65 + 1, v64));
      }
      *(_QWORD *)&v73 = v63;
      *((_QWORD *)&v73 + 1) = v62;
      std::shared_ptr<vision::mod::ImageAnalyzer>::operator=[abi:ne180100]((uint64_t)(a1 + 8), &v73);
      v66 = (std::__shared_weak_count *)*((_QWORD *)&v73 + 1);
      if (*((_QWORD *)&v73 + 1))
      {
        v67 = (unint64_t *)(*((_QWORD *)&v73 + 1) + 8);
        do
          v68 = __ldaxr(v67);
        while (__stlxr(v68 - 1, v67));
        if (!v68)
        {
          ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
          std::__shared_weak_count::__release_weak(v66);
        }
      }
      a1[7] = *((_QWORD *)v61 + 8);
      v69 = 1;
    }
    else
    {
      v69 = 0;
    }
    if (v72 < 0)
      operator delete(__p[0]);
    if ((v69 & 1) == 0)
    {
LABEL_108:
      exception = __cxa_allocate_exception(8uLL);
      *exception = 2936;
      __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
    }
  }
}

vision::mod::LandmarkAttributes *vision::mod::LandmarkAttributes::LandmarkAttributes(vision::mod::LandmarkAttributes *this, char *a2, char a3)
{
  id v6;
  void *v7;
  uint64_t v8;
  void *v9;
  _QWORD *exception;
  _OWORD v12[2];
  int v13;

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 14) = 0;
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 17) = 0;
  *((_QWORD *)this + 18) = 0;
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 21) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  memset(v12, 0, sizeof(v12));
  v13 = 1065353216;
  vision::mod::readBinSerializedModelValues(a2, vision::mod::LandmarkAttributes::sModelFileInfo, v12);
  vision::mod::LandmarkAttributes::init(this, v12, a3);
  if ((a3 & 1) == 0)
  {
    v6 = objc_alloc(MEMORY[0x1E0D1F4F8]);
    v7 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0D1F4E8]), "initWithPlatform:", 0);
    v8 = objc_msgSend(v6, "initWithJSFile:binSerializerId:context:computePath:", a2, "pupil", v7, 0);
    v9 = (void *)*((_QWORD *)this + 6);
    *((_QWORD *)this + 6) = v8;

    if (!*((_QWORD *)this + 6))
    {
      exception = __cxa_allocate_exception(8uLL);
      *exception = 2936;
      __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>>>::~__hash_table((uint64_t)v12);
  return this;
}

void sub_1A158985C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  va_list va;

  va_start(va, a3);
  std::__hash_table<std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>>>::~__hash_table((uint64_t)va);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](v9);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](v8);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](v7);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](v6);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](v5);

  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](a3);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](v3);
  _Unwind_Resume(a1);
}

_QWORD *vision::mod::LandmarkAttributes::LandmarkAttributes(_QWORD *a1, _QWORD *a2, char a3)
{
  a1[1] = 0;
  a1[2] = 0;
  a1[4] = 0;
  a1[8] = 0;
  a1[9] = 0;
  a1[11] = 0;
  a1[14] = 0;
  a1[12] = 0;
  a1[15] = 0;
  a1[17] = 0;
  a1[18] = 0;
  a1[20] = 0;
  a1[21] = 0;
  a1[5] = 0;
  a1[6] = 0;
  vision::mod::LandmarkAttributes::init(a1, a2, a3);
  return a1;
}

void sub_1A1589958(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](v8);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](v7);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](v6);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](v5);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](v4);

  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](v3);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void vision::mod::LandmarkAttributes::~LandmarkAttributes(id *this)
{
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)(this + 20));
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)(this + 17));
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)(this + 14));
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)(this + 11));
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)(this + 8));

  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)(this + 4));
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)(this + 1));
}

float *vision::mod::LandmarkAttributes::computePixelDistanceFeature(_QWORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5;
  float *result;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float *v15;
  uint64_t v16;
  float *v17;
  uint64_t v18;
  float v19;
  float v20;
  int v21;

  v5 = (a3[1] - *a3) >> 3;
  v21 = 0;
  result = (float *)std::vector<float>::vector(a1, ((unint64_t)((v5 - 1) * v5) >> 1) + 1, &v21);
  LODWORD(v7) = 0;
  v8 = *a3;
  v9 = a3[1] - *a3;
  v10 = *(_QWORD *)result;
  if ((int)(v9 >> 3) >= 2)
  {
    v11 = 0;
    LODWORD(v7) = 0;
    v12 = (v9 >> 3) - 1;
    v13 = (int)((uint64_t)v9 >> 3);
    v14 = (v9 >> 3) - 1;
    v15 = (float *)(v8 + 12);
    do
    {
      v16 = v11 + 1;
      if (v11 + 1 < v13)
      {
        v17 = (float *)(v8 + 8 * v11);
        v7 = (int)v7;
        result = v15;
        v18 = v14;
        do
        {
          v19 = (float)(*v17 - *(result - 1)) / *(float *)(a2 + 12);
          v20 = *result;
          result += 2;
          *(float *)(v10 + 4 * v7++) = sqrtf((float)((float)((float)(v17[1] - v20) / *(float *)(a2 + 8))* (float)((float)(v17[1] - v20) / *(float *)(a2 + 8)))+ (float)(v19 * v19));
          --v18;
        }
        while (v18);
      }
      --v14;
      v15 += 2;
      v11 = v16;
    }
    while (v16 != v12);
  }
  *(_DWORD *)(v10 + 4 * (int)v7) = 1065353216;
  return result;
}

void sub_1A158A074(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void **tplTrackerResampler_alloc(uint64_t a1, uint64_t a2)
{
  int64x2_t *v4;
  uint64_t *v5;
  uint64x2_t v6;
  int64x2_t v7;
  size_t v8;
  void *v9;
  void *v10;
  void *v11;
  int64x2_t *v13;

  v4 = (int64x2_t *)malloc_type_calloc(1uLL, 0x68uLL, 0x10100405B433AA0uLL);
  v5 = (uint64_t *)v4;
  v13 = v4;
  if (v4)
  {
    v4[4].i32[2] = 1066192077;
    v4->i64[0] = a1;
    v4->i64[1] = a2;
    v6.i64[0] = a1;
    v6.i64[1] = a2;
    v7 = vaddq_s64((int64x2_t)vcvtq_u64_f64(vcvtq_f64_f32(vrndp_f32(vmul_f32(vmul_f32(vcvt_f32_f64(vcvtq_f64_u64(v6)), (float32x2_t)vdup_n_s32(0x3F8CCCCDu)), (float32x2_t)vdup_n_s32(0x3F99999Au))))), vdupq_n_s64(8uLL));
    v4[1] = v7;
    v8 = v7.i64[0] * v7.i64[1];
    v9 = malloc_type_calloc(v7.i64[0] * v7.i64[1], 1uLL, 0x100004077774924uLL);
    v5[6] = (uint64_t)v9;
    if (!v9
      || (v10 = malloc_type_calloc(v8, 1uLL, 0x100004077774924uLL), (v5[7] = (uint64_t)v10) == 0)
      || (v11 = malloc_type_calloc(v8, 1uLL, 0x100004077774924uLL), (v5[8] = (uint64_t)v11) == 0))
    {
      tplTrackerResampler_free((void ***)&v13);
      return (void **)v13;
    }
  }
  return (void **)v5;
}

void tplTrackerResampler_free(void ***a1)
{
  void **v2;

  if (a1)
  {
    v2 = *a1;
    if (*a1)
    {
      free(v2[6]);
      free(v2[7]);
      free(v2[8]);
      free(v2);
    }
    *a1 = 0;
  }
}

uint64_t tplTrackerResampler_setImage(uint64_t a1, CVPixelBufferRef pixelBuffer, double *a3)
{
  uint64_t v6;
  char *BaseAddressOfPlane;
  size_t HeightOfPlane;
  size_t WidthOfPlane;
  size_t BytesPerRowOfPlane;
  void *v11;
  size_t v12;
  unint64_t v13;
  uint64_t v14;
  double v15;
  double v16;
  double v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  double v23;
  float v24;
  unsigned int v25;
  double v26;
  float v27;
  unsigned int v28;
  float v29;
  float v30;
  unsigned int v31;
  float v32;
  unsigned int v33;
  unint64_t v34;
  unint64_t v35;
  signed int v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  signed int v40;
  signed int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  char *v49;
  uint64_t i;
  int v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unsigned int v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;
  char v63;
  unint64_t v64;
  unint64_t v65;
  signed int v66;
  uint64_t v67;
  unint64_t v68;
  size_t v69;
  uint64_t v70;
  size_t v71;
  int v72;
  signed int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  uint64_t v81;
  uint64_t v82;
  float v83;
  float v84;
  uint64_t v85;
  int v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  char *v92;
  char v93;
  unint64_t v94;
  unint64_t v95;
  signed int v96;
  uint64_t v97;
  unint64_t v98;
  size_t v99;
  uint64_t v100;
  size_t v101;
  signed int v102;
  int v103;
  int v104;
  int v105;
  float v110;
  int v111;
  unint64_t v112;
  int v113;
  unsigned int v114;
  char v115;
  int v116;
  int v117;
  size_t v118;
  unsigned int v119;
  unint64_t v120;
  char v122;
  unsigned int v123;
  int v124;
  size_t v125;
  unint64_t v126;
  BOOL v127;
  int v128;
  unsigned int v129;
  size_t v130;
  BOOL v131;
  int v132;
  unsigned int v133;
  size_t v134;
  BOOL v135;
  int v136;
  int v137;
  int v138;
  int v139;
  int v140;
  float v141;
  float v142;
  float v143;
  int v144;
  uint64_t v145;
  int v146;
  uint64_t v147;
  int v148;
  unint64_t v149;
  int v150;
  unint64_t v151;
  unint64_t v152;
  signed int v153;
  uint64_t v154;
  unint64_t v155;
  size_t v156;
  uint64_t v157;
  size_t v158;
  signed int v159;
  int v160;
  int v161;
  int v162;
  float v164;
  float v165;
  int v166;
  unint64_t v167;
  int v168;
  uint64_t v169;
  _QWORD v170[4];
  _QWORD v171[4];

  if (!a1)
    goto LABEL_169;
  if (CVPixelBufferLockBaseAddress(pixelBuffer, 1uLL))
  {
    v6 = 6782;
    goto LABEL_170;
  }
  BaseAddressOfPlane = (char *)CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, 0);
  v171[0] = BaseAddressOfPlane;
  HeightOfPlane = CVPixelBufferGetHeightOfPlane(pixelBuffer, 0);
  v171[1] = HeightOfPlane;
  WidthOfPlane = CVPixelBufferGetWidthOfPlane(pixelBuffer, 0);
  v171[2] = WidthOfPlane;
  BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, 0);
  v171[3] = BytesPerRowOfPlane;
  v11 = CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, 1uLL);
  v170[0] = v11;
  v170[1] = CVPixelBufferGetHeightOfPlane(pixelBuffer, 1uLL);
  v170[2] = CVPixelBufferGetWidthOfPlane(pixelBuffer, 1uLL);
  v12 = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, 1uLL);
  v170[3] = v12;
  if (!*(_QWORD *)a1)
    goto LABEL_169;
  v13 = *(_QWORD *)(a1 + 8);
  if (!v13)
    goto LABEL_169;
  v14 = v12;
  v169 = (uint64_t)v11;
  v15 = a3[4];
  v16 = a3[5];
  v17 = a3[1];
  v18 = v15 - *a3 + 1.0;
  v19 = v16 - v17 + 1.0;
  v20 = *(float *)(a1 + 72) + -1.0;
  v21 = v18 / (float)*(unint64_t *)a1;
  v22 = v19 / (float)v13;
  v23 = (float)((float)(v20 * v18) * 0.5);
  v24 = *a3 - v23;
  v25 = vcvtms_s32_f32(v24);
  v26 = (float)((float)(v20 * v19) * 0.5);
  v27 = v17 - v26;
  v28 = vcvtms_s32_f32(v27);
  if (v21 >= v22)
    v29 = v21;
  else
    v29 = v22;
  v30 = v15 + v23;
  v31 = vcvtps_s32_f32(v30);
  v32 = v16 + v26;
  v33 = vcvtps_s32_f32(v32);
  if (v29 < 1.2)
  {
    v34 = (v28 & 0xFFFFFFFE) - 2;
    v35 = HeightOfPlane - 1;
    if (HeightOfPlane - 1 < v34)
      LODWORD(v34) = HeightOfPlane - 1;
    v36 = v25 & 0xFFFFFFFE;
    if ((int)(v28 & 0xFFFFFFFE) <= 2)
      v37 = 0;
    else
      v37 = v34;
    v38 = (v36 - 2);
    v39 = WidthOfPlane - 1;
    if (WidthOfPlane - 1 < v38)
      LODWORD(v38) = WidthOfPlane - 1;
    if (v36 <= 2)
      LODWORD(v38) = 0;
    v40 = v31 & 0xFFFFFFFE;
    if (v39 >= (v31 & 0xFFFFFFFE) + 4)
      LODWORD(v39) = v40 + 4;
    if (v40 <= -4)
      LODWORD(v39) = 0;
    v41 = v33 & 0xFFFFFFFE;
    if (v35 >= (v33 & 0xFFFFFFFE) + 4)
      LODWORD(v35) = v41 + 4;
    if (v41 <= -4)
      v42 = 0;
    else
      v42 = v35;
    v43 = v39 - v38;
    v44 = v39 - v38 + 1;
    if (*(_QWORD *)(a1 + 16) >= (unint64_t)v44)
    {
      v45 = v42 - v37;
      v46 = v45 + 1;
      if (*(_QWORD *)(a1 + 24) >= (unint64_t)(v45 + 1))
      {
        *(_QWORD *)(a1 + 32) = v44;
        *(_QWORD *)(a1 + 40) = v46;
        *(_QWORD *)(a1 + 76) = 0x400000003F800000;
        *(float *)(a1 + 84) = (float)(int)v38;
        *(float *)(a1 + 88) = (float)(int)v37;
        *(float *)(a1 + 92) = (float)(int)v38 + 0.5;
        *(float *)(a1 + 96) = (float)(int)v37 + 0.5;
        *(_BYTE *)(a1 + 100) = 1;
        if (v45 != -1)
        {
          v47 = 0;
          v48 = *(_QWORD *)(a1 + 48);
          v49 = &BaseAddressOfPlane[BytesPerRowOfPlane * v37 + v38];
          do
          {
            if (v44)
            {
              for (i = 0; i != v44; ++i)
                *(_BYTE *)(v48 + i) = v49[i];
            }
            v49 += BytesPerRowOfPlane;
            v48 += v44;
            ++v47;
          }
          while (v47 != v46);
          v51 = v44 + (v44 < 0);
          v52 = v46 >= 0 ? v45 + 1 : v45 + 2;
          if ((v45 + 2) >= 3)
          {
            v53 = 0;
            v54 = (uint64_t)v51 >> 1;
            v55 = (uint64_t)v52 >> 1;
            v57 = *(_QWORD *)(a1 + 56);
            v56 = *(_QWORD *)(a1 + 64);
            v58 = (v38 & 0xFFFFFFFE) + v14 * (v37 >> 1);
            v59 = v43 + 2;
            v60 = v58 + v169 + 1;
            v6 = 6784;
            do
            {
              if (v59 >= 3)
              {
                v61 = 0;
                v62 = (char *)v60;
                do
                {
                  *(_BYTE *)(v57 + v61) = *(v62 - 1);
                  v63 = *v62;
                  v62 += 2;
                  *(_BYTE *)(v56 + v61++) = v63;
                }
                while (v54 != v61);
              }
              v57 += v54;
              v56 += v54;
              ++v53;
              v60 += v14;
            }
            while (v53 != v55);
            goto LABEL_170;
          }
        }
LABEL_110:
        v6 = 6784;
        goto LABEL_170;
      }
    }
LABEL_169:
    v6 = 6780;
    goto LABEL_170;
  }
  if (v29 >= 2.4)
  {
    if (v29 < 4.8)
    {
      v94 = (v28 & 0xFFFFFFFC) - 4;
      v95 = HeightOfPlane - 1;
      if (HeightOfPlane - 1 < v94)
        LODWORD(v94) = HeightOfPlane - 1;
      v96 = v25 & 0xFFFFFFFC;
      if ((int)(v28 & 0xFFFFFFFC) <= 4)
        v97 = 0;
      else
        v97 = v94;
      v98 = (v96 - 4);
      v99 = WidthOfPlane - 1;
      if (WidthOfPlane - 1 < v98)
        LODWORD(v98) = WidthOfPlane - 1;
      if (v96 <= 4)
        v100 = 0;
      else
        v100 = v98;
      v101 = (v31 & 0xFFFFFFFC) + 8;
      if (v99 < v101)
        LODWORD(v101) = v99;
      if ((int)(v31 & 0xFFFFFFFC) <= -8)
        LODWORD(v101) = 0;
      v102 = v33 & 0xFFFFFFFC;
      if (v95 >= (v33 & 0xFFFFFFFC) + 8)
        LODWORD(v95) = v102 + 8;
      if (v102 <= -8)
        v103 = 0;
      else
        v103 = v95;
      v104 = v101 - v100 + 1;
      if (*(_QWORD *)(a1 + 16) >= (unint64_t)(v104 >> 2))
      {
        v105 = v103 - v97 + 1;
        if (*(_QWORD *)(a1 + 24) >= (unint64_t)(v105 >> 2))
        {
          *(_QWORD *)(a1 + 32) = (uint64_t)v104 >> 2;
          *(_QWORD *)(a1 + 40) = (uint64_t)v105 >> 2;
          __asm { FMOV            V0.2S, #4.0 }
          *(_QWORD *)(a1 + 76) = _D0;
          *(float *)&_D0 = (float)(int)v100 + 1.5;
          v110 = (float)(int)v97 + 1.5;
          *(_DWORD *)(a1 + 84) = _D0;
          *(float *)(a1 + 88) = v110;
          *(_DWORD *)(a1 + 92) = _D0;
          *(float *)(a1 + 96) = v110;
          *(_BYTE *)(a1 + 100) = 0;
          tplTrackerResampler_lumaDownscale4((uint64_t)BaseAddressOfPlane, BytesPerRowOfPlane, v100, v97, v104, v105, *(_QWORD *)(a1 + 48));
          if (v104 >= 0)
            v111 = v104;
          else
            v111 = v104 + 1;
          v112 = (uint64_t)v111 >> 1;
          if (v105 >= 0)
            v113 = v105;
          else
            v113 = v105 + 1;
          tplTrackerResampler_chromaDownscale2(v169, v14, v100 >> 1, v97 >> 1, v112, (uint64_t)v113 >> 1, *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64));
          goto LABEL_110;
        }
      }
      goto LABEL_169;
    }
    if (v29 <= 9.6)
    {
      v151 = (v28 & 0xFFFFFFF8) - 8;
      v152 = HeightOfPlane - 1;
      if (HeightOfPlane - 1 < v151)
        LODWORD(v151) = HeightOfPlane - 1;
      v153 = v25 & 0xFFFFFFF8;
      if ((int)(v28 & 0xFFFFFFF8) <= 8)
        v154 = 0;
      else
        v154 = v151;
      v155 = (v153 - 8);
      v156 = WidthOfPlane - 1;
      if (WidthOfPlane - 1 < v155)
        LODWORD(v155) = WidthOfPlane - 1;
      if (v153 <= 8)
        v157 = 0;
      else
        v157 = v155;
      v158 = (v31 & 0xFFFFFFF8) + 16;
      if (v156 < v158)
        LODWORD(v158) = v156;
      if ((int)(v31 & 0xFFFFFFF8) <= -16)
        LODWORD(v158) = 0;
      v159 = v33 & 0xFFFFFFF8;
      if (v152 >= (v33 & 0xFFFFFFF8) + 16)
        LODWORD(v152) = v159 + 16;
      if (v159 <= -16)
        v160 = 0;
      else
        v160 = v152;
      v161 = v158 - v157 + 1;
      if (*(_QWORD *)(a1 + 16) < (unint64_t)(v161 >> 3))
        goto LABEL_169;
      v162 = v160 - v154 + 1;
      if (*(_QWORD *)(a1 + 24) < (unint64_t)(v162 >> 3))
        goto LABEL_169;
      *(_QWORD *)(a1 + 32) = (uint64_t)v161 >> 3;
      *(_QWORD *)(a1 + 40) = (uint64_t)v162 >> 3;
      *(_QWORD *)(a1 + 76) = 0x4100000041000000;
      v164 = (float)(int)v157 + 3.5;
      v165 = (float)(int)v154 + 3.5;
      *(float *)(a1 + 84) = v164;
      *(float *)(a1 + 88) = v165;
      *(float *)(a1 + 92) = v164;
      *(float *)(a1 + 96) = v165;
      *(_BYTE *)(a1 + 100) = 0;
      v6 = tplTrackerResampler_lumaDownscale8N(v171, v157, v154, v161, v162, 1, *(_QWORD *)(a1 + 48));
      if (v6 == 128)
      {
        if (v161 >= 0)
          v166 = v161;
        else
          v166 = v161 + 1;
        v167 = (uint64_t)v166 >> 1;
        if (v162 >= 0)
          v168 = v162;
        else
          v168 = v162 + 1;
        tplTrackerResampler_chromaDownscale4(v169, v14, v157 >> 1, v154 >> 1, v167, (uint64_t)v168 >> 1, *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64));
      }
    }
    else
    {
      v114 = v33;
      v115 = vcvtps_s32_f32(log2f(v29 / 1.2));
      v116 = 1 << v115;
      v117 = -(1 << v115);
      v118 = HeightOfPlane - 1;
      v119 = (2 << v115) + v114;
      v120 = v119 & v117;
      _VF = __OFSUB__(HeightOfPlane - 1, v120);
      if (HeightOfPlane - 1 < v120)
        LODWORD(v120) = HeightOfPlane - 1;
      v122 = ((v119 & v117 & 0x80000000) != 0) ^ _VF | ((v119 & v117) == 0);
      v123 = (2 << v115) + v31;
      if (v122)
        v124 = 0;
      else
        v124 = v120;
      v125 = WidthOfPlane - 1;
      v126 = v123 & v117;
      v127 = __OFSUB__(WidthOfPlane - 1, v126);
      if (WidthOfPlane - 1 < v126)
        LODWORD(v126) = WidthOfPlane - 1;
      if (((v123 & v117 & 0x80000000) != 0) ^ v127 | ((v123 & v117) == 0))
        v128 = 0;
      else
        v128 = v126;
      v129 = v28 - v116;
      v130 = (v28 - v116) & v117;
      v131 = __OFSUB__(v118, v130);
      if (v118 >= v130)
        LODWORD(v118) = v129 & v117;
      if (((v129 & v117 & 0x80000000) != 0) ^ v131 | ((v129 & v117) == 0))
        v132 = 0;
      else
        v132 = v118;
      v133 = v25 - v116;
      v134 = (v25 - v116) & v117;
      v135 = __OFSUB__(v125, v134);
      if (v125 >= v134)
        LODWORD(v125) = v133 & v117;
      if (((v133 & v117 & 0x80000000) != 0) ^ v135 | ((v133 & v117) == 0))
        v136 = 0;
      else
        v136 = v125;
      v137 = v128 - v136 + 1;
      v138 = v137 >> v115;
      if (*(_QWORD *)(a1 + 16) < (unint64_t)(v137 >> v115))
        goto LABEL_169;
      v139 = v124 - v132 + 1;
      v140 = v139 >> v115;
      if (*(_QWORD *)(a1 + 24) < (unint64_t)v140)
        goto LABEL_169;
      *(_QWORD *)(a1 + 32) = v138;
      *(_QWORD *)(a1 + 40) = v140;
      *(float *)(a1 + 76) = (float)v116;
      *(float *)(a1 + 80) = (float)v116;
      v141 = (float)v116 + -1.0;
      v142 = (float)v136 + (float)(v141 * 0.5);
      v143 = (float)v132 + (float)(v141 * 0.5);
      *(float *)(a1 + 84) = v142;
      *(float *)(a1 + 88) = v143;
      *(float *)(a1 + 92) = v142;
      *(float *)(a1 + 96) = v143;
      *(_BYTE *)(a1 + 100) = 0;
      v6 = tplTrackerResampler_lumaDownscale8N(v171, v136, v132, v137, v139, (uint64_t)v116 >> 3, *(_QWORD *)(a1 + 48));
      if (v6 == 128)
      {
        if (v136 >= 0)
          v144 = v136;
        else
          v144 = v136 + 1;
        v145 = (uint64_t)v144 >> 1;
        if (v132 >= 0)
          v146 = v132;
        else
          v146 = v132 + 1;
        v147 = (uint64_t)v146 >> 1;
        if (v137 >= 0)
          v148 = v137;
        else
          v148 = v137 + 1;
        v149 = (uint64_t)v148 >> 1;
        if (v139 >= 0)
          v150 = v139;
        else
          v150 = v139 + 1;
        v6 = tplTrackerResampler_chromaDownscale8N(v170, v145, v147, v149, (uint64_t)v150 >> 1, (uint64_t)v116 >> 4, *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64));
      }
    }
  }
  else
  {
    v64 = (v28 & 0xFFFFFFFE) - 2;
    v65 = HeightOfPlane - 1;
    if (HeightOfPlane - 1 < v64)
      LODWORD(v64) = HeightOfPlane - 1;
    v66 = v25 & 0xFFFFFFFE;
    if ((int)(v28 & 0xFFFFFFFE) <= 2)
      v67 = 0;
    else
      v67 = v64;
    v68 = (v66 - 2);
    v69 = WidthOfPlane - 1;
    if (WidthOfPlane - 1 < v68)
      LODWORD(v68) = WidthOfPlane - 1;
    if (v66 <= 2)
      v70 = 0;
    else
      v70 = v68;
    v71 = (v31 & 0xFFFFFFFE) + 4;
    if (v69 < v71)
      LODWORD(v71) = v69;
    if ((int)(v31 & 0xFFFFFFFE) <= -4)
      v72 = 0;
    else
      v72 = v71;
    v73 = v33 & 0xFFFFFFFE;
    if (v65 >= (v33 & 0xFFFFFFFE) + 4)
      LODWORD(v65) = v73 + 4;
    if (v73 <= -4)
      v74 = 0;
    else
      v74 = v65;
    v75 = v72 - v70;
    v76 = v72 - v70 + 1;
    v77 = v75 + 2;
    if (v75 >= -1)
      v77 = v75 + 1;
    if (*(_QWORD *)(a1 + 16) < (unint64_t)(v77 >> 1))
      goto LABEL_169;
    v78 = v74 - v67;
    v79 = v74 - v67 + 1;
    v80 = v78 >= -1 ? v79 : v79 + 1;
    if (*(_QWORD *)(a1 + 24) < (unint64_t)(v80 >> 1))
      goto LABEL_169;
    v81 = (uint64_t)v77 >> 1;
    v82 = (uint64_t)v80 >> 1;
    *(_QWORD *)(a1 + 32) = v81;
    *(_QWORD *)(a1 + 40) = v82;
    *(_QWORD *)(a1 + 76) = 0x4000000040000000;
    v83 = (float)(int)v70 + 0.5;
    v84 = (float)(int)v67 + 0.5;
    *(float *)(a1 + 84) = v83;
    *(float *)(a1 + 88) = v84;
    *(float *)(a1 + 92) = v83;
    *(float *)(a1 + 96) = v84;
    *(_BYTE *)(a1 + 100) = 0;
    v85 = BytesPerRowOfPlane;
    v86 = v78;
    tplTrackerResampler_lumaDownscale2((uint64_t)BaseAddressOfPlane, v85, v70, v67, v76, v79, *(_QWORD *)(a1 + 48));
    if ((v86 + 2) < 3)
      goto LABEL_110;
    v87 = 0;
    v89 = *(_QWORD *)(a1 + 56);
    v88 = *(_QWORD *)(a1 + 64);
    v90 = (v70 & 0xFFFFFFFE) + v14 * (v67 >> 1) + v169 + 1;
    v6 = 6784;
    do
    {
      if ((v75 + 2) >= 3)
      {
        v91 = 0;
        v92 = (char *)v90;
        do
        {
          *(_BYTE *)(v89 + v91) = *(v92 - 1);
          v93 = *v92;
          v92 += 2;
          *(_BYTE *)(v88 + v91++) = v93;
        }
        while (v81 != v91);
      }
      v89 += v81;
      v88 += v81;
      ++v87;
      v90 += v14;
    }
    while (v87 != v82);
  }
LABEL_170:
  CVPixelBufferUnlockBaseAddress(pixelBuffer, 1uLL);
  return v6;
}

void tplTrackerResampler_resample(uint64_t a1, double *a2, unsigned int a3, int a4, uint64_t a5, _BYTE *a6, _BYTE *a7, int *a8, float a9, float a10)
{
  int v10;
  uint64_t v12;
  int v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  char v19;
  unint64_t v20;
  unint64_t v21;
  float v22;
  uint64_t v23;
  int v24;
  float v25;
  signed int v26;
  int v27;
  _BYTE *v29;
  _BYTE *v30;
  uint64_t v31;
  int v32;
  int v33;
  uint64_t v34;
  unsigned int v35;
  unsigned int v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  float v40;
  unsigned int v41;
  uint64_t v42;
  float v43;
  unsigned int v44;
  unsigned int v45;
  unsigned int v46;
  unsigned int v47;
  unsigned int v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  unsigned int v52;
  unsigned int v53;
  unsigned int v54;
  uint64_t v55;
  float v56;
  uint64_t v57;
  signed int v58;
  uint64_t v59;
  unsigned int v60;
  uint64_t v61;
  float v62;
  char v63;
  unsigned int v64;
  uint64_t v65;
  unsigned int v66;
  unsigned int v67;
  unsigned int v68;
  unsigned int v69;
  int v70;
  int *v71;
  unint64_t v72;
  uint64_t v75;
  int v76;
  int v77;

  v10 = a4;
  if ((int)a3 < 1)
  {
    v13 = 0;
    v70 = 0;
    goto LABEL_56;
  }
  v12 = 0;
  v13 = 0;
  v76 = 0;
  v14 = *(float *)(a1 + 76);
  v15 = *(float *)(a1 + 80);
  v16 = a10 / v14;
  v17 = a9 / v14;
  v18 = a10 / v15;
  v19 = *(_BYTE *)(a1 + 100);
  v71 = a8;
  v72 = *(_QWORD *)(a1 + 32);
  v20 = v72 >> v19;
  v21 = *(_QWORD *)(a1 + 40) >> v19;
  v22 = (a2[1] - *(float *)(a1 + 96)) / v15;
  v77 = a3;
  v23 = a3;
  v24 = a4;
  v25 = a9 / v15;
  v75 = a3;
  do
  {
    v26 = vcvtms_s32_f32(v22);
    v27 = v26 + 1;
    if (v22 >= 0.0 && v21 > v27)
    {
      if ((int)v12 >= v77)
        v32 = v77;
      else
        v32 = v12;
      v77 = v32;
      if ((int)v12 <= v76)
        v33 = v76;
      else
        v33 = v12;
      v76 = v33;
      if (v10 >= 1)
      {
        v34 = 0;
        v35 = (float)((float)((float)((float)v27 - v22) * 255.0) + 0.5);
        v36 = 255 - v35;
        v37 = v20 * v26;
        v38 = *(_QWORD *)(a1 + 56) + v37;
        v39 = *(_QWORD *)(a1 + 64) + v37;
        v40 = (*a2 - *(float *)(a1 + 92)) / *(float *)(a1 + 80);
        do
        {
          v41 = vcvtms_s32_f32(v40);
          if ((v41 & 0x80000000) != 0 || (v42 = v41 + 1, v20 <= v42))
          {
            a6[v34] = 0x80;
            a7[v34] = 0x80;
          }
          else
          {
            v43 = (float)((float)((float)(int)v42 - v40) * 255.0) + 0.5;
            v44 = 255 - v43;
            v45 = (v44 * *(unsigned __int8 *)(v38 + v42) + *(unsigned __int8 *)(v38 + v41) * v43 + 191) >> 8;
            v46 = (v44 * *(unsigned __int8 *)(v38 + v20 + v42)
                 + *(unsigned __int8 *)(v38 + v20 + v41) * v43
                 + 191) >> 8;
            v47 = (v44 * *(unsigned __int8 *)(v39 + v42) + *(unsigned __int8 *)(v39 + v41) * v43 + 191) >> 8;
            v48 = (v44 * *(unsigned __int8 *)(v39 + v20 + v42)
                 + *(unsigned __int8 *)(v39 + v20 + v41) * v43
                 + 191) >> 8;
            v49 = v46 * v36 + v45 * v35 + 191;
            v50 = HIWORD(v49);
            v51 = v49 >> 8;
            if (v50)
              LOBYTE(v51) = -1;
            a6[v34] = v51;
            v52 = v48 * v36 + v47 * v35 + 191;
            v53 = HIWORD(v52);
            v54 = v52 >> 8;
            if (v53)
              LOBYTE(v54) = -1;
            a7[v34] = v54;
            if ((int)v34 < v24)
              v24 = v34;
            if ((int)v34 > v13)
              v13 = v34;
          }
          v40 = v18 + v40;
          ++v34;
        }
        while (v10 != v34);
        v23 = a3;
      }
    }
    else if (v10 >= 1)
    {
      v29 = a6;
      v30 = a7;
      v31 = v10;
      do
      {
        *v29++ = 0x80;
        *v30++ = 0x80;
        --v31;
      }
      while (v31);
    }
    v22 = v25 + v22;
    ++v12;
    a7 += v10;
    a6 += v10;
  }
  while (v12 != v23);
  v55 = 0;
  v56 = (a2[1] - *(float *)(a1 + 88)) / *(float *)(a1 + 76);
  v57 = a5;
  do
  {
    if (v55 < v77
      || v55 > v76
      || v56 < 0.0
      || (v58 = vcvtms_s32_f32(v56), *(_QWORD *)(a1 + 40) <= (unint64_t)(v58 + 1)))
    {
      if (v10 >= 1)
      {
        bzero((void *)(a5 + (int)v55 * v10), v10);
        v23 = v75;
      }
    }
    else if (v10 >= 1)
    {
      v59 = 0;
      v60 = (float)((float)((float)((float)(v58 + 1) - v56) * 255.0) + 0.5);
      v61 = *(_QWORD *)(a1 + 48) + v72 * v58;
      v62 = (*a2 - *(float *)(a1 + 84)) / *(float *)(a1 + 76);
      do
      {
        if (v59 < v24)
          goto LABEL_48;
        v63 = 0;
        if (v59 > v13)
          goto LABEL_49;
        v64 = vcvtms_s32_f32(v62);
        if ((v64 & 0x80000000) != 0)
          goto LABEL_49;
        v65 = v64 + 1;
        if (*(_QWORD *)(a1 + 32) <= (unint64_t)v65)
        {
LABEL_48:
          v63 = 0;
        }
        else
        {
          v66 = (float)((float)((float)((float)(int)v65 - v62) * 255.0) + 0.5);
          v67 = (((255 - v66) * *(unsigned __int8 *)(v61 + v72 + v65) + *(unsigned __int8 *)(v61 + v72 + v64) * v66 + 191) >> 8)
              * (255 - v60)
              + (((255 - v66) * *(unsigned __int8 *)(v61 + v65) + *(unsigned __int8 *)(v61 + v64) * v66 + 191) >> 8)
              * v60
              + 191;
          v68 = HIWORD(v67);
          v69 = v67 >> 8;
          if (v68)
            v63 = -1;
          else
            v63 = v69;
        }
LABEL_49:
        *(_BYTE *)(v57 + v59) = v63;
        v62 = v16 + v62;
        ++v59;
      }
      while (v10 != v59);
    }
    v56 = v17 + v56;
    ++v55;
    v57 += v10;
  }
  while (v55 != v23);
  v10 = v24;
  a8 = v71;
  v70 = v76;
  a3 = v77;
LABEL_56:
  *a8 = v10;
  a8[1] = a3;
  a8[2] = v13;
  a8[3] = v70;
}

void sub_1A158B7F8(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;

  objc_begin_catch(a1);
  JUMPOUT(0x1A158B7A4);
}

void sub_1A158BB8C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A158BC1C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

double VNAffineTransformForVisionToTopLeftOriginOrientation@<D0>(int a1@<W0>, int a2@<W1>, uint64_t a3@<X8>)
{
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  char v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  CGAffineTransform v17;
  CGAffineTransform v18;
  CGAffineTransform v19;
  CGAffineTransform v20;
  CGAffineTransform v21;
  CGAffineTransform v22;
  CGAffineTransform v23;
  CGAffineTransform t2;
  CGAffineTransform t1;

  if (a1)
  {
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    *(_QWORD *)a3 = 0x3FF0000000000000;
    *(_QWORD *)&v5 = 0xBFF0000000000000;
    *(_OWORD *)(a3 + 24) = xmmword_1A15FB480;
    *(_QWORD *)(a3 + 40) = 0x3FF0000000000000;
  }
  else
  {
    v6 = MEMORY[0x1E0C9BAA8];
    v7 = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 16);
    *(_OWORD *)a3 = *MEMORY[0x1E0C9BAA8];
    *(_OWORD *)(a3 + 16) = v7;
    v5 = *(_OWORD *)(v6 + 32);
    *(_OWORD *)(a3 + 32) = v5;
  }
  if ((a2 - 2) <= 6)
  {
    v8 = *(_OWORD *)(a3 + 16);
    *(_OWORD *)&t1.a = *(_OWORD *)a3;
    *(_OWORD *)&t1.c = v8;
    *(_OWORD *)&t1.tx = *(_OWORD *)(a3 + 32);
    CGAffineTransformMakeTranslation(&t2, -0.5, -0.5);
    CGAffineTransformConcat((CGAffineTransform *)a3, &t1, &t2);
    v9 = kVisionToOrientationRotationMirrorState[2 * a2];
    if (v9)
    {
      v10 = *(_OWORD *)(a3 + 16);
      *(_OWORD *)&v22.a = *(_OWORD *)a3;
      *(_OWORD *)&v22.c = v10;
      *(_OWORD *)&v22.tx = *(_OWORD *)(a3 + 32);
      CGAffineTransformMakeRotation(&v21, (double)v9 * 90.0 * 0.0174532925);
      CGAffineTransformConcat(&v23, &v22, &v21);
      v11 = *(_OWORD *)&v23.c;
      *(_OWORD *)a3 = *(_OWORD *)&v23.a;
      *(_OWORD *)(a3 + 16) = v11;
      *(_OWORD *)(a3 + 32) = *(_OWORD *)&v23.tx;
    }
    if (((0x14BuLL >> a2) & 1) == 0)
    {
      v12 = *(_OWORD *)(a3 + 16);
      *(_OWORD *)&v20.a = *(_OWORD *)a3;
      *(_OWORD *)&v20.c = v12;
      *(_OWORD *)&v20.tx = *(_OWORD *)(a3 + 32);
      CGAffineTransformMakeScale(&v19, -1.0, 1.0);
      CGAffineTransformConcat(&v23, &v20, &v19);
      v13 = *(_OWORD *)&v23.c;
      *(_OWORD *)a3 = *(_OWORD *)&v23.a;
      *(_OWORD *)(a3 + 16) = v13;
      *(_OWORD *)(a3 + 32) = *(_OWORD *)&v23.tx;
    }
    v14 = *(_OWORD *)(a3 + 16);
    *(_OWORD *)&v18.a = *(_OWORD *)a3;
    *(_OWORD *)&v18.c = v14;
    *(_OWORD *)&v18.tx = *(_OWORD *)(a3 + 32);
    CGAffineTransformMakeTranslation(&v17, 0.5, 0.5);
    CGAffineTransformConcat(&v23, &v18, &v17);
    v15 = *(_OWORD *)&v23.c;
    *(_OWORD *)a3 = *(_OWORD *)&v23.a;
    *(_OWORD *)(a3 + 16) = v15;
    *(CGFloat *)&v5 = v23.tx;
    *(_OWORD *)(a3 + 32) = *(_OWORD *)&v23.tx;
  }
  return *(double *)&v5;
}

void sub_1A158BF40(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A158C164(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A158C478(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  objc_sync_exit(v2);
  _Unwind_Resume(a1);
}

void sub_1A158C82C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  objc_sync_exit(v2);
  _Unwind_Resume(a1);
}

void sub_1A158CAD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

void sub_1A158CB4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A158CCC4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A158CE9C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A158CFC0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A158D178(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A158D46C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;

  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a11);

  _Unwind_Resume(a1);
}

void sub_1A158D6AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  void *v13;
  void *v14;
  void *v15;
  std::__shared_weak_count *v16;
  void *v18;

  std::__shared_weak_count::~__shared_weak_count(v16);
  operator delete(v18);

  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void sub_1A158D84C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A158DA8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  void *v15;
  void *v16;
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

void sub_1A158E0A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

void sub_1A158E258(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A158E570(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void **a15, _QWORD *a16, uint64_t a17, char a18)
{
  void *v18;
  void *v19;
  void *v20;

  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(a16);
  a15 = (void **)&a18;
  std::vector<std::map<int,double>>::__destroy_vector::operator()[abi:ne180100](&a15);

  _Unwind_Resume(a1);
}

void sub_1A158E824(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,id a38)
{
  void *v38;
  void *v39;
  uint64_t v40;

  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a33, 8);

  _Block_object_dispose((const void *)(v40 - 144), 8);
  _Unwind_Resume(a1);
}

void sub_1A158E9C8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A158EB7C(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void sub_1A158EEE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, vision::mod::FaceID3Model *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,id a43)
{
  void *v43;
  void *v44;
  void *v45;
  void *v46;
  void *v47;
  void *v48;

  std::unique_ptr<vision::mod::FaceID3Model>::reset[abi:ne180100](&a12);
  std::istream::~istream();

  std::streambuf::~streambuf();
  _Unwind_Resume(a1);
}

void sub_1A158F120(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  uint64_t v3;

  std::ostream::~ostream();
  std::streambuf::~streambuf();

  _Unwind_Resume(a1);
}

void ___ZL54_serialNumberToPersonUniqueIdentifierDictionaryClassesv_block_invoke_30934()
{
  void *v0;
  void *v1;
  void *v2;
  uint64_t v3;
  void *v4;

  v0 = (void *)MEMORY[0x1A1B0B060]();
  VNEntityUniqueIdentifierClasses();
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v2 = (void *)objc_msgSend(v1, "mutableCopy");

  objc_msgSend(v2, "addObject:", objc_opt_class());
  v3 = objc_msgSend(v2, "copy");
  v4 = (void *)_serialNumberToPersonUniqueIdentifierDictionaryClasses(void)::classes;
  _serialNumberToPersonUniqueIdentifierDictionaryClasses(void)::classes = v3;

  objc_autoreleasePoolPop(v0);
}

void sub_1A158F264(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__16_30940(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__17_30941(uint64_t a1)
{

}

uint64_t __Block_byref_object_copy__30942(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 48) = &off_1E453A1B8;
  *(_QWORD *)(result + 56) = *(_QWORD *)(a2 + 56);
  return result;
}

void sub_1A158F39C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A158F698(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id a13)
{
  void *v13;
  void *v14;

  operator delete(v13);

  _Unwind_Resume(a1);
}

void sub_1A158FF8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, uint64_t a15, void *a16, uint64_t a17, void *a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *__p,uint64_t a37,uint64_t a38,char a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,void *a44,uint64_t a45)
{
  uint64_t v45;

  if (__p)
  {
    a37 = (uint64_t)__p;
    operator delete(__p);
  }
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a34);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a32);
  _Block_object_dispose((const void *)(v45 - 232), 8);

  _Block_object_dispose((const void *)(v45 - 176), 8);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)&a39);

  if (a44)
  {
    a45 = (uint64_t)a44;
    operator delete(a44);
  }
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](v45 - 256);

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__82(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[3] = result;
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  return result;
}

uint64_t __Block_byref_object_dispose__83(uint64_t a1)
{
  return std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100](a1 + 48);
}

uint64_t ___ZL15_newFaceIDModelP27VNPersonsModelConfigurationPU15__autoreleasingP7NSError_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *v3;
  unint64_t v4;
  __int128 v6;

  std::allocate_shared[abi:ne180100]<vision::mod::FaceID3Model,std::allocator<vision::mod::FaceID3Model>,int const&,int const&,int const&,vision::mod::FaceIDIndexMode const&,void>(&v6, *(_DWORD *)(a1 + 40), *(_DWORD *)(a1 + 44), *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52));
  std::shared_ptr<vision::mod::ImageAnalyzer>::operator=[abi:ne180100](*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48, &v6);
  v2 = (std::__shared_weak_count *)*((_QWORD *)&v6 + 1);
  if (*((_QWORD *)&v6 + 1))
  {
    v3 = (unint64_t *)(*((_QWORD *)&v6 + 1) + 8);
    do
      v4 = __ldaxr(v3);
    while (__stlxr(v4 - 1, v3));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return 1;
}

void sub_1A1590304(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15903B0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1590478(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A15905F4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1590694(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1590734(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A159093C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1A15909E0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1590A24(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1590A70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A1590B88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A1590D2C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  v3 = v2;

  _Unwind_Resume(a1);
}

void vision::mod::PetprintGenerator::~PetprintGenerator(vision::mod::PetprintGenerator *this)
{
  vision::mod::PetprintGenerator::~PetprintGenerator(this);
  JUMPOUT(0x1A1B0A898);
}

{
  void *v2;

  *(_QWORD *)this = &off_1E453A388;
  if (*((_BYTE *)this + 60))
  {
    espresso_plan_destroy();
    *((_QWORD *)this + 9) = 0;
    espresso_context_destroy();
    *((_QWORD *)this + 8) = 0;
  }
  std::unique_ptr<vision::mod::ImageProcessing_Preprocessor>::reset[abi:ne180100]((uint64_t *)this + 57, 0);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)this + 440);
  v2 = (void *)*((_QWORD *)this + 2);
  if (v2)
  {
    *((_QWORD *)this + 3) = v2;
    operator delete(v2);
  }
}

char *std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>(char *result, char *__src, uint64_t a3)
{
  _QWORD *v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  void **v10;
  char *v11;
  _BYTE *v12;
  size_t v13;
  char *v14;
  size_t v15;
  void *v16;
  char *v17;

  v5 = result;
  v6 = *((_QWORD *)result + 2);
  v7 = *(char **)result;
  if ((unint64_t)(v6 - *(_QWORD *)result) < 0xC)
  {
    if (v7)
    {
      *((_QWORD *)result + 1) = v7;
      operator delete(v7);
      v6 = 0;
      *v5 = 0;
      v5[1] = 0;
      v5[2] = 0;
    }
    v8 = v6 >> 1;
    if ((unint64_t)(v6 >> 1) <= 3)
      v8 = 3;
    if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFFCLL)
      v9 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v9 = v8;
    result = std::vector<float>::__vallocate[abi:ne180100](v5, v9);
    v11 = (char *)v5[1];
    v10 = (void **)(v5 + 1);
    v7 = v11;
LABEL_15:
    v15 = a3 - (_QWORD)__src;
    if (v15)
    {
      v16 = v7;
      v17 = __src;
      goto LABEL_17;
    }
    goto LABEL_18;
  }
  v10 = (void **)(result + 8);
  v12 = (_BYTE *)*((_QWORD *)result + 1);
  v13 = v12 - v7;
  if ((unint64_t)(v12 - v7) > 0xB)
    goto LABEL_15;
  v14 = &__src[v13];
  if (v12 != v7)
  {
    result = (char *)memmove(*(void **)result, __src, v13);
    v7 = (char *)*v10;
  }
  v15 = a3 - (_QWORD)v14;
  if (v15)
  {
    v16 = v7;
    v17 = v14;
LABEL_17:
    result = (char *)memmove(v16, v17, v15);
  }
LABEL_18:
  *v10 = &v7[v15];
  return result;
}

void vision::mod::PetprintGeneratorConcrete::~PetprintGeneratorConcrete(vision::mod::PetprintGeneratorConcrete *this)
{
  vision::mod::PetprintGenerator::~PetprintGenerator(this);
  JUMPOUT(0x1A1B0A898);
}

void std::__shared_ptr_emplace<vision::mod::PetprintGeneratorConcrete>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453B808;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<vision::mod::PetprintGeneratorConcrete>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453B808;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A1B0A898);
}

uint64_t std::__shared_ptr_emplace<vision::mod::PetprintGeneratorConcrete>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void vision::mod::PetprintGenerator::getPetPrint(uint64_t a1, float **a2)
{
  float *v4;
  float *v5;
  uint64_t v6;
  float v7;
  float v8;
  unint64_t v9;
  float *v10;
  float *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  float *v17;
  int v18;
  uint64_t v19;
  int v20;
  float *v21;
  float v22;
  uint64_t v23;
  float v24;
  float *v25;
  float v26;

  v4 = *a2;
  v5 = a2[1];
  if (v5 != *a2)
  {
    a2[1] = v4;
    v5 = v4;
  }
  if (*(int *)(a1 + 44) >= 1)
  {
    v6 = 0;
    v7 = 0.0;
    do
    {
      v8 = *(float *)(*(_QWORD *)(a1 + 96) + 4 * v6);
      v9 = (unint64_t)a2[2];
      if ((unint64_t)v5 >= v9)
      {
        v11 = *a2;
        v12 = v5 - *a2;
        v13 = v12 + 1;
        if ((unint64_t)(v12 + 1) >> 62)
          std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
        v14 = v9 - (_QWORD)v11;
        if (v14 >> 1 > v13)
          v13 = v14 >> 1;
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFFCLL)
          v15 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v15 = v13;
        if (v15)
        {
          v15 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v15);
          v11 = *a2;
          v5 = a2[1];
        }
        else
        {
          v16 = 0;
        }
        v17 = (float *)(v15 + 4 * v12);
        *v17 = v8;
        v10 = v17 + 1;
        while (v5 != v11)
        {
          v18 = *((_DWORD *)v5-- - 1);
          *((_DWORD *)v17-- - 1) = v18;
        }
        *a2 = v17;
        a2[1] = v10;
        a2[2] = (float *)(v15 + 4 * v16);
        if (v11)
          operator delete(v11);
      }
      else
      {
        *v5 = v8;
        v10 = v5 + 1;
      }
      a2[1] = v10;
      v7 = v7 + v8;
      ++v6;
      v5 = v10;
    }
    while (v6 < *(int *)(a1 + 44));
    if (*(_BYTE *)(a1 + 8))
    {
      v19 = *(unsigned int *)(a1 + 44);
      if ((int)v19 >= 1)
      {
        v20 = *(unsigned __int8 *)(a1 + 9);
        v21 = *a2;
        v22 = 0.0;
        v23 = *(unsigned int *)(a1 + 44);
        do
        {
          v24 = *v21;
          if (v20)
          {
            v24 = v24 - (float)(v7 / (float)(int)v19);
            *v21 = v24;
          }
          v22 = v22 + (float)(v24 * v24);
          ++v21;
          --v23;
        }
        while (v23);
        v25 = *a2;
        v26 = sqrtf(v22);
        do
        {
          *v25 = *v25 / v26;
          ++v25;
          --v19;
        }
        while (v19);
      }
    }
  }
}

void sub_1A15913C8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15914DC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15915E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

void sub_1A159168C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  void *v9;
  void *v10;
  void *v11;

  v11 = v10;

  a9.super_class = (Class)VNFaceBBoxAligner;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_1A159185C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1A1591BBC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A15925C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *__p)
{
  void *v39;
  void *v40;
  void *v41;

  if (v40)
    operator delete(v40);
  if (__p)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_1A1592A88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4;
  va_list va;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  std::__hash_table<std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,vision::mod::ModelValues::ValueInfo>>>::~__hash_table((uint64_t)va);
  std::__hash_table<std::__hash_value_type<unsigned long long,cvml::util::binserialized_table_of_contents::blob_info>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,cvml::util::binserialized_table_of_contents::blob_info>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,cvml::util::binserialized_table_of_contents::blob_info>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,cvml::util::binserialized_table_of_contents::blob_info>>>::~__hash_table((uint64_t)va1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<vision::mod::FaceBoxPoseAligner<signed char>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453B5A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<vision::mod::FaceBoxPoseAligner<signed char>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E453B5A0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A1B0A898);
}

void std::__shared_ptr_emplace<vision::mod::FaceBoxPoseAligner<signed char>>::__on_zero_shared(uint64_t a1)
{
  void *v2;
  void *v3;
  void **v4;

  std::__tree<std::__value_type<long long,std::vector<long long>>,std::__map_value_compare<long long,std::__value_type<long long,std::vector<long long>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,std::vector<long long>>>>::destroy(*(_QWORD **)(a1 + 144));
  v4 = (void **)(a1 + 112);
  std::vector<std::vector<CGPoint>>::__destroy_vector::operator()[abi:ne180100](&v4);
  v2 = *(void **)(a1 + 88);
  if (v2)
  {
    *(_QWORD *)(a1 + 96) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 64);
  if (v3)
  {
    *(_QWORD *)(a1 + 72) = v3;
    operator delete(v3);
  }
}

void sub_1A1592DA4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1592E40(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1593398(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;

  *(_QWORD *)(v25 - 88) = v23;
  std::vector<vision::mod::DetectedObject>::__destroy_vector::operator()[abi:ne180100]((void ***)(v25 - 88));
  *(_QWORD *)(v25 - 88) = &a19;
  std::vector<vision::mod::DetectedObject>::__destroy_vector::operator()[abi:ne180100]((void ***)(v25 - 88));

  _Unwind_Resume(a1);
}

void sub_1A15937B8(_Unwind_Exception *a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  void *v12;
  void *v13;
  void *v14;
  uint64_t v15;
  va_list va;

  va_start(va, a12);

  _Block_object_dispose(va, 8);
  *(_QWORD *)(v15 - 144) = a4;
  std::vector<vision::mod::DetectedObject>::__destroy_vector::operator()[abi:ne180100]((void ***)(v15 - 144));

  _Unwind_Resume(a1);
}

void sub_1A1593964(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1593A60(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A1593DDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, void *a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{

  _Unwind_Resume(a1);
}

void sub_1A15940FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void **a13)
{
  void *v13;
  void *v14;
  void *v15;
  void *v16;

  a13 = (void **)&a10;
  std::vector<vision::mod::DetectedObject>::__destroy_vector::operator()[abi:ne180100](&a13);

  _Unwind_Resume(a1);
}

_QWORD *std::vector<vision::mod::DetectedObject>::vector(_QWORD *a1, unint64_t a2)
{
  int32x2_t *v4;
  int32x2_t *v5;
  uint64_t v6;
  int32x2_t v7;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<vision::mod::DetectedObject>::__vallocate[abi:ne180100](a1, a2);
    v4 = (int32x2_t *)a1[1];
    v5 = &v4[10 * a2];
    v6 = 80 * a2;
    v7 = vdup_n_s32(0x7FC00000u);
    do
    {
      std::string::basic_string[abi:ne180100]<0>(v4, "unknown");
      v4[3] = v7;
      v4[6].i32[1] = 0;
      v4[7].i8[0] = 0;
      v4[7].i32[1] = 0;
      v4[4] = 0;
      v4[5] = 0;
      v4[6].i16[0] = 0;
      v4 += 10;
      v6 -= 80;
    }
    while (v6);
    a1[1] = v5;
  }
  return a1;
}

void sub_1A1594370(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<vision::mod::DetectedObject>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__31326(__n128 *a1, __n128 *a2)
{
  __n128 result;

  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__31327(uint64_t a1)
{
  void **v1;

  v1 = (void **)(a1 + 48);
  std::vector<vision::mod::DetectedObject>::__destroy_vector::operator()[abi:ne180100](&v1);
}

void sub_1A1594488(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1594528(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

_QWORD *__copy_helper_block_ea8_48c69_ZTSNSt3__16vectorIN6vision3mod14DetectedObjectENS_9allocatorIS3_EEEE(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;

  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  v2 = (_QWORD *)(a1 + 48);
  v2[2] = 0;
  return std::vector<vision::mod::DetectedObject>::__init_with_size[abi:ne180100]<vision::mod::DetectedObject*,vision::mod::DetectedObject*>(v2, *(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 56), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a2 + 56) - *(_QWORD *)(a2 + 48)) >> 4));
}

void __destroy_helper_block_ea8_48c69_ZTSNSt3__16vectorIN6vision3mod14DetectedObjectENS_9allocatorIS3_EEEE(uint64_t a1)
{
  void **v1;

  v1 = (void **)(a1 + 48);
  std::vector<vision::mod::DetectedObject>::__destroy_vector::operator()[abi:ne180100](&v1);
}

void sub_1A1594614(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1594920(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_1A159578C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1595964(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A1595A8C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1595E4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12)
{
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

void sub_1A1595FB8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1596374(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  _Unwind_Resume(a1);
}

void sub_1A1596998()
{
  __break(1u);
}

void sub_1A15969C4()
{
  __cxa_end_catch();
  JUMPOUT(0x1A1596A7CLL);
}

void sub_1A15969D4()
{
  JUMPOUT(0x1A1596A7CLL);
}

void sub_1A15969DC(void *a1)
{
  objc_begin_catch(a1);
  JUMPOUT(0x1A1596788);
}

void sub_1A1596A40()
{
  JUMPOUT(0x1A1596A64);
}

void sub_1A1596A4C()
{
  void *v0;

  JUMPOUT(0x1A1596A60);
}

void sub_1A1596C18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

void sub_1A1596E6C(_Unwind_Exception *exception_object, int a2)
{
  void *v2;
  void *v3;
  void *v4;

  if (a2)
  {

    objc_begin_catch(exception_object);
    JUMPOUT(0x1A1596E00);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A159701C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<unsigned char *,void (*)(void *),std::allocator<unsigned char>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A1B0A898);
}

uint64_t std::__shared_ptr_pointer<unsigned char *,void (*)(void *),std::allocator<unsigned char>>::__on_zero_shared(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 32))(*(_QWORD *)(a1 + 24));
}

uint64_t std::__shared_ptr_pointer<unsigned char *,void (*)(void *),std::allocator<unsigned char>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](*(_QWORD *)(a2 + 8), 0x80000001A15FABCALL))
    return a1 + 32;
  else
    return 0;
}

void sub_1A1597D78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  void *v30;

  _Unwind_Resume(a1);
}

void sub_1A1597FFC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A1598D84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, uint64_t a17, void *a18, void *a19, uint64_t a20,uint64_t a21,void *a22,void *a23,void *a24,void *a25,void *a26,void *a27,uint64_t a28,uint64_t a29,void *a30,void *a31,uint64_t a32,uint64_t a33,uint64_t a34,id *a35,id *a36,uint64_t a37,uint64_t a38,void *a39,void *a40)
{
  void *v41;

  objc_destroyWeak((id *)&STACK[0x2A8]);
  _Block_object_dispose(&STACK[0x2B0], 8);

  _Block_object_dispose(&STACK[0x2E8], 8);
  STACK[0x2B0] = a14;
  std::vector<GazeFollowOutputsPerFace>::__destroy_vector::operator()[abi:ne180100]((void ***)&STACK[0x2B0]);
  _Block_object_dispose(&STACK[0x330], 8);
  v41 = (void *)STACK[0x360];
  if (STACK[0x360])
  {
    STACK[0x368] = (unint64_t)v41;
    operator delete(v41);
  }

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__31784(__n128 *a1, __n128 *a2)
{
  __n128 result;

  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__31785(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(_QWORD *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

_QWORD *std::vector<CamGaze_output_label>::vector(_QWORD *a1, unint64_t a2)
{
  size_t v4;
  char *v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2 >> 62)
    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
  v4 = 4 * a2;
  v5 = (char *)operator new(4 * a2);
  *a1 = v5;
  a1[2] = &v5[4 * a2];
  bzero(v5, v4);
  a1[1] = &v5[v4];
  return a1;
}

void sub_1A1599174(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

__n128 __Block_byref_object_copy__42_31787(__n128 *a1, __n128 *a2)
{
  __n128 result;

  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__43_31788(uint64_t a1)
{
  void **v1;

  v1 = (void **)(a1 + 48);
  std::vector<GazeFollowOutputsPerFace>::__destroy_vector::operator()[abi:ne180100](&v1);
}

_QWORD *std::vector<GazeFollowOutputsPerFace>::vector(_QWORD *a1, unint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  char *v5;
  uint64_t v6;
  char *v7;
  _QWORD *v8;
  char *v10;
  int32x4_t v11;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2 >= 0x1E1E1E1E1E1E1E2)
    std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
  v3 = 17 * a2;
  v4 = 136 * a2;
  v5 = (char *)operator new(136 * a2);
  v6 = 0;
  *a1 = v5;
  a1[1] = v5;
  v10 = &v5[8 * v3];
  a1[2] = v10;
  v11 = vdupq_n_s32(0x7FC00000u);
  do
  {
    v7 = &v5[v6];
    *((_OWORD *)v7 + 2) = 0u;
    *((_OWORD *)v7 + 3) = 0u;
    *((_QWORD *)v7 + 10) = 0;
    *(_OWORD *)v7 = 0u;
    *((_OWORD *)v7 + 1) = 0u;
    *((_DWORD *)v7 + 4) = -1;
    *(_QWORD *)&v5[v6 + 24] = 0;
    *((_QWORD *)v7 + 4) = 0;
    *((_QWORD *)v7 + 5) = 0;
    *((_DWORD *)v7 + 12) = -1082130432;
    *(_QWORD *)(v7 + 52) = -1;
    *((_DWORD *)v7 + 15) = -1;
    *((int32x4_t *)v7 + 4) = v11;
    *((_DWORD *)v7 + 20) = 2143289344;
    *(_OWORD *)&v5[v6 + 88] = 0u;
    *(_OWORD *)(v7 + 104) = 0u;
    *(_OWORD *)(v7 + 120) = 0u;
    v8 = operator new(8uLL);
    *((_QWORD *)v7 + 15) = v8 + 1;
    *((_QWORD *)v7 + 16) = v8 + 1;
    *v8 = 0;
    v6 += 136;
    *((_QWORD *)v7 + 14) = v8;
  }
  while (v4 != v6);
  a1[1] = v10;
  return a1;
}

void sub_1A1599308(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  std::vector<GazeFollowOutputsPerFace>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__46(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 48) = *(_DWORD *)(a2 + 48);
  return result;
}

uint64_t __Block_byref_object_copy__51(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__52(uint64_t a1)
{

}

void sub_1A159957C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A1599858()
{
  __break(1u);
}

void sub_1A159987C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, uint64_t a17, void *a18, void *a19, void *a20)
{
  void *v20;
  void *v21;

  objc_end_catch();

  JUMPOUT(0x1A15998F0);
}

void sub_1A1599890(void *a1)
{
  void *v1;
  void *v2;

  objc_begin_catch(a1);
  JUMPOUT(0x1A1599818);
}

void sub_1A159989C(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void std::vector<GazeFollowOutputsPerFace>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  void *v6;
  void **v7;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = (void *)*((_QWORD *)v4 - 3);
        if (v6)
        {
          *((_QWORD *)v4 - 2) = v6;
          operator delete(v6);
        }
        v7 = (void **)(v4 - 48);
        std::vector<std::vector<long long>>::__destroy_vector::operator()[abi:ne180100](&v7);
        v7 = (void **)(v4 - 112);
        std::vector<std::vector<long long>>::__destroy_vector::operator()[abi:ne180100](&v7);
        v4 -= 136;
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1A1599C80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, uint64_t a16, void *a17, void *a18)
{
  void *v18;
  uint64_t v19;

  _Block_object_dispose((const void *)(v19 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_1A159A86C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22)
{
  if (a2)
  {
    if (__p)
      operator delete(__p);
    objc_begin_catch(exception_object);
    JUMPOUT(0x1A159A1E4);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A159AA74(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A159AB2C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A159AC6C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A159AE54(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_1A159AF8C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A159B184(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id a24)
{
  void *v24;
  void *v25;
  void *v26;
  void *v27;

  _Block_object_dispose(&a19, 8);
  _Unwind_Resume(a1);
}

void sub_1A159B3DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__32052(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__32053(uint64_t a1)
{

}

void sub_1A159B590(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A159B7C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1A159B940(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1A159BA4C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  v3 = v2;

  _Unwind_Resume(a1);
}

void sub_1A159BC54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

void sub_1A159BEAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

void sub_1A159C090(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_1A159C1E4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A159C3F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1A159C838(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A159CA4C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A159CAC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A159CBC8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A159CE70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12)
{
  void *v12;
  void *v13;
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

void sub_1A159D030(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A159D0C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A159D1A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A159D250(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A159D2D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1A159D358(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A159D478(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A159D530(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A159D590(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A159D624(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A159D678(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A159D6D4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A159D728(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A159DCC0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A159DDEC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A159DEF8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A159E15C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

double vision::mod::RPNTrackerOptions::clone(vision::mod::RPNTrackerOptions *this)
{
  uint64_t v2;
  uint64_t v3;
  double result;

  v2 = operator new();
  v3 = *((_QWORD *)this + 1);
  *(_QWORD *)v2 = &off_1E453A3A8;
  *(_QWORD *)(v2 + 8) = v3;
  *(_DWORD *)(v2 + 16) = *((_DWORD *)this + 4);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)((char *)this + 24);
  *(_OWORD *)(v2 + 40) = *(_OWORD *)((char *)this + 40);
  *(_OWORD *)(v2 + 56) = *(_OWORD *)((char *)this + 56);
  *(_OWORD *)(v2 + 72) = *(_OWORD *)((char *)this + 72);
  *(_OWORD *)(v2 + 88) = *(_OWORD *)((char *)this + 88);
  result = *((double *)this + 13);
  *(double *)(v2 + 104) = result;
  return result;
}

void vision::mod::ObjectTrackerRPN::~ObjectTrackerRPN(vision::mod::ObjectTrackerRPN *this)
{
  vision::mod::ObjectTrackerRPN::~ObjectTrackerRPN(this);
  JUMPOUT(0x1A1B0A898);
}

{
  *(_QWORD *)this = &off_1E453A338;
  NtDestroyTracker(*((_QWORD *)this + 4));
  *((_QWORD *)this + 4) = 0;
  *(_QWORD *)this = off_1E453A5B0;
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)this + 16);
}

uint64_t vision::mod::ObjectTrackerRPN::setTargetObjects(uint64_t a1, __CVBuffer *a2, float32x2_t **a3)
{
  float32x2_t *v3;
  void *v6;
  void *v7;
  float32x2_t v8;
  float64x2_t v9;
  NSObject *v10;
  int8x16_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD block[7];
  float64x2_t v16;
  int8x16_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  int v21;

  if (!*(_QWORD *)(a1 + 32))
    return 6751;
  v3 = *a3;
  if ((char *)a3[1] - (char *)*a3 != 80)
    return 6780;
  if (!v6)
    __cxa_bad_cast();
  v7 = v6;
  CVPixelBufferGetHeight(a2);
  v20 = 0x2000000000;
  block[1] = 0x40000000;
  v8 = v3[4];
  v9 = vcvtq_f64_f32(v3[3]);
  v18 = 0;
  v19 = &v18;
  v21 = 0;
  v10 = *((_QWORD *)v7 + 11);
  block[0] = MEMORY[0x1E0C809B0];
  block[2] = ___ZN6vision3mod16ObjectTrackerRPN16setTargetObjectsEP10__CVBufferRKNSt3__16vectorINS0_14DetectedObjectENS4_9allocatorIS6_EEEE_block_invoke;
  block[3] = &unk_1E4548CD0;
  block[4] = &v18;
  block[5] = a1;
  block[6] = a2;
  v11 = (int8x16_t)vcvtq_f64_f32(v8);
  v16 = v9;
  v17 = vextq_s8(v11, v11, 8uLL);
  dispatch_sync(v10, block);
  v12 = vision::mod::ObjectTrackerRPN::mapRPNErrorCodesToCVMLStatus(*((_DWORD *)v19 + 6));
  if (v12 == 128)
    v13 = 6784;
  else
    v13 = v12;
  _Block_object_dispose(&v18, 8);
  return v13;
}

void sub_1A159E384(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::ObjectTrackerRPN::track(uint64_t a1, __CVBuffer *a2, uint64_t *a3)
{
  void *v6;
  NSObject *v7;
  uint64_t v8;
  double *v9;
  size_t Height;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  unint64_t v16;
  uint64_t v17;
  _QWORD block[8];
  uint64_t v20;
  double *v21;
  uint64_t v22;
  __n128 (*v23)(uint64_t, uint64_t);
  uint64_t (*v24)();
  __int128 v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  int v31;
  void *__p[2];
  char v33;
  unint64_t v34;
  unint64_t v35;
  uint64_t v36;
  __int16 v37;
  int v38;
  char v39;
  int v40;
  void *v41;
  char v42;
  float v43;
  float v44;
  float v45;
  float v46;
  uint64_t v47;
  __int16 v48;
  int v49;
  char v50;
  int v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)(a1 + 32))
    return 6751;
  if (!v6)
    __cxa_bad_cast();
  v28 = 0;
  v29 = &v28;
  v30 = 0x2000000000;
  v31 = 0;
  v20 = 0;
  v21 = (double *)&v20;
  v22 = 0x5002000000;
  v23 = __Block_byref_object_copy__32521;
  v24 = __Block_byref_object_dispose__32522;
  v25 = 0u;
  v26 = 0u;
  v27 = 0;
  v7 = *((_QWORD *)v6 + 12);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___ZN6vision3mod16ObjectTrackerRPN5trackEP10__CVBufferRNSt3__16vectorINS0_14DetectedObjectENS4_9allocatorIS6_EEEE_block_invoke;
  block[3] = &unk_1E4548CF8;
  block[6] = a1;
  block[7] = a2;
  block[4] = &v28;
  block[5] = &v20;
  dispatch_sync(v7, block);
  v8 = vision::mod::ObjectTrackerRPN::mapRPNErrorCodesToCVMLStatus(*((_DWORD *)v29 + 6));
  if (v8 == 128)
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "unknown");
    v34 = (unint64_t)vdup_n_s32(0x7FC00000u);
    v38 = 0;
    v39 = 0;
    v40 = 0;
    v35 = 0;
    v36 = 0;
    v37 = 0;
    v9 = v21;
    Height = CVPixelBufferGetHeight(a2);
    std::string::basic_string[abi:ne180100]<0>(&v41, "unknown");
    v49 = 0;
    v50 = 0;
    v51 = 0;
    v47 = 0;
    v48 = 0;
    v11 = v9[5];
    v12 = v9[6];
    v13 = v9[8];
    v14 = v9[7];
    v45 = v13;
    v46 = v14;
    v15 = (float)Height - (float)(v12 + v13);
    v43 = v11;
    v44 = v15;
    if (v42 < 0)
      operator delete(v41);
    v34 = __PAIR64__(LODWORD(v15), LODWORD(v11));
    v35 = __PAIR64__(LODWORD(v14), LODWORD(v13));
    v40 = *((_DWORD *)v21 + 19);
    v16 = a3[1];
    if (v16 >= a3[2])
    {
      v17 = std::vector<vision::mod::DetectedObject>::__push_back_slow_path<vision::mod::DetectedObject const&>(a3, (uint64_t)__p);
    }
    else
    {
      vision::mod::DetectedObject::DetectedObject(a3[1], (uint64_t)__p);
      v17 = v16 + 80;
      a3[1] = v16 + 80;
    }
    a3[1] = v17;
    if (v33 < 0)
      operator delete(__p[0]);
    v8 = 6784;
  }
  _Block_object_dispose(&v20, 8);
  _Block_object_dispose(&v28, 8);
  return v8;
}

void sub_1A159E600(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (a37 < 0)
    operator delete(__p);
  _Block_object_dispose(&a18, 8);
  _Block_object_dispose(&a28, 8);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::ObjectTrackerRPN::update(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if (result == 128)
  {
    result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 24))(a1, a2, a3);
    if (result == 128)
      return 6784;
  }
  return result;
}

uint64_t vision::mod::ObjectTrackerRPN::init(const void **this)
{
  unint64_t v1;
  unint64_t v2;
  _DWORD *v4;
  _DWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t result;
  CVPixelBufferRef PixelBuffer;
  CVPixelBufferRef v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  (*((void (**)(const void **))*this + 7))(this);
  if (!v4)
    __cxa_bad_cast();
  v5 = v4;
  LODWORD(v2) = v4[26];
  LODWORD(v1) = v4[27];
  v6 = *((_QWORD *)v4 + 6);
  v7 = *((_QWORD *)v4 + 10);
  v8 = operator new();
  bzero((void *)v8, 0x3D000uLL);
  *(_DWORD *)(v8 + 1080) = -1;
  *(_OWORD *)(v8 + 1104) = 0u;
  *(_BYTE *)(v8 + 1120) = 0;
  bzero((void *)(v8 + 1124), 0x749uLL);
  *(_OWORD *)(v8 + 3342) = 0u;
  *(_OWORD *)(v8 + 3328) = 0u;
  *(_OWORD *)(v8 + 3312) = 0u;
  *(_OWORD *)(v8 + 3296) = 0u;
  *(_OWORD *)(v8 + 3280) = 0u;
  *(_OWORD *)(v8 + 3264) = 0u;
  *(_OWORD *)(v8 + 3248) = 0u;
  *(_OWORD *)(v8 + 3232) = 0u;
  *(_OWORD *)(v8 + 3216) = 0u;
  *(_OWORD *)(v8 + 3200) = 0u;
  *(_OWORD *)(v8 + 3184) = 0u;
  *(_OWORD *)(v8 + 3168) = 0u;
  *(_OWORD *)(v8 + 3152) = 0u;
  *(_OWORD *)(v8 + 3136) = 0u;
  *(_OWORD *)(v8 + 3120) = 0u;
  *(_OWORD *)(v8 + 3104) = 0u;
  *(_OWORD *)(v8 + 3088) = 0u;
  *(_OWORD *)(v8 + 3072) = 0u;
  *(_OWORD *)(v8 + 3056) = 0u;
  *(_OWORD *)(v8 + 3040) = 0u;
  *(_OWORD *)(v8 + 3024) = 0u;
  *(_OWORD *)(v8 + 3008) = 0u;
  *(_OWORD *)(v8 + 2992) = 0u;
  *(_OWORD *)(v8 + 3673) = 0u;
  *(_OWORD *)(v8 + 3664) = 0u;
  *(_OWORD *)(v8 + 3648) = 0u;
  *(_OWORD *)(v8 + 3632) = 0u;
  *(_OWORD *)(v8 + 3616) = 0u;
  *(_OWORD *)(v8 + 3600) = 0u;
  *(_OWORD *)(v8 + 3584) = 0u;
  *(_OWORD *)(v8 + 3568) = 0u;
  *(_OWORD *)(v8 + 3552) = 0u;
  *(_OWORD *)(v8 + 3536) = 0u;
  *(_OWORD *)(v8 + 3520) = 0u;
  *(_OWORD *)(v8 + 3504) = 0u;
  *(_OWORD *)(v8 + 3488) = 0u;
  *(_OWORD *)(v8 + 3472) = 0u;
  *(_OWORD *)(v8 + 3456) = 0u;
  *(_OWORD *)(v8 + 3440) = 0u;
  *(_OWORD *)(v8 + 3424) = 0u;
  *(_OWORD *)(v8 + 3408) = 0u;
  *(_OWORD *)(v8 + 3392) = 0u;
  *(_OWORD *)(v8 + 3376) = 0u;
  *(_OWORD *)(v8 + 3360) = 0u;
  *(_QWORD *)(v8 + 4044) = 0;
  *(_OWORD *)(v8 + 4012) = 0u;
  *(_OWORD *)(v8 + 4028) = 0u;
  *(_OWORD *)(v8 + 3980) = 0u;
  *(_OWORD *)(v8 + 3996) = 0u;
  *(_OWORD *)(v8 + 3948) = 0u;
  *(_OWORD *)(v8 + 3964) = 0u;
  *(_OWORD *)(v8 + 3916) = 0u;
  *(_OWORD *)(v8 + 3932) = 0u;
  *(_OWORD *)(v8 + 3884) = 0u;
  *(_OWORD *)(v8 + 3900) = 0u;
  *(_OWORD *)(v8 + 3852) = 0u;
  *(_OWORD *)(v8 + 3868) = 0u;
  *(_OWORD *)(v8 + 3820) = 0u;
  *(_OWORD *)(v8 + 3836) = 0u;
  *(_OWORD *)(v8 + 3788) = 0u;
  *(_OWORD *)(v8 + 3804) = 0u;
  *(_OWORD *)(v8 + 3756) = 0u;
  *(_OWORD *)(v8 + 3772) = 0u;
  *(_OWORD *)(v8 + 3724) = 0u;
  *(_OWORD *)(v8 + 3740) = 0u;
  *(_OWORD *)(v8 + 3692) = 0u;
  *(_OWORD *)(v8 + 3708) = 0u;
  bzero((void *)(v8 + 4056), 0x3C022uLL);
  this[4] = (const void *)v8;
  *(_BYTE *)(v8 + 4089) = 1;
  *(_QWORD *)(v8 + 1088) = v6;
  *(_QWORD *)(v8 + 1096) = v7;
  *(_OWORD *)(v8 + 24) = *(_OWORD *)(v5 + 6);
  *(_QWORD *)(v8 + 16) = *((_QWORD *)v5 + 5);
  *(_OWORD *)(v8 + 392) = *(_OWORD *)(v5 + 14);
  *(_QWORD *)(v8 + 384) = *((_QWORD *)v5 + 9);
  if (espresso_network_bind_buffer()
    || espresso_network_bind_buffer()
    || espresso_network_bind_buffer()
    || espresso_network_bind_buffer()
    || espresso_network_bind_buffer()
    || espresso_network_bind_buffer())
  {
    v9 = -9;
  }
  else
  {
    *(_BYTE *)(v8 + 1120) = 0;
    *(_QWORD *)(v8 + 1112) = 0;
    if (TtTrkRpnCreate((_QWORD *)(v8 + 1104), v8 + 1124, (unsigned int *)(v8 + 1125)))
      goto LABEL_13;
    TtTrkRpnGetParams(*(_QWORD *)(v8 + 1104), v8 + 1125, v8 + 2992);
    PixelBuffer = NtCreatePixelBuffer(*(_DWORD *)(v8 + 3004), *(_DWORD *)(v8 + 3008), (IOSurfaceRef *)(v8 + 4064));
    *(_QWORD *)(v8 + 4056) = PixelBuffer;
    if (!PixelBuffer)
      goto LABEL_13;
    v12 = NtCreatePixelBuffer(*(_DWORD *)(v8 + 3020), *(_DWORD *)(v8 + 3024), (IOSurfaceRef *)(v8 + 4080));
    *(_QWORD *)(v8 + 4072) = v12;
    if (!v12)
      goto LABEL_13;
    *(_DWORD *)(v8 + 3212) = *(_DWORD *)(v8 + 3016);
    *(_QWORD *)(v8 + 3204) = 0;
    *(_DWORD *)(v8 + 3224) = *(_DWORD *)(v8 + 3032);
    *(_QWORD *)(v8 + 3216) = 0;
    v13 = *(_QWORD *)(v8 + 40);
    *(_QWORD *)(v8 + 3244) = *(_QWORD *)(v8 + 3096);
    v14 = *(_QWORD *)(v8 + 208);
    *(_QWORD *)(v8 + 3228) = v13;
    *(_QWORD *)(v8 + 3236) = v14;
    *(_DWORD *)(v8 + 3268) = *(_DWORD *)(v8 + 3060);
    v15 = *(_QWORD *)(v8 + 744);
    *(_DWORD *)(v8 + 3272) = *(_DWORD *)(v8 + 3064);
    v16 = *(_QWORD *)(v8 + 912);
    *(_QWORD *)(v8 + 3252) = v15;
    *(_QWORD *)(v8 + 3260) = v16;
    if (TtTrkRpnStart(*(rtcv::LoggerDevNull ***)(v8 + 1104), (unsigned int *)(v8 + 1125)))
    {
LABEL_13:
      v9 = -8;
    }
    else
    {
      *(_BYTE *)(v8 + 4088) = 0;
      TtTrkRpnPreProcessCropResizeTempBytes((rtcv *)((double)v2 + 0.5), ((double)v1 + 0.5), (_DWORD *)(v8 + 3512));
      v17 = operator new[]();
      v9 = 0;
      *(_QWORD *)(v8 + 3504) = v17;
      *(_DWORD *)v8 = -1430532899;
    }
  }
  result = vision::mod::ObjectTrackerRPN::mapRPNErrorCodesToCVMLStatus(v9);
  if (result == 128)
    return 6784;
  this[4] = 0;
  return result;
}

uint64_t vision::mod::ObjectTrackerRPN::free(vision::mod::ObjectTrackerRPN *this)
{
  NtDestroyTracker(*((_QWORD *)this + 4));
  *((_QWORD *)this + 4) = 0;
  return 6784;
}

uint64_t vision::mod::ObjectTrackerRPN::mapRPNErrorCodesToCVMLStatus(int a1)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  BOOL v5;
  uint64_t *v6;

  if (vision::mod::ObjectTrackerRPN::mapRPNErrorCodesToCVMLStatus(NtReturn)::onceToken != -1)
    dispatch_once(&vision::mod::ObjectTrackerRPN::mapRPNErrorCodesToCVMLStatus(NtReturn)::onceToken, &__block_literal_global_32518);
  v2 = *(_QWORD *)(vision::mod::ObjectTrackerRPN::mapRPNErrorCodesToCVMLStatus(NtReturn)::mapRPNErrorCodesToCVMLStatus
                 + 8);
  if (!v2)
    return 6782;
  v3 = vision::mod::ObjectTrackerRPN::mapRPNErrorCodesToCVMLStatus(NtReturn)::mapRPNErrorCodesToCVMLStatus + 8;
  do
  {
    v4 = *(_DWORD *)(v2 + 32);
    v5 = v4 < a1;
    if (v4 >= a1)
      v6 = (uint64_t *)v2;
    else
      v6 = (uint64_t *)(v2 + 8);
    if (!v5)
      v3 = v2;
    v2 = *v6;
  }
  while (*v6);
  if (v3 != vision::mod::ObjectTrackerRPN::mapRPNErrorCodesToCVMLStatus(NtReturn)::mapRPNErrorCodesToCVMLStatus + 8
    && *(_DWORD *)(v3 + 32) <= a1)
  {
    return *(_QWORD *)(v3 + 40);
  }
  else
  {
    return 6782;
  }
}

void sub_1A159EE08(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<std::__value_type<long long,int>,std::__map_value_compare<long long,std::__value_type<long long,int>,std::less<long long>,true>,std::allocator<std::__value_type<long long,int>>>::destroy(*(_QWORD **)(v1 + 8));
  MEMORY[0x1A1B0A898](v1, 0x1020C4062D53EE8);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__32521(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a2 + 40);
  v3 = *(_OWORD *)(a2 + 56);
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v3;
  *(__n128 *)(a1 + 40) = result;
  return result;
}

uint64_t ___ZN6vision3mod16ObjectTrackerRPN5trackEP10__CVBufferRNSt3__16vectorINS0_14DetectedObjectENS4_9allocatorIS6_EEEE_block_invoke(uint64_t result)
{
  uint64_t v1;
  _DWORD *v2;
  __CVBuffer *v3;
  uint64_t v4;
  void *BaseAddress;
  int Height;
  int v7;
  int BytesPerRow;
  uint64_t v9;
  int v10;
  unsigned int Width;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  void *v17;
  uint64_t v18;
  unsigned __int8 *v19;
  void *v20;
  int v21;
  int v22;
  int v23;
  int v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  v1 = result;
  v2 = *(_DWORD **)(*(_QWORD *)(result + 48) + 32);
  if (v2 && *v2 == -1430532899)
  {
    v3 = *(__CVBuffer **)(result + 56);
    v4 = *(_QWORD *)(*(_QWORD *)(result + 40) + 8);
    *(_DWORD *)(v4 + 72) = 3;
    NtLockCvPixelBuffers((uint64_t)v2);
    CVPixelBufferLockBaseAddress(v3, 1uLL);
    if (TtTrkRpnInstancePreProcess(*((_QWORD *)v2 + 138), (uint64_t)(v2 + 278), (uint64_t)(v2 + 879), (float32x2_t *)((char *)v2 + 1125), (uint64_t)(v2 + 801), (uint64_t)(v2 + 819), (uint64_t)(v2 + 840)))goto LABEL_5;
    v18 = v4;
    v19 = (unsigned __int8 *)(v2 + 879);
    BaseAddress = CVPixelBufferGetBaseAddress(v3);
    Height = CVPixelBufferGetHeight(v3);
    v7 = 4 * CVPixelBufferGetWidth(v3);
    BytesPerRow = CVPixelBufferGetBytesPerRow(v3);
    v9 = *((_QWORD *)v2 + 138);
    v20 = BaseAddress;
    v21 = Height;
    v22 = v7;
    v23 = BytesPerRow;
    v24 = 1;
    if (TtTrkRpnPreProcessCropResizeRef(v9, (uint64_t)(v2 + 278), (uint64_t)&v20, (uint64_t)(v2 + 819), (uint64_t)(v2 + 876), (uint64_t)v2 + 1125, (uint64_t)(v2 + 801)))
    {
LABEL_5:
      CVPixelBufferUnlockBaseAddress(v3, 1uLL);
      CVPixelBufferUnlockBaseAddress(*((CVPixelBufferRef *)v2 + 509), 0);
      result = CVPixelBufferUnlockBaseAddress(*((CVPixelBufferRef *)v2 + 507), 0);
      v10 = -8;
    }
    else
    {
      v17 = CVPixelBufferGetBaseAddress(*((CVPixelBufferRef *)v2 + 507));
      Width = CVPixelBufferGetWidth(*((CVPixelBufferRef *)v2 + 507));
      v12 = CVPixelBufferGetHeight(*((CVPixelBufferRef *)v2 + 507));
      v13 = Width;
      v14 = CVPixelBufferGetBytesPerRow(*((CVPixelBufferRef *)v2 + 507));
      memcpy(*((void **)v2 + 51), (char *)v2 + 4090, 0x28000uLL);
      memcpy(*((void **)v2 + 72), (char *)v2 + 167930, 0x14000uLL);
      v25 = v17;
      v26 = v12;
      v27 = v13;
      v28 = v14;
      result = espresso_network_bind_input_vimagebuffer_bgra8();
      if ((_DWORD)result
        || (!*((_BYTE *)v2 + 4089)
          ? (result = espresso_plan_execute_sync(), v2[270] = result)
          : (dispatch_sync_f(*((dispatch_queue_t *)v2 + 137), v2, (dispatch_function_t)EspressoInstancePlanExecuteSynced), result = v2[270]), (_DWORD)result))
      {
        v10 = -9;
      }
      else
      {
        TtTrkRpnInstancePostProcess(*((_QWORD *)v2 + 138), v2 + 278, (uint64_t)(v2 + 801), (uint64_t)(v2 + 819), (_DWORD *)((char *)v2 + 1125), v19);
        if (*((_BYTE *)v2 + 4088))
        {
          if (v2[924])
          {
            v15 = v18;
            *(float64x2_t *)(v18 + 40) = vcvtq_f64_f32(*(float32x2_t *)(v2 + 927));
            *(float64x2_t *)(v18 + 56) = vcvtq_f64_f32(*(float32x2_t *)(v2 + 929));
            *(float *)(v18 + 76) = (float)v2[931] / 1000.0;
            v16 = v2[946] != 1;
          }
          else
          {
            v16 = 2;
            v15 = v18;
          }
          *(_DWORD *)(v15 + 72) = v16;
          *v19 = 0;
        }
        CVPixelBufferUnlockBaseAddress(v3, 1uLL);
        CVPixelBufferUnlockBaseAddress(*((CVPixelBufferRef *)v2 + 509), 0);
        result = CVPixelBufferUnlockBaseAddress(*((CVPixelBufferRef *)v2 + 507), 0);
        v10 = 0;
      }
    }
  }
  else
  {
    v10 = -4;
  }
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v1 + 32) + 8) + 24) = v10;
  return result;
}

uint64_t ___ZN6vision3mod16ObjectTrackerRPN16setTargetObjectsEP10__CVBufferRKNSt3__16vectorINS0_14DetectedObjectENS4_9allocatorIS6_EEEE_block_invoke(uint64_t result)
{
  uint64_t v1;
  _DWORD *v2;
  __CVBuffer *v3;
  int v4;
  void *BaseAddress;
  int Height;
  int v7;
  int BytesPerRow;
  uint64_t v9;
  int v10;
  void *v11;
  void *v12;
  unsigned int Width;
  unsigned int v14;
  unsigned int v15;
  int v16;
  float64x2_t v17;
  float64x2_t v18;
  void *v19;
  int v20;
  int v21;
  int v22;
  int v23;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v1 = result;
  v2 = *(_DWORD **)(*(_QWORD *)(result + 40) + 32);
  if (!v2 || *v2 != -1430532899)
  {
    v4 = -4;
    goto LABEL_8;
  }
  v3 = *(__CVBuffer **)(result + 48);
  v17 = *(float64x2_t *)(result + 56);
  v18 = *(float64x2_t *)(result + 72);
  NtLockCvPixelBuffers((uint64_t)v2);
  result = CVPixelBufferLockBaseAddress(v3, 1uLL);
  if ((_DWORD)result)
    goto LABEL_6;
  *(float32x4_t *)(v2 + 927) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v17), v18);
  v2[924] = 1;
  v2[279] = CVPixelBufferGetHeight(v3);
  v2[278] = CVPixelBufferGetWidth(v3);
  if (TtTrkRpnExemplarPreProcess(*((_QWORD *)v2 + 138), (uint64_t)(v2 + 278), (uint64_t)(v2 + 879), (_DWORD *)((char *)v2 + 1125), (uint64_t)(v2 + 801), (uint64_t)(v2 + 819), (uint64_t)(v2 + 840)))goto LABEL_5;
  BaseAddress = CVPixelBufferGetBaseAddress(v3);
  Height = CVPixelBufferGetHeight(v3);
  v7 = 4 * CVPixelBufferGetWidth(v3);
  BytesPerRow = CVPixelBufferGetBytesPerRow(v3);
  v9 = *((_QWORD *)v2 + 138);
  v19 = BaseAddress;
  v20 = Height;
  v21 = v7;
  v22 = BytesPerRow;
  v23 = 1;
  v10 = TtTrkRpnPreProcessCropResizeRef(v9, (uint64_t)(v2 + 278), (uint64_t)&v19, (uint64_t)(v2 + 819), (uint64_t)(v2 + 876), (uint64_t)v2 + 1125, (uint64_t)(v2 + 801));
  if (!BaseAddress || v10 || (v11 = CVPixelBufferGetBaseAddress(*((CVPixelBufferRef *)v2 + 509))) == 0)
  {
LABEL_5:
    CVPixelBufferUnlockBaseAddress(v3, 1uLL);
    CVPixelBufferUnlockBaseAddress(*((CVPixelBufferRef *)v2 + 509), 0);
    result = CVPixelBufferUnlockBaseAddress(*((CVPixelBufferRef *)v2 + 507), 0);
LABEL_6:
    v4 = -8;
    goto LABEL_8;
  }
  v12 = v11;
  Width = CVPixelBufferGetWidth(*((CVPixelBufferRef *)v2 + 509));
  v14 = CVPixelBufferGetHeight(*((CVPixelBufferRef *)v2 + 509));
  v15 = CVPixelBufferGetBytesPerRow(*((CVPixelBufferRef *)v2 + 509));
  if (v14
    && Width
    && v15
    && (v24 = v12, v25 = v14, v26 = Width, v27 = v15, !espresso_network_bind_input_vimagebuffer_bgra8())
    && (!*((_BYTE *)v2 + 4089)
      ? (v16 = espresso_plan_execute_sync(), v2[270] = v16)
      : (dispatch_sync_f(*((dispatch_queue_t *)v2 + 136), v2, (dispatch_function_t)EspressoExemplarPlanExecuteSynced),
         v16 = v2[270]),
        !v16))
  {
    memcpy((char *)v2 + 4090, *((const void **)v2 + 5), 0x28000uLL);
    memcpy((char *)v2 + 167930, *((const void **)v2 + 26), 0x14000uLL);
    if (!TtTrkRpnExemplarPostProcess(*((_QWORD *)v2 + 138), (uint64_t)(v2 + 278), (uint64_t)(v2 + 801), (uint64_t)(v2 + 819), (_DWORD *)((char *)v2 + 1125), (unsigned __int8 *)v2 + 3516))*((_BYTE *)v2 + 4088) = 1;
    CVPixelBufferUnlockBaseAddress(v3, 1uLL);
    CVPixelBufferUnlockBaseAddress(*((CVPixelBufferRef *)v2 + 509), 0);
    result = CVPixelBufferUnlockBaseAddress(*((CVPixelBufferRef *)v2 + 507), 0);
    v4 = 0;
  }
  else
  {
    CVPixelBufferUnlockBaseAddress(v3, 1uLL);
    CVPixelBufferUnlockBaseAddress(*((CVPixelBufferRef *)v2 + 509), 0);
    result = CVPixelBufferUnlockBaseAddress(*((CVPixelBufferRef *)v2 + 507), 0);
    v4 = -9;
  }
LABEL_8:
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v1 + 32) + 8) + 24) = v4;
  return result;
}

void sub_1A159F530(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A159F6C0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A159F8D0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A159FA0C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A159FA8C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A159FB30(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A159FBCC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A159FC7C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A159FD40(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A159FDD4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A159FE78(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A159FF14(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A159FFBC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A15A0080(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A15A0128(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A15A01DC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1A15A0284(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A15A033C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A15A0410(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  v6 = v5;

  _Unwind_Resume(a1);
}

void sub_1A15A04B8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A15A056C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1A15A0614(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A15A06CC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A15A07A0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  v6 = v5;

  _Unwind_Resume(a1);
}

void sub_1A15A0848(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A15A08FC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1A15A09A4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A15A0A5C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A15A0B30(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  v6 = v5;

  _Unwind_Resume(a1);
}

void sub_1A15A0BC4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A15A0C68(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A15A0D04(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A15A0DAC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A15A0E70(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A15A0FB4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A15A1038(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15A140C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_1A15A164C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_1A15A17D4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A15A1A44(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15A1CE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12)
{
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;

  v18 = v15;

  _Unwind_Resume(a1);
}

void sub_1A15A1E98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  void *v13;
  void *v14;
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void sub_1A15A1FCC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15A20D4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15A21B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1A15A2290(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A15A230C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A15A2378(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A15A2444(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15A25DC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A15A2B58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16)
{
  void *v16;
  void *v17;
  void *v18;
  void *v19;

  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::~__hash_table((uint64_t)&STACK[0x230]);
  _Unwind_Resume(a1);
}

char *std::__hash_table<std::__hash_value_type<void *,espresso_buffer_t>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,espresso_buffer_t>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,espresso_buffer_t>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,espresso_buffer_t>>>::__emplace_unique_key_args<void *,std::piecewise_construct_t const&,std::tuple<void *&&>,std::tuple<>>(float *a1, unint64_t a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  void **v11;
  char *v12;
  unint64_t v13;
  float v14;
  float v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  int8x8_t prime;
  void *v20;
  _QWORD *v21;
  uint64_t v22;
  _QWORD *v23;
  unint64_t v24;
  uint8x8_t v25;
  unint64_t v26;
  uint8x8_t v27;
  uint64_t v28;
  _QWORD *v29;
  unint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  unint64_t v33;
  _QWORD *v35;

  v6 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  v7 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v6 >> 47) ^ v6);
  v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  v9 = *((_QWORD *)a1 + 1);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      v3 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9)
        v3 = v8 % v9;
    }
    else
    {
      v3 = v8 & (v9 - 1);
    }
    v11 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v11)
    {
      v12 = (char *)*v11;
      if (*v11)
      {
        do
        {
          v13 = *((_QWORD *)v12 + 1);
          if (v13 == v8)
          {
            if (*((_QWORD *)v12 + 2) == a2)
              return v12;
          }
          else
          {
            if (v10.u32[0] > 1uLL)
            {
              if (v13 >= v9)
                v13 %= v9;
            }
            else
            {
              v13 &= v9 - 1;
            }
            if (v13 != v3)
              break;
          }
          v12 = *(char **)v12;
        }
        while (v12);
      }
    }
  }
  v12 = (char *)operator new(0xC0uLL);
  *(_QWORD *)v12 = 0;
  *((_QWORD *)v12 + 1) = v8;
  *((_QWORD *)v12 + 2) = *a3;
  *(_OWORD *)(v12 + 24) = 0u;
  *(_OWORD *)(v12 + 40) = 0u;
  *(_OWORD *)(v12 + 56) = 0u;
  *(_OWORD *)(v12 + 72) = 0u;
  *(_OWORD *)(v12 + 88) = 0u;
  *(_OWORD *)(v12 + 104) = 0u;
  *(_OWORD *)(v12 + 120) = 0u;
  *(_OWORD *)(v12 + 136) = 0u;
  *(_OWORD *)(v12 + 152) = 0u;
  *(_OWORD *)(v12 + 168) = 0u;
  *((_QWORD *)v12 + 23) = 0;
  v14 = (float)(unint64_t)(*((_QWORD *)a1 + 3) + 1);
  v15 = a1[8];
  if (!v9 || (float)(v15 * (float)v9) < v14)
  {
    v16 = 1;
    if (v9 >= 3)
      v16 = (v9 & (v9 - 1)) != 0;
    v17 = v16 | (2 * v9);
    v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18)
      prime = (int8x8_t)v18;
    else
      prime = (int8x8_t)v17;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v9 = *((_QWORD *)a1 + 1);
    }
    if (*(_QWORD *)&prime > v9)
      goto LABEL_30;
    if (*(_QWORD *)&prime < v9)
    {
      v26 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v9 < 3 || (v27 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v27.i16[0] = vaddlv_u8(v27), v27.u32[0] > 1uLL))
      {
        v26 = std::__next_prime(v26);
      }
      else
      {
        v28 = 1 << -(char)__clz(v26 - 1);
        if (v26 >= 2)
          v26 = v28;
      }
      if (*(_QWORD *)&prime <= v26)
        prime = (int8x8_t)v26;
      if (*(_QWORD *)&prime >= v9)
      {
        v9 = *((_QWORD *)a1 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:ne180100]();
          v20 = operator new(8 * *(_QWORD *)&prime);
          v21 = *(_QWORD **)a1;
          *(_QWORD *)a1 = v20;
          if (v21)
            operator delete(v21);
          v22 = 0;
          *((int8x8_t *)a1 + 1) = prime;
          do
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v22++) = 0;
          while (*(_QWORD *)&prime != v22);
          v23 = (_QWORD *)*((_QWORD *)a1 + 2);
          if (v23)
          {
            v24 = v23[1];
            v25 = (uint8x8_t)vcnt_s8(prime);
            v25.i16[0] = vaddlv_u8(v25);
            if (v25.u32[0] > 1uLL)
            {
              if (v24 >= *(_QWORD *)&prime)
                v24 %= *(_QWORD *)&prime;
            }
            else
            {
              v24 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v24) = a1 + 4;
            v29 = (_QWORD *)*v23;
            if (*v23)
            {
              do
              {
                v30 = v29[1];
                if (v25.u32[0] > 1uLL)
                {
                  if (v30 >= *(_QWORD *)&prime)
                    v30 %= *(_QWORD *)&prime;
                }
                else
                {
                  v30 &= *(_QWORD *)&prime - 1;
                }
                if (v30 != v24)
                {
                  if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v30))
                  {
                    *(_QWORD *)(*(_QWORD *)a1 + 8 * v30) = v23;
                    goto LABEL_55;
                  }
                  *v23 = *v29;
                  *v29 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v30);
                  **(_QWORD **)(*(_QWORD *)a1 + 8 * v30) = v29;
                  v29 = v23;
                }
                v30 = v24;
LABEL_55:
                v23 = v29;
                v29 = (_QWORD *)*v29;
                v24 = v30;
              }
              while (v29);
            }
          }
          v9 = (unint64_t)prime;
          goto LABEL_59;
        }
        v35 = *(_QWORD **)a1;
        *(_QWORD *)a1 = 0;
        if (v35)
          operator delete(v35);
        v9 = 0;
        *((_QWORD *)a1 + 1) = 0;
      }
    }
LABEL_59:
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
  }
  v31 = *(_QWORD **)a1;
  v32 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v32)
  {
    *(_QWORD *)v12 = *v32;
LABEL_72:
    *v32 = v12;
    goto LABEL_73;
  }
  *(_QWORD *)v12 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = v12;
  v31[v3] = a1 + 4;
  if (*(_QWORD *)v12)
  {
    v33 = *(_QWORD *)(*(_QWORD *)v12 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v33 >= v9)
        v33 %= v9;
    }
    else
    {
      v33 &= v9 - 1;
    }
    v32 = (_QWORD *)(*(_QWORD *)a1 + 8 * v33);
    goto LABEL_72;
  }
LABEL_73:
  ++*((_QWORD *)a1 + 3);
  return v12;
}

void sub_1A15A30B0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t eraseContourPixels(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  __int16 *v5;

  if (!result)
    __assert_rtn("eraseContourPixels", "ConnectedComponents.c", 17, "deque != NULL");
  v3 = *(int *)(result + 8);
  v4 = (*(_DWORD *)(result + 12) - v3 + 1);
  if ((int)v4 >= 1)
  {
    v5 = (__int16 *)(*(_QWORD *)(result + 16) + 4 * v3 + 2);
    do
    {
      *(_BYTE *)(a2 + *(v5 - 1) + *v5 * a3) = 0;
      v5 += 2;
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t allocSegments(int *a1, int a2)
{
  uint64_t v2;
  int v3;
  int v4;
  int v5;
  uint64_t result;
  uint64_t v7;
  int v8;
  uint64_t v9;

  v2 = *((_QWORD *)a1 + 1);
  v3 = a1[1];
  v4 = *a1;
  v5 = *a1 + a2;
  *a1 = v5;
  if (v5 > v3)
    __assert_rtn("allocSegments", "Segments.c", 16, "sdb->nSegments <= sdb->maxSegments");
  result = v2 + 48 * v4;
  v7 = result;
  if (a2 >= 2)
  {
    v8 = a2 - 1;
    v9 = result;
    do
    {
      v7 = v9 + 48;
      *(_QWORD *)v9 = v9 + 48;
      *(_BYTE *)(v9 + 8) = 1;
      v9 += 48;
      --v8;
    }
    while (v8);
  }
  *(_QWORD *)v7 = 0;
  *(_BYTE *)(v7 + 8) = 1;
  return result;
}

float segmentSinCos(int a1, __int16 *a2, int a3, __int16 *a4, float *a5, float *a6)
{
  __int16 *v6;
  __int16 *v7;
  int v8;
  int v9;
  int v10;
  float v11;
  float result;

  v6 = &a2[2 * a1 - 2];
  v7 = &a4[2 * a3 - 2];
  v8 = *v6 - *a2;
  v9 = v6[1] - a2[1];
  LODWORD(v6) = *v7 - *a4;
  v10 = v7[1] - a4[1];
  v11 = 1.0 / sqrtf((float)(v8 * v8 + v9 * v9) * (float)((int)v6 * (int)v6 + v10 * v10));
  *a5 = v11 * (float)((int)v6 * v9 - v10 * v8);
  result = v11 * (float)((int)v6 * v8 + v10 * v9);
  *a6 = result;
  return result;
}

float segmentSinCosLen2(int a1, __int16 *a2, int a3, __int16 *a4, float *a5, float *a6, int *a7)
{
  __int16 *v7;
  __int16 *v8;
  int v9;
  int v10;
  int v11;
  int v12;
  float v13;
  float result;

  v7 = &a2[2 * a1 - 2];
  v8 = &a4[2 * a3 - 2];
  v9 = *v7 - *a2;
  v10 = v7[1] - a2[1];
  LODWORD(v7) = *v8 - *a4;
  v11 = v8[1] - a4[1];
  v12 = (_DWORD)v7 * (_DWORD)v7 + v11 * v11;
  v13 = 1.0 / sqrtf((float)(v9 * v9 + v10 * v10) * (float)v12);
  *a5 = v13 * (float)((int)v7 * v10 - v11 * v9);
  result = v13 * (float)((int)v7 * v9 + v11 * v10);
  *a6 = result;
  *a7 = v12;
  return result;
}

void sub_1A15A3674(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15A3780(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A15A3824(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1A15A38A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A15A39AC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15A3AE4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15A3B8C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15A3C70(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A15A3D30(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1A15A3E10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t vision::mod::ImageDescriptorProcessorHasher::hashFeature(vision::mod::ImageDescriptorProcessorHasher *this, const vision::mod::ImageDescriptorBufferAbstract *lpsrc, vision::mod::ImageDescriptorBufferAbstract *a3)
{
  _QWORD *v6;
  _QWORD *v7;
  BOOL v8;

  if (v6)
    v8 = v7 == 0;
  else
    v8 = 1;
  if (v8 || v6[12] != *((_DWORD *)this + 2) || v7[12] != *((_DWORD *)this + 3))
    return 3708;
  vision::mod::ImageDescriptorBufferAbstract::resizeForDescriptorsCount(a3, 1uLL, 0);
  (*(void (**)(vision::mod::ImageDescriptorProcessorHasher *, _QWORD, _QWORD))(*(_QWORD *)this + 184))(this, *((_QWORD *)lpsrc + 7), *((_QWORD *)a3 + 7));
  return 3712;
}

uint64_t vision::mod::ImageDescriptorProcessorHasher::computeHashes(_DWORD *a1, uint64_t a2, _QWORD *a3)
{
  _QWORD *v6;
  void **p_lpsrc;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  char *v13;
  int v14;
  uint64_t *v15;
  int v16;
  int v17;
  unsigned int v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  _QWORD *v32;
  std::__shared_weak_count *v33;
  void *lpsrc;
  std::__shared_weak_count *v35;
  _QWORD *v36;
  unint64_t v37;
  _QWORD *v38;

  (*(void (**)(void **__return_ptr))(*(_QWORD *)a1 + 64))(&lpsrc);
  if (lpsrc
  {
    v32 = v6;
    v33 = v35;
    p_lpsrc = &lpsrc;
  }
  else
  {
    p_lpsrc = (void **)&v32;
  }
  *p_lpsrc = 0;
  p_lpsrc[1] = 0;
  v8 = v35;
  if (v35)
  {
    p_shared_owners = (unint64_t *)&v35->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  v11 = v32;
  if (!v32)
    goto LABEL_32;
  v12 = (*(uint64_t (**)(_DWORD *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 160))(a1, a2, v32);
  if (v12 != 128)
    goto LABEL_33;
  v13 = (char *)v11[7];
  if (!v13)
  {
LABEL_32:
    v12 = 3710;
    goto LABEL_33;
  }
  v14 = a1[3];
  v15 = &CVML_status_internalError;
  if (v14)
  {
    v16 = a1[4];
    if (v16)
    {
      v17 = v14 / v16;
      if (v14 == v14 / v16 * v16)
      {
        v18 = 0;
        v19 = v17;
        v20 = a3 + 2;
        v21 = (_QWORD *)a3[1];
        v22 = 4 * v17;
        do
        {
          if ((unint64_t)v21 >= *v20)
          {
            v23 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v21 - *a3) >> 3);
            v24 = v23 + 1;
            if (v23 + 1 > 0xAAAAAAAAAAAAAAALL)
              std::vector<vision::mod::DescriptorItemSideInfo>::__throw_length_error[abi:ne180100]();
            if (0x5555555555555556 * ((uint64_t)(*v20 - *a3) >> 3) > v24)
              v24 = 0x5555555555555556 * ((uint64_t)(*v20 - *a3) >> 3);
            if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*v20 - *a3) >> 3) >= 0x555555555555555)
              v25 = 0xAAAAAAAAAAAAAAALL;
            else
              v25 = v24;
            v38 = a3 + 2;
            if (v25)
              v25 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(v25);
            else
              v26 = 0;
            v27 = (std::__shared_weak_count *)(v25 + 24 * v23);
            lpsrc = (void *)v25;
            v35 = v27;
            v36 = &v27->__vftable;
            v37 = v25 + 24 * v26;
            v27->__vftable = 0;
            v27->__shared_owners_ = 0;
            v27->__shared_weak_owners_ = 0;
            std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v27, v13, (uint64_t)&v13[v22], v19);
            v36 += 3;
            std::vector<std::vector<float>>::__swap_out_circular_buffer(a3, &lpsrc);
            v21 = (_QWORD *)a3[1];
            std::__split_buffer<std::vector<long long>>::~__split_buffer((uint64_t)&lpsrc);
          }
          else
          {
            *v21 = 0;
            v21[1] = 0;
            v21[2] = 0;
            std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v21, v13, (uint64_t)&v13[v22], v19);
            v21 += 3;
            a3[1] = v21;
          }
          a3[1] = v21;
          ++v18;
          v13 += v22;
        }
        while (v18 < a1[4]);
        v15 = &CVML_status_ok;
      }
    }
  }
  v12 = (*v15 + 128) | 0xE00;
LABEL_33:
  v28 = v33;
  if (v33)
  {
    v29 = (unint64_t *)&v33->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  return v12;
}

void sub_1A15A41D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t vision::mod::ImageDescriptorProcessorHasher::computeHashesInBase64(_DWORD *a1, uint64_t a2, std::vector<std::string> *a3)
{
  _QWORD *v6;
  void **p_lpsrc;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  int v13;
  uint64_t *v14;
  int v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  void *lpsrc;
  std::__shared_weak_count *v25;
  _QWORD *v26;
  std::__shared_weak_count *v27;

  (*(void (**)(void **__return_ptr))(*(_QWORD *)a1 + 64))(&lpsrc);
  if (lpsrc
  {
    v26 = v6;
    v27 = v25;
    p_lpsrc = &lpsrc;
  }
  else
  {
    p_lpsrc = (void **)&v26;
  }
  *p_lpsrc = 0;
  p_lpsrc[1] = 0;
  v8 = v25;
  if (v25)
  {
    p_shared_owners = (unint64_t *)&v25->__shared_owners_;
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  v11 = v26;
  if (v26)
  {
    (*(void (**)(_DWORD *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 160))(a1, a2, v26);
    v12 = v11[7];
    std::vector<std::string>::resize(a3, (int)a1[4]);
    v13 = a1[3];
    v14 = &CVML_status_internalError;
    if (v13)
    {
      v15 = a1[4];
      if (v15)
      {
        if (v13 == v13 / v15 * v15)
        {
          v16 = 0;
          v17 = 0;
          v18 = 4 * (v13 / v15);
          v14 = &CVML_status_ok;
          do
          {
            (*(void (**)(_DWORD *, uint64_t, std::string *))(*(_QWORD *)a1 + 192))(a1, v12, &a3->__begin_[v16]);
            ++v17;
            ++v16;
            v12 += v18;
          }
          while (v17 < a1[4]);
        }
      }
    }
  }
  else
  {
    v14 = &CVML_status_internalError;
  }
  v19 = *v14;
  v20 = v27;
  if (v27)
  {
    v21 = (unint64_t *)&v27->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  return (v19 + 128) | 0xE00;
}

void sub_1A15A43C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  std::shared_ptr<rtcv::Logger::Target>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void vision::mod::ImageDescriptorProcessorHasher::getBase64(std::string *this, uint64_t a2, int a3)
{
  unint64_t v6;
  int v7;
  std::string::value_type v8;
  std::string::value_type v9;
  std::string::value_type v10;
  _QWORD *exception;

  std::string::basic_string[abi:ne180100]<0>(this, "");
  if (a3 >= 25)
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = 3708;
    __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
  }
  v6 = a2 << (24 - a3);
  std::string::push_back(this, vision::mod::ImageDescriptorProcessorHasher::b64chrs[(v6 >> 18) & 0x3F]);
  v7 = vcvtd_n_s64_f64(ceil((double)a3 * 0.125), 3uLL);
  if (v7 < 7)
    v8 = 61;
  else
    v8 = vision::mod::ImageDescriptorProcessorHasher::b64chrs[(v6 >> 12) & 0x3F];
  std::string::push_back(this, v8);
  if (v7 < 13)
    v9 = 61;
  else
    v9 = vision::mod::ImageDescriptorProcessorHasher::b64chrs[(v6 >> 6) & 0x3F];
  std::string::push_back(this, v9);
  if (v7 < 19)
    v10 = 61;
  else
    v10 = vision::mod::ImageDescriptorProcessorHasher::b64chrs[v6 & 0x3F];
  std::string::push_back(this, v10);
}

void sub_1A15A44EC(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void vision::mod::ImageDescriptorProcessorHasher::base64EncodeHash(float *a1, unsigned int a2, int a3, uint64_t a4)
{
  _BYTE *v7;
  int v8;
  unint64_t v9;
  int v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  std::string *p_p;
  std::string::size_type size;
  double v16;
  std::string *v17;
  std::string::size_type v18;
  _QWORD *exception;
  uint64_t v20;
  std::string __p;

  if (*(char *)(a4 + 23) < 0)
  {
    *(_QWORD *)(a4 + 8) = 0;
    v7 = *(_BYTE **)a4;
  }
  else
  {
    *(_BYTE *)(a4 + 23) = 0;
    v7 = (_BYTE *)a4;
  }
  *v7 = 0;
  v8 = vcvtpd_s64_f64(log2((double)(2 * a3)));
  if (v8 >= 25)
  {
    exception = __cxa_allocate_exception(8uLL);
    v20 = 3708;
    goto LABEL_32;
  }
  v9 = 0;
  if (a2)
  {
    v10 = 24;
    v11 = a2;
    while (1)
    {
      v12 = (unint64_t)*a1;
      if (*a1 != (float)v12)
        break;
      if (v10 >= v8)
      {
        v9 = (v9 << v8) | v12;
        v10 -= v8;
      }
      else
      {
        v13 = v8 - v10;
        vision::mod::ImageDescriptorProcessorHasher::getBase64(&__p, (v12 >> (v8 - v10)) | (v9 << v10), 24);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          p_p = &__p;
        else
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        else
          size = __p.__r_.__value_.__l.__size_;
        std::string::append((std::string *)a4, (const std::string::value_type *)p_p, size);
        v16 = ldexp(1.0, v13);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        v9 = (unint64_t)(v16 + -1.0) & v12;
        v10 = 24 - v13;
      }
      ++a1;
      if (!--v11)
        goto LABEL_22;
    }
    exception = __cxa_allocate_exception(8uLL);
    v20 = 3700;
LABEL_32:
    *exception = v20;
    __cxa_throw(exception, MEMORY[0x1E0DE4F28], 0);
  }
  v10 = 24;
LABEL_22:
  vision::mod::ImageDescriptorProcessorHasher::getBase64(&__p, v9, 24 - v10);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v17 = &__p;
  else
    v17 = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v18 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    v18 = __p.__r_.__value_.__l.__size_;
  std::string::append((std::string *)a4, (const std::string::value_type *)v17, v18);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_1A15A46C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1A15A4774(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A15A481C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A15A48CC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A15A4980(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A15A4A34(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A15A4ADC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A15A4B88(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A15A4C90(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A15A4D84(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A15A4E88(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A15A4F90(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A15A5098(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A15A518C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1A15A5288(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A15A5318(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A15A5368(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A15A53C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1A15A5458(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1A15A54C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

BOOL VNNormalizedRectIsIdentityRect(CGRect normalizedRect)
{
  CGRect v2;

  v2.origin.x = 0.0;
  v2.origin.y = 0.0;
  v2.size.width = 1.0;
  v2.size.height = 1.0;
  return CGRectEqualToRect(normalizedRect, v2);
}

CGPoint VNImagePointForNormalizedPointUsingRegionOfInterest(CGPoint normalizedPoint, size_t imageWidth, size_t imageHeight, CGRect roi)
{
  double v4;
  double v5;
  CGPoint result;

  VisionCoreImagePointForNormalizedPoint();
  result.y = v5;
  result.x = v4;
  return result;
}

CGPoint VNNormalizedPointForImagePointUsingRegionOfInterest(CGPoint imagePoint, size_t imageWidth, size_t imageHeight, CGRect roi)
{
  double v4;
  double v5;
  CGPoint result;

  if (imageWidth && imageHeight)
  {
    v4 = (imagePoint.x - roi.origin.x * (double)imageWidth) / (roi.size.width * (double)imageWidth);
    v5 = (imagePoint.y - roi.origin.y * (double)imageHeight) / (roi.size.height * (double)imageHeight);
  }
  else
  {
    v4 = *MEMORY[0x1E0C9D538];
    v5 = *(double *)(MEMORY[0x1E0C9D538] + 8);
  }
  result.y = v5;
  result.x = v4;
  return result;
}

CGRect VNImageRectForNormalizedRect(CGRect normalizedRect, size_t imageWidth, size_t imageHeight)
{
  double v3;
  double v4;
  double v5;
  double v6;
  CGRect result;

  v3 = normalizedRect.origin.x * (double)imageWidth;
  v4 = normalizedRect.size.width * (double)imageWidth;
  v5 = normalizedRect.origin.y * (double)imageHeight;
  v6 = normalizedRect.size.height * (double)imageHeight;
  result.size.height = v6;
  result.size.width = v4;
  result.origin.y = v5;
  result.origin.x = v3;
  return result;
}

CGRect VNImageRectForNormalizedRectUsingRegionOfInterest(CGRect normalizedRect, size_t imageWidth, size_t imageHeight, CGRect roi)
{
  double height;
  double width;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  CGRect result;

  height = roi.size.height;
  width = roi.size.width;
  v8 = normalizedRect.size.height;
  v9 = normalizedRect.size.width;
  VisionCoreImagePointForNormalizedPoint();
  v12 = v9 * width * (double)imageWidth;
  v13 = v8 * height * (double)imageHeight;
  result.size.height = v13;
  result.size.width = v12;
  result.origin.y = v11;
  result.origin.x = v10;
  return result;
}

CGRect VNNormalizedRectForImageRect(CGRect imageRect, size_t imageWidth, size_t imageHeight)
{
  double width;
  double y;
  double x;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  CGRect result;

  width = imageRect.size.width;
  y = imageRect.origin.y;
  x = imageRect.origin.x;
  v6 = 0.0;
  v7 = 0.0;
  v8 = 0.0;
  if (imageWidth)
  {
    v7 = x / (double)imageWidth;
    v8 = width / (double)imageWidth;
  }
  v9 = 0.0;
  if (imageHeight)
  {
    v6 = y / (double)imageHeight;
    v9 = imageRect.size.height / (double)imageHeight;
  }
  v10 = v9;
  result.size.height = v10;
  result.size.width = v8;
  result.origin.y = v6;
  result.origin.x = v7;
  return result;
}

CGRect VNNormalizedRectForImageRectUsingRegionOfInterest(CGRect imageRect, size_t imageWidth, size_t imageHeight, CGRect roi)
{
  CGFloat height;
  CGFloat width;
  CGFloat y;
  CGFloat x;
  CGFloat v8;
  CGFloat v9;
  double v10;
  double v11;
  CGFloat MaxY;
  double v13;
  double v14;
  double v15;
  double v16;
  double MaxX;
  CGFloat v18;
  CGFloat v19;
  CGRect v20;
  CGRect result;

  if (imageWidth && imageHeight)
  {
    height = imageRect.size.height;
    width = imageRect.size.width;
    y = imageRect.origin.y;
    x = imageRect.origin.x;
    v18 = roi.origin.y * (double)imageHeight;
    v19 = roi.origin.x * (double)imageWidth;
    v8 = roi.size.width * (double)imageWidth;
    v9 = roi.size.height * (double)imageHeight;
    v10 = (imageRect.origin.x - v19) / v8;
    v11 = (imageRect.origin.y - v18) / v9;
    MaxX = CGRectGetMaxX(imageRect);
    v20.origin.x = x;
    v20.origin.y = y;
    v20.size.width = width;
    v20.size.height = height;
    MaxY = CGRectGetMaxY(v20);
    v13 = (MaxX - v19) / v8 - v10;
    v14 = (MaxY - v18) / v9 - v11;
  }
  else
  {
    v10 = *MEMORY[0x1E0C9D648];
    v11 = *(double *)(MEMORY[0x1E0C9D648] + 8);
    v13 = *(double *)(MEMORY[0x1E0C9D648] + 16);
    v14 = *(double *)(MEMORY[0x1E0C9D648] + 24);
  }
  v15 = v10;
  v16 = v11;
  result.size.height = v14;
  result.size.width = v13;
  result.origin.y = v16;
  result.origin.x = v15;
  return result;
}

CGPoint VNNormalizedFaceBoundingBoxPointForLandmarkPoint(vector_float2 faceLandmarkPoint, CGRect faceBoundingBox, size_t imageWidth, size_t imageHeight)
{
  double v4;
  double v5;
  CGPoint result;

  v4 = faceBoundingBox.size.height * (double)imageHeight * faceLandmarkPoint.f32[1];
  v5 = faceBoundingBox.size.width * (double)imageWidth * faceLandmarkPoint.f32[0];
  result.y = v4;
  result.x = v5;
  return result;
}

CGPoint VNImagePointForFaceLandmarkPoint(vector_float2 faceLandmarkPoint, CGRect faceBoundingBox, size_t imageWidth, size_t imageHeight)
{
  CGFloat v4;
  CGFloat v5;
  double v6;
  double v7;
  CGPoint result;

  v4 = faceBoundingBox.origin.y * (double)imageHeight;
  v5 = faceBoundingBox.origin.x * (double)imageWidth
     + faceLandmarkPoint.f32[0] * (faceBoundingBox.size.width * (double)imageWidth);
  v6 = v4 + faceLandmarkPoint.f32[1] * (faceBoundingBox.size.height * (double)imageHeight);
  v7 = v5;
  result.y = v6;
  result.x = v7;
  return result;
}

double VNNormalizedRectForPixelRectInBounds(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  if (a7 <= 0.0 || a8 <= 0.0)
    return *MEMORY[0x1E0C9D628];
  else
    return (a1 - a5) / a7;
}

double VNPixelRectForNormalizedRectInBounds(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  double result;
  CGRect v9;

  if (a7 <= 0.0 || a8 <= 0.0)
    return *MEMORY[0x1E0C9D628];
  v9.origin.x = a5 + a1 * a7;
  v9.origin.y = a6 + a2 * a8;
  v9.size.width = a3 * a7;
  v9.size.height = a4 * a8;
  *(_QWORD *)&result = (unint64_t)CGRectIntegral(v9);
  return result;
}

double VNLargestCentralSquareOfRect(double result, double a2, double a3, double a4)
{
  if (a3 >= a4)
    return result + (a3 - a4) * 0.5;
  return result;
}

double VNNormalizedImageRectForNormalizedRegionOfInterestRect(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  unint64_t v14;
  double result;

  v14 = (unint64_t)a1;
  result = 0.0;
  if (v14)
    return (a3 * (double)v14 + a9 * (double)(unint64_t)(a5 * (double)v14)) / (double)v14;
  return result;
}

CGFloat VNIntersectionOverUnion(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  CGRect v13;

  v13 = CGRectIntersection(*(CGRect *)&a1, *(CGRect *)&a5);
  return v13.size.width * v13.size.height / (a3 * a4 + a7 * a8 - v13.size.width * v13.size.height);
}

id VNMethodSignatureStringForObjectAndSelector(void *a1, const char *a2)
{
  id v3;
  void *v4;
  void *v5;
  _BOOL4 isClass;
  objc_class *Class;
  id v8;
  uint64_t v9;
  void *v10;
  void *v11;

  v3 = a1;
  v4 = v3;
  v5 = 0;
  if (v3 && a2)
  {
    isClass = object_isClass(v3);
    Class = object_getClass(v4);
    v8 = objc_alloc(MEMORY[0x1E0CB3940]);
    if (isClass)
      v9 = 43;
    else
      v9 = 45;
    NSStringFromClass(Class);
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    NSStringFromSelector(a2);
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    v5 = (void *)objc_msgSend(v8, "initWithFormat:", CFSTR("%c[%@ %@]"), v9, v10, v11);

  }
  return v5;
}

void sub_1A15A5A00(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v2;

  _Unwind_Resume(a1);
}

__CFString *VNElementTypeToString(unint64_t a1)
{
  if (a1 < 3)
    return off_1E4548FE0[a1];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("VNElementType(%lu)"), a1);
  return (__CFString *)(id)objc_claimAutoreleasedReturnValue();
}

__CFString *VNImageCropAndScaleOptionToString(uint64_t a1)
{
  __CFString *v1;

  if (a1 > 1)
  {
    if (a1 == 2)
      return CFSTR("VNImageCropAndScaleOptionScaleFill");
    if (a1 == 257)
      return CFSTR("VNImageCropAndScaleOptionScaleFitRotate90CCW");
    goto LABEL_10;
  }
  if (!a1)
    return CFSTR("VNImageCropAndScaleOptionCenterCrop");
  if (a1 != 1)
  {
LABEL_10:
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("VNImageCropAndScaleOption(%lu)"), a1);
    v1 = (__CFString *)objc_claimAutoreleasedReturnValue();
    return v1;
  }
  v1 = CFSTR("VNImageCropAndScaleOptionScaleFit");
  return v1;
}

void ___Z71_featureCropOrientationsFromSuperpositionOfFeatureWithImageOrientationsv_block_invoke()
{
  void *v0;
  void *v1;
  void *v2;
  uint64_t v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  _QWORD v10[4];
  _QWORD v11[4];
  _QWORD v12[4];
  _QWORD v13[4];
  _QWORD v14[4];
  _QWORD v15[4];
  _QWORD v16[4];
  _QWORD v17[4];
  _QWORD v18[4];
  _QWORD v19[4];
  _QWORD v20[4];
  _QWORD v21[4];
  _QWORD v22[4];
  _QWORD v23[4];
  _QWORD v24[4];
  _QWORD v25[4];
  _QWORD v26[8];
  _QWORD v27[10];

  v27[8] = *MEMORY[0x1E0C80C00];
  v24[0] = &unk_1E459D2E8;
  v24[1] = &unk_1E459D300;
  v25[0] = &unk_1E459D2E8;
  v25[1] = &unk_1E459D300;
  v24[2] = &unk_1E459D318;
  v24[3] = &unk_1E459D330;
  v25[2] = &unk_1E459D318;
  v25[3] = &unk_1E459D330;
  v26[0] = &unk_1E459D2E8;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v25, v24, 4);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  v27[0] = v9;
  v26[1] = &unk_1E459D348;
  v22[0] = &unk_1E459D2E8;
  v22[1] = &unk_1E459D300;
  v23[0] = &unk_1E459D348;
  v23[1] = &unk_1E459D360;
  v22[2] = &unk_1E459D318;
  v22[3] = &unk_1E459D330;
  v23[2] = &unk_1E459D378;
  v23[3] = &unk_1E459D390;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v23, v22, 4);
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  v27[1] = v8;
  v26[2] = &unk_1E459D318;
  v20[0] = &unk_1E459D2E8;
  v20[1] = &unk_1E459D300;
  v21[0] = &unk_1E459D318;
  v21[1] = &unk_1E459D330;
  v20[2] = &unk_1E459D318;
  v20[3] = &unk_1E459D330;
  v21[2] = &unk_1E459D2E8;
  v21[3] = &unk_1E459D300;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v21, v20, 4);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v27[2] = v7;
  v26[3] = &unk_1E459D378;
  v18[0] = &unk_1E459D2E8;
  v18[1] = &unk_1E459D300;
  v19[0] = &unk_1E459D378;
  v19[1] = &unk_1E459D390;
  v18[2] = &unk_1E459D318;
  v18[3] = &unk_1E459D330;
  v19[2] = &unk_1E459D348;
  v19[3] = &unk_1E459D360;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v19, v18, 4);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v27[3] = v6;
  v26[4] = &unk_1E459D390;
  v16[0] = &unk_1E459D2E8;
  v16[1] = &unk_1E459D300;
  v17[0] = &unk_1E459D390;
  v17[1] = &unk_1E459D348;
  v16[2] = &unk_1E459D318;
  v16[3] = &unk_1E459D330;
  v17[2] = &unk_1E459D360;
  v17[3] = &unk_1E459D378;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v17, v16, 4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v27[4] = v5;
  v26[5] = &unk_1E459D300;
  v14[0] = &unk_1E459D2E8;
  v14[1] = &unk_1E459D300;
  v15[0] = &unk_1E459D300;
  v15[1] = &unk_1E459D318;
  v14[2] = &unk_1E459D318;
  v14[3] = &unk_1E459D330;
  v15[2] = &unk_1E459D330;
  v15[3] = &unk_1E459D2E8;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v15, v14, 4);
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  v27[5] = v0;
  v26[6] = &unk_1E459D360;
  v12[0] = &unk_1E459D2E8;
  v12[1] = &unk_1E459D300;
  v13[0] = &unk_1E459D360;
  v13[1] = &unk_1E459D378;
  v12[2] = &unk_1E459D318;
  v12[3] = &unk_1E459D330;
  v13[2] = &unk_1E459D390;
  v13[3] = &unk_1E459D348;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v13, v12, 4);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v27[6] = v1;
  v26[7] = &unk_1E459D330;
  v10[0] = &unk_1E459D2E8;
  v10[1] = &unk_1E459D300;
  v11[0] = &unk_1E459D330;
  v11[1] = &unk_1E459D2E8;
  v10[2] = &unk_1E459D318;
  v10[3] = &unk_1E459D330;
  v11[2] = &unk_1E459D300;
  v11[3] = &unk_1E459D318;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v11, v10, 4);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v27[7] = v2;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v27, v26, 8);
  v3 = objc_claimAutoreleasedReturnValue();
  v4 = (void *)_featureCropOrientationsFromSuperpositionOfFeatureWithImageOrientations(void)::featureCropOrientationsFromSuperpositionOfFeatureWithImageOrientations;
  _featureCropOrientationsFromSuperpositionOfFeatureWithImageOrientations(void)::featureCropOrientationsFromSuperpositionOfFeatureWithImageOrientations = v3;

}

void sub_1A15A5DBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14)
{
  void *v14;
  void *v15;
  void *v16;
  void *v17;

  v17 = v15;

  _Unwind_Resume(a1);
}

void sub_1A15A5EDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{

  _Unwind_Resume(a1);
}

void sub_1A15A5F54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1A15A5FE0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1A15A60B4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1A15A6240(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

id VNRequestRevisionString(objc_class *a1, unint64_t a2)
{
  Class v3;
  objc_class *v4;
  void *v5;
  id v6;
  void *v7;

  v3 = VNRequestClassFromClientSubclass(a1);
  v4 = v3;
  if (a2 < 0xDECAF000
    || (-[objc_class descriptionForPrivateRevision:](v3, "descriptionForPrivateRevision:", a2),
        (v5 = (void *)objc_claimAutoreleasedReturnValue()) == 0))
  {
    v6 = objc_alloc(MEMORY[0x1E0CB3940]);
    NSStringFromClass(v4);
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    v5 = (void *)objc_msgSend(v6, "initWithFormat:", CFSTR("%@Revision%lu"), v7, a2);

  }
  return v5;
}

void sub_1A15A6308(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

NSUInteger VNElementTypeSize(VNElementType elementType)
{
  if (elementType == VNElementTypeFloat)
    return 4;
  else
    return 8 * (elementType == VNElementTypeDouble);
}

id VNBinModelFilePathFromModelNameAndThrow(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  uint64_t v5;
  id v6;

  v1 = a1;
  VNFrameworkBundle();
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "pathForResource:ofType:", v1, CFSTR("bin"));
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v3)
  {
    v5 = objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("Model file %@.bin is missing"), v1);
    objc_msgSend(MEMORY[0x1E0C99DA0], "exceptionWithName:reason:userInfo:", CFSTR("Loading Resource Error"), v5, 0);
    v6 = (id)objc_claimAutoreleasedReturnValue();
    objc_exception_throw(v6);
  }

  return v3;
}

void sub_1A15A63E4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t VNExecuteBlockWithPixelBuffer(__CVBuffer *a1, CVPixelBufferLockFlags a2, void *a3, _QWORD *a4)
{
  id v7;
  void *v8;
  unsigned int v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD v13[4];
  id v14;
  __CVBuffer *v15;

  v7 = a3;
  if (+[VNCVPixelBufferHelper lockPixelBuffer:lockFlags:error:]((uint64_t)VNCVPixelBufferHelper, a1, a2, a4))
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __VNExecuteBlockWithPixelBuffer_block_invoke;
    v13[3] = &unk_1E4548F28;
    v14 = v7;
    v15 = a1;
    v8 = _Block_copy(v13);
    v9 = VNExecuteBlock(v8, (uint64_t)a4);
    if (v9)
      v10 = a4;
    else
      v10 = 0;
    v11 = +[VNCVPixelBufferHelper unlockPixelBuffer:lockFlags:error:]((uint64_t)VNCVPixelBufferHelper, a1, a2, v10) & v9;

  }
  else
  {
    v11 = 0;
  }

  return v11;
}

void sub_1A15A64F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  void *v13;
  void *v14;

  _Unwind_Resume(a1);
}

id VNFloat32DataForFloat16Data(void *a1, _QWORD *a2)
{
  id v3;
  size_t v4;
  vImagePixelCount v5;
  id v6;
  vImage_Error v7;
  void *v8;
  vImage_Buffer v10;
  vImage_Buffer src;

  v3 = a1;
  v4 = objc_msgSend(v3, "length");
  if ((v4 & 1) != 0)
  {
    if (a2)
    {
      +[VNError errorForInvalidArgumentWithLocalizedDescription:](VNError, "errorForInvalidArgumentWithLocalizedDescription:", CFSTR("float16 data was not a length multiple of 2"));
      v8 = 0;
      *a2 = (id)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      v8 = 0;
    }
  }
  else
  {
    v5 = v4 >> 1;
    src.data = (void *)objc_msgSend(objc_retainAutorelease(v3), "bytes");
    src.height = 1;
    src.width = v4 >> 1;
    src.rowBytes = v4;
    v6 = objc_retainAutorelease((id)objc_msgSend(objc_alloc(MEMORY[0x1E0C99DF0]), "initWithLength:", 4 * (v4 >> 1)));
    v10.data = (void *)objc_msgSend(v6, "mutableBytes");
    v10.height = 1;
    v10.width = v5;
    v10.rowBytes = 4 * v5;
    v7 = vImageConvert_Planar16FtoPlanarF(&src, &v10, 0);
    if (v7)
    {
      if (a2)
      {
        +[VNError errorForVImageError:localizedDescription:](VNError, "errorForVImageError:localizedDescription:", v7, 0);
        v8 = 0;
        *a2 = (id)objc_claimAutoreleasedReturnValue();
      }
      else
      {
        v8 = 0;
      }
    }
    else
    {
      v8 = (void *)objc_msgSend(v6, "copy");
    }

  }
  return v8;
}

void sub_1A15A6654(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id VNFloat16DataForFloat32Data(void *a1, _QWORD *a2)
{
  id v3;
  size_t v4;
  void *v5;
  vImagePixelCount v6;
  id v7;
  vImage_Error v8;
  vImage_Buffer v10;
  vImage_Buffer src;

  v3 = a1;
  v4 = objc_msgSend(v3, "length");
  if ((v4 & 3) != 0)
  {
    if (a2)
    {
      +[VNError errorForInvalidArgumentWithLocalizedDescription:](VNError, "errorForInvalidArgumentWithLocalizedDescription:", CFSTR("float32 data was not a length multiple of 4"));
      v5 = 0;
      *a2 = (id)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      v5 = 0;
    }
  }
  else
  {
    v6 = v4 >> 2;
    src.data = (void *)objc_msgSend(objc_retainAutorelease(v3), "bytes");
    src.height = 1;
    src.width = v4 >> 2;
    src.rowBytes = v4;
    v7 = objc_retainAutorelease((id)objc_msgSend(objc_alloc(MEMORY[0x1E0C99DF0]), "initWithLength:", 2 * (v4 >> 2)));
    v10.data = (void *)objc_msgSend(v7, "mutableBytes");
    v10.height = 1;
    v10.width = v6;
    v10.rowBytes = 2 * v6;
    v8 = vImageConvert_PlanarFtoPlanar16F(&src, &v10, 0);
    if (v8)
    {
      if (a2)
      {
        +[VNError errorForVImageError:localizedDescription:](VNError, "errorForVImageError:localizedDescription:", v8, 0);
        v5 = 0;
        *a2 = (id)objc_claimAutoreleasedReturnValue();
      }
      else
      {
        v5 = 0;
      }
    }
    else
    {
      v5 = (void *)objc_msgSend(v7, "copy");
    }

  }
  return v5;
}

void sub_1A15A67A8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

CFTypeRef VNDebugColorFromValues(const CGFloat *a1)
{
  CGColorSpace *v2;
  CGColorRef v3;

  v2 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9DA10]);
  v3 = CGColorCreate(v2, a1);
  CGColorSpaceRelease(v2);
  return CFAutorelease(v3);
}

CFTypeRef VNDebugContrastOutlineColor()
{
  _OWORD v1[2];
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  v1[0] = xmmword_1A15FAF20;
  v1[1] = unk_1A15FAF30;
  return VNDebugColorFromValues((const CGFloat *)v1);
}

CFTypeRef VNDebugPathColor()
{
  _OWORD v1[2];
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  v1[0] = xmmword_1A15FAF40;
  v1[1] = unk_1A15FAF50;
  return VNDebugColorFromValues((const CGFloat *)v1);
}

CFTypeRef VNDebugQuadColor()
{
  _OWORD v1[2];
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  v1[0] = xmmword_1A15FAF60;
  v1[1] = unk_1A15FAF70;
  return VNDebugColorFromValues((const CGFloat *)v1);
}

CFTypeRef VNDebugBoundingBoxColor()
{
  _OWORD v1[2];
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  v1[0] = xmmword_1A15FAF80;
  v1[1] = unk_1A15FAF90;
  return VNDebugColorFromValues((const CGFloat *)v1);
}

CFTypeRef VNDebugFeatureColor()
{
  _OWORD v1[2];
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  v1[0] = xmmword_1A15FAFA0;
  v1[1] = unk_1A15FAFB0;
  return VNDebugColorFromValues((const CGFloat *)v1);
}

uint64_t VNDebugColorFromCGColor(CGColor *a1)
{
  Class v2;
  SEL v3;

  v2 = NSClassFromString(CFSTR("NSColor"));
  v3 = NSSelectorFromString(CFSTR("colorWithCGColor:"));
  return ((uint64_t (*)(Class, SEL, CGColor *))-[objc_class methodForSelector:](v2, "methodForSelector:", v3))(v2, v3, a1);
}

uint64_t VNGetRequestConcurrentTasksProcessingPolicyLimits(_QWORD *a1, _QWORD *a2, _QWORD *a3, uint64_t *a4)
{
  uint64_t result;

  if (!a1 || !a2 || !a3 || !a4)
    return +[VNError VNAssert:log:](VNError, "VNAssert:log:", 0, CFSTR("One of the output parameters is null"));
  *a1 = +[VNRequestPerformingPriorityGroup1AsyncTasksQueueCache maximumAllowedTasksInTheQueue](VNRequestPerformingPriorityGroup1AsyncTasksQueueCache, "maximumAllowedTasksInTheQueue");
  *a2 = +[VNRequestPerformingPriorityGroup2AsyncTasksQueueCache maximumAllowedTasksInTheQueue](VNRequestPerformingPriorityGroup2AsyncTasksQueueCache, "maximumAllowedTasksInTheQueue");
  *a3 = +[VNRequestAsyncTasksQueueCache maximumAllowedTasksInTheQueue](VNRequestAsyncTasksQueueCache, "maximumAllowedTasksInTheQueue");
  result = +[VNDetectorAsyncTasksQueueCache maximumAllowedTasksInTheQueue](VNDetectorAsyncTasksQueueCache, "maximumAllowedTasksInTheQueue");
  *a4 = result;
  return result;
}

uint64_t VNUpgradeFaceprint(void *a1, void *a2, void *a3, _QWORD *a4, _DWORD *a5, _QWORD *a6)
{
  id v11;
  id v12;
  id v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  int v20;
  uint64_t v21;
  id v22;
  _QWORD v24[3];
  _QWORD v25[4];

  v25[3] = *MEMORY[0x1E0C80C00];
  v11 = a1;
  v12 = a2;
  v13 = a3;
  if (a4)
  {
    if (a5)
    {
      if (__VNUpgradeFaceprint_block_invoke(v11, CFSTR("previousFaceprint"), a6)
        && __VNUpgradeFaceprint_block_invoke(v12, CFSTR("newLowResolutionFaceprint"), a6)
        && __VNUpgradeFaceprint_block_invoke(v13, CFSTR("session"), a6))
      {
        v25[0] = v13;
        v24[0] = CFSTR("VNDetectorProcessOption_Session");
        v24[1] = CFSTR("VNEspressoprintUpgradeDetectorProcessOption_EspressoprintClass");
        v24[2] = CFSTR("VNDetectorOption_ComputeStageDeviceAssignments");
        v25[1] = objc_opt_class();
        v25[2] = MEMORY[0x1E0C9AA70];
        objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v25, v24, 3);
        v14 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v13, "detectorOfType:configuredWithOptions:error:", CFSTR("VNEspressoprintUpgradeDetectorType"), v14, a6);
        v15 = (void *)objc_claimAutoreleasedReturnValue();
        if (!v15)
        {
          v21 = 0;
LABEL_22:

          goto LABEL_16;
        }
        v16 = (void *)objc_msgSend(v14, "mutableCopy");
        objc_msgSend(v16, "setObject:forKeyedSubscript:", v11, CFSTR("VNEspressoprintUpgradeDetectorProcessOption_FromEspressoprint"));
        objc_msgSend(v16, "setObject:forKeyedSubscript:", v12, CFSTR("VNEspressoprintUpgradeDetectorProcessOption_ToEspressoprint"));
        objc_msgSend(v15, "processUsingQualityOfServiceClass:options:regionOfInterest:warningRecorder:error:progressHandler:", qos_class_self(), v16, 0, a6, 0, *MEMORY[0x1E0C9D628], *(double *)(MEMORY[0x1E0C9D628] + 8), *(double *)(MEMORY[0x1E0C9D628] + 16), *(double *)(MEMORY[0x1E0C9D628] + 24));
        v17 = (void *)objc_claimAutoreleasedReturnValue();
        v18 = v17;
        if (v17)
        {
          if (objc_msgSend(v17, "count") == 2)
          {
            objc_msgSend(v18, "objectAtIndex:", 0);
            *a4 = (id)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v18, "objectAtIndex:", 1);
            v19 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v19, "floatValue");
            *a5 = v20;

            v21 = 1;
LABEL_21:

            goto LABEL_22;
          }
          if (a6)
          {
            +[VNError errorForInternalErrorWithLocalizedDescription:](VNError, "errorForInternalErrorWithLocalizedDescription:", CFSTR("Unexpected number of faceprints returned"));
            v21 = 0;
            *a6 = (id)objc_claimAutoreleasedReturnValue();
            goto LABEL_21;
          }
        }
        v21 = 0;
        goto LABEL_21;
      }
      goto LABEL_15;
    }
    if (a6)
    {
      +[VNError errorForInvalidArgument:named:](VNError, "errorForInvalidArgument:named:", 0, CFSTR("sigmaOut"));
      v22 = (id)objc_claimAutoreleasedReturnValue();
      goto LABEL_14;
    }
LABEL_15:
    v21 = 0;
    goto LABEL_16;
  }
  if (!a6)
    goto LABEL_15;
  +[VNError errorForInvalidArgument:named:](VNError, "errorForInvalidArgument:named:", 0, CFSTR("newHighResolutionFaceprintOut"));
  v22 = (id)objc_claimAutoreleasedReturnValue();
LABEL_14:
  v21 = 0;
  *a6 = v22;
LABEL_16:

  return v21;
}

void sub_1A15A6DC4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;

  _Unwind_Resume(a1);
}

void sub_1A15A6EA0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t VNUpgradeTorsoprint(void *a1, void *a2, void *a3, _QWORD *a4, _DWORD *a5, _QWORD *a6)
{
  id v11;
  id v12;
  id v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  int v20;
  uint64_t v21;
  id v22;
  _QWORD v24[3];
  _QWORD v25[4];

  v25[3] = *MEMORY[0x1E0C80C00];
  v11 = a1;
  v12 = a2;
  v13 = a3;
  if (a4)
  {
    if (a5)
    {
      if (__VNUpgradeTorsoprint_block_invoke(v11, CFSTR("previousFaceprint"), a6)
        && __VNUpgradeTorsoprint_block_invoke(v12, CFSTR("newLowResolutionFaceprint"), a6)
        && __VNUpgradeTorsoprint_block_invoke(v13, CFSTR("session"), a6))
      {
        v25[0] = v13;
        v24[0] = CFSTR("VNDetectorProcessOption_Session");
        v24[1] = CFSTR("VNEspressoprintUpgradeDetectorProcessOption_EspressoprintClass");
        v24[2] = CFSTR("VNDetectorOption_ComputeStageDeviceAssignments");
        v25[1] = objc_opt_class();
        v25[2] = MEMORY[0x1E0C9AA70];
        objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v25, v24, 3);
        v14 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v13, "detectorOfType:configuredWithOptions:error:", CFSTR("VNEspressoprintUpgradeDetectorType"), v14, a6);
        v15 = (void *)objc_claimAutoreleasedReturnValue();
        if (!v15)
        {
          v21 = 0;
LABEL_22:

          goto LABEL_16;
        }
        v16 = (void *)objc_msgSend(v14, "mutableCopy");
        objc_msgSend(v16, "setObject:forKeyedSubscript:", v11, CFSTR("VNEspressoprintUpgradeDetectorProcessOption_FromEspressoprint"));
        objc_msgSend(v16, "setObject:forKeyedSubscript:", v12, CFSTR("VNEspressoprintUpgradeDetectorProcessOption_ToEspressoprint"));
        objc_msgSend(v15, "processUsingQualityOfServiceClass:options:regionOfInterest:warningRecorder:error:progressHandler:", qos_class_self(), v16, 0, a6, 0, *MEMORY[0x1E0C9D628], *(double *)(MEMORY[0x1E0C9D628] + 8), *(double *)(MEMORY[0x1E0C9D628] + 16), *(double *)(MEMORY[0x1E0C9D628] + 24));
        v17 = (void *)objc_claimAutoreleasedReturnValue();
        v18 = v17;
        if (v17)
        {
          if (objc_msgSend(v17, "count") == 2)
          {
            objc_msgSend(v18, "objectAtIndex:", 0);
            *a4 = (id)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v18, "objectAtIndex:", 1);
            v19 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v19, "floatValue");
            *a5 = v20;

            v21 = 1;
LABEL_21:

            goto LABEL_22;
          }
          if (a6)
          {
            +[VNError errorForInternalErrorWithLocalizedDescription:](VNError, "errorForInternalErrorWithLocalizedDescription:", CFSTR("Unexpected number of faceprints returned"));
            v21 = 0;
            *a6 = (id)objc_claimAutoreleasedReturnValue();
            goto LABEL_21;
          }
        }
        v21 = 0;
        goto LABEL_21;
      }
      goto LABEL_15;
    }
    if (a6)
    {
      +[VNError errorForInvalidArgument:named:](VNError, "errorForInvalidArgument:named:", 0, CFSTR("sigmaOut"));
      v22 = (id)objc_claimAutoreleasedReturnValue();
      goto LABEL_14;
    }
LABEL_15:
    v21 = 0;
    goto LABEL_16;
  }
  if (!a6)
    goto LABEL_15;
  +[VNError errorForInvalidArgument:named:](VNError, "errorForInvalidArgument:named:", 0, CFSTR("newHighResolutionFaceprintOut"));
  v22 = (id)objc_claimAutoreleasedReturnValue();
LABEL_14:
  v21 = 0;
  *a6 = v22;
LABEL_16:

  return v21;
}

void sub_1A15A718C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;

  _Unwind_Resume(a1);
}

void sub_1A15A7268(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void VNGetRequestConcurrentTasksProcessingPolicy(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  void *v8;
  void *v9;
  void *v10;
  id v11;

  if (a1 && a2 && a3 && a4)
  {
    +[VNRequestPerformingPriorityGroup1AsyncTasksQueueCache sharedCache](VNRequestPerformingPriorityGroup1AsyncTasksQueueCache, "sharedCache");
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    *a1 = objc_msgSend(v8, "maximumTasksCount");
    +[VNRequestPerformingPriorityGroup2AsyncTasksQueueCache sharedCache](VNRequestPerformingPriorityGroup2AsyncTasksQueueCache, "sharedCache");
    v9 = (void *)objc_claimAutoreleasedReturnValue();

    *a2 = objc_msgSend(v9, "maximumTasksCount");
    +[VNRequestAsyncTasksQueueCache sharedCache](VNRequestAsyncTasksQueueCache, "sharedCache");
    v10 = (void *)objc_claimAutoreleasedReturnValue();

    *a3 = objc_msgSend(v10, "maximumTasksCount");
    +[VNDetectorAsyncTasksQueueCache sharedCache](VNDetectorAsyncTasksQueueCache, "sharedCache");
    v11 = (id)objc_claimAutoreleasedReturnValue();

    *a4 = objc_msgSend(v11, "maximumTasksCount");
  }
  else
  {
    +[VNError VNAssert:log:](VNError, "VNAssert:log:", 0, CFSTR("One of the output parameters is null"));
  }
}

void sub_1A15A73A0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void VNSetRequestConcurrentTasksProcessingPolicy(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void *v8;
  void *v9;
  void *v10;
  id v11;

  +[VNRequestPerformingPriorityGroup1AsyncTasksQueueCache sharedCache](VNRequestPerformingPriorityGroup1AsyncTasksQueueCache, "sharedCache");
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v8, "setMaximumTasksCount:", a1);
  +[VNRequestPerformingPriorityGroup2AsyncTasksQueueCache sharedCache](VNRequestPerformingPriorityGroup2AsyncTasksQueueCache, "sharedCache");
  v9 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v9, "setMaximumTasksCount:", a2);
  +[VNRequestAsyncTasksQueueCache sharedCache](VNRequestAsyncTasksQueueCache, "sharedCache");
  v10 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v10, "setMaximumTasksCount:", a3);
  +[VNDetectorAsyncTasksQueueCache sharedCache](VNDetectorAsyncTasksQueueCache, "sharedCache");
  v11 = (id)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v11, "setMaximumTasksCount:", a4);
}

void sub_1A15A749C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL VNCheckRatioMismatch(double a1, double a2, double a3, double a4)
{
  double v4;
  double v5;

  v4 = a1 / a2;
  v5 = a3 / a4;
  if (v4 < 1.0 && v5 >= 1.0)
    return 1;
  if (v5 < 1.0)
    return v4 >= 1.0;
  return 0;
}

int64_t VNGetRequestConcurrentTasksProcessingTimeout()
{
  return +[VNControlledCapacityTasksQueue tasksTimeout](VNControlledCapacityTasksQueue, "tasksTimeout");
}

uint64_t VNDebugImageFromCGImage(uint64_t a1)
{
  Class v2;
  SEL v3;

  if (load_uikit(void)::once != -1)
    dispatch_once(&load_uikit(void)::once, &__block_literal_global_174);
  v2 = NSClassFromString(CFSTR("UIImage"));
  v3 = NSSelectorFromString(CFSTR("imageWithCGImage:"));
  return ((uint64_t (*)(Class, SEL, uint64_t))-[objc_class methodForSelector:](v2, "methodForSelector:", v3))(v2, v3, a1);
}

double VNDebugFallbackSizeWhenImagesizeIsUnknown()
{
  return 512.0;
}

id VNDebugPathFromNormalizedCGPath(uint64_t a1, CGFloat a2, CGFloat a3)
{
  const CGPath *v4;
  Class v5;
  SEL v6;
  id v7;
  CGAffineTransform v9;

  memset(&v9, 0, sizeof(v9));
  CGAffineTransformMakeScale(&v9, a2, a3);
  v4 = (const CGPath *)MEMORY[0x1A1B09D7C](a1, &v9);
  if (load_uikit(void)::once != -1)
    dispatch_once(&load_uikit(void)::once, &__block_literal_global_174);
  v5 = NSClassFromString(CFSTR("UIBezierPath"));
  v6 = NSSelectorFromString(CFSTR("bezierPathWithCGPath:"));
  v7 = (id)((uint64_t (*)(Class, SEL, const CGPath *))-[objc_class methodForSelector:](v5, "methodForSelector:", v6))(v5, v6, v4);
  CGPathRelease(v4);
  return v7;
}

void sub_1A15A7678(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

double VNDebugImageSizeFromObject(void *a1)
{
  id v1;
  double v2;
  double v3;
  double v4;

  v1 = a1;
  if (load_uikit(void)::once != -1)
    dispatch_once(&load_uikit(void)::once, &__block_literal_global_174);
  NSClassFromString(CFSTR("UIImage"));
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_msgSend(v1, "size");
    v3 = v2;
  }
  else
  {
    NSClassFromString(CFSTR("UIBezierPath"));
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      objc_msgSend(v1, "bounds");
      v3 = v4;
    }
    else
    {
      v3 = *MEMORY[0x1E0C9D820];
    }
  }

  return v3;
}

void sub_1A15A7750(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void (*VNDebugImageRenderNormalizedCGPathOnImage(uint64_t a1, void *a2, CGColor *a3))(uint64_t)
{
  id v5;
  void *v6;
  void *v7;
  void (*v8)(uint64_t);
  void (*v9)(uint64_t);
  void (*v10)(void);
  uint64_t v11;
  double v12;
  CGFloat v13;
  double v14;
  CGFloat v15;
  void *v16;
  void *v17;
  CGColor *v18;
  void *v19;
  void *v20;
  int v21;
  CGAffineTransform v23;
  CGAffineTransform v24;
  CGAffineTransform v25;
  CGAffineTransform v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  v6 = (void *)MEMORY[0x1A1B0B060]();
  if (load_uikit(void)::once != -1)
    dispatch_once(&load_uikit(void)::once, &__block_literal_global_174);
  v7 = (void *)load_uikit(void)::uikitHandle;
  v8 = (void (*)(uint64_t))dlsym((void *)load_uikit(void)::uikitHandle, "UIGraphicsBeginImageContext");
  dlsym(v7, "UIGraphicsGetCurrentContext");
  v9 = (void (*)(uint64_t))dlsym(v7, "UIGraphicsGetImageFromCurrentImageContext");
  v10 = (void (*)(void))dlsym(v7, "UIGraphicsEndImageContext");
  NSClassFromString(CFSTR("UIImage"));
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v11 = objc_msgSend(v5, "size");
    v13 = v12;
    v15 = v14;
    v8(v11);
    objc_msgSend(v5, "drawAtPoint:", *MEMORY[0x1E0C9D538], *(double *)(MEMORY[0x1E0C9D538] + 8));
    VNDebugPathFromNormalizedCGPath(a1, v13, v15);
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    memset(&v25, 0, sizeof(v25));
    CGAffineTransformMakeScale(&v25, 1.0, -1.0);
    v24 = v25;
    CGAffineTransformTranslate(&v26, &v24, 0.0, -v15);
    v25 = v26;
    v23 = v26;
    objc_msgSend(v16, "applyTransform:", &v23);
    VNDebugColorFromCGColor(a3);
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_OWORD *)&v26.a = xmmword_1A15FAF20;
    *(_OWORD *)&v26.c = unk_1A15FAF30;
    v18 = (CGColor *)VNDebugColorFromValues(&v26.a);
    VNDebugColorFromCGColor(v18);
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v19, "setStroke");
    objc_msgSend(v16, "setLineWidth:", 3.0);
    objc_msgSend(v16, "stroke");
    objc_msgSend(v17, "setStroke");
    objc_msgSend(v16, "setLineWidth:", 2.0);
    v9(objc_msgSend(v16, "stroke"));
    v9 = (void (*)(uint64_t))objc_claimAutoreleasedReturnValue();
    v10();

LABEL_7:
    v21 = 0;
    goto LABEL_9;
  }
  NSClassFromString(CFSTR("UIBezierPath"));
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v9 = (void (*)(uint64_t))v5;
    VNDebugPathFromNormalizedCGPath(a1, 512.0, 512.0);
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v9, "appendPath:", v20);

    goto LABEL_7;
  }
  v21 = 1;
LABEL_9:
  objc_autoreleasePoolPop(v6);
  if (v21)
  {
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("Could not render path on image %@"), v5);
    v9 = (void (*)(uint64_t))objc_claimAutoreleasedReturnValue();
  }

  return v9;
}

void sub_1A15A7A3C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

__CFString *VNANEArchitectureSubTypeVariantName()
{
  void *v0;
  __CFString *v1;

  if (VNHasANE::once_token != -1)
    dispatch_once(&VNHasANE::once_token, &__block_literal_global_31404);
  if (VNHasANE::hasANESupport)
  {
    objc_msgSend(get_ANEDeviceInfoClass(), "aneSubTypeVariant");
    v0 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v0, "uppercaseString");
    v1 = (__CFString *)objc_claimAutoreleasedReturnValue();

  }
  else
  {
    v1 = &stru_1E4549388;
  }
  return v1;
}

void sub_1A15A7B38(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

__CFString *VNANEArchitectureSubTypeProductVariantName()
{
  void *v0;
  __CFString *v1;

  if (VNHasANE::once_token != -1)
    dispatch_once(&VNHasANE::once_token, &__block_literal_global_31404);
  if (VNHasANE::hasANESupport)
  {
    objc_msgSend(get_ANEDeviceInfoClass(), "aneSubTypeProductVariant");
    v0 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v0, "uppercaseString");
    v1 = (__CFString *)objc_claimAutoreleasedReturnValue();

  }
  else
  {
    v1 = &stru_1E4549388;
  }
  return v1;
}

void sub_1A15A7BC4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id VNANEGenerationNumberForArchitectureName(uint64_t a1, uint64_t a2)
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = __VNANEGenerationNumberForArchitectureName_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = a2;
  if (VNANEGenerationNumberForArchitectureName::onceToken != -1)
    dispatch_once(&VNANEGenerationNumberForArchitectureName::onceToken, block);
  return (id)VNANEGenerationNumberForArchitectureName::aneGenerationNumber;
}

void sub_1A15A7D40(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

